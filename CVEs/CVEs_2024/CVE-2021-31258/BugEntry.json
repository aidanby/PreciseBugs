{"buggy_code": ["/*\n *\t\t\tGPAC - Multimedia Framework C SDK\n *\n *\t\t\tAuthors: Jean Le Feuvre\n *\t\t\tCopyright (c) Telecom ParisTech 2000-2021\n *\t\t\t\t\tAll rights reserved\n *\n *  This file is part of GPAC / ISO Media File Format sub-project\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n\n#include <gpac/internal/isomedia_dev.h>\n#include <gpac/constants.h>\n\n#ifndef GPAC_DISABLE_ISOM\n\n//the only static var. Used to store any error happening while opening a movie\nstatic GF_Err MP4_API_IO_Err;\n\nvoid gf_isom_set_last_error(GF_ISOFile *movie, GF_Err error)\n{\n\tif (!movie) {\n\t\tMP4_API_IO_Err = error;\n\t} else {\n\t\tmovie->LastError = error;\n\t}\n}\n\n\nGF_EXPORT\nGF_Err gf_isom_last_error(GF_ISOFile *the_file)\n{\n\tif (!the_file) return MP4_API_IO_Err;\n\treturn the_file->LastError;\n}\n\nGF_EXPORT\nu8 gf_isom_get_mode(GF_ISOFile *the_file)\n{\n\tif (!the_file) return 0;\n\treturn the_file->openMode;\n}\n\n#if 0 //unused\n/*! gets file size of an ISO file\n\\param isom_file the target ISO file\n\\return the file size in bytes\n*/\nu64 gf_isom_get_file_size(GF_ISOFile *the_file)\n{\n\tif (!the_file) return 0;\n\tif (the_file->movieFileMap) return gf_bs_get_size(the_file->movieFileMap->bs);\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\tif (the_file->editFileMap) return gf_bs_get_size(the_file->editFileMap->bs);\n#endif\n\treturn 0;\n}\n#endif\n\nGF_EXPORT\nGF_Err gf_isom_freeze_order(GF_ISOFile *file)\n{\n\tu32 i=0;\n\tGF_Box *box;\n\tif (!file) return GF_BAD_PARAM;\n\twhile ((box=gf_list_enum(file->TopBoxes, &i))) {\n\t\tgf_isom_box_freeze_order(box);\n\t}\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_inplace_padding(GF_ISOFile *file, u32 padding)\n{\n\tif (!file) return GF_BAD_PARAM;\n\tfile->padding = padding;\n\treturn GF_OK;\n}\n/**************************************************************\n\t\t\t\t\tSample Manip\n**************************************************************/\n\n//creates a new empty sample\nGF_EXPORT\nGF_ISOSample *gf_isom_sample_new()\n{\n\tGF_ISOSample *tmp;\n\tGF_SAFEALLOC(tmp, GF_ISOSample);\n\treturn tmp;\n}\n\n//delete a sample\nGF_EXPORT\nvoid gf_isom_sample_del(GF_ISOSample **samp)\n{\n\tif (!samp || ! *samp) return;\n\tif ((*samp)->data && (*samp)->dataLength) gf_free((*samp)->data);\n\tgf_free(*samp);\n\t*samp = NULL;\n}\n\nstatic u32 gf_isom_probe_type(u32 type)\n{\n\tswitch (type) {\n\tcase GF_ISOM_BOX_TYPE_FTYP:\n\tcase GF_ISOM_BOX_TYPE_MOOV:\n\t\treturn 2;\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tcase GF_ISOM_BOX_TYPE_MOOF:\n\tcase GF_ISOM_BOX_TYPE_STYP:\n\tcase GF_ISOM_BOX_TYPE_SIDX:\n\tcase GF_ISOM_BOX_TYPE_EMSG:\n\tcase GF_ISOM_BOX_TYPE_PRFT:\n    //we map free as segment when it is first in the file - a regular file shall start with ftyp or a file sig, not free\n    //since our route stack may patch boxes to free for incomplete segments, we must map this to free\n    case GF_ISOM_BOX_TYPE_FREE:\n\t\treturn 3;\n#ifndef GPAC_DISABLE_ISOM_ADOBE\n\t/*Adobe specific*/\n\tcase GF_ISOM_BOX_TYPE_AFRA:\n\tcase GF_ISOM_BOX_TYPE_ABST:\n#endif\n#endif\n\tcase GF_ISOM_BOX_TYPE_MDAT:\n\tcase GF_ISOM_BOX_TYPE_SKIP:\n\tcase GF_ISOM_BOX_TYPE_UDTA:\n\tcase GF_ISOM_BOX_TYPE_META:\n\tcase GF_ISOM_BOX_TYPE_VOID:\n\tcase GF_ISOM_BOX_TYPE_JP:\n\tcase GF_QT_BOX_TYPE_WIDE:\n\t\treturn 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nGF_EXPORT\nu32 gf_isom_probe_file_range(const char *fileName, u64 start_range, u64 end_range)\n{\n\tu32 type = 0;\n\n\tif (!strncmp(fileName, \"gmem://\", 7)) {\n\t\tu32 size;\n\t\tu8 *mem_address;\n\t\tif (gf_blob_get(fileName, &mem_address, &size, NULL) != GF_OK) {\n\t\t\treturn 0;\n\t\t}\n        if (size && (size > start_range + 8)) {\n\t\t\ttype = GF_4CC(mem_address[start_range + 4], mem_address[start_range + 5], mem_address[start_range + 6], mem_address[start_range + 7]);\n        }\n        gf_blob_release(fileName);\n\t} else if (!strncmp(fileName, \"isobmff://\", 10)) {\n\t\treturn 2;\n\t} else {\n\t\tu32 nb_read;\n\t\tunsigned char data[4];\n\t\tFILE *f = gf_fopen(fileName, \"rb\");\n\t\tif (!f) return 0;\n\t\tif (start_range) gf_fseek(f, start_range, SEEK_SET);\n\t\ttype = 0;\n\t\tnb_read = (u32) gf_fread(data, 4, f);\n\t\tif (nb_read == 4) {\n\t\t\tif (gf_fread(data, 4, f) == 4) {\n\t\t\t\ttype = GF_4CC(data[0], data[1], data[2], data[3]);\n\t\t\t}\n\t\t}\n\t\tgf_fclose(f);\n\t\tif (!nb_read) return 0;\n\t}\n\treturn gf_isom_probe_type(type);\n}\n\nGF_EXPORT\nu32 gf_isom_probe_file(const char *fileName)\n{\n\treturn gf_isom_probe_file_range(fileName, 0, 0);\n}\n\nGF_EXPORT\nu32 gf_isom_probe_data(const u8*inBuf, u32 inSize)\n{\n\tu32 type;\n\tif (inSize < 8) return 0;\n\ttype = GF_4CC(inBuf[4], inBuf[5], inBuf[6], inBuf[7]);\n\treturn gf_isom_probe_type(type);\n}\n\n\n#ifndef GPAC_DISABLE_AV_PARSERS\n#include <gpac/internal/media_dev.h>\n#endif\n\nstatic GF_Err isom_create_init_from_mem(const char *fileName, GF_ISOFile *file)\n{\n\tu32 sample_rate=0;\n\tu32 nb_channels=0;\n\tu32 bps=0;\n\t//u32 atag=0;\n\tu32 nal_len=4;\n\tu32 width = 0;\n\tu32 height = 0;\n\tu32 timescale = 10000000;\n\tu64 tfdt = 0;\n\tchar sz4cc[5];\n\tchar CodecParams[2048];\n\tu32 CodecParamLen=0;\n\tchar *sep, *val;\n\tGF_TrackBox *trak;\n\tGF_TrackExtendsBox *trex;\n\tGF_SampleTableBox *stbl;\n\n\tsz4cc[0] = 0;\n\n\tval = (char*) ( fileName + strlen(\"isobmff://\") );\n\twhile (1)  {\n\t\tsep = strchr(val, ' ');\n\t\tif (sep) sep[0] = 0;\n\n\t\tif (!strncmp(val, \"4cc=\", 4)) strcpy(sz4cc, val+4);\n\t\telse if (!strncmp(val, \"init=\", 5)) {\n\t\t\tchar szH[3], *data = val+5;\n\t\t\tu32 i, len = (u32) strlen(data);\n\t\t\tfor (i=0; i<len; i+=2) {\n\t\t\t\tu32 v;\n\t\t\t\t//init is hex-encoded so 2 input bytes for one output char\n\t\t\t\tszH[0] = data[i];\n\t\t\t\tszH[1] = data[i+1];\n\t\t\t\tszH[2] = 0;\n\t\t\t\tsscanf(szH, \"%X\", &v);\n\t\t\t\tCodecParams[CodecParamLen] = (char) v;\n\t\t\t\tCodecParamLen++;\n\t\t\t}\n\t\t}\n\t\telse if (!strncmp(val, \"nal=\", 4)) nal_len = atoi(val+4);\n\t\telse if (!strncmp(val, \"bps=\", 4)) bps = atoi(val+4);\n\t\t//else if (!strncmp(val, \"atag=\", 5)) atag = atoi(val+5);\n\t\telse if (!strncmp(val, \"ch=\", 3)) nb_channels = atoi(val+3);\n\t\telse if (!strncmp(val, \"srate=\", 6)) sample_rate = atoi(val+6);\n\t\telse if (!strncmp(val, \"w=\", 2)) width = atoi(val+2);\n\t\telse if (!strncmp(val, \"h=\", 2)) height = atoi(val+2);\n\t\telse if (!strncmp(val, \"scale=\", 6)) timescale = atoi(val+6);\n\t\telse if (!strncmp(val, \"tfdt=\", 5)) {\n\t\t\tsscanf(val+5, LLX, &tfdt);\n\t\t}\n\t\tif (!sep) break;\n\t\tsep[0] = ' ';\n\t\tval = sep+1;\n\t}\n\tif (!stricmp(sz4cc, \"H264\") || !stricmp(sz4cc, \"AVC1\")) {\n\t}\n\telse if (!stricmp(sz4cc, \"AACL\")) {\n\t}\n\telse {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Cannot convert smooth media type %s to ISO init segment\\n\", sz4cc));\n\t\treturn GF_NOT_SUPPORTED;\n\t}\n\n\tfile->moov = (GF_MovieBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_MOOV);\n\tif (!file->moov) return GF_OUT_OF_MEM;\n\tgf_list_add(file->TopBoxes, file->moov);\n\tfile->moov->mov = file;\n\tfile->is_smooth = GF_TRUE;\n\tfile->moov->mvhd = (GF_MovieHeaderBox *) gf_isom_box_new_parent(&file->moov->child_boxes, GF_ISOM_BOX_TYPE_MVHD);\n\tif (!file->moov->mvhd) return GF_OUT_OF_MEM;\n\tfile->moov->mvhd->timeScale = timescale;\n\tfile->moov->mvex = (GF_MovieExtendsBox *) gf_isom_box_new_parent(&file->moov->child_boxes, GF_ISOM_BOX_TYPE_MVEX);\n\tif (!file->moov->mvex) return GF_OUT_OF_MEM;\n\ttrex = (GF_TrackExtendsBox *) gf_isom_box_new_parent(&file->moov->mvex->child_boxes, GF_ISOM_BOX_TYPE_TREX);\n\tif (!trex) return GF_OUT_OF_MEM;\n\n\ttrex->def_sample_desc_index = 1;\n\ttrex->trackID = 1;\n\tgf_list_add(file->moov->mvex->TrackExList, trex);\n\n\ttrak = (GF_TrackBox *) gf_isom_box_new_parent(&file->moov->child_boxes, GF_ISOM_BOX_TYPE_TRAK);\n\tif (!trak) return GF_OUT_OF_MEM;\n\ttrak->moov = file->moov;\n\tgf_list_add(file->moov->trackList, trak);\n\n\ttrak->Header = (GF_TrackHeaderBox *) gf_isom_box_new_parent(&trak->child_boxes, GF_ISOM_BOX_TYPE_TKHD);\n\tif (!trak->Header) return GF_OUT_OF_MEM;\n\ttrak->Header->trackID = 1;\n\ttrak->Header->flags |= 1;\n\ttrak->Header->width = width;\n\ttrak->Header->height = height;\n\n\ttrak->Media = (GF_MediaBox *) gf_isom_box_new_parent(&trak->child_boxes, GF_ISOM_BOX_TYPE_MDIA);\n\tif (!trak->Media) return GF_OUT_OF_MEM;\n\ttrak->Media->mediaTrack = trak;\n\ttrak->Media->mediaHeader = (GF_MediaHeaderBox *) gf_isom_box_new_parent(&trak->Media->child_boxes, GF_ISOM_BOX_TYPE_MDHD);\n\tif (!trak->Media->mediaHeader) return GF_OUT_OF_MEM;\n\ttrak->Media->mediaHeader->timeScale = timescale;\n\n\ttrak->Media->handler = (GF_HandlerBox *) gf_isom_box_new_parent(&trak->Media->child_boxes,GF_ISOM_BOX_TYPE_HDLR);\n\tif (!trak->Media->handler) return GF_OUT_OF_MEM;\n    //we assume by default vide for handler type (only used for smooth streaming)\n\ttrak->Media->handler->handlerType = width ? GF_ISOM_MEDIA_VISUAL : GF_ISOM_MEDIA_AUDIO;\n\n\ttrak->Media->information = (GF_MediaInformationBox *) gf_isom_box_new_parent(&trak->Media->child_boxes, GF_ISOM_BOX_TYPE_MINF);\n\tif (!trak->Media->information) return GF_OUT_OF_MEM;\n\ttrak->Media->information->sampleTable = (GF_SampleTableBox *) gf_isom_box_new_parent(&trak->Media->information->child_boxes, GF_ISOM_BOX_TYPE_STBL);\n\tif (!trak->Media->information->sampleTable) return GF_OUT_OF_MEM;\n\n\tstbl = trak->Media->information->sampleTable;\n\tstbl->SampleSize = (GF_SampleSizeBox *) gf_isom_box_new_parent(&stbl->child_boxes, GF_ISOM_BOX_TYPE_STSZ);\n\tif (!stbl->SampleSize) return GF_OUT_OF_MEM;\n\tstbl->TimeToSample = (GF_TimeToSampleBox *) gf_isom_box_new_parent(&stbl->child_boxes, GF_ISOM_BOX_TYPE_STTS);\n\tif (!stbl->TimeToSample) return GF_OUT_OF_MEM;\n\tstbl->ChunkOffset = (GF_Box *) gf_isom_box_new_parent(&stbl->child_boxes, GF_ISOM_BOX_TYPE_STCO);\n\tif (!stbl->ChunkOffset) return GF_OUT_OF_MEM;\n\tstbl->SampleToChunk = (GF_SampleToChunkBox *) gf_isom_box_new_parent(&stbl->child_boxes, GF_ISOM_BOX_TYPE_STSC);\n\tif (!stbl->SampleToChunk) return GF_OUT_OF_MEM;\n\tstbl->SyncSample = (GF_SyncSampleBox *) gf_isom_box_new_parent(&stbl->child_boxes, GF_ISOM_BOX_TYPE_STSS);\n\tif (!stbl->SyncSample) return GF_OUT_OF_MEM;\n\tstbl->SampleDescription = (GF_SampleDescriptionBox *) gf_isom_box_new_parent(&stbl->child_boxes, GF_ISOM_BOX_TYPE_STSD);\n\tif (!stbl->SampleDescription) return GF_OUT_OF_MEM;\n\n\ttrak->dts_at_seg_start = tfdt;\n\ttrak->dts_at_next_seg_start = tfdt;\n\n\n\tif (!stricmp(sz4cc, \"H264\") || !stricmp(sz4cc, \"AVC1\")) {\n#ifndef GPAC_DISABLE_AV_PARSERS\n\t\tu32 pos = 0;\n\t\tu32 end, sc_size=0;\n#endif\n\t\tGF_MPEGVisualSampleEntryBox *avc =  (GF_MPEGVisualSampleEntryBox *) gf_isom_box_new_parent(&stbl->SampleDescription->child_boxes, GF_ISOM_BOX_TYPE_AVC1);\n\t\tif (!avc) return GF_OUT_OF_MEM;\n\t\tavc->avc_config =  (GF_AVCConfigurationBox *) gf_isom_box_new_parent(&avc->child_boxes, GF_ISOM_BOX_TYPE_AVCC);\n\t\tif (!avc->avc_config) return GF_OUT_OF_MEM;\n\n\t\tavc->Width = width;\n\t\tavc->Height = height;\n\n\t\tavc->avc_config->config = gf_odf_avc_cfg_new();\n\t\tavc->avc_config->config->nal_unit_size = nal_len;\n\t\tavc->avc_config->config->configurationVersion = 1;\n\n#ifndef GPAC_DISABLE_AV_PARSERS\n\t\t//locate pps and sps\n\t\tgf_media_nalu_next_start_code((u8 *) CodecParams, CodecParamLen, &sc_size);\n\t\tpos += sc_size;\n\t\twhile (pos<CodecParamLen) {\n\t\t\tGF_NALUFFParam *slc;\n\t\t\tu8 nal_type;\n\t\t\tchar *nal = &CodecParams[pos];\n\t\t\tend = gf_media_nalu_next_start_code(nal, CodecParamLen-pos, &sc_size);\n\t\t\tif (!end) end = CodecParamLen;\n\n\t\t\tGF_SAFEALLOC(slc, GF_NALUFFParam);\n\t\t\tif (!slc) break;\n\t\t\tslc->size = end;\n\t\t\tslc->data = gf_malloc(sizeof(char)*slc->size);\n\t\t\tif (!slc->data) return GF_OUT_OF_MEM;\n\t\t\tmemcpy(slc->data, nal, sizeof(char)*slc->size);\n\n\t\t\tnal_type = nal[0] & 0x1F;\n\t\t\tif (nal_type == GF_AVC_NALU_SEQ_PARAM) {\n/*\t\t\t\tAVCState avcc;\n\t\t\t\tu32 idx = gf_avc_read_sps(slc->data, slc->size, &avcc, 0, NULL);\n\t\t\t\tavc->avc_config->config->profile_compatibility = avcc.sps[idx].prof_compat;\n\t\t\t\tavc->avc_config->config->AVCProfileIndication = avcc.sps[idx].profile_idc;\n\t\t\t\tavc->avc_config->config->AVCLevelIndication = avcc.sps[idx].level_idc;\n\t\t\t\tavc->avc_config->config->chroma_format = avcc.sps[idx].chroma_format;\n\t\t\t\tavc->avc_config->config->luma_bit_depth = 8 + avcc.sps[idx].luma_bit_depth_m8;\n\t\t\t\tavc->avc_config->config->chroma_bit_depth = 8 + avcc.sps[idx].chroma_bit_depth_m8;\n*/\n\n\t\t\t\tgf_list_add(avc->avc_config->config->sequenceParameterSets, slc);\n\t\t\t} else {\n\t\t\t\tgf_list_add(avc->avc_config->config->pictureParameterSets, slc);\n\t\t\t}\n\t\t\tpos += slc->size + sc_size;\n\t\t}\n#endif\n\n\t\tAVC_RewriteESDescriptor(avc);\n\t}\n\telse if (!stricmp(sz4cc, \"AACL\")) {\n#ifndef GPAC_DISABLE_AV_PARSERS\n\t\tGF_M4ADecSpecInfo aacinfo;\n#endif\n\n\t\tGF_MPEGAudioSampleEntryBox *aac =  (GF_MPEGAudioSampleEntryBox *) gf_isom_box_new_parent(&stbl->SampleDescription->child_boxes, GF_ISOM_BOX_TYPE_MP4A);\n\t\tif (!aac) return GF_OUT_OF_MEM;\n\t\taac->esd = (GF_ESDBox *) gf_isom_box_new_parent(&aac->child_boxes, GF_ISOM_BOX_TYPE_ESDS);\n\t\tif (!aac->esd) return GF_OUT_OF_MEM;\n\t\taac->esd->desc = gf_odf_desc_esd_new(2);\n\t\tif (!aac->esd->desc) return GF_OUT_OF_MEM;\n#ifndef GPAC_DISABLE_AV_PARSERS\n\t\tmemset(&aacinfo, 0, sizeof(GF_M4ADecSpecInfo));\n\t\taacinfo.nb_chan = nb_channels;\n\t\taacinfo.base_object_type = GF_M4A_AAC_LC;\n\t\taacinfo.base_sr = sample_rate;\n\t\tgf_m4a_write_config(&aacinfo, &aac->esd->desc->decoderConfig->decoderSpecificInfo->data, &aac->esd->desc->decoderConfig->decoderSpecificInfo->dataLength);\n#endif\n\t\taac->esd->desc->decoderConfig->streamType = GF_STREAM_AUDIO;\n\t\taac->esd->desc->decoderConfig->objectTypeIndication = GF_CODECID_AAC_MPEG4;\n\t\taac->bitspersample = bps;\n\t\taac->samplerate_hi = sample_rate;\n\t\taac->channel_count = nb_channels;\n\t}\n\n\treturn GF_OK;\n}\n\n/**************************************************************\n\t\t\t\t\tFile Opening in streaming mode\n\t\t\tthe file map is regular (through FILE handles)\n**************************************************************/\nGF_EXPORT\nGF_Err gf_isom_open_progressive_ex(const char *fileName, u64 start_range, u64 end_range, Bool enable_frag_bounds, GF_ISOFile **the_file, u64 *BytesMissing, u32 *outBoxType)\n{\n\tGF_Err e;\n\tGF_ISOFile *movie;\n\n\tif (!BytesMissing || !the_file)\n\t\treturn GF_BAD_PARAM;\n\t*BytesMissing = 0;\n\t*the_file = NULL;\n\n\tmovie = gf_isom_new_movie();\n\tif (!movie) return GF_OUT_OF_MEM;\n\n\tmovie->fileName = gf_strdup(fileName);\n\tmovie->openMode = GF_ISOM_OPEN_READ;\n\tmovie->signal_frag_bounds = enable_frag_bounds;\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\tmovie->editFileMap = NULL;\n\tmovie->finalName = NULL;\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\tif (!strncmp(fileName, \"isobmff://\", 10)) {\n\t\tmovie->movieFileMap = NULL;\n\t\te = isom_create_init_from_mem(fileName, movie);\n\t} else {\n\t\t//do NOT use FileMapping on incomplete files\n\t\te = gf_isom_datamap_new(fileName, NULL, GF_ISOM_DATA_MAP_READ, &movie->movieFileMap);\n\t\tif (e) {\n\t\t\tgf_isom_delete_movie(movie);\n\t\t\treturn e;\n\t\t}\n\n\t\tif (start_range || end_range) {\n\t\t\tif (end_range>start_range) {\n\t\t\t\tgf_bs_seek(movie->movieFileMap->bs, end_range+1);\n\t\t\t\tgf_bs_truncate(movie->movieFileMap->bs);\n\t\t\t}\n\t\t\tgf_bs_seek(movie->movieFileMap->bs, start_range);\n\t\t}\n\t\te = gf_isom_parse_movie_boxes(movie, outBoxType, BytesMissing, GF_TRUE);\n\n\t}\n\tif (e == GF_ISOM_INCOMPLETE_FILE) {\n\t\t//if we have a moov, we're fine\n\t\tif (movie->moov) {\n\t\t\t*the_file = (GF_ISOFile *)movie;\n\t\t\treturn GF_OK;\n\t\t}\n\t\t//if not, delete the movie\n\t\tgf_isom_delete_movie(movie);\n\t\treturn e;\n\t} else if (e) {\n\t\t//if not, delete the movie\n\t\tgf_isom_delete_movie(movie);\n\t\treturn e;\n\t}\n\n\t//OK, let's return\n\t*the_file = (GF_ISOFile *)movie;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_open_progressive(const char *fileName, u64 start_range, u64 end_range, Bool enable_frag_bounds, GF_ISOFile **the_file, u64 *BytesMissing)\n{\n\treturn gf_isom_open_progressive_ex(fileName, start_range, end_range, enable_frag_bounds, the_file, BytesMissing, NULL);\n}\n\n/**************************************************************\n\t\t\t\t\tFile Reading\n**************************************************************/\n\nGF_EXPORT\nGF_ISOFile *gf_isom_open(const char *fileName, GF_ISOOpenMode OpenMode, const char *tmp_dir)\n{\n\tGF_ISOFile *movie;\n\tMP4_API_IO_Err = GF_OK;\n\n\tswitch (OpenMode & 0xFF) {\n\tcase GF_ISOM_OPEN_READ_DUMP:\n\tcase GF_ISOM_OPEN_READ:\n\t\tmovie = gf_isom_open_file(fileName, OpenMode, NULL);\n\t\tbreak;\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\n\tcase GF_ISOM_OPEN_WRITE:\n\t\tmovie = gf_isom_create_movie(fileName, OpenMode, tmp_dir);\n\t\tbreak;\n\tcase GF_ISOM_OPEN_EDIT:\n\tcase GF_ISOM_OPEN_READ_EDIT:\n\tcase GF_ISOM_OPEN_KEEP_FRAGMENTS:\n\t\tmovie = gf_isom_open_file(fileName, OpenMode, tmp_dir);\n\t\tbreak;\n\tcase GF_ISOM_WRITE_EDIT:\n\t\tmovie = gf_isom_create_movie(fileName, OpenMode, tmp_dir);\n\t\tbreak;\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\tdefault:\n\t\treturn NULL;\n\t}\n\treturn (GF_ISOFile *) movie;\n}\n\n\n#if 0\n/*! gets access to the data bitstream  - see \\ref gf_isom_open\n\\param isom_file the target ISO file\n\\param out_bs set to the file input bitstream - do NOT destroy\n\\return error if any\n*/\nGF_Err gf_isom_get_bs(GF_ISOFile *movie, GF_BitStream **out_bs)\n{\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\tif (!movie || movie->openMode != GF_ISOM_OPEN_WRITE || !movie->editFileMap) //memory mode\n\t\treturn GF_NOT_SUPPORTED;\n\n\tif (movie->segment_bs)\n\t\t*out_bs = movie->segment_bs;\n\telse\n\t\t*out_bs = movie->editFileMap->bs;\n\n\tif (movie->moof)\n\t\tmovie->moof->fragment_offset = 0;\n\n\treturn GF_OK;\n#else\n\treturn GF_NOT_SUPPORTED;\n#endif\n}\n#endif\n\n\nGF_EXPORT\nGF_Err gf_isom_write(GF_ISOFile *movie) {\n\tGF_Err e;\n\tif (movie == NULL) return GF_ISOM_INVALID_FILE;\n\te = GF_OK;\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\t//write our movie to the file\n\tif ((movie->openMode != GF_ISOM_OPEN_READ) && (movie->openMode != GF_ISOM_OPEN_READ_EDIT)) {\n\t\tgf_isom_get_duration(movie);\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\t\t//movie fragment mode, just store the fragment\n\t\tif ( (movie->openMode == GF_ISOM_OPEN_WRITE) && (movie->FragmentsFlags & GF_ISOM_FRAG_WRITE_READY) ) {\n\t\t\te = gf_isom_close_fragments(movie);\n\t\t\tif (e) return e;\n\t\t\t//in case of mfra box usage -> create mfro, calculate box sizes and write it out\n\t\t\tif (movie->mfra) {\n\t\t\t\tif (!movie->mfra->mfro) {\n\t\t\t\t\tmovie->mfra->mfro = (GF_MovieFragmentRandomAccessOffsetBox *)gf_isom_box_new_parent(&movie->mfra->child_boxes, GF_ISOM_BOX_TYPE_MFRO);\n\t\t\t\t\tif (!movie->mfra->mfro) return GF_OUT_OF_MEM;\n\t\t\t\t}\n\t\t\t\te = gf_isom_box_size((GF_Box *)movie->mfra);\n\t\t\t\tif (e) return e;\n\t\t\t\tmovie->mfra->mfro->container_size = (u32) movie->mfra->size;\n\n\t\t\t\t//write mfra\n\t\t\t\tif (!strcmp(movie->fileName, \"_gpac_isobmff_redirect\") && movie->on_block_out) {\n\t\t\t\t\tGF_BitStream *bs = gf_bs_new_cbk(movie->on_block_out, movie->on_block_out_usr_data, movie->on_block_out_block_size);\n\n\t\t\t\t\te = gf_isom_box_write((GF_Box *)movie->mfra, bs);\n\t\t\t\t\tgf_bs_del(bs);\n\t\t\t\t} else {\n\t\t\t\t\te = gf_isom_box_write((GF_Box *)movie->mfra, movie->editFileMap->bs);\n\t\t\t\t}\n\t\t\t}\n\t\t} else\n#endif\n\t\t\te = WriteToFile(movie, GF_FALSE);\n\t}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\tif (movie->moov) {\n\t\tu32 i;\n\t\tfor (i=0; i<gf_list_count(movie->moov->trackList); i++) {\n\t\t\tGF_TrackBox *trak = (GF_TrackBox*)gf_list_get(movie->moov->trackList, i);\n\t\t\t/*delete any pending dataHandler of scalable enhancements*/\n\t\t\tif (trak->Media && trak->Media->information && trak->Media->information->scalableDataHandler && (trak->Media->information->scalableDataHandler != movie->movieFileMap))\n\t\t\t\tgf_isom_datamap_del(trak->Media->information->scalableDataHandler);\n\t\t}\n\t}\n#endif\n\n\treturn e;\n}\n\nGF_EXPORT\nGF_Err gf_isom_close(GF_ISOFile *movie)\n{\n\tGF_Err e=GF_OK;\n\tif (movie == NULL) return GF_ISOM_INVALID_FILE;\n\te = gf_isom_write(movie);\n\t//free and return;\n\tgf_isom_delete_movie(movie);\n\treturn e;\n}\n\n\n#if 0 //unused\n/*! checks if files has root OD/IOD or not\n\\param isom_file the target ISO file\n\\return GF_TRUE if the file has a root OD or IOD */\nBool gf_isom_has_root_od(GF_ISOFile *movie)\n{\n\tif (!movie || !movie->moov || !movie->moov->iods || !movie->moov->iods->descriptor) return GF_FALSE;\n\treturn GF_TRUE;\n}\n#endif\n\nGF_EXPORT\nvoid gf_isom_disable_odf_conversion(GF_ISOFile *movie, Bool disable)\n{\n\tif (movie) movie->disable_odf_translate = disable;\n}\n\n//this funct is used for exchange files, where the iods contains an OD\nGF_EXPORT\nGF_Descriptor *gf_isom_get_root_od(GF_ISOFile *movie)\n{\n\tGF_Descriptor *desc;\n\tGF_ObjectDescriptor *od;\n\tGF_InitialObjectDescriptor *iod;\n\tGF_IsomObjectDescriptor *isom_od;\n\tGF_IsomInitialObjectDescriptor *isom_iod;\n\tGF_ESD *esd;\n\tGF_ES_ID_Inc *inc;\n\tu32 i;\n\tu8 useIOD;\n\n\tif (!movie || !movie->moov) return NULL;\n\tif (!movie->moov->iods) return NULL;\n\n\tif (movie->disable_odf_translate) {\n\t\t//duplicate our descriptor\n\t\tmovie->LastError = gf_odf_desc_copy((GF_Descriptor *) movie->moov->iods->descriptor, &desc);\n\t\tif (movie->LastError) return NULL;\n\t\treturn desc;\n\t}\n\tod = NULL;\n\tiod = NULL;\n\n\tswitch (movie->moov->iods->descriptor->tag) {\n\tcase GF_ODF_ISOM_OD_TAG:\n\t\tod = (GF_ObjectDescriptor*)gf_malloc(sizeof(GF_ObjectDescriptor));\n\t\tif (!od) return NULL;\n\n\t\tmemset(od, 0, sizeof(GF_ObjectDescriptor));\n\t\tod->ESDescriptors = gf_list_new();\n\t\tuseIOD = 0;\n\t\tbreak;\n\tcase GF_ODF_ISOM_IOD_TAG:\n\t\tiod = (GF_InitialObjectDescriptor*)gf_malloc(sizeof(GF_InitialObjectDescriptor));\n\t\tif (!iod) return NULL;\n\n\t\tmemset(iod, 0, sizeof(GF_InitialObjectDescriptor));\n\t\tiod->ESDescriptors = gf_list_new();\n\t\tuseIOD = 1;\n\t\tbreak;\n\tdefault:\n\t\treturn NULL;\n\t}\n\n\t//duplicate our descriptor\n\tmovie->LastError = gf_odf_desc_copy((GF_Descriptor *) movie->moov->iods->descriptor, &desc);\n\tif (movie->LastError) return NULL;\n\n\tif (!useIOD) {\n\t\tisom_od = (GF_IsomObjectDescriptor *)desc;\n\t\tod->objectDescriptorID = isom_od->objectDescriptorID;\n\t\tod->extensionDescriptors = isom_od->extensionDescriptors;\n\t\tisom_od->extensionDescriptors = NULL;\n\t\tod->IPMP_Descriptors = isom_od->IPMP_Descriptors;\n\t\tisom_od->IPMP_Descriptors = NULL;\n\t\tod->OCIDescriptors = isom_od->OCIDescriptors;\n\t\tisom_od->OCIDescriptors = NULL;\n\t\tod->URLString = isom_od->URLString;\n\t\tisom_od->URLString = NULL;\n\t\tod->tag = GF_ODF_OD_TAG;\n\t\t//then recreate the desc in Inc\n\t\ti=0;\n\t\twhile ((inc = (GF_ES_ID_Inc*)gf_list_enum(isom_od->ES_ID_IncDescriptors, &i))) {\n\t\t\tmovie->LastError = GetESDForTime(movie->moov, inc->trackID, 0, &esd);\n\t\t\tif (!movie->LastError) movie->LastError = gf_list_add(od->ESDescriptors, esd);\n\t\t\tif (movie->LastError) {\n\t\t\t\tgf_odf_desc_del(desc);\n\t\t\t\tgf_odf_desc_del((GF_Descriptor *) od);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t\tgf_odf_desc_del(desc);\n\t\treturn (GF_Descriptor *)od;\n\t} else {\n\t\tisom_iod = (GF_IsomInitialObjectDescriptor *)desc;\n\t\tiod->objectDescriptorID = isom_iod->objectDescriptorID;\n\t\tiod->extensionDescriptors = isom_iod->extensionDescriptors;\n\t\tisom_iod->extensionDescriptors = NULL;\n\t\tiod->IPMP_Descriptors = isom_iod->IPMP_Descriptors;\n\t\tisom_iod->IPMP_Descriptors = NULL;\n\t\tiod->OCIDescriptors = isom_iod->OCIDescriptors;\n\t\tisom_iod->OCIDescriptors = NULL;\n\t\tiod->URLString = isom_iod->URLString;\n\t\tisom_iod->URLString = NULL;\n\t\tiod->tag = GF_ODF_IOD_TAG;\n\n\t\tiod->audio_profileAndLevel = isom_iod->audio_profileAndLevel;\n\t\tiod->graphics_profileAndLevel = isom_iod->graphics_profileAndLevel;\n\t\tiod->inlineProfileFlag = isom_iod->inlineProfileFlag;\n\t\tiod->OD_profileAndLevel = isom_iod->OD_profileAndLevel;\n\t\tiod->scene_profileAndLevel = isom_iod->scene_profileAndLevel;\n\t\tiod->visual_profileAndLevel = isom_iod->visual_profileAndLevel;\n\t\tiod->IPMPToolList = isom_iod->IPMPToolList;\n\t\tisom_iod->IPMPToolList = NULL;\n\n\t\t//then recreate the desc in Inc\n\t\ti=0;\n\t\twhile ((inc = (GF_ES_ID_Inc*)gf_list_enum(isom_iod->ES_ID_IncDescriptors, &i))) {\n\t\t\tmovie->LastError = GetESDForTime(movie->moov, inc->trackID, 0, &esd);\n\t\t\tif (!movie->LastError) movie->LastError = gf_list_add(iod->ESDescriptors, esd);\n\t\t\tif (movie->LastError) {\n\t\t\t\tgf_odf_desc_del(desc);\n\t\t\t\tgf_odf_desc_del((GF_Descriptor *) iod);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t\tgf_odf_desc_del(desc);\n\t\treturn (GF_Descriptor *)iod;\n\t}\n}\n\n\nGF_EXPORT\nu32 gf_isom_get_track_count(GF_ISOFile *movie)\n{\n\tif (!movie || !movie->moov) return 0;\n\n\tif (!movie->moov->trackList) {\n\t\tmovie->LastError = GF_ISOM_INVALID_FILE;\n\t\treturn 0;\n\t}\n\treturn gf_list_count(movie->moov->trackList);\n}\n\n\nGF_EXPORT\nGF_ISOTrackID gf_isom_get_track_id(GF_ISOFile *movie, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\tif (!movie) return 0;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !trak->Header) return 0;\n\treturn trak->Header->trackID;\n}\n\n\nGF_EXPORT\nu32 gf_isom_get_track_by_id(GF_ISOFile *the_file, GF_ISOTrackID trackID)\n{\n\tu32 count;\n\tu32 i;\n\tif (the_file == NULL) return 0;\n\n\tcount = gf_isom_get_track_count(the_file);\n\tif (!count) return 0;\n\tfor (i = 0; i < count; i++) {\n\t\tGF_TrackBox *trak = gf_isom_get_track_from_file(the_file, i+1);\n\t\tif (!trak || !trak->Header) return 0;\n\t\tif (trak->Header->trackID == trackID) return i+1;\n\t}\n\treturn 0;\n}\n\nGF_EXPORT\nGF_ISOTrackID gf_isom_get_track_original_id(GF_ISOFile *movie, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\tif (!movie) return 0;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return 0;\n\treturn trak->originalID;\n}\n\n//return the timescale of the movie, 0 if error\nGF_EXPORT\nBool gf_isom_has_movie(GF_ISOFile *file)\n{\n\tif (file && file->moov) return GF_TRUE;\n\treturn GF_FALSE;\n}\n\n#ifndef GPAC_DISABLE_ISOM\nGF_EXPORT\nBool gf_isom_has_segment(GF_ISOFile *file, u32 *brand, u32 *version)\n{\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\tu32 i;\n\tGF_Box *a;\n\ti = 0;\n\twhile (NULL != (a = (GF_Box*)gf_list_enum(file->TopBoxes, &i))) {\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t\tif (a->type == GF_ISOM_BOX_TYPE_STYP) {\n\t\t\tGF_FileTypeBox *styp = (GF_FileTypeBox *)a;\n\t\t\t*brand = styp->majorBrand;\n\t\t\t*version = styp->minorVersion;\n\t\t\treturn GF_TRUE;\n\t\t}\n#endif\n\t}\n#endif\n\treturn GF_FALSE;\n}\n\nGF_EXPORT\nu32 gf_isom_segment_get_fragment_count(GF_ISOFile *file)\n{\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\tif (file) {\n\t\tu32 i, count = 0;\n\t\tfor (i=0; i<gf_list_count(file->TopBoxes); i++) {\n\t\t\tGF_Box *a = (GF_Box*)gf_list_get(file->TopBoxes, i);\n\t\t\tif (a->type==GF_ISOM_BOX_TYPE_MOOF) count++;\n\t\t}\n\t\treturn count;\n\t}\n#endif\n\treturn 0;\n}\n\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\nstatic GF_MovieFragmentBox *gf_isom_get_moof(GF_ISOFile *file, u32 moof_index)\n{\n\tu32 i;\n\tfor (i=0; i<gf_list_count(file->TopBoxes); i++) {\n\t\tGF_Box *a = (GF_Box*)gf_list_get(file->TopBoxes, i);\n\t\tif (a->type==GF_ISOM_BOX_TYPE_MOOF) {\n\t\t\tmoof_index--;\n\t\t\tif (!moof_index) return (GF_MovieFragmentBox *) a;\n\t\t}\n\t}\n\treturn NULL;\n}\n#endif /* GPAC_DISABLE_ISOM_FRAGMENTS */\n\nGF_EXPORT\nu32 gf_isom_segment_get_track_fragment_count(GF_ISOFile *file, u32 moof_index)\n{\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\tGF_MovieFragmentBox *moof;\n\tif (!file) return 0;\n\tgf_list_count(file->TopBoxes);\n\tmoof = gf_isom_get_moof(file, moof_index);\n\treturn moof ? gf_list_count(moof->TrackList) : 0;\n#endif\n\treturn 0;\n}\n\nGF_EXPORT\nu32 gf_isom_segment_get_track_fragment_decode_time(GF_ISOFile *file, u32 moof_index, u32 traf_index, u64 *decode_time)\n{\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\tGF_MovieFragmentBox *moof;\n\tGF_TrackFragmentBox *traf;\n\tif (!file) return 0;\n\tgf_list_count(file->TopBoxes);\n\tmoof = gf_isom_get_moof(file, moof_index);\n\ttraf = moof ? (GF_TrackFragmentBox*)gf_list_get(moof->TrackList, traf_index-1) : NULL;\n\tif (!traf) return 0;\n\tif (decode_time) {\n\t\t*decode_time = traf->tfdt ? traf->tfdt->baseMediaDecodeTime : 0;\n\t}\n\treturn traf->tfhd->trackID;\n#endif\n\treturn 0;\n}\n#endif\n\n//return the timescale of the movie, 0 if error\nGF_EXPORT\nu32 gf_isom_get_timescale(GF_ISOFile *movie)\n{\n\tif (!movie || !movie->moov || !movie->moov->mvhd) return 0;\n\treturn movie->moov->mvhd->timeScale;\n}\n\n\n//return the duration of the movie, 0 if error\nGF_EXPORT\nu64 gf_isom_get_duration(GF_ISOFile *movie)\n{\n\tif (!movie || !movie->moov || !movie->moov->mvhd) return 0;\n\n\t//if file was open in Write or Edit mode, recompute the duration\n\t//the duration of a movie is the MaxDuration of all the tracks...\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\tgf_isom_update_duration(movie);\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\treturn movie->moov->mvhd->duration;\n}\n//return the duration of the movie, 0 if error\nGF_EXPORT\nu64 gf_isom_get_original_duration(GF_ISOFile *movie)\n{\n\tif (!movie || !movie->moov|| !movie->moov->mvhd) return 0;\n\treturn movie->moov->mvhd->original_duration;\n}\n\n//return the creation info of the movie\nGF_EXPORT\nGF_Err gf_isom_get_creation_time(GF_ISOFile *movie, u64 *creationTime, u64 *modificationTime)\n{\n\tif (!movie || !movie->moov) return GF_BAD_PARAM;\n\n\tif (creationTime) *creationTime = movie->moov->mvhd->creationTime;\n\tif (creationTime) *modificationTime = movie->moov->mvhd->modificationTime;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_track_creation_time(GF_ISOFile *movie, u32 trackNumber, u64 *creationTime, u64 *modificationTime)\n{\n\tGF_TrackBox *trak;\n\tif (!movie || !movie->moov) return GF_BAD_PARAM;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return 0;\n\n\tif (creationTime) *creationTime = trak->Media->mediaHeader->creationTime;\n\tif (creationTime) *modificationTime = trak->Media->mediaHeader->modificationTime;\n\treturn GF_OK;\n}\n\n//check the presence of a track in IOD. 0: NO, 1: YES, 2: ERROR\nGF_EXPORT\nu8 gf_isom_is_track_in_root_od(GF_ISOFile *movie, u32 trackNumber)\n{\n\tu32 i;\n\tGF_ISOTrackID trackID;\n\tGF_Descriptor *desc;\n\tGF_ES_ID_Inc *inc;\n\tGF_List *inc_list;\n\tif (!movie) return 2;\n\tif (!movie->moov || !movie->moov->iods) return 0;\n\n\tdesc = movie->moov->iods->descriptor;\n\tswitch (desc->tag) {\n\tcase GF_ODF_ISOM_IOD_TAG:\n\t\tinc_list = ((GF_IsomInitialObjectDescriptor *)desc)->ES_ID_IncDescriptors;\n\t\tbreak;\n\tcase GF_ODF_ISOM_OD_TAG:\n\t\tinc_list = ((GF_IsomObjectDescriptor *)desc)->ES_ID_IncDescriptors;\n\t\tbreak;\n\t//files without IOD are possible !\n\tdefault:\n\t\treturn 0;\n\t}\n\ttrackID = gf_isom_get_track_id(movie, trackNumber);\n\tif (!trackID) return 2;\n\ti=0;\n\twhile ((inc = (GF_ES_ID_Inc*)gf_list_enum(inc_list, &i))) {\n\t\tif (inc->trackID == (u32) trackID) return 1;\n\t}\n\treturn 0;\n}\n\n\n\n//gets the enable flag of a track\n//0: NO, 1: YES, 2: ERROR\nGF_EXPORT\nu8 gf_isom_is_track_enabled(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\n\tif (!trak || !trak->Header) return 2;\n\treturn (trak->Header->flags & 1) ? 1 : 0;\n}\n\nGF_EXPORT\nu32 gf_isom_get_track_flags(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return 0;\n\treturn trak->Header->flags;\n}\n\n\n//get the track duration\n//return 0 if bad param\nGF_EXPORT\nu64 gf_isom_get_track_duration(GF_ISOFile *movie, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return 0;\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\t/*in all modes except dump recompute duration in case headers are wrong*/\n\tif (movie->openMode != GF_ISOM_OPEN_READ_DUMP) {\n\t\tSetTrackDuration(trak);\n\t}\n#endif\n\treturn trak->Header->duration;\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_media_language(GF_ISOFile *the_file, u32 trackNumber, char **lang)\n{\n\tu32 count;\n\tBool elng_found = GF_FALSE;\n\tGF_TrackBox *trak;\n\tif (!lang) {\n\t\treturn GF_BAD_PARAM;\n\t}\n\t*lang = NULL;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media) return GF_BAD_PARAM;\n\tcount = gf_list_count(trak->Media->child_boxes);\n\tif (count>0) {\n\t\tu32 i;\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tGF_Box *box = (GF_Box *)gf_list_get(trak->Media->child_boxes, i);\n\t\t\tif (box->type == GF_ISOM_BOX_TYPE_ELNG) {\n\t\t\t\t*lang = gf_strdup(((GF_ExtendedLanguageBox *)box)->extended_language);\n\t\t\t\treturn GF_OK;\n\t\t\t}\n\t\t}\n\t}\n\tif (!elng_found) {\n\t\t*lang = gf_strdup(trak->Media->mediaHeader->packedLanguage);\n\t}\n\treturn GF_OK;\n}\n\nGF_EXPORT\nu32 gf_isom_get_track_kind_count(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_UserDataBox *udta;\n\tGF_UserDataMap *map;\n\tif (trackNumber) {\n\t\tGF_TrackBox *trak = gf_isom_get_track_from_file(the_file, trackNumber);\n\t\tif (!trak) return 0;\n\t\tif (!trak->udta) {\n\t\t\treturn 0;\n\t\t}\n\t\tudta = trak->udta;\n\t} else {\n\t\treturn 0;\n\t}\n\tmap = udta_getEntry(udta, GF_ISOM_BOX_TYPE_KIND, NULL);\n\tif (!map) return 0;\n\n\treturn gf_list_count(map->boxes);\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_track_kind(GF_ISOFile *the_file, u32 trackNumber, u32 index, char **scheme, char **value)\n{\n\tGF_Err e;\n\tGF_UserDataBox *udta;\n\tGF_UserDataMap *map;\n\tGF_KindBox *kindBox;\n\tif (!scheme || !value) {\n\t\treturn GF_BAD_PARAM;\n\t}\n\t*scheme = NULL;\n\t*value = NULL;\n\n\tif (trackNumber) {\n\t\tGF_TrackBox *trak = gf_isom_get_track_from_file(the_file, trackNumber);\n\t\tif (!trak) return GF_BAD_PARAM;\n\t\tif (!trak->udta) {\n\t\t\te = trak_on_child_box((GF_Box*)trak, gf_isom_box_new_parent(&trak->child_boxes, GF_ISOM_BOX_TYPE_UDTA), GF_FALSE);\n\t\t\tif (e) return e;\n\t\t}\n\t\tudta = trak->udta;\n\t} else {\n\t\treturn GF_BAD_PARAM;\n\t}\n\tmap = udta_getEntry(udta, GF_ISOM_BOX_TYPE_KIND, NULL);\n\tif (!map) return GF_BAD_PARAM;\n\n\tkindBox = (GF_KindBox *)gf_list_get(map->boxes, index);\n\tif (!kindBox) return GF_BAD_PARAM;\n\n\t*scheme = gf_strdup(kindBox->schemeURI);\n\tif (kindBox->value) {\n\t\t*value = gf_strdup(kindBox->value);\n\t}\n\treturn GF_OK;\n}\n\n\n//Return the number of track references of a track for a given ReferenceType\n//return 0 if error\nGF_EXPORT\ns32 gf_isom_get_reference_count(GF_ISOFile *movie, u32 trackNumber, u32 referenceType)\n{\n\tGF_TrackBox *trak;\n\tGF_TrackReferenceTypeBox *dpnd;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return -1;\n\tif (!trak->References) return 0;\n\tif (movie->openMode == GF_ISOM_OPEN_WRITE) {\n\t\tmovie->LastError = GF_ISOM_INVALID_MODE;\n\t\treturn -1;\n\t}\n\n\tdpnd = NULL;\n\tif ( (movie->LastError = Track_FindRef(trak, referenceType, &dpnd)) ) return -1;\n\tif (!dpnd) return 0;\n\treturn dpnd->trackIDCount;\n}\n\n\n//Return the number of track references of a track for a given ReferenceType\n//return 0 if error\nGF_EXPORT\nconst GF_ISOTrackID *gf_isom_enum_track_references(GF_ISOFile *movie, u32 trackNumber, u32 idx, u32 *referenceType, u32 *referenceCount)\n{\n\tGF_TrackBox *trak;\n\tGF_TrackReferenceTypeBox *dpnd;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return NULL;\n\tif (!trak->References) return NULL;\n\tdpnd = gf_list_get(trak->References->child_boxes, idx);\n\tif (!dpnd) return NULL;\n\t*referenceType = dpnd->reference_type;\n\t*referenceCount = dpnd->trackIDCount;\n\treturn dpnd->trackIDs;\n}\n\n\n//Return the referenced track number for a track and a given ReferenceType and Index\n//return -1 if error, 0 if the reference is a NULL one, or the trackNumber\nGF_EXPORT\nGF_Err gf_isom_get_reference(GF_ISOFile *movie, u32 trackNumber, u32 referenceType, u32 referenceIndex, u32 *refTrack)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\tGF_TrackReferenceTypeBox *dpnd;\n\tGF_ISOTrackID refTrackNum;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\n\t*refTrack = 0;\n\tif (!trak || !trak->References) return GF_BAD_PARAM;\n\n\tdpnd = NULL;\n\te = Track_FindRef(trak, referenceType, &dpnd);\n\tif (e) return e;\n\tif (!dpnd) return GF_BAD_PARAM;\n\n\tif (!referenceIndex || (referenceIndex > dpnd->trackIDCount)) return GF_BAD_PARAM;\n\n\t//the spec allows a NULL reference\n\t//(ex, to force desync of a track, set a sync ref with ID = 0)\n\tif (dpnd->trackIDs[referenceIndex - 1] == 0) return GF_OK;\n\n\trefTrackNum = gf_isom_get_tracknum_from_id(movie->moov, dpnd->trackIDs[referenceIndex-1]);\n\n\t//if the track was not found, this means the file is broken !!!\n\tif (! refTrackNum) return GF_ISOM_INVALID_FILE;\n\t*refTrack = refTrackNum;\n\treturn GF_OK;\n}\n\n//Return the referenced track ID for a track and a given ReferenceType and Index\n//return -1 if error, 0 if the reference is a NULL one, or the trackNumber\nGF_EXPORT\nGF_Err gf_isom_get_reference_ID(GF_ISOFile *movie, u32 trackNumber, u32 referenceType, u32 referenceIndex, GF_ISOTrackID *refTrackID)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\tGF_TrackReferenceTypeBox *dpnd;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\n\t*refTrackID = 0;\n\tif (!trak || !trak->References || !referenceIndex) return GF_BAD_PARAM;\n\n\tdpnd = NULL;\n\te = Track_FindRef(trak, referenceType, &dpnd);\n\tif (e) return e;\n\tif (!dpnd) return GF_BAD_PARAM;\n\n\tif (referenceIndex > dpnd->trackIDCount) return GF_BAD_PARAM;\n\n\t*refTrackID = dpnd->trackIDs[referenceIndex-1];\n\n\treturn GF_OK;\n}\n\n//Return referenceIndex if the given track has a reference to the given TreckID of a given ReferenceType\n//return 0 if error\nGF_EXPORT\nu32 gf_isom_has_track_reference(GF_ISOFile *movie, u32 trackNumber, u32 referenceType, GF_ISOTrackID refTrackID)\n{\n\tu32 i;\n\tGF_TrackBox *trak;\n\tGF_TrackReferenceTypeBox *dpnd;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return 0;\n\tif (!trak->References) return 0;\n\n\tdpnd = NULL;\n\tif ( (movie->LastError = Track_FindRef(trak, referenceType, &dpnd)) ) return 0;\n\tif (!dpnd) return 0;\n\tfor (i=0; i<dpnd->trackIDCount; i++) {\n\t\tif (dpnd->trackIDs[i]==refTrackID) return i+1;\n\t}\n\treturn 0;\n}\n\n\n\n//Return the media time given the absolute time in the Movie\nGF_EXPORT\nGF_Err gf_isom_get_media_time(GF_ISOFile *the_file, u32 trackNumber, u32 movieTime, u64 *MediaTime)\n{\n\tGF_TrackBox *trak;\n\tu8 useEdit;\n\ts64 SegmentStartTime, mediaOffset;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !MediaTime) return GF_BAD_PARAM;\n\n\tSegmentStartTime = 0;\n\treturn GetMediaTime(trak, GF_FALSE, movieTime, MediaTime, &SegmentStartTime, &mediaOffset, &useEdit, NULL);\n}\n\n\n//Get the stream description index (eg, the ESD) for a given time IN MEDIA TIMESCALE\n//return 0 if error or if empty\nGF_EXPORT\nu32 gf_isom_get_sample_description_index(GF_ISOFile *movie, u32 trackNumber, u64 for_time)\n{\n\tu32 streamDescIndex;\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return 0;\n\n\tif ( (movie->LastError = Media_GetSampleDescIndex(trak->Media, for_time, &streamDescIndex)) ) {\n\t\treturn 0;\n\t}\n\treturn streamDescIndex;\n}\n\n//Get the number of \"streams\" stored in the media - a media can have several stream descriptions...\nGF_EXPORT\nu32 gf_isom_get_sample_description_count(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return 0;\n\n\treturn gf_list_count(trak->Media->information->sampleTable->SampleDescription->child_boxes);\n}\n\n\n//Get the GF_ESD given the StreamDescriptionIndex\n//THE DESCRIPTOR IS DUPLICATED, SO HAS TO BE DELETED BY THE APP\nGF_EXPORT\nGF_ESD *gf_isom_get_esd(GF_ISOFile *movie, u32 trackNumber, u32 StreamDescriptionIndex)\n{\n\tGF_ESD *esd;\n\tGF_Err e;\n\te = GetESD(movie->moov, gf_isom_get_track_id(movie, trackNumber), StreamDescriptionIndex, &esd);\n\tif (e && (e!= GF_ISOM_INVALID_MEDIA)) {\n\t\tmovie->LastError = e;\n\t\tif (esd) gf_odf_desc_del((GF_Descriptor *)esd);\n\t\treturn NULL;\n\t}\n\n\treturn esd;\n}\n\n//Get the decoderConfigDescriptor given the SampleDescriptionIndex\n//THE DESCRIPTOR IS DUPLICATED, SO HAS TO BE DELETED BY THE APP\nGF_EXPORT\nGF_DecoderConfig *gf_isom_get_decoder_config(GF_ISOFile *the_file, u32 trackNumber, u32 StreamDescriptionIndex)\n{\n\tGF_TrackBox *trak;\n\tGF_ESD *esd;\n\tGF_Descriptor *decInfo;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return NULL;\n\t//get the ESD (possibly emulated)\n\tMedia_GetESD(trak->Media, StreamDescriptionIndex, &esd, GF_FALSE);\n\tif (!esd) return NULL;\n\tdecInfo = (GF_Descriptor *) esd->decoderConfig;\n\tesd->decoderConfig = NULL;\n\tgf_odf_desc_del((GF_Descriptor *) esd);\n\treturn (GF_DecoderConfig *)decInfo;\n}\n\n\n//get the media duration (without edit)\n//return 0 if bad param\nGF_EXPORT\nu64 gf_isom_get_media_duration(GF_ISOFile *movie, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return 0;\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\n\t/*except in dump mode always recompute the duration*/\n\tif (movie->openMode != GF_ISOM_OPEN_READ_DUMP) {\n\t\tif ( (movie->LastError = Media_SetDuration(trak)) ) return 0;\n\t}\n\n#endif\n\n\treturn trak->Media->mediaHeader->duration;\n}\n\n//get the media duration (without edit)\n//return 0 if bad param\nGF_EXPORT\nu64 gf_isom_get_media_original_duration(GF_ISOFile *movie, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !trak->Media || !trak->Media->mediaHeader) return 0;\n\n\treturn trak->Media->mediaHeader->original_duration;\n}\n\n//Get the timeScale of the media. All samples DTS/CTS are expressed in this timeScale\nGF_EXPORT\nu32 gf_isom_get_media_timescale(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media || !trak->Media->mediaHeader) return 0;\n\treturn trak->Media->mediaHeader->timeScale;\n}\n\n\nGF_EXPORT\nu32 gf_isom_get_copyright_count(GF_ISOFile *mov)\n{\n\tGF_UserDataMap *map;\n\tif (!mov || !mov->moov || !mov->moov->udta) return 0;\n\tmap = udta_getEntry(mov->moov->udta, GF_ISOM_BOX_TYPE_CPRT, NULL);\n\tif (!map) return 0;\n\treturn gf_list_count(map->boxes);\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_copyright(GF_ISOFile *mov, u32 Index, const char **threeCharCode, const char **notice)\n{\n\tGF_UserDataMap *map;\n\tGF_CopyrightBox *cprt;\n\n\tif (!mov || !mov->moov || !Index) return GF_BAD_PARAM;\n\n\tif (!mov->moov->udta) return GF_OK;\n\tmap = udta_getEntry(mov->moov->udta, GF_ISOM_BOX_TYPE_CPRT, NULL);\n\tif (!map) return GF_OK;\n\n\tif (Index > gf_list_count(map->boxes)) return GF_BAD_PARAM;\n\n\tcprt = (GF_CopyrightBox*)gf_list_get(map->boxes, Index-1);\n\t(*threeCharCode) = cprt->packedLanguageCode;\n\t(*notice) = cprt->notice;\n\treturn GF_OK;\n}\n\n#if 0\nGF_Err gf_isom_get_watermark(GF_ISOFile *mov, bin128 UUID, u8** data, u32* length)\n{\n\tGF_UserDataMap *map;\n\tGF_UnknownUUIDBox *wm;\n\n\tif (!mov) return GF_BAD_PARAM;\n\tif (!mov->moov || !mov->moov->udta) return GF_NOT_SUPPORTED;\n\n\tmap = udta_getEntry(mov->moov->udta, GF_ISOM_BOX_TYPE_UUID, (bin128 *) & UUID);\n\tif (!map) return GF_NOT_SUPPORTED;\n\n\twm = (GF_UnknownUUIDBox*)gf_list_get(map->boxes, 0);\n\tif (!wm) return GF_NOT_SUPPORTED;\n\n\t*data = (u8 *) gf_malloc(sizeof(char)*wm->dataSize);\n\tif (! *data) return GF_OUT_OF_MEM;\n\tmemcpy(*data, wm->data, wm->dataSize);\n\t*length = wm->dataSize;\n\treturn GF_OK;\n}\n#endif\n\nGF_EXPORT\nu32 gf_isom_get_chapter_count(GF_ISOFile *movie, u32 trackNumber)\n{\n\tGF_UserDataMap *map;\n\tGF_ChapterListBox *lst;\n\tGF_UserDataBox *udta;\n\n\tif (!movie || !movie->moov) return 0;\n\n\tudta = NULL;\n\tif (trackNumber) {\n\t\tGF_TrackBox *trak = gf_isom_get_track_from_file(movie, trackNumber);\n\t\tif (!trak) return 0;\n\t\tudta = trak->udta;\n\t} else {\n\t\tudta = movie->moov->udta;\n\t}\n\tif (!udta) return 0;\n\tmap = udta_getEntry(udta, GF_ISOM_BOX_TYPE_CHPL, NULL);\n\tif (!map) return 0;\n\tlst = (GF_ChapterListBox *)gf_list_get(map->boxes, 0);\n\tif (!lst) return 0;\n\treturn gf_list_count(lst->list);\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_chapter(GF_ISOFile *movie, u32 trackNumber, u32 Index, u64 *chapter_time, const char **name)\n{\n\tGF_UserDataMap *map;\n\tGF_ChapterListBox *lst;\n\tGF_ChapterEntry *ce;\n\tGF_UserDataBox *udta;\n\n\tif (!movie || !movie->moov) return GF_BAD_PARAM;\n\n\tudta = NULL;\n\tif (trackNumber) {\n\t\tGF_TrackBox *trak = gf_isom_get_track_from_file(movie, trackNumber);\n\t\tif (!trak) return GF_BAD_PARAM;\n\t\tudta = trak->udta;\n\t} else {\n\t\tudta = movie->moov->udta;\n\t}\n\tif (!udta) return GF_BAD_PARAM;\n\tmap = udta_getEntry(movie->moov->udta, GF_ISOM_BOX_TYPE_CHPL, NULL);\n\tif (!map) return GF_BAD_PARAM;\n\tlst = (GF_ChapterListBox *)gf_list_get(map->boxes, 0);\n\tif (!lst) return GF_BAD_PARAM;\n\n\tce = (GF_ChapterEntry *)gf_list_get(lst->list, Index-1);\n\tif (!ce) return GF_BAD_PARAM;\n\tif (chapter_time) {\n\t\t*chapter_time = ce->start_time;\n\t\t*chapter_time /= 10000L;\n\t}\n\tif (name) *name = ce->name;\n\treturn GF_OK;\n}\n\n\nGF_EXPORT\nu32 gf_isom_get_media_type(GF_ISOFile *movie, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\treturn (trak->Media && trak->Media->handler) ? trak->Media->handler->handlerType : 0;\n}\n\nBool IsMP4Description(u32 entryType)\n{\n\tswitch (entryType) {\n\tcase GF_ISOM_BOX_TYPE_MP4S:\n\tcase GF_ISOM_BOX_TYPE_LSR1:\n\tcase GF_ISOM_BOX_TYPE_MP4A:\n\tcase GF_ISOM_BOX_TYPE_MP4V:\n\tcase GF_ISOM_BOX_TYPE_ENCA:\n\tcase GF_ISOM_BOX_TYPE_ENCV:\n\tcase GF_ISOM_BOX_TYPE_RESV:\n\tcase GF_ISOM_BOX_TYPE_ENCS:\n\t\treturn GF_TRUE;\n\tdefault:\n\t\treturn GF_FALSE;\n\t}\n}\n\nBool gf_isom_is_encrypted_entry(u32 entryType)\n{\n\tswitch (entryType) {\n\tcase GF_ISOM_BOX_TYPE_ENCA:\n\tcase GF_ISOM_BOX_TYPE_ENCV:\n\tcase GF_ISOM_BOX_TYPE_ENCS:\n\t\treturn GF_TRUE;\n\tdefault:\n\t\treturn GF_FALSE;\n\t}\n}\n\nGF_EXPORT\nBool gf_isom_is_track_encrypted(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\tu32 i=0;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return 2;\n\twhile (1) {\n\t\tGF_Box *entry = (GF_Box*)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, i);\n\t\tif (!entry) break;\n\t\tif (gf_isom_is_encrypted_entry(entry->type)) return GF_TRUE;\n\n\t\tif (gf_isom_is_cenc_media(the_file, trackNumber, i+1))\n\t\t\treturn GF_TRUE;\n\n\t\ti++;\n\t}\n\treturn GF_FALSE;\n}\n\nGF_EXPORT\nu32 gf_isom_get_media_subtype(GF_ISOFile *the_file, u32 trackNumber, u32 DescriptionIndex)\n{\n\tGF_TrackBox *trak;\n\tGF_Box *entry;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !DescriptionIndex || !trak->Media || !trak->Media->information || !trak->Media->information->sampleTable) return 0;\n\tentry = (GF_Box*)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, DescriptionIndex-1);\n\tif (!entry) return 0;\n\n\t//filter MPEG sub-types\n\tif (IsMP4Description(entry->type)) {\n\t\tif (gf_isom_is_encrypted_entry(entry->type)) return GF_ISOM_SUBTYPE_MPEG4_CRYP;\n\t\telse return GF_ISOM_SUBTYPE_MPEG4;\n\t}\n\tif (entry->type == GF_ISOM_BOX_TYPE_GNRV) {\n\t\treturn ((GF_GenericVisualSampleEntryBox *)entry)->EntryType;\n\t}\n\telse if (entry->type == GF_ISOM_BOX_TYPE_GNRA) {\n\t\treturn ((GF_GenericAudioSampleEntryBox *)entry)->EntryType;\n\t}\n\telse if (entry->type == GF_ISOM_BOX_TYPE_GNRM) {\n\t\treturn ((GF_GenericSampleEntryBox *)entry)->EntryType;\n\t}\n\treturn entry->type;\n}\n\nGF_EXPORT\nu32 gf_isom_get_mpeg4_subtype(GF_ISOFile *the_file, u32 trackNumber, u32 DescriptionIndex)\n{\n\tGF_TrackBox *trak;\n\tGF_Box *entry=NULL;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !DescriptionIndex) return 0;\n\n\tif (trak->Media\n\t\t&& trak->Media->information\n\t\t&& trak->Media->information->sampleTable\n\t\t&& trak->Media->information->sampleTable->SampleDescription\n\t) {\n\t\tentry = (GF_Box*)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, DescriptionIndex-1);\n\t}\n\tif (!entry) return 0;\n\n\t//filter MPEG sub-types\n\tif (!IsMP4Description(entry->type)) return 0;\n\treturn entry->type;\n}\n\n//Get the HandlerDescription name.\nGF_EXPORT\nGF_Err gf_isom_get_handler_name(GF_ISOFile *the_file, u32 trackNumber, const char **outName)\n{\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !outName) return GF_BAD_PARAM;\n\t*outName = trak->Media->handler->nameUTF8;\n\treturn GF_OK;\n}\n\n//Check the DataReferences of this track\nGF_EXPORT\nGF_Err gf_isom_check_data_reference(GF_ISOFile *the_file, u32 trackNumber, u32 StreamDescriptionIndex)\n{\n\tGF_Err e;\n\tu32 drefIndex;\n\tGF_TrackBox *trak;\n\n\tif (!StreamDescriptionIndex || !trackNumber) return GF_BAD_PARAM;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\te = Media_GetSampleDesc(trak->Media, StreamDescriptionIndex , NULL, &drefIndex);\n\tif (e) return e;\n\tif (!drefIndex) return GF_BAD_PARAM;\n\treturn Media_CheckDataEntry(trak->Media, drefIndex);\n}\n\n//get the location of the data. If URL && URN are NULL, the data is in this file\nGF_EXPORT\nGF_Err gf_isom_get_data_reference(GF_ISOFile *the_file, u32 trackNumber, u32 StreamDescriptionIndex, const char **outURL, const char **outURN)\n{\n\tGF_TrackBox *trak;\n\tGF_DataEntryURLBox *url=NULL;\n\tGF_DataEntryURNBox *urn;\n\tu32 drefIndex;\n\tGF_Err e;\n\n\t*outURL = *outURN = NULL;\n\n\tif (!StreamDescriptionIndex || !trackNumber) return GF_BAD_PARAM;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\te = Media_GetSampleDesc(trak->Media, StreamDescriptionIndex , NULL, &drefIndex);\n\tif (e) return e;\n\tif (!drefIndex) return GF_BAD_PARAM;\n\n\tif (trak->Media\n\t\t&& trak->Media->information\n\t\t&& trak->Media->information->dataInformation\n\t\t&& trak->Media->information->dataInformation->dref\n\t) {\n\t\turl = (GF_DataEntryURLBox*)gf_list_get(trak->Media->information->dataInformation->dref->child_boxes, drefIndex - 1);\n\t}\n\tif (!url) return GF_ISOM_INVALID_FILE;\n\n\tif (url->type == GF_ISOM_BOX_TYPE_URL) {\n\t\t*outURL = url->location;\n\t\t*outURN = NULL;\n\t} else if (url->type == GF_ISOM_BOX_TYPE_URN) {\n\t\turn = (GF_DataEntryURNBox *) url;\n\t\t*outURN = urn->nameURN;\n\t\t*outURL = urn->location;\n\t} else {\n\t\t*outURN = NULL;\n\t\t*outURL = NULL;\n\t}\n\treturn GF_OK;\n}\n\n//Get the number of samples\n//return 0 if error or empty\nGF_EXPORT\nu32 gf_isom_get_sample_count(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media || !trak->Media->information || !trak->Media->information->sampleTable || !trak->Media->information->sampleTable->SampleSize) return 0;\n\treturn trak->Media->information->sampleTable->SampleSize->sampleCount\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t       + trak->sample_count_at_seg_start\n#endif\n\t       ;\n}\n\nGF_EXPORT\nu32 gf_isom_get_constant_sample_size(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media || !trak->Media->information || !trak->Media->information->sampleTable || !trak->Media->information->sampleTable->SampleSize) return 0;\n\treturn trak->Media->information->sampleTable->SampleSize->sampleSize;\n}\n\nGF_EXPORT\nu32 gf_isom_get_constant_sample_duration(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media || !trak->Media->information || !trak->Media->information->sampleTable || !trak->Media->information->sampleTable->TimeToSample) return 0;\n\tif (trak->Media->information->sampleTable->TimeToSample->nb_entries != 1) return 0;\n\treturn trak->Media->information->sampleTable->TimeToSample->entries[0].sampleDelta;\n}\n\nGF_EXPORT\nBool gf_isom_enable_raw_pack(GF_ISOFile *the_file, u32 trackNumber, u32 pack_num_samples)\n{\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_FALSE;\n\ttrak->pack_num_samples = 0;\n\t//we only activate sample packing for raw audio\n\tif (!trak->Media || !trak->Media->handler) return GF_FALSE;\n\tif (trak->Media->handler->handlerType != GF_ISOM_MEDIA_AUDIO) return GF_FALSE;\n\t//and sample duration of 1\n\tif (!trak->Media->information || !trak->Media->information->sampleTable || !trak->Media->information->sampleTable->TimeToSample) return GF_FALSE;\n\tif (trak->Media->information->sampleTable->TimeToSample->nb_entries != 1) return GF_FALSE;\n\tif (!trak->Media->information->sampleTable->TimeToSample->entries) return GF_FALSE;\n\tif (trak->Media->information->sampleTable->TimeToSample->entries[0].sampleDelta != 1) return GF_FALSE;\n\t//and sample with constant size\n\tif (!trak->Media->information->sampleTable->SampleSize || !trak->Media->information->sampleTable->SampleSize->sampleSize) return GF_FALSE;\n\ttrak->pack_num_samples = pack_num_samples;\n\treturn pack_num_samples ? GF_TRUE : GF_FALSE;\n}\n\nBool gf_isom_has_time_offset_table(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media->information->sampleTable->CompositionOffset) return GF_FALSE;\n\treturn GF_TRUE;\n}\n\nGF_EXPORT\nu32 gf_isom_has_time_offset(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tu32 i;\n\tGF_CompositionOffsetBox *ctts;\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media->information->sampleTable->CompositionOffset) return 0;\n\n\t//return true at the first offset found\n\tctts = trak->Media->information->sampleTable->CompositionOffset;\n\tfor (i=0; i<ctts->nb_entries; i++) {\n\t\tif (ctts->entries[i].decodingOffset && ctts->entries[i].sampleCount) return ctts->version ? 2 : 1;\n\t}\n\treturn 0;\n}\n\nGF_EXPORT\ns64 gf_isom_get_cts_to_dts_shift(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media->information->sampleTable->CompositionToDecode) return 0;\n\treturn trak->Media->information->sampleTable->CompositionToDecode->compositionToDTSShift;\n}\n\nGF_EXPORT\nBool gf_isom_has_sync_shadows(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_FALSE;\n\tif (!trak->Media->information->sampleTable->ShadowSync) return GF_FALSE;\n\tif (gf_list_count(trak->Media->information->sampleTable->ShadowSync->entries) ) return GF_TRUE;\n\treturn GF_FALSE;\n}\n\nGF_EXPORT\nBool gf_isom_has_sample_dependency(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_FALSE;\n\tif (!trak->Media->information->sampleTable->SampleDep) return GF_FALSE;\n\treturn GF_TRUE;\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_sample_flags(GF_ISOFile *the_file, u32 trackNumber, u32 sampleNumber, u32 *isLeading, u32 *dependsOn, u32 *dependedOn, u32 *redundant)\n{\n\tGF_TrackBox *trak;\n\t*isLeading = 0;\n\t*dependsOn = 0;\n\t*dependedOn = 0;\n\t*redundant = 0;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\tif (!trak->Media->information->sampleTable->SampleDep) return GF_BAD_PARAM;\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tif (sampleNumber <= trak->sample_count_at_seg_start)\n\t\treturn GF_BAD_PARAM;\n\tsampleNumber -= trak->sample_count_at_seg_start;\n#endif\n\n\treturn stbl_GetSampleDepType(trak->Media->information->sampleTable->SampleDep, sampleNumber, isLeading, dependsOn, dependedOn, redundant);\n}\n\n//return a sample give its number, and set the SampleDescIndex of this sample\n//this index allows to retrieve the stream description if needed (2 media in 1 track)\n//return NULL if error\nGF_EXPORT\nGF_ISOSample *gf_isom_get_sample_ex(GF_ISOFile *the_file, u32 trackNumber, u32 sampleNumber, u32 *sampleDescriptionIndex, GF_ISOSample *static_sample, u64 *data_offset)\n{\n\tGF_Err e;\n\tu32 descIndex;\n\tGF_TrackBox *trak;\n\tGF_ISOSample *samp;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return NULL;\n\n\tif (!sampleNumber) return NULL;\n\tif (static_sample) {\n\t\tsamp = static_sample;\n\t\tif (static_sample->dataLength && !static_sample->alloc_size)\n\t\t\tstatic_sample->alloc_size = static_sample->dataLength;\n\t} else {\n\t\tsamp = gf_isom_sample_new();\n\t}\n\tif (!samp) return NULL;\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tif (sampleNumber<=trak->sample_count_at_seg_start)\n\t\treturn NULL;\n\tsampleNumber -= trak->sample_count_at_seg_start;\n#endif\n\n\te = Media_GetSample(trak->Media, sampleNumber, &samp, &descIndex, GF_FALSE, data_offset);\n\tif (static_sample && !static_sample->alloc_size)\n\t\tstatic_sample->alloc_size = static_sample->dataLength;\n\n\tif (e) {\n\t\tgf_isom_set_last_error(the_file, e);\n\t\tif (!static_sample) gf_isom_sample_del(&samp);\n\t\treturn NULL;\n\t}\n\tif (sampleDescriptionIndex) *sampleDescriptionIndex = descIndex;\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tif (samp) samp->DTS += trak->dts_at_seg_start;\n#endif\n\n\treturn samp;\n}\n\nGF_EXPORT\nGF_ISOSample *gf_isom_get_sample(GF_ISOFile *the_file, u32 trackNumber, u32 sampleNumber, u32 *sampleDescriptionIndex)\n{\n\treturn gf_isom_get_sample_ex(the_file, trackNumber, sampleNumber, sampleDescriptionIndex, NULL, NULL);\n}\n\nGF_EXPORT\nu32 gf_isom_get_sample_duration(GF_ISOFile *the_file, u32 trackNumber, u32 sampleNumber)\n{\n\tu32 dur;\n\tu64 dts;\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !sampleNumber) return 0;\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tif (sampleNumber<=trak->sample_count_at_seg_start) return 0;\n\tsampleNumber -= trak->sample_count_at_seg_start;\n#endif\n\n\tstbl_GetSampleDTS_and_Duration(trak->Media->information->sampleTable->TimeToSample, sampleNumber, &dts, &dur);\n\treturn dur;\n}\n\n\nGF_EXPORT\nu32 gf_isom_get_sample_size(GF_ISOFile *the_file, u32 trackNumber, u32 sampleNumber)\n{\n\tu32 size = 0;\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !sampleNumber) return 0;\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tif (sampleNumber<=trak->sample_count_at_seg_start) return 0;\n\tsampleNumber -= trak->sample_count_at_seg_start;\n#endif\n\tstbl_GetSampleSize(trak->Media->information->sampleTable->SampleSize, sampleNumber, &size);\n\treturn size;\n}\n\nGF_EXPORT\nu32 gf_isom_get_max_sample_size(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media || !trak->Media->information || !trak->Media->information->sampleTable || !trak->Media->information->sampleTable->SampleSize) return 0;\n\n\treturn trak->Media->information->sampleTable->SampleSize->max_size;\n}\n\nGF_EXPORT\nu32 gf_isom_get_avg_sample_size(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media || !trak->Media->information || !trak->Media->information->sampleTable || !trak->Media->information->sampleTable->SampleSize) return 0;\n\n\tif ( trak->Media->information->sampleTable->SampleSize->sampleSize)\n\t\treturn trak->Media->information->sampleTable->SampleSize->sampleSize;\n\n\tif (!trak->Media->information->sampleTable->SampleSize->total_samples) return 0;\n\treturn (u32) (trak->Media->information->sampleTable->SampleSize->total_size / trak->Media->information->sampleTable->SampleSize->total_samples);\n}\n\nGF_EXPORT\nu32 gf_isom_get_max_sample_delta(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media || !trak->Media->information || !trak->Media->information->sampleTable || !trak->Media->information->sampleTable->TimeToSample) return 0;\n\n\treturn trak->Media->information->sampleTable->TimeToSample->max_ts_delta;\n}\n\nGF_EXPORT\nu32 gf_isom_get_max_sample_cts_offset(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media || !trak->Media->information || !trak->Media->information->sampleTable || !trak->Media->information->sampleTable->CompositionOffset) return 0;\n\n\treturn trak->Media->information->sampleTable->CompositionOffset->max_ts_delta;\n}\n\n\nGF_EXPORT\nBool gf_isom_get_sample_sync(GF_ISOFile *the_file, u32 trackNumber, u32 sampleNumber)\n{\n\tGF_ISOSAPType is_rap;\n\tGF_Err e;\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !sampleNumber) return GF_FALSE;\n\n\tif (! trak->Media->information->sampleTable->SyncSample) return GF_TRUE;\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tif (sampleNumber<=trak->sample_count_at_seg_start) return GF_FALSE;\n\tsampleNumber -= trak->sample_count_at_seg_start;\n#endif\n\te = stbl_GetSampleRAP(trak->Media->information->sampleTable->SyncSample, sampleNumber, &is_rap, NULL, NULL);\n\tif (e) return GF_FALSE;\n\treturn is_rap ? GF_TRUE : GF_FALSE;\n}\n\n//same as gf_isom_get_sample but doesn't fetch media data\nGF_EXPORT\nGF_ISOSample *gf_isom_get_sample_info_ex(GF_ISOFile *the_file, u32 trackNumber, u32 sampleNumber, u32 *sampleDescriptionIndex, u64 *data_offset, GF_ISOSample *static_sample)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\tGF_ISOSample *samp;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return NULL;\n\n\tif (!sampleNumber) return NULL;\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tif (sampleNumber<=trak->sample_count_at_seg_start) return NULL;\n\tsampleNumber -= trak->sample_count_at_seg_start;\n#endif\n\tif (static_sample) {\n\t\tsamp = static_sample;\n\t} else {\n\t\tsamp = gf_isom_sample_new();\n\t\tif (!samp) return NULL;\n\t}\n\n\te = Media_GetSample(trak->Media, sampleNumber, &samp, sampleDescriptionIndex, GF_TRUE, data_offset);\n\tif (e) {\n\t\tgf_isom_set_last_error(the_file, e);\n\t\tif (!static_sample)\n\t\t\tgf_isom_sample_del(&samp);\n\t\treturn NULL;\n\t}\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tif (samp) samp->DTS += trak->dts_at_seg_start;\n#endif\n\treturn samp;\n}\n\nGF_EXPORT\nGF_ISOSample *gf_isom_get_sample_info(GF_ISOFile *the_file, u32 trackNumber, u32 sampleNumber, u32 *sampleDescriptionIndex, u64 *data_offset)\n{\n\treturn gf_isom_get_sample_info_ex(the_file, trackNumber, sampleNumber, sampleDescriptionIndex, data_offset, NULL);\n}\n\n\n//get sample dts\nGF_EXPORT\nu64 gf_isom_get_sample_dts(GF_ISOFile *the_file, u32 trackNumber, u32 sampleNumber)\n{\n\tu64 dts;\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return 0;\n\n\tif (!sampleNumber) return 0;\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tif (sampleNumber<=trak->sample_count_at_seg_start) return 0;\n\tsampleNumber -= trak->sample_count_at_seg_start;\n#endif\n\tif (stbl_GetSampleDTS(trak->Media->information->sampleTable->TimeToSample, sampleNumber, &dts) != GF_OK) return 0;\n\treturn dts;\n}\n\nGF_EXPORT\nBool gf_isom_is_self_contained(GF_ISOFile *the_file, u32 trackNumber, u32 sampleDescriptionIndex)\n{\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_FALSE;\n\treturn Media_IsSelfContained(trak->Media, sampleDescriptionIndex);\n}\n\n/*retrieves given sample DTS*/\nGF_EXPORT\nu32 gf_isom_get_sample_from_dts(GF_ISOFile *the_file, u32 trackNumber, u64 dts)\n{\n\tGF_Err e;\n\tu32 sampleNumber, prevSampleNumber;\n\tGF_TrackBox *trak;\n\tGF_SampleTableBox *stbl;\n\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return 0;\n\n\tstbl = trak->Media->information->sampleTable;\n\n\te = stbl_findEntryForTime(stbl, dts, 1, &sampleNumber, &prevSampleNumber);\n\tif (e) return 0;\n\treturn sampleNumber;\n}\n\n\n//return a sample given a desired display time IN MEDIA TIME SCALE\n//and set the StreamDescIndex of this sample\n//this index allows to retrieve the stream description if needed (2 media in 1 track)\n//return NULL if error\n//WARNING: the sample may not be sync even though the sync was requested (depends on the media)\nGF_EXPORT\nGF_Err gf_isom_get_sample_for_media_time(GF_ISOFile *the_file, u32 trackNumber, u64 desiredTime, u32 *StreamDescriptionIndex, GF_ISOSearchMode SearchMode, GF_ISOSample **sample, u32 *SampleNum, u64 *data_offset)\n{\n\tGF_Err e;\n\tu32 sampleNumber, prevSampleNumber, syncNum, shadowSync;\n\tGF_TrackBox *trak;\n\tGF_ISOSample *shadow;\n\tGF_SampleTableBox *stbl;\n\tBool static_sample = GF_FALSE;\n\tu8 useShadow, IsSync;\n\n\tif (SampleNum) *SampleNum = 0;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tstbl = trak->Media->information->sampleTable;\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tif (desiredTime < trak->dts_at_seg_start) {\n\t\tdesiredTime = 0;\n\t} else {\n\t\tdesiredTime -= trak->dts_at_seg_start;\n\t}\n#endif\n\n\te = stbl_findEntryForTime(stbl, desiredTime, 0, &sampleNumber, &prevSampleNumber);\n\tif (e) return e;\n\n\t//if no shadow table, reset to sync only\n\tuseShadow = 0;\n\tif (!stbl->ShadowSync && (SearchMode == GF_ISOM_SEARCH_SYNC_SHADOW))\n\t\tSearchMode = GF_ISOM_SEARCH_SYNC_BACKWARD;\n\n\t//if no syncTable, disable syncSearching, as all samples ARE sync\n\tif (! trak->Media->information->sampleTable->SyncSample) {\n\t\tif (SearchMode == GF_ISOM_SEARCH_SYNC_FORWARD) SearchMode = GF_ISOM_SEARCH_FORWARD;\n\t\tif (SearchMode == GF_ISOM_SEARCH_SYNC_BACKWARD) SearchMode = GF_ISOM_SEARCH_BACKWARD;\n\t}\n\n\t//not found, return EOF or browse backward\n\tif (!sampleNumber && !prevSampleNumber) {\n\t\tif (SearchMode == GF_ISOM_SEARCH_SYNC_BACKWARD || SearchMode == GF_ISOM_SEARCH_BACKWARD) {\n\t\t\tsampleNumber = trak->Media->information->sampleTable->SampleSize->sampleCount;\n\t\t}\n\t\tif (!sampleNumber) return GF_EOS;\n\t}\n\n\t//check in case we have the perfect sample\n\tIsSync = 0;\n\n\t//according to the direction adjust the sampleNum value\n\tswitch (SearchMode) {\n\tcase GF_ISOM_SEARCH_SYNC_FORWARD:\n\t\tIsSync = 1;\n\tcase GF_ISOM_SEARCH_FORWARD:\n\t\t//not the exact one\n\t\tif (!sampleNumber) {\n\t\t\tif (prevSampleNumber != stbl->SampleSize->sampleCount) {\n\t\t\t\tsampleNumber = prevSampleNumber + 1;\n\t\t\t} else {\n\t\t\t\tsampleNumber = prevSampleNumber;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t//if dummy mode, reset to default browsing\n\tcase GF_ISOM_SEARCH_SYNC_BACKWARD:\n\t\tIsSync = 1;\n\tcase GF_ISOM_SEARCH_SYNC_SHADOW:\n\tcase GF_ISOM_SEARCH_BACKWARD:\n\tdefault:\n\t\t//first case, not found....\n\t\tif (!sampleNumber && !prevSampleNumber) {\n\t\t\tsampleNumber = stbl->SampleSize->sampleCount;\n\t\t} else if (!sampleNumber) {\n\t\t\tsampleNumber = prevSampleNumber;\n\t\t}\n\t\tbreak;\n\t}\n\n\t//get the sync sample num\n\tif (IsSync) {\n\t\t//get the SyncNumber\n\t\te = Media_FindSyncSample(trak->Media->information->sampleTable,\n\t\t                         sampleNumber, &syncNum, SearchMode);\n\t\tif (e) return e;\n\t\tif (syncNum) sampleNumber = syncNum;\n\t\tsyncNum = 0;\n\t}\n\t//if we are in shadow mode, get the previous sync sample\n\t//in case we can't find a good SyncShadow\n\telse if (SearchMode == GF_ISOM_SEARCH_SYNC_SHADOW) {\n\t\t//get the SyncNumber\n\t\te = Media_FindSyncSample(trak->Media->information->sampleTable,\n\t\t                         sampleNumber, &syncNum, GF_ISOM_SEARCH_SYNC_BACKWARD);\n\t\tif (e) return e;\n\t}\n\n\n\t//OK sampleNumber is exactly the sample we need (except for shadow)\n\n\tif (sample) {\n\t\tif (*sample) {\n\t\t\tstatic_sample = GF_TRUE;\n\t\t} else {\n\t\t\t*sample = gf_isom_sample_new();\n\t\t\tif (*sample == NULL) return GF_OUT_OF_MEM;\n\t\t}\n\t}\n\t//we are in shadow mode, we need to browse both SyncSample and ShadowSyncSample to get\n\t//the desired sample...\n\tif (SearchMode == GF_ISOM_SEARCH_SYNC_SHADOW) {\n\t\t//get the shadowing number\n\t\tstbl_GetSampleShadow(stbl->ShadowSync, &sampleNumber, &shadowSync);\n\t\t//now sampleNumber is the closest previous shadowed sample.\n\t\t//1- If we have a closer sync sample, use it.\n\t\t//2- if the shadowSync is 0, we don't have any shadowing, use syncNum\n\t\tif ((sampleNumber < syncNum) || (!shadowSync)) {\n\t\t\tsampleNumber = syncNum;\n\t\t} else {\n\t\t\t//otherwise, we have a better alternate sample in the shadowSync for this sample\n\t\t\tuseShadow = 1;\n\t\t}\n\t}\n\n\te = Media_GetSample(trak->Media, sampleNumber, sample, StreamDescriptionIndex, GF_FALSE, data_offset);\n\tif (e) {\n\t\tif (!static_sample)\n\t\t\tgf_isom_sample_del(sample);\n\t\telse if (! (*sample)->alloc_size && (*sample)->data && (*sample)->dataLength )\n\t\t \t(*sample)->alloc_size =  (*sample)->dataLength;\n\n\t\treturn e;\n\t}\n\tif (sample && ! (*sample)->IsRAP) {\n\t\tBool is_rap;\n\t\tGF_ISOSampleRollType roll_type;\n\t\te = gf_isom_get_sample_rap_roll_info(the_file, trackNumber, sampleNumber, &is_rap, &roll_type, NULL);\n\t\tif (e) return e;\n\t\tif (is_rap) (*sample)->IsRAP = SAP_TYPE_3;\n\t}\n\t//optionally get the sample number\n\tif (SampleNum) {\n\t\t*SampleNum = sampleNumber;\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\t\t*SampleNum += trak->sample_count_at_seg_start;\n#endif\n\t}\n\n\t//in shadow mode, we only get the data of the shadowing sample !\n\tif (sample && useShadow) {\n\t\t//we have to use StreamDescriptionIndex in case the sample data is in another desc\n\t\t//though this is unlikely as non optimized...\n\t\tshadow = gf_isom_get_sample(the_file, trackNumber, shadowSync, StreamDescriptionIndex);\n\t\t//if no sample, the shadowSync is broken, return the sample\n\t\tif (!shadow) return GF_OK;\n\t\t(*sample)->IsRAP = RAP;\n\t\tgf_free((*sample)->data);\n\t\t(*sample)->dataLength = shadow->dataLength;\n\t\t(*sample)->data = shadow->data;\n\t\t//set data length to 0 to keep the buffer alive...\n\t\tshadow->dataLength = 0;\n\t\tgf_isom_sample_del(&shadow);\n\t}\n\tif (static_sample && ! (*sample)->alloc_size )\n\t\t (*sample)->alloc_size =  (*sample)->dataLength;\n\t\t \n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_sample_for_movie_time(GF_ISOFile *the_file, u32 trackNumber, u64 movieTime, u32 *StreamDescriptionIndex, GF_ISOSearchMode SearchMode, GF_ISOSample **sample, u32 *sampleNumber, u64 *data_offset)\n{\n\tDouble tsscale;\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\tu64 mediaTime, nextMediaTime;\n\ts64 segStartTime, mediaOffset;\n\tu32 sampNum;\n\tu8 useEdit;\n\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\t//only check duration if initially set - do not check duration as updated after fragment merge since that duration does not take\n\t//into account tfdt\n\tif (trak->Header->initial_duration\n\t\t&& (movieTime * trak->moov->mvhd->timeScale > trak->Header->initial_duration * trak->Media->mediaHeader->timeScale)\n\t) {\n\t\tif (sampleNumber) *sampleNumber = 0;\n\t\t*StreamDescriptionIndex = 0;\n\t\treturn GF_EOS;\n\t}\n\n\t//get the media time for this movie time...\n\tmediaTime = segStartTime = 0;\n\t*StreamDescriptionIndex = 0;\n\tnextMediaTime = 0;\n\n\te = GetMediaTime(trak, (SearchMode==GF_ISOM_SEARCH_SYNC_FORWARD) ? GF_TRUE : GF_FALSE, movieTime, &mediaTime, &segStartTime, &mediaOffset, &useEdit, &nextMediaTime);\n\tif (e) return e;\n\n\t/*here we check if we were playing or not and return no sample in normal search modes*/\n\tif (useEdit && mediaOffset == -1) {\n\t\tif ((SearchMode==GF_ISOM_SEARCH_FORWARD) || (SearchMode==GF_ISOM_SEARCH_BACKWARD)) {\n\t\t\t/*get next sample time in MOVIE timescale*/\n\t\t\tif (SearchMode==GF_ISOM_SEARCH_FORWARD)\n\t\t\t\te = GetNextMediaTime(trak, movieTime, &mediaTime);\n\t\t\telse\n\t\t\t\te = GetPrevMediaTime(trak, movieTime, &mediaTime);\n\t\t\tif (e) return e;\n\t\t\treturn gf_isom_get_sample_for_movie_time(the_file, trackNumber, (u32) mediaTime, StreamDescriptionIndex, GF_ISOM_SEARCH_SYNC_FORWARD, sample, sampleNumber, data_offset);\n\t\t}\n\t\tif (sampleNumber) *sampleNumber = 0;\n\t\tif (sample) {\n\t\t\tif (! (*sample)) {\n\t\t\t\t*sample = gf_isom_sample_new();\n\t\t\t\tif (! *sample) return GF_OUT_OF_MEM;\n\t\t\t}\n\t\t\t(*sample)->DTS = movieTime;\n\t\t\t(*sample)->dataLength = 0;\n\t\t\t(*sample)->CTS_Offset = 0;\n\t\t}\n\t\treturn GF_OK;\n\t}\n\t/*dwell edit in non-sync mode, fetch next/prev sample depending on mode.\n\tOtherwise return the dwell entry*/\n\tif (useEdit==2) {\n\t\tif ((SearchMode==GF_ISOM_SEARCH_FORWARD) || (SearchMode==GF_ISOM_SEARCH_BACKWARD)) {\n\t\t\t/*get next sample time in MOVIE timescale*/\n\t\t\tif (SearchMode==GF_ISOM_SEARCH_FORWARD)\n\t\t\t\te = GetNextMediaTime(trak, movieTime, &mediaTime);\n\t\t\telse\n\t\t\t\te = GetPrevMediaTime(trak, movieTime, &mediaTime);\n\t\t\tif (e) return e;\n\t\t\treturn gf_isom_get_sample_for_movie_time(the_file, trackNumber, (u32) mediaTime, StreamDescriptionIndex, GF_ISOM_SEARCH_SYNC_FORWARD, sample, sampleNumber, data_offset);\n\t\t}\n\t}\n\n\ttsscale = trak->Media->mediaHeader->timeScale;\n\ttsscale /= trak->moov->mvhd->timeScale;\n\n\t//OK, we have a sample so fetch it\n\te = gf_isom_get_sample_for_media_time(the_file, trackNumber, mediaTime, StreamDescriptionIndex, SearchMode, sample, &sampNum, data_offset);\n\tif (e) {\n\t\tif (e==GF_EOS) {\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t\t\t//movie is fragmented and samples not yet received, return EOS\n\t\t\tif (the_file->moov->mvex && !trak->Media->information->sampleTable->SampleSize->sampleCount)\n\t\t\t\treturn e;\n#endif\n\n\t\t\tif (nextMediaTime && (nextMediaTime-1 != movieTime))\n\t\t\t\treturn gf_isom_get_sample_for_movie_time(the_file, trackNumber, nextMediaTime-1, StreamDescriptionIndex, SearchMode, sample, sampleNumber, data_offset);\n\t\t}\n\t\treturn e;\n\t}\n\n\t//OK, now the trick: we have to rebuild the time stamps, according\n\t//to the media time scale (used by SLConfig) - add the edit start time but stay in\n\t//the track TS\n\tif (sample && useEdit) {\n\t\tu64 _ts = (u64)(segStartTime * tsscale);\n\n\t\t(*sample)->DTS += _ts;\n\t\t/*watchout, the sample fetched may be before the first sample in the edit list (when seeking)*/\n\t\tif ( (*sample)->DTS > (u64) mediaOffset) {\n\t\t\t(*sample)->DTS -= (u64) mediaOffset;\n\t\t} else {\n\t\t\t(*sample)->DTS = 0;\n\t\t}\n\t}\n\tif (sampleNumber) *sampleNumber = sampNum;\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tif (sample && (*sample) ) (*sample)->DTS += trak->dts_at_seg_start;\n#endif\n\n\treturn GF_OK;\n}\n\n\n\nGF_EXPORT\nu64 gf_isom_get_missing_bytes(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return 0;\n\n\treturn trak->Media->BytesMissing;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_sample_padding(GF_ISOFile *the_file, u32 trackNumber, u32 padding_bytes)\n{\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\ttrak->padding_bytes = padding_bytes;\n\treturn GF_OK;\n\n}\n\n//get the number of edited segment\nGF_EXPORT\nBool gf_isom_get_edit_list_type(GF_ISOFile *the_file, u32 trackNumber, s64 *mediaOffset)\n{\n\tGF_EdtsEntry *ent;\n\tGF_TrackBox *trak;\n\tu32 count;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_FALSE;\n\t*mediaOffset = 0;\n\tif (!trak->editBox || !trak->editBox->editList) return GF_FALSE;\n\n\tcount = gf_list_count(trak->editBox->editList->entryList);\n\tent = (GF_EdtsEntry*)gf_list_get(trak->editBox->editList->entryList, 0);\n\tif (!ent) return GF_TRUE;\n\t/*mediaRate>0, the track playback shall start at media time>0 -> mediaOffset is < 0 */\n\tif ((count==1) && (ent->mediaRate == 0x10000)) {\n\t\t*mediaOffset = - ent->mediaTime;\n\t\treturn GF_FALSE;\n\t} else if (count==2) {\n\t\t/*mediaRate==-1, the track playback shall be empty for segmentDuration -> mediaOffset is > 0 */\n\t\tif ((ent->mediaRate == -0x10000) || (ent->mediaTime==-1)) {\n\t\t\tDouble time = (Double) ent->segmentDuration;\n\t\t\ttime /= trak->moov->mvhd->timeScale;\n\t\t\ttime *= trak->Media->mediaHeader->timeScale;\n\t\t\t*mediaOffset = (s64) time;\n\n\t\t\t//check next entry, if we start from mediaOffset > 0 this may still result in a skip\n\t\t\tent = (GF_EdtsEntry*)gf_list_get(trak->editBox->editList->entryList, 1);\n\t\t\t//next entry playback rate is not nominal, we need edit list handling\n\t\t\tif (ent->mediaRate != 0x10000)\n\t\t\t\treturn GF_TRUE;\n\n\t\t\tif (ent->mediaTime > 0) {\n\t\t\t\t*mediaOffset -= ent->mediaTime;\n\t\t\t}\n\t\t\treturn GF_FALSE;\n\t\t}\n\t}\n\treturn GF_TRUE;\n}\n\n\n//get the number of edited segment\nGF_EXPORT\nu32 gf_isom_get_edits_count(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return 0;\n\n\tif (!trak->editBox || !trak->editBox->editList) return 0;\n\treturn gf_list_count(trak->editBox->editList->entryList);\n}\n\n\n//Get the desired segment information\nGF_EXPORT\nGF_Err gf_isom_get_edit(GF_ISOFile *the_file, u32 trackNumber, u32 SegmentIndex, u64 *EditTime, u64 *SegmentDuration, u64 *MediaTime, GF_ISOEditType *EditMode)\n{\n\tu32 i;\n\tu64 startTime;\n\tGF_TrackBox *trak;\n\tGF_EditListBox *elst;\n\tGF_EdtsEntry *ent;\n\n\tent = NULL;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tif (!trak->editBox ||\n\t        !trak->editBox->editList ||\n\t        (SegmentIndex > gf_list_count(trak->editBox->editList->entryList)) ||\n\t        !SegmentIndex)\n\t\treturn GF_BAD_PARAM;\n\n\telst = trak->editBox->editList;\n\tstartTime = 0;\n\n\tfor (i = 0; i < SegmentIndex; i++) {\n\t\tent = (GF_EdtsEntry*)gf_list_get(elst->entryList, i);\n\t\tif (i < SegmentIndex-1) startTime += ent->segmentDuration;\n\t}\n\t*EditTime = startTime;\n\t*SegmentDuration = ent->segmentDuration;\n\tif (ent->mediaTime < 0) {\n\t\t*MediaTime = 0;\n\t\t*EditMode = GF_ISOM_EDIT_EMPTY;\n\t\treturn GF_OK;\n\t}\n\tif (ent->mediaRate == 0) {\n\t\t*MediaTime = ent->mediaTime;\n\t\t*EditMode = GF_ISOM_EDIT_DWELL;\n\t\treturn GF_OK;\n\t}\n\t*MediaTime = ent->mediaTime;\n\t*EditMode = GF_ISOM_EDIT_NORMAL;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nu8 gf_isom_has_sync_points(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media || !trak->Media->information || !trak->Media->information->sampleTable) return 0;\n\tif (trak->Media->information->sampleTable->SyncSample) {\n\t\tif (!trak->Media->information->sampleTable->SyncSample->nb_entries) return 2;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n/*returns number of sync points*/\nGF_EXPORT\nu32 gf_isom_get_sync_point_count(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return 0;\n\tif (trak->Media->information->sampleTable->SyncSample) {\n\t\treturn trak->Media->information->sampleTable->SyncSample->nb_entries;\n\t}\n\treturn 0;\n}\n\n\nGF_EXPORT\nGF_Err gf_isom_get_brand_info(GF_ISOFile *movie, u32 *brand, u32 *minorVersion, u32 *AlternateBrandsCount)\n{\n\tif (!movie) return GF_BAD_PARAM;\n\tif (!movie->brand) {\n\t\tif (brand) *brand = GF_ISOM_BRAND_ISOM;\n\t\tif (minorVersion) *minorVersion = 1;\n\t\tif (AlternateBrandsCount) *AlternateBrandsCount = 0;\n\t\treturn GF_OK;\n\t}\n\n\tif (brand) *brand = movie->brand->majorBrand;\n\tif (minorVersion) *minorVersion = movie->brand->minorVersion;\n\tif (AlternateBrandsCount) *AlternateBrandsCount = movie->brand->altCount;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_alternate_brand(GF_ISOFile *movie, u32 BrandIndex, u32 *brand)\n{\n\tif (!movie || !movie->brand || !brand) return GF_BAD_PARAM;\n\tif (BrandIndex > movie->brand->altCount || !BrandIndex) return GF_BAD_PARAM;\n\t*brand = movie->brand->altBrand[BrandIndex-1];\n\treturn GF_OK;\n}\n\nGF_EXPORT\nconst u32 *gf_isom_get_brands(GF_ISOFile *movie)\n{\n\tif (!movie || !movie->brand) return NULL;\n\treturn movie->brand->altBrand;\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_sample_padding_bits(GF_ISOFile *the_file, u32 trackNumber, u32 sampleNumber, u8 *NbBits)\n{\n\tGF_TrackBox *trak;\n\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\n\t//Padding info\n\treturn stbl_GetPaddingBits(trak->Media->information->sampleTable->PaddingBits,\n\t                           sampleNumber, NbBits);\n\n}\n\n\nGF_EXPORT\nBool gf_isom_has_padding_bits(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_FALSE;\n\n\tif (trak->Media->information->sampleTable->PaddingBits) return GF_TRUE;\n\treturn GF_FALSE;\n}\n\nGF_EXPORT\nu32 gf_isom_get_udta_count(GF_ISOFile *movie, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\tGF_UserDataBox *udta;\n\tif (!movie || !movie->moov) return 0;\n\n\tif (trackNumber) {\n\t\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\t\tif (!trak) return 0;\n\t\tudta = trak->udta;\n\t} else {\n\t\tudta = movie->moov->udta;\n\t}\n\tif (udta) return gf_list_count(udta->recordList);\n\treturn 0;\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_udta_type(GF_ISOFile *movie, u32 trackNumber, u32 udta_idx, u32 *UserDataType, bin128 *UUID)\n{\n\tGF_TrackBox *trak;\n\tGF_UserDataBox *udta;\n\tGF_UserDataMap *map;\n\tif (!movie || !movie->moov || !udta_idx) return GF_BAD_PARAM;\n\n\tif (trackNumber) {\n\t\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\t\tif (!trak) return GF_OK;\n\t\tudta = trak->udta;\n\t} else {\n\t\tudta = movie->moov->udta;\n\t}\n\tif (!udta) return GF_BAD_PARAM;\n\tif (udta_idx>gf_list_count(udta->recordList)) return GF_BAD_PARAM;\n\tmap = (GF_UserDataMap*)gf_list_get(udta->recordList, udta_idx - 1);\n\tif (UserDataType) *UserDataType = map->boxType;\n\tif (UUID) memcpy(*UUID, map->uuid, 16);\n\treturn GF_OK;\n}\n\nGF_EXPORT\nu32 gf_isom_get_user_data_count(GF_ISOFile *movie, u32 trackNumber, u32 UserDataType, bin128 UUID)\n{\n\tGF_UserDataMap *map;\n\tGF_TrackBox *trak;\n\tGF_UserDataBox *udta;\n\tbin128 t;\n\tu32 i, count;\n\n\tif (!movie || !movie->moov) return 0;\n\n\tif (UserDataType == GF_ISOM_BOX_TYPE_UUID) UserDataType = 0;\n\tmemset(t, 1, 16);\n\n\tif (trackNumber) {\n\t\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\t\tif (!trak) return 0;\n\t\tudta = trak->udta;\n\t} else {\n\t\tudta = movie->moov->udta;\n\t}\n\tif (!udta) return 0;\n\n\ti=0;\n\twhile ((map = (GF_UserDataMap*)gf_list_enum(udta->recordList, &i))) {\n\t\tcount = gf_list_count(map->boxes);\n\n\t\tif ((map->boxType == GF_ISOM_BOX_TYPE_UUID) && !memcmp(map->uuid, UUID, 16)) return count;\n\t\telse if (map->boxType == UserDataType) return count;\n\t}\n\treturn 0;\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_user_data(GF_ISOFile *movie, u32 trackNumber, u32 UserDataType, bin128 UUID, u32 UserDataIndex, u8 **userData, u32 *userDataSize)\n{\n\tGF_UserDataMap *map;\n\tGF_UnknownBox *ptr;\n\tGF_BitStream *bs;\n\tu32 i;\n\tbin128 t;\n\tGF_TrackBox *trak;\n\tGF_UserDataBox *udta;\n\n\tif (!movie || !movie->moov) return GF_BAD_PARAM;\n\n\tif (trackNumber) {\n\t\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\t\tif (!trak) return GF_BAD_PARAM;\n\t\tudta = trak->udta;\n\t} else {\n\t\tudta = movie->moov->udta;\n\t}\n\tif (!udta) return GF_BAD_PARAM;\n\n\tif (UserDataType == GF_ISOM_BOX_TYPE_UUID) UserDataType = 0;\n\tmemset(t, 1, 16);\n\n\tif (!userData || !userDataSize || *userData) return GF_BAD_PARAM;\n\n\ti=0;\n\twhile ((map = (GF_UserDataMap*)gf_list_enum(udta->recordList, &i))) {\n\t\tif ((map->boxType == GF_ISOM_BOX_TYPE_UUID) && !memcmp(map->uuid, UUID, 16)) goto found;\n\t\telse if (map->boxType == UserDataType) goto found;\n\n\t}\n\treturn GF_BAD_PARAM;\n\nfound:\n\tif (UserDataIndex) {\n\t\tif (UserDataIndex > gf_list_count(map->boxes) ) return GF_BAD_PARAM;\n\t\tptr = (GF_UnknownBox*)gf_list_get(map->boxes, UserDataIndex-1);\n\n\t\tif (ptr->type == GF_ISOM_BOX_TYPE_UNKNOWN) {\n\t\t\t*userData = (char *)gf_malloc(sizeof(char)*ptr->dataSize);\n\t\t\tif (!*userData) return GF_OUT_OF_MEM;\n\t\t\tmemcpy(*userData, ptr->data, sizeof(char)*ptr->dataSize);\n\t\t\t*userDataSize = ptr->dataSize;\n\t\t\treturn GF_OK;\n\t\t} else if (ptr->type == GF_ISOM_BOX_TYPE_UUID) {\n\t\t\tGF_UnknownUUIDBox *p_uuid = (GF_UnknownUUIDBox *)ptr;\n\t\t\t*userData = (char *)gf_malloc(sizeof(char)*p_uuid->dataSize);\n\t\t\tif (!*userData) return GF_OUT_OF_MEM;\n\t\t\tmemcpy(*userData, p_uuid->data, sizeof(char)*p_uuid->dataSize);\n\t\t\t*userDataSize = p_uuid->dataSize;\n\t\t\treturn GF_OK;\n\t\t} else {\n\t\t\tchar *str = NULL;\n\t\t\tswitch (ptr->type) {\n\t\t\tcase GF_ISOM_BOX_TYPE_NAME:\n\t\t\t//case GF_QT_BOX_TYPE_NAME: same as above\n\t\t\t\tstr = ((GF_NameBox *)ptr)->string;\n\t\t\t\tbreak;\n\t\t\tcase GF_ISOM_BOX_TYPE_KIND:\n\t\t\t\tstr = ((GF_KindBox *)ptr)->value;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (str) {\n\t\t\t\tu32 len = (u32) strlen(str) + 1;\n\t\t\t\t*userData = (char *)gf_malloc(sizeof(char) * len);\n\t\t\t\tif (!*userData) return GF_OUT_OF_MEM;\n\t\t\t\tmemcpy(*userData, str, sizeof(char)*len);\n\t\t\t\t*userDataSize = len;\n\t\t\t\treturn GF_OK;\n\t\t\t}\n\t\t\treturn GF_NOT_SUPPORTED;\n\t\t}\n\t}\n\n\t//serialize all boxes\n\tbs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\ti=0;\n\twhile ( (ptr = (GF_UnknownBox*)gf_list_enum(map->boxes, &i))) {\n\t\tu32 type, s, data_size;\n\t\tchar *data=NULL;\n\t\tif (ptr->type == GF_ISOM_BOX_TYPE_UNKNOWN) {\n\t\t\ttype = ptr->original_4cc;\n\t\t\tdata_size = ptr->dataSize;\n\t\t\tdata = ptr->data;\n\t\t} else if (ptr->type == GF_ISOM_BOX_TYPE_UUID) {\n\t\t\tGF_UnknownUUIDBox *p_uuid = (GF_UnknownUUIDBox *)ptr;\n\t\t\ttype = p_uuid->type;\n\t\t\tdata_size = p_uuid->dataSize;\n\t\t\tdata = p_uuid->data;\n\t\t} else {\n\t\t\tgf_isom_box_write((GF_Box *)ptr, bs);\n\t\t\tcontinue;\n\t\t}\n\t\ts = data_size+8;\n\t\tif (ptr->type==GF_ISOM_BOX_TYPE_UUID) s += 16;\n\n\t\tgf_bs_write_u32(bs, s);\n\t\tgf_bs_write_u32(bs, type);\n\t\tif (type==GF_ISOM_BOX_TYPE_UUID) gf_bs_write_data(bs, (char *) map->uuid, 16);\n\t\tif (data) {\n\t\t\tgf_bs_write_data(bs, data, data_size);\n\t\t} else if (ptr->child_boxes) {\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\t\t\tgf_isom_box_array_write((GF_Box *)ptr, ptr->child_boxes, bs);\n#else\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"ISOBMF: udta is a box-list - cannot export in read-only version of libisom in GPAC\\n\" ));\n#endif\n\t\t}\n\t}\n\tgf_bs_get_content(bs, userData, userDataSize);\n\tgf_bs_del(bs);\n\treturn GF_OK;\n}\n\nGF_EXPORT\nvoid gf_isom_delete(GF_ISOFile *movie)\n{\n\t//free and return;\n\tgf_isom_delete_movie(movie);\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_chunks_infos(GF_ISOFile *movie, u32 trackNumber, u32 *dur_min, u32 *dur_avg, u32 *dur_max, u32 *size_min, u32 *size_avg, u32 *size_max)\n{\n\tGF_TrackBox *trak;\n\tu32 i, k, sample_idx, dmin, dmax, smin, smax, tot_chunks;\n\tu64 davg, savg;\n\tGF_SampleToChunkBox *stsc;\n\tGF_TimeToSampleBox *stts;\n\tif (!movie || !trackNumber || !movie->moov) return GF_BAD_PARAM;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tstsc = trak->Media->information->sampleTable->SampleToChunk;\n\tstts = trak->Media->information->sampleTable->TimeToSample;\n\tif (!stsc || !stts) return GF_ISOM_INVALID_FILE;\n\n\tdmin = smin = (u32) -1;\n\tdmax = smax = 0;\n\tdavg = savg = 0;\n\tsample_idx = 1;\n\ttot_chunks = 0;\n\tfor (i=0; i<stsc->nb_entries; i++) {\n\t\tu32 nb_chunk = 0;\n\t\tif (stsc->entries[i].samplesPerChunk >  2*trak->Media->information->sampleTable->SampleSize->sampleCount) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] likely broken stco entry (%u samples per chunk but %u samples total)\\n\", stsc->entries[i].samplesPerChunk, trak->Media->information->sampleTable->SampleSize->sampleCount));\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\t\twhile (1) {\n\t\t\tu32 chunk_dur = 0;\n\t\t\tu32 chunk_size = 0;\n\t\t\tfor (k=0; k<stsc->entries[i].samplesPerChunk; k++) {\n\t\t\t\tu64 dts;\n\t\t\t\tu32 dur;\n\t\t\t\tu32 size;\n\t\t\t\tstbl_GetSampleDTS_and_Duration(stts, k+sample_idx, &dts, &dur);\n\t\t\t\tchunk_dur += dur;\n\t\t\t\tstbl_GetSampleSize(trak->Media->information->sampleTable->SampleSize, k+sample_idx, &size);\n\t\t\t\tchunk_size += size;\n\n\t\t\t}\n\t\t\tif (dmin>chunk_dur) dmin = chunk_dur;\n\t\t\tif (dmax<chunk_dur) dmax = chunk_dur;\n\t\t\tdavg += chunk_dur;\n\t\t\tif (smin>chunk_size) smin = chunk_size;\n\t\t\tif (smax<chunk_size) smax = chunk_size;\n\t\t\tsavg += chunk_size;\n\n\t\t\ttot_chunks ++;\n\t\t\tsample_idx += stsc->entries[i].samplesPerChunk;\n\t\t\tif (i+1==stsc->nb_entries) break;\n\t\t\tnb_chunk ++;\n\t\t\tif (stsc->entries[i].firstChunk + nb_chunk == stsc->entries[i+1].firstChunk) break;\n\t\t}\n\t}\n\tif (tot_chunks) {\n\t\tdavg /= tot_chunks;\n\t\tsavg /= tot_chunks;\n\t}\n\tif (dur_min) *dur_min = dmin;\n\tif (dur_avg) *dur_avg = (u32) davg;\n\tif (dur_max) *dur_max = dmax;\n\n\tif (size_min) *size_min = smin;\n\tif (size_avg) *size_avg = (u32) savg;\n\tif (size_max) *size_max = smax;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_fragment_defaults(GF_ISOFile *the_file, u32 trackNumber,\n                                     u32 *defaultDuration, u32 *defaultSize, u32 *defaultDescriptionIndex,\n                                     u32 *defaultRandomAccess, u8 *defaultPadding, u16 *defaultDegradationPriority)\n{\n\tGF_TrackBox *trak;\n\tGF_StscEntry *sc_ent;\n\tu32 i, j, maxValue, value;\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tGF_TrackExtendsBox *trex;\n#endif\n\tGF_SampleTableBox *stbl;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\t/*if trex is already set, restore flags*/\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\ttrex = the_file->moov->mvex ? GetTrex(the_file->moov, gf_isom_get_track_id(the_file,trackNumber) ) : NULL;\n\tif (trex) {\n\t\ttrex->track = trak;\n\n\t\tif (defaultDuration) *defaultDuration = trex->def_sample_duration;\n\t\tif (defaultSize) *defaultSize = trex->def_sample_size;\n\t\tif (defaultDescriptionIndex) *defaultDescriptionIndex = trex->def_sample_desc_index;\n\t\tif (defaultRandomAccess) *defaultRandomAccess = GF_ISOM_GET_FRAG_SYNC(trex->def_sample_flags);\n\t\tif (defaultPadding) *defaultPadding = GF_ISOM_GET_FRAG_PAD(trex->def_sample_flags);\n\t\tif (defaultDegradationPriority) *defaultDegradationPriority = GF_ISOM_GET_FRAG_DEG(trex->def_sample_flags);\n\t\treturn GF_OK;\n\t}\n#endif\n\n\tstbl = trak->Media->information->sampleTable;\n\tif (!stbl->TimeToSample || !stbl->SampleSize || !stbl->SampleToChunk) return GF_ISOM_INVALID_FILE;\n\n\n\t//duration\n\tif (defaultDuration) {\n\t\tmaxValue = value = 0;\n\t\tfor (i=0; i<stbl->TimeToSample->nb_entries; i++) {\n\t\t\tif (stbl->TimeToSample->entries[i].sampleCount>maxValue) {\n\t\t\t\tvalue = stbl->TimeToSample->entries[i].sampleDelta;\n\t\t\t\tmaxValue = stbl->TimeToSample->entries[i].sampleCount;\n\t\t\t}\n\t\t}\n\t\t*defaultDuration = value;\n\t}\n\t//size\n\tif (defaultSize) {\n\t\t*defaultSize = stbl->SampleSize->sampleSize;\n\t}\n\t//descIndex\n\tif (defaultDescriptionIndex) {\n\t\tGF_SampleToChunkBox *stsc= stbl->SampleToChunk;\n\t\tmaxValue = value = 0;\n\t\tfor (i=0; i<stsc->nb_entries; i++) {\n\t\t\tsc_ent = &stsc->entries[i];\n\t\t\tif ((sc_ent->nextChunk - sc_ent->firstChunk) * sc_ent->samplesPerChunk > maxValue) {\n\t\t\t\tvalue = sc_ent->sampleDescriptionIndex;\n\t\t\t\tmaxValue = (sc_ent->nextChunk - sc_ent->firstChunk) * sc_ent->samplesPerChunk;\n\t\t\t}\n\t\t}\n\t\t*defaultDescriptionIndex = value ? value : 1;\n\t}\n\t//RAP\n\tif (defaultRandomAccess) {\n\t\t//no sync table is ALL RAP\n\t\t*defaultRandomAccess = stbl->SyncSample ? 0 : 1;\n\t\tif (stbl->SyncSample\n\t\t        && (stbl->SyncSample->nb_entries == stbl->SampleSize->sampleCount)) {\n\t\t\t*defaultRandomAccess = 1;\n\t\t}\n\t}\n\t//defaultPadding\n\tif (defaultPadding) {\n\t\t*defaultPadding = 0;\n\t\tif (stbl->PaddingBits) {\n\t\t\tmaxValue = 0;\n\t\t\tfor (i=0; i<stbl->PaddingBits->SampleCount; i++) {\n\t\t\t\tvalue = 0;\n\t\t\t\tfor (j=0; j<stbl->PaddingBits->SampleCount; j++) {\n\t\t\t\t\tif (stbl->PaddingBits->padbits[i]==stbl->PaddingBits->padbits[j]) {\n\t\t\t\t\t\tvalue ++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (value>maxValue) {\n\t\t\t\t\tmaxValue = value;\n\t\t\t\t\t*defaultPadding = stbl->PaddingBits->padbits[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t//defaultDegradationPriority\n\tif (defaultDegradationPriority) {\n\t\t*defaultDegradationPriority = 0;\n\t\tif (stbl->DegradationPriority) {\n\t\t\tmaxValue = 0;\n\t\t\tfor (i=0; i<stbl->DegradationPriority->nb_entries; i++) {\n\t\t\t\tvalue = 0;\n\t\t\t\tfor (j=0; j<stbl->DegradationPriority->nb_entries; j++) {\n\t\t\t\t\tif (stbl->DegradationPriority->priorities[i]==stbl->DegradationPriority->priorities[j]) {\n\t\t\t\t\t\tvalue ++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (value>maxValue) {\n\t\t\t\t\tmaxValue = value;\n\t\t\t\t\t*defaultDegradationPriority = stbl->DegradationPriority->priorities[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\n\nGF_EXPORT\nGF_Err gf_isom_refresh_fragmented(GF_ISOFile *movie, u64 *MissingBytes, const char *new_location)\n{\n#ifdef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\treturn GF_NOT_SUPPORTED;\n#else\n\tu64 prevsize, size;\n\tu32 i;\n\tif (!movie || !movie->movieFileMap || !movie->moov) return GF_BAD_PARAM;\n\tif (movie->openMode != GF_ISOM_OPEN_READ) return GF_BAD_PARAM;\n\n\t/*refresh size*/\n\tsize = movie->movieFileMap ? gf_bs_get_size(movie->movieFileMap->bs) : 0;\n\n\tif (new_location) {\n\t\tBool delete_map;\n\t\tGF_DataMap *previous_movie_fileMap_address = movie->movieFileMap;\n\t\tGF_Err e;\n\n\t\te = gf_isom_datamap_new(new_location, NULL, GF_ISOM_DATA_MAP_READ_ONLY, &movie->movieFileMap);\n\t\tif (e) {\n\t\t\tmovie->movieFileMap = previous_movie_fileMap_address;\n\t\t\treturn e;\n\t\t}\n\n\t\tdelete_map = (previous_movie_fileMap_address != NULL ? GF_TRUE: GF_FALSE);\n\t\tfor (i=0; i<gf_list_count(movie->moov->trackList); i++) {\n\t\t\tGF_TrackBox *trak = (GF_TrackBox *)gf_list_get(movie->moov->trackList, i);\n\t\t\tif (trak->Media->information->dataHandler == previous_movie_fileMap_address) {\n\t\t\t\t//reaasign for later destruction\n\t\t\t\ttrak->Media->information->scalableDataHandler = movie->movieFileMap;\n\t\t\t\t//reassign for Media_GetSample function\n\t\t\t\ttrak->Media->information->dataHandler = movie->movieFileMap;\n\t\t\t} else if (trak->Media->information->scalableDataHandler == previous_movie_fileMap_address) {\n\t\t\t\tdelete_map = GF_FALSE;\n\t\t\t}\n\t\t}\n\t\tif (delete_map) {\n\t\t\tgf_isom_datamap_del(previous_movie_fileMap_address);\n\t\t}\n\t}\n\n\tprevsize = gf_bs_get_refreshed_size(movie->movieFileMap->bs);\n\tif (prevsize==size) return GF_OK;\n\n\tif (!movie->moov->mvex)\n\t\treturn GF_OK;\n\n\t//ok parse root boxes\n\treturn gf_isom_parse_movie_boxes(movie, NULL, MissingBytes, GF_TRUE);\n#endif\n}\n\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\nGF_EXPORT\nvoid gf_isom_set_single_moof_mode(GF_ISOFile *movie, Bool mode)\n{\n\tmovie->single_moof_mode = mode;\n}\n#endif\n\nGF_EXPORT\nGF_Err gf_isom_reset_data_offset(GF_ISOFile *movie, u64 *top_box_start)\n{\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tu32 i, count;\n\tif (!movie || !movie->moov) return GF_BAD_PARAM;\n\tif (top_box_start) *top_box_start = movie->current_top_box_start;\n\tmovie->current_top_box_start = 0;\n\tmovie->NextMoofNumber = 0;\n\tif (movie->moov->mvex && movie->single_moof_mode) {\n\t\tmovie->single_moof_state = 0;\n\t}\n\tcount = gf_list_count(movie->moov->trackList);\n\tfor (i=0; i<count; i++) {\n\t\tGF_TrackBox *tk = gf_list_get(movie->moov->trackList, i);\n\t\ttk->first_traf_merged = GF_FALSE;\n\t}\n#endif\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_current_top_box_offset(GF_ISOFile *movie, u64 *current_top_box_offset)\n{\n\tif (!movie || !movie->moov || !current_top_box_offset) return GF_BAD_PARAM;\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\t*current_top_box_offset = movie->current_top_box_start;\n\treturn GF_OK;\n#else\n\treturn GF_NOT_SUPPORTED;\n#endif\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_removed_bytes(GF_ISOFile *movie, u64 bytes_removed)\n{\n\tif (!movie || !movie->moov) return GF_BAD_PARAM;\n\tmovie->bytes_removed = bytes_removed;\n\treturn GF_OK;\n}\n\nGF_Err gf_isom_purge_samples(GF_ISOFile *the_file, u32 trackNumber, u32 nb_samples)\n{\n\tGF_TrackBox *trak;\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tGF_Err e;\n\tGF_TrackExtendsBox *trex;\n\tGF_SampleTableBox *stbl;\n#endif\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\t/*if trex is already set, restore flags*/\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\ttrex = the_file->moov->mvex ? GetTrex(the_file->moov, gf_isom_get_track_id(the_file,trackNumber) ) : NULL;\n\tif (!trex) return GF_BAD_PARAM;\n\n\t//first unpack chunk offsets and CTS\n\te = stbl_UnpackOffsets(trak->Media->information->sampleTable);\n\tif (e) return e;\n\te = stbl_unpackCTS(trak->Media->information->sampleTable);\n\tif (e) return e;\n\n\tstbl = trak->Media->information->sampleTable;\n\tif (!stbl->TimeToSample || !stbl->SampleSize || !stbl->SampleToChunk) return GF_ISOM_INVALID_FILE;\n\n\t//remove at once nb_samples in stts, ctts, stsz, stco, stsc and stdp (n-times removal is way too slow)\n\t//do NOT change the order DTS, CTS, size chunk\n\tstbl_RemoveDTS(stbl, 1, nb_samples, 0);\n\tstbl_RemoveCTS(stbl, 1, nb_samples);\n\tstbl_RemoveSize(stbl, 1, nb_samples);\n\tstbl_RemoveChunk(stbl, 1, nb_samples);\n\tstbl_RemoveRedundant(stbl, 1, nb_samples);\n\n\t//then remove sample per sample for the rest, which is either\n\t//- sparse data\n\t//- allocated structure rather than memmove-able array\n\t//- not very frequent info (paddind bits)\n\twhile (nb_samples) {\n\t\tstbl_RemoveRAP(stbl, 1);\n\t\tstbl_RemoveShadow(stbl, 1);\n\t\tstbl_RemoveSubSample(stbl, 1);\n\t\tstbl_RemovePaddingBits(stbl, 1);\n\t\tstbl_RemoveSampleGroup(stbl, 1);\n\t\tnb_samples--;\n\t}\n\treturn GF_OK;\n#else\n\treturn GF_NOT_SUPPORTED;\n#endif\n}\n\n\n#define RECREATE_BOX(_a, __cast)\t\\\n    if (_a) {\t\\\n        type = _a->type;\\\n        gf_isom_box_del_parent(&stbl->child_boxes, (GF_Box *)_a);\\\n        _a = __cast gf_isom_box_new_parent(&stbl->child_boxes, type);\\\n    }\\\n\n\nGF_EXPORT\nGF_Err gf_isom_reset_tables(GF_ISOFile *movie, Bool reset_sample_count)\n{\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tu32 i, j;\n\n\tif (!movie || !movie->moov || !movie->moov->mvex) return GF_BAD_PARAM;\n\tfor (i=0; i<gf_list_count(movie->moov->trackList); i++) {\n\t\tGF_Box *a;\n\t\tGF_TrackBox *trak = (GF_TrackBox *)gf_list_get(movie->moov->trackList, i);\n\n\t\tu32 type, dur;\n\t\tu64 dts;\n\t\tGF_SampleTableBox *stbl = trak->Media->information->sampleTable;\n\n\t\ttrak->sample_count_at_seg_start += stbl->SampleSize->sampleCount;\n\t\tif (trak->sample_count_at_seg_start) {\n\t\t\tGF_Err e;\n\t\t\te = stbl_GetSampleDTS_and_Duration(stbl->TimeToSample, stbl->SampleSize->sampleCount, &dts, &dur);\n\t\t\tif (e == GF_OK) {\n\t\t\t\ttrak->dts_at_seg_start += dts + dur;\n\t\t\t}\n\t\t}\n\n\t\tRECREATE_BOX(stbl->ChunkOffset, (GF_Box *));\n\t\tRECREATE_BOX(stbl->CompositionOffset, (GF_CompositionOffsetBox *));\n\t\tRECREATE_BOX(stbl->DegradationPriority, (GF_DegradationPriorityBox *));\n\t\tRECREATE_BOX(stbl->PaddingBits, (GF_PaddingBitsBox *));\n\t\tRECREATE_BOX(stbl->SampleDep, (GF_SampleDependencyTypeBox *));\n\t\tRECREATE_BOX(stbl->SampleSize, (GF_SampleSizeBox *));\n\t\tRECREATE_BOX(stbl->SampleToChunk, (GF_SampleToChunkBox *));\n\t\tRECREATE_BOX(stbl->ShadowSync, (GF_ShadowSyncBox *));\n\t\tRECREATE_BOX(stbl->SyncSample, (GF_SyncSampleBox *));\n\t\tRECREATE_BOX(stbl->TimeToSample, (GF_TimeToSampleBox *));\n\n\t\tgf_isom_box_array_del_parent(&stbl->child_boxes, stbl->sai_offsets);\n\t\tstbl->sai_offsets = NULL;\n\n\t\tgf_isom_box_array_del_parent(&stbl->child_boxes, stbl->sai_sizes);\n\t\tstbl->sai_sizes = NULL;\n\n\t\tgf_isom_box_array_del_parent(&stbl->child_boxes, stbl->sampleGroups);\n\t\tstbl->sampleGroups = NULL;\n\n\t\tj = stbl->nb_sgpd_in_stbl;\n\t\twhile ((a = (GF_Box *)gf_list_enum(stbl->sampleGroupsDescription, &j))) {\n\t\t\tgf_isom_box_del_parent(&stbl->child_boxes, a);\n\t\t\tj--;\n\t\t\tgf_list_rem(stbl->sampleGroupsDescription, j);\n\t\t}\n\n#if 0\n\t\tj = stbl->nb_stbl_boxes;\n\t\twhile ((a = (GF_Box *)gf_list_enum(stbl->child_boxes, &j))) {\n\t\t\tgf_isom_box_del_parent(&stbl->child_boxes, a);\n\t\t\tj--;\n\t\t}\n#endif\n\n\t\tif (reset_sample_count) {\n\t\t\ttrak->Media->information->sampleTable->SampleSize->sampleCount = 0;\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t\t\ttrak->sample_count_at_seg_start = 0;\n\t\t\ttrak->dts_at_seg_start = 0;\n\t\t\ttrak->first_traf_merged = GF_FALSE;\n#endif\n\t\t}\n\n\t}\n\tif (reset_sample_count) {\n\t\tmovie->NextMoofNumber = 0;\n\t}\n#endif\n\treturn GF_OK;\n\n}\n\nGF_EXPORT\nGF_Err gf_isom_release_segment(GF_ISOFile *movie, Bool reset_tables)\n{\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tu32 i, j, base_track_sample_count;\n\tBool has_scalable;\n\tGF_Box *a;\n\tif (!movie || !movie->moov || !movie->moov->mvex) return GF_BAD_PARAM;\n\thas_scalable = gf_isom_needs_layer_reconstruction(movie);\n\tbase_track_sample_count = 0;\n\tmovie->moov->compressed_diff = 0;\n\tfor (i=0; i<gf_list_count(movie->moov->trackList); i++) {\n\t\tGF_TrackBox *trak = (GF_TrackBox*)gf_list_get(movie->moov->trackList, i);\n\t\ttrak->first_traf_merged = GF_FALSE;\n\t\tif (trak->Media->information->dataHandler == movie->movieFileMap) {\n\t\t\ttrak->Media->information->dataHandler = NULL;\n\t\t}\n\t\tif (trak->Media->information->scalableDataHandler == movie->movieFileMap) {\n\t\t\ttrak->Media->information->scalableDataHandler = NULL;\n\t\t} else {\n\t\t\tif (trak->Media->information->scalableDataHandler==trak->Media->information->dataHandler)\n\t\t\t\ttrak->Media->information->dataHandler = NULL;\n\n\t\t\tgf_isom_datamap_del(trak->Media->information->scalableDataHandler);\n\t\t\ttrak->Media->information->scalableDataHandler = NULL;\n\t\t}\n\n\n\t\tif (reset_tables) {\n\t\t\tu32 type, dur;\n\t\t\tu64 dts;\n\t\t\tGF_SampleTableBox *stbl = trak->Media->information->sampleTable;\n\n\t\t\tif (has_scalable) {\n\t\t\t\t//check if the base reference is in the file - if not, do not consider the track is scalable.\n\t\t\t\tif (gf_isom_get_reference_count(movie, i+1, GF_ISOM_REF_BASE) > 0) {\n\t\t\t\t\tu32 on_track=0;\n\t\t\t\t\tGF_TrackBox *base;\n\t\t\t\t\tgf_isom_get_reference(movie, i+1, GF_ISOM_REF_BASE, 1, &on_track);\n\n\t\t\t\t\tbase = gf_isom_get_track_from_file(movie, on_track);\n\t\t\t\t\tif (!base) {\n\t\t\t\t\t\tbase_track_sample_count=0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbase_track_sample_count = base->Media->information->sampleTable->SampleSize->sampleCount;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ttrak->sample_count_at_seg_start += base_track_sample_count ? base_track_sample_count : stbl->SampleSize->sampleCount;\n\n\t\t\tif (trak->sample_count_at_seg_start) {\n\t\t\t\tGF_Err e;\n\t\t\t\te = stbl_GetSampleDTS_and_Duration(stbl->TimeToSample, stbl->SampleSize->sampleCount, &dts, &dur);\n\t\t\t\tif (e == GF_OK) {\n\t\t\t\t\ttrak->dts_at_seg_start += dts + dur;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tRECREATE_BOX(stbl->ChunkOffset, (GF_Box *));\n\t\t\tRECREATE_BOX(stbl->CompositionOffset, (GF_CompositionOffsetBox *));\n\t\t\tRECREATE_BOX(stbl->DegradationPriority, (GF_DegradationPriorityBox *));\n\t\t\tRECREATE_BOX(stbl->PaddingBits, (GF_PaddingBitsBox *));\n\t\t\tRECREATE_BOX(stbl->SampleDep, (GF_SampleDependencyTypeBox *));\n\t\t\tRECREATE_BOX(stbl->SampleSize, (GF_SampleSizeBox *));\n\t\t\tRECREATE_BOX(stbl->SampleToChunk, (GF_SampleToChunkBox *));\n\t\t\tRECREATE_BOX(stbl->ShadowSync, (GF_ShadowSyncBox *));\n\t\t\tRECREATE_BOX(stbl->SyncSample, (GF_SyncSampleBox *));\n\t\t\tRECREATE_BOX(stbl->TimeToSample, (GF_TimeToSampleBox *));\n\n\t\t\tgf_isom_box_array_del_parent(&stbl->child_boxes, stbl->sai_offsets);\n\t\t\tstbl->sai_offsets = NULL;\n\n\t\t\tgf_isom_box_array_del_parent(&stbl->child_boxes, stbl->sai_sizes);\n\t\t\tstbl->sai_sizes = NULL;\n\n\t\t\tgf_isom_box_array_del_parent(&stbl->child_boxes, stbl->sampleGroups);\n\t\t\tstbl->sampleGroups = NULL;\n\n\t\t\tif (trak->sample_encryption) {\n\t\t\t\tif (trak->Media->information->sampleTable->child_boxes) {\n\t\t\t\t\tgf_list_del_item(trak->Media->information->sampleTable->child_boxes, trak->sample_encryption);\n\t\t\t\t}\n\t\t\t\tgf_isom_box_del_parent(&trak->child_boxes, (GF_Box*)trak->sample_encryption);\n\t\t\t\ttrak->sample_encryption = NULL;\n\t\t\t}\n\n\t\t\tj = stbl->nb_sgpd_in_stbl;\n\t\t\twhile ((a = (GF_Box *)gf_list_enum(stbl->sampleGroupsDescription, &j))) {\n\t\t\t\tgf_isom_box_del_parent(&stbl->child_boxes, a);\n\t\t\t\tj--;\n\t\t\t\tgf_list_rem(stbl->sampleGroupsDescription, j);\n\t\t\t}\n\n\t\t\tif (stbl->traf_map) {\n\t\t\t\tfor (j=0; j<stbl->traf_map->nb_entries; j++) {\n\t\t\t\t\tif (stbl->traf_map->frag_starts[j].moof_template)\n\t\t\t\t\t\tgf_free(stbl->traf_map->frag_starts[j].moof_template);\n\t\t\t\t}\n\t\t\t\tmemset(stbl->traf_map->frag_starts, 0, sizeof(GF_TrafMapEntry)*stbl->traf_map->nb_alloc);\n\t\t\t\tstbl->traf_map->nb_entries = 0;\n\t\t\t}\n\n#if 0 // TO CHECK\n\t\t\tj = ptr->nb_stbl_boxes;\n\t\t\twhile ((a = (GF_Box *)gf_list_enum(stbl->child_boxes, &j))) {\n\t\t\t\tgf_isom_box_del_parent(&stbl->child_boxes, a);\n\t\t\t\tj--;\n\t\t\t}\n#endif\n\t\t}\n\n\n\t\tj = 0;\n\t\twhile ((a = (GF_Box *)gf_list_enum(movie->moov->child_boxes, &j))) {\n\t\t\tif (a->type == GF_ISOM_BOX_TYPE_PSSH) {\n\t\t\t\tgf_isom_box_del_parent(&movie->moov->child_boxes, a);\n\t\t\t\tj--;\n\t\t\t}\n\t\t}\n\t}\n\n\tgf_isom_datamap_del(movie->movieFileMap);\n\tmovie->movieFileMap = NULL;\n#endif\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_open_segment(GF_ISOFile *movie, const char *fileName, u64 start_range, u64 end_range, GF_ISOSegOpenMode flags)\n{\n#ifdef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\treturn GF_NOT_SUPPORTED;\n#else\n\tu64 MissingBytes;\n\tGF_Err e;\n\tu32 i;\n\tBool segment_map_assigned = GF_FALSE;\n\tBool is_scalable_segment = (flags & GF_ISOM_SEGMENT_SCALABLE_FLAG) ? GF_TRUE : GF_FALSE;\n\tBool no_order_check = (flags & GF_ISOM_SEGMENT_NO_ORDER_FLAG) ? GF_TRUE: GF_FALSE;\n\tGF_DataMap *tmp = NULL;\n\tGF_DataMap *orig_file_map = NULL;\n\tif (!movie || !movie->moov || !movie->moov->mvex) return GF_BAD_PARAM;\n\tif (movie->openMode != GF_ISOM_OPEN_READ) return GF_BAD_PARAM;\n\n\t/*this is a scalable segment - use a temp data map for the associated track(s) but do NOT touch the movie file map*/\n\tif (is_scalable_segment) {\n\t\ttmp = NULL;\n\t\te = gf_isom_datamap_new(fileName, NULL, GF_ISOM_DATA_MAP_READ_ONLY, &tmp);\n\t\tif (e) return e;\n\n\t\torig_file_map = movie->movieFileMap;\n\t\tmovie->movieFileMap = tmp;\n\t} else {\n\t\tif (movie->movieFileMap)\n\t\t\tgf_isom_release_segment(movie, GF_FALSE);\n\n\t\te = gf_isom_datamap_new(fileName, NULL, GF_ISOM_DATA_MAP_READ_ONLY, &movie->movieFileMap);\n\t\tif (e) return e;\n\t}\n\tmovie->moov->compressed_diff = 0;\n\tmovie->current_top_box_start = 0;\n\n\tif (start_range || end_range) {\n\t\tif (end_range > start_range) {\n\t\t\tgf_bs_seek(movie->movieFileMap->bs, end_range+1);\n\t\t\tgf_bs_truncate(movie->movieFileMap->bs);\n\t\t}\n\t\tgf_bs_seek(movie->movieFileMap->bs, start_range);\n\t\tmovie->current_top_box_start = start_range;\n\t}\n\n\tfor (i=0; i<gf_list_count(movie->moov->trackList); i++) {\n\t\tGF_TrackBox *trak = (GF_TrackBox*)gf_list_get(movie->moov->trackList, i);\n\n\t\tif (!is_scalable_segment) {\n\t\t\t/*reset data handler to new segment*/\n\t\t\tif (trak->Media->information->dataHandler == NULL) {\n\t\t\t\ttrak->Media->information->dataHandler = movie->movieFileMap;\n\t\t\t}\n\t\t} else {\n\t\t\ttrak->present_in_scalable_segment = GF_FALSE;\n\t\t}\n\t}\n\tif (no_order_check) movie->NextMoofNumber = 0;\n\n\t//ok parse root boxes\n\te = gf_isom_parse_movie_boxes(movie, NULL, &MissingBytes, GF_TRUE);\n\n\tif (!is_scalable_segment)\n\t\treturn e;\n\n\tfor (i=0; i<gf_list_count(movie->moov->trackList); i++) {\n\t\tGF_TrackBox *trak = (GF_TrackBox*)gf_list_get(movie->moov->trackList, i);\n\t\tif (trak->present_in_scalable_segment) {\n\t\t\t/*store the temp dataHandler into scalableDataHandler so that it will not be destroyed\n\t\t\tif we append another representation - destruction of this data handler is done in release_segment*/\n\t\t\ttrak->Media->information->scalableDataHandler = tmp;\n\t\t\tif (!segment_map_assigned) {\n\t\t\t\ttrak->Media->information->scalableDataHandler = tmp;\n\t\t\t\tsegment_map_assigned = GF_TRUE;\n\t\t\t}\n\t\t\t//and update the regular dataHandler for the Media_GetSample function\n\t\t\ttrak->Media->information->dataHandler = tmp;\n\t\t}\n\t}\n\tmovie->movieFileMap = \torig_file_map;\n\treturn e;\n#endif\n}\n\nGF_EXPORT\nGF_ISOTrackID gf_isom_get_highest_track_in_scalable_segment(GF_ISOFile *movie, u32 for_base_track)\n{\n#ifdef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\treturn 0;\n#else\n\ts32 max_ref;\n\tu32 i, j;\n\tGF_ISOTrackID track_id;\n\n\tmax_ref = 0;\n\ttrack_id = 0;\n\tfor (i=0; i<gf_list_count(movie->moov->trackList); i++) {\n\t\ts32 ref;\n\t\tu32 ref_type = GF_ISOM_REF_SCAL;\n\t\tGF_TrackBox *trak = (GF_TrackBox*)gf_list_get(movie->moov->trackList, i);\n\t\tif (! trak->present_in_scalable_segment) continue;\n\n\t\tref = gf_isom_get_reference_count(movie, i+1, ref_type);\n\t\tif (ref<=0) {\n\t\t\t//handle implicit reconstruction for LHE1/LHV1, check sbas track ref\n\t\t\tu32 subtype = gf_isom_get_media_subtype(movie, i+1, 1);\n\t\t\tswitch (subtype) {\n\t\t\tcase GF_ISOM_SUBTYPE_LHE1:\n\t\t\tcase GF_ISOM_SUBTYPE_LHV1:\n\t\t\t\tref = gf_isom_get_reference_count(movie, i+1, GF_ISOM_REF_BASE);\n\t\t\t\tif (ref<=0) continue;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (ref<=max_ref) continue;\n\n\t\tfor (j=0; j< (u32) ref; j++) {\n\t\t\tu32 on_track=0;\n\t\t\tgf_isom_get_reference(movie, i+1, GF_ISOM_REF_BASE, j+1, &on_track);\n\t\t\tif (on_track==for_base_track) {\n\t\t\t\tmax_ref = ref;\n\t\t\t\ttrack_id = trak->Header->trackID;\n\t\t\t}\n\t\t}\n\t}\n\treturn track_id;\n#endif\n}\n\n\nGF_EXPORT\nGF_Err gf_isom_text_set_streaming_mode(GF_ISOFile *movie, Bool do_convert)\n{\n\tif (!movie) return GF_BAD_PARAM;\n\tmovie->convert_streaming_text = do_convert;\n\treturn GF_OK;\n}\n\n\nGF_EXPORT\nGF_GenericSampleDescription *gf_isom_get_generic_sample_description(GF_ISOFile *movie, u32 trackNumber, u32 StreamDescriptionIndex)\n{\n\tGF_GenericVisualSampleEntryBox *entry;\n\tGF_GenericAudioSampleEntryBox *gena;\n\tGF_GenericSampleEntryBox *genm;\n\tGF_TrackBox *trak;\n\tGF_GenericSampleDescription *udesc;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !StreamDescriptionIndex || !trak->Media || !trak->Media->information || !trak->Media->information->sampleTable) return 0;\n\n\tentry = (GF_GenericVisualSampleEntryBox *)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, StreamDescriptionIndex-1);\n\t//no entry or MPEG entry:\n\tif (!entry || IsMP4Description(entry->type) ) return NULL;\n\t//if we handle the description return false\n\tswitch (entry->type) {\n\tcase GF_ISOM_SUBTYPE_3GP_AMR:\n\tcase GF_ISOM_SUBTYPE_3GP_AMR_WB:\n\tcase GF_ISOM_SUBTYPE_3GP_EVRC:\n\tcase GF_ISOM_SUBTYPE_3GP_QCELP:\n\tcase GF_ISOM_SUBTYPE_3GP_SMV:\n\tcase GF_ISOM_SUBTYPE_3GP_H263:\n\t\treturn NULL;\n\tcase GF_ISOM_BOX_TYPE_GNRV:\n\t\tGF_SAFEALLOC(udesc, GF_GenericSampleDescription);\n\t\tif (!udesc) return NULL;\n\t\tif (entry->EntryType == GF_ISOM_BOX_TYPE_UUID) {\n\t\t\tmemcpy(udesc->UUID, ((GF_UUIDBox*)entry)->uuid, sizeof(bin128));\n\t\t} else {\n\t\t\tudesc->codec_tag = entry->EntryType;\n\t\t}\n\t\tudesc->version = entry->version;\n\t\tudesc->revision = entry->revision;\n\t\tudesc->vendor_code = entry->vendor;\n\t\tudesc->temporal_quality = entry->temporal_quality;\n\t\tudesc->spatial_quality = entry->spatial_quality;\n\t\tudesc->width = entry->Width;\n\t\tudesc->height = entry->Height;\n\t\tudesc->h_res = entry->horiz_res;\n\t\tudesc->v_res = entry->vert_res;\n\t\tstrcpy(udesc->compressor_name, entry->compressor_name);\n\t\tudesc->depth = entry->bit_depth;\n\t\tudesc->color_table_index = entry->color_table_index;\n\t\tif (entry->data_size) {\n\t\t\tudesc->extension_buf_size = entry->data_size;\n\t\t\tudesc->extension_buf = (char*)gf_malloc(sizeof(char) * entry->data_size);\n\t\t\tif (!udesc->extension_buf) {\n\t\t\t\tgf_free(udesc);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tmemcpy(udesc->extension_buf, entry->data, entry->data_size);\n\t\t}\n\t\treturn udesc;\n\tcase GF_ISOM_BOX_TYPE_GNRA:\n\t\tgena = (GF_GenericAudioSampleEntryBox *)entry;\n\t\tGF_SAFEALLOC(udesc, GF_GenericSampleDescription);\n\t\tif (!udesc) return NULL;\n\t\tif (gena->EntryType == GF_ISOM_BOX_TYPE_UUID) {\n\t\t\tmemcpy(udesc->UUID, ((GF_UUIDBox*)gena)->uuid, sizeof(bin128));\n\t\t} else {\n\t\t\tudesc->codec_tag = gena->EntryType;\n\t\t}\n\t\tudesc->version = gena->version;\n\t\tudesc->revision = gena->revision;\n\t\tudesc->vendor_code = gena->vendor;\n\t\tudesc->samplerate = gena->samplerate_hi;\n\t\tudesc->bits_per_sample = gena->bitspersample;\n\t\tudesc->nb_channels = gena->channel_count;\n\t\tif (gena->data_size) {\n\t\t\tudesc->extension_buf_size = gena->data_size;\n\t\t\tudesc->extension_buf = (char*)gf_malloc(sizeof(char) * gena->data_size);\n\t\t\tif (!udesc->extension_buf) {\n\t\t\t\tgf_free(udesc);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tmemcpy(udesc->extension_buf, gena->data, gena->data_size);\n\t\t}\n\t\treturn udesc;\n\tcase GF_ISOM_BOX_TYPE_GNRM:\n\t\tgenm = (GF_GenericSampleEntryBox *)entry;\n\t\tGF_SAFEALLOC(udesc, GF_GenericSampleDescription);\n\t\tif (!udesc) return NULL;\n\t\tif (genm->EntryType == GF_ISOM_BOX_TYPE_UUID) {\n\t\t\tmemcpy(udesc->UUID, ((GF_UUIDBox*)genm)->uuid, sizeof(bin128));\n\t\t} else {\n\t\t\tudesc->codec_tag = genm->EntryType;\n\t\t}\n\t\tif (genm->data_size) {\n\t\t\tudesc->extension_buf_size = genm->data_size;\n\t\t\tudesc->extension_buf = (char*)gf_malloc(sizeof(char) * genm->data_size);\n\t\t\tif (!udesc->extension_buf) {\n\t\t\t\tgf_free(udesc);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tmemcpy(udesc->extension_buf, genm->data, genm->data_size);\n\t\t}\n\t\treturn udesc;\n\t}\n\treturn NULL;\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_visual_info(GF_ISOFile *movie, u32 trackNumber, u32 StreamDescriptionIndex, u32 *Width, u32 *Height)\n{\n\tGF_TrackBox *trak;\n\tGF_SampleEntryBox *entry;\n\tGF_SampleDescriptionBox *stsd;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tstsd = trak->Media->information->sampleTable->SampleDescription;\n\tif (!stsd) return movie->LastError = GF_ISOM_INVALID_FILE;\n\tif (!StreamDescriptionIndex || StreamDescriptionIndex > gf_list_count(stsd->child_boxes)) return movie->LastError = GF_BAD_PARAM;\n\n\tentry = (GF_SampleEntryBox *)gf_list_get(stsd->child_boxes, StreamDescriptionIndex - 1);\n\t//no support for generic sample entries (eg, no MPEG4 descriptor)\n\tif (entry == NULL) return GF_BAD_PARAM;\n\n\t//valid for MPEG visual, JPG and 3GPP H263\n\tif (entry->internal_type == GF_ISOM_SAMPLE_ENTRY_VIDEO) {\n\t\t*Width = ((GF_VisualSampleEntryBox*)entry)->Width;\n\t\t*Height = ((GF_VisualSampleEntryBox*)entry)->Height;\n\t} else if (trak->Media->handler->handlerType==GF_ISOM_MEDIA_SCENE) {\n\t\t*Width = trak->Header->width>>16;\n\t\t*Height = trak->Header->height>>16;\n\t} else {\n\t\treturn GF_BAD_PARAM;\n\t}\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_visual_bit_depth(GF_ISOFile* movie, u32 trackNumber, u32 StreamDescriptionIndex, u16* bitDepth)\n{\n\tGF_TrackBox* trak;\n\tGF_SampleEntryBox* entry;\n\tGF_SampleDescriptionBox* stsd;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tstsd = trak->Media->information->sampleTable->SampleDescription;\n\tif (!stsd) return movie->LastError = GF_ISOM_INVALID_FILE;\n\tif (!StreamDescriptionIndex || StreamDescriptionIndex > gf_list_count(stsd->child_boxes)) return movie->LastError = GF_BAD_PARAM;\n\n\tentry = (GF_SampleEntryBox*)gf_list_get(stsd->child_boxes, StreamDescriptionIndex - 1);\n\n\t//no support for generic sample entries (eg, no MPEG4 descriptor)\n\tif (entry == NULL) return GF_BAD_PARAM;\n\n\t//valid for MPEG visual, JPG and 3GPP H263\n\tif (entry->internal_type == GF_ISOM_SAMPLE_ENTRY_VIDEO) {\n\t\t*bitDepth = ((GF_VisualSampleEntryBox*)entry)->bit_depth;\n\t} else {\n\t\treturn GF_BAD_PARAM;\n\t}\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_audio_info(GF_ISOFile *movie, u32 trackNumber, u32 StreamDescriptionIndex, u32 *SampleRate, u32 *Channels, u32 *bitsPerSample)\n{\n\tGF_TrackBox *trak;\n\tGF_AudioSampleEntryBox *entry;\n\tGF_SampleDescriptionBox *stsd = NULL;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tif (trak->Media && trak->Media->information && trak->Media->information->sampleTable && trak->Media->information->sampleTable->SampleDescription)\n\t\tstsd = trak->Media->information->sampleTable->SampleDescription;\n\tif (!stsd) return movie->LastError = GF_ISOM_INVALID_FILE;\n\tif (!StreamDescriptionIndex || StreamDescriptionIndex > gf_list_count(stsd->child_boxes)) return movie->LastError = GF_BAD_PARAM;\n\n\tentry = (GF_AudioSampleEntryBox *)gf_list_get(stsd->child_boxes, StreamDescriptionIndex - 1);\n\t//no support for generic sample entries (eg, no MPEG4 descriptor)\n\tif (entry == NULL) return GF_BAD_PARAM;\n\n\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_AUDIO) return GF_BAD_PARAM;\n\n\tif (SampleRate) {\n\t\t(*SampleRate) = entry->samplerate_hi;\n\t\tif (entry->type==GF_ISOM_BOX_TYPE_MLPA) {\n\t\t\tu32 sr = entry->samplerate_hi;\n\t\t\tsr <<= 16;\n\t\t\tsr |= entry->samplerate_lo;\n\t\t\t(*SampleRate) = sr;\n\t\t}\n\t}\n\tif (Channels) (*Channels) = entry->channel_count;\n\tif (bitsPerSample) (*bitsPerSample) = (u8) entry->bitspersample;\n\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_audio_layout(GF_ISOFile *movie, u32 trackNumber, u32 StreamDescriptionIndex, GF_AudioChannelLayout *layout)\n{\n\tGF_TrackBox *trak;\n\tGF_SampleEntryBox *entry;\n\tGF_SampleDescriptionBox *stsd;\n\tGF_ChannelLayoutBox *chnl;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !layout) return GF_BAD_PARAM;\n\tmemset(layout, 0, sizeof(GF_AudioChannelLayout));\n\n\tstsd = trak->Media->information->sampleTable->SampleDescription;\n\tif (!stsd) return movie->LastError = GF_ISOM_INVALID_FILE;\n\tif (!StreamDescriptionIndex || StreamDescriptionIndex > gf_list_count(stsd->child_boxes)) return movie->LastError = GF_BAD_PARAM;\n\n\tentry = (GF_SampleEntryBox *)gf_list_get(stsd->child_boxes, StreamDescriptionIndex - 1);\n\t//no support for generic sample entries (eg, no MPEG4 descriptor)\n\tif (entry == NULL) return GF_BAD_PARAM;\n\n\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_AUDIO) return GF_BAD_PARAM;\n\tchnl = (GF_ChannelLayoutBox *) gf_isom_box_find_child(entry->child_boxes, GF_ISOM_BOX_TYPE_CHNL);\n\tif (!chnl) return GF_NOT_FOUND;\n\n\tmemcpy(layout, &chnl->layout, sizeof(GF_AudioChannelLayout));\n\treturn GF_OK;\n}\nGF_EXPORT\nGF_Err gf_isom_get_pixel_aspect_ratio(GF_ISOFile *movie, u32 trackNumber, u32 StreamDescriptionIndex, u32 *hSpacing, u32 *vSpacing)\n{\n\tGF_TrackBox *trak;\n\tGF_VisualSampleEntryBox *entry;\n\tGF_SampleDescriptionBox *stsd;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !hSpacing || !vSpacing) return GF_BAD_PARAM;\n\t*hSpacing = 1;\n\t*vSpacing = 1;\n\n\tstsd = trak->Media->information->sampleTable->SampleDescription;\n\tif (!stsd) return movie->LastError = GF_ISOM_INVALID_FILE;\n\tif (!StreamDescriptionIndex || StreamDescriptionIndex > gf_list_count(stsd->child_boxes)) return movie->LastError = GF_BAD_PARAM;\n\n\tentry = (GF_VisualSampleEntryBox *)gf_list_get(stsd->child_boxes, StreamDescriptionIndex - 1);\n\t//no support for generic sample entries (eg, no MPEG4 descriptor)\n\tif (entry == NULL) return GF_OK;\n\n\t//valid for MPEG visual, JPG and 3GPP H263\n\tif (entry->internal_type==GF_ISOM_SAMPLE_ENTRY_VIDEO) {\n\t\tGF_PixelAspectRatioBox *pasp = (GF_PixelAspectRatioBox *) gf_isom_box_find_child(entry->child_boxes, GF_ISOM_BOX_TYPE_PASP);\n\t\tif (pasp) {\n\t\t\t*hSpacing = pasp->hSpacing;\n\t\t\t*vSpacing = pasp->vSpacing;\n\t\t}\n\t\treturn GF_OK;\n\t} else {\n\t\treturn GF_BAD_PARAM;\n\t}\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_color_info(GF_ISOFile *movie, u32 trackNumber, u32 StreamDescriptionIndex, u32 *colour_type, u16 *colour_primaries, u16 *transfer_characteristics, u16 *matrix_coefficients, Bool *full_range_flag)\n{\n\tGF_TrackBox *trak;\n\tGF_VisualSampleEntryBox *entry;\n\tGF_SampleDescriptionBox *stsd;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tstsd = trak->Media->information->sampleTable->SampleDescription;\n\tif (!stsd) return movie->LastError = GF_ISOM_INVALID_FILE;\n\tif (!StreamDescriptionIndex || StreamDescriptionIndex > gf_list_count(stsd->child_boxes)) return movie->LastError = GF_BAD_PARAM;\n\n\tentry = (GF_VisualSampleEntryBox *)gf_list_get(stsd->child_boxes, StreamDescriptionIndex - 1);\n\t//no support for generic sample entries (eg, no MPEG4 descriptor)\n\tif (entry == NULL) return GF_OK;\n\n\t//valid for MPEG visual, JPG and 3GPP H263\n\tif (entry->internal_type!=GF_ISOM_SAMPLE_ENTRY_VIDEO) {\n\t\treturn GF_BAD_PARAM;\n\t}\n\tGF_ColourInformationBox *clr = (GF_ColourInformationBox *) gf_isom_box_find_child(entry->child_boxes, GF_ISOM_BOX_TYPE_COLR);\n\tif (!clr) return GF_NOT_FOUND;\n\n\tif (colour_type) *colour_type = clr->colour_type;\n\tif (colour_primaries) *colour_primaries = clr->colour_primaries;\n\tif (transfer_characteristics) *transfer_characteristics = clr->transfer_characteristics;\n\tif (matrix_coefficients) *matrix_coefficients = clr->matrix_coefficients;\n\tif (full_range_flag) *full_range_flag = clr->full_range_flag;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nconst char *gf_isom_get_filename(GF_ISOFile *movie)\n{\n\tif (!movie) return NULL;\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\tif (movie->finalName && !movie->fileName) return movie->finalName;\n#endif\n\treturn movie->fileName;\n}\n\n\nGF_EXPORT\nu8 gf_isom_get_pl_indication(GF_ISOFile *movie, GF_ISOProfileLevelType PL_Code)\n{\n\tGF_IsomInitialObjectDescriptor *iod;\n\tif (!movie || !movie->moov) return 0xFF;\n\tif (!movie->moov->iods || !movie->moov->iods->descriptor) return 0xFF;\n\tif (movie->moov->iods->descriptor->tag != GF_ODF_ISOM_IOD_TAG) return 0xFF;\n\n\tiod = (GF_IsomInitialObjectDescriptor *)movie->moov->iods->descriptor;\n\tswitch (PL_Code) {\n\tcase GF_ISOM_PL_AUDIO:\n\t\treturn iod->audio_profileAndLevel;\n\tcase GF_ISOM_PL_VISUAL:\n\t\treturn iod->visual_profileAndLevel;\n\tcase GF_ISOM_PL_GRAPHICS:\n\t\treturn iod->graphics_profileAndLevel;\n\tcase GF_ISOM_PL_SCENE:\n\t\treturn iod->scene_profileAndLevel;\n\tcase GF_ISOM_PL_OD:\n\t\treturn iod->OD_profileAndLevel;\n\tcase GF_ISOM_PL_INLINE:\n\t\treturn iod->inlineProfileFlag;\n\tcase GF_ISOM_PL_MPEGJ:\n\tdefault:\n\t\treturn 0xFF;\n\t}\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_track_matrix(GF_ISOFile *the_file, u32 trackNumber, u32 matrix[9])\n{\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Header) return GF_BAD_PARAM;\n\tmemcpy(matrix, trak->Header->matrix, sizeof(trak->Header->matrix));\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_track_layout_info(GF_ISOFile *movie, u32 trackNumber, u32 *width, u32 *height, s32 *translation_x, s32 *translation_y, s16 *layer)\n{\n\tGF_TrackBox *tk = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!tk) return GF_BAD_PARAM;\n\tif (width) *width = tk->Header->width>>16;\n\tif (height) *height = tk->Header->height>>16;\n\tif (layer) *layer = tk->Header->layer;\n\tif (translation_x) *translation_x = tk->Header->matrix[6] >> 16;\n\tif (translation_y) *translation_y = tk->Header->matrix[7] >> 16;\n\treturn GF_OK;\n}\n\n\n/*returns total amount of media bytes in track*/\nGF_EXPORT\nu64 gf_isom_get_media_data_size(GF_ISOFile *movie, u32 trackNumber)\n{\n\tu32 i;\n\tu64 size;\n\tGF_SampleSizeBox *stsz;\n\tGF_TrackBox *tk = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!tk) return 0;\n\tstsz = tk->Media->information->sampleTable->SampleSize;\n\tif (!stsz) return 0;\n\tif (stsz->sampleSize) return stsz->sampleSize*stsz->sampleCount;\n\tsize = 0;\n\tfor (i=0; i<stsz->sampleCount; i++) size += stsz->sizes[i];\n\treturn size;\n}\n\n\nGF_EXPORT\nvoid gf_isom_set_default_sync_track(GF_ISOFile *movie, u32 trackNumber)\n{\n\tGF_TrackBox *tk = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!tk) movie->es_id_default_sync = -1;\n\telse movie->es_id_default_sync = tk->Header->trackID;\n}\n\n\nGF_EXPORT\nBool gf_isom_is_single_av(GF_ISOFile *file)\n{\n\tu32 count, i, nb_any, nb_a, nb_v, nb_auxv, nb_pict, nb_scene, nb_od, nb_text;\n\tnb_auxv = nb_pict = nb_a = nb_v = nb_any = nb_scene = nb_od = nb_text = 0;\n\n\tif (!file->moov) return GF_FALSE;\n\tcount = gf_isom_get_track_count(file);\n\tfor (i=0; i<count; i++) {\n\t\tu32 mtype = gf_isom_get_media_type(file, i+1);\n\t\tswitch (mtype) {\n\t\tcase GF_ISOM_MEDIA_SCENE:\n\t\t\tif (gf_isom_get_sample_count(file, i+1)>1) nb_any++;\n\t\t\telse nb_scene++;\n\t\t\tbreak;\n\t\tcase GF_ISOM_MEDIA_OD:\n\t\t\tif (gf_isom_get_sample_count(file, i+1)>1) nb_any++;\n\t\t\telse nb_od++;\n\t\t\tbreak;\n\t\tcase GF_ISOM_MEDIA_TEXT:\n\t\tcase GF_ISOM_MEDIA_SUBT:\n\t\t\tnb_text++;\n\t\t\tbreak;\n\t\tcase GF_ISOM_MEDIA_AUDIO:\n\t\t\tnb_a++;\n\t\t\tbreak;\n        case GF_ISOM_MEDIA_AUXV:\n            /*discard file with images*/\n            if (gf_isom_get_sample_count(file, i+1)==1) nb_any++;\n            else nb_auxv++;\n            break;\n        case GF_ISOM_MEDIA_PICT:\n            /*discard file with images*/\n            if (gf_isom_get_sample_count(file, i+1)==1) nb_any++;\n            else nb_pict++;\n            break;\n\t\tcase GF_ISOM_MEDIA_VISUAL:\n\t\t\t/*discard file with images*/\n\t\t\tif (gf_isom_get_sample_count(file, i+1)==1) nb_any++;\n\t\t\telse nb_v++;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tnb_any++;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (nb_any) return GF_FALSE;\n\tif ((nb_scene<=1) && (nb_od<=1) && (nb_a<=1) && (nb_v+nb_pict+nb_auxv<=1) && (nb_text<=1) ) return GF_TRUE;\n\treturn GF_FALSE;\n}\n\nGF_EXPORT\nBool gf_isom_is_JPEG2000(GF_ISOFile *mov)\n{\n\treturn (mov && mov->is_jp2) ? GF_TRUE : GF_FALSE;\n}\n\nGF_EXPORT\nu32 gf_isom_guess_specification(GF_ISOFile *file)\n{\n\tu32 count, i, nb_any, nb_m4s, nb_a, nb_v, nb_auxv,nb_scene, nb_od, nb_mp3, nb_aac, nb_m4v, nb_avc, nb_amr, nb_h263, nb_qcelp, nb_evrc, nb_smv, nb_text, nb_pict;\n\n\tnb_m4s = nb_a = nb_v = nb_auxv = nb_any = nb_scene = nb_od = nb_mp3 = nb_aac = nb_m4v = nb_avc = nb_amr = nb_h263 = nb_qcelp = nb_evrc = nb_smv = nb_text = nb_pict = 0;\n\n\tif (file->is_jp2) {\n\t\tif (file->moov) return GF_ISOM_BRAND_MJP2;\n\t\treturn GF_ISOM_BRAND_JP2;\n\t}\n\tif (!file->moov) {\n\t\tif (!file->meta || !file->meta->handler) return 0;\n\t\treturn file->meta->handler->handlerType;\n\t}\n\n\tcount = gf_isom_get_track_count(file);\n\tfor (i=0; i<count; i++) {\n\t\tu32 mtype = gf_isom_get_media_type(file, i+1);\n\t\tu32 mstype = gf_isom_get_media_subtype(file, i+1, 1);\n\n\t\tif (mtype==GF_ISOM_MEDIA_SCENE) {\n\t\t\tnb_scene++;\n\t\t\t/*forces non-isma*/\n\t\t\tif (gf_isom_get_sample_count(file, i+1)>1) nb_m4s++;\n\t\t} else if (mtype==GF_ISOM_MEDIA_OD) {\n\t\t\tnb_od++;\n\t\t\t/*forces non-isma*/\n\t\t\tif (gf_isom_get_sample_count(file, i+1)>1) nb_m4s++;\n\t\t}\n\t\telse if ((mtype==GF_ISOM_MEDIA_TEXT) || (mtype==GF_ISOM_MEDIA_SUBT)) nb_text++;\n\t\telse if ((mtype==GF_ISOM_MEDIA_AUDIO) || gf_isom_is_video_handler_type(mtype) ) {\n\t\t\tswitch (mstype) {\n\t\t\tcase GF_ISOM_SUBTYPE_3GP_AMR:\n\t\t\tcase GF_ISOM_SUBTYPE_3GP_AMR_WB:\n\t\t\t\tnb_amr++;\n\t\t\t\tbreak;\n\t\t\tcase GF_ISOM_SUBTYPE_3GP_H263:\n\t\t\t\tnb_h263++;\n\t\t\t\tbreak;\n\t\t\tcase GF_ISOM_SUBTYPE_3GP_EVRC:\n\t\t\t\tnb_evrc++;\n\t\t\t\tbreak;\n\t\t\tcase GF_ISOM_SUBTYPE_3GP_QCELP:\n\t\t\t\tnb_qcelp++;\n\t\t\t\tbreak;\n\t\t\tcase GF_ISOM_SUBTYPE_3GP_SMV:\n\t\t\t\tnb_smv++;\n\t\t\t\tbreak;\n\t\t\tcase GF_ISOM_SUBTYPE_AVC_H264:\n\t\t\tcase GF_ISOM_SUBTYPE_AVC2_H264:\n\t\t\tcase GF_ISOM_SUBTYPE_AVC3_H264:\n\t\t\tcase GF_ISOM_SUBTYPE_AVC4_H264:\n\t\t\t\tnb_avc++;\n\t\t\t\tbreak;\n\t\t\tcase GF_ISOM_SUBTYPE_SVC_H264:\n\t\t\tcase GF_ISOM_SUBTYPE_MVC_H264:\n\t\t\t\tnb_avc++;\n\t\t\t\tbreak;\n\t\t\tcase GF_ISOM_SUBTYPE_MPEG4:\n\t\t\tcase GF_ISOM_SUBTYPE_MPEG4_CRYP:\n\t\t\t{\n\t\t\t\tGF_DecoderConfig *dcd = gf_isom_get_decoder_config(file, i+1, 1);\n\t\t\t\tswitch (dcd->streamType) {\n\t\t\t\tcase GF_STREAM_VISUAL:\n\t\t\t\t\tif (dcd->objectTypeIndication==GF_CODECID_MPEG4_PART2) nb_m4v++;\n\t\t\t\t\telse if ((dcd->objectTypeIndication==GF_CODECID_AVC) || (dcd->objectTypeIndication==GF_CODECID_SVC) || (dcd->objectTypeIndication==GF_CODECID_MVC)) nb_avc++;\n\t\t\t\t\telse nb_v++;\n\t\t\t\t\tbreak;\n\t\t\t\tcase GF_STREAM_AUDIO:\n\t\t\t\t\tswitch (dcd->objectTypeIndication) {\n\t\t\t\t\tcase GF_CODECID_AAC_MPEG2_MP:\n\t\t\t\t\tcase GF_CODECID_AAC_MPEG2_LCP:\n\t\t\t\t\tcase GF_CODECID_AAC_MPEG2_SSRP:\n\t\t\t\t\tcase GF_CODECID_AAC_MPEG4:\n\t\t\t\t\t\tnb_aac++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase GF_CODECID_MPEG2_PART3:\n\t\t\t\t\tcase GF_CODECID_MPEG_AUDIO:\n\t\t\t\t\t\tnb_mp3++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase GF_CODECID_EVRC:\n\t\t\t\t\t\tnb_evrc++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase GF_CODECID_SMV:\n\t\t\t\t\t\tnb_smv++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase GF_CODECID_QCELP:\n\t\t\t\t\t\tnb_qcelp++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tnb_a++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t/*SHOULD NEVER HAPPEN - IF SO, BROKEN MPEG4 FILE*/\n\t\t\t\tdefault:\n\t\t\t\t\tnb_any++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tgf_odf_desc_del((GF_Descriptor *)dcd);\n\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif (mtype==GF_ISOM_MEDIA_VISUAL) nb_v++;\n\t\t\t\telse if (mtype==GF_ISOM_MEDIA_AUXV) nb_auxv++;\n\t\t\t\telse if (mtype==GF_ISOM_MEDIA_PICT) nb_pict++;\n\t\t\t\telse nb_a++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if ((mtype==GF_ISOM_SUBTYPE_MPEG4) || (mtype==GF_ISOM_SUBTYPE_MPEG4_CRYP)) nb_m4s++;\n\t\telse nb_any++;\n\t}\n\tif (nb_any) return GF_ISOM_BRAND_ISOM;\n\tif (nb_qcelp || nb_evrc || nb_smv) {\n\t\t/*non std mix of streams*/\n\t\tif (nb_m4s || nb_avc || nb_scene || nb_od || nb_mp3 || nb_a || nb_v) return GF_ISOM_BRAND_ISOM;\n\t\treturn GF_ISOM_BRAND_3G2A;\n\t}\n\t/*other a/v/s streams*/\n\tif (nb_v || nb_a || nb_m4s) return GF_ISOM_BRAND_MP42;\n\n\tnb_v = nb_m4v + nb_avc + nb_h263;\n\tnb_a = nb_mp3 + nb_aac + nb_amr;\n\n\t/*avc file: whatever has AVC and no systems*/\n\tif (nb_avc) {\n\t\tif (!nb_scene && !nb_od) return GF_ISOM_BRAND_AVC1;\n\t\treturn GF_ISOM_BRAND_MP42;\n\t}\n\t/*MP3: ISMA and MPEG4*/\n\tif (nb_mp3) {\n\t\tif (!nb_text && (nb_v<=1) && (nb_a<=1) && (nb_scene==1) && (nb_od==1))\n\t\t\treturn GF_ISOM_BRAND_ISMA;\n\t\treturn GF_ISOM_BRAND_MP42;\n\t}\n\t/*MP4*/\n\tif (nb_scene || nb_od) {\n\t\t/*issue with AMR and H263 which don't have MPEG mapping: non compliant file*/\n\t\tif (nb_amr || nb_h263) return GF_ISOM_BRAND_ISOM;\n\t\treturn GF_ISOM_BRAND_MP42;\n\t}\n\t/*use ISMA (3GP fine too)*/\n\tif (!nb_amr && !nb_h263 && !nb_text) {\n\t\tif ((nb_v<=1) && (nb_a<=1)) return GF_ISOM_BRAND_ISMA;\n\t\treturn GF_ISOM_BRAND_MP42;\n\t}\n\n\tif ((nb_v<=1) && (nb_a<=1) && (nb_text<=1)) return nb_text ? GF_ISOM_BRAND_3GP6 : GF_ISOM_BRAND_3GP5;\n\treturn GF_ISOM_BRAND_3GG6;\n}\n\nGF_ItemListBox *gf_ismo_locate_box(GF_List *list, u32 boxType, bin128 UUID)\n{\n\tu32 i;\n\tGF_Box *box;\n\ti=0;\n\twhile ((box = (GF_Box *)gf_list_enum(list, &i))) {\n\t\tif (box->type == boxType) {\n\t\t\tGF_UUIDBox* box2 = (GF_UUIDBox* )box;\n\t\t\tif (boxType != GF_ISOM_BOX_TYPE_UUID) return (GF_ItemListBox *)box;\n\t\t\tif (!memcmp(box2->uuid, UUID, 16)) return (GF_ItemListBox *)box;\n\t\t}\n\t}\n\treturn NULL;\n}\n\n/*Apple extensions*/\n\n\nGF_EXPORT\nGF_Err gf_isom_apple_get_tag(GF_ISOFile *mov, GF_ISOiTunesTag tag, const u8 **data, u32 *data_len)\n{\n\tu32 i;\n\tGF_ListItemBox *info;\n\tGF_ItemListBox *ilst;\n\tGF_MetaBox *meta;\n\n\t*data = NULL;\n\t*data_len = 0;\n\n\tmeta = (GF_MetaBox *) gf_isom_get_meta_extensions(mov, GF_FALSE);\n\tif (!meta) return GF_URL_ERROR;\n\n\tilst = gf_ismo_locate_box(meta->child_boxes, GF_ISOM_BOX_TYPE_ILST, NULL);\n\tif (!ilst) return GF_URL_ERROR;\n\n\tif (tag==GF_ISOM_ITUNE_PROBE) return gf_list_count(ilst->child_boxes) ? GF_OK : GF_URL_ERROR;\n\n\ti=0;\n\twhile ( (info=(GF_ListItemBox*)gf_list_enum(ilst->child_boxes, &i))) {\n\t\tif (info->type==tag) break;\n\t\t/*special cases*/\n\t\tif ((tag==GF_ISOM_ITUNE_GENRE) && (info->type==(u32) GF_ISOM_ITUNE_GENRE_USER)) break;\n\t\tinfo = NULL;\n\t}\n\tif (!info || !info->data || !info->data->data) return GF_URL_ERROR;\n\n\tif ((tag == GF_ISOM_ITUNE_GENRE) && (info->data->flags == 0)) {\n\t\tif (info->data->dataSize && (info->data->dataSize>2) && (info->data->dataSize < 5)) {\n\t\t\tGF_BitStream* bs = gf_bs_new(info->data->data, info->data->dataSize, GF_BITSTREAM_READ);\n\t\t\t*data_len = gf_bs_read_int(bs, info->data->dataSize * 8);\n\t\t\tgf_bs_del(bs);\n\t\t\treturn GF_OK;\n\t\t}\n\t}\n//\tif (info->data->flags != 0x1) return GF_URL_ERROR;\n\t*data = info->data->data;\n\t*data_len = info->data->dataSize;\n\tif ((tag==GF_ISOM_ITUNE_COVER_ART) && (info->data->flags==14)) *data_len |= 0x80000000; //(1<<31);\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_apple_enum_tag(GF_ISOFile *mov, u32 idx, GF_ISOiTunesTag *out_tag, const u8 **data, u32 *data_len, u64 *out_int_val, u32 *out_int_val2, u32 *out_flags)\n{\n\tu32 i, child_index;\n\tGF_ListItemBox *info;\n\tGF_ItemListBox *ilst;\n\tGF_MetaBox *meta;\n\tGF_DataBox *dbox = NULL;\n\tu32 itype, tag_val;\n\ts32 tag_idx;\n\t*data = NULL;\n\t*data_len = 0;\n\n\tmeta = (GF_MetaBox *) gf_isom_get_meta_extensions(mov, GF_FALSE);\n\tif (!meta) return GF_URL_ERROR;\n\n\tilst = gf_ismo_locate_box(meta->child_boxes, GF_ISOM_BOX_TYPE_ILST, NULL);\n\tif (!ilst) return GF_URL_ERROR;\n\n\tchild_index = i = 0;\n\twhile ( (info=(GF_ListItemBox*)gf_list_enum(ilst->child_boxes, &i))) {\n\t\tGF_DataBox *data_box = NULL;\n\t\tif (gf_itags_find_by_itag(info->type)<0) {\n\t\t\tif (info->type==GF_ISOM_BOX_TYPE_UNKNOWN) {\n\t\t\t\tdata_box = (GF_DataBox *) gf_isom_box_find_child(info->child_boxes, GF_ISOM_BOX_TYPE_DATA);\n\t\t\t\tif (!data_box) continue;\n\t\t\t\ttag_val = ((GF_UnknownBox *)info)->original_4cc;\n\t\t\t}\n\t\t} else {\n\t\t\tdata_box = info->data;\n\t\t\ttag_val = info->type;\n\t\t}\n\t\tif (child_index==idx) {\n\t\t\tdbox = data_box;\n\t\t\tbreak;\n\t\t}\n\t\tchild_index++;\n\t}\n\tif (!dbox) return GF_URL_ERROR;\n\n\t*out_flags = dbox->flags;\n\t*out_tag = tag_val;\n\tif (!dbox->data) {\n\t\t*data = NULL;\n\t\t*data_len = 1;\n\t\treturn GF_OK;\n\t}\n\n\ttag_idx = gf_itags_find_by_itag(info->type);\n\tif (tag_idx<0) {\n\t\t*data = dbox->data;\n\t\t*data_len = dbox->dataSize;\n\t\treturn GF_OK;\n\t}\n\n\tif ((tag_val == GF_ISOM_ITUNE_GENRE) && (dbox->flags == 0) && (dbox->dataSize>2)) {\n\t\tu32 int_val = dbox->data[0];\n\t\tint_val <<= 8;\n\t\tint_val |= dbox->data[1];\n\t\t*data = NULL;\n\t\t*data_len = 0;\n\t\t*out_int_val = int_val;\n\t\treturn GF_OK;\n\t}\n\n\titype = gf_itags_get_type((u32) tag_idx);\n\tswitch (itype) {\n\tcase GF_ITAG_BOOL:\n\tcase GF_ITAG_INT8:\n\t\tif (dbox->dataSize) *out_int_val = dbox->data[0];\n\t\tbreak;\n\tcase GF_ITAG_INT16:\n\t\tif (dbox->dataSize>1) {\n\t\t\tu16 v = dbox->data[0];\n\t\t\tv<<=8;\n\t\t\tv |= dbox->data[1];\n\t\t\t*out_int_val = v;\n\t\t}\n\t\tbreak;\n\tcase GF_ITAG_INT32:\n\t\tif (dbox->dataSize>3) {\n\t\t\tu32 v = dbox->data[0];\n\t\t\tv<<=8;\n\t\t\tv |= dbox->data[1];\n\t\t\tv<<=8;\n\t\t\tv |= dbox->data[2];\n\t\t\tv<<=8;\n\t\t\tv |= dbox->data[3];\n\t\t\t*out_int_val = v;\n\t\t}\n\t\tbreak;\n\tcase GF_ITAG_INT64:\n\t\tif (dbox->dataSize>3) {\n\t\t\tu64 v = dbox->data[0];\n\t\t\tv<<=8;\n\t\t\tv |= dbox->data[1];\n\t\t\tv<<=8;\n\t\t\tv |= dbox->data[2];\n\t\t\tv<<=8;\n\t\t\tv |= dbox->data[3];\n\t\t\tv<<=8;\n\t\t\tv |= dbox->data[4];\n\t\t\tv<<=8;\n\t\t\tv |= dbox->data[5];\n\t\t\tv<<=8;\n\t\t\tv |= dbox->data[6];\n\t\t\tv<<=8;\n\t\t\tv |= dbox->data[7];\n\t\t\t*out_int_val = v;\n\t\t}\n\t\tbreak;\n\tcase GF_ITAG_FRAC6:\n\tcase GF_ITAG_FRAC8:\n\t\tif (dbox->dataSize>3) {\n\t\t\tu32 v = dbox->data[2];\n\t\t\tv<<=8;\n\t\t\tv |= dbox->data[3];\n\t\t\t*out_int_val = v;\n\t\t\tv = dbox->data[4];\n\t\t\tv<<=8;\n\t\t\tv |= dbox->data[5];\n\t\t\t*out_int_val2 = v;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\t*data = dbox->data;\n\t\t*data_len = dbox->dataSize;\n\t\tbreak;\n\t}\n\treturn GF_OK;\n}\n\n\nGF_EXPORT\nGF_Err gf_isom_wma_enum_tag(GF_ISOFile *mov, u32 idx, char **out_tag, const u8 **data, u32 *data_len, u32 *version, u32 *data_type)\n{\n\tGF_XtraBox *xtra;\n\tGF_XtraTag *tag;\n\n\t*out_tag = NULL;\n\t*data = NULL;\n\t*data_len = 0;\n\t*version = 0;\n\t*data_type = 0;\n\n\txtra = (GF_XtraBox *) gf_isom_get_meta_extensions(mov, GF_TRUE);\n\tif (!xtra) return GF_URL_ERROR;\n\n\ttag = gf_list_get(xtra->tags, idx);\n\tif (!tag) return GF_NOT_FOUND;\n\t*out_tag = tag->name;\n\t*data_len = tag->prop_size;\n\t*data = tag->prop_value;\n\t*version = tag->flags;\n\t*data_type = tag->prop_type;\n\treturn GF_OK;\n}\n\n\nGF_EXPORT\nGF_Err gf_isom_get_track_switch_group_count(GF_ISOFile *movie, u32 trackNumber, u32 *alternateGroupID, u32 *nb_groups)\n{\n\tGF_UserDataMap *map;\n\tGF_TrackBox *trak;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !trak->Header) return GF_BAD_PARAM;\n\t*alternateGroupID = trak->Header->alternate_group;\n\t*nb_groups = 0;\n\tif (!trak->udta) return GF_OK;\n\n\tmap = udta_getEntry(trak->udta, GF_ISOM_BOX_TYPE_TSEL, NULL);\n\tif (!map) return GF_OK;\n\t*nb_groups = gf_list_count(map->boxes);\n\treturn GF_OK;\n}\n\nGF_EXPORT\nconst u32 *gf_isom_get_track_switch_parameter(GF_ISOFile *movie, u32 trackNumber, u32 group_index, u32 *switchGroupID, u32 *criteriaListSize)\n{\n\tGF_TrackBox *trak;\n\tGF_UserDataMap *map;\n\tGF_TrackSelectionBox *tsel;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!group_index || !trak || !trak->udta) return NULL;\n\n\tmap = udta_getEntry(trak->udta, GF_ISOM_BOX_TYPE_TSEL, NULL);\n\tif (!map) return NULL;\n\ttsel = (GF_TrackSelectionBox*)gf_list_get(map->boxes, group_index-1);\n\tif (!tsel) return NULL;\n\t\n\t*switchGroupID = tsel->switchGroup;\n\t*criteriaListSize = tsel->attributeListCount;\n\treturn (const u32 *) tsel->attributeList;\n}\n\nGF_EXPORT\nu32 gf_isom_get_next_alternate_group_id(GF_ISOFile *movie)\n{\n\tu32 id = 0;\n\tu32 i=0;\n\n\twhile (i< gf_isom_get_track_count(movie) ) {\n\t\tGF_TrackBox *trak = gf_isom_get_track_from_file(movie, i+1);\n\t\tif (trak->Header->alternate_group > id)\n\t\t\tid = trak->Header->alternate_group;\n\t\ti++;\n\t}\n\treturn id+1;\n}\n\nGF_EXPORT\nu8 *gf_isom_sample_get_subsamples_buffer(GF_ISOFile *movie, u32 track, u32 sampleNumber, u32 *osize)\n{\n\tu8 *data;\n\tu32 size;\n\tu32 i, count;\n\tGF_BitStream *bs = NULL;\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(movie, track);\n\tif (!trak || !osize) return NULL;\n\tif (!trak->Media || !trak->Media->information->sampleTable || !trak->Media->information->sampleTable->sub_samples) return NULL;\n\n\tcount = gf_list_count(trak->Media->information->sampleTable->sub_samples);\n\tfor (i=0; i<count; i++) {\n\t\tu32 j, sub_count, last_sample = 0;\n\t\tGF_SubSampleInformationBox *sub_samples = gf_list_get(trak->Media->information->sampleTable->sub_samples, i);\n\n\t\tsub_count = gf_list_count(sub_samples->Samples);\n\t\tfor (j=0; j<sub_count; j++) {\n\t\t\tGF_SubSampleInfoEntry *pSamp = (GF_SubSampleInfoEntry *) gf_list_get(sub_samples->Samples, j);\n\t\t\tif (last_sample + pSamp->sample_delta == sampleNumber) {\n\t\t\t\tu32 scount = gf_list_count(pSamp->SubSamples);\n\t\t\t\tfor (j=0; j<scount; j++) {\n\t\t\t\t\tGF_SubSampleEntry *sent = gf_list_get(pSamp->SubSamples, j);\n\t\t\t\t\tif (!bs) bs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\n\t\t\t\t\tgf_bs_write_u32(bs, sub_samples->flags);\n\t\t\t\t\tgf_bs_write_u32(bs, sent->subsample_size);\n\t\t\t\t\tgf_bs_write_u32(bs, sent->reserved);\n\t\t\t\t\tgf_bs_write_u8(bs, sent->subsample_priority);\n\t\t\t\t\tgf_bs_write_u8(bs, sent->discardable);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tlast_sample += pSamp->sample_delta;\n\t\t}\n\t}\n\tif (!bs) return NULL;\n\tgf_bs_get_content(bs, &data, &size);\n\tgf_bs_del(bs);\n\t*osize = size;\n\treturn data;\n}\n\nGF_EXPORT\nu32 gf_isom_sample_has_subsamples(GF_ISOFile *movie, u32 track, u32 sampleNumber, u32 flags)\n{\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(movie, track);\n\tif (!trak) return GF_BAD_PARAM;\n\tif (!trak->Media->information->sampleTable->sub_samples) return 0;\n\tif (!sampleNumber) return 1;\n\treturn gf_isom_sample_get_subsample_entry(movie, track, sampleNumber, flags, NULL);\n}\n\nGF_EXPORT\nGF_Err gf_isom_sample_get_subsample(GF_ISOFile *movie, u32 track, u32 sampleNumber, u32 flags, u32 subSampleNumber, u32 *size, u8 *priority, u32 *reserved, Bool *discardable)\n{\n\tGF_SubSampleEntry *entry;\n\tGF_SubSampleInfoEntry *sub_sample;\n\tu32 count = gf_isom_sample_get_subsample_entry(movie, track, sampleNumber, flags, &sub_sample);\n\tif (!size || !priority || !discardable) return GF_BAD_PARAM;\n\n\tif (!subSampleNumber || (subSampleNumber>count)) return GF_BAD_PARAM;\n\tentry = (GF_SubSampleEntry*)gf_list_get(sub_sample->SubSamples, subSampleNumber-1);\n\t*size = entry->subsample_size;\n\t*priority = entry->subsample_priority;\n\t*reserved = entry->reserved;\n\t*discardable = entry->discardable ? GF_TRUE : GF_FALSE;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_rvc_config(GF_ISOFile *movie, u32 track, u32 sampleDescriptionIndex, u16 *rvc_predefined, u8 **data, u32 *size, const char **mime)\n{\n\tGF_MPEGVisualSampleEntryBox *entry;\n\tGF_TrackBox *trak;\n\n\tif (!rvc_predefined || !data || !size) return GF_BAD_PARAM;\n\t*rvc_predefined = 0;\n\n\ttrak = gf_isom_get_track_from_file(movie, track);\n\tif (!trak) return GF_BAD_PARAM;\n\n\n\tentry = (GF_MPEGVisualSampleEntryBox *) gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, sampleDescriptionIndex-1);\n\tif (!entry ) return GF_BAD_PARAM;\n\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_VIDEO) return GF_BAD_PARAM;\n\n\tGF_RVCConfigurationBox *rvcc = (GF_RVCConfigurationBox *)gf_isom_box_find_child(entry->child_boxes, GF_ISOM_BOX_TYPE_RVCC);\n\tif (!rvcc) return GF_NOT_FOUND;\n\n\t*rvc_predefined = rvcc->predefined_rvc_config;\n\tif (rvcc->rvc_meta_idx) {\n\t\tif (!data || !size) return GF_OK;\n\t\treturn gf_isom_extract_meta_item_mem(movie, GF_FALSE, track, rvcc->rvc_meta_idx, data, size, NULL, mime, GF_FALSE);\n\t}\n\treturn GF_OK;\n}\n\nGF_EXPORT\nBool gf_isom_moov_first(GF_ISOFile *movie)\n{\n\tu32 i;\n\tfor (i=0; i<gf_list_count(movie->TopBoxes); i++) {\n\t\tGF_Box *b = (GF_Box*)gf_list_get(movie->TopBoxes, i);\n\t\tif (b->type == GF_ISOM_BOX_TYPE_MOOV) return GF_TRUE;\n\t\tif (b->type == GF_ISOM_BOX_TYPE_MDAT) return GF_FALSE;\n\t}\n\treturn GF_FALSE;\n}\n\nGF_EXPORT\nvoid gf_isom_reset_fragment_info(GF_ISOFile *movie, Bool keep_sample_count)\n{\n\tu32 i;\n\tif (!movie) return;\n\tfor (i=0; i<gf_list_count(movie->moov->trackList); i++) {\n\t\tGF_TrackBox *trak = (GF_TrackBox*)gf_list_get(movie->moov->trackList, i);\n\t\ttrak->Media->information->sampleTable->SampleSize->sampleCount = 0;\n#ifdef GPAC_DISABLE_ISOM_FRAGMENTS\n\t}\n#else\n\t\t//do not reset tfdt for LL-HLS case where parts do not contain a TFDT\n\t\t//trak->dts_at_seg_start = 0;\n\t\tif (!keep_sample_count)\n\t\t\ttrak->sample_count_at_seg_start = 0;\n\t}\n\tmovie->NextMoofNumber = 0;\n#endif\n}\n\nGF_EXPORT\nvoid gf_isom_reset_seq_num(GF_ISOFile *movie)\n{\n#ifdef GPAC_DISABLE_ISOM_FRAGMENTS\n\tmovie->NextMoofNumber = 0;\n#endif\n}\n\nGF_EXPORT\nvoid gf_isom_reset_sample_count(GF_ISOFile *movie)\n{\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\tu32 i;\n\tif (!movie) return;\n\tfor (i=0; i<gf_list_count(movie->moov->trackList); i++) {\n\t\tGF_TrackBox *trak = (GF_TrackBox*)gf_list_get(movie->moov->trackList, i);\n\t\ttrak->Media->information->sampleTable->SampleSize->sampleCount = 0;\n\t\ttrak->sample_count_at_seg_start = 0;\n\t}\n\tmovie->NextMoofNumber = 0;\n#endif\n}\n\nGF_EXPORT\nBool gf_isom_has_cenc_sample_group(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\tu32 i, count;\n\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_FALSE;\n\tif (!trak->Media->information->sampleTable->sampleGroups) return GF_FALSE;\n\n\tcount = gf_list_count(trak->Media->information->sampleTable->sampleGroupsDescription);\n\tfor (i=0; i<count; i++) {\n\t\tGF_SampleGroupDescriptionBox *sgdesc = (GF_SampleGroupDescriptionBox*)gf_list_get(trak->Media->information->sampleTable->sampleGroupsDescription, i);\n\t\tif (sgdesc->grouping_type==GF_ISOM_SAMPLE_GROUP_SEIG) {\n\t\t\treturn GF_TRUE;\n\t\t}\n\t}\n\treturn GF_FALSE;\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_sample_rap_roll_info(GF_ISOFile *the_file, u32 trackNumber, u32 sample_number, Bool *is_rap, GF_ISOSampleRollType *roll_type, s32 *roll_distance)\n{\n\tGF_TrackBox *trak;\n\tu32 i, count;\n\n\tif (is_rap) *is_rap = GF_FALSE;\n\tif (roll_type) *roll_type = 0;\n\tif (roll_distance) *roll_distance = 0;\n\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\tif (!trak->Media->information->sampleTable->sampleGroups) return GF_OK;\n\n\tif (!sample_number) {\n\t\tcount = gf_list_count(trak->Media->information->sampleTable->sampleGroupsDescription);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tGF_SampleGroupDescriptionBox *sgdesc = (GF_SampleGroupDescriptionBox*)gf_list_get(trak->Media->information->sampleTable->sampleGroupsDescription, i);\n\t\t\tswitch (sgdesc->grouping_type) {\n\t\t\tcase GF_ISOM_SAMPLE_GROUP_RAP:\n\t\t\tcase GF_ISOM_SAMPLE_GROUP_SYNC:\n\t\t\t\tif (is_rap) *is_rap = GF_TRUE;\n\t\t\t\tbreak;\n\t\t\tcase GF_ISOM_SAMPLE_GROUP_ROLL:\n\t\t\tcase GF_ISOM_SAMPLE_GROUP_PROL:\n\t\t\t\tif (roll_type)\n\t\t\t\t\t*roll_type = (sgdesc->grouping_type==GF_ISOM_SAMPLE_GROUP_PROL) ? GF_ISOM_SAMPLE_PREROLL : GF_ISOM_SAMPLE_ROLL;\n\t\t\t\tif (roll_distance) {\n\t\t\t\t\ts32 max_roll = 0;\n\t\t\t\t\tu32 j;\n\t\t\t\t\tfor (j=0; j<gf_list_count(sgdesc->group_descriptions); j++) {\n\t\t\t\t\t\tGF_RollRecoveryEntry *roll_entry = (GF_RollRecoveryEntry*)gf_list_get(sgdesc->group_descriptions, j);\n\t\t\t\t\t\tif (max_roll < roll_entry->roll_distance)\n\t\t\t\t\t\t\tmax_roll = roll_entry->roll_distance;\n\t\t\t\t\t}\n\t\t\t\t\tif (*roll_distance < max_roll) *roll_distance = max_roll;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn GF_OK;\n\t}\n\n\tcount = gf_list_count(trak->Media->information->sampleTable->sampleGroups);\n\tfor (i=0; i<count; i++) {\n\t\tGF_SampleGroupBox *sg;\n\t\tu32 j, group_desc_index;\n\t\tGF_SampleGroupDescriptionBox *sgdesc;\n\t\tu32 first_sample_in_entry, last_sample_in_entry;\n\t\tfirst_sample_in_entry = 1;\n\t\tgroup_desc_index = 0;\n\t\tsg = (GF_SampleGroupBox*)gf_list_get(trak->Media->information->sampleTable->sampleGroups, i);\n\t\tfor (j=0; j<sg->entry_count; j++) {\n\t\t\tlast_sample_in_entry = first_sample_in_entry + sg->sample_entries[j].sample_count - 1;\n\t\t\tif ((sample_number<first_sample_in_entry) || (sample_number>last_sample_in_entry)) {\n\t\t\t\tfirst_sample_in_entry = last_sample_in_entry+1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/*we found our sample*/\n\t\t\tgroup_desc_index = sg->sample_entries[j].group_description_index;\n\t\t\tbreak;\n\t\t}\n\t\t/*no sampleGroup info associated*/\n\t\tif (!group_desc_index) continue;\n\n\t\tsgdesc = NULL;\n\t\tfor (j=0; j<gf_list_count(trak->Media->information->sampleTable->sampleGroupsDescription); j++) {\n\t\t\tsgdesc = (GF_SampleGroupDescriptionBox*)gf_list_get(trak->Media->information->sampleTable->sampleGroupsDescription, j);\n\t\t\tif (sgdesc->grouping_type==sg->grouping_type) break;\n\t\t\tsgdesc = NULL;\n\t\t}\n\t\t/*no sampleGroup description found for this group (invalid file)*/\n\t\tif (!sgdesc) continue;\n\n\t\tswitch (sgdesc->grouping_type) {\n\t\tcase GF_ISOM_SAMPLE_GROUP_RAP:\n\t\tcase GF_ISOM_SAMPLE_GROUP_SYNC:\n\t\t\tif (is_rap) *is_rap = GF_TRUE;\n\t\t\tbreak;\n\t\tcase GF_ISOM_SAMPLE_GROUP_ROLL:\n\t\tcase GF_ISOM_SAMPLE_GROUP_PROL:\n\t\t\tif (roll_type)\n\t\t\t\t*roll_type = (sgdesc->grouping_type==GF_ISOM_SAMPLE_GROUP_PROL) ? GF_ISOM_SAMPLE_PREROLL : GF_ISOM_SAMPLE_ROLL;\n\n\t\t\tif (roll_distance) {\n\t\t\t\tGF_RollRecoveryEntry *roll_entry = (GF_RollRecoveryEntry *) gf_list_get(sgdesc->group_descriptions, group_desc_index - 1);\n\t\t\t\tif (roll_entry)\n\t\t\t\t\t*roll_distance = roll_entry->roll_distance;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_DefaultSampleGroupDescriptionEntry * gf_isom_get_sample_group_info_entry(GF_ISOFile *the_file, GF_TrackBox *trak, u32 grouping_type, u32 sample_group_description_index, u32 *default_index, GF_SampleGroupDescriptionBox **out_sgdp)\n{\n\tu32 i, count;\n\n\tif (!trak || !sample_group_description_index) return NULL;\n\tif (!trak->Media->information->sampleTable->sampleGroupsDescription) return NULL;\n\n\tcount = gf_list_count(trak->Media->information->sampleTable->sampleGroupsDescription);\n\tfor (i=0; i<count; i++) {\n\t\tGF_SampleGroupDescriptionBox *sgdesc = (GF_SampleGroupDescriptionBox*)gf_list_get(trak->Media->information->sampleTable->sampleGroupsDescription, i);\n\t\tif (sgdesc->grouping_type != grouping_type) continue;\n\n\t\tif (sgdesc->default_description_index && !sample_group_description_index) sample_group_description_index = sgdesc->default_description_index;\n\n\t\tif (default_index) *default_index = sgdesc->default_description_index ;\n\t\tif (out_sgdp) *out_sgdp = sgdesc;\n\n\t\tif (!sample_group_description_index) return NULL;\n\t\treturn (GF_DefaultSampleGroupDescriptionEntry*)gf_list_get(sgdesc->group_descriptions, sample_group_description_index-1);\n\t}\n\treturn NULL;\n}\n\nGF_EXPORT\nBool gf_isom_get_sample_group_info(GF_ISOFile *the_file, u32 trackNumber, u32 sample_description_index, u32 grouping_type, u32 *default_index, const u8 **data, u32 *size)\n{\n\tGF_DefaultSampleGroupDescriptionEntry *sg_entry;\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(the_file, trackNumber);\n\n\tif (default_index) *default_index = 0;\n\tif (size) *size = 0;\n\tif (data) *data = NULL;\n\n\tsg_entry = gf_isom_get_sample_group_info_entry(the_file, trak, grouping_type, sample_description_index, default_index, NULL);\n\tif (!sg_entry) return GF_FALSE;\n\n\tswitch (grouping_type) {\n\tcase GF_ISOM_SAMPLE_GROUP_RAP:\n\tcase GF_ISOM_SAMPLE_GROUP_SYNC:\n\tcase GF_ISOM_SAMPLE_GROUP_ROLL:\n\tcase GF_ISOM_SAMPLE_GROUP_SEIG:\n\tcase GF_ISOM_SAMPLE_GROUP_OINF:\n\tcase GF_ISOM_SAMPLE_GROUP_LINF:\n\t\treturn GF_TRUE;\n\tdefault:\n\t\tif (sg_entry && data) *data = (char *) sg_entry->data;\n\t\tif (sg_entry && size) *size = sg_entry->length;\n\t\treturn GF_TRUE;\n\t}\n\treturn GF_FALSE;\n}\n\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n//return the duration of the movie+fragments if known, 0 if error\nGF_EXPORT\nu64 gf_isom_get_fragmented_duration(GF_ISOFile *movie)\n{\n\tif (movie->moov->mvex && movie->moov->mvex->mehd)\n\t\treturn movie->moov->mvex->mehd->fragment_duration;\n\n\treturn 0;\n}\n//return the duration of the movie+fragments if known, 0 if error\nGF_EXPORT\nu32 gf_isom_get_fragments_count(GF_ISOFile *movie, Bool segments_only)\n{\n\tu32 i=0;\n\tu32 nb_frags = 0;\n\tGF_Box *b;\n\twhile ((b=(GF_Box*)gf_list_enum(movie->TopBoxes, &i))) {\n\t\tif (segments_only) {\n\t\t\tif (b->type==GF_ISOM_BOX_TYPE_SIDX)\n\t\t\t\tnb_frags++;\n\t\t} else {\n\t\t\tif (b->type==GF_ISOM_BOX_TYPE_MOOF)\n\t\t\t\tnb_frags++;\n\t\t}\n\t}\n\treturn nb_frags;\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_fragmented_samples_info(GF_ISOFile *movie, GF_ISOTrackID trackID, u32 *nb_samples, u64 *duration)\n{\n\tu32 i=0;\n\tu32 k, l;\n\tGF_MovieFragmentBox *moof;\n\tGF_TrackFragmentBox *traf;\n\n\t*nb_samples = 0;\n\t*duration = 0;\n\twhile ((moof=(GF_MovieFragmentBox*)gf_list_enum(movie->TopBoxes, &i))) {\n\t\tu32 j=0;\n\t\tif (moof->type!=GF_ISOM_BOX_TYPE_MOOF) continue;\n\n\t\twhile ((traf=(GF_TrackFragmentBox*)gf_list_enum( moof->TrackList, &j))) {\n\t\t\tu64 def_duration, samp_dur=0;\n\n\t\t\tif (traf->tfhd->trackID != trackID)\n\t\t\t\tcontinue;\n\n\t\t\tdef_duration = 0;\n\t\t\tif (traf->tfhd->flags & GF_ISOM_TRAF_SAMPLE_DUR) def_duration = traf->tfhd->def_sample_duration;\n\t\t\telse if (traf->trex) def_duration = traf->trex->def_sample_duration;\n\n\t\t\tfor (k=0; k<gf_list_count(traf->TrackRuns); k++) {\n\t\t\t\tGF_TrackFragmentRunBox *trun = (GF_TrackFragmentRunBox*)gf_list_get(traf->TrackRuns, k);\n\t\t\t\t*nb_samples += trun->sample_count;\n\n\t\t\t\tfor (l=0; l<trun->nb_samples; l++) {\n\t\t\t\t\tGF_TrunEntry *ent = &trun->samples[l];\n\n\t\t\t\t\tsamp_dur = def_duration;\n\t\t\t\t\tif (trun->flags & GF_ISOM_TRUN_DURATION) samp_dur = ent->Duration;\n\t\t\t\t\tif (trun->nb_samples == trun->sample_count)\n\t\t\t\t\t\t*duration += samp_dur;\n\t\t\t\t}\n\t\t\t\tif (trun->nb_samples != trun->sample_count)\n\t\t\t\t\t*duration += samp_dur * trun->sample_count;\n\t\t\t}\n\t\t}\n\t}\n\treturn GF_OK;\n}\n#endif\n\nGF_EXPORT\nGF_Err gf_isom_set_nalu_extract_mode(GF_ISOFile *the_file, u32 trackNumber, GF_ISONaluExtractMode nalu_extract_mode)\n{\n\tGF_TrackReferenceTypeBox *dpnd;\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\ttrak->extractor_mode = nalu_extract_mode;\n\n\tif (!trak->References) return GF_OK;\n\n\t/*get base*/\n\tdpnd = NULL;\n\ttrak->has_base_layer = GF_FALSE;\n\tTrack_FindRef(trak, GF_ISOM_REF_SCAL, &dpnd);\n\tif (dpnd) trak->has_base_layer = GF_TRUE;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_ISONaluExtractMode gf_isom_get_nalu_extract_mode(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return 0;\n\treturn trak->extractor_mode;\n}\n\nGF_EXPORT\ns32 gf_isom_get_composition_offset_shift(GF_ISOFile *file, u32 track)\n{\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(file, track);\n\tif (!trak) return 0;\n\tif (!trak->Media || !trak->Media->information || !trak->Media->information->sampleTable || !trak->Media->information->sampleTable->CompositionToDecode) return 0;\n\treturn trak->Media->information->sampleTable->CompositionToDecode->compositionToDTSShift;\n}\n\nGF_EXPORT\nBool gf_isom_needs_layer_reconstruction(GF_ISOFile *file)\n{\n\tu32 count, i;\n\tif (!file)\n\t\treturn GF_FALSE;\n\tcount = gf_isom_get_track_count(file);\n\tfor (i = 0; i < count; i++) {\n\t\tif (gf_isom_get_reference_count(file, i+1, GF_ISOM_REF_SCAL) > 0) {\n\t\t\treturn GF_TRUE;\n\t\t}\n\t\tif (gf_isom_get_reference_count(file, i+1, GF_ISOM_REF_SABT) > 0) {\n\t\t\treturn GF_TRUE;\n\t\t}\n\t\tswitch (gf_isom_get_media_subtype(file, i+1, 1)) {\n\t\tcase GF_ISOM_SUBTYPE_LHV1:\n\t\tcase GF_ISOM_SUBTYPE_LHE1:\n\t\tcase GF_ISOM_SUBTYPE_HVC2:\n\t\tcase GF_ISOM_SUBTYPE_HEV2:\n\t\t\tif (gf_isom_get_reference_count(file, i+1, GF_ISOM_REF_BASE) > 0) {\n\t\t\t\treturn GF_TRUE;\n\t\t\t}\n\t\t}\n\t}\n\treturn GF_FALSE;\n}\n\nGF_EXPORT\nvoid gf_isom_keep_utc_times(GF_ISOFile *file, Bool keep_utc)\n{\n\tif (!file) return;\n\tfile->keep_utc = keep_utc;\n}\n\nGF_EXPORT\nBool gf_isom_has_keep_utc_times(GF_ISOFile *file)\n{\n\tif (!file) return GF_FALSE;\n\treturn file->keep_utc;\n}\n\n\n\nGF_EXPORT\nu32 gf_isom_get_pssh_count(GF_ISOFile *file)\n{\n\tu32 count=0;\n\tu32 i=0;\n\tGF_Box *a_box;\n\tif (file->moov) {\n\t\twhile ((a_box = (GF_Box*)gf_list_enum(file->moov->child_boxes, &i))) {\n\t\t\tif (a_box->type != GF_ISOM_BOX_TYPE_PSSH) continue;\n\t\t\tcount++;\n\t\t}\n\t}\n\tif (file->meta) {\n\t\twhile ((a_box = (GF_Box*)gf_list_enum(file->meta->child_boxes, &i))) {\n\t\t\tif (a_box->type != GF_ISOM_BOX_TYPE_PSSH) continue;\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n}\n\n#if 0 //unused\n/*! gets serialized PSS\n\\param isom_file the target ISO file\n\\param pssh_index 1-based index of PSSH to query, see \\ref gf_isom_get_pssh_count\n\\param pssh_data set to a newly allocated buffer containing serialized PSSH - shall be freeed by caller\n\\param pssh_size set to the size of the allocated buffer\n\\return error if any\n*/\nGF_Err gf_isom_get_pssh(GF_ISOFile *file, u32 pssh_index, u8 **pssh_data, u32 *pssh_size)\n{\n\tGF_Err e;\n\tu32 i=0;\n\tGF_BitStream *bs;\n\tu32 count=1;\n\tGF_Box *pssh;\n\twhile ((pssh = (GF_Box *)gf_list_enum(file->moov->child_boxes, &i))) {\n\t\tif (pssh->type != GF_ISOM_BOX_TYPE_PSSH) continue;\n\t\tif (count == pssh_index) break;\n\t\tcount++;\n\t}\n\tif (!pssh) return GF_BAD_PARAM;\n\tbs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\te = gf_isom_box_write(pssh, bs);\n\tif (!e) {\n\t\tgf_bs_get_content(bs, pssh_data, pssh_size);\n\t}\n\tgf_bs_del(bs);\n\treturn e;\n}\n#endif\n\nGF_EXPORT\nGF_Err gf_isom_get_pssh_info(GF_ISOFile *file, u32 pssh_index, bin128 SystemID, u32 *version, u32 *KID_count, const bin128 **KIDs, const u8 **private_data, u32 *private_data_size)\n{\n\tu32 count=1;\n\tu32 i=0;\n\tGF_ProtectionSystemHeaderBox *pssh=NULL;\n\tif (file->moov) {\n\t\twhile ((pssh = (GF_ProtectionSystemHeaderBox *)gf_list_enum(file->moov->child_boxes, &i))) {\n\t\t\tif (pssh->type != GF_ISOM_BOX_TYPE_PSSH) continue;\n\t\t\tif (count == pssh_index) break;\n\t\t\tcount++;\n\t\t}\n\t}\n\tif (!pssh && file->meta) {\n\t\twhile ((pssh = (GF_ProtectionSystemHeaderBox *)gf_list_enum(file->meta->child_boxes, &i))) {\n\t\t\tif (pssh->type != GF_ISOM_BOX_TYPE_PSSH) continue;\n\t\t\tif (count == pssh_index) break;\n\t\t\tcount++;\n\t\t}\n\t}\n\tif (!pssh) return GF_BAD_PARAM;\n\n\tif (SystemID) memcpy(SystemID, pssh->SystemID, 16);\n\tif (version) *version = pssh->version;\n\tif (KID_count) *KID_count = pssh->KID_count;\n\tif (KIDs) *KIDs = (const bin128 *) pssh->KIDs;\n\tif (private_data_size) *private_data_size = pssh->private_data_size;\n\tif (private_data) *private_data = pssh->private_data;\n\treturn GF_OK;\n}\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\nGF_Err gf_isom_get_sample_cenc_info_internal(GF_TrackBox *trak, GF_TrackFragmentBox *traf, GF_SampleEncryptionBox *senc, u32 sample_number, Bool *IsEncrypted, u8 *crypt_byte_block, u8 *skip_byte_block, const u8 **key_info, u32 *key_info_size)\n#else\nGF_Err gf_isom_get_sample_cenc_info_internal(GF_TrackBox *trak, void *traf, GF_SampleEncryptionBox *senc, u32 sample_number, Bool *IsEncrypted, u8 *crypt_byte_block, u8 *skip_byte_block, const u8 **key_info, u32 *key_info_size)\n#endif\n{\n\tGF_SampleGroupBox *sample_group;\n\tu32 j, group_desc_index;\n\tGF_SampleGroupDescriptionBox *sgdesc;\n\tu32 i, count;\n\tu32 descIndex, chunkNum;\n\tu64 offset;\n\tu32 first_sample_in_entry, last_sample_in_entry;\n\tGF_CENCSampleEncryptionGroupEntry *entry;\n\n\tif (IsEncrypted) *IsEncrypted = GF_FALSE;\n\tif (crypt_byte_block) *crypt_byte_block = 0;\n\tif (skip_byte_block) *skip_byte_block = 0;\n\tif (key_info) *key_info = NULL;\n\tif (key_info_size) *key_info_size = 0;\n\t\n\tif (!trak) return GF_BAD_PARAM;\n\n#ifdef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tif (traf)\n\t\treturn GF_NOT_SUPPORTED;\n#else\n\tsample_number -= trak->sample_count_at_seg_start;\n#endif\n\n\tif (trak->Media->information->sampleTable->SampleSize && trak->Media->information->sampleTable->SampleSize->sampleCount>=sample_number) {\n\t\tstbl_GetSampleInfos(trak->Media->information->sampleTable, sample_number, &offset, &chunkNum, &descIndex, NULL);\n\t} else {\n\t\t//this is dump mode of fragments, we haven't merged tables yet - use current stsd idx indicated in trak\n\t\tdescIndex = trak->current_traf_stsd_idx;\n\t\tif (!descIndex) descIndex = 1;\n\t}\n\n\tgf_isom_cenc_get_default_info_internal(trak, descIndex, NULL, IsEncrypted, crypt_byte_block, skip_byte_block, key_info, key_info_size);\n\n\tsample_group = NULL;\n\tgroup_desc_index = 0;\n\tif (trak->Media->information->sampleTable->sampleGroups) {\n\t\tcount = gf_list_count(trak->Media->information->sampleTable->sampleGroups);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tsample_group = (GF_SampleGroupBox*)gf_list_get(trak->Media->information->sampleTable->sampleGroups, i);\n\t\t\tif (sample_group->grouping_type ==  GF_ISOM_SAMPLE_GROUP_SEIG)\n\t\t\t\tbreak;\n\t\t\tsample_group = NULL;\n\t\t}\n\t\tif (sample_group) {\n\t\t\tfirst_sample_in_entry = 1;\n\t\t\tfor (j=0; j<sample_group->entry_count; j++) {\n\t\t\t\tlast_sample_in_entry = first_sample_in_entry + sample_group->sample_entries[j].sample_count - 1;\n\t\t\t\tif ((sample_number<first_sample_in_entry) || (sample_number>last_sample_in_entry)) {\n\t\t\t\t\tfirst_sample_in_entry = last_sample_in_entry+1;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t/*we found our sample*/\n\t\t\t\tgroup_desc_index = sample_group->sample_entries[j].group_description_index;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\tif (!group_desc_index && traf && traf->sampleGroups) {\n\t\tcount = gf_list_count(traf->sampleGroups);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tgroup_desc_index = 0;\n\t\t\tsample_group = (GF_SampleGroupBox*)gf_list_get(traf->sampleGroups, i);\n\t\t\tif (sample_group->grouping_type ==  GF_ISOM_SAMPLE_GROUP_SEIG)\n\t\t\t\tbreak;\n\t\t\tsample_group = NULL;\n\t\t}\n\t\tif (sample_group) {\n\t\t\tfirst_sample_in_entry = 1;\n\t\t\tfor (j=0; j<sample_group->entry_count; j++) {\n\t\t\t\tlast_sample_in_entry = first_sample_in_entry + sample_group->sample_entries[j].sample_count - 1;\n\t\t\t\tif ((sample_number<first_sample_in_entry) || (sample_number>last_sample_in_entry)) {\n\t\t\t\t\tfirst_sample_in_entry = last_sample_in_entry+1;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t/*we found our sample*/\n\t\t\t\tgroup_desc_index = sample_group->sample_entries[j].group_description_index;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n#endif\n\t/*no sampleGroup info associated*/\n\tif (!group_desc_index) goto exit;\n\n\tsgdesc = NULL;\n\n\tif (group_desc_index<=0x10000) {\n\t\tfor (j=0; j<gf_list_count(trak->Media->information->sampleTable->sampleGroupsDescription); j++) {\n\t\t\tsgdesc = (GF_SampleGroupDescriptionBox*)gf_list_get(trak->Media->information->sampleTable->sampleGroupsDescription, j);\n\t\t\tif (sgdesc->grouping_type==sample_group->grouping_type) break;\n\t\t\tsgdesc = NULL;\n\t\t}\n\t}\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\telse if (traf) {\n\t\tgroup_desc_index -= 0x10000;\n\t\tfor (j=0; j<gf_list_count(traf->sampleGroupsDescription); j++) {\n\t\t\tsgdesc = (GF_SampleGroupDescriptionBox*)gf_list_get(traf->sampleGroupsDescription, j);\n\t\t\tif (sgdesc->grouping_type==sample_group->grouping_type) break;\n\t\t\tsgdesc = NULL;\n\t\t}\n\t}\n#endif\n\t/*no sampleGroup description found for this group (invalid file)*/\n\tif (!sgdesc) return GF_ISOM_INVALID_FILE;\n\n\tentry = (GF_CENCSampleEncryptionGroupEntry *) gf_list_get(sgdesc->group_descriptions, group_desc_index - 1);\n\tif (!entry) return GF_ISOM_INVALID_FILE;\n\n\tif (IsEncrypted) *IsEncrypted = entry->IsProtected;\n\tif (crypt_byte_block) *crypt_byte_block = entry->crypt_byte_block;\n\tif (skip_byte_block) *skip_byte_block = entry->skip_byte_block;\n\n\tif (key_info) *key_info = entry->key_info;\n\tif (key_info_size) *key_info_size = entry->key_info_size;\n\nexit:\n\t//in PIFF we may have default values if no TENC is present: 8 bytes for IV size\n\tif (( (senc && senc->piff_type==1) || (trak->moov && trak->moov->mov->is_smooth) ) && key_info && ! (*key_info) ) {\n\t\tif (!senc) {\n\t\t\tif (IsEncrypted) *IsEncrypted = GF_TRUE;\n\t\t\tif (key_info_size) *key_info_size = 8;\n\t\t} else {\n\t\t\tif (!senc->piff_type) {\n\t\t\t\tsenc->piff_type = 2;\n\t\t\t\tsenc->IV_size = 8;\n\t\t\t}\n\t\t\tassert(senc->IV_size);\n\t\t\tif (IsEncrypted) *IsEncrypted = GF_TRUE;\n\t\t\tif (key_info_size) *key_info_size = senc->IV_size;\n\t\t}\n\t}\n\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_sample_cenc_info(GF_ISOFile *movie, u32 track, u32 sample_number, Bool *IsEncrypted, u8 *crypt_byte_block, u8 *skip_byte_block, const u8 **key_info, u32 *key_info_size)\n{\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(movie, track);\n\tGF_SampleEncryptionBox *senc = trak->sample_encryption;\n\n\treturn gf_isom_get_sample_cenc_info_internal(trak, NULL, senc, sample_number, IsEncrypted, crypt_byte_block, skip_byte_block, key_info, key_info_size);\n}\n\n\nGF_EXPORT\nBool gf_isom_get_last_producer_time_box(GF_ISOFile *file, GF_ISOTrackID *refTrackID, u64 *ntp, u64 *timestamp, Bool reset_info)\n{\n\tif (!file) return GF_FALSE;\n\tif (refTrackID) *refTrackID = 0;\n\tif (ntp) *ntp = 0;\n\tif (timestamp) *timestamp = 0;\n\n\tif (file->last_producer_ref_time) {\n\t\tif (refTrackID) *refTrackID = file->last_producer_ref_time->refTrackID;\n\t\tif (ntp) *ntp = file->last_producer_ref_time->ntp;\n\t\tif (timestamp) *timestamp = file->last_producer_ref_time->timestamp;\n\n\t\tif (reset_info) {\n\t\t\tfile->last_producer_ref_time = NULL;\n\t\t}\n\t\treturn GF_TRUE;\n\t}\n\treturn GF_FALSE;\n}\n\nGF_EXPORT\nu64 gf_isom_get_current_tfdt(GF_ISOFile *the_file, u32 trackNumber)\n{\n#ifdef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\treturn 0;\n#else\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return 0;\n\treturn trak->dts_at_seg_start;\n#endif\n}\n\nGF_EXPORT\nu64 gf_isom_get_smooth_next_tfdt(GF_ISOFile *the_file, u32 trackNumber)\n{\n#ifdef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\treturn 0;\n#else\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return 0;\n\treturn trak->dts_at_next_seg_start;\n#endif\n}\n\nGF_EXPORT\nBool gf_isom_is_smooth_streaming_moov(GF_ISOFile *the_file)\n{\n\treturn the_file ? the_file->is_smooth : GF_FALSE;\n}\n\n\nvoid gf_isom_parse_trif_info(const u8 *data, u32 size, u32 *id, u32 *independent, Bool *full_picture, u32 *x, u32 *y, u32 *w, u32 *h)\n{\n\tGF_BitStream *bs;\n\tbs = gf_bs_new(data, size, GF_BITSTREAM_READ);\n\t*id = gf_bs_read_u16(bs);\n\tif (! gf_bs_read_int(bs, 1)) {\n\t\t*independent=0;\n\t\t*full_picture=0;\n\t\t*x = *y = *w = *h = 0;\n\t} else {\n\t\t*independent = gf_bs_read_int(bs, 2);\n\t\t*full_picture = (Bool)gf_bs_read_int(bs, 1);\n\t\t/*filter_disabled*/ gf_bs_read_int(bs, 1);\n\t\t/*has_dependency_list*/ gf_bs_read_int(bs, 1);\n\t\tgf_bs_read_int(bs, 2);\n\t\t*x = *full_picture ? 0 : gf_bs_read_u16(bs);\n\t\t*y = *full_picture ? 0 : gf_bs_read_u16(bs);\n\t\t*w = gf_bs_read_u16(bs);\n\t\t*h = gf_bs_read_u16(bs);\n\t}\n\tgf_bs_del(bs);\n}\n\nGF_EXPORT\nBool gf_isom_get_tile_info(GF_ISOFile *file, u32 trackNumber, u32 sample_description_index, u32 *default_sample_group_index, u32 *id, u32 *independent, Bool *full_picture, u32 *x, u32 *y, u32 *w, u32 *h)\n{\n\tconst u8 *data;\n\tu32 size;\n\n\tif (!gf_isom_get_sample_group_info(file, trackNumber, sample_description_index, GF_ISOM_SAMPLE_GROUP_TRIF, default_sample_group_index, &data, &size))\n\t\treturn GF_FALSE;\n\tgf_isom_parse_trif_info(data, size, id, independent, full_picture, x, y, w, h);\n\treturn GF_TRUE;\n}\n\nGF_EXPORT\nBool gf_isom_get_oinf_info(GF_ISOFile *file, u32 trackNumber, GF_OperatingPointsInformation **ptr)\n{\n\tu32 oref_track, def_index=0;\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(file, trackNumber);\n\n\tif (!ptr) return GF_FALSE;\n\n\toref_track=0;\n\tgf_isom_get_reference(file, trackNumber, GF_ISOM_REF_OREF, 1, &oref_track);\n\tif (oref_track) {\n\t\ttrak = gf_isom_get_track_from_file(file, oref_track);\n\t\tif (!trak) return GF_FALSE;\n\t}\n\n\t*ptr = (GF_OperatingPointsInformation *) gf_isom_get_sample_group_info_entry(file, trak, GF_ISOM_SAMPLE_GROUP_OINF, 1, &def_index, NULL);\n\n\treturn *ptr ? GF_TRUE : GF_FALSE;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_byte_offset(GF_ISOFile *file, s64 byte_offset)\n{\n\tif (!file) return GF_BAD_PARAM;\n\tfile->read_byte_offset = byte_offset;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nu32 gf_isom_get_nalu_length_field(GF_ISOFile *file, u32 track, u32 StreamDescriptionIndex)\n{\n\tGF_TrackBox *trak;\n\tGF_SampleEntryBox *entry;\n\tGF_MPEGVisualSampleEntryBox *ve;\n\tGF_SampleDescriptionBox *stsd;\n\n\ttrak = gf_isom_get_track_from_file(file, track);\n\tif (!trak) {\n\t\tfile->LastError = GF_BAD_PARAM;\n\t\treturn 0;\n\t}\n\n\tstsd = trak->Media->information->sampleTable->SampleDescription;\n\tif (!stsd || !StreamDescriptionIndex || StreamDescriptionIndex > gf_list_count(stsd->child_boxes)) {\n\t\tfile->LastError = GF_BAD_PARAM;\n\t\treturn 0;\n\t}\n\n\tentry = (GF_SampleEntryBox *)gf_list_get(stsd->child_boxes, StreamDescriptionIndex - 1);\n\t//no support for generic sample entries (eg, no MPEG4 descriptor)\n\tif (!entry || ! gf_isom_is_nalu_based_entry(trak->Media, entry)) {\n\t\tfile->LastError = GF_BAD_PARAM;\n\t\treturn 0;\n\t}\n\n\tve = (GF_MPEGVisualSampleEntryBox*)entry;\n\tif (ve->avc_config) return ve->avc_config->config->nal_unit_size;\n\tif (ve->svc_config) return ve->svc_config->config->nal_unit_size;\n\tif (ve->hevc_config) return ve->hevc_config->config->nal_unit_size;\n\tif (ve->lhvc_config) return ve->lhvc_config->config->nal_unit_size;\n\treturn 0;\n}\n\nGF_EXPORT\nBool gf_isom_is_video_handler_type(u32 mtype)\n{\n\tswitch (mtype) {\n\tcase GF_ISOM_MEDIA_VISUAL:\n\tcase GF_ISOM_MEDIA_AUXV:\n\tcase GF_ISOM_MEDIA_PICT:\n\t\treturn GF_TRUE;\n\tdefault:\n\t\treturn GF_FALSE;\n\t}\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_bitrate(GF_ISOFile *movie, u32 trackNumber, u32 sampleDescIndex, u32 *average_bitrate, u32 *max_bitrate, u32 *decode_buffer_size)\n{\n\tGF_BitRateBox *a;\n\tu32 i, count, mrate, arate, dbsize, type;\n\tGF_SampleEntryBox *ent;\n\tGF_ProtectionSchemeInfoBox *sinf;\n\tGF_TrackBox *trak;\n\tGF_ESDBox *esd;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !trak->Media) return GF_BAD_PARAM;\n\n\tmrate = arate = dbsize = 0;\n\tcount = gf_list_count(trak->Media->information->sampleTable->SampleDescription->child_boxes);\n\tfor (i=0; i<count; i++) {\n\t\tif ((sampleDescIndex>0) && (i+1 != sampleDescIndex)) continue;\n\n\t\tent = (GF_SampleEntryBox *)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, i);\n\t\tif (!ent) return GF_BAD_PARAM;\n\t\ta = gf_isom_sample_entry_get_bitrate(ent, GF_FALSE);\n\t\tif (a) {\n\t\t\tif (mrate<a->maxBitrate) mrate = a->maxBitrate;\n\t\t\tif (arate<a->avgBitrate) arate = a->avgBitrate;\n\t\t\tif (dbsize<a->bufferSizeDB) dbsize = a->bufferSizeDB;\n\t\t\tcontinue;\n\t\t}\n\t\ttype = ent->type;\n\t\tswitch (type) {\n\t\tcase GF_ISOM_BOX_TYPE_ENCV:\n\t\tcase GF_ISOM_BOX_TYPE_ENCA:\n\t\tcase GF_ISOM_BOX_TYPE_ENCS:\n\t\t\tsinf = (GF_ProtectionSchemeInfoBox *) gf_isom_box_find_child(ent->child_boxes, GF_ISOM_BOX_TYPE_SINF);\n\t\t\tif (sinf && sinf->original_format) type = sinf->original_format->data_format;\n\t\t\tbreak;\n\t\t}\n\t\tesd = NULL;\n\t\tswitch (type) {\n\t\tcase GF_ISOM_BOX_TYPE_MP4V:\n\t\t\tesd = ((GF_MPEGVisualSampleEntryBox *)ent)->esd;\n\t\t\tbreak;\n\t\tcase GF_ISOM_BOX_TYPE_MP4A:\n\t\t\tesd = ((GF_MPEGAudioSampleEntryBox *)ent)->esd;\n\t\t\tbreak;\n\t\tcase GF_ISOM_BOX_TYPE_MP4S:\n\t\t\tesd = ((GF_MPEGSampleEntryBox *)ent)->esd;\n\t\t\tbreak;\n\t\t}\n\t\tif (esd && esd->desc && esd->desc->decoderConfig) {\n\t\t\tif (mrate<esd->desc->decoderConfig->maxBitrate) mrate = esd->desc->decoderConfig->maxBitrate;\n\t\t\tif (arate<esd->desc->decoderConfig->avgBitrate) arate = esd->desc->decoderConfig->avgBitrate;\n\t\t\tif (dbsize<esd->desc->decoderConfig->bufferSizeDB) dbsize = esd->desc->decoderConfig->bufferSizeDB;\n\t\t}\n\t}\n\tif (average_bitrate) *average_bitrate = arate;\n\tif (max_bitrate) *max_bitrate = mrate;\n\tif (decode_buffer_size) *decode_buffer_size = dbsize;\n\treturn GF_OK;\n}\n\nvoid gf_isom_enable_traf_map_templates(GF_ISOFile *movie)\n{\n\tif (movie)\n\t\tmovie->signal_frag_bounds=GF_TRUE;\n}\n\nGF_EXPORT\nBool gf_isom_sample_is_fragment_start(GF_ISOFile *movie, u32 trackNumber, u32 sampleNum, GF_ISOFragmentBoundaryInfo *frag_info)\n{\n\tu32 i;\n\tGF_TrackBox *trak;\n\tGF_TrafToSampleMap *tmap;\n\n\tif (frag_info) memset(frag_info, 0, sizeof(GF_ISOFragmentBoundaryInfo));\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !trak->Media) return GF_FALSE;\n\tif (!trak->Media->information->sampleTable->traf_map) return GF_FALSE;\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tif (sampleNum<=trak->sample_count_at_seg_start)\n\t\treturn GF_FALSE;\n\tsampleNum -= trak->sample_count_at_seg_start;\n#endif\n\n\ttmap = trak->Media->information->sampleTable->traf_map;\n\tif (!tmap) return GF_FALSE;\n\tfor (i=0; i<tmap->nb_entries; i++) {\n\t\tGF_TrafMapEntry *finfo = &tmap->frag_starts[i];\n\t\tif (finfo->sample_num == sampleNum) {\n\t\t\tif (frag_info) {\n\t\t\t\tfrag_info->frag_start = finfo->moof_start;\n\t\t\t\tfrag_info->mdat_end = finfo->mdat_end;\n\t\t\t\tfrag_info->moof_template = finfo->moof_template;\n\t\t\t\tfrag_info->moof_template_size = finfo->moof_template_size;\n\t\t\t\tfrag_info->seg_start_plus_one = finfo->seg_start_plus_one;\n\t\t\t\tfrag_info->sidx_start = finfo->sidx_start;\n\t\t\t\tfrag_info->sidx_end = finfo->sidx_end;\n\t\t\t}\n\t\t\treturn GF_TRUE;\n\t\t}\n\n\t\tif (tmap->frag_starts[i].sample_num > sampleNum) return GF_FALSE;\n\t}\n\treturn GF_FALSE;\n}\n\n\n\n\nGF_EXPORT\nGF_Err gf_isom_get_jp2_config(GF_ISOFile *movie, u32 trackNumber, u32 sampleDesc, u8 **out_dsi, u32 *out_size)\n{\n\tGF_TrackBox *trak;\n\tGF_MPEGVisualSampleEntryBox *entry;\n\tGF_BitStream *bs;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !trak->Media || !trak->Media->information || !trak->Media->information->sampleTable || !trak->Media->information->sampleTable->SampleDescription) return GF_ISOM_INVALID_FILE;\n\tentry = (GF_MPEGVisualSampleEntryBox *) gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, sampleDesc-1);\n\tif (!entry || !entry->jp2h) return GF_BAD_PARAM;\n\tif (!entry->jp2h->ihdr) return GF_ISOM_INVALID_FILE;\n\n\tbs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\tgf_isom_box_array_write((GF_Box*)entry->jp2h, entry->jp2h->child_boxes, bs);\n\tgf_bs_get_content(bs, out_dsi, out_size);\n\tgf_bs_del(bs);\n\treturn GF_OK;\n}\n\n\nBool gf_isom_is_identical_sgpd(void *ptr1, void *ptr2, u32 grouping_type)\n{\n\tBool res = GF_FALSE;\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\tGF_BitStream *bs1, *bs2;\n\tu8 *buf1, *buf2;\n\tu32 len1, len2;\n\n\tif (!ptr1 || !ptr2)\n\t\treturn GF_FALSE;\n\n\tbs1 = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\tif (grouping_type) {\n\t\tsgpd_write_entry(grouping_type, ptr1, bs1);\n\t} else {\n\t\tgf_isom_box_size((GF_Box *)ptr1);\n\t\tgf_isom_box_write((GF_Box *)ptr1, bs1);\n\t}\n\tgf_bs_get_content(bs1, &buf1, &len1);\n\tgf_bs_del(bs1);\n\n\tbs2 = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\tif (grouping_type) {\n\t\tsgpd_write_entry(grouping_type, ptr2, bs2);\n\t} else {\n\t\tgf_isom_box_write((GF_Box *)ptr2, bs2);\n\t}\n\tgf_bs_get_content(bs2, &buf2, &len2);\n\tgf_bs_del(bs2);\n\n\n\tif ((len1==len2) && !memcmp(buf1, buf2, len1))\n\t\tres = GF_TRUE;\n\n\tgf_free(buf1);\n\tgf_free(buf2);\n#endif\n\treturn res;\n}\n\nGF_EXPORT\nu64 gf_isom_get_track_magic(GF_ISOFile *movie, u32 trackNumber)\n{\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return 0;\n\treturn trak->magic;\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_file_offset_for_time(GF_ISOFile *movie, Double start_time, u64 *max_offset)\n{\n\tu32 i;\n\tu64 start_ts, cur_start_time;\n\tu64 offset=0;\n\tif (!movie || !movie->moov)\n\t\treturn GF_BAD_PARAM;\n\n\tif (!movie->main_sidx) return GF_NOT_SUPPORTED;\n\tstart_ts = (u64) (start_time * movie->main_sidx->timescale);\n\tcur_start_time = 0;\n\toffset = movie->main_sidx->first_offset + movie->main_sidx_end_pos;\n\n\tfor (i=0; i<movie->main_sidx->nb_refs; i++) {\n\t\tif (cur_start_time >= start_ts) {\n\t\t\t*max_offset = offset;\n\t\t\treturn GF_OK;\n\t\t}\n\t\tcur_start_time += movie->main_sidx->refs[i].subsegment_duration;\n\t\toffset += movie->main_sidx->refs[i].reference_size;\n\t}\n\n\treturn GF_EOS;\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_sidx_duration(GF_ISOFile *movie, u64 *sidx_dur, u32 *sidx_timescale)\n{\n\tu64 dur=0;\n\tu32 i;\n\tif (!movie || !movie->moov || !sidx_timescale || !sidx_dur)\n\t\treturn GF_BAD_PARAM;\n\n\tif (!movie->main_sidx) return GF_NOT_SUPPORTED;\n\t*sidx_timescale = movie->main_sidx->timescale;\n\n\tfor (i=0; i<movie->main_sidx->nb_refs; i++) {\n\t\tdur += movie->main_sidx->refs[i].subsegment_duration;\n\t}\n\t*sidx_dur = dur;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nconst u8 *gf_isom_get_mpegh_compatible_profiles(GF_ISOFile *movie, u32 trackNumber, u32 sampleDescIndex, u32 *nb_compat_profiles)\n{\n\tGF_SampleEntryBox *ent;\n\tGF_MHACompatibleProfilesBox *mhap;\n\tGF_TrackBox *trak;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !trak->Media || !nb_compat_profiles) return NULL;\n\t*nb_compat_profiles = 0;\n\tent = gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, sampleDescIndex-1);\n\tif (!ent) return NULL;\n\tmhap = (GF_MHACompatibleProfilesBox *) gf_isom_box_find_child(ent->child_boxes, GF_ISOM_BOX_TYPE_MHAP);\n\tif (!mhap) return NULL;\n\t*nb_compat_profiles = mhap->num_profiles;\n\treturn mhap->compat_profiles;\n}\n\nconst void *gf_isom_get_tfrf(GF_ISOFile *movie, u32 trackNumber)\n{\n#ifdef GPAC_DISABLE_ISOM_FRAGMENTS\n\treturn NULL;\n#else\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return NULL;\n\n\treturn trak->tfrf;\n#endif\n}\n\nGF_Err gf_isom_get_y3d_info(GF_ISOFile *movie, u32 trackNumber, u32 sampleDescriptionIndex, GF_ISOM_Y3D_Info *info)\n{\n\tGF_SampleEntryBox *ent;\n\tGF_TrackBox *trak;\n\tBool found = GF_FALSE;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !trak->Media || !info) return GF_BAD_PARAM;\n\n\tent = gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, sampleDescriptionIndex-1);\n\tif (!ent) return GF_BAD_PARAM;\n\n\tmemset(info, 0, sizeof(GF_ISOM_Y3D_Info));\n\n\tGF_Stereo3DBox *st3d = (GF_Stereo3DBox *) gf_isom_box_find_child(ent->child_boxes, GF_ISOM_BOX_TYPE_ST3D);\n\tif (st3d) {\n\t\tfound = GF_TRUE;\n\t\tinfo->stereo_type = st3d->stereo_type;\n\t}\n\n\tGF_Box *sv3d = gf_isom_box_find_child(ent->child_boxes, GF_ISOM_BOX_TYPE_SV3D);\n\tif (!sv3d) {\n\t\treturn found ? GF_OK : GF_NOT_FOUND;\n\t}\n\tGF_SphericalVideoInfoBox *svhd = (GF_SphericalVideoInfoBox *) gf_isom_box_find_child(sv3d->child_boxes, GF_ISOM_BOX_TYPE_SVHD);\n\tif (svhd && strlen(svhd->string)) info->meta_data = svhd->string;\n\n\tGF_Box *proj = gf_isom_box_find_child(sv3d->child_boxes, GF_ISOM_BOX_TYPE_PROJ);\n\tif (!proj)\n\t\treturn found ? GF_OK : GF_NOT_FOUND;\n\n\tGF_ProjectionHeaderBox *projh = (GF_ProjectionHeaderBox *) gf_isom_box_find_child(proj->child_boxes, GF_ISOM_BOX_TYPE_PRHD);\n\tif (projh) {\n\t\tinfo->yaw = projh->yaw;\n\t\tinfo->pitch = projh->pitch;\n\t\tinfo->roll = projh->roll;\n\t\tinfo->pose_present = GF_TRUE;\n\t}\n\n\tGF_ProjectionTypeBox *projt = (GF_ProjectionTypeBox *) gf_isom_box_find_child(proj->child_boxes, GF_ISOM_BOX_TYPE_CBMP);\n\tif (projt) {\n\t\tinfo->layout = projt->layout;\n\t\tinfo->padding = projt->padding;\n\t\tinfo->projection_type = 1;\n\t} else {\n\t\tprojt = (GF_ProjectionTypeBox *) gf_isom_box_find_child(proj->child_boxes, GF_ISOM_BOX_TYPE_EQUI);\n\t\tif (projt) {\n\t\t\tinfo->top = projt->bounds_top;\n\t\t\tinfo->bottom = projt->bounds_bottom;\n\t\t\tinfo->left = projt->bounds_left;\n\t\t\tinfo->right = projt->bounds_right;\n\t\t\tinfo->projection_type = 2;\n\t\t} else {\n\t\t\tprojt = (GF_ProjectionTypeBox *) gf_isom_box_find_child(proj->child_boxes, GF_ISOM_BOX_TYPE_EQUI);\n\t\t\tif (projt) {\n\t\t\t\tinfo->projection_type = 3;\n\t\t\t}\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM*/\n", "/*\n *\t\t\tGPAC - Multimedia Framework C SDK\n *\n *\t\t\tAuthors: Jean Le Feuvre\n *\t\t\tCopyright (c) Telecom ParisTech 2000-2021\n *\t\t\t\t\tAll rights reserved\n *\n *  This file is part of GPAC / ISO Media File Format sub-project\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n#include <gpac/internal/isomedia_dev.h>\n#include <gpac/constants.h>\n#include <gpac/iso639.h>\n\n\n#if !defined(GPAC_DISABLE_ISOM) && !defined(GPAC_DISABLE_ISOM_WRITE)\n\nGF_Err CanAccessMovie(GF_ISOFile *movie, GF_ISOOpenMode Mode)\n{\n\tif (!movie) return GF_BAD_PARAM;\n\tif (movie->openMode < Mode) return GF_ISOM_INVALID_MODE;\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tif (movie->FragmentsFlags & GF_ISOM_FRAG_WRITE_READY) return GF_ISOM_INVALID_MODE;\n#endif\n\treturn GF_OK;\n}\n\nstatic GF_Err unpack_track(GF_TrackBox *trak)\n{\n\tGF_Err e = GF_OK;\n\tif (!trak->is_unpacked) {\n\t\te = stbl_UnpackOffsets(trak->Media->information->sampleTable);\n\t\tif (e) return e;\n\t\te = stbl_unpackCTS(trak->Media->information->sampleTable);\n\t\ttrak->is_unpacked = GF_TRUE;\n\t}\n\treturn e;\n}\n\n\nGF_Err FlushCaptureMode(GF_ISOFile *movie)\n{\n\tGF_Err e;\n\tif (movie->openMode != GF_ISOM_OPEN_WRITE) {\n\t\tif (!movie->editFileMap) return GF_ISOM_INVALID_MODE;\n\t\treturn GF_OK;\n\t}\n\t/*make sure nothing was added*/\n\tif (gf_bs_get_position(movie->editFileMap->bs)) return GF_OK;\n\n\tif (!strcmp(movie->fileName, \"_gpac_isobmff_redirect\")) {\n\t\tif (!movie->on_block_out) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[ISOBMFF] Missing output block callback, cannot write\\n\"));\n\t\t\treturn GF_BAD_PARAM;\n\t\t}\n\n\t\tgf_bs_del(movie->editFileMap->bs);\n\t\tmovie->editFileMap->bs = gf_bs_new_cbk(movie->on_block_out, movie->on_block_out_usr_data, movie->on_block_out_block_size);\n\t}\n\n\t/*add all first boxes*/\n\tif (movie->brand) {\n\t\te = gf_isom_box_size((GF_Box *)movie->brand);\n\t\tif (e) return e;\n\t\te = gf_isom_box_write((GF_Box *)movie->brand, movie->editFileMap->bs);\n\t\tif (e) return e;\n\t}\n\tif (movie->pdin) {\n\t\te = gf_isom_box_size((GF_Box *)movie->pdin);\n\t\tif (e) return e;\n\t\te = gf_isom_box_write((GF_Box *)movie->pdin, movie->editFileMap->bs);\n\t\tif (e) return e;\n\t}\n\tmovie->mdat->bsOffset = gf_bs_get_position(movie->editFileMap->bs);\n\n\t/*we have a trick here: the data will be stored on the fly, so the first\n\tthing in the file is the MDAT. As we don't know if we have a large file (>4 GB) or not\n\tdo as if we had one and write 16 bytes: 4 (type) + 4 (size) + 8 (largeSize)...*/\n\tgf_bs_write_long_int(movie->editFileMap->bs, 0, 64);\n\tgf_bs_write_long_int(movie->editFileMap->bs, 0, 64);\n\treturn GF_OK;\n}\n\nstatic GF_Err CheckNoData(GF_ISOFile *movie)\n{\n\tif (movie->openMode != GF_ISOM_OPEN_WRITE) return GF_OK;\n\tif (gf_bs_get_position(movie->editFileMap->bs)) return GF_BAD_PARAM;\n\treturn GF_OK;\n}\n\n/**************************************************************\n\t\t\t\t\tFile Writing / Editing\n**************************************************************/\n//quick function to add an IOD/OD to the file if not present (iods is optional)\nGF_Err AddMovieIOD(GF_MovieBox *moov, u8 isIOD)\n{\n\tGF_Descriptor *od;\n\tGF_ObjectDescriptorBox *iods;\n\n\t//do we have an IOD ?? If not, create one.\n\tif (moov->iods) return GF_OK;\n\n\tif (isIOD) {\n\t\tod = gf_odf_desc_new(GF_ODF_ISOM_IOD_TAG);\n\t} else {\n\t\tod = gf_odf_desc_new(GF_ODF_ISOM_OD_TAG);\n\t}\n\tif (!od) return GF_OUT_OF_MEM;\n\t((GF_IsomObjectDescriptor *)od)->objectDescriptorID = 1;\n\n\tiods = (GF_ObjectDescriptorBox *) gf_isom_box_new_parent(&moov->child_boxes, GF_ISOM_BOX_TYPE_IODS);\n\tif (!iods) return GF_OUT_OF_MEM;\n\tiods->descriptor = od;\n\treturn moov_on_child_box((GF_Box*)moov, (GF_Box *)iods, GF_FALSE);\n}\n\n//add a track to the root OD\nGF_EXPORT\nGF_Err gf_isom_add_track_to_root_od(GF_ISOFile *movie, u32 trackNumber)\n{\n\tGF_Err e;\n\tGF_ES_ID_Inc *inc;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\te = gf_isom_insert_moov(movie);\n\tif (e) return e;\n\n\tif (!movie->moov->iods) AddMovieIOD(movie->moov, 0);\n\n\tif (gf_isom_is_track_in_root_od(movie, trackNumber) == 1) return GF_OK;\n\n\tinc = (GF_ES_ID_Inc *) gf_odf_desc_new(GF_ODF_ESD_INC_TAG);\n\tinc->trackID = gf_isom_get_track_id(movie, trackNumber);\n\tif (!inc->trackID) {\n\t\tgf_odf_desc_del((GF_Descriptor *)inc);\n\t\treturn movie->LastError;\n\t}\n\tif ( (movie->LastError = gf_isom_add_desc_to_root_od(movie, (GF_Descriptor *)inc) ) ) {\n\t\treturn movie->LastError;\n\t}\n\tgf_odf_desc_del((GF_Descriptor *)inc);\n\treturn GF_OK;\n}\n\n//remove the root OD\nGF_EXPORT\nGF_Err gf_isom_remove_root_od(GF_ISOFile *movie)\n{\n\tGF_Err e;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\tif (!movie->moov || !movie->moov->iods) return GF_OK;\n\tgf_isom_box_del_parent(&movie->moov->child_boxes, (GF_Box *)movie->moov->iods);\n\tmovie->moov->iods = NULL;\n\treturn GF_OK;\n}\n\n//remove a track to the root OD\nGF_EXPORT\nGF_Err gf_isom_remove_track_from_root_od(GF_ISOFile *movie, u32 trackNumber)\n{\n\tGF_List *esds;\n\tGF_ES_ID_Inc *inc;\n\tu32 i;\n\tGF_Err e;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\tif (!movie->moov) return GF_OK;\n\n\tif (!gf_isom_is_track_in_root_od(movie, trackNumber)) return GF_OK;\n\n\tif (!movie->moov->iods) {\n\t\te = AddMovieIOD(movie->moov, 0);\n\t\tif (e) return e;\n\t}\n\tswitch (movie->moov->iods->descriptor->tag) {\n\tcase GF_ODF_ISOM_IOD_TAG:\n\t\tesds = ((GF_IsomInitialObjectDescriptor *)movie->moov->iods->descriptor)->ES_ID_IncDescriptors;\n\t\tbreak;\n\tcase GF_ODF_ISOM_OD_TAG:\n\t\tesds = ((GF_IsomObjectDescriptor *)movie->moov->iods->descriptor)->ES_ID_IncDescriptors;\n\t\tbreak;\n\tdefault:\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\n\t//get the desc\n\ti=0;\n\twhile ((inc = (GF_ES_ID_Inc*)gf_list_enum(esds, &i))) {\n\t\tif (inc->trackID == (u32) gf_isom_get_track_id(movie, trackNumber)) {\n\t\t\tgf_odf_desc_del((GF_Descriptor *)inc);\n\t\t\tgf_list_rem(esds, i-1);\n\t\t\tbreak;\n\t\t}\n\t}\n\t//we don't remove the iod for P&Ls and other potential info\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_creation_time(GF_ISOFile *movie, u64 ctime, u64 mtime)\n{\n\tif (!movie || !movie->moov) return GF_BAD_PARAM;\n\tmovie->moov->mvhd->creationTime = ctime;\n\tmovie->moov->mvhd->modificationTime = mtime;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_track_creation_time(GF_ISOFile *movie,u32 trackNumber, u64 ctime, u64 mtime)\n{\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\ttrak->Header->creationTime = ctime;\n\ttrak->Header->modificationTime = mtime;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_media_creation_time(GF_ISOFile *movie,u32 trackNumber, u64 ctime, u64 mtime)\n{\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\tif (!trak->Media || !trak->Media->mediaHeader) return GF_ISOM_INVALID_FILE;\n\n\ttrak->Media->mediaHeader->creationTime = ctime;\n\ttrak->Media->mediaHeader->modificationTime = mtime;\n\treturn GF_OK;\n}\n\n//sets the enable flag of a track\nGF_EXPORT\nGF_Err gf_isom_set_track_enabled(GF_ISOFile *movie, u32 trackNumber, Bool enableTrack)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tif (enableTrack) {\n\t\ttrak->Header->flags |= 1;\n\t} else {\n\t\ttrak->Header->flags &= ~1;\n\t}\n\treturn GF_OK;\n}\n\n//sets the enable flag of a track\nGF_EXPORT\nGF_Err gf_isom_set_track_flags(GF_ISOFile *movie, u32 trackNumber, u32 flags, GF_ISOMTrackFlagOp op)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\tif (op==GF_ISOM_TKFLAGS_ADD)\n\t\ttrak->Header->flags |= flags;\n\telse if (op==GF_ISOM_TKFLAGS_REM)\n\t\ttrak->Header->flags &= ~flags;\n\telse\n\t\ttrak->Header->flags = flags;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_media_language(GF_ISOFile *movie, u32 trackNumber, char *code)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !code) return GF_BAD_PARAM;\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\t// Old language-storage processing\n\t// if the new code is on 3 chars, we use it\n\t// otherwise, we find the associated 3 chars code and use it\n\tif (strlen(code) == 3) {\n\t\tmemcpy(trak->Media->mediaHeader->packedLanguage, code, sizeof(char)*3);\n\t} else {\n\t\ts32 lang_idx;\n\t\tconst char *code_3cc;\n\t\tlang_idx = gf_lang_find(code);\n\t\tif (lang_idx == -1) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"The given code is not a valid one: %s, using 'und' as 3-letter code\\n\", code));\n\t\t\tcode_3cc = \"und\";\n\t\t} else {\n\t\t\tcode_3cc = gf_lang_get_3cc(lang_idx);\n\t\t}\n\t\tmemcpy(trak->Media->mediaHeader->packedLanguage, code_3cc, sizeof(char)*3);\n\t}\n\n\t// New language-storage processing\n\t// change the code in the extended language box (if any)\n\t// otherwise add an extended language box only if the given code is not 3 chars\n\t{\n\t\tu32 i, count;\n\t\tGF_ExtendedLanguageBox *elng;\n\t\telng = NULL;\n\t\tcount = gf_list_count(trak->Media->child_boxes);\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tGF_Box *box = (GF_Box *)gf_list_get(trak->Media->child_boxes, i);\n\t\t\tif (box->type == GF_ISOM_BOX_TYPE_ELNG) {\n\t\t\t\telng = (GF_ExtendedLanguageBox *)box;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!elng && (strlen(code) > 3)) {\n\t\t\telng = (GF_ExtendedLanguageBox *)gf_isom_box_new_parent(&trak->Media->child_boxes, GF_ISOM_BOX_TYPE_ELNG);\n\t\t\tif (!elng) return GF_OUT_OF_MEM;\n\t\t}\n\t\tif (elng) {\n\t\t\tif (elng->extended_language) {\n\t\t\t\tgf_free(elng->extended_language);\n\t\t\t}\n\t\t\telng->extended_language = gf_strdup(code);\n\t\t}\n\t}\n\tif (!movie->keep_utc)\n\t\ttrak->Media->mediaHeader->modificationTime = gf_isom_get_mp4time();\n\treturn GF_OK;\n}\n\nstatic GF_Err gf_isom_set_root_iod(GF_ISOFile *movie)\n{\n\tGF_IsomInitialObjectDescriptor *iod;\n\tGF_IsomObjectDescriptor *od;\n\tGF_Err e;\n\t\n\te = gf_isom_insert_moov(movie);\n\tif (e) return e;\n\tif (!movie->moov->iods) {\n\t\tAddMovieIOD(movie->moov, 1);\n\t\treturn GF_OK;\n\t}\n\t//if OD, switch to IOD\n\tif (movie->moov->iods->descriptor->tag == GF_ODF_ISOM_IOD_TAG) return GF_OK;\n\tod = (GF_IsomObjectDescriptor *) movie->moov->iods->descriptor;\n\tiod = (GF_IsomInitialObjectDescriptor*)gf_malloc(sizeof(GF_IsomInitialObjectDescriptor));\n\tif (!iod) return GF_OUT_OF_MEM;\n\n\tmemset(iod, 0, sizeof(GF_IsomInitialObjectDescriptor));\n\n\tiod->ES_ID_IncDescriptors = od->ES_ID_IncDescriptors;\n\tod->ES_ID_IncDescriptors = NULL;\n\t//not used in root OD\n\tiod->ES_ID_RefDescriptors = NULL;\n\tiod->extensionDescriptors = od->extensionDescriptors;\n\tod->extensionDescriptors = NULL;\n\tiod->IPMP_Descriptors = od->IPMP_Descriptors;\n\tod->IPMP_Descriptors = NULL;\n\tiod->objectDescriptorID = od->objectDescriptorID;\n\tiod->OCIDescriptors = od->OCIDescriptors;\n\tod->OCIDescriptors = NULL;\n\tiod->tag = GF_ODF_ISOM_IOD_TAG;\n\tiod->URLString = od->URLString;\n\tod->URLString = NULL;\n\n\tgf_odf_desc_del((GF_Descriptor *) od);\n\tmovie->moov->iods->descriptor = (GF_Descriptor *)iod;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_add_desc_to_root_od(GF_ISOFile *movie, const GF_Descriptor *theDesc)\n{\n\tGF_Err e;\n\tGF_Descriptor *desc, *dupDesc;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\te = gf_isom_insert_moov(movie);\n\tif (e) return e;\n\n\tif (!movie->moov->iods) {\n\t\te = AddMovieIOD(movie->moov, 0);\n\t\tif (e) return e;\n\t}\n\tif (theDesc->tag==GF_ODF_IPMP_TL_TAG) gf_isom_set_root_iod(movie);\n\n\tdesc = movie->moov->iods->descriptor;\n\t//the type of desc is handled at the OD/IOD level, we'll be notified\n\t//if the desc is not allowed\n\tswitch (desc->tag) {\n\tcase GF_ODF_ISOM_IOD_TAG:\n\tcase GF_ODF_ISOM_OD_TAG:\n\t\t//duplicate the desc\n\t\te = gf_odf_desc_copy((GF_Descriptor *)theDesc, &dupDesc);\n\t\tif (e) return e;\n\t\t//add it (MUST BE  (I)OD level desc)\n\t\tmovie->LastError = gf_odf_desc_add_desc(desc, dupDesc);\n\t\tif (movie->LastError) gf_odf_desc_del((GF_Descriptor *)dupDesc);\n\t\tbreak;\n\tdefault:\n\t\tmovie->LastError = GF_ISOM_INVALID_FILE;\n\t\tbreak;\n\t}\n\treturn movie->LastError;\n}\n\n\nGF_EXPORT\nGF_Err gf_isom_set_timescale(GF_ISOFile *movie, u32 timeScale)\n{\n\tGF_TrackBox *trak;\n\tu32 i;\n\tGF_Err e;\n\tif (!timeScale) return GF_BAD_PARAM;\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\te = gf_isom_insert_moov(movie);\n\tif (e) return e;\n\n\tif (movie->moov->mvhd->timeScale == timeScale) return GF_OK;\n\n\t/*rewrite all durations and edit lists*/\n\tmovie->moov->mvhd->duration *= timeScale;\n\tmovie->moov->mvhd->duration /= movie->moov->mvhd->timeScale;\n\tif (movie->moov->mvex && movie->moov->mvex->mehd) {\n\t\tmovie->moov->mvex->mehd->fragment_duration *= timeScale;\n\t\tmovie->moov->mvex->mehd->fragment_duration /= movie->moov->mvhd->timeScale;\n\t}\n\n\ti=0;\n\twhile ((trak = (GF_TrackBox*)gf_list_enum(movie->moov->trackList, &i))) {\n\t\ttrak->Header->duration *= timeScale;\n\t\ttrak->Header->duration /= movie->moov->mvhd->timeScale;\n\n\t\tif (trak->editBox && trak->editBox->editList) {\n\t\t\tu32 j, count = gf_list_count(trak->editBox->editList->entryList);\n\t\t\tfor (j=0; j<count; j++) {\n\t\t\t\tGF_EdtsEntry *ent = (GF_EdtsEntry *)gf_list_get(trak->editBox->editList->entryList, j);\n\t\t\t\tent->segmentDuration *= timeScale;\n\t\t\t\tent->segmentDuration /= movie->moov->mvhd->timeScale;\n\t\t\t}\n\t\t}\n\t}\n\tif (movie->moov->mvex && movie->moov->mvex->mehd) {\n\t\tmovie->moov->mvex->mehd->fragment_duration *= timeScale;\n\t\tmovie->moov->mvex->mehd->fragment_duration /= movie->moov->mvhd->timeScale;\n\t}\n\tmovie->moov->mvhd->timeScale = timeScale;\n\tmovie->interleavingTime = timeScale;\n\treturn GF_OK;\n}\n\n\nGF_EXPORT\nGF_Err gf_isom_set_pl_indication(GF_ISOFile *movie, GF_ISOProfileLevelType PL_Code, u8 ProfileLevel)\n{\n\tGF_IsomInitialObjectDescriptor *iod;\n\tGF_Err e;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\te = gf_isom_set_root_iod(movie);\n\tif (e) return e;\n\n\tiod = (GF_IsomInitialObjectDescriptor *)movie->moov->iods->descriptor;\n\n\tswitch (PL_Code) {\n\tcase GF_ISOM_PL_AUDIO:\n\t\tiod->audio_profileAndLevel = ProfileLevel;\n\t\tbreak;\n\tcase GF_ISOM_PL_GRAPHICS:\n\t\tiod->graphics_profileAndLevel = ProfileLevel;\n\t\tbreak;\n\tcase GF_ISOM_PL_OD:\n\t\tiod->OD_profileAndLevel = ProfileLevel;\n\t\tbreak;\n\tcase GF_ISOM_PL_SCENE:\n\t\tiod->scene_profileAndLevel = ProfileLevel;\n\t\tbreak;\n\tcase GF_ISOM_PL_VISUAL:\n\t\tiod->visual_profileAndLevel = ProfileLevel;\n\t\tbreak;\n\tcase GF_ISOM_PL_INLINE:\n\t\tiod->inlineProfileFlag = ProfileLevel ? 1 : 0;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_root_od_id(GF_ISOFile *movie, u32 OD_ID)\n{\n\tGF_Err e;\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\te = gf_isom_insert_moov(movie);\n\tif (e) return e;\n\tif (!movie->moov->iods) {\n\t\te = AddMovieIOD(movie->moov, 0);\n\t\tif (e) return e;\n\t}\n\n\tswitch (movie->moov->iods->descriptor->tag) {\n\tcase GF_ODF_ISOM_OD_TAG:\n\t\t((GF_IsomObjectDescriptor *)movie->moov->iods->descriptor)->objectDescriptorID = OD_ID;\n\t\tbreak;\n\tcase GF_ODF_ISOM_IOD_TAG:\n\t\t((GF_IsomInitialObjectDescriptor *)movie->moov->iods->descriptor)->objectDescriptorID = OD_ID;\n\t\tbreak;\n\tdefault:\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_root_od_url(GF_ISOFile *movie, const char *url_string)\n{\n\tGF_Err e;\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\te = gf_isom_insert_moov(movie);\n\tif (e) return e;\n\n\tif (!movie->moov->iods) {\n\t\te = AddMovieIOD(movie->moov, 0);\n\t\tif (e) return e;\n\t}\n\n\tswitch (movie->moov->iods->descriptor->tag) {\n\tcase GF_ODF_ISOM_OD_TAG:\n\t\tif (((GF_IsomObjectDescriptor *)movie->moov->iods->descriptor)->URLString) gf_free(((GF_IsomObjectDescriptor *)movie->moov->iods->descriptor)->URLString);\n\t\t((GF_IsomObjectDescriptor *)movie->moov->iods->descriptor)->URLString = url_string ? gf_strdup(url_string) : NULL;\n\t\tbreak;\n\tcase GF_ODF_ISOM_IOD_TAG:\n\t\tif (((GF_IsomInitialObjectDescriptor *)movie->moov->iods->descriptor)->URLString) gf_free(((GF_IsomInitialObjectDescriptor *)movie->moov->iods->descriptor)->URLString);\n\t\t((GF_IsomInitialObjectDescriptor *)movie->moov->iods->descriptor)->URLString = url_string ? gf_strdup(url_string) : NULL;\n\t\tbreak;\n\tdefault:\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_ISOTrackID gf_isom_get_last_created_track_id(GF_ISOFile *movie)\n{\n\treturn movie ? movie->last_created_track_id : 0;\n}\n\n\nGF_EXPORT\nGF_Err gf_isom_load_extra_boxes(GF_ISOFile *movie, u8 *moov_boxes, u32 moov_boxes_size, Bool udta_only)\n{\n\tGF_BitStream *bs;\n\n\tGF_Err e = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\te = gf_isom_insert_moov(movie);\n\tif (e) return e;\n\n\tbs = gf_bs_new(moov_boxes, moov_boxes_size, GF_BITSTREAM_READ);\n\n\t//we may have terminators in some QT files (4 bytes set to 0 ...)\n\twhile (gf_bs_available(bs) >= 8) {\n\t\tGF_Box *a_box;\n\t\te = gf_isom_box_parse_ex((GF_Box**)&a_box, bs, GF_ISOM_BOX_TYPE_MOOV, GF_FALSE);\n\t\tif (e || !a_box) goto exit;\n\n\t\tif (a_box->type == GF_ISOM_BOX_TYPE_UDTA) {\n\t\t\tif (movie->moov->udta) gf_isom_box_del_parent(&movie->moov->child_boxes, (GF_Box*)movie->moov->udta);\n\t\t\tmovie->moov->udta = (GF_UserDataBox*) a_box;\n\n\t\t\tif (!movie->moov->child_boxes) movie->moov->child_boxes = gf_list_new();\n\t\t\tgf_list_add(movie->moov->child_boxes, a_box);\n\n\t\t} else if (!udta_only && (a_box->type!=GF_ISOM_BOX_TYPE_PSSH) ) {\n\t\t\tif (!movie->moov->child_boxes) movie->moov->child_boxes = gf_list_new();\n\t\t\tgf_list_add(movie->moov->child_boxes, a_box);\n\t\t} else {\n\t\t\tgf_isom_box_del(a_box);\n\t\t}\n\t}\nexit:\n\tgf_bs_del(bs);\n\treturn e;\n}\n\n//creates a new Track. If trackID = 0, the trackID is chosen by the API\n//returns the track number or 0 if error\nGF_EXPORT\nu32 gf_isom_new_track_from_template(GF_ISOFile *movie, GF_ISOTrackID trakID, u32 MediaType, u32 TimeScale, u8 *tk_box, u32 tk_box_size, Bool udta_only)\n{\n\tGF_Err e;\n\tu64 now;\n\tu8 isHint;\n\tGF_TrackBox *trak;\n\tGF_TrackHeaderBox *tkhd;\n\tGF_MediaBox *mdia;\n\tGF_UserDataBox *udta = NULL;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) {\n\t\tgf_isom_set_last_error(movie, e);\n\t\treturn 0;\n\t}\n\te = gf_isom_insert_moov(movie);\n\tif (e) return e;\n\n\n\tisHint = 0;\n\t//we're creating a hint track... it's the same, but mode HAS TO BE EDIT\n\tif (MediaType == GF_ISOM_MEDIA_HINT) {\n//\t\tif (movie->openMode != GF_ISOM_OPEN_EDIT) return 0;\n\t\tisHint = 1;\n\t}\n\n\tmdia = NULL;\n\ttkhd = NULL;\n\ttrak = NULL;\n\tif (trakID) {\n\t\t//check if we are in ES_ID boundaries\n\t\tif (!isHint && (trakID > 0xFFFF)) {\n\t\t\tgf_isom_set_last_error(movie, GF_BAD_PARAM);\n\t\t\treturn 0;\n\t\t}\n\t\t//here we should look for available IDs ...\n\t\tif (!RequestTrack(movie->moov, trakID)) return 0;\n\t} else {\n\t\ttrakID = movie->moov->mvhd->nextTrackID;\n\t\tif (!trakID) trakID = 1;\n\t\t/*ESIDs are on 16 bits*/\n\t\tif (! isHint && (trakID > 0xFFFF)) trakID = 1;\n\n\t\twhile (1) {\n\t\t\tif (RequestTrack(movie->moov, trakID)) break;\n\t\t\ttrakID += 1;\n\t\t\tif (trakID == 0xFFFFFFFF) break;\n\t\t}\n\t\tif (trakID == 0xFFFFFFFF) {\n\t\t\tgf_isom_set_last_error(movie, GF_BAD_PARAM);\n\t\t\treturn 0;\n\t\t}\n\t\tif (! isHint && (trakID > 0xFFFF)) {\n\t\t\tgf_isom_set_last_error(movie, GF_BAD_PARAM);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (tk_box) {\n\t\tGF_BitStream *bs = gf_bs_new(tk_box, tk_box_size, GF_BITSTREAM_READ);\n\t\tgf_bs_set_cookie(bs, GF_ISOM_BS_COOKIE_NO_LOGS|GF_ISOM_BS_COOKIE_CLONE_TRACK);\n\n\t\te = gf_isom_box_parse_ex((GF_Box**)&trak, bs, GF_ISOM_BOX_TYPE_MOOV, GF_FALSE);\n\t\tgf_bs_del(bs);\n\t\tif (e) trak = NULL;\n\t\telse if (udta_only) {\n\t\t\tudta = trak->udta;\n\t\t\ttrak->udta = NULL;\n\t\t\tgf_isom_box_del((GF_Box*)trak);\n\t\t} else {\n\t\t\tBool tpl_ok = GF_TRUE;\n\t\t\tif (!trak->Header || !trak->Media || !trak->Media->handler || !trak->Media->mediaHeader || !trak->Media->information) tpl_ok = GF_FALSE;\n\n\t\t\telse {\n\t\t\t\tif (!MediaType) MediaType = trak->Media->handler->handlerType;\n\t\t\t\te = NewMedia(&trak->Media, MediaType, TimeScale);\n\t\t\t\tif (e) tpl_ok = GF_FALSE;\n\t\t\t}\n\t\t\tif (!tpl_ok) {\n\t\t\t\tudta = trak->udta;\n\t\t\t\ttrak->udta = NULL;\n\t\t\t\tgf_isom_box_del((GF_Box*)trak);\n\t\t\t}\n\t\t}\n\t}\n\tnow = gf_isom_get_mp4time();\n\tif (!trak) {\n\t\t//OK, now create a track...\n\t\ttrak = (GF_TrackBox *) gf_isom_box_new_parent(&movie->moov->child_boxes, GF_ISOM_BOX_TYPE_TRAK);\n\t\tif (!trak) {\n\t\t\tgf_isom_set_last_error(movie, GF_OUT_OF_MEM);\n\t\t\treturn 0;\n\t\t}\n\t\ttkhd = (GF_TrackHeaderBox *) gf_isom_box_new_parent(&trak->child_boxes, GF_ISOM_BOX_TYPE_TKHD);\n\t\tif (!tkhd) {\n\t\t\tgf_isom_set_last_error(movie, GF_OUT_OF_MEM);\n\t\t\treturn 0;\n\t\t}\n\n\t\t//OK, set up the media trak\n\t\te = NewMedia(&mdia, MediaType, TimeScale);\n\t\tif (e) {\n\t\t\tgf_isom_box_del((GF_Box *)mdia);\n\t\t\treturn 0;\n\t\t}\n\t\tassert(trak->child_boxes);\n\t\tgf_list_add(trak->child_boxes, mdia);\n\n\t\t//OK, add this media to our track\n\t\tmdia->mediaTrack = trak;\n\n\t\te = trak_on_child_box((GF_Box*)trak, (GF_Box *) tkhd, GF_FALSE);\n\t\tif (e) goto err_exit;\n\t\te = trak_on_child_box((GF_Box*)trak, (GF_Box *) mdia, GF_FALSE);\n\t\tif (e) goto err_exit;\n\t\ttkhd->trackID = trakID;\n\n\t\tif (gf_sys_is_test_mode() ) {\n\t\t\ttkhd->creationTime = 0;\n\t\t\tmdia->mediaHeader->creationTime = 0;\n\t\t} else {\n\t\t\ttkhd->creationTime = now;\n\t\t\tmdia->mediaHeader->creationTime = now;\n\t\t}\n\n\t} else {\n\t\ttkhd = trak->Header;\n\t\ttkhd->trackID = trakID;\n\t\tmdia = trak->Media;\n\t\tmdia->mediaTrack = trak;\n\t\tmdia->mediaHeader->timeScale = TimeScale;\n\t\tif (mdia->handler->handlerType != MediaType) {\n\t\t\tmdia->handler->handlerType = MediaType;\n\t\t\ttkhd->width = 0;\n\t\t\ttkhd->height = 0;\n\t\t\ttkhd->volume = 0;\n\t\t} else {\n\t\t\tMediaType = 0;\n\t\t}\n\t\ttrak->Header->duration = 0;\n\t\tmdia->mediaHeader->duration = 0;\n\n\t\tif (!movie->moov->child_boxes) movie->moov->child_boxes = gf_list_new();\n\t\tgf_list_add(movie->moov->child_boxes, trak);\n\t}\n\tif (MediaType) {\n\t\t//some default properties for Audio, Visual or private tracks\n\t\tswitch (MediaType) {\n\t\tcase GF_ISOM_MEDIA_VISUAL:\n\t\tcase GF_ISOM_MEDIA_AUXV:\n\t\tcase GF_ISOM_MEDIA_PICT:\n\t\tcase GF_ISOM_MEDIA_SCENE:\n\t\tcase GF_ISOM_MEDIA_TEXT:\n\t\tcase GF_ISOM_MEDIA_SUBT:\n\t\t\t/*320-240 pix in 16.16*/\n\t\t\ttkhd->width = 0x01400000;\n\t\t\ttkhd->height = 0x00F00000;\n\t\t\tbreak;\n\t\tcase GF_ISOM_MEDIA_AUDIO:\n\t\t\ttkhd->volume = 0x0100;\n\t\t\tbreak;\n\t\t}\n\t}\n\tmovie->last_created_track_id = tkhd->trackID;\n\t\n\tif (!movie->keep_utc && !gf_sys_is_test_mode() ) {\n\t\ttkhd->modificationTime = now;\n\t \tmdia->mediaHeader->modificationTime = now;\n\t}\n\n\t//OK, add our trak\n\te = moov_on_child_box((GF_Box*)movie->moov, (GF_Box *)trak, GF_FALSE);\n\tif (e) goto err_exit;\n\t//set the new ID available\n\tif (trakID+1> movie->moov->mvhd->nextTrackID)\n\t\tmovie->moov->mvhd->nextTrackID = trakID+1;\n\n\ttrak->udta = udta;\n\n\t//and return our track number\n\treturn gf_isom_get_track_by_id(movie, trakID);\n\nerr_exit:\n\t//tkhd is registered with track and will be destroyed there\n\tif (trak) gf_isom_box_del((GF_Box *)trak);\n\tif (mdia) gf_isom_box_del((GF_Box *)mdia);\n\treturn 0;\n}\n\nGF_EXPORT\nu32 gf_isom_new_track(GF_ISOFile *movie, GF_ISOTrackID trakID, u32 MediaType, u32 TimeScale)\n{\n\treturn gf_isom_new_track_from_template(movie, trakID, MediaType, TimeScale, NULL, 0, GF_FALSE);\n}\n\nGF_EXPORT\nGF_Err gf_isom_remove_stream_description(GF_ISOFile *movie, u32 trackNumber, u32 StreamDescriptionIndex)\n{\n\tGF_TrackBox *trak;\n\tGF_Err e;\n\tGF_SampleEntryBox *entry;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !trak->Media) return GF_BAD_PARAM;\n\n\tif (!movie->keep_utc)\n\t\ttrak->Media->mediaHeader->modificationTime = gf_isom_get_mp4time();\n\n\tentry = (GF_SampleEntryBox*)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, StreamDescriptionIndex - 1);\n\tif (!entry) return GF_BAD_PARAM;\n\tgf_list_rem(trak->Media->information->sampleTable->SampleDescription->child_boxes, StreamDescriptionIndex - 1);\n\tgf_isom_box_del((GF_Box *)entry);\n\treturn GF_OK;\n}\n\n//Create a new StreamDescription in the file. The URL and URN are used to describe external media\nGF_EXPORT\nGF_Err gf_isom_new_mpeg4_description(GF_ISOFile *movie,\n                                     u32 trackNumber,\n                                     const GF_ESD *esd,\n                                     const char *URLname,\n                                     const char *URNname,\n                                     u32 *outDescriptionIndex)\n{\n\tGF_TrackBox *trak;\n\tGF_Err e;\n\tu32 dataRefIndex;\n\tGF_ESD *new_esd;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !trak->Media ||\n\t        !esd || !esd->decoderConfig ||\n\t        !esd->slConfig) return GF_BAD_PARAM;\n\n\t//get or create the data ref\n\te = Media_FindDataRef(trak->Media->information->dataInformation->dref, (char *)URLname, (char *)URNname, &dataRefIndex);\n\tif (e) return e;\n\tif (!dataRefIndex) {\n\t\te = Media_CreateDataRef(movie, trak->Media->information->dataInformation->dref, (char *)URLname, (char *)URNname, &dataRefIndex);\n\t\tif (e) return e;\n\t}\n\t//duplicate our desc\n\te = gf_odf_desc_copy((GF_Descriptor *)esd, (GF_Descriptor **)&new_esd);\n\tif (e) return e;\n\tif (!movie->keep_utc)\n\t\ttrak->Media->mediaHeader->modificationTime = gf_isom_get_mp4time();\n\te = Track_SetStreamDescriptor(trak, 0, dataRefIndex, new_esd, outDescriptionIndex);\n\tif (e) {\n\t\tgf_odf_desc_del((GF_Descriptor *)new_esd);\n\t\treturn e;\n\t}\n\treturn e;\n}\n\nGF_Err gf_isom_flush_chunk(GF_TrackBox *trak, Bool is_final)\n{\n\tGF_Err e;\n\tu64 data_offset;\n\tu32 sample_number;\n\tu8 *chunk_data;\n\tu32 chunk_size, chunk_alloc;\n\tif (!trak->chunk_cache) return GF_OK;\n\n\tgf_bs_get_content_no_truncate(trak->chunk_cache, &chunk_data, &chunk_size, &chunk_alloc);\n\n\tdata_offset = gf_isom_datamap_get_offset(trak->Media->information->dataHandler);\n\n\te = gf_isom_datamap_add_data(trak->Media->information->dataHandler, chunk_data, chunk_size);\n\tif (e) return e;\n\n\tsample_number = 1 + trak->Media->information->sampleTable->SampleSize->sampleCount;\n\tsample_number -= trak->nb_samples_in_cache;\n\n\te = stbl_AddChunkOffset(trak->Media, sample_number, trak->chunk_stsd_idx, data_offset, trak->nb_samples_in_cache);\n\n\tif (is_final) {\n\t\tgf_free(chunk_data);\n\t\tgf_bs_del(trak->chunk_cache);\n\t\ttrak->chunk_cache = NULL;\n\t} else {\n\t\tgf_bs_reassign_buffer(trak->chunk_cache, chunk_data, chunk_alloc);\n\t}\n\treturn e;\n}\n\nstatic GF_Err trak_add_sample(GF_ISOFile *movie, GF_TrackBox *trak, const GF_ISOSample *sample, u32 descIndex, u64 data_offset, u32 syncShadowSampleNum)\n{\n\tBool skip_data = GF_FALSE;\n\tGF_Err e;\n\n\t//faststart mode with interleaving time, cache data until we have a full chunk\n\tif ((movie->storageMode==GF_ISOM_STORE_FASTSTART) && movie->interleavingTime) {\n\t\tBool flush_chunk = GF_FALSE;\n\t\tu64 stime = sample->DTS;\n\t\tstime *= movie->moov->mvhd->timeScale;\n\t\tstime /= trak->Media->mediaHeader->timeScale;\n\n\t\tif (stime - trak->first_dts_chunk > movie->interleavingTime)\n\t\t\tflush_chunk = GF_TRUE;\n\n\t\tif (movie->next_flush_chunk_time < stime)\n\t\t\tflush_chunk = GF_TRUE;\n\n\t\tif (trak->chunk_stsd_idx != descIndex)\n\t\t\tflush_chunk = GF_TRUE;\n\n\t\tif (trak->Media->information->sampleTable->MaxChunkSize && trak->Media->information->sampleTable->MaxChunkSize < trak->chunk_cache_size + sample->dataLength)\n\t\t\tflush_chunk = GF_TRUE;\n\n\t\tif (flush_chunk) {\n\t\t\tmovie->next_flush_chunk_time = stime + movie->interleavingTime;\n\t\t\tif (trak->chunk_cache) {\n\t\t\t\te = gf_isom_flush_chunk(trak, GF_FALSE);\n\t\t\t\tif (e) return e;\n\t\t\t}\n\t\t\ttrak->nb_samples_in_cache = 0;\n\t\t\ttrak->chunk_cache_size = 0;\n\t\t\ttrak->first_dts_chunk = stime;\n\t\t}\n\t\tif (!trak->chunk_cache)\n\t\t\ttrak->chunk_cache = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\t\tgf_bs_write_data(trak->chunk_cache, sample->data, sample->dataLength);\n\t\ttrak->nb_samples_in_cache += sample->nb_pack ? sample->nb_pack : 1;\n\t\ttrak->chunk_cache_size += sample->dataLength;\n\t\ttrak->chunk_stsd_idx = descIndex;\n\n\t\tskip_data = GF_TRUE;\n\t}\n\n\te = Media_AddSample(trak->Media, data_offset, sample, descIndex, syncShadowSampleNum);\n\tif (e) return e;\n\n\tif (!skip_data && sample->dataLength) {\n\t\te = gf_isom_datamap_add_data(trak->Media->information->dataHandler, sample->data, sample->dataLength);\n\t\tif (e) return e;\n\t}\n\n\treturn GF_OK;\n}\n\n//Add samples to a track. Use streamDescriptionIndex to specify the desired stream (if several)\nGF_EXPORT\nGF_Err gf_isom_add_sample(GF_ISOFile *movie, u32 trackNumber, u32 StreamDescriptionIndex, const GF_ISOSample *sample)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\tGF_SampleEntryBox *entry;\n\tu32 dataRefIndex;\n\tu64 data_offset;\n\tu32 descIndex;\n\tGF_DataEntryURLBox *Dentry;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\te = FlushCaptureMode(movie);\n\tif (e) return e;\n\n\te = unpack_track(trak);\n\tif (e) return e;\n\n\t//OK, add the sample\n\t//1- Get the streamDescriptionIndex and dataRefIndex\n\t//not specified, get the latest used...\n\tdescIndex = StreamDescriptionIndex;\n\tif (!StreamDescriptionIndex) {\n\t\tdescIndex = trak->Media->information->sampleTable->currentEntryIndex;\n\t}\n\te = Media_GetSampleDesc(trak->Media, descIndex, &entry, &dataRefIndex);\n\tif (e) return e;\n\tif (!entry || !dataRefIndex) return GF_BAD_PARAM;\n\t//set the current to this one\n\ttrak->Media->information->sampleTable->currentEntryIndex = descIndex;\n\n\n\t//get this dataRef and return false if not self contained\n\tDentry = (GF_DataEntryURLBox*)gf_list_get(trak->Media->information->dataInformation->dref->child_boxes, dataRefIndex - 1);\n\tif (!Dentry || Dentry->flags != 1) return GF_BAD_PARAM;\n\n\t//Open our data map. We are adding stuff, so use EDIT\n\te = gf_isom_datamap_open(trak->Media, dataRefIndex, 1);\n\tif (e) return e;\n\n\t//Get the offset...\n\tdata_offset = gf_isom_datamap_get_offset(trak->Media->information->dataHandler);\n\n\t/*rewrite OD frame*/\n\tif (trak->Media->handler->handlerType == GF_ISOM_MEDIA_OD) {\n\t\tGF_ISOSample *od_sample = NULL;\n\n\t\te = Media_ParseODFrame(trak->Media, sample, &od_sample);\n\t\tif (e) return e;\n\n\t\te = trak_add_sample(movie, trak, od_sample, descIndex, data_offset, 0);\n\n\t\tif (od_sample)\n\t\t\tgf_isom_sample_del(&od_sample);\n\t} else {\n\t\te = trak_add_sample(movie, trak, sample, descIndex, data_offset, 0);\n\t}\n\tif (e) return e;\n\n\n\tif (!movie->keep_utc)\n\t\ttrak->Media->mediaHeader->modificationTime = gf_isom_get_mp4time();\n\treturn SetTrackDuration(trak);\n}\n\nGF_EXPORT\nGF_Err gf_isom_add_sample_shadow(GF_ISOFile *movie, u32 trackNumber, GF_ISOSample *sample)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\tGF_ISOSample *prev;\n\tGF_SampleEntryBox *entry;\n\tu32 dataRefIndex;\n\tu64 data_offset;\n\tu32 descIndex;\n\tu32 sampleNum, prevSampleNum;\n\tGF_DataEntryURLBox *Dentry;\n\tBool offset_times = GF_FALSE;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !sample) return GF_BAD_PARAM;\n\n\te = FlushCaptureMode(movie);\n\tif (e) return e;\n\n\te = unpack_track(trak);\n\tif (e) return e;\n\n\te = stbl_findEntryForTime(trak->Media->information->sampleTable, sample->DTS, 0, &sampleNum, &prevSampleNum);\n\tif (e) return e;\n\t/*we need the EXACT match*/\n\tif (!sampleNum) return GF_BAD_PARAM;\n\n\tprev = gf_isom_get_sample_info(movie, trackNumber, sampleNum, &descIndex, NULL);\n\tif (!prev) return gf_isom_last_error(movie);\n\t/*for conformance*/\n\tif (sample->DTS==prev->DTS) offset_times = GF_TRUE;\n\tgf_isom_sample_del(&prev);\n\n\te = Media_GetSampleDesc(trak->Media, descIndex, &entry, &dataRefIndex);\n\tif (e) return e;\n\tif (!entry || !dataRefIndex) return GF_BAD_PARAM;\n\ttrak->Media->information->sampleTable->currentEntryIndex = descIndex;\n\n\t//get this dataRef and return false if not self contained\n\tDentry = (GF_DataEntryURLBox*)gf_list_get(trak->Media->information->dataInformation->dref->child_boxes, dataRefIndex - 1);\n\tif (!Dentry || Dentry->flags != 1) return GF_BAD_PARAM;\n\n\t//Open our data map. We are adding stuff, so use EDIT\n\te = gf_isom_datamap_open(trak->Media, dataRefIndex, 1);\n\tif (e) return e;\n\n\tdata_offset = gf_isom_datamap_get_offset(trak->Media->information->dataHandler);\n\tif (offset_times) sample->DTS += 1;\n\n\t/*REWRITE ANY OD STUFF*/\n\tif (trak->Media->handler->handlerType == GF_ISOM_MEDIA_OD) {\n\t\tGF_ISOSample *od_sample = NULL;\n\t\te = Media_ParseODFrame(trak->Media, sample, &od_sample);\n\t\tif (e) return e;\n\n\t\te = trak_add_sample(movie, trak, od_sample, descIndex, data_offset, sampleNum);\n\t\tif (od_sample)\n\t\t\tgf_isom_sample_del(&od_sample);\n\t} else {\n\t\te = trak_add_sample(movie, trak, sample, descIndex, data_offset, sampleNum);\n\t}\n\tif (e) return e;\n\tif (offset_times) sample->DTS -= 1;\n\n\t//OK, update duration\n\te = Media_SetDuration(trak);\n\tif (e) return e;\n\tif (!movie->keep_utc)\n\t\ttrak->Media->mediaHeader->modificationTime = gf_isom_get_mp4time();\n\treturn SetTrackDuration(trak);\n}\n\nGF_EXPORT\nGF_Err gf_isom_append_sample_data(GF_ISOFile *movie, u32 trackNumber, u8 *data, u32 data_size)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\tGF_SampleEntryBox *entry;\n\tu32 dataRefIndex;\n\tu32 descIndex;\n\tGF_DataEntryURLBox *Dentry;\n\n\tif (!data_size) return GF_OK;\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tif (trak->Media->handler->handlerType == GF_ISOM_MEDIA_OD) return GF_BAD_PARAM;\n\n\t//OK, add the sample\n\tdescIndex = trak->Media->information->sampleTable->currentEntryIndex;\n\n\te = Media_GetSampleDesc(trak->Media, descIndex, &entry, &dataRefIndex);\n\tif (e) return e;\n\tif (!entry || !dataRefIndex) return GF_BAD_PARAM;\n\n\t//get this dataRef and return false if not self contained\n\tDentry = (GF_DataEntryURLBox*)gf_list_get(trak->Media->information->dataInformation->dref->child_boxes, dataRefIndex - 1);\n\tif (!Dentry || Dentry->flags != 1) return GF_BAD_PARAM;\n\n\t//Open our data map. We are adding stuff, so use EDIT\n\te = gf_isom_datamap_open(trak->Media, dataRefIndex, 1);\n\tif (e) return e;\n\n\t//add the media data\n\tif (trak->chunk_cache) {\n\t\tgf_bs_write_data(trak->chunk_cache, data, data_size);\n\t\ttrak->chunk_cache_size += data_size;\n\t} else {\n\t\te = gf_isom_datamap_add_data(trak->Media->information->dataHandler, data, data_size);\n\t\tif (e) return e;\n\t}\n\t//update data size\n\treturn stbl_SampleSizeAppend(trak->Media->information->sampleTable->SampleSize, data_size);\n}\n\n\n//Add sample reference to a track. The SampleOffset is the offset of the data in the referenced file\n//you must have created a StreamDescription with URL or URN specifying your referenced file\n//the data offset specifies the beginning of the chunk\n//Use streamDescriptionIndex to specify the desired stream (if several)\nGF_EXPORT\nGF_Err gf_isom_add_sample_reference(GF_ISOFile *movie, u32 trackNumber, u32 StreamDescriptionIndex, GF_ISOSample *sample, u64 dataOffset)\n{\n\tGF_TrackBox *trak;\n\tGF_SampleEntryBox *entry;\n\tu32 dataRefIndex;\n\tu32 descIndex;\n\tGF_DataEntryURLBox *Dentry;\n\tGF_Err e;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\te = unpack_track(trak);\n\tif (e) return e;\n\n\t//OD is not allowed as a data ref\n\tif (trak->Media->handler->handlerType == GF_ISOM_MEDIA_OD) {\n\t\treturn GF_BAD_PARAM;\n\t}\n\t//OK, add the sample\n\t//1- Get the streamDescriptionIndex and dataRefIndex\n\t//not specified, get the latest used...\n\tdescIndex = StreamDescriptionIndex;\n\tif (!StreamDescriptionIndex) {\n\t\tdescIndex = trak->Media->information->sampleTable->currentEntryIndex;\n\t}\n\te = Media_GetSampleDesc(trak->Media, descIndex, &entry, &dataRefIndex);\n\tif (e) return e;\n\tif (!entry || !dataRefIndex) return GF_BAD_PARAM;\n\t//set the current to this one\n\ttrak->Media->information->sampleTable->currentEntryIndex = descIndex;\n\n\n\t//get this dataRef and return false if self contained\n\tDentry =(GF_DataEntryURLBox*) gf_list_get(trak->Media->information->dataInformation->dref->child_boxes, dataRefIndex - 1);\n\tif (Dentry->flags == 1) return GF_BAD_PARAM;\n\n\t//add the meta data\n\te = Media_AddSample(trak->Media, dataOffset, sample, descIndex, 0);\n\tif (e) return e;\n\n\tif (!movie->keep_utc)\n\t\ttrak->Media->mediaHeader->modificationTime = gf_isom_get_mp4time();\n\t//OK, update duration\n\te = Media_SetDuration(trak);\n\tif (e) return e;\n\treturn SetTrackDuration(trak);\n\n}\n\n//set the duration of the last media sample. If not set, the duration of the last sample is the\n//duration of the previous one if any, or 1000 (default value).\nstatic GF_Err gf_isom_set_last_sample_duration_internal(GF_ISOFile *movie, u32 trackNumber, u64 dur_num, u32 dur_den, u32 mode)\n{\n\tGF_TrackBox *trak;\n\tGF_SttsEntry *ent;\n\tGF_TimeToSampleBox *stts;\n\tu64 mdur;\n\tu32 duration;\n\tGF_Err e;\n\tBool is_patch = GF_FALSE;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tif (mode==0) {\n\t\tduration = (u32) dur_num;\n\t} else if (mode==1) {\n\t\tduration = (u32) dur_num;\n\t\tif (dur_den) {\n\t\t\tduration *= trak->Media->mediaHeader->timeScale;\n\t\t\tduration /= dur_den;\n\t\t}\n\t} else {\n\t\tis_patch = GF_TRUE;\n\t}\n\tmdur = trak->Media->mediaHeader->duration;\n\tstts = trak->Media->information->sampleTable->TimeToSample;\n\tif (!stts->nb_entries) return GF_BAD_PARAM;\n\n\tif (is_patch) {\n\t\tu32 i, avg_dur, nb_samp=0;\n\t\tu64 cum_dur=0;\n\t\tfor (i=0; i<stts->nb_entries; i++) {\n\t\t\tent = (GF_SttsEntry*) &stts->entries[i];\n\t\t\tcum_dur += ent->sampleCount*ent->sampleDelta;\n\t\t\tnb_samp += ent->sampleCount;\n\t\t}\n\t\tif (cum_dur <= dur_num || !nb_samp) return GF_OK;\n\t\tavg_dur = (u32) (dur_num / nb_samp);\n\n\t\tfor (i=0; i<stts->nb_entries; i++) {\n\t\t\tent = (GF_SttsEntry*) &stts->entries[i];\n\t\t\tent->sampleDelta = avg_dur;\n\t\t}\n\t\tstts->w_LastDTS = dur_num - avg_dur;\n\t\treturn GF_OK;\n\t}\n\t//get the last entry\n\tent = (GF_SttsEntry*) &stts->entries[stts->nb_entries-1];\n\tif ((mode==1) && !duration && !dur_den) {\n\t\t//same as previous, nothing to adjust\n\t\tif (ent->sampleCount>1) return GF_OK;\n\t\tif (stts->nb_entries==1) return GF_OK;\n\t\tduration = stts->entries[stts->nb_entries-2].sampleDelta;\n\t}\n\n\tmdur -= ent->sampleDelta;\n\tmdur += duration;\n\n\t//we only have one sample\n\tif (ent->sampleCount == 1) {\n\t\tent->sampleDelta = (u32) duration;\n\t\tif (mode && (stts->nb_entries>1) && (stts->entries[stts->nb_entries-2].sampleDelta==duration)) {\n\t\t\tstts->entries[stts->nb_entries-2].sampleCount++;\n\t\t\tstts->nb_entries--;\n\t\t\t//and update the write cache\n\t\t\tstts->w_currentSampleNum = trak->Media->information->sampleTable->SampleSize->sampleCount;\n\t\t}\n\t} else {\n\t\tif (ent->sampleDelta == duration) return GF_OK;\n\t\tent->sampleCount -= 1;\n\n\t\tif (stts->nb_entries==stts->alloc_size) {\n\t\t\tstts->alloc_size++;\n\t\t\tstts->entries = (GF_SttsEntry*)gf_realloc(stts->entries, sizeof(GF_SttsEntry)*stts->alloc_size);\n\t\t\tif (!stts->entries) return GF_OUT_OF_MEM;\n\t\t}\n\t\tstts->entries[stts->nb_entries].sampleCount = 1;\n\t\tstts->entries[stts->nb_entries].sampleDelta = (u32) duration;\n\t\tstts->nb_entries++;\n\t\t//and update the write cache\n\t\tstts->w_currentSampleNum = trak->Media->information->sampleTable->SampleSize->sampleCount;\n\t}\n\tif (!movie->keep_utc)\n\t\ttrak->Media->mediaHeader->modificationTime = gf_isom_get_mp4time();\n\ttrak->Media->mediaHeader->duration = mdur;\n\treturn SetTrackDuration(trak);\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_last_sample_duration(GF_ISOFile *movie, u32 trackNumber, u32 duration)\n{\n\treturn gf_isom_set_last_sample_duration_internal(movie, trackNumber, duration, 0, 0);\n}\n\nGF_EXPORT\nGF_Err gf_isom_patch_last_sample_duration(GF_ISOFile *movie, u32 trackNumber, u64 next_dts)\n{\n\treturn gf_isom_set_last_sample_duration_internal(movie, trackNumber, next_dts, 0, 2);\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_last_sample_duration_ex(GF_ISOFile *movie, u32 trackNumber, u32 dur_num, u32 dur_den)\n{\n\treturn gf_isom_set_last_sample_duration_internal(movie, trackNumber, dur_num, dur_den, 1);\n}\n\n//update a sample data in the media. Note that the sample MUST exists\nGF_EXPORT\nGF_Err gf_isom_update_sample(GF_ISOFile *movie, u32 trackNumber, u32 sampleNumber, GF_ISOSample *sample, Bool data_only)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_EDIT);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\te = unpack_track(trak);\n\tif (e) return e;\n\n\t//block for hint tracks\n\tif (trak->Media->handler->handlerType == GF_ISOM_MEDIA_HINT) return GF_BAD_PARAM;\n\n\t//REWRITE ANY OD STUFF\n\tif (trak->Media->handler->handlerType == GF_ISOM_MEDIA_OD) {\n\t\tGF_ISOSample *od_sample = NULL;\n\t\te = Media_ParseODFrame(trak->Media, sample, &od_sample);\n\t\tif (!e) e = Media_UpdateSample(trak->Media, sampleNumber, od_sample, data_only);\n\t\tif (od_sample) gf_isom_sample_del(&od_sample);\n\t} else {\n\t\te = Media_UpdateSample(trak->Media, sampleNumber, sample, data_only);\n\t}\n\tif (e) return e;\n\tif (!movie->keep_utc)\n\t\ttrak->Media->mediaHeader->modificationTime = gf_isom_get_mp4time();\n\n\tgf_isom_disable_inplace_rewrite(movie);\n\treturn GF_OK;\n}\n\n//update a sample data in the media. Note that the sample MUST exists,\n//that sample->data MUST be NULL and sample->dataLength must be NON NULL;\nGF_EXPORT\nGF_Err gf_isom_update_sample_reference(GF_ISOFile *movie, u32 trackNumber, u32 sampleNumber, GF_ISOSample *sample, u64 data_offset)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_EDIT);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\t//block for hint tracks\n\tif (trak->Media->handler->handlerType == GF_ISOM_MEDIA_HINT) return GF_BAD_PARAM;\n\n\tif (!sampleNumber || !sample) return GF_BAD_PARAM;\n\n\te = unpack_track(trak);\n\tif (e) return e;\n\n\t//OD is not allowed as a data ref\n\tif (trak->Media->handler->handlerType == GF_ISOM_MEDIA_OD) {\n\t\treturn GF_BAD_PARAM;\n\t}\n\t//OK, update it\n\te = Media_UpdateSampleReference(trak->Media, sampleNumber, sample, data_offset);\n\tif (e) return e;\n\n\tif (!movie->keep_utc)\n\t\ttrak->Media->mediaHeader->modificationTime = gf_isom_get_mp4time();\n\treturn GF_OK;\n}\n\n\n//Remove a given sample\nGF_EXPORT\nGF_Err gf_isom_remove_sample(GF_ISOFile *movie, u32 trackNumber, u32 sampleNumber)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_EDIT);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !sampleNumber || (sampleNumber > trak->Media->information->sampleTable->SampleSize->sampleCount) )\n\t\treturn GF_BAD_PARAM;\n\n\t//block for hint tracks\n\tif (trak->Media->handler->handlerType == GF_ISOM_MEDIA_HINT) return GF_BAD_PARAM;\n\n\te = unpack_track(trak);\n\tif (e) return e;\n\t//do NOT change the order DTS, CTS, size chunk\n\n\t//remove DTS\n\te = stbl_RemoveDTS(trak->Media->information->sampleTable, sampleNumber, 1, trak->Media->mediaHeader->timeScale);\n\tif (e) return e;\n\t//remove CTS if any\n\tif (trak->Media->information->sampleTable->CompositionOffset) {\n\t\te = stbl_RemoveCTS(trak->Media->information->sampleTable, sampleNumber, 1);\n\t\tif (e) return e;\n\t}\n\t//remove size\n\te = stbl_RemoveSize(trak->Media->information->sampleTable, sampleNumber, 1);\n\tif (e) return e;\n\t//remove sampleToChunk and chunk\n\te = stbl_RemoveChunk(trak->Media->information->sampleTable, sampleNumber, 1);\n\tif (e) return e;\n\t//remove sync\n\tif (trak->Media->information->sampleTable->SyncSample) {\n\t\te = stbl_RemoveRAP(trak->Media->information->sampleTable, sampleNumber);\n\t\tif (e) return e;\n\t}\n\t//remove sample dep\n\tif (trak->Media->information->sampleTable->SampleDep) {\n\t\te = stbl_RemoveRedundant(trak->Media->information->sampleTable, sampleNumber, 1);\n\t\tif (e) return e;\n\t}\n\t//remove shadow\n\te = stbl_RemoveShadow(trak->Media->information->sampleTable, sampleNumber);\n\tif (e) return e;\n\n\t//remove padding\n\te = stbl_RemovePaddingBits(trak->Media->information->sampleTable, sampleNumber);\n\tif (e) return e;\n\n\te = stbl_RemoveSubSample(trak->Media->information->sampleTable, sampleNumber);\n\tif (e) return e;\n\n\te = stbl_RemoveSampleGroup(trak->Media->information->sampleTable, sampleNumber);\n\tif (e) return e;\n\n\tgf_isom_disable_inplace_rewrite(movie);\n\n\treturn SetTrackDuration(trak);\n}\n\n\nGF_EXPORT\nGF_Err gf_isom_set_final_name(GF_ISOFile *movie, char *filename)\n{\n\tGF_Err e;\n\tif (!movie ) return GF_BAD_PARAM;\n\n\t//if mode is not OPEN_EDIT file was created under the right name\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_EDIT);\n\tif (e) return e;\n\n\tif (filename) {\n\t\t//we don't allow file overwriting\n\t\tif ( (movie->openMode == GF_ISOM_OPEN_EDIT)\n\t\t        && movie->fileName && !strcmp(filename, movie->fileName))\n\t\t\treturn GF_BAD_PARAM;\n\t\tif (movie->finalName) gf_free(movie->finalName);\n\t\tmovie->finalName = gf_strdup(filename);\n\t\tif (!movie->finalName) return GF_OUT_OF_MEM;\n\t\tgf_isom_disable_inplace_rewrite(movie);\n\t}\n\treturn GF_OK;\n}\n\n//Add a system descriptor to the ESD of a stream(EDIT or WRITE mode only)\nGF_EXPORT\nGF_Err gf_isom_add_desc_to_description(GF_ISOFile *movie, u32 trackNumber, u32 StreamDescriptionIndex, const GF_Descriptor *theDesc)\n{\n\tGF_IPIPtr *ipiD;\n\tGF_Err e;\n\tu16 tmpRef;\n\tGF_TrackBox *trak;\n\tGF_Descriptor *desc;\n\tGF_ESD *esd;\n\tGF_TrackReferenceBox *tref;\n\tGF_TrackReferenceTypeBox *dpnd;\n\tGF_MPEGVisualSampleEntryBox *entry;\n\tu32 msubtype;\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\t/*GETS NATIVE DESCRIPTOR ONLY*/\n\te = Media_GetESD(trak->Media, StreamDescriptionIndex, &esd, GF_TRUE);\n\tif (e) return e;\n\n\tentry = gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, StreamDescriptionIndex-1);\n\tif (!entry) return GF_BAD_PARAM;\n\tmsubtype = entry->type;\n\tif ((msubtype==GF_ISOM_BOX_TYPE_ENCV) || (msubtype==GF_ISOM_BOX_TYPE_ENCA))\n\t\tgf_isom_get_original_format_type(movie, trackNumber, StreamDescriptionIndex, &msubtype);\n\n\t//duplicate the desc\n\te = gf_odf_desc_copy((GF_Descriptor *)theDesc, &desc);\n\tif (e) return e;\n\n\t//and add it to the ESD EXCEPT IPI PTR (we need to translate from ES_ID to TrackID!!!\n\tif (!movie->keep_utc)\n\t\ttrak->Media->mediaHeader->modificationTime = gf_isom_get_mp4time();\n\n\tswitch (desc->tag) {\n\tcase GF_ODF_IPI_PTR_TAG:\n\t\tgoto insertIPI;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif ((msubtype==GF_ISOM_BOX_TYPE_MP4S) || (msubtype==GF_ISOM_BOX_TYPE_MP4V) || (msubtype==GF_ISOM_BOX_TYPE_MP4A)) {\n\t\treturn gf_odf_desc_add_desc((GF_Descriptor *)esd, desc);\n\t}\n\n\tif (trak->Media->handler->handlerType!=GF_ISOM_MEDIA_VISUAL) {\n\t\tgf_odf_desc_del(desc);\n\t\treturn GF_NOT_SUPPORTED;\n\t}\n\tGF_MPEG4ExtensionDescriptorsBox *mdesc = (GF_MPEG4ExtensionDescriptorsBox *) gf_isom_box_find_child(entry->child_boxes, GF_ISOM_BOX_TYPE_M4DS);\n\tif (!mdesc) {\n\t\tmdesc = (GF_MPEG4ExtensionDescriptorsBox *) gf_isom_box_new_parent(&entry->child_boxes, GF_ISOM_BOX_TYPE_M4DS);\n\t}\n\treturn gf_list_add(mdesc->descriptors, desc);\n\ninsertIPI:\n\tif (esd->ipiPtr) {\n\t\tgf_odf_desc_del((GF_Descriptor *) esd->ipiPtr);\n\t\tesd->ipiPtr = NULL;\n\t}\n\n\tipiD = (GF_IPIPtr *) desc;\n\t//find a tref\n\tif (!trak->References) {\n\t\ttref = (GF_TrackReferenceBox *) gf_isom_box_new_parent(&trak->child_boxes, GF_ISOM_BOX_TYPE_TREF);\n\t\tif (!tref) return GF_OUT_OF_MEM;\n\t\te = trak_on_child_box((GF_Box*)trak, (GF_Box *)tref, GF_FALSE);\n\t\tif (e) return e;\n\t}\n\ttref = trak->References;\n\n\te = Track_FindRef(trak, GF_ISOM_REF_IPI, &dpnd);\n\tif (e) return e;\n\tif (!dpnd) {\n\t\ttmpRef = 0;\n\t\tdpnd = (GF_TrackReferenceTypeBox *) gf_isom_box_new_parent(&tref->child_boxes, GF_ISOM_BOX_TYPE_REFT);\n\t\tif (!dpnd) return GF_OUT_OF_MEM;\n\t\tdpnd->reference_type = GF_ISOM_BOX_TYPE_IPIR;\n\t\te = reftype_AddRefTrack(dpnd, ipiD->IPI_ES_Id, &tmpRef);\n\t\tif (e) return e;\n\t\t//and replace the tag and value...\n\t\tipiD->IPI_ES_Id = tmpRef;\n\t\tipiD->tag = GF_ODF_ISOM_IPI_PTR_TAG;\n\t} else {\n\t\t//Watch out! ONLY ONE IPI dependency is allowed per stream\n\t\tdpnd->trackIDCount = 1;\n\t\tdpnd->trackIDs[0] = ipiD->IPI_ES_Id;\n\t\t//and replace the tag and value...\n\t\tipiD->IPI_ES_Id = 1;\n\t\tipiD->tag = GF_ODF_ISOM_IPI_PTR_TAG;\n\t}\n\t//and add the desc to the esd...\n\treturn gf_odf_desc_add_desc((GF_Descriptor *)esd, desc);\n}\n\n\n//use carefully. Very useful when you made a lot of changes (IPMP, IPI, OCI, ...)\n//THIS WILL REPLACE THE WHOLE DESCRIPTOR ...\nGF_EXPORT\nGF_Err gf_isom_change_mpeg4_description(GF_ISOFile *movie, u32 trackNumber, u32 StreamDescriptionIndex, const GF_ESD *newESD)\n{\n\tGF_Err e;\n\tGF_ESD *esd;\n\tGF_TrackBox *trak;\n\tGF_SampleEntryBox *entry;\n\tGF_SampleDescriptionBox *stsd;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tstsd = trak->Media->information->sampleTable->SampleDescription;\n\tif (!stsd) return movie->LastError = GF_ISOM_INVALID_FILE;\n\n\tif (!StreamDescriptionIndex || StreamDescriptionIndex > gf_list_count(stsd->child_boxes)) {\n\t\treturn movie->LastError = GF_BAD_PARAM;\n\t}\n\tentry = (GF_SampleEntryBox *)gf_list_get(stsd->child_boxes, StreamDescriptionIndex - 1);\n\t//no support for generic sample entries (eg, no MPEG4 descriptor)\n\tif (entry == NULL) return GF_BAD_PARAM;\n\n\tif (!movie->keep_utc)\n\t\ttrak->Media->mediaHeader->modificationTime = gf_isom_get_mp4time();\n\t//duplicate our desc\n\te = gf_odf_desc_copy((GF_Descriptor *)newESD, (GF_Descriptor **)&esd);\n\tif (e) return e;\n\te = Track_SetStreamDescriptor(trak, StreamDescriptionIndex, entry->dataReferenceIndex, esd, NULL);\n\tif (e != GF_OK) {\n\t\tgf_odf_desc_del((GF_Descriptor *) esd);\n\t}\n\treturn e;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_visual_info(GF_ISOFile *movie, u32 trackNumber, u32 StreamDescriptionIndex, u32 Width, u32 Height)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\tGF_SampleEntryBox *entry;\n\tGF_SampleDescriptionBox *stsd;\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tstsd = trak->Media->information->sampleTable->SampleDescription;\n\tif (!stsd) {\n\t\treturn movie->LastError = GF_ISOM_INVALID_FILE;\n\t}\n\tif (!StreamDescriptionIndex || StreamDescriptionIndex > gf_list_count(stsd->child_boxes)) {\n\t\treturn movie->LastError = GF_BAD_PARAM;\n\t}\n\tentry = (GF_SampleEntryBox *)gf_list_get(stsd->child_boxes, StreamDescriptionIndex - 1);\n\t//no support for generic sample entries (eg, no MPEG4 descriptor)\n\tif (entry == NULL) return GF_BAD_PARAM;\n\tif (!movie->keep_utc)\n\t\ttrak->Media->mediaHeader->modificationTime = gf_isom_get_mp4time();\n\n\t//valid for MPEG visual, JPG and 3GPP H263\n\tif (entry->internal_type == GF_ISOM_SAMPLE_ENTRY_VIDEO) {\n\t\t((GF_VisualSampleEntryBox*)entry)->Width = Width;\n\t\t((GF_VisualSampleEntryBox*)entry)->Height = Height;\n\t\ttrak->Header->width = Width<<16;\n\t\ttrak->Header->height = Height<<16;\n\t\treturn GF_OK;\n\t} else if (trak->Media->handler->handlerType==GF_ISOM_MEDIA_SCENE) {\n\t\ttrak->Header->width = Width<<16;\n\t\ttrak->Header->height = Height<<16;\n\t\treturn GF_OK;\n\t} else {\n\t\treturn GF_BAD_PARAM;\n\t}\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_visual_bit_depth(GF_ISOFile *movie, u32 trackNumber, u32 StreamDescriptionIndex, u16 bitDepth)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\tGF_MPEGVisualSampleEntryBox *entry;\n\tGF_SampleDescriptionBox *stsd;\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tswitch (trak->Media->handler->handlerType) {\n\tcase GF_ISOM_MEDIA_VISUAL:\n\tcase GF_ISOM_MEDIA_PICT:\n\tcase GF_ISOM_MEDIA_AUXV:\n\t\tbreak;\n\tdefault:\n\t\treturn GF_OK;\n\t}\n\n\tstsd = trak->Media->information->sampleTable->SampleDescription;\n\tif (!stsd) {\n\t\treturn movie->LastError = GF_ISOM_INVALID_FILE;\n\t}\n\tif (!StreamDescriptionIndex || StreamDescriptionIndex > gf_list_count(stsd->child_boxes)) {\n\t\treturn movie->LastError = GF_BAD_PARAM;\n\t}\n\tentry = (GF_MPEGVisualSampleEntryBox *)gf_list_get(stsd->child_boxes, StreamDescriptionIndex - 1);\n\t//no support for generic sample entries (eg, no MPEG4 descriptor)\n\tif (entry == NULL) return GF_BAD_PARAM;\n\tentry->bit_depth = bitDepth;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_pixel_aspect_ratio(GF_ISOFile *movie, u32 trackNumber, u32 StreamDescriptionIndex, s32 hSpacing, s32 vSpacing, Bool force_par)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\tGF_SampleEntryBox *entry;\n\tGF_SampleDescriptionBox *stsd;\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tstsd = trak->Media->information->sampleTable->SampleDescription;\n\tif (!stsd) return movie->LastError = GF_ISOM_INVALID_FILE;\n\tif (!StreamDescriptionIndex || StreamDescriptionIndex > gf_list_count(stsd->child_boxes)) {\n\t\treturn movie->LastError = GF_BAD_PARAM;\n\t}\n\tentry = (GF_SampleEntryBox *)gf_list_get(stsd->child_boxes, StreamDescriptionIndex - 1);\n\t//no support for generic sample entries (eg, no MPEG4 descriptor)\n\tif (entry == NULL) return GF_BAD_PARAM;\n\tif (!movie->keep_utc)\n\t\ttrak->Media->mediaHeader->modificationTime = gf_isom_get_mp4time();\n\n\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_VIDEO) return GF_BAD_PARAM;\n\n\tGF_PixelAspectRatioBox *pasp = (GF_PixelAspectRatioBox *) gf_isom_box_find_child(entry->child_boxes, GF_ISOM_BOX_TYPE_PASP);\n\tif (!hSpacing || !vSpacing || ((hSpacing == vSpacing) && !force_par))  {\n\t\tif (pasp) gf_isom_box_del_parent(&entry->child_boxes, (GF_Box *)pasp);\n\t\treturn GF_OK;\n\t}\n\tif (!pasp) {\n\t\tpasp = (GF_PixelAspectRatioBox*)gf_isom_box_new_parent(&entry->child_boxes, GF_ISOM_BOX_TYPE_PASP);\n\t\tif (!pasp) return GF_OUT_OF_MEM;\n\t}\n\tpasp->hSpacing = (u32) hSpacing;\n\tpasp->vSpacing = (u32) vSpacing;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_visual_color_info(GF_ISOFile *movie, u32 trackNumber, u32 StreamDescriptionIndex, u32 colour_type, u16 colour_primaries, u16 transfer_characteristics, u16 matrix_coefficients, Bool full_range_flag, u8 *icc_data, u32 icc_size)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\tGF_SampleEntryBox *entry;\n\tGF_SampleDescriptionBox *stsd;\n\tGF_ColourInformationBox *clr=NULL;\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tstsd = trak->Media->information->sampleTable->SampleDescription;\n\tif (!stsd) return movie->LastError = GF_ISOM_INVALID_FILE;\n\tif (!StreamDescriptionIndex || StreamDescriptionIndex > gf_list_count(stsd->child_boxes)) {\n\t\treturn movie->LastError = GF_BAD_PARAM;\n\t}\n\tentry = (GF_SampleEntryBox *)gf_list_get(stsd->child_boxes, StreamDescriptionIndex - 1);\n\t//no support for generic sample entries (eg, no MPEG4 descriptor)\n\tif (entry == NULL) return GF_BAD_PARAM;\n\tif (!movie->keep_utc)\n\t\ttrak->Media->mediaHeader->modificationTime = gf_isom_get_mp4time();\n\n\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_VIDEO) return GF_OK;\n\n\tclr = (GF_ColourInformationBox *) gf_isom_box_find_child(entry->child_boxes, GF_ISOM_BOX_TYPE_COLR);\n\tif (!colour_type) {\n\t\tif (clr) gf_isom_box_del_parent(&entry->child_boxes, (GF_Box *)clr);\n\t\treturn GF_OK;\n\t}\n\tif (!clr) {\n\t\tclr = (GF_ColourInformationBox*)gf_isom_box_new_parent(&entry->child_boxes, GF_ISOM_BOX_TYPE_COLR);\n\t\tif (!clr) return GF_OUT_OF_MEM;\n\t}\n\tclr->colour_type = colour_type;\n\tclr->colour_primaries = colour_primaries;\n\tclr->transfer_characteristics = transfer_characteristics;\n\tclr->matrix_coefficients = matrix_coefficients;\n\tclr->full_range_flag = full_range_flag;\n\tif (clr->opaque) gf_free(clr->opaque);\n\tclr->opaque = NULL;\n\tclr->opaque_size = 0;\n\tif ((colour_type==GF_ISOM_SUBTYPE_RICC) || (colour_type==GF_ISOM_SUBTYPE_PROF)) {\n\t\tclr->opaque_size = icc_data ? icc_size : 0;\n\t\tif (clr->opaque_size) {\n\t\t\tclr->opaque = gf_malloc(sizeof(char)*clr->opaque_size);\n\t\t\tif (!clr->opaque) return GF_OUT_OF_MEM;\n\t\t\tmemcpy(clr->opaque, icc_data, sizeof(char)*clr->opaque_size);\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_dolby_vision_profile(GF_ISOFile* movie, u32 trackNumber, u32 StreamDescriptionIndex, u32 dv_profile)\n{\n\tGF_Err e;\n\tGF_TrackBox* trak;\n\tGF_SampleEntryBox* entry;\n\tGF_SampleDescriptionBox* stsd;\n\tGF_DOVIConfigurationBox* dovi = NULL;\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tstsd = trak->Media->information->sampleTable->SampleDescription;\n\tif (!stsd) return movie->LastError = GF_ISOM_INVALID_FILE;\n\tif (!StreamDescriptionIndex || StreamDescriptionIndex > gf_list_count(stsd->child_boxes)) {\n\t\treturn movie->LastError = GF_BAD_PARAM;\n\t}\n\tentry = (GF_SampleEntryBox*)gf_list_get(stsd->child_boxes, StreamDescriptionIndex - 1);\n\t//no support for generic sample entries (eg, no MPEG4 descriptor)\n\tif (entry == NULL) return GF_BAD_PARAM;\n\tif (!movie->keep_utc)\n\t\ttrak->Media->mediaHeader->modificationTime = gf_isom_get_mp4time();\n\n\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_VIDEO) return GF_OK;\n\n\tdovi = ((GF_MPEGVisualSampleEntryBox*)entry)->dovi_config;\n\tif (!dv_profile) {\n\t\tif (dovi) gf_isom_box_del((GF_Box*)dovi);\n\t\t((GF_MPEGVisualSampleEntryBox*)entry)->dovi_config = NULL;\n\t\treturn GF_OK;\n\t}\n\tif (!dovi) {\n\t\tdovi = (GF_DOVIConfigurationBox*)gf_isom_box_new_parent(&entry->child_boxes, GF_ISOM_BOX_TYPE_DVCC);\n\t\tif (!dovi) return GF_OUT_OF_MEM;\n\t\t((GF_MPEGVisualSampleEntryBox*)entry)->dovi_config = dovi;\n\t}\n\tentry->type = GF_ISOM_BOX_TYPE_DVHE;\n\tdovi->DOVIConfig.dv_profile = dv_profile;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_high_dynamic_range_info(GF_ISOFile* movie, u32 trackNumber, u32 StreamDescriptionIndex, GF_MasteringDisplayColourVolumeInfo* mdcv, GF_ContentLightLevelInfo* clli)\n{\n\tGF_Err e;\n\tGF_TrackBox* trak;\n\tGF_SampleEntryBox* entry;\n\tGF_SampleDescriptionBox* stsd;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tstsd = trak->Media->information->sampleTable->SampleDescription;\n\tif (!stsd) return movie->LastError = GF_ISOM_INVALID_FILE;\n\tif (!StreamDescriptionIndex || StreamDescriptionIndex > gf_list_count(stsd->child_boxes)) {\n\t\treturn movie->LastError = GF_BAD_PARAM;\n\t}\n\tentry = (GF_SampleEntryBox*)gf_list_get(stsd->child_boxes, StreamDescriptionIndex - 1);\n\t//no support for generic sample entries (eg, no MPEG4 descriptor)\n\tif (entry == NULL) return GF_BAD_PARAM;\n\tif (!movie->keep_utc)\n\t\ttrak->Media->mediaHeader->modificationTime = gf_isom_get_mp4time();\n\n\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_VIDEO) return GF_BAD_PARAM;\n\n\tGF_MasteringDisplayColourVolumeBox *mdcvb = (GF_MasteringDisplayColourVolumeBox *) gf_isom_box_find_child(entry->child_boxes, GF_ISOM_BOX_TYPE_MDCV);\n\tif (!mdcvb) {\n\t\tmdcvb = (GF_MasteringDisplayColourVolumeBox*)gf_isom_box_new_parent(&entry->child_boxes, GF_ISOM_BOX_TYPE_MDCV);\n\t\tif (!mdcvb) return GF_OUT_OF_MEM;\n\t}\n\tmdcvb->mdcv = *mdcv;\n\n\t/*clli*/\n\tGF_ContentLightLevelBox *cllib = (GF_ContentLightLevelBox *)gf_isom_box_find_child(entry->child_boxes, GF_ISOM_BOX_TYPE_CLLI);\n\tif (!cllib) {\n\t\tcllib = (GF_ContentLightLevelBox*)gf_isom_box_new_parent(&entry->child_boxes, GF_ISOM_BOX_TYPE_CLLI);\n\t\tif (!cllib) return GF_OUT_OF_MEM;\n\t}\n\tcllib->clli = *clli;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_clean_aperture(GF_ISOFile *movie, u32 trackNumber, u32 StreamDescriptionIndex, u32 cleanApertureWidthN, u32 cleanApertureWidthD, u32 cleanApertureHeightN, u32 cleanApertureHeightD, u32 horizOffN, u32 horizOffD, u32 vertOffN, u32 vertOffD)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\tGF_SampleEntryBox *entry;\n\tGF_SampleDescriptionBox *stsd;\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tstsd = trak->Media->information->sampleTable->SampleDescription;\n\tif (!stsd) return movie->LastError = GF_ISOM_INVALID_FILE;\n\tif (!StreamDescriptionIndex || StreamDescriptionIndex > gf_list_count(stsd->child_boxes)) {\n\t\treturn movie->LastError = GF_BAD_PARAM;\n\t}\n\tentry = (GF_SampleEntryBox *)gf_list_get(stsd->child_boxes, StreamDescriptionIndex - 1);\n\t//no support for generic sample entries (eg, no MPEG4 descriptor)\n\tif (entry == NULL) return GF_BAD_PARAM;\n\tif (!movie->keep_utc)\n\t\ttrak->Media->mediaHeader->modificationTime = gf_isom_get_mp4time();\n\n\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_VIDEO) return GF_BAD_PARAM;\n\n\tGF_CleanApertureBox *clap = (GF_CleanApertureBox *)gf_isom_box_find_child(entry->child_boxes, GF_ISOM_BOX_TYPE_CLAP);\n\tif (!cleanApertureHeightD || !cleanApertureWidthD || !horizOffD || !vertOffD) {\n\t\tif (clap) gf_isom_box_del_parent(&entry->child_boxes, (GF_Box*)clap);\n\t\treturn GF_OK;\n\t}\n\tif (!clap) {\n\t\tclap = (GF_CleanApertureBox*)gf_isom_box_new_parent(&entry->child_boxes, GF_ISOM_BOX_TYPE_CLAP);\n\t\tif (!clap) return GF_OUT_OF_MEM;\n\t}\n\n\tclap->cleanApertureWidthN = cleanApertureWidthN;\n\tclap->cleanApertureWidthD = cleanApertureWidthD;\n\tclap->cleanApertureHeightN = cleanApertureHeightN;\n\tclap->cleanApertureHeightD = cleanApertureHeightD;\n\tclap->horizOffN = horizOffN;\n\tclap->horizOffD = horizOffD;\n\tclap->vertOffN = vertOffN;\n\tclap->vertOffD = vertOffD;\n\treturn GF_OK;\n}\n\n#include <gpac/maths.h>\nGF_Err gf_isom_update_aperture_info(GF_ISOFile *movie, u32 trackNumber, Bool remove)\n{\n\tGF_Err e;\n\tGF_Box *box, *enof, *prof, *clef;\n\tGF_TrackBox *trak;\n\tGF_VisualSampleEntryBox *ventry;\n\tGF_PixelAspectRatioBox *pasp;\n\tGF_CleanApertureBox *clap;\n\tu32 j, hspacing, vspacing, clap_width_num, clap_width_den, clap_height_num, clap_height_den, high, low;\n\tDouble width, height;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tif (remove) {\n\t\tif (trak->Aperture) {\n\t\t\tgf_isom_box_del(trak->Aperture);\n\t\t\ttrak->Aperture = NULL;\n\t\t}\n\t\treturn GF_OK;\n\t}\n\tenof = prof = clef = NULL;\n\tif (!trak->Aperture) {\n\t\ttrak->Aperture = gf_isom_box_new_parent(&trak->child_boxes, GF_QT_BOX_TYPE_TAPT);\n\t\tif (!trak->Aperture) return GF_OUT_OF_MEM;\n\t}\n\tif (!trak->Aperture->child_boxes) {\n\t\ttrak->Aperture->child_boxes = gf_list_new();\n\t\tif (!trak->Aperture->child_boxes)\n\t\t\treturn GF_OUT_OF_MEM;\n\t}\n\n\tj=0;\n\twhile ( (box = gf_list_enum(trak->Aperture->child_boxes, &j))) {\n\t\tswitch (box->type) {\n\t\tcase GF_QT_BOX_TYPE_CLEF: clef = box; break;\n\t\tcase GF_QT_BOX_TYPE_PROF: prof = box; break;\n\t\tcase GF_QT_BOX_TYPE_ENOF: enof = box; break;\n\t\t}\n\t}\n\tif (!clef) {\n\t\tclef = gf_isom_box_new(GF_QT_BOX_TYPE_CLEF);\n\t\tif (!clef) return GF_OUT_OF_MEM;\n\t\tgf_list_add(trak->Aperture->child_boxes, clef);\n\t}\n\tif (!enof) {\n\t\tenof = gf_isom_box_new(GF_QT_BOX_TYPE_ENOF);\n\t\tif (!enof) return GF_OUT_OF_MEM;\n\t\tgf_list_add(trak->Aperture->child_boxes, enof);\n\t}\n\tif (!prof) {\n\t\tprof = gf_isom_box_new(GF_QT_BOX_TYPE_PROF);\n\t\tif (!prof) return GF_OUT_OF_MEM;\n\t\tgf_list_add(trak->Aperture->child_boxes, prof);\n\t}\n\n\tventry = (GF_VisualSampleEntryBox *)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, 0);\n\t//no support for generic sample entries (eg, no MPEG4 descriptor)\n\tif (ventry == NULL) return GF_BAD_PARAM;\n\tif (!movie->keep_utc)\n\t\ttrak->Media->mediaHeader->modificationTime = gf_isom_get_mp4time();\n\n\tif (ventry->internal_type != GF_ISOM_SAMPLE_ENTRY_VIDEO) return GF_BAD_PARAM;\n\n\tpasp = (GF_PixelAspectRatioBox *) gf_isom_box_find_child(ventry->child_boxes, GF_ISOM_BOX_TYPE_PASP);\n\thspacing = vspacing = 0;\n\tif (pasp) {\n\t\thspacing = pasp->hSpacing;\n\t\tvspacing = pasp->vSpacing;\n\t}\n\tclap_width_num = ventry->Width;\n\tclap_width_den = 1;\n\tclap_height_num = ventry->Height;\n\tclap_height_den = 1;\n\tclap = (GF_CleanApertureBox *) gf_isom_box_find_child(ventry->child_boxes, GF_ISOM_BOX_TYPE_CLAP);\n\tif (clap) {\n\t\tclap_width_num = clap->cleanApertureWidthN;\n\t\tclap_width_den = clap->cleanApertureWidthD;\n\t\tclap_height_num = clap->cleanApertureHeightN;\n\t\tclap_height_den = clap->cleanApertureHeightD;\n\t}\n\t//enof: encoded pixels in 16.16\n\t((GF_ApertureBox *)enof)->width = (ventry->Width)<<16;\n\t((GF_ApertureBox *)enof)->height = (ventry->Height)<<16;\n\n\t//prof: encoded pixels + pasp in 16.16\n\twidth = (Float) (ventry->Width * hspacing);\n\twidth /= vspacing;\n\thigh = (u32) floor((Float)width);\n\tlow = (u32) ( 0xFFFF * (width - (Double)high) );\n\t((GF_ApertureBox *)prof)->width = (high)<<16 | low;\n\t((GF_ApertureBox *)prof)->height = (ventry->Height)<<16;\n\n\t//clef: encoded pixels + pasp + clap in 16.16\n\twidth = (Double) (clap_width_num * hspacing);\n\twidth /= clap_width_den * vspacing;\n\theight = (Float) clap_height_num;\n\theight /= clap_height_den;\n\n\thigh = (u32) floor((Float)width);\n\tlow = (u32) (0xFFFF * (width - (Double)high));\n\t((GF_ApertureBox *)clef)->width = (high)<<16 | low;\n\thigh = (u32) floor((Float)height);\n\tlow = (u32) (0xFFFF * (height - (Double)high));\n\t((GF_ApertureBox *)clef)->height = (high)<<16 | low;\n\n\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_image_sequence_coding_constraints(GF_ISOFile *movie, u32 trackNumber, u32 StreamDescriptionIndex, Bool remove, Bool all_ref_pics_intra, Bool intra_pred_used, u32 max_ref_per_pic)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\tGF_SampleEntryBox *entry;\n\tGF_SampleDescriptionBox *stsd;\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tstsd = trak->Media->information->sampleTable->SampleDescription;\n\tif (!stsd) return movie->LastError = GF_ISOM_INVALID_FILE;\n\tif (!StreamDescriptionIndex || StreamDescriptionIndex > gf_list_count(stsd->child_boxes)) {\n\t\treturn movie->LastError = GF_BAD_PARAM;\n\t}\n\tentry = (GF_SampleEntryBox *)gf_list_get(stsd->child_boxes, StreamDescriptionIndex - 1);\n\t//no support for generic sample entries (eg, no MPEG4 descriptor)\n\tif (entry == NULL) return GF_BAD_PARAM;\n\tif (!movie->keep_utc)\n\t\ttrak->Media->mediaHeader->modificationTime = gf_isom_get_mp4time();\n\n\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_VIDEO) return GF_BAD_PARAM;\n\n\tGF_CodingConstraintsBox*ccst = (GF_CodingConstraintsBox*) gf_isom_box_find_child(entry->child_boxes, GF_ISOM_BOX_TYPE_CCST);\n\tif (remove)  {\n\t\tif (ccst) gf_isom_box_del_parent(&entry->child_boxes, (GF_Box*)ccst);\n\t\treturn GF_OK;\n\t}\n\tif (!ccst) {\n\t\tccst = (GF_CodingConstraintsBox*)gf_isom_box_new_parent(&entry->child_boxes, GF_ISOM_BOX_TYPE_CCST);\n\t\tif (!ccst) return GF_OUT_OF_MEM;\n\t}\n\tccst->all_ref_pics_intra = all_ref_pics_intra;\n\tccst->intra_pred_used = intra_pred_used;\n\tccst->max_ref_per_pic = max_ref_per_pic;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_image_sequence_alpha(GF_ISOFile *movie, u32 trackNumber, u32 StreamDescriptionIndex, Bool remove)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\tGF_SampleEntryBox *entry;\n\tGF_SampleDescriptionBox *stsd;\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tstsd = trak->Media->information->sampleTable->SampleDescription;\n\tif (!stsd) return movie->LastError = GF_ISOM_INVALID_FILE;\n\tif (!StreamDescriptionIndex || StreamDescriptionIndex > gf_list_count(stsd->child_boxes)) {\n\t\treturn movie->LastError = GF_BAD_PARAM;\n\t}\n\tentry = (GF_SampleEntryBox *)gf_list_get(stsd->child_boxes, StreamDescriptionIndex - 1);\n\t//no support for generic sample entries (eg, no MPEG4 descriptor)\n\tif (entry == NULL) return GF_BAD_PARAM;\n\tif (!movie->keep_utc)\n\t\ttrak->Media->mediaHeader->modificationTime = gf_isom_get_mp4time();\n\n\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_VIDEO) return GF_BAD_PARAM;\n\n\tGF_AuxiliaryTypeInfoBox *auxi = (GF_AuxiliaryTypeInfoBox *)gf_isom_box_find_child(entry->child_boxes, GF_ISOM_BOX_TYPE_AUXI);\n\tif (remove)  {\n\t\tif (auxi) gf_isom_box_del_parent(&entry->child_boxes, (GF_Box*)auxi);\n\t\treturn GF_OK;\n\t}\n\tif (!auxi) {\n\t\tauxi = (GF_AuxiliaryTypeInfoBox*)gf_isom_box_new_parent(&entry->child_boxes, GF_ISOM_BOX_TYPE_AUXI);\n\t\tif (!auxi) return GF_OUT_OF_MEM;\n\t}\n\tauxi->aux_track_type = gf_strdup(\"urn:mpeg:mpegB:cicp:systems:auxiliary:alpha\");\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_audio_info(GF_ISOFile *movie, u32 trackNumber, u32 StreamDescriptionIndex, u32 sampleRate, u32 nbChannels, u8 bitsPerSample, GF_AudioSampleEntryImportMode asemode)\n{\n\tGF_Err e;\n\tu32 i, old_qtff_mode=GF_ISOM_AUDIO_QTFF_NONE;\n\tGF_TrackBox *trak;\n\tGF_SampleEntryBox *entry;\n\tGF_AudioSampleEntryBox*aud_entry;\n\tGF_SampleDescriptionBox *stsd;\n\tGF_Box *wave_box = NULL;\n\tGF_Box *gf_isom_audio_sample_get_audio_codec_cfg_box(GF_AudioSampleEntryBox *ptr);\n\tGF_Box *codec_ext = NULL;\n#if 0\n\tGF_ChannelLayoutInfoBox *chan=NULL;\n#endif\n\tGF_OriginalFormatBox *frma=NULL;\n\tGF_ChromaInfoBox *enda=NULL;\n\tGF_ESDBox *esds=NULL;\n\tGF_Box *terminator=NULL;\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tstsd = trak->Media->information->sampleTable->SampleDescription;\n\tif (!stsd) {\n\t\treturn movie->LastError = GF_ISOM_INVALID_FILE;\n\t}\n\tif (!StreamDescriptionIndex || StreamDescriptionIndex > gf_list_count(stsd->child_boxes)) {\n\t\treturn movie->LastError = GF_BAD_PARAM;\n\t}\n\tentry = (GF_SampleEntryBox *)gf_list_get(stsd->child_boxes, StreamDescriptionIndex - 1);\n\t//no support for generic sample entries (eg, no MPEG4 descriptor)\n\tif (entry == NULL) return GF_BAD_PARAM;\n\tif (!movie->keep_utc)\n\t\ttrak->Media->mediaHeader->modificationTime = gf_isom_get_mp4time();\n\n\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_AUDIO) return GF_BAD_PARAM;\n\taud_entry = (GF_AudioSampleEntryBox*) entry;\n\n\tif (entry->type==GF_ISOM_BOX_TYPE_MLPA) {\n\t\taud_entry->samplerate_hi = sampleRate>>16;\n\t\taud_entry->samplerate_lo = sampleRate & 0x0000FFFF;\n\t} else {\n\t\taud_entry->samplerate_hi = sampleRate;\n\t\taud_entry->samplerate_lo = 0;\n\t}\n\taud_entry->bitspersample = bitsPerSample;\n\n\tswitch (asemode) {\n\tcase GF_IMPORT_AUDIO_SAMPLE_ENTRY_v0_2:\n\t\tstsd->version = 0;\n\t\taud_entry->version = 0;\n\t\taud_entry->qtff_mode = GF_ISOM_AUDIO_QTFF_NONE;\n\t\taud_entry->channel_count = 2;\n\t\tbreak;\n\tcase GF_IMPORT_AUDIO_SAMPLE_ENTRY_NOT_SET:\n\tcase GF_IMPORT_AUDIO_SAMPLE_ENTRY_v0_BS:\n\t\tstsd->version = 0;\n\t\taud_entry->version = 0;\n\t\taud_entry->qtff_mode = GF_ISOM_AUDIO_QTFF_NONE;\n\t\taud_entry->channel_count = nbChannels;\n\t\tbreak;\n\tcase GF_IMPORT_AUDIO_SAMPLE_ENTRY_v1_MPEG:\n\t\tstsd->version = 1;\n\t\taud_entry->version = 1;\n\t\taud_entry->qtff_mode = GF_ISOM_AUDIO_QTFF_NONE;\n\t\taud_entry->channel_count = nbChannels;\n\t\tbreak;\n\tcase GF_IMPORT_AUDIO_SAMPLE_ENTRY_v1_QTFF:\n\t\tstsd->version = 0;\n\t\taud_entry->version = 1;\n\t\taud_entry->channel_count = nbChannels;\n\t\told_qtff_mode = aud_entry->qtff_mode;\n\t\tif (aud_entry->qtff_mode != GF_ISOM_AUDIO_QTFF_ON_EXT_VALID)\n\t\t\taud_entry->qtff_mode = GF_ISOM_AUDIO_QTFF_ON_NOEXT;\n\t\tbreak;\n\t}\n\n\taud_entry->compression_id = 0;\n\n\t//check for wave+children and chan for QTFF or remove them for isobmff\n\tfor (i=0; i<gf_list_count(aud_entry->child_boxes); i++) {\n\t\tGF_Box *b = gf_list_get(aud_entry->child_boxes, i);\n\t\tif ((b->type != GF_QT_BOX_TYPE_WAVE) && (b->type != GF_QT_BOX_TYPE_CHAN) ) continue;\n\t\tif (asemode==GF_IMPORT_AUDIO_SAMPLE_ENTRY_v1_QTFF) {\n\t\t\tif (b->type == GF_QT_BOX_TYPE_WAVE) wave_box = b;\n#if 0\n\t\t\telse chan = (GF_ChannelLayoutInfoBox *)b;\n#endif\n\n\t\t} else {\n\t\t\tgf_isom_box_del_parent(&aud_entry->child_boxes, b);\n\t\t\ti--;\n\t\t}\n\t}\n\n\t//TODO: insert channelLayout for ISOBMFF\n\tif (asemode!=GF_IMPORT_AUDIO_SAMPLE_ENTRY_v1_QTFF) return GF_OK;\n\n\tif (aud_entry->type==GF_ISOM_BOX_TYPE_MP4A)\n\t\taud_entry->compression_id = -2;\n\n\tif (!aud_entry->child_boxes) aud_entry->child_boxes = gf_list_new();\n\n#if 0\n\tif (!chan) {\n\t\tchan = (GF_ChannelLayoutInfoBox *) gf_isom_box_new_parent(&aud_entry->child_boxes, GF_QT_BOX_TYPE_CHAN);\n\t}\n\t//TODO, proper channel mapping\n\tchan->layout_tag = (nbChannels==2) ? 6750210 : 6553601;\n#endif\n\n\tcodec_ext = gf_isom_audio_sample_get_audio_codec_cfg_box((GF_AudioSampleEntryBox *)aud_entry);\n\tif (!codec_ext) return GF_OK;\n\n\tif (!wave_box) {\n\t\twave_box = gf_isom_box_new_parent(&aud_entry->child_boxes, GF_QT_BOX_TYPE_WAVE);\n\t}\n\n\tfor (i=0; i<gf_list_count(wave_box->child_boxes); i++) {\n\t\tGF_Box *b = gf_list_get(wave_box->child_boxes, i);\n\t\tswitch (b->type) {\n\t\tcase GF_QT_BOX_TYPE_ENDA:\n\t\t\tenda = (GF_ChromaInfoBox *)b;\n\t\t\tbreak;\n\t\tcase GF_QT_BOX_TYPE_FRMA:\n\t\t\tfrma = (GF_OriginalFormatBox *)b;\n\t\t\tbreak;\n\t\tcase GF_ISOM_BOX_TYPE_ESDS:\n\t\t\tesds = (GF_ESDBox *)b;\n\t\t\tbreak;\n\t\tcase GF_ISOM_BOX_TYPE_UNKNOWN:\n\t\t\tif ( ((GF_UnknownBox*)b)->original_4cc == 0)\n\t\t\t\tterminator = b;\n\t\t\tbreak;\n\t\tcase 0:\n\t\t\tterminator = b;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!wave_box->child_boxes) wave_box->child_boxes = gf_list_new();\n\n\t//do not use new_parent, we do this manually to ensure the order\n\taud_entry->qtff_mode = old_qtff_mode ? old_qtff_mode : GF_ISOM_AUDIO_QTFF_ON_NOEXT;\n\tif (!frma) {\n\t\tfrma = (GF_OriginalFormatBox *)gf_isom_box_new(GF_QT_BOX_TYPE_FRMA);\n\t} else {\n\t\tgf_list_del_item(wave_box->child_boxes, frma);\n\t}\n\tgf_list_add(wave_box->child_boxes, frma);\n\n\tif (esds) gf_list_del_item(wave_box->child_boxes, esds);\n\tif (!esds && (aud_entry->type==GF_ISOM_BOX_TYPE_MP4A) && ((GF_MPEGAudioSampleEntryBox*)aud_entry)->esd) {\n\t\tgf_list_del_item(entry->child_boxes, (GF_Box *) ((GF_MPEGAudioSampleEntryBox*)aud_entry)->esd);\n\t\tgf_list_add(wave_box->child_boxes, (GF_Box *) ((GF_MPEGAudioSampleEntryBox*)aud_entry)->esd);\n\t}\n\n\tif (!enda) {\n\t\tenda = (GF_ChromaInfoBox *)gf_isom_box_new(GF_QT_BOX_TYPE_ENDA);\n\t} else {\n\t\tgf_list_del_item(wave_box->child_boxes, enda);\n\t}\n\tenda->chroma=1;\n\tgf_list_add(wave_box->child_boxes, enda);\n\n\tif (!terminator) {\n\t\tterminator = gf_isom_box_new(0);\n\t} else {\n\t\tgf_list_del_item(wave_box->child_boxes, terminator);\n\t}\n\tgf_list_add(wave_box->child_boxes, terminator);\n\n\tif (aud_entry->type==GF_ISOM_BOX_TYPE_GNRA) {\n\t\tfrma->data_format = ((GF_GenericAudioSampleEntryBox*) aud_entry)->EntryType;\n\t} else {\n\t\tfrma->data_format = aud_entry->type;\n\t}\n\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_audio_layout(GF_ISOFile *movie, u32 trackNumber, u32 sampleDescriptionIndex, GF_AudioChannelLayout *layout)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\tGF_SampleEntryBox *entry;\n\tGF_AudioSampleEntryBox*aud_entry;\n\tGF_SampleDescriptionBox *stsd;\n\tGF_ChannelLayoutBox *chnl;\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tstsd = trak->Media->information->sampleTable->SampleDescription;\n\tif (!stsd) {\n\t\treturn movie->LastError = GF_ISOM_INVALID_FILE;\n\t}\n\tif (!sampleDescriptionIndex || sampleDescriptionIndex > gf_list_count(stsd->child_boxes)) {\n\t\treturn movie->LastError = GF_BAD_PARAM;\n\t}\n\tentry = (GF_SampleEntryBox *)gf_list_get(stsd->child_boxes, sampleDescriptionIndex - 1);\n\t//no support for generic sample entries (eg, no MPEG4 descriptor)\n\tif (entry == NULL) return GF_BAD_PARAM;\n\tif (!movie->keep_utc)\n\t\ttrak->Media->mediaHeader->modificationTime = gf_isom_get_mp4time();\n\n\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_AUDIO) return GF_BAD_PARAM;\n\taud_entry = (GF_AudioSampleEntryBox*) entry;\n\tif (aud_entry->qtff_mode) {\n\t\tu32 sr = aud_entry->samplerate_hi;\n\t\tif (aud_entry->type==GF_ISOM_BOX_TYPE_MLPA) {\n\t\t\tsr <<= 16;\n\t\t\tsr |= aud_entry->samplerate_lo;\n\t\t}\n\t\te = gf_isom_set_audio_info(movie, trackNumber, sampleDescriptionIndex, sr, aud_entry->channel_count, (u8) aud_entry->bitspersample, GF_IMPORT_AUDIO_SAMPLE_ENTRY_v1_MPEG);\n\t\tif (e) return e;\n\t}\n\tchnl = (GF_ChannelLayoutBox *) gf_isom_box_find_child(aud_entry->child_boxes, GF_ISOM_BOX_TYPE_CHNL);\n\tif (!chnl) {\n\t\tchnl = (GF_ChannelLayoutBox *)gf_isom_box_new_parent(&aud_entry->child_boxes, GF_ISOM_BOX_TYPE_CHNL);\n\t\tif (!chnl) return GF_OUT_OF_MEM;\n\t}\n\taud_entry->channel_count = layout->channels_count;\n\tmemcpy(&chnl->layout, layout, sizeof(GF_AudioChannelLayout));\n\treturn GF_OK;\n}\n\n//set the storage mode of a file (FLAT, STREAMABLE, INTERLEAVED)\nGF_EXPORT\nGF_Err gf_isom_set_storage_mode(GF_ISOFile *movie, GF_ISOStorageMode storageMode)\n{\n\tGF_Err e;\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\tswitch (storageMode) {\n\tcase GF_ISOM_STORE_FLAT:\n\tcase GF_ISOM_STORE_STREAMABLE:\n\tcase GF_ISOM_STORE_INTERLEAVED:\n\tcase GF_ISOM_STORE_DRIFT_INTERLEAVED:\n\tcase GF_ISOM_STORE_TIGHT:\n\tcase GF_ISOM_STORE_FASTSTART:\n\t\tmovie->storageMode = storageMode;\n\t\t//specifying a storage mode disables inplace rewrite\n\t\tgf_isom_disable_inplace_rewrite(movie);\n\t\treturn GF_OK;\n\tdefault:\n\t\treturn GF_BAD_PARAM;\n\t}\n}\n\n\nGF_EXPORT\nGF_Err gf_isom_enable_compression(GF_ISOFile *file, GF_ISOCompressMode compress_mode, Bool force_compress)\n{\n\tif (!file) return GF_BAD_PARAM;\n\tfile->compress_mode = compress_mode;\n\tfile->force_compress = force_compress;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_force_64bit_chunk_offset(GF_ISOFile *file, Bool set_on)\n{\n\tif (!file) return GF_BAD_PARAM;\n\tfile->force_co64 = set_on;\n\treturn GF_OK;\n}\n\n\n//update or insert a new edit segment in the track time line. Edits are used to modify\n//the media normal timing. EditTime and EditDuration are expressed in Movie TimeScale\n//If a segment with EditTime already exists, IT IS ERASED\nstatic GF_Err gf_isom_set_edit_internal(GF_ISOFile *movie, u32 trackNumber, u64 EditTime, u64 EditDuration, u64 MediaTime, u32 media_rate, GF_ISOEditType EditMode)\n{\n\tGF_TrackBox *trak;\n\tGF_EditBox *edts;\n\tGF_EditListBox *elst;\n\tGF_EdtsEntry *ent, *newEnt;\n\tu32 i;\n\tGF_Err e;\n\tu64 startTime;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tedts = trak->editBox;\n\tif (! edts) {\n\t\tedts = (GF_EditBox *) gf_isom_box_new_parent(&trak->child_boxes, GF_ISOM_BOX_TYPE_EDTS);\n\t\tif (!edts) return GF_OUT_OF_MEM;\n\t\ttrak_on_child_box((GF_Box*)trak, (GF_Box *)edts, GF_FALSE);\n\t}\n\telst = edts->editList;\n\tif (!elst) {\n\t\telst = (GF_EditListBox *) gf_isom_box_new_parent(&edts->child_boxes, GF_ISOM_BOX_TYPE_ELST);\n\t\tif (!elst) return GF_OUT_OF_MEM;\n\t\tedts_on_child_box((GF_Box*)edts, (GF_Box *)elst, GF_FALSE);\n\t}\n\n\tstartTime = 0;\n\tent = NULL;\n\t//get the prev entry to this startTime if any\n\ti=0;\n\twhile ((ent = (GF_EdtsEntry *)gf_list_enum(elst->entryList, &i))) {\n\t\tif ( (startTime <= EditTime) && (startTime + ent->segmentDuration > EditTime) )\n\t\t\tgoto found;\n\t\tstartTime += ent->segmentDuration;\n\t}\n\n\t//not found, add a new entry and adjust the prev one if any\n\tif (!ent) {\n\t\tnewEnt = CreateEditEntry(EditDuration, MediaTime, EditMode);\n\t\tif (!newEnt) return GF_OUT_OF_MEM;\n\t\tif (EditMode==GF_ISOM_EDIT_NORMAL+1) {\n\t\t\tnewEnt->mediaRate = media_rate;\n\t\t}\n\t\tgf_list_add(elst->entryList, newEnt);\n\t\treturn SetTrackDuration(trak);\n\t}\n\n\tstartTime -= ent->segmentDuration;\n\nfound:\n\n\t//if same time, we erase the current one...\n\tif (startTime == EditTime) {\n\t\tent->segmentDuration = EditDuration;\n\t\tif (EditMode==GF_ISOM_EDIT_NORMAL+1) {\n\t\t\tent->mediaRate = media_rate;\n\t\t\tent->mediaTime = MediaTime;\n\t\t} else {\n\t\t\tswitch (EditMode) {\n\t\t\tcase GF_ISOM_EDIT_EMPTY:\n\t\t\t\tent->mediaRate = 0x10000;\n\t\t\t\tent->mediaTime = -1;\n\t\t\t\tbreak;\n\t\t\tcase GF_ISOM_EDIT_DWELL:\n\t\t\t\tent->mediaRate = 0;\n\t\t\t\tent->mediaTime = MediaTime;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tent->mediaRate = 0x10000;\n\t\t\t\tent->mediaTime = MediaTime;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn SetTrackDuration(trak);\n\t}\n\n\t//adjust so that the prev ent leads to EntryTime\n\t//Note: we don't change the next one as it is unknown to us in\n\t//a lot of case (the author's changes)\n\tent->segmentDuration = EditTime - startTime;\n\tnewEnt = CreateEditEntry(EditDuration, MediaTime, EditMode);\n\tif (!newEnt) return GF_OUT_OF_MEM;\n\tif (EditMode==GF_ISOM_EDIT_NORMAL+1) {\n\t\tnewEnt->mediaRate = media_rate;\n\t\tnewEnt->mediaTime = MediaTime;\n\t}\n\t//is it the last entry ???\n\tif (i >= gf_list_count(elst->entryList) - 1) {\n\t\t//add the new entry at the end\n\t\tgf_list_add(elst->entryList, newEnt);\n\t\treturn SetTrackDuration(trak);\n\t} else {\n\t\t//insert after the current entry (which is i)\n\t\tgf_list_insert(elst->entryList, newEnt, i+1);\n\t\treturn SetTrackDuration(trak);\n\t}\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_edit(GF_ISOFile *movie, u32 trackNumber, u64 EditTime, u64 EditDuration, u64 MediaTime, GF_ISOEditType EditMode)\n{\n\treturn gf_isom_set_edit_internal(movie, trackNumber, EditTime, EditDuration, MediaTime, 0, EditMode);\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_edit_with_rate(GF_ISOFile *movie, u32 trackNumber, u64 EditTime, u64 EditDuration, u64 MediaTime, u32 media_rate)\n{\n\treturn gf_isom_set_edit_internal(movie, trackNumber, EditTime, EditDuration, MediaTime, media_rate, GF_ISOM_EDIT_NORMAL+1);\n\n}\n\n//remove the edit segments for the whole track\nGF_EXPORT\nGF_Err gf_isom_remove_edits(GF_ISOFile *movie, u32 trackNumber)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\tif (!trak->editBox || !trak->editBox->editList) return GF_OK;\n\n\twhile (gf_list_count(trak->editBox->editList->entryList)) {\n\t\tGF_EdtsEntry *ent = (GF_EdtsEntry*)gf_list_get(trak->editBox->editList->entryList, 0);\n\t\tgf_free(ent);\n\t\te = gf_list_rem(trak->editBox->editList->entryList, 0);\n\t\tif (e) return e;\n\t}\n\t//then delete the GF_EditBox...\n\tgf_isom_box_del_parent(&trak->child_boxes, (GF_Box *)trak->editBox);\n\ttrak->editBox = NULL;\n\treturn SetTrackDuration(trak);\n}\n\n\n//remove the edit segments for the whole track\nGF_EXPORT\nGF_Err gf_isom_remove_edit(GF_ISOFile *movie, u32 trackNumber, u32 seg_index)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\tGF_EdtsEntry *ent, *next_ent;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !seg_index) return GF_BAD_PARAM;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\tif (!trak->editBox || !trak->editBox->editList) return GF_OK;\n\tif (gf_list_count(trak->editBox->editList->entryList)<=1) return gf_isom_remove_edits(movie, trackNumber);\n\n\tent = (GF_EdtsEntry*) gf_list_get(trak->editBox->editList->entryList, seg_index-1);\n\tgf_list_rem(trak->editBox->editList->entryList, seg_index-1);\n\tnext_ent = (GF_EdtsEntry *)gf_list_get(trak->editBox->editList->entryList, seg_index-1);\n\tif (next_ent) next_ent->segmentDuration += ent->segmentDuration;\n\tgf_free(ent);\n\treturn SetTrackDuration(trak);\n}\n\n\nGF_EXPORT\nGF_Err gf_isom_append_edit(GF_ISOFile *movie, u32 trackNumber, u64 EditDuration, u64 MediaTime, GF_ISOEditType EditMode)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\tGF_EdtsEntry *ent;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\tif (!trak->editBox) {\n\t\tGF_EditBox *edts = (GF_EditBox *) gf_isom_box_new_parent(&trak->child_boxes, GF_ISOM_BOX_TYPE_EDTS);\n\t\tif (!edts) return GF_OUT_OF_MEM;\n\t\ttrak_on_child_box((GF_Box*)trak, (GF_Box *)edts, GF_FALSE);\n\t\tassert(trak->editBox);\n\t}\n\tif (!trak->editBox->editList) {\n\t\tGF_EditListBox *elst = (GF_EditListBox *) gf_isom_box_new_parent(&trak->editBox->child_boxes, GF_ISOM_BOX_TYPE_ELST);\n\t\tif (!elst) return GF_OUT_OF_MEM;\n\t\tedts_on_child_box((GF_Box*)trak->editBox, (GF_Box *)elst, GF_FALSE);\n\t\tassert(trak->editBox->editList);\n\t}\n\tent = (GF_EdtsEntry *)gf_malloc(sizeof(GF_EdtsEntry));\n\tif (!ent) return GF_OUT_OF_MEM;\n\n\tent->segmentDuration = EditDuration;\n\tswitch (EditMode) {\n\tcase GF_ISOM_EDIT_EMPTY:\n\t\tent->mediaRate = 0x10000;\n\t\tent->mediaTime = -1;\n\t\tbreak;\n\tcase GF_ISOM_EDIT_DWELL:\n\t\tent->mediaRate = 0;\n\t\tent->mediaTime = MediaTime;\n\t\tbreak;\n\tdefault:\n\t\tent->mediaRate = 0x10000;\n\t\tent->mediaTime = MediaTime;\n\t\tbreak;\n\t}\n\tgf_list_add(trak->editBox->editList->entryList, ent);\n\treturn SetTrackDuration(trak);\n}\n\nGF_EXPORT\nGF_Err gf_isom_modify_edit(GF_ISOFile *movie, u32 trackNumber, u32 seg_index, u64 EditDuration, u64 MediaTime, GF_ISOEditType EditMode)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\tGF_EdtsEntry *ent;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !seg_index) return GF_BAD_PARAM;\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\tif (!trak->editBox || !trak->editBox->editList) return GF_OK;\n\tif (gf_list_count(trak->editBox->editList->entryList)<seg_index) return GF_BAD_PARAM;\n\tent = (GF_EdtsEntry*) gf_list_get(trak->editBox->editList->entryList, seg_index-1);\n\n\tent->segmentDuration = EditDuration;\n\tswitch (EditMode) {\n\tcase GF_ISOM_EDIT_EMPTY:\n\t\tent->mediaRate = 0x10000;\n\t\tent->mediaTime = -1;\n\t\tbreak;\n\tcase GF_ISOM_EDIT_DWELL:\n\t\tent->mediaRate = 0;\n\t\tent->mediaTime = MediaTime;\n\t\tbreak;\n\tdefault:\n\t\tent->mediaRate = 0x10000;\n\t\tent->mediaTime = MediaTime;\n\t\tbreak;\n\t}\n\treturn SetTrackDuration(trak);\n}\n\n//removes the desired track\nGF_EXPORT\nGF_Err gf_isom_remove_track(GF_ISOFile *movie, u32 trackNumber)\n{\n\tGF_Err e;\n\tGF_TrackBox *the_trak, *trak;\n\tGF_TrackReferenceTypeBox *tref;\n\tu32 i, j, k, descIndex;\n\tGF_ISOTrackID *newRefs;\n\tu8 found;\n\tGF_ISOSample *samp;\n\tthe_trak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!the_trak) return GF_BAD_PARAM;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\tif (movie->moov->iods && movie->moov->iods->descriptor) {\n\t\tGF_Descriptor *desc;\n\t\tGF_ES_ID_Inc *inc;\n\t\tGF_List *ESDs;\n\t\tdesc = movie->moov->iods->descriptor;\n\t\tif (desc->tag == GF_ODF_ISOM_IOD_TAG) {\n\t\t\tESDs = ((GF_IsomInitialObjectDescriptor *)desc)->ES_ID_IncDescriptors;\n\t\t} else if (desc->tag == GF_ODF_ISOM_OD_TAG) {\n\t\t\tESDs = ((GF_IsomObjectDescriptor *)desc)->ES_ID_IncDescriptors;\n\t\t} else {\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\n\t\t//remove the track ref from the root OD if any\n\t\ti=0;\n\t\twhile ((inc = (GF_ES_ID_Inc *)gf_list_enum(ESDs, &i))) {\n\t\t\tif (inc->trackID == the_trak->Header->trackID) {\n\t\t\t\tgf_odf_desc_del((GF_Descriptor *)inc);\n\t\t\t\ti--;\n\t\t\t\tgf_list_rem(ESDs, i);\n\t\t\t}\n\t\t}\n\t}\n\n\t//remove the track from the movie\n\tgf_list_del_item(movie->moov->trackList, the_trak);\n\n\t//rewrite any OD tracks\n\ti=0;\n\twhile ((trak = (GF_TrackBox *)gf_list_enum(movie->moov->trackList, &i))) {\n\t\tif (trak->Media->handler->handlerType != GF_ISOM_MEDIA_OD) continue;\n\t\t//this is an OD track...\n\t\tj = gf_isom_get_sample_count(movie, i);\n\t\tfor (k=0; k < j; k++) {\n\t\t\t//getting the sample will remove the references to the deleted track in the output OD frame\n\t\t\tsamp = gf_isom_get_sample(movie, i, k+1, &descIndex);\n\t\t\tif (!samp) break;\n\t\t\t//so let's update with the new OD frame ! If the sample is empty, remove it\n\t\t\tif (!samp->dataLength) {\n\t\t\t\te = gf_isom_remove_sample(movie, i, k+1);\n\t\t\t\tif (e) return e;\n\t\t\t} else {\n\t\t\t\te = gf_isom_update_sample(movie, i, k+1, samp, GF_TRUE);\n\t\t\t\tif (e) return e;\n\t\t\t}\n\t\t\t//and don't forget to delete the sample\n\t\t\tgf_isom_sample_del(&samp);\n\t\t}\n\t}\n\n\t//remove the track ref from any \"tref\" box in all tracks, except the one to delete\n\t//note that we don't touch scal references, as we don't want to rewrite AVC/HEVC samples ...\n\ti=0;\n\twhile ((trak = (GF_TrackBox *)gf_list_enum(movie->moov->trackList, &i))) {\n\t\tif (trak == the_trak) continue;\n\t\tif (! trak->References || ! gf_list_count(trak->References->child_boxes)) continue;\n\n\t\tj=0;\n\t\twhile ((tref = (GF_TrackReferenceTypeBox *)gf_list_enum(trak->References->child_boxes, &j))) {\n\t\t\tif (tref->reference_type==GF_ISOM_REF_SCAL)\n\t\t\t\tcontinue;\n\n\t\t\tfound = 0;\n\t\t\tfor (k=0; k<tref->trackIDCount; k++) {\n\t\t\t\tif (tref->trackIDs[k] == the_trak->Header->trackID) found++;\n\t\t\t}\n\t\t\tif (!found) continue;\n\t\t\t//no more refs, remove this ref_type\n\t\t\tif (found == tref->trackIDCount) {\n\t\t\t\tgf_isom_box_del_parent(&trak->References->child_boxes, (GF_Box *)tref);\n\t\t\t\tj--;\n\t\t\t} else {\n\t\t\t\tnewRefs = (GF_ISOTrackID*)gf_malloc(sizeof(GF_ISOTrackID) * (tref->trackIDCount - found));\n\t\t\t\tif (!newRefs) return GF_OUT_OF_MEM;\n\t\t\t\tfound = 0;\n\t\t\t\tfor (k = 0; k < tref->trackIDCount; k++) {\n\t\t\t\t\tif (tref->trackIDs[k] != the_trak->Header->trackID) {\n\t\t\t\t\t\tnewRefs[k-found] = tref->trackIDs[k];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfound++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tgf_free(tref->trackIDs);\n\t\t\t\ttref->trackIDs = newRefs;\n\t\t\t\ttref->trackIDCount -= found;\n\t\t\t}\n\t\t}\n\t\t//a little opt: remove the ref box if empty...\n\t\tif (! gf_list_count(trak->References->child_boxes)) {\n\t\t\tgf_isom_box_del_parent(&trak->child_boxes, (GF_Box *)trak->References);\n\t\t\ttrak->References = NULL;\n\t\t}\n\t}\n\n\tgf_isom_disable_inplace_rewrite(movie);\n\n\t//delete the track\n\tgf_isom_box_del_parent(&movie->moov->child_boxes, (GF_Box *)the_trak);\n\n\t/*update next track ID*/\n\tmovie->moov->mvhd->nextTrackID = 0;\n\ti=0;\n\twhile ((trak = (GF_TrackBox *)gf_list_enum(movie->moov->trackList, &i))) {\n\t\tif (trak->Header->trackID>movie->moov->mvhd->nextTrackID)\n\t\t\tmovie->moov->mvhd->nextTrackID = trak->Header->trackID;\n\t}\n\n\tif (!gf_list_count(movie->moov->trackList)) {\n\t\tgf_list_del_item(movie->TopBoxes, movie->moov);\n\t\tgf_isom_box_del((GF_Box *)movie->moov);\n\t\tmovie->moov = NULL;\n\t}\n\treturn GF_OK;\n}\n\n\nGF_EXPORT\nGF_Err gf_isom_set_copyright(GF_ISOFile *movie, const char *threeCharCode, char *notice)\n{\n\tGF_Err e;\n\tGF_CopyrightBox *ptr;\n\tGF_UserDataMap *map;\n\tu32 count, i;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\tif (!notice || !threeCharCode) return GF_BAD_PARAM;\n\n\te = gf_isom_insert_moov(movie);\n\tif (e) return e;\n\n\tif (!movie->moov->udta) {\n\t\te = moov_on_child_box((GF_Box*)movie->moov, gf_isom_box_new_parent(&movie->moov->child_boxes, GF_ISOM_BOX_TYPE_UDTA), GF_FALSE);\n\t\tif (e) return e;\n\t}\n\tmap = udta_getEntry(movie->moov->udta, GF_ISOM_BOX_TYPE_CPRT, NULL);\n\n\tif (map) {\n\t\t//try to find one in our language...\n\t\tcount = gf_list_count(map->boxes);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tptr = (GF_CopyrightBox*)gf_list_get(map->boxes, i);\n\t\t\tif (!strcmp(threeCharCode, (const char *) ptr->packedLanguageCode)) {\n\t\t\t\tgf_free(ptr->notice);\n\t\t\t\tptr->notice = (char*)gf_malloc(sizeof(char) * (strlen(notice) + 1));\n\t\t\t\tif (!ptr->notice) return GF_OUT_OF_MEM;\n\t\t\t\tstrcpy(ptr->notice, notice);\n\t\t\t\treturn GF_OK;\n\t\t\t}\n\t\t}\n\t}\n\t//nope, create one\n\tptr = (GF_CopyrightBox *)gf_isom_box_new(GF_ISOM_BOX_TYPE_CPRT);\n\tif (!ptr) return GF_OUT_OF_MEM;\n\n\tmemcpy(ptr->packedLanguageCode, threeCharCode, 4);\n\tptr->notice = (char*)gf_malloc(sizeof(char) * (strlen(notice)+1));\n\tif (!ptr->notice) return GF_OUT_OF_MEM;\n\tstrcpy(ptr->notice, notice);\n\treturn udta_on_child_box((GF_Box *)movie->moov->udta, (GF_Box *) ptr, GF_FALSE);\n}\n\nGF_EXPORT\nGF_Err gf_isom_add_track_kind(GF_ISOFile *movie, u32 trackNumber, const char *schemeURI, const char *value)\n{\n\tGF_Err e;\n\tGF_KindBox *ptr;\n\tGF_UserDataBox *udta;\n\tGF_UserDataMap *map;\n\tu32 i, count;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\te = gf_isom_insert_moov(movie);\n\tif (e) return e;\n\n\tif (trackNumber) {\n\t\tGF_TrackBox *trak = gf_isom_get_track_from_file(movie, trackNumber);\n\t\tif (!trak) return GF_BAD_PARAM;\n\t\tif (!trak->udta) {\n\t\t\te = trak_on_child_box((GF_Box*)trak, gf_isom_box_new_parent(&trak->child_boxes, GF_ISOM_BOX_TYPE_UDTA), GF_FALSE);\n\t\t\tif (e) return e;\n\t\t}\n\t\tudta = trak->udta;\n\t} else {\n\t\treturn GF_BAD_PARAM;\n\t}\n\n\tmap = udta_getEntry(udta, GF_ISOM_BOX_TYPE_KIND, NULL);\n\tif (map) {\n\t\tcount = gf_list_count(map->boxes);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tGF_Box *b = (GF_Box *)gf_list_get(map->boxes, i);\n\t\t\tif (b->type == GF_ISOM_BOX_TYPE_KIND) {\n\t\t\t\tGF_KindBox *kb = (GF_KindBox *)b;\n\t\t\t\tif (!strcmp(kb->schemeURI, schemeURI) &&\n\t\t\t\t        ((value && kb->value && !strcmp(value, kb->value)) || (!value && !kb->value))) {\n\t\t\t\t\t// Already there\n\t\t\t\t\treturn GF_OK;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tptr = (GF_KindBox *)gf_isom_box_new(GF_ISOM_BOX_TYPE_KIND);\n\tif (e) return e;\n\n\tptr->schemeURI = gf_strdup(schemeURI);\n\tif (value) ptr->value = gf_strdup(value);\n\treturn udta_on_child_box((GF_Box *)udta, (GF_Box *) ptr, GF_FALSE);\n}\n\nGF_EXPORT\nGF_Err gf_isom_remove_track_kind(GF_ISOFile *movie, u32 trackNumber, const char *schemeURI, const char *value)\n{\n\tGF_Err e;\n\tGF_UserDataBox *udta;\n\tGF_UserDataMap *map;\n\tu32 i;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\te = gf_isom_insert_moov(movie);\n\tif (e) return e;\n\n\tif (trackNumber) {\n\t\tGF_TrackBox *trak = gf_isom_get_track_from_file(movie, trackNumber);\n\t\tif (!trak) return GF_BAD_PARAM;\n\t\tif (!trak->udta) {\n\t\t\te = trak_on_child_box((GF_Box*)trak, gf_isom_box_new_parent(&trak->child_boxes, GF_ISOM_BOX_TYPE_UDTA), GF_FALSE);\n\t\t\tif (e) return e;\n\t\t}\n\t\tudta = trak->udta;\n\t} else {\n\t\treturn GF_OK;\n\t}\n\tmap = udta_getEntry(udta, GF_ISOM_BOX_TYPE_KIND, NULL);\n\tif (map) {\n\t\tfor (i=0; i<gf_list_count(map->boxes); i++) {\n\t\t\tGF_Box *b = (GF_Box *)gf_list_get(map->boxes, i);\n\t\t\tif (b->type == GF_ISOM_BOX_TYPE_KIND) {\n\t\t\t\tGF_KindBox *kb = (GF_KindBox *)b;\n\t\t\t\tif (!schemeURI ||\n\t\t\t\t        (!strcmp(kb->schemeURI, schemeURI) &&\n\t\t\t\t         ((value && kb->value && !strcmp(value, kb->value)) || (!value && !kb->value)))) {\n\t\t\t\t\tgf_isom_box_del_parent(&map->boxes, b);\n\t\t\t\t\ti--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_add_chapter(GF_ISOFile *movie, u32 trackNumber, u64 timestamp, char *name)\n{\n\tGF_Err e;\n\tGF_ChapterListBox *ptr;\n\tu32 i, count;\n\tGF_ChapterEntry *ce;\n\tGF_UserDataBox *udta;\n\tGF_UserDataMap *map;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\te = gf_isom_insert_moov(movie);\n\tif (e) return e;\n\n\tif (trackNumber) {\n\t\tGF_TrackBox *trak = gf_isom_get_track_from_file(movie, trackNumber);\n\t\tif (!trak) return GF_BAD_PARAM;\n\t\tif (!trak->udta) {\n\t\t\te = trak_on_child_box((GF_Box*)trak, gf_isom_box_new_parent(&trak->child_boxes, GF_ISOM_BOX_TYPE_UDTA), GF_FALSE);\n\t\t\tif (e) return e;\n\t\t}\n\t\tudta = trak->udta;\n\t} else {\n\t\tif (!movie->moov->udta) {\n\t\t\te = moov_on_child_box((GF_Box*)movie->moov, gf_isom_box_new_parent(&movie->moov->child_boxes, GF_ISOM_BOX_TYPE_UDTA), GF_FALSE);\n\t\t\tif (e) return e;\n\t\t}\n\t\tudta = movie->moov->udta;\n\t}\n\n\tptr = NULL;\n\tmap = udta_getEntry(udta, GF_ISOM_BOX_TYPE_CHPL, NULL);\n\tif (!map) {\n\t\tptr = (GF_ChapterListBox *)gf_isom_box_new(GF_ISOM_BOX_TYPE_CHPL);\n\t\te = udta_on_child_box((GF_Box *)udta, (GF_Box *) ptr, GF_FALSE);\n\t\tif (e) return e;\n\t\tmap = udta_getEntry(udta, GF_ISOM_BOX_TYPE_CHPL, NULL);\n\t} else {\n\t\tptr = (GF_ChapterListBox*)gf_list_get(map->boxes, 0);\n\t}\n\tif (!map) return GF_OUT_OF_MEM;\n\n\t/*this may happen if original MP4 is not properly formatted*/\n\tif (!ptr) {\n\t\tptr = (GF_ChapterListBox *)gf_isom_box_new(GF_ISOM_BOX_TYPE_CHPL);\n\t\tif (!ptr) return GF_OUT_OF_MEM;\n\t\tgf_list_add(map->boxes, ptr);\n\t}\n\n\tGF_SAFEALLOC(ce, GF_ChapterEntry);\n\tif (!ce) return GF_OUT_OF_MEM;\n\n\tce->start_time = timestamp * 10000L;\n\tce->name = name ? gf_strdup(name) : NULL;\n\n\t/*insert in order*/\n\tcount = gf_list_count(ptr->list);\n\tfor (i=0; i<count; i++) {\n\t\tGF_ChapterEntry *ace = (GF_ChapterEntry *)gf_list_get(ptr->list, i);\n\t\tif (ace->start_time == ce->start_time) {\n\t\t\tif (ace->name) gf_free(ace->name);\n\t\t\tace->name = ce->name;\n\t\t\tgf_free(ce);\n\t\t\treturn GF_OK;\n\t\t}\n\t\tif (ace->start_time >= ce->start_time)\n\t\t\treturn gf_list_insert(ptr->list, ce, i);\n\t}\n\treturn gf_list_add(ptr->list, ce);\n}\n\nGF_EXPORT\nGF_Err gf_isom_remove_chapter(GF_ISOFile *movie, u32 trackNumber, u32 index)\n{\n\tGF_Err e;\n\tGF_ChapterListBox *ptr;\n\tGF_ChapterEntry *ce;\n\tGF_UserDataBox *udta;\n\tGF_UserDataMap *map;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\te = gf_isom_insert_moov(movie);\n\tif (e) return e;\n\n\tif (trackNumber) {\n\t\tGF_TrackBox *trak = gf_isom_get_track_from_file(movie, trackNumber);\n\t\tif (!trak) return GF_BAD_PARAM;\n\t\tif (!trak->udta) return GF_OK;\n\t\tudta = trak->udta;\n\t} else {\n\t\tif (!movie->moov->udta) return GF_OK;\n\t\tudta = movie->moov->udta;\n\t}\n\n\tmap = udta_getEntry(udta, GF_ISOM_BOX_TYPE_CHPL, NULL);\n\tif (!map) return GF_OK;\n\tptr = (GF_ChapterListBox*)gf_list_get(map->boxes, 0);\n\tif (!ptr) return GF_OK;\n\n\tif (index) {\n\t\tce = (GF_ChapterEntry *)gf_list_get(ptr->list, index-1);\n\t\tif (!ce) return GF_BAD_PARAM;\n\t\tif (ce->name) gf_free(ce->name);\n\t\tgf_free(ce);\n\t\tgf_list_rem(ptr->list, index-1);\n\t} else {\n\t\twhile (gf_list_count(ptr->list)) {\n\t\t\tce = (GF_ChapterEntry *)gf_list_get(ptr->list, 0);\n\t\t\tif (ce->name) gf_free(ce->name);\n\t\t\tgf_free(ce);\n\t\t\tgf_list_rem(ptr->list, 0);\n\t\t}\n\t}\n\tif (!gf_list_count(ptr->list)) {\n\t\tgf_list_del_item(udta->recordList, map);\n\t\tgf_isom_box_array_del(map->boxes);\n\t\tgf_free(map);\n\t}\n\treturn GF_OK;\n}\n\n#if 0 //unused\nGF_Err gf_isom_remove_copyright(GF_ISOFile *movie, u32 index)\n{\n\tGF_Err e;\n\tGF_CopyrightBox *ptr;\n\tGF_UserDataMap *map;\n\tu32 count;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\te = gf_isom_insert_moov(movie);\n\tif (e) return e;\n\n\tif (!index) return GF_BAD_PARAM;\n\tif (!movie->moov->udta) return GF_OK;\n\n\tmap = udta_getEntry(movie->moov->udta, GF_ISOM_BOX_TYPE_CPRT, NULL);\n\tif (!map) return GF_OK;\n\n\tcount = gf_list_count(map->boxes);\n\tif (index>count) return GF_BAD_PARAM;\n\n\tptr = (GF_CopyrightBox*)gf_list_get(map->boxes, index-1);\n\tif (ptr) {\n\t\tgf_list_rem(map->boxes, index-1);\n\t\tif (ptr->notice) gf_free(ptr->notice);\n\t\tgf_free(ptr);\n\t}\n\t/*last copyright, remove*/\n\tif (!gf_list_count(map->boxes)) {\n\t\tgf_list_del_item(movie->moov->udta->recordList, map);\n\t\tgf_list_del(map->boxes);\n\t\tgf_free(map);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err gf_isom_set_watermark(GF_ISOFile *movie, bin128 UUID, u8* data, u32 length)\n{\n\tGF_Err e;\n\tGF_UnknownUUIDBox *ptr;\n\tGF_UserDataMap *map;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\te = gf_isom_insert_moov(movie);\n\tif (e) return e;\n\tif (!movie->moov->udta) {\n\t\te = moov_on_child_box((GF_Box*)movie->moov, gf_isom_box_new_parent(&movie->moov->child_boxes, GF_ISOM_BOX_TYPE_UDTA));\n\t\tif (e) return e;\n\t}\n\n\tmap = udta_getEntry(movie->moov->udta, GF_ISOM_BOX_TYPE_UUID, (bin128 *) & UUID);\n\tif (map) {\n\t\tptr = (GF_UnknownUUIDBox *)gf_list_get(map->boxes, 0);\n\t\tif (ptr) {\n\t\t\tgf_free(ptr->data);\n\t\t\tptr->data = (char*)gf_malloc(length);\n\t\t\tif (!ptr->data) return GF_OUT_OF_MEM;\n\t\t\tmemcpy(ptr->data, data, length);\n\t\t\tptr->dataSize = length;\n\t\t\treturn GF_OK;\n\t\t}\n\t}\n\t//nope, create one\n\tptr = (GF_UnknownUUIDBox *)gf_isom_box_new(GF_ISOM_BOX_TYPE_UUID);\n\tif (!ptr) return GF_OUT_OF_MEM;\n\n\tmemcpy(ptr->uuid, UUID, 16);\n\tptr->data = (char*)gf_malloc(length);\n\tif (!ptr->data) return GF_OUT_OF_MEM;\n\tmemcpy(ptr->data, data, length);\n\tptr->dataSize = length;\n\treturn udta_on_child_box((GF_Box *)movie->moov->udta, (GF_Box *) ptr);\n}\n#endif\n\n//set the interleaving time of media data (INTERLEAVED mode only)\n//InterleaveTime is in MovieTimeScale\nGF_EXPORT\nGF_Err gf_isom_set_interleave_time(GF_ISOFile *movie, u32 InterleaveTime)\n{\n\tGF_Err e;\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\tif (!InterleaveTime || !movie->moov) return GF_OK;\n\tmovie->interleavingTime = InterleaveTime;\n\treturn GF_OK;\n}\n\n\n\n//use a compact track version for sample size. This is not usually recommended\n//except for speech codecs where the track has a lot of small samples\n//compaction is done automatically while writing based on the track's sample sizes\nGF_EXPORT\nGF_Err gf_isom_use_compact_size(GF_ISOFile *movie, u32 trackNumber, Bool CompactionOn)\n{\n\tGF_TrackBox *trak;\n\tu32 i, size;\n\tGF_SampleSizeBox *stsz;\n\tGF_Err e;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tif (!trak->Media || !trak->Media->information\n\t        || !trak->Media->information->sampleTable || !trak->Media->information->sampleTable->SampleSize)\n\t\treturn GF_ISOM_INVALID_FILE;\n\n\tstsz = trak->Media->information->sampleTable->SampleSize;\n\n\t//switch to regular table\n\tif (!CompactionOn) {\n\t\tif (stsz->type == GF_ISOM_BOX_TYPE_STSZ) return GF_OK;\n\t\tstsz->type = GF_ISOM_BOX_TYPE_STSZ;\n\t\t//invalidate the sampleSize and recompute it\n\t\tstsz->sampleSize = 0;\n\t\tif (!stsz->sampleCount) return GF_OK;\n\t\t//if the table is empty we can only assume the track is empty (no size indication)\n\t\tif (!stsz->sizes) return GF_OK;\n\t\tsize = stsz->sizes[0];\n\t\t//check whether the sizes are all the same or not\n\t\tfor (i=1; i<stsz->sampleCount; i++) {\n\t\t\tif (size != stsz->sizes[i]) {\n\t\t\t\tsize = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (size) {\n\t\t\tgf_free(stsz->sizes);\n\t\t\tstsz->sizes = NULL;\n\t\t\tstsz->sampleSize = size;\n\t\t}\n\t\treturn GF_OK;\n\t}\n\n\t//switch to compact table\n\tif (stsz->type == GF_ISOM_BOX_TYPE_STZ2) return GF_OK;\n\t//fill the table. Although it seems weird , this is needed in case of edition\n\t//after the function is called. NOte however than we force regular table\n\t//at write time if all samples are of same size\n\tif (stsz->sampleSize) {\n\t\t//this is a weird table indeed ;)\n\t\tif (stsz->sizes) gf_free(stsz->sizes);\n\t\tstsz->sizes = (u32*) gf_malloc(sizeof(u32)*stsz->sampleCount);\n\t\tif (!stsz->sizes) return GF_OUT_OF_MEM;\n\t\tmemset(stsz->sizes, stsz->sampleSize, sizeof(u32));\n\t}\n\t//set the SampleSize to 0 while the file is open\n\tstsz->sampleSize = 0;\n\tstsz->type = GF_ISOM_BOX_TYPE_STZ2;\n\treturn GF_OK;\n}\n\n\nGF_EXPORT\nGF_Err gf_isom_set_brand_info(GF_ISOFile *movie, u32 MajorBrand, u32 MinorVersion)\n{\n\tu32 i, *p;\n\n\tif (!MajorBrand) return GF_BAD_PARAM;\n\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\tif (! (movie->FragmentsFlags & GF_ISOM_FRAG_WRITE_READY)) {\n\t\tGF_Err e = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\t\tif (e) return e;\n\n\t\te = CheckNoData(movie);\n\t\tif (e) return e;\n\t}\n#endif\n\n\tif (!movie->brand) {\n\t\tmovie->brand = (GF_FileTypeBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_FTYP);\n\t\tif (!movie->brand) return GF_OUT_OF_MEM;\n\t\tgf_list_add(movie->TopBoxes, movie->brand);\n\t}\n\n\tmovie->brand->majorBrand = MajorBrand;\n\tmovie->brand->minorVersion = MinorVersion;\n\n\tif (!movie->brand->altBrand) {\n\t\tmovie->brand->altBrand = (u32*)gf_malloc(sizeof(u32));\n\t\tif (!movie->brand->altBrand) return GF_OUT_OF_MEM;\n\t\tmovie->brand->altBrand[0] = MajorBrand;\n\t\tmovie->brand->altCount = 1;\n\t\treturn GF_OK;\n\t}\n\n\t//if brand already present don't change anything\n\tfor (i=0; i<movie->brand->altCount; i++) {\n\t\tif (movie->brand->altBrand[i] == MajorBrand) return GF_OK;\n\t}\n\tp = (u32*)gf_malloc(sizeof(u32)*(movie->brand->altCount + 1));\n\tif (!p) return GF_OUT_OF_MEM;\n\tmemcpy(p, movie->brand->altBrand, sizeof(u32)*movie->brand->altCount);\n\tp[movie->brand->altCount] = MajorBrand;\n\tmovie->brand->altCount += 1;\n\tgf_free(movie->brand->altBrand);\n\tmovie->brand->altBrand = p;\n\treturn GF_OK;\n}\n\n\nGF_EXPORT\nGF_Err gf_isom_modify_alternate_brand(GF_ISOFile *movie, u32 Brand, Bool AddIt)\n{\n\tu32 i, k, *p;\n\n\tif (!Brand) return GF_BAD_PARAM;\n\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\tif (! (movie->FragmentsFlags & GF_ISOM_FRAG_WRITE_READY)) {\n\t\tGF_Err e = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\t\tif (e) return e;\n\n\t\te = CheckNoData(movie);\n\t\tif (e) return e;\n\t}\n#endif\n\n\tif (!movie->brand && AddIt) {\n\t\tmovie->brand = (GF_FileTypeBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_FTYP);\n\t\tif (!movie->brand) return GF_OUT_OF_MEM;\n\t\tgf_list_add(movie->TopBoxes, movie->brand);\n\t}\n\tif (!AddIt && !movie->brand) return GF_OK;\n\n\t//do not mofify major one\n\tif (!AddIt && movie->brand->majorBrand == Brand) return GF_OK;\n\n\tif (!AddIt && movie->brand->altCount == 1) {\n\t\t//fixes it in case\n\t\tmovie->brand->altBrand[0] = movie->brand->majorBrand;\n\t\treturn GF_OK;\n\t}\n\t//check for the brand\n\tfor (i=0; i<movie->brand->altCount; i++) {\n\t\tif (movie->brand->altBrand[i] == Brand) goto found;\n\t}\n\t//Not found\n\tif (!AddIt) return GF_OK;\n\t//add it\n\tp = (u32*)gf_malloc(sizeof(u32)*(movie->brand->altCount + 1));\n\tif (!p) return GF_OUT_OF_MEM;\n\tif (movie->brand->altBrand) {\n\t\tmemcpy(p, movie->brand->altBrand, sizeof(u32)*movie->brand->altCount);\n\t\tgf_free(movie->brand->altBrand);\n\t}\n\tp[movie->brand->altCount] = Brand;\n\tmovie->brand->altCount += 1;\n\tmovie->brand->altBrand = p;\n\treturn GF_OK;\n\nfound:\n\n\t//found\n\tif (AddIt) return GF_OK;\n\tassert(movie->brand->altCount>1);\n\n\t//remove it\n\tp = (u32*)gf_malloc(sizeof(u32)*(movie->brand->altCount - 1));\n\tif (!p) return GF_OUT_OF_MEM;\n\tk = 0;\n\tfor (i=0; i<movie->brand->altCount; i++) {\n\t\tif (movie->brand->altBrand[i] == Brand) continue;\n\t\telse {\n\t\t\tp[k] = movie->brand->altBrand[i];\n\t\t\tk++;\n\t\t}\n\t}\n\tmovie->brand->altCount -= 1;\n\tgf_free(movie->brand->altBrand);\n\tmovie->brand->altBrand = p;\n\treturn GF_OK;\n}\n\n\nGF_Err gf_isom_reset_alt_brands_ex(GF_ISOFile *movie, Bool leave_empty)\n{\n\tu32 *p;\n\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\tif (! (movie->FragmentsFlags & GF_ISOM_FRAG_WRITE_READY)) {\n\t\tGF_Err e = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\t\tif (e) return e;\n\n\t\te = CheckNoData(movie);\n\t\tif (e) return e;\n\t}\n#endif\n\n\tif (!movie->brand) {\n\t\tmovie->brand = (GF_FileTypeBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_FTYP);\n\t\tif (!movie->brand) return GF_OUT_OF_MEM;\n\t\tgf_list_add(movie->TopBoxes, movie->brand);\n\t}\n\tgf_free(movie->brand->altBrand);\n\tif (leave_empty) {\n\t\tmovie->brand->altCount = 0;\n\t\tmovie->brand->altBrand = NULL;\n\t} else {\n\t\tp = (u32*)gf_malloc(sizeof(u32));\n\t\tif (!p) return GF_OUT_OF_MEM;\n\t\tp[0] = movie->brand->majorBrand;\n\t\tmovie->brand->altCount = 1;\n\t\tmovie->brand->altBrand = p;\n\t}\n\treturn GF_OK;\n}\nGF_EXPORT\nGF_Err gf_isom_reset_alt_brands(GF_ISOFile *movie)\n{\n\treturn gf_isom_reset_alt_brands_ex(movie, GF_FALSE);\n}\n\n#if 0 //unused\nGF_Err gf_isom_set_sample_padding_bits(GF_ISOFile *movie, u32 trackNumber, u32 sampleNumber, u8 NbBits)\n{\n\tGF_TrackBox *trak;\n\tGF_Err e;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || NbBits > 7) return GF_BAD_PARAM;\n\n\t//set Padding info\n\treturn stbl_SetPaddingBits(trak->Media->information->sampleTable, sampleNumber, NbBits);\n}\n#endif\n\nGF_EXPORT\nGF_Err gf_isom_remove_user_data_item(GF_ISOFile *movie, u32 trackNumber, u32 UserDataType, bin128 UUID, u32 UserDataIndex)\n{\n\tGF_UserDataMap *map;\n\tGF_Box *a;\n\tu32 i;\n\tbin128 t;\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\tGF_UserDataBox *udta;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\tif (UserDataType == GF_ISOM_BOX_TYPE_UUID) UserDataType = 0;\n\tmemset(t, 1, 16);\n\n\tif (trackNumber) {\n\t\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\t\tif (!trak) return GF_BAD_PARAM;\n\t\tudta = trak->udta;\n\t} else {\n\t\tudta = movie->moov->udta;\n\t}\n\tif (!udta) return GF_BAD_PARAM;\n\tif (!UserDataIndex) return GF_BAD_PARAM;\n\n\ti=0;\n\twhile ((map = (GF_UserDataMap*)gf_list_enum(udta->recordList, &i))) {\n\t\tif ((map->boxType == GF_ISOM_BOX_TYPE_UUID)  && !memcmp(map->uuid, UUID, 16)) goto found;\n\t\telse if (map->boxType == UserDataType) goto found;\n\t}\n\t//not found\n\treturn GF_OK;\n\nfound:\n\n\tif (UserDataIndex > gf_list_count(map->boxes) ) return GF_BAD_PARAM;\n\t//delete the box\n\ta = (GF_Box*)gf_list_get(map->boxes, UserDataIndex-1);\n\tgf_isom_box_del_parent(&map->boxes, a);\n\n\t//remove the map if empty\n\tif (!gf_list_count(map->boxes)) {\n\t\tgf_list_rem(udta->recordList, i-1);\n\t\tgf_isom_box_array_del(map->boxes);\n\t\tgf_free(map);\n\t}\n\t//but we keep the UDTA no matter what\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_remove_user_data(GF_ISOFile *movie, u32 trackNumber, u32 UserDataType, bin128 UUID)\n{\n\tGF_UserDataMap *map;\n\tu32 i;\n\tGF_Err e;\n\tbin128 t;\n\tGF_TrackBox *trak;\n\tGF_UserDataBox *udta;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\tif (UserDataType == GF_ISOM_BOX_TYPE_UUID) UserDataType = 0;\n\tmemset(t, 1, 16);\n\n\tif (trackNumber) {\n\t\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\t\tif (!trak) return GF_EOS;\n\t\tudta = trak->udta;\n\t} else {\n\t\tudta = movie->moov->udta;\n\t}\n\t//do not return any error if no udta\n\tif (!udta) return GF_EOS;\n\n\ti=0;\n\twhile ((map = (GF_UserDataMap*)gf_list_enum(udta->recordList, &i))) {\n\t\tif ((map->boxType == GF_ISOM_BOX_TYPE_UUID)  && !memcmp(map->uuid, UUID, 16)) goto found;\n\t\telse if (map->boxType == UserDataType) goto found;\n\t}\n\t//not found\n\treturn GF_OK;\n\nfound:\n\n\tgf_list_rem(udta->recordList, i-1);\n\tgf_isom_box_array_del(map->boxes);\n\tgf_free(map);\n\n\t//but we keep the UDTA no matter what\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_add_user_data(GF_ISOFile *movie, u32 trackNumber, u32 UserDataType, bin128 UUID, u8 *data, u32 DataLength)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\tGF_UserDataBox *udta;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\tif (UserDataType == GF_ISOM_BOX_TYPE_UUID) UserDataType = 0;\n\n\tif (trackNumber) {\n\t\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\t\tif (!trak) return GF_BAD_PARAM;\n\t\tif (!trak->udta) trak_on_child_box((GF_Box*)trak, gf_isom_box_new_parent(&trak->child_boxes, GF_ISOM_BOX_TYPE_UDTA), GF_FALSE);\n\t\tudta = trak->udta;\n\t} else {\n\t\tif (!movie->moov->udta) moov_on_child_box((GF_Box*)movie->moov, gf_isom_box_new_parent(&movie->moov->child_boxes, GF_ISOM_BOX_TYPE_UDTA), GF_FALSE);\n\t\tudta = movie->moov->udta;\n\t}\n\tif (!udta) return GF_OUT_OF_MEM;\n\n\t//create a default box\n\tif (UserDataType) {\n\t\tGF_UnknownBox *a = (GF_UnknownBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_UNKNOWN);\n\t\tif (!a) return GF_OUT_OF_MEM;\n\t\ta->original_4cc = UserDataType;\n\t\tif (DataLength) {\n\t\t\ta->data = (char*)gf_malloc(sizeof(char)*DataLength);\n\t\t\tif (!a->data) return GF_OUT_OF_MEM;\n\t\t\tmemcpy(a->data, data, DataLength);\n\t\t\ta->dataSize = DataLength;\n\t\t}\n\t\treturn udta_on_child_box((GF_Box *)udta, (GF_Box *) a, GF_FALSE);\n\t} else {\n\t\tGF_UnknownUUIDBox *a = (GF_UnknownUUIDBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_UUID);\n\t\tif (!a) return GF_OUT_OF_MEM;\n\t\tmemcpy(a->uuid, UUID, 16);\n\t\tif (DataLength) {\n\t\t\ta->data = (char*)gf_malloc(sizeof(char)*DataLength);\n\t\t\tif (!a->data) return GF_OUT_OF_MEM;\n\t\t\tmemcpy(a->data, data, DataLength);\n\t\t\ta->dataSize = DataLength;\n\t\t}\n\t\treturn udta_on_child_box((GF_Box *)udta, (GF_Box *) a, GF_FALSE);\n\t}\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_add_user_data_boxes(GF_ISOFile *movie, u32 trackNumber, u8 *data, u32 DataLength)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\tGF_UserDataBox *udta;\n\tGF_BitStream *bs;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\tif (trackNumber) {\n\t\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\t\tif (!trak) return GF_BAD_PARAM;\n\t\tif (!trak->udta) trak_on_child_box((GF_Box*)trak, gf_isom_box_new_parent(&trak->child_boxes, GF_ISOM_BOX_TYPE_UDTA), GF_FALSE);\n\t\tudta = trak->udta;\n\t} else {\n\t\tif (!movie->moov) return GF_BAD_PARAM;\n\t\tif (!movie->moov->udta) moov_on_child_box((GF_Box*)movie->moov, gf_isom_box_new_parent(&movie->moov->child_boxes, GF_ISOM_BOX_TYPE_UDTA), GF_FALSE);\n\t\tudta = movie->moov->udta;\n\t}\n\tif (!udta) return GF_OUT_OF_MEM;\n\n\tbs = gf_bs_new(data, DataLength, GF_BITSTREAM_READ);\n\twhile (gf_bs_available(bs)) {\n\t\tGF_Box *a;\n\t\te = gf_isom_box_parse(&a, bs);\n\t\tif (e) break;\n\t\te = udta_on_child_box((GF_Box *)udta, a, GF_FALSE);\n\t\tif (e) break;\n\t}\n\tgf_bs_del(bs);\n\treturn e;\n}\n\nGF_EXPORT\nGF_Err gf_isom_clone_pl_indications(GF_ISOFile *orig, GF_ISOFile *dest)\n{\n\tGF_IsomInitialObjectDescriptor *iod_d;\n\tif (!orig || !dest) return GF_BAD_PARAM;\n\tif (!orig->moov->iods || !orig->moov->iods->descriptor) return GF_OK;\n\tif (orig->moov->iods->descriptor->tag != GF_ODF_ISOM_IOD_TAG) return GF_OK;\n\n\tAddMovieIOD(dest->moov, 1);\n\tgf_odf_desc_del((GF_Descriptor *)dest->moov->iods->descriptor);\n\tgf_odf_desc_copy((GF_Descriptor *)orig->moov->iods->descriptor, (GF_Descriptor **)&dest->moov->iods->descriptor);\n\tiod_d = (GF_IsomInitialObjectDescriptor *) dest->moov->iods->descriptor;\n\twhile (gf_list_count(iod_d->ES_ID_IncDescriptors)) {\n\t\tGF_Descriptor *d = (GF_Descriptor *)gf_list_get(iod_d->ES_ID_IncDescriptors, 0);\n\t\tgf_list_rem(iod_d->ES_ID_IncDescriptors, 0);\n\t\tgf_odf_desc_del(d);\n\t}\n\twhile (gf_list_count(iod_d->ES_ID_RefDescriptors)) {\n\t\tGF_Descriptor *d = (GF_Descriptor *)gf_list_get(iod_d->ES_ID_RefDescriptors, 0);\n\t\tgf_list_rem(iod_d->ES_ID_RefDescriptors, 0);\n\t\tgf_odf_desc_del(d);\n\t}\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_clone_box(GF_Box *src, GF_Box **dst)\n{\n\tGF_Err e;\n\tu8 *data;\n\tu32 data_size;\n\tGF_BitStream *bs;\n\n\tif (*dst) {\n\t\tgf_isom_box_del(*dst);\n\t\t*dst=NULL;\n\t}\n\tbs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\tif (!bs) return GF_OUT_OF_MEM;\n\te = gf_isom_box_size( (GF_Box *) src);\n\tif (!e) e = gf_isom_box_write((GF_Box *) src, bs);\n\tgf_bs_get_content(bs, &data, &data_size);\n\tgf_bs_del(bs);\n\tif (e) {\n\t\tif (data) gf_free(data);\n\t\treturn e;\n\t}\n\tbs = gf_bs_new(data, data_size, GF_BITSTREAM_READ);\n\tif (!bs) {\n\t\tif (data) gf_free(data);\n\t\treturn GF_OUT_OF_MEM;\n\t}\n\te = gf_isom_box_parse(dst, bs);\n\tgf_bs_del(bs);\n\tgf_free(data);\n\treturn e;\n}\n\n#if 0 //unused\n/*clones the entire movie file to destination. Tracks can be cloned if clone_tracks is set, in which case hint tracks can be\nkept if keep_hint_tracks is set\nif keep_pssh, all pssh boxes will be kept\nfragment information (mvex) is not kept*/\nGF_Err gf_isom_clone_movie(GF_ISOFile *orig_file, GF_ISOFile *dest_file, Bool clone_tracks, Bool keep_hint_tracks, Bool keep_pssh)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_Box *box;\n\n\te = CanAccessMovie(dest_file, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\tif (orig_file->brand) {\n\t\tgf_list_del_item(dest_file->TopBoxes, dest_file->brand);\n\t\tgf_isom_box_del((GF_Box *)dest_file->brand);\n\t\tdest_file->brand = NULL;\n\t\tgf_isom_clone_box((GF_Box *)orig_file->brand, (GF_Box **)&dest_file->brand);\n\t\tif (dest_file->brand) gf_list_add(dest_file->TopBoxes, dest_file->brand);\n\t}\n\n\tif (orig_file->meta) {\n\t\tgf_list_del_item(dest_file->TopBoxes, dest_file->meta);\n\t\tgf_isom_box_del((GF_Box *)dest_file->meta);\n\t\tdest_file->meta = NULL;\n\t\t/*fixme - check imports*/\n\t\tgf_isom_clone_box((GF_Box *)orig_file->meta, (GF_Box **)&dest_file->meta);\n\t\tif (dest_file->meta) gf_list_add(dest_file->TopBoxes, dest_file->meta);\n\t}\n\tif (orig_file->moov) {\n\t\tu32 i, dstTrack;\n\t\tGF_Box *iods;\n\t\tGF_List *tracks = gf_list_new();\n\t\tGF_List *old_tracks = orig_file->moov->trackList;\n\t\torig_file->moov->trackList = tracks;\n\t\tiods = (GF_Box*)orig_file->moov->iods;\n\t\torig_file->moov->iods = NULL;\n\t\te = gf_isom_clone_box((GF_Box *)orig_file->moov, (GF_Box **)&dest_file->moov);\n\t\tif (e) {\n\t\t\tgf_list_del(tracks);\n\t\t\torig_file->moov->trackList = old_tracks;\n\t\t\treturn e;\n\t\t}\n\t\torig_file->moov->trackList = old_tracks;\n\t\tgf_list_del(tracks);\n\t\torig_file->moov->iods = (GF_ObjectDescriptorBox*)iods;\n\t\tgf_list_add(dest_file->TopBoxes, dest_file->moov);\n\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t\tif (dest_file->moov->mvex) {\n\t\t\tgf_isom_box_del_parent(&dest_file->moov->child_boxes, (GF_Box *)dest_file->moov->mvex);\n\t\t\tdest_file->moov->mvex = NULL;\n\t\t}\n#endif\n\n\t\tif (clone_tracks) {\n\t\t\tfor (i=0; i<gf_list_count(orig_file->moov->trackList); i++) {\n\t\t\t\tGF_TrackBox *trak = (GF_TrackBox*)gf_list_get( orig_file->moov->trackList, i);\n\t\t\t\tif (!trak) continue;\n\t\t\t\tif (keep_hint_tracks || (trak->Media->handler->handlerType != GF_ISOM_MEDIA_HINT)) {\n\t\t\t\t\te = gf_isom_clone_track(orig_file, i+1, dest_file, 0, &dstTrack);\n\t\t\t\t\tif (e) return e;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (iods)\n\t\t\t\tgf_isom_clone_box((GF_Box *)orig_file->moov->iods, (GF_Box **)dest_file->moov->iods);\n\t\t} else {\n\t\t\tdest_file->moov->mvhd->nextTrackID = 1;\n\t\t\tgf_isom_clone_pl_indications(orig_file, dest_file);\n\t\t}\n\t\tdest_file->moov->mov = dest_file;\n\t}\n\n\tif (!keep_pssh) {\n\t\ti=0;\n\t\twhile ((box = (GF_Box*)gf_list_get(dest_file->moov->child_boxes, i++))) {\n\t\t\tif (box->type == GF_ISOM_BOX_TYPE_PSSH) {\n\t\t\t\ti--;\n\t\t\t\tgf_isom_box_del_parent(&dest_file->moov->child_boxes, box);\n\t\t\t}\n\t\t}\n\t}\n\n\t//duplicate other boxes\n\ti=0;\n\twhile ((box = (GF_Box*)gf_list_get(orig_file->TopBoxes, i++))) {\n\t\tswitch(box->type) {\n\t\tcase GF_ISOM_BOX_TYPE_MOOV:\n\t\tcase GF_ISOM_BOX_TYPE_META:\n\t\tcase GF_ISOM_BOX_TYPE_MDAT:\n\t\tcase GF_ISOM_BOX_TYPE_FTYP:\n\t\tcase GF_ISOM_BOX_TYPE_PDIN:\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\t\tcase GF_ISOM_BOX_TYPE_STYP:\n\t\tcase GF_ISOM_BOX_TYPE_SIDX:\n\t\tcase GF_ISOM_BOX_TYPE_SSIX:\n\t\tcase GF_ISOM_BOX_TYPE_MOOF:\n#endif\n\t\tcase GF_ISOM_BOX_TYPE_JP:\n\t\t\tbreak;\n\n\t\tcase GF_ISOM_BOX_TYPE_PSSH:\n\t\t\tif (!keep_pssh)\n\t\t\t\tbreak;\n\n\t\tdefault:\n\t\t{\n\t\t\tGF_Box *box2 = NULL;\n\t\t\tgf_isom_clone_box(box, &box2);\n\t\t\tgf_list_add(dest_file->TopBoxes, box2);\n\t\t}\n\t\tbreak;\n\t\t}\n\t}\n\n\treturn GF_OK;\n}\n#endif\n\n\nGF_EXPORT\nGF_Err gf_isom_get_raw_user_data(GF_ISOFile *file, u8 **output, u32 *output_size)\n{\n\tGF_BitStream *bs;\n\tGF_Err e;\n\tGF_Box *b;\n\tu32 i;\n\n\t*output = NULL;\n\t*output_size = 0;\n\tif (!file || !file->moov || (!file->moov->udta && !file->moov->child_boxes)) return GF_OK;\n\tbs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\n\tif (file->moov->udta) {\n\t\te = gf_isom_box_size( (GF_Box *) file->moov->udta);\n\t\tif (e) goto exit;\n\t\te = gf_isom_box_write((GF_Box *) file->moov->udta, bs);\n\t\tif (e) goto exit;\n\t}\n\te = GF_OK;\n\ti=0;\n\twhile ((b = gf_list_enum(file->moov->child_boxes, &i))) {\n\t\tswitch (b->type) {\n\t\tcase GF_ISOM_BOX_TYPE_TRAK:\n\t\tcase GF_ISOM_BOX_TYPE_MVHD:\n\t\tcase GF_ISOM_BOX_TYPE_MVEX:\n\t\tcase GF_ISOM_BOX_TYPE_IODS:\n\t\tcase GF_ISOM_BOX_TYPE_META:\n\t\t\tcontinue;\n\t\t}\n\t\te = gf_isom_box_size( (GF_Box *) b);\n\t\tif (e) goto exit;\n\t\te = gf_isom_box_write((GF_Box *) b, bs);\n\t\tif (e) goto exit;\n\t}\n\n\tgf_bs_get_content(bs, output, output_size);\n\nexit:\n\tgf_bs_del(bs);\n\treturn e;\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_track_template(GF_ISOFile *file, u32 track, u8 **output, u32 *output_size)\n{\n\tGF_TrackBox *trak;\n\tGF_BitStream *bs;\n\tGF_DataReferenceBox *dref;\n\tGF_SampleTableBox *stbl, *stbl_temp;\n\tGF_SampleEncryptionBox *senc;\n\tu32 i, count;\n\n\t*output = NULL;\n\t*output_size = 0;\n\t/*get orig sample desc and clone it*/\n\ttrak = gf_isom_get_track_from_file(file, track);\n\tif (!trak || !trak->Media) return GF_BAD_PARAM;\n\n\t//don't serialize dref\n\tdref = NULL;\n\tif (trak->Media->information->dataInformation) {\n\t\tdref = trak->Media->information->dataInformation->dref;\n\t\ttrak->Media->information->dataInformation->dref = NULL;\n\t\tgf_list_del_item(trak->Media->information->dataInformation->child_boxes, dref);\n\t}\n\n\t//don't serialize stbl but create a temp one\n\tstbl_temp = (GF_SampleTableBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_STBL);\n\tif (!stbl_temp->child_boxes) stbl_temp->child_boxes = gf_list_new();\n\tstbl = trak->Media->information->sampleTable;\n\tgf_list_del_item(trak->Media->information->child_boxes, stbl);\n\n\ttrak->Media->information->sampleTable = stbl_temp;\n\tgf_list_add(trak->Media->information->child_boxes, stbl_temp);\n\n\t/*do not clone sampleDescription table but create an empty one*/\n\tstbl_temp->SampleDescription = (GF_SampleDescriptionBox *) gf_isom_box_new_parent(&stbl_temp->child_boxes, GF_ISOM_BOX_TYPE_STSD);\n\n\t/*clone sampleGroups description tables if any*/\n\tstbl_temp->sampleGroupsDescription = stbl->sampleGroupsDescription;\n\tcount = gf_list_count(stbl->sampleGroupsDescription);\n\tfor (i=0;i<count; i++) {\n\t\tGF_Box *b = gf_list_get(stbl->sampleGroupsDescription, i);\n\t\tgf_list_add(stbl_temp->child_boxes, b);\n\t}\n\t/*clone CompositionToDecode table, we may remove it later*/\n\tstbl_temp->CompositionToDecode = stbl->CompositionToDecode;\n\tgf_list_add(stbl_temp->child_boxes, stbl->CompositionToDecode);\n\n\n\t//don't serialize senc\n\tsenc = trak->sample_encryption;\n\tif (senc) {\n\t\tassert(trak->child_boxes);\n\t\tgf_list_del_item(trak->child_boxes, senc);\n\t\ttrak->sample_encryption = NULL;\n\t}\n\n\tbs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\n\tgf_isom_box_size( (GF_Box *) trak);\n\tgf_isom_box_write((GF_Box *) trak, bs);\n\tgf_bs_get_content(bs, output, output_size);\n\tgf_bs_del(bs);\n\n\t//restore our pointers\n\tif (dref) {\n\t\ttrak->Media->information->dataInformation->dref = dref;\n\t\tgf_list_add(trak->Media->information->dataInformation->child_boxes, dref);\n\t}\n\ttrak->Media->information->sampleTable = stbl;\n\tgf_list_add(trak->Media->information->child_boxes, stbl);\n\tgf_list_del_item(trak->Media->information->child_boxes, stbl_temp);\n\tif (senc) {\n\t\ttrak->sample_encryption = senc;\n\t\tgf_list_add(trak->child_boxes, senc);\n\t}\n\n\tstbl_temp->sampleGroupsDescription = NULL;\n\tcount = gf_list_count(stbl->sampleGroupsDescription);\n\tfor (i=0;i<count; i++) {\n\t\tGF_Box *b = gf_list_get(stbl->sampleGroupsDescription, i);\n\t\tgf_list_del_item(stbl_temp->child_boxes, b);\n\t}\n\n\tstbl_temp->CompositionToDecode = NULL;\n\tgf_list_del_item(stbl_temp->child_boxes, stbl->CompositionToDecode);\n\tgf_isom_box_del((GF_Box *)stbl_temp);\n\treturn GF_OK;\n\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_trex_template(GF_ISOFile *file, u32 track, u8 **output, u32 *output_size)\n{\n\tGF_TrackBox *trak;\n\tGF_BitStream *bs;\n\tu32 i;\n\tGF_TrackExtendsBox *trex = NULL;\n\tGF_TrackExtensionPropertiesBox *trexprop = NULL;\n\n\t*output = NULL;\n\t*output_size = 0;\n\t/*get orig sample desc and clone it*/\n\ttrak = gf_isom_get_track_from_file(file, track);\n\tif (!trak || !trak->Media) return GF_BAD_PARAM;\n\tif (!file->moov->mvex) return GF_NOT_FOUND;\n\tfor (i=0; i<gf_list_count(file->moov->mvex->TrackExList); i++) {\n\t\ttrex = gf_list_get(file->moov->mvex->TrackExList, i);\n\t\tif (trex->trackID == trak->Header->trackID) break;\n\t\ttrex = NULL;\n\t}\n\tif (!trex) return GF_NOT_FOUND;\n\n\tfor (i=0; i<gf_list_count(file->moov->mvex->TrackExPropList); i++) {\n\t\ttrexprop = gf_list_get(file->moov->mvex->TrackExPropList, i);\n\t\tif (trexprop->trackID== trak->Header->trackID) break;\n\t\ttrexprop = NULL;\n\t}\n\tbs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\tgf_isom_box_size( (GF_Box *) trex);\n\tgf_isom_box_write((GF_Box *) trex, bs);\n\n\tif (trexprop) {\n\t\tgf_isom_box_size( (GF_Box *) trexprop);\n\t\tgf_isom_box_write((GF_Box *) trexprop, bs);\n\t}\n\tgf_bs_get_content(bs, output, output_size);\n\tgf_bs_del(bs);\n\n\treturn GF_OK;\n\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_stsd_template(GF_ISOFile *file, u32 track, u32 stsd_idx, u8 **output, u32 *output_size)\n{\n\tGF_TrackBox *trak;\n\tGF_BitStream *bs;\n\tGF_Box *ent;\n\n\t*output = NULL;\n\t*output_size = 0;\n\t/*get orig sample desc and clone it*/\n\ttrak = gf_isom_get_track_from_file(file, track);\n\tif (!trak || !stsd_idx || !trak->Media || !trak->Media->information || !trak->Media->information->sampleTable || !trak->Media->information->sampleTable->SampleDescription) return GF_BAD_PARAM;\n\n\tent = gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, stsd_idx-1);\n\tif (!ent) return GF_BAD_PARAM;\n\n\tbs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\n\tgf_isom_box_size( (GF_Box *) ent);\n\tgf_isom_box_write((GF_Box *) ent, bs);\n\tgf_bs_get_content(bs, output, output_size);\n\tgf_bs_del(bs);\n\treturn GF_OK;\n\n}\n\n\nGF_EXPORT\nGF_Err gf_isom_clone_track(GF_ISOFile *orig_file, u32 orig_track, GF_ISOFile *dest_file, GF_ISOTrackCloneFlags flags, u32 *dest_track)\n{\n\tGF_TrackBox *trak, *new_tk;\n\tGF_BitStream *bs;\n\tu8 *data;\n\tconst u8 *buffer;\n\tu32 data_size;\n\tu32 i, count;\n\tGF_Err e;\n\tGF_SampleTableBox *stbl, *stbl_temp;\n\tGF_SampleEncryptionBox *senc;\n\n\te = CanAccessMovie(dest_file, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\te = gf_isom_insert_moov(dest_file);\n\tif (e) return e;\n\n\t/*get orig sample desc and clone it*/\n\ttrak = gf_isom_get_track_from_file(orig_file, orig_track);\n\tif (!trak || !trak->Media) return GF_BAD_PARAM;\n\n\tstbl = trak->Media->information->sampleTable;\n\tstbl_temp = (GF_SampleTableBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_STBL);\n\tif (!stbl_temp->child_boxes) stbl_temp->child_boxes = gf_list_new();\n\n\ttrak->Media->information->sampleTable = stbl_temp;\n\tgf_list_add(trak->Media->information->child_boxes, stbl_temp);\n\tgf_list_del_item(trak->Media->information->child_boxes, stbl);\n\n\tif (!stbl_temp->child_boxes) stbl_temp->child_boxes = gf_list_new();\n\n\t/*clone sampleDescription table*/\n\tstbl_temp->SampleDescription = stbl->SampleDescription;\n\tgf_list_add(stbl_temp->child_boxes, stbl->SampleDescription);\n\t/*also clone sampleGroups description tables if any*/\n\tstbl_temp->sampleGroupsDescription = stbl->sampleGroupsDescription;\n\tcount = gf_list_count(stbl->sampleGroupsDescription);\n\tfor (i=0; i<count; i++) {\n\t\tGF_Box *b = gf_list_get(stbl->sampleGroupsDescription, i);\n\t\tgf_list_add(stbl_temp->child_boxes, b);\n\t}\n\t/*clone CompositionToDecode table, we may remove it later*/\n\tstbl_temp->CompositionToDecode = stbl->CompositionToDecode;\n\tgf_list_add(stbl_temp->child_boxes, stbl->CompositionToDecode);\n\n\tsenc = trak->sample_encryption;\n\tif (senc) {\n\t\tassert(trak->child_boxes);\n\t\tgf_list_del_item(trak->child_boxes, senc);\n\t\ttrak->sample_encryption = NULL;\n\t}\n\n\tbs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\n\tgf_isom_box_size( (GF_Box *) trak);\n\tgf_isom_box_write((GF_Box *) trak, bs);\n\tgf_bs_get_content(bs, &data, &data_size);\n\tgf_bs_del(bs);\n\tbs = gf_bs_new(data, data_size, GF_BITSTREAM_READ);\n\tif (flags & GF_ISOM_CLONE_TRACK_NO_QT)\n\t\tgf_bs_set_cookie(bs, GF_ISOM_BS_COOKIE_QT_CONV | GF_ISOM_BS_COOKIE_CLONE_TRACK);\n\telse\n\t\tgf_bs_set_cookie(bs, GF_ISOM_BS_COOKIE_CLONE_TRACK);\n\n\te = gf_isom_box_parse((GF_Box **) &new_tk, bs);\n\tgf_bs_del(bs);\n\tgf_free(data);\n\n\ttrak->Media->information->sampleTable = stbl;\n\tgf_list_del_item(trak->Media->information->child_boxes, stbl_temp);\n\tgf_list_add(trak->Media->information->child_boxes, stbl);\n\n\tif (senc) {\n\t\ttrak->sample_encryption = senc;\n\t\tgf_list_add(trak->child_boxes, senc);\n\t}\n\tgf_list_del_item(stbl_temp->child_boxes, stbl_temp->SampleDescription);\n\tstbl_temp->SampleDescription = NULL;\n\n\tcount = gf_list_count(stbl->sampleGroupsDescription);\n\tfor (i=0; i<count; i++) {\n\t\tGF_Box *b = gf_list_get(stbl->sampleGroupsDescription, i);\n\t\tgf_list_del_item(stbl_temp->child_boxes, b);\n\t}\n\tstbl_temp->sampleGroupsDescription = NULL;\n\n\tgf_list_del_item(stbl_temp->child_boxes, stbl_temp->CompositionToDecode);\n\tstbl_temp->CompositionToDecode = NULL;\n\tgf_isom_box_del((GF_Box *)stbl_temp);\n\n\tif (e) {\n\t\tif (new_tk) gf_isom_box_del((GF_Box *)new_tk);\n\t\treturn e;\n\t}\n\n\tgf_isom_disable_inplace_rewrite(dest_file);\n\n\t/*create default boxes*/\n\tstbl = new_tk->Media->information->sampleTable;\n\tstbl->ChunkOffset = gf_isom_box_new_parent(&stbl->child_boxes, GF_ISOM_BOX_TYPE_STCO);\n\tif (!stbl->ChunkOffset) return GF_OUT_OF_MEM;\n\tstbl->SampleSize = (GF_SampleSizeBox *) gf_isom_box_new_parent(&stbl->child_boxes, GF_ISOM_BOX_TYPE_STSZ);\n\tif (!stbl->SampleSize) return GF_OUT_OF_MEM;\n\tstbl->SampleToChunk = (GF_SampleToChunkBox *) gf_isom_box_new_parent(&stbl->child_boxes, GF_ISOM_BOX_TYPE_STSC);\n\tif (!stbl->SampleToChunk) return GF_OUT_OF_MEM;\n\tstbl->TimeToSample = (GF_TimeToSampleBox *) gf_isom_box_new_parent(&stbl->child_boxes, GF_ISOM_BOX_TYPE_STTS);\n\tif (!stbl->TimeToSample) return GF_OUT_OF_MEM;\n\n\t/*check trackID validity before adding track*/\n\tif (gf_isom_get_track_by_id(dest_file, new_tk->Header->trackID)) {\n\t\tu32 ID = 1;\n\t\twhile (1) {\n\t\t\tif (RequestTrack(dest_file->moov, ID)) break;\n\t\t\tID += 1;\n\t\t\tif (ID == 0xFFFFFFFF) break;\n\t\t}\n\t\tnew_tk->Header->trackID = ID;\n\t}\n\tif (!dest_file->moov->child_boxes) dest_file->moov->child_boxes = gf_list_new();\n\tgf_list_add(dest_file->moov->child_boxes, new_tk);\n\tmoov_on_child_box((GF_Box*)dest_file->moov, (GF_Box *)new_tk, GF_FALSE);\n\n\t/*set originalID*/\n\tnew_tk->originalID = trak->Header->trackID;\n\t/*set originalFile*/\n\tbuffer = gf_isom_get_filename(orig_file);\n\tnew_tk->originalFile = gf_crc_32(buffer, (u32) strlen(buffer));\n\n\t/*rewrite edit list segmentDuration to new movie timescale*/\n\tif (dest_file->moov->mvhd->timeScale != orig_file->moov->mvhd->timeScale) {\n\t\tDouble ts_scale = dest_file->moov->mvhd->timeScale;\n\t\tts_scale /= orig_file->moov->mvhd->timeScale;\n\t\tnew_tk->Header->duration = (u64) (new_tk->Header->duration * ts_scale);\n\t\tif (new_tk->editBox && new_tk->editBox->editList) {\n\t\t\tcount = gf_list_count(new_tk->editBox->editList->entryList);\n\t\t\tfor (i=0; i<count; i++) {\n\t\t\t\tGF_EdtsEntry *ent = (GF_EdtsEntry *)gf_list_get(new_tk->editBox->editList->entryList, i);\n\t\t\t\tent->segmentDuration = (u64) (ent->segmentDuration * ts_scale);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!new_tk->Media->information->dataInformation->dref) return GF_BAD_PARAM;\n\n\t/*reset data ref*/\n\tif (! (flags & GF_ISOM_CLONE_TRACK_KEEP_DREF) ) {\n\t\tGF_SampleEntryBox *entry;\n\t\tBool use_alis = GF_FALSE;\n\t\tif (! (flags & GF_ISOM_CLONE_TRACK_NO_QT)) {\n\t\t\tGF_Box *b = gf_list_get(new_tk->Media->information->dataInformation->dref->child_boxes, 0);\n\t\t\tif (b && b->type==GF_QT_BOX_TYPE_ALIS)\n\t\t\t\tuse_alis = GF_TRUE;\n\t\t}\n\t\tgf_isom_box_array_del(new_tk->Media->information->dataInformation->dref->child_boxes);\n\t\tnew_tk->Media->information->dataInformation->dref->child_boxes = gf_list_new();\n\t\t/*update data ref*/\n\t\tentry = (GF_SampleEntryBox*)gf_list_get(new_tk->Media->information->sampleTable->SampleDescription->child_boxes, 0);\n\t\tif (entry) {\n\t\t\tu32 dref;\n\t\t\tMedia_CreateDataRef(dest_file, new_tk->Media->information->dataInformation->dref, use_alis ?  \"alis\" : NULL, NULL, &dref);\n\t\t\tentry->dataReferenceIndex = dref;\n\t\t}\n\t} else {\n\t\tfor (i=0; i<gf_list_count(new_tk->Media->information->dataInformation->dref->child_boxes); i++) {\n\t\t\tGF_DataEntryBox *dref_entry = (GF_DataEntryBox *)gf_list_get(new_tk->Media->information->dataInformation->dref->child_boxes, i);\n\t\t\tif (dref_entry->flags & 1) {\n\t\t\t\tdref_entry->flags &= ~1;\n\t\t\t\te = Media_SetDrefURL((GF_DataEntryURLBox *)dref_entry, orig_file->fileName, dest_file->finalName);\n\t\t\t\tif (e) return e;\n\t\t\t}\n\t\t}\n\t}\n\n\t*dest_track = gf_list_count(dest_file->moov->trackList);\n\n\tif (dest_file->moov->mvhd->nextTrackID<= new_tk->Header->trackID)\n\t\tdest_file->moov->mvhd->nextTrackID = new_tk->Header->trackID+1;\n\n\treturn GF_OK;\n}\n\n#if 0\n/*clones all sampleDescription entries in new track, after an optional reset of existing entries*/\nGF_Err gf_isom_clone_sample_descriptions(GF_ISOFile *the_file, u32 trackNumber, GF_ISOFile *orig_file, u32 orig_track, Bool reset_existing)\n{\n\tu32 i;\n\tGF_TrackBox *dst_trak, *src_trak;\n\tGF_Err e = CanAccessMovie(the_file, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\tdst_trak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!dst_trak || !dst_trak->Media) return GF_BAD_PARAM;\n\tsrc_trak = gf_isom_get_track_from_file(orig_file, orig_track);\n\tif (!src_trak || !src_trak->Media) return GF_BAD_PARAM;\n\n\tif (reset_existing) {\n\t\tgf_isom_box_array_del(dst_trak->Media->information->sampleTable->SampleDescription->child_boxes);\n\t\tdst_trak->Media->information->sampleTable->SampleDescription->child_boxes = gf_list_new();\n\t}\n\n\tfor (i=0; i<gf_list_count(src_trak->Media->information->sampleTable->SampleDescription->child_boxes); i++) {\n\t\tu32 outDesc;\n\t\te = gf_isom_clone_sample_description(the_file, trackNumber, orig_file, orig_track, i+1, NULL, NULL, &outDesc);\n\t\tif (e) break;\n\t}\n\treturn e;\n}\n#endif\n\n\nGF_EXPORT\nGF_Err gf_isom_clone_sample_description(GF_ISOFile *the_file, u32 trackNumber, GF_ISOFile *orig_file, u32 orig_track, u32 orig_desc_index, const char *URLname, const char *URNname, u32 *outDescriptionIndex)\n{\n\tGF_TrackBox *trak;\n\tGF_BitStream *bs;\n\tu8 *data;\n\tu32 data_size;\n\tGF_Box *entry;\n\tGF_Err e;\n\tu32 dataRefIndex;\n    u32 mtype;\n\n\te = CanAccessMovie(the_file, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\t/*get orig sample desc and clone it*/\n\ttrak = gf_isom_get_track_from_file(orig_file, orig_track);\n\tif (!trak || !trak->Media) return GF_BAD_PARAM;\n\n\tentry = (GF_Box*)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, orig_desc_index-1);\n\tif (!entry) return GF_BAD_PARAM;\n\n\tbs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\n\tgf_isom_box_size(entry);\n\tgf_isom_box_write(entry, bs);\n\tgf_bs_get_content(bs, &data, &data_size);\n\tgf_bs_del(bs);\n\tbs = gf_bs_new(data, data_size, GF_BITSTREAM_READ);\n\te = gf_isom_box_parse(&entry, bs);\n\tgf_bs_del(bs);\n\tgf_free(data);\n\tif (e) return e;\n\n\t/*get new track and insert clone*/\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media) goto exit;\n\n\t/*get or create the data ref*/\n\te = Media_FindDataRef(trak->Media->information->dataInformation->dref, (char *)URLname, (char *)URNname, &dataRefIndex);\n\tif (e) goto exit;\n\tif (!dataRefIndex) {\n\t\te = Media_CreateDataRef(the_file, trak->Media->information->dataInformation->dref, (char *)URLname, (char *)URNname, &dataRefIndex);\n\t\tif (e) goto exit;\n\t}\n\tif (!the_file->keep_utc)\n\t\ttrak->Media->mediaHeader->modificationTime = gf_isom_get_mp4time();\n\t/*overwrite dref*/\n\t((GF_SampleEntryBox *)entry)->dataReferenceIndex = dataRefIndex;\n\te = gf_list_add(trak->Media->information->sampleTable->SampleDescription->child_boxes, entry);\n\t*outDescriptionIndex = gf_list_count(trak->Media->information->sampleTable->SampleDescription->child_boxes);\n\n\t/*also clone track w/h info*/\n    mtype = gf_isom_get_media_type(the_file, trackNumber);\n\tif (gf_isom_is_video_handler_type(mtype) ) {\n\t\tgf_isom_set_visual_info(the_file, trackNumber, (*outDescriptionIndex), ((GF_VisualSampleEntryBox*)entry)->Width, ((GF_VisualSampleEntryBox*)entry)->Height);\n\t}\n\treturn e;\n\nexit:\n\tgf_isom_box_del(entry);\n\treturn e;\n}\n\nGF_EXPORT\nGF_Err gf_isom_new_generic_sample_description(GF_ISOFile *movie, u32 trackNumber, const char *URLname, const char *URNname, GF_GenericSampleDescription *udesc, u32 *outDescriptionIndex)\n{\n\tGF_TrackBox *trak;\n\tGF_Err e;\n\tu32 dataRefIndex;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !trak->Media || !udesc) return GF_BAD_PARAM;\n\n\t//get or create the data ref\n\te = Media_FindDataRef(trak->Media->information->dataInformation->dref, (char *)URLname, (char *)URNname, &dataRefIndex);\n\tif (e) return e;\n\tif (!dataRefIndex) {\n\t\te = Media_CreateDataRef(movie, trak->Media->information->dataInformation->dref, (char *)URLname, (char *)URNname, &dataRefIndex);\n\t\tif (e) return e;\n\t}\n\tif (!movie->keep_utc)\n\t\ttrak->Media->mediaHeader->modificationTime = gf_isom_get_mp4time();\n\n\tif (gf_isom_is_video_handler_type(trak->Media->handler->handlerType)) {\n\t\tGF_GenericVisualSampleEntryBox *entry;\n\t\t//create a new entry\n\t\tentry = (GF_GenericVisualSampleEntryBox*) gf_isom_box_new(GF_ISOM_BOX_TYPE_GNRV);\n\t\tif (!entry) return GF_OUT_OF_MEM;\n\n\t\tif (!udesc->codec_tag) {\n\t\t\tentry->EntryType = GF_ISOM_BOX_TYPE_UUID;\n\t\t\tmemcpy(entry->uuid, udesc->UUID, sizeof(bin128));\n\t\t} else {\n\t\t\tentry->EntryType = udesc->codec_tag;\n\t\t}\n\t\tif (entry->EntryType == 0) {\n\t\t\tgf_isom_box_del((GF_Box *)entry);\n\t\t\treturn GF_NOT_SUPPORTED;\n\t\t}\n\n\t\tentry->dataReferenceIndex = dataRefIndex;\n\t\tentry->vendor = udesc->vendor_code;\n\t\tentry->version = udesc->version;\n\t\tentry->revision = udesc->revision;\n\t\tentry->temporal_quality = udesc->temporal_quality;\n\t\tentry->spatial_quality = udesc->spatial_quality;\n\t\tentry->Width = udesc->width;\n\t\tentry->Height = udesc->height;\n\t\tstrcpy(entry->compressor_name, udesc->compressor_name);\n\t\tentry->color_table_index = -1;\n\t\tentry->frames_per_sample = 1;\n\t\tentry->horiz_res = udesc->h_res ? udesc->h_res : 0x00480000;\n\t\tentry->vert_res = udesc->v_res ? udesc->v_res : 0x00480000;\n\t\tentry->bit_depth = udesc->depth ? udesc->depth : 0x18;\n\t\tif (udesc->extension_buf && udesc->extension_buf_size) {\n\t\t\tentry->data = (char*)gf_malloc(sizeof(char) * udesc->extension_buf_size);\n\t\t\tif (!entry->data) {\n\t\t\t\tgf_isom_box_del((GF_Box *) entry);\n\t\t\t\treturn GF_OUT_OF_MEM;\n\t\t\t}\n\t\t\tmemcpy(entry->data, udesc->extension_buf, udesc->extension_buf_size);\n\t\t\tentry->data_size = udesc->extension_buf_size;\n\t\t}\n\t\te = gf_list_add(trak->Media->information->sampleTable->SampleDescription->child_boxes, entry);\n\t}\n\telse if (trak->Media->handler->handlerType==GF_ISOM_MEDIA_AUDIO) {\n\t\tGF_GenericAudioSampleEntryBox *gena;\n\t\t//create a new entry\n\t\tgena = (GF_GenericAudioSampleEntryBox*) gf_isom_box_new(GF_ISOM_BOX_TYPE_GNRA);\n\t\tif (!gena) return GF_OUT_OF_MEM;\n\n\t\tif (!udesc->codec_tag) {\n\t\t\tgena->EntryType = GF_ISOM_BOX_TYPE_UUID;\n\t\t\tmemcpy(gena->uuid, udesc->UUID, sizeof(bin128));\n\t\t} else {\n\t\t\tgena->EntryType = udesc->codec_tag;\n\t\t}\n\t\tif (gena->EntryType == 0) {\n\t\t\tgf_isom_box_del((GF_Box *)gena);\n\t\t\treturn GF_NOT_SUPPORTED;\n\t\t}\n\n\t\tgena->dataReferenceIndex = dataRefIndex;\n\t\tgena->vendor = udesc->vendor_code;\n\t\tgena->version = udesc->version;\n\t\tgena->revision = udesc->revision;\n\t\tgena->bitspersample = udesc->bits_per_sample ? udesc->bits_per_sample : 16;\n\t\tgena->channel_count = udesc->nb_channels ? udesc->nb_channels : 2;\n\t\tgena->samplerate_hi = udesc->samplerate;\n\t\tgena->samplerate_lo = 0;\n\t\tgena->qtff_mode = udesc->is_qtff ? GF_ISOM_AUDIO_QTFF_ON_NOEXT : GF_ISOM_AUDIO_QTFF_NONE;\n\n\t\tif (udesc->extension_buf && udesc->extension_buf_size) {\n\t\t\tgena->data = (char*)gf_malloc(sizeof(char) * udesc->extension_buf_size);\n\t\t\tif (!gena->data) {\n\t\t\t\tgf_isom_box_del((GF_Box *) gena);\n\t\t\t\treturn GF_OUT_OF_MEM;\n\t\t\t}\n\t\t\tmemcpy(gena->data, udesc->extension_buf, udesc->extension_buf_size);\n\t\t\tgena->data_size = udesc->extension_buf_size;\n\t\t}\n\t\te = gf_list_add(trak->Media->information->sampleTable->SampleDescription->child_boxes, gena);\n\t}\n\telse {\n\t\tGF_GenericSampleEntryBox *genm;\n\t\t//create a new entry\n\t\tgenm = (GF_GenericSampleEntryBox*) gf_isom_box_new(GF_ISOM_BOX_TYPE_GNRM);\n\t\tif (!genm) return GF_OUT_OF_MEM;\n\n\t\tif (!udesc->codec_tag) {\n\t\t\tgenm->EntryType = GF_ISOM_BOX_TYPE_UUID;\n\t\t\tmemcpy(genm->uuid, udesc->UUID, sizeof(bin128));\n\t\t} else {\n\t\t\tgenm->EntryType = udesc->codec_tag;\n\t\t}\n\t\tif (genm->EntryType == 0) {\n\t\t\tgf_isom_box_del((GF_Box *)genm);\n\t\t\treturn GF_NOT_SUPPORTED;\n\t\t}\n\n\t\tgenm->dataReferenceIndex = dataRefIndex;\n\t\tif (udesc->extension_buf && udesc->extension_buf_size) {\n\t\t\tgenm->data = (char*)gf_malloc(sizeof(char) * udesc->extension_buf_size);\n\t\t\tif (!genm->data) {\n\t\t\t\tgf_isom_box_del((GF_Box *) genm);\n\t\t\t\treturn GF_OUT_OF_MEM;\n\t\t\t}\n\t\t\tmemcpy(genm->data, udesc->extension_buf, udesc->extension_buf_size);\n\t\t\tgenm->data_size = udesc->extension_buf_size;\n\t\t}\n\t\te = gf_list_add(trak->Media->information->sampleTable->SampleDescription->child_boxes, genm);\n\t}\n\t*outDescriptionIndex = gf_list_count(trak->Media->information->sampleTable->SampleDescription->child_boxes);\n\treturn e;\n}\n\n//use carefully. Very useful when you made a lot of changes (IPMP, IPI, OCI, ...)\n//THIS WILL REPLACE THE WHOLE DESCRIPTOR ...\n#if 0 //unused\n/*change the data field of an unknown sample description*/\nGF_Err gf_isom_change_generic_sample_description(GF_ISOFile *movie, u32 trackNumber, u32 StreamDescriptionIndex, GF_GenericSampleDescription *udesc)\n{\n\tGF_TrackBox *trak;\n\tGF_Err e;\n\tGF_GenericVisualSampleEntryBox *entry;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !trak->Media || !StreamDescriptionIndex) return GF_BAD_PARAM;\n\n\tentry = (GF_GenericVisualSampleEntryBox *)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, StreamDescriptionIndex-1);\n\tif (!entry) return GF_BAD_PARAM;\n\tif (entry->type == GF_ISOM_BOX_TYPE_GNRV) {\n\t\tentry->vendor = udesc->vendor_code;\n\t\tentry->version = udesc->version;\n\t\tentry->revision = udesc->revision;\n\t\tentry->temporal_quality = udesc->temporal_quality;\n\t\tentry->spatial_quality = udesc->spatial_quality;\n\t\tentry->Width = udesc->width;\n\t\tentry->Height = udesc->height;\n\t\tstrcpy(entry->compressor_name, udesc->compressor_name);\n\t\tentry->color_table_index = -1;\n\t\tentry->frames_per_sample = 1;\n\t\tentry->horiz_res = udesc->h_res ? udesc->h_res : 0x00480000;\n\t\tentry->vert_res = udesc->v_res ? udesc->v_res : 0x00480000;\n\t\tentry->bit_depth = udesc->depth ? udesc->depth : 0x18;\n\t\tif (entry->data) gf_free(entry->data);\n\t\tentry->data = NULL;\n\t\tentry->data_size = 0;\n\t\tif (udesc->extension_buf && udesc->extension_buf_size) {\n\t\t\tentry->data = (char*)gf_malloc(sizeof(char) * udesc->extension_buf_size);\n\t\t\tif (!entry->data) {\n\t\t\t\tgf_isom_box_del((GF_Box *) entry);\n\t\t\t\treturn GF_OUT_OF_MEM;\n\t\t\t}\n\t\t\tmemcpy(entry->data, udesc->extension_buf, udesc->extension_buf_size);\n\t\t\tentry->data_size = udesc->extension_buf_size;\n\t\t}\n\t\treturn GF_OK;\n\t} else if (entry->type == GF_ISOM_BOX_TYPE_GNRA) {\n\t\tGF_GenericAudioSampleEntryBox *gena = (GF_GenericAudioSampleEntryBox *)entry;\n\t\tgena->vendor = udesc->vendor_code;\n\t\tgena->version = udesc->version;\n\t\tgena->revision = udesc->revision;\n\t\tgena->bitspersample = udesc->bits_per_sample ? udesc->bits_per_sample : 16;\n\t\tgena->channel_count = udesc->nb_channels ? udesc->nb_channels : 2;\n\t\tgena->samplerate_hi = udesc->samplerate;\n\t\tgena->samplerate_lo = 0;\n\t\tif (gena->data) gf_free(gena->data);\n\t\tgena->data = NULL;\n\t\tgena->data_size = 0;\n\n\t\tif (udesc->extension_buf && udesc->extension_buf_size) {\n\t\t\tgena->data = (char*)gf_malloc(sizeof(char) * udesc->extension_buf_size);\n\t\t\tif (!gena->data) {\n\t\t\t\tgf_isom_box_del((GF_Box *) gena);\n\t\t\t\treturn GF_OUT_OF_MEM;\n\t\t\t}\n\t\t\tmemcpy(gena->data, udesc->extension_buf, udesc->extension_buf_size);\n\t\t\tgena->data_size = udesc->extension_buf_size;\n\t\t}\n\t\treturn GF_OK;\n\t} else if (entry->type == GF_ISOM_BOX_TYPE_GNRM) {\n\t\tGF_GenericSampleEntryBox *genm = (GF_GenericSampleEntryBox *)entry;\n\t\tif (genm->data) gf_free(genm->data);\n\t\tgenm->data = NULL;\n\t\tgenm->data_size = 0;\n\n\t\tif (udesc->extension_buf && udesc->extension_buf_size) {\n\t\t\tgenm->data = (char*)gf_malloc(sizeof(char) * udesc->extension_buf_size);\n\t\t\tif (!genm->data) {\n\t\t\t\tgf_isom_box_del((GF_Box *) genm);\n\t\t\t\treturn GF_OUT_OF_MEM;\n\t\t\t}\n\t\t\tmemcpy(genm->data, udesc->extension_buf, udesc->extension_buf_size);\n\t\t\tgenm->data_size = udesc->extension_buf_size;\n\t\t}\n\t\treturn GF_OK;\n\t}\n\treturn GF_BAD_PARAM;\n}\n#endif\n\n#if 0\n/*removes given stream description*/\nGF_Err gf_isom_remove_sample_description(GF_ISOFile *movie, u32 trackNumber, u32 streamDescIndex)\n{\n\tGF_TrackBox *trak;\n\tGF_Err e;\n\tGF_Box *entry;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !trak->Media || !streamDescIndex) return GF_BAD_PARAM;\n\tentry = (GF_Box*)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, streamDescIndex-1);\n\tif (!entry) return GF_BAD_PARAM;\n\tgf_list_rem(trak->Media->information->sampleTable->SampleDescription->child_boxes, streamDescIndex-1);\n\tgf_isom_box_del(entry);\n\treturn GF_OK;\n}\n#endif\n\n//sets a track reference\nGF_EXPORT\nGF_Err gf_isom_set_track_reference(GF_ISOFile *the_file, u32 trackNumber, u32 referenceType, GF_ISOTrackID ReferencedTrackID)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\tGF_TrackReferenceBox *tref;\n\tGF_TrackReferenceTypeBox *dpnd;\n\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\t//no tref, create one\n\ttref = trak->References;\n\tif (!tref) {\n\t\ttref = (GF_TrackReferenceBox *) gf_isom_box_new_parent(&trak->child_boxes, GF_ISOM_BOX_TYPE_TREF);\n\t\tif (!tref) return GF_OUT_OF_MEM;\n\t\te = trak_on_child_box((GF_Box*)trak, (GF_Box *) tref, GF_FALSE);\n\t\tif (e) return e;\n\t}\n\t//find a ref of the given type\n\te = Track_FindRef(trak, referenceType, &dpnd);\n\tif (e) return e;\n\n\tif (!dpnd) {\n\t\tdpnd = (GF_TrackReferenceTypeBox *) gf_isom_box_new_parent(&tref->child_boxes, GF_ISOM_BOX_TYPE_REFT);\n\t\tif (!dpnd) return GF_OUT_OF_MEM;\n\t\tdpnd->reference_type = referenceType;\n\t}\n\t//add the ref\n\treturn reftype_AddRefTrack(dpnd, ReferencedTrackID, NULL);\n}\n\nGF_EXPORT\nGF_Err gf_isom_purge_track_reference(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\tGF_TrackReferenceTypeBox *ref;\n\tu32 i=0;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\t//no tref, nothing to remove\n\tif (!trak->References) return GF_OK;\n\n\twhile ((ref = gf_list_enum(trak->References->child_boxes, &i))) {\n\t\tu32 k;\n\t\tif (!ref->reference_type) continue;\n\n\t\tfor (k=0; k<ref->trackIDCount; k++) {\n\t\t\tu32 tk = gf_isom_get_track_by_id(the_file, ref->trackIDs[k]);\n\t\t\tif (!tk) {\n\t\t\t\tmemmove(&ref->trackIDs[k], &ref->trackIDs[k+1], ref->trackIDCount-k-1);\n\t\t\t\tk--;\n\t\t\t\tref->trackIDCount--;\n\t\t\t}\n\t\t}\n\t\tif (!ref->trackIDCount) {\n\t\t\ti--;\n\t\t\tgf_isom_box_del_parent(&trak->References->child_boxes, (GF_Box *) ref);\n\t\t}\n\t}\n\tif (!trak->References->child_boxes || !gf_list_count(trak->References->child_boxes)) {\n\t\tgf_isom_box_del_parent(&trak->child_boxes, (GF_Box *) trak->References);\n\t\ttrak->References = NULL;\n\t}\n\treturn GF_OK;\n}\n\n//sets a track reference\nGF_EXPORT\nGF_Err gf_isom_remove_track_references(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tif (trak->References) {\n\t\tgf_isom_box_del_parent(&trak->child_boxes, (GF_Box *)trak->References);\n\t\ttrak->References = NULL;\n\t}\n\treturn GF_OK;\n}\n\nGF_Err gf_isom_remove_track_reference(GF_ISOFile *isom_file, u32 trackNumber, u32 ref_type)\n{\n\tGF_TrackBox *trak;\n\tu32 i=0;\n\tGF_TrackReferenceTypeBox *ref;\n\ttrak = gf_isom_get_track_from_file(isom_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tif (!trak->References) return GF_OK;\n\twhile ((ref = gf_list_enum(trak->References->child_boxes, &i))) {\n\t\tif (ref->reference_type == ref_type) {\n\t\t\tgf_isom_box_del_parent(&trak->References->child_boxes, (GF_Box *)ref);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn GF_OK;\n\n}\n\n//changes track ID\nGF_EXPORT\nGF_Err gf_isom_set_track_id(GF_ISOFile *movie, u32 trackNumber, GF_ISOTrackID trackID)\n{\n\tGF_TrackReferenceTypeBox *ref;\n\tGF_TrackBox *trak, *a_trak;\n\tu32 i, j, k;\n\n\tif (!movie) return GF_BAD_PARAM;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (trak && (trak->Header->trackID==trackID)) return GF_OK;\n\ta_trak = gf_isom_get_track_from_id(movie->moov, trackID);\n\tif (!trak || a_trak) return GF_BAD_PARAM;\n\n\tif (movie->moov->mvhd->nextTrackID<=trackID)\n\t\tmovie->moov->mvhd->nextTrackID = trackID;\n\n\t/*rewrite all dependencies*/\n\ti=0;\n\twhile ((a_trak = (GF_TrackBox*)gf_list_enum(movie->moov->trackList, &i))) {\n\t\tif (!a_trak->References) continue;\n\t\tj=0;\n\t\twhile ((ref = (GF_TrackReferenceTypeBox *)gf_list_enum(a_trak->References->child_boxes, &j))) {\n\t\t\tfor (k=0; k<ref->trackIDCount; k++) {\n\t\t\t\tif (ref->trackIDs[k]==trak->Header->trackID) {\n\t\t\t\t\tref->trackIDs[k] = trackID;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/*and update IOD if any*/\n\tif (movie->moov->iods && movie->moov->iods->descriptor) {\n\t\tGF_ES_ID_Inc *inc;\n\t\tGF_IsomObjectDescriptor *od = (GF_IsomObjectDescriptor *)movie->moov->iods->descriptor;\n\n\t\ti=0;\n\t\twhile ((inc = (GF_ES_ID_Inc*)gf_list_enum(od->ES_ID_IncDescriptors, &i))) {\n\t\t\tif (inc->trackID==trak->Header->trackID) inc->trackID = trackID;\n\t\t}\n\t}\n\ttrak->Header->trackID = trackID;\n\treturn GF_OK;\n}\n\n/*force to rewrite all dependencies when the trackID of referenced track changes*/\nGF_EXPORT\nGF_Err gf_isom_rewrite_track_dependencies(GF_ISOFile *movie, u32 trackNumber)\n{\n\tGF_TrackReferenceTypeBox *ref;\n\tGF_TrackBox *trak, *a_trak;\n\tu32 i, k;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak)\n\t\treturn GF_BAD_PARAM;\n\tif (!trak->References)\n\t\treturn GF_OK;\n\n\ti=0;\n\twhile ((ref = (GF_TrackReferenceTypeBox *)gf_list_enum(trak->References->child_boxes, &i))) {\n\t\tfor (k=0; k < ref->trackIDCount; k++) {\n\t\t\ta_trak = gf_isom_get_track_from_original_id(movie->moov, ref->trackIDs[k], trak->originalFile);\n\t\t\tif (a_trak) {\n\t\t\t\tref->trackIDs[k] = a_trak->Header->trackID;\n\t\t\t} else {\n\t\t\t\ta_trak = gf_isom_get_track_from_id(movie->moov, ref->trackIDs[k]);\n\t\t\t\t/*we should have a track with no original ID (not imported) - should we rewrite the dependency ?*/\n\t\t\t\tif (! a_trak || a_trak->originalID) return GF_BAD_PARAM;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn GF_OK;\n}\n\n#if 0 //unused\n\n/*! changes the sample description index of a sample\n\\param isom_file the destination ISO file\n\\param trackNumber the destination track\n\\param sampleNum the target sample number\n\\param fnewSampleDescIndex the new sample description index to assign to the sample\n\\return error if any\n*/\nGF_EXPORT\nGF_Err gf_isom_change_sample_desc_index(GF_ISOFile *the_file, u32 trackNumber, u32 sample_number, u32 newSampleDescIndex)\n{\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !sample_number || !newSampleDescIndex) return GF_BAD_PARAM;\n\tif (!trak->is_unpacked) {\n\t\tunpack_track(trak);\n\t}\n\tif (!trak->Media->information->sampleTable->SampleToChunk) return GF_BAD_PARAM;\n\tif (trak->Media->information->sampleTable->SampleToChunk->nb_entries < sample_number) return GF_BAD_PARAM;\n\ttrak->Media->information->sampleTable->SampleToChunk->entries[sample_number-1].sampleDescriptionIndex = newSampleDescIndex;\n\treturn GF_OK;\n}\n\n/*modify CTS offset of a given sample (used for B-frames) - MUST be called in unpack mode only*/\nGF_EXPORT\nGF_Err gf_isom_modify_cts_offset(GF_ISOFile *the_file, u32 trackNumber, u32 sample_number, u32 offset)\n{\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\tif (!trak->Media->information->sampleTable->CompositionOffset) return GF_BAD_PARAM;\n\tif (!trak->Media->information->sampleTable->CompositionOffset->unpack_mode) return GF_BAD_PARAM;\n\t/*we're in unpack mode: one entry per sample*/\n\ttrak->Media->information->sampleTable->CompositionOffset->entries[sample_number - 1].decodingOffset = offset;\n\treturn GF_OK;\n}\n#endif\n\nGF_EXPORT\nGF_Err gf_isom_shift_cts_offset(GF_ISOFile *the_file, u32 trackNumber, s32 offset_shift)\n{\n\tu32 i;\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\tif (!trak->Media->information->sampleTable->CompositionOffset) return GF_BAD_PARAM;\n\tif (!trak->Media->information->sampleTable->CompositionOffset->unpack_mode) return GF_BAD_PARAM;\n\n\tfor (i=0; i<trak->Media->information->sampleTable->CompositionOffset->nb_entries; i++) {\n\t\t/*we're in unpack mode: one entry per sample*/\n\t\ttrak->Media->information->sampleTable->CompositionOffset->entries[i].decodingOffset -= offset_shift;\n\t}\n\treturn GF_OK;\n}\n\n#if 0 //unused\nGF_Err gf_isom_remove_cts_info(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_SampleTableBox *stbl;\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tstbl = trak->Media->information->sampleTable;\n\tif (!stbl->CompositionOffset) return GF_OK;\n\n\tgf_isom_box_del_parent(&stbl->child_boxes, (GF_Box *)stbl->CompositionOffset);\n\tstbl->CompositionOffset = NULL;\n\treturn GF_OK;\n}\n#endif\n\nGF_EXPORT\nGF_Err gf_isom_set_cts_packing(GF_ISOFile *the_file, u32 trackNumber, Bool unpack)\n{\n\tGF_Err e;\n\tGF_Err stbl_repackCTS(GF_CompositionOffsetBox *ctts);\n\tGF_Err stbl_unpackCTS(GF_SampleTableBox *stbl);\n\tGF_SampleTableBox *stbl;\n\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tstbl = trak->Media->information->sampleTable;\n\tif (unpack) {\n\t\tif (!stbl->CompositionOffset) {\n\t\t\tstbl->CompositionOffset = (GF_CompositionOffsetBox *) gf_isom_box_new_parent(&stbl->child_boxes, GF_ISOM_BOX_TYPE_CTTS);\n\t\t\tif (!stbl->CompositionOffset) return GF_OUT_OF_MEM;\n\t\t}\n\t\te = stbl_unpackCTS(stbl);\n\t} else {\n\t\tif (!stbl->CompositionOffset) return GF_OK;\n\t\te = stbl_repackCTS(stbl->CompositionOffset);\n\t}\n\tif (e) return e;\n\treturn SetTrackDuration(trak);\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_track_matrix(GF_ISOFile *the_file, u32 trackNumber, s32 matrix[9])\n{\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Header) return GF_BAD_PARAM;\n\tmemcpy(trak->Header->matrix, matrix, sizeof(trak->Header->matrix));\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_track_layout_info(GF_ISOFile *the_file, u32 trackNumber, u32 width, u32 height, s32 translation_x, s32 translation_y, s16 layer)\n{\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Header) return GF_BAD_PARAM;\n\ttrak->Header->width = width;\n\ttrak->Header->height = height;\n\ttrak->Header->matrix[6] = translation_x;\n\ttrak->Header->matrix[7] = translation_y;\n\ttrak->Header->layer = layer;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_media_timescale(GF_ISOFile *the_file, u32 trackNumber, u32 newTS, u32 new_tsinc, u32 force_rescale_type)\n{\n\tDouble scale;\n\tu32 old_ts_inc=0;\n\tu32 old_timescale;\n\tGF_TrackBox *trak;\n\tGF_SampleTableBox *stbl;\n\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media || !trak->Media->mediaHeader) return GF_BAD_PARAM;\n\tif ((trak->Media->mediaHeader->timeScale==newTS) && !new_tsinc)\n\t\treturn GF_EOS;\n\n\tif (!newTS) newTS = trak->Media->mediaHeader->timeScale;\n\tscale = newTS;\n\tscale /= trak->Media->mediaHeader->timeScale;\n\told_timescale = trak->Media->mediaHeader->timeScale;\n\ttrak->Media->mediaHeader->timeScale = newTS;\n\n\tstbl = trak->Media->information->sampleTable;\n\tif (new_tsinc) {\n\t\tu32 i;\n\t\tif (!stbl->TimeToSample || !stbl->TimeToSample->nb_entries)\n\t\t\treturn GF_BAD_PARAM;\n\n\t\tfor (i=0; i<stbl->TimeToSample->nb_entries; i++) {\n\t\t\tif (!old_ts_inc)\n\t\t\t\told_ts_inc = stbl->TimeToSample->entries[i].sampleDelta;\n\t\t\telse if (old_ts_inc<stbl->TimeToSample->entries[i].sampleDelta)\n\t\t\t\told_ts_inc = stbl->TimeToSample->entries[i].sampleDelta;\n\t\t}\n\n\t\tif ((old_timescale==newTS) && (old_ts_inc==new_tsinc))\n\t\t\treturn GF_EOS;\n\n\t\tif (!force_rescale_type)\n\t\t\tforce_rescale_type = 1;\n\t\telse if (force_rescale_type==2) {\n\t\t\tgf_free(stbl->TimeToSample->entries);\n\t\t\tstbl->TimeToSample->alloc_size = 1;\n\t\t\tstbl->TimeToSample->nb_entries = 1;\n\t\t\tstbl->TimeToSample->entries = gf_malloc(sizeof(GF_SttsEntry));\n\t\t\tstbl->TimeToSample->entries[0].sampleDelta = new_tsinc;\n\t\t\tstbl->TimeToSample->entries[0].sampleCount = stbl->SampleSize->sampleCount;\n\t\t}\n\n\n\t\tfor (i=0; i<stbl->TimeToSample->nb_entries; i++) {\n\t\t\tstbl->TimeToSample->entries[i].sampleDelta = new_tsinc;\n\t\t}\n\n\t\tif (stbl->CompositionOffset) {\n\t\t\tfor (i=0; i<stbl->CompositionOffset->nb_entries; i++) {\n\t\t\t\tu32 old_offset = stbl->CompositionOffset->entries[i].decodingOffset;\n\t\t\t\tif (force_rescale_type==2) {\n\t\t\t\t\tu32 val = old_offset ;\n\t\t\t\t\t//get number of TS delta\n\t\t\t\t\told_offset /= old_ts_inc;\n\t\t\t\t\tif (old_offset * old_ts_inc < val)\n\t\t\t\t\t\told_offset++;\n\t\t\t\t\told_offset *= new_tsinc;\n\t\t\t\t} else {\n\t\t\t\t\told_offset *= new_tsinc;\n\t\t\t\t\told_offset /= old_ts_inc;\n\t\t\t\t}\n\t\t\t\tstbl->CompositionOffset->entries[i].decodingOffset = old_offset;\n\t\t\t}\n\t\t}\n\n#define RESCALE_TSVAL(_tsval) {\\\n\t\t\ts64 val = ((s64) _tsval) * new_tsinc;\\\n\t\t\tval /= old_ts_inc;\\\n\t\t\t_tsval = (s32) val;\\\n\t\t}\n\n\t\tif (stbl->CompositionToDecode) {\n\t\t\tRESCALE_TSVAL(stbl->CompositionToDecode->compositionEndTime)\n\t\t\tRESCALE_TSVAL(stbl->CompositionToDecode->compositionStartTime)\n\t\t\tRESCALE_TSVAL(stbl->CompositionToDecode->compositionToDTSShift)\n\t\t\tRESCALE_TSVAL(stbl->CompositionToDecode->greatestDecodeToDisplayDelta)\n\t\t\tRESCALE_TSVAL(stbl->CompositionToDecode->leastDecodeToDisplayDelta)\n\t\t}\n\t\tif (trak->editBox) {\n\t\t\tGF_EdtsEntry *ent;\n\t\t\ti=0;\n\t\t\twhile ((ent = (GF_EdtsEntry*)gf_list_enum(trak->editBox->editList->entryList, &i))) {\n\t\t\t\tRESCALE_TSVAL(ent->mediaTime)\n\t\t\t}\n\t\t}\n#undef RESCALE_TSVAL\n\n\t\treturn SetTrackDuration(trak);\n\t}\n\n\t//rescale timings\n\tu32 i, k, idx, last_delta;\n\tu64 cur_dts;\n\tu64*DTSs = NULL;\n\ts64*CTSs = NULL;\n\n\tif (trak->editBox) {\n\t\tGF_EdtsEntry *ent;\n\t\ti=0;\n\t\twhile ((ent = (GF_EdtsEntry*)gf_list_enum(trak->editBox->editList->entryList, &i))) {\n\t\t\tent->mediaTime = (u32) (scale*ent->mediaTime);\n\t\t}\n\t}\n\tif (! stbl || !stbl->TimeToSample || !stbl->TimeToSample->nb_entries) {\n\t\treturn SetTrackDuration(trak);\n\t}\n\n\tidx = 0;\n\tcur_dts = 0;\n\t//unpack the DTSs\n\tDTSs = (u64*)gf_malloc(sizeof(u64) * (stbl->SampleSize->sampleCount) );\n\tif (!DTSs) return GF_OUT_OF_MEM;\n\n\tCTSs = NULL;\n\tif (stbl->CompositionOffset) {\n\t\tCTSs = (s64*)gf_malloc(sizeof(u64) * (stbl->SampleSize->sampleCount) );\n\t\tif (!CTSs) return GF_OUT_OF_MEM;\n\t}\n\n\tfor (i=0; i<stbl->TimeToSample->nb_entries; i++) {\n\t\tfor (k=0; k<stbl->TimeToSample->entries[i].sampleCount; k++) {\n\t\t\tcur_dts += stbl->TimeToSample->entries[i].sampleDelta;\n\t\t\tDTSs[idx] = (u64) (cur_dts * scale);\n\n\t\t\tif (stbl->CompositionOffset) {\n\t\t\t\ts32 cts_o;\n\t\t\t\tstbl_GetSampleCTS(stbl->CompositionOffset, idx+1, &cts_o);\n\t\t\t\tCTSs[idx] = (s64) ( ((s64) cur_dts + cts_o) * scale);\n\t\t\t}\n\t\t\tidx++;\n\t\t}\n\t}\n\tlast_delta = (u32) (stbl->TimeToSample->entries[stbl->TimeToSample->nb_entries-1].sampleDelta * scale);\n\n\t//repack DTS\n\tif (stbl->SampleSize->sampleCount) {\n\t\tstbl->TimeToSample->entries = gf_realloc(stbl->TimeToSample->entries, sizeof(GF_SttsEntry)*stbl->SampleSize->sampleCount);\n\t\tmemset(stbl->TimeToSample->entries, 0, sizeof(GF_SttsEntry)*stbl->SampleSize->sampleCount);\n\t\tstbl->TimeToSample->entries[0].sampleDelta = (u32) DTSs[0];\n\t\tstbl->TimeToSample->entries[0].sampleCount = 1;\n\t\tidx=0;\n\t\tfor (i=1; i< stbl->SampleSize->sampleCount - 1; i++) {\n\t\t\tif (DTSs[i+1] - DTSs[i] == stbl->TimeToSample->entries[idx].sampleDelta) {\n\t\t\t\tstbl->TimeToSample->entries[idx].sampleCount++;\n\t\t\t} else {\n\t\t\t\tidx++;\n\t\t\t\tstbl->TimeToSample->entries[idx].sampleDelta = (u32) ( DTSs[i+1] - DTSs[i] );\n\t\t\t\tstbl->TimeToSample->entries[idx].sampleCount=1;\n\t\t\t}\n\t\t}\n\t\tif (stbl->SampleSize->sampleCount > 1) {\n\t\t\t//add the sample delta for the last sample\n\t\t\tif (stbl->TimeToSample->entries[idx].sampleDelta == last_delta) {\n\t\t\t\tstbl->TimeToSample->entries[idx].sampleCount++;\n\t\t\t} else {\n\t\t\t\tidx++;\n\t\t\t\tstbl->TimeToSample->entries[idx].sampleDelta = last_delta;\n\t\t\t\tstbl->TimeToSample->entries[idx].sampleCount=1;\n\t\t\t}\n\n\t\t\tstbl->TimeToSample->nb_entries = idx+1;\n\t\t\tstbl->TimeToSample->entries = gf_realloc(stbl->TimeToSample->entries, sizeof(GF_SttsEntry)*stbl->TimeToSample->nb_entries);\n\t\t}\n\t}\n\n\tif (CTSs && stbl->SampleSize->sampleCount>0) {\n\t\t//repack CTS\n\t\tstbl->CompositionOffset->entries = gf_realloc(stbl->CompositionOffset->entries, sizeof(GF_DttsEntry)*stbl->SampleSize->sampleCount);\n\t\tmemset(stbl->CompositionOffset->entries, 0, sizeof(GF_DttsEntry)*stbl->SampleSize->sampleCount);\n\t\tstbl->CompositionOffset->entries[0].decodingOffset = (s32) (CTSs[0] - DTSs[0]);\n\t\tstbl->CompositionOffset->entries[0].sampleCount = 1;\n\t\tidx=0;\n\t\tfor (i=1; i< stbl->SampleSize->sampleCount; i++) {\n\t\t\ts32 cts_o = (s32) (CTSs[i] - DTSs[i]);\n\t\t\tif (cts_o == stbl->CompositionOffset->entries[idx].decodingOffset) {\n\t\t\t\tstbl->CompositionOffset->entries[idx].sampleCount++;\n\t\t\t} else {\n\t\t\t\tidx++;\n\t\t\t\tstbl->CompositionOffset->entries[idx].decodingOffset = cts_o;\n\t\t\t\tstbl->CompositionOffset->entries[idx].sampleCount=1;\n\t\t\t}\n\t\t}\n\t\tstbl->CompositionOffset->nb_entries = idx+1;\n\t\tstbl->CompositionOffset->entries = gf_realloc(stbl->CompositionOffset->entries, sizeof(GF_DttsEntry)*stbl->CompositionOffset->nb_entries);\n\n\t\tgf_free(CTSs);\n\t}\n\tgf_free(DTSs);\n\n\tif (stbl->CompositionToDecode) {\n\t\tstbl->CompositionToDecode->compositionEndTime = (s32) (stbl->CompositionToDecode->compositionEndTime * scale);\n\t\tstbl->CompositionToDecode->compositionStartTime = (s32)(stbl->CompositionToDecode->compositionStartTime * scale);\n\t\tstbl->CompositionToDecode->compositionToDTSShift = (s32)(stbl->CompositionToDecode->compositionToDTSShift * scale);\n\t\tstbl->CompositionToDecode->greatestDecodeToDisplayDelta = (s32)(stbl->CompositionToDecode->greatestDecodeToDisplayDelta * scale);\n\t\tstbl->CompositionToDecode->leastDecodeToDisplayDelta = (s32)(stbl->CompositionToDecode->leastDecodeToDisplayDelta * scale);\n\t}\n\n\treturn SetTrackDuration(trak);\n}\n\nGF_EXPORT\nBool gf_isom_box_equal(GF_Box *a, GF_Box *b)\n{\n\tBool ret;\n\tu8 *data1, *data2;\n\tu32 data1_size, data2_size;\n\tGF_BitStream *bs;\n\n\tif (a == b) return GF_TRUE;\n\tif (!a || !b) return GF_FALSE;\n\n\tdata1 = data2 = NULL;\n\n\tbs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\tgf_isom_box_size(a);\n\tgf_isom_box_write(a, bs);\n\tgf_bs_get_content(bs, &data1, &data1_size);\n\tgf_bs_del(bs);\n\n\tbs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\tgf_isom_box_size(b);\n\tgf_isom_box_write(b, bs);\n\tgf_bs_get_content(bs, &data2, &data2_size);\n\tgf_bs_del(bs);\n\n\tret = GF_FALSE;\n\tif (data1_size == data2_size) {\n\t\tret = (memcmp(data1, data2, sizeof(char)*data1_size) == 0) ? GF_TRUE : GF_FALSE;\n\t}\n\tgf_free(data1);\n\tgf_free(data2);\n\treturn ret;\n}\n\nGF_EXPORT\nBool gf_isom_is_same_sample_description(GF_ISOFile *f1, u32 tk1, u32 sdesc_index1, GF_ISOFile *f2, u32 tk2, u32 sdesc_index2)\n{\n\tu32 i, count;\n\tGF_TrackBox *trak1, *trak2;\n\tGF_ESD *esd1, *esd2;\n\tBool need_memcmp, ret;\n\tGF_Box *a, *b;\n\n\t/*get orig sample desc and clone it*/\n\ttrak1 = gf_isom_get_track_from_file(f1, tk1);\n\tif (!trak1 || !trak1->Media) return GF_FALSE;\n\ttrak2 = gf_isom_get_track_from_file(f2, tk2);\n\tif (!trak2 || !trak2->Media) return GF_FALSE;\n\n\tif (trak1->Media->handler->handlerType != trak2->Media->handler->handlerType) return GF_FALSE;\n\tcount = gf_list_count(trak1->Media->information->sampleTable->SampleDescription->child_boxes);\n\tif (count != gf_list_count(trak2->Media->information->sampleTable->SampleDescription->child_boxes)) {\n\t\tif (!sdesc_index1 && !sdesc_index2) return GF_FALSE;\n\t}\n\n\tneed_memcmp = GF_TRUE;\n\tfor (i=0; i<count; i++) {\n\t\tGF_Box *ent1 = (GF_Box *)gf_list_get(trak1->Media->information->sampleTable->SampleDescription->child_boxes, i);\n\t\tGF_Box *ent2 = (GF_Box *)gf_list_get(trak2->Media->information->sampleTable->SampleDescription->child_boxes, i);\n\n\t\tif (sdesc_index1) ent1 = (GF_Box *)gf_list_get(trak1->Media->information->sampleTable->SampleDescription->child_boxes, sdesc_index1 - 1);\n\t\tif (sdesc_index2) ent2 = (GF_Box *)gf_list_get(trak2->Media->information->sampleTable->SampleDescription->child_boxes, sdesc_index2 - 1);\n\n\t\tif (!ent1 || !ent2) return GF_FALSE;\n\t\tif (ent1->type != ent2->type) return GF_FALSE;\n\n\t\tswitch (ent1->type) {\n\t\t/*for MPEG-4 streams, only compare decSpecInfo (bitrate may not be the same but that's not an issue)*/\n\t\tcase GF_ISOM_BOX_TYPE_MP4S:\n\t\tcase GF_ISOM_BOX_TYPE_MP4A:\n\t\tcase GF_ISOM_BOX_TYPE_MP4V:\n\t\tcase GF_ISOM_BOX_TYPE_ENCA:\n\t\tcase GF_ISOM_BOX_TYPE_ENCV:\n\t\tcase GF_ISOM_BOX_TYPE_RESV:\n\t\tcase GF_ISOM_BOX_TYPE_ENCS:\n\t\t\tMedia_GetESD(trak1->Media, sdesc_index1 ? sdesc_index1 : i+1, &esd1, GF_TRUE);\n\t\t\tMedia_GetESD(trak2->Media, sdesc_index2 ? sdesc_index2 : i+1, &esd2, GF_TRUE);\n\t\t\tif (!esd1 || !esd2) continue;\n\t\t\tneed_memcmp = GF_FALSE;\n\t\t\tif (esd1->decoderConfig->streamType != esd2->decoderConfig->streamType) return GF_FALSE;\n\t\t\tif (esd1->decoderConfig->objectTypeIndication != esd2->decoderConfig->objectTypeIndication) return GF_FALSE;\n\t\t\tif (!esd1->decoderConfig->decoderSpecificInfo && esd2->decoderConfig->decoderSpecificInfo) return GF_FALSE;\n\t\t\tif (esd1->decoderConfig->decoderSpecificInfo && !esd2->decoderConfig->decoderSpecificInfo) return GF_FALSE;\n\t\t\tif (!esd1->decoderConfig->decoderSpecificInfo || !esd2->decoderConfig->decoderSpecificInfo) continue;\n\t\t\tif (memcmp(esd1->decoderConfig->decoderSpecificInfo->data, esd2->decoderConfig->decoderSpecificInfo->data, sizeof(char)*esd1->decoderConfig->decoderSpecificInfo->dataLength)!=0) return GF_FALSE;\n\t\t\tbreak;\n\t\tcase GF_ISOM_BOX_TYPE_HVT1:\n\t\t\treturn GF_TRUE;\n\t\tcase GF_ISOM_BOX_TYPE_AVC1:\n\t\tcase GF_ISOM_BOX_TYPE_AVC2:\n\t\tcase GF_ISOM_BOX_TYPE_AVC3:\n\t\tcase GF_ISOM_BOX_TYPE_AVC4:\n\t\tcase GF_ISOM_BOX_TYPE_SVC1:\n\t\tcase GF_ISOM_BOX_TYPE_MVC1:\n\t\tcase GF_ISOM_BOX_TYPE_HVC1:\n\t\tcase GF_ISOM_BOX_TYPE_HEV1:\n\t\tcase GF_ISOM_BOX_TYPE_HVC2:\n\t\tcase GF_ISOM_BOX_TYPE_HEV2:\n\t\tcase GF_ISOM_BOX_TYPE_LHE1:\n\t\tcase GF_ISOM_BOX_TYPE_LHV1:\n\t\tcase GF_ISOM_BOX_TYPE_AV01:\n\t\tcase GF_ISOM_BOX_TYPE_VVC1:\n\t\tcase GF_ISOM_BOX_TYPE_VVI1:\n\t\t{\n\t\t\tGF_MPEGVisualSampleEntryBox *avc1 = (GF_MPEGVisualSampleEntryBox *)ent1;\n\t\t\tGF_MPEGVisualSampleEntryBox *avc2 = (GF_MPEGVisualSampleEntryBox *)ent2;\n\n\t\t\tif (avc1->hevc_config)\n\t\t\t\ta = (GF_Box *) avc1->hevc_config;\n\t\t\telse if (avc1->lhvc_config)\n\t\t\t\ta = (GF_Box *) avc1->lhvc_config;\n\t\t\telse if (avc1->svc_config)\n\t\t\t\ta = (GF_Box *) avc1->svc_config;\n\t\t\telse if (avc1->mvc_config)\n\t\t\t\ta = (GF_Box *) avc1->mvc_config;\n\t\t\telse if (avc1->av1_config)\n\t\t\t\ta = (GF_Box *)avc1->av1_config;\n\t\t\telse\n\t\t\t\ta = (GF_Box *) avc1->avc_config;\n\n\t\t\tif (avc2->hevc_config)\n\t\t\t\tb = (GF_Box *) avc2->hevc_config;\n\t\t\telse if (avc2->lhvc_config)\n\t\t\t\tb = (GF_Box *) avc2->lhvc_config;\n\t\t\telse if (avc2->svc_config)\n\t\t\t\tb = (GF_Box *) avc2->svc_config;\n\t\t\telse if (avc2->mvc_config)\n\t\t\t\tb = (GF_Box *) avc2->mvc_config;\n\t\t\telse if (avc2->av1_config)\n\t\t\t\tb = (GF_Box *)avc2->av1_config;\n\t\t\telse\n\t\t\t\tb = (GF_Box *) avc2->avc_config;\n\n\t\t\treturn gf_isom_box_equal(a,b);\n\t\t}\n\t\tbreak;\n\t\tcase GF_ISOM_BOX_TYPE_LSR1:\n\t\t{\n\t\t\tGF_LASeRSampleEntryBox *lsr1 = (GF_LASeRSampleEntryBox *)ent1;\n\t\t\tGF_LASeRSampleEntryBox *lsr2 = (GF_LASeRSampleEntryBox *)ent2;\n\t\t\tif (lsr1->lsr_config && lsr2->lsr_config\n\t\t\t        && lsr1->lsr_config->hdr && lsr2->lsr_config->hdr\n\t\t\t        && (lsr1->lsr_config->hdr_size==lsr2->lsr_config->hdr_size)\n\t\t\t        && !memcmp(lsr1->lsr_config->hdr, lsr2->lsr_config->hdr, lsr2->lsr_config->hdr_size)\n\t\t\t   ) {\n\t\t\t\treturn GF_TRUE;\n\t\t\t}\n\t\t\treturn GF_FALSE;\n\t\t}\n\t\tbreak;\n#ifndef GPAC_DISABLE_VTT\n\t\tcase GF_ISOM_BOX_TYPE_WVTT:\n\t\t{\n\t\t\tGF_WebVTTSampleEntryBox *wvtt1 = (GF_WebVTTSampleEntryBox *)ent1;\n\t\t\tGF_WebVTTSampleEntryBox *wvtt2 = (GF_WebVTTSampleEntryBox *)ent2;\n\t\t\tif (wvtt1->config && wvtt2->config &&\n\t\t\t        (wvtt1->config->string && wvtt2->config->string && !strcmp(wvtt1->config->string, wvtt2->config->string))) {\n\t\t\t\treturn GF_TRUE;\n\t\t\t}\n\t\t\treturn GF_FALSE;\n\t\t}\n\t\tbreak;\n#endif\n\t\tcase GF_ISOM_BOX_TYPE_STPP:\n\t\t{\n\t\t\tGF_MetaDataSampleEntryBox *stpp1 = (GF_MetaDataSampleEntryBox *)ent1;\n\t\t\tGF_MetaDataSampleEntryBox *stpp2 = (GF_MetaDataSampleEntryBox *)ent2;\n\t\t\tif (stpp1->xml_namespace && stpp2->xml_namespace && !strcmp(stpp1->xml_namespace, stpp2->xml_namespace)) {\n\t\t\t\treturn GF_TRUE;\n\t\t\t}\n\t\t\treturn GF_FALSE;\n\t\t}\n\t\tbreak;\n\t\tcase GF_ISOM_BOX_TYPE_SBTT:\n\t\t{\n\t\t\treturn GF_FALSE;\n\t\t}\n\t\tbreak;\n\t\tcase GF_ISOM_BOX_TYPE_STXT:\n\t\t{\n\t\t\tGF_MetaDataSampleEntryBox *stxt1 = (GF_MetaDataSampleEntryBox *)ent1;\n\t\t\tGF_MetaDataSampleEntryBox *stxt2 = (GF_MetaDataSampleEntryBox *)ent2;\n\t\t\tif (stxt1->mime_type && stxt2->mime_type &&\n\t\t\t        ( (!stxt1->config && !stxt2->config) ||\n\t\t\t          (stxt1->config && stxt2->config && stxt1->config->config && stxt2->config->config &&\n\t\t\t           !strcmp(stxt1->config->config, stxt2->config->config)))) {\n\t\t\t\treturn GF_TRUE;\n\t\t\t}\n\t\t\treturn GF_FALSE;\n\t\t}\n\t\tcase GF_ISOM_BOX_TYPE_MP3:\n\t\tcase GF_QT_SUBTYPE_RAW_AUD:\n\t\tcase GF_QT_SUBTYPE_TWOS:\n\t\tcase GF_QT_SUBTYPE_SOWT:\n\t\tcase GF_QT_SUBTYPE_FL32:\n\t\tcase GF_QT_SUBTYPE_FL64:\n\t\tcase GF_QT_SUBTYPE_IN24:\n\t\tcase GF_QT_SUBTYPE_IN32:\n\t\tcase GF_QT_SUBTYPE_ULAW:\n\t\tcase GF_QT_SUBTYPE_ALAW:\n\t\tcase GF_QT_SUBTYPE_ADPCM:\n\t\tcase GF_QT_SUBTYPE_IMA_ADPCM:\n\t\tcase GF_QT_SUBTYPE_DVCA:\n\t\tcase GF_QT_SUBTYPE_QDMC:\n\t\tcase GF_QT_SUBTYPE_QDMC2:\n\t\tcase GF_QT_SUBTYPE_QCELP:\n\t\tcase GF_QT_SUBTYPE_kMP3:\n\t\t\treturn GF_TRUE;\n\t\tcase GF_QT_SUBTYPE_APCH:\n\t\tcase GF_QT_SUBTYPE_APCO:\n\t\tcase GF_QT_SUBTYPE_APCN:\n\t\tcase GF_QT_SUBTYPE_APCS:\n\t\tcase GF_QT_SUBTYPE_AP4X:\n\t\tcase GF_QT_SUBTYPE_AP4H:\n\t\tcase GF_QT_SUBTYPE_RAW_VID:\n\t\tcase GF_QT_SUBTYPE_YUYV:\n\t\tcase GF_QT_SUBTYPE_UYVY:\n\t\tcase GF_QT_SUBTYPE_YUV444:\n\t\tcase GF_QT_SUBTYPE_YUVA444:\n\t\tcase GF_QT_SUBTYPE_YUV422_10:\n\t\tcase GF_QT_SUBTYPE_YUV444_10:\n\t\tcase GF_QT_SUBTYPE_YUV422_16:\n\t\tcase GF_QT_SUBTYPE_YUV420:\n\t\tcase GF_QT_SUBTYPE_I420:\n\t\tcase GF_QT_SUBTYPE_IYUV:\n\t\tcase GF_QT_SUBTYPE_YV12:\n\t\tcase GF_QT_SUBTYPE_YVYU:\n\t\tcase GF_QT_SUBTYPE_RGBA:\n\t\tcase GF_QT_SUBTYPE_ABGR:\n\t\t\treturn GF_TRUE;\n\t\t}\n\n\t\tif (sdesc_index1 && sdesc_index2) break;\n\t}\n\tif (!need_memcmp) return GF_TRUE;\n\ta = (GF_Box *)trak1->Media->information->sampleTable->SampleDescription;\n\tb = (GF_Box *)trak2->Media->information->sampleTable->SampleDescription;\n\t//we ignore all bitrate boxes when comparing the box, disable their writing\n\tgf_isom_registry_disable(GF_ISOM_BOX_TYPE_BTRT, GF_TRUE);\n\tret = gf_isom_box_equal(a,b);\n\t//re-enable btrt writing\n\tgf_isom_registry_disable(GF_ISOM_BOX_TYPE_BTRT, GF_FALSE);\n\n\treturn ret;\n}\n\nGF_EXPORT\nu64 gf_isom_estimate_size(GF_ISOFile *movie)\n{\n\tGF_Err e;\n\tGF_Box *a;\n\tu32 i, count;\n\tu64 mdat_size;\n\tif (!movie || !movie->moov) return 0;\n\n\tmdat_size = 0;\n\tcount = gf_list_count(movie->moov->trackList);\n\tfor (i=0; i<count; i++) {\n\t\tmdat_size += gf_isom_get_media_data_size(movie, i+1);\n\t}\n\tif (mdat_size) {\n\t\tmdat_size += 8;\n\t\tif (mdat_size > 0xFFFFFFFF) mdat_size += 8;\n\t}\n\n\ti=0;\n\twhile ((a = (GF_Box*)gf_list_enum(movie->TopBoxes, &i))) {\n\t\te = gf_isom_box_size(a);\n\t\tif (e == GF_OK)\n\t\t\tmdat_size += a->size;\n\t}\n\treturn mdat_size;\n}\n\n\n//set shadowing on/off\n#if 0 //unused\nGF_Err gf_isom_remove_sync_shadows(GF_ISOFile *movie, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\tGF_SampleTableBox *stbl;\n\n\tif (movie->openMode == GF_ISOM_OPEN_READ) return GF_ISOM_INVALID_MODE;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tstbl = trak->Media->information->sampleTable;\n\tif (stbl->ShadowSync) {\n\t\tgf_isom_box_del_parent(&stbl->child_boxes, (GF_Box *) stbl->ShadowSync);\n\t\tstbl->ShadowSync = NULL;\n\t}\n\treturn GF_OK;\n}\n\n/*Use this function to do the shadowing if you use shadowing.\nthe sample to be shadowed MUST be a non-sync sample (ignored if not)\nthe sample shadowing must be a Sync sample (error if not)*/\nGF_Err gf_isom_set_sync_shadow(GF_ISOFile *movie, u32 trackNumber, u32 sampleNumber, u32 syncSample)\n{\n\tGF_TrackBox *trak;\n\tGF_SampleTableBox *stbl;\n\tGF_ISOSAPType isRAP;\n\tGF_Err e;\n\n\tif (movie->openMode == GF_ISOM_OPEN_READ) return GF_ISOM_INVALID_MODE;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !sampleNumber || !syncSample) return GF_BAD_PARAM;\n\n\tstbl = trak->Media->information->sampleTable;\n\tif (!stbl->ShadowSync) {\n\t\tstbl->ShadowSync = (GF_ShadowSyncBox *) gf_isom_box_new_parent(&stbl->child_boxes, GF_ISOM_BOX_TYPE_STSH);\n\t\tif (!stbl->ShadowSync) return GF_OUT_OF_MEM;\n\t}\n\n\t//if no sync, skip\n\tif (!stbl->SyncSample) return GF_OK;\n\t//else set the sync shadow.\n\t//if the sample is sync, ignore\n\te = stbl_GetSampleRAP(stbl->SyncSample, sampleNumber, &isRAP, NULL, NULL);\n\tif (e) return e;\n\tif (isRAP) return GF_OK;\n\t//if the shadowing sample is not sync, error\n\te = stbl_GetSampleRAP(stbl->SyncSample, syncSample, &isRAP, NULL, NULL);\n\tif (e) return e;\n\tif (!isRAP) return GF_BAD_PARAM;\n\n\treturn stbl_SetSyncShadow(stbl->ShadowSync, sampleNumber, syncSample);\n}\n#endif\n\n//set the GroupID of a track (only used for interleaving)\nGF_EXPORT\nGF_Err gf_isom_set_track_interleaving_group(GF_ISOFile *movie, u32 trackNumber, u32 GroupID)\n{\n\tGF_TrackBox *trak;\n\n\tif (movie->openMode != GF_ISOM_OPEN_EDIT) return GF_ISOM_INVALID_MODE;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !GroupID) return GF_BAD_PARAM;\n\n\ttrak->Media->information->sampleTable->groupID = GroupID;\n\treturn GF_OK;\n}\n\n\n//set the Priority of a track within a Group (only used for tight interleaving)\n//Priority ranges from 1 to 9\nGF_EXPORT\nGF_Err gf_isom_set_track_priority_in_group(GF_ISOFile *movie, u32 trackNumber, u32 Priority)\n{\n\tGF_TrackBox *trak;\n\n\tif (movie->openMode != GF_ISOM_OPEN_EDIT) return GF_ISOM_INVALID_MODE;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !Priority) return GF_BAD_PARAM;\n\n\ttrak->Media->information->sampleTable->trackPriority = Priority > 255 ? 255 : Priority;\n\treturn GF_OK;\n}\n\n//set the max SamplesPerChunk (for file optimization)\nGF_EXPORT\nGF_Err gf_isom_hint_max_chunk_size(GF_ISOFile *movie, u32 trackNumber, u32 maxChunkSize)\n{\n\tGF_TrackBox *trak;\n\n\tif (movie->openMode == GF_ISOM_OPEN_READ) return GF_ISOM_INVALID_MODE;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !maxChunkSize) return GF_BAD_PARAM;\n\n\ttrak->Media->information->sampleTable->MaxChunkSize = maxChunkSize;\n\treturn GF_OK;\n}\n\n\nGF_EXPORT\nGF_Err gf_isom_set_extraction_slc(GF_ISOFile *the_file, u32 trackNumber, u32 StreamDescriptionIndex, const GF_SLConfig *slConfig)\n{\n\tGF_TrackBox *trak;\n\tGF_SampleEntryBox *entry;\n\tGF_Err e;\n\tGF_SLConfig **slc;\n\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\te = Media_GetSampleDesc(trak->Media, StreamDescriptionIndex, &entry, NULL);\n\tif (e) return e;\n\n\t//we must be sure we are not using a remote ESD\n\tswitch (entry->type) {\n\tcase GF_ISOM_BOX_TYPE_MP4S:\n\t\tif (((GF_MPEGSampleEntryBox *)entry)->esd->desc->slConfig->predefined != SLPredef_MP4) return GF_BAD_PARAM;\n\t\tslc = & ((GF_MPEGSampleEntryBox *)entry)->slc;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_MP4A:\n\t\tif (((GF_MPEGAudioSampleEntryBox *)entry)->esd->desc->slConfig->predefined != SLPredef_MP4) return GF_BAD_PARAM;\n\t\tslc = & ((GF_MPEGAudioSampleEntryBox *)entry)->slc;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_MP4V:\n\t\tif (((GF_MPEGVisualSampleEntryBox *)entry)->esd->desc->slConfig->predefined != SLPredef_MP4) return GF_BAD_PARAM;\n\t\tslc = & ((GF_MPEGVisualSampleEntryBox *)entry)->slc;\n\t\tbreak;\n\tdefault:\n\t\treturn GF_BAD_PARAM;\n\t}\n\n\tif (*slc) {\n\t\tgf_odf_desc_del((GF_Descriptor *)*slc);\n\t\t*slc = NULL;\n\t}\n\tif (!slConfig) return GF_OK;\n\t//finally duplicate the SL\n\treturn gf_odf_desc_copy((GF_Descriptor *) slConfig, (GF_Descriptor **) slc);\n}\n\n#if 0 //unused\nGF_Err gf_isom_get_extraction_slc(GF_ISOFile *the_file, u32 trackNumber, u32 StreamDescriptionIndex, GF_SLConfig **slConfig)\n{\n\tGF_TrackBox *trak;\n\tGF_SampleEntryBox *entry;\n\tGF_Err e;\n\tGF_SLConfig *slc;\n\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\te = Media_GetSampleDesc(trak->Media, StreamDescriptionIndex, &entry, NULL);\n\tif (e) return e;\n\n\t//we must be sure we are not using a remote ESD\n\tslc = NULL;\n\t*slConfig = NULL;\n\tswitch (entry->type) {\n\tcase GF_ISOM_BOX_TYPE_MP4S:\n\t\tif (((GF_MPEGSampleEntryBox *)entry)->esd->desc->slConfig->predefined != SLPredef_MP4) return GF_BAD_PARAM;\n\t\tslc = ((GF_MPEGSampleEntryBox *)entry)->slc;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_MP4A:\n\t\tif (((GF_MPEGAudioSampleEntryBox *)entry)->esd->desc->slConfig->predefined != SLPredef_MP4) return GF_BAD_PARAM;\n\t\tslc = ((GF_MPEGAudioSampleEntryBox *)entry)->slc;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_MP4V:\n\t\tif (((GF_MPEGVisualSampleEntryBox *)entry)->esd->desc->slConfig->predefined != SLPredef_MP4) return GF_BAD_PARAM;\n\t\tslc = ((GF_MPEGVisualSampleEntryBox *)entry)->slc;\n\t\tbreak;\n\tdefault:\n\t\treturn GF_BAD_PARAM;\n\t}\n\n\tif (!slc) return GF_OK;\n\t//finally duplicate the SL\n\treturn gf_odf_desc_copy((GF_Descriptor *) slc, (GF_Descriptor **) slConfig);\n}\n\nu32 gf_isom_get_track_group(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return 0;\n\treturn trak->Media->information->sampleTable->groupID;\n}\n\nu32 gf_isom_get_track_priority_in_group(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return 0;\n\treturn trak->Media->information->sampleTable->trackPriority;\n}\n#endif\n\n\nGF_EXPORT\nGF_Err gf_isom_make_interleave_ex(GF_ISOFile *file, GF_Fraction *fTimeInSec)\n{\n\tGF_Err e;\n\tu64 itime;\n\tif (!file || !fTimeInSec->den || (fTimeInSec->num<=0)) return GF_BAD_PARAM;\n\n\titime = (u64) fTimeInSec->num;\n\titime *= gf_isom_get_timescale(file);\n\titime /= fTimeInSec->den;\n\tif (file->storageMode==GF_ISOM_STORE_FASTSTART) {\n\t\treturn gf_isom_set_interleave_time(file, (u32) itime);\n\t}\n\tif (gf_isom_get_mode(file) < GF_ISOM_OPEN_EDIT) return GF_BAD_PARAM;\n\te = gf_isom_set_storage_mode(file, GF_ISOM_STORE_DRIFT_INTERLEAVED);\n\tif (e) return e;\n\treturn gf_isom_set_interleave_time(file, (u32) itime);\n}\n\nGF_EXPORT\nGF_Err gf_isom_make_interleave(GF_ISOFile *file, Double TimeInSec)\n{\n\tGF_Fraction f;\n\tf.num = (s32) (TimeInSec * 1000);\n\tf.den = 1000;\n\treturn gf_isom_make_interleave_ex(file, &f);\n\n}\nGF_EXPORT\nGF_Err gf_isom_set_handler_name(GF_ISOFile *the_file, u32 trackNumber, const char *nameUTF8)\n{\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\tif (trak->Media->handler->nameUTF8) gf_free(trak->Media->handler->nameUTF8);\n\ttrak->Media->handler->nameUTF8 = NULL;\n\n\tif (!nameUTF8) return GF_OK;\n\n\tif (!strnicmp(nameUTF8, \"file://\", 7)) {\n\t\tu8 BOM[4];\n\t\tFILE *f = gf_fopen(nameUTF8+7, \"rb\");\n\t\tu64 size;\n\t\tif (!f) return GF_URL_ERROR;\n\t\tsize = gf_fsize(f);\n\t\tif (3!=gf_fread(BOM, 3, f)) {\n\t\t\tgf_fclose(f);\n\t\t\treturn GF_CORRUPTED_DATA;\n\t\t}\n\t\t/*skip BOM if any*/\n\t\tif ((BOM[0]==0xEF) && (BOM[1]==0xBB) && (BOM[2]==0xBF)) size -= 3;\n\t\telse if ((BOM[0]==0xEF) || (BOM[0]==0xFF)) {\n\t\t\tgf_fclose(f);\n\t\t\treturn GF_BAD_PARAM;\n\t\t}\n\t\telse gf_fseek(f, 0, SEEK_SET);\n\t\ttrak->Media->handler->nameUTF8 = (char*)gf_malloc(sizeof(char)*(size_t)(size+1));\n\t\tif (!trak->Media->handler->nameUTF8) {\n\t\t\tgf_fclose(f);\n\t\t\treturn GF_OUT_OF_MEM;\n\t\t}\n\t\tsize = gf_fread(trak->Media->handler->nameUTF8, (size_t)size, f);\n\t\ttrak->Media->handler->nameUTF8[size] = 0;\n\t\tgf_fclose(f);\n\t} else {\n\t\tu32 i, j, len;\n\t\tchar szOrig[1024], szLine[1024];\n\t\tstrcpy(szOrig, nameUTF8);\n\t\tj=0;\n\t\tlen = (u32) strlen(szOrig);\n\t\tfor (i=0; i<len; i++) {\n\t\t\tif (szOrig[i] & 0x80) {\n\t\t\t\t/*non UTF8 (likely some win-CP)*/\n\t\t\t\tif ( (szOrig[i+1] & 0xc0) != 0x80) {\n\t\t\t\t\tszLine[j] = 0xc0 | ( (szOrig[i] >> 6) & 0x3 );\n\t\t\t\t\tj++;\n\t\t\t\t\tszOrig[i] &= 0xbf;\n\t\t\t\t}\n\t\t\t\t/*UTF8 2 bytes char */\n\t\t\t\telse if ( (szOrig[i] & 0xe0) == 0xc0) {\n\t\t\t\t\tszLine[j] = szOrig[i];\n\t\t\t\t\ti++;\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t\t/*UTF8 3 bytes char */\n\t\t\t\telse if ( (szOrig[i] & 0xf0) == 0xe0) {\n\t\t\t\t\tszLine[j] = szOrig[i];\n\t\t\t\t\ti++;\n\t\t\t\t\tj++;\n\t\t\t\t\tszLine[j] = szOrig[i];\n\t\t\t\t\ti++;\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t\t/*UTF8 4 bytes char */\n\t\t\t\telse if ( (szOrig[i] & 0xf8) == 0xf0) {\n\t\t\t\t\tszLine[j] = szOrig[i];\n\t\t\t\t\ti++;\n\t\t\t\t\tj++;\n\t\t\t\t\tszLine[j] = szOrig[i];\n\t\t\t\t\ti++;\n\t\t\t\t\tj++;\n\t\t\t\t\tszLine[j] = szOrig[i];\n\t\t\t\t\ti++;\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tszLine[j] = szOrig[i];\n\t\t\tj++;\n\t\t}\n\t\tszLine[j] = 0;\n\t\ttrak->Media->handler->nameUTF8 = gf_strdup(szLine);\n\t}\n\treturn GF_OK;\n}\n\n#if 0 //unused\n/*clones root OD from input to output file, without copying root OD track references*/\nGF_Err gf_isom_clone_root_od(GF_ISOFile *input, GF_ISOFile *output)\n{\n\tGF_List *esds;\n\tGF_Err e;\n\tu32 i;\n\tGF_Descriptor *desc;\n\n\te = gf_isom_remove_root_od(output);\n\tif (e) return e;\n\tif (!input->moov || !input->moov->iods || !input->moov->iods->descriptor) return GF_OK;\n\te = gf_isom_insert_moov(output);\n\tif (e) return e;\n\te = AddMovieIOD(output->moov, 0);\n\tif (e) return e;\n\tif (output->moov->iods->descriptor) gf_odf_desc_del(output->moov->iods->descriptor);\n\toutput->moov->iods->descriptor = NULL;\n\tgf_odf_desc_copy(input->moov->iods->descriptor, &output->moov->iods->descriptor);\n\n\tswitch (output->moov->iods->descriptor->tag) {\n\tcase GF_ODF_ISOM_IOD_TAG:\n\t\tesds = ((GF_IsomInitialObjectDescriptor *)output->moov->iods->descriptor)->ES_ID_IncDescriptors;\n\t\tbreak;\n\tcase GF_ODF_ISOM_OD_TAG:\n\t\tesds = ((GF_IsomObjectDescriptor *)output->moov->iods->descriptor)->ES_ID_IncDescriptors;\n\t\tbreak;\n\tdefault:\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\n\t//get the desc\n\ti=0;\n\twhile ((desc = (GF_Descriptor*)gf_list_enum(esds, &i))) {\n\t\tgf_odf_desc_del(desc);\n\t\tgf_list_rem(esds, i-1);\n\t}\n\treturn GF_OK;\n}\n#endif\n\nGF_EXPORT\nGF_Err gf_isom_set_media_type(GF_ISOFile *movie, u32 trackNumber, u32 new_type)\n{\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !new_type) return GF_BAD_PARAM;\n\ttrak->Media->handler->handlerType = new_type;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_media_subtype(GF_ISOFile *movie, u32 trackNumber, u32 sampleDescriptionIndex, u32 new_type)\n{\n\tGF_SampleEntryBox*entry;\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !sampleDescriptionIndex || !new_type) return GF_BAD_PARAM;\n\n\tentry = (GF_SampleEntryBox*)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, sampleDescriptionIndex - 1);\n\tif (!entry) return GF_BAD_PARAM;\n\tentry->type = new_type;\n\treturn GF_OK;\n}\n\n\n#if 0 //unused\nGF_Err gf_isom_set_JPEG2000(GF_ISOFile *mov, Bool set_on)\n{\n\tif (!mov) return GF_BAD_PARAM;\n\tmov->is_jp2 = set_on;\n\treturn GF_OK;\n}\n#endif\n\nGF_Err gf_isom_remove_uuid(GF_ISOFile *movie, u32 trackNumber, bin128 UUID)\n{\n\tu32 i, count;\n\tGF_List *list;\n\n\tif (trackNumber==(u32) -1) {\n\t\tif (!movie) return GF_BAD_PARAM;\n\t\tlist = movie->TopBoxes;\n\t} else if (trackNumber) {\n\t\tGF_TrackBox *trak = gf_isom_get_track_from_file(movie, trackNumber);\n\t\tif (!trak) return GF_BAD_PARAM;\n\t\tlist = trak->child_boxes;\n\t} else {\n\t\tif (!movie) return GF_BAD_PARAM;\n\t\tlist = movie->moov->child_boxes;\n\t}\n\n\tcount = list ? gf_list_count(list) : 0;\n\tfor (i=0; i<count; i++) {\n\t\tGF_UnknownUUIDBox *uuid = (GF_UnknownUUIDBox *)gf_list_get(list, i);\n\t\tif (uuid->type != GF_ISOM_BOX_TYPE_UUID) continue;\n\t\tif (memcmp(UUID, uuid->uuid, sizeof(bin128))) continue;\n\t\tgf_list_rem(list, i);\n\t\ti--;\n\t\tcount--;\n\t\tgf_isom_box_del((GF_Box*)uuid);\n\t}\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_add_uuid(GF_ISOFile *movie, u32 trackNumber, bin128 UUID, const u8 *data, u32 data_size)\n{\n\tGF_List *list;\n    u32 btype;\n\tGF_Box *box;\n\tGF_UnknownUUIDBox *uuidb;\n\n\tif (data_size && !data) return GF_BAD_PARAM;\n\tif (trackNumber==(u32) -1) {\n\t\tif (!movie) return GF_BAD_PARAM;\n\t\tlist = movie->TopBoxes;\n\t} else if (trackNumber) {\n\t\tGF_TrackBox *trak = gf_isom_get_track_from_file(movie, trackNumber);\n\t\tif (!trak) return GF_BAD_PARAM;\n\t\tif (!trak->child_boxes) trak->child_boxes = gf_list_new();\n\t\tlist = trak->child_boxes;\n\t} else {\n\t\tif (!movie) return GF_BAD_PARAM;\n\t\tif (!movie->moov->child_boxes) movie->moov->child_boxes = gf_list_new();\n\t\tlist = movie->moov->child_boxes;\n\t}\n    btype = gf_isom_solve_uuid_box((char *) UUID);\n    if (!btype) btype = GF_ISOM_BOX_TYPE_UUID;\n    box = gf_isom_box_new(btype);\n    if (!box) return GF_OUT_OF_MEM;\n\tuuidb = (GF_UnknownUUIDBox*)box;\n\tuuidb->internal_4cc = gf_isom_solve_uuid_box((char *) UUID);\n\tmemcpy(uuidb->uuid, UUID, sizeof(bin128));\n\tuuidb->dataSize = data_size;\n\tif (data_size) {\n\t\tuuidb->data = (char*)gf_malloc(sizeof(char)*data_size);\n\t\tif (!uuidb->data) return GF_OUT_OF_MEM;\n\t\tmemcpy(uuidb->data, data, sizeof(char)*data_size);\n\t}\n\tgf_list_add(list, uuidb);\n\treturn GF_OK;\n}\n\n\nGF_EXPORT\nGF_Err gf_isom_apple_set_tag(GF_ISOFile *mov, GF_ISOiTunesTag tag, const u8 *data, u32 data_len, u64 int_val, u32 int_val2)\n{\n\tGF_Err e;\n\tGF_ItemListBox *ilst;\n\tGF_MetaBox *meta;\n\tGF_ListItemBox *info;\n\tu32 btype, i, itype;\n\ts32 tag_idx;\n\tu32 n=0, d=0;\n\tu8 loc_data[10];\n\tu32 int_flags = 0x15;\n\tGF_DataBox *dbox;\n\n\te = CanAccessMovie(mov, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttag_idx = gf_itags_find_by_itag(tag);\n\tif (tag_idx<0) {\n\t\titype = GF_ITAG_STR;\n\t} else {\n\t\titype = gf_itags_get_type(tag_idx);\n\t}\n\tmeta = (GF_MetaBox *) gf_isom_create_meta_extensions(mov, GF_FALSE);\n\tif (!meta) return GF_BAD_PARAM;\n\n\tilst = gf_ismo_locate_box(meta->child_boxes, GF_ISOM_BOX_TYPE_ILST, NULL);\n\tif (!ilst) {\n\t\tilst = (GF_ItemListBox *) gf_isom_box_new_parent(&meta->child_boxes, GF_ISOM_BOX_TYPE_ILST);\n\t}\n\n\tif (tag==GF_ISOM_ITUNE_RESET) {\n\t\tgf_isom_box_del_parent(&meta->child_boxes, (GF_Box *) ilst);\n\t\t//if last, delete udta - we may still have a handler box remaining\n\t\tif ((gf_list_count(meta->child_boxes) <= 1) && (gf_list_count(mov->moov->udta->recordList)==1)) {\n\t\t\tgf_isom_box_del_parent(&mov->moov->child_boxes, (GF_Box *) mov->moov->udta);\n\t\t\tmov->moov->udta = NULL;\n\t\t}\n\t\treturn GF_OK;\n\t}\n\n\tif (tag==GF_ISOM_ITUNE_GENRE) {\n\t\tif (!int_val && data) {\n\t\t\tint_val = gf_id3_get_genre_tag(data);\n\t\t\tif (int_val) {\n\t\t\t\tdata = NULL;\n\t\t\t\tdata_len = 0;\n\t\t\t\titype = GF_ITAG_INT16;\n\t\t\t\tint_flags = 0;\n\t\t\t}\n\t\t}\n\t\tbtype = data ? GF_ISOM_ITUNE_GENRE_USER : GF_ISOM_ITUNE_GENRE;\n\t} else {\n\t\tbtype = tag;\n\t}\n\t/*remove tag*/\n\ti = 0;\n\twhile ((info = (GF_ListItemBox*)gf_list_enum(ilst->child_boxes, &i))) {\n\t\tif (info->type==btype) {\n\t\t\tgf_isom_box_del_parent(&ilst->child_boxes, (GF_Box *) info);\n\t\t\tinfo = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tif (info->type==GF_ISOM_BOX_TYPE_UNKNOWN) {\n\t\t\tGF_UnknownBox *u = (GF_UnknownBox *) info;\n\t\t\tif (u->original_4cc==btype) {\n\t\t\t\tgf_isom_box_del_parent(&ilst->child_boxes, (GF_Box *) info);\n\t\t\t\tinfo = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!data && data_len) {\n\t\tif (!gf_list_count(ilst->child_boxes) )\n\t\t\tgf_isom_box_del_parent(&meta->child_boxes, (GF_Box *) ilst);\n\t\treturn GF_OK;\n\t}\n\n\tinfo = (GF_ListItemBox *)gf_isom_box_new(btype);\n\tif (info == NULL) return GF_OUT_OF_MEM;\n\n\tdbox = (GF_DataBox *)gf_isom_box_new_parent(&info->child_boxes, GF_ISOM_BOX_TYPE_DATA);\n\tif (!dbox) {\n\t\tgf_isom_box_del((GF_Box *)info);\n\t\treturn GF_OUT_OF_MEM;\n\t}\n\tif (info->type!=GF_ISOM_BOX_TYPE_UNKNOWN) {\n\t\tinfo->data = dbox;\n\t}\n\n\tswitch (itype) {\n\tcase GF_ITAG_FRAC6:\n\tcase GF_ITAG_FRAC8:\n\t\tif (data && data_len) {\n\t\t\tif (sscanf(data, \"%u/%u\", &n, &d) != 2) {\n\t\t\t\tn = d = 0;\n\t\t\t\tif (sscanf(data, \"%u\", &n) != 1)\n\t\t\t\t\tn = 0;\n\t\t\t}\n\t\t} else {\n\t\t\tn = (u32) int_val;\n\t\t\td = int_val2;\n\t\t}\n\t\tif (n) {\n\t\t\tmemset(loc_data, 0, sizeof(char) * 8);\n\t\t\tdata_len = (itype == GF_ITAG_FRAC6) ? 6 : 8;\n\t\t\tloc_data[3] = n;\n\t\t\tloc_data[2] = n >> 8;\n\t\t\tloc_data[5] = d;\n\t\t\tloc_data[4] = d >> 8;\n\t\t\tdata = loc_data;\n\t\t} else {\n\t\t\tdata = NULL;\n\t\t}\n\t\tdbox->flags = 0x15;\n\t\tbreak;\n\tcase GF_ITAG_BOOL:\n\t\tloc_data[0] = 0;\n\t\tif (data && data_len) {\n\t\t\tif ( !strcmp(data, \"yes\") || !strcmp(data, \"1\") || !strcmp(data, \"true\"))\n\t\t\t\tloc_data[0] = 1;\n\t\t} else {\n\t\t\tloc_data[0] = int_val ? 1 : 0;\n\t\t}\n\t\tdata = loc_data;\n\t\tdata_len = 0;\n\t\tdbox->flags = int_flags;\n\t\tbreak;\n\tcase GF_ITAG_INT16:\n\t\tloc_data[0] = 0;\n\t\tif (data && data_len) int_val = atoi(data);\n\t\tloc_data[1] = (u8) int_val;\n\t\tloc_data[0] = (u8) (int_val>>8);\n\t\tdata = loc_data;\n\t\tdata_len = 2;\n\t\tdbox->flags = int_flags;\n\t\tbreak;\n\tcase GF_ITAG_INT32:\n\t\tloc_data[0] = 0;\n\t\tif (data && data_len) int_val = atoi(data);\n\t\tloc_data[3] = (u8) int_val;\n\t\tloc_data[2] = (u8) (int_val>>8);\n\t\tloc_data[1] = (u8) (int_val>>16);\n\t\tloc_data[0] = (u8) (int_val>>24);\n\t\tdata = loc_data;\n\t\tdata_len = 4;\n\t\tdbox->flags = int_flags;\n\t\tbreak;\n\tcase GF_ITAG_INT64:\n\t\tloc_data[0] = 0;\n\t\tif (data && data_len) sscanf(data, LLU, &int_val);\n\t\tloc_data[7] = (u8) int_val;\n\t\tloc_data[6] = (u8) (int_val>>8);\n\t\tloc_data[5] = (u8) (int_val>>16);\n\t\tloc_data[4] = (u8) (int_val>>24);\n\t\tloc_data[3] = (u8) (int_val>>32);\n\t\tloc_data[2] = (u8) (int_val>>40);\n\t\tloc_data[1] = (u8) (int_val>>48);\n\t\tloc_data[0] = (u8) (int_val>>56);\n\t\tdata = loc_data;\n\t\tdata_len = 4;\n\t\tdbox->flags = int_flags;\n\t\tbreak;\n\tdefault:\n\t\tdbox->flags = 1;\n\t\tbreak;\n\t}\n\n\tif (!data) return GF_BAD_PARAM;\n\n\n\tif (tag==GF_ISOM_ITUNE_COVER_ART) {\n\t\tinfo->data->flags = 0;\n\t\t/*check for PNG sig*/\n\t\tif ((data_len>4) && (data[0] == 0x89) && (data[1] == 0x50) && (data[2] == 0x4E) && (data[3] == 0x47) ) {\n\t\t\tinfo->data->flags = 14;\n\t\t}\n\t\telse if ((data_len>4) && (data[0] == 0xFF) && (data[1] == 0xD8) && (data[2] == 0xFF) && (data[3] == 0xE0) ) {\n\t\t\tinfo->data->flags = 13;\n\t\t}\n\t\telse if ((data_len>3) && (data[0] == 'G') && (data[1] == 'I') && (data[2] == 'F') ) {\n\t\t\tinfo->data->flags = 12;\n\t\t}\n\t}\n\n\tdbox->dataSize = data_len;\n\tdbox->data = (char*)gf_malloc(sizeof(char)*data_len);\n\tif (!dbox->data) return GF_OUT_OF_MEM;\n\tmemcpy(dbox->data, data, sizeof(char)*data_len);\n\n\tif (!info && !gf_list_count(ilst->child_boxes) ) {\n\t\tgf_isom_box_del_parent(&meta->child_boxes, (GF_Box *) ilst);\n\t\treturn GF_OK;\n\t}\n\tif (!ilst->child_boxes) ilst->child_boxes = gf_list_new();\n\t\n\treturn gf_list_add(ilst->child_boxes, info);\n}\n\n#include <gpac/utf.h>\n\nGF_EXPORT\nGF_Err gf_isom_wma_set_tag(GF_ISOFile *mov, char *name, char *value)\n{\n\tGF_Err e;\n\tGF_XtraTag *tag=NULL;\n\tu32 count, i;\n\tGF_XtraBox *xtra;\n\n\te = CanAccessMovie(mov, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\tgf_isom_create_meta_extensions(mov, GF_FALSE);\n\n\txtra = (GF_XtraBox *) gf_isom_create_meta_extensions(mov, GF_TRUE);\n\tif (!xtra) return GF_BAD_PARAM;\n\n\tcount = gf_list_count(xtra->tags);\n\tfor (i=0; i<count; i++) {\n\t\ttag = gf_list_get(xtra->tags, i);\n\t\tif (name && tag->name && !strcmp(tag->name, name)) {\n\n\t\t} else {\n\t\t\ttag = NULL;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!value) {\n\t\t\tgf_list_rem(xtra->tags, i);\n\t\t\tgf_free(tag->name);\n\t\t\tif (tag->prop_value) gf_free(tag->prop_value);\n\t\t\tgf_free(tag);\n\t\t\treturn GF_OK;\n\t\t}\n\t\tgf_free(tag->prop_value);\n\t\ttag->prop_value = 0;\n\t}\n\tif (!tag) {\n\t\tif (!name) return GF_OK;\n\n\t\tGF_SAFEALLOC(tag, GF_XtraTag);\n\t\ttag->name = gf_strdup(name);\n\t\ttag->prop_type = 0;\n\t\ttag->flags = 1;\n\t\tgf_list_add(xtra->tags, tag);\n\t}\n\n\tu32 len = (u32) strlen(value);\n\ttag->prop_value = gf_malloc(sizeof(u16) * (len+1) );\n\tmemset(tag->prop_value, 0, sizeof(u16) * (len+1) );\n\tif (len) {\n\t\tu32 _len = (u32) gf_utf8_mbstowcs((u16 *) tag->prop_value, len, (const char **) &value);\n\t\tif (_len != (u32) -1) {\n\t\t\ttag->prop_value[2 * _len] = 0;\n\t\t\ttag->prop_value[2 * _len + 1] = 0;\n\t\t}\n\t\ttag->prop_size = 2 * _len + 2;\n\t} else {\n\t\ttag->prop_size = 2;\n\t}\n\treturn GF_OK;\n}\n\n\nGF_EXPORT\nGF_Err gf_isom_set_alternate_group_id(GF_ISOFile *movie, u32 trackNumber, u32 groupId)\n{\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\ttrak->Header->alternate_group = groupId;\n\treturn GF_OK;\n}\n\n\nGF_EXPORT\nGF_Err gf_isom_set_track_switch_parameter(GF_ISOFile *movie, u32 trackNumber, u32 trackRefGroup, Bool is_switch_group, u32 *switchGroupID, u32 *criteriaList, u32 criteriaListCount)\n{\n\tGF_TrackSelectionBox *tsel;\n\tGF_TrackBox *trak;\n\tGF_UserDataMap *map;\n\tGF_Err e;\n\tu32 alternateGroupID = 0;\n\tu32 next_switch_group_id = 0;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !switchGroupID) return GF_BAD_PARAM;\n\n\n\tif (trackRefGroup) {\n\t\tGF_TrackBox *trak_ref = gf_isom_get_track_from_file(movie, trackRefGroup);\n\t\tif (trak_ref != trak) {\n\t\t\tif (!trak_ref || !trak_ref->Header->alternate_group) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"Track %d has not an alternate group - skipping\\n\", trak_ref ? trak_ref->Header->trackID : 0));\n\t\t\t\treturn GF_BAD_PARAM;\n\t\t\t}\n\t\t\talternateGroupID = trak_ref->Header->alternate_group;\n\t\t} else {\n\t\t\talternateGroupID = trak->Header->alternate_group;\n\t\t}\n\t}\n\tif (!alternateGroupID) {\n\t\t/*there is a function for this ....*/\n\t\tif (trak->Header->alternate_group) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"Track %d has already an alternate group - skipping\\n\", trak->Header->trackID));\n\t\t\treturn GF_BAD_PARAM;\n\t\t}\n\t\talternateGroupID = gf_isom_get_next_alternate_group_id(movie);\n\t}\n\n\tif (is_switch_group) {\n\t\tu32 i=0;\n\t\twhile (i< gf_isom_get_track_count(movie) ) {\n\t\t\t//locate first available ID\n\t\t\tGF_TrackBox *a_trak = gf_isom_get_track_from_file(movie, i+1);\n\n\t\t\tif (a_trak->udta) {\n\t\t\t\tu32 j, count;\n\t\t\t\tmap = udta_getEntry(a_trak->udta, GF_ISOM_BOX_TYPE_TSEL, NULL);\n\t\t\t\tif (map) {\n\t\t\t\t\tcount = gf_list_count(map->boxes);\n\t\t\t\t\tfor (j=0; j<count; j++) {\n\t\t\t\t\t\ttsel = (GF_TrackSelectionBox*)gf_list_get(map->boxes, j);\n\n\t\t\t\t\t\tif (*switchGroupID) {\n\t\t\t\t\t\t\tif (tsel->switchGroup==next_switch_group_id) {\n\t\t\t\t\t\t\t\tif (a_trak->Header->alternate_group != alternateGroupID) return GF_BAD_PARAM;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (tsel->switchGroup && (tsel->switchGroup>=next_switch_group_id) )\n\t\t\t\t\t\t\t\tnext_switch_group_id = tsel->switchGroup;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\tif (! *switchGroupID) *switchGroupID = next_switch_group_id+1;\n\t}\n\n\n\ttrak->Header->alternate_group = alternateGroupID;\n\n\ttsel = NULL;\n\tif (*switchGroupID) {\n\t\tif (!trak->udta) {\n\t\t\te = trak_on_child_box((GF_Box*)trak, gf_isom_box_new_parent(&trak->child_boxes, GF_ISOM_BOX_TYPE_UDTA), GF_FALSE);\n\t\t\tif (e) return e;\n\t\t}\n\n\t\tmap = udta_getEntry(trak->udta, GF_ISOM_BOX_TYPE_TSEL, NULL);\n\n\t\t/*locate tsel box with no switch group*/\n\t\tif (map)  {\n\t\t\tu32 j, count = gf_list_count(map->boxes);\n\t\t\tfor (j=0; j<count; j++) {\n\t\t\t\ttsel = (GF_TrackSelectionBox*)gf_list_get(map->boxes, j);\n\t\t\t\tif (tsel->switchGroup == *switchGroupID) break;\n\t\t\t\ttsel = NULL;\n\t\t\t}\n\t\t}\n\t\tif (!tsel) {\n\t\t\ttsel = (GF_TrackSelectionBox *)gf_isom_box_new(GF_ISOM_BOX_TYPE_TSEL);\n\t\t\tif (!tsel) return GF_OUT_OF_MEM;\n\t\t\te = udta_on_child_box((GF_Box *)trak->udta, (GF_Box *) tsel, GF_FALSE);\n\t\t\tif (e) return e;\n\t\t}\n\n\t\ttsel->switchGroup = *switchGroupID;\n\t\ttsel->attributeListCount = criteriaListCount;\n\t\tif (tsel->attributeList) gf_free(tsel->attributeList);\n\t\ttsel->attributeList = (u32*)gf_malloc(sizeof(u32)*criteriaListCount);\n\t\tif (!tsel->attributeList) return GF_OUT_OF_MEM;\n\t\tmemcpy(tsel->attributeList, criteriaList, sizeof(u32)*criteriaListCount);\n\t}\n\treturn GF_OK;\n}\n\nvoid reset_tsel_box(GF_TrackBox *trak)\n{\n\tGF_UserDataMap *map;\n\ttrak->Header->alternate_group = 0;\n\tmap = udta_getEntry(trak->udta, GF_ISOM_BOX_TYPE_TSEL, NULL);\n\tif (map) {\n\t\tgf_list_del_item(trak->udta->recordList, map);\n\t\tgf_isom_box_array_del(map->boxes);\n\t\tgf_free(map);\n\t}\n\n}\n\nGF_EXPORT\nGF_Err gf_isom_reset_track_switch_parameter(GF_ISOFile *movie, u32 trackNumber, Bool reset_all_group)\n{\n\tGF_TrackBox *trak;\n\tu32 alternateGroupID = 0;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\tif (!trak->Header->alternate_group) return GF_OK;\n\n\talternateGroupID = trak->Header->alternate_group;\n\tif (reset_all_group) {\n\t\tu32 i=0;\n\t\twhile (i< gf_isom_get_track_count(movie) ) {\n\t\t\t//locate first available ID\n\t\t\tGF_TrackBox *a_trak = gf_isom_get_track_from_file(movie, i+1);\n\t\t\tif (a_trak->Header->alternate_group == alternateGroupID) reset_tsel_box(a_trak);\n\t\t\ti++;\n\t\t}\n\t} else {\n\t\treset_tsel_box(trak);\n\t}\n\treturn GF_OK;\n}\n\n\nGF_EXPORT\nGF_Err gf_isom_reset_switch_parameters(GF_ISOFile *movie)\n{\n\tu32 i=0;\n\twhile (i< gf_isom_get_track_count(movie) ) {\n\t\t//locate first available ID\n\t\tGF_TrackBox *a_trak = gf_isom_get_track_from_file(movie, i+1);\n\t\treset_tsel_box(a_trak);\n\t\ti++;\n\t}\n\treturn GF_OK;\n}\n\n\nGF_Err gf_isom_add_subsample(GF_ISOFile *movie, u32 track, u32 sampleNumber, u32 flags, u32 subSampleSize, u8 priority, u32 reserved, Bool discardable)\n{\n\tu32 i, count;\n\tGF_SubSampleInformationBox *sub_samples;\n\tGF_TrackBox *trak;\n\tGF_Err e;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, track);\n\tif (!trak || !trak->Media || !trak->Media->information->sampleTable)\n\t\treturn GF_BAD_PARAM;\n\n\tif (!trak->Media->information->sampleTable->sub_samples) {\n\t\ttrak->Media->information->sampleTable->sub_samples=gf_list_new();\n\t}\n\n\tsub_samples = NULL;\n\tcount = gf_list_count(trak->Media->information->sampleTable->sub_samples);\n\tfor (i=0; i<count; i++) {\n\t\tsub_samples = gf_list_get(trak->Media->information->sampleTable->sub_samples, i);\n\t\tif (sub_samples->flags==flags) break;\n\t\tsub_samples = NULL;\n\t}\n\tif (!sub_samples) {\n\t\tsub_samples = (GF_SubSampleInformationBox *) gf_isom_box_new_parent(&trak->Media->information->sampleTable->child_boxes, GF_ISOM_BOX_TYPE_SUBS);\n\t\tif (!sub_samples) return GF_OUT_OF_MEM;\n\t\tgf_list_add(trak->Media->information->sampleTable->sub_samples, sub_samples);\n\t\tsub_samples->version = (subSampleSize>0xFFFF) ? 1 : 0;\n\t\tsub_samples->flags = flags;\n\t}\n\treturn gf_isom_add_subsample_info(sub_samples, sampleNumber, subSampleSize, priority, reserved, discardable);\n}\n\n\nGF_EXPORT\nGF_Err gf_isom_set_rvc_config(GF_ISOFile *movie, u32 track, u32 sampleDescriptionIndex, u16 rvc_predefined, char *mime, u8 *data, u32 size)\n{\n\tGF_MPEGVisualSampleEntryBox *entry;\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, track);\n\tif (!trak) return GF_BAD_PARAM;\n\n\n\tentry = (GF_MPEGVisualSampleEntryBox *) gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, sampleDescriptionIndex-1);\n\tif (!entry ) return GF_BAD_PARAM;\n\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_VIDEO) return GF_BAD_PARAM;\n\n\tGF_RVCConfigurationBox *rvcc = (GF_RVCConfigurationBox *) gf_isom_box_find_child(entry->child_boxes, GF_ISOM_BOX_TYPE_RVCC);\n\tif (rvcc && rvcc->rvc_meta_idx) {\n\t\tgf_isom_remove_meta_item(movie, GF_FALSE, track, rvcc->rvc_meta_idx);\n\t\trvcc->rvc_meta_idx = 0;\n\t}\n\n\tif (!rvcc) {\n\t\trvcc = (GF_RVCConfigurationBox *) gf_isom_box_new_parent(&entry->child_boxes, GF_ISOM_BOX_TYPE_RVCC);\n\t\tif (!rvcc) return GF_OUT_OF_MEM;\n\t}\n\trvcc->predefined_rvc_config = rvc_predefined;\n\tif (!rvc_predefined) {\n\t\tu32 it_id=0;\n\t\te = gf_isom_set_meta_type(movie, GF_FALSE, track, GF_META_TYPE_RVCI);\n\t\tif (e) return e;\n\t\tgf_isom_modify_alternate_brand(movie, GF_ISOM_BRAND_ISO2, GF_TRUE);\n\t\te = gf_isom_add_meta_item_memory(movie, GF_FALSE, track, \"rvcconfig.xml\", &it_id, GF_META_ITEM_TYPE_MIME, mime, NULL, NULL, data, size, NULL);\n\t\tif (e) return e;\n\t\trvcc->rvc_meta_idx = gf_isom_get_meta_item_count(movie, GF_FALSE, track);\n\t}\n\treturn GF_OK;\n}\n\n/*for now not exported*/\n/*expands sampleGroup table for the given grouping type and sample_number. If sample_number is 0, just appends an entry at the end of the table*/\nstatic GF_Err gf_isom_add_sample_group_entry(GF_List *sampleGroups, u32 sample_number, u32 grouping_type, u32 grouping_type_parameter, u32 sampleGroupDescriptionIndex, GF_List *parent, GF_SampleTableBox *stbl)\n{\n\tGF_SampleGroupBox *sgroup = NULL;\n\tu32 i, count, last_sample_in_entry;\n\tBool all_samples = GF_FALSE;\n\tassert(sampleGroups);\n\tcount = gf_list_count(sampleGroups);\n\tfor (i=0; i<count; i++) {\n\t\tsgroup = (GF_SampleGroupBox*)gf_list_get(sampleGroups, i);\n\t\tif (sgroup->grouping_type==grouping_type) break;\n\t\tsgroup = NULL;\n\t}\n\tif (!sgroup) {\n\t\tsgroup = (GF_SampleGroupBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_SBGP);\n\t\tif (!sgroup) return GF_OUT_OF_MEM;\n\t\tsgroup->grouping_type = grouping_type;\n\t\tsgroup->grouping_type_parameter = grouping_type_parameter;\n//\t\tgf_list_add(sampleGroups, sgroup);\n\t\t//crude patch to align old arch and filters\n\t\tgf_list_insert(sampleGroups, sgroup, 0);\n\t\tassert(parent);\n\t\tgf_list_add(parent, sgroup);\n\t}\n\t/*used in fragments, means we are adding the last sample*/\n\tif (!sample_number) {\n\t\tsample_number = 1;\n\t\tif (sgroup->entry_count) {\n\t\t\tfor (i=0; i<sgroup->entry_count; i++) {\n\t\t\t\tsample_number += sgroup->sample_entries[i].sample_count;\n\t\t\t}\n\t\t}\n\t} else if (sample_number==(u32) -1) {\n\t\tall_samples = GF_TRUE;\n\t\tsample_number = 1;\n\t}\n\n\tif (!sgroup->entry_count) {\n\t\tu32 idx = 0;\n\t\tsgroup->entry_count = (sample_number>1) ? 2 : 1;\n\t\tsgroup->sample_entries = (GF_SampleGroupEntry*)gf_malloc(sizeof(GF_SampleGroupEntry) * sgroup->entry_count );\n\t\tif (!sgroup->sample_entries) return GF_OUT_OF_MEM;\n\t\tif (sample_number>1) {\n\t\t\tsgroup->sample_entries[0].sample_count = sample_number-1;\n\t\t\tsgroup->sample_entries[0].group_description_index = sampleGroupDescriptionIndex ? 0 : 1;\n\t\t\tidx = 1;\n\t\t}\n\t\tsgroup->sample_entries[idx].sample_count = 1;\n\t\tsgroup->sample_entries[idx].group_description_index = sampleGroupDescriptionIndex;\n\t\tif (all_samples && stbl) {\n\t\t\tsgroup->sample_entries[idx].sample_count = stbl->SampleSize->sampleCount;\n\t\t}\n\t\treturn GF_OK;\n\t}\n\tif (all_samples && stbl) {\n\t\tsgroup->entry_count = 1;\n\t\tsgroup->sample_entries[0].group_description_index = sampleGroupDescriptionIndex;\n\t\tsgroup->sample_entries[0].sample_count = stbl->SampleSize->sampleCount;\n\t\treturn GF_OK;\n\t}\n\tlast_sample_in_entry = 0;\n\tfor (i=0; i<sgroup->entry_count; i++) {\n\t\t/*TODO*/\n\t\tif (last_sample_in_entry + sgroup->sample_entries[i].sample_count > sample_number) return GF_NOT_SUPPORTED;\n\t\tlast_sample_in_entry += sgroup->sample_entries[i].sample_count;\n\t}\n\n\tif (last_sample_in_entry == sample_number) {\n\t\tif (sgroup->sample_entries[sgroup->entry_count-1].group_description_index==sampleGroupDescriptionIndex)\n\t\t\treturn GF_OK;\n\t\telse\n\t\t\treturn GF_NOT_SUPPORTED;\n\t}\n\n\tif ((sgroup->sample_entries[sgroup->entry_count-1].group_description_index==sampleGroupDescriptionIndex) && (last_sample_in_entry+1==sample_number)) {\n\t\tsgroup->sample_entries[sgroup->entry_count-1].sample_count++;\n\t\treturn GF_OK;\n\t}\n\t/*last entry was an empty desc (no group associated), just add the number of samples missing until new one, then add new one*/\n\tif (! sgroup->sample_entries[sgroup->entry_count-1].group_description_index) {\n\t\tsgroup->sample_entries[sgroup->entry_count-1].sample_count += sample_number - 1 - last_sample_in_entry;\n\t\tsgroup->sample_entries = (GF_SampleGroupEntry*)gf_realloc(sgroup->sample_entries, sizeof(GF_SampleGroupEntry) * (sgroup->entry_count + 1) );\n\t\tsgroup->sample_entries[sgroup->entry_count].sample_count = 1;\n\t\tsgroup->sample_entries[sgroup->entry_count].group_description_index = sampleGroupDescriptionIndex;\n\t\tsgroup->entry_count++;\n\t\treturn GF_OK;\n\t}\n\t/*we are adding a sample with no desc, add entry at the end*/\n\tif (!sampleGroupDescriptionIndex || (sample_number - 1 - last_sample_in_entry==0) ) {\n\t\tsgroup->sample_entries = (GF_SampleGroupEntry*)gf_realloc(sgroup->sample_entries, sizeof(GF_SampleGroupEntry) * (sgroup->entry_count + 1) );\n\t\tsgroup->sample_entries[sgroup->entry_count].sample_count = 1;\n\t\tsgroup->sample_entries[sgroup->entry_count].group_description_index = sampleGroupDescriptionIndex;\n\t\tsgroup->entry_count++;\n\t\treturn GF_OK;\n\t}\n\t/*need to insert two entries ...*/\n\tsgroup->sample_entries = (GF_SampleGroupEntry*)gf_realloc(sgroup->sample_entries, sizeof(GF_SampleGroupEntry) * (sgroup->entry_count + 2) );\n\n\tsgroup->sample_entries[sgroup->entry_count].sample_count = sample_number - 1 - last_sample_in_entry;\n\tsgroup->sample_entries[sgroup->entry_count].group_description_index = 0;\n\n\tsgroup->sample_entries[sgroup->entry_count+1].sample_count = 1;\n\tsgroup->sample_entries[sgroup->entry_count+1].group_description_index = sampleGroupDescriptionIndex;\n\tsgroup->entry_count+=2;\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\nstatic GF_SampleGroupDescriptionBox *get_sgdp(GF_SampleTableBox *stbl, GF_TrackFragmentBox *traf, u32 grouping_type, Bool *is_traf_sgdp)\n#else\nstatic GF_SampleGroupDescriptionBox *get_sgdp(GF_SampleTableBox *stbl, void *traf, u32 grouping_type, Bool *is_traf_sgdp)\n#endif /* GPAC_DISABLE_ISOM_FRAGMENTS */\n{\n\tGF_List *groupList=NULL;\n\tGF_List **parent=NULL;\n\tGF_SampleGroupDescriptionBox *sgdesc=NULL;\n\tu32 count, i;\n\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\tif (!stbl && traf && traf->trex->track->Media->information->sampleTable)\n\t\tstbl = traf->trex->track->Media->information->sampleTable;\n#endif\n\tif (stbl) {\n\t\tif (!stbl->sampleGroupsDescription && !traf)\n\t\t\tstbl->sampleGroupsDescription = gf_list_new();\n\n\t\tgroupList = stbl->sampleGroupsDescription;\n\t\tif (is_traf_sgdp) *is_traf_sgdp = GF_FALSE;\n\t\tparent = &stbl->child_boxes;\n\n\t\tcount = gf_list_count(groupList);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tsgdesc = (GF_SampleGroupDescriptionBox*)gf_list_get(groupList, i);\n\t\t\tif (sgdesc->grouping_type==grouping_type) break;\n\t\t\tsgdesc = NULL;\n\t\t}\n\t}\n\t\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t/*look in stbl or traf for sample sampleGroupsDescription*/\n\tif (!sgdesc && traf) {\n\t\tif (!traf->sampleGroupsDescription)\n\t\t\ttraf->sampleGroupsDescription = gf_list_new();\n\t\tgroupList = traf->sampleGroupsDescription;\n\t\tparent = &traf->child_boxes;\n\t\tif (is_traf_sgdp) *is_traf_sgdp = GF_TRUE;\n\n\t\tcount = gf_list_count(groupList);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tsgdesc = (GF_SampleGroupDescriptionBox*)gf_list_get(groupList, i);\n\t\t\tif (sgdesc->grouping_type==grouping_type) break;\n\t\t\tsgdesc = NULL;\n\t\t}\n\t}\n#endif\n\n\tif (!sgdesc) {\n\t\tsgdesc = (GF_SampleGroupDescriptionBox *) gf_isom_box_new_parent(parent, GF_ISOM_BOX_TYPE_SGPD);\n\t\tif (!sgdesc) return NULL;\n\t\tsgdesc->grouping_type = grouping_type;\n\t\tassert(groupList);\n\t\tgf_list_add(groupList, sgdesc);\n\t}\n\treturn sgdesc;\n}\n\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\nstatic GF_Err gf_isom_set_sample_group_info_ex(GF_SampleTableBox *stbl, GF_TrackFragmentBox *traf, u32 sample_number, u32 grouping_type, u32 grouping_type_parameter, void *udta, void *(*sg_create_entry)(void *udta), Bool (*sg_compare_entry)(void *udta, void *entry))\n#else\nstatic GF_Err gf_isom_set_sample_group_info_ex(GF_SampleTableBox *stbl, void *traf, u32 sample_number, u32 grouping_type, u32 grouping_type_parameter, void *udta, void *(*sg_create_entry)(void *udta), Bool (*sg_compare_entry)(void *udta, void *entry))\n#endif /* GPAC_DISABLE_ISOM_FRAGMENTS */\n{\n\tGF_List *groupList, *parent;\n\tvoid *entry;\n\tBool is_traf_sgpd;\n\tGF_SampleGroupDescriptionBox *sgdesc = NULL;\n\tu32 i, entry_idx;\n\n\tif (!stbl && !traf) return GF_BAD_PARAM;\n\n\tsgdesc = get_sgdp(stbl, traf, grouping_type, &is_traf_sgpd);\n\tif (!sgdesc) return GF_OUT_OF_MEM;\n\n\tentry = NULL;\n\tif (sg_compare_entry) {\n\t\tfor (i=0; i<gf_list_count(sgdesc->group_descriptions); i++) {\n\t\t\tentry = gf_list_get(sgdesc->group_descriptions, i);\n\t\t\tif (sg_compare_entry(udta, entry)) break;\n\t\t\tentry = NULL;\n\t\t}\n\t}\n\tif (!entry && sg_create_entry) {\n\t\tentry = sg_create_entry(udta);\n\t\tif (!entry) return GF_IO_ERR;\n\t\tif (traf && !is_traf_sgpd) {\n\t\t\tsgdesc = get_sgdp(NULL, traf, grouping_type, &is_traf_sgpd);\n\t\t}\n\t\tgf_list_add(sgdesc->group_descriptions, entry);\n\t}\n\tif (!entry)\n\t\tentry_idx = 0;\n\telse\n\t\tentry_idx = 1 + gf_list_find(sgdesc->group_descriptions, entry);\n\n\t/*look in stbl or traf for sample sampleGroups*/\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\tif (traf) {\n\t\tif (!traf->sampleGroups)\n\t\t\ttraf->sampleGroups = gf_list_new();\n\t\tgroupList = traf->sampleGroups;\n\t\tparent = traf->child_boxes;\n\t\tif (entry_idx && is_traf_sgpd)\n\t\t\tentry_idx |= 0x10000;\n\t} else\n#endif\n\t{\n\t\tif (!stbl->sampleGroups)\n\t\t\tstbl->sampleGroups = gf_list_new();\n\t\tgroupList = stbl->sampleGroups;\n\t\tparent = stbl->child_boxes;\n\t}\n\n\treturn gf_isom_add_sample_group_entry(groupList, sample_number, grouping_type, grouping_type_parameter, entry_idx, parent, stbl);\n}\n\n/*for now not exported*/\nstatic GF_Err gf_isom_set_sample_group_info(GF_ISOFile *movie, u32 track, u32 trafID, u32 sample_number, u32 grouping_type, u32 grouping_type_parameter, void *udta, void *(*sg_create_entry)(void *udta), Bool (*sg_compare_entry)(void *udta, void *entry))\n{\n\tGF_Err e;\n\tGF_TrackBox *trak=NULL;\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\tGF_TrackFragmentBox *traf=NULL;\n#endif\n\tif (!trafID && (movie->FragmentsFlags & GF_ISOM_FRAG_WRITE_READY)) {\n\t\ttrak = gf_isom_get_track_from_file(movie, track);\n\t\tif (!trak) return GF_BAD_PARAM;\n\t\ttrafID = trak->Header->trackID;\n\t}\n\n\tif (trafID) {\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t\tif (!movie->moof || !(movie->FragmentsFlags & GF_ISOM_FRAG_WRITE_READY) )\n\t\t\treturn GF_BAD_PARAM;\n\n\t\ttraf = gf_isom_get_traf(movie, trafID);\n#else\n\t\treturn GF_NOT_SUPPORTED;\n#endif\n\n\t} else if (track) {\n\t\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\t\tif (e) return e;\n\n\t\ttrak = gf_isom_get_track_from_file(movie, track);\n\t\tif (!trak) return GF_BAD_PARAM;\n\t}\n\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\treturn gf_isom_set_sample_group_info_ex(trak ? trak->Media->information->sampleTable : NULL, traf, sample_number, grouping_type, grouping_type_parameter, udta, sg_create_entry, sg_compare_entry);\n#else\n\treturn gf_isom_set_sample_group_info_ex(trak->Media->information->sampleTable, sample_number, grouping_type, grouping_type_parameter, udta, sg_create_entry, sg_compare_entry);\n#endif\n\n}\n\n\nGF_EXPORT\nGF_Err gf_isom_add_sample_group_info(GF_ISOFile *movie, u32 track, u32 grouping_type, void *data, u32 data_size, Bool is_default, u32 *sampleGroupDescriptionIndex)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\tGF_DefaultSampleGroupDescriptionEntry *entry=NULL;\n\tGF_SampleGroupDescriptionBox *sgdesc = NULL;\n\n\tif (sampleGroupDescriptionIndex) *sampleGroupDescriptionIndex = 0;\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, track);\n\tif (!trak) return GF_BAD_PARAM;\n\n\n\tsgdesc = get_sgdp(trak->Media->information->sampleTable, NULL, grouping_type, NULL);\n\tif (!sgdesc) return GF_OUT_OF_MEM;\n\n\tif (grouping_type==GF_ISOM_SAMPLE_GROUP_OINF) {\n\t\tGF_OperatingPointsInformation *ptr = gf_isom_oinf_new_entry();\n\t\tGF_BitStream *bs=gf_bs_new(data, data_size, GF_BITSTREAM_READ);\n\t\te = gf_isom_oinf_read_entry(ptr, bs);\n\t\tgf_bs_del(bs);\n\t\tif (e) {\n\t\t\tgf_isom_oinf_del_entry(ptr);\n\t\t\treturn e;\n\t\t}\n\t\te = gf_list_add(sgdesc->group_descriptions, ptr);\n\t\tif (e) return e;\n\t\tentry = (GF_DefaultSampleGroupDescriptionEntry *) ptr;\n\t} else if (grouping_type==GF_ISOM_SAMPLE_GROUP_LINF) {\n\t\tGF_LHVCLayerInformation *ptr = gf_isom_linf_new_entry();\n\t\tGF_BitStream *bs=gf_bs_new(data, data_size, GF_BITSTREAM_READ);\n\t\te = gf_isom_linf_read_entry(ptr, bs);\n\t\tgf_bs_del(bs);\n\t\tif (e) {\n\t\t\tgf_isom_linf_del_entry(ptr);\n\t\t\treturn e;\n\t\t}\n\t\te = gf_list_add(sgdesc->group_descriptions, ptr);\n\t\tif (e) return e;\n\t\tentry = (GF_DefaultSampleGroupDescriptionEntry *) ptr;\n\t} else {\n\t\tu32 i, count=gf_list_count(sgdesc->group_descriptions);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tGF_DefaultSampleGroupDescriptionEntry *ent = gf_list_get(sgdesc->group_descriptions, i);\n\t\t\tif ((ent->length == data_size) && !memcmp(ent->data, data, data_size)) {\n\t\t\t\tentry = ent;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tentry=NULL;\n\t\t}\n\t\tif (!entry) {\n\t\t\tGF_SAFEALLOC(entry, GF_DefaultSampleGroupDescriptionEntry);\n\t\t\tif (!entry) return GF_OUT_OF_MEM;\n\t\t\tentry->data = (u8*)gf_malloc(sizeof(char) * data_size);\n\t\t\tif (!entry->data) {\n\t\t\t\tgf_free(entry);\n\t\t\t\treturn GF_OUT_OF_MEM;\n\t\t\t}\n\t\t\tentry->length = data_size;\n\t\t\tmemcpy(entry->data, data, sizeof(char) * data_size);\n\t\t\te = gf_list_add(sgdesc->group_descriptions, entry);\n\t\t\tif (e) {\n\t\t\t\tgf_free(entry->data);\n\t\t\t\tgf_free(entry);\n\t\t\t\treturn e;\n\t\t\t}\n\t\t}\n\t}\n\n\n\tif (is_default) {\n\t\tsgdesc->default_description_index = 1 + gf_list_find(sgdesc->group_descriptions, entry);\n\t\tsgdesc->version = 2;\n\t}\n\tif (sampleGroupDescriptionIndex) *sampleGroupDescriptionIndex = 1 + gf_list_find(sgdesc->group_descriptions, entry);\n\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_remove_sample_group(GF_ISOFile *movie, u32 track, u32 grouping_type)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\tu32 count, i;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, track);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tif (trak->Media->information->sampleTable->sampleGroupsDescription) {\n\t\tcount = gf_list_count(trak->Media->information->sampleTable->sampleGroupsDescription);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tGF_SampleGroupDescriptionBox *sgdesc = (GF_SampleGroupDescriptionBox*)gf_list_get(trak->Media->information->sampleTable->sampleGroupsDescription, i);\n\t\t\tif (sgdesc->grouping_type==grouping_type) {\n\t\t\t\tgf_isom_box_del_parent(&trak->Media->information->sampleTable->child_boxes, (GF_Box*)sgdesc);\n\t\t\t\tgf_list_rem(trak->Media->information->sampleTable->sampleGroupsDescription, i);\n\t\t\t\ti--;\n\t\t\t\tcount--;\n\t\t\t}\n\t\t}\n\t}\n\tif (trak->Media->information->sampleTable->sampleGroups) {\n\t\tcount = gf_list_count(trak->Media->information->sampleTable->sampleGroups);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tGF_SampleGroupBox *sgroup = gf_list_get(trak->Media->information->sampleTable->sampleGroups, i);\n\t\t\tif (sgroup->grouping_type==grouping_type) {\n\t\t\t\tgf_isom_box_del_parent(&trak->Media->information->sampleTable->child_boxes, (GF_Box*)sgroup);\n\t\t\t\tgf_list_rem(trak->Media->information->sampleTable->sampleGroups, i);\n\t\t\t\ti--;\n\t\t\t\tcount--;\n\t\t\t}\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_add_sample_info(GF_ISOFile *movie, u32 track, u32 sample_number, u32 grouping_type, u32 sampleGroupDescriptionIndex, u32 grouping_type_parameter)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\tGF_List *groupList;\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, track);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tif (!trak->Media->information->sampleTable->sampleGroups)\n\t\ttrak->Media->information->sampleTable->sampleGroups = gf_list_new();\n\n\tgroupList = trak->Media->information->sampleTable->sampleGroups;\n\treturn gf_isom_add_sample_group_entry(groupList, sample_number, grouping_type, grouping_type_parameter, sampleGroupDescriptionIndex, trak->Media->information->sampleTable->child_boxes, trak->Media->information->sampleTable);\n}\n\nvoid *sg_rap_create_entry(void *udta)\n{\n\tGF_VisualRandomAccessEntry *entry;\n\tu32 *num_leading_samples = (u32 *) udta;\n\tassert(udta);\n\tGF_SAFEALLOC(entry, GF_VisualRandomAccessEntry);\n\tif (!entry) return NULL;\n\tentry->num_leading_samples = *num_leading_samples;\n\tentry->num_leading_samples_known = entry->num_leading_samples ? 1 : 0;\n\treturn entry;\n}\n\nBool sg_rap_compare_entry(void *udta, void *entry)\n{\n\tu32 *num_leading_samples = (u32 *) udta;\n\tif (*num_leading_samples == ((GF_VisualRandomAccessEntry *)entry)->num_leading_samples) return GF_TRUE;\n\treturn GF_FALSE;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_sample_rap_group(GF_ISOFile *movie, u32 track, u32 sample_number, Bool is_rap, u32 num_leading_samples)\n{\n\treturn gf_isom_set_sample_group_info(movie, track, 0, sample_number, GF_ISOM_SAMPLE_GROUP_RAP, 0, &num_leading_samples, is_rap ? sg_rap_create_entry : NULL, is_rap ? sg_rap_compare_entry : NULL);\n}\n\nGF_Err gf_isom_fragment_set_sample_rap_group(GF_ISOFile *movie, GF_ISOTrackID trackID, u32 sample_number_in_frag, Bool is_rap, u32 num_leading_samples)\n{\n\treturn gf_isom_set_sample_group_info(movie, 0, trackID, sample_number_in_frag, GF_ISOM_SAMPLE_GROUP_RAP, 0, &num_leading_samples, is_rap ? sg_rap_create_entry : NULL, is_rap ? sg_rap_compare_entry : NULL);\n}\n\n\n\nvoid *sg_roll_create_entry(void *udta)\n{\n\tGF_RollRecoveryEntry *entry;\n\ts16 *roll_distance = (s16 *) udta;\n\tGF_SAFEALLOC(entry, GF_RollRecoveryEntry);\n\tif (!entry) return NULL;\n\tentry->roll_distance = *roll_distance;\n\treturn entry;\n}\n\nBool sg_roll_compare_entry(void *udta, void *entry)\n{\n\ts16 *roll_distance = (s16 *) udta;\n\tif (*roll_distance == ((GF_RollRecoveryEntry *)entry)->roll_distance) return GF_TRUE;\n\treturn GF_FALSE;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_sample_roll_group(GF_ISOFile *movie, u32 track, u32 sample_number, GF_ISOSampleRollType roll_type, s16 roll_distance)\n{\n\tu32 grp_type = (roll_type>=GF_ISOM_SAMPLE_PREROLL) ? GF_ISOM_SAMPLE_GROUP_PROL : GF_ISOM_SAMPLE_GROUP_ROLL;\n\tif (roll_type==GF_ISOM_SAMPLE_PREROLL_NONE)\n\t\troll_type = 0;\n\n\treturn gf_isom_set_sample_group_info(movie, track, 0, sample_number, grp_type, 0, &roll_distance, roll_type ? sg_roll_create_entry : NULL, roll_type ? sg_roll_compare_entry : NULL);\n}\n\nGF_EXPORT\nGF_Err gf_isom_fragment_set_sample_roll_group(GF_ISOFile *movie, GF_ISOTrackID trackID, u32 sample_number_in_frag, GF_ISOSampleRollType roll_type, s16 roll_distance)\n{\n\tu32 grp_type = (roll_type>=GF_ISOM_SAMPLE_PREROLL) ? GF_ISOM_SAMPLE_GROUP_PROL : GF_ISOM_SAMPLE_GROUP_ROLL;\n\tif (roll_type==GF_ISOM_SAMPLE_PREROLL_NONE)\n\t\troll_type = 0;\n\n\treturn gf_isom_set_sample_group_info(movie, 0, trackID, sample_number_in_frag, grp_type, 0, &roll_distance, roll_type ? sg_roll_create_entry : NULL, roll_type ? sg_roll_compare_entry : NULL);\n}\n\n\nvoid *sg_encryption_create_entry(void *udta)\n{\n\tGF_CENCSampleEncryptionGroupEntry *entry, *from_entry;\n\tGF_SAFEALLOC(entry, GF_CENCSampleEncryptionGroupEntry);\n\tif (!entry) return NULL;\n\tfrom_entry = (GF_CENCSampleEncryptionGroupEntry *)udta;\n\tmemcpy(entry, from_entry, sizeof(GF_CENCSampleEncryptionGroupEntry) );\n\tentry->key_info = gf_malloc(sizeof(u8) * entry->key_info_size);\n\tif (!entry->key_info) {\n\t\tgf_free(entry);\n\t\treturn NULL;\n\t}\n\tmemcpy(entry->key_info, from_entry->key_info, entry->key_info_size);\n\treturn entry;\n}\n\nBool sg_encryption_compare_entry(void *udta, void *_entry)\n{\n\tGF_CENCSampleEncryptionGroupEntry *entry = (GF_CENCSampleEncryptionGroupEntry *)_entry;\n\tGF_CENCSampleEncryptionGroupEntry *with_entry = (GF_CENCSampleEncryptionGroupEntry *)udta;\n\n\tif (entry->IsProtected != with_entry->IsProtected) return GF_FALSE;\n\tif (entry->skip_byte_block != with_entry->skip_byte_block) return GF_FALSE;\n\tif (entry->crypt_byte_block != with_entry->crypt_byte_block) return GF_FALSE;\n\tif (entry->key_info_size != with_entry->key_info_size) return GF_FALSE;\n\n\tif (!memcmp(entry->key_info, with_entry->key_info, with_entry->key_info_size))\n\t\treturn GF_TRUE;\n\treturn GF_FALSE;\n}\n\n\n/*sample encryption information group can be in stbl or traf*/\nGF_EXPORT\nGF_Err gf_isom_set_sample_cenc_group(GF_ISOFile *movie, u32 track, u32 sample_number, u8 isEncrypted, u8 crypt_byte_block, u8 skip_byte_block, u8 *key_info, u32 key_info_size)\n{\n\tGF_CENCSampleEncryptionGroupEntry entry;\n\tif (!key_info || (key_info_size<19))\n\t\treturn GF_BAD_PARAM;\n\n\tmemset(&entry, 0, sizeof(GF_CENCSampleEncryptionGroupEntry));\n\tentry.crypt_byte_block = crypt_byte_block;\n\tentry.skip_byte_block = skip_byte_block;\n\tentry.IsProtected = isEncrypted;\n\tentry.key_info = key_info;\n\tentry.key_info_size = key_info_size;\n\n\treturn gf_isom_set_sample_group_info(movie, track, 0, sample_number, GF_ISOM_SAMPLE_GROUP_SEIG, 0, &entry, sg_encryption_create_entry, sg_encryption_compare_entry);\n}\n\n\n\nGF_EXPORT\nGF_Err gf_isom_set_sample_cenc_default_group(GF_ISOFile *movie, u32 track, u32 sample_number)\n{\n\treturn gf_isom_set_sample_group_info(movie, track, 0, sample_number, GF_ISOM_SAMPLE_GROUP_SEIG, 0, NULL, NULL, NULL);\n}\n\nGF_Err gf_isom_force_ctts(GF_ISOFile *file, u32 track)\n{\n\tGF_TrackBox *trak;\n\tGF_Err e = CanAccessMovie(file, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n \ttrak = gf_isom_get_track_from_file(file, track);\n\tif (!trak) return GF_BAD_PARAM;\n\tif (trak->Media->information->sampleTable->CompositionOffset) return GF_OK;\n\n\ttrak->Media->information->sampleTable->CompositionOffset = (GF_CompositionOffsetBox *) gf_isom_box_new_parent(&trak->Media->information->sampleTable->child_boxes, GF_ISOM_BOX_TYPE_CTTS);\n\tif (!trak->Media->information->sampleTable->CompositionOffset) return GF_OUT_OF_MEM;\n\ttrak->Media->information->sampleTable->CompositionOffset->nb_entries = 1;\n\ttrak->Media->information->sampleTable->CompositionOffset->entries = gf_malloc(sizeof(GF_DttsEntry));\n\ttrak->Media->information->sampleTable->CompositionOffset->entries[0].decodingOffset = 0;\n\ttrak->Media->information->sampleTable->CompositionOffset->entries[0].sampleCount = \ttrak->Media->information->sampleTable->SampleSize->sampleCount;\n\treturn GF_OK;\n}\n\nGF_Err gf_isom_set_ctts_v1(GF_ISOFile *file, u32 track, u32 ctts_shift)\n{\n\tu32 i, shift;\n\tu64 duration;\n\tGF_CompositionOffsetBox *ctts;\n\tGF_CompositionToDecodeBox *cslg;\n\ts32 leastCTTS, greatestCTTS;\n\tGF_TrackBox *trak;\n\tGF_Err e = CanAccessMovie(file, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n \ttrak = gf_isom_get_track_from_file(file, track);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tctts = trak->Media->information->sampleTable->CompositionOffset;\n\tshift = ctts->version ? ctts_shift : ctts->entries[0].decodingOffset;\n\tleastCTTS = GF_INT_MAX;\n\tgreatestCTTS = 0;\n\tfor (i=0; i<ctts->nb_entries; i++) {\n\t\tif (!ctts->version)\n\t\t\tctts->entries[i].decodingOffset -= shift;\n\n\t\tif ((s32)ctts->entries[i].decodingOffset < leastCTTS)\n\t\t\tleastCTTS = ctts->entries[i].decodingOffset;\n\t\tif ((s32)ctts->entries[i].decodingOffset > greatestCTTS)\n\t\t\tgreatestCTTS = ctts->entries[i].decodingOffset;\n\t}\n\tif (!ctts->version) {\n\t\tctts->version = 1;\n\t\t//if we had edit lists, shift all media times by the given amount\n\t\tif (trak->editBox && trak->editBox->editList) {\n\t\t\tfor (i=0; i<gf_list_count(trak->editBox->editList->entryList); i++) {\n\t\t\t\tGF_EdtsEntry *ent = (GF_EdtsEntry*)gf_list_get(trak->editBox->editList->entryList, i);\n\t\t\t\t//empty edit\n\t\t\t\tif (ent->mediaTime<0) continue;\n\t\t\t\tif (ent->mediaTime>=shift) ent->mediaTime -= shift;\n\t\t\t\telse ent->mediaTime = 0;\n\t\t\t\t//no offset and last entry, trash edit\n\t\t\t\tif (!ent->mediaTime && (gf_list_count(trak->editBox->editList->entryList)==1)) {\n\t\t\t\t\tgf_isom_box_del_parent(&trak->child_boxes, (GF_Box *)trak->editBox);\n\t\t\t\t\ttrak->editBox = NULL;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSetTrackDuration(trak);\n\t\t}\n\t}\n\n\tif (!trak->Media->information->sampleTable->CompositionToDecode) {\n\t\ttrak->Media->information->sampleTable->CompositionToDecode = (GF_CompositionToDecodeBox *) gf_isom_box_new_parent(&trak->Media->information->sampleTable->child_boxes, GF_ISOM_BOX_TYPE_CSLG);\n\t\tif (!trak->Media->information->sampleTable->CompositionToDecode)\n\t\t\treturn GF_OUT_OF_MEM;\n\t}\n\n\tcslg = trak->Media->information->sampleTable->CompositionToDecode;\n\tif (cslg) {\n\t\tcslg->compositionToDTSShift = shift;\n\t\tcslg->leastDecodeToDisplayDelta = leastCTTS;\n\t\tcslg->greatestDecodeToDisplayDelta = greatestCTTS;\n\t\tcslg->compositionStartTime = 0;\n\t\t/*for our use case (first CTS set to 0), the composition end time is the media duration if it fits on 32 bits*/\n\t\tduration = gf_isom_get_media_duration(file, track);\n\t\tcslg->compositionEndTime = (duration<0x7FFFFFFF) ? (s32) duration : 0;\n\t}\n\n\tgf_isom_modify_alternate_brand(file, GF_ISOM_BRAND_ISO4, GF_TRUE);\n\treturn GF_OK;\n}\n\nstatic GF_Err gf_isom_set_ctts_v0(GF_ISOFile *file, GF_TrackBox *trak)\n{\n\tu32 i;\n\ts32 shift;\n\tGF_CompositionOffsetBox *ctts;\n\tGF_CompositionToDecodeBox *cslg;\n\n\tctts = trak->Media->information->sampleTable->CompositionOffset;\n\n\tif (!trak->Media->information->sampleTable->CompositionToDecode)\n\t{\n\t\tshift = 0;\n\t\tfor (i=0; i<ctts->nb_entries; i++) {\n\t\t\tif (-ctts->entries[i].decodingOffset > shift)\n\t\t\t\tshift = -ctts->entries[i].decodingOffset;\n\t\t}\n\t\tif (shift > 0)\n\t\t{\n\t\t\tfor (i=0; i<ctts->nb_entries; i++) {\n\t\t\t\tctts->entries[i].decodingOffset += shift;\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\tcslg = trak->Media->information->sampleTable->CompositionToDecode;\n\t\tshift = cslg->compositionToDTSShift;\n\t\tfor (i=0; i<ctts->nb_entries; i++) {\n\t\t\tctts->entries[i].decodingOffset += shift;\n\t\t}\n\t\tgf_isom_box_del_parent(&trak->Media->information->sampleTable->child_boxes, (GF_Box *)cslg);\n\t\ttrak->Media->information->sampleTable->CompositionToDecode = NULL;\n\t}\n\tif (shift>0) {\n\t\t//no edits, insert one\n\t\tif (! trak->editBox) {\n\t\t\tu64 dur = trak->Media->mediaHeader->duration;\n\t\t\tdur *= file->moov->mvhd->timeScale;\n\t\t\tdur /= trak->Media->mediaHeader->timeScale;\n\t\t\tgf_isom_set_edit(file, gf_list_find(file->moov->trackList, trak)+1, 0, dur, shift, GF_ISOM_EDIT_NORMAL);\n\t\t} else {\n\t\t\t//otherwise shift media times in all entries\n\t\t\tfor (i=0; i<gf_list_count(trak->editBox->editList->entryList); i++) {\n\t\t\t\tGF_EdtsEntry *ent = (GF_EdtsEntry*)gf_list_get(trak->editBox->editList->entryList, i);\n\t\t\t\t//empty edit\n\t\t\t\tif (ent->mediaTime<0) continue;\n\t\t\t\tent->mediaTime += shift;\n\t\t\t}\n\t\t\tSetTrackDuration(trak);\n\t\t}\n\t}\n\tctts->version = 0;\n\tgf_isom_modify_alternate_brand(file, GF_ISOM_BRAND_ISO4, GF_FALSE);\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_composition_offset_mode(GF_ISOFile *file, u32 track, Bool use_negative_offsets)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\tGF_CompositionOffsetBox *ctts;\n\n\te = CanAccessMovie(file, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(file, track);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tctts = trak->Media->information->sampleTable->CompositionOffset;\n\tif (!ctts) {\n\t\tif (!use_negative_offsets && trak->Media->information->sampleTable->CompositionToDecode) {\n\t\t\tgf_isom_box_del_parent(&trak->Media->information->sampleTable->child_boxes, (GF_Box *)trak->Media->information->sampleTable->CompositionToDecode);\n\t\t\ttrak->Media->information->sampleTable->CompositionToDecode = NULL;\n\t\t}\n\t\treturn GF_OK;\n\t}\n\n\tif (use_negative_offsets) {\n\t\treturn gf_isom_set_ctts_v1(file, track, 0);\n\t} else {\n\t\tif (ctts->version==0) return GF_OK;\n\t\treturn gf_isom_set_ctts_v0(file, trak);\n\t}\n}\n\n#if 0 //unused\nGF_Err gf_isom_set_sync_table(GF_ISOFile *file, u32 track)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\n\te = CanAccessMovie(file, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(file, track);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tif (!trak->Media->information->sampleTable->SyncSample) {\n\t\ttrak->Media->information->sampleTable->SyncSample = (GF_SyncSampleBox *) gf_isom_box_new_parent(&trak->Media->information->sampleTable->child_boxes, GF_ISOM_BOX_TYPE_STSS);\n\n\t\tif (!trak->Media->information->sampleTable->SyncSample)\n\t\t\treturn GF_OUT_OF_MEM;\n\t}\n\treturn GF_OK;\n}\n#endif\n\nGF_Err gf_isom_set_sample_flags(GF_ISOFile *file, u32 track, u32 sampleNumber, u32 isLeading, u32 dependsOn, u32 dependedOn, u32 redundant)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\n\te = CanAccessMovie(file, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(file, track);\n\tif (!trak) return GF_BAD_PARAM;\n\treturn stbl_SetDependencyType(trak->Media->information->sampleTable, sampleNumber, isLeading, dependsOn, dependedOn, redundant);\n}\n\n#if 0 //unused\nGF_Err gf_isom_sample_set_dep_info(GF_ISOFile *file, u32 track, u32 sampleNumber, u32 isLeading, u32 dependsOn, u32 dependedOn, u32 redundant)\n{\n\tGF_TrackBox *trak;\n\n\ttrak = gf_isom_get_track_from_file(file, track);\n\tif (!trak) return GF_BAD_PARAM;\n\n\treturn stbl_AddDependencyType(trak->Media->information->sampleTable, sampleNumber, isLeading, dependsOn, dependedOn, redundant);\n}\n#endif\n\nGF_EXPORT\nGF_Err gf_isom_copy_sample_info(GF_ISOFile *dst, u32 dst_track, GF_ISOFile *src, u32 src_track, u32 sampleNumber)\n{\n\tu32 i, count, idx, dst_sample_num, subs_flags;\n\tGF_SubSampleInfoEntry *sub_sample;\n\tGF_Err e;\n\tGF_TrackBox *src_trak, *dst_trak;\n\n\tsrc_trak = gf_isom_get_track_from_file(src, src_track);\n\tif (!src_trak) return GF_BAD_PARAM;\n\n\tdst_trak = gf_isom_get_track_from_file(dst, dst_track);\n\tif (!dst_trak) return GF_BAD_PARAM;\n\n\tdst_sample_num = dst_trak->Media->information->sampleTable->SampleSize->sampleCount;\n\n\t/*modify depends flags*/\n\tif (src_trak->Media->information->sampleTable->SampleDep) {\n\t\tu32 isLeading, dependsOn, dependedOn, redundant;\n\n\t\tisLeading = dependsOn = dependedOn = redundant = 0;\n\n\t\te = stbl_GetSampleDepType(src_trak->Media->information->sampleTable->SampleDep, sampleNumber, &isLeading, &dependsOn, &dependedOn, &redundant);\n\t\tif (e) return e;\n\n\t\te = stbl_AppendDependencyType(dst_trak->Media->information->sampleTable, isLeading, dependsOn, dependedOn, redundant);\n\t\tif (e) return e;\n\t}\n\n\t/*copy subsample info if any*/\n\tidx=1;\n\twhile (gf_isom_get_subsample_types(src, src_track, idx, &subs_flags)) {\n\t\tGF_SubSampleInformationBox *dst_subs=NULL;\n\t\tidx++;\n\n\t\tif ( ! gf_isom_sample_get_subsample_entry(src, src_track, sampleNumber, subs_flags, &sub_sample))\n\t\t\tcontinue;\n\n\t\t/*create subsample if needed*/\n\t\tif (!dst_trak->Media->information->sampleTable->sub_samples) {\n\t\t\tdst_trak->Media->information->sampleTable->sub_samples = gf_list_new();\n\t\t}\n\t\tcount = gf_list_count(dst_trak->Media->information->sampleTable->sub_samples);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tdst_subs = gf_list_get(dst_trak->Media->information->sampleTable->sub_samples, i);\n\t\t\tif (dst_subs->flags==subs_flags) break;\n\t\t\tdst_subs=NULL;\n\t\t}\n\t\tif (!dst_subs) {\n\t\t\tdst_subs = (GF_SubSampleInformationBox *) gf_isom_box_new_parent(&dst_trak->Media->information->sampleTable->child_boxes, GF_ISOM_BOX_TYPE_SUBS);\n\t\t\tif (!dst_subs) return GF_OUT_OF_MEM;\n\t\t\tdst_subs->version=0;\n\t\t\tdst_subs->flags = subs_flags;\n\t\t\tgf_list_add(dst_trak->Media->information->sampleTable->sub_samples, dst_subs);\n\t\t}\n\n\t\tcount = gf_list_count(sub_sample->SubSamples);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tGF_SubSampleEntry *entry = (GF_SubSampleEntry*)gf_list_get(sub_sample->SubSamples, i);\n\t\t\te = gf_isom_add_subsample_info(dst_subs, dst_sample_num, entry->subsample_size, entry->subsample_priority, entry->reserved, entry->discardable);\n\t\t\tif (e) return e;\n\t\t}\n\t}\n\n\t/*copy sampleToGroup info if any*/\n\tcount = 0;\n\tif (src_trak->Media->information->sampleTable->sampleGroups)\n\t\tcount = gf_list_count(src_trak->Media->information->sampleTable->sampleGroups);\n\n\tfor (i=0; i<count; i++) {\n\t\tGF_SampleGroupBox *sg;\n\t\tu32 j, k, default_index;\n\t\tu32 first_sample_in_entry, last_sample_in_entry, group_desc_index_src, group_desc_index_dst;\n\t\tfirst_sample_in_entry = 1;\n\n\t\tsg = (GF_SampleGroupBox*)gf_list_get(src_trak->Media->information->sampleTable->sampleGroups, i);\n\t\tfor (j=0; j<sg->entry_count; j++) {\n\t\t\tlast_sample_in_entry = first_sample_in_entry + sg->sample_entries[j].sample_count - 1;\n\t\t\tif ((sampleNumber<first_sample_in_entry) || (sampleNumber>last_sample_in_entry)) {\n\t\t\t\tfirst_sample_in_entry = last_sample_in_entry+1;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!dst_trak->Media->information->sampleTable->sampleGroups)\n\t\t\t\tdst_trak->Media->information->sampleTable->sampleGroups = gf_list_new();\n\n\t\t\tgroup_desc_index_src = group_desc_index_dst = sg->sample_entries[j].group_description_index;\n\n\t\t\tif (group_desc_index_src) {\n\t\t\t\tGF_SampleGroupDescriptionBox *sgd_src, *sgd_dst;\n\t\t\t\tGF_DefaultSampleGroupDescriptionEntry *sgde_src, *sgde_dst;\n\n\t\t\t\tgroup_desc_index_dst = 0;\n\t\t\t\t//check that the sample group description exists !!\n\t\t\t\tsgde_src = gf_isom_get_sample_group_info_entry(src, src_trak, sg->grouping_type, sg->sample_entries[j].group_description_index, &default_index, &sgd_src);\n\n\t\t\t\tif (!sgde_src) break;\n\n\t\t\t\tif (!dst_trak->Media->information->sampleTable->sampleGroupsDescription)\n\t\t\t\t\tdst_trak->Media->information->sampleTable->sampleGroupsDescription = gf_list_new();\n\n\t\t\t\tsgd_dst = NULL;\n\t\t\t\tfor (k=0; k< gf_list_count(dst_trak->Media->information->sampleTable->sampleGroupsDescription); k++) {\n\t\t\t\t\tsgd_dst = gf_list_get(dst_trak->Media->information->sampleTable->sampleGroupsDescription, k);\n\t\t\t\t\tif (sgd_dst->grouping_type==sgd_src->grouping_type) break;\n\t\t\t\t\tsgd_dst = NULL;\n\t\t\t\t}\n\t\t\t\tif (!sgd_dst) {\n\t\t\t\t\tgf_isom_clone_box( (GF_Box *) sgd_src, (GF_Box **) &sgd_dst);\n\t\t\t\t\tif (!sgd_dst) return GF_OUT_OF_MEM;\n\t\t\t\t\tgf_list_add(dst_trak->Media->information->sampleTable->sampleGroupsDescription, sgd_dst);\n\t\t\t\t}\n\n\t\t\t\t//find the same entry\n\t\t\t\tfor (k=0; k<gf_list_count(sgd_dst->group_descriptions); k++) {\n\t\t\t\t\tsgde_dst = gf_list_get(sgd_dst->group_descriptions, i);\n\t\t\t\t\tif (gf_isom_is_identical_sgpd(sgde_src, sgde_dst, sgd_src->grouping_type)) {\n\t\t\t\t\t\tgroup_desc_index_dst = k+1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!group_desc_index_dst) {\n\t\t\t\t\tGF_SampleGroupDescriptionBox *cloned=NULL;\n\t\t\t\t\tgf_isom_clone_box( (GF_Box *) sgd_src, (GF_Box **)  &cloned);\n\t\t\t\t\tif (!cloned) return GF_OUT_OF_MEM;\n\t\t\t\t\tsgde_dst = gf_list_get(cloned->group_descriptions, group_desc_index_dst);\n\t\t\t\t\tgf_list_rem(cloned->group_descriptions, group_desc_index_dst);\n\t\t\t\t\tgf_isom_box_del( (GF_Box *) cloned);\n\t\t\t\t\tgf_list_add(sgd_dst->group_descriptions, sgde_dst);\n\t\t\t\t\tgroup_desc_index_dst = gf_list_count(sgd_dst->group_descriptions);\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t\t/*found our sample, add it to trak->sampleGroups*/\n\t\t\te = gf_isom_add_sample_group_entry(dst_trak->Media->information->sampleTable->sampleGroups, dst_sample_num, sg->grouping_type, sg->grouping_type_parameter, group_desc_index_dst, dst_trak->Media->information->sampleTable->child_boxes, NULL);\n\t\t\tif (e) return e;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_text_set_display_flags(GF_ISOFile *file, u32 track, u32 desc_index, u32 flags, GF_TextFlagsMode op_type)\n{\n\tu32 i;\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\n\te = CanAccessMovie(file, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(file, track);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tfor (i=0; i < gf_list_count(trak->Media->information->sampleTable->SampleDescription->child_boxes); i++) {\n\t\tGF_Tx3gSampleEntryBox *txt;\n\t\tif (desc_index && (i+1 != desc_index)) continue;\n\n\t\ttxt = (GF_Tx3gSampleEntryBox*)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, i);\n\t\tif (txt->type != GF_ISOM_BOX_TYPE_TX3G) continue;\n\n\t\tswitch (op_type) {\n\t\tcase GF_ISOM_TEXT_FLAGS_TOGGLE:\n\t\t\ttxt->displayFlags |= flags;\n\t\t\tbreak;\n\t\tcase GF_ISOM_TEXT_FLAGS_UNTOGGLE:\n\t\t\ttxt->displayFlags &= ~flags;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\ttxt->displayFlags = flags;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn GF_OK;\n\n}\n\n\nGF_EXPORT\nGF_Err gf_isom_update_duration(GF_ISOFile *movie)\n{\n\tu32 i;\n\tu64 maxDur;\n\tGF_TrackBox *trak;\n\n\tif (!movie || !movie->moov) return GF_BAD_PARAM;\n\n\t//if file was open in Write or Edit mode, recompute the duration\n\t//the duration of a movie is the MaxDuration of all the tracks...\n\n\tmaxDur = 0;\n\ti=0;\n\twhile ((trak = (GF_TrackBox *)gf_list_enum(movie->moov->trackList, &i))) {\n\t\tif( (movie->LastError = SetTrackDuration(trak))\t) return movie->LastError;\n\t\tif (trak->Header && (trak->Header->duration > maxDur))\n\t\t\tmaxDur = trak->Header->duration;\n\t}\n\tmovie->moov->mvhd->duration = maxDur;\n\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_update_edit_list_duration(GF_ISOFile *file, u32 track)\n{\n\tu32 i;\n\tu64 trackDuration;\n\tGF_EdtsEntry *ent;\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\n\te = CanAccessMovie(file, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(file, track);\n\tif (!trak) return GF_BAD_PARAM;\n\n\n\t//the total duration is the media duration: adjust it in case...\n\te = Media_SetDuration(trak);\n\tif (e) return e;\n\n\t//assert the timeScales are non-NULL\n\tif (!trak->moov->mvhd->timeScale || !trak->Media->mediaHeader->timeScale) return GF_ISOM_INVALID_FILE;\n\ttrackDuration = (trak->Media->mediaHeader->duration * trak->moov->mvhd->timeScale) / trak->Media->mediaHeader->timeScale;\n\n\t//if we have an edit list, the duration is the sum of all the editList\n\t//entries' duration (always expressed in MovieTimeScale)\n\tif (trak->editBox && trak->editBox->editList) {\n\t\tu64 editListDuration = 0;\n\t\tGF_EditListBox *elst = trak->editBox->editList;\n\t\ti=0;\n\t\twhile ((ent = (GF_EdtsEntry*)gf_list_enum(elst->entryList, &i))) {\n\t\t\tif (ent->segmentDuration > trackDuration)\n\t\t\t\tent->segmentDuration = trackDuration;\n\t\t\tif (!ent->segmentDuration) {\n\t\t\t\tu64 diff;\n\t\t\t\tent->segmentDuration = trackDuration;\n\t\t\t\tif (ent->mediaTime>0) {\n\t\t\t\t\tdiff = ent->mediaTime;\n\t\t\t\t\tdiff *= trak->moov->mvhd->timeScale;\n\t\t\t\t\tdiff /= trak->Media->mediaHeader->timeScale;\n\t\t\t\t\tif (diff < ent->segmentDuration)\n\t\t\t\t\t\tent->segmentDuration -= diff;\n\t\t\t\t\t/*\n\t\t\t\t\telse\n\t\t\t\t\t\tdiff = 0;\n\t\t\t\t\t*/\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ((ent->mediaTime>=0) && ((u64) ent->mediaTime>=trak->Media->mediaHeader->duration)) {\n\t\t\t\tent->mediaTime = trak->Media->mediaHeader->duration;\n\t\t\t}\n\t\t\teditListDuration += ent->segmentDuration;\n\t\t}\n\t\ttrackDuration = editListDuration;\n\t}\n\tif (!trackDuration) {\n\t\ttrackDuration = (trak->Media->mediaHeader->duration * trak->moov->mvhd->timeScale) / trak->Media->mediaHeader->timeScale;\n\t}\n\ttrak->Header->duration = trackDuration;\n\n\treturn GF_OK;\n\n}\n\n\nGF_EXPORT\nGF_Err gf_isom_clone_pssh(GF_ISOFile *output, GF_ISOFile *input, Bool in_moof) {\n\tGF_Box *a;\n\tu32 i;\n\ti = 0;\n\n\twhile ((a = (GF_Box *)gf_list_enum(input->moov->child_boxes, &i))) {\n\t\tif (a->type == GF_ISOM_BOX_TYPE_PSSH) {\n\t\t\tGF_List **child_boxes = &output->moov->child_boxes;\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t\t\tif (in_moof)\n\t\t\t\tchild_boxes = &output->moof->child_boxes;\n#endif\n\n\t\t\tGF_ProtectionSystemHeaderBox *pssh = (GF_ProtectionSystemHeaderBox *)gf_isom_box_new_parent(child_boxes, GF_ISOM_BOX_TYPE_PSSH);\n\t\t\tif (!pssh) return GF_OUT_OF_MEM;\n\t\t\tmemmove(pssh->SystemID, ((GF_ProtectionSystemHeaderBox *)a)->SystemID, 16);\n\t\t\tif (((GF_ProtectionSystemHeaderBox *)a)->KIDs && ((GF_ProtectionSystemHeaderBox *)a)->KID_count > 0) {\n\t\t\t\tpssh->KID_count = ((GF_ProtectionSystemHeaderBox *)a)->KID_count;\n\t\t\t\tpssh->KIDs = (bin128 *)gf_malloc(pssh->KID_count*sizeof(bin128));\n\t\t\t\tif (!pssh->KIDs) return GF_OUT_OF_MEM;\n\t\t\t\tmemmove(pssh->KIDs, ((GF_ProtectionSystemHeaderBox *)a)->KIDs, pssh->KID_count*sizeof(bin128));\n\t\t\t}\n\t\t\tpssh->private_data_size = ((GF_ProtectionSystemHeaderBox *)a)->private_data_size;\n\t\t\tpssh->private_data = (u8 *)gf_malloc(pssh->private_data_size*sizeof(char));\n\t\t\tif (!pssh->private_data) return GF_OUT_OF_MEM;\n\t\t\tmemmove(pssh->private_data, ((GF_ProtectionSystemHeaderBox *)a)->private_data, pssh->private_data_size);\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_track_group(GF_ISOFile *file, u32 track_number, u32 track_group_id, u32 group_type, Bool do_add)\n{\n\tu32 i, j;\n\tGF_TrackGroupTypeBox *trgt;\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\n\te = CanAccessMovie(file, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(file, track_number);\n\tif (!trak) return GF_BAD_PARAM;\n\tif (!trak->groups) trak->groups = (GF_TrackGroupBox*) gf_isom_box_new_parent(&trak->child_boxes, GF_ISOM_BOX_TYPE_TRGR);\n\tif (!trak->groups) return GF_OUT_OF_MEM;\n\n\tfor (j=0; j<gf_list_count(file->moov->trackList); j++) {\n\t\tGF_TrackBox *a_trak = gf_list_get(file->moov->trackList, j);\n\t\tif (!a_trak->groups) continue;\n\n\t\tfor (i=0; i<gf_list_count(a_trak->groups->groups); i++) {\n\t\t\ttrgt = gf_list_get(a_trak->groups->groups, i);\n\n\t\t\tif (trgt->track_group_id==track_group_id) {\n\t\t\t\tif (trgt->group_type != group_type) {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"A track with same group ID is already defined for different group type %s\\n\", gf_4cc_to_str(trgt->group_type) ));\n\t\t\t\t\treturn GF_BAD_PARAM;\n\t\t\t\t}\n\t\t\t\tif (a_trak==trak) {\n\t\t\t\t\tif (!do_add) {\n\t\t\t\t\t\tgf_list_rem(trak->groups->groups, i);\n\t\t\t\t\t\tgf_isom_box_del_parent(&trak->groups->child_boxes, (GF_Box *)trgt);\n\t\t\t\t\t}\n\t\t\t\t\treturn GF_OK;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t//not found, add new group\n\ttrgt = (GF_TrackGroupTypeBox*) gf_isom_box_new_parent(&trak->groups->child_boxes, GF_ISOM_BOX_TYPE_TRGT);\n\tif (!trgt) return GF_OUT_OF_MEM;\n\ttrgt->track_group_id = track_group_id;\n\ttrgt->group_type = group_type;\n\treturn gf_list_add(trak->groups->groups, trgt);\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_nalu_length_field(GF_ISOFile *file, u32 track, u32 StreamDescriptionIndex, u32 nalu_size_length)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\tGF_SampleEntryBox *entry;\n\tGF_MPEGVisualSampleEntryBox *ve;\n\tGF_SampleDescriptionBox *stsd;\n\n\te = CanAccessMovie(file, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(file, track);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tstsd = trak->Media->information->sampleTable->SampleDescription;\n\tif (!stsd || !StreamDescriptionIndex || StreamDescriptionIndex > gf_list_count(stsd->child_boxes)) {\n\t\treturn GF_BAD_PARAM;\n\t}\n\n\tentry = (GF_SampleEntryBox *)gf_list_get(stsd->child_boxes, StreamDescriptionIndex - 1);\n\t//no support for generic sample entries (eg, no MPEG4 descriptor)\n\tif (!entry || ! gf_isom_is_nalu_based_entry(trak->Media, entry)) {\n\t\treturn GF_BAD_PARAM;\n\t}\n\n\tve = (GF_MPEGVisualSampleEntryBox*)entry;\n\tif (ve->avc_config) ve->avc_config->config->nal_unit_size = nalu_size_length;\n\tif (ve->svc_config) ve->svc_config->config->nal_unit_size = nalu_size_length;\n\tif (ve->hevc_config) ve->hevc_config->config->nal_unit_size = nalu_size_length;\n\tif (ve->lhvc_config) ve->lhvc_config->config->nal_unit_size = nalu_size_length;\n\treturn GF_OK;\n}\n\nGF_Err gf_isom_set_sample_group_in_traf(GF_ISOFile *file)\n{\n\tGF_Err e;\n\te = CanAccessMovie(file, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\tfile->sample_groups_in_traf = GF_TRUE;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nvoid gf_isom_set_progress_callback(GF_ISOFile *file, void (*progress_cbk)(void *udta, u64 nb_done, u64 nb_total), void *progress_cbk_udta)\n{\n\tif (file) {\n\t\tfile->progress_cbk = progress_cbk;\n\t\tfile->progress_cbk_udta = progress_cbk_udta;\n\n\t}\n}\n\nGF_Err gf_isom_update_video_sample_entry_fields(GF_ISOFile *file, u32 track, u32 stsd_idx, u16 revision, u32 vendor, u32 temporalQ, u32 spatialQ, u32 horiz_res, u32 vert_res, u16 frames_per_sample, const char *compressor_name, s16 color_table_index)\n{\n\n\tGF_TrackBox *trak;\n\tGF_MPEGVisualSampleEntryBox *vid_ent;\n\n\t/*get orig sample desc and clone it*/\n\ttrak = gf_isom_get_track_from_file(file, track);\n\tif (!trak || !stsd_idx) return GF_BAD_PARAM;\n\n\tif (!trak->Media || !trak->Media->handler || !trak->Media->information || !trak->Media->information->sampleTable || !trak->Media->information->sampleTable->SampleDescription)\n\t\treturn GF_ISOM_INVALID_FILE;\n\n\tswitch (trak->Media->handler->handlerType) {\n\tcase GF_ISOM_MEDIA_VISUAL:\n    case GF_ISOM_MEDIA_AUXV:\n    case GF_ISOM_MEDIA_PICT:\n    \tbreak;\n\tdefault:\n\t\treturn GF_BAD_PARAM;\n\t}\n\tvid_ent = gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, stsd_idx-1);\n\tif (!vid_ent)\n\t\treturn GF_BAD_PARAM;\n\n\tvid_ent->revision = revision;\n\tvid_ent->vendor = vendor;\n\tvid_ent->temporal_quality = temporalQ;\n\tvid_ent->spatial_quality = spatialQ;\n\tvid_ent->horiz_res = horiz_res;\n\tvid_ent->vert_res = vert_res;\n\tvid_ent->frames_per_sample = frames_per_sample;\n\tif (compressor_name)\n\t\tstrncpy(vid_ent->compressor_name, compressor_name, 32);\n\n\tvid_ent->color_table_index = color_table_index;\n\treturn GF_OK;\n}\n\n\nGF_Err gf_isom_update_sample_description_from_template(GF_ISOFile *file, u32 track, u32 sampleDescriptionIndex, u8 *data, u32 size)\n{\n\tGF_BitStream *bs;\n\tGF_TrackBox *trak;\n\tGF_Box *ent, *tpl_ent;\n\tGF_Err e;\n\t/*get orig sample desc and clone it*/\n\ttrak = gf_isom_get_track_from_file(file, track);\n\tif (!trak || !sampleDescriptionIndex) return GF_BAD_PARAM;\n\n\tif (!trak->Media || !trak->Media->handler || !trak->Media->information || !trak->Media->information->sampleTable || !trak->Media->information->sampleTable->SampleDescription)\n\t\treturn GF_ISOM_INVALID_FILE;\n\n\tent = gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, sampleDescriptionIndex-1);\n\tif (!ent) return GF_BAD_PARAM;\n\n\tbs = gf_bs_new(data, size, GF_BITSTREAM_READ);\n//\te = gf_isom_box_parse(&tpl_ent, bs);\n\te = gf_isom_box_parse_ex (&tpl_ent, bs, GF_ISOM_BOX_TYPE_STSD, GF_FALSE);\n\tgf_bs_del(bs);\n\tif (e) return e;\n\n\twhile (gf_list_count(tpl_ent->child_boxes)) {\n\t\tu32 j=0;\n\t\tBool found = GF_FALSE;\n\t\tGF_Box *abox = gf_list_pop_front(tpl_ent->child_boxes);\n\n\t\tswitch (abox->type) {\n\t\tcase GF_ISOM_BOX_TYPE_SINF:\n\t\tcase GF_ISOM_BOX_TYPE_RINF:\n\t\tcase GF_ISOM_BOX_TYPE_BTRT:\n\t\t\tfound = GF_TRUE;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (found) {\n\t\t\tgf_isom_box_del(abox);\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tif (!ent->child_boxes) ent->child_boxes = gf_list_new();\n\t\tfor (j=0; j<gf_list_count(ent->child_boxes); j++) {\n\t\t\tGF_Box *b = gf_list_get(ent->child_boxes, j);\n\t\t\tif (b->type == abox->type) {\n\t\t\t\tfound = GF_TRUE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!found) {\n\t\t\tgf_list_add(ent->child_boxes, abox);\n\t\t} else {\n\t\t\tgf_isom_box_del(abox);\n\t\t}\n\t}\n\tgf_isom_box_del(tpl_ent);\n\n\t//patch for old export\n\tGF_Box *abox = gf_isom_box_find_child(ent->child_boxes, GF_ISOM_BOX_TYPE_SINF);\n\tif (abox) {\n\t\tgf_list_del_item(ent->child_boxes, abox);\n\t\tgf_list_add(ent->child_boxes, abox);\n\t}\n\treturn GF_OK;\n}\n\n#include <gpac/xml.h>\nGF_EXPORT\nGF_Err gf_isom_apply_box_patch(GF_ISOFile *file, GF_ISOTrackID globalTrackID, const char *box_patch_filename, Bool for_fragments)\n{\n\tGF_Err e;\n\tGF_DOMParser *dom;\n\tu32 i;\n\tGF_XMLNode *root;\n\tu8 *box_data=NULL;\n\tu32 box_data_size;\n\tif (!file || !box_patch_filename) return GF_BAD_PARAM;\n\tdom = gf_xml_dom_new();\n\tif (strstr(box_patch_filename, \"<?xml\")) {\n\t\te = gf_xml_dom_parse_string(dom, (char *) box_patch_filename);\n\t} else {\n\t\te = gf_xml_dom_parse(dom, box_patch_filename, NULL, NULL);\n\t}\n\tif (e) goto err_exit;\n\n\troot = gf_xml_dom_get_root(dom);\n\tif (!root || strcmp(root->name, \"GPACBOXES\")) {\n\t\te = GF_NON_COMPLIANT_BITSTREAM;\n\t\tgoto err_exit;\n\t}\n\n\t//compute size of each child boxes to freeze the order\n\tif (for_fragments) {\n\t\tu32 count = file->moof ? gf_list_count(file->moof->child_boxes) : 0;\n\t\tfor (i=0; i<count; i++) {\n\t\t\tGF_Box *box = gf_list_get(file->moof->child_boxes, i);\n\t\t\tif (!(box->internal_flags & GF_ISOM_ORDER_FREEZE)) {\n\t\t\t\tgf_isom_box_size(box);\n\t\t\t\tgf_isom_box_freeze_order(box);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfor (i=0; i<gf_list_count(file->TopBoxes); i++) {\n\t\t\tGF_Box *box = gf_list_get(file->TopBoxes, i);\n\t\t\tif (!(box->internal_flags & GF_ISOM_ORDER_FREEZE)) {\n\t\t\t\tgf_isom_box_size(box);\n\t\t\t\tgf_isom_box_freeze_order(box);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (i=0; i<gf_list_count(root->content); i++) {\n\t\tu32 j;\n\t\tu32 path_len;\n\t\tBool essential_prop=GF_FALSE;\n\t\tu32 trackID=globalTrackID;\n\t\tu32 item_id=trackID;\n\t\tBool is_frag_box;\n\t\tchar *box_path=NULL;\n\t\tGF_Box *parent_box = NULL;\n\t\tGF_XMLNode *box_edit = gf_list_get(root->content, i);\n\t\tif (!box_edit->name || strcmp(box_edit->name, \"Box\")) continue;\n\n\t\tfor (j=0; j<gf_list_count(box_edit->attributes);j++) {\n\t\t\tGF_XMLAttribute *att = gf_list_get(box_edit->attributes, j);\n\t\t\tif (!strcmp(att->name, \"path\")) box_path = att->value;\n\t\t\telse if (!strcmp(att->name, \"essential\")) {\n\t\t\t\tif (!strcmp(att->value, \"yes\") || !strcmp(att->value, \"true\") || !strcmp(att->value, \"1\")) {\n\t\t\t\t\tessential_prop=GF_TRUE;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (!strcmp(att->name, \"itemID\"))\n\t\t\t\titem_id = atoi(att->value);\n\t\t\telse if (!globalTrackID && !strcmp(att->name, \"trackID\"))\n\t\t\t\ttrackID = atoi(att->value);\n\t\t}\n\n\t\tif (!box_path) continue;\n\t\tpath_len = (u32) strlen(box_path);\n\n\t\tis_frag_box = !strncmp(box_path, \"traf\", 4) ? GF_TRUE : GF_FALSE;\n\n\t\tif (for_fragments && !is_frag_box) continue;\n\t\telse if (!for_fragments && is_frag_box) continue;\n\n\t\tgf_xml_parse_bit_sequence(box_edit, box_patch_filename, &box_data, &box_data_size);\n\t\tif (box_data_size && (box_data_size<4) ) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[ISOBMFF] Wrong BS specification for box, shall either be empty or at least 4 bytes for box type\\n\"));\n\t\t\te = GF_NON_COMPLIANT_BITSTREAM;\n\t\t\tgoto err_exit;\n\t\t}\n\n\t\twhile (box_path && (path_len>=4)) {\n\t\t\tu32 parent_list_box_type;\n\t\t\tGF_List **parent_list;\n\t\t\tu32 box_type = GF_4CC(box_path[0],box_path[1],box_path[2],box_path[3]);\n\t\t\tGF_Box *box=NULL;\n\t\t\tGF_BitStream *bs;\n\t\t\ts32 insert_pos = -1;\n\t\t\tbox_path+=4;\n\t\t\tpath_len-=4;\n\n\t\t\tif (!parent_box) {\n\t\t\t\tbox=gf_isom_box_find_child(file->TopBoxes, box_type);\n\t\t\t\tif (!box) {\n\t\t\t\t\tif (box_type==GF_ISOM_BOX_TYPE_TRAK) {\n\t\t\t\t\t\tif (trackID) {\n\t\t\t\t\t\t\tbox = (GF_Box *) gf_isom_get_track_from_file(file, gf_isom_get_track_by_id(file, trackID) );\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!box && gf_list_count(file->moov->trackList)==1) {\n\t\t\t\t\t\t\tbox = gf_list_get(file->moov->trackList, 0);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if (box_type==GF_ISOM_BOX_TYPE_TRAF) {\n\t\t\t\t\t\tif (trackID) {\n\t\t\t\t\t\t\tbox = (GF_Box *) gf_isom_get_traf(file, trackID);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!box && file->moof && gf_list_count(file->moof->TrackList)==1) {\n\t\t\t\t\t\t\tbox = gf_list_get(file->moof->TrackList, 0);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!box) {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[ISOBMFF] Cannot locate box type %s at root or as track\\n\", gf_4cc_to_str(box_type) ));\n\t\t\t\t\te = GF_BAD_PARAM;\n\t\t\t\t\tgoto err_exit;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tbox = gf_isom_box_find_child(parent_box->child_boxes, box_type);\n\t\t\t\tif (!box) {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[ISOBMFF] Cannot locate box type %s at child of %s\\n\", gf_4cc_to_str(box_type), gf_4cc_to_str(parent_box->type)));\n\t\t\t\t\te = GF_BAD_PARAM;\n\t\t\t\t\tgoto err_exit;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// '.' is child access\n\t\t\tif (path_len && (box_path[0]=='.')) {\n\t\t\t\tbox_path += 1;\n\t\t\t\tpath_len-=1;\n\t\t\t\tparent_box = box;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (parent_box && !parent_box->child_boxes) parent_box->child_boxes = gf_list_new();\n\t\t\tparent_list = parent_box ? &parent_box->child_boxes : &file->TopBoxes;\n\t\t\tparent_list_box_type = parent_box ? parent_box->type : 0;\n\n\t\t\t// '+' is append after, '-' is insert before\n\t\t\tif (path_len && ((box_path[0]=='-') || (box_path[0]=='+')) ) {\n\t\t\t\ts32 idx = gf_list_find(*parent_list, box);\n\t\t\t\tassert(idx>=0);\n\t\t\t\tif (box_path[0]=='+') insert_pos = idx+1;\n\t\t\t\telse insert_pos = idx;\n\t\t\t}\n\t\t\telse if (path_len) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[ISOBMFF] Invalid path %s, expecting either '-', '+' or '.' as separators\\n\", box_path));\n\t\t\t\te = GF_NON_COMPLIANT_BITSTREAM;\n\t\t\t\tgoto err_exit;\n\t\t\t}\n\n\t\t\tif (!box_data) {\n\t\t\t\tif (insert_pos>=0) {\n\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[ISOBMFF] Invalid path %s for box removal, ignoring position\\n\", box_path));\n\t\t\t\t}\n\t\t\t\tswitch (box->type) {\n\t\t\t\tcase GF_ISOM_BOX_TYPE_MOOV:\n\t\t\t\t\tfile->moov = NULL;\n\t\t\t\t\tbreak;\n\t\t\t\tcase GF_ISOM_BOX_TYPE_MDAT:\n\t\t\t\t\tfile->mdat = NULL;\n\t\t\t\t\tbreak;\n\t\t\t\tcase GF_ISOM_BOX_TYPE_PDIN:\n\t\t\t\t\tfile->pdin = NULL;\n\t\t\t\t\tbreak;\n\t\t\t\tcase GF_ISOM_BOX_TYPE_FTYP:\n\t\t\t\t\tfile->brand = NULL;\n\t\t\t\t\tbreak;\n\t\t\t\tcase GF_ISOM_BOX_TYPE_META:\n\t\t\t\t\tif ((GF_Box *) file->meta == box) file->meta = NULL;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (parent_box) {\n\t\t\t\t\tgf_isom_box_remove_from_parent(parent_box, box);\n\t\t\t\t}\n\t\t\t\tgf_isom_box_del_parent(parent_list, box);\n\t\t\t} else {\n\t\t\t\tu32 size;\n\n\t\t\t\tbs = gf_bs_new(box_data, box_data_size, GF_BITSTREAM_READ);\n\t\t\t\tsize = gf_bs_read_u32(bs);\n\t\t\t\tif (size != box_data_size) {\n\t\t\t\t\tGF_UnknownBox *new_box = (GF_UnknownBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_UNKNOWN);\n\t\t\t\t\tnew_box->original_4cc = size;\n\t\t\t\t\tnew_box->dataSize = (u32) gf_bs_available(bs);\n\t\t\t\t\tnew_box->data = gf_malloc(sizeof(u8)*new_box->dataSize);\n\t\t\t\t\tgf_bs_read_data(bs, new_box->data, new_box->dataSize);\n\t\t\t\t\tif (insert_pos<0) {\n\t\t\t\t\t\tgf_list_add(box->child_boxes, new_box);\n\t\t\t\t\t\tinsert_pos = gf_list_find(box->child_boxes, new_box);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tgf_list_insert(*parent_list, new_box, insert_pos);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (parent_box && (parent_box->type==GF_ISOM_BOX_TYPE_IPRP)) {\n\t\t\t\t\t\tGF_ItemPropertyAssociationBox *ipma = (GF_ItemPropertyAssociationBox *) gf_isom_box_find_child(parent_box->child_boxes, GF_ISOM_BOX_TYPE_IPMA);\n\t\t\t\t\t\tif (!item_id) {\n\t\t\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[ISOBMFF] Inserting box in ipco without itemID, no association added\\n\"));\n\t\t\t\t\t\t} else if (ipma) {\n\t\t\t\t\t\t\tu32 nb_asso, k;\n\t\t\t\t\t\t\tGF_ItemPropertyAssociationEntry *entry = NULL;\n\t\t\t\t\t\t\tnb_asso = gf_list_count(ipma->entries);\n\t\t\t\t\t\t\tfor (k=0; k<nb_asso;k++) {\n\t\t\t\t\t\t\t\tentry = gf_list_get(ipma->entries, k);\n\t\t\t\t\t\t\t\tif (entry->item_id==item_id) break;\n\t\t\t\t\t\t\t\tentry = NULL;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (!entry) {\n\t\t\t\t\t\t\t\tGF_SAFEALLOC(entry, GF_ItemPropertyAssociationEntry);\n\t\t\t\t\t\t\t\tif (!entry) return GF_OUT_OF_MEM;\n\t\t\t\t\t\t\t\tgf_list_add(ipma->entries, entry);\n\t\t\t\t\t\t\t\tentry->item_id = item_id;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tentry->associations = gf_realloc(entry->associations, sizeof(GF_ItemPropertyAssociationSlot) * (entry->nb_associations+1));\n\t\t\t\t\t\t\tentry->associations[entry->nb_associations].essential = essential_prop;\n\t\t\t\t\t\t\tentry->associations[entry->nb_associations].index = 1+insert_pos;\n\t\t\t\t\t\t\tentry->nb_associations++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tu32 box_idx = 0;\n\n\t\t\t\t\tgf_bs_seek(bs, 0);\n\t\t\t\t\twhile (gf_bs_available(bs)) {\n\t\t\t\t\t\tGF_Box *new_box;\n\t\t\t\t\t\te = gf_isom_box_parse_ex(&new_box, bs, (insert_pos<0) ? box->type : parent_list_box_type, parent_box ? GF_FALSE : GF_TRUE);\n\t\t\t\t\t\tif (e) {\n\t\t\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[ISOBMFF] failed to parse box\\n\", box_path));\n\t\t\t\t\t\t\tgf_bs_del(bs);\n\t\t\t\t\t\t\tgoto err_exit;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (insert_pos<0) {\n\t\t\t\t\t\t\tgf_list_add(box->child_boxes, new_box);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tgf_list_insert(*parent_list, new_box, insert_pos+box_idx);\n\t\t\t\t\t\t\tbox_idx++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tgf_bs_del(bs);\n\n\t\t\t}\n\t\t\tgf_free(box_data);\n\t\t\tbox_data = NULL;\n\t\t\tbox_path = NULL;\n\t\t}\n\t}\n\nerr_exit:\n\n\tgf_xml_dom_del(dom);\n\tif (box_data) gf_free(box_data);\n\treturn e;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_track_magic(GF_ISOFile *movie, u32 trackNumber, u64 magic)\n{\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\ttrak->magic = magic;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_track_index(GF_ISOFile *movie, u32 trackNumber, u32 index, void (*track_num_changed)(void *udta, u32 old_track_num, u32 new_track_num), void *udta)\n{\n\tu32 i, count;\n\tGF_List *tracks;\n\tu32 prev_index=0, prev_pos=0;\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !index) return GF_BAD_PARAM;\n\ttrak->index = index;\n\ttracks = gf_list_new();\n\tcount = gf_list_count(movie->moov->trackList);\n\t//sort tracks in new list\n\tfor (i=0; i<count; i++) {\n\t\tGF_TrackBox *a_tk = gf_list_get(movie->moov->trackList, i);\n\t\tif (!a_tk->index) {\n\t\t\tgf_list_insert(tracks, a_tk, 0);\n\t\t} else if (a_tk->index < prev_index) {\n\t\t\tgf_list_insert(tracks, a_tk, prev_pos);\n\t\t} else {\n\t\t\tgf_list_add(tracks, a_tk);\n\t\t}\n\t\tprev_pos = gf_list_count(tracks) - 1;\n\t\tprev_index = a_tk->index;\n\t}\n\tif (gf_list_count(tracks) != count) {\n\t\tgf_list_del(tracks);\n\t\treturn GF_OUT_OF_MEM;\n\t}\n\tif (track_num_changed) {\n\t\tfor (i=0; i<count; i++) {\n\t\t\tGF_TrackBox *a_tk = gf_list_get(tracks, i);\n\t\t\ts32 old_pos = gf_list_find(movie->moov->trackList, a_tk);\n\t\t\tassert(old_pos>=0);\n\t\t\tif (old_pos != i)\n\t\t\t\ttrack_num_changed(udta, old_pos+1, i+1);\n\t\t}\n\t}\n\tgf_list_del(movie->moov->trackList);\n\tmovie->moov->trackList = tracks;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_ipod_compatible(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\tGF_Err e;\n\tGF_MPEGVisualSampleEntryBox *entry;\n\n\te = CanAccessMovie(the_file, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media) return GF_BAD_PARAM;\n\tentry = (GF_MPEGVisualSampleEntryBox*)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, 0);\n\tif (!entry) return GF_OK;\n\tswitch (entry->type) {\n\tcase GF_ISOM_BOX_TYPE_AVC1:\n\tcase GF_ISOM_BOX_TYPE_AVC2:\n\tcase GF_ISOM_BOX_TYPE_AVC3:\n\tcase GF_ISOM_BOX_TYPE_AVC4:\n\tcase GF_ISOM_BOX_TYPE_SVC1:\n\tcase GF_ISOM_BOX_TYPE_MVC1:\n\tcase GF_ISOM_BOX_TYPE_HVC1:\n\tcase GF_ISOM_BOX_TYPE_HEV1:\n\tcase GF_ISOM_BOX_TYPE_HVT1:\n\t\tbreak;\n\tdefault:\n\t\treturn GF_OK;\n\t}\n\n\tif (!entry->ipod_ext) {\n\t\tentry->ipod_ext = (GF_UnknownUUIDBox *) gf_isom_box_new_parent(&entry->child_boxes, GF_ISOM_BOX_TYPE_UUID);\n\t\tif (!entry->ipod_ext) return GF_OUT_OF_MEM;\n\t}\n\tmemcpy(entry->ipod_ext->uuid, GF_ISOM_IPOD_EXT, sizeof(u8)*16);\n\tentry->ipod_ext->dataSize = 4;\n\tentry->ipod_ext->data = gf_malloc(sizeof(u8)*4);\n\tif (!entry->ipod_ext->data) return GF_OUT_OF_MEM;\n\tmemset(entry->ipod_ext->data, 0, sizeof(u8)*4);\n\treturn GF_OK;\n}\n\nGF_EXPORT\nBool gf_isom_is_inplace_rewrite(GF_ISOFile *movie)\n{\n\tif (!movie) return GF_FALSE;\n\tif (!movie->no_inplace_rewrite) {\n\t\t//things where added to the file, no inplace rewrite\n\t\tif (movie->editFileMap && gf_bs_get_size(movie->editFileMap->bs))\n\t\t\tmovie->no_inplace_rewrite = GF_TRUE;\n\t\t//block redirect (used by mp4mx), no inplace rewrite\n\t\telse if (movie->on_block_out || !strcmp(movie->finalName, \"_gpac_isobmff_redirect\"))\n\t\t\tmovie->no_inplace_rewrite = GF_TRUE;\n\t\t//stdout redirect, no inplace rewrite\n\t\telse if (!strcmp(movie->finalName, \"std\"))\n\t\t\tmovie->no_inplace_rewrite = GF_TRUE;\n\t\t//new file, no inplace rewrite\n\t\telse if (!movie->fileName)\n\t\t\tmovie->no_inplace_rewrite = GF_TRUE;\n\t}\n\tif (movie->no_inplace_rewrite) return GF_FALSE;\n\n\treturn GF_TRUE;\n}\n\nGF_EXPORT\nvoid gf_isom_disable_inplace_rewrite(GF_ISOFile *movie)\n{\n\tif (movie)\n\t\tmovie->no_inplace_rewrite = GF_TRUE;\n}\n\n\nGF_Err gf_isom_set_y3d_info(GF_ISOFile *movie, u32 trackNumber, u32 sampleDescriptionIndex, GF_ISOM_Y3D_Info *info)\n{\n\tGF_Err e;\n\tu32 proj_type;\n\tGF_SampleEntryBox *ent;\n\tGF_TrackBox *trak;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !trak->Media || !info) return GF_BAD_PARAM;\n\n\tent = gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, sampleDescriptionIndex-1);\n\tif (!ent) return GF_BAD_PARAM;\n\n\tif (info->projection_type > GF_PROJ360_EQR) return GF_NOT_SUPPORTED;\n\n\tGF_Stereo3DBox *st3d = (GF_Stereo3DBox *) gf_isom_box_find_child(ent->child_boxes, GF_ISOM_BOX_TYPE_ST3D);\n\tif (st3d) {\n\t\tif (info->stereo_type) {\n\t\t\tst3d->stereo_type = info->stereo_type;\n\t\t} else {\n\t\t\tgf_isom_box_del_parent(&ent->child_boxes, (GF_Box *) st3d);\n\t\t}\n\t} else if (info->stereo_type) {\n\t\tst3d = (GF_Stereo3DBox *) gf_isom_box_new_parent(&ent->child_boxes, GF_ISOM_BOX_TYPE_ST3D);\n\t\tif (!st3d) return GF_OUT_OF_MEM;\n\t\tst3d->stereo_type = info->stereo_type;\n\t}\n\n\n\tGF_Box *sv3d = gf_isom_box_find_child(ent->child_boxes, GF_ISOM_BOX_TYPE_SV3D);\n\tif (sv3d && !info->projection_type) {\n\t\tgf_isom_box_del_parent(&ent->child_boxes, sv3d);\n\t\treturn GF_OK;\n\t}\n\n\tif (!sv3d && !info->projection_type) {\n\t\treturn GF_OK;\n\t}\n\tif (!sv3d) {\n\t\tsv3d = gf_isom_box_new_parent(&ent->child_boxes, GF_ISOM_BOX_TYPE_SV3D);\n\t\tif (!sv3d) return GF_OUT_OF_MEM;\n\t}\n\n\t//svhd mandatory\n\tGF_SphericalVideoInfoBox *svhd = (GF_SphericalVideoInfoBox *) gf_isom_box_find_child(sv3d->child_boxes, GF_ISOM_BOX_TYPE_SVHD);\n\tif (svhd) {\n\t\tif (svhd->string) gf_free(svhd->string);\n\t} else {\n\t\tsvhd = (GF_SphericalVideoInfoBox *) gf_isom_box_new_parent(&sv3d->child_boxes, GF_ISOM_BOX_TYPE_SVHD);\n\t\tif (!svhd) return GF_OUT_OF_MEM;\n\t}\n\tsvhd->string = gf_strdup(info->meta_data ? info->meta_data : \"\");\n\n\t//proj mandatory\n\tGF_Box *proj = gf_isom_box_find_child(sv3d->child_boxes, GF_ISOM_BOX_TYPE_PROJ);\n\tif (!proj) {\n\t\tproj = (GF_Box *) gf_isom_box_new_parent(&sv3d->child_boxes, GF_ISOM_BOX_TYPE_PROJ);\n\t\tif (!proj) return GF_OUT_OF_MEM;\n\t}\n\n\tGF_ProjectionHeaderBox *projh = (GF_ProjectionHeaderBox *) gf_isom_box_find_child(proj->child_boxes, GF_ISOM_BOX_TYPE_PRHD);\n\t//prj header mandatory\n\tif (!projh) {\n\t\tprojh = (GF_ProjectionHeaderBox *) gf_isom_box_new_parent(&proj->child_boxes, GF_ISOM_BOX_TYPE_PRHD);\n\t\tif (!projh) return GF_OUT_OF_MEM;\n\t}\n\tprojh->yaw = info->yaw;\n\tprojh->pitch = info->pitch;\n\tprojh->roll = info->roll;\n\n\tproj_type = (info->projection_type==GF_PROJ360_CUBE_MAP) ? GF_ISOM_BOX_TYPE_CBMP : GF_ISOM_BOX_TYPE_EQUI;\n\n\tGF_ProjectionTypeBox *projt = (GF_ProjectionTypeBox *) gf_isom_box_find_child(proj->child_boxes, proj_type);\n\tif (!projt) {\n\t\tprojt = (GF_ProjectionTypeBox *) gf_isom_box_new_parent(&proj->child_boxes, proj_type);\n\t\tif (!projt) return GF_OUT_OF_MEM;\n\t}\n\tif (info->projection_type==GF_PROJ360_CUBE_MAP) {\n\t\tprojt->layout = info->layout;\n\t\tprojt->padding = info->padding;\n\t} else {\n\t\tprojt->bounds_top = info->top;\n\t\tprojt->bounds_bottom = info->bottom;\n\t\tprojt->bounds_left = info->left;\n\t\tprojt->bounds_right = info->right;\n\t}\n\n\t//remove other ones\n\tGF_Box *b = gf_isom_box_new_parent(&proj->child_boxes, GF_ISOM_BOX_TYPE_MSHP);\n\tif (b) gf_isom_box_del_parent(&proj->child_boxes, b);\n\tif (info->projection_type==GF_PROJ360_CUBE_MAP) {\n\t\tb = gf_isom_box_new_parent(&proj->child_boxes, GF_ISOM_BOX_TYPE_EQUI);\n\t\tif (b) gf_isom_box_del_parent(&proj->child_boxes, b);\n\t} else {\n\t\tb = gf_isom_box_new_parent(&proj->child_boxes, GF_ISOM_BOX_TYPE_EQUI);\n\t\tif (b) gf_isom_box_del_parent(&proj->child_boxes, b);\n\n\t}\n\treturn GF_OK;\n}\n\n\n#endif\t/*!defined(GPAC_DISABLE_ISOM) && !defined(GPAC_DISABLE_ISOM_WRITE)*/\n", "/*\n *\t\t\tGPAC - Multimedia Framework C SDK\n *\n *\t\t\tAuthors: Jean Le Feuvre\n *\t\t\tCopyright (c) Telecom ParisTech 2000-2012\n *\t\t\t\t\tAll rights reserved\n *\n *  This file is part of GPAC / Media Tools sub-project\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n#include <gpac/internal/media_dev.h>\n#include <gpac/base_coding.h>\n#include <gpac/mpeg4_odf.h>\n#include <gpac/constants.h>\n#include <gpac/maths.h>\n#include <gpac/internal/ietf_dev.h>\n\n#ifndef GPAC_DISABLE_ISOM\n\nvoid gf_media_get_sample_average_infos(GF_ISOFile *file, u32 Track, u32 *avgSize, u32 *MaxSize, u32 *TimeDelta, u32 *maxCTSDelta, u32 *const_duration, u32 *bandwidth)\n{\n\tu32 i, count, ts_diff;\n\tu64 prevTS, tdelta;\n\tDouble bw;\n\tGF_ISOSample *samp;\n\n\t*avgSize = *MaxSize = 0;\n\t*TimeDelta = 0;\n\t*maxCTSDelta = 0;\n\tbw = 0;\n\tprevTS = 0;\n\ttdelta = 0;\n\n\tcount = gf_isom_get_sample_count(file, Track);\n\tif (!count) return;\n\t*const_duration = 0;\n\n\tfor (i=0; i<count; i++) {\n\t\tsamp = gf_isom_get_sample_info(file, Track, i+1, NULL, NULL);\n\t\tif (!samp) break;\n\t\t\n\t\t//get the size\n\t\t*avgSize += samp->dataLength;\n\t\tif (*MaxSize < samp->dataLength) *MaxSize = samp->dataLength;\n\t\tts_diff = (u32) (samp->DTS+samp->CTS_Offset - prevTS);\n\t\t//get the time\n\t\ttdelta += ts_diff;\n\n\t\tif (i==1) {\n\t\t\t*const_duration = ts_diff;\n\t\t} else if ( (i<count-1) && (*const_duration != ts_diff) ) {\n\t\t\t*const_duration = 0;\n\t\t}\n\n\t\tprevTS = samp->DTS+samp->CTS_Offset;\n\t\tbw += 8*samp->dataLength;\n\n\t\t//get the CTS delta\n\t\tif ((samp->CTS_Offset>=0) && ((u32)samp->CTS_Offset > *maxCTSDelta))\n\t\t\t*maxCTSDelta = samp->CTS_Offset;\n\t\tgf_isom_sample_del(&samp);\n\t}\n\tif (count>1) *TimeDelta = (u32) (tdelta/ (count-1) );\n\telse *TimeDelta = (u32) tdelta;\n\t*avgSize /= count;\n\tbw *= gf_isom_get_media_timescale(file, Track);\n\tbw /= (s64) gf_isom_get_media_duration(file, Track);\n\tbw /= 1000;\n\t(*bandwidth) = (u32) (bw+0.5);\n\n\t//delta is NOT an average, we need to know exactly how many bits are\n\t//needed to encode CTS-DTS for ANY samples\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_HINTING\n\n/*RTP track hinter*/\nstruct __tag_isom_hinter\n{\n\tGF_ISOFile *file;\n\t/*IDs are kept for mp4 hint sample building*/\n\tu32 TrackNum, TrackID, HintTrack, HintID;\n\t/*current Hint sample and associated RTP time*/\n\tu32 HintSample, RTPTime;\n\n\t/*track has composition time offset*/\n\tBool has_ctts;\n\t/*remember if first SL packet in RTP packet is RAP*/\n\tu8 SampleIsRAP;\n\tu32 base_offset_in_sample;\n\tu32 OrigTimeScale;\n\t/*rtp builder*/\n\tGP_RTPPacketizer *rtp_p;\n\n\tu32 bandwidth, nb_chan;\n\n\t/*NALU size for H264/AVC*/\n\tu32 avc_nalu_size;\n\n\t/*stats*/\n\tu32 TotalSample, CurrentSample;\n};\n\n\n/*\n\toffset for group ID for hint tracks in SimpleAV mode when all media data\n\tis copied to the hint track (no use interleaving hint and original in this case)\n\tthis offset is applied internally by the track hinter. Thus you shouldn't\n\tspecify a GroupID >= OFFSET_HINT_GROUP_ID if you want the lib to perform efficient\n\tinterleaving in any cases (referenced or copied media)\n*/\n#define OFFSET_HINT_GROUP_ID\t0x8000\n\nvoid InitSL_RTP(GF_SLConfig *slc)\n{\n\tmemset(slc, 0, sizeof(GF_SLConfig));\n\tslc->tag = GF_ODF_SLC_TAG;\n\tslc->useTimestampsFlag = 1;\n\tslc->timestampLength = 32;\n}\n\nvoid InitSL_NULL(GF_SLConfig *slc)\n{\n\tmemset(slc, 0, sizeof(GF_SLConfig));\n\tslc->tag = GF_ODF_SLC_TAG;\n\tslc->predefined = 0x01;\n}\n\n\n\nvoid MP4T_OnPacketDone(void *cbk, GF_RTPHeader *header)\n{\n\tu8 disposable;\n\tGF_RTPHinter *tkHint = (GF_RTPHinter *)cbk;\n\tif (!tkHint || !tkHint->HintSample) return;\n\tassert(header->TimeStamp == tkHint->RTPTime);\n\n\tdisposable = 0;\n\tif (tkHint->avc_nalu_size) {\n\t\tdisposable = tkHint->rtp_p->avc_non_idr ? 1 : 0;\n\t}\n\t/*for all other, assume that CTS=DTS means B-frame -> disposable*/\n\telse if (tkHint->has_ctts && (tkHint->rtp_p->sl_header.compositionTimeStamp==tkHint->rtp_p->sl_header.decodingTimeStamp)) {\n\t\tdisposable = 1;\n\t}\n\n\tgf_isom_rtp_packet_set_flags(tkHint->file, tkHint->HintTrack, 0, 0, header->Marker, disposable, 0);\n}\n\n\nvoid MP4T_OnDataRef(void *cbk, u32 payload_size, u32 offset_from_orig)\n{\n\tGF_RTPHinter *tkHint = (GF_RTPHinter *)cbk;\n\tif (!tkHint || !payload_size) return;\n\n\t/*add reference*/\n\tgf_isom_hint_sample_data(tkHint->file, tkHint->HintTrack, tkHint->TrackID,\n\t                         tkHint->CurrentSample, (u16) payload_size, offset_from_orig + tkHint->base_offset_in_sample,\n\t                         NULL, 0);\n}\n\nvoid MP4T_OnData(void *cbk, u8 *data, u32 data_size, Bool is_header)\n{\n\tu8 at_begin;\n\tGF_RTPHinter *tkHint = (GF_RTPHinter *)cbk;\n\tif (!data_size) return;\n\n\tat_begin = is_header ? 1 : 0;\n\tif (data_size <= 14) {\n\t\tgf_isom_hint_direct_data(tkHint->file, tkHint->HintTrack, data, data_size, at_begin);\n\t} else {\n\t\tgf_isom_hint_sample_data(tkHint->file, tkHint->HintTrack, tkHint->HintID, 0, (u16) data_size, 0, data, at_begin);\n\t}\n}\n\n\nvoid MP4T_OnNewPacket(void *cbk, GF_RTPHeader *header)\n{\n\ts32 res;\n\tGF_RTPHinter *tkHint = (GF_RTPHinter *)cbk;\n\tif (!tkHint) return;\n\n\tres = (s32) (tkHint->rtp_p->sl_header.compositionTimeStamp - tkHint->rtp_p->sl_header.decodingTimeStamp);\n\tassert( !res || tkHint->has_ctts);\n\t/*do we need a new sample*/\n\tif (!tkHint->HintSample || (tkHint->RTPTime != header->TimeStamp)) {\n\t\t/*close current sample*/\n\t\tif (tkHint->HintSample) gf_isom_end_hint_sample(tkHint->file, tkHint->HintTrack, tkHint->SampleIsRAP);\n\n\t\t/*start new sample: We use DTS as the sampling instant (RTP TS) to make sure\n\t\tall packets are sent in order*/\n\t\tgf_isom_begin_hint_sample(tkHint->file, tkHint->HintTrack, 1, header->TimeStamp-res);\n\t\ttkHint->HintSample ++;\n\t\ttkHint->RTPTime = header->TimeStamp;\n\t\ttkHint->SampleIsRAP = tkHint->rtp_p->sl_config.hasRandomAccessUnitsOnlyFlag ? 1 : tkHint->rtp_p->sl_header.randomAccessPointFlag;\n\t}\n\t/*create an RTP Packet with the appropriated marker flag - note: the flags are temp ones,\n\tthey are set when the full packet is signaled (to handle multi AUs per RTP)*/\n\tgf_isom_rtp_packet_begin(tkHint->file, tkHint->HintTrack, 0, 0, 0, header->Marker, header->PayloadType, 0, 0, header->SequenceNumber);\n\t/*Add the delta TS to make sure RTP TS is indeed the CTS (sampling time)*/\n\tif (res) gf_isom_rtp_packet_set_offset(tkHint->file, tkHint->HintTrack, res);\n}\n\n\nGF_EXPORT\nGF_RTPHinter *gf_hinter_track_new(GF_ISOFile *file, u32 TrackNum,\n                                  u32 Path_MTU, u32 max_ptime, u32 default_rtp_rate, u32 flags, u8 PayloadID,\n                                  Bool copy_media, u32 InterleaveGroupID, u8 InterleaveGroupPriority, GF_Err *e)\n{\n\n\tGF_SLConfig my_sl;\n\tu32 descIndex, MinSize, MaxSize, avgTS, streamType, codecid, const_dur, nb_ch, maxDTSDelta;\n\tu8 OfficialPayloadID;\n\tu32 TrackMediaSubType, TrackMediaType, hintType, nbEdts, required_rate, force_dts_delta, avc_nalu_size, PL_ID, bandwidth, IV_length, KI_length;\n\tconst char *url, *urn;\n\tchar *mpeg4mode;\n\tBool is_crypted, has_mpeg4_mapping;\n\tGF_RTPHinter *tmp;\n\tGF_ESD *esd;\n\n\t*e = GF_BAD_PARAM;\n\tif (!file || !TrackNum || !gf_isom_get_track_id(file, TrackNum)) return NULL;\n\n\tif (!gf_isom_get_sample_count(file, TrackNum)) {\n\t\t*e = GF_OK;\n\t\treturn NULL;\n\t}\n\t*e = GF_NOT_SUPPORTED;\n\tnbEdts = gf_isom_get_edits_count(file, TrackNum);\n\tif (nbEdts>1) {\n\t\tu64 et, sd, mt;\n\t\tGF_ISOEditType em;\n\t\tgf_isom_get_edit(file, TrackNum, 1, &et, &sd, &mt, &em);\n\t\tif ((nbEdts>2) || (em!=GF_ISOM_EDIT_EMPTY)) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_RTP, (\"[rtp hinter] Cannot hint track whith EditList\\n\"));\n\t\t\treturn NULL;\n\t\t}\n\t}\n\tif (nbEdts) gf_isom_remove_edits(file, TrackNum);\n\n\tif (!gf_isom_is_track_enabled(file, TrackNum)) return NULL;\n\n\t/*by default NO PL signaled*/\n\tPL_ID = 0;\n\tOfficialPayloadID = 0;\n\tforce_dts_delta = 0;\n\tstreamType = 0;\n\tmpeg4mode = NULL;\n\trequired_rate = 0;\n\tis_crypted = 0;\n\tIV_length = KI_length = 0;\n\tcodecid = 0;\n\tnb_ch = 0;\n\tavc_nalu_size = 0;\n\thas_mpeg4_mapping = 1;\n\tconst_dur = 0;\n\tbandwidth=0;\n\tTrackMediaType = gf_isom_get_media_type(file, TrackNum);\n\n\t/*for max compatibility with QT*/\n\tif (!default_rtp_rate) default_rtp_rate = 90000;\n\n\t/*timed-text is a bit special, we support multiple stream descriptions & co*/\n\tif ( (TrackMediaType==GF_ISOM_MEDIA_TEXT) || (TrackMediaType==GF_ISOM_MEDIA_SUBT)) {\n\t\thintType = GF_RTP_PAYT_3GPP_TEXT;\n\t\tcodecid = GF_CODECID_TEXT_MPEG4;\n\t\tstreamType = GF_STREAM_TEXT;\n\t\t/*fixme - this works cos there's only one PL for text in mpeg4 at the current time*/\n\t\tPL_ID = 0x10;\n\t} else {\n\t\tif (gf_isom_get_sample_description_count(file, TrackNum) > 1) return NULL;\n\n\t\tTrackMediaSubType = gf_isom_get_media_subtype(file, TrackNum, 1);\n\t\tswitch (TrackMediaSubType) {\n\t\tcase GF_ISOM_SUBTYPE_MPEG4_CRYP:\n\t\t\tis_crypted = 1;\n\t\tcase GF_ISOM_SUBTYPE_MPEG4:\n\t\t\tesd = gf_isom_get_esd(file, TrackNum, 1);\n\t\t\thintType = GF_RTP_PAYT_MPEG4;\n\t\t\tif (esd && esd->decoderConfig) {\n\t\t\t\tstreamType = esd->decoderConfig->streamType;\n\t\t\t\tcodecid = esd->decoderConfig->objectTypeIndication;\n\t\t\t\tif (esd->URLString) hintType = 0;\n\t\t\t\t/*AAC*/\n\t\t\t\tif ((streamType==GF_STREAM_AUDIO)\n\t\t\t\t\t&& esd->decoderConfig->decoderSpecificInfo && esd->decoderConfig->decoderSpecificInfo->data\n\t\t\t\t        /*(nb: we use mpeg4 for MPEG-2 AAC)*/\n\t\t\t\t        && ((codecid==GF_CODECID_AAC_MPEG4) || (codecid==GF_CODECID_AAC_MPEG2_MP) || (codecid==GF_CODECID_AAC_MPEG2_LCP) || (codecid==GF_CODECID_AAC_MPEG2_SSRP)) ) {\n\n\t\t\t\t\tu32 sample_rate;\n\t\t\t\t\tGF_M4ADecSpecInfo a_cfg;\n\t\t\t\t\tgf_m4a_get_config(esd->decoderConfig->decoderSpecificInfo->data, esd->decoderConfig->decoderSpecificInfo->dataLength, &a_cfg);\n\t\t\t\t\tnb_ch = a_cfg.nb_chan;\n\t\t\t\t\tsample_rate = a_cfg.base_sr;\n\t\t\t\t\tPL_ID = a_cfg.audioPL;\n\t\t\t\t\tswitch (a_cfg.base_object_type) {\n\t\t\t\t\tcase GF_M4A_AAC_MAIN:\n\t\t\t\t\tcase GF_M4A_AAC_LC:\n\t\t\t\t\t\tif (flags & GP_RTP_PCK_USE_LATM_AAC) {\n\t\t\t\t\t\t\thintType = GF_RTP_PAYT_LATM;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\tcase GF_M4A_AAC_SBR:\n\t\t\t\t\tcase GF_M4A_AAC_PS:\n\t\t\t\t\tcase GF_M4A_AAC_LTP:\n\t\t\t\t\tcase GF_M4A_AAC_SCALABLE:\n\t\t\t\t\tcase GF_M4A_ER_AAC_LC:\n\t\t\t\t\tcase GF_M4A_ER_AAC_LTP:\n\t\t\t\t\tcase GF_M4A_ER_AAC_SCALABLE:\n\t\t\t\t\t\tmpeg4mode = \"AAC\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase GF_M4A_CELP:\n\t\t\t\t\tcase GF_M4A_ER_CELP:\n\t\t\t\t\t\tmpeg4mode = \"CELP\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\trequired_rate = sample_rate;\n\t\t\t\t}\n\t\t\t\t/*MPEG1/2 audio*/\n\t\t\t\telse if ((streamType==GF_STREAM_AUDIO) && ((codecid==GF_CODECID_MPEG2_PART3) || (codecid==GF_CODECID_MPEG_AUDIO))) {\n\t\t\t\t\tGF_ISOSample *samp = NULL;\n\t\t\t\t\tif (!is_crypted)\n\t\t\t\t\t\t samp = gf_isom_get_sample(file, TrackNum, 1, NULL);\n\n\t\t\t\t\tif (samp && (samp->dataLength>3)) {\n\t\t\t\t\t\tu32 hdr = GF_4CC((u32)samp->data[0], (u8)samp->data[1], (u8)samp->data[2], (u8)samp->data[3]);\n\t\t\t\t\t\tnb_ch = gf_mp3_num_channels(hdr);\n\t\t\t\t\t\thintType = GF_RTP_PAYT_MPEG12_AUDIO;\n\t\t\t\t\t\t/*use official RTP/AVP payload type*/\n\t\t\t\t\t\tOfficialPayloadID = 14;\n\t\t\t\t\t\trequired_rate = 90000;\n\t\t\t\t\t}\n\t\t\t\t\t/*encrypted MP3 must be sent through MPEG-4 generic to signal all ISMACryp stuff*/\n\t\t\t\t\telse {\n\t\t\t\t\t\tu32 sample_rate;\n\t\t\t\t\t\tgf_isom_get_audio_info(file, TrackNum, 1, &sample_rate, &nb_ch, NULL);\n\t\t\t\t\t\trequired_rate = sample_rate;\n\t\t\t\t\t}\n\t\t\t\t\tif (samp)\n\t\t\t\t\t\tgf_isom_sample_del(&samp);\n\n\t\t\t\t}\n\t\t\t\t/*QCELP audio*/\n\t\t\t\telse if ((streamType==GF_STREAM_AUDIO) && (codecid==GF_CODECID_QCELP)) {\n\t\t\t\t\thintType = GF_RTP_PAYT_QCELP;\n\t\t\t\t\tOfficialPayloadID = 12;\n\t\t\t\t\trequired_rate = 8000;\n\t\t\t\t\tstreamType = GF_STREAM_AUDIO;\n\t\t\t\t\tnb_ch = 1;\n\t\t\t\t}\n\t\t\t\t/*EVRC/SVM audio*/\n\t\t\t\telse if ((streamType==GF_STREAM_AUDIO) && ((codecid==GF_CODECID_EVRC) || (codecid==GF_CODECID_SMV)) ) {\n\t\t\t\t\thintType = GF_RTP_PAYT_EVRC_SMV;\n\t\t\t\t\trequired_rate = 8000;\n\t\t\t\t\tstreamType = GF_STREAM_AUDIO;\n\t\t\t\t\tnb_ch = 1;\n\t\t\t\t}\n\t\t\t\t/*visual streams*/\n\t\t\t\telse if (streamType==GF_STREAM_VISUAL) {\n\t\t\t\t\tif ((codecid==GF_CODECID_MPEG4_PART2) && esd->decoderConfig->decoderSpecificInfo) {\n\t\t\t\t\t\tGF_M4VDecSpecInfo dsi;\n\t\t\t\t\t\tgf_m4v_get_config(esd->decoderConfig->decoderSpecificInfo->data, esd->decoderConfig->decoderSpecificInfo->dataLength, &dsi);\n\t\t\t\t\t\tPL_ID = dsi.VideoPL;\n\t\t\t\t\t}\n\t\t\t\t\t/*MPEG1/2 video*/\n\t\t\t\t\tif ( ((codecid>=GF_CODECID_MPEG2_SIMPLE) && (codecid<=GF_CODECID_MPEG2_422)) || (codecid==GF_CODECID_MPEG1)) {\n\t\t\t\t\t\tif (!is_crypted) {\n\t\t\t\t\t\t\thintType = GF_RTP_PAYT_MPEG12_VIDEO;\n\t\t\t\t\t\t\tOfficialPayloadID = 32;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t/*for ISMA*/\n\t\t\t\t\tif (is_crypted) {\n\t\t\t\t\t\t/*that's another pain with ISMACryp, even if no B-frames the DTS is signaled...*/\n\t\t\t\t\t\tif (codecid==GF_CODECID_MPEG4_PART2) force_dts_delta = 22;\n\t\t\t\t\t\telse if ((codecid==GF_CODECID_AVC) || (codecid==GF_CODECID_SVC)) {\n\t\t\t\t\t\t\tflags &= ~GP_RTP_PCK_USE_MULTI;\n\t\t\t\t\t\t\tforce_dts_delta = 22;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tflags |= GP_RTP_PCK_SIGNAL_RAP | GP_RTP_PCK_SIGNAL_TS;\n\t\t\t\t\t}\n\n\t\t\t\t\trequired_rate = default_rtp_rate;\n\t\t\t\t}\n\t\t\t\t/*systems streams*/\n\t\t\t\telse if (gf_isom_has_sync_shadows(file, TrackNum) || gf_isom_has_sample_dependency(file, TrackNum)) {\n\t\t\t\t\tflags |= GP_RTP_PCK_SYSTEMS_CAROUSEL;\n\t\t\t\t}\n\t\t\t\tgf_odf_desc_del((GF_Descriptor*)esd);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GF_ISOM_SUBTYPE_3GP_H263:\n\t\t\thintType = GF_RTP_PAYT_H263;\n\t\t\trequired_rate = 90000;\n\t\t\tstreamType = GF_STREAM_VISUAL;\n\t\t\tOfficialPayloadID = 34;\n\t\t\t/*not 100% compliant (short header is missing) but should still work*/\n\t\t\tcodecid = GF_CODECID_MPEG4_PART2;\n\t\t\tPL_ID = 0x01;\n\t\t\tbreak;\n\t\tcase GF_ISOM_SUBTYPE_3GP_AMR:\n\t\t\trequired_rate = 8000;\n\t\t\thintType = GF_RTP_PAYT_AMR;\n\t\t\tstreamType = GF_STREAM_AUDIO;\n\t\t\thas_mpeg4_mapping = 0;\n\t\t\tnb_ch = 1;\n\t\t\tbreak;\n\t\tcase GF_ISOM_SUBTYPE_3GP_AMR_WB:\n\t\t\trequired_rate = 16000;\n\t\t\thintType = GF_RTP_PAYT_AMR_WB;\n\t\t\tstreamType = GF_STREAM_AUDIO;\n\t\t\thas_mpeg4_mapping = 0;\n\t\t\tnb_ch = 1;\n\t\t\tbreak;\n\t\tcase GF_ISOM_SUBTYPE_AVC_H264:\n\t\tcase GF_ISOM_SUBTYPE_AVC2_H264:\n\t\tcase GF_ISOM_SUBTYPE_AVC3_H264:\n\t\tcase GF_ISOM_SUBTYPE_AVC4_H264:\n\t\tcase GF_ISOM_SUBTYPE_SVC_H264:\n\t\tcase GF_ISOM_SUBTYPE_MVC_H264:\n\t\t{\n\t\t\tGF_AVCConfig *avcc = gf_isom_avc_config_get(file, TrackNum, 1);\n\t\t\tGF_AVCConfig *svcc = gf_isom_svc_config_get(file, TrackNum, 1);\n\t\t\tGF_AVCConfig *mvcc = gf_isom_mvc_config_get(file, TrackNum, 1);\n\n\t\t\tif (!avcc && !svcc && !mvcc) {\n\t\t\t\t*e = GF_NON_COMPLIANT_BITSTREAM;\n\t\t\t\treturn NULL;\n\t\t\t}\n\n\t\t\trequired_rate = 90000;\t/* \"90 kHz clock rate MUST be used\"*/\n\t\t\thintType = GF_RTP_PAYT_H264_AVC;\n\t\t\tif (TrackMediaSubType==GF_ISOM_SUBTYPE_SVC_H264)\n\t\t\t\thintType = GF_RTP_PAYT_H264_SVC;\n\t\t\telse if (TrackMediaSubType==GF_ISOM_SUBTYPE_MVC_H264)\n\t\t\t\thintType = GF_RTP_PAYT_H264_SVC;\n\t\t\tstreamType = GF_STREAM_VISUAL;\n\t\t\tavc_nalu_size = avcc ? avcc->nal_unit_size : svcc ? svcc->nal_unit_size : mvcc->nal_unit_size;\n\t\t\tcodecid = GF_CODECID_AVC;\n\t\t\tPL_ID = 0x0F;\n\t\t\tgf_odf_avc_cfg_del(avcc);\n\t\t\tgf_odf_avc_cfg_del(svcc);\n\t\t}\n\t\tbreak;\n\t\tcase GF_ISOM_SUBTYPE_HVC1:\n\t\tcase GF_ISOM_SUBTYPE_HEV1:\n\t\tcase GF_ISOM_SUBTYPE_HVC2:\n\t\tcase GF_ISOM_SUBTYPE_HEV2:\n\t\t{\n\t\t\tGF_HEVCConfig *hevcc = gf_isom_hevc_config_get(file, TrackNum, 1);\n\t\t\tif (!hevcc) {\n\t\t\t\t*e = GF_NON_COMPLIANT_BITSTREAM;\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\trequired_rate = 90000;\t/* \"90 kHz clock rate MUST be used\"*/\n\t\t\thintType = GF_RTP_PAYT_HEVC;\n\t\t\tstreamType = GF_STREAM_VISUAL;\n\t\t\tavc_nalu_size = hevcc->nal_unit_size;\n\t\t\tcodecid = GF_CODECID_HEVC;\n\t\t\tPL_ID = 0x0F;\n\t\t\tflags |= GP_RTP_PCK_USE_MULTI;\n\t\t\tgf_odf_hevc_cfg_del(hevcc);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t\tcase GF_ISOM_SUBTYPE_3GP_QCELP:\n\t\t\trequired_rate = 8000;\n\t\t\thintType = GF_RTP_PAYT_QCELP;\n\t\t\tstreamType = GF_STREAM_AUDIO;\n\t\t\tcodecid = GF_CODECID_QCELP;\n\t\t\tOfficialPayloadID = 12;\n\t\t\tnb_ch = 1;\n\t\t\tbreak;\n\t\tcase GF_ISOM_SUBTYPE_3GP_EVRC:\n\t\tcase GF_ISOM_SUBTYPE_3GP_SMV:\n\t\t\trequired_rate = 8000;\n\t\t\thintType = GF_RTP_PAYT_EVRC_SMV;\n\t\t\tstreamType = GF_STREAM_AUDIO;\n\t\t\tcodecid = (TrackMediaSubType==GF_ISOM_SUBTYPE_3GP_EVRC) ? GF_CODECID_EVRC : GF_CODECID_SMV;\n\t\t\tnb_ch = 1;\n\t\t\tbreak;\n\t\tcase GF_ISOM_SUBTYPE_3GP_DIMS:\n#if GPAC_ENABLE_3GPP_DIMS_RTP\n\t\t\thintType = GF_RTP_PAYT_3GPP_DIMS;\n\t\t\tstreamType = GF_STREAM_SCENE;\n#else\n\t\t\thintType = 0;\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_RTP, (\"[RTP Packetizer] 3GPP DIMS over RTP disabled in build\\n\", streamType));\n#endif\n\t\t\tbreak;\n\t\tcase GF_ISOM_SUBTYPE_AC3:\n\t\t\thintType = GF_RTP_PAYT_AC3;\n\t\t\tstreamType = GF_STREAM_AUDIO;\n\t\t\tgf_isom_get_audio_info(file, TrackNum, 1, NULL, &nb_ch, NULL);\n\t\t\tbreak;\n\t\tcase GF_ISOM_SUBTYPE_MP3:\n\t\t{\n\t\t\tGF_ISOSample *samp = gf_isom_get_sample(file, TrackNum, 1, NULL);\n\t\t\tif (samp && (samp->dataLength>3)) {\n\t\t\t\tu32 hdr = GF_4CC((u32)samp->data[0], (u8)samp->data[1], (u8)samp->data[2], (u8)samp->data[3]);\n\t\t\t\tnb_ch = gf_mp3_num_channels(hdr);\n\t\t\t} else {\n\t\t\t\tu32 bps;\n\t\t\t\tgf_isom_get_audio_info(file, TrackNum, 1, &required_rate, &nb_ch, &bps);\n\t\t\t}\n\t\t\thintType = GF_RTP_PAYT_MPEG12_AUDIO;\n\t\t\t/*use official RTP/AVP payload type*/\n\t\t\tOfficialPayloadID = 14;\n\t\t\trequired_rate = 90000;\n\n\t\t\tif (samp)\n\t\t\t\tgf_isom_sample_del(&samp);\n\t\t}\n\t\tbreak;\n\t\tdefault:\n\t\t\t/*ERROR*/\n\t\t\thintType = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/*not hintable*/\n\tif (!hintType) return NULL;\n\t/*we only support self-contained files for hinting*/\n\tgf_isom_get_data_reference(file, TrackNum, 1, &url, &urn);\n\tif (url || urn) return NULL;\n\n\t*e = GF_OUT_OF_MEM;\n\tGF_SAFEALLOC(tmp, GF_RTPHinter);\n\tif (!tmp) return NULL;\n\n\t/*override hinter type if requested and possible*/\n\tif (has_mpeg4_mapping && (flags & GP_RTP_PCK_FORCE_MPEG4)) {\n\t\thintType = GF_RTP_PAYT_MPEG4;\n\t\tavc_nalu_size = 0;\n\t}\n\t/*use static payload ID if enabled*/\n\telse if (OfficialPayloadID && (flags & GP_RTP_PCK_USE_STATIC_ID) ) {\n\t\tPayloadID = OfficialPayloadID;\n\t}\n\n\ttmp->file = file;\n\ttmp->TrackNum = TrackNum;\n\ttmp->avc_nalu_size = avc_nalu_size;\n\ttmp->nb_chan = nb_ch;\n\n\t/*spatial scalability check*/\n\ttmp->has_ctts = gf_isom_has_time_offset(file, TrackNum);\n\n\t/*get sample info*/\n\tgf_media_get_sample_average_infos(file, TrackNum, &MinSize, &MaxSize, &avgTS, &maxDTSDelta, &const_dur, &bandwidth);\n\n\t/*systems carousel: we need at least IDX and RAP signaling*/\n\tif (flags & GP_RTP_PCK_SYSTEMS_CAROUSEL) {\n\t\tflags |= GP_RTP_PCK_SIGNAL_RAP;\n\t}\n\n\t/*update flags in MultiSL*/\n\tif (flags & GP_RTP_PCK_USE_MULTI) {\n\t\tif (MinSize != MaxSize) flags |= GP_RTP_PCK_SIGNAL_SIZE;\n\t\tif (!const_dur) flags |= GP_RTP_PCK_SIGNAL_TS;\n\t}\n\tif (tmp->has_ctts) flags |= GP_RTP_PCK_SIGNAL_TS;\n\n\t/*default SL for RTP */\n\tInitSL_RTP(&my_sl);\n\n\tmy_sl.timestampResolution = gf_isom_get_media_timescale(file, TrackNum);\n\t/*override clockrate if set*/\n\tif (required_rate) {\n\t\tDouble sc = required_rate;\n\t\tsc /= my_sl.timestampResolution;\n\t\tmaxDTSDelta = (u32) (maxDTSDelta*sc);\n\t\tmy_sl.timestampResolution = required_rate;\n\t}\n\t/*switch to RTP TS*/\n\tmax_ptime = (u32) (max_ptime * my_sl.timestampResolution / 1000);\n\n\tmy_sl.AUSeqNumLength = gf_get_bit_size(gf_isom_get_sample_count(file, TrackNum));\n\tif (my_sl.AUSeqNumLength>16) my_sl.AUSeqNumLength=16;\n\n\tmy_sl.CUDuration = const_dur;\n\n\tif (gf_isom_has_sync_points(file, TrackNum)) {\n\t\tmy_sl.useRandomAccessPointFlag = 1;\n\t} else {\n\t\tmy_sl.useRandomAccessPointFlag = 0;\n\t\tmy_sl.hasRandomAccessUnitsOnlyFlag = 1;\n\t}\n\n\tif (is_crypted) {\n\t\tBool use_sel_enc;\n\t\tgf_isom_get_ismacryp_info(file, TrackNum, 1, NULL, NULL, NULL, NULL, NULL, &use_sel_enc, &IV_length, &KI_length);\n\t\tif (use_sel_enc) flags |= GP_RTP_PCK_SELECTIVE_ENCRYPTION;\n\t}\n\n\t// in case a different timescale was provided\n\ttmp->OrigTimeScale = gf_isom_get_media_timescale(file, TrackNum);\n\ttmp->rtp_p = gf_rtp_builder_new(hintType, &my_sl, flags, tmp,\n\t                                MP4T_OnNewPacket, MP4T_OnPacketDone,\n\t                                /*if copy, no data ref*/\n\t                                copy_media ? NULL : MP4T_OnDataRef,\n\t                                MP4T_OnData);\n\n\t//init the builder\n\tgf_rtp_builder_init(tmp->rtp_p, PayloadID, Path_MTU, max_ptime,\n\t                    streamType, codecid, PL_ID, MinSize, MaxSize, avgTS, maxDTSDelta, IV_length, KI_length, mpeg4mode);\n\n\t/*ISMA compliance is a pain...*/\n\tif (force_dts_delta) tmp->rtp_p->slMap.DTSDeltaLength = force_dts_delta;\n\n\n\t/*\t\tHint Track Setup\t*/\n\ttmp->TrackID = gf_isom_get_track_id(file, TrackNum);\n\ttmp->HintID = tmp->TrackID + 65535;\n\twhile (gf_isom_get_track_by_id(file, tmp->HintID)) tmp->HintID++;\n\n\ttmp->HintTrack = gf_isom_new_track(file, tmp->HintID, GF_ISOM_MEDIA_HINT, my_sl.timestampResolution);\n\tgf_isom_setup_hint_track(file, tmp->HintTrack, GF_ISOM_HINT_RTP);\n\t/*create a hint description*/\n\tgf_isom_new_hint_description(file, tmp->HintTrack, -1, -1, 0, &descIndex);\n\tgf_isom_rtp_set_timescale(file, tmp->HintTrack, descIndex, my_sl.timestampResolution);\n\n\tif (hintType==GF_RTP_PAYT_MPEG4) {\n\t\ttmp->rtp_p->slMap.CodecID = codecid;\n\t\t/*set this SL for extraction.*/\n\t\tgf_isom_set_extraction_slc(file, TrackNum, 1, &my_sl);\n\t}\n\ttmp->bandwidth = bandwidth;\n\n\t/*set interleaving*/\n\tgf_isom_set_track_interleaving_group(file, TrackNum, InterleaveGroupID);\n\tif (!copy_media) {\n\t\t/*if we don't copy data set hint track and media track in the same group*/\n\t\tgf_isom_set_track_interleaving_group(file, tmp->HintTrack, InterleaveGroupID);\n\t} else {\n\t\tgf_isom_set_track_interleaving_group(file, tmp->HintTrack, InterleaveGroupID + OFFSET_HINT_GROUP_ID);\n\t}\n\t/*use user-secified priority*/\n\tInterleaveGroupPriority*=2;\n\tgf_isom_set_track_priority_in_group(file, TrackNum, InterleaveGroupPriority+1);\n\tgf_isom_set_track_priority_in_group(file, tmp->HintTrack, InterleaveGroupPriority);\n\n#if 0\n#endif\n\t*e = GF_OK;\n\treturn tmp;\n}\n\nGF_EXPORT\nGF_Err gf_hinter_track_force_no_offsets(GF_RTPHinter *tkHinter)\n{\n\tGF_Err e;\n\tif (!tkHinter) return GF_BAD_PARAM;\n\te = gf_isom_rtp_set_time_offset(tkHinter->file, tkHinter->HintTrack, 1, 0);\n\tif (e) return e;\n\treturn gf_isom_rtp_set_time_sequence_offset(tkHinter->file, tkHinter->HintTrack, 1, 0);\n}\n\nGF_EXPORT\nu32 gf_hinter_track_get_bandwidth(GF_RTPHinter *tkHinter)\n{\n\treturn tkHinter->bandwidth;\n}\n\nGF_EXPORT\nu32 gf_hinter_track_get_flags(GF_RTPHinter *tkHinter)\n{\n\treturn tkHinter->rtp_p->flags;\n}\nGF_EXPORT\nvoid gf_hinter_track_get_payload_name(GF_RTPHinter *tkHinter, char *payloadName)\n{\n\tchar mediaName[30];\n\tgf_rtp_builder_get_payload_name(tkHinter->rtp_p, payloadName, mediaName);\n}\n\nGF_EXPORT\nvoid gf_hinter_track_del(GF_RTPHinter *tkHinter)\n{\n\tif (!tkHinter) return;\n\n\tif (tkHinter->rtp_p) gf_rtp_builder_del(tkHinter->rtp_p);\n\tgf_free(tkHinter);\n}\n\nGF_EXPORT\nGF_Err gf_hinter_track_process(GF_RTPHinter *tkHint)\n{\n\tGF_Err e;\n\tu32 i, descIndex, duration;\n\tu64 ts;\n\tu8 PadBits;\n\tGF_Fraction ft;\n\tGF_ISOSample *samp;\n\n\ttkHint->HintSample = tkHint->RTPTime = 0;\n\n\ttkHint->TotalSample = gf_isom_get_sample_count(tkHint->file, tkHint->TrackNum);\n\tft.num = tkHint->rtp_p->sl_config.timestampResolution;\n\tft.den = tkHint->OrigTimeScale;\n\n\te = GF_OK;\n\tfor (i=0; i<tkHint->TotalSample; i++) {\n\t\tsamp = gf_isom_get_sample(tkHint->file, tkHint->TrackNum, i+1, &descIndex);\n\t\tif (!samp) return gf_isom_last_error(tkHint->file);\n\n\t\t//setup SL\n\t\ttkHint->CurrentSample = i + 1;\n\n\t\t/*keep same AU indicator if sync shadow - TODO FIXME: this assumes shadows are placed interleaved with\n\t\tthe track content which is the case for GPAC scene carousel generation, but may not always be true*/\n\t\tif (samp->IsRAP==RAP_REDUNDANT) {\n\t\t\ttkHint->rtp_p->sl_header.AU_sequenceNumber -= 1;\n\t\t\tsamp->IsRAP = RAP;\n\t\t}\n\n\t\tts = ft.num * (samp->DTS+samp->CTS_Offset) / ft.den;\n\t\ttkHint->rtp_p->sl_header.compositionTimeStamp = ts;\n\n\t\tts = ft.num * samp->DTS / ft.den;\n\t\ttkHint->rtp_p->sl_header.decodingTimeStamp = ts;\n\t\ttkHint->rtp_p->sl_header.randomAccessPointFlag = samp->IsRAP;\n\n\t\ttkHint->base_offset_in_sample = 0;\n\t\t/*crypted*/\n\t\tif (tkHint->rtp_p->slMap.IV_length) {\n\t\t\tGF_ISMASample *s = gf_isom_get_ismacryp_sample(tkHint->file, tkHint->TrackNum, samp, descIndex);\n\t\t\t/*one byte take for selective_enc flag*/\n\t\t\tif (s->flags & GF_ISOM_ISMA_USE_SEL_ENC) tkHint->base_offset_in_sample += 1;\n\t\t\tif (s->flags & GF_ISOM_ISMA_IS_ENCRYPTED) tkHint->base_offset_in_sample += s->IV_length + s->KI_length;\n\t\t\tgf_free(samp->data);\n\t\t\tsamp->data = s->data;\n\t\t\tsamp->dataLength = s->dataLength;\n\t\t\tgf_rtp_builder_set_cryp_info(tkHint->rtp_p, s->IV, (char*)s->key_indicator, (s->flags & GF_ISOM_ISMA_IS_ENCRYPTED) ? 1 : 0);\n\t\t\ts->data = NULL;\n\t\t\ts->dataLength = 0;\n\t\t\tgf_isom_ismacryp_delete_sample(s);\n\t\t}\n\n\t\tif (tkHint->rtp_p->sl_config.usePaddingFlag) {\n\t\t\tgf_isom_get_sample_padding_bits(tkHint->file, tkHint->TrackNum, i+1, &PadBits);\n\t\t\ttkHint->rtp_p->sl_header.paddingBits = PadBits;\n\t\t} else {\n\t\t\ttkHint->rtp_p->sl_header.paddingBits = 0;\n\t\t}\n\n\t\tduration = gf_isom_get_sample_duration(tkHint->file, tkHint->TrackNum, i+1);\n//\t\tts = (u32) (ft * (s64) (duration));\n\n\t\t/*unpack nal units*/\n\t\tif (tkHint->avc_nalu_size) {\n\t\t\tu32 v, size;\n\t\t\tu32 remain = samp->dataLength;\n\t\t\tchar *ptr = samp->data;\n\n\t\t\ttkHint->rtp_p->sl_header.accessUnitStartFlag = 1;\n\t\t\ttkHint->rtp_p->sl_header.accessUnitEndFlag = 0;\n\t\t\twhile (remain) {\n\t\t\t\tsize = 0;\n\t\t\t\tv = tkHint->avc_nalu_size;\n\t\t\t\tif (v>remain) {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_RTP, (\"[rtp hinter] Broken AVC nalu encapsulation: NALU size length is %d but only %d bytes left in sample %d\\n\", v, remain, tkHint->CurrentSample));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\twhile (v) {\n\t\t\t\t\tsize |= (u8) *ptr;\n\t\t\t\t\tptr++;\n\t\t\t\t\tremain--;\n\t\t\t\t\tv-=1;\n\t\t\t\t\tif (v) size<<=8;\n\t\t\t\t}\n\t\t\t\ttkHint->base_offset_in_sample = samp->dataLength-remain;\n\t\t\t\tif (remain < size) {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_RTP, (\"[rtp hinter] Broken AVC nalu encapsulation: NALU size is %d but only %d bytes left in sample %d\\n\", size, remain, tkHint->CurrentSample));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tremain -= size;\n\t\t\t\ttkHint->rtp_p->sl_header.accessUnitEndFlag = remain ? 0 : 1;\n\t\t\t\tif (!size) {\n\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_RTP, (\"[rtp hinter] Broken AVC nalu encapsulation: NALU size is 0, ignoring it\\n\", size));\n\t\t\t\t} else {\n\t\t\t\t\te = gf_rtp_builder_process(tkHint->rtp_p, ptr, size, (u8) !remain, samp->dataLength, duration, (u8) (descIndex + GF_RTP_TX3G_SIDX_OFFSET) );\n\t\t\t\t\tptr += size;\n\t\t\t\t}\n\t\t\t\ttkHint->rtp_p->sl_header.accessUnitStartFlag = 0;\n\t\t\t}\n\t\t} else {\n\t\t\te = gf_rtp_builder_process(tkHint->rtp_p, samp->data, samp->dataLength, 1, samp->dataLength, duration, (u8) (descIndex + GF_RTP_TX3G_SIDX_OFFSET) );\n\t\t}\n\t\ttkHint->rtp_p->sl_header.packetSequenceNumber += 1;\n\n\t\t//signal some progress\n\t\tgf_set_progress(\"Hinting\", tkHint->CurrentSample, tkHint->TotalSample);\n\n\t\ttkHint->rtp_p->sl_header.AU_sequenceNumber += 1;\n\t\tgf_isom_sample_del(&samp);\n\n\t\tif (e) return e;\n\t}\n\n\t//flush\n\tgf_rtp_builder_process(tkHint->rtp_p, NULL, 0, 1, 0, 0, 0);\n\n\tgf_isom_end_hint_sample(tkHint->file, tkHint->HintTrack, (u8) tkHint->SampleIsRAP);\n\treturn GF_OK;\n}\n\nstatic u32 write_nalu_config_array(char *sdpLine, GF_List *nalus)\n{\n\tu32 i, count, b64s;\n\tchar b64[200];\n\n\tcount = gf_list_count(nalus);\n\tfor (i=0; i<count; i++) {\n\t\tGF_NALUFFParam *sl = (GF_NALUFFParam *)gf_list_get(nalus, i);\n\t\tb64s = gf_base64_encode(sl->data, sl->size, b64, 200);\n\t\tb64[b64s]=0;\n\t\tstrcat(sdpLine, b64);\n\t\tif (i+1<count) strcat(sdpLine, \",\");\n\t}\n\treturn count;\n}\n\nstatic void write_avc_config(char *sdpLine, GF_AVCConfig *avcc, GF_AVCConfig *svcc)\n{\n\tu32 count = 0;\n\n\tif (avcc) count += gf_list_count(avcc->sequenceParameterSets) + gf_list_count(avcc->pictureParameterSets) + gf_list_count(avcc->sequenceParameterSetExtensions);\n\tif (svcc) count += gf_list_count(svcc->sequenceParameterSets) + gf_list_count(svcc->pictureParameterSets);\n\tif (!count) return;\n\n\tstrcat(sdpLine, \"; sprop-parameter-sets=\");\n\n\tif (avcc) {\n\t\tcount = write_nalu_config_array(sdpLine, avcc->sequenceParameterSets);\n\t\tif (count) strcat(sdpLine, \",\");\n\t\tcount = write_nalu_config_array(sdpLine, avcc->sequenceParameterSetExtensions);\n\t\tif (count) strcat(sdpLine, \",\");\n\t\tcount = write_nalu_config_array(sdpLine, avcc->pictureParameterSets);\n\t\tif (count) strcat(sdpLine, \",\");\n\t}\n\n\tif (svcc) {\n\t\tcount = write_nalu_config_array(sdpLine, svcc->sequenceParameterSets);\n\t\tif (count) strcat(sdpLine, \",\");\n\t\tcount = write_nalu_config_array(sdpLine, svcc->pictureParameterSets);\n\t\tif (count) strcat(sdpLine, \",\");\n\t}\n\tcount = (u32) strlen(sdpLine);\n\tif (sdpLine[count-1] == ',')\n\t\tsdpLine[count-1] = 0;\n}\n\nGF_EXPORT\nGF_Err gf_hinter_track_finalize(GF_RTPHinter *tkHint, Bool AddSystemInfo)\n{\n\tu32 Width, Height;\n\tGF_ESD *esd;\n\tchar sdpLine[20000];\n\tchar mediaName[30], payloadName[30];\n    u32 mtype;\n\n\tWidth = Height = 0;\n\tgf_isom_sdp_clean_track(tkHint->file, tkHint->TrackNum);\n    mtype = gf_isom_get_media_type(tkHint->file, tkHint->TrackNum);\n    if (gf_isom_is_video_handler_type(mtype))\n\t\tgf_isom_get_visual_info(tkHint->file, tkHint->TrackNum, 1, &Width, &Height);\n\n\tgf_rtp_builder_get_payload_name(tkHint->rtp_p, payloadName, mediaName);\n\n\t/*TODO- extract out of rtp_p for future live tools*/\n\tsprintf(sdpLine, \"m=%s 0 RTP/%s %d\", mediaName, tkHint->rtp_p->slMap.IV_length ? \"SAVP\" : \"AVP\", tkHint->rtp_p->PayloadType);\n\tgf_isom_sdp_add_track_line(tkHint->file, tkHint->HintTrack, sdpLine);\n\tif (tkHint->bandwidth) {\n\t\tsprintf(sdpLine, \"b=AS:%d\", tkHint->bandwidth);\n\t\tgf_isom_sdp_add_track_line(tkHint->file, tkHint->HintTrack, sdpLine);\n\t}\n\tif (tkHint->nb_chan) {\n\t\tsprintf(sdpLine, \"a=rtpmap:%d %s/%d/%d\", tkHint->rtp_p->PayloadType, payloadName, tkHint->rtp_p->sl_config.timestampResolution, tkHint->nb_chan);\n\t} else {\n\t\tsprintf(sdpLine, \"a=rtpmap:%d %s/%d\", tkHint->rtp_p->PayloadType, payloadName, tkHint->rtp_p->sl_config.timestampResolution);\n\t}\n\tgf_isom_sdp_add_track_line(tkHint->file, tkHint->HintTrack, sdpLine);\n\t/*control for MPEG-4*/\n\tif (AddSystemInfo) {\n\t\tsprintf(sdpLine, \"a=mpeg4-esid:%d\", gf_isom_get_track_id(tkHint->file, tkHint->TrackNum));\n\t\tgf_isom_sdp_add_track_line(tkHint->file, tkHint->HintTrack, sdpLine);\n\t}\n\t/*control for QTSS/DSS*/\n\tsprintf(sdpLine, \"a=control:trackID=%d\", gf_isom_get_track_id(tkHint->file, tkHint->HintTrack));\n\tgf_isom_sdp_add_track_line(tkHint->file, tkHint->HintTrack, sdpLine);\n\n\t/*H263 extensions*/\n\tif (tkHint->rtp_p->rtp_payt == GF_RTP_PAYT_H263) {\n\t\tsprintf(sdpLine, \"a=cliprect:0,0,%d,%d\", Height, Width);\n\t\tgf_isom_sdp_add_track_line(tkHint->file, tkHint->HintTrack, sdpLine);\n\t}\n\t/*AMR*/\n\telse if ((tkHint->rtp_p->rtp_payt == GF_RTP_PAYT_AMR) || (tkHint->rtp_p->rtp_payt == GF_RTP_PAYT_AMR_WB)) {\n\t\tsprintf(sdpLine, \"a=fmtp:%d octet-align=1\", tkHint->rtp_p->PayloadType);\n\t\tgf_isom_sdp_add_track_line(tkHint->file, tkHint->HintTrack, sdpLine);\n\t}\n\t/*Text*/\n\telse if (tkHint->rtp_p->rtp_payt == GF_RTP_PAYT_3GPP_TEXT) {\n\t\tu32 w, h, i, m_w, m_h;\n\t\ts32 tx, ty;\n\t\ts16 l;\n\n\t\tgf_isom_get_track_layout_info(tkHint->file, tkHint->TrackNum, &w, &h, &tx, &ty, &l);\n\t\tm_w = w;\n\t\tm_h = h;\n\t\tfor (i=0; i<gf_isom_get_track_count(tkHint->file); i++) {\n\t\t\tswitch (gf_isom_get_media_type(tkHint->file, i+1)) {\n\t\t\tcase GF_ISOM_MEDIA_SCENE:\n\t\t\tcase GF_ISOM_MEDIA_VISUAL:\n\t\t\tcase GF_ISOM_MEDIA_AUXV:\n\t\t\tcase GF_ISOM_MEDIA_PICT:\n\t\t\t\tgf_isom_get_track_layout_info(tkHint->file, i+1, &w, &h, &tx, &ty, &l);\n\t\t\t\tif (w>m_w) m_w = w;\n\t\t\t\tif (h>m_h) m_h = h;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tgf_media_format_ttxt_sdp(tkHint->rtp_p, payloadName, sdpLine, w, h, tx, ty, l, m_w, m_h, NULL);\n\n\t\tstrcat(sdpLine, \"; tx3g=\");\n\t\tfor (i=0; i<gf_isom_get_sample_description_count(tkHint->file, tkHint->TrackNum); i++) {\n\t\t\tu8 *tx3g;\n\t\t\tchar buffer[2000];\n\t\t\tu32 tx3g_len, len;\n\t\t\tgf_isom_text_get_encoded_tx3g(tkHint->file, tkHint->TrackNum, i+1, GF_RTP_TX3G_SIDX_OFFSET, &tx3g, &tx3g_len);\n\t\t\tlen = gf_base64_encode(tx3g, tx3g_len, buffer, 2000);\n\t\t\tgf_free(tx3g);\n\t\t\tbuffer[len] = 0;\n\t\t\tif (i) strcat(sdpLine, \", \");\n\t\t\tstrcat(sdpLine, buffer);\n\t\t}\n\t\tgf_isom_sdp_add_track_line(tkHint->file, tkHint->HintTrack, sdpLine);\n\t}\n\t/*EVRC/SMV in non header-free mode*/\n\telse if ((tkHint->rtp_p->rtp_payt == GF_RTP_PAYT_EVRC_SMV) && (tkHint->rtp_p->auh_size>1)) {\n\t\tsprintf(sdpLine, \"a=fmtp:%d maxptime=%d\", tkHint->rtp_p->PayloadType, tkHint->rtp_p->auh_size*20);\n\t\tgf_isom_sdp_add_track_line(tkHint->file, tkHint->HintTrack, sdpLine);\n\t}\n\t/*H264/AVC*/\n\telse if ((tkHint->rtp_p->rtp_payt == GF_RTP_PAYT_H264_AVC) || (tkHint->rtp_p->rtp_payt == GF_RTP_PAYT_H264_SVC))  {\n\t\tGF_AVCConfig *avcc = gf_isom_avc_config_get(tkHint->file, tkHint->TrackNum, 1);\n\t\tGF_AVCConfig *svcc = gf_isom_svc_config_get(tkHint->file, tkHint->TrackNum, 1);\n\t\t/*TODO - check syntax for SVC (might be some extra signaling)*/\n\n\t\tif (avcc) {\n\t\t\tsprintf(sdpLine, \"a=fmtp:%d profile-level-id=%02X%02X%02X; packetization-mode=1\", tkHint->rtp_p->PayloadType, avcc->AVCProfileIndication, avcc->profile_compatibility, avcc->AVCLevelIndication);\n\t\t} else {\n\t\t\tif (!svcc)\n\t\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t\tsprintf(sdpLine, \"a=fmtp:%d profile-level-id=%02X%02X%02X; packetization-mode=1\", tkHint->rtp_p->PayloadType, svcc->AVCProfileIndication, svcc->profile_compatibility, svcc->AVCLevelIndication);\n\t\t}\n\n\t\twrite_avc_config(sdpLine, avcc, svcc);\n\n\t\tgf_isom_sdp_add_track_line(tkHint->file, tkHint->HintTrack, sdpLine);\n\t\tgf_odf_avc_cfg_del(avcc);\n\t\tgf_odf_avc_cfg_del(svcc);\n\t}\n\t/*MPEG-4 decoder config*/\n\telse if (tkHint->rtp_p->rtp_payt==GF_RTP_PAYT_MPEG4) {\n\t\tesd = gf_isom_get_esd(tkHint->file, tkHint->TrackNum, 1);\n\n\t\tif (esd && esd->decoderConfig && esd->decoderConfig->decoderSpecificInfo && esd->decoderConfig->decoderSpecificInfo->data) {\n\t\t\tgf_rtp_builder_format_sdp(tkHint->rtp_p, payloadName, sdpLine, esd->decoderConfig->decoderSpecificInfo->data, esd->decoderConfig->decoderSpecificInfo->dataLength);\n\t\t} else {\n\t\t\tgf_rtp_builder_format_sdp(tkHint->rtp_p, payloadName, sdpLine, NULL, 0);\n\t\t}\n\t\tif (esd) gf_odf_desc_del((GF_Descriptor *)esd);\n\n\t\tif (tkHint->rtp_p->slMap.IV_length) {\n\t\t\tconst char *kms;\n\t\t\tgf_isom_get_ismacryp_info(tkHint->file, tkHint->TrackNum, 1, NULL, NULL, NULL, NULL, &kms, NULL, NULL, NULL);\n\t\t\tif (!strnicmp(kms, \"(key)\", 5) || !strnicmp(kms, \"(ipmp)\", 6) || !strnicmp(kms, \"(uri)\", 5)) {\n\t\t\t\tstrcat(sdpLine, \"; ISMACrypKey=\");\n\t\t\t} else {\n\t\t\t\tstrcat(sdpLine, \"; ISMACrypKey=(uri)\");\n\t\t\t}\n\t\t\tstrcat(sdpLine, kms);\n\t\t}\n\n\t\tgf_isom_sdp_add_track_line(tkHint->file, tkHint->HintTrack, sdpLine);\n\t}\n\t/*MPEG-4 Audio LATM*/\n\telse if (tkHint->rtp_p->rtp_payt==GF_RTP_PAYT_LATM) {\n\t\tGF_BitStream *bs;\n\t\tu8 *config_bytes;\n\t\tu32 config_size;\n\n\t\t/* form config string */\n\t\tbs = gf_bs_new(NULL, 32, GF_BITSTREAM_WRITE);\n\t\tgf_bs_write_int(bs, 0, 1); /* AudioMuxVersion */\n\t\tgf_bs_write_int(bs, 1, 1); /* all streams same time */\n\t\tgf_bs_write_int(bs, 0, 6); /* numSubFrames */\n\t\tgf_bs_write_int(bs, 0, 4); /* numPrograms */\n\t\tgf_bs_write_int(bs, 0, 3); /* numLayer */\n\n\t\t/* audio-specific config */\n\t\tesd = gf_isom_get_esd(tkHint->file, tkHint->TrackNum, 1);\n\t\tif (esd && esd->decoderConfig && esd->decoderConfig->decoderSpecificInfo) {\n\t\t\t/*PacketVideo patch: don't signal SBR and PS stuff, not allowed in LATM with audioMuxVersion=0*/\n\t\t\tgf_bs_write_data(bs, esd->decoderConfig->decoderSpecificInfo->data, MIN(esd->decoderConfig->decoderSpecificInfo->dataLength, 2) );\n\t\t}\n\t\tif (esd) gf_odf_desc_del((GF_Descriptor *)esd);\n\n\t\t/* other data */\n\t\tgf_bs_write_int(bs, 0, 3); /* frameLengthType */\n\t\tgf_bs_write_int(bs, 0xff, 8); /* latmBufferFullness */\n\t\tgf_bs_write_int(bs, 0, 1); /* otherDataPresent */\n\t\tgf_bs_write_int(bs, 0, 1); /* crcCheckPresent */\n\t\tgf_bs_get_content(bs, &config_bytes, &config_size);\n\t\tgf_bs_del(bs);\n\n\t\tgf_rtp_builder_format_sdp(tkHint->rtp_p, payloadName, sdpLine, config_bytes, config_size);\n\t\tgf_isom_sdp_add_track_line(tkHint->file, tkHint->HintTrack, sdpLine);\n\t\tgf_free(config_bytes);\n\t}\n#if GPAC_ENABLE_3GPP_DIMS_RTP\n\t/*3GPP DIMS*/\n\telse if (tkHint->rtp_p->rtp_payt==GF_RTP_PAYT_3GPP_DIMS) {\n\t\tGF_DIMSDescription dims;\n\t\tgf_isom_get_visual_info(tkHint->file, tkHint->TrackNum, 1, &Width, &Height);\n\n\t\tgf_isom_get_dims_description(tkHint->file, tkHint->TrackNum, 1, &dims);\n\t\tsprintf(sdpLine, \"a=fmtp:%d Version-profile=%d\", tkHint->rtp_p->PayloadType, dims.profile);\n\t\tif (! dims.fullRequestHost) {\n\t\t\tchar fmt[200];\n\t\t\tstrcat(sdpLine, \";useFullRequestHost=0\");\n\t\t\tsprintf(fmt, \";pathComponents=%d\", dims.pathComponents);\n\t\t\tstrcat(sdpLine, fmt);\n\t\t}\n\t\tif (!dims.streamType) strcat(sdpLine, \";stream-type=secondary\");\n\t\tif (dims.containsRedundant == 1) strcat(sdpLine, \";contains-redundant=main\");\n\t\telse if (dims.containsRedundant == 2) strcat(sdpLine, \";contains-redundant=redundant\");\n\n\t\tif (dims.textEncoding && strlen(dims.textEncoding)) {\n\t\t\tstrcat(sdpLine, \";text-encoding=\");\n\t\t\tstrcat(sdpLine, dims.textEncoding);\n\t\t}\n\t\tif (dims.contentEncoding && strlen(dims.contentEncoding)) {\n\t\t\tstrcat(sdpLine, \";content-coding=\");\n\t\t\tstrcat(sdpLine, dims.contentEncoding);\n\t\t}\n\t\tif (dims.contentEncoding && dims.content_script_types && strlen(dims.content_script_types) ) {\n\t\t\tstrcat(sdpLine, \";content-script-types=\");\n\t\t\tstrcat(sdpLine, dims.contentEncoding);\n\t\t}\n\t\tgf_isom_sdp_add_track_line(tkHint->file, tkHint->HintTrack, sdpLine);\n\t}\n#endif\n\t/*extensions for some mobile phones*/\n\tif (Width && Height) {\n\t\tsprintf(sdpLine, \"a=framesize:%d %d-%d\", tkHint->rtp_p->PayloadType, Width, Height);\n\t\tgf_isom_sdp_add_track_line(tkHint->file, tkHint->HintTrack, sdpLine);\n\t}\n\n\tesd = gf_isom_get_esd(tkHint->file, tkHint->TrackNum, 1);\n\tif (esd && esd->decoderConfig && (esd->decoderConfig->rvc_config || esd->decoderConfig->predefined_rvc_config)) {\n\t\tif (esd->decoderConfig->predefined_rvc_config) {\n\t\t\tsprintf(sdpLine, \"a=rvc-config-predef:%d\", esd->decoderConfig->predefined_rvc_config);\n\t\t} else {\n\t\t\t/*temporary ...*/\n\t\t\tif ((esd->decoderConfig->objectTypeIndication==GF_CODECID_AVC) || (esd->decoderConfig->objectTypeIndication==GF_CODECID_SVC)) {\n\t\t\t\tsprintf(sdpLine, \"a=rvc-config:%s\", \"http://download.tsi.telecom-paristech.fr/gpac/RVC/rvc_config_avc.xml\");\n\t\t\t} else {\n\t\t\t\tsprintf(sdpLine, \"a=rvc-config:%s\", \"http://download.tsi.telecom-paristech.fr/gpac/RVC/rvc_config_sp.xml\");\n\t\t\t}\n\t\t}\n\t\tgf_isom_sdp_add_track_line(tkHint->file, tkHint->HintTrack, sdpLine);\n\t}\n\tif (esd) gf_odf_desc_del((GF_Descriptor *)esd);\n\n\tgf_isom_set_track_enabled(tkHint->file, tkHint->HintTrack, GF_TRUE);\n\treturn GF_OK;\n}\n\nGF_EXPORT\nBool gf_hinter_can_embbed_data(u8 *data, u32 data_size, u32 streamType)\n{\n\tchar data64[5000];\n\tu32 size64;\n\n\tsize64 = gf_base64_encode(data, data_size, data64, 5000);\n\tif (!size64) return 0;\n\tswitch (streamType) {\n\tcase GF_STREAM_OD:\n\t\tsize64 += (u32) strlen(\"data:application/mpeg4-od-au;base64,\");\n\t\tbreak;\n\tcase GF_STREAM_SCENE:\n\t\tsize64 += (u32) strlen(\"data:application/mpeg4-bifs-au;base64,\");\n\t\tbreak;\n\tdefault:\n\t\t/*NOT NORMATIVE*/\n\t\tsize64 += (u32) strlen(\"data:application/mpeg4-es-au;base64,\");\n\t\tbreak;\n\t}\n\tif (size64>=255) return 0;\n\treturn 1;\n}\n\n\nGF_EXPORT\nGF_Err gf_hinter_finalize(GF_ISOFile *file, GF_SDP_IODProfile IOD_Profile, u32 bandwidth)\n{\n\tu32 i, sceneT, odT, descIndex, size, size64;\n\tGF_InitialObjectDescriptor *iod;\n\tGF_SLConfig slc;\n\tGF_ISOSample *samp;\n\tBool remove_ocr;\n\tu8 *buffer;\n\tchar buf64[5000], sdpLine[5100];\n\n\n\tgf_isom_sdp_clean(file);\n\n\tif (bandwidth) {\n\t\tsprintf(buf64, \"b=AS:%d\", bandwidth);\n\t\tgf_isom_sdp_add_line(file, buf64);\n\t}\n    //xtended attribute for copyright\n    if (gf_sys_is_test_mode()) {\n        sprintf(buf64, \"a=x-copyright: %s\", \"MP4/3GP File hinted with GPAC - (c) Telecom ParisTech (http://gpac.io)\");\n    } else {\n        sprintf(buf64, \"a=x-copyright: MP4/3GP File hinted with GPAC %s - %s\", gf_gpac_version(), gf_gpac_copyright() );\n    }\n\tgf_isom_sdp_add_line(file, buf64);\n\n\tif (IOD_Profile == GF_SDP_IOD_NONE) return GF_OK;\n\n\todT = sceneT = 0;\n\tfor (i=0; i<gf_isom_get_track_count(file); i++) {\n\t\tif (!gf_isom_is_track_in_root_od(file, i+1)) continue;\n\t\tswitch (gf_isom_get_media_type(file,i+1)) {\n\t\tcase GF_ISOM_MEDIA_OD:\n\t\t\todT = i+1;\n\t\t\tbreak;\n\t\tcase GF_ISOM_MEDIA_SCENE:\n\t\t\tsceneT = i+1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tremove_ocr = 0;\n\tif (IOD_Profile == GF_SDP_IOD_ISMA_STRICT) {\n\t\tIOD_Profile = GF_SDP_IOD_ISMA;\n\t\tremove_ocr = 1;\n\t}\n\n\t/*if we want ISMA like iods, we need at least BIFS */\n\tif ( (IOD_Profile == GF_SDP_IOD_ISMA) && !sceneT ) return GF_BAD_PARAM;\n\n\t/*do NOT change PLs, we assume they are correct*/\n\tiod = (GF_InitialObjectDescriptor *) gf_isom_get_root_od(file);\n\tif (!iod) return GF_NOT_SUPPORTED;\n\n\t/*rewrite an IOD with good SL config - embbed data if possible*/\n\tif (IOD_Profile == GF_SDP_IOD_ISMA) {\n\t\tGF_ESD *esd;\n\t\tBool is_ok = 1;\n\t\twhile (gf_list_count(iod->ESDescriptors)) {\n\t\t\tesd = (GF_ESD*)gf_list_get(iod->ESDescriptors, 0);\n\t\t\tgf_odf_desc_del((GF_Descriptor *) esd);\n\t\t\tgf_list_rem(iod->ESDescriptors, 0);\n\t\t}\n\n\n\t\t/*get OD esd, and embbed stream data if possible*/\n\t\tif (odT) {\n\t\t\tesd = gf_isom_get_esd(file, odT, 1);\n\t\t\tif (gf_isom_get_sample_count(file, odT)==1) {\n\t\t\t\tsamp = gf_isom_get_sample(file, odT, 1, &descIndex);\n\t\t\t\tif (gf_hinter_can_embbed_data(samp->data, samp->dataLength, GF_STREAM_OD)) {\n\t\t\t\t\tInitSL_NULL(&slc);\n\t\t\t\t\tslc.predefined = 0;\n\t\t\t\t\tslc.hasRandomAccessUnitsOnlyFlag = 1;\n\t\t\t\t\tslc.timeScale = slc.timestampResolution = gf_isom_get_media_timescale(file, odT);\n\t\t\t\t\tslc.OCRResolution = 1000;\n\t\t\t\t\tslc.startCTS = samp->DTS+samp->CTS_Offset;\n\t\t\t\t\tslc.startDTS = samp->DTS;\n\t\t\t\t\t//set the SL for future extraction\n\t\t\t\t\tgf_isom_set_extraction_slc(file, odT, 1, &slc);\n\n\t\t\t\t\tsize64 = gf_base64_encode(samp->data, samp->dataLength, buf64, 2000);\n\t\t\t\t\tbuf64[size64] = 0;\n\t\t\t\t\tsprintf(sdpLine, \"data:application/mpeg4-od-au;base64,%s\", buf64);\n\n\t\t\t\t\tesd->decoderConfig->avgBitrate = 0;\n\t\t\t\t\tesd->decoderConfig->bufferSizeDB = samp->dataLength;\n\t\t\t\t\tesd->decoderConfig->maxBitrate = 0;\n\t\t\t\t\tsize64 = (u32) strlen(sdpLine)+1;\n\t\t\t\t\tesd->URLString = (char*)gf_malloc(sizeof(char) * size64);\n\t\t\t\t\tstrcpy(esd->URLString, sdpLine);\n\t\t\t\t} else {\n\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_RTP, (\"[rtp hinter] OD sample too large to be embedded in IOD - ISMA disabled\\n\"));\n\t\t\t\t\tis_ok = 0;\n\t\t\t\t}\n\t\t\t\tgf_isom_sample_del(&samp);\n\t\t\t}\n\t\t\tif (remove_ocr) esd->OCRESID = 0;\n\t\t\telse if (esd->OCRESID == esd->ESID) esd->OCRESID = 0;\n\n\t\t\t//OK, add this to our IOD\n\t\t\tgf_list_add(iod->ESDescriptors, esd);\n\t\t}\n\n\t\tesd = gf_isom_get_esd(file, sceneT, 1);\n\t\tif (gf_isom_get_sample_count(file, sceneT)==1) {\n\t\t\tsamp = gf_isom_get_sample(file, sceneT, 1, &descIndex);\n\t\t\tif (gf_hinter_can_embbed_data(samp->data, samp->dataLength, GF_STREAM_SCENE)) {\n\n\t\t\t\tslc.timeScale = slc.timestampResolution = gf_isom_get_media_timescale(file, sceneT);\n\t\t\t\tslc.OCRResolution = 1000;\n\t\t\t\tslc.startCTS = samp->DTS+samp->CTS_Offset;\n\t\t\t\tslc.startDTS = samp->DTS;\n\t\t\t\t//set the SL for future extraction\n\t\t\t\tgf_isom_set_extraction_slc(file, sceneT, 1, &slc);\n\t\t\t\t//encode in Base64 the sample\n\t\t\t\tsize64 = gf_base64_encode(samp->data, samp->dataLength, buf64, 2000);\n\t\t\t\tbuf64[size64] = 0;\n\t\t\t\tsprintf(sdpLine, \"data:application/mpeg4-bifs-au;base64,%s\", buf64);\n\n\t\t\t\tesd->decoderConfig->avgBitrate = 0;\n\t\t\t\tesd->decoderConfig->bufferSizeDB = samp->dataLength;\n\t\t\t\tesd->decoderConfig->maxBitrate = 0;\n\t\t\t\tesd->URLString = (char*)gf_malloc(sizeof(char) * (strlen(sdpLine)+1));\n\t\t\t\tstrcpy(esd->URLString, sdpLine);\n\t\t\t} else {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_RTP, (\"[rtp hinter] Scene description sample too large to be embedded in IOD - ISMA disabled\\n\"));\n\t\t\t\tis_ok = 0;\n\t\t\t}\n\t\t\tgf_isom_sample_del(&samp);\n\t\t}\n\t\tif (remove_ocr) esd->OCRESID = 0;\n\t\telse if (esd->OCRESID == esd->ESID) esd->OCRESID = 0;\n\n\t\tgf_list_add(iod->ESDescriptors, esd);\n\n\t\tif (is_ok) {\n\t\t\tu32 has_a, has_v, has_i_a, has_i_v;\n\t\t\thas_a = has_v = has_i_a = has_i_v = 0;\n\t\t\tfor (i=0; i<gf_isom_get_track_count(file); i++) {\n\t\t\t\tesd = gf_isom_get_esd(file, i+1, 1);\n\t\t\t\tif (!esd) continue;\n\t\t\t\tif (esd->decoderConfig->streamType==GF_STREAM_VISUAL) {\n\t\t\t\t\tif (esd->decoderConfig->objectTypeIndication==GF_CODECID_MPEG4_PART2) has_i_v ++;\n\t\t\t\t\telse has_v++;\n\t\t\t\t} else if (esd->decoderConfig->streamType==GF_STREAM_AUDIO) {\n\t\t\t\t\tif (esd->decoderConfig->objectTypeIndication==GF_CODECID_AAC_MPEG4) has_i_a ++;\n\t\t\t\t\telse has_a++;\n\t\t\t\t}\n\t\t\t\tgf_odf_desc_del((GF_Descriptor *)esd);\n\t\t\t}\n\t\t\t/*only 1 MPEG-4 visual max and 1 MPEG-4 audio max for ISMA compliancy*/\n\t\t\tif (!has_v && !has_a && (has_i_v<=1) && (has_i_a<=1)) {\n\t\t\t\tsprintf(sdpLine, \"a=isma-compliance:1,1.0,1\");\n\t\t\t\tgf_isom_sdp_add_line(file, sdpLine);\n\t\t\t}\n\t\t}\n\t}\n\n\t//encode the IOD\n\tbuffer = NULL;\n\tsize = 0;\n\tgf_odf_desc_write((GF_Descriptor *) iod, &buffer, &size);\n\tgf_odf_desc_del((GF_Descriptor *)iod);\n\n\t//encode in Base64 the iod\n\tsize64 = gf_base64_encode(buffer, size, buf64, 2000);\n\tbuf64[size64] = 0;\n\tgf_free(buffer);\n\n\tsprintf(sdpLine, \"a=mpeg4-iod:\\\"data:application/mpeg4-iod;base64,%s\\\"\", buf64);\n\tgf_isom_sdp_add_line(file, sdpLine);\n\n\treturn GF_OK;\n}\n\n\n#endif /*GPAC_DISABLE_ISOM_HINTING*/\n\n#endif /*GPAC_DISABLE_ISOM*/\n"], "fixing_code": ["/*\n *\t\t\tGPAC - Multimedia Framework C SDK\n *\n *\t\t\tAuthors: Jean Le Feuvre\n *\t\t\tCopyright (c) Telecom ParisTech 2000-2021\n *\t\t\t\t\tAll rights reserved\n *\n *  This file is part of GPAC / ISO Media File Format sub-project\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n\n#include <gpac/internal/isomedia_dev.h>\n#include <gpac/constants.h>\n\n#ifndef GPAC_DISABLE_ISOM\n\n//the only static var. Used to store any error happening while opening a movie\nstatic GF_Err MP4_API_IO_Err;\n\nvoid gf_isom_set_last_error(GF_ISOFile *movie, GF_Err error)\n{\n\tif (!movie) {\n\t\tMP4_API_IO_Err = error;\n\t} else {\n\t\tmovie->LastError = error;\n\t}\n}\n\n\nGF_EXPORT\nGF_Err gf_isom_last_error(GF_ISOFile *the_file)\n{\n\tif (!the_file) return MP4_API_IO_Err;\n\treturn the_file->LastError;\n}\n\nGF_EXPORT\nu8 gf_isom_get_mode(GF_ISOFile *the_file)\n{\n\tif (!the_file) return 0;\n\treturn the_file->openMode;\n}\n\n#if 0 //unused\n/*! gets file size of an ISO file\n\\param isom_file the target ISO file\n\\return the file size in bytes\n*/\nu64 gf_isom_get_file_size(GF_ISOFile *the_file)\n{\n\tif (!the_file) return 0;\n\tif (the_file->movieFileMap) return gf_bs_get_size(the_file->movieFileMap->bs);\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\tif (the_file->editFileMap) return gf_bs_get_size(the_file->editFileMap->bs);\n#endif\n\treturn 0;\n}\n#endif\n\nGF_EXPORT\nGF_Err gf_isom_freeze_order(GF_ISOFile *file)\n{\n\tu32 i=0;\n\tGF_Box *box;\n\tif (!file) return GF_BAD_PARAM;\n\twhile ((box=gf_list_enum(file->TopBoxes, &i))) {\n\t\tgf_isom_box_freeze_order(box);\n\t}\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_inplace_padding(GF_ISOFile *file, u32 padding)\n{\n\tif (!file) return GF_BAD_PARAM;\n\tfile->padding = padding;\n\treturn GF_OK;\n}\n/**************************************************************\n\t\t\t\t\tSample Manip\n**************************************************************/\n\n//creates a new empty sample\nGF_EXPORT\nGF_ISOSample *gf_isom_sample_new()\n{\n\tGF_ISOSample *tmp;\n\tGF_SAFEALLOC(tmp, GF_ISOSample);\n\treturn tmp;\n}\n\n//delete a sample\nGF_EXPORT\nvoid gf_isom_sample_del(GF_ISOSample **samp)\n{\n\tif (!samp || ! *samp) return;\n\tif ((*samp)->data && (*samp)->dataLength) gf_free((*samp)->data);\n\tgf_free(*samp);\n\t*samp = NULL;\n}\n\nstatic u32 gf_isom_probe_type(u32 type)\n{\n\tswitch (type) {\n\tcase GF_ISOM_BOX_TYPE_FTYP:\n\tcase GF_ISOM_BOX_TYPE_MOOV:\n\t\treturn 2;\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tcase GF_ISOM_BOX_TYPE_MOOF:\n\tcase GF_ISOM_BOX_TYPE_STYP:\n\tcase GF_ISOM_BOX_TYPE_SIDX:\n\tcase GF_ISOM_BOX_TYPE_EMSG:\n\tcase GF_ISOM_BOX_TYPE_PRFT:\n    //we map free as segment when it is first in the file - a regular file shall start with ftyp or a file sig, not free\n    //since our route stack may patch boxes to free for incomplete segments, we must map this to free\n    case GF_ISOM_BOX_TYPE_FREE:\n\t\treturn 3;\n#ifndef GPAC_DISABLE_ISOM_ADOBE\n\t/*Adobe specific*/\n\tcase GF_ISOM_BOX_TYPE_AFRA:\n\tcase GF_ISOM_BOX_TYPE_ABST:\n#endif\n#endif\n\tcase GF_ISOM_BOX_TYPE_MDAT:\n\tcase GF_ISOM_BOX_TYPE_SKIP:\n\tcase GF_ISOM_BOX_TYPE_UDTA:\n\tcase GF_ISOM_BOX_TYPE_META:\n\tcase GF_ISOM_BOX_TYPE_VOID:\n\tcase GF_ISOM_BOX_TYPE_JP:\n\tcase GF_QT_BOX_TYPE_WIDE:\n\t\treturn 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nGF_EXPORT\nu32 gf_isom_probe_file_range(const char *fileName, u64 start_range, u64 end_range)\n{\n\tu32 type = 0;\n\n\tif (!strncmp(fileName, \"gmem://\", 7)) {\n\t\tu32 size;\n\t\tu8 *mem_address;\n\t\tif (gf_blob_get(fileName, &mem_address, &size, NULL) != GF_OK) {\n\t\t\treturn 0;\n\t\t}\n        if (size && (size > start_range + 8)) {\n\t\t\ttype = GF_4CC(mem_address[start_range + 4], mem_address[start_range + 5], mem_address[start_range + 6], mem_address[start_range + 7]);\n        }\n        gf_blob_release(fileName);\n\t} else if (!strncmp(fileName, \"isobmff://\", 10)) {\n\t\treturn 2;\n\t} else {\n\t\tu32 nb_read;\n\t\tunsigned char data[4];\n\t\tFILE *f = gf_fopen(fileName, \"rb\");\n\t\tif (!f) return 0;\n\t\tif (start_range) gf_fseek(f, start_range, SEEK_SET);\n\t\ttype = 0;\n\t\tnb_read = (u32) gf_fread(data, 4, f);\n\t\tif (nb_read == 4) {\n\t\t\tif (gf_fread(data, 4, f) == 4) {\n\t\t\t\ttype = GF_4CC(data[0], data[1], data[2], data[3]);\n\t\t\t}\n\t\t}\n\t\tgf_fclose(f);\n\t\tif (!nb_read) return 0;\n\t}\n\treturn gf_isom_probe_type(type);\n}\n\nGF_EXPORT\nu32 gf_isom_probe_file(const char *fileName)\n{\n\treturn gf_isom_probe_file_range(fileName, 0, 0);\n}\n\nGF_EXPORT\nu32 gf_isom_probe_data(const u8*inBuf, u32 inSize)\n{\n\tu32 type;\n\tif (inSize < 8) return 0;\n\ttype = GF_4CC(inBuf[4], inBuf[5], inBuf[6], inBuf[7]);\n\treturn gf_isom_probe_type(type);\n}\n\n\n#ifndef GPAC_DISABLE_AV_PARSERS\n#include <gpac/internal/media_dev.h>\n#endif\n\nstatic GF_Err isom_create_init_from_mem(const char *fileName, GF_ISOFile *file)\n{\n\tu32 sample_rate=0;\n\tu32 nb_channels=0;\n\tu32 bps=0;\n\t//u32 atag=0;\n\tu32 nal_len=4;\n\tu32 width = 0;\n\tu32 height = 0;\n\tu32 timescale = 10000000;\n\tu64 tfdt = 0;\n\tchar sz4cc[5];\n\tchar CodecParams[2048];\n\tu32 CodecParamLen=0;\n\tchar *sep, *val;\n\tGF_TrackBox *trak;\n\tGF_TrackExtendsBox *trex;\n\tGF_SampleTableBox *stbl;\n\n\tsz4cc[0] = 0;\n\n\tval = (char*) ( fileName + strlen(\"isobmff://\") );\n\twhile (1)  {\n\t\tsep = strchr(val, ' ');\n\t\tif (sep) sep[0] = 0;\n\n\t\tif (!strncmp(val, \"4cc=\", 4)) strcpy(sz4cc, val+4);\n\t\telse if (!strncmp(val, \"init=\", 5)) {\n\t\t\tchar szH[3], *data = val+5;\n\t\t\tu32 i, len = (u32) strlen(data);\n\t\t\tfor (i=0; i<len; i+=2) {\n\t\t\t\tu32 v;\n\t\t\t\t//init is hex-encoded so 2 input bytes for one output char\n\t\t\t\tszH[0] = data[i];\n\t\t\t\tszH[1] = data[i+1];\n\t\t\t\tszH[2] = 0;\n\t\t\t\tsscanf(szH, \"%X\", &v);\n\t\t\t\tCodecParams[CodecParamLen] = (char) v;\n\t\t\t\tCodecParamLen++;\n\t\t\t}\n\t\t}\n\t\telse if (!strncmp(val, \"nal=\", 4)) nal_len = atoi(val+4);\n\t\telse if (!strncmp(val, \"bps=\", 4)) bps = atoi(val+4);\n\t\t//else if (!strncmp(val, \"atag=\", 5)) atag = atoi(val+5);\n\t\telse if (!strncmp(val, \"ch=\", 3)) nb_channels = atoi(val+3);\n\t\telse if (!strncmp(val, \"srate=\", 6)) sample_rate = atoi(val+6);\n\t\telse if (!strncmp(val, \"w=\", 2)) width = atoi(val+2);\n\t\telse if (!strncmp(val, \"h=\", 2)) height = atoi(val+2);\n\t\telse if (!strncmp(val, \"scale=\", 6)) timescale = atoi(val+6);\n\t\telse if (!strncmp(val, \"tfdt=\", 5)) {\n\t\t\tsscanf(val+5, LLX, &tfdt);\n\t\t}\n\t\tif (!sep) break;\n\t\tsep[0] = ' ';\n\t\tval = sep+1;\n\t}\n\tif (!stricmp(sz4cc, \"H264\") || !stricmp(sz4cc, \"AVC1\")) {\n\t}\n\telse if (!stricmp(sz4cc, \"AACL\")) {\n\t}\n\telse {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Cannot convert smooth media type %s to ISO init segment\\n\", sz4cc));\n\t\treturn GF_NOT_SUPPORTED;\n\t}\n\n\tfile->moov = (GF_MovieBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_MOOV);\n\tif (!file->moov) return GF_OUT_OF_MEM;\n\tgf_list_add(file->TopBoxes, file->moov);\n\tfile->moov->mov = file;\n\tfile->is_smooth = GF_TRUE;\n\tfile->moov->mvhd = (GF_MovieHeaderBox *) gf_isom_box_new_parent(&file->moov->child_boxes, GF_ISOM_BOX_TYPE_MVHD);\n\tif (!file->moov->mvhd) return GF_OUT_OF_MEM;\n\tfile->moov->mvhd->timeScale = timescale;\n\tfile->moov->mvex = (GF_MovieExtendsBox *) gf_isom_box_new_parent(&file->moov->child_boxes, GF_ISOM_BOX_TYPE_MVEX);\n\tif (!file->moov->mvex) return GF_OUT_OF_MEM;\n\ttrex = (GF_TrackExtendsBox *) gf_isom_box_new_parent(&file->moov->mvex->child_boxes, GF_ISOM_BOX_TYPE_TREX);\n\tif (!trex) return GF_OUT_OF_MEM;\n\n\ttrex->def_sample_desc_index = 1;\n\ttrex->trackID = 1;\n\tgf_list_add(file->moov->mvex->TrackExList, trex);\n\n\ttrak = (GF_TrackBox *) gf_isom_box_new_parent(&file->moov->child_boxes, GF_ISOM_BOX_TYPE_TRAK);\n\tif (!trak) return GF_OUT_OF_MEM;\n\ttrak->moov = file->moov;\n\tgf_list_add(file->moov->trackList, trak);\n\n\ttrak->Header = (GF_TrackHeaderBox *) gf_isom_box_new_parent(&trak->child_boxes, GF_ISOM_BOX_TYPE_TKHD);\n\tif (!trak->Header) return GF_OUT_OF_MEM;\n\ttrak->Header->trackID = 1;\n\ttrak->Header->flags |= 1;\n\ttrak->Header->width = width;\n\ttrak->Header->height = height;\n\n\ttrak->Media = (GF_MediaBox *) gf_isom_box_new_parent(&trak->child_boxes, GF_ISOM_BOX_TYPE_MDIA);\n\tif (!trak->Media) return GF_OUT_OF_MEM;\n\ttrak->Media->mediaTrack = trak;\n\ttrak->Media->mediaHeader = (GF_MediaHeaderBox *) gf_isom_box_new_parent(&trak->Media->child_boxes, GF_ISOM_BOX_TYPE_MDHD);\n\tif (!trak->Media->mediaHeader) return GF_OUT_OF_MEM;\n\ttrak->Media->mediaHeader->timeScale = timescale;\n\n\ttrak->Media->handler = (GF_HandlerBox *) gf_isom_box_new_parent(&trak->Media->child_boxes,GF_ISOM_BOX_TYPE_HDLR);\n\tif (!trak->Media->handler) return GF_OUT_OF_MEM;\n    //we assume by default vide for handler type (only used for smooth streaming)\n\ttrak->Media->handler->handlerType = width ? GF_ISOM_MEDIA_VISUAL : GF_ISOM_MEDIA_AUDIO;\n\n\ttrak->Media->information = (GF_MediaInformationBox *) gf_isom_box_new_parent(&trak->Media->child_boxes, GF_ISOM_BOX_TYPE_MINF);\n\tif (!trak->Media->information) return GF_OUT_OF_MEM;\n\ttrak->Media->information->sampleTable = (GF_SampleTableBox *) gf_isom_box_new_parent(&trak->Media->information->child_boxes, GF_ISOM_BOX_TYPE_STBL);\n\tif (!trak->Media->information->sampleTable) return GF_OUT_OF_MEM;\n\n\tstbl = trak->Media->information->sampleTable;\n\tstbl->SampleSize = (GF_SampleSizeBox *) gf_isom_box_new_parent(&stbl->child_boxes, GF_ISOM_BOX_TYPE_STSZ);\n\tif (!stbl->SampleSize) return GF_OUT_OF_MEM;\n\tstbl->TimeToSample = (GF_TimeToSampleBox *) gf_isom_box_new_parent(&stbl->child_boxes, GF_ISOM_BOX_TYPE_STTS);\n\tif (!stbl->TimeToSample) return GF_OUT_OF_MEM;\n\tstbl->ChunkOffset = (GF_Box *) gf_isom_box_new_parent(&stbl->child_boxes, GF_ISOM_BOX_TYPE_STCO);\n\tif (!stbl->ChunkOffset) return GF_OUT_OF_MEM;\n\tstbl->SampleToChunk = (GF_SampleToChunkBox *) gf_isom_box_new_parent(&stbl->child_boxes, GF_ISOM_BOX_TYPE_STSC);\n\tif (!stbl->SampleToChunk) return GF_OUT_OF_MEM;\n\tstbl->SyncSample = (GF_SyncSampleBox *) gf_isom_box_new_parent(&stbl->child_boxes, GF_ISOM_BOX_TYPE_STSS);\n\tif (!stbl->SyncSample) return GF_OUT_OF_MEM;\n\tstbl->SampleDescription = (GF_SampleDescriptionBox *) gf_isom_box_new_parent(&stbl->child_boxes, GF_ISOM_BOX_TYPE_STSD);\n\tif (!stbl->SampleDescription) return GF_OUT_OF_MEM;\n\n\ttrak->dts_at_seg_start = tfdt;\n\ttrak->dts_at_next_seg_start = tfdt;\n\n\n\tif (!stricmp(sz4cc, \"H264\") || !stricmp(sz4cc, \"AVC1\")) {\n#ifndef GPAC_DISABLE_AV_PARSERS\n\t\tu32 pos = 0;\n\t\tu32 end, sc_size=0;\n#endif\n\t\tGF_MPEGVisualSampleEntryBox *avc =  (GF_MPEGVisualSampleEntryBox *) gf_isom_box_new_parent(&stbl->SampleDescription->child_boxes, GF_ISOM_BOX_TYPE_AVC1);\n\t\tif (!avc) return GF_OUT_OF_MEM;\n\t\tavc->avc_config =  (GF_AVCConfigurationBox *) gf_isom_box_new_parent(&avc->child_boxes, GF_ISOM_BOX_TYPE_AVCC);\n\t\tif (!avc->avc_config) return GF_OUT_OF_MEM;\n\n\t\tavc->Width = width;\n\t\tavc->Height = height;\n\n\t\tavc->avc_config->config = gf_odf_avc_cfg_new();\n\t\tavc->avc_config->config->nal_unit_size = nal_len;\n\t\tavc->avc_config->config->configurationVersion = 1;\n\n#ifndef GPAC_DISABLE_AV_PARSERS\n\t\t//locate pps and sps\n\t\tgf_media_nalu_next_start_code((u8 *) CodecParams, CodecParamLen, &sc_size);\n\t\tpos += sc_size;\n\t\twhile (pos<CodecParamLen) {\n\t\t\tGF_NALUFFParam *slc;\n\t\t\tu8 nal_type;\n\t\t\tchar *nal = &CodecParams[pos];\n\t\t\tend = gf_media_nalu_next_start_code(nal, CodecParamLen-pos, &sc_size);\n\t\t\tif (!end) end = CodecParamLen;\n\n\t\t\tGF_SAFEALLOC(slc, GF_NALUFFParam);\n\t\t\tif (!slc) break;\n\t\t\tslc->size = end;\n\t\t\tslc->data = gf_malloc(sizeof(char)*slc->size);\n\t\t\tif (!slc->data) return GF_OUT_OF_MEM;\n\t\t\tmemcpy(slc->data, nal, sizeof(char)*slc->size);\n\n\t\t\tnal_type = nal[0] & 0x1F;\n\t\t\tif (nal_type == GF_AVC_NALU_SEQ_PARAM) {\n/*\t\t\t\tAVCState avcc;\n\t\t\t\tu32 idx = gf_avc_read_sps(slc->data, slc->size, &avcc, 0, NULL);\n\t\t\t\tavc->avc_config->config->profile_compatibility = avcc.sps[idx].prof_compat;\n\t\t\t\tavc->avc_config->config->AVCProfileIndication = avcc.sps[idx].profile_idc;\n\t\t\t\tavc->avc_config->config->AVCLevelIndication = avcc.sps[idx].level_idc;\n\t\t\t\tavc->avc_config->config->chroma_format = avcc.sps[idx].chroma_format;\n\t\t\t\tavc->avc_config->config->luma_bit_depth = 8 + avcc.sps[idx].luma_bit_depth_m8;\n\t\t\t\tavc->avc_config->config->chroma_bit_depth = 8 + avcc.sps[idx].chroma_bit_depth_m8;\n*/\n\n\t\t\t\tgf_list_add(avc->avc_config->config->sequenceParameterSets, slc);\n\t\t\t} else {\n\t\t\t\tgf_list_add(avc->avc_config->config->pictureParameterSets, slc);\n\t\t\t}\n\t\t\tpos += slc->size + sc_size;\n\t\t}\n#endif\n\n\t\tAVC_RewriteESDescriptor(avc);\n\t}\n\telse if (!stricmp(sz4cc, \"AACL\")) {\n#ifndef GPAC_DISABLE_AV_PARSERS\n\t\tGF_M4ADecSpecInfo aacinfo;\n#endif\n\n\t\tGF_MPEGAudioSampleEntryBox *aac =  (GF_MPEGAudioSampleEntryBox *) gf_isom_box_new_parent(&stbl->SampleDescription->child_boxes, GF_ISOM_BOX_TYPE_MP4A);\n\t\tif (!aac) return GF_OUT_OF_MEM;\n\t\taac->esd = (GF_ESDBox *) gf_isom_box_new_parent(&aac->child_boxes, GF_ISOM_BOX_TYPE_ESDS);\n\t\tif (!aac->esd) return GF_OUT_OF_MEM;\n\t\taac->esd->desc = gf_odf_desc_esd_new(2);\n\t\tif (!aac->esd->desc) return GF_OUT_OF_MEM;\n#ifndef GPAC_DISABLE_AV_PARSERS\n\t\tmemset(&aacinfo, 0, sizeof(GF_M4ADecSpecInfo));\n\t\taacinfo.nb_chan = nb_channels;\n\t\taacinfo.base_object_type = GF_M4A_AAC_LC;\n\t\taacinfo.base_sr = sample_rate;\n\t\tgf_m4a_write_config(&aacinfo, &aac->esd->desc->decoderConfig->decoderSpecificInfo->data, &aac->esd->desc->decoderConfig->decoderSpecificInfo->dataLength);\n#endif\n\t\taac->esd->desc->decoderConfig->streamType = GF_STREAM_AUDIO;\n\t\taac->esd->desc->decoderConfig->objectTypeIndication = GF_CODECID_AAC_MPEG4;\n\t\taac->bitspersample = bps;\n\t\taac->samplerate_hi = sample_rate;\n\t\taac->channel_count = nb_channels;\n\t}\n\n\treturn GF_OK;\n}\n\n/**************************************************************\n\t\t\t\t\tFile Opening in streaming mode\n\t\t\tthe file map is regular (through FILE handles)\n**************************************************************/\nGF_EXPORT\nGF_Err gf_isom_open_progressive_ex(const char *fileName, u64 start_range, u64 end_range, Bool enable_frag_bounds, GF_ISOFile **the_file, u64 *BytesMissing, u32 *outBoxType)\n{\n\tGF_Err e;\n\tGF_ISOFile *movie;\n\n\tif (!BytesMissing || !the_file)\n\t\treturn GF_BAD_PARAM;\n\t*BytesMissing = 0;\n\t*the_file = NULL;\n\n\tmovie = gf_isom_new_movie();\n\tif (!movie) return GF_OUT_OF_MEM;\n\n\tmovie->fileName = gf_strdup(fileName);\n\tmovie->openMode = GF_ISOM_OPEN_READ;\n\tmovie->signal_frag_bounds = enable_frag_bounds;\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\tmovie->editFileMap = NULL;\n\tmovie->finalName = NULL;\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\tif (!strncmp(fileName, \"isobmff://\", 10)) {\n\t\tmovie->movieFileMap = NULL;\n\t\te = isom_create_init_from_mem(fileName, movie);\n\t} else {\n\t\t//do NOT use FileMapping on incomplete files\n\t\te = gf_isom_datamap_new(fileName, NULL, GF_ISOM_DATA_MAP_READ, &movie->movieFileMap);\n\t\tif (e) {\n\t\t\tgf_isom_delete_movie(movie);\n\t\t\treturn e;\n\t\t}\n\n\t\tif (start_range || end_range) {\n\t\t\tif (end_range>start_range) {\n\t\t\t\tgf_bs_seek(movie->movieFileMap->bs, end_range+1);\n\t\t\t\tgf_bs_truncate(movie->movieFileMap->bs);\n\t\t\t}\n\t\t\tgf_bs_seek(movie->movieFileMap->bs, start_range);\n\t\t}\n\t\te = gf_isom_parse_movie_boxes(movie, outBoxType, BytesMissing, GF_TRUE);\n\n\t}\n\tif (e == GF_ISOM_INCOMPLETE_FILE) {\n\t\t//if we have a moov, we're fine\n\t\tif (movie->moov) {\n\t\t\t*the_file = (GF_ISOFile *)movie;\n\t\t\treturn GF_OK;\n\t\t}\n\t\t//if not, delete the movie\n\t\tgf_isom_delete_movie(movie);\n\t\treturn e;\n\t} else if (e) {\n\t\t//if not, delete the movie\n\t\tgf_isom_delete_movie(movie);\n\t\treturn e;\n\t}\n\n\t//OK, let's return\n\t*the_file = (GF_ISOFile *)movie;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_open_progressive(const char *fileName, u64 start_range, u64 end_range, Bool enable_frag_bounds, GF_ISOFile **the_file, u64 *BytesMissing)\n{\n\treturn gf_isom_open_progressive_ex(fileName, start_range, end_range, enable_frag_bounds, the_file, BytesMissing, NULL);\n}\n\n/**************************************************************\n\t\t\t\t\tFile Reading\n**************************************************************/\n\nGF_EXPORT\nGF_ISOFile *gf_isom_open(const char *fileName, GF_ISOOpenMode OpenMode, const char *tmp_dir)\n{\n\tGF_ISOFile *movie;\n\tMP4_API_IO_Err = GF_OK;\n\n\tswitch (OpenMode & 0xFF) {\n\tcase GF_ISOM_OPEN_READ_DUMP:\n\tcase GF_ISOM_OPEN_READ:\n\t\tmovie = gf_isom_open_file(fileName, OpenMode, NULL);\n\t\tbreak;\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\n\tcase GF_ISOM_OPEN_WRITE:\n\t\tmovie = gf_isom_create_movie(fileName, OpenMode, tmp_dir);\n\t\tbreak;\n\tcase GF_ISOM_OPEN_EDIT:\n\tcase GF_ISOM_OPEN_READ_EDIT:\n\tcase GF_ISOM_OPEN_KEEP_FRAGMENTS:\n\t\tmovie = gf_isom_open_file(fileName, OpenMode, tmp_dir);\n\t\tbreak;\n\tcase GF_ISOM_WRITE_EDIT:\n\t\tmovie = gf_isom_create_movie(fileName, OpenMode, tmp_dir);\n\t\tbreak;\n\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\tdefault:\n\t\treturn NULL;\n\t}\n\treturn (GF_ISOFile *) movie;\n}\n\n\n#if 0\n/*! gets access to the data bitstream  - see \\ref gf_isom_open\n\\param isom_file the target ISO file\n\\param out_bs set to the file input bitstream - do NOT destroy\n\\return error if any\n*/\nGF_Err gf_isom_get_bs(GF_ISOFile *movie, GF_BitStream **out_bs)\n{\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\tif (!movie || movie->openMode != GF_ISOM_OPEN_WRITE || !movie->editFileMap) //memory mode\n\t\treturn GF_NOT_SUPPORTED;\n\n\tif (movie->segment_bs)\n\t\t*out_bs = movie->segment_bs;\n\telse\n\t\t*out_bs = movie->editFileMap->bs;\n\n\tif (movie->moof)\n\t\tmovie->moof->fragment_offset = 0;\n\n\treturn GF_OK;\n#else\n\treturn GF_NOT_SUPPORTED;\n#endif\n}\n#endif\n\n\nGF_EXPORT\nGF_Err gf_isom_write(GF_ISOFile *movie) {\n\tGF_Err e;\n\tif (movie == NULL) return GF_ISOM_INVALID_FILE;\n\te = GF_OK;\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\t//write our movie to the file\n\tif ((movie->openMode != GF_ISOM_OPEN_READ) && (movie->openMode != GF_ISOM_OPEN_READ_EDIT)) {\n\t\tgf_isom_get_duration(movie);\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\t\t//movie fragment mode, just store the fragment\n\t\tif ( (movie->openMode == GF_ISOM_OPEN_WRITE) && (movie->FragmentsFlags & GF_ISOM_FRAG_WRITE_READY) ) {\n\t\t\te = gf_isom_close_fragments(movie);\n\t\t\tif (e) return e;\n\t\t\t//in case of mfra box usage -> create mfro, calculate box sizes and write it out\n\t\t\tif (movie->mfra) {\n\t\t\t\tif (!movie->mfra->mfro) {\n\t\t\t\t\tmovie->mfra->mfro = (GF_MovieFragmentRandomAccessOffsetBox *)gf_isom_box_new_parent(&movie->mfra->child_boxes, GF_ISOM_BOX_TYPE_MFRO);\n\t\t\t\t\tif (!movie->mfra->mfro) return GF_OUT_OF_MEM;\n\t\t\t\t}\n\t\t\t\te = gf_isom_box_size((GF_Box *)movie->mfra);\n\t\t\t\tif (e) return e;\n\t\t\t\tmovie->mfra->mfro->container_size = (u32) movie->mfra->size;\n\n\t\t\t\t//write mfra\n\t\t\t\tif (!strcmp(movie->fileName, \"_gpac_isobmff_redirect\") && movie->on_block_out) {\n\t\t\t\t\tGF_BitStream *bs = gf_bs_new_cbk(movie->on_block_out, movie->on_block_out_usr_data, movie->on_block_out_block_size);\n\n\t\t\t\t\te = gf_isom_box_write((GF_Box *)movie->mfra, bs);\n\t\t\t\t\tgf_bs_del(bs);\n\t\t\t\t} else {\n\t\t\t\t\te = gf_isom_box_write((GF_Box *)movie->mfra, movie->editFileMap->bs);\n\t\t\t\t}\n\t\t\t}\n\t\t} else\n#endif\n\t\t\te = WriteToFile(movie, GF_FALSE);\n\t}\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\tif (movie->moov) {\n\t\tu32 i;\n\t\tfor (i=0; i<gf_list_count(movie->moov->trackList); i++) {\n\t\t\tGF_TrackBox *trak = (GF_TrackBox*)gf_list_get(movie->moov->trackList, i);\n\t\t\t/*delete any pending dataHandler of scalable enhancements*/\n\t\t\tif (trak->Media && trak->Media->information && trak->Media->information->scalableDataHandler && (trak->Media->information->scalableDataHandler != movie->movieFileMap))\n\t\t\t\tgf_isom_datamap_del(trak->Media->information->scalableDataHandler);\n\t\t}\n\t}\n#endif\n\n\treturn e;\n}\n\nGF_EXPORT\nGF_Err gf_isom_close(GF_ISOFile *movie)\n{\n\tGF_Err e=GF_OK;\n\tif (movie == NULL) return GF_ISOM_INVALID_FILE;\n\te = gf_isom_write(movie);\n\t//free and return;\n\tgf_isom_delete_movie(movie);\n\treturn e;\n}\n\n\n#if 0 //unused\n/*! checks if files has root OD/IOD or not\n\\param isom_file the target ISO file\n\\return GF_TRUE if the file has a root OD or IOD */\nBool gf_isom_has_root_od(GF_ISOFile *movie)\n{\n\tif (!movie || !movie->moov || !movie->moov->iods || !movie->moov->iods->descriptor) return GF_FALSE;\n\treturn GF_TRUE;\n}\n#endif\n\nGF_EXPORT\nvoid gf_isom_disable_odf_conversion(GF_ISOFile *movie, Bool disable)\n{\n\tif (movie) movie->disable_odf_translate = disable;\n}\n\n//this funct is used for exchange files, where the iods contains an OD\nGF_EXPORT\nGF_Descriptor *gf_isom_get_root_od(GF_ISOFile *movie)\n{\n\tGF_Descriptor *desc;\n\tGF_ObjectDescriptor *od;\n\tGF_InitialObjectDescriptor *iod;\n\tGF_IsomObjectDescriptor *isom_od;\n\tGF_IsomInitialObjectDescriptor *isom_iod;\n\tGF_ESD *esd;\n\tGF_ES_ID_Inc *inc;\n\tu32 i;\n\tu8 useIOD;\n\n\tif (!movie || !movie->moov) return NULL;\n\tif (!movie->moov->iods) return NULL;\n\n\tif (movie->disable_odf_translate) {\n\t\t//duplicate our descriptor\n\t\tmovie->LastError = gf_odf_desc_copy((GF_Descriptor *) movie->moov->iods->descriptor, &desc);\n\t\tif (movie->LastError) return NULL;\n\t\treturn desc;\n\t}\n\tod = NULL;\n\tiod = NULL;\n\n\tswitch (movie->moov->iods->descriptor->tag) {\n\tcase GF_ODF_ISOM_OD_TAG:\n\t\tod = (GF_ObjectDescriptor*)gf_malloc(sizeof(GF_ObjectDescriptor));\n\t\tif (!od) return NULL;\n\n\t\tmemset(od, 0, sizeof(GF_ObjectDescriptor));\n\t\tod->ESDescriptors = gf_list_new();\n\t\tuseIOD = 0;\n\t\tbreak;\n\tcase GF_ODF_ISOM_IOD_TAG:\n\t\tiod = (GF_InitialObjectDescriptor*)gf_malloc(sizeof(GF_InitialObjectDescriptor));\n\t\tif (!iod) return NULL;\n\n\t\tmemset(iod, 0, sizeof(GF_InitialObjectDescriptor));\n\t\tiod->ESDescriptors = gf_list_new();\n\t\tuseIOD = 1;\n\t\tbreak;\n\tdefault:\n\t\treturn NULL;\n\t}\n\n\t//duplicate our descriptor\n\tmovie->LastError = gf_odf_desc_copy((GF_Descriptor *) movie->moov->iods->descriptor, &desc);\n\tif (movie->LastError) return NULL;\n\n\tif (!useIOD) {\n\t\tisom_od = (GF_IsomObjectDescriptor *)desc;\n\t\tod->objectDescriptorID = isom_od->objectDescriptorID;\n\t\tod->extensionDescriptors = isom_od->extensionDescriptors;\n\t\tisom_od->extensionDescriptors = NULL;\n\t\tod->IPMP_Descriptors = isom_od->IPMP_Descriptors;\n\t\tisom_od->IPMP_Descriptors = NULL;\n\t\tod->OCIDescriptors = isom_od->OCIDescriptors;\n\t\tisom_od->OCIDescriptors = NULL;\n\t\tod->URLString = isom_od->URLString;\n\t\tisom_od->URLString = NULL;\n\t\tod->tag = GF_ODF_OD_TAG;\n\t\t//then recreate the desc in Inc\n\t\ti=0;\n\t\twhile ((inc = (GF_ES_ID_Inc*)gf_list_enum(isom_od->ES_ID_IncDescriptors, &i))) {\n\t\t\tmovie->LastError = GetESDForTime(movie->moov, inc->trackID, 0, &esd);\n\t\t\tif (!movie->LastError) movie->LastError = gf_list_add(od->ESDescriptors, esd);\n\t\t\tif (movie->LastError) {\n\t\t\t\tgf_odf_desc_del(desc);\n\t\t\t\tgf_odf_desc_del((GF_Descriptor *) od);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t\tgf_odf_desc_del(desc);\n\t\treturn (GF_Descriptor *)od;\n\t} else {\n\t\tisom_iod = (GF_IsomInitialObjectDescriptor *)desc;\n\t\tiod->objectDescriptorID = isom_iod->objectDescriptorID;\n\t\tiod->extensionDescriptors = isom_iod->extensionDescriptors;\n\t\tisom_iod->extensionDescriptors = NULL;\n\t\tiod->IPMP_Descriptors = isom_iod->IPMP_Descriptors;\n\t\tisom_iod->IPMP_Descriptors = NULL;\n\t\tiod->OCIDescriptors = isom_iod->OCIDescriptors;\n\t\tisom_iod->OCIDescriptors = NULL;\n\t\tiod->URLString = isom_iod->URLString;\n\t\tisom_iod->URLString = NULL;\n\t\tiod->tag = GF_ODF_IOD_TAG;\n\n\t\tiod->audio_profileAndLevel = isom_iod->audio_profileAndLevel;\n\t\tiod->graphics_profileAndLevel = isom_iod->graphics_profileAndLevel;\n\t\tiod->inlineProfileFlag = isom_iod->inlineProfileFlag;\n\t\tiod->OD_profileAndLevel = isom_iod->OD_profileAndLevel;\n\t\tiod->scene_profileAndLevel = isom_iod->scene_profileAndLevel;\n\t\tiod->visual_profileAndLevel = isom_iod->visual_profileAndLevel;\n\t\tiod->IPMPToolList = isom_iod->IPMPToolList;\n\t\tisom_iod->IPMPToolList = NULL;\n\n\t\t//then recreate the desc in Inc\n\t\ti=0;\n\t\twhile ((inc = (GF_ES_ID_Inc*)gf_list_enum(isom_iod->ES_ID_IncDescriptors, &i))) {\n\t\t\tmovie->LastError = GetESDForTime(movie->moov, inc->trackID, 0, &esd);\n\t\t\tif (!movie->LastError) movie->LastError = gf_list_add(iod->ESDescriptors, esd);\n\t\t\tif (movie->LastError) {\n\t\t\t\tgf_odf_desc_del(desc);\n\t\t\t\tgf_odf_desc_del((GF_Descriptor *) iod);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t\tgf_odf_desc_del(desc);\n\t\treturn (GF_Descriptor *)iod;\n\t}\n}\n\n\nGF_EXPORT\nu32 gf_isom_get_track_count(GF_ISOFile *movie)\n{\n\tif (!movie || !movie->moov) return 0;\n\n\tif (!movie->moov->trackList) {\n\t\tmovie->LastError = GF_ISOM_INVALID_FILE;\n\t\treturn 0;\n\t}\n\treturn gf_list_count(movie->moov->trackList);\n}\n\n\nGF_EXPORT\nGF_ISOTrackID gf_isom_get_track_id(GF_ISOFile *movie, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\tif (!movie) return 0;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !trak->Header) return 0;\n\treturn trak->Header->trackID;\n}\n\n\nGF_EXPORT\nu32 gf_isom_get_track_by_id(GF_ISOFile *the_file, GF_ISOTrackID trackID)\n{\n\tu32 count;\n\tu32 i;\n\tif (the_file == NULL) return 0;\n\n\tcount = gf_isom_get_track_count(the_file);\n\tif (!count) return 0;\n\tfor (i = 0; i < count; i++) {\n\t\tGF_TrackBox *trak = gf_isom_get_track_from_file(the_file, i+1);\n\t\tif (!trak || !trak->Header) return 0;\n\t\tif (trak->Header->trackID == trackID) return i+1;\n\t}\n\treturn 0;\n}\n\nGF_EXPORT\nGF_ISOTrackID gf_isom_get_track_original_id(GF_ISOFile *movie, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\tif (!movie) return 0;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return 0;\n\treturn trak->originalID;\n}\n\n//return the timescale of the movie, 0 if error\nGF_EXPORT\nBool gf_isom_has_movie(GF_ISOFile *file)\n{\n\tif (file && file->moov) return GF_TRUE;\n\treturn GF_FALSE;\n}\n\n#ifndef GPAC_DISABLE_ISOM\nGF_EXPORT\nBool gf_isom_has_segment(GF_ISOFile *file, u32 *brand, u32 *version)\n{\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\tu32 i;\n\tGF_Box *a;\n\ti = 0;\n\twhile (NULL != (a = (GF_Box*)gf_list_enum(file->TopBoxes, &i))) {\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t\tif (a->type == GF_ISOM_BOX_TYPE_STYP) {\n\t\t\tGF_FileTypeBox *styp = (GF_FileTypeBox *)a;\n\t\t\t*brand = styp->majorBrand;\n\t\t\t*version = styp->minorVersion;\n\t\t\treturn GF_TRUE;\n\t\t}\n#endif\n\t}\n#endif\n\treturn GF_FALSE;\n}\n\nGF_EXPORT\nu32 gf_isom_segment_get_fragment_count(GF_ISOFile *file)\n{\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\tif (file) {\n\t\tu32 i, count = 0;\n\t\tfor (i=0; i<gf_list_count(file->TopBoxes); i++) {\n\t\t\tGF_Box *a = (GF_Box*)gf_list_get(file->TopBoxes, i);\n\t\t\tif (a->type==GF_ISOM_BOX_TYPE_MOOF) count++;\n\t\t}\n\t\treturn count;\n\t}\n#endif\n\treturn 0;\n}\n\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\nstatic GF_MovieFragmentBox *gf_isom_get_moof(GF_ISOFile *file, u32 moof_index)\n{\n\tu32 i;\n\tfor (i=0; i<gf_list_count(file->TopBoxes); i++) {\n\t\tGF_Box *a = (GF_Box*)gf_list_get(file->TopBoxes, i);\n\t\tif (a->type==GF_ISOM_BOX_TYPE_MOOF) {\n\t\t\tmoof_index--;\n\t\t\tif (!moof_index) return (GF_MovieFragmentBox *) a;\n\t\t}\n\t}\n\treturn NULL;\n}\n#endif /* GPAC_DISABLE_ISOM_FRAGMENTS */\n\nGF_EXPORT\nu32 gf_isom_segment_get_track_fragment_count(GF_ISOFile *file, u32 moof_index)\n{\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\tGF_MovieFragmentBox *moof;\n\tif (!file) return 0;\n\tgf_list_count(file->TopBoxes);\n\tmoof = gf_isom_get_moof(file, moof_index);\n\treturn moof ? gf_list_count(moof->TrackList) : 0;\n#endif\n\treturn 0;\n}\n\nGF_EXPORT\nu32 gf_isom_segment_get_track_fragment_decode_time(GF_ISOFile *file, u32 moof_index, u32 traf_index, u64 *decode_time)\n{\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\tGF_MovieFragmentBox *moof;\n\tGF_TrackFragmentBox *traf;\n\tif (!file) return 0;\n\tgf_list_count(file->TopBoxes);\n\tmoof = gf_isom_get_moof(file, moof_index);\n\ttraf = moof ? (GF_TrackFragmentBox*)gf_list_get(moof->TrackList, traf_index-1) : NULL;\n\tif (!traf) return 0;\n\tif (decode_time) {\n\t\t*decode_time = traf->tfdt ? traf->tfdt->baseMediaDecodeTime : 0;\n\t}\n\treturn traf->tfhd->trackID;\n#endif\n\treturn 0;\n}\n#endif\n\n//return the timescale of the movie, 0 if error\nGF_EXPORT\nu32 gf_isom_get_timescale(GF_ISOFile *movie)\n{\n\tif (!movie || !movie->moov || !movie->moov->mvhd) return 0;\n\treturn movie->moov->mvhd->timeScale;\n}\n\n\n//return the duration of the movie, 0 if error\nGF_EXPORT\nu64 gf_isom_get_duration(GF_ISOFile *movie)\n{\n\tif (!movie || !movie->moov || !movie->moov->mvhd) return 0;\n\n\t//if file was open in Write or Edit mode, recompute the duration\n\t//the duration of a movie is the MaxDuration of all the tracks...\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\tgf_isom_update_duration(movie);\n#endif /*GPAC_DISABLE_ISOM_WRITE*/\n\n\treturn movie->moov->mvhd->duration;\n}\n//return the duration of the movie, 0 if error\nGF_EXPORT\nu64 gf_isom_get_original_duration(GF_ISOFile *movie)\n{\n\tif (!movie || !movie->moov|| !movie->moov->mvhd) return 0;\n\treturn movie->moov->mvhd->original_duration;\n}\n\n//return the creation info of the movie\nGF_EXPORT\nGF_Err gf_isom_get_creation_time(GF_ISOFile *movie, u64 *creationTime, u64 *modificationTime)\n{\n\tif (!movie || !movie->moov) return GF_BAD_PARAM;\n\n\tif (creationTime) *creationTime = movie->moov->mvhd->creationTime;\n\tif (creationTime) *modificationTime = movie->moov->mvhd->modificationTime;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_track_creation_time(GF_ISOFile *movie, u32 trackNumber, u64 *creationTime, u64 *modificationTime)\n{\n\tGF_TrackBox *trak;\n\tif (!movie || !movie->moov) return GF_BAD_PARAM;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return 0;\n\n\tif (creationTime) *creationTime = trak->Media->mediaHeader->creationTime;\n\tif (creationTime) *modificationTime = trak->Media->mediaHeader->modificationTime;\n\treturn GF_OK;\n}\n\n//check the presence of a track in IOD. 0: NO, 1: YES, 2: ERROR\nGF_EXPORT\nu8 gf_isom_is_track_in_root_od(GF_ISOFile *movie, u32 trackNumber)\n{\n\tu32 i;\n\tGF_ISOTrackID trackID;\n\tGF_Descriptor *desc;\n\tGF_ES_ID_Inc *inc;\n\tGF_List *inc_list;\n\tif (!movie) return 2;\n\tif (!movie->moov || !movie->moov->iods) return 0;\n\n\tdesc = movie->moov->iods->descriptor;\n\tswitch (desc->tag) {\n\tcase GF_ODF_ISOM_IOD_TAG:\n\t\tinc_list = ((GF_IsomInitialObjectDescriptor *)desc)->ES_ID_IncDescriptors;\n\t\tbreak;\n\tcase GF_ODF_ISOM_OD_TAG:\n\t\tinc_list = ((GF_IsomObjectDescriptor *)desc)->ES_ID_IncDescriptors;\n\t\tbreak;\n\t//files without IOD are possible !\n\tdefault:\n\t\treturn 0;\n\t}\n\ttrackID = gf_isom_get_track_id(movie, trackNumber);\n\tif (!trackID) return 2;\n\ti=0;\n\twhile ((inc = (GF_ES_ID_Inc*)gf_list_enum(inc_list, &i))) {\n\t\tif (inc->trackID == (u32) trackID) return 1;\n\t}\n\treturn 0;\n}\n\n\n\n//gets the enable flag of a track\n//0: NO, 1: YES, 2: ERROR\nGF_EXPORT\nu8 gf_isom_is_track_enabled(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\n\tif (!trak || !trak->Header) return 2;\n\treturn (trak->Header->flags & 1) ? 1 : 0;\n}\n\nGF_EXPORT\nu32 gf_isom_get_track_flags(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return 0;\n\treturn trak->Header->flags;\n}\n\n\n//get the track duration\n//return 0 if bad param\nGF_EXPORT\nu64 gf_isom_get_track_duration(GF_ISOFile *movie, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return 0;\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\t/*in all modes except dump recompute duration in case headers are wrong*/\n\tif (movie->openMode != GF_ISOM_OPEN_READ_DUMP) {\n\t\tSetTrackDuration(trak);\n\t}\n#endif\n\treturn trak->Header->duration;\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_media_language(GF_ISOFile *the_file, u32 trackNumber, char **lang)\n{\n\tu32 count;\n\tBool elng_found = GF_FALSE;\n\tGF_TrackBox *trak;\n\tif (!lang) {\n\t\treturn GF_BAD_PARAM;\n\t}\n\t*lang = NULL;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media) return GF_BAD_PARAM;\n\tcount = gf_list_count(trak->Media->child_boxes);\n\tif (count>0) {\n\t\tu32 i;\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tGF_Box *box = (GF_Box *)gf_list_get(trak->Media->child_boxes, i);\n\t\t\tif (box->type == GF_ISOM_BOX_TYPE_ELNG) {\n\t\t\t\t*lang = gf_strdup(((GF_ExtendedLanguageBox *)box)->extended_language);\n\t\t\t\treturn GF_OK;\n\t\t\t}\n\t\t}\n\t}\n\tif (!elng_found) {\n\t\t*lang = gf_strdup(trak->Media->mediaHeader->packedLanguage);\n\t}\n\treturn GF_OK;\n}\n\nGF_EXPORT\nu32 gf_isom_get_track_kind_count(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_UserDataBox *udta;\n\tGF_UserDataMap *map;\n\tif (trackNumber) {\n\t\tGF_TrackBox *trak = gf_isom_get_track_from_file(the_file, trackNumber);\n\t\tif (!trak) return 0;\n\t\tif (!trak->udta) {\n\t\t\treturn 0;\n\t\t}\n\t\tudta = trak->udta;\n\t} else {\n\t\treturn 0;\n\t}\n\tmap = udta_getEntry(udta, GF_ISOM_BOX_TYPE_KIND, NULL);\n\tif (!map) return 0;\n\n\treturn gf_list_count(map->boxes);\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_track_kind(GF_ISOFile *the_file, u32 trackNumber, u32 index, char **scheme, char **value)\n{\n\tGF_Err e;\n\tGF_UserDataBox *udta;\n\tGF_UserDataMap *map;\n\tGF_KindBox *kindBox;\n\tif (!scheme || !value) {\n\t\treturn GF_BAD_PARAM;\n\t}\n\t*scheme = NULL;\n\t*value = NULL;\n\n\tif (trackNumber) {\n\t\tGF_TrackBox *trak = gf_isom_get_track_from_file(the_file, trackNumber);\n\t\tif (!trak) return GF_BAD_PARAM;\n\t\tif (!trak->udta) {\n\t\t\te = trak_on_child_box((GF_Box*)trak, gf_isom_box_new_parent(&trak->child_boxes, GF_ISOM_BOX_TYPE_UDTA), GF_FALSE);\n\t\t\tif (e) return e;\n\t\t}\n\t\tudta = trak->udta;\n\t} else {\n\t\treturn GF_BAD_PARAM;\n\t}\n\tmap = udta_getEntry(udta, GF_ISOM_BOX_TYPE_KIND, NULL);\n\tif (!map) return GF_BAD_PARAM;\n\n\tkindBox = (GF_KindBox *)gf_list_get(map->boxes, index);\n\tif (!kindBox) return GF_BAD_PARAM;\n\n\t*scheme = gf_strdup(kindBox->schemeURI);\n\tif (kindBox->value) {\n\t\t*value = gf_strdup(kindBox->value);\n\t}\n\treturn GF_OK;\n}\n\n\n//Return the number of track references of a track for a given ReferenceType\n//return 0 if error\nGF_EXPORT\ns32 gf_isom_get_reference_count(GF_ISOFile *movie, u32 trackNumber, u32 referenceType)\n{\n\tGF_TrackBox *trak;\n\tGF_TrackReferenceTypeBox *dpnd;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return -1;\n\tif (!trak->References) return 0;\n\tif (movie->openMode == GF_ISOM_OPEN_WRITE) {\n\t\tmovie->LastError = GF_ISOM_INVALID_MODE;\n\t\treturn -1;\n\t}\n\n\tdpnd = NULL;\n\tif ( (movie->LastError = Track_FindRef(trak, referenceType, &dpnd)) ) return -1;\n\tif (!dpnd) return 0;\n\treturn dpnd->trackIDCount;\n}\n\n\n//Return the number of track references of a track for a given ReferenceType\n//return 0 if error\nGF_EXPORT\nconst GF_ISOTrackID *gf_isom_enum_track_references(GF_ISOFile *movie, u32 trackNumber, u32 idx, u32 *referenceType, u32 *referenceCount)\n{\n\tGF_TrackBox *trak;\n\tGF_TrackReferenceTypeBox *dpnd;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return NULL;\n\tif (!trak->References) return NULL;\n\tdpnd = gf_list_get(trak->References->child_boxes, idx);\n\tif (!dpnd) return NULL;\n\t*referenceType = dpnd->reference_type;\n\t*referenceCount = dpnd->trackIDCount;\n\treturn dpnd->trackIDs;\n}\n\n\n//Return the referenced track number for a track and a given ReferenceType and Index\n//return -1 if error, 0 if the reference is a NULL one, or the trackNumber\nGF_EXPORT\nGF_Err gf_isom_get_reference(GF_ISOFile *movie, u32 trackNumber, u32 referenceType, u32 referenceIndex, u32 *refTrack)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\tGF_TrackReferenceTypeBox *dpnd;\n\tGF_ISOTrackID refTrackNum;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\n\t*refTrack = 0;\n\tif (!trak || !trak->References) return GF_BAD_PARAM;\n\n\tdpnd = NULL;\n\te = Track_FindRef(trak, referenceType, &dpnd);\n\tif (e) return e;\n\tif (!dpnd) return GF_BAD_PARAM;\n\n\tif (!referenceIndex || (referenceIndex > dpnd->trackIDCount)) return GF_BAD_PARAM;\n\n\t//the spec allows a NULL reference\n\t//(ex, to force desync of a track, set a sync ref with ID = 0)\n\tif (dpnd->trackIDs[referenceIndex - 1] == 0) return GF_OK;\n\n\trefTrackNum = gf_isom_get_tracknum_from_id(movie->moov, dpnd->trackIDs[referenceIndex-1]);\n\n\t//if the track was not found, this means the file is broken !!!\n\tif (! refTrackNum) return GF_ISOM_INVALID_FILE;\n\t*refTrack = refTrackNum;\n\treturn GF_OK;\n}\n\n//Return the referenced track ID for a track and a given ReferenceType and Index\n//return -1 if error, 0 if the reference is a NULL one, or the trackNumber\nGF_EXPORT\nGF_Err gf_isom_get_reference_ID(GF_ISOFile *movie, u32 trackNumber, u32 referenceType, u32 referenceIndex, GF_ISOTrackID *refTrackID)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\tGF_TrackReferenceTypeBox *dpnd;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\n\t*refTrackID = 0;\n\tif (!trak || !trak->References || !referenceIndex) return GF_BAD_PARAM;\n\n\tdpnd = NULL;\n\te = Track_FindRef(trak, referenceType, &dpnd);\n\tif (e) return e;\n\tif (!dpnd) return GF_BAD_PARAM;\n\n\tif (referenceIndex > dpnd->trackIDCount) return GF_BAD_PARAM;\n\n\t*refTrackID = dpnd->trackIDs[referenceIndex-1];\n\n\treturn GF_OK;\n}\n\n//Return referenceIndex if the given track has a reference to the given TreckID of a given ReferenceType\n//return 0 if error\nGF_EXPORT\nu32 gf_isom_has_track_reference(GF_ISOFile *movie, u32 trackNumber, u32 referenceType, GF_ISOTrackID refTrackID)\n{\n\tu32 i;\n\tGF_TrackBox *trak;\n\tGF_TrackReferenceTypeBox *dpnd;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return 0;\n\tif (!trak->References) return 0;\n\n\tdpnd = NULL;\n\tif ( (movie->LastError = Track_FindRef(trak, referenceType, &dpnd)) ) return 0;\n\tif (!dpnd) return 0;\n\tfor (i=0; i<dpnd->trackIDCount; i++) {\n\t\tif (dpnd->trackIDs[i]==refTrackID) return i+1;\n\t}\n\treturn 0;\n}\n\n\n\n//Return the media time given the absolute time in the Movie\nGF_EXPORT\nGF_Err gf_isom_get_media_time(GF_ISOFile *the_file, u32 trackNumber, u32 movieTime, u64 *MediaTime)\n{\n\tGF_TrackBox *trak;\n\tu8 useEdit;\n\ts64 SegmentStartTime, mediaOffset;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !MediaTime) return GF_BAD_PARAM;\n\n\tSegmentStartTime = 0;\n\treturn GetMediaTime(trak, GF_FALSE, movieTime, MediaTime, &SegmentStartTime, &mediaOffset, &useEdit, NULL);\n}\n\n\n//Get the stream description index (eg, the ESD) for a given time IN MEDIA TIMESCALE\n//return 0 if error or if empty\nGF_EXPORT\nu32 gf_isom_get_sample_description_index(GF_ISOFile *movie, u32 trackNumber, u64 for_time)\n{\n\tu32 streamDescIndex;\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return 0;\n\n\tif ( (movie->LastError = Media_GetSampleDescIndex(trak->Media, for_time, &streamDescIndex)) ) {\n\t\treturn 0;\n\t}\n\treturn streamDescIndex;\n}\n\n//Get the number of \"streams\" stored in the media - a media can have several stream descriptions...\nGF_EXPORT\nu32 gf_isom_get_sample_description_count(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return 0;\n\n\treturn gf_list_count(trak->Media->information->sampleTable->SampleDescription->child_boxes);\n}\n\n\n//Get the GF_ESD given the StreamDescriptionIndex\n//THE DESCRIPTOR IS DUPLICATED, SO HAS TO BE DELETED BY THE APP\nGF_EXPORT\nGF_ESD *gf_isom_get_esd(GF_ISOFile *movie, u32 trackNumber, u32 StreamDescriptionIndex)\n{\n\tGF_ESD *esd;\n\tGF_Err e;\n\te = GetESD(movie->moov, gf_isom_get_track_id(movie, trackNumber), StreamDescriptionIndex, &esd);\n\tif (e && (e!= GF_ISOM_INVALID_MEDIA)) {\n\t\tmovie->LastError = e;\n\t\tif (esd) gf_odf_desc_del((GF_Descriptor *)esd);\n\t\treturn NULL;\n\t}\n\n\treturn esd;\n}\n\n//Get the decoderConfigDescriptor given the SampleDescriptionIndex\n//THE DESCRIPTOR IS DUPLICATED, SO HAS TO BE DELETED BY THE APP\nGF_EXPORT\nGF_DecoderConfig *gf_isom_get_decoder_config(GF_ISOFile *the_file, u32 trackNumber, u32 StreamDescriptionIndex)\n{\n\tGF_TrackBox *trak;\n\tGF_ESD *esd;\n\tGF_Descriptor *decInfo;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return NULL;\n\t//get the ESD (possibly emulated)\n\tMedia_GetESD(trak->Media, StreamDescriptionIndex, &esd, GF_FALSE);\n\tif (!esd) return NULL;\n\tdecInfo = (GF_Descriptor *) esd->decoderConfig;\n\tesd->decoderConfig = NULL;\n\tgf_odf_desc_del((GF_Descriptor *) esd);\n\treturn (GF_DecoderConfig *)decInfo;\n}\n\n\n//get the media duration (without edit)\n//return 0 if bad param\nGF_EXPORT\nu64 gf_isom_get_media_duration(GF_ISOFile *movie, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return 0;\n\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\n\t/*except in dump mode always recompute the duration*/\n\tif (movie->openMode != GF_ISOM_OPEN_READ_DUMP) {\n\t\tif ( (movie->LastError = Media_SetDuration(trak)) ) return 0;\n\t}\n\n#endif\n\n\treturn trak->Media->mediaHeader->duration;\n}\n\n//get the media duration (without edit)\n//return 0 if bad param\nGF_EXPORT\nu64 gf_isom_get_media_original_duration(GF_ISOFile *movie, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !trak->Media || !trak->Media->mediaHeader) return 0;\n\n\treturn trak->Media->mediaHeader->original_duration;\n}\n\n//Get the timeScale of the media. All samples DTS/CTS are expressed in this timeScale\nGF_EXPORT\nu32 gf_isom_get_media_timescale(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media || !trak->Media->mediaHeader) return 0;\n\treturn trak->Media->mediaHeader->timeScale;\n}\n\n\nGF_EXPORT\nu32 gf_isom_get_copyright_count(GF_ISOFile *mov)\n{\n\tGF_UserDataMap *map;\n\tif (!mov || !mov->moov || !mov->moov->udta) return 0;\n\tmap = udta_getEntry(mov->moov->udta, GF_ISOM_BOX_TYPE_CPRT, NULL);\n\tif (!map) return 0;\n\treturn gf_list_count(map->boxes);\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_copyright(GF_ISOFile *mov, u32 Index, const char **threeCharCode, const char **notice)\n{\n\tGF_UserDataMap *map;\n\tGF_CopyrightBox *cprt;\n\n\tif (!mov || !mov->moov || !Index) return GF_BAD_PARAM;\n\n\tif (!mov->moov->udta) return GF_OK;\n\tmap = udta_getEntry(mov->moov->udta, GF_ISOM_BOX_TYPE_CPRT, NULL);\n\tif (!map) return GF_OK;\n\n\tif (Index > gf_list_count(map->boxes)) return GF_BAD_PARAM;\n\n\tcprt = (GF_CopyrightBox*)gf_list_get(map->boxes, Index-1);\n\t(*threeCharCode) = cprt->packedLanguageCode;\n\t(*notice) = cprt->notice;\n\treturn GF_OK;\n}\n\n#if 0\nGF_Err gf_isom_get_watermark(GF_ISOFile *mov, bin128 UUID, u8** data, u32* length)\n{\n\tGF_UserDataMap *map;\n\tGF_UnknownUUIDBox *wm;\n\n\tif (!mov) return GF_BAD_PARAM;\n\tif (!mov->moov || !mov->moov->udta) return GF_NOT_SUPPORTED;\n\n\tmap = udta_getEntry(mov->moov->udta, GF_ISOM_BOX_TYPE_UUID, (bin128 *) & UUID);\n\tif (!map) return GF_NOT_SUPPORTED;\n\n\twm = (GF_UnknownUUIDBox*)gf_list_get(map->boxes, 0);\n\tif (!wm) return GF_NOT_SUPPORTED;\n\n\t*data = (u8 *) gf_malloc(sizeof(char)*wm->dataSize);\n\tif (! *data) return GF_OUT_OF_MEM;\n\tmemcpy(*data, wm->data, wm->dataSize);\n\t*length = wm->dataSize;\n\treturn GF_OK;\n}\n#endif\n\nGF_EXPORT\nu32 gf_isom_get_chapter_count(GF_ISOFile *movie, u32 trackNumber)\n{\n\tGF_UserDataMap *map;\n\tGF_ChapterListBox *lst;\n\tGF_UserDataBox *udta;\n\n\tif (!movie || !movie->moov) return 0;\n\n\tudta = NULL;\n\tif (trackNumber) {\n\t\tGF_TrackBox *trak = gf_isom_get_track_from_file(movie, trackNumber);\n\t\tif (!trak) return 0;\n\t\tudta = trak->udta;\n\t} else {\n\t\tudta = movie->moov->udta;\n\t}\n\tif (!udta) return 0;\n\tmap = udta_getEntry(udta, GF_ISOM_BOX_TYPE_CHPL, NULL);\n\tif (!map) return 0;\n\tlst = (GF_ChapterListBox *)gf_list_get(map->boxes, 0);\n\tif (!lst) return 0;\n\treturn gf_list_count(lst->list);\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_chapter(GF_ISOFile *movie, u32 trackNumber, u32 Index, u64 *chapter_time, const char **name)\n{\n\tGF_UserDataMap *map;\n\tGF_ChapterListBox *lst;\n\tGF_ChapterEntry *ce;\n\tGF_UserDataBox *udta;\n\n\tif (!movie || !movie->moov) return GF_BAD_PARAM;\n\n\tudta = NULL;\n\tif (trackNumber) {\n\t\tGF_TrackBox *trak = gf_isom_get_track_from_file(movie, trackNumber);\n\t\tif (!trak) return GF_BAD_PARAM;\n\t\tudta = trak->udta;\n\t} else {\n\t\tudta = movie->moov->udta;\n\t}\n\tif (!udta) return GF_BAD_PARAM;\n\tmap = udta_getEntry(movie->moov->udta, GF_ISOM_BOX_TYPE_CHPL, NULL);\n\tif (!map) return GF_BAD_PARAM;\n\tlst = (GF_ChapterListBox *)gf_list_get(map->boxes, 0);\n\tif (!lst) return GF_BAD_PARAM;\n\n\tce = (GF_ChapterEntry *)gf_list_get(lst->list, Index-1);\n\tif (!ce) return GF_BAD_PARAM;\n\tif (chapter_time) {\n\t\t*chapter_time = ce->start_time;\n\t\t*chapter_time /= 10000L;\n\t}\n\tif (name) *name = ce->name;\n\treturn GF_OK;\n}\n\n\nGF_EXPORT\nu32 gf_isom_get_media_type(GF_ISOFile *movie, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\treturn (trak->Media && trak->Media->handler) ? trak->Media->handler->handlerType : 0;\n}\n\nBool IsMP4Description(u32 entryType)\n{\n\tswitch (entryType) {\n\tcase GF_ISOM_BOX_TYPE_MP4S:\n\tcase GF_ISOM_BOX_TYPE_LSR1:\n\tcase GF_ISOM_BOX_TYPE_MP4A:\n\tcase GF_ISOM_BOX_TYPE_MP4V:\n\tcase GF_ISOM_BOX_TYPE_ENCA:\n\tcase GF_ISOM_BOX_TYPE_ENCV:\n\tcase GF_ISOM_BOX_TYPE_RESV:\n\tcase GF_ISOM_BOX_TYPE_ENCS:\n\t\treturn GF_TRUE;\n\tdefault:\n\t\treturn GF_FALSE;\n\t}\n}\n\nBool gf_isom_is_encrypted_entry(u32 entryType)\n{\n\tswitch (entryType) {\n\tcase GF_ISOM_BOX_TYPE_ENCA:\n\tcase GF_ISOM_BOX_TYPE_ENCV:\n\tcase GF_ISOM_BOX_TYPE_ENCS:\n\t\treturn GF_TRUE;\n\tdefault:\n\t\treturn GF_FALSE;\n\t}\n}\n\nGF_EXPORT\nBool gf_isom_is_track_encrypted(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\tu32 i=0;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return 2;\n\twhile (1) {\n\t\tGF_Box *entry = (GF_Box*)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, i);\n\t\tif (!entry) break;\n\t\tif (gf_isom_is_encrypted_entry(entry->type)) return GF_TRUE;\n\n\t\tif (gf_isom_is_cenc_media(the_file, trackNumber, i+1))\n\t\t\treturn GF_TRUE;\n\n\t\ti++;\n\t}\n\treturn GF_FALSE;\n}\n\nGF_EXPORT\nu32 gf_isom_get_media_subtype(GF_ISOFile *the_file, u32 trackNumber, u32 DescriptionIndex)\n{\n\tGF_TrackBox *trak;\n\tGF_Box *entry;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !DescriptionIndex || !trak->Media || !trak->Media->information || !trak->Media->information->sampleTable) return 0;\n\tentry = (GF_Box*)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, DescriptionIndex-1);\n\tif (!entry) return 0;\n\n\t//filter MPEG sub-types\n\tif (IsMP4Description(entry->type)) {\n\t\tif (gf_isom_is_encrypted_entry(entry->type)) return GF_ISOM_SUBTYPE_MPEG4_CRYP;\n\t\telse return GF_ISOM_SUBTYPE_MPEG4;\n\t}\n\tif (entry->type == GF_ISOM_BOX_TYPE_GNRV) {\n\t\treturn ((GF_GenericVisualSampleEntryBox *)entry)->EntryType;\n\t}\n\telse if (entry->type == GF_ISOM_BOX_TYPE_GNRA) {\n\t\treturn ((GF_GenericAudioSampleEntryBox *)entry)->EntryType;\n\t}\n\telse if (entry->type == GF_ISOM_BOX_TYPE_GNRM) {\n\t\treturn ((GF_GenericSampleEntryBox *)entry)->EntryType;\n\t}\n\treturn entry->type;\n}\n\nGF_EXPORT\nu32 gf_isom_get_mpeg4_subtype(GF_ISOFile *the_file, u32 trackNumber, u32 DescriptionIndex)\n{\n\tGF_TrackBox *trak;\n\tGF_Box *entry=NULL;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !DescriptionIndex) return 0;\n\n\tif (trak->Media\n\t\t&& trak->Media->information\n\t\t&& trak->Media->information->sampleTable\n\t\t&& trak->Media->information->sampleTable->SampleDescription\n\t) {\n\t\tentry = (GF_Box*)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, DescriptionIndex-1);\n\t}\n\tif (!entry) return 0;\n\n\t//filter MPEG sub-types\n\tif (!IsMP4Description(entry->type)) return 0;\n\treturn entry->type;\n}\n\n//Get the HandlerDescription name.\nGF_EXPORT\nGF_Err gf_isom_get_handler_name(GF_ISOFile *the_file, u32 trackNumber, const char **outName)\n{\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !outName) return GF_BAD_PARAM;\n\t*outName = trak->Media->handler->nameUTF8;\n\treturn GF_OK;\n}\n\n//Check the DataReferences of this track\nGF_EXPORT\nGF_Err gf_isom_check_data_reference(GF_ISOFile *the_file, u32 trackNumber, u32 StreamDescriptionIndex)\n{\n\tGF_Err e;\n\tu32 drefIndex;\n\tGF_TrackBox *trak;\n\n\tif (!StreamDescriptionIndex || !trackNumber) return GF_BAD_PARAM;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\te = Media_GetSampleDesc(trak->Media, StreamDescriptionIndex , NULL, &drefIndex);\n\tif (e) return e;\n\tif (!drefIndex) return GF_BAD_PARAM;\n\treturn Media_CheckDataEntry(trak->Media, drefIndex);\n}\n\n//get the location of the data. If URL && URN are NULL, the data is in this file\nGF_EXPORT\nGF_Err gf_isom_get_data_reference(GF_ISOFile *the_file, u32 trackNumber, u32 StreamDescriptionIndex, const char **outURL, const char **outURN)\n{\n\tGF_TrackBox *trak;\n\tGF_DataEntryURLBox *url=NULL;\n\tGF_DataEntryURNBox *urn;\n\tu32 drefIndex;\n\tGF_Err e;\n\n\t*outURL = *outURN = NULL;\n\n\tif (!StreamDescriptionIndex || !trackNumber) return GF_BAD_PARAM;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\te = Media_GetSampleDesc(trak->Media, StreamDescriptionIndex , NULL, &drefIndex);\n\tif (e) return e;\n\tif (!drefIndex) return GF_BAD_PARAM;\n\n\tif (trak->Media\n\t\t&& trak->Media->information\n\t\t&& trak->Media->information->dataInformation\n\t\t&& trak->Media->information->dataInformation->dref\n\t) {\n\t\turl = (GF_DataEntryURLBox*)gf_list_get(trak->Media->information->dataInformation->dref->child_boxes, drefIndex - 1);\n\t}\n\tif (!url) return GF_ISOM_INVALID_FILE;\n\n\tif (url->type == GF_ISOM_BOX_TYPE_URL) {\n\t\t*outURL = url->location;\n\t\t*outURN = NULL;\n\t} else if (url->type == GF_ISOM_BOX_TYPE_URN) {\n\t\turn = (GF_DataEntryURNBox *) url;\n\t\t*outURN = urn->nameURN;\n\t\t*outURL = urn->location;\n\t} else {\n\t\t*outURN = NULL;\n\t\t*outURL = NULL;\n\t}\n\treturn GF_OK;\n}\n\n//Get the number of samples\n//return 0 if error or empty\nGF_EXPORT\nu32 gf_isom_get_sample_count(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media || !trak->Media->information || !trak->Media->information->sampleTable || !trak->Media->information->sampleTable->SampleSize) return 0;\n\treturn trak->Media->information->sampleTable->SampleSize->sampleCount\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t       + trak->sample_count_at_seg_start\n#endif\n\t       ;\n}\n\nGF_EXPORT\nu32 gf_isom_get_constant_sample_size(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media || !trak->Media->information || !trak->Media->information->sampleTable || !trak->Media->information->sampleTable->SampleSize) return 0;\n\treturn trak->Media->information->sampleTable->SampleSize->sampleSize;\n}\n\nGF_EXPORT\nu32 gf_isom_get_constant_sample_duration(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media || !trak->Media->information || !trak->Media->information->sampleTable || !trak->Media->information->sampleTable->TimeToSample) return 0;\n\tif (trak->Media->information->sampleTable->TimeToSample->nb_entries != 1) return 0;\n\treturn trak->Media->information->sampleTable->TimeToSample->entries[0].sampleDelta;\n}\n\nGF_EXPORT\nBool gf_isom_enable_raw_pack(GF_ISOFile *the_file, u32 trackNumber, u32 pack_num_samples)\n{\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_FALSE;\n\ttrak->pack_num_samples = 0;\n\t//we only activate sample packing for raw audio\n\tif (!trak->Media || !trak->Media->handler) return GF_FALSE;\n\tif (trak->Media->handler->handlerType != GF_ISOM_MEDIA_AUDIO) return GF_FALSE;\n\t//and sample duration of 1\n\tif (!trak->Media->information || !trak->Media->information->sampleTable || !trak->Media->information->sampleTable->TimeToSample) return GF_FALSE;\n\tif (trak->Media->information->sampleTable->TimeToSample->nb_entries != 1) return GF_FALSE;\n\tif (!trak->Media->information->sampleTable->TimeToSample->entries) return GF_FALSE;\n\tif (trak->Media->information->sampleTable->TimeToSample->entries[0].sampleDelta != 1) return GF_FALSE;\n\t//and sample with constant size\n\tif (!trak->Media->information->sampleTable->SampleSize || !trak->Media->information->sampleTable->SampleSize->sampleSize) return GF_FALSE;\n\ttrak->pack_num_samples = pack_num_samples;\n\treturn pack_num_samples ? GF_TRUE : GF_FALSE;\n}\n\nBool gf_isom_has_time_offset_table(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media->information->sampleTable->CompositionOffset) return GF_FALSE;\n\treturn GF_TRUE;\n}\n\nGF_EXPORT\nu32 gf_isom_has_time_offset(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tu32 i;\n\tGF_CompositionOffsetBox *ctts;\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media->information->sampleTable->CompositionOffset) return 0;\n\n\t//return true at the first offset found\n\tctts = trak->Media->information->sampleTable->CompositionOffset;\n\tfor (i=0; i<ctts->nb_entries; i++) {\n\t\tif (ctts->entries[i].decodingOffset && ctts->entries[i].sampleCount) return ctts->version ? 2 : 1;\n\t}\n\treturn 0;\n}\n\nGF_EXPORT\ns64 gf_isom_get_cts_to_dts_shift(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media->information->sampleTable->CompositionToDecode) return 0;\n\treturn trak->Media->information->sampleTable->CompositionToDecode->compositionToDTSShift;\n}\n\nGF_EXPORT\nBool gf_isom_has_sync_shadows(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_FALSE;\n\tif (!trak->Media->information->sampleTable->ShadowSync) return GF_FALSE;\n\tif (gf_list_count(trak->Media->information->sampleTable->ShadowSync->entries) ) return GF_TRUE;\n\treturn GF_FALSE;\n}\n\nGF_EXPORT\nBool gf_isom_has_sample_dependency(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_FALSE;\n\tif (!trak->Media->information->sampleTable->SampleDep) return GF_FALSE;\n\treturn GF_TRUE;\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_sample_flags(GF_ISOFile *the_file, u32 trackNumber, u32 sampleNumber, u32 *isLeading, u32 *dependsOn, u32 *dependedOn, u32 *redundant)\n{\n\tGF_TrackBox *trak;\n\t*isLeading = 0;\n\t*dependsOn = 0;\n\t*dependedOn = 0;\n\t*redundant = 0;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\tif (!trak->Media->information->sampleTable->SampleDep) return GF_BAD_PARAM;\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tif (sampleNumber <= trak->sample_count_at_seg_start)\n\t\treturn GF_BAD_PARAM;\n\tsampleNumber -= trak->sample_count_at_seg_start;\n#endif\n\n\treturn stbl_GetSampleDepType(trak->Media->information->sampleTable->SampleDep, sampleNumber, isLeading, dependsOn, dependedOn, redundant);\n}\n\n//return a sample give its number, and set the SampleDescIndex of this sample\n//this index allows to retrieve the stream description if needed (2 media in 1 track)\n//return NULL if error\nGF_EXPORT\nGF_ISOSample *gf_isom_get_sample_ex(GF_ISOFile *the_file, u32 trackNumber, u32 sampleNumber, u32 *sampleDescriptionIndex, GF_ISOSample *static_sample, u64 *data_offset)\n{\n\tGF_Err e;\n\tu32 descIndex;\n\tGF_TrackBox *trak;\n\tGF_ISOSample *samp;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return NULL;\n\n\tif (!sampleNumber) return NULL;\n\tif (static_sample) {\n\t\tsamp = static_sample;\n\t\tif (static_sample->dataLength && !static_sample->alloc_size)\n\t\t\tstatic_sample->alloc_size = static_sample->dataLength;\n\t} else {\n\t\tsamp = gf_isom_sample_new();\n\t}\n\tif (!samp) return NULL;\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tif (sampleNumber<=trak->sample_count_at_seg_start)\n\t\treturn NULL;\n\tsampleNumber -= trak->sample_count_at_seg_start;\n#endif\n\n\te = Media_GetSample(trak->Media, sampleNumber, &samp, &descIndex, GF_FALSE, data_offset);\n\tif (static_sample && !static_sample->alloc_size)\n\t\tstatic_sample->alloc_size = static_sample->dataLength;\n\n\tif (e) {\n\t\tgf_isom_set_last_error(the_file, e);\n\t\tif (!static_sample) gf_isom_sample_del(&samp);\n\t\treturn NULL;\n\t}\n\tif (sampleDescriptionIndex) *sampleDescriptionIndex = descIndex;\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tif (samp) samp->DTS += trak->dts_at_seg_start;\n#endif\n\n\treturn samp;\n}\n\nGF_EXPORT\nGF_ISOSample *gf_isom_get_sample(GF_ISOFile *the_file, u32 trackNumber, u32 sampleNumber, u32 *sampleDescriptionIndex)\n{\n\treturn gf_isom_get_sample_ex(the_file, trackNumber, sampleNumber, sampleDescriptionIndex, NULL, NULL);\n}\n\nGF_EXPORT\nu32 gf_isom_get_sample_duration(GF_ISOFile *the_file, u32 trackNumber, u32 sampleNumber)\n{\n\tu32 dur;\n\tu64 dts;\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !sampleNumber) return 0;\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tif (sampleNumber<=trak->sample_count_at_seg_start) return 0;\n\tsampleNumber -= trak->sample_count_at_seg_start;\n#endif\n\n\tstbl_GetSampleDTS_and_Duration(trak->Media->information->sampleTable->TimeToSample, sampleNumber, &dts, &dur);\n\treturn dur;\n}\n\n\nGF_EXPORT\nu32 gf_isom_get_sample_size(GF_ISOFile *the_file, u32 trackNumber, u32 sampleNumber)\n{\n\tu32 size = 0;\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !sampleNumber) return 0;\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tif (sampleNumber<=trak->sample_count_at_seg_start) return 0;\n\tsampleNumber -= trak->sample_count_at_seg_start;\n#endif\n\tstbl_GetSampleSize(trak->Media->information->sampleTable->SampleSize, sampleNumber, &size);\n\treturn size;\n}\n\nGF_EXPORT\nu32 gf_isom_get_max_sample_size(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media || !trak->Media->information || !trak->Media->information->sampleTable || !trak->Media->information->sampleTable->SampleSize) return 0;\n\n\treturn trak->Media->information->sampleTable->SampleSize->max_size;\n}\n\nGF_EXPORT\nu32 gf_isom_get_avg_sample_size(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media || !trak->Media->information || !trak->Media->information->sampleTable || !trak->Media->information->sampleTable->SampleSize) return 0;\n\n\tif ( trak->Media->information->sampleTable->SampleSize->sampleSize)\n\t\treturn trak->Media->information->sampleTable->SampleSize->sampleSize;\n\n\tif (!trak->Media->information->sampleTable->SampleSize->total_samples) return 0;\n\treturn (u32) (trak->Media->information->sampleTable->SampleSize->total_size / trak->Media->information->sampleTable->SampleSize->total_samples);\n}\n\nGF_EXPORT\nu32 gf_isom_get_max_sample_delta(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media || !trak->Media->information || !trak->Media->information->sampleTable || !trak->Media->information->sampleTable->TimeToSample) return 0;\n\n\treturn trak->Media->information->sampleTable->TimeToSample->max_ts_delta;\n}\n\nGF_EXPORT\nu32 gf_isom_get_max_sample_cts_offset(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media || !trak->Media->information || !trak->Media->information->sampleTable || !trak->Media->information->sampleTable->CompositionOffset) return 0;\n\n\treturn trak->Media->information->sampleTable->CompositionOffset->max_ts_delta;\n}\n\n\nGF_EXPORT\nBool gf_isom_get_sample_sync(GF_ISOFile *the_file, u32 trackNumber, u32 sampleNumber)\n{\n\tGF_ISOSAPType is_rap;\n\tGF_Err e;\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !sampleNumber) return GF_FALSE;\n\n\tif (! trak->Media->information->sampleTable->SyncSample) return GF_TRUE;\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tif (sampleNumber<=trak->sample_count_at_seg_start) return GF_FALSE;\n\tsampleNumber -= trak->sample_count_at_seg_start;\n#endif\n\te = stbl_GetSampleRAP(trak->Media->information->sampleTable->SyncSample, sampleNumber, &is_rap, NULL, NULL);\n\tif (e) return GF_FALSE;\n\treturn is_rap ? GF_TRUE : GF_FALSE;\n}\n\n//same as gf_isom_get_sample but doesn't fetch media data\nGF_EXPORT\nGF_ISOSample *gf_isom_get_sample_info_ex(GF_ISOFile *the_file, u32 trackNumber, u32 sampleNumber, u32 *sampleDescriptionIndex, u64 *data_offset, GF_ISOSample *static_sample)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\tGF_ISOSample *samp;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return NULL;\n\n\tif (!sampleNumber) return NULL;\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tif (sampleNumber<=trak->sample_count_at_seg_start) return NULL;\n\tsampleNumber -= trak->sample_count_at_seg_start;\n#endif\n\tif (static_sample) {\n\t\tsamp = static_sample;\n\t} else {\n\t\tsamp = gf_isom_sample_new();\n\t\tif (!samp) return NULL;\n\t}\n\n\te = Media_GetSample(trak->Media, sampleNumber, &samp, sampleDescriptionIndex, GF_TRUE, data_offset);\n\tif (e) {\n\t\tgf_isom_set_last_error(the_file, e);\n\t\tif (!static_sample)\n\t\t\tgf_isom_sample_del(&samp);\n\t\treturn NULL;\n\t}\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tif (samp) samp->DTS += trak->dts_at_seg_start;\n#endif\n\treturn samp;\n}\n\nGF_EXPORT\nGF_ISOSample *gf_isom_get_sample_info(GF_ISOFile *the_file, u32 trackNumber, u32 sampleNumber, u32 *sampleDescriptionIndex, u64 *data_offset)\n{\n\treturn gf_isom_get_sample_info_ex(the_file, trackNumber, sampleNumber, sampleDescriptionIndex, data_offset, NULL);\n}\n\n\n//get sample dts\nGF_EXPORT\nu64 gf_isom_get_sample_dts(GF_ISOFile *the_file, u32 trackNumber, u32 sampleNumber)\n{\n\tu64 dts;\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return 0;\n\n\tif (!sampleNumber) return 0;\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tif (sampleNumber<=trak->sample_count_at_seg_start) return 0;\n\tsampleNumber -= trak->sample_count_at_seg_start;\n#endif\n\tif (stbl_GetSampleDTS(trak->Media->information->sampleTable->TimeToSample, sampleNumber, &dts) != GF_OK) return 0;\n\treturn dts;\n}\n\nGF_EXPORT\nBool gf_isom_is_self_contained(GF_ISOFile *the_file, u32 trackNumber, u32 sampleDescriptionIndex)\n{\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_FALSE;\n\treturn Media_IsSelfContained(trak->Media, sampleDescriptionIndex);\n}\n\n/*retrieves given sample DTS*/\nGF_EXPORT\nu32 gf_isom_get_sample_from_dts(GF_ISOFile *the_file, u32 trackNumber, u64 dts)\n{\n\tGF_Err e;\n\tu32 sampleNumber, prevSampleNumber;\n\tGF_TrackBox *trak;\n\tGF_SampleTableBox *stbl;\n\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return 0;\n\n\tstbl = trak->Media->information->sampleTable;\n\n\te = stbl_findEntryForTime(stbl, dts, 1, &sampleNumber, &prevSampleNumber);\n\tif (e) return 0;\n\treturn sampleNumber;\n}\n\n\n//return a sample given a desired display time IN MEDIA TIME SCALE\n//and set the StreamDescIndex of this sample\n//this index allows to retrieve the stream description if needed (2 media in 1 track)\n//return NULL if error\n//WARNING: the sample may not be sync even though the sync was requested (depends on the media)\nGF_EXPORT\nGF_Err gf_isom_get_sample_for_media_time(GF_ISOFile *the_file, u32 trackNumber, u64 desiredTime, u32 *StreamDescriptionIndex, GF_ISOSearchMode SearchMode, GF_ISOSample **sample, u32 *SampleNum, u64 *data_offset)\n{\n\tGF_Err e;\n\tu32 sampleNumber, prevSampleNumber, syncNum, shadowSync;\n\tGF_TrackBox *trak;\n\tGF_ISOSample *shadow;\n\tGF_SampleTableBox *stbl;\n\tBool static_sample = GF_FALSE;\n\tu8 useShadow, IsSync;\n\n\tif (SampleNum) *SampleNum = 0;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tstbl = trak->Media->information->sampleTable;\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tif (desiredTime < trak->dts_at_seg_start) {\n\t\tdesiredTime = 0;\n\t} else {\n\t\tdesiredTime -= trak->dts_at_seg_start;\n\t}\n#endif\n\n\te = stbl_findEntryForTime(stbl, desiredTime, 0, &sampleNumber, &prevSampleNumber);\n\tif (e) return e;\n\n\t//if no shadow table, reset to sync only\n\tuseShadow = 0;\n\tif (!stbl->ShadowSync && (SearchMode == GF_ISOM_SEARCH_SYNC_SHADOW))\n\t\tSearchMode = GF_ISOM_SEARCH_SYNC_BACKWARD;\n\n\t//if no syncTable, disable syncSearching, as all samples ARE sync\n\tif (! trak->Media->information->sampleTable->SyncSample) {\n\t\tif (SearchMode == GF_ISOM_SEARCH_SYNC_FORWARD) SearchMode = GF_ISOM_SEARCH_FORWARD;\n\t\tif (SearchMode == GF_ISOM_SEARCH_SYNC_BACKWARD) SearchMode = GF_ISOM_SEARCH_BACKWARD;\n\t}\n\n\t//not found, return EOF or browse backward\n\tif (!sampleNumber && !prevSampleNumber) {\n\t\tif (SearchMode == GF_ISOM_SEARCH_SYNC_BACKWARD || SearchMode == GF_ISOM_SEARCH_BACKWARD) {\n\t\t\tsampleNumber = trak->Media->information->sampleTable->SampleSize->sampleCount;\n\t\t}\n\t\tif (!sampleNumber) return GF_EOS;\n\t}\n\n\t//check in case we have the perfect sample\n\tIsSync = 0;\n\n\t//according to the direction adjust the sampleNum value\n\tswitch (SearchMode) {\n\tcase GF_ISOM_SEARCH_SYNC_FORWARD:\n\t\tIsSync = 1;\n\tcase GF_ISOM_SEARCH_FORWARD:\n\t\t//not the exact one\n\t\tif (!sampleNumber) {\n\t\t\tif (prevSampleNumber != stbl->SampleSize->sampleCount) {\n\t\t\t\tsampleNumber = prevSampleNumber + 1;\n\t\t\t} else {\n\t\t\t\tsampleNumber = prevSampleNumber;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t//if dummy mode, reset to default browsing\n\tcase GF_ISOM_SEARCH_SYNC_BACKWARD:\n\t\tIsSync = 1;\n\tcase GF_ISOM_SEARCH_SYNC_SHADOW:\n\tcase GF_ISOM_SEARCH_BACKWARD:\n\tdefault:\n\t\t//first case, not found....\n\t\tif (!sampleNumber && !prevSampleNumber) {\n\t\t\tsampleNumber = stbl->SampleSize->sampleCount;\n\t\t} else if (!sampleNumber) {\n\t\t\tsampleNumber = prevSampleNumber;\n\t\t}\n\t\tbreak;\n\t}\n\n\t//get the sync sample num\n\tif (IsSync) {\n\t\t//get the SyncNumber\n\t\te = Media_FindSyncSample(trak->Media->information->sampleTable,\n\t\t                         sampleNumber, &syncNum, SearchMode);\n\t\tif (e) return e;\n\t\tif (syncNum) sampleNumber = syncNum;\n\t\tsyncNum = 0;\n\t}\n\t//if we are in shadow mode, get the previous sync sample\n\t//in case we can't find a good SyncShadow\n\telse if (SearchMode == GF_ISOM_SEARCH_SYNC_SHADOW) {\n\t\t//get the SyncNumber\n\t\te = Media_FindSyncSample(trak->Media->information->sampleTable,\n\t\t                         sampleNumber, &syncNum, GF_ISOM_SEARCH_SYNC_BACKWARD);\n\t\tif (e) return e;\n\t}\n\n\n\t//OK sampleNumber is exactly the sample we need (except for shadow)\n\n\tif (sample) {\n\t\tif (*sample) {\n\t\t\tstatic_sample = GF_TRUE;\n\t\t} else {\n\t\t\t*sample = gf_isom_sample_new();\n\t\t\tif (*sample == NULL) return GF_OUT_OF_MEM;\n\t\t}\n\t}\n\t//we are in shadow mode, we need to browse both SyncSample and ShadowSyncSample to get\n\t//the desired sample...\n\tif (SearchMode == GF_ISOM_SEARCH_SYNC_SHADOW) {\n\t\t//get the shadowing number\n\t\tstbl_GetSampleShadow(stbl->ShadowSync, &sampleNumber, &shadowSync);\n\t\t//now sampleNumber is the closest previous shadowed sample.\n\t\t//1- If we have a closer sync sample, use it.\n\t\t//2- if the shadowSync is 0, we don't have any shadowing, use syncNum\n\t\tif ((sampleNumber < syncNum) || (!shadowSync)) {\n\t\t\tsampleNumber = syncNum;\n\t\t} else {\n\t\t\t//otherwise, we have a better alternate sample in the shadowSync for this sample\n\t\t\tuseShadow = 1;\n\t\t}\n\t}\n\n\te = Media_GetSample(trak->Media, sampleNumber, sample, StreamDescriptionIndex, GF_FALSE, data_offset);\n\tif (e) {\n\t\tif (!static_sample)\n\t\t\tgf_isom_sample_del(sample);\n\t\telse if (! (*sample)->alloc_size && (*sample)->data && (*sample)->dataLength )\n\t\t \t(*sample)->alloc_size =  (*sample)->dataLength;\n\n\t\treturn e;\n\t}\n\tif (sample && ! (*sample)->IsRAP) {\n\t\tBool is_rap;\n\t\tGF_ISOSampleRollType roll_type;\n\t\te = gf_isom_get_sample_rap_roll_info(the_file, trackNumber, sampleNumber, &is_rap, &roll_type, NULL);\n\t\tif (e) return e;\n\t\tif (is_rap) (*sample)->IsRAP = SAP_TYPE_3;\n\t}\n\t//optionally get the sample number\n\tif (SampleNum) {\n\t\t*SampleNum = sampleNumber;\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\t\t*SampleNum += trak->sample_count_at_seg_start;\n#endif\n\t}\n\n\t//in shadow mode, we only get the data of the shadowing sample !\n\tif (sample && useShadow) {\n\t\t//we have to use StreamDescriptionIndex in case the sample data is in another desc\n\t\t//though this is unlikely as non optimized...\n\t\tshadow = gf_isom_get_sample(the_file, trackNumber, shadowSync, StreamDescriptionIndex);\n\t\t//if no sample, the shadowSync is broken, return the sample\n\t\tif (!shadow) return GF_OK;\n\t\t(*sample)->IsRAP = RAP;\n\t\tgf_free((*sample)->data);\n\t\t(*sample)->dataLength = shadow->dataLength;\n\t\t(*sample)->data = shadow->data;\n\t\t//set data length to 0 to keep the buffer alive...\n\t\tshadow->dataLength = 0;\n\t\tgf_isom_sample_del(&shadow);\n\t}\n\tif (static_sample && ! (*sample)->alloc_size )\n\t\t (*sample)->alloc_size =  (*sample)->dataLength;\n\t\t \n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_sample_for_movie_time(GF_ISOFile *the_file, u32 trackNumber, u64 movieTime, u32 *StreamDescriptionIndex, GF_ISOSearchMode SearchMode, GF_ISOSample **sample, u32 *sampleNumber, u64 *data_offset)\n{\n\tDouble tsscale;\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\tu64 mediaTime, nextMediaTime;\n\ts64 segStartTime, mediaOffset;\n\tu32 sampNum;\n\tu8 useEdit;\n\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\t//only check duration if initially set - do not check duration as updated after fragment merge since that duration does not take\n\t//into account tfdt\n\tif (trak->Header->initial_duration\n\t\t&& (movieTime * trak->moov->mvhd->timeScale > trak->Header->initial_duration * trak->Media->mediaHeader->timeScale)\n\t) {\n\t\tif (sampleNumber) *sampleNumber = 0;\n\t\t*StreamDescriptionIndex = 0;\n\t\treturn GF_EOS;\n\t}\n\n\t//get the media time for this movie time...\n\tmediaTime = segStartTime = 0;\n\t*StreamDescriptionIndex = 0;\n\tnextMediaTime = 0;\n\n\te = GetMediaTime(trak, (SearchMode==GF_ISOM_SEARCH_SYNC_FORWARD) ? GF_TRUE : GF_FALSE, movieTime, &mediaTime, &segStartTime, &mediaOffset, &useEdit, &nextMediaTime);\n\tif (e) return e;\n\n\t/*here we check if we were playing or not and return no sample in normal search modes*/\n\tif (useEdit && mediaOffset == -1) {\n\t\tif ((SearchMode==GF_ISOM_SEARCH_FORWARD) || (SearchMode==GF_ISOM_SEARCH_BACKWARD)) {\n\t\t\t/*get next sample time in MOVIE timescale*/\n\t\t\tif (SearchMode==GF_ISOM_SEARCH_FORWARD)\n\t\t\t\te = GetNextMediaTime(trak, movieTime, &mediaTime);\n\t\t\telse\n\t\t\t\te = GetPrevMediaTime(trak, movieTime, &mediaTime);\n\t\t\tif (e) return e;\n\t\t\treturn gf_isom_get_sample_for_movie_time(the_file, trackNumber, (u32) mediaTime, StreamDescriptionIndex, GF_ISOM_SEARCH_SYNC_FORWARD, sample, sampleNumber, data_offset);\n\t\t}\n\t\tif (sampleNumber) *sampleNumber = 0;\n\t\tif (sample) {\n\t\t\tif (! (*sample)) {\n\t\t\t\t*sample = gf_isom_sample_new();\n\t\t\t\tif (! *sample) return GF_OUT_OF_MEM;\n\t\t\t}\n\t\t\t(*sample)->DTS = movieTime;\n\t\t\t(*sample)->dataLength = 0;\n\t\t\t(*sample)->CTS_Offset = 0;\n\t\t}\n\t\treturn GF_OK;\n\t}\n\t/*dwell edit in non-sync mode, fetch next/prev sample depending on mode.\n\tOtherwise return the dwell entry*/\n\tif (useEdit==2) {\n\t\tif ((SearchMode==GF_ISOM_SEARCH_FORWARD) || (SearchMode==GF_ISOM_SEARCH_BACKWARD)) {\n\t\t\t/*get next sample time in MOVIE timescale*/\n\t\t\tif (SearchMode==GF_ISOM_SEARCH_FORWARD)\n\t\t\t\te = GetNextMediaTime(trak, movieTime, &mediaTime);\n\t\t\telse\n\t\t\t\te = GetPrevMediaTime(trak, movieTime, &mediaTime);\n\t\t\tif (e) return e;\n\t\t\treturn gf_isom_get_sample_for_movie_time(the_file, trackNumber, (u32) mediaTime, StreamDescriptionIndex, GF_ISOM_SEARCH_SYNC_FORWARD, sample, sampleNumber, data_offset);\n\t\t}\n\t}\n\n\ttsscale = trak->Media->mediaHeader->timeScale;\n\ttsscale /= trak->moov->mvhd->timeScale;\n\n\t//OK, we have a sample so fetch it\n\te = gf_isom_get_sample_for_media_time(the_file, trackNumber, mediaTime, StreamDescriptionIndex, SearchMode, sample, &sampNum, data_offset);\n\tif (e) {\n\t\tif (e==GF_EOS) {\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t\t\t//movie is fragmented and samples not yet received, return EOS\n\t\t\tif (the_file->moov->mvex && !trak->Media->information->sampleTable->SampleSize->sampleCount)\n\t\t\t\treturn e;\n#endif\n\n\t\t\tif (nextMediaTime && (nextMediaTime-1 != movieTime))\n\t\t\t\treturn gf_isom_get_sample_for_movie_time(the_file, trackNumber, nextMediaTime-1, StreamDescriptionIndex, SearchMode, sample, sampleNumber, data_offset);\n\t\t}\n\t\treturn e;\n\t}\n\n\t//OK, now the trick: we have to rebuild the time stamps, according\n\t//to the media time scale (used by SLConfig) - add the edit start time but stay in\n\t//the track TS\n\tif (sample && useEdit) {\n\t\tu64 _ts = (u64)(segStartTime * tsscale);\n\n\t\t(*sample)->DTS += _ts;\n\t\t/*watchout, the sample fetched may be before the first sample in the edit list (when seeking)*/\n\t\tif ( (*sample)->DTS > (u64) mediaOffset) {\n\t\t\t(*sample)->DTS -= (u64) mediaOffset;\n\t\t} else {\n\t\t\t(*sample)->DTS = 0;\n\t\t}\n\t}\n\tif (sampleNumber) *sampleNumber = sampNum;\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tif (sample && (*sample) ) (*sample)->DTS += trak->dts_at_seg_start;\n#endif\n\n\treturn GF_OK;\n}\n\n\n\nGF_EXPORT\nu64 gf_isom_get_missing_bytes(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return 0;\n\n\treturn trak->Media->BytesMissing;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_sample_padding(GF_ISOFile *the_file, u32 trackNumber, u32 padding_bytes)\n{\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\ttrak->padding_bytes = padding_bytes;\n\treturn GF_OK;\n\n}\n\n//get the number of edited segment\nGF_EXPORT\nBool gf_isom_get_edit_list_type(GF_ISOFile *the_file, u32 trackNumber, s64 *mediaOffset)\n{\n\tGF_EdtsEntry *ent;\n\tGF_TrackBox *trak;\n\tu32 count;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_FALSE;\n\t*mediaOffset = 0;\n\tif (!trak->editBox || !trak->editBox->editList) return GF_FALSE;\n\n\tcount = gf_list_count(trak->editBox->editList->entryList);\n\tent = (GF_EdtsEntry*)gf_list_get(trak->editBox->editList->entryList, 0);\n\tif (!ent) return GF_TRUE;\n\t/*mediaRate>0, the track playback shall start at media time>0 -> mediaOffset is < 0 */\n\tif ((count==1) && (ent->mediaRate == 0x10000)) {\n\t\t*mediaOffset = - ent->mediaTime;\n\t\treturn GF_FALSE;\n\t} else if (count==2) {\n\t\t/*mediaRate==-1, the track playback shall be empty for segmentDuration -> mediaOffset is > 0 */\n\t\tif ((ent->mediaRate == -0x10000) || (ent->mediaTime==-1)) {\n\t\t\tDouble time = (Double) ent->segmentDuration;\n\t\t\ttime /= trak->moov->mvhd->timeScale;\n\t\t\ttime *= trak->Media->mediaHeader->timeScale;\n\t\t\t*mediaOffset = (s64) time;\n\n\t\t\t//check next entry, if we start from mediaOffset > 0 this may still result in a skip\n\t\t\tent = (GF_EdtsEntry*)gf_list_get(trak->editBox->editList->entryList, 1);\n\t\t\t//next entry playback rate is not nominal, we need edit list handling\n\t\t\tif (ent->mediaRate != 0x10000)\n\t\t\t\treturn GF_TRUE;\n\n\t\t\tif (ent->mediaTime > 0) {\n\t\t\t\t*mediaOffset -= ent->mediaTime;\n\t\t\t}\n\t\t\treturn GF_FALSE;\n\t\t}\n\t}\n\treturn GF_TRUE;\n}\n\n\n//get the number of edited segment\nGF_EXPORT\nu32 gf_isom_get_edits_count(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return 0;\n\n\tif (!trak->editBox || !trak->editBox->editList) return 0;\n\treturn gf_list_count(trak->editBox->editList->entryList);\n}\n\n\n//Get the desired segment information\nGF_EXPORT\nGF_Err gf_isom_get_edit(GF_ISOFile *the_file, u32 trackNumber, u32 SegmentIndex, u64 *EditTime, u64 *SegmentDuration, u64 *MediaTime, GF_ISOEditType *EditMode)\n{\n\tu32 i;\n\tu64 startTime;\n\tGF_TrackBox *trak;\n\tGF_EditListBox *elst;\n\tGF_EdtsEntry *ent;\n\n\tent = NULL;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tif (!trak->editBox ||\n\t        !trak->editBox->editList ||\n\t        (SegmentIndex > gf_list_count(trak->editBox->editList->entryList)) ||\n\t        !SegmentIndex)\n\t\treturn GF_BAD_PARAM;\n\n\telst = trak->editBox->editList;\n\tstartTime = 0;\n\n\tfor (i = 0; i < SegmentIndex; i++) {\n\t\tent = (GF_EdtsEntry*)gf_list_get(elst->entryList, i);\n\t\tif (i < SegmentIndex-1) startTime += ent->segmentDuration;\n\t}\n\t*EditTime = startTime;\n\t*SegmentDuration = ent->segmentDuration;\n\tif (ent->mediaTime < 0) {\n\t\t*MediaTime = 0;\n\t\t*EditMode = GF_ISOM_EDIT_EMPTY;\n\t\treturn GF_OK;\n\t}\n\tif (ent->mediaRate == 0) {\n\t\t*MediaTime = ent->mediaTime;\n\t\t*EditMode = GF_ISOM_EDIT_DWELL;\n\t\treturn GF_OK;\n\t}\n\t*MediaTime = ent->mediaTime;\n\t*EditMode = GF_ISOM_EDIT_NORMAL;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nu8 gf_isom_has_sync_points(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media || !trak->Media->information || !trak->Media->information->sampleTable) return 0;\n\tif (trak->Media->information->sampleTable->SyncSample) {\n\t\tif (!trak->Media->information->sampleTable->SyncSample->nb_entries) return 2;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n/*returns number of sync points*/\nGF_EXPORT\nu32 gf_isom_get_sync_point_count(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return 0;\n\tif (trak->Media->information->sampleTable->SyncSample) {\n\t\treturn trak->Media->information->sampleTable->SyncSample->nb_entries;\n\t}\n\treturn 0;\n}\n\n\nGF_EXPORT\nGF_Err gf_isom_get_brand_info(GF_ISOFile *movie, u32 *brand, u32 *minorVersion, u32 *AlternateBrandsCount)\n{\n\tif (!movie) return GF_BAD_PARAM;\n\tif (!movie->brand) {\n\t\tif (brand) *brand = GF_ISOM_BRAND_ISOM;\n\t\tif (minorVersion) *minorVersion = 1;\n\t\tif (AlternateBrandsCount) *AlternateBrandsCount = 0;\n\t\treturn GF_OK;\n\t}\n\n\tif (brand) *brand = movie->brand->majorBrand;\n\tif (minorVersion) *minorVersion = movie->brand->minorVersion;\n\tif (AlternateBrandsCount) *AlternateBrandsCount = movie->brand->altCount;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_alternate_brand(GF_ISOFile *movie, u32 BrandIndex, u32 *brand)\n{\n\tif (!movie || !movie->brand || !brand) return GF_BAD_PARAM;\n\tif (BrandIndex > movie->brand->altCount || !BrandIndex) return GF_BAD_PARAM;\n\t*brand = movie->brand->altBrand[BrandIndex-1];\n\treturn GF_OK;\n}\n\nGF_EXPORT\nconst u32 *gf_isom_get_brands(GF_ISOFile *movie)\n{\n\tif (!movie || !movie->brand) return NULL;\n\treturn movie->brand->altBrand;\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_sample_padding_bits(GF_ISOFile *the_file, u32 trackNumber, u32 sampleNumber, u8 *NbBits)\n{\n\tGF_TrackBox *trak;\n\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\n\t//Padding info\n\treturn stbl_GetPaddingBits(trak->Media->information->sampleTable->PaddingBits,\n\t                           sampleNumber, NbBits);\n\n}\n\n\nGF_EXPORT\nBool gf_isom_has_padding_bits(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_FALSE;\n\n\tif (trak->Media->information->sampleTable->PaddingBits) return GF_TRUE;\n\treturn GF_FALSE;\n}\n\nGF_EXPORT\nu32 gf_isom_get_udta_count(GF_ISOFile *movie, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\tGF_UserDataBox *udta;\n\tif (!movie || !movie->moov) return 0;\n\n\tif (trackNumber) {\n\t\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\t\tif (!trak) return 0;\n\t\tudta = trak->udta;\n\t} else {\n\t\tudta = movie->moov->udta;\n\t}\n\tif (udta) return gf_list_count(udta->recordList);\n\treturn 0;\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_udta_type(GF_ISOFile *movie, u32 trackNumber, u32 udta_idx, u32 *UserDataType, bin128 *UUID)\n{\n\tGF_TrackBox *trak;\n\tGF_UserDataBox *udta;\n\tGF_UserDataMap *map;\n\tif (!movie || !movie->moov || !udta_idx) return GF_BAD_PARAM;\n\n\tif (trackNumber) {\n\t\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\t\tif (!trak) return GF_OK;\n\t\tudta = trak->udta;\n\t} else {\n\t\tudta = movie->moov->udta;\n\t}\n\tif (!udta) return GF_BAD_PARAM;\n\tif (udta_idx>gf_list_count(udta->recordList)) return GF_BAD_PARAM;\n\tmap = (GF_UserDataMap*)gf_list_get(udta->recordList, udta_idx - 1);\n\tif (UserDataType) *UserDataType = map->boxType;\n\tif (UUID) memcpy(*UUID, map->uuid, 16);\n\treturn GF_OK;\n}\n\nGF_EXPORT\nu32 gf_isom_get_user_data_count(GF_ISOFile *movie, u32 trackNumber, u32 UserDataType, bin128 UUID)\n{\n\tGF_UserDataMap *map;\n\tGF_TrackBox *trak;\n\tGF_UserDataBox *udta;\n\tbin128 t;\n\tu32 i, count;\n\n\tif (!movie || !movie->moov) return 0;\n\n\tif (UserDataType == GF_ISOM_BOX_TYPE_UUID) UserDataType = 0;\n\tmemset(t, 1, 16);\n\n\tif (trackNumber) {\n\t\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\t\tif (!trak) return 0;\n\t\tudta = trak->udta;\n\t} else {\n\t\tudta = movie->moov->udta;\n\t}\n\tif (!udta) return 0;\n\n\ti=0;\n\twhile ((map = (GF_UserDataMap*)gf_list_enum(udta->recordList, &i))) {\n\t\tcount = gf_list_count(map->boxes);\n\n\t\tif ((map->boxType == GF_ISOM_BOX_TYPE_UUID) && !memcmp(map->uuid, UUID, 16)) return count;\n\t\telse if (map->boxType == UserDataType) return count;\n\t}\n\treturn 0;\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_user_data(GF_ISOFile *movie, u32 trackNumber, u32 UserDataType, bin128 UUID, u32 UserDataIndex, u8 **userData, u32 *userDataSize)\n{\n\tGF_UserDataMap *map;\n\tGF_UnknownBox *ptr;\n\tGF_BitStream *bs;\n\tu32 i;\n\tbin128 t;\n\tGF_TrackBox *trak;\n\tGF_UserDataBox *udta;\n\n\tif (!movie || !movie->moov) return GF_BAD_PARAM;\n\n\tif (trackNumber) {\n\t\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\t\tif (!trak) return GF_BAD_PARAM;\n\t\tudta = trak->udta;\n\t} else {\n\t\tudta = movie->moov->udta;\n\t}\n\tif (!udta) return GF_BAD_PARAM;\n\n\tif (UserDataType == GF_ISOM_BOX_TYPE_UUID) UserDataType = 0;\n\tmemset(t, 1, 16);\n\n\tif (!userData || !userDataSize || *userData) return GF_BAD_PARAM;\n\n\ti=0;\n\twhile ((map = (GF_UserDataMap*)gf_list_enum(udta->recordList, &i))) {\n\t\tif ((map->boxType == GF_ISOM_BOX_TYPE_UUID) && !memcmp(map->uuid, UUID, 16)) goto found;\n\t\telse if (map->boxType == UserDataType) goto found;\n\n\t}\n\treturn GF_BAD_PARAM;\n\nfound:\n\tif (UserDataIndex) {\n\t\tif (UserDataIndex > gf_list_count(map->boxes) ) return GF_BAD_PARAM;\n\t\tptr = (GF_UnknownBox*)gf_list_get(map->boxes, UserDataIndex-1);\n\n\t\tif (ptr->type == GF_ISOM_BOX_TYPE_UNKNOWN) {\n\t\t\t*userData = (char *)gf_malloc(sizeof(char)*ptr->dataSize);\n\t\t\tif (!*userData) return GF_OUT_OF_MEM;\n\t\t\tmemcpy(*userData, ptr->data, sizeof(char)*ptr->dataSize);\n\t\t\t*userDataSize = ptr->dataSize;\n\t\t\treturn GF_OK;\n\t\t} else if (ptr->type == GF_ISOM_BOX_TYPE_UUID) {\n\t\t\tGF_UnknownUUIDBox *p_uuid = (GF_UnknownUUIDBox *)ptr;\n\t\t\t*userData = (char *)gf_malloc(sizeof(char)*p_uuid->dataSize);\n\t\t\tif (!*userData) return GF_OUT_OF_MEM;\n\t\t\tmemcpy(*userData, p_uuid->data, sizeof(char)*p_uuid->dataSize);\n\t\t\t*userDataSize = p_uuid->dataSize;\n\t\t\treturn GF_OK;\n\t\t} else {\n\t\t\tchar *str = NULL;\n\t\t\tswitch (ptr->type) {\n\t\t\tcase GF_ISOM_BOX_TYPE_NAME:\n\t\t\t//case GF_QT_BOX_TYPE_NAME: same as above\n\t\t\t\tstr = ((GF_NameBox *)ptr)->string;\n\t\t\t\tbreak;\n\t\t\tcase GF_ISOM_BOX_TYPE_KIND:\n\t\t\t\tstr = ((GF_KindBox *)ptr)->value;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (str) {\n\t\t\t\tu32 len = (u32) strlen(str) + 1;\n\t\t\t\t*userData = (char *)gf_malloc(sizeof(char) * len);\n\t\t\t\tif (!*userData) return GF_OUT_OF_MEM;\n\t\t\t\tmemcpy(*userData, str, sizeof(char)*len);\n\t\t\t\t*userDataSize = len;\n\t\t\t\treturn GF_OK;\n\t\t\t}\n\t\t\treturn GF_NOT_SUPPORTED;\n\t\t}\n\t}\n\n\t//serialize all boxes\n\tbs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\ti=0;\n\twhile ( (ptr = (GF_UnknownBox*)gf_list_enum(map->boxes, &i))) {\n\t\tu32 type, s, data_size;\n\t\tchar *data=NULL;\n\t\tif (ptr->type == GF_ISOM_BOX_TYPE_UNKNOWN) {\n\t\t\ttype = ptr->original_4cc;\n\t\t\tdata_size = ptr->dataSize;\n\t\t\tdata = ptr->data;\n\t\t} else if (ptr->type == GF_ISOM_BOX_TYPE_UUID) {\n\t\t\tGF_UnknownUUIDBox *p_uuid = (GF_UnknownUUIDBox *)ptr;\n\t\t\ttype = p_uuid->type;\n\t\t\tdata_size = p_uuid->dataSize;\n\t\t\tdata = p_uuid->data;\n\t\t} else {\n\t\t\tgf_isom_box_write((GF_Box *)ptr, bs);\n\t\t\tcontinue;\n\t\t}\n\t\ts = data_size+8;\n\t\tif (ptr->type==GF_ISOM_BOX_TYPE_UUID) s += 16;\n\n\t\tgf_bs_write_u32(bs, s);\n\t\tgf_bs_write_u32(bs, type);\n\t\tif (type==GF_ISOM_BOX_TYPE_UUID) gf_bs_write_data(bs, (char *) map->uuid, 16);\n\t\tif (data) {\n\t\t\tgf_bs_write_data(bs, data, data_size);\n\t\t} else if (ptr->child_boxes) {\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\t\t\tgf_isom_box_array_write((GF_Box *)ptr, ptr->child_boxes, bs);\n#else\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"ISOBMF: udta is a box-list - cannot export in read-only version of libisom in GPAC\\n\" ));\n#endif\n\t\t}\n\t}\n\tgf_bs_get_content(bs, userData, userDataSize);\n\tgf_bs_del(bs);\n\treturn GF_OK;\n}\n\nGF_EXPORT\nvoid gf_isom_delete(GF_ISOFile *movie)\n{\n\t//free and return;\n\tgf_isom_delete_movie(movie);\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_chunks_infos(GF_ISOFile *movie, u32 trackNumber, u32 *dur_min, u32 *dur_avg, u32 *dur_max, u32 *size_min, u32 *size_avg, u32 *size_max)\n{\n\tGF_TrackBox *trak;\n\tu32 i, k, sample_idx, dmin, dmax, smin, smax, tot_chunks;\n\tu64 davg, savg;\n\tGF_SampleToChunkBox *stsc;\n\tGF_TimeToSampleBox *stts;\n\tif (!movie || !trackNumber || !movie->moov) return GF_BAD_PARAM;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tstsc = trak->Media->information->sampleTable->SampleToChunk;\n\tstts = trak->Media->information->sampleTable->TimeToSample;\n\tif (!stsc || !stts) return GF_ISOM_INVALID_FILE;\n\n\tdmin = smin = (u32) -1;\n\tdmax = smax = 0;\n\tdavg = savg = 0;\n\tsample_idx = 1;\n\ttot_chunks = 0;\n\tfor (i=0; i<stsc->nb_entries; i++) {\n\t\tu32 nb_chunk = 0;\n\t\tif (stsc->entries[i].samplesPerChunk >  2*trak->Media->information->sampleTable->SampleSize->sampleCount) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] likely broken stco entry (%u samples per chunk but %u samples total)\\n\", stsc->entries[i].samplesPerChunk, trak->Media->information->sampleTable->SampleSize->sampleCount));\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\t\twhile (1) {\n\t\t\tu32 chunk_dur = 0;\n\t\t\tu32 chunk_size = 0;\n\t\t\tfor (k=0; k<stsc->entries[i].samplesPerChunk; k++) {\n\t\t\t\tu64 dts;\n\t\t\t\tu32 dur;\n\t\t\t\tu32 size;\n\t\t\t\tstbl_GetSampleDTS_and_Duration(stts, k+sample_idx, &dts, &dur);\n\t\t\t\tchunk_dur += dur;\n\t\t\t\tstbl_GetSampleSize(trak->Media->information->sampleTable->SampleSize, k+sample_idx, &size);\n\t\t\t\tchunk_size += size;\n\n\t\t\t}\n\t\t\tif (dmin>chunk_dur) dmin = chunk_dur;\n\t\t\tif (dmax<chunk_dur) dmax = chunk_dur;\n\t\t\tdavg += chunk_dur;\n\t\t\tif (smin>chunk_size) smin = chunk_size;\n\t\t\tif (smax<chunk_size) smax = chunk_size;\n\t\t\tsavg += chunk_size;\n\n\t\t\ttot_chunks ++;\n\t\t\tsample_idx += stsc->entries[i].samplesPerChunk;\n\t\t\tif (i+1==stsc->nb_entries) break;\n\t\t\tnb_chunk ++;\n\t\t\tif (stsc->entries[i].firstChunk + nb_chunk == stsc->entries[i+1].firstChunk) break;\n\t\t}\n\t}\n\tif (tot_chunks) {\n\t\tdavg /= tot_chunks;\n\t\tsavg /= tot_chunks;\n\t}\n\tif (dur_min) *dur_min = dmin;\n\tif (dur_avg) *dur_avg = (u32) davg;\n\tif (dur_max) *dur_max = dmax;\n\n\tif (size_min) *size_min = smin;\n\tif (size_avg) *size_avg = (u32) savg;\n\tif (size_max) *size_max = smax;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_fragment_defaults(GF_ISOFile *the_file, u32 trackNumber,\n                                     u32 *defaultDuration, u32 *defaultSize, u32 *defaultDescriptionIndex,\n                                     u32 *defaultRandomAccess, u8 *defaultPadding, u16 *defaultDegradationPriority)\n{\n\tGF_TrackBox *trak;\n\tGF_StscEntry *sc_ent;\n\tu32 i, j, maxValue, value;\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tGF_TrackExtendsBox *trex;\n#endif\n\tGF_SampleTableBox *stbl;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\t/*if trex is already set, restore flags*/\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\ttrex = the_file->moov->mvex ? GetTrex(the_file->moov, gf_isom_get_track_id(the_file,trackNumber) ) : NULL;\n\tif (trex) {\n\t\ttrex->track = trak;\n\n\t\tif (defaultDuration) *defaultDuration = trex->def_sample_duration;\n\t\tif (defaultSize) *defaultSize = trex->def_sample_size;\n\t\tif (defaultDescriptionIndex) *defaultDescriptionIndex = trex->def_sample_desc_index;\n\t\tif (defaultRandomAccess) *defaultRandomAccess = GF_ISOM_GET_FRAG_SYNC(trex->def_sample_flags);\n\t\tif (defaultPadding) *defaultPadding = GF_ISOM_GET_FRAG_PAD(trex->def_sample_flags);\n\t\tif (defaultDegradationPriority) *defaultDegradationPriority = GF_ISOM_GET_FRAG_DEG(trex->def_sample_flags);\n\t\treturn GF_OK;\n\t}\n#endif\n\n\tstbl = trak->Media->information->sampleTable;\n\tif (!stbl->TimeToSample || !stbl->SampleSize || !stbl->SampleToChunk) return GF_ISOM_INVALID_FILE;\n\n\n\t//duration\n\tif (defaultDuration) {\n\t\tmaxValue = value = 0;\n\t\tfor (i=0; i<stbl->TimeToSample->nb_entries; i++) {\n\t\t\tif (stbl->TimeToSample->entries[i].sampleCount>maxValue) {\n\t\t\t\tvalue = stbl->TimeToSample->entries[i].sampleDelta;\n\t\t\t\tmaxValue = stbl->TimeToSample->entries[i].sampleCount;\n\t\t\t}\n\t\t}\n\t\t*defaultDuration = value;\n\t}\n\t//size\n\tif (defaultSize) {\n\t\t*defaultSize = stbl->SampleSize->sampleSize;\n\t}\n\t//descIndex\n\tif (defaultDescriptionIndex) {\n\t\tGF_SampleToChunkBox *stsc= stbl->SampleToChunk;\n\t\tmaxValue = value = 0;\n\t\tfor (i=0; i<stsc->nb_entries; i++) {\n\t\t\tsc_ent = &stsc->entries[i];\n\t\t\tif ((sc_ent->nextChunk - sc_ent->firstChunk) * sc_ent->samplesPerChunk > maxValue) {\n\t\t\t\tvalue = sc_ent->sampleDescriptionIndex;\n\t\t\t\tmaxValue = (sc_ent->nextChunk - sc_ent->firstChunk) * sc_ent->samplesPerChunk;\n\t\t\t}\n\t\t}\n\t\t*defaultDescriptionIndex = value ? value : 1;\n\t}\n\t//RAP\n\tif (defaultRandomAccess) {\n\t\t//no sync table is ALL RAP\n\t\t*defaultRandomAccess = stbl->SyncSample ? 0 : 1;\n\t\tif (stbl->SyncSample\n\t\t        && (stbl->SyncSample->nb_entries == stbl->SampleSize->sampleCount)) {\n\t\t\t*defaultRandomAccess = 1;\n\t\t}\n\t}\n\t//defaultPadding\n\tif (defaultPadding) {\n\t\t*defaultPadding = 0;\n\t\tif (stbl->PaddingBits) {\n\t\t\tmaxValue = 0;\n\t\t\tfor (i=0; i<stbl->PaddingBits->SampleCount; i++) {\n\t\t\t\tvalue = 0;\n\t\t\t\tfor (j=0; j<stbl->PaddingBits->SampleCount; j++) {\n\t\t\t\t\tif (stbl->PaddingBits->padbits[i]==stbl->PaddingBits->padbits[j]) {\n\t\t\t\t\t\tvalue ++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (value>maxValue) {\n\t\t\t\t\tmaxValue = value;\n\t\t\t\t\t*defaultPadding = stbl->PaddingBits->padbits[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t//defaultDegradationPriority\n\tif (defaultDegradationPriority) {\n\t\t*defaultDegradationPriority = 0;\n\t\tif (stbl->DegradationPriority) {\n\t\t\tmaxValue = 0;\n\t\t\tfor (i=0; i<stbl->DegradationPriority->nb_entries; i++) {\n\t\t\t\tvalue = 0;\n\t\t\t\tfor (j=0; j<stbl->DegradationPriority->nb_entries; j++) {\n\t\t\t\t\tif (stbl->DegradationPriority->priorities[i]==stbl->DegradationPriority->priorities[j]) {\n\t\t\t\t\t\tvalue ++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (value>maxValue) {\n\t\t\t\t\tmaxValue = value;\n\t\t\t\t\t*defaultDegradationPriority = stbl->DegradationPriority->priorities[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\n\nGF_EXPORT\nGF_Err gf_isom_refresh_fragmented(GF_ISOFile *movie, u64 *MissingBytes, const char *new_location)\n{\n#ifdef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\treturn GF_NOT_SUPPORTED;\n#else\n\tu64 prevsize, size;\n\tu32 i;\n\tif (!movie || !movie->movieFileMap || !movie->moov) return GF_BAD_PARAM;\n\tif (movie->openMode != GF_ISOM_OPEN_READ) return GF_BAD_PARAM;\n\n\t/*refresh size*/\n\tsize = movie->movieFileMap ? gf_bs_get_size(movie->movieFileMap->bs) : 0;\n\n\tif (new_location) {\n\t\tBool delete_map;\n\t\tGF_DataMap *previous_movie_fileMap_address = movie->movieFileMap;\n\t\tGF_Err e;\n\n\t\te = gf_isom_datamap_new(new_location, NULL, GF_ISOM_DATA_MAP_READ_ONLY, &movie->movieFileMap);\n\t\tif (e) {\n\t\t\tmovie->movieFileMap = previous_movie_fileMap_address;\n\t\t\treturn e;\n\t\t}\n\n\t\tdelete_map = (previous_movie_fileMap_address != NULL ? GF_TRUE: GF_FALSE);\n\t\tfor (i=0; i<gf_list_count(movie->moov->trackList); i++) {\n\t\t\tGF_TrackBox *trak = (GF_TrackBox *)gf_list_get(movie->moov->trackList, i);\n\t\t\tif (trak->Media->information->dataHandler == previous_movie_fileMap_address) {\n\t\t\t\t//reaasign for later destruction\n\t\t\t\ttrak->Media->information->scalableDataHandler = movie->movieFileMap;\n\t\t\t\t//reassign for Media_GetSample function\n\t\t\t\ttrak->Media->information->dataHandler = movie->movieFileMap;\n\t\t\t} else if (trak->Media->information->scalableDataHandler == previous_movie_fileMap_address) {\n\t\t\t\tdelete_map = GF_FALSE;\n\t\t\t}\n\t\t}\n\t\tif (delete_map) {\n\t\t\tgf_isom_datamap_del(previous_movie_fileMap_address);\n\t\t}\n\t}\n\n\tprevsize = gf_bs_get_refreshed_size(movie->movieFileMap->bs);\n\tif (prevsize==size) return GF_OK;\n\n\tif (!movie->moov->mvex)\n\t\treturn GF_OK;\n\n\t//ok parse root boxes\n\treturn gf_isom_parse_movie_boxes(movie, NULL, MissingBytes, GF_TRUE);\n#endif\n}\n\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\nGF_EXPORT\nvoid gf_isom_set_single_moof_mode(GF_ISOFile *movie, Bool mode)\n{\n\tmovie->single_moof_mode = mode;\n}\n#endif\n\nGF_EXPORT\nGF_Err gf_isom_reset_data_offset(GF_ISOFile *movie, u64 *top_box_start)\n{\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tu32 i, count;\n\tif (!movie || !movie->moov) return GF_BAD_PARAM;\n\tif (top_box_start) *top_box_start = movie->current_top_box_start;\n\tmovie->current_top_box_start = 0;\n\tmovie->NextMoofNumber = 0;\n\tif (movie->moov->mvex && movie->single_moof_mode) {\n\t\tmovie->single_moof_state = 0;\n\t}\n\tcount = gf_list_count(movie->moov->trackList);\n\tfor (i=0; i<count; i++) {\n\t\tGF_TrackBox *tk = gf_list_get(movie->moov->trackList, i);\n\t\ttk->first_traf_merged = GF_FALSE;\n\t}\n#endif\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_current_top_box_offset(GF_ISOFile *movie, u64 *current_top_box_offset)\n{\n\tif (!movie || !movie->moov || !current_top_box_offset) return GF_BAD_PARAM;\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\t*current_top_box_offset = movie->current_top_box_start;\n\treturn GF_OK;\n#else\n\treturn GF_NOT_SUPPORTED;\n#endif\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_removed_bytes(GF_ISOFile *movie, u64 bytes_removed)\n{\n\tif (!movie || !movie->moov) return GF_BAD_PARAM;\n\tmovie->bytes_removed = bytes_removed;\n\treturn GF_OK;\n}\n\nGF_Err gf_isom_purge_samples(GF_ISOFile *the_file, u32 trackNumber, u32 nb_samples)\n{\n\tGF_TrackBox *trak;\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tGF_Err e;\n\tGF_TrackExtendsBox *trex;\n\tGF_SampleTableBox *stbl;\n#endif\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\t/*if trex is already set, restore flags*/\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\ttrex = the_file->moov->mvex ? GetTrex(the_file->moov, gf_isom_get_track_id(the_file,trackNumber) ) : NULL;\n\tif (!trex) return GF_BAD_PARAM;\n\n\t//first unpack chunk offsets and CTS\n\te = stbl_UnpackOffsets(trak->Media->information->sampleTable);\n\tif (e) return e;\n\te = stbl_unpackCTS(trak->Media->information->sampleTable);\n\tif (e) return e;\n\n\tstbl = trak->Media->information->sampleTable;\n\tif (!stbl->TimeToSample || !stbl->SampleSize || !stbl->SampleToChunk) return GF_ISOM_INVALID_FILE;\n\n\t//remove at once nb_samples in stts, ctts, stsz, stco, stsc and stdp (n-times removal is way too slow)\n\t//do NOT change the order DTS, CTS, size chunk\n\tstbl_RemoveDTS(stbl, 1, nb_samples, 0);\n\tstbl_RemoveCTS(stbl, 1, nb_samples);\n\tstbl_RemoveSize(stbl, 1, nb_samples);\n\tstbl_RemoveChunk(stbl, 1, nb_samples);\n\tstbl_RemoveRedundant(stbl, 1, nb_samples);\n\n\t//then remove sample per sample for the rest, which is either\n\t//- sparse data\n\t//- allocated structure rather than memmove-able array\n\t//- not very frequent info (paddind bits)\n\twhile (nb_samples) {\n\t\tstbl_RemoveRAP(stbl, 1);\n\t\tstbl_RemoveShadow(stbl, 1);\n\t\tstbl_RemoveSubSample(stbl, 1);\n\t\tstbl_RemovePaddingBits(stbl, 1);\n\t\tstbl_RemoveSampleGroup(stbl, 1);\n\t\tnb_samples--;\n\t}\n\treturn GF_OK;\n#else\n\treturn GF_NOT_SUPPORTED;\n#endif\n}\n\n\n#define RECREATE_BOX(_a, __cast)\t\\\n    if (_a) {\t\\\n        type = _a->type;\\\n        gf_isom_box_del_parent(&stbl->child_boxes, (GF_Box *)_a);\\\n        _a = __cast gf_isom_box_new_parent(&stbl->child_boxes, type);\\\n    }\\\n\n\nGF_EXPORT\nGF_Err gf_isom_reset_tables(GF_ISOFile *movie, Bool reset_sample_count)\n{\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tu32 i, j;\n\n\tif (!movie || !movie->moov || !movie->moov->mvex) return GF_BAD_PARAM;\n\tfor (i=0; i<gf_list_count(movie->moov->trackList); i++) {\n\t\tGF_Box *a;\n\t\tGF_TrackBox *trak = (GF_TrackBox *)gf_list_get(movie->moov->trackList, i);\n\n\t\tu32 type, dur;\n\t\tu64 dts;\n\t\tGF_SampleTableBox *stbl = trak->Media->information->sampleTable;\n\n\t\ttrak->sample_count_at_seg_start += stbl->SampleSize->sampleCount;\n\t\tif (trak->sample_count_at_seg_start) {\n\t\t\tGF_Err e;\n\t\t\te = stbl_GetSampleDTS_and_Duration(stbl->TimeToSample, stbl->SampleSize->sampleCount, &dts, &dur);\n\t\t\tif (e == GF_OK) {\n\t\t\t\ttrak->dts_at_seg_start += dts + dur;\n\t\t\t}\n\t\t}\n\n\t\tRECREATE_BOX(stbl->ChunkOffset, (GF_Box *));\n\t\tRECREATE_BOX(stbl->CompositionOffset, (GF_CompositionOffsetBox *));\n\t\tRECREATE_BOX(stbl->DegradationPriority, (GF_DegradationPriorityBox *));\n\t\tRECREATE_BOX(stbl->PaddingBits, (GF_PaddingBitsBox *));\n\t\tRECREATE_BOX(stbl->SampleDep, (GF_SampleDependencyTypeBox *));\n\t\tRECREATE_BOX(stbl->SampleSize, (GF_SampleSizeBox *));\n\t\tRECREATE_BOX(stbl->SampleToChunk, (GF_SampleToChunkBox *));\n\t\tRECREATE_BOX(stbl->ShadowSync, (GF_ShadowSyncBox *));\n\t\tRECREATE_BOX(stbl->SyncSample, (GF_SyncSampleBox *));\n\t\tRECREATE_BOX(stbl->TimeToSample, (GF_TimeToSampleBox *));\n\n\t\tgf_isom_box_array_del_parent(&stbl->child_boxes, stbl->sai_offsets);\n\t\tstbl->sai_offsets = NULL;\n\n\t\tgf_isom_box_array_del_parent(&stbl->child_boxes, stbl->sai_sizes);\n\t\tstbl->sai_sizes = NULL;\n\n\t\tgf_isom_box_array_del_parent(&stbl->child_boxes, stbl->sampleGroups);\n\t\tstbl->sampleGroups = NULL;\n\n\t\tj = stbl->nb_sgpd_in_stbl;\n\t\twhile ((a = (GF_Box *)gf_list_enum(stbl->sampleGroupsDescription, &j))) {\n\t\t\tgf_isom_box_del_parent(&stbl->child_boxes, a);\n\t\t\tj--;\n\t\t\tgf_list_rem(stbl->sampleGroupsDescription, j);\n\t\t}\n\n#if 0\n\t\tj = stbl->nb_stbl_boxes;\n\t\twhile ((a = (GF_Box *)gf_list_enum(stbl->child_boxes, &j))) {\n\t\t\tgf_isom_box_del_parent(&stbl->child_boxes, a);\n\t\t\tj--;\n\t\t}\n#endif\n\n\t\tif (reset_sample_count) {\n\t\t\ttrak->Media->information->sampleTable->SampleSize->sampleCount = 0;\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t\t\ttrak->sample_count_at_seg_start = 0;\n\t\t\ttrak->dts_at_seg_start = 0;\n\t\t\ttrak->first_traf_merged = GF_FALSE;\n#endif\n\t\t}\n\n\t}\n\tif (reset_sample_count) {\n\t\tmovie->NextMoofNumber = 0;\n\t}\n#endif\n\treturn GF_OK;\n\n}\n\nGF_EXPORT\nGF_Err gf_isom_release_segment(GF_ISOFile *movie, Bool reset_tables)\n{\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tu32 i, j, base_track_sample_count;\n\tBool has_scalable;\n\tGF_Box *a;\n\tif (!movie || !movie->moov || !movie->moov->mvex) return GF_BAD_PARAM;\n\thas_scalable = gf_isom_needs_layer_reconstruction(movie);\n\tbase_track_sample_count = 0;\n\tmovie->moov->compressed_diff = 0;\n\tfor (i=0; i<gf_list_count(movie->moov->trackList); i++) {\n\t\tGF_TrackBox *trak = (GF_TrackBox*)gf_list_get(movie->moov->trackList, i);\n\t\ttrak->first_traf_merged = GF_FALSE;\n\t\tif (trak->Media->information->dataHandler == movie->movieFileMap) {\n\t\t\ttrak->Media->information->dataHandler = NULL;\n\t\t}\n\t\tif (trak->Media->information->scalableDataHandler == movie->movieFileMap) {\n\t\t\ttrak->Media->information->scalableDataHandler = NULL;\n\t\t} else {\n\t\t\tif (trak->Media->information->scalableDataHandler==trak->Media->information->dataHandler)\n\t\t\t\ttrak->Media->information->dataHandler = NULL;\n\n\t\t\tgf_isom_datamap_del(trak->Media->information->scalableDataHandler);\n\t\t\ttrak->Media->information->scalableDataHandler = NULL;\n\t\t}\n\n\n\t\tif (reset_tables) {\n\t\t\tu32 type, dur;\n\t\t\tu64 dts;\n\t\t\tGF_SampleTableBox *stbl = trak->Media->information->sampleTable;\n\n\t\t\tif (has_scalable) {\n\t\t\t\t//check if the base reference is in the file - if not, do not consider the track is scalable.\n\t\t\t\tif (gf_isom_get_reference_count(movie, i+1, GF_ISOM_REF_BASE) > 0) {\n\t\t\t\t\tu32 on_track=0;\n\t\t\t\t\tGF_TrackBox *base;\n\t\t\t\t\tgf_isom_get_reference(movie, i+1, GF_ISOM_REF_BASE, 1, &on_track);\n\n\t\t\t\t\tbase = gf_isom_get_track_from_file(movie, on_track);\n\t\t\t\t\tif (!base) {\n\t\t\t\t\t\tbase_track_sample_count=0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbase_track_sample_count = base->Media->information->sampleTable->SampleSize->sampleCount;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ttrak->sample_count_at_seg_start += base_track_sample_count ? base_track_sample_count : stbl->SampleSize->sampleCount;\n\n\t\t\tif (trak->sample_count_at_seg_start) {\n\t\t\t\tGF_Err e;\n\t\t\t\te = stbl_GetSampleDTS_and_Duration(stbl->TimeToSample, stbl->SampleSize->sampleCount, &dts, &dur);\n\t\t\t\tif (e == GF_OK) {\n\t\t\t\t\ttrak->dts_at_seg_start += dts + dur;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tRECREATE_BOX(stbl->ChunkOffset, (GF_Box *));\n\t\t\tRECREATE_BOX(stbl->CompositionOffset, (GF_CompositionOffsetBox *));\n\t\t\tRECREATE_BOX(stbl->DegradationPriority, (GF_DegradationPriorityBox *));\n\t\t\tRECREATE_BOX(stbl->PaddingBits, (GF_PaddingBitsBox *));\n\t\t\tRECREATE_BOX(stbl->SampleDep, (GF_SampleDependencyTypeBox *));\n\t\t\tRECREATE_BOX(stbl->SampleSize, (GF_SampleSizeBox *));\n\t\t\tRECREATE_BOX(stbl->SampleToChunk, (GF_SampleToChunkBox *));\n\t\t\tRECREATE_BOX(stbl->ShadowSync, (GF_ShadowSyncBox *));\n\t\t\tRECREATE_BOX(stbl->SyncSample, (GF_SyncSampleBox *));\n\t\t\tRECREATE_BOX(stbl->TimeToSample, (GF_TimeToSampleBox *));\n\n\t\t\tgf_isom_box_array_del_parent(&stbl->child_boxes, stbl->sai_offsets);\n\t\t\tstbl->sai_offsets = NULL;\n\n\t\t\tgf_isom_box_array_del_parent(&stbl->child_boxes, stbl->sai_sizes);\n\t\t\tstbl->sai_sizes = NULL;\n\n\t\t\tgf_isom_box_array_del_parent(&stbl->child_boxes, stbl->sampleGroups);\n\t\t\tstbl->sampleGroups = NULL;\n\n\t\t\tif (trak->sample_encryption) {\n\t\t\t\tif (trak->Media->information->sampleTable->child_boxes) {\n\t\t\t\t\tgf_list_del_item(trak->Media->information->sampleTable->child_boxes, trak->sample_encryption);\n\t\t\t\t}\n\t\t\t\tgf_isom_box_del_parent(&trak->child_boxes, (GF_Box*)trak->sample_encryption);\n\t\t\t\ttrak->sample_encryption = NULL;\n\t\t\t}\n\n\t\t\tj = stbl->nb_sgpd_in_stbl;\n\t\t\twhile ((a = (GF_Box *)gf_list_enum(stbl->sampleGroupsDescription, &j))) {\n\t\t\t\tgf_isom_box_del_parent(&stbl->child_boxes, a);\n\t\t\t\tj--;\n\t\t\t\tgf_list_rem(stbl->sampleGroupsDescription, j);\n\t\t\t}\n\n\t\t\tif (stbl->traf_map) {\n\t\t\t\tfor (j=0; j<stbl->traf_map->nb_entries; j++) {\n\t\t\t\t\tif (stbl->traf_map->frag_starts[j].moof_template)\n\t\t\t\t\t\tgf_free(stbl->traf_map->frag_starts[j].moof_template);\n\t\t\t\t}\n\t\t\t\tmemset(stbl->traf_map->frag_starts, 0, sizeof(GF_TrafMapEntry)*stbl->traf_map->nb_alloc);\n\t\t\t\tstbl->traf_map->nb_entries = 0;\n\t\t\t}\n\n#if 0 // TO CHECK\n\t\t\tj = ptr->nb_stbl_boxes;\n\t\t\twhile ((a = (GF_Box *)gf_list_enum(stbl->child_boxes, &j))) {\n\t\t\t\tgf_isom_box_del_parent(&stbl->child_boxes, a);\n\t\t\t\tj--;\n\t\t\t}\n#endif\n\t\t}\n\n\n\t\tj = 0;\n\t\twhile ((a = (GF_Box *)gf_list_enum(movie->moov->child_boxes, &j))) {\n\t\t\tif (a->type == GF_ISOM_BOX_TYPE_PSSH) {\n\t\t\t\tgf_isom_box_del_parent(&movie->moov->child_boxes, a);\n\t\t\t\tj--;\n\t\t\t}\n\t\t}\n\t}\n\n\tgf_isom_datamap_del(movie->movieFileMap);\n\tmovie->movieFileMap = NULL;\n#endif\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_open_segment(GF_ISOFile *movie, const char *fileName, u64 start_range, u64 end_range, GF_ISOSegOpenMode flags)\n{\n#ifdef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\treturn GF_NOT_SUPPORTED;\n#else\n\tu64 MissingBytes;\n\tGF_Err e;\n\tu32 i;\n\tBool segment_map_assigned = GF_FALSE;\n\tBool is_scalable_segment = (flags & GF_ISOM_SEGMENT_SCALABLE_FLAG) ? GF_TRUE : GF_FALSE;\n\tBool no_order_check = (flags & GF_ISOM_SEGMENT_NO_ORDER_FLAG) ? GF_TRUE: GF_FALSE;\n\tGF_DataMap *tmp = NULL;\n\tGF_DataMap *orig_file_map = NULL;\n\tif (!movie || !movie->moov || !movie->moov->mvex) return GF_BAD_PARAM;\n\tif (movie->openMode != GF_ISOM_OPEN_READ) return GF_BAD_PARAM;\n\n\t/*this is a scalable segment - use a temp data map for the associated track(s) but do NOT touch the movie file map*/\n\tif (is_scalable_segment) {\n\t\ttmp = NULL;\n\t\te = gf_isom_datamap_new(fileName, NULL, GF_ISOM_DATA_MAP_READ_ONLY, &tmp);\n\t\tif (e) return e;\n\n\t\torig_file_map = movie->movieFileMap;\n\t\tmovie->movieFileMap = tmp;\n\t} else {\n\t\tif (movie->movieFileMap)\n\t\t\tgf_isom_release_segment(movie, GF_FALSE);\n\n\t\te = gf_isom_datamap_new(fileName, NULL, GF_ISOM_DATA_MAP_READ_ONLY, &movie->movieFileMap);\n\t\tif (e) return e;\n\t}\n\tmovie->moov->compressed_diff = 0;\n\tmovie->current_top_box_start = 0;\n\n\tif (start_range || end_range) {\n\t\tif (end_range > start_range) {\n\t\t\tgf_bs_seek(movie->movieFileMap->bs, end_range+1);\n\t\t\tgf_bs_truncate(movie->movieFileMap->bs);\n\t\t}\n\t\tgf_bs_seek(movie->movieFileMap->bs, start_range);\n\t\tmovie->current_top_box_start = start_range;\n\t}\n\n\tfor (i=0; i<gf_list_count(movie->moov->trackList); i++) {\n\t\tGF_TrackBox *trak = (GF_TrackBox*)gf_list_get(movie->moov->trackList, i);\n\n\t\tif (!is_scalable_segment) {\n\t\t\t/*reset data handler to new segment*/\n\t\t\tif (trak->Media->information->dataHandler == NULL) {\n\t\t\t\ttrak->Media->information->dataHandler = movie->movieFileMap;\n\t\t\t}\n\t\t} else {\n\t\t\ttrak->present_in_scalable_segment = GF_FALSE;\n\t\t}\n\t}\n\tif (no_order_check) movie->NextMoofNumber = 0;\n\n\t//ok parse root boxes\n\te = gf_isom_parse_movie_boxes(movie, NULL, &MissingBytes, GF_TRUE);\n\n\tif (!is_scalable_segment)\n\t\treturn e;\n\n\tfor (i=0; i<gf_list_count(movie->moov->trackList); i++) {\n\t\tGF_TrackBox *trak = (GF_TrackBox*)gf_list_get(movie->moov->trackList, i);\n\t\tif (trak->present_in_scalable_segment) {\n\t\t\t/*store the temp dataHandler into scalableDataHandler so that it will not be destroyed\n\t\t\tif we append another representation - destruction of this data handler is done in release_segment*/\n\t\t\ttrak->Media->information->scalableDataHandler = tmp;\n\t\t\tif (!segment_map_assigned) {\n\t\t\t\ttrak->Media->information->scalableDataHandler = tmp;\n\t\t\t\tsegment_map_assigned = GF_TRUE;\n\t\t\t}\n\t\t\t//and update the regular dataHandler for the Media_GetSample function\n\t\t\ttrak->Media->information->dataHandler = tmp;\n\t\t}\n\t}\n\tmovie->movieFileMap = \torig_file_map;\n\treturn e;\n#endif\n}\n\nGF_EXPORT\nGF_ISOTrackID gf_isom_get_highest_track_in_scalable_segment(GF_ISOFile *movie, u32 for_base_track)\n{\n#ifdef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\treturn 0;\n#else\n\ts32 max_ref;\n\tu32 i, j;\n\tGF_ISOTrackID track_id;\n\n\tmax_ref = 0;\n\ttrack_id = 0;\n\tfor (i=0; i<gf_list_count(movie->moov->trackList); i++) {\n\t\ts32 ref;\n\t\tu32 ref_type = GF_ISOM_REF_SCAL;\n\t\tGF_TrackBox *trak = (GF_TrackBox*)gf_list_get(movie->moov->trackList, i);\n\t\tif (! trak->present_in_scalable_segment) continue;\n\n\t\tref = gf_isom_get_reference_count(movie, i+1, ref_type);\n\t\tif (ref<=0) {\n\t\t\t//handle implicit reconstruction for LHE1/LHV1, check sbas track ref\n\t\t\tu32 subtype = gf_isom_get_media_subtype(movie, i+1, 1);\n\t\t\tswitch (subtype) {\n\t\t\tcase GF_ISOM_SUBTYPE_LHE1:\n\t\t\tcase GF_ISOM_SUBTYPE_LHV1:\n\t\t\t\tref = gf_isom_get_reference_count(movie, i+1, GF_ISOM_REF_BASE);\n\t\t\t\tif (ref<=0) continue;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (ref<=max_ref) continue;\n\n\t\tfor (j=0; j< (u32) ref; j++) {\n\t\t\tu32 on_track=0;\n\t\t\tgf_isom_get_reference(movie, i+1, GF_ISOM_REF_BASE, j+1, &on_track);\n\t\t\tif (on_track==for_base_track) {\n\t\t\t\tmax_ref = ref;\n\t\t\t\ttrack_id = trak->Header->trackID;\n\t\t\t}\n\t\t}\n\t}\n\treturn track_id;\n#endif\n}\n\n\nGF_EXPORT\nGF_Err gf_isom_text_set_streaming_mode(GF_ISOFile *movie, Bool do_convert)\n{\n\tif (!movie) return GF_BAD_PARAM;\n\tmovie->convert_streaming_text = do_convert;\n\treturn GF_OK;\n}\n\n\nGF_EXPORT\nGF_GenericSampleDescription *gf_isom_get_generic_sample_description(GF_ISOFile *movie, u32 trackNumber, u32 StreamDescriptionIndex)\n{\n\tGF_GenericVisualSampleEntryBox *entry;\n\tGF_GenericAudioSampleEntryBox *gena;\n\tGF_GenericSampleEntryBox *genm;\n\tGF_TrackBox *trak;\n\tGF_GenericSampleDescription *udesc;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !StreamDescriptionIndex || !trak->Media || !trak->Media->information || !trak->Media->information->sampleTable) return 0;\n\n\tentry = (GF_GenericVisualSampleEntryBox *)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, StreamDescriptionIndex-1);\n\t//no entry or MPEG entry:\n\tif (!entry || IsMP4Description(entry->type) ) return NULL;\n\t//if we handle the description return false\n\tswitch (entry->type) {\n\tcase GF_ISOM_SUBTYPE_3GP_AMR:\n\tcase GF_ISOM_SUBTYPE_3GP_AMR_WB:\n\tcase GF_ISOM_SUBTYPE_3GP_EVRC:\n\tcase GF_ISOM_SUBTYPE_3GP_QCELP:\n\tcase GF_ISOM_SUBTYPE_3GP_SMV:\n\tcase GF_ISOM_SUBTYPE_3GP_H263:\n\t\treturn NULL;\n\tcase GF_ISOM_BOX_TYPE_GNRV:\n\t\tGF_SAFEALLOC(udesc, GF_GenericSampleDescription);\n\t\tif (!udesc) return NULL;\n\t\tif (entry->EntryType == GF_ISOM_BOX_TYPE_UUID) {\n\t\t\tmemcpy(udesc->UUID, ((GF_UUIDBox*)entry)->uuid, sizeof(bin128));\n\t\t} else {\n\t\t\tudesc->codec_tag = entry->EntryType;\n\t\t}\n\t\tudesc->version = entry->version;\n\t\tudesc->revision = entry->revision;\n\t\tudesc->vendor_code = entry->vendor;\n\t\tudesc->temporal_quality = entry->temporal_quality;\n\t\tudesc->spatial_quality = entry->spatial_quality;\n\t\tudesc->width = entry->Width;\n\t\tudesc->height = entry->Height;\n\t\tudesc->h_res = entry->horiz_res;\n\t\tudesc->v_res = entry->vert_res;\n\t\tstrcpy(udesc->compressor_name, entry->compressor_name);\n\t\tudesc->depth = entry->bit_depth;\n\t\tudesc->color_table_index = entry->color_table_index;\n\t\tif (entry->data_size) {\n\t\t\tudesc->extension_buf_size = entry->data_size;\n\t\t\tudesc->extension_buf = (char*)gf_malloc(sizeof(char) * entry->data_size);\n\t\t\tif (!udesc->extension_buf) {\n\t\t\t\tgf_free(udesc);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tmemcpy(udesc->extension_buf, entry->data, entry->data_size);\n\t\t}\n\t\treturn udesc;\n\tcase GF_ISOM_BOX_TYPE_GNRA:\n\t\tgena = (GF_GenericAudioSampleEntryBox *)entry;\n\t\tGF_SAFEALLOC(udesc, GF_GenericSampleDescription);\n\t\tif (!udesc) return NULL;\n\t\tif (gena->EntryType == GF_ISOM_BOX_TYPE_UUID) {\n\t\t\tmemcpy(udesc->UUID, ((GF_UUIDBox*)gena)->uuid, sizeof(bin128));\n\t\t} else {\n\t\t\tudesc->codec_tag = gena->EntryType;\n\t\t}\n\t\tudesc->version = gena->version;\n\t\tudesc->revision = gena->revision;\n\t\tudesc->vendor_code = gena->vendor;\n\t\tudesc->samplerate = gena->samplerate_hi;\n\t\tudesc->bits_per_sample = gena->bitspersample;\n\t\tudesc->nb_channels = gena->channel_count;\n\t\tif (gena->data_size) {\n\t\t\tudesc->extension_buf_size = gena->data_size;\n\t\t\tudesc->extension_buf = (char*)gf_malloc(sizeof(char) * gena->data_size);\n\t\t\tif (!udesc->extension_buf) {\n\t\t\t\tgf_free(udesc);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tmemcpy(udesc->extension_buf, gena->data, gena->data_size);\n\t\t}\n\t\treturn udesc;\n\tcase GF_ISOM_BOX_TYPE_GNRM:\n\t\tgenm = (GF_GenericSampleEntryBox *)entry;\n\t\tGF_SAFEALLOC(udesc, GF_GenericSampleDescription);\n\t\tif (!udesc) return NULL;\n\t\tif (genm->EntryType == GF_ISOM_BOX_TYPE_UUID) {\n\t\t\tmemcpy(udesc->UUID, ((GF_UUIDBox*)genm)->uuid, sizeof(bin128));\n\t\t} else {\n\t\t\tudesc->codec_tag = genm->EntryType;\n\t\t}\n\t\tif (genm->data_size) {\n\t\t\tudesc->extension_buf_size = genm->data_size;\n\t\t\tudesc->extension_buf = (char*)gf_malloc(sizeof(char) * genm->data_size);\n\t\t\tif (!udesc->extension_buf) {\n\t\t\t\tgf_free(udesc);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tmemcpy(udesc->extension_buf, genm->data, genm->data_size);\n\t\t}\n\t\treturn udesc;\n\t}\n\treturn NULL;\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_visual_info(GF_ISOFile *movie, u32 trackNumber, u32 StreamDescriptionIndex, u32 *Width, u32 *Height)\n{\n\tGF_TrackBox *trak;\n\tGF_SampleEntryBox *entry;\n\tGF_SampleDescriptionBox *stsd;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tstsd = trak->Media->information->sampleTable->SampleDescription;\n\tif (!stsd) return movie->LastError = GF_ISOM_INVALID_FILE;\n\tif (!StreamDescriptionIndex || StreamDescriptionIndex > gf_list_count(stsd->child_boxes)) return movie->LastError = GF_BAD_PARAM;\n\n\tentry = (GF_SampleEntryBox *)gf_list_get(stsd->child_boxes, StreamDescriptionIndex - 1);\n\t//no support for generic sample entries (eg, no MPEG4 descriptor)\n\tif (entry == NULL) return GF_BAD_PARAM;\n\n\t//valid for MPEG visual, JPG and 3GPP H263\n\tif (entry->internal_type == GF_ISOM_SAMPLE_ENTRY_VIDEO) {\n\t\t*Width = ((GF_VisualSampleEntryBox*)entry)->Width;\n\t\t*Height = ((GF_VisualSampleEntryBox*)entry)->Height;\n\t} else if (trak->Media->handler->handlerType==GF_ISOM_MEDIA_SCENE) {\n\t\t*Width = trak->Header->width>>16;\n\t\t*Height = trak->Header->height>>16;\n\t} else {\n\t\treturn GF_BAD_PARAM;\n\t}\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_visual_bit_depth(GF_ISOFile* movie, u32 trackNumber, u32 StreamDescriptionIndex, u16* bitDepth)\n{\n\tGF_TrackBox* trak;\n\tGF_SampleEntryBox* entry;\n\tGF_SampleDescriptionBox* stsd;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tstsd = trak->Media->information->sampleTable->SampleDescription;\n\tif (!stsd) return movie->LastError = GF_ISOM_INVALID_FILE;\n\tif (!StreamDescriptionIndex || StreamDescriptionIndex > gf_list_count(stsd->child_boxes)) return movie->LastError = GF_BAD_PARAM;\n\n\tentry = (GF_SampleEntryBox*)gf_list_get(stsd->child_boxes, StreamDescriptionIndex - 1);\n\n\t//no support for generic sample entries (eg, no MPEG4 descriptor)\n\tif (entry == NULL) return GF_BAD_PARAM;\n\n\t//valid for MPEG visual, JPG and 3GPP H263\n\tif (entry->internal_type == GF_ISOM_SAMPLE_ENTRY_VIDEO) {\n\t\t*bitDepth = ((GF_VisualSampleEntryBox*)entry)->bit_depth;\n\t} else {\n\t\treturn GF_BAD_PARAM;\n\t}\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_audio_info(GF_ISOFile *movie, u32 trackNumber, u32 StreamDescriptionIndex, u32 *SampleRate, u32 *Channels, u32 *bitsPerSample)\n{\n\tGF_TrackBox *trak;\n\tGF_AudioSampleEntryBox *entry;\n\tGF_SampleDescriptionBox *stsd = NULL;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tif (trak->Media && trak->Media->information && trak->Media->information->sampleTable && trak->Media->information->sampleTable->SampleDescription)\n\t\tstsd = trak->Media->information->sampleTable->SampleDescription;\n\tif (!stsd) return movie->LastError = GF_ISOM_INVALID_FILE;\n\tif (!StreamDescriptionIndex || StreamDescriptionIndex > gf_list_count(stsd->child_boxes)) return movie->LastError = GF_BAD_PARAM;\n\n\tentry = (GF_AudioSampleEntryBox *)gf_list_get(stsd->child_boxes, StreamDescriptionIndex - 1);\n\t//no support for generic sample entries (eg, no MPEG4 descriptor)\n\tif (entry == NULL) return GF_BAD_PARAM;\n\n\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_AUDIO) return GF_BAD_PARAM;\n\n\tif (SampleRate) {\n\t\t(*SampleRate) = entry->samplerate_hi;\n\t\tif (entry->type==GF_ISOM_BOX_TYPE_MLPA) {\n\t\t\tu32 sr = entry->samplerate_hi;\n\t\t\tsr <<= 16;\n\t\t\tsr |= entry->samplerate_lo;\n\t\t\t(*SampleRate) = sr;\n\t\t}\n\t}\n\tif (Channels) (*Channels) = entry->channel_count;\n\tif (bitsPerSample) (*bitsPerSample) = (u8) entry->bitspersample;\n\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_audio_layout(GF_ISOFile *movie, u32 trackNumber, u32 StreamDescriptionIndex, GF_AudioChannelLayout *layout)\n{\n\tGF_TrackBox *trak;\n\tGF_SampleEntryBox *entry;\n\tGF_SampleDescriptionBox *stsd;\n\tGF_ChannelLayoutBox *chnl;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !layout) return GF_BAD_PARAM;\n\tmemset(layout, 0, sizeof(GF_AudioChannelLayout));\n\n\tstsd = trak->Media->information->sampleTable->SampleDescription;\n\tif (!stsd) return movie->LastError = GF_ISOM_INVALID_FILE;\n\tif (!StreamDescriptionIndex || StreamDescriptionIndex > gf_list_count(stsd->child_boxes)) return movie->LastError = GF_BAD_PARAM;\n\n\tentry = (GF_SampleEntryBox *)gf_list_get(stsd->child_boxes, StreamDescriptionIndex - 1);\n\t//no support for generic sample entries (eg, no MPEG4 descriptor)\n\tif (entry == NULL) return GF_BAD_PARAM;\n\n\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_AUDIO) return GF_BAD_PARAM;\n\tchnl = (GF_ChannelLayoutBox *) gf_isom_box_find_child(entry->child_boxes, GF_ISOM_BOX_TYPE_CHNL);\n\tif (!chnl) return GF_NOT_FOUND;\n\n\tmemcpy(layout, &chnl->layout, sizeof(GF_AudioChannelLayout));\n\treturn GF_OK;\n}\nGF_EXPORT\nGF_Err gf_isom_get_pixel_aspect_ratio(GF_ISOFile *movie, u32 trackNumber, u32 StreamDescriptionIndex, u32 *hSpacing, u32 *vSpacing)\n{\n\tGF_TrackBox *trak;\n\tGF_VisualSampleEntryBox *entry;\n\tGF_SampleDescriptionBox *stsd;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !hSpacing || !vSpacing) return GF_BAD_PARAM;\n\t*hSpacing = 1;\n\t*vSpacing = 1;\n\n\tstsd = trak->Media->information->sampleTable->SampleDescription;\n\tif (!stsd) return movie->LastError = GF_ISOM_INVALID_FILE;\n\tif (!StreamDescriptionIndex || StreamDescriptionIndex > gf_list_count(stsd->child_boxes)) return movie->LastError = GF_BAD_PARAM;\n\n\tentry = (GF_VisualSampleEntryBox *)gf_list_get(stsd->child_boxes, StreamDescriptionIndex - 1);\n\t//no support for generic sample entries (eg, no MPEG4 descriptor)\n\tif (entry == NULL) return GF_OK;\n\n\t//valid for MPEG visual, JPG and 3GPP H263\n\tif (entry->internal_type==GF_ISOM_SAMPLE_ENTRY_VIDEO) {\n\t\tGF_PixelAspectRatioBox *pasp = (GF_PixelAspectRatioBox *) gf_isom_box_find_child(entry->child_boxes, GF_ISOM_BOX_TYPE_PASP);\n\t\tif (pasp) {\n\t\t\t*hSpacing = pasp->hSpacing;\n\t\t\t*vSpacing = pasp->vSpacing;\n\t\t}\n\t\treturn GF_OK;\n\t} else {\n\t\treturn GF_BAD_PARAM;\n\t}\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_color_info(GF_ISOFile *movie, u32 trackNumber, u32 StreamDescriptionIndex, u32 *colour_type, u16 *colour_primaries, u16 *transfer_characteristics, u16 *matrix_coefficients, Bool *full_range_flag)\n{\n\tGF_TrackBox *trak;\n\tGF_VisualSampleEntryBox *entry;\n\tGF_SampleDescriptionBox *stsd;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tstsd = trak->Media->information->sampleTable->SampleDescription;\n\tif (!stsd) return movie->LastError = GF_ISOM_INVALID_FILE;\n\tif (!StreamDescriptionIndex || StreamDescriptionIndex > gf_list_count(stsd->child_boxes)) return movie->LastError = GF_BAD_PARAM;\n\n\tentry = (GF_VisualSampleEntryBox *)gf_list_get(stsd->child_boxes, StreamDescriptionIndex - 1);\n\t//no support for generic sample entries (eg, no MPEG4 descriptor)\n\tif (entry == NULL) return GF_OK;\n\n\t//valid for MPEG visual, JPG and 3GPP H263\n\tif (entry->internal_type!=GF_ISOM_SAMPLE_ENTRY_VIDEO) {\n\t\treturn GF_BAD_PARAM;\n\t}\n\tGF_ColourInformationBox *clr = (GF_ColourInformationBox *) gf_isom_box_find_child(entry->child_boxes, GF_ISOM_BOX_TYPE_COLR);\n\tif (!clr) return GF_NOT_FOUND;\n\n\tif (colour_type) *colour_type = clr->colour_type;\n\tif (colour_primaries) *colour_primaries = clr->colour_primaries;\n\tif (transfer_characteristics) *transfer_characteristics = clr->transfer_characteristics;\n\tif (matrix_coefficients) *matrix_coefficients = clr->matrix_coefficients;\n\tif (full_range_flag) *full_range_flag = clr->full_range_flag;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nconst char *gf_isom_get_filename(GF_ISOFile *movie)\n{\n\tif (!movie) return NULL;\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\tif (movie->finalName && !movie->fileName) return movie->finalName;\n#endif\n\treturn movie->fileName;\n}\n\n\nGF_EXPORT\nu8 gf_isom_get_pl_indication(GF_ISOFile *movie, GF_ISOProfileLevelType PL_Code)\n{\n\tGF_IsomInitialObjectDescriptor *iod;\n\tif (!movie || !movie->moov) return 0xFF;\n\tif (!movie->moov->iods || !movie->moov->iods->descriptor) return 0xFF;\n\tif (movie->moov->iods->descriptor->tag != GF_ODF_ISOM_IOD_TAG) return 0xFF;\n\n\tiod = (GF_IsomInitialObjectDescriptor *)movie->moov->iods->descriptor;\n\tswitch (PL_Code) {\n\tcase GF_ISOM_PL_AUDIO:\n\t\treturn iod->audio_profileAndLevel;\n\tcase GF_ISOM_PL_VISUAL:\n\t\treturn iod->visual_profileAndLevel;\n\tcase GF_ISOM_PL_GRAPHICS:\n\t\treturn iod->graphics_profileAndLevel;\n\tcase GF_ISOM_PL_SCENE:\n\t\treturn iod->scene_profileAndLevel;\n\tcase GF_ISOM_PL_OD:\n\t\treturn iod->OD_profileAndLevel;\n\tcase GF_ISOM_PL_INLINE:\n\t\treturn iod->inlineProfileFlag;\n\tcase GF_ISOM_PL_MPEGJ:\n\tdefault:\n\t\treturn 0xFF;\n\t}\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_track_matrix(GF_ISOFile *the_file, u32 trackNumber, u32 matrix[9])\n{\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Header) return GF_BAD_PARAM;\n\tmemcpy(matrix, trak->Header->matrix, sizeof(trak->Header->matrix));\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_track_layout_info(GF_ISOFile *movie, u32 trackNumber, u32 *width, u32 *height, s32 *translation_x, s32 *translation_y, s16 *layer)\n{\n\tGF_TrackBox *tk = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!tk) return GF_BAD_PARAM;\n\tif (width) *width = tk->Header->width>>16;\n\tif (height) *height = tk->Header->height>>16;\n\tif (layer) *layer = tk->Header->layer;\n\tif (translation_x) *translation_x = tk->Header->matrix[6] >> 16;\n\tif (translation_y) *translation_y = tk->Header->matrix[7] >> 16;\n\treturn GF_OK;\n}\n\n\n/*returns total amount of media bytes in track*/\nGF_EXPORT\nu64 gf_isom_get_media_data_size(GF_ISOFile *movie, u32 trackNumber)\n{\n\tu32 i;\n\tu64 size;\n\tGF_SampleSizeBox *stsz;\n\tGF_TrackBox *tk = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!tk) return 0;\n\tstsz = tk->Media->information->sampleTable->SampleSize;\n\tif (!stsz) return 0;\n\tif (stsz->sampleSize) return stsz->sampleSize*stsz->sampleCount;\n\tsize = 0;\n\tfor (i=0; i<stsz->sampleCount; i++) size += stsz->sizes[i];\n\treturn size;\n}\n\n\nGF_EXPORT\nvoid gf_isom_set_default_sync_track(GF_ISOFile *movie, u32 trackNumber)\n{\n\tGF_TrackBox *tk = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!tk) movie->es_id_default_sync = -1;\n\telse movie->es_id_default_sync = tk->Header->trackID;\n}\n\n\nGF_EXPORT\nBool gf_isom_is_single_av(GF_ISOFile *file)\n{\n\tu32 count, i, nb_any, nb_a, nb_v, nb_auxv, nb_pict, nb_scene, nb_od, nb_text;\n\tnb_auxv = nb_pict = nb_a = nb_v = nb_any = nb_scene = nb_od = nb_text = 0;\n\n\tif (!file->moov) return GF_FALSE;\n\tcount = gf_isom_get_track_count(file);\n\tfor (i=0; i<count; i++) {\n\t\tu32 mtype = gf_isom_get_media_type(file, i+1);\n\t\tswitch (mtype) {\n\t\tcase GF_ISOM_MEDIA_SCENE:\n\t\t\tif (gf_isom_get_sample_count(file, i+1)>1) nb_any++;\n\t\t\telse nb_scene++;\n\t\t\tbreak;\n\t\tcase GF_ISOM_MEDIA_OD:\n\t\t\tif (gf_isom_get_sample_count(file, i+1)>1) nb_any++;\n\t\t\telse nb_od++;\n\t\t\tbreak;\n\t\tcase GF_ISOM_MEDIA_TEXT:\n\t\tcase GF_ISOM_MEDIA_SUBT:\n\t\t\tnb_text++;\n\t\t\tbreak;\n\t\tcase GF_ISOM_MEDIA_AUDIO:\n\t\t\tnb_a++;\n\t\t\tbreak;\n        case GF_ISOM_MEDIA_AUXV:\n            /*discard file with images*/\n            if (gf_isom_get_sample_count(file, i+1)==1) nb_any++;\n            else nb_auxv++;\n            break;\n        case GF_ISOM_MEDIA_PICT:\n            /*discard file with images*/\n            if (gf_isom_get_sample_count(file, i+1)==1) nb_any++;\n            else nb_pict++;\n            break;\n\t\tcase GF_ISOM_MEDIA_VISUAL:\n\t\t\t/*discard file with images*/\n\t\t\tif (gf_isom_get_sample_count(file, i+1)==1) nb_any++;\n\t\t\telse nb_v++;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tnb_any++;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (nb_any) return GF_FALSE;\n\tif ((nb_scene<=1) && (nb_od<=1) && (nb_a<=1) && (nb_v+nb_pict+nb_auxv<=1) && (nb_text<=1) ) return GF_TRUE;\n\treturn GF_FALSE;\n}\n\nGF_EXPORT\nBool gf_isom_is_JPEG2000(GF_ISOFile *mov)\n{\n\treturn (mov && mov->is_jp2) ? GF_TRUE : GF_FALSE;\n}\n\nGF_EXPORT\nu32 gf_isom_guess_specification(GF_ISOFile *file)\n{\n\tu32 count, i, nb_any, nb_m4s, nb_a, nb_v, nb_auxv,nb_scene, nb_od, nb_mp3, nb_aac, nb_m4v, nb_avc, nb_amr, nb_h263, nb_qcelp, nb_evrc, nb_smv, nb_text, nb_pict;\n\n\tnb_m4s = nb_a = nb_v = nb_auxv = nb_any = nb_scene = nb_od = nb_mp3 = nb_aac = nb_m4v = nb_avc = nb_amr = nb_h263 = nb_qcelp = nb_evrc = nb_smv = nb_text = nb_pict = 0;\n\n\tif (file->is_jp2) {\n\t\tif (file->moov) return GF_ISOM_BRAND_MJP2;\n\t\treturn GF_ISOM_BRAND_JP2;\n\t}\n\tif (!file->moov) {\n\t\tif (!file->meta || !file->meta->handler) return 0;\n\t\treturn file->meta->handler->handlerType;\n\t}\n\n\tcount = gf_isom_get_track_count(file);\n\tfor (i=0; i<count; i++) {\n\t\tu32 mtype = gf_isom_get_media_type(file, i+1);\n\t\tu32 mstype = gf_isom_get_media_subtype(file, i+1, 1);\n\n\t\tif (mtype==GF_ISOM_MEDIA_SCENE) {\n\t\t\tnb_scene++;\n\t\t\t/*forces non-isma*/\n\t\t\tif (gf_isom_get_sample_count(file, i+1)>1) nb_m4s++;\n\t\t} else if (mtype==GF_ISOM_MEDIA_OD) {\n\t\t\tnb_od++;\n\t\t\t/*forces non-isma*/\n\t\t\tif (gf_isom_get_sample_count(file, i+1)>1) nb_m4s++;\n\t\t}\n\t\telse if ((mtype==GF_ISOM_MEDIA_TEXT) || (mtype==GF_ISOM_MEDIA_SUBT)) nb_text++;\n\t\telse if ((mtype==GF_ISOM_MEDIA_AUDIO) || gf_isom_is_video_handler_type(mtype) ) {\n\t\t\tswitch (mstype) {\n\t\t\tcase GF_ISOM_SUBTYPE_3GP_AMR:\n\t\t\tcase GF_ISOM_SUBTYPE_3GP_AMR_WB:\n\t\t\t\tnb_amr++;\n\t\t\t\tbreak;\n\t\t\tcase GF_ISOM_SUBTYPE_3GP_H263:\n\t\t\t\tnb_h263++;\n\t\t\t\tbreak;\n\t\t\tcase GF_ISOM_SUBTYPE_3GP_EVRC:\n\t\t\t\tnb_evrc++;\n\t\t\t\tbreak;\n\t\t\tcase GF_ISOM_SUBTYPE_3GP_QCELP:\n\t\t\t\tnb_qcelp++;\n\t\t\t\tbreak;\n\t\t\tcase GF_ISOM_SUBTYPE_3GP_SMV:\n\t\t\t\tnb_smv++;\n\t\t\t\tbreak;\n\t\t\tcase GF_ISOM_SUBTYPE_AVC_H264:\n\t\t\tcase GF_ISOM_SUBTYPE_AVC2_H264:\n\t\t\tcase GF_ISOM_SUBTYPE_AVC3_H264:\n\t\t\tcase GF_ISOM_SUBTYPE_AVC4_H264:\n\t\t\t\tnb_avc++;\n\t\t\t\tbreak;\n\t\t\tcase GF_ISOM_SUBTYPE_SVC_H264:\n\t\t\tcase GF_ISOM_SUBTYPE_MVC_H264:\n\t\t\t\tnb_avc++;\n\t\t\t\tbreak;\n\t\t\tcase GF_ISOM_SUBTYPE_MPEG4:\n\t\t\tcase GF_ISOM_SUBTYPE_MPEG4_CRYP:\n\t\t\t{\n\t\t\t\tGF_DecoderConfig *dcd = gf_isom_get_decoder_config(file, i+1, 1);\n\t\t\t\tif (!dcd) break;\n\t\t\t\tswitch (dcd->streamType) {\n\t\t\t\tcase GF_STREAM_VISUAL:\n\t\t\t\t\tif (dcd->objectTypeIndication==GF_CODECID_MPEG4_PART2) nb_m4v++;\n\t\t\t\t\telse if ((dcd->objectTypeIndication==GF_CODECID_AVC) || (dcd->objectTypeIndication==GF_CODECID_SVC) || (dcd->objectTypeIndication==GF_CODECID_MVC)) nb_avc++;\n\t\t\t\t\telse nb_v++;\n\t\t\t\t\tbreak;\n\t\t\t\tcase GF_STREAM_AUDIO:\n\t\t\t\t\tswitch (dcd->objectTypeIndication) {\n\t\t\t\t\tcase GF_CODECID_AAC_MPEG2_MP:\n\t\t\t\t\tcase GF_CODECID_AAC_MPEG2_LCP:\n\t\t\t\t\tcase GF_CODECID_AAC_MPEG2_SSRP:\n\t\t\t\t\tcase GF_CODECID_AAC_MPEG4:\n\t\t\t\t\t\tnb_aac++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase GF_CODECID_MPEG2_PART3:\n\t\t\t\t\tcase GF_CODECID_MPEG_AUDIO:\n\t\t\t\t\t\tnb_mp3++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase GF_CODECID_EVRC:\n\t\t\t\t\t\tnb_evrc++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase GF_CODECID_SMV:\n\t\t\t\t\t\tnb_smv++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase GF_CODECID_QCELP:\n\t\t\t\t\t\tnb_qcelp++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tnb_a++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t/*SHOULD NEVER HAPPEN - IF SO, BROKEN MPEG4 FILE*/\n\t\t\t\tdefault:\n\t\t\t\t\tnb_any++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tgf_odf_desc_del((GF_Descriptor *)dcd);\n\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif (mtype==GF_ISOM_MEDIA_VISUAL) nb_v++;\n\t\t\t\telse if (mtype==GF_ISOM_MEDIA_AUXV) nb_auxv++;\n\t\t\t\telse if (mtype==GF_ISOM_MEDIA_PICT) nb_pict++;\n\t\t\t\telse nb_a++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if ((mtype==GF_ISOM_SUBTYPE_MPEG4) || (mtype==GF_ISOM_SUBTYPE_MPEG4_CRYP)) nb_m4s++;\n\t\telse nb_any++;\n\t}\n\tif (nb_any) return GF_ISOM_BRAND_ISOM;\n\tif (nb_qcelp || nb_evrc || nb_smv) {\n\t\t/*non std mix of streams*/\n\t\tif (nb_m4s || nb_avc || nb_scene || nb_od || nb_mp3 || nb_a || nb_v) return GF_ISOM_BRAND_ISOM;\n\t\treturn GF_ISOM_BRAND_3G2A;\n\t}\n\t/*other a/v/s streams*/\n\tif (nb_v || nb_a || nb_m4s) return GF_ISOM_BRAND_MP42;\n\n\tnb_v = nb_m4v + nb_avc + nb_h263;\n\tnb_a = nb_mp3 + nb_aac + nb_amr;\n\n\t/*avc file: whatever has AVC and no systems*/\n\tif (nb_avc) {\n\t\tif (!nb_scene && !nb_od) return GF_ISOM_BRAND_AVC1;\n\t\treturn GF_ISOM_BRAND_MP42;\n\t}\n\t/*MP3: ISMA and MPEG4*/\n\tif (nb_mp3) {\n\t\tif (!nb_text && (nb_v<=1) && (nb_a<=1) && (nb_scene==1) && (nb_od==1))\n\t\t\treturn GF_ISOM_BRAND_ISMA;\n\t\treturn GF_ISOM_BRAND_MP42;\n\t}\n\t/*MP4*/\n\tif (nb_scene || nb_od) {\n\t\t/*issue with AMR and H263 which don't have MPEG mapping: non compliant file*/\n\t\tif (nb_amr || nb_h263) return GF_ISOM_BRAND_ISOM;\n\t\treturn GF_ISOM_BRAND_MP42;\n\t}\n\t/*use ISMA (3GP fine too)*/\n\tif (!nb_amr && !nb_h263 && !nb_text) {\n\t\tif ((nb_v<=1) && (nb_a<=1)) return GF_ISOM_BRAND_ISMA;\n\t\treturn GF_ISOM_BRAND_MP42;\n\t}\n\n\tif ((nb_v<=1) && (nb_a<=1) && (nb_text<=1)) return nb_text ? GF_ISOM_BRAND_3GP6 : GF_ISOM_BRAND_3GP5;\n\treturn GF_ISOM_BRAND_3GG6;\n}\n\nGF_ItemListBox *gf_ismo_locate_box(GF_List *list, u32 boxType, bin128 UUID)\n{\n\tu32 i;\n\tGF_Box *box;\n\ti=0;\n\twhile ((box = (GF_Box *)gf_list_enum(list, &i))) {\n\t\tif (box->type == boxType) {\n\t\t\tGF_UUIDBox* box2 = (GF_UUIDBox* )box;\n\t\t\tif (boxType != GF_ISOM_BOX_TYPE_UUID) return (GF_ItemListBox *)box;\n\t\t\tif (!memcmp(box2->uuid, UUID, 16)) return (GF_ItemListBox *)box;\n\t\t}\n\t}\n\treturn NULL;\n}\n\n/*Apple extensions*/\n\n\nGF_EXPORT\nGF_Err gf_isom_apple_get_tag(GF_ISOFile *mov, GF_ISOiTunesTag tag, const u8 **data, u32 *data_len)\n{\n\tu32 i;\n\tGF_ListItemBox *info;\n\tGF_ItemListBox *ilst;\n\tGF_MetaBox *meta;\n\n\t*data = NULL;\n\t*data_len = 0;\n\n\tmeta = (GF_MetaBox *) gf_isom_get_meta_extensions(mov, GF_FALSE);\n\tif (!meta) return GF_URL_ERROR;\n\n\tilst = gf_ismo_locate_box(meta->child_boxes, GF_ISOM_BOX_TYPE_ILST, NULL);\n\tif (!ilst) return GF_URL_ERROR;\n\n\tif (tag==GF_ISOM_ITUNE_PROBE) return gf_list_count(ilst->child_boxes) ? GF_OK : GF_URL_ERROR;\n\n\ti=0;\n\twhile ( (info=(GF_ListItemBox*)gf_list_enum(ilst->child_boxes, &i))) {\n\t\tif (info->type==tag) break;\n\t\t/*special cases*/\n\t\tif ((tag==GF_ISOM_ITUNE_GENRE) && (info->type==(u32) GF_ISOM_ITUNE_GENRE_USER)) break;\n\t\tinfo = NULL;\n\t}\n\tif (!info || !info->data || !info->data->data) return GF_URL_ERROR;\n\n\tif ((tag == GF_ISOM_ITUNE_GENRE) && (info->data->flags == 0)) {\n\t\tif (info->data->dataSize && (info->data->dataSize>2) && (info->data->dataSize < 5)) {\n\t\t\tGF_BitStream* bs = gf_bs_new(info->data->data, info->data->dataSize, GF_BITSTREAM_READ);\n\t\t\t*data_len = gf_bs_read_int(bs, info->data->dataSize * 8);\n\t\t\tgf_bs_del(bs);\n\t\t\treturn GF_OK;\n\t\t}\n\t}\n//\tif (info->data->flags != 0x1) return GF_URL_ERROR;\n\t*data = info->data->data;\n\t*data_len = info->data->dataSize;\n\tif ((tag==GF_ISOM_ITUNE_COVER_ART) && (info->data->flags==14)) *data_len |= 0x80000000; //(1<<31);\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_apple_enum_tag(GF_ISOFile *mov, u32 idx, GF_ISOiTunesTag *out_tag, const u8 **data, u32 *data_len, u64 *out_int_val, u32 *out_int_val2, u32 *out_flags)\n{\n\tu32 i, child_index;\n\tGF_ListItemBox *info;\n\tGF_ItemListBox *ilst;\n\tGF_MetaBox *meta;\n\tGF_DataBox *dbox = NULL;\n\tu32 itype, tag_val;\n\ts32 tag_idx;\n\t*data = NULL;\n\t*data_len = 0;\n\n\tmeta = (GF_MetaBox *) gf_isom_get_meta_extensions(mov, GF_FALSE);\n\tif (!meta) return GF_URL_ERROR;\n\n\tilst = gf_ismo_locate_box(meta->child_boxes, GF_ISOM_BOX_TYPE_ILST, NULL);\n\tif (!ilst) return GF_URL_ERROR;\n\n\tchild_index = i = 0;\n\twhile ( (info=(GF_ListItemBox*)gf_list_enum(ilst->child_boxes, &i))) {\n\t\tGF_DataBox *data_box = NULL;\n\t\tif (gf_itags_find_by_itag(info->type)<0) {\n\t\t\tif (info->type==GF_ISOM_BOX_TYPE_UNKNOWN) {\n\t\t\t\tdata_box = (GF_DataBox *) gf_isom_box_find_child(info->child_boxes, GF_ISOM_BOX_TYPE_DATA);\n\t\t\t\tif (!data_box) continue;\n\t\t\t\ttag_val = ((GF_UnknownBox *)info)->original_4cc;\n\t\t\t}\n\t\t} else {\n\t\t\tdata_box = info->data;\n\t\t\ttag_val = info->type;\n\t\t}\n\t\tif (child_index==idx) {\n\t\t\tdbox = data_box;\n\t\t\tbreak;\n\t\t}\n\t\tchild_index++;\n\t}\n\tif (!dbox) return GF_URL_ERROR;\n\n\t*out_flags = dbox->flags;\n\t*out_tag = tag_val;\n\tif (!dbox->data) {\n\t\t*data = NULL;\n\t\t*data_len = 1;\n\t\treturn GF_OK;\n\t}\n\n\ttag_idx = gf_itags_find_by_itag(info->type);\n\tif (tag_idx<0) {\n\t\t*data = dbox->data;\n\t\t*data_len = dbox->dataSize;\n\t\treturn GF_OK;\n\t}\n\n\tif ((tag_val == GF_ISOM_ITUNE_GENRE) && (dbox->flags == 0) && (dbox->dataSize>2)) {\n\t\tu32 int_val = dbox->data[0];\n\t\tint_val <<= 8;\n\t\tint_val |= dbox->data[1];\n\t\t*data = NULL;\n\t\t*data_len = 0;\n\t\t*out_int_val = int_val;\n\t\treturn GF_OK;\n\t}\n\n\titype = gf_itags_get_type((u32) tag_idx);\n\tswitch (itype) {\n\tcase GF_ITAG_BOOL:\n\tcase GF_ITAG_INT8:\n\t\tif (dbox->dataSize) *out_int_val = dbox->data[0];\n\t\tbreak;\n\tcase GF_ITAG_INT16:\n\t\tif (dbox->dataSize>1) {\n\t\t\tu16 v = dbox->data[0];\n\t\t\tv<<=8;\n\t\t\tv |= dbox->data[1];\n\t\t\t*out_int_val = v;\n\t\t}\n\t\tbreak;\n\tcase GF_ITAG_INT32:\n\t\tif (dbox->dataSize>3) {\n\t\t\tu32 v = dbox->data[0];\n\t\t\tv<<=8;\n\t\t\tv |= dbox->data[1];\n\t\t\tv<<=8;\n\t\t\tv |= dbox->data[2];\n\t\t\tv<<=8;\n\t\t\tv |= dbox->data[3];\n\t\t\t*out_int_val = v;\n\t\t}\n\t\tbreak;\n\tcase GF_ITAG_INT64:\n\t\tif (dbox->dataSize>3) {\n\t\t\tu64 v = dbox->data[0];\n\t\t\tv<<=8;\n\t\t\tv |= dbox->data[1];\n\t\t\tv<<=8;\n\t\t\tv |= dbox->data[2];\n\t\t\tv<<=8;\n\t\t\tv |= dbox->data[3];\n\t\t\tv<<=8;\n\t\t\tv |= dbox->data[4];\n\t\t\tv<<=8;\n\t\t\tv |= dbox->data[5];\n\t\t\tv<<=8;\n\t\t\tv |= dbox->data[6];\n\t\t\tv<<=8;\n\t\t\tv |= dbox->data[7];\n\t\t\t*out_int_val = v;\n\t\t}\n\t\tbreak;\n\tcase GF_ITAG_FRAC6:\n\tcase GF_ITAG_FRAC8:\n\t\tif (dbox->dataSize>3) {\n\t\t\tu32 v = dbox->data[2];\n\t\t\tv<<=8;\n\t\t\tv |= dbox->data[3];\n\t\t\t*out_int_val = v;\n\t\t\tv = dbox->data[4];\n\t\t\tv<<=8;\n\t\t\tv |= dbox->data[5];\n\t\t\t*out_int_val2 = v;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\t*data = dbox->data;\n\t\t*data_len = dbox->dataSize;\n\t\tbreak;\n\t}\n\treturn GF_OK;\n}\n\n\nGF_EXPORT\nGF_Err gf_isom_wma_enum_tag(GF_ISOFile *mov, u32 idx, char **out_tag, const u8 **data, u32 *data_len, u32 *version, u32 *data_type)\n{\n\tGF_XtraBox *xtra;\n\tGF_XtraTag *tag;\n\n\t*out_tag = NULL;\n\t*data = NULL;\n\t*data_len = 0;\n\t*version = 0;\n\t*data_type = 0;\n\n\txtra = (GF_XtraBox *) gf_isom_get_meta_extensions(mov, GF_TRUE);\n\tif (!xtra) return GF_URL_ERROR;\n\n\ttag = gf_list_get(xtra->tags, idx);\n\tif (!tag) return GF_NOT_FOUND;\n\t*out_tag = tag->name;\n\t*data_len = tag->prop_size;\n\t*data = tag->prop_value;\n\t*version = tag->flags;\n\t*data_type = tag->prop_type;\n\treturn GF_OK;\n}\n\n\nGF_EXPORT\nGF_Err gf_isom_get_track_switch_group_count(GF_ISOFile *movie, u32 trackNumber, u32 *alternateGroupID, u32 *nb_groups)\n{\n\tGF_UserDataMap *map;\n\tGF_TrackBox *trak;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !trak->Header) return GF_BAD_PARAM;\n\t*alternateGroupID = trak->Header->alternate_group;\n\t*nb_groups = 0;\n\tif (!trak->udta) return GF_OK;\n\n\tmap = udta_getEntry(trak->udta, GF_ISOM_BOX_TYPE_TSEL, NULL);\n\tif (!map) return GF_OK;\n\t*nb_groups = gf_list_count(map->boxes);\n\treturn GF_OK;\n}\n\nGF_EXPORT\nconst u32 *gf_isom_get_track_switch_parameter(GF_ISOFile *movie, u32 trackNumber, u32 group_index, u32 *switchGroupID, u32 *criteriaListSize)\n{\n\tGF_TrackBox *trak;\n\tGF_UserDataMap *map;\n\tGF_TrackSelectionBox *tsel;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!group_index || !trak || !trak->udta) return NULL;\n\n\tmap = udta_getEntry(trak->udta, GF_ISOM_BOX_TYPE_TSEL, NULL);\n\tif (!map) return NULL;\n\ttsel = (GF_TrackSelectionBox*)gf_list_get(map->boxes, group_index-1);\n\tif (!tsel) return NULL;\n\t\n\t*switchGroupID = tsel->switchGroup;\n\t*criteriaListSize = tsel->attributeListCount;\n\treturn (const u32 *) tsel->attributeList;\n}\n\nGF_EXPORT\nu32 gf_isom_get_next_alternate_group_id(GF_ISOFile *movie)\n{\n\tu32 id = 0;\n\tu32 i=0;\n\n\twhile (i< gf_isom_get_track_count(movie) ) {\n\t\tGF_TrackBox *trak = gf_isom_get_track_from_file(movie, i+1);\n\t\tif (trak->Header->alternate_group > id)\n\t\t\tid = trak->Header->alternate_group;\n\t\ti++;\n\t}\n\treturn id+1;\n}\n\nGF_EXPORT\nu8 *gf_isom_sample_get_subsamples_buffer(GF_ISOFile *movie, u32 track, u32 sampleNumber, u32 *osize)\n{\n\tu8 *data;\n\tu32 size;\n\tu32 i, count;\n\tGF_BitStream *bs = NULL;\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(movie, track);\n\tif (!trak || !osize) return NULL;\n\tif (!trak->Media || !trak->Media->information->sampleTable || !trak->Media->information->sampleTable->sub_samples) return NULL;\n\n\tcount = gf_list_count(trak->Media->information->sampleTable->sub_samples);\n\tfor (i=0; i<count; i++) {\n\t\tu32 j, sub_count, last_sample = 0;\n\t\tGF_SubSampleInformationBox *sub_samples = gf_list_get(trak->Media->information->sampleTable->sub_samples, i);\n\n\t\tsub_count = gf_list_count(sub_samples->Samples);\n\t\tfor (j=0; j<sub_count; j++) {\n\t\t\tGF_SubSampleInfoEntry *pSamp = (GF_SubSampleInfoEntry *) gf_list_get(sub_samples->Samples, j);\n\t\t\tif (last_sample + pSamp->sample_delta == sampleNumber) {\n\t\t\t\tu32 scount = gf_list_count(pSamp->SubSamples);\n\t\t\t\tfor (j=0; j<scount; j++) {\n\t\t\t\t\tGF_SubSampleEntry *sent = gf_list_get(pSamp->SubSamples, j);\n\t\t\t\t\tif (!bs) bs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\n\t\t\t\t\tgf_bs_write_u32(bs, sub_samples->flags);\n\t\t\t\t\tgf_bs_write_u32(bs, sent->subsample_size);\n\t\t\t\t\tgf_bs_write_u32(bs, sent->reserved);\n\t\t\t\t\tgf_bs_write_u8(bs, sent->subsample_priority);\n\t\t\t\t\tgf_bs_write_u8(bs, sent->discardable);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tlast_sample += pSamp->sample_delta;\n\t\t}\n\t}\n\tif (!bs) return NULL;\n\tgf_bs_get_content(bs, &data, &size);\n\tgf_bs_del(bs);\n\t*osize = size;\n\treturn data;\n}\n\nGF_EXPORT\nu32 gf_isom_sample_has_subsamples(GF_ISOFile *movie, u32 track, u32 sampleNumber, u32 flags)\n{\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(movie, track);\n\tif (!trak) return GF_BAD_PARAM;\n\tif (!trak->Media->information->sampleTable->sub_samples) return 0;\n\tif (!sampleNumber) return 1;\n\treturn gf_isom_sample_get_subsample_entry(movie, track, sampleNumber, flags, NULL);\n}\n\nGF_EXPORT\nGF_Err gf_isom_sample_get_subsample(GF_ISOFile *movie, u32 track, u32 sampleNumber, u32 flags, u32 subSampleNumber, u32 *size, u8 *priority, u32 *reserved, Bool *discardable)\n{\n\tGF_SubSampleEntry *entry;\n\tGF_SubSampleInfoEntry *sub_sample;\n\tu32 count = gf_isom_sample_get_subsample_entry(movie, track, sampleNumber, flags, &sub_sample);\n\tif (!size || !priority || !discardable) return GF_BAD_PARAM;\n\n\tif (!subSampleNumber || (subSampleNumber>count)) return GF_BAD_PARAM;\n\tentry = (GF_SubSampleEntry*)gf_list_get(sub_sample->SubSamples, subSampleNumber-1);\n\t*size = entry->subsample_size;\n\t*priority = entry->subsample_priority;\n\t*reserved = entry->reserved;\n\t*discardable = entry->discardable ? GF_TRUE : GF_FALSE;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_rvc_config(GF_ISOFile *movie, u32 track, u32 sampleDescriptionIndex, u16 *rvc_predefined, u8 **data, u32 *size, const char **mime)\n{\n\tGF_MPEGVisualSampleEntryBox *entry;\n\tGF_TrackBox *trak;\n\n\tif (!rvc_predefined || !data || !size) return GF_BAD_PARAM;\n\t*rvc_predefined = 0;\n\n\ttrak = gf_isom_get_track_from_file(movie, track);\n\tif (!trak) return GF_BAD_PARAM;\n\n\n\tentry = (GF_MPEGVisualSampleEntryBox *) gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, sampleDescriptionIndex-1);\n\tif (!entry ) return GF_BAD_PARAM;\n\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_VIDEO) return GF_BAD_PARAM;\n\n\tGF_RVCConfigurationBox *rvcc = (GF_RVCConfigurationBox *)gf_isom_box_find_child(entry->child_boxes, GF_ISOM_BOX_TYPE_RVCC);\n\tif (!rvcc) return GF_NOT_FOUND;\n\n\t*rvc_predefined = rvcc->predefined_rvc_config;\n\tif (rvcc->rvc_meta_idx) {\n\t\tif (!data || !size) return GF_OK;\n\t\treturn gf_isom_extract_meta_item_mem(movie, GF_FALSE, track, rvcc->rvc_meta_idx, data, size, NULL, mime, GF_FALSE);\n\t}\n\treturn GF_OK;\n}\n\nGF_EXPORT\nBool gf_isom_moov_first(GF_ISOFile *movie)\n{\n\tu32 i;\n\tfor (i=0; i<gf_list_count(movie->TopBoxes); i++) {\n\t\tGF_Box *b = (GF_Box*)gf_list_get(movie->TopBoxes, i);\n\t\tif (b->type == GF_ISOM_BOX_TYPE_MOOV) return GF_TRUE;\n\t\tif (b->type == GF_ISOM_BOX_TYPE_MDAT) return GF_FALSE;\n\t}\n\treturn GF_FALSE;\n}\n\nGF_EXPORT\nvoid gf_isom_reset_fragment_info(GF_ISOFile *movie, Bool keep_sample_count)\n{\n\tu32 i;\n\tif (!movie) return;\n\tfor (i=0; i<gf_list_count(movie->moov->trackList); i++) {\n\t\tGF_TrackBox *trak = (GF_TrackBox*)gf_list_get(movie->moov->trackList, i);\n\t\ttrak->Media->information->sampleTable->SampleSize->sampleCount = 0;\n#ifdef GPAC_DISABLE_ISOM_FRAGMENTS\n\t}\n#else\n\t\t//do not reset tfdt for LL-HLS case where parts do not contain a TFDT\n\t\t//trak->dts_at_seg_start = 0;\n\t\tif (!keep_sample_count)\n\t\t\ttrak->sample_count_at_seg_start = 0;\n\t}\n\tmovie->NextMoofNumber = 0;\n#endif\n}\n\nGF_EXPORT\nvoid gf_isom_reset_seq_num(GF_ISOFile *movie)\n{\n#ifdef GPAC_DISABLE_ISOM_FRAGMENTS\n\tmovie->NextMoofNumber = 0;\n#endif\n}\n\nGF_EXPORT\nvoid gf_isom_reset_sample_count(GF_ISOFile *movie)\n{\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\tu32 i;\n\tif (!movie) return;\n\tfor (i=0; i<gf_list_count(movie->moov->trackList); i++) {\n\t\tGF_TrackBox *trak = (GF_TrackBox*)gf_list_get(movie->moov->trackList, i);\n\t\ttrak->Media->information->sampleTable->SampleSize->sampleCount = 0;\n\t\ttrak->sample_count_at_seg_start = 0;\n\t}\n\tmovie->NextMoofNumber = 0;\n#endif\n}\n\nGF_EXPORT\nBool gf_isom_has_cenc_sample_group(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\tu32 i, count;\n\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_FALSE;\n\tif (!trak->Media->information->sampleTable->sampleGroups) return GF_FALSE;\n\n\tcount = gf_list_count(trak->Media->information->sampleTable->sampleGroupsDescription);\n\tfor (i=0; i<count; i++) {\n\t\tGF_SampleGroupDescriptionBox *sgdesc = (GF_SampleGroupDescriptionBox*)gf_list_get(trak->Media->information->sampleTable->sampleGroupsDescription, i);\n\t\tif (sgdesc->grouping_type==GF_ISOM_SAMPLE_GROUP_SEIG) {\n\t\t\treturn GF_TRUE;\n\t\t}\n\t}\n\treturn GF_FALSE;\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_sample_rap_roll_info(GF_ISOFile *the_file, u32 trackNumber, u32 sample_number, Bool *is_rap, GF_ISOSampleRollType *roll_type, s32 *roll_distance)\n{\n\tGF_TrackBox *trak;\n\tu32 i, count;\n\n\tif (is_rap) *is_rap = GF_FALSE;\n\tif (roll_type) *roll_type = 0;\n\tif (roll_distance) *roll_distance = 0;\n\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\tif (!trak->Media->information->sampleTable->sampleGroups) return GF_OK;\n\n\tif (!sample_number) {\n\t\tcount = gf_list_count(trak->Media->information->sampleTable->sampleGroupsDescription);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tGF_SampleGroupDescriptionBox *sgdesc = (GF_SampleGroupDescriptionBox*)gf_list_get(trak->Media->information->sampleTable->sampleGroupsDescription, i);\n\t\t\tswitch (sgdesc->grouping_type) {\n\t\t\tcase GF_ISOM_SAMPLE_GROUP_RAP:\n\t\t\tcase GF_ISOM_SAMPLE_GROUP_SYNC:\n\t\t\t\tif (is_rap) *is_rap = GF_TRUE;\n\t\t\t\tbreak;\n\t\t\tcase GF_ISOM_SAMPLE_GROUP_ROLL:\n\t\t\tcase GF_ISOM_SAMPLE_GROUP_PROL:\n\t\t\t\tif (roll_type)\n\t\t\t\t\t*roll_type = (sgdesc->grouping_type==GF_ISOM_SAMPLE_GROUP_PROL) ? GF_ISOM_SAMPLE_PREROLL : GF_ISOM_SAMPLE_ROLL;\n\t\t\t\tif (roll_distance) {\n\t\t\t\t\ts32 max_roll = 0;\n\t\t\t\t\tu32 j;\n\t\t\t\t\tfor (j=0; j<gf_list_count(sgdesc->group_descriptions); j++) {\n\t\t\t\t\t\tGF_RollRecoveryEntry *roll_entry = (GF_RollRecoveryEntry*)gf_list_get(sgdesc->group_descriptions, j);\n\t\t\t\t\t\tif (max_roll < roll_entry->roll_distance)\n\t\t\t\t\t\t\tmax_roll = roll_entry->roll_distance;\n\t\t\t\t\t}\n\t\t\t\t\tif (*roll_distance < max_roll) *roll_distance = max_roll;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn GF_OK;\n\t}\n\n\tcount = gf_list_count(trak->Media->information->sampleTable->sampleGroups);\n\tfor (i=0; i<count; i++) {\n\t\tGF_SampleGroupBox *sg;\n\t\tu32 j, group_desc_index;\n\t\tGF_SampleGroupDescriptionBox *sgdesc;\n\t\tu32 first_sample_in_entry, last_sample_in_entry;\n\t\tfirst_sample_in_entry = 1;\n\t\tgroup_desc_index = 0;\n\t\tsg = (GF_SampleGroupBox*)gf_list_get(trak->Media->information->sampleTable->sampleGroups, i);\n\t\tfor (j=0; j<sg->entry_count; j++) {\n\t\t\tlast_sample_in_entry = first_sample_in_entry + sg->sample_entries[j].sample_count - 1;\n\t\t\tif ((sample_number<first_sample_in_entry) || (sample_number>last_sample_in_entry)) {\n\t\t\t\tfirst_sample_in_entry = last_sample_in_entry+1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/*we found our sample*/\n\t\t\tgroup_desc_index = sg->sample_entries[j].group_description_index;\n\t\t\tbreak;\n\t\t}\n\t\t/*no sampleGroup info associated*/\n\t\tif (!group_desc_index) continue;\n\n\t\tsgdesc = NULL;\n\t\tfor (j=0; j<gf_list_count(trak->Media->information->sampleTable->sampleGroupsDescription); j++) {\n\t\t\tsgdesc = (GF_SampleGroupDescriptionBox*)gf_list_get(trak->Media->information->sampleTable->sampleGroupsDescription, j);\n\t\t\tif (sgdesc->grouping_type==sg->grouping_type) break;\n\t\t\tsgdesc = NULL;\n\t\t}\n\t\t/*no sampleGroup description found for this group (invalid file)*/\n\t\tif (!sgdesc) continue;\n\n\t\tswitch (sgdesc->grouping_type) {\n\t\tcase GF_ISOM_SAMPLE_GROUP_RAP:\n\t\tcase GF_ISOM_SAMPLE_GROUP_SYNC:\n\t\t\tif (is_rap) *is_rap = GF_TRUE;\n\t\t\tbreak;\n\t\tcase GF_ISOM_SAMPLE_GROUP_ROLL:\n\t\tcase GF_ISOM_SAMPLE_GROUP_PROL:\n\t\t\tif (roll_type)\n\t\t\t\t*roll_type = (sgdesc->grouping_type==GF_ISOM_SAMPLE_GROUP_PROL) ? GF_ISOM_SAMPLE_PREROLL : GF_ISOM_SAMPLE_ROLL;\n\n\t\t\tif (roll_distance) {\n\t\t\t\tGF_RollRecoveryEntry *roll_entry = (GF_RollRecoveryEntry *) gf_list_get(sgdesc->group_descriptions, group_desc_index - 1);\n\t\t\t\tif (roll_entry)\n\t\t\t\t\t*roll_distance = roll_entry->roll_distance;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_DefaultSampleGroupDescriptionEntry * gf_isom_get_sample_group_info_entry(GF_ISOFile *the_file, GF_TrackBox *trak, u32 grouping_type, u32 sample_group_description_index, u32 *default_index, GF_SampleGroupDescriptionBox **out_sgdp)\n{\n\tu32 i, count;\n\n\tif (!trak || !sample_group_description_index) return NULL;\n\tif (!trak->Media->information->sampleTable->sampleGroupsDescription) return NULL;\n\n\tcount = gf_list_count(trak->Media->information->sampleTable->sampleGroupsDescription);\n\tfor (i=0; i<count; i++) {\n\t\tGF_SampleGroupDescriptionBox *sgdesc = (GF_SampleGroupDescriptionBox*)gf_list_get(trak->Media->information->sampleTable->sampleGroupsDescription, i);\n\t\tif (sgdesc->grouping_type != grouping_type) continue;\n\n\t\tif (sgdesc->default_description_index && !sample_group_description_index) sample_group_description_index = sgdesc->default_description_index;\n\n\t\tif (default_index) *default_index = sgdesc->default_description_index ;\n\t\tif (out_sgdp) *out_sgdp = sgdesc;\n\n\t\tif (!sample_group_description_index) return NULL;\n\t\treturn (GF_DefaultSampleGroupDescriptionEntry*)gf_list_get(sgdesc->group_descriptions, sample_group_description_index-1);\n\t}\n\treturn NULL;\n}\n\nGF_EXPORT\nBool gf_isom_get_sample_group_info(GF_ISOFile *the_file, u32 trackNumber, u32 sample_description_index, u32 grouping_type, u32 *default_index, const u8 **data, u32 *size)\n{\n\tGF_DefaultSampleGroupDescriptionEntry *sg_entry;\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(the_file, trackNumber);\n\n\tif (default_index) *default_index = 0;\n\tif (size) *size = 0;\n\tif (data) *data = NULL;\n\n\tsg_entry = gf_isom_get_sample_group_info_entry(the_file, trak, grouping_type, sample_description_index, default_index, NULL);\n\tif (!sg_entry) return GF_FALSE;\n\n\tswitch (grouping_type) {\n\tcase GF_ISOM_SAMPLE_GROUP_RAP:\n\tcase GF_ISOM_SAMPLE_GROUP_SYNC:\n\tcase GF_ISOM_SAMPLE_GROUP_ROLL:\n\tcase GF_ISOM_SAMPLE_GROUP_SEIG:\n\tcase GF_ISOM_SAMPLE_GROUP_OINF:\n\tcase GF_ISOM_SAMPLE_GROUP_LINF:\n\t\treturn GF_TRUE;\n\tdefault:\n\t\tif (sg_entry && data) *data = (char *) sg_entry->data;\n\t\tif (sg_entry && size) *size = sg_entry->length;\n\t\treturn GF_TRUE;\n\t}\n\treturn GF_FALSE;\n}\n\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n//return the duration of the movie+fragments if known, 0 if error\nGF_EXPORT\nu64 gf_isom_get_fragmented_duration(GF_ISOFile *movie)\n{\n\tif (movie->moov->mvex && movie->moov->mvex->mehd)\n\t\treturn movie->moov->mvex->mehd->fragment_duration;\n\n\treturn 0;\n}\n//return the duration of the movie+fragments if known, 0 if error\nGF_EXPORT\nu32 gf_isom_get_fragments_count(GF_ISOFile *movie, Bool segments_only)\n{\n\tu32 i=0;\n\tu32 nb_frags = 0;\n\tGF_Box *b;\n\twhile ((b=(GF_Box*)gf_list_enum(movie->TopBoxes, &i))) {\n\t\tif (segments_only) {\n\t\t\tif (b->type==GF_ISOM_BOX_TYPE_SIDX)\n\t\t\t\tnb_frags++;\n\t\t} else {\n\t\t\tif (b->type==GF_ISOM_BOX_TYPE_MOOF)\n\t\t\t\tnb_frags++;\n\t\t}\n\t}\n\treturn nb_frags;\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_fragmented_samples_info(GF_ISOFile *movie, GF_ISOTrackID trackID, u32 *nb_samples, u64 *duration)\n{\n\tu32 i=0;\n\tu32 k, l;\n\tGF_MovieFragmentBox *moof;\n\tGF_TrackFragmentBox *traf;\n\n\t*nb_samples = 0;\n\t*duration = 0;\n\twhile ((moof=(GF_MovieFragmentBox*)gf_list_enum(movie->TopBoxes, &i))) {\n\t\tu32 j=0;\n\t\tif (moof->type!=GF_ISOM_BOX_TYPE_MOOF) continue;\n\n\t\twhile ((traf=(GF_TrackFragmentBox*)gf_list_enum( moof->TrackList, &j))) {\n\t\t\tu64 def_duration, samp_dur=0;\n\n\t\t\tif (traf->tfhd->trackID != trackID)\n\t\t\t\tcontinue;\n\n\t\t\tdef_duration = 0;\n\t\t\tif (traf->tfhd->flags & GF_ISOM_TRAF_SAMPLE_DUR) def_duration = traf->tfhd->def_sample_duration;\n\t\t\telse if (traf->trex) def_duration = traf->trex->def_sample_duration;\n\n\t\t\tfor (k=0; k<gf_list_count(traf->TrackRuns); k++) {\n\t\t\t\tGF_TrackFragmentRunBox *trun = (GF_TrackFragmentRunBox*)gf_list_get(traf->TrackRuns, k);\n\t\t\t\t*nb_samples += trun->sample_count;\n\n\t\t\t\tfor (l=0; l<trun->nb_samples; l++) {\n\t\t\t\t\tGF_TrunEntry *ent = &trun->samples[l];\n\n\t\t\t\t\tsamp_dur = def_duration;\n\t\t\t\t\tif (trun->flags & GF_ISOM_TRUN_DURATION) samp_dur = ent->Duration;\n\t\t\t\t\tif (trun->nb_samples == trun->sample_count)\n\t\t\t\t\t\t*duration += samp_dur;\n\t\t\t\t}\n\t\t\t\tif (trun->nb_samples != trun->sample_count)\n\t\t\t\t\t*duration += samp_dur * trun->sample_count;\n\t\t\t}\n\t\t}\n\t}\n\treturn GF_OK;\n}\n#endif\n\nGF_EXPORT\nGF_Err gf_isom_set_nalu_extract_mode(GF_ISOFile *the_file, u32 trackNumber, GF_ISONaluExtractMode nalu_extract_mode)\n{\n\tGF_TrackReferenceTypeBox *dpnd;\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\ttrak->extractor_mode = nalu_extract_mode;\n\n\tif (!trak->References) return GF_OK;\n\n\t/*get base*/\n\tdpnd = NULL;\n\ttrak->has_base_layer = GF_FALSE;\n\tTrack_FindRef(trak, GF_ISOM_REF_SCAL, &dpnd);\n\tif (dpnd) trak->has_base_layer = GF_TRUE;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_ISONaluExtractMode gf_isom_get_nalu_extract_mode(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return 0;\n\treturn trak->extractor_mode;\n}\n\nGF_EXPORT\ns32 gf_isom_get_composition_offset_shift(GF_ISOFile *file, u32 track)\n{\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(file, track);\n\tif (!trak) return 0;\n\tif (!trak->Media || !trak->Media->information || !trak->Media->information->sampleTable || !trak->Media->information->sampleTable->CompositionToDecode) return 0;\n\treturn trak->Media->information->sampleTable->CompositionToDecode->compositionToDTSShift;\n}\n\nGF_EXPORT\nBool gf_isom_needs_layer_reconstruction(GF_ISOFile *file)\n{\n\tu32 count, i;\n\tif (!file)\n\t\treturn GF_FALSE;\n\tcount = gf_isom_get_track_count(file);\n\tfor (i = 0; i < count; i++) {\n\t\tif (gf_isom_get_reference_count(file, i+1, GF_ISOM_REF_SCAL) > 0) {\n\t\t\treturn GF_TRUE;\n\t\t}\n\t\tif (gf_isom_get_reference_count(file, i+1, GF_ISOM_REF_SABT) > 0) {\n\t\t\treturn GF_TRUE;\n\t\t}\n\t\tswitch (gf_isom_get_media_subtype(file, i+1, 1)) {\n\t\tcase GF_ISOM_SUBTYPE_LHV1:\n\t\tcase GF_ISOM_SUBTYPE_LHE1:\n\t\tcase GF_ISOM_SUBTYPE_HVC2:\n\t\tcase GF_ISOM_SUBTYPE_HEV2:\n\t\t\tif (gf_isom_get_reference_count(file, i+1, GF_ISOM_REF_BASE) > 0) {\n\t\t\t\treturn GF_TRUE;\n\t\t\t}\n\t\t}\n\t}\n\treturn GF_FALSE;\n}\n\nGF_EXPORT\nvoid gf_isom_keep_utc_times(GF_ISOFile *file, Bool keep_utc)\n{\n\tif (!file) return;\n\tfile->keep_utc = keep_utc;\n}\n\nGF_EXPORT\nBool gf_isom_has_keep_utc_times(GF_ISOFile *file)\n{\n\tif (!file) return GF_FALSE;\n\treturn file->keep_utc;\n}\n\n\n\nGF_EXPORT\nu32 gf_isom_get_pssh_count(GF_ISOFile *file)\n{\n\tu32 count=0;\n\tu32 i=0;\n\tGF_Box *a_box;\n\tif (file->moov) {\n\t\twhile ((a_box = (GF_Box*)gf_list_enum(file->moov->child_boxes, &i))) {\n\t\t\tif (a_box->type != GF_ISOM_BOX_TYPE_PSSH) continue;\n\t\t\tcount++;\n\t\t}\n\t}\n\tif (file->meta) {\n\t\twhile ((a_box = (GF_Box*)gf_list_enum(file->meta->child_boxes, &i))) {\n\t\t\tif (a_box->type != GF_ISOM_BOX_TYPE_PSSH) continue;\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n}\n\n#if 0 //unused\n/*! gets serialized PSS\n\\param isom_file the target ISO file\n\\param pssh_index 1-based index of PSSH to query, see \\ref gf_isom_get_pssh_count\n\\param pssh_data set to a newly allocated buffer containing serialized PSSH - shall be freeed by caller\n\\param pssh_size set to the size of the allocated buffer\n\\return error if any\n*/\nGF_Err gf_isom_get_pssh(GF_ISOFile *file, u32 pssh_index, u8 **pssh_data, u32 *pssh_size)\n{\n\tGF_Err e;\n\tu32 i=0;\n\tGF_BitStream *bs;\n\tu32 count=1;\n\tGF_Box *pssh;\n\twhile ((pssh = (GF_Box *)gf_list_enum(file->moov->child_boxes, &i))) {\n\t\tif (pssh->type != GF_ISOM_BOX_TYPE_PSSH) continue;\n\t\tif (count == pssh_index) break;\n\t\tcount++;\n\t}\n\tif (!pssh) return GF_BAD_PARAM;\n\tbs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\te = gf_isom_box_write(pssh, bs);\n\tif (!e) {\n\t\tgf_bs_get_content(bs, pssh_data, pssh_size);\n\t}\n\tgf_bs_del(bs);\n\treturn e;\n}\n#endif\n\nGF_EXPORT\nGF_Err gf_isom_get_pssh_info(GF_ISOFile *file, u32 pssh_index, bin128 SystemID, u32 *version, u32 *KID_count, const bin128 **KIDs, const u8 **private_data, u32 *private_data_size)\n{\n\tu32 count=1;\n\tu32 i=0;\n\tGF_ProtectionSystemHeaderBox *pssh=NULL;\n\tif (file->moov) {\n\t\twhile ((pssh = (GF_ProtectionSystemHeaderBox *)gf_list_enum(file->moov->child_boxes, &i))) {\n\t\t\tif (pssh->type != GF_ISOM_BOX_TYPE_PSSH) continue;\n\t\t\tif (count == pssh_index) break;\n\t\t\tcount++;\n\t\t}\n\t}\n\tif (!pssh && file->meta) {\n\t\twhile ((pssh = (GF_ProtectionSystemHeaderBox *)gf_list_enum(file->meta->child_boxes, &i))) {\n\t\t\tif (pssh->type != GF_ISOM_BOX_TYPE_PSSH) continue;\n\t\t\tif (count == pssh_index) break;\n\t\t\tcount++;\n\t\t}\n\t}\n\tif (!pssh) return GF_BAD_PARAM;\n\n\tif (SystemID) memcpy(SystemID, pssh->SystemID, 16);\n\tif (version) *version = pssh->version;\n\tif (KID_count) *KID_count = pssh->KID_count;\n\tif (KIDs) *KIDs = (const bin128 *) pssh->KIDs;\n\tif (private_data_size) *private_data_size = pssh->private_data_size;\n\tif (private_data) *private_data = pssh->private_data;\n\treturn GF_OK;\n}\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\nGF_Err gf_isom_get_sample_cenc_info_internal(GF_TrackBox *trak, GF_TrackFragmentBox *traf, GF_SampleEncryptionBox *senc, u32 sample_number, Bool *IsEncrypted, u8 *crypt_byte_block, u8 *skip_byte_block, const u8 **key_info, u32 *key_info_size)\n#else\nGF_Err gf_isom_get_sample_cenc_info_internal(GF_TrackBox *trak, void *traf, GF_SampleEncryptionBox *senc, u32 sample_number, Bool *IsEncrypted, u8 *crypt_byte_block, u8 *skip_byte_block, const u8 **key_info, u32 *key_info_size)\n#endif\n{\n\tGF_SampleGroupBox *sample_group;\n\tu32 j, group_desc_index;\n\tGF_SampleGroupDescriptionBox *sgdesc;\n\tu32 i, count;\n\tu32 descIndex, chunkNum;\n\tu64 offset;\n\tu32 first_sample_in_entry, last_sample_in_entry;\n\tGF_CENCSampleEncryptionGroupEntry *entry;\n\n\tif (IsEncrypted) *IsEncrypted = GF_FALSE;\n\tif (crypt_byte_block) *crypt_byte_block = 0;\n\tif (skip_byte_block) *skip_byte_block = 0;\n\tif (key_info) *key_info = NULL;\n\tif (key_info_size) *key_info_size = 0;\n\t\n\tif (!trak) return GF_BAD_PARAM;\n\n#ifdef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tif (traf)\n\t\treturn GF_NOT_SUPPORTED;\n#else\n\tsample_number -= trak->sample_count_at_seg_start;\n#endif\n\n\tif (trak->Media->information->sampleTable->SampleSize && trak->Media->information->sampleTable->SampleSize->sampleCount>=sample_number) {\n\t\tstbl_GetSampleInfos(trak->Media->information->sampleTable, sample_number, &offset, &chunkNum, &descIndex, NULL);\n\t} else {\n\t\t//this is dump mode of fragments, we haven't merged tables yet - use current stsd idx indicated in trak\n\t\tdescIndex = trak->current_traf_stsd_idx;\n\t\tif (!descIndex) descIndex = 1;\n\t}\n\n\tgf_isom_cenc_get_default_info_internal(trak, descIndex, NULL, IsEncrypted, crypt_byte_block, skip_byte_block, key_info, key_info_size);\n\n\tsample_group = NULL;\n\tgroup_desc_index = 0;\n\tif (trak->Media->information->sampleTable->sampleGroups) {\n\t\tcount = gf_list_count(trak->Media->information->sampleTable->sampleGroups);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tsample_group = (GF_SampleGroupBox*)gf_list_get(trak->Media->information->sampleTable->sampleGroups, i);\n\t\t\tif (sample_group->grouping_type ==  GF_ISOM_SAMPLE_GROUP_SEIG)\n\t\t\t\tbreak;\n\t\t\tsample_group = NULL;\n\t\t}\n\t\tif (sample_group) {\n\t\t\tfirst_sample_in_entry = 1;\n\t\t\tfor (j=0; j<sample_group->entry_count; j++) {\n\t\t\t\tlast_sample_in_entry = first_sample_in_entry + sample_group->sample_entries[j].sample_count - 1;\n\t\t\t\tif ((sample_number<first_sample_in_entry) || (sample_number>last_sample_in_entry)) {\n\t\t\t\t\tfirst_sample_in_entry = last_sample_in_entry+1;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t/*we found our sample*/\n\t\t\t\tgroup_desc_index = sample_group->sample_entries[j].group_description_index;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\tif (!group_desc_index && traf && traf->sampleGroups) {\n\t\tcount = gf_list_count(traf->sampleGroups);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tgroup_desc_index = 0;\n\t\t\tsample_group = (GF_SampleGroupBox*)gf_list_get(traf->sampleGroups, i);\n\t\t\tif (sample_group->grouping_type ==  GF_ISOM_SAMPLE_GROUP_SEIG)\n\t\t\t\tbreak;\n\t\t\tsample_group = NULL;\n\t\t}\n\t\tif (sample_group) {\n\t\t\tfirst_sample_in_entry = 1;\n\t\t\tfor (j=0; j<sample_group->entry_count; j++) {\n\t\t\t\tlast_sample_in_entry = first_sample_in_entry + sample_group->sample_entries[j].sample_count - 1;\n\t\t\t\tif ((sample_number<first_sample_in_entry) || (sample_number>last_sample_in_entry)) {\n\t\t\t\t\tfirst_sample_in_entry = last_sample_in_entry+1;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t/*we found our sample*/\n\t\t\t\tgroup_desc_index = sample_group->sample_entries[j].group_description_index;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n#endif\n\t/*no sampleGroup info associated*/\n\tif (!group_desc_index) goto exit;\n\n\tsgdesc = NULL;\n\n\tif (group_desc_index<=0x10000) {\n\t\tfor (j=0; j<gf_list_count(trak->Media->information->sampleTable->sampleGroupsDescription); j++) {\n\t\t\tsgdesc = (GF_SampleGroupDescriptionBox*)gf_list_get(trak->Media->information->sampleTable->sampleGroupsDescription, j);\n\t\t\tif (sgdesc->grouping_type==sample_group->grouping_type) break;\n\t\t\tsgdesc = NULL;\n\t\t}\n\t}\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\telse if (traf) {\n\t\tgroup_desc_index -= 0x10000;\n\t\tfor (j=0; j<gf_list_count(traf->sampleGroupsDescription); j++) {\n\t\t\tsgdesc = (GF_SampleGroupDescriptionBox*)gf_list_get(traf->sampleGroupsDescription, j);\n\t\t\tif (sgdesc->grouping_type==sample_group->grouping_type) break;\n\t\t\tsgdesc = NULL;\n\t\t}\n\t}\n#endif\n\t/*no sampleGroup description found for this group (invalid file)*/\n\tif (!sgdesc) return GF_ISOM_INVALID_FILE;\n\n\tentry = (GF_CENCSampleEncryptionGroupEntry *) gf_list_get(sgdesc->group_descriptions, group_desc_index - 1);\n\tif (!entry) return GF_ISOM_INVALID_FILE;\n\n\tif (IsEncrypted) *IsEncrypted = entry->IsProtected;\n\tif (crypt_byte_block) *crypt_byte_block = entry->crypt_byte_block;\n\tif (skip_byte_block) *skip_byte_block = entry->skip_byte_block;\n\n\tif (key_info) *key_info = entry->key_info;\n\tif (key_info_size) *key_info_size = entry->key_info_size;\n\nexit:\n\t//in PIFF we may have default values if no TENC is present: 8 bytes for IV size\n\tif (( (senc && senc->piff_type==1) || (trak->moov && trak->moov->mov->is_smooth) ) && key_info && ! (*key_info) ) {\n\t\tif (!senc) {\n\t\t\tif (IsEncrypted) *IsEncrypted = GF_TRUE;\n\t\t\tif (key_info_size) *key_info_size = 8;\n\t\t} else {\n\t\t\tif (!senc->piff_type) {\n\t\t\t\tsenc->piff_type = 2;\n\t\t\t\tsenc->IV_size = 8;\n\t\t\t}\n\t\t\tassert(senc->IV_size);\n\t\t\tif (IsEncrypted) *IsEncrypted = GF_TRUE;\n\t\t\tif (key_info_size) *key_info_size = senc->IV_size;\n\t\t}\n\t}\n\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_sample_cenc_info(GF_ISOFile *movie, u32 track, u32 sample_number, Bool *IsEncrypted, u8 *crypt_byte_block, u8 *skip_byte_block, const u8 **key_info, u32 *key_info_size)\n{\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(movie, track);\n\tGF_SampleEncryptionBox *senc = trak->sample_encryption;\n\n\treturn gf_isom_get_sample_cenc_info_internal(trak, NULL, senc, sample_number, IsEncrypted, crypt_byte_block, skip_byte_block, key_info, key_info_size);\n}\n\n\nGF_EXPORT\nBool gf_isom_get_last_producer_time_box(GF_ISOFile *file, GF_ISOTrackID *refTrackID, u64 *ntp, u64 *timestamp, Bool reset_info)\n{\n\tif (!file) return GF_FALSE;\n\tif (refTrackID) *refTrackID = 0;\n\tif (ntp) *ntp = 0;\n\tif (timestamp) *timestamp = 0;\n\n\tif (file->last_producer_ref_time) {\n\t\tif (refTrackID) *refTrackID = file->last_producer_ref_time->refTrackID;\n\t\tif (ntp) *ntp = file->last_producer_ref_time->ntp;\n\t\tif (timestamp) *timestamp = file->last_producer_ref_time->timestamp;\n\n\t\tif (reset_info) {\n\t\t\tfile->last_producer_ref_time = NULL;\n\t\t}\n\t\treturn GF_TRUE;\n\t}\n\treturn GF_FALSE;\n}\n\nGF_EXPORT\nu64 gf_isom_get_current_tfdt(GF_ISOFile *the_file, u32 trackNumber)\n{\n#ifdef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\treturn 0;\n#else\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return 0;\n\treturn trak->dts_at_seg_start;\n#endif\n}\n\nGF_EXPORT\nu64 gf_isom_get_smooth_next_tfdt(GF_ISOFile *the_file, u32 trackNumber)\n{\n#ifdef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\treturn 0;\n#else\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return 0;\n\treturn trak->dts_at_next_seg_start;\n#endif\n}\n\nGF_EXPORT\nBool gf_isom_is_smooth_streaming_moov(GF_ISOFile *the_file)\n{\n\treturn the_file ? the_file->is_smooth : GF_FALSE;\n}\n\n\nvoid gf_isom_parse_trif_info(const u8 *data, u32 size, u32 *id, u32 *independent, Bool *full_picture, u32 *x, u32 *y, u32 *w, u32 *h)\n{\n\tGF_BitStream *bs;\n\tbs = gf_bs_new(data, size, GF_BITSTREAM_READ);\n\t*id = gf_bs_read_u16(bs);\n\tif (! gf_bs_read_int(bs, 1)) {\n\t\t*independent=0;\n\t\t*full_picture=0;\n\t\t*x = *y = *w = *h = 0;\n\t} else {\n\t\t*independent = gf_bs_read_int(bs, 2);\n\t\t*full_picture = (Bool)gf_bs_read_int(bs, 1);\n\t\t/*filter_disabled*/ gf_bs_read_int(bs, 1);\n\t\t/*has_dependency_list*/ gf_bs_read_int(bs, 1);\n\t\tgf_bs_read_int(bs, 2);\n\t\t*x = *full_picture ? 0 : gf_bs_read_u16(bs);\n\t\t*y = *full_picture ? 0 : gf_bs_read_u16(bs);\n\t\t*w = gf_bs_read_u16(bs);\n\t\t*h = gf_bs_read_u16(bs);\n\t}\n\tgf_bs_del(bs);\n}\n\nGF_EXPORT\nBool gf_isom_get_tile_info(GF_ISOFile *file, u32 trackNumber, u32 sample_description_index, u32 *default_sample_group_index, u32 *id, u32 *independent, Bool *full_picture, u32 *x, u32 *y, u32 *w, u32 *h)\n{\n\tconst u8 *data;\n\tu32 size;\n\n\tif (!gf_isom_get_sample_group_info(file, trackNumber, sample_description_index, GF_ISOM_SAMPLE_GROUP_TRIF, default_sample_group_index, &data, &size))\n\t\treturn GF_FALSE;\n\tgf_isom_parse_trif_info(data, size, id, independent, full_picture, x, y, w, h);\n\treturn GF_TRUE;\n}\n\nGF_EXPORT\nBool gf_isom_get_oinf_info(GF_ISOFile *file, u32 trackNumber, GF_OperatingPointsInformation **ptr)\n{\n\tu32 oref_track, def_index=0;\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(file, trackNumber);\n\n\tif (!ptr) return GF_FALSE;\n\n\toref_track=0;\n\tgf_isom_get_reference(file, trackNumber, GF_ISOM_REF_OREF, 1, &oref_track);\n\tif (oref_track) {\n\t\ttrak = gf_isom_get_track_from_file(file, oref_track);\n\t\tif (!trak) return GF_FALSE;\n\t}\n\n\t*ptr = (GF_OperatingPointsInformation *) gf_isom_get_sample_group_info_entry(file, trak, GF_ISOM_SAMPLE_GROUP_OINF, 1, &def_index, NULL);\n\n\treturn *ptr ? GF_TRUE : GF_FALSE;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_byte_offset(GF_ISOFile *file, s64 byte_offset)\n{\n\tif (!file) return GF_BAD_PARAM;\n\tfile->read_byte_offset = byte_offset;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nu32 gf_isom_get_nalu_length_field(GF_ISOFile *file, u32 track, u32 StreamDescriptionIndex)\n{\n\tGF_TrackBox *trak;\n\tGF_SampleEntryBox *entry;\n\tGF_MPEGVisualSampleEntryBox *ve;\n\tGF_SampleDescriptionBox *stsd;\n\n\ttrak = gf_isom_get_track_from_file(file, track);\n\tif (!trak) {\n\t\tfile->LastError = GF_BAD_PARAM;\n\t\treturn 0;\n\t}\n\n\tstsd = trak->Media->information->sampleTable->SampleDescription;\n\tif (!stsd || !StreamDescriptionIndex || StreamDescriptionIndex > gf_list_count(stsd->child_boxes)) {\n\t\tfile->LastError = GF_BAD_PARAM;\n\t\treturn 0;\n\t}\n\n\tentry = (GF_SampleEntryBox *)gf_list_get(stsd->child_boxes, StreamDescriptionIndex - 1);\n\t//no support for generic sample entries (eg, no MPEG4 descriptor)\n\tif (!entry || ! gf_isom_is_nalu_based_entry(trak->Media, entry)) {\n\t\tfile->LastError = GF_BAD_PARAM;\n\t\treturn 0;\n\t}\n\n\tve = (GF_MPEGVisualSampleEntryBox*)entry;\n\tif (ve->avc_config) return ve->avc_config->config->nal_unit_size;\n\tif (ve->svc_config) return ve->svc_config->config->nal_unit_size;\n\tif (ve->hevc_config) return ve->hevc_config->config->nal_unit_size;\n\tif (ve->lhvc_config) return ve->lhvc_config->config->nal_unit_size;\n\treturn 0;\n}\n\nGF_EXPORT\nBool gf_isom_is_video_handler_type(u32 mtype)\n{\n\tswitch (mtype) {\n\tcase GF_ISOM_MEDIA_VISUAL:\n\tcase GF_ISOM_MEDIA_AUXV:\n\tcase GF_ISOM_MEDIA_PICT:\n\t\treturn GF_TRUE;\n\tdefault:\n\t\treturn GF_FALSE;\n\t}\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_bitrate(GF_ISOFile *movie, u32 trackNumber, u32 sampleDescIndex, u32 *average_bitrate, u32 *max_bitrate, u32 *decode_buffer_size)\n{\n\tGF_BitRateBox *a;\n\tu32 i, count, mrate, arate, dbsize, type;\n\tGF_SampleEntryBox *ent;\n\tGF_ProtectionSchemeInfoBox *sinf;\n\tGF_TrackBox *trak;\n\tGF_ESDBox *esd;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !trak->Media) return GF_BAD_PARAM;\n\n\tmrate = arate = dbsize = 0;\n\tcount = gf_list_count(trak->Media->information->sampleTable->SampleDescription->child_boxes);\n\tfor (i=0; i<count; i++) {\n\t\tif ((sampleDescIndex>0) && (i+1 != sampleDescIndex)) continue;\n\n\t\tent = (GF_SampleEntryBox *)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, i);\n\t\tif (!ent) return GF_BAD_PARAM;\n\t\ta = gf_isom_sample_entry_get_bitrate(ent, GF_FALSE);\n\t\tif (a) {\n\t\t\tif (mrate<a->maxBitrate) mrate = a->maxBitrate;\n\t\t\tif (arate<a->avgBitrate) arate = a->avgBitrate;\n\t\t\tif (dbsize<a->bufferSizeDB) dbsize = a->bufferSizeDB;\n\t\t\tcontinue;\n\t\t}\n\t\ttype = ent->type;\n\t\tswitch (type) {\n\t\tcase GF_ISOM_BOX_TYPE_ENCV:\n\t\tcase GF_ISOM_BOX_TYPE_ENCA:\n\t\tcase GF_ISOM_BOX_TYPE_ENCS:\n\t\t\tsinf = (GF_ProtectionSchemeInfoBox *) gf_isom_box_find_child(ent->child_boxes, GF_ISOM_BOX_TYPE_SINF);\n\t\t\tif (sinf && sinf->original_format) type = sinf->original_format->data_format;\n\t\t\tbreak;\n\t\t}\n\t\tesd = NULL;\n\t\tswitch (type) {\n\t\tcase GF_ISOM_BOX_TYPE_MP4V:\n\t\t\tesd = ((GF_MPEGVisualSampleEntryBox *)ent)->esd;\n\t\t\tbreak;\n\t\tcase GF_ISOM_BOX_TYPE_MP4A:\n\t\t\tesd = ((GF_MPEGAudioSampleEntryBox *)ent)->esd;\n\t\t\tbreak;\n\t\tcase GF_ISOM_BOX_TYPE_MP4S:\n\t\t\tesd = ((GF_MPEGSampleEntryBox *)ent)->esd;\n\t\t\tbreak;\n\t\t}\n\t\tif (esd && esd->desc && esd->desc->decoderConfig) {\n\t\t\tif (mrate<esd->desc->decoderConfig->maxBitrate) mrate = esd->desc->decoderConfig->maxBitrate;\n\t\t\tif (arate<esd->desc->decoderConfig->avgBitrate) arate = esd->desc->decoderConfig->avgBitrate;\n\t\t\tif (dbsize<esd->desc->decoderConfig->bufferSizeDB) dbsize = esd->desc->decoderConfig->bufferSizeDB;\n\t\t}\n\t}\n\tif (average_bitrate) *average_bitrate = arate;\n\tif (max_bitrate) *max_bitrate = mrate;\n\tif (decode_buffer_size) *decode_buffer_size = dbsize;\n\treturn GF_OK;\n}\n\nvoid gf_isom_enable_traf_map_templates(GF_ISOFile *movie)\n{\n\tif (movie)\n\t\tmovie->signal_frag_bounds=GF_TRUE;\n}\n\nGF_EXPORT\nBool gf_isom_sample_is_fragment_start(GF_ISOFile *movie, u32 trackNumber, u32 sampleNum, GF_ISOFragmentBoundaryInfo *frag_info)\n{\n\tu32 i;\n\tGF_TrackBox *trak;\n\tGF_TrafToSampleMap *tmap;\n\n\tif (frag_info) memset(frag_info, 0, sizeof(GF_ISOFragmentBoundaryInfo));\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !trak->Media) return GF_FALSE;\n\tif (!trak->Media->information->sampleTable->traf_map) return GF_FALSE;\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tif (sampleNum<=trak->sample_count_at_seg_start)\n\t\treturn GF_FALSE;\n\tsampleNum -= trak->sample_count_at_seg_start;\n#endif\n\n\ttmap = trak->Media->information->sampleTable->traf_map;\n\tif (!tmap) return GF_FALSE;\n\tfor (i=0; i<tmap->nb_entries; i++) {\n\t\tGF_TrafMapEntry *finfo = &tmap->frag_starts[i];\n\t\tif (finfo->sample_num == sampleNum) {\n\t\t\tif (frag_info) {\n\t\t\t\tfrag_info->frag_start = finfo->moof_start;\n\t\t\t\tfrag_info->mdat_end = finfo->mdat_end;\n\t\t\t\tfrag_info->moof_template = finfo->moof_template;\n\t\t\t\tfrag_info->moof_template_size = finfo->moof_template_size;\n\t\t\t\tfrag_info->seg_start_plus_one = finfo->seg_start_plus_one;\n\t\t\t\tfrag_info->sidx_start = finfo->sidx_start;\n\t\t\t\tfrag_info->sidx_end = finfo->sidx_end;\n\t\t\t}\n\t\t\treturn GF_TRUE;\n\t\t}\n\n\t\tif (tmap->frag_starts[i].sample_num > sampleNum) return GF_FALSE;\n\t}\n\treturn GF_FALSE;\n}\n\n\n\n\nGF_EXPORT\nGF_Err gf_isom_get_jp2_config(GF_ISOFile *movie, u32 trackNumber, u32 sampleDesc, u8 **out_dsi, u32 *out_size)\n{\n\tGF_TrackBox *trak;\n\tGF_MPEGVisualSampleEntryBox *entry;\n\tGF_BitStream *bs;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !trak->Media || !trak->Media->information || !trak->Media->information->sampleTable || !trak->Media->information->sampleTable->SampleDescription) return GF_ISOM_INVALID_FILE;\n\tentry = (GF_MPEGVisualSampleEntryBox *) gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, sampleDesc-1);\n\tif (!entry || !entry->jp2h) return GF_BAD_PARAM;\n\tif (!entry->jp2h->ihdr) return GF_ISOM_INVALID_FILE;\n\n\tbs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\tgf_isom_box_array_write((GF_Box*)entry->jp2h, entry->jp2h->child_boxes, bs);\n\tgf_bs_get_content(bs, out_dsi, out_size);\n\tgf_bs_del(bs);\n\treturn GF_OK;\n}\n\n\nBool gf_isom_is_identical_sgpd(void *ptr1, void *ptr2, u32 grouping_type)\n{\n\tBool res = GF_FALSE;\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\tGF_BitStream *bs1, *bs2;\n\tu8 *buf1, *buf2;\n\tu32 len1, len2;\n\n\tif (!ptr1 || !ptr2)\n\t\treturn GF_FALSE;\n\n\tbs1 = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\tif (grouping_type) {\n\t\tsgpd_write_entry(grouping_type, ptr1, bs1);\n\t} else {\n\t\tgf_isom_box_size((GF_Box *)ptr1);\n\t\tgf_isom_box_write((GF_Box *)ptr1, bs1);\n\t}\n\tgf_bs_get_content(bs1, &buf1, &len1);\n\tgf_bs_del(bs1);\n\n\tbs2 = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\tif (grouping_type) {\n\t\tsgpd_write_entry(grouping_type, ptr2, bs2);\n\t} else {\n\t\tgf_isom_box_write((GF_Box *)ptr2, bs2);\n\t}\n\tgf_bs_get_content(bs2, &buf2, &len2);\n\tgf_bs_del(bs2);\n\n\n\tif ((len1==len2) && !memcmp(buf1, buf2, len1))\n\t\tres = GF_TRUE;\n\n\tgf_free(buf1);\n\tgf_free(buf2);\n#endif\n\treturn res;\n}\n\nGF_EXPORT\nu64 gf_isom_get_track_magic(GF_ISOFile *movie, u32 trackNumber)\n{\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return 0;\n\treturn trak->magic;\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_file_offset_for_time(GF_ISOFile *movie, Double start_time, u64 *max_offset)\n{\n\tu32 i;\n\tu64 start_ts, cur_start_time;\n\tu64 offset=0;\n\tif (!movie || !movie->moov)\n\t\treturn GF_BAD_PARAM;\n\n\tif (!movie->main_sidx) return GF_NOT_SUPPORTED;\n\tstart_ts = (u64) (start_time * movie->main_sidx->timescale);\n\tcur_start_time = 0;\n\toffset = movie->main_sidx->first_offset + movie->main_sidx_end_pos;\n\n\tfor (i=0; i<movie->main_sidx->nb_refs; i++) {\n\t\tif (cur_start_time >= start_ts) {\n\t\t\t*max_offset = offset;\n\t\t\treturn GF_OK;\n\t\t}\n\t\tcur_start_time += movie->main_sidx->refs[i].subsegment_duration;\n\t\toffset += movie->main_sidx->refs[i].reference_size;\n\t}\n\n\treturn GF_EOS;\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_sidx_duration(GF_ISOFile *movie, u64 *sidx_dur, u32 *sidx_timescale)\n{\n\tu64 dur=0;\n\tu32 i;\n\tif (!movie || !movie->moov || !sidx_timescale || !sidx_dur)\n\t\treturn GF_BAD_PARAM;\n\n\tif (!movie->main_sidx) return GF_NOT_SUPPORTED;\n\t*sidx_timescale = movie->main_sidx->timescale;\n\n\tfor (i=0; i<movie->main_sidx->nb_refs; i++) {\n\t\tdur += movie->main_sidx->refs[i].subsegment_duration;\n\t}\n\t*sidx_dur = dur;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nconst u8 *gf_isom_get_mpegh_compatible_profiles(GF_ISOFile *movie, u32 trackNumber, u32 sampleDescIndex, u32 *nb_compat_profiles)\n{\n\tGF_SampleEntryBox *ent;\n\tGF_MHACompatibleProfilesBox *mhap;\n\tGF_TrackBox *trak;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !trak->Media || !nb_compat_profiles) return NULL;\n\t*nb_compat_profiles = 0;\n\tent = gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, sampleDescIndex-1);\n\tif (!ent) return NULL;\n\tmhap = (GF_MHACompatibleProfilesBox *) gf_isom_box_find_child(ent->child_boxes, GF_ISOM_BOX_TYPE_MHAP);\n\tif (!mhap) return NULL;\n\t*nb_compat_profiles = mhap->num_profiles;\n\treturn mhap->compat_profiles;\n}\n\nconst void *gf_isom_get_tfrf(GF_ISOFile *movie, u32 trackNumber)\n{\n#ifdef GPAC_DISABLE_ISOM_FRAGMENTS\n\treturn NULL;\n#else\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return NULL;\n\n\treturn trak->tfrf;\n#endif\n}\n\nGF_Err gf_isom_get_y3d_info(GF_ISOFile *movie, u32 trackNumber, u32 sampleDescriptionIndex, GF_ISOM_Y3D_Info *info)\n{\n\tGF_SampleEntryBox *ent;\n\tGF_TrackBox *trak;\n\tBool found = GF_FALSE;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !trak->Media || !info) return GF_BAD_PARAM;\n\n\tent = gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, sampleDescriptionIndex-1);\n\tif (!ent) return GF_BAD_PARAM;\n\n\tmemset(info, 0, sizeof(GF_ISOM_Y3D_Info));\n\n\tGF_Stereo3DBox *st3d = (GF_Stereo3DBox *) gf_isom_box_find_child(ent->child_boxes, GF_ISOM_BOX_TYPE_ST3D);\n\tif (st3d) {\n\t\tfound = GF_TRUE;\n\t\tinfo->stereo_type = st3d->stereo_type;\n\t}\n\n\tGF_Box *sv3d = gf_isom_box_find_child(ent->child_boxes, GF_ISOM_BOX_TYPE_SV3D);\n\tif (!sv3d) {\n\t\treturn found ? GF_OK : GF_NOT_FOUND;\n\t}\n\tGF_SphericalVideoInfoBox *svhd = (GF_SphericalVideoInfoBox *) gf_isom_box_find_child(sv3d->child_boxes, GF_ISOM_BOX_TYPE_SVHD);\n\tif (svhd && strlen(svhd->string)) info->meta_data = svhd->string;\n\n\tGF_Box *proj = gf_isom_box_find_child(sv3d->child_boxes, GF_ISOM_BOX_TYPE_PROJ);\n\tif (!proj)\n\t\treturn found ? GF_OK : GF_NOT_FOUND;\n\n\tGF_ProjectionHeaderBox *projh = (GF_ProjectionHeaderBox *) gf_isom_box_find_child(proj->child_boxes, GF_ISOM_BOX_TYPE_PRHD);\n\tif (projh) {\n\t\tinfo->yaw = projh->yaw;\n\t\tinfo->pitch = projh->pitch;\n\t\tinfo->roll = projh->roll;\n\t\tinfo->pose_present = GF_TRUE;\n\t}\n\n\tGF_ProjectionTypeBox *projt = (GF_ProjectionTypeBox *) gf_isom_box_find_child(proj->child_boxes, GF_ISOM_BOX_TYPE_CBMP);\n\tif (projt) {\n\t\tinfo->layout = projt->layout;\n\t\tinfo->padding = projt->padding;\n\t\tinfo->projection_type = 1;\n\t} else {\n\t\tprojt = (GF_ProjectionTypeBox *) gf_isom_box_find_child(proj->child_boxes, GF_ISOM_BOX_TYPE_EQUI);\n\t\tif (projt) {\n\t\t\tinfo->top = projt->bounds_top;\n\t\t\tinfo->bottom = projt->bounds_bottom;\n\t\t\tinfo->left = projt->bounds_left;\n\t\t\tinfo->right = projt->bounds_right;\n\t\t\tinfo->projection_type = 2;\n\t\t} else {\n\t\t\tprojt = (GF_ProjectionTypeBox *) gf_isom_box_find_child(proj->child_boxes, GF_ISOM_BOX_TYPE_EQUI);\n\t\t\tif (projt) {\n\t\t\t\tinfo->projection_type = 3;\n\t\t\t}\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_ISOM*/\n", "/*\n *\t\t\tGPAC - Multimedia Framework C SDK\n *\n *\t\t\tAuthors: Jean Le Feuvre\n *\t\t\tCopyright (c) Telecom ParisTech 2000-2021\n *\t\t\t\t\tAll rights reserved\n *\n *  This file is part of GPAC / ISO Media File Format sub-project\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n#include <gpac/internal/isomedia_dev.h>\n#include <gpac/constants.h>\n#include <gpac/iso639.h>\n\n\n#if !defined(GPAC_DISABLE_ISOM) && !defined(GPAC_DISABLE_ISOM_WRITE)\n\nGF_Err CanAccessMovie(GF_ISOFile *movie, GF_ISOOpenMode Mode)\n{\n\tif (!movie) return GF_BAD_PARAM;\n\tif (movie->openMode < Mode) return GF_ISOM_INVALID_MODE;\n\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tif (movie->FragmentsFlags & GF_ISOM_FRAG_WRITE_READY) return GF_ISOM_INVALID_MODE;\n#endif\n\treturn GF_OK;\n}\n\nstatic GF_Err unpack_track(GF_TrackBox *trak)\n{\n\tGF_Err e = GF_OK;\n\tif (!trak->is_unpacked) {\n\t\te = stbl_UnpackOffsets(trak->Media->information->sampleTable);\n\t\tif (e) return e;\n\t\te = stbl_unpackCTS(trak->Media->information->sampleTable);\n\t\ttrak->is_unpacked = GF_TRUE;\n\t}\n\treturn e;\n}\n\n\nGF_Err FlushCaptureMode(GF_ISOFile *movie)\n{\n\tGF_Err e;\n\tif (movie->openMode != GF_ISOM_OPEN_WRITE) {\n\t\tif (!movie->editFileMap) return GF_ISOM_INVALID_MODE;\n\t\treturn GF_OK;\n\t}\n\t/*make sure nothing was added*/\n\tif (gf_bs_get_position(movie->editFileMap->bs)) return GF_OK;\n\n\tif (!strcmp(movie->fileName, \"_gpac_isobmff_redirect\")) {\n\t\tif (!movie->on_block_out) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[ISOBMFF] Missing output block callback, cannot write\\n\"));\n\t\t\treturn GF_BAD_PARAM;\n\t\t}\n\n\t\tgf_bs_del(movie->editFileMap->bs);\n\t\tmovie->editFileMap->bs = gf_bs_new_cbk(movie->on_block_out, movie->on_block_out_usr_data, movie->on_block_out_block_size);\n\t}\n\n\t/*add all first boxes*/\n\tif (movie->brand) {\n\t\te = gf_isom_box_size((GF_Box *)movie->brand);\n\t\tif (e) return e;\n\t\te = gf_isom_box_write((GF_Box *)movie->brand, movie->editFileMap->bs);\n\t\tif (e) return e;\n\t}\n\tif (movie->pdin) {\n\t\te = gf_isom_box_size((GF_Box *)movie->pdin);\n\t\tif (e) return e;\n\t\te = gf_isom_box_write((GF_Box *)movie->pdin, movie->editFileMap->bs);\n\t\tif (e) return e;\n\t}\n\tmovie->mdat->bsOffset = gf_bs_get_position(movie->editFileMap->bs);\n\n\t/*we have a trick here: the data will be stored on the fly, so the first\n\tthing in the file is the MDAT. As we don't know if we have a large file (>4 GB) or not\n\tdo as if we had one and write 16 bytes: 4 (type) + 4 (size) + 8 (largeSize)...*/\n\tgf_bs_write_long_int(movie->editFileMap->bs, 0, 64);\n\tgf_bs_write_long_int(movie->editFileMap->bs, 0, 64);\n\treturn GF_OK;\n}\n\nstatic GF_Err CheckNoData(GF_ISOFile *movie)\n{\n\tif (movie->openMode != GF_ISOM_OPEN_WRITE) return GF_OK;\n\tif (gf_bs_get_position(movie->editFileMap->bs)) return GF_BAD_PARAM;\n\treturn GF_OK;\n}\n\n/**************************************************************\n\t\t\t\t\tFile Writing / Editing\n**************************************************************/\n//quick function to add an IOD/OD to the file if not present (iods is optional)\nGF_Err AddMovieIOD(GF_MovieBox *moov, u8 isIOD)\n{\n\tGF_Descriptor *od;\n\tGF_ObjectDescriptorBox *iods;\n\n\t//do we have an IOD ?? If not, create one.\n\tif (moov->iods) return GF_OK;\n\n\tif (isIOD) {\n\t\tod = gf_odf_desc_new(GF_ODF_ISOM_IOD_TAG);\n\t} else {\n\t\tod = gf_odf_desc_new(GF_ODF_ISOM_OD_TAG);\n\t}\n\tif (!od) return GF_OUT_OF_MEM;\n\t((GF_IsomObjectDescriptor *)od)->objectDescriptorID = 1;\n\n\tiods = (GF_ObjectDescriptorBox *) gf_isom_box_new_parent(&moov->child_boxes, GF_ISOM_BOX_TYPE_IODS);\n\tif (!iods) return GF_OUT_OF_MEM;\n\tiods->descriptor = od;\n\treturn moov_on_child_box((GF_Box*)moov, (GF_Box *)iods, GF_FALSE);\n}\n\n//add a track to the root OD\nGF_EXPORT\nGF_Err gf_isom_add_track_to_root_od(GF_ISOFile *movie, u32 trackNumber)\n{\n\tGF_Err e;\n\tGF_ES_ID_Inc *inc;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\te = gf_isom_insert_moov(movie);\n\tif (e) return e;\n\n\tif (!movie->moov->iods) AddMovieIOD(movie->moov, 0);\n\n\tif (gf_isom_is_track_in_root_od(movie, trackNumber) == 1) return GF_OK;\n\n\tinc = (GF_ES_ID_Inc *) gf_odf_desc_new(GF_ODF_ESD_INC_TAG);\n\tinc->trackID = gf_isom_get_track_id(movie, trackNumber);\n\tif (!inc->trackID) {\n\t\tgf_odf_desc_del((GF_Descriptor *)inc);\n\t\treturn movie->LastError;\n\t}\n\tif ( (movie->LastError = gf_isom_add_desc_to_root_od(movie, (GF_Descriptor *)inc) ) ) {\n\t\treturn movie->LastError;\n\t}\n\tgf_odf_desc_del((GF_Descriptor *)inc);\n\treturn GF_OK;\n}\n\n//remove the root OD\nGF_EXPORT\nGF_Err gf_isom_remove_root_od(GF_ISOFile *movie)\n{\n\tGF_Err e;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\tif (!movie->moov || !movie->moov->iods) return GF_OK;\n\tgf_isom_box_del_parent(&movie->moov->child_boxes, (GF_Box *)movie->moov->iods);\n\tmovie->moov->iods = NULL;\n\treturn GF_OK;\n}\n\n//remove a track to the root OD\nGF_EXPORT\nGF_Err gf_isom_remove_track_from_root_od(GF_ISOFile *movie, u32 trackNumber)\n{\n\tGF_List *esds;\n\tGF_ES_ID_Inc *inc;\n\tu32 i;\n\tGF_Err e;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\tif (!movie->moov) return GF_OK;\n\n\tif (!gf_isom_is_track_in_root_od(movie, trackNumber)) return GF_OK;\n\n\tif (!movie->moov->iods) {\n\t\te = AddMovieIOD(movie->moov, 0);\n\t\tif (e) return e;\n\t}\n\tswitch (movie->moov->iods->descriptor->tag) {\n\tcase GF_ODF_ISOM_IOD_TAG:\n\t\tesds = ((GF_IsomInitialObjectDescriptor *)movie->moov->iods->descriptor)->ES_ID_IncDescriptors;\n\t\tbreak;\n\tcase GF_ODF_ISOM_OD_TAG:\n\t\tesds = ((GF_IsomObjectDescriptor *)movie->moov->iods->descriptor)->ES_ID_IncDescriptors;\n\t\tbreak;\n\tdefault:\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\n\t//get the desc\n\ti=0;\n\twhile ((inc = (GF_ES_ID_Inc*)gf_list_enum(esds, &i))) {\n\t\tif (inc->trackID == (u32) gf_isom_get_track_id(movie, trackNumber)) {\n\t\t\tgf_odf_desc_del((GF_Descriptor *)inc);\n\t\t\tgf_list_rem(esds, i-1);\n\t\t\tbreak;\n\t\t}\n\t}\n\t//we don't remove the iod for P&Ls and other potential info\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_creation_time(GF_ISOFile *movie, u64 ctime, u64 mtime)\n{\n\tif (!movie || !movie->moov) return GF_BAD_PARAM;\n\tmovie->moov->mvhd->creationTime = ctime;\n\tmovie->moov->mvhd->modificationTime = mtime;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_track_creation_time(GF_ISOFile *movie,u32 trackNumber, u64 ctime, u64 mtime)\n{\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\ttrak->Header->creationTime = ctime;\n\ttrak->Header->modificationTime = mtime;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_media_creation_time(GF_ISOFile *movie,u32 trackNumber, u64 ctime, u64 mtime)\n{\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\tif (!trak->Media || !trak->Media->mediaHeader) return GF_ISOM_INVALID_FILE;\n\n\ttrak->Media->mediaHeader->creationTime = ctime;\n\ttrak->Media->mediaHeader->modificationTime = mtime;\n\treturn GF_OK;\n}\n\n//sets the enable flag of a track\nGF_EXPORT\nGF_Err gf_isom_set_track_enabled(GF_ISOFile *movie, u32 trackNumber, Bool enableTrack)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tif (enableTrack) {\n\t\ttrak->Header->flags |= 1;\n\t} else {\n\t\ttrak->Header->flags &= ~1;\n\t}\n\treturn GF_OK;\n}\n\n//sets the enable flag of a track\nGF_EXPORT\nGF_Err gf_isom_set_track_flags(GF_ISOFile *movie, u32 trackNumber, u32 flags, GF_ISOMTrackFlagOp op)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\tif (op==GF_ISOM_TKFLAGS_ADD)\n\t\ttrak->Header->flags |= flags;\n\telse if (op==GF_ISOM_TKFLAGS_REM)\n\t\ttrak->Header->flags &= ~flags;\n\telse\n\t\ttrak->Header->flags = flags;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_media_language(GF_ISOFile *movie, u32 trackNumber, char *code)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !code) return GF_BAD_PARAM;\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\t// Old language-storage processing\n\t// if the new code is on 3 chars, we use it\n\t// otherwise, we find the associated 3 chars code and use it\n\tif (strlen(code) == 3) {\n\t\tmemcpy(trak->Media->mediaHeader->packedLanguage, code, sizeof(char)*3);\n\t} else {\n\t\ts32 lang_idx;\n\t\tconst char *code_3cc;\n\t\tlang_idx = gf_lang_find(code);\n\t\tif (lang_idx == -1) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"The given code is not a valid one: %s, using 'und' as 3-letter code\\n\", code));\n\t\t\tcode_3cc = \"und\";\n\t\t} else {\n\t\t\tcode_3cc = gf_lang_get_3cc(lang_idx);\n\t\t}\n\t\tmemcpy(trak->Media->mediaHeader->packedLanguage, code_3cc, sizeof(char)*3);\n\t}\n\n\t// New language-storage processing\n\t// change the code in the extended language box (if any)\n\t// otherwise add an extended language box only if the given code is not 3 chars\n\t{\n\t\tu32 i, count;\n\t\tGF_ExtendedLanguageBox *elng;\n\t\telng = NULL;\n\t\tcount = gf_list_count(trak->Media->child_boxes);\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tGF_Box *box = (GF_Box *)gf_list_get(trak->Media->child_boxes, i);\n\t\t\tif (box->type == GF_ISOM_BOX_TYPE_ELNG) {\n\t\t\t\telng = (GF_ExtendedLanguageBox *)box;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!elng && (strlen(code) > 3)) {\n\t\t\telng = (GF_ExtendedLanguageBox *)gf_isom_box_new_parent(&trak->Media->child_boxes, GF_ISOM_BOX_TYPE_ELNG);\n\t\t\tif (!elng) return GF_OUT_OF_MEM;\n\t\t}\n\t\tif (elng) {\n\t\t\tif (elng->extended_language) {\n\t\t\t\tgf_free(elng->extended_language);\n\t\t\t}\n\t\t\telng->extended_language = gf_strdup(code);\n\t\t}\n\t}\n\tif (!movie->keep_utc)\n\t\ttrak->Media->mediaHeader->modificationTime = gf_isom_get_mp4time();\n\treturn GF_OK;\n}\n\nstatic GF_Err gf_isom_set_root_iod(GF_ISOFile *movie)\n{\n\tGF_IsomInitialObjectDescriptor *iod;\n\tGF_IsomObjectDescriptor *od;\n\tGF_Err e;\n\t\n\te = gf_isom_insert_moov(movie);\n\tif (e) return e;\n\tif (!movie->moov->iods) {\n\t\tAddMovieIOD(movie->moov, 1);\n\t\treturn GF_OK;\n\t}\n\t//if OD, switch to IOD\n\tif (movie->moov->iods->descriptor->tag == GF_ODF_ISOM_IOD_TAG) return GF_OK;\n\tod = (GF_IsomObjectDescriptor *) movie->moov->iods->descriptor;\n\tiod = (GF_IsomInitialObjectDescriptor*)gf_malloc(sizeof(GF_IsomInitialObjectDescriptor));\n\tif (!iod) return GF_OUT_OF_MEM;\n\n\tmemset(iod, 0, sizeof(GF_IsomInitialObjectDescriptor));\n\n\tiod->ES_ID_IncDescriptors = od->ES_ID_IncDescriptors;\n\tod->ES_ID_IncDescriptors = NULL;\n\t//not used in root OD\n\tiod->ES_ID_RefDescriptors = NULL;\n\tiod->extensionDescriptors = od->extensionDescriptors;\n\tod->extensionDescriptors = NULL;\n\tiod->IPMP_Descriptors = od->IPMP_Descriptors;\n\tod->IPMP_Descriptors = NULL;\n\tiod->objectDescriptorID = od->objectDescriptorID;\n\tiod->OCIDescriptors = od->OCIDescriptors;\n\tod->OCIDescriptors = NULL;\n\tiod->tag = GF_ODF_ISOM_IOD_TAG;\n\tiod->URLString = od->URLString;\n\tod->URLString = NULL;\n\n\tgf_odf_desc_del((GF_Descriptor *) od);\n\tmovie->moov->iods->descriptor = (GF_Descriptor *)iod;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_add_desc_to_root_od(GF_ISOFile *movie, const GF_Descriptor *theDesc)\n{\n\tGF_Err e;\n\tGF_Descriptor *desc, *dupDesc;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\te = gf_isom_insert_moov(movie);\n\tif (e) return e;\n\n\tif (!movie->moov->iods) {\n\t\te = AddMovieIOD(movie->moov, 0);\n\t\tif (e) return e;\n\t}\n\tif (theDesc->tag==GF_ODF_IPMP_TL_TAG) gf_isom_set_root_iod(movie);\n\n\tdesc = movie->moov->iods->descriptor;\n\t//the type of desc is handled at the OD/IOD level, we'll be notified\n\t//if the desc is not allowed\n\tswitch (desc->tag) {\n\tcase GF_ODF_ISOM_IOD_TAG:\n\tcase GF_ODF_ISOM_OD_TAG:\n\t\t//duplicate the desc\n\t\te = gf_odf_desc_copy((GF_Descriptor *)theDesc, &dupDesc);\n\t\tif (e) return e;\n\t\t//add it (MUST BE  (I)OD level desc)\n\t\tmovie->LastError = gf_odf_desc_add_desc(desc, dupDesc);\n\t\tif (movie->LastError) gf_odf_desc_del((GF_Descriptor *)dupDesc);\n\t\tbreak;\n\tdefault:\n\t\tmovie->LastError = GF_ISOM_INVALID_FILE;\n\t\tbreak;\n\t}\n\treturn movie->LastError;\n}\n\n\nGF_EXPORT\nGF_Err gf_isom_set_timescale(GF_ISOFile *movie, u32 timeScale)\n{\n\tGF_TrackBox *trak;\n\tu32 i;\n\tGF_Err e;\n\tif (!timeScale) return GF_BAD_PARAM;\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\te = gf_isom_insert_moov(movie);\n\tif (e) return e;\n\n\tif (movie->moov->mvhd->timeScale == timeScale) return GF_OK;\n\n\t/*rewrite all durations and edit lists*/\n\tmovie->moov->mvhd->duration *= timeScale;\n\tmovie->moov->mvhd->duration /= movie->moov->mvhd->timeScale;\n\tif (movie->moov->mvex && movie->moov->mvex->mehd) {\n\t\tmovie->moov->mvex->mehd->fragment_duration *= timeScale;\n\t\tmovie->moov->mvex->mehd->fragment_duration /= movie->moov->mvhd->timeScale;\n\t}\n\n\ti=0;\n\twhile ((trak = (GF_TrackBox*)gf_list_enum(movie->moov->trackList, &i))) {\n\t\ttrak->Header->duration *= timeScale;\n\t\ttrak->Header->duration /= movie->moov->mvhd->timeScale;\n\n\t\tif (trak->editBox && trak->editBox->editList) {\n\t\t\tu32 j, count = gf_list_count(trak->editBox->editList->entryList);\n\t\t\tfor (j=0; j<count; j++) {\n\t\t\t\tGF_EdtsEntry *ent = (GF_EdtsEntry *)gf_list_get(trak->editBox->editList->entryList, j);\n\t\t\t\tent->segmentDuration *= timeScale;\n\t\t\t\tent->segmentDuration /= movie->moov->mvhd->timeScale;\n\t\t\t}\n\t\t}\n\t}\n\tif (movie->moov->mvex && movie->moov->mvex->mehd) {\n\t\tmovie->moov->mvex->mehd->fragment_duration *= timeScale;\n\t\tmovie->moov->mvex->mehd->fragment_duration /= movie->moov->mvhd->timeScale;\n\t}\n\tmovie->moov->mvhd->timeScale = timeScale;\n\tmovie->interleavingTime = timeScale;\n\treturn GF_OK;\n}\n\n\nGF_EXPORT\nGF_Err gf_isom_set_pl_indication(GF_ISOFile *movie, GF_ISOProfileLevelType PL_Code, u8 ProfileLevel)\n{\n\tGF_IsomInitialObjectDescriptor *iod;\n\tGF_Err e;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\te = gf_isom_set_root_iod(movie);\n\tif (e) return e;\n\n\tiod = (GF_IsomInitialObjectDescriptor *)movie->moov->iods->descriptor;\n\n\tswitch (PL_Code) {\n\tcase GF_ISOM_PL_AUDIO:\n\t\tiod->audio_profileAndLevel = ProfileLevel;\n\t\tbreak;\n\tcase GF_ISOM_PL_GRAPHICS:\n\t\tiod->graphics_profileAndLevel = ProfileLevel;\n\t\tbreak;\n\tcase GF_ISOM_PL_OD:\n\t\tiod->OD_profileAndLevel = ProfileLevel;\n\t\tbreak;\n\tcase GF_ISOM_PL_SCENE:\n\t\tiod->scene_profileAndLevel = ProfileLevel;\n\t\tbreak;\n\tcase GF_ISOM_PL_VISUAL:\n\t\tiod->visual_profileAndLevel = ProfileLevel;\n\t\tbreak;\n\tcase GF_ISOM_PL_INLINE:\n\t\tiod->inlineProfileFlag = ProfileLevel ? 1 : 0;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_root_od_id(GF_ISOFile *movie, u32 OD_ID)\n{\n\tGF_Err e;\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\te = gf_isom_insert_moov(movie);\n\tif (e) return e;\n\tif (!movie->moov->iods) {\n\t\te = AddMovieIOD(movie->moov, 0);\n\t\tif (e) return e;\n\t}\n\n\tswitch (movie->moov->iods->descriptor->tag) {\n\tcase GF_ODF_ISOM_OD_TAG:\n\t\t((GF_IsomObjectDescriptor *)movie->moov->iods->descriptor)->objectDescriptorID = OD_ID;\n\t\tbreak;\n\tcase GF_ODF_ISOM_IOD_TAG:\n\t\t((GF_IsomInitialObjectDescriptor *)movie->moov->iods->descriptor)->objectDescriptorID = OD_ID;\n\t\tbreak;\n\tdefault:\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_root_od_url(GF_ISOFile *movie, const char *url_string)\n{\n\tGF_Err e;\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\te = gf_isom_insert_moov(movie);\n\tif (e) return e;\n\n\tif (!movie->moov->iods) {\n\t\te = AddMovieIOD(movie->moov, 0);\n\t\tif (e) return e;\n\t}\n\n\tswitch (movie->moov->iods->descriptor->tag) {\n\tcase GF_ODF_ISOM_OD_TAG:\n\t\tif (((GF_IsomObjectDescriptor *)movie->moov->iods->descriptor)->URLString) gf_free(((GF_IsomObjectDescriptor *)movie->moov->iods->descriptor)->URLString);\n\t\t((GF_IsomObjectDescriptor *)movie->moov->iods->descriptor)->URLString = url_string ? gf_strdup(url_string) : NULL;\n\t\tbreak;\n\tcase GF_ODF_ISOM_IOD_TAG:\n\t\tif (((GF_IsomInitialObjectDescriptor *)movie->moov->iods->descriptor)->URLString) gf_free(((GF_IsomInitialObjectDescriptor *)movie->moov->iods->descriptor)->URLString);\n\t\t((GF_IsomInitialObjectDescriptor *)movie->moov->iods->descriptor)->URLString = url_string ? gf_strdup(url_string) : NULL;\n\t\tbreak;\n\tdefault:\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_ISOTrackID gf_isom_get_last_created_track_id(GF_ISOFile *movie)\n{\n\treturn movie ? movie->last_created_track_id : 0;\n}\n\n\nGF_EXPORT\nGF_Err gf_isom_load_extra_boxes(GF_ISOFile *movie, u8 *moov_boxes, u32 moov_boxes_size, Bool udta_only)\n{\n\tGF_BitStream *bs;\n\n\tGF_Err e = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\te = gf_isom_insert_moov(movie);\n\tif (e) return e;\n\n\tbs = gf_bs_new(moov_boxes, moov_boxes_size, GF_BITSTREAM_READ);\n\n\t//we may have terminators in some QT files (4 bytes set to 0 ...)\n\twhile (gf_bs_available(bs) >= 8) {\n\t\tGF_Box *a_box;\n\t\te = gf_isom_box_parse_ex((GF_Box**)&a_box, bs, GF_ISOM_BOX_TYPE_MOOV, GF_FALSE);\n\t\tif (e || !a_box) goto exit;\n\n\t\tif (a_box->type == GF_ISOM_BOX_TYPE_UDTA) {\n\t\t\tif (movie->moov->udta) gf_isom_box_del_parent(&movie->moov->child_boxes, (GF_Box*)movie->moov->udta);\n\t\t\tmovie->moov->udta = (GF_UserDataBox*) a_box;\n\n\t\t\tif (!movie->moov->child_boxes) movie->moov->child_boxes = gf_list_new();\n\t\t\tgf_list_add(movie->moov->child_boxes, a_box);\n\n\t\t} else if (!udta_only && (a_box->type!=GF_ISOM_BOX_TYPE_PSSH) ) {\n\t\t\tif (!movie->moov->child_boxes) movie->moov->child_boxes = gf_list_new();\n\t\t\tgf_list_add(movie->moov->child_boxes, a_box);\n\t\t} else {\n\t\t\tgf_isom_box_del(a_box);\n\t\t}\n\t}\nexit:\n\tgf_bs_del(bs);\n\treturn e;\n}\n\n//creates a new Track. If trackID = 0, the trackID is chosen by the API\n//returns the track number or 0 if error\nGF_EXPORT\nu32 gf_isom_new_track_from_template(GF_ISOFile *movie, GF_ISOTrackID trakID, u32 MediaType, u32 TimeScale, u8 *tk_box, u32 tk_box_size, Bool udta_only)\n{\n\tGF_Err e;\n\tu64 now;\n\tu8 isHint;\n\tGF_TrackBox *trak;\n\tGF_TrackHeaderBox *tkhd;\n\tGF_MediaBox *mdia;\n\tGF_UserDataBox *udta = NULL;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) {\n\t\tgf_isom_set_last_error(movie, e);\n\t\treturn 0;\n\t}\n\te = gf_isom_insert_moov(movie);\n\tif (e) return e;\n\n\n\tisHint = 0;\n\t//we're creating a hint track... it's the same, but mode HAS TO BE EDIT\n\tif (MediaType == GF_ISOM_MEDIA_HINT) {\n//\t\tif (movie->openMode != GF_ISOM_OPEN_EDIT) return 0;\n\t\tisHint = 1;\n\t}\n\n\tmdia = NULL;\n\ttkhd = NULL;\n\ttrak = NULL;\n\tif (trakID) {\n\t\t//check if we are in ES_ID boundaries\n\t\tif (!isHint && (trakID > 0xFFFF)) {\n\t\t\tgf_isom_set_last_error(movie, GF_BAD_PARAM);\n\t\t\treturn 0;\n\t\t}\n\t\t//here we should look for available IDs ...\n\t\tif (!RequestTrack(movie->moov, trakID)) return 0;\n\t} else {\n\t\ttrakID = movie->moov->mvhd->nextTrackID;\n\t\tif (!trakID) trakID = 1;\n\t\t/*ESIDs are on 16 bits*/\n\t\tif (! isHint && (trakID > 0xFFFF)) trakID = 1;\n\n\t\twhile (1) {\n\t\t\tif (RequestTrack(movie->moov, trakID)) break;\n\t\t\ttrakID += 1;\n\t\t\tif (trakID == 0xFFFFFFFF) break;\n\t\t}\n\t\tif (trakID == 0xFFFFFFFF) {\n\t\t\tgf_isom_set_last_error(movie, GF_BAD_PARAM);\n\t\t\treturn 0;\n\t\t}\n\t\tif (! isHint && (trakID > 0xFFFF)) {\n\t\t\tgf_isom_set_last_error(movie, GF_BAD_PARAM);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (tk_box) {\n\t\tGF_BitStream *bs = gf_bs_new(tk_box, tk_box_size, GF_BITSTREAM_READ);\n\t\tgf_bs_set_cookie(bs, GF_ISOM_BS_COOKIE_NO_LOGS|GF_ISOM_BS_COOKIE_CLONE_TRACK);\n\n\t\te = gf_isom_box_parse_ex((GF_Box**)&trak, bs, GF_ISOM_BOX_TYPE_MOOV, GF_FALSE);\n\t\tgf_bs_del(bs);\n\t\tif (e) trak = NULL;\n\t\telse if (udta_only) {\n\t\t\tudta = trak->udta;\n\t\t\ttrak->udta = NULL;\n\t\t\tgf_isom_box_del((GF_Box*)trak);\n\t\t} else {\n\t\t\tBool tpl_ok = GF_TRUE;\n\t\t\tif (!trak->Header || !trak->Media || !trak->Media->handler || !trak->Media->mediaHeader || !trak->Media->information) tpl_ok = GF_FALSE;\n\n\t\t\telse {\n\t\t\t\tif (!MediaType) MediaType = trak->Media->handler->handlerType;\n\t\t\t\te = NewMedia(&trak->Media, MediaType, TimeScale);\n\t\t\t\tif (e) tpl_ok = GF_FALSE;\n\t\t\t}\n\t\t\tif (!tpl_ok) {\n\t\t\t\tudta = trak->udta;\n\t\t\t\ttrak->udta = NULL;\n\t\t\t\tgf_isom_box_del((GF_Box*)trak);\n\t\t\t}\n\t\t}\n\t}\n\tnow = gf_isom_get_mp4time();\n\tif (!trak) {\n\t\t//OK, now create a track...\n\t\ttrak = (GF_TrackBox *) gf_isom_box_new_parent(&movie->moov->child_boxes, GF_ISOM_BOX_TYPE_TRAK);\n\t\tif (!trak) {\n\t\t\tgf_isom_set_last_error(movie, GF_OUT_OF_MEM);\n\t\t\treturn 0;\n\t\t}\n\t\ttkhd = (GF_TrackHeaderBox *) gf_isom_box_new_parent(&trak->child_boxes, GF_ISOM_BOX_TYPE_TKHD);\n\t\tif (!tkhd) {\n\t\t\tgf_isom_set_last_error(movie, GF_OUT_OF_MEM);\n\t\t\treturn 0;\n\t\t}\n\n\t\t//OK, set up the media trak\n\t\te = NewMedia(&mdia, MediaType, TimeScale);\n\t\tif (e) {\n\t\t\tgf_isom_box_del((GF_Box *)mdia);\n\t\t\treturn 0;\n\t\t}\n\t\tassert(trak->child_boxes);\n\t\tgf_list_add(trak->child_boxes, mdia);\n\n\t\t//OK, add this media to our track\n\t\tmdia->mediaTrack = trak;\n\n\t\te = trak_on_child_box((GF_Box*)trak, (GF_Box *) tkhd, GF_FALSE);\n\t\tif (e) goto err_exit;\n\t\te = trak_on_child_box((GF_Box*)trak, (GF_Box *) mdia, GF_FALSE);\n\t\tif (e) goto err_exit;\n\t\ttkhd->trackID = trakID;\n\n\t\tif (gf_sys_is_test_mode() ) {\n\t\t\ttkhd->creationTime = 0;\n\t\t\tmdia->mediaHeader->creationTime = 0;\n\t\t} else {\n\t\t\ttkhd->creationTime = now;\n\t\t\tmdia->mediaHeader->creationTime = now;\n\t\t}\n\n\t} else {\n\t\ttkhd = trak->Header;\n\t\ttkhd->trackID = trakID;\n\t\tmdia = trak->Media;\n\t\tmdia->mediaTrack = trak;\n\t\tmdia->mediaHeader->timeScale = TimeScale;\n\t\tif (mdia->handler->handlerType != MediaType) {\n\t\t\tmdia->handler->handlerType = MediaType;\n\t\t\ttkhd->width = 0;\n\t\t\ttkhd->height = 0;\n\t\t\ttkhd->volume = 0;\n\t\t} else {\n\t\t\tMediaType = 0;\n\t\t}\n\t\ttrak->Header->duration = 0;\n\t\tmdia->mediaHeader->duration = 0;\n\n\t\tif (!movie->moov->child_boxes) movie->moov->child_boxes = gf_list_new();\n\t\tgf_list_add(movie->moov->child_boxes, trak);\n\t}\n\tif (MediaType) {\n\t\t//some default properties for Audio, Visual or private tracks\n\t\tswitch (MediaType) {\n\t\tcase GF_ISOM_MEDIA_VISUAL:\n\t\tcase GF_ISOM_MEDIA_AUXV:\n\t\tcase GF_ISOM_MEDIA_PICT:\n\t\tcase GF_ISOM_MEDIA_SCENE:\n\t\tcase GF_ISOM_MEDIA_TEXT:\n\t\tcase GF_ISOM_MEDIA_SUBT:\n\t\t\t/*320-240 pix in 16.16*/\n\t\t\ttkhd->width = 0x01400000;\n\t\t\ttkhd->height = 0x00F00000;\n\t\t\tbreak;\n\t\tcase GF_ISOM_MEDIA_AUDIO:\n\t\t\ttkhd->volume = 0x0100;\n\t\t\tbreak;\n\t\t}\n\t}\n\tmovie->last_created_track_id = tkhd->trackID;\n\t\n\tif (!movie->keep_utc && !gf_sys_is_test_mode() ) {\n\t\ttkhd->modificationTime = now;\n\t \tmdia->mediaHeader->modificationTime = now;\n\t}\n\n\t//OK, add our trak\n\te = moov_on_child_box((GF_Box*)movie->moov, (GF_Box *)trak, GF_FALSE);\n\tif (e) goto err_exit;\n\t//set the new ID available\n\tif (trakID+1> movie->moov->mvhd->nextTrackID)\n\t\tmovie->moov->mvhd->nextTrackID = trakID+1;\n\n\ttrak->udta = udta;\n\n\t//and return our track number\n\treturn gf_isom_get_track_by_id(movie, trakID);\n\nerr_exit:\n\t//tkhd is registered with track and will be destroyed there\n\tif (trak) gf_isom_box_del((GF_Box *)trak);\n\tif (mdia) gf_isom_box_del((GF_Box *)mdia);\n\treturn 0;\n}\n\nGF_EXPORT\nu32 gf_isom_new_track(GF_ISOFile *movie, GF_ISOTrackID trakID, u32 MediaType, u32 TimeScale)\n{\n\treturn gf_isom_new_track_from_template(movie, trakID, MediaType, TimeScale, NULL, 0, GF_FALSE);\n}\n\nGF_EXPORT\nGF_Err gf_isom_remove_stream_description(GF_ISOFile *movie, u32 trackNumber, u32 StreamDescriptionIndex)\n{\n\tGF_TrackBox *trak;\n\tGF_Err e;\n\tGF_SampleEntryBox *entry;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !trak->Media) return GF_BAD_PARAM;\n\n\tif (!movie->keep_utc)\n\t\ttrak->Media->mediaHeader->modificationTime = gf_isom_get_mp4time();\n\n\tentry = (GF_SampleEntryBox*)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, StreamDescriptionIndex - 1);\n\tif (!entry) return GF_BAD_PARAM;\n\tgf_list_rem(trak->Media->information->sampleTable->SampleDescription->child_boxes, StreamDescriptionIndex - 1);\n\tgf_isom_box_del((GF_Box *)entry);\n\treturn GF_OK;\n}\n\n//Create a new StreamDescription in the file. The URL and URN are used to describe external media\nGF_EXPORT\nGF_Err gf_isom_new_mpeg4_description(GF_ISOFile *movie,\n                                     u32 trackNumber,\n                                     const GF_ESD *esd,\n                                     const char *URLname,\n                                     const char *URNname,\n                                     u32 *outDescriptionIndex)\n{\n\tGF_TrackBox *trak;\n\tGF_Err e;\n\tu32 dataRefIndex;\n\tGF_ESD *new_esd;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !trak->Media ||\n\t        !esd || !esd->decoderConfig ||\n\t        !esd->slConfig) return GF_BAD_PARAM;\n\n\t//get or create the data ref\n\te = Media_FindDataRef(trak->Media->information->dataInformation->dref, (char *)URLname, (char *)URNname, &dataRefIndex);\n\tif (e) return e;\n\tif (!dataRefIndex) {\n\t\te = Media_CreateDataRef(movie, trak->Media->information->dataInformation->dref, (char *)URLname, (char *)URNname, &dataRefIndex);\n\t\tif (e) return e;\n\t}\n\t//duplicate our desc\n\te = gf_odf_desc_copy((GF_Descriptor *)esd, (GF_Descriptor **)&new_esd);\n\tif (e) return e;\n\tif (!movie->keep_utc)\n\t\ttrak->Media->mediaHeader->modificationTime = gf_isom_get_mp4time();\n\te = Track_SetStreamDescriptor(trak, 0, dataRefIndex, new_esd, outDescriptionIndex);\n\tif (e) {\n\t\tgf_odf_desc_del((GF_Descriptor *)new_esd);\n\t\treturn e;\n\t}\n\treturn e;\n}\n\nGF_Err gf_isom_flush_chunk(GF_TrackBox *trak, Bool is_final)\n{\n\tGF_Err e;\n\tu64 data_offset;\n\tu32 sample_number;\n\tu8 *chunk_data;\n\tu32 chunk_size, chunk_alloc;\n\tif (!trak->chunk_cache) return GF_OK;\n\n\tgf_bs_get_content_no_truncate(trak->chunk_cache, &chunk_data, &chunk_size, &chunk_alloc);\n\n\tdata_offset = gf_isom_datamap_get_offset(trak->Media->information->dataHandler);\n\n\te = gf_isom_datamap_add_data(trak->Media->information->dataHandler, chunk_data, chunk_size);\n\tif (e) return e;\n\n\tsample_number = 1 + trak->Media->information->sampleTable->SampleSize->sampleCount;\n\tsample_number -= trak->nb_samples_in_cache;\n\n\te = stbl_AddChunkOffset(trak->Media, sample_number, trak->chunk_stsd_idx, data_offset, trak->nb_samples_in_cache);\n\n\tif (is_final) {\n\t\tgf_free(chunk_data);\n\t\tgf_bs_del(trak->chunk_cache);\n\t\ttrak->chunk_cache = NULL;\n\t} else {\n\t\tgf_bs_reassign_buffer(trak->chunk_cache, chunk_data, chunk_alloc);\n\t}\n\treturn e;\n}\n\nstatic GF_Err trak_add_sample(GF_ISOFile *movie, GF_TrackBox *trak, const GF_ISOSample *sample, u32 descIndex, u64 data_offset, u32 syncShadowSampleNum)\n{\n\tBool skip_data = GF_FALSE;\n\tGF_Err e;\n\n\t//faststart mode with interleaving time, cache data until we have a full chunk\n\tif ((movie->storageMode==GF_ISOM_STORE_FASTSTART) && movie->interleavingTime) {\n\t\tBool flush_chunk = GF_FALSE;\n\t\tu64 stime = sample->DTS;\n\t\tstime *= movie->moov->mvhd->timeScale;\n\t\tstime /= trak->Media->mediaHeader->timeScale;\n\n\t\tif (stime - trak->first_dts_chunk > movie->interleavingTime)\n\t\t\tflush_chunk = GF_TRUE;\n\n\t\tif (movie->next_flush_chunk_time < stime)\n\t\t\tflush_chunk = GF_TRUE;\n\n\t\tif (trak->chunk_stsd_idx != descIndex)\n\t\t\tflush_chunk = GF_TRUE;\n\n\t\tif (trak->Media->information->sampleTable->MaxChunkSize && trak->Media->information->sampleTable->MaxChunkSize < trak->chunk_cache_size + sample->dataLength)\n\t\t\tflush_chunk = GF_TRUE;\n\n\t\tif (flush_chunk) {\n\t\t\tmovie->next_flush_chunk_time = stime + movie->interleavingTime;\n\t\t\tif (trak->chunk_cache) {\n\t\t\t\te = gf_isom_flush_chunk(trak, GF_FALSE);\n\t\t\t\tif (e) return e;\n\t\t\t}\n\t\t\ttrak->nb_samples_in_cache = 0;\n\t\t\ttrak->chunk_cache_size = 0;\n\t\t\ttrak->first_dts_chunk = stime;\n\t\t}\n\t\tif (!trak->chunk_cache)\n\t\t\ttrak->chunk_cache = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\t\tgf_bs_write_data(trak->chunk_cache, sample->data, sample->dataLength);\n\t\ttrak->nb_samples_in_cache += sample->nb_pack ? sample->nb_pack : 1;\n\t\ttrak->chunk_cache_size += sample->dataLength;\n\t\ttrak->chunk_stsd_idx = descIndex;\n\n\t\tskip_data = GF_TRUE;\n\t}\n\n\te = Media_AddSample(trak->Media, data_offset, sample, descIndex, syncShadowSampleNum);\n\tif (e) return e;\n\n\tif (!skip_data && sample->dataLength) {\n\t\te = gf_isom_datamap_add_data(trak->Media->information->dataHandler, sample->data, sample->dataLength);\n\t\tif (e) return e;\n\t}\n\n\treturn GF_OK;\n}\n\n//Add samples to a track. Use streamDescriptionIndex to specify the desired stream (if several)\nGF_EXPORT\nGF_Err gf_isom_add_sample(GF_ISOFile *movie, u32 trackNumber, u32 StreamDescriptionIndex, const GF_ISOSample *sample)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\tGF_SampleEntryBox *entry;\n\tu32 dataRefIndex;\n\tu64 data_offset;\n\tu32 descIndex;\n\tGF_DataEntryURLBox *Dentry;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\te = FlushCaptureMode(movie);\n\tif (e) return e;\n\n\te = unpack_track(trak);\n\tif (e) return e;\n\n\t//OK, add the sample\n\t//1- Get the streamDescriptionIndex and dataRefIndex\n\t//not specified, get the latest used...\n\tdescIndex = StreamDescriptionIndex;\n\tif (!StreamDescriptionIndex) {\n\t\tdescIndex = trak->Media->information->sampleTable->currentEntryIndex;\n\t}\n\te = Media_GetSampleDesc(trak->Media, descIndex, &entry, &dataRefIndex);\n\tif (e) return e;\n\tif (!entry || !dataRefIndex) return GF_BAD_PARAM;\n\t//set the current to this one\n\ttrak->Media->information->sampleTable->currentEntryIndex = descIndex;\n\n\n\t//get this dataRef and return false if not self contained\n\tDentry = (GF_DataEntryURLBox*)gf_list_get(trak->Media->information->dataInformation->dref->child_boxes, dataRefIndex - 1);\n\tif (!Dentry || Dentry->flags != 1) return GF_BAD_PARAM;\n\n\t//Open our data map. We are adding stuff, so use EDIT\n\te = gf_isom_datamap_open(trak->Media, dataRefIndex, 1);\n\tif (e) return e;\n\n\t//Get the offset...\n\tdata_offset = gf_isom_datamap_get_offset(trak->Media->information->dataHandler);\n\n\t/*rewrite OD frame*/\n\tif (trak->Media->handler->handlerType == GF_ISOM_MEDIA_OD) {\n\t\tGF_ISOSample *od_sample = NULL;\n\n\t\te = Media_ParseODFrame(trak->Media, sample, &od_sample);\n\t\tif (e) return e;\n\n\t\te = trak_add_sample(movie, trak, od_sample, descIndex, data_offset, 0);\n\n\t\tif (od_sample)\n\t\t\tgf_isom_sample_del(&od_sample);\n\t} else {\n\t\te = trak_add_sample(movie, trak, sample, descIndex, data_offset, 0);\n\t}\n\tif (e) return e;\n\n\n\tif (!movie->keep_utc)\n\t\ttrak->Media->mediaHeader->modificationTime = gf_isom_get_mp4time();\n\treturn SetTrackDuration(trak);\n}\n\nGF_EXPORT\nGF_Err gf_isom_add_sample_shadow(GF_ISOFile *movie, u32 trackNumber, GF_ISOSample *sample)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\tGF_ISOSample *prev;\n\tGF_SampleEntryBox *entry;\n\tu32 dataRefIndex;\n\tu64 data_offset;\n\tu32 descIndex;\n\tu32 sampleNum, prevSampleNum;\n\tGF_DataEntryURLBox *Dentry;\n\tBool offset_times = GF_FALSE;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !sample) return GF_BAD_PARAM;\n\n\te = FlushCaptureMode(movie);\n\tif (e) return e;\n\n\te = unpack_track(trak);\n\tif (e) return e;\n\n\te = stbl_findEntryForTime(trak->Media->information->sampleTable, sample->DTS, 0, &sampleNum, &prevSampleNum);\n\tif (e) return e;\n\t/*we need the EXACT match*/\n\tif (!sampleNum) return GF_BAD_PARAM;\n\n\tprev = gf_isom_get_sample_info(movie, trackNumber, sampleNum, &descIndex, NULL);\n\tif (!prev) return gf_isom_last_error(movie);\n\t/*for conformance*/\n\tif (sample->DTS==prev->DTS) offset_times = GF_TRUE;\n\tgf_isom_sample_del(&prev);\n\n\te = Media_GetSampleDesc(trak->Media, descIndex, &entry, &dataRefIndex);\n\tif (e) return e;\n\tif (!entry || !dataRefIndex) return GF_BAD_PARAM;\n\ttrak->Media->information->sampleTable->currentEntryIndex = descIndex;\n\n\t//get this dataRef and return false if not self contained\n\tDentry = (GF_DataEntryURLBox*)gf_list_get(trak->Media->information->dataInformation->dref->child_boxes, dataRefIndex - 1);\n\tif (!Dentry || Dentry->flags != 1) return GF_BAD_PARAM;\n\n\t//Open our data map. We are adding stuff, so use EDIT\n\te = gf_isom_datamap_open(trak->Media, dataRefIndex, 1);\n\tif (e) return e;\n\n\tdata_offset = gf_isom_datamap_get_offset(trak->Media->information->dataHandler);\n\tif (offset_times) sample->DTS += 1;\n\n\t/*REWRITE ANY OD STUFF*/\n\tif (trak->Media->handler->handlerType == GF_ISOM_MEDIA_OD) {\n\t\tGF_ISOSample *od_sample = NULL;\n\t\te = Media_ParseODFrame(trak->Media, sample, &od_sample);\n\t\tif (e) return e;\n\n\t\te = trak_add_sample(movie, trak, od_sample, descIndex, data_offset, sampleNum);\n\t\tif (od_sample)\n\t\t\tgf_isom_sample_del(&od_sample);\n\t} else {\n\t\te = trak_add_sample(movie, trak, sample, descIndex, data_offset, sampleNum);\n\t}\n\tif (e) return e;\n\tif (offset_times) sample->DTS -= 1;\n\n\t//OK, update duration\n\te = Media_SetDuration(trak);\n\tif (e) return e;\n\tif (!movie->keep_utc)\n\t\ttrak->Media->mediaHeader->modificationTime = gf_isom_get_mp4time();\n\treturn SetTrackDuration(trak);\n}\n\nGF_EXPORT\nGF_Err gf_isom_append_sample_data(GF_ISOFile *movie, u32 trackNumber, u8 *data, u32 data_size)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\tGF_SampleEntryBox *entry;\n\tu32 dataRefIndex;\n\tu32 descIndex;\n\tGF_DataEntryURLBox *Dentry;\n\n\tif (!data_size) return GF_OK;\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tif (trak->Media->handler->handlerType == GF_ISOM_MEDIA_OD) return GF_BAD_PARAM;\n\n\t//OK, add the sample\n\tdescIndex = trak->Media->information->sampleTable->currentEntryIndex;\n\n\te = Media_GetSampleDesc(trak->Media, descIndex, &entry, &dataRefIndex);\n\tif (e) return e;\n\tif (!entry || !dataRefIndex) return GF_BAD_PARAM;\n\n\t//get this dataRef and return false if not self contained\n\tDentry = (GF_DataEntryURLBox*)gf_list_get(trak->Media->information->dataInformation->dref->child_boxes, dataRefIndex - 1);\n\tif (!Dentry || Dentry->flags != 1) return GF_BAD_PARAM;\n\n\t//Open our data map. We are adding stuff, so use EDIT\n\te = gf_isom_datamap_open(trak->Media, dataRefIndex, 1);\n\tif (e) return e;\n\n\t//add the media data\n\tif (trak->chunk_cache) {\n\t\tgf_bs_write_data(trak->chunk_cache, data, data_size);\n\t\ttrak->chunk_cache_size += data_size;\n\t} else {\n\t\te = gf_isom_datamap_add_data(trak->Media->information->dataHandler, data, data_size);\n\t\tif (e) return e;\n\t}\n\t//update data size\n\treturn stbl_SampleSizeAppend(trak->Media->information->sampleTable->SampleSize, data_size);\n}\n\n\n//Add sample reference to a track. The SampleOffset is the offset of the data in the referenced file\n//you must have created a StreamDescription with URL or URN specifying your referenced file\n//the data offset specifies the beginning of the chunk\n//Use streamDescriptionIndex to specify the desired stream (if several)\nGF_EXPORT\nGF_Err gf_isom_add_sample_reference(GF_ISOFile *movie, u32 trackNumber, u32 StreamDescriptionIndex, GF_ISOSample *sample, u64 dataOffset)\n{\n\tGF_TrackBox *trak;\n\tGF_SampleEntryBox *entry;\n\tu32 dataRefIndex;\n\tu32 descIndex;\n\tGF_DataEntryURLBox *Dentry;\n\tGF_Err e;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\te = unpack_track(trak);\n\tif (e) return e;\n\n\t//OD is not allowed as a data ref\n\tif (trak->Media->handler->handlerType == GF_ISOM_MEDIA_OD) {\n\t\treturn GF_BAD_PARAM;\n\t}\n\t//OK, add the sample\n\t//1- Get the streamDescriptionIndex and dataRefIndex\n\t//not specified, get the latest used...\n\tdescIndex = StreamDescriptionIndex;\n\tif (!StreamDescriptionIndex) {\n\t\tdescIndex = trak->Media->information->sampleTable->currentEntryIndex;\n\t}\n\te = Media_GetSampleDesc(trak->Media, descIndex, &entry, &dataRefIndex);\n\tif (e) return e;\n\tif (!entry || !dataRefIndex) return GF_BAD_PARAM;\n\t//set the current to this one\n\ttrak->Media->information->sampleTable->currentEntryIndex = descIndex;\n\n\n\t//get this dataRef and return false if self contained\n\tDentry =(GF_DataEntryURLBox*) gf_list_get(trak->Media->information->dataInformation->dref->child_boxes, dataRefIndex - 1);\n\tif (Dentry->flags == 1) return GF_BAD_PARAM;\n\n\t//add the meta data\n\te = Media_AddSample(trak->Media, dataOffset, sample, descIndex, 0);\n\tif (e) return e;\n\n\tif (!movie->keep_utc)\n\t\ttrak->Media->mediaHeader->modificationTime = gf_isom_get_mp4time();\n\t//OK, update duration\n\te = Media_SetDuration(trak);\n\tif (e) return e;\n\treturn SetTrackDuration(trak);\n\n}\n\n//set the duration of the last media sample. If not set, the duration of the last sample is the\n//duration of the previous one if any, or 1000 (default value).\nstatic GF_Err gf_isom_set_last_sample_duration_internal(GF_ISOFile *movie, u32 trackNumber, u64 dur_num, u32 dur_den, u32 mode)\n{\n\tGF_TrackBox *trak;\n\tGF_SttsEntry *ent;\n\tGF_TimeToSampleBox *stts;\n\tu64 mdur;\n\tu32 duration;\n\tGF_Err e;\n\tBool is_patch = GF_FALSE;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tif (mode==0) {\n\t\tduration = (u32) dur_num;\n\t} else if (mode==1) {\n\t\tduration = (u32) dur_num;\n\t\tif (dur_den) {\n\t\t\tduration *= trak->Media->mediaHeader->timeScale;\n\t\t\tduration /= dur_den;\n\t\t}\n\t} else {\n\t\tis_patch = GF_TRUE;\n\t}\n\tmdur = trak->Media->mediaHeader->duration;\n\tstts = trak->Media->information->sampleTable->TimeToSample;\n\tif (!stts->nb_entries) return GF_BAD_PARAM;\n\n\tif (is_patch) {\n\t\tu32 i, avg_dur, nb_samp=0;\n\t\tu64 cum_dur=0;\n\t\tfor (i=0; i<stts->nb_entries; i++) {\n\t\t\tent = (GF_SttsEntry*) &stts->entries[i];\n\t\t\tcum_dur += ent->sampleCount*ent->sampleDelta;\n\t\t\tnb_samp += ent->sampleCount;\n\t\t}\n\t\tif (cum_dur <= dur_num || !nb_samp) return GF_OK;\n\t\tavg_dur = (u32) (dur_num / nb_samp);\n\n\t\tfor (i=0; i<stts->nb_entries; i++) {\n\t\t\tent = (GF_SttsEntry*) &stts->entries[i];\n\t\t\tent->sampleDelta = avg_dur;\n\t\t}\n\t\tstts->w_LastDTS = dur_num - avg_dur;\n\t\treturn GF_OK;\n\t}\n\t//get the last entry\n\tent = (GF_SttsEntry*) &stts->entries[stts->nb_entries-1];\n\tif ((mode==1) && !duration && !dur_den) {\n\t\t//same as previous, nothing to adjust\n\t\tif (ent->sampleCount>1) return GF_OK;\n\t\tif (stts->nb_entries==1) return GF_OK;\n\t\tduration = stts->entries[stts->nb_entries-2].sampleDelta;\n\t}\n\n\tmdur -= ent->sampleDelta;\n\tmdur += duration;\n\n\t//we only have one sample\n\tif (ent->sampleCount == 1) {\n\t\tent->sampleDelta = (u32) duration;\n\t\tif (mode && (stts->nb_entries>1) && (stts->entries[stts->nb_entries-2].sampleDelta==duration)) {\n\t\t\tstts->entries[stts->nb_entries-2].sampleCount++;\n\t\t\tstts->nb_entries--;\n\t\t\t//and update the write cache\n\t\t\tstts->w_currentSampleNum = trak->Media->information->sampleTable->SampleSize->sampleCount;\n\t\t}\n\t} else {\n\t\tif (ent->sampleDelta == duration) return GF_OK;\n\t\tent->sampleCount -= 1;\n\n\t\tif (stts->nb_entries==stts->alloc_size) {\n\t\t\tstts->alloc_size++;\n\t\t\tstts->entries = (GF_SttsEntry*)gf_realloc(stts->entries, sizeof(GF_SttsEntry)*stts->alloc_size);\n\t\t\tif (!stts->entries) return GF_OUT_OF_MEM;\n\t\t}\n\t\tstts->entries[stts->nb_entries].sampleCount = 1;\n\t\tstts->entries[stts->nb_entries].sampleDelta = (u32) duration;\n\t\tstts->nb_entries++;\n\t\t//and update the write cache\n\t\tstts->w_currentSampleNum = trak->Media->information->sampleTable->SampleSize->sampleCount;\n\t}\n\tif (!movie->keep_utc)\n\t\ttrak->Media->mediaHeader->modificationTime = gf_isom_get_mp4time();\n\ttrak->Media->mediaHeader->duration = mdur;\n\treturn SetTrackDuration(trak);\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_last_sample_duration(GF_ISOFile *movie, u32 trackNumber, u32 duration)\n{\n\treturn gf_isom_set_last_sample_duration_internal(movie, trackNumber, duration, 0, 0);\n}\n\nGF_EXPORT\nGF_Err gf_isom_patch_last_sample_duration(GF_ISOFile *movie, u32 trackNumber, u64 next_dts)\n{\n\treturn gf_isom_set_last_sample_duration_internal(movie, trackNumber, next_dts, 0, 2);\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_last_sample_duration_ex(GF_ISOFile *movie, u32 trackNumber, u32 dur_num, u32 dur_den)\n{\n\treturn gf_isom_set_last_sample_duration_internal(movie, trackNumber, dur_num, dur_den, 1);\n}\n\n//update a sample data in the media. Note that the sample MUST exists\nGF_EXPORT\nGF_Err gf_isom_update_sample(GF_ISOFile *movie, u32 trackNumber, u32 sampleNumber, GF_ISOSample *sample, Bool data_only)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_EDIT);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\te = unpack_track(trak);\n\tif (e) return e;\n\n\t//block for hint tracks\n\tif (trak->Media->handler->handlerType == GF_ISOM_MEDIA_HINT) return GF_BAD_PARAM;\n\n\t//REWRITE ANY OD STUFF\n\tif (trak->Media->handler->handlerType == GF_ISOM_MEDIA_OD) {\n\t\tGF_ISOSample *od_sample = NULL;\n\t\te = Media_ParseODFrame(trak->Media, sample, &od_sample);\n\t\tif (!e) e = Media_UpdateSample(trak->Media, sampleNumber, od_sample, data_only);\n\t\tif (od_sample) gf_isom_sample_del(&od_sample);\n\t} else {\n\t\te = Media_UpdateSample(trak->Media, sampleNumber, sample, data_only);\n\t}\n\tif (e) return e;\n\tif (!movie->keep_utc)\n\t\ttrak->Media->mediaHeader->modificationTime = gf_isom_get_mp4time();\n\n\tgf_isom_disable_inplace_rewrite(movie);\n\treturn GF_OK;\n}\n\n//update a sample data in the media. Note that the sample MUST exists,\n//that sample->data MUST be NULL and sample->dataLength must be NON NULL;\nGF_EXPORT\nGF_Err gf_isom_update_sample_reference(GF_ISOFile *movie, u32 trackNumber, u32 sampleNumber, GF_ISOSample *sample, u64 data_offset)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_EDIT);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\t//block for hint tracks\n\tif (trak->Media->handler->handlerType == GF_ISOM_MEDIA_HINT) return GF_BAD_PARAM;\n\n\tif (!sampleNumber || !sample) return GF_BAD_PARAM;\n\n\te = unpack_track(trak);\n\tif (e) return e;\n\n\t//OD is not allowed as a data ref\n\tif (trak->Media->handler->handlerType == GF_ISOM_MEDIA_OD) {\n\t\treturn GF_BAD_PARAM;\n\t}\n\t//OK, update it\n\te = Media_UpdateSampleReference(trak->Media, sampleNumber, sample, data_offset);\n\tif (e) return e;\n\n\tif (!movie->keep_utc)\n\t\ttrak->Media->mediaHeader->modificationTime = gf_isom_get_mp4time();\n\treturn GF_OK;\n}\n\n\n//Remove a given sample\nGF_EXPORT\nGF_Err gf_isom_remove_sample(GF_ISOFile *movie, u32 trackNumber, u32 sampleNumber)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_EDIT);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !sampleNumber || (sampleNumber > trak->Media->information->sampleTable->SampleSize->sampleCount) )\n\t\treturn GF_BAD_PARAM;\n\n\t//block for hint tracks\n\tif (trak->Media->handler->handlerType == GF_ISOM_MEDIA_HINT) return GF_BAD_PARAM;\n\n\te = unpack_track(trak);\n\tif (e) return e;\n\t//do NOT change the order DTS, CTS, size chunk\n\n\t//remove DTS\n\te = stbl_RemoveDTS(trak->Media->information->sampleTable, sampleNumber, 1, trak->Media->mediaHeader->timeScale);\n\tif (e) return e;\n\t//remove CTS if any\n\tif (trak->Media->information->sampleTable->CompositionOffset) {\n\t\te = stbl_RemoveCTS(trak->Media->information->sampleTable, sampleNumber, 1);\n\t\tif (e) return e;\n\t}\n\t//remove size\n\te = stbl_RemoveSize(trak->Media->information->sampleTable, sampleNumber, 1);\n\tif (e) return e;\n\t//remove sampleToChunk and chunk\n\te = stbl_RemoveChunk(trak->Media->information->sampleTable, sampleNumber, 1);\n\tif (e) return e;\n\t//remove sync\n\tif (trak->Media->information->sampleTable->SyncSample) {\n\t\te = stbl_RemoveRAP(trak->Media->information->sampleTable, sampleNumber);\n\t\tif (e) return e;\n\t}\n\t//remove sample dep\n\tif (trak->Media->information->sampleTable->SampleDep) {\n\t\te = stbl_RemoveRedundant(trak->Media->information->sampleTable, sampleNumber, 1);\n\t\tif (e) return e;\n\t}\n\t//remove shadow\n\te = stbl_RemoveShadow(trak->Media->information->sampleTable, sampleNumber);\n\tif (e) return e;\n\n\t//remove padding\n\te = stbl_RemovePaddingBits(trak->Media->information->sampleTable, sampleNumber);\n\tif (e) return e;\n\n\te = stbl_RemoveSubSample(trak->Media->information->sampleTable, sampleNumber);\n\tif (e) return e;\n\n\te = stbl_RemoveSampleGroup(trak->Media->information->sampleTable, sampleNumber);\n\tif (e) return e;\n\n\tgf_isom_disable_inplace_rewrite(movie);\n\n\treturn SetTrackDuration(trak);\n}\n\n\nGF_EXPORT\nGF_Err gf_isom_set_final_name(GF_ISOFile *movie, char *filename)\n{\n\tGF_Err e;\n\tif (!movie ) return GF_BAD_PARAM;\n\n\t//if mode is not OPEN_EDIT file was created under the right name\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_EDIT);\n\tif (e) return e;\n\n\tif (filename) {\n\t\t//we don't allow file overwriting\n\t\tif ( (movie->openMode == GF_ISOM_OPEN_EDIT)\n\t\t        && movie->fileName && !strcmp(filename, movie->fileName))\n\t\t\treturn GF_BAD_PARAM;\n\t\tif (movie->finalName) gf_free(movie->finalName);\n\t\tmovie->finalName = gf_strdup(filename);\n\t\tif (!movie->finalName) return GF_OUT_OF_MEM;\n\t\tgf_isom_disable_inplace_rewrite(movie);\n\t}\n\treturn GF_OK;\n}\n\n//Add a system descriptor to the ESD of a stream(EDIT or WRITE mode only)\nGF_EXPORT\nGF_Err gf_isom_add_desc_to_description(GF_ISOFile *movie, u32 trackNumber, u32 StreamDescriptionIndex, const GF_Descriptor *theDesc)\n{\n\tGF_IPIPtr *ipiD;\n\tGF_Err e;\n\tu16 tmpRef;\n\tGF_TrackBox *trak;\n\tGF_Descriptor *desc;\n\tGF_ESD *esd;\n\tGF_TrackReferenceBox *tref;\n\tGF_TrackReferenceTypeBox *dpnd;\n\tGF_MPEGVisualSampleEntryBox *entry;\n\tu32 msubtype;\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\t/*GETS NATIVE DESCRIPTOR ONLY*/\n\te = Media_GetESD(trak->Media, StreamDescriptionIndex, &esd, GF_TRUE);\n\tif (e) return e;\n\n\tentry = gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, StreamDescriptionIndex-1);\n\tif (!entry) return GF_BAD_PARAM;\n\tmsubtype = entry->type;\n\tif ((msubtype==GF_ISOM_BOX_TYPE_ENCV) || (msubtype==GF_ISOM_BOX_TYPE_ENCA))\n\t\tgf_isom_get_original_format_type(movie, trackNumber, StreamDescriptionIndex, &msubtype);\n\n\t//duplicate the desc\n\te = gf_odf_desc_copy((GF_Descriptor *)theDesc, &desc);\n\tif (e) return e;\n\n\t//and add it to the ESD EXCEPT IPI PTR (we need to translate from ES_ID to TrackID!!!\n\tif (!movie->keep_utc)\n\t\ttrak->Media->mediaHeader->modificationTime = gf_isom_get_mp4time();\n\n\tswitch (desc->tag) {\n\tcase GF_ODF_IPI_PTR_TAG:\n\t\tgoto insertIPI;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif ((msubtype==GF_ISOM_BOX_TYPE_MP4S) || (msubtype==GF_ISOM_BOX_TYPE_MP4V) || (msubtype==GF_ISOM_BOX_TYPE_MP4A)) {\n\t\treturn gf_odf_desc_add_desc((GF_Descriptor *)esd, desc);\n\t}\n\n\tif (trak->Media->handler->handlerType!=GF_ISOM_MEDIA_VISUAL) {\n\t\tgf_odf_desc_del(desc);\n\t\treturn GF_NOT_SUPPORTED;\n\t}\n\tGF_MPEG4ExtensionDescriptorsBox *mdesc = (GF_MPEG4ExtensionDescriptorsBox *) gf_isom_box_find_child(entry->child_boxes, GF_ISOM_BOX_TYPE_M4DS);\n\tif (!mdesc) {\n\t\tmdesc = (GF_MPEG4ExtensionDescriptorsBox *) gf_isom_box_new_parent(&entry->child_boxes, GF_ISOM_BOX_TYPE_M4DS);\n\t}\n\treturn gf_list_add(mdesc->descriptors, desc);\n\ninsertIPI:\n\tif (esd->ipiPtr) {\n\t\tgf_odf_desc_del((GF_Descriptor *) esd->ipiPtr);\n\t\tesd->ipiPtr = NULL;\n\t}\n\n\tipiD = (GF_IPIPtr *) desc;\n\t//find a tref\n\tif (!trak->References) {\n\t\ttref = (GF_TrackReferenceBox *) gf_isom_box_new_parent(&trak->child_boxes, GF_ISOM_BOX_TYPE_TREF);\n\t\tif (!tref) return GF_OUT_OF_MEM;\n\t\te = trak_on_child_box((GF_Box*)trak, (GF_Box *)tref, GF_FALSE);\n\t\tif (e) return e;\n\t}\n\ttref = trak->References;\n\n\te = Track_FindRef(trak, GF_ISOM_REF_IPI, &dpnd);\n\tif (e) return e;\n\tif (!dpnd) {\n\t\ttmpRef = 0;\n\t\tdpnd = (GF_TrackReferenceTypeBox *) gf_isom_box_new_parent(&tref->child_boxes, GF_ISOM_BOX_TYPE_REFT);\n\t\tif (!dpnd) return GF_OUT_OF_MEM;\n\t\tdpnd->reference_type = GF_ISOM_BOX_TYPE_IPIR;\n\t\te = reftype_AddRefTrack(dpnd, ipiD->IPI_ES_Id, &tmpRef);\n\t\tif (e) return e;\n\t\t//and replace the tag and value...\n\t\tipiD->IPI_ES_Id = tmpRef;\n\t\tipiD->tag = GF_ODF_ISOM_IPI_PTR_TAG;\n\t} else {\n\t\t//Watch out! ONLY ONE IPI dependency is allowed per stream\n\t\tdpnd->trackIDCount = 1;\n\t\tdpnd->trackIDs[0] = ipiD->IPI_ES_Id;\n\t\t//and replace the tag and value...\n\t\tipiD->IPI_ES_Id = 1;\n\t\tipiD->tag = GF_ODF_ISOM_IPI_PTR_TAG;\n\t}\n\t//and add the desc to the esd...\n\treturn gf_odf_desc_add_desc((GF_Descriptor *)esd, desc);\n}\n\n\n//use carefully. Very useful when you made a lot of changes (IPMP, IPI, OCI, ...)\n//THIS WILL REPLACE THE WHOLE DESCRIPTOR ...\nGF_EXPORT\nGF_Err gf_isom_change_mpeg4_description(GF_ISOFile *movie, u32 trackNumber, u32 StreamDescriptionIndex, const GF_ESD *newESD)\n{\n\tGF_Err e;\n\tGF_ESD *esd;\n\tGF_TrackBox *trak;\n\tGF_SampleEntryBox *entry;\n\tGF_SampleDescriptionBox *stsd;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tstsd = trak->Media->information->sampleTable->SampleDescription;\n\tif (!stsd) return movie->LastError = GF_ISOM_INVALID_FILE;\n\n\tif (!StreamDescriptionIndex || StreamDescriptionIndex > gf_list_count(stsd->child_boxes)) {\n\t\treturn movie->LastError = GF_BAD_PARAM;\n\t}\n\tentry = (GF_SampleEntryBox *)gf_list_get(stsd->child_boxes, StreamDescriptionIndex - 1);\n\t//no support for generic sample entries (eg, no MPEG4 descriptor)\n\tif (entry == NULL) return GF_BAD_PARAM;\n\n\tif (!movie->keep_utc)\n\t\ttrak->Media->mediaHeader->modificationTime = gf_isom_get_mp4time();\n\t//duplicate our desc\n\te = gf_odf_desc_copy((GF_Descriptor *)newESD, (GF_Descriptor **)&esd);\n\tif (e) return e;\n\te = Track_SetStreamDescriptor(trak, StreamDescriptionIndex, entry->dataReferenceIndex, esd, NULL);\n\tif (e != GF_OK) {\n\t\tgf_odf_desc_del((GF_Descriptor *) esd);\n\t}\n\treturn e;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_visual_info(GF_ISOFile *movie, u32 trackNumber, u32 StreamDescriptionIndex, u32 Width, u32 Height)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\tGF_SampleEntryBox *entry;\n\tGF_SampleDescriptionBox *stsd;\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tstsd = trak->Media->information->sampleTable->SampleDescription;\n\tif (!stsd) {\n\t\treturn movie->LastError = GF_ISOM_INVALID_FILE;\n\t}\n\tif (!StreamDescriptionIndex || StreamDescriptionIndex > gf_list_count(stsd->child_boxes)) {\n\t\treturn movie->LastError = GF_BAD_PARAM;\n\t}\n\tentry = (GF_SampleEntryBox *)gf_list_get(stsd->child_boxes, StreamDescriptionIndex - 1);\n\t//no support for generic sample entries (eg, no MPEG4 descriptor)\n\tif (entry == NULL) return GF_BAD_PARAM;\n\tif (!movie->keep_utc)\n\t\ttrak->Media->mediaHeader->modificationTime = gf_isom_get_mp4time();\n\n\t//valid for MPEG visual, JPG and 3GPP H263\n\tif (entry->internal_type == GF_ISOM_SAMPLE_ENTRY_VIDEO) {\n\t\t((GF_VisualSampleEntryBox*)entry)->Width = Width;\n\t\t((GF_VisualSampleEntryBox*)entry)->Height = Height;\n\t\ttrak->Header->width = Width<<16;\n\t\ttrak->Header->height = Height<<16;\n\t\treturn GF_OK;\n\t} else if (trak->Media->handler->handlerType==GF_ISOM_MEDIA_SCENE) {\n\t\ttrak->Header->width = Width<<16;\n\t\ttrak->Header->height = Height<<16;\n\t\treturn GF_OK;\n\t} else {\n\t\treturn GF_BAD_PARAM;\n\t}\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_visual_bit_depth(GF_ISOFile *movie, u32 trackNumber, u32 StreamDescriptionIndex, u16 bitDepth)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\tGF_MPEGVisualSampleEntryBox *entry;\n\tGF_SampleDescriptionBox *stsd;\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tswitch (trak->Media->handler->handlerType) {\n\tcase GF_ISOM_MEDIA_VISUAL:\n\tcase GF_ISOM_MEDIA_PICT:\n\tcase GF_ISOM_MEDIA_AUXV:\n\t\tbreak;\n\tdefault:\n\t\treturn GF_OK;\n\t}\n\n\tstsd = trak->Media->information->sampleTable->SampleDescription;\n\tif (!stsd) {\n\t\treturn movie->LastError = GF_ISOM_INVALID_FILE;\n\t}\n\tif (!StreamDescriptionIndex || StreamDescriptionIndex > gf_list_count(stsd->child_boxes)) {\n\t\treturn movie->LastError = GF_BAD_PARAM;\n\t}\n\tentry = (GF_MPEGVisualSampleEntryBox *)gf_list_get(stsd->child_boxes, StreamDescriptionIndex - 1);\n\t//no support for generic sample entries (eg, no MPEG4 descriptor)\n\tif (entry == NULL) return GF_BAD_PARAM;\n\tentry->bit_depth = bitDepth;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_pixel_aspect_ratio(GF_ISOFile *movie, u32 trackNumber, u32 StreamDescriptionIndex, s32 hSpacing, s32 vSpacing, Bool force_par)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\tGF_SampleEntryBox *entry;\n\tGF_SampleDescriptionBox *stsd;\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tstsd = trak->Media->information->sampleTable->SampleDescription;\n\tif (!stsd) return movie->LastError = GF_ISOM_INVALID_FILE;\n\tif (!StreamDescriptionIndex || StreamDescriptionIndex > gf_list_count(stsd->child_boxes)) {\n\t\treturn movie->LastError = GF_BAD_PARAM;\n\t}\n\tentry = (GF_SampleEntryBox *)gf_list_get(stsd->child_boxes, StreamDescriptionIndex - 1);\n\t//no support for generic sample entries (eg, no MPEG4 descriptor)\n\tif (entry == NULL) return GF_BAD_PARAM;\n\tif (!movie->keep_utc)\n\t\ttrak->Media->mediaHeader->modificationTime = gf_isom_get_mp4time();\n\n\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_VIDEO) return GF_BAD_PARAM;\n\n\tGF_PixelAspectRatioBox *pasp = (GF_PixelAspectRatioBox *) gf_isom_box_find_child(entry->child_boxes, GF_ISOM_BOX_TYPE_PASP);\n\tif (!hSpacing || !vSpacing || ((hSpacing == vSpacing) && !force_par))  {\n\t\tif (pasp) gf_isom_box_del_parent(&entry->child_boxes, (GF_Box *)pasp);\n\t\treturn GF_OK;\n\t}\n\tif (!pasp) {\n\t\tpasp = (GF_PixelAspectRatioBox*)gf_isom_box_new_parent(&entry->child_boxes, GF_ISOM_BOX_TYPE_PASP);\n\t\tif (!pasp) return GF_OUT_OF_MEM;\n\t}\n\tpasp->hSpacing = (u32) hSpacing;\n\tpasp->vSpacing = (u32) vSpacing;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_visual_color_info(GF_ISOFile *movie, u32 trackNumber, u32 StreamDescriptionIndex, u32 colour_type, u16 colour_primaries, u16 transfer_characteristics, u16 matrix_coefficients, Bool full_range_flag, u8 *icc_data, u32 icc_size)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\tGF_SampleEntryBox *entry;\n\tGF_SampleDescriptionBox *stsd;\n\tGF_ColourInformationBox *clr=NULL;\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tstsd = trak->Media->information->sampleTable->SampleDescription;\n\tif (!stsd) return movie->LastError = GF_ISOM_INVALID_FILE;\n\tif (!StreamDescriptionIndex || StreamDescriptionIndex > gf_list_count(stsd->child_boxes)) {\n\t\treturn movie->LastError = GF_BAD_PARAM;\n\t}\n\tentry = (GF_SampleEntryBox *)gf_list_get(stsd->child_boxes, StreamDescriptionIndex - 1);\n\t//no support for generic sample entries (eg, no MPEG4 descriptor)\n\tif (entry == NULL) return GF_BAD_PARAM;\n\tif (!movie->keep_utc)\n\t\ttrak->Media->mediaHeader->modificationTime = gf_isom_get_mp4time();\n\n\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_VIDEO) return GF_OK;\n\n\tclr = (GF_ColourInformationBox *) gf_isom_box_find_child(entry->child_boxes, GF_ISOM_BOX_TYPE_COLR);\n\tif (!colour_type) {\n\t\tif (clr) gf_isom_box_del_parent(&entry->child_boxes, (GF_Box *)clr);\n\t\treturn GF_OK;\n\t}\n\tif (!clr) {\n\t\tclr = (GF_ColourInformationBox*)gf_isom_box_new_parent(&entry->child_boxes, GF_ISOM_BOX_TYPE_COLR);\n\t\tif (!clr) return GF_OUT_OF_MEM;\n\t}\n\tclr->colour_type = colour_type;\n\tclr->colour_primaries = colour_primaries;\n\tclr->transfer_characteristics = transfer_characteristics;\n\tclr->matrix_coefficients = matrix_coefficients;\n\tclr->full_range_flag = full_range_flag;\n\tif (clr->opaque) gf_free(clr->opaque);\n\tclr->opaque = NULL;\n\tclr->opaque_size = 0;\n\tif ((colour_type==GF_ISOM_SUBTYPE_RICC) || (colour_type==GF_ISOM_SUBTYPE_PROF)) {\n\t\tclr->opaque_size = icc_data ? icc_size : 0;\n\t\tif (clr->opaque_size) {\n\t\t\tclr->opaque = gf_malloc(sizeof(char)*clr->opaque_size);\n\t\t\tif (!clr->opaque) return GF_OUT_OF_MEM;\n\t\t\tmemcpy(clr->opaque, icc_data, sizeof(char)*clr->opaque_size);\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_dolby_vision_profile(GF_ISOFile* movie, u32 trackNumber, u32 StreamDescriptionIndex, u32 dv_profile)\n{\n\tGF_Err e;\n\tGF_TrackBox* trak;\n\tGF_SampleEntryBox* entry;\n\tGF_SampleDescriptionBox* stsd;\n\tGF_DOVIConfigurationBox* dovi = NULL;\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tstsd = trak->Media->information->sampleTable->SampleDescription;\n\tif (!stsd) return movie->LastError = GF_ISOM_INVALID_FILE;\n\tif (!StreamDescriptionIndex || StreamDescriptionIndex > gf_list_count(stsd->child_boxes)) {\n\t\treturn movie->LastError = GF_BAD_PARAM;\n\t}\n\tentry = (GF_SampleEntryBox*)gf_list_get(stsd->child_boxes, StreamDescriptionIndex - 1);\n\t//no support for generic sample entries (eg, no MPEG4 descriptor)\n\tif (entry == NULL) return GF_BAD_PARAM;\n\tif (!movie->keep_utc)\n\t\ttrak->Media->mediaHeader->modificationTime = gf_isom_get_mp4time();\n\n\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_VIDEO) return GF_OK;\n\n\tdovi = ((GF_MPEGVisualSampleEntryBox*)entry)->dovi_config;\n\tif (!dv_profile) {\n\t\tif (dovi) gf_isom_box_del((GF_Box*)dovi);\n\t\t((GF_MPEGVisualSampleEntryBox*)entry)->dovi_config = NULL;\n\t\treturn GF_OK;\n\t}\n\tif (!dovi) {\n\t\tdovi = (GF_DOVIConfigurationBox*)gf_isom_box_new_parent(&entry->child_boxes, GF_ISOM_BOX_TYPE_DVCC);\n\t\tif (!dovi) return GF_OUT_OF_MEM;\n\t\t((GF_MPEGVisualSampleEntryBox*)entry)->dovi_config = dovi;\n\t}\n\tentry->type = GF_ISOM_BOX_TYPE_DVHE;\n\tdovi->DOVIConfig.dv_profile = dv_profile;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_high_dynamic_range_info(GF_ISOFile* movie, u32 trackNumber, u32 StreamDescriptionIndex, GF_MasteringDisplayColourVolumeInfo* mdcv, GF_ContentLightLevelInfo* clli)\n{\n\tGF_Err e;\n\tGF_TrackBox* trak;\n\tGF_SampleEntryBox* entry;\n\tGF_SampleDescriptionBox* stsd;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tstsd = trak->Media->information->sampleTable->SampleDescription;\n\tif (!stsd) return movie->LastError = GF_ISOM_INVALID_FILE;\n\tif (!StreamDescriptionIndex || StreamDescriptionIndex > gf_list_count(stsd->child_boxes)) {\n\t\treturn movie->LastError = GF_BAD_PARAM;\n\t}\n\tentry = (GF_SampleEntryBox*)gf_list_get(stsd->child_boxes, StreamDescriptionIndex - 1);\n\t//no support for generic sample entries (eg, no MPEG4 descriptor)\n\tif (entry == NULL) return GF_BAD_PARAM;\n\tif (!movie->keep_utc)\n\t\ttrak->Media->mediaHeader->modificationTime = gf_isom_get_mp4time();\n\n\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_VIDEO) return GF_BAD_PARAM;\n\n\tGF_MasteringDisplayColourVolumeBox *mdcvb = (GF_MasteringDisplayColourVolumeBox *) gf_isom_box_find_child(entry->child_boxes, GF_ISOM_BOX_TYPE_MDCV);\n\tif (!mdcvb) {\n\t\tmdcvb = (GF_MasteringDisplayColourVolumeBox*)gf_isom_box_new_parent(&entry->child_boxes, GF_ISOM_BOX_TYPE_MDCV);\n\t\tif (!mdcvb) return GF_OUT_OF_MEM;\n\t}\n\tmdcvb->mdcv = *mdcv;\n\n\t/*clli*/\n\tGF_ContentLightLevelBox *cllib = (GF_ContentLightLevelBox *)gf_isom_box_find_child(entry->child_boxes, GF_ISOM_BOX_TYPE_CLLI);\n\tif (!cllib) {\n\t\tcllib = (GF_ContentLightLevelBox*)gf_isom_box_new_parent(&entry->child_boxes, GF_ISOM_BOX_TYPE_CLLI);\n\t\tif (!cllib) return GF_OUT_OF_MEM;\n\t}\n\tcllib->clli = *clli;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_clean_aperture(GF_ISOFile *movie, u32 trackNumber, u32 StreamDescriptionIndex, u32 cleanApertureWidthN, u32 cleanApertureWidthD, u32 cleanApertureHeightN, u32 cleanApertureHeightD, u32 horizOffN, u32 horizOffD, u32 vertOffN, u32 vertOffD)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\tGF_SampleEntryBox *entry;\n\tGF_SampleDescriptionBox *stsd;\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tstsd = trak->Media->information->sampleTable->SampleDescription;\n\tif (!stsd) return movie->LastError = GF_ISOM_INVALID_FILE;\n\tif (!StreamDescriptionIndex || StreamDescriptionIndex > gf_list_count(stsd->child_boxes)) {\n\t\treturn movie->LastError = GF_BAD_PARAM;\n\t}\n\tentry = (GF_SampleEntryBox *)gf_list_get(stsd->child_boxes, StreamDescriptionIndex - 1);\n\t//no support for generic sample entries (eg, no MPEG4 descriptor)\n\tif (entry == NULL) return GF_BAD_PARAM;\n\tif (!movie->keep_utc)\n\t\ttrak->Media->mediaHeader->modificationTime = gf_isom_get_mp4time();\n\n\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_VIDEO) return GF_BAD_PARAM;\n\n\tGF_CleanApertureBox *clap = (GF_CleanApertureBox *)gf_isom_box_find_child(entry->child_boxes, GF_ISOM_BOX_TYPE_CLAP);\n\tif (!cleanApertureHeightD || !cleanApertureWidthD || !horizOffD || !vertOffD) {\n\t\tif (clap) gf_isom_box_del_parent(&entry->child_boxes, (GF_Box*)clap);\n\t\treturn GF_OK;\n\t}\n\tif (!clap) {\n\t\tclap = (GF_CleanApertureBox*)gf_isom_box_new_parent(&entry->child_boxes, GF_ISOM_BOX_TYPE_CLAP);\n\t\tif (!clap) return GF_OUT_OF_MEM;\n\t}\n\n\tclap->cleanApertureWidthN = cleanApertureWidthN;\n\tclap->cleanApertureWidthD = cleanApertureWidthD;\n\tclap->cleanApertureHeightN = cleanApertureHeightN;\n\tclap->cleanApertureHeightD = cleanApertureHeightD;\n\tclap->horizOffN = horizOffN;\n\tclap->horizOffD = horizOffD;\n\tclap->vertOffN = vertOffN;\n\tclap->vertOffD = vertOffD;\n\treturn GF_OK;\n}\n\n#include <gpac/maths.h>\nGF_Err gf_isom_update_aperture_info(GF_ISOFile *movie, u32 trackNumber, Bool remove)\n{\n\tGF_Err e;\n\tGF_Box *box, *enof, *prof, *clef;\n\tGF_TrackBox *trak;\n\tGF_VisualSampleEntryBox *ventry;\n\tGF_PixelAspectRatioBox *pasp;\n\tGF_CleanApertureBox *clap;\n\tu32 j, hspacing, vspacing, clap_width_num, clap_width_den, clap_height_num, clap_height_den, high, low;\n\tDouble width, height;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tif (remove) {\n\t\tif (trak->Aperture) {\n\t\t\tgf_isom_box_del(trak->Aperture);\n\t\t\ttrak->Aperture = NULL;\n\t\t}\n\t\treturn GF_OK;\n\t}\n\tenof = prof = clef = NULL;\n\tif (!trak->Aperture) {\n\t\ttrak->Aperture = gf_isom_box_new_parent(&trak->child_boxes, GF_QT_BOX_TYPE_TAPT);\n\t\tif (!trak->Aperture) return GF_OUT_OF_MEM;\n\t}\n\tif (!trak->Aperture->child_boxes) {\n\t\ttrak->Aperture->child_boxes = gf_list_new();\n\t\tif (!trak->Aperture->child_boxes)\n\t\t\treturn GF_OUT_OF_MEM;\n\t}\n\n\tj=0;\n\twhile ( (box = gf_list_enum(trak->Aperture->child_boxes, &j))) {\n\t\tswitch (box->type) {\n\t\tcase GF_QT_BOX_TYPE_CLEF: clef = box; break;\n\t\tcase GF_QT_BOX_TYPE_PROF: prof = box; break;\n\t\tcase GF_QT_BOX_TYPE_ENOF: enof = box; break;\n\t\t}\n\t}\n\tif (!clef) {\n\t\tclef = gf_isom_box_new(GF_QT_BOX_TYPE_CLEF);\n\t\tif (!clef) return GF_OUT_OF_MEM;\n\t\tgf_list_add(trak->Aperture->child_boxes, clef);\n\t}\n\tif (!enof) {\n\t\tenof = gf_isom_box_new(GF_QT_BOX_TYPE_ENOF);\n\t\tif (!enof) return GF_OUT_OF_MEM;\n\t\tgf_list_add(trak->Aperture->child_boxes, enof);\n\t}\n\tif (!prof) {\n\t\tprof = gf_isom_box_new(GF_QT_BOX_TYPE_PROF);\n\t\tif (!prof) return GF_OUT_OF_MEM;\n\t\tgf_list_add(trak->Aperture->child_boxes, prof);\n\t}\n\n\tventry = (GF_VisualSampleEntryBox *)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, 0);\n\t//no support for generic sample entries (eg, no MPEG4 descriptor)\n\tif (ventry == NULL) return GF_BAD_PARAM;\n\tif (!movie->keep_utc)\n\t\ttrak->Media->mediaHeader->modificationTime = gf_isom_get_mp4time();\n\n\tif (ventry->internal_type != GF_ISOM_SAMPLE_ENTRY_VIDEO) return GF_BAD_PARAM;\n\n\tpasp = (GF_PixelAspectRatioBox *) gf_isom_box_find_child(ventry->child_boxes, GF_ISOM_BOX_TYPE_PASP);\n\thspacing = vspacing = 0;\n\tif (pasp) {\n\t\thspacing = pasp->hSpacing;\n\t\tvspacing = pasp->vSpacing;\n\t}\n\tclap_width_num = ventry->Width;\n\tclap_width_den = 1;\n\tclap_height_num = ventry->Height;\n\tclap_height_den = 1;\n\tclap = (GF_CleanApertureBox *) gf_isom_box_find_child(ventry->child_boxes, GF_ISOM_BOX_TYPE_CLAP);\n\tif (clap) {\n\t\tclap_width_num = clap->cleanApertureWidthN;\n\t\tclap_width_den = clap->cleanApertureWidthD;\n\t\tclap_height_num = clap->cleanApertureHeightN;\n\t\tclap_height_den = clap->cleanApertureHeightD;\n\t}\n\t//enof: encoded pixels in 16.16\n\t((GF_ApertureBox *)enof)->width = (ventry->Width)<<16;\n\t((GF_ApertureBox *)enof)->height = (ventry->Height)<<16;\n\n\t//prof: encoded pixels + pasp in 16.16\n\twidth = (Float) (ventry->Width * hspacing);\n\twidth /= vspacing;\n\thigh = (u32) floor((Float)width);\n\tlow = (u32) ( 0xFFFF * (width - (Double)high) );\n\t((GF_ApertureBox *)prof)->width = (high)<<16 | low;\n\t((GF_ApertureBox *)prof)->height = (ventry->Height)<<16;\n\n\t//clef: encoded pixels + pasp + clap in 16.16\n\twidth = (Double) (clap_width_num * hspacing);\n\twidth /= clap_width_den * vspacing;\n\theight = (Float) clap_height_num;\n\theight /= clap_height_den;\n\n\thigh = (u32) floor((Float)width);\n\tlow = (u32) (0xFFFF * (width - (Double)high));\n\t((GF_ApertureBox *)clef)->width = (high)<<16 | low;\n\thigh = (u32) floor((Float)height);\n\tlow = (u32) (0xFFFF * (height - (Double)high));\n\t((GF_ApertureBox *)clef)->height = (high)<<16 | low;\n\n\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_image_sequence_coding_constraints(GF_ISOFile *movie, u32 trackNumber, u32 StreamDescriptionIndex, Bool remove, Bool all_ref_pics_intra, Bool intra_pred_used, u32 max_ref_per_pic)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\tGF_SampleEntryBox *entry;\n\tGF_SampleDescriptionBox *stsd;\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tstsd = trak->Media->information->sampleTable->SampleDescription;\n\tif (!stsd) return movie->LastError = GF_ISOM_INVALID_FILE;\n\tif (!StreamDescriptionIndex || StreamDescriptionIndex > gf_list_count(stsd->child_boxes)) {\n\t\treturn movie->LastError = GF_BAD_PARAM;\n\t}\n\tentry = (GF_SampleEntryBox *)gf_list_get(stsd->child_boxes, StreamDescriptionIndex - 1);\n\t//no support for generic sample entries (eg, no MPEG4 descriptor)\n\tif (entry == NULL) return GF_BAD_PARAM;\n\tif (!movie->keep_utc)\n\t\ttrak->Media->mediaHeader->modificationTime = gf_isom_get_mp4time();\n\n\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_VIDEO) return GF_BAD_PARAM;\n\n\tGF_CodingConstraintsBox*ccst = (GF_CodingConstraintsBox*) gf_isom_box_find_child(entry->child_boxes, GF_ISOM_BOX_TYPE_CCST);\n\tif (remove)  {\n\t\tif (ccst) gf_isom_box_del_parent(&entry->child_boxes, (GF_Box*)ccst);\n\t\treturn GF_OK;\n\t}\n\tif (!ccst) {\n\t\tccst = (GF_CodingConstraintsBox*)gf_isom_box_new_parent(&entry->child_boxes, GF_ISOM_BOX_TYPE_CCST);\n\t\tif (!ccst) return GF_OUT_OF_MEM;\n\t}\n\tccst->all_ref_pics_intra = all_ref_pics_intra;\n\tccst->intra_pred_used = intra_pred_used;\n\tccst->max_ref_per_pic = max_ref_per_pic;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_image_sequence_alpha(GF_ISOFile *movie, u32 trackNumber, u32 StreamDescriptionIndex, Bool remove)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\tGF_SampleEntryBox *entry;\n\tGF_SampleDescriptionBox *stsd;\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tstsd = trak->Media->information->sampleTable->SampleDescription;\n\tif (!stsd) return movie->LastError = GF_ISOM_INVALID_FILE;\n\tif (!StreamDescriptionIndex || StreamDescriptionIndex > gf_list_count(stsd->child_boxes)) {\n\t\treturn movie->LastError = GF_BAD_PARAM;\n\t}\n\tentry = (GF_SampleEntryBox *)gf_list_get(stsd->child_boxes, StreamDescriptionIndex - 1);\n\t//no support for generic sample entries (eg, no MPEG4 descriptor)\n\tif (entry == NULL) return GF_BAD_PARAM;\n\tif (!movie->keep_utc)\n\t\ttrak->Media->mediaHeader->modificationTime = gf_isom_get_mp4time();\n\n\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_VIDEO) return GF_BAD_PARAM;\n\n\tGF_AuxiliaryTypeInfoBox *auxi = (GF_AuxiliaryTypeInfoBox *)gf_isom_box_find_child(entry->child_boxes, GF_ISOM_BOX_TYPE_AUXI);\n\tif (remove)  {\n\t\tif (auxi) gf_isom_box_del_parent(&entry->child_boxes, (GF_Box*)auxi);\n\t\treturn GF_OK;\n\t}\n\tif (!auxi) {\n\t\tauxi = (GF_AuxiliaryTypeInfoBox*)gf_isom_box_new_parent(&entry->child_boxes, GF_ISOM_BOX_TYPE_AUXI);\n\t\tif (!auxi) return GF_OUT_OF_MEM;\n\t}\n\tauxi->aux_track_type = gf_strdup(\"urn:mpeg:mpegB:cicp:systems:auxiliary:alpha\");\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_audio_info(GF_ISOFile *movie, u32 trackNumber, u32 StreamDescriptionIndex, u32 sampleRate, u32 nbChannels, u8 bitsPerSample, GF_AudioSampleEntryImportMode asemode)\n{\n\tGF_Err e;\n\tu32 i, old_qtff_mode=GF_ISOM_AUDIO_QTFF_NONE;\n\tGF_TrackBox *trak;\n\tGF_SampleEntryBox *entry;\n\tGF_AudioSampleEntryBox*aud_entry;\n\tGF_SampleDescriptionBox *stsd;\n\tGF_Box *wave_box = NULL;\n\tGF_Box *gf_isom_audio_sample_get_audio_codec_cfg_box(GF_AudioSampleEntryBox *ptr);\n\tGF_Box *codec_ext = NULL;\n#if 0\n\tGF_ChannelLayoutInfoBox *chan=NULL;\n#endif\n\tGF_OriginalFormatBox *frma=NULL;\n\tGF_ChromaInfoBox *enda=NULL;\n\tGF_ESDBox *esds=NULL;\n\tGF_Box *terminator=NULL;\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tstsd = trak->Media->information->sampleTable->SampleDescription;\n\tif (!stsd) {\n\t\treturn movie->LastError = GF_ISOM_INVALID_FILE;\n\t}\n\tif (!StreamDescriptionIndex || StreamDescriptionIndex > gf_list_count(stsd->child_boxes)) {\n\t\treturn movie->LastError = GF_BAD_PARAM;\n\t}\n\tentry = (GF_SampleEntryBox *)gf_list_get(stsd->child_boxes, StreamDescriptionIndex - 1);\n\t//no support for generic sample entries (eg, no MPEG4 descriptor)\n\tif (entry == NULL) return GF_BAD_PARAM;\n\tif (!movie->keep_utc)\n\t\ttrak->Media->mediaHeader->modificationTime = gf_isom_get_mp4time();\n\n\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_AUDIO) return GF_BAD_PARAM;\n\taud_entry = (GF_AudioSampleEntryBox*) entry;\n\n\tif (entry->type==GF_ISOM_BOX_TYPE_MLPA) {\n\t\taud_entry->samplerate_hi = sampleRate>>16;\n\t\taud_entry->samplerate_lo = sampleRate & 0x0000FFFF;\n\t} else {\n\t\taud_entry->samplerate_hi = sampleRate;\n\t\taud_entry->samplerate_lo = 0;\n\t}\n\taud_entry->bitspersample = bitsPerSample;\n\n\tswitch (asemode) {\n\tcase GF_IMPORT_AUDIO_SAMPLE_ENTRY_v0_2:\n\t\tstsd->version = 0;\n\t\taud_entry->version = 0;\n\t\taud_entry->qtff_mode = GF_ISOM_AUDIO_QTFF_NONE;\n\t\taud_entry->channel_count = 2;\n\t\tbreak;\n\tcase GF_IMPORT_AUDIO_SAMPLE_ENTRY_NOT_SET:\n\tcase GF_IMPORT_AUDIO_SAMPLE_ENTRY_v0_BS:\n\t\tstsd->version = 0;\n\t\taud_entry->version = 0;\n\t\taud_entry->qtff_mode = GF_ISOM_AUDIO_QTFF_NONE;\n\t\taud_entry->channel_count = nbChannels;\n\t\tbreak;\n\tcase GF_IMPORT_AUDIO_SAMPLE_ENTRY_v1_MPEG:\n\t\tstsd->version = 1;\n\t\taud_entry->version = 1;\n\t\taud_entry->qtff_mode = GF_ISOM_AUDIO_QTFF_NONE;\n\t\taud_entry->channel_count = nbChannels;\n\t\tbreak;\n\tcase GF_IMPORT_AUDIO_SAMPLE_ENTRY_v1_QTFF:\n\t\tstsd->version = 0;\n\t\taud_entry->version = 1;\n\t\taud_entry->channel_count = nbChannels;\n\t\told_qtff_mode = aud_entry->qtff_mode;\n\t\tif (aud_entry->qtff_mode != GF_ISOM_AUDIO_QTFF_ON_EXT_VALID)\n\t\t\taud_entry->qtff_mode = GF_ISOM_AUDIO_QTFF_ON_NOEXT;\n\t\tbreak;\n\t}\n\n\taud_entry->compression_id = 0;\n\n\t//check for wave+children and chan for QTFF or remove them for isobmff\n\tfor (i=0; i<gf_list_count(aud_entry->child_boxes); i++) {\n\t\tGF_Box *b = gf_list_get(aud_entry->child_boxes, i);\n\t\tif ((b->type != GF_QT_BOX_TYPE_WAVE) && (b->type != GF_QT_BOX_TYPE_CHAN) ) continue;\n\t\tif (asemode==GF_IMPORT_AUDIO_SAMPLE_ENTRY_v1_QTFF) {\n\t\t\tif (b->type == GF_QT_BOX_TYPE_WAVE) wave_box = b;\n#if 0\n\t\t\telse chan = (GF_ChannelLayoutInfoBox *)b;\n#endif\n\n\t\t} else {\n\t\t\tgf_isom_box_del_parent(&aud_entry->child_boxes, b);\n\t\t\ti--;\n\t\t}\n\t}\n\n\t//TODO: insert channelLayout for ISOBMFF\n\tif (asemode!=GF_IMPORT_AUDIO_SAMPLE_ENTRY_v1_QTFF) return GF_OK;\n\n\tif (aud_entry->type==GF_ISOM_BOX_TYPE_MP4A)\n\t\taud_entry->compression_id = -2;\n\n\tif (!aud_entry->child_boxes) aud_entry->child_boxes = gf_list_new();\n\n#if 0\n\tif (!chan) {\n\t\tchan = (GF_ChannelLayoutInfoBox *) gf_isom_box_new_parent(&aud_entry->child_boxes, GF_QT_BOX_TYPE_CHAN);\n\t}\n\t//TODO, proper channel mapping\n\tchan->layout_tag = (nbChannels==2) ? 6750210 : 6553601;\n#endif\n\n\tcodec_ext = gf_isom_audio_sample_get_audio_codec_cfg_box((GF_AudioSampleEntryBox *)aud_entry);\n\tif (!codec_ext) return GF_OK;\n\n\tif (!wave_box) {\n\t\twave_box = gf_isom_box_new_parent(&aud_entry->child_boxes, GF_QT_BOX_TYPE_WAVE);\n\t}\n\n\tfor (i=0; i<gf_list_count(wave_box->child_boxes); i++) {\n\t\tGF_Box *b = gf_list_get(wave_box->child_boxes, i);\n\t\tswitch (b->type) {\n\t\tcase GF_QT_BOX_TYPE_ENDA:\n\t\t\tenda = (GF_ChromaInfoBox *)b;\n\t\t\tbreak;\n\t\tcase GF_QT_BOX_TYPE_FRMA:\n\t\t\tfrma = (GF_OriginalFormatBox *)b;\n\t\t\tbreak;\n\t\tcase GF_ISOM_BOX_TYPE_ESDS:\n\t\t\tesds = (GF_ESDBox *)b;\n\t\t\tbreak;\n\t\tcase GF_ISOM_BOX_TYPE_UNKNOWN:\n\t\t\tif ( ((GF_UnknownBox*)b)->original_4cc == 0)\n\t\t\t\tterminator = b;\n\t\t\tbreak;\n\t\tcase 0:\n\t\t\tterminator = b;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!wave_box->child_boxes) wave_box->child_boxes = gf_list_new();\n\n\t//do not use new_parent, we do this manually to ensure the order\n\taud_entry->qtff_mode = old_qtff_mode ? old_qtff_mode : GF_ISOM_AUDIO_QTFF_ON_NOEXT;\n\tif (!frma) {\n\t\tfrma = (GF_OriginalFormatBox *)gf_isom_box_new(GF_QT_BOX_TYPE_FRMA);\n\t} else {\n\t\tgf_list_del_item(wave_box->child_boxes, frma);\n\t}\n\tgf_list_add(wave_box->child_boxes, frma);\n\n\tif (esds) gf_list_del_item(wave_box->child_boxes, esds);\n\tif (!esds && (aud_entry->type==GF_ISOM_BOX_TYPE_MP4A) && ((GF_MPEGAudioSampleEntryBox*)aud_entry)->esd) {\n\t\tgf_list_del_item(entry->child_boxes, (GF_Box *) ((GF_MPEGAudioSampleEntryBox*)aud_entry)->esd);\n\t\tgf_list_add(wave_box->child_boxes, (GF_Box *) ((GF_MPEGAudioSampleEntryBox*)aud_entry)->esd);\n\t}\n\n\tif (!enda) {\n\t\tenda = (GF_ChromaInfoBox *)gf_isom_box_new(GF_QT_BOX_TYPE_ENDA);\n\t} else {\n\t\tgf_list_del_item(wave_box->child_boxes, enda);\n\t}\n\tenda->chroma=1;\n\tgf_list_add(wave_box->child_boxes, enda);\n\n\tif (!terminator) {\n\t\tterminator = gf_isom_box_new(0);\n\t} else {\n\t\tgf_list_del_item(wave_box->child_boxes, terminator);\n\t}\n\tgf_list_add(wave_box->child_boxes, terminator);\n\n\tif (aud_entry->type==GF_ISOM_BOX_TYPE_GNRA) {\n\t\tfrma->data_format = ((GF_GenericAudioSampleEntryBox*) aud_entry)->EntryType;\n\t} else {\n\t\tfrma->data_format = aud_entry->type;\n\t}\n\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_audio_layout(GF_ISOFile *movie, u32 trackNumber, u32 sampleDescriptionIndex, GF_AudioChannelLayout *layout)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\tGF_SampleEntryBox *entry;\n\tGF_AudioSampleEntryBox*aud_entry;\n\tGF_SampleDescriptionBox *stsd;\n\tGF_ChannelLayoutBox *chnl;\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tstsd = trak->Media->information->sampleTable->SampleDescription;\n\tif (!stsd) {\n\t\treturn movie->LastError = GF_ISOM_INVALID_FILE;\n\t}\n\tif (!sampleDescriptionIndex || sampleDescriptionIndex > gf_list_count(stsd->child_boxes)) {\n\t\treturn movie->LastError = GF_BAD_PARAM;\n\t}\n\tentry = (GF_SampleEntryBox *)gf_list_get(stsd->child_boxes, sampleDescriptionIndex - 1);\n\t//no support for generic sample entries (eg, no MPEG4 descriptor)\n\tif (entry == NULL) return GF_BAD_PARAM;\n\tif (!movie->keep_utc)\n\t\ttrak->Media->mediaHeader->modificationTime = gf_isom_get_mp4time();\n\n\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_AUDIO) return GF_BAD_PARAM;\n\taud_entry = (GF_AudioSampleEntryBox*) entry;\n\tif (aud_entry->qtff_mode) {\n\t\tu32 sr = aud_entry->samplerate_hi;\n\t\tif (aud_entry->type==GF_ISOM_BOX_TYPE_MLPA) {\n\t\t\tsr <<= 16;\n\t\t\tsr |= aud_entry->samplerate_lo;\n\t\t}\n\t\te = gf_isom_set_audio_info(movie, trackNumber, sampleDescriptionIndex, sr, aud_entry->channel_count, (u8) aud_entry->bitspersample, GF_IMPORT_AUDIO_SAMPLE_ENTRY_v1_MPEG);\n\t\tif (e) return e;\n\t}\n\tchnl = (GF_ChannelLayoutBox *) gf_isom_box_find_child(aud_entry->child_boxes, GF_ISOM_BOX_TYPE_CHNL);\n\tif (!chnl) {\n\t\tchnl = (GF_ChannelLayoutBox *)gf_isom_box_new_parent(&aud_entry->child_boxes, GF_ISOM_BOX_TYPE_CHNL);\n\t\tif (!chnl) return GF_OUT_OF_MEM;\n\t}\n\taud_entry->channel_count = layout->channels_count;\n\tmemcpy(&chnl->layout, layout, sizeof(GF_AudioChannelLayout));\n\treturn GF_OK;\n}\n\n//set the storage mode of a file (FLAT, STREAMABLE, INTERLEAVED)\nGF_EXPORT\nGF_Err gf_isom_set_storage_mode(GF_ISOFile *movie, GF_ISOStorageMode storageMode)\n{\n\tGF_Err e;\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\tswitch (storageMode) {\n\tcase GF_ISOM_STORE_FLAT:\n\tcase GF_ISOM_STORE_STREAMABLE:\n\tcase GF_ISOM_STORE_INTERLEAVED:\n\tcase GF_ISOM_STORE_DRIFT_INTERLEAVED:\n\tcase GF_ISOM_STORE_TIGHT:\n\tcase GF_ISOM_STORE_FASTSTART:\n\t\tmovie->storageMode = storageMode;\n\t\t//specifying a storage mode disables inplace rewrite\n\t\tgf_isom_disable_inplace_rewrite(movie);\n\t\treturn GF_OK;\n\tdefault:\n\t\treturn GF_BAD_PARAM;\n\t}\n}\n\n\nGF_EXPORT\nGF_Err gf_isom_enable_compression(GF_ISOFile *file, GF_ISOCompressMode compress_mode, Bool force_compress)\n{\n\tif (!file) return GF_BAD_PARAM;\n\tfile->compress_mode = compress_mode;\n\tfile->force_compress = force_compress;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_force_64bit_chunk_offset(GF_ISOFile *file, Bool set_on)\n{\n\tif (!file) return GF_BAD_PARAM;\n\tfile->force_co64 = set_on;\n\treturn GF_OK;\n}\n\n\n//update or insert a new edit segment in the track time line. Edits are used to modify\n//the media normal timing. EditTime and EditDuration are expressed in Movie TimeScale\n//If a segment with EditTime already exists, IT IS ERASED\nstatic GF_Err gf_isom_set_edit_internal(GF_ISOFile *movie, u32 trackNumber, u64 EditTime, u64 EditDuration, u64 MediaTime, u32 media_rate, GF_ISOEditType EditMode)\n{\n\tGF_TrackBox *trak;\n\tGF_EditBox *edts;\n\tGF_EditListBox *elst;\n\tGF_EdtsEntry *ent, *newEnt;\n\tu32 i;\n\tGF_Err e;\n\tu64 startTime;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tedts = trak->editBox;\n\tif (! edts) {\n\t\tedts = (GF_EditBox *) gf_isom_box_new_parent(&trak->child_boxes, GF_ISOM_BOX_TYPE_EDTS);\n\t\tif (!edts) return GF_OUT_OF_MEM;\n\t\ttrak_on_child_box((GF_Box*)trak, (GF_Box *)edts, GF_FALSE);\n\t}\n\telst = edts->editList;\n\tif (!elst) {\n\t\telst = (GF_EditListBox *) gf_isom_box_new_parent(&edts->child_boxes, GF_ISOM_BOX_TYPE_ELST);\n\t\tif (!elst) return GF_OUT_OF_MEM;\n\t\tedts_on_child_box((GF_Box*)edts, (GF_Box *)elst, GF_FALSE);\n\t}\n\n\tstartTime = 0;\n\tent = NULL;\n\t//get the prev entry to this startTime if any\n\ti=0;\n\twhile ((ent = (GF_EdtsEntry *)gf_list_enum(elst->entryList, &i))) {\n\t\tif ( (startTime <= EditTime) && (startTime + ent->segmentDuration > EditTime) )\n\t\t\tgoto found;\n\t\tstartTime += ent->segmentDuration;\n\t}\n\n\t//not found, add a new entry and adjust the prev one if any\n\tif (!ent) {\n\t\tnewEnt = CreateEditEntry(EditDuration, MediaTime, EditMode);\n\t\tif (!newEnt) return GF_OUT_OF_MEM;\n\t\tif (EditMode==GF_ISOM_EDIT_NORMAL+1) {\n\t\t\tnewEnt->mediaRate = media_rate;\n\t\t}\n\t\tgf_list_add(elst->entryList, newEnt);\n\t\treturn SetTrackDuration(trak);\n\t}\n\n\tstartTime -= ent->segmentDuration;\n\nfound:\n\n\t//if same time, we erase the current one...\n\tif (startTime == EditTime) {\n\t\tent->segmentDuration = EditDuration;\n\t\tif (EditMode==GF_ISOM_EDIT_NORMAL+1) {\n\t\t\tent->mediaRate = media_rate;\n\t\t\tent->mediaTime = MediaTime;\n\t\t} else {\n\t\t\tswitch (EditMode) {\n\t\t\tcase GF_ISOM_EDIT_EMPTY:\n\t\t\t\tent->mediaRate = 0x10000;\n\t\t\t\tent->mediaTime = -1;\n\t\t\t\tbreak;\n\t\t\tcase GF_ISOM_EDIT_DWELL:\n\t\t\t\tent->mediaRate = 0;\n\t\t\t\tent->mediaTime = MediaTime;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tent->mediaRate = 0x10000;\n\t\t\t\tent->mediaTime = MediaTime;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn SetTrackDuration(trak);\n\t}\n\n\t//adjust so that the prev ent leads to EntryTime\n\t//Note: we don't change the next one as it is unknown to us in\n\t//a lot of case (the author's changes)\n\tent->segmentDuration = EditTime - startTime;\n\tnewEnt = CreateEditEntry(EditDuration, MediaTime, EditMode);\n\tif (!newEnt) return GF_OUT_OF_MEM;\n\tif (EditMode==GF_ISOM_EDIT_NORMAL+1) {\n\t\tnewEnt->mediaRate = media_rate;\n\t\tnewEnt->mediaTime = MediaTime;\n\t}\n\t//is it the last entry ???\n\tif (i >= gf_list_count(elst->entryList) - 1) {\n\t\t//add the new entry at the end\n\t\tgf_list_add(elst->entryList, newEnt);\n\t\treturn SetTrackDuration(trak);\n\t} else {\n\t\t//insert after the current entry (which is i)\n\t\tgf_list_insert(elst->entryList, newEnt, i+1);\n\t\treturn SetTrackDuration(trak);\n\t}\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_edit(GF_ISOFile *movie, u32 trackNumber, u64 EditTime, u64 EditDuration, u64 MediaTime, GF_ISOEditType EditMode)\n{\n\treturn gf_isom_set_edit_internal(movie, trackNumber, EditTime, EditDuration, MediaTime, 0, EditMode);\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_edit_with_rate(GF_ISOFile *movie, u32 trackNumber, u64 EditTime, u64 EditDuration, u64 MediaTime, u32 media_rate)\n{\n\treturn gf_isom_set_edit_internal(movie, trackNumber, EditTime, EditDuration, MediaTime, media_rate, GF_ISOM_EDIT_NORMAL+1);\n\n}\n\n//remove the edit segments for the whole track\nGF_EXPORT\nGF_Err gf_isom_remove_edits(GF_ISOFile *movie, u32 trackNumber)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\tif (!trak->editBox || !trak->editBox->editList) return GF_OK;\n\n\twhile (gf_list_count(trak->editBox->editList->entryList)) {\n\t\tGF_EdtsEntry *ent = (GF_EdtsEntry*)gf_list_get(trak->editBox->editList->entryList, 0);\n\t\tgf_free(ent);\n\t\te = gf_list_rem(trak->editBox->editList->entryList, 0);\n\t\tif (e) return e;\n\t}\n\t//then delete the GF_EditBox...\n\tgf_isom_box_del_parent(&trak->child_boxes, (GF_Box *)trak->editBox);\n\ttrak->editBox = NULL;\n\treturn SetTrackDuration(trak);\n}\n\n\n//remove the edit segments for the whole track\nGF_EXPORT\nGF_Err gf_isom_remove_edit(GF_ISOFile *movie, u32 trackNumber, u32 seg_index)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\tGF_EdtsEntry *ent, *next_ent;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !seg_index) return GF_BAD_PARAM;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\tif (!trak->editBox || !trak->editBox->editList) return GF_OK;\n\tif (gf_list_count(trak->editBox->editList->entryList)<=1) return gf_isom_remove_edits(movie, trackNumber);\n\n\tent = (GF_EdtsEntry*) gf_list_get(trak->editBox->editList->entryList, seg_index-1);\n\tgf_list_rem(trak->editBox->editList->entryList, seg_index-1);\n\tnext_ent = (GF_EdtsEntry *)gf_list_get(trak->editBox->editList->entryList, seg_index-1);\n\tif (next_ent) next_ent->segmentDuration += ent->segmentDuration;\n\tgf_free(ent);\n\treturn SetTrackDuration(trak);\n}\n\n\nGF_EXPORT\nGF_Err gf_isom_append_edit(GF_ISOFile *movie, u32 trackNumber, u64 EditDuration, u64 MediaTime, GF_ISOEditType EditMode)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\tGF_EdtsEntry *ent;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\tif (!trak->editBox) {\n\t\tGF_EditBox *edts = (GF_EditBox *) gf_isom_box_new_parent(&trak->child_boxes, GF_ISOM_BOX_TYPE_EDTS);\n\t\tif (!edts) return GF_OUT_OF_MEM;\n\t\ttrak_on_child_box((GF_Box*)trak, (GF_Box *)edts, GF_FALSE);\n\t\tassert(trak->editBox);\n\t}\n\tif (!trak->editBox->editList) {\n\t\tGF_EditListBox *elst = (GF_EditListBox *) gf_isom_box_new_parent(&trak->editBox->child_boxes, GF_ISOM_BOX_TYPE_ELST);\n\t\tif (!elst) return GF_OUT_OF_MEM;\n\t\tedts_on_child_box((GF_Box*)trak->editBox, (GF_Box *)elst, GF_FALSE);\n\t\tassert(trak->editBox->editList);\n\t}\n\tent = (GF_EdtsEntry *)gf_malloc(sizeof(GF_EdtsEntry));\n\tif (!ent) return GF_OUT_OF_MEM;\n\n\tent->segmentDuration = EditDuration;\n\tswitch (EditMode) {\n\tcase GF_ISOM_EDIT_EMPTY:\n\t\tent->mediaRate = 0x10000;\n\t\tent->mediaTime = -1;\n\t\tbreak;\n\tcase GF_ISOM_EDIT_DWELL:\n\t\tent->mediaRate = 0;\n\t\tent->mediaTime = MediaTime;\n\t\tbreak;\n\tdefault:\n\t\tent->mediaRate = 0x10000;\n\t\tent->mediaTime = MediaTime;\n\t\tbreak;\n\t}\n\tgf_list_add(trak->editBox->editList->entryList, ent);\n\treturn SetTrackDuration(trak);\n}\n\nGF_EXPORT\nGF_Err gf_isom_modify_edit(GF_ISOFile *movie, u32 trackNumber, u32 seg_index, u64 EditDuration, u64 MediaTime, GF_ISOEditType EditMode)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\tGF_EdtsEntry *ent;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !seg_index) return GF_BAD_PARAM;\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\tif (!trak->editBox || !trak->editBox->editList) return GF_OK;\n\tif (gf_list_count(trak->editBox->editList->entryList)<seg_index) return GF_BAD_PARAM;\n\tent = (GF_EdtsEntry*) gf_list_get(trak->editBox->editList->entryList, seg_index-1);\n\n\tent->segmentDuration = EditDuration;\n\tswitch (EditMode) {\n\tcase GF_ISOM_EDIT_EMPTY:\n\t\tent->mediaRate = 0x10000;\n\t\tent->mediaTime = -1;\n\t\tbreak;\n\tcase GF_ISOM_EDIT_DWELL:\n\t\tent->mediaRate = 0;\n\t\tent->mediaTime = MediaTime;\n\t\tbreak;\n\tdefault:\n\t\tent->mediaRate = 0x10000;\n\t\tent->mediaTime = MediaTime;\n\t\tbreak;\n\t}\n\treturn SetTrackDuration(trak);\n}\n\n//removes the desired track\nGF_EXPORT\nGF_Err gf_isom_remove_track(GF_ISOFile *movie, u32 trackNumber)\n{\n\tGF_Err e;\n\tGF_TrackBox *the_trak, *trak;\n\tGF_TrackReferenceTypeBox *tref;\n\tu32 i, j, k, descIndex;\n\tGF_ISOTrackID *newRefs;\n\tu8 found;\n\tGF_ISOSample *samp;\n\tthe_trak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!the_trak) return GF_BAD_PARAM;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\tif (movie->moov->iods && movie->moov->iods->descriptor) {\n\t\tGF_Descriptor *desc;\n\t\tGF_ES_ID_Inc *inc;\n\t\tGF_List *ESDs;\n\t\tdesc = movie->moov->iods->descriptor;\n\t\tif (desc->tag == GF_ODF_ISOM_IOD_TAG) {\n\t\t\tESDs = ((GF_IsomInitialObjectDescriptor *)desc)->ES_ID_IncDescriptors;\n\t\t} else if (desc->tag == GF_ODF_ISOM_OD_TAG) {\n\t\t\tESDs = ((GF_IsomObjectDescriptor *)desc)->ES_ID_IncDescriptors;\n\t\t} else {\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\n\t\t//remove the track ref from the root OD if any\n\t\ti=0;\n\t\twhile ((inc = (GF_ES_ID_Inc *)gf_list_enum(ESDs, &i))) {\n\t\t\tif (inc->trackID == the_trak->Header->trackID) {\n\t\t\t\tgf_odf_desc_del((GF_Descriptor *)inc);\n\t\t\t\ti--;\n\t\t\t\tgf_list_rem(ESDs, i);\n\t\t\t}\n\t\t}\n\t}\n\n\t//remove the track from the movie\n\tgf_list_del_item(movie->moov->trackList, the_trak);\n\n\t//rewrite any OD tracks\n\ti=0;\n\twhile ((trak = (GF_TrackBox *)gf_list_enum(movie->moov->trackList, &i))) {\n\t\tif (trak->Media->handler->handlerType != GF_ISOM_MEDIA_OD) continue;\n\t\t//this is an OD track...\n\t\tj = gf_isom_get_sample_count(movie, i);\n\t\tfor (k=0; k < j; k++) {\n\t\t\t//getting the sample will remove the references to the deleted track in the output OD frame\n\t\t\tsamp = gf_isom_get_sample(movie, i, k+1, &descIndex);\n\t\t\tif (!samp) break;\n\t\t\t//so let's update with the new OD frame ! If the sample is empty, remove it\n\t\t\tif (!samp->dataLength) {\n\t\t\t\te = gf_isom_remove_sample(movie, i, k+1);\n\t\t\t\tif (e) return e;\n\t\t\t} else {\n\t\t\t\te = gf_isom_update_sample(movie, i, k+1, samp, GF_TRUE);\n\t\t\t\tif (e) return e;\n\t\t\t}\n\t\t\t//and don't forget to delete the sample\n\t\t\tgf_isom_sample_del(&samp);\n\t\t}\n\t}\n\n\t//remove the track ref from any \"tref\" box in all tracks, except the one to delete\n\t//note that we don't touch scal references, as we don't want to rewrite AVC/HEVC samples ...\n\ti=0;\n\twhile ((trak = (GF_TrackBox *)gf_list_enum(movie->moov->trackList, &i))) {\n\t\tif (trak == the_trak) continue;\n\t\tif (! trak->References || ! gf_list_count(trak->References->child_boxes)) continue;\n\n\t\tj=0;\n\t\twhile ((tref = (GF_TrackReferenceTypeBox *)gf_list_enum(trak->References->child_boxes, &j))) {\n\t\t\tif (tref->reference_type==GF_ISOM_REF_SCAL)\n\t\t\t\tcontinue;\n\n\t\t\tfound = 0;\n\t\t\tfor (k=0; k<tref->trackIDCount; k++) {\n\t\t\t\tif (tref->trackIDs[k] == the_trak->Header->trackID) found++;\n\t\t\t}\n\t\t\tif (!found) continue;\n\t\t\t//no more refs, remove this ref_type\n\t\t\tif (found == tref->trackIDCount) {\n\t\t\t\tgf_isom_box_del_parent(&trak->References->child_boxes, (GF_Box *)tref);\n\t\t\t\tj--;\n\t\t\t} else {\n\t\t\t\tnewRefs = (GF_ISOTrackID*)gf_malloc(sizeof(GF_ISOTrackID) * (tref->trackIDCount - found));\n\t\t\t\tif (!newRefs) return GF_OUT_OF_MEM;\n\t\t\t\tfound = 0;\n\t\t\t\tfor (k = 0; k < tref->trackIDCount; k++) {\n\t\t\t\t\tif (tref->trackIDs[k] != the_trak->Header->trackID) {\n\t\t\t\t\t\tnewRefs[k-found] = tref->trackIDs[k];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfound++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tgf_free(tref->trackIDs);\n\t\t\t\ttref->trackIDs = newRefs;\n\t\t\t\ttref->trackIDCount -= found;\n\t\t\t}\n\t\t}\n\t\t//a little opt: remove the ref box if empty...\n\t\tif (! gf_list_count(trak->References->child_boxes)) {\n\t\t\tgf_isom_box_del_parent(&trak->child_boxes, (GF_Box *)trak->References);\n\t\t\ttrak->References = NULL;\n\t\t}\n\t}\n\n\tgf_isom_disable_inplace_rewrite(movie);\n\n\t//delete the track\n\tgf_isom_box_del_parent(&movie->moov->child_boxes, (GF_Box *)the_trak);\n\n\t/*update next track ID*/\n\tmovie->moov->mvhd->nextTrackID = 0;\n\ti=0;\n\twhile ((trak = (GF_TrackBox *)gf_list_enum(movie->moov->trackList, &i))) {\n\t\tif (trak->Header->trackID>movie->moov->mvhd->nextTrackID)\n\t\t\tmovie->moov->mvhd->nextTrackID = trak->Header->trackID;\n\t}\n\n\tif (!gf_list_count(movie->moov->trackList)) {\n\t\tgf_list_del_item(movie->TopBoxes, movie->moov);\n\t\tgf_isom_box_del((GF_Box *)movie->moov);\n\t\tmovie->moov = NULL;\n\t}\n\treturn GF_OK;\n}\n\n\nGF_EXPORT\nGF_Err gf_isom_set_copyright(GF_ISOFile *movie, const char *threeCharCode, char *notice)\n{\n\tGF_Err e;\n\tGF_CopyrightBox *ptr;\n\tGF_UserDataMap *map;\n\tu32 count, i;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\tif (!notice || !threeCharCode) return GF_BAD_PARAM;\n\n\te = gf_isom_insert_moov(movie);\n\tif (e) return e;\n\n\tif (!movie->moov->udta) {\n\t\te = moov_on_child_box((GF_Box*)movie->moov, gf_isom_box_new_parent(&movie->moov->child_boxes, GF_ISOM_BOX_TYPE_UDTA), GF_FALSE);\n\t\tif (e) return e;\n\t}\n\tmap = udta_getEntry(movie->moov->udta, GF_ISOM_BOX_TYPE_CPRT, NULL);\n\n\tif (map) {\n\t\t//try to find one in our language...\n\t\tcount = gf_list_count(map->boxes);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tptr = (GF_CopyrightBox*)gf_list_get(map->boxes, i);\n\t\t\tif (!strcmp(threeCharCode, (const char *) ptr->packedLanguageCode)) {\n\t\t\t\tgf_free(ptr->notice);\n\t\t\t\tptr->notice = (char*)gf_malloc(sizeof(char) * (strlen(notice) + 1));\n\t\t\t\tif (!ptr->notice) return GF_OUT_OF_MEM;\n\t\t\t\tstrcpy(ptr->notice, notice);\n\t\t\t\treturn GF_OK;\n\t\t\t}\n\t\t}\n\t}\n\t//nope, create one\n\tptr = (GF_CopyrightBox *)gf_isom_box_new(GF_ISOM_BOX_TYPE_CPRT);\n\tif (!ptr) return GF_OUT_OF_MEM;\n\n\tmemcpy(ptr->packedLanguageCode, threeCharCode, 4);\n\tptr->notice = (char*)gf_malloc(sizeof(char) * (strlen(notice)+1));\n\tif (!ptr->notice) return GF_OUT_OF_MEM;\n\tstrcpy(ptr->notice, notice);\n\treturn udta_on_child_box((GF_Box *)movie->moov->udta, (GF_Box *) ptr, GF_FALSE);\n}\n\nGF_EXPORT\nGF_Err gf_isom_add_track_kind(GF_ISOFile *movie, u32 trackNumber, const char *schemeURI, const char *value)\n{\n\tGF_Err e;\n\tGF_KindBox *ptr;\n\tGF_UserDataBox *udta;\n\tGF_UserDataMap *map;\n\tu32 i, count;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\te = gf_isom_insert_moov(movie);\n\tif (e) return e;\n\n\tif (trackNumber) {\n\t\tGF_TrackBox *trak = gf_isom_get_track_from_file(movie, trackNumber);\n\t\tif (!trak) return GF_BAD_PARAM;\n\t\tif (!trak->udta) {\n\t\t\te = trak_on_child_box((GF_Box*)trak, gf_isom_box_new_parent(&trak->child_boxes, GF_ISOM_BOX_TYPE_UDTA), GF_FALSE);\n\t\t\tif (e) return e;\n\t\t}\n\t\tudta = trak->udta;\n\t} else {\n\t\treturn GF_BAD_PARAM;\n\t}\n\n\tmap = udta_getEntry(udta, GF_ISOM_BOX_TYPE_KIND, NULL);\n\tif (map) {\n\t\tcount = gf_list_count(map->boxes);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tGF_Box *b = (GF_Box *)gf_list_get(map->boxes, i);\n\t\t\tif (b->type == GF_ISOM_BOX_TYPE_KIND) {\n\t\t\t\tGF_KindBox *kb = (GF_KindBox *)b;\n\t\t\t\tif (!strcmp(kb->schemeURI, schemeURI) &&\n\t\t\t\t        ((value && kb->value && !strcmp(value, kb->value)) || (!value && !kb->value))) {\n\t\t\t\t\t// Already there\n\t\t\t\t\treturn GF_OK;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tptr = (GF_KindBox *)gf_isom_box_new(GF_ISOM_BOX_TYPE_KIND);\n\tif (e) return e;\n\n\tptr->schemeURI = gf_strdup(schemeURI);\n\tif (value) ptr->value = gf_strdup(value);\n\treturn udta_on_child_box((GF_Box *)udta, (GF_Box *) ptr, GF_FALSE);\n}\n\nGF_EXPORT\nGF_Err gf_isom_remove_track_kind(GF_ISOFile *movie, u32 trackNumber, const char *schemeURI, const char *value)\n{\n\tGF_Err e;\n\tGF_UserDataBox *udta;\n\tGF_UserDataMap *map;\n\tu32 i;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\te = gf_isom_insert_moov(movie);\n\tif (e) return e;\n\n\tif (trackNumber) {\n\t\tGF_TrackBox *trak = gf_isom_get_track_from_file(movie, trackNumber);\n\t\tif (!trak) return GF_BAD_PARAM;\n\t\tif (!trak->udta) {\n\t\t\te = trak_on_child_box((GF_Box*)trak, gf_isom_box_new_parent(&trak->child_boxes, GF_ISOM_BOX_TYPE_UDTA), GF_FALSE);\n\t\t\tif (e) return e;\n\t\t}\n\t\tudta = trak->udta;\n\t} else {\n\t\treturn GF_OK;\n\t}\n\tmap = udta_getEntry(udta, GF_ISOM_BOX_TYPE_KIND, NULL);\n\tif (map) {\n\t\tfor (i=0; i<gf_list_count(map->boxes); i++) {\n\t\t\tGF_Box *b = (GF_Box *)gf_list_get(map->boxes, i);\n\t\t\tif (b->type == GF_ISOM_BOX_TYPE_KIND) {\n\t\t\t\tGF_KindBox *kb = (GF_KindBox *)b;\n\t\t\t\tif (!schemeURI ||\n\t\t\t\t        (!strcmp(kb->schemeURI, schemeURI) &&\n\t\t\t\t         ((value && kb->value && !strcmp(value, kb->value)) || (!value && !kb->value)))) {\n\t\t\t\t\tgf_isom_box_del_parent(&map->boxes, b);\n\t\t\t\t\ti--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_add_chapter(GF_ISOFile *movie, u32 trackNumber, u64 timestamp, char *name)\n{\n\tGF_Err e;\n\tGF_ChapterListBox *ptr;\n\tu32 i, count;\n\tGF_ChapterEntry *ce;\n\tGF_UserDataBox *udta;\n\tGF_UserDataMap *map;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\te = gf_isom_insert_moov(movie);\n\tif (e) return e;\n\n\tif (trackNumber) {\n\t\tGF_TrackBox *trak = gf_isom_get_track_from_file(movie, trackNumber);\n\t\tif (!trak) return GF_BAD_PARAM;\n\t\tif (!trak->udta) {\n\t\t\te = trak_on_child_box((GF_Box*)trak, gf_isom_box_new_parent(&trak->child_boxes, GF_ISOM_BOX_TYPE_UDTA), GF_FALSE);\n\t\t\tif (e) return e;\n\t\t}\n\t\tudta = trak->udta;\n\t} else {\n\t\tif (!movie->moov->udta) {\n\t\t\te = moov_on_child_box((GF_Box*)movie->moov, gf_isom_box_new_parent(&movie->moov->child_boxes, GF_ISOM_BOX_TYPE_UDTA), GF_FALSE);\n\t\t\tif (e) return e;\n\t\t}\n\t\tudta = movie->moov->udta;\n\t}\n\n\tptr = NULL;\n\tmap = udta_getEntry(udta, GF_ISOM_BOX_TYPE_CHPL, NULL);\n\tif (!map) {\n\t\tptr = (GF_ChapterListBox *)gf_isom_box_new(GF_ISOM_BOX_TYPE_CHPL);\n\t\te = udta_on_child_box((GF_Box *)udta, (GF_Box *) ptr, GF_FALSE);\n\t\tif (e) return e;\n\t\tmap = udta_getEntry(udta, GF_ISOM_BOX_TYPE_CHPL, NULL);\n\t} else {\n\t\tptr = (GF_ChapterListBox*)gf_list_get(map->boxes, 0);\n\t}\n\tif (!map) return GF_OUT_OF_MEM;\n\n\t/*this may happen if original MP4 is not properly formatted*/\n\tif (!ptr) {\n\t\tptr = (GF_ChapterListBox *)gf_isom_box_new(GF_ISOM_BOX_TYPE_CHPL);\n\t\tif (!ptr) return GF_OUT_OF_MEM;\n\t\tgf_list_add(map->boxes, ptr);\n\t}\n\n\tGF_SAFEALLOC(ce, GF_ChapterEntry);\n\tif (!ce) return GF_OUT_OF_MEM;\n\n\tce->start_time = timestamp * 10000L;\n\tce->name = name ? gf_strdup(name) : NULL;\n\n\t/*insert in order*/\n\tcount = gf_list_count(ptr->list);\n\tfor (i=0; i<count; i++) {\n\t\tGF_ChapterEntry *ace = (GF_ChapterEntry *)gf_list_get(ptr->list, i);\n\t\tif (ace->start_time == ce->start_time) {\n\t\t\tif (ace->name) gf_free(ace->name);\n\t\t\tace->name = ce->name;\n\t\t\tgf_free(ce);\n\t\t\treturn GF_OK;\n\t\t}\n\t\tif (ace->start_time >= ce->start_time)\n\t\t\treturn gf_list_insert(ptr->list, ce, i);\n\t}\n\treturn gf_list_add(ptr->list, ce);\n}\n\nGF_EXPORT\nGF_Err gf_isom_remove_chapter(GF_ISOFile *movie, u32 trackNumber, u32 index)\n{\n\tGF_Err e;\n\tGF_ChapterListBox *ptr;\n\tGF_ChapterEntry *ce;\n\tGF_UserDataBox *udta;\n\tGF_UserDataMap *map;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\te = gf_isom_insert_moov(movie);\n\tif (e) return e;\n\n\tif (trackNumber) {\n\t\tGF_TrackBox *trak = gf_isom_get_track_from_file(movie, trackNumber);\n\t\tif (!trak) return GF_BAD_PARAM;\n\t\tif (!trak->udta) return GF_OK;\n\t\tudta = trak->udta;\n\t} else {\n\t\tif (!movie->moov->udta) return GF_OK;\n\t\tudta = movie->moov->udta;\n\t}\n\n\tmap = udta_getEntry(udta, GF_ISOM_BOX_TYPE_CHPL, NULL);\n\tif (!map) return GF_OK;\n\tptr = (GF_ChapterListBox*)gf_list_get(map->boxes, 0);\n\tif (!ptr) return GF_OK;\n\n\tif (index) {\n\t\tce = (GF_ChapterEntry *)gf_list_get(ptr->list, index-1);\n\t\tif (!ce) return GF_BAD_PARAM;\n\t\tif (ce->name) gf_free(ce->name);\n\t\tgf_free(ce);\n\t\tgf_list_rem(ptr->list, index-1);\n\t} else {\n\t\twhile (gf_list_count(ptr->list)) {\n\t\t\tce = (GF_ChapterEntry *)gf_list_get(ptr->list, 0);\n\t\t\tif (ce->name) gf_free(ce->name);\n\t\t\tgf_free(ce);\n\t\t\tgf_list_rem(ptr->list, 0);\n\t\t}\n\t}\n\tif (!gf_list_count(ptr->list)) {\n\t\tgf_list_del_item(udta->recordList, map);\n\t\tgf_isom_box_array_del(map->boxes);\n\t\tgf_free(map);\n\t}\n\treturn GF_OK;\n}\n\n#if 0 //unused\nGF_Err gf_isom_remove_copyright(GF_ISOFile *movie, u32 index)\n{\n\tGF_Err e;\n\tGF_CopyrightBox *ptr;\n\tGF_UserDataMap *map;\n\tu32 count;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\te = gf_isom_insert_moov(movie);\n\tif (e) return e;\n\n\tif (!index) return GF_BAD_PARAM;\n\tif (!movie->moov->udta) return GF_OK;\n\n\tmap = udta_getEntry(movie->moov->udta, GF_ISOM_BOX_TYPE_CPRT, NULL);\n\tif (!map) return GF_OK;\n\n\tcount = gf_list_count(map->boxes);\n\tif (index>count) return GF_BAD_PARAM;\n\n\tptr = (GF_CopyrightBox*)gf_list_get(map->boxes, index-1);\n\tif (ptr) {\n\t\tgf_list_rem(map->boxes, index-1);\n\t\tif (ptr->notice) gf_free(ptr->notice);\n\t\tgf_free(ptr);\n\t}\n\t/*last copyright, remove*/\n\tif (!gf_list_count(map->boxes)) {\n\t\tgf_list_del_item(movie->moov->udta->recordList, map);\n\t\tgf_list_del(map->boxes);\n\t\tgf_free(map);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err gf_isom_set_watermark(GF_ISOFile *movie, bin128 UUID, u8* data, u32 length)\n{\n\tGF_Err e;\n\tGF_UnknownUUIDBox *ptr;\n\tGF_UserDataMap *map;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\te = gf_isom_insert_moov(movie);\n\tif (e) return e;\n\tif (!movie->moov->udta) {\n\t\te = moov_on_child_box((GF_Box*)movie->moov, gf_isom_box_new_parent(&movie->moov->child_boxes, GF_ISOM_BOX_TYPE_UDTA));\n\t\tif (e) return e;\n\t}\n\n\tmap = udta_getEntry(movie->moov->udta, GF_ISOM_BOX_TYPE_UUID, (bin128 *) & UUID);\n\tif (map) {\n\t\tptr = (GF_UnknownUUIDBox *)gf_list_get(map->boxes, 0);\n\t\tif (ptr) {\n\t\t\tgf_free(ptr->data);\n\t\t\tptr->data = (char*)gf_malloc(length);\n\t\t\tif (!ptr->data) return GF_OUT_OF_MEM;\n\t\t\tmemcpy(ptr->data, data, length);\n\t\t\tptr->dataSize = length;\n\t\t\treturn GF_OK;\n\t\t}\n\t}\n\t//nope, create one\n\tptr = (GF_UnknownUUIDBox *)gf_isom_box_new(GF_ISOM_BOX_TYPE_UUID);\n\tif (!ptr) return GF_OUT_OF_MEM;\n\n\tmemcpy(ptr->uuid, UUID, 16);\n\tptr->data = (char*)gf_malloc(length);\n\tif (!ptr->data) return GF_OUT_OF_MEM;\n\tmemcpy(ptr->data, data, length);\n\tptr->dataSize = length;\n\treturn udta_on_child_box((GF_Box *)movie->moov->udta, (GF_Box *) ptr);\n}\n#endif\n\n//set the interleaving time of media data (INTERLEAVED mode only)\n//InterleaveTime is in MovieTimeScale\nGF_EXPORT\nGF_Err gf_isom_set_interleave_time(GF_ISOFile *movie, u32 InterleaveTime)\n{\n\tGF_Err e;\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\tif (!InterleaveTime || !movie->moov) return GF_OK;\n\tmovie->interleavingTime = InterleaveTime;\n\treturn GF_OK;\n}\n\n\n\n//use a compact track version for sample size. This is not usually recommended\n//except for speech codecs where the track has a lot of small samples\n//compaction is done automatically while writing based on the track's sample sizes\nGF_EXPORT\nGF_Err gf_isom_use_compact_size(GF_ISOFile *movie, u32 trackNumber, Bool CompactionOn)\n{\n\tGF_TrackBox *trak;\n\tu32 i, size;\n\tGF_SampleSizeBox *stsz;\n\tGF_Err e;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tif (!trak->Media || !trak->Media->information\n\t        || !trak->Media->information->sampleTable || !trak->Media->information->sampleTable->SampleSize)\n\t\treturn GF_ISOM_INVALID_FILE;\n\n\tstsz = trak->Media->information->sampleTable->SampleSize;\n\n\t//switch to regular table\n\tif (!CompactionOn) {\n\t\tif (stsz->type == GF_ISOM_BOX_TYPE_STSZ) return GF_OK;\n\t\tstsz->type = GF_ISOM_BOX_TYPE_STSZ;\n\t\t//invalidate the sampleSize and recompute it\n\t\tstsz->sampleSize = 0;\n\t\tif (!stsz->sampleCount) return GF_OK;\n\t\t//if the table is empty we can only assume the track is empty (no size indication)\n\t\tif (!stsz->sizes) return GF_OK;\n\t\tsize = stsz->sizes[0];\n\t\t//check whether the sizes are all the same or not\n\t\tfor (i=1; i<stsz->sampleCount; i++) {\n\t\t\tif (size != stsz->sizes[i]) {\n\t\t\t\tsize = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (size) {\n\t\t\tgf_free(stsz->sizes);\n\t\t\tstsz->sizes = NULL;\n\t\t\tstsz->sampleSize = size;\n\t\t}\n\t\treturn GF_OK;\n\t}\n\n\t//switch to compact table\n\tif (stsz->type == GF_ISOM_BOX_TYPE_STZ2) return GF_OK;\n\t//fill the table. Although it seems weird , this is needed in case of edition\n\t//after the function is called. NOte however than we force regular table\n\t//at write time if all samples are of same size\n\tif (stsz->sampleSize) {\n\t\t//this is a weird table indeed ;)\n\t\tif (stsz->sizes) gf_free(stsz->sizes);\n\t\tstsz->sizes = (u32*) gf_malloc(sizeof(u32)*stsz->sampleCount);\n\t\tif (!stsz->sizes) return GF_OUT_OF_MEM;\n\t\tmemset(stsz->sizes, stsz->sampleSize, sizeof(u32));\n\t}\n\t//set the SampleSize to 0 while the file is open\n\tstsz->sampleSize = 0;\n\tstsz->type = GF_ISOM_BOX_TYPE_STZ2;\n\treturn GF_OK;\n}\n\n\nGF_EXPORT\nGF_Err gf_isom_set_brand_info(GF_ISOFile *movie, u32 MajorBrand, u32 MinorVersion)\n{\n\tu32 i, *p;\n\n\tif (!MajorBrand) return GF_BAD_PARAM;\n\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\tif (! (movie->FragmentsFlags & GF_ISOM_FRAG_WRITE_READY)) {\n\t\tGF_Err e = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\t\tif (e) return e;\n\n\t\te = CheckNoData(movie);\n\t\tif (e) return e;\n\t}\n#endif\n\n\tif (!movie->brand) {\n\t\tmovie->brand = (GF_FileTypeBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_FTYP);\n\t\tif (!movie->brand) return GF_OUT_OF_MEM;\n\t\tgf_list_add(movie->TopBoxes, movie->brand);\n\t}\n\n\tmovie->brand->majorBrand = MajorBrand;\n\tmovie->brand->minorVersion = MinorVersion;\n\n\tif (!movie->brand->altBrand) {\n\t\tmovie->brand->altBrand = (u32*)gf_malloc(sizeof(u32));\n\t\tif (!movie->brand->altBrand) return GF_OUT_OF_MEM;\n\t\tmovie->brand->altBrand[0] = MajorBrand;\n\t\tmovie->brand->altCount = 1;\n\t\treturn GF_OK;\n\t}\n\n\t//if brand already present don't change anything\n\tfor (i=0; i<movie->brand->altCount; i++) {\n\t\tif (movie->brand->altBrand[i] == MajorBrand) return GF_OK;\n\t}\n\tp = (u32*)gf_malloc(sizeof(u32)*(movie->brand->altCount + 1));\n\tif (!p) return GF_OUT_OF_MEM;\n\tmemcpy(p, movie->brand->altBrand, sizeof(u32)*movie->brand->altCount);\n\tp[movie->brand->altCount] = MajorBrand;\n\tmovie->brand->altCount += 1;\n\tgf_free(movie->brand->altBrand);\n\tmovie->brand->altBrand = p;\n\treturn GF_OK;\n}\n\n\nGF_EXPORT\nGF_Err gf_isom_modify_alternate_brand(GF_ISOFile *movie, u32 Brand, Bool AddIt)\n{\n\tu32 i, k, *p;\n\n\tif (!Brand) return GF_BAD_PARAM;\n\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\tif (! (movie->FragmentsFlags & GF_ISOM_FRAG_WRITE_READY)) {\n\t\tGF_Err e = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\t\tif (e) return e;\n\n\t\te = CheckNoData(movie);\n\t\tif (e) return e;\n\t}\n#endif\n\n\tif (!movie->brand && AddIt) {\n\t\tmovie->brand = (GF_FileTypeBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_FTYP);\n\t\tif (!movie->brand) return GF_OUT_OF_MEM;\n\t\tgf_list_add(movie->TopBoxes, movie->brand);\n\t}\n\tif (!AddIt && !movie->brand) return GF_OK;\n\n\t//do not mofify major one\n\tif (!AddIt && movie->brand->majorBrand == Brand) return GF_OK;\n\n\tif (!AddIt && movie->brand->altCount == 1) {\n\t\t//fixes it in case\n\t\tmovie->brand->altBrand[0] = movie->brand->majorBrand;\n\t\treturn GF_OK;\n\t}\n\t//check for the brand\n\tfor (i=0; i<movie->brand->altCount; i++) {\n\t\tif (movie->brand->altBrand[i] == Brand) goto found;\n\t}\n\t//Not found\n\tif (!AddIt) return GF_OK;\n\t//add it\n\tp = (u32*)gf_malloc(sizeof(u32)*(movie->brand->altCount + 1));\n\tif (!p) return GF_OUT_OF_MEM;\n\tif (movie->brand->altBrand) {\n\t\tmemcpy(p, movie->brand->altBrand, sizeof(u32)*movie->brand->altCount);\n\t\tgf_free(movie->brand->altBrand);\n\t}\n\tp[movie->brand->altCount] = Brand;\n\tmovie->brand->altCount += 1;\n\tmovie->brand->altBrand = p;\n\treturn GF_OK;\n\nfound:\n\n\t//found\n\tif (AddIt) return GF_OK;\n\tassert(movie->brand->altCount>1);\n\n\t//remove it\n\tp = (u32*)gf_malloc(sizeof(u32)*(movie->brand->altCount - 1));\n\tif (!p) return GF_OUT_OF_MEM;\n\tk = 0;\n\tfor (i=0; i<movie->brand->altCount; i++) {\n\t\tif (movie->brand->altBrand[i] == Brand) continue;\n\t\telse {\n\t\t\tp[k] = movie->brand->altBrand[i];\n\t\t\tk++;\n\t\t}\n\t}\n\tmovie->brand->altCount -= 1;\n\tgf_free(movie->brand->altBrand);\n\tmovie->brand->altBrand = p;\n\treturn GF_OK;\n}\n\n\nGF_Err gf_isom_reset_alt_brands_ex(GF_ISOFile *movie, Bool leave_empty)\n{\n\tu32 *p;\n\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\tif (! (movie->FragmentsFlags & GF_ISOM_FRAG_WRITE_READY)) {\n\t\tGF_Err e = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\t\tif (e) return e;\n\n\t\te = CheckNoData(movie);\n\t\tif (e) return e;\n\t}\n#endif\n\n\tif (!movie->brand) {\n\t\tmovie->brand = (GF_FileTypeBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_FTYP);\n\t\tif (!movie->brand) return GF_OUT_OF_MEM;\n\t\tgf_list_add(movie->TopBoxes, movie->brand);\n\t}\n\tgf_free(movie->brand->altBrand);\n\tif (leave_empty) {\n\t\tmovie->brand->altCount = 0;\n\t\tmovie->brand->altBrand = NULL;\n\t} else {\n\t\tp = (u32*)gf_malloc(sizeof(u32));\n\t\tif (!p) return GF_OUT_OF_MEM;\n\t\tp[0] = movie->brand->majorBrand;\n\t\tmovie->brand->altCount = 1;\n\t\tmovie->brand->altBrand = p;\n\t}\n\treturn GF_OK;\n}\nGF_EXPORT\nGF_Err gf_isom_reset_alt_brands(GF_ISOFile *movie)\n{\n\treturn gf_isom_reset_alt_brands_ex(movie, GF_FALSE);\n}\n\n#if 0 //unused\nGF_Err gf_isom_set_sample_padding_bits(GF_ISOFile *movie, u32 trackNumber, u32 sampleNumber, u8 NbBits)\n{\n\tGF_TrackBox *trak;\n\tGF_Err e;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || NbBits > 7) return GF_BAD_PARAM;\n\n\t//set Padding info\n\treturn stbl_SetPaddingBits(trak->Media->information->sampleTable, sampleNumber, NbBits);\n}\n#endif\n\nGF_EXPORT\nGF_Err gf_isom_remove_user_data_item(GF_ISOFile *movie, u32 trackNumber, u32 UserDataType, bin128 UUID, u32 UserDataIndex)\n{\n\tGF_UserDataMap *map;\n\tGF_Box *a;\n\tu32 i;\n\tbin128 t;\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\tGF_UserDataBox *udta;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\tif (UserDataType == GF_ISOM_BOX_TYPE_UUID) UserDataType = 0;\n\tmemset(t, 1, 16);\n\n\tif (trackNumber) {\n\t\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\t\tif (!trak) return GF_BAD_PARAM;\n\t\tudta = trak->udta;\n\t} else {\n\t\tudta = movie->moov->udta;\n\t}\n\tif (!udta) return GF_BAD_PARAM;\n\tif (!UserDataIndex) return GF_BAD_PARAM;\n\n\ti=0;\n\twhile ((map = (GF_UserDataMap*)gf_list_enum(udta->recordList, &i))) {\n\t\tif ((map->boxType == GF_ISOM_BOX_TYPE_UUID)  && !memcmp(map->uuid, UUID, 16)) goto found;\n\t\telse if (map->boxType == UserDataType) goto found;\n\t}\n\t//not found\n\treturn GF_OK;\n\nfound:\n\n\tif (UserDataIndex > gf_list_count(map->boxes) ) return GF_BAD_PARAM;\n\t//delete the box\n\ta = (GF_Box*)gf_list_get(map->boxes, UserDataIndex-1);\n\tgf_isom_box_del_parent(&map->boxes, a);\n\n\t//remove the map if empty\n\tif (!gf_list_count(map->boxes)) {\n\t\tgf_list_rem(udta->recordList, i-1);\n\t\tgf_isom_box_array_del(map->boxes);\n\t\tgf_free(map);\n\t}\n\t//but we keep the UDTA no matter what\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_remove_user_data(GF_ISOFile *movie, u32 trackNumber, u32 UserDataType, bin128 UUID)\n{\n\tGF_UserDataMap *map;\n\tu32 i;\n\tGF_Err e;\n\tbin128 t;\n\tGF_TrackBox *trak;\n\tGF_UserDataBox *udta;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\tif (UserDataType == GF_ISOM_BOX_TYPE_UUID) UserDataType = 0;\n\tmemset(t, 1, 16);\n\n\tif (trackNumber) {\n\t\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\t\tif (!trak) return GF_EOS;\n\t\tudta = trak->udta;\n\t} else {\n\t\tudta = movie->moov->udta;\n\t}\n\t//do not return any error if no udta\n\tif (!udta) return GF_EOS;\n\n\ti=0;\n\twhile ((map = (GF_UserDataMap*)gf_list_enum(udta->recordList, &i))) {\n\t\tif ((map->boxType == GF_ISOM_BOX_TYPE_UUID)  && !memcmp(map->uuid, UUID, 16)) goto found;\n\t\telse if (map->boxType == UserDataType) goto found;\n\t}\n\t//not found\n\treturn GF_OK;\n\nfound:\n\n\tgf_list_rem(udta->recordList, i-1);\n\tgf_isom_box_array_del(map->boxes);\n\tgf_free(map);\n\n\t//but we keep the UDTA no matter what\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_add_user_data(GF_ISOFile *movie, u32 trackNumber, u32 UserDataType, bin128 UUID, u8 *data, u32 DataLength)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\tGF_UserDataBox *udta;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\tif (UserDataType == GF_ISOM_BOX_TYPE_UUID) UserDataType = 0;\n\n\tif (trackNumber) {\n\t\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\t\tif (!trak) return GF_BAD_PARAM;\n\t\tif (!trak->udta) trak_on_child_box((GF_Box*)trak, gf_isom_box_new_parent(&trak->child_boxes, GF_ISOM_BOX_TYPE_UDTA), GF_FALSE);\n\t\tudta = trak->udta;\n\t} else {\n\t\tif (!movie->moov->udta) moov_on_child_box((GF_Box*)movie->moov, gf_isom_box_new_parent(&movie->moov->child_boxes, GF_ISOM_BOX_TYPE_UDTA), GF_FALSE);\n\t\tudta = movie->moov->udta;\n\t}\n\tif (!udta) return GF_OUT_OF_MEM;\n\n\t//create a default box\n\tif (UserDataType) {\n\t\tGF_UnknownBox *a = (GF_UnknownBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_UNKNOWN);\n\t\tif (!a) return GF_OUT_OF_MEM;\n\t\ta->original_4cc = UserDataType;\n\t\tif (DataLength) {\n\t\t\ta->data = (char*)gf_malloc(sizeof(char)*DataLength);\n\t\t\tif (!a->data) return GF_OUT_OF_MEM;\n\t\t\tmemcpy(a->data, data, DataLength);\n\t\t\ta->dataSize = DataLength;\n\t\t}\n\t\treturn udta_on_child_box((GF_Box *)udta, (GF_Box *) a, GF_FALSE);\n\t} else {\n\t\tGF_UnknownUUIDBox *a = (GF_UnknownUUIDBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_UUID);\n\t\tif (!a) return GF_OUT_OF_MEM;\n\t\tmemcpy(a->uuid, UUID, 16);\n\t\tif (DataLength) {\n\t\t\ta->data = (char*)gf_malloc(sizeof(char)*DataLength);\n\t\t\tif (!a->data) return GF_OUT_OF_MEM;\n\t\t\tmemcpy(a->data, data, DataLength);\n\t\t\ta->dataSize = DataLength;\n\t\t}\n\t\treturn udta_on_child_box((GF_Box *)udta, (GF_Box *) a, GF_FALSE);\n\t}\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_add_user_data_boxes(GF_ISOFile *movie, u32 trackNumber, u8 *data, u32 DataLength)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\tGF_UserDataBox *udta;\n\tGF_BitStream *bs;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\tif (trackNumber) {\n\t\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\t\tif (!trak) return GF_BAD_PARAM;\n\t\tif (!trak->udta) trak_on_child_box((GF_Box*)trak, gf_isom_box_new_parent(&trak->child_boxes, GF_ISOM_BOX_TYPE_UDTA), GF_FALSE);\n\t\tudta = trak->udta;\n\t} else {\n\t\tif (!movie->moov) return GF_BAD_PARAM;\n\t\tif (!movie->moov->udta) moov_on_child_box((GF_Box*)movie->moov, gf_isom_box_new_parent(&movie->moov->child_boxes, GF_ISOM_BOX_TYPE_UDTA), GF_FALSE);\n\t\tudta = movie->moov->udta;\n\t}\n\tif (!udta) return GF_OUT_OF_MEM;\n\n\tbs = gf_bs_new(data, DataLength, GF_BITSTREAM_READ);\n\twhile (gf_bs_available(bs)) {\n\t\tGF_Box *a;\n\t\te = gf_isom_box_parse(&a, bs);\n\t\tif (e) break;\n\t\te = udta_on_child_box((GF_Box *)udta, a, GF_FALSE);\n\t\tif (e) break;\n\t}\n\tgf_bs_del(bs);\n\treturn e;\n}\n\nGF_EXPORT\nGF_Err gf_isom_clone_pl_indications(GF_ISOFile *orig, GF_ISOFile *dest)\n{\n\tGF_IsomInitialObjectDescriptor *iod_d;\n\tif (!orig || !dest) return GF_BAD_PARAM;\n\tif (!orig->moov->iods || !orig->moov->iods->descriptor) return GF_OK;\n\tif (orig->moov->iods->descriptor->tag != GF_ODF_ISOM_IOD_TAG) return GF_OK;\n\n\tAddMovieIOD(dest->moov, 1);\n\tgf_odf_desc_del((GF_Descriptor *)dest->moov->iods->descriptor);\n\tgf_odf_desc_copy((GF_Descriptor *)orig->moov->iods->descriptor, (GF_Descriptor **)&dest->moov->iods->descriptor);\n\tiod_d = (GF_IsomInitialObjectDescriptor *) dest->moov->iods->descriptor;\n\twhile (gf_list_count(iod_d->ES_ID_IncDescriptors)) {\n\t\tGF_Descriptor *d = (GF_Descriptor *)gf_list_get(iod_d->ES_ID_IncDescriptors, 0);\n\t\tgf_list_rem(iod_d->ES_ID_IncDescriptors, 0);\n\t\tgf_odf_desc_del(d);\n\t}\n\twhile (gf_list_count(iod_d->ES_ID_RefDescriptors)) {\n\t\tGF_Descriptor *d = (GF_Descriptor *)gf_list_get(iod_d->ES_ID_RefDescriptors, 0);\n\t\tgf_list_rem(iod_d->ES_ID_RefDescriptors, 0);\n\t\tgf_odf_desc_del(d);\n\t}\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_clone_box(GF_Box *src, GF_Box **dst)\n{\n\tGF_Err e;\n\tu8 *data;\n\tu32 data_size;\n\tGF_BitStream *bs;\n\n\tif (*dst) {\n\t\tgf_isom_box_del(*dst);\n\t\t*dst=NULL;\n\t}\n\tbs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\tif (!bs) return GF_OUT_OF_MEM;\n\te = gf_isom_box_size( (GF_Box *) src);\n\tif (!e) e = gf_isom_box_write((GF_Box *) src, bs);\n\tgf_bs_get_content(bs, &data, &data_size);\n\tgf_bs_del(bs);\n\tif (e) {\n\t\tif (data) gf_free(data);\n\t\treturn e;\n\t}\n\tbs = gf_bs_new(data, data_size, GF_BITSTREAM_READ);\n\tif (!bs) {\n\t\tif (data) gf_free(data);\n\t\treturn GF_OUT_OF_MEM;\n\t}\n\te = gf_isom_box_parse(dst, bs);\n\tgf_bs_del(bs);\n\tgf_free(data);\n\treturn e;\n}\n\n#if 0 //unused\n/*clones the entire movie file to destination. Tracks can be cloned if clone_tracks is set, in which case hint tracks can be\nkept if keep_hint_tracks is set\nif keep_pssh, all pssh boxes will be kept\nfragment information (mvex) is not kept*/\nGF_Err gf_isom_clone_movie(GF_ISOFile *orig_file, GF_ISOFile *dest_file, Bool clone_tracks, Bool keep_hint_tracks, Bool keep_pssh)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_Box *box;\n\n\te = CanAccessMovie(dest_file, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\tif (orig_file->brand) {\n\t\tgf_list_del_item(dest_file->TopBoxes, dest_file->brand);\n\t\tgf_isom_box_del((GF_Box *)dest_file->brand);\n\t\tdest_file->brand = NULL;\n\t\tgf_isom_clone_box((GF_Box *)orig_file->brand, (GF_Box **)&dest_file->brand);\n\t\tif (dest_file->brand) gf_list_add(dest_file->TopBoxes, dest_file->brand);\n\t}\n\n\tif (orig_file->meta) {\n\t\tgf_list_del_item(dest_file->TopBoxes, dest_file->meta);\n\t\tgf_isom_box_del((GF_Box *)dest_file->meta);\n\t\tdest_file->meta = NULL;\n\t\t/*fixme - check imports*/\n\t\tgf_isom_clone_box((GF_Box *)orig_file->meta, (GF_Box **)&dest_file->meta);\n\t\tif (dest_file->meta) gf_list_add(dest_file->TopBoxes, dest_file->meta);\n\t}\n\tif (orig_file->moov) {\n\t\tu32 i, dstTrack;\n\t\tGF_Box *iods;\n\t\tGF_List *tracks = gf_list_new();\n\t\tGF_List *old_tracks = orig_file->moov->trackList;\n\t\torig_file->moov->trackList = tracks;\n\t\tiods = (GF_Box*)orig_file->moov->iods;\n\t\torig_file->moov->iods = NULL;\n\t\te = gf_isom_clone_box((GF_Box *)orig_file->moov, (GF_Box **)&dest_file->moov);\n\t\tif (e) {\n\t\t\tgf_list_del(tracks);\n\t\t\torig_file->moov->trackList = old_tracks;\n\t\t\treturn e;\n\t\t}\n\t\torig_file->moov->trackList = old_tracks;\n\t\tgf_list_del(tracks);\n\t\torig_file->moov->iods = (GF_ObjectDescriptorBox*)iods;\n\t\tgf_list_add(dest_file->TopBoxes, dest_file->moov);\n\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t\tif (dest_file->moov->mvex) {\n\t\t\tgf_isom_box_del_parent(&dest_file->moov->child_boxes, (GF_Box *)dest_file->moov->mvex);\n\t\t\tdest_file->moov->mvex = NULL;\n\t\t}\n#endif\n\n\t\tif (clone_tracks) {\n\t\t\tfor (i=0; i<gf_list_count(orig_file->moov->trackList); i++) {\n\t\t\t\tGF_TrackBox *trak = (GF_TrackBox*)gf_list_get( orig_file->moov->trackList, i);\n\t\t\t\tif (!trak) continue;\n\t\t\t\tif (keep_hint_tracks || (trak->Media->handler->handlerType != GF_ISOM_MEDIA_HINT)) {\n\t\t\t\t\te = gf_isom_clone_track(orig_file, i+1, dest_file, 0, &dstTrack);\n\t\t\t\t\tif (e) return e;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (iods)\n\t\t\t\tgf_isom_clone_box((GF_Box *)orig_file->moov->iods, (GF_Box **)dest_file->moov->iods);\n\t\t} else {\n\t\t\tdest_file->moov->mvhd->nextTrackID = 1;\n\t\t\tgf_isom_clone_pl_indications(orig_file, dest_file);\n\t\t}\n\t\tdest_file->moov->mov = dest_file;\n\t}\n\n\tif (!keep_pssh) {\n\t\ti=0;\n\t\twhile ((box = (GF_Box*)gf_list_get(dest_file->moov->child_boxes, i++))) {\n\t\t\tif (box->type == GF_ISOM_BOX_TYPE_PSSH) {\n\t\t\t\ti--;\n\t\t\t\tgf_isom_box_del_parent(&dest_file->moov->child_boxes, box);\n\t\t\t}\n\t\t}\n\t}\n\n\t//duplicate other boxes\n\ti=0;\n\twhile ((box = (GF_Box*)gf_list_get(orig_file->TopBoxes, i++))) {\n\t\tswitch(box->type) {\n\t\tcase GF_ISOM_BOX_TYPE_MOOV:\n\t\tcase GF_ISOM_BOX_TYPE_META:\n\t\tcase GF_ISOM_BOX_TYPE_MDAT:\n\t\tcase GF_ISOM_BOX_TYPE_FTYP:\n\t\tcase GF_ISOM_BOX_TYPE_PDIN:\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\t\tcase GF_ISOM_BOX_TYPE_STYP:\n\t\tcase GF_ISOM_BOX_TYPE_SIDX:\n\t\tcase GF_ISOM_BOX_TYPE_SSIX:\n\t\tcase GF_ISOM_BOX_TYPE_MOOF:\n#endif\n\t\tcase GF_ISOM_BOX_TYPE_JP:\n\t\t\tbreak;\n\n\t\tcase GF_ISOM_BOX_TYPE_PSSH:\n\t\t\tif (!keep_pssh)\n\t\t\t\tbreak;\n\n\t\tdefault:\n\t\t{\n\t\t\tGF_Box *box2 = NULL;\n\t\t\tgf_isom_clone_box(box, &box2);\n\t\t\tgf_list_add(dest_file->TopBoxes, box2);\n\t\t}\n\t\tbreak;\n\t\t}\n\t}\n\n\treturn GF_OK;\n}\n#endif\n\n\nGF_EXPORT\nGF_Err gf_isom_get_raw_user_data(GF_ISOFile *file, u8 **output, u32 *output_size)\n{\n\tGF_BitStream *bs;\n\tGF_Err e;\n\tGF_Box *b;\n\tu32 i;\n\n\t*output = NULL;\n\t*output_size = 0;\n\tif (!file || !file->moov || (!file->moov->udta && !file->moov->child_boxes)) return GF_OK;\n\tbs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\n\tif (file->moov->udta) {\n\t\te = gf_isom_box_size( (GF_Box *) file->moov->udta);\n\t\tif (e) goto exit;\n\t\te = gf_isom_box_write((GF_Box *) file->moov->udta, bs);\n\t\tif (e) goto exit;\n\t}\n\te = GF_OK;\n\ti=0;\n\twhile ((b = gf_list_enum(file->moov->child_boxes, &i))) {\n\t\tswitch (b->type) {\n\t\tcase GF_ISOM_BOX_TYPE_TRAK:\n\t\tcase GF_ISOM_BOX_TYPE_MVHD:\n\t\tcase GF_ISOM_BOX_TYPE_MVEX:\n\t\tcase GF_ISOM_BOX_TYPE_IODS:\n\t\tcase GF_ISOM_BOX_TYPE_META:\n\t\t\tcontinue;\n\t\t}\n\t\te = gf_isom_box_size( (GF_Box *) b);\n\t\tif (e) goto exit;\n\t\te = gf_isom_box_write((GF_Box *) b, bs);\n\t\tif (e) goto exit;\n\t}\n\n\tgf_bs_get_content(bs, output, output_size);\n\nexit:\n\tgf_bs_del(bs);\n\treturn e;\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_track_template(GF_ISOFile *file, u32 track, u8 **output, u32 *output_size)\n{\n\tGF_TrackBox *trak;\n\tGF_BitStream *bs;\n\tGF_DataReferenceBox *dref;\n\tGF_SampleTableBox *stbl, *stbl_temp;\n\tGF_SampleEncryptionBox *senc;\n\tu32 i, count;\n\n\t*output = NULL;\n\t*output_size = 0;\n\t/*get orig sample desc and clone it*/\n\ttrak = gf_isom_get_track_from_file(file, track);\n\tif (!trak || !trak->Media) return GF_BAD_PARAM;\n\n\t//don't serialize dref\n\tdref = NULL;\n\tif (trak->Media->information->dataInformation) {\n\t\tdref = trak->Media->information->dataInformation->dref;\n\t\ttrak->Media->information->dataInformation->dref = NULL;\n\t\tgf_list_del_item(trak->Media->information->dataInformation->child_boxes, dref);\n\t}\n\n\t//don't serialize stbl but create a temp one\n\tstbl_temp = (GF_SampleTableBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_STBL);\n\tif (!stbl_temp->child_boxes) stbl_temp->child_boxes = gf_list_new();\n\tstbl = trak->Media->information->sampleTable;\n\tgf_list_del_item(trak->Media->information->child_boxes, stbl);\n\n\ttrak->Media->information->sampleTable = stbl_temp;\n\tgf_list_add(trak->Media->information->child_boxes, stbl_temp);\n\n\t/*do not clone sampleDescription table but create an empty one*/\n\tstbl_temp->SampleDescription = (GF_SampleDescriptionBox *) gf_isom_box_new_parent(&stbl_temp->child_boxes, GF_ISOM_BOX_TYPE_STSD);\n\n\t/*clone sampleGroups description tables if any*/\n\tstbl_temp->sampleGroupsDescription = stbl->sampleGroupsDescription;\n\tcount = gf_list_count(stbl->sampleGroupsDescription);\n\tfor (i=0;i<count; i++) {\n\t\tGF_Box *b = gf_list_get(stbl->sampleGroupsDescription, i);\n\t\tgf_list_add(stbl_temp->child_boxes, b);\n\t}\n\t/*clone CompositionToDecode table, we may remove it later*/\n\tstbl_temp->CompositionToDecode = stbl->CompositionToDecode;\n\tgf_list_add(stbl_temp->child_boxes, stbl->CompositionToDecode);\n\n\n\t//don't serialize senc\n\tsenc = trak->sample_encryption;\n\tif (senc) {\n\t\tassert(trak->child_boxes);\n\t\tgf_list_del_item(trak->child_boxes, senc);\n\t\ttrak->sample_encryption = NULL;\n\t}\n\n\tbs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\n\tgf_isom_box_size( (GF_Box *) trak);\n\tgf_isom_box_write((GF_Box *) trak, bs);\n\tgf_bs_get_content(bs, output, output_size);\n\tgf_bs_del(bs);\n\n\t//restore our pointers\n\tif (dref) {\n\t\ttrak->Media->information->dataInformation->dref = dref;\n\t\tgf_list_add(trak->Media->information->dataInformation->child_boxes, dref);\n\t}\n\ttrak->Media->information->sampleTable = stbl;\n\tgf_list_add(trak->Media->information->child_boxes, stbl);\n\tgf_list_del_item(trak->Media->information->child_boxes, stbl_temp);\n\tif (senc) {\n\t\ttrak->sample_encryption = senc;\n\t\tgf_list_add(trak->child_boxes, senc);\n\t}\n\n\tstbl_temp->sampleGroupsDescription = NULL;\n\tcount = gf_list_count(stbl->sampleGroupsDescription);\n\tfor (i=0;i<count; i++) {\n\t\tGF_Box *b = gf_list_get(stbl->sampleGroupsDescription, i);\n\t\tgf_list_del_item(stbl_temp->child_boxes, b);\n\t}\n\n\tstbl_temp->CompositionToDecode = NULL;\n\tgf_list_del_item(stbl_temp->child_boxes, stbl->CompositionToDecode);\n\tgf_isom_box_del((GF_Box *)stbl_temp);\n\treturn GF_OK;\n\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_trex_template(GF_ISOFile *file, u32 track, u8 **output, u32 *output_size)\n{\n\tGF_TrackBox *trak;\n\tGF_BitStream *bs;\n\tu32 i;\n\tGF_TrackExtendsBox *trex = NULL;\n\tGF_TrackExtensionPropertiesBox *trexprop = NULL;\n\n\t*output = NULL;\n\t*output_size = 0;\n\t/*get orig sample desc and clone it*/\n\ttrak = gf_isom_get_track_from_file(file, track);\n\tif (!trak || !trak->Media) return GF_BAD_PARAM;\n\tif (!file->moov->mvex) return GF_NOT_FOUND;\n\tfor (i=0; i<gf_list_count(file->moov->mvex->TrackExList); i++) {\n\t\ttrex = gf_list_get(file->moov->mvex->TrackExList, i);\n\t\tif (trex->trackID == trak->Header->trackID) break;\n\t\ttrex = NULL;\n\t}\n\tif (!trex) return GF_NOT_FOUND;\n\n\tfor (i=0; i<gf_list_count(file->moov->mvex->TrackExPropList); i++) {\n\t\ttrexprop = gf_list_get(file->moov->mvex->TrackExPropList, i);\n\t\tif (trexprop->trackID== trak->Header->trackID) break;\n\t\ttrexprop = NULL;\n\t}\n\tbs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\tgf_isom_box_size( (GF_Box *) trex);\n\tgf_isom_box_write((GF_Box *) trex, bs);\n\n\tif (trexprop) {\n\t\tgf_isom_box_size( (GF_Box *) trexprop);\n\t\tgf_isom_box_write((GF_Box *) trexprop, bs);\n\t}\n\tgf_bs_get_content(bs, output, output_size);\n\tgf_bs_del(bs);\n\n\treturn GF_OK;\n\n}\n\nGF_EXPORT\nGF_Err gf_isom_get_stsd_template(GF_ISOFile *file, u32 track, u32 stsd_idx, u8 **output, u32 *output_size)\n{\n\tGF_TrackBox *trak;\n\tGF_BitStream *bs;\n\tGF_Box *ent;\n\n\t*output = NULL;\n\t*output_size = 0;\n\t/*get orig sample desc and clone it*/\n\ttrak = gf_isom_get_track_from_file(file, track);\n\tif (!trak || !stsd_idx || !trak->Media || !trak->Media->information || !trak->Media->information->sampleTable || !trak->Media->information->sampleTable->SampleDescription) return GF_BAD_PARAM;\n\n\tent = gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, stsd_idx-1);\n\tif (!ent) return GF_BAD_PARAM;\n\n\tbs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\n\tgf_isom_box_size( (GF_Box *) ent);\n\tgf_isom_box_write((GF_Box *) ent, bs);\n\tgf_bs_get_content(bs, output, output_size);\n\tgf_bs_del(bs);\n\treturn GF_OK;\n\n}\n\n\nGF_EXPORT\nGF_Err gf_isom_clone_track(GF_ISOFile *orig_file, u32 orig_track, GF_ISOFile *dest_file, GF_ISOTrackCloneFlags flags, u32 *dest_track)\n{\n\tGF_TrackBox *trak, *new_tk;\n\tGF_BitStream *bs;\n\tu8 *data;\n\tconst u8 *buffer;\n\tu32 data_size;\n\tu32 i, count;\n\tGF_Err e;\n\tGF_SampleTableBox *stbl, *stbl_temp;\n\tGF_SampleEncryptionBox *senc;\n\n\te = CanAccessMovie(dest_file, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\te = gf_isom_insert_moov(dest_file);\n\tif (e) return e;\n\n\t/*get orig sample desc and clone it*/\n\ttrak = gf_isom_get_track_from_file(orig_file, orig_track);\n\tif (!trak || !trak->Media) return GF_BAD_PARAM;\n\n\tstbl = trak->Media->information->sampleTable;\n\tstbl_temp = (GF_SampleTableBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_STBL);\n\tif (!stbl_temp->child_boxes) stbl_temp->child_boxes = gf_list_new();\n\n\ttrak->Media->information->sampleTable = stbl_temp;\n\tgf_list_add(trak->Media->information->child_boxes, stbl_temp);\n\tgf_list_del_item(trak->Media->information->child_boxes, stbl);\n\n\tif (!stbl_temp->child_boxes) stbl_temp->child_boxes = gf_list_new();\n\n\t/*clone sampleDescription table*/\n\tstbl_temp->SampleDescription = stbl->SampleDescription;\n\tgf_list_add(stbl_temp->child_boxes, stbl->SampleDescription);\n\t/*also clone sampleGroups description tables if any*/\n\tstbl_temp->sampleGroupsDescription = stbl->sampleGroupsDescription;\n\tcount = gf_list_count(stbl->sampleGroupsDescription);\n\tfor (i=0; i<count; i++) {\n\t\tGF_Box *b = gf_list_get(stbl->sampleGroupsDescription, i);\n\t\tgf_list_add(stbl_temp->child_boxes, b);\n\t}\n\t/*clone CompositionToDecode table, we may remove it later*/\n\tstbl_temp->CompositionToDecode = stbl->CompositionToDecode;\n\tgf_list_add(stbl_temp->child_boxes, stbl->CompositionToDecode);\n\n\tsenc = trak->sample_encryption;\n\tif (senc) {\n\t\tassert(trak->child_boxes);\n\t\tgf_list_del_item(trak->child_boxes, senc);\n\t\ttrak->sample_encryption = NULL;\n\t}\n\n\tbs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\n\tgf_isom_box_size( (GF_Box *) trak);\n\tgf_isom_box_write((GF_Box *) trak, bs);\n\tgf_bs_get_content(bs, &data, &data_size);\n\tgf_bs_del(bs);\n\tbs = gf_bs_new(data, data_size, GF_BITSTREAM_READ);\n\tif (flags & GF_ISOM_CLONE_TRACK_NO_QT)\n\t\tgf_bs_set_cookie(bs, GF_ISOM_BS_COOKIE_QT_CONV | GF_ISOM_BS_COOKIE_CLONE_TRACK);\n\telse\n\t\tgf_bs_set_cookie(bs, GF_ISOM_BS_COOKIE_CLONE_TRACK);\n\n\te = gf_isom_box_parse((GF_Box **) &new_tk, bs);\n\tgf_bs_del(bs);\n\tgf_free(data);\n\n\ttrak->Media->information->sampleTable = stbl;\n\tgf_list_del_item(trak->Media->information->child_boxes, stbl_temp);\n\tgf_list_add(trak->Media->information->child_boxes, stbl);\n\n\tif (senc) {\n\t\ttrak->sample_encryption = senc;\n\t\tgf_list_add(trak->child_boxes, senc);\n\t}\n\tgf_list_del_item(stbl_temp->child_boxes, stbl_temp->SampleDescription);\n\tstbl_temp->SampleDescription = NULL;\n\n\tcount = gf_list_count(stbl->sampleGroupsDescription);\n\tfor (i=0; i<count; i++) {\n\t\tGF_Box *b = gf_list_get(stbl->sampleGroupsDescription, i);\n\t\tgf_list_del_item(stbl_temp->child_boxes, b);\n\t}\n\tstbl_temp->sampleGroupsDescription = NULL;\n\n\tgf_list_del_item(stbl_temp->child_boxes, stbl_temp->CompositionToDecode);\n\tstbl_temp->CompositionToDecode = NULL;\n\tgf_isom_box_del((GF_Box *)stbl_temp);\n\n\tif (e) {\n\t\tif (new_tk) gf_isom_box_del((GF_Box *)new_tk);\n\t\treturn e;\n\t}\n\n\tgf_isom_disable_inplace_rewrite(dest_file);\n\n\t/*create default boxes*/\n\tstbl = new_tk->Media->information->sampleTable;\n\tstbl->ChunkOffset = gf_isom_box_new_parent(&stbl->child_boxes, GF_ISOM_BOX_TYPE_STCO);\n\tif (!stbl->ChunkOffset) return GF_OUT_OF_MEM;\n\tstbl->SampleSize = (GF_SampleSizeBox *) gf_isom_box_new_parent(&stbl->child_boxes, GF_ISOM_BOX_TYPE_STSZ);\n\tif (!stbl->SampleSize) return GF_OUT_OF_MEM;\n\tstbl->SampleToChunk = (GF_SampleToChunkBox *) gf_isom_box_new_parent(&stbl->child_boxes, GF_ISOM_BOX_TYPE_STSC);\n\tif (!stbl->SampleToChunk) return GF_OUT_OF_MEM;\n\tstbl->TimeToSample = (GF_TimeToSampleBox *) gf_isom_box_new_parent(&stbl->child_boxes, GF_ISOM_BOX_TYPE_STTS);\n\tif (!stbl->TimeToSample) return GF_OUT_OF_MEM;\n\n\t/*check trackID validity before adding track*/\n\tif (gf_isom_get_track_by_id(dest_file, new_tk->Header->trackID)) {\n\t\tu32 ID = 1;\n\t\twhile (1) {\n\t\t\tif (RequestTrack(dest_file->moov, ID)) break;\n\t\t\tID += 1;\n\t\t\tif (ID == 0xFFFFFFFF) break;\n\t\t}\n\t\tnew_tk->Header->trackID = ID;\n\t}\n\tif (!dest_file->moov->child_boxes) dest_file->moov->child_boxes = gf_list_new();\n\tgf_list_add(dest_file->moov->child_boxes, new_tk);\n\tmoov_on_child_box((GF_Box*)dest_file->moov, (GF_Box *)new_tk, GF_FALSE);\n\n\t/*set originalID*/\n\tnew_tk->originalID = trak->Header->trackID;\n\t/*set originalFile*/\n\tbuffer = gf_isom_get_filename(orig_file);\n\tnew_tk->originalFile = gf_crc_32(buffer, (u32) strlen(buffer));\n\n\t/*rewrite edit list segmentDuration to new movie timescale*/\n\tif (dest_file->moov->mvhd->timeScale != orig_file->moov->mvhd->timeScale) {\n\t\tDouble ts_scale = dest_file->moov->mvhd->timeScale;\n\t\tts_scale /= orig_file->moov->mvhd->timeScale;\n\t\tnew_tk->Header->duration = (u64) (new_tk->Header->duration * ts_scale);\n\t\tif (new_tk->editBox && new_tk->editBox->editList) {\n\t\t\tcount = gf_list_count(new_tk->editBox->editList->entryList);\n\t\t\tfor (i=0; i<count; i++) {\n\t\t\t\tGF_EdtsEntry *ent = (GF_EdtsEntry *)gf_list_get(new_tk->editBox->editList->entryList, i);\n\t\t\t\tent->segmentDuration = (u64) (ent->segmentDuration * ts_scale);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!new_tk->Media->information->dataInformation->dref) return GF_BAD_PARAM;\n\n\t/*reset data ref*/\n\tif (! (flags & GF_ISOM_CLONE_TRACK_KEEP_DREF) ) {\n\t\tGF_SampleEntryBox *entry;\n\t\tBool use_alis = GF_FALSE;\n\t\tif (! (flags & GF_ISOM_CLONE_TRACK_NO_QT)) {\n\t\t\tGF_Box *b = gf_list_get(new_tk->Media->information->dataInformation->dref->child_boxes, 0);\n\t\t\tif (b && b->type==GF_QT_BOX_TYPE_ALIS)\n\t\t\t\tuse_alis = GF_TRUE;\n\t\t}\n\t\tgf_isom_box_array_del(new_tk->Media->information->dataInformation->dref->child_boxes);\n\t\tnew_tk->Media->information->dataInformation->dref->child_boxes = gf_list_new();\n\t\t/*update data ref*/\n\t\tentry = (GF_SampleEntryBox*)gf_list_get(new_tk->Media->information->sampleTable->SampleDescription->child_boxes, 0);\n\t\tif (entry) {\n\t\t\tu32 dref;\n\t\t\tMedia_CreateDataRef(dest_file, new_tk->Media->information->dataInformation->dref, use_alis ?  \"alis\" : NULL, NULL, &dref);\n\t\t\tentry->dataReferenceIndex = dref;\n\t\t}\n\t} else {\n\t\tfor (i=0; i<gf_list_count(new_tk->Media->information->dataInformation->dref->child_boxes); i++) {\n\t\t\tGF_DataEntryBox *dref_entry = (GF_DataEntryBox *)gf_list_get(new_tk->Media->information->dataInformation->dref->child_boxes, i);\n\t\t\tif (dref_entry->flags & 1) {\n\t\t\t\tdref_entry->flags &= ~1;\n\t\t\t\te = Media_SetDrefURL((GF_DataEntryURLBox *)dref_entry, orig_file->fileName, dest_file->finalName);\n\t\t\t\tif (e) return e;\n\t\t\t}\n\t\t}\n\t}\n\n\t*dest_track = gf_list_count(dest_file->moov->trackList);\n\n\tif (dest_file->moov->mvhd->nextTrackID<= new_tk->Header->trackID)\n\t\tdest_file->moov->mvhd->nextTrackID = new_tk->Header->trackID+1;\n\n\treturn GF_OK;\n}\n\n#if 0\n/*clones all sampleDescription entries in new track, after an optional reset of existing entries*/\nGF_Err gf_isom_clone_sample_descriptions(GF_ISOFile *the_file, u32 trackNumber, GF_ISOFile *orig_file, u32 orig_track, Bool reset_existing)\n{\n\tu32 i;\n\tGF_TrackBox *dst_trak, *src_trak;\n\tGF_Err e = CanAccessMovie(the_file, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\tdst_trak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!dst_trak || !dst_trak->Media) return GF_BAD_PARAM;\n\tsrc_trak = gf_isom_get_track_from_file(orig_file, orig_track);\n\tif (!src_trak || !src_trak->Media) return GF_BAD_PARAM;\n\n\tif (reset_existing) {\n\t\tgf_isom_box_array_del(dst_trak->Media->information->sampleTable->SampleDescription->child_boxes);\n\t\tdst_trak->Media->information->sampleTable->SampleDescription->child_boxes = gf_list_new();\n\t}\n\n\tfor (i=0; i<gf_list_count(src_trak->Media->information->sampleTable->SampleDescription->child_boxes); i++) {\n\t\tu32 outDesc;\n\t\te = gf_isom_clone_sample_description(the_file, trackNumber, orig_file, orig_track, i+1, NULL, NULL, &outDesc);\n\t\tif (e) break;\n\t}\n\treturn e;\n}\n#endif\n\n\nGF_EXPORT\nGF_Err gf_isom_clone_sample_description(GF_ISOFile *the_file, u32 trackNumber, GF_ISOFile *orig_file, u32 orig_track, u32 orig_desc_index, const char *URLname, const char *URNname, u32 *outDescriptionIndex)\n{\n\tGF_TrackBox *trak;\n\tGF_BitStream *bs;\n\tu8 *data;\n\tu32 data_size;\n\tGF_Box *entry;\n\tGF_Err e;\n\tu32 dataRefIndex;\n    u32 mtype;\n\n\te = CanAccessMovie(the_file, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\t/*get orig sample desc and clone it*/\n\ttrak = gf_isom_get_track_from_file(orig_file, orig_track);\n\tif (!trak || !trak->Media) return GF_BAD_PARAM;\n\n\tentry = (GF_Box*)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, orig_desc_index-1);\n\tif (!entry) return GF_BAD_PARAM;\n\n\tbs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\n\tgf_isom_box_size(entry);\n\tgf_isom_box_write(entry, bs);\n\tgf_bs_get_content(bs, &data, &data_size);\n\tgf_bs_del(bs);\n\tbs = gf_bs_new(data, data_size, GF_BITSTREAM_READ);\n\te = gf_isom_box_parse(&entry, bs);\n\tgf_bs_del(bs);\n\tgf_free(data);\n\tif (e) return e;\n\n\t/*get new track and insert clone*/\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media) goto exit;\n\n\t/*get or create the data ref*/\n\te = Media_FindDataRef(trak->Media->information->dataInformation->dref, (char *)URLname, (char *)URNname, &dataRefIndex);\n\tif (e) goto exit;\n\tif (!dataRefIndex) {\n\t\te = Media_CreateDataRef(the_file, trak->Media->information->dataInformation->dref, (char *)URLname, (char *)URNname, &dataRefIndex);\n\t\tif (e) goto exit;\n\t}\n\tif (!the_file->keep_utc)\n\t\ttrak->Media->mediaHeader->modificationTime = gf_isom_get_mp4time();\n\t/*overwrite dref*/\n\t((GF_SampleEntryBox *)entry)->dataReferenceIndex = dataRefIndex;\n\te = gf_list_add(trak->Media->information->sampleTable->SampleDescription->child_boxes, entry);\n\t*outDescriptionIndex = gf_list_count(trak->Media->information->sampleTable->SampleDescription->child_boxes);\n\n\t/*also clone track w/h info*/\n    mtype = gf_isom_get_media_type(the_file, trackNumber);\n\tif (gf_isom_is_video_handler_type(mtype) ) {\n\t\tgf_isom_set_visual_info(the_file, trackNumber, (*outDescriptionIndex), ((GF_VisualSampleEntryBox*)entry)->Width, ((GF_VisualSampleEntryBox*)entry)->Height);\n\t}\n\treturn e;\n\nexit:\n\tgf_isom_box_del(entry);\n\treturn e;\n}\n\nGF_EXPORT\nGF_Err gf_isom_new_generic_sample_description(GF_ISOFile *movie, u32 trackNumber, const char *URLname, const char *URNname, GF_GenericSampleDescription *udesc, u32 *outDescriptionIndex)\n{\n\tGF_TrackBox *trak;\n\tGF_Err e;\n\tu32 dataRefIndex;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !trak->Media || !udesc) return GF_BAD_PARAM;\n\n\t//get or create the data ref\n\te = Media_FindDataRef(trak->Media->information->dataInformation->dref, (char *)URLname, (char *)URNname, &dataRefIndex);\n\tif (e) return e;\n\tif (!dataRefIndex) {\n\t\te = Media_CreateDataRef(movie, trak->Media->information->dataInformation->dref, (char *)URLname, (char *)URNname, &dataRefIndex);\n\t\tif (e) return e;\n\t}\n\tif (!movie->keep_utc)\n\t\ttrak->Media->mediaHeader->modificationTime = gf_isom_get_mp4time();\n\n\tif (gf_isom_is_video_handler_type(trak->Media->handler->handlerType)) {\n\t\tGF_GenericVisualSampleEntryBox *entry;\n\t\t//create a new entry\n\t\tentry = (GF_GenericVisualSampleEntryBox*) gf_isom_box_new(GF_ISOM_BOX_TYPE_GNRV);\n\t\tif (!entry) return GF_OUT_OF_MEM;\n\n\t\tif (!udesc->codec_tag) {\n\t\t\tentry->EntryType = GF_ISOM_BOX_TYPE_UUID;\n\t\t\tmemcpy(entry->uuid, udesc->UUID, sizeof(bin128));\n\t\t} else {\n\t\t\tentry->EntryType = udesc->codec_tag;\n\t\t}\n\t\tif (entry->EntryType == 0) {\n\t\t\tgf_isom_box_del((GF_Box *)entry);\n\t\t\treturn GF_NOT_SUPPORTED;\n\t\t}\n\n\t\tentry->dataReferenceIndex = dataRefIndex;\n\t\tentry->vendor = udesc->vendor_code;\n\t\tentry->version = udesc->version;\n\t\tentry->revision = udesc->revision;\n\t\tentry->temporal_quality = udesc->temporal_quality;\n\t\tentry->spatial_quality = udesc->spatial_quality;\n\t\tentry->Width = udesc->width;\n\t\tentry->Height = udesc->height;\n\t\tstrcpy(entry->compressor_name, udesc->compressor_name);\n\t\tentry->color_table_index = -1;\n\t\tentry->frames_per_sample = 1;\n\t\tentry->horiz_res = udesc->h_res ? udesc->h_res : 0x00480000;\n\t\tentry->vert_res = udesc->v_res ? udesc->v_res : 0x00480000;\n\t\tentry->bit_depth = udesc->depth ? udesc->depth : 0x18;\n\t\tif (udesc->extension_buf && udesc->extension_buf_size) {\n\t\t\tentry->data = (char*)gf_malloc(sizeof(char) * udesc->extension_buf_size);\n\t\t\tif (!entry->data) {\n\t\t\t\tgf_isom_box_del((GF_Box *) entry);\n\t\t\t\treturn GF_OUT_OF_MEM;\n\t\t\t}\n\t\t\tmemcpy(entry->data, udesc->extension_buf, udesc->extension_buf_size);\n\t\t\tentry->data_size = udesc->extension_buf_size;\n\t\t}\n\t\te = gf_list_add(trak->Media->information->sampleTable->SampleDescription->child_boxes, entry);\n\t}\n\telse if (trak->Media->handler->handlerType==GF_ISOM_MEDIA_AUDIO) {\n\t\tGF_GenericAudioSampleEntryBox *gena;\n\t\t//create a new entry\n\t\tgena = (GF_GenericAudioSampleEntryBox*) gf_isom_box_new(GF_ISOM_BOX_TYPE_GNRA);\n\t\tif (!gena) return GF_OUT_OF_MEM;\n\n\t\tif (!udesc->codec_tag) {\n\t\t\tgena->EntryType = GF_ISOM_BOX_TYPE_UUID;\n\t\t\tmemcpy(gena->uuid, udesc->UUID, sizeof(bin128));\n\t\t} else {\n\t\t\tgena->EntryType = udesc->codec_tag;\n\t\t}\n\t\tif (gena->EntryType == 0) {\n\t\t\tgf_isom_box_del((GF_Box *)gena);\n\t\t\treturn GF_NOT_SUPPORTED;\n\t\t}\n\n\t\tgena->dataReferenceIndex = dataRefIndex;\n\t\tgena->vendor = udesc->vendor_code;\n\t\tgena->version = udesc->version;\n\t\tgena->revision = udesc->revision;\n\t\tgena->bitspersample = udesc->bits_per_sample ? udesc->bits_per_sample : 16;\n\t\tgena->channel_count = udesc->nb_channels ? udesc->nb_channels : 2;\n\t\tgena->samplerate_hi = udesc->samplerate;\n\t\tgena->samplerate_lo = 0;\n\t\tgena->qtff_mode = udesc->is_qtff ? GF_ISOM_AUDIO_QTFF_ON_NOEXT : GF_ISOM_AUDIO_QTFF_NONE;\n\n\t\tif (udesc->extension_buf && udesc->extension_buf_size) {\n\t\t\tgena->data = (char*)gf_malloc(sizeof(char) * udesc->extension_buf_size);\n\t\t\tif (!gena->data) {\n\t\t\t\tgf_isom_box_del((GF_Box *) gena);\n\t\t\t\treturn GF_OUT_OF_MEM;\n\t\t\t}\n\t\t\tmemcpy(gena->data, udesc->extension_buf, udesc->extension_buf_size);\n\t\t\tgena->data_size = udesc->extension_buf_size;\n\t\t}\n\t\te = gf_list_add(trak->Media->information->sampleTable->SampleDescription->child_boxes, gena);\n\t}\n\telse {\n\t\tGF_GenericSampleEntryBox *genm;\n\t\t//create a new entry\n\t\tgenm = (GF_GenericSampleEntryBox*) gf_isom_box_new(GF_ISOM_BOX_TYPE_GNRM);\n\t\tif (!genm) return GF_OUT_OF_MEM;\n\n\t\tif (!udesc->codec_tag) {\n\t\t\tgenm->EntryType = GF_ISOM_BOX_TYPE_UUID;\n\t\t\tmemcpy(genm->uuid, udesc->UUID, sizeof(bin128));\n\t\t} else {\n\t\t\tgenm->EntryType = udesc->codec_tag;\n\t\t}\n\t\tif (genm->EntryType == 0) {\n\t\t\tgf_isom_box_del((GF_Box *)genm);\n\t\t\treturn GF_NOT_SUPPORTED;\n\t\t}\n\n\t\tgenm->dataReferenceIndex = dataRefIndex;\n\t\tif (udesc->extension_buf && udesc->extension_buf_size) {\n\t\t\tgenm->data = (char*)gf_malloc(sizeof(char) * udesc->extension_buf_size);\n\t\t\tif (!genm->data) {\n\t\t\t\tgf_isom_box_del((GF_Box *) genm);\n\t\t\t\treturn GF_OUT_OF_MEM;\n\t\t\t}\n\t\t\tmemcpy(genm->data, udesc->extension_buf, udesc->extension_buf_size);\n\t\t\tgenm->data_size = udesc->extension_buf_size;\n\t\t}\n\t\te = gf_list_add(trak->Media->information->sampleTable->SampleDescription->child_boxes, genm);\n\t}\n\t*outDescriptionIndex = gf_list_count(trak->Media->information->sampleTable->SampleDescription->child_boxes);\n\treturn e;\n}\n\n//use carefully. Very useful when you made a lot of changes (IPMP, IPI, OCI, ...)\n//THIS WILL REPLACE THE WHOLE DESCRIPTOR ...\n#if 0 //unused\n/*change the data field of an unknown sample description*/\nGF_Err gf_isom_change_generic_sample_description(GF_ISOFile *movie, u32 trackNumber, u32 StreamDescriptionIndex, GF_GenericSampleDescription *udesc)\n{\n\tGF_TrackBox *trak;\n\tGF_Err e;\n\tGF_GenericVisualSampleEntryBox *entry;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !trak->Media || !StreamDescriptionIndex) return GF_BAD_PARAM;\n\n\tentry = (GF_GenericVisualSampleEntryBox *)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, StreamDescriptionIndex-1);\n\tif (!entry) return GF_BAD_PARAM;\n\tif (entry->type == GF_ISOM_BOX_TYPE_GNRV) {\n\t\tentry->vendor = udesc->vendor_code;\n\t\tentry->version = udesc->version;\n\t\tentry->revision = udesc->revision;\n\t\tentry->temporal_quality = udesc->temporal_quality;\n\t\tentry->spatial_quality = udesc->spatial_quality;\n\t\tentry->Width = udesc->width;\n\t\tentry->Height = udesc->height;\n\t\tstrcpy(entry->compressor_name, udesc->compressor_name);\n\t\tentry->color_table_index = -1;\n\t\tentry->frames_per_sample = 1;\n\t\tentry->horiz_res = udesc->h_res ? udesc->h_res : 0x00480000;\n\t\tentry->vert_res = udesc->v_res ? udesc->v_res : 0x00480000;\n\t\tentry->bit_depth = udesc->depth ? udesc->depth : 0x18;\n\t\tif (entry->data) gf_free(entry->data);\n\t\tentry->data = NULL;\n\t\tentry->data_size = 0;\n\t\tif (udesc->extension_buf && udesc->extension_buf_size) {\n\t\t\tentry->data = (char*)gf_malloc(sizeof(char) * udesc->extension_buf_size);\n\t\t\tif (!entry->data) {\n\t\t\t\tgf_isom_box_del((GF_Box *) entry);\n\t\t\t\treturn GF_OUT_OF_MEM;\n\t\t\t}\n\t\t\tmemcpy(entry->data, udesc->extension_buf, udesc->extension_buf_size);\n\t\t\tentry->data_size = udesc->extension_buf_size;\n\t\t}\n\t\treturn GF_OK;\n\t} else if (entry->type == GF_ISOM_BOX_TYPE_GNRA) {\n\t\tGF_GenericAudioSampleEntryBox *gena = (GF_GenericAudioSampleEntryBox *)entry;\n\t\tgena->vendor = udesc->vendor_code;\n\t\tgena->version = udesc->version;\n\t\tgena->revision = udesc->revision;\n\t\tgena->bitspersample = udesc->bits_per_sample ? udesc->bits_per_sample : 16;\n\t\tgena->channel_count = udesc->nb_channels ? udesc->nb_channels : 2;\n\t\tgena->samplerate_hi = udesc->samplerate;\n\t\tgena->samplerate_lo = 0;\n\t\tif (gena->data) gf_free(gena->data);\n\t\tgena->data = NULL;\n\t\tgena->data_size = 0;\n\n\t\tif (udesc->extension_buf && udesc->extension_buf_size) {\n\t\t\tgena->data = (char*)gf_malloc(sizeof(char) * udesc->extension_buf_size);\n\t\t\tif (!gena->data) {\n\t\t\t\tgf_isom_box_del((GF_Box *) gena);\n\t\t\t\treturn GF_OUT_OF_MEM;\n\t\t\t}\n\t\t\tmemcpy(gena->data, udesc->extension_buf, udesc->extension_buf_size);\n\t\t\tgena->data_size = udesc->extension_buf_size;\n\t\t}\n\t\treturn GF_OK;\n\t} else if (entry->type == GF_ISOM_BOX_TYPE_GNRM) {\n\t\tGF_GenericSampleEntryBox *genm = (GF_GenericSampleEntryBox *)entry;\n\t\tif (genm->data) gf_free(genm->data);\n\t\tgenm->data = NULL;\n\t\tgenm->data_size = 0;\n\n\t\tif (udesc->extension_buf && udesc->extension_buf_size) {\n\t\t\tgenm->data = (char*)gf_malloc(sizeof(char) * udesc->extension_buf_size);\n\t\t\tif (!genm->data) {\n\t\t\t\tgf_isom_box_del((GF_Box *) genm);\n\t\t\t\treturn GF_OUT_OF_MEM;\n\t\t\t}\n\t\t\tmemcpy(genm->data, udesc->extension_buf, udesc->extension_buf_size);\n\t\t\tgenm->data_size = udesc->extension_buf_size;\n\t\t}\n\t\treturn GF_OK;\n\t}\n\treturn GF_BAD_PARAM;\n}\n#endif\n\n#if 0\n/*removes given stream description*/\nGF_Err gf_isom_remove_sample_description(GF_ISOFile *movie, u32 trackNumber, u32 streamDescIndex)\n{\n\tGF_TrackBox *trak;\n\tGF_Err e;\n\tGF_Box *entry;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !trak->Media || !streamDescIndex) return GF_BAD_PARAM;\n\tentry = (GF_Box*)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, streamDescIndex-1);\n\tif (!entry) return GF_BAD_PARAM;\n\tgf_list_rem(trak->Media->information->sampleTable->SampleDescription->child_boxes, streamDescIndex-1);\n\tgf_isom_box_del(entry);\n\treturn GF_OK;\n}\n#endif\n\n//sets a track reference\nGF_EXPORT\nGF_Err gf_isom_set_track_reference(GF_ISOFile *the_file, u32 trackNumber, u32 referenceType, GF_ISOTrackID ReferencedTrackID)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\tGF_TrackReferenceBox *tref;\n\tGF_TrackReferenceTypeBox *dpnd;\n\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\t//no tref, create one\n\ttref = trak->References;\n\tif (!tref) {\n\t\ttref = (GF_TrackReferenceBox *) gf_isom_box_new_parent(&trak->child_boxes, GF_ISOM_BOX_TYPE_TREF);\n\t\tif (!tref) return GF_OUT_OF_MEM;\n\t\te = trak_on_child_box((GF_Box*)trak, (GF_Box *) tref, GF_FALSE);\n\t\tif (e) return e;\n\t}\n\t//find a ref of the given type\n\te = Track_FindRef(trak, referenceType, &dpnd);\n\tif (e) return e;\n\n\tif (!dpnd) {\n\t\tdpnd = (GF_TrackReferenceTypeBox *) gf_isom_box_new_parent(&tref->child_boxes, GF_ISOM_BOX_TYPE_REFT);\n\t\tif (!dpnd) return GF_OUT_OF_MEM;\n\t\tdpnd->reference_type = referenceType;\n\t}\n\t//add the ref\n\treturn reftype_AddRefTrack(dpnd, ReferencedTrackID, NULL);\n}\n\nGF_EXPORT\nGF_Err gf_isom_purge_track_reference(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\tGF_TrackReferenceTypeBox *ref;\n\tu32 i=0;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\t//no tref, nothing to remove\n\tif (!trak->References) return GF_OK;\n\n\twhile ((ref = gf_list_enum(trak->References->child_boxes, &i))) {\n\t\tu32 k;\n\t\tif (!ref->reference_type) continue;\n\n\t\tfor (k=0; k<ref->trackIDCount; k++) {\n\t\t\tu32 tk = gf_isom_get_track_by_id(the_file, ref->trackIDs[k]);\n\t\t\tif (!tk) {\n\t\t\t\tmemmove(&ref->trackIDs[k], &ref->trackIDs[k+1], ref->trackIDCount-k-1);\n\t\t\t\tk--;\n\t\t\t\tref->trackIDCount--;\n\t\t\t}\n\t\t}\n\t\tif (!ref->trackIDCount) {\n\t\t\ti--;\n\t\t\tgf_isom_box_del_parent(&trak->References->child_boxes, (GF_Box *) ref);\n\t\t}\n\t}\n\tif (!trak->References->child_boxes || !gf_list_count(trak->References->child_boxes)) {\n\t\tgf_isom_box_del_parent(&trak->child_boxes, (GF_Box *) trak->References);\n\t\ttrak->References = NULL;\n\t}\n\treturn GF_OK;\n}\n\n//sets a track reference\nGF_EXPORT\nGF_Err gf_isom_remove_track_references(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tif (trak->References) {\n\t\tgf_isom_box_del_parent(&trak->child_boxes, (GF_Box *)trak->References);\n\t\ttrak->References = NULL;\n\t}\n\treturn GF_OK;\n}\n\nGF_Err gf_isom_remove_track_reference(GF_ISOFile *isom_file, u32 trackNumber, u32 ref_type)\n{\n\tGF_TrackBox *trak;\n\tu32 i=0;\n\tGF_TrackReferenceTypeBox *ref;\n\ttrak = gf_isom_get_track_from_file(isom_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tif (!trak->References) return GF_OK;\n\twhile ((ref = gf_list_enum(trak->References->child_boxes, &i))) {\n\t\tif (ref->reference_type == ref_type) {\n\t\t\tgf_isom_box_del_parent(&trak->References->child_boxes, (GF_Box *)ref);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn GF_OK;\n\n}\n\n//changes track ID\nGF_EXPORT\nGF_Err gf_isom_set_track_id(GF_ISOFile *movie, u32 trackNumber, GF_ISOTrackID trackID)\n{\n\tGF_TrackReferenceTypeBox *ref;\n\tGF_TrackBox *trak, *a_trak;\n\tu32 i, j, k;\n\n\tif (!movie) return GF_BAD_PARAM;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (trak && (trak->Header->trackID==trackID)) return GF_OK;\n\ta_trak = gf_isom_get_track_from_id(movie->moov, trackID);\n\tif (!trak || a_trak) return GF_BAD_PARAM;\n\n\tif (movie->moov->mvhd->nextTrackID<=trackID)\n\t\tmovie->moov->mvhd->nextTrackID = trackID;\n\n\t/*rewrite all dependencies*/\n\ti=0;\n\twhile ((a_trak = (GF_TrackBox*)gf_list_enum(movie->moov->trackList, &i))) {\n\t\tif (!a_trak->References) continue;\n\t\tj=0;\n\t\twhile ((ref = (GF_TrackReferenceTypeBox *)gf_list_enum(a_trak->References->child_boxes, &j))) {\n\t\t\tfor (k=0; k<ref->trackIDCount; k++) {\n\t\t\t\tif (ref->trackIDs[k]==trak->Header->trackID) {\n\t\t\t\t\tref->trackIDs[k] = trackID;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/*and update IOD if any*/\n\tif (movie->moov->iods && movie->moov->iods->descriptor) {\n\t\tGF_ES_ID_Inc *inc;\n\t\tGF_IsomObjectDescriptor *od = (GF_IsomObjectDescriptor *)movie->moov->iods->descriptor;\n\n\t\ti=0;\n\t\twhile ((inc = (GF_ES_ID_Inc*)gf_list_enum(od->ES_ID_IncDescriptors, &i))) {\n\t\t\tif (inc->trackID==trak->Header->trackID) inc->trackID = trackID;\n\t\t}\n\t}\n\ttrak->Header->trackID = trackID;\n\treturn GF_OK;\n}\n\n/*force to rewrite all dependencies when the trackID of referenced track changes*/\nGF_EXPORT\nGF_Err gf_isom_rewrite_track_dependencies(GF_ISOFile *movie, u32 trackNumber)\n{\n\tGF_TrackReferenceTypeBox *ref;\n\tGF_TrackBox *trak, *a_trak;\n\tu32 i, k;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak)\n\t\treturn GF_BAD_PARAM;\n\tif (!trak->References)\n\t\treturn GF_OK;\n\n\ti=0;\n\twhile ((ref = (GF_TrackReferenceTypeBox *)gf_list_enum(trak->References->child_boxes, &i))) {\n\t\tfor (k=0; k < ref->trackIDCount; k++) {\n\t\t\ta_trak = gf_isom_get_track_from_original_id(movie->moov, ref->trackIDs[k], trak->originalFile);\n\t\t\tif (a_trak) {\n\t\t\t\tref->trackIDs[k] = a_trak->Header->trackID;\n\t\t\t} else {\n\t\t\t\ta_trak = gf_isom_get_track_from_id(movie->moov, ref->trackIDs[k]);\n\t\t\t\t/*we should have a track with no original ID (not imported) - should we rewrite the dependency ?*/\n\t\t\t\tif (! a_trak || a_trak->originalID) return GF_BAD_PARAM;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn GF_OK;\n}\n\n#if 0 //unused\n\n/*! changes the sample description index of a sample\n\\param isom_file the destination ISO file\n\\param trackNumber the destination track\n\\param sampleNum the target sample number\n\\param fnewSampleDescIndex the new sample description index to assign to the sample\n\\return error if any\n*/\nGF_EXPORT\nGF_Err gf_isom_change_sample_desc_index(GF_ISOFile *the_file, u32 trackNumber, u32 sample_number, u32 newSampleDescIndex)\n{\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !sample_number || !newSampleDescIndex) return GF_BAD_PARAM;\n\tif (!trak->is_unpacked) {\n\t\tunpack_track(trak);\n\t}\n\tif (!trak->Media->information->sampleTable->SampleToChunk) return GF_BAD_PARAM;\n\tif (trak->Media->information->sampleTable->SampleToChunk->nb_entries < sample_number) return GF_BAD_PARAM;\n\ttrak->Media->information->sampleTable->SampleToChunk->entries[sample_number-1].sampleDescriptionIndex = newSampleDescIndex;\n\treturn GF_OK;\n}\n\n/*modify CTS offset of a given sample (used for B-frames) - MUST be called in unpack mode only*/\nGF_EXPORT\nGF_Err gf_isom_modify_cts_offset(GF_ISOFile *the_file, u32 trackNumber, u32 sample_number, u32 offset)\n{\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\tif (!trak->Media->information->sampleTable->CompositionOffset) return GF_BAD_PARAM;\n\tif (!trak->Media->information->sampleTable->CompositionOffset->unpack_mode) return GF_BAD_PARAM;\n\t/*we're in unpack mode: one entry per sample*/\n\ttrak->Media->information->sampleTable->CompositionOffset->entries[sample_number - 1].decodingOffset = offset;\n\treturn GF_OK;\n}\n#endif\n\nGF_EXPORT\nGF_Err gf_isom_shift_cts_offset(GF_ISOFile *the_file, u32 trackNumber, s32 offset_shift)\n{\n\tu32 i;\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\tif (!trak->Media->information->sampleTable->CompositionOffset) return GF_BAD_PARAM;\n\tif (!trak->Media->information->sampleTable->CompositionOffset->unpack_mode) return GF_BAD_PARAM;\n\n\tfor (i=0; i<trak->Media->information->sampleTable->CompositionOffset->nb_entries; i++) {\n\t\t/*we're in unpack mode: one entry per sample*/\n\t\ttrak->Media->information->sampleTable->CompositionOffset->entries[i].decodingOffset -= offset_shift;\n\t}\n\treturn GF_OK;\n}\n\n#if 0 //unused\nGF_Err gf_isom_remove_cts_info(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_SampleTableBox *stbl;\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tstbl = trak->Media->information->sampleTable;\n\tif (!stbl->CompositionOffset) return GF_OK;\n\n\tgf_isom_box_del_parent(&stbl->child_boxes, (GF_Box *)stbl->CompositionOffset);\n\tstbl->CompositionOffset = NULL;\n\treturn GF_OK;\n}\n#endif\n\nGF_EXPORT\nGF_Err gf_isom_set_cts_packing(GF_ISOFile *the_file, u32 trackNumber, Bool unpack)\n{\n\tGF_Err e;\n\tGF_Err stbl_repackCTS(GF_CompositionOffsetBox *ctts);\n\tGF_Err stbl_unpackCTS(GF_SampleTableBox *stbl);\n\tGF_SampleTableBox *stbl;\n\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tstbl = trak->Media->information->sampleTable;\n\tif (unpack) {\n\t\tif (!stbl->CompositionOffset) {\n\t\t\tstbl->CompositionOffset = (GF_CompositionOffsetBox *) gf_isom_box_new_parent(&stbl->child_boxes, GF_ISOM_BOX_TYPE_CTTS);\n\t\t\tif (!stbl->CompositionOffset) return GF_OUT_OF_MEM;\n\t\t}\n\t\te = stbl_unpackCTS(stbl);\n\t} else {\n\t\tif (!stbl->CompositionOffset) return GF_OK;\n\t\te = stbl_repackCTS(stbl->CompositionOffset);\n\t}\n\tif (e) return e;\n\treturn SetTrackDuration(trak);\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_track_matrix(GF_ISOFile *the_file, u32 trackNumber, s32 matrix[9])\n{\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Header) return GF_BAD_PARAM;\n\tmemcpy(trak->Header->matrix, matrix, sizeof(trak->Header->matrix));\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_track_layout_info(GF_ISOFile *the_file, u32 trackNumber, u32 width, u32 height, s32 translation_x, s32 translation_y, s16 layer)\n{\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Header) return GF_BAD_PARAM;\n\ttrak->Header->width = width;\n\ttrak->Header->height = height;\n\ttrak->Header->matrix[6] = translation_x;\n\ttrak->Header->matrix[7] = translation_y;\n\ttrak->Header->layer = layer;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_media_timescale(GF_ISOFile *the_file, u32 trackNumber, u32 newTS, u32 new_tsinc, u32 force_rescale_type)\n{\n\tDouble scale;\n\tu32 old_ts_inc=0;\n\tu32 old_timescale;\n\tGF_TrackBox *trak;\n\tGF_SampleTableBox *stbl;\n\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media || !trak->Media->mediaHeader) return GF_BAD_PARAM;\n\tif ((trak->Media->mediaHeader->timeScale==newTS) && !new_tsinc)\n\t\treturn GF_EOS;\n\n\tif (!newTS) newTS = trak->Media->mediaHeader->timeScale;\n\tscale = newTS;\n\tscale /= trak->Media->mediaHeader->timeScale;\n\told_timescale = trak->Media->mediaHeader->timeScale;\n\ttrak->Media->mediaHeader->timeScale = newTS;\n\n\tstbl = trak->Media->information->sampleTable;\n\tif (new_tsinc) {\n\t\tu32 i;\n\t\tif (!stbl->TimeToSample || !stbl->TimeToSample->nb_entries)\n\t\t\treturn GF_BAD_PARAM;\n\n\t\tfor (i=0; i<stbl->TimeToSample->nb_entries; i++) {\n\t\t\tif (!old_ts_inc)\n\t\t\t\told_ts_inc = stbl->TimeToSample->entries[i].sampleDelta;\n\t\t\telse if (old_ts_inc<stbl->TimeToSample->entries[i].sampleDelta)\n\t\t\t\told_ts_inc = stbl->TimeToSample->entries[i].sampleDelta;\n\t\t}\n\n\t\tif ((old_timescale==newTS) && (old_ts_inc==new_tsinc))\n\t\t\treturn GF_EOS;\n\n\t\tif (!force_rescale_type)\n\t\t\tforce_rescale_type = 1;\n\t\telse if (force_rescale_type==2) {\n\t\t\tgf_free(stbl->TimeToSample->entries);\n\t\t\tstbl->TimeToSample->alloc_size = 1;\n\t\t\tstbl->TimeToSample->nb_entries = 1;\n\t\t\tstbl->TimeToSample->entries = gf_malloc(sizeof(GF_SttsEntry));\n\t\t\tstbl->TimeToSample->entries[0].sampleDelta = new_tsinc;\n\t\t\tstbl->TimeToSample->entries[0].sampleCount = stbl->SampleSize->sampleCount;\n\t\t}\n\n\n\t\tfor (i=0; i<stbl->TimeToSample->nb_entries; i++) {\n\t\t\tstbl->TimeToSample->entries[i].sampleDelta = new_tsinc;\n\t\t}\n\n\t\tif (stbl->CompositionOffset) {\n\t\t\tfor (i=0; i<stbl->CompositionOffset->nb_entries; i++) {\n\t\t\t\tu32 old_offset = stbl->CompositionOffset->entries[i].decodingOffset;\n\t\t\t\tif (force_rescale_type==2) {\n\t\t\t\t\tu32 val = old_offset ;\n\t\t\t\t\t//get number of TS delta\n\t\t\t\t\told_offset /= old_ts_inc;\n\t\t\t\t\tif (old_offset * old_ts_inc < val)\n\t\t\t\t\t\told_offset++;\n\t\t\t\t\told_offset *= new_tsinc;\n\t\t\t\t} else {\n\t\t\t\t\told_offset *= new_tsinc;\n\t\t\t\t\told_offset /= old_ts_inc;\n\t\t\t\t}\n\t\t\t\tstbl->CompositionOffset->entries[i].decodingOffset = old_offset;\n\t\t\t}\n\t\t}\n\n#define RESCALE_TSVAL(_tsval) {\\\n\t\t\ts64 val = ((s64) _tsval) * new_tsinc;\\\n\t\t\tval /= old_ts_inc;\\\n\t\t\t_tsval = (s32) val;\\\n\t\t}\n\n\t\tif (stbl->CompositionToDecode) {\n\t\t\tRESCALE_TSVAL(stbl->CompositionToDecode->compositionEndTime)\n\t\t\tRESCALE_TSVAL(stbl->CompositionToDecode->compositionStartTime)\n\t\t\tRESCALE_TSVAL(stbl->CompositionToDecode->compositionToDTSShift)\n\t\t\tRESCALE_TSVAL(stbl->CompositionToDecode->greatestDecodeToDisplayDelta)\n\t\t\tRESCALE_TSVAL(stbl->CompositionToDecode->leastDecodeToDisplayDelta)\n\t\t}\n\t\tif (trak->editBox) {\n\t\t\tGF_EdtsEntry *ent;\n\t\t\ti=0;\n\t\t\twhile ((ent = (GF_EdtsEntry*)gf_list_enum(trak->editBox->editList->entryList, &i))) {\n\t\t\t\tRESCALE_TSVAL(ent->mediaTime)\n\t\t\t}\n\t\t}\n#undef RESCALE_TSVAL\n\n\t\treturn SetTrackDuration(trak);\n\t}\n\n\t//rescale timings\n\tu32 i, k, idx, last_delta;\n\tu64 cur_dts;\n\tu64*DTSs = NULL;\n\ts64*CTSs = NULL;\n\n\tif (trak->editBox) {\n\t\tGF_EdtsEntry *ent;\n\t\ti=0;\n\t\twhile ((ent = (GF_EdtsEntry*)gf_list_enum(trak->editBox->editList->entryList, &i))) {\n\t\t\tent->mediaTime = (u32) (scale*ent->mediaTime);\n\t\t}\n\t}\n\tif (! stbl || !stbl->TimeToSample || !stbl->TimeToSample->nb_entries) {\n\t\treturn SetTrackDuration(trak);\n\t}\n\n\tidx = 0;\n\tcur_dts = 0;\n\t//unpack the DTSs\n\tDTSs = (u64*)gf_malloc(sizeof(u64) * (stbl->SampleSize->sampleCount) );\n\tif (!DTSs) return GF_OUT_OF_MEM;\n\n\tCTSs = NULL;\n\tif (stbl->CompositionOffset) {\n\t\tCTSs = (s64*)gf_malloc(sizeof(u64) * (stbl->SampleSize->sampleCount) );\n\t\tif (!CTSs) return GF_OUT_OF_MEM;\n\t}\n\n\tfor (i=0; i<stbl->TimeToSample->nb_entries; i++) {\n\t\tfor (k=0; k<stbl->TimeToSample->entries[i].sampleCount; k++) {\n\t\t\tcur_dts += stbl->TimeToSample->entries[i].sampleDelta;\n\t\t\tDTSs[idx] = (u64) (cur_dts * scale);\n\n\t\t\tif (stbl->CompositionOffset) {\n\t\t\t\ts32 cts_o;\n\t\t\t\tstbl_GetSampleCTS(stbl->CompositionOffset, idx+1, &cts_o);\n\t\t\t\tCTSs[idx] = (s64) ( ((s64) cur_dts + cts_o) * scale);\n\t\t\t}\n\t\t\tidx++;\n\t\t}\n\t}\n\tlast_delta = (u32) (stbl->TimeToSample->entries[stbl->TimeToSample->nb_entries-1].sampleDelta * scale);\n\n\t//repack DTS\n\tif (stbl->SampleSize->sampleCount) {\n\t\tstbl->TimeToSample->entries = gf_realloc(stbl->TimeToSample->entries, sizeof(GF_SttsEntry)*stbl->SampleSize->sampleCount);\n\t\tmemset(stbl->TimeToSample->entries, 0, sizeof(GF_SttsEntry)*stbl->SampleSize->sampleCount);\n\t\tstbl->TimeToSample->entries[0].sampleDelta = (u32) DTSs[0];\n\t\tstbl->TimeToSample->entries[0].sampleCount = 1;\n\t\tidx=0;\n\t\tfor (i=1; i< stbl->SampleSize->sampleCount - 1; i++) {\n\t\t\tif (DTSs[i+1] - DTSs[i] == stbl->TimeToSample->entries[idx].sampleDelta) {\n\t\t\t\tstbl->TimeToSample->entries[idx].sampleCount++;\n\t\t\t} else {\n\t\t\t\tidx++;\n\t\t\t\tstbl->TimeToSample->entries[idx].sampleDelta = (u32) ( DTSs[i+1] - DTSs[i] );\n\t\t\t\tstbl->TimeToSample->entries[idx].sampleCount=1;\n\t\t\t}\n\t\t}\n\t\tif (stbl->SampleSize->sampleCount > 1) {\n\t\t\t//add the sample delta for the last sample\n\t\t\tif (stbl->TimeToSample->entries[idx].sampleDelta == last_delta) {\n\t\t\t\tstbl->TimeToSample->entries[idx].sampleCount++;\n\t\t\t} else {\n\t\t\t\tidx++;\n\t\t\t\tstbl->TimeToSample->entries[idx].sampleDelta = last_delta;\n\t\t\t\tstbl->TimeToSample->entries[idx].sampleCount=1;\n\t\t\t}\n\n\t\t\tstbl->TimeToSample->nb_entries = idx+1;\n\t\t\tstbl->TimeToSample->entries = gf_realloc(stbl->TimeToSample->entries, sizeof(GF_SttsEntry)*stbl->TimeToSample->nb_entries);\n\t\t}\n\t}\n\n\tif (CTSs && stbl->SampleSize->sampleCount>0) {\n\t\t//repack CTS\n\t\tstbl->CompositionOffset->entries = gf_realloc(stbl->CompositionOffset->entries, sizeof(GF_DttsEntry)*stbl->SampleSize->sampleCount);\n\t\tmemset(stbl->CompositionOffset->entries, 0, sizeof(GF_DttsEntry)*stbl->SampleSize->sampleCount);\n\t\tstbl->CompositionOffset->entries[0].decodingOffset = (s32) (CTSs[0] - DTSs[0]);\n\t\tstbl->CompositionOffset->entries[0].sampleCount = 1;\n\t\tidx=0;\n\t\tfor (i=1; i< stbl->SampleSize->sampleCount; i++) {\n\t\t\ts32 cts_o = (s32) (CTSs[i] - DTSs[i]);\n\t\t\tif (cts_o == stbl->CompositionOffset->entries[idx].decodingOffset) {\n\t\t\t\tstbl->CompositionOffset->entries[idx].sampleCount++;\n\t\t\t} else {\n\t\t\t\tidx++;\n\t\t\t\tstbl->CompositionOffset->entries[idx].decodingOffset = cts_o;\n\t\t\t\tstbl->CompositionOffset->entries[idx].sampleCount=1;\n\t\t\t}\n\t\t}\n\t\tstbl->CompositionOffset->nb_entries = idx+1;\n\t\tstbl->CompositionOffset->entries = gf_realloc(stbl->CompositionOffset->entries, sizeof(GF_DttsEntry)*stbl->CompositionOffset->nb_entries);\n\n\t\tgf_free(CTSs);\n\t}\n\tgf_free(DTSs);\n\n\tif (stbl->CompositionToDecode) {\n\t\tstbl->CompositionToDecode->compositionEndTime = (s32) (stbl->CompositionToDecode->compositionEndTime * scale);\n\t\tstbl->CompositionToDecode->compositionStartTime = (s32)(stbl->CompositionToDecode->compositionStartTime * scale);\n\t\tstbl->CompositionToDecode->compositionToDTSShift = (s32)(stbl->CompositionToDecode->compositionToDTSShift * scale);\n\t\tstbl->CompositionToDecode->greatestDecodeToDisplayDelta = (s32)(stbl->CompositionToDecode->greatestDecodeToDisplayDelta * scale);\n\t\tstbl->CompositionToDecode->leastDecodeToDisplayDelta = (s32)(stbl->CompositionToDecode->leastDecodeToDisplayDelta * scale);\n\t}\n\n\treturn SetTrackDuration(trak);\n}\n\nGF_EXPORT\nBool gf_isom_box_equal(GF_Box *a, GF_Box *b)\n{\n\tBool ret;\n\tu8 *data1, *data2;\n\tu32 data1_size, data2_size;\n\tGF_BitStream *bs;\n\n\tif (a == b) return GF_TRUE;\n\tif (!a || !b) return GF_FALSE;\n\n\tdata1 = data2 = NULL;\n\n\tbs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\tgf_isom_box_size(a);\n\tgf_isom_box_write(a, bs);\n\tgf_bs_get_content(bs, &data1, &data1_size);\n\tgf_bs_del(bs);\n\n\tbs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\tgf_isom_box_size(b);\n\tgf_isom_box_write(b, bs);\n\tgf_bs_get_content(bs, &data2, &data2_size);\n\tgf_bs_del(bs);\n\n\tret = GF_FALSE;\n\tif (data1_size == data2_size) {\n\t\tret = (memcmp(data1, data2, sizeof(char)*data1_size) == 0) ? GF_TRUE : GF_FALSE;\n\t}\n\tgf_free(data1);\n\tgf_free(data2);\n\treturn ret;\n}\n\nGF_EXPORT\nBool gf_isom_is_same_sample_description(GF_ISOFile *f1, u32 tk1, u32 sdesc_index1, GF_ISOFile *f2, u32 tk2, u32 sdesc_index2)\n{\n\tu32 i, count;\n\tGF_TrackBox *trak1, *trak2;\n\tGF_ESD *esd1, *esd2;\n\tBool need_memcmp, ret;\n\tGF_Box *a, *b;\n\n\t/*get orig sample desc and clone it*/\n\ttrak1 = gf_isom_get_track_from_file(f1, tk1);\n\tif (!trak1 || !trak1->Media) return GF_FALSE;\n\ttrak2 = gf_isom_get_track_from_file(f2, tk2);\n\tif (!trak2 || !trak2->Media) return GF_FALSE;\n\n\tif (trak1->Media->handler->handlerType != trak2->Media->handler->handlerType) return GF_FALSE;\n\tcount = gf_list_count(trak1->Media->information->sampleTable->SampleDescription->child_boxes);\n\tif (count != gf_list_count(trak2->Media->information->sampleTable->SampleDescription->child_boxes)) {\n\t\tif (!sdesc_index1 && !sdesc_index2) return GF_FALSE;\n\t}\n\n\tneed_memcmp = GF_TRUE;\n\tfor (i=0; i<count; i++) {\n\t\tGF_Box *ent1 = (GF_Box *)gf_list_get(trak1->Media->information->sampleTable->SampleDescription->child_boxes, i);\n\t\tGF_Box *ent2 = (GF_Box *)gf_list_get(trak2->Media->information->sampleTable->SampleDescription->child_boxes, i);\n\n\t\tif (sdesc_index1) ent1 = (GF_Box *)gf_list_get(trak1->Media->information->sampleTable->SampleDescription->child_boxes, sdesc_index1 - 1);\n\t\tif (sdesc_index2) ent2 = (GF_Box *)gf_list_get(trak2->Media->information->sampleTable->SampleDescription->child_boxes, sdesc_index2 - 1);\n\n\t\tif (!ent1 || !ent2) return GF_FALSE;\n\t\tif (ent1->type != ent2->type) return GF_FALSE;\n\n\t\tswitch (ent1->type) {\n\t\t/*for MPEG-4 streams, only compare decSpecInfo (bitrate may not be the same but that's not an issue)*/\n\t\tcase GF_ISOM_BOX_TYPE_MP4S:\n\t\tcase GF_ISOM_BOX_TYPE_MP4A:\n\t\tcase GF_ISOM_BOX_TYPE_MP4V:\n\t\tcase GF_ISOM_BOX_TYPE_ENCA:\n\t\tcase GF_ISOM_BOX_TYPE_ENCV:\n\t\tcase GF_ISOM_BOX_TYPE_RESV:\n\t\tcase GF_ISOM_BOX_TYPE_ENCS:\n\t\t\tMedia_GetESD(trak1->Media, sdesc_index1 ? sdesc_index1 : i+1, &esd1, GF_TRUE);\n\t\t\tMedia_GetESD(trak2->Media, sdesc_index2 ? sdesc_index2 : i+1, &esd2, GF_TRUE);\n\t\t\tif (!esd1 || !esd2) continue;\n\t\t\tneed_memcmp = GF_FALSE;\n\t\t\tif (esd1->decoderConfig->streamType != esd2->decoderConfig->streamType) return GF_FALSE;\n\t\t\tif (esd1->decoderConfig->objectTypeIndication != esd2->decoderConfig->objectTypeIndication) return GF_FALSE;\n\t\t\tif (!esd1->decoderConfig->decoderSpecificInfo && esd2->decoderConfig->decoderSpecificInfo) return GF_FALSE;\n\t\t\tif (esd1->decoderConfig->decoderSpecificInfo && !esd2->decoderConfig->decoderSpecificInfo) return GF_FALSE;\n\t\t\tif (!esd1->decoderConfig->decoderSpecificInfo || !esd2->decoderConfig->decoderSpecificInfo) continue;\n\t\t\tif (memcmp(esd1->decoderConfig->decoderSpecificInfo->data, esd2->decoderConfig->decoderSpecificInfo->data, sizeof(char)*esd1->decoderConfig->decoderSpecificInfo->dataLength)!=0) return GF_FALSE;\n\t\t\tbreak;\n\t\tcase GF_ISOM_BOX_TYPE_HVT1:\n\t\t\treturn GF_TRUE;\n\t\tcase GF_ISOM_BOX_TYPE_AVC1:\n\t\tcase GF_ISOM_BOX_TYPE_AVC2:\n\t\tcase GF_ISOM_BOX_TYPE_AVC3:\n\t\tcase GF_ISOM_BOX_TYPE_AVC4:\n\t\tcase GF_ISOM_BOX_TYPE_SVC1:\n\t\tcase GF_ISOM_BOX_TYPE_MVC1:\n\t\tcase GF_ISOM_BOX_TYPE_HVC1:\n\t\tcase GF_ISOM_BOX_TYPE_HEV1:\n\t\tcase GF_ISOM_BOX_TYPE_HVC2:\n\t\tcase GF_ISOM_BOX_TYPE_HEV2:\n\t\tcase GF_ISOM_BOX_TYPE_LHE1:\n\t\tcase GF_ISOM_BOX_TYPE_LHV1:\n\t\tcase GF_ISOM_BOX_TYPE_AV01:\n\t\tcase GF_ISOM_BOX_TYPE_VVC1:\n\t\tcase GF_ISOM_BOX_TYPE_VVI1:\n\t\t{\n\t\t\tGF_MPEGVisualSampleEntryBox *avc1 = (GF_MPEGVisualSampleEntryBox *)ent1;\n\t\t\tGF_MPEGVisualSampleEntryBox *avc2 = (GF_MPEGVisualSampleEntryBox *)ent2;\n\n\t\t\tif (avc1->hevc_config)\n\t\t\t\ta = (GF_Box *) avc1->hevc_config;\n\t\t\telse if (avc1->lhvc_config)\n\t\t\t\ta = (GF_Box *) avc1->lhvc_config;\n\t\t\telse if (avc1->svc_config)\n\t\t\t\ta = (GF_Box *) avc1->svc_config;\n\t\t\telse if (avc1->mvc_config)\n\t\t\t\ta = (GF_Box *) avc1->mvc_config;\n\t\t\telse if (avc1->av1_config)\n\t\t\t\ta = (GF_Box *)avc1->av1_config;\n\t\t\telse\n\t\t\t\ta = (GF_Box *) avc1->avc_config;\n\n\t\t\tif (avc2->hevc_config)\n\t\t\t\tb = (GF_Box *) avc2->hevc_config;\n\t\t\telse if (avc2->lhvc_config)\n\t\t\t\tb = (GF_Box *) avc2->lhvc_config;\n\t\t\telse if (avc2->svc_config)\n\t\t\t\tb = (GF_Box *) avc2->svc_config;\n\t\t\telse if (avc2->mvc_config)\n\t\t\t\tb = (GF_Box *) avc2->mvc_config;\n\t\t\telse if (avc2->av1_config)\n\t\t\t\tb = (GF_Box *)avc2->av1_config;\n\t\t\telse\n\t\t\t\tb = (GF_Box *) avc2->avc_config;\n\n\t\t\treturn gf_isom_box_equal(a,b);\n\t\t}\n\t\tbreak;\n\t\tcase GF_ISOM_BOX_TYPE_LSR1:\n\t\t{\n\t\t\tGF_LASeRSampleEntryBox *lsr1 = (GF_LASeRSampleEntryBox *)ent1;\n\t\t\tGF_LASeRSampleEntryBox *lsr2 = (GF_LASeRSampleEntryBox *)ent2;\n\t\t\tif (lsr1->lsr_config && lsr2->lsr_config\n\t\t\t        && lsr1->lsr_config->hdr && lsr2->lsr_config->hdr\n\t\t\t        && (lsr1->lsr_config->hdr_size==lsr2->lsr_config->hdr_size)\n\t\t\t        && !memcmp(lsr1->lsr_config->hdr, lsr2->lsr_config->hdr, lsr2->lsr_config->hdr_size)\n\t\t\t   ) {\n\t\t\t\treturn GF_TRUE;\n\t\t\t}\n\t\t\treturn GF_FALSE;\n\t\t}\n\t\tbreak;\n#ifndef GPAC_DISABLE_VTT\n\t\tcase GF_ISOM_BOX_TYPE_WVTT:\n\t\t{\n\t\t\tGF_WebVTTSampleEntryBox *wvtt1 = (GF_WebVTTSampleEntryBox *)ent1;\n\t\t\tGF_WebVTTSampleEntryBox *wvtt2 = (GF_WebVTTSampleEntryBox *)ent2;\n\t\t\tif (wvtt1->config && wvtt2->config &&\n\t\t\t        (wvtt1->config->string && wvtt2->config->string && !strcmp(wvtt1->config->string, wvtt2->config->string))) {\n\t\t\t\treturn GF_TRUE;\n\t\t\t}\n\t\t\treturn GF_FALSE;\n\t\t}\n\t\tbreak;\n#endif\n\t\tcase GF_ISOM_BOX_TYPE_STPP:\n\t\t{\n\t\t\tGF_MetaDataSampleEntryBox *stpp1 = (GF_MetaDataSampleEntryBox *)ent1;\n\t\t\tGF_MetaDataSampleEntryBox *stpp2 = (GF_MetaDataSampleEntryBox *)ent2;\n\t\t\tif (stpp1->xml_namespace && stpp2->xml_namespace && !strcmp(stpp1->xml_namespace, stpp2->xml_namespace)) {\n\t\t\t\treturn GF_TRUE;\n\t\t\t}\n\t\t\treturn GF_FALSE;\n\t\t}\n\t\tbreak;\n\t\tcase GF_ISOM_BOX_TYPE_SBTT:\n\t\t{\n\t\t\treturn GF_FALSE;\n\t\t}\n\t\tbreak;\n\t\tcase GF_ISOM_BOX_TYPE_STXT:\n\t\t{\n\t\t\tGF_MetaDataSampleEntryBox *stxt1 = (GF_MetaDataSampleEntryBox *)ent1;\n\t\t\tGF_MetaDataSampleEntryBox *stxt2 = (GF_MetaDataSampleEntryBox *)ent2;\n\t\t\tif (stxt1->mime_type && stxt2->mime_type &&\n\t\t\t        ( (!stxt1->config && !stxt2->config) ||\n\t\t\t          (stxt1->config && stxt2->config && stxt1->config->config && stxt2->config->config &&\n\t\t\t           !strcmp(stxt1->config->config, stxt2->config->config)))) {\n\t\t\t\treturn GF_TRUE;\n\t\t\t}\n\t\t\treturn GF_FALSE;\n\t\t}\n\t\tcase GF_ISOM_BOX_TYPE_MP3:\n\t\tcase GF_QT_SUBTYPE_RAW_AUD:\n\t\tcase GF_QT_SUBTYPE_TWOS:\n\t\tcase GF_QT_SUBTYPE_SOWT:\n\t\tcase GF_QT_SUBTYPE_FL32:\n\t\tcase GF_QT_SUBTYPE_FL64:\n\t\tcase GF_QT_SUBTYPE_IN24:\n\t\tcase GF_QT_SUBTYPE_IN32:\n\t\tcase GF_QT_SUBTYPE_ULAW:\n\t\tcase GF_QT_SUBTYPE_ALAW:\n\t\tcase GF_QT_SUBTYPE_ADPCM:\n\t\tcase GF_QT_SUBTYPE_IMA_ADPCM:\n\t\tcase GF_QT_SUBTYPE_DVCA:\n\t\tcase GF_QT_SUBTYPE_QDMC:\n\t\tcase GF_QT_SUBTYPE_QDMC2:\n\t\tcase GF_QT_SUBTYPE_QCELP:\n\t\tcase GF_QT_SUBTYPE_kMP3:\n\t\t\treturn GF_TRUE;\n\t\tcase GF_QT_SUBTYPE_APCH:\n\t\tcase GF_QT_SUBTYPE_APCO:\n\t\tcase GF_QT_SUBTYPE_APCN:\n\t\tcase GF_QT_SUBTYPE_APCS:\n\t\tcase GF_QT_SUBTYPE_AP4X:\n\t\tcase GF_QT_SUBTYPE_AP4H:\n\t\tcase GF_QT_SUBTYPE_RAW_VID:\n\t\tcase GF_QT_SUBTYPE_YUYV:\n\t\tcase GF_QT_SUBTYPE_UYVY:\n\t\tcase GF_QT_SUBTYPE_YUV444:\n\t\tcase GF_QT_SUBTYPE_YUVA444:\n\t\tcase GF_QT_SUBTYPE_YUV422_10:\n\t\tcase GF_QT_SUBTYPE_YUV444_10:\n\t\tcase GF_QT_SUBTYPE_YUV422_16:\n\t\tcase GF_QT_SUBTYPE_YUV420:\n\t\tcase GF_QT_SUBTYPE_I420:\n\t\tcase GF_QT_SUBTYPE_IYUV:\n\t\tcase GF_QT_SUBTYPE_YV12:\n\t\tcase GF_QT_SUBTYPE_YVYU:\n\t\tcase GF_QT_SUBTYPE_RGBA:\n\t\tcase GF_QT_SUBTYPE_ABGR:\n\t\t\treturn GF_TRUE;\n\t\t}\n\n\t\tif (sdesc_index1 && sdesc_index2) break;\n\t}\n\tif (!need_memcmp) return GF_TRUE;\n\ta = (GF_Box *)trak1->Media->information->sampleTable->SampleDescription;\n\tb = (GF_Box *)trak2->Media->information->sampleTable->SampleDescription;\n\t//we ignore all bitrate boxes when comparing the box, disable their writing\n\tgf_isom_registry_disable(GF_ISOM_BOX_TYPE_BTRT, GF_TRUE);\n\tret = gf_isom_box_equal(a,b);\n\t//re-enable btrt writing\n\tgf_isom_registry_disable(GF_ISOM_BOX_TYPE_BTRT, GF_FALSE);\n\n\treturn ret;\n}\n\nGF_EXPORT\nu64 gf_isom_estimate_size(GF_ISOFile *movie)\n{\n\tGF_Err e;\n\tGF_Box *a;\n\tu32 i, count;\n\tu64 mdat_size;\n\tif (!movie || !movie->moov) return 0;\n\n\tmdat_size = 0;\n\tcount = gf_list_count(movie->moov->trackList);\n\tfor (i=0; i<count; i++) {\n\t\tmdat_size += gf_isom_get_media_data_size(movie, i+1);\n\t}\n\tif (mdat_size) {\n\t\tmdat_size += 8;\n\t\tif (mdat_size > 0xFFFFFFFF) mdat_size += 8;\n\t}\n\n\ti=0;\n\twhile ((a = (GF_Box*)gf_list_enum(movie->TopBoxes, &i))) {\n\t\te = gf_isom_box_size(a);\n\t\tif (e == GF_OK)\n\t\t\tmdat_size += a->size;\n\t}\n\treturn mdat_size;\n}\n\n\n//set shadowing on/off\n#if 0 //unused\nGF_Err gf_isom_remove_sync_shadows(GF_ISOFile *movie, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\tGF_SampleTableBox *stbl;\n\n\tif (movie->openMode == GF_ISOM_OPEN_READ) return GF_ISOM_INVALID_MODE;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tstbl = trak->Media->information->sampleTable;\n\tif (stbl->ShadowSync) {\n\t\tgf_isom_box_del_parent(&stbl->child_boxes, (GF_Box *) stbl->ShadowSync);\n\t\tstbl->ShadowSync = NULL;\n\t}\n\treturn GF_OK;\n}\n\n/*Use this function to do the shadowing if you use shadowing.\nthe sample to be shadowed MUST be a non-sync sample (ignored if not)\nthe sample shadowing must be a Sync sample (error if not)*/\nGF_Err gf_isom_set_sync_shadow(GF_ISOFile *movie, u32 trackNumber, u32 sampleNumber, u32 syncSample)\n{\n\tGF_TrackBox *trak;\n\tGF_SampleTableBox *stbl;\n\tGF_ISOSAPType isRAP;\n\tGF_Err e;\n\n\tif (movie->openMode == GF_ISOM_OPEN_READ) return GF_ISOM_INVALID_MODE;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !sampleNumber || !syncSample) return GF_BAD_PARAM;\n\n\tstbl = trak->Media->information->sampleTable;\n\tif (!stbl->ShadowSync) {\n\t\tstbl->ShadowSync = (GF_ShadowSyncBox *) gf_isom_box_new_parent(&stbl->child_boxes, GF_ISOM_BOX_TYPE_STSH);\n\t\tif (!stbl->ShadowSync) return GF_OUT_OF_MEM;\n\t}\n\n\t//if no sync, skip\n\tif (!stbl->SyncSample) return GF_OK;\n\t//else set the sync shadow.\n\t//if the sample is sync, ignore\n\te = stbl_GetSampleRAP(stbl->SyncSample, sampleNumber, &isRAP, NULL, NULL);\n\tif (e) return e;\n\tif (isRAP) return GF_OK;\n\t//if the shadowing sample is not sync, error\n\te = stbl_GetSampleRAP(stbl->SyncSample, syncSample, &isRAP, NULL, NULL);\n\tif (e) return e;\n\tif (!isRAP) return GF_BAD_PARAM;\n\n\treturn stbl_SetSyncShadow(stbl->ShadowSync, sampleNumber, syncSample);\n}\n#endif\n\n//set the GroupID of a track (only used for interleaving)\nGF_EXPORT\nGF_Err gf_isom_set_track_interleaving_group(GF_ISOFile *movie, u32 trackNumber, u32 GroupID)\n{\n\tGF_TrackBox *trak;\n\n\tif (movie->openMode != GF_ISOM_OPEN_EDIT) return GF_ISOM_INVALID_MODE;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !GroupID) return GF_BAD_PARAM;\n\n\ttrak->Media->information->sampleTable->groupID = GroupID;\n\treturn GF_OK;\n}\n\n\n//set the Priority of a track within a Group (only used for tight interleaving)\n//Priority ranges from 1 to 9\nGF_EXPORT\nGF_Err gf_isom_set_track_priority_in_group(GF_ISOFile *movie, u32 trackNumber, u32 Priority)\n{\n\tGF_TrackBox *trak;\n\n\tif (movie->openMode != GF_ISOM_OPEN_EDIT) return GF_ISOM_INVALID_MODE;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !Priority) return GF_BAD_PARAM;\n\n\ttrak->Media->information->sampleTable->trackPriority = Priority > 255 ? 255 : Priority;\n\treturn GF_OK;\n}\n\n//set the max SamplesPerChunk (for file optimization)\nGF_EXPORT\nGF_Err gf_isom_hint_max_chunk_size(GF_ISOFile *movie, u32 trackNumber, u32 maxChunkSize)\n{\n\tGF_TrackBox *trak;\n\n\tif (movie->openMode == GF_ISOM_OPEN_READ) return GF_ISOM_INVALID_MODE;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !maxChunkSize) return GF_BAD_PARAM;\n\n\ttrak->Media->information->sampleTable->MaxChunkSize = maxChunkSize;\n\treturn GF_OK;\n}\n\n\nGF_EXPORT\nGF_Err gf_isom_set_extraction_slc(GF_ISOFile *the_file, u32 trackNumber, u32 StreamDescriptionIndex, const GF_SLConfig *slConfig)\n{\n\tGF_TrackBox *trak;\n\tGF_SampleEntryBox *entry;\n\tGF_Err e;\n\tGF_SLConfig **slc;\n\tGF_ESDBox *esds;\n\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\te = Media_GetSampleDesc(trak->Media, StreamDescriptionIndex, &entry, NULL);\n\tif (e) return e;\n\n\t//we must be sure we are not using a remote ESD\n\tswitch (entry->type) {\n\tcase GF_ISOM_BOX_TYPE_MP4S:\n\t\tesds = ((GF_MPEGSampleEntryBox *)entry)->esd;\n\t\tif (!esds || !esds->desc || !esds->desc->slConfig || (esds->desc->slConfig->predefined != SLPredef_MP4))\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\tslc = & ((GF_MPEGSampleEntryBox *)entry)->slc;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_MP4A:\n\t\tesds = ((GF_MPEGAudioSampleEntryBox *)entry)->esd;\n\t\tif (!esds || !esds->desc || !esds->desc->slConfig || (esds->desc->slConfig->predefined != SLPredef_MP4))\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\tslc = & ((GF_MPEGAudioSampleEntryBox *)entry)->slc;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_MP4V:\n\t\tesds = ((GF_MPEGVisualSampleEntryBox *)entry)->esd;\n\t\tif (!esds || !esds->desc || !esds->desc->slConfig || (esds->desc->slConfig->predefined != SLPredef_MP4))\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\tslc = & ((GF_MPEGVisualSampleEntryBox *)entry)->slc;\n\t\tbreak;\n\tdefault:\n\t\treturn GF_BAD_PARAM;\n\t}\n\n\tif (*slc) {\n\t\tgf_odf_desc_del((GF_Descriptor *)*slc);\n\t\t*slc = NULL;\n\t}\n\tif (!slConfig) return GF_OK;\n\t//finally duplicate the SL\n\treturn gf_odf_desc_copy((GF_Descriptor *) slConfig, (GF_Descriptor **) slc);\n}\n\n#if 0 //unused\nGF_Err gf_isom_get_extraction_slc(GF_ISOFile *the_file, u32 trackNumber, u32 StreamDescriptionIndex, GF_SLConfig **slConfig)\n{\n\tGF_TrackBox *trak;\n\tGF_SampleEntryBox *entry;\n\tGF_Err e;\n\tGF_SLConfig *slc;\n\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\te = Media_GetSampleDesc(trak->Media, StreamDescriptionIndex, &entry, NULL);\n\tif (e) return e;\n\n\t//we must be sure we are not using a remote ESD\n\tslc = NULL;\n\t*slConfig = NULL;\n\tswitch (entry->type) {\n\tcase GF_ISOM_BOX_TYPE_MP4S:\n\t\tif (((GF_MPEGSampleEntryBox *)entry)->esd->desc->slConfig->predefined != SLPredef_MP4) return GF_BAD_PARAM;\n\t\tslc = ((GF_MPEGSampleEntryBox *)entry)->slc;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_MP4A:\n\t\tif (((GF_MPEGAudioSampleEntryBox *)entry)->esd->desc->slConfig->predefined != SLPredef_MP4) return GF_BAD_PARAM;\n\t\tslc = ((GF_MPEGAudioSampleEntryBox *)entry)->slc;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_MP4V:\n\t\tif (((GF_MPEGVisualSampleEntryBox *)entry)->esd->desc->slConfig->predefined != SLPredef_MP4) return GF_BAD_PARAM;\n\t\tslc = ((GF_MPEGVisualSampleEntryBox *)entry)->slc;\n\t\tbreak;\n\tdefault:\n\t\treturn GF_BAD_PARAM;\n\t}\n\n\tif (!slc) return GF_OK;\n\t//finally duplicate the SL\n\treturn gf_odf_desc_copy((GF_Descriptor *) slc, (GF_Descriptor **) slConfig);\n}\n\nu32 gf_isom_get_track_group(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return 0;\n\treturn trak->Media->information->sampleTable->groupID;\n}\n\nu32 gf_isom_get_track_priority_in_group(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return 0;\n\treturn trak->Media->information->sampleTable->trackPriority;\n}\n#endif\n\n\nGF_EXPORT\nGF_Err gf_isom_make_interleave_ex(GF_ISOFile *file, GF_Fraction *fTimeInSec)\n{\n\tGF_Err e;\n\tu64 itime;\n\tif (!file || !fTimeInSec->den || (fTimeInSec->num<=0)) return GF_BAD_PARAM;\n\n\titime = (u64) fTimeInSec->num;\n\titime *= gf_isom_get_timescale(file);\n\titime /= fTimeInSec->den;\n\tif (file->storageMode==GF_ISOM_STORE_FASTSTART) {\n\t\treturn gf_isom_set_interleave_time(file, (u32) itime);\n\t}\n\tif (gf_isom_get_mode(file) < GF_ISOM_OPEN_EDIT) return GF_BAD_PARAM;\n\te = gf_isom_set_storage_mode(file, GF_ISOM_STORE_DRIFT_INTERLEAVED);\n\tif (e) return e;\n\treturn gf_isom_set_interleave_time(file, (u32) itime);\n}\n\nGF_EXPORT\nGF_Err gf_isom_make_interleave(GF_ISOFile *file, Double TimeInSec)\n{\n\tGF_Fraction f;\n\tf.num = (s32) (TimeInSec * 1000);\n\tf.den = 1000;\n\treturn gf_isom_make_interleave_ex(file, &f);\n\n}\nGF_EXPORT\nGF_Err gf_isom_set_handler_name(GF_ISOFile *the_file, u32 trackNumber, const char *nameUTF8)\n{\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\tif (trak->Media->handler->nameUTF8) gf_free(trak->Media->handler->nameUTF8);\n\ttrak->Media->handler->nameUTF8 = NULL;\n\n\tif (!nameUTF8) return GF_OK;\n\n\tif (!strnicmp(nameUTF8, \"file://\", 7)) {\n\t\tu8 BOM[4];\n\t\tFILE *f = gf_fopen(nameUTF8+7, \"rb\");\n\t\tu64 size;\n\t\tif (!f) return GF_URL_ERROR;\n\t\tsize = gf_fsize(f);\n\t\tif (3!=gf_fread(BOM, 3, f)) {\n\t\t\tgf_fclose(f);\n\t\t\treturn GF_CORRUPTED_DATA;\n\t\t}\n\t\t/*skip BOM if any*/\n\t\tif ((BOM[0]==0xEF) && (BOM[1]==0xBB) && (BOM[2]==0xBF)) size -= 3;\n\t\telse if ((BOM[0]==0xEF) || (BOM[0]==0xFF)) {\n\t\t\tgf_fclose(f);\n\t\t\treturn GF_BAD_PARAM;\n\t\t}\n\t\telse gf_fseek(f, 0, SEEK_SET);\n\t\ttrak->Media->handler->nameUTF8 = (char*)gf_malloc(sizeof(char)*(size_t)(size+1));\n\t\tif (!trak->Media->handler->nameUTF8) {\n\t\t\tgf_fclose(f);\n\t\t\treturn GF_OUT_OF_MEM;\n\t\t}\n\t\tsize = gf_fread(trak->Media->handler->nameUTF8, (size_t)size, f);\n\t\ttrak->Media->handler->nameUTF8[size] = 0;\n\t\tgf_fclose(f);\n\t} else {\n\t\tu32 i, j, len;\n\t\tchar szOrig[1024], szLine[1024];\n\t\tstrcpy(szOrig, nameUTF8);\n\t\tj=0;\n\t\tlen = (u32) strlen(szOrig);\n\t\tfor (i=0; i<len; i++) {\n\t\t\tif (szOrig[i] & 0x80) {\n\t\t\t\t/*non UTF8 (likely some win-CP)*/\n\t\t\t\tif ( (szOrig[i+1] & 0xc0) != 0x80) {\n\t\t\t\t\tszLine[j] = 0xc0 | ( (szOrig[i] >> 6) & 0x3 );\n\t\t\t\t\tj++;\n\t\t\t\t\tszOrig[i] &= 0xbf;\n\t\t\t\t}\n\t\t\t\t/*UTF8 2 bytes char */\n\t\t\t\telse if ( (szOrig[i] & 0xe0) == 0xc0) {\n\t\t\t\t\tszLine[j] = szOrig[i];\n\t\t\t\t\ti++;\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t\t/*UTF8 3 bytes char */\n\t\t\t\telse if ( (szOrig[i] & 0xf0) == 0xe0) {\n\t\t\t\t\tszLine[j] = szOrig[i];\n\t\t\t\t\ti++;\n\t\t\t\t\tj++;\n\t\t\t\t\tszLine[j] = szOrig[i];\n\t\t\t\t\ti++;\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t\t/*UTF8 4 bytes char */\n\t\t\t\telse if ( (szOrig[i] & 0xf8) == 0xf0) {\n\t\t\t\t\tszLine[j] = szOrig[i];\n\t\t\t\t\ti++;\n\t\t\t\t\tj++;\n\t\t\t\t\tszLine[j] = szOrig[i];\n\t\t\t\t\ti++;\n\t\t\t\t\tj++;\n\t\t\t\t\tszLine[j] = szOrig[i];\n\t\t\t\t\ti++;\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tszLine[j] = szOrig[i];\n\t\t\tj++;\n\t\t}\n\t\tszLine[j] = 0;\n\t\ttrak->Media->handler->nameUTF8 = gf_strdup(szLine);\n\t}\n\treturn GF_OK;\n}\n\n#if 0 //unused\n/*clones root OD from input to output file, without copying root OD track references*/\nGF_Err gf_isom_clone_root_od(GF_ISOFile *input, GF_ISOFile *output)\n{\n\tGF_List *esds;\n\tGF_Err e;\n\tu32 i;\n\tGF_Descriptor *desc;\n\n\te = gf_isom_remove_root_od(output);\n\tif (e) return e;\n\tif (!input->moov || !input->moov->iods || !input->moov->iods->descriptor) return GF_OK;\n\te = gf_isom_insert_moov(output);\n\tif (e) return e;\n\te = AddMovieIOD(output->moov, 0);\n\tif (e) return e;\n\tif (output->moov->iods->descriptor) gf_odf_desc_del(output->moov->iods->descriptor);\n\toutput->moov->iods->descriptor = NULL;\n\tgf_odf_desc_copy(input->moov->iods->descriptor, &output->moov->iods->descriptor);\n\n\tswitch (output->moov->iods->descriptor->tag) {\n\tcase GF_ODF_ISOM_IOD_TAG:\n\t\tesds = ((GF_IsomInitialObjectDescriptor *)output->moov->iods->descriptor)->ES_ID_IncDescriptors;\n\t\tbreak;\n\tcase GF_ODF_ISOM_OD_TAG:\n\t\tesds = ((GF_IsomObjectDescriptor *)output->moov->iods->descriptor)->ES_ID_IncDescriptors;\n\t\tbreak;\n\tdefault:\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\n\t//get the desc\n\ti=0;\n\twhile ((desc = (GF_Descriptor*)gf_list_enum(esds, &i))) {\n\t\tgf_odf_desc_del(desc);\n\t\tgf_list_rem(esds, i-1);\n\t}\n\treturn GF_OK;\n}\n#endif\n\nGF_EXPORT\nGF_Err gf_isom_set_media_type(GF_ISOFile *movie, u32 trackNumber, u32 new_type)\n{\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !new_type) return GF_BAD_PARAM;\n\ttrak->Media->handler->handlerType = new_type;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_media_subtype(GF_ISOFile *movie, u32 trackNumber, u32 sampleDescriptionIndex, u32 new_type)\n{\n\tGF_SampleEntryBox*entry;\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !sampleDescriptionIndex || !new_type) return GF_BAD_PARAM;\n\n\tentry = (GF_SampleEntryBox*)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, sampleDescriptionIndex - 1);\n\tif (!entry) return GF_BAD_PARAM;\n\tentry->type = new_type;\n\treturn GF_OK;\n}\n\n\n#if 0 //unused\nGF_Err gf_isom_set_JPEG2000(GF_ISOFile *mov, Bool set_on)\n{\n\tif (!mov) return GF_BAD_PARAM;\n\tmov->is_jp2 = set_on;\n\treturn GF_OK;\n}\n#endif\n\nGF_Err gf_isom_remove_uuid(GF_ISOFile *movie, u32 trackNumber, bin128 UUID)\n{\n\tu32 i, count;\n\tGF_List *list;\n\n\tif (trackNumber==(u32) -1) {\n\t\tif (!movie) return GF_BAD_PARAM;\n\t\tlist = movie->TopBoxes;\n\t} else if (trackNumber) {\n\t\tGF_TrackBox *trak = gf_isom_get_track_from_file(movie, trackNumber);\n\t\tif (!trak) return GF_BAD_PARAM;\n\t\tlist = trak->child_boxes;\n\t} else {\n\t\tif (!movie) return GF_BAD_PARAM;\n\t\tlist = movie->moov->child_boxes;\n\t}\n\n\tcount = list ? gf_list_count(list) : 0;\n\tfor (i=0; i<count; i++) {\n\t\tGF_UnknownUUIDBox *uuid = (GF_UnknownUUIDBox *)gf_list_get(list, i);\n\t\tif (uuid->type != GF_ISOM_BOX_TYPE_UUID) continue;\n\t\tif (memcmp(UUID, uuid->uuid, sizeof(bin128))) continue;\n\t\tgf_list_rem(list, i);\n\t\ti--;\n\t\tcount--;\n\t\tgf_isom_box_del((GF_Box*)uuid);\n\t}\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_add_uuid(GF_ISOFile *movie, u32 trackNumber, bin128 UUID, const u8 *data, u32 data_size)\n{\n\tGF_List *list;\n    u32 btype;\n\tGF_Box *box;\n\tGF_UnknownUUIDBox *uuidb;\n\n\tif (data_size && !data) return GF_BAD_PARAM;\n\tif (trackNumber==(u32) -1) {\n\t\tif (!movie) return GF_BAD_PARAM;\n\t\tlist = movie->TopBoxes;\n\t} else if (trackNumber) {\n\t\tGF_TrackBox *trak = gf_isom_get_track_from_file(movie, trackNumber);\n\t\tif (!trak) return GF_BAD_PARAM;\n\t\tif (!trak->child_boxes) trak->child_boxes = gf_list_new();\n\t\tlist = trak->child_boxes;\n\t} else {\n\t\tif (!movie) return GF_BAD_PARAM;\n\t\tif (!movie->moov->child_boxes) movie->moov->child_boxes = gf_list_new();\n\t\tlist = movie->moov->child_boxes;\n\t}\n    btype = gf_isom_solve_uuid_box((char *) UUID);\n    if (!btype) btype = GF_ISOM_BOX_TYPE_UUID;\n    box = gf_isom_box_new(btype);\n    if (!box) return GF_OUT_OF_MEM;\n\tuuidb = (GF_UnknownUUIDBox*)box;\n\tuuidb->internal_4cc = gf_isom_solve_uuid_box((char *) UUID);\n\tmemcpy(uuidb->uuid, UUID, sizeof(bin128));\n\tuuidb->dataSize = data_size;\n\tif (data_size) {\n\t\tuuidb->data = (char*)gf_malloc(sizeof(char)*data_size);\n\t\tif (!uuidb->data) return GF_OUT_OF_MEM;\n\t\tmemcpy(uuidb->data, data, sizeof(char)*data_size);\n\t}\n\tgf_list_add(list, uuidb);\n\treturn GF_OK;\n}\n\n\nGF_EXPORT\nGF_Err gf_isom_apple_set_tag(GF_ISOFile *mov, GF_ISOiTunesTag tag, const u8 *data, u32 data_len, u64 int_val, u32 int_val2)\n{\n\tGF_Err e;\n\tGF_ItemListBox *ilst;\n\tGF_MetaBox *meta;\n\tGF_ListItemBox *info;\n\tu32 btype, i, itype;\n\ts32 tag_idx;\n\tu32 n=0, d=0;\n\tu8 loc_data[10];\n\tu32 int_flags = 0x15;\n\tGF_DataBox *dbox;\n\n\te = CanAccessMovie(mov, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttag_idx = gf_itags_find_by_itag(tag);\n\tif (tag_idx<0) {\n\t\titype = GF_ITAG_STR;\n\t} else {\n\t\titype = gf_itags_get_type(tag_idx);\n\t}\n\tmeta = (GF_MetaBox *) gf_isom_create_meta_extensions(mov, GF_FALSE);\n\tif (!meta) return GF_BAD_PARAM;\n\n\tilst = gf_ismo_locate_box(meta->child_boxes, GF_ISOM_BOX_TYPE_ILST, NULL);\n\tif (!ilst) {\n\t\tilst = (GF_ItemListBox *) gf_isom_box_new_parent(&meta->child_boxes, GF_ISOM_BOX_TYPE_ILST);\n\t}\n\n\tif (tag==GF_ISOM_ITUNE_RESET) {\n\t\tgf_isom_box_del_parent(&meta->child_boxes, (GF_Box *) ilst);\n\t\t//if last, delete udta - we may still have a handler box remaining\n\t\tif ((gf_list_count(meta->child_boxes) <= 1) && (gf_list_count(mov->moov->udta->recordList)==1)) {\n\t\t\tgf_isom_box_del_parent(&mov->moov->child_boxes, (GF_Box *) mov->moov->udta);\n\t\t\tmov->moov->udta = NULL;\n\t\t}\n\t\treturn GF_OK;\n\t}\n\n\tif (tag==GF_ISOM_ITUNE_GENRE) {\n\t\tif (!int_val && data) {\n\t\t\tint_val = gf_id3_get_genre_tag(data);\n\t\t\tif (int_val) {\n\t\t\t\tdata = NULL;\n\t\t\t\tdata_len = 0;\n\t\t\t\titype = GF_ITAG_INT16;\n\t\t\t\tint_flags = 0;\n\t\t\t}\n\t\t}\n\t\tbtype = data ? GF_ISOM_ITUNE_GENRE_USER : GF_ISOM_ITUNE_GENRE;\n\t} else {\n\t\tbtype = tag;\n\t}\n\t/*remove tag*/\n\ti = 0;\n\twhile ((info = (GF_ListItemBox*)gf_list_enum(ilst->child_boxes, &i))) {\n\t\tif (info->type==btype) {\n\t\t\tgf_isom_box_del_parent(&ilst->child_boxes, (GF_Box *) info);\n\t\t\tinfo = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tif (info->type==GF_ISOM_BOX_TYPE_UNKNOWN) {\n\t\t\tGF_UnknownBox *u = (GF_UnknownBox *) info;\n\t\t\tif (u->original_4cc==btype) {\n\t\t\t\tgf_isom_box_del_parent(&ilst->child_boxes, (GF_Box *) info);\n\t\t\t\tinfo = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!data && data_len) {\n\t\tif (!gf_list_count(ilst->child_boxes) )\n\t\t\tgf_isom_box_del_parent(&meta->child_boxes, (GF_Box *) ilst);\n\t\treturn GF_OK;\n\t}\n\n\tinfo = (GF_ListItemBox *)gf_isom_box_new(btype);\n\tif (info == NULL) return GF_OUT_OF_MEM;\n\n\tdbox = (GF_DataBox *)gf_isom_box_new_parent(&info->child_boxes, GF_ISOM_BOX_TYPE_DATA);\n\tif (!dbox) {\n\t\tgf_isom_box_del((GF_Box *)info);\n\t\treturn GF_OUT_OF_MEM;\n\t}\n\tif (info->type!=GF_ISOM_BOX_TYPE_UNKNOWN) {\n\t\tinfo->data = dbox;\n\t}\n\n\tswitch (itype) {\n\tcase GF_ITAG_FRAC6:\n\tcase GF_ITAG_FRAC8:\n\t\tif (data && data_len) {\n\t\t\tif (sscanf(data, \"%u/%u\", &n, &d) != 2) {\n\t\t\t\tn = d = 0;\n\t\t\t\tif (sscanf(data, \"%u\", &n) != 1)\n\t\t\t\t\tn = 0;\n\t\t\t}\n\t\t} else {\n\t\t\tn = (u32) int_val;\n\t\t\td = int_val2;\n\t\t}\n\t\tif (n) {\n\t\t\tmemset(loc_data, 0, sizeof(char) * 8);\n\t\t\tdata_len = (itype == GF_ITAG_FRAC6) ? 6 : 8;\n\t\t\tloc_data[3] = n;\n\t\t\tloc_data[2] = n >> 8;\n\t\t\tloc_data[5] = d;\n\t\t\tloc_data[4] = d >> 8;\n\t\t\tdata = loc_data;\n\t\t} else {\n\t\t\tdata = NULL;\n\t\t}\n\t\tdbox->flags = 0x15;\n\t\tbreak;\n\tcase GF_ITAG_BOOL:\n\t\tloc_data[0] = 0;\n\t\tif (data && data_len) {\n\t\t\tif ( !strcmp(data, \"yes\") || !strcmp(data, \"1\") || !strcmp(data, \"true\"))\n\t\t\t\tloc_data[0] = 1;\n\t\t} else {\n\t\t\tloc_data[0] = int_val ? 1 : 0;\n\t\t}\n\t\tdata = loc_data;\n\t\tdata_len = 0;\n\t\tdbox->flags = int_flags;\n\t\tbreak;\n\tcase GF_ITAG_INT16:\n\t\tloc_data[0] = 0;\n\t\tif (data && data_len) int_val = atoi(data);\n\t\tloc_data[1] = (u8) int_val;\n\t\tloc_data[0] = (u8) (int_val>>8);\n\t\tdata = loc_data;\n\t\tdata_len = 2;\n\t\tdbox->flags = int_flags;\n\t\tbreak;\n\tcase GF_ITAG_INT32:\n\t\tloc_data[0] = 0;\n\t\tif (data && data_len) int_val = atoi(data);\n\t\tloc_data[3] = (u8) int_val;\n\t\tloc_data[2] = (u8) (int_val>>8);\n\t\tloc_data[1] = (u8) (int_val>>16);\n\t\tloc_data[0] = (u8) (int_val>>24);\n\t\tdata = loc_data;\n\t\tdata_len = 4;\n\t\tdbox->flags = int_flags;\n\t\tbreak;\n\tcase GF_ITAG_INT64:\n\t\tloc_data[0] = 0;\n\t\tif (data && data_len) sscanf(data, LLU, &int_val);\n\t\tloc_data[7] = (u8) int_val;\n\t\tloc_data[6] = (u8) (int_val>>8);\n\t\tloc_data[5] = (u8) (int_val>>16);\n\t\tloc_data[4] = (u8) (int_val>>24);\n\t\tloc_data[3] = (u8) (int_val>>32);\n\t\tloc_data[2] = (u8) (int_val>>40);\n\t\tloc_data[1] = (u8) (int_val>>48);\n\t\tloc_data[0] = (u8) (int_val>>56);\n\t\tdata = loc_data;\n\t\tdata_len = 4;\n\t\tdbox->flags = int_flags;\n\t\tbreak;\n\tdefault:\n\t\tdbox->flags = 1;\n\t\tbreak;\n\t}\n\n\tif (!data) return GF_BAD_PARAM;\n\n\n\tif (tag==GF_ISOM_ITUNE_COVER_ART) {\n\t\tinfo->data->flags = 0;\n\t\t/*check for PNG sig*/\n\t\tif ((data_len>4) && (data[0] == 0x89) && (data[1] == 0x50) && (data[2] == 0x4E) && (data[3] == 0x47) ) {\n\t\t\tinfo->data->flags = 14;\n\t\t}\n\t\telse if ((data_len>4) && (data[0] == 0xFF) && (data[1] == 0xD8) && (data[2] == 0xFF) && (data[3] == 0xE0) ) {\n\t\t\tinfo->data->flags = 13;\n\t\t}\n\t\telse if ((data_len>3) && (data[0] == 'G') && (data[1] == 'I') && (data[2] == 'F') ) {\n\t\t\tinfo->data->flags = 12;\n\t\t}\n\t}\n\n\tdbox->dataSize = data_len;\n\tdbox->data = (char*)gf_malloc(sizeof(char)*data_len);\n\tif (!dbox->data) return GF_OUT_OF_MEM;\n\tmemcpy(dbox->data, data, sizeof(char)*data_len);\n\n\tif (!info && !gf_list_count(ilst->child_boxes) ) {\n\t\tgf_isom_box_del_parent(&meta->child_boxes, (GF_Box *) ilst);\n\t\treturn GF_OK;\n\t}\n\tif (!ilst->child_boxes) ilst->child_boxes = gf_list_new();\n\t\n\treturn gf_list_add(ilst->child_boxes, info);\n}\n\n#include <gpac/utf.h>\n\nGF_EXPORT\nGF_Err gf_isom_wma_set_tag(GF_ISOFile *mov, char *name, char *value)\n{\n\tGF_Err e;\n\tGF_XtraTag *tag=NULL;\n\tu32 count, i;\n\tGF_XtraBox *xtra;\n\n\te = CanAccessMovie(mov, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\tgf_isom_create_meta_extensions(mov, GF_FALSE);\n\n\txtra = (GF_XtraBox *) gf_isom_create_meta_extensions(mov, GF_TRUE);\n\tif (!xtra) return GF_BAD_PARAM;\n\n\tcount = gf_list_count(xtra->tags);\n\tfor (i=0; i<count; i++) {\n\t\ttag = gf_list_get(xtra->tags, i);\n\t\tif (name && tag->name && !strcmp(tag->name, name)) {\n\n\t\t} else {\n\t\t\ttag = NULL;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!value) {\n\t\t\tgf_list_rem(xtra->tags, i);\n\t\t\tgf_free(tag->name);\n\t\t\tif (tag->prop_value) gf_free(tag->prop_value);\n\t\t\tgf_free(tag);\n\t\t\treturn GF_OK;\n\t\t}\n\t\tgf_free(tag->prop_value);\n\t\ttag->prop_value = 0;\n\t}\n\tif (!tag) {\n\t\tif (!name) return GF_OK;\n\n\t\tGF_SAFEALLOC(tag, GF_XtraTag);\n\t\ttag->name = gf_strdup(name);\n\t\ttag->prop_type = 0;\n\t\ttag->flags = 1;\n\t\tgf_list_add(xtra->tags, tag);\n\t}\n\n\tu32 len = (u32) strlen(value);\n\ttag->prop_value = gf_malloc(sizeof(u16) * (len+1) );\n\tmemset(tag->prop_value, 0, sizeof(u16) * (len+1) );\n\tif (len) {\n\t\tu32 _len = (u32) gf_utf8_mbstowcs((u16 *) tag->prop_value, len, (const char **) &value);\n\t\tif (_len != (u32) -1) {\n\t\t\ttag->prop_value[2 * _len] = 0;\n\t\t\ttag->prop_value[2 * _len + 1] = 0;\n\t\t}\n\t\ttag->prop_size = 2 * _len + 2;\n\t} else {\n\t\ttag->prop_size = 2;\n\t}\n\treturn GF_OK;\n}\n\n\nGF_EXPORT\nGF_Err gf_isom_set_alternate_group_id(GF_ISOFile *movie, u32 trackNumber, u32 groupId)\n{\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\ttrak->Header->alternate_group = groupId;\n\treturn GF_OK;\n}\n\n\nGF_EXPORT\nGF_Err gf_isom_set_track_switch_parameter(GF_ISOFile *movie, u32 trackNumber, u32 trackRefGroup, Bool is_switch_group, u32 *switchGroupID, u32 *criteriaList, u32 criteriaListCount)\n{\n\tGF_TrackSelectionBox *tsel;\n\tGF_TrackBox *trak;\n\tGF_UserDataMap *map;\n\tGF_Err e;\n\tu32 alternateGroupID = 0;\n\tu32 next_switch_group_id = 0;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !switchGroupID) return GF_BAD_PARAM;\n\n\n\tif (trackRefGroup) {\n\t\tGF_TrackBox *trak_ref = gf_isom_get_track_from_file(movie, trackRefGroup);\n\t\tif (trak_ref != trak) {\n\t\t\tif (!trak_ref || !trak_ref->Header->alternate_group) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"Track %d has not an alternate group - skipping\\n\", trak_ref ? trak_ref->Header->trackID : 0));\n\t\t\t\treturn GF_BAD_PARAM;\n\t\t\t}\n\t\t\talternateGroupID = trak_ref->Header->alternate_group;\n\t\t} else {\n\t\t\talternateGroupID = trak->Header->alternate_group;\n\t\t}\n\t}\n\tif (!alternateGroupID) {\n\t\t/*there is a function for this ....*/\n\t\tif (trak->Header->alternate_group) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"Track %d has already an alternate group - skipping\\n\", trak->Header->trackID));\n\t\t\treturn GF_BAD_PARAM;\n\t\t}\n\t\talternateGroupID = gf_isom_get_next_alternate_group_id(movie);\n\t}\n\n\tif (is_switch_group) {\n\t\tu32 i=0;\n\t\twhile (i< gf_isom_get_track_count(movie) ) {\n\t\t\t//locate first available ID\n\t\t\tGF_TrackBox *a_trak = gf_isom_get_track_from_file(movie, i+1);\n\n\t\t\tif (a_trak->udta) {\n\t\t\t\tu32 j, count;\n\t\t\t\tmap = udta_getEntry(a_trak->udta, GF_ISOM_BOX_TYPE_TSEL, NULL);\n\t\t\t\tif (map) {\n\t\t\t\t\tcount = gf_list_count(map->boxes);\n\t\t\t\t\tfor (j=0; j<count; j++) {\n\t\t\t\t\t\ttsel = (GF_TrackSelectionBox*)gf_list_get(map->boxes, j);\n\n\t\t\t\t\t\tif (*switchGroupID) {\n\t\t\t\t\t\t\tif (tsel->switchGroup==next_switch_group_id) {\n\t\t\t\t\t\t\t\tif (a_trak->Header->alternate_group != alternateGroupID) return GF_BAD_PARAM;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (tsel->switchGroup && (tsel->switchGroup>=next_switch_group_id) )\n\t\t\t\t\t\t\t\tnext_switch_group_id = tsel->switchGroup;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\tif (! *switchGroupID) *switchGroupID = next_switch_group_id+1;\n\t}\n\n\n\ttrak->Header->alternate_group = alternateGroupID;\n\n\ttsel = NULL;\n\tif (*switchGroupID) {\n\t\tif (!trak->udta) {\n\t\t\te = trak_on_child_box((GF_Box*)trak, gf_isom_box_new_parent(&trak->child_boxes, GF_ISOM_BOX_TYPE_UDTA), GF_FALSE);\n\t\t\tif (e) return e;\n\t\t}\n\n\t\tmap = udta_getEntry(trak->udta, GF_ISOM_BOX_TYPE_TSEL, NULL);\n\n\t\t/*locate tsel box with no switch group*/\n\t\tif (map)  {\n\t\t\tu32 j, count = gf_list_count(map->boxes);\n\t\t\tfor (j=0; j<count; j++) {\n\t\t\t\ttsel = (GF_TrackSelectionBox*)gf_list_get(map->boxes, j);\n\t\t\t\tif (tsel->switchGroup == *switchGroupID) break;\n\t\t\t\ttsel = NULL;\n\t\t\t}\n\t\t}\n\t\tif (!tsel) {\n\t\t\ttsel = (GF_TrackSelectionBox *)gf_isom_box_new(GF_ISOM_BOX_TYPE_TSEL);\n\t\t\tif (!tsel) return GF_OUT_OF_MEM;\n\t\t\te = udta_on_child_box((GF_Box *)trak->udta, (GF_Box *) tsel, GF_FALSE);\n\t\t\tif (e) return e;\n\t\t}\n\n\t\ttsel->switchGroup = *switchGroupID;\n\t\ttsel->attributeListCount = criteriaListCount;\n\t\tif (tsel->attributeList) gf_free(tsel->attributeList);\n\t\ttsel->attributeList = (u32*)gf_malloc(sizeof(u32)*criteriaListCount);\n\t\tif (!tsel->attributeList) return GF_OUT_OF_MEM;\n\t\tmemcpy(tsel->attributeList, criteriaList, sizeof(u32)*criteriaListCount);\n\t}\n\treturn GF_OK;\n}\n\nvoid reset_tsel_box(GF_TrackBox *trak)\n{\n\tGF_UserDataMap *map;\n\ttrak->Header->alternate_group = 0;\n\tmap = udta_getEntry(trak->udta, GF_ISOM_BOX_TYPE_TSEL, NULL);\n\tif (map) {\n\t\tgf_list_del_item(trak->udta->recordList, map);\n\t\tgf_isom_box_array_del(map->boxes);\n\t\tgf_free(map);\n\t}\n\n}\n\nGF_EXPORT\nGF_Err gf_isom_reset_track_switch_parameter(GF_ISOFile *movie, u32 trackNumber, Bool reset_all_group)\n{\n\tGF_TrackBox *trak;\n\tu32 alternateGroupID = 0;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\tif (!trak->Header->alternate_group) return GF_OK;\n\n\talternateGroupID = trak->Header->alternate_group;\n\tif (reset_all_group) {\n\t\tu32 i=0;\n\t\twhile (i< gf_isom_get_track_count(movie) ) {\n\t\t\t//locate first available ID\n\t\t\tGF_TrackBox *a_trak = gf_isom_get_track_from_file(movie, i+1);\n\t\t\tif (a_trak->Header->alternate_group == alternateGroupID) reset_tsel_box(a_trak);\n\t\t\ti++;\n\t\t}\n\t} else {\n\t\treset_tsel_box(trak);\n\t}\n\treturn GF_OK;\n}\n\n\nGF_EXPORT\nGF_Err gf_isom_reset_switch_parameters(GF_ISOFile *movie)\n{\n\tu32 i=0;\n\twhile (i< gf_isom_get_track_count(movie) ) {\n\t\t//locate first available ID\n\t\tGF_TrackBox *a_trak = gf_isom_get_track_from_file(movie, i+1);\n\t\treset_tsel_box(a_trak);\n\t\ti++;\n\t}\n\treturn GF_OK;\n}\n\n\nGF_Err gf_isom_add_subsample(GF_ISOFile *movie, u32 track, u32 sampleNumber, u32 flags, u32 subSampleSize, u8 priority, u32 reserved, Bool discardable)\n{\n\tu32 i, count;\n\tGF_SubSampleInformationBox *sub_samples;\n\tGF_TrackBox *trak;\n\tGF_Err e;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, track);\n\tif (!trak || !trak->Media || !trak->Media->information->sampleTable)\n\t\treturn GF_BAD_PARAM;\n\n\tif (!trak->Media->information->sampleTable->sub_samples) {\n\t\ttrak->Media->information->sampleTable->sub_samples=gf_list_new();\n\t}\n\n\tsub_samples = NULL;\n\tcount = gf_list_count(trak->Media->information->sampleTable->sub_samples);\n\tfor (i=0; i<count; i++) {\n\t\tsub_samples = gf_list_get(trak->Media->information->sampleTable->sub_samples, i);\n\t\tif (sub_samples->flags==flags) break;\n\t\tsub_samples = NULL;\n\t}\n\tif (!sub_samples) {\n\t\tsub_samples = (GF_SubSampleInformationBox *) gf_isom_box_new_parent(&trak->Media->information->sampleTable->child_boxes, GF_ISOM_BOX_TYPE_SUBS);\n\t\tif (!sub_samples) return GF_OUT_OF_MEM;\n\t\tgf_list_add(trak->Media->information->sampleTable->sub_samples, sub_samples);\n\t\tsub_samples->version = (subSampleSize>0xFFFF) ? 1 : 0;\n\t\tsub_samples->flags = flags;\n\t}\n\treturn gf_isom_add_subsample_info(sub_samples, sampleNumber, subSampleSize, priority, reserved, discardable);\n}\n\n\nGF_EXPORT\nGF_Err gf_isom_set_rvc_config(GF_ISOFile *movie, u32 track, u32 sampleDescriptionIndex, u16 rvc_predefined, char *mime, u8 *data, u32 size)\n{\n\tGF_MPEGVisualSampleEntryBox *entry;\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, track);\n\tif (!trak) return GF_BAD_PARAM;\n\n\n\tentry = (GF_MPEGVisualSampleEntryBox *) gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, sampleDescriptionIndex-1);\n\tif (!entry ) return GF_BAD_PARAM;\n\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_VIDEO) return GF_BAD_PARAM;\n\n\tGF_RVCConfigurationBox *rvcc = (GF_RVCConfigurationBox *) gf_isom_box_find_child(entry->child_boxes, GF_ISOM_BOX_TYPE_RVCC);\n\tif (rvcc && rvcc->rvc_meta_idx) {\n\t\tgf_isom_remove_meta_item(movie, GF_FALSE, track, rvcc->rvc_meta_idx);\n\t\trvcc->rvc_meta_idx = 0;\n\t}\n\n\tif (!rvcc) {\n\t\trvcc = (GF_RVCConfigurationBox *) gf_isom_box_new_parent(&entry->child_boxes, GF_ISOM_BOX_TYPE_RVCC);\n\t\tif (!rvcc) return GF_OUT_OF_MEM;\n\t}\n\trvcc->predefined_rvc_config = rvc_predefined;\n\tif (!rvc_predefined) {\n\t\tu32 it_id=0;\n\t\te = gf_isom_set_meta_type(movie, GF_FALSE, track, GF_META_TYPE_RVCI);\n\t\tif (e) return e;\n\t\tgf_isom_modify_alternate_brand(movie, GF_ISOM_BRAND_ISO2, GF_TRUE);\n\t\te = gf_isom_add_meta_item_memory(movie, GF_FALSE, track, \"rvcconfig.xml\", &it_id, GF_META_ITEM_TYPE_MIME, mime, NULL, NULL, data, size, NULL);\n\t\tif (e) return e;\n\t\trvcc->rvc_meta_idx = gf_isom_get_meta_item_count(movie, GF_FALSE, track);\n\t}\n\treturn GF_OK;\n}\n\n/*for now not exported*/\n/*expands sampleGroup table for the given grouping type and sample_number. If sample_number is 0, just appends an entry at the end of the table*/\nstatic GF_Err gf_isom_add_sample_group_entry(GF_List *sampleGroups, u32 sample_number, u32 grouping_type, u32 grouping_type_parameter, u32 sampleGroupDescriptionIndex, GF_List *parent, GF_SampleTableBox *stbl)\n{\n\tGF_SampleGroupBox *sgroup = NULL;\n\tu32 i, count, last_sample_in_entry;\n\tBool all_samples = GF_FALSE;\n\tassert(sampleGroups);\n\tcount = gf_list_count(sampleGroups);\n\tfor (i=0; i<count; i++) {\n\t\tsgroup = (GF_SampleGroupBox*)gf_list_get(sampleGroups, i);\n\t\tif (sgroup->grouping_type==grouping_type) break;\n\t\tsgroup = NULL;\n\t}\n\tif (!sgroup) {\n\t\tsgroup = (GF_SampleGroupBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_SBGP);\n\t\tif (!sgroup) return GF_OUT_OF_MEM;\n\t\tsgroup->grouping_type = grouping_type;\n\t\tsgroup->grouping_type_parameter = grouping_type_parameter;\n//\t\tgf_list_add(sampleGroups, sgroup);\n\t\t//crude patch to align old arch and filters\n\t\tgf_list_insert(sampleGroups, sgroup, 0);\n\t\tassert(parent);\n\t\tgf_list_add(parent, sgroup);\n\t}\n\t/*used in fragments, means we are adding the last sample*/\n\tif (!sample_number) {\n\t\tsample_number = 1;\n\t\tif (sgroup->entry_count) {\n\t\t\tfor (i=0; i<sgroup->entry_count; i++) {\n\t\t\t\tsample_number += sgroup->sample_entries[i].sample_count;\n\t\t\t}\n\t\t}\n\t} else if (sample_number==(u32) -1) {\n\t\tall_samples = GF_TRUE;\n\t\tsample_number = 1;\n\t}\n\n\tif (!sgroup->entry_count) {\n\t\tu32 idx = 0;\n\t\tsgroup->entry_count = (sample_number>1) ? 2 : 1;\n\t\tsgroup->sample_entries = (GF_SampleGroupEntry*)gf_malloc(sizeof(GF_SampleGroupEntry) * sgroup->entry_count );\n\t\tif (!sgroup->sample_entries) return GF_OUT_OF_MEM;\n\t\tif (sample_number>1) {\n\t\t\tsgroup->sample_entries[0].sample_count = sample_number-1;\n\t\t\tsgroup->sample_entries[0].group_description_index = sampleGroupDescriptionIndex ? 0 : 1;\n\t\t\tidx = 1;\n\t\t}\n\t\tsgroup->sample_entries[idx].sample_count = 1;\n\t\tsgroup->sample_entries[idx].group_description_index = sampleGroupDescriptionIndex;\n\t\tif (all_samples && stbl) {\n\t\t\tsgroup->sample_entries[idx].sample_count = stbl->SampleSize->sampleCount;\n\t\t}\n\t\treturn GF_OK;\n\t}\n\tif (all_samples && stbl) {\n\t\tsgroup->entry_count = 1;\n\t\tsgroup->sample_entries[0].group_description_index = sampleGroupDescriptionIndex;\n\t\tsgroup->sample_entries[0].sample_count = stbl->SampleSize->sampleCount;\n\t\treturn GF_OK;\n\t}\n\tlast_sample_in_entry = 0;\n\tfor (i=0; i<sgroup->entry_count; i++) {\n\t\t/*TODO*/\n\t\tif (last_sample_in_entry + sgroup->sample_entries[i].sample_count > sample_number) return GF_NOT_SUPPORTED;\n\t\tlast_sample_in_entry += sgroup->sample_entries[i].sample_count;\n\t}\n\n\tif (last_sample_in_entry == sample_number) {\n\t\tif (sgroup->sample_entries[sgroup->entry_count-1].group_description_index==sampleGroupDescriptionIndex)\n\t\t\treturn GF_OK;\n\t\telse\n\t\t\treturn GF_NOT_SUPPORTED;\n\t}\n\n\tif ((sgroup->sample_entries[sgroup->entry_count-1].group_description_index==sampleGroupDescriptionIndex) && (last_sample_in_entry+1==sample_number)) {\n\t\tsgroup->sample_entries[sgroup->entry_count-1].sample_count++;\n\t\treturn GF_OK;\n\t}\n\t/*last entry was an empty desc (no group associated), just add the number of samples missing until new one, then add new one*/\n\tif (! sgroup->sample_entries[sgroup->entry_count-1].group_description_index) {\n\t\tsgroup->sample_entries[sgroup->entry_count-1].sample_count += sample_number - 1 - last_sample_in_entry;\n\t\tsgroup->sample_entries = (GF_SampleGroupEntry*)gf_realloc(sgroup->sample_entries, sizeof(GF_SampleGroupEntry) * (sgroup->entry_count + 1) );\n\t\tsgroup->sample_entries[sgroup->entry_count].sample_count = 1;\n\t\tsgroup->sample_entries[sgroup->entry_count].group_description_index = sampleGroupDescriptionIndex;\n\t\tsgroup->entry_count++;\n\t\treturn GF_OK;\n\t}\n\t/*we are adding a sample with no desc, add entry at the end*/\n\tif (!sampleGroupDescriptionIndex || (sample_number - 1 - last_sample_in_entry==0) ) {\n\t\tsgroup->sample_entries = (GF_SampleGroupEntry*)gf_realloc(sgroup->sample_entries, sizeof(GF_SampleGroupEntry) * (sgroup->entry_count + 1) );\n\t\tsgroup->sample_entries[sgroup->entry_count].sample_count = 1;\n\t\tsgroup->sample_entries[sgroup->entry_count].group_description_index = sampleGroupDescriptionIndex;\n\t\tsgroup->entry_count++;\n\t\treturn GF_OK;\n\t}\n\t/*need to insert two entries ...*/\n\tsgroup->sample_entries = (GF_SampleGroupEntry*)gf_realloc(sgroup->sample_entries, sizeof(GF_SampleGroupEntry) * (sgroup->entry_count + 2) );\n\n\tsgroup->sample_entries[sgroup->entry_count].sample_count = sample_number - 1 - last_sample_in_entry;\n\tsgroup->sample_entries[sgroup->entry_count].group_description_index = 0;\n\n\tsgroup->sample_entries[sgroup->entry_count+1].sample_count = 1;\n\tsgroup->sample_entries[sgroup->entry_count+1].group_description_index = sampleGroupDescriptionIndex;\n\tsgroup->entry_count+=2;\n\treturn GF_OK;\n}\n\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\nstatic GF_SampleGroupDescriptionBox *get_sgdp(GF_SampleTableBox *stbl, GF_TrackFragmentBox *traf, u32 grouping_type, Bool *is_traf_sgdp)\n#else\nstatic GF_SampleGroupDescriptionBox *get_sgdp(GF_SampleTableBox *stbl, void *traf, u32 grouping_type, Bool *is_traf_sgdp)\n#endif /* GPAC_DISABLE_ISOM_FRAGMENTS */\n{\n\tGF_List *groupList=NULL;\n\tGF_List **parent=NULL;\n\tGF_SampleGroupDescriptionBox *sgdesc=NULL;\n\tu32 count, i;\n\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\tif (!stbl && traf && traf->trex->track->Media->information->sampleTable)\n\t\tstbl = traf->trex->track->Media->information->sampleTable;\n#endif\n\tif (stbl) {\n\t\tif (!stbl->sampleGroupsDescription && !traf)\n\t\t\tstbl->sampleGroupsDescription = gf_list_new();\n\n\t\tgroupList = stbl->sampleGroupsDescription;\n\t\tif (is_traf_sgdp) *is_traf_sgdp = GF_FALSE;\n\t\tparent = &stbl->child_boxes;\n\n\t\tcount = gf_list_count(groupList);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tsgdesc = (GF_SampleGroupDescriptionBox*)gf_list_get(groupList, i);\n\t\t\tif (sgdesc->grouping_type==grouping_type) break;\n\t\t\tsgdesc = NULL;\n\t\t}\n\t}\n\t\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t/*look in stbl or traf for sample sampleGroupsDescription*/\n\tif (!sgdesc && traf) {\n\t\tif (!traf->sampleGroupsDescription)\n\t\t\ttraf->sampleGroupsDescription = gf_list_new();\n\t\tgroupList = traf->sampleGroupsDescription;\n\t\tparent = &traf->child_boxes;\n\t\tif (is_traf_sgdp) *is_traf_sgdp = GF_TRUE;\n\n\t\tcount = gf_list_count(groupList);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tsgdesc = (GF_SampleGroupDescriptionBox*)gf_list_get(groupList, i);\n\t\t\tif (sgdesc->grouping_type==grouping_type) break;\n\t\t\tsgdesc = NULL;\n\t\t}\n\t}\n#endif\n\n\tif (!sgdesc) {\n\t\tsgdesc = (GF_SampleGroupDescriptionBox *) gf_isom_box_new_parent(parent, GF_ISOM_BOX_TYPE_SGPD);\n\t\tif (!sgdesc) return NULL;\n\t\tsgdesc->grouping_type = grouping_type;\n\t\tassert(groupList);\n\t\tgf_list_add(groupList, sgdesc);\n\t}\n\treturn sgdesc;\n}\n\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\nstatic GF_Err gf_isom_set_sample_group_info_ex(GF_SampleTableBox *stbl, GF_TrackFragmentBox *traf, u32 sample_number, u32 grouping_type, u32 grouping_type_parameter, void *udta, void *(*sg_create_entry)(void *udta), Bool (*sg_compare_entry)(void *udta, void *entry))\n#else\nstatic GF_Err gf_isom_set_sample_group_info_ex(GF_SampleTableBox *stbl, void *traf, u32 sample_number, u32 grouping_type, u32 grouping_type_parameter, void *udta, void *(*sg_create_entry)(void *udta), Bool (*sg_compare_entry)(void *udta, void *entry))\n#endif /* GPAC_DISABLE_ISOM_FRAGMENTS */\n{\n\tGF_List *groupList, *parent;\n\tvoid *entry;\n\tBool is_traf_sgpd;\n\tGF_SampleGroupDescriptionBox *sgdesc = NULL;\n\tu32 i, entry_idx;\n\n\tif (!stbl && !traf) return GF_BAD_PARAM;\n\n\tsgdesc = get_sgdp(stbl, traf, grouping_type, &is_traf_sgpd);\n\tif (!sgdesc) return GF_OUT_OF_MEM;\n\n\tentry = NULL;\n\tif (sg_compare_entry) {\n\t\tfor (i=0; i<gf_list_count(sgdesc->group_descriptions); i++) {\n\t\t\tentry = gf_list_get(sgdesc->group_descriptions, i);\n\t\t\tif (sg_compare_entry(udta, entry)) break;\n\t\t\tentry = NULL;\n\t\t}\n\t}\n\tif (!entry && sg_create_entry) {\n\t\tentry = sg_create_entry(udta);\n\t\tif (!entry) return GF_IO_ERR;\n\t\tif (traf && !is_traf_sgpd) {\n\t\t\tsgdesc = get_sgdp(NULL, traf, grouping_type, &is_traf_sgpd);\n\t\t}\n\t\tgf_list_add(sgdesc->group_descriptions, entry);\n\t}\n\tif (!entry)\n\t\tentry_idx = 0;\n\telse\n\t\tentry_idx = 1 + gf_list_find(sgdesc->group_descriptions, entry);\n\n\t/*look in stbl or traf for sample sampleGroups*/\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\tif (traf) {\n\t\tif (!traf->sampleGroups)\n\t\t\ttraf->sampleGroups = gf_list_new();\n\t\tgroupList = traf->sampleGroups;\n\t\tparent = traf->child_boxes;\n\t\tif (entry_idx && is_traf_sgpd)\n\t\t\tentry_idx |= 0x10000;\n\t} else\n#endif\n\t{\n\t\tif (!stbl->sampleGroups)\n\t\t\tstbl->sampleGroups = gf_list_new();\n\t\tgroupList = stbl->sampleGroups;\n\t\tparent = stbl->child_boxes;\n\t}\n\n\treturn gf_isom_add_sample_group_entry(groupList, sample_number, grouping_type, grouping_type_parameter, entry_idx, parent, stbl);\n}\n\n/*for now not exported*/\nstatic GF_Err gf_isom_set_sample_group_info(GF_ISOFile *movie, u32 track, u32 trafID, u32 sample_number, u32 grouping_type, u32 grouping_type_parameter, void *udta, void *(*sg_create_entry)(void *udta), Bool (*sg_compare_entry)(void *udta, void *entry))\n{\n\tGF_Err e;\n\tGF_TrackBox *trak=NULL;\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\tGF_TrackFragmentBox *traf=NULL;\n#endif\n\tif (!trafID && (movie->FragmentsFlags & GF_ISOM_FRAG_WRITE_READY)) {\n\t\ttrak = gf_isom_get_track_from_file(movie, track);\n\t\tif (!trak) return GF_BAD_PARAM;\n\t\ttrafID = trak->Header->trackID;\n\t}\n\n\tif (trafID) {\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t\tif (!movie->moof || !(movie->FragmentsFlags & GF_ISOM_FRAG_WRITE_READY) )\n\t\t\treturn GF_BAD_PARAM;\n\n\t\ttraf = gf_isom_get_traf(movie, trafID);\n#else\n\t\treturn GF_NOT_SUPPORTED;\n#endif\n\n\t} else if (track) {\n\t\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\t\tif (e) return e;\n\n\t\ttrak = gf_isom_get_track_from_file(movie, track);\n\t\tif (!trak) return GF_BAD_PARAM;\n\t}\n\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\treturn gf_isom_set_sample_group_info_ex(trak ? trak->Media->information->sampleTable : NULL, traf, sample_number, grouping_type, grouping_type_parameter, udta, sg_create_entry, sg_compare_entry);\n#else\n\treturn gf_isom_set_sample_group_info_ex(trak->Media->information->sampleTable, sample_number, grouping_type, grouping_type_parameter, udta, sg_create_entry, sg_compare_entry);\n#endif\n\n}\n\n\nGF_EXPORT\nGF_Err gf_isom_add_sample_group_info(GF_ISOFile *movie, u32 track, u32 grouping_type, void *data, u32 data_size, Bool is_default, u32 *sampleGroupDescriptionIndex)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\tGF_DefaultSampleGroupDescriptionEntry *entry=NULL;\n\tGF_SampleGroupDescriptionBox *sgdesc = NULL;\n\n\tif (sampleGroupDescriptionIndex) *sampleGroupDescriptionIndex = 0;\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, track);\n\tif (!trak) return GF_BAD_PARAM;\n\n\n\tsgdesc = get_sgdp(trak->Media->information->sampleTable, NULL, grouping_type, NULL);\n\tif (!sgdesc) return GF_OUT_OF_MEM;\n\n\tif (grouping_type==GF_ISOM_SAMPLE_GROUP_OINF) {\n\t\tGF_OperatingPointsInformation *ptr = gf_isom_oinf_new_entry();\n\t\tGF_BitStream *bs=gf_bs_new(data, data_size, GF_BITSTREAM_READ);\n\t\te = gf_isom_oinf_read_entry(ptr, bs);\n\t\tgf_bs_del(bs);\n\t\tif (e) {\n\t\t\tgf_isom_oinf_del_entry(ptr);\n\t\t\treturn e;\n\t\t}\n\t\te = gf_list_add(sgdesc->group_descriptions, ptr);\n\t\tif (e) return e;\n\t\tentry = (GF_DefaultSampleGroupDescriptionEntry *) ptr;\n\t} else if (grouping_type==GF_ISOM_SAMPLE_GROUP_LINF) {\n\t\tGF_LHVCLayerInformation *ptr = gf_isom_linf_new_entry();\n\t\tGF_BitStream *bs=gf_bs_new(data, data_size, GF_BITSTREAM_READ);\n\t\te = gf_isom_linf_read_entry(ptr, bs);\n\t\tgf_bs_del(bs);\n\t\tif (e) {\n\t\t\tgf_isom_linf_del_entry(ptr);\n\t\t\treturn e;\n\t\t}\n\t\te = gf_list_add(sgdesc->group_descriptions, ptr);\n\t\tif (e) return e;\n\t\tentry = (GF_DefaultSampleGroupDescriptionEntry *) ptr;\n\t} else {\n\t\tu32 i, count=gf_list_count(sgdesc->group_descriptions);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tGF_DefaultSampleGroupDescriptionEntry *ent = gf_list_get(sgdesc->group_descriptions, i);\n\t\t\tif ((ent->length == data_size) && !memcmp(ent->data, data, data_size)) {\n\t\t\t\tentry = ent;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tentry=NULL;\n\t\t}\n\t\tif (!entry) {\n\t\t\tGF_SAFEALLOC(entry, GF_DefaultSampleGroupDescriptionEntry);\n\t\t\tif (!entry) return GF_OUT_OF_MEM;\n\t\t\tentry->data = (u8*)gf_malloc(sizeof(char) * data_size);\n\t\t\tif (!entry->data) {\n\t\t\t\tgf_free(entry);\n\t\t\t\treturn GF_OUT_OF_MEM;\n\t\t\t}\n\t\t\tentry->length = data_size;\n\t\t\tmemcpy(entry->data, data, sizeof(char) * data_size);\n\t\t\te = gf_list_add(sgdesc->group_descriptions, entry);\n\t\t\tif (e) {\n\t\t\t\tgf_free(entry->data);\n\t\t\t\tgf_free(entry);\n\t\t\t\treturn e;\n\t\t\t}\n\t\t}\n\t}\n\n\n\tif (is_default) {\n\t\tsgdesc->default_description_index = 1 + gf_list_find(sgdesc->group_descriptions, entry);\n\t\tsgdesc->version = 2;\n\t}\n\tif (sampleGroupDescriptionIndex) *sampleGroupDescriptionIndex = 1 + gf_list_find(sgdesc->group_descriptions, entry);\n\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_remove_sample_group(GF_ISOFile *movie, u32 track, u32 grouping_type)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\tu32 count, i;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, track);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tif (trak->Media->information->sampleTable->sampleGroupsDescription) {\n\t\tcount = gf_list_count(trak->Media->information->sampleTable->sampleGroupsDescription);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tGF_SampleGroupDescriptionBox *sgdesc = (GF_SampleGroupDescriptionBox*)gf_list_get(trak->Media->information->sampleTable->sampleGroupsDescription, i);\n\t\t\tif (sgdesc->grouping_type==grouping_type) {\n\t\t\t\tgf_isom_box_del_parent(&trak->Media->information->sampleTable->child_boxes, (GF_Box*)sgdesc);\n\t\t\t\tgf_list_rem(trak->Media->information->sampleTable->sampleGroupsDescription, i);\n\t\t\t\ti--;\n\t\t\t\tcount--;\n\t\t\t}\n\t\t}\n\t}\n\tif (trak->Media->information->sampleTable->sampleGroups) {\n\t\tcount = gf_list_count(trak->Media->information->sampleTable->sampleGroups);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tGF_SampleGroupBox *sgroup = gf_list_get(trak->Media->information->sampleTable->sampleGroups, i);\n\t\t\tif (sgroup->grouping_type==grouping_type) {\n\t\t\t\tgf_isom_box_del_parent(&trak->Media->information->sampleTable->child_boxes, (GF_Box*)sgroup);\n\t\t\t\tgf_list_rem(trak->Media->information->sampleTable->sampleGroups, i);\n\t\t\t\ti--;\n\t\t\t\tcount--;\n\t\t\t}\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_add_sample_info(GF_ISOFile *movie, u32 track, u32 sample_number, u32 grouping_type, u32 sampleGroupDescriptionIndex, u32 grouping_type_parameter)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\tGF_List *groupList;\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, track);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tif (!trak->Media->information->sampleTable->sampleGroups)\n\t\ttrak->Media->information->sampleTable->sampleGroups = gf_list_new();\n\n\tgroupList = trak->Media->information->sampleTable->sampleGroups;\n\treturn gf_isom_add_sample_group_entry(groupList, sample_number, grouping_type, grouping_type_parameter, sampleGroupDescriptionIndex, trak->Media->information->sampleTable->child_boxes, trak->Media->information->sampleTable);\n}\n\nvoid *sg_rap_create_entry(void *udta)\n{\n\tGF_VisualRandomAccessEntry *entry;\n\tu32 *num_leading_samples = (u32 *) udta;\n\tassert(udta);\n\tGF_SAFEALLOC(entry, GF_VisualRandomAccessEntry);\n\tif (!entry) return NULL;\n\tentry->num_leading_samples = *num_leading_samples;\n\tentry->num_leading_samples_known = entry->num_leading_samples ? 1 : 0;\n\treturn entry;\n}\n\nBool sg_rap_compare_entry(void *udta, void *entry)\n{\n\tu32 *num_leading_samples = (u32 *) udta;\n\tif (*num_leading_samples == ((GF_VisualRandomAccessEntry *)entry)->num_leading_samples) return GF_TRUE;\n\treturn GF_FALSE;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_sample_rap_group(GF_ISOFile *movie, u32 track, u32 sample_number, Bool is_rap, u32 num_leading_samples)\n{\n\treturn gf_isom_set_sample_group_info(movie, track, 0, sample_number, GF_ISOM_SAMPLE_GROUP_RAP, 0, &num_leading_samples, is_rap ? sg_rap_create_entry : NULL, is_rap ? sg_rap_compare_entry : NULL);\n}\n\nGF_Err gf_isom_fragment_set_sample_rap_group(GF_ISOFile *movie, GF_ISOTrackID trackID, u32 sample_number_in_frag, Bool is_rap, u32 num_leading_samples)\n{\n\treturn gf_isom_set_sample_group_info(movie, 0, trackID, sample_number_in_frag, GF_ISOM_SAMPLE_GROUP_RAP, 0, &num_leading_samples, is_rap ? sg_rap_create_entry : NULL, is_rap ? sg_rap_compare_entry : NULL);\n}\n\n\n\nvoid *sg_roll_create_entry(void *udta)\n{\n\tGF_RollRecoveryEntry *entry;\n\ts16 *roll_distance = (s16 *) udta;\n\tGF_SAFEALLOC(entry, GF_RollRecoveryEntry);\n\tif (!entry) return NULL;\n\tentry->roll_distance = *roll_distance;\n\treturn entry;\n}\n\nBool sg_roll_compare_entry(void *udta, void *entry)\n{\n\ts16 *roll_distance = (s16 *) udta;\n\tif (*roll_distance == ((GF_RollRecoveryEntry *)entry)->roll_distance) return GF_TRUE;\n\treturn GF_FALSE;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_sample_roll_group(GF_ISOFile *movie, u32 track, u32 sample_number, GF_ISOSampleRollType roll_type, s16 roll_distance)\n{\n\tu32 grp_type = (roll_type>=GF_ISOM_SAMPLE_PREROLL) ? GF_ISOM_SAMPLE_GROUP_PROL : GF_ISOM_SAMPLE_GROUP_ROLL;\n\tif (roll_type==GF_ISOM_SAMPLE_PREROLL_NONE)\n\t\troll_type = 0;\n\n\treturn gf_isom_set_sample_group_info(movie, track, 0, sample_number, grp_type, 0, &roll_distance, roll_type ? sg_roll_create_entry : NULL, roll_type ? sg_roll_compare_entry : NULL);\n}\n\nGF_EXPORT\nGF_Err gf_isom_fragment_set_sample_roll_group(GF_ISOFile *movie, GF_ISOTrackID trackID, u32 sample_number_in_frag, GF_ISOSampleRollType roll_type, s16 roll_distance)\n{\n\tu32 grp_type = (roll_type>=GF_ISOM_SAMPLE_PREROLL) ? GF_ISOM_SAMPLE_GROUP_PROL : GF_ISOM_SAMPLE_GROUP_ROLL;\n\tif (roll_type==GF_ISOM_SAMPLE_PREROLL_NONE)\n\t\troll_type = 0;\n\n\treturn gf_isom_set_sample_group_info(movie, 0, trackID, sample_number_in_frag, grp_type, 0, &roll_distance, roll_type ? sg_roll_create_entry : NULL, roll_type ? sg_roll_compare_entry : NULL);\n}\n\n\nvoid *sg_encryption_create_entry(void *udta)\n{\n\tGF_CENCSampleEncryptionGroupEntry *entry, *from_entry;\n\tGF_SAFEALLOC(entry, GF_CENCSampleEncryptionGroupEntry);\n\tif (!entry) return NULL;\n\tfrom_entry = (GF_CENCSampleEncryptionGroupEntry *)udta;\n\tmemcpy(entry, from_entry, sizeof(GF_CENCSampleEncryptionGroupEntry) );\n\tentry->key_info = gf_malloc(sizeof(u8) * entry->key_info_size);\n\tif (!entry->key_info) {\n\t\tgf_free(entry);\n\t\treturn NULL;\n\t}\n\tmemcpy(entry->key_info, from_entry->key_info, entry->key_info_size);\n\treturn entry;\n}\n\nBool sg_encryption_compare_entry(void *udta, void *_entry)\n{\n\tGF_CENCSampleEncryptionGroupEntry *entry = (GF_CENCSampleEncryptionGroupEntry *)_entry;\n\tGF_CENCSampleEncryptionGroupEntry *with_entry = (GF_CENCSampleEncryptionGroupEntry *)udta;\n\n\tif (entry->IsProtected != with_entry->IsProtected) return GF_FALSE;\n\tif (entry->skip_byte_block != with_entry->skip_byte_block) return GF_FALSE;\n\tif (entry->crypt_byte_block != with_entry->crypt_byte_block) return GF_FALSE;\n\tif (entry->key_info_size != with_entry->key_info_size) return GF_FALSE;\n\n\tif (!memcmp(entry->key_info, with_entry->key_info, with_entry->key_info_size))\n\t\treturn GF_TRUE;\n\treturn GF_FALSE;\n}\n\n\n/*sample encryption information group can be in stbl or traf*/\nGF_EXPORT\nGF_Err gf_isom_set_sample_cenc_group(GF_ISOFile *movie, u32 track, u32 sample_number, u8 isEncrypted, u8 crypt_byte_block, u8 skip_byte_block, u8 *key_info, u32 key_info_size)\n{\n\tGF_CENCSampleEncryptionGroupEntry entry;\n\tif (!key_info || (key_info_size<19))\n\t\treturn GF_BAD_PARAM;\n\n\tmemset(&entry, 0, sizeof(GF_CENCSampleEncryptionGroupEntry));\n\tentry.crypt_byte_block = crypt_byte_block;\n\tentry.skip_byte_block = skip_byte_block;\n\tentry.IsProtected = isEncrypted;\n\tentry.key_info = key_info;\n\tentry.key_info_size = key_info_size;\n\n\treturn gf_isom_set_sample_group_info(movie, track, 0, sample_number, GF_ISOM_SAMPLE_GROUP_SEIG, 0, &entry, sg_encryption_create_entry, sg_encryption_compare_entry);\n}\n\n\n\nGF_EXPORT\nGF_Err gf_isom_set_sample_cenc_default_group(GF_ISOFile *movie, u32 track, u32 sample_number)\n{\n\treturn gf_isom_set_sample_group_info(movie, track, 0, sample_number, GF_ISOM_SAMPLE_GROUP_SEIG, 0, NULL, NULL, NULL);\n}\n\nGF_Err gf_isom_force_ctts(GF_ISOFile *file, u32 track)\n{\n\tGF_TrackBox *trak;\n\tGF_Err e = CanAccessMovie(file, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n \ttrak = gf_isom_get_track_from_file(file, track);\n\tif (!trak) return GF_BAD_PARAM;\n\tif (trak->Media->information->sampleTable->CompositionOffset) return GF_OK;\n\n\ttrak->Media->information->sampleTable->CompositionOffset = (GF_CompositionOffsetBox *) gf_isom_box_new_parent(&trak->Media->information->sampleTable->child_boxes, GF_ISOM_BOX_TYPE_CTTS);\n\tif (!trak->Media->information->sampleTable->CompositionOffset) return GF_OUT_OF_MEM;\n\ttrak->Media->information->sampleTable->CompositionOffset->nb_entries = 1;\n\ttrak->Media->information->sampleTable->CompositionOffset->entries = gf_malloc(sizeof(GF_DttsEntry));\n\ttrak->Media->information->sampleTable->CompositionOffset->entries[0].decodingOffset = 0;\n\ttrak->Media->information->sampleTable->CompositionOffset->entries[0].sampleCount = \ttrak->Media->information->sampleTable->SampleSize->sampleCount;\n\treturn GF_OK;\n}\n\nGF_Err gf_isom_set_ctts_v1(GF_ISOFile *file, u32 track, u32 ctts_shift)\n{\n\tu32 i, shift;\n\tu64 duration;\n\tGF_CompositionOffsetBox *ctts;\n\tGF_CompositionToDecodeBox *cslg;\n\ts32 leastCTTS, greatestCTTS;\n\tGF_TrackBox *trak;\n\tGF_Err e = CanAccessMovie(file, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n \ttrak = gf_isom_get_track_from_file(file, track);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tctts = trak->Media->information->sampleTable->CompositionOffset;\n\tshift = ctts->version ? ctts_shift : ctts->entries[0].decodingOffset;\n\tleastCTTS = GF_INT_MAX;\n\tgreatestCTTS = 0;\n\tfor (i=0; i<ctts->nb_entries; i++) {\n\t\tif (!ctts->version)\n\t\t\tctts->entries[i].decodingOffset -= shift;\n\n\t\tif ((s32)ctts->entries[i].decodingOffset < leastCTTS)\n\t\t\tleastCTTS = ctts->entries[i].decodingOffset;\n\t\tif ((s32)ctts->entries[i].decodingOffset > greatestCTTS)\n\t\t\tgreatestCTTS = ctts->entries[i].decodingOffset;\n\t}\n\tif (!ctts->version) {\n\t\tctts->version = 1;\n\t\t//if we had edit lists, shift all media times by the given amount\n\t\tif (trak->editBox && trak->editBox->editList) {\n\t\t\tfor (i=0; i<gf_list_count(trak->editBox->editList->entryList); i++) {\n\t\t\t\tGF_EdtsEntry *ent = (GF_EdtsEntry*)gf_list_get(trak->editBox->editList->entryList, i);\n\t\t\t\t//empty edit\n\t\t\t\tif (ent->mediaTime<0) continue;\n\t\t\t\tif (ent->mediaTime>=shift) ent->mediaTime -= shift;\n\t\t\t\telse ent->mediaTime = 0;\n\t\t\t\t//no offset and last entry, trash edit\n\t\t\t\tif (!ent->mediaTime && (gf_list_count(trak->editBox->editList->entryList)==1)) {\n\t\t\t\t\tgf_isom_box_del_parent(&trak->child_boxes, (GF_Box *)trak->editBox);\n\t\t\t\t\ttrak->editBox = NULL;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSetTrackDuration(trak);\n\t\t}\n\t}\n\n\tif (!trak->Media->information->sampleTable->CompositionToDecode) {\n\t\ttrak->Media->information->sampleTable->CompositionToDecode = (GF_CompositionToDecodeBox *) gf_isom_box_new_parent(&trak->Media->information->sampleTable->child_boxes, GF_ISOM_BOX_TYPE_CSLG);\n\t\tif (!trak->Media->information->sampleTable->CompositionToDecode)\n\t\t\treturn GF_OUT_OF_MEM;\n\t}\n\n\tcslg = trak->Media->information->sampleTable->CompositionToDecode;\n\tif (cslg) {\n\t\tcslg->compositionToDTSShift = shift;\n\t\tcslg->leastDecodeToDisplayDelta = leastCTTS;\n\t\tcslg->greatestDecodeToDisplayDelta = greatestCTTS;\n\t\tcslg->compositionStartTime = 0;\n\t\t/*for our use case (first CTS set to 0), the composition end time is the media duration if it fits on 32 bits*/\n\t\tduration = gf_isom_get_media_duration(file, track);\n\t\tcslg->compositionEndTime = (duration<0x7FFFFFFF) ? (s32) duration : 0;\n\t}\n\n\tgf_isom_modify_alternate_brand(file, GF_ISOM_BRAND_ISO4, GF_TRUE);\n\treturn GF_OK;\n}\n\nstatic GF_Err gf_isom_set_ctts_v0(GF_ISOFile *file, GF_TrackBox *trak)\n{\n\tu32 i;\n\ts32 shift;\n\tGF_CompositionOffsetBox *ctts;\n\tGF_CompositionToDecodeBox *cslg;\n\n\tctts = trak->Media->information->sampleTable->CompositionOffset;\n\n\tif (!trak->Media->information->sampleTable->CompositionToDecode)\n\t{\n\t\tshift = 0;\n\t\tfor (i=0; i<ctts->nb_entries; i++) {\n\t\t\tif (-ctts->entries[i].decodingOffset > shift)\n\t\t\t\tshift = -ctts->entries[i].decodingOffset;\n\t\t}\n\t\tif (shift > 0)\n\t\t{\n\t\t\tfor (i=0; i<ctts->nb_entries; i++) {\n\t\t\t\tctts->entries[i].decodingOffset += shift;\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\tcslg = trak->Media->information->sampleTable->CompositionToDecode;\n\t\tshift = cslg->compositionToDTSShift;\n\t\tfor (i=0; i<ctts->nb_entries; i++) {\n\t\t\tctts->entries[i].decodingOffset += shift;\n\t\t}\n\t\tgf_isom_box_del_parent(&trak->Media->information->sampleTable->child_boxes, (GF_Box *)cslg);\n\t\ttrak->Media->information->sampleTable->CompositionToDecode = NULL;\n\t}\n\tif (shift>0) {\n\t\t//no edits, insert one\n\t\tif (! trak->editBox) {\n\t\t\tu64 dur = trak->Media->mediaHeader->duration;\n\t\t\tdur *= file->moov->mvhd->timeScale;\n\t\t\tdur /= trak->Media->mediaHeader->timeScale;\n\t\t\tgf_isom_set_edit(file, gf_list_find(file->moov->trackList, trak)+1, 0, dur, shift, GF_ISOM_EDIT_NORMAL);\n\t\t} else {\n\t\t\t//otherwise shift media times in all entries\n\t\t\tfor (i=0; i<gf_list_count(trak->editBox->editList->entryList); i++) {\n\t\t\t\tGF_EdtsEntry *ent = (GF_EdtsEntry*)gf_list_get(trak->editBox->editList->entryList, i);\n\t\t\t\t//empty edit\n\t\t\t\tif (ent->mediaTime<0) continue;\n\t\t\t\tent->mediaTime += shift;\n\t\t\t}\n\t\t\tSetTrackDuration(trak);\n\t\t}\n\t}\n\tctts->version = 0;\n\tgf_isom_modify_alternate_brand(file, GF_ISOM_BRAND_ISO4, GF_FALSE);\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_composition_offset_mode(GF_ISOFile *file, u32 track, Bool use_negative_offsets)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\tGF_CompositionOffsetBox *ctts;\n\n\te = CanAccessMovie(file, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(file, track);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tctts = trak->Media->information->sampleTable->CompositionOffset;\n\tif (!ctts) {\n\t\tif (!use_negative_offsets && trak->Media->information->sampleTable->CompositionToDecode) {\n\t\t\tgf_isom_box_del_parent(&trak->Media->information->sampleTable->child_boxes, (GF_Box *)trak->Media->information->sampleTable->CompositionToDecode);\n\t\t\ttrak->Media->information->sampleTable->CompositionToDecode = NULL;\n\t\t}\n\t\treturn GF_OK;\n\t}\n\n\tif (use_negative_offsets) {\n\t\treturn gf_isom_set_ctts_v1(file, track, 0);\n\t} else {\n\t\tif (ctts->version==0) return GF_OK;\n\t\treturn gf_isom_set_ctts_v0(file, trak);\n\t}\n}\n\n#if 0 //unused\nGF_Err gf_isom_set_sync_table(GF_ISOFile *file, u32 track)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\n\te = CanAccessMovie(file, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(file, track);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tif (!trak->Media->information->sampleTable->SyncSample) {\n\t\ttrak->Media->information->sampleTable->SyncSample = (GF_SyncSampleBox *) gf_isom_box_new_parent(&trak->Media->information->sampleTable->child_boxes, GF_ISOM_BOX_TYPE_STSS);\n\n\t\tif (!trak->Media->information->sampleTable->SyncSample)\n\t\t\treturn GF_OUT_OF_MEM;\n\t}\n\treturn GF_OK;\n}\n#endif\n\nGF_Err gf_isom_set_sample_flags(GF_ISOFile *file, u32 track, u32 sampleNumber, u32 isLeading, u32 dependsOn, u32 dependedOn, u32 redundant)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\n\te = CanAccessMovie(file, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(file, track);\n\tif (!trak) return GF_BAD_PARAM;\n\treturn stbl_SetDependencyType(trak->Media->information->sampleTable, sampleNumber, isLeading, dependsOn, dependedOn, redundant);\n}\n\n#if 0 //unused\nGF_Err gf_isom_sample_set_dep_info(GF_ISOFile *file, u32 track, u32 sampleNumber, u32 isLeading, u32 dependsOn, u32 dependedOn, u32 redundant)\n{\n\tGF_TrackBox *trak;\n\n\ttrak = gf_isom_get_track_from_file(file, track);\n\tif (!trak) return GF_BAD_PARAM;\n\n\treturn stbl_AddDependencyType(trak->Media->information->sampleTable, sampleNumber, isLeading, dependsOn, dependedOn, redundant);\n}\n#endif\n\nGF_EXPORT\nGF_Err gf_isom_copy_sample_info(GF_ISOFile *dst, u32 dst_track, GF_ISOFile *src, u32 src_track, u32 sampleNumber)\n{\n\tu32 i, count, idx, dst_sample_num, subs_flags;\n\tGF_SubSampleInfoEntry *sub_sample;\n\tGF_Err e;\n\tGF_TrackBox *src_trak, *dst_trak;\n\n\tsrc_trak = gf_isom_get_track_from_file(src, src_track);\n\tif (!src_trak) return GF_BAD_PARAM;\n\n\tdst_trak = gf_isom_get_track_from_file(dst, dst_track);\n\tif (!dst_trak) return GF_BAD_PARAM;\n\n\tdst_sample_num = dst_trak->Media->information->sampleTable->SampleSize->sampleCount;\n\n\t/*modify depends flags*/\n\tif (src_trak->Media->information->sampleTable->SampleDep) {\n\t\tu32 isLeading, dependsOn, dependedOn, redundant;\n\n\t\tisLeading = dependsOn = dependedOn = redundant = 0;\n\n\t\te = stbl_GetSampleDepType(src_trak->Media->information->sampleTable->SampleDep, sampleNumber, &isLeading, &dependsOn, &dependedOn, &redundant);\n\t\tif (e) return e;\n\n\t\te = stbl_AppendDependencyType(dst_trak->Media->information->sampleTable, isLeading, dependsOn, dependedOn, redundant);\n\t\tif (e) return e;\n\t}\n\n\t/*copy subsample info if any*/\n\tidx=1;\n\twhile (gf_isom_get_subsample_types(src, src_track, idx, &subs_flags)) {\n\t\tGF_SubSampleInformationBox *dst_subs=NULL;\n\t\tidx++;\n\n\t\tif ( ! gf_isom_sample_get_subsample_entry(src, src_track, sampleNumber, subs_flags, &sub_sample))\n\t\t\tcontinue;\n\n\t\t/*create subsample if needed*/\n\t\tif (!dst_trak->Media->information->sampleTable->sub_samples) {\n\t\t\tdst_trak->Media->information->sampleTable->sub_samples = gf_list_new();\n\t\t}\n\t\tcount = gf_list_count(dst_trak->Media->information->sampleTable->sub_samples);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tdst_subs = gf_list_get(dst_trak->Media->information->sampleTable->sub_samples, i);\n\t\t\tif (dst_subs->flags==subs_flags) break;\n\t\t\tdst_subs=NULL;\n\t\t}\n\t\tif (!dst_subs) {\n\t\t\tdst_subs = (GF_SubSampleInformationBox *) gf_isom_box_new_parent(&dst_trak->Media->information->sampleTable->child_boxes, GF_ISOM_BOX_TYPE_SUBS);\n\t\t\tif (!dst_subs) return GF_OUT_OF_MEM;\n\t\t\tdst_subs->version=0;\n\t\t\tdst_subs->flags = subs_flags;\n\t\t\tgf_list_add(dst_trak->Media->information->sampleTable->sub_samples, dst_subs);\n\t\t}\n\n\t\tcount = gf_list_count(sub_sample->SubSamples);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tGF_SubSampleEntry *entry = (GF_SubSampleEntry*)gf_list_get(sub_sample->SubSamples, i);\n\t\t\te = gf_isom_add_subsample_info(dst_subs, dst_sample_num, entry->subsample_size, entry->subsample_priority, entry->reserved, entry->discardable);\n\t\t\tif (e) return e;\n\t\t}\n\t}\n\n\t/*copy sampleToGroup info if any*/\n\tcount = 0;\n\tif (src_trak->Media->information->sampleTable->sampleGroups)\n\t\tcount = gf_list_count(src_trak->Media->information->sampleTable->sampleGroups);\n\n\tfor (i=0; i<count; i++) {\n\t\tGF_SampleGroupBox *sg;\n\t\tu32 j, k, default_index;\n\t\tu32 first_sample_in_entry, last_sample_in_entry, group_desc_index_src, group_desc_index_dst;\n\t\tfirst_sample_in_entry = 1;\n\n\t\tsg = (GF_SampleGroupBox*)gf_list_get(src_trak->Media->information->sampleTable->sampleGroups, i);\n\t\tfor (j=0; j<sg->entry_count; j++) {\n\t\t\tlast_sample_in_entry = first_sample_in_entry + sg->sample_entries[j].sample_count - 1;\n\t\t\tif ((sampleNumber<first_sample_in_entry) || (sampleNumber>last_sample_in_entry)) {\n\t\t\t\tfirst_sample_in_entry = last_sample_in_entry+1;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!dst_trak->Media->information->sampleTable->sampleGroups)\n\t\t\t\tdst_trak->Media->information->sampleTable->sampleGroups = gf_list_new();\n\n\t\t\tgroup_desc_index_src = group_desc_index_dst = sg->sample_entries[j].group_description_index;\n\n\t\t\tif (group_desc_index_src) {\n\t\t\t\tGF_SampleGroupDescriptionBox *sgd_src, *sgd_dst;\n\t\t\t\tGF_DefaultSampleGroupDescriptionEntry *sgde_src, *sgde_dst;\n\n\t\t\t\tgroup_desc_index_dst = 0;\n\t\t\t\t//check that the sample group description exists !!\n\t\t\t\tsgde_src = gf_isom_get_sample_group_info_entry(src, src_trak, sg->grouping_type, sg->sample_entries[j].group_description_index, &default_index, &sgd_src);\n\n\t\t\t\tif (!sgde_src) break;\n\n\t\t\t\tif (!dst_trak->Media->information->sampleTable->sampleGroupsDescription)\n\t\t\t\t\tdst_trak->Media->information->sampleTable->sampleGroupsDescription = gf_list_new();\n\n\t\t\t\tsgd_dst = NULL;\n\t\t\t\tfor (k=0; k< gf_list_count(dst_trak->Media->information->sampleTable->sampleGroupsDescription); k++) {\n\t\t\t\t\tsgd_dst = gf_list_get(dst_trak->Media->information->sampleTable->sampleGroupsDescription, k);\n\t\t\t\t\tif (sgd_dst->grouping_type==sgd_src->grouping_type) break;\n\t\t\t\t\tsgd_dst = NULL;\n\t\t\t\t}\n\t\t\t\tif (!sgd_dst) {\n\t\t\t\t\tgf_isom_clone_box( (GF_Box *) sgd_src, (GF_Box **) &sgd_dst);\n\t\t\t\t\tif (!sgd_dst) return GF_OUT_OF_MEM;\n\t\t\t\t\tgf_list_add(dst_trak->Media->information->sampleTable->sampleGroupsDescription, sgd_dst);\n\t\t\t\t}\n\n\t\t\t\t//find the same entry\n\t\t\t\tfor (k=0; k<gf_list_count(sgd_dst->group_descriptions); k++) {\n\t\t\t\t\tsgde_dst = gf_list_get(sgd_dst->group_descriptions, i);\n\t\t\t\t\tif (gf_isom_is_identical_sgpd(sgde_src, sgde_dst, sgd_src->grouping_type)) {\n\t\t\t\t\t\tgroup_desc_index_dst = k+1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!group_desc_index_dst) {\n\t\t\t\t\tGF_SampleGroupDescriptionBox *cloned=NULL;\n\t\t\t\t\tgf_isom_clone_box( (GF_Box *) sgd_src, (GF_Box **)  &cloned);\n\t\t\t\t\tif (!cloned) return GF_OUT_OF_MEM;\n\t\t\t\t\tsgde_dst = gf_list_get(cloned->group_descriptions, group_desc_index_dst);\n\t\t\t\t\tgf_list_rem(cloned->group_descriptions, group_desc_index_dst);\n\t\t\t\t\tgf_isom_box_del( (GF_Box *) cloned);\n\t\t\t\t\tgf_list_add(sgd_dst->group_descriptions, sgde_dst);\n\t\t\t\t\tgroup_desc_index_dst = gf_list_count(sgd_dst->group_descriptions);\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t\t/*found our sample, add it to trak->sampleGroups*/\n\t\t\te = gf_isom_add_sample_group_entry(dst_trak->Media->information->sampleTable->sampleGroups, dst_sample_num, sg->grouping_type, sg->grouping_type_parameter, group_desc_index_dst, dst_trak->Media->information->sampleTable->child_boxes, NULL);\n\t\t\tif (e) return e;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_text_set_display_flags(GF_ISOFile *file, u32 track, u32 desc_index, u32 flags, GF_TextFlagsMode op_type)\n{\n\tu32 i;\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\n\te = CanAccessMovie(file, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(file, track);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tfor (i=0; i < gf_list_count(trak->Media->information->sampleTable->SampleDescription->child_boxes); i++) {\n\t\tGF_Tx3gSampleEntryBox *txt;\n\t\tif (desc_index && (i+1 != desc_index)) continue;\n\n\t\ttxt = (GF_Tx3gSampleEntryBox*)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, i);\n\t\tif (txt->type != GF_ISOM_BOX_TYPE_TX3G) continue;\n\n\t\tswitch (op_type) {\n\t\tcase GF_ISOM_TEXT_FLAGS_TOGGLE:\n\t\t\ttxt->displayFlags |= flags;\n\t\t\tbreak;\n\t\tcase GF_ISOM_TEXT_FLAGS_UNTOGGLE:\n\t\t\ttxt->displayFlags &= ~flags;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\ttxt->displayFlags = flags;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn GF_OK;\n\n}\n\n\nGF_EXPORT\nGF_Err gf_isom_update_duration(GF_ISOFile *movie)\n{\n\tu32 i;\n\tu64 maxDur;\n\tGF_TrackBox *trak;\n\n\tif (!movie || !movie->moov) return GF_BAD_PARAM;\n\n\t//if file was open in Write or Edit mode, recompute the duration\n\t//the duration of a movie is the MaxDuration of all the tracks...\n\n\tmaxDur = 0;\n\ti=0;\n\twhile ((trak = (GF_TrackBox *)gf_list_enum(movie->moov->trackList, &i))) {\n\t\tif( (movie->LastError = SetTrackDuration(trak))\t) return movie->LastError;\n\t\tif (trak->Header && (trak->Header->duration > maxDur))\n\t\t\tmaxDur = trak->Header->duration;\n\t}\n\tmovie->moov->mvhd->duration = maxDur;\n\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_update_edit_list_duration(GF_ISOFile *file, u32 track)\n{\n\tu32 i;\n\tu64 trackDuration;\n\tGF_EdtsEntry *ent;\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\n\te = CanAccessMovie(file, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(file, track);\n\tif (!trak) return GF_BAD_PARAM;\n\n\n\t//the total duration is the media duration: adjust it in case...\n\te = Media_SetDuration(trak);\n\tif (e) return e;\n\n\t//assert the timeScales are non-NULL\n\tif (!trak->moov->mvhd->timeScale || !trak->Media->mediaHeader->timeScale) return GF_ISOM_INVALID_FILE;\n\ttrackDuration = (trak->Media->mediaHeader->duration * trak->moov->mvhd->timeScale) / trak->Media->mediaHeader->timeScale;\n\n\t//if we have an edit list, the duration is the sum of all the editList\n\t//entries' duration (always expressed in MovieTimeScale)\n\tif (trak->editBox && trak->editBox->editList) {\n\t\tu64 editListDuration = 0;\n\t\tGF_EditListBox *elst = trak->editBox->editList;\n\t\ti=0;\n\t\twhile ((ent = (GF_EdtsEntry*)gf_list_enum(elst->entryList, &i))) {\n\t\t\tif (ent->segmentDuration > trackDuration)\n\t\t\t\tent->segmentDuration = trackDuration;\n\t\t\tif (!ent->segmentDuration) {\n\t\t\t\tu64 diff;\n\t\t\t\tent->segmentDuration = trackDuration;\n\t\t\t\tif (ent->mediaTime>0) {\n\t\t\t\t\tdiff = ent->mediaTime;\n\t\t\t\t\tdiff *= trak->moov->mvhd->timeScale;\n\t\t\t\t\tdiff /= trak->Media->mediaHeader->timeScale;\n\t\t\t\t\tif (diff < ent->segmentDuration)\n\t\t\t\t\t\tent->segmentDuration -= diff;\n\t\t\t\t\t/*\n\t\t\t\t\telse\n\t\t\t\t\t\tdiff = 0;\n\t\t\t\t\t*/\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ((ent->mediaTime>=0) && ((u64) ent->mediaTime>=trak->Media->mediaHeader->duration)) {\n\t\t\t\tent->mediaTime = trak->Media->mediaHeader->duration;\n\t\t\t}\n\t\t\teditListDuration += ent->segmentDuration;\n\t\t}\n\t\ttrackDuration = editListDuration;\n\t}\n\tif (!trackDuration) {\n\t\ttrackDuration = (trak->Media->mediaHeader->duration * trak->moov->mvhd->timeScale) / trak->Media->mediaHeader->timeScale;\n\t}\n\ttrak->Header->duration = trackDuration;\n\n\treturn GF_OK;\n\n}\n\n\nGF_EXPORT\nGF_Err gf_isom_clone_pssh(GF_ISOFile *output, GF_ISOFile *input, Bool in_moof) {\n\tGF_Box *a;\n\tu32 i;\n\ti = 0;\n\n\twhile ((a = (GF_Box *)gf_list_enum(input->moov->child_boxes, &i))) {\n\t\tif (a->type == GF_ISOM_BOX_TYPE_PSSH) {\n\t\t\tGF_List **child_boxes = &output->moov->child_boxes;\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t\t\tif (in_moof)\n\t\t\t\tchild_boxes = &output->moof->child_boxes;\n#endif\n\n\t\t\tGF_ProtectionSystemHeaderBox *pssh = (GF_ProtectionSystemHeaderBox *)gf_isom_box_new_parent(child_boxes, GF_ISOM_BOX_TYPE_PSSH);\n\t\t\tif (!pssh) return GF_OUT_OF_MEM;\n\t\t\tmemmove(pssh->SystemID, ((GF_ProtectionSystemHeaderBox *)a)->SystemID, 16);\n\t\t\tif (((GF_ProtectionSystemHeaderBox *)a)->KIDs && ((GF_ProtectionSystemHeaderBox *)a)->KID_count > 0) {\n\t\t\t\tpssh->KID_count = ((GF_ProtectionSystemHeaderBox *)a)->KID_count;\n\t\t\t\tpssh->KIDs = (bin128 *)gf_malloc(pssh->KID_count*sizeof(bin128));\n\t\t\t\tif (!pssh->KIDs) return GF_OUT_OF_MEM;\n\t\t\t\tmemmove(pssh->KIDs, ((GF_ProtectionSystemHeaderBox *)a)->KIDs, pssh->KID_count*sizeof(bin128));\n\t\t\t}\n\t\t\tpssh->private_data_size = ((GF_ProtectionSystemHeaderBox *)a)->private_data_size;\n\t\t\tpssh->private_data = (u8 *)gf_malloc(pssh->private_data_size*sizeof(char));\n\t\t\tif (!pssh->private_data) return GF_OUT_OF_MEM;\n\t\t\tmemmove(pssh->private_data, ((GF_ProtectionSystemHeaderBox *)a)->private_data, pssh->private_data_size);\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_track_group(GF_ISOFile *file, u32 track_number, u32 track_group_id, u32 group_type, Bool do_add)\n{\n\tu32 i, j;\n\tGF_TrackGroupTypeBox *trgt;\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\n\te = CanAccessMovie(file, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(file, track_number);\n\tif (!trak) return GF_BAD_PARAM;\n\tif (!trak->groups) trak->groups = (GF_TrackGroupBox*) gf_isom_box_new_parent(&trak->child_boxes, GF_ISOM_BOX_TYPE_TRGR);\n\tif (!trak->groups) return GF_OUT_OF_MEM;\n\n\tfor (j=0; j<gf_list_count(file->moov->trackList); j++) {\n\t\tGF_TrackBox *a_trak = gf_list_get(file->moov->trackList, j);\n\t\tif (!a_trak->groups) continue;\n\n\t\tfor (i=0; i<gf_list_count(a_trak->groups->groups); i++) {\n\t\t\ttrgt = gf_list_get(a_trak->groups->groups, i);\n\n\t\t\tif (trgt->track_group_id==track_group_id) {\n\t\t\t\tif (trgt->group_type != group_type) {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"A track with same group ID is already defined for different group type %s\\n\", gf_4cc_to_str(trgt->group_type) ));\n\t\t\t\t\treturn GF_BAD_PARAM;\n\t\t\t\t}\n\t\t\t\tif (a_trak==trak) {\n\t\t\t\t\tif (!do_add) {\n\t\t\t\t\t\tgf_list_rem(trak->groups->groups, i);\n\t\t\t\t\t\tgf_isom_box_del_parent(&trak->groups->child_boxes, (GF_Box *)trgt);\n\t\t\t\t\t}\n\t\t\t\t\treturn GF_OK;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t//not found, add new group\n\ttrgt = (GF_TrackGroupTypeBox*) gf_isom_box_new_parent(&trak->groups->child_boxes, GF_ISOM_BOX_TYPE_TRGT);\n\tif (!trgt) return GF_OUT_OF_MEM;\n\ttrgt->track_group_id = track_group_id;\n\ttrgt->group_type = group_type;\n\treturn gf_list_add(trak->groups->groups, trgt);\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_nalu_length_field(GF_ISOFile *file, u32 track, u32 StreamDescriptionIndex, u32 nalu_size_length)\n{\n\tGF_Err e;\n\tGF_TrackBox *trak;\n\tGF_SampleEntryBox *entry;\n\tGF_MPEGVisualSampleEntryBox *ve;\n\tGF_SampleDescriptionBox *stsd;\n\n\te = CanAccessMovie(file, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(file, track);\n\tif (!trak) return GF_BAD_PARAM;\n\n\tstsd = trak->Media->information->sampleTable->SampleDescription;\n\tif (!stsd || !StreamDescriptionIndex || StreamDescriptionIndex > gf_list_count(stsd->child_boxes)) {\n\t\treturn GF_BAD_PARAM;\n\t}\n\n\tentry = (GF_SampleEntryBox *)gf_list_get(stsd->child_boxes, StreamDescriptionIndex - 1);\n\t//no support for generic sample entries (eg, no MPEG4 descriptor)\n\tif (!entry || ! gf_isom_is_nalu_based_entry(trak->Media, entry)) {\n\t\treturn GF_BAD_PARAM;\n\t}\n\n\tve = (GF_MPEGVisualSampleEntryBox*)entry;\n\tif (ve->avc_config) ve->avc_config->config->nal_unit_size = nalu_size_length;\n\tif (ve->svc_config) ve->svc_config->config->nal_unit_size = nalu_size_length;\n\tif (ve->hevc_config) ve->hevc_config->config->nal_unit_size = nalu_size_length;\n\tif (ve->lhvc_config) ve->lhvc_config->config->nal_unit_size = nalu_size_length;\n\treturn GF_OK;\n}\n\nGF_Err gf_isom_set_sample_group_in_traf(GF_ISOFile *file)\n{\n\tGF_Err e;\n\te = CanAccessMovie(file, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\tfile->sample_groups_in_traf = GF_TRUE;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nvoid gf_isom_set_progress_callback(GF_ISOFile *file, void (*progress_cbk)(void *udta, u64 nb_done, u64 nb_total), void *progress_cbk_udta)\n{\n\tif (file) {\n\t\tfile->progress_cbk = progress_cbk;\n\t\tfile->progress_cbk_udta = progress_cbk_udta;\n\n\t}\n}\n\nGF_Err gf_isom_update_video_sample_entry_fields(GF_ISOFile *file, u32 track, u32 stsd_idx, u16 revision, u32 vendor, u32 temporalQ, u32 spatialQ, u32 horiz_res, u32 vert_res, u16 frames_per_sample, const char *compressor_name, s16 color_table_index)\n{\n\n\tGF_TrackBox *trak;\n\tGF_MPEGVisualSampleEntryBox *vid_ent;\n\n\t/*get orig sample desc and clone it*/\n\ttrak = gf_isom_get_track_from_file(file, track);\n\tif (!trak || !stsd_idx) return GF_BAD_PARAM;\n\n\tif (!trak->Media || !trak->Media->handler || !trak->Media->information || !trak->Media->information->sampleTable || !trak->Media->information->sampleTable->SampleDescription)\n\t\treturn GF_ISOM_INVALID_FILE;\n\n\tswitch (trak->Media->handler->handlerType) {\n\tcase GF_ISOM_MEDIA_VISUAL:\n    case GF_ISOM_MEDIA_AUXV:\n    case GF_ISOM_MEDIA_PICT:\n    \tbreak;\n\tdefault:\n\t\treturn GF_BAD_PARAM;\n\t}\n\tvid_ent = gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, stsd_idx-1);\n\tif (!vid_ent)\n\t\treturn GF_BAD_PARAM;\n\n\tvid_ent->revision = revision;\n\tvid_ent->vendor = vendor;\n\tvid_ent->temporal_quality = temporalQ;\n\tvid_ent->spatial_quality = spatialQ;\n\tvid_ent->horiz_res = horiz_res;\n\tvid_ent->vert_res = vert_res;\n\tvid_ent->frames_per_sample = frames_per_sample;\n\tif (compressor_name)\n\t\tstrncpy(vid_ent->compressor_name, compressor_name, 32);\n\n\tvid_ent->color_table_index = color_table_index;\n\treturn GF_OK;\n}\n\n\nGF_Err gf_isom_update_sample_description_from_template(GF_ISOFile *file, u32 track, u32 sampleDescriptionIndex, u8 *data, u32 size)\n{\n\tGF_BitStream *bs;\n\tGF_TrackBox *trak;\n\tGF_Box *ent, *tpl_ent;\n\tGF_Err e;\n\t/*get orig sample desc and clone it*/\n\ttrak = gf_isom_get_track_from_file(file, track);\n\tif (!trak || !sampleDescriptionIndex) return GF_BAD_PARAM;\n\n\tif (!trak->Media || !trak->Media->handler || !trak->Media->information || !trak->Media->information->sampleTable || !trak->Media->information->sampleTable->SampleDescription)\n\t\treturn GF_ISOM_INVALID_FILE;\n\n\tent = gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, sampleDescriptionIndex-1);\n\tif (!ent) return GF_BAD_PARAM;\n\n\tbs = gf_bs_new(data, size, GF_BITSTREAM_READ);\n//\te = gf_isom_box_parse(&tpl_ent, bs);\n\te = gf_isom_box_parse_ex (&tpl_ent, bs, GF_ISOM_BOX_TYPE_STSD, GF_FALSE);\n\tgf_bs_del(bs);\n\tif (e) return e;\n\n\twhile (gf_list_count(tpl_ent->child_boxes)) {\n\t\tu32 j=0;\n\t\tBool found = GF_FALSE;\n\t\tGF_Box *abox = gf_list_pop_front(tpl_ent->child_boxes);\n\n\t\tswitch (abox->type) {\n\t\tcase GF_ISOM_BOX_TYPE_SINF:\n\t\tcase GF_ISOM_BOX_TYPE_RINF:\n\t\tcase GF_ISOM_BOX_TYPE_BTRT:\n\t\t\tfound = GF_TRUE;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (found) {\n\t\t\tgf_isom_box_del(abox);\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tif (!ent->child_boxes) ent->child_boxes = gf_list_new();\n\t\tfor (j=0; j<gf_list_count(ent->child_boxes); j++) {\n\t\t\tGF_Box *b = gf_list_get(ent->child_boxes, j);\n\t\t\tif (b->type == abox->type) {\n\t\t\t\tfound = GF_TRUE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!found) {\n\t\t\tgf_list_add(ent->child_boxes, abox);\n\t\t} else {\n\t\t\tgf_isom_box_del(abox);\n\t\t}\n\t}\n\tgf_isom_box_del(tpl_ent);\n\n\t//patch for old export\n\tGF_Box *abox = gf_isom_box_find_child(ent->child_boxes, GF_ISOM_BOX_TYPE_SINF);\n\tif (abox) {\n\t\tgf_list_del_item(ent->child_boxes, abox);\n\t\tgf_list_add(ent->child_boxes, abox);\n\t}\n\treturn GF_OK;\n}\n\n#include <gpac/xml.h>\nGF_EXPORT\nGF_Err gf_isom_apply_box_patch(GF_ISOFile *file, GF_ISOTrackID globalTrackID, const char *box_patch_filename, Bool for_fragments)\n{\n\tGF_Err e;\n\tGF_DOMParser *dom;\n\tu32 i;\n\tGF_XMLNode *root;\n\tu8 *box_data=NULL;\n\tu32 box_data_size;\n\tif (!file || !box_patch_filename) return GF_BAD_PARAM;\n\tdom = gf_xml_dom_new();\n\tif (strstr(box_patch_filename, \"<?xml\")) {\n\t\te = gf_xml_dom_parse_string(dom, (char *) box_patch_filename);\n\t} else {\n\t\te = gf_xml_dom_parse(dom, box_patch_filename, NULL, NULL);\n\t}\n\tif (e) goto err_exit;\n\n\troot = gf_xml_dom_get_root(dom);\n\tif (!root || strcmp(root->name, \"GPACBOXES\")) {\n\t\te = GF_NON_COMPLIANT_BITSTREAM;\n\t\tgoto err_exit;\n\t}\n\n\t//compute size of each child boxes to freeze the order\n\tif (for_fragments) {\n\t\tu32 count = file->moof ? gf_list_count(file->moof->child_boxes) : 0;\n\t\tfor (i=0; i<count; i++) {\n\t\t\tGF_Box *box = gf_list_get(file->moof->child_boxes, i);\n\t\t\tif (!(box->internal_flags & GF_ISOM_ORDER_FREEZE)) {\n\t\t\t\tgf_isom_box_size(box);\n\t\t\t\tgf_isom_box_freeze_order(box);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfor (i=0; i<gf_list_count(file->TopBoxes); i++) {\n\t\t\tGF_Box *box = gf_list_get(file->TopBoxes, i);\n\t\t\tif (!(box->internal_flags & GF_ISOM_ORDER_FREEZE)) {\n\t\t\t\tgf_isom_box_size(box);\n\t\t\t\tgf_isom_box_freeze_order(box);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (i=0; i<gf_list_count(root->content); i++) {\n\t\tu32 j;\n\t\tu32 path_len;\n\t\tBool essential_prop=GF_FALSE;\n\t\tu32 trackID=globalTrackID;\n\t\tu32 item_id=trackID;\n\t\tBool is_frag_box;\n\t\tchar *box_path=NULL;\n\t\tGF_Box *parent_box = NULL;\n\t\tGF_XMLNode *box_edit = gf_list_get(root->content, i);\n\t\tif (!box_edit->name || strcmp(box_edit->name, \"Box\")) continue;\n\n\t\tfor (j=0; j<gf_list_count(box_edit->attributes);j++) {\n\t\t\tGF_XMLAttribute *att = gf_list_get(box_edit->attributes, j);\n\t\t\tif (!strcmp(att->name, \"path\")) box_path = att->value;\n\t\t\telse if (!strcmp(att->name, \"essential\")) {\n\t\t\t\tif (!strcmp(att->value, \"yes\") || !strcmp(att->value, \"true\") || !strcmp(att->value, \"1\")) {\n\t\t\t\t\tessential_prop=GF_TRUE;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (!strcmp(att->name, \"itemID\"))\n\t\t\t\titem_id = atoi(att->value);\n\t\t\telse if (!globalTrackID && !strcmp(att->name, \"trackID\"))\n\t\t\t\ttrackID = atoi(att->value);\n\t\t}\n\n\t\tif (!box_path) continue;\n\t\tpath_len = (u32) strlen(box_path);\n\n\t\tis_frag_box = !strncmp(box_path, \"traf\", 4) ? GF_TRUE : GF_FALSE;\n\n\t\tif (for_fragments && !is_frag_box) continue;\n\t\telse if (!for_fragments && is_frag_box) continue;\n\n\t\tgf_xml_parse_bit_sequence(box_edit, box_patch_filename, &box_data, &box_data_size);\n\t\tif (box_data_size && (box_data_size<4) ) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[ISOBMFF] Wrong BS specification for box, shall either be empty or at least 4 bytes for box type\\n\"));\n\t\t\te = GF_NON_COMPLIANT_BITSTREAM;\n\t\t\tgoto err_exit;\n\t\t}\n\n\t\twhile (box_path && (path_len>=4)) {\n\t\t\tu32 parent_list_box_type;\n\t\t\tGF_List **parent_list;\n\t\t\tu32 box_type = GF_4CC(box_path[0],box_path[1],box_path[2],box_path[3]);\n\t\t\tGF_Box *box=NULL;\n\t\t\tGF_BitStream *bs;\n\t\t\ts32 insert_pos = -1;\n\t\t\tbox_path+=4;\n\t\t\tpath_len-=4;\n\n\t\t\tif (!parent_box) {\n\t\t\t\tbox=gf_isom_box_find_child(file->TopBoxes, box_type);\n\t\t\t\tif (!box) {\n\t\t\t\t\tif (box_type==GF_ISOM_BOX_TYPE_TRAK) {\n\t\t\t\t\t\tif (trackID) {\n\t\t\t\t\t\t\tbox = (GF_Box *) gf_isom_get_track_from_file(file, gf_isom_get_track_by_id(file, trackID) );\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!box && gf_list_count(file->moov->trackList)==1) {\n\t\t\t\t\t\t\tbox = gf_list_get(file->moov->trackList, 0);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if (box_type==GF_ISOM_BOX_TYPE_TRAF) {\n\t\t\t\t\t\tif (trackID) {\n\t\t\t\t\t\t\tbox = (GF_Box *) gf_isom_get_traf(file, trackID);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!box && file->moof && gf_list_count(file->moof->TrackList)==1) {\n\t\t\t\t\t\t\tbox = gf_list_get(file->moof->TrackList, 0);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!box) {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[ISOBMFF] Cannot locate box type %s at root or as track\\n\", gf_4cc_to_str(box_type) ));\n\t\t\t\t\te = GF_BAD_PARAM;\n\t\t\t\t\tgoto err_exit;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tbox = gf_isom_box_find_child(parent_box->child_boxes, box_type);\n\t\t\t\tif (!box) {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[ISOBMFF] Cannot locate box type %s at child of %s\\n\", gf_4cc_to_str(box_type), gf_4cc_to_str(parent_box->type)));\n\t\t\t\t\te = GF_BAD_PARAM;\n\t\t\t\t\tgoto err_exit;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// '.' is child access\n\t\t\tif (path_len && (box_path[0]=='.')) {\n\t\t\t\tbox_path += 1;\n\t\t\t\tpath_len-=1;\n\t\t\t\tparent_box = box;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (parent_box && !parent_box->child_boxes) parent_box->child_boxes = gf_list_new();\n\t\t\tparent_list = parent_box ? &parent_box->child_boxes : &file->TopBoxes;\n\t\t\tparent_list_box_type = parent_box ? parent_box->type : 0;\n\n\t\t\t// '+' is append after, '-' is insert before\n\t\t\tif (path_len && ((box_path[0]=='-') || (box_path[0]=='+')) ) {\n\t\t\t\ts32 idx = gf_list_find(*parent_list, box);\n\t\t\t\tassert(idx>=0);\n\t\t\t\tif (box_path[0]=='+') insert_pos = idx+1;\n\t\t\t\telse insert_pos = idx;\n\t\t\t}\n\t\t\telse if (path_len) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[ISOBMFF] Invalid path %s, expecting either '-', '+' or '.' as separators\\n\", box_path));\n\t\t\t\te = GF_NON_COMPLIANT_BITSTREAM;\n\t\t\t\tgoto err_exit;\n\t\t\t}\n\n\t\t\tif (!box_data) {\n\t\t\t\tif (insert_pos>=0) {\n\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[ISOBMFF] Invalid path %s for box removal, ignoring position\\n\", box_path));\n\t\t\t\t}\n\t\t\t\tswitch (box->type) {\n\t\t\t\tcase GF_ISOM_BOX_TYPE_MOOV:\n\t\t\t\t\tfile->moov = NULL;\n\t\t\t\t\tbreak;\n\t\t\t\tcase GF_ISOM_BOX_TYPE_MDAT:\n\t\t\t\t\tfile->mdat = NULL;\n\t\t\t\t\tbreak;\n\t\t\t\tcase GF_ISOM_BOX_TYPE_PDIN:\n\t\t\t\t\tfile->pdin = NULL;\n\t\t\t\t\tbreak;\n\t\t\t\tcase GF_ISOM_BOX_TYPE_FTYP:\n\t\t\t\t\tfile->brand = NULL;\n\t\t\t\t\tbreak;\n\t\t\t\tcase GF_ISOM_BOX_TYPE_META:\n\t\t\t\t\tif ((GF_Box *) file->meta == box) file->meta = NULL;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (parent_box) {\n\t\t\t\t\tgf_isom_box_remove_from_parent(parent_box, box);\n\t\t\t\t}\n\t\t\t\tgf_isom_box_del_parent(parent_list, box);\n\t\t\t} else {\n\t\t\t\tu32 size;\n\n\t\t\t\tbs = gf_bs_new(box_data, box_data_size, GF_BITSTREAM_READ);\n\t\t\t\tsize = gf_bs_read_u32(bs);\n\t\t\t\tif (size != box_data_size) {\n\t\t\t\t\tGF_UnknownBox *new_box = (GF_UnknownBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_UNKNOWN);\n\t\t\t\t\tnew_box->original_4cc = size;\n\t\t\t\t\tnew_box->dataSize = (u32) gf_bs_available(bs);\n\t\t\t\t\tnew_box->data = gf_malloc(sizeof(u8)*new_box->dataSize);\n\t\t\t\t\tgf_bs_read_data(bs, new_box->data, new_box->dataSize);\n\t\t\t\t\tif (insert_pos<0) {\n\t\t\t\t\t\tgf_list_add(box->child_boxes, new_box);\n\t\t\t\t\t\tinsert_pos = gf_list_find(box->child_boxes, new_box);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tgf_list_insert(*parent_list, new_box, insert_pos);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (parent_box && (parent_box->type==GF_ISOM_BOX_TYPE_IPRP)) {\n\t\t\t\t\t\tGF_ItemPropertyAssociationBox *ipma = (GF_ItemPropertyAssociationBox *) gf_isom_box_find_child(parent_box->child_boxes, GF_ISOM_BOX_TYPE_IPMA);\n\t\t\t\t\t\tif (!item_id) {\n\t\t\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[ISOBMFF] Inserting box in ipco without itemID, no association added\\n\"));\n\t\t\t\t\t\t} else if (ipma) {\n\t\t\t\t\t\t\tu32 nb_asso, k;\n\t\t\t\t\t\t\tGF_ItemPropertyAssociationEntry *entry = NULL;\n\t\t\t\t\t\t\tnb_asso = gf_list_count(ipma->entries);\n\t\t\t\t\t\t\tfor (k=0; k<nb_asso;k++) {\n\t\t\t\t\t\t\t\tentry = gf_list_get(ipma->entries, k);\n\t\t\t\t\t\t\t\tif (entry->item_id==item_id) break;\n\t\t\t\t\t\t\t\tentry = NULL;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (!entry) {\n\t\t\t\t\t\t\t\tGF_SAFEALLOC(entry, GF_ItemPropertyAssociationEntry);\n\t\t\t\t\t\t\t\tif (!entry) return GF_OUT_OF_MEM;\n\t\t\t\t\t\t\t\tgf_list_add(ipma->entries, entry);\n\t\t\t\t\t\t\t\tentry->item_id = item_id;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tentry->associations = gf_realloc(entry->associations, sizeof(GF_ItemPropertyAssociationSlot) * (entry->nb_associations+1));\n\t\t\t\t\t\t\tentry->associations[entry->nb_associations].essential = essential_prop;\n\t\t\t\t\t\t\tentry->associations[entry->nb_associations].index = 1+insert_pos;\n\t\t\t\t\t\t\tentry->nb_associations++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tu32 box_idx = 0;\n\n\t\t\t\t\tgf_bs_seek(bs, 0);\n\t\t\t\t\twhile (gf_bs_available(bs)) {\n\t\t\t\t\t\tGF_Box *new_box;\n\t\t\t\t\t\te = gf_isom_box_parse_ex(&new_box, bs, (insert_pos<0) ? box->type : parent_list_box_type, parent_box ? GF_FALSE : GF_TRUE);\n\t\t\t\t\t\tif (e) {\n\t\t\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[ISOBMFF] failed to parse box\\n\", box_path));\n\t\t\t\t\t\t\tgf_bs_del(bs);\n\t\t\t\t\t\t\tgoto err_exit;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (insert_pos<0) {\n\t\t\t\t\t\t\tgf_list_add(box->child_boxes, new_box);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tgf_list_insert(*parent_list, new_box, insert_pos+box_idx);\n\t\t\t\t\t\t\tbox_idx++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tgf_bs_del(bs);\n\n\t\t\t}\n\t\t\tgf_free(box_data);\n\t\t\tbox_data = NULL;\n\t\t\tbox_path = NULL;\n\t\t}\n\t}\n\nerr_exit:\n\n\tgf_xml_dom_del(dom);\n\tif (box_data) gf_free(box_data);\n\treturn e;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_track_magic(GF_ISOFile *movie, u32 trackNumber, u64 magic)\n{\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\ttrak->magic = magic;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_track_index(GF_ISOFile *movie, u32 trackNumber, u32 index, void (*track_num_changed)(void *udta, u32 old_track_num, u32 new_track_num), void *udta)\n{\n\tu32 i, count;\n\tGF_List *tracks;\n\tu32 prev_index=0, prev_pos=0;\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !index) return GF_BAD_PARAM;\n\ttrak->index = index;\n\ttracks = gf_list_new();\n\tcount = gf_list_count(movie->moov->trackList);\n\t//sort tracks in new list\n\tfor (i=0; i<count; i++) {\n\t\tGF_TrackBox *a_tk = gf_list_get(movie->moov->trackList, i);\n\t\tif (!a_tk->index) {\n\t\t\tgf_list_insert(tracks, a_tk, 0);\n\t\t} else if (a_tk->index < prev_index) {\n\t\t\tgf_list_insert(tracks, a_tk, prev_pos);\n\t\t} else {\n\t\t\tgf_list_add(tracks, a_tk);\n\t\t}\n\t\tprev_pos = gf_list_count(tracks) - 1;\n\t\tprev_index = a_tk->index;\n\t}\n\tif (gf_list_count(tracks) != count) {\n\t\tgf_list_del(tracks);\n\t\treturn GF_OUT_OF_MEM;\n\t}\n\tif (track_num_changed) {\n\t\tfor (i=0; i<count; i++) {\n\t\t\tGF_TrackBox *a_tk = gf_list_get(tracks, i);\n\t\t\ts32 old_pos = gf_list_find(movie->moov->trackList, a_tk);\n\t\t\tassert(old_pos>=0);\n\t\t\tif (old_pos != i)\n\t\t\t\ttrack_num_changed(udta, old_pos+1, i+1);\n\t\t}\n\t}\n\tgf_list_del(movie->moov->trackList);\n\tmovie->moov->trackList = tracks;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_isom_set_ipod_compatible(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\tGF_Err e;\n\tGF_MPEGVisualSampleEntryBox *entry;\n\n\te = CanAccessMovie(the_file, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media) return GF_BAD_PARAM;\n\tentry = (GF_MPEGVisualSampleEntryBox*)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, 0);\n\tif (!entry) return GF_OK;\n\tswitch (entry->type) {\n\tcase GF_ISOM_BOX_TYPE_AVC1:\n\tcase GF_ISOM_BOX_TYPE_AVC2:\n\tcase GF_ISOM_BOX_TYPE_AVC3:\n\tcase GF_ISOM_BOX_TYPE_AVC4:\n\tcase GF_ISOM_BOX_TYPE_SVC1:\n\tcase GF_ISOM_BOX_TYPE_MVC1:\n\tcase GF_ISOM_BOX_TYPE_HVC1:\n\tcase GF_ISOM_BOX_TYPE_HEV1:\n\tcase GF_ISOM_BOX_TYPE_HVT1:\n\t\tbreak;\n\tdefault:\n\t\treturn GF_OK;\n\t}\n\n\tif (!entry->ipod_ext) {\n\t\tentry->ipod_ext = (GF_UnknownUUIDBox *) gf_isom_box_new_parent(&entry->child_boxes, GF_ISOM_BOX_TYPE_UUID);\n\t\tif (!entry->ipod_ext) return GF_OUT_OF_MEM;\n\t}\n\tmemcpy(entry->ipod_ext->uuid, GF_ISOM_IPOD_EXT, sizeof(u8)*16);\n\tentry->ipod_ext->dataSize = 4;\n\tentry->ipod_ext->data = gf_malloc(sizeof(u8)*4);\n\tif (!entry->ipod_ext->data) return GF_OUT_OF_MEM;\n\tmemset(entry->ipod_ext->data, 0, sizeof(u8)*4);\n\treturn GF_OK;\n}\n\nGF_EXPORT\nBool gf_isom_is_inplace_rewrite(GF_ISOFile *movie)\n{\n\tif (!movie) return GF_FALSE;\n\tif (!movie->no_inplace_rewrite) {\n\t\t//things where added to the file, no inplace rewrite\n\t\tif (movie->editFileMap && gf_bs_get_size(movie->editFileMap->bs))\n\t\t\tmovie->no_inplace_rewrite = GF_TRUE;\n\t\t//block redirect (used by mp4mx), no inplace rewrite\n\t\telse if (movie->on_block_out || !strcmp(movie->finalName, \"_gpac_isobmff_redirect\"))\n\t\t\tmovie->no_inplace_rewrite = GF_TRUE;\n\t\t//stdout redirect, no inplace rewrite\n\t\telse if (!strcmp(movie->finalName, \"std\"))\n\t\t\tmovie->no_inplace_rewrite = GF_TRUE;\n\t\t//new file, no inplace rewrite\n\t\telse if (!movie->fileName)\n\t\t\tmovie->no_inplace_rewrite = GF_TRUE;\n\t}\n\tif (movie->no_inplace_rewrite) return GF_FALSE;\n\n\treturn GF_TRUE;\n}\n\nGF_EXPORT\nvoid gf_isom_disable_inplace_rewrite(GF_ISOFile *movie)\n{\n\tif (movie)\n\t\tmovie->no_inplace_rewrite = GF_TRUE;\n}\n\n\nGF_Err gf_isom_set_y3d_info(GF_ISOFile *movie, u32 trackNumber, u32 sampleDescriptionIndex, GF_ISOM_Y3D_Info *info)\n{\n\tGF_Err e;\n\tu32 proj_type;\n\tGF_SampleEntryBox *ent;\n\tGF_TrackBox *trak;\n\n\te = CanAccessMovie(movie, GF_ISOM_OPEN_WRITE);\n\tif (e) return e;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !trak->Media || !info) return GF_BAD_PARAM;\n\n\tent = gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, sampleDescriptionIndex-1);\n\tif (!ent) return GF_BAD_PARAM;\n\n\tif (info->projection_type > GF_PROJ360_EQR) return GF_NOT_SUPPORTED;\n\n\tGF_Stereo3DBox *st3d = (GF_Stereo3DBox *) gf_isom_box_find_child(ent->child_boxes, GF_ISOM_BOX_TYPE_ST3D);\n\tif (st3d) {\n\t\tif (info->stereo_type) {\n\t\t\tst3d->stereo_type = info->stereo_type;\n\t\t} else {\n\t\t\tgf_isom_box_del_parent(&ent->child_boxes, (GF_Box *) st3d);\n\t\t}\n\t} else if (info->stereo_type) {\n\t\tst3d = (GF_Stereo3DBox *) gf_isom_box_new_parent(&ent->child_boxes, GF_ISOM_BOX_TYPE_ST3D);\n\t\tif (!st3d) return GF_OUT_OF_MEM;\n\t\tst3d->stereo_type = info->stereo_type;\n\t}\n\n\n\tGF_Box *sv3d = gf_isom_box_find_child(ent->child_boxes, GF_ISOM_BOX_TYPE_SV3D);\n\tif (sv3d && !info->projection_type) {\n\t\tgf_isom_box_del_parent(&ent->child_boxes, sv3d);\n\t\treturn GF_OK;\n\t}\n\n\tif (!sv3d && !info->projection_type) {\n\t\treturn GF_OK;\n\t}\n\tif (!sv3d) {\n\t\tsv3d = gf_isom_box_new_parent(&ent->child_boxes, GF_ISOM_BOX_TYPE_SV3D);\n\t\tif (!sv3d) return GF_OUT_OF_MEM;\n\t}\n\n\t//svhd mandatory\n\tGF_SphericalVideoInfoBox *svhd = (GF_SphericalVideoInfoBox *) gf_isom_box_find_child(sv3d->child_boxes, GF_ISOM_BOX_TYPE_SVHD);\n\tif (svhd) {\n\t\tif (svhd->string) gf_free(svhd->string);\n\t} else {\n\t\tsvhd = (GF_SphericalVideoInfoBox *) gf_isom_box_new_parent(&sv3d->child_boxes, GF_ISOM_BOX_TYPE_SVHD);\n\t\tif (!svhd) return GF_OUT_OF_MEM;\n\t}\n\tsvhd->string = gf_strdup(info->meta_data ? info->meta_data : \"\");\n\n\t//proj mandatory\n\tGF_Box *proj = gf_isom_box_find_child(sv3d->child_boxes, GF_ISOM_BOX_TYPE_PROJ);\n\tif (!proj) {\n\t\tproj = (GF_Box *) gf_isom_box_new_parent(&sv3d->child_boxes, GF_ISOM_BOX_TYPE_PROJ);\n\t\tif (!proj) return GF_OUT_OF_MEM;\n\t}\n\n\tGF_ProjectionHeaderBox *projh = (GF_ProjectionHeaderBox *) gf_isom_box_find_child(proj->child_boxes, GF_ISOM_BOX_TYPE_PRHD);\n\t//prj header mandatory\n\tif (!projh) {\n\t\tprojh = (GF_ProjectionHeaderBox *) gf_isom_box_new_parent(&proj->child_boxes, GF_ISOM_BOX_TYPE_PRHD);\n\t\tif (!projh) return GF_OUT_OF_MEM;\n\t}\n\tprojh->yaw = info->yaw;\n\tprojh->pitch = info->pitch;\n\tprojh->roll = info->roll;\n\n\tproj_type = (info->projection_type==GF_PROJ360_CUBE_MAP) ? GF_ISOM_BOX_TYPE_CBMP : GF_ISOM_BOX_TYPE_EQUI;\n\n\tGF_ProjectionTypeBox *projt = (GF_ProjectionTypeBox *) gf_isom_box_find_child(proj->child_boxes, proj_type);\n\tif (!projt) {\n\t\tprojt = (GF_ProjectionTypeBox *) gf_isom_box_new_parent(&proj->child_boxes, proj_type);\n\t\tif (!projt) return GF_OUT_OF_MEM;\n\t}\n\tif (info->projection_type==GF_PROJ360_CUBE_MAP) {\n\t\tprojt->layout = info->layout;\n\t\tprojt->padding = info->padding;\n\t} else {\n\t\tprojt->bounds_top = info->top;\n\t\tprojt->bounds_bottom = info->bottom;\n\t\tprojt->bounds_left = info->left;\n\t\tprojt->bounds_right = info->right;\n\t}\n\n\t//remove other ones\n\tGF_Box *b = gf_isom_box_new_parent(&proj->child_boxes, GF_ISOM_BOX_TYPE_MSHP);\n\tif (b) gf_isom_box_del_parent(&proj->child_boxes, b);\n\tif (info->projection_type==GF_PROJ360_CUBE_MAP) {\n\t\tb = gf_isom_box_new_parent(&proj->child_boxes, GF_ISOM_BOX_TYPE_EQUI);\n\t\tif (b) gf_isom_box_del_parent(&proj->child_boxes, b);\n\t} else {\n\t\tb = gf_isom_box_new_parent(&proj->child_boxes, GF_ISOM_BOX_TYPE_EQUI);\n\t\tif (b) gf_isom_box_del_parent(&proj->child_boxes, b);\n\n\t}\n\treturn GF_OK;\n}\n\n\n#endif\t/*!defined(GPAC_DISABLE_ISOM) && !defined(GPAC_DISABLE_ISOM_WRITE)*/\n", "/*\n *\t\t\tGPAC - Multimedia Framework C SDK\n *\n *\t\t\tAuthors: Jean Le Feuvre\n *\t\t\tCopyright (c) Telecom ParisTech 2000-2012\n *\t\t\t\t\tAll rights reserved\n *\n *  This file is part of GPAC / Media Tools sub-project\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n#include <gpac/internal/media_dev.h>\n#include <gpac/base_coding.h>\n#include <gpac/mpeg4_odf.h>\n#include <gpac/constants.h>\n#include <gpac/maths.h>\n#include <gpac/internal/ietf_dev.h>\n\n#ifndef GPAC_DISABLE_ISOM\n\nvoid gf_media_get_sample_average_infos(GF_ISOFile *file, u32 Track, u32 *avgSize, u32 *MaxSize, u32 *TimeDelta, u32 *maxCTSDelta, u32 *const_duration, u32 *bandwidth)\n{\n\tu32 i, count, ts_diff;\n\tu64 prevTS, tdelta;\n\tDouble bw;\n\tGF_ISOSample *samp;\n\n\t*avgSize = *MaxSize = 0;\n\t*TimeDelta = 0;\n\t*maxCTSDelta = 0;\n\tbw = 0;\n\tprevTS = 0;\n\ttdelta = 0;\n\n\tcount = gf_isom_get_sample_count(file, Track);\n\tif (!count) return;\n\t*const_duration = 0;\n\n\tfor (i=0; i<count; i++) {\n\t\tsamp = gf_isom_get_sample_info(file, Track, i+1, NULL, NULL);\n\t\tif (!samp) break;\n\t\t\n\t\t//get the size\n\t\t*avgSize += samp->dataLength;\n\t\tif (*MaxSize < samp->dataLength) *MaxSize = samp->dataLength;\n\t\tts_diff = (u32) (samp->DTS+samp->CTS_Offset - prevTS);\n\t\t//get the time\n\t\ttdelta += ts_diff;\n\n\t\tif (i==1) {\n\t\t\t*const_duration = ts_diff;\n\t\t} else if ( (i<count-1) && (*const_duration != ts_diff) ) {\n\t\t\t*const_duration = 0;\n\t\t}\n\n\t\tprevTS = samp->DTS+samp->CTS_Offset;\n\t\tbw += 8*samp->dataLength;\n\n\t\t//get the CTS delta\n\t\tif ((samp->CTS_Offset>=0) && ((u32)samp->CTS_Offset > *maxCTSDelta))\n\t\t\t*maxCTSDelta = samp->CTS_Offset;\n\t\tgf_isom_sample_del(&samp);\n\t}\n\tif (count>1) *TimeDelta = (u32) (tdelta/ (count-1) );\n\telse *TimeDelta = (u32) tdelta;\n\t*avgSize /= count;\n\tbw *= gf_isom_get_media_timescale(file, Track);\n\tbw /= (s64) gf_isom_get_media_duration(file, Track);\n\tbw /= 1000;\n\t(*bandwidth) = (u32) (bw+0.5);\n\n\t//delta is NOT an average, we need to know exactly how many bits are\n\t//needed to encode CTS-DTS for ANY samples\n}\n\n\n#ifndef GPAC_DISABLE_ISOM_HINTING\n\n/*RTP track hinter*/\nstruct __tag_isom_hinter\n{\n\tGF_ISOFile *file;\n\t/*IDs are kept for mp4 hint sample building*/\n\tu32 TrackNum, TrackID, HintTrack, HintID;\n\t/*current Hint sample and associated RTP time*/\n\tu32 HintSample, RTPTime;\n\n\t/*track has composition time offset*/\n\tBool has_ctts;\n\t/*remember if first SL packet in RTP packet is RAP*/\n\tu8 SampleIsRAP;\n\tu32 base_offset_in_sample;\n\tu32 OrigTimeScale;\n\t/*rtp builder*/\n\tGP_RTPPacketizer *rtp_p;\n\n\tu32 bandwidth, nb_chan;\n\n\t/*NALU size for H264/AVC*/\n\tu32 avc_nalu_size;\n\n\t/*stats*/\n\tu32 TotalSample, CurrentSample;\n};\n\n\n/*\n\toffset for group ID for hint tracks in SimpleAV mode when all media data\n\tis copied to the hint track (no use interleaving hint and original in this case)\n\tthis offset is applied internally by the track hinter. Thus you shouldn't\n\tspecify a GroupID >= OFFSET_HINT_GROUP_ID if you want the lib to perform efficient\n\tinterleaving in any cases (referenced or copied media)\n*/\n#define OFFSET_HINT_GROUP_ID\t0x8000\n\nvoid InitSL_RTP(GF_SLConfig *slc)\n{\n\tmemset(slc, 0, sizeof(GF_SLConfig));\n\tslc->tag = GF_ODF_SLC_TAG;\n\tslc->useTimestampsFlag = 1;\n\tslc->timestampLength = 32;\n}\n\nvoid InitSL_NULL(GF_SLConfig *slc)\n{\n\tmemset(slc, 0, sizeof(GF_SLConfig));\n\tslc->tag = GF_ODF_SLC_TAG;\n\tslc->predefined = 0x01;\n}\n\n\n\nvoid MP4T_OnPacketDone(void *cbk, GF_RTPHeader *header)\n{\n\tu8 disposable;\n\tGF_RTPHinter *tkHint = (GF_RTPHinter *)cbk;\n\tif (!tkHint || !tkHint->HintSample) return;\n\tassert(header->TimeStamp == tkHint->RTPTime);\n\n\tdisposable = 0;\n\tif (tkHint->avc_nalu_size) {\n\t\tdisposable = tkHint->rtp_p->avc_non_idr ? 1 : 0;\n\t}\n\t/*for all other, assume that CTS=DTS means B-frame -> disposable*/\n\telse if (tkHint->has_ctts && (tkHint->rtp_p->sl_header.compositionTimeStamp==tkHint->rtp_p->sl_header.decodingTimeStamp)) {\n\t\tdisposable = 1;\n\t}\n\n\tgf_isom_rtp_packet_set_flags(tkHint->file, tkHint->HintTrack, 0, 0, header->Marker, disposable, 0);\n}\n\n\nvoid MP4T_OnDataRef(void *cbk, u32 payload_size, u32 offset_from_orig)\n{\n\tGF_RTPHinter *tkHint = (GF_RTPHinter *)cbk;\n\tif (!tkHint || !payload_size) return;\n\n\t/*add reference*/\n\tgf_isom_hint_sample_data(tkHint->file, tkHint->HintTrack, tkHint->TrackID,\n\t                         tkHint->CurrentSample, (u16) payload_size, offset_from_orig + tkHint->base_offset_in_sample,\n\t                         NULL, 0);\n}\n\nvoid MP4T_OnData(void *cbk, u8 *data, u32 data_size, Bool is_header)\n{\n\tu8 at_begin;\n\tGF_RTPHinter *tkHint = (GF_RTPHinter *)cbk;\n\tif (!data_size) return;\n\n\tat_begin = is_header ? 1 : 0;\n\tif (data_size <= 14) {\n\t\tgf_isom_hint_direct_data(tkHint->file, tkHint->HintTrack, data, data_size, at_begin);\n\t} else {\n\t\tgf_isom_hint_sample_data(tkHint->file, tkHint->HintTrack, tkHint->HintID, 0, (u16) data_size, 0, data, at_begin);\n\t}\n}\n\n\nvoid MP4T_OnNewPacket(void *cbk, GF_RTPHeader *header)\n{\n\ts32 res;\n\tGF_RTPHinter *tkHint = (GF_RTPHinter *)cbk;\n\tif (!tkHint) return;\n\n\tres = (s32) (tkHint->rtp_p->sl_header.compositionTimeStamp - tkHint->rtp_p->sl_header.decodingTimeStamp);\n\tassert( !res || tkHint->has_ctts);\n\t/*do we need a new sample*/\n\tif (!tkHint->HintSample || (tkHint->RTPTime != header->TimeStamp)) {\n\t\t/*close current sample*/\n\t\tif (tkHint->HintSample) gf_isom_end_hint_sample(tkHint->file, tkHint->HintTrack, tkHint->SampleIsRAP);\n\n\t\t/*start new sample: We use DTS as the sampling instant (RTP TS) to make sure\n\t\tall packets are sent in order*/\n\t\tgf_isom_begin_hint_sample(tkHint->file, tkHint->HintTrack, 1, header->TimeStamp-res);\n\t\ttkHint->HintSample ++;\n\t\ttkHint->RTPTime = header->TimeStamp;\n\t\ttkHint->SampleIsRAP = tkHint->rtp_p->sl_config.hasRandomAccessUnitsOnlyFlag ? 1 : tkHint->rtp_p->sl_header.randomAccessPointFlag;\n\t}\n\t/*create an RTP Packet with the appropriated marker flag - note: the flags are temp ones,\n\tthey are set when the full packet is signaled (to handle multi AUs per RTP)*/\n\tgf_isom_rtp_packet_begin(tkHint->file, tkHint->HintTrack, 0, 0, 0, header->Marker, header->PayloadType, 0, 0, header->SequenceNumber);\n\t/*Add the delta TS to make sure RTP TS is indeed the CTS (sampling time)*/\n\tif (res) gf_isom_rtp_packet_set_offset(tkHint->file, tkHint->HintTrack, res);\n}\n\n\nGF_EXPORT\nGF_RTPHinter *gf_hinter_track_new(GF_ISOFile *file, u32 TrackNum,\n                                  u32 Path_MTU, u32 max_ptime, u32 default_rtp_rate, u32 flags, u8 PayloadID,\n                                  Bool copy_media, u32 InterleaveGroupID, u8 InterleaveGroupPriority, GF_Err *e)\n{\n\n\tGF_SLConfig my_sl;\n\tu32 descIndex, MinSize, MaxSize, avgTS, streamType, codecid, const_dur, nb_ch, maxDTSDelta;\n\tu8 OfficialPayloadID;\n\tu32 TrackMediaSubType, TrackMediaType, hintType, nbEdts, required_rate, force_dts_delta, avc_nalu_size, PL_ID, bandwidth, IV_length, KI_length;\n\tconst char *url, *urn;\n\tchar *mpeg4mode;\n\tBool is_crypted, has_mpeg4_mapping;\n\tGF_RTPHinter *tmp;\n\tGF_ESD *esd;\n\n\t*e = GF_BAD_PARAM;\n\tif (!file || !TrackNum || !gf_isom_get_track_id(file, TrackNum)) return NULL;\n\n\tif (!gf_isom_get_sample_count(file, TrackNum)) {\n\t\t*e = GF_OK;\n\t\treturn NULL;\n\t}\n\t*e = GF_NOT_SUPPORTED;\n\tnbEdts = gf_isom_get_edits_count(file, TrackNum);\n\tif (nbEdts>1) {\n\t\tu64 et, sd, mt;\n\t\tGF_ISOEditType em;\n\t\tgf_isom_get_edit(file, TrackNum, 1, &et, &sd, &mt, &em);\n\t\tif ((nbEdts>2) || (em!=GF_ISOM_EDIT_EMPTY)) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_RTP, (\"[rtp hinter] Cannot hint track whith EditList\\n\"));\n\t\t\treturn NULL;\n\t\t}\n\t}\n\tif (nbEdts) gf_isom_remove_edits(file, TrackNum);\n\n\tif (!gf_isom_is_track_enabled(file, TrackNum)) return NULL;\n\n\t/*by default NO PL signaled*/\n\tPL_ID = 0;\n\tOfficialPayloadID = 0;\n\tforce_dts_delta = 0;\n\tstreamType = 0;\n\tmpeg4mode = NULL;\n\trequired_rate = 0;\n\tis_crypted = 0;\n\tIV_length = KI_length = 0;\n\tcodecid = 0;\n\tnb_ch = 0;\n\tavc_nalu_size = 0;\n\thas_mpeg4_mapping = 1;\n\tconst_dur = 0;\n\tbandwidth=0;\n\tTrackMediaType = gf_isom_get_media_type(file, TrackNum);\n\n\t/*for max compatibility with QT*/\n\tif (!default_rtp_rate) default_rtp_rate = 90000;\n\n\t/*timed-text is a bit special, we support multiple stream descriptions & co*/\n\tif ( (TrackMediaType==GF_ISOM_MEDIA_TEXT) || (TrackMediaType==GF_ISOM_MEDIA_SUBT)) {\n\t\thintType = GF_RTP_PAYT_3GPP_TEXT;\n\t\tcodecid = GF_CODECID_TEXT_MPEG4;\n\t\tstreamType = GF_STREAM_TEXT;\n\t\t/*fixme - this works cos there's only one PL for text in mpeg4 at the current time*/\n\t\tPL_ID = 0x10;\n\t} else {\n\t\tif (gf_isom_get_sample_description_count(file, TrackNum) > 1) return NULL;\n\n\t\tTrackMediaSubType = gf_isom_get_media_subtype(file, TrackNum, 1);\n\t\tswitch (TrackMediaSubType) {\n\t\tcase GF_ISOM_SUBTYPE_MPEG4_CRYP:\n\t\t\tis_crypted = 1;\n\t\tcase GF_ISOM_SUBTYPE_MPEG4:\n\t\t\tesd = gf_isom_get_esd(file, TrackNum, 1);\n\t\t\thintType = GF_RTP_PAYT_MPEG4;\n\t\t\tif (esd && esd->decoderConfig) {\n\t\t\t\tstreamType = esd->decoderConfig->streamType;\n\t\t\t\tcodecid = esd->decoderConfig->objectTypeIndication;\n\t\t\t\tif (esd->URLString) hintType = 0;\n\t\t\t\t/*AAC*/\n\t\t\t\tif ((streamType==GF_STREAM_AUDIO)\n\t\t\t\t\t&& esd->decoderConfig->decoderSpecificInfo && esd->decoderConfig->decoderSpecificInfo->data\n\t\t\t\t        /*(nb: we use mpeg4 for MPEG-2 AAC)*/\n\t\t\t\t        && ((codecid==GF_CODECID_AAC_MPEG4) || (codecid==GF_CODECID_AAC_MPEG2_MP) || (codecid==GF_CODECID_AAC_MPEG2_LCP) || (codecid==GF_CODECID_AAC_MPEG2_SSRP)) ) {\n\n\t\t\t\t\tu32 sample_rate;\n\t\t\t\t\tGF_M4ADecSpecInfo a_cfg;\n\t\t\t\t\tgf_m4a_get_config(esd->decoderConfig->decoderSpecificInfo->data, esd->decoderConfig->decoderSpecificInfo->dataLength, &a_cfg);\n\t\t\t\t\tnb_ch = a_cfg.nb_chan;\n\t\t\t\t\tsample_rate = a_cfg.base_sr;\n\t\t\t\t\tPL_ID = a_cfg.audioPL;\n\t\t\t\t\tswitch (a_cfg.base_object_type) {\n\t\t\t\t\tcase GF_M4A_AAC_MAIN:\n\t\t\t\t\tcase GF_M4A_AAC_LC:\n\t\t\t\t\t\tif (flags & GP_RTP_PCK_USE_LATM_AAC) {\n\t\t\t\t\t\t\thintType = GF_RTP_PAYT_LATM;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\tcase GF_M4A_AAC_SBR:\n\t\t\t\t\tcase GF_M4A_AAC_PS:\n\t\t\t\t\tcase GF_M4A_AAC_LTP:\n\t\t\t\t\tcase GF_M4A_AAC_SCALABLE:\n\t\t\t\t\tcase GF_M4A_ER_AAC_LC:\n\t\t\t\t\tcase GF_M4A_ER_AAC_LTP:\n\t\t\t\t\tcase GF_M4A_ER_AAC_SCALABLE:\n\t\t\t\t\t\tmpeg4mode = \"AAC\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase GF_M4A_CELP:\n\t\t\t\t\tcase GF_M4A_ER_CELP:\n\t\t\t\t\t\tmpeg4mode = \"CELP\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\trequired_rate = sample_rate;\n\t\t\t\t}\n\t\t\t\t/*MPEG1/2 audio*/\n\t\t\t\telse if ((streamType==GF_STREAM_AUDIO) && ((codecid==GF_CODECID_MPEG2_PART3) || (codecid==GF_CODECID_MPEG_AUDIO))) {\n\t\t\t\t\tGF_ISOSample *samp = NULL;\n\t\t\t\t\tif (!is_crypted)\n\t\t\t\t\t\t samp = gf_isom_get_sample(file, TrackNum, 1, NULL);\n\n\t\t\t\t\tif (samp && (samp->dataLength>3)) {\n\t\t\t\t\t\tu32 hdr = GF_4CC((u32)samp->data[0], (u8)samp->data[1], (u8)samp->data[2], (u8)samp->data[3]);\n\t\t\t\t\t\tnb_ch = gf_mp3_num_channels(hdr);\n\t\t\t\t\t\thintType = GF_RTP_PAYT_MPEG12_AUDIO;\n\t\t\t\t\t\t/*use official RTP/AVP payload type*/\n\t\t\t\t\t\tOfficialPayloadID = 14;\n\t\t\t\t\t\trequired_rate = 90000;\n\t\t\t\t\t}\n\t\t\t\t\t/*encrypted MP3 must be sent through MPEG-4 generic to signal all ISMACryp stuff*/\n\t\t\t\t\telse {\n\t\t\t\t\t\tu32 sample_rate;\n\t\t\t\t\t\tgf_isom_get_audio_info(file, TrackNum, 1, &sample_rate, &nb_ch, NULL);\n\t\t\t\t\t\trequired_rate = sample_rate;\n\t\t\t\t\t}\n\t\t\t\t\tif (samp)\n\t\t\t\t\t\tgf_isom_sample_del(&samp);\n\n\t\t\t\t}\n\t\t\t\t/*QCELP audio*/\n\t\t\t\telse if ((streamType==GF_STREAM_AUDIO) && (codecid==GF_CODECID_QCELP)) {\n\t\t\t\t\thintType = GF_RTP_PAYT_QCELP;\n\t\t\t\t\tOfficialPayloadID = 12;\n\t\t\t\t\trequired_rate = 8000;\n\t\t\t\t\tstreamType = GF_STREAM_AUDIO;\n\t\t\t\t\tnb_ch = 1;\n\t\t\t\t}\n\t\t\t\t/*EVRC/SVM audio*/\n\t\t\t\telse if ((streamType==GF_STREAM_AUDIO) && ((codecid==GF_CODECID_EVRC) || (codecid==GF_CODECID_SMV)) ) {\n\t\t\t\t\thintType = GF_RTP_PAYT_EVRC_SMV;\n\t\t\t\t\trequired_rate = 8000;\n\t\t\t\t\tstreamType = GF_STREAM_AUDIO;\n\t\t\t\t\tnb_ch = 1;\n\t\t\t\t}\n\t\t\t\t/*visual streams*/\n\t\t\t\telse if (streamType==GF_STREAM_VISUAL) {\n\t\t\t\t\tif ((codecid==GF_CODECID_MPEG4_PART2) && esd->decoderConfig->decoderSpecificInfo) {\n\t\t\t\t\t\tGF_M4VDecSpecInfo dsi;\n\t\t\t\t\t\tgf_m4v_get_config(esd->decoderConfig->decoderSpecificInfo->data, esd->decoderConfig->decoderSpecificInfo->dataLength, &dsi);\n\t\t\t\t\t\tPL_ID = dsi.VideoPL;\n\t\t\t\t\t}\n\t\t\t\t\t/*MPEG1/2 video*/\n\t\t\t\t\tif ( ((codecid>=GF_CODECID_MPEG2_SIMPLE) && (codecid<=GF_CODECID_MPEG2_422)) || (codecid==GF_CODECID_MPEG1)) {\n\t\t\t\t\t\tif (!is_crypted) {\n\t\t\t\t\t\t\thintType = GF_RTP_PAYT_MPEG12_VIDEO;\n\t\t\t\t\t\t\tOfficialPayloadID = 32;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t/*for ISMA*/\n\t\t\t\t\tif (is_crypted) {\n\t\t\t\t\t\t/*that's another pain with ISMACryp, even if no B-frames the DTS is signaled...*/\n\t\t\t\t\t\tif (codecid==GF_CODECID_MPEG4_PART2) force_dts_delta = 22;\n\t\t\t\t\t\telse if ((codecid==GF_CODECID_AVC) || (codecid==GF_CODECID_SVC)) {\n\t\t\t\t\t\t\tflags &= ~GP_RTP_PCK_USE_MULTI;\n\t\t\t\t\t\t\tforce_dts_delta = 22;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tflags |= GP_RTP_PCK_SIGNAL_RAP | GP_RTP_PCK_SIGNAL_TS;\n\t\t\t\t\t}\n\n\t\t\t\t\trequired_rate = default_rtp_rate;\n\t\t\t\t}\n\t\t\t\t/*systems streams*/\n\t\t\t\telse if (gf_isom_has_sync_shadows(file, TrackNum) || gf_isom_has_sample_dependency(file, TrackNum)) {\n\t\t\t\t\tflags |= GP_RTP_PCK_SYSTEMS_CAROUSEL;\n\t\t\t\t}\n\t\t\t\tgf_odf_desc_del((GF_Descriptor*)esd);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GF_ISOM_SUBTYPE_3GP_H263:\n\t\t\thintType = GF_RTP_PAYT_H263;\n\t\t\trequired_rate = 90000;\n\t\t\tstreamType = GF_STREAM_VISUAL;\n\t\t\tOfficialPayloadID = 34;\n\t\t\t/*not 100% compliant (short header is missing) but should still work*/\n\t\t\tcodecid = GF_CODECID_MPEG4_PART2;\n\t\t\tPL_ID = 0x01;\n\t\t\tbreak;\n\t\tcase GF_ISOM_SUBTYPE_3GP_AMR:\n\t\t\trequired_rate = 8000;\n\t\t\thintType = GF_RTP_PAYT_AMR;\n\t\t\tstreamType = GF_STREAM_AUDIO;\n\t\t\thas_mpeg4_mapping = 0;\n\t\t\tnb_ch = 1;\n\t\t\tbreak;\n\t\tcase GF_ISOM_SUBTYPE_3GP_AMR_WB:\n\t\t\trequired_rate = 16000;\n\t\t\thintType = GF_RTP_PAYT_AMR_WB;\n\t\t\tstreamType = GF_STREAM_AUDIO;\n\t\t\thas_mpeg4_mapping = 0;\n\t\t\tnb_ch = 1;\n\t\t\tbreak;\n\t\tcase GF_ISOM_SUBTYPE_AVC_H264:\n\t\tcase GF_ISOM_SUBTYPE_AVC2_H264:\n\t\tcase GF_ISOM_SUBTYPE_AVC3_H264:\n\t\tcase GF_ISOM_SUBTYPE_AVC4_H264:\n\t\tcase GF_ISOM_SUBTYPE_SVC_H264:\n\t\tcase GF_ISOM_SUBTYPE_MVC_H264:\n\t\t{\n\t\t\tGF_AVCConfig *avcc = gf_isom_avc_config_get(file, TrackNum, 1);\n\t\t\tGF_AVCConfig *svcc = gf_isom_svc_config_get(file, TrackNum, 1);\n\t\t\tGF_AVCConfig *mvcc = gf_isom_mvc_config_get(file, TrackNum, 1);\n\n\t\t\tif (!avcc && !svcc && !mvcc) {\n\t\t\t\t*e = GF_NON_COMPLIANT_BITSTREAM;\n\t\t\t\treturn NULL;\n\t\t\t}\n\n\t\t\trequired_rate = 90000;\t/* \"90 kHz clock rate MUST be used\"*/\n\t\t\thintType = GF_RTP_PAYT_H264_AVC;\n\t\t\tif (TrackMediaSubType==GF_ISOM_SUBTYPE_SVC_H264)\n\t\t\t\thintType = GF_RTP_PAYT_H264_SVC;\n\t\t\telse if (TrackMediaSubType==GF_ISOM_SUBTYPE_MVC_H264)\n\t\t\t\thintType = GF_RTP_PAYT_H264_SVC;\n\t\t\tstreamType = GF_STREAM_VISUAL;\n\t\t\tavc_nalu_size = avcc ? avcc->nal_unit_size : svcc ? svcc->nal_unit_size : mvcc->nal_unit_size;\n\t\t\tcodecid = GF_CODECID_AVC;\n\t\t\tPL_ID = 0x0F;\n\t\t\tgf_odf_avc_cfg_del(avcc);\n\t\t\tgf_odf_avc_cfg_del(svcc);\n\t\t}\n\t\tbreak;\n\t\tcase GF_ISOM_SUBTYPE_HVC1:\n\t\tcase GF_ISOM_SUBTYPE_HEV1:\n\t\tcase GF_ISOM_SUBTYPE_HVC2:\n\t\tcase GF_ISOM_SUBTYPE_HEV2:\n\t\t{\n\t\t\tGF_HEVCConfig *hevcc = gf_isom_hevc_config_get(file, TrackNum, 1);\n\t\t\tif (!hevcc) {\n\t\t\t\t*e = GF_NON_COMPLIANT_BITSTREAM;\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\trequired_rate = 90000;\t/* \"90 kHz clock rate MUST be used\"*/\n\t\t\thintType = GF_RTP_PAYT_HEVC;\n\t\t\tstreamType = GF_STREAM_VISUAL;\n\t\t\tavc_nalu_size = hevcc->nal_unit_size;\n\t\t\tcodecid = GF_CODECID_HEVC;\n\t\t\tPL_ID = 0x0F;\n\t\t\tflags |= GP_RTP_PCK_USE_MULTI;\n\t\t\tgf_odf_hevc_cfg_del(hevcc);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t\tcase GF_ISOM_SUBTYPE_3GP_QCELP:\n\t\t\trequired_rate = 8000;\n\t\t\thintType = GF_RTP_PAYT_QCELP;\n\t\t\tstreamType = GF_STREAM_AUDIO;\n\t\t\tcodecid = GF_CODECID_QCELP;\n\t\t\tOfficialPayloadID = 12;\n\t\t\tnb_ch = 1;\n\t\t\tbreak;\n\t\tcase GF_ISOM_SUBTYPE_3GP_EVRC:\n\t\tcase GF_ISOM_SUBTYPE_3GP_SMV:\n\t\t\trequired_rate = 8000;\n\t\t\thintType = GF_RTP_PAYT_EVRC_SMV;\n\t\t\tstreamType = GF_STREAM_AUDIO;\n\t\t\tcodecid = (TrackMediaSubType==GF_ISOM_SUBTYPE_3GP_EVRC) ? GF_CODECID_EVRC : GF_CODECID_SMV;\n\t\t\tnb_ch = 1;\n\t\t\tbreak;\n\t\tcase GF_ISOM_SUBTYPE_3GP_DIMS:\n#if GPAC_ENABLE_3GPP_DIMS_RTP\n\t\t\thintType = GF_RTP_PAYT_3GPP_DIMS;\n\t\t\tstreamType = GF_STREAM_SCENE;\n#else\n\t\t\thintType = 0;\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_RTP, (\"[RTP Packetizer] 3GPP DIMS over RTP disabled in build\\n\", streamType));\n#endif\n\t\t\tbreak;\n\t\tcase GF_ISOM_SUBTYPE_AC3:\n\t\t\thintType = GF_RTP_PAYT_AC3;\n\t\t\tstreamType = GF_STREAM_AUDIO;\n\t\t\tgf_isom_get_audio_info(file, TrackNum, 1, NULL, &nb_ch, NULL);\n\t\t\tbreak;\n\t\tcase GF_ISOM_SUBTYPE_MP3:\n\t\t{\n\t\t\tGF_ISOSample *samp = gf_isom_get_sample(file, TrackNum, 1, NULL);\n\t\t\tif (samp && (samp->dataLength>3)) {\n\t\t\t\tu32 hdr = GF_4CC((u32)samp->data[0], (u8)samp->data[1], (u8)samp->data[2], (u8)samp->data[3]);\n\t\t\t\tnb_ch = gf_mp3_num_channels(hdr);\n\t\t\t} else {\n\t\t\t\tu32 bps;\n\t\t\t\tgf_isom_get_audio_info(file, TrackNum, 1, &required_rate, &nb_ch, &bps);\n\t\t\t}\n\t\t\thintType = GF_RTP_PAYT_MPEG12_AUDIO;\n\t\t\t/*use official RTP/AVP payload type*/\n\t\t\tOfficialPayloadID = 14;\n\t\t\trequired_rate = 90000;\n\n\t\t\tif (samp)\n\t\t\t\tgf_isom_sample_del(&samp);\n\t\t}\n\t\tbreak;\n\t\tdefault:\n\t\t\t/*ERROR*/\n\t\t\thintType = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/*not hintable*/\n\tif (!hintType) return NULL;\n\t/*we only support self-contained files for hinting*/\n\tgf_isom_get_data_reference(file, TrackNum, 1, &url, &urn);\n\tif (url || urn) return NULL;\n\n\t*e = GF_OUT_OF_MEM;\n\tGF_SAFEALLOC(tmp, GF_RTPHinter);\n\tif (!tmp) return NULL;\n\n\t/*override hinter type if requested and possible*/\n\tif (has_mpeg4_mapping && (flags & GP_RTP_PCK_FORCE_MPEG4)) {\n\t\thintType = GF_RTP_PAYT_MPEG4;\n\t\tavc_nalu_size = 0;\n\t}\n\t/*use static payload ID if enabled*/\n\telse if (OfficialPayloadID && (flags & GP_RTP_PCK_USE_STATIC_ID) ) {\n\t\tPayloadID = OfficialPayloadID;\n\t}\n\n\ttmp->file = file;\n\ttmp->TrackNum = TrackNum;\n\ttmp->avc_nalu_size = avc_nalu_size;\n\ttmp->nb_chan = nb_ch;\n\n\t/*spatial scalability check*/\n\ttmp->has_ctts = gf_isom_has_time_offset(file, TrackNum);\n\n\t/*get sample info*/\n\tgf_media_get_sample_average_infos(file, TrackNum, &MinSize, &MaxSize, &avgTS, &maxDTSDelta, &const_dur, &bandwidth);\n\n\t/*systems carousel: we need at least IDX and RAP signaling*/\n\tif (flags & GP_RTP_PCK_SYSTEMS_CAROUSEL) {\n\t\tflags |= GP_RTP_PCK_SIGNAL_RAP;\n\t}\n\n\t/*update flags in MultiSL*/\n\tif (flags & GP_RTP_PCK_USE_MULTI) {\n\t\tif (MinSize != MaxSize) flags |= GP_RTP_PCK_SIGNAL_SIZE;\n\t\tif (!const_dur) flags |= GP_RTP_PCK_SIGNAL_TS;\n\t}\n\tif (tmp->has_ctts) flags |= GP_RTP_PCK_SIGNAL_TS;\n\n\t/*default SL for RTP */\n\tInitSL_RTP(&my_sl);\n\n\tmy_sl.timestampResolution = gf_isom_get_media_timescale(file, TrackNum);\n\t/*override clockrate if set*/\n\tif (required_rate) {\n\t\tDouble sc = required_rate;\n\t\tsc /= my_sl.timestampResolution;\n\t\tmaxDTSDelta = (u32) (maxDTSDelta*sc);\n\t\tmy_sl.timestampResolution = required_rate;\n\t}\n\t/*switch to RTP TS*/\n\tmax_ptime = (u32) (max_ptime * my_sl.timestampResolution / 1000);\n\n\tmy_sl.AUSeqNumLength = gf_get_bit_size(gf_isom_get_sample_count(file, TrackNum));\n\tif (my_sl.AUSeqNumLength>16) my_sl.AUSeqNumLength=16;\n\n\tmy_sl.CUDuration = const_dur;\n\n\tif (gf_isom_has_sync_points(file, TrackNum)) {\n\t\tmy_sl.useRandomAccessPointFlag = 1;\n\t} else {\n\t\tmy_sl.useRandomAccessPointFlag = 0;\n\t\tmy_sl.hasRandomAccessUnitsOnlyFlag = 1;\n\t}\n\n\tif (is_crypted) {\n\t\tBool use_sel_enc;\n\t\tgf_isom_get_ismacryp_info(file, TrackNum, 1, NULL, NULL, NULL, NULL, NULL, &use_sel_enc, &IV_length, &KI_length);\n\t\tif (use_sel_enc) flags |= GP_RTP_PCK_SELECTIVE_ENCRYPTION;\n\t}\n\n\t// in case a different timescale was provided\n\ttmp->OrigTimeScale = gf_isom_get_media_timescale(file, TrackNum);\n\ttmp->rtp_p = gf_rtp_builder_new(hintType, &my_sl, flags, tmp,\n\t                                MP4T_OnNewPacket, MP4T_OnPacketDone,\n\t                                /*if copy, no data ref*/\n\t                                copy_media ? NULL : MP4T_OnDataRef,\n\t                                MP4T_OnData);\n\n\t//init the builder\n\tgf_rtp_builder_init(tmp->rtp_p, PayloadID, Path_MTU, max_ptime,\n\t                    streamType, codecid, PL_ID, MinSize, MaxSize, avgTS, maxDTSDelta, IV_length, KI_length, mpeg4mode);\n\n\t/*ISMA compliance is a pain...*/\n\tif (force_dts_delta) tmp->rtp_p->slMap.DTSDeltaLength = force_dts_delta;\n\n\n\t/*\t\tHint Track Setup\t*/\n\ttmp->TrackID = gf_isom_get_track_id(file, TrackNum);\n\ttmp->HintID = tmp->TrackID + 65535;\n\twhile (gf_isom_get_track_by_id(file, tmp->HintID)) tmp->HintID++;\n\n\ttmp->HintTrack = gf_isom_new_track(file, tmp->HintID, GF_ISOM_MEDIA_HINT, my_sl.timestampResolution);\n\tgf_isom_setup_hint_track(file, tmp->HintTrack, GF_ISOM_HINT_RTP);\n\t/*create a hint description*/\n\tgf_isom_new_hint_description(file, tmp->HintTrack, -1, -1, 0, &descIndex);\n\tgf_isom_rtp_set_timescale(file, tmp->HintTrack, descIndex, my_sl.timestampResolution);\n\n\tif (hintType==GF_RTP_PAYT_MPEG4) {\n\t\ttmp->rtp_p->slMap.CodecID = codecid;\n\t\t/*set this SL for extraction.*/\n\t\t*e = gf_isom_set_extraction_slc(file, TrackNum, 1, &my_sl);\n\t\tif (*e) {\n\t\t\tgf_hinter_track_del(tmp);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\ttmp->bandwidth = bandwidth;\n\n\t/*set interleaving*/\n\tgf_isom_set_track_interleaving_group(file, TrackNum, InterleaveGroupID);\n\tif (!copy_media) {\n\t\t/*if we don't copy data set hint track and media track in the same group*/\n\t\tgf_isom_set_track_interleaving_group(file, tmp->HintTrack, InterleaveGroupID);\n\t} else {\n\t\tgf_isom_set_track_interleaving_group(file, tmp->HintTrack, InterleaveGroupID + OFFSET_HINT_GROUP_ID);\n\t}\n\t/*use user-secified priority*/\n\tInterleaveGroupPriority*=2;\n\tgf_isom_set_track_priority_in_group(file, TrackNum, InterleaveGroupPriority+1);\n\tgf_isom_set_track_priority_in_group(file, tmp->HintTrack, InterleaveGroupPriority);\n\n#if 0\n#endif\n\t*e = GF_OK;\n\treturn tmp;\n}\n\nGF_EXPORT\nGF_Err gf_hinter_track_force_no_offsets(GF_RTPHinter *tkHinter)\n{\n\tGF_Err e;\n\tif (!tkHinter) return GF_BAD_PARAM;\n\te = gf_isom_rtp_set_time_offset(tkHinter->file, tkHinter->HintTrack, 1, 0);\n\tif (e) return e;\n\treturn gf_isom_rtp_set_time_sequence_offset(tkHinter->file, tkHinter->HintTrack, 1, 0);\n}\n\nGF_EXPORT\nu32 gf_hinter_track_get_bandwidth(GF_RTPHinter *tkHinter)\n{\n\treturn tkHinter->bandwidth;\n}\n\nGF_EXPORT\nu32 gf_hinter_track_get_flags(GF_RTPHinter *tkHinter)\n{\n\treturn tkHinter->rtp_p->flags;\n}\nGF_EXPORT\nvoid gf_hinter_track_get_payload_name(GF_RTPHinter *tkHinter, char *payloadName)\n{\n\tchar mediaName[30];\n\tgf_rtp_builder_get_payload_name(tkHinter->rtp_p, payloadName, mediaName);\n}\n\nGF_EXPORT\nvoid gf_hinter_track_del(GF_RTPHinter *tkHinter)\n{\n\tif (!tkHinter) return;\n\n\tif (tkHinter->rtp_p) gf_rtp_builder_del(tkHinter->rtp_p);\n\tgf_free(tkHinter);\n}\n\nGF_EXPORT\nGF_Err gf_hinter_track_process(GF_RTPHinter *tkHint)\n{\n\tGF_Err e;\n\tu32 i, descIndex, duration;\n\tu64 ts;\n\tu8 PadBits;\n\tGF_Fraction ft;\n\tGF_ISOSample *samp;\n\n\ttkHint->HintSample = tkHint->RTPTime = 0;\n\n\ttkHint->TotalSample = gf_isom_get_sample_count(tkHint->file, tkHint->TrackNum);\n\tft.num = tkHint->rtp_p->sl_config.timestampResolution;\n\tft.den = tkHint->OrigTimeScale;\n\n\te = GF_OK;\n\tfor (i=0; i<tkHint->TotalSample; i++) {\n\t\tsamp = gf_isom_get_sample(tkHint->file, tkHint->TrackNum, i+1, &descIndex);\n\t\tif (!samp) return gf_isom_last_error(tkHint->file);\n\n\t\t//setup SL\n\t\ttkHint->CurrentSample = i + 1;\n\n\t\t/*keep same AU indicator if sync shadow - TODO FIXME: this assumes shadows are placed interleaved with\n\t\tthe track content which is the case for GPAC scene carousel generation, but may not always be true*/\n\t\tif (samp->IsRAP==RAP_REDUNDANT) {\n\t\t\ttkHint->rtp_p->sl_header.AU_sequenceNumber -= 1;\n\t\t\tsamp->IsRAP = RAP;\n\t\t}\n\n\t\tts = ft.num * (samp->DTS+samp->CTS_Offset) / ft.den;\n\t\ttkHint->rtp_p->sl_header.compositionTimeStamp = ts;\n\n\t\tts = ft.num * samp->DTS / ft.den;\n\t\ttkHint->rtp_p->sl_header.decodingTimeStamp = ts;\n\t\ttkHint->rtp_p->sl_header.randomAccessPointFlag = samp->IsRAP;\n\n\t\ttkHint->base_offset_in_sample = 0;\n\t\t/*crypted*/\n\t\tif (tkHint->rtp_p->slMap.IV_length) {\n\t\t\tGF_ISMASample *s = gf_isom_get_ismacryp_sample(tkHint->file, tkHint->TrackNum, samp, descIndex);\n\t\t\t/*one byte take for selective_enc flag*/\n\t\t\tif (s->flags & GF_ISOM_ISMA_USE_SEL_ENC) tkHint->base_offset_in_sample += 1;\n\t\t\tif (s->flags & GF_ISOM_ISMA_IS_ENCRYPTED) tkHint->base_offset_in_sample += s->IV_length + s->KI_length;\n\t\t\tgf_free(samp->data);\n\t\t\tsamp->data = s->data;\n\t\t\tsamp->dataLength = s->dataLength;\n\t\t\tgf_rtp_builder_set_cryp_info(tkHint->rtp_p, s->IV, (char*)s->key_indicator, (s->flags & GF_ISOM_ISMA_IS_ENCRYPTED) ? 1 : 0);\n\t\t\ts->data = NULL;\n\t\t\ts->dataLength = 0;\n\t\t\tgf_isom_ismacryp_delete_sample(s);\n\t\t}\n\n\t\tif (tkHint->rtp_p->sl_config.usePaddingFlag) {\n\t\t\tgf_isom_get_sample_padding_bits(tkHint->file, tkHint->TrackNum, i+1, &PadBits);\n\t\t\ttkHint->rtp_p->sl_header.paddingBits = PadBits;\n\t\t} else {\n\t\t\ttkHint->rtp_p->sl_header.paddingBits = 0;\n\t\t}\n\n\t\tduration = gf_isom_get_sample_duration(tkHint->file, tkHint->TrackNum, i+1);\n//\t\tts = (u32) (ft * (s64) (duration));\n\n\t\t/*unpack nal units*/\n\t\tif (tkHint->avc_nalu_size) {\n\t\t\tu32 v, size;\n\t\t\tu32 remain = samp->dataLength;\n\t\t\tchar *ptr = samp->data;\n\n\t\t\ttkHint->rtp_p->sl_header.accessUnitStartFlag = 1;\n\t\t\ttkHint->rtp_p->sl_header.accessUnitEndFlag = 0;\n\t\t\twhile (remain) {\n\t\t\t\tsize = 0;\n\t\t\t\tv = tkHint->avc_nalu_size;\n\t\t\t\tif (v>remain) {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_RTP, (\"[rtp hinter] Broken AVC nalu encapsulation: NALU size length is %d but only %d bytes left in sample %d\\n\", v, remain, tkHint->CurrentSample));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\twhile (v) {\n\t\t\t\t\tsize |= (u8) *ptr;\n\t\t\t\t\tptr++;\n\t\t\t\t\tremain--;\n\t\t\t\t\tv-=1;\n\t\t\t\t\tif (v) size<<=8;\n\t\t\t\t}\n\t\t\t\ttkHint->base_offset_in_sample = samp->dataLength-remain;\n\t\t\t\tif (remain < size) {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_RTP, (\"[rtp hinter] Broken AVC nalu encapsulation: NALU size is %d but only %d bytes left in sample %d\\n\", size, remain, tkHint->CurrentSample));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tremain -= size;\n\t\t\t\ttkHint->rtp_p->sl_header.accessUnitEndFlag = remain ? 0 : 1;\n\t\t\t\tif (!size) {\n\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_RTP, (\"[rtp hinter] Broken AVC nalu encapsulation: NALU size is 0, ignoring it\\n\", size));\n\t\t\t\t} else {\n\t\t\t\t\te = gf_rtp_builder_process(tkHint->rtp_p, ptr, size, (u8) !remain, samp->dataLength, duration, (u8) (descIndex + GF_RTP_TX3G_SIDX_OFFSET) );\n\t\t\t\t\tptr += size;\n\t\t\t\t}\n\t\t\t\ttkHint->rtp_p->sl_header.accessUnitStartFlag = 0;\n\t\t\t}\n\t\t} else {\n\t\t\te = gf_rtp_builder_process(tkHint->rtp_p, samp->data, samp->dataLength, 1, samp->dataLength, duration, (u8) (descIndex + GF_RTP_TX3G_SIDX_OFFSET) );\n\t\t}\n\t\ttkHint->rtp_p->sl_header.packetSequenceNumber += 1;\n\n\t\t//signal some progress\n\t\tgf_set_progress(\"Hinting\", tkHint->CurrentSample, tkHint->TotalSample);\n\n\t\ttkHint->rtp_p->sl_header.AU_sequenceNumber += 1;\n\t\tgf_isom_sample_del(&samp);\n\n\t\tif (e) return e;\n\t}\n\n\t//flush\n\tgf_rtp_builder_process(tkHint->rtp_p, NULL, 0, 1, 0, 0, 0);\n\n\tgf_isom_end_hint_sample(tkHint->file, tkHint->HintTrack, (u8) tkHint->SampleIsRAP);\n\treturn GF_OK;\n}\n\nstatic u32 write_nalu_config_array(char *sdpLine, GF_List *nalus)\n{\n\tu32 i, count, b64s;\n\tchar b64[200];\n\n\tcount = gf_list_count(nalus);\n\tfor (i=0; i<count; i++) {\n\t\tGF_NALUFFParam *sl = (GF_NALUFFParam *)gf_list_get(nalus, i);\n\t\tb64s = gf_base64_encode(sl->data, sl->size, b64, 200);\n\t\tb64[b64s]=0;\n\t\tstrcat(sdpLine, b64);\n\t\tif (i+1<count) strcat(sdpLine, \",\");\n\t}\n\treturn count;\n}\n\nstatic void write_avc_config(char *sdpLine, GF_AVCConfig *avcc, GF_AVCConfig *svcc)\n{\n\tu32 count = 0;\n\n\tif (avcc) count += gf_list_count(avcc->sequenceParameterSets) + gf_list_count(avcc->pictureParameterSets) + gf_list_count(avcc->sequenceParameterSetExtensions);\n\tif (svcc) count += gf_list_count(svcc->sequenceParameterSets) + gf_list_count(svcc->pictureParameterSets);\n\tif (!count) return;\n\n\tstrcat(sdpLine, \"; sprop-parameter-sets=\");\n\n\tif (avcc) {\n\t\tcount = write_nalu_config_array(sdpLine, avcc->sequenceParameterSets);\n\t\tif (count) strcat(sdpLine, \",\");\n\t\tcount = write_nalu_config_array(sdpLine, avcc->sequenceParameterSetExtensions);\n\t\tif (count) strcat(sdpLine, \",\");\n\t\tcount = write_nalu_config_array(sdpLine, avcc->pictureParameterSets);\n\t\tif (count) strcat(sdpLine, \",\");\n\t}\n\n\tif (svcc) {\n\t\tcount = write_nalu_config_array(sdpLine, svcc->sequenceParameterSets);\n\t\tif (count) strcat(sdpLine, \",\");\n\t\tcount = write_nalu_config_array(sdpLine, svcc->pictureParameterSets);\n\t\tif (count) strcat(sdpLine, \",\");\n\t}\n\tcount = (u32) strlen(sdpLine);\n\tif (sdpLine[count-1] == ',')\n\t\tsdpLine[count-1] = 0;\n}\n\nGF_EXPORT\nGF_Err gf_hinter_track_finalize(GF_RTPHinter *tkHint, Bool AddSystemInfo)\n{\n\tu32 Width, Height;\n\tGF_ESD *esd;\n\tchar sdpLine[20000];\n\tchar mediaName[30], payloadName[30];\n    u32 mtype;\n\n\tWidth = Height = 0;\n\tgf_isom_sdp_clean_track(tkHint->file, tkHint->TrackNum);\n    mtype = gf_isom_get_media_type(tkHint->file, tkHint->TrackNum);\n    if (gf_isom_is_video_handler_type(mtype))\n\t\tgf_isom_get_visual_info(tkHint->file, tkHint->TrackNum, 1, &Width, &Height);\n\n\tgf_rtp_builder_get_payload_name(tkHint->rtp_p, payloadName, mediaName);\n\n\t/*TODO- extract out of rtp_p for future live tools*/\n\tsprintf(sdpLine, \"m=%s 0 RTP/%s %d\", mediaName, tkHint->rtp_p->slMap.IV_length ? \"SAVP\" : \"AVP\", tkHint->rtp_p->PayloadType);\n\tgf_isom_sdp_add_track_line(tkHint->file, tkHint->HintTrack, sdpLine);\n\tif (tkHint->bandwidth) {\n\t\tsprintf(sdpLine, \"b=AS:%d\", tkHint->bandwidth);\n\t\tgf_isom_sdp_add_track_line(tkHint->file, tkHint->HintTrack, sdpLine);\n\t}\n\tif (tkHint->nb_chan) {\n\t\tsprintf(sdpLine, \"a=rtpmap:%d %s/%d/%d\", tkHint->rtp_p->PayloadType, payloadName, tkHint->rtp_p->sl_config.timestampResolution, tkHint->nb_chan);\n\t} else {\n\t\tsprintf(sdpLine, \"a=rtpmap:%d %s/%d\", tkHint->rtp_p->PayloadType, payloadName, tkHint->rtp_p->sl_config.timestampResolution);\n\t}\n\tgf_isom_sdp_add_track_line(tkHint->file, tkHint->HintTrack, sdpLine);\n\t/*control for MPEG-4*/\n\tif (AddSystemInfo) {\n\t\tsprintf(sdpLine, \"a=mpeg4-esid:%d\", gf_isom_get_track_id(tkHint->file, tkHint->TrackNum));\n\t\tgf_isom_sdp_add_track_line(tkHint->file, tkHint->HintTrack, sdpLine);\n\t}\n\t/*control for QTSS/DSS*/\n\tsprintf(sdpLine, \"a=control:trackID=%d\", gf_isom_get_track_id(tkHint->file, tkHint->HintTrack));\n\tgf_isom_sdp_add_track_line(tkHint->file, tkHint->HintTrack, sdpLine);\n\n\t/*H263 extensions*/\n\tif (tkHint->rtp_p->rtp_payt == GF_RTP_PAYT_H263) {\n\t\tsprintf(sdpLine, \"a=cliprect:0,0,%d,%d\", Height, Width);\n\t\tgf_isom_sdp_add_track_line(tkHint->file, tkHint->HintTrack, sdpLine);\n\t}\n\t/*AMR*/\n\telse if ((tkHint->rtp_p->rtp_payt == GF_RTP_PAYT_AMR) || (tkHint->rtp_p->rtp_payt == GF_RTP_PAYT_AMR_WB)) {\n\t\tsprintf(sdpLine, \"a=fmtp:%d octet-align=1\", tkHint->rtp_p->PayloadType);\n\t\tgf_isom_sdp_add_track_line(tkHint->file, tkHint->HintTrack, sdpLine);\n\t}\n\t/*Text*/\n\telse if (tkHint->rtp_p->rtp_payt == GF_RTP_PAYT_3GPP_TEXT) {\n\t\tu32 w, h, i, m_w, m_h;\n\t\ts32 tx, ty;\n\t\ts16 l;\n\n\t\tgf_isom_get_track_layout_info(tkHint->file, tkHint->TrackNum, &w, &h, &tx, &ty, &l);\n\t\tm_w = w;\n\t\tm_h = h;\n\t\tfor (i=0; i<gf_isom_get_track_count(tkHint->file); i++) {\n\t\t\tswitch (gf_isom_get_media_type(tkHint->file, i+1)) {\n\t\t\tcase GF_ISOM_MEDIA_SCENE:\n\t\t\tcase GF_ISOM_MEDIA_VISUAL:\n\t\t\tcase GF_ISOM_MEDIA_AUXV:\n\t\t\tcase GF_ISOM_MEDIA_PICT:\n\t\t\t\tgf_isom_get_track_layout_info(tkHint->file, i+1, &w, &h, &tx, &ty, &l);\n\t\t\t\tif (w>m_w) m_w = w;\n\t\t\t\tif (h>m_h) m_h = h;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tgf_media_format_ttxt_sdp(tkHint->rtp_p, payloadName, sdpLine, w, h, tx, ty, l, m_w, m_h, NULL);\n\n\t\tstrcat(sdpLine, \"; tx3g=\");\n\t\tfor (i=0; i<gf_isom_get_sample_description_count(tkHint->file, tkHint->TrackNum); i++) {\n\t\t\tu8 *tx3g;\n\t\t\tchar buffer[2000];\n\t\t\tu32 tx3g_len, len;\n\t\t\tgf_isom_text_get_encoded_tx3g(tkHint->file, tkHint->TrackNum, i+1, GF_RTP_TX3G_SIDX_OFFSET, &tx3g, &tx3g_len);\n\t\t\tlen = gf_base64_encode(tx3g, tx3g_len, buffer, 2000);\n\t\t\tgf_free(tx3g);\n\t\t\tbuffer[len] = 0;\n\t\t\tif (i) strcat(sdpLine, \", \");\n\t\t\tstrcat(sdpLine, buffer);\n\t\t}\n\t\tgf_isom_sdp_add_track_line(tkHint->file, tkHint->HintTrack, sdpLine);\n\t}\n\t/*EVRC/SMV in non header-free mode*/\n\telse if ((tkHint->rtp_p->rtp_payt == GF_RTP_PAYT_EVRC_SMV) && (tkHint->rtp_p->auh_size>1)) {\n\t\tsprintf(sdpLine, \"a=fmtp:%d maxptime=%d\", tkHint->rtp_p->PayloadType, tkHint->rtp_p->auh_size*20);\n\t\tgf_isom_sdp_add_track_line(tkHint->file, tkHint->HintTrack, sdpLine);\n\t}\n\t/*H264/AVC*/\n\telse if ((tkHint->rtp_p->rtp_payt == GF_RTP_PAYT_H264_AVC) || (tkHint->rtp_p->rtp_payt == GF_RTP_PAYT_H264_SVC))  {\n\t\tGF_AVCConfig *avcc = gf_isom_avc_config_get(tkHint->file, tkHint->TrackNum, 1);\n\t\tGF_AVCConfig *svcc = gf_isom_svc_config_get(tkHint->file, tkHint->TrackNum, 1);\n\t\t/*TODO - check syntax for SVC (might be some extra signaling)*/\n\n\t\tif (avcc) {\n\t\t\tsprintf(sdpLine, \"a=fmtp:%d profile-level-id=%02X%02X%02X; packetization-mode=1\", tkHint->rtp_p->PayloadType, avcc->AVCProfileIndication, avcc->profile_compatibility, avcc->AVCLevelIndication);\n\t\t} else {\n\t\t\tif (!svcc)\n\t\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t\tsprintf(sdpLine, \"a=fmtp:%d profile-level-id=%02X%02X%02X; packetization-mode=1\", tkHint->rtp_p->PayloadType, svcc->AVCProfileIndication, svcc->profile_compatibility, svcc->AVCLevelIndication);\n\t\t}\n\n\t\twrite_avc_config(sdpLine, avcc, svcc);\n\n\t\tgf_isom_sdp_add_track_line(tkHint->file, tkHint->HintTrack, sdpLine);\n\t\tgf_odf_avc_cfg_del(avcc);\n\t\tgf_odf_avc_cfg_del(svcc);\n\t}\n\t/*MPEG-4 decoder config*/\n\telse if (tkHint->rtp_p->rtp_payt==GF_RTP_PAYT_MPEG4) {\n\t\tesd = gf_isom_get_esd(tkHint->file, tkHint->TrackNum, 1);\n\n\t\tif (esd && esd->decoderConfig && esd->decoderConfig->decoderSpecificInfo && esd->decoderConfig->decoderSpecificInfo->data) {\n\t\t\tgf_rtp_builder_format_sdp(tkHint->rtp_p, payloadName, sdpLine, esd->decoderConfig->decoderSpecificInfo->data, esd->decoderConfig->decoderSpecificInfo->dataLength);\n\t\t} else {\n\t\t\tgf_rtp_builder_format_sdp(tkHint->rtp_p, payloadName, sdpLine, NULL, 0);\n\t\t}\n\t\tif (esd) gf_odf_desc_del((GF_Descriptor *)esd);\n\n\t\tif (tkHint->rtp_p->slMap.IV_length) {\n\t\t\tconst char *kms;\n\t\t\tgf_isom_get_ismacryp_info(tkHint->file, tkHint->TrackNum, 1, NULL, NULL, NULL, NULL, &kms, NULL, NULL, NULL);\n\t\t\tif (!strnicmp(kms, \"(key)\", 5) || !strnicmp(kms, \"(ipmp)\", 6) || !strnicmp(kms, \"(uri)\", 5)) {\n\t\t\t\tstrcat(sdpLine, \"; ISMACrypKey=\");\n\t\t\t} else {\n\t\t\t\tstrcat(sdpLine, \"; ISMACrypKey=(uri)\");\n\t\t\t}\n\t\t\tstrcat(sdpLine, kms);\n\t\t}\n\n\t\tgf_isom_sdp_add_track_line(tkHint->file, tkHint->HintTrack, sdpLine);\n\t}\n\t/*MPEG-4 Audio LATM*/\n\telse if (tkHint->rtp_p->rtp_payt==GF_RTP_PAYT_LATM) {\n\t\tGF_BitStream *bs;\n\t\tu8 *config_bytes;\n\t\tu32 config_size;\n\n\t\t/* form config string */\n\t\tbs = gf_bs_new(NULL, 32, GF_BITSTREAM_WRITE);\n\t\tgf_bs_write_int(bs, 0, 1); /* AudioMuxVersion */\n\t\tgf_bs_write_int(bs, 1, 1); /* all streams same time */\n\t\tgf_bs_write_int(bs, 0, 6); /* numSubFrames */\n\t\tgf_bs_write_int(bs, 0, 4); /* numPrograms */\n\t\tgf_bs_write_int(bs, 0, 3); /* numLayer */\n\n\t\t/* audio-specific config */\n\t\tesd = gf_isom_get_esd(tkHint->file, tkHint->TrackNum, 1);\n\t\tif (esd && esd->decoderConfig && esd->decoderConfig->decoderSpecificInfo) {\n\t\t\t/*PacketVideo patch: don't signal SBR and PS stuff, not allowed in LATM with audioMuxVersion=0*/\n\t\t\tgf_bs_write_data(bs, esd->decoderConfig->decoderSpecificInfo->data, MIN(esd->decoderConfig->decoderSpecificInfo->dataLength, 2) );\n\t\t}\n\t\tif (esd) gf_odf_desc_del((GF_Descriptor *)esd);\n\n\t\t/* other data */\n\t\tgf_bs_write_int(bs, 0, 3); /* frameLengthType */\n\t\tgf_bs_write_int(bs, 0xff, 8); /* latmBufferFullness */\n\t\tgf_bs_write_int(bs, 0, 1); /* otherDataPresent */\n\t\tgf_bs_write_int(bs, 0, 1); /* crcCheckPresent */\n\t\tgf_bs_get_content(bs, &config_bytes, &config_size);\n\t\tgf_bs_del(bs);\n\n\t\tgf_rtp_builder_format_sdp(tkHint->rtp_p, payloadName, sdpLine, config_bytes, config_size);\n\t\tgf_isom_sdp_add_track_line(tkHint->file, tkHint->HintTrack, sdpLine);\n\t\tgf_free(config_bytes);\n\t}\n#if GPAC_ENABLE_3GPP_DIMS_RTP\n\t/*3GPP DIMS*/\n\telse if (tkHint->rtp_p->rtp_payt==GF_RTP_PAYT_3GPP_DIMS) {\n\t\tGF_DIMSDescription dims;\n\t\tgf_isom_get_visual_info(tkHint->file, tkHint->TrackNum, 1, &Width, &Height);\n\n\t\tgf_isom_get_dims_description(tkHint->file, tkHint->TrackNum, 1, &dims);\n\t\tsprintf(sdpLine, \"a=fmtp:%d Version-profile=%d\", tkHint->rtp_p->PayloadType, dims.profile);\n\t\tif (! dims.fullRequestHost) {\n\t\t\tchar fmt[200];\n\t\t\tstrcat(sdpLine, \";useFullRequestHost=0\");\n\t\t\tsprintf(fmt, \";pathComponents=%d\", dims.pathComponents);\n\t\t\tstrcat(sdpLine, fmt);\n\t\t}\n\t\tif (!dims.streamType) strcat(sdpLine, \";stream-type=secondary\");\n\t\tif (dims.containsRedundant == 1) strcat(sdpLine, \";contains-redundant=main\");\n\t\telse if (dims.containsRedundant == 2) strcat(sdpLine, \";contains-redundant=redundant\");\n\n\t\tif (dims.textEncoding && strlen(dims.textEncoding)) {\n\t\t\tstrcat(sdpLine, \";text-encoding=\");\n\t\t\tstrcat(sdpLine, dims.textEncoding);\n\t\t}\n\t\tif (dims.contentEncoding && strlen(dims.contentEncoding)) {\n\t\t\tstrcat(sdpLine, \";content-coding=\");\n\t\t\tstrcat(sdpLine, dims.contentEncoding);\n\t\t}\n\t\tif (dims.contentEncoding && dims.content_script_types && strlen(dims.content_script_types) ) {\n\t\t\tstrcat(sdpLine, \";content-script-types=\");\n\t\t\tstrcat(sdpLine, dims.contentEncoding);\n\t\t}\n\t\tgf_isom_sdp_add_track_line(tkHint->file, tkHint->HintTrack, sdpLine);\n\t}\n#endif\n\t/*extensions for some mobile phones*/\n\tif (Width && Height) {\n\t\tsprintf(sdpLine, \"a=framesize:%d %d-%d\", tkHint->rtp_p->PayloadType, Width, Height);\n\t\tgf_isom_sdp_add_track_line(tkHint->file, tkHint->HintTrack, sdpLine);\n\t}\n\n\tesd = gf_isom_get_esd(tkHint->file, tkHint->TrackNum, 1);\n\tif (esd && esd->decoderConfig && (esd->decoderConfig->rvc_config || esd->decoderConfig->predefined_rvc_config)) {\n\t\tif (esd->decoderConfig->predefined_rvc_config) {\n\t\t\tsprintf(sdpLine, \"a=rvc-config-predef:%d\", esd->decoderConfig->predefined_rvc_config);\n\t\t} else {\n\t\t\t/*temporary ...*/\n\t\t\tif ((esd->decoderConfig->objectTypeIndication==GF_CODECID_AVC) || (esd->decoderConfig->objectTypeIndication==GF_CODECID_SVC)) {\n\t\t\t\tsprintf(sdpLine, \"a=rvc-config:%s\", \"http://download.tsi.telecom-paristech.fr/gpac/RVC/rvc_config_avc.xml\");\n\t\t\t} else {\n\t\t\t\tsprintf(sdpLine, \"a=rvc-config:%s\", \"http://download.tsi.telecom-paristech.fr/gpac/RVC/rvc_config_sp.xml\");\n\t\t\t}\n\t\t}\n\t\tgf_isom_sdp_add_track_line(tkHint->file, tkHint->HintTrack, sdpLine);\n\t}\n\tif (esd) gf_odf_desc_del((GF_Descriptor *)esd);\n\n\tgf_isom_set_track_enabled(tkHint->file, tkHint->HintTrack, GF_TRUE);\n\treturn GF_OK;\n}\n\nGF_EXPORT\nBool gf_hinter_can_embbed_data(u8 *data, u32 data_size, u32 streamType)\n{\n\tchar data64[5000];\n\tu32 size64;\n\n\tsize64 = gf_base64_encode(data, data_size, data64, 5000);\n\tif (!size64) return 0;\n\tswitch (streamType) {\n\tcase GF_STREAM_OD:\n\t\tsize64 += (u32) strlen(\"data:application/mpeg4-od-au;base64,\");\n\t\tbreak;\n\tcase GF_STREAM_SCENE:\n\t\tsize64 += (u32) strlen(\"data:application/mpeg4-bifs-au;base64,\");\n\t\tbreak;\n\tdefault:\n\t\t/*NOT NORMATIVE*/\n\t\tsize64 += (u32) strlen(\"data:application/mpeg4-es-au;base64,\");\n\t\tbreak;\n\t}\n\tif (size64>=255) return 0;\n\treturn 1;\n}\n\n\nGF_EXPORT\nGF_Err gf_hinter_finalize(GF_ISOFile *file, GF_SDP_IODProfile IOD_Profile, u32 bandwidth)\n{\n\tu32 i, sceneT, odT, descIndex, size, size64;\n\tGF_InitialObjectDescriptor *iod;\n\tGF_SLConfig slc;\n\tGF_ISOSample *samp;\n\tBool remove_ocr;\n\tu8 *buffer;\n\tchar buf64[5000], sdpLine[5100];\n\n\n\tgf_isom_sdp_clean(file);\n\n\tif (bandwidth) {\n\t\tsprintf(buf64, \"b=AS:%d\", bandwidth);\n\t\tgf_isom_sdp_add_line(file, buf64);\n\t}\n    //xtended attribute for copyright\n    if (gf_sys_is_test_mode()) {\n        sprintf(buf64, \"a=x-copyright: %s\", \"MP4/3GP File hinted with GPAC - (c) Telecom ParisTech (http://gpac.io)\");\n    } else {\n        sprintf(buf64, \"a=x-copyright: MP4/3GP File hinted with GPAC %s - %s\", gf_gpac_version(), gf_gpac_copyright() );\n    }\n\tgf_isom_sdp_add_line(file, buf64);\n\n\tif (IOD_Profile == GF_SDP_IOD_NONE) return GF_OK;\n\n\todT = sceneT = 0;\n\tfor (i=0; i<gf_isom_get_track_count(file); i++) {\n\t\tif (!gf_isom_is_track_in_root_od(file, i+1)) continue;\n\t\tswitch (gf_isom_get_media_type(file,i+1)) {\n\t\tcase GF_ISOM_MEDIA_OD:\n\t\t\todT = i+1;\n\t\t\tbreak;\n\t\tcase GF_ISOM_MEDIA_SCENE:\n\t\t\tsceneT = i+1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tremove_ocr = 0;\n\tif (IOD_Profile == GF_SDP_IOD_ISMA_STRICT) {\n\t\tIOD_Profile = GF_SDP_IOD_ISMA;\n\t\tremove_ocr = 1;\n\t}\n\n\t/*if we want ISMA like iods, we need at least BIFS */\n\tif ( (IOD_Profile == GF_SDP_IOD_ISMA) && !sceneT ) return GF_BAD_PARAM;\n\n\t/*do NOT change PLs, we assume they are correct*/\n\tiod = (GF_InitialObjectDescriptor *) gf_isom_get_root_od(file);\n\tif (!iod) return GF_NOT_SUPPORTED;\n\n\t/*rewrite an IOD with good SL config - embbed data if possible*/\n\tif (IOD_Profile == GF_SDP_IOD_ISMA) {\n\t\tGF_ESD *esd;\n\t\tBool is_ok = 1;\n\t\twhile (gf_list_count(iod->ESDescriptors)) {\n\t\t\tesd = (GF_ESD*)gf_list_get(iod->ESDescriptors, 0);\n\t\t\tgf_odf_desc_del((GF_Descriptor *) esd);\n\t\t\tgf_list_rem(iod->ESDescriptors, 0);\n\t\t}\n\n\n\t\t/*get OD esd, and embbed stream data if possible*/\n\t\tif (odT) {\n\t\t\tesd = gf_isom_get_esd(file, odT, 1);\n\t\t\tif (gf_isom_get_sample_count(file, odT)==1) {\n\t\t\t\tsamp = gf_isom_get_sample(file, odT, 1, &descIndex);\n\t\t\t\tif (gf_hinter_can_embbed_data(samp->data, samp->dataLength, GF_STREAM_OD)) {\n\t\t\t\t\tInitSL_NULL(&slc);\n\t\t\t\t\tslc.predefined = 0;\n\t\t\t\t\tslc.hasRandomAccessUnitsOnlyFlag = 1;\n\t\t\t\t\tslc.timeScale = slc.timestampResolution = gf_isom_get_media_timescale(file, odT);\n\t\t\t\t\tslc.OCRResolution = 1000;\n\t\t\t\t\tslc.startCTS = samp->DTS+samp->CTS_Offset;\n\t\t\t\t\tslc.startDTS = samp->DTS;\n\t\t\t\t\t//set the SL for future extraction\n\t\t\t\t\tgf_isom_set_extraction_slc(file, odT, 1, &slc);\n\n\t\t\t\t\tsize64 = gf_base64_encode(samp->data, samp->dataLength, buf64, 2000);\n\t\t\t\t\tbuf64[size64] = 0;\n\t\t\t\t\tsprintf(sdpLine, \"data:application/mpeg4-od-au;base64,%s\", buf64);\n\n\t\t\t\t\tesd->decoderConfig->avgBitrate = 0;\n\t\t\t\t\tesd->decoderConfig->bufferSizeDB = samp->dataLength;\n\t\t\t\t\tesd->decoderConfig->maxBitrate = 0;\n\t\t\t\t\tsize64 = (u32) strlen(sdpLine)+1;\n\t\t\t\t\tesd->URLString = (char*)gf_malloc(sizeof(char) * size64);\n\t\t\t\t\tstrcpy(esd->URLString, sdpLine);\n\t\t\t\t} else {\n\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_RTP, (\"[rtp hinter] OD sample too large to be embedded in IOD - ISMA disabled\\n\"));\n\t\t\t\t\tis_ok = 0;\n\t\t\t\t}\n\t\t\t\tgf_isom_sample_del(&samp);\n\t\t\t}\n\t\t\tif (remove_ocr) esd->OCRESID = 0;\n\t\t\telse if (esd->OCRESID == esd->ESID) esd->OCRESID = 0;\n\n\t\t\t//OK, add this to our IOD\n\t\t\tgf_list_add(iod->ESDescriptors, esd);\n\t\t}\n\n\t\tesd = gf_isom_get_esd(file, sceneT, 1);\n\t\tif (gf_isom_get_sample_count(file, sceneT)==1) {\n\t\t\tsamp = gf_isom_get_sample(file, sceneT, 1, &descIndex);\n\t\t\tif (gf_hinter_can_embbed_data(samp->data, samp->dataLength, GF_STREAM_SCENE)) {\n\n\t\t\t\tslc.timeScale = slc.timestampResolution = gf_isom_get_media_timescale(file, sceneT);\n\t\t\t\tslc.OCRResolution = 1000;\n\t\t\t\tslc.startCTS = samp->DTS+samp->CTS_Offset;\n\t\t\t\tslc.startDTS = samp->DTS;\n\t\t\t\t//set the SL for future extraction\n\t\t\t\tgf_isom_set_extraction_slc(file, sceneT, 1, &slc);\n\t\t\t\t//encode in Base64 the sample\n\t\t\t\tsize64 = gf_base64_encode(samp->data, samp->dataLength, buf64, 2000);\n\t\t\t\tbuf64[size64] = 0;\n\t\t\t\tsprintf(sdpLine, \"data:application/mpeg4-bifs-au;base64,%s\", buf64);\n\n\t\t\t\tesd->decoderConfig->avgBitrate = 0;\n\t\t\t\tesd->decoderConfig->bufferSizeDB = samp->dataLength;\n\t\t\t\tesd->decoderConfig->maxBitrate = 0;\n\t\t\t\tesd->URLString = (char*)gf_malloc(sizeof(char) * (strlen(sdpLine)+1));\n\t\t\t\tstrcpy(esd->URLString, sdpLine);\n\t\t\t} else {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_RTP, (\"[rtp hinter] Scene description sample too large to be embedded in IOD - ISMA disabled\\n\"));\n\t\t\t\tis_ok = 0;\n\t\t\t}\n\t\t\tgf_isom_sample_del(&samp);\n\t\t}\n\t\tif (remove_ocr) esd->OCRESID = 0;\n\t\telse if (esd->OCRESID == esd->ESID) esd->OCRESID = 0;\n\n\t\tgf_list_add(iod->ESDescriptors, esd);\n\n\t\tif (is_ok) {\n\t\t\tu32 has_a, has_v, has_i_a, has_i_v;\n\t\t\thas_a = has_v = has_i_a = has_i_v = 0;\n\t\t\tfor (i=0; i<gf_isom_get_track_count(file); i++) {\n\t\t\t\tesd = gf_isom_get_esd(file, i+1, 1);\n\t\t\t\tif (!esd) continue;\n\t\t\t\tif (esd->decoderConfig->streamType==GF_STREAM_VISUAL) {\n\t\t\t\t\tif (esd->decoderConfig->objectTypeIndication==GF_CODECID_MPEG4_PART2) has_i_v ++;\n\t\t\t\t\telse has_v++;\n\t\t\t\t} else if (esd->decoderConfig->streamType==GF_STREAM_AUDIO) {\n\t\t\t\t\tif (esd->decoderConfig->objectTypeIndication==GF_CODECID_AAC_MPEG4) has_i_a ++;\n\t\t\t\t\telse has_a++;\n\t\t\t\t}\n\t\t\t\tgf_odf_desc_del((GF_Descriptor *)esd);\n\t\t\t}\n\t\t\t/*only 1 MPEG-4 visual max and 1 MPEG-4 audio max for ISMA compliancy*/\n\t\t\tif (!has_v && !has_a && (has_i_v<=1) && (has_i_a<=1)) {\n\t\t\t\tsprintf(sdpLine, \"a=isma-compliance:1,1.0,1\");\n\t\t\t\tgf_isom_sdp_add_line(file, sdpLine);\n\t\t\t}\n\t\t}\n\t}\n\n\t//encode the IOD\n\tbuffer = NULL;\n\tsize = 0;\n\tgf_odf_desc_write((GF_Descriptor *) iod, &buffer, &size);\n\tgf_odf_desc_del((GF_Descriptor *)iod);\n\n\t//encode in Base64 the iod\n\tsize64 = gf_base64_encode(buffer, size, buf64, 2000);\n\tbuf64[size64] = 0;\n\tgf_free(buffer);\n\n\tsprintf(sdpLine, \"a=mpeg4-iod:\\\"data:application/mpeg4-iod;base64,%s\\\"\", buf64);\n\tgf_isom_sdp_add_line(file, sdpLine);\n\n\treturn GF_OK;\n}\n\n\n#endif /*GPAC_DISABLE_ISOM_HINTING*/\n\n#endif /*GPAC_DISABLE_ISOM*/\n"], "filenames": ["src/isomedia/isom_read.c", "src/isomedia/isom_write.c", "src/media_tools/isom_hinter.c"], "buggy_code_start_loc": [3905, 5354, 643], "buggy_code_end_loc": [3905, 5374, 644], "fixing_code_start_loc": [3906, 5355, 643], "fixing_code_end_loc": [3907, 5381, 648], "type": "CWE-476", "message": "The gf_isom_set_extraction_slc function in GPAC 1.0.1 allows attackers to cause a denial of service (NULL pointer dereference) via a crafted file in the MP4Box command.", "other": {"cve": {"id": "CVE-2021-31258", "sourceIdentifier": "cve@mitre.org", "published": "2021-04-19T19:15:18.327", "lastModified": "2021-04-21T19:23:31.363", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The gf_isom_set_extraction_slc function in GPAC 1.0.1 allows attackers to cause a denial of service (NULL pointer dereference) via a crafted file in the MP4Box command."}, {"lang": "es", "value": "La funci\u00f3n gf_isom_set_extraction_slc en GPAC versi\u00f3n 1.0.1, permite a atacantes causar una denegaci\u00f3n de servicio (desreferencia del puntero NULL) por medio de un archivo dise\u00f1ado en el comando MP4Box"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-476"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:gpac:gpac:1.0.1:*:*:*:*:*:*:*", "matchCriteriaId": "82DD2D40-0A05-48FD-940D-32B4D8B51AB3"}]}]}], "references": [{"url": "https://github.com/gpac/gpac/commit/ebfa346eff05049718f7b80041093b4c5581c24e", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/gpac/gpac/issues/1706", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/gpac/gpac/commit/ebfa346eff05049718f7b80041093b4c5581c24e"}}