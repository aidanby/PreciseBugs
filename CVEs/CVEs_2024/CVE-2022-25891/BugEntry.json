{"buggy_code": ["package discord\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"github.com/containrrr/shoutrrr/pkg/format\"\n\t\"github.com/containrrr/shoutrrr/pkg/services/standard\"\n\t\"github.com/containrrr/shoutrrr/pkg/types\"\n\t\"github.com/containrrr/shoutrrr/pkg/util\"\n\t\"net/http\"\n\t\"net/url\"\n)\n\n// Service providing Discord as a notification service\ntype Service struct {\n\tstandard.Standard\n\tconfig *Config\n\tpkr    format.PropKeyResolver\n}\n\nvar limits = types.MessageLimit{\n\tChunkSize:      2000,\n\tTotalChunkSize: 6000,\n\tChunkCount:     10,\n}\n\nconst (\n\thookURL = \"https://discord.com/api/webhooks\"\n\t// Only search this many runes for a good split position\n\tmaxSearchRunes = 100\n)\n\n// Send a notification message to discord\nfunc (service *Service) Send(message string, params *types.Params) error {\n\n\tif service.config.JSON {\n\t\tpostURL := CreateAPIURLFromConfig(service.config)\n\t\treturn doSend([]byte(message), postURL)\n\t}\n\n\titems, omitted := CreateItemsFromPlain(message, service.config.SplitLines)\n\treturn service.sendItems(items, params, omitted)\n}\n\n// SendItems sends items with additional meta data and richer appearance\nfunc (service *Service) SendItems(items []types.MessageItem, params *types.Params) error {\n\treturn service.sendItems(items, params, 0)\n}\n\nfunc (service *Service) sendItems(items []types.MessageItem, params *types.Params, omitted int) error {\n\tvar err error\n\n\tconfig := *service.config\n\tif err = service.pkr.UpdateConfigFromParams(&config, params); err != nil {\n\t\treturn err\n\t}\n\n\tvar payload WebhookPayload\n\tpayload, err = CreatePayloadFromItems(items, config.Title, config.LevelColors(), omitted)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tpayload.Username = config.Username\n\tpayload.AvatarURL = config.Avatar\n\n\tvar payloadBytes []byte\n\tpayloadBytes, err = json.Marshal(payload)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tpostURL := CreateAPIURLFromConfig(&config)\n\treturn doSend(payloadBytes, postURL)\n}\n\n// CreateItemsFromPlain creates a set of MessageItems that is compatible with Discords webhook payload\nfunc CreateItemsFromPlain(plain string, splitLines bool) (items []types.MessageItem, omitted int) {\n\tif splitLines {\n\t\treturn util.MessageItemsFromLines(plain, limits)\n\t}\n\n\treturn util.PartitionMessage(plain, limits, maxSearchRunes)\n}\n\n// Initialize loads ServiceConfig from configURL and sets logger for this Service\nfunc (service *Service) Initialize(configURL *url.URL, logger types.StdLogger) error {\n\tservice.Logger.SetLogger(logger)\n\tservice.config = &Config{}\n\tservice.pkr = format.NewPropKeyResolver(service.config)\n\n\tif err := service.pkr.SetDefaultProps(service.config); err != nil {\n\t\treturn err\n\t}\n\n\tif err := service.config.SetURL(configURL); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\n// CreateAPIURLFromConfig takes a discord config object and creates a post url\nfunc CreateAPIURLFromConfig(config *Config) string {\n\treturn fmt.Sprintf(\n\t\t\"%s/%s/%s\",\n\t\thookURL,\n\t\tconfig.WebhookID,\n\t\tconfig.Token)\n}\n\nfunc doSend(payload []byte, postURL string) error {\n\tres, err := http.Post(postURL, \"application/json\", bytes.NewBuffer(payload))\n\n\tif res == nil && err == nil {\n\t\terr = fmt.Errorf(\"unknown error\")\n\t}\n\n\tif err == nil && res.StatusCode != http.StatusNoContent {\n\t\terr = fmt.Errorf(\"response status code %s\", res.Status)\n\t}\n\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to send discord notification: %v\", err)\n\t}\n\n\treturn nil\n}\n", "package discord\n\nimport (\n\t\"fmt\"\n\t\"github.com/containrrr/shoutrrr/pkg/types\"\n\t\"github.com/containrrr/shoutrrr/pkg/util\"\n\t\"time\"\n)\n\n// WebhookPayload is the webhook endpoint payload\ntype WebhookPayload struct {\n\tEmbeds   []embedItem `json:\"embeds\"`\n\tUsername string      `json:\"username,omitempty\"`\n\tAvatarURL string     `json:\"avatar_url,omitempty\"`\n}\n\n// JSON is the actual notification payload\ntype embedItem struct {\n\tTitle     string       `json:\"title,omitempty\"`\n\tContent   string       `json:\"description,omitempty\"`\n\tURL       string       `json:\"url,omitempty\"`\n\tTimestamp string       `json:\"timestamp,omitempty\"`\n\tColor     uint         `json:\"color,omitempty\"`\n\tFooter    *embedFooter `json:\"footer,omitempty\"`\n}\n\ntype embedFooter struct {\n\tText    string `json:\"text\"`\n\tIconURL string `json:\"icon_url,omitempty\"`\n}\n\n// CreatePayloadFromItems creates a JSON payload to be sent to the discord webhook API\nfunc CreatePayloadFromItems(items []types.MessageItem, title string, colors [types.MessageLevelCount]uint, omitted int) (WebhookPayload, error) {\n\n\tmetaCount := 1\n\tif omitted < 1 && len(title) < 1 {\n\t\tmetaCount = 0\n\t}\n\titemCount := util.Min(9, len(items))\n\n\tembeds := make([]embedItem, metaCount, itemCount+metaCount)\n\n\tfor _, item := range items {\n\n\t\tcolor := uint(0)\n\t\tif item.Level >= types.Unknown && int(item.Level) < len(colors) {\n\t\t\tcolor = colors[item.Level]\n\t\t}\n\n\t\tei := embedItem{\n\t\t\tContent: item.Text,\n\t\t\tColor:   color,\n\t\t}\n\n\t\tif item.Level != types.Unknown {\n\t\t\tei.Footer = &embedFooter{\n\t\t\t\tText: item.Level.String(),\n\t\t\t}\n\t\t}\n\n\t\tif !item.Timestamp.IsZero() {\n\t\t\tei.Timestamp = item.Timestamp.UTC().Format(time.RFC3339)\n\t\t}\n\n\t\tembeds = append(embeds, ei)\n\t}\n\n\tembeds[0].Title = title\n\tif omitted > 0 {\n\t\tembeds[0].Footer = &embedFooter{\n\t\t\tText: fmt.Sprintf(\"... (%v character(s) where omitted)\", omitted),\n\t\t}\n\t}\n\n\treturn WebhookPayload{\n\t\tEmbeds: embeds,\n\t}, nil\n}\n", "package discord_test\n\nimport (\n\t\"log\"\n\t\"time\"\n\n\t\"github.com/containrrr/shoutrrr/internal/testutils\"\n\t. \"github.com/containrrr/shoutrrr/pkg/services/discord\"\n\t\"github.com/containrrr/shoutrrr/pkg/types\"\n\t\"github.com/jarcoal/httpmock\"\n\n\t\"net/url\"\n\t\"os\"\n\t\"strings\"\n\t\"testing\"\n\n\t. \"github.com/onsi/ginkgo\"\n\t. \"github.com/onsi/gomega\"\n)\n\nfunc TestDiscord(t *testing.T) {\n\tRegisterFailHandler(Fail)\n\tRunSpecs(t, \"Shoutrrr Discord Suite\")\n}\n\nvar (\n\tdummyColors   = [types.MessageLevelCount]uint{}\n\tservice       *Service\n\tenvDiscordURL *url.URL\n\tlogger        *log.Logger\n)\n\nvar _ = Describe(\"the discord service\", func() {\n\tBeforeSuite(func() {\n\t\tservice = &Service{}\n\t\tenvDiscordURL, _ = url.Parse(os.Getenv(\"SHOUTRRR_DISCORD_URL\"))\n\t\tlogger = log.New(GinkgoWriter, \"Test\", log.LstdFlags)\n\t})\n\tWhen(\"running integration tests\", func() {\n\t\tIt(\"should work without errors\", func() {\n\t\t\tif envDiscordURL.String() == \"\" {\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tserviceURL, _ := url.Parse(envDiscordURL.String())\n\t\t\terr := service.Initialize(serviceURL, testutils.TestLogger())\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\terr = service.Send(\n\t\t\t\t\"this is an integration test\",\n\t\t\t\tnil,\n\t\t\t)\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t})\n\t})\n\tDescribe(\"the service\", func() {\n\t\tIt(\"should implement Service interface\", func() {\n\t\t\tvar impl types.Service = service\n\t\t\tExpect(impl).ToNot(BeNil())\n\t\t})\n\t})\n\tDescribe(\"creating a config\", func() {\n\t\tWhen(\"given an url and a message\", func() {\n\t\t\tIt(\"should return an error if no arguments where supplied\", func() {\n\t\t\t\tserviceURL, _ := url.Parse(\"discord://\")\n\t\t\t\terr := service.Initialize(serviceURL, nil)\n\t\t\t\tExpect(err).To(HaveOccurred())\n\t\t\t})\n\t\t\tIt(\"should not return an error if exactly two arguments are given\", func() {\n\t\t\t\tserviceURL, _ := url.Parse(\"discord://dummyToken@dummyChannel\")\n\t\t\t\terr := service.Initialize(serviceURL, nil)\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t})\n\t\t\tIt(\"should not return an error when given the raw path parameter\", func() {\n\t\t\t\tserviceURL, _ := url.Parse(\"discord://dummyToken@dummyChannel/raw\")\n\t\t\t\terr := service.Initialize(serviceURL, nil)\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t})\n\t\t\tIt(\"should set the JSON flag when given the raw path parameter\", func() {\n\t\t\t\tserviceURL, _ := url.Parse(\"discord://dummyToken@dummyChannel/raw\")\n\t\t\t\tconfig := Config{}\n\t\t\t\terr := config.SetURL(serviceURL)\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(config.JSON).To(BeTrue())\n\t\t\t})\n\t\t\tIt(\"should not set the JSON flag when not provided raw path parameter\", func() {\n\t\t\t\tserviceURL, _ := url.Parse(\"discord://dummyToken@dummyChannel\")\n\t\t\t\tconfig := Config{}\n\t\t\t\terr := config.SetURL(serviceURL)\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(config.JSON).NotTo(BeTrue())\n\t\t\t})\n\t\t\tIt(\"should return an error if more than two arguments are given\", func() {\n\t\t\t\tserviceURL, _ := url.Parse(\"discord://dummyToken@dummyChannel/illegal-argument\")\n\t\t\t\terr := service.Initialize(serviceURL, nil)\n\t\t\t\tExpect(err).To(HaveOccurred())\n\t\t\t})\n\t\t})\n\t\tWhen(\"parsing the configuration URL\", func() {\n\t\t\tIt(\"should be identical after de-/serialization\", func() {\n\t\t\t\ttestURL := \"discord://token@channel?avatar=TestBot.jpg&color=0x112233&colordebug=0x223344&colorerror=0x334455&colorinfo=0x445566&colorwarn=0x556677&splitlines=No&title=Test+Title&username=TestBot\"\n\n\t\t\t\turl, err := url.Parse(testURL)\n\t\t\t\tExpect(err).NotTo(HaveOccurred(), \"parsing\")\n\n\t\t\t\tconfig := &Config{}\n\t\t\t\terr = config.SetURL(url)\n\t\t\t\tExpect(err).NotTo(HaveOccurred(), \"verifying\")\n\n\t\t\t\toutputURL := config.GetURL()\n\n\t\t\t\tExpect(outputURL.String()).To(Equal(testURL))\n\n\t\t\t})\n\t\t})\n\t})\n\tDescribe(\"creating a json payload\", func() {\n\t\t//When(\"given a blank message\", func() {\n\t\t//\tIt(\"should return an error\", func() {\n\t\t//\t\t_, err := CreatePayloadFromItems(\"\", false)\n\t\t//\t\tExpect(err).To(HaveOccurred())\n\t\t//\t})\n\t\t//})\n\t\tWhen(\"given a message that exceeds the max length\", func() {\n\t\t\tIt(\"should return a payload with chunked messages\", func() {\n\n\t\t\t\tpayload, err := buildPayloadFromHundreds(42, false, \"Title\", dummyColors)\n\t\t\t\tExpect(err).ToNot(HaveOccurred())\n\n\t\t\t\tmeta := payload.Embeds[0]\n\t\t\t\titems := payload.Embeds[1:]\n\n\t\t\t\tExpect(items).To(HaveLen(3))\n\n\t\t\t\tExpect(items[0].Content).To(HaveLen(1994))\n\t\t\t\tExpect(items[1].Content).To(HaveLen(1999))\n\t\t\t\tExpect(items[2].Content).To(HaveLen(205))\n\n\t\t\t\tExpect(meta.Footer).To(BeNil())\n\t\t\t})\n\t\t\tIt(\"omit characters above total max\", func() {\n\n\t\t\t\tpayload, err := buildPayloadFromHundreds(62, false, \"\", dummyColors)\n\t\t\t\tExpect(err).ToNot(HaveOccurred())\n\n\t\t\t\tmeta := payload.Embeds[0]\n\t\t\t\titems := payload.Embeds[1:]\n\n\t\t\t\tExpect(items).To(HaveLen(4))\n\t\t\t\tExpect(items[0].Content).To(HaveLen(1994))\n\t\t\t\tExpect(items[1].Content).To(HaveLen(1999))\n\t\t\t\tExpect(len(items[2].Content)).To(Equal(1999))\n\t\t\t\tExpect(len(items[3].Content)).To(Equal(5))\n\n\t\t\t\tExpect(meta.Footer.Text).To(ContainSubstring(\"200\"))\n\t\t\t})\n\t\t\tWhen(\"no title is supplied and content fits\", func() {\n\t\t\t\tIt(\"should return a payload without a meta chunk\", func() {\n\n\t\t\t\t\tpayload, err := buildPayloadFromHundreds(42, false, \"\", dummyColors)\n\t\t\t\t\tExpect(err).ToNot(HaveOccurred())\n\t\t\t\t\tExpect(payload.Embeds[0].Footer).To(BeNil())\n\t\t\t\t\tExpect(payload.Embeds[0].Title).To(BeEmpty())\n\t\t\t\t})\n\t\t\t})\n\t\t\tWhen(\"no title is supplied but content was omitted\", func() {\n\t\t\t\tIt(\"should return a payload with a meta chunk\", func() {\n\n\t\t\t\t\tpayload, err := buildPayloadFromHundreds(62, false, \"\", dummyColors)\n\t\t\t\t\tExpect(err).ToNot(HaveOccurred())\n\t\t\t\t\tExpect(payload.Embeds[0].Footer).ToNot(BeNil())\n\t\t\t\t})\n\t\t\t})\n\t\t\tWhen(\"title is supplied, but content fits\", func() {\n\t\t\t\tIt(\"should return a payload with a meta chunk\", func() {\n\t\t\t\t\tpayload, err := buildPayloadFromHundreds(42, false, \"Title\", dummyColors)\n\t\t\t\t\tExpect(err).ToNot(HaveOccurred())\n\t\t\t\t\tExpect(payload.Embeds[0].Title).ToNot(BeEmpty())\n\t\t\t\t})\n\t\t\t})\n\n\t\t\tIt(\"rich test 1\", func() {\n\n\t\t\t\ttestTime, _ := time.Parse(time.RFC3339, time.RFC3339)\n\t\t\t\titems := []types.MessageItem{\n\t\t\t\t\t{\n\t\t\t\t\t\tText:      \"Message\",\n\t\t\t\t\t\tTimestamp: testTime,\n\t\t\t\t\t\tLevel:     types.Warning,\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t\tpayload, err := CreatePayloadFromItems(items, \"Title\", dummyColors, 0)\n\t\t\t\tExpect(err).ToNot(HaveOccurred())\n\n\t\t\t\tmeta := payload.Embeds[0]\n\t\t\t\titem := payload.Embeds[1]\n\n\t\t\t\tExpect(payload.Embeds).To(HaveLen(2))\n\t\t\t\tExpect(item.Footer.Text).To(Equal(types.Warning.String()))\n\t\t\t\tExpect(meta.Title).To(Equal(\"Title\"))\n\t\t\t\tExpect(item.Color).To(Equal(dummyColors[types.Warning]))\n\t\t\t})\n\t\t})\n\t})\n\n\tDescribe(\"sending the payload\", func() {\n\t\tvar err error\n\t\tBeforeEach(func() {\n\t\t\thttpmock.Activate()\n\t\t})\n\t\tAfterEach(func() {\n\t\t\thttpmock.DeactivateAndReset()\n\t\t})\n\t\tIt(\"should not report an error if the server accepts the payload\", func() {\n\t\t\tconfig := Config{\n\t\t\t\tWebhookID: \"1\",\n\t\t\t\tToken:     \"dummyToken\",\n\t\t\t}\n\t\t\tserviceURL := config.GetURL()\n\t\t\tservice := Service{}\n\t\t\terr = service.Initialize(serviceURL, logger)\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\tsetupResponder(&config, 204, \"\")\n\n\t\t\terr = service.Send(\"Message\", nil)\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t})\n\n\t})\n})\n\nfunc buildPayloadFromHundreds(hundreds int, split bool, title string, colors [types.MessageLevelCount]uint) (WebhookPayload, error) {\n\thundredChars := \"this string is exactly (to the letter) a hundred characters long which will make the send func error\"\n\tbuilder := strings.Builder{}\n\n\tfor i := 0; i < hundreds; i++ {\n\t\tbuilder.WriteString(hundredChars)\n\t}\n\n\titems, omitted := CreateItemsFromPlain(builder.String(), split)\n\tprintln(\"Items:\", len(items), \"Omitted:\", omitted)\n\n\treturn CreatePayloadFromItems(items, title, colors, omitted)\n}\n\nfunc setupResponder(config *Config, code int, body string) {\n\ttargetURL := CreateAPIURLFromConfig(config)\n\thttpmock.RegisterResponder(\"POST\", targetURL, httpmock.NewStringResponder(code, body))\n}\n", "package util\n\nimport (\n\tt \"github.com/containrrr/shoutrrr/pkg/types\"\n\n\t\"strings\"\n)\n\nconst ellipsis = \" [...]\"\n\n// PartitionMessage splits a string into chunks that is at most chunkSize runes, it will search the last distance runes\n// for a whitespace to make the split appear nicer. It will keep adding chunks until it reaches maxCount chunks, or if\n// the total amount of runes in the chunks reach maxTotal.\n// The chunks are returned together with the number of omitted runes (that did not fit into the chunks)\nfunc PartitionMessage(input string, limits t.MessageLimit, distance int) (items []t.MessageItem, omitted int) {\n\trunes := []rune(input)\n\tchunkOffset := 0\n\tmaxTotal := Min(len(runes), limits.TotalChunkSize)\n\tmaxCount := limits.ChunkCount - 1\n\n\tfor i := 0; i < maxCount; i++ {\n\t\t// If no suitable split point is found, use the chunkSize\n\t\tchunkEnd := chunkOffset + limits.ChunkSize\n\t\t// ... and start next chunk directly after this one\n\t\tnextChunkStart := chunkEnd\n\t\tif chunkEnd > maxTotal {\n\t\t\t// The chunk is smaller than the limit, no need to search\n\t\t\tchunkEnd = maxTotal\n\t\t\tnextChunkStart = maxTotal\n\t\t} else {\n\t\t\tfor r := 0; r < distance; r++ {\n\t\t\t\trp := chunkEnd - r\n\t\t\t\tif runes[rp] == '\\n' || runes[rp] == ' ' {\n\t\t\t\t\t// Suitable split point found\n\t\t\t\t\tchunkEnd = rp\n\t\t\t\t\t// Since the split is on a whitespace, skip it in the next chunk\n\t\t\t\t\tnextChunkStart = chunkEnd + 1\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\titems = append(items, t.MessageItem{\n\t\t\tText: string(runes[chunkOffset:chunkEnd]),\n\t\t})\n\n\t\tchunkOffset = nextChunkStart\n\t\tif chunkOffset >= maxTotal {\n\t\t\tbreak\n\t\t}\n\t}\n\n\treturn items, len(runes) - chunkOffset\n}\n\n// MessageItemsFromLines creates a set of MessageItems that is compatible with the supplied limits\nfunc MessageItemsFromLines(plain string, limits t.MessageLimit) (items []t.MessageItem, omitted int) {\n\tomitted = 0\n\tmaxCount := limits.ChunkCount - 1\n\n\tlines := strings.Split(plain, \"\\n\")\n\titems = make([]t.MessageItem, 0, Min(maxCount, len(lines)))\n\n\ttotalLength := 0\n\tfor l, line := range lines {\n\t\tif l < maxCount && totalLength < limits.TotalChunkSize {\n\t\t\trunes := []rune(line)\n\t\t\tmaxLen := limits.ChunkSize\n\t\t\tif totalLength+maxLen > limits.TotalChunkSize {\n\t\t\t\tmaxLen = limits.TotalChunkSize - totalLength\n\t\t\t}\n\t\t\tif len(runes) > maxLen {\n\t\t\t\t// Trim and add ellipsis\n\t\t\t\trunes = runes[:maxLen-len(ellipsis)]\n\t\t\t\tline = string(runes) + ellipsis\n\t\t\t}\n\n\t\t\tif len(runes) < 1 {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\titems = append(items, t.MessageItem{\n\t\t\t\tText: line,\n\t\t\t})\n\n\t\t\ttotalLength += len(runes)\n\n\t\t} else {\n\t\t\tomitted += len(line)\n\t\t}\n\t}\n\n\treturn items, omitted\n}\n", "package util\n\nimport (\n\t\"github.com/containrrr/shoutrrr/pkg/types\"\n\t. \"github.com/onsi/ginkgo\"\n\t. \"github.com/onsi/gomega\"\n\t\"strings\"\n)\n\nvar _ = Describe(\"Partition Message\", func() {\n\tDescribe(\"creating a json payload\", func() {\n\t\tlimits := types.MessageLimit{\n\t\t\tChunkSize:      2000,\n\t\t\tTotalChunkSize: 6000,\n\t\t\tChunkCount:     10,\n\t\t}\n\t\tWhen(\"given a message that exceeds the max length\", func() {\n\t\t\tWhen(\"not splitting by lines\", func() {\n\t\t\t\tIt(\"should return a payload with chunked messages\", func() {\n\n\t\t\t\t\titems, _ := testPartitionMessage(42, limits, 100)\n\n\t\t\t\t\tExpect(len(items[0].Text)).To(Equal(1994))\n\t\t\t\t\tExpect(len(items[1].Text)).To(Equal(1999))\n\t\t\t\t\tExpect(len(items[2].Text)).To(Equal(205))\n\t\t\t\t})\n\t\t\t\tIt(\"omit characters above total max\", func() {\n\t\t\t\t\titems, _ := testPartitionMessage(62, limits, 100)\n\n\t\t\t\t\tExpect(len(items[0].Text)).To(Equal(1994))\n\t\t\t\t\tExpect(len(items[1].Text)).To(Equal(1999))\n\t\t\t\t\tExpect(len(items[2].Text)).To(Equal(1999))\n\t\t\t\t\tExpect(len(items[3].Text)).To(Equal(5))\n\t\t\t\t})\n\t\t\t})\n\t\t\tWhen(\"splitting by lines\", func() {\n\t\t\t\tIt(\"should return a payload with chunked messages\", func() {\n\t\t\t\t\titems, omitted := testMessageItemsFromLines(18, limits, 2)\n\n\t\t\t\t\tExpect(len(items[0].Text)).To(Equal(200))\n\t\t\t\t\tExpect(len(items[8].Text)).To(Equal(200))\n\n\t\t\t\t\tExpect(omitted).To(Equal(0))\n\t\t\t\t})\n\t\t\t\tIt(\"omit characters above total max\", func() {\n\t\t\t\t\titems, omitted := testMessageItemsFromLines(19, limits, 2)\n\n\t\t\t\t\tExpect(len(items[0].Text)).To(Equal(200))\n\t\t\t\t\tExpect(len(items[8].Text)).To(Equal(200))\n\n\t\t\t\t\tExpect(omitted).To(Equal(100))\n\t\t\t\t})\n\t\t\t\tIt(\"should trim characters above chunk size\", func() {\n\t\t\t\t\thundreds := 42\n\t\t\t\t\trepeat := 21\n\t\t\t\t\titems, omitted := testMessageItemsFromLines(hundreds, limits, repeat)\n\n\t\t\t\t\tExpect(len(items[0].Text)).To(Equal(limits.ChunkSize))\n\t\t\t\t\tExpect(len(items[1].Text)).To(Equal(limits.ChunkSize))\n\n\t\t\t\t\t// Trimmed characters do not count towards the total omitted count\n\t\t\t\t\tExpect(omitted).To(Equal(0))\n\t\t\t\t})\n\n\t\t\t\tIt(\"omit characters above total chunk size\", func() {\n\t\t\t\t\thundreds := 100\n\t\t\t\t\trepeat := 20\n\t\t\t\t\titems, omitted := testMessageItemsFromLines(hundreds, limits, repeat)\n\n\t\t\t\t\tExpect(len(items[0].Text)).To(Equal(limits.ChunkSize))\n\t\t\t\t\tExpect(len(items[1].Text)).To(Equal(limits.ChunkSize))\n\t\t\t\t\tExpect(len(items[2].Text)).To(Equal(limits.ChunkSize))\n\n\t\t\t\t\tmaxRunes := hundreds * 100\n\t\t\t\t\texpectedOmitted := maxRunes - limits.TotalChunkSize\n\n\t\t\t\t\tExpect(omitted).To(Equal(expectedOmitted))\n\t\t\t\t})\n\n\t\t\t})\n\n\t\t})\n\t})\n})\n\nconst hundredChars = \"this string is exactly (to the letter) a hundred characters long which will make the send func error\"\n\nfunc testMessageItemsFromLines(hundreds int, limits types.MessageLimit, repeat int) (items []types.MessageItem, omitted int) {\n\n\tbuilder := strings.Builder{}\n\n\tri := 0\n\tfor i := 0; i < hundreds; i++ {\n\t\tbuilder.WriteString(hundredChars)\n\t\tri++\n\t\tif ri == repeat {\n\t\t\tbuilder.WriteRune('\\n')\n\t\t\tri = 0\n\t\t}\n\t}\n\n\titems, omitted = MessageItemsFromLines(builder.String(), limits)\n\n\tmaxChunkSize := Min(limits.ChunkSize, repeat*100)\n\n\texpectedChunkCount := Min(limits.TotalChunkSize/maxChunkSize, Min(hundreds/repeat, limits.ChunkCount-1))\n\tExpect(len(items)).To(Equal(expectedChunkCount), \"Chunk count\")\n\n\treturn\n}\n\nfunc testPartitionMessage(hundreds int, limits types.MessageLimit, distance int) (items []types.MessageItem, omitted int) {\n\tbuilder := strings.Builder{}\n\n\tfor i := 0; i < hundreds; i++ {\n\t\tbuilder.WriteString(hundredChars)\n\t}\n\n\titems, omitted = PartitionMessage(builder.String(), limits, distance)\n\n\tcontentSize := Min(hundreds*100, limits.TotalChunkSize)\n\texpectedChunkCount := CeilDiv(contentSize, limits.ChunkSize-1)\n\texpectedOmitted := Max(0, (hundreds*100)-contentSize)\n\n\tExpect(omitted).To(Equal(expectedOmitted))\n\tExpect(len(items)).To(Equal(expectedChunkCount))\n\n\treturn\n}\n"], "fixing_code": ["package discord\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"net/url\"\n\n\t\"github.com/containrrr/shoutrrr/pkg/format\"\n\t\"github.com/containrrr/shoutrrr/pkg/services/standard\"\n\t\"github.com/containrrr/shoutrrr/pkg/types\"\n\t\"github.com/containrrr/shoutrrr/pkg/util\"\n)\n\n// Service providing Discord as a notification service\ntype Service struct {\n\tstandard.Standard\n\tconfig *Config\n\tpkr    format.PropKeyResolver\n}\n\nvar limits = types.MessageLimit{\n\tChunkSize:      2000,\n\tTotalChunkSize: 6000,\n\tChunkCount:     10,\n}\n\nconst (\n\thookURL = \"https://discord.com/api/webhooks\"\n\t// Only search this many runes for a good split position\n\tmaxSearchRunes = 100\n)\n\n// Send a notification message to discord\nfunc (service *Service) Send(message string, params *types.Params) (err error) {\n\tif service.config.JSON {\n\t\tpostURL := CreateAPIURLFromConfig(service.config)\n\t\terr = doSend([]byte(message), postURL)\n\t} else {\n\t\titems, omitted := CreateItemsFromPlain(message, service.config.SplitLines)\n\t\terr = service.sendItems(items, params, omitted)\n\t}\n\n\tif err != nil {\n\t\terr = fmt.Errorf(\"failed to send discord notification: %v\", err)\n\t}\n\n\treturn\n}\n\n// SendItems sends items with additional meta data and richer appearance\nfunc (service *Service) SendItems(items []types.MessageItem, params *types.Params) error {\n\treturn service.sendItems(items, params, 0)\n}\n\nfunc (service *Service) sendItems(items []types.MessageItem, params *types.Params, omitted int) error {\n\tvar err error\n\n\tconfig := *service.config\n\tif err = service.pkr.UpdateConfigFromParams(&config, params); err != nil {\n\t\treturn err\n\t}\n\n\tvar payload WebhookPayload\n\tpayload, err = CreatePayloadFromItems(items, config.Title, config.LevelColors(), omitted)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tpayload.Username = config.Username\n\tpayload.AvatarURL = config.Avatar\n\n\tvar payloadBytes []byte\n\tpayloadBytes, err = json.Marshal(payload)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tpostURL := CreateAPIURLFromConfig(&config)\n\treturn doSend(payloadBytes, postURL)\n}\n\n// CreateItemsFromPlain creates a set of MessageItems that is compatible with Discords webhook payload\nfunc CreateItemsFromPlain(plain string, splitLines bool) (items []types.MessageItem, omitted int) {\n\tif splitLines {\n\t\treturn util.MessageItemsFromLines(plain, limits)\n\t}\n\n\treturn util.PartitionMessage(plain, limits, maxSearchRunes)\n}\n\n// Initialize loads ServiceConfig from configURL and sets logger for this Service\nfunc (service *Service) Initialize(configURL *url.URL, logger types.StdLogger) error {\n\tservice.Logger.SetLogger(logger)\n\tservice.config = &Config{}\n\tservice.pkr = format.NewPropKeyResolver(service.config)\n\n\tif err := service.pkr.SetDefaultProps(service.config); err != nil {\n\t\treturn err\n\t}\n\n\tif err := service.config.SetURL(configURL); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\n// CreateAPIURLFromConfig takes a discord config object and creates a post url\nfunc CreateAPIURLFromConfig(config *Config) string {\n\treturn fmt.Sprintf(\n\t\t\"%s/%s/%s\",\n\t\thookURL,\n\t\tconfig.WebhookID,\n\t\tconfig.Token)\n}\n\nfunc doSend(payload []byte, postURL string) error {\n\tres, err := http.Post(postURL, \"application/json\", bytes.NewBuffer(payload))\n\n\tif res == nil && err == nil {\n\t\terr = fmt.Errorf(\"unknown error\")\n\t}\n\n\tif err == nil && res.StatusCode != http.StatusNoContent {\n\t\terr = fmt.Errorf(\"response status code %s\", res.Status)\n\t}\n\n\treturn err\n}\n", "package discord\n\nimport (\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/containrrr/shoutrrr/pkg/types\"\n\t\"github.com/containrrr/shoutrrr/pkg/util\"\n)\n\n// WebhookPayload is the webhook endpoint payload\ntype WebhookPayload struct {\n\tEmbeds    []embedItem `json:\"embeds\"`\n\tUsername  string      `json:\"username,omitempty\"`\n\tAvatarURL string      `json:\"avatar_url,omitempty\"`\n}\n\n// JSON is the actual notification payload\ntype embedItem struct {\n\tTitle     string       `json:\"title,omitempty\"`\n\tContent   string       `json:\"description,omitempty\"`\n\tURL       string       `json:\"url,omitempty\"`\n\tTimestamp string       `json:\"timestamp,omitempty\"`\n\tColor     uint         `json:\"color,omitempty\"`\n\tFooter    *embedFooter `json:\"footer,omitempty\"`\n}\n\ntype embedFooter struct {\n\tText    string `json:\"text\"`\n\tIconURL string `json:\"icon_url,omitempty\"`\n}\n\n// CreatePayloadFromItems creates a JSON payload to be sent to the discord webhook API\nfunc CreatePayloadFromItems(items []types.MessageItem, title string, colors [types.MessageLevelCount]uint, omitted int) (WebhookPayload, error) {\n\n\tif len(items) < 1 {\n\t\treturn WebhookPayload{}, fmt.Errorf(\"message is empty\")\n\t}\n\n\tmetaCount := 1\n\tif omitted < 1 && len(title) < 1 {\n\t\tmetaCount = 0\n\t}\n\titemCount := util.Min(9, len(items))\n\n\tembeds := make([]embedItem, metaCount, itemCount+metaCount)\n\n\tfor _, item := range items {\n\n\t\tcolor := uint(0)\n\t\tif item.Level >= types.Unknown && int(item.Level) < len(colors) {\n\t\t\tcolor = colors[item.Level]\n\t\t}\n\n\t\tei := embedItem{\n\t\t\tContent: item.Text,\n\t\t\tColor:   color,\n\t\t}\n\n\t\tif item.Level != types.Unknown {\n\t\t\tei.Footer = &embedFooter{\n\t\t\t\tText: item.Level.String(),\n\t\t\t}\n\t\t}\n\n\t\tif !item.Timestamp.IsZero() {\n\t\t\tei.Timestamp = item.Timestamp.UTC().Format(time.RFC3339)\n\t\t}\n\n\t\tembeds = append(embeds, ei)\n\t}\n\n\t// This should not happen, but it's better to leave the index check before dereferencing the array\n\tif len(embeds) > 0 {\n\t\tembeds[0].Title = title\n\n\t\tif omitted > 0 {\n\t\t\tembeds[0].Footer = &embedFooter{\n\t\t\t\tText: fmt.Sprintf(\"... (%v character(s) were omitted)\", omitted),\n\t\t\t}\n\t\t}\n\t}\n\n\treturn WebhookPayload{\n\t\tEmbeds: embeds,\n\t}, nil\n}\n", "package discord_test\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"time\"\n\n\t\"github.com/containrrr/shoutrrr/internal/testutils\"\n\t. \"github.com/containrrr/shoutrrr/pkg/services/discord\"\n\t\"github.com/containrrr/shoutrrr/pkg/types\"\n\t\"github.com/jarcoal/httpmock\"\n\n\t\"net/url\"\n\t\"os\"\n\t\"strings\"\n\t\"testing\"\n\n\t. \"github.com/onsi/ginkgo\"\n\t. \"github.com/onsi/gomega\"\n)\n\nfunc TestDiscord(t *testing.T) {\n\tRegisterFailHandler(Fail)\n\tRunSpecs(t, \"Shoutrrr Discord Suite\")\n}\n\nvar (\n\tdummyColors   = [types.MessageLevelCount]uint{}\n\tservice       *Service\n\tenvDiscordURL *url.URL\n\tlogger        *log.Logger\n)\n\nvar _ = Describe(\"the discord service\", func() {\n\tBeforeSuite(func() {\n\t\tservice = &Service{}\n\t\tenvDiscordURL, _ = url.Parse(os.Getenv(\"SHOUTRRR_DISCORD_URL\"))\n\t\tlogger = log.New(GinkgoWriter, \"Test\", log.LstdFlags)\n\t})\n\tWhen(\"running integration tests\", func() {\n\t\tIt(\"should work without errors\", func() {\n\t\t\tif envDiscordURL.String() == \"\" {\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tserviceURL, _ := url.Parse(envDiscordURL.String())\n\t\t\terr := service.Initialize(serviceURL, testutils.TestLogger())\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\n\t\t\terr = service.Send(\n\t\t\t\t\"this is an integration test\",\n\t\t\t\tnil,\n\t\t\t)\n\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t})\n\t})\n\tDescribe(\"the service\", func() {\n\t\tIt(\"should implement Service interface\", func() {\n\t\t\tvar impl types.Service = service\n\t\t\tExpect(impl).ToNot(BeNil())\n\t\t})\n\t})\n\tDescribe(\"creating a config\", func() {\n\t\tWhen(\"given an url and a message\", func() {\n\t\t\tIt(\"should return an error if no arguments where supplied\", func() {\n\t\t\t\tserviceURL, _ := url.Parse(\"discord://\")\n\t\t\t\terr := service.Initialize(serviceURL, nil)\n\t\t\t\tExpect(err).To(HaveOccurred())\n\t\t\t})\n\t\t\tIt(\"should not return an error if exactly two arguments are given\", func() {\n\t\t\t\tserviceURL, _ := url.Parse(\"discord://dummyToken@dummyChannel\")\n\t\t\t\terr := service.Initialize(serviceURL, nil)\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t})\n\t\t\tIt(\"should not return an error when given the raw path parameter\", func() {\n\t\t\t\tserviceURL, _ := url.Parse(\"discord://dummyToken@dummyChannel/raw\")\n\t\t\t\terr := service.Initialize(serviceURL, nil)\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t})\n\t\t\tIt(\"should set the JSON flag when given the raw path parameter\", func() {\n\t\t\t\tserviceURL, _ := url.Parse(\"discord://dummyToken@dummyChannel/raw\")\n\t\t\t\tconfig := Config{}\n\t\t\t\terr := config.SetURL(serviceURL)\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(config.JSON).To(BeTrue())\n\t\t\t})\n\t\t\tIt(\"should not set the JSON flag when not provided raw path parameter\", func() {\n\t\t\t\tserviceURL, _ := url.Parse(\"discord://dummyToken@dummyChannel\")\n\t\t\t\tconfig := Config{}\n\t\t\t\terr := config.SetURL(serviceURL)\n\t\t\t\tExpect(err).NotTo(HaveOccurred())\n\t\t\t\tExpect(config.JSON).NotTo(BeTrue())\n\t\t\t})\n\t\t\tIt(\"should return an error if more than two arguments are given\", func() {\n\t\t\t\tserviceURL, _ := url.Parse(\"discord://dummyToken@dummyChannel/illegal-argument\")\n\t\t\t\terr := service.Initialize(serviceURL, nil)\n\t\t\t\tExpect(err).To(HaveOccurred())\n\t\t\t})\n\t\t})\n\t\tWhen(\"parsing the configuration URL\", func() {\n\t\t\tIt(\"should be identical after de-/serialization\", func() {\n\t\t\t\ttestURL := \"discord://token@channel?avatar=TestBot.jpg&color=0x112233&colordebug=0x223344&colorerror=0x334455&colorinfo=0x445566&colorwarn=0x556677&splitlines=No&title=Test+Title&username=TestBot\"\n\n\t\t\t\turl, err := url.Parse(testURL)\n\t\t\t\tExpect(err).NotTo(HaveOccurred(), \"parsing\")\n\n\t\t\t\tconfig := &Config{}\n\t\t\t\terr = config.SetURL(url)\n\t\t\t\tExpect(err).NotTo(HaveOccurred(), \"verifying\")\n\n\t\t\t\toutputURL := config.GetURL()\n\n\t\t\t\tExpect(outputURL.String()).To(Equal(testURL))\n\n\t\t\t})\n\t\t})\n\t})\n\tDescribe(\"creating a json payload\", func() {\n\t\tWhen(\"given a blank message\", func() {\n\t\t\tWhen(\"split lines is enabled\", func() {\n\t\t\t\tIt(\"should return an error\", func() {\n\t\t\t\t\titems, omitted := CreateItemsFromPlain(\"\", true)\n\t\t\t\t\tExpect(items).To(BeEmpty())\n\t\t\t\t\t_, err := CreatePayloadFromItems(items, \"title\", dummyColors, omitted)\n\t\t\t\t\tExpect(err).To(HaveOccurred())\n\t\t\t\t})\n\t\t\t})\n\t\t\tWhen(\"split lines is disabled\", func() {\n\t\t\t\tIt(\"should return an error\", func() {\n\t\t\t\t\titems, omitted := CreateItemsFromPlain(\"\", false)\n\t\t\t\t\tExpect(items).To(BeEmpty())\n\t\t\t\t\t_, err := CreatePayloadFromItems(items, \"title\", dummyColors, omitted)\n\t\t\t\t\tExpect(err).To(HaveOccurred())\n\t\t\t\t})\n\t\t\t})\n\t\t})\n\t\tWhen(\"given a message that exceeds the max length\", func() {\n\t\t\tIt(\"should return a payload with chunked messages\", func() {\n\n\t\t\t\tpayload, err := buildPayloadFromHundreds(42, false, \"Title\", dummyColors)\n\t\t\t\tExpect(err).ToNot(HaveOccurred())\n\n\t\t\t\tmeta := payload.Embeds[0]\n\t\t\t\titems := payload.Embeds[1:]\n\n\t\t\t\tExpect(items).To(HaveLen(3))\n\n\t\t\t\tExpect(items[0].Content).To(HaveLen(1994))\n\t\t\t\tExpect(items[1].Content).To(HaveLen(1999))\n\t\t\t\tExpect(items[2].Content).To(HaveLen(205))\n\n\t\t\t\tExpect(meta.Footer).To(BeNil())\n\t\t\t})\n\t\t\tIt(\"omit characters above total max\", func() {\n\n\t\t\t\tpayload, err := buildPayloadFromHundreds(62, false, \"\", dummyColors)\n\t\t\t\tExpect(err).ToNot(HaveOccurred())\n\n\t\t\t\tmeta := payload.Embeds[0]\n\t\t\t\titems := payload.Embeds[1:]\n\n\t\t\t\tExpect(items).To(HaveLen(4))\n\t\t\t\tExpect(items[0].Content).To(HaveLen(1994))\n\t\t\t\tExpect(items[1].Content).To(HaveLen(1999))\n\t\t\t\tExpect(len(items[2].Content)).To(Equal(1999))\n\t\t\t\tExpect(len(items[3].Content)).To(Equal(5))\n\n\t\t\t\tExpect(meta.Footer.Text).To(ContainSubstring(\"200\"))\n\t\t\t})\n\t\t\tWhen(\"no title is supplied and content fits\", func() {\n\t\t\t\tIt(\"should return a payload without a meta chunk\", func() {\n\n\t\t\t\t\tpayload, err := buildPayloadFromHundreds(42, false, \"\", dummyColors)\n\t\t\t\t\tExpect(err).ToNot(HaveOccurred())\n\t\t\t\t\tExpect(payload.Embeds[0].Footer).To(BeNil())\n\t\t\t\t\tExpect(payload.Embeds[0].Title).To(BeEmpty())\n\t\t\t\t})\n\t\t\t})\n\t\t\tWhen(\"no title is supplied but content was omitted\", func() {\n\t\t\t\tIt(\"should return a payload with a meta chunk\", func() {\n\n\t\t\t\t\tpayload, err := buildPayloadFromHundreds(62, false, \"\", dummyColors)\n\t\t\t\t\tExpect(err).ToNot(HaveOccurred())\n\t\t\t\t\tExpect(payload.Embeds[0].Footer).ToNot(BeNil())\n\t\t\t\t})\n\t\t\t})\n\t\t\tWhen(\"title is supplied, but content fits\", func() {\n\t\t\t\tIt(\"should return a payload with a meta chunk\", func() {\n\t\t\t\t\tpayload, err := buildPayloadFromHundreds(42, false, \"Title\", dummyColors)\n\t\t\t\t\tExpect(err).ToNot(HaveOccurred())\n\t\t\t\t\tExpect(payload.Embeds[0].Title).ToNot(BeEmpty())\n\t\t\t\t})\n\t\t\t})\n\n\t\t\tIt(\"rich test 1\", func() {\n\n\t\t\t\ttestTime, _ := time.Parse(time.RFC3339, time.RFC3339)\n\t\t\t\titems := []types.MessageItem{\n\t\t\t\t\t{\n\t\t\t\t\t\tText:      \"Message\",\n\t\t\t\t\t\tTimestamp: testTime,\n\t\t\t\t\t\tLevel:     types.Warning,\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t\tpayload, err := CreatePayloadFromItems(items, \"Title\", dummyColors, 0)\n\t\t\t\tExpect(err).ToNot(HaveOccurred())\n\n\t\t\t\tmeta := payload.Embeds[0]\n\t\t\t\titem := payload.Embeds[1]\n\n\t\t\t\tExpect(payload.Embeds).To(HaveLen(2))\n\t\t\t\tExpect(item.Footer.Text).To(Equal(types.Warning.String()))\n\t\t\t\tExpect(meta.Title).To(Equal(\"Title\"))\n\t\t\t\tExpect(item.Color).To(Equal(dummyColors[types.Warning]))\n\t\t\t})\n\t\t})\n\t})\n\n\tDescribe(\"sending the payload\", func() {\n\t\tvar dummyConfig = Config{\n\t\t\tWebhookID: \"1\",\n\t\t\tToken:     \"dummyToken\",\n\t\t}\n\t\tvar service Service\n\t\tBeforeEach(func() {\n\t\t\thttpmock.Activate()\n\t\t\tservice = Service{}\n\t\t\tif err := service.Initialize(dummyConfig.GetURL(), logger); err != nil {\n\t\t\t\tpanic(fmt.Errorf(\"service initialization failed: %v\", err))\n\t\t\t}\n\t\t})\n\t\tAfterEach(func() {\n\t\t\thttpmock.DeactivateAndReset()\n\t\t})\n\t\tIt(\"should not report an error if the server accepts the payload\", func() {\n\t\t\tsetupResponder(&dummyConfig, 204, \"\")\n\n\t\t\tExpect(service.Send(\"Message\", nil)).To(Succeed())\n\t\t})\n\t\tIt(\"should report an error if the server response is not OK\", func() {\n\t\t\tsetupResponder(&dummyConfig, 400, \"\")\n\t\t\tExpect(service.Initialize(dummyConfig.GetURL(), logger)).To(Succeed())\n\t\t\tExpect(service.Send(\"Message\", nil)).NotTo(Succeed())\n\t\t})\n\t\tIt(\"should report an error if the message is empty\", func() {\n\t\t\tsetupResponder(&dummyConfig, 204, \"\")\n\t\t\tExpect(service.Initialize(dummyConfig.GetURL(), logger)).To(Succeed())\n\t\t\tExpect(service.Send(\"\", nil)).NotTo(Succeed())\n\t\t})\n\t\tWhen(\"using a custom json payload\", func() {\n\t\t\tIt(\"should report an error if the server response is not OK\", func() {\n\t\t\t\tconfig := dummyConfig\n\t\t\t\tconfig.JSON = true\n\t\t\t\tsetupResponder(&config, 400, \"\")\n\t\t\t\tExpect(service.Initialize(config.GetURL(), logger)).To(Succeed())\n\t\t\t\tExpect(service.Send(\"Message\", nil)).NotTo(Succeed())\n\t\t\t})\n\t\t})\n\t})\n})\n\nfunc buildPayloadFromHundreds(hundreds int, split bool, title string, colors [types.MessageLevelCount]uint) (WebhookPayload, error) {\n\thundredChars := \"this string is exactly (to the letter) a hundred characters long which will make the send func error\"\n\tbuilder := strings.Builder{}\n\n\tfor i := 0; i < hundreds; i++ {\n\t\tbuilder.WriteString(hundredChars)\n\t}\n\n\titems, omitted := CreateItemsFromPlain(builder.String(), split)\n\tprintln(\"Items:\", len(items), \"Omitted:\", omitted)\n\n\treturn CreatePayloadFromItems(items, title, colors, omitted)\n}\n\nfunc setupResponder(config *Config, code int, body string) {\n\ttargetURL := CreateAPIURLFromConfig(config)\n\thttpmock.RegisterResponder(\"POST\", targetURL, httpmock.NewStringResponder(code, body))\n}\n", "package util\n\nimport (\n\tt \"github.com/containrrr/shoutrrr/pkg/types\"\n\n\t\"strings\"\n)\n\nconst ellipsis = \" [...]\"\n\n// PartitionMessage splits a string into chunks that is at most chunkSize runes, it will search the last distance runes\n// for a whitespace to make the split appear nicer. It will keep adding chunks until it reaches maxCount chunks, or if\n// the total amount of runes in the chunks reach maxTotal.\n// The chunks are returned together with the number of omitted runes (that did not fit into the chunks)\nfunc PartitionMessage(input string, limits t.MessageLimit, distance int) (items []t.MessageItem, omitted int) {\n\trunes := []rune(input)\n\tchunkOffset := 0\n\tmaxTotal := Min(len(runes), limits.TotalChunkSize)\n\tmaxCount := limits.ChunkCount - 1\n\n\tif len(input) == 0 {\n\t\t// If the message is empty, return an empty array\n\t\tomitted = 0\n\t\treturn\n\t}\n\n\tfor i := 0; i < maxCount; i++ {\n\t\t// If no suitable split point is found, start next chunk at chunkSize from chunk start\n\t\tnextChunkStart := chunkOffset + limits.ChunkSize\n\t\t// ... and set the chunk end to the rune before the next chunk\n\t\tchunkEnd := nextChunkStart - 1\n\t\tif chunkEnd > maxTotal {\n\t\t\t// The chunk is smaller than the limit, no need to search\n\t\t\tchunkEnd = maxTotal\n\t\t\tnextChunkStart = maxTotal\n\t\t} else {\n\t\t\tfor r := 0; r < distance; r++ {\n\t\t\t\trp := chunkEnd - r\n\t\t\t\tif runes[rp] == '\\n' || runes[rp] == ' ' {\n\t\t\t\t\t// Suitable split point found\n\t\t\t\t\tchunkEnd = rp\n\t\t\t\t\t// Since the split is on a whitespace, skip it in the next chunk\n\t\t\t\t\tnextChunkStart = chunkEnd + 1\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\titems = append(items, t.MessageItem{\n\t\t\tText: string(runes[chunkOffset:chunkEnd]),\n\t\t})\n\n\t\tchunkOffset = nextChunkStart\n\t\tif chunkOffset >= maxTotal {\n\t\t\tbreak\n\t\t}\n\t}\n\n\treturn items, len(runes) - chunkOffset\n}\n\n// MessageItemsFromLines creates a set of MessageItems that is compatible with the supplied limits\nfunc MessageItemsFromLines(plain string, limits t.MessageLimit) (items []t.MessageItem, omitted int) {\n\tomitted = 0\n\tmaxCount := limits.ChunkCount - 1\n\n\tlines := strings.Split(plain, \"\\n\")\n\titems = make([]t.MessageItem, 0, Min(maxCount, len(lines)))\n\n\ttotalLength := 0\n\tfor l, line := range lines {\n\t\tif l < maxCount && totalLength < limits.TotalChunkSize {\n\t\t\trunes := []rune(line)\n\t\t\tmaxLen := limits.ChunkSize\n\t\t\tif totalLength+maxLen > limits.TotalChunkSize {\n\t\t\t\tmaxLen = limits.TotalChunkSize - totalLength\n\t\t\t}\n\t\t\tif len(runes) > maxLen {\n\t\t\t\t// Trim and add ellipsis\n\t\t\t\trunes = runes[:maxLen-len(ellipsis)]\n\t\t\t\tline = string(runes) + ellipsis\n\t\t\t}\n\n\t\t\tif len(runes) < 1 {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\titems = append(items, t.MessageItem{\n\t\t\t\tText: line,\n\t\t\t})\n\n\t\t\ttotalLength += len(runes)\n\n\t\t} else {\n\t\t\tomitted += len(line)\n\t\t}\n\t}\n\n\treturn items, omitted\n}\n", "package util\n\nimport (\n\t\"strings\"\n\n\t\"github.com/containrrr/shoutrrr/pkg/types\"\n\t. \"github.com/onsi/ginkgo\"\n\t. \"github.com/onsi/gomega\"\n)\n\nvar _ = Describe(\"Partition Message\", func() {\n\tlimits := types.MessageLimit{\n\t\tChunkSize:      2000,\n\t\tTotalChunkSize: 6000,\n\t\tChunkCount:     10,\n\t}\n\tWhen(\"given a message that exceeds the max length\", func() {\n\t\tWhen(\"not splitting by lines\", func() {\n\t\t\tIt(\"should return a payload with chunked messages\", func() {\n\n\t\t\t\titems, _ := testPartitionMessage(42, limits, 100)\n\n\t\t\t\tExpect(len(items[0].Text)).To(Equal(1994))\n\t\t\t\tExpect(len(items[1].Text)).To(Equal(1999))\n\t\t\t\tExpect(len(items[2].Text)).To(Equal(205))\n\t\t\t})\n\t\t\tIt(\"omit characters above total max\", func() {\n\t\t\t\titems, _ := testPartitionMessage(62, limits, 100)\n\n\t\t\t\tExpect(len(items[0].Text)).To(Equal(1994))\n\t\t\t\tExpect(len(items[1].Text)).To(Equal(1999))\n\t\t\t\tExpect(len(items[2].Text)).To(Equal(1999))\n\t\t\t\tExpect(len(items[3].Text)).To(Equal(5))\n\t\t\t})\n\t\t\tIt(\"should handle messages with a size modulus of chunksize\", func() {\n\t\t\t\titems, _ := testPartitionMessage(20, limits, 100)\n\t\t\t\tExpect(len(items[0].Text)).To(Equal(1994))\n\t\t\t\tExpect(len(items[1].Text)).To(Equal(5))\n\n\t\t\t\titems, _ = testPartitionMessage(40, limits, 100)\n\t\t\t\tExpect(len(items[0].Text)).To(Equal(1994))\n\t\t\t\tExpect(len(items[1].Text)).To(Equal(1999))\n\t\t\t\tExpect(len(items[2].Text)).To(Equal(5))\n\t\t\t})\n\t\t\tWhen(\"the message is empty\", func() {\n\t\t\t\tIt(\"should return no items\", func() {\n\t\t\t\t\titems, _ := testPartitionMessage(0, limits, 100)\n\t\t\t\t\tExpect(items).To(BeEmpty())\n\t\t\t\t})\n\t\t\t})\n\n\t\t})\n\t\tWhen(\"splitting by lines\", func() {\n\t\t\tIt(\"should return a payload with chunked messages\", func() {\n\t\t\t\titems, omitted := testMessageItemsFromLines(18, limits, 2)\n\n\t\t\t\tExpect(len(items[0].Text)).To(Equal(200))\n\t\t\t\tExpect(len(items[8].Text)).To(Equal(200))\n\n\t\t\t\tExpect(omitted).To(Equal(0))\n\t\t\t})\n\t\t\tIt(\"omit characters above total max\", func() {\n\t\t\t\titems, omitted := testMessageItemsFromLines(19, limits, 2)\n\n\t\t\t\tExpect(len(items[0].Text)).To(Equal(200))\n\t\t\t\tExpect(len(items[8].Text)).To(Equal(200))\n\n\t\t\t\tExpect(omitted).To(Equal(100))\n\t\t\t})\n\t\t\tIt(\"should trim characters above chunk size\", func() {\n\t\t\t\thundreds := 42\n\t\t\t\trepeat := 21\n\t\t\t\titems, omitted := testMessageItemsFromLines(hundreds, limits, repeat)\n\n\t\t\t\tExpect(len(items[0].Text)).To(Equal(limits.ChunkSize))\n\t\t\t\tExpect(len(items[1].Text)).To(Equal(limits.ChunkSize))\n\n\t\t\t\t// Trimmed characters do not count towards the total omitted count\n\t\t\t\tExpect(omitted).To(Equal(0))\n\t\t\t})\n\n\t\t\tIt(\"omit characters above total chunk size\", func() {\n\t\t\t\thundreds := 100\n\t\t\t\trepeat := 20\n\t\t\t\titems, omitted := testMessageItemsFromLines(hundreds, limits, repeat)\n\n\t\t\t\tExpect(len(items[0].Text)).To(Equal(limits.ChunkSize))\n\t\t\t\tExpect(len(items[1].Text)).To(Equal(limits.ChunkSize))\n\t\t\t\tExpect(len(items[2].Text)).To(Equal(limits.ChunkSize))\n\n\t\t\t\tmaxRunes := hundreds * 100\n\t\t\t\texpectedOmitted := maxRunes - limits.TotalChunkSize\n\n\t\t\t\tExpect(omitted).To(Equal(expectedOmitted))\n\t\t\t})\n\n\t\t})\n\n\t})\n})\n\nconst hundredChars = \"this string is exactly (to the letter) a hundred characters long which will make the send func error\"\n\nfunc testMessageItemsFromLines(hundreds int, limits types.MessageLimit, repeat int) (items []types.MessageItem, omitted int) {\n\n\tbuilder := strings.Builder{}\n\n\tri := 0\n\tfor i := 0; i < hundreds; i++ {\n\t\tbuilder.WriteString(hundredChars)\n\t\tri++\n\t\tif ri == repeat {\n\t\t\tbuilder.WriteRune('\\n')\n\t\t\tri = 0\n\t\t}\n\t}\n\n\titems, omitted = MessageItemsFromLines(builder.String(), limits)\n\n\tmaxChunkSize := Min(limits.ChunkSize, repeat*100)\n\n\texpectedChunkCount := Min(limits.TotalChunkSize/maxChunkSize, Min(hundreds/repeat, limits.ChunkCount-1))\n\tExpect(len(items)).To(Equal(expectedChunkCount), \"Chunk count\")\n\n\treturn\n}\n\nfunc testPartitionMessage(hundreds int, limits types.MessageLimit, distance int) (items []types.MessageItem, omitted int) {\n\tbuilder := strings.Builder{}\n\n\tfor i := 0; i < hundreds; i++ {\n\t\tbuilder.WriteString(hundredChars)\n\t}\n\n\titems, omitted = PartitionMessage(builder.String(), limits, distance)\n\n\tcontentSize := Min(hundreds*100, limits.TotalChunkSize)\n\texpectedChunkCount := CeilDiv(contentSize, limits.ChunkSize-1)\n\texpectedOmitted := Max(0, (hundreds*100)-contentSize)\n\n\tExpect(omitted).To(Equal(expectedOmitted))\n\tExpect(len(items)).To(Equal(expectedChunkCount))\n\n\treturn\n}\n"], "filenames": ["pkg/services/discord/discord.go", "pkg/services/discord/discord_json.go", "pkg/services/discord/discord_test.go", "pkg/util/partition_message.go", "pkg/util/partition_message_test.go"], "buggy_code_start_loc": [6, 4, 3, 20, 3], "buggy_code_end_loc": [129, 72, 230, 26, 82], "fixing_code_start_loc": [7, 5, 4, 21, 4], "fixing_code_end_loc": [131, 81, 259, 32, 99], "type": "NVD-CWE-noinfo", "message": "The package github.com/containrrr/shoutrrr/pkg/util before 0.6.0 are vulnerable to Denial of Service (DoS) via the util.PartitionMessage function. Exploiting this vulnerability is possible by sending exactly 2000, 4000, or 6000 characters messages.", "other": {"cve": {"id": "CVE-2022-25891", "sourceIdentifier": "report@snyk.io", "published": "2022-07-15T20:15:08.540", "lastModified": "2022-07-21T14:35:24.517", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The package github.com/containrrr/shoutrrr/pkg/util before 0.6.0 are vulnerable to Denial of Service (DoS) via the util.PartitionMessage function. Exploiting this vulnerability is possible by sending exactly 2000, 4000, or 6000 characters messages."}, {"lang": "es", "value": "El paquete github.com/containrrr/shoutrrr/pkg/util versiones anteriores a 0.6.0, es vulnerable a una Denegaci\u00f3n de Servicio (DoS) por medio de la funci\u00f3n util.PartitionMessage. Una explotaci\u00f3n de esta vulnerabilidad es posible mediante el env\u00edo de exactamente 2000, 4000, or 6000 caracteres de mensajes"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "report@snyk.io", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:containrrr:shoutrrr:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.6.0", "matchCriteriaId": "84BD144E-65D8-46A2-8477-CD3463B66931"}]}]}], "references": [{"url": "https://github.com/containrrr/shoutrrr/commit/6a27056f9d7522a8b493216195cb7634bf4b5c42", "source": "report@snyk.io", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/containrrr/shoutrrr/issues/240", "source": "report@snyk.io", "tags": ["Exploit", "Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/containrrr/shoutrrr/pull/242", "source": "report@snyk.io", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/containrrr/shoutrrr/releases/tag/v0.6.0", "source": "report@snyk.io", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://snyk.io/vuln/SNYK-GOLANG-GITHUBCOMCONTAINRRRSHOUTRRRPKGUTIL-2849059", "source": "report@snyk.io", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/containrrr/shoutrrr/commit/6a27056f9d7522a8b493216195cb7634bf4b5c42"}}