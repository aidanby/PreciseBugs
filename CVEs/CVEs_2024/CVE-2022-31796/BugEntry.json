{"buggy_code": ["This project implements a complete(!) JPEG (Rec. ITU-T T.81 | ISO/IEC\r\n10918-1) codec, plus a library that can be used to encode and decode\r\nJPEG streams.  It also implements ISO/IEC 18477 aka JPEG XT which is\r\nan extension towards intermediate, high-dynamic-range lossy and\r\nlossless coding of JPEG. In specific, it supports ISO/IEC\r\n18477-3/-6/-7/-8/-9 encoding.\r\n\r\n--------------------------------------------------------------------------\r\n\r\nUnlike many other implementations, libjpeg also implements:\r\n\r\n- 12 bpp image coding for the lossy DCT process,\r\n- the predictive lossless mode of Rec. ITU-T T.81 | ISO/IEC 10918-1,\r\n- the hierarchical process of Rec. ITU-T T.81 | ISO/IEC 10918-1,\r\n- the arithmetic coding option of Rec. ITU-T T.81 | ISO/IEC 10918-1,\r\n- coding of up to 256 component images\r\n- upsampling of images for all factors from 1x1 to 4x4\r\n\r\nStandard features are of course also supported, such as\r\nsequential and progressive mode in 8bpp.\r\n\r\n--------------------------------------------------------------------------\r\n\r\nIn addition, this codec provides methods to encode images\r\n\r\n- with a bit depth between 8 and 16 bits per sample, fully backwards\r\n  compatible to Rec. ITU-T T.81 | ISO/IEC 10918 baseline coding.\r\n\r\n- consisting of floating point samples, specifically images with \r\n  high dynamic range.\r\n\r\n- to encode images without loss, regardless of their bit-depth and their\r\n  sample data type.\r\n\r\n--------------------------------------------------------------------------\r\n\r\nExample usage:\r\n\r\nStandard JPEG compression, with 444 (aka \"no\") subsampling:\r\n\r\n$ jpeg -q <quality> infile.ppm outfile.jpg\r\n\r\nStandard JPEG compression, with 422 subsampling:\r\n\r\n$ jpeg -q <quality> -s 1x1,2x2,2x2 infile.ppm outfile.jpg\r\n\r\nIntermediate dynamic range compression, i.e. compression of images\r\nof a bit-depth between 8 and 16 bits:\r\n\r\n$ jpeg -r -q <base-quality> -Q <extension-quality> -h -r12 infile.ppm outfile.jpg\r\n\r\nThis type of encoding uses a technology known as \"residual scans\" which \r\nincrease the bit-depths in the spatial domain which is enabled by the -r\r\ncommand line switch. The -Q parameter sets the quality of the residual image. \r\nTo improve the precision in the frequency domain, \"refinement scans\" can be used. \r\nThe following encodes a 12-bit image with  four additional refinement scans,\r\nenabled by the \"-R 4\" parameter.\r\n\r\n$ jpeg -q <quality> -R 4 -h infile.ppm outfile.jpg\r\n\r\nBoth technologies can be combined, and the precision of the residual scan\r\ncan also be enlarged by using residual refinement scans with the -rR option.\r\nThe following command line with use a 12-bit residual scan with four refinement\r\nscans:\r\n\r\n$ jpeg -r -q <base-quality> -Q <extension-quality> -h -rR 4 infile.ppm outfile.jpg\r\n\r\nHigh-dynamic range compression allows three different profiles of varying\r\ncomplexity and performance. The profiles are denoted by \"-profile <X>\" where\r\n<X> is a,b or c. The following encodes an HDR image in profile C:\r\n\r\n$ jpeg -r -q <base-quality> -Q <extension-quality> -h -profile c -rR 4 infile.pfm outfile.jpg\r\n\r\nHDR images here have to be fed into the command line in \"pfm\" format. \r\nexr or hdr is not supported as input format and requires conversion to \r\npfm first. pfm is the floating-point equivalent of ppm and encodes each\r\npixel by three 32-bit floating point numbers.\r\n\r\nEncoding in profiles a and b works likewise, though it is generally advisable to\r\nuse \"open loop\" rather than \"closed loop\" coding for these two profiles by\r\nadditionally providing the \"-ol\" parameter. This also works for profile C:\r\n\r\n$ jpeg -ol -r -profile a -q <base-quality> -Q <extension-quality> -h infile.pfm out.jpg\r\n\r\nsimilar for profile B.\r\n\r\nWhat is common to profiles A and C is that you may optionally also specify \r\nthe LDR image, i.e. the image that a legacy JPEG decoder will show. By default, \r\na simple tone mapping algorithm (\"global Reinhard\") will be used to derive a\r\nsuitable LDR image from the input image:\r\n\r\n$ jpeg -ldr infile.ppm -q <base-quality> -Q <extension-quality> -h -rR 4 infile.pfm out.jpg\r\n\r\nThe profile is by default profile c, but it also works for profile a:\r\n\r\n$ jpeg -ol profile a -ldr infile.ppm -q <base-quality> -Q <extension-quality> infile.pfm out.jpg\r\n\r\nIt is in general advisable for profile c encoding to enable residual refinement scans,\r\nprofiles a or b do not require them.\r\n\r\n\r\nThe following options exist for lossless coding integer:\r\n\r\npredictive Rec. ITU-T T.81 | ISO/IEC 10918-1 coding. Note, however,\r\nthat not many implementations are capable of decoding such stream,\r\nthus this is probably not a good option for all-day purposes.\r\n\r\n$ jpeg -p -c infile.ppm out.jpg\r\n\r\nWhile the result is a valid Rec. ITU-T T.81 | ISO/IEC 10918-1 stream,\r\nmost other implementations will hick up and break, thus it is not\r\nadvisable to use it.\r\n\r\nA second option for lossless coding is residual coding within profile c:\r\n\r\n$ jpeg -q <quality> -Q 100 -h -r infile.ppm out.jpg\r\n\r\nThis also works for floating point coding. Note that lossless coding is enabled\r\nby setting the extension quality to 100.\r\n\r\n$ jpeg -q <quality> -Q 100 -h -r infile.pfm out.jpg\r\n\r\nHowever, this is only lossless for 16 bit input samples, i.e. there is a precision\r\nloss due to down-converting the 32-bit input to 16 bit. If samples are out of the\r\n601 gamut, the problem also exists that clamping will happen. To avoid that,\r\nencode in the XYZ color space (profile C only, currently):\r\n\r\n$ jpeg -xyz -q <quality> -Q 100 -h -r infile.pfm out.jpg\r\n\r\nA second option for lossless integer coding is to use a lossless 1-1 DCT\r\nprocess. This is enabled with the -l command line option:\r\n\r\n$ jpeg -l -q 100 -c infile.ppm out.jpg\r\n\r\nRefinement scans can be used to increase the sample precision to up to 12\r\nbits. The \"-c\" command line option disables the lossy color transformation.\r\n\r\nAdditionally, this implementation also supports JPEG LS, which is\r\noutside of Rec. ITU-T T.81 | ISO/IEC 10918-1 and ISO/IEC 18477. For\r\nthat, use the command line option -ls:\r\n\r\n$ jpeg -ls -c infile.ppm out.jpg\r\n\r\nThe \"-c\" command line switch is necessary to disable the color transformation\r\nas JPEG LS typically encodes in RGB and not YCbCr space.\r\n\r\nOptionally, you may specify the JPEG LS \"near\" parameter (maximum error) with\r\nthe -m command line switch:\r\n\r\n$ jpeg -ls -m 2 -c infile.ppm out.jpg\r\n\r\nJPEG LS also specifies a lossless color transformation that is enabled with\r\n-cls:\r\n\r\n$ jpeg -ls -cls infile.ppm out.jpg\r\n\r\n\r\nTo encode images with an alpha channel, specify the source image that \r\ncontains the alpha channel with -al. The alpha channel is a one-component\r\ngrey-scale image, either integer or floating point. The quality of the\r\nalpha channel is specified with -aq, that of the regular image with -q:\r\n\r\n$ jpeg -al alpha.pgm -aq 80 -q 85 input.ppm output.jpg\r\n\r\nAlpha channels can be larger than 8bpp or can be floating point. In both\r\ncases, residual coding is required. To enable residual coding in the alpha\r\nchannel, use the -ar command line option. Similar to the regular image,\r\nwhere residual coding requires two parameters, -q for the base quality and\r\n-Q for the extension quality, an alpha channel that uses residual coding\r\nalso requires a base and extension quality, the former is given by -aq,\r\nthe latter with -aQ:\r\n\r\n$ jpeg -ar -al alphahigh.pgm -q 85 -Q 90 -aq 80 -aQ 90 input.ppm out.jpg\r\n\r\nThe alpha channel can be encoded without loss if desired. For that, enable\r\nresidual coding with -ar and specify an extension quality of 100:\r\n\r\n$ jpeg -ar -al alphahigh.pgm -q 85 -Q 90 -aq 80 -aQ 100 input.ppm out.jpg\r\n\r\nThe alpha channel can use the same technology extensions as the image,\r\nnamely refinement scans in the base or extension image, or 12-bit residual\r\nimages. The number of refinement scans is selected with -aR and -arR for\r\nthe base and residual image, a 12-bit residual image is selected with -ar12.\r\n\r\n--------------------------------------------------------------------------\r\n\r\nDecoding is much simpler:\r\n\r\n$ jpeg infile.jpg out.ppm\r\n\r\nor, for floating point images:\r\n\r\n$ jpeg infile.jpg out.pfm\r\n\r\n\r\nIf you want to decode a JPEG LS image, then you may want to tell the\r\ndecoder explicitly to disable the color transformation even though the\r\ncorresponding marker signalling coding in RGB space is typically missing\r\nfor JPEG LS:\r\n\r\n$ jpeg -c infile.jpg out.ppm\r\n\r\n\r\nIf an alpha channel is included in the image, the decoder does not\r\nreconstruct this automatically, nor does it attempt to merge the alpha\r\nimage into the file. Instead, it may optionally be instructed to write the\r\nalpha channel into a separate 1-component (grey-scale) file:\r\n\r\n$ jpeg -al alpha.pgm infile.jpg outfile.ppm\r\n\r\nThe -al option for the decoder provides the target file for the alpha\r\nchannel.\r\n\r\n--------------------------------------------------------------------------\r\n\r\nStarting with release 1.30, libjpeg will include a couple of optimization\r\nparameters to improve the performance of JPEG and JPEG XT. In this\r\nrelease, the following additional command line switches are available:\r\n\r\n-qt <n> : Selects a different quantization table. The default table,\r\nalso enabled by -qt 0, is the one in the legacy JPEG standard\r\n(Rec. ITU-T T.81 | ISO/IEC 10918-1). -qt 1 is the \"flat\" table for\r\nPSNR-optimal performance. It is not recommended for real-life usage as\r\nits visual performance is non-ideal, it just generates \"nice\r\nnumbers\". -qt 2 is MS-SSIM ideal, but similarly, not necessarily a\r\ngood recommendation for all-day use. -qt 3 is a good compromize and\r\nusually works better than -qt 0.\r\n\r\n-dz : This option enables a deadzone quantizer that shifts the buckets\r\nby 1/8th of their size to the outside. This is (almost) the ideal choice\r\nfor Laplacian sources which would require a shift of 1/12th. Nevertheless,\r\nthis option improves the rate-distortion performance by about 0.3dB on\r\naverage and works pretty consistent over many images.\r\n\r\nAdditional options are planned for future releases.\r\n-------------------------------------------------------------------------------------\r\n\r\nRelease 1.40:\r\n\r\nIn this release, we included additional support for \"full profile\" encoding, i.e.\r\nencoding parameters that do not fit any of the four profiles specified in 18477-7.\r\nUsing such encoding parameters will generate a warning on the command line, but\r\nencoding will proceed anyhow, generating a bitstream that conforms to 18477-7, but\r\nnot to any of the profiles in this standard.\r\n\r\nWith \"-profile a -g 0\" or \"-profile b -g 0\" the encoder will generate a file that\r\nuses an inverse TMO lookup similar to profile C with other encoding parameters\r\nidentical to those defined by profiles A and B.\r\n\r\nThe command line option \"-lr\" will use a logarithmic encoding instead of the gamma\r\nencoding for profile B. Again, this will leave the profile, but will be within the\r\nbounds of 18477-7.\r\n\r\nOther than that, a couple of bug fixes have been made. Profile A and B setup could\r\nnot reset the toe value for the inverse gamma map, due to a typo of one of the\r\nparameters. Profile B accepted a different gamma value than the default, but never\r\ncommunicated it to the core code, i.e. it was simply ignored. Profile B setup ignored\r\nthe epsilon values for numerator and denomiator, and they were communicated wrongly\r\ninto the core code. This was corrected, and epsilons can now be specified on the\r\ncommand line.\r\n\r\n--------------------------------------------------------------------------\r\n\r\nRelease 1.50:\r\n\r\nThis release fixes encoding of ISO/IEC 18477-8 if the IDCT was selected as\r\ntransformation in the extension layer and refinement scans were added, i.e.\r\nthe command line options -rl -rR 4 created invalid codestreams. Previous\r\nreleases used the wrong type of refinement scan (dct bypass refinement instead\r\nof regular refinement) and hence broke reconstruction. Furthermore, previous\r\nreleases no longer allowed near lossless coding with DCT bypass. Instead, regular\r\nDCT coding conforming to ISO/IEC 18477-7 was used. To enable the near-lossless\r\nDCT bypass mode, use the new option \"-ro\" now.\r\n\r\nProfile B encoding could potentially create codestreams that run into\r\nclipping of the extension channel; this always happens if the denominator is\r\nlarger than 1, and has to happen according to Annex C of ISO/IEC 18477-3.\r\nThis release avoids this issue by adjusting the exposure value such that\r\nthe denominator always remains smaller than 1.\r\n\r\n--------------------------------------------------------------------------\r\n\r\nRelease 1.51:\r\n\r\nIf the JPEG-XT markers were delayed to the frame-header intead the global\r\nheader, the previous code did not built up the necessary infrastructure\r\nto compute the checksum and hence could not verify the checksum in such\r\na condition. The 1.51 release fixes this problem.\r\n\r\n--------------------------------------------------------------------------\r\n\r\nRelease 1.52:\r\n\r\nThis file is an updated/enhanced version of the 1.51 release of\r\nthe JPEG XT demo software found on https://github.com/thorfdbg/. It\r\nincludes additional features presented in the paper\r\n\"JPEG on Steroids : Common Optimization Techniques for JPEG Image Compression\"\r\nby the same author.\r\n\r\nIn specific, the following command line flags are *NEW* to this version and\r\nare available only as a contribution to ICIP 2016:\r\n\r\n-oz:          This enables the dynamic programming algorithm to enhance\r\nthe rate-distortion performance by soft-threshold quantization. It has been\r\nused for the tests in section 3.3 of the paper.\r\n\r\n-dr:         This enables the smart de-ringing algorithm that has been used\r\nin section 3.6.\r\n\r\nAdditionally, the following switches have been used for other subsections\r\nof the paper; they are not new to this distribution but available as\r\npart of the regular libjpeg distribution at github or www.jpeg.org:\r\n\r\n-s 1x1,2x2,2x2:     Enable 420 subsampling (444 is default)\r\n-s 1x1,2x1,2x1:     Enable 422 subsampling (444 is default)\r\n-qt n (n=0..8)      Use quantization matrix n.\r\n                    In the paper, n=1 (flat) was used for PSNR-optimized\r\n                    coding, unless otherwise noted.\r\n-dz                 The deadzone quantizer in section 3.3\r\n                    (simpler than -oz)\r\n-v                  Enable coding in processive mode (section 3.5)\r\n-v -qv              Optimized progressive mode (section 3.5)\r\n-h                  Optimized Huffman coding (always used, unless noted\r\n                    otherwise, see section 3.4)\r\n\t\t    \r\n--------------------------------------------------------------------------\r\n\r\nRelease 1.53:\r\n\r\nThis release includes additional functionality to inject markers, or\r\nretrieve markers from a codestream while reading. For that, set\r\nthe JPGTAG_ENCODER_STOP tag of the JPEG::Write() call to a bitmask\r\nwhere the encoder should interrupt writing data (this flag already\r\nexisted before) then write custom data with JPEG::WriteMarker(), then\r\ncontinue with JPEG::Write(). On decoding, set JPGTAG_DECODER_STOP to\r\na bitmask where to stop for markers, then identify markers with\r\nJPEG::PeekMarker(), and retrieve them with JPEG::ReadMarker(). Details\r\ncan be found in cmd/encodec.cpp for encoding, and cmd/reconstruct.cpp.\r\n\r\nOtherwise, no functional changes.\r\n\r\n--------------------------------------------------------------------------\r\n\r\nRelease 1.54:\r\n\r\nIn this release, upsampling has been made conforming to the latest\r\ncorrigendum of 18477-1 and 18477-8. In particular, upsampling is now\r\nby design always centered and never co-sited. The co-sited upsampling\r\nprocedure is still included in the source code, but never executed.\r\n\r\n--------------------------------------------------------------------------\r\n\r\nRelease 1.55:\r\n\r\nThis release only addresses some minor formulation issues of the\r\ncommand line such that references are formatted properly to make this\r\nsoftware package acceptable as a JPEG reference software.\r\nNo functional changes.\r\n\r\n--------------------------------------------------------------------------\r\n\r\nRelease 1.56:\r\n\r\nEncoding and reconstruction of 2-component images was actually never\r\nsupported, as it was considered a rather exotic use-case. Now that a\r\nrequest was made, support for 2-components was added and should\r\nhopefully work ok.\r\n\r\n--------------------------------------------------------------------------\r\n\r\nRelease 1.57:\r\n\r\nNewer g++ compiler versions warned about implicit fall-throughs in switch/\r\ncase constructs that are actually harmless. This release adds an autoconf\r\ndetection of such compiler versions, adds consistent comments throughout\r\nthe code.\r\n\r\n--------------------------------------------------------------------------\r\n\r\nRelease 1.58:\r\n\r\nThis release fixes multiple spelling errors in the file, thanks to\r\nMathieu Mmalaterre for finding and fixing them. The release also\r\naddresses multiple race conditions and improves stability and robustness\r\non invalid streams. Thanks to seviezhou for providing codestreams that\r\ntriggered these defects. In particular, the following defects have\r\nbeen found:\r\n\r\n- when a codestream with unsupported upsampling specification (beyond\r\n  18477-1) was found, the code crashed.\r\n- JPEG LS single component scans did not check whether there is actually\r\n  only a single component referenced in the scan.\r\n- An invalid DC category in the sequential scan could have caused a\r\n  crash in the follow-up decoding.\r\n- AC-coded lossless JPEG scans with horizontal subsampling factors\r\n  trashed memory.\r\n- MCU sizes of 0 remained undetected and caused crashes due to a\r\n  division-by-zero exception.\r\n- The code did not check whether a scan references the same component\r\n  more than once and could have failed with strange effects then.\r\n- The code did not handle EOF conditions in the frame header\r\n  gracefully.\r\n\r\n--------------------------------------------------------------------------\r\n\r\nRelease 1.59:\r\n\r\nThis release addresses a defect in the MCU handling for JPEG LS scans.\r\nThe previous code forgot to reset the JPEG LS state variables on MCU\r\nscan boundaries, thus defeating the independent decodability of MCUs\r\nif restart markers are inserted into the stream. Thanks to Spyros for\r\ndetecting this defect.\r\n\r\n--------------------------------------------------------------------------\r\n\r\nRelease 1.60:\r\n\r\nA specially crafted bitstream depending on line-based JPEG processes\r\ncould trigger a segfault because source data the reconstruction\r\nprocess depended upon were not available. This has been fixed.\r\n\r\n--------------------------------------------------------------------------\r\n\r\nRelease 1.61:\r\n\r\nThe restart interval for JPEG LS streams, specifically, is allowed to\r\nbe larger than 2^16. Modified the DRI marker accordingly. Unfortunately,\r\nas the initial tables section of a codestream of JPEG and JPEG LS is\r\nidentical, JPEG files with an invalid DRI marker size will also be\r\naccepted as valid.\r\n\r\n--------------------------------------------------------------------------\r\n\r\nRelease 1.62:\r\n\r\nThe quantization table could contain entries larger than 255 for the 8-bit\r\nDCT process, even though the standard prohibits this. Now the quantization\r\ntable entries are clipped to the allowed range.\r\nAdded an option -bl to force encoding in the baseline sequential process.\r\nAdded options to read the quantization tables from files rather than using\r\nthe built-in defaults.\r\n\r\n--------------------------------------------------------------------------\r\n\r\nRelease 1.63:\r\n\r\nIn case the decoder was started with an image containing an alpha channel,\r\ni.e. a 18477-9 image, and no output file for the alpha channel was\r\nprovided, the decoder crashed. This issue was fixed, the alpha channel is\r\nnow in this case simply disregarded. Note that you can define the output\r\nfile for the alpha channel with the \"-al\" command line option.\r\n\r\n--------------------------------------------------------------------------\r\n\r\nRelease 1.64:\r\n\r\nThe lossless scan, the arithmetically coded lossless scan and the\r\narithmetically coded sequential scan could run into cases where an\r\nout-of-bounds symbol triggered and out-of-bounds array access and could\r\nhave crashed the decoder. The code is now more carefully changing the\r\nvalidity of the symbols and aborts with an error if it finds illegal\r\ncodes.\r\n\r\n--------------------------------------------------------------------------\r\n\r\nFor license conditions, please check the file README.license in this\r\ndirectory.\r\n\r\nFinally, I want to thank Accusoft and the Computing Center of the University of\r\nStuttgart and Fraunhofer IIS for sponsoring this project.\r\n\r\nThomas Richter, February 2022\r\n\r\n-------------------------------------------------------------------------------------\r\n", "Revision 0.10\r\n-----------------------------\r\n\r\nFirst release of libjpeg to the public.\r\n\r\n\r\nRevision 0.11\r\n-----------------------------\r\n\r\nApparently, the demo frontend code used the \r\nnon-binary mode to open the output files,\r\ncreating corrupt files under platforms where\r\nsuch modes include a text conversion. Fixed.\r\n\r\nThe configure script that tested for the avail-\r\nibility of setjmp did not work on those platforms\r\nwhere setjmp is a macro rather than a function.\r\nThe test for setjmp is now omitted, depending solely\r\non the availibility of longjmp.\r\n\r\n\r\nRevision 0.20\r\n-----------------------------\r\n\r\nThis release fixes a bug in the residual huffman decoder\r\nscan where I forgot to multiply the residuals with the\r\nquantization size. This did not affect lossless coding,\r\nbut only near-lossless coding.\r\nFurthermore, this release adds coding of high-bitdepth\r\nimages with a standard 8bpp JPEG fallback stream. For\r\nthat, simply supply the image to be coded on the command\r\nline and add the \"-r\" option to enable residual coding.\r\nTo use the conforming, but typically ill-supported 12bpp\r\nmode of JPEG, do not use \"-r\".\r\n\r\n\r\nRevision 0.30\r\n-----------------------------\r\n\r\nThis release introduces a new coding strategy for lossless\r\nand high-dynamic range coding. Unlike former releases,\r\nthis release runs an additional reversible color transformation\r\non the residual data, followed by a lossless (scaled) Hadamard\r\ntransformation to avoid color banding in extreme cases. It\r\nalso adds an additional tone mapping curve (or curves) to be\r\nspecified on encoding that allow a higher quality of the\r\nLDR base layer.\r\n\r\nRevision 0.50\r\n-----------------------------\r\n\r\nThe new features in this version are a refined residual coding algorithm that\r\nincludes a runlength scan to improve coding efficiency for low-quality extensions\r\nlayers. This release also features a new HDR compression in the DCT domain that\r\nuses the known JPEG refinement scans of progressive coding to improve the resolution\r\nfrom 8 bit to 12 bit in a completely backwards compatible way. Additionally, the\r\nsoftware was unit-tested with the 10918-2 (JPEG part 2) test streams and various\r\nbugs of the lossless predictive arithmetic coding and lossless predictive coding\r\nwere removed. New command line switches allow the encoding of pfm images (floating\r\npoint, for high-dynamic range) and the number of extension refinement scans.\r\n\r\nRevision 0.60\r\n-----------------------------\r\n\r\nOnly minor modifications were made in this release. The Huffman coder now fills\r\nundefined bits at the end of the entropy coded segment by ones, and potentially\r\ninserts a stuffed zero byte. Note that the standard defines this only in an\r\ninformative note, so it is likely not required. The insertion of a stuffed zero\r\nbyte at this position might also be unnecessary as a parser should identify the\r\nfirst 0xff byte ahead of the marker as \"fill byte\".\r\n\r\nResidual coding has been reworked and uses now a simple progressive scan with the\r\nspecial DC case removed. The performance does not differ significantly, and it\r\nmakes integration into legacy software or hardware easier. \r\n\r\nDefault Huffman tables are now also provided for progressive and lossless scans,\r\nthus optimizing the Huffman tables just for these scan types is no longer \r\nnecessary. Residual or refinement scans still require this argument, though.\r\n\r\nUsage of the codec does not differ from previous releases, though codestreams\r\nusing the residual coding mode are not compatible to those generated by 0.5.\r\nNote that this is still experimental software and the codestream might still\r\nchange until the ISO committee decides on the technology.\r\n\r\nFinally, a couple of workarounds for earlier releases of the g++ compiler have\r\nbeen added.\r\n\r\n\r\nRelease 0.7:\r\n-----------------------------\r\n\r\nThis is a major release of the software which adds a lot of missing\r\nfunctionality and brings it up to date to the latest working draft of\r\n18477-2. In specific, boxes are now written according to the latest\r\nspecification, and three proposals to encode HDR data are now\r\nimplemented: mult1 (quotient method), mult2 (overflow/truncation\r\nmethod) and residual coding. The HDR to LDR non-linear point\r\ntransformation can now be explicitly specified giving a file name on\r\nthe command line (-gf option) which must contain 256 lines, one line\r\nper LDR input sample value. Each line shall contain an ASCII encoded\r\ndecimal number, the output value a reconstructed LDR sample value is\r\nmapped to.\r\n\r\nThis release also supports (finally) subsampling in residual and\r\nmultiplicative coding, just specify the subsampling factors. In this\r\nrelease, the frontend only allows the same subsampling factors for\r\nboth images (legacy and residual) though the back-end is more powerful\r\nand would allow arbitrary combinations.  Lossless coding by residuals\r\nis also supported, residual image subsampling factors are set to 1:1:1\r\nin case the quality of the residual is 100.\r\n\r\nThe SERMS DCT that was removed in the earlier releases is now back and\r\ncan be enabled by the \"-l\" option. Note well that you also need to\r\nspecify \"-c\" to disable the YCbCr transformation.\r\n\r\nThe experimental VESA coding modes that have been part of this code\r\nare now gone for good as they are not part of the specification.\r\n\r\nA huge number of bugs have been fixed, in specific for the handling of\r\ngrey-only images. These should work fine now.\r\n\r\nThis release supports now two variations of the encoding mode,\r\nopen-loop and closed-loop.  In closed-loop coding, which was the\r\ndefault so far, the residual/multiplicative encoder is feed by the\r\nresidual (additive or multiplicative) of the reconstructed LDR and\r\noriginal image. For openloop coding, the encoder does not need to go\r\nthrough a full encoding/decoding cycle of the legacy stream and feeds\r\nin the legacy image derived from the original image to the residual\r\ncoder right away. NOTE THAT THIS MEANS THAT LOSSLESS CODING WILL NOT\r\nOPERATIONAL IN OPEN LOOP MODE, and additive residual coding will be\r\nrather pointless. However, this mode does make sense for the\r\nmultiplicative modes. Regardless of whether open or closed loop coding\r\nis used, the encoded codestream is conforming, though coding results\r\nmay be different.\r\n\r\n\r\nRelease 0.71:\r\n-----------------------------\r\n\r\nThis is a minor bugfix release which also adds one functionality, namely\r\nthe encodign of HDR images in the floating point domain via -mult1.\r\nPrevious versions took a round-trip through the integer domain and\r\nhence required output clipping. The direct-float mode can now be enabled\r\nby disabling the output-clipping process with \"-oc\". \r\n\r\nAdditionally, this release fixes two bugs, mostly related to the internal\r\nstream management. Due to an oversight, the marker-peek-ahead logic for\r\nresidual streams did not work, causing a potential race condition\r\nwhen a marker was overlapping a chunk-boundary of the internal stream\r\nrepresentation. Length computation of the internal stream representation\r\nwas also broken on encoding, causing a potential race condition when the\r\nhuffman table marker was overlapping with a chunk boundary. A third\r\nbug, namely a missing EOC at the end of the residual codestream, was\r\nfixed, too.\r\n\r\nRelease 0.72:\r\n-----------------------------\r\n\r\nThis release fixes a one-line oversight in the handling of subsampled \"residual\" coding,\r\nnamely the quantization output buffer did not advance, causing an assertion failure.\r\nThis release fixes the issue.\r\n\r\n\r\n-------------------------------------------------------------------------------------\r\n\r\nRelease 0.8:\r\n\r\nThis is again an update of the software in order to synchronize it with\r\nthe latest Working Draft (proposed CD text) document; that is, boxes\r\nare written now according to the latest specifications. Furthermore, support\r\nfor refinement scans in the residual domain have been added (with -rR),\r\nresidual data is DCT transformed unless lossless coding is desired.\r\nThis release also adds the checksum box, computes the checksum on encoding\r\nand tests it on decoding. In case it does not fit, a warning is generated.\r\n\r\nQuantization setup changed a bit, using now smaller buckets in the residual\r\nstream which avoids the paradoxical situation that a finer base layer\r\nquantization can cause a quality drop for the overall image.\r\n\r\nA serious bug in legacy coding modes was removed that caused the encoder\r\nor decoder to crash if no residual image was present.\r\n\r\nThis version of the encoder also supports encoding and decoding of images\r\nin wider color spaces; for demonstration purposes, it encodes images in the\r\nXYZ colorspace using the command line option -xyz, or -cxyz where the latter\r\nuses a slightly less efficient method how to represent the images.\r\n\r\nAt this time, the text based format is not supported, and support for the\r\ntwo other profiles (-mult1, -mult2) has been temporarely removed until the\r\nstandardization committee provides a clean solution how to integrate them.\r\n\r\n-------------------------------------------------------------------------------------\r\n\r\nRelease 0.9:\r\n\r\nThis is just another update. This update introduces new DCTs, the Z0 DCT from\r\nISO/IEC 23002-2, the Z1a DCT from the same authors and the CD document of this\r\nstandard, and a lifting-based DCT. Tests show that Z0 and the lifting DCT do not \r\nperform very well, so the default is current Z1 and SERMS.\r\nFurthermore, processing of RCT has changed slightly to ensure that the output\r\nis always in-range, not only for 16 bit output.\r\nDCT-bypass entropy coding was extended to use the full Huffman table, and includes\r\nnow special handling for the race-condition of having to code the value 0x8000\r\nwhich was simply not possible before.\r\nThe codestream syntax has been modified again to reflect the latest edition of\r\nthe standard document, namely the CD of 18477-3.\r\nLots of other minor fixes have been made, as for example in the selection and\r\nencoding of the precision of the residual frame and the computation of the\r\nchecksum.\r\n\r\n\r\n-------------------------------------------------------------------------------------\r\n\r\nRelease 0.91:\r\n\r\nThis release fixes a wrong DC offset in the residual coding path that compromized\r\ncompression efficiency, and a wrong computation in the residual bits.\r\n\r\n-------------------------------------------------------------------------------------\r\n\r\nRelease 0.92:\r\n\r\nThis release improves the computation of the LDR to HDR inverse TMO computation for\r\nprofile C and gains by that sometimes up to 2dB in PSNR. It also provides a \"-sp\"\r\ncommand line switch to use separate separate tables, one per component. This may\r\nhelp in case the image contains some extreme colors.\r\n\r\n-------------------------------------------------------------------------------------\r\n\r\nRelease 1.00alpha1:\r\n\r\nThis is the first complete release of the demo software. It adds again support\r\nfor profiles a and b for lossy HDR image coding and follows the new box-based\r\ndesign of 18477-3.\r\n\r\n-------------------------------------------------------------------------------------\r\n\r\nRelease 1.00beta1:\r\n\r\nThis is a fully verified version of the software, i.e. all modes of operation have\r\nbeen tested by an automatic unit test. This of course does not exclude any bugs,\r\nor any modifications before the finalization of the standard.\r\n\r\nIn comparison to the alpha1 release, the following bugs have been fixed:\r\n\r\n- Predictive lossless mode with restart markers forgot to reconstruct the last line\r\nin some configurations.\r\n- Due to an oversight, hierarchical mode did not work in combination with AC coding.\r\n- Hierarchical mode did not work in the \"semi-lossless\" configuration where the finest\r\nframe is defined by a lossless predictive scan.\r\n- Predictive lossless could have forgotten the last line on streams using the DNL marker\r\nto signal the height of the image.\r\n- JPEG LS restart markers did not work in plane and sample interleaved mode. Note,\r\nhowever, that restart marker handling in the JPEG LS reference software is broken and\r\ndoes not follow the specifications. (Defect report is pending.)\r\n- Grey scale coding in profiles A and B did not work.\r\n- Coding in RGB-colorspace did not work in profiles A and B.\r\n- Encoding in JPEG-LS erraneously inserted JPEG XT boxes into the codestream. While this\r\nis harmless, it increases the rate unnecessarily.\r\n\r\n-------------------------------------------------------------------------------------\r\n\r\nRelease 1.00beta2:\r\n\r\nThis release includes the changes made on the standard in the Strasbourg meeting\r\nof the JPEG committee, in particular it includes a rounding mode specifier of\r\nthe CURV boxes. Additionally, it allows now the inclusion of an arbitrary LDR image\r\nwithin profile B. Previous releases only supported the gamma-plus-clamping tone\r\nmapper which was built into the source. In addition to the new features, this\r\nrelease also includes an improved Huffman decoder that should be considerably\r\nfaster than the previous trivial bit-by-bit decoder.\r\n\r\n-------------------------------------------------------------------------------------\r\n\r\nRelease 1.00beta2.2:\r\n\r\nOnly a short fix in the handling of lossless JPEG scans: This release fixes one\r\nissue, namely correct decoding of 16-bit images where the carry-over was not\r\ncomputed correctly. This change required a careful distinction between differential\r\npredictive and regular-predictive mode, which is interestingly not mentioned in\r\nthe specs (probably nobody tested). A second race was fixed in JPEG-LS handling\r\nwhere bit-stuffing could have left a single isolated zero at the end of a JPEG-LS\r\nscan, causing a warning in the upwards marker parser (though no corrupt reconstruction).\r\n\r\n-------------------------------------------------------------------------------------\r\n\r\nRelease 1.20:\r\n\r\nThis version adds support for alpha channels as defined by ISO/IEC 18477-9\r\nto the code. Alpha channels are specified by one-component grey-scale images,\r\nof bit depths between 8 and 16 bits per sample. They may also consist of\r\nfloating point samples between 0 and 1. To add an alpha channel, use the command\r\nline options -al <filename> -aq <quality> for simple alpha channels of 8 bits per\r\nsample. For more precise alpha channels, residual coding in the alpha domain\r\nmust be enabled with -ar, and an alpha channel residual quality must be specified\r\nwith -aQ <ext-quality>. The coding tools for alpha channels are otherwise identical\r\nfor that of the base image. Alpha coding can be combined with any other coding\r\ntools, i.e. parts 6,7 and 8.\r\n\r\n-------------------------------------------------------------------------------------\r\n\r\nRelease 1.21:\r\n\r\nThis is only a minor maintenance release which removes three experimental DCT\r\nimplementations that are no longer required, fixes two possible un-initialized\r\nvariables and fixes a bug in the box enumeration. Release 1.20 and above started\r\nfor some boxes the box enumeration at zero even though it should start at one.\r\n\r\n-------------------------------------------------------------------------------------\r\n\r\nRelease 1.30:\r\n\r\nThis release fixes a bug in the line-based operation mode that is not available from\r\nthe front end and only works for baseline sequential. Unlike other modes, it does\r\nnot require full internal buffering of the image. It is also synchronized again to\r\nthe latest edition of the standard, offering the additional upscaling in the residual\r\npath for parts 6 and part 7 profile C. It has been cross-tested with other \r\nimplementations, thus interoperability is granted. Clipping for floating-point output\r\nhas been corrected to avoid the representations of NAN and INF.\r\nLast but not least, this release offers the possibility to select between nine different\r\nquantization matrices (-qt 0 to -qt 9), of which -qt 1 is PSNR-optimal and -qt 3 is\r\na good candidate for high visual compression. See the command line parameters for\r\ndetails. Furthermore, the -dz parameter enables a deadzone quantizer that improves\r\nthe compression performance by 0.3 dB on average.\r\n\r\n-------------------------------------------------------------------------------------\r\n\r\nRelease 1.31:\r\n\r\nThis release includes two minor changes that have been made to the specs at the last \r\nWarsaw meeting in June 2015. The order of the FDCT (fixed point DCT) has been adjusted\r\nto match the order of ISO/IEC 23002-2 (MPEG C) and to be consistent with the order of\r\nthe IDCT (integer DCT). Second, the specs allow now Integer Table Lookup boxes with\r\nsample size > 16 bits to allow the usage of a Table lookup in the residual coding\r\npath for part 8 of the specs.\r\n\r\n-------------------------------------------------------------------------------------\r\n\r\nRelease 1.40:\r\n\r\nIn this release, we included additional support for \"full profile\" encoding, i.e.\r\nencoding parameters that do not fit any of the four profiles specified in 18477-7.\r\nUsing such encoding parameters will generate a warning on the command line, but\r\nencoding will proceed anyhow, generating a bitstream that conforms to 18477-7, but\r\nnot to any of the profiles in this standard.\r\n\r\nWith \"-profile a -g 0\" or \"-profile b -g 0\" the encoder will generate a file that\r\nuses an inverse TMO lookup similar to profile C with other encoding parameters\r\nidentical to those defined by profiles A and B.\r\n\r\nThe command line option \"-lr\" will use a logarithmic encoding instead of the gamma\r\nencoding for profile B. Again, this will leave the profile, but will be within the\r\nbounds of 18477-7.\r\n\r\nOther than that, a couple of bug fixes have been made. Profile A and B setup could\r\nnot reset the toe value for the inverse gamma map, due to a typo of one of the\r\nparameters. Profile B accepted a different gamma value than the default, but never\r\ncommunicated it to the core code, i.e. it was simply ignored. Profile B setup ignored\r\nthe epsilon values for numerator and denomiator, and they were communicated wrongly\r\ninto the core code. This was corrected, and epsilons can now be specified on the\r\ncommand line. The JPEG LS part-2 encoder was broken due to a modification of the\r\ncolor transformer factory, and the (non-standardized, proprietary) residual\r\nrefinement arithmetic coding scan mode did not work correctly by depending on a non-\r\nexisting context.\r\n\r\n-------------------------------------------------------------------------------------\r\n\r\nRelease 1.50:\r\n\r\nThis release fixes encoding of ISO/IEC 18477-8 if the IDCT was selected as\r\ntransformation in the extension layer and refinement scans were added, i.e.\r\nthe command line options -rl -rR 4 created invalid codestreams. Previous\r\nreleases used the wrong type of refinement scan (dct bypass refinement instead\r\nof regular refinement) and hence broke reconstruction. Furthermore, previous\r\nreleases no longer allowed near lossless coding with DCT bypass. Instead, regular\r\nDCT coding conforming to ISO/IEC 18477-7 was used. To enable the near-lossless\r\nDCT bypass mode, use the new option \"-ro\" now.\r\n\r\nProfile B encoding could potentially create codestreams that run into\r\nclipping of the extension channel; this always happens if the denominator is\r\nlarger than 1, and has to happen according to Annex C of ISO/IEC 18477-3:2015.\r\nThis release avoids this issue by adjusting the exposure value such that\r\nthe denominator always remains smaller than 1.\r\n\r\n--------------------------------------------------------------------------\r\n\r\nRelease 1.51:\r\n\r\nIf the JPEG-XT markers were delayed to the frame-header intead the global\r\nheader, the previous code did not built up the necessary infrastructure\r\nto compute the checksum and hence could not verify the checksum in such\r\na condition. The 1.51 release fixes this problem.\r\n\r\n-------------------------------------------------------------------------------------\r\n\r\nRelease 1.52:\r\n\r\nThis file is an updated/enhanced version of the 1.50 release of\r\nthe JPEG XT demo software found on https://github.com/thorfdbg/. It\r\nincludes additional features presented in the paper\r\n\"JPEG on Steroids : Common Optimization Techniques for JPEG Image Compression\"\r\nby the same author.\r\n\r\nIn specific, the following command line flags are *NEW* to this version and\r\nare available only as a contribution to ICIP 2016:\r\n\r\n-oz:\t      This enables the dynamic programming algorithm to enhance\r\nthe rate-distortion performance by soft-threshold quantization. It has been\r\nused for the tests in section 3.3 of the paper.\r\n\r\n-dr: \t     This enables the smart de-ringing algorithm that has been used\r\nin section 3.6.\r\n\r\nAdditionally, the following switches have been used for other subsections\r\nof the paper; they are not new to this distribution but available as\r\npart of the regular libjpeg distribution at github or www.jpeg.org:\r\n\r\n-s 1x1,2x2,2x2:\t    Enable 420 subsampling (444 is default)\r\n-s 1x1,2x1,2x1:\t    Enable 422 subsampling (444 is default)\r\n-qt n (n=0..8)\t    Use quantization matrix n.\r\n      \t\t    In the paper, n=1 (flat) was used for PSNR-optimized\r\n\t\t    coding, unless otherwise noted.\r\n-dz\t\t    The deadzone quantizer in section 3.3\r\n\t\t    (simpler than -oz)\r\n-v\t\t    Enable coding in processive mode (section 3.5)\r\n-v -qv\t\t    Optimized progressive mode (section 3.5)\r\n-h \t\t    Optimized Huffman coding (always used, unless noted\r\n\t\t    otherwise, see section 3.4)\r\n\r\n--------------------------------------------------------------------------\r\n\r\nRelease 1.53:\r\n\r\nThis release includes additional functionality to inject markers, or\r\nretrieve markers from a codestream while reading. For that, set\r\nthe JPGTAG_ENCODER_STOP tag of the JPEG::Write() call to a bitmask\r\nwhere the encoder should interrupt writing data (this flag already\r\nexisted before) then write custom data with JPEG::WriteMarker(), then\r\ncontinue with JPEG::Write(). On decoding, set JPGTAG_DECODER_STOP to\r\na bitmask where to stop for markers, then identify markers with\r\nJPEG::PeekMarker(), and retrieve them with JPEG::ReadMarker(). Details\r\ncan be found in cmd/encodec.cpp for encoding, and cmd/reconstruct.cpp.\r\n\r\nOtherwise, no functional changes.\r\n\r\n--------------------------------------------------------------------------\r\n\r\nRelease 1.54:\r\n\r\nIn this release, upsampling has been made conforming to the latest\r\ncorrigendum of 18477-1 and 18477-8. In particular, upsampling is now\r\nby design always centered and never co-sited. The co-sited upsampling\r\nprocedure is still included in the source code, but never executed.\r\n\r\n--------------------------------------------------------------------------\r\n\r\nRelease 1.55:\r\n\r\nThis release only addresses some minor formulation issues of the\r\ncommand line such that references are formatted properly to make this\r\nsoftware package acceptable as a JPEG reference software.\r\nNo functional changes.\r\n\r\n--------------------------------------------------------------------------\r\n\r\nRelease 1.56:\r\n\r\nEncoding and reconstruction of 2-component images was actually never\r\nsupported, as it was considered a rather exotic use-case. Now that a\r\nrequest was made, support for 2-components was added and should\r\nhopefully work ok.\r\n\r\n--------------------------------------------------------------------------\r\n\r\nRelease 1.57:\r\n\r\nNewer g++ compiler versions warned about implicit fall-throughs in switch/\r\ncase constructs that are actually harmless. This release adds an autoconf\r\ndetection of such compiler versions, adds consistent comments throughout\r\nthe code, and disables the compiler warning were necessary.\r\n\r\n--------------------------------------------------------------------------\r\n\r\nRelease 1.58:\r\n\r\nThis release fixes multiple spelling errors in the file, thanks to\r\nMathieu Mmalaterre for finding and fixing them. The release also\r\naddresses multiple race conditions and improves stability and robustness\r\non invalid streams. Thanks to seviezhou for providing codestreams that\r\ntriggered these defects. In particular, the following defects have\r\nbeen found:\r\n\r\n- when a codestream with unsupported upsampling specification (beyond\r\n  18477-1) was found, the code crashed.\r\n- JPEG LS single component scans did not check whether there is actually\r\n  only a single component referenced in the scan.\r\n- An invalid DC category in the sequential scan could have caused a\r\n  crash in the follow-up decoding.\r\n- AC-coded lossless JPEG scans with horizontal subsampling factors\r\n  trashed memory.\r\n- MCU sizes of 0 remained undetected and caused crashes due to a\r\n  division-by-zero exception.\r\n- The code did not check whether a scan references the same component\r\n  more than once and could have failed with strange effects then.\r\n- The code did not handle EOF conditions in the frame header\r\n  gracefully.\r\n\r\n--------------------------------------------------------------------------\r\n\r\nRelease 1.59:\r\n\r\nThis release addresses a defect in the MCU handling for JPEG LS scans.\r\nThe previous code forgot to reset the JPEG LS state variables on MCU\r\nscan boundaries, thus defeating the independent decodability of MCUs\r\nif restart markers are inserted into the stream. Thanks to Spyros for\r\ndetecting this defect.\r\n\r\n--------------------------------------------------------------------------\r\n\r\nRelease 1.60:\r\n\r\nA specially crafted bitstream depending on line-based JPEG processes\r\ncould trigger a segfault because source data the reconstruction\r\nprocess depended upon were not available. This has been fixed.\r\n\r\n--------------------------------------------------------------------------\r\n\r\nRelease 1.61:\r\n\r\nThe restart interval for JPEG LS streams, specifically, is allowed to\r\nbe larger than 2^16. Modified the DRI marker accordingly. Unfortunately,\r\nas the initial tables section of a codestream of JPEG and JPEG LS is\r\nidentical, JPEG files with an invalid DRI marker size will also be\r\naccepted as valid.\r\n\r\n--------------------------------------------------------------------------\r\n\r\nRelease 1.62:\r\n\r\nThe quantization table could contain entries larger than 255 for the 8-bit\r\nDCT process, even though the standard prohibits this. Now the quantization\r\ntable entries are clipped to the allowed range.\r\nAdded an option -bl to force encoding in the baseline sequential process.\r\nAdded options to read the quantization tables from files rather than using\r\nthe built-in defaults.\r\n\r\n--------------------------------------------------------------------------\r\n\r\nRelease 1.63:\r\n\r\nIn case the decoder was started with an image containing an alpha channel,\r\ni.e. a 18477-9 image, and no output file for the alpha channel was\r\nprovided, the decoder crashed. This issue was fixed, the alpha channel is\r\nnow in this case simply disregarded. Note that you can define the output\r\nfile for the alpha channel with the \"-al\" command line option.\r\n\r\n--------------------------------------------------------------------------\r\n\r\nRelease 1.64:\r\n\r\nThe lossless scan, the arithmetically coded lossless scan and the\r\narithmetically coded sequential scan could run into cases where an\r\nout-of-bounds symbol triggered and out-of-bounds array access and could\r\nhave crashed the decoder. The code is now more carefully changing the\r\nvalidity of the symbols and aborts with an error if it finds illegal\r\ncodes.\r\n\r\n--------------------------------------------------------------------------\r\n", "/*************************************************************************\n\n    This project implements a complete(!) JPEG (Recommendation ITU-T\n    T.81 | ISO/IEC 10918-1) codec, plus a library that can be used to\n    encode and decode JPEG streams. \n    It also implements ISO/IEC 18477 aka JPEG XT which is an extension\n    towards intermediate, high-dynamic-range lossy and lossless coding\n    of JPEG. In specific, it supports ISO/IEC 18477-3/-6/-7/-8 encoding.\n\n    Note that only Profiles C and D of ISO/IEC 18477-7 are supported\n    here. Check the JPEG XT reference software for a full implementation\n    of ISO/IEC 18477-7.\n\n    Copyright (C) 2012-2018 Thomas Richter, University of Stuttgart and\n    Accusoft. (C) 2019-2020 Thomas Richter, Fraunhofer IIS.\n\n    This program is available under two licenses, GPLv3 and the ITU\n    Software licence Annex A Option 2, RAND conditions.\n\n    For the full text of the GPU license option, see README.license.gpl.\n    For the full text of the ITU license option, see README.license.itu.\n    \n    You may freely select between these two options.\n\n    For the GPL option, please note the following:\n\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n*************************************************************************/\n/*\n**\n** This is the top-level bitmap requester that distributes data to\n** image scales on encoding, and collects data from image scales on\n** decoding. It also keeps the top-level color transformer and the\n** toplevel subsampling expander.\n**\n** $Id: hierarchicalbitmaprequester.cpp,v 1.42 2020/04/08 10:05:41 thor Exp $\n**\n*/\n\n/// Includes\n#include \"control/hierarchicalbitmaprequester.hpp\"\n#include \"control/lineadapter.hpp\"\n#include \"control/linemerger.hpp\"\n#include \"std/string.hpp\"\n#include \"upsampling/downsamplerbase.hpp\"\n#include \"upsampling/upsamplerbase.hpp\"\n#include \"marker/frame.hpp\"\n#include \"marker/component.hpp\"\n#include \"colortrafo/colortrafo.hpp\"\n#include \"codestream/rectanglerequest.hpp\"\n#include \"codestream/tables.hpp\"\n///\n\n/// HierarchicalBitmapRequester::HierarchicalBitmapRequester\n// Construct from a frame - the frame is just a \"dummy frame\"\n// that contains the dimensions, actually a DHP marker segment\n// without any data in it.\nHierarchicalBitmapRequester::HierarchicalBitmapRequester(class Frame *dimensions)\n  : BitmapCtrl(dimensions)\n#if ACCUSOFT_CODE\n  , m_ppDownsampler(NULL), m_ppUpsampler(NULL), \n    m_ppTempIBM(NULL), m_pSmallestScale(NULL), m_pLargestScale(NULL), m_pTempAdapter(NULL),\n    m_pulReadyLines(NULL), m_pulY(NULL), m_pulHeight(NULL),\n    m_ppEncodingMCU(NULL), m_ppDecodingMCU(NULL),\n    m_bSubsampling(false)\n#endif\n{\n}\n///\n\n/// HierarchicalBitmapRequester::~HierarchicalBitmapRequester\nHierarchicalBitmapRequester::~HierarchicalBitmapRequester(void)\n{\n#if ACCUSOFT_CODE\n  class LineAdapter *la;\n  UBYTE i;\n  \n  if (m_ppEncodingMCU) {\n    assert(m_pLargestScale);\n    for(i = 0;i < (m_ucCount << 3);i++) {\n      m_pLargestScale->DropLine(m_ppEncodingMCU[i],i >> 3);\n    }\n    m_pEnviron->FreeMem(m_ppEncodingMCU,sizeof(struct Line *) * m_ucCount * 8);\n  }\n\n  if (m_ppDecodingMCU) {\n    assert(m_pLargestScale);\n    for(i = 0;i < (m_ucCount << 3);i++) {\n      m_pLargestScale->ReleaseLine(m_ppDecodingMCU[i],i >> 3);\n    }\n    m_pEnviron->FreeMem(m_ppDecodingMCU,sizeof(struct Line *) * m_ucCount * 8);\n  }\n\n  //\n  // Dispose the tree of line adapters\n  while((la = m_pLargestScale)) {\n    m_pLargestScale = la->LowPassOf();\n    delete la->HighPassOf();\n    delete la;\n  }\n  delete m_pTempAdapter;\n  \n  if (m_ppDownsampler) {\n    for(i = 0;i < m_ucCount;i++) {\n      delete m_ppDownsampler[i];\n    }\n    m_pEnviron->FreeMem(m_ppDownsampler,m_ucCount * sizeof(class DownsamplerBase *));\n  }\n\n  if (m_ppUpsampler) {\n    for(i = 0;i < m_ucCount;i++) {\n      delete m_ppUpsampler[i];\n    }\n    m_pEnviron->FreeMem(m_ppUpsampler,m_ucCount * sizeof(class UpsamplerBase *));\n  }\n\n  if (m_ppTempIBM) {\n    for(i = 0;i < m_ucCount;i++) {\n      delete m_ppTempIBM[i];\n    }\n    m_pEnviron->FreeMem(m_ppTempIBM,m_ucCount * sizeof(struct ImageBitMap *));\n  }\n\n  if (m_pulReadyLines)\n    m_pEnviron->FreeMem(m_pulReadyLines,m_ucCount * sizeof(ULONG));\n\n  if (m_pulY)\n    m_pEnviron->FreeMem(m_pulY,m_ucCount * sizeof(ULONG));\n\n  if (m_pulHeight)\n    m_pEnviron->FreeMem(m_pulHeight,m_ucCount * sizeof(ULONG));\n#endif\n}\n///\n\n/// HierarchicalBitmapRequester::BuildCommon\n// Build common structures for encoding and decoding\n#if ACCUSOFT_CODE\nvoid HierarchicalBitmapRequester::BuildCommon(void)\n{\n  BitmapCtrl::BuildCommon();\n  if (m_ppTempIBM == NULL) {\n    m_ppTempIBM = (struct ImageBitMap **)m_pEnviron->AllocMem(sizeof(struct ImageBitMap **) * m_ucCount);\n    memset(m_ppTempIBM,0,sizeof(struct ImageBitMap *) * m_ucCount);\n    for (UBYTE i = 0;i < m_ucCount;i++) {\n      m_ppTempIBM[i] = new(m_pEnviron) struct ImageBitMap();\n    }\n  }\n\n  if (m_pulReadyLines == NULL) {\n    m_pulReadyLines = (ULONG *)m_pEnviron->AllocMem(sizeof(ULONG) * m_ucCount);\n    memset(m_pulReadyLines,0,sizeof(ULONG) * m_ucCount);\n  }\n\n  if (m_pulY == NULL) {\n    m_pulY = (ULONG *)m_pEnviron->AllocMem(sizeof(ULONG) * m_ucCount);\n    memset(m_pulY,0,sizeof(ULONG) * m_ucCount);\n  }\n\n  if (m_pulHeight == NULL) {\n    m_pulHeight = (ULONG *)m_pEnviron->AllocMem(sizeof(ULONG) * m_ucCount);\n    for(UBYTE i = 0;i < m_ucCount;i++) {\n      class Component *comp = m_pFrame->ComponentOf(i);\n      UBYTE suby            = comp->SubYOf();\n      m_pulHeight[i]        = (m_ulPixelHeight + suby - 1) / suby;\n    }\n  }\n}\n#endif\n///\n\n/// HierarchicalBitmapRequester::PrepareForEncoding\n// First time usage: Collect all the information for encoding.\n// May throw on out of memory situations\nvoid HierarchicalBitmapRequester::PrepareForEncoding(void)\n{\n#if ACCUSOFT_CODE\n  \n  BuildCommon();\n\n  if (m_ppEncodingMCU == NULL) {\n    m_ppEncodingMCU = (struct Line **)m_pEnviron->AllocMem(sizeof(struct Line *) * m_ucCount *8);\n    memset(m_ppEncodingMCU,0,sizeof(struct Line *) * m_ucCount * 8);\n  }\n  \n  if (m_ppDownsampler == NULL) {\n    m_ppDownsampler = (class DownsamplerBase **)m_pEnviron->AllocMem(sizeof(class DownsamplerBase *) * m_ucCount);\n    memset(m_ppDownsampler,0,sizeof(class DownsamplerBase *) * m_ucCount);\n    \n    for(UBYTE i = 0;i < m_ucCount;i++) {\n      class Component *comp = m_pFrame->ComponentOf(i);\n      UBYTE sx = comp->SubXOf();\n      UBYTE sy = comp->SubYOf();\n\n      if (sx > 1 || sy > 1) {\n        m_ppDownsampler[i] = DownsamplerBase::CreateDownsampler(m_pEnviron,sx,sy,\n                                                                m_ulPixelWidth,m_ulPixelHeight,\n                                                                m_pFrame->TablesOf()->\n                                                                isDownsamplingInterpolated());\n        m_bSubsampling     = true;\n      }\n    }\n  }\n\n  if (m_pLargestScale)\n    m_pLargestScale->PrepareForEncoding();\n#endif\n}\n///\n\n/// HierarchicalBitmapRequester::PrepareForDecoding\n// First time usage: Collect all the information for encoding.\n// May throw on out of memory situations\nvoid HierarchicalBitmapRequester::PrepareForDecoding(void)\n{\n#if ACCUSOFT_CODE\n\n  UBYTE i;\n\n  BuildCommon();\n\n  if (m_ppDecodingMCU == NULL) {\n    m_ppDecodingMCU = (struct Line **)m_pEnviron->AllocMem(sizeof(struct Line *) * m_ucCount*8);\n    memset(m_ppDecodingMCU,0,sizeof(struct Line *) * m_ucCount * 8);\n  }\n\n  if (m_ppUpsampler == NULL) {\n    m_ppUpsampler = (class UpsamplerBase **)m_pEnviron->AllocMem(sizeof(class UpsamplerBase *) * m_ucCount);\n    memset(m_ppUpsampler,0,sizeof(class Upsampler *) * m_ucCount);\n\n    for(i = 0;i < m_ucCount;i++) {\n      class Component *comp = m_pFrame->ComponentOf(i);\n      UBYTE sx = comp->SubXOf();\n      UBYTE sy = comp->SubYOf();\n\n      if (sx > 1 || sy > 1) {\n        m_ppUpsampler[i] = UpsamplerBase::CreateUpsampler(m_pEnviron,sx,sy,\n                                                          m_ulPixelWidth,m_ulPixelHeight,\n                                                          m_pFrame->TablesOf()->isChromaCentered());\n        m_bSubsampling   = true;\n      }\n    }\n  }\n\n  if (m_pLargestScale)\n    m_pLargestScale->PrepareForDecoding();\n#endif\n}\n///\n\n/// HierarchicalBitmapRequester::ColorTrafoOf\n// Return the color transformer responsible for this scan.\nclass ColorTrafo *HierarchicalBitmapRequester::ColorTrafoOf(bool encoding,bool disabletorgb)\n{\n  return m_pFrame->TablesOf()->ColorTrafoOf(m_pFrame,NULL,PixelTypeOf(),\n                                            encoding,disabletorgb);\n}\n///\n\n/// HierarchicalBitmapRequester::AddImageScale\n// As soon as a frame is parsed off, or created: Add another scale to the image.\n// The boolean arguments identify whether the reference frame, i.e. what is\n// buffered already from previous frames, will be expanded.\nvoid HierarchicalBitmapRequester::AddImageScale(class Frame *frame,bool expandh,bool expandv)\n{\n#if ACCUSOFT_CODE\n  if (m_pLargestScale == NULL) {\n    assert(m_pSmallestScale == NULL);\n    assert(expandh == false && expandv == false);\n    // Actually, this is the smallest scale... as it is the first we build.\n    m_pLargestScale  = frame->BuildLineAdapter();\n    m_pSmallestScale = m_pLargestScale;\n    frame->SetImageBuffer(m_pLargestScale);\n  } else {\n    class LineMerger *merger;\n    // Two things need to be build: The adapter to the new band, and the merger\n    // that merges this band with the output and scales the result\n    // apropriately.\n    assert(m_pTempAdapter == NULL);\n    // This object will pull out lines from the new high-pass...\n    m_pTempAdapter   = frame->BuildLineAdapter();\n    // ...and this guy will merge them with what we currently have.\n    merger           = new(m_pEnviron) class LineMerger(frame,m_pLargestScale,m_pTempAdapter,\n                                                        expandh,expandv);\n    //\n    // And this becomes the next largest scale.\n    m_pLargestScale  = merger;\n    // and controls now the life-time of its children.\n    frame->SetImageBuffer(m_pTempAdapter);\n    m_pTempAdapter   = NULL; \n  }\n#else\n  NOREF(frame);\n  NOREF(expandh);\n  NOREF(expandv);\n#endif\n}\n///\n\n/// HierarchicalBitmapRequester::GenerateDifferentialImage\n// After having written the previous image, compute the differential from the downscaled\n// and-re-upscaled version and push it into the next frame, collect the\n// residuals, make this frame ready for encoding, and retrieve the downscaling\n// data.\nvoid HierarchicalBitmapRequester::GenerateDifferentialImage(class Frame *target,\n                                                            bool &hexp,bool &vexp)\n{\n#if ACCUSOFT_CODE\n  class LineAdapter *lap = m_pLargestScale;\n\n  while(lap) {\n    // The target frame must be one of the high-passes. The frame of a line\n    // adapter is that of the high-pass, so we can check for it.\n    if (lap->HighPassOf()->FrameOf() == target) {\n      class LineMerger *lm = (class LineMerger *)lap;\n      lm->GenerateDifferentialImage();\n      hexp = lm->isHorizontallyExpanding();\n      vexp = lm->isVerticallyExpanding();\n      return;\n    }\n    lap = lap->LowPassOf();\n  }\n  assert(!\"target band not found\");\n#else\n  NOREF(target);\n  NOREF(hexp);\n  NOREF(vexp);\n  JPG_THROW(NOT_IMPLEMENTED,\"HierarchicalBitmapRequester::GenerateDifferentialImage\",\n            \"Lossless JPEG not available in your code release, please contact Accusoft for a full version\");\n#endif\n}\n///\n\n/// HierarchicalBitmapRequester::DefineRegion\n// Define a single 8x8 block starting at the x offset and the given\n// line, taking the input 8x8 buffer.\n#if ACCUSOFT_CODE\nvoid HierarchicalBitmapRequester::DefineRegion(LONG x,const struct Line *const *line,\n                                               const LONG *buffer,UBYTE comp)\n{\n  int cnt = 8;\n  \n  assert(comp < m_ucCount);\n  NOREF(comp);\n\n  x <<= 3;\n  \n  do {\n    if (*line) memcpy((*line)->m_pData + x,buffer,8 * sizeof(LONG));\n    buffer += 8;\n    line++;\n  } while(--cnt);\n}\n#endif\n///\n\n/// HierarchicalBitmapRequester::FetchRegion\n// Define a single 8x8 block starting at the x offset and the given\n// line, taking the input 8x8 buffer.\n#if ACCUSOFT_CODE\nvoid HierarchicalBitmapRequester::FetchRegion(LONG x,const struct Line *const *line,LONG *buffer)\n{\n  int cnt = 8;\n  do {\n    if (*line) \n      memcpy(buffer,(*line)->m_pData + (x << 3),8 * sizeof(LONG));\n    buffer += 8;\n    line++;\n  } while(--cnt);\n}\n#endif\n///\n\n/// HierarchicalBitmapRequester::Allocate8Lines\n// Get the next block of eight lines of the image\n#if ACCUSOFT_CODE\nvoid HierarchicalBitmapRequester::Allocate8Lines(UBYTE c)\n{\n  int cnt;\n  ULONG y = m_pulY[c];\n  //\n  // Allocate a line block from the encoding line adapter.\n  for(cnt = 0;cnt < 8 && y < m_pulHeight[c];cnt++) {\n    assert(m_ppEncodingMCU[cnt | (c << 3)] == NULL);\n    m_ppEncodingMCU[cnt | (c << 3)] = m_pLargestScale->AllocateLine(c);\n    y++;\n  }\n}\n#endif\n///\n\n/// HierarchicalBitmapRequester::Push8Lines\n// Advance the image line pointer by the next eight lines\n// which is here a \"pseudo\"-MCU block.\n#if ACCUSOFT_CODE\nvoid HierarchicalBitmapRequester::Push8Lines(UBYTE c)\n{\n  int cnt;\n  ULONG y = m_pulY[c];\n  //\n  for(cnt = 0;cnt < 8 && y < m_pulHeight[c];cnt++) {\n    assert(m_ppEncodingMCU[cnt | (c << 3)]);\n    m_pLargestScale->PushLine(m_ppEncodingMCU[cnt | (c << 3)],c);\n    m_ppEncodingMCU[cnt | (c << 3)] = NULL;\n    y++;\n  }\n\n  m_pulY[c] = y;\n}\n#endif\n///\n\n/// HierarchicalBitmapRequester::Pull8Lines\n// Pull 8 lines from the top-level and place them into\n// the decoder MCU.\n#if ACCUSOFT_CODE\nvoid HierarchicalBitmapRequester::Pull8Lines(UBYTE c)\n{ \n int cnt;\n  ULONG y = m_pulY[c];\n  //\n  // Allocate a line block from the encoding line adapter.\n  for(cnt = 0;cnt < 8 && y < m_pulHeight[c];cnt++) {\n    assert(m_ppDecodingMCU[cnt | (c << 3)] == NULL);\n    m_ppDecodingMCU[cnt | (c << 3)] = m_pLargestScale->GetNextLine(c);\n    y++;\n  }\n}\n#endif\n///\n\n/// HierarchicalBitmapRequester::Release8Lines\n// Release the currently buffered decoder MCU for the given component.\n#if ACCUSOFT_CODE\nvoid HierarchicalBitmapRequester::Release8Lines(UBYTE c)\n{ \n  int cnt;\n  ULONG y = m_pulY[c];\n  //\n  for(cnt = 0;cnt < 8 && y < m_pulHeight[c];cnt++) {\n    assert(m_ppDecodingMCU[cnt | (c << 3)]);\n    m_pLargestScale->ReleaseLine(m_ppDecodingMCU[cnt | (c << 3)],c);\n    m_ppDecodingMCU[cnt | (c << 3)] = NULL;\n    y++;\n  }\n}\n#endif\n///\n\n/// HierarchicalBitmapRequester::CropEncodingRegion\n// First step of a region encoder: Find the region that can be pulled in the next step,\n// from a rectangle request. This potentially shrinks the rectangle, which should be\n// initialized to the full image.\nvoid HierarchicalBitmapRequester::CropEncodingRegion(RectAngle<LONG> &region,const struct RectangleRequest *)\n{ \n#if ACCUSOFT_CODE\n  int i;\n\n  ClipToImage(region);\n\n  // Find the region to request.\n  for(i = 0;i < m_ucCount;i++) {\n    if (m_pulReadyLines[i] < ULONG(region.ra_MinY))\n      region.ra_MinY = m_pulReadyLines[i];\n  }\n#else\n  NOREF(region);\n#endif\n}\n///\n\n/// HierarchicalBitmapRequester::RequestUserDataForEncoding\n// Request user data for encoding for the given region, potentially clip the region to the\n// data available from the user.\nvoid HierarchicalBitmapRequester::RequestUserDataForEncoding(class BitMapHook *bmh,RectAngle<LONG> &region,bool alpha)\n{\n#if ACCUSOFT_CODE\n  int i;\n\n  m_ulMaxMCU = MAX_ULONG;\n  \n  for(i = 0;i < m_ucCount;i++) {\n    ULONG max;\n    //\n    // Components are always requested completely on encoding.\n    RequestUserData(bmh,region,i,alpha);\n    // All components must have the same sample precision here.\n    max = (m_ppBitmap[i]->ibm_ulHeight - 1) >> 3;\n    if (max < m_ulMaxMCU)\n      m_ulMaxMCU = max; \n    if (LONG(m_ppBitmap[i]->ibm_ulHeight) - 1 < region.ra_MaxY)\n      region.ra_MaxY = m_ppBitmap[i]->ibm_ulHeight - 1;\n  }\n#else\n  NOREF(bmh);\n  NOREF(region);\n  NOREF(alpha);\n#endif\n}\n///\n\n/// HierarchicalBitmapRequester::RequestUserDataForDecoding\n// Pull data buffers from the user data bitmap hook\nvoid HierarchicalBitmapRequester::RequestUserDataForDecoding(class BitMapHook *bmh,RectAngle<LONG> &region,\n                                                             const struct RectangleRequest *rr,bool alpha)\n{\n#if ACCUSOFT_CODE\n  int i;\n\n  ResetBitmaps();\n  \n  if (m_pLargestScale->FrameOf()->WidthOf()   != m_pFrame->WidthOf() ||\n      (m_pLargestScale->FrameOf()->HeightOf() != m_pFrame->HeightOf() &&\n       m_pLargestScale->FrameOf()->HeightOf() != 0 && m_pFrame->HeightOf() != 0)) {\n    JPG_THROW(MALFORMED_STREAM,\"HierarchicalBitmapRequester::ReconstructRegion\",\n              \"hierarchical frame hierarchy is damaged, largest frame does not match the image\");\n  }\n  \n  if (m_ulPixelHeight == 0) {\n    ULONG height = 0;\n    if (m_pLargestScale->FrameOf()->HeightOf() != 0) {\n      height = m_pLargestScale->FrameOf()->HeightOf();\n    } else if (m_pFrame->HeightOf() != 0) {\n      height = m_pFrame->HeightOf();\n    }\n    if (height) {\n      PostImageHeight(height);\n    }\n  }\n  \n  m_ulMaxMCU = MAX_ULONG;\n  \n  for(i = rr->rr_usFirstComponent;i <= rr->rr_usLastComponent;i++) {\n    RequestUserData(bmh,region,i,alpha);\n    ULONG max = (BitmapOf(i).ibm_ulHeight >> 3) - 1;\n    if (max < m_ulMaxMCU)\n      m_ulMaxMCU = max;\n  }\n#else\n  NOREF(bmh);\n  NOREF(region);\n  NOREF(rr);\n  NOREF(alpha);\n#endif\n}\n///\n\n/// HierarchicalBitmapRequester::EncodeRegion\n// Encode a region without downsampling but color transformation\nvoid HierarchicalBitmapRequester::EncodeRegion(const RectAngle<LONG> &region)\n{\n#if ACCUSOFT_CODE\n  class ColorTrafo *ctrafo = ColorTrafoOf(true,false);\n  int i;\n  // \n\n  if (m_bSubsampling) { \n    RectAngle<LONG> r;\n    ULONG minx   = region.ra_MinX >> 3;\n    ULONG maxx   = region.ra_MaxX >> 3;\n    ULONG miny   = region.ra_MinY >> 3;\n    ULONG maxy   = region.ra_MaxY >> 3;\n    ULONG x,y;\n    \n    // First part: Collect the data from\n    // the user and push it into the color transformer buffer.\n    // For that first build the downsampler.\n    for(i = 0;i < m_ucCount;i++) {\n      if (m_ppDownsampler[i]) {\n        m_ppDownsampler[i]->SetBufferedRegion(region);\n      }\n    }\n    \n    for(y = miny,r.ra_MinY = region.ra_MinY;y <= maxy;y++,r.ra_MinY = r.ra_MaxY + 1) {\n      r.ra_MaxY = (r.ra_MinY & -8) + 7;\n      if (r.ra_MaxY > region.ra_MaxY)\n        r.ra_MaxY = region.ra_MaxY;\n\n      for(i = 0;i < m_ucCount;i++) {\n        if (m_ppDownsampler[i] == NULL) {\n          Allocate8Lines(i);\n        }\n      }\n      \n      for(x = minx,r.ra_MinX = region.ra_MinX;x <= maxx;x++,r.ra_MinX = r.ra_MaxX + 1) {\n        r.ra_MaxX = (r.ra_MinX & -8) + 7;\n        if (r.ra_MaxX > region.ra_MaxX)\n          r.ra_MaxX = region.ra_MaxX;\n        \n        for(i = 0;i < m_ucCount;i++) {\n          // Collect the source data.\n          ExtractBitmap(m_ppTempIBM[i],r,i);\n        }\n        \n        //\n        // Run the color transformer.\n        ctrafo->RGB2YCbCr(r,m_ppTempIBM,m_ppCTemp);\n        \n        // Now push the transformed data into either the downsampler, \n        // or the forward DCT block row.\n        for(i = 0;i < m_ucCount;i++) {\n          if (m_ppDownsampler[i]) {\n            // Just collect the data in the downsampler for the time\n            // being. Will be taken care of as soon as it is complete.\n            m_ppDownsampler[i]->DefineRegion(x,y,m_ppCTemp[i]);\n          } else { \n            DefineRegion(x,m_ppEncodingMCU + (i << 3),m_ppCTemp[i],i);\n          }\n        }\n      }\n      //\n      // Advance the quantized rows for the non-subsampled components,\n      // downsampled components will be advanced later.\n      for(i = 0;i < m_ucCount;i++) {\n        m_pulReadyLines[i]    += 8; // somehwere in the buffer.\n        if (m_ppDownsampler[i] == NULL) {\n          Push8Lines(i);\n        } else {\n          LONG bx,by;\n          RectAngle<LONG> blocks;\n          // Collect the downsampled blocks and push that into the DCT.\n          m_ppDownsampler[i]->GetCollectedBlocks(blocks);\n          for(by = blocks.ra_MinY;by <= blocks.ra_MaxY;by++) {\n            Allocate8Lines(i);\n            for(bx = blocks.ra_MinX;bx <= blocks.ra_MaxX;bx++) {\n              LONG src[64]; // temporary buffer, the DCT requires a 8x8 block\n              m_ppDownsampler[i]->DownsampleRegion(bx,by,src);\n              DefineRegion(bx,m_ppEncodingMCU + (i << 3),src,i);\n            }\n            m_ppDownsampler[i]->RemoveBlocks(by);\n            Push8Lines(i);\n          }\n        }\n      }\n    }\n  } else { // No downsampling required, residual coding possible.\n    RectAngle<LONG> r;\n    ULONG minx   = region.ra_MinX >> 3;\n    ULONG maxx   = region.ra_MaxX >> 3;\n    ULONG miny   = region.ra_MinY >> 3;\n    ULONG maxy   = region.ra_MaxY >> 3;\n    ULONG x,y;\n\n    for(y = miny,r.ra_MinY = region.ra_MinY;y <= maxy;y++,r.ra_MinY = r.ra_MaxY + 1) {\n      r.ra_MaxY = (r.ra_MinY & -8) + 7;\n      if (r.ra_MaxY > region.ra_MaxY)\n        r.ra_MaxY = region.ra_MaxY;\n\n      for(i = 0;i < m_ucCount;i++) {\n        Allocate8Lines(i);\n      }\n      \n      for(x = minx,r.ra_MinX = region.ra_MinX;x <= maxx;x++,r.ra_MinX = r.ra_MaxX + 1) {\n        r.ra_MaxX = (r.ra_MinX & -8) + 7;\n        if (r.ra_MaxX > region.ra_MaxX)\n          r.ra_MaxX = region.ra_MaxX;\n\n        for(i = 0;i < m_ucCount;i++) {      \n          ExtractBitmap(m_ppTempIBM[i],r,i);\n        }\n        \n        ctrafo->RGB2YCbCr(r,m_ppTempIBM,m_ppCTemp);\n\n        for(i = 0;i < m_ucCount;i++) {\n          DefineRegion(x,m_ppEncodingMCU + (i << 3),m_ppCTemp[i],i);\n        }\n      }\n      for(i = 0;i < m_ucCount;i++) {\n        Push8Lines(i);\n        m_pulReadyLines[i]   += 8;\n      }\n    }\n  }\n#else\n  NOREF(region);\n#endif\n}\n///\n\n/// HierarchicalBitmapRequester::ReconstructRegion\n// Reconstruct a block, or part of a block\nvoid HierarchicalBitmapRequester::ReconstructRegion(const RectAngle<LONG> &orgregion,const struct RectangleRequest *rr)\n{\n#if ACCUSOFT_CODE\n  class ColorTrafo *ctrafo = ColorTrafoOf(false,!rr->rr_bColorTrafo);\n  UBYTE i;\n  \n  if (m_bSubsampling && rr->rr_bUpsampling) { \n    for(i = rr->rr_usFirstComponent;i <= rr->rr_usLastComponent;i++) {\n      class Component *comp = m_pFrame->ComponentOf(i);\n      UBYTE subx            = comp->SubXOf();\n      UBYTE suby            = comp->SubYOf();\n      class UpsamplerBase *up;  // upsampler\n      LONG bx,by;\n      RectAngle<LONG> blocks;\n      //\n      // Compute the region of blocks\n      assert(subx > 0 && suby > 0);\n      if ((up = m_ppUpsampler[i])) {\n        LONG bwidth           = ((m_ulPixelWidth  + subx - 1) / subx + 7) >> 3;\n        LONG bheight          = ((m_ulPixelHeight + suby - 1) / suby + 7) >> 3;\n        LONG rx               = (subx > 1)?(1):(0);\n        LONG ry               = (suby > 1)?(1):(0);\n        // The +/-1 include additional lines required for subsampling expansion\n        blocks.ra_MinX        = ((orgregion.ra_MinX / subx - rx) >> 3);\n        blocks.ra_MaxX        = ((orgregion.ra_MaxX / subx + rx) >> 3);\n        blocks.ra_MinY        = ((orgregion.ra_MinY / suby - ry) >> 3);\n        blocks.ra_MaxY        = ((orgregion.ra_MaxY / suby + ry) >> 3);\n        // Clip.\n        if (blocks.ra_MinX < 0)        blocks.ra_MinX = 0;\n        if (blocks.ra_MaxX >= bwidth)  blocks.ra_MaxX = bwidth - 1;\n        if (blocks.ra_MinY < 0)        blocks.ra_MinY = 0;\n        if (blocks.ra_MaxY >= bheight) blocks.ra_MaxY = bheight - 1;\n        up->SetBufferedRegion(blocks); // also removes the rectangle of blocks already buffered.\n        //\n        for(by = blocks.ra_MinY;by <= blocks.ra_MaxY;by++) {\n          Pull8Lines(i);\n          for(bx = blocks.ra_MinX;bx <= blocks.ra_MaxX;bx++) {\n            LONG dst[64];\n            FetchRegion(bx,m_ppDecodingMCU + (i << 3),dst);\n            up->DefineRegion(bx,by,dst);\n          }\n          Release8Lines(i);\n        }\n      } else {\n        // Load into the decoding MCU\n        Pull8Lines(i);\n      }\n    }\n    // Now push blocks into the color transformer from the upsampler.\n    {\n      RectAngle<LONG> r;\n      ULONG minx   = orgregion.ra_MinX >> 3;\n      ULONG maxx   = orgregion.ra_MaxX >> 3;\n      ULONG miny   = orgregion.ra_MinY >> 3;\n      ULONG maxy   = orgregion.ra_MaxY >> 3;\n      ULONG x,y;\n      \n      if (maxy > m_ulMaxMCU)\n        maxy = m_ulMaxMCU;\n\n      for(y = miny,r.ra_MinY = orgregion.ra_MinY;y <= maxy;y++,r.ra_MinY = r.ra_MaxY + 1) {\n        r.ra_MaxY = (r.ra_MinY & -8) + 7;\n        if (r.ra_MaxY > orgregion.ra_MaxY)\n          r.ra_MaxY = orgregion.ra_MaxY;\n        \n        for(x = minx,r.ra_MinX = orgregion.ra_MinX;x <= maxx;x++,r.ra_MinX = r.ra_MaxX + 1) {\n          r.ra_MaxX = (r.ra_MinX & -8) + 7;\n          if (r.ra_MaxX > orgregion.ra_MaxX)\n            r.ra_MaxX = orgregion.ra_MaxX;\n          \n          for(i = 0;i < m_ucCount;i++) {\n            if (i >= rr->rr_usFirstComponent && i <= rr->rr_usLastComponent) {\n              ExtractBitmap(m_ppTempIBM[i],r,i);\n              if (m_ppUpsampler[i]) {\n                // Upsampled case, take from the upsampler, transform\n                // into the color buffer.\n                m_ppUpsampler[i]->UpsampleRegion(r,m_ppCTemp[i]);\n              } else {\n                FetchRegion(x,m_ppDecodingMCU + (i << 3),m_ppCTemp[i]);\n              }\n            } else {\n              // Not requested, zero the buffer.\n              memset(m_ppCTemp[i],0,sizeof(LONG) * 64);\n            }\n          }\n          ctrafo->YCbCr2RGB(r,m_ppTempIBM,m_ppCTemp,NULL);\n        }\n        //\n        // Advance the quantized rows for the non-subsampled components,\n        // upsampled components have been advanced above.\n        for(i = rr->rr_usFirstComponent;i <= rr->rr_usLastComponent;i++) {\n          if (m_ppUpsampler[i] == NULL)\n            Release8Lines(i);\n        }\n      }\n    }\n  } else { \n    // direct case, no upsampling required, residual coding possible, but not applied here.\n    RectAngle<LONG> r;\n    RectAngle<LONG> region = orgregion;\n    SubsampledRegion(region,rr);\n    ULONG minx   = region.ra_MinX >> 3;\n    ULONG maxx   = region.ra_MaxX >> 3;\n    ULONG miny   = region.ra_MinY >> 3;\n    ULONG maxy   = region.ra_MaxY >> 3;\n    ULONG x,y;\n      \n    if (maxy > m_ulMaxMCU)\n      maxy = m_ulMaxMCU;\n\n    for(i = rr->rr_usFirstComponent;i <= rr->rr_usLastComponent;i++) {\n      Pull8Lines(i);\n    }\n    \n    for(y = miny,r.ra_MinY = region.ra_MinY;y <= maxy;y++,r.ra_MinY = r.ra_MaxY + 1) {\n      r.ra_MaxY = (r.ra_MinY & -8) + 7;\n      if (r.ra_MaxY > region.ra_MaxY)\n        r.ra_MaxY = region.ra_MaxY;\n        \n      for(x = minx,r.ra_MinX = region.ra_MinX;x <= maxx;x++,r.ra_MinX = r.ra_MaxX + 1) {\n        r.ra_MaxX = (r.ra_MinX & -8) + 7;\n        if (r.ra_MaxX > region.ra_MaxX)\n          r.ra_MaxX = region.ra_MaxX;\n\n        for(i = 0;i < m_ucCount;i++) {      \n          LONG *dst = m_ppCTemp[i];\n          if (i >= rr->rr_usFirstComponent && i <= rr->rr_usLastComponent) {\n            ExtractBitmap(m_ppTempIBM[i],r,i);\n            FetchRegion(x,m_ppDecodingMCU + (i << 3),dst);\n          } else {\n            memset(dst,0,sizeof(LONG) * 64);\n          }\n        }\n        //\n        // Perform the color transformation now.\n        ctrafo->YCbCr2RGB(r,m_ppTempIBM,m_ppCTemp,NULL);\n      } // of loop over x\n      //\n      // Advance the rows.\n      for(i = rr->rr_usFirstComponent;i <= rr->rr_usLastComponent;i++) {\n        Release8Lines(i);\n      }\n    }\n  }\n#else\n  NOREF(orgregion);\n  NOREF(rr);\n#endif\n}\n///\n\n/// HierarchicalBitmapRequester::isNextMCULineReady\n// Return true if the next MCU line is buffered and can be pushed\n// to the encoder.\nbool HierarchicalBitmapRequester::isNextMCULineReady(void) const\n{\n#if ACCUSOFT_CODE\n  // MCUs can only be written if the smallest scale, which is written first,\n  // is ready.\n  return m_pSmallestScale->isNextMCULineReady();\n#else\n  return false;\n#endif\n}\n///\n\n/// HierarchicalBitmapRequester::ResetToStartOfImage\n// Reset all components on the image side of the control to the\n// start of the image. Required when re-requesting the image\n// for encoding or decoding.\nvoid HierarchicalBitmapRequester::ResetToStartOfImage(void)\n{\n#if ACCUSOFT_CODE\n  for(UBYTE i = 0;i < m_ucCount;i++) {\n    m_pulY[i] = 0;\n    m_pulReadyLines[i] = 0;\n  }\n  //\n  assert(m_pLargestScale);\n  // Now iterate through the tree.\n  m_pLargestScale->ResetToStartOfImage();\n#endif\n}\n///\n\n/// HierarchicalBitmapRequester::isImageComplete\n// Return an indicator whether all of the image has been loaded into\n// the image buffer.\nbool HierarchicalBitmapRequester::isImageComplete(void) const\n{ \n#if ACCUSOFT_CODE\n  for(UBYTE i = 0;i < m_ucCount;i++) {\n    if (m_pulReadyLines[i] < m_ulPixelHeight)\n      return false;\n  }\n  return true;\n#else\n  return false;\n#endif\n}\n///\n\n/// HierarchicalBitmapRequester::BufferedLines\n// Return the number of lines available for reconstruction from this scan.\nULONG HierarchicalBitmapRequester::BufferedLines(const struct RectangleRequest *rr) const\n{\n#if ACCUSOFT_CODE\n  ULONG maxlines = m_ulPixelHeight;\n  \n  for(UBYTE i = rr->rr_usFirstComponent;i <= rr->rr_usLastComponent;i++) {\n    class Component *comp = m_pFrame->ComponentOf(i);\n    UBYTE suby            = comp->SubYOf();\n    ULONG lines;\n    // Since the user here asks for complete(!) lines and the highpass comes last\n    // in the codestream, ask the highpass about how many lines are buffered.\n    // These lines are counted in subsampled lines.\n    lines = m_pLargestScale->BufferedLines(i);\n    if (lines >= m_pulHeight[i]) {\n      lines = m_ulPixelHeight;\n    } else if (suby > 1 && lines > 0) {\n      lines = ((lines - 1) * suby) & (-8); // one additional subsampled line, actually,;\n    } else {\n      lines = (lines * suby) & (-8); \n    }\n    if (lines < maxlines)\n      maxlines = lines;\n  }\n\n  return maxlines;\n#else\n  NOREF(rr);\n  return 0;\n#endif\n}\n///\n\n/// HierarchicalBitmapRequester::PostImageHeight\n// Post the height of the frame in lines. This happens\n// when the DNL marker is processed.\nvoid HierarchicalBitmapRequester::PostImageHeight(ULONG lines)\n{\n  BitmapCtrl::PostImageHeight(lines);\n#if ACCUSOFT_CODE\n  assert(m_pulHeight);\n\n  if (m_pLargestScale)\n    m_pLargestScale->PostImageHeight(lines);\n  \n  for(UBYTE i = 0;i < m_ucCount;i++) {\n    class Component *comp = m_pFrame->ComponentOf(i);\n    UBYTE suby            = comp->SubYOf();\n    m_pulHeight[i]        = (m_ulPixelHeight + suby - 1) / suby;\n  }\n#endif\n}\n///\n"], "fixing_code": ["This project implements a complete(!) JPEG (Rec. ITU-T T.81 | ISO/IEC\r\n10918-1) codec, plus a library that can be used to encode and decode\r\nJPEG streams.  It also implements ISO/IEC 18477 aka JPEG XT which is\r\nan extension towards intermediate, high-dynamic-range lossy and\r\nlossless coding of JPEG. In specific, it supports ISO/IEC\r\n18477-3/-6/-7/-8/-9 encoding.\r\n\r\n--------------------------------------------------------------------------\r\n\r\nUnlike many other implementations, libjpeg also implements:\r\n\r\n- 12 bpp image coding for the lossy DCT process,\r\n- the predictive lossless mode of Rec. ITU-T T.81 | ISO/IEC 10918-1,\r\n- the hierarchical process of Rec. ITU-T T.81 | ISO/IEC 10918-1,\r\n- the arithmetic coding option of Rec. ITU-T T.81 | ISO/IEC 10918-1,\r\n- coding of up to 256 component images\r\n- upsampling of images for all factors from 1x1 to 4x4\r\n\r\nStandard features are of course also supported, such as\r\nsequential and progressive mode in 8bpp.\r\n\r\n--------------------------------------------------------------------------\r\n\r\nIn addition, this codec provides methods to encode images\r\n\r\n- with a bit depth between 8 and 16 bits per sample, fully backwards\r\n  compatible to Rec. ITU-T T.81 | ISO/IEC 10918 baseline coding.\r\n\r\n- consisting of floating point samples, specifically images with \r\n  high dynamic range.\r\n\r\n- to encode images without loss, regardless of their bit-depth and their\r\n  sample data type.\r\n\r\n--------------------------------------------------------------------------\r\n\r\nExample usage:\r\n\r\nStandard JPEG compression, with 444 (aka \"no\") subsampling:\r\n\r\n$ jpeg -q <quality> infile.ppm outfile.jpg\r\n\r\nStandard JPEG compression, with 422 subsampling:\r\n\r\n$ jpeg -q <quality> -s 1x1,2x2,2x2 infile.ppm outfile.jpg\r\n\r\nIntermediate dynamic range compression, i.e. compression of images\r\nof a bit-depth between 8 and 16 bits:\r\n\r\n$ jpeg -r -q <base-quality> -Q <extension-quality> -h -r12 infile.ppm outfile.jpg\r\n\r\nThis type of encoding uses a technology known as \"residual scans\" which \r\nincrease the bit-depths in the spatial domain which is enabled by the -r\r\ncommand line switch. The -Q parameter sets the quality of the residual image. \r\nTo improve the precision in the frequency domain, \"refinement scans\" can be used. \r\nThe following encodes a 12-bit image with  four additional refinement scans,\r\nenabled by the \"-R 4\" parameter.\r\n\r\n$ jpeg -q <quality> -R 4 -h infile.ppm outfile.jpg\r\n\r\nBoth technologies can be combined, and the precision of the residual scan\r\ncan also be enlarged by using residual refinement scans with the -rR option.\r\nThe following command line with use a 12-bit residual scan with four refinement\r\nscans:\r\n\r\n$ jpeg -r -q <base-quality> -Q <extension-quality> -h -rR 4 infile.ppm outfile.jpg\r\n\r\nHigh-dynamic range compression allows three different profiles of varying\r\ncomplexity and performance. The profiles are denoted by \"-profile <X>\" where\r\n<X> is a,b or c. The following encodes an HDR image in profile C:\r\n\r\n$ jpeg -r -q <base-quality> -Q <extension-quality> -h -profile c -rR 4 infile.pfm outfile.jpg\r\n\r\nHDR images here have to be fed into the command line in \"pfm\" format. \r\nexr or hdr is not supported as input format and requires conversion to \r\npfm first. pfm is the floating-point equivalent of ppm and encodes each\r\npixel by three 32-bit floating point numbers.\r\n\r\nEncoding in profiles a and b works likewise, though it is generally advisable to\r\nuse \"open loop\" rather than \"closed loop\" coding for these two profiles by\r\nadditionally providing the \"-ol\" parameter. This also works for profile C:\r\n\r\n$ jpeg -ol -r -profile a -q <base-quality> -Q <extension-quality> -h infile.pfm out.jpg\r\n\r\nsimilar for profile B.\r\n\r\nWhat is common to profiles A and C is that you may optionally also specify \r\nthe LDR image, i.e. the image that a legacy JPEG decoder will show. By default, \r\na simple tone mapping algorithm (\"global Reinhard\") will be used to derive a\r\nsuitable LDR image from the input image:\r\n\r\n$ jpeg -ldr infile.ppm -q <base-quality> -Q <extension-quality> -h -rR 4 infile.pfm out.jpg\r\n\r\nThe profile is by default profile c, but it also works for profile a:\r\n\r\n$ jpeg -ol profile a -ldr infile.ppm -q <base-quality> -Q <extension-quality> infile.pfm out.jpg\r\n\r\nIt is in general advisable for profile c encoding to enable residual refinement scans,\r\nprofiles a or b do not require them.\r\n\r\n\r\nThe following options exist for lossless coding integer:\r\n\r\npredictive Rec. ITU-T T.81 | ISO/IEC 10918-1 coding. Note, however,\r\nthat not many implementations are capable of decoding such stream,\r\nthus this is probably not a good option for all-day purposes.\r\n\r\n$ jpeg -p -c infile.ppm out.jpg\r\n\r\nWhile the result is a valid Rec. ITU-T T.81 | ISO/IEC 10918-1 stream,\r\nmost other implementations will hick up and break, thus it is not\r\nadvisable to use it.\r\n\r\nA second option for lossless coding is residual coding within profile c:\r\n\r\n$ jpeg -q <quality> -Q 100 -h -r infile.ppm out.jpg\r\n\r\nThis also works for floating point coding. Note that lossless coding is enabled\r\nby setting the extension quality to 100.\r\n\r\n$ jpeg -q <quality> -Q 100 -h -r infile.pfm out.jpg\r\n\r\nHowever, this is only lossless for 16 bit input samples, i.e. there is a precision\r\nloss due to down-converting the 32-bit input to 16 bit. If samples are out of the\r\n601 gamut, the problem also exists that clamping will happen. To avoid that,\r\nencode in the XYZ color space (profile C only, currently):\r\n\r\n$ jpeg -xyz -q <quality> -Q 100 -h -r infile.pfm out.jpg\r\n\r\nA second option for lossless integer coding is to use a lossless 1-1 DCT\r\nprocess. This is enabled with the -l command line option:\r\n\r\n$ jpeg -l -q 100 -c infile.ppm out.jpg\r\n\r\nRefinement scans can be used to increase the sample precision to up to 12\r\nbits. The \"-c\" command line option disables the lossy color transformation.\r\n\r\nAdditionally, this implementation also supports JPEG LS, which is\r\noutside of Rec. ITU-T T.81 | ISO/IEC 10918-1 and ISO/IEC 18477. For\r\nthat, use the command line option -ls:\r\n\r\n$ jpeg -ls -c infile.ppm out.jpg\r\n\r\nThe \"-c\" command line switch is necessary to disable the color transformation\r\nas JPEG LS typically encodes in RGB and not YCbCr space.\r\n\r\nOptionally, you may specify the JPEG LS \"near\" parameter (maximum error) with\r\nthe -m command line switch:\r\n\r\n$ jpeg -ls -m 2 -c infile.ppm out.jpg\r\n\r\nJPEG LS also specifies a lossless color transformation that is enabled with\r\n-cls:\r\n\r\n$ jpeg -ls -cls infile.ppm out.jpg\r\n\r\n\r\nTo encode images with an alpha channel, specify the source image that \r\ncontains the alpha channel with -al. The alpha channel is a one-component\r\ngrey-scale image, either integer or floating point. The quality of the\r\nalpha channel is specified with -aq, that of the regular image with -q:\r\n\r\n$ jpeg -al alpha.pgm -aq 80 -q 85 input.ppm output.jpg\r\n\r\nAlpha channels can be larger than 8bpp or can be floating point. In both\r\ncases, residual coding is required. To enable residual coding in the alpha\r\nchannel, use the -ar command line option. Similar to the regular image,\r\nwhere residual coding requires two parameters, -q for the base quality and\r\n-Q for the extension quality, an alpha channel that uses residual coding\r\nalso requires a base and extension quality, the former is given by -aq,\r\nthe latter with -aQ:\r\n\r\n$ jpeg -ar -al alphahigh.pgm -q 85 -Q 90 -aq 80 -aQ 90 input.ppm out.jpg\r\n\r\nThe alpha channel can be encoded without loss if desired. For that, enable\r\nresidual coding with -ar and specify an extension quality of 100:\r\n\r\n$ jpeg -ar -al alphahigh.pgm -q 85 -Q 90 -aq 80 -aQ 100 input.ppm out.jpg\r\n\r\nThe alpha channel can use the same technology extensions as the image,\r\nnamely refinement scans in the base or extension image, or 12-bit residual\r\nimages. The number of refinement scans is selected with -aR and -arR for\r\nthe base and residual image, a 12-bit residual image is selected with -ar12.\r\n\r\n--------------------------------------------------------------------------\r\n\r\nDecoding is much simpler:\r\n\r\n$ jpeg infile.jpg out.ppm\r\n\r\nor, for floating point images:\r\n\r\n$ jpeg infile.jpg out.pfm\r\n\r\n\r\nIf you want to decode a JPEG LS image, then you may want to tell the\r\ndecoder explicitly to disable the color transformation even though the\r\ncorresponding marker signalling coding in RGB space is typically missing\r\nfor JPEG LS:\r\n\r\n$ jpeg -c infile.jpg out.ppm\r\n\r\n\r\nIf an alpha channel is included in the image, the decoder does not\r\nreconstruct this automatically, nor does it attempt to merge the alpha\r\nimage into the file. Instead, it may optionally be instructed to write the\r\nalpha channel into a separate 1-component (grey-scale) file:\r\n\r\n$ jpeg -al alpha.pgm infile.jpg outfile.ppm\r\n\r\nThe -al option for the decoder provides the target file for the alpha\r\nchannel.\r\n\r\n--------------------------------------------------------------------------\r\n\r\nStarting with release 1.30, libjpeg will include a couple of optimization\r\nparameters to improve the performance of JPEG and JPEG XT. In this\r\nrelease, the following additional command line switches are available:\r\n\r\n-qt <n> : Selects a different quantization table. The default table,\r\nalso enabled by -qt 0, is the one in the legacy JPEG standard\r\n(Rec. ITU-T T.81 | ISO/IEC 10918-1). -qt 1 is the \"flat\" table for\r\nPSNR-optimal performance. It is not recommended for real-life usage as\r\nits visual performance is non-ideal, it just generates \"nice\r\nnumbers\". -qt 2 is MS-SSIM ideal, but similarly, not necessarily a\r\ngood recommendation for all-day use. -qt 3 is a good compromize and\r\nusually works better than -qt 0.\r\n\r\n-dz : This option enables a deadzone quantizer that shifts the buckets\r\nby 1/8th of their size to the outside. This is (almost) the ideal choice\r\nfor Laplacian sources which would require a shift of 1/12th. Nevertheless,\r\nthis option improves the rate-distortion performance by about 0.3dB on\r\naverage and works pretty consistent over many images.\r\n\r\nAdditional options are planned for future releases.\r\n-------------------------------------------------------------------------------------\r\n\r\nRelease 1.40:\r\n\r\nIn this release, we included additional support for \"full profile\" encoding, i.e.\r\nencoding parameters that do not fit any of the four profiles specified in 18477-7.\r\nUsing such encoding parameters will generate a warning on the command line, but\r\nencoding will proceed anyhow, generating a bitstream that conforms to 18477-7, but\r\nnot to any of the profiles in this standard.\r\n\r\nWith \"-profile a -g 0\" or \"-profile b -g 0\" the encoder will generate a file that\r\nuses an inverse TMO lookup similar to profile C with other encoding parameters\r\nidentical to those defined by profiles A and B.\r\n\r\nThe command line option \"-lr\" will use a logarithmic encoding instead of the gamma\r\nencoding for profile B. Again, this will leave the profile, but will be within the\r\nbounds of 18477-7.\r\n\r\nOther than that, a couple of bug fixes have been made. Profile A and B setup could\r\nnot reset the toe value for the inverse gamma map, due to a typo of one of the\r\nparameters. Profile B accepted a different gamma value than the default, but never\r\ncommunicated it to the core code, i.e. it was simply ignored. Profile B setup ignored\r\nthe epsilon values for numerator and denomiator, and they were communicated wrongly\r\ninto the core code. This was corrected, and epsilons can now be specified on the\r\ncommand line.\r\n\r\n--------------------------------------------------------------------------\r\n\r\nRelease 1.50:\r\n\r\nThis release fixes encoding of ISO/IEC 18477-8 if the IDCT was selected as\r\ntransformation in the extension layer and refinement scans were added, i.e.\r\nthe command line options -rl -rR 4 created invalid codestreams. Previous\r\nreleases used the wrong type of refinement scan (dct bypass refinement instead\r\nof regular refinement) and hence broke reconstruction. Furthermore, previous\r\nreleases no longer allowed near lossless coding with DCT bypass. Instead, regular\r\nDCT coding conforming to ISO/IEC 18477-7 was used. To enable the near-lossless\r\nDCT bypass mode, use the new option \"-ro\" now.\r\n\r\nProfile B encoding could potentially create codestreams that run into\r\nclipping of the extension channel; this always happens if the denominator is\r\nlarger than 1, and has to happen according to Annex C of ISO/IEC 18477-3.\r\nThis release avoids this issue by adjusting the exposure value such that\r\nthe denominator always remains smaller than 1.\r\n\r\n--------------------------------------------------------------------------\r\n\r\nRelease 1.51:\r\n\r\nIf the JPEG-XT markers were delayed to the frame-header intead the global\r\nheader, the previous code did not built up the necessary infrastructure\r\nto compute the checksum and hence could not verify the checksum in such\r\na condition. The 1.51 release fixes this problem.\r\n\r\n--------------------------------------------------------------------------\r\n\r\nRelease 1.52:\r\n\r\nThis file is an updated/enhanced version of the 1.51 release of\r\nthe JPEG XT demo software found on https://github.com/thorfdbg/. It\r\nincludes additional features presented in the paper\r\n\"JPEG on Steroids : Common Optimization Techniques for JPEG Image Compression\"\r\nby the same author.\r\n\r\nIn specific, the following command line flags are *NEW* to this version and\r\nare available only as a contribution to ICIP 2016:\r\n\r\n-oz:          This enables the dynamic programming algorithm to enhance\r\nthe rate-distortion performance by soft-threshold quantization. It has been\r\nused for the tests in section 3.3 of the paper.\r\n\r\n-dr:         This enables the smart de-ringing algorithm that has been used\r\nin section 3.6.\r\n\r\nAdditionally, the following switches have been used for other subsections\r\nof the paper; they are not new to this distribution but available as\r\npart of the regular libjpeg distribution at github or www.jpeg.org:\r\n\r\n-s 1x1,2x2,2x2:     Enable 420 subsampling (444 is default)\r\n-s 1x1,2x1,2x1:     Enable 422 subsampling (444 is default)\r\n-qt n (n=0..8)      Use quantization matrix n.\r\n                    In the paper, n=1 (flat) was used for PSNR-optimized\r\n                    coding, unless otherwise noted.\r\n-dz                 The deadzone quantizer in section 3.3\r\n                    (simpler than -oz)\r\n-v                  Enable coding in processive mode (section 3.5)\r\n-v -qv              Optimized progressive mode (section 3.5)\r\n-h                  Optimized Huffman coding (always used, unless noted\r\n                    otherwise, see section 3.4)\r\n\t\t    \r\n--------------------------------------------------------------------------\r\n\r\nRelease 1.53:\r\n\r\nThis release includes additional functionality to inject markers, or\r\nretrieve markers from a codestream while reading. For that, set\r\nthe JPGTAG_ENCODER_STOP tag of the JPEG::Write() call to a bitmask\r\nwhere the encoder should interrupt writing data (this flag already\r\nexisted before) then write custom data with JPEG::WriteMarker(), then\r\ncontinue with JPEG::Write(). On decoding, set JPGTAG_DECODER_STOP to\r\na bitmask where to stop for markers, then identify markers with\r\nJPEG::PeekMarker(), and retrieve them with JPEG::ReadMarker(). Details\r\ncan be found in cmd/encodec.cpp for encoding, and cmd/reconstruct.cpp.\r\n\r\nOtherwise, no functional changes.\r\n\r\n--------------------------------------------------------------------------\r\n\r\nRelease 1.54:\r\n\r\nIn this release, upsampling has been made conforming to the latest\r\ncorrigendum of 18477-1 and 18477-8. In particular, upsampling is now\r\nby design always centered and never co-sited. The co-sited upsampling\r\nprocedure is still included in the source code, but never executed.\r\n\r\n--------------------------------------------------------------------------\r\n\r\nRelease 1.55:\r\n\r\nThis release only addresses some minor formulation issues of the\r\ncommand line such that references are formatted properly to make this\r\nsoftware package acceptable as a JPEG reference software.\r\nNo functional changes.\r\n\r\n--------------------------------------------------------------------------\r\n\r\nRelease 1.56:\r\n\r\nEncoding and reconstruction of 2-component images was actually never\r\nsupported, as it was considered a rather exotic use-case. Now that a\r\nrequest was made, support for 2-components was added and should\r\nhopefully work ok.\r\n\r\n--------------------------------------------------------------------------\r\n\r\nRelease 1.57:\r\n\r\nNewer g++ compiler versions warned about implicit fall-throughs in switch/\r\ncase constructs that are actually harmless. This release adds an autoconf\r\ndetection of such compiler versions, adds consistent comments throughout\r\nthe code.\r\n\r\n--------------------------------------------------------------------------\r\n\r\nRelease 1.58:\r\n\r\nThis release fixes multiple spelling errors in the file, thanks to\r\nMathieu Mmalaterre for finding and fixing them. The release also\r\naddresses multiple race conditions and improves stability and robustness\r\non invalid streams. Thanks to seviezhou for providing codestreams that\r\ntriggered these defects. In particular, the following defects have\r\nbeen found:\r\n\r\n- when a codestream with unsupported upsampling specification (beyond\r\n  18477-1) was found, the code crashed.\r\n- JPEG LS single component scans did not check whether there is actually\r\n  only a single component referenced in the scan.\r\n- An invalid DC category in the sequential scan could have caused a\r\n  crash in the follow-up decoding.\r\n- AC-coded lossless JPEG scans with horizontal subsampling factors\r\n  trashed memory.\r\n- MCU sizes of 0 remained undetected and caused crashes due to a\r\n  division-by-zero exception.\r\n- The code did not check whether a scan references the same component\r\n  more than once and could have failed with strange effects then.\r\n- The code did not handle EOF conditions in the frame header\r\n  gracefully.\r\n\r\n--------------------------------------------------------------------------\r\n\r\nRelease 1.59:\r\n\r\nThis release addresses a defect in the MCU handling for JPEG LS scans.\r\nThe previous code forgot to reset the JPEG LS state variables on MCU\r\nscan boundaries, thus defeating the independent decodability of MCUs\r\nif restart markers are inserted into the stream. Thanks to Spyros for\r\ndetecting this defect.\r\n\r\n--------------------------------------------------------------------------\r\n\r\nRelease 1.60:\r\n\r\nA specially crafted bitstream depending on line-based JPEG processes\r\ncould trigger a segfault because source data the reconstruction\r\nprocess depended upon were not available. This has been fixed.\r\n\r\n--------------------------------------------------------------------------\r\n\r\nRelease 1.61:\r\n\r\nThe restart interval for JPEG LS streams, specifically, is allowed to\r\nbe larger than 2^16. Modified the DRI marker accordingly. Unfortunately,\r\nas the initial tables section of a codestream of JPEG and JPEG LS is\r\nidentical, JPEG files with an invalid DRI marker size will also be\r\naccepted as valid.\r\n\r\n--------------------------------------------------------------------------\r\n\r\nRelease 1.62:\r\n\r\nThe quantization table could contain entries larger than 255 for the 8-bit\r\nDCT process, even though the standard prohibits this. Now the quantization\r\ntable entries are clipped to the allowed range.\r\nAdded an option -bl to force encoding in the baseline sequential process.\r\nAdded options to read the quantization tables from files rather than using\r\nthe built-in defaults.\r\n\r\n--------------------------------------------------------------------------\r\n\r\nRelease 1.63:\r\n\r\nIn case the decoder was started with an image containing an alpha channel,\r\ni.e. a 18477-9 image, and no output file for the alpha channel was\r\nprovided, the decoder crashed. This issue was fixed, the alpha channel is\r\nnow in this case simply disregarded. Note that you can define the output\r\nfile for the alpha channel with the \"-al\" command line option.\r\n\r\n--------------------------------------------------------------------------\r\n\r\nRelease 1.64:\r\n\r\nThe lossless scan, the arithmetically coded lossless scan and the\r\narithmetically coded sequential scan could run into cases where an\r\nout-of-bounds symbol triggered and out-of-bounds array access and could\r\nhave crashed the decoder. The code is now more carefully changing the\r\nvalidity of the symbols and aborts with an error if it finds illegal\r\ncodes.\r\nThe code now also checks the consistency of the MCU sizes in the\r\nhierarchical process and fails if they differ across levels.\r\n\r\n--------------------------------------------------------------------------\r\n\r\nFor license conditions, please check the file README.license in this\r\ndirectory.\r\n\r\nFinally, I want to thank Accusoft and the Computing Center of the University of\r\nStuttgart and Fraunhofer IIS for sponsoring this project.\r\n\r\nThomas Richter, February 2022\r\n\r\n-------------------------------------------------------------------------------------\r\n", "Revision 0.10\r\n-----------------------------\r\n\r\nFirst release of libjpeg to the public.\r\n\r\n\r\nRevision 0.11\r\n-----------------------------\r\n\r\nApparently, the demo frontend code used the \r\nnon-binary mode to open the output files,\r\ncreating corrupt files under platforms where\r\nsuch modes include a text conversion. Fixed.\r\n\r\nThe configure script that tested for the avail-\r\nibility of setjmp did not work on those platforms\r\nwhere setjmp is a macro rather than a function.\r\nThe test for setjmp is now omitted, depending solely\r\non the availibility of longjmp.\r\n\r\n\r\nRevision 0.20\r\n-----------------------------\r\n\r\nThis release fixes a bug in the residual huffman decoder\r\nscan where I forgot to multiply the residuals with the\r\nquantization size. This did not affect lossless coding,\r\nbut only near-lossless coding.\r\nFurthermore, this release adds coding of high-bitdepth\r\nimages with a standard 8bpp JPEG fallback stream. For\r\nthat, simply supply the image to be coded on the command\r\nline and add the \"-r\" option to enable residual coding.\r\nTo use the conforming, but typically ill-supported 12bpp\r\nmode of JPEG, do not use \"-r\".\r\n\r\n\r\nRevision 0.30\r\n-----------------------------\r\n\r\nThis release introduces a new coding strategy for lossless\r\nand high-dynamic range coding. Unlike former releases,\r\nthis release runs an additional reversible color transformation\r\non the residual data, followed by a lossless (scaled) Hadamard\r\ntransformation to avoid color banding in extreme cases. It\r\nalso adds an additional tone mapping curve (or curves) to be\r\nspecified on encoding that allow a higher quality of the\r\nLDR base layer.\r\n\r\nRevision 0.50\r\n-----------------------------\r\n\r\nThe new features in this version are a refined residual coding algorithm that\r\nincludes a runlength scan to improve coding efficiency for low-quality extensions\r\nlayers. This release also features a new HDR compression in the DCT domain that\r\nuses the known JPEG refinement scans of progressive coding to improve the resolution\r\nfrom 8 bit to 12 bit in a completely backwards compatible way. Additionally, the\r\nsoftware was unit-tested with the 10918-2 (JPEG part 2) test streams and various\r\nbugs of the lossless predictive arithmetic coding and lossless predictive coding\r\nwere removed. New command line switches allow the encoding of pfm images (floating\r\npoint, for high-dynamic range) and the number of extension refinement scans.\r\n\r\nRevision 0.60\r\n-----------------------------\r\n\r\nOnly minor modifications were made in this release. The Huffman coder now fills\r\nundefined bits at the end of the entropy coded segment by ones, and potentially\r\ninserts a stuffed zero byte. Note that the standard defines this only in an\r\ninformative note, so it is likely not required. The insertion of a stuffed zero\r\nbyte at this position might also be unnecessary as a parser should identify the\r\nfirst 0xff byte ahead of the marker as \"fill byte\".\r\n\r\nResidual coding has been reworked and uses now a simple progressive scan with the\r\nspecial DC case removed. The performance does not differ significantly, and it\r\nmakes integration into legacy software or hardware easier. \r\n\r\nDefault Huffman tables are now also provided for progressive and lossless scans,\r\nthus optimizing the Huffman tables just for these scan types is no longer \r\nnecessary. Residual or refinement scans still require this argument, though.\r\n\r\nUsage of the codec does not differ from previous releases, though codestreams\r\nusing the residual coding mode are not compatible to those generated by 0.5.\r\nNote that this is still experimental software and the codestream might still\r\nchange until the ISO committee decides on the technology.\r\n\r\nFinally, a couple of workarounds for earlier releases of the g++ compiler have\r\nbeen added.\r\n\r\n\r\nRelease 0.7:\r\n-----------------------------\r\n\r\nThis is a major release of the software which adds a lot of missing\r\nfunctionality and brings it up to date to the latest working draft of\r\n18477-2. In specific, boxes are now written according to the latest\r\nspecification, and three proposals to encode HDR data are now\r\nimplemented: mult1 (quotient method), mult2 (overflow/truncation\r\nmethod) and residual coding. The HDR to LDR non-linear point\r\ntransformation can now be explicitly specified giving a file name on\r\nthe command line (-gf option) which must contain 256 lines, one line\r\nper LDR input sample value. Each line shall contain an ASCII encoded\r\ndecimal number, the output value a reconstructed LDR sample value is\r\nmapped to.\r\n\r\nThis release also supports (finally) subsampling in residual and\r\nmultiplicative coding, just specify the subsampling factors. In this\r\nrelease, the frontend only allows the same subsampling factors for\r\nboth images (legacy and residual) though the back-end is more powerful\r\nand would allow arbitrary combinations.  Lossless coding by residuals\r\nis also supported, residual image subsampling factors are set to 1:1:1\r\nin case the quality of the residual is 100.\r\n\r\nThe SERMS DCT that was removed in the earlier releases is now back and\r\ncan be enabled by the \"-l\" option. Note well that you also need to\r\nspecify \"-c\" to disable the YCbCr transformation.\r\n\r\nThe experimental VESA coding modes that have been part of this code\r\nare now gone for good as they are not part of the specification.\r\n\r\nA huge number of bugs have been fixed, in specific for the handling of\r\ngrey-only images. These should work fine now.\r\n\r\nThis release supports now two variations of the encoding mode,\r\nopen-loop and closed-loop.  In closed-loop coding, which was the\r\ndefault so far, the residual/multiplicative encoder is feed by the\r\nresidual (additive or multiplicative) of the reconstructed LDR and\r\noriginal image. For openloop coding, the encoder does not need to go\r\nthrough a full encoding/decoding cycle of the legacy stream and feeds\r\nin the legacy image derived from the original image to the residual\r\ncoder right away. NOTE THAT THIS MEANS THAT LOSSLESS CODING WILL NOT\r\nOPERATIONAL IN OPEN LOOP MODE, and additive residual coding will be\r\nrather pointless. However, this mode does make sense for the\r\nmultiplicative modes. Regardless of whether open or closed loop coding\r\nis used, the encoded codestream is conforming, though coding results\r\nmay be different.\r\n\r\n\r\nRelease 0.71:\r\n-----------------------------\r\n\r\nThis is a minor bugfix release which also adds one functionality, namely\r\nthe encodign of HDR images in the floating point domain via -mult1.\r\nPrevious versions took a round-trip through the integer domain and\r\nhence required output clipping. The direct-float mode can now be enabled\r\nby disabling the output-clipping process with \"-oc\". \r\n\r\nAdditionally, this release fixes two bugs, mostly related to the internal\r\nstream management. Due to an oversight, the marker-peek-ahead logic for\r\nresidual streams did not work, causing a potential race condition\r\nwhen a marker was overlapping a chunk-boundary of the internal stream\r\nrepresentation. Length computation of the internal stream representation\r\nwas also broken on encoding, causing a potential race condition when the\r\nhuffman table marker was overlapping with a chunk boundary. A third\r\nbug, namely a missing EOC at the end of the residual codestream, was\r\nfixed, too.\r\n\r\nRelease 0.72:\r\n-----------------------------\r\n\r\nThis release fixes a one-line oversight in the handling of subsampled \"residual\" coding,\r\nnamely the quantization output buffer did not advance, causing an assertion failure.\r\nThis release fixes the issue.\r\n\r\n\r\n-------------------------------------------------------------------------------------\r\n\r\nRelease 0.8:\r\n\r\nThis is again an update of the software in order to synchronize it with\r\nthe latest Working Draft (proposed CD text) document; that is, boxes\r\nare written now according to the latest specifications. Furthermore, support\r\nfor refinement scans in the residual domain have been added (with -rR),\r\nresidual data is DCT transformed unless lossless coding is desired.\r\nThis release also adds the checksum box, computes the checksum on encoding\r\nand tests it on decoding. In case it does not fit, a warning is generated.\r\n\r\nQuantization setup changed a bit, using now smaller buckets in the residual\r\nstream which avoids the paradoxical situation that a finer base layer\r\nquantization can cause a quality drop for the overall image.\r\n\r\nA serious bug in legacy coding modes was removed that caused the encoder\r\nor decoder to crash if no residual image was present.\r\n\r\nThis version of the encoder also supports encoding and decoding of images\r\nin wider color spaces; for demonstration purposes, it encodes images in the\r\nXYZ colorspace using the command line option -xyz, or -cxyz where the latter\r\nuses a slightly less efficient method how to represent the images.\r\n\r\nAt this time, the text based format is not supported, and support for the\r\ntwo other profiles (-mult1, -mult2) has been temporarely removed until the\r\nstandardization committee provides a clean solution how to integrate them.\r\n\r\n-------------------------------------------------------------------------------------\r\n\r\nRelease 0.9:\r\n\r\nThis is just another update. This update introduces new DCTs, the Z0 DCT from\r\nISO/IEC 23002-2, the Z1a DCT from the same authors and the CD document of this\r\nstandard, and a lifting-based DCT. Tests show that Z0 and the lifting DCT do not \r\nperform very well, so the default is current Z1 and SERMS.\r\nFurthermore, processing of RCT has changed slightly to ensure that the output\r\nis always in-range, not only for 16 bit output.\r\nDCT-bypass entropy coding was extended to use the full Huffman table, and includes\r\nnow special handling for the race-condition of having to code the value 0x8000\r\nwhich was simply not possible before.\r\nThe codestream syntax has been modified again to reflect the latest edition of\r\nthe standard document, namely the CD of 18477-3.\r\nLots of other minor fixes have been made, as for example in the selection and\r\nencoding of the precision of the residual frame and the computation of the\r\nchecksum.\r\n\r\n\r\n-------------------------------------------------------------------------------------\r\n\r\nRelease 0.91:\r\n\r\nThis release fixes a wrong DC offset in the residual coding path that compromized\r\ncompression efficiency, and a wrong computation in the residual bits.\r\n\r\n-------------------------------------------------------------------------------------\r\n\r\nRelease 0.92:\r\n\r\nThis release improves the computation of the LDR to HDR inverse TMO computation for\r\nprofile C and gains by that sometimes up to 2dB in PSNR. It also provides a \"-sp\"\r\ncommand line switch to use separate separate tables, one per component. This may\r\nhelp in case the image contains some extreme colors.\r\n\r\n-------------------------------------------------------------------------------------\r\n\r\nRelease 1.00alpha1:\r\n\r\nThis is the first complete release of the demo software. It adds again support\r\nfor profiles a and b for lossy HDR image coding and follows the new box-based\r\ndesign of 18477-3.\r\n\r\n-------------------------------------------------------------------------------------\r\n\r\nRelease 1.00beta1:\r\n\r\nThis is a fully verified version of the software, i.e. all modes of operation have\r\nbeen tested by an automatic unit test. This of course does not exclude any bugs,\r\nor any modifications before the finalization of the standard.\r\n\r\nIn comparison to the alpha1 release, the following bugs have been fixed:\r\n\r\n- Predictive lossless mode with restart markers forgot to reconstruct the last line\r\nin some configurations.\r\n- Due to an oversight, hierarchical mode did not work in combination with AC coding.\r\n- Hierarchical mode did not work in the \"semi-lossless\" configuration where the finest\r\nframe is defined by a lossless predictive scan.\r\n- Predictive lossless could have forgotten the last line on streams using the DNL marker\r\nto signal the height of the image.\r\n- JPEG LS restart markers did not work in plane and sample interleaved mode. Note,\r\nhowever, that restart marker handling in the JPEG LS reference software is broken and\r\ndoes not follow the specifications. (Defect report is pending.)\r\n- Grey scale coding in profiles A and B did not work.\r\n- Coding in RGB-colorspace did not work in profiles A and B.\r\n- Encoding in JPEG-LS erraneously inserted JPEG XT boxes into the codestream. While this\r\nis harmless, it increases the rate unnecessarily.\r\n\r\n-------------------------------------------------------------------------------------\r\n\r\nRelease 1.00beta2:\r\n\r\nThis release includes the changes made on the standard in the Strasbourg meeting\r\nof the JPEG committee, in particular it includes a rounding mode specifier of\r\nthe CURV boxes. Additionally, it allows now the inclusion of an arbitrary LDR image\r\nwithin profile B. Previous releases only supported the gamma-plus-clamping tone\r\nmapper which was built into the source. In addition to the new features, this\r\nrelease also includes an improved Huffman decoder that should be considerably\r\nfaster than the previous trivial bit-by-bit decoder.\r\n\r\n-------------------------------------------------------------------------------------\r\n\r\nRelease 1.00beta2.2:\r\n\r\nOnly a short fix in the handling of lossless JPEG scans: This release fixes one\r\nissue, namely correct decoding of 16-bit images where the carry-over was not\r\ncomputed correctly. This change required a careful distinction between differential\r\npredictive and regular-predictive mode, which is interestingly not mentioned in\r\nthe specs (probably nobody tested). A second race was fixed in JPEG-LS handling\r\nwhere bit-stuffing could have left a single isolated zero at the end of a JPEG-LS\r\nscan, causing a warning in the upwards marker parser (though no corrupt reconstruction).\r\n\r\n-------------------------------------------------------------------------------------\r\n\r\nRelease 1.20:\r\n\r\nThis version adds support for alpha channels as defined by ISO/IEC 18477-9\r\nto the code. Alpha channels are specified by one-component grey-scale images,\r\nof bit depths between 8 and 16 bits per sample. They may also consist of\r\nfloating point samples between 0 and 1. To add an alpha channel, use the command\r\nline options -al <filename> -aq <quality> for simple alpha channels of 8 bits per\r\nsample. For more precise alpha channels, residual coding in the alpha domain\r\nmust be enabled with -ar, and an alpha channel residual quality must be specified\r\nwith -aQ <ext-quality>. The coding tools for alpha channels are otherwise identical\r\nfor that of the base image. Alpha coding can be combined with any other coding\r\ntools, i.e. parts 6,7 and 8.\r\n\r\n-------------------------------------------------------------------------------------\r\n\r\nRelease 1.21:\r\n\r\nThis is only a minor maintenance release which removes three experimental DCT\r\nimplementations that are no longer required, fixes two possible un-initialized\r\nvariables and fixes a bug in the box enumeration. Release 1.20 and above started\r\nfor some boxes the box enumeration at zero even though it should start at one.\r\n\r\n-------------------------------------------------------------------------------------\r\n\r\nRelease 1.30:\r\n\r\nThis release fixes a bug in the line-based operation mode that is not available from\r\nthe front end and only works for baseline sequential. Unlike other modes, it does\r\nnot require full internal buffering of the image. It is also synchronized again to\r\nthe latest edition of the standard, offering the additional upscaling in the residual\r\npath for parts 6 and part 7 profile C. It has been cross-tested with other \r\nimplementations, thus interoperability is granted. Clipping for floating-point output\r\nhas been corrected to avoid the representations of NAN and INF.\r\nLast but not least, this release offers the possibility to select between nine different\r\nquantization matrices (-qt 0 to -qt 9), of which -qt 1 is PSNR-optimal and -qt 3 is\r\na good candidate for high visual compression. See the command line parameters for\r\ndetails. Furthermore, the -dz parameter enables a deadzone quantizer that improves\r\nthe compression performance by 0.3 dB on average.\r\n\r\n-------------------------------------------------------------------------------------\r\n\r\nRelease 1.31:\r\n\r\nThis release includes two minor changes that have been made to the specs at the last \r\nWarsaw meeting in June 2015. The order of the FDCT (fixed point DCT) has been adjusted\r\nto match the order of ISO/IEC 23002-2 (MPEG C) and to be consistent with the order of\r\nthe IDCT (integer DCT). Second, the specs allow now Integer Table Lookup boxes with\r\nsample size > 16 bits to allow the usage of a Table lookup in the residual coding\r\npath for part 8 of the specs.\r\n\r\n-------------------------------------------------------------------------------------\r\n\r\nRelease 1.40:\r\n\r\nIn this release, we included additional support for \"full profile\" encoding, i.e.\r\nencoding parameters that do not fit any of the four profiles specified in 18477-7.\r\nUsing such encoding parameters will generate a warning on the command line, but\r\nencoding will proceed anyhow, generating a bitstream that conforms to 18477-7, but\r\nnot to any of the profiles in this standard.\r\n\r\nWith \"-profile a -g 0\" or \"-profile b -g 0\" the encoder will generate a file that\r\nuses an inverse TMO lookup similar to profile C with other encoding parameters\r\nidentical to those defined by profiles A and B.\r\n\r\nThe command line option \"-lr\" will use a logarithmic encoding instead of the gamma\r\nencoding for profile B. Again, this will leave the profile, but will be within the\r\nbounds of 18477-7.\r\n\r\nOther than that, a couple of bug fixes have been made. Profile A and B setup could\r\nnot reset the toe value for the inverse gamma map, due to a typo of one of the\r\nparameters. Profile B accepted a different gamma value than the default, but never\r\ncommunicated it to the core code, i.e. it was simply ignored. Profile B setup ignored\r\nthe epsilon values for numerator and denomiator, and they were communicated wrongly\r\ninto the core code. This was corrected, and epsilons can now be specified on the\r\ncommand line. The JPEG LS part-2 encoder was broken due to a modification of the\r\ncolor transformer factory, and the (non-standardized, proprietary) residual\r\nrefinement arithmetic coding scan mode did not work correctly by depending on a non-\r\nexisting context.\r\n\r\n-------------------------------------------------------------------------------------\r\n\r\nRelease 1.50:\r\n\r\nThis release fixes encoding of ISO/IEC 18477-8 if the IDCT was selected as\r\ntransformation in the extension layer and refinement scans were added, i.e.\r\nthe command line options -rl -rR 4 created invalid codestreams. Previous\r\nreleases used the wrong type of refinement scan (dct bypass refinement instead\r\nof regular refinement) and hence broke reconstruction. Furthermore, previous\r\nreleases no longer allowed near lossless coding with DCT bypass. Instead, regular\r\nDCT coding conforming to ISO/IEC 18477-7 was used. To enable the near-lossless\r\nDCT bypass mode, use the new option \"-ro\" now.\r\n\r\nProfile B encoding could potentially create codestreams that run into\r\nclipping of the extension channel; this always happens if the denominator is\r\nlarger than 1, and has to happen according to Annex C of ISO/IEC 18477-3:2015.\r\nThis release avoids this issue by adjusting the exposure value such that\r\nthe denominator always remains smaller than 1.\r\n\r\n--------------------------------------------------------------------------\r\n\r\nRelease 1.51:\r\n\r\nIf the JPEG-XT markers were delayed to the frame-header intead the global\r\nheader, the previous code did not built up the necessary infrastructure\r\nto compute the checksum and hence could not verify the checksum in such\r\na condition. The 1.51 release fixes this problem.\r\n\r\n-------------------------------------------------------------------------------------\r\n\r\nRelease 1.52:\r\n\r\nThis file is an updated/enhanced version of the 1.50 release of\r\nthe JPEG XT demo software found on https://github.com/thorfdbg/. It\r\nincludes additional features presented in the paper\r\n\"JPEG on Steroids : Common Optimization Techniques for JPEG Image Compression\"\r\nby the same author.\r\n\r\nIn specific, the following command line flags are *NEW* to this version and\r\nare available only as a contribution to ICIP 2016:\r\n\r\n-oz:\t      This enables the dynamic programming algorithm to enhance\r\nthe rate-distortion performance by soft-threshold quantization. It has been\r\nused for the tests in section 3.3 of the paper.\r\n\r\n-dr: \t     This enables the smart de-ringing algorithm that has been used\r\nin section 3.6.\r\n\r\nAdditionally, the following switches have been used for other subsections\r\nof the paper; they are not new to this distribution but available as\r\npart of the regular libjpeg distribution at github or www.jpeg.org:\r\n\r\n-s 1x1,2x2,2x2:\t    Enable 420 subsampling (444 is default)\r\n-s 1x1,2x1,2x1:\t    Enable 422 subsampling (444 is default)\r\n-qt n (n=0..8)\t    Use quantization matrix n.\r\n      \t\t    In the paper, n=1 (flat) was used for PSNR-optimized\r\n\t\t    coding, unless otherwise noted.\r\n-dz\t\t    The deadzone quantizer in section 3.3\r\n\t\t    (simpler than -oz)\r\n-v\t\t    Enable coding in processive mode (section 3.5)\r\n-v -qv\t\t    Optimized progressive mode (section 3.5)\r\n-h \t\t    Optimized Huffman coding (always used, unless noted\r\n\t\t    otherwise, see section 3.4)\r\n\r\n--------------------------------------------------------------------------\r\n\r\nRelease 1.53:\r\n\r\nThis release includes additional functionality to inject markers, or\r\nretrieve markers from a codestream while reading. For that, set\r\nthe JPGTAG_ENCODER_STOP tag of the JPEG::Write() call to a bitmask\r\nwhere the encoder should interrupt writing data (this flag already\r\nexisted before) then write custom data with JPEG::WriteMarker(), then\r\ncontinue with JPEG::Write(). On decoding, set JPGTAG_DECODER_STOP to\r\na bitmask where to stop for markers, then identify markers with\r\nJPEG::PeekMarker(), and retrieve them with JPEG::ReadMarker(). Details\r\ncan be found in cmd/encodec.cpp for encoding, and cmd/reconstruct.cpp.\r\n\r\nOtherwise, no functional changes.\r\n\r\n--------------------------------------------------------------------------\r\n\r\nRelease 1.54:\r\n\r\nIn this release, upsampling has been made conforming to the latest\r\ncorrigendum of 18477-1 and 18477-8. In particular, upsampling is now\r\nby design always centered and never co-sited. The co-sited upsampling\r\nprocedure is still included in the source code, but never executed.\r\n\r\n--------------------------------------------------------------------------\r\n\r\nRelease 1.55:\r\n\r\nThis release only addresses some minor formulation issues of the\r\ncommand line such that references are formatted properly to make this\r\nsoftware package acceptable as a JPEG reference software.\r\nNo functional changes.\r\n\r\n--------------------------------------------------------------------------\r\n\r\nRelease 1.56:\r\n\r\nEncoding and reconstruction of 2-component images was actually never\r\nsupported, as it was considered a rather exotic use-case. Now that a\r\nrequest was made, support for 2-components was added and should\r\nhopefully work ok.\r\n\r\n--------------------------------------------------------------------------\r\n\r\nRelease 1.57:\r\n\r\nNewer g++ compiler versions warned about implicit fall-throughs in switch/\r\ncase constructs that are actually harmless. This release adds an autoconf\r\ndetection of such compiler versions, adds consistent comments throughout\r\nthe code, and disables the compiler warning were necessary.\r\n\r\n--------------------------------------------------------------------------\r\n\r\nRelease 1.58:\r\n\r\nThis release fixes multiple spelling errors in the file, thanks to\r\nMathieu Mmalaterre for finding and fixing them. The release also\r\naddresses multiple race conditions and improves stability and robustness\r\non invalid streams. Thanks to seviezhou for providing codestreams that\r\ntriggered these defects. In particular, the following defects have\r\nbeen found:\r\n\r\n- when a codestream with unsupported upsampling specification (beyond\r\n  18477-1) was found, the code crashed.\r\n- JPEG LS single component scans did not check whether there is actually\r\n  only a single component referenced in the scan.\r\n- An invalid DC category in the sequential scan could have caused a\r\n  crash in the follow-up decoding.\r\n- AC-coded lossless JPEG scans with horizontal subsampling factors\r\n  trashed memory.\r\n- MCU sizes of 0 remained undetected and caused crashes due to a\r\n  division-by-zero exception.\r\n- The code did not check whether a scan references the same component\r\n  more than once and could have failed with strange effects then.\r\n- The code did not handle EOF conditions in the frame header\r\n  gracefully.\r\n\r\n--------------------------------------------------------------------------\r\n\r\nRelease 1.59:\r\n\r\nThis release addresses a defect in the MCU handling for JPEG LS scans.\r\nThe previous code forgot to reset the JPEG LS state variables on MCU\r\nscan boundaries, thus defeating the independent decodability of MCUs\r\nif restart markers are inserted into the stream. Thanks to Spyros for\r\ndetecting this defect.\r\n\r\n--------------------------------------------------------------------------\r\n\r\nRelease 1.60:\r\n\r\nA specially crafted bitstream depending on line-based JPEG processes\r\ncould trigger a segfault because source data the reconstruction\r\nprocess depended upon were not available. This has been fixed.\r\n\r\n--------------------------------------------------------------------------\r\n\r\nRelease 1.61:\r\n\r\nThe restart interval for JPEG LS streams, specifically, is allowed to\r\nbe larger than 2^16. Modified the DRI marker accordingly. Unfortunately,\r\nas the initial tables section of a codestream of JPEG and JPEG LS is\r\nidentical, JPEG files with an invalid DRI marker size will also be\r\naccepted as valid.\r\n\r\n--------------------------------------------------------------------------\r\n\r\nRelease 1.62:\r\n\r\nThe quantization table could contain entries larger than 255 for the 8-bit\r\nDCT process, even though the standard prohibits this. Now the quantization\r\ntable entries are clipped to the allowed range.\r\nAdded an option -bl to force encoding in the baseline sequential process.\r\nAdded options to read the quantization tables from files rather than using\r\nthe built-in defaults.\r\n\r\n--------------------------------------------------------------------------\r\n\r\nRelease 1.63:\r\n\r\nIn case the decoder was started with an image containing an alpha channel,\r\ni.e. a 18477-9 image, and no output file for the alpha channel was\r\nprovided, the decoder crashed. This issue was fixed, the alpha channel is\r\nnow in this case simply disregarded. Note that you can define the output\r\nfile for the alpha channel with the \"-al\" command line option.\r\n\r\n--------------------------------------------------------------------------\r\n\r\nRelease 1.64:\r\n\r\nThe lossless scan, the arithmetically coded lossless scan and the\r\narithmetically coded sequential scan could run into cases where an\r\nout-of-bounds symbol triggered and out-of-bounds array access and could\r\nhave crashed the decoder. The code is now more carefully changing the\r\nvalidity of the symbols and aborts with an error if it finds illegal\r\ncodes.\r\nThe code now also checks the consistency of the MCU sizes in the\r\nhierarchical process and fails if they differ across levels.\r\n\r\n--------------------------------------------------------------------------\r\n", "/*************************************************************************\n\n    This project implements a complete(!) JPEG (Recommendation ITU-T\n    T.81 | ISO/IEC 10918-1) codec, plus a library that can be used to\n    encode and decode JPEG streams. \n    It also implements ISO/IEC 18477 aka JPEG XT which is an extension\n    towards intermediate, high-dynamic-range lossy and lossless coding\n    of JPEG. In specific, it supports ISO/IEC 18477-3/-6/-7/-8 encoding.\n\n    Note that only Profiles C and D of ISO/IEC 18477-7 are supported\n    here. Check the JPEG XT reference software for a full implementation\n    of ISO/IEC 18477-7.\n\n    Copyright (C) 2012-2018 Thomas Richter, University of Stuttgart and\n    Accusoft. (C) 2019-2020 Thomas Richter, Fraunhofer IIS.\n\n    This program is available under two licenses, GPLv3 and the ITU\n    Software licence Annex A Option 2, RAND conditions.\n\n    For the full text of the GPU license option, see README.license.gpl.\n    For the full text of the ITU license option, see README.license.itu.\n    \n    You may freely select between these two options.\n\n    For the GPL option, please note the following:\n\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n*************************************************************************/\n/*\n**\n** This is the top-level bitmap requester that distributes data to\n** image scales on encoding, and collects data from image scales on\n** decoding. It also keeps the top-level color transformer and the\n** toplevel subsampling expander.\n**\n** $Id: hierarchicalbitmaprequester.cpp,v 1.43 2022/05/24 05:42:35 thor Exp $\n**\n*/\n\n/// Includes\n#include \"control/hierarchicalbitmaprequester.hpp\"\n#include \"control/lineadapter.hpp\"\n#include \"control/linemerger.hpp\"\n#include \"std/string.hpp\"\n#include \"upsampling/downsamplerbase.hpp\"\n#include \"upsampling/upsamplerbase.hpp\"\n#include \"marker/frame.hpp\"\n#include \"marker/component.hpp\"\n#include \"colortrafo/colortrafo.hpp\"\n#include \"codestream/rectanglerequest.hpp\"\n#include \"codestream/tables.hpp\"\n///\n\n/// HierarchicalBitmapRequester::HierarchicalBitmapRequester\n// Construct from a frame - the frame is just a \"dummy frame\"\n// that contains the dimensions, actually a DHP marker segment\n// without any data in it.\nHierarchicalBitmapRequester::HierarchicalBitmapRequester(class Frame *dimensions)\n  : BitmapCtrl(dimensions)\n#if ACCUSOFT_CODE\n  , m_ppDownsampler(NULL), m_ppUpsampler(NULL), \n    m_ppTempIBM(NULL), m_pSmallestScale(NULL), m_pLargestScale(NULL), m_pTempAdapter(NULL),\n    m_pulReadyLines(NULL), m_pulY(NULL), m_pulHeight(NULL),\n    m_ppEncodingMCU(NULL), m_ppDecodingMCU(NULL),\n    m_bSubsampling(false)\n#endif\n{\n}\n///\n\n/// HierarchicalBitmapRequester::~HierarchicalBitmapRequester\nHierarchicalBitmapRequester::~HierarchicalBitmapRequester(void)\n{\n#if ACCUSOFT_CODE\n  class LineAdapter *la;\n  UBYTE i;\n  \n  if (m_ppEncodingMCU) {\n    assert(m_pLargestScale);\n    for(i = 0;i < (m_ucCount << 3);i++) {\n      m_pLargestScale->DropLine(m_ppEncodingMCU[i],i >> 3);\n    }\n    m_pEnviron->FreeMem(m_ppEncodingMCU,sizeof(struct Line *) * m_ucCount * 8);\n  }\n\n  if (m_ppDecodingMCU) {\n    assert(m_pLargestScale);\n    for(i = 0;i < (m_ucCount << 3);i++) {\n      m_pLargestScale->ReleaseLine(m_ppDecodingMCU[i],i >> 3);\n    }\n    m_pEnviron->FreeMem(m_ppDecodingMCU,sizeof(struct Line *) * m_ucCount * 8);\n  }\n\n  //\n  // Dispose the tree of line adapters\n  while((la = m_pLargestScale)) {\n    m_pLargestScale = la->LowPassOf();\n    delete la->HighPassOf();\n    delete la;\n  }\n  delete m_pTempAdapter;\n  \n  if (m_ppDownsampler) {\n    for(i = 0;i < m_ucCount;i++) {\n      delete m_ppDownsampler[i];\n    }\n    m_pEnviron->FreeMem(m_ppDownsampler,m_ucCount * sizeof(class DownsamplerBase *));\n  }\n\n  if (m_ppUpsampler) {\n    for(i = 0;i < m_ucCount;i++) {\n      delete m_ppUpsampler[i];\n    }\n    m_pEnviron->FreeMem(m_ppUpsampler,m_ucCount * sizeof(class UpsamplerBase *));\n  }\n\n  if (m_ppTempIBM) {\n    for(i = 0;i < m_ucCount;i++) {\n      delete m_ppTempIBM[i];\n    }\n    m_pEnviron->FreeMem(m_ppTempIBM,m_ucCount * sizeof(struct ImageBitMap *));\n  }\n\n  if (m_pulReadyLines)\n    m_pEnviron->FreeMem(m_pulReadyLines,m_ucCount * sizeof(ULONG));\n\n  if (m_pulY)\n    m_pEnviron->FreeMem(m_pulY,m_ucCount * sizeof(ULONG));\n\n  if (m_pulHeight)\n    m_pEnviron->FreeMem(m_pulHeight,m_ucCount * sizeof(ULONG));\n#endif\n}\n///\n\n/// HierarchicalBitmapRequester::BuildCommon\n// Build common structures for encoding and decoding\n#if ACCUSOFT_CODE\nvoid HierarchicalBitmapRequester::BuildCommon(void)\n{\n  BitmapCtrl::BuildCommon();\n  if (m_ppTempIBM == NULL) {\n    m_ppTempIBM = (struct ImageBitMap **)m_pEnviron->AllocMem(sizeof(struct ImageBitMap **) * m_ucCount);\n    memset(m_ppTempIBM,0,sizeof(struct ImageBitMap *) * m_ucCount);\n    for (UBYTE i = 0;i < m_ucCount;i++) {\n      m_ppTempIBM[i] = new(m_pEnviron) struct ImageBitMap();\n    }\n  }\n\n  if (m_pulReadyLines == NULL) {\n    m_pulReadyLines = (ULONG *)m_pEnviron->AllocMem(sizeof(ULONG) * m_ucCount);\n    memset(m_pulReadyLines,0,sizeof(ULONG) * m_ucCount);\n  }\n\n  if (m_pulY == NULL) {\n    m_pulY = (ULONG *)m_pEnviron->AllocMem(sizeof(ULONG) * m_ucCount);\n    memset(m_pulY,0,sizeof(ULONG) * m_ucCount);\n  }\n\n  if (m_pulHeight == NULL) {\n    m_pulHeight = (ULONG *)m_pEnviron->AllocMem(sizeof(ULONG) * m_ucCount);\n    for(UBYTE i = 0;i < m_ucCount;i++) {\n      class Component *comp = m_pFrame->ComponentOf(i);\n      UBYTE suby            = comp->SubYOf();\n      m_pulHeight[i]        = (m_ulPixelHeight + suby - 1) / suby;\n    }\n  }\n}\n#endif\n///\n\n/// HierarchicalBitmapRequester::PrepareForEncoding\n// First time usage: Collect all the information for encoding.\n// May throw on out of memory situations\nvoid HierarchicalBitmapRequester::PrepareForEncoding(void)\n{\n#if ACCUSOFT_CODE\n  \n  BuildCommon();\n\n  if (m_ppEncodingMCU == NULL) {\n    m_ppEncodingMCU = (struct Line **)m_pEnviron->AllocMem(sizeof(struct Line *) * m_ucCount *8);\n    memset(m_ppEncodingMCU,0,sizeof(struct Line *) * m_ucCount * 8);\n  }\n  \n  if (m_ppDownsampler == NULL) {\n    m_ppDownsampler = (class DownsamplerBase **)m_pEnviron->AllocMem(sizeof(class DownsamplerBase *) * m_ucCount);\n    memset(m_ppDownsampler,0,sizeof(class DownsamplerBase *) * m_ucCount);\n    \n    for(UBYTE i = 0;i < m_ucCount;i++) {\n      class Component *comp = m_pFrame->ComponentOf(i);\n      UBYTE sx = comp->SubXOf();\n      UBYTE sy = comp->SubYOf();\n\n      if (sx > 1 || sy > 1) {\n        m_ppDownsampler[i] = DownsamplerBase::CreateDownsampler(m_pEnviron,sx,sy,\n                                                                m_ulPixelWidth,m_ulPixelHeight,\n                                                                m_pFrame->TablesOf()->\n                                                                isDownsamplingInterpolated());\n        m_bSubsampling     = true;\n      }\n    }\n  }\n\n  if (m_pLargestScale)\n    m_pLargestScale->PrepareForEncoding();\n#endif\n}\n///\n\n/// HierarchicalBitmapRequester::PrepareForDecoding\n// First time usage: Collect all the information for encoding.\n// May throw on out of memory situations\nvoid HierarchicalBitmapRequester::PrepareForDecoding(void)\n{\n#if ACCUSOFT_CODE\n\n  UBYTE i;\n\n  BuildCommon();\n\n  if (m_ppDecodingMCU == NULL) {\n    m_ppDecodingMCU = (struct Line **)m_pEnviron->AllocMem(sizeof(struct Line *) * m_ucCount*8);\n    memset(m_ppDecodingMCU,0,sizeof(struct Line *) * m_ucCount * 8);\n  }\n\n  if (m_ppUpsampler == NULL) {\n    m_ppUpsampler = (class UpsamplerBase **)m_pEnviron->AllocMem(sizeof(class UpsamplerBase *) * m_ucCount);\n    memset(m_ppUpsampler,0,sizeof(class Upsampler *) * m_ucCount);\n\n    for(i = 0;i < m_ucCount;i++) {\n      class Component *comp = m_pFrame->ComponentOf(i);\n      UBYTE sx = comp->SubXOf();\n      UBYTE sy = comp->SubYOf();\n\n      if (m_pLargestScale) {\n        class Frame *frame = m_pLargestScale->FrameOf();\n        while(frame) {\n          if (frame->ComponentOf(i)->SubXOf() != sx || frame->ComponentOf(i)->SubYOf() != sy)\n            JPG_THROW(MALFORMED_STREAM,\"HierarchicalBitmapRequester::PrepareForDecoding\",\n                      \"component subsampling is inconsistent across hierarchical levels\");\n          frame = frame->NextOf();\n        }\n      }\n\n      if (sx > 1 || sy > 1) {\n        m_ppUpsampler[i] = UpsamplerBase::CreateUpsampler(m_pEnviron,sx,sy,\n                                                          m_ulPixelWidth,m_ulPixelHeight,\n                                                          m_pFrame->TablesOf()->isChromaCentered());\n        m_bSubsampling   = true;\n      }\n    }\n  }\n\n  if (m_pLargestScale)\n    m_pLargestScale->PrepareForDecoding();\n#endif\n}\n///\n\n/// HierarchicalBitmapRequester::ColorTrafoOf\n// Return the color transformer responsible for this scan.\nclass ColorTrafo *HierarchicalBitmapRequester::ColorTrafoOf(bool encoding,bool disabletorgb)\n{\n  return m_pFrame->TablesOf()->ColorTrafoOf(m_pFrame,NULL,PixelTypeOf(),\n                                            encoding,disabletorgb);\n}\n///\n\n/// HierarchicalBitmapRequester::AddImageScale\n// As soon as a frame is parsed off, or created: Add another scale to the image.\n// The boolean arguments identify whether the reference frame, i.e. what is\n// buffered already from previous frames, will be expanded.\nvoid HierarchicalBitmapRequester::AddImageScale(class Frame *frame,bool expandh,bool expandv)\n{\n#if ACCUSOFT_CODE\n  if (m_pLargestScale == NULL) {\n    assert(m_pSmallestScale == NULL);\n    assert(expandh == false && expandv == false);\n    // Actually, this is the smallest scale... as it is the first we build.\n    m_pLargestScale  = frame->BuildLineAdapter();\n    m_pSmallestScale = m_pLargestScale;\n    frame->SetImageBuffer(m_pLargestScale);\n  } else {\n    class LineMerger *merger;\n    // Two things need to be build: The adapter to the new band, and the merger\n    // that merges this band with the output and scales the result\n    // apropriately.\n    assert(m_pTempAdapter == NULL);\n    // This object will pull out lines from the new high-pass...\n    m_pTempAdapter   = frame->BuildLineAdapter();\n    // ...and this guy will merge them with what we currently have.\n    merger           = new(m_pEnviron) class LineMerger(frame,m_pLargestScale,m_pTempAdapter,\n                                                        expandh,expandv);\n    //\n    // And this becomes the next largest scale.\n    m_pLargestScale  = merger;\n    // and controls now the life-time of its children.\n    frame->SetImageBuffer(m_pTempAdapter);\n    m_pTempAdapter   = NULL; \n  }\n#else\n  NOREF(frame);\n  NOREF(expandh);\n  NOREF(expandv);\n#endif\n}\n///\n\n/// HierarchicalBitmapRequester::GenerateDifferentialImage\n// After having written the previous image, compute the differential from the downscaled\n// and-re-upscaled version and push it into the next frame, collect the\n// residuals, make this frame ready for encoding, and retrieve the downscaling\n// data.\nvoid HierarchicalBitmapRequester::GenerateDifferentialImage(class Frame *target,\n                                                            bool &hexp,bool &vexp)\n{\n#if ACCUSOFT_CODE\n  class LineAdapter *lap = m_pLargestScale;\n\n  while(lap) {\n    // The target frame must be one of the high-passes. The frame of a line\n    // adapter is that of the high-pass, so we can check for it.\n    if (lap->HighPassOf()->FrameOf() == target) {\n      class LineMerger *lm = (class LineMerger *)lap;\n      lm->GenerateDifferentialImage();\n      hexp = lm->isHorizontallyExpanding();\n      vexp = lm->isVerticallyExpanding();\n      return;\n    }\n    lap = lap->LowPassOf();\n  }\n  assert(!\"target band not found\");\n#else\n  NOREF(target);\n  NOREF(hexp);\n  NOREF(vexp);\n  JPG_THROW(NOT_IMPLEMENTED,\"HierarchicalBitmapRequester::GenerateDifferentialImage\",\n            \"Lossless JPEG not available in your code release, please contact Accusoft for a full version\");\n#endif\n}\n///\n\n/// HierarchicalBitmapRequester::DefineRegion\n// Define a single 8x8 block starting at the x offset and the given\n// line, taking the input 8x8 buffer.\n#if ACCUSOFT_CODE\nvoid HierarchicalBitmapRequester::DefineRegion(LONG x,const struct Line *const *line,\n                                               const LONG *buffer,UBYTE comp)\n{\n  int cnt = 8;\n  \n  assert(comp < m_ucCount);\n  NOREF(comp);\n\n  x <<= 3;\n  \n  do {\n    if (*line) memcpy((*line)->m_pData + x,buffer,8 * sizeof(LONG));\n    buffer += 8;\n    line++;\n  } while(--cnt);\n}\n#endif\n///\n\n/// HierarchicalBitmapRequester::FetchRegion\n// Define a single 8x8 block starting at the x offset and the given\n// line, taking the input 8x8 buffer.\n#if ACCUSOFT_CODE\nvoid HierarchicalBitmapRequester::FetchRegion(LONG x,const struct Line *const *line,LONG *buffer)\n{\n  int cnt = 8;\n  do {\n    if (*line) \n      memcpy(buffer,(*line)->m_pData + (x << 3),8 * sizeof(LONG));\n    buffer += 8;\n    line++;\n  } while(--cnt);\n}\n#endif\n///\n\n/// HierarchicalBitmapRequester::Allocate8Lines\n// Get the next block of eight lines of the image\n#if ACCUSOFT_CODE\nvoid HierarchicalBitmapRequester::Allocate8Lines(UBYTE c)\n{\n  int cnt;\n  ULONG y = m_pulY[c];\n  //\n  // Allocate a line block from the encoding line adapter.\n  for(cnt = 0;cnt < 8 && y < m_pulHeight[c];cnt++) {\n    assert(m_ppEncodingMCU[cnt | (c << 3)] == NULL);\n    m_ppEncodingMCU[cnt | (c << 3)] = m_pLargestScale->AllocateLine(c);\n    y++;\n  }\n}\n#endif\n///\n\n/// HierarchicalBitmapRequester::Push8Lines\n// Advance the image line pointer by the next eight lines\n// which is here a \"pseudo\"-MCU block.\n#if ACCUSOFT_CODE\nvoid HierarchicalBitmapRequester::Push8Lines(UBYTE c)\n{\n  int cnt;\n  ULONG y = m_pulY[c];\n  //\n  for(cnt = 0;cnt < 8 && y < m_pulHeight[c];cnt++) {\n    assert(m_ppEncodingMCU[cnt | (c << 3)]);\n    m_pLargestScale->PushLine(m_ppEncodingMCU[cnt | (c << 3)],c);\n    m_ppEncodingMCU[cnt | (c << 3)] = NULL;\n    y++;\n  }\n\n  m_pulY[c] = y;\n}\n#endif\n///\n\n/// HierarchicalBitmapRequester::Pull8Lines\n// Pull 8 lines from the top-level and place them into\n// the decoder MCU.\n#if ACCUSOFT_CODE\nvoid HierarchicalBitmapRequester::Pull8Lines(UBYTE c)\n{ \n int cnt;\n  ULONG y = m_pulY[c];\n  //\n  // Allocate a line block from the encoding line adapter.\n  for(cnt = 0;cnt < 8 && y < m_pulHeight[c];cnt++) {\n    assert(m_ppDecodingMCU[cnt | (c << 3)] == NULL);\n    m_ppDecodingMCU[cnt | (c << 3)] = m_pLargestScale->GetNextLine(c);\n    y++;\n  }\n}\n#endif\n///\n\n/// HierarchicalBitmapRequester::Release8Lines\n// Release the currently buffered decoder MCU for the given component.\n#if ACCUSOFT_CODE\nvoid HierarchicalBitmapRequester::Release8Lines(UBYTE c)\n{ \n  int cnt;\n  ULONG y = m_pulY[c];\n  //\n  for(cnt = 0;cnt < 8 && y < m_pulHeight[c];cnt++) {\n    assert(m_ppDecodingMCU[cnt | (c << 3)]);\n    m_pLargestScale->ReleaseLine(m_ppDecodingMCU[cnt | (c << 3)],c);\n    m_ppDecodingMCU[cnt | (c << 3)] = NULL;\n    y++;\n  }\n}\n#endif\n///\n\n/// HierarchicalBitmapRequester::CropEncodingRegion\n// First step of a region encoder: Find the region that can be pulled in the next step,\n// from a rectangle request. This potentially shrinks the rectangle, which should be\n// initialized to the full image.\nvoid HierarchicalBitmapRequester::CropEncodingRegion(RectAngle<LONG> &region,const struct RectangleRequest *)\n{ \n#if ACCUSOFT_CODE\n  int i;\n\n  ClipToImage(region);\n\n  // Find the region to request.\n  for(i = 0;i < m_ucCount;i++) {\n    if (m_pulReadyLines[i] < ULONG(region.ra_MinY))\n      region.ra_MinY = m_pulReadyLines[i];\n  }\n#else\n  NOREF(region);\n#endif\n}\n///\n\n/// HierarchicalBitmapRequester::RequestUserDataForEncoding\n// Request user data for encoding for the given region, potentially clip the region to the\n// data available from the user.\nvoid HierarchicalBitmapRequester::RequestUserDataForEncoding(class BitMapHook *bmh,RectAngle<LONG> &region,bool alpha)\n{\n#if ACCUSOFT_CODE\n  int i;\n\n  m_ulMaxMCU = MAX_ULONG;\n  \n  for(i = 0;i < m_ucCount;i++) {\n    ULONG max;\n    //\n    // Components are always requested completely on encoding.\n    RequestUserData(bmh,region,i,alpha);\n    // All components must have the same sample precision here.\n    max = (m_ppBitmap[i]->ibm_ulHeight - 1) >> 3;\n    if (max < m_ulMaxMCU)\n      m_ulMaxMCU = max; \n    if (LONG(m_ppBitmap[i]->ibm_ulHeight) - 1 < region.ra_MaxY)\n      region.ra_MaxY = m_ppBitmap[i]->ibm_ulHeight - 1;\n  }\n#else\n  NOREF(bmh);\n  NOREF(region);\n  NOREF(alpha);\n#endif\n}\n///\n\n/// HierarchicalBitmapRequester::RequestUserDataForDecoding\n// Pull data buffers from the user data bitmap hook\nvoid HierarchicalBitmapRequester::RequestUserDataForDecoding(class BitMapHook *bmh,RectAngle<LONG> &region,\n                                                             const struct RectangleRequest *rr,bool alpha)\n{\n#if ACCUSOFT_CODE\n  int i;\n\n  ResetBitmaps();\n  \n  if (m_pLargestScale->FrameOf()->WidthOf()   != m_pFrame->WidthOf() ||\n      (m_pLargestScale->FrameOf()->HeightOf() != m_pFrame->HeightOf() &&\n       m_pLargestScale->FrameOf()->HeightOf() != 0 && m_pFrame->HeightOf() != 0)) {\n    JPG_THROW(MALFORMED_STREAM,\"HierarchicalBitmapRequester::ReconstructRegion\",\n              \"hierarchical frame hierarchy is damaged, largest frame does not match the image\");\n  }\n  \n  if (m_ulPixelHeight == 0) {\n    ULONG height = 0;\n    if (m_pLargestScale->FrameOf()->HeightOf() != 0) {\n      height = m_pLargestScale->FrameOf()->HeightOf();\n    } else if (m_pFrame->HeightOf() != 0) {\n      height = m_pFrame->HeightOf();\n    }\n    if (height) {\n      PostImageHeight(height);\n    }\n  }\n  \n  m_ulMaxMCU = MAX_ULONG;\n  \n  for(i = rr->rr_usFirstComponent;i <= rr->rr_usLastComponent;i++) {\n    RequestUserData(bmh,region,i,alpha);\n    ULONG max = (BitmapOf(i).ibm_ulHeight >> 3) - 1;\n    if (max < m_ulMaxMCU)\n      m_ulMaxMCU = max;\n  }\n#else\n  NOREF(bmh);\n  NOREF(region);\n  NOREF(rr);\n  NOREF(alpha);\n#endif\n}\n///\n\n/// HierarchicalBitmapRequester::EncodeRegion\n// Encode a region without downsampling but color transformation\nvoid HierarchicalBitmapRequester::EncodeRegion(const RectAngle<LONG> &region)\n{\n#if ACCUSOFT_CODE\n  class ColorTrafo *ctrafo = ColorTrafoOf(true,false);\n  int i;\n  // \n\n  if (m_bSubsampling) { \n    RectAngle<LONG> r;\n    ULONG minx   = region.ra_MinX >> 3;\n    ULONG maxx   = region.ra_MaxX >> 3;\n    ULONG miny   = region.ra_MinY >> 3;\n    ULONG maxy   = region.ra_MaxY >> 3;\n    ULONG x,y;\n    \n    // First part: Collect the data from\n    // the user and push it into the color transformer buffer.\n    // For that first build the downsampler.\n    for(i = 0;i < m_ucCount;i++) {\n      if (m_ppDownsampler[i]) {\n        m_ppDownsampler[i]->SetBufferedRegion(region);\n      }\n    }\n    \n    for(y = miny,r.ra_MinY = region.ra_MinY;y <= maxy;y++,r.ra_MinY = r.ra_MaxY + 1) {\n      r.ra_MaxY = (r.ra_MinY & -8) + 7;\n      if (r.ra_MaxY > region.ra_MaxY)\n        r.ra_MaxY = region.ra_MaxY;\n\n      for(i = 0;i < m_ucCount;i++) {\n        if (m_ppDownsampler[i] == NULL) {\n          Allocate8Lines(i);\n        }\n      }\n      \n      for(x = minx,r.ra_MinX = region.ra_MinX;x <= maxx;x++,r.ra_MinX = r.ra_MaxX + 1) {\n        r.ra_MaxX = (r.ra_MinX & -8) + 7;\n        if (r.ra_MaxX > region.ra_MaxX)\n          r.ra_MaxX = region.ra_MaxX;\n        \n        for(i = 0;i < m_ucCount;i++) {\n          // Collect the source data.\n          ExtractBitmap(m_ppTempIBM[i],r,i);\n        }\n        \n        //\n        // Run the color transformer.\n        ctrafo->RGB2YCbCr(r,m_ppTempIBM,m_ppCTemp);\n        \n        // Now push the transformed data into either the downsampler, \n        // or the forward DCT block row.\n        for(i = 0;i < m_ucCount;i++) {\n          if (m_ppDownsampler[i]) {\n            // Just collect the data in the downsampler for the time\n            // being. Will be taken care of as soon as it is complete.\n            m_ppDownsampler[i]->DefineRegion(x,y,m_ppCTemp[i]);\n          } else { \n            DefineRegion(x,m_ppEncodingMCU + (i << 3),m_ppCTemp[i],i);\n          }\n        }\n      }\n      //\n      // Advance the quantized rows for the non-subsampled components,\n      // downsampled components will be advanced later.\n      for(i = 0;i < m_ucCount;i++) {\n        m_pulReadyLines[i]    += 8; // somehwere in the buffer.\n        if (m_ppDownsampler[i] == NULL) {\n          Push8Lines(i);\n        } else {\n          LONG bx,by;\n          RectAngle<LONG> blocks;\n          // Collect the downsampled blocks and push that into the DCT.\n          m_ppDownsampler[i]->GetCollectedBlocks(blocks);\n          for(by = blocks.ra_MinY;by <= blocks.ra_MaxY;by++) {\n            Allocate8Lines(i);\n            for(bx = blocks.ra_MinX;bx <= blocks.ra_MaxX;bx++) {\n              LONG src[64]; // temporary buffer, the DCT requires a 8x8 block\n              m_ppDownsampler[i]->DownsampleRegion(bx,by,src);\n              DefineRegion(bx,m_ppEncodingMCU + (i << 3),src,i);\n            }\n            m_ppDownsampler[i]->RemoveBlocks(by);\n            Push8Lines(i);\n          }\n        }\n      }\n    }\n  } else { // No downsampling required, residual coding possible.\n    RectAngle<LONG> r;\n    ULONG minx   = region.ra_MinX >> 3;\n    ULONG maxx   = region.ra_MaxX >> 3;\n    ULONG miny   = region.ra_MinY >> 3;\n    ULONG maxy   = region.ra_MaxY >> 3;\n    ULONG x,y;\n\n    for(y = miny,r.ra_MinY = region.ra_MinY;y <= maxy;y++,r.ra_MinY = r.ra_MaxY + 1) {\n      r.ra_MaxY = (r.ra_MinY & -8) + 7;\n      if (r.ra_MaxY > region.ra_MaxY)\n        r.ra_MaxY = region.ra_MaxY;\n\n      for(i = 0;i < m_ucCount;i++) {\n        Allocate8Lines(i);\n      }\n      \n      for(x = minx,r.ra_MinX = region.ra_MinX;x <= maxx;x++,r.ra_MinX = r.ra_MaxX + 1) {\n        r.ra_MaxX = (r.ra_MinX & -8) + 7;\n        if (r.ra_MaxX > region.ra_MaxX)\n          r.ra_MaxX = region.ra_MaxX;\n\n        for(i = 0;i < m_ucCount;i++) {      \n          ExtractBitmap(m_ppTempIBM[i],r,i);\n        }\n        \n        ctrafo->RGB2YCbCr(r,m_ppTempIBM,m_ppCTemp);\n\n        for(i = 0;i < m_ucCount;i++) {\n          DefineRegion(x,m_ppEncodingMCU + (i << 3),m_ppCTemp[i],i);\n        }\n      }\n      for(i = 0;i < m_ucCount;i++) {\n        Push8Lines(i);\n        m_pulReadyLines[i]   += 8;\n      }\n    }\n  }\n#else\n  NOREF(region);\n#endif\n}\n///\n\n/// HierarchicalBitmapRequester::ReconstructRegion\n// Reconstruct a block, or part of a block\nvoid HierarchicalBitmapRequester::ReconstructRegion(const RectAngle<LONG> &orgregion,const struct RectangleRequest *rr)\n{\n#if ACCUSOFT_CODE\n  class ColorTrafo *ctrafo = ColorTrafoOf(false,!rr->rr_bColorTrafo);\n  UBYTE i;\n  \n  if (m_bSubsampling && rr->rr_bUpsampling) { \n    for(i = rr->rr_usFirstComponent;i <= rr->rr_usLastComponent;i++) {\n      class Component *comp = m_pFrame->ComponentOf(i);\n      UBYTE subx            = comp->SubXOf();\n      UBYTE suby            = comp->SubYOf();\n      class UpsamplerBase *up;  // upsampler\n      LONG bx,by;\n      RectAngle<LONG> blocks;\n      //\n      // Compute the region of blocks\n      assert(subx > 0 && suby > 0);\n      if ((up = m_ppUpsampler[i])) {\n        LONG bwidth           = ((m_ulPixelWidth  + subx - 1) / subx + 7) >> 3;\n        LONG bheight          = ((m_ulPixelHeight + suby - 1) / suby + 7) >> 3;\n        LONG rx               = (subx > 1)?(1):(0);\n        LONG ry               = (suby > 1)?(1):(0);\n        // The +/-1 include additional lines required for subsampling expansion\n        blocks.ra_MinX        = ((orgregion.ra_MinX / subx - rx) >> 3);\n        blocks.ra_MaxX        = ((orgregion.ra_MaxX / subx + rx) >> 3);\n        blocks.ra_MinY        = ((orgregion.ra_MinY / suby - ry) >> 3);\n        blocks.ra_MaxY        = ((orgregion.ra_MaxY / suby + ry) >> 3);\n        // Clip.\n        if (blocks.ra_MinX < 0)        blocks.ra_MinX = 0;\n        if (blocks.ra_MaxX >= bwidth)  blocks.ra_MaxX = bwidth - 1;\n        if (blocks.ra_MinY < 0)        blocks.ra_MinY = 0;\n        if (blocks.ra_MaxY >= bheight) blocks.ra_MaxY = bheight - 1;\n        up->SetBufferedRegion(blocks); // also removes the rectangle of blocks already buffered.\n        //\n        for(by = blocks.ra_MinY;by <= blocks.ra_MaxY;by++) {\n          Pull8Lines(i);\n          for(bx = blocks.ra_MinX;bx <= blocks.ra_MaxX;bx++) {\n            LONG dst[64];\n            FetchRegion(bx,m_ppDecodingMCU + (i << 3),dst);\n            up->DefineRegion(bx,by,dst);\n          }\n          Release8Lines(i);\n        }\n      } else {\n        // Load into the decoding MCU\n        Pull8Lines(i);\n      }\n    }\n    // Now push blocks into the color transformer from the upsampler.\n    {\n      RectAngle<LONG> r;\n      ULONG minx   = orgregion.ra_MinX >> 3;\n      ULONG maxx   = orgregion.ra_MaxX >> 3;\n      ULONG miny   = orgregion.ra_MinY >> 3;\n      ULONG maxy   = orgregion.ra_MaxY >> 3;\n      ULONG x,y;\n      \n      if (maxy > m_ulMaxMCU)\n        maxy = m_ulMaxMCU;\n\n      for(y = miny,r.ra_MinY = orgregion.ra_MinY;y <= maxy;y++,r.ra_MinY = r.ra_MaxY + 1) {\n        r.ra_MaxY = (r.ra_MinY & -8) + 7;\n        if (r.ra_MaxY > orgregion.ra_MaxY)\n          r.ra_MaxY = orgregion.ra_MaxY;\n        \n        for(x = minx,r.ra_MinX = orgregion.ra_MinX;x <= maxx;x++,r.ra_MinX = r.ra_MaxX + 1) {\n          r.ra_MaxX = (r.ra_MinX & -8) + 7;\n          if (r.ra_MaxX > orgregion.ra_MaxX)\n            r.ra_MaxX = orgregion.ra_MaxX;\n          \n          for(i = 0;i < m_ucCount;i++) {\n            if (i >= rr->rr_usFirstComponent && i <= rr->rr_usLastComponent) {\n              ExtractBitmap(m_ppTempIBM[i],r,i);\n              if (m_ppUpsampler[i]) {\n                // Upsampled case, take from the upsampler, transform\n                // into the color buffer.\n                m_ppUpsampler[i]->UpsampleRegion(r,m_ppCTemp[i]);\n              } else {\n                FetchRegion(x,m_ppDecodingMCU + (i << 3),m_ppCTemp[i]);\n              }\n            } else {\n              // Not requested, zero the buffer.\n              memset(m_ppCTemp[i],0,sizeof(LONG) * 64);\n            }\n          }\n          ctrafo->YCbCr2RGB(r,m_ppTempIBM,m_ppCTemp,NULL);\n        }\n        //\n        // Advance the quantized rows for the non-subsampled components,\n        // upsampled components have been advanced above.\n        for(i = rr->rr_usFirstComponent;i <= rr->rr_usLastComponent;i++) {\n          if (m_ppUpsampler[i] == NULL)\n            Release8Lines(i);\n        }\n      }\n    }\n  } else { \n    // direct case, no upsampling required, residual coding possible, but not applied here.\n    RectAngle<LONG> r;\n    RectAngle<LONG> region = orgregion;\n    SubsampledRegion(region,rr);\n    ULONG minx   = region.ra_MinX >> 3;\n    ULONG maxx   = region.ra_MaxX >> 3;\n    ULONG miny   = region.ra_MinY >> 3;\n    ULONG maxy   = region.ra_MaxY >> 3;\n    ULONG x,y;\n      \n    if (maxy > m_ulMaxMCU)\n      maxy = m_ulMaxMCU;\n\n    for(i = rr->rr_usFirstComponent;i <= rr->rr_usLastComponent;i++) {\n      Pull8Lines(i);\n    }\n    \n    for(y = miny,r.ra_MinY = region.ra_MinY;y <= maxy;y++,r.ra_MinY = r.ra_MaxY + 1) {\n      r.ra_MaxY = (r.ra_MinY & -8) + 7;\n      if (r.ra_MaxY > region.ra_MaxY)\n        r.ra_MaxY = region.ra_MaxY;\n        \n      for(x = minx,r.ra_MinX = region.ra_MinX;x <= maxx;x++,r.ra_MinX = r.ra_MaxX + 1) {\n        r.ra_MaxX = (r.ra_MinX & -8) + 7;\n        if (r.ra_MaxX > region.ra_MaxX)\n          r.ra_MaxX = region.ra_MaxX;\n\n        for(i = 0;i < m_ucCount;i++) {      \n          LONG *dst = m_ppCTemp[i];\n          if (i >= rr->rr_usFirstComponent && i <= rr->rr_usLastComponent) {\n            ExtractBitmap(m_ppTempIBM[i],r,i);\n            FetchRegion(x,m_ppDecodingMCU + (i << 3),dst);\n          } else {\n            memset(dst,0,sizeof(LONG) * 64);\n          }\n        }\n        //\n        // Perform the color transformation now.\n        ctrafo->YCbCr2RGB(r,m_ppTempIBM,m_ppCTemp,NULL);\n      } // of loop over x\n      //\n      // Advance the rows.\n      for(i = rr->rr_usFirstComponent;i <= rr->rr_usLastComponent;i++) {\n        Release8Lines(i);\n      }\n    }\n  }\n#else\n  NOREF(orgregion);\n  NOREF(rr);\n#endif\n}\n///\n\n/// HierarchicalBitmapRequester::isNextMCULineReady\n// Return true if the next MCU line is buffered and can be pushed\n// to the encoder.\nbool HierarchicalBitmapRequester::isNextMCULineReady(void) const\n{\n#if ACCUSOFT_CODE\n  // MCUs can only be written if the smallest scale, which is written first,\n  // is ready.\n  return m_pSmallestScale->isNextMCULineReady();\n#else\n  return false;\n#endif\n}\n///\n\n/// HierarchicalBitmapRequester::ResetToStartOfImage\n// Reset all components on the image side of the control to the\n// start of the image. Required when re-requesting the image\n// for encoding or decoding.\nvoid HierarchicalBitmapRequester::ResetToStartOfImage(void)\n{\n#if ACCUSOFT_CODE\n  for(UBYTE i = 0;i < m_ucCount;i++) {\n    m_pulY[i] = 0;\n    m_pulReadyLines[i] = 0;\n  }\n  //\n  assert(m_pLargestScale);\n  // Now iterate through the tree.\n  m_pLargestScale->ResetToStartOfImage();\n#endif\n}\n///\n\n/// HierarchicalBitmapRequester::isImageComplete\n// Return an indicator whether all of the image has been loaded into\n// the image buffer.\nbool HierarchicalBitmapRequester::isImageComplete(void) const\n{ \n#if ACCUSOFT_CODE\n  for(UBYTE i = 0;i < m_ucCount;i++) {\n    if (m_pulReadyLines[i] < m_ulPixelHeight)\n      return false;\n  }\n  return true;\n#else\n  return false;\n#endif\n}\n///\n\n/// HierarchicalBitmapRequester::BufferedLines\n// Return the number of lines available for reconstruction from this scan.\nULONG HierarchicalBitmapRequester::BufferedLines(const struct RectangleRequest *rr) const\n{\n#if ACCUSOFT_CODE\n  ULONG maxlines = m_ulPixelHeight;\n  \n  for(UBYTE i = rr->rr_usFirstComponent;i <= rr->rr_usLastComponent;i++) {\n    class Component *comp = m_pFrame->ComponentOf(i);\n    UBYTE suby            = comp->SubYOf();\n    ULONG lines;\n    // Since the user here asks for complete(!) lines and the highpass comes last\n    // in the codestream, ask the highpass about how many lines are buffered.\n    // These lines are counted in subsampled lines.\n    lines = m_pLargestScale->BufferedLines(i);\n    if (lines >= m_pulHeight[i]) {\n      lines = m_ulPixelHeight;\n    } else if (suby > 1 && lines > 0) {\n      lines = ((lines - 1) * suby) & (-8); // one additional subsampled line, actually,;\n    } else {\n      lines = (lines * suby) & (-8); \n    }\n    if (lines < maxlines)\n      maxlines = lines;\n  }\n\n  return maxlines;\n#else\n  NOREF(rr);\n  return 0;\n#endif\n}\n///\n\n/// HierarchicalBitmapRequester::PostImageHeight\n// Post the height of the frame in lines. This happens\n// when the DNL marker is processed.\nvoid HierarchicalBitmapRequester::PostImageHeight(ULONG lines)\n{\n  BitmapCtrl::PostImageHeight(lines);\n#if ACCUSOFT_CODE\n  assert(m_pulHeight);\n\n  if (m_pLargestScale)\n    m_pLargestScale->PostImageHeight(lines);\n  \n  for(UBYTE i = 0;i < m_ucCount;i++) {\n    class Component *comp = m_pFrame->ComponentOf(i);\n    UBYTE suby            = comp->SubYOf();\n    m_pulHeight[i]        = (m_ulPixelHeight + suby - 1) / suby;\n  }\n#endif\n}\n///\n"], "filenames": ["README", "README.history", "control/hierarchicalbitmaprequester.cpp"], "buggy_code_start_loc": [462, 567, 48], "buggy_code_end_loc": [462, 569, 246], "fixing_code_start_loc": [463, 567, 48], "fixing_code_end_loc": [465, 571, 257], "type": "CWE-125", "message": "libjpeg 1.63 has a heap-based buffer over-read in HierarchicalBitmapRequester::FetchRegion in hierarchicalbitmaprequester.cpp because the MCU size can be different between allocation and use.", "other": {"cve": {"id": "CVE-2022-31796", "sourceIdentifier": "cve@mitre.org", "published": "2022-06-02T14:15:58.153", "lastModified": "2022-06-13T14:24:29.400", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "libjpeg 1.63 has a heap-based buffer over-read in HierarchicalBitmapRequester::FetchRegion in hierarchicalbitmaprequester.cpp because the MCU size can be different between allocation and use."}, {"lang": "es", "value": "libjpeg versi\u00f3n 1.63, presenta una lectura excesiva del b\u00fafer en la regi\u00f3n heap de la memoria en la funci\u00f3n HierarchicalBitmapRequester::FetchRegion en el archivo hierarchicalbitmaprequester.cpp porque el tama\u00f1o de la MCU puede ser diferente entre la asignaci\u00f3n y el uso"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:jpeg:libjpeg:1.63:*:*:*:*:*:*:*", "matchCriteriaId": "13A26F18-0121-441E-AEF2-B13F7E608A8F"}]}]}], "references": [{"url": "https://github.com/thorfdbg/libjpeg/commit/187035b9726710b4fe11d565c7808975c930895d", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/thorfdbg/libjpeg/issues/71", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/thorfdbg/libjpeg/commit/187035b9726710b4fe11d565c7808975c930895d"}}