{"buggy_code": ["/*\n  Copyright (C) 2010  ABRT team\n\n  This program is free software; you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation; either version 2 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License along\n  with this program; if not, write to the Free Software Foundation, Inc.,\n  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n*/\n#include \"problem_api.h\"\n#include \"libabrt.h\"\n\n/* Maximal length of backtrace. */\n#define MAX_BACKTRACE_SIZE (1024*1024)\n/* Amount of data received from one client for a message before reporting error. */\n#define MAX_MESSAGE_SIZE (4*MAX_BACKTRACE_SIZE)\n/* Maximal number of characters read from socket at once. */\n#define INPUT_BUFFER_SIZE (8*1024)\n/* We exit after this many seconds */\n#define TIMEOUT 10\n\n\n/*\nUnix socket in ABRT daemon for creating new dump directories.\n\nWhy to use socket for creating dump dirs? Security. When a Python\nscript throws unexpected exception, ABRT handler catches it, running\nas a part of that broken Python application. The application is running\nwith certain SELinux privileges, for example it can not execute other\nprograms, or to create files in /var/cache or anything else required\nto properly fill a problem directory. Adding these privileges to every\napplication would weaken the security.\nThe most suitable solution is for the Python application\nto open a socket where ABRT daemon is listening, write all relevant\ndata to that socket, and close it. ABRT daemon handles the rest.\n\n** Protocol\n\nInitializing new dump:\nopen /var/run/abrt.socket\n\nProviding dump data (hook writes to the socket):\nMANDATORY ITEMS:\n-> \"PID=\"\n   number 0 - PID_MAX (/proc/sys/kernel/pid_max)\n   \\0\n-> \"EXECUTABLE=\"\n   string\n   \\0\n-> \"BACKTRACE=\"\n   string\n   \\0\n-> \"ANALYZER=\"\n   string\n   \\0\n-> \"BASENAME=\"\n   string (no slashes)\n   \\0\n-> \"REASON=\"\n   string\n   \\0\n\nYou can send more messages using the same KEY=value format.\n*/\n\nstatic unsigned total_bytes_read = 0;\n\nstatic uid_t client_uid = (uid_t)-1L;\n\n\n/* Remove dump dir */\nstatic int delete_path(const char *dump_dir_name)\n{\n    /* If doesn't start with \"g_settings_dump_location/\"... */\n    if (!dir_is_in_dump_location(dump_dir_name))\n    {\n        /* Then refuse to operate on it (someone is attacking us??) */\n        error_msg(\"Bad problem directory name '%s', should start with: '%s'\", dump_dir_name, g_settings_dump_location);\n        return 400; /* Bad Request */\n    }\n    if (!dir_has_correct_permissions(dump_dir_name))\n    {\n        error_msg(\"Problem directory '%s' isn't owned by root:abrt or others are not restricted from access\", dump_dir_name);\n        return 400; /*  */\n    }\n\n    int dir_fd = dd_openfd(dump_dir_name);\n    if (dir_fd < 0)\n    {\n        perror_msg(\"Can't open problem directory '%s'\", dump_dir_name);\n        return 400;\n    }\n    if (!fdump_dir_accessible_by_uid(dir_fd, client_uid))\n    {\n        close(dir_fd);\n        if (errno == ENOTDIR)\n        {\n            error_msg(\"Path '%s' isn't problem directory\", dump_dir_name);\n            return 404; /* Not Found */\n        }\n        error_msg(\"Problem directory '%s' can't be accessed by user with uid %ld\", dump_dir_name, (long)client_uid);\n        return 403; /* Forbidden */\n    }\n\n    struct dump_dir *dd = dd_fdopendir(dir_fd, dump_dir_name, /*flags:*/ 0);\n    if (dd)\n    {\n        if (dd_delete(dd) != 0)\n        {\n            error_msg(\"Failed to delete problem directory '%s'\", dump_dir_name);\n            dd_close(dd);\n            return 400;\n        }\n    }\n\n    return 0; /* success */\n}\n\nstatic pid_t spawn_event_handler_child(const char *dump_dir_name, const char *event_name, int *fdp)\n{\n    char *args[7];\n    args[0] = (char *) LIBEXEC_DIR\"/abrt-handle-event\";\n    /* Do not forward ASK_* messages to parent*/\n    args[1] = (char *) \"-i\";\n    args[2] = (char *) \"-e\";\n    args[3] = (char *) event_name;\n    args[4] = (char *) \"--\";\n    args[5] = (char *) dump_dir_name;\n    args[6] = NULL;\n\n    int pipeout[2];\n    int flags = EXECFLG_INPUT_NUL | EXECFLG_OUTPUT | EXECFLG_QUIET | EXECFLG_ERR2OUT;\n    VERB1 flags &= ~EXECFLG_QUIET;\n\n    char *env_vec[2];\n    /* Intercept ASK_* messages in Client API -> don't wait for user response */\n    env_vec[0] = xstrdup(\"REPORT_CLIENT_NONINTERACTIVE=1\");\n    env_vec[1] = NULL;\n\n    pid_t child = fork_execv_on_steroids(flags, args, pipeout,\n                                         env_vec, /*dir:*/ NULL,\n                                         /*uid(unused):*/ 0);\n    if (fdp)\n        *fdp = pipeout[0];\n    return child;\n}\n\nstatic int run_post_create(const char *dirname)\n{\n    /* If doesn't start with \"g_settings_dump_location/\"... */\n    if (!dir_is_in_dump_location(dirname))\n    {\n        /* Then refuse to operate on it (someone is attacking us??) */\n        error_msg(\"Bad problem directory name '%s', should start with: '%s'\", dirname, g_settings_dump_location);\n        return 400; /* Bad Request */\n    }\n    if (!dir_has_correct_permissions(dirname))\n    {\n        error_msg(\"Problem directory '%s' isn't owned by root:abrt or others are not restricted from access\", dirname);\n        return 400; /*  */\n    }\n    if (g_settings_privatereports)\n    {\n        struct dump_dir *dd = dd_opendir(dirname, DD_OPEN_READONLY);\n        const bool complete = dd && problem_dump_dir_is_complete(dd);\n        dd_close(dd);\n        if (complete)\n        {\n            error_msg(\"Problem directory '%s' has already been processed\", dirname);\n            return 403;\n        }\n    }\n    else if (!dump_dir_accessible_by_uid(dirname, client_uid))\n    {\n        if (errno == ENOTDIR)\n        {\n            error_msg(\"Path '%s' isn't problem directory\", dirname);\n            return 404; /* Not Found */\n        }\n        error_msg(\"Problem directory '%s' can't be accessed by user with uid %ld\", dirname, (long)client_uid);\n        return 403; /* Forbidden */\n    }\n\n    int child_stdout_fd;\n    int child_pid = spawn_event_handler_child(dirname, \"post-create\", &child_stdout_fd);\n\n    char *dup_of_dir = NULL;\n    struct strbuf *cmd_output = strbuf_new();\n\n    bool child_is_post_create = 1; /* else it is a notify child */\n\n read_child_output:\n    //log(\"Reading from event fd %d\", child_stdout_fd);\n\n    /* Read streamed data and split lines */\n    for (;;)\n    {\n        char buf[250]; /* usually we get one line, no need to have big buf */\n        errno = 0;\n        int r = safe_read(child_stdout_fd, buf, sizeof(buf) - 1);\n        if (r <= 0)\n            break;\n        buf[r] = '\\0';\n\n        /* split lines in the current buffer */\n        char *raw = buf;\n        char *newline;\n        while ((newline = strchr(raw, '\\n')) != NULL)\n        {\n            *newline = '\\0';\n            strbuf_append_str(cmd_output, raw);\n            char *msg = cmd_output->buf;\n\n            /* Hmm, DUP_OF_DIR: ends up in syslog. move log() into 'else'? */\n            log(\"%s\", msg);\n\n            if (child_is_post_create\n             && prefixcmp(msg, \"DUP_OF_DIR: \") == 0\n            ) {\n                free(dup_of_dir);\n                dup_of_dir = xstrdup(msg + strlen(\"DUP_OF_DIR: \"));\n            }\n\n            strbuf_clear(cmd_output);\n            /* jump to next line */\n            raw = newline + 1;\n        }\n\n        /* beginning of next line. the line continues by next read */\n        strbuf_append_str(cmd_output, raw);\n    }\n\n    /* EOF/error */\n\n    /* Wait for child to actually exit, collect status */\n    int status = 0;\n    if (safe_waitpid(child_pid, &status, 0) <= 0)\n    /* should not happen */\n        perror_msg(\"waitpid(%d)\", child_pid);\n\n    /* If it was a \"notify[-dup]\" event, then we're done */\n    if (!child_is_post_create)\n        goto ret;\n\n    /* exit 0 means \"this is a good, non-dup dir\" */\n    /* exit with 1 + \"DUP_OF_DIR: dir\" string => dup */\n    if (status != 0)\n    {\n        if (WIFSIGNALED(status))\n        {\n            log(\"'post-create' on '%s' killed by signal %d\",\n                            dirname, WTERMSIG(status));\n            goto delete_bad_dir;\n        }\n        /* else: it is WIFEXITED(status) */\n        if (!dup_of_dir)\n        {\n            log(\"'post-create' on '%s' exited with %d\",\n                            dirname, WEXITSTATUS(status));\n            goto delete_bad_dir;\n        }\n    }\n\n    const char *work_dir = (dup_of_dir ? dup_of_dir : dirname);\n\n    /* Load problem_data (from the *first dir* if this one is a dup) */\n    struct dump_dir *dd = dd_opendir(work_dir, /*flags:*/ 0);\n    if (!dd)\n        /* dd_opendir already emitted error msg */\n        goto delete_bad_dir;\n\n    /* Update count */\n    char *count_str = dd_load_text_ext(dd, FILENAME_COUNT, DD_FAIL_QUIETLY_ENOENT);\n    unsigned long count = strtoul(count_str, NULL, 10);\n\n    /* Don't increase crash count if we are working with newly uploaded\n     * directory (remote crash) which already has its crash count set.\n     */\n    if ((status != 0 && dup_of_dir) || count == 0)\n    {\n        count++;\n        char new_count_str[sizeof(long)*3 + 2];\n        sprintf(new_count_str, \"%lu\", count);\n        dd_save_text(dd, FILENAME_COUNT, new_count_str);\n\n        /* This condition can be simplified to either\n         * (status * != 0 && * dup_of_dir) or (count == 1). But the\n         * chosen form is much more reliable and safe. We must not call\n         * dd_opendir() to locked dd otherwise we go into a deadlock.\n         */\n        if (strcmp(dd->dd_dirname, dirname) != 0)\n        {\n            /* Update the last occurrence file by the time file of the new problem */\n            struct dump_dir *new_dd = dd_opendir(dirname, DD_OPEN_READONLY);\n            char *last_ocr = NULL;\n            if (new_dd)\n            {\n                /* TIME must exists in a valid dump directory but we don't want to die\n                 * due to broken duplicated dump directory */\n                last_ocr = dd_load_text_ext(new_dd, FILENAME_TIME,\n                            DD_LOAD_TEXT_RETURN_NULL_ON_FAILURE | DD_FAIL_QUIETLY_ENOENT);\n                dd_close(new_dd);\n            }\n            else\n            {   /* dd_opendir() already produced a message with good information about failure */\n                error_msg(\"Can't read the last occurrence file from the new dump directory.\");\n            }\n\n            if (!last_ocr)\n            {   /* the new dump directory may lie in the dump location for some time */\n                log(\"Using current time for the last occurrence file which may be incorrect.\");\n                time_t t = time(NULL);\n                last_ocr = xasprintf(\"%lu\", (long)t);\n            }\n\n            dd_save_text(dd, FILENAME_LAST_OCCURRENCE, last_ocr);\n\n            free(last_ocr);\n        }\n    }\n\n    /* Reset mode/uig/gid to correct values for all files created by event run */\n    dd_sanitize_mode_and_owner(dd);\n\n    dd_close(dd);\n\n    if (!dup_of_dir)\n        log_notice(\"New problem directory %s, processing\", work_dir);\n    else\n    {\n        log_warning(\"Deleting problem directory %s (dup of %s)\",\n                    strrchr(dirname, '/') + 1,\n                    strrchr(dup_of_dir, '/') + 1);\n        delete_dump_dir(dirname);\n    }\n\n    /* Run \"notify[-dup]\" event */\n    int fd;\n    child_pid = spawn_event_handler_child(\n                work_dir,\n                (dup_of_dir ? \"notify-dup\" : \"notify\"),\n                &fd\n    );\n    //log(\"Started notify, fd %d -> %d\", fd, child_stdout_fd);\n    xmove_fd(fd, child_stdout_fd);\n    child_is_post_create = 0;\n    strbuf_clear(cmd_output);\n    free(dup_of_dir);\n    dup_of_dir = NULL;\n    goto read_child_output;\n\n delete_bad_dir:\n    log_warning(\"Deleting problem directory '%s'\", dirname);\n    delete_dump_dir(dirname);\n\n ret:\n    strbuf_free(cmd_output);\n    free(dup_of_dir);\n    close(child_stdout_fd);\n    return 0;\n}\n\n/* Create a new problem directory from client session.\n * Caller must ensure that all fields in struct client\n * are properly filled.\n */\nstatic int create_problem_dir(GHashTable *problem_info, unsigned pid)\n{\n    /* Exit if free space is less than 1/4 of MaxCrashReportsSize */\n    if (g_settings_nMaxCrashReportsSize > 0)\n    {\n        if (low_free_space(g_settings_nMaxCrashReportsSize, g_settings_dump_location))\n            exit(1);\n    }\n\n    /* Create temp directory with the problem data.\n     * This directory is renamed to final directory name after\n     * all files have been stored into it.\n     */\n\n    gchar *dir_basename = g_hash_table_lookup(problem_info, \"basename\");\n    if (!dir_basename)\n        dir_basename = g_hash_table_lookup(problem_info, FILENAME_TYPE);\n\n    char *path = xasprintf(\"%s/%s-%s-%u.new\",\n                           g_settings_dump_location,\n                           dir_basename,\n                           iso_date_string(NULL),\n                           pid);\n\n    /* This item is useless, don't save it */\n    g_hash_table_remove(problem_info, \"basename\");\n\n    /* No need to check the path length, as all variables used are limited,\n     * and dd_create() fails if the path is too long.\n     */\n    struct dump_dir *dd = dd_create(path, g_settings_privatereports ? 0 : client_uid, DEFAULT_DUMP_DIR_MODE);\n    if (!dd)\n    {\n        error_msg_and_die(\"Error creating problem directory '%s'\", path);\n    }\n\n    dd_create_basic_files(dd, client_uid, NULL);\n    dd_save_text(dd, FILENAME_ABRT_VERSION, VERSION);\n\n    gpointer gpkey = g_hash_table_lookup(problem_info, FILENAME_CMDLINE);\n    if (!gpkey)\n    {\n        /* Obtain and save the command line. */\n        char *cmdline = get_cmdline(pid);\n        if (cmdline)\n        {\n            dd_save_text(dd, FILENAME_CMDLINE, cmdline);\n            free(cmdline);\n        }\n    }\n\n    /* Store id of the user whose application crashed. */\n    char uid_str[sizeof(long) * 3 + 2];\n    sprintf(uid_str, \"%lu\", (long)client_uid);\n    dd_save_text(dd, FILENAME_UID, uid_str);\n\n    GHashTableIter iter;\n    gpointer gpvalue;\n    g_hash_table_iter_init(&iter, problem_info);\n    while (g_hash_table_iter_next(&iter, &gpkey, &gpvalue))\n    {\n        dd_save_text(dd, (gchar *) gpkey, (gchar *) gpvalue);\n    }\n\n    dd_close(dd);\n\n    /* Not needing it anymore */\n    g_hash_table_destroy(problem_info);\n\n    /* Move the completely created problem directory\n     * to final directory.\n     */\n    char *newpath = xstrndup(path, strlen(path) - strlen(\".new\"));\n    if (rename(path, newpath) == 0)\n        strcpy(path, newpath);\n    free(newpath);\n\n    log_notice(\"Saved problem directory of pid %u to '%s'\", pid, path);\n\n    /* We let the peer know that problem dir was created successfully\n     * _before_ we run potentially long-running post-create.\n     */\n    printf(\"HTTP/1.1 201 Created\\r\\n\\r\\n\");\n    fflush(NULL);\n    close(STDOUT_FILENO);\n    xdup2(STDERR_FILENO, STDOUT_FILENO); /* paranoia: don't leave stdout fd closed */\n\n    /* Trim old problem directories if necessary */\n    if (g_settings_nMaxCrashReportsSize > 0)\n    {\n        trim_problem_dirs(g_settings_dump_location, g_settings_nMaxCrashReportsSize * (double)(1024*1024), path);\n    }\n\n    run_post_create(path);\n\n    /* free(path); */\n    exit(0);\n}\n\nstatic gboolean key_value_ok(gchar *key, gchar *value)\n{\n    char *i;\n\n    /* check key, it has to be valid filename and will end up in the\n     * bugzilla */\n    for (i = key; *i != 0; i++)\n    {\n        if (!isalpha(*i) && (*i != '-') && (*i != '_') && (*i != ' '))\n            return FALSE;\n    }\n\n    /* check value of 'basename', it has to be valid non-hidden directory\n     * name */\n    if (strcmp(key, \"basename\") == 0\n     || strcmp(key, FILENAME_TYPE) == 0\n    )\n    {\n        if (!str_is_correct_filename(value))\n        {\n            error_msg(\"Value of '%s' ('%s') is not a valid directory name\",\n                      key, value);\n            return FALSE;\n        }\n    }\n\n    return TRUE;\n}\n\n/* Handles a message received from client over socket. */\nstatic void process_message(GHashTable *problem_info, char *message)\n{\n    gchar *key, *value;\n\n    value = strchr(message, '=');\n    if (value)\n    {\n        key = g_ascii_strdown(message, value - message); /* result is malloced */\n//TODO: is it ok? it uses g_malloc, not malloc!\n\n        value++;\n        if (key_value_ok(key, value))\n        {\n            if (strcmp(key, FILENAME_UID) == 0)\n            {\n                error_msg(\"Ignoring value of %s, will be determined later\",\n                          FILENAME_UID);\n            }\n            else\n            {\n                g_hash_table_insert(problem_info, key, xstrdup(value));\n                /* Compat, delete when FILENAME_ANALYZER is replaced by FILENAME_TYPE: */\n                if (strcmp(key, FILENAME_TYPE) == 0)\n                    g_hash_table_insert(problem_info, xstrdup(FILENAME_ANALYZER), xstrdup(value));\n                /* Prevent freeing key later: */\n                key = NULL;\n            }\n        }\n        else\n        {\n            /* should use error_msg_and_die() here? */\n            error_msg(\"Invalid key or value format: %s\", message);\n        }\n        free(key);\n    }\n    else\n    {\n        /* should use error_msg_and_die() here? */\n        error_msg(\"Invalid message format: '%s'\", message);\n    }\n}\n\nstatic void die_if_data_is_missing(GHashTable *problem_info)\n{\n    gboolean missing_data = FALSE;\n    gchar **pstring;\n    static const gchar *const needed[] = {\n        FILENAME_TYPE,\n        FILENAME_REASON,\n        /* FILENAME_BACKTRACE, - ECC errors have no such elements */\n        /* FILENAME_EXECUTABLE, */\n        NULL\n    };\n\n    for (pstring = (gchar**) needed; *pstring; pstring++)\n    {\n        if (!g_hash_table_lookup(problem_info, *pstring))\n        {\n            error_msg(\"Element '%s' is missing\", *pstring);\n            missing_data = TRUE;\n        }\n    }\n\n    if (missing_data)\n        error_msg_and_die(\"Some data is missing, aborting\");\n}\n\n/*\n * Takes hash table, looks for key FILENAME_PID and tries to convert its value\n * to int.\n */\nunsigned convert_pid(GHashTable *problem_info)\n{\n    long ret;\n    gchar *pid_str = (gchar *) g_hash_table_lookup(problem_info, FILENAME_PID);\n    char *err_pos;\n\n    if (!pid_str)\n        error_msg_and_die(\"PID data is missing, aborting\");\n\n    errno = 0;\n    ret = strtol(pid_str, &err_pos, 10);\n    if (errno || pid_str == err_pos || *err_pos != '\\0'\n        || ret > UINT_MAX || ret < 1)\n        error_msg_and_die(\"Malformed or out-of-range PID number: '%s'\", pid_str);\n\n    return (unsigned) ret;\n}\n\nstatic int perform_http_xact(void)\n{\n    /* use free instead of g_free so that we can use xstr* functions from\n     * libreport/lib/xfuncs.c\n     */\n    GHashTable *problem_info = g_hash_table_new_full(g_str_hash, g_str_equal,\n                                     free, free);\n    /* Read header */\n    char *body_start = NULL;\n    char *messagebuf_data = NULL;\n    unsigned messagebuf_len = 0;\n    /* Loop until EOF/error/timeout/end_of_header */\n    while (1)\n    {\n        messagebuf_data = xrealloc(messagebuf_data, messagebuf_len + INPUT_BUFFER_SIZE);\n        char *p = messagebuf_data + messagebuf_len;\n        int rd = read(STDIN_FILENO, p, INPUT_BUFFER_SIZE);\n        if (rd < 0)\n        {\n            if (errno == EINTR) /* SIGALRM? */\n                error_msg_and_die(\"Timed out\");\n            perror_msg_and_die(\"read\");\n        }\n        if (rd == 0)\n            break;\n\n        log_debug(\"Received %u bytes of data\", rd);\n        messagebuf_len += rd;\n        total_bytes_read += rd;\n        if (total_bytes_read > MAX_MESSAGE_SIZE)\n            error_msg_and_die(\"Message is too long, aborting\");\n\n        /* Check whether we see end of header */\n        /* Note: we support both [\\r]\\n\\r\\n and \\n\\n */\n        char *past_end = messagebuf_data + messagebuf_len;\n        if (p > messagebuf_data+1)\n            p -= 2; /* start search from two last bytes in last read - they might be '\\n\\r' */\n        while (p < past_end)\n        {\n            p = memchr(p, '\\n', past_end - p);\n            if (!p)\n                break;\n            p++;\n            if (p >= past_end)\n                break;\n            if (*p == '\\n'\n             || (*p == '\\r' && p+1 < past_end && p[1] == '\\n')\n            ) {\n                body_start = p + 1 + (*p == '\\r');\n                *p = '\\0';\n                goto found_end_of_header;\n            }\n        }\n    } /* while (read) */\n found_end_of_header: ;\n    log_debug(\"Request: %s\", messagebuf_data);\n\n    /* Sanitize and analyze header.\n     * Header now is in messagebuf_data, NUL terminated string,\n     * with last empty line deleted (by placement of NUL).\n     * \\r\\n are not (yet) converted to \\n, multi-line headers also\n     * not converted.\n     */\n    /* First line must be \"op<space>[http://host]/path<space>HTTP/n.n\".\n     * <space> is exactly one space char.\n     */\n    if (prefixcmp(messagebuf_data, \"DELETE \") == 0)\n    {\n        messagebuf_data += strlen(\"DELETE \");\n        char *space = strchr(messagebuf_data, ' ');\n        if (!space || prefixcmp(space+1, \"HTTP/\") != 0)\n            return 400; /* Bad Request */\n        *space = '\\0';\n        //decode_url(messagebuf_data); %20 => ' '\n        alarm(0);\n        return delete_path(messagebuf_data);\n    }\n\n    /* We erroneously used \"PUT /\" to create new problems.\n     * POST is the correct request in this case:\n     * \"PUT /\" implies creation or replace of resource named \"/\"!\n     * Delete PUT in 2014.\n     */\n    if (prefixcmp(messagebuf_data, \"PUT \") != 0\n     && prefixcmp(messagebuf_data, \"POST \") != 0\n    ) {\n        return 400; /* Bad Request */\n    }\n\n    enum {\n        CREATION_NOTIFICATION,\n        CREATION_REQUEST,\n    };\n    int url_type;\n    char *url = skip_non_whitespace(messagebuf_data) + 1; /* skip \"POST \" */\n    if (prefixcmp(url, \"/creation_notification \") == 0)\n        url_type = CREATION_NOTIFICATION;\n    else if (prefixcmp(url, \"/ \") == 0)\n        url_type = CREATION_REQUEST;\n    else\n        return 400; /* Bad Request */\n\n    /* Read body */\n    if (!body_start)\n    {\n        log_warning(\"Premature EOF detected, exiting\");\n        return 400; /* Bad Request */\n    }\n\n    messagebuf_len -= (body_start - messagebuf_data);\n    memmove(messagebuf_data, body_start, messagebuf_len);\n    log_debug(\"Body so far: %u bytes, '%s'\", messagebuf_len, messagebuf_data);\n\n    /* Loop until EOF/error/timeout */\n    while (1)\n    {\n        if (url_type == CREATION_REQUEST)\n        {\n            while (1)\n            {\n                unsigned len = strnlen(messagebuf_data, messagebuf_len);\n                if (len >= messagebuf_len)\n                    break;\n                /* messagebuf has at least one NUL - process the line */\n                process_message(problem_info, messagebuf_data);\n                messagebuf_len -= (len + 1);\n                memmove(messagebuf_data, messagebuf_data + len + 1, messagebuf_len);\n            }\n        }\n\n        messagebuf_data = xrealloc(messagebuf_data, messagebuf_len + INPUT_BUFFER_SIZE + 1);\n        int rd = read(STDIN_FILENO, messagebuf_data + messagebuf_len, INPUT_BUFFER_SIZE);\n        if (rd < 0)\n        {\n            if (errno == EINTR) /* SIGALRM? */\n                error_msg_and_die(\"Timed out\");\n            perror_msg_and_die(\"read\");\n        }\n        if (rd == 0)\n            break;\n\n        log_debug(\"Received %u bytes of data\", rd);\n        messagebuf_len += rd;\n        total_bytes_read += rd;\n        if (total_bytes_read > MAX_MESSAGE_SIZE)\n            error_msg_and_die(\"Message is too long, aborting\");\n    }\n\n    /* Body received, EOF was seen. Don't let alarm to interrupt after this. */\n    alarm(0);\n\n    if (url_type == CREATION_NOTIFICATION)\n    {\n        messagebuf_data[messagebuf_len] = '\\0';\n        return run_post_create(messagebuf_data);\n    }\n\n    /* Save problem dir */\n    int ret = 0;\n    unsigned pid = convert_pid(problem_info);\n    die_if_data_is_missing(problem_info);\n\n    char *executable = g_hash_table_lookup(problem_info, FILENAME_EXECUTABLE);\n    if (executable)\n    {\n        char *last_file = concat_path_file(g_settings_dump_location, \"last-via-server\");\n        int repeating_crash = check_recent_crash_file(last_file, executable);\n        free(last_file);\n        if (repeating_crash) /* Only pretend that we saved it */\n            goto out; /* ret is 0: \"success\" */\n    }\n\n#if 0\n//TODO:\n    /* At least it should generate local problem identifier UUID */\n    problem_data_add_basics(problem_info);\n//...the problem being that problem_info here is not a problem_data_t!\n#endif\n\n    create_problem_dir(problem_info, pid);\n    /* does not return */\n\n out:\n    g_hash_table_destroy(problem_info);\n    return ret; /* Used as HTTP response code */\n}\n\nstatic void dummy_handler(int sig_unused) {}\n\nint main(int argc, char **argv)\n{\n    /* I18n */\n    setlocale(LC_ALL, \"\");\n#if ENABLE_NLS\n    bindtextdomain(PACKAGE, LOCALEDIR);\n    textdomain(PACKAGE);\n#endif\n\n    abrt_init(argv);\n\n    /* Can't keep these strings/structs static: _() doesn't support that */\n    const char *program_usage_string = _(\n        \"& [options]\"\n    );\n    enum {\n        OPT_v = 1 << 0,\n        OPT_u = 1 << 1,\n        OPT_s = 1 << 2,\n        OPT_p = 1 << 3,\n    };\n    /* Keep enum above and order of options below in sync! */\n    struct options program_options[] = {\n        OPT__VERBOSE(&g_verbose),\n        OPT_INTEGER('u', NULL, &client_uid, _(\"Use NUM as client uid\")),\n        OPT_BOOL(   's', NULL, NULL       , _(\"Log to syslog\")),\n        OPT_BOOL(   'p', NULL, NULL       , _(\"Add program names to log\")),\n        OPT_END()\n    };\n    unsigned opts = parse_opts(argc, argv, program_options, program_usage_string);\n\n    export_abrt_envvars(opts & OPT_p);\n\n    msg_prefix = xasprintf(\"%s[%u]\", g_progname, getpid());\n    if (opts & OPT_s)\n    {\n        logmode = LOGMODE_JOURNAL;\n    }\n\n    /* Set up timeout handling */\n    /* Part 1 - need this to make SIGALRM interrupt syscalls\n     * (as opposed to restarting them): I want read syscall to be interrupted\n     */\n    struct sigaction sa;\n    /* sa.sa_flags.SA_RESTART bit is clear: make signal interrupt syscalls */\n    memset(&sa, 0, sizeof(sa));\n    sa.sa_handler = dummy_handler; /* pity, SIG_DFL won't do */\n    sigaction(SIGALRM, &sa, NULL);\n    /* Part 2 - set the timeout per se */\n    alarm(TIMEOUT);\n\n    if (client_uid == (uid_t)-1L)\n    {\n        /* Get uid of the connected client */\n        struct ucred cr;\n        socklen_t crlen = sizeof(cr);\n        if (0 != getsockopt(STDIN_FILENO, SOL_SOCKET, SO_PEERCRED, &cr, &crlen))\n            perror_msg_and_die(\"getsockopt(SO_PEERCRED)\");\n        if (crlen != sizeof(cr))\n            error_msg_and_die(\"%s: bad crlen %d\", \"getsockopt(SO_PEERCRED)\", (int)crlen);\n        client_uid = cr.uid;\n    }\n\n    load_abrt_conf();\n\n    int r = perform_http_xact();\n    if (r == 0)\n        r = 200;\n\n    free_abrt_conf_data();\n\n    printf(\"HTTP/1.1 %u \\r\\n\\r\\n\", r);\n\n    return (r >= 400); /* Error if 400+ */\n}\n\n\n\n\n\n\n#if 0\n\n// TODO: example of SSLed connection\n\n#include <openssl/ssl.h>\n#include <openssl/err.h>\n    if (flags & OPT_SSL) {\n        /* load key and cert files */\n        SSL_CTX *ctx;\n        SSL *ssl;\n\n        ctx = init_ssl_context();\n        if (SSL_CTX_use_certificate_file(ctx, cert_path, SSL_FILETYPE_PEM) <= 0\n         || SSL_CTX_use_PrivateKey_file(ctx, key_path, SSL_FILETYPE_PEM) <= 0\n        ) {\n            ERR_print_errors_fp(stderr);\n            error_msg_and_die(\"SSL certificates err\\n\");\n        }\n        if (!SSL_CTX_check_private_key(ctx)) {\n            error_msg_and_die(\"Private key does not match public key\\n\");\n        }\n        (void)SSL_CTX_set_mode(ctx, SSL_MODE_AUTO_RETRY);\n\n        //TODO more errors?\n        ssl = SSL_new(ctx);\n        SSL_set_fd(ssl, sockfd_in);\n        //SSL_set_accept_state(ssl);\n        if (SSL_accept(ssl) == 1) {\n            //while whatever serve\n            while (serve(ssl, flags))\n                continue;\n            //TODO errors\n            SSL_shutdown(ssl);\n        }\n        SSL_free(ssl);\n        SSL_CTX_free(ctx);\n    } else {\n        while (serve(&sockfd_in, flags))\n            continue;\n    }\n\n\n        err = (flags & OPT_SSL) ? SSL_read(sock, buffer, READ_BUF-1):\n                                  read(*(int*)sock, buffer, READ_BUF-1);\n\n        if ( err < 0 ) {\n            //TODO handle errno ||  SSL_get_error(ssl,err);\n            break;\n        }\n        if ( err == 0 ) break;\n\n        if (!head) {\n            buffer[err] = '\\0';\n            clean[i%2] = delete_cr(buffer);\n            cut = g_strstr_len(buffer, -1, \"\\n\\n\");\n            if ( cut == NULL ) {\n                g_string_append(headers, buffer);\n            } else {\n                g_string_append_len(headers, buffer, cut-buffer);\n            }\n        }\n\n        /* end of header section? */\n        if ( !head && ( cut != NULL || (clean[(i+1)%2] && buffer[0]=='\\n') ) ) {\n            parse_head(&request, headers);\n            head = TRUE;\n            c_len = has_body(&request);\n\n            if ( c_len ) {\n                //if we want to read body some day - this will be the right place to begin\n                //malloc body append rest of the (fixed) buffer at the beginning of a body\n                //if clean buffer[1];\n            } else {\n                break;\n            }\n            break; //because we don't support body yet\n        } else if ( head == TRUE ) {\n            /* body-reading stuff\n             * read body, check content-len\n             * save body to request\n             */\n            break;\n        } else {\n            // count header size\n            len += err;\n            if ( len > READ_BUF-1 ) {\n                //TODO header is too long\n                break;\n            }\n        }\n\n        i++;\n    }\n\n    g_string_free(headers, true); //because we allocated it\n\n    rt = generate_response(&request, &response);\n\n    /* write headers */\n    if ( flags & OPT_SSL ) {\n        //TODO err\n        err = SSL_write(sock, response.response_line, strlen(response.response_line));\n        err = SSL_write(sock, response.head->str , strlen(response.head->str));\n        err = SSL_write(sock, \"\\r\\n\", 2);\n    } else {\n        //TODO err\n        err = write(*(int*)sock, response.response_line, strlen(response.response_line));\n        err = write(*(int*)sock, response.head->str , strlen(response.head->str));\n        err = write(*(int*)sock, \"\\r\\n\", 2);\n    }\n#endif\n"], "fixing_code": ["/*\n  Copyright (C) 2010  ABRT team\n\n  This program is free software; you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation; either version 2 of the License, or\n  (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License along\n  with this program; if not, write to the Free Software Foundation, Inc.,\n  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n*/\n#include \"problem_api.h\"\n#include \"libabrt.h\"\n\n/* Maximal length of backtrace. */\n#define MAX_BACKTRACE_SIZE (1024*1024)\n/* Amount of data received from one client for a message before reporting error. */\n#define MAX_MESSAGE_SIZE (4*MAX_BACKTRACE_SIZE)\n/* Maximal number of characters read from socket at once. */\n#define INPUT_BUFFER_SIZE (8*1024)\n/* We exit after this many seconds */\n#define TIMEOUT 10\n\n\n/*\nUnix socket in ABRT daemon for creating new dump directories.\n\nWhy to use socket for creating dump dirs? Security. When a Python\nscript throws unexpected exception, ABRT handler catches it, running\nas a part of that broken Python application. The application is running\nwith certain SELinux privileges, for example it can not execute other\nprograms, or to create files in /var/cache or anything else required\nto properly fill a problem directory. Adding these privileges to every\napplication would weaken the security.\nThe most suitable solution is for the Python application\nto open a socket where ABRT daemon is listening, write all relevant\ndata to that socket, and close it. ABRT daemon handles the rest.\n\n** Protocol\n\nInitializing new dump:\nopen /var/run/abrt.socket\n\nProviding dump data (hook writes to the socket):\nMANDATORY ITEMS:\n-> \"PID=\"\n   number 0 - PID_MAX (/proc/sys/kernel/pid_max)\n   \\0\n-> \"EXECUTABLE=\"\n   string\n   \\0\n-> \"BACKTRACE=\"\n   string\n   \\0\n-> \"ANALYZER=\"\n   string\n   \\0\n-> \"BASENAME=\"\n   string (no slashes)\n   \\0\n-> \"REASON=\"\n   string\n   \\0\n\nYou can send more messages using the same KEY=value format.\n*/\n\nstatic unsigned total_bytes_read = 0;\n\nstatic uid_t client_uid = (uid_t)-1L;\n\n\n/* Remove dump dir */\nstatic int delete_path(const char *dump_dir_name)\n{\n    /* If doesn't start with \"g_settings_dump_location/\"... */\n    if (!dir_is_in_dump_location(dump_dir_name))\n    {\n        /* Then refuse to operate on it (someone is attacking us??) */\n        error_msg(\"Bad problem directory name '%s', should start with: '%s'\", dump_dir_name, g_settings_dump_location);\n        return 400; /* Bad Request */\n    }\n    if (!dir_has_correct_permissions(dump_dir_name))\n    {\n        error_msg(\"Problem directory '%s' isn't owned by root:abrt or others are not restricted from access\", dump_dir_name);\n        return 400; /*  */\n    }\n\n    int dir_fd = dd_openfd(dump_dir_name);\n    if (dir_fd < 0)\n    {\n        perror_msg(\"Can't open problem directory '%s'\", dump_dir_name);\n        return 400;\n    }\n    if (!fdump_dir_accessible_by_uid(dir_fd, client_uid))\n    {\n        close(dir_fd);\n        if (errno == ENOTDIR)\n        {\n            error_msg(\"Path '%s' isn't problem directory\", dump_dir_name);\n            return 404; /* Not Found */\n        }\n        error_msg(\"Problem directory '%s' can't be accessed by user with uid %ld\", dump_dir_name, (long)client_uid);\n        return 403; /* Forbidden */\n    }\n\n    struct dump_dir *dd = dd_fdopendir(dir_fd, dump_dir_name, /*flags:*/ 0);\n    if (dd)\n    {\n        if (dd_delete(dd) != 0)\n        {\n            error_msg(\"Failed to delete problem directory '%s'\", dump_dir_name);\n            dd_close(dd);\n            return 400;\n        }\n    }\n\n    return 0; /* success */\n}\n\nstatic pid_t spawn_event_handler_child(const char *dump_dir_name, const char *event_name, int *fdp)\n{\n    char *args[7];\n    args[0] = (char *) LIBEXEC_DIR\"/abrt-handle-event\";\n    /* Do not forward ASK_* messages to parent*/\n    args[1] = (char *) \"-i\";\n    args[2] = (char *) \"-e\";\n    args[3] = (char *) event_name;\n    args[4] = (char *) \"--\";\n    args[5] = (char *) dump_dir_name;\n    args[6] = NULL;\n\n    int pipeout[2];\n    int flags = EXECFLG_INPUT_NUL | EXECFLG_OUTPUT | EXECFLG_QUIET | EXECFLG_ERR2OUT;\n    VERB1 flags &= ~EXECFLG_QUIET;\n\n    char *env_vec[2];\n    /* Intercept ASK_* messages in Client API -> don't wait for user response */\n    env_vec[0] = xstrdup(\"REPORT_CLIENT_NONINTERACTIVE=1\");\n    env_vec[1] = NULL;\n\n    pid_t child = fork_execv_on_steroids(flags, args, pipeout,\n                                         env_vec, /*dir:*/ NULL,\n                                         /*uid(unused):*/ 0);\n    if (fdp)\n        *fdp = pipeout[0];\n    return child;\n}\n\nstatic int run_post_create(const char *dirname)\n{\n    /* If doesn't start with \"g_settings_dump_location/\"... */\n    if (!dir_is_in_dump_location(dirname))\n    {\n        /* Then refuse to operate on it (someone is attacking us??) */\n        error_msg(\"Bad problem directory name '%s', should start with: '%s'\", dirname, g_settings_dump_location);\n        return 400; /* Bad Request */\n    }\n    if (!dir_has_correct_permissions(dirname))\n    {\n        error_msg(\"Problem directory '%s' isn't owned by root:abrt or others are not restricted from access\", dirname);\n        return 400; /*  */\n    }\n    if (g_settings_privatereports)\n    {\n        struct dump_dir *dd = dd_opendir(dirname, DD_OPEN_READONLY);\n        const bool complete = dd && problem_dump_dir_is_complete(dd);\n        dd_close(dd);\n        if (complete)\n        {\n            error_msg(\"Problem directory '%s' has already been processed\", dirname);\n            return 403;\n        }\n    }\n\n    int child_stdout_fd;\n    int child_pid = spawn_event_handler_child(dirname, \"post-create\", &child_stdout_fd);\n\n    char *dup_of_dir = NULL;\n    struct strbuf *cmd_output = strbuf_new();\n\n    bool child_is_post_create = 1; /* else it is a notify child */\n\n read_child_output:\n    //log(\"Reading from event fd %d\", child_stdout_fd);\n\n    /* Read streamed data and split lines */\n    for (;;)\n    {\n        char buf[250]; /* usually we get one line, no need to have big buf */\n        errno = 0;\n        int r = safe_read(child_stdout_fd, buf, sizeof(buf) - 1);\n        if (r <= 0)\n            break;\n        buf[r] = '\\0';\n\n        /* split lines in the current buffer */\n        char *raw = buf;\n        char *newline;\n        while ((newline = strchr(raw, '\\n')) != NULL)\n        {\n            *newline = '\\0';\n            strbuf_append_str(cmd_output, raw);\n            char *msg = cmd_output->buf;\n\n            /* Hmm, DUP_OF_DIR: ends up in syslog. move log() into 'else'? */\n            log(\"%s\", msg);\n\n            if (child_is_post_create\n             && prefixcmp(msg, \"DUP_OF_DIR: \") == 0\n            ) {\n                free(dup_of_dir);\n                dup_of_dir = xstrdup(msg + strlen(\"DUP_OF_DIR: \"));\n            }\n\n            strbuf_clear(cmd_output);\n            /* jump to next line */\n            raw = newline + 1;\n        }\n\n        /* beginning of next line. the line continues by next read */\n        strbuf_append_str(cmd_output, raw);\n    }\n\n    /* EOF/error */\n\n    /* Wait for child to actually exit, collect status */\n    int status = 0;\n    if (safe_waitpid(child_pid, &status, 0) <= 0)\n    /* should not happen */\n        perror_msg(\"waitpid(%d)\", child_pid);\n\n    /* If it was a \"notify[-dup]\" event, then we're done */\n    if (!child_is_post_create)\n        goto ret;\n\n    /* exit 0 means \"this is a good, non-dup dir\" */\n    /* exit with 1 + \"DUP_OF_DIR: dir\" string => dup */\n    if (status != 0)\n    {\n        if (WIFSIGNALED(status))\n        {\n            log(\"'post-create' on '%s' killed by signal %d\",\n                            dirname, WTERMSIG(status));\n            goto delete_bad_dir;\n        }\n        /* else: it is WIFEXITED(status) */\n        if (!dup_of_dir)\n        {\n            log(\"'post-create' on '%s' exited with %d\",\n                            dirname, WEXITSTATUS(status));\n            goto delete_bad_dir;\n        }\n    }\n\n    const char *work_dir = (dup_of_dir ? dup_of_dir : dirname);\n\n    /* Load problem_data (from the *first dir* if this one is a dup) */\n    struct dump_dir *dd = dd_opendir(work_dir, /*flags:*/ 0);\n    if (!dd)\n        /* dd_opendir already emitted error msg */\n        goto delete_bad_dir;\n\n    /* Update count */\n    char *count_str = dd_load_text_ext(dd, FILENAME_COUNT, DD_FAIL_QUIETLY_ENOENT);\n    unsigned long count = strtoul(count_str, NULL, 10);\n\n    /* Don't increase crash count if we are working with newly uploaded\n     * directory (remote crash) which already has its crash count set.\n     */\n    if ((status != 0 && dup_of_dir) || count == 0)\n    {\n        count++;\n        char new_count_str[sizeof(long)*3 + 2];\n        sprintf(new_count_str, \"%lu\", count);\n        dd_save_text(dd, FILENAME_COUNT, new_count_str);\n\n        /* This condition can be simplified to either\n         * (status * != 0 && * dup_of_dir) or (count == 1). But the\n         * chosen form is much more reliable and safe. We must not call\n         * dd_opendir() to locked dd otherwise we go into a deadlock.\n         */\n        if (strcmp(dd->dd_dirname, dirname) != 0)\n        {\n            /* Update the last occurrence file by the time file of the new problem */\n            struct dump_dir *new_dd = dd_opendir(dirname, DD_OPEN_READONLY);\n            char *last_ocr = NULL;\n            if (new_dd)\n            {\n                /* TIME must exists in a valid dump directory but we don't want to die\n                 * due to broken duplicated dump directory */\n                last_ocr = dd_load_text_ext(new_dd, FILENAME_TIME,\n                            DD_LOAD_TEXT_RETURN_NULL_ON_FAILURE | DD_FAIL_QUIETLY_ENOENT);\n                dd_close(new_dd);\n            }\n            else\n            {   /* dd_opendir() already produced a message with good information about failure */\n                error_msg(\"Can't read the last occurrence file from the new dump directory.\");\n            }\n\n            if (!last_ocr)\n            {   /* the new dump directory may lie in the dump location for some time */\n                log(\"Using current time for the last occurrence file which may be incorrect.\");\n                time_t t = time(NULL);\n                last_ocr = xasprintf(\"%lu\", (long)t);\n            }\n\n            dd_save_text(dd, FILENAME_LAST_OCCURRENCE, last_ocr);\n\n            free(last_ocr);\n        }\n    }\n\n    /* Reset mode/uig/gid to correct values for all files created by event run */\n    dd_sanitize_mode_and_owner(dd);\n\n    dd_close(dd);\n\n    if (!dup_of_dir)\n        log_notice(\"New problem directory %s, processing\", work_dir);\n    else\n    {\n        log_warning(\"Deleting problem directory %s (dup of %s)\",\n                    strrchr(dirname, '/') + 1,\n                    strrchr(dup_of_dir, '/') + 1);\n        delete_dump_dir(dirname);\n    }\n\n    /* Run \"notify[-dup]\" event */\n    int fd;\n    child_pid = spawn_event_handler_child(\n                work_dir,\n                (dup_of_dir ? \"notify-dup\" : \"notify\"),\n                &fd\n    );\n    //log(\"Started notify, fd %d -> %d\", fd, child_stdout_fd);\n    xmove_fd(fd, child_stdout_fd);\n    child_is_post_create = 0;\n    strbuf_clear(cmd_output);\n    free(dup_of_dir);\n    dup_of_dir = NULL;\n    goto read_child_output;\n\n delete_bad_dir:\n    log_warning(\"Deleting problem directory '%s'\", dirname);\n    delete_dump_dir(dirname);\n\n ret:\n    strbuf_free(cmd_output);\n    free(dup_of_dir);\n    close(child_stdout_fd);\n    return 0;\n}\n\n/* Create a new problem directory from client session.\n * Caller must ensure that all fields in struct client\n * are properly filled.\n */\nstatic int create_problem_dir(GHashTable *problem_info, unsigned pid)\n{\n    /* Exit if free space is less than 1/4 of MaxCrashReportsSize */\n    if (g_settings_nMaxCrashReportsSize > 0)\n    {\n        if (low_free_space(g_settings_nMaxCrashReportsSize, g_settings_dump_location))\n            exit(1);\n    }\n\n    /* Create temp directory with the problem data.\n     * This directory is renamed to final directory name after\n     * all files have been stored into it.\n     */\n\n    gchar *dir_basename = g_hash_table_lookup(problem_info, \"basename\");\n    if (!dir_basename)\n        dir_basename = g_hash_table_lookup(problem_info, FILENAME_TYPE);\n\n    char *path = xasprintf(\"%s/%s-%s-%u.new\",\n                           g_settings_dump_location,\n                           dir_basename,\n                           iso_date_string(NULL),\n                           pid);\n\n    /* This item is useless, don't save it */\n    g_hash_table_remove(problem_info, \"basename\");\n\n    /* No need to check the path length, as all variables used are limited,\n     * and dd_create() fails if the path is too long.\n     */\n    struct dump_dir *dd = dd_create(path, g_settings_privatereports ? 0 : client_uid, DEFAULT_DUMP_DIR_MODE);\n    if (!dd)\n    {\n        error_msg_and_die(\"Error creating problem directory '%s'\", path);\n    }\n\n    dd_create_basic_files(dd, client_uid, NULL);\n    dd_save_text(dd, FILENAME_ABRT_VERSION, VERSION);\n\n    gpointer gpkey = g_hash_table_lookup(problem_info, FILENAME_CMDLINE);\n    if (!gpkey)\n    {\n        /* Obtain and save the command line. */\n        char *cmdline = get_cmdline(pid);\n        if (cmdline)\n        {\n            dd_save_text(dd, FILENAME_CMDLINE, cmdline);\n            free(cmdline);\n        }\n    }\n\n    /* Store id of the user whose application crashed. */\n    char uid_str[sizeof(long) * 3 + 2];\n    sprintf(uid_str, \"%lu\", (long)client_uid);\n    dd_save_text(dd, FILENAME_UID, uid_str);\n\n    GHashTableIter iter;\n    gpointer gpvalue;\n    g_hash_table_iter_init(&iter, problem_info);\n    while (g_hash_table_iter_next(&iter, &gpkey, &gpvalue))\n    {\n        dd_save_text(dd, (gchar *) gpkey, (gchar *) gpvalue);\n    }\n\n    dd_close(dd);\n\n    /* Not needing it anymore */\n    g_hash_table_destroy(problem_info);\n\n    /* Move the completely created problem directory\n     * to final directory.\n     */\n    char *newpath = xstrndup(path, strlen(path) - strlen(\".new\"));\n    if (rename(path, newpath) == 0)\n        strcpy(path, newpath);\n    free(newpath);\n\n    log_notice(\"Saved problem directory of pid %u to '%s'\", pid, path);\n\n    /* We let the peer know that problem dir was created successfully\n     * _before_ we run potentially long-running post-create.\n     */\n    printf(\"HTTP/1.1 201 Created\\r\\n\\r\\n\");\n    fflush(NULL);\n    close(STDOUT_FILENO);\n    xdup2(STDERR_FILENO, STDOUT_FILENO); /* paranoia: don't leave stdout fd closed */\n\n    /* Trim old problem directories if necessary */\n    if (g_settings_nMaxCrashReportsSize > 0)\n    {\n        trim_problem_dirs(g_settings_dump_location, g_settings_nMaxCrashReportsSize * (double)(1024*1024), path);\n    }\n\n    run_post_create(path);\n\n    /* free(path); */\n    exit(0);\n}\n\nstatic gboolean key_value_ok(gchar *key, gchar *value)\n{\n    char *i;\n\n    /* check key, it has to be valid filename and will end up in the\n     * bugzilla */\n    for (i = key; *i != 0; i++)\n    {\n        if (!isalpha(*i) && (*i != '-') && (*i != '_') && (*i != ' '))\n            return FALSE;\n    }\n\n    /* check value of 'basename', it has to be valid non-hidden directory\n     * name */\n    if (strcmp(key, \"basename\") == 0\n     || strcmp(key, FILENAME_TYPE) == 0\n    )\n    {\n        if (!str_is_correct_filename(value))\n        {\n            error_msg(\"Value of '%s' ('%s') is not a valid directory name\",\n                      key, value);\n            return FALSE;\n        }\n    }\n\n    return TRUE;\n}\n\n/* Handles a message received from client over socket. */\nstatic void process_message(GHashTable *problem_info, char *message)\n{\n    gchar *key, *value;\n\n    value = strchr(message, '=');\n    if (value)\n    {\n        key = g_ascii_strdown(message, value - message); /* result is malloced */\n//TODO: is it ok? it uses g_malloc, not malloc!\n\n        value++;\n        if (key_value_ok(key, value))\n        {\n            if (strcmp(key, FILENAME_UID) == 0)\n            {\n                error_msg(\"Ignoring value of %s, will be determined later\",\n                          FILENAME_UID);\n            }\n            else\n            {\n                g_hash_table_insert(problem_info, key, xstrdup(value));\n                /* Compat, delete when FILENAME_ANALYZER is replaced by FILENAME_TYPE: */\n                if (strcmp(key, FILENAME_TYPE) == 0)\n                    g_hash_table_insert(problem_info, xstrdup(FILENAME_ANALYZER), xstrdup(value));\n                /* Prevent freeing key later: */\n                key = NULL;\n            }\n        }\n        else\n        {\n            /* should use error_msg_and_die() here? */\n            error_msg(\"Invalid key or value format: %s\", message);\n        }\n        free(key);\n    }\n    else\n    {\n        /* should use error_msg_and_die() here? */\n        error_msg(\"Invalid message format: '%s'\", message);\n    }\n}\n\nstatic void die_if_data_is_missing(GHashTable *problem_info)\n{\n    gboolean missing_data = FALSE;\n    gchar **pstring;\n    static const gchar *const needed[] = {\n        FILENAME_TYPE,\n        FILENAME_REASON,\n        /* FILENAME_BACKTRACE, - ECC errors have no such elements */\n        /* FILENAME_EXECUTABLE, */\n        NULL\n    };\n\n    for (pstring = (gchar**) needed; *pstring; pstring++)\n    {\n        if (!g_hash_table_lookup(problem_info, *pstring))\n        {\n            error_msg(\"Element '%s' is missing\", *pstring);\n            missing_data = TRUE;\n        }\n    }\n\n    if (missing_data)\n        error_msg_and_die(\"Some data is missing, aborting\");\n}\n\n/*\n * Takes hash table, looks for key FILENAME_PID and tries to convert its value\n * to int.\n */\nunsigned convert_pid(GHashTable *problem_info)\n{\n    long ret;\n    gchar *pid_str = (gchar *) g_hash_table_lookup(problem_info, FILENAME_PID);\n    char *err_pos;\n\n    if (!pid_str)\n        error_msg_and_die(\"PID data is missing, aborting\");\n\n    errno = 0;\n    ret = strtol(pid_str, &err_pos, 10);\n    if (errno || pid_str == err_pos || *err_pos != '\\0'\n        || ret > UINT_MAX || ret < 1)\n        error_msg_and_die(\"Malformed or out-of-range PID number: '%s'\", pid_str);\n\n    return (unsigned) ret;\n}\n\nstatic int perform_http_xact(void)\n{\n    /* use free instead of g_free so that we can use xstr* functions from\n     * libreport/lib/xfuncs.c\n     */\n    GHashTable *problem_info = g_hash_table_new_full(g_str_hash, g_str_equal,\n                                     free, free);\n    /* Read header */\n    char *body_start = NULL;\n    char *messagebuf_data = NULL;\n    unsigned messagebuf_len = 0;\n    /* Loop until EOF/error/timeout/end_of_header */\n    while (1)\n    {\n        messagebuf_data = xrealloc(messagebuf_data, messagebuf_len + INPUT_BUFFER_SIZE);\n        char *p = messagebuf_data + messagebuf_len;\n        int rd = read(STDIN_FILENO, p, INPUT_BUFFER_SIZE);\n        if (rd < 0)\n        {\n            if (errno == EINTR) /* SIGALRM? */\n                error_msg_and_die(\"Timed out\");\n            perror_msg_and_die(\"read\");\n        }\n        if (rd == 0)\n            break;\n\n        log_debug(\"Received %u bytes of data\", rd);\n        messagebuf_len += rd;\n        total_bytes_read += rd;\n        if (total_bytes_read > MAX_MESSAGE_SIZE)\n            error_msg_and_die(\"Message is too long, aborting\");\n\n        /* Check whether we see end of header */\n        /* Note: we support both [\\r]\\n\\r\\n and \\n\\n */\n        char *past_end = messagebuf_data + messagebuf_len;\n        if (p > messagebuf_data+1)\n            p -= 2; /* start search from two last bytes in last read - they might be '\\n\\r' */\n        while (p < past_end)\n        {\n            p = memchr(p, '\\n', past_end - p);\n            if (!p)\n                break;\n            p++;\n            if (p >= past_end)\n                break;\n            if (*p == '\\n'\n             || (*p == '\\r' && p+1 < past_end && p[1] == '\\n')\n            ) {\n                body_start = p + 1 + (*p == '\\r');\n                *p = '\\0';\n                goto found_end_of_header;\n            }\n        }\n    } /* while (read) */\n found_end_of_header: ;\n    log_debug(\"Request: %s\", messagebuf_data);\n\n    /* Sanitize and analyze header.\n     * Header now is in messagebuf_data, NUL terminated string,\n     * with last empty line deleted (by placement of NUL).\n     * \\r\\n are not (yet) converted to \\n, multi-line headers also\n     * not converted.\n     */\n    /* First line must be \"op<space>[http://host]/path<space>HTTP/n.n\".\n     * <space> is exactly one space char.\n     */\n    if (prefixcmp(messagebuf_data, \"DELETE \") == 0)\n    {\n        messagebuf_data += strlen(\"DELETE \");\n        char *space = strchr(messagebuf_data, ' ');\n        if (!space || prefixcmp(space+1, \"HTTP/\") != 0)\n            return 400; /* Bad Request */\n        *space = '\\0';\n        //decode_url(messagebuf_data); %20 => ' '\n        alarm(0);\n        return delete_path(messagebuf_data);\n    }\n\n    /* We erroneously used \"PUT /\" to create new problems.\n     * POST is the correct request in this case:\n     * \"PUT /\" implies creation or replace of resource named \"/\"!\n     * Delete PUT in 2014.\n     */\n    if (prefixcmp(messagebuf_data, \"PUT \") != 0\n     && prefixcmp(messagebuf_data, \"POST \") != 0\n    ) {\n        return 400; /* Bad Request */\n    }\n\n    enum {\n        CREATION_NOTIFICATION,\n        CREATION_REQUEST,\n    };\n    int url_type;\n    char *url = skip_non_whitespace(messagebuf_data) + 1; /* skip \"POST \" */\n    if (prefixcmp(url, \"/creation_notification \") == 0)\n        url_type = CREATION_NOTIFICATION;\n    else if (prefixcmp(url, \"/ \") == 0)\n        url_type = CREATION_REQUEST;\n    else\n        return 400; /* Bad Request */\n\n    /* Read body */\n    if (!body_start)\n    {\n        log_warning(\"Premature EOF detected, exiting\");\n        return 400; /* Bad Request */\n    }\n\n    messagebuf_len -= (body_start - messagebuf_data);\n    memmove(messagebuf_data, body_start, messagebuf_len);\n    log_debug(\"Body so far: %u bytes, '%s'\", messagebuf_len, messagebuf_data);\n\n    /* Loop until EOF/error/timeout */\n    while (1)\n    {\n        if (url_type == CREATION_REQUEST)\n        {\n            while (1)\n            {\n                unsigned len = strnlen(messagebuf_data, messagebuf_len);\n                if (len >= messagebuf_len)\n                    break;\n                /* messagebuf has at least one NUL - process the line */\n                process_message(problem_info, messagebuf_data);\n                messagebuf_len -= (len + 1);\n                memmove(messagebuf_data, messagebuf_data + len + 1, messagebuf_len);\n            }\n        }\n\n        messagebuf_data = xrealloc(messagebuf_data, messagebuf_len + INPUT_BUFFER_SIZE + 1);\n        int rd = read(STDIN_FILENO, messagebuf_data + messagebuf_len, INPUT_BUFFER_SIZE);\n        if (rd < 0)\n        {\n            if (errno == EINTR) /* SIGALRM? */\n                error_msg_and_die(\"Timed out\");\n            perror_msg_and_die(\"read\");\n        }\n        if (rd == 0)\n            break;\n\n        log_debug(\"Received %u bytes of data\", rd);\n        messagebuf_len += rd;\n        total_bytes_read += rd;\n        if (total_bytes_read > MAX_MESSAGE_SIZE)\n            error_msg_and_die(\"Message is too long, aborting\");\n    }\n\n    /* Body received, EOF was seen. Don't let alarm to interrupt after this. */\n    alarm(0);\n\n    int ret = 0;\n    if (url_type == CREATION_NOTIFICATION)\n    {\n        if (client_uid != 0)\n        {\n            error_msg(\"UID=%ld is not authorized to trigger post-create processing\", (long)client_uid);\n            ret = 403; /* Forbidden */\n            goto out;\n        }\n\n        messagebuf_data[messagebuf_len] = '\\0';\n        return run_post_create(messagebuf_data);\n    }\n\n    /* Save problem dir */\n    unsigned pid = convert_pid(problem_info);\n    die_if_data_is_missing(problem_info);\n\n    char *executable = g_hash_table_lookup(problem_info, FILENAME_EXECUTABLE);\n    if (executable)\n    {\n        char *last_file = concat_path_file(g_settings_dump_location, \"last-via-server\");\n        int repeating_crash = check_recent_crash_file(last_file, executable);\n        free(last_file);\n        if (repeating_crash) /* Only pretend that we saved it */\n            goto out; /* ret is 0: \"success\" */\n    }\n\n#if 0\n//TODO:\n    /* At least it should generate local problem identifier UUID */\n    problem_data_add_basics(problem_info);\n//...the problem being that problem_info here is not a problem_data_t!\n#endif\n\n    create_problem_dir(problem_info, pid);\n    /* does not return */\n\n out:\n    g_hash_table_destroy(problem_info);\n    return ret; /* Used as HTTP response code */\n}\n\nstatic void dummy_handler(int sig_unused) {}\n\nint main(int argc, char **argv)\n{\n    /* I18n */\n    setlocale(LC_ALL, \"\");\n#if ENABLE_NLS\n    bindtextdomain(PACKAGE, LOCALEDIR);\n    textdomain(PACKAGE);\n#endif\n\n    abrt_init(argv);\n\n    /* Can't keep these strings/structs static: _() doesn't support that */\n    const char *program_usage_string = _(\n        \"& [options]\"\n    );\n    enum {\n        OPT_v = 1 << 0,\n        OPT_u = 1 << 1,\n        OPT_s = 1 << 2,\n        OPT_p = 1 << 3,\n    };\n    /* Keep enum above and order of options below in sync! */\n    struct options program_options[] = {\n        OPT__VERBOSE(&g_verbose),\n        OPT_INTEGER('u', NULL, &client_uid, _(\"Use NUM as client uid\")),\n        OPT_BOOL(   's', NULL, NULL       , _(\"Log to syslog\")),\n        OPT_BOOL(   'p', NULL, NULL       , _(\"Add program names to log\")),\n        OPT_END()\n    };\n    unsigned opts = parse_opts(argc, argv, program_options, program_usage_string);\n\n    export_abrt_envvars(opts & OPT_p);\n\n    msg_prefix = xasprintf(\"%s[%u]\", g_progname, getpid());\n    if (opts & OPT_s)\n    {\n        logmode = LOGMODE_JOURNAL;\n    }\n\n    /* Set up timeout handling */\n    /* Part 1 - need this to make SIGALRM interrupt syscalls\n     * (as opposed to restarting them): I want read syscall to be interrupted\n     */\n    struct sigaction sa;\n    /* sa.sa_flags.SA_RESTART bit is clear: make signal interrupt syscalls */\n    memset(&sa, 0, sizeof(sa));\n    sa.sa_handler = dummy_handler; /* pity, SIG_DFL won't do */\n    sigaction(SIGALRM, &sa, NULL);\n    /* Part 2 - set the timeout per se */\n    alarm(TIMEOUT);\n\n    if (client_uid == (uid_t)-1L)\n    {\n        /* Get uid of the connected client */\n        struct ucred cr;\n        socklen_t crlen = sizeof(cr);\n        if (0 != getsockopt(STDIN_FILENO, SOL_SOCKET, SO_PEERCRED, &cr, &crlen))\n            perror_msg_and_die(\"getsockopt(SO_PEERCRED)\");\n        if (crlen != sizeof(cr))\n            error_msg_and_die(\"%s: bad crlen %d\", \"getsockopt(SO_PEERCRED)\", (int)crlen);\n        client_uid = cr.uid;\n    }\n\n    load_abrt_conf();\n\n    int r = perform_http_xact();\n    if (r == 0)\n        r = 200;\n\n    free_abrt_conf_data();\n\n    printf(\"HTTP/1.1 %u \\r\\n\\r\\n\", r);\n\n    return (r >= 400); /* Error if 400+ */\n}\n\n\n\n\n\n\n#if 0\n\n// TODO: example of SSLed connection\n\n#include <openssl/ssl.h>\n#include <openssl/err.h>\n    if (flags & OPT_SSL) {\n        /* load key and cert files */\n        SSL_CTX *ctx;\n        SSL *ssl;\n\n        ctx = init_ssl_context();\n        if (SSL_CTX_use_certificate_file(ctx, cert_path, SSL_FILETYPE_PEM) <= 0\n         || SSL_CTX_use_PrivateKey_file(ctx, key_path, SSL_FILETYPE_PEM) <= 0\n        ) {\n            ERR_print_errors_fp(stderr);\n            error_msg_and_die(\"SSL certificates err\\n\");\n        }\n        if (!SSL_CTX_check_private_key(ctx)) {\n            error_msg_and_die(\"Private key does not match public key\\n\");\n        }\n        (void)SSL_CTX_set_mode(ctx, SSL_MODE_AUTO_RETRY);\n\n        //TODO more errors?\n        ssl = SSL_new(ctx);\n        SSL_set_fd(ssl, sockfd_in);\n        //SSL_set_accept_state(ssl);\n        if (SSL_accept(ssl) == 1) {\n            //while whatever serve\n            while (serve(ssl, flags))\n                continue;\n            //TODO errors\n            SSL_shutdown(ssl);\n        }\n        SSL_free(ssl);\n        SSL_CTX_free(ctx);\n    } else {\n        while (serve(&sockfd_in, flags))\n            continue;\n    }\n\n\n        err = (flags & OPT_SSL) ? SSL_read(sock, buffer, READ_BUF-1):\n                                  read(*(int*)sock, buffer, READ_BUF-1);\n\n        if ( err < 0 ) {\n            //TODO handle errno ||  SSL_get_error(ssl,err);\n            break;\n        }\n        if ( err == 0 ) break;\n\n        if (!head) {\n            buffer[err] = '\\0';\n            clean[i%2] = delete_cr(buffer);\n            cut = g_strstr_len(buffer, -1, \"\\n\\n\");\n            if ( cut == NULL ) {\n                g_string_append(headers, buffer);\n            } else {\n                g_string_append_len(headers, buffer, cut-buffer);\n            }\n        }\n\n        /* end of header section? */\n        if ( !head && ( cut != NULL || (clean[(i+1)%2] && buffer[0]=='\\n') ) ) {\n            parse_head(&request, headers);\n            head = TRUE;\n            c_len = has_body(&request);\n\n            if ( c_len ) {\n                //if we want to read body some day - this will be the right place to begin\n                //malloc body append rest of the (fixed) buffer at the beginning of a body\n                //if clean buffer[1];\n            } else {\n                break;\n            }\n            break; //because we don't support body yet\n        } else if ( head == TRUE ) {\n            /* body-reading stuff\n             * read body, check content-len\n             * save body to request\n             */\n            break;\n        } else {\n            // count header size\n            len += err;\n            if ( len > READ_BUF-1 ) {\n                //TODO header is too long\n                break;\n            }\n        }\n\n        i++;\n    }\n\n    g_string_free(headers, true); //because we allocated it\n\n    rt = generate_response(&request, &response);\n\n    /* write headers */\n    if ( flags & OPT_SSL ) {\n        //TODO err\n        err = SSL_write(sock, response.response_line, strlen(response.response_line));\n        err = SSL_write(sock, response.head->str , strlen(response.head->str));\n        err = SSL_write(sock, \"\\r\\n\", 2);\n    } else {\n        //TODO err\n        err = write(*(int*)sock, response.response_line, strlen(response.response_line));\n        err = write(*(int*)sock, response.head->str , strlen(response.head->str));\n        err = write(*(int*)sock, \"\\r\\n\", 2);\n    }\n#endif\n"], "filenames": ["src/daemon/abrt-server.c"], "buggy_code_start_loc": [181], "buggy_code_end_loc": [752], "fixing_code_start_loc": [180], "fixing_code_end_loc": [748], "type": "CWE-59", "message": "The default event handling scripts in Automatic Bug Reporting Tool (ABRT) allow local users to gain privileges as demonstrated by a symlink attack on a var_log_messages file.", "other": {"cve": {"id": "CVE-2015-1869", "sourceIdentifier": "secalert@redhat.com", "published": "2020-01-14T18:15:10.540", "lastModified": "2023-02-13T00:47:28.060", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The default event handling scripts in Automatic Bug Reporting Tool (ABRT) allow local users to gain privileges as demonstrated by a symlink attack on a var_log_messages file."}, {"lang": "es", "value": "Los scripts de manejo de eventos predeterminados en Automatic Bug Reporting Tool (ABRT), permiten a usuarios locales alcanzar privilegios como es demostrado por un ataque de enlace simb\u00f3lico en un archivo de var_log_messages."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:C/I:C/A:C", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "COMPLETE", "integrityImpact": "COMPLETE", "availabilityImpact": "COMPLETE", "baseScore": 7.2}, "baseSeverity": "HIGH", "exploitabilityScore": 3.9, "impactScore": 10.0, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-59"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:redhat:automatic_bug_reporting_tool:-:*:*:*:*:*:*:*", "matchCriteriaId": "A396CA2B-75FF-4BEE-8C0A-89B7C030D1E5"}]}]}], "references": [{"url": "http://www.openwall.com/lists/oss-security/2015/04/17/5", "source": "secalert@redhat.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1212861", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://github.com/abrt/abrt/commit/3287aa12eb205cff95cdd00d6d6c5c9a4f8f0eca", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/abrt/abrt/commit/7417505e1d93cc95ec648b74e3c801bc67aacb9f", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/abrt/abrt/commit/3287aa12eb205cff95cdd00d6d6c5c9a4f8f0eca"}}