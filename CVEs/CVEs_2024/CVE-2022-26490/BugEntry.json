{"buggy_code": ["// SPDX-License-Identifier: GPL-2.0-only\n/*\n * Copyright (C) 2014  STMicroelectronics SAS. All rights reserved.\n */\n\n#include <net/nfc/hci.h>\n\n#include \"st21nfca.h\"\n\n#define ST21NFCA_EVT_UICC_ACTIVATE\t\t0x10\n#define ST21NFCA_EVT_UICC_DEACTIVATE\t\t0x13\n#define ST21NFCA_EVT_SE_HARD_RESET\t\t0x20\n#define ST21NFCA_EVT_SE_SOFT_RESET\t\t0x11\n#define ST21NFCA_EVT_SE_END_OF_APDU_TRANSFER\t0x21\n#define ST21NFCA_EVT_SE_ACTIVATE\t\t0x22\n#define ST21NFCA_EVT_SE_DEACTIVATE\t\t0x23\n\n#define ST21NFCA_EVT_TRANSMIT_DATA\t\t0x10\n#define ST21NFCA_EVT_WTX_REQUEST\t\t0x11\n\n#define ST21NFCA_EVT_CONNECTIVITY\t\t0x10\n#define ST21NFCA_EVT_TRANSACTION\t\t0x12\n\n#define ST21NFCA_SE_TO_HOT_PLUG\t\t\t1000\n/* Connectivity pipe only */\n#define ST21NFCA_SE_COUNT_PIPE_UICC\t\t0x01\n/* Connectivity + APDU Reader pipe */\n#define ST21NFCA_SE_COUNT_PIPE_EMBEDDED\t0x02\n\n#define ST21NFCA_SE_MODE_OFF\t\t\t0x00\n#define ST21NFCA_SE_MODE_ON\t\t\t\t0x01\n\n#define ST21NFCA_PARAM_ATR\t\t\t\t0x01\n#define ST21NFCA_ATR_DEFAULT_BWI\t\t0x04\n\n/*\n * WT = 2^BWI/10[s], convert into msecs and add a secure\n * room by increasing by 2 this timeout\n */\n#define ST21NFCA_BWI_TO_TIMEOUT(x)\t\t((1 << x) * 200)\n#define ST21NFCA_ATR_GET_Y_FROM_TD(x)\t(x >> 4)\n\n/* If TA is present bit 0 is set */\n#define ST21NFCA_ATR_TA_PRESENT(x) (x & 0x01)\n/* If TB is present bit 1 is set */\n#define ST21NFCA_ATR_TB_PRESENT(x) (x & 0x02)\n\nstatic u8 st21nfca_se_get_bwi(struct nfc_hci_dev *hdev)\n{\n\tint i;\n\tu8 td;\n\tstruct st21nfca_hci_info *info = nfc_hci_get_clientdata(hdev);\n\n\t/* Bits 8 to 5 of the first TB for T=1 encode BWI from zero to nine */\n\tfor (i = 1; i < ST21NFCA_ESE_MAX_LENGTH; i++) {\n\t\ttd = ST21NFCA_ATR_GET_Y_FROM_TD(info->se_info.atr[i]);\n\t\tif (ST21NFCA_ATR_TA_PRESENT(td))\n\t\t\ti++;\n\t\tif (ST21NFCA_ATR_TB_PRESENT(td)) {\n\t\t\ti++;\n\t\t\treturn info->se_info.atr[i] >> 4;\n\t\t}\n\t}\n\treturn ST21NFCA_ATR_DEFAULT_BWI;\n}\n\nstatic void st21nfca_se_get_atr(struct nfc_hci_dev *hdev)\n{\n\tint r;\n\tstruct sk_buff *skb;\n\tstruct st21nfca_hci_info *info = nfc_hci_get_clientdata(hdev);\n\n\tr = nfc_hci_get_param(hdev, ST21NFCA_APDU_READER_GATE,\n\t\t\tST21NFCA_PARAM_ATR, &skb);\n\tif (r < 0)\n\t\treturn;\n\n\tif (skb->len <= ST21NFCA_ESE_MAX_LENGTH) {\n\t\tmemcpy(info->se_info.atr, skb->data, skb->len);\n\t\tinfo->se_info.wt_timeout =\n\t\t\tST21NFCA_BWI_TO_TIMEOUT(st21nfca_se_get_bwi(hdev));\n\t}\n\tkfree_skb(skb);\n}\n\nstatic int st21nfca_hci_control_se(struct nfc_hci_dev *hdev, u32 se_idx,\n\t\t\t\tu8 state)\n{\n\tstruct st21nfca_hci_info *info = nfc_hci_get_clientdata(hdev);\n\tint r, i;\n\tstruct sk_buff *sk_host_list;\n\tu8 se_event, host_id;\n\n\tswitch (se_idx) {\n\tcase NFC_HCI_UICC_HOST_ID:\n\t\tse_event = (state == ST21NFCA_SE_MODE_ON ?\n\t\t\t\t\tST21NFCA_EVT_UICC_ACTIVATE :\n\t\t\t\t\tST21NFCA_EVT_UICC_DEACTIVATE);\n\n\t\tinfo->se_info.count_pipes = 0;\n\t\tinfo->se_info.expected_pipes = ST21NFCA_SE_COUNT_PIPE_UICC;\n\t\tbreak;\n\tcase ST21NFCA_ESE_HOST_ID:\n\t\tse_event = (state == ST21NFCA_SE_MODE_ON ?\n\t\t\t\t\tST21NFCA_EVT_SE_ACTIVATE :\n\t\t\t\t\tST21NFCA_EVT_SE_DEACTIVATE);\n\n\t\tinfo->se_info.count_pipes = 0;\n\t\tinfo->se_info.expected_pipes = ST21NFCA_SE_COUNT_PIPE_EMBEDDED;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * Wait for an EVT_HOT_PLUG in order to\n\t * retrieve a relevant host list.\n\t */\n\treinit_completion(&info->se_info.req_completion);\n\tr = nfc_hci_send_event(hdev, ST21NFCA_DEVICE_MGNT_GATE, se_event,\n\t\t\t       NULL, 0);\n\tif (r < 0)\n\t\treturn r;\n\n\tmod_timer(&info->se_info.se_active_timer, jiffies +\n\t\tmsecs_to_jiffies(ST21NFCA_SE_TO_HOT_PLUG));\n\tinfo->se_info.se_active = true;\n\n\t/* Ignore return value and check in any case the host_list */\n\twait_for_completion_interruptible(&info->se_info.req_completion);\n\n\tr = nfc_hci_get_param(hdev, NFC_HCI_ADMIN_GATE,\n\t\t\tNFC_HCI_ADMIN_HOST_LIST,\n\t\t\t&sk_host_list);\n\tif (r < 0)\n\t\treturn r;\n\n\tfor (i = 0; i < sk_host_list->len &&\n\t\tsk_host_list->data[i] != se_idx; i++)\n\t\t;\n\thost_id = sk_host_list->data[i];\n\tkfree_skb(sk_host_list);\n\n\tif (state == ST21NFCA_SE_MODE_ON && host_id == se_idx)\n\t\treturn se_idx;\n\telse if (state == ST21NFCA_SE_MODE_OFF && host_id != se_idx)\n\t\treturn se_idx;\n\n\treturn -1;\n}\n\nint st21nfca_hci_discover_se(struct nfc_hci_dev *hdev)\n{\n\tstruct st21nfca_hci_info *info = nfc_hci_get_clientdata(hdev);\n\tint se_count = 0;\n\n\tif (test_bit(ST21NFCA_FACTORY_MODE, &hdev->quirks))\n\t\treturn 0;\n\n\tif (info->se_status->is_uicc_present) {\n\t\tnfc_add_se(hdev->ndev, NFC_HCI_UICC_HOST_ID, NFC_SE_UICC);\n\t\tse_count++;\n\t}\n\n\tif (info->se_status->is_ese_present) {\n\t\tnfc_add_se(hdev->ndev, ST21NFCA_ESE_HOST_ID, NFC_SE_EMBEDDED);\n\t\tse_count++;\n\t}\n\n\treturn !se_count;\n}\nEXPORT_SYMBOL(st21nfca_hci_discover_se);\n\nint st21nfca_hci_enable_se(struct nfc_hci_dev *hdev, u32 se_idx)\n{\n\tint r;\n\n\t/*\n\t * According to upper layer, se_idx == NFC_SE_UICC when\n\t * info->se_status->is_uicc_enable is true should never happen.\n\t * Same for eSE.\n\t */\n\tr = st21nfca_hci_control_se(hdev, se_idx, ST21NFCA_SE_MODE_ON);\n\tif (r == ST21NFCA_ESE_HOST_ID) {\n\t\tst21nfca_se_get_atr(hdev);\n\t\tr = nfc_hci_send_event(hdev, ST21NFCA_APDU_READER_GATE,\n\t\t\t\tST21NFCA_EVT_SE_SOFT_RESET, NULL, 0);\n\t\tif (r < 0)\n\t\t\treturn r;\n\t} else if (r < 0) {\n\t\t/*\n\t\t * The activation tentative failed, the secure element\n\t\t * is not connected. Remove from the list.\n\t\t */\n\t\tnfc_remove_se(hdev->ndev, se_idx);\n\t\treturn r;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(st21nfca_hci_enable_se);\n\nint st21nfca_hci_disable_se(struct nfc_hci_dev *hdev, u32 se_idx)\n{\n\tint r;\n\n\t/*\n\t * According to upper layer, se_idx == NFC_SE_UICC when\n\t * info->se_status->is_uicc_enable is true should never happen\n\t * Same for eSE.\n\t */\n\tr = st21nfca_hci_control_se(hdev, se_idx, ST21NFCA_SE_MODE_OFF);\n\tif (r < 0)\n\t\treturn r;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(st21nfca_hci_disable_se);\n\nint st21nfca_hci_se_io(struct nfc_hci_dev *hdev, u32 se_idx,\n\t\t\tu8 *apdu, size_t apdu_length,\n\t\t\tse_io_cb_t cb, void *cb_context)\n{\n\tstruct st21nfca_hci_info *info = nfc_hci_get_clientdata(hdev);\n\n\tpr_debug(\"se_io %x\\n\", se_idx);\n\n\tswitch (se_idx) {\n\tcase ST21NFCA_ESE_HOST_ID:\n\t\tinfo->se_info.cb = cb;\n\t\tinfo->se_info.cb_context = cb_context;\n\t\tmod_timer(&info->se_info.bwi_timer, jiffies +\n\t\t\t  msecs_to_jiffies(info->se_info.wt_timeout));\n\t\tinfo->se_info.bwi_active = true;\n\t\treturn nfc_hci_send_event(hdev, ST21NFCA_APDU_READER_GATE,\n\t\t\t\t\tST21NFCA_EVT_TRANSMIT_DATA,\n\t\t\t\t\tapdu, apdu_length);\n\tdefault:\n\t\treturn -ENODEV;\n\t}\n}\nEXPORT_SYMBOL(st21nfca_hci_se_io);\n\nstatic void st21nfca_se_wt_timeout(struct timer_list *t)\n{\n\t/*\n\t * No answer from the secure element\n\t * within the defined timeout.\n\t * Let's send a reset request as recovery procedure.\n\t * According to the situation, we first try to send a software reset\n\t * to the secure element. If the next command is still not\n\t * answering in time, we send to the CLF a secure element hardware\n\t * reset request.\n\t */\n\t/* hardware reset managed through VCC_UICC_OUT power supply */\n\tu8 param = 0x01;\n\tstruct st21nfca_hci_info *info = from_timer(info, t,\n\t\t\t\t\t\t    se_info.bwi_timer);\n\n\tinfo->se_info.bwi_active = false;\n\n\tif (!info->se_info.xch_error) {\n\t\tinfo->se_info.xch_error = true;\n\t\tnfc_hci_send_event(info->hdev, ST21NFCA_APDU_READER_GATE,\n\t\t\t\tST21NFCA_EVT_SE_SOFT_RESET, NULL, 0);\n\t} else {\n\t\tinfo->se_info.xch_error = false;\n\t\tnfc_hci_send_event(info->hdev, ST21NFCA_DEVICE_MGNT_GATE,\n\t\t\t\tST21NFCA_EVT_SE_HARD_RESET, &param, 1);\n\t}\n\tinfo->se_info.cb(info->se_info.cb_context, NULL, 0, -ETIME);\n}\n\nstatic void st21nfca_se_activation_timeout(struct timer_list *t)\n{\n\tstruct st21nfca_hci_info *info = from_timer(info, t,\n\t\t\t\t\t\t    se_info.se_active_timer);\n\n\tinfo->se_info.se_active = false;\n\n\tcomplete(&info->se_info.req_completion);\n}\n\n/*\n * Returns:\n * <= 0: driver handled the event, skb consumed\n *    1: driver does not handle the event, please do standard processing\n */\nint st21nfca_connectivity_event_received(struct nfc_hci_dev *hdev, u8 host,\n\t\t\t\tu8 event, struct sk_buff *skb)\n{\n\tint r = 0;\n\tstruct device *dev = &hdev->ndev->dev;\n\tstruct nfc_evt_transaction *transaction;\n\n\tpr_debug(\"connectivity gate event: %x\\n\", event);\n\n\tswitch (event) {\n\tcase ST21NFCA_EVT_CONNECTIVITY:\n\t\tr = nfc_se_connectivity(hdev->ndev, host);\n\tbreak;\n\tcase ST21NFCA_EVT_TRANSACTION:\n\t\t/*\n\t\t * According to specification etsi 102 622\n\t\t * 11.2.2.4 EVT_TRANSACTION Table 52\n\t\t * Description\tTag\tLength\n\t\t * AID\t\t81\t5 to 16\n\t\t * PARAMETERS\t82\t0 to 255\n\t\t */\n\t\tif (skb->len < NFC_MIN_AID_LENGTH + 2 &&\n\t\t    skb->data[0] != NFC_EVT_TRANSACTION_AID_TAG)\n\t\t\treturn -EPROTO;\n\n\t\ttransaction = devm_kzalloc(dev, skb->len - 2, GFP_KERNEL);\n\t\tif (!transaction)\n\t\t\treturn -ENOMEM;\n\n\t\ttransaction->aid_len = skb->data[1];\n\t\tmemcpy(transaction->aid, &skb->data[2],\n\t\t       transaction->aid_len);\n\n\t\t/* Check next byte is PARAMETERS tag (82) */\n\t\tif (skb->data[transaction->aid_len + 2] !=\n\t\t    NFC_EVT_TRANSACTION_PARAMS_TAG)\n\t\t\treturn -EPROTO;\n\n\t\ttransaction->params_len = skb->data[transaction->aid_len + 3];\n\t\tmemcpy(transaction->params, skb->data +\n\t\t       transaction->aid_len + 4, transaction->params_len);\n\n\t\tr = nfc_se_transaction(hdev->ndev, host, transaction);\n\tbreak;\n\tdefault:\n\t\tnfc_err(&hdev->ndev->dev, \"Unexpected event on connectivity gate\\n\");\n\t\treturn 1;\n\t}\n\tkfree_skb(skb);\n\treturn r;\n}\nEXPORT_SYMBOL(st21nfca_connectivity_event_received);\n\nint st21nfca_apdu_reader_event_received(struct nfc_hci_dev *hdev,\n\t\t\t\t\tu8 event, struct sk_buff *skb)\n{\n\tint r = 0;\n\tstruct st21nfca_hci_info *info = nfc_hci_get_clientdata(hdev);\n\n\tpr_debug(\"apdu reader gate event: %x\\n\", event);\n\n\tswitch (event) {\n\tcase ST21NFCA_EVT_TRANSMIT_DATA:\n\t\tdel_timer_sync(&info->se_info.bwi_timer);\n\t\tinfo->se_info.bwi_active = false;\n\t\tr = nfc_hci_send_event(hdev, ST21NFCA_DEVICE_MGNT_GATE,\n\t\t\t\tST21NFCA_EVT_SE_END_OF_APDU_TRANSFER, NULL, 0);\n\t\tif (r < 0)\n\t\t\tgoto exit;\n\n\t\tinfo->se_info.cb(info->se_info.cb_context,\n\t\t\tskb->data, skb->len, 0);\n\t\tbreak;\n\tcase ST21NFCA_EVT_WTX_REQUEST:\n\t\tmod_timer(&info->se_info.bwi_timer, jiffies +\n\t\t\t\tmsecs_to_jiffies(info->se_info.wt_timeout));\n\t\tbreak;\n\tdefault:\n\t\tnfc_err(&hdev->ndev->dev, \"Unexpected event on apdu reader gate\\n\");\n\t\treturn 1;\n\t}\n\nexit:\n\tkfree_skb(skb);\n\treturn r;\n}\nEXPORT_SYMBOL(st21nfca_apdu_reader_event_received);\n\nvoid st21nfca_se_init(struct nfc_hci_dev *hdev)\n{\n\tstruct st21nfca_hci_info *info = nfc_hci_get_clientdata(hdev);\n\n\tinit_completion(&info->se_info.req_completion);\n\t/* initialize timers */\n\ttimer_setup(&info->se_info.bwi_timer, st21nfca_se_wt_timeout, 0);\n\tinfo->se_info.bwi_active = false;\n\n\ttimer_setup(&info->se_info.se_active_timer,\n\t\t    st21nfca_se_activation_timeout, 0);\n\tinfo->se_info.se_active = false;\n\n\tinfo->se_info.count_pipes = 0;\n\tinfo->se_info.expected_pipes = 0;\n\n\tinfo->se_info.xch_error = false;\n\n\tinfo->se_info.wt_timeout =\n\t\t\tST21NFCA_BWI_TO_TIMEOUT(ST21NFCA_ATR_DEFAULT_BWI);\n}\nEXPORT_SYMBOL(st21nfca_se_init);\n\nvoid st21nfca_se_deinit(struct nfc_hci_dev *hdev)\n{\n\tstruct st21nfca_hci_info *info = nfc_hci_get_clientdata(hdev);\n\n\tif (info->se_info.bwi_active)\n\t\tdel_timer_sync(&info->se_info.bwi_timer);\n\tif (info->se_info.se_active)\n\t\tdel_timer_sync(&info->se_info.se_active_timer);\n\n\tinfo->se_info.bwi_active = false;\n\tinfo->se_info.se_active = false;\n}\nEXPORT_SYMBOL(st21nfca_se_deinit);\n"], "fixing_code": ["// SPDX-License-Identifier: GPL-2.0-only\n/*\n * Copyright (C) 2014  STMicroelectronics SAS. All rights reserved.\n */\n\n#include <net/nfc/hci.h>\n\n#include \"st21nfca.h\"\n\n#define ST21NFCA_EVT_UICC_ACTIVATE\t\t0x10\n#define ST21NFCA_EVT_UICC_DEACTIVATE\t\t0x13\n#define ST21NFCA_EVT_SE_HARD_RESET\t\t0x20\n#define ST21NFCA_EVT_SE_SOFT_RESET\t\t0x11\n#define ST21NFCA_EVT_SE_END_OF_APDU_TRANSFER\t0x21\n#define ST21NFCA_EVT_SE_ACTIVATE\t\t0x22\n#define ST21NFCA_EVT_SE_DEACTIVATE\t\t0x23\n\n#define ST21NFCA_EVT_TRANSMIT_DATA\t\t0x10\n#define ST21NFCA_EVT_WTX_REQUEST\t\t0x11\n\n#define ST21NFCA_EVT_CONNECTIVITY\t\t0x10\n#define ST21NFCA_EVT_TRANSACTION\t\t0x12\n\n#define ST21NFCA_SE_TO_HOT_PLUG\t\t\t1000\n/* Connectivity pipe only */\n#define ST21NFCA_SE_COUNT_PIPE_UICC\t\t0x01\n/* Connectivity + APDU Reader pipe */\n#define ST21NFCA_SE_COUNT_PIPE_EMBEDDED\t0x02\n\n#define ST21NFCA_SE_MODE_OFF\t\t\t0x00\n#define ST21NFCA_SE_MODE_ON\t\t\t\t0x01\n\n#define ST21NFCA_PARAM_ATR\t\t\t\t0x01\n#define ST21NFCA_ATR_DEFAULT_BWI\t\t0x04\n\n/*\n * WT = 2^BWI/10[s], convert into msecs and add a secure\n * room by increasing by 2 this timeout\n */\n#define ST21NFCA_BWI_TO_TIMEOUT(x)\t\t((1 << x) * 200)\n#define ST21NFCA_ATR_GET_Y_FROM_TD(x)\t(x >> 4)\n\n/* If TA is present bit 0 is set */\n#define ST21NFCA_ATR_TA_PRESENT(x) (x & 0x01)\n/* If TB is present bit 1 is set */\n#define ST21NFCA_ATR_TB_PRESENT(x) (x & 0x02)\n\nstatic u8 st21nfca_se_get_bwi(struct nfc_hci_dev *hdev)\n{\n\tint i;\n\tu8 td;\n\tstruct st21nfca_hci_info *info = nfc_hci_get_clientdata(hdev);\n\n\t/* Bits 8 to 5 of the first TB for T=1 encode BWI from zero to nine */\n\tfor (i = 1; i < ST21NFCA_ESE_MAX_LENGTH; i++) {\n\t\ttd = ST21NFCA_ATR_GET_Y_FROM_TD(info->se_info.atr[i]);\n\t\tif (ST21NFCA_ATR_TA_PRESENT(td))\n\t\t\ti++;\n\t\tif (ST21NFCA_ATR_TB_PRESENT(td)) {\n\t\t\ti++;\n\t\t\treturn info->se_info.atr[i] >> 4;\n\t\t}\n\t}\n\treturn ST21NFCA_ATR_DEFAULT_BWI;\n}\n\nstatic void st21nfca_se_get_atr(struct nfc_hci_dev *hdev)\n{\n\tint r;\n\tstruct sk_buff *skb;\n\tstruct st21nfca_hci_info *info = nfc_hci_get_clientdata(hdev);\n\n\tr = nfc_hci_get_param(hdev, ST21NFCA_APDU_READER_GATE,\n\t\t\tST21NFCA_PARAM_ATR, &skb);\n\tif (r < 0)\n\t\treturn;\n\n\tif (skb->len <= ST21NFCA_ESE_MAX_LENGTH) {\n\t\tmemcpy(info->se_info.atr, skb->data, skb->len);\n\t\tinfo->se_info.wt_timeout =\n\t\t\tST21NFCA_BWI_TO_TIMEOUT(st21nfca_se_get_bwi(hdev));\n\t}\n\tkfree_skb(skb);\n}\n\nstatic int st21nfca_hci_control_se(struct nfc_hci_dev *hdev, u32 se_idx,\n\t\t\t\tu8 state)\n{\n\tstruct st21nfca_hci_info *info = nfc_hci_get_clientdata(hdev);\n\tint r, i;\n\tstruct sk_buff *sk_host_list;\n\tu8 se_event, host_id;\n\n\tswitch (se_idx) {\n\tcase NFC_HCI_UICC_HOST_ID:\n\t\tse_event = (state == ST21NFCA_SE_MODE_ON ?\n\t\t\t\t\tST21NFCA_EVT_UICC_ACTIVATE :\n\t\t\t\t\tST21NFCA_EVT_UICC_DEACTIVATE);\n\n\t\tinfo->se_info.count_pipes = 0;\n\t\tinfo->se_info.expected_pipes = ST21NFCA_SE_COUNT_PIPE_UICC;\n\t\tbreak;\n\tcase ST21NFCA_ESE_HOST_ID:\n\t\tse_event = (state == ST21NFCA_SE_MODE_ON ?\n\t\t\t\t\tST21NFCA_EVT_SE_ACTIVATE :\n\t\t\t\t\tST21NFCA_EVT_SE_DEACTIVATE);\n\n\t\tinfo->se_info.count_pipes = 0;\n\t\tinfo->se_info.expected_pipes = ST21NFCA_SE_COUNT_PIPE_EMBEDDED;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * Wait for an EVT_HOT_PLUG in order to\n\t * retrieve a relevant host list.\n\t */\n\treinit_completion(&info->se_info.req_completion);\n\tr = nfc_hci_send_event(hdev, ST21NFCA_DEVICE_MGNT_GATE, se_event,\n\t\t\t       NULL, 0);\n\tif (r < 0)\n\t\treturn r;\n\n\tmod_timer(&info->se_info.se_active_timer, jiffies +\n\t\tmsecs_to_jiffies(ST21NFCA_SE_TO_HOT_PLUG));\n\tinfo->se_info.se_active = true;\n\n\t/* Ignore return value and check in any case the host_list */\n\twait_for_completion_interruptible(&info->se_info.req_completion);\n\n\tr = nfc_hci_get_param(hdev, NFC_HCI_ADMIN_GATE,\n\t\t\tNFC_HCI_ADMIN_HOST_LIST,\n\t\t\t&sk_host_list);\n\tif (r < 0)\n\t\treturn r;\n\n\tfor (i = 0; i < sk_host_list->len &&\n\t\tsk_host_list->data[i] != se_idx; i++)\n\t\t;\n\thost_id = sk_host_list->data[i];\n\tkfree_skb(sk_host_list);\n\n\tif (state == ST21NFCA_SE_MODE_ON && host_id == se_idx)\n\t\treturn se_idx;\n\telse if (state == ST21NFCA_SE_MODE_OFF && host_id != se_idx)\n\t\treturn se_idx;\n\n\treturn -1;\n}\n\nint st21nfca_hci_discover_se(struct nfc_hci_dev *hdev)\n{\n\tstruct st21nfca_hci_info *info = nfc_hci_get_clientdata(hdev);\n\tint se_count = 0;\n\n\tif (test_bit(ST21NFCA_FACTORY_MODE, &hdev->quirks))\n\t\treturn 0;\n\n\tif (info->se_status->is_uicc_present) {\n\t\tnfc_add_se(hdev->ndev, NFC_HCI_UICC_HOST_ID, NFC_SE_UICC);\n\t\tse_count++;\n\t}\n\n\tif (info->se_status->is_ese_present) {\n\t\tnfc_add_se(hdev->ndev, ST21NFCA_ESE_HOST_ID, NFC_SE_EMBEDDED);\n\t\tse_count++;\n\t}\n\n\treturn !se_count;\n}\nEXPORT_SYMBOL(st21nfca_hci_discover_se);\n\nint st21nfca_hci_enable_se(struct nfc_hci_dev *hdev, u32 se_idx)\n{\n\tint r;\n\n\t/*\n\t * According to upper layer, se_idx == NFC_SE_UICC when\n\t * info->se_status->is_uicc_enable is true should never happen.\n\t * Same for eSE.\n\t */\n\tr = st21nfca_hci_control_se(hdev, se_idx, ST21NFCA_SE_MODE_ON);\n\tif (r == ST21NFCA_ESE_HOST_ID) {\n\t\tst21nfca_se_get_atr(hdev);\n\t\tr = nfc_hci_send_event(hdev, ST21NFCA_APDU_READER_GATE,\n\t\t\t\tST21NFCA_EVT_SE_SOFT_RESET, NULL, 0);\n\t\tif (r < 0)\n\t\t\treturn r;\n\t} else if (r < 0) {\n\t\t/*\n\t\t * The activation tentative failed, the secure element\n\t\t * is not connected. Remove from the list.\n\t\t */\n\t\tnfc_remove_se(hdev->ndev, se_idx);\n\t\treturn r;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(st21nfca_hci_enable_se);\n\nint st21nfca_hci_disable_se(struct nfc_hci_dev *hdev, u32 se_idx)\n{\n\tint r;\n\n\t/*\n\t * According to upper layer, se_idx == NFC_SE_UICC when\n\t * info->se_status->is_uicc_enable is true should never happen\n\t * Same for eSE.\n\t */\n\tr = st21nfca_hci_control_se(hdev, se_idx, ST21NFCA_SE_MODE_OFF);\n\tif (r < 0)\n\t\treturn r;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(st21nfca_hci_disable_se);\n\nint st21nfca_hci_se_io(struct nfc_hci_dev *hdev, u32 se_idx,\n\t\t\tu8 *apdu, size_t apdu_length,\n\t\t\tse_io_cb_t cb, void *cb_context)\n{\n\tstruct st21nfca_hci_info *info = nfc_hci_get_clientdata(hdev);\n\n\tpr_debug(\"se_io %x\\n\", se_idx);\n\n\tswitch (se_idx) {\n\tcase ST21NFCA_ESE_HOST_ID:\n\t\tinfo->se_info.cb = cb;\n\t\tinfo->se_info.cb_context = cb_context;\n\t\tmod_timer(&info->se_info.bwi_timer, jiffies +\n\t\t\t  msecs_to_jiffies(info->se_info.wt_timeout));\n\t\tinfo->se_info.bwi_active = true;\n\t\treturn nfc_hci_send_event(hdev, ST21NFCA_APDU_READER_GATE,\n\t\t\t\t\tST21NFCA_EVT_TRANSMIT_DATA,\n\t\t\t\t\tapdu, apdu_length);\n\tdefault:\n\t\treturn -ENODEV;\n\t}\n}\nEXPORT_SYMBOL(st21nfca_hci_se_io);\n\nstatic void st21nfca_se_wt_timeout(struct timer_list *t)\n{\n\t/*\n\t * No answer from the secure element\n\t * within the defined timeout.\n\t * Let's send a reset request as recovery procedure.\n\t * According to the situation, we first try to send a software reset\n\t * to the secure element. If the next command is still not\n\t * answering in time, we send to the CLF a secure element hardware\n\t * reset request.\n\t */\n\t/* hardware reset managed through VCC_UICC_OUT power supply */\n\tu8 param = 0x01;\n\tstruct st21nfca_hci_info *info = from_timer(info, t,\n\t\t\t\t\t\t    se_info.bwi_timer);\n\n\tinfo->se_info.bwi_active = false;\n\n\tif (!info->se_info.xch_error) {\n\t\tinfo->se_info.xch_error = true;\n\t\tnfc_hci_send_event(info->hdev, ST21NFCA_APDU_READER_GATE,\n\t\t\t\tST21NFCA_EVT_SE_SOFT_RESET, NULL, 0);\n\t} else {\n\t\tinfo->se_info.xch_error = false;\n\t\tnfc_hci_send_event(info->hdev, ST21NFCA_DEVICE_MGNT_GATE,\n\t\t\t\tST21NFCA_EVT_SE_HARD_RESET, &param, 1);\n\t}\n\tinfo->se_info.cb(info->se_info.cb_context, NULL, 0, -ETIME);\n}\n\nstatic void st21nfca_se_activation_timeout(struct timer_list *t)\n{\n\tstruct st21nfca_hci_info *info = from_timer(info, t,\n\t\t\t\t\t\t    se_info.se_active_timer);\n\n\tinfo->se_info.se_active = false;\n\n\tcomplete(&info->se_info.req_completion);\n}\n\n/*\n * Returns:\n * <= 0: driver handled the event, skb consumed\n *    1: driver does not handle the event, please do standard processing\n */\nint st21nfca_connectivity_event_received(struct nfc_hci_dev *hdev, u8 host,\n\t\t\t\tu8 event, struct sk_buff *skb)\n{\n\tint r = 0;\n\tstruct device *dev = &hdev->ndev->dev;\n\tstruct nfc_evt_transaction *transaction;\n\n\tpr_debug(\"connectivity gate event: %x\\n\", event);\n\n\tswitch (event) {\n\tcase ST21NFCA_EVT_CONNECTIVITY:\n\t\tr = nfc_se_connectivity(hdev->ndev, host);\n\tbreak;\n\tcase ST21NFCA_EVT_TRANSACTION:\n\t\t/*\n\t\t * According to specification etsi 102 622\n\t\t * 11.2.2.4 EVT_TRANSACTION Table 52\n\t\t * Description\tTag\tLength\n\t\t * AID\t\t81\t5 to 16\n\t\t * PARAMETERS\t82\t0 to 255\n\t\t */\n\t\tif (skb->len < NFC_MIN_AID_LENGTH + 2 &&\n\t\t    skb->data[0] != NFC_EVT_TRANSACTION_AID_TAG)\n\t\t\treturn -EPROTO;\n\n\t\ttransaction = devm_kzalloc(dev, skb->len - 2, GFP_KERNEL);\n\t\tif (!transaction)\n\t\t\treturn -ENOMEM;\n\n\t\ttransaction->aid_len = skb->data[1];\n\n\t\t/* Checking if the length of the AID is valid */\n\t\tif (transaction->aid_len > sizeof(transaction->aid))\n\t\t\treturn -EINVAL;\n\n\t\tmemcpy(transaction->aid, &skb->data[2],\n\t\t       transaction->aid_len);\n\n\t\t/* Check next byte is PARAMETERS tag (82) */\n\t\tif (skb->data[transaction->aid_len + 2] !=\n\t\t    NFC_EVT_TRANSACTION_PARAMS_TAG)\n\t\t\treturn -EPROTO;\n\n\t\ttransaction->params_len = skb->data[transaction->aid_len + 3];\n\n\t\t/* Total size is allocated (skb->len - 2) minus fixed array members */\n\t\tif (transaction->params_len > ((skb->len - 2) - sizeof(struct nfc_evt_transaction)))\n\t\t\treturn -EINVAL;\n\n\t\tmemcpy(transaction->params, skb->data +\n\t\t       transaction->aid_len + 4, transaction->params_len);\n\n\t\tr = nfc_se_transaction(hdev->ndev, host, transaction);\n\tbreak;\n\tdefault:\n\t\tnfc_err(&hdev->ndev->dev, \"Unexpected event on connectivity gate\\n\");\n\t\treturn 1;\n\t}\n\tkfree_skb(skb);\n\treturn r;\n}\nEXPORT_SYMBOL(st21nfca_connectivity_event_received);\n\nint st21nfca_apdu_reader_event_received(struct nfc_hci_dev *hdev,\n\t\t\t\t\tu8 event, struct sk_buff *skb)\n{\n\tint r = 0;\n\tstruct st21nfca_hci_info *info = nfc_hci_get_clientdata(hdev);\n\n\tpr_debug(\"apdu reader gate event: %x\\n\", event);\n\n\tswitch (event) {\n\tcase ST21NFCA_EVT_TRANSMIT_DATA:\n\t\tdel_timer_sync(&info->se_info.bwi_timer);\n\t\tinfo->se_info.bwi_active = false;\n\t\tr = nfc_hci_send_event(hdev, ST21NFCA_DEVICE_MGNT_GATE,\n\t\t\t\tST21NFCA_EVT_SE_END_OF_APDU_TRANSFER, NULL, 0);\n\t\tif (r < 0)\n\t\t\tgoto exit;\n\n\t\tinfo->se_info.cb(info->se_info.cb_context,\n\t\t\tskb->data, skb->len, 0);\n\t\tbreak;\n\tcase ST21NFCA_EVT_WTX_REQUEST:\n\t\tmod_timer(&info->se_info.bwi_timer, jiffies +\n\t\t\t\tmsecs_to_jiffies(info->se_info.wt_timeout));\n\t\tbreak;\n\tdefault:\n\t\tnfc_err(&hdev->ndev->dev, \"Unexpected event on apdu reader gate\\n\");\n\t\treturn 1;\n\t}\n\nexit:\n\tkfree_skb(skb);\n\treturn r;\n}\nEXPORT_SYMBOL(st21nfca_apdu_reader_event_received);\n\nvoid st21nfca_se_init(struct nfc_hci_dev *hdev)\n{\n\tstruct st21nfca_hci_info *info = nfc_hci_get_clientdata(hdev);\n\n\tinit_completion(&info->se_info.req_completion);\n\t/* initialize timers */\n\ttimer_setup(&info->se_info.bwi_timer, st21nfca_se_wt_timeout, 0);\n\tinfo->se_info.bwi_active = false;\n\n\ttimer_setup(&info->se_info.se_active_timer,\n\t\t    st21nfca_se_activation_timeout, 0);\n\tinfo->se_info.se_active = false;\n\n\tinfo->se_info.count_pipes = 0;\n\tinfo->se_info.expected_pipes = 0;\n\n\tinfo->se_info.xch_error = false;\n\n\tinfo->se_info.wt_timeout =\n\t\t\tST21NFCA_BWI_TO_TIMEOUT(ST21NFCA_ATR_DEFAULT_BWI);\n}\nEXPORT_SYMBOL(st21nfca_se_init);\n\nvoid st21nfca_se_deinit(struct nfc_hci_dev *hdev)\n{\n\tstruct st21nfca_hci_info *info = nfc_hci_get_clientdata(hdev);\n\n\tif (info->se_info.bwi_active)\n\t\tdel_timer_sync(&info->se_info.bwi_timer);\n\tif (info->se_info.se_active)\n\t\tdel_timer_sync(&info->se_info.se_active_timer);\n\n\tinfo->se_info.bwi_active = false;\n\tinfo->se_info.se_active = false;\n}\nEXPORT_SYMBOL(st21nfca_se_deinit);\n"], "filenames": ["drivers/nfc/st21nfca/se.c"], "buggy_code_start_loc": [318], "buggy_code_end_loc": [327], "fixing_code_start_loc": [319], "fixing_code_end_loc": [338], "type": "CWE-120", "message": "st21nfca_connectivity_event_received in drivers/nfc/st21nfca/se.c in the Linux kernel through 5.16.12 has EVT_TRANSACTION buffer overflows because of untrusted length parameters.", "other": {"cve": {"id": "CVE-2022-26490", "sourceIdentifier": "cve@mitre.org", "published": "2022-03-06T04:15:07.100", "lastModified": "2023-01-20T02:27:20.017", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "st21nfca_connectivity_event_received in drivers/nfc/st21nfca/se.c in the Linux kernel through 5.16.12 has EVT_TRANSACTION buffer overflows because of untrusted length parameters."}, {"lang": "es", "value": "La funci\u00f3n st21nfca_connectivity_event_received en el archivo drivers/nfc/st21nfca/se.c en el kernel de Linux hasta la versi\u00f3n 5.16.12, presenta desbordamientos de b\u00fafer EVT_TRANSACTION debido a par\u00e1metros de longitud no confiables"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 4.6}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.9, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-120"}]}], "configurations": [{"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndIncluding": "5.16.12", "matchCriteriaId": "02C9F709-39A8-42F8-A574-A0319FC53F7C"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:34:*:*:*:*:*:*:*", "matchCriteriaId": "A930E247-0B43-43CB-98FF-6CE7B8189835"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:35:*:*:*:*:*:*:*", "matchCriteriaId": "80E516C0-98A4-4ADE-B69F-66A772E2BAAA"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h300s_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "6770B6C3-732E-4E22-BF1C-2D2FD610061C"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h300s:-:*:*:*:*:*:*:*", "matchCriteriaId": "9F9C8C20-42EB-4AB5-BD97-212DEB070C43"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h500s_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "7FFF7106-ED78-49BA-9EC5-B889E3685D53"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h500s:-:*:*:*:*:*:*:*", "matchCriteriaId": "E63D8B0F-006E-4801-BF9D-1C001BBFB4F9"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h700s_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "56409CEC-5A1E-4450-AA42-641E459CC2AF"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h700s:-:*:*:*:*:*:*:*", "matchCriteriaId": "B06F4839-D16A-4A61-9BB5-55B13F41E47F"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h300e_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "108A2215-50FB-4074-94CF-C130FA14566D"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h300e:-:*:*:*:*:*:*:*", "matchCriteriaId": "7AFC73CE-ABB9-42D3-9A71-3F5BC5381E0E"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h500e_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "32F0B6C0-F930-480D-962B-3F4EFDCC13C7"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h500e:-:*:*:*:*:*:*:*", "matchCriteriaId": "803BC414-B250-4E3A-A478-A3881340D6B8"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h700e_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "0FEB3337-BFDE-462A-908B-176F92053CEC"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h700e:-:*:*:*:*:*:*:*", "matchCriteriaId": "736AEAE9-782B-4F71-9893-DED53367E102"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h410s_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "D0B4AD8A-F172-4558-AEC6-FF424BA2D912"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h410s:-:*:*:*:*:*:*:*", "matchCriteriaId": "8497A4C9-8474-4A62-8331-3FE862ED4098"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h410c_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "234DEFE0-5CE5-4B0A-96B8-5D227CB8ED31"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h410c:-:*:*:*:*:*:*:*", "matchCriteriaId": "CDDF61B7-EC5C-467C-B710-B89F502CD04F"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}]}]}], "references": [{"url": "https://github.com/torvalds/linux/commit/4fbcc1a4cb20fe26ad0225679c536c80f1648221", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2022/07/msg00000.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/BG4J46EMFPDD5QHYXDUI3PJCZQ7HQAZR/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/C5AUUDGSDLGYU7SZSK4PFAN22NISQZBT/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20220429-0004/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.debian.org/security/2022/dsa-5127", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.debian.org/security/2022/dsa-5173", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/4fbcc1a4cb20fe26ad0225679c536c80f1648221"}}