{"buggy_code": ["/* -*- mode: c; indent-tabs-mode: nil -*- */\n/*\n * Copyright 2000, 2008 by the Massachusetts Institute of Technology.\n * All Rights Reserved.\n *\n * Export of this software from the United States of America may\n *   require a specific license from the United States Government.\n *   It is the responsibility of any person or organization contemplating\n *   export to obtain such a license before exporting.\n *\n * WITHIN THAT CONSTRAINT, permission to use, copy, modify, and\n * distribute this software and its documentation for any purpose and\n * without fee is hereby granted, provided that the above copyright\n * notice appear in all copies and that both that copyright notice and\n * this permission notice appear in supporting documentation, and that\n * the name of M.I.T. not be used in advertising or publicity pertaining\n * to distribution of the software without specific, written prior\n * permission.  Furthermore if you modify this software you must label\n * your software as modified software and not distribute it in such a\n * fashion that it might be confused with the original M.I.T. software.\n * M.I.T. makes no representations about the suitability of\n * this software for any purpose.  It is provided \"as is\" without express\n * or implied warranty.\n *\n */\n/*\n * Copyright 1993 by OpenVision Technologies, Inc.\n *\n * Permission to use, copy, modify, distribute, and sell this software\n * and its documentation for any purpose is hereby granted without fee,\n * provided that the above copyright notice appears in all copies and\n * that both that copyright notice and this permission notice appear in\n * supporting documentation, and that the name of OpenVision not be used\n * in advertising or publicity pertaining to distribution of the software\n * without specific, written prior permission. OpenVision makes no\n * representations about the suitability of this software for any\n * purpose.  It is provided \"as is\" without express or implied warranty.\n *\n * OPENVISION DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,\n * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO\n * EVENT SHALL OPENVISION BE LIABLE FOR ANY SPECIAL, INDIRECT OR\n * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF\n * USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\n * OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\n * PERFORMANCE OF THIS SOFTWARE.\n */\n\n#ifndef _GSSAPIP_KRB5_H_\n#define _GSSAPIP_KRB5_H_\n\n#include <k5-int.h>\n\n#ifdef HAVE_MEMORY_H\n#include <memory.h>\n#endif\n\n/* work around sunos braindamage */\n#ifdef major\n#undef major\n#endif\n#ifdef minor\n#undef minor\n#endif\n\n#include \"gssapiP_generic.h\"\n\n/* The include of gssapi_krb5.h will dtrt with the above #defines in\n * effect.\n */\n#include \"gssapi_krb5.h\"\n#include \"gssapi_err_krb5.h\"\n#include \"gssapi_ext.h\"\n\n/* for debugging */\n#undef CFX_EXERCISE\n\n/** constants **/\n\n#define GSS_MECH_KRB5_OID_LENGTH 9\n#define GSS_MECH_KRB5_OID \"\\052\\206\\110\\206\\367\\022\\001\\002\\002\"\n\n#define GSS_MECH_KRB5_OLD_OID_LENGTH 5\n#define GSS_MECH_KRB5_OLD_OID \"\\053\\005\\001\\005\\002\"\n\n/* Incorrect krb5 mech OID emitted by MS. */\n#define GSS_MECH_KRB5_WRONG_OID_LENGTH 9\n#define GSS_MECH_KRB5_WRONG_OID \"\\052\\206\\110\\202\\367\\022\\001\\002\\002\"\n\n/* IAKERB variant */\n#define GSS_MECH_IAKERB_OID_LENGTH 6\n#define GSS_MECH_IAKERB_OID \"\\053\\006\\001\\005\\002\\005\"\n\nextern const gss_OID_set_desc * const kg_all_mechs;\n\n#define CKSUMTYPE_KG_CB         0x8003\n\n#define KG_TOK_CTX_AP_REQ       0x0100\n#define KG_TOK_CTX_AP_REP       0x0200\n#define KG_TOK_CTX_ERROR        0x0300\n#define KG_TOK_SIGN_MSG         0x0101\n#define KG_TOK_SEAL_MSG         0x0201\n#define KG_TOK_MIC_MSG          0x0101\n#define KG_TOK_WRAP_MSG         0x0201\n#define KG_TOK_DEL_CTX          0x0102\n#define KG2_TOK_MIC_MSG         0x0404\n#define KG2_TOK_WRAP_MSG        0x0504\n#define KG2_TOK_DEL_CTX         0x0405\n#define IAKERB_TOK_PROXY        0x0501\n\n#define KRB5_GSS_FOR_CREDS_OPTION 1\n\n#define KG2_RESP_FLAG_ERROR             0x0001\n#define KG2_RESP_FLAG_DELEG_OK          0x0002\n\n/** CFX flags **/\n#define FLAG_SENDER_IS_ACCEPTOR 0x01\n#define FLAG_WRAP_CONFIDENTIAL  0x02\n#define FLAG_ACCEPTOR_SUBKEY    0x04\n\n/* These are to be stored in little-endian order, i.e., des-mac is\n   stored as 02 00.  */\nenum sgn_alg {\n    SGN_ALG_DES_MAC_MD5           = 0x0000,\n    SGN_ALG_MD2_5                 = 0x0001,\n    SGN_ALG_DES_MAC               = 0x0002,\n    SGN_ALG_3                     = 0x0003, /* not published */\n    SGN_ALG_HMAC_MD5              = 0x0011, /* microsoft w2k;  */\n    SGN_ALG_HMAC_SHA1_DES3_KD     = 0x0004\n};\nenum seal_alg {\n    SEAL_ALG_NONE            = 0xffff,\n    SEAL_ALG_DES             = 0x0000,\n    SEAL_ALG_1               = 0x0001, /* not published */\n    SEAL_ALG_MICROSOFT_RC4   = 0x0010, /* microsoft w2k;  */\n    SEAL_ALG_DES3KD          = 0x0002\n};\n\n/* for 3DES */\n#define KG_USAGE_SEAL 22\n#define KG_USAGE_SIGN 23\n#define KG_USAGE_SEQ  24\n\n/* for draft-ietf-krb-wg-gssapi-cfx-01 */\n#define KG_USAGE_ACCEPTOR_SEAL  22\n#define KG_USAGE_ACCEPTOR_SIGN  23\n#define KG_USAGE_INITIATOR_SEAL 24\n#define KG_USAGE_INITIATOR_SIGN 25\n\nenum qop {\n    GSS_KRB5_INTEG_C_QOP_MD5       = 0x0001, /* *partial* MD5 = \"MD2.5\" */\n    GSS_KRB5_INTEG_C_QOP_DES_MD5   = 0x0002,\n    GSS_KRB5_INTEG_C_QOP_DES_MAC   = 0x0003,\n    GSS_KRB5_INTEG_C_QOP_HMAC_SHA1 = 0x0004,\n    GSS_KRB5_INTEG_C_QOP_MASK      = 0x00ff,\n    GSS_KRB5_CONF_C_QOP_DES        = 0x0100,\n    GSS_KRB5_CONF_C_QOP_DES3_KD    = 0x0200,\n    GSS_KRB5_CONF_C_QOP_MASK       = 0xff00\n};\n\n/** internal types **/\n\ntypedef struct _krb5_gss_name_rec {\n    krb5_principal princ;       /* immutable */\n    char *service;              /* immutable */\n    char *host;                 /* immutable */\n    k5_mutex_t lock;            /* protects ad_context only for now */\n    krb5_authdata_context ad_context;\n} krb5_gss_name_rec, *krb5_gss_name_t;\n\ntypedef struct _krb5_gss_cred_id_rec {\n    /* protect against simultaneous accesses */\n    k5_mutex_t lock;\n\n    /* name/type of credential */\n    gss_cred_usage_t usage;\n    krb5_gss_name_t name;\n    krb5_principal impersonator;\n    unsigned int default_identity : 1;\n    unsigned int iakerb_mech : 1;\n    unsigned int destroy_ccache : 1;\n    unsigned int suppress_ci_flags : 1;\n\n    /* keytab (accept) data */\n    krb5_keytab keytab;\n    krb5_rcache rcache;\n\n    /* ccache (init) data */\n    krb5_ccache ccache;\n    krb5_keytab client_keytab;\n    krb5_boolean have_tgt;\n    krb5_timestamp expire;\n    krb5_timestamp refresh_time;\n    krb5_enctype *req_enctypes;  /* limit negotiated enctypes to this list */\n    char *password;\n} krb5_gss_cred_id_rec, *krb5_gss_cred_id_t;\n\ntypedef struct _krb5_gss_ctx_ext_rec {\n    struct {\n        krb5_data *conv;\n        int verified;\n    } iakerb;\n} krb5_gss_ctx_ext_rec, *krb5_gss_ctx_ext_t;\n\ntypedef struct _krb5_gss_ctx_id_rec {\n    krb5_magic magic;\n    unsigned int initiate : 1;   /* nonzero if initiating, zero if accepting */\n    unsigned int established : 1;\n    unsigned int have_acceptor_subkey : 1;\n    unsigned int seed_init : 1;  /* XXX tested but never actually set */\n    unsigned int terminated : 1;\n    OM_uint32 gss_flags;\n    unsigned char seed[16];\n    krb5_gss_name_t here;\n    krb5_gss_name_t there;\n    krb5_key subkey; /* One of two potential keys to use with RFC 4121\n                      * packets; this key must always be set. */\n    int signalg;\n    size_t cksum_size;\n    int sealalg;\n    krb5_key enc; /* RFC 1964 encryption key; seq xored with a constant\n                   * for DES, seq for other RFC 1964 enctypes  */\n    krb5_key seq; /* RFC 1964 sequencing key */\n    krb5_ticket_times krb_times;\n    krb5_flags krb_flags;\n    /* XXX these used to be signed.  the old spec is inspecific, and\n       the new spec specifies unsigned.  I don't believe that the change\n       affects the wire encoding. */\n    uint64_t seq_send;\n    uint64_t seq_recv;\n    g_seqnum_state seqstate;\n    krb5_context k5_context;\n    krb5_auth_context auth_context;\n    gss_OID_desc *mech_used;\n    /* Protocol spec revision for sending packets\n       0 => RFC 1964 with 3DES and RC4 enhancements\n       1 => RFC 4121\n       No others defined so far.  It is always permitted to receive\n       tokens in RFC 4121 format.  If enc is non-null, receiving RFC\n       1964 tokens is permitted.*/\n    int proto;\n    krb5_cksumtype cksumtype;    /* for \"main\" subkey */\n    krb5_key acceptor_subkey; /* CFX only */\n    krb5_cksumtype acceptor_subkey_cksumtype;\n    int cred_rcache;             /* did we get rcache from creds? */\n    krb5_authdata **authdata;\n} krb5_gss_ctx_id_rec, *krb5_gss_ctx_id_t;\n\nextern g_set kg_vdb;\n\n#ifndef LEAN_CLIENT\nextern k5_mutex_t gssint_krb5_keytab_lock;\n#endif /* LEAN_CLIENT */\n\n/** helper functions **/\n\nOM_uint32 kg_get_defcred\n(OM_uint32 *minor_status,\n gss_cred_id_t *cred);\n\nkrb5_error_code kg_checksum_channel_bindings\n(krb5_context context, gss_channel_bindings_t cb,\n krb5_checksum *cksum);\n\nkrb5_error_code kg_make_seq_num (krb5_context context,\n                                 krb5_key key,\n                                 int direction, krb5_ui_4 seqnum, unsigned char *cksum,\n                                 unsigned char *buf);\n\nkrb5_error_code kg_get_seq_num (krb5_context context,\n                                krb5_key key,\n                                unsigned char *cksum, unsigned char *buf, int *direction,\n                                krb5_ui_4 *seqnum);\n\nkrb5_error_code kg_make_seed (krb5_context context,\n                              krb5_key key,\n                              unsigned char *seed);\n\nkrb5_error_code\nkg_setup_keys(krb5_context context,\n              krb5_gss_ctx_id_rec *ctx,\n              krb5_key subkey,\n              krb5_cksumtype *cksumtype);\n\nint kg_confounder_size (krb5_context context, krb5_enctype enctype);\n\nkrb5_error_code kg_make_confounder (krb5_context context,\n                                    krb5_enctype enctype, unsigned char *buf);\n\nkrb5_error_code kg_encrypt (krb5_context context,\n                            krb5_key key, int usage,\n                            krb5_pointer iv,\n                            krb5_const_pointer in,\n                            krb5_pointer out,\n                            unsigned int length);\n\n/* Encrypt length bytes at ptr in place, with the given key and usage.  If\n * iv is not NULL, use it as the cipher state. */\nkrb5_error_code kg_encrypt_inplace(krb5_context context, krb5_key key,\n                                   int usage, krb5_pointer iv,\n                                   krb5_pointer ptr, unsigned int length);\n\nkrb5_error_code kg_encrypt_iov (krb5_context context,\n                                int proto, int dce_style,\n                                size_t ec, size_t rrc,\n                                krb5_key key, int usage,\n                                krb5_pointer iv,\n                                gss_iov_buffer_desc *iov,\n                                int iov_count);\n\nkrb5_error_code\nkg_arcfour_docrypt (const krb5_keyblock *keyblock, int usage,\n                    const unsigned char *kd_data, size_t kd_data_len,\n                    const unsigned char *input_buf, size_t input_len,\n                    unsigned char *output_buf);\n\nkrb5_error_code\nkg_arcfour_docrypt_iov (krb5_context context,\n                        const krb5_keyblock *keyblock, int usage,\n                        const unsigned char *kd_data, size_t kd_data_len,\n                        gss_iov_buffer_desc *iov,\n                        int iov_count);\n\nkrb5_error_code kg_decrypt (krb5_context context,\n                            krb5_key key,  int usage,\n                            krb5_pointer iv,\n                            krb5_const_pointer in,\n                            krb5_pointer out,\n                            unsigned int length);\n\nkrb5_error_code kg_decrypt_iov (krb5_context context,\n                                int proto, int dce_style,\n                                size_t ec, size_t rrc,\n                                krb5_key key,  int usage,\n                                krb5_pointer iv,\n                                gss_iov_buffer_desc *iov,\n                                int iov_count);\n\nOM_uint32 kg_seal (OM_uint32 *minor_status,\n                   gss_ctx_id_t context_handle,\n                   int conf_req_flag,\n                   gss_qop_t qop_req,\n                   gss_buffer_t input_message_buffer,\n                   int *conf_state,\n                   gss_buffer_t output_message_buffer,\n                   int toktype);\n\nOM_uint32 kg_unseal (OM_uint32 *minor_status,\n                     gss_ctx_id_t context_handle,\n                     gss_buffer_t input_token_buffer,\n                     gss_buffer_t message_buffer,\n                     int *conf_state,\n                     gss_qop_t *qop_state,\n                     int toktype);\n\nOM_uint32 kg_seal_size (OM_uint32 *minor_status,\n                        gss_ctx_id_t context_handle,\n                        int conf_req_flag,\n                        gss_qop_t qop_req,\n                        OM_uint32 output_size,\n                        OM_uint32 *input_size);\n\nkrb5_error_code kg_ctx_size (krb5_context kcontext,\n                             krb5_pointer arg,\n                             size_t *sizep);\n\nkrb5_error_code kg_ctx_externalize (krb5_context kcontext,\n                                    krb5_pointer arg,\n                                    krb5_octet **buffer,\n                                    size_t *lenremain);\n\nkrb5_error_code kg_ctx_internalize (krb5_context kcontext,\n                                    krb5_pointer *argp,\n                                    krb5_octet **buffer,\n                                    size_t *lenremain);\n\nOM_uint32 kg_sync_ccache_name (krb5_context context, OM_uint32 *minor_status);\n\nOM_uint32 kg_caller_provided_ccache_name (OM_uint32 *minor_status,\n                                          int *out_caller_provided_name);\n\nOM_uint32 kg_get_ccache_name (OM_uint32 *minor_status,\n                              const char **out_name);\n\nOM_uint32 kg_set_ccache_name (OM_uint32 *minor_status,\n                              const char *name);\n\n/* AEAD */\n\nkrb5_error_code gss_krb5int_make_seal_token_v3_iov(krb5_context context,\n                           krb5_gss_ctx_id_rec *ctx,\n                           int conf_req_flag,\n                           int *conf_state,\n                           gss_iov_buffer_desc *iov,\n                           int iov_count,\n                           int toktype);\n\nOM_uint32 gss_krb5int_unseal_v3_iov(krb5_context context,\n                          OM_uint32 *minor_status,\n                          krb5_gss_ctx_id_rec *ctx,\n                          gss_iov_buffer_desc *iov,\n                          int iov_count,\n                          int *conf_state,\n                          gss_qop_t *qop_state,\n                          int toktype);\n\ngss_iov_buffer_t kg_locate_iov (gss_iov_buffer_desc *iov,\n              int iov_count,\n              OM_uint32 type);\n\ngss_iov_buffer_t kg_locate_header_iov(gss_iov_buffer_desc *iov, int iov_count,\n                                      int toktype);\n\nvoid kg_iov_msglen(gss_iov_buffer_desc *iov,\n              int iov_count,\n              size_t *data_length,\n              size_t *assoc_data_length);\n\nvoid kg_release_iov(gss_iov_buffer_desc *iov,\n               int iov_count);\n\nkrb5_error_code kg_make_checksum_iov_v1(krb5_context context,\n                krb5_cksumtype type,\n                size_t token_cksum_len,\n                krb5_key seq,\n                krb5_key enc, /* for conf len */\n                krb5_keyusage sign_usage,\n                gss_iov_buffer_desc *iov,\n                int iov_count,\n                int toktype,\n                krb5_checksum *checksum);\n\nkrb5_error_code kg_make_checksum_iov_v3(krb5_context context,\n                krb5_cksumtype type,\n                size_t rrc,\n                krb5_key key,\n                krb5_keyusage sign_usage,\n                gss_iov_buffer_desc *iov,\n                int iov_count,\n                int toktype);\n\nkrb5_error_code kg_verify_checksum_iov_v3(krb5_context context,\n                krb5_cksumtype type,\n                size_t rrc,\n                krb5_key key,\n                krb5_keyusage sign_usage,\n                gss_iov_buffer_desc *iov,\n                int iov_count,\n                int toktype,\n                krb5_boolean *valid);\n\nOM_uint32 kg_seal_iov (OM_uint32 *minor_status,\n            gss_ctx_id_t context_handle,\n            int conf_req_flag,\n            gss_qop_t qop_req,\n            int *conf_state,\n            gss_iov_buffer_desc *iov,\n            int iov_count,\n            int toktype);\n\nOM_uint32 kg_unseal_iov (OM_uint32 *minor_status,\n            gss_ctx_id_t context_handle,\n            int *conf_state,\n            gss_qop_t *qop_state,\n            gss_iov_buffer_desc *iov,\n            int iov_count,\n            int toktype);\n\nOM_uint32 kg_seal_iov_length(OM_uint32 *minor_status,\n           gss_ctx_id_t context_handle,\n           int conf_req_flag,\n           gss_qop_t qop_req,\n           int *conf_state,\n           gss_iov_buffer_desc *iov,\n           int iov_count,\n           int toktype);\n\nkrb5_cryptotype kg_translate_flag_iov(OM_uint32 type);\n\nOM_uint32 kg_fixup_padding_iov(OM_uint32 *minor_status,\n        gss_iov_buffer_desc *iov,\n        int iov_count);\n\nkrb5_boolean kg_integ_only_iov(gss_iov_buffer_desc *iov, int iov_count);\n\nkrb5_error_code kg_allocate_iov(gss_iov_buffer_t iov, size_t size);\n\nkrb5_error_code\nkrb5_to_gss_cred(krb5_context context,\n                 krb5_creds *creds,\n                 krb5_gss_cred_id_t *out_cred);\n\nkrb5_boolean\nkg_cred_time_to_refresh(krb5_context context, krb5_gss_cred_id_rec *cred);\n\nvoid\nkg_cred_set_initial_refresh(krb5_context context, krb5_gss_cred_id_rec *cred,\n                            krb5_ticket_times *times);\n\nOM_uint32\nkg_cred_resolve(OM_uint32 *minor_status, krb5_context context,\n                gss_cred_id_t cred_handle, gss_name_t target_name);\n\n/** declarations of internal name mechanism functions **/\n\nOM_uint32 KRB5_CALLCONV krb5_gss_acquire_cred\n(OM_uint32*,       /* minor_status */\n gss_name_t,       /* desired_name */\n OM_uint32,        /* time_req */\n gss_OID_set,      /* desired_mechs */\n gss_cred_usage_t, /* cred_usage */\n gss_cred_id_t*,   /* output_cred_handle */\n gss_OID_set*,     /* actual_mechs */\n OM_uint32*        /* time_rec */\n);\n\nOM_uint32 KRB5_CALLCONV iakerb_gss_acquire_cred\n(OM_uint32*,       /* minor_status */\n gss_name_t,       /* desired_name */\n OM_uint32,        /* time_req */\n gss_OID_set,      /* desired_mechs */\n gss_cred_usage_t, /* cred_usage */\n gss_cred_id_t*,   /* output_cred_handle */\n gss_OID_set*,     /* actual_mechs */\n OM_uint32*        /* time_rec */\n);\n\nOM_uint32 KRB5_CALLCONV\nkrb5_gss_acquire_cred_with_password(\n    OM_uint32 *minor_status,\n    const gss_name_t desired_name,\n    const gss_buffer_t password,\n    OM_uint32 time_req,\n    const gss_OID_set desired_mechs,\n    int cred_usage,\n    gss_cred_id_t *output_cred_handle,\n    gss_OID_set *actual_mechs,\n    OM_uint32 *time_rec);\n\nOM_uint32 KRB5_CALLCONV\niakerb_gss_acquire_cred_with_password(\n    OM_uint32 *minor_status,\n    const gss_name_t desired_name,\n    const gss_buffer_t password,\n    OM_uint32 time_req,\n    const gss_OID_set desired_mechs,\n    int cred_usage,\n    gss_cred_id_t *output_cred_handle,\n    gss_OID_set *actual_mechs,\n    OM_uint32 *time_rec);\n\nOM_uint32 KRB5_CALLCONV krb5_gss_release_cred\n(OM_uint32*,       /* minor_status */\n gss_cred_id_t*    /* cred_handle */\n);\n\nOM_uint32 KRB5_CALLCONV krb5_gss_init_sec_context\n(OM_uint32*,       /* minor_status */\n gss_cred_id_t,    /* claimant_cred_handle */\n gss_ctx_id_t*,    /* context_handle */\n gss_name_t,       /* target_name */\n gss_OID,          /* mech_type */\n OM_uint32,        /* req_flags */\n OM_uint32,        /* time_req */\n gss_channel_bindings_t,\n /* input_chan_bindings */\n gss_buffer_t,     /* input_token */\n gss_OID*,         /* actual_mech_type */\n gss_buffer_t,     /* output_token */\n OM_uint32*,       /* ret_flags */\n OM_uint32*        /* time_rec */\n);\n\nOM_uint32 krb5_gss_init_sec_context_ext\n(OM_uint32*,       /* minor_status */\n gss_cred_id_t,    /* claimant_cred_handle */\n gss_ctx_id_t*,    /* context_handle */\n gss_name_t,       /* target_name */\n gss_OID,          /* mech_type */\n OM_uint32,        /* req_flags */\n OM_uint32,        /* time_req */\n gss_channel_bindings_t,\n /* input_chan_bindings */\n gss_buffer_t,     /* input_token */\n gss_OID*,         /* actual_mech_type */\n gss_buffer_t,     /* output_token */\n OM_uint32*,       /* ret_flags */\n OM_uint32*,       /* time_rec */\n krb5_gss_ctx_ext_t /* exts */\n);\n\n#ifndef LEAN_CLIENT\nOM_uint32 KRB5_CALLCONV krb5_gss_accept_sec_context\n(OM_uint32*,       /* minor_status */\n gss_ctx_id_t*,    /* context_handle */\n gss_cred_id_t,    /* verifier_cred_handle */\n gss_buffer_t,     /* input_token_buffer */\n gss_channel_bindings_t,\n /* input_chan_bindings */\n gss_name_t*,      /* src_name */\n gss_OID*,         /* mech_type */\n gss_buffer_t,     /* output_token */\n OM_uint32*,       /* ret_flags */\n OM_uint32*,       /* time_rec */\n gss_cred_id_t*    /* delegated_cred_handle */\n);\n\nOM_uint32 KRB5_CALLCONV krb5_gss_accept_sec_context_ext\n(OM_uint32*,       /* minor_status */\n gss_ctx_id_t*,    /* context_handle */\n gss_cred_id_t,    /* verifier_cred_handle */\n gss_buffer_t,     /* input_token_buffer */\n gss_channel_bindings_t,\n /* input_chan_bindings */\n gss_name_t*,      /* src_name */\n gss_OID*,         /* mech_type */\n gss_buffer_t,     /* output_token */\n OM_uint32*,       /* ret_flags */\n OM_uint32*,       /* time_rec */\n gss_cred_id_t*,   /* delegated_cred_handle */\n krb5_gss_ctx_ext_t/*exts */\n);\n#endif /* LEAN_CLIENT */\n\nOM_uint32 KRB5_CALLCONV krb5_gss_process_context_token\n(OM_uint32*,       /* minor_status */\n gss_ctx_id_t,     /* context_handle */\n gss_buffer_t      /* token_buffer */\n);\n\nOM_uint32 KRB5_CALLCONV krb5_gss_delete_sec_context\n(OM_uint32*,       /* minor_status */\n gss_ctx_id_t*,    /* context_handle */\n gss_buffer_t      /* output_token */\n);\n\nOM_uint32 KRB5_CALLCONV krb5_gss_context_time\n(OM_uint32*,       /* minor_status */\n gss_ctx_id_t,     /* context_handle */\n OM_uint32*        /* time_rec */\n);\n\nOM_uint32 KRB5_CALLCONV krb5_gss_display_status\n(OM_uint32*,       /* minor_status */\n OM_uint32,        /* status_value */\n int,              /* status_type */\n gss_OID,          /* mech_type */\n OM_uint32*,       /* message_context */\n gss_buffer_t      /* status_string */\n);\n\nOM_uint32 KRB5_CALLCONV krb5_gss_indicate_mechs\n(OM_uint32*,       /* minor_status */\n gss_OID_set*      /* mech_set */\n);\n\nOM_uint32 KRB5_CALLCONV krb5_gss_compare_name\n(OM_uint32*,       /* minor_status */\n gss_name_t,       /* name1 */\n gss_name_t,       /* name2 */\n int*              /* name_equal */\n);\n\nOM_uint32 KRB5_CALLCONV krb5_gss_display_name\n(OM_uint32*,      /* minor_status */\n gss_name_t,      /* input_name */\n gss_buffer_t,    /* output_name_buffer */\n gss_OID*         /* output_name_type */\n);\n\n\nOM_uint32 KRB5_CALLCONV krb5_gss_import_name\n(OM_uint32*,       /* minor_status */\n gss_buffer_t,     /* input_name_buffer */\n gss_OID,          /* input_name_type */\n gss_name_t*       /* output_name */\n);\n\nOM_uint32 KRB5_CALLCONV krb5_gss_release_name\n(OM_uint32*,       /* minor_status */\n gss_name_t*       /* input_name */\n);\n\nOM_uint32 KRB5_CALLCONV krb5_gss_inquire_cred\n(OM_uint32 *,      /* minor_status */\n gss_cred_id_t,    /* cred_handle */\n gss_name_t *,     /* name */\n OM_uint32 *,      /* lifetime */\n gss_cred_usage_t*,/* cred_usage */\n gss_OID_set *     /* mechanisms */\n);\n\nOM_uint32 KRB5_CALLCONV krb5_gss_inquire_context\n(OM_uint32*,       /* minor_status */\n gss_ctx_id_t,     /* context_handle */\n gss_name_t*,      /* initiator_name */\n gss_name_t*,      /* acceptor_name */\n OM_uint32*,       /* lifetime_rec */\n gss_OID*,         /* mech_type */\n OM_uint32*,       /* ret_flags */\n int*,             /* locally_initiated */\n int*              /* open */\n);\n\n/* New V2 entry points */\nOM_uint32 KRB5_CALLCONV krb5_gss_get_mic\n(OM_uint32 *,           /* minor_status */\n gss_ctx_id_t,               /* context_handle */\n gss_qop_t,                  /* qop_req */\n gss_buffer_t,               /* message_buffer */\n gss_buffer_t                /* message_token */\n);\n\nOM_uint32 KRB5_CALLCONV krb5_gss_get_mic_iov\n(OM_uint32 *,                /* minor_status */\n gss_ctx_id_t,               /* context_handle */\n gss_qop_t,                  /* qop_req */\n gss_iov_buffer_desc *,      /* iov */\n int                         /* iov_count */\n);\n\nOM_uint32 KRB5_CALLCONV krb5_gss_get_mic_iov_length\n(OM_uint32 *,                /* minor_status */\n gss_ctx_id_t,               /* context_handle */\n gss_qop_t,                  /* qop_req */\n gss_iov_buffer_desc *,      /* iov */\n int                         /* iov_count */\n);\n\nOM_uint32 KRB5_CALLCONV krb5_gss_verify_mic\n(OM_uint32 *,           /* minor_status */\n gss_ctx_id_t,               /* context_handle */\n gss_buffer_t,               /* message_buffer */\n gss_buffer_t,               /* message_token */\n gss_qop_t *                 /* qop_state */\n);\n\nOM_uint32 KRB5_CALLCONV krb5_gss_verify_mic_iov\n(OM_uint32 *,                /* minor_status */\n gss_ctx_id_t,               /* context_handle */\n gss_qop_t *,                /* qop_state */\n gss_iov_buffer_desc *,      /* iov */\n int                         /* iov_count */\n);\n\nOM_uint32 KRB5_CALLCONV krb5_gss_wrap\n(OM_uint32 *,           /* minor_status */\n gss_ctx_id_t,               /* context_handle */\n int,                        /* conf_req_flag */\n gss_qop_t,                  /* qop_req */\n gss_buffer_t,               /* input_message_buffer */\n int *,                      /* conf_state */\n gss_buffer_t                /* output_message_buffer */\n);\n\nOM_uint32 KRB5_CALLCONV krb5_gss_wrap_iov\n(OM_uint32 *,           /* minor_status */\n gss_ctx_id_t,              /* context_handle */\n int,                       /* conf_req_flag */\n gss_qop_t,                 /* qop_req */\n int *,                     /* conf_state */\n gss_iov_buffer_desc *,     /* iov */\n int                        /* iov_count */\n);\n\nOM_uint32 KRB5_CALLCONV krb5_gss_wrap_iov_length\n(OM_uint32 *,           /* minor_status */\n gss_ctx_id_t,              /* context_handle */\n int,                       /* conf_req_flag */\n gss_qop_t,                 /* qop_req */\n int *,                     /* conf_state */\n gss_iov_buffer_desc *,     /* iov */\n int                        /* iov_count */\n);\n\nOM_uint32 KRB5_CALLCONV krb5_gss_unwrap\n(OM_uint32 *,           /* minor_status */\n gss_ctx_id_t,               /* context_handle */\n gss_buffer_t,               /* input_message_buffer */\n gss_buffer_t,               /* output_message_buffer */\n int *,                      /* conf_state */\n gss_qop_t *                 /* qop_state */\n);\n\nOM_uint32 KRB5_CALLCONV krb5_gss_unwrap_iov\n(OM_uint32 *,           /* minor_status */\n gss_ctx_id_t,              /* context_handle */\n int *,                     /* conf_state */\n gss_qop_t *,               /* qop_state */\n gss_iov_buffer_desc *,     /* iov */\n int                        /* iov_count */\n);\n\nOM_uint32 KRB5_CALLCONV krb5_gss_wrap_size_limit\n(OM_uint32 *,           /* minor_status */\n gss_ctx_id_t,               /* context_handle */\n int,                        /* conf_req_flag */\n gss_qop_t,                  /* qop_req */\n OM_uint32,                  /* req_output_size */\n OM_uint32 *                 /* max_input_size */\n);\n\nOM_uint32 KRB5_CALLCONV krb5_gss_import_name_object\n(OM_uint32 *,           /* minor_status */\n void *,                     /* input_name */\n gss_OID,                    /* input_name_type */\n gss_name_t *                /* output_name */\n);\n\nOM_uint32 KRB5_CALLCONV krb5_gss_export_name_object\n(OM_uint32 *,           /* minor_status */\n gss_name_t,                 /* input_name */\n gss_OID,                    /* desired_name_type */\n void * *                    /* output_name */\n);\n\nOM_uint32 KRB5_CALLCONV krb5_gss_inquire_cred_by_mech\n(OM_uint32  *,          /* minor_status */\n gss_cred_id_t,              /* cred_handle */\n gss_OID,                    /* mech_type */\n gss_name_t *,               /* name */\n OM_uint32 *,                /* initiator_lifetime */\n OM_uint32 *,                /* acceptor_lifetime */\n gss_cred_usage_t *          /* cred_usage */\n);\n#ifndef LEAN_CLIENT\nOM_uint32 KRB5_CALLCONV krb5_gss_export_sec_context\n(OM_uint32 *,           /* minor_status */\n gss_ctx_id_t *,             /* context_handle */\n gss_buffer_t                /* interprocess_token */\n);\n\nOM_uint32 KRB5_CALLCONV krb5_gss_import_sec_context\n(OM_uint32 *,           /* minor_status */\n gss_buffer_t,               /* interprocess_token */\n gss_ctx_id_t *              /* context_handle */\n);\n#endif /* LEAN_CLIENT */\n\nkrb5_error_code krb5_gss_ser_init(krb5_context);\n\nOM_uint32 krb5_gss_release_oid\n(OM_uint32 *,           /* minor_status */\n gss_OID *                   /* oid */\n);\n\nOM_uint32 KRB5_CALLCONV krb5_gss_internal_release_oid\n(OM_uint32 *,           /* minor_status */\n gss_OID *                   /* oid */\n);\n\nOM_uint32 KRB5_CALLCONV krb5_gss_inquire_names_for_mech\n(OM_uint32 *,           /* minor_status */\n gss_OID,                    /* mechanism */\n gss_OID_set *               /* name_types */\n);\n\nOM_uint32 krb5_gss_canonicalize_name\n(OM_uint32  *,          /* minor_status */\n const gss_name_t,           /* input_name */\n const gss_OID,              /* mech_type */\n gss_name_t *                /* output_name */\n);\n\nOM_uint32 KRB5_CALLCONV krb5_gss_export_name\n(OM_uint32  *,          /* minor_status */\n const gss_name_t,           /* input_name */\n gss_buffer_t                /* exported_name */\n);\n\nOM_uint32 KRB5_CALLCONV krb5_gss_duplicate_name\n(OM_uint32  *,          /* minor_status */\n const gss_name_t,           /* input_name */\n gss_name_t *                /* dest_name */\n);\n\nOM_uint32 krb5_gss_validate_cred\n(OM_uint32 *,           /* minor_status */\n gss_cred_id_t               /* cred */\n);\n\nOM_uint32 KRB5_CALLCONV krb5_gss_acquire_cred_impersonate_name(\n    OM_uint32 *,            /* minor_status */\n    const gss_cred_id_t,    /* impersonator_cred_handle */\n    const gss_name_t,       /* desired_name */\n    OM_uint32,              /* time_req */\n    const gss_OID_set,      /* desired_mechs */\n    gss_cred_usage_t,       /* cred_usage */\n    gss_cred_id_t *,        /* output_cred_handle */\n    gss_OID_set *,          /* actual_mechs */\n    OM_uint32 *);           /* time_rec */\n\nOM_uint32\nkrb5_gss_validate_cred_1(OM_uint32 * /* minor_status */,\n                         gss_cred_id_t /* cred_handle */,\n                         krb5_context /* context */);\n\ngss_OID krb5_gss_convert_static_mech_oid(gss_OID oid);\n\nkrb5_error_code gss_krb5int_make_seal_token_v3(krb5_context,\n                                               krb5_gss_ctx_id_rec *,\n                                               const gss_buffer_desc *,\n                                               gss_buffer_t,\n                                               int, int);\n\nOM_uint32 gss_krb5int_unseal_token_v3(krb5_context *contextptr,\n                                      OM_uint32 *minor_status,\n                                      krb5_gss_ctx_id_rec *ctx,\n                                      unsigned char *ptr,\n                                      unsigned int bodysize,\n                                      gss_buffer_t message_buffer,\n                                      int *conf_state, gss_qop_t *qop_state,\n                                      int toktype);\n\nint gss_krb5int_rotate_left (void *ptr, size_t bufsiz, size_t rc);\n\n/* naming_exts.c */\n#define KG_INIT_NAME_NO_COPY 0x1\n\nkrb5_error_code\nkg_init_name(krb5_context context, krb5_principal principal,\n             char *service, char *host, krb5_authdata_context ad_context,\n             krb5_flags flags, krb5_gss_name_t *name);\n\nkrb5_error_code\nkg_release_name(krb5_context context, krb5_gss_name_t *name);\n\nkrb5_error_code\nkg_duplicate_name(krb5_context context, const krb5_gss_name_t src,\n                  krb5_gss_name_t *dst);\n\nkrb5_boolean\nkg_compare_name(krb5_context context,\n                krb5_gss_name_t name1,\n                krb5_gss_name_t name2);\n\nkrb5_boolean\nkg_acceptor_princ(krb5_context context, krb5_gss_name_t name,\n                  krb5_principal *princ_out);\n\nOM_uint32 KRB5_CALLCONV\nkrb5_gss_display_name_ext(OM_uint32 *minor_status,\n                          gss_name_t name,\n                          gss_OID display_as_name_type,\n                          gss_buffer_t display_name);\n\nOM_uint32 KRB5_CALLCONV\nkrb5_gss_inquire_name(OM_uint32 *minor_status,\n                      gss_name_t name,\n                      int *name_is_MN,\n                      gss_OID *MN_mech,\n                      gss_buffer_set_t *attrs);\n\nOM_uint32 KRB5_CALLCONV\nkrb5_gss_get_name_attribute(OM_uint32 *minor_status,\n                            gss_name_t name,\n                            gss_buffer_t attr,\n                            int *authenticated,\n                            int *complete,\n                            gss_buffer_t value,\n                            gss_buffer_t display_value,\n                            int *more);\n\nOM_uint32 KRB5_CALLCONV\nkrb5_gss_set_name_attribute(OM_uint32 *minor_status,\n                            gss_name_t name,\n                            int complete,\n                            gss_buffer_t attr,\n                            gss_buffer_t value);\n\nOM_uint32 KRB5_CALLCONV\nkrb5_gss_delete_name_attribute(OM_uint32 *minor_status,\n                               gss_name_t name,\n                               gss_buffer_t attr);\n\nOM_uint32 KRB5_CALLCONV\nkrb5_gss_export_name_composite(OM_uint32 *minor_status,\n                               gss_name_t name,\n                               gss_buffer_t exp_composite_name);\n\nOM_uint32 KRB5_CALLCONV\nkrb5_gss_map_name_to_any(OM_uint32 *minor_status,\n                         gss_name_t name,\n                         int authenticated,\n                         gss_buffer_t type_id,\n                         gss_any_t *output);\n\nOM_uint32 KRB5_CALLCONV\nkrb5_gss_release_any_name_mapping(OM_uint32 *minor_status,\n                                  gss_name_t name,\n                                  gss_buffer_t type_id,\n                                  gss_any_t *input);\n\nOM_uint32 KRB5_CALLCONV\nkrb5_gss_pseudo_random(OM_uint32 *minor_status,\n                       gss_ctx_id_t context,\n                       int prf_key,\n                       const gss_buffer_t prf_in,\n                       ssize_t desired_output_len,\n                       gss_buffer_t prf_out);\n\nOM_uint32 KRB5_CALLCONV\nkrb5_gss_store_cred(OM_uint32 *minor_status,\n                    gss_cred_id_t input_cred_handle,\n                    gss_cred_usage_t cred_usage,\n                    const gss_OID desired_mech,\n                    OM_uint32 overwrite_cred,\n                    OM_uint32 default_cred,\n                    gss_OID_set *elements_stored,\n                    gss_cred_usage_t *cred_usage_stored);\n\n/* s4u_gss_glue.c */\nOM_uint32\nkg_compose_deleg_cred(OM_uint32 *minor_status,\n                      krb5_gss_cred_id_t impersonator_cred,\n                      krb5_creds *subject_creds,\n                      OM_uint32 time_req,\n                      krb5_gss_cred_id_t *output_cred,\n                      OM_uint32 *time_rec,\n                      krb5_context context);\n\n/*\n * These take unglued krb5-mech-specific contexts.\n */\n\n#define GSS_KRB5_GET_TKT_FLAGS_OID_LENGTH 11\n#define GSS_KRB5_GET_TKT_FLAGS_OID \"\\x2a\\x86\\x48\\x86\\xf7\\x12\\x01\\x02\\x02\\x05\\x01\"\n\nOM_uint32 gss_krb5int_get_tkt_flags\n(OM_uint32 *minor_status,\n const gss_ctx_id_t context_handle,\n const gss_OID desired_object,\n gss_buffer_set_t *data_set);\n\n#define GSS_KRB5_COPY_CCACHE_OID_LENGTH 11\n#define GSS_KRB5_COPY_CCACHE_OID \"\\x2a\\x86\\x48\\x86\\xf7\\x12\\x01\\x02\\x02\\x05\\x02\"\n\nOM_uint32 gss_krb5int_copy_ccache\n(OM_uint32 *minor_status,\n gss_cred_id_t *cred_handle,\n const gss_OID desired_oid,\n const gss_buffer_t value);\n\n#define GSS_KRB5_CCACHE_NAME_OID_LENGTH 11\n#define GSS_KRB5_CCACHE_NAME_OID \"\\x2a\\x86\\x48\\x86\\xf7\\x12\\x01\\x02\\x02\\x05\\x03\"\n\nstruct krb5_gss_ccache_name_req {\n    const char *name;\n    const char **out_name;\n};\n\nOM_uint32\ngss_krb5int_ccache_name(OM_uint32 *minor_status, const gss_OID, const gss_OID,\n                        const gss_buffer_t);\n\n#define GSS_KRB5_INQ_SSPI_SESSION_KEY_OID_LENGTH 11\n#define GSS_KRB5_INQ_SSPI_SESSION_KEY_OID \"\\x2a\\x86\\x48\\x86\\xf7\\x12\\x01\\x02\\x02\\x05\\x05\"\n\nOM_uint32\ngss_krb5int_inq_session_key(OM_uint32 *, const gss_ctx_id_t, const gss_OID, gss_buffer_set_t *);\n\n#define GSS_KRB5_SET_ALLOWABLE_ENCTYPES_OID_LENGTH 11\n#define GSS_KRB5_SET_ALLOWABLE_ENCTYPES_OID \"\\x2a\\x86\\x48\\x86\\xf7\\x12\\x01\\x02\\x02\\x05\\x04\"\n\nstruct krb5_gss_set_allowable_enctypes_req {\n    OM_uint32 num_ktypes;\n    krb5_enctype *ktypes;\n};\n\nOM_uint32\ngss_krb5int_set_allowable_enctypes(OM_uint32 *minor_status,\n                                   gss_cred_id_t *cred,\n                                   const gss_OID desired_oid,\n                                   const gss_buffer_t value);\n\n#define GSS_KRB5_EXPORT_LUCID_SEC_CONTEXT_OID_LENGTH 11\n#define GSS_KRB5_EXPORT_LUCID_SEC_CONTEXT_OID \"\\x2a\\x86\\x48\\x86\\xf7\\x12\\x01\\x02\\x02\\x05\\x06\"\n\nOM_uint32\ngss_krb5int_export_lucid_sec_context(OM_uint32 *minor_status,\n                                     const gss_ctx_id_t context_handle,\n                                     const gss_OID desired_object,\n                                     gss_buffer_set_t *data_set);\n\n#define GSS_KRB5_FREE_LUCID_SEC_CONTEXT_OID_LENGTH 11\n#define GSS_KRB5_FREE_LUCID_SEC_CONTEXT_OID \"\\x2a\\x86\\x48\\x86\\xf7\\x12\\x01\\x02\\x02\\x05\\x07\"\n\nOM_uint32\ngss_krb5int_free_lucid_sec_context(OM_uint32 *, const gss_OID,\n                                   const gss_OID, gss_buffer_t);\n\nextern k5_mutex_t kg_kdc_flag_mutex;\nkrb5_error_code krb5_gss_init_context (krb5_context *ctxp);\n\n#define GSS_KRB5_USE_KDC_CONTEXT_OID_LENGTH 11\n#define GSS_KRB5_USE_KDC_CONTEXT_OID \"\\x2a\\x86\\x48\\x86\\xf7\\x12\\x01\\x02\\x02\\x05\\x08\"\n\nOM_uint32 krb5int_gss_use_kdc_context(OM_uint32 *, const gss_OID,\n                                      const gss_OID, gss_buffer_t);\n\nkrb5_error_code krb5_gss_use_kdc_context(void);\n\n#define GSS_KRB5_REGISTER_ACCEPTOR_IDENTITY_OID_LENGTH 11\n#define GSS_KRB5_REGISTER_ACCEPTOR_IDENTITY_OID \"\\x2a\\x86\\x48\\x86\\xf7\\x12\\x01\\x02\\x02\\x05\\x09\"\n\nOM_uint32\ngss_krb5int_register_acceptor_identity(OM_uint32 *, const gss_OID, const gss_OID, gss_buffer_t);\n\n#define GSS_KRB5_EXTRACT_AUTHZ_DATA_FROM_SEC_CONTEXT_OID_LENGTH 11\n#define GSS_KRB5_EXTRACT_AUTHZ_DATA_FROM_SEC_CONTEXT_OID \"\\x2a\\x86\\x48\\x86\\xf7\\x12\\x01\\x02\\x02\\x05\\x0a\"\n\nOM_uint32\ngss_krb5int_extract_authz_data_from_sec_context(OM_uint32 *minor_status,\n                                                const gss_ctx_id_t context_handle,\n                                                const gss_OID desired_object,\n                                                gss_buffer_set_t *ad_data);\n\n#define GSS_KRB5_SET_CRED_RCACHE_OID_LENGTH 11\n#define GSS_KRB5_SET_CRED_RCACHE_OID \"\\x2a\\x86\\x48\\x86\\xf7\\x12\\x01\\x02\\x02\\x05\\x0b\"\n\nOM_uint32\ngss_krb5int_set_cred_rcache(OM_uint32 *, gss_cred_id_t *, const gss_OID, const gss_buffer_t);\n\n#define GSS_KRB5_EXTRACT_AUTHTIME_FROM_SEC_CONTEXT_OID_LENGTH 11\n#define GSS_KRB5_EXTRACT_AUTHTIME_FROM_SEC_CONTEXT_OID \"\\x2a\\x86\\x48\\x86\\xf7\\x12\\x01\\x02\\x02\\x05\\x0c\"\n\nOM_uint32\ngss_krb5int_extract_authtime_from_sec_context(OM_uint32 *,\n                                              const gss_ctx_id_t,\n                                              const gss_OID,\n                                              gss_buffer_set_t *);\n\n#define GSS_KRB5_IMPORT_CRED_OID_LENGTH 11\n#define GSS_KRB5_IMPORT_CRED_OID \"\\x2a\\x86\\x48\\x86\\xf7\\x12\\x01\\x02\\x02\\x05\\x0d\"\n\nstruct krb5_gss_import_cred_req {\n    krb5_ccache id;\n    krb5_principal keytab_principal;\n    krb5_keytab keytab;\n};\n\nOM_uint32\ngss_krb5int_import_cred(OM_uint32 *minor_status,\n                        gss_cred_id_t *cred,\n                        const gss_OID desired_oid,\n                        const gss_buffer_t value);\n\n#ifdef _GSS_STATIC_LINK\nint gss_krb5int_lib_init(void);\nvoid gss_krb5int_lib_fini(void);\n#endif /* _GSS_STATIC_LINK */\n\nOM_uint32 gss_krb5int_initialize_library(void);\nvoid gss_krb5int_cleanup_library(void);\n\n/* For error message handling.  */\n/* Returns a shared string, not a private copy!  */\nextern char *\nkrb5_gss_get_error_message(OM_uint32 minor_code);\nextern void\nkrb5_gss_save_error_string(OM_uint32 minor_code, char *msg);\nextern void\nkrb5_gss_save_error_message(OM_uint32 minor_code, const char *format, ...)\n#if !defined(__cplusplus) && (__GNUC__ > 2)\n    __attribute__((__format__(__printf__, 2, 3)))\n#endif\n    ;\n    extern void\n    krb5_gss_save_error_info(OM_uint32 minor_code, krb5_context ctx);\n#define get_error_message krb5_gss_get_error_message\n#define save_error_string krb5_gss_save_error_string\n#define save_error_message krb5_gss_save_error_message\n#ifdef KRB5_KERNEL\n/* Error messages aren't needed in the kernel, so reduce dependencies. */\n#define save_error_info(x,y)\n#else\n#define save_error_info krb5_gss_save_error_info\n#endif\nextern void krb5_gss_delete_error_info(void *p);\n\n/* Prefix concatenated with Kerberos encryption type */\n#define GSS_KRB5_SESSION_KEY_ENCTYPE_OID_LENGTH 10\n#define GSS_KRB5_SESSION_KEY_ENCTYPE_OID  \"\\x2a\\x86\\x48\\x86\\xf7\\x12\\x01\\x02\\x02\\x04\"\n\n/* IAKERB */\n\nOM_uint32 KRB5_CALLCONV\niakerb_gss_init_sec_context(OM_uint32 *minor_status,\n                            gss_cred_id_t claimant_cred_handle,\n                            gss_ctx_id_t *context_handle,\n                            gss_name_t target_name,\n                            gss_OID mech_type,\n                            OM_uint32 req_flags,\n                            OM_uint32 time_req,\n                            gss_channel_bindings_t input_chan_bindings,\n                            gss_buffer_t input_token,\n                            gss_OID *actual_mech_type,\n                            gss_buffer_t output_token,\n                            OM_uint32 *ret_flags,\n                            OM_uint32 *time_rec);\n\nOM_uint32 KRB5_CALLCONV\niakerb_gss_accept_sec_context(OM_uint32 *minor_status,\n                              gss_ctx_id_t *context_handler,\n                              gss_cred_id_t verifier_cred_handle,\n                              gss_buffer_t input_token,\n                              gss_channel_bindings_t input_chan_bindings,\n                              gss_name_t *src_name,\n                              gss_OID *mech_type,\n                              gss_buffer_t output_token,\n                              OM_uint32 *ret_flags,\n                              OM_uint32 *time_rec,\n                              gss_cred_id_t *delegated_cred_handle);\n\nOM_uint32 KRB5_CALLCONV\niakerb_gss_delete_sec_context(OM_uint32 *minor_status,\n                              gss_ctx_id_t *context_handle,\n                              gss_buffer_t output_token);\n\nkrb5_error_code\niakerb_make_finished(krb5_context context,\n                     krb5_key key,\n                     const krb5_data *conv,\n                     krb5_data **finished);\n\nkrb5_error_code\niakerb_verify_finished(krb5_context context,\n                       krb5_key key,\n                       const krb5_data *conv,\n                       const krb5_data *finished);\n\n/*\n * Transfer contents of a krb5_data to a gss_buffer and invalidate the source\n * On unix, this is a simple pointer copy\n * On windows, memory is reallocated and copied.\n */\nstatic inline krb5_error_code\ndata_to_gss(krb5_data *input_k5data, gss_buffer_t output_buffer)\n{\n    krb5_error_code code = 0;\n    output_buffer->length = input_k5data->length;\n#if defined(_WIN32) || defined(DEBUG_GSSALLOC)\n    if (output_buffer->length > 0) {\n        output_buffer->value = gssalloc_malloc(output_buffer->length);\n        if (output_buffer->value)\n            memcpy(output_buffer->value, input_k5data->data, output_buffer->length);\n        else\n            code = ENOMEM;\n    } else {\n        output_buffer->value = NULL;\n    }\n    free(input_k5data->data);\n#else\n    output_buffer->value = input_k5data->data;\n#endif\n    *input_k5data = empty_data();\n    return code;\n}\n\n#define KRB5_GSS_EXTS_IAKERB_FINISHED 1\n\n\n/* Credential store extensions */\n\n#define KRB5_CS_CLI_KEYTAB_URN \"client_keytab\"\n#define KRB5_CS_KEYTAB_URN \"keytab\"\n#define KRB5_CS_CCACHE_URN \"ccache\"\n#define KRB5_CS_RCACHE_URN \"rcache\"\n\nOM_uint32\nkg_value_from_cred_store(gss_const_key_value_set_t cred_store,\n                         const char *type, const char **value);\n\nOM_uint32 KRB5_CALLCONV\nkrb5_gss_acquire_cred_from(\n    OM_uint32 *,               /* minor_status */\n    const gss_name_t,          /* desired_name */\n    OM_uint32,                 /* time_req */\n    const gss_OID_set,         /* desired_mechs */\n    gss_cred_usage_t,          /* cred_usage */\n    gss_const_key_value_set_t, /* cred_store */\n    gss_cred_id_t *,           /* output_cred_handle */\n    gss_OID_set *,             /* actual_mechs */\n    OM_uint32 *);              /* time_rec */\n\nOM_uint32 KRB5_CALLCONV\nkrb5_gss_store_cred_into(\n    OM_uint32 *,               /* minor_status */\n    gss_cred_id_t,             /* input_cred_handle */\n    gss_cred_usage_t,          /* input_usage */\n    const gss_OID,             /* desired_mech */\n    OM_uint32,                 /* overwrite_cred */\n    OM_uint32,                 /* default_cred */\n    gss_const_key_value_set_t, /* cred_store */\n    gss_OID_set *,             /* elements_stored */\n    gss_cred_usage_t *);       /* cred_usage_stored */\n\nOM_uint32 KRB5_CALLCONV\nkrb5_gss_export_cred(OM_uint32 *minor_status, gss_cred_id_t cred_handle,\n                     gss_buffer_t token);\n\nOM_uint32 KRB5_CALLCONV\nkrb5_gss_import_cred(OM_uint32 *minor_status, gss_buffer_t token,\n                     gss_cred_id_t *cred_handle);\n\n/* Magic string to identify exported krb5 GSS credentials.  Increment this if\n * the format changes. */\n#define CRED_EXPORT_MAGIC \"K5C1\"\n\n#endif /* _GSSAPIP_KRB5_H_ */\n", "/* -*- mode: c; c-basic-offset: 4; indent-tabs-mode: nil -*- */\n/*\n * Copyright 1993 by OpenVision Technologies, Inc.\n *\n * Permission to use, copy, modify, distribute, and sell this software\n * and its documentation for any purpose is hereby granted without fee,\n * provided that the above copyright notice appears in all copies and\n * that both that copyright notice and this permission notice appear in\n * supporting documentation, and that the name of OpenVision not be used\n * in advertising or publicity pertaining to distribution of the software\n * without specific, written prior permission. OpenVision makes no\n * representations about the suitability of this software for any\n * purpose.  It is provided \"as is\" without express or implied warranty.\n *\n * OPENVISION DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,\n * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO\n * EVENT SHALL OPENVISION BE LIABLE FOR ANY SPECIAL, INDIRECT OR\n * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF\n * USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\n * OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\n * PERFORMANCE OF THIS SOFTWARE.\n */\n\n/*\n * Copyright (C) 1998 by the FundsXpress, INC.\n *\n * All rights reserved.\n *\n * Export of this software from the United States of America may require\n * a specific license from the United States Government.  It is the\n * responsibility of any person or organization contemplating export to\n * obtain such a license before exporting.\n *\n * WITHIN THAT CONSTRAINT, permission to use, copy, modify, and\n * distribute this software and its documentation for any purpose and\n * without fee is hereby granted, provided that the above copyright\n * notice appear in all copies and that both that copyright notice and\n * this permission notice appear in supporting documentation, and that\n * the name of FundsXpress. not be used in advertising or publicity pertaining\n * to distribution of the software without specific, written prior\n * permission.  FundsXpress makes no representations about the suitability of\n * this software for any purpose.  It is provided \"as is\" without express\n * or implied warranty.\n *\n * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED\n * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.\n */\n/*\n * Copyright (c) 2006-2008, Novell, Inc.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *   * Redistributions of source code must retain the above copyright notice,\n *       this list of conditions and the following disclaimer.\n *   * Redistributions in binary form must reproduce the above copyright\n *       notice, this list of conditions and the following disclaimer in the\n *       documentation and/or other materials provided with the distribution.\n *   * The copyright holder's name is not used to endorse or promote products\n *       derived from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n/*\n * $Id$\n */\n\n\n/* For declaration of krb5_ser_context_init */\n#include \"k5-int.h\"\n#include \"gssapiP_krb5.h\"\n#include \"mglueP.h\"\n\n#ifndef NO_PASSWORD\n#include <pwd.h>\n#endif\n\n/** exported constants defined in gssapi_krb5{,_nx}.h **/\n\n/* these are bogus, but will compile */\n\n/*\n * The OID of the draft krb5 mechanism, assigned by IETF, is:\n *      iso(1) org(3) dod(5) internet(1) security(5)\n *      kerberosv5(2) = 1.3.5.1.5.2\n * The OID of the krb5_name type is:\n *      iso(1) member-body(2) US(840) mit(113554) infosys(1) gssapi(2)\n *      krb5(2) krb5_name(1) = 1.2.840.113554.1.2.2.1\n * The OID of the krb5_principal type is:\n *      iso(1) member-body(2) US(840) mit(113554) infosys(1) gssapi(2)\n *      krb5(2) krb5_principal(2) = 1.2.840.113554.1.2.2.2\n * The OID of the proposed standard krb5 mechanism is:\n *      iso(1) member-body(2) US(840) mit(113554) infosys(1) gssapi(2)\n *      krb5(2) = 1.2.840.113554.1.2.2\n * The OID of the proposed standard krb5 v2 mechanism is:\n *      iso(1) member-body(2) US(840) mit(113554) infosys(1) gssapi(2)\n *      krb5v2(3) = 1.2.840.113554.1.2.3\n * Provisionally reserved for Kerberos session key algorithm\n * identifiers is:\n *      iso(1) member-body(2) US(840) mit(113554) infosys(1) gssapi(2)\n *      krb5(2) krb5_enctype(4) = 1.2.840.113554.1.2.2.4\n * Provisionally reserved for Kerberos mechanism-specific APIs:\n *      iso(1) member-body(2) US(840) mit(113554) infosys(1) gssapi(2)\n *      krb5(2) krb5_gssapi_ext(5) = 1.2.840.113554.1.2.2.5\n */\n\n/*\n * Encoding rules: The first two values are encoded in one byte as 40\n * * value1 + value2.  Subsequent values are encoded base 128, most\n * significant digit first, with the high bit (\\200) set on all octets\n * except the last in each value's encoding.\n */\n\n#define NO_CI_FLAGS_X_OID_LENGTH 6\n#define NO_CI_FLAGS_X_OID \"\\x2a\\x85\\x70\\x2b\\x0d\\x1d\"\n\nconst gss_OID_desc krb5_gss_oid_array[] = {\n    /* this is the official, rfc-specified OID */\n    {GSS_MECH_KRB5_OID_LENGTH, GSS_MECH_KRB5_OID},\n    /* this pre-RFC mech OID */\n    {GSS_MECH_KRB5_OLD_OID_LENGTH, GSS_MECH_KRB5_OLD_OID},\n    /* this is the unofficial, incorrect mech OID emitted by MS */\n    {GSS_MECH_KRB5_WRONG_OID_LENGTH, GSS_MECH_KRB5_WRONG_OID},\n    /* IAKERB OID */\n    {GSS_MECH_IAKERB_OID_LENGTH, GSS_MECH_IAKERB_OID},\n    /* this is the v2 assigned OID */\n    {9, \"\\052\\206\\110\\206\\367\\022\\001\\002\\003\"},\n    /* these two are name type OID's */\n    /* 2.1.1. Kerberos Principal Name Form:  (rfc 1964)\n     * This name form shall be represented by the Object Identifier {iso(1)\n     * member-body(2) United States(840) mit(113554) infosys(1) gssapi(2)\n     * krb5(2) krb5_name(1)}.  The recommended symbolic name for this type\n     * is \"GSS_KRB5_NT_PRINCIPAL_NAME\". */\n    {10, \"\\052\\206\\110\\206\\367\\022\\001\\002\\002\\001\"},\n    /* gss_nt_krb5_principal.  Object identifier for a krb5_principal. Do not use. */\n    {10, \"\\052\\206\\110\\206\\367\\022\\001\\002\\002\\002\"},\n    {NO_CI_FLAGS_X_OID_LENGTH, NO_CI_FLAGS_X_OID},\n    { 0, 0 }\n};\n\nconst gss_OID_desc * const gss_mech_krb5              = krb5_gss_oid_array+0;\nconst gss_OID_desc * const gss_mech_krb5_old          = krb5_gss_oid_array+1;\nconst gss_OID_desc * const gss_mech_krb5_wrong        = krb5_gss_oid_array+2;\nconst gss_OID_desc * const gss_mech_iakerb            = krb5_gss_oid_array+3;\n\n\nconst gss_OID_desc * const gss_nt_krb5_name           = krb5_gss_oid_array+5;\nconst gss_OID_desc * const gss_nt_krb5_principal      = krb5_gss_oid_array+6;\nconst gss_OID_desc * const GSS_KRB5_NT_PRINCIPAL_NAME = krb5_gss_oid_array+5;\n\nconst gss_OID_desc * const GSS_KRB5_CRED_NO_CI_FLAGS_X = krb5_gss_oid_array+7;\n\nstatic const gss_OID_set_desc oidsets[] = {\n    {1, (gss_OID) krb5_gss_oid_array+0}, /* RFC OID */\n    {1, (gss_OID) krb5_gss_oid_array+1}, /* pre-RFC OID */\n    {3, (gss_OID) krb5_gss_oid_array+0}, /* all names for krb5 mech */\n    {4, (gss_OID) krb5_gss_oid_array+0}, /* all krb5 names and IAKERB */\n};\n\nconst gss_OID_set_desc * const gss_mech_set_krb5 = oidsets+0;\nconst gss_OID_set_desc * const gss_mech_set_krb5_old = oidsets+1;\nconst gss_OID_set_desc * const gss_mech_set_krb5_both = oidsets+2;\nconst gss_OID_set_desc * const kg_all_mechs = oidsets+3;\n\ng_set kg_vdb = G_SET_INIT;\n\n/** default credential support */\n\n/*\n * init_sec_context() will explicitly re-acquire default credentials,\n * so handling the expiration/invalidation condition here isn't needed.\n */\nOM_uint32\nkg_get_defcred(minor_status, cred)\n    OM_uint32 *minor_status;\n    gss_cred_id_t *cred;\n{\n    OM_uint32 major;\n\n    if ((major = krb5_gss_acquire_cred(minor_status,\n                                       (gss_name_t) NULL, GSS_C_INDEFINITE,\n                                       GSS_C_NULL_OID_SET, GSS_C_INITIATE,\n                                       cred, NULL, NULL)) && GSS_ERROR(major)) {\n        return(major);\n    }\n    *minor_status = 0;\n    return(GSS_S_COMPLETE);\n}\n\nOM_uint32\nkg_sync_ccache_name (krb5_context context, OM_uint32 *minor_status)\n{\n    OM_uint32 err = 0;\n\n    /*\n     * Sync up the context ccache name with the GSSAPI ccache name.\n     * If kg_ccache_name is NULL -- normal unless someone has called\n     * gss_krb5_ccache_name() -- then the system default ccache will\n     * be picked up and used by resetting the context default ccache.\n     * This is needed for platforms which support multiple ccaches.\n     */\n\n    if (!err) {\n        /* if NULL, resets the context default ccache */\n        err = krb5_cc_set_default_name(context,\n                                       (char *) k5_getspecific(K5_KEY_GSS_KRB5_CCACHE_NAME));\n    }\n\n    *minor_status = err;\n    return (*minor_status == 0) ? GSS_S_COMPLETE : GSS_S_FAILURE;\n}\n\n/* This function returns whether or not the caller set a cccache name.  Used by\n * gss_acquire_cred to figure out if the caller wants to only look at this\n * ccache or search the cache collection for the desired name */\nOM_uint32\nkg_caller_provided_ccache_name (OM_uint32 *minor_status,\n                                int *out_caller_provided_name)\n{\n    if (out_caller_provided_name) {\n        *out_caller_provided_name =\n            (k5_getspecific(K5_KEY_GSS_KRB5_CCACHE_NAME) != NULL);\n    }\n\n    *minor_status = 0;\n    return GSS_S_COMPLETE;\n}\n\nOM_uint32\nkg_get_ccache_name (OM_uint32 *minor_status, const char **out_name)\n{\n    const char *name = NULL;\n    OM_uint32 err = 0;\n    char *kg_ccache_name;\n\n    kg_ccache_name = k5_getspecific(K5_KEY_GSS_KRB5_CCACHE_NAME);\n\n    if (kg_ccache_name != NULL) {\n        name = strdup(kg_ccache_name);\n        if (name == NULL)\n            err = ENOMEM;\n    } else {\n        krb5_context context = NULL;\n\n        /* Reset the context default ccache (see text above), and then\n           retrieve it.  */\n        err = krb5_gss_init_context(&context);\n        if (!err)\n            err = krb5_cc_set_default_name (context, NULL);\n        if (!err) {\n            name = krb5_cc_default_name(context);\n            if (name) {\n                name = strdup(name);\n                if (name == NULL)\n                    err = ENOMEM;\n            }\n        }\n        if (err && context)\n            save_error_info(err, context);\n        if (context)\n            krb5_free_context(context);\n    }\n\n    if (!err) {\n        if (out_name) {\n            *out_name = name;\n        }\n    }\n\n    *minor_status = err;\n    return (*minor_status == 0) ? GSS_S_COMPLETE : GSS_S_FAILURE;\n}\n\nOM_uint32\nkg_set_ccache_name (OM_uint32 *minor_status, const char *name)\n{\n    char *new_name = NULL;\n    char *swap = NULL;\n    char *kg_ccache_name;\n    krb5_error_code kerr;\n\n    if (name) {\n        new_name = strdup(name);\n        if (new_name == NULL) {\n            *minor_status = ENOMEM;\n            return GSS_S_FAILURE;\n        }\n    }\n\n    kg_ccache_name = k5_getspecific(K5_KEY_GSS_KRB5_CCACHE_NAME);\n    swap = kg_ccache_name;\n    kg_ccache_name = new_name;\n    new_name = swap;\n    kerr = k5_setspecific(K5_KEY_GSS_KRB5_CCACHE_NAME, kg_ccache_name);\n    if (kerr != 0) {\n        /* Can't store, so free up the storage.  */\n        free(kg_ccache_name);\n        /* ??? free(new_name); */\n        *minor_status = kerr;\n        return GSS_S_FAILURE;\n    }\n\n    free (new_name);\n    *minor_status = 0;\n    return GSS_S_COMPLETE;\n}\n\n#define g_OID_prefix_equal(o1, o2)                                      \\\n    (((o1)->length >= (o2)->length) &&                                  \\\n     (memcmp((o1)->elements, (o2)->elements, (o2)->length) == 0))\n\n/*\n * gss_inquire_sec_context_by_oid() methods\n */\nstatic struct {\n    gss_OID_desc oid;\n    OM_uint32 (*func)(OM_uint32 *, const gss_ctx_id_t, const gss_OID, gss_buffer_set_t *);\n} krb5_gss_inquire_sec_context_by_oid_ops[] = {\n    {\n        {GSS_KRB5_GET_TKT_FLAGS_OID_LENGTH, GSS_KRB5_GET_TKT_FLAGS_OID},\n        gss_krb5int_get_tkt_flags\n    },\n    {\n        {GSS_KRB5_EXTRACT_AUTHZ_DATA_FROM_SEC_CONTEXT_OID_LENGTH, GSS_KRB5_EXTRACT_AUTHZ_DATA_FROM_SEC_CONTEXT_OID},\n        gss_krb5int_extract_authz_data_from_sec_context\n    },\n    {\n        {GSS_KRB5_INQ_SSPI_SESSION_KEY_OID_LENGTH, GSS_KRB5_INQ_SSPI_SESSION_KEY_OID},\n        gss_krb5int_inq_session_key\n    },\n    {\n        {GSS_KRB5_EXPORT_LUCID_SEC_CONTEXT_OID_LENGTH, GSS_KRB5_EXPORT_LUCID_SEC_CONTEXT_OID},\n        gss_krb5int_export_lucid_sec_context\n    },\n    {\n        {GSS_KRB5_EXTRACT_AUTHTIME_FROM_SEC_CONTEXT_OID_LENGTH, GSS_KRB5_EXTRACT_AUTHTIME_FROM_SEC_CONTEXT_OID},\n        gss_krb5int_extract_authtime_from_sec_context\n    }\n};\n\nstatic OM_uint32 KRB5_CALLCONV\nkrb5_gss_inquire_sec_context_by_oid (OM_uint32 *minor_status,\n                                     const gss_ctx_id_t context_handle,\n                                     const gss_OID desired_object,\n                                     gss_buffer_set_t *data_set)\n{\n    krb5_gss_ctx_id_rec *ctx;\n    size_t i;\n\n    if (minor_status == NULL)\n        return GSS_S_CALL_INACCESSIBLE_WRITE;\n\n    *minor_status = 0;\n\n    if (desired_object == GSS_C_NO_OID)\n        return GSS_S_CALL_INACCESSIBLE_READ;\n\n    if (data_set == NULL)\n        return GSS_S_CALL_INACCESSIBLE_WRITE;\n\n    *data_set = GSS_C_NO_BUFFER_SET;\n\n    ctx = (krb5_gss_ctx_id_rec *) context_handle;\n\n    if (ctx->terminated || !ctx->established)\n        return GSS_S_NO_CONTEXT;\n\n    for (i = 0; i < sizeof(krb5_gss_inquire_sec_context_by_oid_ops)/\n             sizeof(krb5_gss_inquire_sec_context_by_oid_ops[0]); i++) {\n        if (g_OID_prefix_equal(desired_object, &krb5_gss_inquire_sec_context_by_oid_ops[i].oid)) {\n            return (*krb5_gss_inquire_sec_context_by_oid_ops[i].func)(minor_status,\n                                                                      context_handle,\n                                                                      desired_object,\n                                                                      data_set);\n        }\n    }\n\n    *minor_status = EINVAL;\n\n    return GSS_S_UNAVAILABLE;\n}\n\n/*\n * gss_inquire_cred_by_oid() methods\n */\n#if 0\nstatic struct {\n    gss_OID_desc oid;\n    OM_uint32 (*func)(OM_uint32 *, const gss_cred_id_t, const gss_OID, gss_buffer_set_t *);\n} krb5_gss_inquire_cred_by_oid_ops[] = {\n};\n#endif\n\nstatic OM_uint32 KRB5_CALLCONV\nkrb5_gss_inquire_cred_by_oid(OM_uint32 *minor_status,\n                             const gss_cred_id_t cred_handle,\n                             const gss_OID desired_object,\n                             gss_buffer_set_t *data_set)\n{\n    OM_uint32 major_status = GSS_S_FAILURE;\n#if 0\n    size_t i;\n#endif\n\n    if (minor_status == NULL)\n        return GSS_S_CALL_INACCESSIBLE_WRITE;\n\n    *minor_status = 0;\n\n    if (desired_object == GSS_C_NO_OID)\n        return GSS_S_CALL_INACCESSIBLE_READ;\n\n    if (data_set == NULL)\n        return GSS_S_CALL_INACCESSIBLE_WRITE;\n\n    *data_set = GSS_C_NO_BUFFER_SET;\n    if (cred_handle == GSS_C_NO_CREDENTIAL) {\n        *minor_status = (OM_uint32)KRB5_NOCREDS_SUPPLIED;\n        return GSS_S_NO_CRED;\n    }\n\n    major_status = krb5_gss_validate_cred(minor_status, cred_handle);\n    if (GSS_ERROR(major_status))\n        return major_status;\n\n#if 0\n    for (i = 0; i < sizeof(krb5_gss_inquire_cred_by_oid_ops)/\n             sizeof(krb5_gss_inquire_cred_by_oid_ops[0]); i++) {\n        if (g_OID_prefix_equal(desired_object, &krb5_gss_inquire_cred_by_oid_ops[i].oid)) {\n            return (*krb5_gss_inquire_cred_by_oid_ops[i].func)(minor_status,\n                                                               cred_handle,\n                                                               desired_object,\n                                                               data_set);\n        }\n    }\n#endif\n\n    *minor_status = EINVAL;\n\n    return GSS_S_UNAVAILABLE;\n}\n\n/*\n * gss_set_sec_context_option() methods\n * (Disabled until we have something to populate the array.)\n */\n#if 0\nstatic struct {\n    gss_OID_desc oid;\n    OM_uint32 (*func)(OM_uint32 *, gss_ctx_id_t *, const gss_OID, const gss_buffer_t);\n} krb5_gss_set_sec_context_option_ops[] = {\n};\n#endif\n\nstatic OM_uint32 KRB5_CALLCONV\nkrb5_gss_set_sec_context_option (OM_uint32 *minor_status,\n                                 gss_ctx_id_t *context_handle,\n                                 const gss_OID desired_object,\n                                 const gss_buffer_t value)\n{\n#if 0\n    size_t i;\n#endif\n\n    if (minor_status == NULL)\n        return GSS_S_CALL_INACCESSIBLE_WRITE;\n\n    *minor_status = 0;\n\n    if (context_handle == NULL)\n        return GSS_S_CALL_INACCESSIBLE_READ;\n\n    if (desired_object == GSS_C_NO_OID)\n        return GSS_S_CALL_INACCESSIBLE_READ;\n\n#if 0\n    for (i = 0; i < sizeof(krb5_gss_set_sec_context_option_ops)/\n             sizeof(krb5_gss_set_sec_context_option_ops[0]); i++) {\n        if (g_OID_prefix_equal(desired_object, &krb5_gss_set_sec_context_option_ops[i].oid)) {\n            return (*krb5_gss_set_sec_context_option_ops[i].func)(minor_status,\n                                                                  context_handle,\n                                                                  desired_object,\n                                                                  value);\n        }\n    }\n#endif\n\n    *minor_status = EINVAL;\n\n    return GSS_S_UNAVAILABLE;\n}\n\nstatic OM_uint32\nno_ci_flags(OM_uint32 *minor_status,\n            gss_cred_id_t *cred_handle,\n            const gss_OID desired_oid,\n            const gss_buffer_t value)\n{\n    krb5_gss_cred_id_t cred;\n\n    cred = (krb5_gss_cred_id_t) *cred_handle;\n    cred->suppress_ci_flags = 1;\n\n    *minor_status = 0;\n    return GSS_S_COMPLETE;\n}\n/*\n * gssspi_set_cred_option() methods\n */\nstatic struct {\n    gss_OID_desc oid;\n    OM_uint32 (*func)(OM_uint32 *, gss_cred_id_t *, const gss_OID, const gss_buffer_t);\n} krb5_gssspi_set_cred_option_ops[] = {\n    {\n        {GSS_KRB5_COPY_CCACHE_OID_LENGTH, GSS_KRB5_COPY_CCACHE_OID},\n        gss_krb5int_copy_ccache\n    },\n    {\n        {GSS_KRB5_SET_ALLOWABLE_ENCTYPES_OID_LENGTH, GSS_KRB5_SET_ALLOWABLE_ENCTYPES_OID},\n        gss_krb5int_set_allowable_enctypes\n    },\n    {\n        {GSS_KRB5_SET_CRED_RCACHE_OID_LENGTH, GSS_KRB5_SET_CRED_RCACHE_OID},\n        gss_krb5int_set_cred_rcache\n    },\n    {\n        {GSS_KRB5_IMPORT_CRED_OID_LENGTH, GSS_KRB5_IMPORT_CRED_OID},\n        gss_krb5int_import_cred\n    },\n    {\n        {NO_CI_FLAGS_X_OID_LENGTH, NO_CI_FLAGS_X_OID},\n        no_ci_flags\n    },\n};\n\nstatic OM_uint32 KRB5_CALLCONV\nkrb5_gssspi_set_cred_option(OM_uint32 *minor_status,\n                            gss_cred_id_t *cred_handle,\n                            const gss_OID desired_object,\n                            const gss_buffer_t value)\n{\n    OM_uint32 major_status = GSS_S_FAILURE;\n    size_t i;\n\n    if (minor_status == NULL)\n        return GSS_S_CALL_INACCESSIBLE_WRITE;\n\n    if (cred_handle == NULL)\n        return GSS_S_CALL_INACCESSIBLE_WRITE;\n\n    *minor_status = 0;\n\n    if (desired_object == GSS_C_NO_OID)\n        return GSS_S_CALL_INACCESSIBLE_READ;\n\n    if (*cred_handle != GSS_C_NO_CREDENTIAL) {\n        major_status = krb5_gss_validate_cred(minor_status, *cred_handle);\n        if (GSS_ERROR(major_status))\n            return major_status;\n    }\n\n    for (i = 0; i < sizeof(krb5_gssspi_set_cred_option_ops)/\n             sizeof(krb5_gssspi_set_cred_option_ops[0]); i++) {\n        if (g_OID_prefix_equal(desired_object, &krb5_gssspi_set_cred_option_ops[i].oid)) {\n            return (*krb5_gssspi_set_cred_option_ops[i].func)(minor_status,\n                                                              cred_handle,\n                                                              desired_object,\n                                                              value);\n        }\n    }\n\n    *minor_status = EINVAL;\n\n    return GSS_S_UNAVAILABLE;\n}\n\n/*\n * gssspi_mech_invoke() methods\n */\nstatic struct {\n    gss_OID_desc oid;\n    OM_uint32 (*func)(OM_uint32 *, const gss_OID, const gss_OID, gss_buffer_t);\n} krb5_gssspi_mech_invoke_ops[] = {\n    {\n        {GSS_KRB5_REGISTER_ACCEPTOR_IDENTITY_OID_LENGTH, GSS_KRB5_REGISTER_ACCEPTOR_IDENTITY_OID},\n        gss_krb5int_register_acceptor_identity\n    },\n    {\n        {GSS_KRB5_CCACHE_NAME_OID_LENGTH, GSS_KRB5_CCACHE_NAME_OID},\n        gss_krb5int_ccache_name\n    },\n    {\n        {GSS_KRB5_FREE_LUCID_SEC_CONTEXT_OID_LENGTH, GSS_KRB5_FREE_LUCID_SEC_CONTEXT_OID},\n        gss_krb5int_free_lucid_sec_context\n    },\n#ifndef _WIN32\n    {\n        {GSS_KRB5_USE_KDC_CONTEXT_OID_LENGTH, GSS_KRB5_USE_KDC_CONTEXT_OID},\n        krb5int_gss_use_kdc_context\n    },\n#endif\n};\n\nstatic OM_uint32 KRB5_CALLCONV\nkrb5_gssspi_mech_invoke (OM_uint32 *minor_status,\n                         const gss_OID desired_mech,\n                         const gss_OID desired_object,\n                         gss_buffer_t value)\n{\n    size_t i;\n\n    if (minor_status == NULL)\n        return GSS_S_CALL_INACCESSIBLE_WRITE;\n\n    *minor_status = 0;\n\n    if (desired_mech == GSS_C_NO_OID)\n        return GSS_S_BAD_MECH;\n\n    if (desired_object == GSS_C_NO_OID)\n        return GSS_S_CALL_INACCESSIBLE_READ;\n\n    for (i = 0; i < sizeof(krb5_gssspi_mech_invoke_ops)/\n             sizeof(krb5_gssspi_mech_invoke_ops[0]); i++) {\n        if (g_OID_prefix_equal(desired_object, &krb5_gssspi_mech_invoke_ops[i].oid)) {\n            return (*krb5_gssspi_mech_invoke_ops[i].func)(minor_status,\n                                                          desired_mech,\n                                                          desired_object,\n                                                          value);\n        }\n    }\n\n    *minor_status = EINVAL;\n\n    return GSS_S_UNAVAILABLE;\n}\n\n#define GS2_KRB5_SASL_NAME        \"GS2-KRB5\"\n#define GS2_KRB5_SASL_NAME_LEN    (sizeof(GS2_KRB5_SASL_NAME) - 1)\n\n#define GS2_IAKERB_SASL_NAME      \"GS2-IAKERB\"\n#define GS2_IAKERB_SASL_NAME_LEN  (sizeof(GS2_IAKERB_SASL_NAME) - 1)\n\nstatic OM_uint32 KRB5_CALLCONV\nkrb5_gss_inquire_mech_for_saslname(OM_uint32 *minor_status,\n                                   const gss_buffer_t sasl_mech_name,\n                                   gss_OID *mech_type)\n{\n    *minor_status = 0;\n\n    if (sasl_mech_name->length == GS2_KRB5_SASL_NAME_LEN &&\n        memcmp(sasl_mech_name->value,\n               GS2_KRB5_SASL_NAME, GS2_KRB5_SASL_NAME_LEN) == 0) {\n        if (mech_type != NULL)\n            *mech_type = (gss_OID)gss_mech_krb5;\n        return GSS_S_COMPLETE;\n    } else if (sasl_mech_name->length == GS2_IAKERB_SASL_NAME_LEN &&\n               memcmp(sasl_mech_name->value,\n                      GS2_IAKERB_SASL_NAME, GS2_IAKERB_SASL_NAME_LEN) == 0) {\n        if (mech_type != NULL)\n            *mech_type = (gss_OID)gss_mech_iakerb;\n        return GSS_S_COMPLETE;\n    }\n\n    return GSS_S_BAD_MECH;\n}\n\nstatic OM_uint32 KRB5_CALLCONV\nkrb5_gss_inquire_saslname_for_mech(OM_uint32 *minor_status,\n                                   const gss_OID desired_mech,\n                                   gss_buffer_t sasl_mech_name,\n                                   gss_buffer_t mech_name,\n                                   gss_buffer_t mech_description)\n{\n    if (g_OID_equal(desired_mech, gss_mech_iakerb)) {\n        if (!g_make_string_buffer(GS2_IAKERB_SASL_NAME, sasl_mech_name) ||\n            !g_make_string_buffer(\"iakerb\", mech_name) ||\n            !g_make_string_buffer(\"Initial and Pass Through Authentication \"\n                                  \"Kerberos Mechanism (IAKERB)\",\n                                  mech_description))\n            goto fail;\n    } else {\n        if (!g_make_string_buffer(GS2_KRB5_SASL_NAME, sasl_mech_name) ||\n            !g_make_string_buffer(\"krb5\", mech_name) ||\n            !g_make_string_buffer(\"Kerberos 5 GSS-API Mechanism\",\n                                  mech_description))\n            goto fail;\n    }\n\n    *minor_status = 0;\n    return GSS_S_COMPLETE;\n\nfail:\n    *minor_status = ENOMEM;\n    return GSS_S_FAILURE;\n}\n\nstatic OM_uint32 KRB5_CALLCONV\nkrb5_gss_inquire_attrs_for_mech(OM_uint32 *minor_status,\n                                gss_const_OID mech,\n                                gss_OID_set *mech_attrs,\n                                gss_OID_set *known_mech_attrs)\n{\n    OM_uint32 major, tmpMinor;\n\n    if (mech_attrs == NULL) {\n        *minor_status = 0;\n        return GSS_S_COMPLETE;\n    }\n\n    major = gss_create_empty_oid_set(minor_status, mech_attrs);\n    if (GSS_ERROR(major))\n        goto cleanup;\n\n#define MA_SUPPORTED(ma)    do {                                        \\\n        major = gss_add_oid_set_member(minor_status, (gss_OID)ma,       \\\n                                       mech_attrs);                     \\\n        if (GSS_ERROR(major))                                           \\\n            goto cleanup;                                               \\\n    } while (0)\n\n    MA_SUPPORTED(GSS_C_MA_MECH_CONCRETE);\n    MA_SUPPORTED(GSS_C_MA_ITOK_FRAMED);\n    MA_SUPPORTED(GSS_C_MA_AUTH_INIT);\n    MA_SUPPORTED(GSS_C_MA_AUTH_TARG);\n    MA_SUPPORTED(GSS_C_MA_DELEG_CRED);\n    MA_SUPPORTED(GSS_C_MA_INTEG_PROT);\n    MA_SUPPORTED(GSS_C_MA_CONF_PROT);\n    MA_SUPPORTED(GSS_C_MA_MIC);\n    MA_SUPPORTED(GSS_C_MA_WRAP);\n    MA_SUPPORTED(GSS_C_MA_PROT_READY);\n    MA_SUPPORTED(GSS_C_MA_REPLAY_DET);\n    MA_SUPPORTED(GSS_C_MA_OOS_DET);\n    MA_SUPPORTED(GSS_C_MA_CBINDINGS);\n    MA_SUPPORTED(GSS_C_MA_CTX_TRANS);\n\n    if (g_OID_equal(mech, gss_mech_iakerb)) {\n        MA_SUPPORTED(GSS_C_MA_AUTH_INIT_INIT);\n        MA_SUPPORTED(GSS_C_MA_NOT_DFLT_MECH);\n    } else if (!g_OID_equal(mech, gss_mech_krb5)) {\n        MA_SUPPORTED(GSS_C_MA_DEPRECATED);\n    }\n\ncleanup:\n    if (GSS_ERROR(major))\n        gss_release_oid_set(&tmpMinor, mech_attrs);\n\n    return major;\n}\n\nstatic OM_uint32 KRB5_CALLCONV\nkrb5_gss_localname(OM_uint32 *minor,\n                   const gss_name_t pname,\n                   const gss_const_OID mech_type,\n                   gss_buffer_t localname)\n{\n    krb5_context context;\n    krb5_error_code code;\n    krb5_gss_name_t kname;\n    char lname[BUFSIZ];\n\n    code = krb5_gss_init_context(&context);\n    if (code != 0) {\n        *minor = code;\n        return GSS_S_FAILURE;\n    }\n\n    kname = (krb5_gss_name_t)pname;\n\n    code = krb5_aname_to_localname(context, kname->princ,\n                                   sizeof(lname), lname);\n    if (code != 0) {\n        *minor = KRB5_NO_LOCALNAME;\n        krb5_free_context(context);\n        return GSS_S_FAILURE;\n    }\n\n\n    krb5_free_context(context);\n    localname->value = gssalloc_strdup(lname);\n    localname->length = strlen(lname);\n\n    return (code == 0) ? GSS_S_COMPLETE : GSS_S_FAILURE;\n}\n\n\nstatic OM_uint32 KRB5_CALLCONV\nkrb5_gss_authorize_localname(OM_uint32 *minor,\n                             const gss_name_t pname,\n                             gss_const_buffer_t local_user,\n                             gss_const_OID name_type)\n{\n    krb5_context context;\n    krb5_error_code code;\n    krb5_gss_name_t kname;\n    char *user;\n    int user_ok;\n\n    if (name_type != GSS_C_NO_OID &&\n        !g_OID_equal(name_type, GSS_C_NT_USER_NAME)) {\n        return GSS_S_BAD_NAMETYPE;\n    }\n\n    kname = (krb5_gss_name_t)pname;\n\n    code = krb5_gss_init_context(&context);\n    if (code != 0) {\n        *minor = code;\n        return GSS_S_FAILURE;\n    }\n\n    user = k5memdup0(local_user->value, local_user->length, &code);\n    if (user == NULL) {\n        *minor = code;\n        krb5_free_context(context);\n        return GSS_S_FAILURE;\n    }\n\n    user_ok = krb5_kuserok(context, kname->princ, user);\n\n    free(user);\n    krb5_free_context(context);\n\n    *minor = 0;\n    return user_ok ? GSS_S_COMPLETE : GSS_S_UNAUTHORIZED;\n}\n\nstatic struct gss_config krb5_mechanism = {\n    { GSS_MECH_KRB5_OID_LENGTH, GSS_MECH_KRB5_OID },\n    NULL,\n    krb5_gss_acquire_cred,\n    krb5_gss_release_cred,\n    krb5_gss_init_sec_context,\n#ifdef LEAN_CLIENT\n    NULL,\n#else\n    krb5_gss_accept_sec_context,\n#endif\n    krb5_gss_process_context_token,\n    krb5_gss_delete_sec_context,\n    krb5_gss_context_time,\n    krb5_gss_get_mic,\n    krb5_gss_verify_mic,\n#if defined(IOV_SHIM_EXERCISE_WRAP) || defined(IOV_SHIM_EXERCISE)\n    NULL,\n#else\n    krb5_gss_wrap,\n#endif\n#if defined(IOV_SHIM_EXERCISE_UNWRAP) || defined(IOV_SHIM_EXERCISE)\n    NULL,\n#else\n    krb5_gss_unwrap,\n#endif\n    krb5_gss_display_status,\n    krb5_gss_indicate_mechs,\n    krb5_gss_compare_name,\n    krb5_gss_display_name,\n    krb5_gss_import_name,\n    krb5_gss_release_name,\n    krb5_gss_inquire_cred,\n    NULL,                /* add_cred */\n#ifdef LEAN_CLIENT\n    NULL,\n    NULL,\n#else\n    krb5_gss_export_sec_context,\n    krb5_gss_import_sec_context,\n#endif\n    krb5_gss_inquire_cred_by_mech,\n    krb5_gss_inquire_names_for_mech,\n    krb5_gss_inquire_context,\n    krb5_gss_internal_release_oid,\n    krb5_gss_wrap_size_limit,\n    krb5_gss_localname,\n\n    krb5_gss_authorize_localname,\n    krb5_gss_export_name,\n    krb5_gss_duplicate_name,\n    krb5_gss_store_cred,\n    krb5_gss_inquire_sec_context_by_oid,\n    krb5_gss_inquire_cred_by_oid,\n    krb5_gss_set_sec_context_option,\n    krb5_gssspi_set_cred_option,\n    krb5_gssspi_mech_invoke,\n    NULL,                /* wrap_aead */\n    NULL,                /* unwrap_aead */\n    krb5_gss_wrap_iov,\n    krb5_gss_unwrap_iov,\n    krb5_gss_wrap_iov_length,\n    NULL,               /* complete_auth_token */\n    krb5_gss_acquire_cred_impersonate_name,\n    NULL,               /* krb5_gss_add_cred_impersonate_name */\n    NULL,               /* display_name_ext */\n    krb5_gss_inquire_name,\n    krb5_gss_get_name_attribute,\n    krb5_gss_set_name_attribute,\n    krb5_gss_delete_name_attribute,\n    krb5_gss_export_name_composite,\n    krb5_gss_map_name_to_any,\n    krb5_gss_release_any_name_mapping,\n    krb5_gss_pseudo_random,\n    NULL,               /* set_neg_mechs */\n    krb5_gss_inquire_saslname_for_mech,\n    krb5_gss_inquire_mech_for_saslname,\n    krb5_gss_inquire_attrs_for_mech,\n    krb5_gss_acquire_cred_from,\n    krb5_gss_store_cred_into,\n    krb5_gss_acquire_cred_with_password,\n    krb5_gss_export_cred,\n    krb5_gss_import_cred,\n    NULL,               /* import_sec_context_by_mech */\n    NULL,               /* import_name_by_mech */\n    NULL,               /* import_cred_by_mech */\n    krb5_gss_get_mic_iov,\n    krb5_gss_verify_mic_iov,\n    krb5_gss_get_mic_iov_length,\n};\n\n#ifdef _GSS_STATIC_LINK\n#include \"mglueP.h\"\nstatic int gss_iakerbmechglue_init(void)\n{\n    struct gss_mech_config mech_iakerb;\n    struct gss_config iakerb_mechanism = krb5_mechanism;\n\n    /* IAKERB mechanism mirrors krb5, but with different context SPIs */\n    iakerb_mechanism.gss_accept_sec_context = iakerb_gss_accept_sec_context;\n    iakerb_mechanism.gss_init_sec_context   = iakerb_gss_init_sec_context;\n    iakerb_mechanism.gss_delete_sec_context = iakerb_gss_delete_sec_context;\n    iakerb_mechanism.gss_acquire_cred       = iakerb_gss_acquire_cred;\n    iakerb_mechanism.gssspi_acquire_cred_with_password\n                                    = iakerb_gss_acquire_cred_with_password;\n\n    memset(&mech_iakerb, 0, sizeof(mech_iakerb));\n    mech_iakerb.mech = &iakerb_mechanism;\n\n    mech_iakerb.mechNameStr = \"iakerb\";\n    mech_iakerb.mech_type = (gss_OID)gss_mech_iakerb;\n    gssint_register_mechinfo(&mech_iakerb);\n\n    return 0;\n}\n\nstatic int gss_krb5mechglue_init(void)\n{\n    struct gss_mech_config mech_krb5;\n\n    memset(&mech_krb5, 0, sizeof(mech_krb5));\n    mech_krb5.mech = &krb5_mechanism;\n\n    mech_krb5.mechNameStr = \"kerberos_v5\";\n    mech_krb5.mech_type = (gss_OID)gss_mech_krb5;\n    gssint_register_mechinfo(&mech_krb5);\n\n    mech_krb5.mechNameStr = \"kerberos_v5_old\";\n    mech_krb5.mech_type = (gss_OID)gss_mech_krb5_old;\n    gssint_register_mechinfo(&mech_krb5);\n\n    mech_krb5.mechNameStr = \"mskrb\";\n    mech_krb5.mech_type = (gss_OID)gss_mech_krb5_wrong;\n    gssint_register_mechinfo(&mech_krb5);\n\n    return 0;\n}\n#else\nMAKE_INIT_FUNCTION(gss_krb5int_lib_init);\nMAKE_FINI_FUNCTION(gss_krb5int_lib_fini);\n\ngss_mechanism KRB5_CALLCONV\ngss_mech_initialize(void)\n{\n    return &krb5_mechanism;\n}\n#endif /* _GSS_STATIC_LINK */\n\nint gss_krb5int_lib_init(void)\n{\n    int err;\n\n#ifdef SHOW_INITFINI_FUNCS\n    printf(\"gss_krb5int_lib_init\\n\");\n#endif\n\n    add_error_table(&et_k5g_error_table);\n\n#ifndef LEAN_CLIENT\n    err = k5_mutex_finish_init(&gssint_krb5_keytab_lock);\n    if (err)\n        return err;\n#endif /* LEAN_CLIENT */\n    err = k5_key_register(K5_KEY_GSS_KRB5_SET_CCACHE_OLD_NAME, free);\n    if (err)\n        return err;\n    err = k5_key_register(K5_KEY_GSS_KRB5_CCACHE_NAME, free);\n    if (err)\n        return err;\n    err = k5_key_register(K5_KEY_GSS_KRB5_ERROR_MESSAGE,\n                          krb5_gss_delete_error_info);\n    if (err)\n        return err;\n#ifndef _WIN32\n    err = k5_mutex_finish_init(&kg_kdc_flag_mutex);\n    if (err)\n        return err;\n    err = k5_mutex_finish_init(&kg_vdb.mutex);\n    if (err)\n        return err;\n#endif\n#ifdef _GSS_STATIC_LINK\n    err = gss_krb5mechglue_init();\n    if (err)\n        return err;\n    err = gss_iakerbmechglue_init();\n    if (err)\n        return err;\n#endif\n\n    return 0;\n}\n\nvoid gss_krb5int_lib_fini(void)\n{\n#ifndef _GSS_STATIC_LINK\n    if (!INITIALIZER_RAN(gss_krb5int_lib_init) || PROGRAM_EXITING()) {\n# ifdef SHOW_INITFINI_FUNCS\n        printf(\"gss_krb5int_lib_fini: skipping\\n\");\n# endif\n        return;\n    }\n#endif\n#ifdef SHOW_INITFINI_FUNCS\n    printf(\"gss_krb5int_lib_fini\\n\");\n#endif\n    remove_error_table(&et_k5g_error_table);\n\n    k5_key_delete(K5_KEY_GSS_KRB5_SET_CCACHE_OLD_NAME);\n    k5_key_delete(K5_KEY_GSS_KRB5_CCACHE_NAME);\n    k5_key_delete(K5_KEY_GSS_KRB5_ERROR_MESSAGE);\n    k5_mutex_destroy(&kg_vdb.mutex);\n#ifndef _WIN32\n    k5_mutex_destroy(&kg_kdc_flag_mutex);\n#endif\n#ifndef LEAN_CLIENT\n    k5_mutex_destroy(&gssint_krb5_keytab_lock);\n#endif /* LEAN_CLIENT */\n}\n\n#ifdef _GSS_STATIC_LINK\nextern OM_uint32 gssint_lib_init(void);\n#endif\n\nOM_uint32 gss_krb5int_initialize_library (void)\n{\n#ifdef _GSS_STATIC_LINK\n    return gssint_mechglue_initialize_library();\n#else\n    return CALL_INIT_FUNCTION(gss_krb5int_lib_init);\n#endif\n}\n", "/* -*- mode: c; c-basic-offset: 4; indent-tabs-mode: nil -*- */\n/*\n * Copyright 2009  by the Massachusetts Institute of Technology.\n * All Rights Reserved.\n *\n * Export of this software from the United States of America may\n *   require a specific license from the United States Government.\n *   It is the responsibility of any person or organization contemplating\n *   export to obtain such a license before exporting.\n *\n * WITHIN THAT CONSTRAINT, permission to use, copy, modify, and\n * distribute this software and its documentation for any purpose and\n * without fee is hereby granted, provided that the above copyright\n * notice appear in all copies and that both that copyright notice and\n * this permission notice appear in supporting documentation, and that\n * the name of M.I.T. not be used in advertising or publicity pertaining\n * to distribution of the software without specific, written prior\n * permission.  Furthermore if you modify this software you must label\n * your software as modified software and not distribute it in such a\n * fashion that it might be confused with the original M.I.T. software.\n * M.I.T. makes no representations about the suitability of\n * this software for any purpose.  It is provided \"as is\" without express\n * or implied warranty.\n */\n#include \"k5-int.h\"\n#include \"gssapiP_krb5.h\"\n\n/*\n * IAKERB implementation\n */\n\nextern int gssint_get_der_length(unsigned char **, OM_uint32, unsigned int*);\n\nenum iakerb_state {\n    IAKERB_AS_REQ,      /* acquiring ticket with initial creds */\n    IAKERB_TGS_REQ,     /* acquiring ticket with TGT */\n    IAKERB_AP_REQ       /* hand-off to normal GSS AP-REQ exchange */\n};\n\nstruct _iakerb_ctx_id_rec {\n    krb5_magic magic;                   /* KG_IAKERB_CONTEXT */\n    krb5_context k5c;\n    gss_cred_id_t defcred;              /* Initiator only */\n    enum iakerb_state state;            /* Initiator only */\n    krb5_init_creds_context icc;        /* Initiator only */\n    krb5_tkt_creds_context tcc;         /* Initiator only */\n    gss_ctx_id_t gssc;\n    krb5_data conv;                     /* conversation for checksumming */\n    unsigned int count;                 /* number of round trips */\n    krb5_get_init_creds_opt *gic_opts;\n};\n\n#define IAKERB_MAX_HOPS ( 16 /* MAX_IN_TKT_LOOPS */ + KRB5_REFERRAL_MAXHOPS )\n\ntypedef struct _iakerb_ctx_id_rec iakerb_ctx_id_rec;\ntypedef iakerb_ctx_id_rec *iakerb_ctx_id_t;\n\n/*\n * Release an IAKERB context\n */\nstatic void\niakerb_release_context(iakerb_ctx_id_t ctx)\n{\n    OM_uint32 tmp;\n\n    if (ctx == NULL)\n        return;\n\n    krb5_gss_release_cred(&tmp, &ctx->defcred);\n    krb5_init_creds_free(ctx->k5c, ctx->icc);\n    krb5_tkt_creds_free(ctx->k5c, ctx->tcc);\n    krb5_gss_delete_sec_context(&tmp, &ctx->gssc, NULL);\n    krb5_free_data_contents(ctx->k5c, &ctx->conv);\n    krb5_get_init_creds_opt_free(ctx->k5c, ctx->gic_opts);\n    krb5_free_context(ctx->k5c);\n    free(ctx);\n}\n\n/*\n * Create a IAKERB-FINISHED structure containing a checksum of\n * the entire IAKERB exchange.\n */\nkrb5_error_code\niakerb_make_finished(krb5_context context,\n                     krb5_key key,\n                     const krb5_data *conv,\n                     krb5_data **finished)\n{\n    krb5_error_code code;\n    krb5_iakerb_finished iaf;\n\n    *finished = NULL;\n\n    memset(&iaf, 0, sizeof(iaf));\n\n    if (key == NULL)\n        return KRB5KDC_ERR_NULL_KEY;\n\n    code = krb5_k_make_checksum(context, 0, key, KRB5_KEYUSAGE_IAKERB_FINISHED,\n                                conv, &iaf.checksum);\n    if (code != 0)\n        return code;\n\n    code = encode_krb5_iakerb_finished(&iaf, finished);\n\n    krb5_free_checksum_contents(context, &iaf.checksum);\n\n    return code;\n}\n\n/*\n * Verify a IAKERB-FINISHED structure submitted by the initiator\n */\nkrb5_error_code\niakerb_verify_finished(krb5_context context,\n                       krb5_key key,\n                       const krb5_data *conv,\n                       const krb5_data *finished)\n{\n    krb5_error_code code;\n    krb5_iakerb_finished *iaf;\n    krb5_boolean valid = FALSE;\n\n    if (key == NULL)\n        return KRB5KDC_ERR_NULL_KEY;\n\n    code = decode_krb5_iakerb_finished(finished, &iaf);\n    if (code != 0)\n        return code;\n\n    code = krb5_k_verify_checksum(context, key, KRB5_KEYUSAGE_IAKERB_FINISHED,\n                                  conv, &iaf->checksum, &valid);\n    if (code == 0 && valid == FALSE)\n        code = KRB5KRB_AP_ERR_BAD_INTEGRITY;\n\n    krb5_free_iakerb_finished(context, iaf);\n\n    return code;\n}\n\n/*\n * Save a token for future checksumming.\n */\nstatic krb5_error_code\niakerb_save_token(iakerb_ctx_id_t ctx, const gss_buffer_t token)\n{\n    char *p;\n\n    p = realloc(ctx->conv.data, ctx->conv.length + token->length);\n    if (p == NULL)\n        return ENOMEM;\n\n    memcpy(p + ctx->conv.length, token->value, token->length);\n    ctx->conv.data = p;\n    ctx->conv.length += token->length;\n\n    return 0;\n}\n\n/*\n * Parse a token into IAKERB-HEADER and KRB-KDC-REQ/REP\n */\nstatic krb5_error_code\niakerb_parse_token(iakerb_ctx_id_t ctx,\n                   int initialContextToken,\n                   const gss_buffer_t token,\n                   krb5_data *realm,\n                   krb5_data **cookie,\n                   krb5_data *request)\n{\n    krb5_error_code code;\n    krb5_iakerb_header *iah = NULL;\n    unsigned int bodysize, lenlen;\n    int length;\n    unsigned char *ptr;\n    int flags = 0;\n    krb5_data data;\n\n    if (token == GSS_C_NO_BUFFER || token->length == 0) {\n        code = KRB5_BAD_MSIZE;\n        goto cleanup;\n    }\n\n    if (initialContextToken)\n        flags |= G_VFY_TOKEN_HDR_WRAPPER_REQUIRED;\n\n    ptr = token->value;\n\n    code = g_verify_token_header(gss_mech_iakerb,\n                                 &bodysize, &ptr,\n                                 IAKERB_TOK_PROXY,\n                                 token->length, flags);\n    if (code != 0)\n        goto cleanup;\n\n    data.data = (char *)ptr;\n\n    if (bodysize-- == 0 || *ptr++ != 0x30 /* SEQUENCE */) {\n        code = ASN1_BAD_ID;\n        goto cleanup;\n    }\n\n    length = gssint_get_der_length(&ptr, bodysize, &lenlen);\n    if (length < 0 || bodysize - lenlen < (unsigned int)length) {\n        code = KRB5_BAD_MSIZE;\n        goto cleanup;\n    }\n    data.length = 1 /* SEQUENCE */ + lenlen + length;\n\n    ptr += length;\n    bodysize -= (lenlen + length);\n\n    code = decode_krb5_iakerb_header(&data, &iah);\n    if (code != 0)\n        goto cleanup;\n\n    if (realm != NULL) {\n        *realm = iah->target_realm;\n        iah->target_realm.data = NULL;\n    }\n\n    if (cookie != NULL) {\n        *cookie = iah->cookie;\n        iah->cookie = NULL;\n    }\n\n    request->data = (char *)ptr;\n    request->length = bodysize;\n\n    assert(request->data + request->length ==\n           (char *)token->value + token->length);\n\ncleanup:\n    krb5_free_iakerb_header(ctx->k5c, iah);\n\n    return code;\n}\n\n/*\n * Create a token from IAKERB-HEADER and KRB-KDC-REQ/REP\n */\nstatic krb5_error_code\niakerb_make_token(iakerb_ctx_id_t ctx,\n                  krb5_data *realm,\n                  krb5_data *cookie,\n                  krb5_data *request,\n                  int initialContextToken,\n                  gss_buffer_t token)\n{\n    krb5_error_code code;\n    krb5_iakerb_header iah;\n    krb5_data *data = NULL;\n    char *p;\n    unsigned int tokenSize;\n    unsigned char *q;\n\n    token->value = NULL;\n    token->length = 0;\n\n    /*\n     * Assemble the IAKERB-HEADER from the realm and cookie\n     */\n    memset(&iah, 0, sizeof(iah));\n    iah.target_realm = *realm;\n    iah.cookie = cookie;\n\n    code = encode_krb5_iakerb_header(&iah, &data);\n    if (code != 0)\n        goto cleanup;\n\n    /*\n     * Concatenate Kerberos request.\n     */\n    p = realloc(data->data, data->length + request->length);\n    if (p == NULL) {\n        code = ENOMEM;\n        goto cleanup;\n    }\n    data->data = p;\n\n    if (request->length > 0)\n        memcpy(data->data + data->length, request->data, request->length);\n    data->length += request->length;\n\n    if (initialContextToken)\n        tokenSize = g_token_size(gss_mech_iakerb, data->length);\n    else\n        tokenSize = 2 + data->length;\n\n    token->value = q = gssalloc_malloc(tokenSize);\n    if (q == NULL) {\n        code = ENOMEM;\n        goto cleanup;\n    }\n    token->length = tokenSize;\n\n    if (initialContextToken) {\n        g_make_token_header(gss_mech_iakerb, data->length, &q,\n                            IAKERB_TOK_PROXY);\n    } else {\n        store_16_be(IAKERB_TOK_PROXY, q);\n        q += 2;\n    }\n    memcpy(q, data->data, data->length);\n    q += data->length;\n\n    assert(q == (unsigned char *)token->value + token->length);\n\ncleanup:\n    krb5_free_data(ctx->k5c, data);\n\n    return code;\n}\n\n/*\n * Parse the IAKERB token in input_token and send the contained KDC\n * request to the KDC for the realm.\n *\n * Wrap the KDC reply in output_token.\n */\nstatic krb5_error_code\niakerb_acceptor_step(iakerb_ctx_id_t ctx,\n                     int initialContextToken,\n                     const gss_buffer_t input_token,\n                     gss_buffer_t output_token)\n{\n    krb5_error_code code;\n    krb5_data request = empty_data(), reply = empty_data();\n    krb5_data realm = empty_data();\n    OM_uint32 tmp;\n    int tcp_only, use_master;\n    krb5_ui_4 kdc_code;\n\n    output_token->length = 0;\n    output_token->value = NULL;\n\n    if (ctx->count >= IAKERB_MAX_HOPS) {\n        code = KRB5_KDC_UNREACH;\n        goto cleanup;\n    }\n\n    code = iakerb_parse_token(ctx, initialContextToken, input_token, &realm,\n                              NULL, &request);\n    if (code != 0)\n        goto cleanup;\n\n    if (realm.length == 0 || request.length == 0) {\n        code = KRB5_BAD_MSIZE;\n        goto cleanup;\n    }\n\n    code = iakerb_save_token(ctx, input_token);\n    if (code != 0)\n        goto cleanup;\n\n    for (tcp_only = 0; tcp_only <= 1; tcp_only++) {\n        use_master = 0;\n        code = krb5_sendto_kdc(ctx->k5c, &request, &realm,\n                               &reply, &use_master, tcp_only);\n        if (code == 0 && krb5_is_krb_error(&reply)) {\n            krb5_error *error;\n\n            code = decode_krb5_error(&reply, &error);\n            if (code != 0)\n                goto cleanup;\n            kdc_code = error->error;\n            krb5_free_error(ctx->k5c, error);\n            if (kdc_code == KRB_ERR_RESPONSE_TOO_BIG) {\n                krb5_free_data_contents(ctx->k5c, &reply);\n                reply = empty_data();\n                continue;\n            }\n        }\n        break;\n    }\n\n    if (code == KRB5_KDC_UNREACH || code == KRB5_REALM_UNKNOWN) {\n        krb5_error error;\n\n        memset(&error, 0, sizeof(error));\n        if (code == KRB5_KDC_UNREACH)\n            error.error = KRB_AP_ERR_IAKERB_KDC_NO_RESPONSE;\n        else if (code == KRB5_REALM_UNKNOWN)\n            error.error = KRB_AP_ERR_IAKERB_KDC_NOT_FOUND;\n\n        code = krb5_mk_error(ctx->k5c, &error, &reply);\n        if (code != 0)\n            goto cleanup;\n    } else if (code != 0)\n        goto cleanup;\n\n    code = iakerb_make_token(ctx, &realm, NULL, &reply, 0, output_token);\n    if (code != 0)\n        goto cleanup;\n\n    code = iakerb_save_token(ctx, output_token);\n    if (code != 0)\n        goto cleanup;\n\n    ctx->count++;\n\ncleanup:\n    if (code != 0)\n        gss_release_buffer(&tmp, output_token);\n    /* request is a pointer into input_token, no need to free */\n    krb5_free_data_contents(ctx->k5c, &realm);\n    krb5_free_data_contents(ctx->k5c, &reply);\n\n    return code;\n}\n\n/*\n * Initialise the krb5_init_creds context for the IAKERB context\n */\nstatic krb5_error_code\niakerb_init_creds_ctx(iakerb_ctx_id_t ctx,\n                      krb5_gss_cred_id_t cred,\n                      OM_uint32 time_req)\n{\n    krb5_error_code code;\n\n    if (cred->iakerb_mech == 0) {\n        code = EINVAL;\n        goto cleanup;\n    }\n\n    assert(cred->name != NULL);\n    assert(cred->name->princ != NULL);\n\n    code = krb5_get_init_creds_opt_alloc(ctx->k5c, &ctx->gic_opts);\n    if (code != 0)\n        goto cleanup;\n\n    if (time_req != 0 && time_req != GSS_C_INDEFINITE)\n        krb5_get_init_creds_opt_set_tkt_life(ctx->gic_opts, time_req);\n\n    code = krb5_get_init_creds_opt_set_out_ccache(ctx->k5c, ctx->gic_opts,\n                                                  cred->ccache);\n    if (code != 0)\n        goto cleanup;\n\n    code = krb5_init_creds_init(ctx->k5c,\n                                cred->name->princ,\n                                NULL,   /* prompter */\n                                NULL,   /* data */\n                                0,      /* start_time */\n                                ctx->gic_opts,\n                                &ctx->icc);\n    if (code != 0)\n        goto cleanup;\n\n    if (cred->password != NULL) {\n        code = krb5_init_creds_set_password(ctx->k5c, ctx->icc,\n                                            cred->password);\n    } else {\n        code = krb5_init_creds_set_keytab(ctx->k5c, ctx->icc,\n                                          cred->client_keytab);\n    }\n    if (code != 0)\n        goto cleanup;\n\ncleanup:\n    return code;\n}\n\n/*\n * Initialise the krb5_tkt_creds context for the IAKERB context\n */\nstatic krb5_error_code\niakerb_tkt_creds_ctx(iakerb_ctx_id_t ctx,\n                     krb5_gss_cred_id_t cred,\n                     krb5_gss_name_t name,\n                     OM_uint32 time_req)\n\n{\n    krb5_error_code code;\n    krb5_creds creds;\n    krb5_timestamp now;\n\n    assert(cred->name != NULL);\n    assert(cred->name->princ != NULL);\n\n    memset(&creds, 0, sizeof(creds));\n\n    creds.client = cred->name->princ;\n    creds.server = name->princ;\n\n    if (time_req != 0 && time_req != GSS_C_INDEFINITE) {\n        code = krb5_timeofday(ctx->k5c, &now);\n        if (code != 0)\n            goto cleanup;\n\n        creds.times.endtime = now + time_req;\n    }\n\n    if (cred->name->ad_context != NULL) {\n        code = krb5_authdata_export_authdata(ctx->k5c,\n                                             cred->name->ad_context,\n                                             AD_USAGE_TGS_REQ,\n                                             &creds.authdata);\n        if (code != 0)\n            goto cleanup;\n    }\n\n    code = krb5_tkt_creds_init(ctx->k5c, cred->ccache, &creds, 0, &ctx->tcc);\n    if (code != 0)\n        goto cleanup;\n\ncleanup:\n    krb5_free_authdata(ctx->k5c, creds.authdata);\n\n    return code;\n}\n\n/*\n * Parse the IAKERB token in input_token and process the KDC\n * response.\n *\n * Emit the next KDC request, if any, in output_token.\n */\nstatic krb5_error_code\niakerb_initiator_step(iakerb_ctx_id_t ctx,\n                      krb5_gss_cred_id_t cred,\n                      krb5_gss_name_t name,\n                      OM_uint32 time_req,\n                      const gss_buffer_t input_token,\n                      gss_buffer_t output_token)\n{\n    krb5_error_code code = 0;\n    krb5_data in = empty_data(), out = empty_data(), realm = empty_data();\n    krb5_data *cookie = NULL;\n    OM_uint32 tmp;\n    unsigned int flags = 0;\n    krb5_ticket_times times;\n\n    output_token->length = 0;\n    output_token->value = NULL;\n\n    if (input_token != GSS_C_NO_BUFFER) {\n        code = iakerb_parse_token(ctx, 0, input_token, NULL, &cookie, &in);\n        if (code != 0)\n            goto cleanup;\n\n        code = iakerb_save_token(ctx, input_token);\n        if (code != 0)\n            goto cleanup;\n    }\n\n    switch (ctx->state) {\n    case IAKERB_AS_REQ:\n        if (ctx->icc == NULL) {\n            code = iakerb_init_creds_ctx(ctx, cred, time_req);\n            if (code != 0)\n                goto cleanup;\n        }\n\n        code = krb5_init_creds_step(ctx->k5c, ctx->icc, &in, &out, &realm,\n                                    &flags);\n        if (code != 0) {\n            if (cred->have_tgt) {\n                /* We were trying to refresh; keep going with current creds. */\n                ctx->state = IAKERB_TGS_REQ;\n                krb5_clear_error_message(ctx->k5c);\n            } else {\n                goto cleanup;\n            }\n        } else if (!(flags & KRB5_INIT_CREDS_STEP_FLAG_CONTINUE)) {\n            krb5_init_creds_get_times(ctx->k5c, ctx->icc, &times);\n            kg_cred_set_initial_refresh(ctx->k5c, cred, &times);\n            cred->expire = times.endtime;\n\n            krb5_init_creds_free(ctx->k5c, ctx->icc);\n            ctx->icc = NULL;\n\n            ctx->state = IAKERB_TGS_REQ;\n        } else\n            break;\n        in = empty_data();\n        /* Done with AS request; fall through to TGS request. */\n    case IAKERB_TGS_REQ:\n        if (ctx->tcc == NULL) {\n            code = iakerb_tkt_creds_ctx(ctx, cred, name, time_req);\n            if (code != 0)\n                goto cleanup;\n        }\n\n        code = krb5_tkt_creds_step(ctx->k5c, ctx->tcc, &in, &out, &realm,\n                                   &flags);\n        if (code != 0)\n            goto cleanup;\n        if (!(flags & KRB5_TKT_CREDS_STEP_FLAG_CONTINUE)) {\n            krb5_tkt_creds_get_times(ctx->k5c, ctx->tcc, &times);\n            cred->expire = times.endtime;\n\n            krb5_tkt_creds_free(ctx->k5c, ctx->tcc);\n            ctx->tcc = NULL;\n\n            ctx->state = IAKERB_AP_REQ;\n        } else\n            break;\n        /* Done with TGS request; fall through to AP request. */\n    case IAKERB_AP_REQ:\n        break;\n    }\n\n    if (out.length != 0) {\n        assert(ctx->state != IAKERB_AP_REQ);\n\n        code = iakerb_make_token(ctx, &realm, cookie, &out,\n                                 (input_token == GSS_C_NO_BUFFER),\n                                 output_token);\n        if (code != 0)\n            goto cleanup;\n\n        /* Save the token for generating a future checksum */\n        code = iakerb_save_token(ctx, output_token);\n        if (code != 0)\n            goto cleanup;\n\n        ctx->count++;\n    }\n\ncleanup:\n    if (code != 0)\n        gss_release_buffer(&tmp, output_token);\n    krb5_free_data(ctx->k5c, cookie);\n    krb5_free_data_contents(ctx->k5c, &out);\n    krb5_free_data_contents(ctx->k5c, &realm);\n\n    return code;\n}\n\n/*\n * Determine the starting IAKERB state for a context. If we already\n * have a ticket, we may not need to do IAKERB at all.\n */\nstatic krb5_error_code\niakerb_get_initial_state(iakerb_ctx_id_t ctx,\n                         krb5_gss_cred_id_t cred,\n                         krb5_gss_name_t target,\n                         OM_uint32 time_req,\n                         enum iakerb_state *state)\n{\n    krb5_creds in_creds, *out_creds = NULL;\n    krb5_error_code code;\n\n    memset(&in_creds, 0, sizeof(in_creds));\n\n    in_creds.client = cred->name->princ;\n    in_creds.server = target->princ;\n\n    if (cred->name->ad_context != NULL) {\n        code = krb5_authdata_export_authdata(ctx->k5c,\n                                             cred->name->ad_context,\n                                             AD_USAGE_TGS_REQ,\n                                             &in_creds.authdata);\n        if (code != 0)\n            goto cleanup;\n    }\n\n    if (time_req != 0 && time_req != GSS_C_INDEFINITE) {\n        krb5_timestamp now;\n\n        code = krb5_timeofday(ctx->k5c, &now);\n        if (code != 0)\n            goto cleanup;\n\n        in_creds.times.endtime = now + time_req;\n    }\n\n    /* Make an AS request if we have no creds or it's time to refresh them. */\n    if (cred->expire == 0 || kg_cred_time_to_refresh(ctx->k5c, cred)) {\n        *state = IAKERB_AS_REQ;\n        code = 0;\n        goto cleanup;\n    }\n\n    code = krb5_get_credentials(ctx->k5c, KRB5_GC_CACHED, cred->ccache,\n                                &in_creds, &out_creds);\n    if (code == KRB5_CC_NOTFOUND || code == KRB5_CC_NOT_KTYPE) {\n        *state = cred->have_tgt ? IAKERB_TGS_REQ : IAKERB_AS_REQ;\n        code = 0;\n    } else if (code == 0) {\n        *state = IAKERB_AP_REQ;\n        krb5_free_creds(ctx->k5c, out_creds);\n    }\n\ncleanup:\n    krb5_free_authdata(ctx->k5c, in_creds.authdata);\n\n    return code;\n}\n\n/*\n * Allocate and initialise an IAKERB context\n */\nstatic krb5_error_code\niakerb_alloc_context(iakerb_ctx_id_t *pctx)\n{\n    iakerb_ctx_id_t ctx;\n    krb5_error_code code;\n\n    *pctx = NULL;\n\n    ctx = k5alloc(sizeof(*ctx), &code);\n    if (ctx == NULL)\n        goto cleanup;\n    ctx->defcred = GSS_C_NO_CREDENTIAL;\n    ctx->magic = KG_IAKERB_CONTEXT;\n    ctx->state = IAKERB_AS_REQ;\n    ctx->count = 0;\n\n    code = krb5_gss_init_context(&ctx->k5c);\n    if (code != 0)\n        goto cleanup;\n\n    *pctx = ctx;\n\ncleanup:\n    if (code != 0)\n        iakerb_release_context(ctx);\n\n    return code;\n}\n\n/*\n * Delete an IAKERB context. This can also accept Kerberos context\n * handles. The heuristic is similar to SPNEGO's delete_sec_context.\n */\nOM_uint32 KRB5_CALLCONV\niakerb_gss_delete_sec_context(OM_uint32 *minor_status,\n                              gss_ctx_id_t *context_handle,\n                              gss_buffer_t output_token)\n{\n    OM_uint32 major_status = GSS_S_COMPLETE;\n\n    if (output_token != GSS_C_NO_BUFFER) {\n        output_token->length = 0;\n        output_token->value = NULL;\n    }\n\n    *minor_status = 0;\n\n    if (*context_handle != GSS_C_NO_CONTEXT) {\n        iakerb_ctx_id_t iakerb_ctx = (iakerb_ctx_id_t)*context_handle;\n\n        if (iakerb_ctx->magic == KG_IAKERB_CONTEXT) {\n            iakerb_release_context(iakerb_ctx);\n            *context_handle = GSS_C_NO_CONTEXT;\n        } else {\n            assert(iakerb_ctx->magic == KG_CONTEXT);\n\n            major_status = krb5_gss_delete_sec_context(minor_status,\n                                                       context_handle,\n                                                       output_token);\n        }\n    }\n\n    return major_status;\n}\n\nstatic krb5_boolean\niakerb_is_iakerb_token(const gss_buffer_t token)\n{\n    krb5_error_code code;\n    unsigned int bodysize = token->length;\n    unsigned char *ptr = token->value;\n\n    code = g_verify_token_header(gss_mech_iakerb,\n                                 &bodysize, &ptr,\n                                 IAKERB_TOK_PROXY,\n                                 token->length, 0);\n\n    return (code == 0);\n}\n\nstatic void\niakerb_make_exts(iakerb_ctx_id_t ctx, krb5_gss_ctx_ext_rec *exts)\n{\n    memset(exts, 0, sizeof(*exts));\n\n    if (ctx->conv.length != 0)\n        exts->iakerb.conv = &ctx->conv;\n}\n\nOM_uint32 KRB5_CALLCONV\niakerb_gss_accept_sec_context(OM_uint32 *minor_status,\n                              gss_ctx_id_t *context_handle,\n                              gss_cred_id_t verifier_cred_handle,\n                              gss_buffer_t input_token,\n                              gss_channel_bindings_t input_chan_bindings,\n                              gss_name_t *src_name,\n                              gss_OID *mech_type,\n                              gss_buffer_t output_token,\n                              OM_uint32 *ret_flags,\n                              OM_uint32 *time_rec,\n                              gss_cred_id_t *delegated_cred_handle)\n{\n    OM_uint32 major_status = GSS_S_FAILURE;\n    OM_uint32 code;\n    iakerb_ctx_id_t ctx;\n    int initialContextToken = (*context_handle == GSS_C_NO_CONTEXT);\n\n    if (initialContextToken) {\n        code = iakerb_alloc_context(&ctx);\n        if (code != 0)\n            goto cleanup;\n\n    } else\n        ctx = (iakerb_ctx_id_t)*context_handle;\n\n    if (iakerb_is_iakerb_token(input_token)) {\n        if (ctx->gssc != GSS_C_NO_CONTEXT) {\n            /* We shouldn't get an IAKERB token now. */\n            code = G_WRONG_TOKID;\n            major_status = GSS_S_DEFECTIVE_TOKEN;\n            goto cleanup;\n        }\n        code = iakerb_acceptor_step(ctx, initialContextToken,\n                                    input_token, output_token);\n        if (code == (OM_uint32)KRB5_BAD_MSIZE)\n            major_status = GSS_S_DEFECTIVE_TOKEN;\n        if (code != 0)\n            goto cleanup;\n        if (initialContextToken) {\n            *context_handle = (gss_ctx_id_t)ctx;\n            ctx = NULL;\n        }\n        if (src_name != NULL)\n            *src_name = GSS_C_NO_NAME;\n        if (mech_type != NULL)\n            *mech_type = (gss_OID)gss_mech_iakerb;\n        if (ret_flags != NULL)\n            *ret_flags = 0;\n        if (time_rec != NULL)\n            *time_rec = 0;\n        if (delegated_cred_handle != NULL)\n            *delegated_cred_handle = GSS_C_NO_CREDENTIAL;\n        major_status = GSS_S_CONTINUE_NEEDED;\n    } else {\n        krb5_gss_ctx_ext_rec exts;\n\n        iakerb_make_exts(ctx, &exts);\n\n        major_status = krb5_gss_accept_sec_context_ext(&code,\n                                                       &ctx->gssc,\n                                                       verifier_cred_handle,\n                                                       input_token,\n                                                       input_chan_bindings,\n                                                       src_name,\n                                                       NULL,\n                                                       output_token,\n                                                       ret_flags,\n                                                       time_rec,\n                                                       delegated_cred_handle,\n                                                       &exts);\n        if (major_status == GSS_S_COMPLETE) {\n            *context_handle = ctx->gssc;\n            ctx->gssc = NULL;\n            iakerb_release_context(ctx);\n        }\n        if (mech_type != NULL)\n            *mech_type = (gss_OID)gss_mech_krb5;\n    }\n\ncleanup:\n    if (initialContextToken && GSS_ERROR(major_status)) {\n        iakerb_release_context(ctx);\n        *context_handle = GSS_C_NO_CONTEXT;\n    }\n\n    *minor_status = code;\n    return major_status;\n}\n\nOM_uint32 KRB5_CALLCONV\niakerb_gss_init_sec_context(OM_uint32 *minor_status,\n                            gss_cred_id_t claimant_cred_handle,\n                            gss_ctx_id_t *context_handle,\n                            gss_name_t target_name,\n                            gss_OID mech_type,\n                            OM_uint32 req_flags,\n                            OM_uint32 time_req,\n                            gss_channel_bindings_t input_chan_bindings,\n                            gss_buffer_t input_token,\n                            gss_OID *actual_mech_type,\n                            gss_buffer_t output_token,\n                            OM_uint32 *ret_flags,\n                            OM_uint32 *time_rec)\n{\n    OM_uint32 major_status = GSS_S_FAILURE;\n    krb5_error_code code;\n    iakerb_ctx_id_t ctx;\n    krb5_gss_cred_id_t kcred;\n    krb5_gss_name_t kname;\n    krb5_boolean cred_locked = FALSE;\n    int initialContextToken = (*context_handle == GSS_C_NO_CONTEXT);\n\n    if (initialContextToken) {\n        code = iakerb_alloc_context(&ctx);\n        if (code != 0) {\n            *minor_status = code;\n            goto cleanup;\n        }\n        if (claimant_cred_handle == GSS_C_NO_CREDENTIAL) {\n            major_status = iakerb_gss_acquire_cred(minor_status, NULL,\n                                                   GSS_C_INDEFINITE,\n                                                   GSS_C_NULL_OID_SET,\n                                                   GSS_C_INITIATE,\n                                                   &ctx->defcred, NULL, NULL);\n            if (GSS_ERROR(major_status))\n                goto cleanup;\n            claimant_cred_handle = ctx->defcred;\n        }\n    } else {\n        ctx = (iakerb_ctx_id_t)*context_handle;\n        if (claimant_cred_handle == GSS_C_NO_CREDENTIAL)\n            claimant_cred_handle = ctx->defcred;\n    }\n\n    kname = (krb5_gss_name_t)target_name;\n\n    major_status = kg_cred_resolve(minor_status, ctx->k5c,\n                                   claimant_cred_handle, target_name);\n    if (GSS_ERROR(major_status))\n        goto cleanup;\n    cred_locked = TRUE;\n    kcred = (krb5_gss_cred_id_t)claimant_cred_handle;\n\n    major_status = GSS_S_FAILURE;\n\n    if (initialContextToken) {\n        code = iakerb_get_initial_state(ctx, kcred, kname, time_req,\n                                        &ctx->state);\n        if (code != 0) {\n            *minor_status = code;\n            goto cleanup;\n        }\n        *context_handle = (gss_ctx_id_t)ctx;\n    }\n\n    if (ctx->state != IAKERB_AP_REQ) {\n        /* We need to do IAKERB. */\n        code = iakerb_initiator_step(ctx,\n                                     kcred,\n                                     kname,\n                                     time_req,\n                                     input_token,\n                                     output_token);\n        if (code == KRB5_BAD_MSIZE)\n            major_status = GSS_S_DEFECTIVE_TOKEN;\n        if (code != 0) {\n            *minor_status = code;\n            goto cleanup;\n        }\n    }\n\n    if (ctx->state == IAKERB_AP_REQ) {\n        krb5_gss_ctx_ext_rec exts;\n\n        if (cred_locked) {\n            k5_mutex_unlock(&kcred->lock);\n            cred_locked = FALSE;\n        }\n\n        iakerb_make_exts(ctx, &exts);\n\n        if (ctx->gssc == GSS_C_NO_CONTEXT)\n            input_token = GSS_C_NO_BUFFER;\n\n        /* IAKERB is finished, or we skipped to Kerberos directly. */\n        major_status = krb5_gss_init_sec_context_ext(minor_status,\n                                                     (gss_cred_id_t) kcred,\n                                                     &ctx->gssc,\n                                                     target_name,\n                                                     (gss_OID)gss_mech_iakerb,\n                                                     req_flags,\n                                                     time_req,\n                                                     input_chan_bindings,\n                                                     input_token,\n                                                     NULL,\n                                                     output_token,\n                                                     ret_flags,\n                                                     time_rec,\n                                                     &exts);\n        if (major_status == GSS_S_COMPLETE) {\n            *context_handle = ctx->gssc;\n            ctx->gssc = GSS_C_NO_CONTEXT;\n            iakerb_release_context(ctx);\n        }\n        if (actual_mech_type != NULL)\n            *actual_mech_type = (gss_OID)gss_mech_krb5;\n    } else {\n        if (actual_mech_type != NULL)\n            *actual_mech_type = (gss_OID)gss_mech_iakerb;\n        if (ret_flags != NULL)\n            *ret_flags = 0;\n        if (time_rec != NULL)\n            *time_rec = 0;\n        major_status = GSS_S_CONTINUE_NEEDED;\n    }\n\ncleanup:\n    if (cred_locked)\n        k5_mutex_unlock(&kcred->lock);\n    if (initialContextToken && GSS_ERROR(major_status)) {\n        iakerb_release_context(ctx);\n        *context_handle = GSS_C_NO_CONTEXT;\n    }\n\n    return major_status;\n}\n"], "fixing_code": ["/* -*- mode: c; indent-tabs-mode: nil -*- */\n/*\n * Copyright 2000, 2008 by the Massachusetts Institute of Technology.\n * All Rights Reserved.\n *\n * Export of this software from the United States of America may\n *   require a specific license from the United States Government.\n *   It is the responsibility of any person or organization contemplating\n *   export to obtain such a license before exporting.\n *\n * WITHIN THAT CONSTRAINT, permission to use, copy, modify, and\n * distribute this software and its documentation for any purpose and\n * without fee is hereby granted, provided that the above copyright\n * notice appear in all copies and that both that copyright notice and\n * this permission notice appear in supporting documentation, and that\n * the name of M.I.T. not be used in advertising or publicity pertaining\n * to distribution of the software without specific, written prior\n * permission.  Furthermore if you modify this software you must label\n * your software as modified software and not distribute it in such a\n * fashion that it might be confused with the original M.I.T. software.\n * M.I.T. makes no representations about the suitability of\n * this software for any purpose.  It is provided \"as is\" without express\n * or implied warranty.\n *\n */\n/*\n * Copyright 1993 by OpenVision Technologies, Inc.\n *\n * Permission to use, copy, modify, distribute, and sell this software\n * and its documentation for any purpose is hereby granted without fee,\n * provided that the above copyright notice appears in all copies and\n * that both that copyright notice and this permission notice appear in\n * supporting documentation, and that the name of OpenVision not be used\n * in advertising or publicity pertaining to distribution of the software\n * without specific, written prior permission. OpenVision makes no\n * representations about the suitability of this software for any\n * purpose.  It is provided \"as is\" without express or implied warranty.\n *\n * OPENVISION DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,\n * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO\n * EVENT SHALL OPENVISION BE LIABLE FOR ANY SPECIAL, INDIRECT OR\n * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF\n * USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\n * OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\n * PERFORMANCE OF THIS SOFTWARE.\n */\n\n#ifndef _GSSAPIP_KRB5_H_\n#define _GSSAPIP_KRB5_H_\n\n#include <k5-int.h>\n\n#ifdef HAVE_MEMORY_H\n#include <memory.h>\n#endif\n\n/* work around sunos braindamage */\n#ifdef major\n#undef major\n#endif\n#ifdef minor\n#undef minor\n#endif\n\n#include \"gssapiP_generic.h\"\n\n/* The include of gssapi_krb5.h will dtrt with the above #defines in\n * effect.\n */\n#include \"gssapi_krb5.h\"\n#include \"gssapi_err_krb5.h\"\n#include \"gssapi_ext.h\"\n\n/* for debugging */\n#undef CFX_EXERCISE\n\n/** constants **/\n\n#define GSS_MECH_KRB5_OID_LENGTH 9\n#define GSS_MECH_KRB5_OID \"\\052\\206\\110\\206\\367\\022\\001\\002\\002\"\n\n#define GSS_MECH_KRB5_OLD_OID_LENGTH 5\n#define GSS_MECH_KRB5_OLD_OID \"\\053\\005\\001\\005\\002\"\n\n/* Incorrect krb5 mech OID emitted by MS. */\n#define GSS_MECH_KRB5_WRONG_OID_LENGTH 9\n#define GSS_MECH_KRB5_WRONG_OID \"\\052\\206\\110\\202\\367\\022\\001\\002\\002\"\n\n/* IAKERB variant */\n#define GSS_MECH_IAKERB_OID_LENGTH 6\n#define GSS_MECH_IAKERB_OID \"\\053\\006\\001\\005\\002\\005\"\n\nextern const gss_OID_set_desc * const kg_all_mechs;\n\n#define CKSUMTYPE_KG_CB         0x8003\n\n#define KG_TOK_CTX_AP_REQ       0x0100\n#define KG_TOK_CTX_AP_REP       0x0200\n#define KG_TOK_CTX_ERROR        0x0300\n#define KG_TOK_SIGN_MSG         0x0101\n#define KG_TOK_SEAL_MSG         0x0201\n#define KG_TOK_MIC_MSG          0x0101\n#define KG_TOK_WRAP_MSG         0x0201\n#define KG_TOK_DEL_CTX          0x0102\n#define KG2_TOK_MIC_MSG         0x0404\n#define KG2_TOK_WRAP_MSG        0x0504\n#define KG2_TOK_DEL_CTX         0x0405\n#define IAKERB_TOK_PROXY        0x0501\n\n#define KRB5_GSS_FOR_CREDS_OPTION 1\n\n#define KG2_RESP_FLAG_ERROR             0x0001\n#define KG2_RESP_FLAG_DELEG_OK          0x0002\n\n/** CFX flags **/\n#define FLAG_SENDER_IS_ACCEPTOR 0x01\n#define FLAG_WRAP_CONFIDENTIAL  0x02\n#define FLAG_ACCEPTOR_SUBKEY    0x04\n\n/* These are to be stored in little-endian order, i.e., des-mac is\n   stored as 02 00.  */\nenum sgn_alg {\n    SGN_ALG_DES_MAC_MD5           = 0x0000,\n    SGN_ALG_MD2_5                 = 0x0001,\n    SGN_ALG_DES_MAC               = 0x0002,\n    SGN_ALG_3                     = 0x0003, /* not published */\n    SGN_ALG_HMAC_MD5              = 0x0011, /* microsoft w2k;  */\n    SGN_ALG_HMAC_SHA1_DES3_KD     = 0x0004\n};\nenum seal_alg {\n    SEAL_ALG_NONE            = 0xffff,\n    SEAL_ALG_DES             = 0x0000,\n    SEAL_ALG_1               = 0x0001, /* not published */\n    SEAL_ALG_MICROSOFT_RC4   = 0x0010, /* microsoft w2k;  */\n    SEAL_ALG_DES3KD          = 0x0002\n};\n\n/* for 3DES */\n#define KG_USAGE_SEAL 22\n#define KG_USAGE_SIGN 23\n#define KG_USAGE_SEQ  24\n\n/* for draft-ietf-krb-wg-gssapi-cfx-01 */\n#define KG_USAGE_ACCEPTOR_SEAL  22\n#define KG_USAGE_ACCEPTOR_SIGN  23\n#define KG_USAGE_INITIATOR_SEAL 24\n#define KG_USAGE_INITIATOR_SIGN 25\n\nenum qop {\n    GSS_KRB5_INTEG_C_QOP_MD5       = 0x0001, /* *partial* MD5 = \"MD2.5\" */\n    GSS_KRB5_INTEG_C_QOP_DES_MD5   = 0x0002,\n    GSS_KRB5_INTEG_C_QOP_DES_MAC   = 0x0003,\n    GSS_KRB5_INTEG_C_QOP_HMAC_SHA1 = 0x0004,\n    GSS_KRB5_INTEG_C_QOP_MASK      = 0x00ff,\n    GSS_KRB5_CONF_C_QOP_DES        = 0x0100,\n    GSS_KRB5_CONF_C_QOP_DES3_KD    = 0x0200,\n    GSS_KRB5_CONF_C_QOP_MASK       = 0xff00\n};\n\n/** internal types **/\n\ntypedef struct _krb5_gss_name_rec {\n    krb5_principal princ;       /* immutable */\n    char *service;              /* immutable */\n    char *host;                 /* immutable */\n    k5_mutex_t lock;            /* protects ad_context only for now */\n    krb5_authdata_context ad_context;\n} krb5_gss_name_rec, *krb5_gss_name_t;\n\ntypedef struct _krb5_gss_cred_id_rec {\n    /* protect against simultaneous accesses */\n    k5_mutex_t lock;\n\n    /* name/type of credential */\n    gss_cred_usage_t usage;\n    krb5_gss_name_t name;\n    krb5_principal impersonator;\n    unsigned int default_identity : 1;\n    unsigned int iakerb_mech : 1;\n    unsigned int destroy_ccache : 1;\n    unsigned int suppress_ci_flags : 1;\n\n    /* keytab (accept) data */\n    krb5_keytab keytab;\n    krb5_rcache rcache;\n\n    /* ccache (init) data */\n    krb5_ccache ccache;\n    krb5_keytab client_keytab;\n    krb5_boolean have_tgt;\n    krb5_timestamp expire;\n    krb5_timestamp refresh_time;\n    krb5_enctype *req_enctypes;  /* limit negotiated enctypes to this list */\n    char *password;\n} krb5_gss_cred_id_rec, *krb5_gss_cred_id_t;\n\ntypedef struct _krb5_gss_ctx_ext_rec {\n    struct {\n        krb5_data *conv;\n        int verified;\n    } iakerb;\n} krb5_gss_ctx_ext_rec, *krb5_gss_ctx_ext_t;\n\ntypedef struct _krb5_gss_ctx_id_rec {\n    krb5_magic magic;\n    unsigned int initiate : 1;   /* nonzero if initiating, zero if accepting */\n    unsigned int established : 1;\n    unsigned int have_acceptor_subkey : 1;\n    unsigned int seed_init : 1;  /* XXX tested but never actually set */\n    unsigned int terminated : 1;\n    OM_uint32 gss_flags;\n    unsigned char seed[16];\n    krb5_gss_name_t here;\n    krb5_gss_name_t there;\n    krb5_key subkey; /* One of two potential keys to use with RFC 4121\n                      * packets; this key must always be set. */\n    int signalg;\n    size_t cksum_size;\n    int sealalg;\n    krb5_key enc; /* RFC 1964 encryption key; seq xored with a constant\n                   * for DES, seq for other RFC 1964 enctypes  */\n    krb5_key seq; /* RFC 1964 sequencing key */\n    krb5_ticket_times krb_times;\n    krb5_flags krb_flags;\n    /* XXX these used to be signed.  the old spec is inspecific, and\n       the new spec specifies unsigned.  I don't believe that the change\n       affects the wire encoding. */\n    uint64_t seq_send;\n    uint64_t seq_recv;\n    g_seqnum_state seqstate;\n    krb5_context k5_context;\n    krb5_auth_context auth_context;\n    gss_OID_desc *mech_used;\n    /* Protocol spec revision for sending packets\n       0 => RFC 1964 with 3DES and RC4 enhancements\n       1 => RFC 4121\n       No others defined so far.  It is always permitted to receive\n       tokens in RFC 4121 format.  If enc is non-null, receiving RFC\n       1964 tokens is permitted.*/\n    int proto;\n    krb5_cksumtype cksumtype;    /* for \"main\" subkey */\n    krb5_key acceptor_subkey; /* CFX only */\n    krb5_cksumtype acceptor_subkey_cksumtype;\n    int cred_rcache;             /* did we get rcache from creds? */\n    krb5_authdata **authdata;\n} krb5_gss_ctx_id_rec, *krb5_gss_ctx_id_t;\n\nextern g_set kg_vdb;\n\n#ifndef LEAN_CLIENT\nextern k5_mutex_t gssint_krb5_keytab_lock;\n#endif /* LEAN_CLIENT */\n\n/** helper functions **/\n\nOM_uint32 kg_get_defcred\n(OM_uint32 *minor_status,\n gss_cred_id_t *cred);\n\nkrb5_error_code kg_checksum_channel_bindings\n(krb5_context context, gss_channel_bindings_t cb,\n krb5_checksum *cksum);\n\nkrb5_error_code kg_make_seq_num (krb5_context context,\n                                 krb5_key key,\n                                 int direction, krb5_ui_4 seqnum, unsigned char *cksum,\n                                 unsigned char *buf);\n\nkrb5_error_code kg_get_seq_num (krb5_context context,\n                                krb5_key key,\n                                unsigned char *cksum, unsigned char *buf, int *direction,\n                                krb5_ui_4 *seqnum);\n\nkrb5_error_code kg_make_seed (krb5_context context,\n                              krb5_key key,\n                              unsigned char *seed);\n\nkrb5_error_code\nkg_setup_keys(krb5_context context,\n              krb5_gss_ctx_id_rec *ctx,\n              krb5_key subkey,\n              krb5_cksumtype *cksumtype);\n\nint kg_confounder_size (krb5_context context, krb5_enctype enctype);\n\nkrb5_error_code kg_make_confounder (krb5_context context,\n                                    krb5_enctype enctype, unsigned char *buf);\n\nkrb5_error_code kg_encrypt (krb5_context context,\n                            krb5_key key, int usage,\n                            krb5_pointer iv,\n                            krb5_const_pointer in,\n                            krb5_pointer out,\n                            unsigned int length);\n\n/* Encrypt length bytes at ptr in place, with the given key and usage.  If\n * iv is not NULL, use it as the cipher state. */\nkrb5_error_code kg_encrypt_inplace(krb5_context context, krb5_key key,\n                                   int usage, krb5_pointer iv,\n                                   krb5_pointer ptr, unsigned int length);\n\nkrb5_error_code kg_encrypt_iov (krb5_context context,\n                                int proto, int dce_style,\n                                size_t ec, size_t rrc,\n                                krb5_key key, int usage,\n                                krb5_pointer iv,\n                                gss_iov_buffer_desc *iov,\n                                int iov_count);\n\nkrb5_error_code\nkg_arcfour_docrypt (const krb5_keyblock *keyblock, int usage,\n                    const unsigned char *kd_data, size_t kd_data_len,\n                    const unsigned char *input_buf, size_t input_len,\n                    unsigned char *output_buf);\n\nkrb5_error_code\nkg_arcfour_docrypt_iov (krb5_context context,\n                        const krb5_keyblock *keyblock, int usage,\n                        const unsigned char *kd_data, size_t kd_data_len,\n                        gss_iov_buffer_desc *iov,\n                        int iov_count);\n\nkrb5_error_code kg_decrypt (krb5_context context,\n                            krb5_key key,  int usage,\n                            krb5_pointer iv,\n                            krb5_const_pointer in,\n                            krb5_pointer out,\n                            unsigned int length);\n\nkrb5_error_code kg_decrypt_iov (krb5_context context,\n                                int proto, int dce_style,\n                                size_t ec, size_t rrc,\n                                krb5_key key,  int usage,\n                                krb5_pointer iv,\n                                gss_iov_buffer_desc *iov,\n                                int iov_count);\n\nOM_uint32 kg_seal (OM_uint32 *minor_status,\n                   gss_ctx_id_t context_handle,\n                   int conf_req_flag,\n                   gss_qop_t qop_req,\n                   gss_buffer_t input_message_buffer,\n                   int *conf_state,\n                   gss_buffer_t output_message_buffer,\n                   int toktype);\n\nOM_uint32 kg_unseal (OM_uint32 *minor_status,\n                     gss_ctx_id_t context_handle,\n                     gss_buffer_t input_token_buffer,\n                     gss_buffer_t message_buffer,\n                     int *conf_state,\n                     gss_qop_t *qop_state,\n                     int toktype);\n\nOM_uint32 kg_seal_size (OM_uint32 *minor_status,\n                        gss_ctx_id_t context_handle,\n                        int conf_req_flag,\n                        gss_qop_t qop_req,\n                        OM_uint32 output_size,\n                        OM_uint32 *input_size);\n\nkrb5_error_code kg_ctx_size (krb5_context kcontext,\n                             krb5_pointer arg,\n                             size_t *sizep);\n\nkrb5_error_code kg_ctx_externalize (krb5_context kcontext,\n                                    krb5_pointer arg,\n                                    krb5_octet **buffer,\n                                    size_t *lenremain);\n\nkrb5_error_code kg_ctx_internalize (krb5_context kcontext,\n                                    krb5_pointer *argp,\n                                    krb5_octet **buffer,\n                                    size_t *lenremain);\n\nOM_uint32 kg_sync_ccache_name (krb5_context context, OM_uint32 *minor_status);\n\nOM_uint32 kg_caller_provided_ccache_name (OM_uint32 *minor_status,\n                                          int *out_caller_provided_name);\n\nOM_uint32 kg_get_ccache_name (OM_uint32 *minor_status,\n                              const char **out_name);\n\nOM_uint32 kg_set_ccache_name (OM_uint32 *minor_status,\n                              const char *name);\n\n/* AEAD */\n\nkrb5_error_code gss_krb5int_make_seal_token_v3_iov(krb5_context context,\n                           krb5_gss_ctx_id_rec *ctx,\n                           int conf_req_flag,\n                           int *conf_state,\n                           gss_iov_buffer_desc *iov,\n                           int iov_count,\n                           int toktype);\n\nOM_uint32 gss_krb5int_unseal_v3_iov(krb5_context context,\n                          OM_uint32 *minor_status,\n                          krb5_gss_ctx_id_rec *ctx,\n                          gss_iov_buffer_desc *iov,\n                          int iov_count,\n                          int *conf_state,\n                          gss_qop_t *qop_state,\n                          int toktype);\n\ngss_iov_buffer_t kg_locate_iov (gss_iov_buffer_desc *iov,\n              int iov_count,\n              OM_uint32 type);\n\ngss_iov_buffer_t kg_locate_header_iov(gss_iov_buffer_desc *iov, int iov_count,\n                                      int toktype);\n\nvoid kg_iov_msglen(gss_iov_buffer_desc *iov,\n              int iov_count,\n              size_t *data_length,\n              size_t *assoc_data_length);\n\nvoid kg_release_iov(gss_iov_buffer_desc *iov,\n               int iov_count);\n\nkrb5_error_code kg_make_checksum_iov_v1(krb5_context context,\n                krb5_cksumtype type,\n                size_t token_cksum_len,\n                krb5_key seq,\n                krb5_key enc, /* for conf len */\n                krb5_keyusage sign_usage,\n                gss_iov_buffer_desc *iov,\n                int iov_count,\n                int toktype,\n                krb5_checksum *checksum);\n\nkrb5_error_code kg_make_checksum_iov_v3(krb5_context context,\n                krb5_cksumtype type,\n                size_t rrc,\n                krb5_key key,\n                krb5_keyusage sign_usage,\n                gss_iov_buffer_desc *iov,\n                int iov_count,\n                int toktype);\n\nkrb5_error_code kg_verify_checksum_iov_v3(krb5_context context,\n                krb5_cksumtype type,\n                size_t rrc,\n                krb5_key key,\n                krb5_keyusage sign_usage,\n                gss_iov_buffer_desc *iov,\n                int iov_count,\n                int toktype,\n                krb5_boolean *valid);\n\nOM_uint32 kg_seal_iov (OM_uint32 *minor_status,\n            gss_ctx_id_t context_handle,\n            int conf_req_flag,\n            gss_qop_t qop_req,\n            int *conf_state,\n            gss_iov_buffer_desc *iov,\n            int iov_count,\n            int toktype);\n\nOM_uint32 kg_unseal_iov (OM_uint32 *minor_status,\n            gss_ctx_id_t context_handle,\n            int *conf_state,\n            gss_qop_t *qop_state,\n            gss_iov_buffer_desc *iov,\n            int iov_count,\n            int toktype);\n\nOM_uint32 kg_seal_iov_length(OM_uint32 *minor_status,\n           gss_ctx_id_t context_handle,\n           int conf_req_flag,\n           gss_qop_t qop_req,\n           int *conf_state,\n           gss_iov_buffer_desc *iov,\n           int iov_count,\n           int toktype);\n\nkrb5_cryptotype kg_translate_flag_iov(OM_uint32 type);\n\nOM_uint32 kg_fixup_padding_iov(OM_uint32 *minor_status,\n        gss_iov_buffer_desc *iov,\n        int iov_count);\n\nkrb5_boolean kg_integ_only_iov(gss_iov_buffer_desc *iov, int iov_count);\n\nkrb5_error_code kg_allocate_iov(gss_iov_buffer_t iov, size_t size);\n\nkrb5_error_code\nkrb5_to_gss_cred(krb5_context context,\n                 krb5_creds *creds,\n                 krb5_gss_cred_id_t *out_cred);\n\nkrb5_boolean\nkg_cred_time_to_refresh(krb5_context context, krb5_gss_cred_id_rec *cred);\n\nvoid\nkg_cred_set_initial_refresh(krb5_context context, krb5_gss_cred_id_rec *cred,\n                            krb5_ticket_times *times);\n\nOM_uint32\nkg_cred_resolve(OM_uint32 *minor_status, krb5_context context,\n                gss_cred_id_t cred_handle, gss_name_t target_name);\n\n/** declarations of internal name mechanism functions **/\n\nOM_uint32 KRB5_CALLCONV krb5_gss_acquire_cred\n(OM_uint32*,       /* minor_status */\n gss_name_t,       /* desired_name */\n OM_uint32,        /* time_req */\n gss_OID_set,      /* desired_mechs */\n gss_cred_usage_t, /* cred_usage */\n gss_cred_id_t*,   /* output_cred_handle */\n gss_OID_set*,     /* actual_mechs */\n OM_uint32*        /* time_rec */\n);\n\nOM_uint32 KRB5_CALLCONV iakerb_gss_acquire_cred\n(OM_uint32*,       /* minor_status */\n gss_name_t,       /* desired_name */\n OM_uint32,        /* time_req */\n gss_OID_set,      /* desired_mechs */\n gss_cred_usage_t, /* cred_usage */\n gss_cred_id_t*,   /* output_cred_handle */\n gss_OID_set*,     /* actual_mechs */\n OM_uint32*        /* time_rec */\n);\n\nOM_uint32 KRB5_CALLCONV\nkrb5_gss_acquire_cred_with_password(\n    OM_uint32 *minor_status,\n    const gss_name_t desired_name,\n    const gss_buffer_t password,\n    OM_uint32 time_req,\n    const gss_OID_set desired_mechs,\n    int cred_usage,\n    gss_cred_id_t *output_cred_handle,\n    gss_OID_set *actual_mechs,\n    OM_uint32 *time_rec);\n\nOM_uint32 KRB5_CALLCONV\niakerb_gss_acquire_cred_with_password(\n    OM_uint32 *minor_status,\n    const gss_name_t desired_name,\n    const gss_buffer_t password,\n    OM_uint32 time_req,\n    const gss_OID_set desired_mechs,\n    int cred_usage,\n    gss_cred_id_t *output_cred_handle,\n    gss_OID_set *actual_mechs,\n    OM_uint32 *time_rec);\n\nOM_uint32 KRB5_CALLCONV krb5_gss_release_cred\n(OM_uint32*,       /* minor_status */\n gss_cred_id_t*    /* cred_handle */\n);\n\nOM_uint32 KRB5_CALLCONV krb5_gss_init_sec_context\n(OM_uint32*,       /* minor_status */\n gss_cred_id_t,    /* claimant_cred_handle */\n gss_ctx_id_t*,    /* context_handle */\n gss_name_t,       /* target_name */\n gss_OID,          /* mech_type */\n OM_uint32,        /* req_flags */\n OM_uint32,        /* time_req */\n gss_channel_bindings_t,\n /* input_chan_bindings */\n gss_buffer_t,     /* input_token */\n gss_OID*,         /* actual_mech_type */\n gss_buffer_t,     /* output_token */\n OM_uint32*,       /* ret_flags */\n OM_uint32*        /* time_rec */\n);\n\nOM_uint32 krb5_gss_init_sec_context_ext\n(OM_uint32*,       /* minor_status */\n gss_cred_id_t,    /* claimant_cred_handle */\n gss_ctx_id_t*,    /* context_handle */\n gss_name_t,       /* target_name */\n gss_OID,          /* mech_type */\n OM_uint32,        /* req_flags */\n OM_uint32,        /* time_req */\n gss_channel_bindings_t,\n /* input_chan_bindings */\n gss_buffer_t,     /* input_token */\n gss_OID*,         /* actual_mech_type */\n gss_buffer_t,     /* output_token */\n OM_uint32*,       /* ret_flags */\n OM_uint32*,       /* time_rec */\n krb5_gss_ctx_ext_t /* exts */\n);\n\n#ifndef LEAN_CLIENT\nOM_uint32 KRB5_CALLCONV krb5_gss_accept_sec_context\n(OM_uint32*,       /* minor_status */\n gss_ctx_id_t*,    /* context_handle */\n gss_cred_id_t,    /* verifier_cred_handle */\n gss_buffer_t,     /* input_token_buffer */\n gss_channel_bindings_t,\n /* input_chan_bindings */\n gss_name_t*,      /* src_name */\n gss_OID*,         /* mech_type */\n gss_buffer_t,     /* output_token */\n OM_uint32*,       /* ret_flags */\n OM_uint32*,       /* time_rec */\n gss_cred_id_t*    /* delegated_cred_handle */\n);\n\nOM_uint32 KRB5_CALLCONV krb5_gss_accept_sec_context_ext\n(OM_uint32*,       /* minor_status */\n gss_ctx_id_t*,    /* context_handle */\n gss_cred_id_t,    /* verifier_cred_handle */\n gss_buffer_t,     /* input_token_buffer */\n gss_channel_bindings_t,\n /* input_chan_bindings */\n gss_name_t*,      /* src_name */\n gss_OID*,         /* mech_type */\n gss_buffer_t,     /* output_token */\n OM_uint32*,       /* ret_flags */\n OM_uint32*,       /* time_rec */\n gss_cred_id_t*,   /* delegated_cred_handle */\n krb5_gss_ctx_ext_t/*exts */\n);\n#endif /* LEAN_CLIENT */\n\nOM_uint32 KRB5_CALLCONV krb5_gss_inquire_sec_context_by_oid\n(OM_uint32*,       /* minor_status */\n const gss_ctx_id_t,\n /* context_handle */\n const gss_OID,    /* desired_object */\n gss_buffer_set_t* /* data_set */\n);\n\nOM_uint32 KRB5_CALLCONV krb5_gss_set_sec_context_option\n(OM_uint32*,       /* minor_status */\n gss_ctx_id_t*,    /* context_handle */\n const gss_OID,    /* desired_object */\n const gss_buffer_t/* value */\n);\n\nOM_uint32 KRB5_CALLCONV krb5_gss_process_context_token\n(OM_uint32*,       /* minor_status */\n gss_ctx_id_t,     /* context_handle */\n gss_buffer_t      /* token_buffer */\n);\n\nOM_uint32 KRB5_CALLCONV krb5_gss_delete_sec_context\n(OM_uint32*,       /* minor_status */\n gss_ctx_id_t*,    /* context_handle */\n gss_buffer_t      /* output_token */\n);\n\nOM_uint32 KRB5_CALLCONV krb5_gss_context_time\n(OM_uint32*,       /* minor_status */\n gss_ctx_id_t,     /* context_handle */\n OM_uint32*        /* time_rec */\n);\n\nOM_uint32 KRB5_CALLCONV krb5_gss_display_status\n(OM_uint32*,       /* minor_status */\n OM_uint32,        /* status_value */\n int,              /* status_type */\n gss_OID,          /* mech_type */\n OM_uint32*,       /* message_context */\n gss_buffer_t      /* status_string */\n);\n\nOM_uint32 KRB5_CALLCONV krb5_gss_indicate_mechs\n(OM_uint32*,       /* minor_status */\n gss_OID_set*      /* mech_set */\n);\n\nOM_uint32 KRB5_CALLCONV krb5_gss_compare_name\n(OM_uint32*,       /* minor_status */\n gss_name_t,       /* name1 */\n gss_name_t,       /* name2 */\n int*              /* name_equal */\n);\n\nOM_uint32 KRB5_CALLCONV krb5_gss_display_name\n(OM_uint32*,      /* minor_status */\n gss_name_t,      /* input_name */\n gss_buffer_t,    /* output_name_buffer */\n gss_OID*         /* output_name_type */\n);\n\n\nOM_uint32 KRB5_CALLCONV krb5_gss_import_name\n(OM_uint32*,       /* minor_status */\n gss_buffer_t,     /* input_name_buffer */\n gss_OID,          /* input_name_type */\n gss_name_t*       /* output_name */\n);\n\nOM_uint32 KRB5_CALLCONV krb5_gss_release_name\n(OM_uint32*,       /* minor_status */\n gss_name_t*       /* input_name */\n);\n\nOM_uint32 KRB5_CALLCONV krb5_gss_inquire_cred\n(OM_uint32 *,      /* minor_status */\n gss_cred_id_t,    /* cred_handle */\n gss_name_t *,     /* name */\n OM_uint32 *,      /* lifetime */\n gss_cred_usage_t*,/* cred_usage */\n gss_OID_set *     /* mechanisms */\n);\n\nOM_uint32 KRB5_CALLCONV krb5_gss_inquire_context\n(OM_uint32*,       /* minor_status */\n gss_ctx_id_t,     /* context_handle */\n gss_name_t*,      /* initiator_name */\n gss_name_t*,      /* acceptor_name */\n OM_uint32*,       /* lifetime_rec */\n gss_OID*,         /* mech_type */\n OM_uint32*,       /* ret_flags */\n int*,             /* locally_initiated */\n int*              /* open */\n);\n\n/* New V2 entry points */\nOM_uint32 KRB5_CALLCONV krb5_gss_get_mic\n(OM_uint32 *,           /* minor_status */\n gss_ctx_id_t,               /* context_handle */\n gss_qop_t,                  /* qop_req */\n gss_buffer_t,               /* message_buffer */\n gss_buffer_t                /* message_token */\n);\n\nOM_uint32 KRB5_CALLCONV krb5_gss_get_mic_iov\n(OM_uint32 *,                /* minor_status */\n gss_ctx_id_t,               /* context_handle */\n gss_qop_t,                  /* qop_req */\n gss_iov_buffer_desc *,      /* iov */\n int                         /* iov_count */\n);\n\nOM_uint32 KRB5_CALLCONV krb5_gss_get_mic_iov_length\n(OM_uint32 *,                /* minor_status */\n gss_ctx_id_t,               /* context_handle */\n gss_qop_t,                  /* qop_req */\n gss_iov_buffer_desc *,      /* iov */\n int                         /* iov_count */\n);\n\nOM_uint32 KRB5_CALLCONV krb5_gss_verify_mic\n(OM_uint32 *,           /* minor_status */\n gss_ctx_id_t,               /* context_handle */\n gss_buffer_t,               /* message_buffer */\n gss_buffer_t,               /* message_token */\n gss_qop_t *                 /* qop_state */\n);\n\nOM_uint32 KRB5_CALLCONV krb5_gss_verify_mic_iov\n(OM_uint32 *,                /* minor_status */\n gss_ctx_id_t,               /* context_handle */\n gss_qop_t *,                /* qop_state */\n gss_iov_buffer_desc *,      /* iov */\n int                         /* iov_count */\n);\n\nOM_uint32 KRB5_CALLCONV krb5_gss_wrap\n(OM_uint32 *,           /* minor_status */\n gss_ctx_id_t,               /* context_handle */\n int,                        /* conf_req_flag */\n gss_qop_t,                  /* qop_req */\n gss_buffer_t,               /* input_message_buffer */\n int *,                      /* conf_state */\n gss_buffer_t                /* output_message_buffer */\n);\n\nOM_uint32 KRB5_CALLCONV krb5_gss_wrap_iov\n(OM_uint32 *,           /* minor_status */\n gss_ctx_id_t,              /* context_handle */\n int,                       /* conf_req_flag */\n gss_qop_t,                 /* qop_req */\n int *,                     /* conf_state */\n gss_iov_buffer_desc *,     /* iov */\n int                        /* iov_count */\n);\n\nOM_uint32 KRB5_CALLCONV krb5_gss_wrap_iov_length\n(OM_uint32 *,           /* minor_status */\n gss_ctx_id_t,              /* context_handle */\n int,                       /* conf_req_flag */\n gss_qop_t,                 /* qop_req */\n int *,                     /* conf_state */\n gss_iov_buffer_desc *,     /* iov */\n int                        /* iov_count */\n);\n\nOM_uint32 KRB5_CALLCONV krb5_gss_unwrap\n(OM_uint32 *,           /* minor_status */\n gss_ctx_id_t,               /* context_handle */\n gss_buffer_t,               /* input_message_buffer */\n gss_buffer_t,               /* output_message_buffer */\n int *,                      /* conf_state */\n gss_qop_t *                 /* qop_state */\n);\n\nOM_uint32 KRB5_CALLCONV krb5_gss_unwrap_iov\n(OM_uint32 *,           /* minor_status */\n gss_ctx_id_t,              /* context_handle */\n int *,                     /* conf_state */\n gss_qop_t *,               /* qop_state */\n gss_iov_buffer_desc *,     /* iov */\n int                        /* iov_count */\n);\n\nOM_uint32 KRB5_CALLCONV krb5_gss_wrap_size_limit\n(OM_uint32 *,           /* minor_status */\n gss_ctx_id_t,               /* context_handle */\n int,                        /* conf_req_flag */\n gss_qop_t,                  /* qop_req */\n OM_uint32,                  /* req_output_size */\n OM_uint32 *                 /* max_input_size */\n);\n\nOM_uint32 KRB5_CALLCONV krb5_gss_import_name_object\n(OM_uint32 *,           /* minor_status */\n void *,                     /* input_name */\n gss_OID,                    /* input_name_type */\n gss_name_t *                /* output_name */\n);\n\nOM_uint32 KRB5_CALLCONV krb5_gss_export_name_object\n(OM_uint32 *,           /* minor_status */\n gss_name_t,                 /* input_name */\n gss_OID,                    /* desired_name_type */\n void * *                    /* output_name */\n);\n\nOM_uint32 KRB5_CALLCONV krb5_gss_inquire_cred_by_mech\n(OM_uint32  *,          /* minor_status */\n gss_cred_id_t,              /* cred_handle */\n gss_OID,                    /* mech_type */\n gss_name_t *,               /* name */\n OM_uint32 *,                /* initiator_lifetime */\n OM_uint32 *,                /* acceptor_lifetime */\n gss_cred_usage_t *          /* cred_usage */\n);\n#ifndef LEAN_CLIENT\nOM_uint32 KRB5_CALLCONV krb5_gss_export_sec_context\n(OM_uint32 *,           /* minor_status */\n gss_ctx_id_t *,             /* context_handle */\n gss_buffer_t                /* interprocess_token */\n);\n\nOM_uint32 KRB5_CALLCONV krb5_gss_import_sec_context\n(OM_uint32 *,           /* minor_status */\n gss_buffer_t,               /* interprocess_token */\n gss_ctx_id_t *              /* context_handle */\n);\n#endif /* LEAN_CLIENT */\n\nkrb5_error_code krb5_gss_ser_init(krb5_context);\n\nOM_uint32 krb5_gss_release_oid\n(OM_uint32 *,           /* minor_status */\n gss_OID *                   /* oid */\n);\n\nOM_uint32 KRB5_CALLCONV krb5_gss_internal_release_oid\n(OM_uint32 *,           /* minor_status */\n gss_OID *                   /* oid */\n);\n\nOM_uint32 KRB5_CALLCONV krb5_gss_inquire_names_for_mech\n(OM_uint32 *,           /* minor_status */\n gss_OID,                    /* mechanism */\n gss_OID_set *               /* name_types */\n);\n\nOM_uint32 krb5_gss_canonicalize_name\n(OM_uint32  *,          /* minor_status */\n const gss_name_t,           /* input_name */\n const gss_OID,              /* mech_type */\n gss_name_t *                /* output_name */\n);\n\nOM_uint32 KRB5_CALLCONV krb5_gss_export_name\n(OM_uint32  *,          /* minor_status */\n const gss_name_t,           /* input_name */\n gss_buffer_t                /* exported_name */\n);\n\nOM_uint32 KRB5_CALLCONV krb5_gss_duplicate_name\n(OM_uint32  *,          /* minor_status */\n const gss_name_t,           /* input_name */\n gss_name_t *                /* dest_name */\n);\n\nOM_uint32 krb5_gss_validate_cred\n(OM_uint32 *,           /* minor_status */\n gss_cred_id_t               /* cred */\n);\n\nOM_uint32 KRB5_CALLCONV krb5_gss_acquire_cred_impersonate_name(\n    OM_uint32 *,            /* minor_status */\n    const gss_cred_id_t,    /* impersonator_cred_handle */\n    const gss_name_t,       /* desired_name */\n    OM_uint32,              /* time_req */\n    const gss_OID_set,      /* desired_mechs */\n    gss_cred_usage_t,       /* cred_usage */\n    gss_cred_id_t *,        /* output_cred_handle */\n    gss_OID_set *,          /* actual_mechs */\n    OM_uint32 *);           /* time_rec */\n\nOM_uint32\nkrb5_gss_validate_cred_1(OM_uint32 * /* minor_status */,\n                         gss_cred_id_t /* cred_handle */,\n                         krb5_context /* context */);\n\ngss_OID krb5_gss_convert_static_mech_oid(gss_OID oid);\n\nkrb5_error_code gss_krb5int_make_seal_token_v3(krb5_context,\n                                               krb5_gss_ctx_id_rec *,\n                                               const gss_buffer_desc *,\n                                               gss_buffer_t,\n                                               int, int);\n\nOM_uint32 gss_krb5int_unseal_token_v3(krb5_context *contextptr,\n                                      OM_uint32 *minor_status,\n                                      krb5_gss_ctx_id_rec *ctx,\n                                      unsigned char *ptr,\n                                      unsigned int bodysize,\n                                      gss_buffer_t message_buffer,\n                                      int *conf_state, gss_qop_t *qop_state,\n                                      int toktype);\n\nint gss_krb5int_rotate_left (void *ptr, size_t bufsiz, size_t rc);\n\n/* naming_exts.c */\n#define KG_INIT_NAME_NO_COPY 0x1\n\nkrb5_error_code\nkg_init_name(krb5_context context, krb5_principal principal,\n             char *service, char *host, krb5_authdata_context ad_context,\n             krb5_flags flags, krb5_gss_name_t *name);\n\nkrb5_error_code\nkg_release_name(krb5_context context, krb5_gss_name_t *name);\n\nkrb5_error_code\nkg_duplicate_name(krb5_context context, const krb5_gss_name_t src,\n                  krb5_gss_name_t *dst);\n\nkrb5_boolean\nkg_compare_name(krb5_context context,\n                krb5_gss_name_t name1,\n                krb5_gss_name_t name2);\n\nkrb5_boolean\nkg_acceptor_princ(krb5_context context, krb5_gss_name_t name,\n                  krb5_principal *princ_out);\n\nOM_uint32 KRB5_CALLCONV\nkrb5_gss_display_name_ext(OM_uint32 *minor_status,\n                          gss_name_t name,\n                          gss_OID display_as_name_type,\n                          gss_buffer_t display_name);\n\nOM_uint32 KRB5_CALLCONV\nkrb5_gss_inquire_name(OM_uint32 *minor_status,\n                      gss_name_t name,\n                      int *name_is_MN,\n                      gss_OID *MN_mech,\n                      gss_buffer_set_t *attrs);\n\nOM_uint32 KRB5_CALLCONV\nkrb5_gss_get_name_attribute(OM_uint32 *minor_status,\n                            gss_name_t name,\n                            gss_buffer_t attr,\n                            int *authenticated,\n                            int *complete,\n                            gss_buffer_t value,\n                            gss_buffer_t display_value,\n                            int *more);\n\nOM_uint32 KRB5_CALLCONV\nkrb5_gss_set_name_attribute(OM_uint32 *minor_status,\n                            gss_name_t name,\n                            int complete,\n                            gss_buffer_t attr,\n                            gss_buffer_t value);\n\nOM_uint32 KRB5_CALLCONV\nkrb5_gss_delete_name_attribute(OM_uint32 *minor_status,\n                               gss_name_t name,\n                               gss_buffer_t attr);\n\nOM_uint32 KRB5_CALLCONV\nkrb5_gss_export_name_composite(OM_uint32 *minor_status,\n                               gss_name_t name,\n                               gss_buffer_t exp_composite_name);\n\nOM_uint32 KRB5_CALLCONV\nkrb5_gss_map_name_to_any(OM_uint32 *minor_status,\n                         gss_name_t name,\n                         int authenticated,\n                         gss_buffer_t type_id,\n                         gss_any_t *output);\n\nOM_uint32 KRB5_CALLCONV\nkrb5_gss_release_any_name_mapping(OM_uint32 *minor_status,\n                                  gss_name_t name,\n                                  gss_buffer_t type_id,\n                                  gss_any_t *input);\n\nOM_uint32 KRB5_CALLCONV\nkrb5_gss_pseudo_random(OM_uint32 *minor_status,\n                       gss_ctx_id_t context,\n                       int prf_key,\n                       const gss_buffer_t prf_in,\n                       ssize_t desired_output_len,\n                       gss_buffer_t prf_out);\n\nOM_uint32 KRB5_CALLCONV\nkrb5_gss_store_cred(OM_uint32 *minor_status,\n                    gss_cred_id_t input_cred_handle,\n                    gss_cred_usage_t cred_usage,\n                    const gss_OID desired_mech,\n                    OM_uint32 overwrite_cred,\n                    OM_uint32 default_cred,\n                    gss_OID_set *elements_stored,\n                    gss_cred_usage_t *cred_usage_stored);\n\n/* s4u_gss_glue.c */\nOM_uint32\nkg_compose_deleg_cred(OM_uint32 *minor_status,\n                      krb5_gss_cred_id_t impersonator_cred,\n                      krb5_creds *subject_creds,\n                      OM_uint32 time_req,\n                      krb5_gss_cred_id_t *output_cred,\n                      OM_uint32 *time_rec,\n                      krb5_context context);\n\n/*\n * These take unglued krb5-mech-specific contexts.\n */\n\n#define GSS_KRB5_GET_TKT_FLAGS_OID_LENGTH 11\n#define GSS_KRB5_GET_TKT_FLAGS_OID \"\\x2a\\x86\\x48\\x86\\xf7\\x12\\x01\\x02\\x02\\x05\\x01\"\n\nOM_uint32 gss_krb5int_get_tkt_flags\n(OM_uint32 *minor_status,\n const gss_ctx_id_t context_handle,\n const gss_OID desired_object,\n gss_buffer_set_t *data_set);\n\n#define GSS_KRB5_COPY_CCACHE_OID_LENGTH 11\n#define GSS_KRB5_COPY_CCACHE_OID \"\\x2a\\x86\\x48\\x86\\xf7\\x12\\x01\\x02\\x02\\x05\\x02\"\n\nOM_uint32 gss_krb5int_copy_ccache\n(OM_uint32 *minor_status,\n gss_cred_id_t *cred_handle,\n const gss_OID desired_oid,\n const gss_buffer_t value);\n\n#define GSS_KRB5_CCACHE_NAME_OID_LENGTH 11\n#define GSS_KRB5_CCACHE_NAME_OID \"\\x2a\\x86\\x48\\x86\\xf7\\x12\\x01\\x02\\x02\\x05\\x03\"\n\nstruct krb5_gss_ccache_name_req {\n    const char *name;\n    const char **out_name;\n};\n\nOM_uint32\ngss_krb5int_ccache_name(OM_uint32 *minor_status, const gss_OID, const gss_OID,\n                        const gss_buffer_t);\n\n#define GSS_KRB5_INQ_SSPI_SESSION_KEY_OID_LENGTH 11\n#define GSS_KRB5_INQ_SSPI_SESSION_KEY_OID \"\\x2a\\x86\\x48\\x86\\xf7\\x12\\x01\\x02\\x02\\x05\\x05\"\n\nOM_uint32\ngss_krb5int_inq_session_key(OM_uint32 *, const gss_ctx_id_t, const gss_OID, gss_buffer_set_t *);\n\n#define GSS_KRB5_SET_ALLOWABLE_ENCTYPES_OID_LENGTH 11\n#define GSS_KRB5_SET_ALLOWABLE_ENCTYPES_OID \"\\x2a\\x86\\x48\\x86\\xf7\\x12\\x01\\x02\\x02\\x05\\x04\"\n\nstruct krb5_gss_set_allowable_enctypes_req {\n    OM_uint32 num_ktypes;\n    krb5_enctype *ktypes;\n};\n\nOM_uint32\ngss_krb5int_set_allowable_enctypes(OM_uint32 *minor_status,\n                                   gss_cred_id_t *cred,\n                                   const gss_OID desired_oid,\n                                   const gss_buffer_t value);\n\n#define GSS_KRB5_EXPORT_LUCID_SEC_CONTEXT_OID_LENGTH 11\n#define GSS_KRB5_EXPORT_LUCID_SEC_CONTEXT_OID \"\\x2a\\x86\\x48\\x86\\xf7\\x12\\x01\\x02\\x02\\x05\\x06\"\n\nOM_uint32\ngss_krb5int_export_lucid_sec_context(OM_uint32 *minor_status,\n                                     const gss_ctx_id_t context_handle,\n                                     const gss_OID desired_object,\n                                     gss_buffer_set_t *data_set);\n\n#define GSS_KRB5_FREE_LUCID_SEC_CONTEXT_OID_LENGTH 11\n#define GSS_KRB5_FREE_LUCID_SEC_CONTEXT_OID \"\\x2a\\x86\\x48\\x86\\xf7\\x12\\x01\\x02\\x02\\x05\\x07\"\n\nOM_uint32\ngss_krb5int_free_lucid_sec_context(OM_uint32 *, const gss_OID,\n                                   const gss_OID, gss_buffer_t);\n\nextern k5_mutex_t kg_kdc_flag_mutex;\nkrb5_error_code krb5_gss_init_context (krb5_context *ctxp);\n\n#define GSS_KRB5_USE_KDC_CONTEXT_OID_LENGTH 11\n#define GSS_KRB5_USE_KDC_CONTEXT_OID \"\\x2a\\x86\\x48\\x86\\xf7\\x12\\x01\\x02\\x02\\x05\\x08\"\n\nOM_uint32 krb5int_gss_use_kdc_context(OM_uint32 *, const gss_OID,\n                                      const gss_OID, gss_buffer_t);\n\nkrb5_error_code krb5_gss_use_kdc_context(void);\n\n#define GSS_KRB5_REGISTER_ACCEPTOR_IDENTITY_OID_LENGTH 11\n#define GSS_KRB5_REGISTER_ACCEPTOR_IDENTITY_OID \"\\x2a\\x86\\x48\\x86\\xf7\\x12\\x01\\x02\\x02\\x05\\x09\"\n\nOM_uint32\ngss_krb5int_register_acceptor_identity(OM_uint32 *, const gss_OID, const gss_OID, gss_buffer_t);\n\n#define GSS_KRB5_EXTRACT_AUTHZ_DATA_FROM_SEC_CONTEXT_OID_LENGTH 11\n#define GSS_KRB5_EXTRACT_AUTHZ_DATA_FROM_SEC_CONTEXT_OID \"\\x2a\\x86\\x48\\x86\\xf7\\x12\\x01\\x02\\x02\\x05\\x0a\"\n\nOM_uint32\ngss_krb5int_extract_authz_data_from_sec_context(OM_uint32 *minor_status,\n                                                const gss_ctx_id_t context_handle,\n                                                const gss_OID desired_object,\n                                                gss_buffer_set_t *ad_data);\n\n#define GSS_KRB5_SET_CRED_RCACHE_OID_LENGTH 11\n#define GSS_KRB5_SET_CRED_RCACHE_OID \"\\x2a\\x86\\x48\\x86\\xf7\\x12\\x01\\x02\\x02\\x05\\x0b\"\n\nOM_uint32\ngss_krb5int_set_cred_rcache(OM_uint32 *, gss_cred_id_t *, const gss_OID, const gss_buffer_t);\n\n#define GSS_KRB5_EXTRACT_AUTHTIME_FROM_SEC_CONTEXT_OID_LENGTH 11\n#define GSS_KRB5_EXTRACT_AUTHTIME_FROM_SEC_CONTEXT_OID \"\\x2a\\x86\\x48\\x86\\xf7\\x12\\x01\\x02\\x02\\x05\\x0c\"\n\nOM_uint32\ngss_krb5int_extract_authtime_from_sec_context(OM_uint32 *,\n                                              const gss_ctx_id_t,\n                                              const gss_OID,\n                                              gss_buffer_set_t *);\n\n#define GSS_KRB5_IMPORT_CRED_OID_LENGTH 11\n#define GSS_KRB5_IMPORT_CRED_OID \"\\x2a\\x86\\x48\\x86\\xf7\\x12\\x01\\x02\\x02\\x05\\x0d\"\n\nstruct krb5_gss_import_cred_req {\n    krb5_ccache id;\n    krb5_principal keytab_principal;\n    krb5_keytab keytab;\n};\n\nOM_uint32\ngss_krb5int_import_cred(OM_uint32 *minor_status,\n                        gss_cred_id_t *cred,\n                        const gss_OID desired_oid,\n                        const gss_buffer_t value);\n\n#ifdef _GSS_STATIC_LINK\nint gss_krb5int_lib_init(void);\nvoid gss_krb5int_lib_fini(void);\n#endif /* _GSS_STATIC_LINK */\n\nOM_uint32 gss_krb5int_initialize_library(void);\nvoid gss_krb5int_cleanup_library(void);\n\n/* For error message handling.  */\n/* Returns a shared string, not a private copy!  */\nextern char *\nkrb5_gss_get_error_message(OM_uint32 minor_code);\nextern void\nkrb5_gss_save_error_string(OM_uint32 minor_code, char *msg);\nextern void\nkrb5_gss_save_error_message(OM_uint32 minor_code, const char *format, ...)\n#if !defined(__cplusplus) && (__GNUC__ > 2)\n    __attribute__((__format__(__printf__, 2, 3)))\n#endif\n    ;\n    extern void\n    krb5_gss_save_error_info(OM_uint32 minor_code, krb5_context ctx);\n#define get_error_message krb5_gss_get_error_message\n#define save_error_string krb5_gss_save_error_string\n#define save_error_message krb5_gss_save_error_message\n#ifdef KRB5_KERNEL\n/* Error messages aren't needed in the kernel, so reduce dependencies. */\n#define save_error_info(x,y)\n#else\n#define save_error_info krb5_gss_save_error_info\n#endif\nextern void krb5_gss_delete_error_info(void *p);\n\n/* Prefix concatenated with Kerberos encryption type */\n#define GSS_KRB5_SESSION_KEY_ENCTYPE_OID_LENGTH 10\n#define GSS_KRB5_SESSION_KEY_ENCTYPE_OID  \"\\x2a\\x86\\x48\\x86\\xf7\\x12\\x01\\x02\\x02\\x04\"\n\n/* IAKERB */\n\nOM_uint32 KRB5_CALLCONV\niakerb_gss_init_sec_context(OM_uint32 *minor_status,\n                            gss_cred_id_t claimant_cred_handle,\n                            gss_ctx_id_t *context_handle,\n                            gss_name_t target_name,\n                            gss_OID mech_type,\n                            OM_uint32 req_flags,\n                            OM_uint32 time_req,\n                            gss_channel_bindings_t input_chan_bindings,\n                            gss_buffer_t input_token,\n                            gss_OID *actual_mech_type,\n                            gss_buffer_t output_token,\n                            OM_uint32 *ret_flags,\n                            OM_uint32 *time_rec);\n\nOM_uint32 KRB5_CALLCONV\niakerb_gss_accept_sec_context(OM_uint32 *minor_status,\n                              gss_ctx_id_t *context_handler,\n                              gss_cred_id_t verifier_cred_handle,\n                              gss_buffer_t input_token,\n                              gss_channel_bindings_t input_chan_bindings,\n                              gss_name_t *src_name,\n                              gss_OID *mech_type,\n                              gss_buffer_t output_token,\n                              OM_uint32 *ret_flags,\n                              OM_uint32 *time_rec,\n                              gss_cred_id_t *delegated_cred_handle);\n\nOM_uint32 KRB5_CALLCONV\niakerb_gss_delete_sec_context(OM_uint32 *minor_status,\n                              gss_ctx_id_t *context_handle,\n                              gss_buffer_t output_token);\n\nkrb5_error_code\niakerb_make_finished(krb5_context context,\n                     krb5_key key,\n                     const krb5_data *conv,\n                     krb5_data **finished);\n\nkrb5_error_code\niakerb_verify_finished(krb5_context context,\n                       krb5_key key,\n                       const krb5_data *conv,\n                       const krb5_data *finished);\n\n/*\n * Transfer contents of a krb5_data to a gss_buffer and invalidate the source\n * On unix, this is a simple pointer copy\n * On windows, memory is reallocated and copied.\n */\nstatic inline krb5_error_code\ndata_to_gss(krb5_data *input_k5data, gss_buffer_t output_buffer)\n{\n    krb5_error_code code = 0;\n    output_buffer->length = input_k5data->length;\n#if defined(_WIN32) || defined(DEBUG_GSSALLOC)\n    if (output_buffer->length > 0) {\n        output_buffer->value = gssalloc_malloc(output_buffer->length);\n        if (output_buffer->value)\n            memcpy(output_buffer->value, input_k5data->data, output_buffer->length);\n        else\n            code = ENOMEM;\n    } else {\n        output_buffer->value = NULL;\n    }\n    free(input_k5data->data);\n#else\n    output_buffer->value = input_k5data->data;\n#endif\n    *input_k5data = empty_data();\n    return code;\n}\n\n#define KRB5_GSS_EXTS_IAKERB_FINISHED 1\n\n\n/* Credential store extensions */\n\n#define KRB5_CS_CLI_KEYTAB_URN \"client_keytab\"\n#define KRB5_CS_KEYTAB_URN \"keytab\"\n#define KRB5_CS_CCACHE_URN \"ccache\"\n#define KRB5_CS_RCACHE_URN \"rcache\"\n\nOM_uint32\nkg_value_from_cred_store(gss_const_key_value_set_t cred_store,\n                         const char *type, const char **value);\n\nOM_uint32 KRB5_CALLCONV\nkrb5_gss_acquire_cred_from(\n    OM_uint32 *,               /* minor_status */\n    const gss_name_t,          /* desired_name */\n    OM_uint32,                 /* time_req */\n    const gss_OID_set,         /* desired_mechs */\n    gss_cred_usage_t,          /* cred_usage */\n    gss_const_key_value_set_t, /* cred_store */\n    gss_cred_id_t *,           /* output_cred_handle */\n    gss_OID_set *,             /* actual_mechs */\n    OM_uint32 *);              /* time_rec */\n\nOM_uint32 KRB5_CALLCONV\nkrb5_gss_store_cred_into(\n    OM_uint32 *,               /* minor_status */\n    gss_cred_id_t,             /* input_cred_handle */\n    gss_cred_usage_t,          /* input_usage */\n    const gss_OID,             /* desired_mech */\n    OM_uint32,                 /* overwrite_cred */\n    OM_uint32,                 /* default_cred */\n    gss_const_key_value_set_t, /* cred_store */\n    gss_OID_set *,             /* elements_stored */\n    gss_cred_usage_t *);       /* cred_usage_stored */\n\nOM_uint32 KRB5_CALLCONV\nkrb5_gss_export_cred(OM_uint32 *minor_status, gss_cred_id_t cred_handle,\n                     gss_buffer_t token);\n\nOM_uint32 KRB5_CALLCONV\nkrb5_gss_import_cred(OM_uint32 *minor_status, gss_buffer_t token,\n                     gss_cred_id_t *cred_handle);\n\nOM_uint32 KRB5_CALLCONV\niakerb_gss_process_context_token(OM_uint32 *minor_status,\n                                 const gss_ctx_id_t context_handle,\n                                 const gss_buffer_t token_buffer);\n\nOM_uint32 KRB5_CALLCONV\niakerb_gss_context_time(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n                        OM_uint32 *time_rec);\n\nOM_uint32 KRB5_CALLCONV\niakerb_gss_inquire_context(OM_uint32 *minor_status,\n                           gss_ctx_id_t context_handle, gss_name_t *src_name,\n                           gss_name_t *targ_name, OM_uint32 *lifetime_rec,\n                           gss_OID *mech_type, OM_uint32 *ctx_flags,\n                           int *locally_initiated, int *opened);\n\nOM_uint32 KRB5_CALLCONV\niakerb_gss_get_mic(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n                   gss_qop_t qop_req, gss_buffer_t message_buffer,\n                   gss_buffer_t message_token);\n\nOM_uint32 KRB5_CALLCONV\niakerb_gss_get_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n                       gss_qop_t qop_req, gss_iov_buffer_desc *iov,\n                       int iov_count);\n\nOM_uint32 KRB5_CALLCONV\niakerb_gss_get_mic_iov_length(OM_uint32 *minor_status,\n                              gss_ctx_id_t context_handle, gss_qop_t qop_req,\n                              gss_iov_buffer_desc *iov, int iov_count);\n\nOM_uint32 KRB5_CALLCONV\niakerb_gss_verify_mic(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n                      gss_buffer_t msg_buffer, gss_buffer_t token_buffer,\n                      gss_qop_t *qop_state);\n\nOM_uint32 KRB5_CALLCONV\niakerb_gss_verify_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n                          gss_qop_t *qop_state, gss_iov_buffer_desc *iov,\n                          int iov_count);\n\nOM_uint32 KRB5_CALLCONV\niakerb_gss_wrap(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n                int conf_req_flag, gss_qop_t qop_req,\n                gss_buffer_t input_message_buffer, int *conf_state,\n                gss_buffer_t output_message_buffer);\n\nOM_uint32 KRB5_CALLCONV\niakerb_gss_wrap_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n                    int conf_req_flag, gss_qop_t qop_req, int *conf_state,\n                    gss_iov_buffer_desc *iov, int iov_count);\n\nOM_uint32 KRB5_CALLCONV\niakerb_gss_wrap_iov_length(OM_uint32 *minor_status,\n                           gss_ctx_id_t context_handle, int conf_req_flag,\n                           gss_qop_t qop_req, int *conf_state,\n                           gss_iov_buffer_desc *iov, int iov_count);\n\nOM_uint32 KRB5_CALLCONV\niakerb_gss_unwrap(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n                  gss_buffer_t input_message_buffer,\n                  gss_buffer_t output_message_buffer, int *conf_state,\n                  gss_qop_t *qop_state);\n\nOM_uint32 KRB5_CALLCONV\niakerb_gss_unwrap_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n                      int *conf_state, gss_qop_t *qop_state,\n                      gss_iov_buffer_desc *iov, int iov_count);\n\nOM_uint32 KRB5_CALLCONV\niakerb_gss_wrap_size_limit(OM_uint32 *minor_status,\n                           gss_ctx_id_t context_handle, int conf_req_flag,\n                           gss_qop_t qop_req, OM_uint32 req_output_size,\n                           OM_uint32 *max_input_size);\n\n#ifndef LEAN_CLIENT\nOM_uint32 KRB5_CALLCONV\niakerb_gss_export_sec_context(OM_uint32 *minor_status,\n                              gss_ctx_id_t *context_handle,\n                              gss_buffer_t interprocess_token);\n#endif /* LEAN_CLIENT */\n\nOM_uint32 KRB5_CALLCONV\niakerb_gss_inquire_sec_context_by_oid(OM_uint32 *minor_status,\n                                      const gss_ctx_id_t context_handle,\n                                      const gss_OID desired_object,\n                                      gss_buffer_set_t *data_set);\n\nOM_uint32 KRB5_CALLCONV\niakerb_gss_set_sec_context_option(OM_uint32 *minor_status,\n                                  gss_ctx_id_t *context_handle,\n                                  const gss_OID desired_object,\n                                  const gss_buffer_t value);\n\nOM_uint32 KRB5_CALLCONV\niakerb_gss_pseudo_random(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n                         int prf_key, const gss_buffer_t prf_in,\n                         ssize_t desired_output_len, gss_buffer_t prf_out);\n\n/* Magic string to identify exported krb5 GSS credentials.  Increment this if\n * the format changes. */\n#define CRED_EXPORT_MAGIC \"K5C1\"\n\n#endif /* _GSSAPIP_KRB5_H_ */\n", "/* -*- mode: c; c-basic-offset: 4; indent-tabs-mode: nil -*- */\n/*\n * Copyright 1993 by OpenVision Technologies, Inc.\n *\n * Permission to use, copy, modify, distribute, and sell this software\n * and its documentation for any purpose is hereby granted without fee,\n * provided that the above copyright notice appears in all copies and\n * that both that copyright notice and this permission notice appear in\n * supporting documentation, and that the name of OpenVision not be used\n * in advertising or publicity pertaining to distribution of the software\n * without specific, written prior permission. OpenVision makes no\n * representations about the suitability of this software for any\n * purpose.  It is provided \"as is\" without express or implied warranty.\n *\n * OPENVISION DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,\n * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO\n * EVENT SHALL OPENVISION BE LIABLE FOR ANY SPECIAL, INDIRECT OR\n * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF\n * USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\n * OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\n * PERFORMANCE OF THIS SOFTWARE.\n */\n\n/*\n * Copyright (C) 1998 by the FundsXpress, INC.\n *\n * All rights reserved.\n *\n * Export of this software from the United States of America may require\n * a specific license from the United States Government.  It is the\n * responsibility of any person or organization contemplating export to\n * obtain such a license before exporting.\n *\n * WITHIN THAT CONSTRAINT, permission to use, copy, modify, and\n * distribute this software and its documentation for any purpose and\n * without fee is hereby granted, provided that the above copyright\n * notice appear in all copies and that both that copyright notice and\n * this permission notice appear in supporting documentation, and that\n * the name of FundsXpress. not be used in advertising or publicity pertaining\n * to distribution of the software without specific, written prior\n * permission.  FundsXpress makes no representations about the suitability of\n * this software for any purpose.  It is provided \"as is\" without express\n * or implied warranty.\n *\n * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED\n * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.\n */\n/*\n * Copyright (c) 2006-2008, Novell, Inc.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *   * Redistributions of source code must retain the above copyright notice,\n *       this list of conditions and the following disclaimer.\n *   * Redistributions in binary form must reproduce the above copyright\n *       notice, this list of conditions and the following disclaimer in the\n *       documentation and/or other materials provided with the distribution.\n *   * The copyright holder's name is not used to endorse or promote products\n *       derived from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n/*\n * $Id$\n */\n\n\n/* For declaration of krb5_ser_context_init */\n#include \"k5-int.h\"\n#include \"gssapiP_krb5.h\"\n#include \"mglueP.h\"\n\n#ifndef NO_PASSWORD\n#include <pwd.h>\n#endif\n\n/** exported constants defined in gssapi_krb5{,_nx}.h **/\n\n/* these are bogus, but will compile */\n\n/*\n * The OID of the draft krb5 mechanism, assigned by IETF, is:\n *      iso(1) org(3) dod(5) internet(1) security(5)\n *      kerberosv5(2) = 1.3.5.1.5.2\n * The OID of the krb5_name type is:\n *      iso(1) member-body(2) US(840) mit(113554) infosys(1) gssapi(2)\n *      krb5(2) krb5_name(1) = 1.2.840.113554.1.2.2.1\n * The OID of the krb5_principal type is:\n *      iso(1) member-body(2) US(840) mit(113554) infosys(1) gssapi(2)\n *      krb5(2) krb5_principal(2) = 1.2.840.113554.1.2.2.2\n * The OID of the proposed standard krb5 mechanism is:\n *      iso(1) member-body(2) US(840) mit(113554) infosys(1) gssapi(2)\n *      krb5(2) = 1.2.840.113554.1.2.2\n * The OID of the proposed standard krb5 v2 mechanism is:\n *      iso(1) member-body(2) US(840) mit(113554) infosys(1) gssapi(2)\n *      krb5v2(3) = 1.2.840.113554.1.2.3\n * Provisionally reserved for Kerberos session key algorithm\n * identifiers is:\n *      iso(1) member-body(2) US(840) mit(113554) infosys(1) gssapi(2)\n *      krb5(2) krb5_enctype(4) = 1.2.840.113554.1.2.2.4\n * Provisionally reserved for Kerberos mechanism-specific APIs:\n *      iso(1) member-body(2) US(840) mit(113554) infosys(1) gssapi(2)\n *      krb5(2) krb5_gssapi_ext(5) = 1.2.840.113554.1.2.2.5\n */\n\n/*\n * Encoding rules: The first two values are encoded in one byte as 40\n * * value1 + value2.  Subsequent values are encoded base 128, most\n * significant digit first, with the high bit (\\200) set on all octets\n * except the last in each value's encoding.\n */\n\n#define NO_CI_FLAGS_X_OID_LENGTH 6\n#define NO_CI_FLAGS_X_OID \"\\x2a\\x85\\x70\\x2b\\x0d\\x1d\"\n\nconst gss_OID_desc krb5_gss_oid_array[] = {\n    /* this is the official, rfc-specified OID */\n    {GSS_MECH_KRB5_OID_LENGTH, GSS_MECH_KRB5_OID},\n    /* this pre-RFC mech OID */\n    {GSS_MECH_KRB5_OLD_OID_LENGTH, GSS_MECH_KRB5_OLD_OID},\n    /* this is the unofficial, incorrect mech OID emitted by MS */\n    {GSS_MECH_KRB5_WRONG_OID_LENGTH, GSS_MECH_KRB5_WRONG_OID},\n    /* IAKERB OID */\n    {GSS_MECH_IAKERB_OID_LENGTH, GSS_MECH_IAKERB_OID},\n    /* this is the v2 assigned OID */\n    {9, \"\\052\\206\\110\\206\\367\\022\\001\\002\\003\"},\n    /* these two are name type OID's */\n    /* 2.1.1. Kerberos Principal Name Form:  (rfc 1964)\n     * This name form shall be represented by the Object Identifier {iso(1)\n     * member-body(2) United States(840) mit(113554) infosys(1) gssapi(2)\n     * krb5(2) krb5_name(1)}.  The recommended symbolic name for this type\n     * is \"GSS_KRB5_NT_PRINCIPAL_NAME\". */\n    {10, \"\\052\\206\\110\\206\\367\\022\\001\\002\\002\\001\"},\n    /* gss_nt_krb5_principal.  Object identifier for a krb5_principal. Do not use. */\n    {10, \"\\052\\206\\110\\206\\367\\022\\001\\002\\002\\002\"},\n    {NO_CI_FLAGS_X_OID_LENGTH, NO_CI_FLAGS_X_OID},\n    { 0, 0 }\n};\n\nconst gss_OID_desc * const gss_mech_krb5              = krb5_gss_oid_array+0;\nconst gss_OID_desc * const gss_mech_krb5_old          = krb5_gss_oid_array+1;\nconst gss_OID_desc * const gss_mech_krb5_wrong        = krb5_gss_oid_array+2;\nconst gss_OID_desc * const gss_mech_iakerb            = krb5_gss_oid_array+3;\n\n\nconst gss_OID_desc * const gss_nt_krb5_name           = krb5_gss_oid_array+5;\nconst gss_OID_desc * const gss_nt_krb5_principal      = krb5_gss_oid_array+6;\nconst gss_OID_desc * const GSS_KRB5_NT_PRINCIPAL_NAME = krb5_gss_oid_array+5;\n\nconst gss_OID_desc * const GSS_KRB5_CRED_NO_CI_FLAGS_X = krb5_gss_oid_array+7;\n\nstatic const gss_OID_set_desc oidsets[] = {\n    {1, (gss_OID) krb5_gss_oid_array+0}, /* RFC OID */\n    {1, (gss_OID) krb5_gss_oid_array+1}, /* pre-RFC OID */\n    {3, (gss_OID) krb5_gss_oid_array+0}, /* all names for krb5 mech */\n    {4, (gss_OID) krb5_gss_oid_array+0}, /* all krb5 names and IAKERB */\n};\n\nconst gss_OID_set_desc * const gss_mech_set_krb5 = oidsets+0;\nconst gss_OID_set_desc * const gss_mech_set_krb5_old = oidsets+1;\nconst gss_OID_set_desc * const gss_mech_set_krb5_both = oidsets+2;\nconst gss_OID_set_desc * const kg_all_mechs = oidsets+3;\n\ng_set kg_vdb = G_SET_INIT;\n\n/** default credential support */\n\n/*\n * init_sec_context() will explicitly re-acquire default credentials,\n * so handling the expiration/invalidation condition here isn't needed.\n */\nOM_uint32\nkg_get_defcred(minor_status, cred)\n    OM_uint32 *minor_status;\n    gss_cred_id_t *cred;\n{\n    OM_uint32 major;\n\n    if ((major = krb5_gss_acquire_cred(minor_status,\n                                       (gss_name_t) NULL, GSS_C_INDEFINITE,\n                                       GSS_C_NULL_OID_SET, GSS_C_INITIATE,\n                                       cred, NULL, NULL)) && GSS_ERROR(major)) {\n        return(major);\n    }\n    *minor_status = 0;\n    return(GSS_S_COMPLETE);\n}\n\nOM_uint32\nkg_sync_ccache_name (krb5_context context, OM_uint32 *minor_status)\n{\n    OM_uint32 err = 0;\n\n    /*\n     * Sync up the context ccache name with the GSSAPI ccache name.\n     * If kg_ccache_name is NULL -- normal unless someone has called\n     * gss_krb5_ccache_name() -- then the system default ccache will\n     * be picked up and used by resetting the context default ccache.\n     * This is needed for platforms which support multiple ccaches.\n     */\n\n    if (!err) {\n        /* if NULL, resets the context default ccache */\n        err = krb5_cc_set_default_name(context,\n                                       (char *) k5_getspecific(K5_KEY_GSS_KRB5_CCACHE_NAME));\n    }\n\n    *minor_status = err;\n    return (*minor_status == 0) ? GSS_S_COMPLETE : GSS_S_FAILURE;\n}\n\n/* This function returns whether or not the caller set a cccache name.  Used by\n * gss_acquire_cred to figure out if the caller wants to only look at this\n * ccache or search the cache collection for the desired name */\nOM_uint32\nkg_caller_provided_ccache_name (OM_uint32 *minor_status,\n                                int *out_caller_provided_name)\n{\n    if (out_caller_provided_name) {\n        *out_caller_provided_name =\n            (k5_getspecific(K5_KEY_GSS_KRB5_CCACHE_NAME) != NULL);\n    }\n\n    *minor_status = 0;\n    return GSS_S_COMPLETE;\n}\n\nOM_uint32\nkg_get_ccache_name (OM_uint32 *minor_status, const char **out_name)\n{\n    const char *name = NULL;\n    OM_uint32 err = 0;\n    char *kg_ccache_name;\n\n    kg_ccache_name = k5_getspecific(K5_KEY_GSS_KRB5_CCACHE_NAME);\n\n    if (kg_ccache_name != NULL) {\n        name = strdup(kg_ccache_name);\n        if (name == NULL)\n            err = ENOMEM;\n    } else {\n        krb5_context context = NULL;\n\n        /* Reset the context default ccache (see text above), and then\n           retrieve it.  */\n        err = krb5_gss_init_context(&context);\n        if (!err)\n            err = krb5_cc_set_default_name (context, NULL);\n        if (!err) {\n            name = krb5_cc_default_name(context);\n            if (name) {\n                name = strdup(name);\n                if (name == NULL)\n                    err = ENOMEM;\n            }\n        }\n        if (err && context)\n            save_error_info(err, context);\n        if (context)\n            krb5_free_context(context);\n    }\n\n    if (!err) {\n        if (out_name) {\n            *out_name = name;\n        }\n    }\n\n    *minor_status = err;\n    return (*minor_status == 0) ? GSS_S_COMPLETE : GSS_S_FAILURE;\n}\n\nOM_uint32\nkg_set_ccache_name (OM_uint32 *minor_status, const char *name)\n{\n    char *new_name = NULL;\n    char *swap = NULL;\n    char *kg_ccache_name;\n    krb5_error_code kerr;\n\n    if (name) {\n        new_name = strdup(name);\n        if (new_name == NULL) {\n            *minor_status = ENOMEM;\n            return GSS_S_FAILURE;\n        }\n    }\n\n    kg_ccache_name = k5_getspecific(K5_KEY_GSS_KRB5_CCACHE_NAME);\n    swap = kg_ccache_name;\n    kg_ccache_name = new_name;\n    new_name = swap;\n    kerr = k5_setspecific(K5_KEY_GSS_KRB5_CCACHE_NAME, kg_ccache_name);\n    if (kerr != 0) {\n        /* Can't store, so free up the storage.  */\n        free(kg_ccache_name);\n        /* ??? free(new_name); */\n        *minor_status = kerr;\n        return GSS_S_FAILURE;\n    }\n\n    free (new_name);\n    *minor_status = 0;\n    return GSS_S_COMPLETE;\n}\n\n#define g_OID_prefix_equal(o1, o2)                                      \\\n    (((o1)->length >= (o2)->length) &&                                  \\\n     (memcmp((o1)->elements, (o2)->elements, (o2)->length) == 0))\n\n/*\n * gss_inquire_sec_context_by_oid() methods\n */\nstatic struct {\n    gss_OID_desc oid;\n    OM_uint32 (*func)(OM_uint32 *, const gss_ctx_id_t, const gss_OID, gss_buffer_set_t *);\n} krb5_gss_inquire_sec_context_by_oid_ops[] = {\n    {\n        {GSS_KRB5_GET_TKT_FLAGS_OID_LENGTH, GSS_KRB5_GET_TKT_FLAGS_OID},\n        gss_krb5int_get_tkt_flags\n    },\n    {\n        {GSS_KRB5_EXTRACT_AUTHZ_DATA_FROM_SEC_CONTEXT_OID_LENGTH, GSS_KRB5_EXTRACT_AUTHZ_DATA_FROM_SEC_CONTEXT_OID},\n        gss_krb5int_extract_authz_data_from_sec_context\n    },\n    {\n        {GSS_KRB5_INQ_SSPI_SESSION_KEY_OID_LENGTH, GSS_KRB5_INQ_SSPI_SESSION_KEY_OID},\n        gss_krb5int_inq_session_key\n    },\n    {\n        {GSS_KRB5_EXPORT_LUCID_SEC_CONTEXT_OID_LENGTH, GSS_KRB5_EXPORT_LUCID_SEC_CONTEXT_OID},\n        gss_krb5int_export_lucid_sec_context\n    },\n    {\n        {GSS_KRB5_EXTRACT_AUTHTIME_FROM_SEC_CONTEXT_OID_LENGTH, GSS_KRB5_EXTRACT_AUTHTIME_FROM_SEC_CONTEXT_OID},\n        gss_krb5int_extract_authtime_from_sec_context\n    }\n};\n\nOM_uint32 KRB5_CALLCONV\nkrb5_gss_inquire_sec_context_by_oid (OM_uint32 *minor_status,\n                                     const gss_ctx_id_t context_handle,\n                                     const gss_OID desired_object,\n                                     gss_buffer_set_t *data_set)\n{\n    krb5_gss_ctx_id_rec *ctx;\n    size_t i;\n\n    if (minor_status == NULL)\n        return GSS_S_CALL_INACCESSIBLE_WRITE;\n\n    *minor_status = 0;\n\n    if (desired_object == GSS_C_NO_OID)\n        return GSS_S_CALL_INACCESSIBLE_READ;\n\n    if (data_set == NULL)\n        return GSS_S_CALL_INACCESSIBLE_WRITE;\n\n    *data_set = GSS_C_NO_BUFFER_SET;\n\n    ctx = (krb5_gss_ctx_id_rec *) context_handle;\n\n    if (ctx->terminated || !ctx->established)\n        return GSS_S_NO_CONTEXT;\n\n    for (i = 0; i < sizeof(krb5_gss_inquire_sec_context_by_oid_ops)/\n             sizeof(krb5_gss_inquire_sec_context_by_oid_ops[0]); i++) {\n        if (g_OID_prefix_equal(desired_object, &krb5_gss_inquire_sec_context_by_oid_ops[i].oid)) {\n            return (*krb5_gss_inquire_sec_context_by_oid_ops[i].func)(minor_status,\n                                                                      context_handle,\n                                                                      desired_object,\n                                                                      data_set);\n        }\n    }\n\n    *minor_status = EINVAL;\n\n    return GSS_S_UNAVAILABLE;\n}\n\n/*\n * gss_inquire_cred_by_oid() methods\n */\n#if 0\nstatic struct {\n    gss_OID_desc oid;\n    OM_uint32 (*func)(OM_uint32 *, const gss_cred_id_t, const gss_OID, gss_buffer_set_t *);\n} krb5_gss_inquire_cred_by_oid_ops[] = {\n};\n#endif\n\nstatic OM_uint32 KRB5_CALLCONV\nkrb5_gss_inquire_cred_by_oid(OM_uint32 *minor_status,\n                             const gss_cred_id_t cred_handle,\n                             const gss_OID desired_object,\n                             gss_buffer_set_t *data_set)\n{\n    OM_uint32 major_status = GSS_S_FAILURE;\n#if 0\n    size_t i;\n#endif\n\n    if (minor_status == NULL)\n        return GSS_S_CALL_INACCESSIBLE_WRITE;\n\n    *minor_status = 0;\n\n    if (desired_object == GSS_C_NO_OID)\n        return GSS_S_CALL_INACCESSIBLE_READ;\n\n    if (data_set == NULL)\n        return GSS_S_CALL_INACCESSIBLE_WRITE;\n\n    *data_set = GSS_C_NO_BUFFER_SET;\n    if (cred_handle == GSS_C_NO_CREDENTIAL) {\n        *minor_status = (OM_uint32)KRB5_NOCREDS_SUPPLIED;\n        return GSS_S_NO_CRED;\n    }\n\n    major_status = krb5_gss_validate_cred(minor_status, cred_handle);\n    if (GSS_ERROR(major_status))\n        return major_status;\n\n#if 0\n    for (i = 0; i < sizeof(krb5_gss_inquire_cred_by_oid_ops)/\n             sizeof(krb5_gss_inquire_cred_by_oid_ops[0]); i++) {\n        if (g_OID_prefix_equal(desired_object, &krb5_gss_inquire_cred_by_oid_ops[i].oid)) {\n            return (*krb5_gss_inquire_cred_by_oid_ops[i].func)(minor_status,\n                                                               cred_handle,\n                                                               desired_object,\n                                                               data_set);\n        }\n    }\n#endif\n\n    *minor_status = EINVAL;\n\n    return GSS_S_UNAVAILABLE;\n}\n\n/*\n * gss_set_sec_context_option() methods\n * (Disabled until we have something to populate the array.)\n */\n#if 0\nstatic struct {\n    gss_OID_desc oid;\n    OM_uint32 (*func)(OM_uint32 *, gss_ctx_id_t *, const gss_OID, const gss_buffer_t);\n} krb5_gss_set_sec_context_option_ops[] = {\n};\n#endif\n\nOM_uint32 KRB5_CALLCONV\nkrb5_gss_set_sec_context_option (OM_uint32 *minor_status,\n                                 gss_ctx_id_t *context_handle,\n                                 const gss_OID desired_object,\n                                 const gss_buffer_t value)\n{\n#if 0\n    size_t i;\n#endif\n\n    if (minor_status == NULL)\n        return GSS_S_CALL_INACCESSIBLE_WRITE;\n\n    *minor_status = 0;\n\n    if (context_handle == NULL)\n        return GSS_S_CALL_INACCESSIBLE_READ;\n\n    if (desired_object == GSS_C_NO_OID)\n        return GSS_S_CALL_INACCESSIBLE_READ;\n\n#if 0\n    for (i = 0; i < sizeof(krb5_gss_set_sec_context_option_ops)/\n             sizeof(krb5_gss_set_sec_context_option_ops[0]); i++) {\n        if (g_OID_prefix_equal(desired_object, &krb5_gss_set_sec_context_option_ops[i].oid)) {\n            return (*krb5_gss_set_sec_context_option_ops[i].func)(minor_status,\n                                                                  context_handle,\n                                                                  desired_object,\n                                                                  value);\n        }\n    }\n#endif\n\n    *minor_status = EINVAL;\n\n    return GSS_S_UNAVAILABLE;\n}\n\nstatic OM_uint32\nno_ci_flags(OM_uint32 *minor_status,\n            gss_cred_id_t *cred_handle,\n            const gss_OID desired_oid,\n            const gss_buffer_t value)\n{\n    krb5_gss_cred_id_t cred;\n\n    cred = (krb5_gss_cred_id_t) *cred_handle;\n    cred->suppress_ci_flags = 1;\n\n    *minor_status = 0;\n    return GSS_S_COMPLETE;\n}\n/*\n * gssspi_set_cred_option() methods\n */\nstatic struct {\n    gss_OID_desc oid;\n    OM_uint32 (*func)(OM_uint32 *, gss_cred_id_t *, const gss_OID, const gss_buffer_t);\n} krb5_gssspi_set_cred_option_ops[] = {\n    {\n        {GSS_KRB5_COPY_CCACHE_OID_LENGTH, GSS_KRB5_COPY_CCACHE_OID},\n        gss_krb5int_copy_ccache\n    },\n    {\n        {GSS_KRB5_SET_ALLOWABLE_ENCTYPES_OID_LENGTH, GSS_KRB5_SET_ALLOWABLE_ENCTYPES_OID},\n        gss_krb5int_set_allowable_enctypes\n    },\n    {\n        {GSS_KRB5_SET_CRED_RCACHE_OID_LENGTH, GSS_KRB5_SET_CRED_RCACHE_OID},\n        gss_krb5int_set_cred_rcache\n    },\n    {\n        {GSS_KRB5_IMPORT_CRED_OID_LENGTH, GSS_KRB5_IMPORT_CRED_OID},\n        gss_krb5int_import_cred\n    },\n    {\n        {NO_CI_FLAGS_X_OID_LENGTH, NO_CI_FLAGS_X_OID},\n        no_ci_flags\n    },\n};\n\nstatic OM_uint32 KRB5_CALLCONV\nkrb5_gssspi_set_cred_option(OM_uint32 *minor_status,\n                            gss_cred_id_t *cred_handle,\n                            const gss_OID desired_object,\n                            const gss_buffer_t value)\n{\n    OM_uint32 major_status = GSS_S_FAILURE;\n    size_t i;\n\n    if (minor_status == NULL)\n        return GSS_S_CALL_INACCESSIBLE_WRITE;\n\n    if (cred_handle == NULL)\n        return GSS_S_CALL_INACCESSIBLE_WRITE;\n\n    *minor_status = 0;\n\n    if (desired_object == GSS_C_NO_OID)\n        return GSS_S_CALL_INACCESSIBLE_READ;\n\n    if (*cred_handle != GSS_C_NO_CREDENTIAL) {\n        major_status = krb5_gss_validate_cred(minor_status, *cred_handle);\n        if (GSS_ERROR(major_status))\n            return major_status;\n    }\n\n    for (i = 0; i < sizeof(krb5_gssspi_set_cred_option_ops)/\n             sizeof(krb5_gssspi_set_cred_option_ops[0]); i++) {\n        if (g_OID_prefix_equal(desired_object, &krb5_gssspi_set_cred_option_ops[i].oid)) {\n            return (*krb5_gssspi_set_cred_option_ops[i].func)(minor_status,\n                                                              cred_handle,\n                                                              desired_object,\n                                                              value);\n        }\n    }\n\n    *minor_status = EINVAL;\n\n    return GSS_S_UNAVAILABLE;\n}\n\n/*\n * gssspi_mech_invoke() methods\n */\nstatic struct {\n    gss_OID_desc oid;\n    OM_uint32 (*func)(OM_uint32 *, const gss_OID, const gss_OID, gss_buffer_t);\n} krb5_gssspi_mech_invoke_ops[] = {\n    {\n        {GSS_KRB5_REGISTER_ACCEPTOR_IDENTITY_OID_LENGTH, GSS_KRB5_REGISTER_ACCEPTOR_IDENTITY_OID},\n        gss_krb5int_register_acceptor_identity\n    },\n    {\n        {GSS_KRB5_CCACHE_NAME_OID_LENGTH, GSS_KRB5_CCACHE_NAME_OID},\n        gss_krb5int_ccache_name\n    },\n    {\n        {GSS_KRB5_FREE_LUCID_SEC_CONTEXT_OID_LENGTH, GSS_KRB5_FREE_LUCID_SEC_CONTEXT_OID},\n        gss_krb5int_free_lucid_sec_context\n    },\n#ifndef _WIN32\n    {\n        {GSS_KRB5_USE_KDC_CONTEXT_OID_LENGTH, GSS_KRB5_USE_KDC_CONTEXT_OID},\n        krb5int_gss_use_kdc_context\n    },\n#endif\n};\n\nstatic OM_uint32 KRB5_CALLCONV\nkrb5_gssspi_mech_invoke (OM_uint32 *minor_status,\n                         const gss_OID desired_mech,\n                         const gss_OID desired_object,\n                         gss_buffer_t value)\n{\n    size_t i;\n\n    if (minor_status == NULL)\n        return GSS_S_CALL_INACCESSIBLE_WRITE;\n\n    *minor_status = 0;\n\n    if (desired_mech == GSS_C_NO_OID)\n        return GSS_S_BAD_MECH;\n\n    if (desired_object == GSS_C_NO_OID)\n        return GSS_S_CALL_INACCESSIBLE_READ;\n\n    for (i = 0; i < sizeof(krb5_gssspi_mech_invoke_ops)/\n             sizeof(krb5_gssspi_mech_invoke_ops[0]); i++) {\n        if (g_OID_prefix_equal(desired_object, &krb5_gssspi_mech_invoke_ops[i].oid)) {\n            return (*krb5_gssspi_mech_invoke_ops[i].func)(minor_status,\n                                                          desired_mech,\n                                                          desired_object,\n                                                          value);\n        }\n    }\n\n    *minor_status = EINVAL;\n\n    return GSS_S_UNAVAILABLE;\n}\n\n#define GS2_KRB5_SASL_NAME        \"GS2-KRB5\"\n#define GS2_KRB5_SASL_NAME_LEN    (sizeof(GS2_KRB5_SASL_NAME) - 1)\n\n#define GS2_IAKERB_SASL_NAME      \"GS2-IAKERB\"\n#define GS2_IAKERB_SASL_NAME_LEN  (sizeof(GS2_IAKERB_SASL_NAME) - 1)\n\nstatic OM_uint32 KRB5_CALLCONV\nkrb5_gss_inquire_mech_for_saslname(OM_uint32 *minor_status,\n                                   const gss_buffer_t sasl_mech_name,\n                                   gss_OID *mech_type)\n{\n    *minor_status = 0;\n\n    if (sasl_mech_name->length == GS2_KRB5_SASL_NAME_LEN &&\n        memcmp(sasl_mech_name->value,\n               GS2_KRB5_SASL_NAME, GS2_KRB5_SASL_NAME_LEN) == 0) {\n        if (mech_type != NULL)\n            *mech_type = (gss_OID)gss_mech_krb5;\n        return GSS_S_COMPLETE;\n    } else if (sasl_mech_name->length == GS2_IAKERB_SASL_NAME_LEN &&\n               memcmp(sasl_mech_name->value,\n                      GS2_IAKERB_SASL_NAME, GS2_IAKERB_SASL_NAME_LEN) == 0) {\n        if (mech_type != NULL)\n            *mech_type = (gss_OID)gss_mech_iakerb;\n        return GSS_S_COMPLETE;\n    }\n\n    return GSS_S_BAD_MECH;\n}\n\nstatic OM_uint32 KRB5_CALLCONV\nkrb5_gss_inquire_saslname_for_mech(OM_uint32 *minor_status,\n                                   const gss_OID desired_mech,\n                                   gss_buffer_t sasl_mech_name,\n                                   gss_buffer_t mech_name,\n                                   gss_buffer_t mech_description)\n{\n    if (g_OID_equal(desired_mech, gss_mech_iakerb)) {\n        if (!g_make_string_buffer(GS2_IAKERB_SASL_NAME, sasl_mech_name) ||\n            !g_make_string_buffer(\"iakerb\", mech_name) ||\n            !g_make_string_buffer(\"Initial and Pass Through Authentication \"\n                                  \"Kerberos Mechanism (IAKERB)\",\n                                  mech_description))\n            goto fail;\n    } else {\n        if (!g_make_string_buffer(GS2_KRB5_SASL_NAME, sasl_mech_name) ||\n            !g_make_string_buffer(\"krb5\", mech_name) ||\n            !g_make_string_buffer(\"Kerberos 5 GSS-API Mechanism\",\n                                  mech_description))\n            goto fail;\n    }\n\n    *minor_status = 0;\n    return GSS_S_COMPLETE;\n\nfail:\n    *minor_status = ENOMEM;\n    return GSS_S_FAILURE;\n}\n\nstatic OM_uint32 KRB5_CALLCONV\nkrb5_gss_inquire_attrs_for_mech(OM_uint32 *minor_status,\n                                gss_const_OID mech,\n                                gss_OID_set *mech_attrs,\n                                gss_OID_set *known_mech_attrs)\n{\n    OM_uint32 major, tmpMinor;\n\n    if (mech_attrs == NULL) {\n        *minor_status = 0;\n        return GSS_S_COMPLETE;\n    }\n\n    major = gss_create_empty_oid_set(minor_status, mech_attrs);\n    if (GSS_ERROR(major))\n        goto cleanup;\n\n#define MA_SUPPORTED(ma)    do {                                        \\\n        major = gss_add_oid_set_member(minor_status, (gss_OID)ma,       \\\n                                       mech_attrs);                     \\\n        if (GSS_ERROR(major))                                           \\\n            goto cleanup;                                               \\\n    } while (0)\n\n    MA_SUPPORTED(GSS_C_MA_MECH_CONCRETE);\n    MA_SUPPORTED(GSS_C_MA_ITOK_FRAMED);\n    MA_SUPPORTED(GSS_C_MA_AUTH_INIT);\n    MA_SUPPORTED(GSS_C_MA_AUTH_TARG);\n    MA_SUPPORTED(GSS_C_MA_DELEG_CRED);\n    MA_SUPPORTED(GSS_C_MA_INTEG_PROT);\n    MA_SUPPORTED(GSS_C_MA_CONF_PROT);\n    MA_SUPPORTED(GSS_C_MA_MIC);\n    MA_SUPPORTED(GSS_C_MA_WRAP);\n    MA_SUPPORTED(GSS_C_MA_PROT_READY);\n    MA_SUPPORTED(GSS_C_MA_REPLAY_DET);\n    MA_SUPPORTED(GSS_C_MA_OOS_DET);\n    MA_SUPPORTED(GSS_C_MA_CBINDINGS);\n    MA_SUPPORTED(GSS_C_MA_CTX_TRANS);\n\n    if (g_OID_equal(mech, gss_mech_iakerb)) {\n        MA_SUPPORTED(GSS_C_MA_AUTH_INIT_INIT);\n        MA_SUPPORTED(GSS_C_MA_NOT_DFLT_MECH);\n    } else if (!g_OID_equal(mech, gss_mech_krb5)) {\n        MA_SUPPORTED(GSS_C_MA_DEPRECATED);\n    }\n\ncleanup:\n    if (GSS_ERROR(major))\n        gss_release_oid_set(&tmpMinor, mech_attrs);\n\n    return major;\n}\n\nstatic OM_uint32 KRB5_CALLCONV\nkrb5_gss_localname(OM_uint32 *minor,\n                   const gss_name_t pname,\n                   const gss_const_OID mech_type,\n                   gss_buffer_t localname)\n{\n    krb5_context context;\n    krb5_error_code code;\n    krb5_gss_name_t kname;\n    char lname[BUFSIZ];\n\n    code = krb5_gss_init_context(&context);\n    if (code != 0) {\n        *minor = code;\n        return GSS_S_FAILURE;\n    }\n\n    kname = (krb5_gss_name_t)pname;\n\n    code = krb5_aname_to_localname(context, kname->princ,\n                                   sizeof(lname), lname);\n    if (code != 0) {\n        *minor = KRB5_NO_LOCALNAME;\n        krb5_free_context(context);\n        return GSS_S_FAILURE;\n    }\n\n\n    krb5_free_context(context);\n    localname->value = gssalloc_strdup(lname);\n    localname->length = strlen(lname);\n\n    return (code == 0) ? GSS_S_COMPLETE : GSS_S_FAILURE;\n}\n\n\nstatic OM_uint32 KRB5_CALLCONV\nkrb5_gss_authorize_localname(OM_uint32 *minor,\n                             const gss_name_t pname,\n                             gss_const_buffer_t local_user,\n                             gss_const_OID name_type)\n{\n    krb5_context context;\n    krb5_error_code code;\n    krb5_gss_name_t kname;\n    char *user;\n    int user_ok;\n\n    if (name_type != GSS_C_NO_OID &&\n        !g_OID_equal(name_type, GSS_C_NT_USER_NAME)) {\n        return GSS_S_BAD_NAMETYPE;\n    }\n\n    kname = (krb5_gss_name_t)pname;\n\n    code = krb5_gss_init_context(&context);\n    if (code != 0) {\n        *minor = code;\n        return GSS_S_FAILURE;\n    }\n\n    user = k5memdup0(local_user->value, local_user->length, &code);\n    if (user == NULL) {\n        *minor = code;\n        krb5_free_context(context);\n        return GSS_S_FAILURE;\n    }\n\n    user_ok = krb5_kuserok(context, kname->princ, user);\n\n    free(user);\n    krb5_free_context(context);\n\n    *minor = 0;\n    return user_ok ? GSS_S_COMPLETE : GSS_S_UNAUTHORIZED;\n}\n\nstatic struct gss_config krb5_mechanism = {\n    { GSS_MECH_KRB5_OID_LENGTH, GSS_MECH_KRB5_OID },\n    NULL,\n    krb5_gss_acquire_cred,\n    krb5_gss_release_cred,\n    krb5_gss_init_sec_context,\n#ifdef LEAN_CLIENT\n    NULL,\n#else\n    krb5_gss_accept_sec_context,\n#endif\n    krb5_gss_process_context_token,\n    krb5_gss_delete_sec_context,\n    krb5_gss_context_time,\n    krb5_gss_get_mic,\n    krb5_gss_verify_mic,\n#if defined(IOV_SHIM_EXERCISE_WRAP) || defined(IOV_SHIM_EXERCISE)\n    NULL,\n#else\n    krb5_gss_wrap,\n#endif\n#if defined(IOV_SHIM_EXERCISE_UNWRAP) || defined(IOV_SHIM_EXERCISE)\n    NULL,\n#else\n    krb5_gss_unwrap,\n#endif\n    krb5_gss_display_status,\n    krb5_gss_indicate_mechs,\n    krb5_gss_compare_name,\n    krb5_gss_display_name,\n    krb5_gss_import_name,\n    krb5_gss_release_name,\n    krb5_gss_inquire_cred,\n    NULL,                /* add_cred */\n#ifdef LEAN_CLIENT\n    NULL,\n    NULL,\n#else\n    krb5_gss_export_sec_context,\n    krb5_gss_import_sec_context,\n#endif\n    krb5_gss_inquire_cred_by_mech,\n    krb5_gss_inquire_names_for_mech,\n    krb5_gss_inquire_context,\n    krb5_gss_internal_release_oid,\n    krb5_gss_wrap_size_limit,\n    krb5_gss_localname,\n\n    krb5_gss_authorize_localname,\n    krb5_gss_export_name,\n    krb5_gss_duplicate_name,\n    krb5_gss_store_cred,\n    krb5_gss_inquire_sec_context_by_oid,\n    krb5_gss_inquire_cred_by_oid,\n    krb5_gss_set_sec_context_option,\n    krb5_gssspi_set_cred_option,\n    krb5_gssspi_mech_invoke,\n    NULL,                /* wrap_aead */\n    NULL,                /* unwrap_aead */\n    krb5_gss_wrap_iov,\n    krb5_gss_unwrap_iov,\n    krb5_gss_wrap_iov_length,\n    NULL,               /* complete_auth_token */\n    krb5_gss_acquire_cred_impersonate_name,\n    NULL,               /* krb5_gss_add_cred_impersonate_name */\n    NULL,               /* display_name_ext */\n    krb5_gss_inquire_name,\n    krb5_gss_get_name_attribute,\n    krb5_gss_set_name_attribute,\n    krb5_gss_delete_name_attribute,\n    krb5_gss_export_name_composite,\n    krb5_gss_map_name_to_any,\n    krb5_gss_release_any_name_mapping,\n    krb5_gss_pseudo_random,\n    NULL,               /* set_neg_mechs */\n    krb5_gss_inquire_saslname_for_mech,\n    krb5_gss_inquire_mech_for_saslname,\n    krb5_gss_inquire_attrs_for_mech,\n    krb5_gss_acquire_cred_from,\n    krb5_gss_store_cred_into,\n    krb5_gss_acquire_cred_with_password,\n    krb5_gss_export_cred,\n    krb5_gss_import_cred,\n    NULL,               /* import_sec_context_by_mech */\n    NULL,               /* import_name_by_mech */\n    NULL,               /* import_cred_by_mech */\n    krb5_gss_get_mic_iov,\n    krb5_gss_verify_mic_iov,\n    krb5_gss_get_mic_iov_length,\n};\n\n/* Functions which use security contexts or acquire creds are IAKERB-specific;\n * other functions can borrow from the krb5 mech. */\nstatic struct gss_config iakerb_mechanism = {\n    { GSS_MECH_KRB5_OID_LENGTH, GSS_MECH_KRB5_OID },\n    NULL,\n    iakerb_gss_acquire_cred,\n    krb5_gss_release_cred,\n    iakerb_gss_init_sec_context,\n#ifdef LEAN_CLIENT\n    NULL,\n#else\n    iakerb_gss_accept_sec_context,\n#endif\n    iakerb_gss_process_context_token,\n    iakerb_gss_delete_sec_context,\n    iakerb_gss_context_time,\n    iakerb_gss_get_mic,\n    iakerb_gss_verify_mic,\n#if defined(IOV_SHIM_EXERCISE_WRAP) || defined(IOV_SHIM_EXERCISE)\n    NULL,\n#else\n    iakerb_gss_wrap,\n#endif\n#if defined(IOV_SHIM_EXERCISE_UNWRAP) || defined(IOV_SHIM_EXERCISE)\n    NULL,\n#else\n    iakerb_gss_unwrap,\n#endif\n    krb5_gss_display_status,\n    krb5_gss_indicate_mechs,\n    krb5_gss_compare_name,\n    krb5_gss_display_name,\n    krb5_gss_import_name,\n    krb5_gss_release_name,\n    krb5_gss_inquire_cred,\n    NULL,                /* add_cred */\n#ifdef LEAN_CLIENT\n    NULL,\n    NULL,\n#else\n    iakerb_gss_export_sec_context,\n    NULL,\n#endif\n    krb5_gss_inquire_cred_by_mech,\n    krb5_gss_inquire_names_for_mech,\n    iakerb_gss_inquire_context,\n    krb5_gss_internal_release_oid,\n    iakerb_gss_wrap_size_limit,\n    krb5_gss_localname,\n    krb5_gss_authorize_localname,\n    krb5_gss_export_name,\n    krb5_gss_duplicate_name,\n    krb5_gss_store_cred,\n    iakerb_gss_inquire_sec_context_by_oid,\n    krb5_gss_inquire_cred_by_oid,\n    iakerb_gss_set_sec_context_option,\n    krb5_gssspi_set_cred_option,\n    krb5_gssspi_mech_invoke,\n    NULL,                /* wrap_aead */\n    NULL,                /* unwrap_aead */\n    iakerb_gss_wrap_iov,\n    iakerb_gss_unwrap_iov,\n    iakerb_gss_wrap_iov_length,\n    NULL,               /* complete_auth_token */\n    NULL,               /* acquire_cred_impersonate_name */\n    NULL,               /* add_cred_impersonate_name */\n    NULL,               /* display_name_ext */\n    krb5_gss_inquire_name,\n    krb5_gss_get_name_attribute,\n    krb5_gss_set_name_attribute,\n    krb5_gss_delete_name_attribute,\n    krb5_gss_export_name_composite,\n    krb5_gss_map_name_to_any,\n    krb5_gss_release_any_name_mapping,\n    iakerb_gss_pseudo_random,\n    NULL,               /* set_neg_mechs */\n    krb5_gss_inquire_saslname_for_mech,\n    krb5_gss_inquire_mech_for_saslname,\n    krb5_gss_inquire_attrs_for_mech,\n    krb5_gss_acquire_cred_from,\n    krb5_gss_store_cred_into,\n    iakerb_gss_acquire_cred_with_password,\n    krb5_gss_export_cred,\n    krb5_gss_import_cred,\n    NULL,               /* import_sec_context_by_mech */\n    NULL,               /* import_name_by_mech */\n    NULL,               /* import_cred_by_mech */\n    iakerb_gss_get_mic_iov,\n    iakerb_gss_verify_mic_iov,\n    iakerb_gss_get_mic_iov_length,\n};\n\n#ifdef _GSS_STATIC_LINK\n#include \"mglueP.h\"\nstatic int gss_iakerbmechglue_init(void)\n{\n    struct gss_mech_config mech_iakerb;\n\n    memset(&mech_iakerb, 0, sizeof(mech_iakerb));\n    mech_iakerb.mech = &iakerb_mechanism;\n\n    mech_iakerb.mechNameStr = \"iakerb\";\n    mech_iakerb.mech_type = (gss_OID)gss_mech_iakerb;\n    gssint_register_mechinfo(&mech_iakerb);\n\n    return 0;\n}\n\nstatic int gss_krb5mechglue_init(void)\n{\n    struct gss_mech_config mech_krb5;\n\n    memset(&mech_krb5, 0, sizeof(mech_krb5));\n    mech_krb5.mech = &krb5_mechanism;\n\n    mech_krb5.mechNameStr = \"kerberos_v5\";\n    mech_krb5.mech_type = (gss_OID)gss_mech_krb5;\n    gssint_register_mechinfo(&mech_krb5);\n\n    mech_krb5.mechNameStr = \"kerberos_v5_old\";\n    mech_krb5.mech_type = (gss_OID)gss_mech_krb5_old;\n    gssint_register_mechinfo(&mech_krb5);\n\n    mech_krb5.mechNameStr = \"mskrb\";\n    mech_krb5.mech_type = (gss_OID)gss_mech_krb5_wrong;\n    gssint_register_mechinfo(&mech_krb5);\n\n    return 0;\n}\n#else\nMAKE_INIT_FUNCTION(gss_krb5int_lib_init);\nMAKE_FINI_FUNCTION(gss_krb5int_lib_fini);\n\ngss_mechanism KRB5_CALLCONV\ngss_mech_initialize(void)\n{\n    return &krb5_mechanism;\n}\n#endif /* _GSS_STATIC_LINK */\n\nint gss_krb5int_lib_init(void)\n{\n    int err;\n\n#ifdef SHOW_INITFINI_FUNCS\n    printf(\"gss_krb5int_lib_init\\n\");\n#endif\n\n    add_error_table(&et_k5g_error_table);\n\n#ifndef LEAN_CLIENT\n    err = k5_mutex_finish_init(&gssint_krb5_keytab_lock);\n    if (err)\n        return err;\n#endif /* LEAN_CLIENT */\n    err = k5_key_register(K5_KEY_GSS_KRB5_SET_CCACHE_OLD_NAME, free);\n    if (err)\n        return err;\n    err = k5_key_register(K5_KEY_GSS_KRB5_CCACHE_NAME, free);\n    if (err)\n        return err;\n    err = k5_key_register(K5_KEY_GSS_KRB5_ERROR_MESSAGE,\n                          krb5_gss_delete_error_info);\n    if (err)\n        return err;\n#ifndef _WIN32\n    err = k5_mutex_finish_init(&kg_kdc_flag_mutex);\n    if (err)\n        return err;\n    err = k5_mutex_finish_init(&kg_vdb.mutex);\n    if (err)\n        return err;\n#endif\n#ifdef _GSS_STATIC_LINK\n    err = gss_krb5mechglue_init();\n    if (err)\n        return err;\n    err = gss_iakerbmechglue_init();\n    if (err)\n        return err;\n#endif\n\n    return 0;\n}\n\nvoid gss_krb5int_lib_fini(void)\n{\n#ifndef _GSS_STATIC_LINK\n    if (!INITIALIZER_RAN(gss_krb5int_lib_init) || PROGRAM_EXITING()) {\n# ifdef SHOW_INITFINI_FUNCS\n        printf(\"gss_krb5int_lib_fini: skipping\\n\");\n# endif\n        return;\n    }\n#endif\n#ifdef SHOW_INITFINI_FUNCS\n    printf(\"gss_krb5int_lib_fini\\n\");\n#endif\n    remove_error_table(&et_k5g_error_table);\n\n    k5_key_delete(K5_KEY_GSS_KRB5_SET_CCACHE_OLD_NAME);\n    k5_key_delete(K5_KEY_GSS_KRB5_CCACHE_NAME);\n    k5_key_delete(K5_KEY_GSS_KRB5_ERROR_MESSAGE);\n    k5_mutex_destroy(&kg_vdb.mutex);\n#ifndef _WIN32\n    k5_mutex_destroy(&kg_kdc_flag_mutex);\n#endif\n#ifndef LEAN_CLIENT\n    k5_mutex_destroy(&gssint_krb5_keytab_lock);\n#endif /* LEAN_CLIENT */\n}\n\n#ifdef _GSS_STATIC_LINK\nextern OM_uint32 gssint_lib_init(void);\n#endif\n\nOM_uint32 gss_krb5int_initialize_library (void)\n{\n#ifdef _GSS_STATIC_LINK\n    return gssint_mechglue_initialize_library();\n#else\n    return CALL_INIT_FUNCTION(gss_krb5int_lib_init);\n#endif\n}\n", "/* -*- mode: c; c-basic-offset: 4; indent-tabs-mode: nil -*- */\n/*\n * Copyright 2009  by the Massachusetts Institute of Technology.\n * All Rights Reserved.\n *\n * Export of this software from the United States of America may\n *   require a specific license from the United States Government.\n *   It is the responsibility of any person or organization contemplating\n *   export to obtain such a license before exporting.\n *\n * WITHIN THAT CONSTRAINT, permission to use, copy, modify, and\n * distribute this software and its documentation for any purpose and\n * without fee is hereby granted, provided that the above copyright\n * notice appear in all copies and that both that copyright notice and\n * this permission notice appear in supporting documentation, and that\n * the name of M.I.T. not be used in advertising or publicity pertaining\n * to distribution of the software without specific, written prior\n * permission.  Furthermore if you modify this software you must label\n * your software as modified software and not distribute it in such a\n * fashion that it might be confused with the original M.I.T. software.\n * M.I.T. makes no representations about the suitability of\n * this software for any purpose.  It is provided \"as is\" without express\n * or implied warranty.\n */\n#include \"k5-int.h\"\n#include \"gssapiP_krb5.h\"\n\n/*\n * IAKERB implementation\n */\n\nextern int gssint_get_der_length(unsigned char **, OM_uint32, unsigned int*);\n\nenum iakerb_state {\n    IAKERB_AS_REQ,      /* acquiring ticket with initial creds */\n    IAKERB_TGS_REQ,     /* acquiring ticket with TGT */\n    IAKERB_AP_REQ       /* hand-off to normal GSS AP-REQ exchange */\n};\n\nstruct _iakerb_ctx_id_rec {\n    krb5_magic magic;                   /* KG_IAKERB_CONTEXT */\n    krb5_context k5c;\n    gss_cred_id_t defcred;              /* Initiator only */\n    enum iakerb_state state;            /* Initiator only */\n    krb5_init_creds_context icc;        /* Initiator only */\n    krb5_tkt_creds_context tcc;         /* Initiator only */\n    gss_ctx_id_t gssc;\n    krb5_data conv;                     /* conversation for checksumming */\n    unsigned int count;                 /* number of round trips */\n    int initiate;\n    int established;\n    krb5_get_init_creds_opt *gic_opts;\n};\n\n#define IAKERB_MAX_HOPS ( 16 /* MAX_IN_TKT_LOOPS */ + KRB5_REFERRAL_MAXHOPS )\n\ntypedef struct _iakerb_ctx_id_rec iakerb_ctx_id_rec;\ntypedef iakerb_ctx_id_rec *iakerb_ctx_id_t;\n\n/*\n * Release an IAKERB context\n */\nstatic void\niakerb_release_context(iakerb_ctx_id_t ctx)\n{\n    OM_uint32 tmp;\n\n    if (ctx == NULL)\n        return;\n\n    krb5_gss_release_cred(&tmp, &ctx->defcred);\n    krb5_init_creds_free(ctx->k5c, ctx->icc);\n    krb5_tkt_creds_free(ctx->k5c, ctx->tcc);\n    krb5_gss_delete_sec_context(&tmp, &ctx->gssc, NULL);\n    krb5_free_data_contents(ctx->k5c, &ctx->conv);\n    krb5_get_init_creds_opt_free(ctx->k5c, ctx->gic_opts);\n    krb5_free_context(ctx->k5c);\n    free(ctx);\n}\n\n/*\n * Create a IAKERB-FINISHED structure containing a checksum of\n * the entire IAKERB exchange.\n */\nkrb5_error_code\niakerb_make_finished(krb5_context context,\n                     krb5_key key,\n                     const krb5_data *conv,\n                     krb5_data **finished)\n{\n    krb5_error_code code;\n    krb5_iakerb_finished iaf;\n\n    *finished = NULL;\n\n    memset(&iaf, 0, sizeof(iaf));\n\n    if (key == NULL)\n        return KRB5KDC_ERR_NULL_KEY;\n\n    code = krb5_k_make_checksum(context, 0, key, KRB5_KEYUSAGE_IAKERB_FINISHED,\n                                conv, &iaf.checksum);\n    if (code != 0)\n        return code;\n\n    code = encode_krb5_iakerb_finished(&iaf, finished);\n\n    krb5_free_checksum_contents(context, &iaf.checksum);\n\n    return code;\n}\n\n/*\n * Verify a IAKERB-FINISHED structure submitted by the initiator\n */\nkrb5_error_code\niakerb_verify_finished(krb5_context context,\n                       krb5_key key,\n                       const krb5_data *conv,\n                       const krb5_data *finished)\n{\n    krb5_error_code code;\n    krb5_iakerb_finished *iaf;\n    krb5_boolean valid = FALSE;\n\n    if (key == NULL)\n        return KRB5KDC_ERR_NULL_KEY;\n\n    code = decode_krb5_iakerb_finished(finished, &iaf);\n    if (code != 0)\n        return code;\n\n    code = krb5_k_verify_checksum(context, key, KRB5_KEYUSAGE_IAKERB_FINISHED,\n                                  conv, &iaf->checksum, &valid);\n    if (code == 0 && valid == FALSE)\n        code = KRB5KRB_AP_ERR_BAD_INTEGRITY;\n\n    krb5_free_iakerb_finished(context, iaf);\n\n    return code;\n}\n\n/*\n * Save a token for future checksumming.\n */\nstatic krb5_error_code\niakerb_save_token(iakerb_ctx_id_t ctx, const gss_buffer_t token)\n{\n    char *p;\n\n    p = realloc(ctx->conv.data, ctx->conv.length + token->length);\n    if (p == NULL)\n        return ENOMEM;\n\n    memcpy(p + ctx->conv.length, token->value, token->length);\n    ctx->conv.data = p;\n    ctx->conv.length += token->length;\n\n    return 0;\n}\n\n/*\n * Parse a token into IAKERB-HEADER and KRB-KDC-REQ/REP\n */\nstatic krb5_error_code\niakerb_parse_token(iakerb_ctx_id_t ctx,\n                   int initialContextToken,\n                   const gss_buffer_t token,\n                   krb5_data *realm,\n                   krb5_data **cookie,\n                   krb5_data *request)\n{\n    krb5_error_code code;\n    krb5_iakerb_header *iah = NULL;\n    unsigned int bodysize, lenlen;\n    int length;\n    unsigned char *ptr;\n    int flags = 0;\n    krb5_data data;\n\n    if (token == GSS_C_NO_BUFFER || token->length == 0) {\n        code = KRB5_BAD_MSIZE;\n        goto cleanup;\n    }\n\n    if (initialContextToken)\n        flags |= G_VFY_TOKEN_HDR_WRAPPER_REQUIRED;\n\n    ptr = token->value;\n\n    code = g_verify_token_header(gss_mech_iakerb,\n                                 &bodysize, &ptr,\n                                 IAKERB_TOK_PROXY,\n                                 token->length, flags);\n    if (code != 0)\n        goto cleanup;\n\n    data.data = (char *)ptr;\n\n    if (bodysize-- == 0 || *ptr++ != 0x30 /* SEQUENCE */) {\n        code = ASN1_BAD_ID;\n        goto cleanup;\n    }\n\n    length = gssint_get_der_length(&ptr, bodysize, &lenlen);\n    if (length < 0 || bodysize - lenlen < (unsigned int)length) {\n        code = KRB5_BAD_MSIZE;\n        goto cleanup;\n    }\n    data.length = 1 /* SEQUENCE */ + lenlen + length;\n\n    ptr += length;\n    bodysize -= (lenlen + length);\n\n    code = decode_krb5_iakerb_header(&data, &iah);\n    if (code != 0)\n        goto cleanup;\n\n    if (realm != NULL) {\n        *realm = iah->target_realm;\n        iah->target_realm.data = NULL;\n    }\n\n    if (cookie != NULL) {\n        *cookie = iah->cookie;\n        iah->cookie = NULL;\n    }\n\n    request->data = (char *)ptr;\n    request->length = bodysize;\n\n    assert(request->data + request->length ==\n           (char *)token->value + token->length);\n\ncleanup:\n    krb5_free_iakerb_header(ctx->k5c, iah);\n\n    return code;\n}\n\n/*\n * Create a token from IAKERB-HEADER and KRB-KDC-REQ/REP\n */\nstatic krb5_error_code\niakerb_make_token(iakerb_ctx_id_t ctx,\n                  krb5_data *realm,\n                  krb5_data *cookie,\n                  krb5_data *request,\n                  int initialContextToken,\n                  gss_buffer_t token)\n{\n    krb5_error_code code;\n    krb5_iakerb_header iah;\n    krb5_data *data = NULL;\n    char *p;\n    unsigned int tokenSize;\n    unsigned char *q;\n\n    token->value = NULL;\n    token->length = 0;\n\n    /*\n     * Assemble the IAKERB-HEADER from the realm and cookie\n     */\n    memset(&iah, 0, sizeof(iah));\n    iah.target_realm = *realm;\n    iah.cookie = cookie;\n\n    code = encode_krb5_iakerb_header(&iah, &data);\n    if (code != 0)\n        goto cleanup;\n\n    /*\n     * Concatenate Kerberos request.\n     */\n    p = realloc(data->data, data->length + request->length);\n    if (p == NULL) {\n        code = ENOMEM;\n        goto cleanup;\n    }\n    data->data = p;\n\n    if (request->length > 0)\n        memcpy(data->data + data->length, request->data, request->length);\n    data->length += request->length;\n\n    if (initialContextToken)\n        tokenSize = g_token_size(gss_mech_iakerb, data->length);\n    else\n        tokenSize = 2 + data->length;\n\n    token->value = q = gssalloc_malloc(tokenSize);\n    if (q == NULL) {\n        code = ENOMEM;\n        goto cleanup;\n    }\n    token->length = tokenSize;\n\n    if (initialContextToken) {\n        g_make_token_header(gss_mech_iakerb, data->length, &q,\n                            IAKERB_TOK_PROXY);\n    } else {\n        store_16_be(IAKERB_TOK_PROXY, q);\n        q += 2;\n    }\n    memcpy(q, data->data, data->length);\n    q += data->length;\n\n    assert(q == (unsigned char *)token->value + token->length);\n\ncleanup:\n    krb5_free_data(ctx->k5c, data);\n\n    return code;\n}\n\n/*\n * Parse the IAKERB token in input_token and send the contained KDC\n * request to the KDC for the realm.\n *\n * Wrap the KDC reply in output_token.\n */\nstatic krb5_error_code\niakerb_acceptor_step(iakerb_ctx_id_t ctx,\n                     int initialContextToken,\n                     const gss_buffer_t input_token,\n                     gss_buffer_t output_token)\n{\n    krb5_error_code code;\n    krb5_data request = empty_data(), reply = empty_data();\n    krb5_data realm = empty_data();\n    OM_uint32 tmp;\n    int tcp_only, use_master;\n    krb5_ui_4 kdc_code;\n\n    output_token->length = 0;\n    output_token->value = NULL;\n\n    if (ctx->count >= IAKERB_MAX_HOPS) {\n        code = KRB5_KDC_UNREACH;\n        goto cleanup;\n    }\n\n    code = iakerb_parse_token(ctx, initialContextToken, input_token, &realm,\n                              NULL, &request);\n    if (code != 0)\n        goto cleanup;\n\n    if (realm.length == 0 || request.length == 0) {\n        code = KRB5_BAD_MSIZE;\n        goto cleanup;\n    }\n\n    code = iakerb_save_token(ctx, input_token);\n    if (code != 0)\n        goto cleanup;\n\n    for (tcp_only = 0; tcp_only <= 1; tcp_only++) {\n        use_master = 0;\n        code = krb5_sendto_kdc(ctx->k5c, &request, &realm,\n                               &reply, &use_master, tcp_only);\n        if (code == 0 && krb5_is_krb_error(&reply)) {\n            krb5_error *error;\n\n            code = decode_krb5_error(&reply, &error);\n            if (code != 0)\n                goto cleanup;\n            kdc_code = error->error;\n            krb5_free_error(ctx->k5c, error);\n            if (kdc_code == KRB_ERR_RESPONSE_TOO_BIG) {\n                krb5_free_data_contents(ctx->k5c, &reply);\n                reply = empty_data();\n                continue;\n            }\n        }\n        break;\n    }\n\n    if (code == KRB5_KDC_UNREACH || code == KRB5_REALM_UNKNOWN) {\n        krb5_error error;\n\n        memset(&error, 0, sizeof(error));\n        if (code == KRB5_KDC_UNREACH)\n            error.error = KRB_AP_ERR_IAKERB_KDC_NO_RESPONSE;\n        else if (code == KRB5_REALM_UNKNOWN)\n            error.error = KRB_AP_ERR_IAKERB_KDC_NOT_FOUND;\n\n        code = krb5_mk_error(ctx->k5c, &error, &reply);\n        if (code != 0)\n            goto cleanup;\n    } else if (code != 0)\n        goto cleanup;\n\n    code = iakerb_make_token(ctx, &realm, NULL, &reply, 0, output_token);\n    if (code != 0)\n        goto cleanup;\n\n    code = iakerb_save_token(ctx, output_token);\n    if (code != 0)\n        goto cleanup;\n\n    ctx->count++;\n\ncleanup:\n    if (code != 0)\n        gss_release_buffer(&tmp, output_token);\n    /* request is a pointer into input_token, no need to free */\n    krb5_free_data_contents(ctx->k5c, &realm);\n    krb5_free_data_contents(ctx->k5c, &reply);\n\n    return code;\n}\n\n/*\n * Initialise the krb5_init_creds context for the IAKERB context\n */\nstatic krb5_error_code\niakerb_init_creds_ctx(iakerb_ctx_id_t ctx,\n                      krb5_gss_cred_id_t cred,\n                      OM_uint32 time_req)\n{\n    krb5_error_code code;\n\n    if (cred->iakerb_mech == 0) {\n        code = EINVAL;\n        goto cleanup;\n    }\n\n    assert(cred->name != NULL);\n    assert(cred->name->princ != NULL);\n\n    code = krb5_get_init_creds_opt_alloc(ctx->k5c, &ctx->gic_opts);\n    if (code != 0)\n        goto cleanup;\n\n    if (time_req != 0 && time_req != GSS_C_INDEFINITE)\n        krb5_get_init_creds_opt_set_tkt_life(ctx->gic_opts, time_req);\n\n    code = krb5_get_init_creds_opt_set_out_ccache(ctx->k5c, ctx->gic_opts,\n                                                  cred->ccache);\n    if (code != 0)\n        goto cleanup;\n\n    code = krb5_init_creds_init(ctx->k5c,\n                                cred->name->princ,\n                                NULL,   /* prompter */\n                                NULL,   /* data */\n                                0,      /* start_time */\n                                ctx->gic_opts,\n                                &ctx->icc);\n    if (code != 0)\n        goto cleanup;\n\n    if (cred->password != NULL) {\n        code = krb5_init_creds_set_password(ctx->k5c, ctx->icc,\n                                            cred->password);\n    } else {\n        code = krb5_init_creds_set_keytab(ctx->k5c, ctx->icc,\n                                          cred->client_keytab);\n    }\n    if (code != 0)\n        goto cleanup;\n\ncleanup:\n    return code;\n}\n\n/*\n * Initialise the krb5_tkt_creds context for the IAKERB context\n */\nstatic krb5_error_code\niakerb_tkt_creds_ctx(iakerb_ctx_id_t ctx,\n                     krb5_gss_cred_id_t cred,\n                     krb5_gss_name_t name,\n                     OM_uint32 time_req)\n\n{\n    krb5_error_code code;\n    krb5_creds creds;\n    krb5_timestamp now;\n\n    assert(cred->name != NULL);\n    assert(cred->name->princ != NULL);\n\n    memset(&creds, 0, sizeof(creds));\n\n    creds.client = cred->name->princ;\n    creds.server = name->princ;\n\n    if (time_req != 0 && time_req != GSS_C_INDEFINITE) {\n        code = krb5_timeofday(ctx->k5c, &now);\n        if (code != 0)\n            goto cleanup;\n\n        creds.times.endtime = now + time_req;\n    }\n\n    if (cred->name->ad_context != NULL) {\n        code = krb5_authdata_export_authdata(ctx->k5c,\n                                             cred->name->ad_context,\n                                             AD_USAGE_TGS_REQ,\n                                             &creds.authdata);\n        if (code != 0)\n            goto cleanup;\n    }\n\n    code = krb5_tkt_creds_init(ctx->k5c, cred->ccache, &creds, 0, &ctx->tcc);\n    if (code != 0)\n        goto cleanup;\n\ncleanup:\n    krb5_free_authdata(ctx->k5c, creds.authdata);\n\n    return code;\n}\n\n/*\n * Parse the IAKERB token in input_token and process the KDC\n * response.\n *\n * Emit the next KDC request, if any, in output_token.\n */\nstatic krb5_error_code\niakerb_initiator_step(iakerb_ctx_id_t ctx,\n                      krb5_gss_cred_id_t cred,\n                      krb5_gss_name_t name,\n                      OM_uint32 time_req,\n                      const gss_buffer_t input_token,\n                      gss_buffer_t output_token)\n{\n    krb5_error_code code = 0;\n    krb5_data in = empty_data(), out = empty_data(), realm = empty_data();\n    krb5_data *cookie = NULL;\n    OM_uint32 tmp;\n    unsigned int flags = 0;\n    krb5_ticket_times times;\n\n    output_token->length = 0;\n    output_token->value = NULL;\n\n    if (input_token != GSS_C_NO_BUFFER) {\n        code = iakerb_parse_token(ctx, 0, input_token, NULL, &cookie, &in);\n        if (code != 0)\n            goto cleanup;\n\n        code = iakerb_save_token(ctx, input_token);\n        if (code != 0)\n            goto cleanup;\n    }\n\n    switch (ctx->state) {\n    case IAKERB_AS_REQ:\n        if (ctx->icc == NULL) {\n            code = iakerb_init_creds_ctx(ctx, cred, time_req);\n            if (code != 0)\n                goto cleanup;\n        }\n\n        code = krb5_init_creds_step(ctx->k5c, ctx->icc, &in, &out, &realm,\n                                    &flags);\n        if (code != 0) {\n            if (cred->have_tgt) {\n                /* We were trying to refresh; keep going with current creds. */\n                ctx->state = IAKERB_TGS_REQ;\n                krb5_clear_error_message(ctx->k5c);\n            } else {\n                goto cleanup;\n            }\n        } else if (!(flags & KRB5_INIT_CREDS_STEP_FLAG_CONTINUE)) {\n            krb5_init_creds_get_times(ctx->k5c, ctx->icc, &times);\n            kg_cred_set_initial_refresh(ctx->k5c, cred, &times);\n            cred->expire = times.endtime;\n\n            krb5_init_creds_free(ctx->k5c, ctx->icc);\n            ctx->icc = NULL;\n\n            ctx->state = IAKERB_TGS_REQ;\n        } else\n            break;\n        in = empty_data();\n        /* Done with AS request; fall through to TGS request. */\n    case IAKERB_TGS_REQ:\n        if (ctx->tcc == NULL) {\n            code = iakerb_tkt_creds_ctx(ctx, cred, name, time_req);\n            if (code != 0)\n                goto cleanup;\n        }\n\n        code = krb5_tkt_creds_step(ctx->k5c, ctx->tcc, &in, &out, &realm,\n                                   &flags);\n        if (code != 0)\n            goto cleanup;\n        if (!(flags & KRB5_TKT_CREDS_STEP_FLAG_CONTINUE)) {\n            krb5_tkt_creds_get_times(ctx->k5c, ctx->tcc, &times);\n            cred->expire = times.endtime;\n\n            krb5_tkt_creds_free(ctx->k5c, ctx->tcc);\n            ctx->tcc = NULL;\n\n            ctx->state = IAKERB_AP_REQ;\n        } else\n            break;\n        /* Done with TGS request; fall through to AP request. */\n    case IAKERB_AP_REQ:\n        break;\n    }\n\n    if (out.length != 0) {\n        assert(ctx->state != IAKERB_AP_REQ);\n\n        code = iakerb_make_token(ctx, &realm, cookie, &out,\n                                 (input_token == GSS_C_NO_BUFFER),\n                                 output_token);\n        if (code != 0)\n            goto cleanup;\n\n        /* Save the token for generating a future checksum */\n        code = iakerb_save_token(ctx, output_token);\n        if (code != 0)\n            goto cleanup;\n\n        ctx->count++;\n    }\n\ncleanup:\n    if (code != 0)\n        gss_release_buffer(&tmp, output_token);\n    krb5_free_data(ctx->k5c, cookie);\n    krb5_free_data_contents(ctx->k5c, &out);\n    krb5_free_data_contents(ctx->k5c, &realm);\n\n    return code;\n}\n\n/*\n * Determine the starting IAKERB state for a context. If we already\n * have a ticket, we may not need to do IAKERB at all.\n */\nstatic krb5_error_code\niakerb_get_initial_state(iakerb_ctx_id_t ctx,\n                         krb5_gss_cred_id_t cred,\n                         krb5_gss_name_t target,\n                         OM_uint32 time_req,\n                         enum iakerb_state *state)\n{\n    krb5_creds in_creds, *out_creds = NULL;\n    krb5_error_code code;\n\n    memset(&in_creds, 0, sizeof(in_creds));\n\n    in_creds.client = cred->name->princ;\n    in_creds.server = target->princ;\n\n    if (cred->name->ad_context != NULL) {\n        code = krb5_authdata_export_authdata(ctx->k5c,\n                                             cred->name->ad_context,\n                                             AD_USAGE_TGS_REQ,\n                                             &in_creds.authdata);\n        if (code != 0)\n            goto cleanup;\n    }\n\n    if (time_req != 0 && time_req != GSS_C_INDEFINITE) {\n        krb5_timestamp now;\n\n        code = krb5_timeofday(ctx->k5c, &now);\n        if (code != 0)\n            goto cleanup;\n\n        in_creds.times.endtime = now + time_req;\n    }\n\n    /* Make an AS request if we have no creds or it's time to refresh them. */\n    if (cred->expire == 0 || kg_cred_time_to_refresh(ctx->k5c, cred)) {\n        *state = IAKERB_AS_REQ;\n        code = 0;\n        goto cleanup;\n    }\n\n    code = krb5_get_credentials(ctx->k5c, KRB5_GC_CACHED, cred->ccache,\n                                &in_creds, &out_creds);\n    if (code == KRB5_CC_NOTFOUND || code == KRB5_CC_NOT_KTYPE) {\n        *state = cred->have_tgt ? IAKERB_TGS_REQ : IAKERB_AS_REQ;\n        code = 0;\n    } else if (code == 0) {\n        *state = IAKERB_AP_REQ;\n        krb5_free_creds(ctx->k5c, out_creds);\n    }\n\ncleanup:\n    krb5_free_authdata(ctx->k5c, in_creds.authdata);\n\n    return code;\n}\n\n/*\n * Allocate and initialise an IAKERB context\n */\nstatic krb5_error_code\niakerb_alloc_context(iakerb_ctx_id_t *pctx, int initiate)\n{\n    iakerb_ctx_id_t ctx;\n    krb5_error_code code;\n\n    *pctx = NULL;\n\n    ctx = k5alloc(sizeof(*ctx), &code);\n    if (ctx == NULL)\n        goto cleanup;\n    ctx->defcred = GSS_C_NO_CREDENTIAL;\n    ctx->magic = KG_IAKERB_CONTEXT;\n    ctx->state = IAKERB_AS_REQ;\n    ctx->count = 0;\n    ctx->initiate = initiate;\n    ctx->established = 0;\n\n    code = krb5_gss_init_context(&ctx->k5c);\n    if (code != 0)\n        goto cleanup;\n\n    *pctx = ctx;\n\ncleanup:\n    if (code != 0)\n        iakerb_release_context(ctx);\n\n    return code;\n}\n\n/*\n * Delete an IAKERB context. This can also accept Kerberos context\n * handles. The heuristic is similar to SPNEGO's delete_sec_context.\n */\nOM_uint32 KRB5_CALLCONV\niakerb_gss_delete_sec_context(OM_uint32 *minor_status,\n                              gss_ctx_id_t *context_handle,\n                              gss_buffer_t output_token)\n{\n    iakerb_ctx_id_t iakerb_ctx = (iakerb_ctx_id_t)*context_handle;\n\n    if (output_token != GSS_C_NO_BUFFER) {\n        output_token->length = 0;\n        output_token->value = NULL;\n    }\n\n    *minor_status = 0;\n    *context_handle = GSS_C_NO_CONTEXT;\n    iakerb_release_context(iakerb_ctx);\n\n    return GSS_S_COMPLETE;\n}\n\nstatic krb5_boolean\niakerb_is_iakerb_token(const gss_buffer_t token)\n{\n    krb5_error_code code;\n    unsigned int bodysize = token->length;\n    unsigned char *ptr = token->value;\n\n    code = g_verify_token_header(gss_mech_iakerb,\n                                 &bodysize, &ptr,\n                                 IAKERB_TOK_PROXY,\n                                 token->length, 0);\n\n    return (code == 0);\n}\n\nstatic void\niakerb_make_exts(iakerb_ctx_id_t ctx, krb5_gss_ctx_ext_rec *exts)\n{\n    memset(exts, 0, sizeof(*exts));\n\n    if (ctx->conv.length != 0)\n        exts->iakerb.conv = &ctx->conv;\n}\n\nOM_uint32 KRB5_CALLCONV\niakerb_gss_accept_sec_context(OM_uint32 *minor_status,\n                              gss_ctx_id_t *context_handle,\n                              gss_cred_id_t verifier_cred_handle,\n                              gss_buffer_t input_token,\n                              gss_channel_bindings_t input_chan_bindings,\n                              gss_name_t *src_name,\n                              gss_OID *mech_type,\n                              gss_buffer_t output_token,\n                              OM_uint32 *ret_flags,\n                              OM_uint32 *time_rec,\n                              gss_cred_id_t *delegated_cred_handle)\n{\n    OM_uint32 major_status = GSS_S_FAILURE;\n    OM_uint32 code;\n    iakerb_ctx_id_t ctx;\n    int initialContextToken = (*context_handle == GSS_C_NO_CONTEXT);\n\n    if (initialContextToken) {\n        code = iakerb_alloc_context(&ctx, 0);\n        if (code != 0)\n            goto cleanup;\n\n    } else\n        ctx = (iakerb_ctx_id_t)*context_handle;\n\n    if (iakerb_is_iakerb_token(input_token)) {\n        if (ctx->gssc != GSS_C_NO_CONTEXT) {\n            /* We shouldn't get an IAKERB token now. */\n            code = G_WRONG_TOKID;\n            major_status = GSS_S_DEFECTIVE_TOKEN;\n            goto cleanup;\n        }\n        code = iakerb_acceptor_step(ctx, initialContextToken,\n                                    input_token, output_token);\n        if (code == (OM_uint32)KRB5_BAD_MSIZE)\n            major_status = GSS_S_DEFECTIVE_TOKEN;\n        if (code != 0)\n            goto cleanup;\n        if (initialContextToken) {\n            *context_handle = (gss_ctx_id_t)ctx;\n            ctx = NULL;\n        }\n        if (src_name != NULL)\n            *src_name = GSS_C_NO_NAME;\n        if (mech_type != NULL)\n            *mech_type = (gss_OID)gss_mech_iakerb;\n        if (ret_flags != NULL)\n            *ret_flags = 0;\n        if (time_rec != NULL)\n            *time_rec = 0;\n        if (delegated_cred_handle != NULL)\n            *delegated_cred_handle = GSS_C_NO_CREDENTIAL;\n        major_status = GSS_S_CONTINUE_NEEDED;\n    } else {\n        krb5_gss_ctx_ext_rec exts;\n\n        iakerb_make_exts(ctx, &exts);\n\n        major_status = krb5_gss_accept_sec_context_ext(&code,\n                                                       &ctx->gssc,\n                                                       verifier_cred_handle,\n                                                       input_token,\n                                                       input_chan_bindings,\n                                                       src_name,\n                                                       NULL,\n                                                       output_token,\n                                                       ret_flags,\n                                                       time_rec,\n                                                       delegated_cred_handle,\n                                                       &exts);\n        if (major_status == GSS_S_COMPLETE)\n            ctx->established = 1;\n        if (mech_type != NULL)\n            *mech_type = (gss_OID)gss_mech_krb5;\n    }\n\ncleanup:\n    if (initialContextToken && GSS_ERROR(major_status)) {\n        iakerb_release_context(ctx);\n        *context_handle = GSS_C_NO_CONTEXT;\n    }\n\n    *minor_status = code;\n    return major_status;\n}\n\nOM_uint32 KRB5_CALLCONV\niakerb_gss_init_sec_context(OM_uint32 *minor_status,\n                            gss_cred_id_t claimant_cred_handle,\n                            gss_ctx_id_t *context_handle,\n                            gss_name_t target_name,\n                            gss_OID mech_type,\n                            OM_uint32 req_flags,\n                            OM_uint32 time_req,\n                            gss_channel_bindings_t input_chan_bindings,\n                            gss_buffer_t input_token,\n                            gss_OID *actual_mech_type,\n                            gss_buffer_t output_token,\n                            OM_uint32 *ret_flags,\n                            OM_uint32 *time_rec)\n{\n    OM_uint32 major_status = GSS_S_FAILURE;\n    krb5_error_code code;\n    iakerb_ctx_id_t ctx;\n    krb5_gss_cred_id_t kcred;\n    krb5_gss_name_t kname;\n    krb5_boolean cred_locked = FALSE;\n    int initialContextToken = (*context_handle == GSS_C_NO_CONTEXT);\n\n    if (initialContextToken) {\n        code = iakerb_alloc_context(&ctx, 1);\n        if (code != 0) {\n            *minor_status = code;\n            goto cleanup;\n        }\n        if (claimant_cred_handle == GSS_C_NO_CREDENTIAL) {\n            major_status = iakerb_gss_acquire_cred(minor_status, NULL,\n                                                   GSS_C_INDEFINITE,\n                                                   GSS_C_NULL_OID_SET,\n                                                   GSS_C_INITIATE,\n                                                   &ctx->defcred, NULL, NULL);\n            if (GSS_ERROR(major_status))\n                goto cleanup;\n            claimant_cred_handle = ctx->defcred;\n        }\n    } else {\n        ctx = (iakerb_ctx_id_t)*context_handle;\n        if (claimant_cred_handle == GSS_C_NO_CREDENTIAL)\n            claimant_cred_handle = ctx->defcred;\n    }\n\n    kname = (krb5_gss_name_t)target_name;\n\n    major_status = kg_cred_resolve(minor_status, ctx->k5c,\n                                   claimant_cred_handle, target_name);\n    if (GSS_ERROR(major_status))\n        goto cleanup;\n    cred_locked = TRUE;\n    kcred = (krb5_gss_cred_id_t)claimant_cred_handle;\n\n    major_status = GSS_S_FAILURE;\n\n    if (initialContextToken) {\n        code = iakerb_get_initial_state(ctx, kcred, kname, time_req,\n                                        &ctx->state);\n        if (code != 0) {\n            *minor_status = code;\n            goto cleanup;\n        }\n        *context_handle = (gss_ctx_id_t)ctx;\n    }\n\n    if (ctx->state != IAKERB_AP_REQ) {\n        /* We need to do IAKERB. */\n        code = iakerb_initiator_step(ctx,\n                                     kcred,\n                                     kname,\n                                     time_req,\n                                     input_token,\n                                     output_token);\n        if (code == KRB5_BAD_MSIZE)\n            major_status = GSS_S_DEFECTIVE_TOKEN;\n        if (code != 0) {\n            *minor_status = code;\n            goto cleanup;\n        }\n    }\n\n    if (ctx->state == IAKERB_AP_REQ) {\n        krb5_gss_ctx_ext_rec exts;\n\n        if (cred_locked) {\n            k5_mutex_unlock(&kcred->lock);\n            cred_locked = FALSE;\n        }\n\n        iakerb_make_exts(ctx, &exts);\n\n        if (ctx->gssc == GSS_C_NO_CONTEXT)\n            input_token = GSS_C_NO_BUFFER;\n\n        /* IAKERB is finished, or we skipped to Kerberos directly. */\n        major_status = krb5_gss_init_sec_context_ext(minor_status,\n                                                     (gss_cred_id_t) kcred,\n                                                     &ctx->gssc,\n                                                     target_name,\n                                                     (gss_OID)gss_mech_iakerb,\n                                                     req_flags,\n                                                     time_req,\n                                                     input_chan_bindings,\n                                                     input_token,\n                                                     NULL,\n                                                     output_token,\n                                                     ret_flags,\n                                                     time_rec,\n                                                     &exts);\n        if (major_status == GSS_S_COMPLETE)\n            ctx->established = 1;\n        if (actual_mech_type != NULL)\n            *actual_mech_type = (gss_OID)gss_mech_krb5;\n    } else {\n        if (actual_mech_type != NULL)\n            *actual_mech_type = (gss_OID)gss_mech_iakerb;\n        if (ret_flags != NULL)\n            *ret_flags = 0;\n        if (time_rec != NULL)\n            *time_rec = 0;\n        major_status = GSS_S_CONTINUE_NEEDED;\n    }\n\ncleanup:\n    if (cred_locked)\n        k5_mutex_unlock(&kcred->lock);\n    if (initialContextToken && GSS_ERROR(major_status)) {\n        iakerb_release_context(ctx);\n        *context_handle = GSS_C_NO_CONTEXT;\n    }\n\n    return major_status;\n}\n\nOM_uint32 KRB5_CALLCONV\niakerb_gss_unwrap(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n                  gss_buffer_t input_message_buffer,\n                  gss_buffer_t output_message_buffer, int *conf_state,\n                  gss_qop_t *qop_state)\n{\n    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;\n\n    if (ctx->gssc == GSS_C_NO_CONTEXT)\n        return GSS_S_NO_CONTEXT;\n\n    return krb5_gss_unwrap(minor_status, ctx->gssc, input_message_buffer,\n                           output_message_buffer, conf_state, qop_state);\n}\n\nOM_uint32 KRB5_CALLCONV\niakerb_gss_wrap(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n                int conf_req_flag, gss_qop_t qop_req,\n                gss_buffer_t input_message_buffer, int *conf_state,\n                gss_buffer_t output_message_buffer)\n{\n    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;\n\n    if (ctx->gssc == GSS_C_NO_CONTEXT)\n        return GSS_S_NO_CONTEXT;\n\n    return krb5_gss_wrap(minor_status, ctx->gssc, conf_req_flag, qop_req,\n                         input_message_buffer, conf_state,\n                         output_message_buffer);\n}\n\nOM_uint32 KRB5_CALLCONV\niakerb_gss_process_context_token(OM_uint32 *minor_status,\n                                 const gss_ctx_id_t context_handle,\n                                 const gss_buffer_t token_buffer)\n{\n    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;\n\n    if (ctx->gssc == GSS_C_NO_CONTEXT)\n        return GSS_S_DEFECTIVE_TOKEN;\n\n    return krb5_gss_process_context_token(minor_status, ctx->gssc,\n                                          token_buffer);\n}\n\nOM_uint32 KRB5_CALLCONV\niakerb_gss_context_time(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n                        OM_uint32 *time_rec)\n{\n    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;\n\n    if (ctx->gssc == GSS_C_NO_CONTEXT)\n        return GSS_S_NO_CONTEXT;\n\n    return krb5_gss_context_time(minor_status, ctx->gssc, time_rec);\n}\n\n#ifndef LEAN_CLIENT\n\nOM_uint32 KRB5_CALLCONV\niakerb_gss_export_sec_context(OM_uint32 *minor_status,\n                              gss_ctx_id_t *context_handle,\n                              gss_buffer_t interprocess_token)\n{\n    OM_uint32 maj;\n    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;\n\n    /* We don't currently support exporting partially established contexts. */\n    if (!ctx->established)\n        return GSS_S_UNAVAILABLE;\n\n    maj = krb5_gss_export_sec_context(minor_status, &ctx->gssc,\n                                      interprocess_token);\n    if (ctx->gssc == GSS_C_NO_CONTEXT) {\n        iakerb_release_context(ctx);\n        *context_handle = GSS_C_NO_CONTEXT;\n    }\n    return maj;\n}\n\n/*\n * Until we implement partial context exports, there are no SPNEGO exported\n * context tokens, only tokens for the underlying krb5 context.  So we do not\n * need to implement an iakerb_gss_import_sec_context() yet; it would be\n * unreachable except via a manually constructed token.\n */\n\n#endif /* LEAN_CLIENT */\n\nOM_uint32 KRB5_CALLCONV\niakerb_gss_inquire_context(OM_uint32 *minor_status,\n                           gss_ctx_id_t context_handle, gss_name_t *src_name,\n                           gss_name_t *targ_name, OM_uint32 *lifetime_rec,\n                           gss_OID *mech_type, OM_uint32 *ctx_flags,\n                           int *initiate, int *opened)\n{\n    OM_uint32 ret;\n    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;\n\n    if (src_name != NULL)\n        *src_name = GSS_C_NO_NAME;\n    if (targ_name != NULL)\n        *targ_name = GSS_C_NO_NAME;\n    if (lifetime_rec != NULL)\n        *lifetime_rec = 0;\n    if (mech_type != NULL)\n        *mech_type = (gss_OID)gss_mech_iakerb;\n    if (ctx_flags != NULL)\n        *ctx_flags = 0;\n    if (initiate != NULL)\n        *initiate = ctx->initiate;\n    if (opened != NULL)\n        *opened = ctx->established;\n\n    if (ctx->gssc == GSS_C_NO_CONTEXT)\n        return GSS_S_COMPLETE;\n\n    ret = krb5_gss_inquire_context(minor_status, ctx->gssc, src_name,\n                                   targ_name, lifetime_rec, mech_type,\n                                   ctx_flags, initiate, opened);\n\n    if (!ctx->established) {\n        /* Report IAKERB as the mech OID until the context is established. */\n        if (mech_type != NULL)\n            *mech_type = (gss_OID)gss_mech_iakerb;\n\n        /* We don't support exporting partially-established contexts. */\n        if (ctx_flags != NULL)\n            *ctx_flags &= ~GSS_C_TRANS_FLAG;\n    }\n\n    return ret;\n}\n\nOM_uint32 KRB5_CALLCONV\niakerb_gss_wrap_size_limit(OM_uint32 *minor_status,\n                           gss_ctx_id_t context_handle, int conf_req_flag,\n                           gss_qop_t qop_req, OM_uint32 req_output_size,\n                           OM_uint32 *max_input_size)\n{\n    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;\n\n    if (ctx->gssc == GSS_C_NO_CONTEXT)\n        return GSS_S_NO_CONTEXT;\n\n    return krb5_gss_wrap_size_limit(minor_status, ctx->gssc, conf_req_flag,\n                                    qop_req, req_output_size, max_input_size);\n}\n\nOM_uint32 KRB5_CALLCONV\niakerb_gss_get_mic(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n                   gss_qop_t qop_req, gss_buffer_t message_buffer,\n                   gss_buffer_t message_token)\n{\n    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;\n\n    if (ctx->gssc == GSS_C_NO_CONTEXT)\n        return GSS_S_NO_CONTEXT;\n\n    return krb5_gss_get_mic(minor_status, ctx->gssc, qop_req, message_buffer,\n                            message_token);\n}\n\nOM_uint32 KRB5_CALLCONV\niakerb_gss_verify_mic(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n                      gss_buffer_t msg_buffer, gss_buffer_t token_buffer,\n                      gss_qop_t *qop_state)\n{\n    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;\n\n    if (ctx->gssc == GSS_C_NO_CONTEXT)\n        return GSS_S_NO_CONTEXT;\n\n    return krb5_gss_verify_mic(minor_status, ctx->gssc, msg_buffer,\n                               token_buffer, qop_state);\n}\n\nOM_uint32 KRB5_CALLCONV\niakerb_gss_inquire_sec_context_by_oid(OM_uint32 *minor_status,\n                                      const gss_ctx_id_t context_handle,\n                                      const gss_OID desired_object,\n                                      gss_buffer_set_t *data_set)\n{\n    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;\n\n    if (ctx->gssc == GSS_C_NO_CONTEXT)\n        return GSS_S_UNAVAILABLE;\n\n    return krb5_gss_inquire_sec_context_by_oid(minor_status, ctx->gssc,\n                                               desired_object, data_set);\n}\n\nOM_uint32 KRB5_CALLCONV\niakerb_gss_set_sec_context_option(OM_uint32 *minor_status,\n                                  gss_ctx_id_t *context_handle,\n                                  const gss_OID desired_object,\n                                  const gss_buffer_t value)\n{\n    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)*context_handle;\n\n    if (ctx == NULL || ctx->gssc == GSS_C_NO_CONTEXT)\n        return GSS_S_UNAVAILABLE;\n\n    return krb5_gss_set_sec_context_option(minor_status, &ctx->gssc,\n                                           desired_object, value);\n}\n\nOM_uint32 KRB5_CALLCONV\niakerb_gss_wrap_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n                    int conf_req_flag, gss_qop_t qop_req, int *conf_state,\n                    gss_iov_buffer_desc *iov, int iov_count)\n{\n    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;\n\n    if (ctx->gssc == GSS_C_NO_CONTEXT)\n        return GSS_S_NO_CONTEXT;\n\n    return krb5_gss_wrap_iov(minor_status, ctx->gssc, conf_req_flag, qop_req,\n                             conf_state, iov, iov_count);\n}\n\nOM_uint32 KRB5_CALLCONV\niakerb_gss_unwrap_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n                      int *conf_state, gss_qop_t *qop_state,\n                      gss_iov_buffer_desc *iov, int iov_count)\n{\n    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;\n\n    if (ctx->gssc == GSS_C_NO_CONTEXT)\n        return GSS_S_NO_CONTEXT;\n\n    return krb5_gss_unwrap_iov(minor_status, ctx->gssc, conf_state, qop_state,\n                               iov, iov_count);\n}\n\nOM_uint32 KRB5_CALLCONV\niakerb_gss_wrap_iov_length(OM_uint32 *minor_status,\n                           gss_ctx_id_t context_handle, int conf_req_flag,\n                           gss_qop_t qop_req, int *conf_state,\n                           gss_iov_buffer_desc *iov, int iov_count)\n{\n    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;\n\n    if (ctx->gssc == GSS_C_NO_CONTEXT)\n        return GSS_S_NO_CONTEXT;\n\n    return krb5_gss_wrap_iov_length(minor_status, ctx->gssc, conf_req_flag,\n                                    qop_req, conf_state, iov, iov_count);\n}\n\nOM_uint32 KRB5_CALLCONV\niakerb_gss_pseudo_random(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n                         int prf_key, const gss_buffer_t prf_in,\n                         ssize_t desired_output_len, gss_buffer_t prf_out)\n{\n    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;\n\n    if (ctx->gssc == GSS_C_NO_CONTEXT)\n        return GSS_S_NO_CONTEXT;\n\n    return krb5_gss_pseudo_random(minor_status, ctx->gssc, prf_key, prf_in,\n                                  desired_output_len, prf_out);\n}\n\nOM_uint32 KRB5_CALLCONV\niakerb_gss_get_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n                       gss_qop_t qop_req, gss_iov_buffer_desc *iov,\n                       int iov_count)\n{\n    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;\n\n    if (ctx->gssc == GSS_C_NO_CONTEXT)\n        return GSS_S_NO_CONTEXT;\n\n    return krb5_gss_get_mic_iov(minor_status, ctx->gssc, qop_req, iov,\n                                iov_count);\n}\n\nOM_uint32 KRB5_CALLCONV\niakerb_gss_verify_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n                          gss_qop_t *qop_state, gss_iov_buffer_desc *iov,\n                          int iov_count)\n{\n    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;\n\n    if (ctx->gssc == GSS_C_NO_CONTEXT)\n        return GSS_S_NO_CONTEXT;\n\n    return krb5_gss_verify_mic_iov(minor_status, ctx->gssc, qop_state, iov,\n                                   iov_count);\n}\n\nOM_uint32 KRB5_CALLCONV\niakerb_gss_get_mic_iov_length(OM_uint32 *minor_status,\n                              gss_ctx_id_t context_handle, gss_qop_t qop_req,\n                              gss_iov_buffer_desc *iov, int iov_count)\n{\n    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;\n\n    if (ctx->gssc == GSS_C_NO_CONTEXT)\n        return GSS_S_NO_CONTEXT;\n\n    return krb5_gss_get_mic_iov_length(minor_status, ctx->gssc, qop_req, iov,\n                                       iov_count);\n}\n"], "filenames": ["src/lib/gssapi/krb5/gssapiP_krb5.h", "src/lib/gssapi/krb5/gssapi_krb5.c", "src/lib/gssapi/krb5/iakerb.c"], "buggy_code_start_loc": [623, 354, 49], "buggy_code_end_loc": [1304, 946, 1012], "fixing_code_start_loc": [624, 354, 50], "fixing_code_end_loc": [1419, 1028, 1304], "type": "CWE-18", "message": "lib/gssapi/krb5/iakerb.c in MIT Kerberos 5 (aka krb5) before 1.14 relies on an inappropriate context handle, which allows remote attackers to cause a denial of service (incorrect pointer read and process crash) via a crafted IAKERB packet that is mishandled during a gss_inquire_context call.", "other": {"cve": {"id": "CVE-2015-2696", "sourceIdentifier": "cve@mitre.org", "published": "2015-11-09T03:59:02.263", "lastModified": "2021-02-02T18:51:52.900", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "lib/gssapi/krb5/iakerb.c in MIT Kerberos 5 (aka krb5) before 1.14 relies on an inappropriate context handle, which allows remote attackers to cause a denial of service (incorrect pointer read and process crash) via a crafted IAKERB packet that is mishandled during a gss_inquire_context call."}, {"lang": "es", "value": "lib/gssapi/krb5/iakerb.c en MIT Kerberos 5 (tambi\u00e9n conocido como krb5) en versiones anteriores a 1.14 conf\u00eda en un manejo de contexto inapropiado, lo cual permite a atacantes remotos provocar una denegaci\u00f3n de servicio (lectura de puntero incorrecto y ca\u00edda de proceso) a trav\u00e9s de un paquete IAKERB manipulado que no es manejado correctamente durante una llamada a gss_inquire_context."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:C", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "COMPLETE", "baseScore": 7.1}, "baseSeverity": "HIGH", "exploitabilityScore": 8.6, "impactScore": 6.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-18"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.14", "matchCriteriaId": "0A215EB7-53BD-44AD-B546-DDF20B3797A6"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:leap:42.1:*:*:*:*:*:*:*", "matchCriteriaId": "4863BE36-D16A-4D75-90D9-FD76DB5B48B7"}, {"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:opensuse:13.1:*:*:*:*:*:*:*", "matchCriteriaId": "A10BC294-9196-425F-9FB0-B1625465B47F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:opensuse:13.2:*:*:*:*:*:*:*", "matchCriteriaId": "03117DF1-3BEC-4B8D-AD63-DBBDB2126081"}, {"vulnerable": true, "criteria": "cpe:2.3:o:suse:linux_enterprise_desktop:12:-:*:*:*:*:*:*", "matchCriteriaId": "D2DF4815-B8CB-4AD3-B91D-2E09A8E318E9"}, {"vulnerable": true, "criteria": "cpe:2.3:o:suse:linux_enterprise_server:12:-:*:*:*:*:*:*", "matchCriteriaId": "15FC9014-BD85-4382-9D04-C0703E901D7A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:suse:linux_enterprise_software_development_kit:12:-:*:*:*:*:*:*", "matchCriteriaId": "1831D45A-EE6E-4220-8F8C-248B69520948"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "16F59A04-14CF-49E2-9973-645477EA09DA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:12.04:*:*:*:-:*:*:*", "matchCriteriaId": "CB66DB75-2B16-4EBF-9B93-CE49D8086E41"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:14.04:*:*:*:esm:*:*:*", "matchCriteriaId": "815D70A8-47D3-459C-A32C-9FEACA0659D1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:15.04:*:*:*:*:*:*:*", "matchCriteriaId": "F38D3B7E-8429-473F-BB31-FC3583EE5A5B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:15.10:*:*:*:*:*:*:*", "matchCriteriaId": "E88A537F-F4D0-46B9-9E37-965233C2A355"}]}]}], "references": [{"url": "http://krbdev.mit.edu/rt/Ticket/Display.html?id=8244", "source": "cve@mitre.org", "tags": ["Vendor Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2015-11/msg00006.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2015-11/msg00014.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2015-11/msg00022.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://www.debian.org/security/2015/dsa-3395", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/90675", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "http://www.securitytracker.com/id/1034084", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "http://www.ubuntu.com/usn/USN-2810-1", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/krb5/krb5/commit/e04f0283516e80d2f93366e0d479d13c9b5c8c2a", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/201611-14", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/krb5/krb5/commit/e04f0283516e80d2f93366e0d479d13c9b5c8c2a"}}