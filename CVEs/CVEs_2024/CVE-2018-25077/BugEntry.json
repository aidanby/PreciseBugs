{"buggy_code": [".DS_Store\n.idea\n", ".DS_Store\n.idea\n.git*\n", "/**\n * mel-spintax\n *\n * Parse Spintax formatted text (Nested Spintax supported)\n *\n * @copyright 2015 Dmitry Gureev\n * @license MIT Licensed\n *\n * Examples:\n *     // Get unspinned text\n *     console.log(spintax.unspin('{Hello|Hi} John!'));\n *     // >>> \"Hello John!\" or \"Hi John!\"\n *\n *     // Get unspinned text from Nested Spintax\n *     console.log(spintax.unspin('{Hello|Hi {there|again}} John!'));\n *     // >>> \"Hello John!\" or \"Hi there John!\" or \"Hi again John!\"\n *\n *     // Count unique variations\n *     console.log(spintax.count('{Hello|Hi {there|again}} John!'));\n *     // >>> 3\n *\n *     // Validate format\n *     console.log(spintax.validate('{Hello|Hi} John!'));\n *     // >>> true\n *     console.log(spintax.validate('{Hello|Hi John!'));\n *     // >>> false\n */\n(function(exports) {\n\n\t/**\n\t * Check text is Spintax\n\t *\n\t * @param text {String} Spintax formatted string\n\t * @return {Boolean}\n\t */\n\texports.isSpintax = function(text) {\n\t\treturn text.match(/{.*(\\|.*)+}/) !== null;\n\t};\n\n\t/**\n\t * Find and return array of first Spintax occurence or null\n\t *\n\t * @param text {String} Spintax formatted string\n\t * @return {null|Array}\n\t */\n\texports.findSpintax = function(text) {\n\t\treturn text.match(/{([^{}]+?)}/);\n\t};\n\n\t/**\n\t * Unspin Spintax text\n\t *\n\t * @param text {String} Spintax formatted text\n\t * @return {String}\n\t */\n\texports.unspin = function(text) {\n\t\tvar spin;\n\t\tvar options;\n\t\tvar choice;\n\t\tvar originalText = text;\n\t\tvar unspinCount = 0;\n\n\t\t// While we find Spintax keep unspinning it\n\t\twhile (exports.isSpintax(text)) {\n\t\t\tif (unspinCount >= 1000) {\n\t\t\t\tthrow new Error('Unable unspin text after 1000 iterations (' + originalText + ')');\n\t\t\t}\n\n\t\t\t// Find first Spintax occurrence\n\t\t\tspin = exports.findSpintax(text);\n\n\t\t\t// Put the Spintax options in an array\n\t\t\toptions = spin[1].split('|');\n\n\t\t\t// Choose a random option based on the options length\n\t\t\tchoice = options[Math.floor(Math.random() * options.length)];\n\n\t\t\t// Put our unspun choice back into text\n\t\t\ttext = text.replace(spin[0], choice);\n\n\t\t\t// Increase unspin counter\n\t\t\tunspinCount++;\n\t\t}\n\n\t\treturn text;\n\t};\n\n\t/**\n\t * Count Spintax variations\n\t *\n\t * @param text {String} Spintax formatted text\n\t * @return {Number}\n\t */\n\texports.count = function(text) {\n\t\tvar spin;\n\t\tvar options;\n\t\tvar num;\n\t\tvar totals;\n\t\tvar total = 0;\n\t\tvar i;\n\t\tvar reFind = /%%%\\d+%%%/g;\n\t\tvar reParse = /%%%(\\d+)%%%/;\n\t\tvar ps = 'N';\n\t\tvar pm = '%%%' + ps + '%%%';\n\t\tvar originalText = text;\n\t\tvar unspinCount = 0;\n\n\t\twhile (exports.isSpintax(text)) {\n\t\t\tif (unspinCount >= 1000) {\n\t\t\t\tthrow new Error('Unable unspin text after 1000 iterations (' + originalText + ')');\n\t\t\t}\n\n\t\t\tspin = exports.findSpintax(text);\n\t\t\toptions = spin[1].split('|');\n\t\t\tnum = 0;\n\n\t\t\tfor (i = 0; i < options.length; i++) {\n\t\t\t\tif (options[i].match(reFind)) {\n\t\t\t\t\tnum += parseInt(options[i].match(reParse)[1]) || 1;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tnum += 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ttext = text.replace(spin[0], pm.replace(ps, num.toString()));\n\n\t\t\t// Increase unspin counter\n\t\t\tunspinCount++;\n\t\t}\n\n\t\tif (text.match(reFind)) {\n\t\t\ttotals = text.match(reFind);\n\t\t\ttotal = 1;\n\n\t\t\tfor (i = 0; i < totals.length; i++) {\n\t\t\t\ttotal *= parseInt(totals[i].match(reParse)[1]) || 1;\n\t\t\t}\n\t\t}\n\n\t\treturn total;\n\t};\n\n\t/**\n\t * Check given text for a valid Spintax-format\n\t *\n\t * @param text {String} Spintax formatted text\n\t * @return {Boolean}\n\t */\n\texports.validate = function(text) {\n\t\t// Unspin text\n\t\ttext = exports.unspin(text);\n\n\t\t// Check text for remaining Spintax format sequences: { then | or | then }\n\t\treturn text.match(/({[^}]*\\|)|(\\|[^{]*})/) === null;\n\t};\n\n})(typeof exports === 'undefined' ? this['spintax'] = {} : exports);\n", "{\n  \"name\": \"mel-spintax\",\n  \"version\": \"1.0.2\",\n  \"description\": \"Parse Spintax formatted text (Nested Spintax supported)\",\n  \"main\": \"index.js\",\n  \"directories\": {\n    \"lib\": \"lib\",\n    \"test\": \"test\"\n  },\n  \"scripts\": {\n    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/melnaron/mel-spintax.git\"\n  },\n  \"keywords\": [\n    \"spintax\",\n    \"spin\",\n    \"spun\",\n    \"text\",\n    \"spam\",\n    \"seo\",\n    \"substitute\",\n    \"substitution\"\n  ],\n  \"author\": \"Dmitry Gureev <melnaron@gmail.com>\",\n  \"license\": \"MIT\",\n  \"bugs\": {\n    \"url\": \"https://github.com/melnaron/mel-spintax/issues\"\n  },\n  \"homepage\": \"https://github.com/melnaron/mel-spintax\"\n}\n"], "fixing_code": [".DS_Store\n.idea\n.vscode\n", ".DS_Store\n.idea\n.vscode\n.git*\n", "/**\n * mel-spintax\n *\n * Parse Spintax formatted text (Nested Spintax supported)\n *\n * @copyright 2015 Dmitry Gureev\n * @license MIT Licensed\n *\n * Examples:\n *     // Get unspinned text\n *     console.log(spintax.unspin('{Hello|Hi} John!'));\n *     // >>> \"Hello John!\" or \"Hi John!\"\n *\n *     // Get unspinned text from Nested Spintax\n *     console.log(spintax.unspin('{Hello|Hi {there|again}} John!'));\n *     // >>> \"Hello John!\" or \"Hi there John!\" or \"Hi again John!\"\n *\n *     // Count unique variations\n *     console.log(spintax.count('{Hello|Hi {there|again}} John!'));\n *     // >>> 3\n *\n *     // Validate format\n *     console.log(spintax.validate('{Hello|Hi} John!'));\n *     // >>> true\n *     console.log(spintax.validate('{Hello|Hi John!'));\n *     // >>> false\n */\n(function(exports) {\n\n\t/**\n\t * Check text is Spintax\n\t *\n\t * @param text {String} Spintax formatted string\n\t * @return {Boolean}\n\t */\n\texports.isSpintax = function(text) {\n\t\treturn text.match(/\\{[^}]*\\|*[^}]*\\}/) !== null;\n\t};\n\n\t/**\n\t * Find and return array of first Spintax occurence or null\n\t *\n\t * @param text {String} Spintax formatted string\n\t * @return {null|Array}\n\t */\n\texports.findSpintax = function(text) {\n\t\treturn text.match(/\\{([^{}]+?)\\}/);\n\t};\n\n\t/**\n\t * Unspin Spintax text\n\t *\n\t * @param text {String} Spintax formatted text\n\t * @return {String}\n\t */\n\texports.unspin = function(text) {\n\t\tvar spin;\n\t\tvar options;\n\t\tvar choice;\n\t\tvar originalText = text;\n\t\tvar unspinCount = 0;\n\n\t\t// While we find Spintax keep unspinning it\n\t\twhile (exports.isSpintax(text)) {\n\t\t\tif (unspinCount >= 1000) {\n\t\t\t\tthrow new Error('Unable unspin text after 1000 iterations (' + originalText + ')');\n\t\t\t}\n\n\t\t\t// Find first Spintax occurrence\n\t\t\tspin = exports.findSpintax(text);\n\n\t\t\t// Put the Spintax options in an array\n\t\t\toptions = spin[1].split('|');\n\n\t\t\t// Choose a random option based on the options length\n\t\t\tchoice = options[Math.floor(Math.random() * options.length)];\n\n\t\t\t// Put our unspun choice back into text\n\t\t\ttext = text.replace(spin[0], choice);\n\n\t\t\t// Increase unspin counter\n\t\t\tunspinCount++;\n\t\t}\n\n\t\treturn text;\n\t};\n\n\t/**\n\t * Count Spintax variations\n\t *\n\t * @param text {String} Spintax formatted text\n\t * @return {Number}\n\t */\n\texports.count = function(text) {\n\t\tvar spin;\n\t\tvar options;\n\t\tvar num;\n\t\tvar totals;\n\t\tvar total = 0;\n\t\tvar i;\n\t\tvar reFind = /%%%\\d+%%%/g;\n\t\tvar reParse = /%%%(\\d+)%%%/;\n\t\tvar ps = 'N';\n\t\tvar pm = '%%%' + ps + '%%%';\n\t\tvar originalText = text;\n\t\tvar unspinCount = 0;\n\n\t\twhile (exports.isSpintax(text)) {\n\t\t\tif (unspinCount >= 1000) {\n\t\t\t\tthrow new Error('Unable unspin text after 1000 iterations (' + originalText + ')');\n\t\t\t}\n\n\t\t\tspin = exports.findSpintax(text);\n\t\t\toptions = spin[1].split('|');\n\t\t\tnum = 0;\n\n\t\t\tfor (i = 0; i < options.length; i++) {\n\t\t\t\tif (options[i].match(reFind)) {\n\t\t\t\t\tnum += parseInt(options[i].match(reParse)[1]) || 1;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tnum += 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ttext = text.replace(spin[0], pm.replace(ps, num.toString()));\n\n\t\t\t// Increase unspin counter\n\t\t\tunspinCount++;\n\t\t}\n\n\t\tif (text.match(reFind)) {\n\t\t\ttotals = text.match(reFind);\n\t\t\ttotal = 1;\n\n\t\t\tfor (i = 0; i < totals.length; i++) {\n\t\t\t\ttotal *= parseInt(totals[i].match(reParse)[1]) || 1;\n\t\t\t}\n\t\t}\n\n\t\treturn total;\n\t};\n\n\t/**\n\t * Check given text for a valid Spintax-format\n\t *\n\t * @param text {String} Spintax formatted text\n\t * @return {Boolean}\n\t */\n\texports.validate = function(text) {\n\t\t// Unspin text\n\t\ttext = exports.unspin(text);\n\n\t\t// Check text for remaining Spintax format sequences: { then | or | then }\n\t\treturn text.match(/(\\{[^}]*\\|)|(\\|[^{]*\\})/) === null;\n\t};\n\n})(typeof exports === 'undefined' ? this['spintax'] = {} : exports);\n", "{\n  \"name\": \"mel-spintax\",\n  \"version\": \"1.0.3\",\n  \"description\": \"Parse Spintax formatted text (Nested Spintax supported)\",\n  \"main\": \"index.js\",\n  \"directories\": {\n    \"lib\": \"lib\",\n    \"test\": \"test\"\n  },\n  \"scripts\": {\n    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/melnaron/mel-spintax.git\"\n  },\n  \"keywords\": [\n    \"spintax\",\n    \"spin\",\n    \"spun\",\n    \"text\",\n    \"spam\",\n    \"seo\",\n    \"substitute\",\n    \"substitution\"\n  ],\n  \"author\": \"Dmitry Gureev <melnaron@gmail.com>\",\n  \"license\": \"MIT\",\n  \"bugs\": {\n    \"url\": \"https://github.com/melnaron/mel-spintax/issues\"\n  },\n  \"homepage\": \"https://github.com/melnaron/mel-spintax\"\n}\n"], "filenames": [".gitignore", ".npmignore", "lib/spintax.js", "package.json"], "buggy_code_start_loc": [2, 2, 37, 3], "buggy_code_end_loc": [2, 2, 156, 4], "fixing_code_start_loc": [3, 3, 37, 3], "fixing_code_end_loc": [4, 4, 156, 4], "type": "CWE-1333", "message": "A vulnerability was found in melnaron mel-spintax. It has been rated as problematic. Affected by this issue is some unknown functionality of the file lib/spintax.js. The manipulation of the argument text leads to inefficient regular expression complexity. The name of the patch is 37767617846e27b87b63004e30216e8f919637d3. It is recommended to apply a patch to fix this issue. The identifier of this vulnerability is VDB-218456.", "other": {"cve": {"id": "CVE-2018-25077", "sourceIdentifier": "cna@vuldb.com", "published": "2023-01-18T01:15:11.653", "lastModified": "2023-01-25T17:46:28.577", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A vulnerability was found in melnaron mel-spintax. It has been rated as problematic. Affected by this issue is some unknown functionality of the file lib/spintax.js. The manipulation of the argument text leads to inefficient regular expression complexity. The name of the patch is 37767617846e27b87b63004e30216e8f919637d3. It is recommended to apply a patch to fix this issue. The identifier of this vulnerability is VDB-218456."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV30": [{"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:A/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:L", "attackVector": "ADJACENT_NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "LOW", "baseScore": 3.5, "baseSeverity": "LOW"}, "exploitabilityScore": 2.1, "impactScore": 1.4}], "cvssMetricV2": [{"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "2.0", "vectorString": "AV:A/AC:M/Au:S/C:N/I:N/A:P", "accessVector": "ADJACENT_NETWORK", "accessComplexity": "MEDIUM", "authentication": "SINGLE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 2.3}, "baseSeverity": "LOW", "exploitabilityScore": 4.4, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "cna@vuldb.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-1333"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:mel-spintax_project:mel-spintax:*:*:*:*:*:*:*:*", "versionEndExcluding": "2018-06-02", "matchCriteriaId": "9BE0FBE1-33C8-4CA8-8E58-3CF7A5DD33A4"}]}]}], "references": [{"url": "https://github.com/melnaron/mel-spintax/commit/37767617846e27b87b63004e30216e8f919637d3", "source": "cna@vuldb.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://vuldb.com/?ctiid.218456", "source": "cna@vuldb.com", "tags": ["Permissions Required", "Third Party Advisory"]}, {"url": "https://vuldb.com/?id.218456", "source": "cna@vuldb.com", "tags": ["Permissions Required", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/melnaron/mel-spintax/commit/37767617846e27b87b63004e30216e8f919637d3"}}