{"buggy_code": ["/**\n * collectd - src/network.c\n * Copyright (C) 2005-2013  Florian octo Forster\n * Copyright (C) 2009       Aman Gupta\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation; only version 2.1 of the License is\n * applicable.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with this program; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n *\n * Authors:\n *   Florian octo Forster <octo at collectd.org>\n *   Aman Gupta <aman at tmm1.net>\n **/\n\n#define _DEFAULT_SOURCE\n#define _BSD_SOURCE /* For struct ip_mreq */\n\n#include \"collectd.h\"\n#include \"plugin.h\"\n#include \"common.h\"\n#include \"configfile.h\"\n#include \"utils_fbhash.h\"\n#include \"utils_avltree.h\"\n#include \"utils_cache.h\"\n#include \"utils_complain.h\"\n\n#include \"network.h\"\n\n#if HAVE_PTHREAD_H\n# include <pthread.h>\n#endif\n#if HAVE_SYS_SOCKET_H\n# include <sys/socket.h>\n#endif\n#if HAVE_NETDB_H\n# include <netdb.h>\n#endif\n#if HAVE_NETINET_IN_H\n# include <netinet/in.h>\n#endif\n#if HAVE_ARPA_INET_H\n# include <arpa/inet.h>\n#endif\n#if HAVE_POLL_H\n# include <poll.h>\n#endif\n#if HAVE_NET_IF_H\n# include <net/if.h>\n#endif\n\n#if HAVE_LIBGCRYPT\n# include <pthread.h>\n# if defined __APPLE__\n/* default xcode compiler throws warnings even when deprecated functionality\n * is not used. -Werror breaks the build because of erroneous warnings.\n * http://stackoverflow.com/questions/10556299/compiler-warnings-with-libgcrypt-v1-5-0/12830209#12830209\n */\n#  pragma GCC diagnostic ignored \"-Wdeprecated-declarations\"\n# endif\n/* FreeBSD's copy of libgcrypt extends the existing GCRYPT_NO_DEPRECATED\n * to properly hide all deprecated functionality.\n * http://svnweb.freebsd.org/ports/head/security/libgcrypt/files/patch-src__gcrypt.h.in\n */\n# define GCRYPT_NO_DEPRECATED\n# include <gcrypt.h>\n# if defined __APPLE__\n/* Re enable deprecation warnings */\n#  pragma GCC diagnostic warning \"-Wdeprecated-declarations\"\n# endif\n# if GCRYPT_VERSION_NUMBER < 0x010600\nGCRY_THREAD_OPTION_PTHREAD_IMPL;\n# endif\n#endif\n\n#ifndef IPV6_ADD_MEMBERSHIP\n# ifdef IPV6_JOIN_GROUP\n#  define IPV6_ADD_MEMBERSHIP IPV6_JOIN_GROUP\n# else\n#  error \"Neither IP_ADD_MEMBERSHIP nor IPV6_JOIN_GROUP is defined\"\n# endif\n#endif /* !IP_ADD_MEMBERSHIP */\n\n/*\n * Maximum size required for encryption / signing:\n *\n *    42 bytes for the encryption header\n * +  64 bytes for the username\n * -----------\n * = 106 bytes\n */\n#define BUFF_SIG_SIZE 106\n\n/*\n * Private data types\n */\n#define SECURITY_LEVEL_NONE     0\n#if HAVE_LIBGCRYPT\n# define SECURITY_LEVEL_SIGN    1\n# define SECURITY_LEVEL_ENCRYPT 2\n#endif\nstruct sockent_client\n{\n\tint fd;\n\tstruct sockaddr_storage *addr;\n\tsocklen_t                addrlen;\n#if HAVE_LIBGCRYPT\n\tint security_level;\n\tchar *username;\n\tchar *password;\n\tgcry_cipher_hd_t cypher;\n\tunsigned char password_hash[32];\n#endif\n};\n\nstruct sockent_server\n{\n\tint *fd;\n\tsize_t fd_num;\n#if HAVE_LIBGCRYPT\n\tint security_level;\n\tchar *auth_file;\n\tfbhash_t *userdb;\n\tgcry_cipher_hd_t cypher;\n#endif\n};\n\ntypedef struct sockent\n{\n#define SOCKENT_TYPE_CLIENT 1\n#define SOCKENT_TYPE_SERVER 2\n\tint type;\n\n\tchar *node;\n\tchar *service;\n\tint interface;\n\n\tunion\n\t{\n\t\tstruct sockent_client client;\n\t\tstruct sockent_server server;\n\t} data;\n\n\tstruct sockent *next;\n} sockent_t;\n\n/*                      1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 3 3\n *  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n * +-------+-----------------------+-------------------------------+\n * ! Ver.  !                       ! Length                        !\n * +-------+-----------------------+-------------------------------+\n */\nstruct part_header_s\n{\n\tuint16_t type;\n\tuint16_t length;\n};\ntypedef struct part_header_s part_header_t;\n\n/*                      1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 3 3\n *  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n * +-------------------------------+-------------------------------+\n * ! Type                          ! Length                        !\n * +-------------------------------+-------------------------------+\n * : (Length - 4) Bytes                                            :\n * +---------------------------------------------------------------+\n */\nstruct part_string_s\n{\n\tpart_header_t *head;\n\tchar *value;\n};\ntypedef struct part_string_s part_string_t;\n\n/*                      1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 3 3\n *  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n * +-------------------------------+-------------------------------+\n * ! Type                          ! Length                        !\n * +-------------------------------+-------------------------------+\n * : (Length - 4 == 2 || 4 || 8) Bytes                             :\n * +---------------------------------------------------------------+\n */\nstruct part_number_s\n{\n\tpart_header_t *head;\n\tuint64_t *value;\n};\ntypedef struct part_number_s part_number_t;\n\n/*                      1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 3 3\n *  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n * +-------------------------------+-------------------------------+\n * ! Type                          ! Length                        !\n * +-------------------------------+---------------+---------------+\n * ! Num of values                 ! Type0         ! Type1         !\n * +-------------------------------+---------------+---------------+\n * ! Value0                                                        !\n * !                                                               !\n * +---------------------------------------------------------------+\n * ! Value1                                                        !\n * !                                                               !\n * +---------------------------------------------------------------+\n */\nstruct part_values_s\n{\n\tpart_header_t *head;\n\tuint16_t *num_values;\n\tuint8_t  *values_types;\n\tvalue_t  *values;\n};\ntypedef struct part_values_s part_values_t;\n\n/*                      1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 3 3\n *  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n * +-------------------------------+-------------------------------+\n * ! Type                          ! Length                        !\n * +-------------------------------+-------------------------------+\n * ! Hash (Bits   0 -  31)                                         !\n * : :                                                             :\n * ! Hash (Bits 224 - 255)                                         !\n * +---------------------------------------------------------------+\n */\n/* Minimum size */\n#define PART_SIGNATURE_SHA256_SIZE 36\nstruct part_signature_sha256_s\n{\n  part_header_t head;\n  unsigned char hash[32];\n  char *username;\n};\ntypedef struct part_signature_sha256_s part_signature_sha256_t;\n\n/*                      1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 3 3\n *  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n * +-------------------------------+-------------------------------+\n * ! Type                          ! Length                        !\n * +-------------------------------+-------------------------------+\n * ! Original length               ! Padding (0 - 15 bytes)        !\n * +-------------------------------+-------------------------------+\n * ! Hash (Bits   0 -  31)                                         !\n * : :                                                             :\n * ! Hash (Bits 128 - 159)                                         !\n * +---------------------------------------------------------------+\n */\n/* Minimum size */\n#define PART_ENCRYPTION_AES256_SIZE 42\nstruct part_encryption_aes256_s\n{\n  part_header_t head;\n  uint16_t username_length;\n  char *username;\n  unsigned char iv[16];\n  /* <encrypted> */\n  unsigned char hash[20];\n  /*   <payload /> */\n  /* </encrypted> */\n};\ntypedef struct part_encryption_aes256_s part_encryption_aes256_t;\n\nstruct receive_list_entry_s\n{\n  char *data;\n  int  data_len;\n  int  fd;\n  struct receive_list_entry_s *next;\n};\ntypedef struct receive_list_entry_s receive_list_entry_t;\n\n/*\n * Private variables\n */\nstatic int network_config_ttl = 0;\n/* Ethernet - (IPv6 + UDP) = 1500 - (40 + 8) = 1452 */\nstatic size_t network_config_packet_size = 1452;\nstatic int network_config_forward = 0;\nstatic int network_config_stats = 0;\n\nstatic sockent_t *sending_sockets = NULL;\n\nstatic receive_list_entry_t *receive_list_head = NULL;\nstatic receive_list_entry_t *receive_list_tail = NULL;\nstatic pthread_mutex_t       receive_list_lock = PTHREAD_MUTEX_INITIALIZER;\nstatic pthread_cond_t        receive_list_cond = PTHREAD_COND_INITIALIZER;\nstatic uint64_t              receive_list_length = 0;\n\nstatic sockent_t     *listen_sockets = NULL;\nstatic struct pollfd *listen_sockets_pollfd = NULL;\nstatic size_t         listen_sockets_num = 0;\n\n/* The receive and dispatch threads will run as long as `listen_loop' is set to\n * zero. */\nstatic int       listen_loop = 0;\nstatic int       receive_thread_running = 0;\nstatic pthread_t receive_thread_id;\nstatic int       dispatch_thread_running = 0;\nstatic pthread_t dispatch_thread_id;\n\n/* Buffer in which to-be-sent network packets are constructed. */\nstatic char            *send_buffer;\nstatic char            *send_buffer_ptr;\nstatic int              send_buffer_fill;\nstatic value_list_t     send_buffer_vl = VALUE_LIST_STATIC;\nstatic pthread_mutex_t  send_buffer_lock = PTHREAD_MUTEX_INITIALIZER;\n\n/* XXX: These counters are incremented from one place only. The spot in which\n * the values are incremented is either only reachable by one thread (the\n * dispatch thread, for example) or locked by some lock (send_buffer_lock for\n * example). Only if neither is true, the stats_lock is acquired. The counters\n * are always read without holding a lock in the hope that writing 8 bytes to\n * memory is an atomic operation. */\nstatic derive_t stats_octets_rx  = 0;\nstatic derive_t stats_octets_tx  = 0;\nstatic derive_t stats_packets_rx = 0;\nstatic derive_t stats_packets_tx = 0;\nstatic derive_t stats_values_dispatched = 0;\nstatic derive_t stats_values_not_dispatched = 0;\nstatic derive_t stats_values_sent = 0;\nstatic derive_t stats_values_not_sent = 0;\nstatic pthread_mutex_t stats_lock = PTHREAD_MUTEX_INITIALIZER;\n\n/*\n * Private functions\n */\nstatic _Bool check_receive_okay (const value_list_t *vl) /* {{{ */\n{\n  uint64_t time_sent = 0;\n  int status;\n\n  status = uc_meta_data_get_unsigned_int (vl,\n      \"network:time_sent\", &time_sent);\n\n  /* This is a value we already sent. Don't allow it to be received again in\n   * order to avoid looping. */\n  if ((status == 0) && (time_sent >= ((uint64_t) vl->time)))\n    return (0);\n\n  return (1);\n} /* }}} _Bool check_receive_okay */\n\nstatic _Bool check_send_okay (const value_list_t *vl) /* {{{ */\n{\n  _Bool received = 0;\n  int status;\n\n  if (network_config_forward != 0)\n    return (1);\n\n  if (vl->meta == NULL)\n    return (1);\n\n  status = meta_data_get_boolean (vl->meta, \"network:received\", &received);\n  if (status == -ENOENT)\n    return (1);\n  else if (status != 0)\n  {\n    ERROR (\"network plugin: check_send_okay: meta_data_get_boolean failed \"\n\t\"with status %i.\", status);\n    return (1);\n  }\n\n  /* By default, only *send* value lists that were not *received* by the\n   * network plugin. */\n  return (!received);\n} /* }}} _Bool check_send_okay */\n\nstatic _Bool check_notify_received (const notification_t *n) /* {{{ */\n{\n  notification_meta_t *ptr;\n\n  for (ptr = n->meta; ptr != NULL; ptr = ptr->next)\n    if ((strcmp (\"network:received\", ptr->name) == 0)\n        && (ptr->type == NM_TYPE_BOOLEAN))\n      return ((_Bool) ptr->nm_value.nm_boolean);\n\n  return (0);\n} /* }}} _Bool check_notify_received */\n\nstatic _Bool check_send_notify_okay (const notification_t *n) /* {{{ */\n{\n  static c_complain_t complain_forwarding = C_COMPLAIN_INIT_STATIC;\n  _Bool received = 0;\n\n  if (n->meta == NULL)\n    return (1);\n\n  received = check_notify_received (n);\n\n  if (network_config_forward && received)\n  {\n    c_complain_once (LOG_ERR, &complain_forwarding,\n        \"network plugin: A notification has been received via the network \"\n        \"and forwarding is enabled. Forwarding of notifications is currently \"\n        \"not supported, because there is not loop-deteciton available. \"\n        \"Please contact the collectd mailing list if you need this \"\n        \"feature.\");\n  }\n\n  /* By default, only *send* value lists that were not *received* by the\n   * network plugin. */\n  return (!received);\n} /* }}} _Bool check_send_notify_okay */\n\nstatic int network_dispatch_values (value_list_t *vl, /* {{{ */\n    const char *username)\n{\n  int status;\n\n  if ((vl->time <= 0)\n      || (strlen (vl->host) <= 0)\n      || (strlen (vl->plugin) <= 0)\n      || (strlen (vl->type) <= 0))\n    return (-EINVAL);\n\n  if (!check_receive_okay (vl))\n  {\n#if COLLECT_DEBUG\n    char name[6*DATA_MAX_NAME_LEN];\n    FORMAT_VL (name, sizeof (name), vl);\n    name[sizeof (name) - 1] = 0;\n    DEBUG (\"network plugin: network_dispatch_values: \"\n\t\"NOT dispatching %s.\", name);\n#endif\n    stats_values_not_dispatched++;\n    return (0);\n  }\n\n  assert (vl->meta == NULL);\n\n  vl->meta = meta_data_create ();\n  if (vl->meta == NULL)\n  {\n    ERROR (\"network plugin: meta_data_create failed.\");\n    return (-ENOMEM);\n  }\n\n  status = meta_data_add_boolean (vl->meta, \"network:received\", 1);\n  if (status != 0)\n  {\n    ERROR (\"network plugin: meta_data_add_boolean failed.\");\n    meta_data_destroy (vl->meta);\n    vl->meta = NULL;\n    return (status);\n  }\n\n  if (username != NULL)\n  {\n    status = meta_data_add_string (vl->meta, \"network:username\", username);\n    if (status != 0)\n    {\n      ERROR (\"network plugin: meta_data_add_string failed.\");\n      meta_data_destroy (vl->meta);\n      vl->meta = NULL;\n      return (status);\n    }\n  }\n\n  plugin_dispatch_values (vl);\n  stats_values_dispatched++;\n\n  meta_data_destroy (vl->meta);\n  vl->meta = NULL;\n\n  return (0);\n} /* }}} int network_dispatch_values */\n\nstatic int network_dispatch_notification (notification_t *n) /* {{{ */\n{\n  int status;\n\n  assert (n->meta == NULL);\n\n  status = plugin_notification_meta_add_boolean (n, \"network:received\", 1);\n  if (status != 0)\n  {\n    ERROR (\"network plugin: plugin_notification_meta_add_boolean failed.\");\n    plugin_notification_meta_free (n->meta);\n    n->meta = NULL;\n    return (status);\n  }\n\n  status = plugin_dispatch_notification (n);\n\n  plugin_notification_meta_free (n->meta);\n  n->meta = NULL;\n\n  return (status);\n} /* }}} int network_dispatch_notification */\n\n#if HAVE_LIBGCRYPT\nstatic void network_init_gcrypt (void) /* {{{ */\n{\n  /* http://lists.gnupg.org/pipermail/gcrypt-devel/2003-August/000458.html\n   * Because you can't know in a library whether another library has\n   * already initialized the library */\n  if (gcry_control (GCRYCTL_ANY_INITIALIZATION_P))\n    return;\n\n /* http://www.gnupg.org/documentation/manuals/gcrypt/Multi_002dThreading.html\n  * To ensure thread-safety, it's important to set GCRYCTL_SET_THREAD_CBS\n  * *before* initalizing Libgcrypt with gcry_check_version(), which itself must\n  * be called before any other gcry_* function. GCRYCTL_ANY_INITIALIZATION_P\n  * above doesn't count, as it doesn't implicitly initalize Libgcrypt.\n  *\n  * tl;dr: keep all these gry_* statements in this exact order please. */\n# if GCRYPT_VERSION_NUMBER < 0x010600\n  gcry_control (GCRYCTL_SET_THREAD_CBS, &gcry_threads_pthread);\n# endif\n  gcry_check_version (NULL);\n  gcry_control (GCRYCTL_INIT_SECMEM, 32768);\n  gcry_control (GCRYCTL_INITIALIZATION_FINISHED);\n} /* }}} void network_init_gcrypt */\n\nstatic gcry_cipher_hd_t network_get_aes256_cypher (sockent_t *se, /* {{{ */\n    const void *iv, size_t iv_size, const char *username)\n{\n  gcry_error_t err;\n  gcry_cipher_hd_t *cyper_ptr;\n  unsigned char password_hash[32];\n\n  if (se->type == SOCKENT_TYPE_CLIENT)\n  {\n\t  cyper_ptr = &se->data.client.cypher;\n\t  memcpy (password_hash, se->data.client.password_hash,\n\t\t\t  sizeof (password_hash));\n  }\n  else\n  {\n\t  char *secret;\n\n\t  cyper_ptr = &se->data.server.cypher;\n\n\t  if (username == NULL)\n\t\t  return (NULL);\n\n\t  secret = fbh_get (se->data.server.userdb, username);\n\t  if (secret == NULL)\n\t\t  return (NULL);\n\n\t  gcry_md_hash_buffer (GCRY_MD_SHA256,\n\t\t\t  password_hash,\n\t\t\t  secret, strlen (secret));\n\n\t  sfree (secret);\n  }\n\n  if (*cyper_ptr == NULL)\n  {\n    err = gcry_cipher_open (cyper_ptr,\n        GCRY_CIPHER_AES256, GCRY_CIPHER_MODE_OFB, /* flags = */ 0);\n    if (err != 0)\n    {\n      ERROR (\"network plugin: gcry_cipher_open returned: %s\",\n          gcry_strerror (err));\n      *cyper_ptr = NULL;\n      return (NULL);\n    }\n  }\n  else\n  {\n    gcry_cipher_reset (*cyper_ptr);\n  }\n  assert (*cyper_ptr != NULL);\n\n  err = gcry_cipher_setkey (*cyper_ptr,\n      password_hash, sizeof (password_hash));\n  if (err != 0)\n  {\n    ERROR (\"network plugin: gcry_cipher_setkey returned: %s\",\n        gcry_strerror (err));\n    gcry_cipher_close (*cyper_ptr);\n    *cyper_ptr = NULL;\n    return (NULL);\n  }\n\n  err = gcry_cipher_setiv (*cyper_ptr, iv, iv_size);\n  if (err != 0)\n  {\n    ERROR (\"network plugin: gcry_cipher_setkey returned: %s\",\n        gcry_strerror (err));\n    gcry_cipher_close (*cyper_ptr);\n    *cyper_ptr = NULL;\n    return (NULL);\n  }\n\n  return (*cyper_ptr);\n} /* }}} int network_get_aes256_cypher */\n#endif /* HAVE_LIBGCRYPT */\n\nstatic int write_part_values (char **ret_buffer, int *ret_buffer_len,\n\t\tconst data_set_t *ds, const value_list_t *vl)\n{\n\tchar *packet_ptr;\n\tint packet_len;\n\tint num_values;\n\n\tpart_header_t pkg_ph;\n\tuint16_t      pkg_num_values;\n\tuint8_t      *pkg_values_types;\n\tvalue_t      *pkg_values;\n\n\tint offset;\n\tint i;\n\n\tnum_values = vl->values_len;\n\tpacket_len = sizeof (part_header_t) + sizeof (uint16_t)\n\t\t+ (num_values * sizeof (uint8_t))\n\t\t+ (num_values * sizeof (value_t));\n\n\tif (*ret_buffer_len < packet_len)\n\t\treturn (-1);\n\n\tpkg_values_types = (uint8_t *) malloc (num_values * sizeof (uint8_t));\n\tif (pkg_values_types == NULL)\n\t{\n\t\tERROR (\"network plugin: write_part_values: malloc failed.\");\n\t\treturn (-1);\n\t}\n\n\tpkg_values = (value_t *) malloc (num_values * sizeof (value_t));\n\tif (pkg_values == NULL)\n\t{\n\t\tfree (pkg_values_types);\n\t\tERROR (\"network plugin: write_part_values: malloc failed.\");\n\t\treturn (-1);\n\t}\n\n\tpkg_ph.type = htons (TYPE_VALUES);\n\tpkg_ph.length = htons (packet_len);\n\n\tpkg_num_values = htons ((uint16_t) vl->values_len);\n\n\tfor (i = 0; i < num_values; i++)\n\t{\n\t\tpkg_values_types[i] = (uint8_t) ds->ds[i].type;\n\t\tswitch (ds->ds[i].type)\n\t\t{\n\t\t\tcase DS_TYPE_COUNTER:\n\t\t\t\tpkg_values[i].counter = htonll (vl->values[i].counter);\n\t\t\t\tbreak;\n\n\t\t\tcase DS_TYPE_GAUGE:\n\t\t\t\tpkg_values[i].gauge = htond (vl->values[i].gauge);\n\t\t\t\tbreak;\n\n\t\t\tcase DS_TYPE_DERIVE:\n\t\t\t\tpkg_values[i].derive = htonll (vl->values[i].derive);\n\t\t\t\tbreak;\n\n\t\t\tcase DS_TYPE_ABSOLUTE:\n\t\t\t\tpkg_values[i].absolute = htonll (vl->values[i].absolute);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tfree (pkg_values_types);\n\t\t\t\tfree (pkg_values);\n\t\t\t\tERROR (\"network plugin: write_part_values: \"\n\t\t\t\t\t\t\"Unknown data source type: %i\",\n\t\t\t\t\t\tds->ds[i].type);\n\t\t\t\treturn (-1);\n\t\t} /* switch (ds->ds[i].type) */\n\t} /* for (num_values) */\n\n\t/*\n\t * Use `memcpy' to write everything to the buffer, because the pointer\n\t * may be unaligned and some architectures, such as SPARC, can't handle\n\t * that.\n\t */\n\tpacket_ptr = *ret_buffer;\n\toffset = 0;\n\tmemcpy (packet_ptr + offset, &pkg_ph, sizeof (pkg_ph));\n\toffset += sizeof (pkg_ph);\n\tmemcpy (packet_ptr + offset, &pkg_num_values, sizeof (pkg_num_values));\n\toffset += sizeof (pkg_num_values);\n\tmemcpy (packet_ptr + offset, pkg_values_types, num_values * sizeof (uint8_t));\n\toffset += num_values * sizeof (uint8_t);\n\tmemcpy (packet_ptr + offset, pkg_values, num_values * sizeof (value_t));\n\toffset += num_values * sizeof (value_t);\n\n\tassert (offset == packet_len);\n\n\t*ret_buffer = packet_ptr + packet_len;\n\t*ret_buffer_len -= packet_len;\n\n\tfree (pkg_values_types);\n\tfree (pkg_values);\n\n\treturn (0);\n} /* int write_part_values */\n\nstatic int write_part_number (char **ret_buffer, int *ret_buffer_len,\n\t\tint type, uint64_t value)\n{\n\tchar *packet_ptr;\n\tint packet_len;\n\n\tpart_header_t pkg_head;\n\tuint64_t pkg_value;\n\n\tint offset;\n\n\tpacket_len = sizeof (pkg_head) + sizeof (pkg_value);\n\n\tif (*ret_buffer_len < packet_len)\n\t\treturn (-1);\n\n\tpkg_head.type = htons (type);\n\tpkg_head.length = htons (packet_len);\n\tpkg_value = htonll (value);\n\n\tpacket_ptr = *ret_buffer;\n\toffset = 0;\n\tmemcpy (packet_ptr + offset, &pkg_head, sizeof (pkg_head));\n\toffset += sizeof (pkg_head);\n\tmemcpy (packet_ptr + offset, &pkg_value, sizeof (pkg_value));\n\toffset += sizeof (pkg_value);\n\n\tassert (offset == packet_len);\n\n\t*ret_buffer = packet_ptr + packet_len;\n\t*ret_buffer_len -= packet_len;\n\n\treturn (0);\n} /* int write_part_number */\n\nstatic int write_part_string (char **ret_buffer, int *ret_buffer_len,\n\t\tint type, const char *str, int str_len)\n{\n\tchar *buffer;\n\tint buffer_len;\n\n\tuint16_t pkg_type;\n\tuint16_t pkg_length;\n\n\tint offset;\n\n\tbuffer_len = 2 * sizeof (uint16_t) + str_len + 1;\n\tif (*ret_buffer_len < buffer_len)\n\t\treturn (-1);\n\n\tpkg_type = htons (type);\n\tpkg_length = htons (buffer_len);\n\n\tbuffer = *ret_buffer;\n\toffset = 0;\n\tmemcpy (buffer + offset, (void *) &pkg_type, sizeof (pkg_type));\n\toffset += sizeof (pkg_type);\n\tmemcpy (buffer + offset, (void *) &pkg_length, sizeof (pkg_length));\n\toffset += sizeof (pkg_length);\n\tmemcpy (buffer + offset, str, str_len);\n\toffset += str_len;\n\tmemset (buffer + offset, '\\0', 1);\n\toffset += 1;\n\n\tassert (offset == buffer_len);\n\n\t*ret_buffer = buffer + buffer_len;\n\t*ret_buffer_len -= buffer_len;\n\n\treturn (0);\n} /* int write_part_string */\n\nstatic int parse_part_values (void **ret_buffer, size_t *ret_buffer_len,\n\t\tvalue_t **ret_values, int *ret_num_values)\n{\n\tchar *buffer = *ret_buffer;\n\tsize_t buffer_len = *ret_buffer_len;\n\n\tuint16_t tmp16;\n\tsize_t exp_size;\n\tint   i;\n\n\tuint16_t pkg_length;\n\tuint16_t pkg_type;\n\tuint16_t pkg_numval;\n\n\tuint8_t *pkg_types;\n\tvalue_t *pkg_values;\n\n\tif (buffer_len < 15)\n\t{\n\t\tNOTICE (\"network plugin: packet is too short: \"\n\t\t\t\t\"buffer_len = %zu\", buffer_len);\n\t\treturn (-1);\n\t}\n\n\tmemcpy ((void *) &tmp16, buffer, sizeof (tmp16));\n\tbuffer += sizeof (tmp16);\n\tpkg_type = ntohs (tmp16);\n\n\tmemcpy ((void *) &tmp16, buffer, sizeof (tmp16));\n\tbuffer += sizeof (tmp16);\n\tpkg_length = ntohs (tmp16);\n\n\tmemcpy ((void *) &tmp16, buffer, sizeof (tmp16));\n\tbuffer += sizeof (tmp16);\n\tpkg_numval = ntohs (tmp16);\n\n\tassert (pkg_type == TYPE_VALUES);\n\n\texp_size = 3 * sizeof (uint16_t)\n\t\t+ pkg_numval * (sizeof (uint8_t) + sizeof (value_t));\n\tif (buffer_len < exp_size)\n\t{\n\t\tWARNING (\"network plugin: parse_part_values: \"\n\t\t\t\t\"Packet too short: \"\n\t\t\t\t\"Chunk of size %zu expected, \"\n\t\t\t\t\"but buffer has only %zu bytes left.\",\n\t\t\t\texp_size, buffer_len);\n\t\treturn (-1);\n\t}\n\n\tif (pkg_length != exp_size)\n\t{\n\t\tWARNING (\"network plugin: parse_part_values: \"\n\t\t\t\t\"Length and number of values \"\n\t\t\t\t\"in the packet don't match.\");\n\t\treturn (-1);\n\t}\n\n\tpkg_types = (uint8_t *) malloc (pkg_numval * sizeof (uint8_t));\n\tpkg_values = (value_t *) malloc (pkg_numval * sizeof (value_t));\n\tif ((pkg_types == NULL) || (pkg_values == NULL))\n\t{\n\t\tsfree (pkg_types);\n\t\tsfree (pkg_values);\n\t\tERROR (\"network plugin: parse_part_values: malloc failed.\");\n\t\treturn (-1);\n\t}\n\n\tmemcpy ((void *) pkg_types, (void *) buffer, pkg_numval * sizeof (uint8_t));\n\tbuffer += pkg_numval * sizeof (uint8_t);\n\tmemcpy ((void *) pkg_values, (void *) buffer, pkg_numval * sizeof (value_t));\n\tbuffer += pkg_numval * sizeof (value_t);\n\n\tfor (i = 0; i < pkg_numval; i++)\n\t{\n\t\tswitch (pkg_types[i])\n\t\t{\n\t\t  case DS_TYPE_COUNTER:\n\t\t    pkg_values[i].counter = (counter_t) ntohll (pkg_values[i].counter);\n\t\t    break;\n\n\t\t  case DS_TYPE_GAUGE:\n\t\t    pkg_values[i].gauge = (gauge_t) ntohd (pkg_values[i].gauge);\n\t\t    break;\n\n\t\t  case DS_TYPE_DERIVE:\n\t\t    pkg_values[i].derive = (derive_t) ntohll (pkg_values[i].derive);\n\t\t    break;\n\n\t\t  case DS_TYPE_ABSOLUTE:\n\t\t    pkg_values[i].absolute = (absolute_t) ntohll (pkg_values[i].absolute);\n\t\t    break;\n\n\t\t  default:\n\t\t    NOTICE (\"network plugin: parse_part_values: \"\n\t\t\t\"Don't know how to handle data source type %\"PRIu8,\n\t\t\tpkg_types[i]);\n\t\t    sfree (pkg_types);\n\t\t    sfree (pkg_values);\n\t\t    return (-1);\n\t\t} /* switch (pkg_types[i]) */\n\t}\n\n\t*ret_buffer     = buffer;\n\t*ret_buffer_len = buffer_len - pkg_length;\n\t*ret_num_values = pkg_numval;\n\t*ret_values     = pkg_values;\n\n\tsfree (pkg_types);\n\n\treturn (0);\n} /* int parse_part_values */\n\nstatic int parse_part_number (void **ret_buffer, size_t *ret_buffer_len,\n\t\tuint64_t *value)\n{\n\tchar *buffer = *ret_buffer;\n\tsize_t buffer_len = *ret_buffer_len;\n\n\tuint16_t tmp16;\n\tuint64_t tmp64;\n\tsize_t exp_size = 2 * sizeof (uint16_t) + sizeof (uint64_t);\n\n\tuint16_t pkg_length;\n\n\tif (buffer_len < exp_size)\n\t{\n\t\tWARNING (\"network plugin: parse_part_number: \"\n\t\t\t\t\"Packet too short: \"\n\t\t\t\t\"Chunk of size %zu expected, \"\n\t\t\t\t\"but buffer has only %zu bytes left.\",\n\t\t\t\texp_size, buffer_len);\n\t\treturn (-1);\n\t}\n\n\tmemcpy ((void *) &tmp16, buffer, sizeof (tmp16));\n\tbuffer += sizeof (tmp16);\n\t/* pkg_type = ntohs (tmp16); */\n\n\tmemcpy ((void *) &tmp16, buffer, sizeof (tmp16));\n\tbuffer += sizeof (tmp16);\n\tpkg_length = ntohs (tmp16);\n\n\tmemcpy ((void *) &tmp64, buffer, sizeof (tmp64));\n\tbuffer += sizeof (tmp64);\n\t*value = ntohll (tmp64);\n\n\t*ret_buffer = buffer;\n\t*ret_buffer_len = buffer_len - pkg_length;\n\n\treturn (0);\n} /* int parse_part_number */\n\nstatic int parse_part_string (void **ret_buffer, size_t *ret_buffer_len,\n\t\tchar *output, int output_len)\n{\n\tchar *buffer = *ret_buffer;\n\tsize_t buffer_len = *ret_buffer_len;\n\n\tuint16_t tmp16;\n\tsize_t header_size = 2 * sizeof (uint16_t);\n\n\tuint16_t pkg_length;\n\n\tif (buffer_len < header_size)\n\t{\n\t\tWARNING (\"network plugin: parse_part_string: \"\n\t\t\t\t\"Packet too short: \"\n\t\t\t\t\"Chunk of at least size %zu expected, \"\n\t\t\t\t\"but buffer has only %zu bytes left.\",\n\t\t\t\theader_size, buffer_len);\n\t\treturn (-1);\n\t}\n\n\tmemcpy ((void *) &tmp16, buffer, sizeof (tmp16));\n\tbuffer += sizeof (tmp16);\n\t/* pkg_type = ntohs (tmp16); */\n\n\tmemcpy ((void *) &tmp16, buffer, sizeof (tmp16));\n\tbuffer += sizeof (tmp16);\n\tpkg_length = ntohs (tmp16);\n\n\t/* Check that packet fits in the input buffer */\n\tif (pkg_length > buffer_len)\n\t{\n\t\tWARNING (\"network plugin: parse_part_string: \"\n\t\t\t\t\"Packet too big: \"\n\t\t\t\t\"Chunk of size %\"PRIu16\" received, \"\n\t\t\t\t\"but buffer has only %zu bytes left.\",\n\t\t\t\tpkg_length, buffer_len);\n\t\treturn (-1);\n\t}\n\n\t/* Check that pkg_length is in the valid range */\n\tif (pkg_length <= header_size)\n\t{\n\t\tWARNING (\"network plugin: parse_part_string: \"\n\t\t\t\t\"Packet too short: \"\n\t\t\t\t\"Header claims this packet is only %hu \"\n\t\t\t\t\"bytes long.\", pkg_length);\n\t\treturn (-1);\n\t}\n\n\t/* Check that the package data fits into the output buffer.\n\t * The previous if-statement ensures that:\n\t * `pkg_length > header_size' */\n\tif ((output_len < 0)\n\t\t\t|| ((size_t) output_len < ((size_t) pkg_length - header_size)))\n\t{\n\t\tWARNING (\"network plugin: parse_part_string: \"\n\t\t\t\t\"Output buffer too small.\");\n\t\treturn (-1);\n\t}\n\n\t/* All sanity checks successfull, let's copy the data over */\n\toutput_len = pkg_length - header_size;\n\tmemcpy ((void *) output, (void *) buffer, output_len);\n\tbuffer += output_len;\n\n\t/* For some very weird reason '\\0' doesn't do the trick on SPARC in\n\t * this statement. */\n\tif (output[output_len - 1] != 0)\n\t{\n\t\tWARNING (\"network plugin: parse_part_string: \"\n\t\t\t\t\"Received string does not end \"\n\t\t\t\t\"with a NULL-byte.\");\n\t\treturn (-1);\n\t}\n\n\t*ret_buffer = buffer;\n\t*ret_buffer_len = buffer_len - pkg_length;\n\n\treturn (0);\n} /* int parse_part_string */\n\n/* Forward declaration: parse_part_sign_sha256 and parse_part_encr_aes256 call\n * parse_packet and vice versa. */\n#define PP_SIGNED    0x01\n#define PP_ENCRYPTED 0x02\nstatic int parse_packet (sockent_t *se,\n\t\tvoid *buffer, size_t buffer_size, int flags,\n\t\tconst char *username);\n\n#define BUFFER_READ(p,s) do { \\\n  memcpy ((p), buffer + buffer_offset, (s)); \\\n  buffer_offset += (s); \\\n} while (0)\n\n#if HAVE_LIBGCRYPT\nstatic int parse_part_sign_sha256 (sockent_t *se, /* {{{ */\n    void **ret_buffer, size_t *ret_buffer_len, int flags)\n{\n  static c_complain_t complain_no_users = C_COMPLAIN_INIT_STATIC;\n\n  char *buffer;\n  size_t buffer_len;\n  size_t buffer_offset;\n\n  size_t username_len;\n  char *secret;\n\n  part_signature_sha256_t pss;\n  uint16_t pss_head_length;\n  char hash[sizeof (pss.hash)];\n\n  gcry_md_hd_t hd;\n  gcry_error_t err;\n  unsigned char *hash_ptr;\n\n  buffer = *ret_buffer;\n  buffer_len = *ret_buffer_len;\n  buffer_offset = 0;\n\n  if (se->data.server.userdb == NULL)\n  {\n    c_complain (LOG_NOTICE, &complain_no_users,\n        \"network plugin: Received signed network packet but can't verify it \"\n        \"because no user DB has been configured. Will accept it.\");\n    return (0);\n  }\n\n  /* Check if the buffer has enough data for this structure. */\n  if (buffer_len <= PART_SIGNATURE_SHA256_SIZE)\n    return (-ENOMEM);\n\n  /* Read type and length header */\n  BUFFER_READ (&pss.head.type, sizeof (pss.head.type));\n  BUFFER_READ (&pss.head.length, sizeof (pss.head.length));\n  pss_head_length = ntohs (pss.head.length);\n\n  /* Check if the `pss_head_length' is within bounds. */\n  if ((pss_head_length <= PART_SIGNATURE_SHA256_SIZE)\n      || (pss_head_length > buffer_len))\n  {\n    ERROR (\"network plugin: HMAC-SHA-256 with invalid length received.\");\n    return (-1);\n  }\n\n  /* Copy the hash. */\n  BUFFER_READ (pss.hash, sizeof (pss.hash));\n\n  /* Calculate username length (without null byte) and allocate memory */\n  username_len = pss_head_length - PART_SIGNATURE_SHA256_SIZE;\n  pss.username = malloc (username_len + 1);\n  if (pss.username == NULL)\n    return (-ENOMEM);\n\n  /* Read the username */\n  BUFFER_READ (pss.username, username_len);\n  pss.username[username_len] = 0;\n\n  assert (buffer_offset == pss_head_length);\n\n  /* Query the password */\n  secret = fbh_get (se->data.server.userdb, pss.username);\n  if (secret == NULL)\n  {\n    ERROR (\"network plugin: Unknown user: %s\", pss.username);\n    sfree (pss.username);\n    return (-ENOENT);\n  }\n\n  /* Create a hash device and check the HMAC */\n  hd = NULL;\n  err = gcry_md_open (&hd, GCRY_MD_SHA256, GCRY_MD_FLAG_HMAC);\n  if (err != 0)\n  {\n    ERROR (\"network plugin: Creating HMAC-SHA-256 object failed: %s\",\n        gcry_strerror (err));\n    sfree (secret);\n    sfree (pss.username);\n    return (-1);\n  }\n\n  err = gcry_md_setkey (hd, secret, strlen (secret));\n  if (err != 0)\n  {\n    ERROR (\"network plugin: gcry_md_setkey failed: %s\", gcry_strerror (err));\n    gcry_md_close (hd);\n    sfree (secret);\n    sfree (pss.username);\n    return (-1);\n  }\n\n  gcry_md_write (hd,\n      buffer     + PART_SIGNATURE_SHA256_SIZE,\n      buffer_len - PART_SIGNATURE_SHA256_SIZE);\n  hash_ptr = gcry_md_read (hd, GCRY_MD_SHA256);\n  if (hash_ptr == NULL)\n  {\n    ERROR (\"network plugin: gcry_md_read failed.\");\n    gcry_md_close (hd);\n    sfree (secret);\n    sfree (pss.username);\n    return (-1);\n  }\n  memcpy (hash, hash_ptr, sizeof (hash));\n\n  /* Clean up */\n  gcry_md_close (hd);\n  hd = NULL;\n\n  if (memcmp (pss.hash, hash, sizeof (pss.hash)) != 0)\n  {\n    WARNING (\"network plugin: Verifying HMAC-SHA-256 signature failed: \"\n        \"Hash mismatch.\");\n  }\n  else\n  {\n    parse_packet (se, buffer + buffer_offset, buffer_len - buffer_offset,\n        flags | PP_SIGNED, pss.username);\n  }\n\n  sfree (secret);\n  sfree (pss.username);\n\n  *ret_buffer = buffer + buffer_len;\n  *ret_buffer_len = 0;\n\n  return (0);\n} /* }}} int parse_part_sign_sha256 */\n/* #endif HAVE_LIBGCRYPT */\n\n#else /* if !HAVE_LIBGCRYPT */\nstatic int parse_part_sign_sha256 (sockent_t *se, /* {{{ */\n    void **ret_buffer, size_t *ret_buffer_size, int flags)\n{\n  static int warning_has_been_printed = 0;\n\n  char *buffer;\n  size_t buffer_size;\n  size_t buffer_offset;\n  uint16_t part_len;\n\n  part_signature_sha256_t pss;\n\n  buffer = *ret_buffer;\n  buffer_size = *ret_buffer_size;\n  buffer_offset = 0;\n\n  if (buffer_size <= PART_SIGNATURE_SHA256_SIZE)\n    return (-ENOMEM);\n\n  BUFFER_READ (&pss.head.type, sizeof (pss.head.type));\n  BUFFER_READ (&pss.head.length, sizeof (pss.head.length));\n  part_len = ntohs (pss.head.length);\n\n  if ((part_len <= PART_SIGNATURE_SHA256_SIZE)\n      || (part_len > buffer_size))\n    return (-EINVAL);\n\n  if (warning_has_been_printed == 0)\n  {\n    WARNING (\"network plugin: Received signed packet, but the network \"\n        \"plugin was not linked with libgcrypt, so I cannot \"\n        \"verify the signature. The packet will be accepted.\");\n    warning_has_been_printed = 1;\n  }\n\n  parse_packet (se, buffer + part_len, buffer_size - part_len, flags,\n      /* username = */ NULL);\n\n  *ret_buffer = buffer + buffer_size;\n  *ret_buffer_size = 0;\n\n  return (0);\n} /* }}} int parse_part_sign_sha256 */\n#endif /* !HAVE_LIBGCRYPT */\n\n#if HAVE_LIBGCRYPT\nstatic int parse_part_encr_aes256 (sockent_t *se, /* {{{ */\n\t\tvoid **ret_buffer, size_t *ret_buffer_len,\n\t\tint flags)\n{\n  char  *buffer = *ret_buffer;\n  size_t buffer_len = *ret_buffer_len;\n  size_t payload_len;\n  size_t part_size;\n  size_t buffer_offset;\n  uint16_t username_len;\n  part_encryption_aes256_t pea;\n  unsigned char hash[sizeof (pea.hash)];\n\n  gcry_cipher_hd_t cypher;\n  gcry_error_t err;\n\n  /* Make sure at least the header if available. */\n  if (buffer_len <= PART_ENCRYPTION_AES256_SIZE)\n  {\n    NOTICE (\"network plugin: parse_part_encr_aes256: \"\n        \"Discarding short packet.\");\n    return (-1);\n  }\n\n  buffer_offset = 0;\n\n  /* Copy the unencrypted information into `pea'. */\n  BUFFER_READ (&pea.head.type, sizeof (pea.head.type));\n  BUFFER_READ (&pea.head.length, sizeof (pea.head.length));\n\n  /* Check the `part size'. */\n  part_size = ntohs (pea.head.length);\n  if ((part_size <= PART_ENCRYPTION_AES256_SIZE)\n      || (part_size > buffer_len))\n  {\n    NOTICE (\"network plugin: parse_part_encr_aes256: \"\n        \"Discarding part with invalid size.\");\n    return (-1);\n  }\n\n  /* Read the username */\n  BUFFER_READ (&username_len, sizeof (username_len));\n  username_len = ntohs (username_len);\n\n  if ((username_len <= 0)\n      || (username_len > (part_size - (PART_ENCRYPTION_AES256_SIZE + 1))))\n  {\n    NOTICE (\"network plugin: parse_part_encr_aes256: \"\n        \"Discarding part with invalid username length.\");\n    return (-1);\n  }\n\n  assert (username_len > 0);\n  pea.username = malloc (username_len + 1);\n  if (pea.username == NULL)\n    return (-ENOMEM);\n  BUFFER_READ (pea.username, username_len);\n  pea.username[username_len] = 0;\n\n  /* Last but not least, the initialization vector */\n  BUFFER_READ (pea.iv, sizeof (pea.iv));\n\n  /* Make sure we are at the right position */\n  assert (buffer_offset == (username_len +\n        PART_ENCRYPTION_AES256_SIZE - sizeof (pea.hash)));\n\n  cypher = network_get_aes256_cypher (se, pea.iv, sizeof (pea.iv),\n      pea.username);\n  if (cypher == NULL)\n  {\n    sfree (pea.username);\n    return (-1);\n  }\n\n  payload_len = part_size - (PART_ENCRYPTION_AES256_SIZE + username_len);\n  assert (payload_len > 0);\n\n  /* Decrypt the packet in-place */\n  err = gcry_cipher_decrypt (cypher,\n      buffer    + buffer_offset,\n      part_size - buffer_offset,\n      /* in = */ NULL, /* in len = */ 0);\n  if (err != 0)\n  {\n    sfree (pea.username);\n    ERROR (\"network plugin: gcry_cipher_decrypt returned: %s\",\n        gcry_strerror (err));\n    return (-1);\n  }\n\n  /* Read the hash */\n  BUFFER_READ (pea.hash, sizeof (pea.hash));\n\n  /* Make sure we're at the right position - again */\n  assert (buffer_offset == (username_len + PART_ENCRYPTION_AES256_SIZE));\n  assert (buffer_offset == (part_size - payload_len));\n\n  /* Check hash sum */\n  memset (hash, 0, sizeof (hash));\n  gcry_md_hash_buffer (GCRY_MD_SHA1, hash,\n      buffer + buffer_offset, payload_len);\n  if (memcmp (hash, pea.hash, sizeof (hash)) != 0)\n  {\n    sfree (pea.username);\n    ERROR (\"network plugin: Decryption failed: Checksum mismatch.\");\n    return (-1);\n  }\n\n  parse_packet (se, buffer + buffer_offset, payload_len,\n      flags | PP_ENCRYPTED, pea.username);\n\n  /* XXX: Free pea.username?!? */\n\n  /* Update return values */\n  *ret_buffer =     buffer     + part_size;\n  *ret_buffer_len = buffer_len - part_size;\n\n  sfree (pea.username);\n\n  return (0);\n} /* }}} int parse_part_encr_aes256 */\n/* #endif HAVE_LIBGCRYPT */\n\n#else /* if !HAVE_LIBGCRYPT */\nstatic int parse_part_encr_aes256 (sockent_t *se, /* {{{ */\n    void **ret_buffer, size_t *ret_buffer_size, int flags)\n{\n  static int warning_has_been_printed = 0;\n\n  char *buffer;\n  size_t buffer_size;\n  size_t buffer_offset;\n\n  part_header_t ph;\n  size_t ph_length;\n\n  buffer = *ret_buffer;\n  buffer_size = *ret_buffer_size;\n  buffer_offset = 0;\n\n  /* parse_packet assures this minimum size. */\n  assert (buffer_size >= (sizeof (ph.type) + sizeof (ph.length)));\n\n  BUFFER_READ (&ph.type, sizeof (ph.type));\n  BUFFER_READ (&ph.length, sizeof (ph.length));\n  ph_length = ntohs (ph.length);\n\n  if ((ph_length <= PART_ENCRYPTION_AES256_SIZE)\n      || (ph_length > buffer_size))\n  {\n    ERROR (\"network plugin: AES-256 encrypted part \"\n        \"with invalid length received.\");\n    return (-1);\n  }\n\n  if (warning_has_been_printed == 0)\n  {\n    WARNING (\"network plugin: Received encrypted packet, but the network \"\n        \"plugin was not linked with libgcrypt, so I cannot \"\n        \"decrypt it. The part will be discarded.\");\n    warning_has_been_printed = 1;\n  }\n\n  *ret_buffer += ph_length;\n  *ret_buffer_size -= ph_length;\n\n  return (0);\n} /* }}} int parse_part_encr_aes256 */\n#endif /* !HAVE_LIBGCRYPT */\n\n#undef BUFFER_READ\n\nstatic int parse_packet (sockent_t *se, /* {{{ */\n\t\tvoid *buffer, size_t buffer_size, int flags,\n\t\tconst char *username)\n{\n\tint status;\n\n\tvalue_list_t vl = VALUE_LIST_INIT;\n\tnotification_t n;\n\n#if HAVE_LIBGCRYPT\n\tint packet_was_signed = (flags & PP_SIGNED);\n        int packet_was_encrypted = (flags & PP_ENCRYPTED);\n\tint printed_ignore_warning = 0;\n#endif /* HAVE_LIBGCRYPT */\n\n\n\tmemset (&vl, '\\0', sizeof (vl));\n\tmemset (&n, '\\0', sizeof (n));\n\tstatus = 0;\n\n\twhile ((status == 0) && (0 < buffer_size)\n\t\t\t&& ((unsigned int) buffer_size > sizeof (part_header_t)))\n\t{\n\t\tuint16_t pkg_length;\n\t\tuint16_t pkg_type;\n\n\t\tmemcpy ((void *) &pkg_type,\n\t\t\t\t(void *) buffer,\n\t\t\t\tsizeof (pkg_type));\n\t\tmemcpy ((void *) &pkg_length,\n\t\t\t\t(void *) (buffer + sizeof (pkg_type)),\n\t\t\t\tsizeof (pkg_length));\n\n\t\tpkg_length = ntohs (pkg_length);\n\t\tpkg_type = ntohs (pkg_type);\n\n\t\tif (pkg_length > buffer_size)\n\t\t\tbreak;\n\t\t/* Ensure that this loop terminates eventually */\n\t\tif (pkg_length < (2 * sizeof (uint16_t)))\n\t\t\tbreak;\n\n\t\tif (pkg_type == TYPE_ENCR_AES256)\n\t\t{\n\t\t\tstatus = parse_part_encr_aes256 (se,\n\t\t\t\t\t&buffer, &buffer_size, flags);\n\t\t\tif (status != 0)\n\t\t\t{\n\t\t\t\tERROR (\"network plugin: Decrypting AES256 \"\n\t\t\t\t\t\t\"part failed \"\n\t\t\t\t\t\t\"with status %i.\", status);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n#if HAVE_LIBGCRYPT\n\t\telse if ((se->data.server.security_level == SECURITY_LEVEL_ENCRYPT)\n\t\t\t\t&& (packet_was_encrypted == 0))\n\t\t{\n\t\t\tif (printed_ignore_warning == 0)\n\t\t\t{\n\t\t\t\tINFO (\"network plugin: Unencrypted packet or \"\n\t\t\t\t\t\t\"part has been ignored.\");\n\t\t\t\tprinted_ignore_warning = 1;\n\t\t\t}\n\t\t\tbuffer = ((char *) buffer) + pkg_length;\n\t\t\tcontinue;\n\t\t}\n#endif /* HAVE_LIBGCRYPT */\n\t\telse if (pkg_type == TYPE_SIGN_SHA256)\n\t\t{\n\t\t\tstatus = parse_part_sign_sha256 (se,\n                                        &buffer, &buffer_size, flags);\n\t\t\tif (status != 0)\n\t\t\t{\n\t\t\t\tERROR (\"network plugin: Verifying HMAC-SHA-256 \"\n\t\t\t\t\t\t\"signature failed \"\n\t\t\t\t\t\t\"with status %i.\", status);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n#if HAVE_LIBGCRYPT\n\t\telse if ((se->data.server.security_level == SECURITY_LEVEL_SIGN)\n\t\t\t\t&& (packet_was_encrypted == 0)\n\t\t\t\t&& (packet_was_signed == 0))\n\t\t{\n\t\t\tif (printed_ignore_warning == 0)\n\t\t\t{\n\t\t\t\tINFO (\"network plugin: Unsigned packet or \"\n\t\t\t\t\t\t\"part has been ignored.\");\n\t\t\t\tprinted_ignore_warning = 1;\n\t\t\t}\n\t\t\tbuffer = ((char *) buffer) + pkg_length;\n\t\t\tcontinue;\n\t\t}\n#endif /* HAVE_LIBGCRYPT */\n\t\telse if (pkg_type == TYPE_VALUES)\n\t\t{\n\t\t\tstatus = parse_part_values (&buffer, &buffer_size,\n\t\t\t\t\t&vl.values, &vl.values_len);\n\t\t\tif (status != 0)\n\t\t\t\tbreak;\n\n\t\t\tnetwork_dispatch_values (&vl, username);\n\n\t\t\tsfree (vl.values);\n\t\t}\n\t\telse if (pkg_type == TYPE_TIME)\n\t\t{\n\t\t\tuint64_t tmp = 0;\n\t\t\tstatus = parse_part_number (&buffer, &buffer_size,\n\t\t\t\t\t&tmp);\n\t\t\tif (status == 0)\n\t\t\t{\n\t\t\t\tvl.time = TIME_T_TO_CDTIME_T (tmp);\n\t\t\t\tn.time  = TIME_T_TO_CDTIME_T (tmp);\n\t\t\t}\n\t\t}\n\t\telse if (pkg_type == TYPE_TIME_HR)\n\t\t{\n\t\t\tuint64_t tmp = 0;\n\t\t\tstatus = parse_part_number (&buffer, &buffer_size,\n\t\t\t\t\t&tmp);\n\t\t\tif (status == 0)\n\t\t\t{\n\t\t\t\tvl.time = (cdtime_t) tmp;\n\t\t\t\tn.time  = (cdtime_t) tmp;\n\t\t\t}\n\t\t}\n\t\telse if (pkg_type == TYPE_INTERVAL)\n\t\t{\n\t\t\tuint64_t tmp = 0;\n\t\t\tstatus = parse_part_number (&buffer, &buffer_size,\n\t\t\t\t\t&tmp);\n\t\t\tif (status == 0)\n\t\t\t\tvl.interval = TIME_T_TO_CDTIME_T (tmp);\n\t\t}\n\t\telse if (pkg_type == TYPE_INTERVAL_HR)\n\t\t{\n\t\t\tuint64_t tmp = 0;\n\t\t\tstatus = parse_part_number (&buffer, &buffer_size,\n\t\t\t\t\t&tmp);\n\t\t\tif (status == 0)\n\t\t\t\tvl.interval = (cdtime_t) tmp;\n\t\t}\n\t\telse if (pkg_type == TYPE_HOST)\n\t\t{\n\t\t\tstatus = parse_part_string (&buffer, &buffer_size,\n\t\t\t\t\tvl.host, sizeof (vl.host));\n\t\t\tif (status == 0)\n\t\t\t\tsstrncpy (n.host, vl.host, sizeof (n.host));\n\t\t}\n\t\telse if (pkg_type == TYPE_PLUGIN)\n\t\t{\n\t\t\tstatus = parse_part_string (&buffer, &buffer_size,\n\t\t\t\t\tvl.plugin, sizeof (vl.plugin));\n\t\t\tif (status == 0)\n\t\t\t\tsstrncpy (n.plugin, vl.plugin,\n\t\t\t\t\t\tsizeof (n.plugin));\n\t\t}\n\t\telse if (pkg_type == TYPE_PLUGIN_INSTANCE)\n\t\t{\n\t\t\tstatus = parse_part_string (&buffer, &buffer_size,\n\t\t\t\t\tvl.plugin_instance,\n\t\t\t\t\tsizeof (vl.plugin_instance));\n\t\t\tif (status == 0)\n\t\t\t\tsstrncpy (n.plugin_instance,\n\t\t\t\t\t\tvl.plugin_instance,\n\t\t\t\t\t\tsizeof (n.plugin_instance));\n\t\t}\n\t\telse if (pkg_type == TYPE_TYPE)\n\t\t{\n\t\t\tstatus = parse_part_string (&buffer, &buffer_size,\n\t\t\t\t\tvl.type, sizeof (vl.type));\n\t\t\tif (status == 0)\n\t\t\t\tsstrncpy (n.type, vl.type, sizeof (n.type));\n\t\t}\n\t\telse if (pkg_type == TYPE_TYPE_INSTANCE)\n\t\t{\n\t\t\tstatus = parse_part_string (&buffer, &buffer_size,\n\t\t\t\t\tvl.type_instance,\n\t\t\t\t\tsizeof (vl.type_instance));\n\t\t\tif (status == 0)\n\t\t\t\tsstrncpy (n.type_instance, vl.type_instance,\n\t\t\t\t\t\tsizeof (n.type_instance));\n\t\t}\n\t\telse if (pkg_type == TYPE_MESSAGE)\n\t\t{\n\t\t\tstatus = parse_part_string (&buffer, &buffer_size,\n\t\t\t\t\tn.message, sizeof (n.message));\n\n\t\t\tif (status != 0)\n\t\t\t{\n\t\t\t\t/* do nothing */\n\t\t\t}\n\t\t\telse if ((n.severity != NOTIF_FAILURE)\n\t\t\t\t\t&& (n.severity != NOTIF_WARNING)\n\t\t\t\t\t&& (n.severity != NOTIF_OKAY))\n\t\t\t{\n\t\t\t\tINFO (\"network plugin: \"\n\t\t\t\t\t\t\"Ignoring notification with \"\n\t\t\t\t\t\t\"unknown severity %i.\",\n\t\t\t\t\t\tn.severity);\n\t\t\t}\n\t\t\telse if (n.time <= 0)\n\t\t\t{\n\t\t\t\tINFO (\"network plugin: \"\n\t\t\t\t\t\t\"Ignoring notification with \"\n\t\t\t\t\t\t\"time == 0.\");\n\t\t\t}\n\t\t\telse if (strlen (n.message) <= 0)\n\t\t\t{\n\t\t\t\tINFO (\"network plugin: \"\n\t\t\t\t\t\t\"Ignoring notification with \"\n\t\t\t\t\t\t\"an empty message.\");\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tnetwork_dispatch_notification (&n);\n\t\t\t}\n\t\t}\n\t\telse if (pkg_type == TYPE_SEVERITY)\n\t\t{\n\t\t\tuint64_t tmp = 0;\n\t\t\tstatus = parse_part_number (&buffer, &buffer_size,\n\t\t\t\t\t&tmp);\n\t\t\tif (status == 0)\n\t\t\t\tn.severity = (int) tmp;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tDEBUG (\"network plugin: parse_packet: Unknown part\"\n\t\t\t\t\t\" type: 0x%04hx\", pkg_type);\n\t\t\tbuffer = ((char *) buffer) + pkg_length;\n\t\t}\n\t} /* while (buffer_size > sizeof (part_header_t)) */\n\n\tif (status == 0 && buffer_size > 0)\n\t\tWARNING (\"network plugin: parse_packet: Received truncated \"\n\t\t\t\t\"packet, try increasing `MaxPacketSize'\");\n\n\treturn (status);\n} /* }}} int parse_packet */\n\nstatic void free_sockent_client (struct sockent_client *sec) /* {{{ */\n{\n  if (sec->fd >= 0)\n  {\n    close (sec->fd);\n    sec->fd = -1;\n  }\n  sfree (sec->addr);\n#if HAVE_LIBGCRYPT\n  sfree (sec->username);\n  sfree (sec->password);\n  if (sec->cypher != NULL)\n    gcry_cipher_close (sec->cypher);\n#endif\n} /* }}} void free_sockent_client */\n\nstatic void free_sockent_server (struct sockent_server *ses) /* {{{ */\n{\n  size_t i;\n\n  for (i = 0; i < ses->fd_num; i++)\n  {\n    if (ses->fd[i] >= 0)\n    {\n      close (ses->fd[i]);\n      ses->fd[i] = -1;\n    }\n  }\n\n  sfree (ses->fd);\n#if HAVE_LIBGCRYPT\n  sfree (ses->auth_file);\n  fbh_destroy (ses->userdb);\n  if (ses->cypher != NULL)\n    gcry_cipher_close (ses->cypher);\n#endif\n} /* }}} void free_sockent_server */\n\nstatic void sockent_destroy (sockent_t *se) /* {{{ */\n{\n  sockent_t *next;\n\n  DEBUG (\"network plugin: sockent_destroy (se = %p);\", (void *) se);\n\n  while (se != NULL)\n  {\n    next = se->next;\n\n    sfree (se->node);\n    sfree (se->service);\n\n    if (se->type == SOCKENT_TYPE_CLIENT)\n      free_sockent_client (&se->data.client);\n    else\n      free_sockent_server (&se->data.server);\n\n    sfree (se);\n    se = next;\n  }\n} /* }}} void sockent_destroy */\n\n/*\n * int network_set_ttl\n *\n * Set the `IP_MULTICAST_TTL', `IP_TTL', `IPV6_MULTICAST_HOPS' or\n * `IPV6_UNICAST_HOPS', depending on which option is applicable.\n *\n * The `struct addrinfo' is used to destinguish between unicast and multicast\n * sockets.\n */\nstatic int network_set_ttl (const sockent_t *se, const struct addrinfo *ai)\n{\n\tDEBUG (\"network plugin: network_set_ttl: network_config_ttl = %i;\",\n\t\t\tnetwork_config_ttl);\n\n        assert (se->type == SOCKENT_TYPE_CLIENT);\n\n\tif ((network_config_ttl < 1) || (network_config_ttl > 255))\n\t\treturn (-1);\n\n\tif (ai->ai_family == AF_INET)\n\t{\n\t\tstruct sockaddr_in *addr = (struct sockaddr_in *) ai->ai_addr;\n\t\tint optname;\n\n\t\tif (IN_MULTICAST (ntohl (addr->sin_addr.s_addr)))\n\t\t\toptname = IP_MULTICAST_TTL;\n\t\telse\n\t\t\toptname = IP_TTL;\n\n\t\tif (setsockopt (se->data.client.fd, IPPROTO_IP, optname,\n\t\t\t\t\t&network_config_ttl,\n\t\t\t\t\tsizeof (network_config_ttl)) != 0)\n\t\t{\n\t\t\tchar errbuf[1024];\n\t\t\tERROR (\"network plugin: setsockopt (ipv4-ttl): %s\",\n\t\t\t\t\tsstrerror (errno, errbuf, sizeof (errbuf)));\n\t\t\treturn (-1);\n\t\t}\n\t}\n\telse if (ai->ai_family == AF_INET6)\n\t{\n\t\t/* Useful example: http://gsyc.escet.urjc.es/~eva/IPv6-web/examples/mcast.html */\n\t\tstruct sockaddr_in6 *addr = (struct sockaddr_in6 *) ai->ai_addr;\n\t\tint optname;\n\n\t\tif (IN6_IS_ADDR_MULTICAST (&addr->sin6_addr))\n\t\t\toptname = IPV6_MULTICAST_HOPS;\n\t\telse\n\t\t\toptname = IPV6_UNICAST_HOPS;\n\n\t\tif (setsockopt (se->data.client.fd, IPPROTO_IPV6, optname,\n\t\t\t\t\t&network_config_ttl,\n\t\t\t\t\tsizeof (network_config_ttl)) != 0)\n\t\t{\n\t\t\tchar errbuf[1024];\n\t\t\tERROR (\"network plugin: setsockopt(ipv6-ttl): %s\",\n\t\t\t\t\tsstrerror (errno, errbuf,\n\t\t\t\t\t\tsizeof (errbuf)));\n\t\t\treturn (-1);\n\t\t}\n\t}\n\n\treturn (0);\n} /* int network_set_ttl */\n\nstatic int network_set_interface (const sockent_t *se, const struct addrinfo *ai) /* {{{ */\n{\n\tDEBUG (\"network plugin: network_set_interface: interface index = %i;\",\n\t\t\tse->interface);\n\n        assert (se->type == SOCKENT_TYPE_CLIENT);\n\n\tif (ai->ai_family == AF_INET)\n\t{\n\t\tstruct sockaddr_in *addr = (struct sockaddr_in *) ai->ai_addr;\n\n\t\tif (IN_MULTICAST (ntohl (addr->sin_addr.s_addr)))\n\t\t{\n#if HAVE_STRUCT_IP_MREQN_IMR_IFINDEX\n\t\t\t/* If possible, use the \"ip_mreqn\" structure which has\n\t\t\t * an \"interface index\" member. Using the interface\n\t\t\t * index is preferred here, because of its similarity\n\t\t\t * to the way IPv6 handles this. Unfortunately, it\n\t\t\t * appears not to be portable. */\n\t\t\tstruct ip_mreqn mreq;\n\n\t\t\tmemset (&mreq, 0, sizeof (mreq));\n\t\t\tmreq.imr_multiaddr.s_addr = addr->sin_addr.s_addr;\n\t\t\tmreq.imr_address.s_addr = ntohl (INADDR_ANY);\n\t\t\tmreq.imr_ifindex = se->interface;\n#else\n\t\t\tstruct ip_mreq mreq;\n\n\t\t\tmemset (&mreq, 0, sizeof (mreq));\n\t\t\tmreq.imr_multiaddr.s_addr = addr->sin_addr.s_addr;\n\t\t\tmreq.imr_interface.s_addr = ntohl (INADDR_ANY);\n#endif\n\n\t\t\tif (setsockopt (se->data.client.fd, IPPROTO_IP, IP_MULTICAST_IF,\n\t\t\t\t\t\t&mreq, sizeof (mreq)) != 0)\n\t\t\t{\n\t\t\t\tchar errbuf[1024];\n\t\t\t\tERROR (\"network plugin: setsockopt (ipv4-multicast-if): %s\",\n\t\t\t\t\t\tsstrerror (errno, errbuf, sizeof (errbuf)));\n\t\t\t\treturn (-1);\n\t\t\t}\n\n\t\t\treturn (0);\n\t\t}\n\t}\n\telse if (ai->ai_family == AF_INET6)\n\t{\n\t\tstruct sockaddr_in6 *addr = (struct sockaddr_in6 *) ai->ai_addr;\n\n\t\tif (IN6_IS_ADDR_MULTICAST (&addr->sin6_addr))\n\t\t{\n\t\t\tif (setsockopt (se->data.client.fd, IPPROTO_IPV6, IPV6_MULTICAST_IF,\n\t\t\t\t\t\t&se->interface,\n\t\t\t\t\t\tsizeof (se->interface)) != 0)\n\t\t\t{\n\t\t\t\tchar errbuf[1024];\n\t\t\t\tERROR (\"network plugin: setsockopt (ipv6-multicast-if): %s\",\n\t\t\t\t\t\tsstrerror (errno, errbuf,\n\t\t\t\t\t\t\tsizeof (errbuf)));\n\t\t\t\treturn (-1);\n\t\t\t}\n\n\t\t\treturn (0);\n\t\t}\n\t}\n\n\t/* else: Not a multicast interface. */\n\tif (se->interface != 0)\n\t{\n#if defined(HAVE_IF_INDEXTONAME) && HAVE_IF_INDEXTONAME && defined(SO_BINDTODEVICE)\n\t\tchar interface_name[IFNAMSIZ];\n\n\t\tif (if_indextoname (se->interface, interface_name) == NULL)\n\t\t\treturn (-1);\n\n\t\tDEBUG (\"network plugin: Binding socket to interface %s\", interface_name);\n\n\t\tif (setsockopt (se->data.client.fd, SOL_SOCKET, SO_BINDTODEVICE,\n\t\t\t\t\tinterface_name,\n\t\t\t\t\tsizeof(interface_name)) == -1 )\n\t\t{\n\t\t\tchar errbuf[1024];\n\t\t\tERROR (\"network plugin: setsockopt (bind-if): %s\",\n\t\t\t\t\tsstrerror (errno, errbuf, sizeof (errbuf)));\n\t\t\treturn (-1);\n\t\t}\n/* #endif HAVE_IF_INDEXTONAME && SO_BINDTODEVICE */\n\n#else\n\t\tWARNING (\"network plugin: Cannot set the interface on a unicast \"\n\t\t\t\"socket because \"\n# if !defined(SO_BINDTODEVICE)\n\t\t\t\"the \\\"SO_BINDTODEVICE\\\" socket option \"\n# else\n\t\t\t\"the \\\"if_indextoname\\\" function \"\n# endif\n\t\t\t\"is not available on your system.\");\n#endif\n\n\t}\n\n\treturn (0);\n} /* }}} network_set_interface */\n\nstatic int network_bind_socket (int fd, const struct addrinfo *ai, const int interface_idx)\n{\n#if KERNEL_SOLARIS\n\tchar loop   = 0;\n#else\n\tint loop = 0;\n#endif\n\tint yes  = 1;\n\n\t/* allow multiple sockets to use the same PORT number */\n\tif (setsockopt (fd, SOL_SOCKET, SO_REUSEADDR,\n\t\t\t\t&yes, sizeof(yes)) == -1) {\n                char errbuf[1024];\n                ERROR (\"network plugin: setsockopt (reuseaddr): %s\",\n                                sstrerror (errno, errbuf, sizeof (errbuf)));\n\t\treturn (-1);\n\t}\n\n\tDEBUG (\"fd = %i; calling `bind'\", fd);\n\n\tif (bind (fd, ai->ai_addr, ai->ai_addrlen) == -1)\n\t{\n\t\tchar errbuf[1024];\n\t\tERROR (\"bind: %s\",\n\t\t\t\tsstrerror (errno, errbuf, sizeof (errbuf)));\n\t\treturn (-1);\n\t}\n\n\tif (ai->ai_family == AF_INET)\n\t{\n\t\tstruct sockaddr_in *addr = (struct sockaddr_in *) ai->ai_addr;\n\t\tif (IN_MULTICAST (ntohl (addr->sin_addr.s_addr)))\n\t\t{\n#if HAVE_STRUCT_IP_MREQN_IMR_IFINDEX\n\t\t\tstruct ip_mreqn mreq;\n#else\n\t\t\tstruct ip_mreq mreq;\n#endif\n\n\t\t\tDEBUG (\"fd = %i; IPv4 multicast address found\", fd);\n\n\t\t\tmreq.imr_multiaddr.s_addr = addr->sin_addr.s_addr;\n#if HAVE_STRUCT_IP_MREQN_IMR_IFINDEX\n\t\t\t/* Set the interface using the interface index if\n\t\t\t * possible (available). Unfortunately, the struct\n\t\t\t * ip_mreqn is not portable. */\n\t\t\tmreq.imr_address.s_addr = ntohl (INADDR_ANY);\n\t\t\tmreq.imr_ifindex = interface_idx;\n#else\n\t\t\tmreq.imr_interface.s_addr = ntohl (INADDR_ANY);\n#endif\n\n\t\t\tif (setsockopt (fd, IPPROTO_IP, IP_MULTICAST_LOOP,\n\t\t\t\t\t\t&loop, sizeof (loop)) == -1)\n\t\t\t{\n\t\t\t\tchar errbuf[1024];\n\t\t\t\tERROR (\"network plugin: setsockopt (multicast-loop): %s\",\n\t\t\t\t\t\tsstrerror (errno, errbuf,\n\t\t\t\t\t\t\tsizeof (errbuf)));\n\t\t\t\treturn (-1);\n\t\t\t}\n\n\t\t\tif (setsockopt (fd, IPPROTO_IP, IP_ADD_MEMBERSHIP,\n\t\t\t\t\t\t&mreq, sizeof (mreq)) == -1)\n\t\t\t{\n\t\t\t\tchar errbuf[1024];\n\t\t\t\tERROR (\"network plugin: setsockopt (add-membership): %s\",\n\t\t\t\t\t\tsstrerror (errno, errbuf,\n\t\t\t\t\t\t\tsizeof (errbuf)));\n\t\t\t\treturn (-1);\n\t\t\t}\n\n\t\t\treturn (0);\n\t\t}\n\t}\n\telse if (ai->ai_family == AF_INET6)\n\t{\n\t\t/* Useful example: http://gsyc.escet.urjc.es/~eva/IPv6-web/examples/mcast.html */\n\t\tstruct sockaddr_in6 *addr = (struct sockaddr_in6 *) ai->ai_addr;\n\t\tif (IN6_IS_ADDR_MULTICAST (&addr->sin6_addr))\n\t\t{\n\t\t\tstruct ipv6_mreq mreq;\n\n\t\t\tDEBUG (\"fd = %i; IPv6 multicast address found\", fd);\n\n\t\t\tmemcpy (&mreq.ipv6mr_multiaddr,\n\t\t\t\t\t&addr->sin6_addr,\n\t\t\t\t\tsizeof (addr->sin6_addr));\n\n\t\t\t/* http://developer.apple.com/documentation/Darwin/Reference/ManPages/man4/ip6.4.html\n\t\t\t * ipv6mr_interface may be set to zeroes to\n\t\t\t * choose the default multicast interface or to\n\t\t\t * the index of a particular multicast-capable\n\t\t\t * interface if the host is multihomed.\n\t\t\t * Membership is associ-associated with a\n\t\t\t * single interface; programs running on\n\t\t\t * multihomed hosts may need to join the same\n\t\t\t * group on more than one interface.*/\n\t\t\tmreq.ipv6mr_interface = interface_idx;\n\n\t\t\tif (setsockopt (fd, IPPROTO_IPV6, IPV6_MULTICAST_LOOP,\n\t\t\t\t\t\t&loop, sizeof (loop)) == -1)\n\t\t\t{\n\t\t\t\tchar errbuf[1024];\n\t\t\t\tERROR (\"network plugin: setsockopt (ipv6-multicast-loop): %s\",\n\t\t\t\t\t\tsstrerror (errno, errbuf,\n\t\t\t\t\t\t\tsizeof (errbuf)));\n\t\t\t\treturn (-1);\n\t\t\t}\n\n\t\t\tif (setsockopt (fd, IPPROTO_IPV6, IPV6_ADD_MEMBERSHIP,\n\t\t\t\t\t\t&mreq, sizeof (mreq)) == -1)\n\t\t\t{\n\t\t\t\tchar errbuf[1024];\n\t\t\t\tERROR (\"network plugin: setsockopt (ipv6-add-membership): %s\",\n\t\t\t\t\t\tsstrerror (errno, errbuf,\n\t\t\t\t\t\t\tsizeof (errbuf)));\n\t\t\t\treturn (-1);\n\t\t\t}\n\n\t\t\treturn (0);\n\t\t}\n\t}\n\n#if defined(HAVE_IF_INDEXTONAME) && HAVE_IF_INDEXTONAME && defined(SO_BINDTODEVICE)\n\t/* if a specific interface was set, bind the socket to it. But to avoid\n \t * possible problems with multicast routing, only do that for non-multicast\n\t * addresses */\n\tif (interface_idx != 0)\n\t{\n\t\tchar interface_name[IFNAMSIZ];\n\n\t\tif (if_indextoname (interface_idx, interface_name) == NULL)\n\t\t\treturn (-1);\n\n\t\tDEBUG (\"fd = %i; Binding socket to interface %s\", fd, interface_name);\n\n\t\tif (setsockopt (fd, SOL_SOCKET, SO_BINDTODEVICE,\n\t\t\t\t\tinterface_name,\n\t\t\t\t\tsizeof(interface_name)) == -1 )\n\t\t{\n\t\t\tchar errbuf[1024];\n\t\t\tERROR (\"network plugin: setsockopt (bind-if): %s\",\n\t\t\t\t\tsstrerror (errno, errbuf, sizeof (errbuf)));\n\t\t\treturn (-1);\n\t\t}\n\t}\n#endif /* HAVE_IF_INDEXTONAME && SO_BINDTODEVICE */\n\n\treturn (0);\n} /* int network_bind_socket */\n\n/* Initialize a sockent structure. `type' must be either `SOCKENT_TYPE_CLIENT'\n * or `SOCKENT_TYPE_SERVER' */\nstatic sockent_t *sockent_create (int type) /* {{{ */\n{\n\tsockent_t *se;\n\n\tif ((type != SOCKENT_TYPE_CLIENT) && (type != SOCKENT_TYPE_SERVER))\n\t\treturn (NULL);\n\n\tse = malloc (sizeof (*se));\n\tif (se == NULL)\n\t\treturn (NULL);\n\tmemset (se, 0, sizeof (*se));\n\n\tse->type = type;\n\tse->node = NULL;\n\tse->service = NULL;\n\tse->interface = 0;\n\tse->next = NULL;\n\n\tif (type == SOCKENT_TYPE_SERVER)\n\t{\n\t\tse->data.server.fd = NULL;\n\t\tse->data.server.fd_num = 0;\n#if HAVE_LIBGCRYPT\n\t\tse->data.server.security_level = SECURITY_LEVEL_NONE;\n\t\tse->data.server.auth_file = NULL;\n\t\tse->data.server.userdb = NULL;\n\t\tse->data.server.cypher = NULL;\n#endif\n\t}\n\telse\n\t{\n\t\tse->data.client.fd = -1;\n\t\tse->data.client.addr = NULL;\n#if HAVE_LIBGCRYPT\n\t\tse->data.client.security_level = SECURITY_LEVEL_NONE;\n\t\tse->data.client.username = NULL;\n\t\tse->data.client.password = NULL;\n\t\tse->data.client.cypher = NULL;\n#endif\n\t}\n\n\treturn (se);\n} /* }}} sockent_t *sockent_create */\n\nstatic int sockent_init_crypto (sockent_t *se) /* {{{ */\n{\n#if HAVE_LIBGCRYPT /* {{{ */\n\tif (se->type == SOCKENT_TYPE_CLIENT)\n\t{\n\t\tif (se->data.client.security_level > SECURITY_LEVEL_NONE)\n\t\t{\n\t\t\tnetwork_init_gcrypt ();\n\n\t\t\tif ((se->data.client.username == NULL)\n\t\t\t\t\t|| (se->data.client.password == NULL))\n\t\t\t{\n\t\t\t\tERROR (\"network plugin: Client socket with \"\n\t\t\t\t\t\t\"security requested, but no \"\n\t\t\t\t\t\t\"credentials are configured.\");\n\t\t\t\treturn (-1);\n\t\t\t}\n\t\t\tgcry_md_hash_buffer (GCRY_MD_SHA256,\n\t\t\t\t\tse->data.client.password_hash,\n\t\t\t\t\tse->data.client.password,\n\t\t\t\t\tstrlen (se->data.client.password));\n\t\t}\n\t}\n\telse /* (se->type == SOCKENT_TYPE_SERVER) */\n\t{\n\t\tif (se->data.server.security_level > SECURITY_LEVEL_NONE)\n\t\t{\n\t\t\tnetwork_init_gcrypt ();\n\n\t\t\tif (se->data.server.auth_file == NULL)\n\t\t\t{\n\t\t\t\tERROR (\"network plugin: Server socket with \"\n\t\t\t\t\t\t\"security requested, but no \"\n\t\t\t\t\t\t\"password file is configured.\");\n\t\t\t\treturn (-1);\n\t\t\t}\n\t\t}\n\t\tif (se->data.server.auth_file != NULL)\n\t\t{\n\t\t\tse->data.server.userdb = fbh_create (se->data.server.auth_file);\n\t\t\tif (se->data.server.userdb == NULL)\n\t\t\t{\n\t\t\t\tERROR (\"network plugin: Reading password file \"\n\t\t\t\t\t\t\"`%s' failed.\",\n\t\t\t\t\t\tse->data.server.auth_file);\n\t\t\t\tif (se->data.server.security_level > SECURITY_LEVEL_NONE)\n\t\t\t\t\treturn (-1);\n\t\t\t}\n\t\t}\n\t}\n#endif /* }}} HAVE_LIBGCRYPT */\n\n\treturn (0);\n} /* }}} int sockent_init_crypto */\n\nstatic int sockent_client_connect (sockent_t *se) /* {{{ */\n{\n\tstatic c_complain_t complaint = C_COMPLAIN_INIT_STATIC;\n\n\tstruct sockent_client *client;\n\tstruct addrinfo  ai_hints;\n\tstruct addrinfo *ai_list = NULL, *ai_ptr;\n\tint status;\n\n\tif ((se == NULL) || (se->type != SOCKENT_TYPE_CLIENT))\n\t\treturn (EINVAL);\n\n\tclient = &se->data.client;\n\tif (client->fd >= 0) /* already connected */\n\t\treturn (0);\n\n\tmemset (&ai_hints, 0, sizeof (ai_hints));\n#ifdef AI_ADDRCONFIG\n\tai_hints.ai_flags |= AI_ADDRCONFIG;\n#endif\n\tai_hints.ai_family   = AF_UNSPEC;\n\tai_hints.ai_socktype = SOCK_DGRAM;\n\tai_hints.ai_protocol = IPPROTO_UDP;\n\n\tstatus = getaddrinfo (se->node,\n\t\t\t(se->service != NULL) ? se->service : NET_DEFAULT_PORT,\n\t\t\t&ai_hints, &ai_list);\n\tif (status != 0)\n\t{\n\t\tc_complain (LOG_ERR, &complaint,\n\t\t\t\t\"network plugin: getaddrinfo (%s, %s) failed: %s\",\n\t\t\t\t(se->node == NULL) ? \"(null)\" : se->node,\n\t\t\t\t(se->service == NULL) ? \"(null)\" : se->service,\n\t\t\t\tgai_strerror (status));\n\t\treturn (-1);\n\t}\n\telse\n\t{\n\t\tc_release (LOG_NOTICE, &complaint,\n\t\t\t\t\"network plugin: Successfully resolved \\\"%s\\\".\",\n\t\t\t\tse->node);\n\t}\n\n\tfor (ai_ptr = ai_list; ai_ptr != NULL; ai_ptr = ai_ptr->ai_next)\n\t{\n\t\tclient->fd = socket (ai_ptr->ai_family,\n\t\t\t\tai_ptr->ai_socktype,\n\t\t\t\tai_ptr->ai_protocol);\n\t\tif (client->fd < 0)\n\t\t{\n\t\t\tchar errbuf[1024];\n\t\t\tERROR (\"network plugin: socket(2) failed: %s\",\n\t\t\t\t\tsstrerror (errno, errbuf,\n\t\t\t\t\t\tsizeof (errbuf)));\n\t\t\tcontinue;\n\t\t}\n\n\t\tclient->addr = malloc (sizeof (*client->addr));\n\t\tif (client->addr == NULL)\n\t\t{\n\t\t\tERROR (\"network plugin: malloc failed.\");\n\t\t\tclose (client->fd);\n\t\t\tclient->fd = -1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tmemset (client->addr, 0, sizeof (*client->addr));\n\t\tassert (sizeof (*client->addr) >= ai_ptr->ai_addrlen);\n\t\tmemcpy (client->addr, ai_ptr->ai_addr, ai_ptr->ai_addrlen);\n\t\tclient->addrlen = ai_ptr->ai_addrlen;\n\n\t\tnetwork_set_ttl (se, ai_ptr);\n\t\tnetwork_set_interface (se, ai_ptr);\n\n\t\t/* We don't open more than one write-socket per\n\t\t * node/service pair.. */\n\t\tbreak;\n\t}\n\n\tfreeaddrinfo (ai_list);\n\tif (client->fd < 0)\n\t\treturn (-1);\n\treturn (0);\n} /* }}} int sockent_client_connect */\n\nstatic int sockent_client_disconnect (sockent_t *se) /* {{{ */\n{\n\tstruct sockent_client *client;\n\n\tif ((se == NULL) || (se->type != SOCKENT_TYPE_CLIENT))\n\t\treturn (EINVAL);\n\n\tclient = &se->data.client;\n\tif (client->fd >= 0) /* connected */\n\t{\n\t\tclose (client->fd);\n\t\tclient->fd = -1;\n\t}\n\n\tsfree (client->addr);\n\tclient->addrlen = 0;\n\n\treturn (0);\n} /* }}} int sockent_client_disconnect */\n\n/* Open the file descriptors for a initialized sockent structure. */\nstatic int sockent_server_listen (sockent_t *se) /* {{{ */\n{\n\tstruct addrinfo  ai_hints;\n\tstruct addrinfo *ai_list, *ai_ptr;\n\tint              status;\n\n        const char *node;\n        const char *service;\n\n\tif (se == NULL)\n\t\treturn (-1);\n\n\tassert (se->data.server.fd == NULL);\n\tassert (se->data.server.fd_num == 0);\n\n        node = se->node;\n        service = se->service;\n\n        if (service == NULL)\n          service = NET_DEFAULT_PORT;\n\n        DEBUG (\"network plugin: sockent_server_listen: node = %s; service = %s;\",\n            node, service);\n\n\tmemset (&ai_hints, 0, sizeof (ai_hints));\n\tai_hints.ai_flags  = 0;\n#ifdef AI_PASSIVE\n\tai_hints.ai_flags |= AI_PASSIVE;\n#endif\n#ifdef AI_ADDRCONFIG\n\tai_hints.ai_flags |= AI_ADDRCONFIG;\n#endif\n\tai_hints.ai_family   = AF_UNSPEC;\n\tai_hints.ai_socktype = SOCK_DGRAM;\n\tai_hints.ai_protocol = IPPROTO_UDP;\n\n\tstatus = getaddrinfo (node, service, &ai_hints, &ai_list);\n\tif (status != 0)\n\t{\n\t\tERROR (\"network plugin: getaddrinfo (%s, %s) failed: %s\",\n\t\t\t\t(se->node == NULL) ? \"(null)\" : se->node,\n\t\t\t\t(se->service == NULL) ? \"(null)\" : se->service,\n\t\t\t\tgai_strerror (status));\n\t\treturn (-1);\n\t}\n\n\tfor (ai_ptr = ai_list; ai_ptr != NULL; ai_ptr = ai_ptr->ai_next)\n\t{\n\t\tint *tmp;\n\n\t\ttmp = realloc (se->data.server.fd,\n\t\t\t\tsizeof (*tmp) * (se->data.server.fd_num + 1));\n\t\tif (tmp == NULL)\n\t\t{\n\t\t\tERROR (\"network plugin: realloc failed.\");\n\t\t\tcontinue;\n\t\t}\n\t\tse->data.server.fd = tmp;\n\t\ttmp = se->data.server.fd + se->data.server.fd_num;\n\n\t\t*tmp = socket (ai_ptr->ai_family, ai_ptr->ai_socktype,\n\t\t\t\tai_ptr->ai_protocol);\n\t\tif (*tmp < 0)\n\t\t{\n\t\t\tchar errbuf[1024];\n\t\t\tERROR (\"network plugin: socket(2) failed: %s\",\n\t\t\t\t\tsstrerror (errno, errbuf,\n\t\t\t\t\t\tsizeof (errbuf)));\n\t\t\tcontinue;\n\t\t}\n\n\t\tstatus = network_bind_socket (*tmp, ai_ptr, se->interface);\n\t\tif (status != 0)\n\t\t{\n\t\t\tclose (*tmp);\n\t\t\t*tmp = -1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tse->data.server.fd_num++;\n\t\tcontinue;\n\t} /* for (ai_list) */\n\n\tfreeaddrinfo (ai_list);\n\n\tif (se->data.server.fd_num <= 0)\n\t\treturn (-1);\n\treturn (0);\n} /* }}} int sockent_server_listen */\n\n/* Add a sockent to the global list of sockets */\nstatic int sockent_add (sockent_t *se) /* {{{ */\n{\n\tsockent_t *last_ptr;\n\n\tif (se == NULL)\n\t\treturn (-1);\n\n\tif (se->type == SOCKENT_TYPE_SERVER)\n\t{\n\t\tstruct pollfd *tmp;\n\t\tsize_t i;\n\n\t\ttmp = realloc (listen_sockets_pollfd,\n\t\t\t\tsizeof (*tmp) * (listen_sockets_num\n\t\t\t\t\t+ se->data.server.fd_num));\n\t\tif (tmp == NULL)\n\t\t{\n\t\t\tERROR (\"network plugin: realloc failed.\");\n\t\t\treturn (-1);\n\t\t}\n\t\tlisten_sockets_pollfd = tmp;\n\t\ttmp = listen_sockets_pollfd + listen_sockets_num;\n\n\t\tfor (i = 0; i < se->data.server.fd_num; i++)\n\t\t{\n\t\t\tmemset (tmp + i, 0, sizeof (*tmp));\n\t\t\ttmp[i].fd = se->data.server.fd[i];\n\t\t\ttmp[i].events = POLLIN | POLLPRI;\n\t\t\ttmp[i].revents = 0;\n\t\t}\n\n\t\tlisten_sockets_num += se->data.server.fd_num;\n\n\t\tif (listen_sockets == NULL)\n\t\t{\n\t\t\tlisten_sockets = se;\n\t\t\treturn (0);\n\t\t}\n\t\tlast_ptr = listen_sockets;\n\t}\n\telse /* if (se->type == SOCKENT_TYPE_CLIENT) */\n\t{\n\t\tif (sending_sockets == NULL)\n\t\t{\n\t\t\tsending_sockets = se;\n\t\t\treturn (0);\n\t\t}\n\t\tlast_ptr = sending_sockets;\n\t}\n\n\twhile (last_ptr->next != NULL)\n\t\tlast_ptr = last_ptr->next;\n\tlast_ptr->next = se;\n\n\treturn (0);\n} /* }}} int sockent_add */\n\nstatic void *dispatch_thread (void __attribute__((unused)) *arg) /* {{{ */\n{\n  while (42)\n  {\n    receive_list_entry_t *ent;\n    sockent_t *se;\n\n    /* Lock and wait for more data to come in */\n    pthread_mutex_lock (&receive_list_lock);\n    while ((listen_loop == 0)\n        && (receive_list_head == NULL))\n      pthread_cond_wait (&receive_list_cond, &receive_list_lock);\n\n    /* Remove the head entry and unlock */\n    ent = receive_list_head;\n    if (ent != NULL)\n      receive_list_head = ent->next;\n    receive_list_length--;\n    pthread_mutex_unlock (&receive_list_lock);\n\n    /* Check whether we are supposed to exit. We do NOT check `listen_loop'\n     * because we dispatch all missing packets before shutting down. */\n    if (ent == NULL)\n      break;\n\n    /* Look for the correct `sockent_t' */\n    se = listen_sockets;\n    while (se != NULL)\n    {\n      size_t i;\n\n      for (i = 0; i < se->data.server.fd_num; i++)\n        if (se->data.server.fd[i] == ent->fd)\n          break;\n\n      if (i < se->data.server.fd_num)\n        break;\n\n      se = se->next;\n    }\n\n    if (se == NULL)\n    {\n      ERROR (\"network plugin: Got packet from FD %i, but can't \"\n          \"find an appropriate socket entry.\",\n          ent->fd);\n      sfree (ent->data);\n      sfree (ent);\n      continue;\n    }\n\n    parse_packet (se, ent->data, ent->data_len, /* flags = */ 0,\n\t/* username = */ NULL);\n    sfree (ent->data);\n    sfree (ent);\n  } /* while (42) */\n\n  return (NULL);\n} /* }}} void *dispatch_thread */\n\nstatic int network_receive (void) /* {{{ */\n{\n\tchar buffer[network_config_packet_size];\n\tint  buffer_len;\n\n\tint i;\n\tint status = 0;\n\n\treceive_list_entry_t *private_list_head;\n\treceive_list_entry_t *private_list_tail;\n\tuint64_t              private_list_length;\n\n\tassert (listen_sockets_num > 0);\n\n\tprivate_list_head = NULL;\n\tprivate_list_tail = NULL;\n\tprivate_list_length = 0;\n\n\twhile (listen_loop == 0)\n\t{\n\t\tstatus = poll (listen_sockets_pollfd, listen_sockets_num, -1);\n\t\tif (status <= 0)\n\t\t{\n\t\t\tchar errbuf[1024];\n\t\t\tif (errno == EINTR)\n\t\t\t\tcontinue;\n\t\t\tERROR (\"network plugin: poll(2) failed: %s\",\n\t\t\t\t\tsstrerror (errno, errbuf, sizeof (errbuf)));\n\t\t\tbreak;\n\t\t}\n\n\t\tfor (i = 0; (i < listen_sockets_num) && (status > 0); i++)\n\t\t{\n\t\t\treceive_list_entry_t *ent;\n\n\t\t\tif ((listen_sockets_pollfd[i].revents\n\t\t\t\t\t\t& (POLLIN | POLLPRI)) == 0)\n\t\t\t\tcontinue;\n\t\t\tstatus--;\n\n\t\t\tbuffer_len = recv (listen_sockets_pollfd[i].fd,\n\t\t\t\t\tbuffer, sizeof (buffer),\n\t\t\t\t\t0 /* no flags */);\n\t\t\tif (buffer_len < 0)\n\t\t\t{\n\t\t\t\tchar errbuf[1024];\n\t\t\t\tstatus = (errno != 0) ? errno : -1;\n\t\t\t\tERROR (\"network plugin: recv(2) failed: %s\",\n\t\t\t\t\t\tsstrerror (errno, errbuf, sizeof (errbuf)));\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tstats_octets_rx += ((uint64_t) buffer_len);\n\t\t\tstats_packets_rx++;\n\n\t\t\t/* TODO: Possible performance enhancement: Do not free\n\t\t\t * these entries in the dispatch thread but put them in\n\t\t\t * another list, so we don't have to allocate more and\n\t\t\t * more of these structures. */\n\t\t\tent = malloc (sizeof (receive_list_entry_t));\n\t\t\tif (ent == NULL)\n\t\t\t{\n\t\t\t\tERROR (\"network plugin: malloc failed.\");\n\t\t\t\tstatus = ENOMEM;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmemset (ent, 0, sizeof (receive_list_entry_t));\n\t\t\tent->data = malloc (network_config_packet_size);\n\t\t\tif (ent->data == NULL)\n\t\t\t{\n\t\t\t\tsfree (ent);\n\t\t\t\tERROR (\"network plugin: malloc failed.\");\n\t\t\t\tstatus = ENOMEM;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tent->fd = listen_sockets_pollfd[i].fd;\n\t\t\tent->next = NULL;\n\n\t\t\tmemcpy (ent->data, buffer, buffer_len);\n\t\t\tent->data_len = buffer_len;\n\n\t\t\tif (private_list_head == NULL)\n\t\t\t\tprivate_list_head = ent;\n\t\t\telse\n\t\t\t\tprivate_list_tail->next = ent;\n\t\t\tprivate_list_tail = ent;\n\t\t\tprivate_list_length++;\n\n\t\t\t/* Do not block here. Blocking here has led to\n\t\t\t * insufficient performance in the past. */\n\t\t\tif (pthread_mutex_trylock (&receive_list_lock) == 0)\n\t\t\t{\n\t\t\t\tassert (((receive_list_head == NULL) && (receive_list_length == 0))\n\t\t\t\t\t\t|| ((receive_list_head != NULL) && (receive_list_length != 0)));\n\n\t\t\t\tif (receive_list_head == NULL)\n\t\t\t\t\treceive_list_head = private_list_head;\n\t\t\t\telse\n\t\t\t\t\treceive_list_tail->next = private_list_head;\n\t\t\t\treceive_list_tail = private_list_tail;\n\t\t\t\treceive_list_length += private_list_length;\n\n\t\t\t\tpthread_cond_signal (&receive_list_cond);\n\t\t\t\tpthread_mutex_unlock (&receive_list_lock);\n\n\t\t\t\tprivate_list_head = NULL;\n\t\t\t\tprivate_list_tail = NULL;\n\t\t\t\tprivate_list_length = 0;\n\t\t\t}\n\n\t\t\tstatus = 0;\n\t\t} /* for (listen_sockets_pollfd) */\n\n\t\tif (status != 0)\n\t\t\tbreak;\n\t} /* while (listen_loop == 0) */\n\n\t/* Make sure everything is dispatched before exiting. */\n\tif (private_list_head != NULL)\n\t{\n\t\tpthread_mutex_lock (&receive_list_lock);\n\n\t\tif (receive_list_head == NULL)\n\t\t\treceive_list_head = private_list_head;\n\t\telse\n\t\t\treceive_list_tail->next = private_list_head;\n\t\treceive_list_tail = private_list_tail;\n\t\treceive_list_length += private_list_length;\n\n\t\tpthread_cond_signal (&receive_list_cond);\n\t\tpthread_mutex_unlock (&receive_list_lock);\n\t}\n\n\treturn (status);\n} /* }}} int network_receive */\n\nstatic void *receive_thread (void __attribute__((unused)) *arg)\n{\n\treturn (network_receive () ? (void *) 1 : (void *) 0);\n} /* void *receive_thread */\n\nstatic void network_init_buffer (void)\n{\n\tmemset (send_buffer, 0, network_config_packet_size);\n\tsend_buffer_ptr = send_buffer;\n\tsend_buffer_fill = 0;\n\n\tmemset (&send_buffer_vl, 0, sizeof (send_buffer_vl));\n} /* int network_init_buffer */\n\nstatic void networt_send_buffer_plain (sockent_t *se, /* {{{ */\n\t\tconst char *buffer, size_t buffer_size)\n{\n\tint status;\n\n\twhile (42)\n\t{\n\t\tstatus = sockent_client_connect (se);\n\t\tif (status != 0)\n\t\t\treturn;\n\n\t\tstatus = sendto (se->data.client.fd, buffer, buffer_size,\n\t\t\t\t/* flags = */ 0,\n\t\t\t\t(struct sockaddr *) se->data.client.addr,\n\t\t\t\tse->data.client.addrlen);\n\t\tif (status < 0)\n\t\t{\n\t\t\tchar errbuf[1024];\n\n\t\t\tif ((errno == EINTR) || (errno == EAGAIN))\n\t\t\t\tcontinue;\n\n\t\t\tERROR (\"network plugin: sendto failed: %s. Closing sending socket.\",\n\t\t\t\t\tsstrerror (errno, errbuf, sizeof (errbuf)));\n\t\t\tsockent_client_disconnect (se);\n\t\t\treturn;\n\t\t}\n\n\t\tbreak;\n\t} /* while (42) */\n} /* }}} void networt_send_buffer_plain */\n\n#if HAVE_LIBGCRYPT\n#define BUFFER_ADD(p,s) do { \\\n  memcpy (buffer + buffer_offset, (p), (s)); \\\n  buffer_offset += (s); \\\n} while (0)\n\nstatic void networt_send_buffer_signed (sockent_t *se, /* {{{ */\n\t\tconst char *in_buffer, size_t in_buffer_size)\n{\n  part_signature_sha256_t ps;\n  char buffer[BUFF_SIG_SIZE + in_buffer_size];\n  size_t buffer_offset;\n  size_t username_len;\n\n  gcry_md_hd_t hd;\n  gcry_error_t err;\n  unsigned char *hash;\n\n  hd = NULL;\n  err = gcry_md_open (&hd, GCRY_MD_SHA256, GCRY_MD_FLAG_HMAC);\n  if (err != 0)\n  {\n    ERROR (\"network plugin: Creating HMAC object failed: %s\",\n        gcry_strerror (err));\n    return;\n  }\n\n  err = gcry_md_setkey (hd, se->data.client.password,\n      strlen (se->data.client.password));\n  if (err != 0)\n  {\n    ERROR (\"network plugin: gcry_md_setkey failed: %s\",\n        gcry_strerror (err));\n    gcry_md_close (hd);\n    return;\n  }\n\n  username_len = strlen (se->data.client.username);\n  if (username_len > (BUFF_SIG_SIZE - PART_SIGNATURE_SHA256_SIZE))\n  {\n    ERROR (\"network plugin: Username too long: %s\",\n        se->data.client.username);\n    return;\n  }\n\n  memcpy (buffer + PART_SIGNATURE_SHA256_SIZE,\n      se->data.client.username, username_len);\n  memcpy (buffer + PART_SIGNATURE_SHA256_SIZE + username_len,\n      in_buffer, in_buffer_size);\n\n  /* Initialize the `ps' structure. */\n  memset (&ps, 0, sizeof (ps));\n  ps.head.type = htons (TYPE_SIGN_SHA256);\n  ps.head.length = htons (PART_SIGNATURE_SHA256_SIZE + username_len);\n\n  /* Calculate the hash value. */\n  gcry_md_write (hd, buffer + PART_SIGNATURE_SHA256_SIZE,\n      username_len + in_buffer_size);\n  hash = gcry_md_read (hd, GCRY_MD_SHA256);\n  if (hash == NULL)\n  {\n    ERROR (\"network plugin: gcry_md_read failed.\");\n    gcry_md_close (hd);\n    return;\n  }\n  memcpy (ps.hash, hash, sizeof (ps.hash));\n\n  /* Add the header */\n  buffer_offset = 0;\n\n  BUFFER_ADD (&ps.head.type, sizeof (ps.head.type));\n  BUFFER_ADD (&ps.head.length, sizeof (ps.head.length));\n  BUFFER_ADD (ps.hash, sizeof (ps.hash));\n\n  assert (buffer_offset == PART_SIGNATURE_SHA256_SIZE);\n\n  gcry_md_close (hd);\n  hd = NULL;\n\n  buffer_offset = PART_SIGNATURE_SHA256_SIZE + username_len + in_buffer_size;\n  networt_send_buffer_plain (se, buffer, buffer_offset);\n} /* }}} void networt_send_buffer_signed */\n\nstatic void networt_send_buffer_encrypted (sockent_t *se, /* {{{ */\n\t\tconst char *in_buffer, size_t in_buffer_size)\n{\n  part_encryption_aes256_t pea;\n  char buffer[BUFF_SIG_SIZE + in_buffer_size];\n  size_t buffer_size;\n  size_t buffer_offset;\n  size_t header_size;\n  size_t username_len;\n  gcry_error_t err;\n  gcry_cipher_hd_t cypher;\n\n  /* Initialize the header fields */\n  memset (&pea, 0, sizeof (pea));\n  pea.head.type = htons (TYPE_ENCR_AES256);\n\n  pea.username = se->data.client.username;\n\n  username_len = strlen (pea.username);\n  if ((PART_ENCRYPTION_AES256_SIZE + username_len) > BUFF_SIG_SIZE)\n  {\n    ERROR (\"network plugin: Username too long: %s\", pea.username);\n    return;\n  }\n\n  buffer_size = PART_ENCRYPTION_AES256_SIZE + username_len + in_buffer_size;\n  header_size = PART_ENCRYPTION_AES256_SIZE + username_len\n    - sizeof (pea.hash);\n\n  assert (buffer_size <= sizeof (buffer));\n  DEBUG (\"network plugin: networt_send_buffer_encrypted: \"\n      \"buffer_size = %zu;\", buffer_size);\n\n  pea.head.length = htons ((uint16_t) (PART_ENCRYPTION_AES256_SIZE\n        + username_len + in_buffer_size));\n  pea.username_length = htons ((uint16_t) username_len);\n\n  /* Chose a random initialization vector. */\n  gcry_randomize ((void *) &pea.iv, sizeof (pea.iv), GCRY_STRONG_RANDOM);\n\n  /* Create hash of the payload */\n  gcry_md_hash_buffer (GCRY_MD_SHA1, pea.hash, in_buffer, in_buffer_size);\n\n  /* Initialize the buffer */\n  buffer_offset = 0;\n  memset (buffer, 0, sizeof (buffer));\n\n\n  BUFFER_ADD (&pea.head.type, sizeof (pea.head.type));\n  BUFFER_ADD (&pea.head.length, sizeof (pea.head.length));\n  BUFFER_ADD (&pea.username_length, sizeof (pea.username_length));\n  BUFFER_ADD (pea.username, username_len);\n  BUFFER_ADD (pea.iv, sizeof (pea.iv));\n  assert (buffer_offset == header_size);\n  BUFFER_ADD (pea.hash, sizeof (pea.hash));\n  BUFFER_ADD (in_buffer, in_buffer_size);\n\n  assert (buffer_offset == buffer_size);\n\n  cypher = network_get_aes256_cypher (se, pea.iv, sizeof (pea.iv),\n      se->data.client.password);\n  if (cypher == NULL)\n    return;\n\n  /* Encrypt the buffer in-place */\n  err = gcry_cipher_encrypt (cypher,\n      buffer      + header_size,\n      buffer_size - header_size,\n      /* in = */ NULL, /* in len = */ 0);\n  if (err != 0)\n  {\n    ERROR (\"network plugin: gcry_cipher_encrypt returned: %s\",\n        gcry_strerror (err));\n    return;\n  }\n\n  /* Send it out without further modifications */\n  networt_send_buffer_plain (se, buffer, buffer_size);\n} /* }}} void networt_send_buffer_encrypted */\n#undef BUFFER_ADD\n#endif /* HAVE_LIBGCRYPT */\n\nstatic void network_send_buffer (char *buffer, size_t buffer_len) /* {{{ */\n{\n  sockent_t *se;\n\n  DEBUG (\"network plugin: network_send_buffer: buffer_len = %zu\", buffer_len);\n\n  for (se = sending_sockets; se != NULL; se = se->next)\n  {\n#if HAVE_LIBGCRYPT\n    if (se->data.client.security_level == SECURITY_LEVEL_ENCRYPT)\n      networt_send_buffer_encrypted (se, buffer, buffer_len);\n    else if (se->data.client.security_level == SECURITY_LEVEL_SIGN)\n      networt_send_buffer_signed (se, buffer, buffer_len);\n    else /* if (se->data.client.security_level == SECURITY_LEVEL_NONE) */\n#endif /* HAVE_LIBGCRYPT */\n      networt_send_buffer_plain (se, buffer, buffer_len);\n  } /* for (sending_sockets) */\n} /* }}} void network_send_buffer */\n\nstatic int add_to_buffer (char *buffer, int buffer_size, /* {{{ */\n\t\tvalue_list_t *vl_def,\n\t\tconst data_set_t *ds, const value_list_t *vl)\n{\n\tchar *buffer_orig = buffer;\n\n\tif (strcmp (vl_def->host, vl->host) != 0)\n\t{\n\t\tif (write_part_string (&buffer, &buffer_size, TYPE_HOST,\n\t\t\t\t\tvl->host, strlen (vl->host)) != 0)\n\t\t\treturn (-1);\n\t\tsstrncpy (vl_def->host, vl->host, sizeof (vl_def->host));\n\t}\n\n\tif (vl_def->time != vl->time)\n\t{\n\t\tif (write_part_number (&buffer, &buffer_size, TYPE_TIME_HR,\n\t\t\t\t\t(uint64_t) vl->time))\n\t\t\treturn (-1);\n\t\tvl_def->time = vl->time;\n\t}\n\n\tif (vl_def->interval != vl->interval)\n\t{\n\t\tif (write_part_number (&buffer, &buffer_size, TYPE_INTERVAL_HR,\n\t\t\t\t\t(uint64_t) vl->interval))\n\t\t\treturn (-1);\n\t\tvl_def->interval = vl->interval;\n\t}\n\n\tif (strcmp (vl_def->plugin, vl->plugin) != 0)\n\t{\n\t\tif (write_part_string (&buffer, &buffer_size, TYPE_PLUGIN,\n\t\t\t\t\tvl->plugin, strlen (vl->plugin)) != 0)\n\t\t\treturn (-1);\n\t\tsstrncpy (vl_def->plugin, vl->plugin, sizeof (vl_def->plugin));\n\t}\n\n\tif (strcmp (vl_def->plugin_instance, vl->plugin_instance) != 0)\n\t{\n\t\tif (write_part_string (&buffer, &buffer_size, TYPE_PLUGIN_INSTANCE,\n\t\t\t\t\tvl->plugin_instance,\n\t\t\t\t\tstrlen (vl->plugin_instance)) != 0)\n\t\t\treturn (-1);\n\t\tsstrncpy (vl_def->plugin_instance, vl->plugin_instance, sizeof (vl_def->plugin_instance));\n\t}\n\n\tif (strcmp (vl_def->type, vl->type) != 0)\n\t{\n\t\tif (write_part_string (&buffer, &buffer_size, TYPE_TYPE,\n\t\t\t\t\tvl->type, strlen (vl->type)) != 0)\n\t\t\treturn (-1);\n\t\tsstrncpy (vl_def->type, ds->type, sizeof (vl_def->type));\n\t}\n\n\tif (strcmp (vl_def->type_instance, vl->type_instance) != 0)\n\t{\n\t\tif (write_part_string (&buffer, &buffer_size, TYPE_TYPE_INSTANCE,\n\t\t\t\t\tvl->type_instance,\n\t\t\t\t\tstrlen (vl->type_instance)) != 0)\n\t\t\treturn (-1);\n\t\tsstrncpy (vl_def->type_instance, vl->type_instance, sizeof (vl_def->type_instance));\n\t}\n\n\tif (write_part_values (&buffer, &buffer_size, ds, vl) != 0)\n\t\treturn (-1);\n\n\treturn (buffer - buffer_orig);\n} /* }}} int add_to_buffer */\n\nstatic void flush_buffer (void)\n{\n\tDEBUG (\"network plugin: flush_buffer: send_buffer_fill = %i\",\n\t\t\tsend_buffer_fill);\n\n\tnetwork_send_buffer (send_buffer, (size_t) send_buffer_fill);\n\n\tstats_octets_tx += ((uint64_t) send_buffer_fill);\n\tstats_packets_tx++;\n\n\tnetwork_init_buffer ();\n}\n\nstatic int network_write (const data_set_t *ds, const value_list_t *vl,\n\t\tuser_data_t __attribute__((unused)) *user_data)\n{\n\tint status;\n\n\tif (!check_send_okay (vl))\n\t{\n#if COLLECT_DEBUG\n\t  char name[6*DATA_MAX_NAME_LEN];\n\t  FORMAT_VL (name, sizeof (name), vl);\n\t  name[sizeof (name) - 1] = 0;\n\t  DEBUG (\"network plugin: network_write: \"\n\t      \"NOT sending %s.\", name);\n#endif\n\t  /* Counter is not protected by another lock and may be reached by\n\t   * multiple threads */\n\t  pthread_mutex_lock (&stats_lock);\n\t  stats_values_not_sent++;\n\t  pthread_mutex_unlock (&stats_lock);\n\t  return (0);\n\t}\n\n\tuc_meta_data_add_unsigned_int (vl,\n\t    \"network:time_sent\", (uint64_t) vl->time);\n\n\tpthread_mutex_lock (&send_buffer_lock);\n\n\tstatus = add_to_buffer (send_buffer_ptr,\n\t\t\tnetwork_config_packet_size - (send_buffer_fill + BUFF_SIG_SIZE),\n\t\t\t&send_buffer_vl,\n\t\t\tds, vl);\n\tif (status >= 0)\n\t{\n\t\t/* status == bytes added to the buffer */\n\t\tsend_buffer_fill += status;\n\t\tsend_buffer_ptr  += status;\n\n\t\tstats_values_sent++;\n\t}\n\telse\n\t{\n\t\tflush_buffer ();\n\n\t\tstatus = add_to_buffer (send_buffer_ptr,\n\t\t\t\tnetwork_config_packet_size - (send_buffer_fill + BUFF_SIG_SIZE),\n\t\t\t\t&send_buffer_vl,\n\t\t\t\tds, vl);\n\n\t\tif (status >= 0)\n\t\t{\n\t\t\tsend_buffer_fill += status;\n\t\t\tsend_buffer_ptr  += status;\n\n\t\t\tstats_values_sent++;\n\t\t}\n\t}\n\n\tif (status < 0)\n\t{\n\t\tERROR (\"network plugin: Unable to append to the \"\n\t\t\t\t\"buffer for some weird reason\");\n\t}\n\telse if ((network_config_packet_size - send_buffer_fill) < 15)\n\t{\n\t\tflush_buffer ();\n\t}\n\n\tpthread_mutex_unlock (&send_buffer_lock);\n\n\treturn ((status < 0) ? -1 : 0);\n} /* int network_write */\n\nstatic int network_config_set_boolean (const oconfig_item_t *ci, /* {{{ */\n    int *retval)\n{\n  if ((ci->values_num != 1)\n      || ((ci->values[0].type != OCONFIG_TYPE_BOOLEAN)\n        && (ci->values[0].type != OCONFIG_TYPE_STRING)))\n  {\n    ERROR (\"network plugin: The `%s' config option needs \"\n        \"exactly one boolean argument.\", ci->key);\n    return (-1);\n  }\n\n  if (ci->values[0].type == OCONFIG_TYPE_BOOLEAN)\n  {\n    if (ci->values[0].value.boolean)\n      *retval = 1;\n    else\n      *retval = 0;\n  }\n  else\n  {\n    char *str = ci->values[0].value.string;\n\n    if (IS_TRUE (str))\n      *retval = 1;\n    else if (IS_FALSE (str))\n      *retval = 0;\n    else\n    {\n      ERROR (\"network plugin: Cannot parse string value `%s' of the `%s' \"\n          \"option as boolean value.\",\n          str, ci->key);\n      return (-1);\n    }\n  }\n\n  return (0);\n} /* }}} int network_config_set_boolean */\n\nstatic int network_config_set_ttl (const oconfig_item_t *ci) /* {{{ */\n{\n  int tmp;\n  if ((ci->values_num != 1)\n      || (ci->values[0].type != OCONFIG_TYPE_NUMBER))\n  {\n    WARNING (\"network plugin: The `TimeToLive' config option needs exactly \"\n        \"one numeric argument.\");\n    return (-1);\n  }\n\n  tmp = (int) ci->values[0].value.number;\n  if ((tmp > 0) && (tmp <= 255))\n    network_config_ttl = tmp;\n  else {\n    WARNING (\"network plugin: The `TimeToLive' must be between 1 and 255.\");\n    return (-1);\n  }\n\n  return (0);\n} /* }}} int network_config_set_ttl */\n\nstatic int network_config_set_interface (const oconfig_item_t *ci, /* {{{ */\n    int *interface)\n{\n  if ((ci->values_num != 1)\n      || (ci->values[0].type != OCONFIG_TYPE_STRING))\n  {\n    WARNING (\"network plugin: The `Interface' config option needs exactly \"\n        \"one string argument.\");\n    return (-1);\n  }\n\n  if (interface == NULL)\n    return (-1);\n\n  *interface = if_nametoindex (ci->values[0].value.string);\n\n  return (0);\n} /* }}} int network_config_set_interface */\n\nstatic int network_config_set_buffer_size (const oconfig_item_t *ci) /* {{{ */\n{\n  int tmp;\n  if ((ci->values_num != 1)\n      || (ci->values[0].type != OCONFIG_TYPE_NUMBER))\n  {\n    WARNING (\"network plugin: The `MaxPacketSize' config option needs exactly \"\n        \"one numeric argument.\");\n    return (-1);\n  }\n\n  tmp = (int) ci->values[0].value.number;\n  if ((tmp >= 1024) && (tmp <= 65535))\n    network_config_packet_size = tmp;\n\n  return (0);\n} /* }}} int network_config_set_buffer_size */\n\n#if HAVE_LIBGCRYPT\nstatic int network_config_set_string (const oconfig_item_t *ci, /* {{{ */\n    char **ret_string)\n{\n  char *tmp;\n  if ((ci->values_num != 1)\n      || (ci->values[0].type != OCONFIG_TYPE_STRING))\n  {\n    WARNING (\"network plugin: The `%s' config option needs exactly \"\n        \"one string argument.\", ci->key);\n    return (-1);\n  }\n\n  tmp = strdup (ci->values[0].value.string);\n  if (tmp == NULL)\n    return (-1);\n\n  sfree (*ret_string);\n  *ret_string = tmp;\n\n  return (0);\n} /* }}} int network_config_set_string */\n#endif /* HAVE_LIBGCRYPT */\n\n#if HAVE_LIBGCRYPT\nstatic int network_config_set_security_level (oconfig_item_t *ci, /* {{{ */\n    int *retval)\n{\n  char *str;\n  if ((ci->values_num != 1)\n      || (ci->values[0].type != OCONFIG_TYPE_STRING))\n  {\n    WARNING (\"network plugin: The `SecurityLevel' config option needs exactly \"\n        \"one string argument.\");\n    return (-1);\n  }\n\n  str = ci->values[0].value.string;\n  if (strcasecmp (\"Encrypt\", str) == 0)\n    *retval = SECURITY_LEVEL_ENCRYPT;\n  else if (strcasecmp (\"Sign\", str) == 0)\n    *retval = SECURITY_LEVEL_SIGN;\n  else if (strcasecmp (\"None\", str) == 0)\n    *retval = SECURITY_LEVEL_NONE;\n  else\n  {\n    WARNING (\"network plugin: Unknown security level: %s.\", str);\n    return (-1);\n  }\n\n  return (0);\n} /* }}} int network_config_set_security_level */\n#endif /* HAVE_LIBGCRYPT */\n\nstatic int network_config_add_listen (const oconfig_item_t *ci) /* {{{ */\n{\n  sockent_t *se;\n  int status;\n  int i;\n\n  if ((ci->values_num < 1) || (ci->values_num > 2)\n      || (ci->values[0].type != OCONFIG_TYPE_STRING)\n      || ((ci->values_num > 1) && (ci->values[1].type != OCONFIG_TYPE_STRING)))\n  {\n    ERROR (\"network plugin: The `%s' config option needs \"\n        \"one or two string arguments.\", ci->key);\n    return (-1);\n  }\n\n  se = sockent_create (SOCKENT_TYPE_SERVER);\n  if (se == NULL)\n  {\n    ERROR (\"network plugin: sockent_create failed.\");\n    return (-1);\n  }\n\n  se->node = strdup (ci->values[0].value.string);\n  if (ci->values_num >= 2)\n    se->service = strdup (ci->values[1].value.string);\n\n  for (i = 0; i < ci->children_num; i++)\n  {\n    oconfig_item_t *child = ci->children + i;\n\n#if HAVE_LIBGCRYPT\n    if (strcasecmp (\"AuthFile\", child->key) == 0)\n      network_config_set_string (child, &se->data.server.auth_file);\n    else if (strcasecmp (\"SecurityLevel\", child->key) == 0)\n      network_config_set_security_level (child,\n          &se->data.server.security_level);\n    else\n#endif /* HAVE_LIBGCRYPT */\n    if (strcasecmp (\"Interface\", child->key) == 0)\n      network_config_set_interface (child,\n          &se->interface);\n    else\n    {\n      WARNING (\"network plugin: Option `%s' is not allowed here.\",\n          child->key);\n    }\n  }\n\n#if HAVE_LIBGCRYPT\n  if ((se->data.server.security_level > SECURITY_LEVEL_NONE)\n      && (se->data.server.auth_file == NULL))\n  {\n    ERROR (\"network plugin: A security level higher than `none' was \"\n        \"requested, but no AuthFile option was given. Cowardly refusing to \"\n        \"open this socket!\");\n    sockent_destroy (se);\n    return (-1);\n  }\n#endif /* HAVE_LIBGCRYPT */\n\n  status = sockent_init_crypto (se);\n  if (status != 0)\n  {\n    ERROR (\"network plugin: network_config_add_listen: sockent_init_crypto() failed.\");\n    sockent_destroy (se);\n    return (-1);\n  }\n\n  status = sockent_server_listen (se);\n  if (status != 0)\n  {\n    ERROR (\"network plugin: network_config_add_server: sockent_server_listen failed.\");\n    sockent_destroy (se);\n    return (-1);\n  }\n\n  status = sockent_add (se);\n  if (status != 0)\n  {\n    ERROR (\"network plugin: network_config_add_listen: sockent_add failed.\");\n    sockent_destroy (se);\n    return (-1);\n  }\n\n  return (0);\n} /* }}} int network_config_add_listen */\n\nstatic int network_config_add_server (const oconfig_item_t *ci) /* {{{ */\n{\n  sockent_t *se;\n  int status;\n  int i;\n\n  if ((ci->values_num < 1) || (ci->values_num > 2)\n      || (ci->values[0].type != OCONFIG_TYPE_STRING)\n      || ((ci->values_num > 1) && (ci->values[1].type != OCONFIG_TYPE_STRING)))\n  {\n    ERROR (\"network plugin: The `%s' config option needs \"\n        \"one or two string arguments.\", ci->key);\n    return (-1);\n  }\n\n  se = sockent_create (SOCKENT_TYPE_CLIENT);\n  if (se == NULL)\n  {\n    ERROR (\"network plugin: sockent_create failed.\");\n    return (-1);\n  }\n\n  se->node = strdup (ci->values[0].value.string);\n  if (ci->values_num >= 2)\n    se->service = strdup (ci->values[1].value.string);\n\n  for (i = 0; i < ci->children_num; i++)\n  {\n    oconfig_item_t *child = ci->children + i;\n\n#if HAVE_LIBGCRYPT\n    if (strcasecmp (\"Username\", child->key) == 0)\n      network_config_set_string (child, &se->data.client.username);\n    else if (strcasecmp (\"Password\", child->key) == 0)\n      network_config_set_string (child, &se->data.client.password);\n    else if (strcasecmp (\"SecurityLevel\", child->key) == 0)\n      network_config_set_security_level (child,\n          &se->data.client.security_level);\n    else\n#endif /* HAVE_LIBGCRYPT */\n    if (strcasecmp (\"Interface\", child->key) == 0)\n      network_config_set_interface (child,\n          &se->interface);\n    else\n    {\n      WARNING (\"network plugin: Option `%s' is not allowed here.\",\n          child->key);\n    }\n  }\n\n#if HAVE_LIBGCRYPT\n  if ((se->data.client.security_level > SECURITY_LEVEL_NONE)\n      && ((se->data.client.username == NULL)\n        || (se->data.client.password == NULL)))\n  {\n    ERROR (\"network plugin: A security level higher than `none' was \"\n        \"requested, but no Username or Password option was given. \"\n        \"Cowardly refusing to open this socket!\");\n    sockent_destroy (se);\n    return (-1);\n  }\n#endif /* HAVE_LIBGCRYPT */\n\n  status = sockent_init_crypto (se);\n  if (status != 0)\n  {\n    ERROR (\"network plugin: network_config_add_server: sockent_init_crypto() failed.\");\n    sockent_destroy (se);\n    return (-1);\n  }\n\n  /* No call to sockent_client_connect() here -- it is called from\n   * networt_send_buffer_plain(). */\n\n  status = sockent_add (se);\n  if (status != 0)\n  {\n    ERROR (\"network plugin: network_config_add_server: sockent_add failed.\");\n    sockent_destroy (se);\n    return (-1);\n  }\n\n  return (0);\n} /* }}} int network_config_add_server */\n\nstatic int network_config (oconfig_item_t *ci) /* {{{ */\n{\n  int i;\n\n  /* The options need to be applied first */\n  for (i = 0; i < ci->children_num; i++)\n  {\n    oconfig_item_t *child = ci->children + i;\n    if (strcasecmp (\"TimeToLive\", child->key) == 0)\n      network_config_set_ttl (child);\n  }\n\n  for (i = 0; i < ci->children_num; i++)\n  {\n    oconfig_item_t *child = ci->children + i;\n\n    if (strcasecmp (\"Listen\", child->key) == 0)\n      network_config_add_listen (child);\n    else if (strcasecmp (\"Server\", child->key) == 0)\n      network_config_add_server (child);\n    else if (strcasecmp (\"TimeToLive\", child->key) == 0) {\n      /* Handled earlier */\n    }\n    else if (strcasecmp (\"MaxPacketSize\", child->key) == 0)\n      network_config_set_buffer_size (child);\n    else if (strcasecmp (\"Forward\", child->key) == 0)\n      network_config_set_boolean (child, &network_config_forward);\n    else if (strcasecmp (\"ReportStats\", child->key) == 0)\n      network_config_set_boolean (child, &network_config_stats);\n    else\n    {\n      WARNING (\"network plugin: Option `%s' is not allowed here.\",\n          child->key);\n    }\n  }\n\n  return (0);\n} /* }}} int network_config */\n\nstatic int network_notification (const notification_t *n,\n    user_data_t __attribute__((unused)) *user_data)\n{\n  char  buffer[network_config_packet_size];\n  char *buffer_ptr = buffer;\n  int   buffer_free = sizeof (buffer);\n  int   status;\n\n  if (!check_send_notify_okay (n))\n    return (0);\n\n  memset (buffer, 0, sizeof (buffer));\n\n  status = write_part_number (&buffer_ptr, &buffer_free, TYPE_TIME_HR,\n      (uint64_t) n->time);\n  if (status != 0)\n    return (-1);\n\n  status = write_part_number (&buffer_ptr, &buffer_free, TYPE_SEVERITY,\n      (uint64_t) n->severity);\n  if (status != 0)\n    return (-1);\n\n  if (strlen (n->host) > 0)\n  {\n    status = write_part_string (&buffer_ptr, &buffer_free, TYPE_HOST,\n        n->host, strlen (n->host));\n    if (status != 0)\n      return (-1);\n  }\n\n  if (strlen (n->plugin) > 0)\n  {\n    status = write_part_string (&buffer_ptr, &buffer_free, TYPE_PLUGIN,\n        n->plugin, strlen (n->plugin));\n    if (status != 0)\n      return (-1);\n  }\n\n  if (strlen (n->plugin_instance) > 0)\n  {\n    status = write_part_string (&buffer_ptr, &buffer_free,\n        TYPE_PLUGIN_INSTANCE,\n        n->plugin_instance, strlen (n->plugin_instance));\n    if (status != 0)\n      return (-1);\n  }\n\n  if (strlen (n->type) > 0)\n  {\n    status = write_part_string (&buffer_ptr, &buffer_free, TYPE_TYPE,\n        n->type, strlen (n->type));\n    if (status != 0)\n      return (-1);\n  }\n\n  if (strlen (n->type_instance) > 0)\n  {\n    status = write_part_string (&buffer_ptr, &buffer_free, TYPE_TYPE_INSTANCE,\n        n->type_instance, strlen (n->type_instance));\n    if (status != 0)\n      return (-1);\n  }\n\n  status = write_part_string (&buffer_ptr, &buffer_free, TYPE_MESSAGE,\n      n->message, strlen (n->message));\n  if (status != 0)\n    return (-1);\n\n  network_send_buffer (buffer, sizeof (buffer) - buffer_free);\n\n  return (0);\n} /* int network_notification */\n\nstatic int network_shutdown (void)\n{\n\tsockent_t *se;\n\n\tlisten_loop++;\n\n\t/* Kill the listening thread */\n\tif (receive_thread_running != 0)\n\t{\n\t\tINFO (\"network plugin: Stopping receive thread.\");\n\t\tpthread_kill (receive_thread_id, SIGTERM);\n\t\tpthread_join (receive_thread_id, NULL /* no return value */);\n\t\tmemset (&receive_thread_id, 0, sizeof (receive_thread_id));\n\t\treceive_thread_running = 0;\n\t}\n\n\t/* Shutdown the dispatching thread */\n\tif (dispatch_thread_running != 0)\n\t{\n\t\tINFO (\"network plugin: Stopping dispatch thread.\");\n\t\tpthread_mutex_lock (&receive_list_lock);\n\t\tpthread_cond_broadcast (&receive_list_cond);\n\t\tpthread_mutex_unlock (&receive_list_lock);\n\t\tpthread_join (dispatch_thread_id, /* ret = */ NULL);\n\t\tdispatch_thread_running = 0;\n\t}\n\n\tsockent_destroy (listen_sockets);\n\n\tif (send_buffer_fill > 0)\n\t\tflush_buffer ();\n\n\tsfree (send_buffer);\n\n\tfor (se = sending_sockets; se != NULL; se = se->next)\n\t\tsockent_client_disconnect (se);\n\tsockent_destroy (sending_sockets);\n\n\tplugin_unregister_config (\"network\");\n\tplugin_unregister_init (\"network\");\n\tplugin_unregister_write (\"network\");\n\tplugin_unregister_shutdown (\"network\");\n\n\treturn (0);\n} /* int network_shutdown */\n\nstatic int network_stats_read (void) /* {{{ */\n{\n\tderive_t copy_octets_rx;\n\tderive_t copy_octets_tx;\n\tderive_t copy_packets_rx;\n\tderive_t copy_packets_tx;\n\tderive_t copy_values_dispatched;\n\tderive_t copy_values_not_dispatched;\n\tderive_t copy_values_sent;\n\tderive_t copy_values_not_sent;\n\tderive_t copy_receive_list_length;\n\tvalue_list_t vl = VALUE_LIST_INIT;\n\tvalue_t values[2];\n\n\tcopy_octets_rx = stats_octets_rx;\n\tcopy_octets_tx = stats_octets_tx;\n\tcopy_packets_rx = stats_packets_rx;\n\tcopy_packets_tx = stats_packets_tx;\n\tcopy_values_dispatched = stats_values_dispatched;\n\tcopy_values_not_dispatched = stats_values_not_dispatched;\n\tcopy_values_sent = stats_values_sent;\n\tcopy_values_not_sent = stats_values_not_sent;\n\tcopy_receive_list_length = receive_list_length;\n\n\t/* Initialize `vl' */\n\tvl.values = values;\n\tvl.values_len = 2;\n\tvl.time = 0;\n\tsstrncpy (vl.host, hostname_g, sizeof (vl.host));\n\tsstrncpy (vl.plugin, \"network\", sizeof (vl.plugin));\n\n\t/* Octets received / sent */\n\tvl.values[0].derive = (derive_t) copy_octets_rx;\n\tvl.values[1].derive = (derive_t) copy_octets_tx;\n\tsstrncpy (vl.type, \"if_octets\", sizeof (vl.type));\n\tplugin_dispatch_values (&vl);\n\n\t/* Packets received / send */\n\tvl.values[0].derive = (derive_t) copy_packets_rx;\n\tvl.values[1].derive = (derive_t) copy_packets_tx;\n\tsstrncpy (vl.type, \"if_packets\", sizeof (vl.type));\n\tplugin_dispatch_values (&vl);\n\n\t/* Values (not) dispatched and (not) send */\n\tsstrncpy (vl.type, \"total_values\", sizeof (vl.type));\n\tvl.values_len = 1;\n\n\tvl.values[0].derive = (derive_t) copy_values_dispatched;\n\tsstrncpy (vl.type_instance, \"dispatch-accepted\",\n\t\t\tsizeof (vl.type_instance));\n\tplugin_dispatch_values (&vl);\n\n\tvl.values[0].derive = (derive_t) copy_values_not_dispatched;\n\tsstrncpy (vl.type_instance, \"dispatch-rejected\",\n\t\t\tsizeof (vl.type_instance));\n\tplugin_dispatch_values (&vl);\n\n\tvl.values[0].derive = (derive_t) copy_values_sent;\n\tsstrncpy (vl.type_instance, \"send-accepted\",\n\t\t\tsizeof (vl.type_instance));\n\tplugin_dispatch_values (&vl);\n\n\tvl.values[0].derive = (derive_t) copy_values_not_sent;\n\tsstrncpy (vl.type_instance, \"send-rejected\",\n\t\t\tsizeof (vl.type_instance));\n\tplugin_dispatch_values (&vl);\n\n\t/* Receive queue length */\n\tvl.values[0].gauge = (gauge_t) copy_receive_list_length;\n\tsstrncpy (vl.type, \"queue_length\", sizeof (vl.type));\n\tvl.type_instance[0] = 0;\n\tplugin_dispatch_values (&vl);\n\n\treturn (0);\n} /* }}} int network_stats_read */\n\nstatic int network_init (void)\n{\n\tstatic _Bool have_init = 0;\n\n\t/* Check if we were already initialized. If so, just return - there's\n\t * nothing more to do (for now, that is). */\n\tif (have_init)\n\t\treturn (0);\n\thave_init = 1;\n\n#if HAVE_LIBGCRYPT\n\tnetwork_init_gcrypt ();\n#endif\n\n\tif (network_config_stats != 0)\n\t\tplugin_register_read (\"network\", network_stats_read);\n\n\tplugin_register_shutdown (\"network\", network_shutdown);\n\n\tsend_buffer = malloc (network_config_packet_size);\n\tif (send_buffer == NULL)\n\t{\n\t\tERROR (\"network plugin: malloc failed.\");\n\t\treturn (-1);\n\t}\n\tnetwork_init_buffer ();\n\n\t/* setup socket(s) and so on */\n\tif (sending_sockets != NULL)\n\t{\n\t\tplugin_register_write (\"network\", network_write,\n\t\t\t\t/* user_data = */ NULL);\n\t\tplugin_register_notification (\"network\", network_notification,\n\t\t\t\t/* user_data = */ NULL);\n\t}\n\n\t/* If no threads need to be started, return here. */\n\tif ((listen_sockets_num == 0)\n\t\t\t|| ((dispatch_thread_running != 0)\n\t\t\t\t&& (receive_thread_running != 0)))\n\t\treturn (0);\n\n\tif (dispatch_thread_running == 0)\n\t{\n\t\tint status;\n\t\tstatus = plugin_thread_create (&dispatch_thread_id,\n\t\t\t\tNULL /* no attributes */,\n\t\t\t\tdispatch_thread,\n\t\t\t\tNULL /* no argument */);\n\t\tif (status != 0)\n\t\t{\n\t\t\tchar errbuf[1024];\n\t\t\tERROR (\"network: pthread_create failed: %s\",\n\t\t\t\t\tsstrerror (errno, errbuf,\n\t\t\t\t\t\tsizeof (errbuf)));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tdispatch_thread_running = 1;\n\t\t}\n\t}\n\n\tif (receive_thread_running == 0)\n\t{\n\t\tint status;\n\t\tstatus = plugin_thread_create (&receive_thread_id,\n\t\t\t\tNULL /* no attributes */,\n\t\t\t\treceive_thread,\n\t\t\t\tNULL /* no argument */);\n\t\tif (status != 0)\n\t\t{\n\t\t\tchar errbuf[1024];\n\t\t\tERROR (\"network: pthread_create failed: %s\",\n\t\t\t\t\tsstrerror (errno, errbuf,\n\t\t\t\t\t\tsizeof (errbuf)));\n\t\t}\n\t\telse\n\t\t{\n\t\t\treceive_thread_running = 1;\n\t\t}\n\t}\n\n\treturn (0);\n} /* int network_init */\n\n/*\n * The flush option of the network plugin cannot flush individual identifiers.\n * All the values are added to a buffer and sent when the buffer is full, the\n * requested value may or may not be in there, it's not worth finding out. We\n * just send the buffer if `flush'  is called - if the requested value was in\n * there, good. If not, well, then there is nothing to flush.. -octo\n */\nstatic int network_flush (__attribute__((unused)) cdtime_t timeout,\n\t\t__attribute__((unused)) const char *identifier,\n\t\t__attribute__((unused)) user_data_t *user_data)\n{\n\tpthread_mutex_lock (&send_buffer_lock);\n\n\tif (send_buffer_fill > 0)\n\t  flush_buffer ();\n\n\tpthread_mutex_unlock (&send_buffer_lock);\n\n\treturn (0);\n} /* int network_flush */\n\nvoid module_register (void)\n{\n\tplugin_register_complex_config (\"network\", network_config);\n\tplugin_register_init   (\"network\", network_init);\n\tplugin_register_flush   (\"network\", network_flush,\n\t\t\t/* user_data = */ NULL);\n} /* void module_register */\n\n/* vim: set fdm=marker : */\n"], "fixing_code": ["/**\n * collectd - src/network.c\n * Copyright (C) 2005-2013  Florian octo Forster\n * Copyright (C) 2009       Aman Gupta\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation; only version 2.1 of the License is\n * applicable.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with this program; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n *\n * Authors:\n *   Florian octo Forster <octo at collectd.org>\n *   Aman Gupta <aman at tmm1.net>\n **/\n\n#define _DEFAULT_SOURCE\n#define _BSD_SOURCE /* For struct ip_mreq */\n\n#include \"collectd.h\"\n#include \"plugin.h\"\n#include \"common.h\"\n#include \"configfile.h\"\n#include \"utils_fbhash.h\"\n#include \"utils_avltree.h\"\n#include \"utils_cache.h\"\n#include \"utils_complain.h\"\n\n#include \"network.h\"\n\n#if HAVE_PTHREAD_H\n# include <pthread.h>\n#endif\n#if HAVE_SYS_SOCKET_H\n# include <sys/socket.h>\n#endif\n#if HAVE_NETDB_H\n# include <netdb.h>\n#endif\n#if HAVE_NETINET_IN_H\n# include <netinet/in.h>\n#endif\n#if HAVE_ARPA_INET_H\n# include <arpa/inet.h>\n#endif\n#if HAVE_POLL_H\n# include <poll.h>\n#endif\n#if HAVE_NET_IF_H\n# include <net/if.h>\n#endif\n\n#if HAVE_LIBGCRYPT\n# include <pthread.h>\n# if defined __APPLE__\n/* default xcode compiler throws warnings even when deprecated functionality\n * is not used. -Werror breaks the build because of erroneous warnings.\n * http://stackoverflow.com/questions/10556299/compiler-warnings-with-libgcrypt-v1-5-0/12830209#12830209\n */\n#  pragma GCC diagnostic ignored \"-Wdeprecated-declarations\"\n# endif\n/* FreeBSD's copy of libgcrypt extends the existing GCRYPT_NO_DEPRECATED\n * to properly hide all deprecated functionality.\n * http://svnweb.freebsd.org/ports/head/security/libgcrypt/files/patch-src__gcrypt.h.in\n */\n# define GCRYPT_NO_DEPRECATED\n# include <gcrypt.h>\n# if defined __APPLE__\n/* Re enable deprecation warnings */\n#  pragma GCC diagnostic warning \"-Wdeprecated-declarations\"\n# endif\n# if GCRYPT_VERSION_NUMBER < 0x010600\nGCRY_THREAD_OPTION_PTHREAD_IMPL;\n# endif\n#endif\n\n#ifndef IPV6_ADD_MEMBERSHIP\n# ifdef IPV6_JOIN_GROUP\n#  define IPV6_ADD_MEMBERSHIP IPV6_JOIN_GROUP\n# else\n#  error \"Neither IP_ADD_MEMBERSHIP nor IPV6_JOIN_GROUP is defined\"\n# endif\n#endif /* !IP_ADD_MEMBERSHIP */\n\n/*\n * Maximum size required for encryption / signing:\n *\n *    42 bytes for the encryption header\n * +  64 bytes for the username\n * -----------\n * = 106 bytes\n */\n#define BUFF_SIG_SIZE 106\n\n/*\n * Private data types\n */\n#define SECURITY_LEVEL_NONE     0\n#if HAVE_LIBGCRYPT\n# define SECURITY_LEVEL_SIGN    1\n# define SECURITY_LEVEL_ENCRYPT 2\n#endif\nstruct sockent_client\n{\n\tint fd;\n\tstruct sockaddr_storage *addr;\n\tsocklen_t                addrlen;\n#if HAVE_LIBGCRYPT\n\tint security_level;\n\tchar *username;\n\tchar *password;\n\tgcry_cipher_hd_t cypher;\n\tunsigned char password_hash[32];\n#endif\n};\n\nstruct sockent_server\n{\n\tint *fd;\n\tsize_t fd_num;\n#if HAVE_LIBGCRYPT\n\tint security_level;\n\tchar *auth_file;\n\tfbhash_t *userdb;\n\tgcry_cipher_hd_t cypher;\n#endif\n};\n\ntypedef struct sockent\n{\n#define SOCKENT_TYPE_CLIENT 1\n#define SOCKENT_TYPE_SERVER 2\n\tint type;\n\n\tchar *node;\n\tchar *service;\n\tint interface;\n\n\tunion\n\t{\n\t\tstruct sockent_client client;\n\t\tstruct sockent_server server;\n\t} data;\n\n\tstruct sockent *next;\n} sockent_t;\n\n/*                      1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 3 3\n *  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n * +-------+-----------------------+-------------------------------+\n * ! Ver.  !                       ! Length                        !\n * +-------+-----------------------+-------------------------------+\n */\nstruct part_header_s\n{\n\tuint16_t type;\n\tuint16_t length;\n};\ntypedef struct part_header_s part_header_t;\n\n/*                      1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 3 3\n *  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n * +-------------------------------+-------------------------------+\n * ! Type                          ! Length                        !\n * +-------------------------------+-------------------------------+\n * : (Length - 4) Bytes                                            :\n * +---------------------------------------------------------------+\n */\nstruct part_string_s\n{\n\tpart_header_t *head;\n\tchar *value;\n};\ntypedef struct part_string_s part_string_t;\n\n/*                      1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 3 3\n *  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n * +-------------------------------+-------------------------------+\n * ! Type                          ! Length                        !\n * +-------------------------------+-------------------------------+\n * : (Length - 4 == 2 || 4 || 8) Bytes                             :\n * +---------------------------------------------------------------+\n */\nstruct part_number_s\n{\n\tpart_header_t *head;\n\tuint64_t *value;\n};\ntypedef struct part_number_s part_number_t;\n\n/*                      1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 3 3\n *  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n * +-------------------------------+-------------------------------+\n * ! Type                          ! Length                        !\n * +-------------------------------+---------------+---------------+\n * ! Num of values                 ! Type0         ! Type1         !\n * +-------------------------------+---------------+---------------+\n * ! Value0                                                        !\n * !                                                               !\n * +---------------------------------------------------------------+\n * ! Value1                                                        !\n * !                                                               !\n * +---------------------------------------------------------------+\n */\nstruct part_values_s\n{\n\tpart_header_t *head;\n\tuint16_t *num_values;\n\tuint8_t  *values_types;\n\tvalue_t  *values;\n};\ntypedef struct part_values_s part_values_t;\n\n/*                      1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 3 3\n *  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n * +-------------------------------+-------------------------------+\n * ! Type                          ! Length                        !\n * +-------------------------------+-------------------------------+\n * ! Hash (Bits   0 -  31)                                         !\n * : :                                                             :\n * ! Hash (Bits 224 - 255)                                         !\n * +---------------------------------------------------------------+\n */\n/* Minimum size */\n#define PART_SIGNATURE_SHA256_SIZE 36\nstruct part_signature_sha256_s\n{\n  part_header_t head;\n  unsigned char hash[32];\n  char *username;\n};\ntypedef struct part_signature_sha256_s part_signature_sha256_t;\n\n/*                      1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 3 3\n *  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n * +-------------------------------+-------------------------------+\n * ! Type                          ! Length                        !\n * +-------------------------------+-------------------------------+\n * ! Original length               ! Padding (0 - 15 bytes)        !\n * +-------------------------------+-------------------------------+\n * ! Hash (Bits   0 -  31)                                         !\n * : :                                                             :\n * ! Hash (Bits 128 - 159)                                         !\n * +---------------------------------------------------------------+\n */\n/* Minimum size */\n#define PART_ENCRYPTION_AES256_SIZE 42\nstruct part_encryption_aes256_s\n{\n  part_header_t head;\n  uint16_t username_length;\n  char *username;\n  unsigned char iv[16];\n  /* <encrypted> */\n  unsigned char hash[20];\n  /*   <payload /> */\n  /* </encrypted> */\n};\ntypedef struct part_encryption_aes256_s part_encryption_aes256_t;\n\nstruct receive_list_entry_s\n{\n  char *data;\n  int  data_len;\n  int  fd;\n  struct receive_list_entry_s *next;\n};\ntypedef struct receive_list_entry_s receive_list_entry_t;\n\n/*\n * Private variables\n */\nstatic int network_config_ttl = 0;\n/* Ethernet - (IPv6 + UDP) = 1500 - (40 + 8) = 1452 */\nstatic size_t network_config_packet_size = 1452;\nstatic int network_config_forward = 0;\nstatic int network_config_stats = 0;\n\nstatic sockent_t *sending_sockets = NULL;\n\nstatic receive_list_entry_t *receive_list_head = NULL;\nstatic receive_list_entry_t *receive_list_tail = NULL;\nstatic pthread_mutex_t       receive_list_lock = PTHREAD_MUTEX_INITIALIZER;\nstatic pthread_cond_t        receive_list_cond = PTHREAD_COND_INITIALIZER;\nstatic uint64_t              receive_list_length = 0;\n\nstatic sockent_t     *listen_sockets = NULL;\nstatic struct pollfd *listen_sockets_pollfd = NULL;\nstatic size_t         listen_sockets_num = 0;\n\n/* The receive and dispatch threads will run as long as `listen_loop' is set to\n * zero. */\nstatic int       listen_loop = 0;\nstatic int       receive_thread_running = 0;\nstatic pthread_t receive_thread_id;\nstatic int       dispatch_thread_running = 0;\nstatic pthread_t dispatch_thread_id;\n\n/* Buffer in which to-be-sent network packets are constructed. */\nstatic char            *send_buffer;\nstatic char            *send_buffer_ptr;\nstatic int              send_buffer_fill;\nstatic value_list_t     send_buffer_vl = VALUE_LIST_STATIC;\nstatic pthread_mutex_t  send_buffer_lock = PTHREAD_MUTEX_INITIALIZER;\n\n/* XXX: These counters are incremented from one place only. The spot in which\n * the values are incremented is either only reachable by one thread (the\n * dispatch thread, for example) or locked by some lock (send_buffer_lock for\n * example). Only if neither is true, the stats_lock is acquired. The counters\n * are always read without holding a lock in the hope that writing 8 bytes to\n * memory is an atomic operation. */\nstatic derive_t stats_octets_rx  = 0;\nstatic derive_t stats_octets_tx  = 0;\nstatic derive_t stats_packets_rx = 0;\nstatic derive_t stats_packets_tx = 0;\nstatic derive_t stats_values_dispatched = 0;\nstatic derive_t stats_values_not_dispatched = 0;\nstatic derive_t stats_values_sent = 0;\nstatic derive_t stats_values_not_sent = 0;\nstatic pthread_mutex_t stats_lock = PTHREAD_MUTEX_INITIALIZER;\n\n/*\n * Private functions\n */\nstatic _Bool check_receive_okay (const value_list_t *vl) /* {{{ */\n{\n  uint64_t time_sent = 0;\n  int status;\n\n  status = uc_meta_data_get_unsigned_int (vl,\n      \"network:time_sent\", &time_sent);\n\n  /* This is a value we already sent. Don't allow it to be received again in\n   * order to avoid looping. */\n  if ((status == 0) && (time_sent >= ((uint64_t) vl->time)))\n    return (0);\n\n  return (1);\n} /* }}} _Bool check_receive_okay */\n\nstatic _Bool check_send_okay (const value_list_t *vl) /* {{{ */\n{\n  _Bool received = 0;\n  int status;\n\n  if (network_config_forward != 0)\n    return (1);\n\n  if (vl->meta == NULL)\n    return (1);\n\n  status = meta_data_get_boolean (vl->meta, \"network:received\", &received);\n  if (status == -ENOENT)\n    return (1);\n  else if (status != 0)\n  {\n    ERROR (\"network plugin: check_send_okay: meta_data_get_boolean failed \"\n\t\"with status %i.\", status);\n    return (1);\n  }\n\n  /* By default, only *send* value lists that were not *received* by the\n   * network plugin. */\n  return (!received);\n} /* }}} _Bool check_send_okay */\n\nstatic _Bool check_notify_received (const notification_t *n) /* {{{ */\n{\n  notification_meta_t *ptr;\n\n  for (ptr = n->meta; ptr != NULL; ptr = ptr->next)\n    if ((strcmp (\"network:received\", ptr->name) == 0)\n        && (ptr->type == NM_TYPE_BOOLEAN))\n      return ((_Bool) ptr->nm_value.nm_boolean);\n\n  return (0);\n} /* }}} _Bool check_notify_received */\n\nstatic _Bool check_send_notify_okay (const notification_t *n) /* {{{ */\n{\n  static c_complain_t complain_forwarding = C_COMPLAIN_INIT_STATIC;\n  _Bool received = 0;\n\n  if (n->meta == NULL)\n    return (1);\n\n  received = check_notify_received (n);\n\n  if (network_config_forward && received)\n  {\n    c_complain_once (LOG_ERR, &complain_forwarding,\n        \"network plugin: A notification has been received via the network \"\n        \"and forwarding is enabled. Forwarding of notifications is currently \"\n        \"not supported, because there is not loop-deteciton available. \"\n        \"Please contact the collectd mailing list if you need this \"\n        \"feature.\");\n  }\n\n  /* By default, only *send* value lists that were not *received* by the\n   * network plugin. */\n  return (!received);\n} /* }}} _Bool check_send_notify_okay */\n\nstatic int network_dispatch_values (value_list_t *vl, /* {{{ */\n    const char *username)\n{\n  int status;\n\n  if ((vl->time <= 0)\n      || (strlen (vl->host) <= 0)\n      || (strlen (vl->plugin) <= 0)\n      || (strlen (vl->type) <= 0))\n    return (-EINVAL);\n\n  if (!check_receive_okay (vl))\n  {\n#if COLLECT_DEBUG\n    char name[6*DATA_MAX_NAME_LEN];\n    FORMAT_VL (name, sizeof (name), vl);\n    name[sizeof (name) - 1] = 0;\n    DEBUG (\"network plugin: network_dispatch_values: \"\n\t\"NOT dispatching %s.\", name);\n#endif\n    stats_values_not_dispatched++;\n    return (0);\n  }\n\n  assert (vl->meta == NULL);\n\n  vl->meta = meta_data_create ();\n  if (vl->meta == NULL)\n  {\n    ERROR (\"network plugin: meta_data_create failed.\");\n    return (-ENOMEM);\n  }\n\n  status = meta_data_add_boolean (vl->meta, \"network:received\", 1);\n  if (status != 0)\n  {\n    ERROR (\"network plugin: meta_data_add_boolean failed.\");\n    meta_data_destroy (vl->meta);\n    vl->meta = NULL;\n    return (status);\n  }\n\n  if (username != NULL)\n  {\n    status = meta_data_add_string (vl->meta, \"network:username\", username);\n    if (status != 0)\n    {\n      ERROR (\"network plugin: meta_data_add_string failed.\");\n      meta_data_destroy (vl->meta);\n      vl->meta = NULL;\n      return (status);\n    }\n  }\n\n  plugin_dispatch_values (vl);\n  stats_values_dispatched++;\n\n  meta_data_destroy (vl->meta);\n  vl->meta = NULL;\n\n  return (0);\n} /* }}} int network_dispatch_values */\n\nstatic int network_dispatch_notification (notification_t *n) /* {{{ */\n{\n  int status;\n\n  assert (n->meta == NULL);\n\n  status = plugin_notification_meta_add_boolean (n, \"network:received\", 1);\n  if (status != 0)\n  {\n    ERROR (\"network plugin: plugin_notification_meta_add_boolean failed.\");\n    plugin_notification_meta_free (n->meta);\n    n->meta = NULL;\n    return (status);\n  }\n\n  status = plugin_dispatch_notification (n);\n\n  plugin_notification_meta_free (n->meta);\n  n->meta = NULL;\n\n  return (status);\n} /* }}} int network_dispatch_notification */\n\n#if HAVE_LIBGCRYPT\nstatic void network_init_gcrypt (void) /* {{{ */\n{\n  /* http://lists.gnupg.org/pipermail/gcrypt-devel/2003-August/000458.html\n   * Because you can't know in a library whether another library has\n   * already initialized the library */\n  if (gcry_control (GCRYCTL_ANY_INITIALIZATION_P))\n    return;\n\n /* http://www.gnupg.org/documentation/manuals/gcrypt/Multi_002dThreading.html\n  * To ensure thread-safety, it's important to set GCRYCTL_SET_THREAD_CBS\n  * *before* initalizing Libgcrypt with gcry_check_version(), which itself must\n  * be called before any other gcry_* function. GCRYCTL_ANY_INITIALIZATION_P\n  * above doesn't count, as it doesn't implicitly initalize Libgcrypt.\n  *\n  * tl;dr: keep all these gry_* statements in this exact order please. */\n# if GCRYPT_VERSION_NUMBER < 0x010600\n  gcry_control (GCRYCTL_SET_THREAD_CBS, &gcry_threads_pthread);\n# endif\n  gcry_check_version (NULL);\n  gcry_control (GCRYCTL_INIT_SECMEM, 32768);\n  gcry_control (GCRYCTL_INITIALIZATION_FINISHED);\n} /* }}} void network_init_gcrypt */\n\nstatic gcry_cipher_hd_t network_get_aes256_cypher (sockent_t *se, /* {{{ */\n    const void *iv, size_t iv_size, const char *username)\n{\n  gcry_error_t err;\n  gcry_cipher_hd_t *cyper_ptr;\n  unsigned char password_hash[32];\n\n  if (se->type == SOCKENT_TYPE_CLIENT)\n  {\n\t  cyper_ptr = &se->data.client.cypher;\n\t  memcpy (password_hash, se->data.client.password_hash,\n\t\t\t  sizeof (password_hash));\n  }\n  else\n  {\n\t  char *secret;\n\n\t  cyper_ptr = &se->data.server.cypher;\n\n\t  if (username == NULL)\n\t\t  return (NULL);\n\n\t  secret = fbh_get (se->data.server.userdb, username);\n\t  if (secret == NULL)\n\t\t  return (NULL);\n\n\t  gcry_md_hash_buffer (GCRY_MD_SHA256,\n\t\t\t  password_hash,\n\t\t\t  secret, strlen (secret));\n\n\t  sfree (secret);\n  }\n\n  if (*cyper_ptr == NULL)\n  {\n    err = gcry_cipher_open (cyper_ptr,\n        GCRY_CIPHER_AES256, GCRY_CIPHER_MODE_OFB, /* flags = */ 0);\n    if (err != 0)\n    {\n      ERROR (\"network plugin: gcry_cipher_open returned: %s\",\n          gcry_strerror (err));\n      *cyper_ptr = NULL;\n      return (NULL);\n    }\n  }\n  else\n  {\n    gcry_cipher_reset (*cyper_ptr);\n  }\n  assert (*cyper_ptr != NULL);\n\n  err = gcry_cipher_setkey (*cyper_ptr,\n      password_hash, sizeof (password_hash));\n  if (err != 0)\n  {\n    ERROR (\"network plugin: gcry_cipher_setkey returned: %s\",\n        gcry_strerror (err));\n    gcry_cipher_close (*cyper_ptr);\n    *cyper_ptr = NULL;\n    return (NULL);\n  }\n\n  err = gcry_cipher_setiv (*cyper_ptr, iv, iv_size);\n  if (err != 0)\n  {\n    ERROR (\"network plugin: gcry_cipher_setkey returned: %s\",\n        gcry_strerror (err));\n    gcry_cipher_close (*cyper_ptr);\n    *cyper_ptr = NULL;\n    return (NULL);\n  }\n\n  return (*cyper_ptr);\n} /* }}} int network_get_aes256_cypher */\n#endif /* HAVE_LIBGCRYPT */\n\nstatic int write_part_values (char **ret_buffer, int *ret_buffer_len,\n\t\tconst data_set_t *ds, const value_list_t *vl)\n{\n\tchar *packet_ptr;\n\tint packet_len;\n\tint num_values;\n\n\tpart_header_t pkg_ph;\n\tuint16_t      pkg_num_values;\n\tuint8_t      *pkg_values_types;\n\tvalue_t      *pkg_values;\n\n\tint offset;\n\tint i;\n\n\tnum_values = vl->values_len;\n\tpacket_len = sizeof (part_header_t) + sizeof (uint16_t)\n\t\t+ (num_values * sizeof (uint8_t))\n\t\t+ (num_values * sizeof (value_t));\n\n\tif (*ret_buffer_len < packet_len)\n\t\treturn (-1);\n\n\tpkg_values_types = (uint8_t *) malloc (num_values * sizeof (uint8_t));\n\tif (pkg_values_types == NULL)\n\t{\n\t\tERROR (\"network plugin: write_part_values: malloc failed.\");\n\t\treturn (-1);\n\t}\n\n\tpkg_values = (value_t *) malloc (num_values * sizeof (value_t));\n\tif (pkg_values == NULL)\n\t{\n\t\tfree (pkg_values_types);\n\t\tERROR (\"network plugin: write_part_values: malloc failed.\");\n\t\treturn (-1);\n\t}\n\n\tpkg_ph.type = htons (TYPE_VALUES);\n\tpkg_ph.length = htons (packet_len);\n\n\tpkg_num_values = htons ((uint16_t) vl->values_len);\n\n\tfor (i = 0; i < num_values; i++)\n\t{\n\t\tpkg_values_types[i] = (uint8_t) ds->ds[i].type;\n\t\tswitch (ds->ds[i].type)\n\t\t{\n\t\t\tcase DS_TYPE_COUNTER:\n\t\t\t\tpkg_values[i].counter = htonll (vl->values[i].counter);\n\t\t\t\tbreak;\n\n\t\t\tcase DS_TYPE_GAUGE:\n\t\t\t\tpkg_values[i].gauge = htond (vl->values[i].gauge);\n\t\t\t\tbreak;\n\n\t\t\tcase DS_TYPE_DERIVE:\n\t\t\t\tpkg_values[i].derive = htonll (vl->values[i].derive);\n\t\t\t\tbreak;\n\n\t\t\tcase DS_TYPE_ABSOLUTE:\n\t\t\t\tpkg_values[i].absolute = htonll (vl->values[i].absolute);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tfree (pkg_values_types);\n\t\t\t\tfree (pkg_values);\n\t\t\t\tERROR (\"network plugin: write_part_values: \"\n\t\t\t\t\t\t\"Unknown data source type: %i\",\n\t\t\t\t\t\tds->ds[i].type);\n\t\t\t\treturn (-1);\n\t\t} /* switch (ds->ds[i].type) */\n\t} /* for (num_values) */\n\n\t/*\n\t * Use `memcpy' to write everything to the buffer, because the pointer\n\t * may be unaligned and some architectures, such as SPARC, can't handle\n\t * that.\n\t */\n\tpacket_ptr = *ret_buffer;\n\toffset = 0;\n\tmemcpy (packet_ptr + offset, &pkg_ph, sizeof (pkg_ph));\n\toffset += sizeof (pkg_ph);\n\tmemcpy (packet_ptr + offset, &pkg_num_values, sizeof (pkg_num_values));\n\toffset += sizeof (pkg_num_values);\n\tmemcpy (packet_ptr + offset, pkg_values_types, num_values * sizeof (uint8_t));\n\toffset += num_values * sizeof (uint8_t);\n\tmemcpy (packet_ptr + offset, pkg_values, num_values * sizeof (value_t));\n\toffset += num_values * sizeof (value_t);\n\n\tassert (offset == packet_len);\n\n\t*ret_buffer = packet_ptr + packet_len;\n\t*ret_buffer_len -= packet_len;\n\n\tfree (pkg_values_types);\n\tfree (pkg_values);\n\n\treturn (0);\n} /* int write_part_values */\n\nstatic int write_part_number (char **ret_buffer, int *ret_buffer_len,\n\t\tint type, uint64_t value)\n{\n\tchar *packet_ptr;\n\tint packet_len;\n\n\tpart_header_t pkg_head;\n\tuint64_t pkg_value;\n\n\tint offset;\n\n\tpacket_len = sizeof (pkg_head) + sizeof (pkg_value);\n\n\tif (*ret_buffer_len < packet_len)\n\t\treturn (-1);\n\n\tpkg_head.type = htons (type);\n\tpkg_head.length = htons (packet_len);\n\tpkg_value = htonll (value);\n\n\tpacket_ptr = *ret_buffer;\n\toffset = 0;\n\tmemcpy (packet_ptr + offset, &pkg_head, sizeof (pkg_head));\n\toffset += sizeof (pkg_head);\n\tmemcpy (packet_ptr + offset, &pkg_value, sizeof (pkg_value));\n\toffset += sizeof (pkg_value);\n\n\tassert (offset == packet_len);\n\n\t*ret_buffer = packet_ptr + packet_len;\n\t*ret_buffer_len -= packet_len;\n\n\treturn (0);\n} /* int write_part_number */\n\nstatic int write_part_string (char **ret_buffer, int *ret_buffer_len,\n\t\tint type, const char *str, int str_len)\n{\n\tchar *buffer;\n\tint buffer_len;\n\n\tuint16_t pkg_type;\n\tuint16_t pkg_length;\n\n\tint offset;\n\n\tbuffer_len = 2 * sizeof (uint16_t) + str_len + 1;\n\tif (*ret_buffer_len < buffer_len)\n\t\treturn (-1);\n\n\tpkg_type = htons (type);\n\tpkg_length = htons (buffer_len);\n\n\tbuffer = *ret_buffer;\n\toffset = 0;\n\tmemcpy (buffer + offset, (void *) &pkg_type, sizeof (pkg_type));\n\toffset += sizeof (pkg_type);\n\tmemcpy (buffer + offset, (void *) &pkg_length, sizeof (pkg_length));\n\toffset += sizeof (pkg_length);\n\tmemcpy (buffer + offset, str, str_len);\n\toffset += str_len;\n\tmemset (buffer + offset, '\\0', 1);\n\toffset += 1;\n\n\tassert (offset == buffer_len);\n\n\t*ret_buffer = buffer + buffer_len;\n\t*ret_buffer_len -= buffer_len;\n\n\treturn (0);\n} /* int write_part_string */\n\nstatic int parse_part_values (void **ret_buffer, size_t *ret_buffer_len,\n\t\tvalue_t **ret_values, int *ret_num_values)\n{\n\tchar *buffer = *ret_buffer;\n\tsize_t buffer_len = *ret_buffer_len;\n\n\tuint16_t tmp16;\n\tsize_t exp_size;\n\tint   i;\n\n\tuint16_t pkg_length;\n\tuint16_t pkg_type;\n\tuint16_t pkg_numval;\n\n\tuint8_t *pkg_types;\n\tvalue_t *pkg_values;\n\n\tif (buffer_len < 15)\n\t{\n\t\tNOTICE (\"network plugin: packet is too short: \"\n\t\t\t\t\"buffer_len = %zu\", buffer_len);\n\t\treturn (-1);\n\t}\n\n\tmemcpy ((void *) &tmp16, buffer, sizeof (tmp16));\n\tbuffer += sizeof (tmp16);\n\tpkg_type = ntohs (tmp16);\n\n\tmemcpy ((void *) &tmp16, buffer, sizeof (tmp16));\n\tbuffer += sizeof (tmp16);\n\tpkg_length = ntohs (tmp16);\n\n\tmemcpy ((void *) &tmp16, buffer, sizeof (tmp16));\n\tbuffer += sizeof (tmp16);\n\tpkg_numval = ntohs (tmp16);\n\n\tassert (pkg_type == TYPE_VALUES);\n\n\texp_size = 3 * sizeof (uint16_t)\n\t\t+ pkg_numval * (sizeof (uint8_t) + sizeof (value_t));\n\tif (buffer_len < exp_size)\n\t{\n\t\tWARNING (\"network plugin: parse_part_values: \"\n\t\t\t\t\"Packet too short: \"\n\t\t\t\t\"Chunk of size %zu expected, \"\n\t\t\t\t\"but buffer has only %zu bytes left.\",\n\t\t\t\texp_size, buffer_len);\n\t\treturn (-1);\n\t}\n\n\tif (pkg_length != exp_size)\n\t{\n\t\tWARNING (\"network plugin: parse_part_values: \"\n\t\t\t\t\"Length and number of values \"\n\t\t\t\t\"in the packet don't match.\");\n\t\treturn (-1);\n\t}\n\n\tpkg_types = (uint8_t *) malloc (pkg_numval * sizeof (uint8_t));\n\tpkg_values = (value_t *) malloc (pkg_numval * sizeof (value_t));\n\tif ((pkg_types == NULL) || (pkg_values == NULL))\n\t{\n\t\tsfree (pkg_types);\n\t\tsfree (pkg_values);\n\t\tERROR (\"network plugin: parse_part_values: malloc failed.\");\n\t\treturn (-1);\n\t}\n\n\tmemcpy ((void *) pkg_types, (void *) buffer, pkg_numval * sizeof (uint8_t));\n\tbuffer += pkg_numval * sizeof (uint8_t);\n\tmemcpy ((void *) pkg_values, (void *) buffer, pkg_numval * sizeof (value_t));\n\tbuffer += pkg_numval * sizeof (value_t);\n\n\tfor (i = 0; i < pkg_numval; i++)\n\t{\n\t\tswitch (pkg_types[i])\n\t\t{\n\t\t  case DS_TYPE_COUNTER:\n\t\t    pkg_values[i].counter = (counter_t) ntohll (pkg_values[i].counter);\n\t\t    break;\n\n\t\t  case DS_TYPE_GAUGE:\n\t\t    pkg_values[i].gauge = (gauge_t) ntohd (pkg_values[i].gauge);\n\t\t    break;\n\n\t\t  case DS_TYPE_DERIVE:\n\t\t    pkg_values[i].derive = (derive_t) ntohll (pkg_values[i].derive);\n\t\t    break;\n\n\t\t  case DS_TYPE_ABSOLUTE:\n\t\t    pkg_values[i].absolute = (absolute_t) ntohll (pkg_values[i].absolute);\n\t\t    break;\n\n\t\t  default:\n\t\t    NOTICE (\"network plugin: parse_part_values: \"\n\t\t\t\"Don't know how to handle data source type %\"PRIu8,\n\t\t\tpkg_types[i]);\n\t\t    sfree (pkg_types);\n\t\t    sfree (pkg_values);\n\t\t    return (-1);\n\t\t} /* switch (pkg_types[i]) */\n\t}\n\n\t*ret_buffer     = buffer;\n\t*ret_buffer_len = buffer_len - pkg_length;\n\t*ret_num_values = pkg_numval;\n\t*ret_values     = pkg_values;\n\n\tsfree (pkg_types);\n\n\treturn (0);\n} /* int parse_part_values */\n\nstatic int parse_part_number (void **ret_buffer, size_t *ret_buffer_len,\n\t\tuint64_t *value)\n{\n\tchar *buffer = *ret_buffer;\n\tsize_t buffer_len = *ret_buffer_len;\n\n\tuint16_t tmp16;\n\tuint64_t tmp64;\n\tsize_t exp_size = 2 * sizeof (uint16_t) + sizeof (uint64_t);\n\n\tuint16_t pkg_length;\n\n\tif (buffer_len < exp_size)\n\t{\n\t\tWARNING (\"network plugin: parse_part_number: \"\n\t\t\t\t\"Packet too short: \"\n\t\t\t\t\"Chunk of size %zu expected, \"\n\t\t\t\t\"but buffer has only %zu bytes left.\",\n\t\t\t\texp_size, buffer_len);\n\t\treturn (-1);\n\t}\n\n\tmemcpy ((void *) &tmp16, buffer, sizeof (tmp16));\n\tbuffer += sizeof (tmp16);\n\t/* pkg_type = ntohs (tmp16); */\n\n\tmemcpy ((void *) &tmp16, buffer, sizeof (tmp16));\n\tbuffer += sizeof (tmp16);\n\tpkg_length = ntohs (tmp16);\n\n\tmemcpy ((void *) &tmp64, buffer, sizeof (tmp64));\n\tbuffer += sizeof (tmp64);\n\t*value = ntohll (tmp64);\n\n\t*ret_buffer = buffer;\n\t*ret_buffer_len = buffer_len - pkg_length;\n\n\treturn (0);\n} /* int parse_part_number */\n\nstatic int parse_part_string (void **ret_buffer, size_t *ret_buffer_len,\n\t\tchar *output, int output_len)\n{\n\tchar *buffer = *ret_buffer;\n\tsize_t buffer_len = *ret_buffer_len;\n\n\tuint16_t tmp16;\n\tsize_t header_size = 2 * sizeof (uint16_t);\n\n\tuint16_t pkg_length;\n\n\tif (buffer_len < header_size)\n\t{\n\t\tWARNING (\"network plugin: parse_part_string: \"\n\t\t\t\t\"Packet too short: \"\n\t\t\t\t\"Chunk of at least size %zu expected, \"\n\t\t\t\t\"but buffer has only %zu bytes left.\",\n\t\t\t\theader_size, buffer_len);\n\t\treturn (-1);\n\t}\n\n\tmemcpy ((void *) &tmp16, buffer, sizeof (tmp16));\n\tbuffer += sizeof (tmp16);\n\t/* pkg_type = ntohs (tmp16); */\n\n\tmemcpy ((void *) &tmp16, buffer, sizeof (tmp16));\n\tbuffer += sizeof (tmp16);\n\tpkg_length = ntohs (tmp16);\n\n\t/* Check that packet fits in the input buffer */\n\tif (pkg_length > buffer_len)\n\t{\n\t\tWARNING (\"network plugin: parse_part_string: \"\n\t\t\t\t\"Packet too big: \"\n\t\t\t\t\"Chunk of size %\"PRIu16\" received, \"\n\t\t\t\t\"but buffer has only %zu bytes left.\",\n\t\t\t\tpkg_length, buffer_len);\n\t\treturn (-1);\n\t}\n\n\t/* Check that pkg_length is in the valid range */\n\tif (pkg_length <= header_size)\n\t{\n\t\tWARNING (\"network plugin: parse_part_string: \"\n\t\t\t\t\"Packet too short: \"\n\t\t\t\t\"Header claims this packet is only %hu \"\n\t\t\t\t\"bytes long.\", pkg_length);\n\t\treturn (-1);\n\t}\n\n\t/* Check that the package data fits into the output buffer.\n\t * The previous if-statement ensures that:\n\t * `pkg_length > header_size' */\n\tif ((output_len < 0)\n\t\t\t|| ((size_t) output_len < ((size_t) pkg_length - header_size)))\n\t{\n\t\tWARNING (\"network plugin: parse_part_string: \"\n\t\t\t\t\"Output buffer too small.\");\n\t\treturn (-1);\n\t}\n\n\t/* All sanity checks successfull, let's copy the data over */\n\toutput_len = pkg_length - header_size;\n\tmemcpy ((void *) output, (void *) buffer, output_len);\n\tbuffer += output_len;\n\n\t/* For some very weird reason '\\0' doesn't do the trick on SPARC in\n\t * this statement. */\n\tif (output[output_len - 1] != 0)\n\t{\n\t\tWARNING (\"network plugin: parse_part_string: \"\n\t\t\t\t\"Received string does not end \"\n\t\t\t\t\"with a NULL-byte.\");\n\t\treturn (-1);\n\t}\n\n\t*ret_buffer = buffer;\n\t*ret_buffer_len = buffer_len - pkg_length;\n\n\treturn (0);\n} /* int parse_part_string */\n\n/* Forward declaration: parse_part_sign_sha256 and parse_part_encr_aes256 call\n * parse_packet and vice versa. */\n#define PP_SIGNED    0x01\n#define PP_ENCRYPTED 0x02\nstatic int parse_packet (sockent_t *se,\n\t\tvoid *buffer, size_t buffer_size, int flags,\n\t\tconst char *username);\n\n#define BUFFER_READ(p,s) do { \\\n  memcpy ((p), buffer + buffer_offset, (s)); \\\n  buffer_offset += (s); \\\n} while (0)\n\n#if HAVE_LIBGCRYPT\nstatic int parse_part_sign_sha256 (sockent_t *se, /* {{{ */\n    void **ret_buffer, size_t *ret_buffer_len, int flags)\n{\n  static c_complain_t complain_no_users = C_COMPLAIN_INIT_STATIC;\n\n  char *buffer;\n  size_t buffer_len;\n  size_t buffer_offset;\n\n  size_t username_len;\n  char *secret;\n\n  part_signature_sha256_t pss;\n  uint16_t pss_head_length;\n  char hash[sizeof (pss.hash)];\n\n  gcry_md_hd_t hd;\n  gcry_error_t err;\n  unsigned char *hash_ptr;\n\n  buffer = *ret_buffer;\n  buffer_len = *ret_buffer_len;\n  buffer_offset = 0;\n\n  if (se->data.server.userdb == NULL)\n  {\n    c_complain (LOG_NOTICE, &complain_no_users,\n        \"network plugin: Received signed network packet but can't verify it \"\n        \"because no user DB has been configured. Will accept it.\");\n    return (0);\n  }\n\n  /* Check if the buffer has enough data for this structure. */\n  if (buffer_len <= PART_SIGNATURE_SHA256_SIZE)\n    return (-ENOMEM);\n\n  /* Read type and length header */\n  BUFFER_READ (&pss.head.type, sizeof (pss.head.type));\n  BUFFER_READ (&pss.head.length, sizeof (pss.head.length));\n  pss_head_length = ntohs (pss.head.length);\n\n  /* Check if the `pss_head_length' is within bounds. */\n  if ((pss_head_length <= PART_SIGNATURE_SHA256_SIZE)\n      || (pss_head_length > buffer_len))\n  {\n    ERROR (\"network plugin: HMAC-SHA-256 with invalid length received.\");\n    return (-1);\n  }\n\n  /* Copy the hash. */\n  BUFFER_READ (pss.hash, sizeof (pss.hash));\n\n  /* Calculate username length (without null byte) and allocate memory */\n  username_len = pss_head_length - PART_SIGNATURE_SHA256_SIZE;\n  pss.username = malloc (username_len + 1);\n  if (pss.username == NULL)\n    return (-ENOMEM);\n\n  /* Read the username */\n  BUFFER_READ (pss.username, username_len);\n  pss.username[username_len] = 0;\n\n  assert (buffer_offset == pss_head_length);\n\n  /* Query the password */\n  secret = fbh_get (se->data.server.userdb, pss.username);\n  if (secret == NULL)\n  {\n    ERROR (\"network plugin: Unknown user: %s\", pss.username);\n    sfree (pss.username);\n    return (-ENOENT);\n  }\n\n  /* Create a hash device and check the HMAC */\n  hd = NULL;\n  err = gcry_md_open (&hd, GCRY_MD_SHA256, GCRY_MD_FLAG_HMAC);\n  if (err != 0)\n  {\n    ERROR (\"network plugin: Creating HMAC-SHA-256 object failed: %s\",\n        gcry_strerror (err));\n    sfree (secret);\n    sfree (pss.username);\n    return (-1);\n  }\n\n  err = gcry_md_setkey (hd, secret, strlen (secret));\n  if (err != 0)\n  {\n    ERROR (\"network plugin: gcry_md_setkey failed: %s\", gcry_strerror (err));\n    gcry_md_close (hd);\n    sfree (secret);\n    sfree (pss.username);\n    return (-1);\n  }\n\n  gcry_md_write (hd,\n      buffer     + PART_SIGNATURE_SHA256_SIZE,\n      buffer_len - PART_SIGNATURE_SHA256_SIZE);\n  hash_ptr = gcry_md_read (hd, GCRY_MD_SHA256);\n  if (hash_ptr == NULL)\n  {\n    ERROR (\"network plugin: gcry_md_read failed.\");\n    gcry_md_close (hd);\n    sfree (secret);\n    sfree (pss.username);\n    return (-1);\n  }\n  memcpy (hash, hash_ptr, sizeof (hash));\n\n  /* Clean up */\n  gcry_md_close (hd);\n  hd = NULL;\n\n  if (memcmp (pss.hash, hash, sizeof (pss.hash)) != 0)\n  {\n    WARNING (\"network plugin: Verifying HMAC-SHA-256 signature failed: \"\n        \"Hash mismatch.\");\n  }\n  else\n  {\n    parse_packet (se, buffer + buffer_offset, buffer_len - buffer_offset,\n        flags | PP_SIGNED, pss.username);\n  }\n\n  sfree (secret);\n  sfree (pss.username);\n\n  *ret_buffer = buffer + buffer_len;\n  *ret_buffer_len = 0;\n\n  return (0);\n} /* }}} int parse_part_sign_sha256 */\n/* #endif HAVE_LIBGCRYPT */\n\n#else /* if !HAVE_LIBGCRYPT */\nstatic int parse_part_sign_sha256 (sockent_t *se, /* {{{ */\n    void **ret_buffer, size_t *ret_buffer_size, int flags)\n{\n  static int warning_has_been_printed = 0;\n\n  char *buffer;\n  size_t buffer_size;\n  size_t buffer_offset;\n  uint16_t part_len;\n\n  part_signature_sha256_t pss;\n\n  buffer = *ret_buffer;\n  buffer_size = *ret_buffer_size;\n  buffer_offset = 0;\n\n  if (buffer_size <= PART_SIGNATURE_SHA256_SIZE)\n    return (-ENOMEM);\n\n  BUFFER_READ (&pss.head.type, sizeof (pss.head.type));\n  BUFFER_READ (&pss.head.length, sizeof (pss.head.length));\n  part_len = ntohs (pss.head.length);\n\n  if ((part_len <= PART_SIGNATURE_SHA256_SIZE)\n      || (part_len > buffer_size))\n    return (-EINVAL);\n\n  if (warning_has_been_printed == 0)\n  {\n    WARNING (\"network plugin: Received signed packet, but the network \"\n        \"plugin was not linked with libgcrypt, so I cannot \"\n        \"verify the signature. The packet will be accepted.\");\n    warning_has_been_printed = 1;\n  }\n\n  parse_packet (se, buffer + part_len, buffer_size - part_len, flags,\n      /* username = */ NULL);\n\n  *ret_buffer = buffer + buffer_size;\n  *ret_buffer_size = 0;\n\n  return (0);\n} /* }}} int parse_part_sign_sha256 */\n#endif /* !HAVE_LIBGCRYPT */\n\n#if HAVE_LIBGCRYPT\nstatic int parse_part_encr_aes256 (sockent_t *se, /* {{{ */\n\t\tvoid **ret_buffer, size_t *ret_buffer_len,\n\t\tint flags)\n{\n  char  *buffer = *ret_buffer;\n  size_t buffer_len = *ret_buffer_len;\n  size_t payload_len;\n  size_t part_size;\n  size_t buffer_offset;\n  uint16_t username_len;\n  part_encryption_aes256_t pea;\n  unsigned char hash[sizeof (pea.hash)];\n\n  gcry_cipher_hd_t cypher;\n  gcry_error_t err;\n\n  /* Make sure at least the header if available. */\n  if (buffer_len <= PART_ENCRYPTION_AES256_SIZE)\n  {\n    NOTICE (\"network plugin: parse_part_encr_aes256: \"\n        \"Discarding short packet.\");\n    return (-1);\n  }\n\n  buffer_offset = 0;\n\n  /* Copy the unencrypted information into `pea'. */\n  BUFFER_READ (&pea.head.type, sizeof (pea.head.type));\n  BUFFER_READ (&pea.head.length, sizeof (pea.head.length));\n\n  /* Check the `part size'. */\n  part_size = ntohs (pea.head.length);\n  if ((part_size <= PART_ENCRYPTION_AES256_SIZE)\n      || (part_size > buffer_len))\n  {\n    NOTICE (\"network plugin: parse_part_encr_aes256: \"\n        \"Discarding part with invalid size.\");\n    return (-1);\n  }\n\n  /* Read the username */\n  BUFFER_READ (&username_len, sizeof (username_len));\n  username_len = ntohs (username_len);\n\n  if ((username_len <= 0)\n      || (username_len > (part_size - (PART_ENCRYPTION_AES256_SIZE + 1))))\n  {\n    NOTICE (\"network plugin: parse_part_encr_aes256: \"\n        \"Discarding part with invalid username length.\");\n    return (-1);\n  }\n\n  assert (username_len > 0);\n  pea.username = malloc (username_len + 1);\n  if (pea.username == NULL)\n    return (-ENOMEM);\n  BUFFER_READ (pea.username, username_len);\n  pea.username[username_len] = 0;\n\n  /* Last but not least, the initialization vector */\n  BUFFER_READ (pea.iv, sizeof (pea.iv));\n\n  /* Make sure we are at the right position */\n  assert (buffer_offset == (username_len +\n        PART_ENCRYPTION_AES256_SIZE - sizeof (pea.hash)));\n\n  cypher = network_get_aes256_cypher (se, pea.iv, sizeof (pea.iv),\n      pea.username);\n  if (cypher == NULL)\n  {\n    sfree (pea.username);\n    return (-1);\n  }\n\n  payload_len = part_size - (PART_ENCRYPTION_AES256_SIZE + username_len);\n  assert (payload_len > 0);\n\n  /* Decrypt the packet in-place */\n  err = gcry_cipher_decrypt (cypher,\n      buffer    + buffer_offset,\n      part_size - buffer_offset,\n      /* in = */ NULL, /* in len = */ 0);\n  if (err != 0)\n  {\n    sfree (pea.username);\n    ERROR (\"network plugin: gcry_cipher_decrypt returned: %s\",\n        gcry_strerror (err));\n    return (-1);\n  }\n\n  /* Read the hash */\n  BUFFER_READ (pea.hash, sizeof (pea.hash));\n\n  /* Make sure we're at the right position - again */\n  assert (buffer_offset == (username_len + PART_ENCRYPTION_AES256_SIZE));\n  assert (buffer_offset == (part_size - payload_len));\n\n  /* Check hash sum */\n  memset (hash, 0, sizeof (hash));\n  gcry_md_hash_buffer (GCRY_MD_SHA1, hash,\n      buffer + buffer_offset, payload_len);\n  if (memcmp (hash, pea.hash, sizeof (hash)) != 0)\n  {\n    sfree (pea.username);\n    ERROR (\"network plugin: Decryption failed: Checksum mismatch.\");\n    return (-1);\n  }\n\n  parse_packet (se, buffer + buffer_offset, payload_len,\n      flags | PP_ENCRYPTED, pea.username);\n\n  /* XXX: Free pea.username?!? */\n\n  /* Update return values */\n  *ret_buffer =     buffer     + part_size;\n  *ret_buffer_len = buffer_len - part_size;\n\n  sfree (pea.username);\n\n  return (0);\n} /* }}} int parse_part_encr_aes256 */\n/* #endif HAVE_LIBGCRYPT */\n\n#else /* if !HAVE_LIBGCRYPT */\nstatic int parse_part_encr_aes256 (sockent_t *se, /* {{{ */\n    void **ret_buffer, size_t *ret_buffer_size, int flags)\n{\n  static int warning_has_been_printed = 0;\n\n  char *buffer;\n  size_t buffer_size;\n  size_t buffer_offset;\n\n  part_header_t ph;\n  size_t ph_length;\n\n  buffer = *ret_buffer;\n  buffer_size = *ret_buffer_size;\n  buffer_offset = 0;\n\n  /* parse_packet assures this minimum size. */\n  assert (buffer_size >= (sizeof (ph.type) + sizeof (ph.length)));\n\n  BUFFER_READ (&ph.type, sizeof (ph.type));\n  BUFFER_READ (&ph.length, sizeof (ph.length));\n  ph_length = ntohs (ph.length);\n\n  if ((ph_length <= PART_ENCRYPTION_AES256_SIZE)\n      || (ph_length > buffer_size))\n  {\n    ERROR (\"network plugin: AES-256 encrypted part \"\n        \"with invalid length received.\");\n    return (-1);\n  }\n\n  if (warning_has_been_printed == 0)\n  {\n    WARNING (\"network plugin: Received encrypted packet, but the network \"\n        \"plugin was not linked with libgcrypt, so I cannot \"\n        \"decrypt it. The part will be discarded.\");\n    warning_has_been_printed = 1;\n  }\n\n  *ret_buffer += ph_length;\n  *ret_buffer_size -= ph_length;\n\n  return (0);\n} /* }}} int parse_part_encr_aes256 */\n#endif /* !HAVE_LIBGCRYPT */\n\n#undef BUFFER_READ\n\nstatic int parse_packet (sockent_t *se, /* {{{ */\n\t\tvoid *buffer, size_t buffer_size, int flags,\n\t\tconst char *username)\n{\n\tint status;\n\n\tvalue_list_t vl = VALUE_LIST_INIT;\n\tnotification_t n;\n\n#if HAVE_LIBGCRYPT\n\tint packet_was_signed = (flags & PP_SIGNED);\n        int packet_was_encrypted = (flags & PP_ENCRYPTED);\n\tint printed_ignore_warning = 0;\n#endif /* HAVE_LIBGCRYPT */\n\n\n\tmemset (&vl, '\\0', sizeof (vl));\n\tmemset (&n, '\\0', sizeof (n));\n\tstatus = 0;\n\n\twhile ((status == 0) && (0 < buffer_size)\n\t\t\t&& ((unsigned int) buffer_size > sizeof (part_header_t)))\n\t{\n\t\tuint16_t pkg_length;\n\t\tuint16_t pkg_type;\n\n\t\tmemcpy ((void *) &pkg_type,\n\t\t\t\t(void *) buffer,\n\t\t\t\tsizeof (pkg_type));\n\t\tmemcpy ((void *) &pkg_length,\n\t\t\t\t(void *) (buffer + sizeof (pkg_type)),\n\t\t\t\tsizeof (pkg_length));\n\n\t\tpkg_length = ntohs (pkg_length);\n\t\tpkg_type = ntohs (pkg_type);\n\n\t\tif (pkg_length > buffer_size)\n\t\t\tbreak;\n\t\t/* Ensure that this loop terminates eventually */\n\t\tif (pkg_length < (2 * sizeof (uint16_t)))\n\t\t\tbreak;\n\n\t\tif (pkg_type == TYPE_ENCR_AES256)\n\t\t{\n\t\t\tstatus = parse_part_encr_aes256 (se,\n\t\t\t\t\t&buffer, &buffer_size, flags);\n\t\t\tif (status != 0)\n\t\t\t{\n\t\t\t\tERROR (\"network plugin: Decrypting AES256 \"\n\t\t\t\t\t\t\"part failed \"\n\t\t\t\t\t\t\"with status %i.\", status);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n#if HAVE_LIBGCRYPT\n\t\telse if ((se->data.server.security_level == SECURITY_LEVEL_ENCRYPT)\n\t\t\t\t&& (packet_was_encrypted == 0))\n\t\t{\n\t\t\tif (printed_ignore_warning == 0)\n\t\t\t{\n\t\t\t\tINFO (\"network plugin: Unencrypted packet or \"\n\t\t\t\t\t\t\"part has been ignored.\");\n\t\t\t\tprinted_ignore_warning = 1;\n\t\t\t}\n\t\t\tbuffer = ((char *) buffer) + pkg_length;\n\t\t\tbuffer_size -= (size_t) pkg_length;\n\t\t\tcontinue;\n\t\t}\n#endif /* HAVE_LIBGCRYPT */\n\t\telse if (pkg_type == TYPE_SIGN_SHA256)\n\t\t{\n\t\t\tstatus = parse_part_sign_sha256 (se,\n                                        &buffer, &buffer_size, flags);\n\t\t\tif (status != 0)\n\t\t\t{\n\t\t\t\tERROR (\"network plugin: Verifying HMAC-SHA-256 \"\n\t\t\t\t\t\t\"signature failed \"\n\t\t\t\t\t\t\"with status %i.\", status);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n#if HAVE_LIBGCRYPT\n\t\telse if ((se->data.server.security_level == SECURITY_LEVEL_SIGN)\n\t\t\t\t&& (packet_was_encrypted == 0)\n\t\t\t\t&& (packet_was_signed == 0))\n\t\t{\n\t\t\tif (printed_ignore_warning == 0)\n\t\t\t{\n\t\t\t\tINFO (\"network plugin: Unsigned packet or \"\n\t\t\t\t\t\t\"part has been ignored.\");\n\t\t\t\tprinted_ignore_warning = 1;\n\t\t\t}\n\t\t\tbuffer = ((char *) buffer) + pkg_length;\n\t\t\tbuffer_size -= (size_t) pkg_length;\n\t\t\tcontinue;\n\t\t}\n#endif /* HAVE_LIBGCRYPT */\n\t\telse if (pkg_type == TYPE_VALUES)\n\t\t{\n\t\t\tstatus = parse_part_values (&buffer, &buffer_size,\n\t\t\t\t\t&vl.values, &vl.values_len);\n\t\t\tif (status != 0)\n\t\t\t\tbreak;\n\n\t\t\tnetwork_dispatch_values (&vl, username);\n\n\t\t\tsfree (vl.values);\n\t\t}\n\t\telse if (pkg_type == TYPE_TIME)\n\t\t{\n\t\t\tuint64_t tmp = 0;\n\t\t\tstatus = parse_part_number (&buffer, &buffer_size,\n\t\t\t\t\t&tmp);\n\t\t\tif (status == 0)\n\t\t\t{\n\t\t\t\tvl.time = TIME_T_TO_CDTIME_T (tmp);\n\t\t\t\tn.time  = TIME_T_TO_CDTIME_T (tmp);\n\t\t\t}\n\t\t}\n\t\telse if (pkg_type == TYPE_TIME_HR)\n\t\t{\n\t\t\tuint64_t tmp = 0;\n\t\t\tstatus = parse_part_number (&buffer, &buffer_size,\n\t\t\t\t\t&tmp);\n\t\t\tif (status == 0)\n\t\t\t{\n\t\t\t\tvl.time = (cdtime_t) tmp;\n\t\t\t\tn.time  = (cdtime_t) tmp;\n\t\t\t}\n\t\t}\n\t\telse if (pkg_type == TYPE_INTERVAL)\n\t\t{\n\t\t\tuint64_t tmp = 0;\n\t\t\tstatus = parse_part_number (&buffer, &buffer_size,\n\t\t\t\t\t&tmp);\n\t\t\tif (status == 0)\n\t\t\t\tvl.interval = TIME_T_TO_CDTIME_T (tmp);\n\t\t}\n\t\telse if (pkg_type == TYPE_INTERVAL_HR)\n\t\t{\n\t\t\tuint64_t tmp = 0;\n\t\t\tstatus = parse_part_number (&buffer, &buffer_size,\n\t\t\t\t\t&tmp);\n\t\t\tif (status == 0)\n\t\t\t\tvl.interval = (cdtime_t) tmp;\n\t\t}\n\t\telse if (pkg_type == TYPE_HOST)\n\t\t{\n\t\t\tstatus = parse_part_string (&buffer, &buffer_size,\n\t\t\t\t\tvl.host, sizeof (vl.host));\n\t\t\tif (status == 0)\n\t\t\t\tsstrncpy (n.host, vl.host, sizeof (n.host));\n\t\t}\n\t\telse if (pkg_type == TYPE_PLUGIN)\n\t\t{\n\t\t\tstatus = parse_part_string (&buffer, &buffer_size,\n\t\t\t\t\tvl.plugin, sizeof (vl.plugin));\n\t\t\tif (status == 0)\n\t\t\t\tsstrncpy (n.plugin, vl.plugin,\n\t\t\t\t\t\tsizeof (n.plugin));\n\t\t}\n\t\telse if (pkg_type == TYPE_PLUGIN_INSTANCE)\n\t\t{\n\t\t\tstatus = parse_part_string (&buffer, &buffer_size,\n\t\t\t\t\tvl.plugin_instance,\n\t\t\t\t\tsizeof (vl.plugin_instance));\n\t\t\tif (status == 0)\n\t\t\t\tsstrncpy (n.plugin_instance,\n\t\t\t\t\t\tvl.plugin_instance,\n\t\t\t\t\t\tsizeof (n.plugin_instance));\n\t\t}\n\t\telse if (pkg_type == TYPE_TYPE)\n\t\t{\n\t\t\tstatus = parse_part_string (&buffer, &buffer_size,\n\t\t\t\t\tvl.type, sizeof (vl.type));\n\t\t\tif (status == 0)\n\t\t\t\tsstrncpy (n.type, vl.type, sizeof (n.type));\n\t\t}\n\t\telse if (pkg_type == TYPE_TYPE_INSTANCE)\n\t\t{\n\t\t\tstatus = parse_part_string (&buffer, &buffer_size,\n\t\t\t\t\tvl.type_instance,\n\t\t\t\t\tsizeof (vl.type_instance));\n\t\t\tif (status == 0)\n\t\t\t\tsstrncpy (n.type_instance, vl.type_instance,\n\t\t\t\t\t\tsizeof (n.type_instance));\n\t\t}\n\t\telse if (pkg_type == TYPE_MESSAGE)\n\t\t{\n\t\t\tstatus = parse_part_string (&buffer, &buffer_size,\n\t\t\t\t\tn.message, sizeof (n.message));\n\n\t\t\tif (status != 0)\n\t\t\t{\n\t\t\t\t/* do nothing */\n\t\t\t}\n\t\t\telse if ((n.severity != NOTIF_FAILURE)\n\t\t\t\t\t&& (n.severity != NOTIF_WARNING)\n\t\t\t\t\t&& (n.severity != NOTIF_OKAY))\n\t\t\t{\n\t\t\t\tINFO (\"network plugin: \"\n\t\t\t\t\t\t\"Ignoring notification with \"\n\t\t\t\t\t\t\"unknown severity %i.\",\n\t\t\t\t\t\tn.severity);\n\t\t\t}\n\t\t\telse if (n.time <= 0)\n\t\t\t{\n\t\t\t\tINFO (\"network plugin: \"\n\t\t\t\t\t\t\"Ignoring notification with \"\n\t\t\t\t\t\t\"time == 0.\");\n\t\t\t}\n\t\t\telse if (strlen (n.message) <= 0)\n\t\t\t{\n\t\t\t\tINFO (\"network plugin: \"\n\t\t\t\t\t\t\"Ignoring notification with \"\n\t\t\t\t\t\t\"an empty message.\");\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tnetwork_dispatch_notification (&n);\n\t\t\t}\n\t\t}\n\t\telse if (pkg_type == TYPE_SEVERITY)\n\t\t{\n\t\t\tuint64_t tmp = 0;\n\t\t\tstatus = parse_part_number (&buffer, &buffer_size,\n\t\t\t\t\t&tmp);\n\t\t\tif (status == 0)\n\t\t\t\tn.severity = (int) tmp;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tDEBUG (\"network plugin: parse_packet: Unknown part\"\n\t\t\t\t\t\" type: 0x%04hx\", pkg_type);\n\t\t\tbuffer = ((char *) buffer) + pkg_length;\n\t\t\tbuffer_size -= (size_t) pkg_length;\n\t\t}\n\t} /* while (buffer_size > sizeof (part_header_t)) */\n\n\tif (status == 0 && buffer_size > 0)\n\t\tWARNING (\"network plugin: parse_packet: Received truncated \"\n\t\t\t\t\"packet, try increasing `MaxPacketSize'\");\n\n\treturn (status);\n} /* }}} int parse_packet */\n\nstatic void free_sockent_client (struct sockent_client *sec) /* {{{ */\n{\n  if (sec->fd >= 0)\n  {\n    close (sec->fd);\n    sec->fd = -1;\n  }\n  sfree (sec->addr);\n#if HAVE_LIBGCRYPT\n  sfree (sec->username);\n  sfree (sec->password);\n  if (sec->cypher != NULL)\n    gcry_cipher_close (sec->cypher);\n#endif\n} /* }}} void free_sockent_client */\n\nstatic void free_sockent_server (struct sockent_server *ses) /* {{{ */\n{\n  size_t i;\n\n  for (i = 0; i < ses->fd_num; i++)\n  {\n    if (ses->fd[i] >= 0)\n    {\n      close (ses->fd[i]);\n      ses->fd[i] = -1;\n    }\n  }\n\n  sfree (ses->fd);\n#if HAVE_LIBGCRYPT\n  sfree (ses->auth_file);\n  fbh_destroy (ses->userdb);\n  if (ses->cypher != NULL)\n    gcry_cipher_close (ses->cypher);\n#endif\n} /* }}} void free_sockent_server */\n\nstatic void sockent_destroy (sockent_t *se) /* {{{ */\n{\n  sockent_t *next;\n\n  DEBUG (\"network plugin: sockent_destroy (se = %p);\", (void *) se);\n\n  while (se != NULL)\n  {\n    next = se->next;\n\n    sfree (se->node);\n    sfree (se->service);\n\n    if (se->type == SOCKENT_TYPE_CLIENT)\n      free_sockent_client (&se->data.client);\n    else\n      free_sockent_server (&se->data.server);\n\n    sfree (se);\n    se = next;\n  }\n} /* }}} void sockent_destroy */\n\n/*\n * int network_set_ttl\n *\n * Set the `IP_MULTICAST_TTL', `IP_TTL', `IPV6_MULTICAST_HOPS' or\n * `IPV6_UNICAST_HOPS', depending on which option is applicable.\n *\n * The `struct addrinfo' is used to destinguish between unicast and multicast\n * sockets.\n */\nstatic int network_set_ttl (const sockent_t *se, const struct addrinfo *ai)\n{\n\tDEBUG (\"network plugin: network_set_ttl: network_config_ttl = %i;\",\n\t\t\tnetwork_config_ttl);\n\n        assert (se->type == SOCKENT_TYPE_CLIENT);\n\n\tif ((network_config_ttl < 1) || (network_config_ttl > 255))\n\t\treturn (-1);\n\n\tif (ai->ai_family == AF_INET)\n\t{\n\t\tstruct sockaddr_in *addr = (struct sockaddr_in *) ai->ai_addr;\n\t\tint optname;\n\n\t\tif (IN_MULTICAST (ntohl (addr->sin_addr.s_addr)))\n\t\t\toptname = IP_MULTICAST_TTL;\n\t\telse\n\t\t\toptname = IP_TTL;\n\n\t\tif (setsockopt (se->data.client.fd, IPPROTO_IP, optname,\n\t\t\t\t\t&network_config_ttl,\n\t\t\t\t\tsizeof (network_config_ttl)) != 0)\n\t\t{\n\t\t\tchar errbuf[1024];\n\t\t\tERROR (\"network plugin: setsockopt (ipv4-ttl): %s\",\n\t\t\t\t\tsstrerror (errno, errbuf, sizeof (errbuf)));\n\t\t\treturn (-1);\n\t\t}\n\t}\n\telse if (ai->ai_family == AF_INET6)\n\t{\n\t\t/* Useful example: http://gsyc.escet.urjc.es/~eva/IPv6-web/examples/mcast.html */\n\t\tstruct sockaddr_in6 *addr = (struct sockaddr_in6 *) ai->ai_addr;\n\t\tint optname;\n\n\t\tif (IN6_IS_ADDR_MULTICAST (&addr->sin6_addr))\n\t\t\toptname = IPV6_MULTICAST_HOPS;\n\t\telse\n\t\t\toptname = IPV6_UNICAST_HOPS;\n\n\t\tif (setsockopt (se->data.client.fd, IPPROTO_IPV6, optname,\n\t\t\t\t\t&network_config_ttl,\n\t\t\t\t\tsizeof (network_config_ttl)) != 0)\n\t\t{\n\t\t\tchar errbuf[1024];\n\t\t\tERROR (\"network plugin: setsockopt(ipv6-ttl): %s\",\n\t\t\t\t\tsstrerror (errno, errbuf,\n\t\t\t\t\t\tsizeof (errbuf)));\n\t\t\treturn (-1);\n\t\t}\n\t}\n\n\treturn (0);\n} /* int network_set_ttl */\n\nstatic int network_set_interface (const sockent_t *se, const struct addrinfo *ai) /* {{{ */\n{\n\tDEBUG (\"network plugin: network_set_interface: interface index = %i;\",\n\t\t\tse->interface);\n\n        assert (se->type == SOCKENT_TYPE_CLIENT);\n\n\tif (ai->ai_family == AF_INET)\n\t{\n\t\tstruct sockaddr_in *addr = (struct sockaddr_in *) ai->ai_addr;\n\n\t\tif (IN_MULTICAST (ntohl (addr->sin_addr.s_addr)))\n\t\t{\n#if HAVE_STRUCT_IP_MREQN_IMR_IFINDEX\n\t\t\t/* If possible, use the \"ip_mreqn\" structure which has\n\t\t\t * an \"interface index\" member. Using the interface\n\t\t\t * index is preferred here, because of its similarity\n\t\t\t * to the way IPv6 handles this. Unfortunately, it\n\t\t\t * appears not to be portable. */\n\t\t\tstruct ip_mreqn mreq;\n\n\t\t\tmemset (&mreq, 0, sizeof (mreq));\n\t\t\tmreq.imr_multiaddr.s_addr = addr->sin_addr.s_addr;\n\t\t\tmreq.imr_address.s_addr = ntohl (INADDR_ANY);\n\t\t\tmreq.imr_ifindex = se->interface;\n#else\n\t\t\tstruct ip_mreq mreq;\n\n\t\t\tmemset (&mreq, 0, sizeof (mreq));\n\t\t\tmreq.imr_multiaddr.s_addr = addr->sin_addr.s_addr;\n\t\t\tmreq.imr_interface.s_addr = ntohl (INADDR_ANY);\n#endif\n\n\t\t\tif (setsockopt (se->data.client.fd, IPPROTO_IP, IP_MULTICAST_IF,\n\t\t\t\t\t\t&mreq, sizeof (mreq)) != 0)\n\t\t\t{\n\t\t\t\tchar errbuf[1024];\n\t\t\t\tERROR (\"network plugin: setsockopt (ipv4-multicast-if): %s\",\n\t\t\t\t\t\tsstrerror (errno, errbuf, sizeof (errbuf)));\n\t\t\t\treturn (-1);\n\t\t\t}\n\n\t\t\treturn (0);\n\t\t}\n\t}\n\telse if (ai->ai_family == AF_INET6)\n\t{\n\t\tstruct sockaddr_in6 *addr = (struct sockaddr_in6 *) ai->ai_addr;\n\n\t\tif (IN6_IS_ADDR_MULTICAST (&addr->sin6_addr))\n\t\t{\n\t\t\tif (setsockopt (se->data.client.fd, IPPROTO_IPV6, IPV6_MULTICAST_IF,\n\t\t\t\t\t\t&se->interface,\n\t\t\t\t\t\tsizeof (se->interface)) != 0)\n\t\t\t{\n\t\t\t\tchar errbuf[1024];\n\t\t\t\tERROR (\"network plugin: setsockopt (ipv6-multicast-if): %s\",\n\t\t\t\t\t\tsstrerror (errno, errbuf,\n\t\t\t\t\t\t\tsizeof (errbuf)));\n\t\t\t\treturn (-1);\n\t\t\t}\n\n\t\t\treturn (0);\n\t\t}\n\t}\n\n\t/* else: Not a multicast interface. */\n\tif (se->interface != 0)\n\t{\n#if defined(HAVE_IF_INDEXTONAME) && HAVE_IF_INDEXTONAME && defined(SO_BINDTODEVICE)\n\t\tchar interface_name[IFNAMSIZ];\n\n\t\tif (if_indextoname (se->interface, interface_name) == NULL)\n\t\t\treturn (-1);\n\n\t\tDEBUG (\"network plugin: Binding socket to interface %s\", interface_name);\n\n\t\tif (setsockopt (se->data.client.fd, SOL_SOCKET, SO_BINDTODEVICE,\n\t\t\t\t\tinterface_name,\n\t\t\t\t\tsizeof(interface_name)) == -1 )\n\t\t{\n\t\t\tchar errbuf[1024];\n\t\t\tERROR (\"network plugin: setsockopt (bind-if): %s\",\n\t\t\t\t\tsstrerror (errno, errbuf, sizeof (errbuf)));\n\t\t\treturn (-1);\n\t\t}\n/* #endif HAVE_IF_INDEXTONAME && SO_BINDTODEVICE */\n\n#else\n\t\tWARNING (\"network plugin: Cannot set the interface on a unicast \"\n\t\t\t\"socket because \"\n# if !defined(SO_BINDTODEVICE)\n\t\t\t\"the \\\"SO_BINDTODEVICE\\\" socket option \"\n# else\n\t\t\t\"the \\\"if_indextoname\\\" function \"\n# endif\n\t\t\t\"is not available on your system.\");\n#endif\n\n\t}\n\n\treturn (0);\n} /* }}} network_set_interface */\n\nstatic int network_bind_socket (int fd, const struct addrinfo *ai, const int interface_idx)\n{\n#if KERNEL_SOLARIS\n\tchar loop   = 0;\n#else\n\tint loop = 0;\n#endif\n\tint yes  = 1;\n\n\t/* allow multiple sockets to use the same PORT number */\n\tif (setsockopt (fd, SOL_SOCKET, SO_REUSEADDR,\n\t\t\t\t&yes, sizeof(yes)) == -1) {\n                char errbuf[1024];\n                ERROR (\"network plugin: setsockopt (reuseaddr): %s\",\n                                sstrerror (errno, errbuf, sizeof (errbuf)));\n\t\treturn (-1);\n\t}\n\n\tDEBUG (\"fd = %i; calling `bind'\", fd);\n\n\tif (bind (fd, ai->ai_addr, ai->ai_addrlen) == -1)\n\t{\n\t\tchar errbuf[1024];\n\t\tERROR (\"bind: %s\",\n\t\t\t\tsstrerror (errno, errbuf, sizeof (errbuf)));\n\t\treturn (-1);\n\t}\n\n\tif (ai->ai_family == AF_INET)\n\t{\n\t\tstruct sockaddr_in *addr = (struct sockaddr_in *) ai->ai_addr;\n\t\tif (IN_MULTICAST (ntohl (addr->sin_addr.s_addr)))\n\t\t{\n#if HAVE_STRUCT_IP_MREQN_IMR_IFINDEX\n\t\t\tstruct ip_mreqn mreq;\n#else\n\t\t\tstruct ip_mreq mreq;\n#endif\n\n\t\t\tDEBUG (\"fd = %i; IPv4 multicast address found\", fd);\n\n\t\t\tmreq.imr_multiaddr.s_addr = addr->sin_addr.s_addr;\n#if HAVE_STRUCT_IP_MREQN_IMR_IFINDEX\n\t\t\t/* Set the interface using the interface index if\n\t\t\t * possible (available). Unfortunately, the struct\n\t\t\t * ip_mreqn is not portable. */\n\t\t\tmreq.imr_address.s_addr = ntohl (INADDR_ANY);\n\t\t\tmreq.imr_ifindex = interface_idx;\n#else\n\t\t\tmreq.imr_interface.s_addr = ntohl (INADDR_ANY);\n#endif\n\n\t\t\tif (setsockopt (fd, IPPROTO_IP, IP_MULTICAST_LOOP,\n\t\t\t\t\t\t&loop, sizeof (loop)) == -1)\n\t\t\t{\n\t\t\t\tchar errbuf[1024];\n\t\t\t\tERROR (\"network plugin: setsockopt (multicast-loop): %s\",\n\t\t\t\t\t\tsstrerror (errno, errbuf,\n\t\t\t\t\t\t\tsizeof (errbuf)));\n\t\t\t\treturn (-1);\n\t\t\t}\n\n\t\t\tif (setsockopt (fd, IPPROTO_IP, IP_ADD_MEMBERSHIP,\n\t\t\t\t\t\t&mreq, sizeof (mreq)) == -1)\n\t\t\t{\n\t\t\t\tchar errbuf[1024];\n\t\t\t\tERROR (\"network plugin: setsockopt (add-membership): %s\",\n\t\t\t\t\t\tsstrerror (errno, errbuf,\n\t\t\t\t\t\t\tsizeof (errbuf)));\n\t\t\t\treturn (-1);\n\t\t\t}\n\n\t\t\treturn (0);\n\t\t}\n\t}\n\telse if (ai->ai_family == AF_INET6)\n\t{\n\t\t/* Useful example: http://gsyc.escet.urjc.es/~eva/IPv6-web/examples/mcast.html */\n\t\tstruct sockaddr_in6 *addr = (struct sockaddr_in6 *) ai->ai_addr;\n\t\tif (IN6_IS_ADDR_MULTICAST (&addr->sin6_addr))\n\t\t{\n\t\t\tstruct ipv6_mreq mreq;\n\n\t\t\tDEBUG (\"fd = %i; IPv6 multicast address found\", fd);\n\n\t\t\tmemcpy (&mreq.ipv6mr_multiaddr,\n\t\t\t\t\t&addr->sin6_addr,\n\t\t\t\t\tsizeof (addr->sin6_addr));\n\n\t\t\t/* http://developer.apple.com/documentation/Darwin/Reference/ManPages/man4/ip6.4.html\n\t\t\t * ipv6mr_interface may be set to zeroes to\n\t\t\t * choose the default multicast interface or to\n\t\t\t * the index of a particular multicast-capable\n\t\t\t * interface if the host is multihomed.\n\t\t\t * Membership is associ-associated with a\n\t\t\t * single interface; programs running on\n\t\t\t * multihomed hosts may need to join the same\n\t\t\t * group on more than one interface.*/\n\t\t\tmreq.ipv6mr_interface = interface_idx;\n\n\t\t\tif (setsockopt (fd, IPPROTO_IPV6, IPV6_MULTICAST_LOOP,\n\t\t\t\t\t\t&loop, sizeof (loop)) == -1)\n\t\t\t{\n\t\t\t\tchar errbuf[1024];\n\t\t\t\tERROR (\"network plugin: setsockopt (ipv6-multicast-loop): %s\",\n\t\t\t\t\t\tsstrerror (errno, errbuf,\n\t\t\t\t\t\t\tsizeof (errbuf)));\n\t\t\t\treturn (-1);\n\t\t\t}\n\n\t\t\tif (setsockopt (fd, IPPROTO_IPV6, IPV6_ADD_MEMBERSHIP,\n\t\t\t\t\t\t&mreq, sizeof (mreq)) == -1)\n\t\t\t{\n\t\t\t\tchar errbuf[1024];\n\t\t\t\tERROR (\"network plugin: setsockopt (ipv6-add-membership): %s\",\n\t\t\t\t\t\tsstrerror (errno, errbuf,\n\t\t\t\t\t\t\tsizeof (errbuf)));\n\t\t\t\treturn (-1);\n\t\t\t}\n\n\t\t\treturn (0);\n\t\t}\n\t}\n\n#if defined(HAVE_IF_INDEXTONAME) && HAVE_IF_INDEXTONAME && defined(SO_BINDTODEVICE)\n\t/* if a specific interface was set, bind the socket to it. But to avoid\n \t * possible problems with multicast routing, only do that for non-multicast\n\t * addresses */\n\tif (interface_idx != 0)\n\t{\n\t\tchar interface_name[IFNAMSIZ];\n\n\t\tif (if_indextoname (interface_idx, interface_name) == NULL)\n\t\t\treturn (-1);\n\n\t\tDEBUG (\"fd = %i; Binding socket to interface %s\", fd, interface_name);\n\n\t\tif (setsockopt (fd, SOL_SOCKET, SO_BINDTODEVICE,\n\t\t\t\t\tinterface_name,\n\t\t\t\t\tsizeof(interface_name)) == -1 )\n\t\t{\n\t\t\tchar errbuf[1024];\n\t\t\tERROR (\"network plugin: setsockopt (bind-if): %s\",\n\t\t\t\t\tsstrerror (errno, errbuf, sizeof (errbuf)));\n\t\t\treturn (-1);\n\t\t}\n\t}\n#endif /* HAVE_IF_INDEXTONAME && SO_BINDTODEVICE */\n\n\treturn (0);\n} /* int network_bind_socket */\n\n/* Initialize a sockent structure. `type' must be either `SOCKENT_TYPE_CLIENT'\n * or `SOCKENT_TYPE_SERVER' */\nstatic sockent_t *sockent_create (int type) /* {{{ */\n{\n\tsockent_t *se;\n\n\tif ((type != SOCKENT_TYPE_CLIENT) && (type != SOCKENT_TYPE_SERVER))\n\t\treturn (NULL);\n\n\tse = malloc (sizeof (*se));\n\tif (se == NULL)\n\t\treturn (NULL);\n\tmemset (se, 0, sizeof (*se));\n\n\tse->type = type;\n\tse->node = NULL;\n\tse->service = NULL;\n\tse->interface = 0;\n\tse->next = NULL;\n\n\tif (type == SOCKENT_TYPE_SERVER)\n\t{\n\t\tse->data.server.fd = NULL;\n\t\tse->data.server.fd_num = 0;\n#if HAVE_LIBGCRYPT\n\t\tse->data.server.security_level = SECURITY_LEVEL_NONE;\n\t\tse->data.server.auth_file = NULL;\n\t\tse->data.server.userdb = NULL;\n\t\tse->data.server.cypher = NULL;\n#endif\n\t}\n\telse\n\t{\n\t\tse->data.client.fd = -1;\n\t\tse->data.client.addr = NULL;\n#if HAVE_LIBGCRYPT\n\t\tse->data.client.security_level = SECURITY_LEVEL_NONE;\n\t\tse->data.client.username = NULL;\n\t\tse->data.client.password = NULL;\n\t\tse->data.client.cypher = NULL;\n#endif\n\t}\n\n\treturn (se);\n} /* }}} sockent_t *sockent_create */\n\nstatic int sockent_init_crypto (sockent_t *se) /* {{{ */\n{\n#if HAVE_LIBGCRYPT /* {{{ */\n\tif (se->type == SOCKENT_TYPE_CLIENT)\n\t{\n\t\tif (se->data.client.security_level > SECURITY_LEVEL_NONE)\n\t\t{\n\t\t\tnetwork_init_gcrypt ();\n\n\t\t\tif ((se->data.client.username == NULL)\n\t\t\t\t\t|| (se->data.client.password == NULL))\n\t\t\t{\n\t\t\t\tERROR (\"network plugin: Client socket with \"\n\t\t\t\t\t\t\"security requested, but no \"\n\t\t\t\t\t\t\"credentials are configured.\");\n\t\t\t\treturn (-1);\n\t\t\t}\n\t\t\tgcry_md_hash_buffer (GCRY_MD_SHA256,\n\t\t\t\t\tse->data.client.password_hash,\n\t\t\t\t\tse->data.client.password,\n\t\t\t\t\tstrlen (se->data.client.password));\n\t\t}\n\t}\n\telse /* (se->type == SOCKENT_TYPE_SERVER) */\n\t{\n\t\tif (se->data.server.security_level > SECURITY_LEVEL_NONE)\n\t\t{\n\t\t\tnetwork_init_gcrypt ();\n\n\t\t\tif (se->data.server.auth_file == NULL)\n\t\t\t{\n\t\t\t\tERROR (\"network plugin: Server socket with \"\n\t\t\t\t\t\t\"security requested, but no \"\n\t\t\t\t\t\t\"password file is configured.\");\n\t\t\t\treturn (-1);\n\t\t\t}\n\t\t}\n\t\tif (se->data.server.auth_file != NULL)\n\t\t{\n\t\t\tse->data.server.userdb = fbh_create (se->data.server.auth_file);\n\t\t\tif (se->data.server.userdb == NULL)\n\t\t\t{\n\t\t\t\tERROR (\"network plugin: Reading password file \"\n\t\t\t\t\t\t\"`%s' failed.\",\n\t\t\t\t\t\tse->data.server.auth_file);\n\t\t\t\tif (se->data.server.security_level > SECURITY_LEVEL_NONE)\n\t\t\t\t\treturn (-1);\n\t\t\t}\n\t\t}\n\t}\n#endif /* }}} HAVE_LIBGCRYPT */\n\n\treturn (0);\n} /* }}} int sockent_init_crypto */\n\nstatic int sockent_client_connect (sockent_t *se) /* {{{ */\n{\n\tstatic c_complain_t complaint = C_COMPLAIN_INIT_STATIC;\n\n\tstruct sockent_client *client;\n\tstruct addrinfo  ai_hints;\n\tstruct addrinfo *ai_list = NULL, *ai_ptr;\n\tint status;\n\n\tif ((se == NULL) || (se->type != SOCKENT_TYPE_CLIENT))\n\t\treturn (EINVAL);\n\n\tclient = &se->data.client;\n\tif (client->fd >= 0) /* already connected */\n\t\treturn (0);\n\n\tmemset (&ai_hints, 0, sizeof (ai_hints));\n#ifdef AI_ADDRCONFIG\n\tai_hints.ai_flags |= AI_ADDRCONFIG;\n#endif\n\tai_hints.ai_family   = AF_UNSPEC;\n\tai_hints.ai_socktype = SOCK_DGRAM;\n\tai_hints.ai_protocol = IPPROTO_UDP;\n\n\tstatus = getaddrinfo (se->node,\n\t\t\t(se->service != NULL) ? se->service : NET_DEFAULT_PORT,\n\t\t\t&ai_hints, &ai_list);\n\tif (status != 0)\n\t{\n\t\tc_complain (LOG_ERR, &complaint,\n\t\t\t\t\"network plugin: getaddrinfo (%s, %s) failed: %s\",\n\t\t\t\t(se->node == NULL) ? \"(null)\" : se->node,\n\t\t\t\t(se->service == NULL) ? \"(null)\" : se->service,\n\t\t\t\tgai_strerror (status));\n\t\treturn (-1);\n\t}\n\telse\n\t{\n\t\tc_release (LOG_NOTICE, &complaint,\n\t\t\t\t\"network plugin: Successfully resolved \\\"%s\\\".\",\n\t\t\t\tse->node);\n\t}\n\n\tfor (ai_ptr = ai_list; ai_ptr != NULL; ai_ptr = ai_ptr->ai_next)\n\t{\n\t\tclient->fd = socket (ai_ptr->ai_family,\n\t\t\t\tai_ptr->ai_socktype,\n\t\t\t\tai_ptr->ai_protocol);\n\t\tif (client->fd < 0)\n\t\t{\n\t\t\tchar errbuf[1024];\n\t\t\tERROR (\"network plugin: socket(2) failed: %s\",\n\t\t\t\t\tsstrerror (errno, errbuf,\n\t\t\t\t\t\tsizeof (errbuf)));\n\t\t\tcontinue;\n\t\t}\n\n\t\tclient->addr = malloc (sizeof (*client->addr));\n\t\tif (client->addr == NULL)\n\t\t{\n\t\t\tERROR (\"network plugin: malloc failed.\");\n\t\t\tclose (client->fd);\n\t\t\tclient->fd = -1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tmemset (client->addr, 0, sizeof (*client->addr));\n\t\tassert (sizeof (*client->addr) >= ai_ptr->ai_addrlen);\n\t\tmemcpy (client->addr, ai_ptr->ai_addr, ai_ptr->ai_addrlen);\n\t\tclient->addrlen = ai_ptr->ai_addrlen;\n\n\t\tnetwork_set_ttl (se, ai_ptr);\n\t\tnetwork_set_interface (se, ai_ptr);\n\n\t\t/* We don't open more than one write-socket per\n\t\t * node/service pair.. */\n\t\tbreak;\n\t}\n\n\tfreeaddrinfo (ai_list);\n\tif (client->fd < 0)\n\t\treturn (-1);\n\treturn (0);\n} /* }}} int sockent_client_connect */\n\nstatic int sockent_client_disconnect (sockent_t *se) /* {{{ */\n{\n\tstruct sockent_client *client;\n\n\tif ((se == NULL) || (se->type != SOCKENT_TYPE_CLIENT))\n\t\treturn (EINVAL);\n\n\tclient = &se->data.client;\n\tif (client->fd >= 0) /* connected */\n\t{\n\t\tclose (client->fd);\n\t\tclient->fd = -1;\n\t}\n\n\tsfree (client->addr);\n\tclient->addrlen = 0;\n\n\treturn (0);\n} /* }}} int sockent_client_disconnect */\n\n/* Open the file descriptors for a initialized sockent structure. */\nstatic int sockent_server_listen (sockent_t *se) /* {{{ */\n{\n\tstruct addrinfo  ai_hints;\n\tstruct addrinfo *ai_list, *ai_ptr;\n\tint              status;\n\n        const char *node;\n        const char *service;\n\n\tif (se == NULL)\n\t\treturn (-1);\n\n\tassert (se->data.server.fd == NULL);\n\tassert (se->data.server.fd_num == 0);\n\n        node = se->node;\n        service = se->service;\n\n        if (service == NULL)\n          service = NET_DEFAULT_PORT;\n\n        DEBUG (\"network plugin: sockent_server_listen: node = %s; service = %s;\",\n            node, service);\n\n\tmemset (&ai_hints, 0, sizeof (ai_hints));\n\tai_hints.ai_flags  = 0;\n#ifdef AI_PASSIVE\n\tai_hints.ai_flags |= AI_PASSIVE;\n#endif\n#ifdef AI_ADDRCONFIG\n\tai_hints.ai_flags |= AI_ADDRCONFIG;\n#endif\n\tai_hints.ai_family   = AF_UNSPEC;\n\tai_hints.ai_socktype = SOCK_DGRAM;\n\tai_hints.ai_protocol = IPPROTO_UDP;\n\n\tstatus = getaddrinfo (node, service, &ai_hints, &ai_list);\n\tif (status != 0)\n\t{\n\t\tERROR (\"network plugin: getaddrinfo (%s, %s) failed: %s\",\n\t\t\t\t(se->node == NULL) ? \"(null)\" : se->node,\n\t\t\t\t(se->service == NULL) ? \"(null)\" : se->service,\n\t\t\t\tgai_strerror (status));\n\t\treturn (-1);\n\t}\n\n\tfor (ai_ptr = ai_list; ai_ptr != NULL; ai_ptr = ai_ptr->ai_next)\n\t{\n\t\tint *tmp;\n\n\t\ttmp = realloc (se->data.server.fd,\n\t\t\t\tsizeof (*tmp) * (se->data.server.fd_num + 1));\n\t\tif (tmp == NULL)\n\t\t{\n\t\t\tERROR (\"network plugin: realloc failed.\");\n\t\t\tcontinue;\n\t\t}\n\t\tse->data.server.fd = tmp;\n\t\ttmp = se->data.server.fd + se->data.server.fd_num;\n\n\t\t*tmp = socket (ai_ptr->ai_family, ai_ptr->ai_socktype,\n\t\t\t\tai_ptr->ai_protocol);\n\t\tif (*tmp < 0)\n\t\t{\n\t\t\tchar errbuf[1024];\n\t\t\tERROR (\"network plugin: socket(2) failed: %s\",\n\t\t\t\t\tsstrerror (errno, errbuf,\n\t\t\t\t\t\tsizeof (errbuf)));\n\t\t\tcontinue;\n\t\t}\n\n\t\tstatus = network_bind_socket (*tmp, ai_ptr, se->interface);\n\t\tif (status != 0)\n\t\t{\n\t\t\tclose (*tmp);\n\t\t\t*tmp = -1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tse->data.server.fd_num++;\n\t\tcontinue;\n\t} /* for (ai_list) */\n\n\tfreeaddrinfo (ai_list);\n\n\tif (se->data.server.fd_num <= 0)\n\t\treturn (-1);\n\treturn (0);\n} /* }}} int sockent_server_listen */\n\n/* Add a sockent to the global list of sockets */\nstatic int sockent_add (sockent_t *se) /* {{{ */\n{\n\tsockent_t *last_ptr;\n\n\tif (se == NULL)\n\t\treturn (-1);\n\n\tif (se->type == SOCKENT_TYPE_SERVER)\n\t{\n\t\tstruct pollfd *tmp;\n\t\tsize_t i;\n\n\t\ttmp = realloc (listen_sockets_pollfd,\n\t\t\t\tsizeof (*tmp) * (listen_sockets_num\n\t\t\t\t\t+ se->data.server.fd_num));\n\t\tif (tmp == NULL)\n\t\t{\n\t\t\tERROR (\"network plugin: realloc failed.\");\n\t\t\treturn (-1);\n\t\t}\n\t\tlisten_sockets_pollfd = tmp;\n\t\ttmp = listen_sockets_pollfd + listen_sockets_num;\n\n\t\tfor (i = 0; i < se->data.server.fd_num; i++)\n\t\t{\n\t\t\tmemset (tmp + i, 0, sizeof (*tmp));\n\t\t\ttmp[i].fd = se->data.server.fd[i];\n\t\t\ttmp[i].events = POLLIN | POLLPRI;\n\t\t\ttmp[i].revents = 0;\n\t\t}\n\n\t\tlisten_sockets_num += se->data.server.fd_num;\n\n\t\tif (listen_sockets == NULL)\n\t\t{\n\t\t\tlisten_sockets = se;\n\t\t\treturn (0);\n\t\t}\n\t\tlast_ptr = listen_sockets;\n\t}\n\telse /* if (se->type == SOCKENT_TYPE_CLIENT) */\n\t{\n\t\tif (sending_sockets == NULL)\n\t\t{\n\t\t\tsending_sockets = se;\n\t\t\treturn (0);\n\t\t}\n\t\tlast_ptr = sending_sockets;\n\t}\n\n\twhile (last_ptr->next != NULL)\n\t\tlast_ptr = last_ptr->next;\n\tlast_ptr->next = se;\n\n\treturn (0);\n} /* }}} int sockent_add */\n\nstatic void *dispatch_thread (void __attribute__((unused)) *arg) /* {{{ */\n{\n  while (42)\n  {\n    receive_list_entry_t *ent;\n    sockent_t *se;\n\n    /* Lock and wait for more data to come in */\n    pthread_mutex_lock (&receive_list_lock);\n    while ((listen_loop == 0)\n        && (receive_list_head == NULL))\n      pthread_cond_wait (&receive_list_cond, &receive_list_lock);\n\n    /* Remove the head entry and unlock */\n    ent = receive_list_head;\n    if (ent != NULL)\n      receive_list_head = ent->next;\n    receive_list_length--;\n    pthread_mutex_unlock (&receive_list_lock);\n\n    /* Check whether we are supposed to exit. We do NOT check `listen_loop'\n     * because we dispatch all missing packets before shutting down. */\n    if (ent == NULL)\n      break;\n\n    /* Look for the correct `sockent_t' */\n    se = listen_sockets;\n    while (se != NULL)\n    {\n      size_t i;\n\n      for (i = 0; i < se->data.server.fd_num; i++)\n        if (se->data.server.fd[i] == ent->fd)\n          break;\n\n      if (i < se->data.server.fd_num)\n        break;\n\n      se = se->next;\n    }\n\n    if (se == NULL)\n    {\n      ERROR (\"network plugin: Got packet from FD %i, but can't \"\n          \"find an appropriate socket entry.\",\n          ent->fd);\n      sfree (ent->data);\n      sfree (ent);\n      continue;\n    }\n\n    parse_packet (se, ent->data, ent->data_len, /* flags = */ 0,\n\t/* username = */ NULL);\n    sfree (ent->data);\n    sfree (ent);\n  } /* while (42) */\n\n  return (NULL);\n} /* }}} void *dispatch_thread */\n\nstatic int network_receive (void) /* {{{ */\n{\n\tchar buffer[network_config_packet_size];\n\tint  buffer_len;\n\n\tint i;\n\tint status = 0;\n\n\treceive_list_entry_t *private_list_head;\n\treceive_list_entry_t *private_list_tail;\n\tuint64_t              private_list_length;\n\n\tassert (listen_sockets_num > 0);\n\n\tprivate_list_head = NULL;\n\tprivate_list_tail = NULL;\n\tprivate_list_length = 0;\n\n\twhile (listen_loop == 0)\n\t{\n\t\tstatus = poll (listen_sockets_pollfd, listen_sockets_num, -1);\n\t\tif (status <= 0)\n\t\t{\n\t\t\tchar errbuf[1024];\n\t\t\tif (errno == EINTR)\n\t\t\t\tcontinue;\n\t\t\tERROR (\"network plugin: poll(2) failed: %s\",\n\t\t\t\t\tsstrerror (errno, errbuf, sizeof (errbuf)));\n\t\t\tbreak;\n\t\t}\n\n\t\tfor (i = 0; (i < listen_sockets_num) && (status > 0); i++)\n\t\t{\n\t\t\treceive_list_entry_t *ent;\n\n\t\t\tif ((listen_sockets_pollfd[i].revents\n\t\t\t\t\t\t& (POLLIN | POLLPRI)) == 0)\n\t\t\t\tcontinue;\n\t\t\tstatus--;\n\n\t\t\tbuffer_len = recv (listen_sockets_pollfd[i].fd,\n\t\t\t\t\tbuffer, sizeof (buffer),\n\t\t\t\t\t0 /* no flags */);\n\t\t\tif (buffer_len < 0)\n\t\t\t{\n\t\t\t\tchar errbuf[1024];\n\t\t\t\tstatus = (errno != 0) ? errno : -1;\n\t\t\t\tERROR (\"network plugin: recv(2) failed: %s\",\n\t\t\t\t\t\tsstrerror (errno, errbuf, sizeof (errbuf)));\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tstats_octets_rx += ((uint64_t) buffer_len);\n\t\t\tstats_packets_rx++;\n\n\t\t\t/* TODO: Possible performance enhancement: Do not free\n\t\t\t * these entries in the dispatch thread but put them in\n\t\t\t * another list, so we don't have to allocate more and\n\t\t\t * more of these structures. */\n\t\t\tent = malloc (sizeof (receive_list_entry_t));\n\t\t\tif (ent == NULL)\n\t\t\t{\n\t\t\t\tERROR (\"network plugin: malloc failed.\");\n\t\t\t\tstatus = ENOMEM;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmemset (ent, 0, sizeof (receive_list_entry_t));\n\t\t\tent->data = malloc (network_config_packet_size);\n\t\t\tif (ent->data == NULL)\n\t\t\t{\n\t\t\t\tsfree (ent);\n\t\t\t\tERROR (\"network plugin: malloc failed.\");\n\t\t\t\tstatus = ENOMEM;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tent->fd = listen_sockets_pollfd[i].fd;\n\t\t\tent->next = NULL;\n\n\t\t\tmemcpy (ent->data, buffer, buffer_len);\n\t\t\tent->data_len = buffer_len;\n\n\t\t\tif (private_list_head == NULL)\n\t\t\t\tprivate_list_head = ent;\n\t\t\telse\n\t\t\t\tprivate_list_tail->next = ent;\n\t\t\tprivate_list_tail = ent;\n\t\t\tprivate_list_length++;\n\n\t\t\t/* Do not block here. Blocking here has led to\n\t\t\t * insufficient performance in the past. */\n\t\t\tif (pthread_mutex_trylock (&receive_list_lock) == 0)\n\t\t\t{\n\t\t\t\tassert (((receive_list_head == NULL) && (receive_list_length == 0))\n\t\t\t\t\t\t|| ((receive_list_head != NULL) && (receive_list_length != 0)));\n\n\t\t\t\tif (receive_list_head == NULL)\n\t\t\t\t\treceive_list_head = private_list_head;\n\t\t\t\telse\n\t\t\t\t\treceive_list_tail->next = private_list_head;\n\t\t\t\treceive_list_tail = private_list_tail;\n\t\t\t\treceive_list_length += private_list_length;\n\n\t\t\t\tpthread_cond_signal (&receive_list_cond);\n\t\t\t\tpthread_mutex_unlock (&receive_list_lock);\n\n\t\t\t\tprivate_list_head = NULL;\n\t\t\t\tprivate_list_tail = NULL;\n\t\t\t\tprivate_list_length = 0;\n\t\t\t}\n\n\t\t\tstatus = 0;\n\t\t} /* for (listen_sockets_pollfd) */\n\n\t\tif (status != 0)\n\t\t\tbreak;\n\t} /* while (listen_loop == 0) */\n\n\t/* Make sure everything is dispatched before exiting. */\n\tif (private_list_head != NULL)\n\t{\n\t\tpthread_mutex_lock (&receive_list_lock);\n\n\t\tif (receive_list_head == NULL)\n\t\t\treceive_list_head = private_list_head;\n\t\telse\n\t\t\treceive_list_tail->next = private_list_head;\n\t\treceive_list_tail = private_list_tail;\n\t\treceive_list_length += private_list_length;\n\n\t\tpthread_cond_signal (&receive_list_cond);\n\t\tpthread_mutex_unlock (&receive_list_lock);\n\t}\n\n\treturn (status);\n} /* }}} int network_receive */\n\nstatic void *receive_thread (void __attribute__((unused)) *arg)\n{\n\treturn (network_receive () ? (void *) 1 : (void *) 0);\n} /* void *receive_thread */\n\nstatic void network_init_buffer (void)\n{\n\tmemset (send_buffer, 0, network_config_packet_size);\n\tsend_buffer_ptr = send_buffer;\n\tsend_buffer_fill = 0;\n\n\tmemset (&send_buffer_vl, 0, sizeof (send_buffer_vl));\n} /* int network_init_buffer */\n\nstatic void networt_send_buffer_plain (sockent_t *se, /* {{{ */\n\t\tconst char *buffer, size_t buffer_size)\n{\n\tint status;\n\n\twhile (42)\n\t{\n\t\tstatus = sockent_client_connect (se);\n\t\tif (status != 0)\n\t\t\treturn;\n\n\t\tstatus = sendto (se->data.client.fd, buffer, buffer_size,\n\t\t\t\t/* flags = */ 0,\n\t\t\t\t(struct sockaddr *) se->data.client.addr,\n\t\t\t\tse->data.client.addrlen);\n\t\tif (status < 0)\n\t\t{\n\t\t\tchar errbuf[1024];\n\n\t\t\tif ((errno == EINTR) || (errno == EAGAIN))\n\t\t\t\tcontinue;\n\n\t\t\tERROR (\"network plugin: sendto failed: %s. Closing sending socket.\",\n\t\t\t\t\tsstrerror (errno, errbuf, sizeof (errbuf)));\n\t\t\tsockent_client_disconnect (se);\n\t\t\treturn;\n\t\t}\n\n\t\tbreak;\n\t} /* while (42) */\n} /* }}} void networt_send_buffer_plain */\n\n#if HAVE_LIBGCRYPT\n#define BUFFER_ADD(p,s) do { \\\n  memcpy (buffer + buffer_offset, (p), (s)); \\\n  buffer_offset += (s); \\\n} while (0)\n\nstatic void networt_send_buffer_signed (sockent_t *se, /* {{{ */\n\t\tconst char *in_buffer, size_t in_buffer_size)\n{\n  part_signature_sha256_t ps;\n  char buffer[BUFF_SIG_SIZE + in_buffer_size];\n  size_t buffer_offset;\n  size_t username_len;\n\n  gcry_md_hd_t hd;\n  gcry_error_t err;\n  unsigned char *hash;\n\n  hd = NULL;\n  err = gcry_md_open (&hd, GCRY_MD_SHA256, GCRY_MD_FLAG_HMAC);\n  if (err != 0)\n  {\n    ERROR (\"network plugin: Creating HMAC object failed: %s\",\n        gcry_strerror (err));\n    return;\n  }\n\n  err = gcry_md_setkey (hd, se->data.client.password,\n      strlen (se->data.client.password));\n  if (err != 0)\n  {\n    ERROR (\"network plugin: gcry_md_setkey failed: %s\",\n        gcry_strerror (err));\n    gcry_md_close (hd);\n    return;\n  }\n\n  username_len = strlen (se->data.client.username);\n  if (username_len > (BUFF_SIG_SIZE - PART_SIGNATURE_SHA256_SIZE))\n  {\n    ERROR (\"network plugin: Username too long: %s\",\n        se->data.client.username);\n    return;\n  }\n\n  memcpy (buffer + PART_SIGNATURE_SHA256_SIZE,\n      se->data.client.username, username_len);\n  memcpy (buffer + PART_SIGNATURE_SHA256_SIZE + username_len,\n      in_buffer, in_buffer_size);\n\n  /* Initialize the `ps' structure. */\n  memset (&ps, 0, sizeof (ps));\n  ps.head.type = htons (TYPE_SIGN_SHA256);\n  ps.head.length = htons (PART_SIGNATURE_SHA256_SIZE + username_len);\n\n  /* Calculate the hash value. */\n  gcry_md_write (hd, buffer + PART_SIGNATURE_SHA256_SIZE,\n      username_len + in_buffer_size);\n  hash = gcry_md_read (hd, GCRY_MD_SHA256);\n  if (hash == NULL)\n  {\n    ERROR (\"network plugin: gcry_md_read failed.\");\n    gcry_md_close (hd);\n    return;\n  }\n  memcpy (ps.hash, hash, sizeof (ps.hash));\n\n  /* Add the header */\n  buffer_offset = 0;\n\n  BUFFER_ADD (&ps.head.type, sizeof (ps.head.type));\n  BUFFER_ADD (&ps.head.length, sizeof (ps.head.length));\n  BUFFER_ADD (ps.hash, sizeof (ps.hash));\n\n  assert (buffer_offset == PART_SIGNATURE_SHA256_SIZE);\n\n  gcry_md_close (hd);\n  hd = NULL;\n\n  buffer_offset = PART_SIGNATURE_SHA256_SIZE + username_len + in_buffer_size;\n  networt_send_buffer_plain (se, buffer, buffer_offset);\n} /* }}} void networt_send_buffer_signed */\n\nstatic void networt_send_buffer_encrypted (sockent_t *se, /* {{{ */\n\t\tconst char *in_buffer, size_t in_buffer_size)\n{\n  part_encryption_aes256_t pea;\n  char buffer[BUFF_SIG_SIZE + in_buffer_size];\n  size_t buffer_size;\n  size_t buffer_offset;\n  size_t header_size;\n  size_t username_len;\n  gcry_error_t err;\n  gcry_cipher_hd_t cypher;\n\n  /* Initialize the header fields */\n  memset (&pea, 0, sizeof (pea));\n  pea.head.type = htons (TYPE_ENCR_AES256);\n\n  pea.username = se->data.client.username;\n\n  username_len = strlen (pea.username);\n  if ((PART_ENCRYPTION_AES256_SIZE + username_len) > BUFF_SIG_SIZE)\n  {\n    ERROR (\"network plugin: Username too long: %s\", pea.username);\n    return;\n  }\n\n  buffer_size = PART_ENCRYPTION_AES256_SIZE + username_len + in_buffer_size;\n  header_size = PART_ENCRYPTION_AES256_SIZE + username_len\n    - sizeof (pea.hash);\n\n  assert (buffer_size <= sizeof (buffer));\n  DEBUG (\"network plugin: networt_send_buffer_encrypted: \"\n      \"buffer_size = %zu;\", buffer_size);\n\n  pea.head.length = htons ((uint16_t) (PART_ENCRYPTION_AES256_SIZE\n        + username_len + in_buffer_size));\n  pea.username_length = htons ((uint16_t) username_len);\n\n  /* Chose a random initialization vector. */\n  gcry_randomize ((void *) &pea.iv, sizeof (pea.iv), GCRY_STRONG_RANDOM);\n\n  /* Create hash of the payload */\n  gcry_md_hash_buffer (GCRY_MD_SHA1, pea.hash, in_buffer, in_buffer_size);\n\n  /* Initialize the buffer */\n  buffer_offset = 0;\n  memset (buffer, 0, sizeof (buffer));\n\n\n  BUFFER_ADD (&pea.head.type, sizeof (pea.head.type));\n  BUFFER_ADD (&pea.head.length, sizeof (pea.head.length));\n  BUFFER_ADD (&pea.username_length, sizeof (pea.username_length));\n  BUFFER_ADD (pea.username, username_len);\n  BUFFER_ADD (pea.iv, sizeof (pea.iv));\n  assert (buffer_offset == header_size);\n  BUFFER_ADD (pea.hash, sizeof (pea.hash));\n  BUFFER_ADD (in_buffer, in_buffer_size);\n\n  assert (buffer_offset == buffer_size);\n\n  cypher = network_get_aes256_cypher (se, pea.iv, sizeof (pea.iv),\n      se->data.client.password);\n  if (cypher == NULL)\n    return;\n\n  /* Encrypt the buffer in-place */\n  err = gcry_cipher_encrypt (cypher,\n      buffer      + header_size,\n      buffer_size - header_size,\n      /* in = */ NULL, /* in len = */ 0);\n  if (err != 0)\n  {\n    ERROR (\"network plugin: gcry_cipher_encrypt returned: %s\",\n        gcry_strerror (err));\n    return;\n  }\n\n  /* Send it out without further modifications */\n  networt_send_buffer_plain (se, buffer, buffer_size);\n} /* }}} void networt_send_buffer_encrypted */\n#undef BUFFER_ADD\n#endif /* HAVE_LIBGCRYPT */\n\nstatic void network_send_buffer (char *buffer, size_t buffer_len) /* {{{ */\n{\n  sockent_t *se;\n\n  DEBUG (\"network plugin: network_send_buffer: buffer_len = %zu\", buffer_len);\n\n  for (se = sending_sockets; se != NULL; se = se->next)\n  {\n#if HAVE_LIBGCRYPT\n    if (se->data.client.security_level == SECURITY_LEVEL_ENCRYPT)\n      networt_send_buffer_encrypted (se, buffer, buffer_len);\n    else if (se->data.client.security_level == SECURITY_LEVEL_SIGN)\n      networt_send_buffer_signed (se, buffer, buffer_len);\n    else /* if (se->data.client.security_level == SECURITY_LEVEL_NONE) */\n#endif /* HAVE_LIBGCRYPT */\n      networt_send_buffer_plain (se, buffer, buffer_len);\n  } /* for (sending_sockets) */\n} /* }}} void network_send_buffer */\n\nstatic int add_to_buffer (char *buffer, int buffer_size, /* {{{ */\n\t\tvalue_list_t *vl_def,\n\t\tconst data_set_t *ds, const value_list_t *vl)\n{\n\tchar *buffer_orig = buffer;\n\n\tif (strcmp (vl_def->host, vl->host) != 0)\n\t{\n\t\tif (write_part_string (&buffer, &buffer_size, TYPE_HOST,\n\t\t\t\t\tvl->host, strlen (vl->host)) != 0)\n\t\t\treturn (-1);\n\t\tsstrncpy (vl_def->host, vl->host, sizeof (vl_def->host));\n\t}\n\n\tif (vl_def->time != vl->time)\n\t{\n\t\tif (write_part_number (&buffer, &buffer_size, TYPE_TIME_HR,\n\t\t\t\t\t(uint64_t) vl->time))\n\t\t\treturn (-1);\n\t\tvl_def->time = vl->time;\n\t}\n\n\tif (vl_def->interval != vl->interval)\n\t{\n\t\tif (write_part_number (&buffer, &buffer_size, TYPE_INTERVAL_HR,\n\t\t\t\t\t(uint64_t) vl->interval))\n\t\t\treturn (-1);\n\t\tvl_def->interval = vl->interval;\n\t}\n\n\tif (strcmp (vl_def->plugin, vl->plugin) != 0)\n\t{\n\t\tif (write_part_string (&buffer, &buffer_size, TYPE_PLUGIN,\n\t\t\t\t\tvl->plugin, strlen (vl->plugin)) != 0)\n\t\t\treturn (-1);\n\t\tsstrncpy (vl_def->plugin, vl->plugin, sizeof (vl_def->plugin));\n\t}\n\n\tif (strcmp (vl_def->plugin_instance, vl->plugin_instance) != 0)\n\t{\n\t\tif (write_part_string (&buffer, &buffer_size, TYPE_PLUGIN_INSTANCE,\n\t\t\t\t\tvl->plugin_instance,\n\t\t\t\t\tstrlen (vl->plugin_instance)) != 0)\n\t\t\treturn (-1);\n\t\tsstrncpy (vl_def->plugin_instance, vl->plugin_instance, sizeof (vl_def->plugin_instance));\n\t}\n\n\tif (strcmp (vl_def->type, vl->type) != 0)\n\t{\n\t\tif (write_part_string (&buffer, &buffer_size, TYPE_TYPE,\n\t\t\t\t\tvl->type, strlen (vl->type)) != 0)\n\t\t\treturn (-1);\n\t\tsstrncpy (vl_def->type, ds->type, sizeof (vl_def->type));\n\t}\n\n\tif (strcmp (vl_def->type_instance, vl->type_instance) != 0)\n\t{\n\t\tif (write_part_string (&buffer, &buffer_size, TYPE_TYPE_INSTANCE,\n\t\t\t\t\tvl->type_instance,\n\t\t\t\t\tstrlen (vl->type_instance)) != 0)\n\t\t\treturn (-1);\n\t\tsstrncpy (vl_def->type_instance, vl->type_instance, sizeof (vl_def->type_instance));\n\t}\n\n\tif (write_part_values (&buffer, &buffer_size, ds, vl) != 0)\n\t\treturn (-1);\n\n\treturn (buffer - buffer_orig);\n} /* }}} int add_to_buffer */\n\nstatic void flush_buffer (void)\n{\n\tDEBUG (\"network plugin: flush_buffer: send_buffer_fill = %i\",\n\t\t\tsend_buffer_fill);\n\n\tnetwork_send_buffer (send_buffer, (size_t) send_buffer_fill);\n\n\tstats_octets_tx += ((uint64_t) send_buffer_fill);\n\tstats_packets_tx++;\n\n\tnetwork_init_buffer ();\n}\n\nstatic int network_write (const data_set_t *ds, const value_list_t *vl,\n\t\tuser_data_t __attribute__((unused)) *user_data)\n{\n\tint status;\n\n\tif (!check_send_okay (vl))\n\t{\n#if COLLECT_DEBUG\n\t  char name[6*DATA_MAX_NAME_LEN];\n\t  FORMAT_VL (name, sizeof (name), vl);\n\t  name[sizeof (name) - 1] = 0;\n\t  DEBUG (\"network plugin: network_write: \"\n\t      \"NOT sending %s.\", name);\n#endif\n\t  /* Counter is not protected by another lock and may be reached by\n\t   * multiple threads */\n\t  pthread_mutex_lock (&stats_lock);\n\t  stats_values_not_sent++;\n\t  pthread_mutex_unlock (&stats_lock);\n\t  return (0);\n\t}\n\n\tuc_meta_data_add_unsigned_int (vl,\n\t    \"network:time_sent\", (uint64_t) vl->time);\n\n\tpthread_mutex_lock (&send_buffer_lock);\n\n\tstatus = add_to_buffer (send_buffer_ptr,\n\t\t\tnetwork_config_packet_size - (send_buffer_fill + BUFF_SIG_SIZE),\n\t\t\t&send_buffer_vl,\n\t\t\tds, vl);\n\tif (status >= 0)\n\t{\n\t\t/* status == bytes added to the buffer */\n\t\tsend_buffer_fill += status;\n\t\tsend_buffer_ptr  += status;\n\n\t\tstats_values_sent++;\n\t}\n\telse\n\t{\n\t\tflush_buffer ();\n\n\t\tstatus = add_to_buffer (send_buffer_ptr,\n\t\t\t\tnetwork_config_packet_size - (send_buffer_fill + BUFF_SIG_SIZE),\n\t\t\t\t&send_buffer_vl,\n\t\t\t\tds, vl);\n\n\t\tif (status >= 0)\n\t\t{\n\t\t\tsend_buffer_fill += status;\n\t\t\tsend_buffer_ptr  += status;\n\n\t\t\tstats_values_sent++;\n\t\t}\n\t}\n\n\tif (status < 0)\n\t{\n\t\tERROR (\"network plugin: Unable to append to the \"\n\t\t\t\t\"buffer for some weird reason\");\n\t}\n\telse if ((network_config_packet_size - send_buffer_fill) < 15)\n\t{\n\t\tflush_buffer ();\n\t}\n\n\tpthread_mutex_unlock (&send_buffer_lock);\n\n\treturn ((status < 0) ? -1 : 0);\n} /* int network_write */\n\nstatic int network_config_set_boolean (const oconfig_item_t *ci, /* {{{ */\n    int *retval)\n{\n  if ((ci->values_num != 1)\n      || ((ci->values[0].type != OCONFIG_TYPE_BOOLEAN)\n        && (ci->values[0].type != OCONFIG_TYPE_STRING)))\n  {\n    ERROR (\"network plugin: The `%s' config option needs \"\n        \"exactly one boolean argument.\", ci->key);\n    return (-1);\n  }\n\n  if (ci->values[0].type == OCONFIG_TYPE_BOOLEAN)\n  {\n    if (ci->values[0].value.boolean)\n      *retval = 1;\n    else\n      *retval = 0;\n  }\n  else\n  {\n    char *str = ci->values[0].value.string;\n\n    if (IS_TRUE (str))\n      *retval = 1;\n    else if (IS_FALSE (str))\n      *retval = 0;\n    else\n    {\n      ERROR (\"network plugin: Cannot parse string value `%s' of the `%s' \"\n          \"option as boolean value.\",\n          str, ci->key);\n      return (-1);\n    }\n  }\n\n  return (0);\n} /* }}} int network_config_set_boolean */\n\nstatic int network_config_set_ttl (const oconfig_item_t *ci) /* {{{ */\n{\n  int tmp;\n  if ((ci->values_num != 1)\n      || (ci->values[0].type != OCONFIG_TYPE_NUMBER))\n  {\n    WARNING (\"network plugin: The `TimeToLive' config option needs exactly \"\n        \"one numeric argument.\");\n    return (-1);\n  }\n\n  tmp = (int) ci->values[0].value.number;\n  if ((tmp > 0) && (tmp <= 255))\n    network_config_ttl = tmp;\n  else {\n    WARNING (\"network plugin: The `TimeToLive' must be between 1 and 255.\");\n    return (-1);\n  }\n\n  return (0);\n} /* }}} int network_config_set_ttl */\n\nstatic int network_config_set_interface (const oconfig_item_t *ci, /* {{{ */\n    int *interface)\n{\n  if ((ci->values_num != 1)\n      || (ci->values[0].type != OCONFIG_TYPE_STRING))\n  {\n    WARNING (\"network plugin: The `Interface' config option needs exactly \"\n        \"one string argument.\");\n    return (-1);\n  }\n\n  if (interface == NULL)\n    return (-1);\n\n  *interface = if_nametoindex (ci->values[0].value.string);\n\n  return (0);\n} /* }}} int network_config_set_interface */\n\nstatic int network_config_set_buffer_size (const oconfig_item_t *ci) /* {{{ */\n{\n  int tmp;\n  if ((ci->values_num != 1)\n      || (ci->values[0].type != OCONFIG_TYPE_NUMBER))\n  {\n    WARNING (\"network plugin: The `MaxPacketSize' config option needs exactly \"\n        \"one numeric argument.\");\n    return (-1);\n  }\n\n  tmp = (int) ci->values[0].value.number;\n  if ((tmp >= 1024) && (tmp <= 65535))\n    network_config_packet_size = tmp;\n\n  return (0);\n} /* }}} int network_config_set_buffer_size */\n\n#if HAVE_LIBGCRYPT\nstatic int network_config_set_string (const oconfig_item_t *ci, /* {{{ */\n    char **ret_string)\n{\n  char *tmp;\n  if ((ci->values_num != 1)\n      || (ci->values[0].type != OCONFIG_TYPE_STRING))\n  {\n    WARNING (\"network plugin: The `%s' config option needs exactly \"\n        \"one string argument.\", ci->key);\n    return (-1);\n  }\n\n  tmp = strdup (ci->values[0].value.string);\n  if (tmp == NULL)\n    return (-1);\n\n  sfree (*ret_string);\n  *ret_string = tmp;\n\n  return (0);\n} /* }}} int network_config_set_string */\n#endif /* HAVE_LIBGCRYPT */\n\n#if HAVE_LIBGCRYPT\nstatic int network_config_set_security_level (oconfig_item_t *ci, /* {{{ */\n    int *retval)\n{\n  char *str;\n  if ((ci->values_num != 1)\n      || (ci->values[0].type != OCONFIG_TYPE_STRING))\n  {\n    WARNING (\"network plugin: The `SecurityLevel' config option needs exactly \"\n        \"one string argument.\");\n    return (-1);\n  }\n\n  str = ci->values[0].value.string;\n  if (strcasecmp (\"Encrypt\", str) == 0)\n    *retval = SECURITY_LEVEL_ENCRYPT;\n  else if (strcasecmp (\"Sign\", str) == 0)\n    *retval = SECURITY_LEVEL_SIGN;\n  else if (strcasecmp (\"None\", str) == 0)\n    *retval = SECURITY_LEVEL_NONE;\n  else\n  {\n    WARNING (\"network plugin: Unknown security level: %s.\", str);\n    return (-1);\n  }\n\n  return (0);\n} /* }}} int network_config_set_security_level */\n#endif /* HAVE_LIBGCRYPT */\n\nstatic int network_config_add_listen (const oconfig_item_t *ci) /* {{{ */\n{\n  sockent_t *se;\n  int status;\n  int i;\n\n  if ((ci->values_num < 1) || (ci->values_num > 2)\n      || (ci->values[0].type != OCONFIG_TYPE_STRING)\n      || ((ci->values_num > 1) && (ci->values[1].type != OCONFIG_TYPE_STRING)))\n  {\n    ERROR (\"network plugin: The `%s' config option needs \"\n        \"one or two string arguments.\", ci->key);\n    return (-1);\n  }\n\n  se = sockent_create (SOCKENT_TYPE_SERVER);\n  if (se == NULL)\n  {\n    ERROR (\"network plugin: sockent_create failed.\");\n    return (-1);\n  }\n\n  se->node = strdup (ci->values[0].value.string);\n  if (ci->values_num >= 2)\n    se->service = strdup (ci->values[1].value.string);\n\n  for (i = 0; i < ci->children_num; i++)\n  {\n    oconfig_item_t *child = ci->children + i;\n\n#if HAVE_LIBGCRYPT\n    if (strcasecmp (\"AuthFile\", child->key) == 0)\n      network_config_set_string (child, &se->data.server.auth_file);\n    else if (strcasecmp (\"SecurityLevel\", child->key) == 0)\n      network_config_set_security_level (child,\n          &se->data.server.security_level);\n    else\n#endif /* HAVE_LIBGCRYPT */\n    if (strcasecmp (\"Interface\", child->key) == 0)\n      network_config_set_interface (child,\n          &se->interface);\n    else\n    {\n      WARNING (\"network plugin: Option `%s' is not allowed here.\",\n          child->key);\n    }\n  }\n\n#if HAVE_LIBGCRYPT\n  if ((se->data.server.security_level > SECURITY_LEVEL_NONE)\n      && (se->data.server.auth_file == NULL))\n  {\n    ERROR (\"network plugin: A security level higher than `none' was \"\n        \"requested, but no AuthFile option was given. Cowardly refusing to \"\n        \"open this socket!\");\n    sockent_destroy (se);\n    return (-1);\n  }\n#endif /* HAVE_LIBGCRYPT */\n\n  status = sockent_init_crypto (se);\n  if (status != 0)\n  {\n    ERROR (\"network plugin: network_config_add_listen: sockent_init_crypto() failed.\");\n    sockent_destroy (se);\n    return (-1);\n  }\n\n  status = sockent_server_listen (se);\n  if (status != 0)\n  {\n    ERROR (\"network plugin: network_config_add_server: sockent_server_listen failed.\");\n    sockent_destroy (se);\n    return (-1);\n  }\n\n  status = sockent_add (se);\n  if (status != 0)\n  {\n    ERROR (\"network plugin: network_config_add_listen: sockent_add failed.\");\n    sockent_destroy (se);\n    return (-1);\n  }\n\n  return (0);\n} /* }}} int network_config_add_listen */\n\nstatic int network_config_add_server (const oconfig_item_t *ci) /* {{{ */\n{\n  sockent_t *se;\n  int status;\n  int i;\n\n  if ((ci->values_num < 1) || (ci->values_num > 2)\n      || (ci->values[0].type != OCONFIG_TYPE_STRING)\n      || ((ci->values_num > 1) && (ci->values[1].type != OCONFIG_TYPE_STRING)))\n  {\n    ERROR (\"network plugin: The `%s' config option needs \"\n        \"one or two string arguments.\", ci->key);\n    return (-1);\n  }\n\n  se = sockent_create (SOCKENT_TYPE_CLIENT);\n  if (se == NULL)\n  {\n    ERROR (\"network plugin: sockent_create failed.\");\n    return (-1);\n  }\n\n  se->node = strdup (ci->values[0].value.string);\n  if (ci->values_num >= 2)\n    se->service = strdup (ci->values[1].value.string);\n\n  for (i = 0; i < ci->children_num; i++)\n  {\n    oconfig_item_t *child = ci->children + i;\n\n#if HAVE_LIBGCRYPT\n    if (strcasecmp (\"Username\", child->key) == 0)\n      network_config_set_string (child, &se->data.client.username);\n    else if (strcasecmp (\"Password\", child->key) == 0)\n      network_config_set_string (child, &se->data.client.password);\n    else if (strcasecmp (\"SecurityLevel\", child->key) == 0)\n      network_config_set_security_level (child,\n          &se->data.client.security_level);\n    else\n#endif /* HAVE_LIBGCRYPT */\n    if (strcasecmp (\"Interface\", child->key) == 0)\n      network_config_set_interface (child,\n          &se->interface);\n    else\n    {\n      WARNING (\"network plugin: Option `%s' is not allowed here.\",\n          child->key);\n    }\n  }\n\n#if HAVE_LIBGCRYPT\n  if ((se->data.client.security_level > SECURITY_LEVEL_NONE)\n      && ((se->data.client.username == NULL)\n        || (se->data.client.password == NULL)))\n  {\n    ERROR (\"network plugin: A security level higher than `none' was \"\n        \"requested, but no Username or Password option was given. \"\n        \"Cowardly refusing to open this socket!\");\n    sockent_destroy (se);\n    return (-1);\n  }\n#endif /* HAVE_LIBGCRYPT */\n\n  status = sockent_init_crypto (se);\n  if (status != 0)\n  {\n    ERROR (\"network plugin: network_config_add_server: sockent_init_crypto() failed.\");\n    sockent_destroy (se);\n    return (-1);\n  }\n\n  /* No call to sockent_client_connect() here -- it is called from\n   * networt_send_buffer_plain(). */\n\n  status = sockent_add (se);\n  if (status != 0)\n  {\n    ERROR (\"network plugin: network_config_add_server: sockent_add failed.\");\n    sockent_destroy (se);\n    return (-1);\n  }\n\n  return (0);\n} /* }}} int network_config_add_server */\n\nstatic int network_config (oconfig_item_t *ci) /* {{{ */\n{\n  int i;\n\n  /* The options need to be applied first */\n  for (i = 0; i < ci->children_num; i++)\n  {\n    oconfig_item_t *child = ci->children + i;\n    if (strcasecmp (\"TimeToLive\", child->key) == 0)\n      network_config_set_ttl (child);\n  }\n\n  for (i = 0; i < ci->children_num; i++)\n  {\n    oconfig_item_t *child = ci->children + i;\n\n    if (strcasecmp (\"Listen\", child->key) == 0)\n      network_config_add_listen (child);\n    else if (strcasecmp (\"Server\", child->key) == 0)\n      network_config_add_server (child);\n    else if (strcasecmp (\"TimeToLive\", child->key) == 0) {\n      /* Handled earlier */\n    }\n    else if (strcasecmp (\"MaxPacketSize\", child->key) == 0)\n      network_config_set_buffer_size (child);\n    else if (strcasecmp (\"Forward\", child->key) == 0)\n      network_config_set_boolean (child, &network_config_forward);\n    else if (strcasecmp (\"ReportStats\", child->key) == 0)\n      network_config_set_boolean (child, &network_config_stats);\n    else\n    {\n      WARNING (\"network plugin: Option `%s' is not allowed here.\",\n          child->key);\n    }\n  }\n\n  return (0);\n} /* }}} int network_config */\n\nstatic int network_notification (const notification_t *n,\n    user_data_t __attribute__((unused)) *user_data)\n{\n  char  buffer[network_config_packet_size];\n  char *buffer_ptr = buffer;\n  int   buffer_free = sizeof (buffer);\n  int   status;\n\n  if (!check_send_notify_okay (n))\n    return (0);\n\n  memset (buffer, 0, sizeof (buffer));\n\n  status = write_part_number (&buffer_ptr, &buffer_free, TYPE_TIME_HR,\n      (uint64_t) n->time);\n  if (status != 0)\n    return (-1);\n\n  status = write_part_number (&buffer_ptr, &buffer_free, TYPE_SEVERITY,\n      (uint64_t) n->severity);\n  if (status != 0)\n    return (-1);\n\n  if (strlen (n->host) > 0)\n  {\n    status = write_part_string (&buffer_ptr, &buffer_free, TYPE_HOST,\n        n->host, strlen (n->host));\n    if (status != 0)\n      return (-1);\n  }\n\n  if (strlen (n->plugin) > 0)\n  {\n    status = write_part_string (&buffer_ptr, &buffer_free, TYPE_PLUGIN,\n        n->plugin, strlen (n->plugin));\n    if (status != 0)\n      return (-1);\n  }\n\n  if (strlen (n->plugin_instance) > 0)\n  {\n    status = write_part_string (&buffer_ptr, &buffer_free,\n        TYPE_PLUGIN_INSTANCE,\n        n->plugin_instance, strlen (n->plugin_instance));\n    if (status != 0)\n      return (-1);\n  }\n\n  if (strlen (n->type) > 0)\n  {\n    status = write_part_string (&buffer_ptr, &buffer_free, TYPE_TYPE,\n        n->type, strlen (n->type));\n    if (status != 0)\n      return (-1);\n  }\n\n  if (strlen (n->type_instance) > 0)\n  {\n    status = write_part_string (&buffer_ptr, &buffer_free, TYPE_TYPE_INSTANCE,\n        n->type_instance, strlen (n->type_instance));\n    if (status != 0)\n      return (-1);\n  }\n\n  status = write_part_string (&buffer_ptr, &buffer_free, TYPE_MESSAGE,\n      n->message, strlen (n->message));\n  if (status != 0)\n    return (-1);\n\n  network_send_buffer (buffer, sizeof (buffer) - buffer_free);\n\n  return (0);\n} /* int network_notification */\n\nstatic int network_shutdown (void)\n{\n\tsockent_t *se;\n\n\tlisten_loop++;\n\n\t/* Kill the listening thread */\n\tif (receive_thread_running != 0)\n\t{\n\t\tINFO (\"network plugin: Stopping receive thread.\");\n\t\tpthread_kill (receive_thread_id, SIGTERM);\n\t\tpthread_join (receive_thread_id, NULL /* no return value */);\n\t\tmemset (&receive_thread_id, 0, sizeof (receive_thread_id));\n\t\treceive_thread_running = 0;\n\t}\n\n\t/* Shutdown the dispatching thread */\n\tif (dispatch_thread_running != 0)\n\t{\n\t\tINFO (\"network plugin: Stopping dispatch thread.\");\n\t\tpthread_mutex_lock (&receive_list_lock);\n\t\tpthread_cond_broadcast (&receive_list_cond);\n\t\tpthread_mutex_unlock (&receive_list_lock);\n\t\tpthread_join (dispatch_thread_id, /* ret = */ NULL);\n\t\tdispatch_thread_running = 0;\n\t}\n\n\tsockent_destroy (listen_sockets);\n\n\tif (send_buffer_fill > 0)\n\t\tflush_buffer ();\n\n\tsfree (send_buffer);\n\n\tfor (se = sending_sockets; se != NULL; se = se->next)\n\t\tsockent_client_disconnect (se);\n\tsockent_destroy (sending_sockets);\n\n\tplugin_unregister_config (\"network\");\n\tplugin_unregister_init (\"network\");\n\tplugin_unregister_write (\"network\");\n\tplugin_unregister_shutdown (\"network\");\n\n\treturn (0);\n} /* int network_shutdown */\n\nstatic int network_stats_read (void) /* {{{ */\n{\n\tderive_t copy_octets_rx;\n\tderive_t copy_octets_tx;\n\tderive_t copy_packets_rx;\n\tderive_t copy_packets_tx;\n\tderive_t copy_values_dispatched;\n\tderive_t copy_values_not_dispatched;\n\tderive_t copy_values_sent;\n\tderive_t copy_values_not_sent;\n\tderive_t copy_receive_list_length;\n\tvalue_list_t vl = VALUE_LIST_INIT;\n\tvalue_t values[2];\n\n\tcopy_octets_rx = stats_octets_rx;\n\tcopy_octets_tx = stats_octets_tx;\n\tcopy_packets_rx = stats_packets_rx;\n\tcopy_packets_tx = stats_packets_tx;\n\tcopy_values_dispatched = stats_values_dispatched;\n\tcopy_values_not_dispatched = stats_values_not_dispatched;\n\tcopy_values_sent = stats_values_sent;\n\tcopy_values_not_sent = stats_values_not_sent;\n\tcopy_receive_list_length = receive_list_length;\n\n\t/* Initialize `vl' */\n\tvl.values = values;\n\tvl.values_len = 2;\n\tvl.time = 0;\n\tsstrncpy (vl.host, hostname_g, sizeof (vl.host));\n\tsstrncpy (vl.plugin, \"network\", sizeof (vl.plugin));\n\n\t/* Octets received / sent */\n\tvl.values[0].derive = (derive_t) copy_octets_rx;\n\tvl.values[1].derive = (derive_t) copy_octets_tx;\n\tsstrncpy (vl.type, \"if_octets\", sizeof (vl.type));\n\tplugin_dispatch_values (&vl);\n\n\t/* Packets received / send */\n\tvl.values[0].derive = (derive_t) copy_packets_rx;\n\tvl.values[1].derive = (derive_t) copy_packets_tx;\n\tsstrncpy (vl.type, \"if_packets\", sizeof (vl.type));\n\tplugin_dispatch_values (&vl);\n\n\t/* Values (not) dispatched and (not) send */\n\tsstrncpy (vl.type, \"total_values\", sizeof (vl.type));\n\tvl.values_len = 1;\n\n\tvl.values[0].derive = (derive_t) copy_values_dispatched;\n\tsstrncpy (vl.type_instance, \"dispatch-accepted\",\n\t\t\tsizeof (vl.type_instance));\n\tplugin_dispatch_values (&vl);\n\n\tvl.values[0].derive = (derive_t) copy_values_not_dispatched;\n\tsstrncpy (vl.type_instance, \"dispatch-rejected\",\n\t\t\tsizeof (vl.type_instance));\n\tplugin_dispatch_values (&vl);\n\n\tvl.values[0].derive = (derive_t) copy_values_sent;\n\tsstrncpy (vl.type_instance, \"send-accepted\",\n\t\t\tsizeof (vl.type_instance));\n\tplugin_dispatch_values (&vl);\n\n\tvl.values[0].derive = (derive_t) copy_values_not_sent;\n\tsstrncpy (vl.type_instance, \"send-rejected\",\n\t\t\tsizeof (vl.type_instance));\n\tplugin_dispatch_values (&vl);\n\n\t/* Receive queue length */\n\tvl.values[0].gauge = (gauge_t) copy_receive_list_length;\n\tsstrncpy (vl.type, \"queue_length\", sizeof (vl.type));\n\tvl.type_instance[0] = 0;\n\tplugin_dispatch_values (&vl);\n\n\treturn (0);\n} /* }}} int network_stats_read */\n\nstatic int network_init (void)\n{\n\tstatic _Bool have_init = 0;\n\n\t/* Check if we were already initialized. If so, just return - there's\n\t * nothing more to do (for now, that is). */\n\tif (have_init)\n\t\treturn (0);\n\thave_init = 1;\n\n#if HAVE_LIBGCRYPT\n\tnetwork_init_gcrypt ();\n#endif\n\n\tif (network_config_stats != 0)\n\t\tplugin_register_read (\"network\", network_stats_read);\n\n\tplugin_register_shutdown (\"network\", network_shutdown);\n\n\tsend_buffer = malloc (network_config_packet_size);\n\tif (send_buffer == NULL)\n\t{\n\t\tERROR (\"network plugin: malloc failed.\");\n\t\treturn (-1);\n\t}\n\tnetwork_init_buffer ();\n\n\t/* setup socket(s) and so on */\n\tif (sending_sockets != NULL)\n\t{\n\t\tplugin_register_write (\"network\", network_write,\n\t\t\t\t/* user_data = */ NULL);\n\t\tplugin_register_notification (\"network\", network_notification,\n\t\t\t\t/* user_data = */ NULL);\n\t}\n\n\t/* If no threads need to be started, return here. */\n\tif ((listen_sockets_num == 0)\n\t\t\t|| ((dispatch_thread_running != 0)\n\t\t\t\t&& (receive_thread_running != 0)))\n\t\treturn (0);\n\n\tif (dispatch_thread_running == 0)\n\t{\n\t\tint status;\n\t\tstatus = plugin_thread_create (&dispatch_thread_id,\n\t\t\t\tNULL /* no attributes */,\n\t\t\t\tdispatch_thread,\n\t\t\t\tNULL /* no argument */);\n\t\tif (status != 0)\n\t\t{\n\t\t\tchar errbuf[1024];\n\t\t\tERROR (\"network: pthread_create failed: %s\",\n\t\t\t\t\tsstrerror (errno, errbuf,\n\t\t\t\t\t\tsizeof (errbuf)));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tdispatch_thread_running = 1;\n\t\t}\n\t}\n\n\tif (receive_thread_running == 0)\n\t{\n\t\tint status;\n\t\tstatus = plugin_thread_create (&receive_thread_id,\n\t\t\t\tNULL /* no attributes */,\n\t\t\t\treceive_thread,\n\t\t\t\tNULL /* no argument */);\n\t\tif (status != 0)\n\t\t{\n\t\t\tchar errbuf[1024];\n\t\t\tERROR (\"network: pthread_create failed: %s\",\n\t\t\t\t\tsstrerror (errno, errbuf,\n\t\t\t\t\t\tsizeof (errbuf)));\n\t\t}\n\t\telse\n\t\t{\n\t\t\treceive_thread_running = 1;\n\t\t}\n\t}\n\n\treturn (0);\n} /* int network_init */\n\n/*\n * The flush option of the network plugin cannot flush individual identifiers.\n * All the values are added to a buffer and sent when the buffer is full, the\n * requested value may or may not be in there, it's not worth finding out. We\n * just send the buffer if `flush'  is called - if the requested value was in\n * there, good. If not, well, then there is nothing to flush.. -octo\n */\nstatic int network_flush (__attribute__((unused)) cdtime_t timeout,\n\t\t__attribute__((unused)) const char *identifier,\n\t\t__attribute__((unused)) user_data_t *user_data)\n{\n\tpthread_mutex_lock (&send_buffer_lock);\n\n\tif (send_buffer_fill > 0)\n\t  flush_buffer ();\n\n\tpthread_mutex_unlock (&send_buffer_lock);\n\n\treturn (0);\n} /* int network_flush */\n\nvoid module_register (void)\n{\n\tplugin_register_complex_config (\"network\", network_config);\n\tplugin_register_init   (\"network\", network_init);\n\tplugin_register_flush   (\"network\", network_flush,\n\t\t\t/* user_data = */ NULL);\n} /* void module_register */\n\n/* vim: set fdm=marker : */\n"], "filenames": ["src/network.c"], "buggy_code_start_loc": [1437], "buggy_code_end_loc": [1605], "fixing_code_start_loc": [1438], "fixing_code_end_loc": [1609], "type": "CWE-119", "message": "Heap-based buffer overflow in the parse_packet function in network.c in collectd before 5.4.3 and 5.x before 5.5.2 allows remote attackers to cause a denial of service (daemon crash) or possibly execute arbitrary code via a crafted network packet.", "other": {"cve": {"id": "CVE-2016-6254", "sourceIdentifier": "cve@mitre.org", "published": "2016-08-19T21:59:13.290", "lastModified": "2019-03-04T17:42:12.480", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Heap-based buffer overflow in the parse_packet function in network.c in collectd before 5.4.3 and 5.x before 5.5.2 allows remote attackers to cause a denial of service (daemon crash) or possibly execute arbitrary code via a crafted network packet."}, {"lang": "es", "value": "Desbordamiento de b\u00fafer basado en memoria din\u00e1mica en la funci\u00f3n parse_packet en network.c en collectd en versiones anteriores a 5.4.3 y 5.x en versiones anteriores a 5.5.2 permite a atacantes remotos provocar una denegaci\u00f3n de servicio (ca\u00edda del demonio) o posiblemente ejecutar c\u00f3digo arbitrario a trav\u00e9s de un paquete de red manipulado."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.1, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.2}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.4}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-119"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:collectd:collectd:*:*:*:*:*:*:*:*", "versionStartIncluding": "5.4.0", "versionEndExcluding": "5.4.3", "matchCriteriaId": "83879687-A7BB-4BDF-B915-5BD9C3205EFD"}, {"vulnerable": true, "criteria": "cpe:2.3:a:collectd:collectd:*:*:*:*:*:*:*:*", "versionStartIncluding": "5.5.0", "versionEndExcluding": "5.5.2", "matchCriteriaId": "2940A599-26F7-4B25-B376-8C619EEAD082"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:23:*:*:*:*:*:*:*", "matchCriteriaId": "E79AB8DD-C907-4038-A931-1A5A4CFB6A5B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:24:*:*:*:*:*:*:*", "matchCriteriaId": "C729D5D1-ED95-443A-9F53-5D7C2FD9B80C"}]}]}], "references": [{"url": "http://collectd.org/news.shtml", "source": "cve@mitre.org", "tags": ["Release Notes", "Vendor Advisory"]}, {"url": "http://www.debian.org/security/2016/dsa-3636", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/collectd/collectd/commit/b589096f907052b3a4da2b9ccc9b0e2e888dfc18", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/CM4W5SJ4OTBGINGIN4NJLXCUZAZANO6J/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/UIZ5UXDOB7BA5NGE2F2I2BL4K6763DHW/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/collectd/collectd/commit/b589096f907052b3a4da2b9ccc9b0e2e888dfc18"}}