{"buggy_code": ["/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * Handling of regular expressions: vim_regcomp(), vim_regexec(), vim_regsub()\n */\n\n// By default: do not create debugging logs or files related to regular\n// expressions, even when compiling with -DDEBUG.\n// Uncomment the second line to get the regexp debugging.\n#undef DEBUG\n// #define DEBUG\n\n#include \"vim.h\"\n\n#ifdef DEBUG\n// show/save debugging data when BT engine is used\n# define BT_REGEXP_DUMP\n// save the debugging data to a file instead of displaying it\n# define BT_REGEXP_LOG\n# define BT_REGEXP_DEBUG_LOG\n# define BT_REGEXP_DEBUG_LOG_NAME\t\"bt_regexp_debug.log\"\n#endif\n\n#ifdef FEAT_RELTIME\nstatic sig_atomic_t dummy_timeout_flag = 0;\nstatic volatile sig_atomic_t *timeout_flag = &dummy_timeout_flag;\n#endif\n\n/*\n * Magic characters have a special meaning, they don't match literally.\n * Magic characters are negative.  This separates them from literal characters\n * (possibly multi-byte).  Only ASCII characters can be Magic.\n */\n#define Magic(x)\t((int)(x) - 256)\n#define un_Magic(x)\t((x) + 256)\n#define is_Magic(x)\t((x) < 0)\n\n    static int\nno_Magic(int x)\n{\n    if (is_Magic(x))\n\treturn un_Magic(x);\n    return x;\n}\n\n    static int\ntoggle_Magic(int x)\n{\n    if (is_Magic(x))\n\treturn un_Magic(x);\n    return Magic(x);\n}\n\n#ifdef FEAT_RELTIME\nstatic int timeout_nesting = 0;\n\n/*\n * Start a timer that will cause the regexp to abort after \"msec\".\n * This doesn't work well recursively.  In case it happens anyway, the first\n * set timeout will prevail, nested ones are ignored.\n * The caller must make sure there is a matching disable_regexp_timeout() call!\n */\n    void\ninit_regexp_timeout(long msec)\n{\n    if (timeout_nesting == 0)\n\ttimeout_flag = start_timeout(msec);\n    ++timeout_nesting;\n}\n\n    void\ndisable_regexp_timeout(void)\n{\n    if (timeout_nesting == 0)\n\tiemsg(\"disable_regexp_timeout() called without active timer\");\n    else if (--timeout_nesting == 0)\n    {\n\tstop_timeout();\n\ttimeout_flag = &dummy_timeout_flag;\n    }\n}\n#endif\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n# ifdef FEAT_RELTIME\nstatic sig_atomic_t *saved_timeout_flag;\n# endif\n\n/*\n * Used at the debug prompt: disable the timeout so that expression evaluation\n * can used patterns.\n * Must be followed by calling restore_timeout_for_debugging().\n */\n    void\nsave_timeout_for_debugging(void)\n{\n# ifdef FEAT_RELTIME\n    saved_timeout_flag = (sig_atomic_t *)timeout_flag;\n    timeout_flag = &dummy_timeout_flag;\n# endif\n}\n\n    void\nrestore_timeout_for_debugging(void)\n{\n# ifdef FEAT_RELTIME\n    timeout_flag = saved_timeout_flag;\n# endif\n}\n#endif\n\n/*\n * The first byte of the BT regexp internal \"program\" is actually this magic\n * number; the start node begins in the second byte.  It's used to catch the\n * most severe mutilation of the program by the caller.\n */\n\n#define REGMAGIC\t0234\n\n/*\n * Utility definitions.\n */\n#define UCHARAT(p)\t((int)*(char_u *)(p))\n\n// Used for an error (down from) vim_regcomp(): give the error message, set\n// rc_did_emsg and return NULL\n#define EMSG_RET_NULL(m) return (emsg((m)), rc_did_emsg = TRUE, (void *)NULL)\n#define IEMSG_RET_NULL(m) return (iemsg((m)), rc_did_emsg = TRUE, (void *)NULL)\n#define EMSG_RET_FAIL(m) return (emsg((m)), rc_did_emsg = TRUE, FAIL)\n#define EMSG2_RET_NULL(m, c) return (semsg((const char *)(m), (c) ? \"\" : \"\\\\\"), rc_did_emsg = TRUE, (void *)NULL)\n#define EMSG3_RET_NULL(m, c, a) return (semsg((const char *)(m), (c) ? \"\" : \"\\\\\", (a)), rc_did_emsg = TRUE, (void *)NULL)\n#define EMSG2_RET_FAIL(m, c) return (semsg((const char *)(m), (c) ? \"\" : \"\\\\\"), rc_did_emsg = TRUE, FAIL)\n#define EMSG_ONE_RET_NULL EMSG2_RET_NULL(_(e_invalid_item_in_str_brackets), reg_magic == MAGIC_ALL)\n\n\n#define MAX_LIMIT\t(32767L << 16L)\n\n#define NOT_MULTI\t0\n#define MULTI_ONE\t1\n#define MULTI_MULT\t2\n\n// return values for regmatch()\n#define RA_FAIL\t\t1\t// something failed, abort\n#define RA_CONT\t\t2\t// continue in inner loop\n#define RA_BREAK\t3\t// break inner loop\n#define RA_MATCH\t4\t// successful match\n#define RA_NOMATCH\t5\t// didn't match\n\n/*\n * Return NOT_MULTI if c is not a \"multi\" operator.\n * Return MULTI_ONE if c is a single \"multi\" operator.\n * Return MULTI_MULT if c is a multi \"multi\" operator.\n */\n    static int\nre_multi_type(int c)\n{\n    if (c == Magic('@') || c == Magic('=') || c == Magic('?'))\n\treturn MULTI_ONE;\n    if (c == Magic('*') || c == Magic('+') || c == Magic('{'))\n\treturn MULTI_MULT;\n    return NOT_MULTI;\n}\n\nstatic char_u\t\t*reg_prev_sub = NULL;\n\n/*\n * REGEXP_INRANGE contains all characters which are always special in a []\n * range after '\\'.\n * REGEXP_ABBR contains all characters which act as abbreviations after '\\'.\n * These are:\n *  \\n\t- New line (NL).\n *  \\r\t- Carriage Return (CR).\n *  \\t\t- Tab (TAB).\n *  \\e\t- Escape (ESC).\n *  \\b\t- Backspace (Ctrl_H).\n *  \\d  - Character code in decimal, eg \\d123\n *  \\o\t- Character code in octal, eg \\o80\n *  \\x\t- Character code in hex, eg \\x4a\n *  \\u\t- Multibyte character code, eg \\u20ac\n *  \\U\t- Long multibyte character code, eg \\U12345678\n */\nstatic char_u REGEXP_INRANGE[] = \"]^-n\\\\\";\nstatic char_u REGEXP_ABBR[] = \"nrtebdoxuU\";\n\n/*\n * Translate '\\x' to its control character, except \"\\n\", which is Magic.\n */\n    static int\nbackslash_trans(int c)\n{\n    switch (c)\n    {\n\tcase 'r':   return CAR;\n\tcase 't':   return TAB;\n\tcase 'e':   return ESC;\n\tcase 'b':   return BS;\n    }\n    return c;\n}\n\n/*\n * Check for a character class name \"[:name:]\".  \"pp\" points to the '['.\n * Returns one of the CLASS_ items. CLASS_NONE means that no item was\n * recognized.  Otherwise \"pp\" is advanced to after the item.\n */\n    static int\nget_char_class(char_u **pp)\n{\n    static const char *(class_names[]) =\n    {\n\t\"alnum:]\",\n#define CLASS_ALNUM 0\n\t\"alpha:]\",\n#define CLASS_ALPHA 1\n\t\"blank:]\",\n#define CLASS_BLANK 2\n\t\"cntrl:]\",\n#define CLASS_CNTRL 3\n\t\"digit:]\",\n#define CLASS_DIGIT 4\n\t\"graph:]\",\n#define CLASS_GRAPH 5\n\t\"lower:]\",\n#define CLASS_LOWER 6\n\t\"print:]\",\n#define CLASS_PRINT 7\n\t\"punct:]\",\n#define CLASS_PUNCT 8\n\t\"space:]\",\n#define CLASS_SPACE 9\n\t\"upper:]\",\n#define CLASS_UPPER 10\n\t\"xdigit:]\",\n#define CLASS_XDIGIT 11\n\t\"tab:]\",\n#define CLASS_TAB 12\n\t\"return:]\",\n#define CLASS_RETURN 13\n\t\"backspace:]\",\n#define CLASS_BACKSPACE 14\n\t\"escape:]\",\n#define CLASS_ESCAPE 15\n\t\"ident:]\",\n#define CLASS_IDENT 16\n\t\"keyword:]\",\n#define CLASS_KEYWORD 17\n\t\"fname:]\",\n#define CLASS_FNAME 18\n    };\n#define CLASS_NONE 99\n    int i;\n\n    if ((*pp)[1] == ':')\n    {\n\tfor (i = 0; i < (int)ARRAY_LENGTH(class_names); ++i)\n\t    if (STRNCMP(*pp + 2, class_names[i], STRLEN(class_names[i])) == 0)\n\t    {\n\t\t*pp += STRLEN(class_names[i]) + 2;\n\t\treturn i;\n\t    }\n    }\n    return CLASS_NONE;\n}\n\n/*\n * Specific version of character class functions.\n * Using a table to keep this fast.\n */\nstatic short\tclass_tab[256];\n\n#define\t    RI_DIGIT\t0x01\n#define\t    RI_HEX\t0x02\n#define\t    RI_OCTAL\t0x04\n#define\t    RI_WORD\t0x08\n#define\t    RI_HEAD\t0x10\n#define\t    RI_ALPHA\t0x20\n#define\t    RI_LOWER\t0x40\n#define\t    RI_UPPER\t0x80\n#define\t    RI_WHITE\t0x100\n\n    static void\ninit_class_tab(void)\n{\n    int\t\ti;\n    static int\tdone = FALSE;\n\n    if (done)\n\treturn;\n\n    for (i = 0; i < 256; ++i)\n    {\n\tif (i >= '0' && i <= '7')\n\t    class_tab[i] = RI_DIGIT + RI_HEX + RI_OCTAL + RI_WORD;\n\telse if (i >= '8' && i <= '9')\n\t    class_tab[i] = RI_DIGIT + RI_HEX + RI_WORD;\n\telse if (i >= 'a' && i <= 'f')\n\t    class_tab[i] = RI_HEX + RI_WORD + RI_HEAD + RI_ALPHA + RI_LOWER;\n\telse if (i >= 'g' && i <= 'z')\n\t    class_tab[i] = RI_WORD + RI_HEAD + RI_ALPHA + RI_LOWER;\n\telse if (i >= 'A' && i <= 'F')\n\t    class_tab[i] = RI_HEX + RI_WORD + RI_HEAD + RI_ALPHA + RI_UPPER;\n\telse if (i >= 'G' && i <= 'Z')\n\t    class_tab[i] = RI_WORD + RI_HEAD + RI_ALPHA + RI_UPPER;\n\telse if (i == '_')\n\t    class_tab[i] = RI_WORD + RI_HEAD;\n\telse\n\t    class_tab[i] = 0;\n    }\n    class_tab[' '] |= RI_WHITE;\n    class_tab['\\t'] |= RI_WHITE;\n    done = TRUE;\n}\n\n#define ri_digit(c)\t((c) < 0x100 && (class_tab[c] & RI_DIGIT))\n#define ri_hex(c)\t((c) < 0x100 && (class_tab[c] & RI_HEX))\n#define ri_octal(c)\t((c) < 0x100 && (class_tab[c] & RI_OCTAL))\n#define ri_word(c)\t((c) < 0x100 && (class_tab[c] & RI_WORD))\n#define ri_head(c)\t((c) < 0x100 && (class_tab[c] & RI_HEAD))\n#define ri_alpha(c)\t((c) < 0x100 && (class_tab[c] & RI_ALPHA))\n#define ri_lower(c)\t((c) < 0x100 && (class_tab[c] & RI_LOWER))\n#define ri_upper(c)\t((c) < 0x100 && (class_tab[c] & RI_UPPER))\n#define ri_white(c)\t((c) < 0x100 && (class_tab[c] & RI_WHITE))\n\n// flags for regflags\n#define RF_ICASE    1\t// ignore case\n#define RF_NOICASE  2\t// don't ignore case\n#define RF_HASNL    4\t// can match a NL\n#define RF_ICOMBINE 8\t// ignore combining characters\n#define RF_LOOKBH   16\t// uses \"\\@<=\" or \"\\@<!\"\n\n/*\n * Global work variables for vim_regcomp().\n */\n\nstatic char_u\t*regparse;\t// Input-scan pointer.\nstatic int\tregnpar;\t// () count.\nstatic int\twants_nfa;\t// regex should use NFA engine\n#ifdef FEAT_SYN_HL\nstatic int\tregnzpar;\t// \\z() count.\nstatic int\tre_has_z;\t// \\z item detected\n#endif\nstatic unsigned\tregflags;\t// RF_ flags for prog\n#if defined(FEAT_SYN_HL) || defined(PROTO)\nstatic int\thad_eol;\t// TRUE when EOL found by vim_regcomp()\n#endif\n\nstatic magic_T\treg_magic;\t// magicness of the pattern\n\nstatic int\treg_string;\t// matching with a string instead of a buffer\n\t\t\t\t// line\nstatic int\treg_strict;\t// \"[abc\" is illegal\n\n/*\n * META contains all characters that may be magic, except '^' and '$'.\n */\n\n// META[] is used often enough to justify turning it into a table.\nstatic char_u META_flags[] = {\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n//\t\t   %  &     (  )  *  +\t      .\n    0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 1, 0,\n//     1  2  3\t4  5  6  7  8  9\t<  =  >  ?\n    0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1,\n//  @  A     C\tD     F     H  I     K\tL  M\t O\n    1, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 0, 1,\n//  P\t     S\t   U  V  W  X\t  Z  [\t\t _\n    1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1,\n//     a     c\td     f     h  i     k\tl  m  n  o\n    0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1,\n//  p\t     s\t   u  v  w  x\t  z  {\t|     ~\n    1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1\n};\n\nstatic int\tcurchr;\t\t// currently parsed character\n// Previous character.  Note: prevchr is sometimes -1 when we are not at the\n// start, eg in /[ ^I]^ the pattern was never found even if it existed,\n// because ^ was taken to be magic -- webb\nstatic int\tprevchr;\nstatic int\tprevprevchr;\t// previous-previous character\nstatic int\tnextchr;\t// used for ungetchr()\n\n// arguments for reg()\n#define REG_NOPAREN\t0\t// toplevel reg()\n#define REG_PAREN\t1\t// \\(\\)\n#define REG_ZPAREN\t2\t// \\z(\\)\n#define REG_NPAREN\t3\t// \\%(\\)\n\ntypedef struct\n{\n     char_u\t*regparse;\n     int\tprevchr_len;\n     int\tcurchr;\n     int\tprevchr;\n     int\tprevprevchr;\n     int\tnextchr;\n     int\tat_start;\n     int\tprev_at_start;\n     int\tregnpar;\n} parse_state_T;\n\nstatic void\tinitchr(char_u *);\nstatic int\tgetchr(void);\nstatic void\tskipchr_keepstart(void);\nstatic int\tpeekchr(void);\nstatic void\tskipchr(void);\nstatic void\tungetchr(void);\nstatic long\tgethexchrs(int maxinputlen);\nstatic long\tgetoctchrs(void);\nstatic long\tgetdecchrs(void);\nstatic int\tcoll_get_char(void);\nstatic int\tprog_magic_wrong(void);\nstatic int\tcstrncmp(char_u *s1, char_u *s2, int *n);\nstatic char_u\t*cstrchr(char_u *, int);\nstatic int\tre_mult_next(char *what);\nstatic int\treg_iswordc(int);\n#ifdef FEAT_EVAL\nstatic void report_re_switch(char_u *pat);\n#endif\n\nstatic regengine_T bt_regengine;\nstatic regengine_T nfa_regengine;\n\n/*\n * Return TRUE if compiled regular expression \"prog\" can match a line break.\n */\n    int\nre_multiline(regprog_T *prog)\n{\n    return (prog->regflags & RF_HASNL);\n}\n\n/*\n * Check for an equivalence class name \"[=a=]\".  \"pp\" points to the '['.\n * Returns a character representing the class. Zero means that no item was\n * recognized.  Otherwise \"pp\" is advanced to after the item.\n */\n    static int\nget_equi_class(char_u **pp)\n{\n    int\t\tc;\n    int\t\tl = 1;\n    char_u\t*p = *pp;\n\n    if (p[1] == '=' && p[2] != NUL)\n    {\n\tif (has_mbyte)\n\t    l = (*mb_ptr2len)(p + 2);\n\tif (p[l + 2] == '=' && p[l + 3] == ']')\n\t{\n\t    if (has_mbyte)\n\t\tc = mb_ptr2char(p + 2);\n\t    else\n\t\tc = p[2];\n\t    *pp += l + 4;\n\t    return c;\n\t}\n    }\n    return 0;\n}\n\n/*\n * Check for a collating element \"[.a.]\".  \"pp\" points to the '['.\n * Returns a character. Zero means that no item was recognized.  Otherwise\n * \"pp\" is advanced to after the item.\n * Currently only single characters are recognized!\n */\n    static int\nget_coll_element(char_u **pp)\n{\n    int\t\tc;\n    int\t\tl = 1;\n    char_u\t*p = *pp;\n\n    if (p[0] != NUL && p[1] == '.' && p[2] != NUL)\n    {\n\tif (has_mbyte)\n\t    l = (*mb_ptr2len)(p + 2);\n\tif (p[l + 2] == '.' && p[l + 3] == ']')\n\t{\n\t    if (has_mbyte)\n\t\tc = mb_ptr2char(p + 2);\n\t    else\n\t\tc = p[2];\n\t    *pp += l + 4;\n\t    return c;\n\t}\n    }\n    return 0;\n}\n\nstatic int reg_cpo_lit; // 'cpoptions' contains 'l' flag\nstatic int reg_cpo_bsl; // 'cpoptions' contains '\\' flag\n\n    static void\nget_cpo_flags(void)\n{\n    reg_cpo_lit = vim_strchr(p_cpo, CPO_LITERAL) != NULL;\n    reg_cpo_bsl = vim_strchr(p_cpo, CPO_BACKSL) != NULL;\n}\n\n/*\n * Skip over a \"[]\" range.\n * \"p\" must point to the character after the '['.\n * The returned pointer is on the matching ']', or the terminating NUL.\n */\n    static char_u *\nskip_anyof(char_u *p)\n{\n    int\t\tl;\n\n    if (*p == '^')\t// Complement of range.\n\t++p;\n    if (*p == ']' || *p == '-')\n\t++p;\n    while (*p != NUL && *p != ']')\n    {\n\tif (has_mbyte && (l = (*mb_ptr2len)(p)) > 1)\n\t    p += l;\n\telse\n\t    if (*p == '-')\n\t    {\n\t\t++p;\n\t\tif (*p != ']' && *p != NUL)\n\t\t    MB_PTR_ADV(p);\n\t    }\n\telse if (*p == '\\\\'\n\t\t&& !reg_cpo_bsl\n\t\t&& (vim_strchr(REGEXP_INRANGE, p[1]) != NULL\n\t\t    || (!reg_cpo_lit && vim_strchr(REGEXP_ABBR, p[1]) != NULL)))\n\t    p += 2;\n\telse if (*p == '[')\n\t{\n\t    if (get_char_class(&p) == CLASS_NONE\n\t\t    && get_equi_class(&p) == 0\n\t\t    && get_coll_element(&p) == 0\n\t\t    && *p != NUL)\n\t\t++p; // it is not a class name and not NUL\n\t}\n\telse\n\t    ++p;\n    }\n\n    return p;\n}\n\n/*\n * Skip past regular expression.\n * Stop at end of \"startp\" or where \"delim\" is found ('/', '?', etc).\n * Take care of characters with a backslash in front of it.\n * Skip strings inside [ and ].\n */\n    char_u *\nskip_regexp(\n    char_u\t*startp,\n    int\t\tdelim,\n    int\t\tmagic)\n{\n    return skip_regexp_ex(startp, delim, magic, NULL, NULL, NULL);\n}\n\n/*\n * Call skip_regexp() and when the delimiter does not match give an error and\n * return NULL.\n */\n    char_u *\nskip_regexp_err(\n    char_u\t*startp,\n    int\t\tdelim,\n    int\t\tmagic)\n{\n    char_u *p = skip_regexp(startp, delim, magic);\n\n    if (*p != delim)\n    {\n\tsemsg(_(e_missing_delimiter_after_search_pattern_str), startp);\n\treturn NULL;\n    }\n    return p;\n}\n\n/*\n * skip_regexp() with extra arguments:\n * When \"newp\" is not NULL and \"dirc\" is '?', make an allocated copy of the\n * expression and change \"\\?\" to \"?\".  If \"*newp\" is not NULL the expression\n * is changed in-place.\n * If a \"\\?\" is changed to \"?\" then \"dropped\" is incremented, unless NULL.\n * If \"magic_val\" is not NULL, returns the effective magicness of the pattern\n */\n    char_u *\nskip_regexp_ex(\n    char_u\t*startp,\n    int\t\tdirc,\n    int\t\tmagic,\n    char_u\t**newp,\n    int\t\t*dropped,\n    magic_T\t*magic_val)\n{\n    magic_T\tmymagic;\n    char_u\t*p = startp;\n\n    if (magic)\n\tmymagic = MAGIC_ON;\n    else\n\tmymagic = MAGIC_OFF;\n    get_cpo_flags();\n\n    for (; p[0] != NUL; MB_PTR_ADV(p))\n    {\n\tif (p[0] == dirc)\t// found end of regexp\n\t    break;\n\tif ((p[0] == '[' && mymagic >= MAGIC_ON)\n\t\t|| (p[0] == '\\\\' && p[1] == '[' && mymagic <= MAGIC_OFF))\n\t{\n\t    p = skip_anyof(p + 1);\n\t    if (p[0] == NUL)\n\t\tbreak;\n\t}\n\telse if (p[0] == '\\\\' && p[1] != NUL)\n\t{\n\t    if (dirc == '?' && newp != NULL && p[1] == '?')\n\t    {\n\t\t// change \"\\?\" to \"?\", make a copy first.\n\t\tif (*newp == NULL)\n\t\t{\n\t\t    *newp = vim_strsave(startp);\n\t\t    if (*newp != NULL)\n\t\t\tp = *newp + (p - startp);\n\t\t}\n\t\tif (dropped != NULL)\n\t\t    ++*dropped;\n\t\tif (*newp != NULL)\n\t\t    STRMOVE(p, p + 1);\n\t\telse\n\t\t    ++p;\n\t    }\n\t    else\n\t\t++p;    // skip next character\n\t    if (*p == 'v')\n\t\tmymagic = MAGIC_ALL;\n\t    else if (*p == 'V')\n\t\tmymagic = MAGIC_NONE;\n\t}\n    }\n    if (magic_val != NULL)\n\t*magic_val = mymagic;\n    return p;\n}\n\n/*\n * Functions for getting characters from the regexp input.\n */\nstatic int\tprevchr_len;\t// byte length of previous char\nstatic int\tat_start;\t// True when on the first character\nstatic int\tprev_at_start;  // True when on the second character\n\n/*\n * Start parsing at \"str\".\n */\n    static void\ninitchr(char_u *str)\n{\n    regparse = str;\n    prevchr_len = 0;\n    curchr = prevprevchr = prevchr = nextchr = -1;\n    at_start = TRUE;\n    prev_at_start = FALSE;\n}\n\n/*\n * Save the current parse state, so that it can be restored and parsing\n * starts in the same state again.\n */\n    static void\nsave_parse_state(parse_state_T *ps)\n{\n    ps->regparse = regparse;\n    ps->prevchr_len = prevchr_len;\n    ps->curchr = curchr;\n    ps->prevchr = prevchr;\n    ps->prevprevchr = prevprevchr;\n    ps->nextchr = nextchr;\n    ps->at_start = at_start;\n    ps->prev_at_start = prev_at_start;\n    ps->regnpar = regnpar;\n}\n\n/*\n * Restore a previously saved parse state.\n */\n    static void\nrestore_parse_state(parse_state_T *ps)\n{\n    regparse = ps->regparse;\n    prevchr_len = ps->prevchr_len;\n    curchr = ps->curchr;\n    prevchr = ps->prevchr;\n    prevprevchr = ps->prevprevchr;\n    nextchr = ps->nextchr;\n    at_start = ps->at_start;\n    prev_at_start = ps->prev_at_start;\n    regnpar = ps->regnpar;\n}\n\n\n/*\n * Get the next character without advancing.\n */\n    static int\npeekchr(void)\n{\n    static int\tafter_slash = FALSE;\n\n    if (curchr != -1)\n\treturn curchr;\n\n    switch (curchr = regparse[0])\n    {\n\tcase '.':\n\tcase '[':\n\tcase '~':\n\t    // magic when 'magic' is on\n\t    if (reg_magic >= MAGIC_ON)\n\t\tcurchr = Magic(curchr);\n\t    break;\n\tcase '(':\n\tcase ')':\n\tcase '{':\n\tcase '%':\n\tcase '+':\n\tcase '=':\n\tcase '?':\n\tcase '@':\n\tcase '!':\n\tcase '&':\n\tcase '|':\n\tcase '<':\n\tcase '>':\n\tcase '#':\t// future ext.\n\tcase '\"':\t// future ext.\n\tcase '\\'':\t// future ext.\n\tcase ',':\t// future ext.\n\tcase '-':\t// future ext.\n\tcase ':':\t// future ext.\n\tcase ';':\t// future ext.\n\tcase '`':\t// future ext.\n\tcase '/':\t// Can't be used in / command\n\t\t\t// magic only after \"\\v\"\n\t    if (reg_magic == MAGIC_ALL)\n\t\tcurchr = Magic(curchr);\n\t    break;\n\tcase '*':\n\t    // * is not magic as the very first character, eg \"?*ptr\", when\n\t    // after '^', eg \"/^*ptr\" and when after \"\\(\", \"\\|\", \"\\&\".  But\n\t    // \"\\(\\*\" is not magic, thus must be magic if \"after_slash\"\n\t    if (reg_magic >= MAGIC_ON\n\t\t    && !at_start\n\t\t    && !(prev_at_start && prevchr == Magic('^'))\n\t\t    && (after_slash\n\t\t\t|| (prevchr != Magic('(')\n\t\t\t    && prevchr != Magic('&')\n\t\t\t    && prevchr != Magic('|'))))\n\t\tcurchr = Magic('*');\n\t    break;\n\tcase '^':\n\t    // '^' is only magic as the very first character and if it's after\n\t    // \"\\(\", \"\\|\", \"\\&' or \"\\n\"\n\t    if (reg_magic >= MAGIC_OFF\n\t\t    && (at_start\n\t\t\t|| reg_magic == MAGIC_ALL\n\t\t\t|| prevchr == Magic('(')\n\t\t\t|| prevchr == Magic('|')\n\t\t\t|| prevchr == Magic('&')\n\t\t\t|| prevchr == Magic('n')\n\t\t\t|| (no_Magic(prevchr) == '('\n\t\t\t    && prevprevchr == Magic('%'))))\n\t    {\n\t\tcurchr = Magic('^');\n\t\tat_start = TRUE;\n\t\tprev_at_start = FALSE;\n\t    }\n\t    break;\n\tcase '$':\n\t    // '$' is only magic as the very last char and if it's in front of\n\t    // either \"\\|\", \"\\)\", \"\\&\", or \"\\n\"\n\t    if (reg_magic >= MAGIC_OFF)\n\t    {\n\t\tchar_u *p = regparse + 1;\n\t\tint is_magic_all = (reg_magic == MAGIC_ALL);\n\n\t\t// ignore \\c \\C \\m \\M \\v \\V and \\Z after '$'\n\t\twhile (p[0] == '\\\\' && (p[1] == 'c' || p[1] == 'C'\n\t\t\t    || p[1] == 'm' || p[1] == 'M'\n\t\t\t    || p[1] == 'v' || p[1] == 'V' || p[1] == 'Z'))\n\t\t{\n\t\t    if (p[1] == 'v')\n\t\t\tis_magic_all = TRUE;\n\t\t    else if (p[1] == 'm' || p[1] == 'M' || p[1] == 'V')\n\t\t\tis_magic_all = FALSE;\n\t\t    p += 2;\n\t\t}\n\t\tif (p[0] == NUL\n\t\t\t|| (p[0] == '\\\\'\n\t\t\t    && (p[1] == '|' || p[1] == '&' || p[1] == ')'\n\t\t\t\t|| p[1] == 'n'))\n\t\t\t|| (is_magic_all\n\t\t\t    && (p[0] == '|' || p[0] == '&' || p[0] == ')'))\n\t\t\t|| reg_magic == MAGIC_ALL)\n\t\t    curchr = Magic('$');\n\t    }\n\t    break;\n\tcase '\\\\':\n\t    {\n\t\tint c = regparse[1];\n\n\t\tif (c == NUL)\n\t\t    curchr = '\\\\';\t// trailing '\\'\n\t\telse if (c <= '~' && META_flags[c])\n\t\t{\n\t\t    /*\n\t\t     * META contains everything that may be magic sometimes,\n\t\t     * except ^ and $ (\"\\^\" and \"\\$\" are only magic after\n\t\t     * \"\\V\").  We now fetch the next character and toggle its\n\t\t     * magicness.  Therefore, \\ is so meta-magic that it is\n\t\t     * not in META.\n\t\t     */\n\t\t    curchr = -1;\n\t\t    prev_at_start = at_start;\n\t\t    at_start = FALSE;\t// be able to say \"/\\*ptr\"\n\t\t    ++regparse;\n\t\t    ++after_slash;\n\t\t    peekchr();\n\t\t    --regparse;\n\t\t    --after_slash;\n\t\t    curchr = toggle_Magic(curchr);\n\t\t}\n\t\telse if (vim_strchr(REGEXP_ABBR, c))\n\t\t{\n\t\t    /*\n\t\t     * Handle abbreviations, like \"\\t\" for TAB -- webb\n\t\t     */\n\t\t    curchr = backslash_trans(c);\n\t\t}\n\t\telse if (reg_magic == MAGIC_NONE && (c == '$' || c == '^'))\n\t\t    curchr = toggle_Magic(c);\n\t\telse\n\t\t{\n\t\t    /*\n\t\t     * Next character can never be (made) magic?\n\t\t     * Then backslashing it won't do anything.\n\t\t     */\n\t\t    if (has_mbyte)\n\t\t\tcurchr = (*mb_ptr2char)(regparse + 1);\n\t\t    else\n\t\t\tcurchr = c;\n\t\t}\n\t\tbreak;\n\t    }\n\n\tdefault:\n\t    if (has_mbyte)\n\t\tcurchr = (*mb_ptr2char)(regparse);\n    }\n\n    return curchr;\n}\n\n/*\n * Eat one lexed character.  Do this in a way that we can undo it.\n */\n    static void\nskipchr(void)\n{\n    // peekchr() eats a backslash, do the same here\n    if (*regparse == '\\\\')\n\tprevchr_len = 1;\n    else\n\tprevchr_len = 0;\n    if (regparse[prevchr_len] != NUL)\n    {\n\tif (enc_utf8)\n\t    // exclude composing chars that mb_ptr2len does include\n\t    prevchr_len += utf_ptr2len(regparse + prevchr_len);\n\telse if (has_mbyte)\n\t    prevchr_len += (*mb_ptr2len)(regparse + prevchr_len);\n\telse\n\t    ++prevchr_len;\n    }\n    regparse += prevchr_len;\n    prev_at_start = at_start;\n    at_start = FALSE;\n    prevprevchr = prevchr;\n    prevchr = curchr;\n    curchr = nextchr;\t    // use previously unget char, or -1\n    nextchr = -1;\n}\n\n/*\n * Skip a character while keeping the value of prev_at_start for at_start.\n * prevchr and prevprevchr are also kept.\n */\n    static void\nskipchr_keepstart(void)\n{\n    int as = prev_at_start;\n    int pr = prevchr;\n    int prpr = prevprevchr;\n\n    skipchr();\n    at_start = as;\n    prevchr = pr;\n    prevprevchr = prpr;\n}\n\n/*\n * Get the next character from the pattern. We know about magic and such, so\n * therefore we need a lexical analyzer.\n */\n    static int\ngetchr(void)\n{\n    int chr = peekchr();\n\n    skipchr();\n    return chr;\n}\n\n/*\n * put character back.  Works only once!\n */\n    static void\nungetchr(void)\n{\n    nextchr = curchr;\n    curchr = prevchr;\n    prevchr = prevprevchr;\n    at_start = prev_at_start;\n    prev_at_start = FALSE;\n\n    // Backup regparse, so that it's at the same position as before the\n    // getchr().\n    regparse -= prevchr_len;\n}\n\n/*\n * Get and return the value of the hex string at the current position.\n * Return -1 if there is no valid hex number.\n * The position is updated:\n *     blahblah\\%x20asdf\n *\t   before-^ ^-after\n * The parameter controls the maximum number of input characters. This will be\n * 2 when reading a \\%x20 sequence and 4 when reading a \\%u20AC sequence.\n */\n    static long\ngethexchrs(int maxinputlen)\n{\n    long_u\tnr = 0;\n    int\t\tc;\n    int\t\ti;\n\n    for (i = 0; i < maxinputlen; ++i)\n    {\n\tc = regparse[0];\n\tif (!vim_isxdigit(c))\n\t    break;\n\tnr <<= 4;\n\tnr |= hex2nr(c);\n\t++regparse;\n    }\n\n    if (i == 0)\n\treturn -1;\n    return (long)nr;\n}\n\n/*\n * Get and return the value of the decimal string immediately after the\n * current position. Return -1 for invalid.  Consumes all digits.\n */\n    static long\ngetdecchrs(void)\n{\n    long_u\tnr = 0;\n    int\t\tc;\n    int\t\ti;\n\n    for (i = 0; ; ++i)\n    {\n\tc = regparse[0];\n\tif (c < '0' || c > '9')\n\t    break;\n\tnr *= 10;\n\tnr += c - '0';\n\t++regparse;\n\tcurchr = -1; // no longer valid\n    }\n\n    if (i == 0)\n\treturn -1;\n    return (long)nr;\n}\n\n/*\n * get and return the value of the octal string immediately after the current\n * position. Return -1 for invalid, or 0-255 for valid. Smart enough to handle\n * numbers > 377 correctly (for example, 400 is treated as 40) and doesn't\n * treat 8 or 9 as recognised characters. Position is updated:\n *     blahblah\\%o210asdf\n *\t   before-^  ^-after\n */\n    static long\ngetoctchrs(void)\n{\n    long_u\tnr = 0;\n    int\t\tc;\n    int\t\ti;\n\n    for (i = 0; i < 3 && nr < 040; ++i)\n    {\n\tc = regparse[0];\n\tif (c < '0' || c > '7')\n\t    break;\n\tnr <<= 3;\n\tnr |= hex2nr(c);\n\t++regparse;\n    }\n\n    if (i == 0)\n\treturn -1;\n    return (long)nr;\n}\n\n/*\n * read_limits - Read two integers to be taken as a minimum and maximum.\n * If the first character is '-', then the range is reversed.\n * Should end with 'end'.  If minval is missing, zero is default, if maxval is\n * missing, a very big number is the default.\n */\n    static int\nread_limits(long *minval, long *maxval)\n{\n    int\t\treverse = FALSE;\n    char_u\t*first_char;\n    long\ttmp;\n\n    if (*regparse == '-')\n    {\n\t// Starts with '-', so reverse the range later\n\tregparse++;\n\treverse = TRUE;\n    }\n    first_char = regparse;\n    *minval = getdigits(&regparse);\n    if (*regparse == ',')\t    // There is a comma\n    {\n\tif (vim_isdigit(*++regparse))\n\t    *maxval = getdigits(&regparse);\n\telse\n\t    *maxval = MAX_LIMIT;\n    }\n    else if (VIM_ISDIGIT(*first_char))\n\t*maxval = *minval;\t    // It was \\{n} or \\{-n}\n    else\n\t*maxval = MAX_LIMIT;\t    // It was \\{} or \\{-}\n    if (*regparse == '\\\\')\n\tregparse++;\t// Allow either \\{...} or \\{...\\}\n    if (*regparse != '}')\n\tEMSG2_RET_FAIL(_(e_syntax_error_in_str_curlies),\n\t\t\t\t\t\t       reg_magic == MAGIC_ALL);\n\n    /*\n     * Reverse the range if there was a '-', or make sure it is in the right\n     * order otherwise.\n     */\n    if ((!reverse && *minval > *maxval) || (reverse && *minval < *maxval))\n    {\n\ttmp = *minval;\n\t*minval = *maxval;\n\t*maxval = tmp;\n    }\n    skipchr();\t\t// let's be friends with the lexer again\n    return OK;\n}\n\n/*\n * vim_regexec and friends\n */\n\n/*\n * Global work variables for vim_regexec().\n */\n\nstatic void\tcleanup_subexpr(void);\n#ifdef FEAT_SYN_HL\nstatic void\tcleanup_zsubexpr(void);\n#endif\nstatic int\tmatch_with_backref(linenr_T start_lnum, colnr_T start_col, linenr_T end_lnum, colnr_T end_col, int *bytelen);\n\n/*\n * Sometimes need to save a copy of a line.  Since alloc()/free() is very\n * slow, we keep one allocated piece of memory and only re-allocate it when\n * it's too small.  It's freed in bt_regexec_both() when finished.\n */\nstatic char_u\t*reg_tofree = NULL;\nstatic unsigned\treg_tofreelen;\n\n/*\n * Structure used to store the execution state of the regex engine.\n * Which ones are set depends on whether a single-line or multi-line match is\n * done:\n *\t\t\tsingle-line\t\tmulti-line\n * reg_match\t\t&regmatch_T\t\tNULL\n * reg_mmatch\t\tNULL\t\t\t&regmmatch_T\n * reg_startp\t\treg_match->startp\t<invalid>\n * reg_endp\t\treg_match->endp\t\t<invalid>\n * reg_startpos\t\t<invalid>\t\treg_mmatch->startpos\n * reg_endpos\t\t<invalid>\t\treg_mmatch->endpos\n * reg_win\t\tNULL\t\t\twindow in which to search\n * reg_buf\t\tcurbuf\t\t\tbuffer in which to search\n * reg_firstlnum\t<invalid>\t\tfirst line in which to search\n * reg_maxline\t\t0\t\t\tlast line nr\n * reg_line_lbr\t\tFALSE or TRUE\t\tFALSE\n */\ntypedef struct {\n    regmatch_T\t\t*reg_match;\n    regmmatch_T\t\t*reg_mmatch;\n\n    char_u\t\t**reg_startp;\n    char_u\t\t**reg_endp;\n    lpos_T\t\t*reg_startpos;\n    lpos_T\t\t*reg_endpos;\n\n    win_T\t\t*reg_win;\n    buf_T\t\t*reg_buf;\n    linenr_T\t\treg_firstlnum;\n    linenr_T\t\treg_maxline;\n    int\t\t\treg_line_lbr;\t// \"\\n\" in string is line break\n\n    // The current match-position is stord in these variables:\n    linenr_T\tlnum;\t\t// line number, relative to first line\n    char_u\t*line;\t\t// start of current line\n    char_u\t*input;\t\t// current input, points into \"line\"\n\n    int\tneed_clear_subexpr;\t// subexpressions still need to be cleared\n#ifdef FEAT_SYN_HL\n    int\tneed_clear_zsubexpr;\t// extmatch subexpressions still need to be\n\t\t\t\t// cleared\n#endif\n\n    // Internal copy of 'ignorecase'.  It is set at each call to vim_regexec().\n    // Normally it gets the value of \"rm_ic\" or \"rmm_ic\", but when the pattern\n    // contains '\\c' or '\\C' the value is overruled.\n    int\t\t\treg_ic;\n\n    // Similar to \"reg_ic\", but only for 'combining' characters.  Set with \\Z\n    // flag in the regexp.  Defaults to false, always.\n    int\t\t\treg_icombine;\n\n    // Copy of \"rmm_maxcol\": maximum column to search for a match.  Zero when\n    // there is no maximum.\n    colnr_T\t\treg_maxcol;\n\n    // State for the NFA engine regexec.\n    int nfa_has_zend;\t    // NFA regexp \\ze operator encountered.\n    int nfa_has_backref;    // NFA regexp \\1 .. \\9 encountered.\n    int nfa_nsubexpr;\t    // Number of sub expressions actually being used\n\t\t\t    // during execution. 1 if only the whole match\n\t\t\t    // (subexpr 0) is used.\n    // listid is global, so that it increases on recursive calls to\n    // nfa_regmatch(), which means we don't have to clear the lastlist field of\n    // all the states.\n    int nfa_listid;\n    int nfa_alt_listid;\n\n#ifdef FEAT_SYN_HL\n    int nfa_has_zsubexpr;   // NFA regexp has \\z( ), set zsubexpr.\n#endif\n} regexec_T;\n\nstatic regexec_T\trex;\nstatic int\t\trex_in_use = FALSE;\n\n/*\n * Return TRUE if character 'c' is included in 'iskeyword' option for\n * \"reg_buf\" buffer.\n */\n    static int\nreg_iswordc(int c)\n{\n    return vim_iswordc_buf(c, rex.reg_buf);\n}\n\n/*\n * Get pointer to the line \"lnum\", which is relative to \"reg_firstlnum\".\n */\n    static char_u *\nreg_getline(linenr_T lnum)\n{\n    // when looking behind for a match/no-match lnum is negative.  But we\n    // can't go before line 1\n    if (rex.reg_firstlnum + lnum < 1)\n\treturn NULL;\n    if (lnum > rex.reg_maxline)\n\t// Must have matched the \"\\n\" in the last line.\n\treturn (char_u *)\"\";\n    return ml_get_buf(rex.reg_buf, rex.reg_firstlnum + lnum, FALSE);\n}\n\n#ifdef FEAT_SYN_HL\nstatic char_u\t*reg_startzp[NSUBEXP];\t// Workspace to mark beginning\nstatic char_u\t*reg_endzp[NSUBEXP];\t//   and end of \\z(...\\) matches\nstatic lpos_T\treg_startzpos[NSUBEXP];\t// idem, beginning pos\nstatic lpos_T\treg_endzpos[NSUBEXP];\t// idem, end pos\n#endif\n\n// TRUE if using multi-line regexp.\n#define REG_MULTI\t(rex.reg_match == NULL)\n\n#ifdef FEAT_SYN_HL\n/*\n * Create a new extmatch and mark it as referenced once.\n */\n    static reg_extmatch_T *\nmake_extmatch(void)\n{\n    reg_extmatch_T\t*em;\n\n    em = ALLOC_CLEAR_ONE(reg_extmatch_T);\n    if (em != NULL)\n\tem->refcnt = 1;\n    return em;\n}\n\n/*\n * Add a reference to an extmatch.\n */\n    reg_extmatch_T *\nref_extmatch(reg_extmatch_T *em)\n{\n    if (em != NULL)\n\tem->refcnt++;\n    return em;\n}\n\n/*\n * Remove a reference to an extmatch.  If there are no references left, free\n * the info.\n */\n    void\nunref_extmatch(reg_extmatch_T *em)\n{\n    int i;\n\n    if (em != NULL && --em->refcnt <= 0)\n    {\n\tfor (i = 0; i < NSUBEXP; ++i)\n\t    vim_free(em->matches[i]);\n\tvim_free(em);\n    }\n}\n#endif\n\n/*\n * Get class of previous character.\n */\n    static int\nreg_prev_class(void)\n{\n    if (rex.input > rex.line)\n\treturn mb_get_class_buf(rex.input - 1\n\t\t       - (*mb_head_off)(rex.line, rex.input - 1), rex.reg_buf);\n    return -1;\n}\n\n/*\n * Return TRUE if the current rex.input position matches the Visual area.\n */\n    static int\nreg_match_visual(void)\n{\n    pos_T\ttop, bot;\n    linenr_T    lnum;\n    colnr_T\tcol;\n    win_T\t*wp = rex.reg_win == NULL ? curwin : rex.reg_win;\n    int\t\tmode;\n    colnr_T\tstart, end;\n    colnr_T\tstart2, end2;\n    colnr_T\tcols;\n    colnr_T\tcurswant;\n\n    // Check if the buffer is the current buffer and not using a string.\n    if (rex.reg_buf != curbuf || VIsual.lnum == 0 || !REG_MULTI)\n\treturn FALSE;\n\n    if (VIsual_active)\n    {\n\tif (LT_POS(VIsual, wp->w_cursor))\n\t{\n\t    top = VIsual;\n\t    bot = wp->w_cursor;\n\t}\n\telse\n\t{\n\t    top = wp->w_cursor;\n\t    bot = VIsual;\n\t}\n\tmode = VIsual_mode;\n\tcurswant = wp->w_curswant;\n    }\n    else\n    {\n\tif (LT_POS(curbuf->b_visual.vi_start, curbuf->b_visual.vi_end))\n\t{\n\t    top = curbuf->b_visual.vi_start;\n\t    bot = curbuf->b_visual.vi_end;\n\t}\n\telse\n\t{\n\t    top = curbuf->b_visual.vi_end;\n\t    bot = curbuf->b_visual.vi_start;\n\t}\n\tmode = curbuf->b_visual.vi_mode;\n\tcurswant = curbuf->b_visual.vi_curswant;\n    }\n    lnum = rex.lnum + rex.reg_firstlnum;\n    if (lnum < top.lnum || lnum > bot.lnum)\n\treturn FALSE;\n\n    col = (colnr_T)(rex.input - rex.line);\n    if (mode == 'v')\n    {\n\tif ((lnum == top.lnum && col < top.col)\n\t\t|| (lnum == bot.lnum && col >= bot.col + (*p_sel != 'e')))\n\t    return FALSE;\n    }\n    else if (mode == Ctrl_V)\n    {\n\tgetvvcol(wp, &top, &start, NULL, &end);\n\tgetvvcol(wp, &bot, &start2, NULL, &end2);\n\tif (start2 < start)\n\t    start = start2;\n\tif (end2 > end)\n\t    end = end2;\n\tif (top.col == MAXCOL || bot.col == MAXCOL || curswant == MAXCOL)\n\t    end = MAXCOL;\n\n\t// getvvcol() flushes rex.line, need to get it again\n\trex.line = reg_getline(rex.lnum);\n\trex.input = rex.line + col;\n\n\tcols = win_linetabsize(wp, rex.reg_firstlnum + rex.lnum, rex.line, col);\n\tif (cols < start || cols > end - (*p_sel == 'e'))\n\t    return FALSE;\n    }\n    return TRUE;\n}\n\n/*\n * Check the regexp program for its magic number.\n * Return TRUE if it's wrong.\n */\n    static int\nprog_magic_wrong(void)\n{\n    regprog_T\t*prog;\n\n    prog = REG_MULTI ? rex.reg_mmatch->regprog : rex.reg_match->regprog;\n    if (prog->engine == &nfa_regengine)\n\t// For NFA matcher we don't check the magic\n\treturn FALSE;\n\n    if (UCHARAT(((bt_regprog_T *)prog)->program) != REGMAGIC)\n    {\n\temsg(_(e_corrupted_regexp_program));\n\treturn TRUE;\n    }\n    return FALSE;\n}\n\n/*\n * Cleanup the subexpressions, if this wasn't done yet.\n * This construction is used to clear the subexpressions only when they are\n * used (to increase speed).\n */\n    static void\ncleanup_subexpr(void)\n{\n    if (!rex.need_clear_subexpr)\n\treturn;\n\n    if (REG_MULTI)\n    {\n\t// Use 0xff to set lnum to -1\n\tvim_memset(rex.reg_startpos, 0xff, sizeof(lpos_T) * NSUBEXP);\n\tvim_memset(rex.reg_endpos, 0xff, sizeof(lpos_T) * NSUBEXP);\n    }\n    else\n    {\n\tvim_memset(rex.reg_startp, 0, sizeof(char_u *) * NSUBEXP);\n\tvim_memset(rex.reg_endp, 0, sizeof(char_u *) * NSUBEXP);\n    }\n    rex.need_clear_subexpr = FALSE;\n}\n\n#ifdef FEAT_SYN_HL\n    static void\ncleanup_zsubexpr(void)\n{\n    if (!rex.need_clear_zsubexpr)\n\treturn;\n\n    if (REG_MULTI)\n    {\n\t// Use 0xff to set lnum to -1\n\tvim_memset(reg_startzpos, 0xff, sizeof(lpos_T) * NSUBEXP);\n\tvim_memset(reg_endzpos, 0xff, sizeof(lpos_T) * NSUBEXP);\n    }\n    else\n    {\n\tvim_memset(reg_startzp, 0, sizeof(char_u *) * NSUBEXP);\n\tvim_memset(reg_endzp, 0, sizeof(char_u *) * NSUBEXP);\n    }\n    rex.need_clear_zsubexpr = FALSE;\n}\n#endif\n\n/*\n * Advance rex.lnum, rex.line and rex.input to the next line.\n */\n    static void\nreg_nextline(void)\n{\n    rex.line = reg_getline(++rex.lnum);\n    rex.input = rex.line;\n    fast_breakcheck();\n}\n\n/*\n * Check whether a backreference matches.\n * Returns RA_FAIL, RA_NOMATCH or RA_MATCH.\n * If \"bytelen\" is not NULL, it is set to the byte length of the match in the\n * last line.\n */\n    static int\nmatch_with_backref(\n    linenr_T start_lnum,\n    colnr_T  start_col,\n    linenr_T end_lnum,\n    colnr_T  end_col,\n    int\t     *bytelen)\n{\n    linenr_T\tclnum = start_lnum;\n    colnr_T\tccol = start_col;\n    int\t\tlen;\n    char_u\t*p;\n\n    if (bytelen != NULL)\n\t*bytelen = 0;\n    for (;;)\n    {\n\t// Since getting one line may invalidate the other, need to make copy.\n\t// Slow!\n\tif (rex.line != reg_tofree)\n\t{\n\t    len = (int)STRLEN(rex.line);\n\t    if (reg_tofree == NULL || len >= (int)reg_tofreelen)\n\t    {\n\t\tlen += 50;\t// get some extra\n\t\tvim_free(reg_tofree);\n\t\treg_tofree = alloc(len);\n\t\tif (reg_tofree == NULL)\n\t\t    return RA_FAIL; // out of memory!\n\t\treg_tofreelen = len;\n\t    }\n\t    STRCPY(reg_tofree, rex.line);\n\t    rex.input = reg_tofree + (rex.input - rex.line);\n\t    rex.line = reg_tofree;\n\t}\n\n\t// Get the line to compare with.\n\tp = reg_getline(clnum);\n\tif (clnum == end_lnum)\n\t    len = end_col - ccol;\n\telse\n\t    len = (int)STRLEN(p + ccol);\n\n\tif (cstrncmp(p + ccol, rex.input, &len) != 0)\n\t    return RA_NOMATCH;  // doesn't match\n\tif (bytelen != NULL)\n\t    *bytelen += len;\n\tif (clnum == end_lnum)\n\t    break;\t\t// match and at end!\n\tif (rex.lnum >= rex.reg_maxline)\n\t    return RA_NOMATCH;  // text too short\n\n\t// Advance to next line.\n\treg_nextline();\n\tif (bytelen != NULL)\n\t    *bytelen = 0;\n\t++clnum;\n\tccol = 0;\n\tif (got_int)\n\t    return RA_FAIL;\n    }\n\n    // found a match!  Note that rex.line may now point to a copy of the line,\n    // that should not matter.\n    return RA_MATCH;\n}\n\n/*\n * Used in a place where no * or \\+ can follow.\n */\n    static int\nre_mult_next(char *what)\n{\n    if (re_multi_type(peekchr()) == MULTI_MULT)\n    {\n       semsg(_(e_nfa_regexp_cannot_repeat_str), what);\n       rc_did_emsg = TRUE;\n       return FAIL;\n    }\n    return OK;\n}\n\ntypedef struct\n{\n    int a, b, c;\n} decomp_T;\n\n\n// 0xfb20 - 0xfb4f\nstatic decomp_T decomp_table[0xfb4f-0xfb20+1] =\n{\n    {0x5e2,0,0},\t\t// 0xfb20\talt ayin\n    {0x5d0,0,0},\t\t// 0xfb21\talt alef\n    {0x5d3,0,0},\t\t// 0xfb22\talt dalet\n    {0x5d4,0,0},\t\t// 0xfb23\talt he\n    {0x5db,0,0},\t\t// 0xfb24\talt kaf\n    {0x5dc,0,0},\t\t// 0xfb25\talt lamed\n    {0x5dd,0,0},\t\t// 0xfb26\talt mem-sofit\n    {0x5e8,0,0},\t\t// 0xfb27\talt resh\n    {0x5ea,0,0},\t\t// 0xfb28\talt tav\n    {'+', 0, 0},\t\t// 0xfb29\talt plus\n    {0x5e9, 0x5c1, 0},\t\t// 0xfb2a\tshin+shin-dot\n    {0x5e9, 0x5c2, 0},\t\t// 0xfb2b\tshin+sin-dot\n    {0x5e9, 0x5c1, 0x5bc},\t// 0xfb2c\tshin+shin-dot+dagesh\n    {0x5e9, 0x5c2, 0x5bc},\t// 0xfb2d\tshin+sin-dot+dagesh\n    {0x5d0, 0x5b7, 0},\t\t// 0xfb2e\talef+patah\n    {0x5d0, 0x5b8, 0},\t\t// 0xfb2f\talef+qamats\n    {0x5d0, 0x5b4, 0},\t\t// 0xfb30\talef+hiriq\n    {0x5d1, 0x5bc, 0},\t\t// 0xfb31\tbet+dagesh\n    {0x5d2, 0x5bc, 0},\t\t// 0xfb32\tgimel+dagesh\n    {0x5d3, 0x5bc, 0},\t\t// 0xfb33\tdalet+dagesh\n    {0x5d4, 0x5bc, 0},\t\t// 0xfb34\the+dagesh\n    {0x5d5, 0x5bc, 0},\t\t// 0xfb35\tvav+dagesh\n    {0x5d6, 0x5bc, 0},\t\t// 0xfb36\tzayin+dagesh\n    {0xfb37, 0, 0},\t\t// 0xfb37 -- UNUSED\n    {0x5d8, 0x5bc, 0},\t\t// 0xfb38\ttet+dagesh\n    {0x5d9, 0x5bc, 0},\t\t// 0xfb39\tyud+dagesh\n    {0x5da, 0x5bc, 0},\t\t// 0xfb3a\tkaf sofit+dagesh\n    {0x5db, 0x5bc, 0},\t\t// 0xfb3b\tkaf+dagesh\n    {0x5dc, 0x5bc, 0},\t\t// 0xfb3c\tlamed+dagesh\n    {0xfb3d, 0, 0},\t\t// 0xfb3d -- UNUSED\n    {0x5de, 0x5bc, 0},\t\t// 0xfb3e\tmem+dagesh\n    {0xfb3f, 0, 0},\t\t// 0xfb3f -- UNUSED\n    {0x5e0, 0x5bc, 0},\t\t// 0xfb40\tnun+dagesh\n    {0x5e1, 0x5bc, 0},\t\t// 0xfb41\tsamech+dagesh\n    {0xfb42, 0, 0},\t\t// 0xfb42 -- UNUSED\n    {0x5e3, 0x5bc, 0},\t\t// 0xfb43\tpe sofit+dagesh\n    {0x5e4, 0x5bc,0},\t\t// 0xfb44\tpe+dagesh\n    {0xfb45, 0, 0},\t\t// 0xfb45 -- UNUSED\n    {0x5e6, 0x5bc, 0},\t\t// 0xfb46\ttsadi+dagesh\n    {0x5e7, 0x5bc, 0},\t\t// 0xfb47\tqof+dagesh\n    {0x5e8, 0x5bc, 0},\t\t// 0xfb48\tresh+dagesh\n    {0x5e9, 0x5bc, 0},\t\t// 0xfb49\tshin+dagesh\n    {0x5ea, 0x5bc, 0},\t\t// 0xfb4a\ttav+dagesh\n    {0x5d5, 0x5b9, 0},\t\t// 0xfb4b\tvav+holam\n    {0x5d1, 0x5bf, 0},\t\t// 0xfb4c\tbet+rafe\n    {0x5db, 0x5bf, 0},\t\t// 0xfb4d\tkaf+rafe\n    {0x5e4, 0x5bf, 0},\t\t// 0xfb4e\tpe+rafe\n    {0x5d0, 0x5dc, 0}\t\t// 0xfb4f\talef-lamed\n};\n\n    static void\nmb_decompose(int c, int *c1, int *c2, int *c3)\n{\n    decomp_T d;\n\n    if (c >= 0xfb20 && c <= 0xfb4f)\n    {\n\td = decomp_table[c - 0xfb20];\n\t*c1 = d.a;\n\t*c2 = d.b;\n\t*c3 = d.c;\n    }\n    else\n    {\n\t*c1 = c;\n\t*c2 = *c3 = 0;\n    }\n}\n\n/*\n * Compare two strings, ignore case if rex.reg_ic set.\n * Return 0 if strings match, non-zero otherwise.\n * Correct the length \"*n\" when composing characters are ignored.\n */\n    static int\ncstrncmp(char_u *s1, char_u *s2, int *n)\n{\n    int\t\tresult;\n\n    if (!rex.reg_ic)\n\tresult = STRNCMP(s1, s2, *n);\n    else\n\tresult = MB_STRNICMP(s1, s2, *n);\n\n    // if it failed and it's utf8 and we want to combineignore:\n    if (result != 0 && enc_utf8 && rex.reg_icombine)\n    {\n\tchar_u\t*str1, *str2;\n\tint\tc1, c2, c11, c12;\n\tint\tjunk;\n\n\t// we have to handle the strcmp ourselves, since it is necessary to\n\t// deal with the composing characters by ignoring them:\n\tstr1 = s1;\n\tstr2 = s2;\n\tc1 = c2 = 0;\n\twhile ((int)(str1 - s1) < *n)\n\t{\n\t    c1 = mb_ptr2char_adv(&str1);\n\t    c2 = mb_ptr2char_adv(&str2);\n\n\t    // Decompose the character if necessary, into 'base' characters.\n\t    // Currently hard-coded for Hebrew, Arabic to be done...\n\t    if (c1 != c2 && (!rex.reg_ic || utf_fold(c1) != utf_fold(c2)))\n\t    {\n\t\t// decomposition necessary?\n\t\tmb_decompose(c1, &c11, &junk, &junk);\n\t\tmb_decompose(c2, &c12, &junk, &junk);\n\t\tc1 = c11;\n\t\tc2 = c12;\n\t\tif (c11 != c12\n\t\t\t    && (!rex.reg_ic || utf_fold(c11) != utf_fold(c12)))\n\t\t    break;\n\t    }\n\t}\n\tresult = c2 - c1;\n\tif (result == 0)\n\t    *n = (int)(str2 - s2);\n    }\n\n    return result;\n}\n\n/*\n * cstrchr: This function is used a lot for simple searches, keep it fast!\n */\n    static char_u *\ncstrchr(char_u *s, int c)\n{\n    char_u\t*p;\n    int\t\tcc;\n\n    if (!rex.reg_ic || (!enc_utf8 && mb_char2len(c) > 1))\n\treturn vim_strchr(s, c);\n\n    // tolower() and toupper() can be slow, comparing twice should be a lot\n    // faster (esp. when using MS Visual C++!).\n    // For UTF-8 need to use folded case.\n    if (enc_utf8 && c > 0x80)\n\tcc = utf_fold(c);\n    else\n\t if (MB_ISUPPER(c))\n\tcc = MB_TOLOWER(c);\n    else if (MB_ISLOWER(c))\n\tcc = MB_TOUPPER(c);\n    else\n\treturn vim_strchr(s, c);\n\n    if (has_mbyte)\n    {\n\tfor (p = s; *p != NUL; p += (*mb_ptr2len)(p))\n\t{\n\t    if (enc_utf8 && c > 0x80)\n\t    {\n\t\tint uc = utf_ptr2char(p);\n\n\t\t// Do not match an illegal byte.  E.g. 0xff matches 0xc3 0xbf,\n\t\t// not 0xff.\n\t\tif ((uc < 0x80 || uc != *p) && utf_fold(uc) == cc)\n\t\t    return p;\n\t    }\n\t    else if (*p == c || *p == cc)\n\t\treturn p;\n\t}\n    }\n    else\n\t// Faster version for when there are no multi-byte characters.\n\tfor (p = s; *p != NUL; ++p)\n\t    if (*p == c || *p == cc)\n\t\treturn p;\n\n    return NULL;\n}\n\n////////////////////////////////////////////////////////////////\n//\t\t      regsub stuff\t\t\t      //\n////////////////////////////////////////////////////////////////\n\n/*\n * We should define ftpr as a pointer to a function returning a pointer to\n * a function returning a pointer to a function ...\n * This is impossible, so we declare a pointer to a function returning a\n * void pointer. This should work for all compilers.\n */\ntypedef void (*(*fptr_T)(int *, int));\n\nstatic int vim_regsub_both(char_u *source, typval_T *expr, char_u *dest, int destlen, int flags);\n\n    static fptr_T\ndo_upper(int *d, int c)\n{\n    *d = MB_TOUPPER(c);\n\n    return (fptr_T)NULL;\n}\n\n    static fptr_T\ndo_Upper(int *d, int c)\n{\n    *d = MB_TOUPPER(c);\n\n    return (fptr_T)do_Upper;\n}\n\n    static fptr_T\ndo_lower(int *d, int c)\n{\n    *d = MB_TOLOWER(c);\n\n    return (fptr_T)NULL;\n}\n\n    static fptr_T\ndo_Lower(int *d, int c)\n{\n    *d = MB_TOLOWER(c);\n\n    return (fptr_T)do_Lower;\n}\n\n/*\n * regtilde(): Replace tildes in the pattern by the old pattern.\n *\n * Short explanation of the tilde: It stands for the previous replacement\n * pattern.  If that previous pattern also contains a ~ we should go back a\n * step further...  But we insert the previous pattern into the current one\n * and remember that.\n * This still does not handle the case where \"magic\" changes.  So require the\n * user to keep his hands off of \"magic\".\n *\n * The tildes are parsed once before the first call to vim_regsub().\n */\n    char_u *\nregtilde(char_u *source, int magic)\n{\n    char_u\t*newsub = source;\n    char_u\t*tmpsub;\n    char_u\t*p;\n    int\t\tlen;\n    int\t\tprevlen;\n\n    for (p = newsub; *p; ++p)\n    {\n\tif ((*p == '~' && magic) || (*p == '\\\\' && *(p + 1) == '~' && !magic))\n\t{\n\t    if (reg_prev_sub != NULL)\n\t    {\n\t\t// length = len(newsub) - 1 + len(prev_sub) + 1\n\t\tprevlen = (int)STRLEN(reg_prev_sub);\n\t\ttmpsub = alloc(STRLEN(newsub) + prevlen);\n\t\tif (tmpsub != NULL)\n\t\t{\n\t\t    // copy prefix\n\t\t    len = (int)(p - newsub);\t// not including ~\n\t\t    mch_memmove(tmpsub, newsub, (size_t)len);\n\t\t    // interpret tilde\n\t\t    mch_memmove(tmpsub + len, reg_prev_sub, (size_t)prevlen);\n\t\t    // copy postfix\n\t\t    if (!magic)\n\t\t\t++p;\t\t\t// back off backslash\n\t\t    STRCPY(tmpsub + len + prevlen, p + 1);\n\n\t\t    if (newsub != source)\t// already allocated newsub\n\t\t\tvim_free(newsub);\n\t\t    newsub = tmpsub;\n\t\t    p = newsub + len + prevlen;\n\t\t}\n\t    }\n\t    else if (magic)\n\t\tSTRMOVE(p, p + 1);\t// remove '~'\n\t    else\n\t\tSTRMOVE(p, p + 2);\t// remove '\\~'\n\t    --p;\n\t}\n\telse\n\t{\n\t    if (*p == '\\\\' && p[1])\t\t// skip escaped characters\n\t\t++p;\n\t    if (has_mbyte)\n\t\tp += (*mb_ptr2len)(p) - 1;\n\t}\n    }\n\n    // Store a copy of newsub  in reg_prev_sub.  It is always allocated,\n    // because recursive calls may make the returned string invalid.\n    vim_free(reg_prev_sub);\n    reg_prev_sub = vim_strsave(newsub);\n\n    return newsub;\n}\n\n#ifdef FEAT_EVAL\nstatic int can_f_submatch = FALSE;\t// TRUE when submatch() can be used\n\n// These pointers are used for reg_submatch().  Needed for when the\n// substitution string is an expression that contains a call to substitute()\n// and submatch().\ntypedef struct {\n    regmatch_T\t*sm_match;\n    regmmatch_T\t*sm_mmatch;\n    linenr_T\tsm_firstlnum;\n    linenr_T\tsm_maxline;\n    int\t\tsm_line_lbr;\n} regsubmatch_T;\n\nstatic regsubmatch_T rsm;  // can only be used when can_f_submatch is TRUE\n#endif\n\n#ifdef FEAT_EVAL\n\n/*\n * Put the submatches in \"argv[argskip]\" which is a list passed into\n * call_func() by vim_regsub_both().\n */\n    static int\nfill_submatch_list(int argc UNUSED, typval_T *argv, int argskip, ufunc_T *fp)\n{\n    listitem_T\t*li;\n    int\t\ti;\n    char_u\t*s;\n    typval_T\t*listarg = argv + argskip;\n\n    if (!has_varargs(fp) && fp->uf_args.ga_len <= argskip)\n\t// called function doesn't take a submatches argument\n\treturn argskip;\n\n    // Relies on sl_list to be the first item in staticList10_T.\n    init_static_list((staticList10_T *)(listarg->vval.v_list));\n\n    // There are always 10 list items in staticList10_T.\n    li = listarg->vval.v_list->lv_first;\n    for (i = 0; i < 10; ++i)\n    {\n\ts = rsm.sm_match->startp[i];\n\tif (s == NULL || rsm.sm_match->endp[i] == NULL)\n\t    s = NULL;\n\telse\n\t    s = vim_strnsave(s, rsm.sm_match->endp[i] - s);\n\tli->li_tv.v_type = VAR_STRING;\n\tli->li_tv.vval.v_string = s;\n\tli = li->li_next;\n    }\n    return argskip + 1;\n}\n\n    static void\nclear_submatch_list(staticList10_T *sl)\n{\n    int i;\n\n    for (i = 0; i < 10; ++i)\n\tvim_free(sl->sl_items[i].li_tv.vval.v_string);\n}\n#endif\n\n/*\n * vim_regsub() - perform substitutions after a vim_regexec() or\n * vim_regexec_multi() match.\n *\n * If \"flags\" has REGSUB_COPY really copy into \"dest[destlen]\".\n * Otherwise nothing is copied, only compute the length of the result.\n *\n * If \"flags\" has REGSUB_MAGIC then behave like 'magic' is set.\n *\n * If \"flags\" has REGSUB_BACKSLASH a backslash will be removed later, need to\n * double them to keep them, and insert a backslash before a CR to avoid it\n * being replaced with a line break later.\n *\n * Note: The matched text must not change between the call of\n * vim_regexec()/vim_regexec_multi() and vim_regsub()!  It would make the back\n * references invalid!\n *\n * Returns the size of the replacement, including terminating NUL.\n */\n    int\nvim_regsub(\n    regmatch_T\t*rmp,\n    char_u\t*source,\n    typval_T\t*expr,\n    char_u\t*dest,\n    int\t\tdestlen,\n    int\t\tflags)\n{\n    int\t\tresult;\n    regexec_T\trex_save;\n    int\t\trex_in_use_save = rex_in_use;\n\n    if (rex_in_use)\n\t// Being called recursively, save the state.\n\trex_save = rex;\n    rex_in_use = TRUE;\n\n    rex.reg_match = rmp;\n    rex.reg_mmatch = NULL;\n    rex.reg_maxline = 0;\n    rex.reg_buf = curbuf;\n    rex.reg_line_lbr = TRUE;\n    result = vim_regsub_both(source, expr, dest, destlen, flags);\n\n    rex_in_use = rex_in_use_save;\n    if (rex_in_use)\n\trex = rex_save;\n\n    return result;\n}\n\n    int\nvim_regsub_multi(\n    regmmatch_T\t*rmp,\n    linenr_T\tlnum,\n    char_u\t*source,\n    char_u\t*dest,\n    int\t\tdestlen,\n    int\t\tflags)\n{\n    int\t\tresult;\n    regexec_T\trex_save;\n    int\t\trex_in_use_save = rex_in_use;\n\n    if (rex_in_use)\n\t// Being called recursively, save the state.\n\trex_save = rex;\n    rex_in_use = TRUE;\n\n    rex.reg_match = NULL;\n    rex.reg_mmatch = rmp;\n    rex.reg_buf = curbuf;\t// always works on the current buffer!\n    rex.reg_firstlnum = lnum;\n    rex.reg_maxline = curbuf->b_ml.ml_line_count - lnum;\n    rex.reg_line_lbr = FALSE;\n    result = vim_regsub_both(source, NULL, dest, destlen, flags);\n\n    rex_in_use = rex_in_use_save;\n    if (rex_in_use)\n\trex = rex_save;\n\n    return result;\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n// When nesting more than a couple levels it's probably a mistake.\n# define MAX_REGSUB_NESTING 4\nstatic char_u   *eval_result[MAX_REGSUB_NESTING] = {NULL, NULL, NULL, NULL};\n\n# if defined(EXITFREE) || defined(PROTO)\n    void\nfree_resub_eval_result(void)\n{\n    int i;\n\n    for (i = 0; i < MAX_REGSUB_NESTING; ++i)\n\tVIM_CLEAR(eval_result[i]);\n}\n# endif\n#endif\n\n    static int\nvim_regsub_both(\n    char_u\t*source,\n    typval_T\t*expr,\n    char_u\t*dest,\n    int\t\tdestlen,\n    int\t\tflags)\n{\n    char_u\t*src;\n    char_u\t*dst;\n    char_u\t*s;\n    int\t\tc;\n    int\t\tcc;\n    int\t\tno = -1;\n    fptr_T\tfunc_all = (fptr_T)NULL;\n    fptr_T\tfunc_one = (fptr_T)NULL;\n    linenr_T\tclnum = 0;\t// init for GCC\n    int\t\tlen = 0;\t// init for GCC\n#ifdef FEAT_EVAL\n    static int  nesting = 0;\n    int\t\tnested;\n#endif\n    int\t\tcopy = flags & REGSUB_COPY;\n\n    // Be paranoid...\n    if ((source == NULL && expr == NULL) || dest == NULL)\n    {\n\temsg(_(e_null_argument));\n\treturn 0;\n    }\n    if (prog_magic_wrong())\n\treturn 0;\n#ifdef FEAT_EVAL\n    if (nesting == MAX_REGSUB_NESTING)\n    {\n\temsg(_(e_substitute_nesting_too_deep));\n\treturn 0;\n    }\n    nested = nesting;\n#endif\n    src = source;\n    dst = dest;\n\n    /*\n     * When the substitute part starts with \"\\=\" evaluate it as an expression.\n     */\n    if (expr != NULL || (source[0] == '\\\\' && source[1] == '='))\n    {\n#ifdef FEAT_EVAL\n\t// To make sure that the length doesn't change between checking the\n\t// length and copying the string, and to speed up things, the\n\t// resulting string is saved from the call with\n\t// \"flags & REGSUB_COPY\" == 0 to the call with\n\t// \"flags & REGSUB_COPY\" != 0.\n\tif (copy)\n\t{\n\t    if (eval_result[nested] != NULL)\n\t    {\n\t\tSTRCPY(dest, eval_result[nested]);\n\t\tdst += STRLEN(eval_result[nested]);\n\t\tVIM_CLEAR(eval_result[nested]);\n\t    }\n\t}\n\telse\n\t{\n\t    int\t\t    prev_can_f_submatch = can_f_submatch;\n\t    regsubmatch_T   rsm_save;\n\n\t    VIM_CLEAR(eval_result[nested]);\n\n\t    // The expression may contain substitute(), which calls us\n\t    // recursively.  Make sure submatch() gets the text from the first\n\t    // level.\n\t    if (can_f_submatch)\n\t\trsm_save = rsm;\n\t    can_f_submatch = TRUE;\n\t    rsm.sm_match = rex.reg_match;\n\t    rsm.sm_mmatch = rex.reg_mmatch;\n\t    rsm.sm_firstlnum = rex.reg_firstlnum;\n\t    rsm.sm_maxline = rex.reg_maxline;\n\t    rsm.sm_line_lbr = rex.reg_line_lbr;\n\n\t    // Although unlikely, it is possible that the expression invokes a\n\t    // substitute command (it might fail, but still).  Therefore keep\n\t    // an array of eval results.\n\t    ++nesting;\n\n\t    if (expr != NULL)\n\t    {\n\t\ttypval_T\targv[2];\n\t\tchar_u\t\tbuf[NUMBUFLEN];\n\t\ttypval_T\trettv;\n\t\tstaticList10_T\tmatchList;\n\t\tfuncexe_T\tfuncexe;\n\n\t\trettv.v_type = VAR_STRING;\n\t\trettv.vval.v_string = NULL;\n\t\targv[0].v_type = VAR_LIST;\n\t\targv[0].vval.v_list = &matchList.sl_list;\n\t\tmatchList.sl_list.lv_len = 0;\n\t\tCLEAR_FIELD(funcexe);\n\t\tfuncexe.fe_argv_func = fill_submatch_list;\n\t\tfuncexe.fe_evaluate = TRUE;\n\t\tif (expr->v_type == VAR_FUNC)\n\t\t{\n\t\t    s = expr->vval.v_string;\n\t\t    call_func(s, -1, &rettv, 1, argv, &funcexe);\n\t\t}\n\t\telse if (expr->v_type == VAR_PARTIAL)\n\t\t{\n\t\t    partial_T   *partial = expr->vval.v_partial;\n\n\t\t    s = partial_name(partial);\n\t\t    funcexe.fe_partial = partial;\n\t\t    call_func(s, -1, &rettv, 1, argv, &funcexe);\n\t\t}\n\t\telse if (expr->v_type == VAR_INSTR)\n\t\t{\n\t\t    exe_typval_instr(expr, &rettv);\n\t\t}\n\t\tif (matchList.sl_list.lv_len > 0)\n\t\t    // fill_submatch_list() was called\n\t\t    clear_submatch_list(&matchList);\n\n\t\tif (rettv.v_type == VAR_UNKNOWN)\n\t\t    // something failed, no need to report another error\n\t\t    eval_result[nested] = NULL;\n\t\telse\n\t\t{\n\t\t    eval_result[nested] = tv_get_string_buf_chk(&rettv, buf);\n\t\t    if (eval_result[nested] != NULL)\n\t\t\teval_result[nested] = vim_strsave(eval_result[nested]);\n\t\t}\n\t\tclear_tv(&rettv);\n\t    }\n\t    else if (substitute_instr != NULL)\n\t\t// Execute instructions from ISN_SUBSTITUTE.\n\t\teval_result[nested] = exe_substitute_instr();\n\t    else\n\t\teval_result[nested] = eval_to_string(source + 2, TRUE, FALSE);\n\t    --nesting;\n\n\t    if (eval_result[nested] != NULL)\n\t    {\n\t\tint had_backslash = FALSE;\n\n\t\tfor (s = eval_result[nested]; *s != NUL; MB_PTR_ADV(s))\n\t\t{\n\t\t    // Change NL to CR, so that it becomes a line break,\n\t\t    // unless called from vim_regexec_nl().\n\t\t    // Skip over a backslashed character.\n\t\t    if (*s == NL && !rsm.sm_line_lbr)\n\t\t\t*s = CAR;\n\t\t    else if (*s == '\\\\' && s[1] != NUL)\n\t\t    {\n\t\t\t++s;\n\t\t\t/* Change NL to CR here too, so that this works:\n\t\t\t * :s/abc\\\\\\ndef/\\=\"aaa\\\\\\nbbb\"/  on text:\n\t\t\t *   abc\\\n\t\t\t *   def\n\t\t\t * Not when called from vim_regexec_nl().\n\t\t\t */\n\t\t\tif (*s == NL && !rsm.sm_line_lbr)\n\t\t\t    *s = CAR;\n\t\t\thad_backslash = TRUE;\n\t\t    }\n\t\t}\n\t\tif (had_backslash && (flags & REGSUB_BACKSLASH))\n\t\t{\n\t\t    // Backslashes will be consumed, need to double them.\n\t\t    s = vim_strsave_escaped(eval_result[nested], (char_u *)\"\\\\\");\n\t\t    if (s != NULL)\n\t\t    {\n\t\t\tvim_free(eval_result[nested]);\n\t\t\teval_result[nested] = s;\n\t\t    }\n\t\t}\n\n\t\tdst += STRLEN(eval_result[nested]);\n\t    }\n\n\t    can_f_submatch = prev_can_f_submatch;\n\t    if (can_f_submatch)\n\t\trsm = rsm_save;\n\t}\n#endif\n    }\n    else\n      while ((c = *src++) != NUL)\n      {\n\tif (c == '&' && (flags & REGSUB_MAGIC))\n\t    no = 0;\n\telse if (c == '\\\\' && *src != NUL)\n\t{\n\t    if (*src == '&' && !(flags & REGSUB_MAGIC))\n\t    {\n\t\t++src;\n\t\tno = 0;\n\t    }\n\t    else if ('0' <= *src && *src <= '9')\n\t    {\n\t\tno = *src++ - '0';\n\t    }\n\t    else if (vim_strchr((char_u *)\"uUlLeE\", *src))\n\t    {\n\t\tswitch (*src++)\n\t\t{\n\t\tcase 'u':   func_one = (fptr_T)do_upper;\n\t\t\t    continue;\n\t\tcase 'U':   func_all = (fptr_T)do_Upper;\n\t\t\t    continue;\n\t\tcase 'l':   func_one = (fptr_T)do_lower;\n\t\t\t    continue;\n\t\tcase 'L':   func_all = (fptr_T)do_Lower;\n\t\t\t    continue;\n\t\tcase 'e':\n\t\tcase 'E':   func_one = func_all = (fptr_T)NULL;\n\t\t\t    continue;\n\t\t}\n\t    }\n\t}\n\tif (no < 0)\t      // Ordinary character.\n\t{\n\t    if (c == K_SPECIAL && src[0] != NUL && src[1] != NUL)\n\t    {\n\t\t// Copy a special key as-is.\n\t\tif (copy)\n\t\t{\n\t\t    if (dst + 3 > dest + destlen)\n\t\t    {\n\t\t\tiemsg(\"vim_regsub_both(): not enough space\");\n\t\t\treturn 0;\n\t\t    }\n\t\t    *dst++ = c;\n\t\t    *dst++ = *src++;\n\t\t    *dst++ = *src++;\n\t\t}\n\t\telse\n\t\t{\n\t\t    dst += 3;\n\t\t    src += 2;\n\t\t}\n\t\tcontinue;\n\t    }\n\n\t    if (c == '\\\\' && *src != NUL)\n\t    {\n\t\t// Check for abbreviations -- webb\n\t\tswitch (*src)\n\t\t{\n\t\t    case 'r':\tc = CAR;\t++src;\tbreak;\n\t\t    case 'n':\tc = NL;\t\t++src;\tbreak;\n\t\t    case 't':\tc = TAB;\t++src;\tbreak;\n\t\t // Oh no!  \\e already has meaning in subst pat :-(\n\t\t // case 'e':   c = ESC;\t++src;\tbreak;\n\t\t    case 'b':\tc = Ctrl_H;\t++src;\tbreak;\n\n\t\t    // If \"backslash\" is TRUE the backslash will be removed\n\t\t    // later.  Used to insert a literal CR.\n\t\t    default:\tif (flags & REGSUB_BACKSLASH)\n\t\t\t\t{\n\t\t\t\t    if (copy)\n\t\t\t\t    {\n\t\t\t\t\tif (dst + 1 > dest + destlen)\n\t\t\t\t\t{\n\t\t\t\t\t    iemsg(\"vim_regsub_both(): not enough space\");\n\t\t\t\t\t    return 0;\n\t\t\t\t\t}\n\t\t\t\t\t*dst = '\\\\';\n\t\t\t\t    }\n\t\t\t\t    ++dst;\n\t\t\t\t}\n\t\t\t\tc = *src++;\n\t\t}\n\t    }\n\t    else if (has_mbyte)\n\t\tc = mb_ptr2char(src - 1);\n\n\t    // Write to buffer, if copy is set.\n\t    if (func_one != (fptr_T)NULL)\n\t\t// Turbo C complains without the typecast\n\t\tfunc_one = (fptr_T)(func_one(&cc, c));\n\t    else if (func_all != (fptr_T)NULL)\n\t\t// Turbo C complains without the typecast\n\t\tfunc_all = (fptr_T)(func_all(&cc, c));\n\t    else // just copy\n\t\tcc = c;\n\n\t    if (has_mbyte)\n\t    {\n\t\tint totlen = mb_ptr2len(src - 1);\n\t\tint charlen = mb_char2len(cc);\n\n\t\tif (copy)\n\t\t{\n\t\t    if (dst + charlen > dest + destlen)\n\t\t    {\n\t\t\tiemsg(\"vim_regsub_both(): not enough space\");\n\t\t\treturn 0;\n\t\t    }\n\t\t    mb_char2bytes(cc, dst);\n\t\t}\n\t\tdst += charlen - 1;\n\t\tif (enc_utf8)\n\t\t{\n\t\t    int clen = utf_ptr2len(src - 1);\n\n\t\t    // If the character length is shorter than \"totlen\", there\n\t\t    // are composing characters; copy them as-is.\n\t\t    if (clen < totlen)\n\t\t    {\n\t\t\tif (copy)\n\t\t\t{\n\t\t\t    if (dst + totlen - clen > dest + destlen)\n\t\t\t    {\n\t\t\t\tiemsg(\"vim_regsub_both(): not enough space\");\n\t\t\t\treturn 0;\n\t\t\t    }\n\t\t\t    mch_memmove(dst + 1, src - 1 + clen,\n\t\t\t\t\t\t     (size_t)(totlen - clen));\n\t\t\t}\n\t\t\tdst += totlen - clen;\n\t\t    }\n\t\t}\n\t\tsrc += totlen - 1;\n\t    }\n\t    else if (copy)\n\t    {\n\t\tif (dst + 1 > dest + destlen)\n\t\t{\n\t\t    iemsg(\"vim_regsub_both(): not enough space\");\n\t\t    return 0;\n\t\t}\n\t\t*dst = cc;\n\t    }\n\t    dst++;\n\t}\n\telse\n\t{\n\t    if (REG_MULTI)\n\t    {\n\t\tclnum = rex.reg_mmatch->startpos[no].lnum;\n\t\tif (clnum < 0 || rex.reg_mmatch->endpos[no].lnum < 0)\n\t\t    s = NULL;\n\t\telse\n\t\t{\n\t\t    s = reg_getline(clnum) + rex.reg_mmatch->startpos[no].col;\n\t\t    if (rex.reg_mmatch->endpos[no].lnum == clnum)\n\t\t\tlen = rex.reg_mmatch->endpos[no].col\n\t\t\t\t\t    - rex.reg_mmatch->startpos[no].col;\n\t\t    else\n\t\t\tlen = (int)STRLEN(s);\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\ts = rex.reg_match->startp[no];\n\t\tif (rex.reg_match->endp[no] == NULL)\n\t\t    s = NULL;\n\t\telse\n\t\t    len = (int)(rex.reg_match->endp[no] - s);\n\t    }\n\t    if (s != NULL)\n\t    {\n\t\tfor (;;)\n\t\t{\n\t\t    if (len == 0)\n\t\t    {\n\t\t\tif (REG_MULTI)\n\t\t\t{\n\t\t\t    if (rex.reg_mmatch->endpos[no].lnum == clnum)\n\t\t\t\tbreak;\n\t\t\t    if (copy)\n\t\t\t    {\n\t\t\t\tif (dst + 1 > dest + destlen)\n\t\t\t\t{\n\t\t\t\t    iemsg(\"vim_regsub_both(): not enough space\");\n\t\t\t\t    return 0;\n\t\t\t\t}\n\t\t\t\t*dst = CAR;\n\t\t\t    }\n\t\t\t    ++dst;\n\t\t\t    s = reg_getline(++clnum);\n\t\t\t    if (rex.reg_mmatch->endpos[no].lnum == clnum)\n\t\t\t\tlen = rex.reg_mmatch->endpos[no].col;\n\t\t\t    else\n\t\t\t\tlen = (int)STRLEN(s);\n\t\t\t}\n\t\t\telse\n\t\t\t    break;\n\t\t    }\n\t\t    else if (*s == NUL) // we hit NUL.\n\t\t    {\n\t\t\tif (copy)\n\t\t\t    iemsg(_(e_damaged_match_string));\n\t\t\tgoto exit;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tif ((flags & REGSUB_BACKSLASH)\n\t\t\t\t\t\t  && (*s == CAR || *s == '\\\\'))\n\t\t\t{\n\t\t\t    /*\n\t\t\t     * Insert a backslash in front of a CR, otherwise\n\t\t\t     * it will be replaced by a line break.\n\t\t\t     * Number of backslashes will be halved later,\n\t\t\t     * double them here.\n\t\t\t     */\n\t\t\t    if (copy)\n\t\t\t    {\n\t\t\t\tif (dst + 2 > dest + destlen)\n\t\t\t\t{\n\t\t\t\t    iemsg(\"vim_regsub_both(): not enough space\");\n\t\t\t\t    return 0;\n\t\t\t\t}\n\t\t\t\tdst[0] = '\\\\';\n\t\t\t\tdst[1] = *s;\n\t\t\t    }\n\t\t\t    dst += 2;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    if (has_mbyte)\n\t\t\t\tc = mb_ptr2char(s);\n\t\t\t    else\n\t\t\t\tc = *s;\n\n\t\t\t    if (func_one != (fptr_T)NULL)\n\t\t\t\t// Turbo C complains without the typecast\n\t\t\t\tfunc_one = (fptr_T)(func_one(&cc, c));\n\t\t\t    else if (func_all != (fptr_T)NULL)\n\t\t\t\t// Turbo C complains without the typecast\n\t\t\t\tfunc_all = (fptr_T)(func_all(&cc, c));\n\t\t\t    else // just copy\n\t\t\t\tcc = c;\n\n\t\t\t    if (has_mbyte)\n\t\t\t    {\n\t\t\t\tint l;\n\t\t\t\tint charlen;\n\n\t\t\t\t// Copy composing characters separately, one\n\t\t\t\t// at a time.\n\t\t\t\tif (enc_utf8)\n\t\t\t\t    l = utf_ptr2len(s) - 1;\n\t\t\t\telse\n\t\t\t\t    l = mb_ptr2len(s) - 1;\n\n\t\t\t\ts += l;\n\t\t\t\tlen -= l;\n\t\t\t\tcharlen = mb_char2len(cc);\n\t\t\t\tif (copy)\n\t\t\t\t{\n\t\t\t\t    if (dst + charlen > dest + destlen)\n\t\t\t\t    {\n\t\t\t\t\tiemsg(\"vim_regsub_both(): not enough space\");\n\t\t\t\t\treturn 0;\n\t\t\t\t    }\n\t\t\t\t    mb_char2bytes(cc, dst);\n\t\t\t\t}\n\t\t\t\tdst += charlen - 1;\n\t\t\t    }\n\t\t\t    else if (copy)\n\t\t\t    {\n\t\t\t\tif (dst + 1 > dest + destlen)\n\t\t\t\t{\n\t\t\t\t    iemsg(\"vim_regsub_both(): not enough space\");\n\t\t\t\t    return 0;\n\t\t\t\t}\n\t\t\t\t*dst = cc;\n\t\t\t    }\n\t\t\t    dst++;\n\t\t\t}\n\n\t\t\t++s;\n\t\t\t--len;\n\t\t    }\n\t\t}\n\t    }\n\t    no = -1;\n\t}\n      }\n    if (copy)\n\t*dst = NUL;\n\nexit:\n    return (int)((dst - dest) + 1);\n}\n\n#ifdef FEAT_EVAL\n/*\n * Call reg_getline() with the line numbers from the submatch.  If a\n * substitute() was used the reg_maxline and other values have been\n * overwritten.\n */\n    static char_u *\nreg_getline_submatch(linenr_T lnum)\n{\n    char_u *s;\n    linenr_T save_first = rex.reg_firstlnum;\n    linenr_T save_max = rex.reg_maxline;\n\n    rex.reg_firstlnum = rsm.sm_firstlnum;\n    rex.reg_maxline = rsm.sm_maxline;\n\n    s = reg_getline(lnum);\n\n    rex.reg_firstlnum = save_first;\n    rex.reg_maxline = save_max;\n    return s;\n}\n\n/*\n * Used for the submatch() function: get the string from the n'th submatch in\n * allocated memory.\n * Returns NULL when not in a \":s\" command and for a non-existing submatch.\n */\n    char_u *\nreg_submatch(int no)\n{\n    char_u\t*retval = NULL;\n    char_u\t*s;\n    int\t\tlen;\n    int\t\tround;\n    linenr_T\tlnum;\n\n    if (!can_f_submatch || no < 0)\n\treturn NULL;\n\n    if (rsm.sm_match == NULL)\n    {\n\t/*\n\t * First round: compute the length and allocate memory.\n\t * Second round: copy the text.\n\t */\n\tfor (round = 1; round <= 2; ++round)\n\t{\n\t    lnum = rsm.sm_mmatch->startpos[no].lnum;\n\t    if (lnum < 0 || rsm.sm_mmatch->endpos[no].lnum < 0)\n\t\treturn NULL;\n\n\t    s = reg_getline_submatch(lnum);\n\t    if (s == NULL)  // anti-crash check, cannot happen?\n\t\tbreak;\n\t    s += rsm.sm_mmatch->startpos[no].col;\n\t    if (rsm.sm_mmatch->endpos[no].lnum == lnum)\n\t    {\n\t\t// Within one line: take form start to end col.\n\t\tlen = rsm.sm_mmatch->endpos[no].col\n\t\t\t\t\t  - rsm.sm_mmatch->startpos[no].col;\n\t\tif (round == 2)\n\t\t    vim_strncpy(retval, s, len);\n\t\t++len;\n\t    }\n\t    else\n\t    {\n\t\t// Multiple lines: take start line from start col, middle\n\t\t// lines completely and end line up to end col.\n\t\tlen = (int)STRLEN(s);\n\t\tif (round == 2)\n\t\t{\n\t\t    STRCPY(retval, s);\n\t\t    retval[len] = '\\n';\n\t\t}\n\t\t++len;\n\t\t++lnum;\n\t\twhile (lnum < rsm.sm_mmatch->endpos[no].lnum)\n\t\t{\n\t\t    s = reg_getline_submatch(lnum++);\n\t\t    if (round == 2)\n\t\t\tSTRCPY(retval + len, s);\n\t\t    len += (int)STRLEN(s);\n\t\t    if (round == 2)\n\t\t\tretval[len] = '\\n';\n\t\t    ++len;\n\t\t}\n\t\tif (round == 2)\n\t\t    STRNCPY(retval + len, reg_getline_submatch(lnum),\n\t\t\t\t\t     rsm.sm_mmatch->endpos[no].col);\n\t\tlen += rsm.sm_mmatch->endpos[no].col;\n\t\tif (round == 2)\n\t\t    retval[len] = NUL;\n\t\t++len;\n\t    }\n\n\t    if (retval == NULL)\n\t    {\n\t\tretval = alloc(len);\n\t\tif (retval == NULL)\n\t\t    return NULL;\n\t    }\n\t}\n    }\n    else\n    {\n\ts = rsm.sm_match->startp[no];\n\tif (s == NULL || rsm.sm_match->endp[no] == NULL)\n\t    retval = NULL;\n\telse\n\t    retval = vim_strnsave(s, rsm.sm_match->endp[no] - s);\n    }\n\n    return retval;\n}\n\n/*\n * Used for the submatch() function with the optional non-zero argument: get\n * the list of strings from the n'th submatch in allocated memory with NULs\n * represented in NLs.\n * Returns a list of allocated strings.  Returns NULL when not in a \":s\"\n * command, for a non-existing submatch and for any error.\n */\n    list_T *\nreg_submatch_list(int no)\n{\n    char_u\t*s;\n    linenr_T\tslnum;\n    linenr_T\telnum;\n    colnr_T\tscol;\n    colnr_T\tecol;\n    int\t\ti;\n    list_T\t*list;\n    int\t\terror = FALSE;\n\n    if (!can_f_submatch || no < 0)\n\treturn NULL;\n\n    if (rsm.sm_match == NULL)\n    {\n\tslnum = rsm.sm_mmatch->startpos[no].lnum;\n\telnum = rsm.sm_mmatch->endpos[no].lnum;\n\tif (slnum < 0 || elnum < 0)\n\t    return NULL;\n\n\tscol = rsm.sm_mmatch->startpos[no].col;\n\tecol = rsm.sm_mmatch->endpos[no].col;\n\n\tlist = list_alloc();\n\tif (list == NULL)\n\t    return NULL;\n\n\ts = reg_getline_submatch(slnum) + scol;\n\tif (slnum == elnum)\n\t{\n\t    if (list_append_string(list, s, ecol - scol) == FAIL)\n\t\terror = TRUE;\n\t}\n\telse\n\t{\n\t    if (list_append_string(list, s, -1) == FAIL)\n\t\terror = TRUE;\n\t    for (i = 1; i < elnum - slnum; i++)\n\t    {\n\t\ts = reg_getline_submatch(slnum + i);\n\t\tif (list_append_string(list, s, -1) == FAIL)\n\t\t    error = TRUE;\n\t    }\n\t    s = reg_getline_submatch(elnum);\n\t    if (list_append_string(list, s, ecol) == FAIL)\n\t\terror = TRUE;\n\t}\n    }\n    else\n    {\n\ts = rsm.sm_match->startp[no];\n\tif (s == NULL || rsm.sm_match->endp[no] == NULL)\n\t    return NULL;\n\tlist = list_alloc();\n\tif (list == NULL)\n\t    return NULL;\n\tif (list_append_string(list, s,\n\t\t\t\t (int)(rsm.sm_match->endp[no] - s)) == FAIL)\n\t    error = TRUE;\n    }\n\n    if (error)\n    {\n\tlist_free(list);\n\treturn NULL;\n    }\n    ++list->lv_refcount;\n    return list;\n}\n#endif\n\n/*\n * Initialize the values used for matching against multiple lines\n */\n    static void\ninit_regexec_multi(\n\tregmmatch_T\t*rmp,\n\twin_T\t\t*win,\t// window in which to search or NULL\n\tbuf_T\t\t*buf,\t// buffer in which to search\n\tlinenr_T\tlnum)\t// nr of line to start looking for match\n{\n    rex.reg_match = NULL;\n    rex.reg_mmatch = rmp;\n    rex.reg_buf = buf;\n    rex.reg_win = win;\n    rex.reg_firstlnum = lnum;\n    rex.reg_maxline = rex.reg_buf->b_ml.ml_line_count - lnum;\n    rex.reg_line_lbr = FALSE;\n    rex.reg_ic = rmp->rmm_ic;\n    rex.reg_icombine = FALSE;\n    rex.reg_maxcol = rmp->rmm_maxcol;\n}\n\n#include \"regexp_bt.c\"\n\nstatic regengine_T bt_regengine =\n{\n    bt_regcomp,\n    bt_regfree,\n    bt_regexec_nl,\n    bt_regexec_multi,\n};\n\n#include \"regexp_nfa.c\"\n\nstatic regengine_T nfa_regengine =\n{\n    nfa_regcomp,\n    nfa_regfree,\n    nfa_regexec_nl,\n    nfa_regexec_multi,\n};\n\n// Which regexp engine to use? Needed for vim_regcomp().\n// Must match with 'regexpengine'.\nstatic int regexp_engine = 0;\n\n#ifdef DEBUG\nstatic char_u regname[][30] = {\n\t\t    \"AUTOMATIC Regexp Engine\",\n\t\t    \"BACKTRACKING Regexp Engine\",\n\t\t    \"NFA Regexp Engine\"\n\t\t\t    };\n#endif\n\n/*\n * Compile a regular expression into internal code.\n * Returns the program in allocated memory.\n * Use vim_regfree() to free the memory.\n * Returns NULL for an error.\n */\n    regprog_T *\nvim_regcomp(char_u *expr_arg, int re_flags)\n{\n    regprog_T   *prog = NULL;\n    char_u\t*expr = expr_arg;\n    int\t\tcalled_emsg_before;\n\n    regexp_engine = p_re;\n\n    // Check for prefix \"\\%#=\", that sets the regexp engine\n    if (STRNCMP(expr, \"\\\\%#=\", 4) == 0)\n    {\n\tint newengine = expr[4] - '0';\n\n\tif (newengine == AUTOMATIC_ENGINE\n\t    || newengine == BACKTRACKING_ENGINE\n\t    || newengine == NFA_ENGINE)\n\t{\n\t    regexp_engine = expr[4] - '0';\n\t    expr += 5;\n#ifdef DEBUG\n\t    smsg(\"New regexp mode selected (%d): %s\",\n\t\t\t\t\t   regexp_engine, regname[newengine]);\n#endif\n\t}\n\telse\n\t{\n\t    emsg(_(e_percent_hash_can_only_be_followed_by_zero_one_two_automatic_engine_will_be_used));\n\t    regexp_engine = AUTOMATIC_ENGINE;\n\t}\n    }\n#ifdef DEBUG\n    bt_regengine.expr = expr;\n    nfa_regengine.expr = expr;\n#endif\n    // reg_iswordc() uses rex.reg_buf\n    rex.reg_buf = curbuf;\n\n    /*\n     * First try the NFA engine, unless backtracking was requested.\n     */\n    called_emsg_before = called_emsg;\n    if (regexp_engine != BACKTRACKING_ENGINE)\n\tprog = nfa_regengine.regcomp(expr,\n\t\tre_flags + (regexp_engine == AUTOMATIC_ENGINE ? RE_AUTO : 0));\n    else\n\tprog = bt_regengine.regcomp(expr, re_flags);\n\n    // Check for error compiling regexp with initial engine.\n    if (prog == NULL)\n    {\n#ifdef BT_REGEXP_DEBUG_LOG\n\tif (regexp_engine == BACKTRACKING_ENGINE)   // debugging log for BT engine\n\t{\n\t    FILE *f;\n\t    f = fopen(BT_REGEXP_DEBUG_LOG_NAME, \"a\");\n\t    if (f)\n\t    {\n\t\tfprintf(f, \"Syntax error in \\\"%s\\\"\\n\", expr);\n\t\tfclose(f);\n\t    }\n\t    else\n\t\tsemsg(\"(NFA) Could not open \\\"%s\\\" to write !!!\",\n\t\t\tBT_REGEXP_DEBUG_LOG_NAME);\n\t}\n#endif\n\t/*\n\t * If the NFA engine failed, try the backtracking engine.\n\t * The NFA engine also fails for patterns that it can't handle well\n\t * but are still valid patterns, thus a retry should work.\n\t * But don't try if an error message was given.\n\t */\n\tif (regexp_engine == AUTOMATIC_ENGINE\n\t\t\t\t\t  && called_emsg == called_emsg_before)\n\t{\n\t    regexp_engine = BACKTRACKING_ENGINE;\n#ifdef FEAT_EVAL\n\t    report_re_switch(expr);\n#endif\n\t    prog = bt_regengine.regcomp(expr, re_flags);\n\t}\n    }\n\n    if (prog != NULL)\n    {\n\t// Store the info needed to call regcomp() again when the engine turns\n\t// out to be very slow when executing it.\n\tprog->re_engine = regexp_engine;\n\tprog->re_flags  = re_flags;\n    }\n\n    return prog;\n}\n\n/*\n * Free a compiled regexp program, returned by vim_regcomp().\n */\n    void\nvim_regfree(regprog_T *prog)\n{\n    if (prog != NULL)\n\tprog->engine->regfree(prog);\n}\n\n#if defined(EXITFREE) || defined(PROTO)\n    void\nfree_regexp_stuff(void)\n{\n    ga_clear(&regstack);\n    ga_clear(&backpos);\n    vim_free(reg_tofree);\n    vim_free(reg_prev_sub);\n}\n#endif\n\n#ifdef FEAT_EVAL\n    static void\nreport_re_switch(char_u *pat)\n{\n    if (p_verbose > 0)\n    {\n\tverbose_enter();\n\tmsg_puts(_(\"Switching to backtracking RE engine for pattern: \"));\n\tmsg_puts((char *)pat);\n\tverbose_leave();\n    }\n}\n#endif\n\n#if defined(FEAT_X11) || defined(PROTO)\n/*\n * Return whether \"prog\" is currently being executed.\n */\n    int\nregprog_in_use(regprog_T *prog)\n{\n    return prog->re_in_use;\n}\n#endif\n\n/*\n * Match a regexp against a string.\n * \"rmp->regprog\" must be a compiled regexp as returned by vim_regcomp().\n * Note: \"rmp->regprog\" may be freed and changed.\n * Uses curbuf for line count and 'iskeyword'.\n * When \"nl\" is TRUE consider a \"\\n\" in \"line\" to be a line break.\n *\n * Return TRUE if there is a match, FALSE if not.\n */\n    static int\nvim_regexec_string(\n    regmatch_T\t*rmp,\n    char_u\t*line,  // string to match against\n    colnr_T\tcol,    // column to start looking for match\n    int\t\tnl)\n{\n    int\t\tresult;\n    regexec_T\trex_save;\n    int\t\trex_in_use_save = rex_in_use;\n\n    // Cannot use the same prog recursively, it contains state.\n    if (rmp->regprog->re_in_use)\n    {\n\temsg(_(e_cannot_use_pattern_recursively));\n\treturn FALSE;\n    }\n    rmp->regprog->re_in_use = TRUE;\n\n    if (rex_in_use)\n\t// Being called recursively, save the state.\n\trex_save = rex;\n    rex_in_use = TRUE;\n\n    rex.reg_startp = NULL;\n    rex.reg_endp = NULL;\n    rex.reg_startpos = NULL;\n    rex.reg_endpos = NULL;\n\n    result = rmp->regprog->engine->regexec_nl(rmp, line, col, nl);\n    rmp->regprog->re_in_use = FALSE;\n\n    // NFA engine aborted because it's very slow.\n    if (rmp->regprog->re_engine == AUTOMATIC_ENGINE\n\t\t\t\t\t       && result == NFA_TOO_EXPENSIVE)\n    {\n\tint    save_p_re = p_re;\n\tint    re_flags = rmp->regprog->re_flags;\n\tchar_u *pat = vim_strsave(((nfa_regprog_T *)rmp->regprog)->pattern);\n\n\tp_re = BACKTRACKING_ENGINE;\n\tvim_regfree(rmp->regprog);\n\tif (pat != NULL)\n\t{\n#ifdef FEAT_EVAL\n\t    report_re_switch(pat);\n#endif\n\t    rmp->regprog = vim_regcomp(pat, re_flags);\n\t    if (rmp->regprog != NULL)\n\t    {\n\t\trmp->regprog->re_in_use = TRUE;\n\t\tresult = rmp->regprog->engine->regexec_nl(rmp, line, col, nl);\n\t\trmp->regprog->re_in_use = FALSE;\n\t    }\n\t    vim_free(pat);\n\t}\n\n\tp_re = save_p_re;\n    }\n\n    rex_in_use = rex_in_use_save;\n    if (rex_in_use)\n\trex = rex_save;\n\n    return result > 0;\n}\n\n#if defined(FEAT_SPELL) || defined(FEAT_EVAL) || defined(FEAT_X11) || defined(PROTO)\n/*\n * Note: \"*prog\" may be freed and changed.\n * Return TRUE if there is a match, FALSE if not.\n */\n    int\nvim_regexec_prog(\n    regprog_T\t**prog,\n    int\t\tignore_case,\n    char_u\t*line,\n    colnr_T\tcol)\n{\n    int\t\tr;\n    regmatch_T\tregmatch;\n\n    regmatch.regprog = *prog;\n    regmatch.rm_ic = ignore_case;\n    r = vim_regexec_string(&regmatch, line, col, FALSE);\n    *prog = regmatch.regprog;\n    return r;\n}\n#endif\n\n/*\n * Note: \"rmp->regprog\" may be freed and changed.\n * Return TRUE if there is a match, FALSE if not.\n */\n    int\nvim_regexec(regmatch_T *rmp, char_u *line, colnr_T col)\n{\n    return vim_regexec_string(rmp, line, col, FALSE);\n}\n\n/*\n * Like vim_regexec(), but consider a \"\\n\" in \"line\" to be a line break.\n * Note: \"rmp->regprog\" may be freed and changed.\n * Return TRUE if there is a match, FALSE if not.\n */\n    int\nvim_regexec_nl(regmatch_T *rmp, char_u *line, colnr_T col)\n{\n    return vim_regexec_string(rmp, line, col, TRUE);\n}\n\n/*\n * Match a regexp against multiple lines.\n * \"rmp->regprog\" must be a compiled regexp as returned by vim_regcomp().\n * Note: \"rmp->regprog\" may be freed and changed, even set to NULL.\n * Uses curbuf for line count and 'iskeyword'.\n *\n * Return zero if there is no match.  Return number of lines contained in the\n * match otherwise.\n */\n    long\nvim_regexec_multi(\n    regmmatch_T *rmp,\n    win_T       *win,\t\t// window in which to search or NULL\n    buf_T       *buf,\t\t// buffer in which to search\n    linenr_T\tlnum,\t\t// nr of line to start looking for match\n    colnr_T\tcol,\t\t// column to start looking for match\n    int\t\t*timed_out)\t// flag is set when timeout limit reached\n{\n    int\t\tresult;\n    regexec_T\trex_save;\n    int\t\trex_in_use_save = rex_in_use;\n\n    // Cannot use the same prog recursively, it contains state.\n    if (rmp->regprog->re_in_use)\n    {\n\temsg(_(e_cannot_use_pattern_recursively));\n\treturn FALSE;\n    }\n    rmp->regprog->re_in_use = TRUE;\n\n    if (rex_in_use)\n\t// Being called recursively, save the state.\n\trex_save = rex;\n    rex_in_use = TRUE;\n\n    result = rmp->regprog->engine->regexec_multi(\n\t\t\t\t      rmp, win, buf, lnum, col, timed_out);\n    rmp->regprog->re_in_use = FALSE;\n\n    // NFA engine aborted because it's very slow.\n    if (rmp->regprog->re_engine == AUTOMATIC_ENGINE\n\t\t\t\t\t       && result == NFA_TOO_EXPENSIVE)\n    {\n\tint    save_p_re = p_re;\n\tint    re_flags = rmp->regprog->re_flags;\n\tchar_u *pat = vim_strsave(((nfa_regprog_T *)rmp->regprog)->pattern);\n\n\tp_re = BACKTRACKING_ENGINE;\n\tif (pat != NULL)\n\t{\n\t    regprog_T *prev_prog = rmp->regprog;\n\n#ifdef FEAT_EVAL\n\t    report_re_switch(pat);\n#endif\n#ifdef FEAT_SYN_HL\n\t    // checking for \\z misuse was already done when compiling for NFA,\n\t    // allow all here\n\t    reg_do_extmatch = REX_ALL;\n#endif\n\t    rmp->regprog = vim_regcomp(pat, re_flags);\n#ifdef FEAT_SYN_HL\n\t    reg_do_extmatch = 0;\n#endif\n\t    if (rmp->regprog == NULL)\n\t    {\n\t\t// Somehow compiling the pattern failed now, put back the\n\t\t// previous one to avoid \"regprog\" becoming NULL.\n\t\trmp->regprog = prev_prog;\n\t    }\n\t    else\n\t    {\n\t\tvim_regfree(prev_prog);\n\n\t\trmp->regprog->re_in_use = TRUE;\n\t\tresult = rmp->regprog->engine->regexec_multi(\n\t\t\t\t      rmp, win, buf, lnum, col, timed_out);\n\t\trmp->regprog->re_in_use = FALSE;\n\t    }\n\t    vim_free(pat);\n\t}\n\tp_re = save_p_re;\n    }\n\n    rex_in_use = rex_in_use_save;\n    if (rex_in_use)\n\trex = rex_save;\n\n    return result <= 0 ? 0 : result;\n}\n", "\" Tests for the substitute (:s) command\n\nsource shared.vim\nsource check.vim\nsource screendump.vim\n\nfunc Test_multiline_subst()\n  enew!\n  call append(0, [\"1 aa\",\n\t      \\ \"bb\",\n\t      \\ \"cc\",\n\t      \\ \"2 dd\",\n\t      \\ \"ee\",\n\t      \\ \"3 ef\",\n\t      \\ \"gh\",\n\t      \\ \"4 ij\",\n\t      \\ \"5 a8\",\n\t      \\ \"8b c9\",\n\t      \\ \"9d\",\n\t      \\ \"6 e7\",\n\t      \\ \"77f\",\n\t      \\ \"xxxxx\"])\n\n  1\n  \" test if replacing a line break works with a back reference\n  /^1/,/^2/s/\\n\\(.\\)/ \\1/\n  \" test if inserting a line break works with a back reference\n  /^3/,/^4/s/\\(.\\)$/\\r\\1/\n  \" test if replacing a line break with another line break works\n  /^5/,/^6/s/\\(\\_d\\{3}\\)/x\\1x/\n  call assert_equal('1 aa bb cc 2 dd ee', getline(1))\n  call assert_equal('3 e', getline(2))\n  call assert_equal('f', getline(3))\n  call assert_equal('g', getline(4))\n  call assert_equal('h', getline(5))\n  call assert_equal('4 i', getline(6))\n  call assert_equal('j', getline(7))\n  call assert_equal('5 ax8', getline(8))\n  call assert_equal('8xb cx9', getline(9))\n  call assert_equal('9xd', getline(10))\n  call assert_equal('6 ex7', getline(11))\n  call assert_equal('7x7f', getline(12))\n  call assert_equal('xxxxx', getline(13))\n  enew!\nendfunc\n\nfunc Test_substitute_variants()\n  \" Validate that all the 2-/3-letter variants which embed the flags into the\n  \" command name actually work.\n  enew!\n  let ln = 'Testing string'\n  let variants = [\n\t\\ { 'cmd': ':s/Test/test/c', 'exp': 'testing string', 'prompt': 'y' },\n\t\\ { 'cmd': ':s/foo/bar/ce', 'exp': ln },\n\t\\ { 'cmd': ':s/t/r/cg', 'exp': 'Tesring srring', 'prompt': 'a' },\n\t\\ { 'cmd': ':s/t/r/ci', 'exp': 'resting string', 'prompt': 'y' },\n\t\\ { 'cmd': ':s/t/r/cI', 'exp': 'Tesring string', 'prompt': 'y' },\n\t\\ { 'cmd': ':s/t/r/c', 'exp': 'Testing string', 'prompt': 'n' },\n\t\\ { 'cmd': ':s/t/r/cn', 'exp': ln },\n\t\\ { 'cmd': ':s/t/r/cp', 'exp': 'Tesring string', 'prompt': 'y' },\n\t\\ { 'cmd': ':s/t/r/cl', 'exp': 'Tesring string', 'prompt': 'y' },\n\t\\ { 'cmd': ':s/t/r/gc', 'exp': 'Tesring srring', 'prompt': 'a' },\n\t\\ { 'cmd': ':s/i/I/gc', 'exp': 'TestIng string', 'prompt': 'l' },\n\t\\ { 'cmd': ':s/foo/bar/ge', 'exp': ln },\n\t\\ { 'cmd': ':s/t/r/g', 'exp': 'Tesring srring' },\n\t\\ { 'cmd': ':s/t/r/gi', 'exp': 'resring srring' },\n\t\\ { 'cmd': ':s/t/r/gI', 'exp': 'Tesring srring' },\n\t\\ { 'cmd': ':s/t/r/gn', 'exp': ln },\n\t\\ { 'cmd': ':s/t/r/gp', 'exp': 'Tesring srring' },\n\t\\ { 'cmd': ':s/t/r/gl', 'exp': 'Tesring srring' },\n\t\\ { 'cmd': ':s//r/gr', 'exp': 'Testr strr' },\n\t\\ { 'cmd': ':s/t/r/ic', 'exp': 'resting string', 'prompt': 'y' },\n\t\\ { 'cmd': ':s/foo/bar/ie', 'exp': ln },\n\t\\ { 'cmd': ':s/t/r/i', 'exp': 'resting string' },\n\t\\ { 'cmd': ':s/t/r/iI', 'exp': 'Tesring string' },\n\t\\ { 'cmd': ':s/t/r/in', 'exp': ln },\n\t\\ { 'cmd': ':s/t/r/ip', 'exp': 'resting string' },\n\t\\ { 'cmd': ':s//r/ir', 'exp': 'Testr string' },\n\t\\ { 'cmd': ':s/t/r/Ic', 'exp': 'Tesring string', 'prompt': 'y' },\n\t\\ { 'cmd': ':s/foo/bar/Ie', 'exp': ln },\n\t\\ { 'cmd': ':s/t/r/Ig', 'exp': 'Tesring srring' },\n\t\\ { 'cmd': ':s/t/r/Ii', 'exp': 'resting string' },\n\t\\ { 'cmd': ':s/t/r/I', 'exp': 'Tesring string' },\n\t\\ { 'cmd': ':s/t/r/Ip', 'exp': 'Tesring string' },\n\t\\ { 'cmd': ':s/t/r/Il', 'exp': 'Tesring string' },\n\t\\ { 'cmd': ':s//r/Ir', 'exp': 'Testr string' },\n\t\\ { 'cmd': ':s//r/rc', 'exp': 'Testr string', 'prompt': 'y' },\n\t\\ { 'cmd': ':s//r/rg', 'exp': 'Testr strr' },\n\t\\ { 'cmd': ':s//r/ri', 'exp': 'Testr string' },\n\t\\ { 'cmd': ':s//r/rI', 'exp': 'Testr string' },\n\t\\ { 'cmd': ':s//r/rn', 'exp': 'Testing string' },\n\t\\ { 'cmd': ':s//r/rp', 'exp': 'Testr string' },\n\t\\ { 'cmd': ':s//r/rl', 'exp': 'Testr string' },\n\t\\ { 'cmd': ':s//r/r', 'exp': 'Testr string' },\n\t\\ { 'cmd': ':s/i/I/gc', 'exp': 'Testing string', 'prompt': 'q' },\n\t\\]\n\n  for var in variants\n    for run in [1, 2]\n      let cmd = var.cmd\n      if run == 2 && cmd =~ \"/.*/.*/.\"\n\t\" Change  :s/from/to/{flags}  to  :s{flags}\n\tlet cmd = substitute(cmd, '/.*/', '', '')\n      endif\n      call setline(1, [ln])\n      let msg = printf('using \"%s\"', cmd)\n      let @/='ing'\n      let v:errmsg = ''\n      call feedkeys(cmd . \"\\<CR>\" . get(var, 'prompt', ''), 'ntx')\n      \" No error should exist (matters for testing e flag)\n      call assert_equal('', v:errmsg, msg)\n      call assert_equal(var.exp, getline('.'), msg)\n    endfor\n  endfor\nendfunc\n\n\" Test the l, p, # flags.\nfunc Test_substitute_flags_lp()\n  new\n  call setline(1, \"abc\\tdef\\<C-h>ghi\")\n\n  let a = execute('s/a/a/p')\n  call assert_equal(\"\\nabc     def^Hghi\", a)\n\n  let a = execute('s/a/a/l')\n  call assert_equal(\"\\nabc^Idef^Hghi$\", a)\n\n  let a = execute('s/a/a/#')\n  call assert_equal(\"\\n  1 abc     def^Hghi\", a)\n\n  let a = execute('s/a/a/p#')\n  call assert_equal(\"\\n  1 abc     def^Hghi\", a)\n\n  let a = execute('s/a/a/l#')\n  call assert_equal(\"\\n  1 abc^Idef^Hghi$\", a)\n\n  let a = execute('s/a/a/')\n  call assert_equal(\"\", a)\n\n  bwipe!\nendfunc\n\nfunc Test_substitute_repeat()\n  \" This caused an invalid memory access.\n  split Xsubfile\n  s/^/x\n  call feedkeys(\"Qsc\\<CR>y\", 'tx')\n  bwipe!\nendfunc\n\n\" Test %s/\\n// which is implemented as a special case to use a\n\" more efficient join rather than doing a regular substitution.\nfunc Test_substitute_join()\n  new\n\n  call setline(1, [\"foo\\tbar\", \"bar\\<C-H>foo\"])\n  let a = execute('%s/\\n//')\n  call assert_equal(\"\", a)\n  call assert_equal([\"foo\\tbarbar\\<C-H>foo\"], getline(1, '$'))\n  call assert_equal('\\n', histget(\"search\", -1))\n\n  call setline(1, [\"foo\\tbar\", \"bar\\<C-H>foo\"])\n  let a = execute('%s/\\n//g')\n  call assert_equal(\"\", a)\n  call assert_equal([\"foo\\tbarbar\\<C-H>foo\"], getline(1, '$'))\n  call assert_equal('\\n', histget(\"search\", -1))\n\n  call setline(1, [\"foo\\tbar\", \"bar\\<C-H>foo\"])\n  let a = execute('%s/\\n//p')\n  call assert_equal(\"\\nfoo     barbar^Hfoo\", a)\n  call assert_equal([\"foo\\tbarbar\\<C-H>foo\"], getline(1, '$'))\n  call assert_equal('\\n', histget(\"search\", -1))\n\n  call setline(1, [\"foo\\tbar\", \"bar\\<C-H>foo\"])\n  let a = execute('%s/\\n//l')\n  call assert_equal(\"\\nfoo^Ibarbar^Hfoo$\", a)\n  call assert_equal([\"foo\\tbarbar\\<C-H>foo\"], getline(1, '$'))\n  call assert_equal('\\n', histget(\"search\", -1))\n\n  call setline(1, [\"foo\\tbar\", \"bar\\<C-H>foo\"])\n  let a = execute('%s/\\n//#')\n  call assert_equal(\"\\n  1 foo     barbar^Hfoo\", a)\n  call assert_equal([\"foo\\tbarbar\\<C-H>foo\"], getline(1, '$'))\n  call assert_equal('\\n', histget(\"search\", -1))\n\n  call setline(1, ['foo', 'bar', 'baz', 'qux'])\n  call execute('1,2s/\\n//')\n  call assert_equal(['foobarbaz', 'qux'], getline(1, '$'))\n\n  bwipe!\nendfunc\n\nfunc Test_substitute_count()\n  new\n  call setline(1, ['foo foo', 'foo foo', 'foo foo', 'foo foo', 'foo foo'])\n  2\n\n  s/foo/bar/3\n  call assert_equal(['foo foo', 'bar foo', 'bar foo', 'bar foo', 'foo foo'],\n  \\                 getline(1, '$'))\n\n  call assert_fails('s/foo/bar/0', 'E939:')\n\n  call setline(1, ['foo foo', 'foo foo', 'foo foo', 'foo foo', 'foo foo'])\n  2,4s/foo/bar/ 10\n  call assert_equal(['foo foo', 'foo foo', 'foo foo', 'bar foo', 'bar foo'],\n        \\           getline(1, '$'))\n\n  bwipe!\nendfunc\n\n\" Test substitute 'n' flag (report number of matches, do not substitute).\nfunc Test_substitute_flag_n()\n  new\n  let lines = ['foo foo', 'foo foo', 'foo foo', 'foo foo', 'foo foo']\n  call setline(1, lines)\n\n  call assert_equal(\"\\n3 matches on 3 lines\", execute('2,4s/foo/bar/n'))\n  call assert_equal(\"\\n6 matches on 3 lines\", execute('2,4s/foo/bar/gn'))\n\n  \" c flag (confirm) should be ignored when using n flag.\n  call assert_equal(\"\\n3 matches on 3 lines\", execute('2,4s/foo/bar/nc'))\n\n  \" No substitution should have been done.\n  call assert_equal(lines, getline(1, '$'))\n\n  %delete _\n  call setline(1, ['A', 'Bar', 'Baz'])\n  call assert_equal(\"\\n1 match on 1 line\", execute('s/\\nB\\@=//gn'))\n\n  bwipe!\nendfunc\n\nfunc Test_substitute_errors()\n  new\n  call setline(1, 'foobar')\n\n  call assert_fails('s/FOO/bar/', 'E486:')\n  call assert_fails('s/foo/bar/@', 'E488:')\n  call assert_fails('s/\\(/bar/', 'E54:')\n  call assert_fails('s afooabara', 'E146:')\n  call assert_fails('s\\\\a', 'E10:')\n\n  setl nomodifiable\n  call assert_fails('s/foo/bar/', 'E21:')\n\n  call assert_fails(\"let s=substitute([], 'a', 'A', 'g')\", 'E730:')\n  call assert_fails(\"let s=substitute('abcda', [], 'A', 'g')\", 'E730:')\n  call assert_fails(\"let s=substitute('abcda', 'a', [], 'g')\", 'E730:')\n  call assert_fails(\"let s=substitute('abcda', 'a', 'A', [])\", 'E730:')\n  call assert_fails(\"let s=substitute('abc', '\\\\%(', 'A', 'g')\", 'E53:')\n\n  bwipe!\nendfunc\n\n\" Test for *sub-replace-special* and *sub-replace-expression* on substitute().\nfunc Test_sub_replace_1()\n  \" Run the tests with 'magic' on\n  set magic\n  set cpo&\n  call assert_equal('AA', substitute('A', 'A', '&&', ''))\n  call assert_equal('&', substitute('B', 'B', '\\&', ''))\n  call assert_equal('C123456789987654321', substitute('C123456789', 'C\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)', '\\0\\9\\8\\7\\6\\5\\4\\3\\2\\1', ''))\n  call assert_equal('d', substitute('D', 'D', 'd', ''))\n  call assert_equal('~', substitute('E', 'E', '~', ''))\n  call assert_equal('~', substitute('F', 'F', '\\~', ''))\n  call assert_equal('Gg', substitute('G', 'G', '\\ugg', ''))\n  call assert_equal('Hh', substitute('H', 'H', '\\Uh\\Eh', ''))\n  call assert_equal('iI', substitute('I', 'I', '\\lII', ''))\n  call assert_equal('jJ', substitute('J', 'J', '\\LJ\\EJ', ''))\n  call assert_equal('Kk', substitute('K', 'K', '\\Uk\\ek', ''))\n  call assert_equal(\"l\\<C-V>\\<C-M>l\",\n\t\t\t\\ substitute('lLl', 'L', \"\\<C-V>\\<C-M>\", ''))\n  call assert_equal(\"m\\<C-M>m\", substitute('mMm', 'M', '\\r', ''))\n  call assert_equal(\"n\\<C-V>\\<C-M>n\",\n\t\t\t\\ substitute('nNn', 'N', \"\\\\\\<C-V>\\<C-M>\", ''))\n  call assert_equal(\"o\\no\", substitute('oOo', 'O', '\\n', ''))\n  call assert_equal(\"p\\<C-H>p\", substitute('pPp', 'P', '\\b', ''))\n  call assert_equal(\"q\\tq\", substitute('qQq', 'Q', '\\t', ''))\n  call assert_equal('r\\r', substitute('rRr', 'R', '\\\\', ''))\n  call assert_equal('scs', substitute('sSs', 'S', '\\c', ''))\n  call assert_equal(\"u\\nu\", substitute('uUu', 'U', \"\\n\", ''))\n  call assert_equal(\"v\\<C-H>v\", substitute('vVv', 'V', \"\\b\", ''))\n  call assert_equal(\"w\\\\w\", substitute('wWw', 'W', \"\\\\\", ''))\n  call assert_equal(\"x\\<C-M>x\", substitute('xXx', 'X', \"\\r\", ''))\n  call assert_equal(\"YyyY\", substitute('Y', 'Y', '\\L\\uyYy\\l\\EY', ''))\n  call assert_equal(\"zZZz\", substitute('Z', 'Z', '\\U\\lZzZ\\u\\Ez', ''))\n  \" \\v or \\V after $\n  call assert_equal('abxx', substitute('abcd', 'xy$\\v|cd$', 'xx', ''))\n  call assert_equal('abxx', substitute('abcd', 'xy$\\V\\|cd\\$', 'xx', ''))\nendfunc\n\nfunc Test_sub_replace_2()\n  \" Run the tests with 'magic' off\n  set nomagic\n  set cpo&\n  call assert_equal('AA', substitute('A', 'A', '&&', ''))\n  call assert_equal('&', substitute('B', 'B', '\\&', ''))\n  call assert_equal('C123456789987654321', substitute('C123456789', 'C\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)', '\\0\\9\\8\\7\\6\\5\\4\\3\\2\\1', ''))\n  call assert_equal('d', substitute('D', 'D', 'd', ''))\n  call assert_equal('~', substitute('E', 'E', '~', ''))\n  call assert_equal('~', substitute('F', 'F', '\\~', ''))\n  call assert_equal('Gg', substitute('G', 'G', '\\ugg', ''))\n  call assert_equal('Hh', substitute('H', 'H', '\\Uh\\Eh', ''))\n  call assert_equal('iI', substitute('I', 'I', '\\lII', ''))\n  call assert_equal('jJ', substitute('J', 'J', '\\LJ\\EJ', ''))\n  call assert_equal('Kk', substitute('K', 'K', '\\Uk\\ek', ''))\n  call assert_equal(\"l\\<C-V>\\<C-M>l\",\n\t\t\t\\ substitute('lLl', 'L', \"\\<C-V>\\<C-M>\", ''))\n  call assert_equal(\"m\\<C-M>m\", substitute('mMm', 'M', '\\r', ''))\n  call assert_equal(\"n\\<C-V>\\<C-M>n\",\n\t\t\t\\ substitute('nNn', 'N', \"\\\\\\<C-V>\\<C-M>\", ''))\n  call assert_equal(\"o\\no\", substitute('oOo', 'O', '\\n', ''))\n  call assert_equal(\"p\\<C-H>p\", substitute('pPp', 'P', '\\b', ''))\n  call assert_equal(\"q\\tq\", substitute('qQq', 'Q', '\\t', ''))\n  call assert_equal('r\\r', substitute('rRr', 'R', '\\\\', ''))\n  call assert_equal('scs', substitute('sSs', 'S', '\\c', ''))\n  call assert_equal(\"t\\<C-M>t\", substitute('tTt', 'T', \"\\r\", ''))\n  call assert_equal(\"u\\nu\", substitute('uUu', 'U', \"\\n\", ''))\n  call assert_equal(\"v\\<C-H>v\", substitute('vVv', 'V', \"\\b\", ''))\n  call assert_equal('w\\w', substitute('wWw', 'W', \"\\\\\", ''))\n  call assert_equal('XxxX', substitute('X', 'X', '\\L\\uxXx\\l\\EX', ''))\n  call assert_equal('yYYy', substitute('Y', 'Y', '\\U\\lYyY\\u\\Ey', ''))\nendfunc\n\nfunc Test_sub_replace_3()\n  set magic&\n  set cpo&\n  call assert_equal('a\\a', substitute('aAa', 'A', '\\=\"\\\\\"', ''))\n  call assert_equal('b\\\\b', substitute('bBb', 'B', '\\=\"\\\\\\\\\"', ''))\n  call assert_equal(\"c\\rc\", substitute('cCc', 'C', \"\\\\=\\\"\\r\\\"\", ''))\n  call assert_equal(\"d\\\\\\rd\", substitute('dDd', 'D', \"\\\\=\\\"\\\\\\\\\\r\\\"\", ''))\n  call assert_equal(\"e\\\\\\\\\\re\", substitute('eEe', 'E', \"\\\\=\\\"\\\\\\\\\\\\\\\\\\r\\\"\", ''))\n  call assert_equal('f\\rf', substitute('fFf', 'F', '\\=\"\\\\r\"', ''))\n  call assert_equal('j\\nj', substitute('jJj', 'J', '\\=\"\\\\n\"', ''))\n  call assert_equal(\"k\\<C-M>k\", substitute('kKk', 'K', '\\=\"\\r\"', ''))\n  call assert_equal(\"l\\nl\", substitute('lLl', 'L', '\\=\"\\n\"', ''))\nendfunc\n\n\" Test for submatch() on substitute().\nfunc Test_sub_replace_4()\n  set magic&\n  set cpo&\n  call assert_equal('a\\a', substitute('aAa', 'A',\n\t\t\\ '\\=substitute(submatch(0), \".\", \"\\\\\", \"\")', ''))\n  call assert_equal('b\\b', substitute('bBb', 'B',\n\t\t\\ '\\=substitute(submatch(0), \".\", \"\\\\\\\\\", \"\")', ''))\n  call assert_equal(\"c\\<C-V>\\<C-M>c\", substitute('cCc', 'C', '\\=substitute(submatch(0), \".\", \"\\<C-V>\\<C-M>\", \"\")', ''))\n  call assert_equal(\"d\\<C-V>\\<C-M>d\", substitute('dDd', 'D', '\\=substitute(submatch(0), \".\", \"\\\\\\<C-V>\\<C-M>\", \"\")', ''))\n  call assert_equal(\"e\\\\\\<C-V>\\<C-M>e\", substitute('eEe', 'E', '\\=substitute(submatch(0), \".\", \"\\\\\\\\\\<C-V>\\<C-M>\", \"\")', ''))\n  call assert_equal(\"f\\<C-M>f\", substitute('fFf', 'F', '\\=substitute(submatch(0), \".\", \"\\\\r\", \"\")', ''))\n  call assert_equal(\"j\\nj\", substitute('jJj', 'J', '\\=substitute(submatch(0), \".\", \"\\\\n\", \"\")', ''))\n  call assert_equal(\"k\\rk\", substitute('kKk', 'K', '\\=substitute(submatch(0), \".\", \"\\r\", \"\")', ''))\n  call assert_equal(\"l\\nl\", substitute('lLl', 'L', '\\=substitute(submatch(0), \".\", \"\\n\", \"\")', ''))\nendfunc\n\nfunc Test_sub_replace_5()\n  set magic&\n  set cpo&\n  call assert_equal('A123456789987654321', substitute('A123456789',\n\t\t\\ 'A\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)',\n\t\t\\ '\\=submatch(0) . submatch(9) . submatch(8) . ' .\n\t\t\\ 'submatch(7) . submatch(6) . submatch(5) . ' .\n\t\t\\ 'submatch(4) . submatch(3) . submatch(2) . submatch(1)',\n\t\t\\ ''))\n   call assert_equal(\"[['A123456789'], ['9'], ['8'], ['7'], ['6'], \" .\n\t\t\\ \"['5'], ['4'], ['3'], ['2'], ['1']]\",\n\t\t\\ substitute('A123456789',\n\t\t\\ 'A\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)',\n\t\t\\ '\\=string([submatch(0, 1), submatch(9, 1), ' .\n\t\t\\ 'submatch(8, 1), 7->submatch(1), submatch(6, 1), ' .\n\t\t\\ 'submatch(5, 1), submatch(4, 1), submatch(3, 1), ' .\n\t\t\\ 'submatch(2, 1), submatch(1, 1)])',\n\t\t\\ ''))\nendfunc\n\nfunc Test_sub_replace_6()\n  set magic&\n  set cpo+=/\n  call assert_equal('a', substitute('A', 'A', 'a', ''))\n  call assert_equal('%', substitute('B', 'B', '%', ''))\n  set cpo-=/\n  call assert_equal('c', substitute('C', 'C', 'c', ''))\n  call assert_equal('%', substitute('D', 'D', '%', ''))\nendfunc\n\nfunc Test_sub_replace_7()\n  set magic&\n  set cpo&\n  call assert_equal('A\u0016A', substitute('A\u0016A', 'A.', '\\=submatch(0)', ''))\n  call assert_equal(\"B\\nB\", substitute(\"B\\nB\", 'B.', '\\=submatch(0)', ''))\n  call assert_equal(\"['B\\n']B\", substitute(\"B\\nB\", 'B.', '\\=string(submatch(0, 1))', ''))\n  call assert_equal('-abab', substitute('-bb', '\\zeb', 'a', 'g'))\n  call assert_equal('c-cbcbc', substitute('-bb', '\\ze', 'c', 'g'))\nendfunc\n\n\" Test for *:s%* on :substitute.\nfunc Test_sub_replace_8()\n  new\n  set magic&\n  set cpo&\n  $put =',,X'\n  s/\\(^\\|,\\)\\ze\\(,\\|X\\)/\\1N/g\n  call assert_equal('N,,NX', getline(\"$\"))\n  $put =',,Y'\n  let cmd = ':s/\\(^\\|,\\)\\ze\\(,\\|Y\\)/\\1N/gc'\n  call feedkeys(cmd . \"\\<CR>a\", \"xt\")\n  call assert_equal('N,,NY', getline(\"$\"))\n  :$put =',,Z'\n  let cmd = ':s/\\(^\\|,\\)\\ze\\(,\\|Z\\)/\\1N/gc'\n  call feedkeys(cmd . \"\\<CR>yy\", \"xt\")\n  call assert_equal('N,,NZ', getline(\"$\"))\n  enew! | close\nendfunc\n\nfunc Test_sub_replace_9()\n  new\n  set magic&\n  set cpo&\n  $put ='xxx'\n  call feedkeys(\":s/x/X/gc\\<CR>yyq\", \"xt\")\n  call assert_equal('XXx', getline(\"$\"))\n  enew! | close\nendfunc\n\nfunc Test_sub_replace_10()\n   set magic&\n   set cpo&\n   call assert_equal('a1a2a3a', substitute('123', '\\zs', 'a', 'g'))\n   call assert_equal('aaa', substitute('123', '\\zs.', 'a', 'g'))\n   call assert_equal('1a2a3a', substitute('123', '.\\zs', 'a', 'g'))\n   call assert_equal('a1a2a3a', substitute('123', '\\ze', 'a', 'g'))\n   call assert_equal('a1a2a3', substitute('123', '\\ze.', 'a', 'g'))\n   call assert_equal('aaa', substitute('123', '.\\ze', 'a', 'g'))\n   call assert_equal('aa2a3a', substitute('123', '1\\|\\ze', 'a', 'g'))\n   call assert_equal('1aaa', substitute('123', '1\\zs\\|[23]', 'a', 'g'))\nendfunc\n\nfunc SubReplacer(text, submatches)\n  return a:text .. a:submatches[0] .. a:text\nendfunc\nfunc SubReplacerVar(text, ...)\n  return a:text .. a:1[0] .. a:text\nendfunc\ndef SubReplacerVar9(text: string, ...args: list<list<string>>): string\n  return text .. args[0][0] .. text\nenddef\nfunc SubReplacer20(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19, submatches)\n  return a:t3 .. a:submatches[0] .. a:t11\nendfunc\n\nfunc Test_substitute_partial()\n  call assert_equal('1foo2foo3', substitute('123', '2', function('SubReplacer', ['foo']), 'g'))\n  call assert_equal('1foo2foo3', substitute('123', '2', function('SubReplacerVar', ['foo']), 'g'))\n  call assert_equal('1foo2foo3', substitute('123', '2', function('SubReplacerVar9', ['foo']), 'g'))\n\n  \" 19 arguments plus one is just OK\n  let Replacer = function('SubReplacer20', repeat(['foo'], 19))\n  call assert_equal('1foo2foo3', substitute('123', '2', Replacer, 'g'))\n\n  \" 20 arguments plus one is too many\n  let Replacer = function('SubReplacer20', repeat(['foo'], 20))\n  call assert_fails(\"call substitute('123', '2', Replacer, 'g')\", 'E118:')\nendfunc\n\nfunc Test_substitute_float()\n  call assert_equal('number 1.23', substitute('number ', '$', { -> 1.23 }, ''))\n  vim9 assert_equal('number 1.23', substitute('number ', '$', () => 1.23, ''))\nendfunc\n\n\" Tests for *sub-replace-special* and *sub-replace-expression* on :substitute.\n\n\" Execute a list of :substitute command tests\nfunc Run_SubCmd_Tests(tests)\n  enew!\n  for t in a:tests\n    let start = line('.') + 1\n    let end = start + len(t[2]) - 1\n    exe \"normal o\" . t[0]\n    call cursor(start, 1)\n    exe t[1]\n    call assert_equal(t[2], getline(start, end), t[1])\n  endfor\n  enew!\nendfunc\n\nfunc Test_sub_cmd_1()\n  set magic\n  set cpo&\n\n  \" List entry format: [input, cmd, output]\n  let tests = [['A', 's/A/&&/', ['AA']],\n\t      \\ ['B', 's/B/\\&/', ['&']],\n\t      \\ ['C123456789', 's/C\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)/\\0\\9\\8\\7\\6\\5\\4\\3\\2\\1/', ['C123456789987654321']],\n\t      \\ ['D', 's/D/d/', ['d']],\n\t      \\ ['E', 's/E/~/', ['d']],\n\t      \\ ['F', 's/F/\\~/', ['~']],\n\t      \\ ['G', 's/G/\\ugg/', ['Gg']],\n\t      \\ ['H', 's/H/\\Uh\\Eh/', ['Hh']],\n\t      \\ ['I', 's/I/\\lII/', ['iI']],\n\t      \\ ['J', 's/J/\\LJ\\EJ/', ['jJ']],\n\t      \\ ['K', 's/K/\\Uk\\ek/', ['Kk']],\n\t      \\ ['lLl', \"s/L/\\<C-V>\\<C-M>/\", [\"l\\<C-V>\", 'l']],\n\t      \\ ['mMm', 's/M/\\r/', ['m', 'm']],\n\t      \\ ['nNn', \"s/N/\\\\\\<C-V>\\<C-M>/\", [\"n\\<C-V>\", 'n']],\n\t      \\ ['oOo', 's/O/\\n/', [\"o\\no\"]],\n\t      \\ ['pPp', 's/P/\\b/', [\"p\\<C-H>p\"]],\n\t      \\ ['qQq', 's/Q/\\t/', [\"q\\tq\"]],\n\t      \\ ['rRr', 's/R/\\\\/', ['r\\r']],\n\t      \\ ['sSs', 's/S/\\c/', ['scs']],\n\t      \\ ['tTt', \"s/T/\\<C-V>\\<C-J>/\", [\"t\\<C-V>\\<C-J>t\"]],\n\t      \\ ['U', 's/U/\\L\\uuUu\\l\\EU/', ['UuuU']],\n\t      \\ ['V', 's/V/\\U\\lVvV\\u\\Ev/', ['vVVv']],\n\t      \\ ['\\', 's/\\\\/\\\\\\\\/', ['\\\\']]\n\t      \\ ]\n  call Run_SubCmd_Tests(tests)\nendfunc\n\nfunc Test_sub_cmd_2()\n  set nomagic\n  set cpo&\n\n  \" List entry format: [input, cmd, output]\n  let tests = [['A', 's/A/&&/', ['&&']],\n\t      \\ ['B', 's/B/\\&/', ['B']],\n\t      \\ ['C123456789', 's/\\mC\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)/\\0\\9\\8\\7\\6\\5\\4\\3\\2\\1/', ['C123456789987654321']],\n\t      \\ ['D', 's/D/d/', ['d']],\n\t      \\ ['E', 's/E/~/', ['~']],\n\t      \\ ['F', 's/F/\\~/', ['~']],\n\t      \\ ['G', 's/G/\\ugg/', ['Gg']],\n\t      \\ ['H', 's/H/\\Uh\\Eh/', ['Hh']],\n\t      \\ ['I', 's/I/\\lII/', ['iI']],\n\t      \\ ['J', 's/J/\\LJ\\EJ/', ['jJ']],\n\t      \\ ['K', 's/K/\\Uk\\ek/', ['Kk']],\n\t      \\ ['lLl', \"s/L/\\<C-V>\\<C-M>/\", [\"l\\<C-V>\", 'l']],\n\t      \\ ['mMm', 's/M/\\r/', ['m', 'm']],\n\t      \\ ['nNn', \"s/N/\\\\\\<C-V>\\<C-M>/\", [\"n\\<C-V>\", 'n']],\n\t      \\ ['oOo', 's/O/\\n/', [\"o\\no\"]],\n\t      \\ ['pPp', 's/P/\\b/', [\"p\\<C-H>p\"]],\n\t      \\ ['qQq', 's/Q/\\t/', [\"q\\tq\"]],\n\t      \\ ['rRr', 's/R/\\\\/', ['r\\r']],\n\t      \\ ['sSs', 's/S/\\c/', ['scs']],\n\t      \\ ['tTt', \"s/T/\\<C-V>\\<C-J>/\", [\"t\\<C-V>\\<C-J>t\"]],\n\t      \\ ['U', 's/U/\\L\\uuUu\\l\\EU/', ['UuuU']],\n\t      \\ ['V', 's/V/\\U\\lVvV\\u\\Ev/', ['vVVv']],\n\t      \\ ['\\', 's/\\\\/\\\\\\\\/', ['\\\\']]\n\t      \\ ]\n  call Run_SubCmd_Tests(tests)\nendfunc\n\nfunc Test_sub_cmd_3()\n  set nomagic\n  set cpo&\n\n  \" List entry format: [input, cmd, output]\n  let tests = [['aAa', \"s/A/\\\\='\\\\'/\", ['a\\a']],\n\t      \\ ['bBb', \"s/B/\\\\='\\\\\\\\'/\", ['b\\\\b']],\n\t      \\ ['cCc', \"s/C/\\\\='\\<C-V>\\<C-M>'/\", [\"c\\<C-V>\", 'c']],\n\t      \\ ['dDd', \"s/D/\\\\='\\\\\\<C-V>\\<C-M>'/\", [\"d\\\\\\<C-V>\", 'd']],\n\t      \\ ['eEe', \"s/E/\\\\='\\\\\\\\\\<C-V>\\<C-M>'/\", [\"e\\\\\\\\\\<C-V>\", 'e']],\n\t      \\ ['fFf', \"s/F/\\\\='\\r'/\", ['f', 'f']],\n\t      \\ ['gGg', \"s/G/\\\\='\\<C-V>\\<C-J>'/\", [\"g\\<C-V>\", 'g']],\n\t      \\ ['hHh', \"s/H/\\\\='\\\\\\<C-V>\\<C-J>'/\", [\"h\\\\\\<C-V>\", 'h']],\n\t      \\ ['iIi', \"s/I/\\\\='\\\\\\\\\\<C-V>\\<C-J>'/\", [\"i\\\\\\\\\\<C-V>\", 'i']],\n\t      \\ ['jJj', \"s/J/\\\\='\\n'/\", ['j', 'j']],\n\t      \\ ['kKk', 's/K/\\=\"\\r\"/', ['k', 'k']],\n\t      \\ ['lLl', 's/L/\\=\"\\n\"/', ['l', 'l']]\n\t      \\ ]\n  call Run_SubCmd_Tests(tests)\nendfunc\n\n\" Test for submatch() on :substitute.\nfunc Test_sub_cmd_4()\n  set magic&\n  set cpo&\n\n  \" List entry format: [input, cmd, output]\n  let tests = [ ['aAa', \"s/A/\\\\=substitute(submatch(0), '.', '\\\\', '')/\",\n\t      \\\t\t\t\t['a\\a']],\n\t      \\ ['bBb', \"s/B/\\\\=substitute(submatch(0), '.', '\\\\', '')/\",\n\t      \\\t\t\t\t['b\\b']],\n\t      \\ ['cCc', \"s/C/\\\\=substitute(submatch(0), '.', '\\<C-V>\\<C-M>', '')/\",\n\t      \\\t\t\t\t[\"c\\<C-V>\", 'c']],\n\t      \\ ['dDd', \"s/D/\\\\=substitute(submatch(0), '.', '\\\\\\<C-V>\\<C-M>', '')/\",\n\t      \\\t\t\t\t[\"d\\<C-V>\", 'd']],\n\t      \\ ['eEe', \"s/E/\\\\=substitute(submatch(0), '.', '\\\\\\\\\\<C-V>\\<C-M>', '')/\",\n\t      \\\t\t\t\t[\"e\\\\\\<C-V>\", 'e']],\n\t      \\ ['fFf', \"s/F/\\\\=substitute(submatch(0), '.', '\\\\r', '')/\",\n\t      \\\t\t\t\t['f', 'f']],\n\t      \\ ['gGg', 's/G/\\=substitute(submatch(0), \".\", \"\\<C-V>\\<C-J>\", \"\")/',\n\t      \\\t\t\t\t[\"g\\<C-V>\", 'g']],\n\t      \\ ['hHh', 's/H/\\=substitute(submatch(0), \".\", \"\\\\\\<C-V>\\<C-J>\", \"\")/',\n\t      \\\t\t\t\t[\"h\\<C-V>\", 'h']],\n\t      \\ ['iIi', 's/I/\\=substitute(submatch(0), \".\", \"\\\\\\\\\\<C-V>\\<C-J>\", \"\")/',\n\t      \\\t\t\t\t[\"i\\\\\\<C-V>\", 'i']],\n\t      \\ ['jJj', \"s/J/\\\\=substitute(submatch(0), '.', '\\\\n', '')/\",\n\t      \\\t\t\t\t['j', 'j']],\n\t      \\ ['kKk', \"s/K/\\\\=substitute(submatch(0), '.', '\\\\r', '')/\",\n\t      \\\t\t\t\t['k', 'k']],\n\t      \\ ['lLl', \"s/L/\\\\=substitute(submatch(0), '.', '\\\\n', '')/\",\n\t      \\\t\t\t\t['l', 'l']],\n\t      \\ ]\n  call Run_SubCmd_Tests(tests)\nendfunc\n\nfunc Test_sub_cmd_5()\n  set magic&\n  set cpo&\n\n  \" List entry format: [input, cmd, output]\n  let tests = [ ['A123456789', 's/A\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)/\\=submatch(0) . submatch(9) . submatch(8) . submatch(7) . submatch(6) . submatch(5) . submatch(4) . submatch(3) . submatch(2) . submatch(1)/', ['A123456789987654321']],\n\t      \\ ['B123456789', 's/B\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)/\\=string([submatch(0, 1), submatch(9, 1), submatch(8, 1), submatch(7, 1), submatch(6, 1), submatch(5, 1), submatch(4, 1), submatch(3, 1), submatch(2, 1), submatch(1, 1)])/', [\"[['B123456789'], ['9'], ['8'], ['7'], ['6'], ['5'], ['4'], ['3'], ['2'], ['1']]\"]],\n\t      \\ ]\n  call Run_SubCmd_Tests(tests)\nendfunc\n\n\" Test for *:s%* on :substitute.\nfunc Test_sub_cmd_6()\n  set magic&\n  set cpo+=/\n\n  \" List entry format: [input, cmd, output]\n  let tests = [ ['A', 's/A/a/', ['a']],\n\t      \\ ['B', 's/B/%/', ['a']],\n\t      \\ ]\n  call Run_SubCmd_Tests(tests)\n\n  set cpo-=/\n  let tests = [ ['C', 's/C/c/', ['c']],\n\t      \\ ['D', 's/D/%/', ['%']],\n\t      \\ ]\n  call Run_SubCmd_Tests(tests)\n\n  set cpo&\nendfunc\n\n\" Test for :s replacing \\n with  line break.\nfunc Test_sub_cmd_7()\n  set magic&\n  set cpo&\n\n  \" List entry format: [input, cmd, output]\n  let tests = [ [\"A\\<C-V>\\<C-M>A\", 's/A./\\=submatch(0)/', ['A', 'A']],\n\t      \\ [\"B\\<C-V>\\<C-J>B\", 's/B./\\=submatch(0)/', ['B', 'B']],\n\t      \\ [\"C\\<C-V>\\<C-J>C\", 's/C./\\=strtrans(string(submatch(0, 1)))/', [strtrans(\"['C\\<C-J>']C\")]],\n\t      \\ [\"D\\<C-V>\\<C-J>\\nD\", 's/D.\\nD/\\=strtrans(string(submatch(0, 1)))/', [strtrans(\"['D\\<C-J>', 'D']\")]],\n\t      \\ [\"E\\<C-V>\\<C-J>\\n\\<C-V>\\<C-J>\\n\\<C-V>\\<C-J>\\n\\<C-V>\\<C-J>\\n\\<C-V>\\<C-J>E\", 's/E\\_.\\{-}E/\\=strtrans(string(submatch(0, 1)))/', [strtrans(\"['E\\<C-J>', '\\<C-J>', '\\<C-J>', '\\<C-J>', '\\<C-J>E']\")]],\n\t      \\ ]\n  call Run_SubCmd_Tests(tests)\n\n  exe \"normal oQ\\nQ\\<Esc>k\"\n  call assert_fails('s/Q[^\\n]Q/\\=submatch(0).\"foobar\"/', 'E486:')\n  enew!\nendfunc\n\nfunc TitleString()\n  let check = 'foo' =~ 'bar'\n  return \"\"\nendfunc\n\nfunc Test_sub_cmd_8()\n  set titlestring=%{TitleString()}\n\n  enew!\n  call append(0, ['', 'test_one', 'test_two'])\n  call cursor(1,1)\n  /^test_one/s/.*/\\=\"foo\\nbar\"/\n  call assert_equal('foo', getline(2))\n  call assert_equal('bar', getline(3))\n  call feedkeys(':/^test_two/s/.*/\\=\"foo\\nbar\"/c', \"t\")\n  call feedkeys(\"\\<CR>y\", \"xt\")\n  call assert_equal('foo', getline(4))\n  call assert_equal('bar', getline(5))\n\n  enew!\n  set titlestring&\nendfunc\n\nfunc Test_sub_cmd_9()\n  new\n  let input = ['1 aaa', '2 aaa', '3 aaa']\n  call setline(1, input)\n  func Foo()\n    return submatch(0)\n  endfunc\n  %s/aaa/\\=Foo()/gn\n  call assert_equal(input, getline(1, '$'))\n  call assert_equal(1, &modifiable)\n\n  delfunc Foo\n  bw!\nendfunc\n\nfunc Test_sub_highlight_zero_match()\n  CheckRunVimInTerminal\n\n  let lines =<< trim END\n    call setline(1, ['one', 'two', 'three'])\n  END\n  call writefile(lines, 'XscriptSubHighlight', 'D')\n  let buf = RunVimInTerminal('-S XscriptSubHighlight', #{rows: 8, cols: 60})\n  call term_sendkeys(buf, \":%s/^/   /c\\<CR>\")\n  call VerifyScreenDump(buf, 'Test_sub_highlight_zer_match_1', {})\n\n  call term_sendkeys(buf, \"\\<Esc>\")\n  call StopVimInTerminal(buf)\nendfunc\n\nfunc Test_nocatch_sub_failure_handling()\n  \" normal error results in all replacements\n  func Foo()\n    foobar\n  endfunc\n  new\n  call setline(1, ['1 aaa', '2 aaa', '3 aaa'])\n  \" need silent! to avoid a delay when entering Insert mode\n  silent! %s/aaa/\\=Foo()/g\n  call assert_equal(['1 0', '2 0', '3 0'], getline(1, 3))\n\n  \" Throw without try-catch causes abort after the first line.\n  \" We cannot test this, since it would stop executing the test script.\n\n  \" try/catch does not result in any changes\n  func! Foo()\n    throw 'error'\n  endfunc\n  call setline(1, ['1 aaa', '2 aaa', '3 aaa'])\n  let error_caught = 0\n  try\n    %s/aaa/\\=Foo()/g\n  catch\n    let error_caught = 1\n  endtry\n  call assert_equal(1, error_caught)\n  call assert_equal(['1 aaa', '2 aaa', '3 aaa'], getline(1, 3))\n\n  \" Same, but using \"n\" flag so that \"sandbox\" gets set\n  call setline(1, ['1 aaa', '2 aaa', '3 aaa'])\n  let error_caught = 0\n  try\n    %s/aaa/\\=Foo()/gn\n  catch\n    let error_caught = 1\n  endtry\n  call assert_equal(1, error_caught)\n  call assert_equal(['1 aaa', '2 aaa', '3 aaa'], getline(1, 3))\n\n  delfunc Foo\n  bwipe!\nendfunc\n\n\" Test \":s/pat/sub/\" with different ~s in sub.\nfunc Test_replace_with_tilde()\n  new\n  \" Set the last replace string to empty\n  s/^$//\n  call append(0, ['- Bug in \"vPPPP\" on this text:'])\n  normal gg\n  s/u/~u~/\n  call assert_equal('- Bug in \"vPPPP\" on this text:', getline(1))\n  s/i/~u~/\n  call assert_equal('- Bug uuun \"vPPPP\" on this text:', getline(1))\n  s/o/~~~/\n  call assert_equal('- Bug uuun \"vPPPP\" uuuuuuuuun this text:', getline(1))\n  close!\nendfunc\n\nfunc Test_replace_keeppatterns()\n  new\n  a\nfoobar\n\nsubstitute foo asdf\n\none two\n.\n\n  normal gg\n  /^substitute\n  s/foo/bar/\n  call assert_equal('foo', @/)\n  call assert_equal('substitute bar asdf', getline('.'))\n\n  /^substitute\n  keeppatterns s/asdf/xyz/\n  call assert_equal('^substitute', @/)\n  call assert_equal('substitute bar xyz', getline('.'))\n\n  exe \"normal /bar /e\\<CR>\"\n  call assert_equal(15, col('.'))\n  normal -\n  keeppatterns /xyz\n  call assert_equal('bar ', @/)\n  call assert_equal('substitute bar xyz', getline('.'))\n  exe \"normal 0dn\"\n  call assert_equal('xyz', getline('.'))\n\n  close!\nendfunc\n\nfunc Test_sub_beyond_end()\n  new\n  call setline(1, '#')\n  let @/ = '^#\\n\\zs'\n  s///e\n  call assert_equal('#', getline(1))\n  bwipe!\nendfunc\n\n\" Test for repeating last substitution using :~ and :&r\nfunc Test_repeat_last_sub()\n  new\n  call setline(1, ['blue green yellow orange white'])\n  s/blue/red/\n  let @/ = 'yellow'\n  ~\n  let @/ = 'white'\n  :&r\n  let @/ = 'green'\n  s//gray\n  call assert_equal('red gray red orange red', getline(1))\n  close!\nendfunc\n\n\" Test for Vi compatible substitution:\n\"     \\/{string}/, \\?{string}? and \\&{string}&\nfunc Test_sub_vi_compatibility()\n  new\n  call setline(1, ['blue green yellow orange blue'])\n  let @/ = 'orange'\n  s\\/white/\n  let @/ = 'blue'\n  s\\?amber?\n  let @/ = 'white'\n  s\\&green&\n  call assert_equal('amber green yellow white green', getline(1))\n  close!\n\n  call assert_fails('vim9cmd s\\/white/', 'E1270:')\n  call assert_fails('vim9cmd s\\?white?', 'E1270:')\n  call assert_fails('vim9cmd s\\&white&', 'E1270:')\nendfunc\n\n\" Test for substitute with the new text longer than the original text\nfunc Test_sub_expand_text()\n  new\n  call setline(1, 'abcabcabcabcabcabcabcabc')\n  s/b/\\=repeat('B', 10)/g\n  call assert_equal(repeat('aBBBBBBBBBBc', 8), getline(1))\n  close!\nendfunc\n\n\" Test for command failures when the last substitute pattern is not set.\nfunc Test_sub_with_no_last_pat()\n  let lines =<< trim [SCRIPT]\n    call assert_fails('~', 'E33:')\n    call assert_fails('s//abc/g', 'E35:')\n    call assert_fails('s\\/bar', 'E35:')\n    call assert_fails('s\\&bar&', 'E33:')\n    call writefile(v:errors, 'Xresult')\n    qall!\n  [SCRIPT]\n  call writefile(lines, 'Xscript', 'D')\n  if RunVim([], [], '--clean -S Xscript')\n    call assert_equal([], readfile('Xresult'))\n  endif\n\n  let lines =<< trim [SCRIPT]\n    set cpo+=/\n    call assert_fails('s/abc/%/', 'E33:')\n    call writefile(v:errors, 'Xresult')\n    qall!\n  [SCRIPT]\n  call writefile(lines, 'Xscript')\n  if RunVim([], [], '--clean -S Xscript')\n    call assert_equal([], readfile('Xresult'))\n  endif\n\n  call delete('Xresult')\nendfunc\n\nfunc Test_substitute()\n  call assert_equal('a\uff11a\uff12a\uff13a', substitute('\uff11\uff12\uff13', '\\zs', 'a', 'g'))\n  \" Substitute with special keys\n  call assert_equal(\"a\\<End>c\", substitute('abc', \"a.c\", \"a\\<End>c\", ''))\nendfunc\n\nfunc Test_substitute_expr()\n  let g:val = 'XXX'\n  call assert_equal('XXX', substitute('yyy', 'y*', '\\=g:val', ''))\n  call assert_equal('XXX', substitute('yyy', 'y*', {-> g:val}, ''))\n  call assert_equal(\"-\\u1b \\uf2-\", substitute(\"-%1b %f2-\", '%\\(\\x\\x\\)',\n\t\t\t   \\ '\\=nr2char(\"0x\" . submatch(1))', 'g'))\n  call assert_equal(\"-\\u1b \\uf2-\", substitute(\"-%1b %f2-\", '%\\(\\x\\x\\)',\n\t\t\t   \\ {-> nr2char(\"0x\" . submatch(1))}, 'g'))\n\n  call assert_equal('231', substitute('123', '\\(.\\)\\(.\\)\\(.\\)',\n\t\\ {-> submatch(2) . submatch(3) . submatch(1)}, ''))\n\n  func Recurse()\n    return substitute('yyy', 'y\\(.\\)y', {-> submatch(1)}, '')\n  endfunc\n  \" recursive call works\n  call assert_equal('-y-x-', substitute('xxx', 'x\\(.\\)x', {-> '-' . Recurse() . '-' . submatch(1) . '-'}, ''))\n\n  call assert_fails(\"let s=submatch([])\", 'E745:')\n  call assert_fails(\"let s=submatch(2, [])\", 'E745:')\nendfunc\n\nfunc Test_invalid_submatch()\n  \" This was causing invalid memory access in Vim-7.4.2232 and older\n  call assert_fails(\"call substitute('x', '.', {-> submatch(10)}, '')\", 'E935:')\n  call assert_fails('eval submatch(-1)', 'E935:')\n  call assert_equal('', submatch(0))\n  call assert_equal('', submatch(1))\n  call assert_equal([], submatch(0, 1))\n  call assert_equal([], submatch(1, 1))\nendfunc\n\nfunc Test_submatch_list_concatenate()\n  let pat = 'A\\(.\\)'\n  let Rep = {-> string([submatch(0, 1)] + [[submatch(1)]])}\n  call substitute('A1', pat, Rep, '')->assert_equal(\"[['A1'], ['1']]\")\nendfunc\n\nfunc Test_substitute_expr_arg()\n  call assert_equal('123456789-123456789=', substitute('123456789',\n\t\\ '\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)',\n\t\\ {m -> m[0] . '-' . m[1] . m[2] . m[3] . m[4] . m[5] . m[6] . m[7] . m[8] . m[9] . '='}, ''))\n\n  call assert_equal('123456-123456=789', substitute('123456789',\n\t\\ '\\(.\\)\\(.\\)\\(.\\)\\(a*\\)\\(n*\\)\\(.\\)\\(.\\)\\(.\\)\\(x*\\)',\n\t\\ {m -> m[0] . '-' . m[1] . m[2] . m[3] . m[4] . m[5] . m[6] . m[7] . m[8] . m[9] . '='}, ''))\n\n  call assert_equal('123456789-123456789x=', substitute('123456789',\n\t\\ '\\(.\\)\\(.\\)\\(.*\\)',\n\t\\ {m -> m[0] . '-' . m[1] . m[2] . m[3] . 'x' . m[4] . m[5] . m[6] . m[7] . m[8] . m[9] . '='}, ''))\n\n  call assert_fails(\"call substitute('xxx', '.', {m -> string(add(m, 'x'))}, '')\", 'E742:')\n  call assert_fails(\"call substitute('xxx', '.', {m -> string(insert(m, 'x'))}, '')\", 'E742:')\n  call assert_fails(\"call substitute('xxx', '.', {m -> string(extend(m, ['x']))}, '')\", 'E742:')\n  call assert_fails(\"call substitute('xxx', '.', {m -> string(remove(m, 1))}, '')\", 'E742:')\nendfunc\n\n\" Test for using a function to supply the substitute string\nfunc Test_substitute_using_func()\n  func Xfunc()\n    return '1234'\n  endfunc\n  call assert_equal('a1234f', substitute('abcdef', 'b..e',\n        \\ function(\"Xfunc\"), ''))\n  delfunc Xfunc\nendfunc\n\n\" Test for using submatch() with a multiline match\nfunc Test_substitute_multiline_submatch()\n  new\n  call setline(1, ['line1', 'line2', 'line3', 'line4'])\n  %s/^line1\\(\\_.\\+\\)line4$/\\=submatch(1)/\n  call assert_equal(['', 'line2', 'line3', ''], getline(1, '$'))\n  close!\nendfunc\n\nfunc Test_substitute_skipped_range()\n  new\n  if 0\n    /1/5/2/2/\\n\n  endif\n  call assert_equal([0, 1, 1, 0, 1], getcurpos())\n  bwipe!\nendfunc\n\n\" Test using the 'gdefault' option (when on, flag 'g' is default on).\nfunc Test_substitute_gdefault()\n  new\n\n  \" First check without 'gdefault'\n  call setline(1, 'foo bar foo')\n  s/foo/FOO/\n  call assert_equal('FOO bar foo', getline(1))\n  call setline(1, 'foo bar foo')\n  s/foo/FOO/g\n  call assert_equal('FOO bar FOO', getline(1))\n  call setline(1, 'foo bar foo')\n  s/foo/FOO/gg\n  call assert_equal('FOO bar foo', getline(1))\n\n  \" Then check with 'gdefault'\n  set gdefault\n  call setline(1, 'foo bar foo')\n  s/foo/FOO/\n  call assert_equal('FOO bar FOO', getline(1))\n  call setline(1, 'foo bar foo')\n  s/foo/FOO/g\n  call assert_equal('FOO bar foo', getline(1))\n  call setline(1, 'foo bar foo')\n  s/foo/FOO/gg\n  call assert_equal('FOO bar FOO', getline(1))\n\n  \" Setting 'compatible' should reset 'gdefault'\n  call assert_equal(1, &gdefault)\n  set compatible\n  call assert_equal(0, &gdefault)\n  set nocompatible\n  call assert_equal(0, &gdefault)\n\n  bw!\nendfunc\n\n\" This was using \"old_sub\" after it was freed.\nfunc Test_using_old_sub()\n  set compatible maxfuncdepth=10\n  new\n  call setline(1, 'some text.')\n  func Repl()\n    ~\n    s/\n  endfunc\n  silent! s/\\%')/\\=Repl()\n\n  delfunc Repl\n  bwipe!\n  set nocompatible\nendfunc\n\n\" This was switching windows in between computing the length and using it.\nfunc Test_sub_change_window()\n  silent! lfile\n  sil! norm o0000000000000000000000000000000000000000000000000000\n  func Repl()\n    lopen\n  endfunc\n  silent!  s/\\%')/\\=Repl()\n  bwipe!\n  bwipe!\n  delfunc Repl\nendfunc\n\n\" This was undoign a change in between computing the length and using it.\nfunc Do_Test_sub_undo_change()\n  new\n  norm o0000000000000000000000000000000000000000000000000000\n  silent! s/\\%')/\\=Repl()\n  bwipe!\nendfunc\n\nfunc Test_sub_undo_change()\n  func Repl()\n    silent! norm g-\n  endfunc\n  call Do_Test_sub_undo_change()\n\n  func! Repl()\n    silent earlier\n  endfunc\n  call Do_Test_sub_undo_change()\n\n  delfunc Repl\nendfunc\n\n\" This was opening a command line window from the expression\nfunc Test_sub_open_cmdline_win()\n  \" the error only happens in a very specific setup, run a new Vim instance to\n  \" get a clean starting point.\n  let lines =<< trim [SCRIPT]\n    set vb t_vb=\n    norm o0000000000000000000000000000000000000000000000000000\n    func Replace()\n      norm q/\n    endfunc\n    s/\\%')/\\=Replace()\n    redir >Xresult\n    messages\n    redir END\n    qall!\n  [SCRIPT]\n  call writefile(lines, 'Xscript', 'D')\n  if RunVim([], [], '-u NONE -S Xscript')\n    call assert_match('E565: Not allowed to change text or change window',\n          \\ readfile('Xresult')->join('XX'))\n  endif\n\n  call delete('Xresult')\nendfunc\n\n\" This was editing a script file from the expression\nfunc Test_sub_edit_scriptfile()\n  new\n  norm o0000000000000000000000000000000000000000000000000000\n  func EditScript()\n    silent! scr! Xsedfile\n  endfunc\n  s/\\%')/\\=EditScript()\n\n  delfunc EditScript\n  bwipe!\nendfunc\n\n\" This was editing another file from the expression.\nfunc Test_sub_expr_goto_other_file()\n  call writefile([''], 'Xfileone', 'D')\n  enew!\n  call setline(1, ['a', 'b', 'c', 'd',\n\t\\ 'Xfileone zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz'])\n\n  func g:SplitGotoFile()\n    exe \"sil! norm 0\\<C-W>gf\"\n    return ''\n  endfunc\n\n  $\n  s/\\%')/\\=g:SplitGotoFile()\n\n  delfunc g:SplitGotoFile\n  bwipe!\nendfunc\n\nfunc Test_recursive_expr_substitute()\n  \" this was reading invalid memory\n  let lines =<< trim END\n      func Repl(g, n)\n        s\n        r%:s000\n      endfunc\n      next 0\n      let caught = 0\n      s/\\%')/\\=Repl(0, 0)\n      qall!\n  END\n  call writefile(lines, 'XexprSubst', 'D')\n  call RunVim([], [], '--clean -S XexprSubst')\nendfunc\n\n\" Test for the 2-letter and 3-letter :substitute commands\nfunc Test_substitute_short_cmd()\n  new\n  call setline(1, ['one', 'one one one'])\n  s/one/two\n  call cursor(2, 1)\n\n  \" :sc\n  call feedkeys(\":sc\\<CR>y\", 'xt')\n  call assert_equal('two one one', getline(2))\n\n  \" :scg\n  call setline(2, 'one one one')\n  call feedkeys(\":scg\\<CR>nyq\", 'xt')\n  call assert_equal('one two one', getline(2))\n\n  \" :sci\n  call setline(2, 'ONE One onE')\n  call feedkeys(\":sci\\<CR>y\", 'xt')\n  call assert_equal('two One onE', getline(2))\n\n  \" :scI\n  set ignorecase\n  call setline(2, 'ONE One one')\n  call feedkeys(\":scI\\<CR>y\", 'xt')\n  call assert_equal('ONE One two', getline(2))\n  set ignorecase&\n\n  \" :scn\n  call setline(2, 'one one one')\n  let t = execute('scn')->split(\"\\n\")\n  call assert_equal(['1 match on 1 line'], t)\n  call assert_equal('one one one', getline(2))\n\n  \" :scp\n  call setline(2, \"\\tone one one\")\n  redir => output\n  call feedkeys(\":scp\\<CR>y\", 'xt')\n  redir END\n  call assert_equal('        two one one', output->split(\"\\n\")[-1])\n  call assert_equal(\"\\ttwo one one\", getline(2))\n\n  \" :scl\n  call setline(2, \"\\tone one one\")\n  redir => output\n  call feedkeys(\":scl\\<CR>y\", 'xt')\n  redir END\n  call assert_equal(\"^Itwo one one$\", output->split(\"\\n\")[-1])\n  call assert_equal(\"\\ttwo one one\", getline(2))\n\n  \" :sgc\n  call setline(2, 'one one one one one')\n  call feedkeys(\":sgc\\<CR>nyyq\", 'xt')\n  call assert_equal('one two two one one', getline(2))\n\n  \" :sg\n  call setline(2, 'one one one')\n  sg\n  call assert_equal('two two two', getline(2))\n\n  \" :sgi\n  call setline(2, 'ONE One onE')\n  sgi\n  call assert_equal('two two two', getline(2))\n\n  \" :sgI\n  set ignorecase\n  call setline(2, 'ONE One one')\n  sgI\n  call assert_equal('ONE One two', getline(2))\n  set ignorecase&\n\n  \" :sgn\n  call setline(2, 'one one one')\n  let t = execute('sgn')->split(\"\\n\")\n  call assert_equal(['3 matches on 1 line'], t)\n  call assert_equal('one one one', getline(2))\n\n  \" :sgp\n  call setline(2, \"\\tone one one\")\n  redir => output\n  sgp\n  redir END\n  call assert_equal('        two two two', output->split(\"\\n\")[-1])\n  call assert_equal(\"\\ttwo two two\", getline(2))\n\n  \" :sgl\n  call setline(2, \"\\tone one one\")\n  redir => output\n  sgl\n  redir END\n  call assert_equal(\"^Itwo two two$\", output->split(\"\\n\")[-1])\n  call assert_equal(\"\\ttwo two two\", getline(2))\n\n  \" :sgr\n  call setline(2, \"one one one\")\n  call cursor(2, 1)\n  s/abc/xyz/e\n  let @/ = 'one'\n  sgr\n  call assert_equal('xyz xyz xyz', getline(2))\n\n  \" :sic\n  call cursor(1, 1)\n  s/one/two/e\n  call setline(2, \"ONE One one\")\n  call cursor(2, 1)\n  call feedkeys(\":sic\\<CR>y\", 'xt')\n  call assert_equal('two One one', getline(2))\n\n  \" :si\n  call setline(2, \"ONE One one\")\n  si\n  call assert_equal('two One one', getline(2))\n\n  \" :siI\n  call setline(2, \"ONE One one\")\n  siI\n  call assert_equal('ONE One two', getline(2))\n\n  \" :sin\n  call setline(2, 'ONE One onE')\n  let t = execute('sin')->split(\"\\n\")\n  call assert_equal(['1 match on 1 line'], t)\n  call assert_equal('ONE One onE', getline(2))\n\n  \" :sip\n  call setline(2, \"\\tONE One onE\")\n  redir => output\n  sip\n  redir END\n  call assert_equal('        two One onE', output->split(\"\\n\")[-1])\n  call assert_equal(\"\\ttwo One onE\", getline(2))\n\n  \" :sir\n  call setline(2, \"ONE One onE\")\n  call cursor(2, 1)\n  s/abc/xyz/e\n  let @/ = 'one'\n  sir\n  call assert_equal('xyz One onE', getline(2))\n\n  \" :sIc\n  call cursor(1, 1)\n  s/one/two/e\n  call setline(2, \"ONE One one\")\n  call cursor(2, 1)\n  call feedkeys(\":sIc\\<CR>y\", 'xt')\n  call assert_equal('ONE One two', getline(2))\n\n  \" :sIg\n  call setline(2, \"ONE one onE one\")\n  sIg\n  call assert_equal('ONE two onE two', getline(2))\n\n  \" :sIi\n  call setline(2, \"ONE One one\")\n  sIi\n  call assert_equal('two One one', getline(2))\n\n  \" :sI\n  call setline(2, \"ONE One one\")\n  sI\n  call assert_equal('ONE One two', getline(2))\n\n  \" :sIn\n  call setline(2, 'ONE One one')\n  let t = execute('sIn')->split(\"\\n\")\n  call assert_equal(['1 match on 1 line'], t)\n  call assert_equal('ONE One one', getline(2))\n\n  \" :sIp\n  call setline(2, \"\\tONE One one\")\n  redir => output\n  sIp\n  redir END\n  call assert_equal('        ONE One two', output->split(\"\\n\")[-1])\n  call assert_equal(\"\\tONE One two\", getline(2))\n\n  \" :sIl\n  call setline(2, \"\\tONE onE one\")\n  redir => output\n  sIl\n  redir END\n  call assert_equal(\"^IONE onE two$\", output->split(\"\\n\")[-1])\n  call assert_equal(\"\\tONE onE two\", getline(2))\n\n  \" :sIr\n  call setline(2, \"ONE one onE\")\n  call cursor(2, 1)\n  s/abc/xyz/e\n  let @/ = 'one'\n  sIr\n  call assert_equal('ONE xyz onE', getline(2))\n\n  \" :src\n  call setline(2, \"ONE one one\")\n  call cursor(2, 1)\n  s/abc/xyz/e\n  let @/ = 'one'\n  call feedkeys(\":src\\<CR>y\", 'xt')\n  call assert_equal('ONE xyz one', getline(2))\n\n  \" :srg\n  call setline(2, \"one one one\")\n  call cursor(2, 1)\n  s/abc/xyz/e\n  let @/ = 'one'\n  srg\n  call assert_equal('xyz xyz xyz', getline(2))\n\n  \" :sri\n  call setline(2, \"ONE one onE\")\n  call cursor(2, 1)\n  s/abc/xyz/e\n  let @/ = 'one'\n  sri\n  call assert_equal('xyz one onE', getline(2))\n\n  \" :srI\n  call setline(2, \"ONE one onE\")\n  call cursor(2, 1)\n  s/abc/xyz/e\n  let @/ = 'one'\n  srI\n  call assert_equal('ONE xyz onE', getline(2))\n\n  \" :srn\n  call setline(2, \"ONE one onE\")\n  call cursor(2, 1)\n  s/abc/xyz/e\n  let @/ = 'one'\n  let t = execute('srn')->split(\"\\n\")\n  call assert_equal(['1 match on 1 line'], t)\n  call assert_equal('ONE one onE', getline(2))\n\n  \" :srp\n  call setline(2, \"\\tONE one onE\")\n  call cursor(2, 1)\n  s/abc/xyz/e\n  let @/ = 'one'\n  redir => output\n  srp\n  redir END\n  call assert_equal('        ONE xyz onE', output->split(\"\\n\")[-1])\n  call assert_equal(\"\\tONE xyz onE\", getline(2))\n\n  \" :srl\n  call setline(2, \"\\tONE one onE\")\n  call cursor(2, 1)\n  s/abc/xyz/e\n  let @/ = 'one'\n  redir => output\n  srl\n  redir END\n  call assert_equal(\"^IONE xyz onE$\", output->split(\"\\n\")[-1])\n  call assert_equal(\"\\tONE xyz onE\", getline(2))\n\n  \" :sr\n  call setline(2, \"ONE one onE\")\n  call cursor(2, 1)\n  s/abc/xyz/e\n  let @/ = 'one'\n  sr\n  call assert_equal('ONE xyz onE', getline(2))\n\n  \" :sce\n  s/abc/xyz/e\n  call assert_fails(\"sc\", 'E486:')\n  sce\n  \" :sge\n  call assert_fails(\"sg\", 'E486:')\n  sge\n  \" :sie\n  call assert_fails(\"si\", 'E486:')\n  sie\n  \" :sIe\n  call assert_fails(\"sI\", 'E486:')\n  sIe\n\n  bw!\nendfunc\n\n\" This should be done last to reveal a memory leak when vim_regsub_both() is\n\" called to evaluate an expression but it is not used in a second call.\nfunc Test_z_substitute_expr_leak()\n  func SubExpr()\n    ~n\n  endfunc\n  silent! s/\\%')/\\=SubExpr()\n  delfunc SubExpr\nendfunc\n\n\" vim: shiftwidth=2 sts=2 expandtab\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\t\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n#include \"vim.h\"\n\n/*\n * Vim originated from Stevie version 3.6 (Fish disk 217) by GRWalter (Fred)\n * It has been changed beyond recognition since then.\n *\n * Differences between version 8.2 and 9.0 can be found with \":help version9\".\n * Differences between version 7.4 and 8.x can be found with \":help version8\".\n * Differences between version 6.4 and 7.x can be found with \":help version7\".\n * Differences between version 5.8 and 6.x can be found with \":help version6\".\n * Differences between version 4.x and 5.x can be found with \":help version5\".\n * Differences between version 3.0 and 4.x can be found with \":help version4\".\n * All the remarks about older versions have been removed, they are not very\n * interesting.\n */\n\n#include \"version.h\"\n\nchar\t\t*Version = VIM_VERSION_SHORT;\nstatic char\t*mediumVersion = VIM_VERSION_MEDIUM;\n\n#if defined(HAVE_DATE_TIME) || defined(PROTO)\n# if (defined(VMS) && defined(VAXC)) || defined(PROTO)\nchar\tlongVersion[sizeof(VIM_VERSION_LONG_DATE) + sizeof(__DATE__)\n\t\t\t\t\t\t      + sizeof(__TIME__) + 3];\n\n    void\ninit_longVersion(void)\n{\n    /*\n     * Construct the long version string.  Necessary because\n     * VAX C can't concatenate strings in the preprocessor.\n     */\n    strcpy(longVersion, VIM_VERSION_LONG_DATE);\n#ifdef BUILD_DATE\n    strcat(longVersion, BUILD_DATE);\n#else\n    strcat(longVersion, __DATE__);\n    strcat(longVersion, \" \");\n    strcat(longVersion, __TIME__);\n#endif\n    strcat(longVersion, \")\");\n}\n\n# else\nchar\t*longVersion = NULL;\n\n    void\ninit_longVersion(void)\n{\n    if (longVersion != NULL)\n\treturn;\n\n#ifdef BUILD_DATE\n    char *date_time = BUILD_DATE;\n#else\n    char *date_time = __DATE__ \" \" __TIME__;\n#endif\n    char *msg = _(\"%s (%s, compiled %s)\");\n    size_t len = strlen(msg)\n\t+ strlen(VIM_VERSION_LONG_ONLY)\n\t+ strlen(VIM_VERSION_DATE_ONLY)\n\t+ strlen(date_time);\n\n    longVersion = alloc(len);\n    if (longVersion == NULL)\n\tlongVersion = VIM_VERSION_LONG;\n    else\n\tvim_snprintf(longVersion, len, msg,\n\t\tVIM_VERSION_LONG_ONLY, VIM_VERSION_DATE_ONLY, date_time);\n}\n# endif\n#else\nchar\t*longVersion = VIM_VERSION_LONG;\n\n    void\ninit_longVersion(void)\n{\n    // nothing to do\n}\n#endif\n\nstatic char *(features[]) =\n{\n#ifdef HAVE_ACL\n\t\"+acl\",\n#else\n\t\"-acl\",\n#endif\n#ifdef AMIGA\t\t// only for Amiga systems\n# ifdef FEAT_ARP\n\t\"+ARP\",\n# else\n\t\"-ARP\",\n# endif\n#endif\n#ifdef FEAT_ARABIC\n\t\"+arabic\",\n#else\n\t\"-arabic\",\n#endif\n\t\"+autocmd\",\n#ifdef FEAT_AUTOCHDIR\n       \"+autochdir\",\n#else\n       \"-autochdir\",\n#endif\n#ifdef FEAT_AUTOSERVERNAME\n\t\"+autoservername\",\n#else\n\t\"-autoservername\",\n#endif\n#ifdef FEAT_BEVAL_GUI\n\t\"+balloon_eval\",\n#else\n\t\"-balloon_eval\",\n#endif\n#ifdef FEAT_BEVAL_TERM\n\t\"+balloon_eval_term\",\n#else\n\t\"-balloon_eval_term\",\n#endif\n#ifdef FEAT_BROWSE\n\t\"+browse\",\n#else\n\t\"-browse\",\n#endif\n\t\"++builtin_terms\",\n#ifdef FEAT_BYTEOFF\n\t\"+byte_offset\",\n#else\n\t\"-byte_offset\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+channel\",\n#else\n\t\"-channel\",\n#endif\n\t\"+cindent\",\n#ifdef FEAT_CLIENTSERVER\n\t\"+clientserver\",\n#else\n\t\"-clientserver\",\n#endif\n#ifdef FEAT_CLIPBOARD\n\t\"+clipboard\",\n#else\n\t\"-clipboard\",\n#endif\n\t\"+cmdline_compl\",\n\t\"+cmdline_hist\",\n\t\"+cmdline_info\",\n\t\"+comments\",\n#ifdef FEAT_CONCEAL\n\t\"+conceal\",\n#else\n\t\"-conceal\",\n#endif\n#ifdef FEAT_CRYPT\n\t\"+cryptv\",\n#else\n\t\"-cryptv\",\n#endif\n#ifdef FEAT_CSCOPE\n\t\"+cscope\",\n#else\n\t\"-cscope\",\n#endif\n\t\"+cursorbind\",\n#ifdef CURSOR_SHAPE\n\t\"+cursorshape\",\n#else\n\t\"-cursorshape\",\n#endif\n#if defined(FEAT_CON_DIALOG) && defined(FEAT_GUI_DIALOG)\n\t\"+dialog_con_gui\",\n#else\n# if defined(FEAT_CON_DIALOG)\n\t\"+dialog_con\",\n# else\n#  if defined(FEAT_GUI_DIALOG)\n\t\"+dialog_gui\",\n#  else\n\t\"-dialog\",\n#  endif\n# endif\n#endif\n#ifdef FEAT_DIFF\n\t\"+diff\",\n#else\n\t\"-diff\",\n#endif\n#ifdef FEAT_DIGRAPHS\n\t\"+digraphs\",\n#else\n\t\"-digraphs\",\n#endif\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_DIRECTX\n\t\"+directx\",\n# else\n\t\"-directx\",\n# endif\n#endif\n#ifdef FEAT_DND\n\t\"+dnd\",\n#else\n\t\"-dnd\",\n#endif\n\t\"-ebcdic\",\n#ifdef FEAT_EMACS_TAGS\n\t\"+emacs_tags\",\n#else\n\t\"-emacs_tags\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+eval\",\n#else\n\t\"-eval\",\n#endif\n\t\"+ex_extra\",\n#ifdef FEAT_SEARCH_EXTRA\n\t\"+extra_search\",\n#else\n\t\"-extra_search\",\n#endif\n\t\"-farsi\",\n\t\"+file_in_path\",\n#ifdef FEAT_FIND_ID\n\t\"+find_in_path\",\n#else\n\t\"-find_in_path\",\n#endif\n\t\"+float\",\n#ifdef FEAT_FOLDING\n\t\"+folding\",\n#else\n\t\"-folding\",\n#endif\n\t\"-footer\",\n\t// only interesting on Unix systems\n#if !defined(USE_SYSTEM) && defined(UNIX)\n\t\"+fork()\",\n#endif\n#ifdef FEAT_GETTEXT\n# ifdef DYNAMIC_GETTEXT\n\t\"+gettext/dyn\",\n# else\n\t\"+gettext\",\n# endif\n#else\n\t\"-gettext\",\n#endif\n\t\"-hangul_input\",\n#if (defined(HAVE_ICONV_H) && defined(USE_ICONV)) || defined(DYNAMIC_ICONV)\n# ifdef DYNAMIC_ICONV\n\t\"+iconv/dyn\",\n# else\n\t\"+iconv\",\n# endif\n#else\n\t\"-iconv\",\n#endif\n\t\"+insert_expand\",\n#ifdef FEAT_IPV6\n\t\"+ipv6\",\n#else\n\t\"-ipv6\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+job\",\n#else\n\t\"-job\",\n#endif\n\t\"+jumplist\",\n#ifdef FEAT_KEYMAP\n\t\"+keymap\",\n#else\n\t\"-keymap\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+lambda\",\n#else\n\t\"-lambda\",\n#endif\n#ifdef FEAT_LANGMAP\n\t\"+langmap\",\n#else\n\t\"-langmap\",\n#endif\n#ifdef FEAT_LIBCALL\n\t\"+libcall\",\n#else\n\t\"-libcall\",\n#endif\n#ifdef FEAT_LINEBREAK\n\t\"+linebreak\",\n#else\n\t\"-linebreak\",\n#endif\n\t\"+lispindent\",\n\t\"+listcmds\",\n\t\"+localmap\",\n#ifdef FEAT_LUA\n# ifdef DYNAMIC_LUA\n\t\"+lua/dyn\",\n# else\n\t\"+lua\",\n# endif\n#else\n\t\"-lua\",\n#endif\n#ifdef FEAT_MENU\n\t\"+menu\",\n#else\n\t\"-menu\",\n#endif\n#ifdef FEAT_SESSION\n\t\"+mksession\",\n#else\n\t\"-mksession\",\n#endif\n\t\"+modify_fname\",\n\t\"+mouse\",\n#ifdef FEAT_MOUSESHAPE\n\t\"+mouseshape\",\n#else\n\t\"-mouseshape\",\n#endif\n\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_MOUSE_DEC\n\t\"+mouse_dec\",\n# else\n\t\"-mouse_dec\",\n# endif\n# ifdef FEAT_MOUSE_GPM\n#  ifdef DYNAMIC_GPM\n\t\"+mouse_gpm/dyn\",\n#  else\n\t\"+mouse_gpm\",\n#  endif\n# else\n\t\"-mouse_gpm\",\n# endif\n# ifdef FEAT_MOUSE_JSB\n\t\"+mouse_jsbterm\",\n# else\n\t\"-mouse_jsbterm\",\n# endif\n# ifdef FEAT_MOUSE_NET\n\t\"+mouse_netterm\",\n# else\n\t\"-mouse_netterm\",\n# endif\n#endif\n\n#ifdef __QNX__\n# ifdef FEAT_MOUSE_PTERM\n\t\"+mouse_pterm\",\n# else\n\t\"-mouse_pterm\",\n# endif\n#endif\n\n#if defined(UNIX) || defined(VMS)\n\t\"+mouse_sgr\",\n# ifdef FEAT_SYSMOUSE\n\t\"+mouse_sysmouse\",\n# else\n\t\"-mouse_sysmouse\",\n# endif\n# ifdef FEAT_MOUSE_URXVT\n\t\"+mouse_urxvt\",\n# else\n\t\"-mouse_urxvt\",\n# endif\n\t\"+mouse_xterm\",\n#endif\n\n#ifdef FEAT_MBYTE_IME\n# ifdef DYNAMIC_IME\n\t\"+multi_byte_ime/dyn\",\n# else\n\t\"+multi_byte_ime\",\n# endif\n#else\n\t\"+multi_byte\",\n#endif\n#ifdef FEAT_MULTI_LANG\n\t\"+multi_lang\",\n#else\n\t\"-multi_lang\",\n#endif\n#ifdef FEAT_MZSCHEME\n# ifdef DYNAMIC_MZSCHEME\n\t\"+mzscheme/dyn\",\n# else\n\t\"+mzscheme\",\n# endif\n#else\n\t\"-mzscheme\",\n#endif\n#ifdef FEAT_NETBEANS_INTG\n\t\"+netbeans_intg\",\n#else\n\t\"-netbeans_intg\",\n#endif\n\t\"+num64\",\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_OLE\n\t\"+ole\",\n# else\n\t\"-ole\",\n# endif\n#endif\n#ifdef FEAT_EVAL\n\t\"+packages\",\n#else\n\t\"-packages\",\n#endif\n\t\"+path_extra\",\n#ifdef FEAT_PERL\n# ifdef DYNAMIC_PERL\n\t\"+perl/dyn\",\n# else\n\t\"+perl\",\n# endif\n#else\n\t\"-perl\",\n#endif\n#ifdef FEAT_PERSISTENT_UNDO\n\t\"+persistent_undo\",\n#else\n\t\"-persistent_undo\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+popupwin\",\n#else\n\t\"-popupwin\",\n#endif\n#ifdef FEAT_PRINTER\n# ifdef FEAT_POSTSCRIPT\n\t\"+postscript\",\n# else\n\t\"-postscript\",\n# endif\n\t\"+printer\",\n#else\n\t\"-printer\",\n#endif\n#ifdef FEAT_PROFILE\n\t\"+profile\",\n#else\n\t\"-profile\",\n#endif\n#ifdef FEAT_PYTHON\n# ifdef DYNAMIC_PYTHON\n\t\"+python/dyn\",\n# else\n\t\"+python\",\n# endif\n#else\n\t\"-python\",\n#endif\n#ifdef FEAT_PYTHON3\n# ifdef DYNAMIC_PYTHON3\n\t\"+python3/dyn\",\n# else\n\t\"+python3\",\n# endif\n#else\n\t\"-python3\",\n#endif\n#ifdef FEAT_QUICKFIX\n\t\"+quickfix\",\n#else\n\t\"-quickfix\",\n#endif\n#ifdef FEAT_RELTIME\n\t\"+reltime\",\n#else\n\t\"-reltime\",\n#endif\n#ifdef FEAT_RIGHTLEFT\n\t\"+rightleft\",\n#else\n\t\"-rightleft\",\n#endif\n#ifdef FEAT_RUBY\n# ifdef DYNAMIC_RUBY\n\t\"+ruby/dyn\",\n# else\n\t\"+ruby\",\n# endif\n#else\n\t\"-ruby\",\n#endif\n\t\"+scrollbind\",\n#ifdef FEAT_SIGNS\n\t\"+signs\",\n#else\n\t\"-signs\",\n#endif\n\t\"+smartindent\",\n#ifdef FEAT_SODIUM\n# ifdef DYNAMIC_SODIUM\n\t\"+sodium/dyn\",\n# else\n\t\"+sodium\",\n# endif\n#else\n\t\"-sodium\",\n#endif\n#ifdef FEAT_SOUND\n\t\"+sound\",\n#else\n\t\"-sound\",\n#endif\n#ifdef FEAT_SPELL\n\t\"+spell\",\n#else\n\t\"-spell\",\n#endif\n#ifdef STARTUPTIME\n\t\"+startuptime\",\n#else\n\t\"-startuptime\",\n#endif\n#ifdef FEAT_STL_OPT\n\t\"+statusline\",\n#else\n\t\"-statusline\",\n#endif\n\t\"-sun_workshop\",\n#ifdef FEAT_SYN_HL\n\t\"+syntax\",\n#else\n\t\"-syntax\",\n#endif\n\t    // only interesting on Unix systems\n#if defined(USE_SYSTEM) && defined(UNIX)\n\t\"+system()\",\n#endif\n\t\"+tag_binary\",\n\t\"-tag_old_static\",\n\t\"-tag_any_white\",\n#ifdef FEAT_TCL\n# ifdef DYNAMIC_TCL\n\t\"+tcl/dyn\",\n# else\n\t\"+tcl\",\n# endif\n#else\n\t\"-tcl\",\n#endif\n#ifdef FEAT_TERMGUICOLORS\n\t\"+termguicolors\",\n#else\n\t\"-termguicolors\",\n#endif\n#ifdef FEAT_TERMINAL\n\t\"+terminal\",\n#else\n\t\"-terminal\",\n#endif\n#if defined(UNIX)\n// only Unix can have terminfo instead of termcap\n# ifdef TERMINFO\n\t\"+terminfo\",\n# else\n\t\"-terminfo\",\n# endif\n#endif\n#ifdef FEAT_TERMRESPONSE\n\t\"+termresponse\",\n#else\n\t\"-termresponse\",\n#endif\n\t\"+textobjects\",\n#ifdef FEAT_PROP_POPUP\n\t\"+textprop\",\n#else\n\t\"-textprop\",\n#endif\n#if !defined(UNIX)\n// unix always includes termcap support\n# ifdef HAVE_TGETENT\n\t\"+tgetent\",\n# else\n\t\"-tgetent\",\n# endif\n#endif\n#ifdef FEAT_TIMERS\n\t\"+timers\",\n#else\n\t\"-timers\",\n#endif\n\t\"+title\",\n#ifdef FEAT_TOOLBAR\n\t\"+toolbar\",\n#else\n\t\"-toolbar\",\n#endif\n\t\"+user_commands\",\n#ifdef FEAT_VARTABS\n\t\"+vartabs\",\n#else\n\t\"-vartabs\",\n#endif\n\t\"+vertsplit\",\n\t\"+vim9script\",\n#ifdef FEAT_VIMINFO\n\t\"+viminfo\",\n#else\n\t\"-viminfo\",\n#endif\n\t\"+virtualedit\",\n\t\"+visual\",\n\t\"+visualextra\",\n\t\"+vreplace\",\n#ifdef MSWIN\n# ifdef FEAT_VTP\n\t\"+vtp\",\n# else\n\t\"-vtp\",\n# endif\n#endif\n\t\"+wildignore\",\n\t\"+wildmenu\",\n\t\"+windows\",\n#ifdef FEAT_WRITEBACKUP\n\t\"+writebackup\",\n#else\n\t\"-writebackup\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_X11\n\t\"+X11\",\n# else\n\t\"-X11\",\n# endif\n#endif\n#ifdef FEAT_XFONTSET\n\t\"+xfontset\",\n#else\n\t\"-xfontset\",\n#endif\n#ifdef FEAT_XIM\n\t\"+xim\",\n#else\n\t\"-xim\",\n#endif\n#if defined(MSWIN)\n# ifdef FEAT_XPM_W32\n\t\"+xpm_w32\",\n# else\n\t\"-xpm_w32\",\n# endif\n#elif defined(HAVE_XPM)\n\t\"+xpm\",\n#else\n\t\"-xpm\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# if defined(USE_XSMP_INTERACT)\n\t\"+xsmp_interact\",\n# elif defined(USE_XSMP)\n\t\"+xsmp\",\n# else\n\t\"-xsmp\",\n# endif\n# ifdef FEAT_XCLIPBOARD\n\t\"+xterm_clipboard\",\n# else\n\t\"-xterm_clipboard\",\n# endif\n#endif\n#ifdef FEAT_XTERM_SAVE\n\t\"+xterm_save\",\n#else\n\t\"-xterm_save\",\n#endif\n\tNULL\n};\n\nstatic int included_patches[] =\n{   /* Add new patch number below this line */\n/**/\n    1531,\n/**/\n    1530,\n/**/\n    1529,\n/**/\n    1528,\n/**/\n    1527,\n/**/\n    1526,\n/**/\n    1525,\n/**/\n    1524,\n/**/\n    1523,\n/**/\n    1522,\n/**/\n    1521,\n/**/\n    1520,\n/**/\n    1519,\n/**/\n    1518,\n/**/\n    1517,\n/**/\n    1516,\n/**/\n    1515,\n/**/\n    1514,\n/**/\n    1513,\n/**/\n    1512,\n/**/\n    1511,\n/**/\n    1510,\n/**/\n    1509,\n/**/\n    1508,\n/**/\n    1507,\n/**/\n    1506,\n/**/\n    1505,\n/**/\n    1504,\n/**/\n    1503,\n/**/\n    1502,\n/**/\n    1501,\n/**/\n    1500,\n/**/\n    1499,\n/**/\n    1498,\n/**/\n    1497,\n/**/\n    1496,\n/**/\n    1495,\n/**/\n    1494,\n/**/\n    1493,\n/**/\n    1492,\n/**/\n    1491,\n/**/\n    1490,\n/**/\n    1489,\n/**/\n    1488,\n/**/\n    1487,\n/**/\n    1486,\n/**/\n    1485,\n/**/\n    1484,\n/**/\n    1483,\n/**/\n    1482,\n/**/\n    1481,\n/**/\n    1480,\n/**/\n    1479,\n/**/\n    1478,\n/**/\n    1477,\n/**/\n    1476,\n/**/\n    1475,\n/**/\n    1474,\n/**/\n    1473,\n/**/\n    1472,\n/**/\n    1471,\n/**/\n    1470,\n/**/\n    1469,\n/**/\n    1468,\n/**/\n    1467,\n/**/\n    1466,\n/**/\n    1465,\n/**/\n    1464,\n/**/\n    1463,\n/**/\n    1462,\n/**/\n    1461,\n/**/\n    1460,\n/**/\n    1459,\n/**/\n    1458,\n/**/\n    1457,\n/**/\n    1456,\n/**/\n    1455,\n/**/\n    1454,\n/**/\n    1453,\n/**/\n    1452,\n/**/\n    1451,\n/**/\n    1450,\n/**/\n    1449,\n/**/\n    1448,\n/**/\n    1447,\n/**/\n    1446,\n/**/\n    1445,\n/**/\n    1444,\n/**/\n    1443,\n/**/\n    1442,\n/**/\n    1441,\n/**/\n    1440,\n/**/\n    1439,\n/**/\n    1438,\n/**/\n    1437,\n/**/\n    1436,\n/**/\n    1435,\n/**/\n    1434,\n/**/\n    1433,\n/**/\n    1432,\n/**/\n    1431,\n/**/\n    1430,\n/**/\n    1429,\n/**/\n    1428,\n/**/\n    1427,\n/**/\n    1426,\n/**/\n    1425,\n/**/\n    1424,\n/**/\n    1423,\n/**/\n    1422,\n/**/\n    1421,\n/**/\n    1420,\n/**/\n    1419,\n/**/\n    1418,\n/**/\n    1417,\n/**/\n    1416,\n/**/\n    1415,\n/**/\n    1414,\n/**/\n    1413,\n/**/\n    1412,\n/**/\n    1411,\n/**/\n    1410,\n/**/\n    1409,\n/**/\n    1408,\n/**/\n    1407,\n/**/\n    1406,\n/**/\n    1405,\n/**/\n    1404,\n/**/\n    1403,\n/**/\n    1402,\n/**/\n    1401,\n/**/\n    1400,\n/**/\n    1399,\n/**/\n    1398,\n/**/\n    1397,\n/**/\n    1396,\n/**/\n    1395,\n/**/\n    1394,\n/**/\n    1393,\n/**/\n    1392,\n/**/\n    1391,\n/**/\n    1390,\n/**/\n    1389,\n/**/\n    1388,\n/**/\n    1387,\n/**/\n    1386,\n/**/\n    1385,\n/**/\n    1384,\n/**/\n    1383,\n/**/\n    1382,\n/**/\n    1381,\n/**/\n    1380,\n/**/\n    1379,\n/**/\n    1378,\n/**/\n    1377,\n/**/\n    1376,\n/**/\n    1375,\n/**/\n    1374,\n/**/\n    1373,\n/**/\n    1372,\n/**/\n    1371,\n/**/\n    1370,\n/**/\n    1369,\n/**/\n    1368,\n/**/\n    1367,\n/**/\n    1366,\n/**/\n    1365,\n/**/\n    1364,\n/**/\n    1363,\n/**/\n    1362,\n/**/\n    1361,\n/**/\n    1360,\n/**/\n    1359,\n/**/\n    1358,\n/**/\n    1357,\n/**/\n    1356,\n/**/\n    1355,\n/**/\n    1354,\n/**/\n    1353,\n/**/\n    1352,\n/**/\n    1351,\n/**/\n    1350,\n/**/\n    1349,\n/**/\n    1348,\n/**/\n    1347,\n/**/\n    1346,\n/**/\n    1345,\n/**/\n    1344,\n/**/\n    1343,\n/**/\n    1342,\n/**/\n    1341,\n/**/\n    1340,\n/**/\n    1339,\n/**/\n    1338,\n/**/\n    1337,\n/**/\n    1336,\n/**/\n    1335,\n/**/\n    1334,\n/**/\n    1333,\n/**/\n    1332,\n/**/\n    1331,\n/**/\n    1330,\n/**/\n    1329,\n/**/\n    1328,\n/**/\n    1327,\n/**/\n    1326,\n/**/\n    1325,\n/**/\n    1324,\n/**/\n    1323,\n/**/\n    1322,\n/**/\n    1321,\n/**/\n    1320,\n/**/\n    1319,\n/**/\n    1318,\n/**/\n    1317,\n/**/\n    1316,\n/**/\n    1315,\n/**/\n    1314,\n/**/\n    1313,\n/**/\n    1312,\n/**/\n    1311,\n/**/\n    1310,\n/**/\n    1309,\n/**/\n    1308,\n/**/\n    1307,\n/**/\n    1306,\n/**/\n    1305,\n/**/\n    1304,\n/**/\n    1303,\n/**/\n    1302,\n/**/\n    1301,\n/**/\n    1300,\n/**/\n    1299,\n/**/\n    1298,\n/**/\n    1297,\n/**/\n    1296,\n/**/\n    1295,\n/**/\n    1294,\n/**/\n    1293,\n/**/\n    1292,\n/**/\n    1291,\n/**/\n    1290,\n/**/\n    1289,\n/**/\n    1288,\n/**/\n    1287,\n/**/\n    1286,\n/**/\n    1285,\n/**/\n    1284,\n/**/\n    1283,\n/**/\n    1282,\n/**/\n    1281,\n/**/\n    1280,\n/**/\n    1279,\n/**/\n    1278,\n/**/\n    1277,\n/**/\n    1276,\n/**/\n    1275,\n/**/\n    1274,\n/**/\n    1273,\n/**/\n    1272,\n/**/\n    1271,\n/**/\n    1270,\n/**/\n    1269,\n/**/\n    1268,\n/**/\n    1267,\n/**/\n    1266,\n/**/\n    1265,\n/**/\n    1264,\n/**/\n    1263,\n/**/\n    1262,\n/**/\n    1261,\n/**/\n    1260,\n/**/\n    1259,\n/**/\n    1258,\n/**/\n    1257,\n/**/\n    1256,\n/**/\n    1255,\n/**/\n    1254,\n/**/\n    1253,\n/**/\n    1252,\n/**/\n    1251,\n/**/\n    1250,\n/**/\n    1249,\n/**/\n    1248,\n/**/\n    1247,\n/**/\n    1246,\n/**/\n    1245,\n/**/\n    1244,\n/**/\n    1243,\n/**/\n    1242,\n/**/\n    1241,\n/**/\n    1240,\n/**/\n    1239,\n/**/\n    1238,\n/**/\n    1237,\n/**/\n    1236,\n/**/\n    1235,\n/**/\n    1234,\n/**/\n    1233,\n/**/\n    1232,\n/**/\n    1231,\n/**/\n    1230,\n/**/\n    1229,\n/**/\n    1228,\n/**/\n    1227,\n/**/\n    1226,\n/**/\n    1225,\n/**/\n    1224,\n/**/\n    1223,\n/**/\n    1222,\n/**/\n    1221,\n/**/\n    1220,\n/**/\n    1219,\n/**/\n    1218,\n/**/\n    1217,\n/**/\n    1216,\n/**/\n    1215,\n/**/\n    1214,\n/**/\n    1213,\n/**/\n    1212,\n/**/\n    1211,\n/**/\n    1210,\n/**/\n    1209,\n/**/\n    1208,\n/**/\n    1207,\n/**/\n    1206,\n/**/\n    1205,\n/**/\n    1204,\n/**/\n    1203,\n/**/\n    1202,\n/**/\n    1201,\n/**/\n    1200,\n/**/\n    1199,\n/**/\n    1198,\n/**/\n    1197,\n/**/\n    1196,\n/**/\n    1195,\n/**/\n    1194,\n/**/\n    1193,\n/**/\n    1192,\n/**/\n    1191,\n/**/\n    1190,\n/**/\n    1189,\n/**/\n    1188,\n/**/\n    1187,\n/**/\n    1186,\n/**/\n    1185,\n/**/\n    1184,\n/**/\n    1183,\n/**/\n    1182,\n/**/\n    1181,\n/**/\n    1180,\n/**/\n    1179,\n/**/\n    1178,\n/**/\n    1177,\n/**/\n    1176,\n/**/\n    1175,\n/**/\n    1174,\n/**/\n    1173,\n/**/\n    1172,\n/**/\n    1171,\n/**/\n    1170,\n/**/\n    1169,\n/**/\n    1168,\n/**/\n    1167,\n/**/\n    1166,\n/**/\n    1165,\n/**/\n    1164,\n/**/\n    1163,\n/**/\n    1162,\n/**/\n    1161,\n/**/\n    1160,\n/**/\n    1159,\n/**/\n    1158,\n/**/\n    1157,\n/**/\n    1156,\n/**/\n    1155,\n/**/\n    1154,\n/**/\n    1153,\n/**/\n    1152,\n/**/\n    1151,\n/**/\n    1150,\n/**/\n    1149,\n/**/\n    1148,\n/**/\n    1147,\n/**/\n    1146,\n/**/\n    1145,\n/**/\n    1144,\n/**/\n    1143,\n/**/\n    1142,\n/**/\n    1141,\n/**/\n    1140,\n/**/\n    1139,\n/**/\n    1138,\n/**/\n    1137,\n/**/\n    1136,\n/**/\n    1135,\n/**/\n    1134,\n/**/\n    1133,\n/**/\n    1132,\n/**/\n    1131,\n/**/\n    1130,\n/**/\n    1129,\n/**/\n    1128,\n/**/\n    1127,\n/**/\n    1126,\n/**/\n    1125,\n/**/\n    1124,\n/**/\n    1123,\n/**/\n    1122,\n/**/\n    1121,\n/**/\n    1120,\n/**/\n    1119,\n/**/\n    1118,\n/**/\n    1117,\n/**/\n    1116,\n/**/\n    1115,\n/**/\n    1114,\n/**/\n    1113,\n/**/\n    1112,\n/**/\n    1111,\n/**/\n    1110,\n/**/\n    1109,\n/**/\n    1108,\n/**/\n    1107,\n/**/\n    1106,\n/**/\n    1105,\n/**/\n    1104,\n/**/\n    1103,\n/**/\n    1102,\n/**/\n    1101,\n/**/\n    1100,\n/**/\n    1099,\n/**/\n    1098,\n/**/\n    1097,\n/**/\n    1096,\n/**/\n    1095,\n/**/\n    1094,\n/**/\n    1093,\n/**/\n    1092,\n/**/\n    1091,\n/**/\n    1090,\n/**/\n    1089,\n/**/\n    1088,\n/**/\n    1087,\n/**/\n    1086,\n/**/\n    1085,\n/**/\n    1084,\n/**/\n    1083,\n/**/\n    1082,\n/**/\n    1081,\n/**/\n    1080,\n/**/\n    1079,\n/**/\n    1078,\n/**/\n    1077,\n/**/\n    1076,\n/**/\n    1075,\n/**/\n    1074,\n/**/\n    1073,\n/**/\n    1072,\n/**/\n    1071,\n/**/\n    1070,\n/**/\n    1069,\n/**/\n    1068,\n/**/\n    1067,\n/**/\n    1066,\n/**/\n    1065,\n/**/\n    1064,\n/**/\n    1063,\n/**/\n    1062,\n/**/\n    1061,\n/**/\n    1060,\n/**/\n    1059,\n/**/\n    1058,\n/**/\n    1057,\n/**/\n    1056,\n/**/\n    1055,\n/**/\n    1054,\n/**/\n    1053,\n/**/\n    1052,\n/**/\n    1051,\n/**/\n    1050,\n/**/\n    1049,\n/**/\n    1048,\n/**/\n    1047,\n/**/\n    1046,\n/**/\n    1045,\n/**/\n    1044,\n/**/\n    1043,\n/**/\n    1042,\n/**/\n    1041,\n/**/\n    1040,\n/**/\n    1039,\n/**/\n    1038,\n/**/\n    1037,\n/**/\n    1036,\n/**/\n    1035,\n/**/\n    1034,\n/**/\n    1033,\n/**/\n    1032,\n/**/\n    1031,\n/**/\n    1030,\n/**/\n    1029,\n/**/\n    1028,\n/**/\n    1027,\n/**/\n    1026,\n/**/\n    1025,\n/**/\n    1024,\n/**/\n    1023,\n/**/\n    1022,\n/**/\n    1021,\n/**/\n    1020,\n/**/\n    1019,\n/**/\n    1018,\n/**/\n    1017,\n/**/\n    1016,\n/**/\n    1015,\n/**/\n    1014,\n/**/\n    1013,\n/**/\n    1012,\n/**/\n    1011,\n/**/\n    1010,\n/**/\n    1009,\n/**/\n    1008,\n/**/\n    1007,\n/**/\n    1006,\n/**/\n    1005,\n/**/\n    1004,\n/**/\n    1003,\n/**/\n    1002,\n/**/\n    1001,\n/**/\n    1000,\n/**/\n    999,\n/**/\n    998,\n/**/\n    997,\n/**/\n    996,\n/**/\n    995,\n/**/\n    994,\n/**/\n    993,\n/**/\n    992,\n/**/\n    991,\n/**/\n    990,\n/**/\n    989,\n/**/\n    988,\n/**/\n    987,\n/**/\n    986,\n/**/\n    985,\n/**/\n    984,\n/**/\n    983,\n/**/\n    982,\n/**/\n    981,\n/**/\n    980,\n/**/\n    979,\n/**/\n    978,\n/**/\n    977,\n/**/\n    976,\n/**/\n    975,\n/**/\n    974,\n/**/\n    973,\n/**/\n    972,\n/**/\n    971,\n/**/\n    970,\n/**/\n    969,\n/**/\n    968,\n/**/\n    967,\n/**/\n    966,\n/**/\n    965,\n/**/\n    964,\n/**/\n    963,\n/**/\n    962,\n/**/\n    961,\n/**/\n    960,\n/**/\n    959,\n/**/\n    958,\n/**/\n    957,\n/**/\n    956,\n/**/\n    955,\n/**/\n    954,\n/**/\n    953,\n/**/\n    952,\n/**/\n    951,\n/**/\n    950,\n/**/\n    949,\n/**/\n    948,\n/**/\n    947,\n/**/\n    946,\n/**/\n    945,\n/**/\n    944,\n/**/\n    943,\n/**/\n    942,\n/**/\n    941,\n/**/\n    940,\n/**/\n    939,\n/**/\n    938,\n/**/\n    937,\n/**/\n    936,\n/**/\n    935,\n/**/\n    934,\n/**/\n    933,\n/**/\n    932,\n/**/\n    931,\n/**/\n    930,\n/**/\n    929,\n/**/\n    928,\n/**/\n    927,\n/**/\n    926,\n/**/\n    925,\n/**/\n    924,\n/**/\n    923,\n/**/\n    922,\n/**/\n    921,\n/**/\n    920,\n/**/\n    919,\n/**/\n    918,\n/**/\n    917,\n/**/\n    916,\n/**/\n    915,\n/**/\n    914,\n/**/\n    913,\n/**/\n    912,\n/**/\n    911,\n/**/\n    910,\n/**/\n    909,\n/**/\n    908,\n/**/\n    907,\n/**/\n    906,\n/**/\n    905,\n/**/\n    904,\n/**/\n    903,\n/**/\n    902,\n/**/\n    901,\n/**/\n    900,\n/**/\n    899,\n/**/\n    898,\n/**/\n    897,\n/**/\n    896,\n/**/\n    895,\n/**/\n    894,\n/**/\n    893,\n/**/\n    892,\n/**/\n    891,\n/**/\n    890,\n/**/\n    889,\n/**/\n    888,\n/**/\n    887,\n/**/\n    886,\n/**/\n    885,\n/**/\n    884,\n/**/\n    883,\n/**/\n    882,\n/**/\n    881,\n/**/\n    880,\n/**/\n    879,\n/**/\n    878,\n/**/\n    877,\n/**/\n    876,\n/**/\n    875,\n/**/\n    874,\n/**/\n    873,\n/**/\n    872,\n/**/\n    871,\n/**/\n    870,\n/**/\n    869,\n/**/\n    868,\n/**/\n    867,\n/**/\n    866,\n/**/\n    865,\n/**/\n    864,\n/**/\n    863,\n/**/\n    862,\n/**/\n    861,\n/**/\n    860,\n/**/\n    859,\n/**/\n    858,\n/**/\n    857,\n/**/\n    856,\n/**/\n    855,\n/**/\n    854,\n/**/\n    853,\n/**/\n    852,\n/**/\n    851,\n/**/\n    850,\n/**/\n    849,\n/**/\n    848,\n/**/\n    847,\n/**/\n    846,\n/**/\n    845,\n/**/\n    844,\n/**/\n    843,\n/**/\n    842,\n/**/\n    841,\n/**/\n    840,\n/**/\n    839,\n/**/\n    838,\n/**/\n    837,\n/**/\n    836,\n/**/\n    835,\n/**/\n    834,\n/**/\n    833,\n/**/\n    832,\n/**/\n    831,\n/**/\n    830,\n/**/\n    829,\n/**/\n    828,\n/**/\n    827,\n/**/\n    826,\n/**/\n    825,\n/**/\n    824,\n/**/\n    823,\n/**/\n    822,\n/**/\n    821,\n/**/\n    820,\n/**/\n    819,\n/**/\n    818,\n/**/\n    817,\n/**/\n    816,\n/**/\n    815,\n/**/\n    814,\n/**/\n    813,\n/**/\n    812,\n/**/\n    811,\n/**/\n    810,\n/**/\n    809,\n/**/\n    808,\n/**/\n    807,\n/**/\n    806,\n/**/\n    805,\n/**/\n    804,\n/**/\n    803,\n/**/\n    802,\n/**/\n    801,\n/**/\n    800,\n/**/\n    799,\n/**/\n    798,\n/**/\n    797,\n/**/\n    796,\n/**/\n    795,\n/**/\n    794,\n/**/\n    793,\n/**/\n    792,\n/**/\n    791,\n/**/\n    790,\n/**/\n    789,\n/**/\n    788,\n/**/\n    787,\n/**/\n    786,\n/**/\n    785,\n/**/\n    784,\n/**/\n    783,\n/**/\n    782,\n/**/\n    781,\n/**/\n    780,\n/**/\n    779,\n/**/\n    778,\n/**/\n    777,\n/**/\n    776,\n/**/\n    775,\n/**/\n    774,\n/**/\n    773,\n/**/\n    772,\n/**/\n    771,\n/**/\n    770,\n/**/\n    769,\n/**/\n    768,\n/**/\n    767,\n/**/\n    766,\n/**/\n    765,\n/**/\n    764,\n/**/\n    763,\n/**/\n    762,\n/**/\n    761,\n/**/\n    760,\n/**/\n    759,\n/**/\n    758,\n/**/\n    757,\n/**/\n    756,\n/**/\n    755,\n/**/\n    754,\n/**/\n    753,\n/**/\n    752,\n/**/\n    751,\n/**/\n    750,\n/**/\n    749,\n/**/\n    748,\n/**/\n    747,\n/**/\n    746,\n/**/\n    745,\n/**/\n    744,\n/**/\n    743,\n/**/\n    742,\n/**/\n    741,\n/**/\n    740,\n/**/\n    739,\n/**/\n    738,\n/**/\n    737,\n/**/\n    736,\n/**/\n    735,\n/**/\n    734,\n/**/\n    733,\n/**/\n    732,\n/**/\n    731,\n/**/\n    730,\n/**/\n    729,\n/**/\n    728,\n/**/\n    727,\n/**/\n    726,\n/**/\n    725,\n/**/\n    724,\n/**/\n    723,\n/**/\n    722,\n/**/\n    721,\n/**/\n    720,\n/**/\n    719,\n/**/\n    718,\n/**/\n    717,\n/**/\n    716,\n/**/\n    715,\n/**/\n    714,\n/**/\n    713,\n/**/\n    712,\n/**/\n    711,\n/**/\n    710,\n/**/\n    709,\n/**/\n    708,\n/**/\n    707,\n/**/\n    706,\n/**/\n    705,\n/**/\n    704,\n/**/\n    703,\n/**/\n    702,\n/**/\n    701,\n/**/\n    700,\n/**/\n    699,\n/**/\n    698,\n/**/\n    697,\n/**/\n    696,\n/**/\n    695,\n/**/\n    694,\n/**/\n    693,\n/**/\n    692,\n/**/\n    691,\n/**/\n    690,\n/**/\n    689,\n/**/\n    688,\n/**/\n    687,\n/**/\n    686,\n/**/\n    685,\n/**/\n    684,\n/**/\n    683,\n/**/\n    682,\n/**/\n    681,\n/**/\n    680,\n/**/\n    679,\n/**/\n    678,\n/**/\n    677,\n/**/\n    676,\n/**/\n    675,\n/**/\n    674,\n/**/\n    673,\n/**/\n    672,\n/**/\n    671,\n/**/\n    670,\n/**/\n    669,\n/**/\n    668,\n/**/\n    667,\n/**/\n    666,\n/**/\n    665,\n/**/\n    664,\n/**/\n    663,\n/**/\n    662,\n/**/\n    661,\n/**/\n    660,\n/**/\n    659,\n/**/\n    658,\n/**/\n    657,\n/**/\n    656,\n/**/\n    655,\n/**/\n    654,\n/**/\n    653,\n/**/\n    652,\n/**/\n    651,\n/**/\n    650,\n/**/\n    649,\n/**/\n    648,\n/**/\n    647,\n/**/\n    646,\n/**/\n    645,\n/**/\n    644,\n/**/\n    643,\n/**/\n    642,\n/**/\n    641,\n/**/\n    640,\n/**/\n    639,\n/**/\n    638,\n/**/\n    637,\n/**/\n    636,\n/**/\n    635,\n/**/\n    634,\n/**/\n    633,\n/**/\n    632,\n/**/\n    631,\n/**/\n    630,\n/**/\n    629,\n/**/\n    628,\n/**/\n    627,\n/**/\n    626,\n/**/\n    625,\n/**/\n    624,\n/**/\n    623,\n/**/\n    622,\n/**/\n    621,\n/**/\n    620,\n/**/\n    619,\n/**/\n    618,\n/**/\n    617,\n/**/\n    616,\n/**/\n    615,\n/**/\n    614,\n/**/\n    613,\n/**/\n    612,\n/**/\n    611,\n/**/\n    610,\n/**/\n    609,\n/**/\n    608,\n/**/\n    607,\n/**/\n    606,\n/**/\n    605,\n/**/\n    604,\n/**/\n    603,\n/**/\n    602,\n/**/\n    601,\n/**/\n    600,\n/**/\n    599,\n/**/\n    598,\n/**/\n    597,\n/**/\n    596,\n/**/\n    595,\n/**/\n    594,\n/**/\n    593,\n/**/\n    592,\n/**/\n    591,\n/**/\n    590,\n/**/\n    589,\n/**/\n    588,\n/**/\n    587,\n/**/\n    586,\n/**/\n    585,\n/**/\n    584,\n/**/\n    583,\n/**/\n    582,\n/**/\n    581,\n/**/\n    580,\n/**/\n    579,\n/**/\n    578,\n/**/\n    577,\n/**/\n    576,\n/**/\n    575,\n/**/\n    574,\n/**/\n    573,\n/**/\n    572,\n/**/\n    571,\n/**/\n    570,\n/**/\n    569,\n/**/\n    568,\n/**/\n    567,\n/**/\n    566,\n/**/\n    565,\n/**/\n    564,\n/**/\n    563,\n/**/\n    562,\n/**/\n    561,\n/**/\n    560,\n/**/\n    559,\n/**/\n    558,\n/**/\n    557,\n/**/\n    556,\n/**/\n    555,\n/**/\n    554,\n/**/\n    553,\n/**/\n    552,\n/**/\n    551,\n/**/\n    550,\n/**/\n    549,\n/**/\n    548,\n/**/\n    547,\n/**/\n    546,\n/**/\n    545,\n/**/\n    544,\n/**/\n    543,\n/**/\n    542,\n/**/\n    541,\n/**/\n    540,\n/**/\n    539,\n/**/\n    538,\n/**/\n    537,\n/**/\n    536,\n/**/\n    535,\n/**/\n    534,\n/**/\n    533,\n/**/\n    532,\n/**/\n    531,\n/**/\n    530,\n/**/\n    529,\n/**/\n    528,\n/**/\n    527,\n/**/\n    526,\n/**/\n    525,\n/**/\n    524,\n/**/\n    523,\n/**/\n    522,\n/**/\n    521,\n/**/\n    520,\n/**/\n    519,\n/**/\n    518,\n/**/\n    517,\n/**/\n    516,\n/**/\n    515,\n/**/\n    514,\n/**/\n    513,\n/**/\n    512,\n/**/\n    511,\n/**/\n    510,\n/**/\n    509,\n/**/\n    508,\n/**/\n    507,\n/**/\n    506,\n/**/\n    505,\n/**/\n    504,\n/**/\n    503,\n/**/\n    502,\n/**/\n    501,\n/**/\n    500,\n/**/\n    499,\n/**/\n    498,\n/**/\n    497,\n/**/\n    496,\n/**/\n    495,\n/**/\n    494,\n/**/\n    493,\n/**/\n    492,\n/**/\n    491,\n/**/\n    490,\n/**/\n    489,\n/**/\n    488,\n/**/\n    487,\n/**/\n    486,\n/**/\n    485,\n/**/\n    484,\n/**/\n    483,\n/**/\n    482,\n/**/\n    481,\n/**/\n    480,\n/**/\n    479,\n/**/\n    478,\n/**/\n    477,\n/**/\n    476,\n/**/\n    475,\n/**/\n    474,\n/**/\n    473,\n/**/\n    472,\n/**/\n    471,\n/**/\n    470,\n/**/\n    469,\n/**/\n    468,\n/**/\n    467,\n/**/\n    466,\n/**/\n    465,\n/**/\n    464,\n/**/\n    463,\n/**/\n    462,\n/**/\n    461,\n/**/\n    460,\n/**/\n    459,\n/**/\n    458,\n/**/\n    457,\n/**/\n    456,\n/**/\n    455,\n/**/\n    454,\n/**/\n    453,\n/**/\n    452,\n/**/\n    451,\n/**/\n    450,\n/**/\n    449,\n/**/\n    448,\n/**/\n    447,\n/**/\n    446,\n/**/\n    445,\n/**/\n    444,\n/**/\n    443,\n/**/\n    442,\n/**/\n    441,\n/**/\n    440,\n/**/\n    439,\n/**/\n    438,\n/**/\n    437,\n/**/\n    436,\n/**/\n    435,\n/**/\n    434,\n/**/\n    433,\n/**/\n    432,\n/**/\n    431,\n/**/\n    430,\n/**/\n    429,\n/**/\n    428,\n/**/\n    427,\n/**/\n    426,\n/**/\n    425,\n/**/\n    424,\n/**/\n    423,\n/**/\n    422,\n/**/\n    421,\n/**/\n    420,\n/**/\n    419,\n/**/\n    418,\n/**/\n    417,\n/**/\n    416,\n/**/\n    415,\n/**/\n    414,\n/**/\n    413,\n/**/\n    412,\n/**/\n    411,\n/**/\n    410,\n/**/\n    409,\n/**/\n    408,\n/**/\n    407,\n/**/\n    406,\n/**/\n    405,\n/**/\n    404,\n/**/\n    403,\n/**/\n    402,\n/**/\n    401,\n/**/\n    400,\n/**/\n    399,\n/**/\n    398,\n/**/\n    397,\n/**/\n    396,\n/**/\n    395,\n/**/\n    394,\n/**/\n    393,\n/**/\n    392,\n/**/\n    391,\n/**/\n    390,\n/**/\n    389,\n/**/\n    388,\n/**/\n    387,\n/**/\n    386,\n/**/\n    385,\n/**/\n    384,\n/**/\n    383,\n/**/\n    382,\n/**/\n    381,\n/**/\n    380,\n/**/\n    379,\n/**/\n    378,\n/**/\n    377,\n/**/\n    376,\n/**/\n    375,\n/**/\n    374,\n/**/\n    373,\n/**/\n    372,\n/**/\n    371,\n/**/\n    370,\n/**/\n    369,\n/**/\n    368,\n/**/\n    367,\n/**/\n    366,\n/**/\n    365,\n/**/\n    364,\n/**/\n    363,\n/**/\n    362,\n/**/\n    361,\n/**/\n    360,\n/**/\n    359,\n/**/\n    358,\n/**/\n    357,\n/**/\n    356,\n/**/\n    355,\n/**/\n    354,\n/**/\n    353,\n/**/\n    352,\n/**/\n    351,\n/**/\n    350,\n/**/\n    349,\n/**/\n    348,\n/**/\n    347,\n/**/\n    346,\n/**/\n    345,\n/**/\n    344,\n/**/\n    343,\n/**/\n    342,\n/**/\n    341,\n/**/\n    340,\n/**/\n    339,\n/**/\n    338,\n/**/\n    337,\n/**/\n    336,\n/**/\n    335,\n/**/\n    334,\n/**/\n    333,\n/**/\n    332,\n/**/\n    331,\n/**/\n    330,\n/**/\n    329,\n/**/\n    328,\n/**/\n    327,\n/**/\n    326,\n/**/\n    325,\n/**/\n    324,\n/**/\n    323,\n/**/\n    322,\n/**/\n    321,\n/**/\n    320,\n/**/\n    319,\n/**/\n    318,\n/**/\n    317,\n/**/\n    316,\n/**/\n    315,\n/**/\n    314,\n/**/\n    313,\n/**/\n    312,\n/**/\n    311,\n/**/\n    310,\n/**/\n    309,\n/**/\n    308,\n/**/\n    307,\n/**/\n    306,\n/**/\n    305,\n/**/\n    304,\n/**/\n    303,\n/**/\n    302,\n/**/\n    301,\n/**/\n    300,\n/**/\n    299,\n/**/\n    298,\n/**/\n    297,\n/**/\n    296,\n/**/\n    295,\n/**/\n    294,\n/**/\n    293,\n/**/\n    292,\n/**/\n    291,\n/**/\n    290,\n/**/\n    289,\n/**/\n    288,\n/**/\n    287,\n/**/\n    286,\n/**/\n    285,\n/**/\n    284,\n/**/\n    283,\n/**/\n    282,\n/**/\n    281,\n/**/\n    280,\n/**/\n    279,\n/**/\n    278,\n/**/\n    277,\n/**/\n    276,\n/**/\n    275,\n/**/\n    274,\n/**/\n    273,\n/**/\n    272,\n/**/\n    271,\n/**/\n    270,\n/**/\n    269,\n/**/\n    268,\n/**/\n    267,\n/**/\n    266,\n/**/\n    265,\n/**/\n    264,\n/**/\n    263,\n/**/\n    262,\n/**/\n    261,\n/**/\n    260,\n/**/\n    259,\n/**/\n    258,\n/**/\n    257,\n/**/\n    256,\n/**/\n    255,\n/**/\n    254,\n/**/\n    253,\n/**/\n    252,\n/**/\n    251,\n/**/\n    250,\n/**/\n    249,\n/**/\n    248,\n/**/\n    247,\n/**/\n    246,\n/**/\n    245,\n/**/\n    244,\n/**/\n    243,\n/**/\n    242,\n/**/\n    241,\n/**/\n    240,\n/**/\n    239,\n/**/\n    238,\n/**/\n    237,\n/**/\n    236,\n/**/\n    235,\n/**/\n    234,\n/**/\n    233,\n/**/\n    232,\n/**/\n    231,\n/**/\n    230,\n/**/\n    229,\n/**/\n    228,\n/**/\n    227,\n/**/\n    226,\n/**/\n    225,\n/**/\n    224,\n/**/\n    223,\n/**/\n    222,\n/**/\n    221,\n/**/\n    220,\n/**/\n    219,\n/**/\n    218,\n/**/\n    217,\n/**/\n    216,\n/**/\n    215,\n/**/\n    214,\n/**/\n    213,\n/**/\n    212,\n/**/\n    211,\n/**/\n    210,\n/**/\n    209,\n/**/\n    208,\n/**/\n    207,\n/**/\n    206,\n/**/\n    205,\n/**/\n    204,\n/**/\n    203,\n/**/\n    202,\n/**/\n    201,\n/**/\n    200,\n/**/\n    199,\n/**/\n    198,\n/**/\n    197,\n/**/\n    196,\n/**/\n    195,\n/**/\n    194,\n/**/\n    193,\n/**/\n    192,\n/**/\n    191,\n/**/\n    190,\n/**/\n    189,\n/**/\n    188,\n/**/\n    187,\n/**/\n    186,\n/**/\n    185,\n/**/\n    184,\n/**/\n    183,\n/**/\n    182,\n/**/\n    181,\n/**/\n    180,\n/**/\n    179,\n/**/\n    178,\n/**/\n    177,\n/**/\n    176,\n/**/\n    175,\n/**/\n    174,\n/**/\n    173,\n/**/\n    172,\n/**/\n    171,\n/**/\n    170,\n/**/\n    169,\n/**/\n    168,\n/**/\n    167,\n/**/\n    166,\n/**/\n    165,\n/**/\n    164,\n/**/\n    163,\n/**/\n    162,\n/**/\n    161,\n/**/\n    160,\n/**/\n    159,\n/**/\n    158,\n/**/\n    157,\n/**/\n    156,\n/**/\n    155,\n/**/\n    154,\n/**/\n    153,\n/**/\n    152,\n/**/\n    151,\n/**/\n    150,\n/**/\n    149,\n/**/\n    148,\n/**/\n    147,\n/**/\n    146,\n/**/\n    145,\n/**/\n    144,\n/**/\n    143,\n/**/\n    142,\n/**/\n    141,\n/**/\n    140,\n/**/\n    139,\n/**/\n    138,\n/**/\n    137,\n/**/\n    136,\n/**/\n    135,\n/**/\n    134,\n/**/\n    133,\n/**/\n    132,\n/**/\n    131,\n/**/\n    130,\n/**/\n    129,\n/**/\n    128,\n/**/\n    127,\n/**/\n    126,\n/**/\n    125,\n/**/\n    124,\n/**/\n    123,\n/**/\n    122,\n/**/\n    121,\n/**/\n    120,\n/**/\n    119,\n/**/\n    118,\n/**/\n    117,\n/**/\n    116,\n/**/\n    115,\n/**/\n    114,\n/**/\n    113,\n/**/\n    112,\n/**/\n    111,\n/**/\n    110,\n/**/\n    109,\n/**/\n    108,\n/**/\n    107,\n/**/\n    106,\n/**/\n    105,\n/**/\n    104,\n/**/\n    103,\n/**/\n    102,\n/**/\n    101,\n/**/\n    100,\n/**/\n    99,\n/**/\n    98,\n/**/\n    97,\n/**/\n    96,\n/**/\n    95,\n/**/\n    94,\n/**/\n    93,\n/**/\n    92,\n/**/\n    91,\n/**/\n    90,\n/**/\n    89,\n/**/\n    88,\n/**/\n    87,\n/**/\n    86,\n/**/\n    85,\n/**/\n    84,\n/**/\n    83,\n/**/\n    82,\n/**/\n    81,\n/**/\n    80,\n/**/\n    79,\n/**/\n    78,\n/**/\n    77,\n/**/\n    76,\n/**/\n    75,\n/**/\n    74,\n/**/\n    73,\n/**/\n    72,\n/**/\n    71,\n/**/\n    70,\n/**/\n    69,\n/**/\n    68,\n/**/\n    67,\n/**/\n    66,\n/**/\n    65,\n/**/\n    64,\n/**/\n    63,\n/**/\n    62,\n/**/\n    61,\n/**/\n    60,\n/**/\n    59,\n/**/\n    58,\n/**/\n    57,\n/**/\n    56,\n/**/\n    55,\n/**/\n    54,\n/**/\n    53,\n/**/\n    52,\n/**/\n    51,\n/**/\n    50,\n/**/\n    49,\n/**/\n    48,\n/**/\n    47,\n/**/\n    46,\n/**/\n    45,\n/**/\n    44,\n/**/\n    43,\n/**/\n    42,\n/**/\n    41,\n/**/\n    40,\n/**/\n    39,\n/**/\n    38,\n/**/\n    37,\n/**/\n    36,\n/**/\n    35,\n/**/\n    34,\n/**/\n    33,\n/**/\n    32,\n/**/\n    31,\n/**/\n    30,\n/**/\n    29,\n/**/\n    28,\n/**/\n    27,\n/**/\n    26,\n/**/\n    25,\n/**/\n    24,\n/**/\n    23,\n/**/\n    22,\n/**/\n    21,\n/**/\n    20,\n/**/\n    19,\n/**/\n    18,\n/**/\n    17,\n/**/\n    16,\n/**/\n    15,\n/**/\n    14,\n/**/\n    13,\n/**/\n    12,\n/**/\n    11,\n/**/\n    10,\n/**/\n    9,\n/**/\n    8,\n/**/\n    7,\n/**/\n    6,\n/**/\n    5,\n/**/\n    4,\n/**/\n    3,\n/**/\n    2,\n/**/\n    1,\n/**/\n    0\n};\n\n/*\n * Place to put a short description when adding a feature with a patch.\n * Keep it short, e.g.,: \"relative numbers\", \"persistent undo\".\n * Also add a comment marker to separate the lines.\n * See the official Vim patches for the diff format: It must use a context of\n * one line only.  Create it by hand or use \"diff -C2\" and edit the patch.\n */\nstatic char *(extra_patches[]) =\n{   /* Add your patch description below this line */\n/**/\n    NULL\n};\n\n    int\nhighest_patch(void)\n{\n    // this relies on the highest patch number to be the first entry\n    return included_patches[0];\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return TRUE if patch \"n\" has been included.\n */\n    int\nhas_patch(int n)\n{\n    int\t\th, m, l;\n\n    // Perform a binary search.\n    l = 0;\n    h = (int)ARRAY_LENGTH(included_patches) - 1;\n    for (;;)\n    {\n\tm = (l + h) / 2;\n\tif (included_patches[m] == n)\n\t    return TRUE;\n\tif (l == h)\n\t    break;\n\tif (included_patches[m] < n)\n\t    h = m;\n\telse\n\t    l = m + 1;\n    }\n    return FALSE;\n}\n#endif\n\n    void\nex_version(exarg_T *eap)\n{\n    /*\n     * Ignore a \":version 9.99\" command.\n     */\n    if (*eap->arg == NUL)\n    {\n\tmsg_putchar('\\n');\n\tlist_version();\n    }\n}\n\n/*\n * Output a string for the version message.  If it's going to wrap, output a\n * newline, unless the message is too long to fit on the screen anyway.\n * When \"wrap\" is TRUE wrap the string in [].\n */\n    static void\nversion_msg_wrap(char_u *s, int wrap)\n{\n    int\t\tlen = vim_strsize(s) + (wrap ? 2 : 0);\n\n    if (!got_int && len < (int)Columns && msg_col + len >= (int)Columns\n\t\t\t\t\t\t\t\t&& *s != '\\n')\n\tmsg_putchar('\\n');\n    if (!got_int)\n    {\n\tif (wrap)\n\t    msg_puts(\"[\");\n\tmsg_puts((char *)s);\n\tif (wrap)\n\t    msg_puts(\"]\");\n    }\n}\n\n    static void\nversion_msg(char *s)\n{\n    version_msg_wrap((char_u *)s, FALSE);\n}\n\n/*\n * List all features aligned in columns, dictionary style.\n */\n    static void\nlist_features(void)\n{\n    list_in_columns((char_u **)features, -1, -1);\n}\n\n/*\n * List string items nicely aligned in columns.\n * When \"size\" is < 0 then the last entry is marked with NULL.\n * The entry with index \"current\" is inclosed in [].\n */\n    void\nlist_in_columns(char_u **items, int size, int current)\n{\n    int\t\ti;\n    int\t\tncol;\n    int\t\tnrow;\n    int\t\tcur_row = 1;\n    int\t\titem_count = 0;\n    int\t\twidth = 0;\n#ifdef FEAT_SYN_HL\n    int\t\tuse_highlight = (items == (char_u **)features);\n#endif\n\n    // Find the length of the longest item, use that + 1 as the column\n    // width.\n    for (i = 0; size < 0 ? items[i] != NULL : i < size; ++i)\n    {\n\tint l = vim_strsize(items[i]) + (i == current ? 2 : 0);\n\n\tif (l > width)\n\t    width = l;\n\t++item_count;\n    }\n    width += 1;\n\n    if (Columns < width)\n    {\n\t// Not enough screen columns - show one per line\n\tfor (i = 0; i < item_count; ++i)\n\t{\n\t    version_msg_wrap(items[i], i == current);\n\t    if (msg_col > 0 && i < item_count - 1)\n\t\tmsg_putchar('\\n');\n\t}\n\treturn;\n    }\n\n    // The rightmost column doesn't need a separator.\n    // Sacrifice it to fit in one more column if possible.\n    ncol = (int) (Columns + 1) / width;\n    nrow = item_count / ncol + ((item_count % ncol) ? 1 : 0);\n\n    // \"i\" counts columns then rows.  \"idx\" counts rows then columns.\n    for (i = 0; !got_int && i < nrow * ncol; ++i)\n    {\n\tint idx = (i / ncol) + (i % ncol) * nrow;\n\n\tif (idx < item_count)\n\t{\n\t    int last_col = (i + 1) % ncol == 0;\n\n\t    if (idx == current)\n\t\tmsg_putchar('[');\n#ifdef FEAT_SYN_HL\n\t    if (use_highlight && items[idx][0] == '-')\n\t\tmsg_puts_attr((char *)items[idx], HL_ATTR(HLF_W));\n\t    else\n#endif\n\t\tmsg_puts((char *)items[idx]);\n\t    if (idx == current)\n\t\tmsg_putchar(']');\n\t    if (last_col)\n\t    {\n\t\tif (msg_col > 0 && cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t    else\n\t    {\n\t\twhile (msg_col % width)\n\t\t    msg_putchar(' ');\n\t    }\n\t}\n\telse\n\t{\n\t    // this row is out of items, thus at the end of the row\n\t    if (msg_col > 0)\n\t    {\n\t\tif (cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t}\n    }\n}\n\n    void\nlist_version(void)\n{\n    int\t\ti;\n    int\t\tfirst;\n    char\t*s = \"\";\n\n    /*\n     * When adding features here, don't forget to update the list of\n     * internal variables in eval.c!\n     */\n    init_longVersion();\n    msg(longVersion);\n#ifdef MSWIN\n# ifdef FEAT_GUI_MSWIN\n#  ifdef VIMDLL\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI/console version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI/console version\"));\n#   endif\n#  else\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI version\"));\n#   endif\n#  endif\n#  ifdef FEAT_OLE\n    msg_puts(_(\" with OLE support\"));\n#  endif\n# else\n#  ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit console version\"));\n#  else\n    msg_puts(_(\"\\nMS-Windows 32-bit console version\"));\n#  endif\n# endif\n#endif\n#if defined(MACOS_X)\n# if defined(MACOS_X_DARWIN)\n    msg_puts(_(\"\\nmacOS version\"));\n# else\n    msg_puts(_(\"\\nmacOS version w/o darwin feat.\"));\n# endif\n# if defined(__arm64__)\n    msg_puts(\" - arm64\");\n# elif defined(__x86_64__)\n    msg_puts(\" - x86_64\");\n# endif\n#endif\n\n#ifdef VMS\n    msg_puts(_(\"\\nOpenVMS version\"));\n# ifdef HAVE_PATHDEF\n    if (*compiled_arch != NUL)\n    {\n\tmsg_puts(\" - \");\n\tmsg_puts((char *)compiled_arch);\n    }\n# endif\n\n#endif\n\n    // Print the list of patch numbers if there is at least one.\n    // Print a range when patches are consecutive: \"1-10, 12, 15-40, 42-45\"\n    if (included_patches[0] != 0)\n    {\n\tmsg_puts(_(\"\\nIncluded patches: \"));\n\tfirst = -1;\n\ti = (int)ARRAY_LENGTH(included_patches) - 1;\n\twhile (--i >= 0)\n\t{\n\t    if (first < 0)\n\t\tfirst = included_patches[i];\n\t    if (i == 0 || included_patches[i - 1] != included_patches[i] + 1)\n\t    {\n\t\tmsg_puts(s);\n\t\ts = \", \";\n\t\tmsg_outnum((long)first);\n\t\tif (first != included_patches[i])\n\t\t{\n\t\t    msg_puts(\"-\");\n\t\t    msg_outnum((long)included_patches[i]);\n\t\t}\n\t\tfirst = -1;\n\t    }\n\t}\n    }\n\n    // Print the list of extra patch descriptions if there is at least one.\n    if (extra_patches[0] != NULL)\n    {\n\tmsg_puts(_(\"\\nExtra patches: \"));\n\ts = \"\";\n\tfor (i = 0; extra_patches[i] != NULL; ++i)\n\t{\n\t    msg_puts(s);\n\t    s = \", \";\n\t    msg_puts(extra_patches[i]);\n\t}\n    }\n\n#ifdef MODIFIED_BY\n    msg_puts(\"\\n\");\n    msg_puts(_(\"Modified by \"));\n    msg_puts(MODIFIED_BY);\n#endif\n\n#ifdef HAVE_PATHDEF\n    if (*compiled_user != NUL || *compiled_sys != NUL)\n    {\n\tmsg_puts(_(\"\\nCompiled \"));\n\tif (*compiled_user != NUL)\n\t{\n\t    msg_puts(_(\"by \"));\n\t    msg_puts((char *)compiled_user);\n\t}\n\tif (*compiled_sys != NUL)\n\t{\n\t    msg_puts(\"@\");\n\t    msg_puts((char *)compiled_sys);\n\t}\n    }\n#endif\n\n#if defined(FEAT_HUGE)\n    msg_puts(_(\"\\nHuge version \"));\n#elif defined(FEAT_NORMAL)\n    msg_puts(_(\"\\nNormal version \"));\n#else\n    msg_puts(_(\"\\nTiny version \"));\n#endif\n#if !defined(FEAT_GUI)\n    msg_puts(_(\"without GUI.\"));\n#elif defined(FEAT_GUI_GTK)\n# if defined(USE_GTK3)\n    msg_puts(_(\"with GTK3 GUI.\"));\n# elif defined(FEAT_GUI_GNOME)\n     msg_puts(_(\"with GTK2-GNOME GUI.\"));\n# else\n     msg_puts(_(\"with GTK2 GUI.\"));\n# endif\n#elif defined(FEAT_GUI_MOTIF)\n    msg_puts(_(\"with X11-Motif GUI.\"));\n#elif defined(FEAT_GUI_HAIKU)\n    msg_puts(_(\"with Haiku GUI.\"));\n#elif defined(FEAT_GUI_PHOTON)\n    msg_puts(_(\"with Photon GUI.\"));\n#elif defined(MSWIN)\n    msg_puts(_(\"with GUI.\"));\n#endif\n    version_msg(_(\"  Features included (+) or not (-):\\n\"));\n\n    list_features();\n    if (msg_col > 0)\n\tmsg_putchar('\\n');\n\n#ifdef SYS_VIMRC_FILE\n    version_msg(_(\"   system vimrc file: \\\"\"));\n    version_msg(SYS_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE\n    version_msg(_(\"     user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE2\n    version_msg(_(\" 2nd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE3\n    version_msg(_(\" 3rd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE\n    version_msg(_(\"      user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE2\n    version_msg(_(\"  2nd user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef FEAT_GUI\n# ifdef SYS_GVIMRC_FILE\n    version_msg(_(\"  system gvimrc file: \\\"\"));\n    version_msg(SYS_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n    version_msg(_(\"    user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# ifdef USR_GVIMRC_FILE2\n    version_msg(_(\"2nd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n# endif\n# ifdef USR_GVIMRC_FILE3\n    version_msg(_(\"3rd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n    version_msg(_(\"       defaults file: \\\"\"));\n    version_msg(VIM_DEFAULTS_FILE);\n    version_msg(\"\\\"\\n\");\n#ifdef FEAT_GUI\n# ifdef SYS_MENU_FILE\n    version_msg(_(\"    system menu file: \\\"\"));\n    version_msg(SYS_MENU_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n#ifdef HAVE_PATHDEF\n    if (*default_vim_dir != NUL)\n    {\n\tversion_msg(_(\"  fall-back for $VIM: \\\"\"));\n\tversion_msg((char *)default_vim_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    if (*default_vimruntime_dir != NUL)\n    {\n\tversion_msg(_(\" f-b for $VIMRUNTIME: \\\"\"));\n\tversion_msg((char *)default_vimruntime_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    version_msg(_(\"Compilation: \"));\n    version_msg((char *)all_cflags);\n    version_msg(\"\\n\");\n#ifdef VMS\n    if (*compiler_version != NUL)\n    {\n\tversion_msg(_(\"Compiler: \"));\n\tversion_msg((char *)compiler_version);\n\tversion_msg(\"\\n\");\n    }\n#endif\n    version_msg(_(\"Linking: \"));\n    version_msg((char *)all_lflags);\n#endif\n#ifdef DEBUG\n    version_msg(\"\\n\");\n    version_msg(_(\"  DEBUG BUILD\"));\n#endif\n}\n\nstatic void do_intro_line(int row, char_u *mesg, int add_version, int attr);\nstatic void intro_message(int colon);\n\n/*\n * Show the intro message when not editing a file.\n */\n    void\nmaybe_intro_message(void)\n{\n    if (BUFEMPTY()\n\t    && curbuf->b_fname == NULL\n\t    && firstwin->w_next == NULL\n\t    && vim_strchr(p_shm, SHM_INTRO) == NULL)\n\tintro_message(FALSE);\n}\n\n/*\n * Give an introductory message about Vim.\n * Only used when starting Vim on an empty file, without a file name.\n * Or with the \":intro\" command (for Sven :-).\n */\n    static void\nintro_message(\n    int\t\tcolon)\t\t// TRUE for \":intro\"\n{\n    int\t\ti;\n    int\t\trow;\n    int\t\tblanklines;\n    int\t\tsponsor;\n    char\t*p;\n    static char\t*(lines[]) =\n    {\n\tN_(\"VIM - Vi IMproved\"),\n\t\"\",\n\tN_(\"version \"),\n\tN_(\"by Bram Moolenaar et al.\"),\n#ifdef MODIFIED_BY\n\t\" \",\n#endif\n\tN_(\"Vim is open source and freely distributable\"),\n\t\"\",\n\tN_(\"Help poor children in Uganda!\"),\n\tN_(\"type  :help iccf<Enter>       for information \"),\n\t\"\",\n\tN_(\"type  :q<Enter>               to exit         \"),\n\tN_(\"type  :help<Enter>  or  <F1>  for on-line help\"),\n\tN_(\"type  :help version9<Enter>   for version info\"),\n\tNULL,\n\t\"\",\n\tN_(\"Running in Vi compatible mode\"),\n\tN_(\"type  :set nocp<Enter>        for Vim defaults\"),\n\tN_(\"type  :help cp-default<Enter> for info on this\"),\n    };\n#ifdef FEAT_GUI\n    static char\t*(gui_lines[]) =\n    {\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n#ifdef MODIFIED_BY\n\tNULL,\n#endif\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Help->Orphans           for information    \"),\n\tNULL,\n\tN_(\"Running modeless, typed text is inserted\"),\n\tN_(\"menu  Edit->Global Settings->Toggle Insert Mode  \"),\n\tN_(\"                              for two modes      \"),\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Edit->Global Settings->Toggle Vi Compatible\"),\n\tN_(\"                              for Vim defaults   \"),\n    };\n#endif\n\n    // blanklines = screen height - # message lines\n    blanklines = (int)Rows - (ARRAY_LENGTH(lines) - 1);\n    if (!p_cp)\n\tblanklines += 4;  // add 4 for not showing \"Vi compatible\" message\n\n    // Don't overwrite a statusline.  Depends on 'cmdheight'.\n    if (p_ls > 1)\n\tblanklines -= Rows - topframe->fr_height;\n    if (blanklines < 0)\n\tblanklines = 0;\n\n    // Show the sponsor and register message one out of four times, the Uganda\n    // message two out of four times.\n    sponsor = (int)time(NULL);\n    sponsor = ((sponsor & 2) == 0) - ((sponsor & 4) == 0);\n\n    // start displaying the message lines after half of the blank lines\n    row = blanklines / 2;\n    if ((row >= 2 && Columns >= 50) || colon)\n    {\n\tfor (i = 0; i < (int)ARRAY_LENGTH(lines); ++i)\n\t{\n\t    p = lines[i];\n#ifdef FEAT_GUI\n\t    if (p_im && gui.in_use && gui_lines[i] != NULL)\n\t\tp = gui_lines[i];\n#endif\n\t    if (p == NULL)\n\t    {\n\t\tif (!p_cp)\n\t\t    break;\n\t\tcontinue;\n\t    }\n\t    if (sponsor != 0)\n\t    {\n\t\tif (strstr(p, \"children\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"Sponsor Vim development!\")\n\t\t\t: N_(\"Become a registered Vim user!\");\n\t\telse if (strstr(p, \"iccf\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"type  :help sponsor<Enter>    for information \")\n\t\t\t: N_(\"type  :help register<Enter>   for information \");\n\t\telse if (strstr(p, \"Orphans\") != NULL)\n\t\t    p = N_(\"menu  Help->Sponsor/Register  for information    \");\n\t    }\n\t    if (*p != NUL)\n\t\tdo_intro_line(row, (char_u *)_(p), i == 2, 0);\n\t    ++row;\n\t}\n    }\n\n    // Make the wait-return message appear just below the text.\n    if (colon)\n\tmsg_row = row;\n}\n\n    static void\ndo_intro_line(\n    int\t\trow,\n    char_u\t*mesg,\n    int\t\tadd_version,\n    int\t\tattr)\n{\n    char_u\tvers[20];\n    int\t\tcol;\n    char_u\t*p;\n    int\t\tl;\n    int\t\tclen;\n#ifdef MODIFIED_BY\n# define MODBY_LEN 150\n    char_u\tmodby[MODBY_LEN];\n\n    if (*mesg == ' ')\n    {\n\tvim_strncpy(modby, (char_u *)_(\"Modified by \"), MODBY_LEN - 1);\n\tl = (int)STRLEN(modby);\n\tvim_strncpy(modby + l, (char_u *)MODIFIED_BY, MODBY_LEN - l - 1);\n\tmesg = modby;\n    }\n#endif\n\n    // Center the message horizontally.\n    col = vim_strsize(mesg);\n    if (add_version)\n    {\n\tSTRCPY(vers, mediumVersion);\n\tif (highest_patch())\n\t{\n\t    // Check for 9.9x or 9.9xx, alpha/beta version\n\t    if (isalpha((int)vers[3]))\n\t    {\n\t\tint len = (isalpha((int)vers[4])) ? 5 : 4;\n\t\tsprintf((char *)vers + len, \".%d%s\", highest_patch(),\n\t\t\t\t\t\t\t mediumVersion + len);\n\t    }\n\t    else\n\t\tsprintf((char *)vers + 3, \".%d\", highest_patch());\n\t}\n\tcol += (int)STRLEN(vers);\n    }\n    col = (Columns - col) / 2;\n    if (col < 0)\n\tcol = 0;\n\n    // Split up in parts to highlight <> items differently.\n    for (p = mesg; *p != NUL; p += l)\n    {\n\tclen = 0;\n\tfor (l = 0; p[l] != NUL\n\t\t\t && (l == 0 || (p[l] != '<' && p[l - 1] != '>')); ++l)\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tclen += ptr2cells(p + l);\n\t\tl += (*mb_ptr2len)(p + l) - 1;\n\t    }\n\t    else\n\t\tclen += byte2cells(p[l]);\n\t}\n\tscreen_puts_len(p, l, row, col, *p == '<' ? HL_ATTR(HLF_8) : attr);\n\tcol += clen;\n    }\n\n    // Add the version number to the version line.\n    if (add_version)\n\tscreen_puts(vers, row, col, 0);\n}\n\n/*\n * \":intro\": clear screen, display intro screen and wait for return.\n */\n    void\nex_intro(exarg_T *eap UNUSED)\n{\n    screenclear();\n    intro_message(TRUE);\n    wait_return(TRUE);\n}\n"], "fixing_code": ["/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * Handling of regular expressions: vim_regcomp(), vim_regexec(), vim_regsub()\n */\n\n// By default: do not create debugging logs or files related to regular\n// expressions, even when compiling with -DDEBUG.\n// Uncomment the second line to get the regexp debugging.\n#undef DEBUG\n// #define DEBUG\n\n#include \"vim.h\"\n\n#ifdef DEBUG\n// show/save debugging data when BT engine is used\n# define BT_REGEXP_DUMP\n// save the debugging data to a file instead of displaying it\n# define BT_REGEXP_LOG\n# define BT_REGEXP_DEBUG_LOG\n# define BT_REGEXP_DEBUG_LOG_NAME\t\"bt_regexp_debug.log\"\n#endif\n\n#ifdef FEAT_RELTIME\nstatic sig_atomic_t dummy_timeout_flag = 0;\nstatic volatile sig_atomic_t *timeout_flag = &dummy_timeout_flag;\n#endif\n\n/*\n * Magic characters have a special meaning, they don't match literally.\n * Magic characters are negative.  This separates them from literal characters\n * (possibly multi-byte).  Only ASCII characters can be Magic.\n */\n#define Magic(x)\t((int)(x) - 256)\n#define un_Magic(x)\t((x) + 256)\n#define is_Magic(x)\t((x) < 0)\n\n    static int\nno_Magic(int x)\n{\n    if (is_Magic(x))\n\treturn un_Magic(x);\n    return x;\n}\n\n    static int\ntoggle_Magic(int x)\n{\n    if (is_Magic(x))\n\treturn un_Magic(x);\n    return Magic(x);\n}\n\n#ifdef FEAT_RELTIME\nstatic int timeout_nesting = 0;\n\n/*\n * Start a timer that will cause the regexp to abort after \"msec\".\n * This doesn't work well recursively.  In case it happens anyway, the first\n * set timeout will prevail, nested ones are ignored.\n * The caller must make sure there is a matching disable_regexp_timeout() call!\n */\n    void\ninit_regexp_timeout(long msec)\n{\n    if (timeout_nesting == 0)\n\ttimeout_flag = start_timeout(msec);\n    ++timeout_nesting;\n}\n\n    void\ndisable_regexp_timeout(void)\n{\n    if (timeout_nesting == 0)\n\tiemsg(\"disable_regexp_timeout() called without active timer\");\n    else if (--timeout_nesting == 0)\n    {\n\tstop_timeout();\n\ttimeout_flag = &dummy_timeout_flag;\n    }\n}\n#endif\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n# ifdef FEAT_RELTIME\nstatic sig_atomic_t *saved_timeout_flag;\n# endif\n\n/*\n * Used at the debug prompt: disable the timeout so that expression evaluation\n * can used patterns.\n * Must be followed by calling restore_timeout_for_debugging().\n */\n    void\nsave_timeout_for_debugging(void)\n{\n# ifdef FEAT_RELTIME\n    saved_timeout_flag = (sig_atomic_t *)timeout_flag;\n    timeout_flag = &dummy_timeout_flag;\n# endif\n}\n\n    void\nrestore_timeout_for_debugging(void)\n{\n# ifdef FEAT_RELTIME\n    timeout_flag = saved_timeout_flag;\n# endif\n}\n#endif\n\n/*\n * The first byte of the BT regexp internal \"program\" is actually this magic\n * number; the start node begins in the second byte.  It's used to catch the\n * most severe mutilation of the program by the caller.\n */\n\n#define REGMAGIC\t0234\n\n/*\n * Utility definitions.\n */\n#define UCHARAT(p)\t((int)*(char_u *)(p))\n\n// Used for an error (down from) vim_regcomp(): give the error message, set\n// rc_did_emsg and return NULL\n#define EMSG_RET_NULL(m) return (emsg((m)), rc_did_emsg = TRUE, (void *)NULL)\n#define IEMSG_RET_NULL(m) return (iemsg((m)), rc_did_emsg = TRUE, (void *)NULL)\n#define EMSG_RET_FAIL(m) return (emsg((m)), rc_did_emsg = TRUE, FAIL)\n#define EMSG2_RET_NULL(m, c) return (semsg((const char *)(m), (c) ? \"\" : \"\\\\\"), rc_did_emsg = TRUE, (void *)NULL)\n#define EMSG3_RET_NULL(m, c, a) return (semsg((const char *)(m), (c) ? \"\" : \"\\\\\", (a)), rc_did_emsg = TRUE, (void *)NULL)\n#define EMSG2_RET_FAIL(m, c) return (semsg((const char *)(m), (c) ? \"\" : \"\\\\\"), rc_did_emsg = TRUE, FAIL)\n#define EMSG_ONE_RET_NULL EMSG2_RET_NULL(_(e_invalid_item_in_str_brackets), reg_magic == MAGIC_ALL)\n\n\n#define MAX_LIMIT\t(32767L << 16L)\n\n#define NOT_MULTI\t0\n#define MULTI_ONE\t1\n#define MULTI_MULT\t2\n\n// return values for regmatch()\n#define RA_FAIL\t\t1\t// something failed, abort\n#define RA_CONT\t\t2\t// continue in inner loop\n#define RA_BREAK\t3\t// break inner loop\n#define RA_MATCH\t4\t// successful match\n#define RA_NOMATCH\t5\t// didn't match\n\n/*\n * Return NOT_MULTI if c is not a \"multi\" operator.\n * Return MULTI_ONE if c is a single \"multi\" operator.\n * Return MULTI_MULT if c is a multi \"multi\" operator.\n */\n    static int\nre_multi_type(int c)\n{\n    if (c == Magic('@') || c == Magic('=') || c == Magic('?'))\n\treturn MULTI_ONE;\n    if (c == Magic('*') || c == Magic('+') || c == Magic('{'))\n\treturn MULTI_MULT;\n    return NOT_MULTI;\n}\n\nstatic char_u\t\t*reg_prev_sub = NULL;\n\n/*\n * REGEXP_INRANGE contains all characters which are always special in a []\n * range after '\\'.\n * REGEXP_ABBR contains all characters which act as abbreviations after '\\'.\n * These are:\n *  \\n\t- New line (NL).\n *  \\r\t- Carriage Return (CR).\n *  \\t\t- Tab (TAB).\n *  \\e\t- Escape (ESC).\n *  \\b\t- Backspace (Ctrl_H).\n *  \\d  - Character code in decimal, eg \\d123\n *  \\o\t- Character code in octal, eg \\o80\n *  \\x\t- Character code in hex, eg \\x4a\n *  \\u\t- Multibyte character code, eg \\u20ac\n *  \\U\t- Long multibyte character code, eg \\U12345678\n */\nstatic char_u REGEXP_INRANGE[] = \"]^-n\\\\\";\nstatic char_u REGEXP_ABBR[] = \"nrtebdoxuU\";\n\n/*\n * Translate '\\x' to its control character, except \"\\n\", which is Magic.\n */\n    static int\nbackslash_trans(int c)\n{\n    switch (c)\n    {\n\tcase 'r':   return CAR;\n\tcase 't':   return TAB;\n\tcase 'e':   return ESC;\n\tcase 'b':   return BS;\n    }\n    return c;\n}\n\n/*\n * Check for a character class name \"[:name:]\".  \"pp\" points to the '['.\n * Returns one of the CLASS_ items. CLASS_NONE means that no item was\n * recognized.  Otherwise \"pp\" is advanced to after the item.\n */\n    static int\nget_char_class(char_u **pp)\n{\n    static const char *(class_names[]) =\n    {\n\t\"alnum:]\",\n#define CLASS_ALNUM 0\n\t\"alpha:]\",\n#define CLASS_ALPHA 1\n\t\"blank:]\",\n#define CLASS_BLANK 2\n\t\"cntrl:]\",\n#define CLASS_CNTRL 3\n\t\"digit:]\",\n#define CLASS_DIGIT 4\n\t\"graph:]\",\n#define CLASS_GRAPH 5\n\t\"lower:]\",\n#define CLASS_LOWER 6\n\t\"print:]\",\n#define CLASS_PRINT 7\n\t\"punct:]\",\n#define CLASS_PUNCT 8\n\t\"space:]\",\n#define CLASS_SPACE 9\n\t\"upper:]\",\n#define CLASS_UPPER 10\n\t\"xdigit:]\",\n#define CLASS_XDIGIT 11\n\t\"tab:]\",\n#define CLASS_TAB 12\n\t\"return:]\",\n#define CLASS_RETURN 13\n\t\"backspace:]\",\n#define CLASS_BACKSPACE 14\n\t\"escape:]\",\n#define CLASS_ESCAPE 15\n\t\"ident:]\",\n#define CLASS_IDENT 16\n\t\"keyword:]\",\n#define CLASS_KEYWORD 17\n\t\"fname:]\",\n#define CLASS_FNAME 18\n    };\n#define CLASS_NONE 99\n    int i;\n\n    if ((*pp)[1] == ':')\n    {\n\tfor (i = 0; i < (int)ARRAY_LENGTH(class_names); ++i)\n\t    if (STRNCMP(*pp + 2, class_names[i], STRLEN(class_names[i])) == 0)\n\t    {\n\t\t*pp += STRLEN(class_names[i]) + 2;\n\t\treturn i;\n\t    }\n    }\n    return CLASS_NONE;\n}\n\n/*\n * Specific version of character class functions.\n * Using a table to keep this fast.\n */\nstatic short\tclass_tab[256];\n\n#define\t    RI_DIGIT\t0x01\n#define\t    RI_HEX\t0x02\n#define\t    RI_OCTAL\t0x04\n#define\t    RI_WORD\t0x08\n#define\t    RI_HEAD\t0x10\n#define\t    RI_ALPHA\t0x20\n#define\t    RI_LOWER\t0x40\n#define\t    RI_UPPER\t0x80\n#define\t    RI_WHITE\t0x100\n\n    static void\ninit_class_tab(void)\n{\n    int\t\ti;\n    static int\tdone = FALSE;\n\n    if (done)\n\treturn;\n\n    for (i = 0; i < 256; ++i)\n    {\n\tif (i >= '0' && i <= '7')\n\t    class_tab[i] = RI_DIGIT + RI_HEX + RI_OCTAL + RI_WORD;\n\telse if (i >= '8' && i <= '9')\n\t    class_tab[i] = RI_DIGIT + RI_HEX + RI_WORD;\n\telse if (i >= 'a' && i <= 'f')\n\t    class_tab[i] = RI_HEX + RI_WORD + RI_HEAD + RI_ALPHA + RI_LOWER;\n\telse if (i >= 'g' && i <= 'z')\n\t    class_tab[i] = RI_WORD + RI_HEAD + RI_ALPHA + RI_LOWER;\n\telse if (i >= 'A' && i <= 'F')\n\t    class_tab[i] = RI_HEX + RI_WORD + RI_HEAD + RI_ALPHA + RI_UPPER;\n\telse if (i >= 'G' && i <= 'Z')\n\t    class_tab[i] = RI_WORD + RI_HEAD + RI_ALPHA + RI_UPPER;\n\telse if (i == '_')\n\t    class_tab[i] = RI_WORD + RI_HEAD;\n\telse\n\t    class_tab[i] = 0;\n    }\n    class_tab[' '] |= RI_WHITE;\n    class_tab['\\t'] |= RI_WHITE;\n    done = TRUE;\n}\n\n#define ri_digit(c)\t((c) < 0x100 && (class_tab[c] & RI_DIGIT))\n#define ri_hex(c)\t((c) < 0x100 && (class_tab[c] & RI_HEX))\n#define ri_octal(c)\t((c) < 0x100 && (class_tab[c] & RI_OCTAL))\n#define ri_word(c)\t((c) < 0x100 && (class_tab[c] & RI_WORD))\n#define ri_head(c)\t((c) < 0x100 && (class_tab[c] & RI_HEAD))\n#define ri_alpha(c)\t((c) < 0x100 && (class_tab[c] & RI_ALPHA))\n#define ri_lower(c)\t((c) < 0x100 && (class_tab[c] & RI_LOWER))\n#define ri_upper(c)\t((c) < 0x100 && (class_tab[c] & RI_UPPER))\n#define ri_white(c)\t((c) < 0x100 && (class_tab[c] & RI_WHITE))\n\n// flags for regflags\n#define RF_ICASE    1\t// ignore case\n#define RF_NOICASE  2\t// don't ignore case\n#define RF_HASNL    4\t// can match a NL\n#define RF_ICOMBINE 8\t// ignore combining characters\n#define RF_LOOKBH   16\t// uses \"\\@<=\" or \"\\@<!\"\n\n/*\n * Global work variables for vim_regcomp().\n */\n\nstatic char_u\t*regparse;\t// Input-scan pointer.\nstatic int\tregnpar;\t// () count.\nstatic int\twants_nfa;\t// regex should use NFA engine\n#ifdef FEAT_SYN_HL\nstatic int\tregnzpar;\t// \\z() count.\nstatic int\tre_has_z;\t// \\z item detected\n#endif\nstatic unsigned\tregflags;\t// RF_ flags for prog\n#if defined(FEAT_SYN_HL) || defined(PROTO)\nstatic int\thad_eol;\t// TRUE when EOL found by vim_regcomp()\n#endif\n\nstatic magic_T\treg_magic;\t// magicness of the pattern\n\nstatic int\treg_string;\t// matching with a string instead of a buffer\n\t\t\t\t// line\nstatic int\treg_strict;\t// \"[abc\" is illegal\n\n/*\n * META contains all characters that may be magic, except '^' and '$'.\n */\n\n// META[] is used often enough to justify turning it into a table.\nstatic char_u META_flags[] = {\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n//\t\t   %  &     (  )  *  +\t      .\n    0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 1, 0,\n//     1  2  3\t4  5  6  7  8  9\t<  =  >  ?\n    0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1,\n//  @  A     C\tD     F     H  I     K\tL  M\t O\n    1, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 0, 1,\n//  P\t     S\t   U  V  W  X\t  Z  [\t\t _\n    1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1,\n//     a     c\td     f     h  i     k\tl  m  n  o\n    0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1,\n//  p\t     s\t   u  v  w  x\t  z  {\t|     ~\n    1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1\n};\n\nstatic int\tcurchr;\t\t// currently parsed character\n// Previous character.  Note: prevchr is sometimes -1 when we are not at the\n// start, eg in /[ ^I]^ the pattern was never found even if it existed,\n// because ^ was taken to be magic -- webb\nstatic int\tprevchr;\nstatic int\tprevprevchr;\t// previous-previous character\nstatic int\tnextchr;\t// used for ungetchr()\n\n// arguments for reg()\n#define REG_NOPAREN\t0\t// toplevel reg()\n#define REG_PAREN\t1\t// \\(\\)\n#define REG_ZPAREN\t2\t// \\z(\\)\n#define REG_NPAREN\t3\t// \\%(\\)\n\ntypedef struct\n{\n     char_u\t*regparse;\n     int\tprevchr_len;\n     int\tcurchr;\n     int\tprevchr;\n     int\tprevprevchr;\n     int\tnextchr;\n     int\tat_start;\n     int\tprev_at_start;\n     int\tregnpar;\n} parse_state_T;\n\nstatic void\tinitchr(char_u *);\nstatic int\tgetchr(void);\nstatic void\tskipchr_keepstart(void);\nstatic int\tpeekchr(void);\nstatic void\tskipchr(void);\nstatic void\tungetchr(void);\nstatic long\tgethexchrs(int maxinputlen);\nstatic long\tgetoctchrs(void);\nstatic long\tgetdecchrs(void);\nstatic int\tcoll_get_char(void);\nstatic int\tprog_magic_wrong(void);\nstatic int\tcstrncmp(char_u *s1, char_u *s2, int *n);\nstatic char_u\t*cstrchr(char_u *, int);\nstatic int\tre_mult_next(char *what);\nstatic int\treg_iswordc(int);\n#ifdef FEAT_EVAL\nstatic void report_re_switch(char_u *pat);\n#endif\n\nstatic regengine_T bt_regengine;\nstatic regengine_T nfa_regengine;\n\n/*\n * Return TRUE if compiled regular expression \"prog\" can match a line break.\n */\n    int\nre_multiline(regprog_T *prog)\n{\n    return (prog->regflags & RF_HASNL);\n}\n\n/*\n * Check for an equivalence class name \"[=a=]\".  \"pp\" points to the '['.\n * Returns a character representing the class. Zero means that no item was\n * recognized.  Otherwise \"pp\" is advanced to after the item.\n */\n    static int\nget_equi_class(char_u **pp)\n{\n    int\t\tc;\n    int\t\tl = 1;\n    char_u\t*p = *pp;\n\n    if (p[1] == '=' && p[2] != NUL)\n    {\n\tif (has_mbyte)\n\t    l = (*mb_ptr2len)(p + 2);\n\tif (p[l + 2] == '=' && p[l + 3] == ']')\n\t{\n\t    if (has_mbyte)\n\t\tc = mb_ptr2char(p + 2);\n\t    else\n\t\tc = p[2];\n\t    *pp += l + 4;\n\t    return c;\n\t}\n    }\n    return 0;\n}\n\n/*\n * Check for a collating element \"[.a.]\".  \"pp\" points to the '['.\n * Returns a character. Zero means that no item was recognized.  Otherwise\n * \"pp\" is advanced to after the item.\n * Currently only single characters are recognized!\n */\n    static int\nget_coll_element(char_u **pp)\n{\n    int\t\tc;\n    int\t\tl = 1;\n    char_u\t*p = *pp;\n\n    if (p[0] != NUL && p[1] == '.' && p[2] != NUL)\n    {\n\tif (has_mbyte)\n\t    l = (*mb_ptr2len)(p + 2);\n\tif (p[l + 2] == '.' && p[l + 3] == ']')\n\t{\n\t    if (has_mbyte)\n\t\tc = mb_ptr2char(p + 2);\n\t    else\n\t\tc = p[2];\n\t    *pp += l + 4;\n\t    return c;\n\t}\n    }\n    return 0;\n}\n\nstatic int reg_cpo_lit; // 'cpoptions' contains 'l' flag\nstatic int reg_cpo_bsl; // 'cpoptions' contains '\\' flag\n\n    static void\nget_cpo_flags(void)\n{\n    reg_cpo_lit = vim_strchr(p_cpo, CPO_LITERAL) != NULL;\n    reg_cpo_bsl = vim_strchr(p_cpo, CPO_BACKSL) != NULL;\n}\n\n/*\n * Skip over a \"[]\" range.\n * \"p\" must point to the character after the '['.\n * The returned pointer is on the matching ']', or the terminating NUL.\n */\n    static char_u *\nskip_anyof(char_u *p)\n{\n    int\t\tl;\n\n    if (*p == '^')\t// Complement of range.\n\t++p;\n    if (*p == ']' || *p == '-')\n\t++p;\n    while (*p != NUL && *p != ']')\n    {\n\tif (has_mbyte && (l = (*mb_ptr2len)(p)) > 1)\n\t    p += l;\n\telse\n\t    if (*p == '-')\n\t    {\n\t\t++p;\n\t\tif (*p != ']' && *p != NUL)\n\t\t    MB_PTR_ADV(p);\n\t    }\n\telse if (*p == '\\\\'\n\t\t&& !reg_cpo_bsl\n\t\t&& (vim_strchr(REGEXP_INRANGE, p[1]) != NULL\n\t\t    || (!reg_cpo_lit && vim_strchr(REGEXP_ABBR, p[1]) != NULL)))\n\t    p += 2;\n\telse if (*p == '[')\n\t{\n\t    if (get_char_class(&p) == CLASS_NONE\n\t\t    && get_equi_class(&p) == 0\n\t\t    && get_coll_element(&p) == 0\n\t\t    && *p != NUL)\n\t\t++p; // it is not a class name and not NUL\n\t}\n\telse\n\t    ++p;\n    }\n\n    return p;\n}\n\n/*\n * Skip past regular expression.\n * Stop at end of \"startp\" or where \"delim\" is found ('/', '?', etc).\n * Take care of characters with a backslash in front of it.\n * Skip strings inside [ and ].\n */\n    char_u *\nskip_regexp(\n    char_u\t*startp,\n    int\t\tdelim,\n    int\t\tmagic)\n{\n    return skip_regexp_ex(startp, delim, magic, NULL, NULL, NULL);\n}\n\n/*\n * Call skip_regexp() and when the delimiter does not match give an error and\n * return NULL.\n */\n    char_u *\nskip_regexp_err(\n    char_u\t*startp,\n    int\t\tdelim,\n    int\t\tmagic)\n{\n    char_u *p = skip_regexp(startp, delim, magic);\n\n    if (*p != delim)\n    {\n\tsemsg(_(e_missing_delimiter_after_search_pattern_str), startp);\n\treturn NULL;\n    }\n    return p;\n}\n\n/*\n * skip_regexp() with extra arguments:\n * When \"newp\" is not NULL and \"dirc\" is '?', make an allocated copy of the\n * expression and change \"\\?\" to \"?\".  If \"*newp\" is not NULL the expression\n * is changed in-place.\n * If a \"\\?\" is changed to \"?\" then \"dropped\" is incremented, unless NULL.\n * If \"magic_val\" is not NULL, returns the effective magicness of the pattern\n */\n    char_u *\nskip_regexp_ex(\n    char_u\t*startp,\n    int\t\tdirc,\n    int\t\tmagic,\n    char_u\t**newp,\n    int\t\t*dropped,\n    magic_T\t*magic_val)\n{\n    magic_T\tmymagic;\n    char_u\t*p = startp;\n\n    if (magic)\n\tmymagic = MAGIC_ON;\n    else\n\tmymagic = MAGIC_OFF;\n    get_cpo_flags();\n\n    for (; p[0] != NUL; MB_PTR_ADV(p))\n    {\n\tif (p[0] == dirc)\t// found end of regexp\n\t    break;\n\tif ((p[0] == '[' && mymagic >= MAGIC_ON)\n\t\t|| (p[0] == '\\\\' && p[1] == '[' && mymagic <= MAGIC_OFF))\n\t{\n\t    p = skip_anyof(p + 1);\n\t    if (p[0] == NUL)\n\t\tbreak;\n\t}\n\telse if (p[0] == '\\\\' && p[1] != NUL)\n\t{\n\t    if (dirc == '?' && newp != NULL && p[1] == '?')\n\t    {\n\t\t// change \"\\?\" to \"?\", make a copy first.\n\t\tif (*newp == NULL)\n\t\t{\n\t\t    *newp = vim_strsave(startp);\n\t\t    if (*newp != NULL)\n\t\t\tp = *newp + (p - startp);\n\t\t}\n\t\tif (dropped != NULL)\n\t\t    ++*dropped;\n\t\tif (*newp != NULL)\n\t\t    STRMOVE(p, p + 1);\n\t\telse\n\t\t    ++p;\n\t    }\n\t    else\n\t\t++p;    // skip next character\n\t    if (*p == 'v')\n\t\tmymagic = MAGIC_ALL;\n\t    else if (*p == 'V')\n\t\tmymagic = MAGIC_NONE;\n\t}\n    }\n    if (magic_val != NULL)\n\t*magic_val = mymagic;\n    return p;\n}\n\n/*\n * Functions for getting characters from the regexp input.\n */\nstatic int\tprevchr_len;\t// byte length of previous char\nstatic int\tat_start;\t// True when on the first character\nstatic int\tprev_at_start;  // True when on the second character\n\n/*\n * Start parsing at \"str\".\n */\n    static void\ninitchr(char_u *str)\n{\n    regparse = str;\n    prevchr_len = 0;\n    curchr = prevprevchr = prevchr = nextchr = -1;\n    at_start = TRUE;\n    prev_at_start = FALSE;\n}\n\n/*\n * Save the current parse state, so that it can be restored and parsing\n * starts in the same state again.\n */\n    static void\nsave_parse_state(parse_state_T *ps)\n{\n    ps->regparse = regparse;\n    ps->prevchr_len = prevchr_len;\n    ps->curchr = curchr;\n    ps->prevchr = prevchr;\n    ps->prevprevchr = prevprevchr;\n    ps->nextchr = nextchr;\n    ps->at_start = at_start;\n    ps->prev_at_start = prev_at_start;\n    ps->regnpar = regnpar;\n}\n\n/*\n * Restore a previously saved parse state.\n */\n    static void\nrestore_parse_state(parse_state_T *ps)\n{\n    regparse = ps->regparse;\n    prevchr_len = ps->prevchr_len;\n    curchr = ps->curchr;\n    prevchr = ps->prevchr;\n    prevprevchr = ps->prevprevchr;\n    nextchr = ps->nextchr;\n    at_start = ps->at_start;\n    prev_at_start = ps->prev_at_start;\n    regnpar = ps->regnpar;\n}\n\n\n/*\n * Get the next character without advancing.\n */\n    static int\npeekchr(void)\n{\n    static int\tafter_slash = FALSE;\n\n    if (curchr != -1)\n\treturn curchr;\n\n    switch (curchr = regparse[0])\n    {\n\tcase '.':\n\tcase '[':\n\tcase '~':\n\t    // magic when 'magic' is on\n\t    if (reg_magic >= MAGIC_ON)\n\t\tcurchr = Magic(curchr);\n\t    break;\n\tcase '(':\n\tcase ')':\n\tcase '{':\n\tcase '%':\n\tcase '+':\n\tcase '=':\n\tcase '?':\n\tcase '@':\n\tcase '!':\n\tcase '&':\n\tcase '|':\n\tcase '<':\n\tcase '>':\n\tcase '#':\t// future ext.\n\tcase '\"':\t// future ext.\n\tcase '\\'':\t// future ext.\n\tcase ',':\t// future ext.\n\tcase '-':\t// future ext.\n\tcase ':':\t// future ext.\n\tcase ';':\t// future ext.\n\tcase '`':\t// future ext.\n\tcase '/':\t// Can't be used in / command\n\t\t\t// magic only after \"\\v\"\n\t    if (reg_magic == MAGIC_ALL)\n\t\tcurchr = Magic(curchr);\n\t    break;\n\tcase '*':\n\t    // * is not magic as the very first character, eg \"?*ptr\", when\n\t    // after '^', eg \"/^*ptr\" and when after \"\\(\", \"\\|\", \"\\&\".  But\n\t    // \"\\(\\*\" is not magic, thus must be magic if \"after_slash\"\n\t    if (reg_magic >= MAGIC_ON\n\t\t    && !at_start\n\t\t    && !(prev_at_start && prevchr == Magic('^'))\n\t\t    && (after_slash\n\t\t\t|| (prevchr != Magic('(')\n\t\t\t    && prevchr != Magic('&')\n\t\t\t    && prevchr != Magic('|'))))\n\t\tcurchr = Magic('*');\n\t    break;\n\tcase '^':\n\t    // '^' is only magic as the very first character and if it's after\n\t    // \"\\(\", \"\\|\", \"\\&' or \"\\n\"\n\t    if (reg_magic >= MAGIC_OFF\n\t\t    && (at_start\n\t\t\t|| reg_magic == MAGIC_ALL\n\t\t\t|| prevchr == Magic('(')\n\t\t\t|| prevchr == Magic('|')\n\t\t\t|| prevchr == Magic('&')\n\t\t\t|| prevchr == Magic('n')\n\t\t\t|| (no_Magic(prevchr) == '('\n\t\t\t    && prevprevchr == Magic('%'))))\n\t    {\n\t\tcurchr = Magic('^');\n\t\tat_start = TRUE;\n\t\tprev_at_start = FALSE;\n\t    }\n\t    break;\n\tcase '$':\n\t    // '$' is only magic as the very last char and if it's in front of\n\t    // either \"\\|\", \"\\)\", \"\\&\", or \"\\n\"\n\t    if (reg_magic >= MAGIC_OFF)\n\t    {\n\t\tchar_u *p = regparse + 1;\n\t\tint is_magic_all = (reg_magic == MAGIC_ALL);\n\n\t\t// ignore \\c \\C \\m \\M \\v \\V and \\Z after '$'\n\t\twhile (p[0] == '\\\\' && (p[1] == 'c' || p[1] == 'C'\n\t\t\t    || p[1] == 'm' || p[1] == 'M'\n\t\t\t    || p[1] == 'v' || p[1] == 'V' || p[1] == 'Z'))\n\t\t{\n\t\t    if (p[1] == 'v')\n\t\t\tis_magic_all = TRUE;\n\t\t    else if (p[1] == 'm' || p[1] == 'M' || p[1] == 'V')\n\t\t\tis_magic_all = FALSE;\n\t\t    p += 2;\n\t\t}\n\t\tif (p[0] == NUL\n\t\t\t|| (p[0] == '\\\\'\n\t\t\t    && (p[1] == '|' || p[1] == '&' || p[1] == ')'\n\t\t\t\t|| p[1] == 'n'))\n\t\t\t|| (is_magic_all\n\t\t\t    && (p[0] == '|' || p[0] == '&' || p[0] == ')'))\n\t\t\t|| reg_magic == MAGIC_ALL)\n\t\t    curchr = Magic('$');\n\t    }\n\t    break;\n\tcase '\\\\':\n\t    {\n\t\tint c = regparse[1];\n\n\t\tif (c == NUL)\n\t\t    curchr = '\\\\';\t// trailing '\\'\n\t\telse if (c <= '~' && META_flags[c])\n\t\t{\n\t\t    /*\n\t\t     * META contains everything that may be magic sometimes,\n\t\t     * except ^ and $ (\"\\^\" and \"\\$\" are only magic after\n\t\t     * \"\\V\").  We now fetch the next character and toggle its\n\t\t     * magicness.  Therefore, \\ is so meta-magic that it is\n\t\t     * not in META.\n\t\t     */\n\t\t    curchr = -1;\n\t\t    prev_at_start = at_start;\n\t\t    at_start = FALSE;\t// be able to say \"/\\*ptr\"\n\t\t    ++regparse;\n\t\t    ++after_slash;\n\t\t    peekchr();\n\t\t    --regparse;\n\t\t    --after_slash;\n\t\t    curchr = toggle_Magic(curchr);\n\t\t}\n\t\telse if (vim_strchr(REGEXP_ABBR, c))\n\t\t{\n\t\t    /*\n\t\t     * Handle abbreviations, like \"\\t\" for TAB -- webb\n\t\t     */\n\t\t    curchr = backslash_trans(c);\n\t\t}\n\t\telse if (reg_magic == MAGIC_NONE && (c == '$' || c == '^'))\n\t\t    curchr = toggle_Magic(c);\n\t\telse\n\t\t{\n\t\t    /*\n\t\t     * Next character can never be (made) magic?\n\t\t     * Then backslashing it won't do anything.\n\t\t     */\n\t\t    if (has_mbyte)\n\t\t\tcurchr = (*mb_ptr2char)(regparse + 1);\n\t\t    else\n\t\t\tcurchr = c;\n\t\t}\n\t\tbreak;\n\t    }\n\n\tdefault:\n\t    if (has_mbyte)\n\t\tcurchr = (*mb_ptr2char)(regparse);\n    }\n\n    return curchr;\n}\n\n/*\n * Eat one lexed character.  Do this in a way that we can undo it.\n */\n    static void\nskipchr(void)\n{\n    // peekchr() eats a backslash, do the same here\n    if (*regparse == '\\\\')\n\tprevchr_len = 1;\n    else\n\tprevchr_len = 0;\n    if (regparse[prevchr_len] != NUL)\n    {\n\tif (enc_utf8)\n\t    // exclude composing chars that mb_ptr2len does include\n\t    prevchr_len += utf_ptr2len(regparse + prevchr_len);\n\telse if (has_mbyte)\n\t    prevchr_len += (*mb_ptr2len)(regparse + prevchr_len);\n\telse\n\t    ++prevchr_len;\n    }\n    regparse += prevchr_len;\n    prev_at_start = at_start;\n    at_start = FALSE;\n    prevprevchr = prevchr;\n    prevchr = curchr;\n    curchr = nextchr;\t    // use previously unget char, or -1\n    nextchr = -1;\n}\n\n/*\n * Skip a character while keeping the value of prev_at_start for at_start.\n * prevchr and prevprevchr are also kept.\n */\n    static void\nskipchr_keepstart(void)\n{\n    int as = prev_at_start;\n    int pr = prevchr;\n    int prpr = prevprevchr;\n\n    skipchr();\n    at_start = as;\n    prevchr = pr;\n    prevprevchr = prpr;\n}\n\n/*\n * Get the next character from the pattern. We know about magic and such, so\n * therefore we need a lexical analyzer.\n */\n    static int\ngetchr(void)\n{\n    int chr = peekchr();\n\n    skipchr();\n    return chr;\n}\n\n/*\n * put character back.  Works only once!\n */\n    static void\nungetchr(void)\n{\n    nextchr = curchr;\n    curchr = prevchr;\n    prevchr = prevprevchr;\n    at_start = prev_at_start;\n    prev_at_start = FALSE;\n\n    // Backup regparse, so that it's at the same position as before the\n    // getchr().\n    regparse -= prevchr_len;\n}\n\n/*\n * Get and return the value of the hex string at the current position.\n * Return -1 if there is no valid hex number.\n * The position is updated:\n *     blahblah\\%x20asdf\n *\t   before-^ ^-after\n * The parameter controls the maximum number of input characters. This will be\n * 2 when reading a \\%x20 sequence and 4 when reading a \\%u20AC sequence.\n */\n    static long\ngethexchrs(int maxinputlen)\n{\n    long_u\tnr = 0;\n    int\t\tc;\n    int\t\ti;\n\n    for (i = 0; i < maxinputlen; ++i)\n    {\n\tc = regparse[0];\n\tif (!vim_isxdigit(c))\n\t    break;\n\tnr <<= 4;\n\tnr |= hex2nr(c);\n\t++regparse;\n    }\n\n    if (i == 0)\n\treturn -1;\n    return (long)nr;\n}\n\n/*\n * Get and return the value of the decimal string immediately after the\n * current position. Return -1 for invalid.  Consumes all digits.\n */\n    static long\ngetdecchrs(void)\n{\n    long_u\tnr = 0;\n    int\t\tc;\n    int\t\ti;\n\n    for (i = 0; ; ++i)\n    {\n\tc = regparse[0];\n\tif (c < '0' || c > '9')\n\t    break;\n\tnr *= 10;\n\tnr += c - '0';\n\t++regparse;\n\tcurchr = -1; // no longer valid\n    }\n\n    if (i == 0)\n\treturn -1;\n    return (long)nr;\n}\n\n/*\n * get and return the value of the octal string immediately after the current\n * position. Return -1 for invalid, or 0-255 for valid. Smart enough to handle\n * numbers > 377 correctly (for example, 400 is treated as 40) and doesn't\n * treat 8 or 9 as recognised characters. Position is updated:\n *     blahblah\\%o210asdf\n *\t   before-^  ^-after\n */\n    static long\ngetoctchrs(void)\n{\n    long_u\tnr = 0;\n    int\t\tc;\n    int\t\ti;\n\n    for (i = 0; i < 3 && nr < 040; ++i)\n    {\n\tc = regparse[0];\n\tif (c < '0' || c > '7')\n\t    break;\n\tnr <<= 3;\n\tnr |= hex2nr(c);\n\t++regparse;\n    }\n\n    if (i == 0)\n\treturn -1;\n    return (long)nr;\n}\n\n/*\n * read_limits - Read two integers to be taken as a minimum and maximum.\n * If the first character is '-', then the range is reversed.\n * Should end with 'end'.  If minval is missing, zero is default, if maxval is\n * missing, a very big number is the default.\n */\n    static int\nread_limits(long *minval, long *maxval)\n{\n    int\t\treverse = FALSE;\n    char_u\t*first_char;\n    long\ttmp;\n\n    if (*regparse == '-')\n    {\n\t// Starts with '-', so reverse the range later\n\tregparse++;\n\treverse = TRUE;\n    }\n    first_char = regparse;\n    *minval = getdigits(&regparse);\n    if (*regparse == ',')\t    // There is a comma\n    {\n\tif (vim_isdigit(*++regparse))\n\t    *maxval = getdigits(&regparse);\n\telse\n\t    *maxval = MAX_LIMIT;\n    }\n    else if (VIM_ISDIGIT(*first_char))\n\t*maxval = *minval;\t    // It was \\{n} or \\{-n}\n    else\n\t*maxval = MAX_LIMIT;\t    // It was \\{} or \\{-}\n    if (*regparse == '\\\\')\n\tregparse++;\t// Allow either \\{...} or \\{...\\}\n    if (*regparse != '}')\n\tEMSG2_RET_FAIL(_(e_syntax_error_in_str_curlies),\n\t\t\t\t\t\t       reg_magic == MAGIC_ALL);\n\n    /*\n     * Reverse the range if there was a '-', or make sure it is in the right\n     * order otherwise.\n     */\n    if ((!reverse && *minval > *maxval) || (reverse && *minval < *maxval))\n    {\n\ttmp = *minval;\n\t*minval = *maxval;\n\t*maxval = tmp;\n    }\n    skipchr();\t\t// let's be friends with the lexer again\n    return OK;\n}\n\n/*\n * vim_regexec and friends\n */\n\n/*\n * Global work variables for vim_regexec().\n */\n\nstatic void\tcleanup_subexpr(void);\n#ifdef FEAT_SYN_HL\nstatic void\tcleanup_zsubexpr(void);\n#endif\nstatic int\tmatch_with_backref(linenr_T start_lnum, colnr_T start_col, linenr_T end_lnum, colnr_T end_col, int *bytelen);\n\n/*\n * Sometimes need to save a copy of a line.  Since alloc()/free() is very\n * slow, we keep one allocated piece of memory and only re-allocate it when\n * it's too small.  It's freed in bt_regexec_both() when finished.\n */\nstatic char_u\t*reg_tofree = NULL;\nstatic unsigned\treg_tofreelen;\n\n/*\n * Structure used to store the execution state of the regex engine.\n * Which ones are set depends on whether a single-line or multi-line match is\n * done:\n *\t\t\tsingle-line\t\tmulti-line\n * reg_match\t\t&regmatch_T\t\tNULL\n * reg_mmatch\t\tNULL\t\t\t&regmmatch_T\n * reg_startp\t\treg_match->startp\t<invalid>\n * reg_endp\t\treg_match->endp\t\t<invalid>\n * reg_startpos\t\t<invalid>\t\treg_mmatch->startpos\n * reg_endpos\t\t<invalid>\t\treg_mmatch->endpos\n * reg_win\t\tNULL\t\t\twindow in which to search\n * reg_buf\t\tcurbuf\t\t\tbuffer in which to search\n * reg_firstlnum\t<invalid>\t\tfirst line in which to search\n * reg_maxline\t\t0\t\t\tlast line nr\n * reg_line_lbr\t\tFALSE or TRUE\t\tFALSE\n */\ntypedef struct {\n    regmatch_T\t\t*reg_match;\n    regmmatch_T\t\t*reg_mmatch;\n\n    char_u\t\t**reg_startp;\n    char_u\t\t**reg_endp;\n    lpos_T\t\t*reg_startpos;\n    lpos_T\t\t*reg_endpos;\n\n    win_T\t\t*reg_win;\n    buf_T\t\t*reg_buf;\n    linenr_T\t\treg_firstlnum;\n    linenr_T\t\treg_maxline;\n    int\t\t\treg_line_lbr;\t// \"\\n\" in string is line break\n\n    // The current match-position is stord in these variables:\n    linenr_T\tlnum;\t\t// line number, relative to first line\n    char_u\t*line;\t\t// start of current line\n    char_u\t*input;\t\t// current input, points into \"line\"\n\n    int\tneed_clear_subexpr;\t// subexpressions still need to be cleared\n#ifdef FEAT_SYN_HL\n    int\tneed_clear_zsubexpr;\t// extmatch subexpressions still need to be\n\t\t\t\t// cleared\n#endif\n\n    // Internal copy of 'ignorecase'.  It is set at each call to vim_regexec().\n    // Normally it gets the value of \"rm_ic\" or \"rmm_ic\", but when the pattern\n    // contains '\\c' or '\\C' the value is overruled.\n    int\t\t\treg_ic;\n\n    // Similar to \"reg_ic\", but only for 'combining' characters.  Set with \\Z\n    // flag in the regexp.  Defaults to false, always.\n    int\t\t\treg_icombine;\n\n    // Copy of \"rmm_maxcol\": maximum column to search for a match.  Zero when\n    // there is no maximum.\n    colnr_T\t\treg_maxcol;\n\n    // State for the NFA engine regexec.\n    int nfa_has_zend;\t    // NFA regexp \\ze operator encountered.\n    int nfa_has_backref;    // NFA regexp \\1 .. \\9 encountered.\n    int nfa_nsubexpr;\t    // Number of sub expressions actually being used\n\t\t\t    // during execution. 1 if only the whole match\n\t\t\t    // (subexpr 0) is used.\n    // listid is global, so that it increases on recursive calls to\n    // nfa_regmatch(), which means we don't have to clear the lastlist field of\n    // all the states.\n    int nfa_listid;\n    int nfa_alt_listid;\n\n#ifdef FEAT_SYN_HL\n    int nfa_has_zsubexpr;   // NFA regexp has \\z( ), set zsubexpr.\n#endif\n} regexec_T;\n\nstatic regexec_T\trex;\nstatic int\t\trex_in_use = FALSE;\n\n/*\n * Return TRUE if character 'c' is included in 'iskeyword' option for\n * \"reg_buf\" buffer.\n */\n    static int\nreg_iswordc(int c)\n{\n    return vim_iswordc_buf(c, rex.reg_buf);\n}\n\n/*\n * Get pointer to the line \"lnum\", which is relative to \"reg_firstlnum\".\n */\n    static char_u *\nreg_getline(linenr_T lnum)\n{\n    // when looking behind for a match/no-match lnum is negative.  But we\n    // can't go before line 1\n    if (rex.reg_firstlnum + lnum < 1)\n\treturn NULL;\n    if (lnum > rex.reg_maxline)\n\t// Must have matched the \"\\n\" in the last line.\n\treturn (char_u *)\"\";\n    return ml_get_buf(rex.reg_buf, rex.reg_firstlnum + lnum, FALSE);\n}\n\n#ifdef FEAT_SYN_HL\nstatic char_u\t*reg_startzp[NSUBEXP];\t// Workspace to mark beginning\nstatic char_u\t*reg_endzp[NSUBEXP];\t//   and end of \\z(...\\) matches\nstatic lpos_T\treg_startzpos[NSUBEXP];\t// idem, beginning pos\nstatic lpos_T\treg_endzpos[NSUBEXP];\t// idem, end pos\n#endif\n\n// TRUE if using multi-line regexp.\n#define REG_MULTI\t(rex.reg_match == NULL)\n\n#ifdef FEAT_SYN_HL\n/*\n * Create a new extmatch and mark it as referenced once.\n */\n    static reg_extmatch_T *\nmake_extmatch(void)\n{\n    reg_extmatch_T\t*em;\n\n    em = ALLOC_CLEAR_ONE(reg_extmatch_T);\n    if (em != NULL)\n\tem->refcnt = 1;\n    return em;\n}\n\n/*\n * Add a reference to an extmatch.\n */\n    reg_extmatch_T *\nref_extmatch(reg_extmatch_T *em)\n{\n    if (em != NULL)\n\tem->refcnt++;\n    return em;\n}\n\n/*\n * Remove a reference to an extmatch.  If there are no references left, free\n * the info.\n */\n    void\nunref_extmatch(reg_extmatch_T *em)\n{\n    int i;\n\n    if (em != NULL && --em->refcnt <= 0)\n    {\n\tfor (i = 0; i < NSUBEXP; ++i)\n\t    vim_free(em->matches[i]);\n\tvim_free(em);\n    }\n}\n#endif\n\n/*\n * Get class of previous character.\n */\n    static int\nreg_prev_class(void)\n{\n    if (rex.input > rex.line)\n\treturn mb_get_class_buf(rex.input - 1\n\t\t       - (*mb_head_off)(rex.line, rex.input - 1), rex.reg_buf);\n    return -1;\n}\n\n/*\n * Return TRUE if the current rex.input position matches the Visual area.\n */\n    static int\nreg_match_visual(void)\n{\n    pos_T\ttop, bot;\n    linenr_T    lnum;\n    colnr_T\tcol;\n    win_T\t*wp = rex.reg_win == NULL ? curwin : rex.reg_win;\n    int\t\tmode;\n    colnr_T\tstart, end;\n    colnr_T\tstart2, end2;\n    colnr_T\tcols;\n    colnr_T\tcurswant;\n\n    // Check if the buffer is the current buffer and not using a string.\n    if (rex.reg_buf != curbuf || VIsual.lnum == 0 || !REG_MULTI)\n\treturn FALSE;\n\n    if (VIsual_active)\n    {\n\tif (LT_POS(VIsual, wp->w_cursor))\n\t{\n\t    top = VIsual;\n\t    bot = wp->w_cursor;\n\t}\n\telse\n\t{\n\t    top = wp->w_cursor;\n\t    bot = VIsual;\n\t}\n\tmode = VIsual_mode;\n\tcurswant = wp->w_curswant;\n    }\n    else\n    {\n\tif (LT_POS(curbuf->b_visual.vi_start, curbuf->b_visual.vi_end))\n\t{\n\t    top = curbuf->b_visual.vi_start;\n\t    bot = curbuf->b_visual.vi_end;\n\t}\n\telse\n\t{\n\t    top = curbuf->b_visual.vi_end;\n\t    bot = curbuf->b_visual.vi_start;\n\t}\n\tmode = curbuf->b_visual.vi_mode;\n\tcurswant = curbuf->b_visual.vi_curswant;\n    }\n    lnum = rex.lnum + rex.reg_firstlnum;\n    if (lnum < top.lnum || lnum > bot.lnum)\n\treturn FALSE;\n\n    col = (colnr_T)(rex.input - rex.line);\n    if (mode == 'v')\n    {\n\tif ((lnum == top.lnum && col < top.col)\n\t\t|| (lnum == bot.lnum && col >= bot.col + (*p_sel != 'e')))\n\t    return FALSE;\n    }\n    else if (mode == Ctrl_V)\n    {\n\tgetvvcol(wp, &top, &start, NULL, &end);\n\tgetvvcol(wp, &bot, &start2, NULL, &end2);\n\tif (start2 < start)\n\t    start = start2;\n\tif (end2 > end)\n\t    end = end2;\n\tif (top.col == MAXCOL || bot.col == MAXCOL || curswant == MAXCOL)\n\t    end = MAXCOL;\n\n\t// getvvcol() flushes rex.line, need to get it again\n\trex.line = reg_getline(rex.lnum);\n\trex.input = rex.line + col;\n\n\tcols = win_linetabsize(wp, rex.reg_firstlnum + rex.lnum, rex.line, col);\n\tif (cols < start || cols > end - (*p_sel == 'e'))\n\t    return FALSE;\n    }\n    return TRUE;\n}\n\n/*\n * Check the regexp program for its magic number.\n * Return TRUE if it's wrong.\n */\n    static int\nprog_magic_wrong(void)\n{\n    regprog_T\t*prog;\n\n    prog = REG_MULTI ? rex.reg_mmatch->regprog : rex.reg_match->regprog;\n    if (prog->engine == &nfa_regengine)\n\t// For NFA matcher we don't check the magic\n\treturn FALSE;\n\n    if (UCHARAT(((bt_regprog_T *)prog)->program) != REGMAGIC)\n    {\n\temsg(_(e_corrupted_regexp_program));\n\treturn TRUE;\n    }\n    return FALSE;\n}\n\n/*\n * Cleanup the subexpressions, if this wasn't done yet.\n * This construction is used to clear the subexpressions only when they are\n * used (to increase speed).\n */\n    static void\ncleanup_subexpr(void)\n{\n    if (!rex.need_clear_subexpr)\n\treturn;\n\n    if (REG_MULTI)\n    {\n\t// Use 0xff to set lnum to -1\n\tvim_memset(rex.reg_startpos, 0xff, sizeof(lpos_T) * NSUBEXP);\n\tvim_memset(rex.reg_endpos, 0xff, sizeof(lpos_T) * NSUBEXP);\n    }\n    else\n    {\n\tvim_memset(rex.reg_startp, 0, sizeof(char_u *) * NSUBEXP);\n\tvim_memset(rex.reg_endp, 0, sizeof(char_u *) * NSUBEXP);\n    }\n    rex.need_clear_subexpr = FALSE;\n}\n\n#ifdef FEAT_SYN_HL\n    static void\ncleanup_zsubexpr(void)\n{\n    if (!rex.need_clear_zsubexpr)\n\treturn;\n\n    if (REG_MULTI)\n    {\n\t// Use 0xff to set lnum to -1\n\tvim_memset(reg_startzpos, 0xff, sizeof(lpos_T) * NSUBEXP);\n\tvim_memset(reg_endzpos, 0xff, sizeof(lpos_T) * NSUBEXP);\n    }\n    else\n    {\n\tvim_memset(reg_startzp, 0, sizeof(char_u *) * NSUBEXP);\n\tvim_memset(reg_endzp, 0, sizeof(char_u *) * NSUBEXP);\n    }\n    rex.need_clear_zsubexpr = FALSE;\n}\n#endif\n\n/*\n * Advance rex.lnum, rex.line and rex.input to the next line.\n */\n    static void\nreg_nextline(void)\n{\n    rex.line = reg_getline(++rex.lnum);\n    rex.input = rex.line;\n    fast_breakcheck();\n}\n\n/*\n * Check whether a backreference matches.\n * Returns RA_FAIL, RA_NOMATCH or RA_MATCH.\n * If \"bytelen\" is not NULL, it is set to the byte length of the match in the\n * last line.\n */\n    static int\nmatch_with_backref(\n    linenr_T start_lnum,\n    colnr_T  start_col,\n    linenr_T end_lnum,\n    colnr_T  end_col,\n    int\t     *bytelen)\n{\n    linenr_T\tclnum = start_lnum;\n    colnr_T\tccol = start_col;\n    int\t\tlen;\n    char_u\t*p;\n\n    if (bytelen != NULL)\n\t*bytelen = 0;\n    for (;;)\n    {\n\t// Since getting one line may invalidate the other, need to make copy.\n\t// Slow!\n\tif (rex.line != reg_tofree)\n\t{\n\t    len = (int)STRLEN(rex.line);\n\t    if (reg_tofree == NULL || len >= (int)reg_tofreelen)\n\t    {\n\t\tlen += 50;\t// get some extra\n\t\tvim_free(reg_tofree);\n\t\treg_tofree = alloc(len);\n\t\tif (reg_tofree == NULL)\n\t\t    return RA_FAIL; // out of memory!\n\t\treg_tofreelen = len;\n\t    }\n\t    STRCPY(reg_tofree, rex.line);\n\t    rex.input = reg_tofree + (rex.input - rex.line);\n\t    rex.line = reg_tofree;\n\t}\n\n\t// Get the line to compare with.\n\tp = reg_getline(clnum);\n\tif (clnum == end_lnum)\n\t    len = end_col - ccol;\n\telse\n\t    len = (int)STRLEN(p + ccol);\n\n\tif (cstrncmp(p + ccol, rex.input, &len) != 0)\n\t    return RA_NOMATCH;  // doesn't match\n\tif (bytelen != NULL)\n\t    *bytelen += len;\n\tif (clnum == end_lnum)\n\t    break;\t\t// match and at end!\n\tif (rex.lnum >= rex.reg_maxline)\n\t    return RA_NOMATCH;  // text too short\n\n\t// Advance to next line.\n\treg_nextline();\n\tif (bytelen != NULL)\n\t    *bytelen = 0;\n\t++clnum;\n\tccol = 0;\n\tif (got_int)\n\t    return RA_FAIL;\n    }\n\n    // found a match!  Note that rex.line may now point to a copy of the line,\n    // that should not matter.\n    return RA_MATCH;\n}\n\n/*\n * Used in a place where no * or \\+ can follow.\n */\n    static int\nre_mult_next(char *what)\n{\n    if (re_multi_type(peekchr()) == MULTI_MULT)\n    {\n       semsg(_(e_nfa_regexp_cannot_repeat_str), what);\n       rc_did_emsg = TRUE;\n       return FAIL;\n    }\n    return OK;\n}\n\ntypedef struct\n{\n    int a, b, c;\n} decomp_T;\n\n\n// 0xfb20 - 0xfb4f\nstatic decomp_T decomp_table[0xfb4f-0xfb20+1] =\n{\n    {0x5e2,0,0},\t\t// 0xfb20\talt ayin\n    {0x5d0,0,0},\t\t// 0xfb21\talt alef\n    {0x5d3,0,0},\t\t// 0xfb22\talt dalet\n    {0x5d4,0,0},\t\t// 0xfb23\talt he\n    {0x5db,0,0},\t\t// 0xfb24\talt kaf\n    {0x5dc,0,0},\t\t// 0xfb25\talt lamed\n    {0x5dd,0,0},\t\t// 0xfb26\talt mem-sofit\n    {0x5e8,0,0},\t\t// 0xfb27\talt resh\n    {0x5ea,0,0},\t\t// 0xfb28\talt tav\n    {'+', 0, 0},\t\t// 0xfb29\talt plus\n    {0x5e9, 0x5c1, 0},\t\t// 0xfb2a\tshin+shin-dot\n    {0x5e9, 0x5c2, 0},\t\t// 0xfb2b\tshin+sin-dot\n    {0x5e9, 0x5c1, 0x5bc},\t// 0xfb2c\tshin+shin-dot+dagesh\n    {0x5e9, 0x5c2, 0x5bc},\t// 0xfb2d\tshin+sin-dot+dagesh\n    {0x5d0, 0x5b7, 0},\t\t// 0xfb2e\talef+patah\n    {0x5d0, 0x5b8, 0},\t\t// 0xfb2f\talef+qamats\n    {0x5d0, 0x5b4, 0},\t\t// 0xfb30\talef+hiriq\n    {0x5d1, 0x5bc, 0},\t\t// 0xfb31\tbet+dagesh\n    {0x5d2, 0x5bc, 0},\t\t// 0xfb32\tgimel+dagesh\n    {0x5d3, 0x5bc, 0},\t\t// 0xfb33\tdalet+dagesh\n    {0x5d4, 0x5bc, 0},\t\t// 0xfb34\the+dagesh\n    {0x5d5, 0x5bc, 0},\t\t// 0xfb35\tvav+dagesh\n    {0x5d6, 0x5bc, 0},\t\t// 0xfb36\tzayin+dagesh\n    {0xfb37, 0, 0},\t\t// 0xfb37 -- UNUSED\n    {0x5d8, 0x5bc, 0},\t\t// 0xfb38\ttet+dagesh\n    {0x5d9, 0x5bc, 0},\t\t// 0xfb39\tyud+dagesh\n    {0x5da, 0x5bc, 0},\t\t// 0xfb3a\tkaf sofit+dagesh\n    {0x5db, 0x5bc, 0},\t\t// 0xfb3b\tkaf+dagesh\n    {0x5dc, 0x5bc, 0},\t\t// 0xfb3c\tlamed+dagesh\n    {0xfb3d, 0, 0},\t\t// 0xfb3d -- UNUSED\n    {0x5de, 0x5bc, 0},\t\t// 0xfb3e\tmem+dagesh\n    {0xfb3f, 0, 0},\t\t// 0xfb3f -- UNUSED\n    {0x5e0, 0x5bc, 0},\t\t// 0xfb40\tnun+dagesh\n    {0x5e1, 0x5bc, 0},\t\t// 0xfb41\tsamech+dagesh\n    {0xfb42, 0, 0},\t\t// 0xfb42 -- UNUSED\n    {0x5e3, 0x5bc, 0},\t\t// 0xfb43\tpe sofit+dagesh\n    {0x5e4, 0x5bc,0},\t\t// 0xfb44\tpe+dagesh\n    {0xfb45, 0, 0},\t\t// 0xfb45 -- UNUSED\n    {0x5e6, 0x5bc, 0},\t\t// 0xfb46\ttsadi+dagesh\n    {0x5e7, 0x5bc, 0},\t\t// 0xfb47\tqof+dagesh\n    {0x5e8, 0x5bc, 0},\t\t// 0xfb48\tresh+dagesh\n    {0x5e9, 0x5bc, 0},\t\t// 0xfb49\tshin+dagesh\n    {0x5ea, 0x5bc, 0},\t\t// 0xfb4a\ttav+dagesh\n    {0x5d5, 0x5b9, 0},\t\t// 0xfb4b\tvav+holam\n    {0x5d1, 0x5bf, 0},\t\t// 0xfb4c\tbet+rafe\n    {0x5db, 0x5bf, 0},\t\t// 0xfb4d\tkaf+rafe\n    {0x5e4, 0x5bf, 0},\t\t// 0xfb4e\tpe+rafe\n    {0x5d0, 0x5dc, 0}\t\t// 0xfb4f\talef-lamed\n};\n\n    static void\nmb_decompose(int c, int *c1, int *c2, int *c3)\n{\n    decomp_T d;\n\n    if (c >= 0xfb20 && c <= 0xfb4f)\n    {\n\td = decomp_table[c - 0xfb20];\n\t*c1 = d.a;\n\t*c2 = d.b;\n\t*c3 = d.c;\n    }\n    else\n    {\n\t*c1 = c;\n\t*c2 = *c3 = 0;\n    }\n}\n\n/*\n * Compare two strings, ignore case if rex.reg_ic set.\n * Return 0 if strings match, non-zero otherwise.\n * Correct the length \"*n\" when composing characters are ignored.\n */\n    static int\ncstrncmp(char_u *s1, char_u *s2, int *n)\n{\n    int\t\tresult;\n\n    if (!rex.reg_ic)\n\tresult = STRNCMP(s1, s2, *n);\n    else\n\tresult = MB_STRNICMP(s1, s2, *n);\n\n    // if it failed and it's utf8 and we want to combineignore:\n    if (result != 0 && enc_utf8 && rex.reg_icombine)\n    {\n\tchar_u\t*str1, *str2;\n\tint\tc1, c2, c11, c12;\n\tint\tjunk;\n\n\t// we have to handle the strcmp ourselves, since it is necessary to\n\t// deal with the composing characters by ignoring them:\n\tstr1 = s1;\n\tstr2 = s2;\n\tc1 = c2 = 0;\n\twhile ((int)(str1 - s1) < *n)\n\t{\n\t    c1 = mb_ptr2char_adv(&str1);\n\t    c2 = mb_ptr2char_adv(&str2);\n\n\t    // Decompose the character if necessary, into 'base' characters.\n\t    // Currently hard-coded for Hebrew, Arabic to be done...\n\t    if (c1 != c2 && (!rex.reg_ic || utf_fold(c1) != utf_fold(c2)))\n\t    {\n\t\t// decomposition necessary?\n\t\tmb_decompose(c1, &c11, &junk, &junk);\n\t\tmb_decompose(c2, &c12, &junk, &junk);\n\t\tc1 = c11;\n\t\tc2 = c12;\n\t\tif (c11 != c12\n\t\t\t    && (!rex.reg_ic || utf_fold(c11) != utf_fold(c12)))\n\t\t    break;\n\t    }\n\t}\n\tresult = c2 - c1;\n\tif (result == 0)\n\t    *n = (int)(str2 - s2);\n    }\n\n    return result;\n}\n\n/*\n * cstrchr: This function is used a lot for simple searches, keep it fast!\n */\n    static char_u *\ncstrchr(char_u *s, int c)\n{\n    char_u\t*p;\n    int\t\tcc;\n\n    if (!rex.reg_ic || (!enc_utf8 && mb_char2len(c) > 1))\n\treturn vim_strchr(s, c);\n\n    // tolower() and toupper() can be slow, comparing twice should be a lot\n    // faster (esp. when using MS Visual C++!).\n    // For UTF-8 need to use folded case.\n    if (enc_utf8 && c > 0x80)\n\tcc = utf_fold(c);\n    else\n\t if (MB_ISUPPER(c))\n\tcc = MB_TOLOWER(c);\n    else if (MB_ISLOWER(c))\n\tcc = MB_TOUPPER(c);\n    else\n\treturn vim_strchr(s, c);\n\n    if (has_mbyte)\n    {\n\tfor (p = s; *p != NUL; p += (*mb_ptr2len)(p))\n\t{\n\t    if (enc_utf8 && c > 0x80)\n\t    {\n\t\tint uc = utf_ptr2char(p);\n\n\t\t// Do not match an illegal byte.  E.g. 0xff matches 0xc3 0xbf,\n\t\t// not 0xff.\n\t\tif ((uc < 0x80 || uc != *p) && utf_fold(uc) == cc)\n\t\t    return p;\n\t    }\n\t    else if (*p == c || *p == cc)\n\t\treturn p;\n\t}\n    }\n    else\n\t// Faster version for when there are no multi-byte characters.\n\tfor (p = s; *p != NUL; ++p)\n\t    if (*p == c || *p == cc)\n\t\treturn p;\n\n    return NULL;\n}\n\n////////////////////////////////////////////////////////////////\n//\t\t      regsub stuff\t\t\t      //\n////////////////////////////////////////////////////////////////\n\n/*\n * We should define ftpr as a pointer to a function returning a pointer to\n * a function returning a pointer to a function ...\n * This is impossible, so we declare a pointer to a function returning a\n * void pointer. This should work for all compilers.\n */\ntypedef void (*(*fptr_T)(int *, int));\n\nstatic int vim_regsub_both(char_u *source, typval_T *expr, char_u *dest, int destlen, int flags);\n\n    static fptr_T\ndo_upper(int *d, int c)\n{\n    *d = MB_TOUPPER(c);\n\n    return (fptr_T)NULL;\n}\n\n    static fptr_T\ndo_Upper(int *d, int c)\n{\n    *d = MB_TOUPPER(c);\n\n    return (fptr_T)do_Upper;\n}\n\n    static fptr_T\ndo_lower(int *d, int c)\n{\n    *d = MB_TOLOWER(c);\n\n    return (fptr_T)NULL;\n}\n\n    static fptr_T\ndo_Lower(int *d, int c)\n{\n    *d = MB_TOLOWER(c);\n\n    return (fptr_T)do_Lower;\n}\n\n/*\n * regtilde(): Replace tildes in the pattern by the old pattern.\n *\n * Short explanation of the tilde: It stands for the previous replacement\n * pattern.  If that previous pattern also contains a ~ we should go back a\n * step further...  But we insert the previous pattern into the current one\n * and remember that.\n * This still does not handle the case where \"magic\" changes.  So require the\n * user to keep his hands off of \"magic\".\n *\n * The tildes are parsed once before the first call to vim_regsub().\n */\n    char_u *\nregtilde(char_u *source, int magic)\n{\n    char_u\t*newsub = source;\n    char_u\t*p;\n\n    for (p = newsub; *p; ++p)\n    {\n\tif ((*p == '~' && magic) || (*p == '\\\\' && *(p + 1) == '~' && !magic))\n\t{\n\t    if (reg_prev_sub != NULL)\n\t    {\n\t\t// length = len(newsub) - 1 + len(prev_sub) + 1\n\t\t// Avoid making the text longer than MAXCOL, it will cause\n\t\t// trouble at some point.\n\t\tsize_t\tprevsublen = STRLEN(reg_prev_sub);\n\t\tsize_t  newsublen = STRLEN(newsub);\n\t\tif (prevsublen > MAXCOL || newsublen > MAXCOL\n\t\t\t\t\t    || newsublen + prevsublen > MAXCOL)\n\t\t{\n\t\t    emsg(_(e_resulting_text_too_long));\n\t\t    break;\n\t\t}\n\n\t\tchar_u *tmpsub = alloc(newsublen + prevsublen);\n\t\tif (tmpsub != NULL)\n\t\t{\n\t\t    // copy prefix\n\t\t    size_t prefixlen = p - newsub;\t// not including ~\n\t\t    mch_memmove(tmpsub, newsub, prefixlen);\n\t\t    // interpret tilde\n\t\t    mch_memmove(tmpsub + prefixlen, reg_prev_sub,\n\t\t\t\t\t\t\t       prevsublen);\n\t\t    // copy postfix\n\t\t    if (!magic)\n\t\t\t++p;\t\t\t// back off backslash\n\t\t    STRCPY(tmpsub + prefixlen + prevsublen, p + 1);\n\n\t\t    if (newsub != source)\t// allocated newsub before\n\t\t\tvim_free(newsub);\n\t\t    newsub = tmpsub;\n\t\t    p = newsub + prefixlen + prevsublen;\n\t\t}\n\t    }\n\t    else if (magic)\n\t\tSTRMOVE(p, p + 1);\t// remove '~'\n\t    else\n\t\tSTRMOVE(p, p + 2);\t// remove '\\~'\n\t    --p;\n\t}\n\telse\n\t{\n\t    if (*p == '\\\\' && p[1])\t\t// skip escaped characters\n\t\t++p;\n\t    if (has_mbyte)\n\t\tp += (*mb_ptr2len)(p) - 1;\n\t}\n    }\n\n    // Store a copy of newsub  in reg_prev_sub.  It is always allocated,\n    // because recursive calls may make the returned string invalid.\n    vim_free(reg_prev_sub);\n    reg_prev_sub = vim_strsave(newsub);\n\n    return newsub;\n}\n\n#ifdef FEAT_EVAL\nstatic int can_f_submatch = FALSE;\t// TRUE when submatch() can be used\n\n// These pointers are used for reg_submatch().  Needed for when the\n// substitution string is an expression that contains a call to substitute()\n// and submatch().\ntypedef struct {\n    regmatch_T\t*sm_match;\n    regmmatch_T\t*sm_mmatch;\n    linenr_T\tsm_firstlnum;\n    linenr_T\tsm_maxline;\n    int\t\tsm_line_lbr;\n} regsubmatch_T;\n\nstatic regsubmatch_T rsm;  // can only be used when can_f_submatch is TRUE\n#endif\n\n#ifdef FEAT_EVAL\n\n/*\n * Put the submatches in \"argv[argskip]\" which is a list passed into\n * call_func() by vim_regsub_both().\n */\n    static int\nfill_submatch_list(int argc UNUSED, typval_T *argv, int argskip, ufunc_T *fp)\n{\n    listitem_T\t*li;\n    int\t\ti;\n    char_u\t*s;\n    typval_T\t*listarg = argv + argskip;\n\n    if (!has_varargs(fp) && fp->uf_args.ga_len <= argskip)\n\t// called function doesn't take a submatches argument\n\treturn argskip;\n\n    // Relies on sl_list to be the first item in staticList10_T.\n    init_static_list((staticList10_T *)(listarg->vval.v_list));\n\n    // There are always 10 list items in staticList10_T.\n    li = listarg->vval.v_list->lv_first;\n    for (i = 0; i < 10; ++i)\n    {\n\ts = rsm.sm_match->startp[i];\n\tif (s == NULL || rsm.sm_match->endp[i] == NULL)\n\t    s = NULL;\n\telse\n\t    s = vim_strnsave(s, rsm.sm_match->endp[i] - s);\n\tli->li_tv.v_type = VAR_STRING;\n\tli->li_tv.vval.v_string = s;\n\tli = li->li_next;\n    }\n    return argskip + 1;\n}\n\n    static void\nclear_submatch_list(staticList10_T *sl)\n{\n    int i;\n\n    for (i = 0; i < 10; ++i)\n\tvim_free(sl->sl_items[i].li_tv.vval.v_string);\n}\n#endif\n\n/*\n * vim_regsub() - perform substitutions after a vim_regexec() or\n * vim_regexec_multi() match.\n *\n * If \"flags\" has REGSUB_COPY really copy into \"dest[destlen]\".\n * Otherwise nothing is copied, only compute the length of the result.\n *\n * If \"flags\" has REGSUB_MAGIC then behave like 'magic' is set.\n *\n * If \"flags\" has REGSUB_BACKSLASH a backslash will be removed later, need to\n * double them to keep them, and insert a backslash before a CR to avoid it\n * being replaced with a line break later.\n *\n * Note: The matched text must not change between the call of\n * vim_regexec()/vim_regexec_multi() and vim_regsub()!  It would make the back\n * references invalid!\n *\n * Returns the size of the replacement, including terminating NUL.\n */\n    int\nvim_regsub(\n    regmatch_T\t*rmp,\n    char_u\t*source,\n    typval_T\t*expr,\n    char_u\t*dest,\n    int\t\tdestlen,\n    int\t\tflags)\n{\n    int\t\tresult;\n    regexec_T\trex_save;\n    int\t\trex_in_use_save = rex_in_use;\n\n    if (rex_in_use)\n\t// Being called recursively, save the state.\n\trex_save = rex;\n    rex_in_use = TRUE;\n\n    rex.reg_match = rmp;\n    rex.reg_mmatch = NULL;\n    rex.reg_maxline = 0;\n    rex.reg_buf = curbuf;\n    rex.reg_line_lbr = TRUE;\n    result = vim_regsub_both(source, expr, dest, destlen, flags);\n\n    rex_in_use = rex_in_use_save;\n    if (rex_in_use)\n\trex = rex_save;\n\n    return result;\n}\n\n    int\nvim_regsub_multi(\n    regmmatch_T\t*rmp,\n    linenr_T\tlnum,\n    char_u\t*source,\n    char_u\t*dest,\n    int\t\tdestlen,\n    int\t\tflags)\n{\n    int\t\tresult;\n    regexec_T\trex_save;\n    int\t\trex_in_use_save = rex_in_use;\n\n    if (rex_in_use)\n\t// Being called recursively, save the state.\n\trex_save = rex;\n    rex_in_use = TRUE;\n\n    rex.reg_match = NULL;\n    rex.reg_mmatch = rmp;\n    rex.reg_buf = curbuf;\t// always works on the current buffer!\n    rex.reg_firstlnum = lnum;\n    rex.reg_maxline = curbuf->b_ml.ml_line_count - lnum;\n    rex.reg_line_lbr = FALSE;\n    result = vim_regsub_both(source, NULL, dest, destlen, flags);\n\n    rex_in_use = rex_in_use_save;\n    if (rex_in_use)\n\trex = rex_save;\n\n    return result;\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n// When nesting more than a couple levels it's probably a mistake.\n# define MAX_REGSUB_NESTING 4\nstatic char_u   *eval_result[MAX_REGSUB_NESTING] = {NULL, NULL, NULL, NULL};\n\n# if defined(EXITFREE) || defined(PROTO)\n    void\nfree_resub_eval_result(void)\n{\n    int i;\n\n    for (i = 0; i < MAX_REGSUB_NESTING; ++i)\n\tVIM_CLEAR(eval_result[i]);\n}\n# endif\n#endif\n\n    static int\nvim_regsub_both(\n    char_u\t*source,\n    typval_T\t*expr,\n    char_u\t*dest,\n    int\t\tdestlen,\n    int\t\tflags)\n{\n    char_u\t*src;\n    char_u\t*dst;\n    char_u\t*s;\n    int\t\tc;\n    int\t\tcc;\n    int\t\tno = -1;\n    fptr_T\tfunc_all = (fptr_T)NULL;\n    fptr_T\tfunc_one = (fptr_T)NULL;\n    linenr_T\tclnum = 0;\t// init for GCC\n    int\t\tlen = 0;\t// init for GCC\n#ifdef FEAT_EVAL\n    static int  nesting = 0;\n    int\t\tnested;\n#endif\n    int\t\tcopy = flags & REGSUB_COPY;\n\n    // Be paranoid...\n    if ((source == NULL && expr == NULL) || dest == NULL)\n    {\n\temsg(_(e_null_argument));\n\treturn 0;\n    }\n    if (prog_magic_wrong())\n\treturn 0;\n#ifdef FEAT_EVAL\n    if (nesting == MAX_REGSUB_NESTING)\n    {\n\temsg(_(e_substitute_nesting_too_deep));\n\treturn 0;\n    }\n    nested = nesting;\n#endif\n    src = source;\n    dst = dest;\n\n    /*\n     * When the substitute part starts with \"\\=\" evaluate it as an expression.\n     */\n    if (expr != NULL || (source[0] == '\\\\' && source[1] == '='))\n    {\n#ifdef FEAT_EVAL\n\t// To make sure that the length doesn't change between checking the\n\t// length and copying the string, and to speed up things, the\n\t// resulting string is saved from the call with\n\t// \"flags & REGSUB_COPY\" == 0 to the call with\n\t// \"flags & REGSUB_COPY\" != 0.\n\tif (copy)\n\t{\n\t    if (eval_result[nested] != NULL)\n\t    {\n\t\tSTRCPY(dest, eval_result[nested]);\n\t\tdst += STRLEN(eval_result[nested]);\n\t\tVIM_CLEAR(eval_result[nested]);\n\t    }\n\t}\n\telse\n\t{\n\t    int\t\t    prev_can_f_submatch = can_f_submatch;\n\t    regsubmatch_T   rsm_save;\n\n\t    VIM_CLEAR(eval_result[nested]);\n\n\t    // The expression may contain substitute(), which calls us\n\t    // recursively.  Make sure submatch() gets the text from the first\n\t    // level.\n\t    if (can_f_submatch)\n\t\trsm_save = rsm;\n\t    can_f_submatch = TRUE;\n\t    rsm.sm_match = rex.reg_match;\n\t    rsm.sm_mmatch = rex.reg_mmatch;\n\t    rsm.sm_firstlnum = rex.reg_firstlnum;\n\t    rsm.sm_maxline = rex.reg_maxline;\n\t    rsm.sm_line_lbr = rex.reg_line_lbr;\n\n\t    // Although unlikely, it is possible that the expression invokes a\n\t    // substitute command (it might fail, but still).  Therefore keep\n\t    // an array of eval results.\n\t    ++nesting;\n\n\t    if (expr != NULL)\n\t    {\n\t\ttypval_T\targv[2];\n\t\tchar_u\t\tbuf[NUMBUFLEN];\n\t\ttypval_T\trettv;\n\t\tstaticList10_T\tmatchList;\n\t\tfuncexe_T\tfuncexe;\n\n\t\trettv.v_type = VAR_STRING;\n\t\trettv.vval.v_string = NULL;\n\t\targv[0].v_type = VAR_LIST;\n\t\targv[0].vval.v_list = &matchList.sl_list;\n\t\tmatchList.sl_list.lv_len = 0;\n\t\tCLEAR_FIELD(funcexe);\n\t\tfuncexe.fe_argv_func = fill_submatch_list;\n\t\tfuncexe.fe_evaluate = TRUE;\n\t\tif (expr->v_type == VAR_FUNC)\n\t\t{\n\t\t    s = expr->vval.v_string;\n\t\t    call_func(s, -1, &rettv, 1, argv, &funcexe);\n\t\t}\n\t\telse if (expr->v_type == VAR_PARTIAL)\n\t\t{\n\t\t    partial_T   *partial = expr->vval.v_partial;\n\n\t\t    s = partial_name(partial);\n\t\t    funcexe.fe_partial = partial;\n\t\t    call_func(s, -1, &rettv, 1, argv, &funcexe);\n\t\t}\n\t\telse if (expr->v_type == VAR_INSTR)\n\t\t{\n\t\t    exe_typval_instr(expr, &rettv);\n\t\t}\n\t\tif (matchList.sl_list.lv_len > 0)\n\t\t    // fill_submatch_list() was called\n\t\t    clear_submatch_list(&matchList);\n\n\t\tif (rettv.v_type == VAR_UNKNOWN)\n\t\t    // something failed, no need to report another error\n\t\t    eval_result[nested] = NULL;\n\t\telse\n\t\t{\n\t\t    eval_result[nested] = tv_get_string_buf_chk(&rettv, buf);\n\t\t    if (eval_result[nested] != NULL)\n\t\t\teval_result[nested] = vim_strsave(eval_result[nested]);\n\t\t}\n\t\tclear_tv(&rettv);\n\t    }\n\t    else if (substitute_instr != NULL)\n\t\t// Execute instructions from ISN_SUBSTITUTE.\n\t\teval_result[nested] = exe_substitute_instr();\n\t    else\n\t\teval_result[nested] = eval_to_string(source + 2, TRUE, FALSE);\n\t    --nesting;\n\n\t    if (eval_result[nested] != NULL)\n\t    {\n\t\tint had_backslash = FALSE;\n\n\t\tfor (s = eval_result[nested]; *s != NUL; MB_PTR_ADV(s))\n\t\t{\n\t\t    // Change NL to CR, so that it becomes a line break,\n\t\t    // unless called from vim_regexec_nl().\n\t\t    // Skip over a backslashed character.\n\t\t    if (*s == NL && !rsm.sm_line_lbr)\n\t\t\t*s = CAR;\n\t\t    else if (*s == '\\\\' && s[1] != NUL)\n\t\t    {\n\t\t\t++s;\n\t\t\t/* Change NL to CR here too, so that this works:\n\t\t\t * :s/abc\\\\\\ndef/\\=\"aaa\\\\\\nbbb\"/  on text:\n\t\t\t *   abc\\\n\t\t\t *   def\n\t\t\t * Not when called from vim_regexec_nl().\n\t\t\t */\n\t\t\tif (*s == NL && !rsm.sm_line_lbr)\n\t\t\t    *s = CAR;\n\t\t\thad_backslash = TRUE;\n\t\t    }\n\t\t}\n\t\tif (had_backslash && (flags & REGSUB_BACKSLASH))\n\t\t{\n\t\t    // Backslashes will be consumed, need to double them.\n\t\t    s = vim_strsave_escaped(eval_result[nested], (char_u *)\"\\\\\");\n\t\t    if (s != NULL)\n\t\t    {\n\t\t\tvim_free(eval_result[nested]);\n\t\t\teval_result[nested] = s;\n\t\t    }\n\t\t}\n\n\t\tdst += STRLEN(eval_result[nested]);\n\t    }\n\n\t    can_f_submatch = prev_can_f_submatch;\n\t    if (can_f_submatch)\n\t\trsm = rsm_save;\n\t}\n#endif\n    }\n    else\n      while ((c = *src++) != NUL)\n      {\n\tif (c == '&' && (flags & REGSUB_MAGIC))\n\t    no = 0;\n\telse if (c == '\\\\' && *src != NUL)\n\t{\n\t    if (*src == '&' && !(flags & REGSUB_MAGIC))\n\t    {\n\t\t++src;\n\t\tno = 0;\n\t    }\n\t    else if ('0' <= *src && *src <= '9')\n\t    {\n\t\tno = *src++ - '0';\n\t    }\n\t    else if (vim_strchr((char_u *)\"uUlLeE\", *src))\n\t    {\n\t\tswitch (*src++)\n\t\t{\n\t\tcase 'u':   func_one = (fptr_T)do_upper;\n\t\t\t    continue;\n\t\tcase 'U':   func_all = (fptr_T)do_Upper;\n\t\t\t    continue;\n\t\tcase 'l':   func_one = (fptr_T)do_lower;\n\t\t\t    continue;\n\t\tcase 'L':   func_all = (fptr_T)do_Lower;\n\t\t\t    continue;\n\t\tcase 'e':\n\t\tcase 'E':   func_one = func_all = (fptr_T)NULL;\n\t\t\t    continue;\n\t\t}\n\t    }\n\t}\n\tif (no < 0)\t      // Ordinary character.\n\t{\n\t    if (c == K_SPECIAL && src[0] != NUL && src[1] != NUL)\n\t    {\n\t\t// Copy a special key as-is.\n\t\tif (copy)\n\t\t{\n\t\t    if (dst + 3 > dest + destlen)\n\t\t    {\n\t\t\tiemsg(\"vim_regsub_both(): not enough space\");\n\t\t\treturn 0;\n\t\t    }\n\t\t    *dst++ = c;\n\t\t    *dst++ = *src++;\n\t\t    *dst++ = *src++;\n\t\t}\n\t\telse\n\t\t{\n\t\t    dst += 3;\n\t\t    src += 2;\n\t\t}\n\t\tcontinue;\n\t    }\n\n\t    if (c == '\\\\' && *src != NUL)\n\t    {\n\t\t// Check for abbreviations -- webb\n\t\tswitch (*src)\n\t\t{\n\t\t    case 'r':\tc = CAR;\t++src;\tbreak;\n\t\t    case 'n':\tc = NL;\t\t++src;\tbreak;\n\t\t    case 't':\tc = TAB;\t++src;\tbreak;\n\t\t // Oh no!  \\e already has meaning in subst pat :-(\n\t\t // case 'e':   c = ESC;\t++src;\tbreak;\n\t\t    case 'b':\tc = Ctrl_H;\t++src;\tbreak;\n\n\t\t    // If \"backslash\" is TRUE the backslash will be removed\n\t\t    // later.  Used to insert a literal CR.\n\t\t    default:\tif (flags & REGSUB_BACKSLASH)\n\t\t\t\t{\n\t\t\t\t    if (copy)\n\t\t\t\t    {\n\t\t\t\t\tif (dst + 1 > dest + destlen)\n\t\t\t\t\t{\n\t\t\t\t\t    iemsg(\"vim_regsub_both(): not enough space\");\n\t\t\t\t\t    return 0;\n\t\t\t\t\t}\n\t\t\t\t\t*dst = '\\\\';\n\t\t\t\t    }\n\t\t\t\t    ++dst;\n\t\t\t\t}\n\t\t\t\tc = *src++;\n\t\t}\n\t    }\n\t    else if (has_mbyte)\n\t\tc = mb_ptr2char(src - 1);\n\n\t    // Write to buffer, if copy is set.\n\t    if (func_one != (fptr_T)NULL)\n\t\t// Turbo C complains without the typecast\n\t\tfunc_one = (fptr_T)(func_one(&cc, c));\n\t    else if (func_all != (fptr_T)NULL)\n\t\t// Turbo C complains without the typecast\n\t\tfunc_all = (fptr_T)(func_all(&cc, c));\n\t    else // just copy\n\t\tcc = c;\n\n\t    if (has_mbyte)\n\t    {\n\t\tint totlen = mb_ptr2len(src - 1);\n\t\tint charlen = mb_char2len(cc);\n\n\t\tif (copy)\n\t\t{\n\t\t    if (dst + charlen > dest + destlen)\n\t\t    {\n\t\t\tiemsg(\"vim_regsub_both(): not enough space\");\n\t\t\treturn 0;\n\t\t    }\n\t\t    mb_char2bytes(cc, dst);\n\t\t}\n\t\tdst += charlen - 1;\n\t\tif (enc_utf8)\n\t\t{\n\t\t    int clen = utf_ptr2len(src - 1);\n\n\t\t    // If the character length is shorter than \"totlen\", there\n\t\t    // are composing characters; copy them as-is.\n\t\t    if (clen < totlen)\n\t\t    {\n\t\t\tif (copy)\n\t\t\t{\n\t\t\t    if (dst + totlen - clen > dest + destlen)\n\t\t\t    {\n\t\t\t\tiemsg(\"vim_regsub_both(): not enough space\");\n\t\t\t\treturn 0;\n\t\t\t    }\n\t\t\t    mch_memmove(dst + 1, src - 1 + clen,\n\t\t\t\t\t\t     (size_t)(totlen - clen));\n\t\t\t}\n\t\t\tdst += totlen - clen;\n\t\t    }\n\t\t}\n\t\tsrc += totlen - 1;\n\t    }\n\t    else if (copy)\n\t    {\n\t\tif (dst + 1 > dest + destlen)\n\t\t{\n\t\t    iemsg(\"vim_regsub_both(): not enough space\");\n\t\t    return 0;\n\t\t}\n\t\t*dst = cc;\n\t    }\n\t    dst++;\n\t}\n\telse\n\t{\n\t    if (REG_MULTI)\n\t    {\n\t\tclnum = rex.reg_mmatch->startpos[no].lnum;\n\t\tif (clnum < 0 || rex.reg_mmatch->endpos[no].lnum < 0)\n\t\t    s = NULL;\n\t\telse\n\t\t{\n\t\t    s = reg_getline(clnum) + rex.reg_mmatch->startpos[no].col;\n\t\t    if (rex.reg_mmatch->endpos[no].lnum == clnum)\n\t\t\tlen = rex.reg_mmatch->endpos[no].col\n\t\t\t\t\t    - rex.reg_mmatch->startpos[no].col;\n\t\t    else\n\t\t\tlen = (int)STRLEN(s);\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\ts = rex.reg_match->startp[no];\n\t\tif (rex.reg_match->endp[no] == NULL)\n\t\t    s = NULL;\n\t\telse\n\t\t    len = (int)(rex.reg_match->endp[no] - s);\n\t    }\n\t    if (s != NULL)\n\t    {\n\t\tfor (;;)\n\t\t{\n\t\t    if (len == 0)\n\t\t    {\n\t\t\tif (REG_MULTI)\n\t\t\t{\n\t\t\t    if (rex.reg_mmatch->endpos[no].lnum == clnum)\n\t\t\t\tbreak;\n\t\t\t    if (copy)\n\t\t\t    {\n\t\t\t\tif (dst + 1 > dest + destlen)\n\t\t\t\t{\n\t\t\t\t    iemsg(\"vim_regsub_both(): not enough space\");\n\t\t\t\t    return 0;\n\t\t\t\t}\n\t\t\t\t*dst = CAR;\n\t\t\t    }\n\t\t\t    ++dst;\n\t\t\t    s = reg_getline(++clnum);\n\t\t\t    if (rex.reg_mmatch->endpos[no].lnum == clnum)\n\t\t\t\tlen = rex.reg_mmatch->endpos[no].col;\n\t\t\t    else\n\t\t\t\tlen = (int)STRLEN(s);\n\t\t\t}\n\t\t\telse\n\t\t\t    break;\n\t\t    }\n\t\t    else if (*s == NUL) // we hit NUL.\n\t\t    {\n\t\t\tif (copy)\n\t\t\t    iemsg(_(e_damaged_match_string));\n\t\t\tgoto exit;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tif ((flags & REGSUB_BACKSLASH)\n\t\t\t\t\t\t  && (*s == CAR || *s == '\\\\'))\n\t\t\t{\n\t\t\t    /*\n\t\t\t     * Insert a backslash in front of a CR, otherwise\n\t\t\t     * it will be replaced by a line break.\n\t\t\t     * Number of backslashes will be halved later,\n\t\t\t     * double them here.\n\t\t\t     */\n\t\t\t    if (copy)\n\t\t\t    {\n\t\t\t\tif (dst + 2 > dest + destlen)\n\t\t\t\t{\n\t\t\t\t    iemsg(\"vim_regsub_both(): not enough space\");\n\t\t\t\t    return 0;\n\t\t\t\t}\n\t\t\t\tdst[0] = '\\\\';\n\t\t\t\tdst[1] = *s;\n\t\t\t    }\n\t\t\t    dst += 2;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    if (has_mbyte)\n\t\t\t\tc = mb_ptr2char(s);\n\t\t\t    else\n\t\t\t\tc = *s;\n\n\t\t\t    if (func_one != (fptr_T)NULL)\n\t\t\t\t// Turbo C complains without the typecast\n\t\t\t\tfunc_one = (fptr_T)(func_one(&cc, c));\n\t\t\t    else if (func_all != (fptr_T)NULL)\n\t\t\t\t// Turbo C complains without the typecast\n\t\t\t\tfunc_all = (fptr_T)(func_all(&cc, c));\n\t\t\t    else // just copy\n\t\t\t\tcc = c;\n\n\t\t\t    if (has_mbyte)\n\t\t\t    {\n\t\t\t\tint l;\n\t\t\t\tint charlen;\n\n\t\t\t\t// Copy composing characters separately, one\n\t\t\t\t// at a time.\n\t\t\t\tif (enc_utf8)\n\t\t\t\t    l = utf_ptr2len(s) - 1;\n\t\t\t\telse\n\t\t\t\t    l = mb_ptr2len(s) - 1;\n\n\t\t\t\ts += l;\n\t\t\t\tlen -= l;\n\t\t\t\tcharlen = mb_char2len(cc);\n\t\t\t\tif (copy)\n\t\t\t\t{\n\t\t\t\t    if (dst + charlen > dest + destlen)\n\t\t\t\t    {\n\t\t\t\t\tiemsg(\"vim_regsub_both(): not enough space\");\n\t\t\t\t\treturn 0;\n\t\t\t\t    }\n\t\t\t\t    mb_char2bytes(cc, dst);\n\t\t\t\t}\n\t\t\t\tdst += charlen - 1;\n\t\t\t    }\n\t\t\t    else if (copy)\n\t\t\t    {\n\t\t\t\tif (dst + 1 > dest + destlen)\n\t\t\t\t{\n\t\t\t\t    iemsg(\"vim_regsub_both(): not enough space\");\n\t\t\t\t    return 0;\n\t\t\t\t}\n\t\t\t\t*dst = cc;\n\t\t\t    }\n\t\t\t    dst++;\n\t\t\t}\n\n\t\t\t++s;\n\t\t\t--len;\n\t\t    }\n\t\t}\n\t    }\n\t    no = -1;\n\t}\n      }\n    if (copy)\n\t*dst = NUL;\n\nexit:\n    return (int)((dst - dest) + 1);\n}\n\n#ifdef FEAT_EVAL\n/*\n * Call reg_getline() with the line numbers from the submatch.  If a\n * substitute() was used the reg_maxline and other values have been\n * overwritten.\n */\n    static char_u *\nreg_getline_submatch(linenr_T lnum)\n{\n    char_u *s;\n    linenr_T save_first = rex.reg_firstlnum;\n    linenr_T save_max = rex.reg_maxline;\n\n    rex.reg_firstlnum = rsm.sm_firstlnum;\n    rex.reg_maxline = rsm.sm_maxline;\n\n    s = reg_getline(lnum);\n\n    rex.reg_firstlnum = save_first;\n    rex.reg_maxline = save_max;\n    return s;\n}\n\n/*\n * Used for the submatch() function: get the string from the n'th submatch in\n * allocated memory.\n * Returns NULL when not in a \":s\" command and for a non-existing submatch.\n */\n    char_u *\nreg_submatch(int no)\n{\n    char_u\t*retval = NULL;\n    char_u\t*s;\n    int\t\tlen;\n    int\t\tround;\n    linenr_T\tlnum;\n\n    if (!can_f_submatch || no < 0)\n\treturn NULL;\n\n    if (rsm.sm_match == NULL)\n    {\n\t/*\n\t * First round: compute the length and allocate memory.\n\t * Second round: copy the text.\n\t */\n\tfor (round = 1; round <= 2; ++round)\n\t{\n\t    lnum = rsm.sm_mmatch->startpos[no].lnum;\n\t    if (lnum < 0 || rsm.sm_mmatch->endpos[no].lnum < 0)\n\t\treturn NULL;\n\n\t    s = reg_getline_submatch(lnum);\n\t    if (s == NULL)  // anti-crash check, cannot happen?\n\t\tbreak;\n\t    s += rsm.sm_mmatch->startpos[no].col;\n\t    if (rsm.sm_mmatch->endpos[no].lnum == lnum)\n\t    {\n\t\t// Within one line: take form start to end col.\n\t\tlen = rsm.sm_mmatch->endpos[no].col\n\t\t\t\t\t  - rsm.sm_mmatch->startpos[no].col;\n\t\tif (round == 2)\n\t\t    vim_strncpy(retval, s, len);\n\t\t++len;\n\t    }\n\t    else\n\t    {\n\t\t// Multiple lines: take start line from start col, middle\n\t\t// lines completely and end line up to end col.\n\t\tlen = (int)STRLEN(s);\n\t\tif (round == 2)\n\t\t{\n\t\t    STRCPY(retval, s);\n\t\t    retval[len] = '\\n';\n\t\t}\n\t\t++len;\n\t\t++lnum;\n\t\twhile (lnum < rsm.sm_mmatch->endpos[no].lnum)\n\t\t{\n\t\t    s = reg_getline_submatch(lnum++);\n\t\t    if (round == 2)\n\t\t\tSTRCPY(retval + len, s);\n\t\t    len += (int)STRLEN(s);\n\t\t    if (round == 2)\n\t\t\tretval[len] = '\\n';\n\t\t    ++len;\n\t\t}\n\t\tif (round == 2)\n\t\t    STRNCPY(retval + len, reg_getline_submatch(lnum),\n\t\t\t\t\t     rsm.sm_mmatch->endpos[no].col);\n\t\tlen += rsm.sm_mmatch->endpos[no].col;\n\t\tif (round == 2)\n\t\t    retval[len] = NUL;\n\t\t++len;\n\t    }\n\n\t    if (retval == NULL)\n\t    {\n\t\tretval = alloc(len);\n\t\tif (retval == NULL)\n\t\t    return NULL;\n\t    }\n\t}\n    }\n    else\n    {\n\ts = rsm.sm_match->startp[no];\n\tif (s == NULL || rsm.sm_match->endp[no] == NULL)\n\t    retval = NULL;\n\telse\n\t    retval = vim_strnsave(s, rsm.sm_match->endp[no] - s);\n    }\n\n    return retval;\n}\n\n/*\n * Used for the submatch() function with the optional non-zero argument: get\n * the list of strings from the n'th submatch in allocated memory with NULs\n * represented in NLs.\n * Returns a list of allocated strings.  Returns NULL when not in a \":s\"\n * command, for a non-existing submatch and for any error.\n */\n    list_T *\nreg_submatch_list(int no)\n{\n    char_u\t*s;\n    linenr_T\tslnum;\n    linenr_T\telnum;\n    colnr_T\tscol;\n    colnr_T\tecol;\n    int\t\ti;\n    list_T\t*list;\n    int\t\terror = FALSE;\n\n    if (!can_f_submatch || no < 0)\n\treturn NULL;\n\n    if (rsm.sm_match == NULL)\n    {\n\tslnum = rsm.sm_mmatch->startpos[no].lnum;\n\telnum = rsm.sm_mmatch->endpos[no].lnum;\n\tif (slnum < 0 || elnum < 0)\n\t    return NULL;\n\n\tscol = rsm.sm_mmatch->startpos[no].col;\n\tecol = rsm.sm_mmatch->endpos[no].col;\n\n\tlist = list_alloc();\n\tif (list == NULL)\n\t    return NULL;\n\n\ts = reg_getline_submatch(slnum) + scol;\n\tif (slnum == elnum)\n\t{\n\t    if (list_append_string(list, s, ecol - scol) == FAIL)\n\t\terror = TRUE;\n\t}\n\telse\n\t{\n\t    if (list_append_string(list, s, -1) == FAIL)\n\t\terror = TRUE;\n\t    for (i = 1; i < elnum - slnum; i++)\n\t    {\n\t\ts = reg_getline_submatch(slnum + i);\n\t\tif (list_append_string(list, s, -1) == FAIL)\n\t\t    error = TRUE;\n\t    }\n\t    s = reg_getline_submatch(elnum);\n\t    if (list_append_string(list, s, ecol) == FAIL)\n\t\terror = TRUE;\n\t}\n    }\n    else\n    {\n\ts = rsm.sm_match->startp[no];\n\tif (s == NULL || rsm.sm_match->endp[no] == NULL)\n\t    return NULL;\n\tlist = list_alloc();\n\tif (list == NULL)\n\t    return NULL;\n\tif (list_append_string(list, s,\n\t\t\t\t (int)(rsm.sm_match->endp[no] - s)) == FAIL)\n\t    error = TRUE;\n    }\n\n    if (error)\n    {\n\tlist_free(list);\n\treturn NULL;\n    }\n    ++list->lv_refcount;\n    return list;\n}\n#endif\n\n/*\n * Initialize the values used for matching against multiple lines\n */\n    static void\ninit_regexec_multi(\n\tregmmatch_T\t*rmp,\n\twin_T\t\t*win,\t// window in which to search or NULL\n\tbuf_T\t\t*buf,\t// buffer in which to search\n\tlinenr_T\tlnum)\t// nr of line to start looking for match\n{\n    rex.reg_match = NULL;\n    rex.reg_mmatch = rmp;\n    rex.reg_buf = buf;\n    rex.reg_win = win;\n    rex.reg_firstlnum = lnum;\n    rex.reg_maxline = rex.reg_buf->b_ml.ml_line_count - lnum;\n    rex.reg_line_lbr = FALSE;\n    rex.reg_ic = rmp->rmm_ic;\n    rex.reg_icombine = FALSE;\n    rex.reg_maxcol = rmp->rmm_maxcol;\n}\n\n#include \"regexp_bt.c\"\n\nstatic regengine_T bt_regengine =\n{\n    bt_regcomp,\n    bt_regfree,\n    bt_regexec_nl,\n    bt_regexec_multi,\n};\n\n#include \"regexp_nfa.c\"\n\nstatic regengine_T nfa_regengine =\n{\n    nfa_regcomp,\n    nfa_regfree,\n    nfa_regexec_nl,\n    nfa_regexec_multi,\n};\n\n// Which regexp engine to use? Needed for vim_regcomp().\n// Must match with 'regexpengine'.\nstatic int regexp_engine = 0;\n\n#ifdef DEBUG\nstatic char_u regname[][30] = {\n\t\t    \"AUTOMATIC Regexp Engine\",\n\t\t    \"BACKTRACKING Regexp Engine\",\n\t\t    \"NFA Regexp Engine\"\n\t\t\t    };\n#endif\n\n/*\n * Compile a regular expression into internal code.\n * Returns the program in allocated memory.\n * Use vim_regfree() to free the memory.\n * Returns NULL for an error.\n */\n    regprog_T *\nvim_regcomp(char_u *expr_arg, int re_flags)\n{\n    regprog_T   *prog = NULL;\n    char_u\t*expr = expr_arg;\n    int\t\tcalled_emsg_before;\n\n    regexp_engine = p_re;\n\n    // Check for prefix \"\\%#=\", that sets the regexp engine\n    if (STRNCMP(expr, \"\\\\%#=\", 4) == 0)\n    {\n\tint newengine = expr[4] - '0';\n\n\tif (newengine == AUTOMATIC_ENGINE\n\t    || newengine == BACKTRACKING_ENGINE\n\t    || newengine == NFA_ENGINE)\n\t{\n\t    regexp_engine = expr[4] - '0';\n\t    expr += 5;\n#ifdef DEBUG\n\t    smsg(\"New regexp mode selected (%d): %s\",\n\t\t\t\t\t   regexp_engine, regname[newengine]);\n#endif\n\t}\n\telse\n\t{\n\t    emsg(_(e_percent_hash_can_only_be_followed_by_zero_one_two_automatic_engine_will_be_used));\n\t    regexp_engine = AUTOMATIC_ENGINE;\n\t}\n    }\n#ifdef DEBUG\n    bt_regengine.expr = expr;\n    nfa_regengine.expr = expr;\n#endif\n    // reg_iswordc() uses rex.reg_buf\n    rex.reg_buf = curbuf;\n\n    /*\n     * First try the NFA engine, unless backtracking was requested.\n     */\n    called_emsg_before = called_emsg;\n    if (regexp_engine != BACKTRACKING_ENGINE)\n\tprog = nfa_regengine.regcomp(expr,\n\t\tre_flags + (regexp_engine == AUTOMATIC_ENGINE ? RE_AUTO : 0));\n    else\n\tprog = bt_regengine.regcomp(expr, re_flags);\n\n    // Check for error compiling regexp with initial engine.\n    if (prog == NULL)\n    {\n#ifdef BT_REGEXP_DEBUG_LOG\n\tif (regexp_engine == BACKTRACKING_ENGINE)   // debugging log for BT engine\n\t{\n\t    FILE *f;\n\t    f = fopen(BT_REGEXP_DEBUG_LOG_NAME, \"a\");\n\t    if (f)\n\t    {\n\t\tfprintf(f, \"Syntax error in \\\"%s\\\"\\n\", expr);\n\t\tfclose(f);\n\t    }\n\t    else\n\t\tsemsg(\"(NFA) Could not open \\\"%s\\\" to write !!!\",\n\t\t\tBT_REGEXP_DEBUG_LOG_NAME);\n\t}\n#endif\n\t/*\n\t * If the NFA engine failed, try the backtracking engine.\n\t * The NFA engine also fails for patterns that it can't handle well\n\t * but are still valid patterns, thus a retry should work.\n\t * But don't try if an error message was given.\n\t */\n\tif (regexp_engine == AUTOMATIC_ENGINE\n\t\t\t\t\t  && called_emsg == called_emsg_before)\n\t{\n\t    regexp_engine = BACKTRACKING_ENGINE;\n#ifdef FEAT_EVAL\n\t    report_re_switch(expr);\n#endif\n\t    prog = bt_regengine.regcomp(expr, re_flags);\n\t}\n    }\n\n    if (prog != NULL)\n    {\n\t// Store the info needed to call regcomp() again when the engine turns\n\t// out to be very slow when executing it.\n\tprog->re_engine = regexp_engine;\n\tprog->re_flags  = re_flags;\n    }\n\n    return prog;\n}\n\n/*\n * Free a compiled regexp program, returned by vim_regcomp().\n */\n    void\nvim_regfree(regprog_T *prog)\n{\n    if (prog != NULL)\n\tprog->engine->regfree(prog);\n}\n\n#if defined(EXITFREE) || defined(PROTO)\n    void\nfree_regexp_stuff(void)\n{\n    ga_clear(&regstack);\n    ga_clear(&backpos);\n    vim_free(reg_tofree);\n    vim_free(reg_prev_sub);\n}\n#endif\n\n#ifdef FEAT_EVAL\n    static void\nreport_re_switch(char_u *pat)\n{\n    if (p_verbose > 0)\n    {\n\tverbose_enter();\n\tmsg_puts(_(\"Switching to backtracking RE engine for pattern: \"));\n\tmsg_puts((char *)pat);\n\tverbose_leave();\n    }\n}\n#endif\n\n#if defined(FEAT_X11) || defined(PROTO)\n/*\n * Return whether \"prog\" is currently being executed.\n */\n    int\nregprog_in_use(regprog_T *prog)\n{\n    return prog->re_in_use;\n}\n#endif\n\n/*\n * Match a regexp against a string.\n * \"rmp->regprog\" must be a compiled regexp as returned by vim_regcomp().\n * Note: \"rmp->regprog\" may be freed and changed.\n * Uses curbuf for line count and 'iskeyword'.\n * When \"nl\" is TRUE consider a \"\\n\" in \"line\" to be a line break.\n *\n * Return TRUE if there is a match, FALSE if not.\n */\n    static int\nvim_regexec_string(\n    regmatch_T\t*rmp,\n    char_u\t*line,  // string to match against\n    colnr_T\tcol,    // column to start looking for match\n    int\t\tnl)\n{\n    int\t\tresult;\n    regexec_T\trex_save;\n    int\t\trex_in_use_save = rex_in_use;\n\n    // Cannot use the same prog recursively, it contains state.\n    if (rmp->regprog->re_in_use)\n    {\n\temsg(_(e_cannot_use_pattern_recursively));\n\treturn FALSE;\n    }\n    rmp->regprog->re_in_use = TRUE;\n\n    if (rex_in_use)\n\t// Being called recursively, save the state.\n\trex_save = rex;\n    rex_in_use = TRUE;\n\n    rex.reg_startp = NULL;\n    rex.reg_endp = NULL;\n    rex.reg_startpos = NULL;\n    rex.reg_endpos = NULL;\n\n    result = rmp->regprog->engine->regexec_nl(rmp, line, col, nl);\n    rmp->regprog->re_in_use = FALSE;\n\n    // NFA engine aborted because it's very slow.\n    if (rmp->regprog->re_engine == AUTOMATIC_ENGINE\n\t\t\t\t\t       && result == NFA_TOO_EXPENSIVE)\n    {\n\tint    save_p_re = p_re;\n\tint    re_flags = rmp->regprog->re_flags;\n\tchar_u *pat = vim_strsave(((nfa_regprog_T *)rmp->regprog)->pattern);\n\n\tp_re = BACKTRACKING_ENGINE;\n\tvim_regfree(rmp->regprog);\n\tif (pat != NULL)\n\t{\n#ifdef FEAT_EVAL\n\t    report_re_switch(pat);\n#endif\n\t    rmp->regprog = vim_regcomp(pat, re_flags);\n\t    if (rmp->regprog != NULL)\n\t    {\n\t\trmp->regprog->re_in_use = TRUE;\n\t\tresult = rmp->regprog->engine->regexec_nl(rmp, line, col, nl);\n\t\trmp->regprog->re_in_use = FALSE;\n\t    }\n\t    vim_free(pat);\n\t}\n\n\tp_re = save_p_re;\n    }\n\n    rex_in_use = rex_in_use_save;\n    if (rex_in_use)\n\trex = rex_save;\n\n    return result > 0;\n}\n\n#if defined(FEAT_SPELL) || defined(FEAT_EVAL) || defined(FEAT_X11) || defined(PROTO)\n/*\n * Note: \"*prog\" may be freed and changed.\n * Return TRUE if there is a match, FALSE if not.\n */\n    int\nvim_regexec_prog(\n    regprog_T\t**prog,\n    int\t\tignore_case,\n    char_u\t*line,\n    colnr_T\tcol)\n{\n    int\t\tr;\n    regmatch_T\tregmatch;\n\n    regmatch.regprog = *prog;\n    regmatch.rm_ic = ignore_case;\n    r = vim_regexec_string(&regmatch, line, col, FALSE);\n    *prog = regmatch.regprog;\n    return r;\n}\n#endif\n\n/*\n * Note: \"rmp->regprog\" may be freed and changed.\n * Return TRUE if there is a match, FALSE if not.\n */\n    int\nvim_regexec(regmatch_T *rmp, char_u *line, colnr_T col)\n{\n    return vim_regexec_string(rmp, line, col, FALSE);\n}\n\n/*\n * Like vim_regexec(), but consider a \"\\n\" in \"line\" to be a line break.\n * Note: \"rmp->regprog\" may be freed and changed.\n * Return TRUE if there is a match, FALSE if not.\n */\n    int\nvim_regexec_nl(regmatch_T *rmp, char_u *line, colnr_T col)\n{\n    return vim_regexec_string(rmp, line, col, TRUE);\n}\n\n/*\n * Match a regexp against multiple lines.\n * \"rmp->regprog\" must be a compiled regexp as returned by vim_regcomp().\n * Note: \"rmp->regprog\" may be freed and changed, even set to NULL.\n * Uses curbuf for line count and 'iskeyword'.\n *\n * Return zero if there is no match.  Return number of lines contained in the\n * match otherwise.\n */\n    long\nvim_regexec_multi(\n    regmmatch_T *rmp,\n    win_T       *win,\t\t// window in which to search or NULL\n    buf_T       *buf,\t\t// buffer in which to search\n    linenr_T\tlnum,\t\t// nr of line to start looking for match\n    colnr_T\tcol,\t\t// column to start looking for match\n    int\t\t*timed_out)\t// flag is set when timeout limit reached\n{\n    int\t\tresult;\n    regexec_T\trex_save;\n    int\t\trex_in_use_save = rex_in_use;\n\n    // Cannot use the same prog recursively, it contains state.\n    if (rmp->regprog->re_in_use)\n    {\n\temsg(_(e_cannot_use_pattern_recursively));\n\treturn FALSE;\n    }\n    rmp->regprog->re_in_use = TRUE;\n\n    if (rex_in_use)\n\t// Being called recursively, save the state.\n\trex_save = rex;\n    rex_in_use = TRUE;\n\n    result = rmp->regprog->engine->regexec_multi(\n\t\t\t\t      rmp, win, buf, lnum, col, timed_out);\n    rmp->regprog->re_in_use = FALSE;\n\n    // NFA engine aborted because it's very slow.\n    if (rmp->regprog->re_engine == AUTOMATIC_ENGINE\n\t\t\t\t\t       && result == NFA_TOO_EXPENSIVE)\n    {\n\tint    save_p_re = p_re;\n\tint    re_flags = rmp->regprog->re_flags;\n\tchar_u *pat = vim_strsave(((nfa_regprog_T *)rmp->regprog)->pattern);\n\n\tp_re = BACKTRACKING_ENGINE;\n\tif (pat != NULL)\n\t{\n\t    regprog_T *prev_prog = rmp->regprog;\n\n#ifdef FEAT_EVAL\n\t    report_re_switch(pat);\n#endif\n#ifdef FEAT_SYN_HL\n\t    // checking for \\z misuse was already done when compiling for NFA,\n\t    // allow all here\n\t    reg_do_extmatch = REX_ALL;\n#endif\n\t    rmp->regprog = vim_regcomp(pat, re_flags);\n#ifdef FEAT_SYN_HL\n\t    reg_do_extmatch = 0;\n#endif\n\t    if (rmp->regprog == NULL)\n\t    {\n\t\t// Somehow compiling the pattern failed now, put back the\n\t\t// previous one to avoid \"regprog\" becoming NULL.\n\t\trmp->regprog = prev_prog;\n\t    }\n\t    else\n\t    {\n\t\tvim_regfree(prev_prog);\n\n\t\trmp->regprog->re_in_use = TRUE;\n\t\tresult = rmp->regprog->engine->regexec_multi(\n\t\t\t\t      rmp, win, buf, lnum, col, timed_out);\n\t\trmp->regprog->re_in_use = FALSE;\n\t    }\n\t    vim_free(pat);\n\t}\n\tp_re = save_p_re;\n    }\n\n    rex_in_use = rex_in_use_save;\n    if (rex_in_use)\n\trex = rex_save;\n\n    return result <= 0 ? 0 : result;\n}\n", "\" Tests for the substitute (:s) command\n\nsource shared.vim\nsource check.vim\nsource screendump.vim\n\nfunc Test_multiline_subst()\n  enew!\n  call append(0, [\"1 aa\",\n\t      \\ \"bb\",\n\t      \\ \"cc\",\n\t      \\ \"2 dd\",\n\t      \\ \"ee\",\n\t      \\ \"3 ef\",\n\t      \\ \"gh\",\n\t      \\ \"4 ij\",\n\t      \\ \"5 a8\",\n\t      \\ \"8b c9\",\n\t      \\ \"9d\",\n\t      \\ \"6 e7\",\n\t      \\ \"77f\",\n\t      \\ \"xxxxx\"])\n\n  1\n  \" test if replacing a line break works with a back reference\n  /^1/,/^2/s/\\n\\(.\\)/ \\1/\n  \" test if inserting a line break works with a back reference\n  /^3/,/^4/s/\\(.\\)$/\\r\\1/\n  \" test if replacing a line break with another line break works\n  /^5/,/^6/s/\\(\\_d\\{3}\\)/x\\1x/\n  call assert_equal('1 aa bb cc 2 dd ee', getline(1))\n  call assert_equal('3 e', getline(2))\n  call assert_equal('f', getline(3))\n  call assert_equal('g', getline(4))\n  call assert_equal('h', getline(5))\n  call assert_equal('4 i', getline(6))\n  call assert_equal('j', getline(7))\n  call assert_equal('5 ax8', getline(8))\n  call assert_equal('8xb cx9', getline(9))\n  call assert_equal('9xd', getline(10))\n  call assert_equal('6 ex7', getline(11))\n  call assert_equal('7x7f', getline(12))\n  call assert_equal('xxxxx', getline(13))\n  enew!\nendfunc\n\nfunc Test_substitute_variants()\n  \" Validate that all the 2-/3-letter variants which embed the flags into the\n  \" command name actually work.\n  enew!\n  let ln = 'Testing string'\n  let variants = [\n\t\\ { 'cmd': ':s/Test/test/c', 'exp': 'testing string', 'prompt': 'y' },\n\t\\ { 'cmd': ':s/foo/bar/ce', 'exp': ln },\n\t\\ { 'cmd': ':s/t/r/cg', 'exp': 'Tesring srring', 'prompt': 'a' },\n\t\\ { 'cmd': ':s/t/r/ci', 'exp': 'resting string', 'prompt': 'y' },\n\t\\ { 'cmd': ':s/t/r/cI', 'exp': 'Tesring string', 'prompt': 'y' },\n\t\\ { 'cmd': ':s/t/r/c', 'exp': 'Testing string', 'prompt': 'n' },\n\t\\ { 'cmd': ':s/t/r/cn', 'exp': ln },\n\t\\ { 'cmd': ':s/t/r/cp', 'exp': 'Tesring string', 'prompt': 'y' },\n\t\\ { 'cmd': ':s/t/r/cl', 'exp': 'Tesring string', 'prompt': 'y' },\n\t\\ { 'cmd': ':s/t/r/gc', 'exp': 'Tesring srring', 'prompt': 'a' },\n\t\\ { 'cmd': ':s/i/I/gc', 'exp': 'TestIng string', 'prompt': 'l' },\n\t\\ { 'cmd': ':s/foo/bar/ge', 'exp': ln },\n\t\\ { 'cmd': ':s/t/r/g', 'exp': 'Tesring srring' },\n\t\\ { 'cmd': ':s/t/r/gi', 'exp': 'resring srring' },\n\t\\ { 'cmd': ':s/t/r/gI', 'exp': 'Tesring srring' },\n\t\\ { 'cmd': ':s/t/r/gn', 'exp': ln },\n\t\\ { 'cmd': ':s/t/r/gp', 'exp': 'Tesring srring' },\n\t\\ { 'cmd': ':s/t/r/gl', 'exp': 'Tesring srring' },\n\t\\ { 'cmd': ':s//r/gr', 'exp': 'Testr strr' },\n\t\\ { 'cmd': ':s/t/r/ic', 'exp': 'resting string', 'prompt': 'y' },\n\t\\ { 'cmd': ':s/foo/bar/ie', 'exp': ln },\n\t\\ { 'cmd': ':s/t/r/i', 'exp': 'resting string' },\n\t\\ { 'cmd': ':s/t/r/iI', 'exp': 'Tesring string' },\n\t\\ { 'cmd': ':s/t/r/in', 'exp': ln },\n\t\\ { 'cmd': ':s/t/r/ip', 'exp': 'resting string' },\n\t\\ { 'cmd': ':s//r/ir', 'exp': 'Testr string' },\n\t\\ { 'cmd': ':s/t/r/Ic', 'exp': 'Tesring string', 'prompt': 'y' },\n\t\\ { 'cmd': ':s/foo/bar/Ie', 'exp': ln },\n\t\\ { 'cmd': ':s/t/r/Ig', 'exp': 'Tesring srring' },\n\t\\ { 'cmd': ':s/t/r/Ii', 'exp': 'resting string' },\n\t\\ { 'cmd': ':s/t/r/I', 'exp': 'Tesring string' },\n\t\\ { 'cmd': ':s/t/r/Ip', 'exp': 'Tesring string' },\n\t\\ { 'cmd': ':s/t/r/Il', 'exp': 'Tesring string' },\n\t\\ { 'cmd': ':s//r/Ir', 'exp': 'Testr string' },\n\t\\ { 'cmd': ':s//r/rc', 'exp': 'Testr string', 'prompt': 'y' },\n\t\\ { 'cmd': ':s//r/rg', 'exp': 'Testr strr' },\n\t\\ { 'cmd': ':s//r/ri', 'exp': 'Testr string' },\n\t\\ { 'cmd': ':s//r/rI', 'exp': 'Testr string' },\n\t\\ { 'cmd': ':s//r/rn', 'exp': 'Testing string' },\n\t\\ { 'cmd': ':s//r/rp', 'exp': 'Testr string' },\n\t\\ { 'cmd': ':s//r/rl', 'exp': 'Testr string' },\n\t\\ { 'cmd': ':s//r/r', 'exp': 'Testr string' },\n\t\\ { 'cmd': ':s/i/I/gc', 'exp': 'Testing string', 'prompt': 'q' },\n\t\\]\n\n  for var in variants\n    for run in [1, 2]\n      let cmd = var.cmd\n      if run == 2 && cmd =~ \"/.*/.*/.\"\n\t\" Change  :s/from/to/{flags}  to  :s{flags}\n\tlet cmd = substitute(cmd, '/.*/', '', '')\n      endif\n      call setline(1, [ln])\n      let msg = printf('using \"%s\"', cmd)\n      let @/='ing'\n      let v:errmsg = ''\n      call feedkeys(cmd . \"\\<CR>\" . get(var, 'prompt', ''), 'ntx')\n      \" No error should exist (matters for testing e flag)\n      call assert_equal('', v:errmsg, msg)\n      call assert_equal(var.exp, getline('.'), msg)\n    endfor\n  endfor\nendfunc\n\n\" Test the l, p, # flags.\nfunc Test_substitute_flags_lp()\n  new\n  call setline(1, \"abc\\tdef\\<C-h>ghi\")\n\n  let a = execute('s/a/a/p')\n  call assert_equal(\"\\nabc     def^Hghi\", a)\n\n  let a = execute('s/a/a/l')\n  call assert_equal(\"\\nabc^Idef^Hghi$\", a)\n\n  let a = execute('s/a/a/#')\n  call assert_equal(\"\\n  1 abc     def^Hghi\", a)\n\n  let a = execute('s/a/a/p#')\n  call assert_equal(\"\\n  1 abc     def^Hghi\", a)\n\n  let a = execute('s/a/a/l#')\n  call assert_equal(\"\\n  1 abc^Idef^Hghi$\", a)\n\n  let a = execute('s/a/a/')\n  call assert_equal(\"\", a)\n\n  bwipe!\nendfunc\n\nfunc Test_substitute_repeat()\n  \" This caused an invalid memory access.\n  split Xsubfile\n  s/^/x\n  call feedkeys(\"Qsc\\<CR>y\", 'tx')\n  bwipe!\nendfunc\n\n\" Test %s/\\n// which is implemented as a special case to use a\n\" more efficient join rather than doing a regular substitution.\nfunc Test_substitute_join()\n  new\n\n  call setline(1, [\"foo\\tbar\", \"bar\\<C-H>foo\"])\n  let a = execute('%s/\\n//')\n  call assert_equal(\"\", a)\n  call assert_equal([\"foo\\tbarbar\\<C-H>foo\"], getline(1, '$'))\n  call assert_equal('\\n', histget(\"search\", -1))\n\n  call setline(1, [\"foo\\tbar\", \"bar\\<C-H>foo\"])\n  let a = execute('%s/\\n//g')\n  call assert_equal(\"\", a)\n  call assert_equal([\"foo\\tbarbar\\<C-H>foo\"], getline(1, '$'))\n  call assert_equal('\\n', histget(\"search\", -1))\n\n  call setline(1, [\"foo\\tbar\", \"bar\\<C-H>foo\"])\n  let a = execute('%s/\\n//p')\n  call assert_equal(\"\\nfoo     barbar^Hfoo\", a)\n  call assert_equal([\"foo\\tbarbar\\<C-H>foo\"], getline(1, '$'))\n  call assert_equal('\\n', histget(\"search\", -1))\n\n  call setline(1, [\"foo\\tbar\", \"bar\\<C-H>foo\"])\n  let a = execute('%s/\\n//l')\n  call assert_equal(\"\\nfoo^Ibarbar^Hfoo$\", a)\n  call assert_equal([\"foo\\tbarbar\\<C-H>foo\"], getline(1, '$'))\n  call assert_equal('\\n', histget(\"search\", -1))\n\n  call setline(1, [\"foo\\tbar\", \"bar\\<C-H>foo\"])\n  let a = execute('%s/\\n//#')\n  call assert_equal(\"\\n  1 foo     barbar^Hfoo\", a)\n  call assert_equal([\"foo\\tbarbar\\<C-H>foo\"], getline(1, '$'))\n  call assert_equal('\\n', histget(\"search\", -1))\n\n  call setline(1, ['foo', 'bar', 'baz', 'qux'])\n  call execute('1,2s/\\n//')\n  call assert_equal(['foobarbaz', 'qux'], getline(1, '$'))\n\n  bwipe!\nendfunc\n\nfunc Test_substitute_count()\n  new\n  call setline(1, ['foo foo', 'foo foo', 'foo foo', 'foo foo', 'foo foo'])\n  2\n\n  s/foo/bar/3\n  call assert_equal(['foo foo', 'bar foo', 'bar foo', 'bar foo', 'foo foo'],\n  \\                 getline(1, '$'))\n\n  call assert_fails('s/foo/bar/0', 'E939:')\n\n  call setline(1, ['foo foo', 'foo foo', 'foo foo', 'foo foo', 'foo foo'])\n  2,4s/foo/bar/ 10\n  call assert_equal(['foo foo', 'foo foo', 'foo foo', 'bar foo', 'bar foo'],\n        \\           getline(1, '$'))\n\n  bwipe!\nendfunc\n\n\" Test substitute 'n' flag (report number of matches, do not substitute).\nfunc Test_substitute_flag_n()\n  new\n  let lines = ['foo foo', 'foo foo', 'foo foo', 'foo foo', 'foo foo']\n  call setline(1, lines)\n\n  call assert_equal(\"\\n3 matches on 3 lines\", execute('2,4s/foo/bar/n'))\n  call assert_equal(\"\\n6 matches on 3 lines\", execute('2,4s/foo/bar/gn'))\n\n  \" c flag (confirm) should be ignored when using n flag.\n  call assert_equal(\"\\n3 matches on 3 lines\", execute('2,4s/foo/bar/nc'))\n\n  \" No substitution should have been done.\n  call assert_equal(lines, getline(1, '$'))\n\n  %delete _\n  call setline(1, ['A', 'Bar', 'Baz'])\n  call assert_equal(\"\\n1 match on 1 line\", execute('s/\\nB\\@=//gn'))\n\n  bwipe!\nendfunc\n\nfunc Test_substitute_errors()\n  new\n  call setline(1, 'foobar')\n\n  call assert_fails('s/FOO/bar/', 'E486:')\n  call assert_fails('s/foo/bar/@', 'E488:')\n  call assert_fails('s/\\(/bar/', 'E54:')\n  call assert_fails('s afooabara', 'E146:')\n  call assert_fails('s\\\\a', 'E10:')\n\n  setl nomodifiable\n  call assert_fails('s/foo/bar/', 'E21:')\n\n  call assert_fails(\"let s=substitute([], 'a', 'A', 'g')\", 'E730:')\n  call assert_fails(\"let s=substitute('abcda', [], 'A', 'g')\", 'E730:')\n  call assert_fails(\"let s=substitute('abcda', 'a', [], 'g')\", 'E730:')\n  call assert_fails(\"let s=substitute('abcda', 'a', 'A', [])\", 'E730:')\n  call assert_fails(\"let s=substitute('abc', '\\\\%(', 'A', 'g')\", 'E53:')\n\n  bwipe!\nendfunc\n\n\" Test for *sub-replace-special* and *sub-replace-expression* on substitute().\nfunc Test_sub_replace_1()\n  \" Run the tests with 'magic' on\n  set magic\n  set cpo&\n  call assert_equal('AA', substitute('A', 'A', '&&', ''))\n  call assert_equal('&', substitute('B', 'B', '\\&', ''))\n  call assert_equal('C123456789987654321', substitute('C123456789', 'C\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)', '\\0\\9\\8\\7\\6\\5\\4\\3\\2\\1', ''))\n  call assert_equal('d', substitute('D', 'D', 'd', ''))\n  call assert_equal('~', substitute('E', 'E', '~', ''))\n  call assert_equal('~', substitute('F', 'F', '\\~', ''))\n  call assert_equal('Gg', substitute('G', 'G', '\\ugg', ''))\n  call assert_equal('Hh', substitute('H', 'H', '\\Uh\\Eh', ''))\n  call assert_equal('iI', substitute('I', 'I', '\\lII', ''))\n  call assert_equal('jJ', substitute('J', 'J', '\\LJ\\EJ', ''))\n  call assert_equal('Kk', substitute('K', 'K', '\\Uk\\ek', ''))\n  call assert_equal(\"l\\<C-V>\\<C-M>l\",\n\t\t\t\\ substitute('lLl', 'L', \"\\<C-V>\\<C-M>\", ''))\n  call assert_equal(\"m\\<C-M>m\", substitute('mMm', 'M', '\\r', ''))\n  call assert_equal(\"n\\<C-V>\\<C-M>n\",\n\t\t\t\\ substitute('nNn', 'N', \"\\\\\\<C-V>\\<C-M>\", ''))\n  call assert_equal(\"o\\no\", substitute('oOo', 'O', '\\n', ''))\n  call assert_equal(\"p\\<C-H>p\", substitute('pPp', 'P', '\\b', ''))\n  call assert_equal(\"q\\tq\", substitute('qQq', 'Q', '\\t', ''))\n  call assert_equal('r\\r', substitute('rRr', 'R', '\\\\', ''))\n  call assert_equal('scs', substitute('sSs', 'S', '\\c', ''))\n  call assert_equal(\"u\\nu\", substitute('uUu', 'U', \"\\n\", ''))\n  call assert_equal(\"v\\<C-H>v\", substitute('vVv', 'V', \"\\b\", ''))\n  call assert_equal(\"w\\\\w\", substitute('wWw', 'W', \"\\\\\", ''))\n  call assert_equal(\"x\\<C-M>x\", substitute('xXx', 'X', \"\\r\", ''))\n  call assert_equal(\"YyyY\", substitute('Y', 'Y', '\\L\\uyYy\\l\\EY', ''))\n  call assert_equal(\"zZZz\", substitute('Z', 'Z', '\\U\\lZzZ\\u\\Ez', ''))\n  \" \\v or \\V after $\n  call assert_equal('abxx', substitute('abcd', 'xy$\\v|cd$', 'xx', ''))\n  call assert_equal('abxx', substitute('abcd', 'xy$\\V\\|cd\\$', 'xx', ''))\nendfunc\n\nfunc Test_sub_replace_2()\n  \" Run the tests with 'magic' off\n  set nomagic\n  set cpo&\n  call assert_equal('AA', substitute('A', 'A', '&&', ''))\n  call assert_equal('&', substitute('B', 'B', '\\&', ''))\n  call assert_equal('C123456789987654321', substitute('C123456789', 'C\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)', '\\0\\9\\8\\7\\6\\5\\4\\3\\2\\1', ''))\n  call assert_equal('d', substitute('D', 'D', 'd', ''))\n  call assert_equal('~', substitute('E', 'E', '~', ''))\n  call assert_equal('~', substitute('F', 'F', '\\~', ''))\n  call assert_equal('Gg', substitute('G', 'G', '\\ugg', ''))\n  call assert_equal('Hh', substitute('H', 'H', '\\Uh\\Eh', ''))\n  call assert_equal('iI', substitute('I', 'I', '\\lII', ''))\n  call assert_equal('jJ', substitute('J', 'J', '\\LJ\\EJ', ''))\n  call assert_equal('Kk', substitute('K', 'K', '\\Uk\\ek', ''))\n  call assert_equal(\"l\\<C-V>\\<C-M>l\",\n\t\t\t\\ substitute('lLl', 'L', \"\\<C-V>\\<C-M>\", ''))\n  call assert_equal(\"m\\<C-M>m\", substitute('mMm', 'M', '\\r', ''))\n  call assert_equal(\"n\\<C-V>\\<C-M>n\",\n\t\t\t\\ substitute('nNn', 'N', \"\\\\\\<C-V>\\<C-M>\", ''))\n  call assert_equal(\"o\\no\", substitute('oOo', 'O', '\\n', ''))\n  call assert_equal(\"p\\<C-H>p\", substitute('pPp', 'P', '\\b', ''))\n  call assert_equal(\"q\\tq\", substitute('qQq', 'Q', '\\t', ''))\n  call assert_equal('r\\r', substitute('rRr', 'R', '\\\\', ''))\n  call assert_equal('scs', substitute('sSs', 'S', '\\c', ''))\n  call assert_equal(\"t\\<C-M>t\", substitute('tTt', 'T', \"\\r\", ''))\n  call assert_equal(\"u\\nu\", substitute('uUu', 'U', \"\\n\", ''))\n  call assert_equal(\"v\\<C-H>v\", substitute('vVv', 'V', \"\\b\", ''))\n  call assert_equal('w\\w', substitute('wWw', 'W', \"\\\\\", ''))\n  call assert_equal('XxxX', substitute('X', 'X', '\\L\\uxXx\\l\\EX', ''))\n  call assert_equal('yYYy', substitute('Y', 'Y', '\\U\\lYyY\\u\\Ey', ''))\nendfunc\n\nfunc Test_sub_replace_3()\n  set magic&\n  set cpo&\n  call assert_equal('a\\a', substitute('aAa', 'A', '\\=\"\\\\\"', ''))\n  call assert_equal('b\\\\b', substitute('bBb', 'B', '\\=\"\\\\\\\\\"', ''))\n  call assert_equal(\"c\\rc\", substitute('cCc', 'C', \"\\\\=\\\"\\r\\\"\", ''))\n  call assert_equal(\"d\\\\\\rd\", substitute('dDd', 'D', \"\\\\=\\\"\\\\\\\\\\r\\\"\", ''))\n  call assert_equal(\"e\\\\\\\\\\re\", substitute('eEe', 'E', \"\\\\=\\\"\\\\\\\\\\\\\\\\\\r\\\"\", ''))\n  call assert_equal('f\\rf', substitute('fFf', 'F', '\\=\"\\\\r\"', ''))\n  call assert_equal('j\\nj', substitute('jJj', 'J', '\\=\"\\\\n\"', ''))\n  call assert_equal(\"k\\<C-M>k\", substitute('kKk', 'K', '\\=\"\\r\"', ''))\n  call assert_equal(\"l\\nl\", substitute('lLl', 'L', '\\=\"\\n\"', ''))\nendfunc\n\n\" Test for submatch() on substitute().\nfunc Test_sub_replace_4()\n  set magic&\n  set cpo&\n  call assert_equal('a\\a', substitute('aAa', 'A',\n\t\t\\ '\\=substitute(submatch(0), \".\", \"\\\\\", \"\")', ''))\n  call assert_equal('b\\b', substitute('bBb', 'B',\n\t\t\\ '\\=substitute(submatch(0), \".\", \"\\\\\\\\\", \"\")', ''))\n  call assert_equal(\"c\\<C-V>\\<C-M>c\", substitute('cCc', 'C', '\\=substitute(submatch(0), \".\", \"\\<C-V>\\<C-M>\", \"\")', ''))\n  call assert_equal(\"d\\<C-V>\\<C-M>d\", substitute('dDd', 'D', '\\=substitute(submatch(0), \".\", \"\\\\\\<C-V>\\<C-M>\", \"\")', ''))\n  call assert_equal(\"e\\\\\\<C-V>\\<C-M>e\", substitute('eEe', 'E', '\\=substitute(submatch(0), \".\", \"\\\\\\\\\\<C-V>\\<C-M>\", \"\")', ''))\n  call assert_equal(\"f\\<C-M>f\", substitute('fFf', 'F', '\\=substitute(submatch(0), \".\", \"\\\\r\", \"\")', ''))\n  call assert_equal(\"j\\nj\", substitute('jJj', 'J', '\\=substitute(submatch(0), \".\", \"\\\\n\", \"\")', ''))\n  call assert_equal(\"k\\rk\", substitute('kKk', 'K', '\\=substitute(submatch(0), \".\", \"\\r\", \"\")', ''))\n  call assert_equal(\"l\\nl\", substitute('lLl', 'L', '\\=substitute(submatch(0), \".\", \"\\n\", \"\")', ''))\nendfunc\n\nfunc Test_sub_replace_5()\n  set magic&\n  set cpo&\n  call assert_equal('A123456789987654321', substitute('A123456789',\n\t\t\\ 'A\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)',\n\t\t\\ '\\=submatch(0) . submatch(9) . submatch(8) . ' .\n\t\t\\ 'submatch(7) . submatch(6) . submatch(5) . ' .\n\t\t\\ 'submatch(4) . submatch(3) . submatch(2) . submatch(1)',\n\t\t\\ ''))\n   call assert_equal(\"[['A123456789'], ['9'], ['8'], ['7'], ['6'], \" .\n\t\t\\ \"['5'], ['4'], ['3'], ['2'], ['1']]\",\n\t\t\\ substitute('A123456789',\n\t\t\\ 'A\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)',\n\t\t\\ '\\=string([submatch(0, 1), submatch(9, 1), ' .\n\t\t\\ 'submatch(8, 1), 7->submatch(1), submatch(6, 1), ' .\n\t\t\\ 'submatch(5, 1), submatch(4, 1), submatch(3, 1), ' .\n\t\t\\ 'submatch(2, 1), submatch(1, 1)])',\n\t\t\\ ''))\nendfunc\n\nfunc Test_sub_replace_6()\n  set magic&\n  set cpo+=/\n  call assert_equal('a', substitute('A', 'A', 'a', ''))\n  call assert_equal('%', substitute('B', 'B', '%', ''))\n  set cpo-=/\n  call assert_equal('c', substitute('C', 'C', 'c', ''))\n  call assert_equal('%', substitute('D', 'D', '%', ''))\nendfunc\n\nfunc Test_sub_replace_7()\n  set magic&\n  set cpo&\n  call assert_equal('A\u0016A', substitute('A\u0016A', 'A.', '\\=submatch(0)', ''))\n  call assert_equal(\"B\\nB\", substitute(\"B\\nB\", 'B.', '\\=submatch(0)', ''))\n  call assert_equal(\"['B\\n']B\", substitute(\"B\\nB\", 'B.', '\\=string(submatch(0, 1))', ''))\n  call assert_equal('-abab', substitute('-bb', '\\zeb', 'a', 'g'))\n  call assert_equal('c-cbcbc', substitute('-bb', '\\ze', 'c', 'g'))\nendfunc\n\n\" Test for *:s%* on :substitute.\nfunc Test_sub_replace_8()\n  new\n  set magic&\n  set cpo&\n  $put =',,X'\n  s/\\(^\\|,\\)\\ze\\(,\\|X\\)/\\1N/g\n  call assert_equal('N,,NX', getline(\"$\"))\n  $put =',,Y'\n  let cmd = ':s/\\(^\\|,\\)\\ze\\(,\\|Y\\)/\\1N/gc'\n  call feedkeys(cmd . \"\\<CR>a\", \"xt\")\n  call assert_equal('N,,NY', getline(\"$\"))\n  :$put =',,Z'\n  let cmd = ':s/\\(^\\|,\\)\\ze\\(,\\|Z\\)/\\1N/gc'\n  call feedkeys(cmd . \"\\<CR>yy\", \"xt\")\n  call assert_equal('N,,NZ', getline(\"$\"))\n  enew! | close\nendfunc\n\nfunc Test_sub_replace_9()\n  new\n  set magic&\n  set cpo&\n  $put ='xxx'\n  call feedkeys(\":s/x/X/gc\\<CR>yyq\", \"xt\")\n  call assert_equal('XXx', getline(\"$\"))\n  enew! | close\nendfunc\n\nfunc Test_sub_replace_10()\n   set magic&\n   set cpo&\n   call assert_equal('a1a2a3a', substitute('123', '\\zs', 'a', 'g'))\n   call assert_equal('aaa', substitute('123', '\\zs.', 'a', 'g'))\n   call assert_equal('1a2a3a', substitute('123', '.\\zs', 'a', 'g'))\n   call assert_equal('a1a2a3a', substitute('123', '\\ze', 'a', 'g'))\n   call assert_equal('a1a2a3', substitute('123', '\\ze.', 'a', 'g'))\n   call assert_equal('aaa', substitute('123', '.\\ze', 'a', 'g'))\n   call assert_equal('aa2a3a', substitute('123', '1\\|\\ze', 'a', 'g'))\n   call assert_equal('1aaa', substitute('123', '1\\zs\\|[23]', 'a', 'g'))\nendfunc\n\nfunc SubReplacer(text, submatches)\n  return a:text .. a:submatches[0] .. a:text\nendfunc\nfunc SubReplacerVar(text, ...)\n  return a:text .. a:1[0] .. a:text\nendfunc\ndef SubReplacerVar9(text: string, ...args: list<list<string>>): string\n  return text .. args[0][0] .. text\nenddef\nfunc SubReplacer20(t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18, t19, submatches)\n  return a:t3 .. a:submatches[0] .. a:t11\nendfunc\n\nfunc Test_substitute_partial()\n  call assert_equal('1foo2foo3', substitute('123', '2', function('SubReplacer', ['foo']), 'g'))\n  call assert_equal('1foo2foo3', substitute('123', '2', function('SubReplacerVar', ['foo']), 'g'))\n  call assert_equal('1foo2foo3', substitute('123', '2', function('SubReplacerVar9', ['foo']), 'g'))\n\n  \" 19 arguments plus one is just OK\n  let Replacer = function('SubReplacer20', repeat(['foo'], 19))\n  call assert_equal('1foo2foo3', substitute('123', '2', Replacer, 'g'))\n\n  \" 20 arguments plus one is too many\n  let Replacer = function('SubReplacer20', repeat(['foo'], 20))\n  call assert_fails(\"call substitute('123', '2', Replacer, 'g')\", 'E118:')\nendfunc\n\nfunc Test_substitute_float()\n  call assert_equal('number 1.23', substitute('number ', '$', { -> 1.23 }, ''))\n  vim9 assert_equal('number 1.23', substitute('number ', '$', () => 1.23, ''))\nendfunc\n\n\" Tests for *sub-replace-special* and *sub-replace-expression* on :substitute.\n\n\" Execute a list of :substitute command tests\nfunc Run_SubCmd_Tests(tests)\n  enew!\n  for t in a:tests\n    let start = line('.') + 1\n    let end = start + len(t[2]) - 1\n    exe \"normal o\" . t[0]\n    call cursor(start, 1)\n    exe t[1]\n    call assert_equal(t[2], getline(start, end), t[1])\n  endfor\n  enew!\nendfunc\n\nfunc Test_sub_cmd_1()\n  set magic\n  set cpo&\n\n  \" List entry format: [input, cmd, output]\n  let tests = [['A', 's/A/&&/', ['AA']],\n\t      \\ ['B', 's/B/\\&/', ['&']],\n\t      \\ ['C123456789', 's/C\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)/\\0\\9\\8\\7\\6\\5\\4\\3\\2\\1/', ['C123456789987654321']],\n\t      \\ ['D', 's/D/d/', ['d']],\n\t      \\ ['E', 's/E/~/', ['d']],\n\t      \\ ['F', 's/F/\\~/', ['~']],\n\t      \\ ['G', 's/G/\\ugg/', ['Gg']],\n\t      \\ ['H', 's/H/\\Uh\\Eh/', ['Hh']],\n\t      \\ ['I', 's/I/\\lII/', ['iI']],\n\t      \\ ['J', 's/J/\\LJ\\EJ/', ['jJ']],\n\t      \\ ['K', 's/K/\\Uk\\ek/', ['Kk']],\n\t      \\ ['lLl', \"s/L/\\<C-V>\\<C-M>/\", [\"l\\<C-V>\", 'l']],\n\t      \\ ['mMm', 's/M/\\r/', ['m', 'm']],\n\t      \\ ['nNn', \"s/N/\\\\\\<C-V>\\<C-M>/\", [\"n\\<C-V>\", 'n']],\n\t      \\ ['oOo', 's/O/\\n/', [\"o\\no\"]],\n\t      \\ ['pPp', 's/P/\\b/', [\"p\\<C-H>p\"]],\n\t      \\ ['qQq', 's/Q/\\t/', [\"q\\tq\"]],\n\t      \\ ['rRr', 's/R/\\\\/', ['r\\r']],\n\t      \\ ['sSs', 's/S/\\c/', ['scs']],\n\t      \\ ['tTt', \"s/T/\\<C-V>\\<C-J>/\", [\"t\\<C-V>\\<C-J>t\"]],\n\t      \\ ['U', 's/U/\\L\\uuUu\\l\\EU/', ['UuuU']],\n\t      \\ ['V', 's/V/\\U\\lVvV\\u\\Ev/', ['vVVv']],\n\t      \\ ['\\', 's/\\\\/\\\\\\\\/', ['\\\\']]\n\t      \\ ]\n  call Run_SubCmd_Tests(tests)\nendfunc\n\nfunc Test_sub_cmd_2()\n  set nomagic\n  set cpo&\n\n  \" List entry format: [input, cmd, output]\n  let tests = [['A', 's/A/&&/', ['&&']],\n\t      \\ ['B', 's/B/\\&/', ['B']],\n\t      \\ ['C123456789', 's/\\mC\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)/\\0\\9\\8\\7\\6\\5\\4\\3\\2\\1/', ['C123456789987654321']],\n\t      \\ ['D', 's/D/d/', ['d']],\n\t      \\ ['E', 's/E/~/', ['~']],\n\t      \\ ['F', 's/F/\\~/', ['~']],\n\t      \\ ['G', 's/G/\\ugg/', ['Gg']],\n\t      \\ ['H', 's/H/\\Uh\\Eh/', ['Hh']],\n\t      \\ ['I', 's/I/\\lII/', ['iI']],\n\t      \\ ['J', 's/J/\\LJ\\EJ/', ['jJ']],\n\t      \\ ['K', 's/K/\\Uk\\ek/', ['Kk']],\n\t      \\ ['lLl', \"s/L/\\<C-V>\\<C-M>/\", [\"l\\<C-V>\", 'l']],\n\t      \\ ['mMm', 's/M/\\r/', ['m', 'm']],\n\t      \\ ['nNn', \"s/N/\\\\\\<C-V>\\<C-M>/\", [\"n\\<C-V>\", 'n']],\n\t      \\ ['oOo', 's/O/\\n/', [\"o\\no\"]],\n\t      \\ ['pPp', 's/P/\\b/', [\"p\\<C-H>p\"]],\n\t      \\ ['qQq', 's/Q/\\t/', [\"q\\tq\"]],\n\t      \\ ['rRr', 's/R/\\\\/', ['r\\r']],\n\t      \\ ['sSs', 's/S/\\c/', ['scs']],\n\t      \\ ['tTt', \"s/T/\\<C-V>\\<C-J>/\", [\"t\\<C-V>\\<C-J>t\"]],\n\t      \\ ['U', 's/U/\\L\\uuUu\\l\\EU/', ['UuuU']],\n\t      \\ ['V', 's/V/\\U\\lVvV\\u\\Ev/', ['vVVv']],\n\t      \\ ['\\', 's/\\\\/\\\\\\\\/', ['\\\\']]\n\t      \\ ]\n  call Run_SubCmd_Tests(tests)\nendfunc\n\nfunc Test_sub_cmd_3()\n  set nomagic\n  set cpo&\n\n  \" List entry format: [input, cmd, output]\n  let tests = [['aAa', \"s/A/\\\\='\\\\'/\", ['a\\a']],\n\t      \\ ['bBb', \"s/B/\\\\='\\\\\\\\'/\", ['b\\\\b']],\n\t      \\ ['cCc', \"s/C/\\\\='\\<C-V>\\<C-M>'/\", [\"c\\<C-V>\", 'c']],\n\t      \\ ['dDd', \"s/D/\\\\='\\\\\\<C-V>\\<C-M>'/\", [\"d\\\\\\<C-V>\", 'd']],\n\t      \\ ['eEe', \"s/E/\\\\='\\\\\\\\\\<C-V>\\<C-M>'/\", [\"e\\\\\\\\\\<C-V>\", 'e']],\n\t      \\ ['fFf', \"s/F/\\\\='\\r'/\", ['f', 'f']],\n\t      \\ ['gGg', \"s/G/\\\\='\\<C-V>\\<C-J>'/\", [\"g\\<C-V>\", 'g']],\n\t      \\ ['hHh', \"s/H/\\\\='\\\\\\<C-V>\\<C-J>'/\", [\"h\\\\\\<C-V>\", 'h']],\n\t      \\ ['iIi', \"s/I/\\\\='\\\\\\\\\\<C-V>\\<C-J>'/\", [\"i\\\\\\\\\\<C-V>\", 'i']],\n\t      \\ ['jJj', \"s/J/\\\\='\\n'/\", ['j', 'j']],\n\t      \\ ['kKk', 's/K/\\=\"\\r\"/', ['k', 'k']],\n\t      \\ ['lLl', 's/L/\\=\"\\n\"/', ['l', 'l']]\n\t      \\ ]\n  call Run_SubCmd_Tests(tests)\nendfunc\n\n\" Test for submatch() on :substitute.\nfunc Test_sub_cmd_4()\n  set magic&\n  set cpo&\n\n  \" List entry format: [input, cmd, output]\n  let tests = [ ['aAa', \"s/A/\\\\=substitute(submatch(0), '.', '\\\\', '')/\",\n\t      \\\t\t\t\t['a\\a']],\n\t      \\ ['bBb', \"s/B/\\\\=substitute(submatch(0), '.', '\\\\', '')/\",\n\t      \\\t\t\t\t['b\\b']],\n\t      \\ ['cCc', \"s/C/\\\\=substitute(submatch(0), '.', '\\<C-V>\\<C-M>', '')/\",\n\t      \\\t\t\t\t[\"c\\<C-V>\", 'c']],\n\t      \\ ['dDd', \"s/D/\\\\=substitute(submatch(0), '.', '\\\\\\<C-V>\\<C-M>', '')/\",\n\t      \\\t\t\t\t[\"d\\<C-V>\", 'd']],\n\t      \\ ['eEe', \"s/E/\\\\=substitute(submatch(0), '.', '\\\\\\\\\\<C-V>\\<C-M>', '')/\",\n\t      \\\t\t\t\t[\"e\\\\\\<C-V>\", 'e']],\n\t      \\ ['fFf', \"s/F/\\\\=substitute(submatch(0), '.', '\\\\r', '')/\",\n\t      \\\t\t\t\t['f', 'f']],\n\t      \\ ['gGg', 's/G/\\=substitute(submatch(0), \".\", \"\\<C-V>\\<C-J>\", \"\")/',\n\t      \\\t\t\t\t[\"g\\<C-V>\", 'g']],\n\t      \\ ['hHh', 's/H/\\=substitute(submatch(0), \".\", \"\\\\\\<C-V>\\<C-J>\", \"\")/',\n\t      \\\t\t\t\t[\"h\\<C-V>\", 'h']],\n\t      \\ ['iIi', 's/I/\\=substitute(submatch(0), \".\", \"\\\\\\\\\\<C-V>\\<C-J>\", \"\")/',\n\t      \\\t\t\t\t[\"i\\\\\\<C-V>\", 'i']],\n\t      \\ ['jJj', \"s/J/\\\\=substitute(submatch(0), '.', '\\\\n', '')/\",\n\t      \\\t\t\t\t['j', 'j']],\n\t      \\ ['kKk', \"s/K/\\\\=substitute(submatch(0), '.', '\\\\r', '')/\",\n\t      \\\t\t\t\t['k', 'k']],\n\t      \\ ['lLl', \"s/L/\\\\=substitute(submatch(0), '.', '\\\\n', '')/\",\n\t      \\\t\t\t\t['l', 'l']],\n\t      \\ ]\n  call Run_SubCmd_Tests(tests)\nendfunc\n\nfunc Test_sub_cmd_5()\n  set magic&\n  set cpo&\n\n  \" List entry format: [input, cmd, output]\n  let tests = [ ['A123456789', 's/A\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)/\\=submatch(0) . submatch(9) . submatch(8) . submatch(7) . submatch(6) . submatch(5) . submatch(4) . submatch(3) . submatch(2) . submatch(1)/', ['A123456789987654321']],\n\t      \\ ['B123456789', 's/B\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)/\\=string([submatch(0, 1), submatch(9, 1), submatch(8, 1), submatch(7, 1), submatch(6, 1), submatch(5, 1), submatch(4, 1), submatch(3, 1), submatch(2, 1), submatch(1, 1)])/', [\"[['B123456789'], ['9'], ['8'], ['7'], ['6'], ['5'], ['4'], ['3'], ['2'], ['1']]\"]],\n\t      \\ ]\n  call Run_SubCmd_Tests(tests)\nendfunc\n\n\" Test for *:s%* on :substitute.\nfunc Test_sub_cmd_6()\n  set magic&\n  set cpo+=/\n\n  \" List entry format: [input, cmd, output]\n  let tests = [ ['A', 's/A/a/', ['a']],\n\t      \\ ['B', 's/B/%/', ['a']],\n\t      \\ ]\n  call Run_SubCmd_Tests(tests)\n\n  set cpo-=/\n  let tests = [ ['C', 's/C/c/', ['c']],\n\t      \\ ['D', 's/D/%/', ['%']],\n\t      \\ ]\n  call Run_SubCmd_Tests(tests)\n\n  set cpo&\nendfunc\n\n\" Test for :s replacing \\n with  line break.\nfunc Test_sub_cmd_7()\n  set magic&\n  set cpo&\n\n  \" List entry format: [input, cmd, output]\n  let tests = [ [\"A\\<C-V>\\<C-M>A\", 's/A./\\=submatch(0)/', ['A', 'A']],\n\t      \\ [\"B\\<C-V>\\<C-J>B\", 's/B./\\=submatch(0)/', ['B', 'B']],\n\t      \\ [\"C\\<C-V>\\<C-J>C\", 's/C./\\=strtrans(string(submatch(0, 1)))/', [strtrans(\"['C\\<C-J>']C\")]],\n\t      \\ [\"D\\<C-V>\\<C-J>\\nD\", 's/D.\\nD/\\=strtrans(string(submatch(0, 1)))/', [strtrans(\"['D\\<C-J>', 'D']\")]],\n\t      \\ [\"E\\<C-V>\\<C-J>\\n\\<C-V>\\<C-J>\\n\\<C-V>\\<C-J>\\n\\<C-V>\\<C-J>\\n\\<C-V>\\<C-J>E\", 's/E\\_.\\{-}E/\\=strtrans(string(submatch(0, 1)))/', [strtrans(\"['E\\<C-J>', '\\<C-J>', '\\<C-J>', '\\<C-J>', '\\<C-J>E']\")]],\n\t      \\ ]\n  call Run_SubCmd_Tests(tests)\n\n  exe \"normal oQ\\nQ\\<Esc>k\"\n  call assert_fails('s/Q[^\\n]Q/\\=submatch(0).\"foobar\"/', 'E486:')\n  enew!\nendfunc\n\nfunc TitleString()\n  let check = 'foo' =~ 'bar'\n  return \"\"\nendfunc\n\nfunc Test_sub_cmd_8()\n  set titlestring=%{TitleString()}\n\n  enew!\n  call append(0, ['', 'test_one', 'test_two'])\n  call cursor(1,1)\n  /^test_one/s/.*/\\=\"foo\\nbar\"/\n  call assert_equal('foo', getline(2))\n  call assert_equal('bar', getline(3))\n  call feedkeys(':/^test_two/s/.*/\\=\"foo\\nbar\"/c', \"t\")\n  call feedkeys(\"\\<CR>y\", \"xt\")\n  call assert_equal('foo', getline(4))\n  call assert_equal('bar', getline(5))\n\n  enew!\n  set titlestring&\nendfunc\n\nfunc Test_sub_cmd_9()\n  new\n  let input = ['1 aaa', '2 aaa', '3 aaa']\n  call setline(1, input)\n  func Foo()\n    return submatch(0)\n  endfunc\n  %s/aaa/\\=Foo()/gn\n  call assert_equal(input, getline(1, '$'))\n  call assert_equal(1, &modifiable)\n\n  delfunc Foo\n  bw!\nendfunc\n\nfunc Test_sub_highlight_zero_match()\n  CheckRunVimInTerminal\n\n  let lines =<< trim END\n    call setline(1, ['one', 'two', 'three'])\n  END\n  call writefile(lines, 'XscriptSubHighlight', 'D')\n  let buf = RunVimInTerminal('-S XscriptSubHighlight', #{rows: 8, cols: 60})\n  call term_sendkeys(buf, \":%s/^/   /c\\<CR>\")\n  call VerifyScreenDump(buf, 'Test_sub_highlight_zer_match_1', {})\n\n  call term_sendkeys(buf, \"\\<Esc>\")\n  call StopVimInTerminal(buf)\nendfunc\n\nfunc Test_nocatch_sub_failure_handling()\n  \" normal error results in all replacements\n  func Foo()\n    foobar\n  endfunc\n  new\n  call setline(1, ['1 aaa', '2 aaa', '3 aaa'])\n  \" need silent! to avoid a delay when entering Insert mode\n  silent! %s/aaa/\\=Foo()/g\n  call assert_equal(['1 0', '2 0', '3 0'], getline(1, 3))\n\n  \" Throw without try-catch causes abort after the first line.\n  \" We cannot test this, since it would stop executing the test script.\n\n  \" try/catch does not result in any changes\n  func! Foo()\n    throw 'error'\n  endfunc\n  call setline(1, ['1 aaa', '2 aaa', '3 aaa'])\n  let error_caught = 0\n  try\n    %s/aaa/\\=Foo()/g\n  catch\n    let error_caught = 1\n  endtry\n  call assert_equal(1, error_caught)\n  call assert_equal(['1 aaa', '2 aaa', '3 aaa'], getline(1, 3))\n\n  \" Same, but using \"n\" flag so that \"sandbox\" gets set\n  call setline(1, ['1 aaa', '2 aaa', '3 aaa'])\n  let error_caught = 0\n  try\n    %s/aaa/\\=Foo()/gn\n  catch\n    let error_caught = 1\n  endtry\n  call assert_equal(1, error_caught)\n  call assert_equal(['1 aaa', '2 aaa', '3 aaa'], getline(1, 3))\n\n  delfunc Foo\n  bwipe!\nendfunc\n\n\" Test \":s/pat/sub/\" with different ~s in sub.\nfunc Test_replace_with_tilde()\n  new\n  \" Set the last replace string to empty\n  s/^$//\n  call append(0, ['- Bug in \"vPPPP\" on this text:'])\n  normal gg\n  s/u/~u~/\n  call assert_equal('- Bug in \"vPPPP\" on this text:', getline(1))\n  s/i/~u~/\n  call assert_equal('- Bug uuun \"vPPPP\" on this text:', getline(1))\n  s/o/~~~/\n  call assert_equal('- Bug uuun \"vPPPP\" uuuuuuuuun this text:', getline(1))\n  close!\nendfunc\n\nfunc Test_replace_keeppatterns()\n  new\n  a\nfoobar\n\nsubstitute foo asdf\n\none two\n.\n\n  normal gg\n  /^substitute\n  s/foo/bar/\n  call assert_equal('foo', @/)\n  call assert_equal('substitute bar asdf', getline('.'))\n\n  /^substitute\n  keeppatterns s/asdf/xyz/\n  call assert_equal('^substitute', @/)\n  call assert_equal('substitute bar xyz', getline('.'))\n\n  exe \"normal /bar /e\\<CR>\"\n  call assert_equal(15, col('.'))\n  normal -\n  keeppatterns /xyz\n  call assert_equal('bar ', @/)\n  call assert_equal('substitute bar xyz', getline('.'))\n  exe \"normal 0dn\"\n  call assert_equal('xyz', getline('.'))\n\n  close!\nendfunc\n\nfunc Test_sub_beyond_end()\n  new\n  call setline(1, '#')\n  let @/ = '^#\\n\\zs'\n  s///e\n  call assert_equal('#', getline(1))\n  bwipe!\nendfunc\n\n\" Test for repeating last substitution using :~ and :&r\nfunc Test_repeat_last_sub()\n  new\n  call setline(1, ['blue green yellow orange white'])\n  s/blue/red/\n  let @/ = 'yellow'\n  ~\n  let @/ = 'white'\n  :&r\n  let @/ = 'green'\n  s//gray\n  call assert_equal('red gray red orange red', getline(1))\n  close!\nendfunc\n\n\" Test for Vi compatible substitution:\n\"     \\/{string}/, \\?{string}? and \\&{string}&\nfunc Test_sub_vi_compatibility()\n  new\n  call setline(1, ['blue green yellow orange blue'])\n  let @/ = 'orange'\n  s\\/white/\n  let @/ = 'blue'\n  s\\?amber?\n  let @/ = 'white'\n  s\\&green&\n  call assert_equal('amber green yellow white green', getline(1))\n  close!\n\n  call assert_fails('vim9cmd s\\/white/', 'E1270:')\n  call assert_fails('vim9cmd s\\?white?', 'E1270:')\n  call assert_fails('vim9cmd s\\&white&', 'E1270:')\nendfunc\n\n\" Test for substitute with the new text longer than the original text\nfunc Test_sub_expand_text()\n  new\n  call setline(1, 'abcabcabcabcabcabcabcabc')\n  s/b/\\=repeat('B', 10)/g\n  call assert_equal(repeat('aBBBBBBBBBBc', 8), getline(1))\n  close!\nendfunc\n\n\" Test for command failures when the last substitute pattern is not set.\nfunc Test_sub_with_no_last_pat()\n  let lines =<< trim [SCRIPT]\n    call assert_fails('~', 'E33:')\n    call assert_fails('s//abc/g', 'E35:')\n    call assert_fails('s\\/bar', 'E35:')\n    call assert_fails('s\\&bar&', 'E33:')\n    call writefile(v:errors, 'Xresult')\n    qall!\n  [SCRIPT]\n  call writefile(lines, 'Xscript', 'D')\n  if RunVim([], [], '--clean -S Xscript')\n    call assert_equal([], readfile('Xresult'))\n  endif\n\n  let lines =<< trim [SCRIPT]\n    set cpo+=/\n    call assert_fails('s/abc/%/', 'E33:')\n    call writefile(v:errors, 'Xresult')\n    qall!\n  [SCRIPT]\n  call writefile(lines, 'Xscript')\n  if RunVim([], [], '--clean -S Xscript')\n    call assert_equal([], readfile('Xresult'))\n  endif\n\n  call delete('Xresult')\nendfunc\n\nfunc Test_substitute()\n  call assert_equal('a\uff11a\uff12a\uff13a', substitute('\uff11\uff12\uff13', '\\zs', 'a', 'g'))\n  \" Substitute with special keys\n  call assert_equal(\"a\\<End>c\", substitute('abc', \"a.c\", \"a\\<End>c\", ''))\nendfunc\n\nfunc Test_substitute_expr()\n  let g:val = 'XXX'\n  call assert_equal('XXX', substitute('yyy', 'y*', '\\=g:val', ''))\n  call assert_equal('XXX', substitute('yyy', 'y*', {-> g:val}, ''))\n  call assert_equal(\"-\\u1b \\uf2-\", substitute(\"-%1b %f2-\", '%\\(\\x\\x\\)',\n\t\t\t   \\ '\\=nr2char(\"0x\" . submatch(1))', 'g'))\n  call assert_equal(\"-\\u1b \\uf2-\", substitute(\"-%1b %f2-\", '%\\(\\x\\x\\)',\n\t\t\t   \\ {-> nr2char(\"0x\" . submatch(1))}, 'g'))\n\n  call assert_equal('231', substitute('123', '\\(.\\)\\(.\\)\\(.\\)',\n\t\\ {-> submatch(2) . submatch(3) . submatch(1)}, ''))\n\n  func Recurse()\n    return substitute('yyy', 'y\\(.\\)y', {-> submatch(1)}, '')\n  endfunc\n  \" recursive call works\n  call assert_equal('-y-x-', substitute('xxx', 'x\\(.\\)x', {-> '-' . Recurse() . '-' . submatch(1) . '-'}, ''))\n\n  call assert_fails(\"let s=submatch([])\", 'E745:')\n  call assert_fails(\"let s=submatch(2, [])\", 'E745:')\nendfunc\n\nfunc Test_invalid_submatch()\n  \" This was causing invalid memory access in Vim-7.4.2232 and older\n  call assert_fails(\"call substitute('x', '.', {-> submatch(10)}, '')\", 'E935:')\n  call assert_fails('eval submatch(-1)', 'E935:')\n  call assert_equal('', submatch(0))\n  call assert_equal('', submatch(1))\n  call assert_equal([], submatch(0, 1))\n  call assert_equal([], submatch(1, 1))\nendfunc\n\nfunc Test_submatch_list_concatenate()\n  let pat = 'A\\(.\\)'\n  let Rep = {-> string([submatch(0, 1)] + [[submatch(1)]])}\n  call substitute('A1', pat, Rep, '')->assert_equal(\"[['A1'], ['1']]\")\nendfunc\n\nfunc Test_substitute_expr_arg()\n  call assert_equal('123456789-123456789=', substitute('123456789',\n\t\\ '\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)\\(.\\)',\n\t\\ {m -> m[0] . '-' . m[1] . m[2] . m[3] . m[4] . m[5] . m[6] . m[7] . m[8] . m[9] . '='}, ''))\n\n  call assert_equal('123456-123456=789', substitute('123456789',\n\t\\ '\\(.\\)\\(.\\)\\(.\\)\\(a*\\)\\(n*\\)\\(.\\)\\(.\\)\\(.\\)\\(x*\\)',\n\t\\ {m -> m[0] . '-' . m[1] . m[2] . m[3] . m[4] . m[5] . m[6] . m[7] . m[8] . m[9] . '='}, ''))\n\n  call assert_equal('123456789-123456789x=', substitute('123456789',\n\t\\ '\\(.\\)\\(.\\)\\(.*\\)',\n\t\\ {m -> m[0] . '-' . m[1] . m[2] . m[3] . 'x' . m[4] . m[5] . m[6] . m[7] . m[8] . m[9] . '='}, ''))\n\n  call assert_fails(\"call substitute('xxx', '.', {m -> string(add(m, 'x'))}, '')\", 'E742:')\n  call assert_fails(\"call substitute('xxx', '.', {m -> string(insert(m, 'x'))}, '')\", 'E742:')\n  call assert_fails(\"call substitute('xxx', '.', {m -> string(extend(m, ['x']))}, '')\", 'E742:')\n  call assert_fails(\"call substitute('xxx', '.', {m -> string(remove(m, 1))}, '')\", 'E742:')\nendfunc\n\n\" Test for using a function to supply the substitute string\nfunc Test_substitute_using_func()\n  func Xfunc()\n    return '1234'\n  endfunc\n  call assert_equal('a1234f', substitute('abcdef', 'b..e',\n        \\ function(\"Xfunc\"), ''))\n  delfunc Xfunc\nendfunc\n\n\" Test for using submatch() with a multiline match\nfunc Test_substitute_multiline_submatch()\n  new\n  call setline(1, ['line1', 'line2', 'line3', 'line4'])\n  %s/^line1\\(\\_.\\+\\)line4$/\\=submatch(1)/\n  call assert_equal(['', 'line2', 'line3', ''], getline(1, '$'))\n  close!\nendfunc\n\nfunc Test_substitute_skipped_range()\n  new\n  if 0\n    /1/5/2/2/\\n\n  endif\n  call assert_equal([0, 1, 1, 0, 1], getcurpos())\n  bwipe!\nendfunc\n\n\" Test using the 'gdefault' option (when on, flag 'g' is default on).\nfunc Test_substitute_gdefault()\n  new\n\n  \" First check without 'gdefault'\n  call setline(1, 'foo bar foo')\n  s/foo/FOO/\n  call assert_equal('FOO bar foo', getline(1))\n  call setline(1, 'foo bar foo')\n  s/foo/FOO/g\n  call assert_equal('FOO bar FOO', getline(1))\n  call setline(1, 'foo bar foo')\n  s/foo/FOO/gg\n  call assert_equal('FOO bar foo', getline(1))\n\n  \" Then check with 'gdefault'\n  set gdefault\n  call setline(1, 'foo bar foo')\n  s/foo/FOO/\n  call assert_equal('FOO bar FOO', getline(1))\n  call setline(1, 'foo bar foo')\n  s/foo/FOO/g\n  call assert_equal('FOO bar foo', getline(1))\n  call setline(1, 'foo bar foo')\n  s/foo/FOO/gg\n  call assert_equal('FOO bar FOO', getline(1))\n\n  \" Setting 'compatible' should reset 'gdefault'\n  call assert_equal(1, &gdefault)\n  set compatible\n  call assert_equal(0, &gdefault)\n  set nocompatible\n  call assert_equal(0, &gdefault)\n\n  bw!\nendfunc\n\n\" This was using \"old_sub\" after it was freed.\nfunc Test_using_old_sub()\n  set compatible maxfuncdepth=10\n  new\n  call setline(1, 'some text.')\n  func Repl()\n    ~\n    s/\n  endfunc\n  silent! s/\\%')/\\=Repl()\n\n  delfunc Repl\n  bwipe!\n  set nocompatible\nendfunc\n\n\" This was switching windows in between computing the length and using it.\nfunc Test_sub_change_window()\n  silent! lfile\n  sil! norm o0000000000000000000000000000000000000000000000000000\n  func Repl()\n    lopen\n  endfunc\n  silent!  s/\\%')/\\=Repl()\n  bwipe!\n  bwipe!\n  delfunc Repl\nendfunc\n\n\" This was undoign a change in between computing the length and using it.\nfunc Do_Test_sub_undo_change()\n  new\n  norm o0000000000000000000000000000000000000000000000000000\n  silent! s/\\%')/\\=Repl()\n  bwipe!\nendfunc\n\nfunc Test_sub_undo_change()\n  func Repl()\n    silent! norm g-\n  endfunc\n  call Do_Test_sub_undo_change()\n\n  func! Repl()\n    silent earlier\n  endfunc\n  call Do_Test_sub_undo_change()\n\n  delfunc Repl\nendfunc\n\n\" This was opening a command line window from the expression\nfunc Test_sub_open_cmdline_win()\n  \" the error only happens in a very specific setup, run a new Vim instance to\n  \" get a clean starting point.\n  let lines =<< trim [SCRIPT]\n    set vb t_vb=\n    norm o0000000000000000000000000000000000000000000000000000\n    func Replace()\n      norm q/\n    endfunc\n    s/\\%')/\\=Replace()\n    redir >Xresult\n    messages\n    redir END\n    qall!\n  [SCRIPT]\n  call writefile(lines, 'Xscript', 'D')\n  if RunVim([], [], '-u NONE -S Xscript')\n    call assert_match('E565: Not allowed to change text or change window',\n          \\ readfile('Xresult')->join('XX'))\n  endif\n\n  call delete('Xresult')\nendfunc\n\n\" This was editing a script file from the expression\nfunc Test_sub_edit_scriptfile()\n  new\n  norm o0000000000000000000000000000000000000000000000000000\n  func EditScript()\n    silent! scr! Xsedfile\n  endfunc\n  s/\\%')/\\=EditScript()\n\n  delfunc EditScript\n  bwipe!\nendfunc\n\n\" This was editing another file from the expression.\nfunc Test_sub_expr_goto_other_file()\n  call writefile([''], 'Xfileone', 'D')\n  enew!\n  call setline(1, ['a', 'b', 'c', 'd',\n\t\\ 'Xfileone zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz'])\n\n  func g:SplitGotoFile()\n    exe \"sil! norm 0\\<C-W>gf\"\n    return ''\n  endfunc\n\n  $\n  s/\\%')/\\=g:SplitGotoFile()\n\n  delfunc g:SplitGotoFile\n  bwipe!\nendfunc\n\nfunc Test_recursive_expr_substitute()\n  \" this was reading invalid memory\n  let lines =<< trim END\n      func Repl(g, n)\n        s\n        r%:s000\n      endfunc\n      next 0\n      let caught = 0\n      s/\\%')/\\=Repl(0, 0)\n      qall!\n  END\n  call writefile(lines, 'XexprSubst', 'D')\n  call RunVim([], [], '--clean -S XexprSubst')\nendfunc\n\n\" Test for the 2-letter and 3-letter :substitute commands\nfunc Test_substitute_short_cmd()\n  new\n  call setline(1, ['one', 'one one one'])\n  s/one/two\n  call cursor(2, 1)\n\n  \" :sc\n  call feedkeys(\":sc\\<CR>y\", 'xt')\n  call assert_equal('two one one', getline(2))\n\n  \" :scg\n  call setline(2, 'one one one')\n  call feedkeys(\":scg\\<CR>nyq\", 'xt')\n  call assert_equal('one two one', getline(2))\n\n  \" :sci\n  call setline(2, 'ONE One onE')\n  call feedkeys(\":sci\\<CR>y\", 'xt')\n  call assert_equal('two One onE', getline(2))\n\n  \" :scI\n  set ignorecase\n  call setline(2, 'ONE One one')\n  call feedkeys(\":scI\\<CR>y\", 'xt')\n  call assert_equal('ONE One two', getline(2))\n  set ignorecase&\n\n  \" :scn\n  call setline(2, 'one one one')\n  let t = execute('scn')->split(\"\\n\")\n  call assert_equal(['1 match on 1 line'], t)\n  call assert_equal('one one one', getline(2))\n\n  \" :scp\n  call setline(2, \"\\tone one one\")\n  redir => output\n  call feedkeys(\":scp\\<CR>y\", 'xt')\n  redir END\n  call assert_equal('        two one one', output->split(\"\\n\")[-1])\n  call assert_equal(\"\\ttwo one one\", getline(2))\n\n  \" :scl\n  call setline(2, \"\\tone one one\")\n  redir => output\n  call feedkeys(\":scl\\<CR>y\", 'xt')\n  redir END\n  call assert_equal(\"^Itwo one one$\", output->split(\"\\n\")[-1])\n  call assert_equal(\"\\ttwo one one\", getline(2))\n\n  \" :sgc\n  call setline(2, 'one one one one one')\n  call feedkeys(\":sgc\\<CR>nyyq\", 'xt')\n  call assert_equal('one two two one one', getline(2))\n\n  \" :sg\n  call setline(2, 'one one one')\n  sg\n  call assert_equal('two two two', getline(2))\n\n  \" :sgi\n  call setline(2, 'ONE One onE')\n  sgi\n  call assert_equal('two two two', getline(2))\n\n  \" :sgI\n  set ignorecase\n  call setline(2, 'ONE One one')\n  sgI\n  call assert_equal('ONE One two', getline(2))\n  set ignorecase&\n\n  \" :sgn\n  call setline(2, 'one one one')\n  let t = execute('sgn')->split(\"\\n\")\n  call assert_equal(['3 matches on 1 line'], t)\n  call assert_equal('one one one', getline(2))\n\n  \" :sgp\n  call setline(2, \"\\tone one one\")\n  redir => output\n  sgp\n  redir END\n  call assert_equal('        two two two', output->split(\"\\n\")[-1])\n  call assert_equal(\"\\ttwo two two\", getline(2))\n\n  \" :sgl\n  call setline(2, \"\\tone one one\")\n  redir => output\n  sgl\n  redir END\n  call assert_equal(\"^Itwo two two$\", output->split(\"\\n\")[-1])\n  call assert_equal(\"\\ttwo two two\", getline(2))\n\n  \" :sgr\n  call setline(2, \"one one one\")\n  call cursor(2, 1)\n  s/abc/xyz/e\n  let @/ = 'one'\n  sgr\n  call assert_equal('xyz xyz xyz', getline(2))\n\n  \" :sic\n  call cursor(1, 1)\n  s/one/two/e\n  call setline(2, \"ONE One one\")\n  call cursor(2, 1)\n  call feedkeys(\":sic\\<CR>y\", 'xt')\n  call assert_equal('two One one', getline(2))\n\n  \" :si\n  call setline(2, \"ONE One one\")\n  si\n  call assert_equal('two One one', getline(2))\n\n  \" :siI\n  call setline(2, \"ONE One one\")\n  siI\n  call assert_equal('ONE One two', getline(2))\n\n  \" :sin\n  call setline(2, 'ONE One onE')\n  let t = execute('sin')->split(\"\\n\")\n  call assert_equal(['1 match on 1 line'], t)\n  call assert_equal('ONE One onE', getline(2))\n\n  \" :sip\n  call setline(2, \"\\tONE One onE\")\n  redir => output\n  sip\n  redir END\n  call assert_equal('        two One onE', output->split(\"\\n\")[-1])\n  call assert_equal(\"\\ttwo One onE\", getline(2))\n\n  \" :sir\n  call setline(2, \"ONE One onE\")\n  call cursor(2, 1)\n  s/abc/xyz/e\n  let @/ = 'one'\n  sir\n  call assert_equal('xyz One onE', getline(2))\n\n  \" :sIc\n  call cursor(1, 1)\n  s/one/two/e\n  call setline(2, \"ONE One one\")\n  call cursor(2, 1)\n  call feedkeys(\":sIc\\<CR>y\", 'xt')\n  call assert_equal('ONE One two', getline(2))\n\n  \" :sIg\n  call setline(2, \"ONE one onE one\")\n  sIg\n  call assert_equal('ONE two onE two', getline(2))\n\n  \" :sIi\n  call setline(2, \"ONE One one\")\n  sIi\n  call assert_equal('two One one', getline(2))\n\n  \" :sI\n  call setline(2, \"ONE One one\")\n  sI\n  call assert_equal('ONE One two', getline(2))\n\n  \" :sIn\n  call setline(2, 'ONE One one')\n  let t = execute('sIn')->split(\"\\n\")\n  call assert_equal(['1 match on 1 line'], t)\n  call assert_equal('ONE One one', getline(2))\n\n  \" :sIp\n  call setline(2, \"\\tONE One one\")\n  redir => output\n  sIp\n  redir END\n  call assert_equal('        ONE One two', output->split(\"\\n\")[-1])\n  call assert_equal(\"\\tONE One two\", getline(2))\n\n  \" :sIl\n  call setline(2, \"\\tONE onE one\")\n  redir => output\n  sIl\n  redir END\n  call assert_equal(\"^IONE onE two$\", output->split(\"\\n\")[-1])\n  call assert_equal(\"\\tONE onE two\", getline(2))\n\n  \" :sIr\n  call setline(2, \"ONE one onE\")\n  call cursor(2, 1)\n  s/abc/xyz/e\n  let @/ = 'one'\n  sIr\n  call assert_equal('ONE xyz onE', getline(2))\n\n  \" :src\n  call setline(2, \"ONE one one\")\n  call cursor(2, 1)\n  s/abc/xyz/e\n  let @/ = 'one'\n  call feedkeys(\":src\\<CR>y\", 'xt')\n  call assert_equal('ONE xyz one', getline(2))\n\n  \" :srg\n  call setline(2, \"one one one\")\n  call cursor(2, 1)\n  s/abc/xyz/e\n  let @/ = 'one'\n  srg\n  call assert_equal('xyz xyz xyz', getline(2))\n\n  \" :sri\n  call setline(2, \"ONE one onE\")\n  call cursor(2, 1)\n  s/abc/xyz/e\n  let @/ = 'one'\n  sri\n  call assert_equal('xyz one onE', getline(2))\n\n  \" :srI\n  call setline(2, \"ONE one onE\")\n  call cursor(2, 1)\n  s/abc/xyz/e\n  let @/ = 'one'\n  srI\n  call assert_equal('ONE xyz onE', getline(2))\n\n  \" :srn\n  call setline(2, \"ONE one onE\")\n  call cursor(2, 1)\n  s/abc/xyz/e\n  let @/ = 'one'\n  let t = execute('srn')->split(\"\\n\")\n  call assert_equal(['1 match on 1 line'], t)\n  call assert_equal('ONE one onE', getline(2))\n\n  \" :srp\n  call setline(2, \"\\tONE one onE\")\n  call cursor(2, 1)\n  s/abc/xyz/e\n  let @/ = 'one'\n  redir => output\n  srp\n  redir END\n  call assert_equal('        ONE xyz onE', output->split(\"\\n\")[-1])\n  call assert_equal(\"\\tONE xyz onE\", getline(2))\n\n  \" :srl\n  call setline(2, \"\\tONE one onE\")\n  call cursor(2, 1)\n  s/abc/xyz/e\n  let @/ = 'one'\n  redir => output\n  srl\n  redir END\n  call assert_equal(\"^IONE xyz onE$\", output->split(\"\\n\")[-1])\n  call assert_equal(\"\\tONE xyz onE\", getline(2))\n\n  \" :sr\n  call setline(2, \"ONE one onE\")\n  call cursor(2, 1)\n  s/abc/xyz/e\n  let @/ = 'one'\n  sr\n  call assert_equal('ONE xyz onE', getline(2))\n\n  \" :sce\n  s/abc/xyz/e\n  call assert_fails(\"sc\", 'E486:')\n  sce\n  \" :sge\n  call assert_fails(\"sg\", 'E486:')\n  sge\n  \" :sie\n  call assert_fails(\"si\", 'E486:')\n  sie\n  \" :sIe\n  call assert_fails(\"sI\", 'E486:')\n  sIe\n\n  bw!\nendfunc\n\n\" Check handling expanding \"~\" resulting in extremely long text.\nfunc Test_substitute_tilde_too_long()\n  enew!\n\n  s/.*/ixxx\n  s//~~~~~~~~~AAAAAAA@(\n\n  \" Either fails with \"out of memory\" or \"text too long\".\n  \" This can take a long time.\n  call assert_fails('sil! norm &&&&&&&&&', ['E1240:\\|E342:'])\n\n  bwipe!\nendfunc\n\n\" This should be done last to reveal a memory leak when vim_regsub_both() is\n\" called to evaluate an expression but it is not used in a second call.\nfunc Test_z_substitute_expr_leak()\n  func SubExpr()\n    ~n\n  endfunc\n  silent! s/\\%')/\\=SubExpr()\n  delfunc SubExpr\nendfunc\n\n\" vim: shiftwidth=2 sts=2 expandtab\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\t\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n#include \"vim.h\"\n\n/*\n * Vim originated from Stevie version 3.6 (Fish disk 217) by GRWalter (Fred)\n * It has been changed beyond recognition since then.\n *\n * Differences between version 8.2 and 9.0 can be found with \":help version9\".\n * Differences between version 7.4 and 8.x can be found with \":help version8\".\n * Differences between version 6.4 and 7.x can be found with \":help version7\".\n * Differences between version 5.8 and 6.x can be found with \":help version6\".\n * Differences between version 4.x and 5.x can be found with \":help version5\".\n * Differences between version 3.0 and 4.x can be found with \":help version4\".\n * All the remarks about older versions have been removed, they are not very\n * interesting.\n */\n\n#include \"version.h\"\n\nchar\t\t*Version = VIM_VERSION_SHORT;\nstatic char\t*mediumVersion = VIM_VERSION_MEDIUM;\n\n#if defined(HAVE_DATE_TIME) || defined(PROTO)\n# if (defined(VMS) && defined(VAXC)) || defined(PROTO)\nchar\tlongVersion[sizeof(VIM_VERSION_LONG_DATE) + sizeof(__DATE__)\n\t\t\t\t\t\t      + sizeof(__TIME__) + 3];\n\n    void\ninit_longVersion(void)\n{\n    /*\n     * Construct the long version string.  Necessary because\n     * VAX C can't concatenate strings in the preprocessor.\n     */\n    strcpy(longVersion, VIM_VERSION_LONG_DATE);\n#ifdef BUILD_DATE\n    strcat(longVersion, BUILD_DATE);\n#else\n    strcat(longVersion, __DATE__);\n    strcat(longVersion, \" \");\n    strcat(longVersion, __TIME__);\n#endif\n    strcat(longVersion, \")\");\n}\n\n# else\nchar\t*longVersion = NULL;\n\n    void\ninit_longVersion(void)\n{\n    if (longVersion != NULL)\n\treturn;\n\n#ifdef BUILD_DATE\n    char *date_time = BUILD_DATE;\n#else\n    char *date_time = __DATE__ \" \" __TIME__;\n#endif\n    char *msg = _(\"%s (%s, compiled %s)\");\n    size_t len = strlen(msg)\n\t+ strlen(VIM_VERSION_LONG_ONLY)\n\t+ strlen(VIM_VERSION_DATE_ONLY)\n\t+ strlen(date_time);\n\n    longVersion = alloc(len);\n    if (longVersion == NULL)\n\tlongVersion = VIM_VERSION_LONG;\n    else\n\tvim_snprintf(longVersion, len, msg,\n\t\tVIM_VERSION_LONG_ONLY, VIM_VERSION_DATE_ONLY, date_time);\n}\n# endif\n#else\nchar\t*longVersion = VIM_VERSION_LONG;\n\n    void\ninit_longVersion(void)\n{\n    // nothing to do\n}\n#endif\n\nstatic char *(features[]) =\n{\n#ifdef HAVE_ACL\n\t\"+acl\",\n#else\n\t\"-acl\",\n#endif\n#ifdef AMIGA\t\t// only for Amiga systems\n# ifdef FEAT_ARP\n\t\"+ARP\",\n# else\n\t\"-ARP\",\n# endif\n#endif\n#ifdef FEAT_ARABIC\n\t\"+arabic\",\n#else\n\t\"-arabic\",\n#endif\n\t\"+autocmd\",\n#ifdef FEAT_AUTOCHDIR\n       \"+autochdir\",\n#else\n       \"-autochdir\",\n#endif\n#ifdef FEAT_AUTOSERVERNAME\n\t\"+autoservername\",\n#else\n\t\"-autoservername\",\n#endif\n#ifdef FEAT_BEVAL_GUI\n\t\"+balloon_eval\",\n#else\n\t\"-balloon_eval\",\n#endif\n#ifdef FEAT_BEVAL_TERM\n\t\"+balloon_eval_term\",\n#else\n\t\"-balloon_eval_term\",\n#endif\n#ifdef FEAT_BROWSE\n\t\"+browse\",\n#else\n\t\"-browse\",\n#endif\n\t\"++builtin_terms\",\n#ifdef FEAT_BYTEOFF\n\t\"+byte_offset\",\n#else\n\t\"-byte_offset\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+channel\",\n#else\n\t\"-channel\",\n#endif\n\t\"+cindent\",\n#ifdef FEAT_CLIENTSERVER\n\t\"+clientserver\",\n#else\n\t\"-clientserver\",\n#endif\n#ifdef FEAT_CLIPBOARD\n\t\"+clipboard\",\n#else\n\t\"-clipboard\",\n#endif\n\t\"+cmdline_compl\",\n\t\"+cmdline_hist\",\n\t\"+cmdline_info\",\n\t\"+comments\",\n#ifdef FEAT_CONCEAL\n\t\"+conceal\",\n#else\n\t\"-conceal\",\n#endif\n#ifdef FEAT_CRYPT\n\t\"+cryptv\",\n#else\n\t\"-cryptv\",\n#endif\n#ifdef FEAT_CSCOPE\n\t\"+cscope\",\n#else\n\t\"-cscope\",\n#endif\n\t\"+cursorbind\",\n#ifdef CURSOR_SHAPE\n\t\"+cursorshape\",\n#else\n\t\"-cursorshape\",\n#endif\n#if defined(FEAT_CON_DIALOG) && defined(FEAT_GUI_DIALOG)\n\t\"+dialog_con_gui\",\n#else\n# if defined(FEAT_CON_DIALOG)\n\t\"+dialog_con\",\n# else\n#  if defined(FEAT_GUI_DIALOG)\n\t\"+dialog_gui\",\n#  else\n\t\"-dialog\",\n#  endif\n# endif\n#endif\n#ifdef FEAT_DIFF\n\t\"+diff\",\n#else\n\t\"-diff\",\n#endif\n#ifdef FEAT_DIGRAPHS\n\t\"+digraphs\",\n#else\n\t\"-digraphs\",\n#endif\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_DIRECTX\n\t\"+directx\",\n# else\n\t\"-directx\",\n# endif\n#endif\n#ifdef FEAT_DND\n\t\"+dnd\",\n#else\n\t\"-dnd\",\n#endif\n\t\"-ebcdic\",\n#ifdef FEAT_EMACS_TAGS\n\t\"+emacs_tags\",\n#else\n\t\"-emacs_tags\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+eval\",\n#else\n\t\"-eval\",\n#endif\n\t\"+ex_extra\",\n#ifdef FEAT_SEARCH_EXTRA\n\t\"+extra_search\",\n#else\n\t\"-extra_search\",\n#endif\n\t\"-farsi\",\n\t\"+file_in_path\",\n#ifdef FEAT_FIND_ID\n\t\"+find_in_path\",\n#else\n\t\"-find_in_path\",\n#endif\n\t\"+float\",\n#ifdef FEAT_FOLDING\n\t\"+folding\",\n#else\n\t\"-folding\",\n#endif\n\t\"-footer\",\n\t// only interesting on Unix systems\n#if !defined(USE_SYSTEM) && defined(UNIX)\n\t\"+fork()\",\n#endif\n#ifdef FEAT_GETTEXT\n# ifdef DYNAMIC_GETTEXT\n\t\"+gettext/dyn\",\n# else\n\t\"+gettext\",\n# endif\n#else\n\t\"-gettext\",\n#endif\n\t\"-hangul_input\",\n#if (defined(HAVE_ICONV_H) && defined(USE_ICONV)) || defined(DYNAMIC_ICONV)\n# ifdef DYNAMIC_ICONV\n\t\"+iconv/dyn\",\n# else\n\t\"+iconv\",\n# endif\n#else\n\t\"-iconv\",\n#endif\n\t\"+insert_expand\",\n#ifdef FEAT_IPV6\n\t\"+ipv6\",\n#else\n\t\"-ipv6\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+job\",\n#else\n\t\"-job\",\n#endif\n\t\"+jumplist\",\n#ifdef FEAT_KEYMAP\n\t\"+keymap\",\n#else\n\t\"-keymap\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+lambda\",\n#else\n\t\"-lambda\",\n#endif\n#ifdef FEAT_LANGMAP\n\t\"+langmap\",\n#else\n\t\"-langmap\",\n#endif\n#ifdef FEAT_LIBCALL\n\t\"+libcall\",\n#else\n\t\"-libcall\",\n#endif\n#ifdef FEAT_LINEBREAK\n\t\"+linebreak\",\n#else\n\t\"-linebreak\",\n#endif\n\t\"+lispindent\",\n\t\"+listcmds\",\n\t\"+localmap\",\n#ifdef FEAT_LUA\n# ifdef DYNAMIC_LUA\n\t\"+lua/dyn\",\n# else\n\t\"+lua\",\n# endif\n#else\n\t\"-lua\",\n#endif\n#ifdef FEAT_MENU\n\t\"+menu\",\n#else\n\t\"-menu\",\n#endif\n#ifdef FEAT_SESSION\n\t\"+mksession\",\n#else\n\t\"-mksession\",\n#endif\n\t\"+modify_fname\",\n\t\"+mouse\",\n#ifdef FEAT_MOUSESHAPE\n\t\"+mouseshape\",\n#else\n\t\"-mouseshape\",\n#endif\n\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_MOUSE_DEC\n\t\"+mouse_dec\",\n# else\n\t\"-mouse_dec\",\n# endif\n# ifdef FEAT_MOUSE_GPM\n#  ifdef DYNAMIC_GPM\n\t\"+mouse_gpm/dyn\",\n#  else\n\t\"+mouse_gpm\",\n#  endif\n# else\n\t\"-mouse_gpm\",\n# endif\n# ifdef FEAT_MOUSE_JSB\n\t\"+mouse_jsbterm\",\n# else\n\t\"-mouse_jsbterm\",\n# endif\n# ifdef FEAT_MOUSE_NET\n\t\"+mouse_netterm\",\n# else\n\t\"-mouse_netterm\",\n# endif\n#endif\n\n#ifdef __QNX__\n# ifdef FEAT_MOUSE_PTERM\n\t\"+mouse_pterm\",\n# else\n\t\"-mouse_pterm\",\n# endif\n#endif\n\n#if defined(UNIX) || defined(VMS)\n\t\"+mouse_sgr\",\n# ifdef FEAT_SYSMOUSE\n\t\"+mouse_sysmouse\",\n# else\n\t\"-mouse_sysmouse\",\n# endif\n# ifdef FEAT_MOUSE_URXVT\n\t\"+mouse_urxvt\",\n# else\n\t\"-mouse_urxvt\",\n# endif\n\t\"+mouse_xterm\",\n#endif\n\n#ifdef FEAT_MBYTE_IME\n# ifdef DYNAMIC_IME\n\t\"+multi_byte_ime/dyn\",\n# else\n\t\"+multi_byte_ime\",\n# endif\n#else\n\t\"+multi_byte\",\n#endif\n#ifdef FEAT_MULTI_LANG\n\t\"+multi_lang\",\n#else\n\t\"-multi_lang\",\n#endif\n#ifdef FEAT_MZSCHEME\n# ifdef DYNAMIC_MZSCHEME\n\t\"+mzscheme/dyn\",\n# else\n\t\"+mzscheme\",\n# endif\n#else\n\t\"-mzscheme\",\n#endif\n#ifdef FEAT_NETBEANS_INTG\n\t\"+netbeans_intg\",\n#else\n\t\"-netbeans_intg\",\n#endif\n\t\"+num64\",\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_OLE\n\t\"+ole\",\n# else\n\t\"-ole\",\n# endif\n#endif\n#ifdef FEAT_EVAL\n\t\"+packages\",\n#else\n\t\"-packages\",\n#endif\n\t\"+path_extra\",\n#ifdef FEAT_PERL\n# ifdef DYNAMIC_PERL\n\t\"+perl/dyn\",\n# else\n\t\"+perl\",\n# endif\n#else\n\t\"-perl\",\n#endif\n#ifdef FEAT_PERSISTENT_UNDO\n\t\"+persistent_undo\",\n#else\n\t\"-persistent_undo\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+popupwin\",\n#else\n\t\"-popupwin\",\n#endif\n#ifdef FEAT_PRINTER\n# ifdef FEAT_POSTSCRIPT\n\t\"+postscript\",\n# else\n\t\"-postscript\",\n# endif\n\t\"+printer\",\n#else\n\t\"-printer\",\n#endif\n#ifdef FEAT_PROFILE\n\t\"+profile\",\n#else\n\t\"-profile\",\n#endif\n#ifdef FEAT_PYTHON\n# ifdef DYNAMIC_PYTHON\n\t\"+python/dyn\",\n# else\n\t\"+python\",\n# endif\n#else\n\t\"-python\",\n#endif\n#ifdef FEAT_PYTHON3\n# ifdef DYNAMIC_PYTHON3\n\t\"+python3/dyn\",\n# else\n\t\"+python3\",\n# endif\n#else\n\t\"-python3\",\n#endif\n#ifdef FEAT_QUICKFIX\n\t\"+quickfix\",\n#else\n\t\"-quickfix\",\n#endif\n#ifdef FEAT_RELTIME\n\t\"+reltime\",\n#else\n\t\"-reltime\",\n#endif\n#ifdef FEAT_RIGHTLEFT\n\t\"+rightleft\",\n#else\n\t\"-rightleft\",\n#endif\n#ifdef FEAT_RUBY\n# ifdef DYNAMIC_RUBY\n\t\"+ruby/dyn\",\n# else\n\t\"+ruby\",\n# endif\n#else\n\t\"-ruby\",\n#endif\n\t\"+scrollbind\",\n#ifdef FEAT_SIGNS\n\t\"+signs\",\n#else\n\t\"-signs\",\n#endif\n\t\"+smartindent\",\n#ifdef FEAT_SODIUM\n# ifdef DYNAMIC_SODIUM\n\t\"+sodium/dyn\",\n# else\n\t\"+sodium\",\n# endif\n#else\n\t\"-sodium\",\n#endif\n#ifdef FEAT_SOUND\n\t\"+sound\",\n#else\n\t\"-sound\",\n#endif\n#ifdef FEAT_SPELL\n\t\"+spell\",\n#else\n\t\"-spell\",\n#endif\n#ifdef STARTUPTIME\n\t\"+startuptime\",\n#else\n\t\"-startuptime\",\n#endif\n#ifdef FEAT_STL_OPT\n\t\"+statusline\",\n#else\n\t\"-statusline\",\n#endif\n\t\"-sun_workshop\",\n#ifdef FEAT_SYN_HL\n\t\"+syntax\",\n#else\n\t\"-syntax\",\n#endif\n\t    // only interesting on Unix systems\n#if defined(USE_SYSTEM) && defined(UNIX)\n\t\"+system()\",\n#endif\n\t\"+tag_binary\",\n\t\"-tag_old_static\",\n\t\"-tag_any_white\",\n#ifdef FEAT_TCL\n# ifdef DYNAMIC_TCL\n\t\"+tcl/dyn\",\n# else\n\t\"+tcl\",\n# endif\n#else\n\t\"-tcl\",\n#endif\n#ifdef FEAT_TERMGUICOLORS\n\t\"+termguicolors\",\n#else\n\t\"-termguicolors\",\n#endif\n#ifdef FEAT_TERMINAL\n\t\"+terminal\",\n#else\n\t\"-terminal\",\n#endif\n#if defined(UNIX)\n// only Unix can have terminfo instead of termcap\n# ifdef TERMINFO\n\t\"+terminfo\",\n# else\n\t\"-terminfo\",\n# endif\n#endif\n#ifdef FEAT_TERMRESPONSE\n\t\"+termresponse\",\n#else\n\t\"-termresponse\",\n#endif\n\t\"+textobjects\",\n#ifdef FEAT_PROP_POPUP\n\t\"+textprop\",\n#else\n\t\"-textprop\",\n#endif\n#if !defined(UNIX)\n// unix always includes termcap support\n# ifdef HAVE_TGETENT\n\t\"+tgetent\",\n# else\n\t\"-tgetent\",\n# endif\n#endif\n#ifdef FEAT_TIMERS\n\t\"+timers\",\n#else\n\t\"-timers\",\n#endif\n\t\"+title\",\n#ifdef FEAT_TOOLBAR\n\t\"+toolbar\",\n#else\n\t\"-toolbar\",\n#endif\n\t\"+user_commands\",\n#ifdef FEAT_VARTABS\n\t\"+vartabs\",\n#else\n\t\"-vartabs\",\n#endif\n\t\"+vertsplit\",\n\t\"+vim9script\",\n#ifdef FEAT_VIMINFO\n\t\"+viminfo\",\n#else\n\t\"-viminfo\",\n#endif\n\t\"+virtualedit\",\n\t\"+visual\",\n\t\"+visualextra\",\n\t\"+vreplace\",\n#ifdef MSWIN\n# ifdef FEAT_VTP\n\t\"+vtp\",\n# else\n\t\"-vtp\",\n# endif\n#endif\n\t\"+wildignore\",\n\t\"+wildmenu\",\n\t\"+windows\",\n#ifdef FEAT_WRITEBACKUP\n\t\"+writebackup\",\n#else\n\t\"-writebackup\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_X11\n\t\"+X11\",\n# else\n\t\"-X11\",\n# endif\n#endif\n#ifdef FEAT_XFONTSET\n\t\"+xfontset\",\n#else\n\t\"-xfontset\",\n#endif\n#ifdef FEAT_XIM\n\t\"+xim\",\n#else\n\t\"-xim\",\n#endif\n#if defined(MSWIN)\n# ifdef FEAT_XPM_W32\n\t\"+xpm_w32\",\n# else\n\t\"-xpm_w32\",\n# endif\n#elif defined(HAVE_XPM)\n\t\"+xpm\",\n#else\n\t\"-xpm\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# if defined(USE_XSMP_INTERACT)\n\t\"+xsmp_interact\",\n# elif defined(USE_XSMP)\n\t\"+xsmp\",\n# else\n\t\"-xsmp\",\n# endif\n# ifdef FEAT_XCLIPBOARD\n\t\"+xterm_clipboard\",\n# else\n\t\"-xterm_clipboard\",\n# endif\n#endif\n#ifdef FEAT_XTERM_SAVE\n\t\"+xterm_save\",\n#else\n\t\"-xterm_save\",\n#endif\n\tNULL\n};\n\nstatic int included_patches[] =\n{   /* Add new patch number below this line */\n/**/\n    1532,\n/**/\n    1531,\n/**/\n    1530,\n/**/\n    1529,\n/**/\n    1528,\n/**/\n    1527,\n/**/\n    1526,\n/**/\n    1525,\n/**/\n    1524,\n/**/\n    1523,\n/**/\n    1522,\n/**/\n    1521,\n/**/\n    1520,\n/**/\n    1519,\n/**/\n    1518,\n/**/\n    1517,\n/**/\n    1516,\n/**/\n    1515,\n/**/\n    1514,\n/**/\n    1513,\n/**/\n    1512,\n/**/\n    1511,\n/**/\n    1510,\n/**/\n    1509,\n/**/\n    1508,\n/**/\n    1507,\n/**/\n    1506,\n/**/\n    1505,\n/**/\n    1504,\n/**/\n    1503,\n/**/\n    1502,\n/**/\n    1501,\n/**/\n    1500,\n/**/\n    1499,\n/**/\n    1498,\n/**/\n    1497,\n/**/\n    1496,\n/**/\n    1495,\n/**/\n    1494,\n/**/\n    1493,\n/**/\n    1492,\n/**/\n    1491,\n/**/\n    1490,\n/**/\n    1489,\n/**/\n    1488,\n/**/\n    1487,\n/**/\n    1486,\n/**/\n    1485,\n/**/\n    1484,\n/**/\n    1483,\n/**/\n    1482,\n/**/\n    1481,\n/**/\n    1480,\n/**/\n    1479,\n/**/\n    1478,\n/**/\n    1477,\n/**/\n    1476,\n/**/\n    1475,\n/**/\n    1474,\n/**/\n    1473,\n/**/\n    1472,\n/**/\n    1471,\n/**/\n    1470,\n/**/\n    1469,\n/**/\n    1468,\n/**/\n    1467,\n/**/\n    1466,\n/**/\n    1465,\n/**/\n    1464,\n/**/\n    1463,\n/**/\n    1462,\n/**/\n    1461,\n/**/\n    1460,\n/**/\n    1459,\n/**/\n    1458,\n/**/\n    1457,\n/**/\n    1456,\n/**/\n    1455,\n/**/\n    1454,\n/**/\n    1453,\n/**/\n    1452,\n/**/\n    1451,\n/**/\n    1450,\n/**/\n    1449,\n/**/\n    1448,\n/**/\n    1447,\n/**/\n    1446,\n/**/\n    1445,\n/**/\n    1444,\n/**/\n    1443,\n/**/\n    1442,\n/**/\n    1441,\n/**/\n    1440,\n/**/\n    1439,\n/**/\n    1438,\n/**/\n    1437,\n/**/\n    1436,\n/**/\n    1435,\n/**/\n    1434,\n/**/\n    1433,\n/**/\n    1432,\n/**/\n    1431,\n/**/\n    1430,\n/**/\n    1429,\n/**/\n    1428,\n/**/\n    1427,\n/**/\n    1426,\n/**/\n    1425,\n/**/\n    1424,\n/**/\n    1423,\n/**/\n    1422,\n/**/\n    1421,\n/**/\n    1420,\n/**/\n    1419,\n/**/\n    1418,\n/**/\n    1417,\n/**/\n    1416,\n/**/\n    1415,\n/**/\n    1414,\n/**/\n    1413,\n/**/\n    1412,\n/**/\n    1411,\n/**/\n    1410,\n/**/\n    1409,\n/**/\n    1408,\n/**/\n    1407,\n/**/\n    1406,\n/**/\n    1405,\n/**/\n    1404,\n/**/\n    1403,\n/**/\n    1402,\n/**/\n    1401,\n/**/\n    1400,\n/**/\n    1399,\n/**/\n    1398,\n/**/\n    1397,\n/**/\n    1396,\n/**/\n    1395,\n/**/\n    1394,\n/**/\n    1393,\n/**/\n    1392,\n/**/\n    1391,\n/**/\n    1390,\n/**/\n    1389,\n/**/\n    1388,\n/**/\n    1387,\n/**/\n    1386,\n/**/\n    1385,\n/**/\n    1384,\n/**/\n    1383,\n/**/\n    1382,\n/**/\n    1381,\n/**/\n    1380,\n/**/\n    1379,\n/**/\n    1378,\n/**/\n    1377,\n/**/\n    1376,\n/**/\n    1375,\n/**/\n    1374,\n/**/\n    1373,\n/**/\n    1372,\n/**/\n    1371,\n/**/\n    1370,\n/**/\n    1369,\n/**/\n    1368,\n/**/\n    1367,\n/**/\n    1366,\n/**/\n    1365,\n/**/\n    1364,\n/**/\n    1363,\n/**/\n    1362,\n/**/\n    1361,\n/**/\n    1360,\n/**/\n    1359,\n/**/\n    1358,\n/**/\n    1357,\n/**/\n    1356,\n/**/\n    1355,\n/**/\n    1354,\n/**/\n    1353,\n/**/\n    1352,\n/**/\n    1351,\n/**/\n    1350,\n/**/\n    1349,\n/**/\n    1348,\n/**/\n    1347,\n/**/\n    1346,\n/**/\n    1345,\n/**/\n    1344,\n/**/\n    1343,\n/**/\n    1342,\n/**/\n    1341,\n/**/\n    1340,\n/**/\n    1339,\n/**/\n    1338,\n/**/\n    1337,\n/**/\n    1336,\n/**/\n    1335,\n/**/\n    1334,\n/**/\n    1333,\n/**/\n    1332,\n/**/\n    1331,\n/**/\n    1330,\n/**/\n    1329,\n/**/\n    1328,\n/**/\n    1327,\n/**/\n    1326,\n/**/\n    1325,\n/**/\n    1324,\n/**/\n    1323,\n/**/\n    1322,\n/**/\n    1321,\n/**/\n    1320,\n/**/\n    1319,\n/**/\n    1318,\n/**/\n    1317,\n/**/\n    1316,\n/**/\n    1315,\n/**/\n    1314,\n/**/\n    1313,\n/**/\n    1312,\n/**/\n    1311,\n/**/\n    1310,\n/**/\n    1309,\n/**/\n    1308,\n/**/\n    1307,\n/**/\n    1306,\n/**/\n    1305,\n/**/\n    1304,\n/**/\n    1303,\n/**/\n    1302,\n/**/\n    1301,\n/**/\n    1300,\n/**/\n    1299,\n/**/\n    1298,\n/**/\n    1297,\n/**/\n    1296,\n/**/\n    1295,\n/**/\n    1294,\n/**/\n    1293,\n/**/\n    1292,\n/**/\n    1291,\n/**/\n    1290,\n/**/\n    1289,\n/**/\n    1288,\n/**/\n    1287,\n/**/\n    1286,\n/**/\n    1285,\n/**/\n    1284,\n/**/\n    1283,\n/**/\n    1282,\n/**/\n    1281,\n/**/\n    1280,\n/**/\n    1279,\n/**/\n    1278,\n/**/\n    1277,\n/**/\n    1276,\n/**/\n    1275,\n/**/\n    1274,\n/**/\n    1273,\n/**/\n    1272,\n/**/\n    1271,\n/**/\n    1270,\n/**/\n    1269,\n/**/\n    1268,\n/**/\n    1267,\n/**/\n    1266,\n/**/\n    1265,\n/**/\n    1264,\n/**/\n    1263,\n/**/\n    1262,\n/**/\n    1261,\n/**/\n    1260,\n/**/\n    1259,\n/**/\n    1258,\n/**/\n    1257,\n/**/\n    1256,\n/**/\n    1255,\n/**/\n    1254,\n/**/\n    1253,\n/**/\n    1252,\n/**/\n    1251,\n/**/\n    1250,\n/**/\n    1249,\n/**/\n    1248,\n/**/\n    1247,\n/**/\n    1246,\n/**/\n    1245,\n/**/\n    1244,\n/**/\n    1243,\n/**/\n    1242,\n/**/\n    1241,\n/**/\n    1240,\n/**/\n    1239,\n/**/\n    1238,\n/**/\n    1237,\n/**/\n    1236,\n/**/\n    1235,\n/**/\n    1234,\n/**/\n    1233,\n/**/\n    1232,\n/**/\n    1231,\n/**/\n    1230,\n/**/\n    1229,\n/**/\n    1228,\n/**/\n    1227,\n/**/\n    1226,\n/**/\n    1225,\n/**/\n    1224,\n/**/\n    1223,\n/**/\n    1222,\n/**/\n    1221,\n/**/\n    1220,\n/**/\n    1219,\n/**/\n    1218,\n/**/\n    1217,\n/**/\n    1216,\n/**/\n    1215,\n/**/\n    1214,\n/**/\n    1213,\n/**/\n    1212,\n/**/\n    1211,\n/**/\n    1210,\n/**/\n    1209,\n/**/\n    1208,\n/**/\n    1207,\n/**/\n    1206,\n/**/\n    1205,\n/**/\n    1204,\n/**/\n    1203,\n/**/\n    1202,\n/**/\n    1201,\n/**/\n    1200,\n/**/\n    1199,\n/**/\n    1198,\n/**/\n    1197,\n/**/\n    1196,\n/**/\n    1195,\n/**/\n    1194,\n/**/\n    1193,\n/**/\n    1192,\n/**/\n    1191,\n/**/\n    1190,\n/**/\n    1189,\n/**/\n    1188,\n/**/\n    1187,\n/**/\n    1186,\n/**/\n    1185,\n/**/\n    1184,\n/**/\n    1183,\n/**/\n    1182,\n/**/\n    1181,\n/**/\n    1180,\n/**/\n    1179,\n/**/\n    1178,\n/**/\n    1177,\n/**/\n    1176,\n/**/\n    1175,\n/**/\n    1174,\n/**/\n    1173,\n/**/\n    1172,\n/**/\n    1171,\n/**/\n    1170,\n/**/\n    1169,\n/**/\n    1168,\n/**/\n    1167,\n/**/\n    1166,\n/**/\n    1165,\n/**/\n    1164,\n/**/\n    1163,\n/**/\n    1162,\n/**/\n    1161,\n/**/\n    1160,\n/**/\n    1159,\n/**/\n    1158,\n/**/\n    1157,\n/**/\n    1156,\n/**/\n    1155,\n/**/\n    1154,\n/**/\n    1153,\n/**/\n    1152,\n/**/\n    1151,\n/**/\n    1150,\n/**/\n    1149,\n/**/\n    1148,\n/**/\n    1147,\n/**/\n    1146,\n/**/\n    1145,\n/**/\n    1144,\n/**/\n    1143,\n/**/\n    1142,\n/**/\n    1141,\n/**/\n    1140,\n/**/\n    1139,\n/**/\n    1138,\n/**/\n    1137,\n/**/\n    1136,\n/**/\n    1135,\n/**/\n    1134,\n/**/\n    1133,\n/**/\n    1132,\n/**/\n    1131,\n/**/\n    1130,\n/**/\n    1129,\n/**/\n    1128,\n/**/\n    1127,\n/**/\n    1126,\n/**/\n    1125,\n/**/\n    1124,\n/**/\n    1123,\n/**/\n    1122,\n/**/\n    1121,\n/**/\n    1120,\n/**/\n    1119,\n/**/\n    1118,\n/**/\n    1117,\n/**/\n    1116,\n/**/\n    1115,\n/**/\n    1114,\n/**/\n    1113,\n/**/\n    1112,\n/**/\n    1111,\n/**/\n    1110,\n/**/\n    1109,\n/**/\n    1108,\n/**/\n    1107,\n/**/\n    1106,\n/**/\n    1105,\n/**/\n    1104,\n/**/\n    1103,\n/**/\n    1102,\n/**/\n    1101,\n/**/\n    1100,\n/**/\n    1099,\n/**/\n    1098,\n/**/\n    1097,\n/**/\n    1096,\n/**/\n    1095,\n/**/\n    1094,\n/**/\n    1093,\n/**/\n    1092,\n/**/\n    1091,\n/**/\n    1090,\n/**/\n    1089,\n/**/\n    1088,\n/**/\n    1087,\n/**/\n    1086,\n/**/\n    1085,\n/**/\n    1084,\n/**/\n    1083,\n/**/\n    1082,\n/**/\n    1081,\n/**/\n    1080,\n/**/\n    1079,\n/**/\n    1078,\n/**/\n    1077,\n/**/\n    1076,\n/**/\n    1075,\n/**/\n    1074,\n/**/\n    1073,\n/**/\n    1072,\n/**/\n    1071,\n/**/\n    1070,\n/**/\n    1069,\n/**/\n    1068,\n/**/\n    1067,\n/**/\n    1066,\n/**/\n    1065,\n/**/\n    1064,\n/**/\n    1063,\n/**/\n    1062,\n/**/\n    1061,\n/**/\n    1060,\n/**/\n    1059,\n/**/\n    1058,\n/**/\n    1057,\n/**/\n    1056,\n/**/\n    1055,\n/**/\n    1054,\n/**/\n    1053,\n/**/\n    1052,\n/**/\n    1051,\n/**/\n    1050,\n/**/\n    1049,\n/**/\n    1048,\n/**/\n    1047,\n/**/\n    1046,\n/**/\n    1045,\n/**/\n    1044,\n/**/\n    1043,\n/**/\n    1042,\n/**/\n    1041,\n/**/\n    1040,\n/**/\n    1039,\n/**/\n    1038,\n/**/\n    1037,\n/**/\n    1036,\n/**/\n    1035,\n/**/\n    1034,\n/**/\n    1033,\n/**/\n    1032,\n/**/\n    1031,\n/**/\n    1030,\n/**/\n    1029,\n/**/\n    1028,\n/**/\n    1027,\n/**/\n    1026,\n/**/\n    1025,\n/**/\n    1024,\n/**/\n    1023,\n/**/\n    1022,\n/**/\n    1021,\n/**/\n    1020,\n/**/\n    1019,\n/**/\n    1018,\n/**/\n    1017,\n/**/\n    1016,\n/**/\n    1015,\n/**/\n    1014,\n/**/\n    1013,\n/**/\n    1012,\n/**/\n    1011,\n/**/\n    1010,\n/**/\n    1009,\n/**/\n    1008,\n/**/\n    1007,\n/**/\n    1006,\n/**/\n    1005,\n/**/\n    1004,\n/**/\n    1003,\n/**/\n    1002,\n/**/\n    1001,\n/**/\n    1000,\n/**/\n    999,\n/**/\n    998,\n/**/\n    997,\n/**/\n    996,\n/**/\n    995,\n/**/\n    994,\n/**/\n    993,\n/**/\n    992,\n/**/\n    991,\n/**/\n    990,\n/**/\n    989,\n/**/\n    988,\n/**/\n    987,\n/**/\n    986,\n/**/\n    985,\n/**/\n    984,\n/**/\n    983,\n/**/\n    982,\n/**/\n    981,\n/**/\n    980,\n/**/\n    979,\n/**/\n    978,\n/**/\n    977,\n/**/\n    976,\n/**/\n    975,\n/**/\n    974,\n/**/\n    973,\n/**/\n    972,\n/**/\n    971,\n/**/\n    970,\n/**/\n    969,\n/**/\n    968,\n/**/\n    967,\n/**/\n    966,\n/**/\n    965,\n/**/\n    964,\n/**/\n    963,\n/**/\n    962,\n/**/\n    961,\n/**/\n    960,\n/**/\n    959,\n/**/\n    958,\n/**/\n    957,\n/**/\n    956,\n/**/\n    955,\n/**/\n    954,\n/**/\n    953,\n/**/\n    952,\n/**/\n    951,\n/**/\n    950,\n/**/\n    949,\n/**/\n    948,\n/**/\n    947,\n/**/\n    946,\n/**/\n    945,\n/**/\n    944,\n/**/\n    943,\n/**/\n    942,\n/**/\n    941,\n/**/\n    940,\n/**/\n    939,\n/**/\n    938,\n/**/\n    937,\n/**/\n    936,\n/**/\n    935,\n/**/\n    934,\n/**/\n    933,\n/**/\n    932,\n/**/\n    931,\n/**/\n    930,\n/**/\n    929,\n/**/\n    928,\n/**/\n    927,\n/**/\n    926,\n/**/\n    925,\n/**/\n    924,\n/**/\n    923,\n/**/\n    922,\n/**/\n    921,\n/**/\n    920,\n/**/\n    919,\n/**/\n    918,\n/**/\n    917,\n/**/\n    916,\n/**/\n    915,\n/**/\n    914,\n/**/\n    913,\n/**/\n    912,\n/**/\n    911,\n/**/\n    910,\n/**/\n    909,\n/**/\n    908,\n/**/\n    907,\n/**/\n    906,\n/**/\n    905,\n/**/\n    904,\n/**/\n    903,\n/**/\n    902,\n/**/\n    901,\n/**/\n    900,\n/**/\n    899,\n/**/\n    898,\n/**/\n    897,\n/**/\n    896,\n/**/\n    895,\n/**/\n    894,\n/**/\n    893,\n/**/\n    892,\n/**/\n    891,\n/**/\n    890,\n/**/\n    889,\n/**/\n    888,\n/**/\n    887,\n/**/\n    886,\n/**/\n    885,\n/**/\n    884,\n/**/\n    883,\n/**/\n    882,\n/**/\n    881,\n/**/\n    880,\n/**/\n    879,\n/**/\n    878,\n/**/\n    877,\n/**/\n    876,\n/**/\n    875,\n/**/\n    874,\n/**/\n    873,\n/**/\n    872,\n/**/\n    871,\n/**/\n    870,\n/**/\n    869,\n/**/\n    868,\n/**/\n    867,\n/**/\n    866,\n/**/\n    865,\n/**/\n    864,\n/**/\n    863,\n/**/\n    862,\n/**/\n    861,\n/**/\n    860,\n/**/\n    859,\n/**/\n    858,\n/**/\n    857,\n/**/\n    856,\n/**/\n    855,\n/**/\n    854,\n/**/\n    853,\n/**/\n    852,\n/**/\n    851,\n/**/\n    850,\n/**/\n    849,\n/**/\n    848,\n/**/\n    847,\n/**/\n    846,\n/**/\n    845,\n/**/\n    844,\n/**/\n    843,\n/**/\n    842,\n/**/\n    841,\n/**/\n    840,\n/**/\n    839,\n/**/\n    838,\n/**/\n    837,\n/**/\n    836,\n/**/\n    835,\n/**/\n    834,\n/**/\n    833,\n/**/\n    832,\n/**/\n    831,\n/**/\n    830,\n/**/\n    829,\n/**/\n    828,\n/**/\n    827,\n/**/\n    826,\n/**/\n    825,\n/**/\n    824,\n/**/\n    823,\n/**/\n    822,\n/**/\n    821,\n/**/\n    820,\n/**/\n    819,\n/**/\n    818,\n/**/\n    817,\n/**/\n    816,\n/**/\n    815,\n/**/\n    814,\n/**/\n    813,\n/**/\n    812,\n/**/\n    811,\n/**/\n    810,\n/**/\n    809,\n/**/\n    808,\n/**/\n    807,\n/**/\n    806,\n/**/\n    805,\n/**/\n    804,\n/**/\n    803,\n/**/\n    802,\n/**/\n    801,\n/**/\n    800,\n/**/\n    799,\n/**/\n    798,\n/**/\n    797,\n/**/\n    796,\n/**/\n    795,\n/**/\n    794,\n/**/\n    793,\n/**/\n    792,\n/**/\n    791,\n/**/\n    790,\n/**/\n    789,\n/**/\n    788,\n/**/\n    787,\n/**/\n    786,\n/**/\n    785,\n/**/\n    784,\n/**/\n    783,\n/**/\n    782,\n/**/\n    781,\n/**/\n    780,\n/**/\n    779,\n/**/\n    778,\n/**/\n    777,\n/**/\n    776,\n/**/\n    775,\n/**/\n    774,\n/**/\n    773,\n/**/\n    772,\n/**/\n    771,\n/**/\n    770,\n/**/\n    769,\n/**/\n    768,\n/**/\n    767,\n/**/\n    766,\n/**/\n    765,\n/**/\n    764,\n/**/\n    763,\n/**/\n    762,\n/**/\n    761,\n/**/\n    760,\n/**/\n    759,\n/**/\n    758,\n/**/\n    757,\n/**/\n    756,\n/**/\n    755,\n/**/\n    754,\n/**/\n    753,\n/**/\n    752,\n/**/\n    751,\n/**/\n    750,\n/**/\n    749,\n/**/\n    748,\n/**/\n    747,\n/**/\n    746,\n/**/\n    745,\n/**/\n    744,\n/**/\n    743,\n/**/\n    742,\n/**/\n    741,\n/**/\n    740,\n/**/\n    739,\n/**/\n    738,\n/**/\n    737,\n/**/\n    736,\n/**/\n    735,\n/**/\n    734,\n/**/\n    733,\n/**/\n    732,\n/**/\n    731,\n/**/\n    730,\n/**/\n    729,\n/**/\n    728,\n/**/\n    727,\n/**/\n    726,\n/**/\n    725,\n/**/\n    724,\n/**/\n    723,\n/**/\n    722,\n/**/\n    721,\n/**/\n    720,\n/**/\n    719,\n/**/\n    718,\n/**/\n    717,\n/**/\n    716,\n/**/\n    715,\n/**/\n    714,\n/**/\n    713,\n/**/\n    712,\n/**/\n    711,\n/**/\n    710,\n/**/\n    709,\n/**/\n    708,\n/**/\n    707,\n/**/\n    706,\n/**/\n    705,\n/**/\n    704,\n/**/\n    703,\n/**/\n    702,\n/**/\n    701,\n/**/\n    700,\n/**/\n    699,\n/**/\n    698,\n/**/\n    697,\n/**/\n    696,\n/**/\n    695,\n/**/\n    694,\n/**/\n    693,\n/**/\n    692,\n/**/\n    691,\n/**/\n    690,\n/**/\n    689,\n/**/\n    688,\n/**/\n    687,\n/**/\n    686,\n/**/\n    685,\n/**/\n    684,\n/**/\n    683,\n/**/\n    682,\n/**/\n    681,\n/**/\n    680,\n/**/\n    679,\n/**/\n    678,\n/**/\n    677,\n/**/\n    676,\n/**/\n    675,\n/**/\n    674,\n/**/\n    673,\n/**/\n    672,\n/**/\n    671,\n/**/\n    670,\n/**/\n    669,\n/**/\n    668,\n/**/\n    667,\n/**/\n    666,\n/**/\n    665,\n/**/\n    664,\n/**/\n    663,\n/**/\n    662,\n/**/\n    661,\n/**/\n    660,\n/**/\n    659,\n/**/\n    658,\n/**/\n    657,\n/**/\n    656,\n/**/\n    655,\n/**/\n    654,\n/**/\n    653,\n/**/\n    652,\n/**/\n    651,\n/**/\n    650,\n/**/\n    649,\n/**/\n    648,\n/**/\n    647,\n/**/\n    646,\n/**/\n    645,\n/**/\n    644,\n/**/\n    643,\n/**/\n    642,\n/**/\n    641,\n/**/\n    640,\n/**/\n    639,\n/**/\n    638,\n/**/\n    637,\n/**/\n    636,\n/**/\n    635,\n/**/\n    634,\n/**/\n    633,\n/**/\n    632,\n/**/\n    631,\n/**/\n    630,\n/**/\n    629,\n/**/\n    628,\n/**/\n    627,\n/**/\n    626,\n/**/\n    625,\n/**/\n    624,\n/**/\n    623,\n/**/\n    622,\n/**/\n    621,\n/**/\n    620,\n/**/\n    619,\n/**/\n    618,\n/**/\n    617,\n/**/\n    616,\n/**/\n    615,\n/**/\n    614,\n/**/\n    613,\n/**/\n    612,\n/**/\n    611,\n/**/\n    610,\n/**/\n    609,\n/**/\n    608,\n/**/\n    607,\n/**/\n    606,\n/**/\n    605,\n/**/\n    604,\n/**/\n    603,\n/**/\n    602,\n/**/\n    601,\n/**/\n    600,\n/**/\n    599,\n/**/\n    598,\n/**/\n    597,\n/**/\n    596,\n/**/\n    595,\n/**/\n    594,\n/**/\n    593,\n/**/\n    592,\n/**/\n    591,\n/**/\n    590,\n/**/\n    589,\n/**/\n    588,\n/**/\n    587,\n/**/\n    586,\n/**/\n    585,\n/**/\n    584,\n/**/\n    583,\n/**/\n    582,\n/**/\n    581,\n/**/\n    580,\n/**/\n    579,\n/**/\n    578,\n/**/\n    577,\n/**/\n    576,\n/**/\n    575,\n/**/\n    574,\n/**/\n    573,\n/**/\n    572,\n/**/\n    571,\n/**/\n    570,\n/**/\n    569,\n/**/\n    568,\n/**/\n    567,\n/**/\n    566,\n/**/\n    565,\n/**/\n    564,\n/**/\n    563,\n/**/\n    562,\n/**/\n    561,\n/**/\n    560,\n/**/\n    559,\n/**/\n    558,\n/**/\n    557,\n/**/\n    556,\n/**/\n    555,\n/**/\n    554,\n/**/\n    553,\n/**/\n    552,\n/**/\n    551,\n/**/\n    550,\n/**/\n    549,\n/**/\n    548,\n/**/\n    547,\n/**/\n    546,\n/**/\n    545,\n/**/\n    544,\n/**/\n    543,\n/**/\n    542,\n/**/\n    541,\n/**/\n    540,\n/**/\n    539,\n/**/\n    538,\n/**/\n    537,\n/**/\n    536,\n/**/\n    535,\n/**/\n    534,\n/**/\n    533,\n/**/\n    532,\n/**/\n    531,\n/**/\n    530,\n/**/\n    529,\n/**/\n    528,\n/**/\n    527,\n/**/\n    526,\n/**/\n    525,\n/**/\n    524,\n/**/\n    523,\n/**/\n    522,\n/**/\n    521,\n/**/\n    520,\n/**/\n    519,\n/**/\n    518,\n/**/\n    517,\n/**/\n    516,\n/**/\n    515,\n/**/\n    514,\n/**/\n    513,\n/**/\n    512,\n/**/\n    511,\n/**/\n    510,\n/**/\n    509,\n/**/\n    508,\n/**/\n    507,\n/**/\n    506,\n/**/\n    505,\n/**/\n    504,\n/**/\n    503,\n/**/\n    502,\n/**/\n    501,\n/**/\n    500,\n/**/\n    499,\n/**/\n    498,\n/**/\n    497,\n/**/\n    496,\n/**/\n    495,\n/**/\n    494,\n/**/\n    493,\n/**/\n    492,\n/**/\n    491,\n/**/\n    490,\n/**/\n    489,\n/**/\n    488,\n/**/\n    487,\n/**/\n    486,\n/**/\n    485,\n/**/\n    484,\n/**/\n    483,\n/**/\n    482,\n/**/\n    481,\n/**/\n    480,\n/**/\n    479,\n/**/\n    478,\n/**/\n    477,\n/**/\n    476,\n/**/\n    475,\n/**/\n    474,\n/**/\n    473,\n/**/\n    472,\n/**/\n    471,\n/**/\n    470,\n/**/\n    469,\n/**/\n    468,\n/**/\n    467,\n/**/\n    466,\n/**/\n    465,\n/**/\n    464,\n/**/\n    463,\n/**/\n    462,\n/**/\n    461,\n/**/\n    460,\n/**/\n    459,\n/**/\n    458,\n/**/\n    457,\n/**/\n    456,\n/**/\n    455,\n/**/\n    454,\n/**/\n    453,\n/**/\n    452,\n/**/\n    451,\n/**/\n    450,\n/**/\n    449,\n/**/\n    448,\n/**/\n    447,\n/**/\n    446,\n/**/\n    445,\n/**/\n    444,\n/**/\n    443,\n/**/\n    442,\n/**/\n    441,\n/**/\n    440,\n/**/\n    439,\n/**/\n    438,\n/**/\n    437,\n/**/\n    436,\n/**/\n    435,\n/**/\n    434,\n/**/\n    433,\n/**/\n    432,\n/**/\n    431,\n/**/\n    430,\n/**/\n    429,\n/**/\n    428,\n/**/\n    427,\n/**/\n    426,\n/**/\n    425,\n/**/\n    424,\n/**/\n    423,\n/**/\n    422,\n/**/\n    421,\n/**/\n    420,\n/**/\n    419,\n/**/\n    418,\n/**/\n    417,\n/**/\n    416,\n/**/\n    415,\n/**/\n    414,\n/**/\n    413,\n/**/\n    412,\n/**/\n    411,\n/**/\n    410,\n/**/\n    409,\n/**/\n    408,\n/**/\n    407,\n/**/\n    406,\n/**/\n    405,\n/**/\n    404,\n/**/\n    403,\n/**/\n    402,\n/**/\n    401,\n/**/\n    400,\n/**/\n    399,\n/**/\n    398,\n/**/\n    397,\n/**/\n    396,\n/**/\n    395,\n/**/\n    394,\n/**/\n    393,\n/**/\n    392,\n/**/\n    391,\n/**/\n    390,\n/**/\n    389,\n/**/\n    388,\n/**/\n    387,\n/**/\n    386,\n/**/\n    385,\n/**/\n    384,\n/**/\n    383,\n/**/\n    382,\n/**/\n    381,\n/**/\n    380,\n/**/\n    379,\n/**/\n    378,\n/**/\n    377,\n/**/\n    376,\n/**/\n    375,\n/**/\n    374,\n/**/\n    373,\n/**/\n    372,\n/**/\n    371,\n/**/\n    370,\n/**/\n    369,\n/**/\n    368,\n/**/\n    367,\n/**/\n    366,\n/**/\n    365,\n/**/\n    364,\n/**/\n    363,\n/**/\n    362,\n/**/\n    361,\n/**/\n    360,\n/**/\n    359,\n/**/\n    358,\n/**/\n    357,\n/**/\n    356,\n/**/\n    355,\n/**/\n    354,\n/**/\n    353,\n/**/\n    352,\n/**/\n    351,\n/**/\n    350,\n/**/\n    349,\n/**/\n    348,\n/**/\n    347,\n/**/\n    346,\n/**/\n    345,\n/**/\n    344,\n/**/\n    343,\n/**/\n    342,\n/**/\n    341,\n/**/\n    340,\n/**/\n    339,\n/**/\n    338,\n/**/\n    337,\n/**/\n    336,\n/**/\n    335,\n/**/\n    334,\n/**/\n    333,\n/**/\n    332,\n/**/\n    331,\n/**/\n    330,\n/**/\n    329,\n/**/\n    328,\n/**/\n    327,\n/**/\n    326,\n/**/\n    325,\n/**/\n    324,\n/**/\n    323,\n/**/\n    322,\n/**/\n    321,\n/**/\n    320,\n/**/\n    319,\n/**/\n    318,\n/**/\n    317,\n/**/\n    316,\n/**/\n    315,\n/**/\n    314,\n/**/\n    313,\n/**/\n    312,\n/**/\n    311,\n/**/\n    310,\n/**/\n    309,\n/**/\n    308,\n/**/\n    307,\n/**/\n    306,\n/**/\n    305,\n/**/\n    304,\n/**/\n    303,\n/**/\n    302,\n/**/\n    301,\n/**/\n    300,\n/**/\n    299,\n/**/\n    298,\n/**/\n    297,\n/**/\n    296,\n/**/\n    295,\n/**/\n    294,\n/**/\n    293,\n/**/\n    292,\n/**/\n    291,\n/**/\n    290,\n/**/\n    289,\n/**/\n    288,\n/**/\n    287,\n/**/\n    286,\n/**/\n    285,\n/**/\n    284,\n/**/\n    283,\n/**/\n    282,\n/**/\n    281,\n/**/\n    280,\n/**/\n    279,\n/**/\n    278,\n/**/\n    277,\n/**/\n    276,\n/**/\n    275,\n/**/\n    274,\n/**/\n    273,\n/**/\n    272,\n/**/\n    271,\n/**/\n    270,\n/**/\n    269,\n/**/\n    268,\n/**/\n    267,\n/**/\n    266,\n/**/\n    265,\n/**/\n    264,\n/**/\n    263,\n/**/\n    262,\n/**/\n    261,\n/**/\n    260,\n/**/\n    259,\n/**/\n    258,\n/**/\n    257,\n/**/\n    256,\n/**/\n    255,\n/**/\n    254,\n/**/\n    253,\n/**/\n    252,\n/**/\n    251,\n/**/\n    250,\n/**/\n    249,\n/**/\n    248,\n/**/\n    247,\n/**/\n    246,\n/**/\n    245,\n/**/\n    244,\n/**/\n    243,\n/**/\n    242,\n/**/\n    241,\n/**/\n    240,\n/**/\n    239,\n/**/\n    238,\n/**/\n    237,\n/**/\n    236,\n/**/\n    235,\n/**/\n    234,\n/**/\n    233,\n/**/\n    232,\n/**/\n    231,\n/**/\n    230,\n/**/\n    229,\n/**/\n    228,\n/**/\n    227,\n/**/\n    226,\n/**/\n    225,\n/**/\n    224,\n/**/\n    223,\n/**/\n    222,\n/**/\n    221,\n/**/\n    220,\n/**/\n    219,\n/**/\n    218,\n/**/\n    217,\n/**/\n    216,\n/**/\n    215,\n/**/\n    214,\n/**/\n    213,\n/**/\n    212,\n/**/\n    211,\n/**/\n    210,\n/**/\n    209,\n/**/\n    208,\n/**/\n    207,\n/**/\n    206,\n/**/\n    205,\n/**/\n    204,\n/**/\n    203,\n/**/\n    202,\n/**/\n    201,\n/**/\n    200,\n/**/\n    199,\n/**/\n    198,\n/**/\n    197,\n/**/\n    196,\n/**/\n    195,\n/**/\n    194,\n/**/\n    193,\n/**/\n    192,\n/**/\n    191,\n/**/\n    190,\n/**/\n    189,\n/**/\n    188,\n/**/\n    187,\n/**/\n    186,\n/**/\n    185,\n/**/\n    184,\n/**/\n    183,\n/**/\n    182,\n/**/\n    181,\n/**/\n    180,\n/**/\n    179,\n/**/\n    178,\n/**/\n    177,\n/**/\n    176,\n/**/\n    175,\n/**/\n    174,\n/**/\n    173,\n/**/\n    172,\n/**/\n    171,\n/**/\n    170,\n/**/\n    169,\n/**/\n    168,\n/**/\n    167,\n/**/\n    166,\n/**/\n    165,\n/**/\n    164,\n/**/\n    163,\n/**/\n    162,\n/**/\n    161,\n/**/\n    160,\n/**/\n    159,\n/**/\n    158,\n/**/\n    157,\n/**/\n    156,\n/**/\n    155,\n/**/\n    154,\n/**/\n    153,\n/**/\n    152,\n/**/\n    151,\n/**/\n    150,\n/**/\n    149,\n/**/\n    148,\n/**/\n    147,\n/**/\n    146,\n/**/\n    145,\n/**/\n    144,\n/**/\n    143,\n/**/\n    142,\n/**/\n    141,\n/**/\n    140,\n/**/\n    139,\n/**/\n    138,\n/**/\n    137,\n/**/\n    136,\n/**/\n    135,\n/**/\n    134,\n/**/\n    133,\n/**/\n    132,\n/**/\n    131,\n/**/\n    130,\n/**/\n    129,\n/**/\n    128,\n/**/\n    127,\n/**/\n    126,\n/**/\n    125,\n/**/\n    124,\n/**/\n    123,\n/**/\n    122,\n/**/\n    121,\n/**/\n    120,\n/**/\n    119,\n/**/\n    118,\n/**/\n    117,\n/**/\n    116,\n/**/\n    115,\n/**/\n    114,\n/**/\n    113,\n/**/\n    112,\n/**/\n    111,\n/**/\n    110,\n/**/\n    109,\n/**/\n    108,\n/**/\n    107,\n/**/\n    106,\n/**/\n    105,\n/**/\n    104,\n/**/\n    103,\n/**/\n    102,\n/**/\n    101,\n/**/\n    100,\n/**/\n    99,\n/**/\n    98,\n/**/\n    97,\n/**/\n    96,\n/**/\n    95,\n/**/\n    94,\n/**/\n    93,\n/**/\n    92,\n/**/\n    91,\n/**/\n    90,\n/**/\n    89,\n/**/\n    88,\n/**/\n    87,\n/**/\n    86,\n/**/\n    85,\n/**/\n    84,\n/**/\n    83,\n/**/\n    82,\n/**/\n    81,\n/**/\n    80,\n/**/\n    79,\n/**/\n    78,\n/**/\n    77,\n/**/\n    76,\n/**/\n    75,\n/**/\n    74,\n/**/\n    73,\n/**/\n    72,\n/**/\n    71,\n/**/\n    70,\n/**/\n    69,\n/**/\n    68,\n/**/\n    67,\n/**/\n    66,\n/**/\n    65,\n/**/\n    64,\n/**/\n    63,\n/**/\n    62,\n/**/\n    61,\n/**/\n    60,\n/**/\n    59,\n/**/\n    58,\n/**/\n    57,\n/**/\n    56,\n/**/\n    55,\n/**/\n    54,\n/**/\n    53,\n/**/\n    52,\n/**/\n    51,\n/**/\n    50,\n/**/\n    49,\n/**/\n    48,\n/**/\n    47,\n/**/\n    46,\n/**/\n    45,\n/**/\n    44,\n/**/\n    43,\n/**/\n    42,\n/**/\n    41,\n/**/\n    40,\n/**/\n    39,\n/**/\n    38,\n/**/\n    37,\n/**/\n    36,\n/**/\n    35,\n/**/\n    34,\n/**/\n    33,\n/**/\n    32,\n/**/\n    31,\n/**/\n    30,\n/**/\n    29,\n/**/\n    28,\n/**/\n    27,\n/**/\n    26,\n/**/\n    25,\n/**/\n    24,\n/**/\n    23,\n/**/\n    22,\n/**/\n    21,\n/**/\n    20,\n/**/\n    19,\n/**/\n    18,\n/**/\n    17,\n/**/\n    16,\n/**/\n    15,\n/**/\n    14,\n/**/\n    13,\n/**/\n    12,\n/**/\n    11,\n/**/\n    10,\n/**/\n    9,\n/**/\n    8,\n/**/\n    7,\n/**/\n    6,\n/**/\n    5,\n/**/\n    4,\n/**/\n    3,\n/**/\n    2,\n/**/\n    1,\n/**/\n    0\n};\n\n/*\n * Place to put a short description when adding a feature with a patch.\n * Keep it short, e.g.,: \"relative numbers\", \"persistent undo\".\n * Also add a comment marker to separate the lines.\n * See the official Vim patches for the diff format: It must use a context of\n * one line only.  Create it by hand or use \"diff -C2\" and edit the patch.\n */\nstatic char *(extra_patches[]) =\n{   /* Add your patch description below this line */\n/**/\n    NULL\n};\n\n    int\nhighest_patch(void)\n{\n    // this relies on the highest patch number to be the first entry\n    return included_patches[0];\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return TRUE if patch \"n\" has been included.\n */\n    int\nhas_patch(int n)\n{\n    int\t\th, m, l;\n\n    // Perform a binary search.\n    l = 0;\n    h = (int)ARRAY_LENGTH(included_patches) - 1;\n    for (;;)\n    {\n\tm = (l + h) / 2;\n\tif (included_patches[m] == n)\n\t    return TRUE;\n\tif (l == h)\n\t    break;\n\tif (included_patches[m] < n)\n\t    h = m;\n\telse\n\t    l = m + 1;\n    }\n    return FALSE;\n}\n#endif\n\n    void\nex_version(exarg_T *eap)\n{\n    /*\n     * Ignore a \":version 9.99\" command.\n     */\n    if (*eap->arg == NUL)\n    {\n\tmsg_putchar('\\n');\n\tlist_version();\n    }\n}\n\n/*\n * Output a string for the version message.  If it's going to wrap, output a\n * newline, unless the message is too long to fit on the screen anyway.\n * When \"wrap\" is TRUE wrap the string in [].\n */\n    static void\nversion_msg_wrap(char_u *s, int wrap)\n{\n    int\t\tlen = vim_strsize(s) + (wrap ? 2 : 0);\n\n    if (!got_int && len < (int)Columns && msg_col + len >= (int)Columns\n\t\t\t\t\t\t\t\t&& *s != '\\n')\n\tmsg_putchar('\\n');\n    if (!got_int)\n    {\n\tif (wrap)\n\t    msg_puts(\"[\");\n\tmsg_puts((char *)s);\n\tif (wrap)\n\t    msg_puts(\"]\");\n    }\n}\n\n    static void\nversion_msg(char *s)\n{\n    version_msg_wrap((char_u *)s, FALSE);\n}\n\n/*\n * List all features aligned in columns, dictionary style.\n */\n    static void\nlist_features(void)\n{\n    list_in_columns((char_u **)features, -1, -1);\n}\n\n/*\n * List string items nicely aligned in columns.\n * When \"size\" is < 0 then the last entry is marked with NULL.\n * The entry with index \"current\" is inclosed in [].\n */\n    void\nlist_in_columns(char_u **items, int size, int current)\n{\n    int\t\ti;\n    int\t\tncol;\n    int\t\tnrow;\n    int\t\tcur_row = 1;\n    int\t\titem_count = 0;\n    int\t\twidth = 0;\n#ifdef FEAT_SYN_HL\n    int\t\tuse_highlight = (items == (char_u **)features);\n#endif\n\n    // Find the length of the longest item, use that + 1 as the column\n    // width.\n    for (i = 0; size < 0 ? items[i] != NULL : i < size; ++i)\n    {\n\tint l = vim_strsize(items[i]) + (i == current ? 2 : 0);\n\n\tif (l > width)\n\t    width = l;\n\t++item_count;\n    }\n    width += 1;\n\n    if (Columns < width)\n    {\n\t// Not enough screen columns - show one per line\n\tfor (i = 0; i < item_count; ++i)\n\t{\n\t    version_msg_wrap(items[i], i == current);\n\t    if (msg_col > 0 && i < item_count - 1)\n\t\tmsg_putchar('\\n');\n\t}\n\treturn;\n    }\n\n    // The rightmost column doesn't need a separator.\n    // Sacrifice it to fit in one more column if possible.\n    ncol = (int) (Columns + 1) / width;\n    nrow = item_count / ncol + ((item_count % ncol) ? 1 : 0);\n\n    // \"i\" counts columns then rows.  \"idx\" counts rows then columns.\n    for (i = 0; !got_int && i < nrow * ncol; ++i)\n    {\n\tint idx = (i / ncol) + (i % ncol) * nrow;\n\n\tif (idx < item_count)\n\t{\n\t    int last_col = (i + 1) % ncol == 0;\n\n\t    if (idx == current)\n\t\tmsg_putchar('[');\n#ifdef FEAT_SYN_HL\n\t    if (use_highlight && items[idx][0] == '-')\n\t\tmsg_puts_attr((char *)items[idx], HL_ATTR(HLF_W));\n\t    else\n#endif\n\t\tmsg_puts((char *)items[idx]);\n\t    if (idx == current)\n\t\tmsg_putchar(']');\n\t    if (last_col)\n\t    {\n\t\tif (msg_col > 0 && cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t    else\n\t    {\n\t\twhile (msg_col % width)\n\t\t    msg_putchar(' ');\n\t    }\n\t}\n\telse\n\t{\n\t    // this row is out of items, thus at the end of the row\n\t    if (msg_col > 0)\n\t    {\n\t\tif (cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t}\n    }\n}\n\n    void\nlist_version(void)\n{\n    int\t\ti;\n    int\t\tfirst;\n    char\t*s = \"\";\n\n    /*\n     * When adding features here, don't forget to update the list of\n     * internal variables in eval.c!\n     */\n    init_longVersion();\n    msg(longVersion);\n#ifdef MSWIN\n# ifdef FEAT_GUI_MSWIN\n#  ifdef VIMDLL\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI/console version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI/console version\"));\n#   endif\n#  else\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI version\"));\n#   endif\n#  endif\n#  ifdef FEAT_OLE\n    msg_puts(_(\" with OLE support\"));\n#  endif\n# else\n#  ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit console version\"));\n#  else\n    msg_puts(_(\"\\nMS-Windows 32-bit console version\"));\n#  endif\n# endif\n#endif\n#if defined(MACOS_X)\n# if defined(MACOS_X_DARWIN)\n    msg_puts(_(\"\\nmacOS version\"));\n# else\n    msg_puts(_(\"\\nmacOS version w/o darwin feat.\"));\n# endif\n# if defined(__arm64__)\n    msg_puts(\" - arm64\");\n# elif defined(__x86_64__)\n    msg_puts(\" - x86_64\");\n# endif\n#endif\n\n#ifdef VMS\n    msg_puts(_(\"\\nOpenVMS version\"));\n# ifdef HAVE_PATHDEF\n    if (*compiled_arch != NUL)\n    {\n\tmsg_puts(\" - \");\n\tmsg_puts((char *)compiled_arch);\n    }\n# endif\n\n#endif\n\n    // Print the list of patch numbers if there is at least one.\n    // Print a range when patches are consecutive: \"1-10, 12, 15-40, 42-45\"\n    if (included_patches[0] != 0)\n    {\n\tmsg_puts(_(\"\\nIncluded patches: \"));\n\tfirst = -1;\n\ti = (int)ARRAY_LENGTH(included_patches) - 1;\n\twhile (--i >= 0)\n\t{\n\t    if (first < 0)\n\t\tfirst = included_patches[i];\n\t    if (i == 0 || included_patches[i - 1] != included_patches[i] + 1)\n\t    {\n\t\tmsg_puts(s);\n\t\ts = \", \";\n\t\tmsg_outnum((long)first);\n\t\tif (first != included_patches[i])\n\t\t{\n\t\t    msg_puts(\"-\");\n\t\t    msg_outnum((long)included_patches[i]);\n\t\t}\n\t\tfirst = -1;\n\t    }\n\t}\n    }\n\n    // Print the list of extra patch descriptions if there is at least one.\n    if (extra_patches[0] != NULL)\n    {\n\tmsg_puts(_(\"\\nExtra patches: \"));\n\ts = \"\";\n\tfor (i = 0; extra_patches[i] != NULL; ++i)\n\t{\n\t    msg_puts(s);\n\t    s = \", \";\n\t    msg_puts(extra_patches[i]);\n\t}\n    }\n\n#ifdef MODIFIED_BY\n    msg_puts(\"\\n\");\n    msg_puts(_(\"Modified by \"));\n    msg_puts(MODIFIED_BY);\n#endif\n\n#ifdef HAVE_PATHDEF\n    if (*compiled_user != NUL || *compiled_sys != NUL)\n    {\n\tmsg_puts(_(\"\\nCompiled \"));\n\tif (*compiled_user != NUL)\n\t{\n\t    msg_puts(_(\"by \"));\n\t    msg_puts((char *)compiled_user);\n\t}\n\tif (*compiled_sys != NUL)\n\t{\n\t    msg_puts(\"@\");\n\t    msg_puts((char *)compiled_sys);\n\t}\n    }\n#endif\n\n#if defined(FEAT_HUGE)\n    msg_puts(_(\"\\nHuge version \"));\n#elif defined(FEAT_NORMAL)\n    msg_puts(_(\"\\nNormal version \"));\n#else\n    msg_puts(_(\"\\nTiny version \"));\n#endif\n#if !defined(FEAT_GUI)\n    msg_puts(_(\"without GUI.\"));\n#elif defined(FEAT_GUI_GTK)\n# if defined(USE_GTK3)\n    msg_puts(_(\"with GTK3 GUI.\"));\n# elif defined(FEAT_GUI_GNOME)\n     msg_puts(_(\"with GTK2-GNOME GUI.\"));\n# else\n     msg_puts(_(\"with GTK2 GUI.\"));\n# endif\n#elif defined(FEAT_GUI_MOTIF)\n    msg_puts(_(\"with X11-Motif GUI.\"));\n#elif defined(FEAT_GUI_HAIKU)\n    msg_puts(_(\"with Haiku GUI.\"));\n#elif defined(FEAT_GUI_PHOTON)\n    msg_puts(_(\"with Photon GUI.\"));\n#elif defined(MSWIN)\n    msg_puts(_(\"with GUI.\"));\n#endif\n    version_msg(_(\"  Features included (+) or not (-):\\n\"));\n\n    list_features();\n    if (msg_col > 0)\n\tmsg_putchar('\\n');\n\n#ifdef SYS_VIMRC_FILE\n    version_msg(_(\"   system vimrc file: \\\"\"));\n    version_msg(SYS_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE\n    version_msg(_(\"     user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE2\n    version_msg(_(\" 2nd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE3\n    version_msg(_(\" 3rd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE\n    version_msg(_(\"      user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE2\n    version_msg(_(\"  2nd user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef FEAT_GUI\n# ifdef SYS_GVIMRC_FILE\n    version_msg(_(\"  system gvimrc file: \\\"\"));\n    version_msg(SYS_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n    version_msg(_(\"    user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# ifdef USR_GVIMRC_FILE2\n    version_msg(_(\"2nd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n# endif\n# ifdef USR_GVIMRC_FILE3\n    version_msg(_(\"3rd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n    version_msg(_(\"       defaults file: \\\"\"));\n    version_msg(VIM_DEFAULTS_FILE);\n    version_msg(\"\\\"\\n\");\n#ifdef FEAT_GUI\n# ifdef SYS_MENU_FILE\n    version_msg(_(\"    system menu file: \\\"\"));\n    version_msg(SYS_MENU_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n#ifdef HAVE_PATHDEF\n    if (*default_vim_dir != NUL)\n    {\n\tversion_msg(_(\"  fall-back for $VIM: \\\"\"));\n\tversion_msg((char *)default_vim_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    if (*default_vimruntime_dir != NUL)\n    {\n\tversion_msg(_(\" f-b for $VIMRUNTIME: \\\"\"));\n\tversion_msg((char *)default_vimruntime_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    version_msg(_(\"Compilation: \"));\n    version_msg((char *)all_cflags);\n    version_msg(\"\\n\");\n#ifdef VMS\n    if (*compiler_version != NUL)\n    {\n\tversion_msg(_(\"Compiler: \"));\n\tversion_msg((char *)compiler_version);\n\tversion_msg(\"\\n\");\n    }\n#endif\n    version_msg(_(\"Linking: \"));\n    version_msg((char *)all_lflags);\n#endif\n#ifdef DEBUG\n    version_msg(\"\\n\");\n    version_msg(_(\"  DEBUG BUILD\"));\n#endif\n}\n\nstatic void do_intro_line(int row, char_u *mesg, int add_version, int attr);\nstatic void intro_message(int colon);\n\n/*\n * Show the intro message when not editing a file.\n */\n    void\nmaybe_intro_message(void)\n{\n    if (BUFEMPTY()\n\t    && curbuf->b_fname == NULL\n\t    && firstwin->w_next == NULL\n\t    && vim_strchr(p_shm, SHM_INTRO) == NULL)\n\tintro_message(FALSE);\n}\n\n/*\n * Give an introductory message about Vim.\n * Only used when starting Vim on an empty file, without a file name.\n * Or with the \":intro\" command (for Sven :-).\n */\n    static void\nintro_message(\n    int\t\tcolon)\t\t// TRUE for \":intro\"\n{\n    int\t\ti;\n    int\t\trow;\n    int\t\tblanklines;\n    int\t\tsponsor;\n    char\t*p;\n    static char\t*(lines[]) =\n    {\n\tN_(\"VIM - Vi IMproved\"),\n\t\"\",\n\tN_(\"version \"),\n\tN_(\"by Bram Moolenaar et al.\"),\n#ifdef MODIFIED_BY\n\t\" \",\n#endif\n\tN_(\"Vim is open source and freely distributable\"),\n\t\"\",\n\tN_(\"Help poor children in Uganda!\"),\n\tN_(\"type  :help iccf<Enter>       for information \"),\n\t\"\",\n\tN_(\"type  :q<Enter>               to exit         \"),\n\tN_(\"type  :help<Enter>  or  <F1>  for on-line help\"),\n\tN_(\"type  :help version9<Enter>   for version info\"),\n\tNULL,\n\t\"\",\n\tN_(\"Running in Vi compatible mode\"),\n\tN_(\"type  :set nocp<Enter>        for Vim defaults\"),\n\tN_(\"type  :help cp-default<Enter> for info on this\"),\n    };\n#ifdef FEAT_GUI\n    static char\t*(gui_lines[]) =\n    {\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n#ifdef MODIFIED_BY\n\tNULL,\n#endif\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Help->Orphans           for information    \"),\n\tNULL,\n\tN_(\"Running modeless, typed text is inserted\"),\n\tN_(\"menu  Edit->Global Settings->Toggle Insert Mode  \"),\n\tN_(\"                              for two modes      \"),\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Edit->Global Settings->Toggle Vi Compatible\"),\n\tN_(\"                              for Vim defaults   \"),\n    };\n#endif\n\n    // blanklines = screen height - # message lines\n    blanklines = (int)Rows - (ARRAY_LENGTH(lines) - 1);\n    if (!p_cp)\n\tblanklines += 4;  // add 4 for not showing \"Vi compatible\" message\n\n    // Don't overwrite a statusline.  Depends on 'cmdheight'.\n    if (p_ls > 1)\n\tblanklines -= Rows - topframe->fr_height;\n    if (blanklines < 0)\n\tblanklines = 0;\n\n    // Show the sponsor and register message one out of four times, the Uganda\n    // message two out of four times.\n    sponsor = (int)time(NULL);\n    sponsor = ((sponsor & 2) == 0) - ((sponsor & 4) == 0);\n\n    // start displaying the message lines after half of the blank lines\n    row = blanklines / 2;\n    if ((row >= 2 && Columns >= 50) || colon)\n    {\n\tfor (i = 0; i < (int)ARRAY_LENGTH(lines); ++i)\n\t{\n\t    p = lines[i];\n#ifdef FEAT_GUI\n\t    if (p_im && gui.in_use && gui_lines[i] != NULL)\n\t\tp = gui_lines[i];\n#endif\n\t    if (p == NULL)\n\t    {\n\t\tif (!p_cp)\n\t\t    break;\n\t\tcontinue;\n\t    }\n\t    if (sponsor != 0)\n\t    {\n\t\tif (strstr(p, \"children\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"Sponsor Vim development!\")\n\t\t\t: N_(\"Become a registered Vim user!\");\n\t\telse if (strstr(p, \"iccf\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"type  :help sponsor<Enter>    for information \")\n\t\t\t: N_(\"type  :help register<Enter>   for information \");\n\t\telse if (strstr(p, \"Orphans\") != NULL)\n\t\t    p = N_(\"menu  Help->Sponsor/Register  for information    \");\n\t    }\n\t    if (*p != NUL)\n\t\tdo_intro_line(row, (char_u *)_(p), i == 2, 0);\n\t    ++row;\n\t}\n    }\n\n    // Make the wait-return message appear just below the text.\n    if (colon)\n\tmsg_row = row;\n}\n\n    static void\ndo_intro_line(\n    int\t\trow,\n    char_u\t*mesg,\n    int\t\tadd_version,\n    int\t\tattr)\n{\n    char_u\tvers[20];\n    int\t\tcol;\n    char_u\t*p;\n    int\t\tl;\n    int\t\tclen;\n#ifdef MODIFIED_BY\n# define MODBY_LEN 150\n    char_u\tmodby[MODBY_LEN];\n\n    if (*mesg == ' ')\n    {\n\tvim_strncpy(modby, (char_u *)_(\"Modified by \"), MODBY_LEN - 1);\n\tl = (int)STRLEN(modby);\n\tvim_strncpy(modby + l, (char_u *)MODIFIED_BY, MODBY_LEN - l - 1);\n\tmesg = modby;\n    }\n#endif\n\n    // Center the message horizontally.\n    col = vim_strsize(mesg);\n    if (add_version)\n    {\n\tSTRCPY(vers, mediumVersion);\n\tif (highest_patch())\n\t{\n\t    // Check for 9.9x or 9.9xx, alpha/beta version\n\t    if (isalpha((int)vers[3]))\n\t    {\n\t\tint len = (isalpha((int)vers[4])) ? 5 : 4;\n\t\tsprintf((char *)vers + len, \".%d%s\", highest_patch(),\n\t\t\t\t\t\t\t mediumVersion + len);\n\t    }\n\t    else\n\t\tsprintf((char *)vers + 3, \".%d\", highest_patch());\n\t}\n\tcol += (int)STRLEN(vers);\n    }\n    col = (Columns - col) / 2;\n    if (col < 0)\n\tcol = 0;\n\n    // Split up in parts to highlight <> items differently.\n    for (p = mesg; *p != NUL; p += l)\n    {\n\tclen = 0;\n\tfor (l = 0; p[l] != NUL\n\t\t\t && (l == 0 || (p[l] != '<' && p[l - 1] != '>')); ++l)\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tclen += ptr2cells(p + l);\n\t\tl += (*mb_ptr2len)(p + l) - 1;\n\t    }\n\t    else\n\t\tclen += byte2cells(p[l]);\n\t}\n\tscreen_puts_len(p, l, row, col, *p == '<' ? HL_ATTR(HLF_8) : attr);\n\tcol += clen;\n    }\n\n    // Add the version number to the version line.\n    if (add_version)\n\tscreen_puts(vers, row, col, 0);\n}\n\n/*\n * \":intro\": clear screen, display intro screen and wait for return.\n */\n    void\nex_intro(exarg_T *eap UNUSED)\n{\n    screenclear();\n    intro_message(TRUE);\n    wait_return(TRUE);\n}\n"], "filenames": ["src/regexp.c", "src/testdir/test_substitute.vim", "src/version.c"], "buggy_code_start_loc": [1770, 1416, 697], "buggy_code_end_loc": [1800, 1416, 697], "fixing_code_start_loc": [1769, 1417, 698], "fixing_code_end_loc": [1808, 1431, 700], "type": "CWE-190", "message": "Integer Overflow or Wraparound in GitHub repository vim/vim prior to 9.0.1532.", "other": {"cve": {"id": "CVE-2023-2610", "sourceIdentifier": "security@huntr.dev", "published": "2023-05-09T22:15:10.197", "lastModified": "2023-05-24T05:15:12.677", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Integer Overflow or Wraparound in GitHub repository vim/vim prior to 9.0.1532."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-190"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:vim:vim:*:*:*:*:*:*:*:*", "versionEndExcluding": "9.0.1532", "matchCriteriaId": "2D2C26EC-72A8-44BC-BD3D-B2878B8C3EBA"}]}]}], "references": [{"url": "https://github.com/vim/vim/commit/ab9a2d884b3a4abe319606ea95a5a6d6b01cd73a", "source": "security@huntr.dev", "tags": ["Patch"]}, {"url": "https://huntr.dev/bounties/31e67340-935b-4f6c-a923-f7246bc29c7d", "source": "security@huntr.dev", "tags": ["Exploit", "Patch"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/PCLJN4QINITA3ZASKLEJ64C5TFNKELMO/", "source": "security@huntr.dev"}]}, "github_commit_url": "https://github.com/vim/vim/commit/ab9a2d884b3a4abe319606ea95a5a6d6b01cd73a"}}