{"buggy_code": ["package logic\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/golang-jwt/jwt/v4\"\n\t\"github.com/gravitl/netmaker/logger\"\n\t\"github.com/gravitl/netmaker/models\"\n\t\"github.com/gravitl/netmaker/servercfg\"\n)\n\nvar jwtSecretKey []byte\n\n// SetJWTSecret - sets the jwt secret on server startup\nfunc SetJWTSecret() {\n\tcurrentSecret, jwtErr := FetchJWTSecret()\n\tif jwtErr != nil {\n\t\tjwtSecretKey = []byte(RandomString(64)) // 512 bit random password\n\t\tif err := StoreJWTSecret(string(jwtSecretKey)); err != nil {\n\t\t\tlogger.FatalLog(\"something went wrong when configuring JWT authentication\")\n\t\t}\n\t} else {\n\t\tjwtSecretKey = []byte(currentSecret)\n\t}\n}\n\n// CreateJWT func will used to create the JWT while signing in and signing out\nfunc CreateJWT(uuid string, macAddress string, network string) (response string, err error) {\n\texpirationTime := time.Now().Add(5 * time.Minute)\n\tclaims := &models.Claims{\n\t\tID:         uuid,\n\t\tNetwork:    network,\n\t\tMacAddress: macAddress,\n\t\tStandardClaims: jwt.StandardClaims{\n\t\t\tIssuer:    \"Netmaker\",\n\t\t\tSubject:   fmt.Sprintf(\"node|%s\", uuid),\n\t\t\tIssuedAt:  time.Now().Unix(),\n\t\t\tExpiresAt: expirationTime.Unix(),\n\t\t},\n\t}\n\n\ttoken := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)\n\ttokenString, err := token.SignedString(jwtSecretKey)\n\tif err == nil {\n\t\treturn tokenString, nil\n\t}\n\treturn \"\", err\n}\n\n// CreateUserJWT - creates a user jwt token\nfunc CreateUserJWT(username string, networks []string, isadmin bool) (response string, err error) {\n\texpirationTime := time.Now().Add(60 * 12 * time.Minute)\n\tclaims := &models.UserClaims{\n\t\tUserName: username,\n\t\tNetworks: networks,\n\t\tIsAdmin:  isadmin,\n\t\tStandardClaims: jwt.StandardClaims{\n\t\t\tIssuer:    \"Netmaker\",\n\t\t\tIssuedAt:  time.Now().Unix(),\n\t\t\tSubject:   fmt.Sprintf(\"user|%s\", username),\n\t\t\tExpiresAt: expirationTime.Unix(),\n\t\t},\n\t}\n\n\ttoken := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)\n\ttokenString, err := token.SignedString(jwtSecretKey)\n\tif err == nil {\n\t\treturn tokenString, nil\n\t}\n\treturn \"\", err\n}\n\n// VerifyToken func will used to Verify the JWT Token while using APIS\nfunc VerifyUserToken(tokenString string) (username string, networks []string, isadmin bool, err error) {\n\tclaims := &models.UserClaims{}\n\n\tif tokenString == servercfg.GetMasterKey() {\n\t\treturn \"masteradministrator\", nil, true, nil\n\t}\n\n\ttoken, err := jwt.ParseWithClaims(tokenString, claims, func(token *jwt.Token) (interface{}, error) {\n\t\treturn jwtSecretKey, nil\n\t})\n\n\tif token != nil && token.Valid {\n\t\t// check that user exists\n\t\tif user, err := GetUser(claims.UserName); user.UserName != \"\" && err == nil {\n\t\t\treturn claims.UserName, claims.Networks, claims.IsAdmin, nil\n\t\t}\n\t\terr = errors.New(\"user does not exist\")\n\t}\n\treturn \"\", nil, false, err\n}\n\n// VerifyToken - gRPC [nodes] Only\nfunc VerifyToken(tokenString string) (nodeID string, mac string, network string, err error) {\n\tclaims := &models.Claims{}\n\n\t//this may be a stupid way of serving up a master key\n\t//TODO: look into a different method. Encryption?\n\tif tokenString == servercfg.GetMasterKey() {\n\t\treturn \"mastermac\", \"\", \"\", nil\n\t}\n\n\ttoken, err := jwt.ParseWithClaims(tokenString, claims, func(token *jwt.Token) (interface{}, error) {\n\t\treturn jwtSecretKey, nil\n\t})\n\n\tif token != nil {\n\t\treturn claims.ID, claims.MacAddress, claims.Network, nil\n\t}\n\treturn \"\", \"\", \"\", err\n}\n", "// package for logicing client and server code\npackage logic\n\nimport (\n\t\"encoding/base64\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"math/rand\"\n\t\"net\"\n\t\"os\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/gravitl/netmaker/database\"\n\t\"github.com/gravitl/netmaker/logger\"\n\t\"github.com/gravitl/netmaker/models\"\n\t\"github.com/gravitl/netmaker/netclient/ncutils\"\n\t\"github.com/gravitl/netmaker/servercfg\"\n)\n\n// IsBase64 - checks if a string is in base64 format\n// This is used to validate public keys (make sure they're base64 encoded like all public keys should be).\nfunc IsBase64(s string) bool {\n\t_, err := base64.StdEncoding.DecodeString(s)\n\treturn err == nil\n}\n\n// CheckEndpoint - checks if an endpoint is valid\nfunc CheckEndpoint(endpoint string) bool {\n\tendpointarr := strings.Split(endpoint, \":\")\n\treturn len(endpointarr) == 2\n}\n\n// FileExists - checks if local file exists\nfunc FileExists(f string) bool {\n\tinfo, err := os.Stat(f)\n\tif os.IsNotExist(err) {\n\t\treturn false\n\t}\n\treturn !info.IsDir()\n}\n\n// IsAddressInCIDR - util to see if an address is in a cidr or not\nfunc IsAddressInCIDR(address, cidr string) bool {\n\tvar _, currentCIDR, cidrErr = net.ParseCIDR(cidr)\n\tif cidrErr != nil {\n\t\treturn false\n\t}\n\tvar addrParts = strings.Split(address, \".\")\n\tvar addrPartLength = len(addrParts)\n\tif addrPartLength != 4 {\n\t\treturn false\n\t} else {\n\t\tif addrParts[addrPartLength-1] == \"0\" ||\n\t\t\taddrParts[addrPartLength-1] == \"255\" {\n\t\t\treturn false\n\t\t}\n\t}\n\tip, _, err := net.ParseCIDR(fmt.Sprintf(\"%s/32\", address))\n\tif err != nil {\n\t\treturn false\n\t}\n\treturn currentCIDR.Contains(ip)\n}\n\n// SetNetworkNodesLastModified - sets the network nodes last modified\nfunc SetNetworkNodesLastModified(networkName string) error {\n\n\ttimestamp := time.Now().Unix()\n\n\tnetwork, err := GetParentNetwork(networkName)\n\tif err != nil {\n\t\treturn err\n\t}\n\tnetwork.NodesLastModified = timestamp\n\tdata, err := json.Marshal(&network)\n\tif err != nil {\n\t\treturn err\n\t}\n\terr = database.Insert(networkName, string(data), database.NETWORKS_TABLE_NAME)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\n// // GetNode - fetches a node from database\n// func GetNode(macaddress string, network string) (models.Node, error) {\n// \tvar node models.Node\n\n// \tkey, err := GetRecordKey(macaddress, network)\n// \tif err != nil {\n// \t\treturn node, err\n// \t}\n// \tdata, err := database.FetchRecord(database.NODES_TABLE_NAME, key)\n// \tif err != nil {\n// \t\tif data == \"\" {\n// \t\t\tdata, _ = database.FetchRecord(database.DELETED_NODES_TABLE_NAME, key)\n// \t\t\terr = json.Unmarshal([]byte(data), &node)\n// \t\t}\n// \t\treturn node, err\n// \t}\n// \tif err = json.Unmarshal([]byte(data), &node); err != nil {\n// \t\treturn node, err\n// \t}\n// \tSetNodeDefaults(&node)\n\n// \treturn node, err\n// }\n\n// DeleteNodeByID - deletes a node from database or moves into delete nodes table\nfunc DeleteNodeByID(node *models.Node, exterminate bool) error {\n\tvar err error\n\tvar key = node.ID\n\tif !exterminate {\n\t\tnode.Action = models.NODE_DELETE\n\t\tnodedata, err := json.Marshal(&node)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\terr = database.Insert(key, string(nodedata), database.DELETED_NODES_TABLE_NAME)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t} else {\n\t\tif err := database.DeleteRecord(database.DELETED_NODES_TABLE_NAME, key); err != nil {\n\t\t\tlogger.Log(2, err.Error())\n\t\t}\n\t}\n\tif err = database.DeleteRecord(database.NODES_TABLE_NAME, key); err != nil {\n\t\treturn err\n\t}\n\tif servercfg.IsDNSMode() {\n\t\tSetDNS()\n\t}\n\treturn removeLocalServer(node)\n}\n\n// GetNodePeers - fetches peers for a given node\nfunc GetNodePeers(networkName string, excludeRelayed bool) ([]models.Node, error) {\n\tvar peers []models.Node\n\tvar networkNodes, egressNetworkNodes, err = getNetworkEgressAndNodes(networkName)\n\tif err != nil {\n\t\treturn peers, nil\n\t}\n\n\tudppeers, errN := database.GetPeers(networkName)\n\tif errN != nil {\n\t\tlogger.Log(2, errN.Error())\n\t}\n\n\tfor _, node := range networkNodes {\n\t\tvar peer = models.Node{}\n\t\tif node.IsEgressGateway == \"yes\" { // handle egress stuff\n\t\t\tpeer.EgressGatewayRanges = node.EgressGatewayRanges\n\t\t\tpeer.IsEgressGateway = node.IsEgressGateway\n\t\t}\n\t\tallow := node.IsRelayed != \"yes\" || !excludeRelayed\n\n\t\tif node.Network == networkName && node.IsPending != \"yes\" && allow {\n\t\t\tpeer = setPeerInfo(&node)\n\t\t\tif node.UDPHolePunch == \"yes\" && errN == nil && CheckEndpoint(udppeers[node.PublicKey]) {\n\t\t\t\tendpointstring := udppeers[node.PublicKey]\n\t\t\t\tendpointarr := strings.Split(endpointstring, \":\")\n\t\t\t\tif len(endpointarr) == 2 {\n\t\t\t\t\tport, err := strconv.Atoi(endpointarr[1])\n\t\t\t\t\tif err == nil {\n\t\t\t\t\t\t// peer.Endpoint = endpointarr[0]\n\t\t\t\t\t\tpeer.ListenPort = int32(port)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif node.IsRelay == \"yes\" {\n\t\t\t\tnetwork, err := GetNetwork(networkName)\n\t\t\t\tif err == nil {\n\t\t\t\t\tpeer.AllowedIPs = append(peer.AllowedIPs, network.AddressRange)\n\t\t\t\t} else {\n\t\t\t\t\tpeer.AllowedIPs = append(peer.AllowedIPs, node.RelayAddrs...)\n\t\t\t\t}\n\t\t\t\tfor _, egressNode := range egressNetworkNodes {\n\t\t\t\t\tif egressNode.IsRelayed == \"yes\" && StringSliceContains(node.RelayAddrs, egressNode.Address) {\n\t\t\t\t\t\tpeer.AllowedIPs = append(peer.AllowedIPs, egressNode.EgressGatewayRanges...)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tpeers = append(peers, peer)\n\t\t}\n\t}\n\n\treturn peers, err\n}\n\n// GetPeersList - gets the peers of a given network\nfunc GetPeersList(networkName string, excludeRelayed bool, relayedNodeAddr string) ([]models.Node, error) {\n\tvar peers []models.Node\n\tvar err error\n\tif relayedNodeAddr == \"\" {\n\t\tpeers, err = GetNodePeers(networkName, excludeRelayed)\n\t} else {\n\t\tvar relayNode models.Node\n\t\trelayNode, err = GetNodeRelay(networkName, relayedNodeAddr)\n\t\tif relayNode.Address != \"\" {\n\t\t\tvar peerNode = setPeerInfo(&relayNode)\n\t\t\tnetwork, err := GetNetwork(networkName)\n\t\t\tif err == nil {\n\t\t\t\tpeerNode.AllowedIPs = append(peerNode.AllowedIPs, network.AddressRange)\n\t\t\t\tvar _, egressNetworkNodes, err = getNetworkEgressAndNodes(networkName)\n\t\t\t\tif err == nil {\n\t\t\t\t\tfor _, egress := range egressNetworkNodes {\n\t\t\t\t\t\tif egress.Address != relayedNodeAddr {\n\t\t\t\t\t\t\tpeerNode.AllowedIPs = append(peerNode.AllowedIPs, egress.EgressGatewayRanges...)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tpeerNode.AllowedIPs = append(peerNode.AllowedIPs, peerNode.RelayAddrs...)\n\t\t\t}\n\t\t\tnodepeers, err := GetNodePeers(networkName, false)\n\t\t\tif err == nil && peerNode.UDPHolePunch == \"yes\" {\n\t\t\t\tfor _, nodepeer := range nodepeers {\n\t\t\t\t\tif nodepeer.Address == peerNode.Address {\n\t\t\t\t\t\t// peerNode.Endpoint = nodepeer.Endpoint\n\t\t\t\t\t\tpeerNode.ListenPort = nodepeer.ListenPort\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tpeers = append(peers, peerNode)\n\t\t}\n\t}\n\treturn peers, err\n}\n\n// RandomString - returns a random string in a charset\nfunc RandomString(length int) string {\n\tconst charset = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\"\n\n\tvar seededRand *rand.Rand = rand.New(rand.NewSource(time.Now().UnixNano()))\n\n\tb := make([]byte, length)\n\tfor i := range b {\n\t\tb[i] = charset[seededRand.Intn(len(charset))]\n\t}\n\treturn string(b)\n}\n\n// == Private Methods ==\n\nfunc getNetworkEgressAndNodes(networkName string) ([]models.Node, []models.Node, error) {\n\tvar networkNodes, egressNetworkNodes []models.Node\n\tcollection, err := database.FetchRecords(database.NODES_TABLE_NAME)\n\tif err != nil {\n\t\tif database.IsEmptyRecord(err) {\n\t\t\treturn networkNodes, egressNetworkNodes, nil\n\t\t}\n\t\tlogger.Log(2, err.Error())\n\t\treturn nil, nil, err\n\t}\n\n\tfor _, value := range collection {\n\t\tvar node = models.Node{}\n\t\terr := json.Unmarshal([]byte(value), &node)\n\t\tif err != nil {\n\t\t\tlogger.Log(2, err.Error())\n\t\t\tcontinue\n\t\t}\n\t\tif node.Network == networkName {\n\t\t\tnetworkNodes = append(networkNodes, node)\n\t\t\tif node.IsEgressGateway == \"yes\" {\n\t\t\t\tegressNetworkNodes = append(egressNetworkNodes, node)\n\t\t\t}\n\t\t}\n\t}\n\treturn networkNodes, egressNetworkNodes, nil\n}\n\nfunc setPeerInfo(node *models.Node) models.Node {\n\tvar peer models.Node\n\tpeer.RelayAddrs = node.RelayAddrs\n\tpeer.IsRelay = node.IsRelay\n\tpeer.IsServer = node.IsServer\n\tpeer.IsRelayed = node.IsRelayed\n\tpeer.PublicKey = node.PublicKey\n\tpeer.Endpoint = node.Endpoint\n\tpeer.Name = node.Name\n\tpeer.LocalAddress = node.LocalAddress\n\tpeer.ListenPort = node.ListenPort\n\tpeer.AllowedIPs = node.AllowedIPs\n\tpeer.UDPHolePunch = node.UDPHolePunch\n\tpeer.Address = node.Address\n\tpeer.Address6 = node.Address6\n\tpeer.EgressGatewayRanges = node.EgressGatewayRanges\n\tpeer.IsEgressGateway = node.IsEgressGateway\n\tpeer.IngressGatewayRange = node.IngressGatewayRange\n\tpeer.IsIngressGateway = node.IsIngressGateway\n\tpeer.IsPending = node.IsPending\n\treturn peer\n}\n\nfunc setIPForwardingLinux() error {\n\tout, err := ncutils.RunCmd(\"sysctl net.ipv4.ip_forward\", true)\n\tif err != nil {\n\t\tlogger.Log(0, \"WARNING: Error encountered setting ip forwarding. This can break functionality.\")\n\t\treturn err\n\t} else {\n\t\ts := strings.Fields(string(out))\n\t\tif s[2] != \"1\" {\n\t\t\t_, err = ncutils.RunCmd(\"sysctl -w net.ipv4.ip_forward=1\", true)\n\t\t\tif err != nil {\n\t\t\t\tlogger.Log(0, \"WARNING: Error encountered setting ip forwarding. You may want to investigate this.\")\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}\n\n// StringSliceContains - sees if a string slice contains a string element\nfunc StringSliceContains(slice []string, item string) bool {\n\tfor _, s := range slice {\n\t\tif s == item {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n// == private ==\n\n// sets the network server peers of a given node\nfunc setNetworkServerPeers(serverNode *models.Node) {\n\tif currentPeersList, err := getSystemPeers(serverNode); err == nil {\n\t\tif database.SetPeers(currentPeersList, serverNode.Network) {\n\t\t\tlogger.Log(1, \"set new peers on network\", serverNode.Network)\n\t\t}\n\t} else {\n\t\tlogger.Log(1, \"could not set peers on network\", serverNode.Network, \":\", err.Error())\n\t}\n}\n\n// ShouldPublishPeerPorts - Gets ports from iface, sets, and returns true if they are different\nfunc ShouldPublishPeerPorts(serverNode *models.Node) bool {\n\tif currentPeersList, err := getSystemPeers(serverNode); err == nil {\n\t\tif database.SetPeers(currentPeersList, serverNode.Network) {\n\t\t\tlogger.Log(1, \"set new peers on network\", serverNode.Network)\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n"], "fixing_code": ["package logic\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/golang-jwt/jwt/v4\"\n\t\"github.com/gravitl/netmaker/logger\"\n\t\"github.com/gravitl/netmaker/models\"\n\t\"github.com/gravitl/netmaker/servercfg\"\n)\n\nvar jwtSecretKey []byte\n\n// SetJWTSecret - sets the jwt secret on server startup\nfunc SetJWTSecret() {\n\tcurrentSecret, jwtErr := FetchJWTSecret()\n\tif jwtErr != nil {\n\t\tnewValue, err := GenerateCryptoString(64)\n\t\tif err != nil {\n\t\t\tlogger.FatalLog(\"something went wrong when generating JWT signature\")\n\t\t}\n\t\tjwtSecretKey = []byte(newValue) // 512 bit random password\n\t\tif err := StoreJWTSecret(string(jwtSecretKey)); err != nil {\n\t\t\tlogger.FatalLog(\"something went wrong when configuring JWT authentication\")\n\t\t}\n\t} else {\n\t\tjwtSecretKey = []byte(currentSecret)\n\t}\n}\n\n// CreateJWT func will used to create the JWT while signing in and signing out\nfunc CreateJWT(uuid string, macAddress string, network string) (response string, err error) {\n\texpirationTime := time.Now().Add(5 * time.Minute)\n\tclaims := &models.Claims{\n\t\tID:         uuid,\n\t\tNetwork:    network,\n\t\tMacAddress: macAddress,\n\t\tStandardClaims: jwt.StandardClaims{\n\t\t\tIssuer:    \"Netmaker\",\n\t\t\tSubject:   fmt.Sprintf(\"node|%s\", uuid),\n\t\t\tIssuedAt:  time.Now().Unix(),\n\t\t\tExpiresAt: expirationTime.Unix(),\n\t\t},\n\t}\n\n\ttoken := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)\n\ttokenString, err := token.SignedString(jwtSecretKey)\n\tif err == nil {\n\t\treturn tokenString, nil\n\t}\n\treturn \"\", err\n}\n\n// CreateUserJWT - creates a user jwt token\nfunc CreateUserJWT(username string, networks []string, isadmin bool) (response string, err error) {\n\texpirationTime := time.Now().Add(60 * 12 * time.Minute)\n\tclaims := &models.UserClaims{\n\t\tUserName: username,\n\t\tNetworks: networks,\n\t\tIsAdmin:  isadmin,\n\t\tStandardClaims: jwt.StandardClaims{\n\t\t\tIssuer:    \"Netmaker\",\n\t\t\tIssuedAt:  time.Now().Unix(),\n\t\t\tSubject:   fmt.Sprintf(\"user|%s\", username),\n\t\t\tExpiresAt: expirationTime.Unix(),\n\t\t},\n\t}\n\n\ttoken := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)\n\ttokenString, err := token.SignedString(jwtSecretKey)\n\tif err == nil {\n\t\treturn tokenString, nil\n\t}\n\treturn \"\", err\n}\n\n// VerifyToken func will used to Verify the JWT Token while using APIS\nfunc VerifyUserToken(tokenString string) (username string, networks []string, isadmin bool, err error) {\n\tclaims := &models.UserClaims{}\n\n\tif tokenString == servercfg.GetMasterKey() {\n\t\treturn \"masteradministrator\", nil, true, nil\n\t}\n\n\ttoken, err := jwt.ParseWithClaims(tokenString, claims, func(token *jwt.Token) (interface{}, error) {\n\t\treturn jwtSecretKey, nil\n\t})\n\n\tif token != nil && token.Valid {\n\t\t// check that user exists\n\t\tif user, err := GetUser(claims.UserName); user.UserName != \"\" && err == nil {\n\t\t\treturn claims.UserName, claims.Networks, claims.IsAdmin, nil\n\t\t}\n\t\terr = errors.New(\"user does not exist\")\n\t}\n\treturn \"\", nil, false, err\n}\n\n// VerifyToken - gRPC [nodes] Only\nfunc VerifyToken(tokenString string) (nodeID string, mac string, network string, err error) {\n\tclaims := &models.Claims{}\n\n\t//this may be a stupid way of serving up a master key\n\t//TODO: look into a different method. Encryption?\n\tif tokenString == servercfg.GetMasterKey() {\n\t\treturn \"mastermac\", \"\", \"\", nil\n\t}\n\n\ttoken, err := jwt.ParseWithClaims(tokenString, claims, func(token *jwt.Token) (interface{}, error) {\n\t\treturn jwtSecretKey, nil\n\t})\n\n\tif token != nil {\n\t\treturn claims.ID, claims.MacAddress, claims.Network, nil\n\t}\n\treturn \"\", \"\", \"\", err\n}\n", "// package for logicing client and server code\npackage logic\n\nimport (\n\tcrand \"crypto/rand\"\n\t\"encoding/base64\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"math/big\"\n\t\"math/rand\"\n\t\"net\"\n\t\"os\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/gravitl/netmaker/database\"\n\t\"github.com/gravitl/netmaker/logger\"\n\t\"github.com/gravitl/netmaker/models\"\n\t\"github.com/gravitl/netmaker/netclient/ncutils\"\n\t\"github.com/gravitl/netmaker/servercfg\"\n)\n\n// IsBase64 - checks if a string is in base64 format\n// This is used to validate public keys (make sure they're base64 encoded like all public keys should be).\nfunc IsBase64(s string) bool {\n\t_, err := base64.StdEncoding.DecodeString(s)\n\treturn err == nil\n}\n\n// CheckEndpoint - checks if an endpoint is valid\nfunc CheckEndpoint(endpoint string) bool {\n\tendpointarr := strings.Split(endpoint, \":\")\n\treturn len(endpointarr) == 2\n}\n\n// FileExists - checks if local file exists\nfunc FileExists(f string) bool {\n\tinfo, err := os.Stat(f)\n\tif os.IsNotExist(err) {\n\t\treturn false\n\t}\n\treturn !info.IsDir()\n}\n\n// IsAddressInCIDR - util to see if an address is in a cidr or not\nfunc IsAddressInCIDR(address, cidr string) bool {\n\tvar _, currentCIDR, cidrErr = net.ParseCIDR(cidr)\n\tif cidrErr != nil {\n\t\treturn false\n\t}\n\tvar addrParts = strings.Split(address, \".\")\n\tvar addrPartLength = len(addrParts)\n\tif addrPartLength != 4 {\n\t\treturn false\n\t} else {\n\t\tif addrParts[addrPartLength-1] == \"0\" ||\n\t\t\taddrParts[addrPartLength-1] == \"255\" {\n\t\t\treturn false\n\t\t}\n\t}\n\tip, _, err := net.ParseCIDR(fmt.Sprintf(\"%s/32\", address))\n\tif err != nil {\n\t\treturn false\n\t}\n\treturn currentCIDR.Contains(ip)\n}\n\n// SetNetworkNodesLastModified - sets the network nodes last modified\nfunc SetNetworkNodesLastModified(networkName string) error {\n\n\ttimestamp := time.Now().Unix()\n\n\tnetwork, err := GetParentNetwork(networkName)\n\tif err != nil {\n\t\treturn err\n\t}\n\tnetwork.NodesLastModified = timestamp\n\tdata, err := json.Marshal(&network)\n\tif err != nil {\n\t\treturn err\n\t}\n\terr = database.Insert(networkName, string(data), database.NETWORKS_TABLE_NAME)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\n// GenerateCryptoString - generates random string of n length\nfunc GenerateCryptoString(n int) (string, error) {\n\tconst chars = \"123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-\"\n\tret := make([]byte, n)\n\tfor i := range ret {\n\t\tnum, err := crand.Int(crand.Reader, big.NewInt(int64(len(chars))))\n\t\tif err != nil {\n\t\t\treturn \"\", err\n\t\t}\n\t\tret[i] = chars[num.Int64()]\n\t}\n\n\treturn string(ret), nil\n}\n\n// DeleteNodeByID - deletes a node from database or moves into delete nodes table\nfunc DeleteNodeByID(node *models.Node, exterminate bool) error {\n\tvar err error\n\tvar key = node.ID\n\tif !exterminate {\n\t\tnode.Action = models.NODE_DELETE\n\t\tnodedata, err := json.Marshal(&node)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\terr = database.Insert(key, string(nodedata), database.DELETED_NODES_TABLE_NAME)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t} else {\n\t\tif err := database.DeleteRecord(database.DELETED_NODES_TABLE_NAME, key); err != nil {\n\t\t\tlogger.Log(2, err.Error())\n\t\t}\n\t}\n\tif err = database.DeleteRecord(database.NODES_TABLE_NAME, key); err != nil {\n\t\treturn err\n\t}\n\tif servercfg.IsDNSMode() {\n\t\tSetDNS()\n\t}\n\treturn removeLocalServer(node)\n}\n\n// GetNodePeers - fetches peers for a given node\nfunc GetNodePeers(networkName string, excludeRelayed bool) ([]models.Node, error) {\n\tvar peers []models.Node\n\tvar networkNodes, egressNetworkNodes, err = getNetworkEgressAndNodes(networkName)\n\tif err != nil {\n\t\treturn peers, nil\n\t}\n\n\tudppeers, errN := database.GetPeers(networkName)\n\tif errN != nil {\n\t\tlogger.Log(2, errN.Error())\n\t}\n\n\tfor _, node := range networkNodes {\n\t\tvar peer = models.Node{}\n\t\tif node.IsEgressGateway == \"yes\" { // handle egress stuff\n\t\t\tpeer.EgressGatewayRanges = node.EgressGatewayRanges\n\t\t\tpeer.IsEgressGateway = node.IsEgressGateway\n\t\t}\n\t\tallow := node.IsRelayed != \"yes\" || !excludeRelayed\n\n\t\tif node.Network == networkName && node.IsPending != \"yes\" && allow {\n\t\t\tpeer = setPeerInfo(&node)\n\t\t\tif node.UDPHolePunch == \"yes\" && errN == nil && CheckEndpoint(udppeers[node.PublicKey]) {\n\t\t\t\tendpointstring := udppeers[node.PublicKey]\n\t\t\t\tendpointarr := strings.Split(endpointstring, \":\")\n\t\t\t\tif len(endpointarr) == 2 {\n\t\t\t\t\tport, err := strconv.Atoi(endpointarr[1])\n\t\t\t\t\tif err == nil {\n\t\t\t\t\t\t// peer.Endpoint = endpointarr[0]\n\t\t\t\t\t\tpeer.ListenPort = int32(port)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif node.IsRelay == \"yes\" {\n\t\t\t\tnetwork, err := GetNetwork(networkName)\n\t\t\t\tif err == nil {\n\t\t\t\t\tpeer.AllowedIPs = append(peer.AllowedIPs, network.AddressRange)\n\t\t\t\t} else {\n\t\t\t\t\tpeer.AllowedIPs = append(peer.AllowedIPs, node.RelayAddrs...)\n\t\t\t\t}\n\t\t\t\tfor _, egressNode := range egressNetworkNodes {\n\t\t\t\t\tif egressNode.IsRelayed == \"yes\" && StringSliceContains(node.RelayAddrs, egressNode.Address) {\n\t\t\t\t\t\tpeer.AllowedIPs = append(peer.AllowedIPs, egressNode.EgressGatewayRanges...)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tpeers = append(peers, peer)\n\t\t}\n\t}\n\n\treturn peers, err\n}\n\n// GetPeersList - gets the peers of a given network\nfunc GetPeersList(networkName string, excludeRelayed bool, relayedNodeAddr string) ([]models.Node, error) {\n\tvar peers []models.Node\n\tvar err error\n\tif relayedNodeAddr == \"\" {\n\t\tpeers, err = GetNodePeers(networkName, excludeRelayed)\n\t} else {\n\t\tvar relayNode models.Node\n\t\trelayNode, err = GetNodeRelay(networkName, relayedNodeAddr)\n\t\tif relayNode.Address != \"\" {\n\t\t\tvar peerNode = setPeerInfo(&relayNode)\n\t\t\tnetwork, err := GetNetwork(networkName)\n\t\t\tif err == nil {\n\t\t\t\tpeerNode.AllowedIPs = append(peerNode.AllowedIPs, network.AddressRange)\n\t\t\t\tvar _, egressNetworkNodes, err = getNetworkEgressAndNodes(networkName)\n\t\t\t\tif err == nil {\n\t\t\t\t\tfor _, egress := range egressNetworkNodes {\n\t\t\t\t\t\tif egress.Address != relayedNodeAddr {\n\t\t\t\t\t\t\tpeerNode.AllowedIPs = append(peerNode.AllowedIPs, egress.EgressGatewayRanges...)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tpeerNode.AllowedIPs = append(peerNode.AllowedIPs, peerNode.RelayAddrs...)\n\t\t\t}\n\t\t\tnodepeers, err := GetNodePeers(networkName, false)\n\t\t\tif err == nil && peerNode.UDPHolePunch == \"yes\" {\n\t\t\t\tfor _, nodepeer := range nodepeers {\n\t\t\t\t\tif nodepeer.Address == peerNode.Address {\n\t\t\t\t\t\t// peerNode.Endpoint = nodepeer.Endpoint\n\t\t\t\t\t\tpeerNode.ListenPort = nodepeer.ListenPort\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tpeers = append(peers, peerNode)\n\t\t}\n\t}\n\treturn peers, err\n}\n\n// RandomString - returns a random string in a charset\nfunc RandomString(length int) string {\n\tconst charset = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\"\n\n\tvar seededRand *rand.Rand = rand.New(rand.NewSource(time.Now().UnixNano()))\n\n\tb := make([]byte, length)\n\tfor i := range b {\n\t\tb[i] = charset[seededRand.Intn(len(charset))]\n\t}\n\treturn string(b)\n}\n\n// == Private Methods ==\n\nfunc getNetworkEgressAndNodes(networkName string) ([]models.Node, []models.Node, error) {\n\tvar networkNodes, egressNetworkNodes []models.Node\n\tcollection, err := database.FetchRecords(database.NODES_TABLE_NAME)\n\tif err != nil {\n\t\tif database.IsEmptyRecord(err) {\n\t\t\treturn networkNodes, egressNetworkNodes, nil\n\t\t}\n\t\tlogger.Log(2, err.Error())\n\t\treturn nil, nil, err\n\t}\n\n\tfor _, value := range collection {\n\t\tvar node = models.Node{}\n\t\terr := json.Unmarshal([]byte(value), &node)\n\t\tif err != nil {\n\t\t\tlogger.Log(2, err.Error())\n\t\t\tcontinue\n\t\t}\n\t\tif node.Network == networkName {\n\t\t\tnetworkNodes = append(networkNodes, node)\n\t\t\tif node.IsEgressGateway == \"yes\" {\n\t\t\t\tegressNetworkNodes = append(egressNetworkNodes, node)\n\t\t\t}\n\t\t}\n\t}\n\treturn networkNodes, egressNetworkNodes, nil\n}\n\nfunc setPeerInfo(node *models.Node) models.Node {\n\tvar peer models.Node\n\tpeer.RelayAddrs = node.RelayAddrs\n\tpeer.IsRelay = node.IsRelay\n\tpeer.IsServer = node.IsServer\n\tpeer.IsRelayed = node.IsRelayed\n\tpeer.PublicKey = node.PublicKey\n\tpeer.Endpoint = node.Endpoint\n\tpeer.Name = node.Name\n\tpeer.LocalAddress = node.LocalAddress\n\tpeer.ListenPort = node.ListenPort\n\tpeer.AllowedIPs = node.AllowedIPs\n\tpeer.UDPHolePunch = node.UDPHolePunch\n\tpeer.Address = node.Address\n\tpeer.Address6 = node.Address6\n\tpeer.EgressGatewayRanges = node.EgressGatewayRanges\n\tpeer.IsEgressGateway = node.IsEgressGateway\n\tpeer.IngressGatewayRange = node.IngressGatewayRange\n\tpeer.IsIngressGateway = node.IsIngressGateway\n\tpeer.IsPending = node.IsPending\n\treturn peer\n}\n\nfunc setIPForwardingLinux() error {\n\tout, err := ncutils.RunCmd(\"sysctl net.ipv4.ip_forward\", true)\n\tif err != nil {\n\t\tlogger.Log(0, \"WARNING: Error encountered setting ip forwarding. This can break functionality.\")\n\t\treturn err\n\t} else {\n\t\ts := strings.Fields(string(out))\n\t\tif s[2] != \"1\" {\n\t\t\t_, err = ncutils.RunCmd(\"sysctl -w net.ipv4.ip_forward=1\", true)\n\t\t\tif err != nil {\n\t\t\t\tlogger.Log(0, \"WARNING: Error encountered setting ip forwarding. You may want to investigate this.\")\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}\n\n// StringSliceContains - sees if a string slice contains a string element\nfunc StringSliceContains(slice []string, item string) bool {\n\tfor _, s := range slice {\n\t\tif s == item {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n// == private ==\n\n// sets the network server peers of a given node\nfunc setNetworkServerPeers(serverNode *models.Node) {\n\tif currentPeersList, err := getSystemPeers(serverNode); err == nil {\n\t\tif database.SetPeers(currentPeersList, serverNode.Network) {\n\t\t\tlogger.Log(1, \"set new peers on network\", serverNode.Network)\n\t\t}\n\t} else {\n\t\tlogger.Log(1, \"could not set peers on network\", serverNode.Network, \":\", err.Error())\n\t}\n}\n\n// ShouldPublishPeerPorts - Gets ports from iface, sets, and returns true if they are different\nfunc ShouldPublishPeerPorts(serverNode *models.Node) bool {\n\tif currentPeersList, err := getSystemPeers(serverNode); err == nil {\n\t\tif database.SetPeers(currentPeersList, serverNode.Network) {\n\t\t\tlogger.Log(1, \"set new peers on network\", serverNode.Network)\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n"], "filenames": ["logic/jwts.go", "logic/util.go"], "buggy_code_start_loc": [20, 4], "buggy_code_end_loc": [21, 111], "fixing_code_start_loc": [20, 5], "fixing_code_end_loc": [25, 104], "type": "CWE-321", "message": "Use of Hard-coded Cryptographic Key in Go github.com/gravitl/netmaker prior to 0.8.5,0.9.4,0.10.0,0.10.1.", "other": {"cve": {"id": "CVE-2022-0664", "sourceIdentifier": "security@huntr.dev", "published": "2022-02-18T14:15:07.987", "lastModified": "2022-02-26T03:19:53.983", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Use of Hard-coded Cryptographic Key in Go github.com/gravitl/netmaker prior to 0.8.5,0.9.4,0.10.0,0.10.1."}, {"lang": "es", "value": "Un Uso de una Clave Criptogr\u00e1fica Embebida en Go github.com/gravitl/netmaker versiones anteriores a 0.8.5,0.9.4,0.10.0,0.10.1"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:C/I:C/A:C", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "COMPLETE", "integrityImpact": "COMPLETE", "availabilityImpact": "COMPLETE", "baseScore": 10.0}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 10.0, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-321"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:gravitl:netmaker:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.8.5", "matchCriteriaId": "4F28A807-C8DF-4096-BB3D-0BF59F58349B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:gravitl:netmaker:*:*:*:*:*:*:*:*", "versionStartIncluding": "0.9.0", "versionEndExcluding": "0.9.4", "matchCriteriaId": "5657BA6A-3F11-4BB7-B187-EFBAF3ECEBD0"}]}]}], "references": [{"url": "https://github.com/gravitl/netmaker/commit/9bee12642986cb9534e268447b70e6f0f03c59cf", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/29898a42-fd4f-4b5b-a8e3-ab573cb87eac", "source": "security@huntr.dev", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/gravitl/netmaker/commit/9bee12642986cb9534e268447b70e6f0f03c59cf"}}