{"buggy_code": ["import { createQueryBuilder, getConnection, In } from \"typeorm\";\nimport { Region, Status } from \"../../../../../constants/Project\";\nimport {\n    CloudStorageConfigsDAO,\n    CloudStorageUserFilesDAO,\n    CloudStorageFilesDAO,\n} from \"../../../../../dao\";\nimport { CloudStorageFilesModel } from \"../../../../../model/cloudStorage/CloudStorageFiles\";\nimport { CloudStorageUserFilesModel } from \"../../../../../model/cloudStorage/CloudStorageUserFiles\";\nimport { FastifySchema, Response, ResponseError } from \"../../../../../types/Server\";\nimport { getFilePath, ossClient } from \"../Utils\";\nimport { AbstractController } from \"../../../../../abstract/controller\";\nimport { Controller } from \"../../../../../decorator/Controller\";\nimport { ControllerError } from \"../../../../../error/ControllerError\";\nimport { ErrorCode } from \"../../../../../ErrorCode\";\n\n@Controller<RequestType, ResponseType>({\n    method: \"post\",\n    path: \"cloud-storage/alibaba-cloud/remove\",\n    auth: true,\n})\nexport class AlibabaCloudRemoveFile extends AbstractController<RequestType, ResponseType> {\n    public static readonly schema: FastifySchema<RequestType> = {\n        body: {\n            type: \"object\",\n            required: [\"fileUUIDs\"],\n            properties: {\n                fileUUIDs: {\n                    type: \"array\",\n                    items: {\n                        type: \"string\",\n                        format: \"uuid-v4\",\n                    },\n                    minItems: 1,\n                },\n            },\n        },\n    };\n\n    public async execute(): Promise<Response<ResponseType>> {\n        const { fileUUIDs } = this.body;\n        const userUUID = this.userUUID;\n\n        const fileInfo: FileInfoType[] = await createQueryBuilder(CloudStorageUserFilesModel, \"fc\")\n            .addSelect(\"f.file_uuid\", \"file_uuid\")\n            .addSelect(\"f.file_name\", \"file_name\")\n            .addSelect(\"f.file_size\", \"file_size\")\n            .addSelect(\"f.region\", \"region\")\n            .innerJoin(CloudStorageFilesModel, \"f\", \"fc.file_uuid = f.file_uuid\")\n            .where(\n                `f.file_uuid IN (:...fileUUIDs)\n                AND fc.user_uuid = :userUUID\n                AND fc.is_delete = false\n                AND f.is_delete = false`,\n                {\n                    fileUUIDs,\n                    userUUID,\n                },\n            )\n            .getRawMany();\n\n        if (fileInfo.length === 0) {\n            throw new ControllerError(ErrorCode.FileNotFound);\n        }\n\n        const cloudStorageConfigsInfo = await CloudStorageConfigsDAO().findOne([\"total_usage\"], {\n            user_uuid: userUUID,\n        });\n\n        const totalUsage = Number(cloudStorageConfigsInfo?.total_usage) || 0;\n\n        const { fileList, remainingTotalUsage } = ((): {\n            fileList: FileListType;\n            remainingTotalUsage: number;\n        } => {\n            const fileList: FileListType = {};\n            let remainingTotalUsage = totalUsage;\n\n            fileInfo.forEach(({ file_uuid, file_name, file_size, region }) => {\n                if (typeof fileList[region] === \"undefined\") {\n                    fileList[region] = [];\n                }\n\n                (fileList as Required<FileListType>)[region].push(\n                    getFilePath(file_name, file_uuid),\n                );\n                remainingTotalUsage -= file_size;\n            });\n\n            return {\n                fileList,\n                remainingTotalUsage: remainingTotalUsage < 0 ? 0 : remainingTotalUsage,\n            };\n        })();\n\n        await getConnection().transaction(async t => {\n            const commands: Promise<unknown>[] = [];\n\n            commands.push(\n                CloudStorageUserFilesDAO(t).remove({\n                    file_uuid: In(fileUUIDs),\n                    user_uuid: userUUID,\n                }),\n            );\n\n            commands.push(\n                CloudStorageFilesDAO(t).remove({\n                    file_uuid: In(fileUUIDs),\n                }),\n            );\n\n            commands.push(\n                CloudStorageConfigsDAO(t).update(\n                    {\n                        total_usage: String(remainingTotalUsage),\n                    },\n                    {\n                        user_uuid: userUUID,\n                    },\n                ),\n            );\n\n            await Promise.all(commands);\n\n            const deleteMultiByRegion = Object.keys(fileList).map(region => {\n                return ossClient[region as Region].deleteMulti(fileList[region as Region]!);\n            });\n\n            await Promise.all(deleteMultiByRegion);\n        });\n\n        return {\n            status: Status.Success,\n            data: {},\n        };\n    }\n\n    public errorHandler(error: Error): ResponseError {\n        return this.autoHandlerError(error);\n    }\n}\n\ninterface RequestType {\n    body: {\n        fileUUIDs: string[];\n    };\n}\n\ninterface ResponseType {}\n\ntype FileListType = {\n    [region in Region]?: string[];\n};\n\ninterface FileInfoType {\n    file_uuid: string;\n    file_name: string;\n    file_size: number;\n    region: Region;\n}\n"], "fixing_code": ["import { createQueryBuilder, getConnection, In } from \"typeorm\";\nimport { Region, Status } from \"../../../../../constants/Project\";\nimport {\n    CloudStorageConfigsDAO,\n    CloudStorageFilesDAO,\n    CloudStorageUserFilesDAO,\n} from \"../../../../../dao\";\nimport { CloudStorageFilesModel } from \"../../../../../model/cloudStorage/CloudStorageFiles\";\nimport { CloudStorageUserFilesModel } from \"../../../../../model/cloudStorage/CloudStorageUserFiles\";\nimport { FastifySchema, Response, ResponseError } from \"../../../../../types/Server\";\nimport { getFilePath, ossClient } from \"../Utils\";\nimport { AbstractController } from \"../../../../../abstract/controller\";\nimport { Controller } from \"../../../../../decorator/Controller\";\nimport { ControllerError } from \"../../../../../error/ControllerError\";\nimport { ErrorCode } from \"../../../../../ErrorCode\";\n\n@Controller<RequestType, ResponseType>({\n    method: \"post\",\n    path: \"cloud-storage/alibaba-cloud/remove\",\n    auth: true,\n})\nexport class AlibabaCloudRemoveFile extends AbstractController<RequestType, ResponseType> {\n    public static readonly schema: FastifySchema<RequestType> = {\n        body: {\n            type: \"object\",\n            required: [\"fileUUIDs\"],\n            properties: {\n                fileUUIDs: {\n                    type: \"array\",\n                    items: {\n                        type: \"string\",\n                        format: \"uuid-v4\",\n                    },\n                    minItems: 1,\n                },\n            },\n        },\n    };\n\n    public async execute(): Promise<Response<ResponseType>> {\n        const { fileUUIDs } = this.body;\n        const userUUID = this.userUUID;\n\n        await this.assertFilesOwnerIsCurrentUser();\n\n        const fileInfo: FileInfoType[] = await createQueryBuilder(CloudStorageUserFilesModel, \"fc\")\n            .addSelect(\"f.file_uuid\", \"file_uuid\")\n            .addSelect(\"f.file_name\", \"file_name\")\n            .addSelect(\"f.file_size\", \"file_size\")\n            .addSelect(\"f.region\", \"region\")\n            .innerJoin(CloudStorageFilesModel, \"f\", \"fc.file_uuid = f.file_uuid\")\n            .where(\n                `f.file_uuid IN (:...fileUUIDs)\n                AND fc.user_uuid = :userUUID\n                AND fc.is_delete = false\n                AND f.is_delete = false`,\n                {\n                    fileUUIDs,\n                    userUUID,\n                },\n            )\n            .getRawMany();\n\n        if (fileInfo.length === 0) {\n            return {\n                status: Status.Success,\n                data: {},\n            };\n        }\n\n        const cloudStorageConfigsInfo = await CloudStorageConfigsDAO().findOne([\"total_usage\"], {\n            user_uuid: userUUID,\n        });\n\n        const totalUsage = Number(cloudStorageConfigsInfo?.total_usage) || 0;\n\n        const { fileList, remainingTotalUsage } = ((): {\n            fileList: FileListType;\n            remainingTotalUsage: number;\n        } => {\n            const fileList: FileListType = {};\n            let remainingTotalUsage = totalUsage;\n\n            fileInfo.forEach(({ file_uuid, file_name, file_size, region }) => {\n                if (typeof fileList[region] === \"undefined\") {\n                    fileList[region] = [];\n                }\n\n                (fileList as Required<FileListType>)[region].push(\n                    getFilePath(file_name, file_uuid),\n                );\n                remainingTotalUsage -= file_size;\n            });\n\n            return {\n                fileList,\n                remainingTotalUsage: remainingTotalUsage < 0 ? 0 : remainingTotalUsage,\n            };\n        })();\n\n        await getConnection().transaction(async t => {\n            const commands: Promise<unknown>[] = [];\n\n            commands.push(\n                CloudStorageUserFilesDAO(t).remove({\n                    file_uuid: In(fileUUIDs),\n                    user_uuid: userUUID,\n                }),\n            );\n\n            commands.push(\n                CloudStorageFilesDAO(t).remove({\n                    file_uuid: In(fileUUIDs),\n                }),\n            );\n\n            commands.push(\n                CloudStorageConfigsDAO(t).update(\n                    {\n                        total_usage: String(remainingTotalUsage),\n                    },\n                    {\n                        user_uuid: userUUID,\n                    },\n                ),\n            );\n\n            await Promise.all(commands);\n\n            const deleteMultiByRegion = Object.keys(fileList).map(region => {\n                return ossClient[region as Region].deleteMulti(fileList[region as Region]!);\n            });\n\n            await Promise.all(deleteMultiByRegion);\n        });\n\n        return {\n            status: Status.Success,\n            data: {},\n        };\n    }\n\n    public errorHandler(error: Error): ResponseError {\n        return this.autoHandlerError(error);\n    }\n\n    private async assertFilesOwnerIsCurrentUser(): Promise<void> {\n        const filesOwner = await CloudStorageUserFilesDAO().find([\"user_uuid\"], {\n            file_uuid: In(this.body.fileUUIDs),\n        });\n\n        for (const { user_uuid } of filesOwner) {\n            if (user_uuid !== this.userUUID) {\n                throw new ControllerError(ErrorCode.NotPermission);\n            }\n        }\n    }\n}\n\ninterface RequestType {\n    body: {\n        fileUUIDs: string[];\n    };\n}\n\ninterface ResponseType {}\n\ntype FileListType = {\n    [region in Region]?: string[];\n};\n\ninterface FileInfoType {\n    file_uuid: string;\n    file_name: string;\n    file_size: number;\n    region: Region;\n}\n"], "filenames": ["src/v1/controller/cloudStorage/alibabaCloud/remove/index.ts"], "buggy_code_start_loc": [4], "buggy_code_end_loc": [140], "fixing_code_start_loc": [5], "fixing_code_end_loc": [158], "type": "NVD-CWE-Other", "message": "The remove API in v1/controller/cloudStorage/alibabaCloud/remove/index.ts in netless Agora Flat Server before 2021-07-30 mishandles file ownership.", "other": {"cve": {"id": "CVE-2021-38621", "sourceIdentifier": "cve@mitre.org", "published": "2021-08-13T15:15:07.160", "lastModified": "2022-07-12T17:42:04.277", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The remove API in v1/controller/cloudStorage/alibabaCloud/remove/index.ts in netless Agora Flat Server before 2021-07-30 mishandles file ownership."}, {"lang": "es", "value": "La API de eliminaci\u00f3n en el componente v1/controller/cloudStorage/alibabaCloud/remove/index.ts en el Agora Flat Server sin red antes del 30-07-2021, maneja inapropiadamente la propiedad de los archivos."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 9.1, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.2}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 6.4}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-Other"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:netless:flat_server:*:*:*:*:*:node.js:*:*", "versionEndExcluding": "2021-07-30", "matchCriteriaId": "E2FC449C-D523-47D7-9CEE-4440943E291D"}]}]}], "references": [{"url": "https://github.com/netless-io/flat-server/commit/425aa970f6366874c61aa1466527fced5501e476", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/netless-io/flat-server/commit/425aa970f6366874c61aa1466527fced5501e476"}}