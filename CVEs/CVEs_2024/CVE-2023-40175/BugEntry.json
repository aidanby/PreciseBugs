{"buggy_code": ["# frozen_string_literal: true\n\nclass IO\n  # We need to use this for a jruby work around on both 1.8 and 1.9.\n  # So this either creates the constant (on 1.8), or harmlessly\n  # reopens it (on 1.9).\n  module WaitReadable\n  end\nend\n\nrequire_relative 'detect'\nrequire_relative 'io_buffer'\nrequire 'tempfile'\nrequire 'forwardable'\n\nif Puma::IS_JRUBY\n  # We have to work around some OpenSSL buffer/io-readiness bugs\n  # so we pull it in regardless of if the user is binding\n  # to an SSL socket\n  require 'openssl'\nend\n\nmodule Puma\n\n  class ConnectionError < RuntimeError; end\n\n  class HttpParserError501 < IOError; end\n\n  #\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014 DO NOT USE \u2014 this class is for internal use only \u2014\u2014\u2014\n\n\n  # An instance of this class represents a unique request from a client.\n  # For example, this could be a web request from a browser or from CURL.\n  #\n  # An instance of `Puma::Client` can be used as if it were an IO object\n  # by the reactor. The reactor is expected to call `#to_io`\n  # on any non-IO objects it polls. For example, nio4r internally calls\n  # `IO::try_convert` (which may call `#to_io`) when a new socket is\n  # registered.\n  #\n  # Instances of this class are responsible for knowing if\n  # the header and body are fully buffered via the `try_to_finish` method.\n  # They can be used to \"time out\" a response via the `timeout_at` reader.\n  #\n  class Client # :nodoc:\n\n    # this tests all values but the last, which must be chunked\n    ALLOWED_TRANSFER_ENCODING = %w[compress deflate gzip].freeze\n\n    # chunked body validation\n    CHUNK_SIZE_INVALID = /[^\\h]/.freeze\n    CHUNK_VALID_ENDING = \"\\r\\n\".freeze\n\n    # Content-Length header value validation\n    CONTENT_LENGTH_VALUE_INVALID = /[^\\d]/.freeze\n\n    TE_ERR_MSG = 'Invalid Transfer-Encoding'\n\n    # The object used for a request with no body. All requests with\n    # no body share this one object since it has no state.\n    EmptyBody = NullIO.new\n\n    include Puma::Const\n    extend Forwardable\n\n    def initialize(io, env=nil)\n      @io = io\n      @to_io = io.to_io\n      @io_buffer = IOBuffer.new\n      @proto_env = env\n      @env = env&.dup\n\n      @parser = HttpParser.new\n      @parsed_bytes = 0\n      @read_header = true\n      @read_proxy = false\n      @ready = false\n\n      @body = nil\n      @body_read_start = nil\n      @buffer = nil\n      @tempfile = nil\n\n      @timeout_at = nil\n\n      @requests_served = 0\n      @hijacked = false\n\n      @http_content_length_limit = nil\n      @http_content_length_limit_exceeded = false\n\n      @peerip = nil\n      @peer_family = nil\n      @listener = nil\n      @remote_addr_header = nil\n      @expect_proxy_proto = false\n\n      @body_remain = 0\n\n      @in_last_chunk = false\n\n      # need unfrozen ASCII-8BIT, +'' is UTF-8\n      @read_buffer = String.new # rubocop: disable Performance/UnfreezeString\n    end\n\n    attr_reader :env, :to_io, :body, :io, :timeout_at, :ready, :hijacked,\n                :tempfile, :io_buffer, :http_content_length_limit_exceeded\n\n    attr_writer :peerip, :http_content_length_limit\n\n    attr_accessor :remote_addr_header, :listener\n\n    def_delegators :@io, :closed?\n\n    # Test to see if io meets a bare minimum of functioning, @to_io needs to be\n    # used for MiniSSL::Socket\n    def io_ok?\n      @to_io.is_a?(::BasicSocket) && !closed?\n    end\n\n    # @!attribute [r] inspect\n    def inspect\n      \"#<Puma::Client:0x#{object_id.to_s(16)} @ready=#{@ready.inspect}>\"\n    end\n\n    # For the hijack protocol (allows us to just put the Client object\n    # into the env)\n    def call\n      @hijacked = true\n      env[HIJACK_IO] ||= @io\n    end\n\n    # @!attribute [r] in_data_phase\n    def in_data_phase\n      !(@read_header || @read_proxy)\n    end\n\n    def set_timeout(val)\n      @timeout_at = Process.clock_gettime(Process::CLOCK_MONOTONIC) + val\n    end\n\n    # Number of seconds until the timeout elapses.\n    def timeout\n      [@timeout_at - Process.clock_gettime(Process::CLOCK_MONOTONIC), 0].max\n    end\n\n    def reset(fast_check=true)\n      @parser.reset\n      @io_buffer.reset\n      @read_header = true\n      @read_proxy = !!@expect_proxy_proto\n      @env = @proto_env.dup\n      @body = nil\n      @tempfile = nil\n      @parsed_bytes = 0\n      @ready = false\n      @body_remain = 0\n      @peerip = nil if @remote_addr_header\n      @in_last_chunk = false\n      @http_content_length_limit_exceeded = false\n\n      if @buffer\n        return false unless try_to_parse_proxy_protocol\n\n        @parsed_bytes = @parser.execute(@env, @buffer, @parsed_bytes)\n\n        if @parser.finished?\n          return setup_body\n        elsif @parsed_bytes >= MAX_HEADER\n          raise HttpParserError,\n            \"HEADER is longer than allowed, aborting client early.\"\n        end\n\n        return false\n      else\n        begin\n          if fast_check && @to_io.wait_readable(FAST_TRACK_KA_TIMEOUT)\n            return try_to_finish\n          end\n        rescue IOError\n          # swallow it\n        end\n\n      end\n    end\n\n    def close\n      begin\n        @io.close\n      rescue IOError, Errno::EBADF\n        Puma::Util.purge_interrupt_queue\n      end\n    end\n\n    # If necessary, read the PROXY protocol from the buffer. Returns\n    # false if more data is needed.\n    def try_to_parse_proxy_protocol\n      if @read_proxy\n        if @expect_proxy_proto == :v1\n          if @buffer.include? \"\\r\\n\"\n            if md = PROXY_PROTOCOL_V1_REGEX.match(@buffer)\n              if md[1]\n                @peerip = md[1].split(\" \")[0]\n              end\n              @buffer = md.post_match\n            end\n            # if the buffer has a \\r\\n but doesn't have a PROXY protocol\n            # request, this is just HTTP from a non-PROXY client; move on\n            @read_proxy = false\n            return @buffer.size > 0\n          else\n            return false\n          end\n        end\n      end\n      true\n    end\n\n    def try_to_finish\n      if env[CONTENT_LENGTH] && above_http_content_limit(env[CONTENT_LENGTH].to_i)\n        @http_content_length_limit_exceeded = true\n      end\n\n      if @http_content_length_limit_exceeded\n        @buffer = nil\n        @body = EmptyBody\n        set_ready\n        return true\n      end\n\n      return read_body if in_data_phase\n\n      begin\n        data = @io.read_nonblock(CHUNK_SIZE)\n      rescue IO::WaitReadable\n        return false\n      rescue EOFError\n        # Swallow error, don't log\n      rescue SystemCallError, IOError\n        raise ConnectionError, \"Connection error detected during read\"\n      end\n\n      # No data means a closed socket\n      unless data\n        @buffer = nil\n        set_ready\n        raise EOFError\n      end\n\n      if @buffer\n        @buffer << data\n      else\n        @buffer = data\n      end\n\n      return false unless try_to_parse_proxy_protocol\n\n      @parsed_bytes = @parser.execute(@env, @buffer, @parsed_bytes)\n\n      if @parser.finished? && above_http_content_limit(@parser.body.bytesize)\n        @http_content_length_limit_exceeded = true\n      end\n\n      if @parser.finished?\n        return setup_body\n      elsif @parsed_bytes >= MAX_HEADER\n        raise HttpParserError,\n          \"HEADER is longer than allowed, aborting client early.\"\n      end\n\n      false\n    end\n\n    def eagerly_finish\n      return true if @ready\n      return false unless @to_io.wait_readable(0)\n      try_to_finish\n    end\n\n    def finish(timeout)\n      return if @ready\n      @to_io.wait_readable(timeout) || timeout! until try_to_finish\n    end\n\n    def timeout!\n      write_error(408) if in_data_phase\n      raise ConnectionError\n    end\n\n    def write_error(status_code)\n      begin\n        @io << ERROR_RESPONSE[status_code]\n      rescue StandardError\n      end\n    end\n\n    def peerip\n      return @peerip if @peerip\n\n      if @remote_addr_header\n        hdr = (@env[@remote_addr_header] || @io.peeraddr.last).split(/[\\s,]/).first\n        @peerip = hdr\n        return hdr\n      end\n\n      @peerip ||= @io.peeraddr.last\n    end\n\n    def peer_family\n      return @peer_family if @peer_family\n\n      @peer_family ||= begin\n                         @io.local_address.afamily\n                       rescue\n                         Socket::AF_INET\n                       end\n    end\n\n    # Returns true if the persistent connection can be closed immediately\n    # without waiting for the configured idle/shutdown timeout.\n    # @version 5.0.0\n    #\n    def can_close?\n      # Allow connection to close if we're not in the middle of parsing a request.\n      @parsed_bytes == 0\n    end\n\n    def expect_proxy_proto=(val)\n      if val\n        if @read_header\n          @read_proxy = true\n        end\n      else\n        @read_proxy = false\n      end\n      @expect_proxy_proto = val\n    end\n\n    private\n\n    def setup_body\n      @body_read_start = Process.clock_gettime(Process::CLOCK_MONOTONIC, :float_millisecond)\n\n      if @env[HTTP_EXPECT] == CONTINUE\n        # TODO allow a hook here to check the headers before\n        # going forward\n        @io << HTTP_11_100\n        @io.flush\n      end\n\n      @read_header = false\n\n      body = @parser.body\n\n      te = @env[TRANSFER_ENCODING2]\n      if te\n        te_lwr = te.downcase\n        if te.include? ','\n          te_ary = te_lwr.split ','\n          te_count = te_ary.count CHUNKED\n          te_valid = te_ary[0..-2].all? { |e| ALLOWED_TRANSFER_ENCODING.include? e }\n          if te_ary.last == CHUNKED && te_count == 1 && te_valid\n            @env.delete TRANSFER_ENCODING2\n            return setup_chunked_body body\n          elsif te_count >= 1\n            raise HttpParserError   , \"#{TE_ERR_MSG}, multiple chunked: '#{te}'\"\n          elsif !te_valid\n            raise HttpParserError501, \"#{TE_ERR_MSG}, unknown value: '#{te}'\"\n          end\n        elsif te_lwr == CHUNKED\n          @env.delete TRANSFER_ENCODING2\n          return setup_chunked_body body\n        elsif ALLOWED_TRANSFER_ENCODING.include? te_lwr\n          raise HttpParserError     , \"#{TE_ERR_MSG}, single value must be chunked: '#{te}'\"\n        else\n          raise HttpParserError501  , \"#{TE_ERR_MSG}, unknown value: '#{te}'\"\n        end\n      end\n\n      @chunked_body = false\n\n      cl = @env[CONTENT_LENGTH]\n\n      if cl\n        # cannot contain characters that are not \\d\n        if CONTENT_LENGTH_VALUE_INVALID.match? cl\n          raise HttpParserError, \"Invalid Content-Length: #{cl.inspect}\"\n        end\n      else\n        @buffer = body.empty? ? nil : body\n        @body = EmptyBody\n        set_ready\n        return true\n      end\n\n      remain = cl.to_i - body.bytesize\n\n      if remain <= 0\n        @body = StringIO.new(body)\n        @buffer = nil\n        set_ready\n        return true\n      end\n\n      if remain > MAX_BODY\n        @body = Tempfile.new(Const::PUMA_TMP_BASE)\n        @body.unlink\n        @body.binmode\n        @tempfile = @body\n      else\n        # The body[0,0] trick is to get an empty string in the same\n        # encoding as body.\n        @body = StringIO.new body[0,0]\n      end\n\n      @body.write body\n\n      @body_remain = remain\n\n      false\n    end\n\n    def read_body\n      if @chunked_body\n        return read_chunked_body\n      end\n\n      # Read an odd sized chunk so we can read even sized ones\n      # after this\n      remain = @body_remain\n\n      if remain > CHUNK_SIZE\n        want = CHUNK_SIZE\n      else\n        want = remain\n      end\n\n      begin\n        chunk = @io.read_nonblock(want, @read_buffer)\n      rescue IO::WaitReadable\n        return false\n      rescue SystemCallError, IOError\n        raise ConnectionError, \"Connection error detected during read\"\n      end\n\n      # No chunk means a closed socket\n      unless chunk\n        @body.close\n        @buffer = nil\n        set_ready\n        raise EOFError\n      end\n\n      remain -= @body.write(chunk)\n\n      if remain <= 0\n        @body.rewind\n        @buffer = nil\n        set_ready\n        return true\n      end\n\n      @body_remain = remain\n\n      false\n    end\n\n    def read_chunked_body\n      while true\n        begin\n          chunk = @io.read_nonblock(4096, @read_buffer)\n        rescue IO::WaitReadable\n          return false\n        rescue SystemCallError, IOError\n          raise ConnectionError, \"Connection error detected during read\"\n        end\n\n        # No chunk means a closed socket\n        unless chunk\n          @body.close\n          @buffer = nil\n          set_ready\n          raise EOFError\n        end\n\n        if decode_chunk(chunk)\n          @env[CONTENT_LENGTH] = @chunked_content_length.to_s\n          return true\n        end\n      end\n    end\n\n    def setup_chunked_body(body)\n      @chunked_body = true\n      @partial_part_left = 0\n      @prev_chunk = \"\"\n\n      @body = Tempfile.new(Const::PUMA_TMP_BASE)\n      @body.unlink\n      @body.binmode\n      @tempfile = @body\n      @chunked_content_length = 0\n\n      if decode_chunk(body)\n        @env[CONTENT_LENGTH] = @chunked_content_length.to_s\n        return true\n      end\n    end\n\n    # @version 5.0.0\n    def write_chunk(str)\n      @chunked_content_length += @body.write(str)\n    end\n\n    def decode_chunk(chunk)\n      if @partial_part_left > 0\n        if @partial_part_left <= chunk.size\n          if @partial_part_left > 2\n            write_chunk(chunk[0..(@partial_part_left-3)]) # skip the \\r\\n\n          end\n          chunk = chunk[@partial_part_left..-1]\n          @partial_part_left = 0\n        else\n          if @partial_part_left > 2\n            if @partial_part_left == chunk.size + 1\n              # Don't include the last \\r\n              write_chunk(chunk[0..(@partial_part_left-3)])\n            else\n              # don't include the last \\r\\n\n              write_chunk(chunk)\n            end\n          end\n          @partial_part_left -= chunk.size\n          return false\n        end\n      end\n\n      if @prev_chunk.empty?\n        io = StringIO.new(chunk)\n      else\n        io = StringIO.new(@prev_chunk+chunk)\n        @prev_chunk = \"\"\n      end\n\n      while !io.eof?\n        line = io.gets\n        if line.end_with?(\"\\r\\n\")\n          # Puma doesn't process chunk extensions, but should parse if they're\n          # present, which is the reason for the semicolon regex\n          chunk_hex = line.strip[/\\A[^;]+/]\n          if CHUNK_SIZE_INVALID.match? chunk_hex\n            raise HttpParserError, \"Invalid chunk size: '#{chunk_hex}'\"\n          end\n          len = chunk_hex.to_i(16)\n          if len == 0\n            @in_last_chunk = true\n            @body.rewind\n            rest = io.read\n            last_crlf_size = \"\\r\\n\".bytesize\n            if rest.bytesize < last_crlf_size\n              @buffer = nil\n              @partial_part_left = last_crlf_size - rest.bytesize\n              return false\n            else\n              @buffer = rest[last_crlf_size..-1]\n              @buffer = nil if @buffer.empty?\n              set_ready\n              return true\n            end\n          end\n\n          len += 2\n\n          part = io.read(len)\n\n          unless part\n            @partial_part_left = len\n            next\n          end\n\n          got = part.size\n\n          case\n          when got == len\n            # proper chunked segment must end with \"\\r\\n\"\n            if part.end_with? CHUNK_VALID_ENDING\n              write_chunk(part[0..-3]) # to skip the ending \\r\\n\n            else\n              raise HttpParserError, \"Chunk size mismatch\"\n            end\n          when got <= len - 2\n            write_chunk(part)\n            @partial_part_left = len - part.size\n          when got == len - 1 # edge where we get just \\r but not \\n\n            write_chunk(part[0..-2])\n            @partial_part_left = len - part.size\n          end\n        else\n          @prev_chunk = line\n          return false\n        end\n      end\n\n      if @in_last_chunk\n        set_ready\n        true\n      else\n        false\n      end\n    end\n\n    def set_ready\n      if @body_read_start\n        @env['puma.request_body_wait'] = Process.clock_gettime(Process::CLOCK_MONOTONIC, :float_millisecond) - @body_read_start\n      end\n      @requests_served += 1\n      @ready = true\n    end\n\n    def above_http_content_limit(value)\n      @http_content_length_limit&.< value\n    end\n  end\nend\n", "require_relative \"helper\"\nrequire \"puma/events\"\nrequire \"puma/server\"\nrequire \"net/http\"\nrequire \"nio\"\nrequire \"ipaddr\"\n\nclass WithoutBacktraceError < StandardError\n  def backtrace; nil; end\n  def message; \"no backtrace error\"; end\nend\n\nclass TestPumaServer < Minitest::Test\n  parallelize_me!\n\n  STATUS_CODES = ::Puma::HTTP_STATUS_CODES\n\n  def setup\n    @host = \"127.0.0.1\"\n\n    @ios = []\n\n    @app = ->(env) { [200, {}, [env['rack.url_scheme']]] }\n\n    @log_writer = Puma::LogWriter.strings\n    @events = Puma::Events.new\n    @server = Puma::Server.new @app, @events, {log_writer: @log_writer}\n  end\n\n  def teardown\n    @server.stop(true)\n    # Errno::EBADF raised on macOS\n    @ios.each do |io|\n      begin\n        io.close if io.respond_to?(:close) && !io.closed?\n        File.unlink io.path if io.is_a? File\n      rescue Errno::EBADF\n      ensure\n        io = nil\n      end\n    end\n  end\n\n  def server_run(**options, &block)\n    options[:log_writer]  ||= @log_writer\n    options[:min_threads] ||= 1\n    @server = Puma::Server.new block || @app, @events, options\n    @port = (@server.add_tcp_listener @host, 0).addr[1]\n    @server.run\n  end\n\n  def header(sock)\n    header = []\n    while true\n      line = sock.gets\n      break if line == \"\\r\\n\"\n      header << line.strip\n    end\n\n    header\n  end\n\n  # only for shorter bodies!\n  def send_http_and_sysread(req)\n    send_http(req).sysread 2_048\n  end\n\n  def send_http_and_read(req)\n    send_http(req).read\n  end\n\n  def send_http(req)\n    new_connection << req\n  end\n\n  def send_proxy_v1_http(req, remote_ip, multisend = false)\n    addr = IPAddr.new(remote_ip)\n    family = addr.ipv4? ? \"TCP4\" : \"TCP6\"\n    target = addr.ipv4? ? \"127.0.0.1\" : \"::1\"\n    conn = new_connection\n    if multisend\n      conn << \"PROXY #{family} #{remote_ip} #{target} 10000 80\\r\\n\"\n      sleep 0.15\n      conn << req\n    else\n      conn << (\"PROXY #{family} #{remote_ip} #{target} 10000 80\\r\\n\" + req)\n    end\n  end\n\n  def new_connection\n    TCPSocket.new(@host, @port).tap {|sock| @ios << sock}\n  end\n\n  def test_normalize_host_header_missing\n    server_run do |env|\n      [200, {}, [env[\"SERVER_NAME\"], \"\\n\", env[\"SERVER_PORT\"]]]\n    end\n\n    data = send_http_and_read \"GET / HTTP/1.0\\r\\n\\r\\n\"\n    assert_equal \"localhost\\n80\", data.split(\"\\r\\n\").last\n  end\n\n  def test_normalize_host_header_hostname\n    server_run do |env|\n      [200, {}, [env[\"SERVER_NAME\"], \"\\n\", env[\"SERVER_PORT\"]]]\n    end\n\n    data = send_http_and_read \"GET / HTTP/1.0\\r\\nHost: example.com:456\\r\\n\\r\\n\"\n    assert_equal \"example.com\\n456\", data.split(\"\\r\\n\").last\n\n    data = send_http_and_read \"GET / HTTP/1.0\\r\\nHost: example.com\\r\\n\\r\\n\"\n    assert_equal \"example.com\\n80\", data.split(\"\\r\\n\").last\n  end\n\n  def test_normalize_host_header_ipv4\n    server_run do |env|\n      [200, {}, [env[\"SERVER_NAME\"], \"\\n\", env[\"SERVER_PORT\"]]]\n    end\n\n    data = send_http_and_read \"GET / HTTP/1.0\\r\\nHost: 123.123.123.123:456\\r\\n\\r\\n\"\n    assert_equal \"123.123.123.123\\n456\", data.split(\"\\r\\n\").last\n\n    data = send_http_and_read \"GET / HTTP/1.0\\r\\nHost: 123.123.123.123\\r\\n\\r\\n\"\n    assert_equal \"123.123.123.123\\n80\", data.split(\"\\r\\n\").last\n  end\n\n  def test_normalize_host_header_ipv6\n    server_run do |env|\n      [200, {}, [env[\"SERVER_NAME\"], \"\\n\", env[\"SERVER_PORT\"]]]\n    end\n\n    data = send_http_and_read \"GET / HTTP/1.0\\r\\nHost: [::ffff:127.0.0.1]:9292\\r\\n\\r\\n\"\n    assert_equal \"[::ffff:127.0.0.1]\\n9292\", data.split(\"\\r\\n\").last\n\n    data = send_http_and_read \"GET / HTTP/1.0\\r\\nHost: [::1]:9292\\r\\n\\r\\n\"\n    assert_equal \"[::1]\\n9292\", data.split(\"\\r\\n\").last\n\n    data = send_http_and_read \"GET / HTTP/1.0\\r\\nHost: [::1]\\r\\n\\r\\n\"\n    assert_equal \"[::1]\\n80\", data.split(\"\\r\\n\").last\n  end\n\n  def test_streaming_body\n    server_run do |env|\n      body = lambda do |stream|\n        stream.write(\"Hello World\")\n        stream.close\n      end\n\n      [200, {}, body]\n    end\n\n    data = send_http_and_read \"GET / HTTP/1.0\\r\\nConnection: close\\r\\n\\r\\n\"\n\n    assert_equal \"Hello World\", data.split(\"\\r\\n\\r\\n\", 2).last\n  end\n\n  def test_file_body\n    random_bytes = SecureRandom.random_bytes(4096 * 32)\n\n    tf = tempfile_create(\"test_file_body\", random_bytes)\n\n    server_run { |env| [200, {}, tf] }\n\n    data = +''\n    skt = send_http(\"GET / HTTP/1.1\\r\\nHost: [::ffff:127.0.0.1]:#{@port}\\r\\n\\r\\n\")\n    data << skt.sysread(65_536) while skt.wait_readable(0.1)\n\n    ary = data.split(\"\\r\\n\\r\\n\", 2)\n\n    assert_equal random_bytes.bytesize, ary.last.bytesize\n    assert_equal random_bytes, ary.last\n  ensure\n    tf.close\n  end\n\n  def test_file_to_path\n    random_bytes = SecureRandom.random_bytes(4096 * 32)\n\n    tf = tempfile_create(\"test_file_to_path\", random_bytes)\n    path = tf.path\n\n    obj = Object.new\n    obj.singleton_class.send(:define_method, :to_path) { path }\n    obj.singleton_class.send(:define_method, :each) { path } # dummy, method needs to exist\n\n    server_run { |env| [200, {}, obj] }\n\n    data = +''\n    skt = send_http(\"GET / HTTP/1.1\\r\\nHost: [::ffff:127.0.0.1]:#{@port}\\r\\n\\r\\n\")\n    data << skt.sysread(65_536) while skt.wait_readable(0.1)\n    ary = data.split(\"\\r\\n\\r\\n\", 2)\n\n    assert_equal random_bytes.bytesize, ary.last.bytesize\n    assert_equal random_bytes, ary.last\n  ensure\n    tf.close\n  end\n\n  def test_proper_stringio_body\n    data = nil\n\n    server_run do |env|\n      data = env['rack.input'].read\n      [200, {}, [\"ok\"]]\n    end\n\n    fifteen = \"1\" * 15\n\n    sock = send_http \"PUT / HTTP/1.0\\r\\nContent-Length: 30\\r\\n\\r\\n#{fifteen}\"\n\n    sleep 0.1 # important so that the previous data is sent as a packet\n    sock << fifteen\n\n    sock.read\n\n    assert_equal \"#{fifteen}#{fifteen}\", data\n  end\n\n  def test_puma_socket\n    body = \"HTTP/1.1 750 Upgraded to Awesome\\r\\nDone: Yep!\\r\\n\"\n    server_run do |env|\n      io = env['puma.socket']\n      io.write body\n      io.close\n      [-1, {}, []]\n    end\n\n    data = send_http_and_read \"PUT / HTTP/1.0\\r\\n\\r\\nHello\"\n\n    assert_equal body, data\n  end\n\n  def test_very_large_return\n    giant = \"x\" * 2056610\n\n    server_run do\n      [200, {}, [giant]]\n    end\n\n    sock = send_http \"GET / HTTP/1.0\\r\\n\\r\\n\"\n\n    while true\n      line = sock.gets\n      break if line == \"\\r\\n\"\n    end\n\n    out = sock.read\n\n    assert_equal giant.bytesize, out.bytesize\n  end\n\n  def test_respect_x_forwarded_proto\n    env = {}\n    env['HOST'] = \"example.com\"\n    env['HTTP_X_FORWARDED_PROTO'] = \"https,http\"\n\n    assert_equal \"443\", @server.default_server_port(env)\n  end\n\n  def test_respect_x_forwarded_ssl_on\n    env = {}\n    env['HOST'] = 'example.com'\n    env['HTTP_X_FORWARDED_SSL'] = 'on'\n\n    assert_equal \"443\", @server.default_server_port(env)\n  end\n\n  def test_respect_x_forwarded_scheme\n    env = {}\n    env['HOST'] = 'example.com'\n    env['HTTP_X_FORWARDED_SCHEME'] = 'https'\n\n    assert_equal '443', @server.default_server_port(env)\n  end\n\n  def test_default_server_port\n    server_run do |env|\n      [200, {}, [env['SERVER_PORT']]]\n    end\n\n    req = Net::HTTP::Get.new '/'\n    req['HOST'] = 'example.com'\n\n    res = Net::HTTP.start @host, @port do |http|\n      http.request(req)\n    end\n\n    assert_equal \"80\", res.body\n  end\n\n  def test_default_server_port_respects_x_forwarded_proto\n    server_run do |env|\n      [200, {}, [env['SERVER_PORT']]]\n    end\n\n    req = Net::HTTP::Get.new(\"/\")\n    req['HOST'] = \"example.com\"\n    req['X-FORWARDED-PROTO'] = \"https,http\"\n\n    res = Net::HTTP.start @host, @port do |http|\n      http.request(req)\n    end\n\n    assert_equal \"443\", res.body\n  end\n\n  def test_HEAD_has_no_body\n    server_run { [200, {\"Foo\" => \"Bar\"}, [\"hello\"]] }\n\n    data = send_http_and_read \"HEAD / HTTP/1.0\\r\\n\\r\\n\"\n\n    assert_equal \"HTTP/1.0 200 OK\\r\\nFoo: Bar\\r\\nContent-Length: 5\\r\\n\\r\\n\", data\n  end\n\n  def test_GET_with_empty_body_has_sane_chunking\n    server_run { [200, {}, [\"\"]] }\n\n    data = send_http_and_read \"HEAD / HTTP/1.0\\r\\n\\r\\n\"\n\n    assert_equal \"HTTP/1.0 200 OK\\r\\nContent-Length: 0\\r\\n\\r\\n\", data\n  end\n\n  def test_early_hints_works\n    server_run(early_hints: true) do |env|\n     env['rack.early_hints'].call(\"Link\" => \"</style.css>; rel=preload; as=style\\n</script.js>; rel=preload\")\n     [200, { \"X-Hello\" => \"World\" }, [\"Hello world!\"]]\n    end\n\n    data = send_http_and_read \"HEAD / HTTP/1.0\\r\\n\\r\\n\"\n\n    expected_data = <<~EOF.gsub(\"\\n\", \"\\r\\n\") + \"\\r\\n\"\n      HTTP/1.1 103 Early Hints\n      Link: </style.css>; rel=preload; as=style\n      Link: </script.js>; rel=preload\n\n      HTTP/1.0 200 OK\n      X-Hello: World\n      Content-Length: 12\n    EOF\n\n    assert_equal true, @server.early_hints\n    assert_equal expected_data, data\n  end\n\n  def test_early_hints_are_ignored_if_connection_lost\n\n    server_run(early_hints: true) do |env|\n      env['rack.early_hints'].call(\"Link\" => \"</script.js>; rel=preload\")\n      [200, { \"X-Hello\" => \"World\" }, [\"Hello world!\"]]\n    end\n\n    def @server.fast_write(*args)\n      raise Puma::ConnectionError\n    end\n\n    # This request will cause the server to try and send early hints\n    _ = send_http \"HEAD / HTTP/1.0\\r\\n\\r\\n\"\n\n    # Give the server some time to try to write (and fail)\n    sleep 0.1\n\n    # Expect no errors in stderr\n    assert @log_writer.stderr.pos.zero?, \"Server didn't swallow the connection error\"\n  end\n\n  def test_early_hints_is_off_by_default\n    server_run do |env|\n     assert_nil env['rack.early_hints']\n     [200, { \"X-Hello\" => \"World\" }, [\"Hello world!\"]]\n    end\n\n    data = send_http_and_read \"HEAD / HTTP/1.0\\r\\n\\r\\n\"\n\n    expected_data = <<~EOF.gsub(\"\\n\", \"\\r\\n\") + \"\\r\\n\"\n      HTTP/1.0 200 OK\n      X-Hello: World\n      Content-Length: 12\n    EOF\n\n    assert_nil @server.early_hints\n    assert_equal expected_data, data\n  end\n\n  def test_request_payload_too_large\n    server_run(http_content_length_limit: 10)\n\n    sock = send_http \"POST / HTTP/1.1\\r\\nHost: test.com\\r\\nContent-Type: text/plain\\r\\nContent-Length: 19\\r\\n\\r\\n\"\n    sock << \"hello world foo bar\"\n\n    data = sock.gets\n\n    # Content Too Large\n    assert_equal \"HTTP/1.1 413 #{STATUS_CODES[413]}\\r\\n\", data\n  end\n\n  def test_http_11_keep_alive_with_large_payload\n    server_run(http_content_length_limit: 10) { [204, {}, []] }\n\n    sock = send_http \"GET / HTTP/1.1\\r\\nConnection: Keep-Alive\\r\\nContent-Length: 17\\r\\n\\r\\n\"\n    sock << \"hello world foo bar\"\n    h = header sock\n\n    # Content Too Large\n    assert_equal [\"HTTP/1.1 413 #{STATUS_CODES[413]}\", \"Content-Length: 17\"], h\n\n  end\n\n  def test_GET_with_no_body_has_sane_chunking\n    server_run { [200, {}, []] }\n\n    data = send_http_and_read \"HEAD / HTTP/1.0\\r\\n\\r\\n\"\n\n    assert_equal \"HTTP/1.0 200 OK\\r\\nContent-Length: 0\\r\\n\\r\\n\", data\n  end\n\n  def test_doesnt_print_backtrace_in_production\n    server_run(environment: :production) { raise \"don't leak me bro\" }\n\n    data = send_http_and_read \"GET / HTTP/1.0\\r\\n\\r\\n\"\n\n    refute_match(/don't leak me bro/, data)\n    assert_match(/HTTP\\/1.0 500 Internal Server Error/, data)\n  end\n\n  def test_eof_on_connection_close_is_not_logged_as_an_error\n    server_run\n\n    new_connection.close # Make a connection and close without writing\n\n    @server.stop(true)\n    stderr = @log_writer.stderr.string\n    assert stderr.empty?, \"Expected stderr from server to be empty but it was #{stderr.inspect}\"\n  end\n\n  def test_force_shutdown_custom_error_message\n    handler = lambda {|err, env, status| [500, {\"Content-Type\" => \"application/json\"}, [\"{}\\n\"]]}\n    server_run(lowlevel_error_handler: handler, force_shutdown_after: 2) do\n      @server.stop\n      sleep 5\n    end\n\n    data = send_http_and_read \"GET / HTTP/1.0\\r\\n\\r\\n\"\n\n    assert_match(/HTTP\\/1.0 500 Internal Server Error/, data)\n    assert_match(/Content-Type: application\\/json/, data)\n    assert_match(/{}\\n$/, data)\n  end\n\n  class ArrayClose < Array\n    attr_reader :is_closed\n    def closed?\n      @is_closed\n    end\n\n    def close\n      @is_closed = true\n    end\n  end\n\n  # returns status as an array, which throws lowlevel error\n  def test_lowlevel_error_body_close\n    app_body = ArrayClose.new(['lowlevel_error'])\n\n    server_run(log_writer: @log_writer, :force_shutdown_after => 2) do\n      [[0,1], {}, app_body]\n    end\n\n    data = send_http_and_sysread \"GET / HTTP/1.0\\r\\n\\r\\n\"\n\n    assert_includes data, 'HTTP/1.0 500 Internal Server Error'\n    assert_includes data, \"Puma caught this error: undefined method `to_i' for\"\n    assert_includes data, \"Array\"\n    refute_includes data, 'lowlevel_error'\n    sleep 0.1 unless ::Puma::IS_MRI\n    assert app_body.closed?\n  end\n\n  def test_lowlevel_error_message\n    server_run(log_writer: @log_writer, :force_shutdown_after => 2) do\n      raise NoMethodError, \"Oh no an error\"\n    end\n\n    data = send_http_and_sysread \"GET / HTTP/1.0\\r\\n\\r\\n\"\n\n    # Internal Server Error\n    assert_includes data, \"HTTP/1.0 500 #{STATUS_CODES[500]}\"\n    assert_match(/Puma caught this error: Oh no an error.*\\(NoMethodError\\).*test\\/test_puma_server.rb/m, data)\n  end\n\n  def test_lowlevel_error_message_without_backtrace\n    server_run(log_writer: @log_writer, :force_shutdown_after => 2) do\n      raise WithoutBacktraceError.new\n    end\n\n    data = send_http_and_sysread \"GET / HTTP/1.1\\r\\n\\r\\n\"\n    # Internal Server Error\n    assert_includes data, \"HTTP/1.1 500 #{STATUS_CODES[500]}\"\n    assert_includes data, 'Puma caught this error: no backtrace error (WithoutBacktraceError)'\n    assert_includes data, '<no backtrace available>'\n  end\n\n  def test_force_shutdown_error_default\n    server_run(force_shutdown_after: 2) do\n      @server.stop\n      sleep 5\n    end\n\n    data = send_http_and_read \"GET / HTTP/1.0\\r\\n\\r\\n\"\n\n    assert_match(/HTTP\\/1.0 503 Service Unavailable/, data)\n    assert_match(/Puma caught this error.+Puma::ThreadPool::ForceShutdown/, data)\n  end\n\n  def test_prints_custom_error\n    re = lambda { |err| [302, {'Content-Type' => 'text', 'Location' => 'foo.html'}, ['302 found']] }\n    server_run(lowlevel_error_handler: re) { raise \"don't leak me bro\" }\n\n    data = send_http_and_read \"GET / HTTP/1.0\\r\\n\\r\\n\"\n\n    assert_match(/HTTP\\/1.0 302 Found/, data)\n  end\n\n  def test_leh_gets_env_as_well\n    re = lambda { |err,env|\n      env['REQUEST_PATH'] || raise('where is env?')\n      [302, {'Content-Type' => 'text', 'Location' => 'foo.html'}, ['302 found']]\n    }\n\n    server_run(lowlevel_error_handler: re) { raise \"don't leak me bro\" }\n\n    data = send_http_and_read \"GET / HTTP/1.0\\r\\n\\r\\n\"\n\n    assert_match(/HTTP\\/1.0 302 Found/, data)\n  end\n\n  def test_leh_has_status\n    re = lambda { |err, env, status|\n      raise \"Cannot find status\" unless status\n      [302, {'Content-Type' => 'text', 'Location' => 'foo.html'}, ['302 found']]\n    }\n\n    server_run(lowlevel_error_handler: re) { raise \"don't leak me bro\" }\n\n    data = send_http_and_read \"GET / HTTP/1.0\\r\\n\\r\\n\"\n\n    assert_match(/HTTP\\/1.0 302 Found/, data)\n  end\n\n  def test_custom_http_codes_10\n    server_run { [449, {}, [\"\"]] }\n\n    data = send_http_and_read \"GET / HTTP/1.0\\r\\n\\r\\n\"\n\n    assert_equal \"HTTP/1.0 449 CUSTOM\\r\\nContent-Length: 0\\r\\n\\r\\n\", data\n  end\n\n  def test_custom_http_codes_11\n    server_run { [449, {}, [\"\"]] }\n\n    data = send_http_and_read \"GET / HTTP/1.1\\r\\nConnection: close\\r\\n\\r\\n\"\n\n    assert_equal \"HTTP/1.1 449 CUSTOM\\r\\nConnection: close\\r\\nContent-Length: 0\\r\\n\\r\\n\", data\n  end\n\n  def test_HEAD_returns_content_headers\n    server_run { [200, {\"Content-Type\" => \"application/pdf\",\n                                     \"Content-Length\" => \"4242\"}, []] }\n\n    data = send_http_and_read \"HEAD / HTTP/1.0\\r\\n\\r\\n\"\n\n    assert_equal \"HTTP/1.0 200 OK\\r\\nContent-Type: application/pdf\\r\\nContent-Length: 4242\\r\\n\\r\\n\", data\n  end\n\n  def test_status_hook_fires_when_server_changes_states\n\n    states = []\n\n    @events.register(:state) { |s| states << s }\n\n    server_run { [200, {}, [\"\"]] }\n\n    _ = send_http_and_read \"HEAD / HTTP/1.0\\r\\n\\r\\n\"\n\n    assert_equal [:booting, :running], states\n\n    @server.stop(true)\n\n    assert_equal [:booting, :running, :stop, :done], states\n  end\n\n  def test_timeout_in_data_phase(**options)\n    server_run(first_data_timeout: 1, **options)\n\n    sock = send_http \"POST / HTTP/1.1\\r\\nHost: test.com\\r\\nContent-Type: text/plain\\r\\nContent-Length: 5\\r\\n\\r\\n\"\n\n    sock << \"Hello\" unless sock.wait_readable(1.15)\n\n    data = sock.gets\n\n    # Request Timeout\n    assert_equal \"HTTP/1.1 408 #{STATUS_CODES[408]}\\r\\n\", data\n  end\n\n  def test_timeout_data_no_queue\n    test_timeout_in_data_phase(queue_requests: false)\n  end\n\n  # https://github.com/puma/puma/issues/2574\n  def test_no_timeout_after_data_received\n    @server.instance_variable_set(:@first_data_timeout, 1)\n    server_run\n\n    sock = send_http \"POST / HTTP/1.1\\r\\nHost: test.com\\r\\nContent-Type: text/plain\\r\\nContent-Length: 11\\r\\n\\r\\n\"\n    sleep 0.5\n\n    sock << \"hello\"\n    sleep 0.5\n    sock << \"world\"\n    sleep 0.5\n    sock << \"!\"\n\n    data = sock.gets\n\n    assert_equal \"HTTP/1.1 200 OK\\r\\n\", data\n  end\n\n  def test_no_timeout_after_data_received_no_queue\n    @server = Puma::Server.new @app, @events, {log_writer: @log_writer, queue_requests: false}\n    test_no_timeout_after_data_received\n  end\n\n  def test_http_11_keep_alive_with_body\n    server_run { [200, {\"Content-Type\" => \"plain/text\"}, [\"hello\\n\"]] }\n\n    sock = send_http \"GET / HTTP/1.1\\r\\nConnection: Keep-Alive\\r\\n\\r\\n\"\n\n    h = header sock\n\n    body = sock.gets\n\n    assert_equal [\"HTTP/1.1 200 OK\", \"Content-Type: plain/text\", \"Content-Length: 6\"], h\n    assert_equal \"hello\\n\", body\n\n    sock.close\n  end\n\n  def test_http_11_close_with_body\n    server_run { [200, {\"Content-Type\" => \"plain/text\"}, [\"hello\"]] }\n\n    data = send_http_and_read \"GET / HTTP/1.1\\r\\nConnection: close\\r\\n\\r\\n\"\n\n    assert_equal \"HTTP/1.1 200 OK\\r\\nContent-Type: plain/text\\r\\nConnection: close\\r\\nContent-Length: 5\\r\\n\\r\\nhello\", data\n  end\n\n  def test_http_11_keep_alive_without_body\n    server_run { [204, {}, []] }\n\n    sock = send_http \"GET / HTTP/1.1\\r\\nConnection: Keep-Alive\\r\\n\\r\\n\"\n\n    h = header sock\n\n    # No Content\n    assert_equal [\"HTTP/1.1 204 #{STATUS_CODES[204]}\"], h\n  end\n\n  def test_http_11_close_without_body\n    server_run { [204, {}, []] }\n\n    sock = send_http \"GET / HTTP/1.1\\r\\nConnection: close\\r\\n\\r\\n\"\n\n    h = header sock\n\n    # No Content\n    assert_equal [\"HTTP/1.1 204 #{STATUS_CODES[204]}\", \"Connection: close\"], h\n  end\n\n  def test_http_10_keep_alive_with_body\n    server_run { [200, {\"Content-Type\" => \"plain/text\"}, [\"hello\\n\"]] }\n\n    sock = send_http \"GET / HTTP/1.0\\r\\nConnection: Keep-Alive\\r\\n\\r\\n\"\n\n    h = header sock\n\n    body = sock.gets\n\n    assert_equal [\"HTTP/1.0 200 OK\", \"Content-Type: plain/text\", \"Connection: Keep-Alive\", \"Content-Length: 6\"], h\n    assert_equal \"hello\\n\", body\n  end\n\n  def test_http_10_close_with_body\n    server_run { [200, {\"Content-Type\" => \"plain/text\"}, [\"hello\"]] }\n\n    data = send_http_and_read \"GET / HTTP/1.0\\r\\nConnection: close\\r\\n\\r\\n\"\n\n    assert_equal \"HTTP/1.0 200 OK\\r\\nContent-Type: plain/text\\r\\nContent-Length: 5\\r\\n\\r\\nhello\", data\n  end\n\n  def test_http_10_keep_alive_without_body\n    server_run { [204, {}, []] }\n\n    sock = send_http \"GET / HTTP/1.0\\r\\nConnection: Keep-Alive\\r\\n\\r\\n\"\n\n    h = header sock\n\n    assert_equal [\"HTTP/1.0 204 No Content\", \"Connection: Keep-Alive\"], h\n  end\n\n  def test_http_10_close_without_body\n    server_run { [204, {}, []] }\n\n    data = send_http_and_read \"GET / HTTP/1.0\\r\\nConnection: close\\r\\n\\r\\n\"\n\n    assert_equal \"HTTP/1.0 204 No Content\\r\\n\\r\\n\", data\n  end\n\n  def test_Expect_100\n    server_run { [200, {}, [\"\"]] }\n\n    data = send_http_and_read \"GET / HTTP/1.1\\r\\nConnection: close\\r\\nExpect: 100-continue\\r\\n\\r\\n\"\n\n    assert_equal \"HTTP/1.1 100 Continue\\r\\n\\r\\nHTTP/1.1 200 OK\\r\\nConnection: close\\r\\nContent-Length: 0\\r\\n\\r\\n\", data\n  end\n\n  def test_chunked_request\n    body = nil\n    content_length = nil\n    transfer_encoding = nil\n    server_run { |env|\n      body = env['rack.input'].read\n      content_length = env['CONTENT_LENGTH']\n      transfer_encoding = env['HTTP_TRANSFER_ENCODING']\n      [200, {}, [\"\"]]\n    }\n\n    data = send_http_and_read \"GET / HTTP/1.1\\r\\nConnection: close\\r\\nTransfer-Encoding: gzip,chunked\\r\\n\\r\\n1\\r\\nh\\r\\n4\\r\\nello\\r\\n0\\r\\n\\r\\n\"\n\n    assert_equal \"HTTP/1.1 200 OK\\r\\nConnection: close\\r\\nContent-Length: 0\\r\\n\\r\\n\", data\n    assert_equal \"hello\", body\n    assert_equal \"5\", content_length\n    assert_nil transfer_encoding\n  end\n\n  def test_large_chunked_request\n    body = nil\n    content_length = nil\n    server_run { |env|\n      body = env['rack.input'].read\n      content_length = env['CONTENT_LENGTH']\n      [200, {}, [\"\"]]\n    }\n\n    header = \"GET / HTTP/1.1\\r\\nConnection: close\\r\\nTransfer-Encoding: chunked\\r\\n\\r\\n\"\n\n    chunk_header_size = 6 # 4fb8\\r\\n\n    # Current implementation reads one chunk of CHUNK_SIZE, then more chunks of size 4096.\n    # We want a chunk to split exactly after \"#{request_body}\\r\", before the \"\\n\".\n    edge_case_size = Puma::Const::CHUNK_SIZE + 4096 - header.size - chunk_header_size - 1\n\n    margin = 0 # 0 for only testing this specific case, increase to test more surrounding sizes\n    (-margin..margin).each do |i|\n      size = edge_case_size + i\n      request_body = '.' * size\n      request = \"#{header}#{size.to_s(16)}\\r\\n#{request_body}\\r\\n0\\r\\n\\r\\n\"\n\n      data = send_http_and_read request\n\n      assert_equal \"HTTP/1.1 200 OK\\r\\nConnection: close\\r\\nContent-Length: 0\\r\\n\\r\\n\", data\n      assert_equal size, Integer(content_length)\n      assert_equal request_body, body\n    end\n  end\n\n  def test_chunked_request_pause_before_value\n    body = nil\n    content_length = nil\n    server_run { |env|\n      body = env['rack.input'].read\n      content_length = env['CONTENT_LENGTH']\n      [200, {}, [\"\"]]\n    }\n\n    sock = send_http \"GET / HTTP/1.1\\r\\nConnection: close\\r\\nTransfer-Encoding: chunked\\r\\n\\r\\n1\\r\\n\"\n    sleep 1\n\n    sock << \"h\\r\\n4\\r\\nello\\r\\n0\\r\\n\\r\\n\"\n\n    data = sock.read\n\n    assert_equal \"HTTP/1.1 200 OK\\r\\nConnection: close\\r\\nContent-Length: 0\\r\\n\\r\\n\", data\n    assert_equal \"hello\", body\n    assert_equal \"5\", content_length\n  end\n\n  def test_chunked_request_pause_between_chunks\n    body = nil\n    content_length = nil\n    server_run { |env|\n      body = env['rack.input'].read\n      content_length = env['CONTENT_LENGTH']\n      [200, {}, [\"\"]]\n    }\n\n    sock = send_http \"GET / HTTP/1.1\\r\\nConnection: close\\r\\nTransfer-Encoding: chunked\\r\\n\\r\\n1\\r\\nh\\r\\n\"\n    sleep 1\n\n    sock << \"4\\r\\nello\\r\\n0\\r\\n\\r\\n\"\n\n    data = sock.read\n\n    assert_equal \"HTTP/1.1 200 OK\\r\\nConnection: close\\r\\nContent-Length: 0\\r\\n\\r\\n\", data\n    assert_equal \"hello\", body\n    assert_equal \"5\", content_length\n  end\n\n  def test_chunked_request_pause_mid_count\n    body = nil\n    content_length = nil\n    server_run { |env|\n      body = env['rack.input'].read\n      content_length = env['CONTENT_LENGTH']\n      [200, {}, [\"\"]]\n    }\n\n    sock = send_http \"GET / HTTP/1.1\\r\\nConnection: close\\r\\nTransfer-Encoding: chunked\\r\\n\\r\\n1\\r\"\n    sleep 1\n\n    sock << \"\\nh\\r\\n4\\r\\nello\\r\\n0\\r\\n\\r\\n\"\n\n    data = sock.read\n\n    assert_equal \"HTTP/1.1 200 OK\\r\\nConnection: close\\r\\nContent-Length: 0\\r\\n\\r\\n\", data\n    assert_equal \"hello\", body\n    assert_equal \"5\", content_length\n  end\n\n  def test_chunked_request_pause_before_count_newline\n    body = nil\n    content_length = nil\n    server_run { |env|\n      body = env['rack.input'].read\n      content_length = env['CONTENT_LENGTH']\n      [200, {}, [\"\"]]\n    }\n\n    sock = send_http \"GET / HTTP/1.1\\r\\nConnection: close\\r\\nTransfer-Encoding: chunked\\r\\n\\r\\n1\"\n    sleep 1\n\n    sock << \"\\r\\nh\\r\\n4\\r\\nello\\r\\n0\\r\\n\\r\\n\"\n\n    data = sock.read\n\n    assert_equal \"HTTP/1.1 200 OK\\r\\nConnection: close\\r\\nContent-Length: 0\\r\\n\\r\\n\", data\n    assert_equal \"hello\", body\n    assert_equal \"5\", content_length\n  end\n\n  def test_chunked_request_pause_mid_value\n    body = nil\n    content_length = nil\n    server_run { |env|\n      body = env['rack.input'].read\n      content_length = env['CONTENT_LENGTH']\n      [200, {}, [\"\"]]\n    }\n\n    sock = send_http \"GET / HTTP/1.1\\r\\nConnection: close\\r\\nTransfer-Encoding: chunked\\r\\n\\r\\n1\\r\\nh\\r\\n4\\r\\ne\"\n    sleep 1\n\n    sock << \"llo\\r\\n0\\r\\n\\r\\n\"\n\n    data = sock.read\n\n    assert_equal \"HTTP/1.1 200 OK\\r\\nConnection: close\\r\\nContent-Length: 0\\r\\n\\r\\n\", data\n    assert_equal \"hello\", body\n    assert_equal \"5\", content_length\n  end\n\n  def test_chunked_request_pause_between_cr_lf_after_size_of_second_chunk\n    body = nil\n    content_length = nil\n    server_run { |env|\n      body = env['rack.input'].read\n      content_length = env['CONTENT_LENGTH']\n      [200, {}, [\"\"]]\n    }\n\n    part1 = 'a' * 4200\n\n    chunked_body = \"#{part1.size.to_s(16)}\\r\\n#{part1}\\r\\n1\\r\\nb\\r\\n0\\r\\n\\r\\n\"\n\n    sock = send_http \"PUT /path HTTP/1.1\\r\\nConnection: close\\r\\nTransfer-Encoding: chunked\\r\\n\\r\\n\"\n\n    sleep 0.1\n\n    sock << chunked_body[0..-10]\n\n    sleep 0.1\n\n    sock << chunked_body[-9..-1]\n\n    data = sock.read\n\n    assert_equal \"HTTP/1.1 200 OK\\r\\nConnection: close\\r\\nContent-Length: 0\\r\\n\\r\\n\", data\n    assert_equal (part1 + 'b'), body\n    assert_equal \"4201\", content_length\n  end\n\n  def test_chunked_request_pause_between_closing_cr_lf\n    body = nil\n    content_length = nil\n    server_run { |env|\n      body = env['rack.input'].read\n      content_length = env['CONTENT_LENGTH']\n      [200, {}, [\"\"]]\n    }\n\n    sock = send_http \"PUT /path HTTP/1.1\\r\\nConnection: close\\r\\nTransfer-Encoding: chunked\\r\\n\\r\\n5\\r\\nhello\\r\"\n\n    sleep 1\n\n    sock << \"\\n0\\r\\n\\r\\n\"\n\n    data = sock.read\n\n    assert_equal \"HTTP/1.1 200 OK\\r\\nConnection: close\\r\\nContent-Length: 0\\r\\n\\r\\n\", data\n    assert_equal 'hello', body\n    assert_equal \"5\", content_length\n  end\n\n  def test_chunked_request_pause_before_closing_cr_lf\n    body = nil\n    content_length = nil\n    server_run { |env|\n      body = env['rack.input'].read\n      content_length = env['CONTENT_LENGTH']\n      [200, {}, [\"\"]]\n    }\n\n    sock = send_http \"PUT /path HTTP/1.1\\r\\nConnection: close\\r\\nTransfer-Encoding: chunked\\r\\n\\r\\n5\\r\\nhello\"\n\n    sleep 1\n\n    sock << \"\\r\\n0\\r\\n\\r\\n\"\n\n    data = sock.read\n\n    assert_equal \"HTTP/1.1 200 OK\\r\\nConnection: close\\r\\nContent-Length: 0\\r\\n\\r\\n\", data\n    assert_equal 'hello', body\n    assert_equal \"5\", content_length\n  end\n\n  def test_chunked_request_header_case\n    body = nil\n    content_length = nil\n    server_run { |env|\n      body = env['rack.input'].read\n      content_length = env['CONTENT_LENGTH']\n      [200, {}, [\"\"]]\n    }\n\n    data = send_http_and_read \"GET / HTTP/1.1\\r\\nConnection: close\\r\\nTransfer-Encoding: Chunked\\r\\n\\r\\n1\\r\\nh\\r\\n4\\r\\nello\\r\\n0\\r\\n\\r\\n\"\n\n    assert_equal \"HTTP/1.1 200 OK\\r\\nConnection: close\\r\\nContent-Length: 0\\r\\n\\r\\n\", data\n    assert_equal \"hello\", body\n    assert_equal \"5\", content_length\n  end\n\n  def test_chunked_keep_alive\n    body = nil\n    content_length = nil\n    server_run { |env|\n      body = env['rack.input'].read\n      content_length = env['CONTENT_LENGTH']\n      [200, {}, [\"\"]]\n    }\n\n    sock = send_http \"GET / HTTP/1.1\\r\\nConnection: Keep-Alive\\r\\nTransfer-Encoding: chunked\\r\\n\\r\\n1\\r\\nh\\r\\n4\\r\\nello\\r\\n0\\r\\n\\r\\n\"\n\n    h = header sock\n\n    assert_equal [\"HTTP/1.1 200 OK\", \"Content-Length: 0\"], h\n    assert_equal \"hello\", body\n    assert_equal \"5\", content_length\n\n    sock.close\n  end\n\n  def test_chunked_keep_alive_two_back_to_back\n    body = nil\n    content_length = nil\n    server_run { |env|\n      body = env['rack.input'].read\n      content_length = env['CONTENT_LENGTH']\n      [200, {}, [\"\"]]\n    }\n\n    sock = send_http \"GET / HTTP/1.1\\r\\nConnection: Keep-Alive\\r\\nTransfer-Encoding: chunked\\r\\n\\r\\n1\\r\\nh\\r\\n4\\r\\nello\\r\\n0\\r\\n\"\n\n    last_crlf_written = false\n    last_crlf_writer = Thread.new do\n      sleep 0.1\n      sock << \"\\r\"\n      sleep 0.1\n      sock << \"\\n\"\n      last_crlf_written = true\n    end\n\n    h = header(sock)\n    assert_equal [\"HTTP/1.1 200 OK\", \"Content-Length: 0\"], h\n    assert_equal \"hello\", body\n    assert_equal \"5\", content_length\n    sleep 0.05 if TRUFFLE\n    assert_equal true, last_crlf_written\n\n    last_crlf_writer.join\n\n    sock << \"GET / HTTP/1.1\\r\\nConnection: Keep-Alive\\r\\nTransfer-Encoding: chunked\\r\\n\\r\\n4\\r\\ngood\\r\\n3\\r\\nbye\\r\\n0\\r\\n\\r\\n\"\n    sleep 0.1\n\n    h = header(sock)\n\n    assert_equal [\"HTTP/1.1 200 OK\", \"Content-Length: 0\"], h\n    assert_equal \"goodbye\", body\n    assert_equal \"7\", content_length\n\n    sock.close\n  end\n\n  def test_chunked_keep_alive_two_back_to_back_with_set_remote_address\n    body = nil\n    content_length = nil\n    remote_addr =nil\n    server_run(remote_address: :header, remote_address_header: 'HTTP_X_FORWARDED_FOR') { |env|\n      body = env['rack.input'].read\n      content_length = env['CONTENT_LENGTH']\n      remote_addr = env['REMOTE_ADDR']\n      [200, {}, [\"\"]]\n    }\n\n    sock = send_http \"GET / HTTP/1.1\\r\\nX-Forwarded-For: 127.0.0.1\\r\\nConnection: Keep-Alive\\r\\nTransfer-Encoding: chunked\\r\\n\\r\\n1\\r\\nh\\r\\n4\\r\\nello\\r\\n0\\r\\n\\r\\n\"\n\n    h = header sock\n    assert_equal [\"HTTP/1.1 200 OK\", \"Content-Length: 0\"], h\n    assert_equal \"hello\", body\n    assert_equal \"5\", content_length\n    assert_equal \"127.0.0.1\", remote_addr\n\n    sock << \"GET / HTTP/1.1\\r\\nX-Forwarded-For: 127.0.0.2\\r\\nConnection: Keep-Alive\\r\\nTransfer-Encoding: chunked\\r\\n\\r\\n4\\r\\ngood\\r\\n3\\r\\nbye\\r\\n0\\r\\n\\r\\n\"\n    sleep 0.1\n\n    h = header(sock)\n\n    assert_equal [\"HTTP/1.1 200 OK\", \"Content-Length: 0\"], h\n    assert_equal \"goodbye\", body\n    assert_equal \"7\", content_length\n    assert_equal \"127.0.0.2\", remote_addr\n\n    sock.close\n  end\n\n  def test_chunked_encoding\n    enc = Encoding::UTF_16LE\n    str = \"\u2500\u2500\u0438\u0457_\u30c6\u30b9\u30c8\u2500\u2500\\n\".encode enc\n\n    server_run {\n      hdrs = {}\n      hdrs['Content-Type'] = \"text; charset=#{enc.to_s.downcase}\"\n\n      body = Enumerator.new do |yielder|\n        100.times do |entry|\n          yielder << str\n        end\n        yielder << \"\\nHello World\\n\".encode(enc)\n      end\n\n      [200, hdrs, body]\n    }\n\n    body = Net::HTTP.start @host, @port do |http|\n      http.request(Net::HTTP::Get.new '/').body.force_encoding(enc)\n    end\n    assert_includes body, str\n    assert_equal enc, body.encoding\n  end\n\n  def test_empty_header_values\n    server_run { [200, {\"X-Empty-Header\" => \"\"}, []] }\n\n    data = send_http_and_read \"HEAD / HTTP/1.0\\r\\n\\r\\n\"\n\n    assert_equal \"HTTP/1.0 200 OK\\r\\nX-Empty-Header: \\r\\nContent-Length: 0\\r\\n\\r\\n\", data\n  end\n\n  def test_request_body_wait\n    request_body_wait = nil\n    server_run { |env|\n      request_body_wait = env['puma.request_body_wait']\n      [204, {}, []]\n    }\n\n    sock = send_http \"POST / HTTP/1.1\\r\\nHost: test.com\\r\\nContent-Type: text/plain\\r\\nContent-Length: 5\\r\\n\\r\\nh\"\n    sleep 1\n    sock << \"ello\"\n\n    sock.gets\n\n    assert request_body_wait.is_a?(Float)\n    # Could be 1000 but the tests get flaky. We don't care if it's extremely precise so much as that\n    # it is set to a reasonable number.\n    assert_operator request_body_wait, :>=, 900\n  end\n\n  def test_request_body_wait_chunked\n    request_body_wait = nil\n    server_run { |env|\n      request_body_wait = env['puma.request_body_wait']\n      [204, {}, []]\n    }\n\n    sock = send_http \"GET / HTTP/1.1\\r\\nConnection: close\\r\\nTransfer-Encoding: chunked\\r\\n\\r\\n1\\r\\nh\\r\\n\"\n    sleep 3\n    sock << \"4\\r\\nello\\r\\n0\\r\\n\\r\\n\"\n\n    sock.gets\n\n    # Could be 1000 but the tests get flaky. We don't care if it's extremely precise so much as that\n    # it is set to a reasonable number.\n    assert_operator request_body_wait, :>=, 900\n  end\n\n  def test_open_connection_wait(**options)\n    server_run(**options) { [200, {}, [\"Hello\"]] }\n    s = send_http nil\n    sleep 0.1\n    s << \"GET / HTTP/1.0\\r\\n\\r\\n\"\n    assert_equal 'Hello', s.readlines.last\n  end\n\n  def test_open_connection_wait_no_queue\n    test_open_connection_wait(queue_requests: false)\n  end\n\n  # Rack may pass a newline in a header expecting us to split it.\n  def test_newline_splits\n    server_run { [200, {'X-header' => \"first line\\nsecond line\"}, [\"Hello\"]] }\n\n    data = send_http_and_read \"HEAD / HTTP/1.0\\r\\n\\r\\n\"\n\n    assert_match \"X-header: first line\\r\\nX-header: second line\\r\\n\", data\n  end\n\n  def test_newline_splits_in_early_hint\n    server_run(early_hints: true) do |env|\n      env['rack.early_hints'].call({'X-header' => \"first line\\nsecond line\"})\n      [200, {}, [\"Hello world!\"]]\n    end\n\n    data = send_http_and_read \"HEAD / HTTP/1.0\\r\\n\\r\\n\"\n\n    assert_match \"X-header: first line\\r\\nX-header: second line\\r\\n\", data\n  end\n\n  def test_proxy_protocol\n    server_run(remote_address: :proxy_protocol, remote_address_proxy_protocol: :v1) do |env|\n      [200, {}, [env[\"REMOTE_ADDR\"]]]\n    end\n\n    remote_addr = send_proxy_v1_http(\"GET / HTTP/1.0\\r\\n\\r\\n\", \"1.2.3.4\").read.split(\"\\r\\n\").last\n    assert_equal '1.2.3.4', remote_addr\n\n    remote_addr = send_proxy_v1_http(\"GET / HTTP/1.0\\r\\n\\r\\n\", \"fd00::1\").read.split(\"\\r\\n\").last\n    assert_equal 'fd00::1', remote_addr\n\n    remote_addr = send_proxy_v1_http(\"GET / HTTP/1.0\\r\\n\\r\\n\", \"fd00::1\", true).read.split(\"\\r\\n\").last\n    assert_equal 'fd00::1', remote_addr\n  end\n\n  # To comply with the Rack spec, we have to split header field values\n  # containing newlines into multiple headers.\n  def assert_does_not_allow_http_injection(app, opts = {})\n    server_run(early_hints: opts[:early_hints], &app)\n\n    data = send_http_and_read \"HEAD / HTTP/1.0\\r\\n\\r\\n\"\n\n    refute_match(/[\\r\\n]Cookie: hack[\\r\\n]/, data)\n  end\n\n  # HTTP Injection Tests\n  #\n  # Puma should prevent injection of CR and LF characters into headers, either as\n  # CRLF or CR or LF, because browsers may interpret it at as a line end and\n  # allow untrusted input in the header to split the header or start the\n  # response body. While it's not documented anywhere and they shouldn't be doing\n  # it, Chrome and curl recognize a lone CR as a line end. According to RFC,\n  # clients SHOULD interpret LF as a line end for robustness, and CRLF is the\n  # specced line end.\n  #\n  # There are three different tests because there are three ways to set header\n  # content in Puma. Regular (rack env), early hints, and a special case for\n  # overriding content-length.\n  {\"cr\" => \"\\r\", \"lf\" => \"\\n\", \"crlf\" => \"\\r\\n\"}.each do |suffix, line_ending|\n    # The cr-only case for the following test was CVE-2020-5247\n    define_method(\"test_prevent_response_splitting_headers_#{suffix}\") do\n      app = ->(_) { [200, {'X-header' => \"untrusted input#{line_ending}Cookie: hack\"}, [\"Hello\"]] }\n      assert_does_not_allow_http_injection(app)\n    end\n\n    define_method(\"test_prevent_response_splitting_headers_early_hint_#{suffix}\") do\n      app = ->(env) do\n        env['rack.early_hints'].call(\"X-header\" => \"untrusted input#{line_ending}Cookie: hack\")\n        [200, {}, [\"Hello\"]]\n      end\n      assert_does_not_allow_http_injection(app, early_hints: true)\n    end\n\n    define_method(\"test_prevent_content_length_injection_#{suffix}\") do\n      app = ->(_) { [200, {'content-length' => \"untrusted input#{line_ending}Cookie: hack\"}, [\"Hello\"]] }\n      assert_does_not_allow_http_injection(app)\n    end\n  end\n\n  # Perform a server shutdown while requests are pending (one in app-server response, one still sending client request).\n  def shutdown_requests(s1_complete: true, s1_response: nil, post: false, s2_response: nil, **options)\n    mutex = Mutex.new\n    app_finished = ConditionVariable.new\n    server_run(**options) { |env|\n      path = env['REQUEST_PATH']\n      mutex.synchronize do\n        app_finished.signal\n        app_finished.wait(mutex) if path == '/s1'\n      end\n      [204, {}, []]\n    }\n\n    pool = @server.instance_variable_get(:@thread_pool)\n\n    # Trigger potential race condition by pausing Reactor#add until shutdown begins.\n    if options.fetch(:queue_requests, true)\n      reactor = @server.instance_variable_get(:@reactor)\n      reactor.instance_variable_set(:@pool, pool)\n      reactor.extend(Module.new do\n        def add(client)\n          if client.env['REQUEST_PATH'] == '/s2'\n            Thread.pass until @pool.instance_variable_get(:@shutdown)\n          end\n          super\n        end\n      end)\n    end\n\n    s1 = nil\n    s2 = send_http post ?\n      \"POST /s2 HTTP/1.1\\r\\nHost: test.com\\r\\nContent-Type: text/plain\\r\\nContent-Length: 5\\r\\n\\r\\nhi!\" :\n      \"GET /s2 HTTP/1.1\\r\\n\"\n    mutex.synchronize do\n      s1 = send_http \"GET /s1 HTTP/1.1\\r\\n\\r\\n\"\n      app_finished.wait(mutex)\n      app_finished.signal if s1_complete\n    end\n    @server.stop\n    Thread.pass until pool.instance_variable_get(:@shutdown)\n\n    assert_match(s1_response, s1.gets) if s1_response\n\n    # Send s2 after shutdown begins\n    s2 << \"\\r\\n\" unless s2.wait_readable(0.2)\n\n    assert s2.wait_readable(10), 'timeout waiting for response'\n    s2_result = begin\n      s2.gets\n    rescue Errno::ECONNABORTED, Errno::ECONNRESET\n      # Some platforms raise errors instead of returning a response/EOF when a TCP connection is aborted.\n      post ? '408' : nil\n    end\n\n    if s2_response\n      assert_match s2_response, s2_result\n    else\n      assert_nil s2_result\n    end\n  end\n\n  # Shutdown should allow pending requests and app-responses to complete.\n  def test_shutdown_requests\n    opts = {s1_response: /204/, s2_response: /204/}\n    shutdown_requests(**opts)\n    shutdown_requests(**opts, queue_requests: false)\n  end\n\n  # Requests still pending after `force_shutdown_after` should have connection closed (408 w/pending POST body).\n  # App-responses still pending should return 503 (uncaught Puma::ThreadPool::ForceShutdown exception).\n  def test_force_shutdown\n    opts = {s1_complete: false, s1_response: /503/, s2_response: nil, force_shutdown_after: 0}\n    shutdown_requests(**opts)\n    shutdown_requests(**opts, queue_requests: false)\n    shutdown_requests(**opts, post: true, s2_response: /408/)\n  end\n\n  def test_http11_connection_header_queue\n    server_run { [200, {}, [\"\"]] }\n\n    sock = send_http \"GET / HTTP/1.1\\r\\n\\r\\n\"\n    assert_equal [\"HTTP/1.1 200 OK\", \"Content-Length: 0\"], header(sock)\n\n    sock << \"GET / HTTP/1.1\\r\\nConnection: close\\r\\n\\r\\n\"\n    assert_equal [\"HTTP/1.1 200 OK\", \"Connection: close\", \"Content-Length: 0\"], header(sock)\n\n    sock.close\n  end\n\n  def test_http10_connection_header_queue\n    server_run { [200, {}, [\"\"]] }\n\n    sock = send_http \"GET / HTTP/1.0\\r\\nConnection: keep-alive\\r\\n\\r\\n\"\n    assert_equal [\"HTTP/1.0 200 OK\", \"Connection: Keep-Alive\", \"Content-Length: 0\"], header(sock)\n\n    sock << \"GET / HTTP/1.0\\r\\n\\r\\n\"\n    assert_equal [\"HTTP/1.0 200 OK\", \"Content-Length: 0\"], header(sock)\n    sock.close\n  end\n\n  def test_http11_connection_header_no_queue\n    server_run(queue_requests: false) { [200, {}, [\"\"]] }\n    sock = send_http \"GET / HTTP/1.1\\r\\n\\r\\n\"\n    assert_equal [\"HTTP/1.1 200 OK\", \"Connection: close\", \"Content-Length: 0\"], header(sock)\n    sock.close\n  end\n\n  def test_http10_connection_header_no_queue\n    server_run(queue_requests: false) { [200, {}, [\"\"]] }\n    sock = send_http \"GET / HTTP/1.0\\r\\n\\r\\n\"\n    assert_equal [\"HTTP/1.0 200 OK\", \"Content-Length: 0\"], header(sock)\n    sock.close\n  end\n\n  def stub_accept_nonblock(error)\n    @port = (@server.add_tcp_listener @host, 0).addr[1]\n    io = @server.binder.ios.last\n\n    accept_old = io.method(:accept_nonblock)\n    io.singleton_class.send :define_method, :accept_nonblock do\n      accept_old.call.close\n      raise error\n    end\n\n    @server.run\n    new_connection\n    sleep 0.01\n  end\n\n  # System-resource errors such as EMFILE should not be silently swallowed by accept loop.\n  def test_accept_emfile\n    stub_accept_nonblock Errno::EMFILE.new('accept(2)')\n    refute_empty @log_writer.stderr.string, \"Expected EMFILE error not logged\"\n  end\n\n  # Retryable errors such as ECONNABORTED should be silently swallowed by accept loop.\n  def test_accept_econnaborted\n    # Match Ruby #accept_nonblock implementation, ECONNABORTED error is extended by IO::WaitReadable.\n    error = Errno::ECONNABORTED.new('accept(2) would block').tap {|e| e.extend IO::WaitReadable}\n    stub_accept_nonblock(error)\n    assert_empty @log_writer.stderr.string\n  end\n\n  # see      https://github.com/puma/puma/issues/2390\n  # fixed by https://github.com/puma/puma/pull/2279\n  #\n  def test_client_quick_close_no_lowlevel_error_handler_call\n    handler = ->(err, env, status) {\n      @log_writer.stdout.write \"LLEH #{err.message}\"\n      [500, {\"Content-Type\" => \"application/json\"}, [\"{}\\n\"]]\n    }\n\n    server_run(lowlevel_error_handler: handler) { [200, {}, ['Hello World']] }\n\n    # valid req & read, close\n    sock = TCPSocket.new @host, @port\n    sock.syswrite \"GET / HTTP/1.0\\r\\n\\r\\n\"\n    sleep 0.05  # macOS TruffleRuby may not get the body without\n    resp = sock.sysread 256\n    sock.close\n    assert_match 'Hello World', resp\n    sleep 0.5\n    assert_empty @log_writer.stdout.string\n\n    # valid req, close\n    sock = TCPSocket.new @host, @port\n    sock.syswrite \"GET / HTTP/1.0\\r\\n\\r\\n\"\n    sock.close\n    sleep 0.5\n    assert_empty @log_writer.stdout.string\n\n    # invalid req, close\n    sock = TCPSocket.new @host, @port\n    sock.syswrite \"GET / HTTP\"\n    sock.close\n    sleep 0.5\n    assert_empty @log_writer.stdout.string\n  end\n\n  def test_idle_connections_closed_immediately_on_shutdown\n    server_run\n    sock = new_connection\n    sleep 0.5 # give enough time for new connection to enter reactor\n    @server.stop false\n\n    assert sock.wait_readable(1), 'Unexpected timeout'\n    assert_raises EOFError do\n      sock.read_nonblock(256)\n    end\n  end\n\n  def test_run_stop_thread_safety\n    100.times do\n      thread = @server.run\n      @server.stop\n      assert thread.join(1)\n    end\n  end\n\n  def test_command_ignored_before_run\n    @server.stop # ignored\n    @server.run\n    @server.halt\n    done = Queue.new\n    @server.events.register(:state) do |state|\n      done << @server.instance_variable_get(:@status) if state == :done\n    end\n    assert_equal :halt, done.pop\n  end\n\n  def test_custom_io_selector\n    backend = NIO::Selector.backends.first\n\n    @server = Puma::Server.new @app, @events, {log_writer: @log_writer, :io_selector_backend => backend}\n    @server.run\n\n    selector = @server.instance_variable_get(:@reactor).instance_variable_get(:@selector)\n\n    assert_equal selector.backend, backend\n  end\n\n  def test_drain_on_shutdown(drain=true)\n    num_connections = 10\n\n    wait = Queue.new\n    server_run(drain_on_shutdown: drain, max_threads: 1) do\n      wait.pop\n      [200, {}, [\"DONE\"]]\n    end\n    connections = Array.new(num_connections) {send_http \"GET / HTTP/1.0\\r\\n\\r\\n\"}\n    @server.stop\n    wait.close\n    bad = 0\n    connections.each do |s|\n      begin\n        assert_match 'DONE', s.read\n      rescue Errno::ECONNRESET\n        bad += 1\n      end\n    end\n    if drain\n      assert_equal 0, bad\n    else\n      refute_equal 0, bad\n    end\n  end\n\n  def test_not_drain_on_shutdown\n    test_drain_on_shutdown false\n  end\n\n  def test_remote_address_header\n    server_run(remote_address: :header, remote_address_header: 'HTTP_X_REMOTE_IP') do |env|\n      [200, {}, [env['REMOTE_ADDR']]]\n    end\n    remote_addr = send_http_and_read(\"GET / HTTP/1.1\\r\\nX-Remote-IP: 1.2.3.4\\r\\n\\r\\n\").split(\"\\r\\n\").last\n    assert_equal '1.2.3.4', remote_addr\n\n    # TODO: it would be great to test a connection from a non-localhost IP, but we can't really do that. For\n    # now, at least test that it doesn't return garbage.\n    remote_addr = send_http_and_sysread(\"GET / HTTP/1.1\\r\\n\\r\\n\").split(\"\\r\\n\").last\n    assert_equal @host, remote_addr\n  end\n\n  def get_chunk_times\n    body = +''\n    times = []\n    Net::HTTP.start @host, @port do |http|\n      req = Net::HTTP::Get.new '/'\n      http.request req do |resp|\n        resp.read_body do |chunk|\n          next if chunk.empty?\n          body << chunk\n          times << Process.clock_gettime(Process::CLOCK_MONOTONIC)\n        end\n\n      end\n    end\n    [body, times]\n  end\n\n  # see https://github.com/sinatra/sinatra/blob/master/examples/stream.ru\n  def test_streaming_enum_body_1\n    str = \"Hello Puma World\"\n    body_len = str.bytesize * 3\n\n    server_run do |env|\n      hdrs = {}\n      hdrs['Content-Type'] = \"text; charset=utf-8\"\n\n      body = Enumerator.new do |yielder|\n          yielder << str\n          sleep 0.5\n          yielder << str\n          sleep 1.5\n          yielder << str\n      end\n      [200, hdrs, body]\n    end\n\n    resp_body, times = get_chunk_times\n    assert_equal body_len, resp_body.bytesize\n    assert_equal str * 3, resp_body\n    assert times[1] - times[0] > 0.4\n    assert times[1] - times[0] < 1\n    assert times[2] - times[1] > 1\n  end\n\n  # similar to a longer running app passing its output thru an enum body\n  # example - https://github.com/dentarg/testssl.web\n  def test_streaming_enum_body_2\n    str = \"Hello Puma World\"\n    loops = 10\n    body_len = str.bytesize * loops\n\n    server_run do |env|\n      hdrs = {}\n      hdrs['Content-Type'] = \"text; charset=utf-8\"\n\n      body = Enumerator.new do |yielder|\n        loops.times do |i|\n          sleep 0.15 unless i.zero?\n          yielder << str\n        end\n      end\n      [200, hdrs, body]\n    end\n    resp_body, times = get_chunk_times\n    assert_equal body_len, resp_body.bytesize\n    assert_equal str * loops, resp_body\n    assert_operator times.last - times.first, :>, 1.0\n  end\n\n  def test_empty_body_array_content_length_0\n    server_run { |env| [404, {'Content-Length' => '0'}, []] }\n\n    resp = send_http_and_sysread \"GET / HTTP/1.1\\r\\n\\r\\n\"\n    # Not Found\n    assert_equal \"HTTP/1.1 404 #{STATUS_CODES[404]}\\r\\nContent-Length: 0\\r\\n\\r\\n\", resp\n  end\n\n  def test_empty_body_array_no_content_length\n    server_run { |env| [404, {}, []] }\n\n    resp = send_http_and_sysread \"GET / HTTP/1.1\\r\\n\\r\\n\"\n    # Not Found\n    assert_equal \"HTTP/1.1 404 #{STATUS_CODES[404]}\\r\\nContent-Length: 0\\r\\n\\r\\n\", resp\n  end\n\n  def test_empty_body_enum\n    server_run { |env| [404, {}, [].to_enum] }\n\n    resp = send_http_and_sysread \"GET / HTTP/1.1\\r\\n\\r\\n\"\n    # Not Found\n    assert_equal \"HTTP/1.1 404 #{STATUS_CODES[404]}\\r\\nTransfer-Encoding: chunked\\r\\n\\r\\n0\\r\\n\\r\\n\", resp\n  end\n\n  def test_form_data_encoding_windows_bom\n    req_body = nil\n\n    str = \"\u2500\u2500\u2500\u2500 Hello,World,From,Puma \u2500\u2500\u2500\u2500\\r\\n\"\n\n    file_contents = str * 5_500 # req body is > 256 kB\n\n    file_bytesize = file_contents.bytesize + 3 # 3 = BOM byte size\n\n    fio = Tempfile.create 'win_bom_utf8_'\n\n    temp_file_path = fio.path\n    fio.close\n\n    File.open temp_file_path, \"wb:UTF-8\" do |f|\n      f.write \"\\xEF\\xBB\\xBF#{file_contents}\"\n    end\n\n    server_run do |env|\n      req_body = env['rack.input'].read\n      [200, {}, [req_body]]\n    end\n\n    cmd = \"curl -H 'transfer-encoding: chunked' --form data=@#{temp_file_path} http://127.0.0.1:#{@port}/\"\n\n    out_r, _, _ = spawn_cmd cmd\n\n    out_r.wait_readable 3\n\n    form_file_data = req_body.split(\"\\r\\n\\r\\n\", 2)[1].sub(/\\r\\n----\\S+\\r\\n\\z/, '')\n\n    assert_equal file_bytesize, form_file_data.bytesize\n    assert_equal out_r.read.bytesize, req_body.bytesize\n  end\n\n  def test_form_data_encoding_windows\n    req_body = nil\n\n    str = \"\u2500\u2500\u2500\u2500 Hello,World,From,Puma \u2500\u2500\u2500\u2500\\r\\n\"\n\n    file_contents = str * 5_500 # req body is > 256 kB\n\n    file_bytesize = file_contents.bytesize\n\n    fio = tempfile_create 'win_utf8_', file_contents\n\n    temp_file_path = fio.path\n    fio.close\n\n    server_run do |env|\n      req_body = env['rack.input'].read\n      [200, {}, [req_body]]\n    end\n\n    cmd = \"curl -H 'transfer-encoding: chunked' --form data=@#{temp_file_path} http://127.0.0.1:#{@port}/\"\n\n    out_r, _, _ = spawn_cmd cmd\n\n    out_r.wait_readable 3\n\n    form_file_data = req_body.split(\"\\r\\n\\r\\n\", 2)[1].sub(/\\r\\n----\\S+\\r\\n\\z/, '')\n\n    assert_equal file_bytesize, form_file_data.bytesize\n    assert_equal out_r.read.bytesize, req_body.bytesize\n  end\n\n  def test_supported_http_methods_match\n    server_run(supported_http_methods: ['PROPFIND', 'PROPPATCH']) do |env|\n      body = [env['REQUEST_METHOD']]\n      [200, {}, body]\n    end\n    resp = send_http_and_read \"PROPFIND / HTTP/1.0\\r\\n\\r\\n\"\n    assert_match 'PROPFIND', resp\n  end\n\n  def test_supported_http_methods_no_match\n    server_run(supported_http_methods: ['PROPFIND', 'PROPPATCH']) do |env|\n      body = [env['REQUEST_METHOD']]\n      [200, {}, body]\n    end\n    resp = send_http_and_read \"GET / HTTP/1.0\\r\\n\\r\\n\"\n    assert_match 'Not Implemented', resp\n  end\n\n  def test_supported_http_methods_accept_all\n    server_run(supported_http_methods: :any) do |env|\n      body = [env['REQUEST_METHOD']]\n      [200, {}, body]\n    end\n    resp = send_http_and_read \"YOUR_SPECIAL_METHOD / HTTP/1.0\\r\\n\\r\\n\"\n    assert_match 'YOUR_SPECIAL_METHOD', resp\n  end\n\n  def test_supported_http_methods_empty\n    server_run(supported_http_methods: []) do |env|\n      body = [env['REQUEST_METHOD']]\n      [200, {}, body]\n    end\n    resp = send_http_and_read \"GET / HTTP/1.0\\r\\n\\r\\n\"\n    assert_match(/\\AHTTP\\/1\\.0 501 Not Implemented/, resp)\n  end\n\n\n  def spawn_cmd(env = {}, cmd)\n    opts = {}\n\n    out_r, out_w = IO.pipe\n    opts[:out] = out_w\n\n    err_r, err_w = IO.pipe\n    opts[:err] = err_w\n\n    out_r.binmode\n    err_r.binmode\n\n    pid = spawn(env, cmd, opts)\n    [out_w, err_w].each(&:close)\n    [out_r, err_r, pid]\n  end\n\n  def test_lowlevel_error_handler_response\n    options = {\n      lowlevel_error_handler: ->(_error) do\n        [500, {}, [\"something wrong happened\"]]\n      end\n    }\n    broken_app = ->(_env) { [200, nil, []] }\n\n    server_run(**options, &broken_app)\n\n    data = send_http_and_read \"GET / HTTP/1.1\\r\\n\\r\\n\"\n\n    assert_match(/something wrong happened/, data)\n  end\nend\n"], "fixing_code": ["# frozen_string_literal: true\n\nclass IO\n  # We need to use this for a jruby work around on both 1.8 and 1.9.\n  # So this either creates the constant (on 1.8), or harmlessly\n  # reopens it (on 1.9).\n  module WaitReadable\n  end\nend\n\nrequire_relative 'detect'\nrequire_relative 'io_buffer'\nrequire 'tempfile'\nrequire 'forwardable'\n\nif Puma::IS_JRUBY\n  # We have to work around some OpenSSL buffer/io-readiness bugs\n  # so we pull it in regardless of if the user is binding\n  # to an SSL socket\n  require 'openssl'\nend\n\nmodule Puma\n\n  class ConnectionError < RuntimeError; end\n\n  class HttpParserError501 < IOError; end\n\n  #\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014 DO NOT USE \u2014 this class is for internal use only \u2014\u2014\u2014\n\n\n  # An instance of this class represents a unique request from a client.\n  # For example, this could be a web request from a browser or from CURL.\n  #\n  # An instance of `Puma::Client` can be used as if it were an IO object\n  # by the reactor. The reactor is expected to call `#to_io`\n  # on any non-IO objects it polls. For example, nio4r internally calls\n  # `IO::try_convert` (which may call `#to_io`) when a new socket is\n  # registered.\n  #\n  # Instances of this class are responsible for knowing if\n  # the header and body are fully buffered via the `try_to_finish` method.\n  # They can be used to \"time out\" a response via the `timeout_at` reader.\n  #\n  class Client # :nodoc:\n\n    # this tests all values but the last, which must be chunked\n    ALLOWED_TRANSFER_ENCODING = %w[compress deflate gzip].freeze\n\n    # chunked body validation\n    CHUNK_SIZE_INVALID = /[^\\h]/.freeze\n    CHUNK_VALID_ENDING = Const::LINE_END\n    CHUNK_VALID_ENDING_SIZE = CHUNK_VALID_ENDING.bytesize\n\n    # Content-Length header value validation\n    CONTENT_LENGTH_VALUE_INVALID = /[^\\d]/.freeze\n\n    TE_ERR_MSG = 'Invalid Transfer-Encoding'\n\n    # The object used for a request with no body. All requests with\n    # no body share this one object since it has no state.\n    EmptyBody = NullIO.new\n\n    include Puma::Const\n    extend Forwardable\n\n    def initialize(io, env=nil)\n      @io = io\n      @to_io = io.to_io\n      @io_buffer = IOBuffer.new\n      @proto_env = env\n      @env = env&.dup\n\n      @parser = HttpParser.new\n      @parsed_bytes = 0\n      @read_header = true\n      @read_proxy = false\n      @ready = false\n\n      @body = nil\n      @body_read_start = nil\n      @buffer = nil\n      @tempfile = nil\n\n      @timeout_at = nil\n\n      @requests_served = 0\n      @hijacked = false\n\n      @http_content_length_limit = nil\n      @http_content_length_limit_exceeded = false\n\n      @peerip = nil\n      @peer_family = nil\n      @listener = nil\n      @remote_addr_header = nil\n      @expect_proxy_proto = false\n\n      @body_remain = 0\n\n      @in_last_chunk = false\n\n      # need unfrozen ASCII-8BIT, +'' is UTF-8\n      @read_buffer = String.new # rubocop: disable Performance/UnfreezeString\n    end\n\n    attr_reader :env, :to_io, :body, :io, :timeout_at, :ready, :hijacked,\n                :tempfile, :io_buffer, :http_content_length_limit_exceeded\n\n    attr_writer :peerip, :http_content_length_limit\n\n    attr_accessor :remote_addr_header, :listener\n\n    def_delegators :@io, :closed?\n\n    # Test to see if io meets a bare minimum of functioning, @to_io needs to be\n    # used for MiniSSL::Socket\n    def io_ok?\n      @to_io.is_a?(::BasicSocket) && !closed?\n    end\n\n    # @!attribute [r] inspect\n    def inspect\n      \"#<Puma::Client:0x#{object_id.to_s(16)} @ready=#{@ready.inspect}>\"\n    end\n\n    # For the hijack protocol (allows us to just put the Client object\n    # into the env)\n    def call\n      @hijacked = true\n      env[HIJACK_IO] ||= @io\n    end\n\n    # @!attribute [r] in_data_phase\n    def in_data_phase\n      !(@read_header || @read_proxy)\n    end\n\n    def set_timeout(val)\n      @timeout_at = Process.clock_gettime(Process::CLOCK_MONOTONIC) + val\n    end\n\n    # Number of seconds until the timeout elapses.\n    def timeout\n      [@timeout_at - Process.clock_gettime(Process::CLOCK_MONOTONIC), 0].max\n    end\n\n    def reset(fast_check=true)\n      @parser.reset\n      @io_buffer.reset\n      @read_header = true\n      @read_proxy = !!@expect_proxy_proto\n      @env = @proto_env.dup\n      @body = nil\n      @tempfile = nil\n      @parsed_bytes = 0\n      @ready = false\n      @body_remain = 0\n      @peerip = nil if @remote_addr_header\n      @in_last_chunk = false\n      @http_content_length_limit_exceeded = false\n\n      if @buffer\n        return false unless try_to_parse_proxy_protocol\n\n        @parsed_bytes = @parser.execute(@env, @buffer, @parsed_bytes)\n\n        if @parser.finished?\n          return setup_body\n        elsif @parsed_bytes >= MAX_HEADER\n          raise HttpParserError,\n            \"HEADER is longer than allowed, aborting client early.\"\n        end\n\n        return false\n      else\n        begin\n          if fast_check && @to_io.wait_readable(FAST_TRACK_KA_TIMEOUT)\n            return try_to_finish\n          end\n        rescue IOError\n          # swallow it\n        end\n\n      end\n    end\n\n    def close\n      begin\n        @io.close\n      rescue IOError, Errno::EBADF\n        Puma::Util.purge_interrupt_queue\n      end\n    end\n\n    # If necessary, read the PROXY protocol from the buffer. Returns\n    # false if more data is needed.\n    def try_to_parse_proxy_protocol\n      if @read_proxy\n        if @expect_proxy_proto == :v1\n          if @buffer.include? \"\\r\\n\"\n            if md = PROXY_PROTOCOL_V1_REGEX.match(@buffer)\n              if md[1]\n                @peerip = md[1].split(\" \")[0]\n              end\n              @buffer = md.post_match\n            end\n            # if the buffer has a \\r\\n but doesn't have a PROXY protocol\n            # request, this is just HTTP from a non-PROXY client; move on\n            @read_proxy = false\n            return @buffer.size > 0\n          else\n            return false\n          end\n        end\n      end\n      true\n    end\n\n    def try_to_finish\n      if env[CONTENT_LENGTH] && above_http_content_limit(env[CONTENT_LENGTH].to_i)\n        @http_content_length_limit_exceeded = true\n      end\n\n      if @http_content_length_limit_exceeded\n        @buffer = nil\n        @body = EmptyBody\n        set_ready\n        return true\n      end\n\n      return read_body if in_data_phase\n\n      begin\n        data = @io.read_nonblock(CHUNK_SIZE)\n      rescue IO::WaitReadable\n        return false\n      rescue EOFError\n        # Swallow error, don't log\n      rescue SystemCallError, IOError\n        raise ConnectionError, \"Connection error detected during read\"\n      end\n\n      # No data means a closed socket\n      unless data\n        @buffer = nil\n        set_ready\n        raise EOFError\n      end\n\n      if @buffer\n        @buffer << data\n      else\n        @buffer = data\n      end\n\n      return false unless try_to_parse_proxy_protocol\n\n      @parsed_bytes = @parser.execute(@env, @buffer, @parsed_bytes)\n\n      if @parser.finished? && above_http_content_limit(@parser.body.bytesize)\n        @http_content_length_limit_exceeded = true\n      end\n\n      if @parser.finished?\n        return setup_body\n      elsif @parsed_bytes >= MAX_HEADER\n        raise HttpParserError,\n          \"HEADER is longer than allowed, aborting client early.\"\n      end\n\n      false\n    end\n\n    def eagerly_finish\n      return true if @ready\n      return false unless @to_io.wait_readable(0)\n      try_to_finish\n    end\n\n    def finish(timeout)\n      return if @ready\n      @to_io.wait_readable(timeout) || timeout! until try_to_finish\n    end\n\n    def timeout!\n      write_error(408) if in_data_phase\n      raise ConnectionError\n    end\n\n    def write_error(status_code)\n      begin\n        @io << ERROR_RESPONSE[status_code]\n      rescue StandardError\n      end\n    end\n\n    def peerip\n      return @peerip if @peerip\n\n      if @remote_addr_header\n        hdr = (@env[@remote_addr_header] || @io.peeraddr.last).split(/[\\s,]/).first\n        @peerip = hdr\n        return hdr\n      end\n\n      @peerip ||= @io.peeraddr.last\n    end\n\n    def peer_family\n      return @peer_family if @peer_family\n\n      @peer_family ||= begin\n                         @io.local_address.afamily\n                       rescue\n                         Socket::AF_INET\n                       end\n    end\n\n    # Returns true if the persistent connection can be closed immediately\n    # without waiting for the configured idle/shutdown timeout.\n    # @version 5.0.0\n    #\n    def can_close?\n      # Allow connection to close if we're not in the middle of parsing a request.\n      @parsed_bytes == 0\n    end\n\n    def expect_proxy_proto=(val)\n      if val\n        if @read_header\n          @read_proxy = true\n        end\n      else\n        @read_proxy = false\n      end\n      @expect_proxy_proto = val\n    end\n\n    private\n\n    def setup_body\n      @body_read_start = Process.clock_gettime(Process::CLOCK_MONOTONIC, :float_millisecond)\n\n      if @env[HTTP_EXPECT] == CONTINUE\n        # TODO allow a hook here to check the headers before\n        # going forward\n        @io << HTTP_11_100\n        @io.flush\n      end\n\n      @read_header = false\n\n      body = @parser.body\n\n      te = @env[TRANSFER_ENCODING2]\n      if te\n        te_lwr = te.downcase\n        if te.include? ','\n          te_ary = te_lwr.split ','\n          te_count = te_ary.count CHUNKED\n          te_valid = te_ary[0..-2].all? { |e| ALLOWED_TRANSFER_ENCODING.include? e }\n          if te_ary.last == CHUNKED && te_count == 1 && te_valid\n            @env.delete TRANSFER_ENCODING2\n            return setup_chunked_body body\n          elsif te_count >= 1\n            raise HttpParserError   , \"#{TE_ERR_MSG}, multiple chunked: '#{te}'\"\n          elsif !te_valid\n            raise HttpParserError501, \"#{TE_ERR_MSG}, unknown value: '#{te}'\"\n          end\n        elsif te_lwr == CHUNKED\n          @env.delete TRANSFER_ENCODING2\n          return setup_chunked_body body\n        elsif ALLOWED_TRANSFER_ENCODING.include? te_lwr\n          raise HttpParserError     , \"#{TE_ERR_MSG}, single value must be chunked: '#{te}'\"\n        else\n          raise HttpParserError501  , \"#{TE_ERR_MSG}, unknown value: '#{te}'\"\n        end\n      end\n\n      @chunked_body = false\n\n      cl = @env[CONTENT_LENGTH]\n\n      if cl\n        # cannot contain characters that are not \\d, or be empty\n        if CONTENT_LENGTH_VALUE_INVALID.match?(cl) || cl.empty?\n          raise HttpParserError, \"Invalid Content-Length: #{cl.inspect}\"\n        end\n      else\n        @buffer = body.empty? ? nil : body\n        @body = EmptyBody\n        set_ready\n        return true\n      end\n\n      remain = cl.to_i - body.bytesize\n\n      if remain <= 0\n        @body = StringIO.new(body)\n        @buffer = nil\n        set_ready\n        return true\n      end\n\n      if remain > MAX_BODY\n        @body = Tempfile.new(Const::PUMA_TMP_BASE)\n        @body.unlink\n        @body.binmode\n        @tempfile = @body\n      else\n        # The body[0,0] trick is to get an empty string in the same\n        # encoding as body.\n        @body = StringIO.new body[0,0]\n      end\n\n      @body.write body\n\n      @body_remain = remain\n\n      false\n    end\n\n    def read_body\n      if @chunked_body\n        return read_chunked_body\n      end\n\n      # Read an odd sized chunk so we can read even sized ones\n      # after this\n      remain = @body_remain\n\n      if remain > CHUNK_SIZE\n        want = CHUNK_SIZE\n      else\n        want = remain\n      end\n\n      begin\n        chunk = @io.read_nonblock(want, @read_buffer)\n      rescue IO::WaitReadable\n        return false\n      rescue SystemCallError, IOError\n        raise ConnectionError, \"Connection error detected during read\"\n      end\n\n      # No chunk means a closed socket\n      unless chunk\n        @body.close\n        @buffer = nil\n        set_ready\n        raise EOFError\n      end\n\n      remain -= @body.write(chunk)\n\n      if remain <= 0\n        @body.rewind\n        @buffer = nil\n        set_ready\n        return true\n      end\n\n      @body_remain = remain\n\n      false\n    end\n\n    def read_chunked_body\n      while true\n        begin\n          chunk = @io.read_nonblock(4096, @read_buffer)\n        rescue IO::WaitReadable\n          return false\n        rescue SystemCallError, IOError\n          raise ConnectionError, \"Connection error detected during read\"\n        end\n\n        # No chunk means a closed socket\n        unless chunk\n          @body.close\n          @buffer = nil\n          set_ready\n          raise EOFError\n        end\n\n        if decode_chunk(chunk)\n          @env[CONTENT_LENGTH] = @chunked_content_length.to_s\n          return true\n        end\n      end\n    end\n\n    def setup_chunked_body(body)\n      @chunked_body = true\n      @partial_part_left = 0\n      @prev_chunk = \"\"\n\n      @body = Tempfile.new(Const::PUMA_TMP_BASE)\n      @body.unlink\n      @body.binmode\n      @tempfile = @body\n      @chunked_content_length = 0\n\n      if decode_chunk(body)\n        @env[CONTENT_LENGTH] = @chunked_content_length.to_s\n        return true\n      end\n    end\n\n    # @version 5.0.0\n    def write_chunk(str)\n      @chunked_content_length += @body.write(str)\n    end\n\n    def decode_chunk(chunk)\n      if @partial_part_left > 0\n        if @partial_part_left <= chunk.size\n          if @partial_part_left > 2\n            write_chunk(chunk[0..(@partial_part_left-3)]) # skip the \\r\\n\n          end\n          chunk = chunk[@partial_part_left..-1]\n          @partial_part_left = 0\n        else\n          if @partial_part_left > 2\n            if @partial_part_left == chunk.size + 1\n              # Don't include the last \\r\n              write_chunk(chunk[0..(@partial_part_left-3)])\n            else\n              # don't include the last \\r\\n\n              write_chunk(chunk)\n            end\n          end\n          @partial_part_left -= chunk.size\n          return false\n        end\n      end\n\n      if @prev_chunk.empty?\n        io = StringIO.new(chunk)\n      else\n        io = StringIO.new(@prev_chunk+chunk)\n        @prev_chunk = \"\"\n      end\n\n      while !io.eof?\n        line = io.gets\n        if line.end_with?(CHUNK_VALID_ENDING)\n          # Puma doesn't process chunk extensions, but should parse if they're\n          # present, which is the reason for the semicolon regex\n          chunk_hex = line.strip[/\\A[^;]+/]\n          if CHUNK_SIZE_INVALID.match? chunk_hex\n            raise HttpParserError, \"Invalid chunk size: '#{chunk_hex}'\"\n          end\n          len = chunk_hex.to_i(16)\n          if len == 0\n            @in_last_chunk = true\n            @body.rewind\n            rest = io.read\n            if rest.bytesize < CHUNK_VALID_ENDING_SIZE\n              @buffer = nil\n              @partial_part_left = CHUNK_VALID_ENDING_SIZE - rest.bytesize\n              return false\n            else\n              # if the next character is a CRLF, set buffer to everything after that CRLF\n              start_of_rest = if rest.start_with?(CHUNK_VALID_ENDING)\n                CHUNK_VALID_ENDING_SIZE\n              else # we have started a trailer section, which we do not support. skip it!\n                rest.index(CHUNK_VALID_ENDING*2) + CHUNK_VALID_ENDING_SIZE*2\n              end\n\n              @buffer = rest[start_of_rest..-1]\n              @buffer = nil if @buffer.empty?\n              set_ready\n              return true\n            end\n          end\n\n          len += 2\n\n          part = io.read(len)\n\n          unless part\n            @partial_part_left = len\n            next\n          end\n\n          got = part.size\n\n          case\n          when got == len\n            # proper chunked segment must end with \"\\r\\n\"\n            if part.end_with? CHUNK_VALID_ENDING\n              write_chunk(part[0..-3]) # to skip the ending \\r\\n\n            else\n              raise HttpParserError, \"Chunk size mismatch\"\n            end\n          when got <= len - 2\n            write_chunk(part)\n            @partial_part_left = len - part.size\n          when got == len - 1 # edge where we get just \\r but not \\n\n            write_chunk(part[0..-2])\n            @partial_part_left = len - part.size\n          end\n        else\n          @prev_chunk = line\n          return false\n        end\n      end\n\n      if @in_last_chunk\n        set_ready\n        true\n      else\n        false\n      end\n    end\n\n    def set_ready\n      if @body_read_start\n        @env['puma.request_body_wait'] = Process.clock_gettime(Process::CLOCK_MONOTONIC, :float_millisecond) - @body_read_start\n      end\n      @requests_served += 1\n      @ready = true\n    end\n\n    def above_http_content_limit(value)\n      @http_content_length_limit&.< value\n    end\n  end\nend\n", "require_relative \"helper\"\nrequire \"puma/events\"\nrequire \"puma/server\"\nrequire \"net/http\"\nrequire \"nio\"\nrequire \"ipaddr\"\n\nclass WithoutBacktraceError < StandardError\n  def backtrace; nil; end\n  def message; \"no backtrace error\"; end\nend\n\nclass TestPumaServer < Minitest::Test\n  parallelize_me!\n\n  STATUS_CODES = ::Puma::HTTP_STATUS_CODES\n\n  def setup\n    @host = \"127.0.0.1\"\n\n    @ios = []\n\n    @app = ->(env) { [200, {}, [env['rack.url_scheme']]] }\n\n    @log_writer = Puma::LogWriter.strings\n    @events = Puma::Events.new\n    @server = Puma::Server.new @app, @events, {log_writer: @log_writer}\n  end\n\n  def teardown\n    @server.stop(true)\n    # Errno::EBADF raised on macOS\n    @ios.each do |io|\n      begin\n        io.close if io.respond_to?(:close) && !io.closed?\n        File.unlink io.path if io.is_a? File\n      rescue Errno::EBADF\n      ensure\n        io = nil\n      end\n    end\n  end\n\n  def server_run(**options, &block)\n    options[:log_writer]  ||= @log_writer\n    options[:min_threads] ||= 1\n    @server = Puma::Server.new block || @app, @events, options\n    @port = (@server.add_tcp_listener @host, 0).addr[1]\n    @server.run\n  end\n\n  def header(sock)\n    header = []\n    while true\n      line = sock.gets\n      break if line == \"\\r\\n\"\n      header << line.strip\n    end\n\n    header\n  end\n\n  # only for shorter bodies!\n  def send_http_and_sysread(req)\n    send_http(req).sysread 2_048\n  end\n\n  def send_http_and_read(req)\n    send_http(req).read\n  end\n\n  def send_http(req)\n    new_connection << req\n  end\n\n  def send_proxy_v1_http(req, remote_ip, multisend = false)\n    addr = IPAddr.new(remote_ip)\n    family = addr.ipv4? ? \"TCP4\" : \"TCP6\"\n    target = addr.ipv4? ? \"127.0.0.1\" : \"::1\"\n    conn = new_connection\n    if multisend\n      conn << \"PROXY #{family} #{remote_ip} #{target} 10000 80\\r\\n\"\n      sleep 0.15\n      conn << req\n    else\n      conn << (\"PROXY #{family} #{remote_ip} #{target} 10000 80\\r\\n\" + req)\n    end\n  end\n\n  def new_connection\n    TCPSocket.new(@host, @port).tap {|sock| @ios << sock}\n  end\n\n  def test_normalize_host_header_missing\n    server_run do |env|\n      [200, {}, [env[\"SERVER_NAME\"], \"\\n\", env[\"SERVER_PORT\"]]]\n    end\n\n    data = send_http_and_read \"GET / HTTP/1.0\\r\\n\\r\\n\"\n    assert_equal \"localhost\\n80\", data.split(\"\\r\\n\").last\n  end\n\n  def test_normalize_host_header_hostname\n    server_run do |env|\n      [200, {}, [env[\"SERVER_NAME\"], \"\\n\", env[\"SERVER_PORT\"]]]\n    end\n\n    data = send_http_and_read \"GET / HTTP/1.0\\r\\nHost: example.com:456\\r\\n\\r\\n\"\n    assert_equal \"example.com\\n456\", data.split(\"\\r\\n\").last\n\n    data = send_http_and_read \"GET / HTTP/1.0\\r\\nHost: example.com\\r\\n\\r\\n\"\n    assert_equal \"example.com\\n80\", data.split(\"\\r\\n\").last\n  end\n\n  def test_normalize_host_header_ipv4\n    server_run do |env|\n      [200, {}, [env[\"SERVER_NAME\"], \"\\n\", env[\"SERVER_PORT\"]]]\n    end\n\n    data = send_http_and_read \"GET / HTTP/1.0\\r\\nHost: 123.123.123.123:456\\r\\n\\r\\n\"\n    assert_equal \"123.123.123.123\\n456\", data.split(\"\\r\\n\").last\n\n    data = send_http_and_read \"GET / HTTP/1.0\\r\\nHost: 123.123.123.123\\r\\n\\r\\n\"\n    assert_equal \"123.123.123.123\\n80\", data.split(\"\\r\\n\").last\n  end\n\n  def test_normalize_host_header_ipv6\n    server_run do |env|\n      [200, {}, [env[\"SERVER_NAME\"], \"\\n\", env[\"SERVER_PORT\"]]]\n    end\n\n    data = send_http_and_read \"GET / HTTP/1.0\\r\\nHost: [::ffff:127.0.0.1]:9292\\r\\n\\r\\n\"\n    assert_equal \"[::ffff:127.0.0.1]\\n9292\", data.split(\"\\r\\n\").last\n\n    data = send_http_and_read \"GET / HTTP/1.0\\r\\nHost: [::1]:9292\\r\\n\\r\\n\"\n    assert_equal \"[::1]\\n9292\", data.split(\"\\r\\n\").last\n\n    data = send_http_and_read \"GET / HTTP/1.0\\r\\nHost: [::1]\\r\\n\\r\\n\"\n    assert_equal \"[::1]\\n80\", data.split(\"\\r\\n\").last\n  end\n\n  def test_streaming_body\n    server_run do |env|\n      body = lambda do |stream|\n        stream.write(\"Hello World\")\n        stream.close\n      end\n\n      [200, {}, body]\n    end\n\n    data = send_http_and_read \"GET / HTTP/1.0\\r\\nConnection: close\\r\\n\\r\\n\"\n\n    assert_equal \"Hello World\", data.split(\"\\r\\n\\r\\n\", 2).last\n  end\n\n  def test_file_body\n    random_bytes = SecureRandom.random_bytes(4096 * 32)\n\n    tf = tempfile_create(\"test_file_body\", random_bytes)\n\n    server_run { |env| [200, {}, tf] }\n\n    data = +''\n    skt = send_http(\"GET / HTTP/1.1\\r\\nHost: [::ffff:127.0.0.1]:#{@port}\\r\\n\\r\\n\")\n    data << skt.sysread(65_536) while skt.wait_readable(0.1)\n\n    ary = data.split(\"\\r\\n\\r\\n\", 2)\n\n    assert_equal random_bytes.bytesize, ary.last.bytesize\n    assert_equal random_bytes, ary.last\n  ensure\n    tf.close\n  end\n\n  def test_file_to_path\n    random_bytes = SecureRandom.random_bytes(4096 * 32)\n\n    tf = tempfile_create(\"test_file_to_path\", random_bytes)\n    path = tf.path\n\n    obj = Object.new\n    obj.singleton_class.send(:define_method, :to_path) { path }\n    obj.singleton_class.send(:define_method, :each) { path } # dummy, method needs to exist\n\n    server_run { |env| [200, {}, obj] }\n\n    data = +''\n    skt = send_http(\"GET / HTTP/1.1\\r\\nHost: [::ffff:127.0.0.1]:#{@port}\\r\\n\\r\\n\")\n    data << skt.sysread(65_536) while skt.wait_readable(0.1)\n    ary = data.split(\"\\r\\n\\r\\n\", 2)\n\n    assert_equal random_bytes.bytesize, ary.last.bytesize\n    assert_equal random_bytes, ary.last\n  ensure\n    tf.close\n  end\n\n  def test_proper_stringio_body\n    data = nil\n\n    server_run do |env|\n      data = env['rack.input'].read\n      [200, {}, [\"ok\"]]\n    end\n\n    fifteen = \"1\" * 15\n\n    sock = send_http \"PUT / HTTP/1.0\\r\\nContent-Length: 30\\r\\n\\r\\n#{fifteen}\"\n\n    sleep 0.1 # important so that the previous data is sent as a packet\n    sock << fifteen\n\n    sock.read\n\n    assert_equal \"#{fifteen}#{fifteen}\", data\n  end\n\n  def test_puma_socket\n    body = \"HTTP/1.1 750 Upgraded to Awesome\\r\\nDone: Yep!\\r\\n\"\n    server_run do |env|\n      io = env['puma.socket']\n      io.write body\n      io.close\n      [-1, {}, []]\n    end\n\n    data = send_http_and_read \"PUT / HTTP/1.0\\r\\n\\r\\nHello\"\n\n    assert_equal body, data\n  end\n\n  def test_very_large_return\n    giant = \"x\" * 2056610\n\n    server_run do\n      [200, {}, [giant]]\n    end\n\n    sock = send_http \"GET / HTTP/1.0\\r\\n\\r\\n\"\n\n    while true\n      line = sock.gets\n      break if line == \"\\r\\n\"\n    end\n\n    out = sock.read\n\n    assert_equal giant.bytesize, out.bytesize\n  end\n\n  def test_respect_x_forwarded_proto\n    env = {}\n    env['HOST'] = \"example.com\"\n    env['HTTP_X_FORWARDED_PROTO'] = \"https,http\"\n\n    assert_equal \"443\", @server.default_server_port(env)\n  end\n\n  def test_respect_x_forwarded_ssl_on\n    env = {}\n    env['HOST'] = 'example.com'\n    env['HTTP_X_FORWARDED_SSL'] = 'on'\n\n    assert_equal \"443\", @server.default_server_port(env)\n  end\n\n  def test_respect_x_forwarded_scheme\n    env = {}\n    env['HOST'] = 'example.com'\n    env['HTTP_X_FORWARDED_SCHEME'] = 'https'\n\n    assert_equal '443', @server.default_server_port(env)\n  end\n\n  def test_default_server_port\n    server_run do |env|\n      [200, {}, [env['SERVER_PORT']]]\n    end\n\n    req = Net::HTTP::Get.new '/'\n    req['HOST'] = 'example.com'\n\n    res = Net::HTTP.start @host, @port do |http|\n      http.request(req)\n    end\n\n    assert_equal \"80\", res.body\n  end\n\n  def test_default_server_port_respects_x_forwarded_proto\n    server_run do |env|\n      [200, {}, [env['SERVER_PORT']]]\n    end\n\n    req = Net::HTTP::Get.new(\"/\")\n    req['HOST'] = \"example.com\"\n    req['X-FORWARDED-PROTO'] = \"https,http\"\n\n    res = Net::HTTP.start @host, @port do |http|\n      http.request(req)\n    end\n\n    assert_equal \"443\", res.body\n  end\n\n  def test_HEAD_has_no_body\n    server_run { [200, {\"Foo\" => \"Bar\"}, [\"hello\"]] }\n\n    data = send_http_and_read \"HEAD / HTTP/1.0\\r\\n\\r\\n\"\n\n    assert_equal \"HTTP/1.0 200 OK\\r\\nFoo: Bar\\r\\nContent-Length: 5\\r\\n\\r\\n\", data\n  end\n\n  def test_GET_with_empty_body_has_sane_chunking\n    server_run { [200, {}, [\"\"]] }\n\n    data = send_http_and_read \"HEAD / HTTP/1.0\\r\\n\\r\\n\"\n\n    assert_equal \"HTTP/1.0 200 OK\\r\\nContent-Length: 0\\r\\n\\r\\n\", data\n  end\n\n  def test_early_hints_works\n    server_run(early_hints: true) do |env|\n     env['rack.early_hints'].call(\"Link\" => \"</style.css>; rel=preload; as=style\\n</script.js>; rel=preload\")\n     [200, { \"X-Hello\" => \"World\" }, [\"Hello world!\"]]\n    end\n\n    data = send_http_and_read \"HEAD / HTTP/1.0\\r\\n\\r\\n\"\n\n    expected_data = <<~EOF.gsub(\"\\n\", \"\\r\\n\") + \"\\r\\n\"\n      HTTP/1.1 103 Early Hints\n      Link: </style.css>; rel=preload; as=style\n      Link: </script.js>; rel=preload\n\n      HTTP/1.0 200 OK\n      X-Hello: World\n      Content-Length: 12\n    EOF\n\n    assert_equal true, @server.early_hints\n    assert_equal expected_data, data\n  end\n\n  def test_early_hints_are_ignored_if_connection_lost\n\n    server_run(early_hints: true) do |env|\n      env['rack.early_hints'].call(\"Link\" => \"</script.js>; rel=preload\")\n      [200, { \"X-Hello\" => \"World\" }, [\"Hello world!\"]]\n    end\n\n    def @server.fast_write(*args)\n      raise Puma::ConnectionError\n    end\n\n    # This request will cause the server to try and send early hints\n    _ = send_http \"HEAD / HTTP/1.0\\r\\n\\r\\n\"\n\n    # Give the server some time to try to write (and fail)\n    sleep 0.1\n\n    # Expect no errors in stderr\n    assert @log_writer.stderr.pos.zero?, \"Server didn't swallow the connection error\"\n  end\n\n  def test_early_hints_is_off_by_default\n    server_run do |env|\n     assert_nil env['rack.early_hints']\n     [200, { \"X-Hello\" => \"World\" }, [\"Hello world!\"]]\n    end\n\n    data = send_http_and_read \"HEAD / HTTP/1.0\\r\\n\\r\\n\"\n\n    expected_data = <<~EOF.gsub(\"\\n\", \"\\r\\n\") + \"\\r\\n\"\n      HTTP/1.0 200 OK\n      X-Hello: World\n      Content-Length: 12\n    EOF\n\n    assert_nil @server.early_hints\n    assert_equal expected_data, data\n  end\n\n  def test_request_payload_too_large\n    server_run(http_content_length_limit: 10)\n\n    sock = send_http \"POST / HTTP/1.1\\r\\nHost: test.com\\r\\nContent-Type: text/plain\\r\\nContent-Length: 19\\r\\n\\r\\n\"\n    sock << \"hello world foo bar\"\n\n    data = sock.gets\n\n    # Content Too Large\n    assert_equal \"HTTP/1.1 413 #{STATUS_CODES[413]}\\r\\n\", data\n  end\n\n  def test_http_11_keep_alive_with_large_payload\n    server_run(http_content_length_limit: 10) { [204, {}, []] }\n\n    sock = send_http \"GET / HTTP/1.1\\r\\nConnection: Keep-Alive\\r\\nContent-Length: 17\\r\\n\\r\\n\"\n    sock << \"hello world foo bar\"\n    h = header sock\n\n    # Content Too Large\n    assert_equal [\"HTTP/1.1 413 #{STATUS_CODES[413]}\", \"Content-Length: 17\"], h\n\n  end\n\n  def test_GET_with_no_body_has_sane_chunking\n    server_run { [200, {}, []] }\n\n    data = send_http_and_read \"HEAD / HTTP/1.0\\r\\n\\r\\n\"\n\n    assert_equal \"HTTP/1.0 200 OK\\r\\nContent-Length: 0\\r\\n\\r\\n\", data\n  end\n\n  def test_doesnt_print_backtrace_in_production\n    server_run(environment: :production) { raise \"don't leak me bro\" }\n\n    data = send_http_and_read \"GET / HTTP/1.0\\r\\n\\r\\n\"\n\n    refute_match(/don't leak me bro/, data)\n    assert_match(/HTTP\\/1.0 500 Internal Server Error/, data)\n  end\n\n  def test_eof_on_connection_close_is_not_logged_as_an_error\n    server_run\n\n    new_connection.close # Make a connection and close without writing\n\n    @server.stop(true)\n    stderr = @log_writer.stderr.string\n    assert stderr.empty?, \"Expected stderr from server to be empty but it was #{stderr.inspect}\"\n  end\n\n  def test_force_shutdown_custom_error_message\n    handler = lambda {|err, env, status| [500, {\"Content-Type\" => \"application/json\"}, [\"{}\\n\"]]}\n    server_run(lowlevel_error_handler: handler, force_shutdown_after: 2) do\n      @server.stop\n      sleep 5\n    end\n\n    data = send_http_and_read \"GET / HTTP/1.0\\r\\n\\r\\n\"\n\n    assert_match(/HTTP\\/1.0 500 Internal Server Error/, data)\n    assert_match(/Content-Type: application\\/json/, data)\n    assert_match(/{}\\n$/, data)\n  end\n\n  class ArrayClose < Array\n    attr_reader :is_closed\n    def closed?\n      @is_closed\n    end\n\n    def close\n      @is_closed = true\n    end\n  end\n\n  # returns status as an array, which throws lowlevel error\n  def test_lowlevel_error_body_close\n    app_body = ArrayClose.new(['lowlevel_error'])\n\n    server_run(log_writer: @log_writer, :force_shutdown_after => 2) do\n      [[0,1], {}, app_body]\n    end\n\n    data = send_http_and_sysread \"GET / HTTP/1.0\\r\\n\\r\\n\"\n\n    assert_includes data, 'HTTP/1.0 500 Internal Server Error'\n    assert_includes data, \"Puma caught this error: undefined method `to_i' for\"\n    assert_includes data, \"Array\"\n    refute_includes data, 'lowlevel_error'\n    sleep 0.1 unless ::Puma::IS_MRI\n    assert app_body.closed?\n  end\n\n  def test_lowlevel_error_message\n    server_run(log_writer: @log_writer, :force_shutdown_after => 2) do\n      raise NoMethodError, \"Oh no an error\"\n    end\n\n    data = send_http_and_sysread \"GET / HTTP/1.0\\r\\n\\r\\n\"\n\n    # Internal Server Error\n    assert_includes data, \"HTTP/1.0 500 #{STATUS_CODES[500]}\"\n    assert_match(/Puma caught this error: Oh no an error.*\\(NoMethodError\\).*test\\/test_puma_server.rb/m, data)\n  end\n\n  def test_lowlevel_error_message_without_backtrace\n    server_run(log_writer: @log_writer, :force_shutdown_after => 2) do\n      raise WithoutBacktraceError.new\n    end\n\n    data = send_http_and_sysread \"GET / HTTP/1.1\\r\\n\\r\\n\"\n    # Internal Server Error\n    assert_includes data, \"HTTP/1.1 500 #{STATUS_CODES[500]}\"\n    assert_includes data, 'Puma caught this error: no backtrace error (WithoutBacktraceError)'\n    assert_includes data, '<no backtrace available>'\n  end\n\n  def test_force_shutdown_error_default\n    server_run(force_shutdown_after: 2) do\n      @server.stop\n      sleep 5\n    end\n\n    data = send_http_and_read \"GET / HTTP/1.0\\r\\n\\r\\n\"\n\n    assert_match(/HTTP\\/1.0 503 Service Unavailable/, data)\n    assert_match(/Puma caught this error.+Puma::ThreadPool::ForceShutdown/, data)\n  end\n\n  def test_prints_custom_error\n    re = lambda { |err| [302, {'Content-Type' => 'text', 'Location' => 'foo.html'}, ['302 found']] }\n    server_run(lowlevel_error_handler: re) { raise \"don't leak me bro\" }\n\n    data = send_http_and_read \"GET / HTTP/1.0\\r\\n\\r\\n\"\n\n    assert_match(/HTTP\\/1.0 302 Found/, data)\n  end\n\n  def test_leh_gets_env_as_well\n    re = lambda { |err,env|\n      env['REQUEST_PATH'] || raise('where is env?')\n      [302, {'Content-Type' => 'text', 'Location' => 'foo.html'}, ['302 found']]\n    }\n\n    server_run(lowlevel_error_handler: re) { raise \"don't leak me bro\" }\n\n    data = send_http_and_read \"GET / HTTP/1.0\\r\\n\\r\\n\"\n\n    assert_match(/HTTP\\/1.0 302 Found/, data)\n  end\n\n  def test_leh_has_status\n    re = lambda { |err, env, status|\n      raise \"Cannot find status\" unless status\n      [302, {'Content-Type' => 'text', 'Location' => 'foo.html'}, ['302 found']]\n    }\n\n    server_run(lowlevel_error_handler: re) { raise \"don't leak me bro\" }\n\n    data = send_http_and_read \"GET / HTTP/1.0\\r\\n\\r\\n\"\n\n    assert_match(/HTTP\\/1.0 302 Found/, data)\n  end\n\n  def test_custom_http_codes_10\n    server_run { [449, {}, [\"\"]] }\n\n    data = send_http_and_read \"GET / HTTP/1.0\\r\\n\\r\\n\"\n\n    assert_equal \"HTTP/1.0 449 CUSTOM\\r\\nContent-Length: 0\\r\\n\\r\\n\", data\n  end\n\n  def test_custom_http_codes_11\n    server_run { [449, {}, [\"\"]] }\n\n    data = send_http_and_read \"GET / HTTP/1.1\\r\\nConnection: close\\r\\n\\r\\n\"\n\n    assert_equal \"HTTP/1.1 449 CUSTOM\\r\\nConnection: close\\r\\nContent-Length: 0\\r\\n\\r\\n\", data\n  end\n\n  def test_HEAD_returns_content_headers\n    server_run { [200, {\"Content-Type\" => \"application/pdf\",\n                                     \"Content-Length\" => \"4242\"}, []] }\n\n    data = send_http_and_read \"HEAD / HTTP/1.0\\r\\n\\r\\n\"\n\n    assert_equal \"HTTP/1.0 200 OK\\r\\nContent-Type: application/pdf\\r\\nContent-Length: 4242\\r\\n\\r\\n\", data\n  end\n\n  def test_status_hook_fires_when_server_changes_states\n\n    states = []\n\n    @events.register(:state) { |s| states << s }\n\n    server_run { [200, {}, [\"\"]] }\n\n    _ = send_http_and_read \"HEAD / HTTP/1.0\\r\\n\\r\\n\"\n\n    assert_equal [:booting, :running], states\n\n    @server.stop(true)\n\n    assert_equal [:booting, :running, :stop, :done], states\n  end\n\n  def test_timeout_in_data_phase(**options)\n    server_run(first_data_timeout: 1, **options)\n\n    sock = send_http \"POST / HTTP/1.1\\r\\nHost: test.com\\r\\nContent-Type: text/plain\\r\\nContent-Length: 5\\r\\n\\r\\n\"\n\n    sock << \"Hello\" unless sock.wait_readable(1.15)\n\n    data = sock.gets\n\n    # Request Timeout\n    assert_equal \"HTTP/1.1 408 #{STATUS_CODES[408]}\\r\\n\", data\n  end\n\n  def test_timeout_data_no_queue\n    test_timeout_in_data_phase(queue_requests: false)\n  end\n\n  # https://github.com/puma/puma/issues/2574\n  def test_no_timeout_after_data_received\n    @server.instance_variable_set(:@first_data_timeout, 1)\n    server_run\n\n    sock = send_http \"POST / HTTP/1.1\\r\\nHost: test.com\\r\\nContent-Type: text/plain\\r\\nContent-Length: 11\\r\\n\\r\\n\"\n    sleep 0.5\n\n    sock << \"hello\"\n    sleep 0.5\n    sock << \"world\"\n    sleep 0.5\n    sock << \"!\"\n\n    data = sock.gets\n\n    assert_equal \"HTTP/1.1 200 OK\\r\\n\", data\n  end\n\n  def test_no_timeout_after_data_received_no_queue\n    @server = Puma::Server.new @app, @events, {log_writer: @log_writer, queue_requests: false}\n    test_no_timeout_after_data_received\n  end\n\n  def test_http_11_keep_alive_with_body\n    server_run { [200, {\"Content-Type\" => \"plain/text\"}, [\"hello\\n\"]] }\n\n    sock = send_http \"GET / HTTP/1.1\\r\\nConnection: Keep-Alive\\r\\n\\r\\n\"\n\n    h = header sock\n\n    body = sock.gets\n\n    assert_equal [\"HTTP/1.1 200 OK\", \"Content-Type: plain/text\", \"Content-Length: 6\"], h\n    assert_equal \"hello\\n\", body\n\n    sock.close\n  end\n\n  def test_http_11_close_with_body\n    server_run { [200, {\"Content-Type\" => \"plain/text\"}, [\"hello\"]] }\n\n    data = send_http_and_read \"GET / HTTP/1.1\\r\\nConnection: close\\r\\n\\r\\n\"\n\n    assert_equal \"HTTP/1.1 200 OK\\r\\nContent-Type: plain/text\\r\\nConnection: close\\r\\nContent-Length: 5\\r\\n\\r\\nhello\", data\n  end\n\n  def test_http_11_keep_alive_without_body\n    server_run { [204, {}, []] }\n\n    sock = send_http \"GET / HTTP/1.1\\r\\nConnection: Keep-Alive\\r\\n\\r\\n\"\n\n    h = header sock\n\n    # No Content\n    assert_equal [\"HTTP/1.1 204 #{STATUS_CODES[204]}\"], h\n  end\n\n  def test_http_11_close_without_body\n    server_run { [204, {}, []] }\n\n    sock = send_http \"GET / HTTP/1.1\\r\\nConnection: close\\r\\n\\r\\n\"\n\n    h = header sock\n\n    # No Content\n    assert_equal [\"HTTP/1.1 204 #{STATUS_CODES[204]}\", \"Connection: close\"], h\n  end\n\n  def test_http_10_keep_alive_with_body\n    server_run { [200, {\"Content-Type\" => \"plain/text\"}, [\"hello\\n\"]] }\n\n    sock = send_http \"GET / HTTP/1.0\\r\\nConnection: Keep-Alive\\r\\n\\r\\n\"\n\n    h = header sock\n\n    body = sock.gets\n\n    assert_equal [\"HTTP/1.0 200 OK\", \"Content-Type: plain/text\", \"Connection: Keep-Alive\", \"Content-Length: 6\"], h\n    assert_equal \"hello\\n\", body\n  end\n\n  def test_http_10_close_with_body\n    server_run { [200, {\"Content-Type\" => \"plain/text\"}, [\"hello\"]] }\n\n    data = send_http_and_read \"GET / HTTP/1.0\\r\\nConnection: close\\r\\n\\r\\n\"\n\n    assert_equal \"HTTP/1.0 200 OK\\r\\nContent-Type: plain/text\\r\\nContent-Length: 5\\r\\n\\r\\nhello\", data\n  end\n\n  def test_http_10_keep_alive_without_body\n    server_run { [204, {}, []] }\n\n    sock = send_http \"GET / HTTP/1.0\\r\\nConnection: Keep-Alive\\r\\n\\r\\n\"\n\n    h = header sock\n\n    assert_equal [\"HTTP/1.0 204 No Content\", \"Connection: Keep-Alive\"], h\n  end\n\n  def test_http_10_close_without_body\n    server_run { [204, {}, []] }\n\n    data = send_http_and_read \"GET / HTTP/1.0\\r\\nConnection: close\\r\\n\\r\\n\"\n\n    assert_equal \"HTTP/1.0 204 No Content\\r\\n\\r\\n\", data\n  end\n\n  def test_Expect_100\n    server_run { [200, {}, [\"\"]] }\n\n    data = send_http_and_read \"GET / HTTP/1.1\\r\\nConnection: close\\r\\nExpect: 100-continue\\r\\n\\r\\n\"\n\n    assert_equal \"HTTP/1.1 100 Continue\\r\\n\\r\\nHTTP/1.1 200 OK\\r\\nConnection: close\\r\\nContent-Length: 0\\r\\n\\r\\n\", data\n  end\n\n  def test_chunked_request\n    body = nil\n    content_length = nil\n    transfer_encoding = nil\n    server_run { |env|\n      body = env['rack.input'].read\n      content_length = env['CONTENT_LENGTH']\n      transfer_encoding = env['HTTP_TRANSFER_ENCODING']\n      [200, {}, [\"\"]]\n    }\n\n    data = send_http_and_read \"GET / HTTP/1.1\\r\\nConnection: close\\r\\nTransfer-Encoding: gzip,chunked\\r\\n\\r\\n1\\r\\nh\\r\\n4\\r\\nello\\r\\n0\\r\\n\\r\\n\"\n\n    assert_equal \"HTTP/1.1 200 OK\\r\\nConnection: close\\r\\nContent-Length: 0\\r\\n\\r\\n\", data\n    assert_equal \"hello\", body\n    assert_equal \"5\", content_length\n    assert_nil transfer_encoding\n  end\n\n  def test_large_chunked_request\n    body = nil\n    content_length = nil\n    server_run { |env|\n      body = env['rack.input'].read\n      content_length = env['CONTENT_LENGTH']\n      [200, {}, [\"\"]]\n    }\n\n    header = \"GET / HTTP/1.1\\r\\nConnection: close\\r\\nContent-Length: 200\\r\\nTransfer-Encoding: chunked\\r\\n\\r\\n\"\n\n    chunk_header_size = 6 # 4fb8\\r\\n\n    # Current implementation reads one chunk of CHUNK_SIZE, then more chunks of size 4096.\n    # We want a chunk to split exactly after \"#{request_body}\\r\", before the \"\\n\".\n    edge_case_size = Puma::Const::CHUNK_SIZE + 4096 - header.size - chunk_header_size - 1\n\n    margin = 0 # 0 for only testing this specific case, increase to test more surrounding sizes\n    (-margin..margin).each do |i|\n      size = edge_case_size + i\n      request_body = '.' * size\n      request = \"#{header}#{size.to_s(16)}\\r\\n#{request_body}\\r\\n0\\r\\n\\r\\n\"\n\n      data = send_http_and_read request\n\n      assert_equal \"HTTP/1.1 200 OK\\r\\nConnection: close\\r\\nContent-Length: 0\\r\\n\\r\\n\", data\n      assert_equal size, Integer(content_length)\n      assert_equal request_body, body\n    end\n  end\n\n  def test_chunked_request_pause_before_value\n    body = nil\n    content_length = nil\n    server_run { |env|\n      body = env['rack.input'].read\n      content_length = env['CONTENT_LENGTH']\n      [200, {}, [\"\"]]\n    }\n\n    sock = send_http \"GET / HTTP/1.1\\r\\nConnection: close\\r\\nTransfer-Encoding: chunked\\r\\n\\r\\n1\\r\\n\"\n    sleep 1\n\n    sock << \"h\\r\\n4\\r\\nello\\r\\n0\\r\\n\\r\\n\"\n\n    data = sock.read\n\n    assert_equal \"HTTP/1.1 200 OK\\r\\nConnection: close\\r\\nContent-Length: 0\\r\\n\\r\\n\", data\n    assert_equal \"hello\", body\n    assert_equal \"5\", content_length\n  end\n\n  def test_chunked_request_pause_between_chunks\n    body = nil\n    content_length = nil\n    server_run { |env|\n      body = env['rack.input'].read\n      content_length = env['CONTENT_LENGTH']\n      [200, {}, [\"\"]]\n    }\n\n    sock = send_http \"GET / HTTP/1.1\\r\\nConnection: close\\r\\nTransfer-Encoding: chunked\\r\\n\\r\\n1\\r\\nh\\r\\n\"\n    sleep 1\n\n    sock << \"4\\r\\nello\\r\\n0\\r\\n\\r\\n\"\n\n    data = sock.read\n\n    assert_equal \"HTTP/1.1 200 OK\\r\\nConnection: close\\r\\nContent-Length: 0\\r\\n\\r\\n\", data\n    assert_equal \"hello\", body\n    assert_equal \"5\", content_length\n  end\n\n  def test_chunked_request_pause_mid_count\n    body = nil\n    content_length = nil\n    server_run { |env|\n      body = env['rack.input'].read\n      content_length = env['CONTENT_LENGTH']\n      [200, {}, [\"\"]]\n    }\n\n    sock = send_http \"GET / HTTP/1.1\\r\\nConnection: close\\r\\nTransfer-Encoding: chunked\\r\\n\\r\\n1\\r\"\n    sleep 1\n\n    sock << \"\\nh\\r\\n4\\r\\nello\\r\\n0\\r\\n\\r\\n\"\n\n    data = sock.read\n\n    assert_equal \"HTTP/1.1 200 OK\\r\\nConnection: close\\r\\nContent-Length: 0\\r\\n\\r\\n\", data\n    assert_equal \"hello\", body\n    assert_equal \"5\", content_length\n  end\n\n  def test_chunked_request_pause_before_count_newline\n    body = nil\n    content_length = nil\n    server_run { |env|\n      body = env['rack.input'].read\n      content_length = env['CONTENT_LENGTH']\n      [200, {}, [\"\"]]\n    }\n\n    sock = send_http \"GET / HTTP/1.1\\r\\nConnection: close\\r\\nTransfer-Encoding: chunked\\r\\n\\r\\n1\"\n    sleep 1\n\n    sock << \"\\r\\nh\\r\\n4\\r\\nello\\r\\n0\\r\\n\\r\\n\"\n\n    data = sock.read\n\n    assert_equal \"HTTP/1.1 200 OK\\r\\nConnection: close\\r\\nContent-Length: 0\\r\\n\\r\\n\", data\n    assert_equal \"hello\", body\n    assert_equal \"5\", content_length\n  end\n\n  def test_chunked_request_pause_mid_value\n    body = nil\n    content_length = nil\n    server_run { |env|\n      body = env['rack.input'].read\n      content_length = env['CONTENT_LENGTH']\n      [200, {}, [\"\"]]\n    }\n\n    sock = send_http \"GET / HTTP/1.1\\r\\nConnection: close\\r\\nTransfer-Encoding: chunked\\r\\n\\r\\n1\\r\\nh\\r\\n4\\r\\ne\"\n    sleep 1\n\n    sock << \"llo\\r\\n0\\r\\n\\r\\n\"\n\n    data = sock.read\n\n    assert_equal \"HTTP/1.1 200 OK\\r\\nConnection: close\\r\\nContent-Length: 0\\r\\n\\r\\n\", data\n    assert_equal \"hello\", body\n    assert_equal \"5\", content_length\n  end\n\n  def test_chunked_request_pause_between_cr_lf_after_size_of_second_chunk\n    body = nil\n    content_length = nil\n    server_run { |env|\n      body = env['rack.input'].read\n      content_length = env['CONTENT_LENGTH']\n      [200, {}, [\"\"]]\n    }\n\n    part1 = 'a' * 4200\n\n    chunked_body = \"#{part1.size.to_s(16)}\\r\\n#{part1}\\r\\n1\\r\\nb\\r\\n0\\r\\n\\r\\n\"\n\n    sock = send_http \"PUT /path HTTP/1.1\\r\\nConnection: close\\r\\nTransfer-Encoding: chunked\\r\\n\\r\\n\"\n\n    sleep 0.1\n\n    sock << chunked_body[0..-10]\n\n    sleep 0.1\n\n    sock << chunked_body[-9..-1]\n\n    data = sock.read\n\n    assert_equal \"HTTP/1.1 200 OK\\r\\nConnection: close\\r\\nContent-Length: 0\\r\\n\\r\\n\", data\n    assert_equal (part1 + 'b'), body\n    assert_equal \"4201\", content_length\n  end\n\n  def test_chunked_request_pause_between_closing_cr_lf\n    body = nil\n    content_length = nil\n    server_run { |env|\n      body = env['rack.input'].read\n      content_length = env['CONTENT_LENGTH']\n      [200, {}, [\"\"]]\n    }\n\n    sock = send_http \"PUT /path HTTP/1.1\\r\\nConnection: close\\r\\nTransfer-Encoding: chunked\\r\\n\\r\\n5\\r\\nhello\\r\"\n\n    sleep 1\n\n    sock << \"\\n0\\r\\n\\r\\n\"\n\n    data = sock.read\n\n    assert_equal \"HTTP/1.1 200 OK\\r\\nConnection: close\\r\\nContent-Length: 0\\r\\n\\r\\n\", data\n    assert_equal 'hello', body\n    assert_equal \"5\", content_length\n  end\n\n  def test_chunked_request_pause_before_closing_cr_lf\n    body = nil\n    content_length = nil\n    server_run { |env|\n      body = env['rack.input'].read\n      content_length = env['CONTENT_LENGTH']\n      [200, {}, [\"\"]]\n    }\n\n    sock = send_http \"PUT /path HTTP/1.1\\r\\nConnection: close\\r\\nTransfer-Encoding: chunked\\r\\n\\r\\n5\\r\\nhello\"\n\n    sleep 1\n\n    sock << \"\\r\\n0\\r\\n\\r\\n\"\n\n    data = sock.read\n\n    assert_equal \"HTTP/1.1 200 OK\\r\\nConnection: close\\r\\nContent-Length: 0\\r\\n\\r\\n\", data\n    assert_equal 'hello', body\n    assert_equal \"5\", content_length\n  end\n\n  def test_chunked_request_header_case\n    body = nil\n    content_length = nil\n    server_run { |env|\n      body = env['rack.input'].read\n      content_length = env['CONTENT_LENGTH']\n      [200, {}, [\"\"]]\n    }\n\n    data = send_http_and_read \"GET / HTTP/1.1\\r\\nConnection: close\\r\\nTransfer-Encoding: Chunked\\r\\n\\r\\n1\\r\\nh\\r\\n4\\r\\nello\\r\\n0\\r\\n\\r\\n\"\n\n    assert_equal \"HTTP/1.1 200 OK\\r\\nConnection: close\\r\\nContent-Length: 0\\r\\n\\r\\n\", data\n    assert_equal \"hello\", body\n    assert_equal \"5\", content_length\n  end\n\n  def test_chunked_keep_alive\n    body = nil\n    content_length = nil\n    server_run { |env|\n      body = env['rack.input'].read\n      content_length = env['CONTENT_LENGTH']\n      [200, {}, [\"\"]]\n    }\n\n    sock = send_http \"GET / HTTP/1.1\\r\\nConnection: Keep-Alive\\r\\nTransfer-Encoding: chunked\\r\\n\\r\\n1\\r\\nh\\r\\n4\\r\\nello\\r\\n0\\r\\n\\r\\n\"\n\n    h = header sock\n\n    assert_equal [\"HTTP/1.1 200 OK\", \"Content-Length: 0\"], h\n    assert_equal \"hello\", body\n    assert_equal \"5\", content_length\n\n    sock.close\n  end\n\n  def test_chunked_keep_alive_two_back_to_back\n    body = nil\n    content_length = nil\n    server_run { |env|\n      body = env['rack.input'].read\n      content_length = env['CONTENT_LENGTH']\n      [200, {}, [\"\"]]\n    }\n\n    sock = send_http \"GET / HTTP/1.1\\r\\nConnection: Keep-Alive\\r\\nTransfer-Encoding: chunked\\r\\n\\r\\n1\\r\\nh\\r\\n4\\r\\nello\\r\\n0\\r\\n\"\n\n    last_crlf_written = false\n    last_crlf_writer = Thread.new do\n      sleep 0.1\n      sock << \"\\r\"\n      sleep 0.1\n      sock << \"\\n\"\n      last_crlf_written = true\n    end\n\n    h = header(sock)\n    assert_equal [\"HTTP/1.1 200 OK\", \"Content-Length: 0\"], h\n    assert_equal \"hello\", body\n    assert_equal \"5\", content_length\n    sleep 0.05 if TRUFFLE\n    assert_equal true, last_crlf_written\n\n    last_crlf_writer.join\n\n    sock << \"GET / HTTP/1.1\\r\\nConnection: Keep-Alive\\r\\nTransfer-Encoding: chunked\\r\\n\\r\\n4\\r\\ngood\\r\\n3\\r\\nbye\\r\\n0\\r\\n\\r\\n\"\n    sleep 0.1\n\n    h = header(sock)\n\n    assert_equal [\"HTTP/1.1 200 OK\", \"Content-Length: 0\"], h\n    assert_equal \"goodbye\", body\n    assert_equal \"7\", content_length\n\n    sock.close\n  end\n\n  def test_chunked_keep_alive_two_back_to_back_with_set_remote_address\n    body = nil\n    content_length = nil\n    remote_addr =nil\n    server_run(remote_address: :header, remote_address_header: 'HTTP_X_FORWARDED_FOR') { |env|\n      body = env['rack.input'].read\n      content_length = env['CONTENT_LENGTH']\n      remote_addr = env['REMOTE_ADDR']\n      [200, {}, [\"\"]]\n    }\n\n    sock = send_http \"GET / HTTP/1.1\\r\\nX-Forwarded-For: 127.0.0.1\\r\\nConnection: Keep-Alive\\r\\nTransfer-Encoding: chunked\\r\\n\\r\\n1\\r\\nh\\r\\n4\\r\\nello\\r\\n0\\r\\n\\r\\n\"\n\n    h = header sock\n    assert_equal [\"HTTP/1.1 200 OK\", \"Content-Length: 0\"], h\n    assert_equal \"hello\", body\n    assert_equal \"5\", content_length\n    assert_equal \"127.0.0.1\", remote_addr\n\n    sock << \"GET / HTTP/1.1\\r\\nX-Forwarded-For: 127.0.0.2\\r\\nConnection: Keep-Alive\\r\\nTransfer-Encoding: chunked\\r\\n\\r\\n4\\r\\ngood\\r\\n3\\r\\nbye\\r\\n0\\r\\n\\r\\n\"\n    sleep 0.1\n\n    h = header(sock)\n\n    assert_equal [\"HTTP/1.1 200 OK\", \"Content-Length: 0\"], h\n    assert_equal \"goodbye\", body\n    assert_equal \"7\", content_length\n    assert_equal \"127.0.0.2\", remote_addr\n\n    sock.close\n  end\n\n  def test_chunked_encoding\n    enc = Encoding::UTF_16LE\n    str = \"\u2500\u2500\u0438\u0457_\u30c6\u30b9\u30c8\u2500\u2500\\n\".encode enc\n\n    server_run {\n      hdrs = {}\n      hdrs['Content-Type'] = \"text; charset=#{enc.to_s.downcase}\"\n\n      body = Enumerator.new do |yielder|\n        100.times do |entry|\n          yielder << str\n        end\n        yielder << \"\\nHello World\\n\".encode(enc)\n      end\n\n      [200, hdrs, body]\n    }\n\n    body = Net::HTTP.start @host, @port do |http|\n      http.request(Net::HTTP::Get.new '/').body.force_encoding(enc)\n    end\n    assert_includes body, str\n    assert_equal enc, body.encoding\n  end\n\n  def test_empty_header_values\n    server_run { [200, {\"X-Empty-Header\" => \"\"}, []] }\n\n    data = send_http_and_read \"HEAD / HTTP/1.0\\r\\n\\r\\n\"\n\n    assert_equal \"HTTP/1.0 200 OK\\r\\nX-Empty-Header: \\r\\nContent-Length: 0\\r\\n\\r\\n\", data\n  end\n\n  def test_request_body_wait\n    request_body_wait = nil\n    server_run { |env|\n      request_body_wait = env['puma.request_body_wait']\n      [204, {}, []]\n    }\n\n    sock = send_http \"POST / HTTP/1.1\\r\\nHost: test.com\\r\\nContent-Type: text/plain\\r\\nContent-Length: 5\\r\\n\\r\\nh\"\n    sleep 1\n    sock << \"ello\"\n\n    sock.gets\n\n    assert request_body_wait.is_a?(Float)\n    # Could be 1000 but the tests get flaky. We don't care if it's extremely precise so much as that\n    # it is set to a reasonable number.\n    assert_operator request_body_wait, :>=, 900\n  end\n\n  def test_request_body_wait_chunked\n    request_body_wait = nil\n    server_run { |env|\n      request_body_wait = env['puma.request_body_wait']\n      [204, {}, []]\n    }\n\n    sock = send_http \"GET / HTTP/1.1\\r\\nConnection: close\\r\\nTransfer-Encoding: chunked\\r\\n\\r\\n1\\r\\nh\\r\\n\"\n    sleep 3\n    sock << \"4\\r\\nello\\r\\n0\\r\\n\\r\\n\"\n\n    sock.gets\n\n    # Could be 1000 but the tests get flaky. We don't care if it's extremely precise so much as that\n    # it is set to a reasonable number.\n    assert_operator request_body_wait, :>=, 900\n  end\n\n  def test_open_connection_wait(**options)\n    server_run(**options) { [200, {}, [\"Hello\"]] }\n    s = send_http nil\n    sleep 0.1\n    s << \"GET / HTTP/1.0\\r\\n\\r\\n\"\n    assert_equal 'Hello', s.readlines.last\n  end\n\n  def test_open_connection_wait_no_queue\n    test_open_connection_wait(queue_requests: false)\n  end\n\n  # Rack may pass a newline in a header expecting us to split it.\n  def test_newline_splits\n    server_run { [200, {'X-header' => \"first line\\nsecond line\"}, [\"Hello\"]] }\n\n    data = send_http_and_read \"HEAD / HTTP/1.0\\r\\n\\r\\n\"\n\n    assert_match \"X-header: first line\\r\\nX-header: second line\\r\\n\", data\n  end\n\n  def test_newline_splits_in_early_hint\n    server_run(early_hints: true) do |env|\n      env['rack.early_hints'].call({'X-header' => \"first line\\nsecond line\"})\n      [200, {}, [\"Hello world!\"]]\n    end\n\n    data = send_http_and_read \"HEAD / HTTP/1.0\\r\\n\\r\\n\"\n\n    assert_match \"X-header: first line\\r\\nX-header: second line\\r\\n\", data\n  end\n\n  def test_proxy_protocol\n    server_run(remote_address: :proxy_protocol, remote_address_proxy_protocol: :v1) do |env|\n      [200, {}, [env[\"REMOTE_ADDR\"]]]\n    end\n\n    remote_addr = send_proxy_v1_http(\"GET / HTTP/1.0\\r\\n\\r\\n\", \"1.2.3.4\").read.split(\"\\r\\n\").last\n    assert_equal '1.2.3.4', remote_addr\n\n    remote_addr = send_proxy_v1_http(\"GET / HTTP/1.0\\r\\n\\r\\n\", \"fd00::1\").read.split(\"\\r\\n\").last\n    assert_equal 'fd00::1', remote_addr\n\n    remote_addr = send_proxy_v1_http(\"GET / HTTP/1.0\\r\\n\\r\\n\", \"fd00::1\", true).read.split(\"\\r\\n\").last\n    assert_equal 'fd00::1', remote_addr\n  end\n\n  # To comply with the Rack spec, we have to split header field values\n  # containing newlines into multiple headers.\n  def assert_does_not_allow_http_injection(app, opts = {})\n    server_run(early_hints: opts[:early_hints], &app)\n\n    data = send_http_and_read \"HEAD / HTTP/1.0\\r\\n\\r\\n\"\n\n    refute_match(/[\\r\\n]Cookie: hack[\\r\\n]/, data)\n  end\n\n  # HTTP Injection Tests\n  #\n  # Puma should prevent injection of CR and LF characters into headers, either as\n  # CRLF or CR or LF, because browsers may interpret it at as a line end and\n  # allow untrusted input in the header to split the header or start the\n  # response body. While it's not documented anywhere and they shouldn't be doing\n  # it, Chrome and curl recognize a lone CR as a line end. According to RFC,\n  # clients SHOULD interpret LF as a line end for robustness, and CRLF is the\n  # specced line end.\n  #\n  # There are three different tests because there are three ways to set header\n  # content in Puma. Regular (rack env), early hints, and a special case for\n  # overriding content-length.\n  {\"cr\" => \"\\r\", \"lf\" => \"\\n\", \"crlf\" => \"\\r\\n\"}.each do |suffix, line_ending|\n    # The cr-only case for the following test was CVE-2020-5247\n    define_method(\"test_prevent_response_splitting_headers_#{suffix}\") do\n      app = ->(_) { [200, {'X-header' => \"untrusted input#{line_ending}Cookie: hack\"}, [\"Hello\"]] }\n      assert_does_not_allow_http_injection(app)\n    end\n\n    define_method(\"test_prevent_response_splitting_headers_early_hint_#{suffix}\") do\n      app = ->(env) do\n        env['rack.early_hints'].call(\"X-header\" => \"untrusted input#{line_ending}Cookie: hack\")\n        [200, {}, [\"Hello\"]]\n      end\n      assert_does_not_allow_http_injection(app, early_hints: true)\n    end\n\n    define_method(\"test_prevent_content_length_injection_#{suffix}\") do\n      app = ->(_) { [200, {'content-length' => \"untrusted input#{line_ending}Cookie: hack\"}, [\"Hello\"]] }\n      assert_does_not_allow_http_injection(app)\n    end\n  end\n\n  # Perform a server shutdown while requests are pending (one in app-server response, one still sending client request).\n  def shutdown_requests(s1_complete: true, s1_response: nil, post: false, s2_response: nil, **options)\n    mutex = Mutex.new\n    app_finished = ConditionVariable.new\n    server_run(**options) { |env|\n      path = env['REQUEST_PATH']\n      mutex.synchronize do\n        app_finished.signal\n        app_finished.wait(mutex) if path == '/s1'\n      end\n      [204, {}, []]\n    }\n\n    pool = @server.instance_variable_get(:@thread_pool)\n\n    # Trigger potential race condition by pausing Reactor#add until shutdown begins.\n    if options.fetch(:queue_requests, true)\n      reactor = @server.instance_variable_get(:@reactor)\n      reactor.instance_variable_set(:@pool, pool)\n      reactor.extend(Module.new do\n        def add(client)\n          if client.env['REQUEST_PATH'] == '/s2'\n            Thread.pass until @pool.instance_variable_get(:@shutdown)\n          end\n          super\n        end\n      end)\n    end\n\n    s1 = nil\n    s2 = send_http post ?\n      \"POST /s2 HTTP/1.1\\r\\nHost: test.com\\r\\nContent-Type: text/plain\\r\\nContent-Length: 5\\r\\n\\r\\nhi!\" :\n      \"GET /s2 HTTP/1.1\\r\\n\"\n    mutex.synchronize do\n      s1 = send_http \"GET /s1 HTTP/1.1\\r\\n\\r\\n\"\n      app_finished.wait(mutex)\n      app_finished.signal if s1_complete\n    end\n    @server.stop\n    Thread.pass until pool.instance_variable_get(:@shutdown)\n\n    assert_match(s1_response, s1.gets) if s1_response\n\n    # Send s2 after shutdown begins\n    s2 << \"\\r\\n\" unless s2.wait_readable(0.2)\n\n    assert s2.wait_readable(10), 'timeout waiting for response'\n    s2_result = begin\n      s2.gets\n    rescue Errno::ECONNABORTED, Errno::ECONNRESET\n      # Some platforms raise errors instead of returning a response/EOF when a TCP connection is aborted.\n      post ? '408' : nil\n    end\n\n    if s2_response\n      assert_match s2_response, s2_result\n    else\n      assert_nil s2_result\n    end\n  end\n\n  # Shutdown should allow pending requests and app-responses to complete.\n  def test_shutdown_requests\n    opts = {s1_response: /204/, s2_response: /204/}\n    shutdown_requests(**opts)\n    shutdown_requests(**opts, queue_requests: false)\n  end\n\n  # Requests still pending after `force_shutdown_after` should have connection closed (408 w/pending POST body).\n  # App-responses still pending should return 503 (uncaught Puma::ThreadPool::ForceShutdown exception).\n  def test_force_shutdown\n    opts = {s1_complete: false, s1_response: /503/, s2_response: nil, force_shutdown_after: 0}\n    shutdown_requests(**opts)\n    shutdown_requests(**opts, queue_requests: false)\n    shutdown_requests(**opts, post: true, s2_response: /408/)\n  end\n\n  def test_http11_connection_header_queue\n    server_run { [200, {}, [\"\"]] }\n\n    sock = send_http \"GET / HTTP/1.1\\r\\n\\r\\n\"\n    assert_equal [\"HTTP/1.1 200 OK\", \"Content-Length: 0\"], header(sock)\n\n    sock << \"GET / HTTP/1.1\\r\\nConnection: close\\r\\n\\r\\n\"\n    assert_equal [\"HTTP/1.1 200 OK\", \"Connection: close\", \"Content-Length: 0\"], header(sock)\n\n    sock.close\n  end\n\n  def test_http10_connection_header_queue\n    server_run { [200, {}, [\"\"]] }\n\n    sock = send_http \"GET / HTTP/1.0\\r\\nConnection: keep-alive\\r\\n\\r\\n\"\n    assert_equal [\"HTTP/1.0 200 OK\", \"Connection: Keep-Alive\", \"Content-Length: 0\"], header(sock)\n\n    sock << \"GET / HTTP/1.0\\r\\n\\r\\n\"\n    assert_equal [\"HTTP/1.0 200 OK\", \"Content-Length: 0\"], header(sock)\n    sock.close\n  end\n\n  def test_http11_connection_header_no_queue\n    server_run(queue_requests: false) { [200, {}, [\"\"]] }\n    sock = send_http \"GET / HTTP/1.1\\r\\n\\r\\n\"\n    assert_equal [\"HTTP/1.1 200 OK\", \"Connection: close\", \"Content-Length: 0\"], header(sock)\n    sock.close\n  end\n\n  def test_http10_connection_header_no_queue\n    server_run(queue_requests: false) { [200, {}, [\"\"]] }\n    sock = send_http \"GET / HTTP/1.0\\r\\n\\r\\n\"\n    assert_equal [\"HTTP/1.0 200 OK\", \"Content-Length: 0\"], header(sock)\n    sock.close\n  end\n\n  def stub_accept_nonblock(error)\n    @port = (@server.add_tcp_listener @host, 0).addr[1]\n    io = @server.binder.ios.last\n\n    accept_old = io.method(:accept_nonblock)\n    io.singleton_class.send :define_method, :accept_nonblock do\n      accept_old.call.close\n      raise error\n    end\n\n    @server.run\n    new_connection\n    sleep 0.01\n  end\n\n  # System-resource errors such as EMFILE should not be silently swallowed by accept loop.\n  def test_accept_emfile\n    stub_accept_nonblock Errno::EMFILE.new('accept(2)')\n    refute_empty @log_writer.stderr.string, \"Expected EMFILE error not logged\"\n  end\n\n  # Retryable errors such as ECONNABORTED should be silently swallowed by accept loop.\n  def test_accept_econnaborted\n    # Match Ruby #accept_nonblock implementation, ECONNABORTED error is extended by IO::WaitReadable.\n    error = Errno::ECONNABORTED.new('accept(2) would block').tap {|e| e.extend IO::WaitReadable}\n    stub_accept_nonblock(error)\n    assert_empty @log_writer.stderr.string\n  end\n\n  # see      https://github.com/puma/puma/issues/2390\n  # fixed by https://github.com/puma/puma/pull/2279\n  #\n  def test_client_quick_close_no_lowlevel_error_handler_call\n    handler = ->(err, env, status) {\n      @log_writer.stdout.write \"LLEH #{err.message}\"\n      [500, {\"Content-Type\" => \"application/json\"}, [\"{}\\n\"]]\n    }\n\n    server_run(lowlevel_error_handler: handler) { [200, {}, ['Hello World']] }\n\n    # valid req & read, close\n    sock = TCPSocket.new @host, @port\n    sock.syswrite \"GET / HTTP/1.0\\r\\n\\r\\n\"\n    sleep 0.05  # macOS TruffleRuby may not get the body without\n    resp = sock.sysread 256\n    sock.close\n    assert_match 'Hello World', resp\n    sleep 0.5\n    assert_empty @log_writer.stdout.string\n\n    # valid req, close\n    sock = TCPSocket.new @host, @port\n    sock.syswrite \"GET / HTTP/1.0\\r\\n\\r\\n\"\n    sock.close\n    sleep 0.5\n    assert_empty @log_writer.stdout.string\n\n    # invalid req, close\n    sock = TCPSocket.new @host, @port\n    sock.syswrite \"GET / HTTP\"\n    sock.close\n    sleep 0.5\n    assert_empty @log_writer.stdout.string\n  end\n\n  def test_idle_connections_closed_immediately_on_shutdown\n    server_run\n    sock = new_connection\n    sleep 0.5 # give enough time for new connection to enter reactor\n    @server.stop false\n\n    assert sock.wait_readable(1), 'Unexpected timeout'\n    assert_raises EOFError do\n      sock.read_nonblock(256)\n    end\n  end\n\n  def test_run_stop_thread_safety\n    100.times do\n      thread = @server.run\n      @server.stop\n      assert thread.join(1)\n    end\n  end\n\n  def test_command_ignored_before_run\n    @server.stop # ignored\n    @server.run\n    @server.halt\n    done = Queue.new\n    @server.events.register(:state) do |state|\n      done << @server.instance_variable_get(:@status) if state == :done\n    end\n    assert_equal :halt, done.pop\n  end\n\n  def test_custom_io_selector\n    backend = NIO::Selector.backends.first\n\n    @server = Puma::Server.new @app, @events, {log_writer: @log_writer, :io_selector_backend => backend}\n    @server.run\n\n    selector = @server.instance_variable_get(:@reactor).instance_variable_get(:@selector)\n\n    assert_equal selector.backend, backend\n  end\n\n  def test_drain_on_shutdown(drain=true)\n    num_connections = 10\n\n    wait = Queue.new\n    server_run(drain_on_shutdown: drain, max_threads: 1) do\n      wait.pop\n      [200, {}, [\"DONE\"]]\n    end\n    connections = Array.new(num_connections) {send_http \"GET / HTTP/1.0\\r\\n\\r\\n\"}\n    @server.stop\n    wait.close\n    bad = 0\n    connections.each do |s|\n      begin\n        assert_match 'DONE', s.read\n      rescue Errno::ECONNRESET\n        bad += 1\n      end\n    end\n    if drain\n      assert_equal 0, bad\n    else\n      refute_equal 0, bad\n    end\n  end\n\n  def test_not_drain_on_shutdown\n    test_drain_on_shutdown false\n  end\n\n  def test_remote_address_header\n    server_run(remote_address: :header, remote_address_header: 'HTTP_X_REMOTE_IP') do |env|\n      [200, {}, [env['REMOTE_ADDR']]]\n    end\n    remote_addr = send_http_and_read(\"GET / HTTP/1.1\\r\\nX-Remote-IP: 1.2.3.4\\r\\n\\r\\n\").split(\"\\r\\n\").last\n    assert_equal '1.2.3.4', remote_addr\n\n    # TODO: it would be great to test a connection from a non-localhost IP, but we can't really do that. For\n    # now, at least test that it doesn't return garbage.\n    remote_addr = send_http_and_sysread(\"GET / HTTP/1.1\\r\\n\\r\\n\").split(\"\\r\\n\").last\n    assert_equal @host, remote_addr\n  end\n\n  def get_chunk_times\n    body = +''\n    times = []\n    Net::HTTP.start @host, @port do |http|\n      req = Net::HTTP::Get.new '/'\n      http.request req do |resp|\n        resp.read_body do |chunk|\n          next if chunk.empty?\n          body << chunk\n          times << Process.clock_gettime(Process::CLOCK_MONOTONIC)\n        end\n\n      end\n    end\n    [body, times]\n  end\n\n  # see https://github.com/sinatra/sinatra/blob/master/examples/stream.ru\n  def test_streaming_enum_body_1\n    str = \"Hello Puma World\"\n    body_len = str.bytesize * 3\n\n    server_run do |env|\n      hdrs = {}\n      hdrs['Content-Type'] = \"text; charset=utf-8\"\n\n      body = Enumerator.new do |yielder|\n          yielder << str\n          sleep 0.5\n          yielder << str\n          sleep 1.5\n          yielder << str\n      end\n      [200, hdrs, body]\n    end\n\n    resp_body, times = get_chunk_times\n    assert_equal body_len, resp_body.bytesize\n    assert_equal str * 3, resp_body\n    assert times[1] - times[0] > 0.4\n    assert times[1] - times[0] < 1\n    assert times[2] - times[1] > 1\n  end\n\n  # similar to a longer running app passing its output thru an enum body\n  # example - https://github.com/dentarg/testssl.web\n  def test_streaming_enum_body_2\n    str = \"Hello Puma World\"\n    loops = 10\n    body_len = str.bytesize * loops\n\n    server_run do |env|\n      hdrs = {}\n      hdrs['Content-Type'] = \"text; charset=utf-8\"\n\n      body = Enumerator.new do |yielder|\n        loops.times do |i|\n          sleep 0.15 unless i.zero?\n          yielder << str\n        end\n      end\n      [200, hdrs, body]\n    end\n    resp_body, times = get_chunk_times\n    assert_equal body_len, resp_body.bytesize\n    assert_equal str * loops, resp_body\n    assert_operator times.last - times.first, :>, 1.0\n  end\n\n  def test_empty_body_array_content_length_0\n    server_run { |env| [404, {'Content-Length' => '0'}, []] }\n\n    resp = send_http_and_sysread \"GET / HTTP/1.1\\r\\n\\r\\n\"\n    # Not Found\n    assert_equal \"HTTP/1.1 404 #{STATUS_CODES[404]}\\r\\nContent-Length: 0\\r\\n\\r\\n\", resp\n  end\n\n  def test_empty_body_array_no_content_length\n    server_run { |env| [404, {}, []] }\n\n    resp = send_http_and_sysread \"GET / HTTP/1.1\\r\\n\\r\\n\"\n    # Not Found\n    assert_equal \"HTTP/1.1 404 #{STATUS_CODES[404]}\\r\\nContent-Length: 0\\r\\n\\r\\n\", resp\n  end\n\n  def test_empty_body_enum\n    server_run { |env| [404, {}, [].to_enum] }\n\n    resp = send_http_and_sysread \"GET / HTTP/1.1\\r\\n\\r\\n\"\n    # Not Found\n    assert_equal \"HTTP/1.1 404 #{STATUS_CODES[404]}\\r\\nTransfer-Encoding: chunked\\r\\n\\r\\n0\\r\\n\\r\\n\", resp\n  end\n\n  def test_form_data_encoding_windows_bom\n    req_body = nil\n\n    str = \"\u2500\u2500\u2500\u2500 Hello,World,From,Puma \u2500\u2500\u2500\u2500\\r\\n\"\n\n    file_contents = str * 5_500 # req body is > 256 kB\n\n    file_bytesize = file_contents.bytesize + 3 # 3 = BOM byte size\n\n    fio = Tempfile.create 'win_bom_utf8_'\n\n    temp_file_path = fio.path\n    fio.close\n\n    File.open temp_file_path, \"wb:UTF-8\" do |f|\n      f.write \"\\xEF\\xBB\\xBF#{file_contents}\"\n    end\n\n    server_run do |env|\n      req_body = env['rack.input'].read\n      [200, {}, [req_body]]\n    end\n\n    cmd = \"curl -H 'transfer-encoding: chunked' --form data=@#{temp_file_path} http://127.0.0.1:#{@port}/\"\n\n    out_r, _, _ = spawn_cmd cmd\n\n    out_r.wait_readable 3\n\n    form_file_data = req_body.split(\"\\r\\n\\r\\n\", 2)[1].sub(/\\r\\n----\\S+\\r\\n\\z/, '')\n\n    assert_equal file_bytesize, form_file_data.bytesize\n    assert_equal out_r.read.bytesize, req_body.bytesize\n  end\n\n  def test_form_data_encoding_windows\n    req_body = nil\n\n    str = \"\u2500\u2500\u2500\u2500 Hello,World,From,Puma \u2500\u2500\u2500\u2500\\r\\n\"\n\n    file_contents = str * 5_500 # req body is > 256 kB\n\n    file_bytesize = file_contents.bytesize\n\n    fio = tempfile_create 'win_utf8_', file_contents\n\n    temp_file_path = fio.path\n    fio.close\n\n    server_run do |env|\n      req_body = env['rack.input'].read\n      [200, {}, [req_body]]\n    end\n\n    cmd = \"curl -H 'transfer-encoding: chunked' --form data=@#{temp_file_path} http://127.0.0.1:#{@port}/\"\n\n    out_r, _, _ = spawn_cmd cmd\n\n    out_r.wait_readable 3\n\n    form_file_data = req_body.split(\"\\r\\n\\r\\n\", 2)[1].sub(/\\r\\n----\\S+\\r\\n\\z/, '')\n\n    assert_equal file_bytesize, form_file_data.bytesize\n    assert_equal out_r.read.bytesize, req_body.bytesize\n  end\n\n  def test_supported_http_methods_match\n    server_run(supported_http_methods: ['PROPFIND', 'PROPPATCH']) do |env|\n      body = [env['REQUEST_METHOD']]\n      [200, {}, body]\n    end\n    resp = send_http_and_read \"PROPFIND / HTTP/1.0\\r\\n\\r\\n\"\n    assert_match 'PROPFIND', resp\n  end\n\n  def test_supported_http_methods_no_match\n    server_run(supported_http_methods: ['PROPFIND', 'PROPPATCH']) do |env|\n      body = [env['REQUEST_METHOD']]\n      [200, {}, body]\n    end\n    resp = send_http_and_read \"GET / HTTP/1.0\\r\\n\\r\\n\"\n    assert_match 'Not Implemented', resp\n  end\n\n  def test_supported_http_methods_accept_all\n    server_run(supported_http_methods: :any) do |env|\n      body = [env['REQUEST_METHOD']]\n      [200, {}, body]\n    end\n    resp = send_http_and_read \"YOUR_SPECIAL_METHOD / HTTP/1.0\\r\\n\\r\\n\"\n    assert_match 'YOUR_SPECIAL_METHOD', resp\n  end\n\n  def test_supported_http_methods_empty\n    server_run(supported_http_methods: []) do |env|\n      body = [env['REQUEST_METHOD']]\n      [200, {}, body]\n    end\n    resp = send_http_and_read \"GET / HTTP/1.0\\r\\n\\r\\n\"\n    assert_match(/\\AHTTP\\/1\\.0 501 Not Implemented/, resp)\n  end\n\n\n  def spawn_cmd(env = {}, cmd)\n    opts = {}\n\n    out_r, out_w = IO.pipe\n    opts[:out] = out_w\n\n    err_r, err_w = IO.pipe\n    opts[:err] = err_w\n\n    out_r.binmode\n    err_r.binmode\n\n    pid = spawn(env, cmd, opts)\n    [out_w, err_w].each(&:close)\n    [out_r, err_r, pid]\n  end\n\n  def test_lowlevel_error_handler_response\n    options = {\n      lowlevel_error_handler: ->(_error) do\n        [500, {}, [\"something wrong happened\"]]\n      end\n    }\n    broken_app = ->(_env) { [200, nil, []] }\n\n    server_run(**options, &broken_app)\n\n    data = send_http_and_read \"GET / HTTP/1.1\\r\\n\\r\\n\"\n\n    assert_match(/something wrong happened/, data)\n  end\n\n  def test_cl_empty_string\n    server_run do |env|\n      [200, {}, [\"\"]]\n    end\n\n    # rubocop:disable Layout/TrailingWhitespace\n    empty_cl_request = <<~REQ.gsub(\"\\n\", \"\\r\\n\")\n      GET / HTTP/1.1\n      Host: localhost\n      Content-Length: \n      \n      GET / HTTP/1.1\n      Host: localhost\n      \n    REQ\n    # rubocop:enable Layout/TrailingWhitespace\n\n    data = send_http_and_read empty_cl_request\n    assert_operator data, :start_with?, 'HTTP/1.1 400 Bad Request'\n  end\n\n  def test_crlf_trailer_smuggle\n    server_run do |env|\n      [200, {}, [\"\"]]\n    end\n\n    smuggled_payload = <<~REQ.gsub(\"\\n\", \"\\r\\n\")\n      GET / HTTP/1.1\n      Transfer-Encoding: chunked\n      Host: whatever\n\n      0\n      X:POST / HTTP/1.1\n      Host: whatever\n\n      GET / HTTP/1.1\n      Host: whatever\n\n    REQ\n\n    data = send_http_and_read smuggled_payload\n    assert_equal 2, data.scan(\"HTTP/1.1 200 OK\").size\n  end\n\n  # test to check if content-length is ignored when 'transfer-encoding: chunked'\n  # is used.  See also test_large_chunked_request\n  def test_cl_and_te_smuggle\n    body = nil\n    server_run { |env|\n      body = env['rack.input'].read\n      [200, {}, [\"\"]]\n    }\n\n    req = <<~REQ.gsub(\"\\n\", \"\\r\\n\")\n      POST /search HTTP/1.1\n      Host: vulnerable-website.com\n      Content-Type: application/x-www-form-urlencoded\n      Content-Length: 4\n      Transfer-Encoding: chunked\n\n      7b\n      GET /404 HTTP/1.1\n      Host: vulnerable-website.com\n      Content-Type: application/x-www-form-urlencoded\n      Content-Length: 144\n\n      x=\n      0\n\n    REQ\n\n    data = send_http_and_read req\n\n    assert_includes body, \"GET /404 HTTP/1.1\\r\\n\"\n    assert_includes body, \"Content-Length: 144\\r\\n\"\n    assert_equal 1, data.scan(\"HTTP/1.1 200 OK\").size\n  end\nend\n"], "filenames": ["lib/puma/client.rb", "test/test_puma_server.rb"], "buggy_code_start_loc": [52, 752], "buggy_code_end_loc": [566, 1712], "fixing_code_start_loc": [52, 752], "fixing_code_end_loc": [573, 1791], "type": "CWE-444", "message": "Puma is a Ruby/Rack web server built for parallelism. Prior to versions 6.3.1 and 5.6.7, puma exhibited incorrect behavior when parsing chunked transfer encoding bodies and zero-length Content-Length headers in a way that allowed HTTP request smuggling. Severity of this issue is highly dependent on the nature of the web site using puma is. This could be caused by either incorrect parsing of trailing fields in chunked transfer encoding bodies or by parsing of blank/zero-length Content-Length headers. Both issues have been addressed and this vulnerability has been fixed in versions 6.3.1 and 5.6.7. Users are advised to upgrade. There are no known workarounds for this vulnerability.", "other": {"cve": {"id": "CVE-2023-40175", "sourceIdentifier": "security-advisories@github.com", "published": "2023-08-18T22:15:11.653", "lastModified": "2023-08-24T18:48:29.013", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Puma is a Ruby/Rack web server built for parallelism. Prior to versions 6.3.1 and 5.6.7, puma exhibited incorrect behavior when parsing chunked transfer encoding bodies and zero-length Content-Length headers in a way that allowed HTTP request smuggling. Severity of this issue is highly dependent on the nature of the web site using puma is. This could be caused by either incorrect parsing of trailing fields in chunked transfer encoding bodies or by parsing of blank/zero-length Content-Length headers. Both issues have been addressed and this vulnerability has been fixed in versions 6.3.1 and 5.6.7. Users are advised to upgrade. There are no known workarounds for this vulnerability."}, {"lang": "es", "value": "Puma es un servidor web Ruby/Rack construido para paralelismo. Antes de las versiones 6.3.1 y 5.6.7, Puma mostraba un comportamiento incorrecto al analizar cuerpos de codificaci\u00f3n de transferencia en trozos y cabeceras Content-Length de longitud cero de forma que permit\u00eda el contrabando de peticiones HTTP. La gravedad de este problema depende en gran medida de la naturaleza del sitio web que utiliza Puma. Esto podr\u00eda ser causado por un an\u00e1lisis incorrecto de los campos finales en los cuerpos de codificaci\u00f3n de transferencia en trozos o por el an\u00e1lisis de cabeceras Content-Length en blanco/longitud cero. Ambos problemas han sido solucionados y esta vulnerabilidad ha sido corregida en las versiones 6.3.1 y 5.6.7.Se recomienda a los usuarios que actualicen. No se conocen soluciones para esta vulnerabilidad. "}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:L/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 7.3, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.4}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-444"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:puma:puma:*:*:*:*:*:ruby:*:*", "versionEndExcluding": "5.6.7", "matchCriteriaId": "2C1EAED4-2740-4325-B155-DA1EAB8C2FD1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:puma:puma:*:*:*:*:*:ruby:*:*", "versionStartIncluding": "6.0.0", "versionEndExcluding": "6.3.1", "matchCriteriaId": "3FEE1A57-B890-43B7-98FB-3ACFD1F2818E"}]}]}], "references": [{"url": "https://github.com/puma/puma/commit/690155e7d644b80eeef0a6094f9826ee41f1080a", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/puma/puma/security/advisories/GHSA-68xg-gqqm-vgj8", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/puma/puma/commit/690155e7d644b80eeef0a6094f9826ee41f1080a"}}