{"buggy_code": ["/**\n *\n * Ulfius Framework\n *\n * REST framework library\n *\n * ulfius.c: framework functions definitions\n *\n * Copyright 2015-2020 Nicolas Mora <mail@babelouest.org>\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public License\n * as published by the Free Software Foundation;\n * version 2.1 of the License.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU GENERAL PUBLIC LICENSE for more details.\n *\n * You should have received a copy of the GNU General Public\n * License along with this library.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\n\n#include <string.h>\n#include <ctype.h>\n#include <stdlib.h>\n#include <pthread.h>\n#include \"u_private.h\"\n#include \"ulfius.h\"\n\n#ifndef U_DISABLE_CURL\n#include <curl/curl.h>\n#endif\n\n/** Define mock yder functions when yder is disabled **/\n#ifdef U_DISABLE_YDER\nint y_init_logs(const char * app, const unsigned long init_mode, const unsigned long init_level, const char * init_log_file, const char * message) {\n  (void)(app);\n  (void)(init_mode);\n  (void)(init_level);\n  (void)(init_log_file);\n  (void)(message);\n  return 1;\n}\n\nint y_set_logs_callback(void (* y_callback_log_message) (void * cls, const char * app_name, const time_t date, const unsigned long level, const char * message), void * cls, const char * message) {\n  (void)(y_callback_log_message);\n  (void)(cls);\n  (void)(message);\n  return 1;\n}\n\nvoid y_log_message(const unsigned long type, const char * message, ...) {\n  (void)(type);\n  (void)(message);\n}\n\nint y_close_logs(void) {\n  return 1;\n}\n#endif\n\n/**\n * Fill a map with the key/values specified\n */\n#if MHD_VERSION >= 0x00097002\nstatic enum MHD_Result ulfius_fill_map_check_utf8(void * cls, enum MHD_ValueKind kind, const char * key, const char * value) {\n#else\nstatic int ulfius_fill_map_check_utf8(void * cls, enum MHD_ValueKind kind, const char * key, const char * value) {\n#endif\n  char * tmp;\n  int res;\n  UNUSED(kind);\n\n  if (cls == NULL || key == NULL) {\n    // Invalid parameters\n    y_log_message(Y_LOG_LEVEL_ERROR, \"Ulfius - Error invalid parameters for ulfius_fill_map_check_utf8\");\n    return MHD_NO;\n  } else if (utf8_check(key, o_strlen(key)) == NULL && (value == NULL || utf8_check(value, o_strlen(value)) == NULL)) {\n    if (u_map_get(((struct _u_map *)cls), key) != NULL) {\n      // u_map already has a value with this this key, appending value separated with a comma ',')\n      tmp = msprintf(\"%s,%s\", u_map_get(((struct _u_map *)cls), key), (value==NULL?\"\":value));\n      res = u_map_put(((struct _u_map *)cls), key, tmp);\n      o_free(tmp);\n      if (res == U_OK) {\n        return MHD_YES;\n      } else {\n        return MHD_NO;\n      }\n    } else if (u_map_put(((struct _u_map *)cls), key, (value==NULL?\"\":value)) == U_OK) {\n      return MHD_YES;\n    } else {\n      return MHD_NO;\n    }\n  } else {\n    return MHD_YES;\n  }\n}\n\n/**\n * Fill a map with the key/values specified\n */\n#if MHD_VERSION >= 0x00097002\nstatic enum MHD_Result ulfius_fill_map(void * cls, enum MHD_ValueKind kind, const char * key, const char * value) {\n#else\nstatic int ulfius_fill_map(void * cls, enum MHD_ValueKind kind, const char * key, const char * value) {\n#endif\n  char * tmp;\n  int res;\n  UNUSED(kind);\n\n  if (cls == NULL || key == NULL) {\n    // Invalid parameters\n    y_log_message(Y_LOG_LEVEL_ERROR, \"Ulfius - Error invalid parameters for ulfius_fill_map\");\n    return MHD_NO;\n  } else if (u_map_get(((struct _u_map *)cls), key) != NULL) {\n    // u_map already has a value with this this key, appending value separated with a comma ',')\n    tmp = msprintf(\"%s,%s\", u_map_get(((struct _u_map *)cls), key), (value==NULL?\"\":value));\n    res = u_map_put(((struct _u_map *)cls), key, tmp);\n    o_free(tmp);\n    if (res == U_OK) {\n      return MHD_YES;\n    } else {\n      return MHD_NO;\n    }\n  } else if (u_map_put(((struct _u_map *)cls), key, (value==NULL?\"\":value)) == U_OK) {\n    return MHD_YES;\n  } else {\n    return MHD_NO;\n  }\n}\n\n/**\n * ulfius_is_valid_endpoint\n * return true if the endpoind has valid parameters\n */\n#if MHD_VERSION >= 0x00097002\nstatic enum MHD_Result ulfius_is_valid_endpoint(const struct _u_endpoint * endpoint, int to_delete) {\n#else\nstatic int ulfius_is_valid_endpoint(const struct _u_endpoint * endpoint, int to_delete) {\n#endif\n  if (endpoint != NULL) {\n    if (ulfius_equals_endpoints(endpoint, ulfius_empty_endpoint())) {\n      // Should be the last endpoint of the list to close it\n      return 1;\n    } else if (endpoint->http_method == NULL) {\n      return 0;\n    } else if (!to_delete && endpoint->callback_function == NULL) {\n      return 0;\n    } else if (endpoint->url_prefix == NULL && endpoint->url_format == NULL) {\n      return 0;\n    } else {\n      return 1;\n    }\n  } else {\n    return 0;\n  }\n}\n\n/**\n * ulfius_validate_endpoint_list\n * return true if endpoint_list has valid parameters\n */\nstatic int ulfius_validate_endpoint_list(const struct _u_endpoint * endpoint_list, int nb_endpoints) {\n  int i;\n  if (endpoint_list != NULL) {\n    for (i=0; i < nb_endpoints; i++) {\n      if (i == 0 && ulfius_equals_endpoints(ulfius_empty_endpoint(), &endpoint_list[i])) {\n        // One can not have an empty endpoint in the beginning of the list\n        y_log_message(Y_LOG_LEVEL_ERROR, \"Ulfius - Error, no empty endpoint allowed in the beginning of the endpoint list\");\n        return U_ERROR_PARAMS;\n      } else if (!ulfius_is_valid_endpoint(&endpoint_list[i], 0)) {\n        // One must set at least the parameters http_method, url_format and callback_function\n        y_log_message(Y_LOG_LEVEL_ERROR, \"Ulfius - Error, endpoint at index %d has invalid parameters\", i);\n        return U_ERROR_PARAMS;\n      }\n    }\n    return U_OK;\n  } else {\n    y_log_message(Y_LOG_LEVEL_ERROR, \"Ulfius - Error, no endpoint list\");\n    return U_ERROR_PARAMS;\n  }\n}\n\n/**\n * ulfius_validate_instance\n * return true if u_instance has valid parameters\n */\nstatic int ulfius_validate_instance(const struct _u_instance * u_instance) {\n  if (u_instance == NULL ||\n      u_instance->port <= 0 ||\n      u_instance->port >= 65536 ||\n      ulfius_validate_endpoint_list(u_instance->endpoint_list, u_instance->nb_endpoints) != U_OK) {\n    y_log_message(Y_LOG_LEVEL_ERROR, \"Ulfius - Error, instance or has invalid parameters\");\n    return U_ERROR_PARAMS;\n  }\n  return U_OK;\n}\n\n/**\n * Internal method used to duplicate the full url before it's manipulated and modified by MHD\n */\nvoid * ulfius_uri_logger (void * cls, const char * uri) {\n  struct connection_info_struct * con_info = o_malloc (sizeof (struct connection_info_struct));\n  UNUSED(cls);\n\n  if (con_info != NULL) {\n    con_info->callback_first_iteration = 1;\n    con_info->u_instance = NULL;\n    u_map_init(&con_info->map_url_initial);\n    con_info->request = o_malloc(sizeof(struct _u_request));\n    if (con_info->request == NULL) {\n      y_log_message(Y_LOG_LEVEL_ERROR, \"Ulfius - Error allocating memory for con_info->request\");\n      o_free(con_info);\n      return NULL;\n    }\n\n    if (NULL == con_info->request || ulfius_init_request(con_info->request) != U_OK) {\n      ulfius_clean_request_full(con_info->request);\n      o_free(con_info);\n      return NULL;\n    }\n    con_info->request->http_url = o_strdup(uri);\n    if (o_strchr(uri, '?') != NULL) {\n      con_info->request->url_path = o_strndup(uri, o_strchr(uri, '?') - uri);\n    } else {\n      con_info->request->url_path = o_strdup(uri);\n    }\n    if (con_info->request->http_url == NULL || con_info->request->url_path == NULL) {\n      y_log_message(Y_LOG_LEVEL_ERROR, \"Ulfius - Error allocating memory for con_info->request->http_url or con_info->request->url_path\");\n      ulfius_clean_request_full(con_info->request);\n      o_free(con_info);\n      return NULL;\n    }\n    con_info->max_post_param_size = 0;\n  } else {\n    y_log_message(Y_LOG_LEVEL_ERROR, \"Ulfius - Error allocating memory for con_info\");\n  }\n  return con_info;\n}\n\n/**\n * ulfius_get_body_from_response\n * Extract the body data from the response if any\n * Copy it in newly allocated response_buffer and set the size in response_buffer_len\n * return U_OK on success\n */\nstatic int ulfius_get_body_from_response(struct _u_response * response, void ** response_buffer, size_t * response_buffer_len) {\n  if (response == NULL || response_buffer == NULL || response_buffer_len == NULL) {\n    return U_ERROR_PARAMS;\n  } else {\n    if (response->binary_body != NULL && response->binary_body_length > 0) {\n      // The user sent a binary response\n      *response_buffer = o_malloc(response->binary_body_length);\n      if (*response_buffer == NULL) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"Ulfius - Error allocating memory for response_buffer\");\n        response->status = MHD_HTTP_INTERNAL_SERVER_ERROR;\n        response->binary_body = o_strdup(ULFIUS_HTTP_ERROR_BODY);\n        response->binary_body_length = o_strlen(ULFIUS_HTTP_ERROR_BODY);\n        if (response->binary_body == NULL) {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"Ulfius - Error allocating memory for response->binary_body\");\n          return U_ERROR_MEMORY;\n        }\n      } else {\n        memcpy(*response_buffer, response->binary_body, response->binary_body_length);\n        *response_buffer_len = response->binary_body_length;\n      }\n    } else {\n      *response_buffer = NULL;\n      *response_buffer_len = 0;\n    }\n    return U_OK;\n  }\n}\n\n/**\n * mhd_request_completed\n * function used to clean data allocated after a web call is complete\n */\nvoid mhd_request_completed (void *cls, struct MHD_Connection *connection,\n                        void **con_cls, enum MHD_RequestTerminationCode toe) {\n  struct connection_info_struct *con_info = *con_cls;\n  UNUSED(toe);\n  UNUSED(connection);\n  UNUSED(cls);\n\n  if (NULL == con_info) {\n    return;\n  }\n  if (con_info->has_post_processor && con_info->post_processor != NULL) {\n    MHD_destroy_post_processor (con_info->post_processor);\n  }\n  ulfius_clean_request_full(con_info->request);\n  u_map_clean(&con_info->map_url_initial);\n  con_info->request = NULL;\n  o_free(con_info);\n  con_info = NULL;\n  *con_cls = NULL;\n}\n\n/**\n * mhd_iterate_post_data\n * function used to iterate post parameters\n * if a parameter is larger than max_post_param_size, truncate it\n * return MHD_NO on error\n */\n#if MHD_VERSION >= 0x00097002\nstatic enum MHD_Result mhd_iterate_post_data (void * coninfo_cls, enum MHD_ValueKind kind, const char * key,\n                                              const char * filename, const char * content_type,\n                                              const char * transfer_encoding, const char * data, uint64_t off, size_t size) {\n#else\nstatic int mhd_iterate_post_data (void * coninfo_cls, enum MHD_ValueKind kind, const char * key,\n                                  const char * filename, const char * content_type,\n                                  const char * transfer_encoding, const char * data, uint64_t off, size_t size) {\n#endif\n  struct connection_info_struct * con_info = coninfo_cls;\n  size_t data_size = size, cur_size;\n  char * filename_param = NULL, * data_concat = NULL;\n  const char * cur_data;\n#if MHD_VERSION >= 0x00097002\n  enum MHD_Result ret = MHD_YES;\n#else\n  int ret = MHD_YES;\n#endif\n  UNUSED(kind);\n\n  if (con_info->u_instance == NULL) {\n    ret = MHD_NO;\n  } else if (filename != NULL && con_info->u_instance->file_upload_callback != NULL) {\n    if (con_info->u_instance->file_upload_callback(con_info->request, key, filename, content_type, transfer_encoding, data, off, size, con_info->u_instance->file_upload_cls) != U_OK) {\n      ret = MHD_NO;\n    }\n  } else {\n    \n    do {\n      if (con_info->u_instance->check_utf8) {\n        if (utf8_check(key, o_strlen(key)) != NULL || data == NULL || utf8_check(data, o_strlen(data)) != NULL || (filename != NULL && utf8_check(filename, o_strlen(filename)) != NULL)) {\n          break;\n        }\n      }\n      \n      if (con_info->max_post_param_size && off > con_info->max_post_param_size) {\n        break;\n      }\n      \n      if (off + size > con_info->max_post_param_size) {\n        data_size = con_info->max_post_param_size - off;\n      }\n      \n      if (filename != NULL) {\n        filename_param = msprintf(\"%s_filename\", key);\n        if (!u_map_has_key((struct _u_map *)con_info->request->map_post_body, filename_param) && u_map_put((struct _u_map *)con_info->request->map_post_body, filename_param, filename) != U_OK) {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"Ulfius - Error u_map_put filename value\");\n        }\n        cur_data = u_map_get((struct _u_map *)con_info->request->map_post_body, key);\n        cur_size = u_map_get_length((struct _u_map *)con_info->request->map_post_body, key);\n        if (cur_data != NULL) {\n          if (off) {\n            if (u_map_put_binary((struct _u_map *)con_info->request->map_post_body, key, data, cur_size, data_size) != U_OK) {\n              ret = MHD_NO;\n              break;\n            }\n          } else {\n            if (u_map_put_binary((struct _u_map *)con_info->request->map_post_body, key, \",\", cur_size, 1) != U_OK ||\n                u_map_put_binary((struct _u_map *)con_info->request->map_post_body, key, data, cur_size+1, 1) != U_OK) {\n              ret = MHD_NO;\n              break;\n            }\n          }\n        } else {\n          if (u_map_put_binary((struct _u_map *)con_info->request->map_post_body, key, data, 0, data_size) != U_OK) {\n            ret = MHD_NO;\n            break;\n          }\n        }\n      } else {\n        cur_data = u_map_get((struct _u_map *)con_info->request->map_post_body, key);\n        cur_size = u_map_get_length((struct _u_map *)con_info->request->map_post_body, key);\n        if (cur_data != NULL) {\n          if (off) {\n            data_concat = msprintf(\"%s%s\", cur_data, data);\n          } else {\n            data_concat = msprintf(\"%s,%s\", cur_data, data);\n          }\n          if (u_map_put((struct _u_map *)con_info->request->map_post_body, key, data_concat) != U_OK) {\n            ret = MHD_NO;\n            break;\n          }\n        } else {\n          if (u_map_put((struct _u_map *)con_info->request->map_post_body, key, data) != U_OK) {\n            ret = MHD_NO;\n            break;\n          }\n        }\n      }\n      \n    } while (0);\n    o_free(data_concat);\n    o_free(filename_param);\n  }\n  return ret;\n}\n\n#if MHD_VERSION >= 0x00096100\n  #define MHD_CREATE_RESPONSE_FROM_BUFFER_PIMPED(len, buf, flag) MHD_create_response_from_buffer_with_free_callback((len), (buf), &o_free)\n#else\n  #define MHD_CREATE_RESPONSE_FROM_BUFFER_PIMPED(len, buf, flag) MHD_create_response_from_buffer((len), (buf), (flag))\n#endif\n\n/**\n * ulfius_webservice_dispatcher\n * function executed by libmicrohttpd every time an HTTP call is made\n * return MHD_NO on error\n */\n#if MHD_VERSION >= 0x00097002\nstatic enum MHD_Result ulfius_webservice_dispatcher (void * cls,\n                                                     struct MHD_Connection * connection,\n                                                     const char * url,\n                                                     const char * method,\n                                                     const char * version,\n                                                     const char * upload_data,\n                                                     size_t * upload_data_size,\n                                                     void ** con_cls) {\n#else\nstatic int ulfius_webservice_dispatcher (void * cls,\n                                         struct MHD_Connection * connection,\n                                         const char * url,\n                                         const char * method,\n                                         const char * version,\n                                         const char * upload_data,\n                                         size_t * upload_data_size,\n                                         void ** con_cls) {\n#endif\n\n  struct _u_endpoint * endpoint_list = ((struct _u_instance *)cls)->endpoint_list, ** current_endpoint_list = NULL, * current_endpoint = NULL;\n  struct connection_info_struct * con_info = * con_cls;\n  int mhd_ret = MHD_NO, callback_ret = U_OK, i, close_loop = 0, inner_error = U_OK, mhd_response_flag;\n#ifndef U_DISABLE_WEBSOCKET\n  // Websocket variables\n  int upgrade_protocol = 0;\n  char * protocol = NULL, * extension = NULL, ** extension_list = NULL;\n  size_t extension_len, x, y;\n#endif\n\n#ifndef U_DISABLE_GNUTLS\n  // Client certificate authentication variables\n  const union MHD_ConnectionInfo * ci;\n  unsigned int listsize;\n  const gnutls_datum_t * pcert;\n  gnutls_certificate_status_t client_cert_status = 0;\n  int ret_cert;\n#endif\n  char * content_type, * auth_realm = NULL;\n  struct _u_response * response = NULL;\n  struct sockaddr * so_client;\n\n  void * response_buffer = NULL;\n  size_t response_buffer_len = 0;\n\n  // Response variables\n  struct MHD_Response * mhd_response = NULL;\n\n  UNUSED(url);\n\n  // Prepare for POST or PUT input data\n  // Initialize the input maps\n  if (con_info == NULL) {\n    y_log_message(Y_LOG_LEVEL_ERROR, \"Ulfius - Error con_info is NULL\");\n    return MHD_NO;\n  }\n\n  if (con_info->u_instance == NULL) {\n    con_info->u_instance = (struct _u_instance *)cls;\n  }\n\n  if (con_info->callback_first_iteration) {\n#ifndef U_DISABLE_GNUTLS\n    ci = MHD_get_connection_info (connection, MHD_CONNECTION_INFO_GNUTLS_SESSION);\n    if (ci != NULL && ci->tls_session != NULL) {\n      if (((struct _u_instance *)cls)->use_client_cert_auth) {\n        if (((ret_cert = gnutls_certificate_verify_peers2(ci->tls_session, &client_cert_status)) != 0 && ret_cert != GNUTLS_E_NO_CERTIFICATE_FOUND) || client_cert_status != 0) {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"Ulfius - Error gnutls_certificate_verify_peers2\");\n        } else if (!ret_cert) {\n          pcert = gnutls_certificate_get_peers(ci->tls_session, &listsize);\n          if ((pcert == NULL) || (listsize == 0)) {\n            y_log_message(Y_LOG_LEVEL_ERROR, \"Ulfius - Failed to retrieve client certificate chain\");\n          } else if (gnutls_x509_crt_init(&(con_info->request->client_cert))) {\n            y_log_message(Y_LOG_LEVEL_ERROR, \"Ulfius - Failed to initialize client certificate\");\n          } else if (gnutls_x509_crt_import(con_info->request->client_cert, &pcert[0], GNUTLS_X509_FMT_DER)) {\n            y_log_message(Y_LOG_LEVEL_ERROR, \"Ulfius - Failed to import client certificate\");\n            gnutls_x509_crt_deinit(con_info->request->client_cert);\n          }\n        }\n      }\n    }\n#endif\n    con_info->callback_first_iteration = 0;\n    so_client = MHD_get_connection_info (connection, MHD_CONNECTION_INFO_CLIENT_ADDRESS)->client_addr;\n    con_info->has_post_processor = 0;\n    con_info->max_post_param_size = ((struct _u_instance *)cls)->max_post_param_size;\n    con_info->request->http_protocol = o_strdup(version);\n    con_info->request->http_verb = o_strdup(method);\n    con_info->request->client_address = o_malloc(sizeof(struct sockaddr));\n    if (con_info->request->client_address == NULL || con_info->request->http_verb == NULL) {\n      y_log_message(Y_LOG_LEVEL_ERROR, \"Ulfius - Error allocating client_address or http_verb\");\n      return MHD_NO;\n    }\n    memcpy(con_info->request->client_address, so_client, sizeof(struct sockaddr));\n    if (con_info->u_instance->check_utf8) {\n      MHD_get_connection_values (connection, MHD_HEADER_KIND, ulfius_fill_map_check_utf8, con_info->request->map_header);\n      MHD_get_connection_values (connection, MHD_GET_ARGUMENT_KIND, ulfius_fill_map_check_utf8, &con_info->map_url_initial);\n      MHD_get_connection_values (connection, MHD_COOKIE_KIND, ulfius_fill_map_check_utf8, con_info->request->map_cookie);\n    } else {\n      MHD_get_connection_values (connection, MHD_HEADER_KIND, ulfius_fill_map, con_info->request->map_header);\n      MHD_get_connection_values (connection, MHD_GET_ARGUMENT_KIND, ulfius_fill_map, &con_info->map_url_initial);\n      MHD_get_connection_values (connection, MHD_COOKIE_KIND, ulfius_fill_map, con_info->request->map_cookie);\n    }\n    content_type = (char*)u_map_get_case(con_info->request->map_header, ULFIUS_HTTP_HEADER_CONTENT);\n\n    // Set POST Processor if content-type is properly set\n    if (content_type != NULL && \n       (0 == o_strncmp(MHD_HTTP_POST_ENCODING_FORM_URLENCODED, content_type, o_strlen(MHD_HTTP_POST_ENCODING_FORM_URLENCODED)) ||\n        0 == o_strncmp(MHD_HTTP_POST_ENCODING_MULTIPART_FORMDATA, content_type, o_strlen(MHD_HTTP_POST_ENCODING_MULTIPART_FORMDATA)))) {\n      con_info->has_post_processor = 1;\n      con_info->post_processor = MHD_create_post_processor (connection, ULFIUS_POSTBUFFERSIZE, mhd_iterate_post_data, (void *) con_info);\n      if (NULL == con_info->post_processor) {\n        ulfius_clean_request_full(con_info->request);\n        con_info->request = NULL;\n        y_log_message(Y_LOG_LEVEL_ERROR, \"Ulfius - Error allocating post_processor\");\n        return MHD_NO;\n      }\n    }\n    return MHD_YES;\n  } else if (*upload_data_size != 0) {\n    size_t body_len = con_info->request->binary_body_length + *upload_data_size, upload_data_size_current = *upload_data_size;\n\n    if (((struct _u_instance *)cls)->max_post_body_size > 0 && con_info->request->binary_body_length + *upload_data_size > ((struct _u_instance *)cls)->max_post_body_size) {\n      body_len = ((struct _u_instance *)cls)->max_post_body_size;\n      upload_data_size_current = ((struct _u_instance *)cls)->max_post_body_size - con_info->request->binary_body_length;\n    }\n\n    if (body_len >= con_info->request->binary_body_length) {\n      con_info->request->binary_body = o_realloc(con_info->request->binary_body, body_len);\n      if (con_info->request->binary_body == NULL) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"Ulfius - Error allocating memory for con_info->request->binary_body\");\n        return MHD_NO;\n      } else {\n        memcpy((char*)con_info->request->binary_body + con_info->request->binary_body_length, upload_data, upload_data_size_current);\n        con_info->request->binary_body_length += upload_data_size_current;\n        // Handles request binary_body\n        const char * content_type = u_map_get_case(con_info->request->map_header, ULFIUS_HTTP_HEADER_CONTENT);\n        if (0 == o_strncmp(MHD_HTTP_POST_ENCODING_FORM_URLENCODED, content_type, o_strlen(MHD_HTTP_POST_ENCODING_FORM_URLENCODED)) ||\n            0 == o_strncmp(MHD_HTTP_POST_ENCODING_MULTIPART_FORMDATA, content_type, o_strlen(MHD_HTTP_POST_ENCODING_MULTIPART_FORMDATA))) {\n          MHD_post_process (con_info->post_processor, upload_data, *upload_data_size);\n        }\n        *upload_data_size = 0;\n        return MHD_YES;\n      }\n    } else {\n      return MHD_YES;\n    }\n  } else {\n    // Check if the endpoint has one or more matches\n    current_endpoint_list = ulfius_endpoint_match(method, con_info->request->url_path, endpoint_list);\n\n    // Set to default_endpoint if no match\n    if ((current_endpoint_list == NULL || current_endpoint_list[0] == NULL) && ((struct _u_instance *)cls)->default_endpoint != NULL && ((struct _u_instance *)cls)->default_endpoint->callback_function != NULL) {\n      current_endpoint_list = o_realloc(current_endpoint_list, 2*sizeof(struct _u_endpoint *));\n      if (current_endpoint_list != NULL) {\n        if ((current_endpoint_list[0] = o_malloc(sizeof(struct _u_endpoint))) != NULL) {\n          if (ulfius_copy_endpoint(current_endpoint_list[0], ((struct _u_instance *)cls)->default_endpoint) != U_OK) {\n            y_log_message(Y_LOG_LEVEL_ERROR, \"Ulfius - Error ulfius_copy_endpoint for current_endpoint_list[0]\");\n          }\n        } else {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"Ulfius - Error allocating memory for current_endpoint_list[0] of default endpoint\");\n        }\n        current_endpoint_list[1] = NULL;\n      } else {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"Ulfius - Error allocating memory for current_endpoint_list of default endpoint\");\n      }\n    }\n\n#if MHD_VERSION >= 0x00096100\n    mhd_response_flag = ((struct _u_instance *)cls)->mhd_response_copy_data?MHD_RESPMEM_MUST_COPY:MHD_RESPMEM_MUST_FREE;\n#else\n    mhd_response_flag = MHD_RESPMEM_MUST_FREE;\n#endif\n    if (current_endpoint_list[0] != NULL) {\n      response = o_malloc(sizeof(struct _u_response));\n      if (response == NULL) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"Ulfius - Error allocating response\");\n        mhd_ret = MHD_NO;\n      } else if (ulfius_init_response(response) != U_OK) {\n        o_free(response);\n        y_log_message(Y_LOG_LEVEL_ERROR, \"Ulfius - Error ulfius_init_response\");\n        mhd_ret = MHD_NO;\n      } else {\n        // Add default headers (if any) to the response header maps\n        if (((struct _u_instance *)cls)->default_headers != NULL && u_map_count(((struct _u_instance *)cls)->default_headers) > 0) {\n          u_map_clean_full(response->map_header);\n          response->map_header = u_map_copy(((struct _u_instance *)cls)->default_headers);\n        }\n\n        // Initialize auth variables\n        con_info->request->auth_basic_user = MHD_basic_auth_get_username_password(connection, &con_info->request->auth_basic_password);\n\n        for (i=0; current_endpoint_list[i] != NULL && !close_loop; i++) {\n          current_endpoint = current_endpoint_list[i];\n          u_map_empty(con_info->request->map_url);\n          u_map_copy_into(con_info->request->map_url, &con_info->map_url_initial);\n          if (ulfius_parse_url(con_info->request->url_path, current_endpoint, con_info->request->map_url, con_info->u_instance->check_utf8) != U_OK) {\n            o_free(response);\n            y_log_message(Y_LOG_LEVEL_ERROR, \"Ulfius - Error parsing url: \", con_info->request->url_path);\n            mhd_ret = MHD_NO;\n          }\n          // Run callback function with the input parameters filled for the current callback\n          callback_ret = current_endpoint->callback_function(con_info->request, response, current_endpoint->user_data);\n          if (callback_ret != U_CALLBACK_IGNORE) {\n            con_info->request->callback_position++;\n          }\n          if (response->timeout > 0 && MHD_set_connection_option(connection, MHD_CONNECTION_OPTION_TIMEOUT, response->timeout) !=  MHD_YES) {\n            y_log_message(Y_LOG_LEVEL_ERROR, \"Ulfius - Error setting connection response timeout value\");\n          }\n          if (response->stream_callback != NULL) {\n            // Call the stream_callback function to build the response binary_body\n            // A stram_callback is always the last one\n            mhd_response = MHD_create_response_from_callback(response->stream_size, response->stream_block_size, response->stream_callback, response->stream_user_data, response->stream_callback_free);\n            if (mhd_response == NULL) {\n              y_log_message(Y_LOG_LEVEL_ERROR, \"Ulfius - Error MHD_create_response_from_callback\");\n              mhd_ret = MHD_NO;\n            } else if (ulfius_set_response_header(mhd_response, response->map_header) == -1 || ulfius_set_response_cookie(mhd_response, response) == -1) {\n              y_log_message(Y_LOG_LEVEL_ERROR, \"Ulfius - Error setting headers or cookies\");\n              mhd_ret = MHD_NO;\n            }\n            close_loop = 1;\n#ifndef U_DISABLE_WEBSOCKET\n          } else if (((struct _websocket_handle *)response->websocket_handle)->websocket_manager_callback != NULL ||\n                     ((struct _websocket_handle *)response->websocket_handle)->websocket_incoming_message_callback != NULL) {\n            struct _websocket * websocket = o_malloc(sizeof(struct _websocket));\n            int websocket_has_error = 0;\n            if (websocket != NULL && ulfius_init_websocket(websocket) == U_OK) {\n              // if the session is a valid websocket request,\n              // Initiate an UPGRADE session,\n              // then run the websocket callback functions with initialized data\n              if (NULL != o_strcasestr(u_map_get_case(con_info->request->map_header, \"upgrade\"), U_WEBSOCKET_UPGRADE_VALUE) &&\n                  NULL != u_map_get_case(con_info->request->map_header, \"Sec-WebSocket-Key\") &&\n                  NULL != o_strcasestr(u_map_get_case(con_info->request->map_header, \"Connection\"), \"Upgrade\") &&\n                  0 == o_strcmp(con_info->request->http_protocol, \"HTTP/1.1\") &&\n                  0 == o_strcmp(u_map_get_case(con_info->request->map_header, \"Sec-WebSocket-Version\"), \"13\") &&\n                  0 == o_strcmp(con_info->request->http_verb, \"GET\")) {\n                int ret_protocol = U_ERROR, ret_extensions = U_OK;\n                // Check websocket_protocol and websocket_extensions to match ours\n                if (u_map_has_key(con_info->request->map_header, \"Sec-WebSocket-Extensions\") && (extension_len = pointer_list_size(((struct _websocket_handle *)response->websocket_handle)->websocket_extension_list))) {\n                  if (split_string(u_map_get_case(con_info->request->map_header, \"Sec-WebSocket-Extensions\"), \",\", &extension_list)) {\n                    for (x=0; extension_list[x]!=NULL; x++) {\n                      for (y=0; y<extension_len; y++) {\n                        struct _websocket_extension * ws_ext = (struct _websocket_extension *)pointer_list_get_at(((struct _websocket_handle *)response->websocket_handle)->websocket_extension_list, y);\n                        if (ws_ext != NULL && !ws_ext->enabled) {\n                          if (ws_ext->websocket_extension_server_match != NULL) {\n                            if (ws_ext->websocket_extension_server_match(trimwhitespace(extension_list[x]), (const char **)extension_list, &ws_ext->extension_client, ws_ext->websocket_extension_server_match_user_data, &ws_ext->context) == U_OK) {\n                              if (!(ws_ext->rsv & ((struct _websocket_handle *)response->websocket_handle)->rsv_expected)) {\n                                ((struct _websocket_handle *)response->websocket_handle)->rsv_expected |= ws_ext->rsv;\n                                ws_ext->enabled = 1;\n                                if (extension != NULL) {\n                                  extension = mstrcatf(extension, \", %s\", ws_ext->extension_client);\n                                } else {\n                                  extension = o_strdup(ws_ext->extension_client);\n                                }\n                              }\n                              break;\n                            }\n                          } else {\n                            if (0 == o_strcmp(extension_list[x], ws_ext->extension_server)) {\n                              if (!(ws_ext->rsv & ((struct _websocket_handle *)response->websocket_handle)->rsv_expected)) {\n                                ws_ext->extension_client = o_strdup(extension_list[x]);\n                                ((struct _websocket_handle *)response->websocket_handle)->rsv_expected |= ws_ext->rsv;\n                                ws_ext->enabled = 1;\n                                if (extension != NULL) {\n                                  extension = mstrcatf(extension, \", %s\", ws_ext->extension_client);\n                                } else {\n                                  extension = o_strdup(ws_ext->extension_client);\n                                }\n                                break;\n                              }\n                            }\n                          }\n                        }\n                      }\n                    }\n                  } else {\n                    y_log_message(Y_LOG_LEVEL_ERROR, \"Ulfius - Error split_string Sec-WebSocket-Extensions\");\n                  }\n                  free_string_array(extension_list);\n                } else {\n                  ret_extensions = ulfius_check_list_match(u_map_get_case(con_info->request->map_header, \"Sec-WebSocket-Extensions\"), ((struct _websocket_handle *)response->websocket_handle)->websocket_extensions, \",\", &extension);\n                }\n                if (ret_extensions == U_OK &&\n                    (ret_protocol = ulfius_check_first_match(u_map_get_case(con_info->request->map_header, \"Sec-WebSocket-Protocol\"), ((struct _websocket_handle *)response->websocket_handle)->websocket_protocol, \",\", &protocol)) == U_OK) {\n                  char websocket_accept[32] = {0};\n                  if (ulfius_generate_handshake_answer(u_map_get_case(con_info->request->map_header, \"Sec-WebSocket-Key\"), websocket_accept)) {\n                    websocket->request = ulfius_duplicate_request(con_info->request);\n                    if (websocket->request != NULL) {\n                      websocket->instance = (struct _u_instance *)cls;\n                      websocket->websocket_manager_callback = ((struct _websocket_handle *)response->websocket_handle)->websocket_manager_callback;\n                      websocket->websocket_manager_user_data = ((struct _websocket_handle *)response->websocket_handle)->websocket_manager_user_data;\n                      websocket->websocket_incoming_message_callback = ((struct _websocket_handle *)response->websocket_handle)->websocket_incoming_message_callback;\n                      websocket->websocket_incoming_user_data = ((struct _websocket_handle *)response->websocket_handle)->websocket_incoming_user_data;\n                      websocket->websocket_onclose_callback = ((struct _websocket_handle *)response->websocket_handle)->websocket_onclose_callback;\n                      websocket->websocket_onclose_user_data = ((struct _websocket_handle *)response->websocket_handle)->websocket_onclose_user_data;\n                      websocket->websocket_manager->rsv_expected = ((struct _websocket_handle *)response->websocket_handle)->rsv_expected;\n                      websocket->websocket_manager->websocket_extension_list = ((struct _websocket_handle *)response->websocket_handle)->websocket_extension_list;\n                      ((struct _websocket_handle *)response->websocket_handle)->websocket_extension_list = NULL;\n                      mhd_response = MHD_create_response_for_upgrade(ulfius_start_websocket_cb, websocket);\n                      if (mhd_response == NULL) {\n                        y_log_message(Y_LOG_LEVEL_ERROR, \"Ulfius - Error MHD_create_response_for_upgrade\");\n                        mhd_ret = MHD_NO;\n                      } else {\n                        MHD_add_response_header (mhd_response,\n                                                 MHD_HTTP_HEADER_UPGRADE,\n                                                 U_WEBSOCKET_UPGRADE_VALUE);\n                        MHD_add_response_header (mhd_response,\n                                                 \"Sec-WebSocket-Accept\",\n                                                 websocket_accept);\n                        MHD_add_response_header (mhd_response,\n                                                 \"Sec-WebSocket-Protocol\",\n                                                 protocol);\n                        if (o_strlen(extension)) {\n                          MHD_add_response_header (mhd_response,\n                                                   \"Sec-WebSocket-Extensions\",\n                                                   extension);\n                        }\n                        if (ulfius_set_response_header(mhd_response, response->map_header) == -1 || ulfius_set_response_cookie(mhd_response, response) == -1) {\n                          y_log_message(Y_LOG_LEVEL_ERROR, \"Ulfius - Error setting headers or cookies\");\n                          mhd_ret = MHD_NO;\n                          websocket_has_error = 1;\n                        } else {\n                          ulfius_instance_add_websocket_active((struct _u_instance *)cls, websocket);\n                          upgrade_protocol = 1;\n                        }\n                      }\n                    } else {\n                      // Error building struct _websocket, sending error 500\n                      response->status = MHD_HTTP_INTERNAL_SERVER_ERROR;\n                      response_buffer = o_strdup(ULFIUS_HTTP_ERROR_BODY);\n                      if (response_buffer == NULL) {\n                        y_log_message(Y_LOG_LEVEL_ERROR, \"Ulfius - Error allocating memory for websocket->request\");\n                        mhd_ret = MHD_NO;\n                      } else {\n                        response_buffer_len = o_strlen(ULFIUS_HTTP_ERROR_BODY);\n                        mhd_response = MHD_CREATE_RESPONSE_FROM_BUFFER_PIMPED (response_buffer_len, response_buffer, mhd_response_flag );\n                      }\n                      websocket_has_error = 1;\n                    }\n                  } else {\n                    // Error building ulfius_generate_handshake_answer, sending error 500\n                    response->status = MHD_HTTP_INTERNAL_SERVER_ERROR;\n                    response_buffer = o_strdup(ULFIUS_HTTP_ERROR_BODY);\n                    if (response_buffer == NULL) {\n                      y_log_message(Y_LOG_LEVEL_ERROR, \"Ulfius - Error allocating memory for response_buffer\");\n                      mhd_ret = MHD_NO;\n                    } else {\n                      response_buffer_len = o_strlen(ULFIUS_HTTP_ERROR_BODY);\n                      mhd_response = MHD_CREATE_RESPONSE_FROM_BUFFER_PIMPED (response_buffer_len, response_buffer, mhd_response_flag );\n                    }\n                    websocket_has_error = 1;\n                  }\n                } else {\n                  response->status = MHD_HTTP_BAD_REQUEST;\n                  response_buffer = msprintf(\"%s%s\", (ret_protocol!=U_OK?\"Error validating protocol\\n\":\"\"), (ret_extensions!=U_OK?\"Error validating extensions\":\"\"));\n                  y_log_message(Y_LOG_LEVEL_DEBUG, \"Ulfius - Error websocket connection: %s\", response_buffer);\n                  mhd_response = MHD_CREATE_RESPONSE_FROM_BUFFER_PIMPED (o_strlen(response_buffer), response_buffer, mhd_response_flag );\n                  websocket_has_error = 1;\n                }\n                o_free(protocol);\n                o_free(extension);\n              } else {\n                response_buffer = msprintf(\"%s%s%s%s%s%s\",\n                                           o_strcasestr(u_map_get_case(con_info->request->map_header, \"upgrade\"), U_WEBSOCKET_UPGRADE_VALUE)==NULL?\"No Upgrade websocket header\\n\":\"\",\n                                           o_strcasestr(u_map_get_case(con_info->request->map_header, \"Connection\"), \"Upgrade\")==NULL?\"No Connection Upgrade header\\n\":\"\",\n                                           u_map_get_case(con_info->request->map_header, \"Sec-WebSocket-Key\")==NULL?\"No Sec-WebSocket-Key header\\n\":\"\",\n                                           o_strcmp(con_info->request->http_protocol, \"HTTP/1.1\")!=0?\"Wrong HTTP Protocol\\n\":\"\",\n                                           o_strcmp(u_map_get_case(con_info->request->map_header, \"Sec-WebSocket-Version\"), \"13\")!=0?\"Wrong websocket version\\n\":\"\",\n                                           o_strcmp(con_info->request->http_verb, \"GET\")!=0?\"Method is not GET\\n\":\"\");\n                response->status = MHD_HTTP_BAD_REQUEST;\n                y_log_message(Y_LOG_LEVEL_DEBUG, \"Ulfius - Error websocket connection: %s\", response_buffer);\n                mhd_response = MHD_CREATE_RESPONSE_FROM_BUFFER_PIMPED (o_strlen(response_buffer), response_buffer, mhd_response_flag );\n                websocket_has_error = 1;\n              }\n            } else {\n              // Error building struct _websocket, sending error 500\n              response->status = MHD_HTTP_INTERNAL_SERVER_ERROR;\n              response_buffer = o_strdup(ULFIUS_HTTP_ERROR_BODY);\n              if (response_buffer == NULL) {\n                y_log_message(Y_LOG_LEVEL_ERROR, \"Ulfius - Error allocating memory for response_buffer\");\n                mhd_ret = MHD_NO;\n              } else {\n                response_buffer_len = o_strlen(ULFIUS_HTTP_ERROR_BODY);\n                mhd_response = MHD_CREATE_RESPONSE_FROM_BUFFER_PIMPED (response_buffer_len, response_buffer, mhd_response_flag );\n              }\n              websocket_has_error = 1;\n            }\n            close_loop = 1;\n            if (websocket_has_error) {\n              if (((struct _websocket_handle *)response->websocket_handle)->websocket_onclose_callback != NULL) {\n                ((struct _websocket_handle *)response->websocket_handle)->websocket_onclose_callback(con_info->request, websocket->websocket_manager!=NULL?websocket->websocket_manager:NULL, ((struct _websocket_handle *)response->websocket_handle)->websocket_onclose_user_data);\n              }\n              ulfius_clear_websocket(websocket);\n            }\n#endif\n          } else {\n            if ((callback_ret == U_CALLBACK_CONTINUE || callback_ret == U_CALLBACK_IGNORE) && current_endpoint_list[i+1] == NULL) {\n              // If callback_ret is U_CALLBACK_CONTINUE or U_CALLBACK_IGNORE but callback function is the last one on the list\n              callback_ret = U_CALLBACK_COMPLETE;\n            }\n            // Test callback_ret to know what to do\n            switch (callback_ret) {\n              case U_CALLBACK_CONTINUE:\n              case U_CALLBACK_IGNORE:\n                break;\n              case U_CALLBACK_COMPLETE:\n                close_loop = 1;\n                if (ulfius_get_body_from_response(response, &response_buffer, &response_buffer_len) == U_OK) {\n                  // Build the response binary_body\n                  mhd_response = MHD_CREATE_RESPONSE_FROM_BUFFER_PIMPED (response_buffer_len, response_buffer, mhd_response_flag );\n                  if (mhd_response == NULL) {\n                    y_log_message(Y_LOG_LEVEL_ERROR, \"Ulfius - Error MHD_create_response_from_buffer\");\n                    mhd_ret = MHD_NO;\n                  } else if (ulfius_set_response_header(mhd_response, response->map_header) == -1 || ulfius_set_response_cookie(mhd_response, response) == -1) {\n                    y_log_message(Y_LOG_LEVEL_ERROR, \"Ulfius - Error setting headers or cookies\");\n                    mhd_ret = MHD_NO;\n                  }\n                } else {\n                  // Error building response, sending error 500\n                  response->status = MHD_HTTP_INTERNAL_SERVER_ERROR;\n                  response_buffer = o_strdup(ULFIUS_HTTP_ERROR_BODY);\n                  if (response_buffer == NULL) {\n                    y_log_message(Y_LOG_LEVEL_ERROR, \"Ulfius - Error allocating memory for response_buffer\");\n                    mhd_ret = MHD_NO;\n                  } else {\n                    response_buffer_len = o_strlen(ULFIUS_HTTP_ERROR_BODY);\n                    mhd_response = MHD_CREATE_RESPONSE_FROM_BUFFER_PIMPED (response_buffer_len, response_buffer, mhd_response_flag );\n                  }\n                }\n                break;\n              case U_CALLBACK_UNAUTHORIZED:\n                close_loop = 1;\n                // Wrong credentials, send status 401 and realm value if set\n                if (ulfius_get_body_from_response(response, &response_buffer, &response_buffer_len) == U_OK) {\n                  mhd_response = MHD_CREATE_RESPONSE_FROM_BUFFER_PIMPED (response_buffer_len, response_buffer, mhd_response_flag );\n                  if (ulfius_set_response_header(mhd_response, response->map_header) == -1 || ulfius_set_response_cookie(mhd_response, response) == -1) {\n                    inner_error = U_ERROR_PARAMS;\n                    y_log_message(Y_LOG_LEVEL_ERROR, \"Ulfius - Error setting headers or cookies\");\n                    response->status = MHD_HTTP_INTERNAL_SERVER_ERROR;\n                    response->binary_body = o_strdup(ULFIUS_HTTP_ERROR_BODY);\n                    response->binary_body_length = o_strlen(ULFIUS_HTTP_ERROR_BODY);\n                    if (response->binary_body == NULL) {\n                      inner_error = U_ERROR_MEMORY;\n                      y_log_message(Y_LOG_LEVEL_ERROR, \"Ulfius - Error allocating memory for response->binary_body\");\n                      mhd_ret = MHD_NO;\n                    }\n                  } else {\n                    inner_error = U_CALLBACK_UNAUTHORIZED;\n                  }\n                } else {\n                  // Error building response, sending error 500\n                  response_buffer = o_strdup(ULFIUS_HTTP_ERROR_BODY);\n                  if (response_buffer == NULL) {\n                    inner_error = U_ERROR_MEMORY;\n                    y_log_message(Y_LOG_LEVEL_ERROR, \"Ulfius - Error allocating memory for response_buffer\");\n                    mhd_ret = MHD_NO;\n                  } else {\n                    response_buffer_len = o_strlen(ULFIUS_HTTP_ERROR_BODY);\n                    mhd_response = MHD_CREATE_RESPONSE_FROM_BUFFER_PIMPED (response_buffer_len, response_buffer, mhd_response_flag );\n                    inner_error = U_CALLBACK_UNAUTHORIZED;\n                  }\n                }\n                if (response->auth_realm != NULL) {\n                  auth_realm = response->auth_realm;\n                } else if (((struct _u_instance *)cls)->default_auth_realm != NULL) {\n                  auth_realm = ((struct _u_instance *)cls)->default_auth_realm;\n                }\n                break;\n              case U_CALLBACK_ERROR:\n              default:\n                close_loop = 1;\n                response->status = MHD_HTTP_INTERNAL_SERVER_ERROR;\n                response_buffer = o_strdup(ULFIUS_HTTP_ERROR_BODY);\n                if (response_buffer == NULL) {\n                  y_log_message(Y_LOG_LEVEL_ERROR, \"Ulfius - Error allocating memory for response_buffer\");\n                  mhd_ret = MHD_NO;\n                } else {\n                  response_buffer_len = o_strlen(ULFIUS_HTTP_ERROR_BODY);\n                  mhd_response = MHD_CREATE_RESPONSE_FROM_BUFFER_PIMPED (response_buffer_len, response_buffer, mhd_response_flag );\n                }\n                break;\n            }\n          }\n        }\n\n        if (!con_info->request->callback_position && ((struct _u_instance *)cls)->default_endpoint != NULL && ((struct _u_instance *)cls)->default_endpoint->callback_function != NULL && mhd_response == NULL) {\n          callback_ret = ((struct _u_instance *)cls)->default_endpoint->callback_function(con_info->request, response, ((struct _u_instance *)cls)->default_endpoint->user_data);\n          // Test callback_ret to know what to do\n          switch (callback_ret) {\n            case U_CALLBACK_UNAUTHORIZED:\n              // Wrong credentials, send status 401 and realm value if set\n              if (ulfius_get_body_from_response(response, &response_buffer, &response_buffer_len) == U_OK) {\n                mhd_response = MHD_CREATE_RESPONSE_FROM_BUFFER_PIMPED (response_buffer_len, response_buffer, mhd_response_flag );\n                if (ulfius_set_response_header(mhd_response, response->map_header) == -1 || ulfius_set_response_cookie(mhd_response, response) == -1) {\n                  inner_error = U_ERROR_PARAMS;\n                  y_log_message(Y_LOG_LEVEL_ERROR, \"Ulfius - Error setting headers or cookies\");\n                  response->status = MHD_HTTP_INTERNAL_SERVER_ERROR;\n                  response->binary_body = o_strdup(ULFIUS_HTTP_ERROR_BODY);\n                  response->binary_body_length = o_strlen(ULFIUS_HTTP_ERROR_BODY);\n                  if (response->binary_body == NULL) {\n                    inner_error = U_ERROR_MEMORY;\n                    y_log_message(Y_LOG_LEVEL_ERROR, \"Ulfius - Error allocating memory for response->binary_body\");\n                    mhd_ret = MHD_NO;\n                  }\n                } else {\n                  inner_error = U_CALLBACK_UNAUTHORIZED;\n                }\n              } else {\n                // Error building response, sending error 500\n                response_buffer = o_strdup(ULFIUS_HTTP_ERROR_BODY);\n                if (response_buffer == NULL) {\n                  inner_error = U_ERROR_MEMORY;\n                  y_log_message(Y_LOG_LEVEL_ERROR, \"Ulfius - Error allocating memory for response_buffer\");\n                  mhd_ret = MHD_NO;\n                } else {\n                  response_buffer_len = o_strlen(ULFIUS_HTTP_ERROR_BODY);\n                  mhd_response = MHD_CREATE_RESPONSE_FROM_BUFFER_PIMPED (response_buffer_len, response_buffer, mhd_response_flag );\n                  inner_error = U_CALLBACK_UNAUTHORIZED;\n                }\n              }\n              if (response->auth_realm != NULL) {\n                auth_realm = response->auth_realm;\n              } else if (((struct _u_instance *)cls)->default_auth_realm != NULL) {\n                auth_realm = ((struct _u_instance *)cls)->default_auth_realm;\n              }\n              break;\n            case U_CALLBACK_ERROR:\n              close_loop = 1;\n              response->status = MHD_HTTP_INTERNAL_SERVER_ERROR;\n              response_buffer = o_strdup(ULFIUS_HTTP_ERROR_BODY);\n              if (response_buffer == NULL) {\n                y_log_message(Y_LOG_LEVEL_ERROR, \"Ulfius - Error allocating memory for response_buffer\");\n                mhd_ret = MHD_NO;\n              } else {\n                response_buffer_len = o_strlen(ULFIUS_HTTP_ERROR_BODY);\n                mhd_response = MHD_CREATE_RESPONSE_FROM_BUFFER_PIMPED (response_buffer_len, response_buffer, mhd_response_flag );\n              }\n              break;\n            case U_CALLBACK_CONTINUE:\n            case U_CALLBACK_IGNORE:\n            case U_CALLBACK_COMPLETE:\n              if (ulfius_get_body_from_response(response, &response_buffer, &response_buffer_len) == U_OK) {\n                // Build the response binary_body\n                mhd_response = MHD_CREATE_RESPONSE_FROM_BUFFER_PIMPED (response_buffer_len, response_buffer, mhd_response_flag );\n                if (mhd_response == NULL) {\n                  y_log_message(Y_LOG_LEVEL_ERROR, \"Ulfius - Error MHD_create_response_from_buffer\");\n                  mhd_ret = MHD_NO;\n                } else if (ulfius_set_response_header(mhd_response, response->map_header) == -1 || ulfius_set_response_cookie(mhd_response, response) == -1) {\n                  y_log_message(Y_LOG_LEVEL_ERROR, \"Ulfius - Error setting headers or cookies\");\n                  mhd_ret = MHD_NO;\n                }\n              } else {\n                // Error building response, sending error 500\n                response->status = MHD_HTTP_INTERNAL_SERVER_ERROR;\n                response_buffer = o_strdup(ULFIUS_HTTP_ERROR_BODY);\n                if (response_buffer == NULL) {\n                  y_log_message(Y_LOG_LEVEL_ERROR, \"Ulfius - Error allocating memory for response_buffer\");\n                  mhd_ret = MHD_NO;\n                } else {\n                  response_buffer_len = o_strlen(ULFIUS_HTTP_ERROR_BODY);\n                  mhd_response = MHD_CREATE_RESPONSE_FROM_BUFFER_PIMPED (response_buffer_len, response_buffer, mhd_response_flag );\n                }\n              }\n              break;\n            default:\n              break;\n          }\n        }\n\n        if (mhd_response != NULL) {\n          if (auth_realm != NULL && inner_error == U_CALLBACK_UNAUTHORIZED) {\n            mhd_ret = MHD_queue_basic_auth_fail_response (connection, auth_realm, mhd_response);\n          } else if (inner_error == U_CALLBACK_UNAUTHORIZED) {\n            mhd_ret = MHD_queue_response (connection, MHD_HTTP_UNAUTHORIZED, mhd_response);\n#ifndef U_DISABLE_WEBSOCKET\n          } else if (upgrade_protocol) {\n            mhd_ret = MHD_queue_response (connection,\n                                          MHD_HTTP_SWITCHING_PROTOCOLS,\n                                          mhd_response);\n#endif\n          } else {\n            mhd_ret = MHD_queue_response (connection, response->status, mhd_response);\n          }\n          MHD_destroy_response (mhd_response);\n          // Free Response parameters\n          if (response->free_shared_data != NULL && response->shared_data != NULL) {\n            response->free_shared_data(response->shared_data);\n          }\n          ulfius_clean_response_full(response);\n          response = NULL;\n        }\n      }\n    } else {\n      response_buffer = o_strdup(ULFIUS_HTTP_NOT_FOUND_BODY);\n      if (response_buffer == NULL) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"Ulfius - Error allocating memory for response_buffer\");\n        mhd_ret = MHD_NO;\n      } else {\n        response_buffer_len = o_strlen(ULFIUS_HTTP_NOT_FOUND_BODY);\n        mhd_response = MHD_CREATE_RESPONSE_FROM_BUFFER_PIMPED (response_buffer_len, response_buffer, mhd_response_flag );\n        mhd_ret = MHD_queue_response (connection, MHD_HTTP_NOT_FOUND, mhd_response);\n        MHD_destroy_response (mhd_response);\n      }\n    }\n#if MHD_VERSION < 0x00096100\n    if (mhd_response_flag == MHD_RESPMEM_MUST_COPY) {\n      o_free(response_buffer);\n    }\n#else\n    (void)mhd_response_flag;\n#endif\n    for (i=0; current_endpoint_list[i] != NULL; i++) {\n      ulfius_clean_endpoint(current_endpoint_list[i]);\n      o_free(current_endpoint_list[i]);\n    }\n    o_free(current_endpoint_list);\n    return mhd_ret;\n  }\n}\n\n/**\n * ulfius_run_mhd_daemon\n * Starts a mhd daemon for the specified instance\n * return a pointer to the mhd_daemon on success, NULL on error\n *\n */\nstatic struct MHD_Daemon * ulfius_run_mhd_daemon(struct _u_instance * u_instance, const char * key_pem, const char * cert_pem, const char * root_ca_perm) {\n  unsigned int mhd_flags = MHD_USE_THREAD_PER_CONNECTION;\n  int index;\n\n#ifdef DEBUG\n  mhd_flags |= MHD_USE_DEBUG;\n#endif\n#if MHD_VERSION >= 0x00095300\n  mhd_flags |= MHD_USE_INTERNAL_POLLING_THREAD;\n#endif\n#ifndef U_DISABLE_WEBSOCKET\n  mhd_flags |= MHD_ALLOW_UPGRADE;\n#endif\n\n  if (u_instance->mhd_daemon == NULL) {\n    struct MHD_OptionItem mhd_ops[8];\n\n    // Default options\n    mhd_ops[0].option = MHD_OPTION_NOTIFY_COMPLETED;\n    mhd_ops[0].value = (intptr_t)mhd_request_completed;\n    mhd_ops[0].ptr_value = NULL;\n\n#if MHD_VERSION >= 0x00095208\n    // If bind_address6 is specified, listen only to IPV6 addresses\n    if (u_instance->bind_address6 != NULL) {\n      mhd_ops[1].option = MHD_OPTION_SOCK_ADDR;\n      mhd_ops[1].value = 0;\n      mhd_ops[1].ptr_value = (void *)u_instance->bind_address6;\n      mhd_flags |= MHD_USE_IPv6;\n    } else {\n      mhd_ops[1].option = MHD_OPTION_SOCK_ADDR;\n      mhd_ops[1].value = 0;\n      mhd_ops[1].ptr_value = (void *)u_instance->bind_address;\n      // Default network stack is listening to IPV4 only\n      if ((u_instance->network_type & U_USE_IPV4) && (u_instance->network_type & U_USE_IPV6)) {\n        // If u_instance->network_type & U_USE_ALL, listen to IPV4 and IPV6 addresses\n        mhd_flags |= MHD_USE_DUAL_STACK;\n      } else if (u_instance->network_type & U_USE_IPV6) {\n        // If u_instance->network_type & U_USE_IPV6, listen to IPV6 addresses only\n        mhd_flags |= MHD_USE_IPv6;\n      }\n    }\n#else\n    mhd_ops[1].option = MHD_OPTION_SOCK_ADDR;\n    mhd_ops[1].value = 0;\n    mhd_ops[1].ptr_value = (void *)u_instance->bind_address;\n#endif\n\n    mhd_ops[2].option = MHD_OPTION_URI_LOG_CALLBACK;\n    mhd_ops[2].value = (intptr_t)ulfius_uri_logger;\n    mhd_ops[2].ptr_value = NULL;\n\n    index = 3;\n\n    if (key_pem != NULL && cert_pem != NULL) {\n      // HTTPS parameters\n      mhd_flags |= MHD_USE_SSL;\n      mhd_ops[index].option = MHD_OPTION_HTTPS_MEM_KEY;\n      mhd_ops[index].value = 0;\n      mhd_ops[index].ptr_value = (void*)key_pem;\n\n      mhd_ops[index + 1].option = MHD_OPTION_HTTPS_MEM_CERT;\n      mhd_ops[index + 1].value = 0;\n      mhd_ops[index + 1].ptr_value = (void*)cert_pem;\n\n      index += 2;\n\n      if (root_ca_perm != NULL) {\n        mhd_ops[index].option = MHD_OPTION_HTTPS_MEM_TRUST;\n        mhd_ops[index].value = 0;\n        mhd_ops[index].ptr_value = (void *)root_ca_perm;\n\n        index++;\n      }\n    }\n    if (u_instance->timeout > 0) {\n      mhd_ops[index].option = MHD_OPTION_CONNECTION_TIMEOUT;\n      mhd_ops[index].value = u_instance->timeout;\n      mhd_ops[index].ptr_value = NULL;\n\n      index++;\n    }\n\n    mhd_ops[index].option = MHD_OPTION_END;\n    mhd_ops[index].value = 0;\n    mhd_ops[index].ptr_value = NULL;\n\n    return MHD_start_daemon (\n      mhd_flags, u_instance->port, NULL, NULL, &ulfius_webservice_dispatcher, (void *)u_instance,\n      MHD_OPTION_ARRAY, mhd_ops,\n      MHD_OPTION_END\n    );\n  } else {\n    y_log_message(Y_LOG_LEVEL_ERROR, \"Ulfius - Error, instance already started\");\n    return NULL;\n  }\n}\n\n/**\n * ulfius_start_framework\n * Initializes the framework and run the webservice based on the parameters given\n * return true if no error\n *\n * u_instance:    pointer to a struct _u_instance that describe its port and bind address\n * return U_OK on success\n */\nint ulfius_start_framework(struct _u_instance * u_instance) {\n#ifndef U_DISABLE_GNUTLS\n  return ulfius_start_secure_ca_trust_framework(u_instance, NULL, NULL, NULL);\n#else\n  return ulfius_start_secure_framework(u_instance, NULL, NULL);\n#endif\n}\n\n/**\n * ulfius_start_secure_framework\n * Initializes the framework and run the webservice based on the parameters given using an HTTPS connection\n *\n * u_instance:    pointer to a struct _u_instance that describe its port and bind address\n * key_pem:       private key for the server\n * cert_pem:      server certificate\n * return U_OK on success\n */\nint ulfius_start_secure_framework(struct _u_instance * u_instance, const char * key_pem, const char * cert_pem) {\n#ifndef U_DISABLE_GNUTLS\n  return ulfius_start_secure_ca_trust_framework(u_instance, key_pem, cert_pem, NULL);\n#else\n#ifndef U_DISABLE_JANSSON\n  o_malloc_t malloc_fn;\n  o_free_t free_fn;\n\n  o_get_alloc_funcs(&malloc_fn, NULL, &free_fn);\n  json_set_alloc_funcs((json_malloc_t)malloc_fn, (json_free_t)free_fn);\n#endif\n  // Check parameters and validate u_instance and endpoint_list that there is no mistake\n  if (u_instance == NULL) {\n    y_log_message(Y_LOG_LEVEL_ERROR, \"Ulfius - ulfius_start_secure_framework - Error, u_instance is NULL\");\n    return U_ERROR_PARAMS;\n  } else if ((key_pem == NULL && cert_pem != NULL) || (key_pem != NULL && cert_pem == NULL)) {\n    y_log_message(Y_LOG_LEVEL_ERROR, \"Ulfius - ulfius_start_secure_framework - Error, you must specify key_pem and cert_pem\");\n    return U_ERROR_PARAMS;\n  }\n  if (ulfius_validate_instance(u_instance) == U_OK) {\n    u_instance->mhd_daemon = ulfius_run_mhd_daemon(u_instance, key_pem, cert_pem, NULL);\n\n    if (u_instance->mhd_daemon == NULL) {\n      y_log_message(Y_LOG_LEVEL_ERROR, \"Ulfius - Error MHD_start_daemon, aborting\");\n      u_instance->status = U_STATUS_ERROR;\n      return U_ERROR_LIBMHD;\n    } else {\n      u_instance->status = U_STATUS_RUNNING;\n      return U_OK;\n    }\n  } else {\n    y_log_message(Y_LOG_LEVEL_ERROR, \"Ulfius - ulfius_start_secure_framework - error input parameters\");\n    return U_ERROR_PARAMS;\n  }\n#endif\n}\n\n#ifndef U_DISABLE_GNUTLS\n/**\n * ulfius_start_secure_ca_trust_framework\n * Initializes the framework and run the webservice based on the parameters given using an HTTPS connection\n * And using a root server to authenticate client connections\n *\n * u_instance:    pointer to a struct _u_instance that describe its port and bind address\n * key_pem:       private key for the server\n * cert_pem:      server certificate\n * root_ca_pem:   client root CA you're willing to trust for this instance\n * return U_OK on success\n */\nint ulfius_start_secure_ca_trust_framework(struct _u_instance * u_instance, const char * key_pem, const char * cert_pem, const char * root_ca_pem) {\n#ifndef U_DISABLE_JANSSON\n  o_malloc_t malloc_fn;\n  o_free_t free_fn;\n\n  o_get_alloc_funcs(&malloc_fn, NULL, &free_fn);\n  json_set_alloc_funcs((json_malloc_t)malloc_fn, (json_free_t)free_fn);\n#endif\n  // Check parameters and validate u_instance and endpoint_list that there is no mistake\n  if (u_instance == NULL) {\n    y_log_message(Y_LOG_LEVEL_ERROR, \"Ulfius - ulfius_start_secure_ca_trust_framework - Error, u_instance is NULL\");\n    return U_ERROR_PARAMS;\n  } else if ((key_pem == NULL && cert_pem != NULL) || (key_pem != NULL && cert_pem == NULL)) {\n    y_log_message(Y_LOG_LEVEL_ERROR, \"Ulfius - ulfius_start_secure_ca_trust_framework - Error, you must specify key_pem and cert_pem\");\n    return U_ERROR_PARAMS;\n  } else if (root_ca_pem != NULL && (key_pem == NULL || cert_pem == NULL)) {\n    y_log_message(Y_LOG_LEVEL_ERROR, \"Ulfius - ulfius_start_secure_ca_trust_framework - Error, you must specify key_pem and cert_pem in addition to root_ca_pem\");\n    return U_ERROR_PARAMS;\n  }\n  if (root_ca_pem != NULL) {\n    u_instance->use_client_cert_auth = 1;\n  } else {\n    u_instance->use_client_cert_auth = 0;\n  }\n  if (ulfius_validate_instance(u_instance) == U_OK) {\n    u_instance->mhd_daemon = ulfius_run_mhd_daemon(u_instance, key_pem, cert_pem, root_ca_pem);\n\n    if (u_instance->mhd_daemon == NULL) {\n      y_log_message(Y_LOG_LEVEL_ERROR, \"Ulfius - Error MHD_start_daemon, aborting\");\n      u_instance->status = U_STATUS_ERROR;\n      return U_ERROR_LIBMHD;\n    } else {\n      u_instance->status = U_STATUS_RUNNING;\n      return U_OK;\n    }\n  } else {\n    y_log_message(Y_LOG_LEVEL_ERROR, \"Ulfius - ulfius_start_secure_ca_trust_framework - error input parameters\");\n    return U_ERROR_PARAMS;\n  }\n}\n#endif\n\n/**\n * ulfius_start_framework_with_mhd_options\n * Initializes the framework and run the webservice based on the specified MHD options table given in parameter\n * Read https://www.gnu.org/software/libmicrohttpd/tutorial.html for more information\n * This is for user who know what they do, Ulfius' options used in other `ulfius_start_framework_*`\n * are good for most use cases where you need a multi-threaded HTTP webservice\n * Some struct MHD_OptionItem may cause unexpected problems with Ulfius API\n * If you find an unresolved issue with this function you can open an issue in GitHub\n * But some issues may not be solvable if fixing them would break Ulfius API or philosophy\n * i.e.: you're on your own\n * @param u_instance pointer to a struct _u_instance that describe its port and bind address\n * @param mhd_flags OR-ed combination of MHD_FLAG values\n * @param mhd_ops struct MHD_OptionItem * options table\n * - MUST contain an option with the fllowing value: {.option = MHD_OPTION_NOTIFY_COMPLETED; .value = (intptr_t)mhd_request_completed; .ptr_value = NULL;}\n * - MUST contain an option with the fllowing value: {.option = MHD_OPTION_URI_LOG_CALLBACK; .value = (intptr_t)ulfius_uri_logger; .ptr_value = NULL;}\n * - MUST end with a terminal struct MHD_OptionItem: {.option = MHD_OPTION_END; .value = 0; .ptr_value = NULL;}\n * @return U_OK on success\n */\nint ulfius_start_framework_with_mhd_options(struct _u_instance * u_instance, unsigned int mhd_flags, struct MHD_OptionItem * mhd_ops) {\n  if (u_instance == NULL) {\n    y_log_message(Y_LOG_LEVEL_ERROR, \"Ulfius - ulfius_start_framework_with_mhd_options - Error, u_instance is NULL\");\n    return U_ERROR_PARAMS;\n  } else if (mhd_ops == NULL) {\n    y_log_message(Y_LOG_LEVEL_ERROR, \"Ulfius - ulfius_start_framework_with_mhd_options - Error, mhd_ops is NULL\");\n    return U_ERROR_PARAMS;\n  } else {\n    u_instance->mhd_daemon = MHD_start_daemon (mhd_flags, u_instance->port, NULL, NULL, &ulfius_webservice_dispatcher, (void *)u_instance, MHD_OPTION_ARRAY, mhd_ops, MHD_OPTION_END);\n    if (u_instance->mhd_daemon != NULL) {\n      u_instance->status = U_STATUS_RUNNING;\n      return U_OK;\n    } else {\n      y_log_message(Y_LOG_LEVEL_ERROR, \"Ulfius - ulfius_start_framework_with_mhd_options - Error MHD_start_daemon, aborting\");\n      u_instance->status = U_STATUS_ERROR;\n      return U_ERROR_LIBMHD;\n    }\n  }\n}\n\n/**\n * ulfius_stop_framework\n *\n * Stop the webservice\n * u_instance:    pointer to a struct _u_instance that describe its port and bind address\n * return U_OK on success\n */\nint ulfius_stop_framework(struct _u_instance * u_instance) {\n  if (u_instance != NULL && u_instance->mhd_daemon != NULL) {\n#ifndef U_DISABLE_WEBSOCKET\n    int i;\n    // Loop in all active websockets and send close signal\n    if (pthread_mutex_lock(&((struct _websocket_handler *)u_instance->websocket_handler)->websocket_active_lock)) {\n      y_log_message(Y_LOG_LEVEL_ERROR, \"Ulfius - Error locking websocket websocket_active_lock\");\n    } else {\n      for (i=((struct _websocket_handler *)u_instance->websocket_handler)->nb_websocket_active-1; i>=0; i--) {\n        ((struct _websocket_handler *)u_instance->websocket_handler)->websocket_active[i]->websocket_manager->close_flag = 1;\n      }\n      pthread_mutex_unlock(&((struct _websocket_handler *)u_instance->websocket_handler)->websocket_active_lock);\n    }\n    pthread_mutex_lock(&((struct _websocket_handler *)u_instance->websocket_handler)->websocket_close_lock);\n    while (((struct _websocket_handler *)u_instance->websocket_handler)->nb_websocket_active > 0) {\n      pthread_cond_wait(&((struct _websocket_handler *)u_instance->websocket_handler)->websocket_close_cond, &((struct _websocket_handler *)u_instance->websocket_handler)->websocket_close_lock);\n    }\n    pthread_mutex_unlock(&((struct _websocket_handler *)u_instance->websocket_handler)->websocket_close_lock);\n#endif\n    MHD_stop_daemon (u_instance->mhd_daemon);\n    u_instance->mhd_daemon = NULL;\n    u_instance->status = U_STATUS_STOP;\n    return U_OK;\n  } else if (u_instance != NULL) {\n    u_instance->status = U_STATUS_ERROR;\n    return U_ERROR_PARAMS;\n  } else {\n    return U_ERROR;\n  }\n}\n\n/**\n * ulfius_copy_endpoint\n * return a copy of an endpoint with duplicate values\n */\nint ulfius_copy_endpoint(struct _u_endpoint * dest, const struct _u_endpoint * source) {\n  if (source != NULL && dest != NULL) {\n    dest->http_method = o_strdup(source->http_method);\n    dest->url_prefix = o_strdup(source->url_prefix);\n    dest->url_format = o_strdup(source->url_format);\n    dest->callback_function = source->callback_function;\n    dest->user_data = source->user_data;\n    dest->priority = source->priority;\n    if (ulfius_is_valid_endpoint(dest, 0)) {\n      return U_OK;\n    } else {\n      return U_ERROR_MEMORY;\n    }\n  }\n  return U_ERROR_PARAMS;\n}\n\n/**\n * duplicate_endpoint_list\n * return a copy of an endpoint list with duplicate values\n * returned value must be free'd after use\n */\nstruct _u_endpoint * ulfius_duplicate_endpoint_list(const struct _u_endpoint * endpoint_list) {\n  struct _u_endpoint * to_return = NULL;\n  int i;\n\n  if (endpoint_list != NULL) {\n    for (i=0; endpoint_list[i].http_method != NULL; i++) {\n      if ((to_return = o_realloc(to_return, (i+1)*sizeof(struct _u_endpoint *))) == NULL) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"Ulfius - Error allocating memory for duplicate_endpoint_list.to_return\");\n        return NULL;\n      } else {\n        ulfius_copy_endpoint(&to_return[i], &endpoint_list[i]);\n      }\n    }\n  }\n  return to_return;\n}\n\n/**\n * clean_endpoint\n * free allocated memory by an endpoint\n */\nvoid ulfius_clean_endpoint(struct _u_endpoint * endpoint) {\n  if (endpoint != NULL) {\n    o_free(endpoint->http_method);\n    o_free(endpoint->url_prefix);\n    o_free(endpoint->url_format);\n    endpoint->http_method = NULL;\n    endpoint->url_prefix = NULL;\n    endpoint->url_format = NULL;\n  }\n}\n\n/**\n * ulfius_clean_endpoint_list\n * free allocated memory by an endpoint list\n */\nvoid ulfius_clean_endpoint_list(struct _u_endpoint * endpoint_list) {\n  int i;\n\n  if (endpoint_list != NULL) {\n    for (i=0; endpoint_list[i].http_method != NULL; i++) {\n      ulfius_clean_endpoint(&endpoint_list[i]);\n    }\n    o_free(endpoint_list);\n  }\n}\n\nint ulfius_add_endpoint(struct _u_instance * u_instance, const struct _u_endpoint * u_endpoint) {\n  int res;\n\n  if (u_instance != NULL && u_endpoint != NULL) {\n    if (ulfius_is_valid_endpoint(u_endpoint, 0)) {\n      if (u_instance->endpoint_list == NULL) {\n        // No endpoint, create a list with 2 endpoints so the last one is an empty one\n        u_instance->endpoint_list = o_malloc(2 * sizeof(struct _u_endpoint));\n        if (u_instance->endpoint_list == NULL) {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"Ulfius - ulfius_add_endpoint, Error allocating memory for u_instance->endpoint_list\");\n          return U_ERROR_MEMORY;\n        }\n        u_instance->nb_endpoints = 1;\n      } else {\n        u_instance->nb_endpoints++;\n        u_instance->endpoint_list = o_realloc(u_instance->endpoint_list, (u_instance->nb_endpoints + 1) * sizeof(struct _u_endpoint));\n        if (u_instance->endpoint_list == NULL) {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"Ulfius - ulfius_add_endpoint, Error reallocating memory for u_instance->endpoint_list\");\n          return U_ERROR_MEMORY;\n        }\n      }\n      res = ulfius_copy_endpoint(&u_instance->endpoint_list[u_instance->nb_endpoints - 1], u_endpoint);\n      if (res != U_OK) {\n        return res;\n      } else {\n        // Add empty endpoint at the end of the endpoint list\n        ulfius_copy_endpoint(&u_instance->endpoint_list[u_instance->nb_endpoints], ulfius_empty_endpoint());\n      }\n      return U_OK;\n    } else {\n      y_log_message(Y_LOG_LEVEL_ERROR, \"Ulfius - ulfius_add_endpoint, invalid struct _u_endpoint\");\n      return U_ERROR_PARAMS;\n    }\n  } else {\n    y_log_message(Y_LOG_LEVEL_ERROR, \"Ulfius - ulfius_add_endpoint, invalid parameters\");\n    return U_ERROR_PARAMS;\n  }\n  return U_ERROR;\n}\n\nint ulfius_add_endpoint_list(struct _u_instance * u_instance, const struct _u_endpoint ** u_endpoint_list) {\n  int i, res;\n  if (u_instance != NULL && u_endpoint_list != NULL) {\n    for (i=0; !ulfius_equals_endpoints(u_endpoint_list[i], ulfius_empty_endpoint()); i++) {\n      res = ulfius_add_endpoint(u_instance, u_endpoint_list[i]);\n      if (res != U_OK) {\n        return res;\n      }\n    }\n    return U_OK;\n  } else {\n    y_log_message(Y_LOG_LEVEL_ERROR, \"Ulfius - ulfius_add_endpoint_list, invalid parameters\");\n    return U_ERROR_PARAMS;\n  }\n  return U_ERROR;\n}\n\nint ulfius_remove_endpoint(struct _u_instance * u_instance, const struct _u_endpoint * u_endpoint) {\n  int i, j, found = 0, ret = U_OK;\n  char * trim_prefix = NULL, * trim_prefix_save = NULL, * trim_format = NULL, * trim_format_save = NULL,\n       * trim_cur_prefix = NULL, * trim_cur_prefix_save = NULL, * trim_cur_format = NULL, * trim_cur_format_save = NULL;\n  if (u_instance != NULL && u_endpoint != NULL && !ulfius_equals_endpoints(u_endpoint, ulfius_empty_endpoint()) && ulfius_is_valid_endpoint(u_endpoint, 1)) {\n    trim_prefix_save = o_strdup(u_endpoint->url_prefix);\n    trim_prefix = trimcharacter(trim_prefix_save, '/');\n    trim_format_save = o_strdup(u_endpoint->url_format);\n    trim_format = trimcharacter(trim_format_save, '/');\n    for (i=u_instance->nb_endpoints-1; i>=0 && ret == U_OK; i--) {\n      trim_cur_prefix_save = o_strdup(u_instance->endpoint_list[i].url_prefix);\n      trim_cur_prefix = trimcharacter(trim_cur_prefix_save, '/');\n      trim_cur_format_save = o_strdup(u_instance->endpoint_list[i].url_format);\n      trim_cur_format = trimcharacter(trim_cur_format_save, '/');\n\n      // Compare u_endpoint with u_instance->endpoint_list[i]\n      if (0 == o_strcmp(u_instance->endpoint_list[i].http_method, u_endpoint->http_method) &&\n          0 == o_strcmp(trim_cur_prefix, trim_prefix) &&\n          0 == o_strcmp(trim_cur_format, trim_format)) {\n        // It's a match!\n        // Remove current endpoint and move the next ones to their previous index, then reduce the endpoint_list by 1\n        found = 1;\n        o_free(u_instance->endpoint_list[i].http_method);\n        o_free(u_instance->endpoint_list[i].url_prefix);\n        o_free(u_instance->endpoint_list[i].url_format);\n        for (j=i; j<u_instance->nb_endpoints; j++) {\n          u_instance->endpoint_list[j] = u_instance->endpoint_list[j+1];\n        }\n        u_instance->nb_endpoints--;\n        u_instance->endpoint_list = o_realloc(u_instance->endpoint_list, (u_instance->nb_endpoints + 1)*sizeof(struct _u_endpoint));\n        if (u_instance->endpoint_list == NULL) {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"Ulfius - ulfius_add_endpoint, Error reallocating memory for u_instance->endpoint_list\");\n          ret = U_ERROR_MEMORY;\n        }\n      }\n      o_free(trim_cur_prefix_save);\n      o_free(trim_cur_format_save);\n      trim_cur_prefix_save = NULL;\n      trim_cur_format_save = NULL;\n    }\n    if (!found) {\n      ret = U_ERROR_NOT_FOUND;\n    }\n    o_free(trim_prefix_save);\n    o_free(trim_format_save);\n    trim_prefix_save = NULL;\n    trim_format_save = NULL;\n  } else {\n    y_log_message(Y_LOG_LEVEL_ERROR, \"Ulfius - ulfius_remove_endpoint, invalid parameters\");\n    ret = U_ERROR_PARAMS;\n  }\n  return ret;\n}\n\nconst struct _u_endpoint * ulfius_empty_endpoint(void) {\n  static struct _u_endpoint empty_endpoint;\n\n  empty_endpoint.http_method = NULL;\n  empty_endpoint.url_prefix = NULL;\n  empty_endpoint.url_format = NULL;\n  empty_endpoint.callback_function = NULL;\n  empty_endpoint.user_data = NULL;\n  return &empty_endpoint;\n}\n\nint ulfius_equals_endpoints(const struct _u_endpoint * endpoint1, const struct _u_endpoint * endpoint2) {\n  if (endpoint1 != NULL && endpoint2 != NULL) {\n    if (endpoint1 == endpoint2) {\n      return 1;\n    } else if (o_strcmp(endpoint2->http_method, endpoint1->http_method) != 0) {\n        return 0;\n    } else if (o_strcmp(endpoint2->url_prefix, endpoint1->url_prefix) != 0) {\n        return 0;\n    } else if (o_strcmp(endpoint2->url_format, endpoint1->url_format) != 0) {\n        return 0;\n    } else {\n      return 1;\n    }\n  } else {\n    return 1;\n  }\n}\n\nint ulfius_add_endpoint_by_val(struct _u_instance * u_instance,\n                               const char * http_method,\n                               const char * url_prefix,\n                               const char * url_format,\n                               unsigned int priority,\n                               int (* callback_function)(const struct _u_request * request, // Input parameters (set by the framework)\n                                                         struct _u_response * response,     // Output parameters (set by the user)\n                                                         void * user_data),\n                               void * user_data) {\n  struct _u_endpoint endpoint;\n  if (u_instance != NULL) {\n    endpoint.http_method = (char *)http_method;\n    endpoint.url_prefix = (char *)url_prefix;\n    endpoint.url_format = (char *)url_format;\n    endpoint.priority = priority;\n    endpoint.callback_function = callback_function;\n    endpoint.user_data = user_data;\n    return ulfius_add_endpoint(u_instance, &endpoint);\n  } else {\n    return U_ERROR_PARAMS;\n  }\n}\n\nint ulfius_remove_endpoint_by_val(struct _u_instance * u_instance, const char * http_method, const char * url_prefix, const char * url_format) {\n  struct _u_endpoint endpoint;\n  if (u_instance != NULL) {\n    endpoint.http_method = (char *)http_method;\n    endpoint.url_prefix = (char *)url_prefix;\n    endpoint.url_format = (char *)url_format;\n    endpoint.callback_function = NULL;\n    return ulfius_remove_endpoint(u_instance, &endpoint);\n  } else {\n    return U_ERROR_PARAMS;\n  }\n}\n\nint ulfius_set_default_endpoint(struct _u_instance * u_instance,\n                                         int (* callback_function)(const struct _u_request * request, struct _u_response * response, void * user_data),\n                                         void * user_data) {\n  if (u_instance != NULL && callback_function != NULL) {\n    if (u_instance->default_endpoint == NULL) {\n      u_instance->default_endpoint = o_malloc(sizeof(struct _u_endpoint));\n      if (u_instance->default_endpoint == NULL) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"Ulfius - Error allocating memory for u_instance->default_endpoint\");\n        return U_ERROR_MEMORY;\n      }\n    }\n    u_instance->default_endpoint->http_method = NULL;\n    u_instance->default_endpoint->url_prefix = NULL;\n    u_instance->default_endpoint->url_format = NULL;\n    u_instance->default_endpoint->callback_function = callback_function;\n    u_instance->default_endpoint->user_data = user_data;\n    u_instance->default_endpoint->priority = 0;\n    return U_OK;\n  } else {\n    return U_ERROR_PARAMS;\n  }\n}\n\nint ulfius_set_upload_file_callback_function(struct _u_instance * u_instance,\n                                             int (* file_upload_callback) (const struct _u_request * request,\n                                                                           const char * key,\n                                                                           const char * filename,\n                                                                           const char * content_type,\n                                                                           const char * transfer_encoding,\n                                                                           const char * data,\n                                                                           uint64_t off,\n                                                                           size_t size,\n                                                                           void * cls),\n                                             void * cls) {\n  if (u_instance != NULL && file_upload_callback != NULL) {\n    u_instance->file_upload_callback = file_upload_callback;\n    u_instance->file_upload_cls = cls;\n    return U_OK;\n  } else {\n    return U_ERROR_PARAMS;\n  }\n}\n\nvoid ulfius_clean_instance(struct _u_instance * u_instance) {\n  if (u_instance != NULL) {\n    ulfius_clean_endpoint_list(u_instance->endpoint_list);\n    u_map_clean_full(u_instance->default_headers);\n    o_free(u_instance->default_auth_realm);\n    o_free(u_instance->default_endpoint);\n    u_instance->endpoint_list = NULL;\n    u_instance->default_headers = NULL;\n    u_instance->default_auth_realm = NULL;\n    u_instance->bind_address = NULL;\n    u_instance->default_endpoint = NULL;\n#ifndef U_DISABLE_WEBSOCKET\n    /* ulfius_clean_instance might be called without websocket_handler being initialized */\n    if ((struct _websocket_handler *)u_instance->websocket_handler) {\n      if (((struct _websocket_handler *)u_instance->websocket_handler)->pthread_init &&\n          (pthread_mutex_destroy(&((struct _websocket_handler *)u_instance->websocket_handler)->websocket_close_lock) ||\n          pthread_cond_destroy(&((struct _websocket_handler *)u_instance->websocket_handler)->websocket_close_cond) ||\n          pthread_mutex_destroy(&((struct _websocket_handler *)u_instance->websocket_handler)->websocket_active_lock))) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"Ulfius - Error destroying websocket_close_lock or websocket_close_cond or websocket_active_lock\");\n      }\n      o_free(u_instance->websocket_handler);\n      u_instance->websocket_handler = NULL;\n    }\n#endif\n  }\n}\n\nstatic int internal_ulfius_init_instance(struct _u_instance * u_instance,\n                                         unsigned int port,\n                                         struct sockaddr_in * bind_address4,\n                                         struct sockaddr_in6 * bind_address6,\n                                         unsigned short network_type,\n                                         const char * default_auth_realm) {\n#ifndef U_DISABLE_WEBSOCKET\n  pthread_mutexattr_t mutexattr;\n#endif\n#if MHD_VERSION >= 0x00095208\n  if (u_instance != NULL && port > 0 && port < 65536 && (bind_address4 == NULL || bind_address6 == NULL) && (network_type & U_USE_ALL)) {\n#else\nUNUSED(network_type);\n  if (u_instance != NULL && port > 0 && port < 65536) {\n#endif\n    u_instance->mhd_daemon = NULL;\n    u_instance->status = U_STATUS_STOP;\n    u_instance->port = port;\n    u_instance->bind_address = bind_address4;\n    u_instance->bind_address6 = bind_address6;\n#if MHD_VERSION >= 0x00095208\n    u_instance->network_type = network_type;\n#endif\n    u_instance->timeout = 0;\n    u_instance->default_auth_realm = o_strdup(default_auth_realm);\n    u_instance->nb_endpoints = 0;\n    u_instance->endpoint_list = NULL;\n    u_instance->default_headers = o_malloc(sizeof(struct _u_map));\n    u_instance->mhd_response_copy_data = 0;\n    u_instance->check_utf8 = 1;\n    if (u_instance->default_headers == NULL) {\n      y_log_message(Y_LOG_LEVEL_ERROR, \"Ulfius - Error allocating memory for u_instance->default_headers\");\n      ulfius_clean_instance(u_instance);\n      return U_ERROR_MEMORY;\n    }\n    u_map_init(u_instance->default_headers);\n    u_instance->default_endpoint = NULL;\n    u_instance->max_post_param_size = 0;\n    u_instance->max_post_body_size = 0;\n    u_instance->file_upload_callback = NULL;\n    u_instance->file_upload_cls = NULL;\n#ifndef U_DISABLE_GNUTLS\n    u_instance->use_client_cert_auth = 0;\n#endif\n#ifndef U_DISABLE_WEBSOCKET\n    u_instance->websocket_handler = o_malloc(sizeof(struct _websocket_handler));\n    if (u_instance->websocket_handler == NULL) {\n      y_log_message(Y_LOG_LEVEL_ERROR, \"Ulfius - Error allocating memory for u_instance->websocket_handler\");\n      ulfius_clean_instance(u_instance);\n      return U_ERROR_MEMORY;\n    }\n    pthread_mutexattr_init ( &mutexattr );\n    pthread_mutexattr_settype( &mutexattr, PTHREAD_MUTEX_RECURSIVE );\n    if (pthread_mutex_init(&((struct _websocket_handler *)u_instance->websocket_handler)->websocket_active_lock, &mutexattr) != 0) {\n      y_log_message(Y_LOG_LEVEL_ERROR, \"Ulfius - Error initializing websocket_active_lock\");\n      ulfius_clean_instance(u_instance);\n      return U_ERROR;\n    }\n    pthread_mutexattr_destroy(&mutexattr);\n    ((struct _websocket_handler *)u_instance->websocket_handler)->pthread_init = 0;\n    ((struct _websocket_handler *)u_instance->websocket_handler)->nb_websocket_active = 0;\n    ((struct _websocket_handler *)u_instance->websocket_handler)->websocket_active = NULL;\n    if (pthread_mutex_init(&((struct _websocket_handler *)u_instance->websocket_handler)->websocket_close_lock, NULL) ||\n        pthread_cond_init(&((struct _websocket_handler *)u_instance->websocket_handler)->websocket_close_cond, NULL)) {\n      y_log_message(Y_LOG_LEVEL_ERROR, \"Ulfius - Error initializing websocket_close_lock or websocket_close_cond\");\n      ulfius_clean_instance(u_instance);\n      return U_ERROR_MEMORY;\n    }\n    ((struct _websocket_handler *)u_instance->websocket_handler)->pthread_init = 1;\n#else\n    u_instance->websocket_handler = NULL;\n#endif\n    return U_OK;\n  } else {\n    return U_ERROR_PARAMS;\n  }\n}\n\nint ulfius_init_instance(struct _u_instance * u_instance, unsigned int port, struct sockaddr_in * bind_address, const char * default_auth_realm) {\n  return internal_ulfius_init_instance(u_instance, port, bind_address, NULL, U_USE_IPV4, default_auth_realm);\n}\n\n#if MHD_VERSION >= 0x00095208\nint ulfius_init_instance_ipv6(struct _u_instance * u_instance, unsigned int port, struct sockaddr_in6 * bind_address, unsigned short network_type, const char * default_auth_realm) {\n  if (network_type & U_USE_IPV6) {\n    return internal_ulfius_init_instance(u_instance, port, NULL, bind_address, bind_address!=NULL?U_USE_IPV6:network_type, default_auth_realm);\n  } else {\n    return U_ERROR_PARAMS;\n  }\n}\n#endif\n\nvoid u_free(void * data) {\n  o_free(data);\n}\n\n/**\n * The utf8_check() function scans the string starting\n * at s. It returns a pointer to the first byte of the first malformed\n * or overlong UTF-8 sequence found, or NULL if the string contains\n * only correct UTF-8. It also spots UTF-8 sequences that could cause\n * trouble if converted to UTF-16, namely surrogate characters\n * (U+D800..U+DFFF) and non-Unicode positions (U+FFFE..U+FFFF). This\n * routine is very likely to find a malformed sequence if the input\n * uses any other encoding than UTF-8. It therefore can be used as a\n * very effective heuristic for distinguishing between UTF-8 and other\n * encodings.\n *\n * I wrote this code mainly as a specification of functionality; there\n * are no doubt performance optimizations possible for certain CPUs.\n *\n * Markus Kuhn <http://www.cl.cam.ac.uk/~mgk25/> -- 2005-03-30\n * Nicolas Mora <mail@babelouest.org>\n * License: http://www.cl.cam.ac.uk/~mgk25/short-license.html\n */\nconst unsigned char * utf8_check(const char * s_orig, size_t len) {\n  const unsigned char * s = (unsigned char *)s_orig;\n  size_t i = 0;\n\n  while (i<len) {\n    if (*s < 0x80) {\n      /* 0xxxxxxx */\n      s++;\n      i++;\n    } else if ((s[0] & 0xe0) == 0xc0) {\n      /* 110XXXXx 10xxxxxx */\n      if ((i+1 >= len) ||\n          (s[1] & 0xc0) != 0x80 ||\n          (s[0] & 0xfe) == 0xc0) {                  /* overlong? */\n        return s;\n      } else {\n        s += 2;\n        i += 2;\n      }\n    } else if ((s[0] & 0xf0) == 0xe0) {\n      /* 1110XXXX 10Xxxxxx 10xxxxxx */\n      if ((i+2 >= len) ||\n          (s[1] & 0xc0) != 0x80 ||\n          (s[2] & 0xc0) != 0x80 ||\n          (s[0] == 0xe0 && (s[1] & 0xe0) == 0x80) ||                 /* overlong? */\n          (s[0] == 0xed && (s[1] & 0xe0) == 0xa0) ||                 /* surrogate? */\n          (s[0] == 0xef && s[1] == 0xbf && (s[2] & 0xfe) == 0xbe && /* U+FFFE or U+FFFF? */\n          s[2] != 0xbf && s[2] != 0xbe)) { /* Hideous hack to comply with autobahn testsuite, TODO: fix that one day (and other jokes I tell myself) */\n        return s;\n      } else {\n        s += 3;\n        i += 3;\n      }\n    } else if ((s[0] & 0xf8) == 0xf0) {\n      /* 11110XXX 10XXxxxx 10xxxxxx 10xxxxxx */\n      if ((i+3 >= len) ||\n          (s[1] & 0xc0) != 0x80 ||\n          (s[2] & 0xc0) != 0x80 ||\n          (s[3] & 0xc0) != 0x80 ||\n          (s[0] == 0xf0 && (s[1] & 0xf0) == 0x80) ||      /* overlong? */\n          (s[0] == 0xf4 && s[1] > 0x8f) || s[0] > 0xf4) { /* > U+10FFFF? */\n        return s;\n      } else {\n        s += 4;\n        i += 4;\n      }\n    } else {\n      return s;\n    }\n  }\n  return NULL;\n}\n\n/**\n * Converts a hex character to its integer value\n */\nstatic char from_hex(char ch) {\n  return isdigit(ch) ? ch - '0' : tolower(ch) - 'a' + 10;\n}\n\n/**\n * Converts an integer value to its hex character\n */\nstatic char to_hex(char code) {\n  static char hex[] = \"0123456789ABCDEF\";\n  return hex[code & 15];\n}\n\n/**\n * Returns a url-encoded version of str\n * returned value must be cleaned after use\n * Thanks Geek Hideout!\n * http://www.geekhideout.com/urlcode.shtml\n */\nchar * ulfius_url_encode(const char * str) {\n  char * pstr = (char*)str, * buf = NULL, * pbuf = NULL;\n  if (str != NULL) {\n    buf = malloc(strlen(str) * 3 + 1);\n    if (buf != NULL) {\n      pbuf = buf;\n      while (* pstr) {\n        // \"$-_.+!*'(),\"\n        if (isalnum(* pstr) || * pstr == '$' || * pstr == '-' || * pstr == '_' ||\n            * pstr == '.' || * pstr == '!' || * pstr == '*' ||\n            * pstr == '\\'' || * pstr == '(' || * pstr == ')' || * pstr == ',')\n          * pbuf++ = * pstr;\n        else if (* pstr == ' ')\n          * pbuf++ = '+';\n        else\n          * pbuf++ = '%', * pbuf++ = to_hex(* pstr >> 4), * pbuf++ = to_hex(* pstr & 15);\n        pstr++;\n      }\n      * pbuf = '\\0';\n    } else {\n      y_log_message(Y_LOG_LEVEL_ERROR, \"Ulfius - Error allocating resources for buf (ulfius_url_encode)\");\n    }\n    return buf;\n  } else {\n    return NULL;\n  }\n}\n\n/**\n * Returns a url-decoded version of str\n * returned value must be cleaned after use\n * Thanks Geek Hideout!\n * http://www.geekhideout.com/urlcode.shtml\n */\nchar * ulfius_url_decode(const char * str) {\n  char * pstr = (char*)str, * buf = NULL, * pbuf = NULL;\n  if (str != NULL) {\n    buf = malloc(strlen(str) + 1);\n    if (buf != NULL) {\n      pbuf = buf;\n      while (* pstr) {\n        if (* pstr == '%') {\n          if (pstr[1] && pstr[2]) {\n            * pbuf++ = from_hex(pstr[1]) << 4 | from_hex(pstr[2]);\n            pstr += 2;\n          }\n        } else if (* pstr == '+') {\n          * pbuf++ = ' ';\n        } else {\n          * pbuf++ = * pstr;\n        }\n        pstr++;\n      }\n      * pbuf = '\\0';\n    } else {\n      y_log_message(Y_LOG_LEVEL_ERROR, \"Ulfius - Error allocating resources for buf (ulfius_url_decode)\");\n    }\n    return buf;\n  } else {\n    return NULL;\n  }\n}\n\nint ulfius_global_init(void) {\n  int ret = U_OK;\n  o_malloc_t malloc_fn;\n  o_realloc_t realloc_fn;\n  o_free_t free_fn;\n\n  o_get_alloc_funcs(&malloc_fn, &realloc_fn, &free_fn);\n#ifndef U_DISABLE_CURL\n  if (curl_global_init(CURL_GLOBAL_ALL) != CURLE_OK) {\n    y_log_message(Y_LOG_LEVEL_ERROR, \"Ulfius - Error curl_global_init\");\n    ret = U_ERROR;\n  } else {\n    if (curl_global_init_mem(CURL_GLOBAL_DEFAULT, malloc_fn, free_fn, realloc_fn, *o_strdup, *calloc) != CURLE_OK) {\n      y_log_message(Y_LOG_LEVEL_ERROR, \"Ulfius - Error curl_global_init_mem\");\n      ret = U_ERROR_MEMORY;\n    }\n  }\n#endif\n#ifndef U_DISABLE_JANSSON\n  json_set_alloc_funcs((json_malloc_t)malloc_fn, (json_free_t)free_fn);\n#endif\n  return ret;\n}\n\nvoid ulfius_global_close(void) {\n#ifndef U_DISABLE_CURL\n  curl_global_cleanup();\n#endif\n}\n"], "fixing_code": ["/**\n *\n * Ulfius Framework\n *\n * REST framework library\n *\n * ulfius.c: framework functions definitions\n *\n * Copyright 2015-2020 Nicolas Mora <mail@babelouest.org>\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public License\n * as published by the Free Software Foundation;\n * version 2.1 of the License.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU GENERAL PUBLIC LICENSE for more details.\n *\n * You should have received a copy of the GNU General Public\n * License along with this library.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\n\n#include <string.h>\n#include <ctype.h>\n#include <stdlib.h>\n#include <pthread.h>\n#include \"u_private.h\"\n#include \"ulfius.h\"\n\n#ifndef U_DISABLE_CURL\n#include <curl/curl.h>\n#endif\n\n/** Define mock yder functions when yder is disabled **/\n#ifdef U_DISABLE_YDER\nint y_init_logs(const char * app, const unsigned long init_mode, const unsigned long init_level, const char * init_log_file, const char * message) {\n  (void)(app);\n  (void)(init_mode);\n  (void)(init_level);\n  (void)(init_log_file);\n  (void)(message);\n  return 1;\n}\n\nint y_set_logs_callback(void (* y_callback_log_message) (void * cls, const char * app_name, const time_t date, const unsigned long level, const char * message), void * cls, const char * message) {\n  (void)(y_callback_log_message);\n  (void)(cls);\n  (void)(message);\n  return 1;\n}\n\nvoid y_log_message(const unsigned long type, const char * message, ...) {\n  (void)(type);\n  (void)(message);\n}\n\nint y_close_logs(void) {\n  return 1;\n}\n#endif\n\n/**\n * Fill a map with the key/values specified\n */\n#if MHD_VERSION >= 0x00097002\nstatic enum MHD_Result ulfius_fill_map_check_utf8(void * cls, enum MHD_ValueKind kind, const char * key, const char * value) {\n#else\nstatic int ulfius_fill_map_check_utf8(void * cls, enum MHD_ValueKind kind, const char * key, const char * value) {\n#endif\n  char * tmp;\n  int res;\n  UNUSED(kind);\n\n  if (cls == NULL || key == NULL) {\n    // Invalid parameters\n    y_log_message(Y_LOG_LEVEL_ERROR, \"Ulfius - Error invalid parameters for ulfius_fill_map_check_utf8\");\n    return MHD_NO;\n  } else if (utf8_check(key, o_strlen(key)) == NULL && (value == NULL || utf8_check(value, o_strlen(value)) == NULL)) {\n    if (u_map_get(((struct _u_map *)cls), key) != NULL) {\n      // u_map already has a value with this this key, appending value separated with a comma ',')\n      tmp = msprintf(\"%s,%s\", u_map_get(((struct _u_map *)cls), key), (value==NULL?\"\":value));\n      res = u_map_put(((struct _u_map *)cls), key, tmp);\n      o_free(tmp);\n      if (res == U_OK) {\n        return MHD_YES;\n      } else {\n        return MHD_NO;\n      }\n    } else if (u_map_put(((struct _u_map *)cls), key, (value==NULL?\"\":value)) == U_OK) {\n      return MHD_YES;\n    } else {\n      return MHD_NO;\n    }\n  } else {\n    return MHD_YES;\n  }\n}\n\n/**\n * Fill a map with the key/values specified\n */\n#if MHD_VERSION >= 0x00097002\nstatic enum MHD_Result ulfius_fill_map(void * cls, enum MHD_ValueKind kind, const char * key, const char * value) {\n#else\nstatic int ulfius_fill_map(void * cls, enum MHD_ValueKind kind, const char * key, const char * value) {\n#endif\n  char * tmp;\n  int res;\n  UNUSED(kind);\n\n  if (cls == NULL || key == NULL) {\n    // Invalid parameters\n    y_log_message(Y_LOG_LEVEL_ERROR, \"Ulfius - Error invalid parameters for ulfius_fill_map\");\n    return MHD_NO;\n  } else if (u_map_get(((struct _u_map *)cls), key) != NULL) {\n    // u_map already has a value with this this key, appending value separated with a comma ',')\n    tmp = msprintf(\"%s,%s\", u_map_get(((struct _u_map *)cls), key), (value==NULL?\"\":value));\n    res = u_map_put(((struct _u_map *)cls), key, tmp);\n    o_free(tmp);\n    if (res == U_OK) {\n      return MHD_YES;\n    } else {\n      return MHD_NO;\n    }\n  } else if (u_map_put(((struct _u_map *)cls), key, (value==NULL?\"\":value)) == U_OK) {\n    return MHD_YES;\n  } else {\n    return MHD_NO;\n  }\n}\n\n/**\n * ulfius_is_valid_endpoint\n * return true if the endpoind has valid parameters\n */\n#if MHD_VERSION >= 0x00097002\nstatic enum MHD_Result ulfius_is_valid_endpoint(const struct _u_endpoint * endpoint, int to_delete) {\n#else\nstatic int ulfius_is_valid_endpoint(const struct _u_endpoint * endpoint, int to_delete) {\n#endif\n  if (endpoint != NULL) {\n    if (ulfius_equals_endpoints(endpoint, ulfius_empty_endpoint())) {\n      // Should be the last endpoint of the list to close it\n      return 1;\n    } else if (endpoint->http_method == NULL) {\n      return 0;\n    } else if (!to_delete && endpoint->callback_function == NULL) {\n      return 0;\n    } else if (endpoint->url_prefix == NULL && endpoint->url_format == NULL) {\n      return 0;\n    } else {\n      return 1;\n    }\n  } else {\n    return 0;\n  }\n}\n\n/**\n * ulfius_validate_endpoint_list\n * return true if endpoint_list has valid parameters\n */\nstatic int ulfius_validate_endpoint_list(const struct _u_endpoint * endpoint_list, int nb_endpoints) {\n  int i;\n  if (endpoint_list != NULL) {\n    for (i=0; i < nb_endpoints; i++) {\n      if (i == 0 && ulfius_equals_endpoints(ulfius_empty_endpoint(), &endpoint_list[i])) {\n        // One can not have an empty endpoint in the beginning of the list\n        y_log_message(Y_LOG_LEVEL_ERROR, \"Ulfius - Error, no empty endpoint allowed in the beginning of the endpoint list\");\n        return U_ERROR_PARAMS;\n      } else if (!ulfius_is_valid_endpoint(&endpoint_list[i], 0)) {\n        // One must set at least the parameters http_method, url_format and callback_function\n        y_log_message(Y_LOG_LEVEL_ERROR, \"Ulfius - Error, endpoint at index %d has invalid parameters\", i);\n        return U_ERROR_PARAMS;\n      }\n    }\n    return U_OK;\n  } else {\n    y_log_message(Y_LOG_LEVEL_ERROR, \"Ulfius - Error, no endpoint list\");\n    return U_ERROR_PARAMS;\n  }\n}\n\n/**\n * ulfius_validate_instance\n * return true if u_instance has valid parameters\n */\nstatic int ulfius_validate_instance(const struct _u_instance * u_instance) {\n  if (u_instance == NULL ||\n      u_instance->port <= 0 ||\n      u_instance->port >= 65536 ||\n      ulfius_validate_endpoint_list(u_instance->endpoint_list, u_instance->nb_endpoints) != U_OK) {\n    y_log_message(Y_LOG_LEVEL_ERROR, \"Ulfius - Error, instance or has invalid parameters\");\n    return U_ERROR_PARAMS;\n  }\n  return U_OK;\n}\n\n/**\n * Internal method used to duplicate the full url before it's manipulated and modified by MHD\n */\nvoid * ulfius_uri_logger (void * cls, const char * uri) {\n  struct connection_info_struct * con_info = o_malloc (sizeof (struct connection_info_struct));\n  UNUSED(cls);\n\n  if (con_info != NULL) {\n    memset(con_info, 0, sizeof(struct connection_info_struct));\n    con_info->callback_first_iteration = 1;\n    con_info->u_instance = NULL;\n    u_map_init(&con_info->map_url_initial);\n    con_info->request = o_malloc(sizeof(struct _u_request));\n    if (con_info->request == NULL) {\n      y_log_message(Y_LOG_LEVEL_ERROR, \"Ulfius - Error allocating memory for con_info->request\");\n      o_free(con_info);\n      return NULL;\n    }\n\n    if (ulfius_init_request(con_info->request) != U_OK) {\n      y_log_message(Y_LOG_LEVEL_ERROR, \"Ulfius - Error initializing con_info->request\");\n      ulfius_clean_request_full(con_info->request);\n      o_free(con_info);\n      return NULL;\n    }\n    con_info->request->http_url = o_strdup(uri);\n    if (o_strchr(uri, '?') != NULL) {\n      con_info->request->url_path = o_strndup(uri, o_strchr(uri, '?') - uri);\n    } else {\n      con_info->request->url_path = o_strdup(uri);\n    }\n    if (con_info->request->http_url == NULL || con_info->request->url_path == NULL) {\n      y_log_message(Y_LOG_LEVEL_ERROR, \"Ulfius - Error allocating memory for con_info->request->http_url or con_info->request->url_path\");\n      ulfius_clean_request_full(con_info->request);\n      o_free(con_info);\n      return NULL;\n    }\n    con_info->max_post_param_size = 0;\n  } else {\n    y_log_message(Y_LOG_LEVEL_ERROR, \"Ulfius - Error allocating memory for con_info\");\n  }\n  return con_info;\n}\n\n/**\n * ulfius_get_body_from_response\n * Extract the body data from the response if any\n * Copy it in newly allocated response_buffer and set the size in response_buffer_len\n * return U_OK on success\n */\nstatic int ulfius_get_body_from_response(struct _u_response * response, void ** response_buffer, size_t * response_buffer_len) {\n  if (response == NULL || response_buffer == NULL || response_buffer_len == NULL) {\n    return U_ERROR_PARAMS;\n  } else {\n    if (response->binary_body != NULL && response->binary_body_length > 0) {\n      // The user sent a binary response\n      *response_buffer = o_malloc(response->binary_body_length);\n      if (*response_buffer == NULL) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"Ulfius - Error allocating memory for response_buffer\");\n        response->status = MHD_HTTP_INTERNAL_SERVER_ERROR;\n        response->binary_body = o_strdup(ULFIUS_HTTP_ERROR_BODY);\n        response->binary_body_length = o_strlen(ULFIUS_HTTP_ERROR_BODY);\n        if (response->binary_body == NULL) {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"Ulfius - Error allocating memory for response->binary_body\");\n          return U_ERROR_MEMORY;\n        }\n      } else {\n        memcpy(*response_buffer, response->binary_body, response->binary_body_length);\n        *response_buffer_len = response->binary_body_length;\n      }\n    } else {\n      *response_buffer = NULL;\n      *response_buffer_len = 0;\n    }\n    return U_OK;\n  }\n}\n\n/**\n * mhd_request_completed\n * function used to clean data allocated after a web call is complete\n */\nvoid mhd_request_completed (void *cls, struct MHD_Connection *connection,\n                        void **con_cls, enum MHD_RequestTerminationCode toe) {\n  struct connection_info_struct *con_info = *con_cls;\n  UNUSED(toe);\n  UNUSED(connection);\n  UNUSED(cls);\n\n  if (NULL == con_info) {\n    return;\n  }\n  if (con_info->has_post_processor && con_info->post_processor != NULL) {\n    MHD_destroy_post_processor (con_info->post_processor);\n  }\n  ulfius_clean_request_full(con_info->request);\n  u_map_clean(&con_info->map_url_initial);\n  con_info->request = NULL;\n  o_free(con_info);\n  con_info = NULL;\n  *con_cls = NULL;\n}\n\n/**\n * mhd_iterate_post_data\n * function used to iterate post parameters\n * if a parameter is larger than max_post_param_size, truncate it\n * return MHD_NO on error\n */\n#if MHD_VERSION >= 0x00097002\nstatic enum MHD_Result mhd_iterate_post_data (void * coninfo_cls, enum MHD_ValueKind kind, const char * key,\n                                              const char * filename, const char * content_type,\n                                              const char * transfer_encoding, const char * data, uint64_t off, size_t size) {\n#else\nstatic int mhd_iterate_post_data (void * coninfo_cls, enum MHD_ValueKind kind, const char * key,\n                                  const char * filename, const char * content_type,\n                                  const char * transfer_encoding, const char * data, uint64_t off, size_t size) {\n#endif\n  struct connection_info_struct * con_info = coninfo_cls;\n  size_t data_size = size, cur_size;\n  char * filename_param = NULL, * data_concat = NULL;\n  const char * cur_data;\n#if MHD_VERSION >= 0x00097002\n  enum MHD_Result ret = MHD_YES;\n#else\n  int ret = MHD_YES;\n#endif\n  UNUSED(kind);\n\n  if (con_info->u_instance == NULL) {\n    ret = MHD_NO;\n  } else if (filename != NULL && con_info->u_instance->file_upload_callback != NULL) {\n    if (con_info->u_instance->file_upload_callback(con_info->request, key, filename, content_type, transfer_encoding, data, off, size, con_info->u_instance->file_upload_cls) != U_OK) {\n      ret = MHD_NO;\n    }\n  } else {\n    \n    do {\n      if (con_info->u_instance->check_utf8) {\n        if (utf8_check(key, o_strlen(key)) != NULL || data == NULL || utf8_check(data, o_strlen(data)) != NULL || (filename != NULL && utf8_check(filename, o_strlen(filename)) != NULL)) {\n          break;\n        }\n      }\n      \n      if (con_info->max_post_param_size && off > con_info->max_post_param_size) {\n        break;\n      }\n      \n      if (off + size > con_info->max_post_param_size) {\n        data_size = con_info->max_post_param_size - off;\n      }\n      \n      if (filename != NULL) {\n        filename_param = msprintf(\"%s_filename\", key);\n        if (!u_map_has_key((struct _u_map *)con_info->request->map_post_body, filename_param) && u_map_put((struct _u_map *)con_info->request->map_post_body, filename_param, filename) != U_OK) {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"Ulfius - Error u_map_put filename value\");\n        }\n        cur_data = u_map_get((struct _u_map *)con_info->request->map_post_body, key);\n        cur_size = u_map_get_length((struct _u_map *)con_info->request->map_post_body, key);\n        if (cur_data != NULL) {\n          if (off) {\n            if (u_map_put_binary((struct _u_map *)con_info->request->map_post_body, key, data, cur_size, data_size) != U_OK) {\n              ret = MHD_NO;\n              break;\n            }\n          } else {\n            if (u_map_put_binary((struct _u_map *)con_info->request->map_post_body, key, \",\", cur_size, 1) != U_OK ||\n                u_map_put_binary((struct _u_map *)con_info->request->map_post_body, key, data, cur_size+1, 1) != U_OK) {\n              ret = MHD_NO;\n              break;\n            }\n          }\n        } else {\n          if (u_map_put_binary((struct _u_map *)con_info->request->map_post_body, key, data, 0, data_size) != U_OK) {\n            ret = MHD_NO;\n            break;\n          }\n        }\n      } else {\n        cur_data = u_map_get((struct _u_map *)con_info->request->map_post_body, key);\n        cur_size = u_map_get_length((struct _u_map *)con_info->request->map_post_body, key);\n        if (cur_data != NULL) {\n          if (off) {\n            data_concat = msprintf(\"%s%s\", cur_data, data);\n          } else {\n            data_concat = msprintf(\"%s,%s\", cur_data, data);\n          }\n          if (u_map_put((struct _u_map *)con_info->request->map_post_body, key, data_concat) != U_OK) {\n            ret = MHD_NO;\n            break;\n          }\n        } else {\n          if (u_map_put((struct _u_map *)con_info->request->map_post_body, key, data) != U_OK) {\n            ret = MHD_NO;\n            break;\n          }\n        }\n      }\n      \n    } while (0);\n    o_free(data_concat);\n    o_free(filename_param);\n  }\n  return ret;\n}\n\n#if MHD_VERSION >= 0x00096100\n  #define MHD_CREATE_RESPONSE_FROM_BUFFER_PIMPED(len, buf, flag) MHD_create_response_from_buffer_with_free_callback((len), (buf), &o_free)\n#else\n  #define MHD_CREATE_RESPONSE_FROM_BUFFER_PIMPED(len, buf, flag) MHD_create_response_from_buffer((len), (buf), (flag))\n#endif\n\n/**\n * ulfius_webservice_dispatcher\n * function executed by libmicrohttpd every time an HTTP call is made\n * return MHD_NO on error\n */\n#if MHD_VERSION >= 0x00097002\nstatic enum MHD_Result ulfius_webservice_dispatcher (void * cls,\n                                                     struct MHD_Connection * connection,\n                                                     const char * url,\n                                                     const char * method,\n                                                     const char * version,\n                                                     const char * upload_data,\n                                                     size_t * upload_data_size,\n                                                     void ** con_cls) {\n#else\nstatic int ulfius_webservice_dispatcher (void * cls,\n                                         struct MHD_Connection * connection,\n                                         const char * url,\n                                         const char * method,\n                                         const char * version,\n                                         const char * upload_data,\n                                         size_t * upload_data_size,\n                                         void ** con_cls) {\n#endif\n  struct _u_endpoint * endpoint_list = ((struct _u_instance *)cls)->endpoint_list, ** current_endpoint_list = NULL, * current_endpoint = NULL;\n  struct connection_info_struct * con_info = * con_cls;\n  int mhd_ret = MHD_NO, callback_ret = U_OK, i, close_loop = 0, inner_error = U_OK, mhd_response_flag;\n#ifndef U_DISABLE_WEBSOCKET\n  // Websocket variables\n  int upgrade_protocol = 0;\n  char * protocol = NULL, * extension = NULL, ** extension_list = NULL;\n  size_t extension_len, x, y;\n#endif\n\n#ifndef U_DISABLE_GNUTLS\n  // Client certificate authentication variables\n  const union MHD_ConnectionInfo * ci;\n  unsigned int listsize;\n  const gnutls_datum_t * pcert;\n  gnutls_certificate_status_t client_cert_status = 0;\n  int ret_cert;\n#endif\n  char * content_type, * auth_realm = NULL;\n  struct _u_response * response = NULL;\n  struct sockaddr * so_client;\n\n  void * response_buffer = NULL;\n  size_t response_buffer_len = 0;\n\n  // Response variables\n  struct MHD_Response * mhd_response = NULL;\n\n  UNUSED(url);\n\n  // Prepare for POST or PUT input data\n  // Initialize the input maps\n  if (con_info == NULL) {\n    y_log_message(Y_LOG_LEVEL_ERROR, \"Ulfius - Error con_info is NULL\");\n    return MHD_NO;\n  }\n\n  if (con_info->u_instance == NULL) {\n    con_info->u_instance = (struct _u_instance *)cls;\n  }\n\n  if (con_info->callback_first_iteration) {\n#ifndef U_DISABLE_GNUTLS\n    ci = MHD_get_connection_info (connection, MHD_CONNECTION_INFO_GNUTLS_SESSION);\n    if (ci != NULL && ci->tls_session != NULL) {\n      if (((struct _u_instance *)cls)->use_client_cert_auth) {\n        if (((ret_cert = gnutls_certificate_verify_peers2(ci->tls_session, &client_cert_status)) != 0 && ret_cert != GNUTLS_E_NO_CERTIFICATE_FOUND) || client_cert_status != 0) {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"Ulfius - Error gnutls_certificate_verify_peers2\");\n        } else if (!ret_cert) {\n          pcert = gnutls_certificate_get_peers(ci->tls_session, &listsize);\n          if ((pcert == NULL) || (listsize == 0)) {\n            y_log_message(Y_LOG_LEVEL_ERROR, \"Ulfius - Failed to retrieve client certificate chain\");\n          } else if (gnutls_x509_crt_init(&(con_info->request->client_cert))) {\n            y_log_message(Y_LOG_LEVEL_ERROR, \"Ulfius - Failed to initialize client certificate\");\n          } else if (gnutls_x509_crt_import(con_info->request->client_cert, &pcert[0], GNUTLS_X509_FMT_DER)) {\n            y_log_message(Y_LOG_LEVEL_ERROR, \"Ulfius - Failed to import client certificate\");\n            gnutls_x509_crt_deinit(con_info->request->client_cert);\n          }\n        }\n      }\n    }\n#endif\n    con_info->callback_first_iteration = 0;\n    so_client = MHD_get_connection_info (connection, MHD_CONNECTION_INFO_CLIENT_ADDRESS)->client_addr;\n    con_info->has_post_processor = 0;\n    con_info->max_post_param_size = ((struct _u_instance *)cls)->max_post_param_size;\n    con_info->request->http_protocol = o_strdup(version);\n    con_info->request->http_verb = o_strdup(method);\n    con_info->request->client_address = o_malloc(sizeof(struct sockaddr));\n    if (con_info->request->client_address == NULL || con_info->request->http_verb == NULL) {\n      y_log_message(Y_LOG_LEVEL_ERROR, \"Ulfius - Error allocating client_address or http_verb\");\n      return MHD_NO;\n    }\n    memcpy(con_info->request->client_address, so_client, sizeof(struct sockaddr));\n    if (con_info->u_instance->check_utf8) {\n      MHD_get_connection_values (connection, MHD_HEADER_KIND, ulfius_fill_map_check_utf8, con_info->request->map_header);\n      MHD_get_connection_values (connection, MHD_GET_ARGUMENT_KIND, ulfius_fill_map_check_utf8, &con_info->map_url_initial);\n      MHD_get_connection_values (connection, MHD_COOKIE_KIND, ulfius_fill_map_check_utf8, con_info->request->map_cookie);\n    } else {\n      MHD_get_connection_values (connection, MHD_HEADER_KIND, ulfius_fill_map, con_info->request->map_header);\n      MHD_get_connection_values (connection, MHD_GET_ARGUMENT_KIND, ulfius_fill_map, &con_info->map_url_initial);\n      MHD_get_connection_values (connection, MHD_COOKIE_KIND, ulfius_fill_map, con_info->request->map_cookie);\n    }\n    content_type = (char*)u_map_get_case(con_info->request->map_header, ULFIUS_HTTP_HEADER_CONTENT);\n\n    // Set POST Processor if content-type is properly set\n    if (content_type != NULL && \n       (0 == o_strncmp(MHD_HTTP_POST_ENCODING_FORM_URLENCODED, content_type, o_strlen(MHD_HTTP_POST_ENCODING_FORM_URLENCODED)) ||\n        0 == o_strncmp(MHD_HTTP_POST_ENCODING_MULTIPART_FORMDATA, content_type, o_strlen(MHD_HTTP_POST_ENCODING_MULTIPART_FORMDATA)))) {\n      con_info->has_post_processor = 1;\n      con_info->post_processor = MHD_create_post_processor (connection, ULFIUS_POSTBUFFERSIZE, mhd_iterate_post_data, (void *) con_info);\n      if (NULL == con_info->post_processor) {\n        ulfius_clean_request_full(con_info->request);\n        con_info->request = NULL;\n        y_log_message(Y_LOG_LEVEL_ERROR, \"Ulfius - Error allocating post_processor\");\n        return MHD_NO;\n      }\n    }\n    return MHD_YES;\n  } else if (*upload_data_size != 0) {\n    size_t body_len = con_info->request->binary_body_length + *upload_data_size, upload_data_size_current = *upload_data_size;\n\n    if (((struct _u_instance *)cls)->max_post_body_size > 0 && con_info->request->binary_body_length + *upload_data_size > ((struct _u_instance *)cls)->max_post_body_size) {\n      body_len = ((struct _u_instance *)cls)->max_post_body_size;\n      upload_data_size_current = ((struct _u_instance *)cls)->max_post_body_size - con_info->request->binary_body_length;\n    }\n\n    if (body_len >= con_info->request->binary_body_length) {\n      con_info->request->binary_body = o_realloc(con_info->request->binary_body, body_len);\n      if (con_info->request->binary_body == NULL) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"Ulfius - Error allocating memory for con_info->request->binary_body\");\n        return MHD_NO;\n      } else {\n        memcpy((char*)con_info->request->binary_body + con_info->request->binary_body_length, upload_data, upload_data_size_current);\n        con_info->request->binary_body_length += upload_data_size_current;\n        // Handles request binary_body\n        const char * content_type = u_map_get_case(con_info->request->map_header, ULFIUS_HTTP_HEADER_CONTENT);\n        if (0 == o_strncmp(MHD_HTTP_POST_ENCODING_FORM_URLENCODED, content_type, o_strlen(MHD_HTTP_POST_ENCODING_FORM_URLENCODED)) ||\n            0 == o_strncmp(MHD_HTTP_POST_ENCODING_MULTIPART_FORMDATA, content_type, o_strlen(MHD_HTTP_POST_ENCODING_MULTIPART_FORMDATA))) {\n          MHD_post_process (con_info->post_processor, upload_data, *upload_data_size);\n        }\n        *upload_data_size = 0;\n        return MHD_YES;\n      }\n    } else {\n      return MHD_YES;\n    }\n  } else {\n    // Check if the endpoint has one or more matches\n    current_endpoint_list = ulfius_endpoint_match(method, con_info->request->url_path, endpoint_list);\n\n    // Set to default_endpoint if no match\n    if ((current_endpoint_list == NULL || current_endpoint_list[0] == NULL) && ((struct _u_instance *)cls)->default_endpoint != NULL && ((struct _u_instance *)cls)->default_endpoint->callback_function != NULL) {\n      current_endpoint_list = o_realloc(current_endpoint_list, 2*sizeof(struct _u_endpoint *));\n      if (current_endpoint_list != NULL) {\n        if ((current_endpoint_list[0] = o_malloc(sizeof(struct _u_endpoint))) != NULL) {\n          if (ulfius_copy_endpoint(current_endpoint_list[0], ((struct _u_instance *)cls)->default_endpoint) != U_OK) {\n            y_log_message(Y_LOG_LEVEL_ERROR, \"Ulfius - Error ulfius_copy_endpoint for current_endpoint_list[0]\");\n          }\n        } else {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"Ulfius - Error allocating memory for current_endpoint_list[0] of default endpoint\");\n        }\n        current_endpoint_list[1] = NULL;\n      } else {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"Ulfius - Error allocating memory for current_endpoint_list of default endpoint\");\n      }\n    }\n\n#if MHD_VERSION >= 0x00096100\n    mhd_response_flag = ((struct _u_instance *)cls)->mhd_response_copy_data?MHD_RESPMEM_MUST_COPY:MHD_RESPMEM_MUST_FREE;\n#else\n    mhd_response_flag = MHD_RESPMEM_MUST_FREE;\n#endif\n    if (current_endpoint_list[0] != NULL) {\n      response = o_malloc(sizeof(struct _u_response));\n      if (response == NULL) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"Ulfius - Error allocating response\");\n        mhd_ret = MHD_NO;\n      } else if (ulfius_init_response(response) != U_OK) {\n        o_free(response);\n        y_log_message(Y_LOG_LEVEL_ERROR, \"Ulfius - Error ulfius_init_response\");\n        mhd_ret = MHD_NO;\n      } else {\n        // Add default headers (if any) to the response header maps\n        if (((struct _u_instance *)cls)->default_headers != NULL && u_map_count(((struct _u_instance *)cls)->default_headers) > 0) {\n          u_map_clean_full(response->map_header);\n          response->map_header = u_map_copy(((struct _u_instance *)cls)->default_headers);\n        }\n\n        // Initialize auth variables\n        con_info->request->auth_basic_user = MHD_basic_auth_get_username_password(connection, &con_info->request->auth_basic_password);\n\n        for (i=0; current_endpoint_list[i] != NULL && !close_loop; i++) {\n          current_endpoint = current_endpoint_list[i];\n          u_map_empty(con_info->request->map_url);\n          u_map_copy_into(con_info->request->map_url, &con_info->map_url_initial);\n          if (ulfius_parse_url(con_info->request->url_path, current_endpoint, con_info->request->map_url, con_info->u_instance->check_utf8) != U_OK) {\n            o_free(response);\n            y_log_message(Y_LOG_LEVEL_ERROR, \"Ulfius - Error parsing url: \", con_info->request->url_path);\n            mhd_ret = MHD_NO;\n          }\n          // Run callback function with the input parameters filled for the current callback\n          callback_ret = current_endpoint->callback_function(con_info->request, response, current_endpoint->user_data);\n          if (callback_ret != U_CALLBACK_IGNORE) {\n            con_info->request->callback_position++;\n          }\n          if (response->timeout > 0 && MHD_set_connection_option(connection, MHD_CONNECTION_OPTION_TIMEOUT, response->timeout) !=  MHD_YES) {\n            y_log_message(Y_LOG_LEVEL_ERROR, \"Ulfius - Error setting connection response timeout value\");\n          }\n          if (response->stream_callback != NULL) {\n            // Call the stream_callback function to build the response binary_body\n            // A stram_callback is always the last one\n            mhd_response = MHD_create_response_from_callback(response->stream_size, response->stream_block_size, response->stream_callback, response->stream_user_data, response->stream_callback_free);\n            if (mhd_response == NULL) {\n              y_log_message(Y_LOG_LEVEL_ERROR, \"Ulfius - Error MHD_create_response_from_callback\");\n              mhd_ret = MHD_NO;\n            } else if (ulfius_set_response_header(mhd_response, response->map_header) == -1 || ulfius_set_response_cookie(mhd_response, response) == -1) {\n              y_log_message(Y_LOG_LEVEL_ERROR, \"Ulfius - Error setting headers or cookies\");\n              mhd_ret = MHD_NO;\n            }\n            close_loop = 1;\n#ifndef U_DISABLE_WEBSOCKET\n          } else if (((struct _websocket_handle *)response->websocket_handle)->websocket_manager_callback != NULL ||\n                     ((struct _websocket_handle *)response->websocket_handle)->websocket_incoming_message_callback != NULL) {\n            struct _websocket * websocket = o_malloc(sizeof(struct _websocket));\n            int websocket_has_error = 0;\n            if (websocket != NULL && ulfius_init_websocket(websocket) == U_OK) {\n              // if the session is a valid websocket request,\n              // Initiate an UPGRADE session,\n              // then run the websocket callback functions with initialized data\n              if (NULL != o_strcasestr(u_map_get_case(con_info->request->map_header, \"upgrade\"), U_WEBSOCKET_UPGRADE_VALUE) &&\n                  NULL != u_map_get_case(con_info->request->map_header, \"Sec-WebSocket-Key\") &&\n                  NULL != o_strcasestr(u_map_get_case(con_info->request->map_header, \"Connection\"), \"Upgrade\") &&\n                  0 == o_strcmp(con_info->request->http_protocol, \"HTTP/1.1\") &&\n                  0 == o_strcmp(u_map_get_case(con_info->request->map_header, \"Sec-WebSocket-Version\"), \"13\") &&\n                  0 == o_strcmp(con_info->request->http_verb, \"GET\")) {\n                int ret_protocol = U_ERROR, ret_extensions = U_OK;\n                // Check websocket_protocol and websocket_extensions to match ours\n                if (u_map_has_key(con_info->request->map_header, \"Sec-WebSocket-Extensions\") && (extension_len = pointer_list_size(((struct _websocket_handle *)response->websocket_handle)->websocket_extension_list))) {\n                  if (split_string(u_map_get_case(con_info->request->map_header, \"Sec-WebSocket-Extensions\"), \",\", &extension_list)) {\n                    for (x=0; extension_list[x]!=NULL; x++) {\n                      for (y=0; y<extension_len; y++) {\n                        struct _websocket_extension * ws_ext = (struct _websocket_extension *)pointer_list_get_at(((struct _websocket_handle *)response->websocket_handle)->websocket_extension_list, y);\n                        if (ws_ext != NULL && !ws_ext->enabled) {\n                          if (ws_ext->websocket_extension_server_match != NULL) {\n                            if (ws_ext->websocket_extension_server_match(trimwhitespace(extension_list[x]), (const char **)extension_list, &ws_ext->extension_client, ws_ext->websocket_extension_server_match_user_data, &ws_ext->context) == U_OK) {\n                              if (!(ws_ext->rsv & ((struct _websocket_handle *)response->websocket_handle)->rsv_expected)) {\n                                ((struct _websocket_handle *)response->websocket_handle)->rsv_expected |= ws_ext->rsv;\n                                ws_ext->enabled = 1;\n                                if (extension != NULL) {\n                                  extension = mstrcatf(extension, \", %s\", ws_ext->extension_client);\n                                } else {\n                                  extension = o_strdup(ws_ext->extension_client);\n                                }\n                              }\n                              break;\n                            }\n                          } else {\n                            if (0 == o_strcmp(extension_list[x], ws_ext->extension_server)) {\n                              if (!(ws_ext->rsv & ((struct _websocket_handle *)response->websocket_handle)->rsv_expected)) {\n                                ws_ext->extension_client = o_strdup(extension_list[x]);\n                                ((struct _websocket_handle *)response->websocket_handle)->rsv_expected |= ws_ext->rsv;\n                                ws_ext->enabled = 1;\n                                if (extension != NULL) {\n                                  extension = mstrcatf(extension, \", %s\", ws_ext->extension_client);\n                                } else {\n                                  extension = o_strdup(ws_ext->extension_client);\n                                }\n                                break;\n                              }\n                            }\n                          }\n                        }\n                      }\n                    }\n                  } else {\n                    y_log_message(Y_LOG_LEVEL_ERROR, \"Ulfius - Error split_string Sec-WebSocket-Extensions\");\n                  }\n                  free_string_array(extension_list);\n                } else {\n                  ret_extensions = ulfius_check_list_match(u_map_get_case(con_info->request->map_header, \"Sec-WebSocket-Extensions\"), ((struct _websocket_handle *)response->websocket_handle)->websocket_extensions, \",\", &extension);\n                }\n                if (ret_extensions == U_OK &&\n                    (ret_protocol = ulfius_check_first_match(u_map_get_case(con_info->request->map_header, \"Sec-WebSocket-Protocol\"), ((struct _websocket_handle *)response->websocket_handle)->websocket_protocol, \",\", &protocol)) == U_OK) {\n                  char websocket_accept[32] = {0};\n                  if (ulfius_generate_handshake_answer(u_map_get_case(con_info->request->map_header, \"Sec-WebSocket-Key\"), websocket_accept)) {\n                    websocket->request = ulfius_duplicate_request(con_info->request);\n                    if (websocket->request != NULL) {\n                      websocket->instance = (struct _u_instance *)cls;\n                      websocket->websocket_manager_callback = ((struct _websocket_handle *)response->websocket_handle)->websocket_manager_callback;\n                      websocket->websocket_manager_user_data = ((struct _websocket_handle *)response->websocket_handle)->websocket_manager_user_data;\n                      websocket->websocket_incoming_message_callback = ((struct _websocket_handle *)response->websocket_handle)->websocket_incoming_message_callback;\n                      websocket->websocket_incoming_user_data = ((struct _websocket_handle *)response->websocket_handle)->websocket_incoming_user_data;\n                      websocket->websocket_onclose_callback = ((struct _websocket_handle *)response->websocket_handle)->websocket_onclose_callback;\n                      websocket->websocket_onclose_user_data = ((struct _websocket_handle *)response->websocket_handle)->websocket_onclose_user_data;\n                      websocket->websocket_manager->rsv_expected = ((struct _websocket_handle *)response->websocket_handle)->rsv_expected;\n                      websocket->websocket_manager->websocket_extension_list = ((struct _websocket_handle *)response->websocket_handle)->websocket_extension_list;\n                      ((struct _websocket_handle *)response->websocket_handle)->websocket_extension_list = NULL;\n                      mhd_response = MHD_create_response_for_upgrade(ulfius_start_websocket_cb, websocket);\n                      if (mhd_response == NULL) {\n                        y_log_message(Y_LOG_LEVEL_ERROR, \"Ulfius - Error MHD_create_response_for_upgrade\");\n                        mhd_ret = MHD_NO;\n                      } else {\n                        MHD_add_response_header (mhd_response,\n                                                 MHD_HTTP_HEADER_UPGRADE,\n                                                 U_WEBSOCKET_UPGRADE_VALUE);\n                        MHD_add_response_header (mhd_response,\n                                                 \"Sec-WebSocket-Accept\",\n                                                 websocket_accept);\n                        MHD_add_response_header (mhd_response,\n                                                 \"Sec-WebSocket-Protocol\",\n                                                 protocol);\n                        if (o_strlen(extension)) {\n                          MHD_add_response_header (mhd_response,\n                                                   \"Sec-WebSocket-Extensions\",\n                                                   extension);\n                        }\n                        if (ulfius_set_response_header(mhd_response, response->map_header) == -1 || ulfius_set_response_cookie(mhd_response, response) == -1) {\n                          y_log_message(Y_LOG_LEVEL_ERROR, \"Ulfius - Error setting headers or cookies\");\n                          mhd_ret = MHD_NO;\n                          websocket_has_error = 1;\n                        } else {\n                          ulfius_instance_add_websocket_active((struct _u_instance *)cls, websocket);\n                          upgrade_protocol = 1;\n                        }\n                      }\n                    } else {\n                      // Error building struct _websocket, sending error 500\n                      response->status = MHD_HTTP_INTERNAL_SERVER_ERROR;\n                      response_buffer = o_strdup(ULFIUS_HTTP_ERROR_BODY);\n                      if (response_buffer == NULL) {\n                        y_log_message(Y_LOG_LEVEL_ERROR, \"Ulfius - Error allocating memory for websocket->request\");\n                        mhd_ret = MHD_NO;\n                      } else {\n                        response_buffer_len = o_strlen(ULFIUS_HTTP_ERROR_BODY);\n                        mhd_response = MHD_CREATE_RESPONSE_FROM_BUFFER_PIMPED (response_buffer_len, response_buffer, mhd_response_flag );\n                      }\n                      websocket_has_error = 1;\n                    }\n                  } else {\n                    // Error building ulfius_generate_handshake_answer, sending error 500\n                    response->status = MHD_HTTP_INTERNAL_SERVER_ERROR;\n                    response_buffer = o_strdup(ULFIUS_HTTP_ERROR_BODY);\n                    if (response_buffer == NULL) {\n                      y_log_message(Y_LOG_LEVEL_ERROR, \"Ulfius - Error allocating memory for response_buffer\");\n                      mhd_ret = MHD_NO;\n                    } else {\n                      response_buffer_len = o_strlen(ULFIUS_HTTP_ERROR_BODY);\n                      mhd_response = MHD_CREATE_RESPONSE_FROM_BUFFER_PIMPED (response_buffer_len, response_buffer, mhd_response_flag );\n                    }\n                    websocket_has_error = 1;\n                  }\n                } else {\n                  response->status = MHD_HTTP_BAD_REQUEST;\n                  response_buffer = msprintf(\"%s%s\", (ret_protocol!=U_OK?\"Error validating protocol\\n\":\"\"), (ret_extensions!=U_OK?\"Error validating extensions\":\"\"));\n                  y_log_message(Y_LOG_LEVEL_DEBUG, \"Ulfius - Error websocket connection: %s\", response_buffer);\n                  mhd_response = MHD_CREATE_RESPONSE_FROM_BUFFER_PIMPED (o_strlen(response_buffer), response_buffer, mhd_response_flag );\n                  websocket_has_error = 1;\n                }\n                o_free(protocol);\n                o_free(extension);\n              } else {\n                response_buffer = msprintf(\"%s%s%s%s%s%s\",\n                                           o_strcasestr(u_map_get_case(con_info->request->map_header, \"upgrade\"), U_WEBSOCKET_UPGRADE_VALUE)==NULL?\"No Upgrade websocket header\\n\":\"\",\n                                           o_strcasestr(u_map_get_case(con_info->request->map_header, \"Connection\"), \"Upgrade\")==NULL?\"No Connection Upgrade header\\n\":\"\",\n                                           u_map_get_case(con_info->request->map_header, \"Sec-WebSocket-Key\")==NULL?\"No Sec-WebSocket-Key header\\n\":\"\",\n                                           o_strcmp(con_info->request->http_protocol, \"HTTP/1.1\")!=0?\"Wrong HTTP Protocol\\n\":\"\",\n                                           o_strcmp(u_map_get_case(con_info->request->map_header, \"Sec-WebSocket-Version\"), \"13\")!=0?\"Wrong websocket version\\n\":\"\",\n                                           o_strcmp(con_info->request->http_verb, \"GET\")!=0?\"Method is not GET\\n\":\"\");\n                response->status = MHD_HTTP_BAD_REQUEST;\n                y_log_message(Y_LOG_LEVEL_DEBUG, \"Ulfius - Error websocket connection: %s\", response_buffer);\n                mhd_response = MHD_CREATE_RESPONSE_FROM_BUFFER_PIMPED (o_strlen(response_buffer), response_buffer, mhd_response_flag );\n                websocket_has_error = 1;\n              }\n            } else {\n              // Error building struct _websocket, sending error 500\n              response->status = MHD_HTTP_INTERNAL_SERVER_ERROR;\n              response_buffer = o_strdup(ULFIUS_HTTP_ERROR_BODY);\n              if (response_buffer == NULL) {\n                y_log_message(Y_LOG_LEVEL_ERROR, \"Ulfius - Error allocating memory for response_buffer\");\n                mhd_ret = MHD_NO;\n              } else {\n                response_buffer_len = o_strlen(ULFIUS_HTTP_ERROR_BODY);\n                mhd_response = MHD_CREATE_RESPONSE_FROM_BUFFER_PIMPED (response_buffer_len, response_buffer, mhd_response_flag );\n              }\n              websocket_has_error = 1;\n            }\n            close_loop = 1;\n            if (websocket_has_error) {\n              if (((struct _websocket_handle *)response->websocket_handle)->websocket_onclose_callback != NULL) {\n                ((struct _websocket_handle *)response->websocket_handle)->websocket_onclose_callback(con_info->request, websocket->websocket_manager!=NULL?websocket->websocket_manager:NULL, ((struct _websocket_handle *)response->websocket_handle)->websocket_onclose_user_data);\n              }\n              ulfius_clear_websocket(websocket);\n            }\n#endif\n          } else {\n            if ((callback_ret == U_CALLBACK_CONTINUE || callback_ret == U_CALLBACK_IGNORE) && current_endpoint_list[i+1] == NULL) {\n              // If callback_ret is U_CALLBACK_CONTINUE or U_CALLBACK_IGNORE but callback function is the last one on the list\n              callback_ret = U_CALLBACK_COMPLETE;\n            }\n            // Test callback_ret to know what to do\n            switch (callback_ret) {\n              case U_CALLBACK_CONTINUE:\n              case U_CALLBACK_IGNORE:\n                break;\n              case U_CALLBACK_COMPLETE:\n                close_loop = 1;\n                if (ulfius_get_body_from_response(response, &response_buffer, &response_buffer_len) == U_OK) {\n                  // Build the response binary_body\n                  mhd_response = MHD_CREATE_RESPONSE_FROM_BUFFER_PIMPED (response_buffer_len, response_buffer, mhd_response_flag );\n                  if (mhd_response == NULL) {\n                    y_log_message(Y_LOG_LEVEL_ERROR, \"Ulfius - Error MHD_create_response_from_buffer\");\n                    mhd_ret = MHD_NO;\n                  } else if (ulfius_set_response_header(mhd_response, response->map_header) == -1 || ulfius_set_response_cookie(mhd_response, response) == -1) {\n                    y_log_message(Y_LOG_LEVEL_ERROR, \"Ulfius - Error setting headers or cookies\");\n                    mhd_ret = MHD_NO;\n                  }\n                } else {\n                  // Error building response, sending error 500\n                  response->status = MHD_HTTP_INTERNAL_SERVER_ERROR;\n                  response_buffer = o_strdup(ULFIUS_HTTP_ERROR_BODY);\n                  if (response_buffer == NULL) {\n                    y_log_message(Y_LOG_LEVEL_ERROR, \"Ulfius - Error allocating memory for response_buffer\");\n                    mhd_ret = MHD_NO;\n                  } else {\n                    response_buffer_len = o_strlen(ULFIUS_HTTP_ERROR_BODY);\n                    mhd_response = MHD_CREATE_RESPONSE_FROM_BUFFER_PIMPED (response_buffer_len, response_buffer, mhd_response_flag );\n                  }\n                }\n                break;\n              case U_CALLBACK_UNAUTHORIZED:\n                close_loop = 1;\n                // Wrong credentials, send status 401 and realm value if set\n                if (ulfius_get_body_from_response(response, &response_buffer, &response_buffer_len) == U_OK) {\n                  mhd_response = MHD_CREATE_RESPONSE_FROM_BUFFER_PIMPED (response_buffer_len, response_buffer, mhd_response_flag );\n                  if (ulfius_set_response_header(mhd_response, response->map_header) == -1 || ulfius_set_response_cookie(mhd_response, response) == -1) {\n                    inner_error = U_ERROR_PARAMS;\n                    y_log_message(Y_LOG_LEVEL_ERROR, \"Ulfius - Error setting headers or cookies\");\n                    response->status = MHD_HTTP_INTERNAL_SERVER_ERROR;\n                    response->binary_body = o_strdup(ULFIUS_HTTP_ERROR_BODY);\n                    response->binary_body_length = o_strlen(ULFIUS_HTTP_ERROR_BODY);\n                    if (response->binary_body == NULL) {\n                      inner_error = U_ERROR_MEMORY;\n                      y_log_message(Y_LOG_LEVEL_ERROR, \"Ulfius - Error allocating memory for response->binary_body\");\n                      mhd_ret = MHD_NO;\n                    }\n                  } else {\n                    inner_error = U_CALLBACK_UNAUTHORIZED;\n                  }\n                } else {\n                  // Error building response, sending error 500\n                  response_buffer = o_strdup(ULFIUS_HTTP_ERROR_BODY);\n                  if (response_buffer == NULL) {\n                    inner_error = U_ERROR_MEMORY;\n                    y_log_message(Y_LOG_LEVEL_ERROR, \"Ulfius - Error allocating memory for response_buffer\");\n                    mhd_ret = MHD_NO;\n                  } else {\n                    response_buffer_len = o_strlen(ULFIUS_HTTP_ERROR_BODY);\n                    mhd_response = MHD_CREATE_RESPONSE_FROM_BUFFER_PIMPED (response_buffer_len, response_buffer, mhd_response_flag );\n                    inner_error = U_CALLBACK_UNAUTHORIZED;\n                  }\n                }\n                if (response->auth_realm != NULL) {\n                  auth_realm = response->auth_realm;\n                } else if (((struct _u_instance *)cls)->default_auth_realm != NULL) {\n                  auth_realm = ((struct _u_instance *)cls)->default_auth_realm;\n                }\n                break;\n              case U_CALLBACK_ERROR:\n              default:\n                close_loop = 1;\n                response->status = MHD_HTTP_INTERNAL_SERVER_ERROR;\n                response_buffer = o_strdup(ULFIUS_HTTP_ERROR_BODY);\n                if (response_buffer == NULL) {\n                  y_log_message(Y_LOG_LEVEL_ERROR, \"Ulfius - Error allocating memory for response_buffer\");\n                  mhd_ret = MHD_NO;\n                } else {\n                  response_buffer_len = o_strlen(ULFIUS_HTTP_ERROR_BODY);\n                  mhd_response = MHD_CREATE_RESPONSE_FROM_BUFFER_PIMPED (response_buffer_len, response_buffer, mhd_response_flag );\n                }\n                break;\n            }\n          }\n        }\n\n        if (!con_info->request->callback_position && ((struct _u_instance *)cls)->default_endpoint != NULL && ((struct _u_instance *)cls)->default_endpoint->callback_function != NULL && mhd_response == NULL) {\n          callback_ret = ((struct _u_instance *)cls)->default_endpoint->callback_function(con_info->request, response, ((struct _u_instance *)cls)->default_endpoint->user_data);\n          // Test callback_ret to know what to do\n          switch (callback_ret) {\n            case U_CALLBACK_UNAUTHORIZED:\n              // Wrong credentials, send status 401 and realm value if set\n              if (ulfius_get_body_from_response(response, &response_buffer, &response_buffer_len) == U_OK) {\n                mhd_response = MHD_CREATE_RESPONSE_FROM_BUFFER_PIMPED (response_buffer_len, response_buffer, mhd_response_flag );\n                if (ulfius_set_response_header(mhd_response, response->map_header) == -1 || ulfius_set_response_cookie(mhd_response, response) == -1) {\n                  inner_error = U_ERROR_PARAMS;\n                  y_log_message(Y_LOG_LEVEL_ERROR, \"Ulfius - Error setting headers or cookies\");\n                  response->status = MHD_HTTP_INTERNAL_SERVER_ERROR;\n                  response->binary_body = o_strdup(ULFIUS_HTTP_ERROR_BODY);\n                  response->binary_body_length = o_strlen(ULFIUS_HTTP_ERROR_BODY);\n                  if (response->binary_body == NULL) {\n                    inner_error = U_ERROR_MEMORY;\n                    y_log_message(Y_LOG_LEVEL_ERROR, \"Ulfius - Error allocating memory for response->binary_body\");\n                    mhd_ret = MHD_NO;\n                  }\n                } else {\n                  inner_error = U_CALLBACK_UNAUTHORIZED;\n                }\n              } else {\n                // Error building response, sending error 500\n                response_buffer = o_strdup(ULFIUS_HTTP_ERROR_BODY);\n                if (response_buffer == NULL) {\n                  inner_error = U_ERROR_MEMORY;\n                  y_log_message(Y_LOG_LEVEL_ERROR, \"Ulfius - Error allocating memory for response_buffer\");\n                  mhd_ret = MHD_NO;\n                } else {\n                  response_buffer_len = o_strlen(ULFIUS_HTTP_ERROR_BODY);\n                  mhd_response = MHD_CREATE_RESPONSE_FROM_BUFFER_PIMPED (response_buffer_len, response_buffer, mhd_response_flag );\n                  inner_error = U_CALLBACK_UNAUTHORIZED;\n                }\n              }\n              if (response->auth_realm != NULL) {\n                auth_realm = response->auth_realm;\n              } else if (((struct _u_instance *)cls)->default_auth_realm != NULL) {\n                auth_realm = ((struct _u_instance *)cls)->default_auth_realm;\n              }\n              break;\n            case U_CALLBACK_ERROR:\n              close_loop = 1;\n              response->status = MHD_HTTP_INTERNAL_SERVER_ERROR;\n              response_buffer = o_strdup(ULFIUS_HTTP_ERROR_BODY);\n              if (response_buffer == NULL) {\n                y_log_message(Y_LOG_LEVEL_ERROR, \"Ulfius - Error allocating memory for response_buffer\");\n                mhd_ret = MHD_NO;\n              } else {\n                response_buffer_len = o_strlen(ULFIUS_HTTP_ERROR_BODY);\n                mhd_response = MHD_CREATE_RESPONSE_FROM_BUFFER_PIMPED (response_buffer_len, response_buffer, mhd_response_flag );\n              }\n              break;\n            case U_CALLBACK_CONTINUE:\n            case U_CALLBACK_IGNORE:\n            case U_CALLBACK_COMPLETE:\n              if (ulfius_get_body_from_response(response, &response_buffer, &response_buffer_len) == U_OK) {\n                // Build the response binary_body\n                mhd_response = MHD_CREATE_RESPONSE_FROM_BUFFER_PIMPED (response_buffer_len, response_buffer, mhd_response_flag );\n                if (mhd_response == NULL) {\n                  y_log_message(Y_LOG_LEVEL_ERROR, \"Ulfius - Error MHD_create_response_from_buffer\");\n                  mhd_ret = MHD_NO;\n                } else if (ulfius_set_response_header(mhd_response, response->map_header) == -1 || ulfius_set_response_cookie(mhd_response, response) == -1) {\n                  y_log_message(Y_LOG_LEVEL_ERROR, \"Ulfius - Error setting headers or cookies\");\n                  mhd_ret = MHD_NO;\n                }\n              } else {\n                // Error building response, sending error 500\n                response->status = MHD_HTTP_INTERNAL_SERVER_ERROR;\n                response_buffer = o_strdup(ULFIUS_HTTP_ERROR_BODY);\n                if (response_buffer == NULL) {\n                  y_log_message(Y_LOG_LEVEL_ERROR, \"Ulfius - Error allocating memory for response_buffer\");\n                  mhd_ret = MHD_NO;\n                } else {\n                  response_buffer_len = o_strlen(ULFIUS_HTTP_ERROR_BODY);\n                  mhd_response = MHD_CREATE_RESPONSE_FROM_BUFFER_PIMPED (response_buffer_len, response_buffer, mhd_response_flag );\n                }\n              }\n              break;\n            default:\n              break;\n          }\n        }\n\n        if (mhd_response != NULL) {\n          if (auth_realm != NULL && inner_error == U_CALLBACK_UNAUTHORIZED) {\n            mhd_ret = MHD_queue_basic_auth_fail_response (connection, auth_realm, mhd_response);\n          } else if (inner_error == U_CALLBACK_UNAUTHORIZED) {\n            mhd_ret = MHD_queue_response (connection, MHD_HTTP_UNAUTHORIZED, mhd_response);\n#ifndef U_DISABLE_WEBSOCKET\n          } else if (upgrade_protocol) {\n            mhd_ret = MHD_queue_response (connection,\n                                          MHD_HTTP_SWITCHING_PROTOCOLS,\n                                          mhd_response);\n#endif\n          } else {\n            mhd_ret = MHD_queue_response (connection, response->status, mhd_response);\n          }\n          MHD_destroy_response (mhd_response);\n          // Free Response parameters\n          if (response->free_shared_data != NULL && response->shared_data != NULL) {\n            response->free_shared_data(response->shared_data);\n          }\n          ulfius_clean_response_full(response);\n          response = NULL;\n        }\n      }\n    } else {\n      response_buffer = o_strdup(ULFIUS_HTTP_NOT_FOUND_BODY);\n      if (response_buffer == NULL) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"Ulfius - Error allocating memory for response_buffer\");\n        mhd_ret = MHD_NO;\n      } else {\n        response_buffer_len = o_strlen(ULFIUS_HTTP_NOT_FOUND_BODY);\n        mhd_response = MHD_CREATE_RESPONSE_FROM_BUFFER_PIMPED (response_buffer_len, response_buffer, mhd_response_flag );\n        mhd_ret = MHD_queue_response (connection, MHD_HTTP_NOT_FOUND, mhd_response);\n        MHD_destroy_response (mhd_response);\n      }\n    }\n#if MHD_VERSION < 0x00096100\n    if (mhd_response_flag == MHD_RESPMEM_MUST_COPY) {\n      o_free(response_buffer);\n    }\n#else\n    (void)mhd_response_flag;\n#endif\n    for (i=0; current_endpoint_list[i] != NULL; i++) {\n      ulfius_clean_endpoint(current_endpoint_list[i]);\n      o_free(current_endpoint_list[i]);\n    }\n    o_free(current_endpoint_list);\n    return mhd_ret;\n  }\n}\n\n/**\n * ulfius_run_mhd_daemon\n * Starts a mhd daemon for the specified instance\n * return a pointer to the mhd_daemon on success, NULL on error\n *\n */\nstatic struct MHD_Daemon * ulfius_run_mhd_daemon(struct _u_instance * u_instance, const char * key_pem, const char * cert_pem, const char * root_ca_perm) {\n  unsigned int mhd_flags = MHD_USE_THREAD_PER_CONNECTION;\n  int index;\n\n#ifdef DEBUG\n  mhd_flags |= MHD_USE_DEBUG;\n#endif\n#if MHD_VERSION >= 0x00095300\n  mhd_flags |= MHD_USE_INTERNAL_POLLING_THREAD;\n#endif\n#ifndef U_DISABLE_WEBSOCKET\n  mhd_flags |= MHD_ALLOW_UPGRADE;\n#endif\n\n  if (u_instance->mhd_daemon == NULL) {\n    struct MHD_OptionItem mhd_ops[8];\n\n    // Default options\n    mhd_ops[0].option = MHD_OPTION_NOTIFY_COMPLETED;\n    mhd_ops[0].value = (intptr_t)mhd_request_completed;\n    mhd_ops[0].ptr_value = NULL;\n\n#if MHD_VERSION >= 0x00095208\n    // If bind_address6 is specified, listen only to IPV6 addresses\n    if (u_instance->bind_address6 != NULL) {\n      mhd_ops[1].option = MHD_OPTION_SOCK_ADDR;\n      mhd_ops[1].value = 0;\n      mhd_ops[1].ptr_value = (void *)u_instance->bind_address6;\n      mhd_flags |= MHD_USE_IPv6;\n    } else {\n      mhd_ops[1].option = MHD_OPTION_SOCK_ADDR;\n      mhd_ops[1].value = 0;\n      mhd_ops[1].ptr_value = (void *)u_instance->bind_address;\n      // Default network stack is listening to IPV4 only\n      if ((u_instance->network_type & U_USE_IPV4) && (u_instance->network_type & U_USE_IPV6)) {\n        // If u_instance->network_type & U_USE_ALL, listen to IPV4 and IPV6 addresses\n        mhd_flags |= MHD_USE_DUAL_STACK;\n      } else if (u_instance->network_type & U_USE_IPV6) {\n        // If u_instance->network_type & U_USE_IPV6, listen to IPV6 addresses only\n        mhd_flags |= MHD_USE_IPv6;\n      }\n    }\n#else\n    mhd_ops[1].option = MHD_OPTION_SOCK_ADDR;\n    mhd_ops[1].value = 0;\n    mhd_ops[1].ptr_value = (void *)u_instance->bind_address;\n#endif\n\n    mhd_ops[2].option = MHD_OPTION_URI_LOG_CALLBACK;\n    mhd_ops[2].value = (intptr_t)ulfius_uri_logger;\n    mhd_ops[2].ptr_value = NULL;\n\n    index = 3;\n\n    if (key_pem != NULL && cert_pem != NULL) {\n      // HTTPS parameters\n      mhd_flags |= MHD_USE_SSL;\n      mhd_ops[index].option = MHD_OPTION_HTTPS_MEM_KEY;\n      mhd_ops[index].value = 0;\n      mhd_ops[index].ptr_value = (void*)key_pem;\n\n      mhd_ops[index + 1].option = MHD_OPTION_HTTPS_MEM_CERT;\n      mhd_ops[index + 1].value = 0;\n      mhd_ops[index + 1].ptr_value = (void*)cert_pem;\n\n      index += 2;\n\n      if (root_ca_perm != NULL) {\n        mhd_ops[index].option = MHD_OPTION_HTTPS_MEM_TRUST;\n        mhd_ops[index].value = 0;\n        mhd_ops[index].ptr_value = (void *)root_ca_perm;\n\n        index++;\n      }\n    }\n    if (u_instance->timeout > 0) {\n      mhd_ops[index].option = MHD_OPTION_CONNECTION_TIMEOUT;\n      mhd_ops[index].value = u_instance->timeout;\n      mhd_ops[index].ptr_value = NULL;\n\n      index++;\n    }\n\n    mhd_ops[index].option = MHD_OPTION_END;\n    mhd_ops[index].value = 0;\n    mhd_ops[index].ptr_value = NULL;\n\n    return MHD_start_daemon (\n      mhd_flags, u_instance->port, NULL, NULL, &ulfius_webservice_dispatcher, (void *)u_instance,\n      MHD_OPTION_ARRAY, mhd_ops,\n      MHD_OPTION_END\n    );\n  } else {\n    y_log_message(Y_LOG_LEVEL_ERROR, \"Ulfius - Error, instance already started\");\n    return NULL;\n  }\n}\n\n/**\n * ulfius_start_framework\n * Initializes the framework and run the webservice based on the parameters given\n * return true if no error\n *\n * u_instance:    pointer to a struct _u_instance that describe its port and bind address\n * return U_OK on success\n */\nint ulfius_start_framework(struct _u_instance * u_instance) {\n#ifndef U_DISABLE_GNUTLS\n  return ulfius_start_secure_ca_trust_framework(u_instance, NULL, NULL, NULL);\n#else\n  return ulfius_start_secure_framework(u_instance, NULL, NULL);\n#endif\n}\n\n/**\n * ulfius_start_secure_framework\n * Initializes the framework and run the webservice based on the parameters given using an HTTPS connection\n *\n * u_instance:    pointer to a struct _u_instance that describe its port and bind address\n * key_pem:       private key for the server\n * cert_pem:      server certificate\n * return U_OK on success\n */\nint ulfius_start_secure_framework(struct _u_instance * u_instance, const char * key_pem, const char * cert_pem) {\n#ifndef U_DISABLE_GNUTLS\n  return ulfius_start_secure_ca_trust_framework(u_instance, key_pem, cert_pem, NULL);\n#else\n#ifndef U_DISABLE_JANSSON\n  o_malloc_t malloc_fn;\n  o_free_t free_fn;\n\n  o_get_alloc_funcs(&malloc_fn, NULL, &free_fn);\n  json_set_alloc_funcs((json_malloc_t)malloc_fn, (json_free_t)free_fn);\n#endif\n  // Check parameters and validate u_instance and endpoint_list that there is no mistake\n  if (u_instance == NULL) {\n    y_log_message(Y_LOG_LEVEL_ERROR, \"Ulfius - ulfius_start_secure_framework - Error, u_instance is NULL\");\n    return U_ERROR_PARAMS;\n  } else if ((key_pem == NULL && cert_pem != NULL) || (key_pem != NULL && cert_pem == NULL)) {\n    y_log_message(Y_LOG_LEVEL_ERROR, \"Ulfius - ulfius_start_secure_framework - Error, you must specify key_pem and cert_pem\");\n    return U_ERROR_PARAMS;\n  }\n  if (ulfius_validate_instance(u_instance) == U_OK) {\n    u_instance->mhd_daemon = ulfius_run_mhd_daemon(u_instance, key_pem, cert_pem, NULL);\n\n    if (u_instance->mhd_daemon == NULL) {\n      y_log_message(Y_LOG_LEVEL_ERROR, \"Ulfius - Error MHD_start_daemon, aborting\");\n      u_instance->status = U_STATUS_ERROR;\n      return U_ERROR_LIBMHD;\n    } else {\n      u_instance->status = U_STATUS_RUNNING;\n      return U_OK;\n    }\n  } else {\n    y_log_message(Y_LOG_LEVEL_ERROR, \"Ulfius - ulfius_start_secure_framework - error input parameters\");\n    return U_ERROR_PARAMS;\n  }\n#endif\n}\n\n#ifndef U_DISABLE_GNUTLS\n/**\n * ulfius_start_secure_ca_trust_framework\n * Initializes the framework and run the webservice based on the parameters given using an HTTPS connection\n * And using a root server to authenticate client connections\n *\n * u_instance:    pointer to a struct _u_instance that describe its port and bind address\n * key_pem:       private key for the server\n * cert_pem:      server certificate\n * root_ca_pem:   client root CA you're willing to trust for this instance\n * return U_OK on success\n */\nint ulfius_start_secure_ca_trust_framework(struct _u_instance * u_instance, const char * key_pem, const char * cert_pem, const char * root_ca_pem) {\n#ifndef U_DISABLE_JANSSON\n  o_malloc_t malloc_fn;\n  o_free_t free_fn;\n\n  o_get_alloc_funcs(&malloc_fn, NULL, &free_fn);\n  json_set_alloc_funcs((json_malloc_t)malloc_fn, (json_free_t)free_fn);\n#endif\n  // Check parameters and validate u_instance and endpoint_list that there is no mistake\n  if (u_instance == NULL) {\n    y_log_message(Y_LOG_LEVEL_ERROR, \"Ulfius - ulfius_start_secure_ca_trust_framework - Error, u_instance is NULL\");\n    return U_ERROR_PARAMS;\n  } else if ((key_pem == NULL && cert_pem != NULL) || (key_pem != NULL && cert_pem == NULL)) {\n    y_log_message(Y_LOG_LEVEL_ERROR, \"Ulfius - ulfius_start_secure_ca_trust_framework - Error, you must specify key_pem and cert_pem\");\n    return U_ERROR_PARAMS;\n  } else if (root_ca_pem != NULL && (key_pem == NULL || cert_pem == NULL)) {\n    y_log_message(Y_LOG_LEVEL_ERROR, \"Ulfius - ulfius_start_secure_ca_trust_framework - Error, you must specify key_pem and cert_pem in addition to root_ca_pem\");\n    return U_ERROR_PARAMS;\n  }\n  if (root_ca_pem != NULL) {\n    u_instance->use_client_cert_auth = 1;\n  } else {\n    u_instance->use_client_cert_auth = 0;\n  }\n  if (ulfius_validate_instance(u_instance) == U_OK) {\n    u_instance->mhd_daemon = ulfius_run_mhd_daemon(u_instance, key_pem, cert_pem, root_ca_pem);\n\n    if (u_instance->mhd_daemon == NULL) {\n      y_log_message(Y_LOG_LEVEL_ERROR, \"Ulfius - Error MHD_start_daemon, aborting\");\n      u_instance->status = U_STATUS_ERROR;\n      return U_ERROR_LIBMHD;\n    } else {\n      u_instance->status = U_STATUS_RUNNING;\n      return U_OK;\n    }\n  } else {\n    y_log_message(Y_LOG_LEVEL_ERROR, \"Ulfius - ulfius_start_secure_ca_trust_framework - error input parameters\");\n    return U_ERROR_PARAMS;\n  }\n}\n#endif\n\n/**\n * ulfius_start_framework_with_mhd_options\n * Initializes the framework and run the webservice based on the specified MHD options table given in parameter\n * Read https://www.gnu.org/software/libmicrohttpd/tutorial.html for more information\n * This is for user who know what they do, Ulfius' options used in other `ulfius_start_framework_*`\n * are good for most use cases where you need a multi-threaded HTTP webservice\n * Some struct MHD_OptionItem may cause unexpected problems with Ulfius API\n * If you find an unresolved issue with this function you can open an issue in GitHub\n * But some issues may not be solvable if fixing them would break Ulfius API or philosophy\n * i.e.: you're on your own\n * @param u_instance pointer to a struct _u_instance that describe its port and bind address\n * @param mhd_flags OR-ed combination of MHD_FLAG values\n * @param mhd_ops struct MHD_OptionItem * options table\n * - MUST contain an option with the fllowing value: {.option = MHD_OPTION_NOTIFY_COMPLETED; .value = (intptr_t)mhd_request_completed; .ptr_value = NULL;}\n * - MUST contain an option with the fllowing value: {.option = MHD_OPTION_URI_LOG_CALLBACK; .value = (intptr_t)ulfius_uri_logger; .ptr_value = NULL;}\n * - MUST end with a terminal struct MHD_OptionItem: {.option = MHD_OPTION_END; .value = 0; .ptr_value = NULL;}\n * @return U_OK on success\n */\nint ulfius_start_framework_with_mhd_options(struct _u_instance * u_instance, unsigned int mhd_flags, struct MHD_OptionItem * mhd_ops) {\n  if (u_instance == NULL) {\n    y_log_message(Y_LOG_LEVEL_ERROR, \"Ulfius - ulfius_start_framework_with_mhd_options - Error, u_instance is NULL\");\n    return U_ERROR_PARAMS;\n  } else if (mhd_ops == NULL) {\n    y_log_message(Y_LOG_LEVEL_ERROR, \"Ulfius - ulfius_start_framework_with_mhd_options - Error, mhd_ops is NULL\");\n    return U_ERROR_PARAMS;\n  } else {\n    u_instance->mhd_daemon = MHD_start_daemon (mhd_flags, u_instance->port, NULL, NULL, &ulfius_webservice_dispatcher, (void *)u_instance, MHD_OPTION_ARRAY, mhd_ops, MHD_OPTION_END);\n    if (u_instance->mhd_daemon != NULL) {\n      u_instance->status = U_STATUS_RUNNING;\n      return U_OK;\n    } else {\n      y_log_message(Y_LOG_LEVEL_ERROR, \"Ulfius - ulfius_start_framework_with_mhd_options - Error MHD_start_daemon, aborting\");\n      u_instance->status = U_STATUS_ERROR;\n      return U_ERROR_LIBMHD;\n    }\n  }\n}\n\n/**\n * ulfius_stop_framework\n *\n * Stop the webservice\n * u_instance:    pointer to a struct _u_instance that describe its port and bind address\n * return U_OK on success\n */\nint ulfius_stop_framework(struct _u_instance * u_instance) {\n  if (u_instance != NULL && u_instance->mhd_daemon != NULL) {\n#ifndef U_DISABLE_WEBSOCKET\n    int i;\n    // Loop in all active websockets and send close signal\n    if (pthread_mutex_lock(&((struct _websocket_handler *)u_instance->websocket_handler)->websocket_active_lock)) {\n      y_log_message(Y_LOG_LEVEL_ERROR, \"Ulfius - Error locking websocket websocket_active_lock\");\n    } else {\n      for (i=((struct _websocket_handler *)u_instance->websocket_handler)->nb_websocket_active-1; i>=0; i--) {\n        ((struct _websocket_handler *)u_instance->websocket_handler)->websocket_active[i]->websocket_manager->close_flag = 1;\n      }\n      pthread_mutex_unlock(&((struct _websocket_handler *)u_instance->websocket_handler)->websocket_active_lock);\n    }\n    pthread_mutex_lock(&((struct _websocket_handler *)u_instance->websocket_handler)->websocket_close_lock);\n    while (((struct _websocket_handler *)u_instance->websocket_handler)->nb_websocket_active > 0) {\n      pthread_cond_wait(&((struct _websocket_handler *)u_instance->websocket_handler)->websocket_close_cond, &((struct _websocket_handler *)u_instance->websocket_handler)->websocket_close_lock);\n    }\n    pthread_mutex_unlock(&((struct _websocket_handler *)u_instance->websocket_handler)->websocket_close_lock);\n#endif\n    MHD_stop_daemon (u_instance->mhd_daemon);\n    u_instance->mhd_daemon = NULL;\n    u_instance->status = U_STATUS_STOP;\n    return U_OK;\n  } else if (u_instance != NULL) {\n    u_instance->status = U_STATUS_ERROR;\n    return U_ERROR_PARAMS;\n  } else {\n    return U_ERROR;\n  }\n}\n\n/**\n * ulfius_copy_endpoint\n * return a copy of an endpoint with duplicate values\n */\nint ulfius_copy_endpoint(struct _u_endpoint * dest, const struct _u_endpoint * source) {\n  if (source != NULL && dest != NULL) {\n    dest->http_method = o_strdup(source->http_method);\n    dest->url_prefix = o_strdup(source->url_prefix);\n    dest->url_format = o_strdup(source->url_format);\n    dest->callback_function = source->callback_function;\n    dest->user_data = source->user_data;\n    dest->priority = source->priority;\n    if (ulfius_is_valid_endpoint(dest, 0)) {\n      return U_OK;\n    } else {\n      return U_ERROR_MEMORY;\n    }\n  }\n  return U_ERROR_PARAMS;\n}\n\n/**\n * duplicate_endpoint_list\n * return a copy of an endpoint list with duplicate values\n * returned value must be free'd after use\n */\nstruct _u_endpoint * ulfius_duplicate_endpoint_list(const struct _u_endpoint * endpoint_list) {\n  struct _u_endpoint * to_return = NULL;\n  int i;\n\n  if (endpoint_list != NULL) {\n    for (i=0; endpoint_list[i].http_method != NULL; i++) {\n      if ((to_return = o_realloc(to_return, (i+1)*sizeof(struct _u_endpoint *))) == NULL) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"Ulfius - Error allocating memory for duplicate_endpoint_list.to_return\");\n        return NULL;\n      } else {\n        ulfius_copy_endpoint(&to_return[i], &endpoint_list[i]);\n      }\n    }\n  }\n  return to_return;\n}\n\n/**\n * clean_endpoint\n * free allocated memory by an endpoint\n */\nvoid ulfius_clean_endpoint(struct _u_endpoint * endpoint) {\n  if (endpoint != NULL) {\n    o_free(endpoint->http_method);\n    o_free(endpoint->url_prefix);\n    o_free(endpoint->url_format);\n    endpoint->http_method = NULL;\n    endpoint->url_prefix = NULL;\n    endpoint->url_format = NULL;\n  }\n}\n\n/**\n * ulfius_clean_endpoint_list\n * free allocated memory by an endpoint list\n */\nvoid ulfius_clean_endpoint_list(struct _u_endpoint * endpoint_list) {\n  int i;\n\n  if (endpoint_list != NULL) {\n    for (i=0; endpoint_list[i].http_method != NULL; i++) {\n      ulfius_clean_endpoint(&endpoint_list[i]);\n    }\n    o_free(endpoint_list);\n  }\n}\n\nint ulfius_add_endpoint(struct _u_instance * u_instance, const struct _u_endpoint * u_endpoint) {\n  int res;\n\n  if (u_instance != NULL && u_endpoint != NULL) {\n    if (ulfius_is_valid_endpoint(u_endpoint, 0)) {\n      if (u_instance->endpoint_list == NULL) {\n        // No endpoint, create a list with 2 endpoints so the last one is an empty one\n        u_instance->endpoint_list = o_malloc(2 * sizeof(struct _u_endpoint));\n        if (u_instance->endpoint_list == NULL) {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"Ulfius - ulfius_add_endpoint, Error allocating memory for u_instance->endpoint_list\");\n          return U_ERROR_MEMORY;\n        }\n        u_instance->nb_endpoints = 1;\n      } else {\n        u_instance->nb_endpoints++;\n        u_instance->endpoint_list = o_realloc(u_instance->endpoint_list, (u_instance->nb_endpoints + 1) * sizeof(struct _u_endpoint));\n        if (u_instance->endpoint_list == NULL) {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"Ulfius - ulfius_add_endpoint, Error reallocating memory for u_instance->endpoint_list\");\n          return U_ERROR_MEMORY;\n        }\n      }\n      res = ulfius_copy_endpoint(&u_instance->endpoint_list[u_instance->nb_endpoints - 1], u_endpoint);\n      if (res != U_OK) {\n        return res;\n      } else {\n        // Add empty endpoint at the end of the endpoint list\n        ulfius_copy_endpoint(&u_instance->endpoint_list[u_instance->nb_endpoints], ulfius_empty_endpoint());\n      }\n      return U_OK;\n    } else {\n      y_log_message(Y_LOG_LEVEL_ERROR, \"Ulfius - ulfius_add_endpoint, invalid struct _u_endpoint\");\n      return U_ERROR_PARAMS;\n    }\n  } else {\n    y_log_message(Y_LOG_LEVEL_ERROR, \"Ulfius - ulfius_add_endpoint, invalid parameters\");\n    return U_ERROR_PARAMS;\n  }\n  return U_ERROR;\n}\n\nint ulfius_add_endpoint_list(struct _u_instance * u_instance, const struct _u_endpoint ** u_endpoint_list) {\n  int i, res;\n  if (u_instance != NULL && u_endpoint_list != NULL) {\n    for (i=0; !ulfius_equals_endpoints(u_endpoint_list[i], ulfius_empty_endpoint()); i++) {\n      res = ulfius_add_endpoint(u_instance, u_endpoint_list[i]);\n      if (res != U_OK) {\n        return res;\n      }\n    }\n    return U_OK;\n  } else {\n    y_log_message(Y_LOG_LEVEL_ERROR, \"Ulfius - ulfius_add_endpoint_list, invalid parameters\");\n    return U_ERROR_PARAMS;\n  }\n  return U_ERROR;\n}\n\nint ulfius_remove_endpoint(struct _u_instance * u_instance, const struct _u_endpoint * u_endpoint) {\n  int i, j, found = 0, ret = U_OK;\n  char * trim_prefix = NULL, * trim_prefix_save = NULL, * trim_format = NULL, * trim_format_save = NULL,\n       * trim_cur_prefix = NULL, * trim_cur_prefix_save = NULL, * trim_cur_format = NULL, * trim_cur_format_save = NULL;\n  if (u_instance != NULL && u_endpoint != NULL && !ulfius_equals_endpoints(u_endpoint, ulfius_empty_endpoint()) && ulfius_is_valid_endpoint(u_endpoint, 1)) {\n    trim_prefix_save = o_strdup(u_endpoint->url_prefix);\n    trim_prefix = trimcharacter(trim_prefix_save, '/');\n    trim_format_save = o_strdup(u_endpoint->url_format);\n    trim_format = trimcharacter(trim_format_save, '/');\n    for (i=u_instance->nb_endpoints-1; i>=0 && ret == U_OK; i--) {\n      trim_cur_prefix_save = o_strdup(u_instance->endpoint_list[i].url_prefix);\n      trim_cur_prefix = trimcharacter(trim_cur_prefix_save, '/');\n      trim_cur_format_save = o_strdup(u_instance->endpoint_list[i].url_format);\n      trim_cur_format = trimcharacter(trim_cur_format_save, '/');\n\n      // Compare u_endpoint with u_instance->endpoint_list[i]\n      if (0 == o_strcmp(u_instance->endpoint_list[i].http_method, u_endpoint->http_method) &&\n          0 == o_strcmp(trim_cur_prefix, trim_prefix) &&\n          0 == o_strcmp(trim_cur_format, trim_format)) {\n        // It's a match!\n        // Remove current endpoint and move the next ones to their previous index, then reduce the endpoint_list by 1\n        found = 1;\n        o_free(u_instance->endpoint_list[i].http_method);\n        o_free(u_instance->endpoint_list[i].url_prefix);\n        o_free(u_instance->endpoint_list[i].url_format);\n        for (j=i; j<u_instance->nb_endpoints; j++) {\n          u_instance->endpoint_list[j] = u_instance->endpoint_list[j+1];\n        }\n        u_instance->nb_endpoints--;\n        u_instance->endpoint_list = o_realloc(u_instance->endpoint_list, (u_instance->nb_endpoints + 1)*sizeof(struct _u_endpoint));\n        if (u_instance->endpoint_list == NULL) {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"Ulfius - ulfius_add_endpoint, Error reallocating memory for u_instance->endpoint_list\");\n          ret = U_ERROR_MEMORY;\n        }\n      }\n      o_free(trim_cur_prefix_save);\n      o_free(trim_cur_format_save);\n      trim_cur_prefix_save = NULL;\n      trim_cur_format_save = NULL;\n    }\n    if (!found) {\n      ret = U_ERROR_NOT_FOUND;\n    }\n    o_free(trim_prefix_save);\n    o_free(trim_format_save);\n    trim_prefix_save = NULL;\n    trim_format_save = NULL;\n  } else {\n    y_log_message(Y_LOG_LEVEL_ERROR, \"Ulfius - ulfius_remove_endpoint, invalid parameters\");\n    ret = U_ERROR_PARAMS;\n  }\n  return ret;\n}\n\nconst struct _u_endpoint * ulfius_empty_endpoint(void) {\n  static struct _u_endpoint empty_endpoint;\n\n  empty_endpoint.http_method = NULL;\n  empty_endpoint.url_prefix = NULL;\n  empty_endpoint.url_format = NULL;\n  empty_endpoint.callback_function = NULL;\n  empty_endpoint.user_data = NULL;\n  return &empty_endpoint;\n}\n\nint ulfius_equals_endpoints(const struct _u_endpoint * endpoint1, const struct _u_endpoint * endpoint2) {\n  if (endpoint1 != NULL && endpoint2 != NULL) {\n    if (endpoint1 == endpoint2) {\n      return 1;\n    } else if (o_strcmp(endpoint2->http_method, endpoint1->http_method) != 0) {\n        return 0;\n    } else if (o_strcmp(endpoint2->url_prefix, endpoint1->url_prefix) != 0) {\n        return 0;\n    } else if (o_strcmp(endpoint2->url_format, endpoint1->url_format) != 0) {\n        return 0;\n    } else {\n      return 1;\n    }\n  } else {\n    return 1;\n  }\n}\n\nint ulfius_add_endpoint_by_val(struct _u_instance * u_instance,\n                               const char * http_method,\n                               const char * url_prefix,\n                               const char * url_format,\n                               unsigned int priority,\n                               int (* callback_function)(const struct _u_request * request, // Input parameters (set by the framework)\n                                                         struct _u_response * response,     // Output parameters (set by the user)\n                                                         void * user_data),\n                               void * user_data) {\n  struct _u_endpoint endpoint;\n  if (u_instance != NULL) {\n    endpoint.http_method = (char *)http_method;\n    endpoint.url_prefix = (char *)url_prefix;\n    endpoint.url_format = (char *)url_format;\n    endpoint.priority = priority;\n    endpoint.callback_function = callback_function;\n    endpoint.user_data = user_data;\n    return ulfius_add_endpoint(u_instance, &endpoint);\n  } else {\n    return U_ERROR_PARAMS;\n  }\n}\n\nint ulfius_remove_endpoint_by_val(struct _u_instance * u_instance, const char * http_method, const char * url_prefix, const char * url_format) {\n  struct _u_endpoint endpoint;\n  if (u_instance != NULL) {\n    endpoint.http_method = (char *)http_method;\n    endpoint.url_prefix = (char *)url_prefix;\n    endpoint.url_format = (char *)url_format;\n    endpoint.callback_function = NULL;\n    return ulfius_remove_endpoint(u_instance, &endpoint);\n  } else {\n    return U_ERROR_PARAMS;\n  }\n}\n\nint ulfius_set_default_endpoint(struct _u_instance * u_instance,\n                                         int (* callback_function)(const struct _u_request * request, struct _u_response * response, void * user_data),\n                                         void * user_data) {\n  if (u_instance != NULL && callback_function != NULL) {\n    if (u_instance->default_endpoint == NULL) {\n      u_instance->default_endpoint = o_malloc(sizeof(struct _u_endpoint));\n      if (u_instance->default_endpoint == NULL) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"Ulfius - Error allocating memory for u_instance->default_endpoint\");\n        return U_ERROR_MEMORY;\n      }\n    }\n    u_instance->default_endpoint->http_method = NULL;\n    u_instance->default_endpoint->url_prefix = NULL;\n    u_instance->default_endpoint->url_format = NULL;\n    u_instance->default_endpoint->callback_function = callback_function;\n    u_instance->default_endpoint->user_data = user_data;\n    u_instance->default_endpoint->priority = 0;\n    return U_OK;\n  } else {\n    return U_ERROR_PARAMS;\n  }\n}\n\nint ulfius_set_upload_file_callback_function(struct _u_instance * u_instance,\n                                             int (* file_upload_callback) (const struct _u_request * request,\n                                                                           const char * key,\n                                                                           const char * filename,\n                                                                           const char * content_type,\n                                                                           const char * transfer_encoding,\n                                                                           const char * data,\n                                                                           uint64_t off,\n                                                                           size_t size,\n                                                                           void * cls),\n                                             void * cls) {\n  if (u_instance != NULL && file_upload_callback != NULL) {\n    u_instance->file_upload_callback = file_upload_callback;\n    u_instance->file_upload_cls = cls;\n    return U_OK;\n  } else {\n    return U_ERROR_PARAMS;\n  }\n}\n\nvoid ulfius_clean_instance(struct _u_instance * u_instance) {\n  if (u_instance != NULL) {\n    ulfius_clean_endpoint_list(u_instance->endpoint_list);\n    u_map_clean_full(u_instance->default_headers);\n    o_free(u_instance->default_auth_realm);\n    o_free(u_instance->default_endpoint);\n    u_instance->endpoint_list = NULL;\n    u_instance->default_headers = NULL;\n    u_instance->default_auth_realm = NULL;\n    u_instance->bind_address = NULL;\n    u_instance->default_endpoint = NULL;\n#ifndef U_DISABLE_WEBSOCKET\n    /* ulfius_clean_instance might be called without websocket_handler being initialized */\n    if ((struct _websocket_handler *)u_instance->websocket_handler) {\n      if (((struct _websocket_handler *)u_instance->websocket_handler)->pthread_init &&\n          (pthread_mutex_destroy(&((struct _websocket_handler *)u_instance->websocket_handler)->websocket_close_lock) ||\n          pthread_cond_destroy(&((struct _websocket_handler *)u_instance->websocket_handler)->websocket_close_cond) ||\n          pthread_mutex_destroy(&((struct _websocket_handler *)u_instance->websocket_handler)->websocket_active_lock))) {\n        y_log_message(Y_LOG_LEVEL_ERROR, \"Ulfius - Error destroying websocket_close_lock or websocket_close_cond or websocket_active_lock\");\n      }\n      o_free(u_instance->websocket_handler);\n      u_instance->websocket_handler = NULL;\n    }\n#endif\n  }\n}\n\nstatic int internal_ulfius_init_instance(struct _u_instance * u_instance,\n                                         unsigned int port,\n                                         struct sockaddr_in * bind_address4,\n                                         struct sockaddr_in6 * bind_address6,\n                                         unsigned short network_type,\n                                         const char * default_auth_realm) {\n#ifndef U_DISABLE_WEBSOCKET\n  pthread_mutexattr_t mutexattr;\n#endif\n#if MHD_VERSION >= 0x00095208\n  if (u_instance != NULL && port > 0 && port < 65536 && (bind_address4 == NULL || bind_address6 == NULL) && (network_type & U_USE_ALL)) {\n#else\nUNUSED(network_type);\n  if (u_instance != NULL && port > 0 && port < 65536) {\n#endif\n    u_instance->mhd_daemon = NULL;\n    u_instance->status = U_STATUS_STOP;\n    u_instance->port = port;\n    u_instance->bind_address = bind_address4;\n    u_instance->bind_address6 = bind_address6;\n#if MHD_VERSION >= 0x00095208\n    u_instance->network_type = network_type;\n#endif\n    u_instance->timeout = 0;\n    u_instance->default_auth_realm = o_strdup(default_auth_realm);\n    u_instance->nb_endpoints = 0;\n    u_instance->endpoint_list = NULL;\n    u_instance->default_headers = o_malloc(sizeof(struct _u_map));\n    u_instance->mhd_response_copy_data = 0;\n    u_instance->check_utf8 = 1;\n    if (u_instance->default_headers == NULL) {\n      y_log_message(Y_LOG_LEVEL_ERROR, \"Ulfius - Error allocating memory for u_instance->default_headers\");\n      ulfius_clean_instance(u_instance);\n      return U_ERROR_MEMORY;\n    }\n    u_map_init(u_instance->default_headers);\n    u_instance->default_endpoint = NULL;\n    u_instance->max_post_param_size = 0;\n    u_instance->max_post_body_size = 0;\n    u_instance->file_upload_callback = NULL;\n    u_instance->file_upload_cls = NULL;\n#ifndef U_DISABLE_GNUTLS\n    u_instance->use_client_cert_auth = 0;\n#endif\n#ifndef U_DISABLE_WEBSOCKET\n    u_instance->websocket_handler = o_malloc(sizeof(struct _websocket_handler));\n    if (u_instance->websocket_handler == NULL) {\n      y_log_message(Y_LOG_LEVEL_ERROR, \"Ulfius - Error allocating memory for u_instance->websocket_handler\");\n      ulfius_clean_instance(u_instance);\n      return U_ERROR_MEMORY;\n    }\n    pthread_mutexattr_init ( &mutexattr );\n    pthread_mutexattr_settype( &mutexattr, PTHREAD_MUTEX_RECURSIVE );\n    if (pthread_mutex_init(&((struct _websocket_handler *)u_instance->websocket_handler)->websocket_active_lock, &mutexattr) != 0) {\n      y_log_message(Y_LOG_LEVEL_ERROR, \"Ulfius - Error initializing websocket_active_lock\");\n      ulfius_clean_instance(u_instance);\n      return U_ERROR;\n    }\n    pthread_mutexattr_destroy(&mutexattr);\n    ((struct _websocket_handler *)u_instance->websocket_handler)->pthread_init = 0;\n    ((struct _websocket_handler *)u_instance->websocket_handler)->nb_websocket_active = 0;\n    ((struct _websocket_handler *)u_instance->websocket_handler)->websocket_active = NULL;\n    if (pthread_mutex_init(&((struct _websocket_handler *)u_instance->websocket_handler)->websocket_close_lock, NULL) ||\n        pthread_cond_init(&((struct _websocket_handler *)u_instance->websocket_handler)->websocket_close_cond, NULL)) {\n      y_log_message(Y_LOG_LEVEL_ERROR, \"Ulfius - Error initializing websocket_close_lock or websocket_close_cond\");\n      ulfius_clean_instance(u_instance);\n      return U_ERROR_MEMORY;\n    }\n    ((struct _websocket_handler *)u_instance->websocket_handler)->pthread_init = 1;\n#else\n    u_instance->websocket_handler = NULL;\n#endif\n    return U_OK;\n  } else {\n    return U_ERROR_PARAMS;\n  }\n}\n\nint ulfius_init_instance(struct _u_instance * u_instance, unsigned int port, struct sockaddr_in * bind_address, const char * default_auth_realm) {\n  return internal_ulfius_init_instance(u_instance, port, bind_address, NULL, U_USE_IPV4, default_auth_realm);\n}\n\n#if MHD_VERSION >= 0x00095208\nint ulfius_init_instance_ipv6(struct _u_instance * u_instance, unsigned int port, struct sockaddr_in6 * bind_address, unsigned short network_type, const char * default_auth_realm) {\n  if (network_type & U_USE_IPV6) {\n    return internal_ulfius_init_instance(u_instance, port, NULL, bind_address, bind_address!=NULL?U_USE_IPV6:network_type, default_auth_realm);\n  } else {\n    return U_ERROR_PARAMS;\n  }\n}\n#endif\n\nvoid u_free(void * data) {\n  o_free(data);\n}\n\n/**\n * The utf8_check() function scans the string starting\n * at s. It returns a pointer to the first byte of the first malformed\n * or overlong UTF-8 sequence found, or NULL if the string contains\n * only correct UTF-8. It also spots UTF-8 sequences that could cause\n * trouble if converted to UTF-16, namely surrogate characters\n * (U+D800..U+DFFF) and non-Unicode positions (U+FFFE..U+FFFF). This\n * routine is very likely to find a malformed sequence if the input\n * uses any other encoding than UTF-8. It therefore can be used as a\n * very effective heuristic for distinguishing between UTF-8 and other\n * encodings.\n *\n * I wrote this code mainly as a specification of functionality; there\n * are no doubt performance optimizations possible for certain CPUs.\n *\n * Markus Kuhn <http://www.cl.cam.ac.uk/~mgk25/> -- 2005-03-30\n * Nicolas Mora <mail@babelouest.org>\n * License: http://www.cl.cam.ac.uk/~mgk25/short-license.html\n */\nconst unsigned char * utf8_check(const char * s_orig, size_t len) {\n  const unsigned char * s = (unsigned char *)s_orig;\n  size_t i = 0;\n\n  while (i<len) {\n    if (*s < 0x80) {\n      /* 0xxxxxxx */\n      s++;\n      i++;\n    } else if ((s[0] & 0xe0) == 0xc0) {\n      /* 110XXXXx 10xxxxxx */\n      if ((i+1 >= len) ||\n          (s[1] & 0xc0) != 0x80 ||\n          (s[0] & 0xfe) == 0xc0) {                  /* overlong? */\n        return s;\n      } else {\n        s += 2;\n        i += 2;\n      }\n    } else if ((s[0] & 0xf0) == 0xe0) {\n      /* 1110XXXX 10Xxxxxx 10xxxxxx */\n      if ((i+2 >= len) ||\n          (s[1] & 0xc0) != 0x80 ||\n          (s[2] & 0xc0) != 0x80 ||\n          (s[0] == 0xe0 && (s[1] & 0xe0) == 0x80) ||                 /* overlong? */\n          (s[0] == 0xed && (s[1] & 0xe0) == 0xa0) ||                 /* surrogate? */\n          (s[0] == 0xef && s[1] == 0xbf && (s[2] & 0xfe) == 0xbe && /* U+FFFE or U+FFFF? */\n          s[2] != 0xbf && s[2] != 0xbe)) { /* Hideous hack to comply with autobahn testsuite, TODO: fix that one day (and other jokes I tell myself) */\n        return s;\n      } else {\n        s += 3;\n        i += 3;\n      }\n    } else if ((s[0] & 0xf8) == 0xf0) {\n      /* 11110XXX 10XXxxxx 10xxxxxx 10xxxxxx */\n      if ((i+3 >= len) ||\n          (s[1] & 0xc0) != 0x80 ||\n          (s[2] & 0xc0) != 0x80 ||\n          (s[3] & 0xc0) != 0x80 ||\n          (s[0] == 0xf0 && (s[1] & 0xf0) == 0x80) ||      /* overlong? */\n          (s[0] == 0xf4 && s[1] > 0x8f) || s[0] > 0xf4) { /* > U+10FFFF? */\n        return s;\n      } else {\n        s += 4;\n        i += 4;\n      }\n    } else {\n      return s;\n    }\n  }\n  return NULL;\n}\n\n/**\n * Converts a hex character to its integer value\n */\nstatic char from_hex(char ch) {\n  return isdigit(ch) ? ch - '0' : tolower(ch) - 'a' + 10;\n}\n\n/**\n * Converts an integer value to its hex character\n */\nstatic char to_hex(char code) {\n  static char hex[] = \"0123456789ABCDEF\";\n  return hex[code & 15];\n}\n\n/**\n * Returns a url-encoded version of str\n * returned value must be cleaned after use\n * Thanks Geek Hideout!\n * http://www.geekhideout.com/urlcode.shtml\n */\nchar * ulfius_url_encode(const char * str) {\n  char * pstr = (char*)str, * buf = NULL, * pbuf = NULL;\n  if (str != NULL) {\n    buf = malloc(strlen(str) * 3 + 1);\n    if (buf != NULL) {\n      pbuf = buf;\n      while (* pstr) {\n        // \"$-_.+!*'(),\"\n        if (isalnum(* pstr) || * pstr == '$' || * pstr == '-' || * pstr == '_' ||\n            * pstr == '.' || * pstr == '!' || * pstr == '*' ||\n            * pstr == '\\'' || * pstr == '(' || * pstr == ')' || * pstr == ',')\n          * pbuf++ = * pstr;\n        else if (* pstr == ' ')\n          * pbuf++ = '+';\n        else\n          * pbuf++ = '%', * pbuf++ = to_hex(* pstr >> 4), * pbuf++ = to_hex(* pstr & 15);\n        pstr++;\n      }\n      * pbuf = '\\0';\n    } else {\n      y_log_message(Y_LOG_LEVEL_ERROR, \"Ulfius - Error allocating resources for buf (ulfius_url_encode)\");\n    }\n    return buf;\n  } else {\n    return NULL;\n  }\n}\n\n/**\n * Returns a url-decoded version of str\n * returned value must be cleaned after use\n * Thanks Geek Hideout!\n * http://www.geekhideout.com/urlcode.shtml\n */\nchar * ulfius_url_decode(const char * str) {\n  char * pstr = (char*)str, * buf = NULL, * pbuf = NULL;\n  if (str != NULL) {\n    buf = malloc(strlen(str) + 1);\n    if (buf != NULL) {\n      pbuf = buf;\n      while (* pstr) {\n        if (* pstr == '%') {\n          if (pstr[1] && pstr[2]) {\n            * pbuf++ = from_hex(pstr[1]) << 4 | from_hex(pstr[2]);\n            pstr += 2;\n          }\n        } else if (* pstr == '+') {\n          * pbuf++ = ' ';\n        } else {\n          * pbuf++ = * pstr;\n        }\n        pstr++;\n      }\n      * pbuf = '\\0';\n    } else {\n      y_log_message(Y_LOG_LEVEL_ERROR, \"Ulfius - Error allocating resources for buf (ulfius_url_decode)\");\n    }\n    return buf;\n  } else {\n    return NULL;\n  }\n}\n\nint ulfius_global_init(void) {\n  int ret = U_OK;\n  o_malloc_t malloc_fn;\n  o_realloc_t realloc_fn;\n  o_free_t free_fn;\n\n  o_get_alloc_funcs(&malloc_fn, &realloc_fn, &free_fn);\n#ifndef U_DISABLE_CURL\n  if (curl_global_init(CURL_GLOBAL_ALL) != CURLE_OK) {\n    y_log_message(Y_LOG_LEVEL_ERROR, \"Ulfius - Error curl_global_init\");\n    ret = U_ERROR;\n  } else {\n    if (curl_global_init_mem(CURL_GLOBAL_DEFAULT, malloc_fn, free_fn, realloc_fn, *o_strdup, *calloc) != CURLE_OK) {\n      y_log_message(Y_LOG_LEVEL_ERROR, \"Ulfius - Error curl_global_init_mem\");\n      ret = U_ERROR_MEMORY;\n    }\n  }\n#endif\n#ifndef U_DISABLE_JANSSON\n  json_set_alloc_funcs((json_malloc_t)malloc_fn, (json_free_t)free_fn);\n#endif\n  return ret;\n}\n\nvoid ulfius_global_close(void) {\n#ifndef U_DISABLE_CURL\n  curl_global_cleanup();\n#endif\n}\n"], "filenames": ["src/ulfius.c"], "buggy_code_start_loc": [209], "buggy_code_end_loc": [437], "fixing_code_start_loc": [210], "fixing_code_end_loc": [437], "type": "NVD-CWE-noinfo", "message": "ulfius_uri_logger in Ulfius HTTP Framework before 2.7.4 omits con_info initialization and a con_info->request NULL check for certain malformed HTTP requests.", "other": {"cve": {"id": "CVE-2021-40540", "sourceIdentifier": "cve@mitre.org", "published": "2021-09-07T02:15:07.130", "lastModified": "2021-09-16T16:00:47.267", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "ulfius_uri_logger in Ulfius HTTP Framework before 2.7.4 omits con_info initialization and a con_info->request NULL check for certain malformed HTTP requests."}, {"lang": "es", "value": "la funci\u00f3n ulfius_uri_logger en Ulfius HTTP Framework antes de la versi\u00f3n 2.7.4 omite la inicializaci\u00f3n de con_info y la comprobaci\u00f3n de con_info-)request NULL para determinadas peticiones HTTP malformadas"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:ulfius_project:ulfius:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.7.4", "matchCriteriaId": "5C8CFDCE-F4D2-487C-9672-597FC6DD79E5"}]}]}], "references": [{"url": "http://packetstormsecurity.com/files/164152/Ulfius-Web-Framework-Remote-Memory-Corruption.html", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/babelouest/ulfius/commit/c83f564c184a27145e07c274b305cabe943bbfaa", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/babelouest/ulfius/compare/v2.7.3...v2.7.4", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/babelouest/ulfius/commit/c83f564c184a27145e07c274b305cabe943bbfaa"}}