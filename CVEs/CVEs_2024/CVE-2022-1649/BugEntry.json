{"buggy_code": ["/* radare - LGPL - Copyright 2010-2021 - nibble, mrmacete, pancake */\n\n#include <stdio.h>\n#include <r_types.h>\n#include <r_util.h>\n#include \"mach0.h\"\n#include <r_hash.h>\n\n// TODO: deprecate bprintf and use Eprintf (bin->self)\n#define bprintf if (bin->verbose) eprintf\n#define Eprintf if (mo->verbose) eprintf\n\n#define IS_PTR_AUTH(x) ((x & (1ULL << 63)) != 0)\n#define IS_PTR_BIND(x) ((x & (1ULL << 62)) != 0)\n\ntypedef struct {\n\tstruct symbol_t *symbols;\n\tint j;\n\tint symbols_count;\n\tHtPP *hash;\n} RSymCtx;\n\ntypedef void (*RExportsIterator)(struct MACH0_(obj_t) *bin, const char *name, ut64 flags, ut64 offset, void *ctx);\n\ntypedef struct {\n\tut8 *node;\n\tchar *label;\n\tint i;\n\tut8 *next_child;\n} RTrieState;\n\ntypedef struct {\n\tut8 * imports;\n\tRSkipList *relocs;\n} RWalkBindChainsContext;\n\n// OMG; THIS SHOULD BE KILLED; this var exposes the local native endian, which is completely unnecessary\n// USE THIS: int ws = bf->o->info->big_endian;\n#define mach0_endian 1\n\nstatic ut64 read_uleb128(ut8 **p, ut8 *end) {\n\tconst char *error = NULL;\n\tut64 v;\n\t*p = (ut8 *)r_uleb128 (*p, end - *p, &v, &error);\n\tif (error) {\n\t\teprintf (\"%s\\n\", error);\n\t\tR_FREE (error);\n\t\treturn UT64_MAX;\n\t}\n\treturn v;\n}\n\nstatic ut64 entry_to_vaddr(struct MACH0_(obj_t) *bin) {\n\tswitch (bin->main_cmd.cmd) {\n\tcase LC_MAIN:\n\t\treturn bin->entry + bin->baddr;\n\tcase LC_UNIXTHREAD:\n\tcase LC_THREAD:\n\t\treturn bin->entry;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic ut64 addr_to_offset(struct MACH0_(obj_t) *bin, ut64 addr) {\n\tif (bin->segs) {\n\t\tsize_t i;\n\t\tfor (i = 0; i < bin->nsegs; i++) {\n\t\t\tconst ut64 segment_base = (ut64)bin->segs[i].vmaddr;\n\t\t\tconst ut64 segment_size = (ut64)bin->segs[i].vmsize;\n\t\t\tif (addr >= segment_base && addr < segment_base + segment_size) {\n\t\t\t\treturn bin->segs[i].fileoff + (addr - segment_base);\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic ut64 offset_to_vaddr(struct MACH0_(obj_t) *bin, ut64 offset) {\n\tif (bin->segs) {\n\t\tsize_t i;\n\t\tfor (i = 0; i < bin->nsegs; i++) {\n\t\t\tut64 segment_base = (ut64)bin->segs[i].fileoff;\n\t\t\tut64 segment_size = (ut64)bin->segs[i].filesize;\n\t\t\tif (offset >= segment_base && offset < segment_base + segment_size) {\n\t\t\t\treturn bin->segs[i].vmaddr + (offset - segment_base);\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic ut64 pa2va(RBinFile *bf, ut64 offset) {\n\tr_return_val_if_fail (bf && bf->rbin, offset);\n\tRIO *io = bf->rbin->iob.io;\n\tif (!io || !io->va) {\n\t\treturn offset;\n\t}\n\tstruct MACH0_(obj_t) *bin = bf->o->bin_obj;\n\treturn bin? offset_to_vaddr (bin, offset): offset;\n}\n\nstatic void init_sdb_formats(struct MACH0_(obj_t) *bin) {\n\t/*\n\t * These definitions are used by r2 -nn\n\t * must be kept in sync with libr/bin/d/macho\n\t */\n\tsdb_set (bin->kv, \"mach0_build_platform.cparse\",\n\t\t\"enum mach0_build_platform\" \"{MACOS=1, IOS=2, TVOS=3, WATCHOS=4, BRIDGEOS=5, IOSMAC=6, IOSSIMULATOR=7, TVOSSIMULATOR=8, WATCHOSSIMULATOR=9};\",\n\t\t0);\n\tsdb_set (bin->kv, \"mach0_build_tool.cparse\",\n\t\t\"enum mach0_build_tool\" \"{CLANG=1, SWIFT=2, LD=3};\",\n\t\t0);\n\tsdb_set (bin->kv, \"mach0_load_command_type.cparse\",\n\t\t\"enum mach0_load_command_type\" \"{ LC_SEGMENT=0x00000001ULL, LC_SYMTAB=0x00000002ULL, LC_SYMSEG=0x00000003ULL, LC_THREAD=0x00000004ULL, LC_UNIXTHREAD=0x00000005ULL, LC_LOADFVMLIB=0x00000006ULL, LC_IDFVMLIB=0x00000007ULL, LC_IDENT=0x00000008ULL, LC_FVMFILE=0x00000009ULL, LC_PREPAGE=0x0000000aULL, LC_DYSYMTAB=0x0000000bULL, LC_LOAD_DYLIB=0x0000000cULL, LC_ID_DYLIB=0x0000000dULL, LC_LOAD_DYLINKER=0x0000000eULL, LC_ID_DYLINKER=0x0000000fULL, LC_PREBOUND_DYLIB=0x00000010ULL, LC_ROUTINES=0x00000011ULL, LC_SUB_FRAMEWORK=0x00000012ULL, LC_SUB_UMBRELLA=0x00000013ULL, LC_SUB_CLIENT=0x00000014ULL, LC_SUB_LIBRARY=0x00000015ULL, LC_TWOLEVEL_HINTS=0x00000016ULL, LC_PREBIND_CKSUM=0x00000017ULL, LC_LOAD_WEAK_DYLIB=0x80000018ULL, LC_SEGMENT_64=0x00000019ULL, LC_ROUTINES_64=0x0000001aULL, LC_UUID=0x0000001bULL, LC_RPATH=0x8000001cULL, LC_CODE_SIGNATURE=0x0000001dULL, LC_SEGMENT_SPLIT_INFO=0x0000001eULL, LC_REEXPORT_DYLIB=0x8000001fULL, LC_LAZY_LOAD_DYLIB=0x00000020ULL, LC_ENCRYPTION_INFO=0x00000021ULL, LC_DYLD_INFO=0x00000022ULL, LC_DYLD_INFO_ONLY=0x80000022ULL, LC_LOAD_UPWARD_DYLIB=0x80000023ULL, LC_VERSION_MIN_MACOSX=0x00000024ULL, LC_VERSION_MIN_IPHONEOS=0x00000025ULL, LC_FUNCTION_STARTS=0x00000026ULL, LC_DYLD_ENVIRONMENT=0x00000027ULL, LC_MAIN=0x80000028ULL, LC_DATA_IN_CODE=0x00000029ULL, LC_SOURCE_VERSION=0x0000002aULL, LC_DYLIB_CODE_SIGN_DRS=0x0000002bULL, LC_ENCRYPTION_INFO_64=0x0000002cULL, LC_LINKER_OPTION=0x0000002dULL, LC_LINKER_OPTIMIZATION_HINT=0x0000002eULL, LC_VERSION_MIN_TVOS=0x0000002fULL, LC_VERSION_MIN_WATCHOS=0x00000030ULL, LC_NOTE=0x00000031ULL, LC_BUILD_VERSION=0x00000032ULL };\",\n\t\t0);\n\tsdb_set (bin->kv, \"mach0_header_filetype.cparse\",\n\t\t\"enum mach0_header_filetype\" \"{MH_OBJECT=1, MH_EXECUTE=2, MH_FVMLIB=3, MH_CORE=4, MH_PRELOAD=5, MH_DYLIB=6, MH_DYLINKER=7, MH_BUNDLE=8, MH_DYLIB_STUB=9, MH_DSYM=10, MH_KEXT_BUNDLE=11};\",\n\t\t0);\n\tsdb_set (bin->kv, \"mach0_header_flags.cparse\",\n\t\t\"enum mach0_header_flags\" \"{MH_NOUNDEFS=1, MH_INCRLINK=2,MH_DYLDLINK=4,MH_BINDATLOAD=8,MH_PREBOUND=0x10, MH_SPLIT_SEGS=0x20,MH_LAZY_INIT=0x40,MH_TWOLEVEL=0x80, MH_FORCE_FLAT=0x100,MH_NOMULTIDEFS=0x200,MH_NOFIXPREBINDING=0x400, MH_PREBINDABLE=0x800, MH_ALLMODSBOUND=0x1000, MH_SUBSECTIONS_VIA_SYMBOLS=0x2000, MH_CANONICAL=0x4000,MH_WEAK_DEFINES=0x8000, MH_BINDS_TO_WEAK=0x10000,MH_ALLOW_STACK_EXECUTION=0x20000, MH_ROOT_SAFE=0x40000,MH_SETUID_SAFE=0x80000, MH_NO_REEXPORTED_DYLIBS=0x100000,MH_PIE=0x200000, MH_DEAD_STRIPPABLE_DYLIB=0x400000, MH_HAS_TLV_DESCRIPTORS=0x800000, MH_NO_HEAP_EXECUTION=0x1000000};\",\n\t\t0);\n\tsdb_set (bin->kv, \"mach0_section_types.cparse\",\n\t\t\"enum mach0_section_types\" \"{S_REGULAR=0, S_ZEROFILL=1, S_CSTRING_LITERALS=2, S_4BYTE_LITERALS=3, S_8BYTE_LITERALS=4, S_LITERAL_POINTERS=5, S_NON_LAZY_SYMBOL_POINTERS=6, S_LAZY_SYMBOL_POINTERS=7, S_SYMBOL_STUBS=8, S_MOD_INIT_FUNC_POINTERS=9, S_MOD_TERM_FUNC_POINTERS=0xa, S_COALESCED=0xb, S_GB_ZEROFILL=0xc, S_INTERPOSING=0xd, S_16BYTE_LITERALS=0xe, S_DTRACE_DOF=0xf, S_LAZY_DYLIB_SYMBOL_POINTERS=0x10, S_THREAD_LOCAL_REGULAR=0x11, S_THREAD_LOCAL_ZEROFILL=0x12, S_THREAD_LOCAL_VARIABLES=0x13, S_THREAD_LOCAL_VARIABLE_POINTERS=0x14, S_THREAD_LOCAL_INIT_FUNCTION_POINTERS=0x15, S_INIT_FUNC_OFFSETS=0x16};\",\n\t\t0);\n\tsdb_set (bin->kv, \"mach0_section_attrs.cparse\",\n\t\t\"enum mach0_section_attrs\" \"{S_ATTR_PURE_INSTRUCTIONS=0x800000ULL, S_ATTR_NO_TOC=0x400000ULL, S_ATTR_STRIP_STATIC_SYMS=0x200000ULL, S_ATTR_NO_DEAD_STRIP=0x100000ULL, S_ATTR_LIVE_SUPPORT=0x080000ULL, S_ATTR_SELF_MODIFYING_CODE=0x040000ULL, S_ATTR_DEBUG=0x020000ULL, S_ATTR_SOME_INSTRUCTIONS=0x000004ULL, S_ATTR_EXT_RELOC=0x000002ULL, S_ATTR_LOC_RELOC=0x000001ULL};\",\n\t\t0);\n\tsdb_set (bin->kv, \"mach0_header.format\",\n\t\t\"xxx[4]Edd[4]B \"\n\t\t\"magic cputype cpusubtype (mach0_header_filetype)filetype ncmds sizeofcmds (mach0_header_flags)flags\",\n\t\t0);\n\tsdb_set (bin->kv, \"mach0_segment.format\",\n\t\t\"[4]Ed[16]zxxxxoodx \"\n\t\t\"(mach0_load_command_type)cmd cmdsize segname vmaddr vmsize fileoff filesize maxprot initprot nsects flags\",\n\t\t0);\n\tsdb_set (bin->kv, \"mach0_segment64.format\",\n\t\t\"[4]Ed[16]zqqqqoodx \"\n\t\t\"(mach0_load_command_type)cmd cmdsize segname vmaddr vmsize fileoff filesize maxprot initprot nsects flags\",\n\t\t0);\n\tsdb_set (bin->kv, \"mach0_symtab_command.format\",\n\t\t\"[4]Edxdxd \"\n\t\t\"(mach0_load_command_type)cmd cmdsize symoff nsyms stroff strsize\",\n\t\t0);\n\tsdb_set (bin->kv, \"mach0_dysymtab_command.format\",\n\t\t\"[4]Edddddddddddxdxdxxxd \"\n\t\t\"(mach0_load_command_type)cmd cmdsize ilocalsym nlocalsym iextdefsym nextdefsym iundefsym nundefsym tocoff ntoc moddtaboff nmodtab extrefsymoff nextrefsyms inddirectsymoff nindirectsyms extreloff nextrel locreloff nlocrel\",\n\t\t0);\n\tsdb_set (bin->kv, \"mach0_section.format\",\n\t\t\"[16]z[16]zxxxxxx[1]E[3]Bxx \"\n\t\t\"sectname segname addr size offset align reloff nreloc (mach0_section_types)flags_type (mach0_section_attrs)flags_attr reserved1 reserved2\", 0);\n\tsdb_set (bin->kv, \"mach0_section64.format\",\n\t\t\"[16]z[16]zqqxxxx[1]E[3]Bxxx \"\n\t\t\"sectname segname addr size offset align reloff nreloc (mach0_section_types)flags_type (mach0_section_attrs)flags_attr reserved1 reserved2 reserved3\",\n\t\t0);\n\tsdb_set (bin->kv, \"mach0_dylib.format\",\n\t\t\"xxxxz \"\n\t\t\"name_offset timestamp current_version compatibility_version name\",\n\t\t0);\n\tsdb_set (bin->kv, \"mach0_dylib_command.format\",\n\t\t\"[4]Ed? \"\n\t\t\"(mach0_load_command_type)cmd cmdsize (mach0_dylib)dylib\",\n\t\t0);\n\tsdb_set (bin->kv, \"mach0_id_dylib_command.format\",\n\t\t\"[4]Ed? \"\n\t\t\"(mach0_load_command_type)cmd cmdsize (mach0_dylib)dylib\",\n\t\t0);\n\tsdb_set (bin->kv, \"mach0_uuid_command.format\",\n\t\t\"[4]Ed[16]b \"\n\t\t\"(mach0_load_command_type)cmd cmdsize uuid\",\n\t\t0);\n\tsdb_set (bin->kv, \"mach0_rpath_command.format\",\n\t\t\"[4]Edxz \"\n\t\t\"(mach0_load_command_type)cmd cmdsize path_offset path\",\n\t\t0);\n\tsdb_set (bin->kv, \"mach0_entry_point_command.format\",\n\t\t\"[4]Edqq \"\n\t\t\"(mach0_load_command_type)cmd cmdsize entryoff stacksize\",\n\t\t0);\n\tsdb_set (bin->kv, \"mach0_encryption_info64_command.format\",\n\t\t\"[4]Edxddx \"\n\t\t\"(mach0_load_command_type)cmd cmdsize offset size id padding\",\n\t\t0);\n\tsdb_set (bin->kv, \"mach0_encryption_info_command.format\",\n\t\t\"[4]Edxdd \"\n\t\t\"(mach0_load_command_type)cmd cmdsize offset size id\",\n\t\t0);\n\tsdb_set (bin->kv, \"mach0_code_signature_command.format\",\n\t\t\"[4]Edxd \"\n\t\t\"(mach0_load_command_type)cmd cmdsize offset size\",\n\t\t0);\n\tsdb_set (bin->kv, \"mach0_dyld_info_only_command.format\",\n\t\t\"[4]Edxdxdxdxdxd \"\n\t\t\"(mach0_load_command_type)cmd cmdsize rebase_off rebase_size bind_off bind_size weak_bind_off weak_bind_size lazy_bind_off lazy_bind_size export_off export_size\",\n\t\t0);\n\tsdb_set (bin->kv, \"mach0_load_dylinker_command.format\",\n\t\t\"[4]Edxz \"\n\t\t\"(mach0_load_command_type)cmd cmdsize name_offset name\",\n\t\t0);\n\tsdb_set (bin->kv, \"mach0_id_dylinker_command.format\",\n\t\t\"[4]Edxzi \"\n\t\t\"(mach0_load_command_type)cmd cmdsize name_offset name\",\n\t\t0);\n\tsdb_set (bin->kv, \"mach0_build_version_command.format\",\n\t\t\"[4]Ed[4]Exxd \"\n\t\t\"(mach0_load_command_type)cmd cmdsize (mach0_build_platform)platform minos sdk ntools\",\n\t\t0);\n\tsdb_set (bin->kv, \"mach0_build_version_tool.format\",\n\t\t\"[4]Ex \"\n\t\t\"(mach0_build_tool)tool version\",\n\t\t0);\n\tsdb_set (bin->kv, \"mach0_source_version_command.format\",\n\t\t\"[4]Edq \"\n\t\t\"(mach0_load_command_type)cmd cmdsize version\",\n\t\t0);\n\tsdb_set (bin->kv, \"mach0_function_starts_command.format\",\n\t\t\"[4]Edxd \"\n\t\t\"(mach0_load_command_type)cmd cmdsize offset size\",\n\t\t0);\n\tsdb_set (bin->kv, \"mach0_data_in_code_command.format\",\n\t\t\"[4]Edxd \"\n\t\t\"(mach0_load_command_type)cmd cmdsize offset size\",\n\t\t0);\n\tsdb_set (bin->kv, \"mach0_version_min_command.format\",\n\t\t\"[4]Edxx \"\n\t\t\"(mach0_load_command_type)cmd cmdsize version reserved\",\n\t\t0);\n\tsdb_set (bin->kv, \"mach0_segment_split_info_command.format\",\n\t\t\"[4]Edxd \"\n\t\t\"(mach0_load_command_type)cmd cmdsize offset size\",\n\t\t0);\n\tsdb_set (bin->kv, \"mach0_unixthread_command.format\",\n\t\t\"[4]Eddd \"\n\t\t\"(mach0_load_command_type)cmd cmdsize flavor count\",\n\t\t0);\n}\n\nstatic bool init_hdr(struct MACH0_(obj_t) *bin) {\n\tut8 magicbytes[4] = {0};\n\tut8 machohdrbytes[sizeof (struct MACH0_(mach_header))] = {0};\n\tint len;\n\n\tif (r_buf_read_at (bin->b, 0 + bin->header_at, magicbytes, 4) < 1) {\n\t\treturn false;\n\t}\n\tif (r_read_le32 (magicbytes) == 0xfeedface) {\n\t\tbin->big_endian = false;\n\t} else if (r_read_be32 (magicbytes) == 0xfeedface) {\n\t\tbin->big_endian = true;\n\t} else if (r_read_le32 (magicbytes) == FAT_MAGIC) {\n\t\tbin->big_endian = false;\n\t} else if (r_read_be32 (magicbytes) == FAT_MAGIC) {\n\t\tbin->big_endian = true;\n\t} else if (r_read_le32 (magicbytes) == 0xfeedfacf) {\n\t\tbin->big_endian = false;\n\t} else if (r_read_be32 (magicbytes) == 0xfeedfacf) {\n\t\tbin->big_endian = true;\n\t} else {\n\t\treturn false; // object files are magic == 0, but body is different :?\n\t}\n\tlen = r_buf_read_at (bin->b, 0 + bin->header_at, machohdrbytes, sizeof (machohdrbytes));\n\tif (len != sizeof (machohdrbytes)) {\n\t\tbprintf (\"Error: read (hdr)\\n\");\n\t\treturn false;\n\t}\n\tbin->hdr.magic = r_read_ble (&machohdrbytes[0], bin->big_endian, 32);\n\tbin->hdr.cputype = r_read_ble (&machohdrbytes[4], bin->big_endian, 32);\n\tbin->hdr.cpusubtype = r_read_ble (&machohdrbytes[8], bin->big_endian, 32);\n\tbin->hdr.filetype = r_read_ble (&machohdrbytes[12], bin->big_endian, 32);\n\tbin->hdr.ncmds = r_read_ble (&machohdrbytes[16], bin->big_endian, 32);\n\tbin->hdr.sizeofcmds = r_read_ble (&machohdrbytes[20], bin->big_endian, 32);\n\tbin->hdr.flags = r_read_ble (&machohdrbytes[24], bin->big_endian, 32);\n#if R_BIN_MACH064\n\tbin->hdr.reserved = r_read_ble (&machohdrbytes[28], bin->big_endian, 32);\n#endif\n\tinit_sdb_formats (bin);\n\tsdb_num_set (bin->kv, \"mach0_header.offset\", 0, 0); // wat about fatmach0?\n\treturn true;\n}\n\nstatic bool parse_segments(struct MACH0_(obj_t) *bin, ut64 off) {\n\tsize_t i, j, k, sect, len;\n\tut32 size_sects;\n\tut8 segcom[sizeof (struct MACH0_(segment_command))] = {0};\n\tut8 sec[sizeof (struct MACH0_(section))] = {0};\n\tchar section_flagname[128];\n\n\tif (!UT32_MUL (&size_sects, bin->nsegs, sizeof (struct MACH0_(segment_command)))) {\n\t\treturn false;\n\t}\n\tif (!size_sects || size_sects > bin->size) {\n\t\treturn false;\n\t}\n\tif (off > bin->size || off + sizeof (struct MACH0_(segment_command)) > bin->size) {\n\t\treturn false;\n\t}\n\tif (!(bin->segs = realloc (bin->segs, bin->nsegs * sizeof(struct MACH0_(segment_command))))) {\n\t\tr_sys_perror (\"realloc (seg)\");\n\t\treturn false;\n\t}\n\tj = bin->nsegs - 1;\n\tlen = r_buf_read_at (bin->b, off, segcom, sizeof (struct MACH0_(segment_command)));\n\tif (len != sizeof (struct MACH0_(segment_command))) {\n\t\tbprintf (\"Error: read (seg)\\n\");\n\t\treturn false;\n\t}\n\ti = 0;\n\tbin->segs[j].cmd = r_read_ble32 (&segcom[i], bin->big_endian);\n\ti += sizeof (ut32);\n\tbin->segs[j].cmdsize = r_read_ble32 (&segcom[i], bin->big_endian);\n\ti += sizeof (ut32);\n\tmemcpy (&bin->segs[j].segname, &segcom[i], 16);\n\ti += 16;\n#if R_BIN_MACH064\n\tbin->segs[j].vmaddr = r_read_ble64 (&segcom[i], bin->big_endian);\n\ti += sizeof (ut64);\n\tbin->segs[j].vmsize = r_read_ble64 (&segcom[i], bin->big_endian);\n\ti += sizeof (ut64);\n\tbin->segs[j].fileoff = r_read_ble64 (&segcom[i], bin->big_endian);\n\ti += sizeof (ut64);\n\tbin->segs[j].filesize = r_read_ble64 (&segcom[i], bin->big_endian);\n\ti += sizeof (ut64);\n#else\n\tbin->segs[j].vmaddr = r_read_ble32 (&segcom[i], bin->big_endian);\n\ti += sizeof (ut32);\n\tbin->segs[j].vmsize = r_read_ble32 (&segcom[i], bin->big_endian);\n\ti += sizeof (ut32);\n\tbin->segs[j].fileoff = r_read_ble32 (&segcom[i], bin->big_endian);\n\ti += sizeof (ut32);\n\tbin->segs[j].filesize = r_read_ble32 (&segcom[i], bin->big_endian);\n\ti += sizeof (ut32);\n#endif\n\tbin->segs[j].maxprot = r_read_ble32 (&segcom[i], bin->big_endian);\n\ti += sizeof (ut32);\n\tbin->segs[j].initprot = r_read_ble32 (&segcom[i], bin->big_endian);\n\ti += sizeof (ut32);\n\tbin->segs[j].nsects = r_read_ble32 (&segcom[i], bin->big_endian);\n\ti += sizeof (ut32);\n\tbin->segs[j].flags = r_read_ble32 (&segcom[i], bin->big_endian);\n\n\tchar *segment_flagname = NULL;\n#if R_BIN_MACH064\n\tsegment_flagname = r_str_newf (\"mach0_segment64_%u.offset\", (ut32)j);\n#else\n\tsegment_flagname = r_str_newf (\"mach0_segment_%u.offset\", (ut32)j);\n#endif\n\tsdb_num_set (bin->kv, segment_flagname, off, 0);\n\tfree (segment_flagname);\n\tsdb_num_set (bin->kv, \"mach0_segments.count\", 0, 0);\n\n\tif (bin->segs[j].nsects > 0) {\n\t\tsect = bin->nsects;\n\t\tbin->nsects += bin->segs[j].nsects;\n\t\tif (bin->nsects > 128) {\n\t\t\tint new_nsects = bin->nsects & 0xf;\n\t\t\tbprintf (\"WARNING: mach0 header contains too many sections (%d). Wrapping to %d\\n\",\n\t\t\t\t bin->nsects, new_nsects);\n\t\t\tbin->nsects = new_nsects;\n\t\t}\n\t\tif ((int)bin->nsects < 1) {\n\t\t\tbprintf (\"Warning: Invalid number of sections\\n\");\n\t\t\tbin->nsects = sect;\n\t\t\treturn false;\n\t\t}\n\t\tif (!UT32_MUL (&size_sects, bin->nsects-sect, sizeof (struct MACH0_(section)))){\n\t\t\tbin->nsects = sect;\n\t\t\treturn false;\n\t\t}\n\t\tif (!size_sects || size_sects > bin->size){\n\t\t\tbin->nsects = sect;\n\t\t\treturn false;\n\t\t}\n\n\t\tif (bin->segs[j].cmdsize != sizeof (struct MACH0_(segment_command)) \\\n\t\t\t\t  + (sizeof (struct MACH0_(section))*bin->segs[j].nsects)){\n\t\t\tbin->nsects = sect;\n\t\t\treturn false;\n\t\t}\n\n\t\tif (off + sizeof (struct MACH0_(segment_command)) > bin->size ||\\\n\t\t\t\toff + sizeof (struct MACH0_(segment_command)) + size_sects > bin->size){\n\t\t\tbin->nsects = sect;\n\t\t\treturn false;\n\t\t}\n\n\t\tif (!(bin->sects = realloc (bin->sects, bin->nsects * sizeof (struct MACH0_(section))))) {\n\t\t\tr_sys_perror (\"realloc (sects)\");\n\t\t\tbin->nsects = sect;\n\t\t\treturn false;\n\t\t}\n\n\t\tfor (k = sect, j = 0; k < bin->nsects; k++, j++) {\n\t\t\tut64 offset = off + sizeof (struct MACH0_(segment_command)) + j * sizeof (struct MACH0_(section));\n\t\t\tlen = r_buf_read_at (bin->b, offset, sec, sizeof (struct MACH0_(section)));\n\t\t\tif (len != sizeof (struct MACH0_(section))) {\n\t\t\t\tbprintf (\"Error: read (sects)\\n\");\n\t\t\t\tbin->nsects = sect;\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\ti = 0;\n\t\t\tmemcpy (&bin->sects[k].sectname, &sec[i], 16);\n\t\t\ti += 16;\n\t\t\tmemcpy (&bin->sects[k].segname, &sec[i], 16);\n\t\t\ti += 16;\n\t\t\tsnprintf (section_flagname, sizeof (section_flagname), \"mach0_section_%.16s_%.16s.offset\",\n\t\t\t\t\t\tbin->sects[k].segname, bin->sects[k].sectname);\n\t\t\tsdb_num_set (bin->kv, section_flagname, offset, 0);\n#if R_BIN_MACH064\n\t\t\tsnprintf (section_flagname, sizeof (section_flagname), \"mach0_section_%.16s_%.16s.format\",\n\t\t\t\t\t\tbin->sects[k].segname, bin->sects[k].sectname);\n\t\t\tsdb_set (bin->kv, section_flagname, \"mach0_section64\", 0);\n#else\n\t\t\tsnprintf (section_flagname, sizeof (section_flagname), \"mach0_section_%.16s_%.16s.format\",\n\t\t\t\t\t\tbin->sects[k].segname, bin->sects[k].sectname);\n\t\t\tsdb_set (bin->kv, section_flagname, \"mach0_section\", 0);\n#endif\n\n#if R_BIN_MACH064\n\t\t\tbin->sects[k].addr = r_read_ble64 (&sec[i], bin->big_endian);\n\t\t\ti += sizeof (ut64);\n\t\t\tbin->sects[k].size = r_read_ble64 (&sec[i], bin->big_endian);\n\t\t\ti += sizeof (ut64);\n#else\n\t\t\tbin->sects[k].addr = r_read_ble32 (&sec[i], bin->big_endian);\n\t\t\ti += sizeof (ut32);\n\t\t\tbin->sects[k].size = r_read_ble32 (&sec[i], bin->big_endian);\n\t\t\ti += sizeof (ut32);\n#endif\n\t\t\tbin->sects[k].offset = r_read_ble32 (&sec[i], bin->big_endian);\n\t\t\ti += sizeof (ut32);\n\t\t\tbin->sects[k].align = r_read_ble32 (&sec[i], bin->big_endian);\n\t\t\ti += sizeof (ut32);\n\t\t\tbin->sects[k].reloff = r_read_ble32 (&sec[i], bin->big_endian);\n\t\t\ti += sizeof (ut32);\n\t\t\tbin->sects[k].nreloc = r_read_ble32 (&sec[i], bin->big_endian);\n\t\t\ti += sizeof (ut32);\n\t\t\tbin->sects[k].flags = r_read_ble32 (&sec[i], bin->big_endian);\n\t\t\ti += sizeof (ut32);\n\t\t\tbin->sects[k].reserved1 = r_read_ble32 (&sec[i], bin->big_endian);\n\t\t\ti += sizeof (ut32);\n\t\t\tbin->sects[k].reserved2 = r_read_ble32 (&sec[i], bin->big_endian);\n#if R_BIN_MACH064\n\t\t\ti += sizeof (ut32);\n\t\t\tbin->sects[k].reserved3 = r_read_ble32 (&sec[i], bin->big_endian);\n#endif\n\t\t}\n\t}\n\treturn true;\n}\n\n#define Error(x) error_message = x; goto error;\nstatic bool parse_symtab(struct MACH0_(obj_t) *mo, ut64 off) {\n\tstruct symtab_command st;\n\tut32 size_sym;\n\tsize_t i;\n\tconst char *error_message = \"\";\n\tut8 symt[sizeof (struct symtab_command)] = {0};\n\tut8 nlst[sizeof (struct MACH0_(nlist))] = {0};\n\tconst bool be = mo->big_endian;\n\n\tif (off > (ut64)mo->size || off + sizeof (struct symtab_command) > (ut64)mo->size) {\n\t\treturn false;\n\t}\n\tint len = r_buf_read_at (mo->b, off, symt, sizeof (struct symtab_command));\n\tif (len != sizeof (struct symtab_command)) {\n\t\tEprintf (\"Error: read (symtab)\\n\");\n\t\treturn false;\n\t}\n\tst.cmd = r_read_ble32 (symt, be);\n\tst.cmdsize = r_read_ble32 (symt + 4, be);\n\tst.symoff = r_read_ble32 (symt + 8, be) + mo->symbols_off;\n\tst.nsyms = r_read_ble32 (symt + 12, be);\n\tst.stroff = r_read_ble32 (symt + 16, be) + mo->symbols_off;\n\tst.strsize = r_read_ble32 (symt + 20, be);\n\n\tmo->symtab = NULL;\n\tmo->nsymtab = 0;\n\tif (st.strsize > 0 && st.strsize < mo->size && st.nsyms > 0) {\n\t\tmo->nsymtab = st.nsyms;\n\t\tif (st.stroff > mo->size || st.stroff + st.strsize > mo->size) {\n\t\t\tError (\"fail\");\n\t\t}\n\t\tif (!UT32_MUL (&size_sym, mo->nsymtab, sizeof (struct MACH0_(nlist)))) {\n\t\t\tError (\"fail2\");\n\t\t}\n\t\tif (!size_sym) {\n\t\t\tError (\"symbol size is zero\");\n\t\t}\n\t\tif (st.symoff > mo->size || st.symoff + size_sym > mo->size) {\n\t\t\tError (\"symoff is out of bounds\");\n\t\t}\n\t\tif (!(mo->symstr = calloc (1, st.strsize + 2))) {\n\t\t\tError (\"symoff is out of bounds\");\n\t\t}\n\t\tmo->symstrlen = st.strsize;\n\t\tlen = r_buf_read_at (mo->b, st.stroff, (ut8*)mo->symstr, st.strsize);\n\t\tif (len != st.strsize) {\n\t\t\tError (\"Error: read (symstr)\");\n\t\t}\n\t\tut64 max_nsymtab = (r_buf_size (mo->b) - st.symoff) / sizeof (struct MACH0_(nlist));\n\t\tif (mo->nsymtab > max_nsymtab || !(mo->symtab = calloc (mo->nsymtab, sizeof (struct MACH0_(nlist))))) {\n\t\t\tgoto error;\n\t\t}\n\t\tfor (i = 0; i < mo->nsymtab; i++) {\n\t\t\tut64 at = st.symoff + (i * sizeof (struct MACH0_(nlist)));\n\t\t\tlen = r_buf_read_at (mo->b, at, nlst, sizeof (struct MACH0_(nlist)));\n\t\t\tif (len != sizeof (struct MACH0_(nlist))) {\n\t\t\t\tError (\"read (nlist)\");\n\t\t\t}\n\t\t\t//XXX not very safe what if is n_un.n_name instead?\n\t\t\tmo->symtab[i].n_strx = r_read_ble32 (nlst, be);\n\t\t\tmo->symtab[i].n_type = r_read_ble8 (nlst + 4);\n\t\t\tmo->symtab[i].n_sect = r_read_ble8 (nlst + 5);\n\t\t\tmo->symtab[i].n_desc = r_read_ble16 (nlst + 6, be);\n#if R_BIN_MACH064\n\t\t\tmo->symtab[i].n_value = r_read_ble64 (&nlst[8], be);\n#else\n\t\t\tmo->symtab[i].n_value = r_read_ble32 (&nlst[8], be);\n#endif\n\t\t}\n\t}\n\treturn true;\nerror:\n\tR_FREE (mo->symstr);\n\tR_FREE (mo->symtab);\n\tEprintf (\"%s\\n\", error_message);\n\treturn false;\n}\n\nstatic bool parse_dysymtab(struct MACH0_(obj_t) *bin, ut64 off) {\n\tsize_t len, i;\n\tut32 size_tab;\n\tut8 dysym[sizeof (struct dysymtab_command)] = {0};\n\tut8 dytoc[sizeof (struct dylib_table_of_contents)] = {0};\n\tut8 dymod[sizeof (struct MACH0_(dylib_module))] = {0};\n\tut8 idsyms[sizeof (ut32)] = {0};\n\n\tif (off > bin->size || off + sizeof (struct dysymtab_command) > bin->size) {\n\t\treturn false;\n\t}\n\n\tlen = r_buf_read_at (bin->b, off, dysym, sizeof (struct dysymtab_command));\n\tif (len != sizeof (struct dysymtab_command)) {\n\t\tbprintf (\"Error: read (dysymtab)\\n\");\n\t\treturn false;\n\t}\n\n\tbin->dysymtab.cmd = r_read_ble32 (&dysym[0], bin->big_endian);\n\tbin->dysymtab.cmdsize = r_read_ble32 (&dysym[4], bin->big_endian);\n\tbin->dysymtab.ilocalsym = r_read_ble32 (&dysym[8], bin->big_endian);\n\tbin->dysymtab.nlocalsym = r_read_ble32 (&dysym[12], bin->big_endian);\n\tbin->dysymtab.iextdefsym = r_read_ble32 (&dysym[16], bin->big_endian);\n\tbin->dysymtab.nextdefsym = r_read_ble32 (&dysym[20], bin->big_endian);\n\tbin->dysymtab.iundefsym = r_read_ble32 (&dysym[24], bin->big_endian);\n\tbin->dysymtab.nundefsym = r_read_ble32 (&dysym[28], bin->big_endian);\n\tbin->dysymtab.tocoff = r_read_ble32 (&dysym[32], bin->big_endian);\n\tbin->dysymtab.ntoc = r_read_ble32 (&dysym[36], bin->big_endian);\n\tbin->dysymtab.modtaboff = r_read_ble32 (&dysym[40], bin->big_endian);\n\tbin->dysymtab.nmodtab = r_read_ble32 (&dysym[44], bin->big_endian);\n\tbin->dysymtab.extrefsymoff = r_read_ble32 (&dysym[48], bin->big_endian);\n\tbin->dysymtab.nextrefsyms = r_read_ble32 (&dysym[52], bin->big_endian);\n\tbin->dysymtab.indirectsymoff = r_read_ble32 (&dysym[56], bin->big_endian);\n\tbin->dysymtab.nindirectsyms = r_read_ble32 (&dysym[60], bin->big_endian);\n\tbin->dysymtab.extreloff = r_read_ble32 (&dysym[64], bin->big_endian);\n\tbin->dysymtab.nextrel = r_read_ble32 (&dysym[68], bin->big_endian);\n\tbin->dysymtab.locreloff = r_read_ble32 (&dysym[72], bin->big_endian);\n\tbin->dysymtab.nlocrel = r_read_ble32 (&dysym[76], bin->big_endian);\n\n\tbin->ntoc = bin->dysymtab.ntoc;\n\tif (bin->ntoc > 0) {\n\t\tif (!(bin->toc = calloc (bin->ntoc, sizeof (struct dylib_table_of_contents)))) {\n\t\t\tr_sys_perror (\"calloc (toc)\");\n\t\t\treturn false;\n\t\t}\n\t\tif (!UT32_MUL (&size_tab, bin->ntoc, sizeof (struct dylib_table_of_contents))){\n\t\t\tR_FREE (bin->toc);\n\t\t\treturn false;\n\t\t}\n\t\tif (!size_tab){\n\t\t\tR_FREE (bin->toc);\n\t\t\treturn false;\n\t\t}\n\t\tif (bin->dysymtab.tocoff > bin->size || bin->dysymtab.tocoff + size_tab > bin->size){\n\t\t\tR_FREE (bin->toc);\n\t\t\treturn false;\n\t\t}\n\t\tfor (i = 0; i < bin->ntoc; i++) {\n\t\t\tlen = r_buf_read_at (bin->b, bin->dysymtab.tocoff +\n\t\t\t\ti * sizeof (struct dylib_table_of_contents),\n\t\t\t\tdytoc, sizeof (struct dylib_table_of_contents));\n\t\t\tif (len != sizeof (struct dylib_table_of_contents)) {\n\t\t\t\tbprintf (\"Error: read (toc)\\n\");\n\t\t\t\tR_FREE (bin->toc);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tbin->toc[i].symbol_index = r_read_ble32 (&dytoc[0], bin->big_endian);\n\t\t\tbin->toc[i].module_index = r_read_ble32 (&dytoc[4], bin->big_endian);\n\t\t}\n\t}\n\tbin->nmodtab = bin->dysymtab.nmodtab;\n\tut64 max_nmodtab = (bin->size - bin->dysymtab.modtaboff) / sizeof (struct MACH0_(dylib_module));\n\tif (bin->nmodtab > 0 && bin->nmodtab <= max_nmodtab) {\n\t\tif (!(bin->modtab = calloc (bin->nmodtab, sizeof (struct MACH0_(dylib_module))))) {\n\t\t\tr_sys_perror (\"calloc (modtab)\");\n\t\t\treturn false;\n\t\t}\n\t\tif (!UT32_MUL (&size_tab, bin->nmodtab, sizeof (struct MACH0_(dylib_module)))){\n\t\t\tR_FREE (bin->modtab);\n\t\t\treturn false;\n\t\t}\n\t\tif (!size_tab){\n\t\t\tR_FREE (bin->modtab);\n\t\t\treturn false;\n\t\t}\n\t\tif (bin->dysymtab.modtaboff > bin->size || \\\n\t\t  bin->dysymtab.modtaboff + size_tab > bin->size){\n\t\t\tR_FREE (bin->modtab);\n\t\t\treturn false;\n\t\t}\n\t\tfor (i = 0; i < bin->nmodtab; i++) {\n\t\t\tlen = r_buf_read_at (bin->b, bin->dysymtab.modtaboff +\n\t\t\t\ti * sizeof (struct MACH0_(dylib_module)),\n\t\t\t\tdymod, sizeof (struct MACH0_(dylib_module)));\n\t\t\tif (len == -1) {\n\t\t\t\tbprintf (\"Error: read (modtab)\\n\");\n\t\t\t\tR_FREE (bin->modtab);\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tbin->modtab[i].module_name = r_read_ble32 (&dymod[0], bin->big_endian);\n\t\t\tbin->modtab[i].iextdefsym = r_read_ble32 (&dymod[4], bin->big_endian);\n\t\t\tbin->modtab[i].nextdefsym = r_read_ble32 (&dymod[8], bin->big_endian);\n\t\t\tbin->modtab[i].irefsym = r_read_ble32 (&dymod[12], bin->big_endian);\n\t\t\tbin->modtab[i].nrefsym = r_read_ble32 (&dymod[16], bin->big_endian);\n\t\t\tbin->modtab[i].ilocalsym = r_read_ble32 (&dymod[20], bin->big_endian);\n\t\t\tbin->modtab[i].nlocalsym = r_read_ble32 (&dymod[24], bin->big_endian);\n\t\t\tbin->modtab[i].iextrel = r_read_ble32 (&dymod[28], bin->big_endian);\n\t\t\tbin->modtab[i].nextrel = r_read_ble32 (&dymod[32], bin->big_endian);\n\t\t\tbin->modtab[i].iinit_iterm = r_read_ble32 (&dymod[36], bin->big_endian);\n\t\t\tbin->modtab[i].ninit_nterm = r_read_ble32 (&dymod[40], bin->big_endian);\n#if R_BIN_MACH064\n\t\t\tbin->modtab[i].objc_module_info_size = r_read_ble32 (&dymod[44], bin->big_endian);\n\t\t\tbin->modtab[i].objc_module_info_addr = r_read_ble64 (&dymod[48], bin->big_endian);\n#else\n\t\t\tbin->modtab[i].objc_module_info_addr = r_read_ble32 (&dymod[44], bin->big_endian);\n\t\t\tbin->modtab[i].objc_module_info_size = r_read_ble32 (&dymod[48], bin->big_endian);\n#endif\n\t\t}\n\t}\n\tbin->nindirectsyms = bin->dysymtab.nindirectsyms;\n\tif (bin->nindirectsyms > 0) {\n\t\tif (!(bin->indirectsyms = calloc (bin->nindirectsyms, sizeof (ut32)))) {\n\t\t\tr_sys_perror (\"calloc (indirectsyms)\");\n\t\t\treturn false;\n\t\t}\n\t\tif (!UT32_MUL (&size_tab, bin->nindirectsyms, sizeof (ut32))){\n\t\t\tR_FREE (bin->indirectsyms);\n\t\t\treturn false;\n\t\t}\n\t\tif (!size_tab){\n\t\t\tR_FREE (bin->indirectsyms);\n\t\t\treturn false;\n\t\t}\n\t\tif (bin->dysymtab.indirectsymoff > bin->size || \\\n\t\t\t\tbin->dysymtab.indirectsymoff + size_tab > bin->size){\n\t\t\tR_FREE (bin->indirectsyms);\n\t\t\treturn false;\n\t\t}\n\t\tfor (i = 0; i < bin->nindirectsyms; i++) {\n\t\t\tlen = r_buf_read_at (bin->b, bin->dysymtab.indirectsymoff + i * sizeof (ut32), idsyms, 4);\n\t\t\tif (len == -1) {\n\t\t\t\tbprintf (\"Error: read (indirect syms)\\n\");\n\t\t\t\tR_FREE (bin->indirectsyms);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tbin->indirectsyms[i] = r_read_ble32 (&idsyms[0], bin->big_endian);\n\t\t}\n\t}\n\t/* TODO extrefsyms, extrel, locrel */\n\treturn true;\n}\n\nstatic char *readString(ut8 *p, int off, int len) {\n\tif (off < 0 || off >= len) {\n\t\treturn NULL;\n\t}\n\treturn r_str_ndup ((const char *)p + off, len - off);\n}\n\nstatic void parseCodeDirectory(RBuffer *b, int offset, int datasize) {\n\ttypedef struct __CodeDirectory {\n\t\tuint32_t magic;\t\t/* magic number (CSMAGIC_CODEDIRECTORY) */\n\t\tuint32_t length;\t/* total length of CodeDirectory blob */\n\t\tuint32_t version;\t/* compatibility version */\n\t\tuint32_t flags;\t\t/* setup and mode flags */\n\t\tuint32_t hashOffset;\t/* offset of hash slot element at index zero */\n\t\tuint32_t identOffset;\t/* offset of identifier string */\n\t\tuint32_t nSpecialSlots;\t/* number of special hash slots */\n\t\tuint32_t nCodeSlots;\t/* number of ordinary (code) hash slots */\n\t\tuint32_t codeLimit;\t/* limit to main image signature range */\n\t\tuint8_t hashSize;\t/* size of each hash in bytes */\n\t\tuint8_t hashType;\t/* type of hash (cdHashType* constants) */\n\t\tuint8_t platform;\t/* unused (must be zero) */\n\t\tuint8_t\tpageSize;\t/* log2(page size in bytes); 0 => infinite */\n\t\tuint32_t spare2;\t/* unused (must be zero) */\n\t\t/* followed by dynamic content as located by offset fields above */\n\t\tuint32_t scatterOffset;\n\t\tuint32_t teamIDOffset;\n\t\tuint32_t spare3;\n\t\tut64 codeLimit64;\n\t\tut64 execSegBase;\n\t\tut64 execSegLimit;\n\t\tut64 execSegFlags;\n\t} CS_CodeDirectory;\n\tut64 off = offset;\n\tint psize = datasize;\n\tut8 *p = calloc (1, psize);\n\tif (!p) {\n\t\treturn;\n\t}\n\teprintf (\"Offset: 0x%08\"PFMT64x\"\\n\", off);\n\tr_buf_read_at (b, off, p, datasize);\n\tCS_CodeDirectory cscd = {0};\n\t#define READFIELD(x) cscd.x = r_read_ble32 (p + r_offsetof (CS_CodeDirectory, x), 1)\n\t#define READFIELD8(x) cscd.x = p[r_offsetof (CS_CodeDirectory, x)]\n\tREADFIELD (length);\n\tREADFIELD (version);\n\tREADFIELD (flags);\n\tREADFIELD (hashOffset);\n\tREADFIELD (identOffset);\n\tREADFIELD (nSpecialSlots);\n\tREADFIELD (nCodeSlots);\n\tREADFIELD (hashSize);\n\tREADFIELD (teamIDOffset);\n\tREADFIELD8 (hashType);\n\tREADFIELD (pageSize);\n\tREADFIELD (codeLimit);\n\teprintf (\"Version: %x\\n\", cscd.version);\n\teprintf (\"Flags: %x\\n\", cscd.flags);\n\teprintf (\"Length: %d\\n\", cscd.length);\n\teprintf (\"PageSize: %d\\n\", cscd.pageSize);\n\teprintf (\"hashOffset: %d\\n\", cscd.hashOffset);\n\teprintf (\"codeLimit: %d\\n\", cscd.codeLimit);\n\teprintf (\"hashSize: %d\\n\", cscd.hashSize);\n\teprintf (\"hashType: %d\\n\", cscd.hashType);\n\tchar *identity = readString (p, cscd.identOffset, psize);\n\teprintf (\"Identity: %s\\n\", identity);\n\tchar *teamId = readString (p, cscd.teamIDOffset, psize);\n\teprintf (\"TeamID: %s\\n\", teamId);\n\teprintf (\"CodeSlots: %d\\n\", cscd.nCodeSlots);\n\tfree (identity);\n\tfree (teamId);\n\n\tint hashSize = 20; // SHA1 is default\n\tint algoType = R_HASH_SHA1;\n\tconst char *hashName = \"sha1\";\n\tswitch (cscd.hashType) {\n\tcase 0: // SHA1 == 20 bytes\n\tcase 1: // SHA1 == 20 bytes\n\t\thashSize = 20;\n\t\thashName = \"sha1\";\n\t\talgoType = R_HASH_SHA1;\n\t\tbreak;\n\tcase 2: // SHA256 == 32 bytes\n\t\thashSize = 32;\n\t\talgoType = R_HASH_SHA256;\n\t\thashName = \"sha256\";\n\t\tbreak;\n\t}\n\t// computed cdhash\n\tRHash *ctx = r_hash_new (true, algoType);\n\tint fofsz = cscd.length;\n\tif (fofsz > 0 && fofsz < (r_buf_size (b) - off)) {\n\t\tut8 *fofbuf = calloc (fofsz, 1);\n\t\tif (fofbuf) {\n\t\t\tint i;\n\t\t\tif (r_buf_read_at (b, off, fofbuf, fofsz) != fofsz) {\n\t\t\t\teprintf (\"Invalid cdhash offset/length values\\n\");\n\t\t\t}\n\t\t\tr_hash_do_begin (ctx, algoType);\n\t\t\tif (algoType == R_HASH_SHA1) {\n\t\t\t\tr_hash_do_sha1 (ctx, fofbuf, fofsz);\n\t\t\t} else {\n\t\t\t\tr_hash_do_sha256 (ctx, fofbuf, fofsz);\n\t\t\t}\n\t\t\tr_hash_do_end (ctx, algoType);\n\t\t\teprintf (\"ph %s @ 0x%\"PFMT64x\"!%d\\n\", hashName, off, fofsz);\n\t\t\teprintf (\"ComputedCDHash: \");\n\t\t\tfor (i = 0; i < hashSize;i++) {\n\t\t\t\teprintf (\"%02x\", ctx->digest[i]);\n\t\t\t}\n\t\t\teprintf (\"\\n\");\n\t\t\tfree (fofbuf);\n\t\t}\n\t}\n\t// show and check the rest of hashes\n\tut8 *hash = p + cscd.hashOffset;\n\tint j = 0;\n\tint k = 0;\n\teprintf (\"Hashed region: 0x%08\"PFMT64x\" - 0x%08\"PFMT64x\"\\n\", (ut64)0, (ut64)cscd.codeLimit);\n\tfor (j = 0; j < cscd.nCodeSlots; j++) {\n\t\tint fof = 4096 * j;\n\t\tint idx = j * hashSize;\n\t\teprintf (\"0x%08\"PFMT64x\"  \", off + cscd.hashOffset + idx);\n\t\tfor (k = 0; k < hashSize; k++) {\n\t\t\teprintf (\"%02x\", hash[idx + k]);\n\t\t}\n\t\tut8 fofbuf[4096];\n\t\tint fofsz = R_MIN (sizeof (fofbuf), cscd.codeLimit - fof);\n\t\tr_buf_read_at (b, fof, fofbuf, sizeof (fofbuf));\n\t\tr_hash_do_begin (ctx, algoType);\n\t\tif (algoType == R_HASH_SHA1) {\n\t\t\tr_hash_do_sha1 (ctx, fofbuf, fofsz);\n\t\t} else {\n\t\t\tr_hash_do_sha256 (ctx, fofbuf, fofsz);\n\t\t}\n\t\tr_hash_do_end (ctx, algoType);\n\t\tif (memcmp (hash + idx, ctx->digest, hashSize)) {\n\t\t\teprintf (\"  wx \");\n\t\t\tint i;\n\t\t\tfor (i = 0; i < hashSize;i++) {\n\t\t\t\teprintf (\"%02x\", ctx->digest[i]);\n\t\t\t}\n\t\t} else {\n\t\t\teprintf (\"  OK\");\n\t\t}\n\t\teprintf (\"\\n\");\n\t}\n\tr_hash_free (ctx);\n\tfree (p);\n}\n\n// parse the Load Command\nstatic bool parse_signature(struct MACH0_(obj_t) *bin, ut64 off) {\n\tint i,len;\n\tut32 data;\n\tbin->signature = NULL;\n\tstruct linkedit_data_command link = {0};\n\tut8 lit[sizeof (struct linkedit_data_command)] = {0};\n\tstruct blob_index_t idx = {0};\n\tstruct super_blob_t super = {{0}};\n\n\tif (off > bin->size || off + sizeof (struct linkedit_data_command) > bin->size) {\n\t\treturn false;\n\t}\n\tlen = r_buf_read_at (bin->b, off, lit, sizeof (struct linkedit_data_command));\n\tif (len != sizeof (struct linkedit_data_command)) {\n\t\tbprintf (\"Failed to get data while parsing LC_CODE_SIGNATURE command\\n\");\n\t\treturn false;\n\t}\n\tlink.cmd = r_read_ble32 (&lit[0], bin->big_endian);\n\tlink.cmdsize = r_read_ble32 (&lit[4], bin->big_endian);\n\tlink.dataoff = r_read_ble32 (&lit[8], bin->big_endian);\n\tlink.datasize = r_read_ble32 (&lit[12], bin->big_endian);\n\n\tdata = link.dataoff;\n\tif (data > bin->size || data + sizeof (struct super_blob_t) > bin->size) {\n\t\tbin->signature = (ut8 *)strdup (\"Malformed entitlement\");\n\t\treturn true;\n\t}\n\tsuper.blob.magic = r_buf_read_ble32_at (bin->b, data, mach0_endian);\n\tsuper.blob.length = r_buf_read_ble32_at (bin->b, data + 4, mach0_endian);\n\tsuper.count = r_buf_read_ble32_at (bin->b, data + 8, mach0_endian);\n\tchar *verbose = r_sys_getenv (\"RABIN2_CODESIGN_VERBOSE\");\n\tbool isVerbose = false;\n\tif (verbose) {\n\t\tisVerbose = *verbose;\n\t\tfree (verbose);\n\t}\n\t// to dump all certificates\n\t// [0x00053f75]> b 5K;/x 30800609;wtf @@ hit*\n\t// then do this:\n\t// $ openssl asn1parse -inform der -in a|less\n\t// $ openssl pkcs7 -inform DER -print_certs -text -in a\n\tfor (i = 0; i < super.count; i++) {\n\t\tif (data + i > bin->size) {\n\t\t\tbin->signature = (ut8 *)strdup (\"Malformed entitlement\");\n\t\t\tbreak;\n\t\t}\n\t\tstruct blob_index_t bi;\n\t\tif (r_buf_read_at (bin->b, data + 12 + (i * sizeof (struct blob_index_t)),\n\t\t\t(ut8*)&bi, sizeof (struct blob_index_t)) < sizeof (struct blob_index_t)) {\n\t\t\tbreak;\n\t\t}\n\t\tidx.type = r_read_ble32 (&bi.type, mach0_endian);\n\t\tidx.offset = r_read_ble32 (&bi.offset, mach0_endian);\n\t\tswitch (idx.type) {\n\t\tcase CSSLOT_ENTITLEMENTS:\n\t\t\tif (true || isVerbose) {\n\t\t\t\tut64 off = data + idx.offset;\n\t\t\t\tif (off > bin->size || off + sizeof (struct blob_t) > bin->size) {\n\t\t\t\t\tbin->signature = (ut8 *)strdup (\"Malformed entitlement\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tstruct blob_t entitlements = {0};\n\t\t\t\tentitlements.magic = r_buf_read_ble32_at (bin->b, off, mach0_endian);\n\t\t\t\tentitlements.length = r_buf_read_ble32_at (bin->b, off + 4, mach0_endian);\n\t\t\t\tlen = entitlements.length - sizeof (struct blob_t);\n\t\t\t\tif (len <= bin->size && len > 1) {\n\t\t\t\t\tbin->signature = calloc (1, len + 1);\n\t\t\t\t\tif (!bin->signature) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (off + sizeof (struct blob_t) + len < r_buf_size (bin->b)) {\n\t\t\t\t\t\tr_buf_read_at (bin->b, off + sizeof (struct blob_t), (ut8 *)bin->signature, len);\n\t\t\t\t\t\tif (len >= 0) {\n\t\t\t\t\t\t\tbin->signature[len] = '\\0';\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbin->signature = (ut8 *)strdup (\"Malformed entitlement\");\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tbin->signature = (ut8 *)strdup (\"Malformed entitlement\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase CSSLOT_CODEDIRECTORY:\n\t\t\tif (isVerbose) {\n\t\t\t\tparseCodeDirectory (bin->b, data + idx.offset, link.datasize);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0x1000:\n\t\t\t// unknown\n\t\t\tbreak;\n\t\tcase CSSLOT_CMS_SIGNATURE: // ASN1/DER certificate\n\t\t\tif (isVerbose) {\n\t\t\t\tut8 header[8] = {0};\n\t\t\t\tr_buf_read_at (bin->b, data + idx.offset, header, sizeof (header));\n\t\t\t\tut32 length = R_MIN (UT16_MAX, r_read_ble32 (header + 4, 1));\n\t\t\t\tut8 *p = calloc (length, 1);\n\t\t\t\tif (p) {\n\t\t\t\t\tr_buf_read_at (bin->b, data + idx.offset + 0, p, length);\n\t\t\t\t\tut32 *words = (ut32*)p;\n\t\t\t\t\teprintf (\"Magic: %x\\n\", words[0]);\n\t\t\t\t\teprintf (\"wtf DUMP @%d!%d\\n\",\n\t\t\t\t\t\t(int)data + idx.offset + 8, (int)length);\n\t\t\t\t\teprintf (\"openssl pkcs7 -print_certs -text -inform der -in DUMP\\n\");\n\t\t\t\t\teprintf (\"openssl asn1parse -offset %d -length %d -inform der -in /bin/ls\\n\",\n\t\t\t\t\t\t(int)data + idx.offset + 8, (int)length);\n\t\t\t\t\teprintf (\"pFp@%d!%d\\n\",\n\t\t\t\t\t\t(int)data + idx.offset + 8, (int)length);\n\t\t\t\t\tfree (p);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase CSSLOT_REQUIREMENTS: // 2\n\t\t\t{\n\t\t\t\tut8 p[256];\n\t\t\t\tr_buf_read_at (bin->b, data + idx.offset + 16, p, sizeof (p));\n\t\t\t\tp[sizeof (p) - 1] = 0;\n\t\t\t\tut32 slot_size = r_read_ble32 (p + 8, 1);\n\t\t\t\tif (slot_size < sizeof (p)) {\n\t\t\t\t\tut32 ident_size = r_read_ble32 (p + 8, 1);\n\t\t\t\t\tif (!ident_size || ident_size > sizeof (p) - 28) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tchar *ident = r_str_ndup ((const char *)p + 28, ident_size);\n\t\t\t\t\tif (ident) {\n\t\t\t\t\t\tsdb_set (bin->kv, \"mach0.ident\", ident, 0);\n\t\t\t\t\t\tfree (ident);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (bin->verbose) {\n\t\t\t\t\t\teprintf (\"Invalid code slot size\\n\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase CSSLOT_INFOSLOT: // 1;\n\t\tcase CSSLOT_RESOURCEDIR: // 3;\n\t\tcase CSSLOT_APPLICATION: // 4;\n\t\t\t// TODO: parse those codesign slots\n\t\t\tif (bin->verbose) {\n\t\t\t\teprintf (\"TODO: Some codesign slots are not yet supported\\n\");\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (bin->verbose) {\n\t\t\t\teprintf (\"Unknown Code signature slot %d\\n\", idx.type);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!bin->signature) {\n\t\tbin->signature = (ut8 *)strdup (\"No entitlement found\");\n\t}\n\treturn true;\n}\n\nstatic int parse_thread(struct MACH0_(obj_t) *bin, struct load_command *lc, ut64 off, bool is_first_thread) {\n\tut64 ptr_thread, pc = UT64_MAX, pc_offset = UT64_MAX;\n\tut32 flavor, count;\n\tut8 *arw_ptr = NULL;\n\tint arw_sz, len = 0;\n\tut8 thc[sizeof (struct thread_command)] = {0};\n\tut8 tmp[4];\n\n\tif (off > bin->size || off + sizeof (struct thread_command) > bin->size) {\n\t\treturn false;\n\t}\n\n\tlen = r_buf_read_at (bin->b, off, thc, 8);\n\tif (len < 1) {\n\t\tgoto wrong_read;\n\t}\n\tbin->thread.cmd = r_read_ble32 (&thc[0], bin->big_endian);\n\tbin->thread.cmdsize = r_read_ble32 (&thc[4], bin->big_endian);\n\tif (r_buf_read_at (bin->b, off + sizeof (struct thread_command), tmp, 4) < 4) {\n\t\tgoto wrong_read;\n\t}\n\tflavor = r_read_ble32 (tmp, bin->big_endian);\n\n\tif (off + sizeof (struct thread_command) + sizeof (flavor) > bin->size ||\n\t\toff + sizeof (struct thread_command) + sizeof (flavor) + sizeof (ut32) > bin->size) {\n\t\treturn false;\n\t}\n\n\t// TODO: use count for checks\n\tif (r_buf_read_at (bin->b, off + sizeof (struct thread_command) + sizeof (flavor), tmp, 4) < 4) {\n\t\tgoto wrong_read;\n\t}\n\tcount = r_read_ble32 (tmp, bin->big_endian);\n\tptr_thread = off + sizeof (struct thread_command) + sizeof (flavor) + sizeof (count);\n\n\tif (ptr_thread > bin->size) {\n\t\treturn false;\n\t}\n\n\tswitch (bin->hdr.cputype) {\n\tcase CPU_TYPE_I386:\n\tcase CPU_TYPE_X86_64:\n\t\tswitch (flavor) {\n\t\tcase X86_THREAD_STATE32:\n\t\t\tif (ptr_thread + sizeof (struct x86_thread_state32) > bin->size) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (r_buf_fread_at (bin->b, ptr_thread,\n\t\t\t\t(ut8*)&bin->thread_state.x86_32, \"16i\", 1) == -1) {\n\t\t\t\tbprintf (\"Error: read (thread state x86_32)\\n\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tpc = bin->thread_state.x86_32.eip;\n\t\t\tpc_offset = ptr_thread + r_offsetof(struct x86_thread_state32, eip);\n\t\t\tarw_ptr = (ut8 *)&bin->thread_state.x86_32;\n\t\t\tarw_sz = sizeof (struct x86_thread_state32);\n\t\t\tbreak;\n\t\tcase X86_THREAD_STATE64:\n\t\t\tif (ptr_thread + sizeof (struct x86_thread_state64) > bin->size) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (r_buf_fread_at (bin->b, ptr_thread,\n\t\t\t\t(ut8*)&bin->thread_state.x86_64, \"32l\", 1) == -1) {\n\t\t\t\tbprintf (\"Error: read (thread state x86_64)\\n\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tpc = bin->thread_state.x86_64.rip;\n\t\t\tpc_offset = ptr_thread + r_offsetof(struct x86_thread_state64, rip);\n\t\t\tarw_ptr = (ut8 *)&bin->thread_state.x86_64;\n\t\t\tarw_sz = sizeof (struct x86_thread_state64);\n\t\t\tbreak;\n\t\t//default: bprintf (\"Unknown type\\n\");\n\t\t}\n\t\tbreak;\n\tcase CPU_TYPE_POWERPC:\n\tcase CPU_TYPE_POWERPC64:\n\t\tif (flavor == X86_THREAD_STATE32) {\n\t\t\tif (ptr_thread + sizeof (struct ppc_thread_state32) > bin->size) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (r_buf_fread_at (bin->b, ptr_thread,\n\t\t\t\t(ut8*)&bin->thread_state.ppc_32, bin->big_endian ? \"40I\" : \"40i\", 1) == -1) {\n\t\t\t\tbprintf (\"Error: read (thread state ppc_32)\\n\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tpc = bin->thread_state.ppc_32.srr0;\n\t\t\tpc_offset = ptr_thread + r_offsetof(struct ppc_thread_state32, srr0);\n\t\t\tarw_ptr = (ut8 *)&bin->thread_state.ppc_32;\n\t\t\tarw_sz = sizeof (struct ppc_thread_state32);\n\t\t} else if (flavor == X86_THREAD_STATE64) {\n\t\t\tif (ptr_thread + sizeof (struct ppc_thread_state64) > bin->size) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (r_buf_fread_at (bin->b, ptr_thread,\n\t\t\t\t(ut8*)&bin->thread_state.ppc_64, bin->big_endian ? \"34LI3LI\" : \"34li3li\", 1) == -1) {\n\t\t\t\tbprintf (\"Error: read (thread state ppc_64)\\n\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tpc = bin->thread_state.ppc_64.srr0;\n\t\t\tpc_offset = ptr_thread + r_offsetof(struct ppc_thread_state64, srr0);\n\t\t\tarw_ptr = (ut8 *)&bin->thread_state.ppc_64;\n\t\t\tarw_sz = sizeof (struct ppc_thread_state64);\n\t\t}\n\t\tbreak;\n\tcase CPU_TYPE_ARM:\n\t\tif (ptr_thread + sizeof (struct arm_thread_state32) > bin->size) {\n\t\t\treturn false;\n\t\t}\n\t\tif (r_buf_fread_at (bin->b, ptr_thread,\n\t\t\t(ut8*)&bin->thread_state.arm_32, bin->big_endian ? \"17I\" : \"17i\", 1) == -1) {\n\t\t\tbprintf (\"Error: read (thread state arm)\\n\");\n\t\t\treturn false;\n\t\t}\n\t\tpc = bin->thread_state.arm_32.r15;\n\t\tpc_offset = ptr_thread + r_offsetof (struct arm_thread_state32, r15);\n\t\tarw_ptr = (ut8 *)&bin->thread_state.arm_32;\n\t\tarw_sz = sizeof (struct arm_thread_state32);\n\t\tbreak;\n\tcase CPU_TYPE_ARM64:\n\t\tif (ptr_thread + sizeof (struct arm_thread_state64) > bin->size) {\n\t\t\treturn false;\n\t\t}\n\t\tif (r_buf_fread_at (bin->b, ptr_thread,\n\t\t\t(ut8*)&bin->thread_state.arm_64, bin->big_endian ? \"34LI1I\" : \"34Li1i\", 1) == -1) {\n\t\t\tbprintf (\"Error: read (thread state arm)\\n\");\n\t\t\treturn false;\n\t\t}\n\t\tpc = r_read_be64 (&bin->thread_state.arm_64.pc);\n\t\tpc_offset = ptr_thread + r_offsetof (struct arm_thread_state64, pc);\n\t\tarw_ptr = (ut8*)&bin->thread_state.arm_64;\n\t\tarw_sz = sizeof (struct arm_thread_state64);\n\t\tbreak;\n\tdefault:\n\t\tbprintf (\"Error: read (unknown thread state structure)\\n\");\n\t\treturn false;\n\t}\n\n\t// TODO: this shouldnt be an bprintf...\n\tif (arw_ptr && arw_sz > 0) {\n\t\tint i;\n\t\tut8 *p = arw_ptr;\n\t\tbprintf (\"arw \");\n\t\tfor (i = 0; i < arw_sz; i++) {\n\t\t\tbprintf (\"%02x\", 0xff & p[i]);\n\t\t}\n\t\tbprintf (\"\\n\");\n\t}\n\n\tif (is_first_thread) {\n\t\tbin->main_cmd = *lc;\n\t\tif (pc != UT64_MAX) {\n\t\t\tbin->entry = pc;\n\t\t}\n\t\tif (pc_offset != UT64_MAX) {\n\t\t\tsdb_num_set (bin->kv, \"mach0.entry.offset\", pc_offset, 0);\n\t\t}\n\t}\n\n\treturn true;\nwrong_read:\n\tbprintf (\"Error: read (thread)\\n\");\n\treturn false;\n}\n\nstatic int parse_function_starts(struct MACH0_(obj_t) *bin, ut64 off) {\n\tstruct linkedit_data_command fc;\n\tut8 sfc[sizeof (struct linkedit_data_command)] = {0};\n\tint len;\n\n\tif (off > bin->size || off + sizeof (struct linkedit_data_command) > bin->size) {\n\t\tbprintf (\"Likely overflow while parsing\"\n\t\t\t\" LC_FUNCTION_STARTS command\\n\");\n\t}\n\tbin->func_start = NULL;\n\tlen = r_buf_read_at (bin->b, off, sfc, sizeof (struct linkedit_data_command));\n\tif (len < 1) {\n\t\tbprintf (\"Failed to get data while parsing\"\n\t\t\t\" LC_FUNCTION_STARTS command\\n\");\n\t}\n\tfc.cmd = r_read_ble32 (&sfc[0], bin->big_endian);\n\tfc.cmdsize = r_read_ble32 (&sfc[4], bin->big_endian);\n\tfc.dataoff = r_read_ble32 (&sfc[8], bin->big_endian);\n\tfc.datasize = r_read_ble32 (&sfc[12], bin->big_endian);\n\n\tif ((int)fc.datasize > 0) {\n\t\tut8 *buf = calloc (1, fc.datasize + 1);\n\t\tif (!buf) {\n\t\t\tbprintf (\"Failed to allocate buffer\\n\");\n\t\t\treturn false;\n\t\t}\n\t\tbin->func_size = fc.datasize;\n\t\tif (fc.dataoff > bin->size || fc.dataoff + fc.datasize > bin->size) {\n\t\t\tfree (buf);\n\t\t\tbprintf (\"Likely overflow while parsing \"\n\t\t\t\t\"LC_FUNCTION_STARTS command\\n\");\n\t\t\treturn false;\n\t\t}\n\t\tlen = r_buf_read_at (bin->b, fc.dataoff, buf, fc.datasize);\n\t\tif (len != fc.datasize) {\n\t\t\tfree (buf);\n\t\t\tbprintf (\"Failed to get data while parsing\"\n\t\t\t\t\" LC_FUNCTION_STARTS\\n\");\n\t\t\treturn false;\n\t\t}\n\t\tbuf[fc.datasize] = 0; // null-terminated buffer\n\t\tbin->func_start = buf;\n\t\treturn true;\n\t}\n\tbin->func_start = NULL;\n\treturn false;\n\n}\n\nstatic int parse_dylib(struct MACH0_(obj_t) *bin, ut64 off) {\n\tstruct dylib_command dl;\n\tint lib, len;\n\tut8 sdl[sizeof (struct dylib_command)] = {0};\n\n\tif (off > bin->size || off + sizeof (struct dylib_command) > bin->size) {\n\t\treturn false;\n\t}\n\tlib = bin->nlibs - 1;\n\n\tvoid *relibs = realloc (bin->libs, bin->nlibs * R_BIN_MACH0_STRING_LENGTH);\n\tif (!relibs) {\n\t\tr_sys_perror (\"realloc (libs)\");\n\t\treturn false;\n\t}\n\tbin->libs = relibs;\n\tlen = r_buf_read_at (bin->b, off, sdl, sizeof (struct dylib_command));\n\tif (len < 1) {\n\t\tbprintf (\"Error: read (dylib)\\n\");\n\t\treturn false;\n\t}\n\tdl.cmd = r_read_ble32 (&sdl[0], bin->big_endian);\n\tdl.cmdsize = r_read_ble32 (&sdl[4], bin->big_endian);\n\tdl.dylib.name = r_read_ble32 (&sdl[8], bin->big_endian);\n\tdl.dylib.timestamp = r_read_ble32 (&sdl[12], bin->big_endian);\n\tdl.dylib.current_version = r_read_ble32 (&sdl[16], bin->big_endian);\n\tdl.dylib.compatibility_version = r_read_ble32 (&sdl[20], bin->big_endian);\n\n\tif (off + dl.dylib.name > bin->size ||\\\n\t  off + dl.dylib.name + R_BIN_MACH0_STRING_LENGTH > bin->size) {\n\t\treturn false;\n\t}\n\n\tmemset (bin->libs[lib], 0, R_BIN_MACH0_STRING_LENGTH);\n\tlen = r_buf_read_at (bin->b, off + dl.dylib.name,\n\t\t(ut8*)bin->libs[lib], R_BIN_MACH0_STRING_LENGTH - 1);\n\tbin->libs[lib][R_BIN_MACH0_STRING_LENGTH - 1] = 0;\n\tif (len < 1) {\n\t\tbprintf (\"Error: read (dylib str)\");\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nstatic const char *cmd_to_string(ut32 cmd) {\n\tswitch (cmd) {\n\tcase LC_DATA_IN_CODE:\n\t\treturn \"LC_DATA_IN_CODE\";\n\tcase LC_CODE_SIGNATURE:\n\t\treturn \"LC_CODE_SIGNATURE\";\n\tcase LC_RPATH:\n\t\treturn \"LC_RPATH\";\n\tcase LC_TWOLEVEL_HINTS:\n\t\treturn \"LC_TWOLEVEL_HINTS\";\n\tcase LC_PREBIND_CKSUM:\n\t\treturn \"LC_PREBIND_CKSUM\";\n\tcase LC_SEGMENT:\n\t\treturn \"LC_SEGMENT\";\n\tcase LC_SEGMENT_64:\n\t\treturn \"LC_SEGMENT_64\";\n\tcase LC_SYMTAB:\n\t\treturn \"LC_SYMTAB\";\n\tcase LC_SYMSEG:\n\t\treturn \"LC_SYMSEG\";\n\tcase LC_DYSYMTAB:\n\t\treturn \"LC_DYSYMTAB\";\n\tcase LC_PREBOUND_DYLIB:\n\t\treturn \"LC_PREBOUND_DYLIB\";\n\tcase LC_ROUTINES:\n\t\treturn \"LC_ROUTINES\";\n\tcase LC_ROUTINES_64:\n\t\treturn \"LC_ROUTINES_64\";\n\tcase LC_SUB_FRAMEWORK:\n\t\treturn \"LC_SUB_FRAMEWORK\";\n\tcase LC_SUB_UMBRELLA:\n\t\treturn \"LC_SUB_UMBRELLA\";\n\tcase LC_SUB_CLIENT:\n\t\treturn \"LC_SUB_CLIENT\";\n\tcase LC_SUB_LIBRARY:\n\t\treturn \"LC_SUB_LIBRARY\";\n\tcase LC_FUNCTION_STARTS:\n\t\treturn \"LC_FUNCTION_STARTS\";\n\tcase LC_DYLIB_CODE_SIGN_DRS:\n\t\treturn \"LC_DYLIB_CODE_SIGN_DRS\";\n\tcase LC_NOTE:\n\t\treturn \"LC_NOTE\";\n\tcase LC_BUILD_VERSION:\n\t\treturn \"LC_BUILD_VERSION\";\n\tcase LC_VERSION_MIN_MACOSX:\n\t\treturn \"LC_VERSION_MIN_MACOSX\";\n\tcase LC_VERSION_MIN_IPHONEOS:\n\t\treturn \"LC_VERSION_MIN_IPHONEOS\";\n\tcase LC_VERSION_MIN_TVOS:\n\t\treturn \"LC_VERSION_MIN_TVOS\";\n\tcase LC_VERSION_MIN_WATCHOS:\n\t\treturn \"LC_VERSION_MIN_WATCHOS\";\n\tcase LC_DYLD_INFO:\n\t\treturn \"LC_DYLD_INFO\";\n\tcase LC_DYLD_INFO_ONLY:\n\t\treturn \"LC_DYLD_INFO_ONLY\";\n\tcase LC_DYLD_ENVIRONMENT:\n\t\treturn \"LC_DYLD_ENVIRONMENT\";\n\tcase LC_SOURCE_VERSION:\n\t\treturn \"LC_SOURCE_VERSION\";\n\tcase LC_MAIN:\n\t\treturn \"LC_MAIN\";\n\tcase LC_UUID:\n\t\treturn \"LC_UUID\";\n\tcase LC_ID_DYLIB:\n\t\treturn \"LC_ID_DYLIB\";\n\tcase LC_ID_DYLINKER:\n\t\treturn \"LC_ID_DYLINKER\";\n\tcase LC_LAZY_LOAD_DYLIB:\n\t\treturn \"LC_LAZY_LOAD_DYLIB\";\n\tcase LC_ENCRYPTION_INFO:\n\t\treturn \"LC_ENCRYPTION_INFO\";\n\tcase LC_ENCRYPTION_INFO_64:\n\t\treturn \"LC_ENCRYPTION_INFO_64\";\n\tcase LC_SEGMENT_SPLIT_INFO:\n\t\treturn \"LC_SEGMENT_SPLIT_INFO\";\n\tcase LC_REEXPORT_DYLIB:\n\t\treturn \"LC_REEXPORT_DYLIB\";\n\tcase LC_LINKER_OPTION:\n\t\treturn \"LC_LINKER_OPTION\";\n\tcase LC_LINKER_OPTIMIZATION_HINT:\n\t\treturn \"LC_LINKER_OPTIMIZATION_HINT\";\n\tcase LC_LOAD_DYLINKER:\n\t\treturn \"LC_LOAD_DYLINKER\";\n\tcase LC_LOAD_DYLIB:\n\t\treturn \"LC_LOAD_DYLIB\";\n\tcase LC_LOAD_WEAK_DYLIB:\n\t\treturn \"LC_LOAD_WEAK_DYLIB\";\n\tcase LC_THREAD:\n\t\treturn \"LC_THREAD\";\n\tcase LC_UNIXTHREAD:\n\t\treturn \"LC_UNIXTHREAD\";\n\tcase LC_LOADFVMLIB:\n\t\treturn \"LC_LOADFVMLIB\";\n\tcase LC_IDFVMLIB:\n\t\treturn \"LC_IDFVMLIB\";\n\tcase LC_IDENT:\n\t\treturn \"LC_IDENT\";\n\tcase LC_FVMFILE:\n\t\treturn \"LC_FVMFILE\";\n\tcase LC_PREPAGE:\n\t\treturn \"LC_PREPAGE\";\n\t}\n\treturn \"\";\n}\n\nstatic const char *cmd_to_pf_definition(ut32 cmd) {\n\tswitch (cmd) {\n\tcase LC_BUILD_VERSION:\n\t\treturn \"mach0_build_version_command\";\n\tcase LC_CODE_SIGNATURE:\n\t\treturn \"mach0_code_signature_command\";\n\tcase LC_DATA_IN_CODE:\n\t\treturn \"mach0_data_in_code_command\";\n\tcase LC_DYLD_INFO:\n\tcase LC_DYLD_INFO_ONLY:\n\t\treturn \"mach0_dyld_info_only_command\";\n\tcase LC_DYLD_ENVIRONMENT:\n\t\treturn NULL;\n\tcase LC_DYLIB_CODE_SIGN_DRS:\n\t\treturn NULL;\n\tcase LC_DYSYMTAB:\n\t\treturn \"mach0_dysymtab_command\";\n\tcase LC_ENCRYPTION_INFO:\n\t\treturn \"mach0_encryption_info_command\";\n\tcase LC_ENCRYPTION_INFO_64:\n\t\treturn \"mach0_encryption_info64_command\";\n\tcase LC_FUNCTION_STARTS:\n\t\treturn \"mach0_function_starts_command\";\n\tcase LC_FVMFILE:\n\t\treturn NULL;\n\tcase LC_ID_DYLIB:\n\t\treturn \"mach0_id_dylib_command\";\n\tcase LC_ID_DYLINKER:\n\t\treturn \"mach0_id_dylinker_command\";\n\tcase LC_IDENT:\n\t\treturn NULL;\n\tcase LC_IDFVMLIB:\n\t\treturn NULL;\n\tcase LC_LINKER_OPTION:\n\t\treturn NULL;\n\tcase LC_LINKER_OPTIMIZATION_HINT:\n\t\treturn NULL;\n\tcase LC_LOAD_DYLINKER:\n\t\treturn \"mach0_load_dylinker_command\";\n\tcase LC_LAZY_LOAD_DYLIB:\n\tcase LC_LOAD_WEAK_DYLIB:\n\tcase LC_LOAD_DYLIB:\n\t\treturn \"mach0_dylib_command\";\n\tcase LC_LOADFVMLIB:\n\t\treturn NULL;\n\tcase LC_MAIN:\n\t\treturn \"mach0_entry_point_command\";\n\tcase LC_NOTE:\n\t\treturn NULL;\n\tcase LC_PREBIND_CKSUM:\n\t\treturn NULL;\n\tcase LC_PREBOUND_DYLIB:\n\t\treturn NULL;\n\tcase LC_PREPAGE:\n\t\treturn NULL;\n\tcase LC_REEXPORT_DYLIB:\n\t\treturn NULL;\n\tcase LC_ROUTINES:\n\t\treturn NULL;\n\tcase LC_ROUTINES_64:\n\t\treturn NULL;\n\tcase LC_RPATH:\n\t\treturn \"mach0_rpath_command\";\n\tcase LC_SEGMENT:\n\t\treturn \"mach0_segment\";\n\tcase LC_SEGMENT_64:\n\t\treturn \"mach0_segment64\";\n\tcase LC_SEGMENT_SPLIT_INFO:\n\t\treturn \"mach0_segment_split_info_command\";\n\tcase LC_SOURCE_VERSION:\n\t\treturn \"mach0_source_version_command\";\n\tcase LC_SUB_FRAMEWORK:\n\t\treturn NULL;\n\tcase LC_SUB_UMBRELLA:\n\t\treturn NULL;\n\tcase LC_SUB_CLIENT:\n\t\treturn NULL;\n\tcase LC_SUB_LIBRARY:\n\t\treturn NULL;\n\tcase LC_SYMTAB:\n\t\treturn \"mach0_symtab_command\";\n\tcase LC_SYMSEG:\n\t\treturn NULL;\n\tcase LC_TWOLEVEL_HINTS:\n\t\treturn NULL;\n\tcase LC_UUID:\n\t\treturn \"mach0_uuid_command\";\n\tcase LC_VERSION_MIN_MACOSX:\n\tcase LC_VERSION_MIN_IPHONEOS:\n\tcase LC_VERSION_MIN_TVOS:\n\tcase LC_VERSION_MIN_WATCHOS:\n\t\treturn \"mach0_version_min_command\";\n\tcase LC_THREAD:\n\t\treturn NULL;\n\tcase LC_UNIXTHREAD:\n\t\treturn \"mach0_unixthread_command\";\n\t}\n\treturn NULL;\n}\n\nstatic const char *build_version_platform_to_string(ut32 platform) {\n\tswitch (platform) {\n\tcase 1:\n\t\treturn \"macOS\";\n\tcase 2:\n\t\treturn \"iOS\";\n\tcase 3:\n\t\treturn \"tvOS\";\n\tcase 4:\n\t\treturn \"watchOS\";\n\tcase 5:\n\t\treturn \"bridgeOS\";\n\tcase 6:\n\t\treturn \"iOSmac\";\n\tcase 7:\n\t\treturn \"iOS Simulator\";\n\tcase 8:\n\t\treturn \"tvOS Simulator\";\n\tcase 9:\n\t\treturn \"watchOS Simulator\";\n\tdefault:\n\t\treturn \"unknown\";\n\t}\n}\n\nstatic const char *build_version_tool_to_string(ut32 tool) {\n\tswitch (tool) {\n\tcase 1:\n\t\treturn \"clang\";\n\tcase 2:\n\t\treturn \"swift\";\n\tcase 3:\n\t\treturn \"ld\";\n\tdefault:\n\t\treturn \"unknown\";\n\t}\n}\n\nstatic size_t get_word_size(struct MACH0_(obj_t) *bin) {\n\tconst size_t word_size = MACH0_(get_bits)(bin) / 8;\n\treturn R_MAX (word_size, 4);\n}\n\nstatic bool parse_chained_fixups(struct MACH0_(obj_t) *bin, ut32 offset, ut32 size) {\n\tstruct dyld_chained_fixups_header header;\n\tif (size < sizeof (header)) {\n\t\treturn false;\n\t}\n\tif (r_buf_fread_at (bin->b, offset, (ut8 *)&header, \"7i\", 1) != sizeof (header)) {\n\t\treturn false;\n\t}\n\tif (header.fixups_version > 0) {\n\t\teprintf (\"Unsupported fixups version: %u\\n\", header.fixups_version);\n\t\treturn false;\n\t}\n\tut64 starts_at = offset + header.starts_offset;\n\tif (header.starts_offset > size) {\n\t\treturn false;\n\t}\n\tut32 segs_count = r_buf_read_le32_at (bin->b, starts_at);\n\tif (segs_count == UT32_MAX || segs_count == 0) {\n\t\treturn false;\n\t}\n\tbin->segs_count = segs_count;\n\tbin->chained_starts = R_NEWS0 (struct r_dyld_chained_starts_in_segment *, segs_count);\n\tif (!bin->chained_starts) {\n\t\treturn false;\n\t}\n\tbin->fixups_header = header;\n\tbin->fixups_offset = offset;\n\tbin->fixups_size = size;\n\tsize_t i;\n\tut64 cursor = starts_at + sizeof (ut32);\n\tut64 bsize = r_buf_size (bin->b);\n\tfor (i = 0; i < segs_count && cursor + 4 < bsize; i++) {\n\t\tut32 seg_off;\n\t\tif ((seg_off = r_buf_read_le32_at (bin->b, cursor)) == UT32_MAX || !seg_off) {\n\t\t\tcursor += sizeof (ut32);\n\t\t\tcontinue;\n\t\t}\n\t\tif (i >= bin->nsegs) {\n\t\t\tbreak;\n\t\t}\n\t\tstruct r_dyld_chained_starts_in_segment *cur_seg = R_NEW0 (struct r_dyld_chained_starts_in_segment);\n\t\tif (!cur_seg) {\n\t\t\treturn false;\n\t\t}\n\t\tbin->chained_starts[i] = cur_seg;\n\t\tif (r_buf_fread_at (bin->b, starts_at + seg_off, (ut8 *)cur_seg, \"isslis\", 1) != 22) {\n\t\t\treturn false;\n\t\t}\n\t\tif (cur_seg->page_count > 0) {\n\t\t\tut16 *page_start = malloc (sizeof (ut16) * cur_seg->page_count);\n\t\t\tif (!page_start) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (r_buf_fread_at (bin->b, starts_at + seg_off + 22, (ut8 *)page_start, \"s\", cur_seg->page_count)\n\t\t\t\t\t!= cur_seg->page_count * 2) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tcur_seg->page_start = page_start;\n\t\t}\n\t\tcursor += sizeof (ut32);\n\t}\n\t/* TODO: handle also imports, symbols and multiple starts (32-bit only) */\n\treturn true;\n}\n\nstatic bool reconstruct_chained_fixup(struct MACH0_(obj_t) *bin) {\n\tif (!bin->dyld_info) {\n\t\treturn false;\n\t}\n\tif (!bin->nsegs) {\n\t\treturn false;\n\t}\n\tbin->chained_starts = R_NEWS0 (struct r_dyld_chained_starts_in_segment *, bin->nsegs);\n\tif (!bin->chained_starts) {\n\t\treturn false;\n\t}\n\tsize_t wordsize = get_word_size (bin);\n\tut8 *p = NULL;\n\tsize_t j, count, skip, bind_size;\n\tint seg_idx = 0;\n\tut64 seg_off = 0;\n\tbind_size = bin->dyld_info->bind_size;\n\tif (!bind_size || bind_size < 1) {\n\t\treturn false;\n\t}\n\tif (bin->dyld_info->bind_off > bin->size) {\n\t\treturn false;\n\t}\n\tif (bin->dyld_info->bind_off + bind_size > bin->size) {\n\t\treturn false;\n\t}\n\tut8 *opcodes = calloc (1, bind_size + 1);\n\tif (!opcodes) {\n\t\treturn false;\n\t}\n\tif (r_buf_read_at (bin->b, bin->dyld_info->bind_off, opcodes, bind_size) != bind_size) {\n\t\tbprintf (\"Error: read (dyld_info bind) at 0x%08\"PFMT64x\"\\n\", (ut64)(size_t)bin->dyld_info->bind_off);\n\t\tR_FREE (opcodes);\n\t\treturn false;\n\t}\n\tstruct r_dyld_chained_starts_in_segment *cur_seg = NULL;\n\tsize_t cur_seg_idx = 0;\n\tut8 *end;\n\tbool done = false;\n\tfor (p = opcodes, end = opcodes + bind_size; !done && p < end;) {\n\t\tut8 imm = *p & BIND_IMMEDIATE_MASK, op = *p & BIND_OPCODE_MASK;\n\t\tp++;\n\t\tswitch (op) {\n\t\tcase BIND_OPCODE_DONE:\n\t\t\tdone = true;\n\t\t\tbreak;\n\t\tcase BIND_OPCODE_THREADED: {\n\t\t\tswitch (imm) {\n\t\t\tcase BIND_SUBOPCODE_THREADED_SET_BIND_ORDINAL_TABLE_SIZE_ULEB: {\n\t\t\t\tread_uleb128 (&p, end);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase BIND_SUBOPCODE_THREADED_APPLY: {\n\t\t\t\tconst size_t ps = 0x1000;\n\t\t\t\tif (!cur_seg || cur_seg_idx != seg_idx) {\n\t\t\t\t\tcur_seg_idx = seg_idx;\n\t\t\t\t\tcur_seg = bin->chained_starts[seg_idx];\n\t\t\t\t\tif (!cur_seg) {\n\t\t\t\t\t\tcur_seg = R_NEW0 (struct r_dyld_chained_starts_in_segment);\n\t\t\t\t\t\tif (!cur_seg) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbin->chained_starts[seg_idx] = cur_seg;\n\t\t\t\t\t\tcur_seg->pointer_format = DYLD_CHAINED_PTR_ARM64E;\n\t\t\t\t\t\tcur_seg->page_size = ps;\n\t\t\t\t\t\tcur_seg->page_count = ((bin->segs[seg_idx].vmsize + (ps - 1)) & ~(ps - 1)) / ps;\n\t\t\t\t\t\tif (cur_seg->page_count > 0) {\n\t\t\t\t\t\t\tcur_seg->page_start = malloc (sizeof (ut16) * cur_seg->page_count);\n\t\t\t\t\t\t\tif (!cur_seg->page_start) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tmemset (cur_seg->page_start, 0xff, sizeof (ut16) * cur_seg->page_count);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (cur_seg) {\n\t\t\t\t\tut32 page_index = (ut32)(seg_off / ps);\n\t\t\t\t\tsize_t maxsize = cur_seg->page_count * sizeof (ut16);\n\t\t\t\t\tif (page_index < maxsize && cur_seg->page_start) {\n\t\t\t\t\t\tcur_seg->page_start[page_index] = seg_off & 0xfff;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdefault:\n\t\t\t\tbprintf (\"Error: Unexpected BIND_OPCODE_THREADED sub-opcode: 0x%x\\n\", imm);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase BIND_OPCODE_SET_DYLIB_ORDINAL_IMM:\n\t\tcase BIND_OPCODE_SET_DYLIB_SPECIAL_IMM:\n\t\tcase BIND_OPCODE_SET_TYPE_IMM:\n\t\t\tbreak;\n\t\tcase BIND_OPCODE_SET_DYLIB_ORDINAL_ULEB:\n\t\t\tread_uleb128 (&p, end);\n\t\t\tbreak;\n\t\tcase BIND_OPCODE_SET_SYMBOL_TRAILING_FLAGS_IMM:\n\t\t\twhile (*p++ && p < end) {\n\t\t\t\t/* empty loop */\n\t\t\t}\n\t\t\tbreak;\n\t\tcase BIND_OPCODE_SET_ADDEND_SLEB:\n\t\t\tr_sleb128 ((const ut8 **)&p, end);\n\t\t\tbreak;\n\t\tcase BIND_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB:\n\t\t\tseg_idx = imm;\n\t\t\tif (seg_idx >= bin->nsegs) {\n\t\t\t\tbprintf (\"Error: BIND_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB\"\n\t\t\t\t\t\" has unexistent segment %d\\n\", seg_idx);\n\t\t\t\tR_FREE (opcodes);\n\t\t\t\treturn false;\n\t\t\t} else {\n\t\t\t\tseg_off = read_uleb128 (&p, end);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase BIND_OPCODE_ADD_ADDR_ULEB:\n\t\t\tseg_off += read_uleb128 (&p, end);\n\t\t\tbreak;\n\t\tcase BIND_OPCODE_DO_BIND:\n\t\t\tbreak;\n\t\tcase BIND_OPCODE_DO_BIND_ADD_ADDR_ULEB:\n\t\t\tseg_off += read_uleb128 (&p, end) + wordsize;\n\t\t\tbreak;\n\t\tcase BIND_OPCODE_DO_BIND_ADD_ADDR_IMM_SCALED:\n\t\t\tseg_off += (ut64)imm * (ut64)wordsize + wordsize;\n\t\t\tbreak;\n\t\tcase BIND_OPCODE_DO_BIND_ULEB_TIMES_SKIPPING_ULEB:\n\t\t\tcount = read_uleb128 (&p, end);\n\t\t\tskip = read_uleb128 (&p, end);\n\t\t\tfor (j = 0; j < count; j++) {\n\t\t\t\tseg_off += skip + wordsize;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbprintf (\"Error: unknown bind opcode 0x%02x in dyld_info\\n\", *p);\n\t\t\tR_FREE (opcodes);\n\t\t\treturn false;\n\t\t}\n\t}\n\tR_FREE (opcodes);\n\n\tbin->segs_count = bin->nsegs;\n\treturn true;\n}\n\nstatic int init_items(struct MACH0_(obj_t) *bin) {\n\tstruct load_command lc = {0, 0};\n\tut8 loadc[sizeof (struct load_command)] = {0};\n\tbool is_first_thread = true;\n\tut64 off = 0LL;\n\tint i, len;\n\tchar cmd_flagname[128];\n\n\tbin->uuidn = 0;\n\tbin->os = 0;\n\tbin->has_crypto = 0;\n\tif (bin->hdr.sizeofcmds > bin->size) {\n\t\tbprintf (\"Warning: chopping hdr.sizeofcmds\\n\");\n\t\tbin->hdr.sizeofcmds = bin->size - 128;\n\t\t//return false;\n\t}\n\t//bprintf (\"Commands: %d\\n\", bin->hdr.ncmds);\n\tfor (i = 0, off = sizeof (struct MACH0_(mach_header)) + bin->header_at; \\\n\t\t\ti < bin->hdr.ncmds; i++, off += lc.cmdsize) {\n\t\tif (off > bin->size || off + sizeof (struct load_command) > bin->size) {\n\t\t\tbprintf (\"mach0: out of bounds command\\n\");\n\t\t\treturn false;\n\t\t}\n\t\tlen = r_buf_read_at (bin->b, off, loadc, sizeof (struct load_command));\n\t\tif (len < 1) {\n\t\t\tbprintf (\"Error: read (lc) at 0x%08\"PFMT64x\"\\n\", off);\n\t\t\treturn false;\n\t\t}\n\t\tlc.cmd = r_read_ble32 (&loadc[0], bin->big_endian);\n\t\tlc.cmdsize = r_read_ble32 (&loadc[4], bin->big_endian);\n\n\t\tif (lc.cmdsize < 1 || off + lc.cmdsize > bin->size) {\n\t\t\tbprintf (\"Warning: mach0_header %d = cmdsize<1. (0x%\"PFMT64x\" vs 0x%\"PFMT64x\")\\n\", i,\n\t\t\t\t(ut64)(off + lc.cmdsize), (ut64)(bin->size));\n\t\t\tbreak;\n\t\t}\n\t\tsnprintf (cmd_flagname, sizeof (cmd_flagname), \"mach0_cmd_%d.offset\", i);\n\t\tsdb_num_set (bin->kv, cmd_flagname, off, 0);\n\t\tconst char *format_name = cmd_to_pf_definition (lc.cmd);\n\t\tsnprintf (cmd_flagname, sizeof (cmd_flagname), \"mach0_cmd_%d.format\", i);\n\t\tif (format_name) {\n\t\t\tsdb_set (bin->kv, cmd_flagname, format_name, 0);\n\t\t} else {\n\t\t\tsdb_set (bin->kv, cmd_flagname, \"[4]Ed (mach_load_command_type)cmd size\", 0);\n\t\t}\n\n\t\tsnprintf (cmd_flagname, sizeof (cmd_flagname), \"mach0_cmd_%d.cmd\", i);\n\t\tswitch (lc.cmd) {\n\t\tcase LC_DATA_IN_CODE:\n\t\t\tsdb_set (bin->kv, cmd_flagname, \"data_in_code\", 0);\n\t\t\tbreak;\n\t\tcase LC_RPATH:\n\t\t\tsdb_set (bin->kv, cmd_flagname, \"rpath\", 0);\n\t\t\t//bprintf (\"--->\\n\");\n\t\t\tbreak;\n\t\tcase LC_SEGMENT_64:\n\t\tcase LC_SEGMENT:\n\t\t\tsdb_set (bin->kv, cmd_flagname, \"segment\", 0);\n\t\t\tbin->nsegs++;\n\t\t\tif (!parse_segments (bin, off)) {\n\t\t\t\tbprintf (\"error parsing segment\\n\");\n\t\t\t\tbin->nsegs--;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LC_SYMTAB:\n\t\t\tsdb_set (bin->kv, cmd_flagname, \"symtab\", 0);\n\t\t\tif (!parse_symtab (bin, off)) {\n\t\t\t\tbprintf (\"error parsing symtab\\n\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LC_DYSYMTAB:\n\t\t\tsdb_set (bin->kv, cmd_flagname, \"dysymtab\", 0);\n\t\t\tif (!parse_dysymtab (bin, off)) {\n\t\t\t\tbprintf (\"error parsing dysymtab\\n\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LC_DYLIB_CODE_SIGN_DRS:\n\t\t\tsdb_set (bin->kv, cmd_flagname, \"dylib_code_sign_drs\", 0);\n\t\t\t//bprintf (\"[mach0] code is signed\\n\");\n\t\t\tbreak;\n\t\tcase LC_VERSION_MIN_MACOSX:\n\t\t\tsdb_set (bin->kv, cmd_flagname, \"version_min_macosx\", 0);\n\t\t\tbin->os = 1;\n\t\t\t// set OS = osx\n\t\t\t//bprintf (\"[mach0] Requires OSX >= x\\n\");\n\t\t\tbreak;\n\t\tcase LC_VERSION_MIN_IPHONEOS:\n\t\t\tsdb_set (bin->kv, cmd_flagname, \"version_min_iphoneos\", 0);\n\t\t\tbin->os = 2;\n\t\t\t// set OS = ios\n\t\t\t//bprintf (\"[mach0] Requires iOS >= x\\n\");\n\t\t\tbreak;\n\t\tcase LC_VERSION_MIN_TVOS:\n\t\t\tsdb_set (bin->kv, cmd_flagname, \"version_min_tvos\", 0);\n\t\t\tbin->os = 4;\n\t\t\tbreak;\n\t\tcase LC_VERSION_MIN_WATCHOS:\n\t\t\tsdb_set (bin->kv, cmd_flagname, \"version_min_watchos\", 0);\n\t\t\tbin->os = 3;\n\t\t\tbreak;\n\t\tcase LC_UUID:\n\t\t\tsdb_set (bin->kv, cmd_flagname, \"uuid\", 0);\n\t\t\t{\n\t\t\tstruct uuid_command uc = {0};\n\t\t\tif (off + sizeof (struct uuid_command) > bin->size) {\n\t\t\t\tbprintf (\"UUID out of bounds\\n\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (r_buf_fread_at (bin->b, off, (ut8*)&uc, \"24c\", 1) != -1) {\n\t\t\t\tchar key[128];\n\t\t\t\tchar val[128];\n\t\t\t\tsnprintf (key, sizeof (key)-1, \"uuid.%d\", bin->uuidn++);\n\t\t\t\tr_hex_bin2str ((ut8*)&uc.uuid, 16, val);\n\t\t\t\tsdb_set (bin->kv, key, val, 0);\n\t\t\t\t//for (i=0;i<16; i++) bprintf (\"%02x%c\", uc.uuid[i], (i==15)?'\\n':'-');\n\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LC_ENCRYPTION_INFO_64:\n\t\t\t/* TODO: the struct is probably different here */\n\t\tcase LC_ENCRYPTION_INFO:\n\t\t\tsdb_set (bin->kv, cmd_flagname, \"encryption_info\", 0);\n\t\t\t{\n\t\t\tstruct MACH0_(encryption_info_command) eic = {0};\n\t\t\tut8 seic[sizeof (struct MACH0_(encryption_info_command))] = {0};\n\t\t\tif (off + sizeof (struct MACH0_(encryption_info_command)) > bin->size) {\n\t\t\t\tbprintf (\"encryption info out of bounds\\n\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (r_buf_read_at (bin->b, off, seic, sizeof (struct MACH0_(encryption_info_command))) != -1) {\n\t\t\t\teic.cmd = r_read_ble32 (&seic[0], bin->big_endian);\n\t\t\t\teic.cmdsize = r_read_ble32 (&seic[4], bin->big_endian);\n\t\t\t\teic.cryptoff = r_read_ble32 (&seic[8], bin->big_endian);\n\t\t\t\teic.cryptsize = r_read_ble32 (&seic[12], bin->big_endian);\n\t\t\t\teic.cryptid = r_read_ble32 (&seic[16], bin->big_endian);\n\n\t\t\t\tbin->has_crypto = eic.cryptid;\n\t\t\t\tsdb_set (bin->kv, \"crypto\", \"true\", 0);\n\t\t\t\tsdb_num_set (bin->kv, \"cryptid\", eic.cryptid, 0);\n\t\t\t\tsdb_num_set (bin->kv, \"cryptoff\", eic.cryptoff, 0);\n\t\t\t\tsdb_num_set (bin->kv, \"cryptsize\", eic.cryptsize, 0);\n\t\t\t\tsdb_num_set (bin->kv, \"cryptheader\", off, 0);\n\t\t\t} }\n\t\t\tbreak;\n\t\tcase LC_LOAD_DYLINKER:\n\t\t\t{\n\t\t\t\tsdb_set (bin->kv, cmd_flagname, \"dylinker\", 0);\n\t\t\t\tR_FREE (bin->intrp);\n\t\t\t\t//bprintf (\"[mach0] load dynamic linker\\n\");\n\t\t\t\tstruct dylinker_command dy = {0};\n\t\t\t\tut8 sdy[sizeof (struct dylinker_command)] = {0};\n\t\t\t\tif (off + sizeof (struct dylinker_command) > bin->size){\n\t\t\t\t\tbprintf (\"Warning: Cannot parse dylinker command\\n\");\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tif (r_buf_read_at (bin->b, off, sdy, sizeof (struct dylinker_command)) == -1) {\n\t\t\t\t\tbprintf (\"Warning: read (LC_DYLD_INFO) at 0x%08\"PFMT64x\"\\n\", off);\n\t\t\t\t} else {\n\t\t\t\t\tdy.cmd = r_read_ble32 (&sdy[0], bin->big_endian);\n\t\t\t\t\tdy.cmdsize = r_read_ble32 (&sdy[4], bin->big_endian);\n\t\t\t\t\tdy.name = r_read_ble32 (&sdy[8], bin->big_endian);\n\n\t\t\t\t\tint len = dy.cmdsize;\n\t\t\t\t\tchar *buf = malloc (len+1);\n\t\t\t\t\tif (buf) {\n\t\t\t\t\t\t// wtf @ off + 0xc ?\n\t\t\t\t\t\tr_buf_read_at (bin->b, off + 0xc, (ut8*)buf, len);\n\t\t\t\t\t\tbuf[len] = 0;\n\t\t\t\t\t\tfree (bin->intrp);\n\t\t\t\t\t\tbin->intrp = buf;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LC_MAIN:\n\t\t\t{\n\t\t\tstruct {\n\t\t\t\tut64 eo;\n\t\t\t\tut64 ss;\n\t\t\t} ep = {0};\n\t\t\tut8 sep[2 * sizeof (ut64)] = {0};\n\t\t\tsdb_set (bin->kv, cmd_flagname, \"main\", 0);\n\n\t\t\tif (!is_first_thread) {\n\t\t\t\tbprintf (\"Error: LC_MAIN with other threads\\n\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (off + 8 > bin->size || off + sizeof (ep) > bin->size) {\n\t\t\t\tbprintf (\"invalid command size for main\\n\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tr_buf_read_at (bin->b, off + 8, sep, 2 * sizeof (ut64));\n\t\t\tep.eo = r_read_ble64 (&sep[0], bin->big_endian);\n\t\t\tep.ss = r_read_ble64 (&sep[8], bin->big_endian);\n\n\t\t\tbin->entry = ep.eo;\n\t\t\tbin->main_cmd = lc;\n\n\t\t\tsdb_num_set (bin->kv, \"mach0.entry.offset\", off + 8, 0);\n\t\t\tsdb_num_set (bin->kv, \"stacksize\", ep.ss, 0);\n\n\t\t\tis_first_thread = false;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LC_UNIXTHREAD:\n\t\t\tsdb_set (bin->kv, cmd_flagname, \"unixthread\", 0);\n\t\t\tif (!is_first_thread) {\n\t\t\t\tbprintf (\"Error: LC_UNIXTHREAD with other threads\\n\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\tcase LC_THREAD:\n\t\t\tsdb_set (bin->kv, cmd_flagname, \"thread\", 0);\n\t\t\tif (!parse_thread (bin, &lc, off, is_first_thread)) {\n\t\t\t\tbprintf (\"Cannot parse thread\\n\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tis_first_thread = false;\n\t\t\tbreak;\n\t\tcase LC_LOAD_DYLIB:\n\t\tcase LC_LOAD_WEAK_DYLIB:\n\t\t\tsdb_set (bin->kv, cmd_flagname, \"load_dylib\", 0);\n\t\t\tbin->nlibs++;\n\t\t\tif (!parse_dylib (bin, off)) {\n\t\t\t\tbprintf (\"Cannot parse dylib\\n\");\n\t\t\t\tbin->nlibs--;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LC_DYLD_INFO:\n\t\tcase LC_DYLD_INFO_ONLY:\n\t\t\t{\n\t\t\tut8 dyldi[sizeof (struct dyld_info_command)] = {0};\n\t\t\tsdb_set (bin->kv, cmd_flagname, \"dyld_info\", 0);\n\t\t\tbin->dyld_info = calloc (1, sizeof (struct dyld_info_command));\n\t\t\tif (bin->dyld_info) {\n\t\t\t\tif (off + sizeof (struct dyld_info_command) > bin->size){\n\t\t\t\t\tbprintf (\"Cannot parse dyldinfo\\n\");\n\t\t\t\t\tR_FREE (bin->dyld_info);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tif (r_buf_read_at (bin->b, off, dyldi, sizeof (struct dyld_info_command)) == -1) {\n\t\t\t\t\tR_FREE (bin->dyld_info);\n\t\t\t\t\tbprintf (\"Error: read (LC_DYLD_INFO) at 0x%08\"PFMT64x\"\\n\", off);\n\t\t\t\t} else {\n\t\t\t\t\tbin->dyld_info->cmd = r_read_ble32 (&dyldi[0], bin->big_endian);\n\t\t\t\t\tbin->dyld_info->cmdsize = r_read_ble32 (&dyldi[4], bin->big_endian);\n\t\t\t\t\tbin->dyld_info->rebase_off = r_read_ble32 (&dyldi[8], bin->big_endian);\n\t\t\t\t\tbin->dyld_info->rebase_size = r_read_ble32 (&dyldi[12], bin->big_endian);\n\t\t\t\t\tbin->dyld_info->bind_off = r_read_ble32 (&dyldi[16], bin->big_endian);\n\t\t\t\t\tbin->dyld_info->bind_size = r_read_ble32 (&dyldi[20], bin->big_endian);\n\t\t\t\t\tbin->dyld_info->weak_bind_off = r_read_ble32 (&dyldi[24], bin->big_endian);\n\t\t\t\t\tbin->dyld_info->weak_bind_size = r_read_ble32 (&dyldi[28], bin->big_endian);\n\t\t\t\t\tbin->dyld_info->lazy_bind_off = r_read_ble32 (&dyldi[32], bin->big_endian);\n\t\t\t\t\tbin->dyld_info->lazy_bind_size = r_read_ble32 (&dyldi[36], bin->big_endian);\n\t\t\t\t\tbin->dyld_info->export_off = r_read_ble32 (&dyldi[40], bin->big_endian) + bin->symbols_off;\n\t\t\t\t\tbin->dyld_info->export_size = r_read_ble32 (&dyldi[44], bin->big_endian);\n\t\t\t\t}\n\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LC_CODE_SIGNATURE:\n\t\t\tparse_signature (bin, off);\n\t\t\tsdb_set (bin->kv, cmd_flagname, \"signature\", 0);\n\t\t\t/* ut32 dataoff\n\t\t\t// ut32 datasize */\n\t\t\tbreak;\n\t\tcase LC_SOURCE_VERSION:\n\t\t\tsdb_set (bin->kv, cmd_flagname, \"version\", 0);\n\t\t\t/* uint64_t  version;  */\n\t\t\t/* A.B.C.D.E packed as a24.b10.c10.d10.e10 */\n\t\t\t//bprintf (\"mach0: TODO: Show source version\\n\");\n\t\t\tbreak;\n\t\tcase LC_SEGMENT_SPLIT_INFO:\n\t\t\tsdb_set (bin->kv, cmd_flagname, \"split_info\", 0);\n\t\t\t/* TODO */\n\t\t\tbreak;\n\t\tcase LC_FUNCTION_STARTS:\n\t\t\tsdb_set (bin->kv, cmd_flagname, \"function_starts\", 0);\n\t\t\tif (!parse_function_starts (bin, off)) {\n\t\t\t\tbprintf (\"Cannot parse LC_FUNCTION_STARTS\\n\");\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LC_REEXPORT_DYLIB:\n\t\t\tsdb_set (bin->kv, cmd_flagname, \"dylib\", 0);\n\t\t\t/* TODO */\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t//bprintf (\"mach0: Unknown header command %x\\n\", lc.cmd);\n\t\t\tbreak;\n\t\t}\n\t}\n\tbool has_chained_fixups = false;\n\tfor (i = 0, off = sizeof (struct MACH0_(mach_header)) + bin->header_at; \\\n\t\t\ti < bin->hdr.ncmds; i++, off += lc.cmdsize) {\n\t\tlen = r_buf_read_at (bin->b, off, loadc, sizeof (struct load_command));\n\t\tif (len < 1) {\n\t\t\tbprintf (\"Error: read (lc) at 0x%08\"PFMT64x\"\\n\", off);\n\t\t\treturn false;\n\t\t}\n\t\tlc.cmd = r_read_ble32 (&loadc[0], bin->big_endian);\n\t\tlc.cmdsize = r_read_ble32 (&loadc[4], bin->big_endian);\n\n\t\tif (lc.cmdsize < 1 || off + lc.cmdsize > bin->size) {\n\t\t\tbprintf (\"Warning: mach0_header %d = cmdsize<1. (0x%\"PFMT64x\" vs 0x%\"PFMT64x\")\\n\", i,\n\t\t\t\t(ut64)(off + lc.cmdsize), (ut64)(bin->size));\n\t\t\tbreak;\n\t\t}\n\t\tsnprintf (cmd_flagname, sizeof (cmd_flagname), \"mach0_cmd_%d.offset\", i);\n\t\tsdb_num_set (bin->kv, cmd_flagname, off, 0);\n\t\tconst char *format_name = cmd_to_pf_definition (lc.cmd);\n\t\tsnprintf (cmd_flagname, sizeof (cmd_flagname), \"mach0_cmd_%d.format\", i);\n\t\tif (format_name) {\n\t\t\tsdb_set (bin->kv, cmd_flagname, format_name, 0);\n\t\t} else {\n\t\t\tsdb_set (bin->kv, cmd_flagname, \"[4]Ed (mach_load_command_type)cmd size\", 0);\n\t\t}\n\n\t\tswitch (lc.cmd) {\n\t\tcase LC_DATA_IN_CODE:\n\t\t\tsnprintf (cmd_flagname, sizeof (cmd_flagname), \"mach0_cmd_%d.cmd\", i);\n\t\t\tsdb_set (bin->kv, cmd_flagname, \"data_in_code\", 0);\n\t\t\tif (bin->verbose) {\n\t\t\t\tut8 buf[8];\n\t\t\t\tr_buf_read_at (bin->b, off + 8, buf, sizeof (buf));\n\t\t\t\tut32 dataoff = r_read_ble32 (buf, bin->big_endian);\n\t\t\t\tut32 datasize= r_read_ble32 (buf + 4, bin->big_endian);\n\t\t\t\teprintf (\"data-in-code at 0x%x size %d\\n\", dataoff, datasize);\n\t\t\t\tut8 *db = (ut8*)malloc (datasize);\n\t\t\t\tif (db) {\n\t\t\t\t\tr_buf_read_at (bin->b, dataoff, db, datasize);\n\t\t\t\t\t// TODO table of non-instructions regions in __text\n\t\t\t\t\tint j;\n\t\t\t\t\tfor (j = 0; j < datasize; j += 8) {\n\t\t\t\t\t\tut32 dw = r_read_ble32 (db + j, bin->big_endian);\n\t\t\t\t\t\t// int kind = r_read_ble16 (db + i + 4 + 2, bin->big_endian);\n\t\t\t\t\t\tint len = r_read_ble16 (db + j + 4, bin->big_endian);\n\t\t\t\t\t\tut64 va = offset_to_vaddr(bin, dw);\n\t\t\t\t\t//\teprintf (\"# 0x%d -> 0x%x\\n\", dw, va);\n\t\t\t\t\t//\teprintf (\"0x%x kind %d len %d\\n\", dw, kind, len);\n\t\t\t\t\t\teprintf (\"Cd 4 %d @ 0x%\"PFMT64x\"\\n\", len / 4, va);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LC_DYLD_EXPORTS_TRIE:\n\t\t\tif (bin->verbose) {\n\t\t\t\tut8 buf[8];\n\t\t\t\tr_buf_read_at (bin->b, off + 8, buf, sizeof (buf));\n\t\t\t\tut32 dataoff = r_read_ble32 (buf, bin->big_endian);\n\t\t\t\tut32 datasize= r_read_ble32 (buf + 4, bin->big_endian);\n\t\t\t\teprintf (\"exports trie at 0x%x size %d\\n\", dataoff, datasize);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LC_DYLD_CHAINED_FIXUPS: {\n\t\t\t\tut8 buf[8];\n\t\t\t\tif (r_buf_read_at (bin->b, off + 8, buf, sizeof (buf)) == sizeof (buf)) {\n\t\t\t\t\tut32 dataoff = r_read_ble32 (buf, bin->big_endian);\n\t\t\t\t\tut32 datasize= r_read_ble32 (buf + 4, bin->big_endian);\n\t\t\t\t\tif (bin->verbose) {\n\t\t\t\t\t\teprintf (\"chained fixups at 0x%x size %d\\n\", dataoff, datasize);\n\t\t\t\t\t}\n\t\t\t\t\thas_chained_fixups = parse_chained_fixups (bin, dataoff, datasize);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!has_chained_fixups && bin->hdr.cputype == CPU_TYPE_ARM64 &&\n\t\t(bin->hdr.cpusubtype & ~CPU_SUBTYPE_MASK) == CPU_SUBTYPE_ARM64E) {\n#if 0\n\t\tif (bin->verbose) {\n\t\t\teprintf (\"reconstructing chained fixups\\n\");\n\t\t}\n#endif\n\t\treconstruct_chained_fixup (bin);\n\t}\n\treturn true;\n}\n\nstatic bool init(struct MACH0_(obj_t) *mo) {\n\tif (!init_hdr (mo)) {\n\t\treturn false;\n\t}\n\tif (!init_items (mo)) {\n\t\tEprintf (\"Warning: Cannot initialize items\\n\");\n\t}\n\tmo->baddr = MACH0_(get_baddr)(mo);\n\treturn true;\n}\n\nvoid *MACH0_(mach0_free)(struct MACH0_(obj_t) *mo) {\n\tif (!mo) {\n\t\treturn NULL;\n\t}\n\n\tsize_t i;\n\tif (mo->symbols) {\n\t\tfor (i = 0; !mo->symbols[i].last; i++) {\n\t\t\tfree (mo->symbols[i].name);\n\t\t}\n\t\tfree (mo->symbols);\n\t}\n\tfree (mo->segs);\n\tfree (mo->sects);\n\tfree (mo->symtab);\n\tfree (mo->symstr);\n\tfree (mo->indirectsyms);\n\tfree (mo->imports_by_ord);\n\tht_pp_free (mo->imports_by_name);\n\tfree (mo->dyld_info);\n\tfree (mo->toc);\n\tfree (mo->modtab);\n\tfree (mo->libs);\n\tfree (mo->func_start);\n\tfree (mo->signature);\n\tfree (mo->intrp);\n\tfree (mo->compiler);\n\tif (mo->chained_starts) {\n\t\tfor (i = 0; i < mo->nsegs && i < mo->segs_count; i++) {\n\t\t\tif (mo->chained_starts[i]) {\n\t\t\t\tfree (mo->chained_starts[i]->page_start);\n\t\t\t\tfree (mo->chained_starts[i]);\n\t\t\t}\n\t\t}\n\t\tfree (mo->chained_starts);\n\t}\n\tr_buf_free (mo->b);\n\tfree (mo);\n\treturn NULL;\n}\n\nvoid MACH0_(opts_set_default)(struct MACH0_(opts_t) *options, RBinFile *bf) {\n\tr_return_if_fail (options && bf && bf->rbin);\n\toptions->header_at = 0;\n\toptions->symbols_off = 0;\n\toptions->verbose = bf->rbin->verbose;\n}\n\nstatic void *duplicate_ptr(void *p) {\n\treturn p;\n}\n\nstatic void free_only_key(HtPPKv *kv) {\n\tfree (kv->key);\n}\n\nstatic size_t ptr_size(void *c) {\n\t// :D\n\treturn 8;\n}\n\n// XXX should be deprecated its never called\nstruct MACH0_(obj_t) *MACH0_(mach0_new)(const char *file, struct MACH0_(opts_t) *options) {\n\tstruct MACH0_(obj_t) *bin = R_NEW0 (struct MACH0_(obj_t));\n\tif (!bin) {\n\t\treturn NULL;\n\t}\n\tif (options) {\n\t\tbin->verbose = options->verbose;\n\t\tbin->header_at = options->header_at;\n\t\tbin->symbols_off = options->symbols_off;\n\t}\n\tbin->file = file;\n\tsize_t binsz;\n\tut8 *buf = (ut8 *)r_file_slurp (file, &binsz);\n\tbin->size = binsz;\n\tif (!buf) {\n\t\treturn MACH0_(mach0_free)(bin);\n\t}\n\tbin->b = r_buf_new ();\n\tif (!r_buf_set_bytes (bin->b, buf, bin->size)) {\n\t\tfree (buf);\n\t\treturn MACH0_(mach0_free)(bin);\n\t}\n\tfree (buf);\n\tbin->dyld_info = NULL;\n\tif (!init (bin)) {\n\t\treturn MACH0_(mach0_free)(bin);\n\t}\n\tbin->imports_by_ord_size = 0;\n\tbin->imports_by_ord = NULL;\n\tbin->imports_by_name = ht_pp_new ((HtPPDupValue)duplicate_ptr, free_only_key, (HtPPCalcSizeV)ptr_size);\n\treturn bin;\n}\n\nstruct MACH0_(obj_t) *MACH0_(new_buf)(RBuffer *buf, struct MACH0_(opts_t) *options) {\n\tr_return_val_if_fail (buf, NULL);\n\tstruct MACH0_(obj_t) *bin = R_NEW0 (struct MACH0_(obj_t));\n\tif (bin) {\n\t\tbin->b = r_buf_ref (buf);\n\t\tbin->main_addr = UT64_MAX;\n\t\tbin->kv = sdb_new (NULL, \"bin.mach0\", 0);\n\t\tbin->size = r_buf_size (bin->b);\n\t\tif (options) {\n\t\t\tbin->verbose = options->verbose;\n\t\t\tbin->header_at = options->header_at;\n\t\t\tbin->symbols_off = options->symbols_off;\n\t\t}\n\t\tif (!init (bin)) {\n\t\t\treturn MACH0_(mach0_free)(bin);\n\t\t}\n\t}\n\treturn bin;\n}\n\n// prot: r = 1, w = 2, x = 4\n// perm: r = 4, w = 2, x = 1\nstatic int prot2perm(int x) {\n\tint r = 0;\n\tif (x & 1) {\n\t\tr |= 4;\n\t}\n\tif (x & 2) {\n\t\tr |= 2;\n\t}\n\tif (x & 4) {\n\t\tr |= 1;\n\t}\n\treturn r;\n}\n\nstatic bool is_data_section(RBinSection *sect) {\n\tif (strstr (sect->name, \"_cstring\")) {\n\t\treturn true;\n\t}\n\tif (strstr (sect->name, \"_objc_methname\")) {\n\t\treturn true;\n\t}\n\tif (strstr (sect->name, \"_objc_classname\")) {\n\t\treturn true;\n\t}\n\tif (strstr (sect->name, \"_objc_methtype\")) {\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nRList *MACH0_(get_segments)(RBinFile *bf) {\n\tstruct MACH0_(obj_t) *bin = bf->o->bin_obj;\n\tRList *list = r_list_newf ((RListFree)r_bin_section_free);\n\tsize_t i, j;\n\n\t/* for core files */\n\tif (bin->nsegs > 0) {\n\t\tstruct MACH0_(segment_command) *seg;\n\t\tfor (i = 0; i < bin->nsegs; i++) {\n\t\t\tseg = &bin->segs[i];\n\t\t\tif (!seg->initprot) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tRBinSection *s = r_bin_section_new (NULL);\n\t\t\tif (!s) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ts->vaddr = seg->vmaddr;\n\t\t\ts->vsize = seg->vmsize;\n\t\t\ts->size = seg->vmsize;\n\t\t\ts->paddr = seg->fileoff;\n\t\t\ts->paddr += bf->o->boffset;\n\t\t\t//TODO s->flags = seg->flags;\n\t\t\ts->name = r_str_ndup (seg->segname, 16);\n\t\t\ts->is_segment = true;\n\t\t\tr_str_filter (s->name, -1);\n\t\t\ts->perm = prot2perm (seg->initprot);\n\t\t\ts->add = true;\n\t\t\tr_list_append (list, s);\n\t\t}\n\t}\n\tif (bin->nsects > 0) {\n\t\tint last_section = R_MIN (bin->nsects, 128); // maybe drop this limit?\n\t\tfor (i = 0; i < last_section; i++) {\n\t\t\tRBinSection *s = R_NEW0 (RBinSection);\n\t\t\tif (!s) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ts->vaddr = (ut64)bin->sects[i].addr;\n\t\t\ts->vsize = (ut64)bin->sects[i].size;\n\t\t\ts->is_segment = false;\n\t\t\ts->size = (bin->sects[i].flags == S_ZEROFILL) ? 0 : (ut64)bin->sects[i].size;\n\t\t\t// XXX flags\n\t\t\ts->paddr = (ut64)bin->sects[i].offset;\n\t\t\tint segment_index = 0;\n\t\t\t//s->perm =prot2perm (bin->segs[j].initprot);\n\t\t\tfor (j = 0; j < bin->nsegs; j++) {\n\t\t\t\tif (s->vaddr >= bin->segs[j].vmaddr &&\n\t\t\t\t\t\ts->vaddr < (bin->segs[j].vmaddr + bin->segs[j].vmsize)) {\n\t\t\t\t\ts->perm = prot2perm (bin->segs[j].initprot);\n\t\t\t\t\tsegment_index = j;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tchar *section_name = r_str_ndup (bin->sects[i].sectname, 16);\n\t\t\tchar *segment_name = r_str_newf (\"%u.%s\", (ut32)i, bin->segs[segment_index].segname);\n\t\t\ts->name = r_str_newf (\"%s.%s\", segment_name, section_name);\n\t\t\tif (strstr (s->name, \"__const\")) {\n\t\t\t\ts->format = r_str_newf (\"Cd 4[%\"PFMT64d\"]\", s->size / 4);\n\t\t\t}\n\t\t\ts->is_data = is_data_section (s);\n\t\t\tif (strstr (section_name, \"interpos\") || strstr (section_name, \"__mod_\")) {\n#if R_BIN_MACH064\n\t\t\t\tconst int ws = 8;\n#else\n\t\t\t\tconst int ws = 4;\n#endif\n\t\t\t\ts->format = r_str_newf (\"Cd %d[%\"PFMT64d\"]\", ws, s->vsize / ws);\n\t\t\t}\n\t\t\tr_list_append (list, s);\n\t\t\tfree (segment_name);\n\t\t\tfree (section_name);\n\t\t}\n\t}\n\treturn list;\n}\n\n// XXX this function is called so many times\nstruct section_t *MACH0_(get_sections)(struct MACH0_(obj_t) *bin) {\n\tr_return_val_if_fail (bin, NULL);\n\tstruct section_t *sections;\n\tchar sectname[64], raw_segname[17];\n\tsize_t i, j, to;\n\n\t/* for core files */\n\tif (bin->nsects < 1 && bin->nsegs > 0) {\n\t\tstruct MACH0_(segment_command) *seg;\n\t\tif (!(sections = calloc ((bin->nsegs + 1), sizeof (struct section_t)))) {\n\t\t\treturn NULL;\n\t\t}\n\t\tfor (i = 0; i < bin->nsegs; i++) {\n\t\t\tseg = &bin->segs[i];\n\t\t\tsections[i].addr = seg->vmaddr;\n\t\t\tsections[i].offset = seg->fileoff;\n\t\t\tsections[i].size = seg->vmsize;\n\t\t\tsections[i].vsize = seg->vmsize;\n\t\t\tsections[i].align = 4096;\n\t\t\tsections[i].flags = seg->flags;\n\t\t\tr_str_ncpy (sectname, seg->segname, 16);\n\t\t\tsectname[16] = 0;\n\t\t\tr_str_filter (sectname, -1);\n\t\t\t// hack to support multiple sections with same name\n\t\t\tsections[i].perm = prot2perm (seg->initprot);\n\t\t\tsections[i].last = 0;\n\t\t}\n\t\tsections[i].last = 1;\n\t\treturn sections;\n\t}\n\n\tif (!bin->sects) {\n\t\treturn NULL;\n\t}\n\tto = R_MIN (bin->nsects, 128); // limit number of sections here to avoid fuzzed bins\n\tif (to < 1) {\n\t\treturn NULL;\n\t}\n\tif (!(sections = calloc (bin->nsects + 1, sizeof (struct section_t)))) {\n\t\treturn NULL;\n\t}\n\tfor (i = 0; i < to; i++) {\n\t\tsections[i].offset = (ut64)bin->sects[i].offset;\n\t\tsections[i].addr = (ut64)bin->sects[i].addr;\n\t\tsections[i].size = (bin->sects[i].flags == S_ZEROFILL) ? 0 : (ut64)bin->sects[i].size;\n\t\tsections[i].vsize = (ut64)bin->sects[i].size;\n\t\tsections[i].align = bin->sects[i].align;\n\t\tsections[i].flags = bin->sects[i].flags;\n\t\tr_str_ncpy (sectname, bin->sects[i].sectname, 17);\n\t\tr_str_filter (sectname, -1);\n\t\tr_str_ncpy (raw_segname, bin->sects[i].segname, 16);\n\t\tfor (j = 0; j < bin->nsegs; j++) {\n\t\t\tif (sections[i].addr >= bin->segs[j].vmaddr &&\n\t\t\t\tsections[i].addr < (bin->segs[j].vmaddr + bin->segs[j].vmsize)) {\n\t\t\t\tsections[i].perm = prot2perm (bin->segs[j].initprot);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tsnprintf (sections[i].name, sizeof (sections[i].name),\n\t\t\t\"%d.%s.%s\", (int)i, raw_segname, sectname);\n\t\tsections[i].last = 0;\n\t}\n\tsections[i].last = 1;\n\treturn sections;\n}\n\nstatic bool parse_import_stub(struct MACH0_(obj_t) *bin, struct symbol_t *symbol, int idx) {\n\tsize_t i, j, nsyms, stridx;\n\tconst char *symstr;\n\tif (idx < 0) {\n\t\treturn false;\n\t}\n\tsymbol->offset = 0LL;\n\tsymbol->addr = 0LL;\n\tsymbol->name = NULL;\n\tsymbol->is_imported = true;\n\n\tif (!bin || !bin->sects) {\n\t\treturn false;\n\t}\n\tfor (i = 0; i < bin->nsects; i++) {\n\t\tif ((bin->sects[i].flags & SECTION_TYPE) == S_SYMBOL_STUBS && bin->sects[i].reserved2 > 0) {\n\t\t\tut64 sect_size = bin->sects[i].size;\n\t\t\tut32 sect_fragment = bin->sects[i].reserved2;\n\t\t\tif (bin->sects[i].offset > bin->size) {\n\t\t\t\tbprintf (\"mach0: section offset starts way beyond the end of the file\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (sect_size > bin->size) {\n\t\t\t\tbprintf (\"mach0: Invalid symbol table size\\n\");\n\t\t\t\tsect_size = bin->size - bin->sects[i].offset;\n\t\t\t}\n\t\t\tnsyms = (int)(sect_size / sect_fragment);\n\t\t\tfor (j = 0; j < nsyms; j++) {\n\t\t\t\tif (bin->sects) {\n\t\t\t\t\tif (bin->sects[i].reserved1 + j >= bin->nindirectsyms) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (bin->indirectsyms) {\n\t\t\t\t\tif (idx != bin->indirectsyms[bin->sects[i].reserved1 + j]) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (idx > bin->nsymtab) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tsymbol->type = R_BIN_MACH0_SYMBOL_TYPE_LOCAL;\n\t\t\t\tint delta = j * bin->sects[i].reserved2;\n\t\t\t\tif (delta < 0) {\n\t\t\t\t\tbprintf (\"mach0: corrupted reserved2 value leads to int overflow.\\n\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tsymbol->offset = bin->sects[i].offset + delta;\n\t\t\t\tsymbol->addr = bin->sects[i].addr + delta;\n\t\t\t\tsymbol->size = 0;\n\t\t\t\tstridx = bin->symtab[idx].n_strx;\n\t\t\t\tif (stridx < bin->symstrlen) {\n\t\t\t\t\tsymstr = (char *)bin->symstr + stridx;\n\t\t\t\t} else {\n\t\t\t\t\tsymstr = \"???\";\n\t\t\t\t}\n\t\t\t\t// Remove the extra underscore that every import seems to have in Mach-O.\n\t\t\t\tif (*symstr == '_') {\n\t\t\t\t\tsymstr++;\n\t\t\t\t}\n\t\t\t\tsymbol->name = strdup (symstr);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\nstatic int inSymtab(HtPP *hash, const char *name, ut64 addr) {\n\tbool found = false;\n\tchar *key = r_str_newf (\"%\"PFMT64x\".%s\", addr, name);\n\tht_pp_find (hash, key, &found);\n\tif (found) {\n\t\tfree (key);\n\t\treturn true;\n\t}\n\tht_pp_insert (hash, key, \"1\");\n\tfree (key);\n\treturn false;\n}\n\nstatic char *get_name(struct MACH0_(obj_t) *mo, ut32 stridx, bool filter) {\n\tsize_t i = 0;\n\tif (!mo->symstr || stridx >= mo->symstrlen) {\n\t\treturn NULL;\n\t}\n\tint len = mo->symstrlen - stridx;\n\tconst char *symstr = (const char*)mo->symstr + stridx;\n\tfor (i = 0; i < len; i++) {\n\t\tif ((ut8)(symstr[i] & 0xff) == 0xff || !symstr[i]) {\n\t\t\tlen = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (len > 0) {\n\t\tchar *res = r_str_ndup (symstr, len);\n\t\tif (filter) {\n\t\t\tr_str_filter (res, -1);\n\t\t}\n\t\treturn res;\n\t}\n\treturn NULL;\n}\n\nstatic int walk_exports(struct MACH0_(obj_t) *bin, RExportsIterator iterator, void *ctx) {\n\tRList *states = NULL;\n\tr_return_val_if_fail (bin, 0);\n\tif (!bin->dyld_info) {\n\t\treturn 0;\n\t}\n\n\tsize_t count = 0;\n\tut8 *p = NULL;\n\tut64 size = bin->dyld_info->export_size;\n\tif (!size || size >= SIZE_MAX) {\n\t\treturn 0;\n\t}\n\tut8 *trie = calloc (size + 1, 1);\n\tif (!trie) {\n\t\treturn 0;\n\t}\n\tut8 *end = trie + size;\n\tif (r_buf_read_at (bin->b, bin->dyld_info->export_off, trie, bin->dyld_info->export_size) != size) {\n\t\tgoto beach;\n\t}\n\n\tstates = r_list_newf ((RListFree)free);\n\tif (!states) {\n\t\tgoto beach;\n\t}\n\n\tRTrieState *root = R_NEW0 (RTrieState);\n\tif (!root) {\n\t\tgoto beach;\n\t}\n\troot->node = trie;\n\troot->i = 0;\n\troot->label = NULL;\n\tr_list_push (states, root);\n\n\tdo {\n\t\tRTrieState * state = r_list_get_top (states);\n\t\tp = state->node;\n\t\tut64 len = read_uleb128 (&p, end);\n\t\tif (len == UT64_MAX) {\n\t\t\tbreak;\n\t\t}\n\t\tif (len) {\n\t\t\tut64 flags = read_uleb128 (&p, end);\n\t\t\tif (flags == UT64_MAX) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tut64 offset = read_uleb128 (&p, end);\n\t\t\tif (offset == UT64_MAX) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tut64 resolver = 0;\n\t\t\tbool isReexport = flags & EXPORT_SYMBOL_FLAGS_REEXPORT;\n\t\t\tbool hasResolver = flags & EXPORT_SYMBOL_FLAGS_STUB_AND_RESOLVER;\n\t\t\tif (hasResolver) {\n\t\t\t\tut64 res = read_uleb128 (&p, end);\n\t\t\t\tif (res == UT64_MAX) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tresolver = res + bin->header_at;\n\t\t\t} else if (isReexport) {\n\t\t\t\tp += strlen ((char*) p) + 1;\n\t\t\t\t// TODO: handle this\n\t\t\t}\n\t\t\tif (!isReexport) {\n\t\t\t\toffset += bin->header_at;\n\t\t\t}\n\t\t\tif (iterator && !isReexport) {\n\t\t\t\tchar * name = NULL;\n\t\t\t\tRListIter *iter;\n\t\t\t\tRTrieState *s;\n\t\t\t\tr_list_foreach (states, iter, s) {\n\t\t\t\t\tif (!s->label) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tname = r_str_append (name, s->label);\n\t\t\t\t}\n\t\t\t\tif (!name) {\n\t\t\t\t\tbprintf (\"malformed export trie %d\\n\", __LINE__);\n\t\t\t\t\tgoto beach;\n\t\t\t\t}\n\t\t\t\tif (hasResolver) {\n\t\t\t\t\tchar * stub_name = r_str_newf (\"stub.%s\", name);\n\t\t\t\t\titerator (bin, stub_name, flags, offset, ctx);\n\t\t\t\t\titerator (bin, name, flags, resolver, ctx);\n\t\t\t\t\tR_FREE (stub_name);\n\t\t\t\t} else {\n\t\t\t\t\titerator (bin, name, flags, offset, ctx);\n\t\t\t\t}\n\t\t\t\tR_FREE (name);\n\t\t\t}\n\t\t\tif (!isReexport) {\n\t\t\t\tif (hasResolver) {\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\tut64 child_count = read_uleb128 (&p, end);\n\t\tif (child_count == UT64_MAX) {\n\t\t\tgoto beach;\n\t\t}\n\t\tif (state->i == child_count) {\n\t\t\tfree (r_list_pop (states));\n\t\t\tcontinue;\n\t\t}\n\t\tif (!state->next_child) {\n\t\t\tstate->next_child = p;\n\t\t} else {\n\t\t\tp = state->next_child;\n\t\t}\n\t\tRTrieState * next = R_NEW0 (RTrieState);\n\t\tif (!next) {\n\t\t\tgoto beach;\n\t\t}\n\t\tnext->label = (char *) p;\n\t\tp += strlen (next->label) + 1;\n\t\tif (p >= end) {\n\t\t\tbprintf (\"malformed export trie %d\\n\", __LINE__);\n\t\t\tR_FREE (next);\n\t\t\tgoto beach;\n\t\t}\n\t\tut64 tr = read_uleb128 (&p, end);\n\t\tif (tr == UT64_MAX || tr >= size) {\n\t\t\tR_FREE (next);\n\t\t\tgoto beach;\n\t\t}\n\t\tnext->node = trie + (size_t)tr;\n\t\tif (next->node >= end) {\n\t\t\tbprintf (\"malformed export trie %d\\n\", __LINE__);\n\t\t\tR_FREE (next);\n\t\t\tgoto beach;\n\t\t}\n\t\t{\n\t\t\t// avoid loops\n\t\t\tRListIter *it;\n\t\t\tRTrieState *s;\n\t\t\tr_list_foreach (states, it, s) {\n\t\t\t\tif (s->node == next->node) {\n\t\t\t\t\tbprintf (\"malformed export trie %d\\n\", __LINE__);\n\t\t\t\t\tR_FREE (next);\n\t\t\t\t\tgoto beach;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tnext->i = 0;\n\t\tstate->i++;\n\t\tstate->next_child = p;\n\t\tr_list_push (states, next);\n\t} while (r_list_length (states));\n\nbeach:\n\tr_list_free (states);\n\tR_FREE (trie);\n\treturn count;\n}\n\nstatic void fill_exports_list(struct MACH0_(obj_t) *bin, const char *name, ut64 flags, ut64 offset, void *ctx) {\n\tRList *list = (RList*) ctx;\n\tRBinSymbol *sym = R_NEW0 (RBinSymbol);\n\tif (!sym) {\n\t\treturn;\n\t}\n\tsym->vaddr = offset_to_vaddr (bin, offset);\n\tsym->paddr = offset;\n\tsym->type = \"EXT\";\n\tsym->name = strdup (name);\n\tsym->bind = R_BIN_BIND_GLOBAL_STR;\n\tr_list_append (list, sym);\n}\n\n// TODO: Return RList<RBinSymbol> // 2x speedup\nconst RList *MACH0_(get_symbols_list)(struct MACH0_(obj_t) *bin) {\n\tstatic RList * cache = NULL; // XXX DONT COMMIT WITH THIS\n\tstruct symbol_t *symbols;\n\tsize_t j, s, symbols_size, symbols_count;\n\tut32 to, from;\n\tsize_t i;\n\n\tr_return_val_if_fail (bin, NULL);\n\tif (cache) {\n\t\treturn cache;\n\t}\n\tRList *list = r_list_newf ((RListFree)r_bin_symbol_free);\n\tcache = list;\n\n\tHtPP *hash = ht_pp_new0 ();\n\tif (!hash) {\n\t\treturn NULL;\n\t}\n\n\twalk_exports (bin, fill_exports_list, list);\n\tif (r_list_length (list)) {\n\t\tRListIter *it;\n\t\tRBinSymbol *s;\n\t\tr_list_foreach (list, it, s) {\n\t\t\tinSymtab (hash, s->name, s->vaddr);\n\t\t}\n\t}\n\n\tif (!bin->symtab || !bin->symstr) {\n\t\tht_pp_free (hash);\n\t\treturn list;\n\t}\n\t/* parse dynamic symbol table */\n\tsymbols_count = (bin->dysymtab.nextdefsym + \\\n\t\t\tbin->dysymtab.nlocalsym + \\\n\t\t\tbin->dysymtab.nundefsym );\n\tsymbols_count += bin->nsymtab;\n\tsymbols_size = (symbols_count + 1) * 2 * sizeof (struct symbol_t);\n\n\tif (symbols_size < 1 || !(symbols = calloc (1, symbols_size))) {\n\t\tht_pp_free (hash);\n\t\treturn NULL;\n\t}\n\tj = 0; // symbol_idx\n\tbin->main_addr = 0;\n\tint bits = MACH0_(get_bits_from_hdr) (&bin->hdr);\n\tfor (s = 0; s < 2; s++) {\n\t\tswitch (s) {\n\t\tcase 0:\n\t\t\tfrom = bin->dysymtab.iextdefsym;\n\t\t\tto = from + bin->dysymtab.nextdefsym;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tfrom = bin->dysymtab.ilocalsym;\n\t\t\tto = from + bin->dysymtab.nlocalsym;\n\t\t\tbreak;\n#if NOT_USED\n\t\tcase 2:\n\t\t\tfrom = bin->dysymtab.iundefsym;\n\t\t\tto = from + bin->dysymtab.nundefsym;\n\t\t\tbreak;\n#endif\n\t\t}\n\t\tif (from == to) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tfrom = R_MIN (from, symbols_size / sizeof (struct symbol_t));\n\t\tto = R_MIN (R_MIN (to, bin->nsymtab), symbols_size / sizeof (struct symbol_t));\n\n\t\tut32 maxsymbols = symbols_size / sizeof (struct symbol_t);\n\t\tif (symbols_count >= maxsymbols) {\n\t\t\tsymbols_count = maxsymbols - 1;\n\t\t\teprintf (\"macho warning: Symbol table truncated\\n\");\n\t\t}\n\t\tfor (i = from; i < to && j < symbols_count; i++, j++) {\n\t\t\tRBinSymbol *sym = R_NEW0 (RBinSymbol);\n\t\t\tsym->vaddr = bin->symtab[i].n_value;\n\t\t\tsym->paddr = addr_to_offset (bin, sym->vaddr);\n\t\t\tsymbols[j].size = 0; /* TODO: Is it anywhere? */\n\t\t\tsym->bits = bin->symtab[i].n_desc & N_ARM_THUMB_DEF ? 16 : bits;\n\n\t\t\tif (bin->symtab[i].n_type & N_EXT) {\n\t\t\t\tsym->type = \"EXT\";\n\t\t\t} else {\n\t\t\t\tsym->type = \"LOCAL\";\n\t\t\t}\n\t\t\tint stridx = bin->symtab[i].n_strx;\n\t\t\tchar *sym_name = get_name (bin, stridx, false);\n\t\t\tif (sym_name) {\n\t\t\t\tsym->name = sym_name;\n\t\t\t\tif (!bin->main_addr || bin->main_addr == UT64_MAX) {\n\t\t\t\t\tconst char *name = sym->name;\n\t\t\t\t\tif (!strcmp (name, \"__Dmain\")) {\n\t\t\t\t\t\tbin->main_addr = symbols[j].addr;\n\t\t\t\t\t} else if (strstr (name, \"4main\") && !strstr (name, \"STATIC\")) {\n\t\t\t\t\t\tbin->main_addr = symbols[j].addr;\n\t\t\t\t\t} else if (!strcmp (name, \"_main\")) {\n\t\t\t\t\t\tbin->main_addr = symbols[j].addr;\n\t\t\t\t\t} else if (!strcmp (name, \"main\")) {\n\t\t\t\t\t\tbin->main_addr = symbols[j].addr;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tsym->name = r_str_newf (\"unk%u\", (ut32)i);\n\t\t\t}\n\t\t\tif (!inSymtab (hash, sym->name, sym->vaddr)) {\n\t\t\t\tr_list_append (list, sym);\n\t\t\t} else {\n\t\t\t\tr_bin_symbol_free (sym);\n\t\t\t}\n\t\t}\n\t}\n\tto = R_MIN ((ut32)bin->nsymtab, bin->dysymtab.iundefsym + bin->dysymtab.nundefsym);\n\tfor (i = bin->dysymtab.iundefsym; i < to; i++) {\n\t\tstruct symbol_t symbol;\n\t\tif (j > symbols_count) {\n\t\t\tbprintf (\"mach0-get-symbols: error\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tif (parse_import_stub (bin, &symbol, i)) {\n\t\t\tj++;\n\t\t\tRBinSymbol *sym = R_NEW0 (RBinSymbol);\n\t\t\tsym->vaddr = symbol.addr;\n\t\t\tsym->paddr = symbol.offset;\n\t\t\tsym->name = symbol.name;\n\t\t\tif (!sym->name) {\n\t\t\t\tsym->name = r_str_newf (\"unk%u\", (ut32)i);\n\t\t\t}\n\t\t\tsym->is_imported = symbol.is_imported;\n\t\t\tr_list_append (list, sym);\n\t\t}\n\t}\n\n\tfor (i = 0; i < bin->nsymtab && i < symbols_count; i++) {\n\t\tstruct MACH0_(nlist) *st = &bin->symtab[i];\n\t\t// 0 is for imports\n\t\t// 1 is for symbols\n\t\t// 2 is for func.eh (exception handlers?)\n\t\tint section = st->n_sect;\n\t\tif (section == 1 && j < symbols_count) { // text ??st->n_type == 1) maybe wrong\n\t\t\tRBinSymbol *sym = R_NEW0(RBinSymbol);\n\t\t\t/* is symbol */\n\t\t\tsym->vaddr = st->n_value;\n\t\t\tsym->paddr = addr_to_offset (bin, symbols[j].addr);\n\t\t\tsym->is_imported = symbols[j].is_imported;\n\t\t\tif (st->n_type & N_EXT) {\n\t\t\t\tsym->type = \"EXT\";\n\t\t\t} else {\n\t\t\t\tsym->type = \"LOCAL\";\n\t\t\t}\n\t\t\tchar *sym_name = get_name (bin, st->n_strx, false);\n\t\t\tif (sym_name) {\n\t\t\t\tsym->name = sym_name;\n\t\t\t\tif (inSymtab (hash, sym->name, sym->vaddr)) {\n\t\t\t\t\tr_bin_symbol_free (sym);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (!bin->main_addr || bin->main_addr == UT64_MAX) {\n\t\t\t\t\tconst char *name = sym->name;\n\t\t\t\t\tif (!strcmp (name, \"__Dmain\")) {\n\t\t\t\t\t\tbin->main_addr = symbols[i].addr;\n\t\t\t\t\t} else if (strstr (name, \"4main\") && !strstr (name, \"STATIC\")) {\n\t\t\t\t\t\tbin->main_addr = symbols[i].addr;\n\t\t\t\t\t} else if (!strcmp (symbols[i].name, \"_main\")) {\n\t\t\t\t\t\tbin->main_addr = symbols[i].addr;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tsym->name = r_str_newf (\"unk%u\", (ut32)i);\n\t\t\t}\n\t\t\tr_list_append (list, sym);\n\t\t\tj++;\n\t\t}\n\t}\n\tht_pp_free (hash);\n\t// bin->symbols = symbols;\n    free (symbols);\n\treturn list;\n}\n\nstatic void assign_export_symbol_t(struct MACH0_(obj_t) *bin, const char *name, ut64 flags, ut64 offset, void *ctx) {\n\tRSymCtx *sym_ctx = (RSymCtx*) ctx;\n\tint j = sym_ctx->j;\n\tif (j < sym_ctx->symbols_count) {\n\t\tsym_ctx->symbols[j].offset = offset;\n\t\tsym_ctx->symbols[j].addr = offset_to_vaddr (bin, offset);\n\t\tif (inSymtab (sym_ctx->hash, name, sym_ctx->symbols[j].addr)) {\n\t\t\treturn;\n\t\t}\n\t\tsym_ctx->symbols[j].size = 0;\n\t\tsym_ctx->symbols[j].type = R_BIN_MACH0_SYMBOL_TYPE_EXT;\n\t\tsym_ctx->symbols[j].name = strdup (name);\n\t\tsym_ctx->j++;\n\t}\n}\n\nconst struct symbol_t *MACH0_(get_symbols)(struct MACH0_(obj_t) *bin) {\n\tstruct symbol_t *symbols;\n\tint j, s, stridx, symbols_size, symbols_count;\n\tut32 to, from, i;\n\n\tif (bin->symbols) {\n\t\treturn bin->symbols;\n\t}\n\n\tHtPP *hash = ht_pp_new0 ();\n\tif (!hash) {\n\t\treturn NULL;\n\t}\n\n\tr_return_val_if_fail (bin, NULL);\n\tint n_exports = walk_exports (bin, NULL, NULL);\n\n\tsymbols_count = n_exports;\n\tj = 0; // symbol_idx\n\n\tint bits = MACH0_(get_bits_from_hdr) (&bin->hdr);\n\tif (bin->symtab && bin->symstr) {\n\t\t/* parse dynamic symbol table */\n\t\tsymbols_count = (bin->dysymtab.nextdefsym + \\\n\t\t\t\tbin->dysymtab.nlocalsym + \\\n\t\t\t\tbin->dysymtab.nundefsym );\n\t\tsymbols_count += bin->nsymtab;\n\t\tif (symbols_count < 0 || ((st64)symbols_count * 2) > ST32_MAX) {\n\t\t\teprintf (\"Symbols count overflow\\n\");\n\t\t\tht_pp_free (hash);\n\t\t\treturn NULL;\n\t\t}\n\t\tsymbols_size = (symbols_count + 1) * 2 * sizeof (struct symbol_t);\n\n\t\tif (symbols_size < 1) {\n\t\t\tht_pp_free (hash);\n\t\t\treturn NULL;\n\t\t}\n\t\tif (!(symbols = calloc (1, symbols_size))) {\n\t\t\tht_pp_free (hash);\n\t\t\treturn NULL;\n\t\t}\n\t\tbin->main_addr = 0;\n\t\tfor (s = 0; s < 2; s++) {\n\t\t\tswitch (s) {\n\t\t\tcase 0:\n\t\t\t\tfrom = bin->dysymtab.iextdefsym;\n\t\t\t\tto = from + bin->dysymtab.nextdefsym;\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tfrom = bin->dysymtab.ilocalsym;\n\t\t\t\tto = from + bin->dysymtab.nlocalsym;\n\t\t\t\tbreak;\n#if NOT_USED\n\t\t\tcase 2:\n\t\t\t\tfrom = bin->dysymtab.iundefsym;\n\t\t\t\tto = from + bin->dysymtab.nundefsym;\n\t\t\t\tbreak;\n#endif\n\t\t\t}\n\t\t\tif (from == to) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfrom = R_MIN (from, symbols_size / sizeof (struct symbol_t));\n\t\t\tto = R_MIN (R_MIN (to, bin->nsymtab), symbols_size / sizeof (struct symbol_t));\n\n\t\t\tut32 maxsymbols = symbols_size / sizeof (struct symbol_t);\n\t\t\tif (symbols_count >= maxsymbols) {\n\t\t\t\tsymbols_count = maxsymbols - 1;\n\t\t\t\teprintf (\"macho warning: Symbol table truncated\\n\");\n\t\t\t}\n\t\t\tfor (i = from; i < to && j < symbols_count; i++, j++) {\n\t\t\t\tsymbols[j].offset = addr_to_offset (bin, bin->symtab[i].n_value);\n\t\t\t\tsymbols[j].addr = bin->symtab[i].n_value;\n\t\t\t\tsymbols[j].size = 0; /* TODO: Is it anywhere? */\n\t\t\t\tsymbols[j].bits = bin->symtab[i].n_desc & N_ARM_THUMB_DEF ? 16 : bits;\n\t\t\t\tsymbols[j].is_imported = false;\n\t\t\t\tsymbols[j].type = (bin->symtab[i].n_type & N_EXT)\n\t\t\t\t\t? R_BIN_MACH0_SYMBOL_TYPE_EXT\n\t\t\t\t\t: R_BIN_MACH0_SYMBOL_TYPE_LOCAL;\n\t\t\t\tstridx = bin->symtab[i].n_strx;\n\t\t\t\tsymbols[j].name = get_name (bin, stridx, false);\n\t\t\t\tsymbols[j].last = false;\n\n\t\t\t\tconst char *name = symbols[j].name;\n\t\t\t\tif (bin->main_addr == 0 && name) {\n\t\t\t\t\tif (!strcmp (name, \"__Dmain\")) {\n\t\t\t\t\t\tbin->main_addr = symbols[j].addr;\n\t\t\t\t\t} else if (strstr (name, \"4main\") && !strstr (name, \"STATIC\")) {\n\t\t\t\t\t\tbin->main_addr = symbols[j].addr;\n\t\t\t\t\t} else if (!strcmp (name, \"_main\")) {\n\t\t\t\t\t\tbin->main_addr = symbols[j].addr;\n\t\t\t\t\t} else if (!strcmp (name, \"main\")) {\n\t\t\t\t\t\tbin->main_addr = symbols[j].addr;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (inSymtab (hash, symbols[j].name, symbols[j].addr)) {\n\t\t\t\t\tfree (symbols[j].name);\n\t\t\t\t\tsymbols[j].name = NULL;\n\t\t\t\t\tj--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tto = R_MIN ((ut32)bin->nsymtab, bin->dysymtab.iundefsym + bin->dysymtab.nundefsym);\n\t\tfor (i = bin->dysymtab.iundefsym; i < to; i++) {\n\t\t\tif (j > symbols_count) {\n\t\t\t\tbprintf (\"mach0-get-symbols: error\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (parse_import_stub (bin, &symbols[j], i)) {\n\t\t\t\tsymbols[j++].last = false;\n\t\t\t}\n\t\t}\n\n\t\tfor (i = 0; i < bin->nsymtab; i++) {\n\t\t\tstruct MACH0_(nlist) *st = &bin->symtab[i];\n\t\t\tif (st->n_type & N_STAB) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t// 0 is for imports\n\t\t\t// 1 is for symbols\n\t\t\t// 2 is for func.eh (exception handlers?)\n\t\t\tint section = st->n_sect;\n\t\t\tif (section == 1 && j < symbols_count) {\n\t\t\t\t// check if symbol exists already\n\t\t\t\t/* is symbol */\n\t\t\t\tsymbols[j].addr = st->n_value;\n\t\t\t\tsymbols[j].offset = addr_to_offset (bin, symbols[j].addr);\n\t\t\t\tsymbols[j].size = 0; /* find next symbol and crop */\n\t\t\t\tsymbols[j].type = (st->n_type & N_EXT)\n\t\t\t\t\t? R_BIN_MACH0_SYMBOL_TYPE_EXT\n\t\t\t\t\t: R_BIN_MACH0_SYMBOL_TYPE_LOCAL;\n\t\t\t\tchar *sym_name = get_name (bin, st->n_strx, false);\n\t\t\t\tif (sym_name) {\n\t\t\t\t\tsymbols[j].name = sym_name;\n\t\t\t\t} else {\n\t\t\t\t\tsymbols[j].name = r_str_newf (\"entry%d\", i);\n\t\t\t\t}\n\t\t\t\tsymbols[j].last = 0;\n\t\t\t\tif (inSymtab (hash, symbols[j].name, symbols[j].addr)) {\n\t\t\t\t\tR_FREE (symbols[j].name);\n\t\t\t\t} else {\n\t\t\t\t\tj++;\n\t\t\t\t}\n\n\t\t\t\tconst char *name = symbols[i].name;\n\t\t\t\tif (bin->main_addr == 0 && name) {\n\t\t\t\t\tif (name && !strcmp (name, \"__Dmain\")) {\n\t\t\t\t\t\tbin->main_addr = symbols[i].addr;\n\t\t\t\t\t} else if (name && strstr (name, \"4main\") && !strstr (name, \"STATIC\")) {\n\t\t\t\t\t\tbin->main_addr = symbols[i].addr;\n\t\t\t\t\t} else if (symbols[i].name && !strcmp (symbols[i].name, \"_main\")) {\n\t\t\t\t\t\tbin->main_addr = symbols[i].addr;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else if (!n_exports) {\n\t\tht_pp_free (hash);\n\t\treturn NULL;\n\t} else {\n\t\tsymbols_size = (symbols_count + 1) * sizeof (struct symbol_t);\n\t\tif (symbols_size < 1) {\n\t\t\tht_pp_free (hash);\n\t\t\treturn NULL;\n\t\t}\n\t\tif (!(symbols = calloc (1, symbols_size))) {\n\t\t\tht_pp_free (hash);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\tif (n_exports && (symbols_count - j) >= n_exports) {\n\t\tRSymCtx sym_ctx;\n\t\tsym_ctx.symbols = symbols;\n\t\tsym_ctx.j = j;\n\t\tsym_ctx.symbols_count = symbols_count;\n\t\tsym_ctx.hash = hash;\n\t\twalk_exports (bin, assign_export_symbol_t, &sym_ctx);\n\t\tj = sym_ctx.j;\n\t}\n\tht_pp_free (hash);\n\tsymbols[j].last = true;\n\tbin->symbols = symbols;\n\treturn symbols;\n}\n\nstatic int parse_import_ptr(struct MACH0_(obj_t) *bin, struct reloc_t *reloc, int idx) {\n\tint i, j, sym;\n\tsize_t wordsize;\n\tut32 stype;\n\twordsize = get_word_size (bin);\n\tif (idx < 0 || idx >= bin->nsymtab) {\n\t\treturn 0;\n\t}\n\tif ((bin->symtab[idx].n_desc & REFERENCE_TYPE) == REFERENCE_FLAG_UNDEFINED_LAZY) {\n\t\tstype = S_LAZY_SYMBOL_POINTERS;\n\t} else {\n\t\tstype = S_NON_LAZY_SYMBOL_POINTERS;\n\t}\n\n\treloc->offset = 0;\n\treloc->addr = 0;\n\treloc->addend = 0;\n#define CASE(T) case ((T) / 8): reloc->type = R_BIN_RELOC_ ## T; break\n\tswitch (wordsize) {\n\tCASE(8);\n\tCASE(16);\n\tCASE(32);\n\tCASE(64);\n\tdefault: return false;\n\t}\n#undef CASE\n\n\tfor (i = 0; i < bin->nsects; i++) {\n\t\tif ((bin->sects[i].flags & SECTION_TYPE) == stype) {\n\t\t\tfor (j = 0, sym = -1; bin->sects[i].reserved1 + j < bin->nindirectsyms; j++) {\n\t\t\t\tint indidx = bin->sects[i].reserved1 + j;\n\t\t\t\tif (indidx < 0 || indidx >= bin->nindirectsyms) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (idx == bin->indirectsyms[indidx]) {\n\t\t\t\t\tsym = j;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\treloc->offset = sym == -1 ? 0 : bin->sects[i].offset + sym * wordsize;\n\t\t\treloc->addr = sym == -1 ? 0 : bin->sects[i].addr + sym * wordsize;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nstruct import_t *MACH0_(get_imports)(struct MACH0_(obj_t) *bin) {\n\tr_return_val_if_fail (bin, NULL);\n\n\tint i, j, idx, stridx;\n\tif (!bin->sects || !bin->symtab || !bin->symstr || !bin->indirectsyms) {\n\t\treturn NULL;\n\t}\n\n\tif (bin->dysymtab.nundefsym < 1 || bin->dysymtab.nundefsym > 0xfffff) {\n\t\treturn NULL;\n\t}\n\n\tstruct import_t *imports = calloc (bin->dysymtab.nundefsym + 1, sizeof (struct import_t));\n\tif (!imports) {\n\t\treturn NULL;\n\t}\n\tfor (i = j = 0; i < bin->dysymtab.nundefsym; i++) {\n\t\tidx = bin->dysymtab.iundefsym + i;\n\t\tif (idx < 0 || idx >= bin->nsymtab) {\n\t\t\tbprintf (\"WARNING: Imports index out of bounds. Ignoring relocs\\n\");\n\t\t\tfree (imports);\n\t\t\treturn NULL;\n\t\t}\n\t\tstridx = bin->symtab[idx].n_strx;\n\t\tchar *imp_name = get_name (bin, stridx, false);\n\t\tif (imp_name) {\n\t\t\tr_str_ncpy (imports[j].name, imp_name, R_BIN_MACH0_STRING_LENGTH - 1);\n\t\t\tfree (imp_name);\n\t\t} else {\n\t\t\t//imports[j].name[0] = 0;\n\t\t\tcontinue;\n\t\t}\n\t\timports[j].ord = i;\n\t\timports[j++].last = 0;\n\t}\n\timports[j].last = 1;\n\n\tif (!bin->imports_by_ord_size) {\n\t\tif (j > 0) {\n\t\t\tbin->imports_by_ord_size = j;\n\t\t\tbin->imports_by_ord = (RBinImport**)calloc (j, sizeof (RBinImport*));\n\t\t} else {\n\t\t\tbin->imports_by_ord_size = 0;\n\t\t\tbin->imports_by_ord = NULL;\n\t\t}\n\t}\n\n\treturn imports;\n}\n\nstatic int reloc_comparator(struct reloc_t *a, struct reloc_t *b) {\n\treturn a->addr - b->addr;\n}\n\nstatic void parse_relocation_info(struct MACH0_(obj_t) *bin, RSkipList *relocs, ut32 offset, ut32 num) {\n\tif (!num || !offset || (st32)num < 0) {\n\t\treturn;\n\t}\n\n\tut64 total_size = num * sizeof (struct relocation_info);\n\tif (offset > bin->size) {\n\t\treturn;\n\t}\n\tif (total_size > bin->size) {\n\t\ttotal_size = bin->size - offset;\n\t\tnum = total_size /= sizeof (struct relocation_info);\n\t}\n\tstruct relocation_info *info = calloc (num, sizeof (struct relocation_info));\n\tif (!info) {\n\t\treturn;\n\t}\n\n\tif (r_buf_read_at (bin->b, offset, (ut8 *) info, total_size) < total_size) {\n\t\tfree (info);\n\t\treturn;\n\t}\n\n\tsize_t i;\n\tfor (i = 0; i < num; i++) {\n\t\tstruct relocation_info a_info = info[i];\n\t\tut32 sym_num = a_info.r_symbolnum;\n\t\tif (sym_num >= bin->nsymtab) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tut32 stridx = bin->symtab[sym_num].n_strx;\n\t\tchar *sym_name = get_name (bin, stridx, false);\n\t\tif (!sym_name) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tstruct reloc_t *reloc = R_NEW0 (struct reloc_t);\n\t\tif (!reloc) {\n\t\t\tfree (info);\n\t\t\tfree (sym_name);\n\t\t\treturn;\n\t\t}\n\n\t\treloc->addr = offset_to_vaddr (bin, a_info.r_address);\n\t\treloc->offset = a_info.r_address;\n\t\treloc->ord = sym_num;\n\t\treloc->type = a_info.r_type; // enum RelocationInfoType\n\t\treloc->external = a_info.r_extern;\n\t\treloc->pc_relative = a_info.r_pcrel;\n\t\treloc->size = a_info.r_length;\n\t\tr_str_ncpy (reloc->name, sym_name, sizeof (reloc->name) - 1);\n\t\tr_skiplist_insert (relocs, reloc);\n\t\tfree (sym_name);\n\t}\n\tfree (info);\n}\n\nstatic bool walk_bind_chains_callback(void * context, RFixupEventDetails * event_details) {\n\tr_return_val_if_fail (event_details->type == R_FIXUP_EVENT_BIND || event_details->type == R_FIXUP_EVENT_BIND_AUTH, false);\n\tRWalkBindChainsContext *ctx = context;\n\tut8 *imports = ctx->imports;\n\tstruct MACH0_(obj_t) *bin = event_details->bin;\n\tut32 imports_count = bin->fixups_header.imports_count;\n\tut32 fixups_offset = bin->fixups_offset;\n\tut32 fixups_size = bin->fixups_size;\n\tut32 imports_format = bin->fixups_header.imports_format;\n\tut32 import_index = ((RFixupBindEventDetails *) event_details)->ordinal;\n\tut64 addend = 0;\n\tif (event_details->type != R_FIXUP_EVENT_BIND_AUTH) {\n\t\taddend = ((RFixupBindEventDetails *) event_details)->addend;\n\t}\n\n\tif (import_index < imports_count) {\n\t\tut64 name_offset;\n\t\tswitch (imports_format) {\n\t\t\tcase DYLD_CHAINED_IMPORT: {\n\t\t\t\tstruct dyld_chained_import * item = &((struct dyld_chained_import *) imports)[import_index];\n\t\t\t\tname_offset = item->name_offset;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase DYLD_CHAINED_IMPORT_ADDEND: {\n\t\t\t\tstruct dyld_chained_import_addend * item = &((struct dyld_chained_import_addend *) imports)[import_index];\n\t\t\t\tname_offset = item->name_offset;\n\t\t\t\taddend += item->addend;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase DYLD_CHAINED_IMPORT_ADDEND64: {\n\t\t\t\tstruct dyld_chained_import_addend64 * item = &((struct dyld_chained_import_addend64 *) imports)[import_index];\n\t\t\t\tname_offset = item->name_offset;\n\t\t\t\taddend += item->addend;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdefault:\n\t\t\t\tbprintf (\"Unsupported imports format\\n\");\n\t\t\t\treturn false;\n\t\t}\n\n\t\tut64 symbols_offset = bin->fixups_header.symbols_offset + fixups_offset;\n\n\t\tif (symbols_offset + name_offset + 1 < fixups_offset + fixups_size) {\n\t\t\tchar *name = r_buf_get_string (bin->b, symbols_offset + name_offset);\n\t\t\tif (name) {\n\t\t\t\tstruct reloc_t *reloc = R_NEW0 (struct reloc_t);\n\t\t\t\tif (!reloc) {\n\t\t\t\t\tfree (name);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\treloc->addr = offset_to_vaddr (bin, event_details->offset);\n\t\t\t\treloc->offset = event_details->offset;\n\t\t\t\treloc->ord = import_index;\n\t\t\t\treloc->type = R_BIN_RELOC_64;\n\t\t\t\treloc->size = 8;\n\t\t\t\treloc->addend = addend;\n\t\t\t\tr_str_ncpy (reloc->name, name, sizeof (reloc->name) - 1);\n\t\t\t\tr_skiplist_insert_autofree (ctx->relocs, reloc);\n\t\t\t\tfree (name);\n\t\t\t} else if (bin->verbose) {\n\t\t\t\teprintf (\"Malformed chained bind: failed to read name\\n\");\n\t\t\t}\n\t\t} else if (bin->verbose) {\n\t\t\teprintf (\"Malformed chained bind: name_offset out of bounds\\n\");\n\t\t}\n\t} else if (bin->verbose) {\n\t\teprintf (\"Malformed chained bind: import out of length\\n\");\n\t}\n\n\treturn true;\n}\n\nstatic void walk_bind_chains(struct MACH0_(obj_t) *bin, RSkipList *relocs) {\n\tr_return_if_fail (bin && bin->fixups_offset);\n\n\tut8 *imports = NULL;\n\n\tut32 imports_count = bin->fixups_header.imports_count;\n\tut32 fixups_offset = bin->fixups_offset;\n\tut32 imports_offset = bin->fixups_header.imports_offset;\n\tif (!imports_count || !imports_offset) {\n\t\treturn;\n\t}\n\tif (bin->fixups_header.symbols_format != 0) {\n\t\teprintf (\"Compressed fixups symbols not supported yet, please file a bug with a sample attached.\\n\");\n\t\treturn;\n\t}\n\n\tut32 imports_format = bin->fixups_header.imports_format;\n\tut64 imports_size;\n\tswitch (imports_format) {\n\t\tcase DYLD_CHAINED_IMPORT:\n\t\t\timports_size = sizeof (struct dyld_chained_import) * imports_count;\n\t\t\tbreak;\n\t\tcase DYLD_CHAINED_IMPORT_ADDEND:\n\t\t\timports_size = sizeof (struct dyld_chained_import_addend) * imports_count;\n\t\t\tbreak;\n\t\tcase DYLD_CHAINED_IMPORT_ADDEND64:\n\t\t\timports_size = sizeof (struct dyld_chained_import_addend64) * imports_count;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\teprintf (\"Unsupported chained imports format: %d\\n\", imports_format);\n\t\t\tgoto beach;\n\t}\n\n\timports = malloc (imports_size);\n\tif (!imports) {\n\t\tgoto beach;\n\t}\n\n\tswitch (imports_format) {\n\t\tcase DYLD_CHAINED_IMPORT:\n\t\t\tif (r_buf_fread_at (bin->b, fixups_offset + imports_offset,\n\t\t\t\t\timports, \"i\", imports_count) != imports_size) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase DYLD_CHAINED_IMPORT_ADDEND:\n\t\t\tif (r_buf_fread_at (bin->b, fixups_offset + imports_offset,\n\t\t\t\t\timports, \"ii\", imports_count) != imports_size) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase DYLD_CHAINED_IMPORT_ADDEND64:\n\t\t\tif (r_buf_fread_at (bin->b, fixups_offset + imports_offset,\n\t\t\t\t\timports, \"il\", imports_count) != imports_size) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tbreak;\n\t}\n\n\tRWalkBindChainsContext ctx;\n\tctx.imports = imports;\n\tctx.relocs = relocs;\n\n\tMACH0_(iterate_chained_fixups) (bin, 0, UT64_MAX, R_FIXUP_EVENT_MASK_BIND_ALL, &walk_bind_chains_callback, &ctx);\n\nbeach:\n\tfree (imports);\n}\n\nstatic bool is_valid_ordinal_table_size(ut64 size) {\n\treturn size > 0 && size <= UT16_MAX;\n}\n\nRSkipList *MACH0_(get_relocs)(struct MACH0_(obj_t) *bin) {\n\tRSkipList *relocs = NULL;\n\tRPVector *threaded_binds = NULL;\n\tsize_t wordsize = get_word_size (bin);\n\tif (bin->dyld_info) {\n\t\tut8 *opcodes, rel_type = 0;\n\t\tsize_t bind_size, lazy_size, weak_size;\n\n#define CASE(T) case ((T) / 8): rel_type = R_BIN_RELOC_ ## T; break\n\t\tswitch (wordsize) {\n\t\tCASE(8);\n\t\tCASE(16);\n\t\tCASE(32);\n\t\tCASE(64);\n\t\tdefault: return NULL;\n\t\t}\n#undef CASE\n\t\tbind_size = bin->dyld_info->bind_size;\n\t\tlazy_size = bin->dyld_info->lazy_bind_size;\n\t\tweak_size = bin->dyld_info->weak_bind_size;\n\n\t\tif (!bind_size && !lazy_size) {\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif ((bind_size + lazy_size)<1) {\n\t\t\treturn NULL;\n\t\t}\n\t\tif (bin->dyld_info->bind_off > bin->size || bin->dyld_info->bind_off + bind_size > bin->size) {\n\t\t\treturn NULL;\n\t\t}\n\t\tif (bin->dyld_info->lazy_bind_off > bin->size || \\\n\t\t\tbin->dyld_info->lazy_bind_off + lazy_size > bin->size) {\n\t\t\treturn NULL;\n\t\t}\n\t\tif (bin->dyld_info->bind_off + bind_size + lazy_size > bin->size) {\n\t\t\treturn NULL;\n\t\t}\n\t\tif (bin->dyld_info->weak_bind_off + weak_size > bin->size) {\n\t\t\treturn NULL;\n\t\t}\n\t\tut64 amount = bind_size + lazy_size + weak_size;\n\t\tif (amount == 0 || amount > UT32_MAX) {\n\t\t\treturn NULL;\n\t\t}\n\t\tif (!bin->segs) {\n\t\t\treturn NULL;\n\t\t}\n\t\trelocs = r_skiplist_new ((RListFree) &free, (RListComparator) &reloc_comparator);\n\t\tif (!relocs) {\n\t\t\treturn NULL;\n\t\t}\n\t\topcodes = calloc (1, amount + 1);\n\t\tif (!opcodes) {\n\t\t\tr_skiplist_free (relocs);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tint len = r_buf_read_at (bin->b, bin->dyld_info->bind_off, opcodes, bind_size);\n\t\tlen += r_buf_read_at (bin->b, bin->dyld_info->lazy_bind_off, opcodes + bind_size, lazy_size);\n\t\tlen += r_buf_read_at (bin->b, bin->dyld_info->weak_bind_off, opcodes + bind_size + lazy_size, weak_size);\n\t\tif (len < amount) {\n\t\t\tbprintf (\"Error: read (dyld_info bind) at 0x%08\"PFMT64x\"\\n\", (ut64)(size_t)bin->dyld_info->bind_off);\n\t\t\tR_FREE (opcodes);\n\t\t\tr_skiplist_free (relocs);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tsize_t partition_sizes[] = {bind_size, lazy_size, weak_size};\n\t\tsize_t pidx;\n\t\tint opcodes_offset = 0;\n\t\tfor (pidx = 0; pidx < R_ARRAY_SIZE (partition_sizes); pidx++) {\n\t\t\tsize_t partition_size = partition_sizes[pidx];\n\n\t\t\tut8 type = 0;\n\t\t\tint lib_ord = 0, seg_idx = -1, sym_ord = -1;\n\t\t\tchar *sym_name = NULL;\n\t\t\tsize_t j, count, skip;\n\t\t\tst64 addend = 0;\n\t\t\tut64 addr = bin->segs[0].vmaddr;\n\t\t\tut64 segment_size = bin->segs[0].filesize;\n\t\t\tif (bin->segs[0].filesize != bin->segs[0].vmsize) {\n\t\t\t\t// is probably invalid and we should warn the user\n\t\t\t}\n\t\t\tif (segment_size > bin->size) {\n\t\t\t\t// is probably invalid and we should warn the user\n\t\t\t\tsegment_size = bin->size;\n\t\t\t}\n\t\t\tut64 segment_end_addr = addr + segment_size;\n\n\t\t\tut8 *p = opcodes + opcodes_offset;\n\t\t\tut8 *end = p + partition_size;\n\t\t\tbool done = false;\n\t\t\twhile (!done && p < end) {\n\t\t\t\tut8 imm = *p & BIND_IMMEDIATE_MASK;\n\t\t\t\tut8 op = *p & BIND_OPCODE_MASK;\n\t\t\t\tp++;\n\t\t\t\tswitch (op) {\n\t\t\t\tcase BIND_OPCODE_DONE: {\n\t\t\t\t\tbool in_lazy_binds = pidx == 1;\n\t\t\t\t\tif (!in_lazy_binds) {\n\t\t\t\t\t\tdone = true;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase BIND_OPCODE_THREADED: {\n\t\t\t\t\tswitch (imm) {\n\t\t\t\t\tcase BIND_SUBOPCODE_THREADED_SET_BIND_ORDINAL_TABLE_SIZE_ULEB: {\n\t\t\t\t\t\tut64 table_size = read_uleb128 (&p, end);\n\t\t\t\t\t\tif (!is_valid_ordinal_table_size (table_size)) {\n\t\t\t\t\t\t\tbprintf (\"Error: BIND_SUBOPCODE_THREADED_SET_BIND_ORDINAL_TABLE_SIZE_ULEB size is wrong\\n\");\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (threaded_binds) {\n\t\t\t\t\t\t\tr_pvector_free (threaded_binds);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthreaded_binds = r_pvector_new_with_len ((RPVectorFree) &free, table_size);\n\t\t\t\t\t\tif (threaded_binds) {\n\t\t\t\t\t\t\tsym_ord = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcase BIND_SUBOPCODE_THREADED_APPLY:\n\t\t\t\t\t\tif (threaded_binds) {\n\t\t\t\t\t\t\tint cur_seg_idx = (seg_idx != -1)? seg_idx: 0;\n\t\t\t\t\t\t\tsize_t n_threaded_binds = r_pvector_len (threaded_binds);\n\t\t\t\t\t\t\twhile (addr < segment_end_addr) {\n\t\t\t\t\t\t\t\tut8 tmp[8];\n\t\t\t\t\t\t\t\tut64 paddr = addr - bin->segs[cur_seg_idx].vmaddr + bin->segs[cur_seg_idx].fileoff;\n\t\t\t\t\t\t\t\tbin->rebasing_buffer = true;\n\t\t\t\t\t\t\t\tif (r_buf_read_at (bin->b, paddr, tmp, 8) != 8) {\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbin->rebasing_buffer = false;\n\t\t\t\t\t\t\t\tut64 raw_ptr = r_read_le64 (tmp);\n\t\t\t\t\t\t\t\tbool is_auth = (raw_ptr & (1ULL << 63)) != 0;\n\t\t\t\t\t\t\t\tbool is_bind = (raw_ptr & (1ULL << 62)) != 0;\n\t\t\t\t\t\t\t\tint ordinal = -1;\n\t\t\t\t\t\t\t\tint addend = -1;\n\t\t\t\t\t\t\t\tut64 delta;\n\t\t\t\t\t\t\t\tif (is_auth && is_bind) {\n\t\t\t\t\t\t\t\t\tstruct dyld_chained_ptr_arm64e_auth_bind *p =\n\t\t\t\t\t\t\t\t\t\t\t(struct dyld_chained_ptr_arm64e_auth_bind *) &raw_ptr;\n\t\t\t\t\t\t\t\t\tdelta = p->next;\n\t\t\t\t\t\t\t\t\tordinal = p->ordinal;\n\t\t\t\t\t\t\t\t} else if (!is_auth && is_bind) {\n\t\t\t\t\t\t\t\t\tstruct dyld_chained_ptr_arm64e_bind *p =\n\t\t\t\t\t\t\t\t\t\t\t(struct dyld_chained_ptr_arm64e_bind *) &raw_ptr;\n\t\t\t\t\t\t\t\t\tdelta = p->next;\n\t\t\t\t\t\t\t\t\tordinal = p->ordinal;\n\t\t\t\t\t\t\t\t\taddend = p->addend;\n\t\t\t\t\t\t\t\t} else if (is_auth && !is_bind) {\n\t\t\t\t\t\t\t\t\tstruct dyld_chained_ptr_arm64e_auth_rebase *p =\n\t\t\t\t\t\t\t\t\t\t\t(struct dyld_chained_ptr_arm64e_auth_rebase *) &raw_ptr;\n\t\t\t\t\t\t\t\t\tdelta = p->next;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tstruct dyld_chained_ptr_arm64e_rebase *p =\n\t\t\t\t\t\t\t\t\t\t\t(struct dyld_chained_ptr_arm64e_rebase *) &raw_ptr;\n\t\t\t\t\t\t\t\t\tdelta = p->next;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (ordinal != -1) {\n\t\t\t\t\t\t\t\t\tif (ordinal >= n_threaded_binds) {\n\t\t\t\t\t\t\t\t\t\tbprintf (\"Error: Malformed bind chain\\n\");\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tstruct reloc_t *ref = r_pvector_at (threaded_binds, ordinal);\n\t\t\t\t\t\t\t\t\tif (!ref) {\n\t\t\t\t\t\t\t\t\t\tbprintf (\"Error: Inconsistent bind opcodes\\n\");\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tstruct reloc_t *reloc = R_NEW0 (struct reloc_t);\n\t\t\t\t\t\t\t\t\tif (!reloc) {\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t*reloc = *ref;\n\t\t\t\t\t\t\t\t\treloc->addr = addr;\n\t\t\t\t\t\t\t\t\treloc->offset = paddr;\n\t\t\t\t\t\t\t\t\tif (addend != -1) {\n\t\t\t\t\t\t\t\t\t\treloc->addend = addend;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tr_skiplist_insert (relocs, reloc);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\taddr += delta * wordsize;\n\t\t\t\t\t\t\t\tif (!delta) {\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tbprintf (\"Error: Unexpected BIND_OPCODE_THREADED sub-opcode: 0x%x\\n\", imm);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase BIND_OPCODE_SET_DYLIB_ORDINAL_IMM:\n\t\t\t\t\tlib_ord = imm;\n\t\t\t\t\tbreak;\n\t\t\t\tcase BIND_OPCODE_SET_DYLIB_ORDINAL_ULEB:\n\t\t\t\t\tlib_ord = read_uleb128 (&p, end);\n\t\t\t\t\tbreak;\n\t\t\t\tcase BIND_OPCODE_SET_DYLIB_SPECIAL_IMM:\n\t\t\t\t\tlib_ord = imm? (st8)(BIND_OPCODE_MASK | imm) : 0;\n\t\t\t\t\tbreak;\n\t\t\t\tcase BIND_OPCODE_SET_SYMBOL_TRAILING_FLAGS_IMM: {\n\t\t\t\t\tsym_name = (char*)p;\n\t\t\t\t\twhile (*p++ && p < end) {\n\t\t\t\t\t\t/* empty loop */\n\t\t\t\t\t}\n\t\t\t\t\tif (threaded_binds) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tsym_ord = -1;\n\t\t\t\t\tif (bin->symtab && bin->dysymtab.nundefsym < UT16_MAX) {\n\t\t\t\t\t\tfor (j = 0; j < bin->dysymtab.nundefsym; j++) {\n\t\t\t\t\t\t\tsize_t stridx = 0;\n\t\t\t\t\t\t\tbool found = false;\n\t\t\t\t\t\t\tint iundefsym = bin->dysymtab.iundefsym;\n\t\t\t\t\t\t\tif (iundefsym >= 0 && iundefsym < bin->nsymtab) {\n\t\t\t\t\t\t\t\tint sidx = iundefsym + j;\n\t\t\t\t\t\t\t\tif (sidx < 0 || sidx >= bin->nsymtab) {\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tstridx = bin->symtab[sidx].n_strx;\n\t\t\t\t\t\t\t\tif (stridx >= bin->symstrlen) {\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (found && !strcmp ((const char *)bin->symstr + stridx, sym_name)) {\n\t\t\t\t\t\t\t\tsym_ord = j;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase BIND_OPCODE_SET_TYPE_IMM:\n\t\t\t\t\ttype = imm;\n\t\t\t\t\tbreak;\n\t\t\t\tcase BIND_OPCODE_SET_ADDEND_SLEB:\n\t\t\t\t\taddend = r_sleb128 ((const ut8 **)&p, end);\n\t\t\t\t\tbreak;\n\t\t\t\tcase BIND_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB:\n\t\t\t\t\tseg_idx = imm;\n\t\t\t\t\tif (seg_idx >= bin->nsegs) {\n\t\t\t\t\t\tbprintf (\"Error: BIND_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB\"\n\t\t\t\t\t\t\t\" has unexistent segment %d\\n\", seg_idx);\n\t\t\t\t\t\tfree (opcodes);\n\t\t\t\t\t\tr_skiplist_free (relocs);\n\t\t\t\t\t\tr_pvector_free (threaded_binds);\n\t\t\t\t\t\treturn NULL; // early exit to avoid future mayhem\n\t\t\t\t\t}\n\t\t\t\t\taddr = bin->segs[seg_idx].vmaddr + read_uleb128 (&p, end);\n\t\t\t\t\tsegment_end_addr = bin->segs[seg_idx].vmaddr \\\n\t\t\t\t\t\t\t+ bin->segs[seg_idx].vmsize;\n\t\t\t\t\tbreak;\n\t\t\t\tcase BIND_OPCODE_ADD_ADDR_ULEB:\n\t\t\t\t\taddr += read_uleb128 (&p, end);\n\t\t\t\t\tbreak;\n#define DO_BIND() do {\\\n\tif (sym_ord < 0 && !sym_name) break;\\\n\tif (!threaded_binds) {\\\n\t\tif (seg_idx < 0 ) break;\\\n\t\tif (!addr) break;\\\n\t}\\\n\tstruct reloc_t *reloc = R_NEW0 (struct reloc_t);\\\n\treloc->addr = addr;\\\n\tif (seg_idx >= 0) {\\\n\t\treloc->offset = addr - bin->segs[seg_idx].vmaddr + bin->segs[seg_idx].fileoff;\\\n\t\tif (type == BIND_TYPE_TEXT_PCREL32)\\\n\t\t\treloc->addend = addend - (bin->baddr + addr);\\\n\t\telse\\\n\t\t\treloc->addend = addend;\\\n\t} else {\\\n\t\treloc->addend = addend;\\\n\t}\\\n\t/* library ordinal ??? */ \\\n\treloc->ord = lib_ord;\\\n\treloc->ord = sym_ord;\\\n\treloc->type = rel_type;\\\n\tif (sym_name)\\\n\t\tr_str_ncpy (reloc->name, sym_name, 256);\\\n\tif (threaded_binds)\\\n\t\tr_pvector_set (threaded_binds, sym_ord, reloc);\\\n\telse\\\n\t\tr_skiplist_insert (relocs, reloc);\\\n} while (0)\n\t\t\t\tcase BIND_OPCODE_DO_BIND:\n\t\t\t\t\tif (!threaded_binds && addr >= segment_end_addr) {\n\t\t\t\t\t\tbprintf (\"Error: Malformed DO bind opcode 0x%\"PFMT64x\"\\n\", addr);\n\t\t\t\t\t\tgoto beach;\n\t\t\t\t\t}\n\t\t\t\t\tDO_BIND ();\n\t\t\t\t\tif (!threaded_binds) {\n\t\t\t\t\t\taddr += wordsize;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsym_ord++;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase BIND_OPCODE_DO_BIND_ADD_ADDR_ULEB:\n\t\t\t\t\tif (addr >= segment_end_addr) {\n\t\t\t\t\t\tbprintf (\"Error: Malformed ADDR ULEB bind opcode\\n\");\n\t\t\t\t\t\tgoto beach;\n\t\t\t\t\t}\n\t\t\t\t\tDO_BIND ();\n\t\t\t\t\taddr += read_uleb128 (&p, end) + wordsize;\n\t\t\t\t\tbreak;\n\t\t\t\tcase BIND_OPCODE_DO_BIND_ADD_ADDR_IMM_SCALED:\n\t\t\t\t\tif (addr >= segment_end_addr) {\n\t\t\t\t\t\tbprintf (\"Error: Malformed IMM SCALED bind opcode\\n\");\n\t\t\t\t\t\tgoto beach;\n\t\t\t\t\t}\n\t\t\t\t\tDO_BIND ();\n\t\t\t\t\taddr += (ut64)imm * (ut64)wordsize + wordsize;\n\t\t\t\t\tbreak;\n\t\t\t\tcase BIND_OPCODE_DO_BIND_ULEB_TIMES_SKIPPING_ULEB:\n\t\t\t\t\tcount = read_uleb128 (&p, end);\n\t\t\t\t\tskip = read_uleb128 (&p, end);\n\t\t\t\t\tfor (j = 0; j < count; j++) {\n\t\t\t\t\t\tif (addr >= segment_end_addr) {\n\t\t\t\t\t\t\tbprintf (\"Error: Malformed ULEB TIMES bind opcode\\n\");\n\t\t\t\t\t\t\tgoto beach;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tDO_BIND ();\n\t\t\t\t\t\taddr += skip + wordsize;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n#undef DO_BIND\n\t\t\t\tdefault:\n\t\t\t\t\tbprintf (\"Error: unknown bind opcode 0x%02x in dyld_info\\n\", *p);\n\t\t\t\t\tR_FREE (opcodes);\n\t\t\t\t\tr_pvector_free (threaded_binds);\n\t\t\t\t\treturn relocs;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\topcodes_offset += partition_size;\n\t\t}\n\n\t\tR_FREE (opcodes);\n\t\tr_pvector_free (threaded_binds);\n\t\tthreaded_binds = NULL;\n\t}\n\n\tif (bin->symtab && bin->symstr && bin->sects && bin->indirectsyms) {\n\t\tint j;\n\t\tint amount = bin->dysymtab.nundefsym;\n\t\tif (amount < 0) {\n\t\t\tamount = 0;\n\t\t}\n\t\tif (!relocs) {\n\t\t\trelocs = r_skiplist_new ((RListFree) &free, (RListComparator) &reloc_comparator);\n\t\t\tif (!relocs) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t}\n\t\tfor (j = 0; j < amount; j++) {\n\t\t\tstruct reloc_t *reloc = R_NEW0 (struct reloc_t);\n\t\t\tif (!reloc) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (parse_import_ptr (bin, reloc, bin->dysymtab.iundefsym + j)) {\n\t\t\t\treloc->ord = j;\n\t\t\t\tr_skiplist_insert_autofree (relocs, reloc);\n\t\t\t} else {\n\t\t\t\tR_FREE (reloc);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (bin->symtab && bin->dysymtab.extreloff && bin->dysymtab.nextrel) {\n\t\tif (!relocs) {\n\t\t\trelocs = r_skiplist_new ((RListFree) &free, (RListComparator) &reloc_comparator);\n\t\t\tif (!relocs) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t}\n\t\tparse_relocation_info (bin, relocs, bin->dysymtab.extreloff, bin->dysymtab.nextrel);\n\t}\n\n\tif (!bin->dyld_info && bin->chained_starts && bin->nsegs && bin->fixups_offset) {\n\t\tif (!relocs) {\n\t\t\trelocs = r_skiplist_new ((RListFree) &free, (RListComparator) &reloc_comparator);\n\t\t\tif (!relocs) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t}\n\t\twalk_bind_chains (bin, relocs);\n\t}\nbeach:\n\tr_pvector_free (threaded_binds);\n\treturn relocs;\n}\n\nstruct addr_t *MACH0_(get_entrypoint)(struct MACH0_(obj_t) *bin) {\n\tr_return_val_if_fail (bin, NULL);\n\n\tut64 ea = entry_to_vaddr (bin);\n\tif (ea == 0 || ea == UT64_MAX) {\n\t\treturn NULL;\n\t}\n\tstruct addr_t *entry = R_NEW0 (struct addr_t);\n\tif (!entry) {\n\t\treturn NULL;\n\t}\n\tentry->addr = ea;\n\tentry->offset = addr_to_offset (bin, entry->addr);\n\tentry->haddr = sdb_num_get (bin->kv, \"mach0.entry.offset\", 0);\n\tsdb_num_set (bin->kv, \"mach0.entry.vaddr\", entry->addr, 0);\n\tsdb_num_set (bin->kv, \"mach0.entry.paddr\", bin->entry, 0);\n\n\tif (entry->offset == 0 && !bin->sects) {\n\t\tint i;\n\t\tfor (i = 0; i < bin->nsects; i++) {\n\t\t\t// XXX: section name shoudnt matter .. just check for exec flags\n\t\t\tif (!strncmp (bin->sects[i].sectname, \"__text\", 6)) {\n\t\t\t\tentry->offset = (ut64)bin->sects[i].offset;\n\t\t\t\tsdb_num_set (bin->kv, \"mach0.entry\", entry->offset, 0);\n\t\t\t\tentry->addr = (ut64)bin->sects[i].addr;\n\t\t\t\tif (!entry->addr) { // workaround for object files\n\t\t\t\t\teprintf (\"entrypoint is 0...\\n\");\n\t\t\t\t\t// XXX(lowlyw) there's technically not really entrypoints\n\t\t\t\t\t// for .o files, so ignore this...\n\t\t\t\t\t// entry->addr = entry->offset;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbin->entry = entry->addr;\n\t}\n\treturn entry;\n}\n\nvoid MACH0_(kv_loadlibs)(struct MACH0_(obj_t) *bin) {\n\tint i;\n\tchar lib_flagname[128];\n\tfor (i = 0; i < bin->nlibs; i++) {\n\t\tsnprintf (lib_flagname, sizeof (lib_flagname), \"libs.%d.name\", i);\n\t\tsdb_set (bin->kv, lib_flagname, bin->libs[i], 0);\n\t}\n}\n\nstruct lib_t *MACH0_(get_libs)(struct MACH0_(obj_t) *bin) {\n\tstruct lib_t *libs;\n\tint i;\n\tchar lib_flagname[128];\n\n\tif (!bin->nlibs) {\n\t\treturn NULL;\n\t}\n\tif (!(libs = calloc ((bin->nlibs + 1), sizeof (struct lib_t)))) {\n\t\treturn NULL;\n\t}\n\tfor (i = 0; i < bin->nlibs; i++) {\n\t\tsnprintf (lib_flagname, sizeof (lib_flagname), \"libs.%d.name\", i);\n\t\tsdb_set (bin->kv, lib_flagname, bin->libs[i], 0);\n\t\tr_str_ncpy (libs[i].name, bin->libs[i], R_BIN_MACH0_STRING_LENGTH - 1);\n\t\tlibs[i].last = 0;\n\t}\n\tlibs[i].last = 1;\n\treturn libs;\n}\n\nut64 MACH0_(get_baddr)(struct MACH0_(obj_t) *bin) {\n\tint i;\n\n\tif (bin->hdr.filetype != MH_EXECUTE && bin->hdr.filetype != MH_DYLINKER &&\n\t\t\tbin->hdr.filetype != MH_FILESET) {\n\t\treturn 0;\n\t}\n\tfor (i = 0; i < bin->nsegs; i++) {\n\t\tif (bin->segs[i].fileoff == 0 && bin->segs[i].filesize != 0) {\n\t\t\treturn bin->segs[i].vmaddr;\n\t\t}\n\t}\n\treturn 0;\n}\n\nchar *MACH0_(get_class)(struct MACH0_(obj_t) *bin) {\n#if R_BIN_MACH064\n\treturn r_str_new (\"MACH064\");\n#else\n\treturn r_str_new (\"MACH0\");\n#endif\n}\n\n//XXX we are mixing up bits from cpu and opcodes\n//since thumb use 16 bits opcode but run in 32 bits\n//cpus  so here we should only return 32 or 64\nint MACH0_(get_bits)(struct MACH0_(obj_t) *bin) {\n\tif (bin) {\n\t\tint bits = MACH0_(get_bits_from_hdr) (&bin->hdr);\n\t\tif (bin->hdr.cputype == CPU_TYPE_ARM && bin->entry & 1) {\n\t\t\treturn 16;\n\t\t}\n\t\treturn bits;\n\t}\n\treturn 32;\n}\n\nint MACH0_(get_bits_from_hdr)(struct MACH0_(mach_header) *hdr) {\n\tif (hdr->magic == MH_MAGIC_64 || hdr->magic == MH_CIGAM_64) {\n\t\treturn 64;\n\t}\n\tif (hdr->cputype == CPU_TYPE_ARM64_32) { // new apple watch aka arm64_32\n\t\treturn 64;\n\t}\n\tif ((hdr->cpusubtype & CPU_SUBTYPE_MASK) == (CPU_SUBTYPE_ARM_V7K << 24)) {\n\t\treturn 16;\n\t}\n\treturn 32;\n}\n\nbool MACH0_(is_big_endian)(struct MACH0_(obj_t) *bin) {\n\tif (bin) {\n\t\tconst int cpu = bin->hdr.cputype;\n\t\treturn cpu == CPU_TYPE_POWERPC || cpu == CPU_TYPE_POWERPC64;\n\t}\n\treturn false;\n}\n\nconst char *MACH0_(get_intrp)(struct MACH0_(obj_t) *bin) {\n\treturn bin? bin->intrp: NULL;\n}\n\nconst char *MACH0_(get_os)(struct MACH0_(obj_t) *bin) {\n\tif (bin) {\n\t\tswitch (bin->os) {\n\t\tcase 1: return \"macos\";\n\t\tcase 2: return \"ios\";\n\t\tcase 3: return \"watchos\";\n\t\tcase 4: return \"tvos\";\n\t\t}\n\t}\n\treturn \"darwin\";\n}\n\nconst char *MACH0_(get_cputype_from_hdr)(struct MACH0_(mach_header) *hdr) {\n\tconst char *archstr = \"unknown\";\n\tswitch (hdr->cputype) {\n\tcase CPU_TYPE_VAX:\n\t\tarchstr = \"vax\";\n\t\tbreak;\n\tcase CPU_TYPE_MC680x0:\n\t\tarchstr = \"mc680x0\";\n\t\tbreak;\n\tcase CPU_TYPE_I386:\n\tcase CPU_TYPE_X86_64:\n\t\tarchstr = \"x86\";\n\t\tbreak;\n\tcase CPU_TYPE_MC88000:\n\t\tarchstr = \"mc88000\";\n\t\tbreak;\n\tcase CPU_TYPE_MC98000:\n\t\tarchstr = \"mc98000\";\n\t\tbreak;\n\tcase CPU_TYPE_HPPA:\n\t\tarchstr = \"hppa\";\n\t\tbreak;\n\tcase CPU_TYPE_ARM:\n\tcase CPU_TYPE_ARM64:\n\tcase CPU_TYPE_ARM64_32:\n\t\tarchstr = \"arm\";\n\t\tbreak;\n\tcase CPU_TYPE_SPARC:\n\t\tarchstr = \"sparc\";\n\t\tbreak;\n\tcase CPU_TYPE_MIPS:\n\t\tarchstr = \"mips\";\n\t\tbreak;\n\tcase CPU_TYPE_I860:\n\t\tarchstr = \"i860\";\n\t\tbreak;\n\tcase CPU_TYPE_POWERPC:\n\tcase CPU_TYPE_POWERPC64:\n\t\tarchstr = \"ppc\";\n\t\tbreak;\n\tdefault:\n\t\teprintf (\"Unknown arch %d\\n\", hdr->cputype);\n\t\tbreak;\n\t}\n\treturn archstr;\n}\n\nconst char *MACH0_(get_cputype)(struct MACH0_(obj_t) *bin) {\n\treturn bin? MACH0_(get_cputype_from_hdr) (&bin->hdr): \"unknown\";\n}\n\nstatic const char *cpusubtype_tostring(ut32 cputype, ut32 cpusubtype) {\n\tswitch (cputype) {\n\tcase CPU_TYPE_VAX:\n\t\tswitch (cpusubtype) {\n\t\tcase CPU_SUBTYPE_VAX_ALL:\treturn \"all\";\n\t\tcase CPU_SUBTYPE_VAX780:\treturn \"vax780\";\n\t\tcase CPU_SUBTYPE_VAX785:\treturn \"vax785\";\n\t\tcase CPU_SUBTYPE_VAX750:\treturn \"vax750\";\n\t\tcase CPU_SUBTYPE_VAX730:\treturn \"vax730\";\n\t\tcase CPU_SUBTYPE_UVAXI:\t\treturn \"uvaxI\";\n\t\tcase CPU_SUBTYPE_UVAXII:\treturn \"uvaxII\";\n\t\tcase CPU_SUBTYPE_VAX8200:\treturn \"vax8200\";\n\t\tcase CPU_SUBTYPE_VAX8500:\treturn \"vax8500\";\n\t\tcase CPU_SUBTYPE_VAX8600:\treturn \"vax8600\";\n\t\tcase CPU_SUBTYPE_VAX8650:\treturn \"vax8650\";\n\t\tcase CPU_SUBTYPE_VAX8800:\treturn \"vax8800\";\n\t\tcase CPU_SUBTYPE_UVAXIII:\treturn \"uvaxIII\";\n\t\tdefault:\t\t\treturn \"Unknown vax subtype\";\n\t\t}\n\tcase CPU_TYPE_MC680x0:\n\t\tswitch (cpusubtype) {\n\t\tcase CPU_SUBTYPE_MC68030:\treturn \"mc68030\";\n\t\tcase CPU_SUBTYPE_MC68040:\treturn \"mc68040\";\n\t\tcase CPU_SUBTYPE_MC68030_ONLY:\treturn \"mc68030 only\";\n\t\tdefault:\t\t\treturn \"Unknown mc680x0 subtype\";\n\t\t}\n\tcase CPU_TYPE_I386:\n\t\tswitch (cpusubtype) {\n\t\tcase CPU_SUBTYPE_386: \t\t\treturn \"386\";\n\t\tcase CPU_SUBTYPE_486: \t\t\treturn \"486\";\n\t\tcase CPU_SUBTYPE_486SX: \t\treturn \"486sx\";\n\t\tcase CPU_SUBTYPE_PENT: \t\t\treturn \"Pentium\";\n\t\tcase CPU_SUBTYPE_PENTPRO: \t\treturn \"Pentium Pro\";\n\t\tcase CPU_SUBTYPE_PENTII_M3: \t\treturn \"Pentium 3 M3\";\n\t\tcase CPU_SUBTYPE_PENTII_M5: \t\treturn \"Pentium 3 M5\";\n\t\tcase CPU_SUBTYPE_CELERON: \t\treturn \"Celeron\";\n\t\tcase CPU_SUBTYPE_CELERON_MOBILE:\treturn \"Celeron Mobile\";\n\t\tcase CPU_SUBTYPE_PENTIUM_3:\t\treturn \"Pentium 3\";\n\t\tcase CPU_SUBTYPE_PENTIUM_3_M:\t\treturn \"Pentium 3 M\";\n\t\tcase CPU_SUBTYPE_PENTIUM_3_XEON:\treturn \"Pentium 3 Xeon\";\n\t\tcase CPU_SUBTYPE_PENTIUM_M:\t\treturn \"Pentium Mobile\";\n\t\tcase CPU_SUBTYPE_PENTIUM_4:\t\treturn \"Pentium 4\";\n\t\tcase CPU_SUBTYPE_PENTIUM_4_M:\t\treturn \"Pentium 4 M\";\n\t\tcase CPU_SUBTYPE_ITANIUM:\t\treturn \"Itanium\";\n\t\tcase CPU_SUBTYPE_ITANIUM_2:\t\treturn \"Itanium 2\";\n\t\tcase CPU_SUBTYPE_XEON:\t\t\treturn \"Xeon\";\n\t\tcase CPU_SUBTYPE_XEON_MP:\t\treturn \"Xeon MP\";\n\t\tdefault:\t\t\t\treturn \"Unknown i386 subtype\";\n\t\t}\n\tcase CPU_TYPE_X86_64:\n\t\tswitch (cpusubtype & 0xff) {\n\t\tcase CPU_SUBTYPE_X86_64_ALL:\treturn \"x86 64 all\";\n\t\tcase CPU_SUBTYPE_X86_ARCH1:\treturn \"x86 arch 1\";\n\t\tdefault:\t\t\treturn \"Unknown x86 subtype\";\n\t\t}\n\tcase CPU_TYPE_MC88000:\n\t\tswitch (cpusubtype & 0xff) {\n\t\tcase CPU_SUBTYPE_MC88000_ALL:\treturn \"all\";\n\t\tcase CPU_SUBTYPE_MC88100:\treturn \"mc88100\";\n\t\tcase CPU_SUBTYPE_MC88110:\treturn \"mc88110\";\n\t\tdefault:\t\t\treturn \"Unknown mc88000 subtype\";\n\t\t}\n\tcase CPU_TYPE_MC98000:\n\t\tswitch (cpusubtype & 0xff) {\n\t\tcase CPU_SUBTYPE_MC98000_ALL:\treturn \"all\";\n\t\tcase CPU_SUBTYPE_MC98601:\treturn \"mc98601\";\n\t\tdefault:\t\t\treturn \"Unknown mc98000 subtype\";\n\t\t}\n\tcase CPU_TYPE_HPPA:\n\t\tswitch (cpusubtype & 0xff) {\n\t\tcase CPU_SUBTYPE_HPPA_7100:\treturn \"hppa7100\";\n\t\tcase CPU_SUBTYPE_HPPA_7100LC:\treturn \"hppa7100LC\";\n\t\tdefault:\t\t\treturn \"Unknown hppa subtype\";\n\t\t}\n\tcase CPU_TYPE_ARM64:\n\t\tswitch (cpusubtype & 0xff) {\n\t\tcase CPU_SUBTYPE_ARM64_ALL:\treturn \"all\";\n\t\tcase CPU_SUBTYPE_ARM64_V8:\treturn \"arm64v8\";\n\t\tcase CPU_SUBTYPE_ARM64E:\treturn \"arm64e\";\n\t\tdefault:\t\t\treturn \"Unknown arm64 subtype\";\n\t\t}\n\tcase CPU_TYPE_ARM:\n\t\tswitch (cpusubtype & 0xff) {\n\t\tcase CPU_SUBTYPE_ARM_ALL:\n\t\t\treturn \"all\";\n\t\tcase CPU_SUBTYPE_ARM_V4T:\n\t\t\treturn \"v4t\";\n\t\tcase CPU_SUBTYPE_ARM_V5:\n\t\t\treturn \"v5\";\n\t\tcase CPU_SUBTYPE_ARM_V6:\n\t\t\treturn \"v6\";\n\t\tcase CPU_SUBTYPE_ARM_XSCALE:\n\t\t\treturn \"xscale\";\n\t\tcase CPU_SUBTYPE_ARM_V7:\n\t\t\treturn \"v7\";\n\t\tcase CPU_SUBTYPE_ARM_V7F:\n\t\t\treturn \"v7f\";\n\t\tcase CPU_SUBTYPE_ARM_V7S:\n\t\t\treturn \"v7s\";\n\t\tcase CPU_SUBTYPE_ARM_V7K:\n\t\t\treturn \"v7k\";\n\t\tcase CPU_SUBTYPE_ARM_V7M:\n\t\t\treturn \"v7m\";\n\t\tcase CPU_SUBTYPE_ARM_V7EM:\n\t\t\treturn \"v7em\";\n\t\tdefault:\n\t\t\teprintf (\"Unknown arm subtype %d\\n\", cpusubtype & 0xff);\n\t\t\treturn \"unknown arm subtype\";\n\t\t}\n\tcase CPU_TYPE_SPARC:\n\t\tswitch (cpusubtype & 0xff) {\n\t\tcase CPU_SUBTYPE_SPARC_ALL:\treturn \"all\";\n\t\tdefault:\t\t\treturn \"Unknown sparc subtype\";\n\t\t}\n\tcase CPU_TYPE_MIPS:\n\t\tswitch (cpusubtype & 0xff) {\n\t\tcase CPU_SUBTYPE_MIPS_ALL:\treturn \"all\";\n\t\tcase CPU_SUBTYPE_MIPS_R2300:\treturn \"r2300\";\n\t\tcase CPU_SUBTYPE_MIPS_R2600:\treturn \"r2600\";\n\t\tcase CPU_SUBTYPE_MIPS_R2800:\treturn \"r2800\";\n\t\tcase CPU_SUBTYPE_MIPS_R2000a:\treturn \"r2000a\";\n\t\tcase CPU_SUBTYPE_MIPS_R2000:\treturn \"r2000\";\n\t\tcase CPU_SUBTYPE_MIPS_R3000a:\treturn \"r3000a\";\n\t\tcase CPU_SUBTYPE_MIPS_R3000:\treturn \"r3000\";\n\t\tdefault:\t\t\treturn \"Unknown mips subtype\";\n\t\t}\n\tcase CPU_TYPE_I860:\n\t\tswitch (cpusubtype & 0xff) {\n\t\tcase CPU_SUBTYPE_I860_ALL:\treturn \"all\";\n\t\tcase CPU_SUBTYPE_I860_860:\treturn \"860\";\n\t\tdefault:\t\t\treturn \"Unknown i860 subtype\";\n\t\t}\n\tcase CPU_TYPE_POWERPC:\n\tcase CPU_TYPE_POWERPC64:\n\t\tswitch (cpusubtype & 0xff) {\n\t\tcase CPU_SUBTYPE_POWERPC_ALL:\treturn \"all\";\n\t\tcase CPU_SUBTYPE_POWERPC_601:\treturn \"601\";\n\t\tcase CPU_SUBTYPE_POWERPC_602:\treturn \"602\";\n\t\tcase CPU_SUBTYPE_POWERPC_603:\treturn \"603\";\n\t\tcase CPU_SUBTYPE_POWERPC_603e:\treturn \"603e\";\n\t\tcase CPU_SUBTYPE_POWERPC_603ev:\treturn \"603ev\";\n\t\tcase CPU_SUBTYPE_POWERPC_604:\treturn \"604\";\n\t\tcase CPU_SUBTYPE_POWERPC_604e:\treturn \"604e\";\n\t\tcase CPU_SUBTYPE_POWERPC_620:\treturn \"620\";\n\t\tcase CPU_SUBTYPE_POWERPC_750:\treturn \"750\";\n\t\tcase CPU_SUBTYPE_POWERPC_7400:\treturn \"7400\";\n\t\tcase CPU_SUBTYPE_POWERPC_7450:\treturn \"7450\";\n\t\tcase CPU_SUBTYPE_POWERPC_970:\treturn \"970\";\n\t\tdefault:\t\t\treturn \"Unknown ppc subtype\";\n\t\t}\n\t}\n\treturn \"Unknown cputype\";\n}\n\nchar *MACH0_(get_cpusubtype_from_hdr)(struct MACH0_(mach_header) *hdr) {\n\tr_return_val_if_fail (hdr, NULL);\n\treturn strdup (cpusubtype_tostring (hdr->cputype, hdr->cpusubtype));\n}\n\nchar *MACH0_(get_cpusubtype)(struct MACH0_(obj_t) *bin) {\n\treturn bin? MACH0_(get_cpusubtype_from_hdr) (&bin->hdr): strdup (\"Unknown\");\n}\n\nbool MACH0_(is_pie)(struct MACH0_(obj_t) *bin) {\n\treturn (bin && bin->hdr.filetype == MH_EXECUTE && bin->hdr.flags & MH_PIE);\n}\n\nbool MACH0_(has_nx)(struct MACH0_(obj_t) *bin) {\n\treturn (bin && bin->hdr.filetype == MH_EXECUTE &&\n\t\tbin->hdr.flags & MH_NO_HEAP_EXECUTION);\n}\n\nchar *MACH0_(get_filetype_from_hdr)(struct MACH0_(mach_header) *hdr) {\n\tconst char *mhtype = \"Unknown\";\n\tswitch (hdr->filetype) {\n\tcase MH_OBJECT:     mhtype = \"Relocatable object\"; break;\n\tcase MH_EXECUTE:    mhtype = \"Executable file\"; break;\n\tcase MH_FVMLIB:     mhtype = \"Fixed VM shared library\"; break;\n\tcase MH_CORE:       mhtype = \"Core file\"; break;\n\tcase MH_PRELOAD:    mhtype = \"Preloaded executable file\"; break;\n\tcase MH_DYLIB:      mhtype = \"Dynamically bound shared library\"; break;\n\tcase MH_DYLINKER:   mhtype = \"Dynamic link editor\"; break;\n\tcase MH_BUNDLE:     mhtype = \"Dynamically bound bundle file\"; break;\n\tcase MH_DYLIB_STUB: mhtype = \"Shared library stub for static linking (no sections)\"; break;\n\tcase MH_DSYM:       mhtype = \"Companion file with only debug sections\"; break;\n\tcase MH_KEXT_BUNDLE: mhtype = \"Kernel extension bundle file\"; break;\n\tcase MH_FILESET:    mhtype = \"Kernel cache file\"; break;\n\t}\n\treturn strdup (mhtype);\n}\n\nchar *MACH0_(get_filetype)(struct MACH0_(obj_t) *bin) {\n\treturn bin? MACH0_(get_filetype_from_hdr) (&bin->hdr): strdup (\"Unknown\");\n}\n\nut64 MACH0_(get_main)(struct MACH0_(obj_t) *bin) {\n\tut64 addr = UT64_MAX;\n\tint i;\n\n\t// 0 = sscanned but no main found\n\t// -1 = not scanned, so no main\n\t// other = valid main addr\n\tif (bin->main_addr == UT64_MAX) {\n#if FEATURE_SYMLIST\n\t\t (void)MACH0_(get_symbols_list) (bin);\n#else\n\t\t (void)MACH0_(get_symbols) (bin);\n#endif\n\t}\n\tif (bin->main_addr != 0 && bin->main_addr != UT64_MAX) {\n\t\treturn bin->main_addr;\n\t}\n\t// dummy call to initialize things\n\tfree (MACH0_(get_entrypoint)(bin));\n\n\tbin->main_addr = 0;\n\n\tif (addr == UT64_MAX && bin->main_cmd.cmd == LC_MAIN) {\n\t\taddr = bin->entry + bin->baddr;\n\t}\n\n\tif (!addr) {\n\t\tut8 b[128];\n\t\tut64 entry = addr_to_offset (bin, bin->entry);\n\t\t// XXX: X86 only and hacky!\n\t\tif (entry > bin->size || entry + sizeof (b) > bin->size) {\n\t\t\treturn UT64_MAX;\n\t\t}\n\t\ti = r_buf_read_at (bin->b, entry, b, sizeof (b));\n\t\tif (i < 80) {\n\t\t\treturn UT64_MAX;\n\t\t}\n\t\tfor (i = 0; i < 64; i++) {\n\t\t\tif (b[i] == 0xe8 && !b[i + 3] && !b[i + 4]) {\n\t\t\t\tint delta = b[i + 1] | (b[i + 2] << 8) | (b[i + 3] << 16) | (b[i + 4] << 24);\n\t\t\t\taddr = bin->entry + i + 5 + delta;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!addr) {\n\t\t\taddr = entry;\n\t\t}\n\t}\n\treturn bin->main_addr = addr;\n}\n\nvoid MACH0_(mach_headerfields)(RBinFile *bf) {\n\tPrintfCallback cb_printf = bf->rbin->cb_printf;\n\tif (!cb_printf) {\n\t\tcb_printf = printf;\n\t}\n\tRBuffer *buf = bf->buf;\n\tut64 length = r_buf_size (buf);\n\tint n = 0;\n\tstruct MACH0_(mach_header) *mh = MACH0_(get_hdr)(buf);\n\tif (!mh) {\n\t\treturn;\n\t}\n\tut64 pvaddr = pa2va (bf, 0);\n\tcb_printf (\"pf.mach0_header @ 0x%08\"PFMT64x\"\\n\", pvaddr);\n\tcb_printf (\"0x%08\"PFMT64x\"  Magic       0x%x\\n\", pvaddr, mh->magic);\n\tpvaddr += 4;\n\tcb_printf (\"0x%08\"PFMT64x\"  CpuType     0x%x\\n\", pvaddr, mh->cputype);\n\tpvaddr += 4;\n\tcb_printf (\"0x%08\"PFMT64x\"  CpuSubType  0x%x\\n\", pvaddr, mh->cpusubtype);\n\tpvaddr += 4;\n\tcb_printf (\"0x%08\"PFMT64x\"  FileType    0x%x\\n\", pvaddr, mh->filetype);\n\tpvaddr += 4;\n\tcb_printf (\"0x%08\"PFMT64x\"  nCmds       %d\\n\", pvaddr, mh->ncmds);\n\tpvaddr += 4;\n\tcb_printf (\"0x%08\"PFMT64x\"  sizeOfCmds  %d\\n\", pvaddr, mh->sizeofcmds);\n\tpvaddr += 4;\n\tcb_printf (\"0x%08\"PFMT64x\"  Flags       0x%x\\n\", pvaddr, mh->flags);\n\tpvaddr += 4;\n\tbool is64 = mh->cputype >> 16;\n\n\tut64 addr = 0x20 - 4;\n\tut32 word = 0;\n\tut8 wordbuf[sizeof (word)];\n\tbool isBe = false;\n\tswitch (mh->cputype) {\n\tcase CPU_TYPE_POWERPC:\n\tcase CPU_TYPE_POWERPC64:\n\t\tisBe = true;\n\t\tbreak;\n\t}\n#define READWORD() \\\n\t\tif (r_buf_read_at (buf, addr, (ut8*)wordbuf, 4) != 4) { \\\n\t\t\teprintf (\"Invalid address in buffer.\\n\"); \\\n\t\t\tbreak; \\\n\t\t} \\\n\t\taddr += 4; \\\n\t\tpvaddr += 4;\\\n\t\tword = isBe? r_read_be32 (wordbuf): r_read_le32 (wordbuf);\n\tif (is64) {\n\t\taddr += 4;\n\t\tpvaddr += 4;\n\t}\n\tfor (n = 0; n < mh->ncmds && addr < length; n++) {\n\t\tREADWORD ();\n\t\tut32 lcType = word;\n\t\tconst char *pf_definition = cmd_to_pf_definition (lcType);\n\t\tif (pf_definition) {\n\t\t\tcb_printf (\"pf.%s @ 0x%08\"PFMT64x\"\\n\", pf_definition, pvaddr - 4);\n\t\t}\n\t\tcb_printf (\"0x%08\"PFMT64x\"  cmd %7d 0x%x %s\\n\",\n\t\t\tpvaddr - 4, n, lcType, cmd_to_string (lcType));\n\t\tREADWORD ();\n\t\tif (addr > length) {\n\t\t\tbreak;\n\t\t}\n\t\tint lcSize = word;\n\t\tword &= 0xFFFFFF;\n\t\tcb_printf (\"0x%08\"PFMT64x\"  cmdsize     %d\\n\", pvaddr - 4, word);\n\t\tif (lcSize < 1) {\n\t\t\teprintf (\"Invalid size for a load command\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tswitch (lcType) {\n\t\tcase LC_BUILD_VERSION: {\n\t\t\tcb_printf (\"0x%08\"PFMT64x\"  platform    %s\\n\",\n\t\t\t\tpvaddr, build_version_platform_to_string (r_buf_read_le32_at (buf, addr)));\n\t\t\tcb_printf (\"0x%08\"PFMT64x\"  minos       %d.%d.%d\\n\",\n\t\t\t\tpvaddr + 4, r_buf_read_le16_at (buf, addr + 6), r_buf_read8_at (buf, addr + 5),\n\t\t\t\tr_buf_read8_at (buf, addr + 4));\n\t\t\tcb_printf (\"0x%08\"PFMT64x\"  sdk         %d.%d.%d\\n\",\n\t\t\t\tpvaddr + 8, r_buf_read_le16_at (buf, addr + 10), r_buf_read8_at (buf, addr + 9),\n\t\t\t\tr_buf_read8_at (buf, addr + 8));\n\t\t\tut32 ntools = r_buf_read_le32_at (buf, addr + 12);\n\t\t\tcb_printf (\"0x%08\"PFMT64x\"  ntools      %d\\n\",\n\t\t\t\tpvaddr + 12, ntools);\n\t\t\tut64 off = 16;\n\t\t\twhile (off < (lcSize - 8) && ntools--) {\n\t\t\t\tcb_printf (\"pf.mach0_build_version_tool @ 0x%08\"PFMT64x\"\\n\", pvaddr + off);\n\t\t\t\tcb_printf (\"0x%08\"PFMT64x\"  tool        %s\\n\",\n\t\t\t\t\tpvaddr + off, build_version_tool_to_string (r_buf_read_le32_at (buf, addr + off)));\n\t\t\t\toff += 4;\n\t\t\t\tif (off >= (lcSize - 8)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcb_printf (\"0x%08\"PFMT64x\"  version     %d.%d.%d\\n\",\n\t\t\t\t\tpvaddr + off, r_buf_read_le16_at (buf, addr + off + 2), r_buf_read8_at (buf, addr + off + 1),\n\t\t\t\t\tr_buf_read8_at (buf, addr + off));\n\t\t\t\toff += 4;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase LC_MAIN:\n\t\t\t{\n\t\t\t\tut8 data[64] = {0};\n\t\t\t\tr_buf_read_at (buf, addr, data, sizeof (data));\n#if R_BIN_MACH064\n\t\t\t\tut64 ep = r_read_ble64 (&data, false); //  bin->big_endian);\n\t\t\t\tcb_printf (\"0x%08\"PFMT64x\"  entry0      0x%\" PFMT64x \"\\n\", pvaddr, ep);\n\t\t\t\tut64 ss = r_read_ble64 (&data[8], false); //  bin->big_endian);\n\t\t\t\tcb_printf (\"0x%08\"PFMT64x\"  stacksize   0x%\" PFMT64x \"\\n\", pvaddr +  8, ss);\n#else\n\t\t\t\tut32 ep = r_read_ble32 (&data, false); //  bin->big_endian);\n\t\t\t\tcb_printf (\"0x%08\"PFMT32x\"  entry0      0x%\" PFMT32x \"\\n\", (ut32)pvaddr, ep);\n\t\t\t\tut32 ss = r_read_ble32 (&data[4], false); //  bin->big_endian);\n\t\t\t\tcb_printf (\"0x%08\"PFMT32x\"  stacksize   0x%\" PFMT32x \"\\n\", (ut32)pvaddr +  4, ss);\n#endif\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LC_SYMTAB:\n#if 0\n\t\t\t{\n\t\t\tchar *id = r_buf_get_string (buf, addr + 20);\n\t\t\tcb_printf (\"0x%08\"PFMT64x\"  id         0x%x\\n\", addr + 20, r_str_get (id));\n\t\t\tcb_printf (\"0x%08\"PFMT64x\"  symooff    0x%x\\n\", addr + 20, r_str_get (id));\n\t\t\tcb_printf (\"0x%08\"PFMT64x\"  nsyms      %d\\n\", addr + 20, r_str_get (id));\n\t\t\tcb_printf (\"0x%08\"PFMT64x\"  stroff     0x%x\\n\", addr + 20, r_str_get (id));\n\t\t\tcb_printf (\"0x%08\"PFMT64x\"  strsize    0x%x\\n\", addr + 20, r_str_get (id));\n\t\t\tfree (id);\n\t\t\t}\n#endif\n\t\t\tbreak;\n\t\tcase LC_ID_DYLIB: { // install_name_tool\n\t\t\tut32 str_off = r_buf_read_ble32_at (buf, addr, isBe);\n\t\t\tchar *id = r_buf_get_string (buf, addr + str_off - 8);\n\t\t\tcb_printf (\"0x%08\"PFMT64x\"  current     %d.%d.%d\\n\",\n\t\t\t\tpvaddr + 8, r_buf_read_le16_at (buf, addr + 10), r_buf_read8_at (buf, addr + 9),\n\t\t\t\tr_buf_read8_at (buf, addr + 8));\n\t\t\tcb_printf (\"0x%08\"PFMT64x\"  compat      %d.%d.%d\\n\",\n\t\t\t\tpvaddr + 12, r_buf_read_le16_at (buf, addr + 14), r_buf_read8_at (buf, addr + 13),\n\t\t\t\tr_buf_read8_at (buf, addr + 12));\n\t\t\tcb_printf (\"0x%08\"PFMT64x\"  id          %s\\n\",\n\t\t\t\tpvaddr + str_off - 8, r_str_get (id));\n\t\t\tif (id) {\n\t\t\t\tfree (id);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase LC_UUID:\n\t\t\t{\n\t\t\t\tut8 i, uuid[16];\n\t\t\t\tr_buf_read_at (buf, addr, uuid, sizeof (uuid));\n\t\t\t\tcb_printf (\"0x%08\"PFMT64x\"  uuid        \", pvaddr);\n\t\t\t\tfor (i = 0; i < sizeof (uuid); i++) {\n\t\t\t\t\tcb_printf (\"%02x\", uuid[i]);\n\t\t\t\t}\n\t\t\t\tcb_printf (\"\\n\");\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LC_SEGMENT:\n\t\tcase LC_SEGMENT_64:\n\t\t\t{\n\t\t\t\tut8 name[17] = {0};\n\t\t\t\tr_buf_read_at (buf, addr, name, sizeof (name) - 1);\n\t\t\t\tcb_printf (\"0x%08\"PFMT64x\"  name        %s\\n\", pvaddr, name);\n\t\t\t\tut32 nsects = r_buf_read_le32_at (buf, addr - 8 + (is64 ? 64 : 48));\n\t\t\t\tut64 off = is64 ? 72 : 56;\n\t\t\t\twhile (off < lcSize && nsects--) {\n\t\t\t\t\tif (is64) {\n\t\t\t\t\t\tcb_printf (\"pf.mach0_section64 @ 0x%08\"PFMT64x\"\\n\", pvaddr - 8 + off);\n\t\t\t\t\t\toff += 80;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcb_printf (\"pf.mach0_section @ 0x%08\"PFMT64x\"\\n\", pvaddr - 8 + off);\n\t\t\t\t\t\toff += 68;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LC_LOAD_DYLIB:\n\t\tcase LC_LOAD_WEAK_DYLIB: {\n\t\t\tut32 str_off = r_buf_read_ble32_at (buf, addr, isBe);\n\t\t\tchar *load_dylib = r_buf_get_string (buf, addr + str_off - 8);\n\t\t\tcb_printf (\"0x%08\"PFMT64x\"  current     %d.%d.%d\\n\",\n\t\t\t\tpvaddr + 8, r_buf_read_le16_at (buf, addr + 10), r_buf_read8_at (buf, addr + 9),\n\t\t\t\tr_buf_read8_at (buf, addr + 8));\n\t\t\tcb_printf (\"0x%08\"PFMT64x\"  compat      %d.%d.%d\\n\",\n\t\t\t\tpvaddr + 12, r_buf_read_le16_at (buf, addr + 14), r_buf_read8_at (buf, addr + 13),\n\t\t\t\tr_buf_read8_at (buf, addr + 12));\n\t\t\tcb_printf (\"0x%08\"PFMT64x\"  load_dylib  %s\\n\",\n\t\t\t\tpvaddr + str_off - 8, r_str_get (load_dylib));\n\t\t\tif (load_dylib) {\n\t\t\t\tfree (load_dylib);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase LC_RPATH: {\n\t\t\tchar *rpath = r_buf_get_string (buf, addr + 4);\n\t\t\tcb_printf (\"0x%08\" PFMT64x \"  rpath       %s\\n\",\n\t\t\t\tpvaddr + 4, r_str_get (rpath));\n\t\t\tif (rpath) {\n\t\t\t\tfree (rpath);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase LC_ENCRYPTION_INFO:\n\t\tcase LC_ENCRYPTION_INFO_64: {\n\t\t\tut32 word = r_buf_read_le32_at (buf, addr);\n\t\t\tcb_printf (\"0x%08\"PFMT64x\"  cryptoff   0x%08x\\n\", pvaddr, word);\n\t\t\tword = r_buf_read_le32_at (buf, addr + 4);\n\t\t\tcb_printf (\"0x%08\"PFMT64x\"  cryptsize  %d\\n\", pvaddr + 4, word);\n\t\t\tword = r_buf_read_le32_at (buf, addr + 8);\n\t\t\tcb_printf (\"0x%08\"PFMT64x\"  cryptid    %d\\n\", pvaddr + 8, word);\n\t\t\tbreak;\n\t\t}\n\t\tcase LC_CODE_SIGNATURE: {\n\t\t\tut32 words[2];\n\t\t\tr_buf_read_at (buf, addr, (ut8 *)words, sizeof (words));\n\t\t\tcb_printf (\"0x%08\"PFMT64x\"  dataoff     0x%08x\\n\", pvaddr, words[0]);\n\t\t\tcb_printf (\"0x%08\"PFMT64x\"  datasize    %d\\n\", pvaddr + 4, words[1]);\n\t\t\tcb_printf (\"# wtf mach0.sign %d @ 0x%x\\n\", words[1], words[0]);\n\t\t\tbreak;\n\t\t}\n\t\t}\n\t\taddr += word - 8;\n\t\tpvaddr += word - 8;\n\t}\n\tfree (mh);\n}\n\nRList *MACH0_(mach_fields)(RBinFile *bf) {\n\tRBuffer *buf = bf->buf;\n\tut64 length = r_buf_size (buf);\n\tstruct MACH0_(mach_header) *mh = MACH0_(get_hdr) (buf);\n\tif (!mh) {\n\t\treturn NULL;\n\t}\n\tRList *ret = r_list_new ();\n\tif (!ret) {\n\t\tfree (mh);\n\t\treturn NULL;\n\t}\n\tret->free = free;\n\tut64 addr = pa2va (bf, 0);\n\tut64 paddr = 0;\n\n\tr_list_append (ret, r_bin_field_new (addr, addr, 1, \"header\", \"mach0_header\", \"mach0_header\", true));\n\taddr += 0x20 - 4;\n\tpaddr += 0x20 - 4;\n\tbool is64 = mh->cputype >> 16;\n\tif (is64) {\n\t\taddr += 4;\n\t\tpaddr += 4;\n\t}\n\n\tbool isBe = false;\n\tswitch (mh->cputype) {\n\tcase CPU_TYPE_POWERPC:\n\tcase CPU_TYPE_POWERPC64:\n\t\tisBe = true;\n\t\tbreak;\n\t}\n\n\tint n;\n\tchar load_command_flagname[128];\n\tfor (n = 0; n < mh->ncmds && paddr < length; n++) {\n\t\tut32 lcType = r_buf_read_ble32_at (buf, paddr, isBe);\n\t\tut32 word = r_buf_read_ble32_at (buf, paddr + 4, isBe);\n\t\tif (paddr + 8 > length) {\n\t\t\tbreak;\n\t\t}\n\t\tut32 lcSize = word;\n\t\tword &= 0xFFFFFF;\n\t\tif (lcSize < 1) {\n\t\t\teprintf (\"Invalid size for a load command\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tif (word == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tconst char *pf_definition = cmd_to_pf_definition (lcType);\n\t\tif (pf_definition) {\n\t\t\tsnprintf (load_command_flagname, sizeof (load_command_flagname), \"load_command_%d_%s\", n, cmd_to_string (lcType));\n\t\t\tr_list_append (ret, r_bin_field_new (addr, addr, 1, load_command_flagname, pf_definition, pf_definition, true));\n\t\t}\n\t\tswitch (lcType) {\n\t\tcase LC_BUILD_VERSION: {\n\t\t\tut32 ntools = r_buf_read_le32_at (buf, paddr + 20);\n\t\t\tut64 off = 24;\n\t\t\tint j = 0;\n\t\t\tchar tool_flagname[32];\n\t\t\twhile (off < lcSize && ntools--) {\n\t\t\t\tsnprintf (tool_flagname, sizeof (tool_flagname), \"tool_%d\", j++);\n\t\t\t\tr_list_append (ret, r_bin_field_new (addr + off, addr + off, 1, tool_flagname, \"mach0_build_version_tool\", \"mach0_build_version_tool\", true));\n\t\t\t\toff += 8;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase LC_SEGMENT:\n\t\tcase LC_SEGMENT_64: {\n\t\t\tut32 nsects = r_buf_read_le32_at (buf, addr + (is64 ? 64 : 48));\n\t\t\tut64 off = is64 ? 72 : 56;\n\t\t\tsize_t i, j = 0;\n\t\t\tchar section_flagname[128];\n\t\t\tfor (i = 0; i < nsects && (addr + off) < length && off < lcSize; i++) {\n\t\t\t\tconst char *sname = is64? \"mach0_section64\": \"mach0_section\";\n\t\t\t\tsnprintf (section_flagname, sizeof (section_flagname), \"section_%u\", (ut32)j++);\n\t\t\t\tRBinField *f = r_bin_field_new (addr + off, addr + off, 1, section_flagname, sname, sname, true);\n\t\t\t\tr_list_append (ret, f);\n\t\t\t\toff += is64? 80: 68;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t// TODO\n\t\t\tbreak;\n\t\t}\n\t\t}\n\t\taddr += word;\n\t\tpaddr += word;\n\t}\n\tfree (mh);\n\treturn ret;\n}\n\nstruct MACH0_(mach_header) *MACH0_(get_hdr)(RBuffer *buf) {\n\tut8 magicbytes[sizeof (ut32)] = {0};\n\tut8 machohdrbytes[sizeof (struct MACH0_(mach_header))] = {0};\n\tint len;\n\tstruct MACH0_(mach_header) *macho_hdr = R_NEW0 (struct MACH0_(mach_header));\n\tbool big_endian = false;\n\tif (!macho_hdr) {\n\t\treturn NULL;\n\t}\n\tif (r_buf_read_at (buf, 0, magicbytes, 4) < 1) {\n\t\tfree (macho_hdr);\n\t\treturn false;\n\t}\n\n\tif (r_read_le32 (magicbytes) == 0xfeedface) {\n\t\tbig_endian = false;\n\t} else if (r_read_be32 (magicbytes) == 0xfeedface) {\n\t\tbig_endian = true;\n\t} else if (r_read_le32 (magicbytes) == FAT_MAGIC) {\n\t\tbig_endian = false;\n\t} else if (r_read_be32 (magicbytes) == FAT_MAGIC) {\n\t\tbig_endian = true;\n\t} else if (r_read_le32 (magicbytes) == 0xfeedfacf) {\n\t\tbig_endian = false;\n\t} else if (r_read_be32 (magicbytes) == 0xfeedfacf) {\n\t\tbig_endian = true;\n\t} else {\n\t\t/* also extract non-mach0s */\n#if 0\n\t\tfree (macho_hdr);\n\t\treturn NULL;\n#endif\n\t}\n\tlen = r_buf_read_at (buf, 0, machohdrbytes, sizeof (machohdrbytes));\n\tif (len != sizeof (struct MACH0_(mach_header))) {\n\t\tfree (macho_hdr);\n\t\treturn NULL;\n\t}\n\tmacho_hdr->magic = r_read_ble (&machohdrbytes[0], big_endian, 32);\n\tmacho_hdr->cputype = r_read_ble (&machohdrbytes[4], big_endian, 32);\n\tmacho_hdr->cpusubtype = r_read_ble (&machohdrbytes[8], big_endian, 32);\n\tmacho_hdr->filetype = r_read_ble (&machohdrbytes[12], big_endian, 32);\n\tmacho_hdr->ncmds = r_read_ble (&machohdrbytes[16], big_endian, 32);\n\tmacho_hdr->sizeofcmds = r_read_ble (&machohdrbytes[20], big_endian, 32);\n\tmacho_hdr->flags = r_read_ble (&machohdrbytes[24], big_endian, 32);\n#if R_BIN_MACH064\n\tmacho_hdr->reserved = r_read_ble (&machohdrbytes[28], big_endian, 32);\n#endif\n\treturn macho_hdr;\n}\n\nvoid MACH0_(iterate_chained_fixups)(struct MACH0_(obj_t) *bin, ut64 limit_start, ut64 limit_end, ut32 event_mask, RFixupCallback callback, void * context) {\n\tint i = 0;\n\tfor (; i < bin->nsegs && i < bin->segs_count; i++) {\n\t\tif (!bin->chained_starts[i]) {\n\t\t\tcontinue;\n\t\t}\n\t\tint page_size = bin->chained_starts[i]->page_size;\n\t\tif (page_size < 1) {\n\t\t\tpage_size = 4096;\n\t\t}\n\t\tut64 start = bin->segs[i].fileoff;\n\t\tut64 end = start + bin->segs[i].filesize;\n\t\tif (end >= limit_start && start <= limit_end) {\n\t\t\tut64 page_idx = (R_MAX (start, limit_start) - start) / page_size;\n\t\t\tut64 page_end_idx = (R_MIN (limit_end, end) - start) / page_size;\n\t\t\tfor (; page_idx <= page_end_idx; page_idx++) {\n\t\t\t\tif (page_idx >= bin->chained_starts[i]->page_count) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tut16 page_start = bin->chained_starts[i]->page_start[page_idx];\n\t\t\t\tif (page_start == DYLD_CHAINED_PTR_START_NONE) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tut64 cursor = start + page_idx * page_size + page_start;\n\t\t\t\twhile (cursor < limit_end && cursor < end) {\n\t\t\t\t\tut8 tmp[8];\n\t\t\t\t\tbool previous_rebasing = bin->rebasing_buffer;\n\t\t\t\t\tbin->rebasing_buffer = true;\n\t\t\t\t\tif (r_buf_read_at (bin->b, cursor, tmp, 8) != 8) {\n\t\t\t\t\t\tbin->rebasing_buffer = previous_rebasing;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tbin->rebasing_buffer = previous_rebasing;\n\t\t\t\t\tut64 raw_ptr = r_read_le64 (tmp);\n\t\t\t\t\tut64 ptr_value = raw_ptr;\n\t\t\t\t\tut64 delta, stride, addend;\n\t\t\t\t\tut16 pointer_format = bin->chained_starts[i]->pointer_format;\n\t\t\t\t\tRFixupEvent event = R_FIXUP_EVENT_NONE;\n\t\t\t\t\tut8 key = 0, addr_div = 0;\n\t\t\t\t\tut16 diversity = 0;\n\t\t\t\t\tut32 ordinal = UT32_MAX;\n\t\t\t\t\tswitch (pointer_format) {\n\t\t\t\t\tcase DYLD_CHAINED_PTR_ARM64E:\n\t\t\t\t\t\t{\n\t\t\t\t\t\tstride = 8;\n\t\t\t\t\t\tbool is_auth = IS_PTR_AUTH (raw_ptr);\n\t\t\t\t\t\tbool is_bind = IS_PTR_BIND (raw_ptr);\n\t\t\t\t\t\tif (is_auth && is_bind) {\n\t\t\t\t\t\t\tstruct dyld_chained_ptr_arm64e_auth_bind *p =\n\t\t\t\t\t\t\t\t\t(struct dyld_chained_ptr_arm64e_auth_bind *) &raw_ptr;\n\t\t\t\t\t\t\tevent = R_FIXUP_EVENT_BIND_AUTH;\n\t\t\t\t\t\t\tdelta = p->next;\n\t\t\t\t\t\t\tordinal = p->ordinal;\n\t\t\t\t\t\t\tkey = p->key;\n\t\t\t\t\t\t\taddr_div = p->addrDiv;\n\t\t\t\t\t\t\tdiversity = p->diversity;\n\t\t\t\t\t\t} else if (!is_auth && is_bind) {\n\t\t\t\t\t\t\tstruct dyld_chained_ptr_arm64e_bind *p =\n\t\t\t\t\t\t\t\t\t(struct dyld_chained_ptr_arm64e_bind *) &raw_ptr;\n\t\t\t\t\t\t\tevent = R_FIXUP_EVENT_BIND;\n\t\t\t\t\t\t\tdelta = p->next;\n\t\t\t\t\t\t\tordinal = p->ordinal;\n\t\t\t\t\t\t\taddend = p->addend;\n\t\t\t\t\t\t} else if (is_auth && !is_bind) {\n\t\t\t\t\t\t\tstruct dyld_chained_ptr_arm64e_auth_rebase *p =\n\t\t\t\t\t\t\t\t\t(struct dyld_chained_ptr_arm64e_auth_rebase *) &raw_ptr;\n\t\t\t\t\t\t\tevent = R_FIXUP_EVENT_REBASE_AUTH;\n\t\t\t\t\t\t\tdelta = p->next;\n\t\t\t\t\t\t\tptr_value = p->target + bin->baddr;\n\t\t\t\t\t\t\tkey = p->key;\n\t\t\t\t\t\t\taddr_div = p->addrDiv;\n\t\t\t\t\t\t\tdiversity = p->diversity;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tstruct dyld_chained_ptr_arm64e_rebase *p =\n\t\t\t\t\t\t\t\t\t(struct dyld_chained_ptr_arm64e_rebase *) &raw_ptr;\n\t\t\t\t\t\t\tevent = R_FIXUP_EVENT_REBASE;\n\t\t\t\t\t\t\tdelta = p->next;\n\t\t\t\t\t\t\tptr_value = ((ut64)p->high8 << 56) | p->target;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase DYLD_CHAINED_PTR_ARM64E_USERLAND24:\n\t\t\t\t\t\t{\n\t\t\t\t\t\tstride = 8;\n\t\t\t\t\t\tstruct dyld_chained_ptr_arm64e_bind24 *bind =\n\t\t\t\t\t\t\t\t(struct dyld_chained_ptr_arm64e_bind24 *) &raw_ptr;\n\t\t\t\t\t\tif (bind->bind) {\n\t\t\t\t\t\t\tdelta = bind->next;\n\t\t\t\t\t\t\tif (bind->auth) {\n\t\t\t\t\t\t\t\tstruct dyld_chained_ptr_arm64e_auth_bind24 *p =\n\t\t\t\t\t\t\t\t\t\t(struct dyld_chained_ptr_arm64e_auth_bind24 *) &raw_ptr;\n\t\t\t\t\t\t\t\tevent = R_FIXUP_EVENT_BIND_AUTH;\n\t\t\t\t\t\t\t\tordinal = p->ordinal;\n\t\t\t\t\t\t\t\tkey = p->key;\n\t\t\t\t\t\t\t\taddr_div = p->addrDiv;\n\t\t\t\t\t\t\t\tdiversity = p->diversity;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tevent = R_FIXUP_EVENT_BIND;\n\t\t\t\t\t\t\t\tordinal = bind->ordinal;\n\t\t\t\t\t\t\t\taddend = bind->addend;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (bind->auth) {\n\t\t\t\t\t\t\t\tstruct dyld_chained_ptr_arm64e_auth_rebase *p =\n\t\t\t\t\t\t\t\t\t\t(struct dyld_chained_ptr_arm64e_auth_rebase *) &raw_ptr;\n\t\t\t\t\t\t\t\tevent = R_FIXUP_EVENT_REBASE_AUTH;\n\t\t\t\t\t\t\t\tdelta = p->next;\n\t\t\t\t\t\t\t\tptr_value = p->target + bin->baddr;\n\t\t\t\t\t\t\t\tkey = p->key;\n\t\t\t\t\t\t\t\taddr_div = p->addrDiv;\n\t\t\t\t\t\t\t\tdiversity = p->diversity;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tstruct dyld_chained_ptr_arm64e_rebase *p =\n\t\t\t\t\t\t\t\t\t(struct dyld_chained_ptr_arm64e_rebase *) &raw_ptr;\n\t\t\t\t\t\t\t\tevent = R_FIXUP_EVENT_REBASE;\n\t\t\t\t\t\t\t\tdelta = p->next;\n\t\t\t\t\t\t\t\tptr_value = bin->baddr + (((ut64)p->high8 << 56) | p->target);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase DYLD_CHAINED_PTR_64:\n\t\t\t\t\tcase DYLD_CHAINED_PTR_64_OFFSET:\n\t\t\t\t\t\t{\n\t\t\t\t\t\tstride = 4;\n\t\t\t\t\t\tstruct dyld_chained_ptr_64_bind *bind =\n\t\t\t\t\t\t\t\t(struct dyld_chained_ptr_64_bind *) &raw_ptr;\n\t\t\t\t\t\tif (bind->bind) {\n\t\t\t\t\t\t\tevent = R_FIXUP_EVENT_BIND;\n\t\t\t\t\t\t\tdelta = bind->next;\n\t\t\t\t\t\t\tordinal = bind->ordinal;\n\t\t\t\t\t\t\taddend = bind->addend;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tstruct dyld_chained_ptr_64_rebase *p =\n\t\t\t\t\t\t\t\t(struct dyld_chained_ptr_64_rebase *) &raw_ptr;\n\t\t\t\t\t\t\tevent = R_FIXUP_EVENT_REBASE;\n\t\t\t\t\t\t\tdelta = p->next;\n\t\t\t\t\t\t\tptr_value = ((ut64)p->high8 << 56) | p->target;\n\t\t\t\t\t\t\tif (pointer_format == DYLD_CHAINED_PTR_64_OFFSET) {\n\t\t\t\t\t\t\t\tptr_value += bin->baddr;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\teprintf (\"Unsupported chained pointer format %d\\n\", pointer_format);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tif (cursor >= limit_start && cursor <= limit_end - 8 && (event & event_mask) != 0) {\n\t\t\t\t\t\tbool carry_on;\n\t\t\t\t\t\tswitch (event) {\n\t\t\t\t\t\tcase R_FIXUP_EVENT_BIND: {\n\t\t\t\t\t\t\tRFixupBindEventDetails event_details;\n\n\t\t\t\t\t\t\tevent_details.type = event;\n\t\t\t\t\t\t\tevent_details.bin = bin;\n\t\t\t\t\t\t\tevent_details.offset = cursor;\n\t\t\t\t\t\t\tevent_details.raw_ptr = raw_ptr;\n\t\t\t\t\t\t\tevent_details.ordinal = ordinal;\n\t\t\t\t\t\t\tevent_details.addend = addend;\n\n\t\t\t\t\t\t\tcarry_on = callback (context, (RFixupEventDetails *) &event_details);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase R_FIXUP_EVENT_BIND_AUTH: {\n\t\t\t\t\t\t\tRFixupBindAuthEventDetails event_details;\n\n\t\t\t\t\t\t\tevent_details.type = event;\n\t\t\t\t\t\t\tevent_details.bin = bin;\n\t\t\t\t\t\t\tevent_details.offset = cursor;\n\t\t\t\t\t\t\tevent_details.raw_ptr = raw_ptr;\n\t\t\t\t\t\t\tevent_details.ordinal = ordinal;\n\t\t\t\t\t\t\tevent_details.key = key;\n\t\t\t\t\t\t\tevent_details.addr_div = addr_div;\n\t\t\t\t\t\t\tevent_details.diversity = diversity;\n\n\t\t\t\t\t\t\tcarry_on = callback (context, (RFixupEventDetails *) &event_details);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase R_FIXUP_EVENT_REBASE: {\n\t\t\t\t\t\t\tRFixupRebaseEventDetails event_details;\n\n\t\t\t\t\t\t\tevent_details.type = event;\n\t\t\t\t\t\t\tevent_details.bin = bin;\n\t\t\t\t\t\t\tevent_details.offset = cursor;\n\t\t\t\t\t\t\tevent_details.raw_ptr = raw_ptr;\n\t\t\t\t\t\t\tevent_details.ptr_value = ptr_value;\n\n\t\t\t\t\t\t\tcarry_on = callback (context, (RFixupEventDetails *) &event_details);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase R_FIXUP_EVENT_REBASE_AUTH: {\n\t\t\t\t\t\t\tRFixupRebaseAuthEventDetails event_details;\n\n\t\t\t\t\t\t\tevent_details.type = event;\n\t\t\t\t\t\t\tevent_details.bin = bin;\n\t\t\t\t\t\t\tevent_details.offset = cursor;\n\t\t\t\t\t\t\tevent_details.raw_ptr = raw_ptr;\n\t\t\t\t\t\t\tevent_details.ptr_value = ptr_value;\n\t\t\t\t\t\t\tevent_details.key = key;\n\t\t\t\t\t\t\tevent_details.addr_div = addr_div;\n\t\t\t\t\t\t\tevent_details.diversity = diversity;\n\n\t\t\t\t\t\t\tcarry_on = callback (context, (RFixupEventDetails *) &event_details);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\teprintf (\"Unexpected event while iterating chained fixups\\n\");\n\t\t\t\t\t\t\tcarry_on = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!carry_on) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcursor += delta * stride;\n\t\t\t\t\tif (!delta) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n"], "fixing_code": ["/* radare - LGPL - Copyright 2010-2021 - nibble, mrmacete, pancake */\n\n#include <stdio.h>\n#include <r_types.h>\n#include <r_util.h>\n#include \"mach0.h\"\n#include <r_hash.h>\n\n// TODO: deprecate bprintf and use Eprintf (bin->self)\n#define bprintf if (bin->verbose) eprintf\n#define Eprintf if (mo->verbose) eprintf\n\n#define IS_PTR_AUTH(x) ((x & (1ULL << 63)) != 0)\n#define IS_PTR_BIND(x) ((x & (1ULL << 62)) != 0)\n\ntypedef struct {\n\tstruct symbol_t *symbols;\n\tint j;\n\tint symbols_count;\n\tHtPP *hash;\n} RSymCtx;\n\ntypedef void (*RExportsIterator)(struct MACH0_(obj_t) *bin, const char *name, ut64 flags, ut64 offset, void *ctx);\n\ntypedef struct {\n\tut8 *node;\n\tchar *label;\n\tint i;\n\tut8 *next_child;\n} RTrieState;\n\ntypedef struct {\n\tut8 * imports;\n\tRSkipList *relocs;\n} RWalkBindChainsContext;\n\n// OMG; THIS SHOULD BE KILLED; this var exposes the local native endian, which is completely unnecessary\n// USE THIS: int ws = bf->o->info->big_endian;\n#define mach0_endian 1\n\nstatic ut64 read_uleb128(ut8 **p, ut8 *end) {\n\tconst char *error = NULL;\n\tut64 v;\n\t*p = (ut8 *)r_uleb128 (*p, end - *p, &v, &error);\n\tif (error) {\n\t\teprintf (\"%s\\n\", error);\n\t\tR_FREE (error);\n\t\treturn UT64_MAX;\n\t}\n\treturn v;\n}\n\nstatic ut64 entry_to_vaddr(struct MACH0_(obj_t) *bin) {\n\tswitch (bin->main_cmd.cmd) {\n\tcase LC_MAIN:\n\t\treturn bin->entry + bin->baddr;\n\tcase LC_UNIXTHREAD:\n\tcase LC_THREAD:\n\t\treturn bin->entry;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic ut64 addr_to_offset(struct MACH0_(obj_t) *bin, ut64 addr) {\n\tif (bin->segs) {\n\t\tsize_t i;\n\t\tfor (i = 0; i < bin->nsegs; i++) {\n\t\t\tconst ut64 segment_base = (ut64)bin->segs[i].vmaddr;\n\t\t\tconst ut64 segment_size = (ut64)bin->segs[i].vmsize;\n\t\t\tif (addr >= segment_base && addr < segment_base + segment_size) {\n\t\t\t\treturn bin->segs[i].fileoff + (addr - segment_base);\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic ut64 offset_to_vaddr(struct MACH0_(obj_t) *bin, ut64 offset) {\n\tif (bin->segs) {\n\t\tsize_t i;\n\t\tfor (i = 0; i < bin->nsegs; i++) {\n\t\t\tut64 segment_base = (ut64)bin->segs[i].fileoff;\n\t\t\tut64 segment_size = (ut64)bin->segs[i].filesize;\n\t\t\tif (offset >= segment_base && offset < segment_base + segment_size) {\n\t\t\t\treturn bin->segs[i].vmaddr + (offset - segment_base);\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic ut64 pa2va(RBinFile *bf, ut64 offset) {\n\tr_return_val_if_fail (bf && bf->rbin, offset);\n\tRIO *io = bf->rbin->iob.io;\n\tif (!io || !io->va) {\n\t\treturn offset;\n\t}\n\tstruct MACH0_(obj_t) *bin = bf->o->bin_obj;\n\treturn bin? offset_to_vaddr (bin, offset): offset;\n}\n\nstatic void init_sdb_formats(struct MACH0_(obj_t) *bin) {\n\t/*\n\t * These definitions are used by r2 -nn\n\t * must be kept in sync with libr/bin/d/macho\n\t */\n\tsdb_set (bin->kv, \"mach0_build_platform.cparse\",\n\t\t\"enum mach0_build_platform\" \"{MACOS=1, IOS=2, TVOS=3, WATCHOS=4, BRIDGEOS=5, IOSMAC=6, IOSSIMULATOR=7, TVOSSIMULATOR=8, WATCHOSSIMULATOR=9};\",\n\t\t0);\n\tsdb_set (bin->kv, \"mach0_build_tool.cparse\",\n\t\t\"enum mach0_build_tool\" \"{CLANG=1, SWIFT=2, LD=3};\",\n\t\t0);\n\tsdb_set (bin->kv, \"mach0_load_command_type.cparse\",\n\t\t\"enum mach0_load_command_type\" \"{ LC_SEGMENT=0x00000001ULL, LC_SYMTAB=0x00000002ULL, LC_SYMSEG=0x00000003ULL, LC_THREAD=0x00000004ULL, LC_UNIXTHREAD=0x00000005ULL, LC_LOADFVMLIB=0x00000006ULL, LC_IDFVMLIB=0x00000007ULL, LC_IDENT=0x00000008ULL, LC_FVMFILE=0x00000009ULL, LC_PREPAGE=0x0000000aULL, LC_DYSYMTAB=0x0000000bULL, LC_LOAD_DYLIB=0x0000000cULL, LC_ID_DYLIB=0x0000000dULL, LC_LOAD_DYLINKER=0x0000000eULL, LC_ID_DYLINKER=0x0000000fULL, LC_PREBOUND_DYLIB=0x00000010ULL, LC_ROUTINES=0x00000011ULL, LC_SUB_FRAMEWORK=0x00000012ULL, LC_SUB_UMBRELLA=0x00000013ULL, LC_SUB_CLIENT=0x00000014ULL, LC_SUB_LIBRARY=0x00000015ULL, LC_TWOLEVEL_HINTS=0x00000016ULL, LC_PREBIND_CKSUM=0x00000017ULL, LC_LOAD_WEAK_DYLIB=0x80000018ULL, LC_SEGMENT_64=0x00000019ULL, LC_ROUTINES_64=0x0000001aULL, LC_UUID=0x0000001bULL, LC_RPATH=0x8000001cULL, LC_CODE_SIGNATURE=0x0000001dULL, LC_SEGMENT_SPLIT_INFO=0x0000001eULL, LC_REEXPORT_DYLIB=0x8000001fULL, LC_LAZY_LOAD_DYLIB=0x00000020ULL, LC_ENCRYPTION_INFO=0x00000021ULL, LC_DYLD_INFO=0x00000022ULL, LC_DYLD_INFO_ONLY=0x80000022ULL, LC_LOAD_UPWARD_DYLIB=0x80000023ULL, LC_VERSION_MIN_MACOSX=0x00000024ULL, LC_VERSION_MIN_IPHONEOS=0x00000025ULL, LC_FUNCTION_STARTS=0x00000026ULL, LC_DYLD_ENVIRONMENT=0x00000027ULL, LC_MAIN=0x80000028ULL, LC_DATA_IN_CODE=0x00000029ULL, LC_SOURCE_VERSION=0x0000002aULL, LC_DYLIB_CODE_SIGN_DRS=0x0000002bULL, LC_ENCRYPTION_INFO_64=0x0000002cULL, LC_LINKER_OPTION=0x0000002dULL, LC_LINKER_OPTIMIZATION_HINT=0x0000002eULL, LC_VERSION_MIN_TVOS=0x0000002fULL, LC_VERSION_MIN_WATCHOS=0x00000030ULL, LC_NOTE=0x00000031ULL, LC_BUILD_VERSION=0x00000032ULL };\",\n\t\t0);\n\tsdb_set (bin->kv, \"mach0_header_filetype.cparse\",\n\t\t\"enum mach0_header_filetype\" \"{MH_OBJECT=1, MH_EXECUTE=2, MH_FVMLIB=3, MH_CORE=4, MH_PRELOAD=5, MH_DYLIB=6, MH_DYLINKER=7, MH_BUNDLE=8, MH_DYLIB_STUB=9, MH_DSYM=10, MH_KEXT_BUNDLE=11};\",\n\t\t0);\n\tsdb_set (bin->kv, \"mach0_header_flags.cparse\",\n\t\t\"enum mach0_header_flags\" \"{MH_NOUNDEFS=1, MH_INCRLINK=2,MH_DYLDLINK=4,MH_BINDATLOAD=8,MH_PREBOUND=0x10, MH_SPLIT_SEGS=0x20,MH_LAZY_INIT=0x40,MH_TWOLEVEL=0x80, MH_FORCE_FLAT=0x100,MH_NOMULTIDEFS=0x200,MH_NOFIXPREBINDING=0x400, MH_PREBINDABLE=0x800, MH_ALLMODSBOUND=0x1000, MH_SUBSECTIONS_VIA_SYMBOLS=0x2000, MH_CANONICAL=0x4000,MH_WEAK_DEFINES=0x8000, MH_BINDS_TO_WEAK=0x10000,MH_ALLOW_STACK_EXECUTION=0x20000, MH_ROOT_SAFE=0x40000,MH_SETUID_SAFE=0x80000, MH_NO_REEXPORTED_DYLIBS=0x100000,MH_PIE=0x200000, MH_DEAD_STRIPPABLE_DYLIB=0x400000, MH_HAS_TLV_DESCRIPTORS=0x800000, MH_NO_HEAP_EXECUTION=0x1000000};\",\n\t\t0);\n\tsdb_set (bin->kv, \"mach0_section_types.cparse\",\n\t\t\"enum mach0_section_types\" \"{S_REGULAR=0, S_ZEROFILL=1, S_CSTRING_LITERALS=2, S_4BYTE_LITERALS=3, S_8BYTE_LITERALS=4, S_LITERAL_POINTERS=5, S_NON_LAZY_SYMBOL_POINTERS=6, S_LAZY_SYMBOL_POINTERS=7, S_SYMBOL_STUBS=8, S_MOD_INIT_FUNC_POINTERS=9, S_MOD_TERM_FUNC_POINTERS=0xa, S_COALESCED=0xb, S_GB_ZEROFILL=0xc, S_INTERPOSING=0xd, S_16BYTE_LITERALS=0xe, S_DTRACE_DOF=0xf, S_LAZY_DYLIB_SYMBOL_POINTERS=0x10, S_THREAD_LOCAL_REGULAR=0x11, S_THREAD_LOCAL_ZEROFILL=0x12, S_THREAD_LOCAL_VARIABLES=0x13, S_THREAD_LOCAL_VARIABLE_POINTERS=0x14, S_THREAD_LOCAL_INIT_FUNCTION_POINTERS=0x15, S_INIT_FUNC_OFFSETS=0x16};\",\n\t\t0);\n\tsdb_set (bin->kv, \"mach0_section_attrs.cparse\",\n\t\t\"enum mach0_section_attrs\" \"{S_ATTR_PURE_INSTRUCTIONS=0x800000ULL, S_ATTR_NO_TOC=0x400000ULL, S_ATTR_STRIP_STATIC_SYMS=0x200000ULL, S_ATTR_NO_DEAD_STRIP=0x100000ULL, S_ATTR_LIVE_SUPPORT=0x080000ULL, S_ATTR_SELF_MODIFYING_CODE=0x040000ULL, S_ATTR_DEBUG=0x020000ULL, S_ATTR_SOME_INSTRUCTIONS=0x000004ULL, S_ATTR_EXT_RELOC=0x000002ULL, S_ATTR_LOC_RELOC=0x000001ULL};\",\n\t\t0);\n\tsdb_set (bin->kv, \"mach0_header.format\",\n\t\t\"xxx[4]Edd[4]B \"\n\t\t\"magic cputype cpusubtype (mach0_header_filetype)filetype ncmds sizeofcmds (mach0_header_flags)flags\",\n\t\t0);\n\tsdb_set (bin->kv, \"mach0_segment.format\",\n\t\t\"[4]Ed[16]zxxxxoodx \"\n\t\t\"(mach0_load_command_type)cmd cmdsize segname vmaddr vmsize fileoff filesize maxprot initprot nsects flags\",\n\t\t0);\n\tsdb_set (bin->kv, \"mach0_segment64.format\",\n\t\t\"[4]Ed[16]zqqqqoodx \"\n\t\t\"(mach0_load_command_type)cmd cmdsize segname vmaddr vmsize fileoff filesize maxprot initprot nsects flags\",\n\t\t0);\n\tsdb_set (bin->kv, \"mach0_symtab_command.format\",\n\t\t\"[4]Edxdxd \"\n\t\t\"(mach0_load_command_type)cmd cmdsize symoff nsyms stroff strsize\",\n\t\t0);\n\tsdb_set (bin->kv, \"mach0_dysymtab_command.format\",\n\t\t\"[4]Edddddddddddxdxdxxxd \"\n\t\t\"(mach0_load_command_type)cmd cmdsize ilocalsym nlocalsym iextdefsym nextdefsym iundefsym nundefsym tocoff ntoc moddtaboff nmodtab extrefsymoff nextrefsyms inddirectsymoff nindirectsyms extreloff nextrel locreloff nlocrel\",\n\t\t0);\n\tsdb_set (bin->kv, \"mach0_section.format\",\n\t\t\"[16]z[16]zxxxxxx[1]E[3]Bxx \"\n\t\t\"sectname segname addr size offset align reloff nreloc (mach0_section_types)flags_type (mach0_section_attrs)flags_attr reserved1 reserved2\", 0);\n\tsdb_set (bin->kv, \"mach0_section64.format\",\n\t\t\"[16]z[16]zqqxxxx[1]E[3]Bxxx \"\n\t\t\"sectname segname addr size offset align reloff nreloc (mach0_section_types)flags_type (mach0_section_attrs)flags_attr reserved1 reserved2 reserved3\",\n\t\t0);\n\tsdb_set (bin->kv, \"mach0_dylib.format\",\n\t\t\"xxxxz \"\n\t\t\"name_offset timestamp current_version compatibility_version name\",\n\t\t0);\n\tsdb_set (bin->kv, \"mach0_dylib_command.format\",\n\t\t\"[4]Ed? \"\n\t\t\"(mach0_load_command_type)cmd cmdsize (mach0_dylib)dylib\",\n\t\t0);\n\tsdb_set (bin->kv, \"mach0_id_dylib_command.format\",\n\t\t\"[4]Ed? \"\n\t\t\"(mach0_load_command_type)cmd cmdsize (mach0_dylib)dylib\",\n\t\t0);\n\tsdb_set (bin->kv, \"mach0_uuid_command.format\",\n\t\t\"[4]Ed[16]b \"\n\t\t\"(mach0_load_command_type)cmd cmdsize uuid\",\n\t\t0);\n\tsdb_set (bin->kv, \"mach0_rpath_command.format\",\n\t\t\"[4]Edxz \"\n\t\t\"(mach0_load_command_type)cmd cmdsize path_offset path\",\n\t\t0);\n\tsdb_set (bin->kv, \"mach0_entry_point_command.format\",\n\t\t\"[4]Edqq \"\n\t\t\"(mach0_load_command_type)cmd cmdsize entryoff stacksize\",\n\t\t0);\n\tsdb_set (bin->kv, \"mach0_encryption_info64_command.format\",\n\t\t\"[4]Edxddx \"\n\t\t\"(mach0_load_command_type)cmd cmdsize offset size id padding\",\n\t\t0);\n\tsdb_set (bin->kv, \"mach0_encryption_info_command.format\",\n\t\t\"[4]Edxdd \"\n\t\t\"(mach0_load_command_type)cmd cmdsize offset size id\",\n\t\t0);\n\tsdb_set (bin->kv, \"mach0_code_signature_command.format\",\n\t\t\"[4]Edxd \"\n\t\t\"(mach0_load_command_type)cmd cmdsize offset size\",\n\t\t0);\n\tsdb_set (bin->kv, \"mach0_dyld_info_only_command.format\",\n\t\t\"[4]Edxdxdxdxdxd \"\n\t\t\"(mach0_load_command_type)cmd cmdsize rebase_off rebase_size bind_off bind_size weak_bind_off weak_bind_size lazy_bind_off lazy_bind_size export_off export_size\",\n\t\t0);\n\tsdb_set (bin->kv, \"mach0_load_dylinker_command.format\",\n\t\t\"[4]Edxz \"\n\t\t\"(mach0_load_command_type)cmd cmdsize name_offset name\",\n\t\t0);\n\tsdb_set (bin->kv, \"mach0_id_dylinker_command.format\",\n\t\t\"[4]Edxzi \"\n\t\t\"(mach0_load_command_type)cmd cmdsize name_offset name\",\n\t\t0);\n\tsdb_set (bin->kv, \"mach0_build_version_command.format\",\n\t\t\"[4]Ed[4]Exxd \"\n\t\t\"(mach0_load_command_type)cmd cmdsize (mach0_build_platform)platform minos sdk ntools\",\n\t\t0);\n\tsdb_set (bin->kv, \"mach0_build_version_tool.format\",\n\t\t\"[4]Ex \"\n\t\t\"(mach0_build_tool)tool version\",\n\t\t0);\n\tsdb_set (bin->kv, \"mach0_source_version_command.format\",\n\t\t\"[4]Edq \"\n\t\t\"(mach0_load_command_type)cmd cmdsize version\",\n\t\t0);\n\tsdb_set (bin->kv, \"mach0_function_starts_command.format\",\n\t\t\"[4]Edxd \"\n\t\t\"(mach0_load_command_type)cmd cmdsize offset size\",\n\t\t0);\n\tsdb_set (bin->kv, \"mach0_data_in_code_command.format\",\n\t\t\"[4]Edxd \"\n\t\t\"(mach0_load_command_type)cmd cmdsize offset size\",\n\t\t0);\n\tsdb_set (bin->kv, \"mach0_version_min_command.format\",\n\t\t\"[4]Edxx \"\n\t\t\"(mach0_load_command_type)cmd cmdsize version reserved\",\n\t\t0);\n\tsdb_set (bin->kv, \"mach0_segment_split_info_command.format\",\n\t\t\"[4]Edxd \"\n\t\t\"(mach0_load_command_type)cmd cmdsize offset size\",\n\t\t0);\n\tsdb_set (bin->kv, \"mach0_unixthread_command.format\",\n\t\t\"[4]Eddd \"\n\t\t\"(mach0_load_command_type)cmd cmdsize flavor count\",\n\t\t0);\n}\n\nstatic bool init_hdr(struct MACH0_(obj_t) *bin) {\n\tut8 magicbytes[4] = {0};\n\tut8 machohdrbytes[sizeof (struct MACH0_(mach_header))] = {0};\n\tint len;\n\n\tif (r_buf_read_at (bin->b, 0 + bin->header_at, magicbytes, 4) < 1) {\n\t\treturn false;\n\t}\n\tif (r_read_le32 (magicbytes) == 0xfeedface) {\n\t\tbin->big_endian = false;\n\t} else if (r_read_be32 (magicbytes) == 0xfeedface) {\n\t\tbin->big_endian = true;\n\t} else if (r_read_le32 (magicbytes) == FAT_MAGIC) {\n\t\tbin->big_endian = false;\n\t} else if (r_read_be32 (magicbytes) == FAT_MAGIC) {\n\t\tbin->big_endian = true;\n\t} else if (r_read_le32 (magicbytes) == 0xfeedfacf) {\n\t\tbin->big_endian = false;\n\t} else if (r_read_be32 (magicbytes) == 0xfeedfacf) {\n\t\tbin->big_endian = true;\n\t} else {\n\t\treturn false; // object files are magic == 0, but body is different :?\n\t}\n\tlen = r_buf_read_at (bin->b, 0 + bin->header_at, machohdrbytes, sizeof (machohdrbytes));\n\tif (len != sizeof (machohdrbytes)) {\n\t\tbprintf (\"Error: read (hdr)\\n\");\n\t\treturn false;\n\t}\n\tbin->hdr.magic = r_read_ble (&machohdrbytes[0], bin->big_endian, 32);\n\tbin->hdr.cputype = r_read_ble (&machohdrbytes[4], bin->big_endian, 32);\n\tbin->hdr.cpusubtype = r_read_ble (&machohdrbytes[8], bin->big_endian, 32);\n\tbin->hdr.filetype = r_read_ble (&machohdrbytes[12], bin->big_endian, 32);\n\tbin->hdr.ncmds = r_read_ble (&machohdrbytes[16], bin->big_endian, 32);\n\tbin->hdr.sizeofcmds = r_read_ble (&machohdrbytes[20], bin->big_endian, 32);\n\tbin->hdr.flags = r_read_ble (&machohdrbytes[24], bin->big_endian, 32);\n#if R_BIN_MACH064\n\tbin->hdr.reserved = r_read_ble (&machohdrbytes[28], bin->big_endian, 32);\n#endif\n\tinit_sdb_formats (bin);\n\tsdb_num_set (bin->kv, \"mach0_header.offset\", 0, 0); // wat about fatmach0?\n\treturn true;\n}\n\nstatic bool parse_segments(struct MACH0_(obj_t) *bin, ut64 off) {\n\tsize_t i, j, k, sect, len;\n\tut32 size_sects;\n\tut8 segcom[sizeof (struct MACH0_(segment_command))] = {0};\n\tut8 sec[sizeof (struct MACH0_(section))] = {0};\n\tchar section_flagname[128];\n\n\tif (!UT32_MUL (&size_sects, bin->nsegs, sizeof (struct MACH0_(segment_command)))) {\n\t\treturn false;\n\t}\n\tif (!size_sects || size_sects > bin->size) {\n\t\treturn false;\n\t}\n\tif (off > bin->size || off + sizeof (struct MACH0_(segment_command)) > bin->size) {\n\t\treturn false;\n\t}\n\tif (!(bin->segs = realloc (bin->segs, bin->nsegs * sizeof(struct MACH0_(segment_command))))) {\n\t\tr_sys_perror (\"realloc (seg)\");\n\t\treturn false;\n\t}\n\tj = bin->nsegs - 1;\n\tlen = r_buf_read_at (bin->b, off, segcom, sizeof (struct MACH0_(segment_command)));\n\tif (len != sizeof (struct MACH0_(segment_command))) {\n\t\tbprintf (\"Error: read (seg)\\n\");\n\t\treturn false;\n\t}\n\ti = 0;\n\tbin->segs[j].cmd = r_read_ble32 (&segcom[i], bin->big_endian);\n\ti += sizeof (ut32);\n\tbin->segs[j].cmdsize = r_read_ble32 (&segcom[i], bin->big_endian);\n\ti += sizeof (ut32);\n\tmemcpy (&bin->segs[j].segname, &segcom[i], 16);\n\ti += 16;\n#if R_BIN_MACH064\n\tbin->segs[j].vmaddr = r_read_ble64 (&segcom[i], bin->big_endian);\n\ti += sizeof (ut64);\n\tbin->segs[j].vmsize = r_read_ble64 (&segcom[i], bin->big_endian);\n\ti += sizeof (ut64);\n\tbin->segs[j].fileoff = r_read_ble64 (&segcom[i], bin->big_endian);\n\ti += sizeof (ut64);\n\tbin->segs[j].filesize = r_read_ble64 (&segcom[i], bin->big_endian);\n\ti += sizeof (ut64);\n#else\n\tbin->segs[j].vmaddr = r_read_ble32 (&segcom[i], bin->big_endian);\n\ti += sizeof (ut32);\n\tbin->segs[j].vmsize = r_read_ble32 (&segcom[i], bin->big_endian);\n\ti += sizeof (ut32);\n\tbin->segs[j].fileoff = r_read_ble32 (&segcom[i], bin->big_endian);\n\ti += sizeof (ut32);\n\tbin->segs[j].filesize = r_read_ble32 (&segcom[i], bin->big_endian);\n\ti += sizeof (ut32);\n#endif\n\tbin->segs[j].maxprot = r_read_ble32 (&segcom[i], bin->big_endian);\n\ti += sizeof (ut32);\n\tbin->segs[j].initprot = r_read_ble32 (&segcom[i], bin->big_endian);\n\ti += sizeof (ut32);\n\tbin->segs[j].nsects = r_read_ble32 (&segcom[i], bin->big_endian);\n\ti += sizeof (ut32);\n\tbin->segs[j].flags = r_read_ble32 (&segcom[i], bin->big_endian);\n\n\tchar *segment_flagname = NULL;\n#if R_BIN_MACH064\n\tsegment_flagname = r_str_newf (\"mach0_segment64_%u.offset\", (ut32)j);\n#else\n\tsegment_flagname = r_str_newf (\"mach0_segment_%u.offset\", (ut32)j);\n#endif\n\tsdb_num_set (bin->kv, segment_flagname, off, 0);\n\tfree (segment_flagname);\n\tsdb_num_set (bin->kv, \"mach0_segments.count\", 0, 0);\n\n\tif (bin->segs[j].nsects > 0) {\n\t\tsect = bin->nsects;\n\t\tbin->nsects += bin->segs[j].nsects;\n\t\tif (bin->nsects > 128) {\n\t\t\tint new_nsects = bin->nsects & 0xf;\n\t\t\tbprintf (\"WARNING: mach0 header contains too many sections (%d). Wrapping to %d\\n\",\n\t\t\t\t bin->nsects, new_nsects);\n\t\t\tbin->nsects = new_nsects;\n\t\t}\n\t\tif ((int)bin->nsects < 1) {\n\t\t\tbprintf (\"Warning: Invalid number of sections\\n\");\n\t\t\tbin->nsects = sect;\n\t\t\treturn false;\n\t\t}\n\t\tif (!UT32_MUL (&size_sects, bin->nsects-sect, sizeof (struct MACH0_(section)))){\n\t\t\tbin->nsects = sect;\n\t\t\treturn false;\n\t\t}\n\t\tif (!size_sects || size_sects > bin->size){\n\t\t\tbin->nsects = sect;\n\t\t\treturn false;\n\t\t}\n\n\t\tif (bin->segs[j].cmdsize != sizeof (struct MACH0_(segment_command)) \\\n\t\t\t\t  + (sizeof (struct MACH0_(section))*bin->segs[j].nsects)){\n\t\t\tbin->nsects = sect;\n\t\t\treturn false;\n\t\t}\n\n\t\tif (off + sizeof (struct MACH0_(segment_command)) > bin->size ||\\\n\t\t\t\toff + sizeof (struct MACH0_(segment_command)) + size_sects > bin->size){\n\t\t\tbin->nsects = sect;\n\t\t\treturn false;\n\t\t}\n\n\t\tif (!(bin->sects = realloc (bin->sects, bin->nsects * sizeof (struct MACH0_(section))))) {\n\t\t\tr_sys_perror (\"realloc (sects)\");\n\t\t\tbin->nsects = sect;\n\t\t\treturn false;\n\t\t}\n\n\t\tfor (k = sect, j = 0; k < bin->nsects; k++, j++) {\n\t\t\tut64 offset = off + sizeof (struct MACH0_(segment_command)) + j * sizeof (struct MACH0_(section));\n\t\t\tlen = r_buf_read_at (bin->b, offset, sec, sizeof (struct MACH0_(section)));\n\t\t\tif (len != sizeof (struct MACH0_(section))) {\n\t\t\t\tbprintf (\"Error: read (sects)\\n\");\n\t\t\t\tbin->nsects = sect;\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\ti = 0;\n\t\t\tmemcpy (&bin->sects[k].sectname, &sec[i], 16);\n\t\t\ti += 16;\n\t\t\tmemcpy (&bin->sects[k].segname, &sec[i], 16);\n\t\t\ti += 16;\n\t\t\tsnprintf (section_flagname, sizeof (section_flagname), \"mach0_section_%.16s_%.16s.offset\",\n\t\t\t\t\t\tbin->sects[k].segname, bin->sects[k].sectname);\n\t\t\tsdb_num_set (bin->kv, section_flagname, offset, 0);\n#if R_BIN_MACH064\n\t\t\tsnprintf (section_flagname, sizeof (section_flagname), \"mach0_section_%.16s_%.16s.format\",\n\t\t\t\t\t\tbin->sects[k].segname, bin->sects[k].sectname);\n\t\t\tsdb_set (bin->kv, section_flagname, \"mach0_section64\", 0);\n#else\n\t\t\tsnprintf (section_flagname, sizeof (section_flagname), \"mach0_section_%.16s_%.16s.format\",\n\t\t\t\t\t\tbin->sects[k].segname, bin->sects[k].sectname);\n\t\t\tsdb_set (bin->kv, section_flagname, \"mach0_section\", 0);\n#endif\n\n#if R_BIN_MACH064\n\t\t\tbin->sects[k].addr = r_read_ble64 (&sec[i], bin->big_endian);\n\t\t\ti += sizeof (ut64);\n\t\t\tbin->sects[k].size = r_read_ble64 (&sec[i], bin->big_endian);\n\t\t\ti += sizeof (ut64);\n#else\n\t\t\tbin->sects[k].addr = r_read_ble32 (&sec[i], bin->big_endian);\n\t\t\ti += sizeof (ut32);\n\t\t\tbin->sects[k].size = r_read_ble32 (&sec[i], bin->big_endian);\n\t\t\ti += sizeof (ut32);\n#endif\n\t\t\tbin->sects[k].offset = r_read_ble32 (&sec[i], bin->big_endian);\n\t\t\ti += sizeof (ut32);\n\t\t\tbin->sects[k].align = r_read_ble32 (&sec[i], bin->big_endian);\n\t\t\ti += sizeof (ut32);\n\t\t\tbin->sects[k].reloff = r_read_ble32 (&sec[i], bin->big_endian);\n\t\t\ti += sizeof (ut32);\n\t\t\tbin->sects[k].nreloc = r_read_ble32 (&sec[i], bin->big_endian);\n\t\t\ti += sizeof (ut32);\n\t\t\tbin->sects[k].flags = r_read_ble32 (&sec[i], bin->big_endian);\n\t\t\ti += sizeof (ut32);\n\t\t\tbin->sects[k].reserved1 = r_read_ble32 (&sec[i], bin->big_endian);\n\t\t\ti += sizeof (ut32);\n\t\t\tbin->sects[k].reserved2 = r_read_ble32 (&sec[i], bin->big_endian);\n#if R_BIN_MACH064\n\t\t\ti += sizeof (ut32);\n\t\t\tbin->sects[k].reserved3 = r_read_ble32 (&sec[i], bin->big_endian);\n#endif\n\t\t}\n\t}\n\treturn true;\n}\n\n#define Error(x) error_message = x; goto error;\nstatic bool parse_symtab(struct MACH0_(obj_t) *mo, ut64 off) {\n\tstruct symtab_command st;\n\tut32 size_sym;\n\tsize_t i;\n\tconst char *error_message = \"\";\n\tut8 symt[sizeof (struct symtab_command)] = {0};\n\tut8 nlst[sizeof (struct MACH0_(nlist))] = {0};\n\tconst bool be = mo->big_endian;\n\n\tif (off > (ut64)mo->size || off + sizeof (struct symtab_command) > (ut64)mo->size) {\n\t\treturn false;\n\t}\n\tint len = r_buf_read_at (mo->b, off, symt, sizeof (struct symtab_command));\n\tif (len != sizeof (struct symtab_command)) {\n\t\tEprintf (\"Error: read (symtab)\\n\");\n\t\treturn false;\n\t}\n\tst.cmd = r_read_ble32 (symt, be);\n\tst.cmdsize = r_read_ble32 (symt + 4, be);\n\tst.symoff = r_read_ble32 (symt + 8, be) + mo->symbols_off;\n\tst.nsyms = r_read_ble32 (symt + 12, be);\n\tst.stroff = r_read_ble32 (symt + 16, be) + mo->symbols_off;\n\tst.strsize = r_read_ble32 (symt + 20, be);\n\n\tmo->symtab = NULL;\n\tmo->nsymtab = 0;\n\tif (st.strsize > 0 && st.strsize < mo->size && st.nsyms > 0) {\n\t\tmo->nsymtab = st.nsyms;\n\t\tif (st.stroff > mo->size || st.stroff + st.strsize > mo->size) {\n\t\t\tError (\"fail\");\n\t\t}\n\t\tif (!UT32_MUL (&size_sym, mo->nsymtab, sizeof (struct MACH0_(nlist)))) {\n\t\t\tError (\"fail2\");\n\t\t}\n\t\tif (!size_sym) {\n\t\t\tError (\"symbol size is zero\");\n\t\t}\n\t\tif (st.symoff > mo->size || st.symoff + size_sym > mo->size) {\n\t\t\tError (\"symoff is out of bounds\");\n\t\t}\n\t\tif (!(mo->symstr = calloc (1, st.strsize + 2))) {\n\t\t\tError (\"symoff is out of bounds\");\n\t\t}\n\t\tmo->symstrlen = st.strsize;\n\t\tlen = r_buf_read_at (mo->b, st.stroff, (ut8*)mo->symstr, st.strsize);\n\t\tif (len != st.strsize) {\n\t\t\tError (\"Error: read (symstr)\");\n\t\t}\n\t\tut64 max_nsymtab = (r_buf_size (mo->b) - st.symoff) / sizeof (struct MACH0_(nlist));\n\t\tif (mo->nsymtab > max_nsymtab || !(mo->symtab = calloc (mo->nsymtab, sizeof (struct MACH0_(nlist))))) {\n\t\t\tgoto error;\n\t\t}\n\t\tfor (i = 0; i < mo->nsymtab; i++) {\n\t\t\tut64 at = st.symoff + (i * sizeof (struct MACH0_(nlist)));\n\t\t\tlen = r_buf_read_at (mo->b, at, nlst, sizeof (struct MACH0_(nlist)));\n\t\t\tif (len != sizeof (struct MACH0_(nlist))) {\n\t\t\t\tError (\"read (nlist)\");\n\t\t\t}\n\t\t\t//XXX not very safe what if is n_un.n_name instead?\n\t\t\tmo->symtab[i].n_strx = r_read_ble32 (nlst, be);\n\t\t\tmo->symtab[i].n_type = r_read_ble8 (nlst + 4);\n\t\t\tmo->symtab[i].n_sect = r_read_ble8 (nlst + 5);\n\t\t\tmo->symtab[i].n_desc = r_read_ble16 (nlst + 6, be);\n#if R_BIN_MACH064\n\t\t\tmo->symtab[i].n_value = r_read_ble64 (&nlst[8], be);\n#else\n\t\t\tmo->symtab[i].n_value = r_read_ble32 (&nlst[8], be);\n#endif\n\t\t}\n\t}\n\treturn true;\nerror:\n\tR_FREE (mo->symstr);\n\tR_FREE (mo->symtab);\n\tEprintf (\"%s\\n\", error_message);\n\treturn false;\n}\n\nstatic bool parse_dysymtab(struct MACH0_(obj_t) *bin, ut64 off) {\n\tsize_t len, i;\n\tut32 size_tab;\n\tut8 dysym[sizeof (struct dysymtab_command)] = {0};\n\tut8 dytoc[sizeof (struct dylib_table_of_contents)] = {0};\n\tut8 dymod[sizeof (struct MACH0_(dylib_module))] = {0};\n\tut8 idsyms[sizeof (ut32)] = {0};\n\n\tif (off > bin->size || off + sizeof (struct dysymtab_command) > bin->size) {\n\t\treturn false;\n\t}\n\n\tlen = r_buf_read_at (bin->b, off, dysym, sizeof (struct dysymtab_command));\n\tif (len != sizeof (struct dysymtab_command)) {\n\t\tbprintf (\"Error: read (dysymtab)\\n\");\n\t\treturn false;\n\t}\n\n\tbin->dysymtab.cmd = r_read_ble32 (&dysym[0], bin->big_endian);\n\tbin->dysymtab.cmdsize = r_read_ble32 (&dysym[4], bin->big_endian);\n\tbin->dysymtab.ilocalsym = r_read_ble32 (&dysym[8], bin->big_endian);\n\tbin->dysymtab.nlocalsym = r_read_ble32 (&dysym[12], bin->big_endian);\n\tbin->dysymtab.iextdefsym = r_read_ble32 (&dysym[16], bin->big_endian);\n\tbin->dysymtab.nextdefsym = r_read_ble32 (&dysym[20], bin->big_endian);\n\tbin->dysymtab.iundefsym = r_read_ble32 (&dysym[24], bin->big_endian);\n\tbin->dysymtab.nundefsym = r_read_ble32 (&dysym[28], bin->big_endian);\n\tbin->dysymtab.tocoff = r_read_ble32 (&dysym[32], bin->big_endian);\n\tbin->dysymtab.ntoc = r_read_ble32 (&dysym[36], bin->big_endian);\n\tbin->dysymtab.modtaboff = r_read_ble32 (&dysym[40], bin->big_endian);\n\tbin->dysymtab.nmodtab = r_read_ble32 (&dysym[44], bin->big_endian);\n\tbin->dysymtab.extrefsymoff = r_read_ble32 (&dysym[48], bin->big_endian);\n\tbin->dysymtab.nextrefsyms = r_read_ble32 (&dysym[52], bin->big_endian);\n\tbin->dysymtab.indirectsymoff = r_read_ble32 (&dysym[56], bin->big_endian);\n\tbin->dysymtab.nindirectsyms = r_read_ble32 (&dysym[60], bin->big_endian);\n\tbin->dysymtab.extreloff = r_read_ble32 (&dysym[64], bin->big_endian);\n\tbin->dysymtab.nextrel = r_read_ble32 (&dysym[68], bin->big_endian);\n\tbin->dysymtab.locreloff = r_read_ble32 (&dysym[72], bin->big_endian);\n\tbin->dysymtab.nlocrel = r_read_ble32 (&dysym[76], bin->big_endian);\n\n\tbin->ntoc = bin->dysymtab.ntoc;\n\tif (bin->ntoc > 0) {\n\t\tif (!(bin->toc = calloc (bin->ntoc, sizeof (struct dylib_table_of_contents)))) {\n\t\t\tr_sys_perror (\"calloc (toc)\");\n\t\t\treturn false;\n\t\t}\n\t\tif (!UT32_MUL (&size_tab, bin->ntoc, sizeof (struct dylib_table_of_contents))){\n\t\t\tR_FREE (bin->toc);\n\t\t\treturn false;\n\t\t}\n\t\tif (!size_tab){\n\t\t\tR_FREE (bin->toc);\n\t\t\treturn false;\n\t\t}\n\t\tif (bin->dysymtab.tocoff > bin->size || bin->dysymtab.tocoff + size_tab > bin->size){\n\t\t\tR_FREE (bin->toc);\n\t\t\treturn false;\n\t\t}\n\t\tfor (i = 0; i < bin->ntoc; i++) {\n\t\t\tlen = r_buf_read_at (bin->b, bin->dysymtab.tocoff +\n\t\t\t\ti * sizeof (struct dylib_table_of_contents),\n\t\t\t\tdytoc, sizeof (struct dylib_table_of_contents));\n\t\t\tif (len != sizeof (struct dylib_table_of_contents)) {\n\t\t\t\tbprintf (\"Error: read (toc)\\n\");\n\t\t\t\tR_FREE (bin->toc);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tbin->toc[i].symbol_index = r_read_ble32 (&dytoc[0], bin->big_endian);\n\t\t\tbin->toc[i].module_index = r_read_ble32 (&dytoc[4], bin->big_endian);\n\t\t}\n\t}\n\tbin->nmodtab = bin->dysymtab.nmodtab;\n\tut64 max_nmodtab = (bin->size - bin->dysymtab.modtaboff) / sizeof (struct MACH0_(dylib_module));\n\tif (bin->nmodtab > 0 && bin->nmodtab <= max_nmodtab) {\n\t\tif (!(bin->modtab = calloc (bin->nmodtab, sizeof (struct MACH0_(dylib_module))))) {\n\t\t\tr_sys_perror (\"calloc (modtab)\");\n\t\t\treturn false;\n\t\t}\n\t\tif (!UT32_MUL (&size_tab, bin->nmodtab, sizeof (struct MACH0_(dylib_module)))){\n\t\t\tR_FREE (bin->modtab);\n\t\t\treturn false;\n\t\t}\n\t\tif (!size_tab){\n\t\t\tR_FREE (bin->modtab);\n\t\t\treturn false;\n\t\t}\n\t\tif (bin->dysymtab.modtaboff > bin->size || \\\n\t\t  bin->dysymtab.modtaboff + size_tab > bin->size){\n\t\t\tR_FREE (bin->modtab);\n\t\t\treturn false;\n\t\t}\n\t\tfor (i = 0; i < bin->nmodtab; i++) {\n\t\t\tlen = r_buf_read_at (bin->b, bin->dysymtab.modtaboff +\n\t\t\t\ti * sizeof (struct MACH0_(dylib_module)),\n\t\t\t\tdymod, sizeof (struct MACH0_(dylib_module)));\n\t\t\tif (len == -1) {\n\t\t\t\tbprintf (\"Error: read (modtab)\\n\");\n\t\t\t\tR_FREE (bin->modtab);\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tbin->modtab[i].module_name = r_read_ble32 (&dymod[0], bin->big_endian);\n\t\t\tbin->modtab[i].iextdefsym = r_read_ble32 (&dymod[4], bin->big_endian);\n\t\t\tbin->modtab[i].nextdefsym = r_read_ble32 (&dymod[8], bin->big_endian);\n\t\t\tbin->modtab[i].irefsym = r_read_ble32 (&dymod[12], bin->big_endian);\n\t\t\tbin->modtab[i].nrefsym = r_read_ble32 (&dymod[16], bin->big_endian);\n\t\t\tbin->modtab[i].ilocalsym = r_read_ble32 (&dymod[20], bin->big_endian);\n\t\t\tbin->modtab[i].nlocalsym = r_read_ble32 (&dymod[24], bin->big_endian);\n\t\t\tbin->modtab[i].iextrel = r_read_ble32 (&dymod[28], bin->big_endian);\n\t\t\tbin->modtab[i].nextrel = r_read_ble32 (&dymod[32], bin->big_endian);\n\t\t\tbin->modtab[i].iinit_iterm = r_read_ble32 (&dymod[36], bin->big_endian);\n\t\t\tbin->modtab[i].ninit_nterm = r_read_ble32 (&dymod[40], bin->big_endian);\n#if R_BIN_MACH064\n\t\t\tbin->modtab[i].objc_module_info_size = r_read_ble32 (&dymod[44], bin->big_endian);\n\t\t\tbin->modtab[i].objc_module_info_addr = r_read_ble64 (&dymod[48], bin->big_endian);\n#else\n\t\t\tbin->modtab[i].objc_module_info_addr = r_read_ble32 (&dymod[44], bin->big_endian);\n\t\t\tbin->modtab[i].objc_module_info_size = r_read_ble32 (&dymod[48], bin->big_endian);\n#endif\n\t\t}\n\t}\n\tbin->nindirectsyms = bin->dysymtab.nindirectsyms;\n\tif (bin->nindirectsyms > 0) {\n\t\tif (!(bin->indirectsyms = calloc (bin->nindirectsyms, sizeof (ut32)))) {\n\t\t\tr_sys_perror (\"calloc (indirectsyms)\");\n\t\t\treturn false;\n\t\t}\n\t\tif (!UT32_MUL (&size_tab, bin->nindirectsyms, sizeof (ut32))){\n\t\t\tR_FREE (bin->indirectsyms);\n\t\t\treturn false;\n\t\t}\n\t\tif (!size_tab){\n\t\t\tR_FREE (bin->indirectsyms);\n\t\t\treturn false;\n\t\t}\n\t\tif (bin->dysymtab.indirectsymoff > bin->size || \\\n\t\t\t\tbin->dysymtab.indirectsymoff + size_tab > bin->size){\n\t\t\tR_FREE (bin->indirectsyms);\n\t\t\treturn false;\n\t\t}\n\t\tfor (i = 0; i < bin->nindirectsyms; i++) {\n\t\t\tlen = r_buf_read_at (bin->b, bin->dysymtab.indirectsymoff + i * sizeof (ut32), idsyms, 4);\n\t\t\tif (len == -1) {\n\t\t\t\tbprintf (\"Error: read (indirect syms)\\n\");\n\t\t\t\tR_FREE (bin->indirectsyms);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tbin->indirectsyms[i] = r_read_ble32 (&idsyms[0], bin->big_endian);\n\t\t}\n\t}\n\t/* TODO extrefsyms, extrel, locrel */\n\treturn true;\n}\n\nstatic char *readString(ut8 *p, int off, int len) {\n\tif (off < 0 || off >= len) {\n\t\treturn NULL;\n\t}\n\treturn r_str_ndup ((const char *)p + off, len - off);\n}\n\nstatic void parseCodeDirectory(RBuffer *b, int offset, int datasize) {\n\ttypedef struct __CodeDirectory {\n\t\tuint32_t magic;\t\t/* magic number (CSMAGIC_CODEDIRECTORY) */\n\t\tuint32_t length;\t/* total length of CodeDirectory blob */\n\t\tuint32_t version;\t/* compatibility version */\n\t\tuint32_t flags;\t\t/* setup and mode flags */\n\t\tuint32_t hashOffset;\t/* offset of hash slot element at index zero */\n\t\tuint32_t identOffset;\t/* offset of identifier string */\n\t\tuint32_t nSpecialSlots;\t/* number of special hash slots */\n\t\tuint32_t nCodeSlots;\t/* number of ordinary (code) hash slots */\n\t\tuint32_t codeLimit;\t/* limit to main image signature range */\n\t\tuint8_t hashSize;\t/* size of each hash in bytes */\n\t\tuint8_t hashType;\t/* type of hash (cdHashType* constants) */\n\t\tuint8_t platform;\t/* unused (must be zero) */\n\t\tuint8_t\tpageSize;\t/* log2(page size in bytes); 0 => infinite */\n\t\tuint32_t spare2;\t/* unused (must be zero) */\n\t\t/* followed by dynamic content as located by offset fields above */\n\t\tuint32_t scatterOffset;\n\t\tuint32_t teamIDOffset;\n\t\tuint32_t spare3;\n\t\tut64 codeLimit64;\n\t\tut64 execSegBase;\n\t\tut64 execSegLimit;\n\t\tut64 execSegFlags;\n\t} CS_CodeDirectory;\n\tut64 off = offset;\n\tint psize = datasize;\n\tut8 *p = calloc (1, psize);\n\tif (!p) {\n\t\treturn;\n\t}\n\teprintf (\"Offset: 0x%08\"PFMT64x\"\\n\", off);\n\tr_buf_read_at (b, off, p, datasize);\n\tCS_CodeDirectory cscd = {0};\n\t#define READFIELD(x) cscd.x = r_read_ble32 (p + r_offsetof (CS_CodeDirectory, x), 1)\n\t#define READFIELD8(x) cscd.x = p[r_offsetof (CS_CodeDirectory, x)]\n\tREADFIELD (length);\n\tREADFIELD (version);\n\tREADFIELD (flags);\n\tREADFIELD (hashOffset);\n\tREADFIELD (identOffset);\n\tREADFIELD (nSpecialSlots);\n\tREADFIELD (nCodeSlots);\n\tREADFIELD (hashSize);\n\tREADFIELD (teamIDOffset);\n\tREADFIELD8 (hashType);\n\tREADFIELD (pageSize);\n\tREADFIELD (codeLimit);\n\teprintf (\"Version: %x\\n\", cscd.version);\n\teprintf (\"Flags: %x\\n\", cscd.flags);\n\teprintf (\"Length: %d\\n\", cscd.length);\n\teprintf (\"PageSize: %d\\n\", cscd.pageSize);\n\teprintf (\"hashOffset: %d\\n\", cscd.hashOffset);\n\teprintf (\"codeLimit: %d\\n\", cscd.codeLimit);\n\teprintf (\"hashSize: %d\\n\", cscd.hashSize);\n\teprintf (\"hashType: %d\\n\", cscd.hashType);\n\tchar *identity = readString (p, cscd.identOffset, psize);\n\teprintf (\"Identity: %s\\n\", identity);\n\tchar *teamId = readString (p, cscd.teamIDOffset, psize);\n\teprintf (\"TeamID: %s\\n\", teamId);\n\teprintf (\"CodeSlots: %d\\n\", cscd.nCodeSlots);\n\tfree (identity);\n\tfree (teamId);\n\n\tint hashSize = 20; // SHA1 is default\n\tint algoType = R_HASH_SHA1;\n\tconst char *hashName = \"sha1\";\n\tswitch (cscd.hashType) {\n\tcase 0: // SHA1 == 20 bytes\n\tcase 1: // SHA1 == 20 bytes\n\t\thashSize = 20;\n\t\thashName = \"sha1\";\n\t\talgoType = R_HASH_SHA1;\n\t\tbreak;\n\tcase 2: // SHA256 == 32 bytes\n\t\thashSize = 32;\n\t\talgoType = R_HASH_SHA256;\n\t\thashName = \"sha256\";\n\t\tbreak;\n\t}\n\t// computed cdhash\n\tRHash *ctx = r_hash_new (true, algoType);\n\tint fofsz = cscd.length;\n\tif (fofsz > 0 && fofsz < (r_buf_size (b) - off)) {\n\t\tut8 *fofbuf = calloc (fofsz, 1);\n\t\tif (fofbuf) {\n\t\t\tint i;\n\t\t\tif (r_buf_read_at (b, off, fofbuf, fofsz) != fofsz) {\n\t\t\t\teprintf (\"Invalid cdhash offset/length values\\n\");\n\t\t\t}\n\t\t\tr_hash_do_begin (ctx, algoType);\n\t\t\tif (algoType == R_HASH_SHA1) {\n\t\t\t\tr_hash_do_sha1 (ctx, fofbuf, fofsz);\n\t\t\t} else {\n\t\t\t\tr_hash_do_sha256 (ctx, fofbuf, fofsz);\n\t\t\t}\n\t\t\tr_hash_do_end (ctx, algoType);\n\t\t\teprintf (\"ph %s @ 0x%\"PFMT64x\"!%d\\n\", hashName, off, fofsz);\n\t\t\teprintf (\"ComputedCDHash: \");\n\t\t\tfor (i = 0; i < hashSize;i++) {\n\t\t\t\teprintf (\"%02x\", ctx->digest[i]);\n\t\t\t}\n\t\t\teprintf (\"\\n\");\n\t\t\tfree (fofbuf);\n\t\t}\n\t}\n\t// show and check the rest of hashes\n\tut8 *hash = p + cscd.hashOffset;\n\tint j = 0;\n\tint k = 0;\n\teprintf (\"Hashed region: 0x%08\"PFMT64x\" - 0x%08\"PFMT64x\"\\n\", (ut64)0, (ut64)cscd.codeLimit);\n\tfor (j = 0; j < cscd.nCodeSlots; j++) {\n\t\tint fof = 4096 * j;\n\t\tint idx = j * hashSize;\n\t\teprintf (\"0x%08\"PFMT64x\"  \", off + cscd.hashOffset + idx);\n\t\tfor (k = 0; k < hashSize; k++) {\n\t\t\teprintf (\"%02x\", hash[idx + k]);\n\t\t}\n\t\tut8 fofbuf[4096];\n\t\tint fofsz = R_MIN (sizeof (fofbuf), cscd.codeLimit - fof);\n\t\tr_buf_read_at (b, fof, fofbuf, sizeof (fofbuf));\n\t\tr_hash_do_begin (ctx, algoType);\n\t\tif (algoType == R_HASH_SHA1) {\n\t\t\tr_hash_do_sha1 (ctx, fofbuf, fofsz);\n\t\t} else {\n\t\t\tr_hash_do_sha256 (ctx, fofbuf, fofsz);\n\t\t}\n\t\tr_hash_do_end (ctx, algoType);\n\t\tif (memcmp (hash + idx, ctx->digest, hashSize)) {\n\t\t\teprintf (\"  wx \");\n\t\t\tint i;\n\t\t\tfor (i = 0; i < hashSize;i++) {\n\t\t\t\teprintf (\"%02x\", ctx->digest[i]);\n\t\t\t}\n\t\t} else {\n\t\t\teprintf (\"  OK\");\n\t\t}\n\t\teprintf (\"\\n\");\n\t}\n\tr_hash_free (ctx);\n\tfree (p);\n}\n\n// parse the Load Command\nstatic bool parse_signature(struct MACH0_(obj_t) *bin, ut64 off) {\n\tint i,len;\n\tut32 data;\n\tbin->signature = NULL;\n\tstruct linkedit_data_command link = {0};\n\tut8 lit[sizeof (struct linkedit_data_command)] = {0};\n\tstruct blob_index_t idx = {0};\n\tstruct super_blob_t super = {{0}};\n\n\tif (off > bin->size || off + sizeof (struct linkedit_data_command) > bin->size) {\n\t\treturn false;\n\t}\n\tlen = r_buf_read_at (bin->b, off, lit, sizeof (struct linkedit_data_command));\n\tif (len != sizeof (struct linkedit_data_command)) {\n\t\tbprintf (\"Failed to get data while parsing LC_CODE_SIGNATURE command\\n\");\n\t\treturn false;\n\t}\n\tlink.cmd = r_read_ble32 (&lit[0], bin->big_endian);\n\tlink.cmdsize = r_read_ble32 (&lit[4], bin->big_endian);\n\tlink.dataoff = r_read_ble32 (&lit[8], bin->big_endian);\n\tlink.datasize = r_read_ble32 (&lit[12], bin->big_endian);\n\n\tdata = link.dataoff;\n\tif (data > bin->size || data + sizeof (struct super_blob_t) > bin->size) {\n\t\tbin->signature = (ut8 *)strdup (\"Malformed entitlement\");\n\t\treturn true;\n\t}\n\tsuper.blob.magic = r_buf_read_ble32_at (bin->b, data, mach0_endian);\n\tsuper.blob.length = r_buf_read_ble32_at (bin->b, data + 4, mach0_endian);\n\tsuper.count = r_buf_read_ble32_at (bin->b, data + 8, mach0_endian);\n\tchar *verbose = r_sys_getenv (\"RABIN2_CODESIGN_VERBOSE\");\n\tbool isVerbose = false;\n\tif (verbose) {\n\t\tisVerbose = *verbose;\n\t\tfree (verbose);\n\t}\n\t// to dump all certificates\n\t// [0x00053f75]> b 5K;/x 30800609;wtf @@ hit*\n\t// then do this:\n\t// $ openssl asn1parse -inform der -in a|less\n\t// $ openssl pkcs7 -inform DER -print_certs -text -in a\n\tfor (i = 0; i < super.count; i++) {\n\t\tif (data + i > bin->size) {\n\t\t\tbin->signature = (ut8 *)strdup (\"Malformed entitlement\");\n\t\t\tbreak;\n\t\t}\n\t\tstruct blob_index_t bi;\n\t\tif (r_buf_read_at (bin->b, data + 12 + (i * sizeof (struct blob_index_t)),\n\t\t\t(ut8*)&bi, sizeof (struct blob_index_t)) < sizeof (struct blob_index_t)) {\n\t\t\tbreak;\n\t\t}\n\t\tidx.type = r_read_ble32 (&bi.type, mach0_endian);\n\t\tidx.offset = r_read_ble32 (&bi.offset, mach0_endian);\n\t\tswitch (idx.type) {\n\t\tcase CSSLOT_ENTITLEMENTS:\n\t\t\tif (true || isVerbose) {\n\t\t\t\tut64 off = data + idx.offset;\n\t\t\t\tif (off > bin->size || off + sizeof (struct blob_t) > bin->size) {\n\t\t\t\t\tbin->signature = (ut8 *)strdup (\"Malformed entitlement\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tstruct blob_t entitlements = {0};\n\t\t\t\tentitlements.magic = r_buf_read_ble32_at (bin->b, off, mach0_endian);\n\t\t\t\tentitlements.length = r_buf_read_ble32_at (bin->b, off + 4, mach0_endian);\n\t\t\t\tlen = entitlements.length - sizeof (struct blob_t);\n\t\t\t\tif (len <= bin->size && len > 1) {\n\t\t\t\t\tbin->signature = calloc (1, len + 1);\n\t\t\t\t\tif (!bin->signature) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (off + sizeof (struct blob_t) + len < r_buf_size (bin->b)) {\n\t\t\t\t\t\tr_buf_read_at (bin->b, off + sizeof (struct blob_t), (ut8 *)bin->signature, len);\n\t\t\t\t\t\tif (len >= 0) {\n\t\t\t\t\t\t\tbin->signature[len] = '\\0';\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbin->signature = (ut8 *)strdup (\"Malformed entitlement\");\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tbin->signature = (ut8 *)strdup (\"Malformed entitlement\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase CSSLOT_CODEDIRECTORY:\n\t\t\tif (isVerbose) {\n\t\t\t\tparseCodeDirectory (bin->b, data + idx.offset, link.datasize);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0x1000:\n\t\t\t// unknown\n\t\t\tbreak;\n\t\tcase CSSLOT_CMS_SIGNATURE: // ASN1/DER certificate\n\t\t\tif (isVerbose) {\n\t\t\t\tut8 header[8] = {0};\n\t\t\t\tr_buf_read_at (bin->b, data + idx.offset, header, sizeof (header));\n\t\t\t\tut32 length = R_MIN (UT16_MAX, r_read_ble32 (header + 4, 1));\n\t\t\t\tut8 *p = calloc (length, 1);\n\t\t\t\tif (p) {\n\t\t\t\t\tr_buf_read_at (bin->b, data + idx.offset + 0, p, length);\n\t\t\t\t\tut32 *words = (ut32*)p;\n\t\t\t\t\teprintf (\"Magic: %x\\n\", words[0]);\n\t\t\t\t\teprintf (\"wtf DUMP @%d!%d\\n\",\n\t\t\t\t\t\t(int)data + idx.offset + 8, (int)length);\n\t\t\t\t\teprintf (\"openssl pkcs7 -print_certs -text -inform der -in DUMP\\n\");\n\t\t\t\t\teprintf (\"openssl asn1parse -offset %d -length %d -inform der -in /bin/ls\\n\",\n\t\t\t\t\t\t(int)data + idx.offset + 8, (int)length);\n\t\t\t\t\teprintf (\"pFp@%d!%d\\n\",\n\t\t\t\t\t\t(int)data + idx.offset + 8, (int)length);\n\t\t\t\t\tfree (p);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase CSSLOT_REQUIREMENTS: // 2\n\t\t\t{\n\t\t\t\tut8 p[256];\n\t\t\t\tr_buf_read_at (bin->b, data + idx.offset + 16, p, sizeof (p));\n\t\t\t\tp[sizeof (p) - 1] = 0;\n\t\t\t\tut32 slot_size = r_read_ble32 (p + 8, 1);\n\t\t\t\tif (slot_size < sizeof (p)) {\n\t\t\t\t\tut32 ident_size = r_read_ble32 (p + 8, 1);\n\t\t\t\t\tif (!ident_size || ident_size > sizeof (p) - 28) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tchar *ident = r_str_ndup ((const char *)p + 28, ident_size);\n\t\t\t\t\tif (ident) {\n\t\t\t\t\t\tsdb_set (bin->kv, \"mach0.ident\", ident, 0);\n\t\t\t\t\t\tfree (ident);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (bin->verbose) {\n\t\t\t\t\t\teprintf (\"Invalid code slot size\\n\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase CSSLOT_INFOSLOT: // 1;\n\t\tcase CSSLOT_RESOURCEDIR: // 3;\n\t\tcase CSSLOT_APPLICATION: // 4;\n\t\t\t// TODO: parse those codesign slots\n\t\t\tif (bin->verbose) {\n\t\t\t\teprintf (\"TODO: Some codesign slots are not yet supported\\n\");\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (bin->verbose) {\n\t\t\t\teprintf (\"Unknown Code signature slot %d\\n\", idx.type);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!bin->signature) {\n\t\tbin->signature = (ut8 *)strdup (\"No entitlement found\");\n\t}\n\treturn true;\n}\n\nstatic int parse_thread(struct MACH0_(obj_t) *bin, struct load_command *lc, ut64 off, bool is_first_thread) {\n\tut64 ptr_thread, pc = UT64_MAX, pc_offset = UT64_MAX;\n\tut32 flavor, count;\n\tut8 *arw_ptr = NULL;\n\tint arw_sz, len = 0;\n\tut8 thc[sizeof (struct thread_command)] = {0};\n\tut8 tmp[4];\n\n\tif (off > bin->size || off + sizeof (struct thread_command) > bin->size) {\n\t\treturn false;\n\t}\n\n\tlen = r_buf_read_at (bin->b, off, thc, 8);\n\tif (len < 1) {\n\t\tgoto wrong_read;\n\t}\n\tbin->thread.cmd = r_read_ble32 (&thc[0], bin->big_endian);\n\tbin->thread.cmdsize = r_read_ble32 (&thc[4], bin->big_endian);\n\tif (r_buf_read_at (bin->b, off + sizeof (struct thread_command), tmp, 4) < 4) {\n\t\tgoto wrong_read;\n\t}\n\tflavor = r_read_ble32 (tmp, bin->big_endian);\n\n\tif (off + sizeof (struct thread_command) + sizeof (flavor) > bin->size ||\n\t\toff + sizeof (struct thread_command) + sizeof (flavor) + sizeof (ut32) > bin->size) {\n\t\treturn false;\n\t}\n\n\t// TODO: use count for checks\n\tif (r_buf_read_at (bin->b, off + sizeof (struct thread_command) + sizeof (flavor), tmp, 4) < 4) {\n\t\tgoto wrong_read;\n\t}\n\tcount = r_read_ble32 (tmp, bin->big_endian);\n\tptr_thread = off + sizeof (struct thread_command) + sizeof (flavor) + sizeof (count);\n\n\tif (ptr_thread > bin->size) {\n\t\treturn false;\n\t}\n\n\tswitch (bin->hdr.cputype) {\n\tcase CPU_TYPE_I386:\n\tcase CPU_TYPE_X86_64:\n\t\tswitch (flavor) {\n\t\tcase X86_THREAD_STATE32:\n\t\t\tif (ptr_thread + sizeof (struct x86_thread_state32) > bin->size) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (r_buf_fread_at (bin->b, ptr_thread,\n\t\t\t\t(ut8*)&bin->thread_state.x86_32, \"16i\", 1) == -1) {\n\t\t\t\tbprintf (\"Error: read (thread state x86_32)\\n\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tpc = bin->thread_state.x86_32.eip;\n\t\t\tpc_offset = ptr_thread + r_offsetof(struct x86_thread_state32, eip);\n\t\t\tarw_ptr = (ut8 *)&bin->thread_state.x86_32;\n\t\t\tarw_sz = sizeof (struct x86_thread_state32);\n\t\t\tbreak;\n\t\tcase X86_THREAD_STATE64:\n\t\t\tif (ptr_thread + sizeof (struct x86_thread_state64) > bin->size) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (r_buf_fread_at (bin->b, ptr_thread,\n\t\t\t\t(ut8*)&bin->thread_state.x86_64, \"32l\", 1) == -1) {\n\t\t\t\tbprintf (\"Error: read (thread state x86_64)\\n\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tpc = bin->thread_state.x86_64.rip;\n\t\t\tpc_offset = ptr_thread + r_offsetof(struct x86_thread_state64, rip);\n\t\t\tarw_ptr = (ut8 *)&bin->thread_state.x86_64;\n\t\t\tarw_sz = sizeof (struct x86_thread_state64);\n\t\t\tbreak;\n\t\t//default: bprintf (\"Unknown type\\n\");\n\t\t}\n\t\tbreak;\n\tcase CPU_TYPE_POWERPC:\n\tcase CPU_TYPE_POWERPC64:\n\t\tif (flavor == X86_THREAD_STATE32) {\n\t\t\tif (ptr_thread + sizeof (struct ppc_thread_state32) > bin->size) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (r_buf_fread_at (bin->b, ptr_thread,\n\t\t\t\t(ut8*)&bin->thread_state.ppc_32, bin->big_endian ? \"40I\" : \"40i\", 1) == -1) {\n\t\t\t\tbprintf (\"Error: read (thread state ppc_32)\\n\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tpc = bin->thread_state.ppc_32.srr0;\n\t\t\tpc_offset = ptr_thread + r_offsetof(struct ppc_thread_state32, srr0);\n\t\t\tarw_ptr = (ut8 *)&bin->thread_state.ppc_32;\n\t\t\tarw_sz = sizeof (struct ppc_thread_state32);\n\t\t} else if (flavor == X86_THREAD_STATE64) {\n\t\t\tif (ptr_thread + sizeof (struct ppc_thread_state64) > bin->size) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (r_buf_fread_at (bin->b, ptr_thread,\n\t\t\t\t(ut8*)&bin->thread_state.ppc_64, bin->big_endian ? \"34LI3LI\" : \"34li3li\", 1) == -1) {\n\t\t\t\tbprintf (\"Error: read (thread state ppc_64)\\n\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tpc = bin->thread_state.ppc_64.srr0;\n\t\t\tpc_offset = ptr_thread + r_offsetof(struct ppc_thread_state64, srr0);\n\t\t\tarw_ptr = (ut8 *)&bin->thread_state.ppc_64;\n\t\t\tarw_sz = sizeof (struct ppc_thread_state64);\n\t\t}\n\t\tbreak;\n\tcase CPU_TYPE_ARM:\n\t\tif (ptr_thread + sizeof (struct arm_thread_state32) > bin->size) {\n\t\t\treturn false;\n\t\t}\n\t\tif (r_buf_fread_at (bin->b, ptr_thread,\n\t\t\t(ut8*)&bin->thread_state.arm_32, bin->big_endian ? \"17I\" : \"17i\", 1) == -1) {\n\t\t\tbprintf (\"Error: read (thread state arm)\\n\");\n\t\t\treturn false;\n\t\t}\n\t\tpc = bin->thread_state.arm_32.r15;\n\t\tpc_offset = ptr_thread + r_offsetof (struct arm_thread_state32, r15);\n\t\tarw_ptr = (ut8 *)&bin->thread_state.arm_32;\n\t\tarw_sz = sizeof (struct arm_thread_state32);\n\t\tbreak;\n\tcase CPU_TYPE_ARM64:\n\t\tif (ptr_thread + sizeof (struct arm_thread_state64) > bin->size) {\n\t\t\treturn false;\n\t\t}\n\t\tif (r_buf_fread_at (bin->b, ptr_thread,\n\t\t\t(ut8*)&bin->thread_state.arm_64, bin->big_endian ? \"34LI1I\" : \"34Li1i\", 1) == -1) {\n\t\t\tbprintf (\"Error: read (thread state arm)\\n\");\n\t\t\treturn false;\n\t\t}\n\t\tpc = r_read_be64 (&bin->thread_state.arm_64.pc);\n\t\tpc_offset = ptr_thread + r_offsetof (struct arm_thread_state64, pc);\n\t\tarw_ptr = (ut8*)&bin->thread_state.arm_64;\n\t\tarw_sz = sizeof (struct arm_thread_state64);\n\t\tbreak;\n\tdefault:\n\t\tbprintf (\"Error: read (unknown thread state structure)\\n\");\n\t\treturn false;\n\t}\n\n\t// TODO: this shouldnt be an bprintf...\n\tif (arw_ptr && arw_sz > 0) {\n\t\tint i;\n\t\tut8 *p = arw_ptr;\n\t\tbprintf (\"arw \");\n\t\tfor (i = 0; i < arw_sz; i++) {\n\t\t\tbprintf (\"%02x\", 0xff & p[i]);\n\t\t}\n\t\tbprintf (\"\\n\");\n\t}\n\n\tif (is_first_thread) {\n\t\tbin->main_cmd = *lc;\n\t\tif (pc != UT64_MAX) {\n\t\t\tbin->entry = pc;\n\t\t}\n\t\tif (pc_offset != UT64_MAX) {\n\t\t\tsdb_num_set (bin->kv, \"mach0.entry.offset\", pc_offset, 0);\n\t\t}\n\t}\n\n\treturn true;\nwrong_read:\n\tbprintf (\"Error: read (thread)\\n\");\n\treturn false;\n}\n\nstatic int parse_function_starts(struct MACH0_(obj_t) *bin, ut64 off) {\n\tstruct linkedit_data_command fc;\n\tut8 sfc[sizeof (struct linkedit_data_command)] = {0};\n\tint len;\n\n\tif (off > bin->size || off + sizeof (struct linkedit_data_command) > bin->size) {\n\t\tbprintf (\"Likely overflow while parsing\"\n\t\t\t\" LC_FUNCTION_STARTS command\\n\");\n\t}\n\tbin->func_start = NULL;\n\tlen = r_buf_read_at (bin->b, off, sfc, sizeof (struct linkedit_data_command));\n\tif (len < 1) {\n\t\tbprintf (\"Failed to get data while parsing\"\n\t\t\t\" LC_FUNCTION_STARTS command\\n\");\n\t}\n\tfc.cmd = r_read_ble32 (&sfc[0], bin->big_endian);\n\tfc.cmdsize = r_read_ble32 (&sfc[4], bin->big_endian);\n\tfc.dataoff = r_read_ble32 (&sfc[8], bin->big_endian);\n\tfc.datasize = r_read_ble32 (&sfc[12], bin->big_endian);\n\n\tif ((int)fc.datasize > 0) {\n\t\tut8 *buf = calloc (1, fc.datasize + 1);\n\t\tif (!buf) {\n\t\t\tbprintf (\"Failed to allocate buffer\\n\");\n\t\t\treturn false;\n\t\t}\n\t\tbin->func_size = fc.datasize;\n\t\tif (fc.dataoff > bin->size || fc.dataoff + fc.datasize > bin->size) {\n\t\t\tfree (buf);\n\t\t\tbprintf (\"Likely overflow while parsing \"\n\t\t\t\t\"LC_FUNCTION_STARTS command\\n\");\n\t\t\treturn false;\n\t\t}\n\t\tlen = r_buf_read_at (bin->b, fc.dataoff, buf, fc.datasize);\n\t\tif (len != fc.datasize) {\n\t\t\tfree (buf);\n\t\t\tbprintf (\"Failed to get data while parsing\"\n\t\t\t\t\" LC_FUNCTION_STARTS\\n\");\n\t\t\treturn false;\n\t\t}\n\t\tbuf[fc.datasize] = 0; // null-terminated buffer\n\t\tbin->func_start = buf;\n\t\treturn true;\n\t}\n\tbin->func_start = NULL;\n\treturn false;\n\n}\n\nstatic int parse_dylib(struct MACH0_(obj_t) *bin, ut64 off) {\n\tstruct dylib_command dl;\n\tint lib, len;\n\tut8 sdl[sizeof (struct dylib_command)] = {0};\n\n\tif (off > bin->size || off + sizeof (struct dylib_command) > bin->size) {\n\t\treturn false;\n\t}\n\tlib = bin->nlibs - 1;\n\n\tvoid *relibs = realloc (bin->libs, bin->nlibs * R_BIN_MACH0_STRING_LENGTH);\n\tif (!relibs) {\n\t\tr_sys_perror (\"realloc (libs)\");\n\t\treturn false;\n\t}\n\tbin->libs = relibs;\n\tlen = r_buf_read_at (bin->b, off, sdl, sizeof (struct dylib_command));\n\tif (len < 1) {\n\t\tbprintf (\"Error: read (dylib)\\n\");\n\t\treturn false;\n\t}\n\tdl.cmd = r_read_ble32 (&sdl[0], bin->big_endian);\n\tdl.cmdsize = r_read_ble32 (&sdl[4], bin->big_endian);\n\tdl.dylib.name = r_read_ble32 (&sdl[8], bin->big_endian);\n\tdl.dylib.timestamp = r_read_ble32 (&sdl[12], bin->big_endian);\n\tdl.dylib.current_version = r_read_ble32 (&sdl[16], bin->big_endian);\n\tdl.dylib.compatibility_version = r_read_ble32 (&sdl[20], bin->big_endian);\n\n\tif (off + dl.dylib.name > bin->size ||\\\n\t  off + dl.dylib.name + R_BIN_MACH0_STRING_LENGTH > bin->size) {\n\t\treturn false;\n\t}\n\n\tmemset (bin->libs[lib], 0, R_BIN_MACH0_STRING_LENGTH);\n\tlen = r_buf_read_at (bin->b, off + dl.dylib.name,\n\t\t(ut8*)bin->libs[lib], R_BIN_MACH0_STRING_LENGTH - 1);\n\tbin->libs[lib][R_BIN_MACH0_STRING_LENGTH - 1] = 0;\n\tif (len < 1) {\n\t\tbprintf (\"Error: read (dylib str)\");\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nstatic const char *cmd_to_string(ut32 cmd) {\n\tswitch (cmd) {\n\tcase LC_DATA_IN_CODE:\n\t\treturn \"LC_DATA_IN_CODE\";\n\tcase LC_CODE_SIGNATURE:\n\t\treturn \"LC_CODE_SIGNATURE\";\n\tcase LC_RPATH:\n\t\treturn \"LC_RPATH\";\n\tcase LC_TWOLEVEL_HINTS:\n\t\treturn \"LC_TWOLEVEL_HINTS\";\n\tcase LC_PREBIND_CKSUM:\n\t\treturn \"LC_PREBIND_CKSUM\";\n\tcase LC_SEGMENT:\n\t\treturn \"LC_SEGMENT\";\n\tcase LC_SEGMENT_64:\n\t\treturn \"LC_SEGMENT_64\";\n\tcase LC_SYMTAB:\n\t\treturn \"LC_SYMTAB\";\n\tcase LC_SYMSEG:\n\t\treturn \"LC_SYMSEG\";\n\tcase LC_DYSYMTAB:\n\t\treturn \"LC_DYSYMTAB\";\n\tcase LC_PREBOUND_DYLIB:\n\t\treturn \"LC_PREBOUND_DYLIB\";\n\tcase LC_ROUTINES:\n\t\treturn \"LC_ROUTINES\";\n\tcase LC_ROUTINES_64:\n\t\treturn \"LC_ROUTINES_64\";\n\tcase LC_SUB_FRAMEWORK:\n\t\treturn \"LC_SUB_FRAMEWORK\";\n\tcase LC_SUB_UMBRELLA:\n\t\treturn \"LC_SUB_UMBRELLA\";\n\tcase LC_SUB_CLIENT:\n\t\treturn \"LC_SUB_CLIENT\";\n\tcase LC_SUB_LIBRARY:\n\t\treturn \"LC_SUB_LIBRARY\";\n\tcase LC_FUNCTION_STARTS:\n\t\treturn \"LC_FUNCTION_STARTS\";\n\tcase LC_DYLIB_CODE_SIGN_DRS:\n\t\treturn \"LC_DYLIB_CODE_SIGN_DRS\";\n\tcase LC_NOTE:\n\t\treturn \"LC_NOTE\";\n\tcase LC_BUILD_VERSION:\n\t\treturn \"LC_BUILD_VERSION\";\n\tcase LC_VERSION_MIN_MACOSX:\n\t\treturn \"LC_VERSION_MIN_MACOSX\";\n\tcase LC_VERSION_MIN_IPHONEOS:\n\t\treturn \"LC_VERSION_MIN_IPHONEOS\";\n\tcase LC_VERSION_MIN_TVOS:\n\t\treturn \"LC_VERSION_MIN_TVOS\";\n\tcase LC_VERSION_MIN_WATCHOS:\n\t\treturn \"LC_VERSION_MIN_WATCHOS\";\n\tcase LC_DYLD_INFO:\n\t\treturn \"LC_DYLD_INFO\";\n\tcase LC_DYLD_INFO_ONLY:\n\t\treturn \"LC_DYLD_INFO_ONLY\";\n\tcase LC_DYLD_ENVIRONMENT:\n\t\treturn \"LC_DYLD_ENVIRONMENT\";\n\tcase LC_SOURCE_VERSION:\n\t\treturn \"LC_SOURCE_VERSION\";\n\tcase LC_MAIN:\n\t\treturn \"LC_MAIN\";\n\tcase LC_UUID:\n\t\treturn \"LC_UUID\";\n\tcase LC_ID_DYLIB:\n\t\treturn \"LC_ID_DYLIB\";\n\tcase LC_ID_DYLINKER:\n\t\treturn \"LC_ID_DYLINKER\";\n\tcase LC_LAZY_LOAD_DYLIB:\n\t\treturn \"LC_LAZY_LOAD_DYLIB\";\n\tcase LC_ENCRYPTION_INFO:\n\t\treturn \"LC_ENCRYPTION_INFO\";\n\tcase LC_ENCRYPTION_INFO_64:\n\t\treturn \"LC_ENCRYPTION_INFO_64\";\n\tcase LC_SEGMENT_SPLIT_INFO:\n\t\treturn \"LC_SEGMENT_SPLIT_INFO\";\n\tcase LC_REEXPORT_DYLIB:\n\t\treturn \"LC_REEXPORT_DYLIB\";\n\tcase LC_LINKER_OPTION:\n\t\treturn \"LC_LINKER_OPTION\";\n\tcase LC_LINKER_OPTIMIZATION_HINT:\n\t\treturn \"LC_LINKER_OPTIMIZATION_HINT\";\n\tcase LC_LOAD_DYLINKER:\n\t\treturn \"LC_LOAD_DYLINKER\";\n\tcase LC_LOAD_DYLIB:\n\t\treturn \"LC_LOAD_DYLIB\";\n\tcase LC_LOAD_WEAK_DYLIB:\n\t\treturn \"LC_LOAD_WEAK_DYLIB\";\n\tcase LC_THREAD:\n\t\treturn \"LC_THREAD\";\n\tcase LC_UNIXTHREAD:\n\t\treturn \"LC_UNIXTHREAD\";\n\tcase LC_LOADFVMLIB:\n\t\treturn \"LC_LOADFVMLIB\";\n\tcase LC_IDFVMLIB:\n\t\treturn \"LC_IDFVMLIB\";\n\tcase LC_IDENT:\n\t\treturn \"LC_IDENT\";\n\tcase LC_FVMFILE:\n\t\treturn \"LC_FVMFILE\";\n\tcase LC_PREPAGE:\n\t\treturn \"LC_PREPAGE\";\n\t}\n\treturn \"\";\n}\n\nstatic const char *cmd_to_pf_definition(ut32 cmd) {\n\tswitch (cmd) {\n\tcase LC_BUILD_VERSION:\n\t\treturn \"mach0_build_version_command\";\n\tcase LC_CODE_SIGNATURE:\n\t\treturn \"mach0_code_signature_command\";\n\tcase LC_DATA_IN_CODE:\n\t\treturn \"mach0_data_in_code_command\";\n\tcase LC_DYLD_INFO:\n\tcase LC_DYLD_INFO_ONLY:\n\t\treturn \"mach0_dyld_info_only_command\";\n\tcase LC_DYLD_ENVIRONMENT:\n\t\treturn NULL;\n\tcase LC_DYLIB_CODE_SIGN_DRS:\n\t\treturn NULL;\n\tcase LC_DYSYMTAB:\n\t\treturn \"mach0_dysymtab_command\";\n\tcase LC_ENCRYPTION_INFO:\n\t\treturn \"mach0_encryption_info_command\";\n\tcase LC_ENCRYPTION_INFO_64:\n\t\treturn \"mach0_encryption_info64_command\";\n\tcase LC_FUNCTION_STARTS:\n\t\treturn \"mach0_function_starts_command\";\n\tcase LC_FVMFILE:\n\t\treturn NULL;\n\tcase LC_ID_DYLIB:\n\t\treturn \"mach0_id_dylib_command\";\n\tcase LC_ID_DYLINKER:\n\t\treturn \"mach0_id_dylinker_command\";\n\tcase LC_IDENT:\n\t\treturn NULL;\n\tcase LC_IDFVMLIB:\n\t\treturn NULL;\n\tcase LC_LINKER_OPTION:\n\t\treturn NULL;\n\tcase LC_LINKER_OPTIMIZATION_HINT:\n\t\treturn NULL;\n\tcase LC_LOAD_DYLINKER:\n\t\treturn \"mach0_load_dylinker_command\";\n\tcase LC_LAZY_LOAD_DYLIB:\n\tcase LC_LOAD_WEAK_DYLIB:\n\tcase LC_LOAD_DYLIB:\n\t\treturn \"mach0_dylib_command\";\n\tcase LC_LOADFVMLIB:\n\t\treturn NULL;\n\tcase LC_MAIN:\n\t\treturn \"mach0_entry_point_command\";\n\tcase LC_NOTE:\n\t\treturn NULL;\n\tcase LC_PREBIND_CKSUM:\n\t\treturn NULL;\n\tcase LC_PREBOUND_DYLIB:\n\t\treturn NULL;\n\tcase LC_PREPAGE:\n\t\treturn NULL;\n\tcase LC_REEXPORT_DYLIB:\n\t\treturn NULL;\n\tcase LC_ROUTINES:\n\t\treturn NULL;\n\tcase LC_ROUTINES_64:\n\t\treturn NULL;\n\tcase LC_RPATH:\n\t\treturn \"mach0_rpath_command\";\n\tcase LC_SEGMENT:\n\t\treturn \"mach0_segment\";\n\tcase LC_SEGMENT_64:\n\t\treturn \"mach0_segment64\";\n\tcase LC_SEGMENT_SPLIT_INFO:\n\t\treturn \"mach0_segment_split_info_command\";\n\tcase LC_SOURCE_VERSION:\n\t\treturn \"mach0_source_version_command\";\n\tcase LC_SUB_FRAMEWORK:\n\t\treturn NULL;\n\tcase LC_SUB_UMBRELLA:\n\t\treturn NULL;\n\tcase LC_SUB_CLIENT:\n\t\treturn NULL;\n\tcase LC_SUB_LIBRARY:\n\t\treturn NULL;\n\tcase LC_SYMTAB:\n\t\treturn \"mach0_symtab_command\";\n\tcase LC_SYMSEG:\n\t\treturn NULL;\n\tcase LC_TWOLEVEL_HINTS:\n\t\treturn NULL;\n\tcase LC_UUID:\n\t\treturn \"mach0_uuid_command\";\n\tcase LC_VERSION_MIN_MACOSX:\n\tcase LC_VERSION_MIN_IPHONEOS:\n\tcase LC_VERSION_MIN_TVOS:\n\tcase LC_VERSION_MIN_WATCHOS:\n\t\treturn \"mach0_version_min_command\";\n\tcase LC_THREAD:\n\t\treturn NULL;\n\tcase LC_UNIXTHREAD:\n\t\treturn \"mach0_unixthread_command\";\n\t}\n\treturn NULL;\n}\n\nstatic const char *build_version_platform_to_string(ut32 platform) {\n\tswitch (platform) {\n\tcase 1:\n\t\treturn \"macOS\";\n\tcase 2:\n\t\treturn \"iOS\";\n\tcase 3:\n\t\treturn \"tvOS\";\n\tcase 4:\n\t\treturn \"watchOS\";\n\tcase 5:\n\t\treturn \"bridgeOS\";\n\tcase 6:\n\t\treturn \"iOSmac\";\n\tcase 7:\n\t\treturn \"iOS Simulator\";\n\tcase 8:\n\t\treturn \"tvOS Simulator\";\n\tcase 9:\n\t\treturn \"watchOS Simulator\";\n\tdefault:\n\t\treturn \"unknown\";\n\t}\n}\n\nstatic const char *build_version_tool_to_string(ut32 tool) {\n\tswitch (tool) {\n\tcase 1:\n\t\treturn \"clang\";\n\tcase 2:\n\t\treturn \"swift\";\n\tcase 3:\n\t\treturn \"ld\";\n\tdefault:\n\t\treturn \"unknown\";\n\t}\n}\n\nstatic size_t get_word_size(struct MACH0_(obj_t) *bin) {\n\tconst size_t word_size = MACH0_(get_bits)(bin) / 8;\n\treturn R_MAX (word_size, 4);\n}\n\nstatic bool parse_chained_fixups(struct MACH0_(obj_t) *bin, ut32 offset, ut32 size) {\n\tstruct dyld_chained_fixups_header header;\n\tif (size < sizeof (header)) {\n\t\treturn false;\n\t}\n\tif (r_buf_fread_at (bin->b, offset, (ut8 *)&header, \"7i\", 1) != sizeof (header)) {\n\t\treturn false;\n\t}\n\tif (header.fixups_version > 0) {\n\t\teprintf (\"Unsupported fixups version: %u\\n\", header.fixups_version);\n\t\treturn false;\n\t}\n\tut64 starts_at = offset + header.starts_offset;\n\tif (header.starts_offset > size) {\n\t\treturn false;\n\t}\n\tut32 segs_count = r_buf_read_le32_at (bin->b, starts_at);\n\tif (segs_count == UT32_MAX || segs_count == 0) {\n\t\treturn false;\n\t}\n\tbin->segs_count = segs_count;\n\tbin->chained_starts = R_NEWS0 (struct r_dyld_chained_starts_in_segment *, segs_count);\n\tif (!bin->chained_starts) {\n\t\treturn false;\n\t}\n\tbin->fixups_header = header;\n\tbin->fixups_offset = offset;\n\tbin->fixups_size = size;\n\tsize_t i;\n\tut64 cursor = starts_at + sizeof (ut32);\n\tut64 bsize = r_buf_size (bin->b);\n\tfor (i = 0; i < segs_count && cursor + 4 < bsize; i++) {\n\t\tut32 seg_off;\n\t\tif ((seg_off = r_buf_read_le32_at (bin->b, cursor)) == UT32_MAX || !seg_off) {\n\t\t\tcursor += sizeof (ut32);\n\t\t\tcontinue;\n\t\t}\n\t\tif (i >= bin->nsegs) {\n\t\t\tbreak;\n\t\t}\n\t\tstruct r_dyld_chained_starts_in_segment *cur_seg = R_NEW0 (struct r_dyld_chained_starts_in_segment);\n\t\tif (!cur_seg) {\n\t\t\treturn false;\n\t\t}\n\t\tbin->chained_starts[i] = cur_seg;\n\t\tif (r_buf_fread_at (bin->b, starts_at + seg_off, (ut8 *)cur_seg, \"isslis\", 1) != 22) {\n\t\t\treturn false;\n\t\t}\n\t\tif (cur_seg->page_count > 0) {\n\t\t\tut16 *page_start = malloc (sizeof (ut16) * cur_seg->page_count);\n\t\t\tif (!page_start) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (r_buf_fread_at (bin->b, starts_at + seg_off + 22, (ut8 *)page_start, \"s\", cur_seg->page_count)\n\t\t\t\t\t!= cur_seg->page_count * 2) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tcur_seg->page_start = page_start;\n\t\t}\n\t\tcursor += sizeof (ut32);\n\t}\n\t/* TODO: handle also imports, symbols and multiple starts (32-bit only) */\n\treturn true;\n}\n\nstatic bool reconstruct_chained_fixup(struct MACH0_(obj_t) *bin) {\n\tif (!bin->dyld_info) {\n\t\treturn false;\n\t}\n\tif (!bin->nsegs) {\n\t\treturn false;\n\t}\n\tbin->chained_starts = R_NEWS0 (struct r_dyld_chained_starts_in_segment *, bin->nsegs);\n\tif (!bin->chained_starts) {\n\t\treturn false;\n\t}\n\tsize_t wordsize = get_word_size (bin);\n\tut8 *p = NULL;\n\tsize_t j, count, skip, bind_size;\n\tint seg_idx = 0;\n\tut64 seg_off = 0;\n\tbind_size = bin->dyld_info->bind_size;\n\tif (!bind_size || bind_size < 1) {\n\t\treturn false;\n\t}\n\tif (bin->dyld_info->bind_off > bin->size) {\n\t\treturn false;\n\t}\n\tif (bin->dyld_info->bind_off + bind_size > bin->size) {\n\t\treturn false;\n\t}\n\tut8 *opcodes = calloc (1, bind_size + 1);\n\tif (!opcodes) {\n\t\treturn false;\n\t}\n\tif (r_buf_read_at (bin->b, bin->dyld_info->bind_off, opcodes, bind_size) != bind_size) {\n\t\tbprintf (\"Error: read (dyld_info bind) at 0x%08\"PFMT64x\"\\n\", (ut64)(size_t)bin->dyld_info->bind_off);\n\t\tR_FREE (opcodes);\n\t\treturn false;\n\t}\n\tstruct r_dyld_chained_starts_in_segment *cur_seg = NULL;\n\tsize_t cur_seg_idx = 0;\n\tut8 *end;\n\tbool done = false;\n\tfor (p = opcodes, end = opcodes + bind_size; !done && p < end;) {\n\t\tut8 imm = *p & BIND_IMMEDIATE_MASK, op = *p & BIND_OPCODE_MASK;\n\t\tp++;\n\t\tswitch (op) {\n\t\tcase BIND_OPCODE_DONE:\n\t\t\tdone = true;\n\t\t\tbreak;\n\t\tcase BIND_OPCODE_THREADED: {\n\t\t\tswitch (imm) {\n\t\t\tcase BIND_SUBOPCODE_THREADED_SET_BIND_ORDINAL_TABLE_SIZE_ULEB: {\n\t\t\t\tread_uleb128 (&p, end);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase BIND_SUBOPCODE_THREADED_APPLY: {\n\t\t\t\tconst size_t ps = 0x1000;\n\t\t\t\tif (!cur_seg || cur_seg_idx != seg_idx) {\n\t\t\t\t\tcur_seg_idx = seg_idx;\n\t\t\t\t\tcur_seg = bin->chained_starts[seg_idx];\n\t\t\t\t\tif (!cur_seg) {\n\t\t\t\t\t\tcur_seg = R_NEW0 (struct r_dyld_chained_starts_in_segment);\n\t\t\t\t\t\tif (!cur_seg) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbin->chained_starts[seg_idx] = cur_seg;\n\t\t\t\t\t\tcur_seg->pointer_format = DYLD_CHAINED_PTR_ARM64E;\n\t\t\t\t\t\tcur_seg->page_size = ps;\n\t\t\t\t\t\tcur_seg->page_count = ((bin->segs[seg_idx].vmsize + (ps - 1)) & ~(ps - 1)) / ps;\n\t\t\t\t\t\tif (cur_seg->page_count > 0) {\n\t\t\t\t\t\t\tcur_seg->page_start = malloc (sizeof (ut16) * cur_seg->page_count);\n\t\t\t\t\t\t\tif (!cur_seg->page_start) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tmemset (cur_seg->page_start, 0xff, sizeof (ut16) * cur_seg->page_count);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (cur_seg) {\n\t\t\t\t\tut32 page_index = (ut32)(seg_off / ps);\n\t\t\t\t\tsize_t maxsize = cur_seg->page_count * sizeof (ut16);\n\t\t\t\t\tif (page_index < maxsize && cur_seg->page_start) {\n\t\t\t\t\t\tcur_seg->page_start[page_index] = seg_off & 0xfff;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdefault:\n\t\t\t\tbprintf (\"Error: Unexpected BIND_OPCODE_THREADED sub-opcode: 0x%x\\n\", imm);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase BIND_OPCODE_SET_DYLIB_ORDINAL_IMM:\n\t\tcase BIND_OPCODE_SET_DYLIB_SPECIAL_IMM:\n\t\tcase BIND_OPCODE_SET_TYPE_IMM:\n\t\t\tbreak;\n\t\tcase BIND_OPCODE_SET_DYLIB_ORDINAL_ULEB:\n\t\t\tread_uleb128 (&p, end);\n\t\t\tbreak;\n\t\tcase BIND_OPCODE_SET_SYMBOL_TRAILING_FLAGS_IMM:\n\t\t\twhile (*p++ && p < end) {\n\t\t\t\t/* empty loop */\n\t\t\t}\n\t\t\tbreak;\n\t\tcase BIND_OPCODE_SET_ADDEND_SLEB:\n\t\t\tr_sleb128 ((const ut8 **)&p, end);\n\t\t\tbreak;\n\t\tcase BIND_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB:\n\t\t\tseg_idx = imm;\n\t\t\tif (seg_idx >= bin->nsegs) {\n\t\t\t\tbprintf (\"Error: BIND_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB\"\n\t\t\t\t\t\" has unexistent segment %d\\n\", seg_idx);\n\t\t\t\tR_FREE (opcodes);\n\t\t\t\treturn false;\n\t\t\t} else {\n\t\t\t\tseg_off = read_uleb128 (&p, end);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase BIND_OPCODE_ADD_ADDR_ULEB:\n\t\t\tseg_off += read_uleb128 (&p, end);\n\t\t\tbreak;\n\t\tcase BIND_OPCODE_DO_BIND:\n\t\t\tbreak;\n\t\tcase BIND_OPCODE_DO_BIND_ADD_ADDR_ULEB:\n\t\t\tseg_off += read_uleb128 (&p, end) + wordsize;\n\t\t\tbreak;\n\t\tcase BIND_OPCODE_DO_BIND_ADD_ADDR_IMM_SCALED:\n\t\t\tseg_off += (ut64)imm * (ut64)wordsize + wordsize;\n\t\t\tbreak;\n\t\tcase BIND_OPCODE_DO_BIND_ULEB_TIMES_SKIPPING_ULEB:\n\t\t\tcount = read_uleb128 (&p, end);\n\t\t\tskip = read_uleb128 (&p, end);\n\t\t\tfor (j = 0; j < count; j++) {\n\t\t\t\tseg_off += skip + wordsize;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbprintf (\"Error: unknown bind opcode 0x%02x in dyld_info\\n\", *p);\n\t\t\tR_FREE (opcodes);\n\t\t\treturn false;\n\t\t}\n\t}\n\tR_FREE (opcodes);\n\n\tbin->segs_count = bin->nsegs;\n\treturn true;\n}\n\nstatic int init_items(struct MACH0_(obj_t) *bin) {\n\tstruct load_command lc = {0, 0};\n\tut8 loadc[sizeof (struct load_command)] = {0};\n\tbool is_first_thread = true;\n\tut64 off = 0LL;\n\tint i, len;\n\tchar cmd_flagname[128];\n\n\tbin->uuidn = 0;\n\tbin->os = 0;\n\tbin->has_crypto = 0;\n\tif (bin->hdr.sizeofcmds > bin->size) {\n\t\tbprintf (\"Warning: chopping hdr.sizeofcmds\\n\");\n\t\tbin->hdr.sizeofcmds = bin->size - 128;\n\t\t//return false;\n\t}\n\t//bprintf (\"Commands: %d\\n\", bin->hdr.ncmds);\n\tfor (i = 0, off = sizeof (struct MACH0_(mach_header)) + bin->header_at; \\\n\t\t\ti < bin->hdr.ncmds; i++, off += lc.cmdsize) {\n\t\tif (off > bin->size || off + sizeof (struct load_command) > bin->size) {\n\t\t\tbprintf (\"mach0: out of bounds command\\n\");\n\t\t\treturn false;\n\t\t}\n\t\tlen = r_buf_read_at (bin->b, off, loadc, sizeof (struct load_command));\n\t\tif (len < 1) {\n\t\t\tbprintf (\"Error: read (lc) at 0x%08\"PFMT64x\"\\n\", off);\n\t\t\treturn false;\n\t\t}\n\t\tlc.cmd = r_read_ble32 (&loadc[0], bin->big_endian);\n\t\tlc.cmdsize = r_read_ble32 (&loadc[4], bin->big_endian);\n\n\t\tif (lc.cmdsize < 1 || off + lc.cmdsize > bin->size) {\n\t\t\tbprintf (\"Warning: mach0_header %d = cmdsize<1. (0x%\"PFMT64x\" vs 0x%\"PFMT64x\")\\n\", i,\n\t\t\t\t(ut64)(off + lc.cmdsize), (ut64)(bin->size));\n\t\t\tbreak;\n\t\t}\n\t\tsnprintf (cmd_flagname, sizeof (cmd_flagname), \"mach0_cmd_%d.offset\", i);\n\t\tsdb_num_set (bin->kv, cmd_flagname, off, 0);\n\t\tconst char *format_name = cmd_to_pf_definition (lc.cmd);\n\t\tsnprintf (cmd_flagname, sizeof (cmd_flagname), \"mach0_cmd_%d.format\", i);\n\t\tif (format_name) {\n\t\t\tsdb_set (bin->kv, cmd_flagname, format_name, 0);\n\t\t} else {\n\t\t\tsdb_set (bin->kv, cmd_flagname, \"[4]Ed (mach_load_command_type)cmd size\", 0);\n\t\t}\n\n\t\tsnprintf (cmd_flagname, sizeof (cmd_flagname), \"mach0_cmd_%d.cmd\", i);\n\t\tswitch (lc.cmd) {\n\t\tcase LC_DATA_IN_CODE:\n\t\t\tsdb_set (bin->kv, cmd_flagname, \"data_in_code\", 0);\n\t\t\tbreak;\n\t\tcase LC_RPATH:\n\t\t\tsdb_set (bin->kv, cmd_flagname, \"rpath\", 0);\n\t\t\t//bprintf (\"--->\\n\");\n\t\t\tbreak;\n\t\tcase LC_SEGMENT_64:\n\t\tcase LC_SEGMENT:\n\t\t\tsdb_set (bin->kv, cmd_flagname, \"segment\", 0);\n\t\t\tbin->nsegs++;\n\t\t\tif (!parse_segments (bin, off)) {\n\t\t\t\tbprintf (\"error parsing segment\\n\");\n\t\t\t\tbin->nsegs--;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LC_SYMTAB:\n\t\t\tsdb_set (bin->kv, cmd_flagname, \"symtab\", 0);\n\t\t\tif (!parse_symtab (bin, off)) {\n\t\t\t\tbprintf (\"error parsing symtab\\n\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LC_DYSYMTAB:\n\t\t\tsdb_set (bin->kv, cmd_flagname, \"dysymtab\", 0);\n\t\t\tif (!parse_dysymtab (bin, off)) {\n\t\t\t\tbprintf (\"error parsing dysymtab\\n\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LC_DYLIB_CODE_SIGN_DRS:\n\t\t\tsdb_set (bin->kv, cmd_flagname, \"dylib_code_sign_drs\", 0);\n\t\t\t//bprintf (\"[mach0] code is signed\\n\");\n\t\t\tbreak;\n\t\tcase LC_VERSION_MIN_MACOSX:\n\t\t\tsdb_set (bin->kv, cmd_flagname, \"version_min_macosx\", 0);\n\t\t\tbin->os = 1;\n\t\t\t// set OS = osx\n\t\t\t//bprintf (\"[mach0] Requires OSX >= x\\n\");\n\t\t\tbreak;\n\t\tcase LC_VERSION_MIN_IPHONEOS:\n\t\t\tsdb_set (bin->kv, cmd_flagname, \"version_min_iphoneos\", 0);\n\t\t\tbin->os = 2;\n\t\t\t// set OS = ios\n\t\t\t//bprintf (\"[mach0] Requires iOS >= x\\n\");\n\t\t\tbreak;\n\t\tcase LC_VERSION_MIN_TVOS:\n\t\t\tsdb_set (bin->kv, cmd_flagname, \"version_min_tvos\", 0);\n\t\t\tbin->os = 4;\n\t\t\tbreak;\n\t\tcase LC_VERSION_MIN_WATCHOS:\n\t\t\tsdb_set (bin->kv, cmd_flagname, \"version_min_watchos\", 0);\n\t\t\tbin->os = 3;\n\t\t\tbreak;\n\t\tcase LC_UUID:\n\t\t\tsdb_set (bin->kv, cmd_flagname, \"uuid\", 0);\n\t\t\t{\n\t\t\tstruct uuid_command uc = {0};\n\t\t\tif (off + sizeof (struct uuid_command) > bin->size) {\n\t\t\t\tbprintf (\"UUID out of bounds\\n\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (r_buf_fread_at (bin->b, off, (ut8*)&uc, \"24c\", 1) != -1) {\n\t\t\t\tchar key[128];\n\t\t\t\tchar val[128];\n\t\t\t\tsnprintf (key, sizeof (key)-1, \"uuid.%d\", bin->uuidn++);\n\t\t\t\tr_hex_bin2str ((ut8*)&uc.uuid, 16, val);\n\t\t\t\tsdb_set (bin->kv, key, val, 0);\n\t\t\t\t//for (i=0;i<16; i++) bprintf (\"%02x%c\", uc.uuid[i], (i==15)?'\\n':'-');\n\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LC_ENCRYPTION_INFO_64:\n\t\t\t/* TODO: the struct is probably different here */\n\t\tcase LC_ENCRYPTION_INFO:\n\t\t\tsdb_set (bin->kv, cmd_flagname, \"encryption_info\", 0);\n\t\t\t{\n\t\t\tstruct MACH0_(encryption_info_command) eic = {0};\n\t\t\tut8 seic[sizeof (struct MACH0_(encryption_info_command))] = {0};\n\t\t\tif (off + sizeof (struct MACH0_(encryption_info_command)) > bin->size) {\n\t\t\t\tbprintf (\"encryption info out of bounds\\n\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (r_buf_read_at (bin->b, off, seic, sizeof (struct MACH0_(encryption_info_command))) != -1) {\n\t\t\t\teic.cmd = r_read_ble32 (&seic[0], bin->big_endian);\n\t\t\t\teic.cmdsize = r_read_ble32 (&seic[4], bin->big_endian);\n\t\t\t\teic.cryptoff = r_read_ble32 (&seic[8], bin->big_endian);\n\t\t\t\teic.cryptsize = r_read_ble32 (&seic[12], bin->big_endian);\n\t\t\t\teic.cryptid = r_read_ble32 (&seic[16], bin->big_endian);\n\n\t\t\t\tbin->has_crypto = eic.cryptid;\n\t\t\t\tsdb_set (bin->kv, \"crypto\", \"true\", 0);\n\t\t\t\tsdb_num_set (bin->kv, \"cryptid\", eic.cryptid, 0);\n\t\t\t\tsdb_num_set (bin->kv, \"cryptoff\", eic.cryptoff, 0);\n\t\t\t\tsdb_num_set (bin->kv, \"cryptsize\", eic.cryptsize, 0);\n\t\t\t\tsdb_num_set (bin->kv, \"cryptheader\", off, 0);\n\t\t\t} }\n\t\t\tbreak;\n\t\tcase LC_LOAD_DYLINKER:\n\t\t\t{\n\t\t\t\tsdb_set (bin->kv, cmd_flagname, \"dylinker\", 0);\n\t\t\t\tR_FREE (bin->intrp);\n\t\t\t\t//bprintf (\"[mach0] load dynamic linker\\n\");\n\t\t\t\tstruct dylinker_command dy = {0};\n\t\t\t\tut8 sdy[sizeof (struct dylinker_command)] = {0};\n\t\t\t\tif (off + sizeof (struct dylinker_command) > bin->size){\n\t\t\t\t\tbprintf (\"Warning: Cannot parse dylinker command\\n\");\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tif (r_buf_read_at (bin->b, off, sdy, sizeof (struct dylinker_command)) == -1) {\n\t\t\t\t\tbprintf (\"Warning: read (LC_DYLD_INFO) at 0x%08\"PFMT64x\"\\n\", off);\n\t\t\t\t} else {\n\t\t\t\t\tdy.cmd = r_read_ble32 (&sdy[0], bin->big_endian);\n\t\t\t\t\tdy.cmdsize = r_read_ble32 (&sdy[4], bin->big_endian);\n\t\t\t\t\tdy.name = r_read_ble32 (&sdy[8], bin->big_endian);\n\n\t\t\t\t\tint len = dy.cmdsize;\n\t\t\t\t\tchar *buf = malloc (len+1);\n\t\t\t\t\tif (buf) {\n\t\t\t\t\t\t// wtf @ off + 0xc ?\n\t\t\t\t\t\tr_buf_read_at (bin->b, off + 0xc, (ut8*)buf, len);\n\t\t\t\t\t\tbuf[len] = 0;\n\t\t\t\t\t\tfree (bin->intrp);\n\t\t\t\t\t\tbin->intrp = buf;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LC_MAIN:\n\t\t\t{\n\t\t\tstruct {\n\t\t\t\tut64 eo;\n\t\t\t\tut64 ss;\n\t\t\t} ep = {0};\n\t\t\tut8 sep[2 * sizeof (ut64)] = {0};\n\t\t\tsdb_set (bin->kv, cmd_flagname, \"main\", 0);\n\n\t\t\tif (!is_first_thread) {\n\t\t\t\tbprintf (\"Error: LC_MAIN with other threads\\n\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (off + 8 > bin->size || off + sizeof (ep) > bin->size) {\n\t\t\t\tbprintf (\"invalid command size for main\\n\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tr_buf_read_at (bin->b, off + 8, sep, 2 * sizeof (ut64));\n\t\t\tep.eo = r_read_ble64 (&sep[0], bin->big_endian);\n\t\t\tep.ss = r_read_ble64 (&sep[8], bin->big_endian);\n\n\t\t\tbin->entry = ep.eo;\n\t\t\tbin->main_cmd = lc;\n\n\t\t\tsdb_num_set (bin->kv, \"mach0.entry.offset\", off + 8, 0);\n\t\t\tsdb_num_set (bin->kv, \"stacksize\", ep.ss, 0);\n\n\t\t\tis_first_thread = false;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LC_UNIXTHREAD:\n\t\t\tsdb_set (bin->kv, cmd_flagname, \"unixthread\", 0);\n\t\t\tif (!is_first_thread) {\n\t\t\t\tbprintf (\"Error: LC_UNIXTHREAD with other threads\\n\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\tcase LC_THREAD:\n\t\t\tsdb_set (bin->kv, cmd_flagname, \"thread\", 0);\n\t\t\tif (!parse_thread (bin, &lc, off, is_first_thread)) {\n\t\t\t\tbprintf (\"Cannot parse thread\\n\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tis_first_thread = false;\n\t\t\tbreak;\n\t\tcase LC_LOAD_DYLIB:\n\t\tcase LC_LOAD_WEAK_DYLIB:\n\t\t\tsdb_set (bin->kv, cmd_flagname, \"load_dylib\", 0);\n\t\t\tbin->nlibs++;\n\t\t\tif (!parse_dylib (bin, off)) {\n\t\t\t\tbprintf (\"Cannot parse dylib\\n\");\n\t\t\t\tbin->nlibs--;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LC_DYLD_INFO:\n\t\tcase LC_DYLD_INFO_ONLY:\n\t\t\t{\n\t\t\tut8 dyldi[sizeof (struct dyld_info_command)] = {0};\n\t\t\tsdb_set (bin->kv, cmd_flagname, \"dyld_info\", 0);\n\t\t\tbin->dyld_info = calloc (1, sizeof (struct dyld_info_command));\n\t\t\tif (bin->dyld_info) {\n\t\t\t\tif (off + sizeof (struct dyld_info_command) > bin->size){\n\t\t\t\t\tbprintf (\"Cannot parse dyldinfo\\n\");\n\t\t\t\t\tR_FREE (bin->dyld_info);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tif (r_buf_read_at (bin->b, off, dyldi, sizeof (struct dyld_info_command)) == -1) {\n\t\t\t\t\tR_FREE (bin->dyld_info);\n\t\t\t\t\tbprintf (\"Error: read (LC_DYLD_INFO) at 0x%08\"PFMT64x\"\\n\", off);\n\t\t\t\t} else {\n\t\t\t\t\tbin->dyld_info->cmd = r_read_ble32 (&dyldi[0], bin->big_endian);\n\t\t\t\t\tbin->dyld_info->cmdsize = r_read_ble32 (&dyldi[4], bin->big_endian);\n\t\t\t\t\tbin->dyld_info->rebase_off = r_read_ble32 (&dyldi[8], bin->big_endian);\n\t\t\t\t\tbin->dyld_info->rebase_size = r_read_ble32 (&dyldi[12], bin->big_endian);\n\t\t\t\t\tbin->dyld_info->bind_off = r_read_ble32 (&dyldi[16], bin->big_endian);\n\t\t\t\t\tbin->dyld_info->bind_size = r_read_ble32 (&dyldi[20], bin->big_endian);\n\t\t\t\t\tbin->dyld_info->weak_bind_off = r_read_ble32 (&dyldi[24], bin->big_endian);\n\t\t\t\t\tbin->dyld_info->weak_bind_size = r_read_ble32 (&dyldi[28], bin->big_endian);\n\t\t\t\t\tbin->dyld_info->lazy_bind_off = r_read_ble32 (&dyldi[32], bin->big_endian);\n\t\t\t\t\tbin->dyld_info->lazy_bind_size = r_read_ble32 (&dyldi[36], bin->big_endian);\n\t\t\t\t\tbin->dyld_info->export_off = r_read_ble32 (&dyldi[40], bin->big_endian) + bin->symbols_off;\n\t\t\t\t\tbin->dyld_info->export_size = r_read_ble32 (&dyldi[44], bin->big_endian);\n\t\t\t\t}\n\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LC_CODE_SIGNATURE:\n\t\t\tparse_signature (bin, off);\n\t\t\tsdb_set (bin->kv, cmd_flagname, \"signature\", 0);\n\t\t\t/* ut32 dataoff\n\t\t\t// ut32 datasize */\n\t\t\tbreak;\n\t\tcase LC_SOURCE_VERSION:\n\t\t\tsdb_set (bin->kv, cmd_flagname, \"version\", 0);\n\t\t\t/* uint64_t  version;  */\n\t\t\t/* A.B.C.D.E packed as a24.b10.c10.d10.e10 */\n\t\t\t//bprintf (\"mach0: TODO: Show source version\\n\");\n\t\t\tbreak;\n\t\tcase LC_SEGMENT_SPLIT_INFO:\n\t\t\tsdb_set (bin->kv, cmd_flagname, \"split_info\", 0);\n\t\t\t/* TODO */\n\t\t\tbreak;\n\t\tcase LC_FUNCTION_STARTS:\n\t\t\tsdb_set (bin->kv, cmd_flagname, \"function_starts\", 0);\n\t\t\tif (!parse_function_starts (bin, off)) {\n\t\t\t\tbprintf (\"Cannot parse LC_FUNCTION_STARTS\\n\");\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LC_REEXPORT_DYLIB:\n\t\t\tsdb_set (bin->kv, cmd_flagname, \"dylib\", 0);\n\t\t\t/* TODO */\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t//bprintf (\"mach0: Unknown header command %x\\n\", lc.cmd);\n\t\t\tbreak;\n\t\t}\n\t}\n\tbool has_chained_fixups = false;\n\tfor (i = 0, off = sizeof (struct MACH0_(mach_header)) + bin->header_at; \\\n\t\t\ti < bin->hdr.ncmds; i++, off += lc.cmdsize) {\n\t\tlen = r_buf_read_at (bin->b, off, loadc, sizeof (struct load_command));\n\t\tif (len < 1) {\n\t\t\tbprintf (\"Error: read (lc) at 0x%08\"PFMT64x\"\\n\", off);\n\t\t\treturn false;\n\t\t}\n\t\tlc.cmd = r_read_ble32 (&loadc[0], bin->big_endian);\n\t\tlc.cmdsize = r_read_ble32 (&loadc[4], bin->big_endian);\n\n\t\tif (lc.cmdsize < 1 || off + lc.cmdsize > bin->size) {\n\t\t\tbprintf (\"Warning: mach0_header %d = cmdsize<1. (0x%\"PFMT64x\" vs 0x%\"PFMT64x\")\\n\", i,\n\t\t\t\t(ut64)(off + lc.cmdsize), (ut64)(bin->size));\n\t\t\tbreak;\n\t\t}\n\t\tsnprintf (cmd_flagname, sizeof (cmd_flagname), \"mach0_cmd_%d.offset\", i);\n\t\tsdb_num_set (bin->kv, cmd_flagname, off, 0);\n\t\tconst char *format_name = cmd_to_pf_definition (lc.cmd);\n\t\tsnprintf (cmd_flagname, sizeof (cmd_flagname), \"mach0_cmd_%d.format\", i);\n\t\tif (format_name) {\n\t\t\tsdb_set (bin->kv, cmd_flagname, format_name, 0);\n\t\t} else {\n\t\t\tsdb_set (bin->kv, cmd_flagname, \"[4]Ed (mach_load_command_type)cmd size\", 0);\n\t\t}\n\n\t\tswitch (lc.cmd) {\n\t\tcase LC_DATA_IN_CODE:\n\t\t\tsnprintf (cmd_flagname, sizeof (cmd_flagname), \"mach0_cmd_%d.cmd\", i);\n\t\t\tsdb_set (bin->kv, cmd_flagname, \"data_in_code\", 0);\n\t\t\tif (bin->verbose) {\n\t\t\t\tut8 buf[8];\n\t\t\t\tr_buf_read_at (bin->b, off + 8, buf, sizeof (buf));\n\t\t\t\tut32 dataoff = r_read_ble32 (buf, bin->big_endian);\n\t\t\t\tut32 datasize= r_read_ble32 (buf + 4, bin->big_endian);\n\t\t\t\teprintf (\"data-in-code at 0x%x size %d\\n\", dataoff, datasize);\n\t\t\t\tut8 *db = (ut8*)malloc (datasize);\n\t\t\t\tif (db) {\n\t\t\t\t\tr_buf_read_at (bin->b, dataoff, db, datasize);\n\t\t\t\t\t// TODO table of non-instructions regions in __text\n\t\t\t\t\tint j;\n\t\t\t\t\tfor (j = 0; j < datasize; j += 8) {\n\t\t\t\t\t\tut32 dw = r_read_ble32 (db + j, bin->big_endian);\n\t\t\t\t\t\t// int kind = r_read_ble16 (db + i + 4 + 2, bin->big_endian);\n\t\t\t\t\t\tint len = r_read_ble16 (db + j + 4, bin->big_endian);\n\t\t\t\t\t\tut64 va = offset_to_vaddr(bin, dw);\n\t\t\t\t\t//\teprintf (\"# 0x%d -> 0x%x\\n\", dw, va);\n\t\t\t\t\t//\teprintf (\"0x%x kind %d len %d\\n\", dw, kind, len);\n\t\t\t\t\t\teprintf (\"Cd 4 %d @ 0x%\"PFMT64x\"\\n\", len / 4, va);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LC_DYLD_EXPORTS_TRIE:\n\t\t\tif (bin->verbose) {\n\t\t\t\tut8 buf[8];\n\t\t\t\tr_buf_read_at (bin->b, off + 8, buf, sizeof (buf));\n\t\t\t\tut32 dataoff = r_read_ble32 (buf, bin->big_endian);\n\t\t\t\tut32 datasize= r_read_ble32 (buf + 4, bin->big_endian);\n\t\t\t\teprintf (\"exports trie at 0x%x size %d\\n\", dataoff, datasize);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LC_DYLD_CHAINED_FIXUPS: {\n\t\t\t\tut8 buf[8];\n\t\t\t\tif (r_buf_read_at (bin->b, off + 8, buf, sizeof (buf)) == sizeof (buf)) {\n\t\t\t\t\tut32 dataoff = r_read_ble32 (buf, bin->big_endian);\n\t\t\t\t\tut32 datasize= r_read_ble32 (buf + 4, bin->big_endian);\n\t\t\t\t\tif (bin->verbose) {\n\t\t\t\t\t\teprintf (\"chained fixups at 0x%x size %d\\n\", dataoff, datasize);\n\t\t\t\t\t}\n\t\t\t\t\thas_chained_fixups = parse_chained_fixups (bin, dataoff, datasize);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!has_chained_fixups && bin->hdr.cputype == CPU_TYPE_ARM64 &&\n\t\t(bin->hdr.cpusubtype & ~CPU_SUBTYPE_MASK) == CPU_SUBTYPE_ARM64E) {\n#if 0\n\t\tif (bin->verbose) {\n\t\t\teprintf (\"reconstructing chained fixups\\n\");\n\t\t}\n#endif\n\t\treconstruct_chained_fixup (bin);\n\t}\n\treturn true;\n}\n\nstatic bool init(struct MACH0_(obj_t) *mo) {\n\tif (!init_hdr (mo)) {\n\t\treturn false;\n\t}\n\tif (!init_items (mo)) {\n\t\tEprintf (\"Warning: Cannot initialize items\\n\");\n\t}\n\tmo->baddr = MACH0_(get_baddr)(mo);\n\treturn true;\n}\n\nvoid *MACH0_(mach0_free)(struct MACH0_(obj_t) *mo) {\n\tif (!mo) {\n\t\treturn NULL;\n\t}\n\n\tsize_t i;\n\tif (mo->symbols) {\n\t\tfor (i = 0; !mo->symbols[i].last; i++) {\n\t\t\tfree (mo->symbols[i].name);\n\t\t}\n\t\tfree (mo->symbols);\n\t}\n\tfree (mo->segs);\n\tfree (mo->sects);\n\tfree (mo->symtab);\n\tfree (mo->symstr);\n\tfree (mo->indirectsyms);\n\tfree (mo->imports_by_ord);\n\tht_pp_free (mo->imports_by_name);\n\tfree (mo->dyld_info);\n\tfree (mo->toc);\n\tfree (mo->modtab);\n\tfree (mo->libs);\n\tfree (mo->func_start);\n\tfree (mo->signature);\n\tfree (mo->intrp);\n\tfree (mo->compiler);\n\tif (mo->chained_starts) {\n\t\tfor (i = 0; i < mo->nsegs && i < mo->segs_count; i++) {\n\t\t\tif (mo->chained_starts[i]) {\n\t\t\t\tfree (mo->chained_starts[i]->page_start);\n\t\t\t\tfree (mo->chained_starts[i]);\n\t\t\t}\n\t\t}\n\t\tfree (mo->chained_starts);\n\t}\n\tr_buf_free (mo->b);\n\tfree (mo);\n\treturn NULL;\n}\n\nvoid MACH0_(opts_set_default)(struct MACH0_(opts_t) *options, RBinFile *bf) {\n\tr_return_if_fail (options && bf && bf->rbin);\n\toptions->header_at = 0;\n\toptions->symbols_off = 0;\n\toptions->verbose = bf->rbin->verbose;\n}\n\nstatic void *duplicate_ptr(void *p) {\n\treturn p;\n}\n\nstatic void free_only_key(HtPPKv *kv) {\n\tfree (kv->key);\n}\n\nstatic size_t ptr_size(void *c) {\n\t// :D\n\treturn 8;\n}\n\n// XXX should be deprecated its never called\nstruct MACH0_(obj_t) *MACH0_(mach0_new)(const char *file, struct MACH0_(opts_t) *options) {\n\tstruct MACH0_(obj_t) *bin = R_NEW0 (struct MACH0_(obj_t));\n\tif (!bin) {\n\t\treturn NULL;\n\t}\n\tif (options) {\n\t\tbin->verbose = options->verbose;\n\t\tbin->header_at = options->header_at;\n\t\tbin->symbols_off = options->symbols_off;\n\t}\n\tbin->file = file;\n\tsize_t binsz;\n\tut8 *buf = (ut8 *)r_file_slurp (file, &binsz);\n\tbin->size = binsz;\n\tif (!buf) {\n\t\treturn MACH0_(mach0_free)(bin);\n\t}\n\tbin->b = r_buf_new ();\n\tif (!r_buf_set_bytes (bin->b, buf, bin->size)) {\n\t\tfree (buf);\n\t\treturn MACH0_(mach0_free)(bin);\n\t}\n\tfree (buf);\n\tbin->dyld_info = NULL;\n\tif (!init (bin)) {\n\t\treturn MACH0_(mach0_free)(bin);\n\t}\n\tbin->imports_by_ord_size = 0;\n\tbin->imports_by_ord = NULL;\n\tbin->imports_by_name = ht_pp_new ((HtPPDupValue)duplicate_ptr, free_only_key, (HtPPCalcSizeV)ptr_size);\n\treturn bin;\n}\n\nstruct MACH0_(obj_t) *MACH0_(new_buf)(RBuffer *buf, struct MACH0_(opts_t) *options) {\n\tr_return_val_if_fail (buf, NULL);\n\tstruct MACH0_(obj_t) *bin = R_NEW0 (struct MACH0_(obj_t));\n\tif (bin) {\n\t\tbin->b = r_buf_ref (buf);\n\t\tbin->main_addr = UT64_MAX;\n\t\tbin->kv = sdb_new (NULL, \"bin.mach0\", 0);\n\t\tbin->size = r_buf_size (bin->b);\n\t\tif (options) {\n\t\t\tbin->verbose = options->verbose;\n\t\t\tbin->header_at = options->header_at;\n\t\t\tbin->symbols_off = options->symbols_off;\n\t\t}\n\t\tif (!init (bin)) {\n\t\t\treturn MACH0_(mach0_free)(bin);\n\t\t}\n\t}\n\treturn bin;\n}\n\n// prot: r = 1, w = 2, x = 4\n// perm: r = 4, w = 2, x = 1\nstatic int prot2perm(int x) {\n\tint r = 0;\n\tif (x & 1) {\n\t\tr |= 4;\n\t}\n\tif (x & 2) {\n\t\tr |= 2;\n\t}\n\tif (x & 4) {\n\t\tr |= 1;\n\t}\n\treturn r;\n}\n\nstatic bool is_data_section(RBinSection *sect) {\n\tif (strstr (sect->name, \"_cstring\")) {\n\t\treturn true;\n\t}\n\tif (strstr (sect->name, \"_objc_methname\")) {\n\t\treturn true;\n\t}\n\tif (strstr (sect->name, \"_objc_classname\")) {\n\t\treturn true;\n\t}\n\tif (strstr (sect->name, \"_objc_methtype\")) {\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nRList *MACH0_(get_segments)(RBinFile *bf) {\n\tstruct MACH0_(obj_t) *bin = bf->o->bin_obj;\n\tRList *list = r_list_newf ((RListFree)r_bin_section_free);\n\tsize_t i, j;\n\n\t/* for core files */\n\tif (bin->nsegs > 0) {\n\t\tstruct MACH0_(segment_command) *seg;\n\t\tfor (i = 0; i < bin->nsegs; i++) {\n\t\t\tseg = &bin->segs[i];\n\t\t\tif (!seg->initprot) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tRBinSection *s = r_bin_section_new (NULL);\n\t\t\tif (!s) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ts->vaddr = seg->vmaddr;\n\t\t\ts->vsize = seg->vmsize;\n\t\t\ts->size = seg->vmsize;\n\t\t\ts->paddr = seg->fileoff;\n\t\t\ts->paddr += bf->o->boffset;\n\t\t\t//TODO s->flags = seg->flags;\n\t\t\ts->name = r_str_ndup (seg->segname, 16);\n\t\t\ts->is_segment = true;\n\t\t\tr_str_filter (s->name, -1);\n\t\t\ts->perm = prot2perm (seg->initprot);\n\t\t\ts->add = true;\n\t\t\tr_list_append (list, s);\n\t\t}\n\t}\n\tif (bin->nsects > 0) {\n\t\tint last_section = R_MIN (bin->nsects, 128); // maybe drop this limit?\n\t\tfor (i = 0; i < last_section; i++) {\n\t\t\tRBinSection *s = R_NEW0 (RBinSection);\n\t\t\tif (!s) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ts->vaddr = (ut64)bin->sects[i].addr;\n\t\t\ts->vsize = (ut64)bin->sects[i].size;\n\t\t\ts->is_segment = false;\n\t\t\ts->size = (bin->sects[i].flags == S_ZEROFILL) ? 0 : (ut64)bin->sects[i].size;\n\t\t\t// XXX flags\n\t\t\ts->paddr = (ut64)bin->sects[i].offset;\n\t\t\tint segment_index = 0;\n\t\t\t//s->perm =prot2perm (bin->segs[j].initprot);\n\t\t\tfor (j = 0; j < bin->nsegs; j++) {\n\t\t\t\tif (s->vaddr >= bin->segs[j].vmaddr &&\n\t\t\t\t\t\ts->vaddr < (bin->segs[j].vmaddr + bin->segs[j].vmsize)) {\n\t\t\t\t\ts->perm = prot2perm (bin->segs[j].initprot);\n\t\t\t\t\tsegment_index = j;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tchar *section_name = r_str_ndup (bin->sects[i].sectname, 16);\n\t\t\tchar *segment_name = r_str_newf (\"%u.%s\", (ut32)i, bin->segs[segment_index].segname);\n\t\t\ts->name = r_str_newf (\"%s.%s\", segment_name, section_name);\n\t\t\tif (strstr (s->name, \"__const\")) {\n\t\t\t\ts->format = r_str_newf (\"Cd 4[%\"PFMT64d\"]\", s->size / 4);\n\t\t\t}\n\t\t\ts->is_data = is_data_section (s);\n\t\t\tif (strstr (section_name, \"interpos\") || strstr (section_name, \"__mod_\")) {\n#if R_BIN_MACH064\n\t\t\t\tconst int ws = 8;\n#else\n\t\t\t\tconst int ws = 4;\n#endif\n\t\t\t\ts->format = r_str_newf (\"Cd %d[%\"PFMT64d\"]\", ws, s->vsize / ws);\n\t\t\t}\n\t\t\tr_list_append (list, s);\n\t\t\tfree (segment_name);\n\t\t\tfree (section_name);\n\t\t}\n\t}\n\treturn list;\n}\n\n// XXX this function is called so many times\nstruct section_t *MACH0_(get_sections)(struct MACH0_(obj_t) *bin) {\n\tr_return_val_if_fail (bin, NULL);\n\tstruct section_t *sections;\n\tchar sectname[64], raw_segname[17];\n\tsize_t i, j, to;\n\n\t/* for core files */\n\tif (bin->nsects < 1 && bin->nsegs > 0) {\n\t\tstruct MACH0_(segment_command) *seg;\n\t\tif (!(sections = calloc ((bin->nsegs + 1), sizeof (struct section_t)))) {\n\t\t\treturn NULL;\n\t\t}\n\t\tfor (i = 0; i < bin->nsegs; i++) {\n\t\t\tseg = &bin->segs[i];\n\t\t\tsections[i].addr = seg->vmaddr;\n\t\t\tsections[i].offset = seg->fileoff;\n\t\t\tsections[i].size = seg->vmsize;\n\t\t\tsections[i].vsize = seg->vmsize;\n\t\t\tsections[i].align = 4096;\n\t\t\tsections[i].flags = seg->flags;\n\t\t\tr_str_ncpy (sectname, seg->segname, 16);\n\t\t\tsectname[16] = 0;\n\t\t\tr_str_filter (sectname, -1);\n\t\t\t// hack to support multiple sections with same name\n\t\t\tsections[i].perm = prot2perm (seg->initprot);\n\t\t\tsections[i].last = 0;\n\t\t}\n\t\tsections[i].last = 1;\n\t\treturn sections;\n\t}\n\n\tif (!bin->sects) {\n\t\treturn NULL;\n\t}\n\tto = R_MIN (bin->nsects, 128); // limit number of sections here to avoid fuzzed bins\n\tif (to < 1) {\n\t\treturn NULL;\n\t}\n\tif (!(sections = calloc (bin->nsects + 1, sizeof (struct section_t)))) {\n\t\treturn NULL;\n\t}\n\tfor (i = 0; i < to; i++) {\n\t\tsections[i].offset = (ut64)bin->sects[i].offset;\n\t\tsections[i].addr = (ut64)bin->sects[i].addr;\n\t\tsections[i].size = (bin->sects[i].flags == S_ZEROFILL) ? 0 : (ut64)bin->sects[i].size;\n\t\tsections[i].vsize = (ut64)bin->sects[i].size;\n\t\tsections[i].align = bin->sects[i].align;\n\t\tsections[i].flags = bin->sects[i].flags;\n\t\tr_str_ncpy (sectname, bin->sects[i].sectname, 17);\n\t\tr_str_filter (sectname, -1);\n\t\tr_str_ncpy (raw_segname, bin->sects[i].segname, 16);\n\t\tfor (j = 0; j < bin->nsegs; j++) {\n\t\t\tif (sections[i].addr >= bin->segs[j].vmaddr &&\n\t\t\t\tsections[i].addr < (bin->segs[j].vmaddr + bin->segs[j].vmsize)) {\n\t\t\t\tsections[i].perm = prot2perm (bin->segs[j].initprot);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tsnprintf (sections[i].name, sizeof (sections[i].name),\n\t\t\t\"%d.%s.%s\", (int)i, raw_segname, sectname);\n\t\tsections[i].last = 0;\n\t}\n\tsections[i].last = 1;\n\treturn sections;\n}\n\nstatic bool parse_import_stub(struct MACH0_(obj_t) *bin, struct symbol_t *symbol, int idx) {\n\tsize_t i, j, nsyms, stridx;\n\tconst char *symstr;\n\tif (idx < 0) {\n\t\treturn false;\n\t}\n\tsymbol->offset = 0LL;\n\tsymbol->addr = 0LL;\n\tsymbol->name = NULL;\n\tsymbol->is_imported = true;\n\n\tif (!bin || !bin->sects) {\n\t\treturn false;\n\t}\n\tfor (i = 0; i < bin->nsects; i++) {\n\t\tif ((bin->sects[i].flags & SECTION_TYPE) == S_SYMBOL_STUBS && bin->sects[i].reserved2 > 0) {\n\t\t\tut64 sect_size = bin->sects[i].size;\n\t\t\tut32 sect_fragment = bin->sects[i].reserved2;\n\t\t\tif (bin->sects[i].offset > bin->size) {\n\t\t\t\tbprintf (\"mach0: section offset starts way beyond the end of the file\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (sect_size > bin->size) {\n\t\t\t\tbprintf (\"mach0: Invalid symbol table size\\n\");\n\t\t\t\tsect_size = bin->size - bin->sects[i].offset;\n\t\t\t}\n\t\t\tnsyms = (int)(sect_size / sect_fragment);\n\t\t\tfor (j = 0; j < nsyms; j++) {\n\t\t\t\tif (bin->sects) {\n\t\t\t\t\tif (bin->sects[i].reserved1 + j >= bin->nindirectsyms) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (bin->indirectsyms) {\n\t\t\t\t\tif (idx != bin->indirectsyms[bin->sects[i].reserved1 + j]) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (idx > bin->nsymtab) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tsymbol->type = R_BIN_MACH0_SYMBOL_TYPE_LOCAL;\n\t\t\t\tint delta = j * bin->sects[i].reserved2;\n\t\t\t\tif (delta < 0) {\n\t\t\t\t\tbprintf (\"mach0: corrupted reserved2 value leads to int overflow.\\n\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tsymbol->offset = bin->sects[i].offset + delta;\n\t\t\t\tsymbol->addr = bin->sects[i].addr + delta;\n\t\t\t\tsymbol->size = 0;\n\t\t\t\tstridx = bin->symtab[idx].n_strx;\n\t\t\t\tif (stridx < bin->symstrlen) {\n\t\t\t\t\tsymstr = (char *)bin->symstr + stridx;\n\t\t\t\t} else {\n\t\t\t\t\tsymstr = \"???\";\n\t\t\t\t}\n\t\t\t\t// Remove the extra underscore that every import seems to have in Mach-O.\n\t\t\t\tif (*symstr == '_') {\n\t\t\t\t\tsymstr++;\n\t\t\t\t}\n\t\t\t\tsymbol->name = strdup (symstr);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\nstatic int inSymtab(HtPP *hash, const char *name, ut64 addr) {\n\tbool found = false;\n\tchar *key = r_str_newf (\"%\"PFMT64x\".%s\", addr, name);\n\tht_pp_find (hash, key, &found);\n\tif (found) {\n\t\tfree (key);\n\t\treturn true;\n\t}\n\tht_pp_insert (hash, key, \"1\");\n\tfree (key);\n\treturn false;\n}\n\nstatic char *get_name(struct MACH0_(obj_t) *mo, ut32 stridx, bool filter) {\n\tsize_t i = 0;\n\tif (!mo->symstr || stridx >= mo->symstrlen) {\n\t\treturn NULL;\n\t}\n\tint len = mo->symstrlen - stridx;\n\tconst char *symstr = (const char*)mo->symstr + stridx;\n\tfor (i = 0; i < len; i++) {\n\t\tif ((ut8)(symstr[i] & 0xff) == 0xff || !symstr[i]) {\n\t\t\tlen = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (len > 0) {\n\t\tchar *res = r_str_ndup (symstr, len);\n\t\tif (filter) {\n\t\t\tr_str_filter (res, -1);\n\t\t}\n\t\treturn res;\n\t}\n\treturn NULL;\n}\n\nstatic int walk_exports(struct MACH0_(obj_t) *bin, RExportsIterator iterator, void *ctx) {\n\tRList *states = NULL;\n\tr_return_val_if_fail (bin, 0);\n\tif (!bin->dyld_info) {\n\t\treturn 0;\n\t}\n\n\tsize_t count = 0;\n\tut8 *p = NULL;\n\tut64 size = bin->dyld_info->export_size;\n\tif (!size || size >= SIZE_MAX) {\n\t\treturn 0;\n\t}\n\tut8 *trie = calloc (size + 1, 1);\n\tif (!trie) {\n\t\treturn 0;\n\t}\n\tut8 *end = trie + size;\n\tif (r_buf_read_at (bin->b, bin->dyld_info->export_off, trie, bin->dyld_info->export_size) != size) {\n\t\tgoto beach;\n\t}\n\n\tstates = r_list_newf ((RListFree)free);\n\tif (!states) {\n\t\tgoto beach;\n\t}\n\n\tRTrieState *root = R_NEW0 (RTrieState);\n\tif (!root) {\n\t\tgoto beach;\n\t}\n\troot->node = trie;\n\troot->i = 0;\n\troot->label = NULL;\n\tr_list_push (states, root);\n\n\tdo {\n\t\tRTrieState * state = r_list_get_top (states);\n\t\tp = state->node;\n\t\tut64 len = read_uleb128 (&p, end);\n\t\tif (len == UT64_MAX) {\n\t\t\tbreak;\n\t\t}\n\t\tif (len) {\n\t\t\tut64 flags = read_uleb128 (&p, end);\n\t\t\tif (flags == UT64_MAX) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tut64 offset = read_uleb128 (&p, end);\n\t\t\tif (offset == UT64_MAX) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tut64 resolver = 0;\n\t\t\tbool isReexport = flags & EXPORT_SYMBOL_FLAGS_REEXPORT;\n\t\t\tbool hasResolver = flags & EXPORT_SYMBOL_FLAGS_STUB_AND_RESOLVER;\n\t\t\tif (hasResolver) {\n\t\t\t\tut64 res = read_uleb128 (&p, end);\n\t\t\t\tif (res == UT64_MAX) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tresolver = res + bin->header_at;\n\t\t\t} else if (isReexport) {\n\t\t\t\tp += strlen ((char*) p) + 1;\n\t\t\t\t// TODO: handle this\n\t\t\t}\n\t\t\tif (!isReexport) {\n\t\t\t\toffset += bin->header_at;\n\t\t\t}\n\t\t\tif (iterator && !isReexport) {\n\t\t\t\tchar * name = NULL;\n\t\t\t\tRListIter *iter;\n\t\t\t\tRTrieState *s;\n\t\t\t\tr_list_foreach (states, iter, s) {\n\t\t\t\t\tif (!s->label) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tname = r_str_append (name, s->label);\n\t\t\t\t}\n\t\t\t\tif (!name) {\n\t\t\t\t\tbprintf (\"malformed export trie %d\\n\", __LINE__);\n\t\t\t\t\tgoto beach;\n\t\t\t\t}\n\t\t\t\tif (hasResolver) {\n\t\t\t\t\tchar * stub_name = r_str_newf (\"stub.%s\", name);\n\t\t\t\t\titerator (bin, stub_name, flags, offset, ctx);\n\t\t\t\t\titerator (bin, name, flags, resolver, ctx);\n\t\t\t\t\tR_FREE (stub_name);\n\t\t\t\t} else {\n\t\t\t\t\titerator (bin, name, flags, offset, ctx);\n\t\t\t\t}\n\t\t\t\tR_FREE (name);\n\t\t\t}\n\t\t\tif (!isReexport) {\n\t\t\t\tif (hasResolver) {\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\tut64 child_count = read_uleb128 (&p, end);\n\t\tif (child_count == UT64_MAX) {\n\t\t\tgoto beach;\n\t\t}\n\t\tif (state->i == child_count) {\n\t\t\tfree (r_list_pop (states));\n\t\t\tcontinue;\n\t\t}\n\t\tif (!state->next_child) {\n\t\t\tstate->next_child = p;\n\t\t} else {\n\t\t\tp = state->next_child;\n\t\t}\n\t\tRTrieState * next = R_NEW0 (RTrieState);\n\t\tif (!next) {\n\t\t\tgoto beach;\n\t\t}\n\t\tnext->label = (char *) p;\n\t\tp += strlen (next->label) + 1;\n\t\tif (p >= end) {\n\t\t\tbprintf (\"malformed export trie %d\\n\", __LINE__);\n\t\t\tR_FREE (next);\n\t\t\tgoto beach;\n\t\t}\n\t\tut64 tr = read_uleb128 (&p, end);\n\t\tif (tr == UT64_MAX || tr >= size) {\n\t\t\tR_FREE (next);\n\t\t\tgoto beach;\n\t\t}\n\t\tnext->node = trie + (size_t)tr;\n\t\tif (next->node >= end) {\n\t\t\tbprintf (\"malformed export trie %d\\n\", __LINE__);\n\t\t\tR_FREE (next);\n\t\t\tgoto beach;\n\t\t}\n\t\t{\n\t\t\t// avoid loops\n\t\t\tRListIter *it;\n\t\t\tRTrieState *s;\n\t\t\tr_list_foreach (states, it, s) {\n\t\t\t\tif (s->node == next->node) {\n\t\t\t\t\tbprintf (\"malformed export trie %d\\n\", __LINE__);\n\t\t\t\t\tR_FREE (next);\n\t\t\t\t\tgoto beach;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tnext->i = 0;\n\t\tstate->i++;\n\t\tstate->next_child = p;\n\t\tr_list_push (states, next);\n\t} while (r_list_length (states));\n\nbeach:\n\tr_list_free (states);\n\tR_FREE (trie);\n\treturn count;\n}\n\nstatic void fill_exports_list(struct MACH0_(obj_t) *bin, const char *name, ut64 flags, ut64 offset, void *ctx) {\n\tRList *list = (RList*) ctx;\n\tRBinSymbol *sym = R_NEW0 (RBinSymbol);\n\tif (!sym) {\n\t\treturn;\n\t}\n\tsym->vaddr = offset_to_vaddr (bin, offset);\n\tsym->paddr = offset;\n\tsym->type = \"EXT\";\n\tsym->name = strdup (name);\n\tsym->bind = R_BIN_BIND_GLOBAL_STR;\n\tr_list_append (list, sym);\n}\n\n// TODO: Return RList<RBinSymbol> // 2x speedup\nconst RList *MACH0_(get_symbols_list)(struct MACH0_(obj_t) *bin) {\n\tstatic RList * cache = NULL; // XXX DONT COMMIT WITH THIS\n\tstruct symbol_t *symbols;\n\tsize_t j, s, symbols_size, symbols_count;\n\tut32 to, from;\n\tsize_t i;\n\n\tr_return_val_if_fail (bin, NULL);\n\tif (cache) {\n\t\treturn cache;\n\t}\n\tRList *list = r_list_newf ((RListFree)r_bin_symbol_free);\n\tcache = list;\n\n\tHtPP *hash = ht_pp_new0 ();\n\tif (!hash) {\n\t\treturn NULL;\n\t}\n\n\twalk_exports (bin, fill_exports_list, list);\n\tif (r_list_length (list)) {\n\t\tRListIter *it;\n\t\tRBinSymbol *s;\n\t\tr_list_foreach (list, it, s) {\n\t\t\tinSymtab (hash, s->name, s->vaddr);\n\t\t}\n\t}\n\n\tif (!bin->symtab || !bin->symstr) {\n\t\tht_pp_free (hash);\n\t\treturn list;\n\t}\n\t/* parse dynamic symbol table */\n\tsymbols_count = (bin->dysymtab.nextdefsym + \\\n\t\t\tbin->dysymtab.nlocalsym + \\\n\t\t\tbin->dysymtab.nundefsym );\n\tsymbols_count += bin->nsymtab;\n\tsymbols_size = (symbols_count + 1) * 2 * sizeof (struct symbol_t);\n\n\tif (symbols_size < 1 || !(symbols = calloc (1, symbols_size))) {\n\t\tht_pp_free (hash);\n\t\treturn NULL;\n\t}\n\tj = 0; // symbol_idx\n\tbin->main_addr = 0;\n\tint bits = MACH0_(get_bits_from_hdr) (&bin->hdr);\n\tfor (s = 0; s < 2; s++) {\n\t\tswitch (s) {\n\t\tcase 0:\n\t\t\tfrom = bin->dysymtab.iextdefsym;\n\t\t\tto = from + bin->dysymtab.nextdefsym;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tfrom = bin->dysymtab.ilocalsym;\n\t\t\tto = from + bin->dysymtab.nlocalsym;\n\t\t\tbreak;\n#if NOT_USED\n\t\tcase 2:\n\t\t\tfrom = bin->dysymtab.iundefsym;\n\t\t\tto = from + bin->dysymtab.nundefsym;\n\t\t\tbreak;\n#endif\n\t\t}\n\t\tif (from == to) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tfrom = R_MIN (from, symbols_size / sizeof (struct symbol_t));\n\t\tto = R_MIN (R_MIN (to, bin->nsymtab), symbols_size / sizeof (struct symbol_t));\n\n\t\tut32 maxsymbols = symbols_size / sizeof (struct symbol_t);\n\t\tif (symbols_count >= maxsymbols) {\n\t\t\tsymbols_count = maxsymbols - 1;\n\t\t\teprintf (\"macho warning: Symbol table truncated\\n\");\n\t\t}\n\t\tfor (i = from; i < to && j < symbols_count; i++, j++) {\n\t\t\tRBinSymbol *sym = R_NEW0 (RBinSymbol);\n\t\t\tsym->vaddr = bin->symtab[i].n_value;\n\t\t\tsym->paddr = addr_to_offset (bin, sym->vaddr);\n\t\t\tsymbols[j].size = 0; /* TODO: Is it anywhere? */\n\t\t\tsym->bits = bin->symtab[i].n_desc & N_ARM_THUMB_DEF ? 16 : bits;\n\n\t\t\tif (bin->symtab[i].n_type & N_EXT) {\n\t\t\t\tsym->type = \"EXT\";\n\t\t\t} else {\n\t\t\t\tsym->type = \"LOCAL\";\n\t\t\t}\n\t\t\tint stridx = bin->symtab[i].n_strx;\n\t\t\tchar *sym_name = get_name (bin, stridx, false);\n\t\t\tif (sym_name) {\n\t\t\t\tsym->name = sym_name;\n\t\t\t\tif (!bin->main_addr || bin->main_addr == UT64_MAX) {\n\t\t\t\t\tconst char *name = sym->name;\n\t\t\t\t\tif (!strcmp (name, \"__Dmain\")) {\n\t\t\t\t\t\tbin->main_addr = symbols[j].addr;\n\t\t\t\t\t} else if (strstr (name, \"4main\") && !strstr (name, \"STATIC\")) {\n\t\t\t\t\t\tbin->main_addr = symbols[j].addr;\n\t\t\t\t\t} else if (!strcmp (name, \"_main\")) {\n\t\t\t\t\t\tbin->main_addr = symbols[j].addr;\n\t\t\t\t\t} else if (!strcmp (name, \"main\")) {\n\t\t\t\t\t\tbin->main_addr = symbols[j].addr;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tsym->name = r_str_newf (\"unk%u\", (ut32)i);\n\t\t\t}\n\t\t\tif (!inSymtab (hash, sym->name, sym->vaddr)) {\n\t\t\t\tr_list_append (list, sym);\n\t\t\t} else {\n\t\t\t\tr_bin_symbol_free (sym);\n\t\t\t}\n\t\t}\n\t}\n\tto = R_MIN ((ut32)bin->nsymtab, bin->dysymtab.iundefsym + bin->dysymtab.nundefsym);\n\tfor (i = bin->dysymtab.iundefsym; i < to; i++) {\n\t\tstruct symbol_t symbol;\n\t\tif (j > symbols_count) {\n\t\t\tbprintf (\"mach0-get-symbols: error\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tif (parse_import_stub (bin, &symbol, i)) {\n\t\t\tj++;\n\t\t\tRBinSymbol *sym = R_NEW0 (RBinSymbol);\n\t\t\tsym->vaddr = symbol.addr;\n\t\t\tsym->paddr = symbol.offset;\n\t\t\tsym->name = symbol.name;\n\t\t\tif (!sym->name) {\n\t\t\t\tsym->name = r_str_newf (\"unk%u\", (ut32)i);\n\t\t\t}\n\t\t\tsym->is_imported = symbol.is_imported;\n\t\t\tr_list_append (list, sym);\n\t\t}\n\t}\n\n\tfor (i = 0; i < bin->nsymtab && i < symbols_count; i++) {\n\t\tstruct MACH0_(nlist) *st = &bin->symtab[i];\n\t\t// 0 is for imports\n\t\t// 1 is for symbols\n\t\t// 2 is for func.eh (exception handlers?)\n\t\tint section = st->n_sect;\n\t\tif (section == 1 && j < symbols_count) { // text ??st->n_type == 1) maybe wrong\n\t\t\tRBinSymbol *sym = R_NEW0(RBinSymbol);\n\t\t\t/* is symbol */\n\t\t\tsym->vaddr = st->n_value;\n\t\t\tsym->paddr = addr_to_offset (bin, symbols[j].addr);\n\t\t\tsym->is_imported = symbols[j].is_imported;\n\t\t\tif (st->n_type & N_EXT) {\n\t\t\t\tsym->type = \"EXT\";\n\t\t\t} else {\n\t\t\t\tsym->type = \"LOCAL\";\n\t\t\t}\n\t\t\tchar *sym_name = get_name (bin, st->n_strx, false);\n\t\t\tif (sym_name) {\n\t\t\t\tsym->name = sym_name;\n\t\t\t\tif (inSymtab (hash, sym->name, sym->vaddr)) {\n\t\t\t\t\tr_bin_symbol_free (sym);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (!bin->main_addr || bin->main_addr == UT64_MAX) {\n\t\t\t\t\tconst char *name = sym->name;\n\t\t\t\t\tif (!strcmp (name, \"__Dmain\")) {\n\t\t\t\t\t\tbin->main_addr = symbols[i].addr;\n\t\t\t\t\t} else if (strstr (name, \"4main\") && !strstr (name, \"STATIC\")) {\n\t\t\t\t\t\tbin->main_addr = symbols[i].addr;\n\t\t\t\t\t} else if (!strcmp (symbols[i].name, \"_main\")) {\n\t\t\t\t\t\tbin->main_addr = symbols[i].addr;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tsym->name = r_str_newf (\"unk%u\", (ut32)i);\n\t\t\t}\n\t\t\tr_list_append (list, sym);\n\t\t\tj++;\n\t\t}\n\t}\n\tht_pp_free (hash);\n\t// bin->symbols = symbols;\n    free (symbols);\n\treturn list;\n}\n\nstatic void assign_export_symbol_t(struct MACH0_(obj_t) *bin, const char *name, ut64 flags, ut64 offset, void *ctx) {\n\tRSymCtx *sym_ctx = (RSymCtx*) ctx;\n\tint j = sym_ctx->j;\n\tif (j < sym_ctx->symbols_count) {\n\t\tsym_ctx->symbols[j].offset = offset;\n\t\tsym_ctx->symbols[j].addr = offset_to_vaddr (bin, offset);\n\t\tif (inSymtab (sym_ctx->hash, name, sym_ctx->symbols[j].addr)) {\n\t\t\treturn;\n\t\t}\n\t\tsym_ctx->symbols[j].size = 0;\n\t\tsym_ctx->symbols[j].type = R_BIN_MACH0_SYMBOL_TYPE_EXT;\n\t\tsym_ctx->symbols[j].name = strdup (name);\n\t\tsym_ctx->j++;\n\t}\n}\n\nconst struct symbol_t *MACH0_(get_symbols)(struct MACH0_(obj_t) *bin) {\n\tstruct symbol_t *symbols;\n\tint j, s, stridx, symbols_size, symbols_count;\n\tut32 to, from, i;\n\n\tif (bin->symbols) {\n\t\treturn bin->symbols;\n\t}\n\n\tHtPP *hash = ht_pp_new0 ();\n\tif (!hash) {\n\t\treturn NULL;\n\t}\n\n\tr_return_val_if_fail (bin, NULL);\n\tint n_exports = walk_exports (bin, NULL, NULL);\n\n\tsymbols_count = n_exports;\n\tj = 0; // symbol_idx\n\n\tint bits = MACH0_(get_bits_from_hdr) (&bin->hdr);\n\tif (bin->symtab && bin->symstr) {\n\t\t/* parse dynamic symbol table */\n\t\tsymbols_count = (bin->dysymtab.nextdefsym + \\\n\t\t\t\tbin->dysymtab.nlocalsym + \\\n\t\t\t\tbin->dysymtab.nundefsym );\n\t\tsymbols_count += bin->nsymtab;\n\t\tif (symbols_count < 0 || ((st64)symbols_count * 2) > ST32_MAX) {\n\t\t\teprintf (\"Symbols count overflow\\n\");\n\t\t\tht_pp_free (hash);\n\t\t\treturn NULL;\n\t\t}\n\t\tsymbols_size = (symbols_count + 1) * 2 * sizeof (struct symbol_t);\n\n\t\tif (symbols_size < 1) {\n\t\t\tht_pp_free (hash);\n\t\t\treturn NULL;\n\t\t}\n\t\tif (!(symbols = calloc (1, symbols_size))) {\n\t\t\tht_pp_free (hash);\n\t\t\treturn NULL;\n\t\t}\n\t\tbin->main_addr = 0;\n\t\tfor (s = 0; s < 2; s++) {\n\t\t\tswitch (s) {\n\t\t\tcase 0:\n\t\t\t\tfrom = bin->dysymtab.iextdefsym;\n\t\t\t\tto = from + bin->dysymtab.nextdefsym;\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tfrom = bin->dysymtab.ilocalsym;\n\t\t\t\tto = from + bin->dysymtab.nlocalsym;\n\t\t\t\tbreak;\n#if NOT_USED\n\t\t\tcase 2:\n\t\t\t\tfrom = bin->dysymtab.iundefsym;\n\t\t\t\tto = from + bin->dysymtab.nundefsym;\n\t\t\t\tbreak;\n#endif\n\t\t\t}\n\t\t\tif (from == to) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfrom = R_MIN (from, symbols_size / sizeof (struct symbol_t));\n\t\t\tto = R_MIN (R_MIN (to, bin->nsymtab), symbols_size / sizeof (struct symbol_t));\n\n\t\t\tut32 maxsymbols = symbols_size / sizeof (struct symbol_t);\n\t\t\tif (symbols_count >= maxsymbols) {\n\t\t\t\tsymbols_count = maxsymbols - 1;\n\t\t\t\teprintf (\"macho warning: Symbol table truncated\\n\");\n\t\t\t}\n\t\t\tfor (i = from; i < to && j < symbols_count; i++, j++) {\n\t\t\t\tsymbols[j].offset = addr_to_offset (bin, bin->symtab[i].n_value);\n\t\t\t\tsymbols[j].addr = bin->symtab[i].n_value;\n\t\t\t\tsymbols[j].size = 0; /* TODO: Is it anywhere? */\n\t\t\t\tsymbols[j].bits = bin->symtab[i].n_desc & N_ARM_THUMB_DEF ? 16 : bits;\n\t\t\t\tsymbols[j].is_imported = false;\n\t\t\t\tsymbols[j].type = (bin->symtab[i].n_type & N_EXT)\n\t\t\t\t\t? R_BIN_MACH0_SYMBOL_TYPE_EXT\n\t\t\t\t\t: R_BIN_MACH0_SYMBOL_TYPE_LOCAL;\n\t\t\t\tstridx = bin->symtab[i].n_strx;\n\t\t\t\tsymbols[j].name = get_name (bin, stridx, false);\n\t\t\t\tsymbols[j].last = false;\n\n\t\t\t\tconst char *name = symbols[j].name;\n\t\t\t\tif (bin->main_addr == 0 && name) {\n\t\t\t\t\tif (!strcmp (name, \"__Dmain\")) {\n\t\t\t\t\t\tbin->main_addr = symbols[j].addr;\n\t\t\t\t\t} else if (strstr (name, \"4main\") && !strstr (name, \"STATIC\")) {\n\t\t\t\t\t\tbin->main_addr = symbols[j].addr;\n\t\t\t\t\t} else if (!strcmp (name, \"_main\")) {\n\t\t\t\t\t\tbin->main_addr = symbols[j].addr;\n\t\t\t\t\t} else if (!strcmp (name, \"main\")) {\n\t\t\t\t\t\tbin->main_addr = symbols[j].addr;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (inSymtab (hash, symbols[j].name, symbols[j].addr)) {\n\t\t\t\t\tfree (symbols[j].name);\n\t\t\t\t\tsymbols[j].name = NULL;\n\t\t\t\t\tj--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tto = R_MIN ((ut32)bin->nsymtab, bin->dysymtab.iundefsym + bin->dysymtab.nundefsym);\n\t\tfor (i = bin->dysymtab.iundefsym; i < to; i++) {\n\t\t\tif (j > symbols_count) {\n\t\t\t\tbprintf (\"mach0-get-symbols: error\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (parse_import_stub (bin, &symbols[j], i)) {\n\t\t\t\tsymbols[j++].last = false;\n\t\t\t}\n\t\t}\n\n\t\tfor (i = 0; i < bin->nsymtab; i++) {\n\t\t\tstruct MACH0_(nlist) *st = &bin->symtab[i];\n\t\t\tif (st->n_type & N_STAB) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t// 0 is for imports\n\t\t\t// 1 is for symbols\n\t\t\t// 2 is for func.eh (exception handlers?)\n\t\t\tint section = st->n_sect;\n\t\t\tif (section == 1 && j < symbols_count) {\n\t\t\t\t// check if symbol exists already\n\t\t\t\t/* is symbol */\n\t\t\t\tsymbols[j].addr = st->n_value;\n\t\t\t\tsymbols[j].offset = addr_to_offset (bin, symbols[j].addr);\n\t\t\t\tsymbols[j].size = 0; /* find next symbol and crop */\n\t\t\t\tsymbols[j].type = (st->n_type & N_EXT)\n\t\t\t\t\t? R_BIN_MACH0_SYMBOL_TYPE_EXT\n\t\t\t\t\t: R_BIN_MACH0_SYMBOL_TYPE_LOCAL;\n\t\t\t\tchar *sym_name = get_name (bin, st->n_strx, false);\n\t\t\t\tif (sym_name) {\n\t\t\t\t\tsymbols[j].name = sym_name;\n\t\t\t\t} else {\n\t\t\t\t\tsymbols[j].name = r_str_newf (\"entry%d\", i);\n\t\t\t\t}\n\t\t\t\tsymbols[j].last = 0;\n\t\t\t\tif (inSymtab (hash, symbols[j].name, symbols[j].addr)) {\n\t\t\t\t\tR_FREE (symbols[j].name);\n\t\t\t\t} else {\n\t\t\t\t\tj++;\n\t\t\t\t}\n\n\t\t\t\tconst char *name = symbols[i].name;\n\t\t\t\tif (bin->main_addr == 0 && name) {\n\t\t\t\t\tif (name && !strcmp (name, \"__Dmain\")) {\n\t\t\t\t\t\tbin->main_addr = symbols[i].addr;\n\t\t\t\t\t} else if (name && strstr (name, \"4main\") && !strstr (name, \"STATIC\")) {\n\t\t\t\t\t\tbin->main_addr = symbols[i].addr;\n\t\t\t\t\t} else if (symbols[i].name && !strcmp (symbols[i].name, \"_main\")) {\n\t\t\t\t\t\tbin->main_addr = symbols[i].addr;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else if (!n_exports) {\n\t\tht_pp_free (hash);\n\t\treturn NULL;\n\t} else {\n\t\tsymbols_size = (symbols_count + 1) * sizeof (struct symbol_t);\n\t\tif (symbols_size < 1) {\n\t\t\tht_pp_free (hash);\n\t\t\treturn NULL;\n\t\t}\n\t\tif (!(symbols = calloc (1, symbols_size))) {\n\t\t\tht_pp_free (hash);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\tif (n_exports && (symbols_count - j) >= n_exports) {\n\t\tRSymCtx sym_ctx;\n\t\tsym_ctx.symbols = symbols;\n\t\tsym_ctx.j = j;\n\t\tsym_ctx.symbols_count = symbols_count;\n\t\tsym_ctx.hash = hash;\n\t\twalk_exports (bin, assign_export_symbol_t, &sym_ctx);\n\t\tj = sym_ctx.j;\n\t}\n\tht_pp_free (hash);\n\tsymbols[j].last = true;\n\tbin->symbols = symbols;\n\treturn symbols;\n}\n\nstatic int parse_import_ptr(struct MACH0_(obj_t) *bin, struct reloc_t *reloc, int idx) {\n\tint i, j, sym;\n\tsize_t wordsize;\n\tut32 stype;\n\twordsize = get_word_size (bin);\n\tif (idx < 0 || idx >= bin->nsymtab) {\n\t\treturn 0;\n\t}\n\tif ((bin->symtab[idx].n_desc & REFERENCE_TYPE) == REFERENCE_FLAG_UNDEFINED_LAZY) {\n\t\tstype = S_LAZY_SYMBOL_POINTERS;\n\t} else {\n\t\tstype = S_NON_LAZY_SYMBOL_POINTERS;\n\t}\n\n\treloc->offset = 0;\n\treloc->addr = 0;\n\treloc->addend = 0;\n#define CASE(T) case ((T) / 8): reloc->type = R_BIN_RELOC_ ## T; break\n\tswitch (wordsize) {\n\tCASE(8);\n\tCASE(16);\n\tCASE(32);\n\tCASE(64);\n\tdefault: return false;\n\t}\n#undef CASE\n\n\tfor (i = 0; i < bin->nsects; i++) {\n\t\tif ((bin->sects[i].flags & SECTION_TYPE) == stype) {\n\t\t\tfor (j = 0, sym = -1; bin->sects[i].reserved1 + j < bin->nindirectsyms; j++) {\n\t\t\t\tint indidx = bin->sects[i].reserved1 + j;\n\t\t\t\tif (indidx < 0 || indidx >= bin->nindirectsyms) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (idx == bin->indirectsyms[indidx]) {\n\t\t\t\t\tsym = j;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\treloc->offset = sym == -1 ? 0 : bin->sects[i].offset + sym * wordsize;\n\t\t\treloc->addr = sym == -1 ? 0 : bin->sects[i].addr + sym * wordsize;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nstruct import_t *MACH0_(get_imports)(struct MACH0_(obj_t) *bin) {\n\tr_return_val_if_fail (bin, NULL);\n\n\tint i, j, idx, stridx;\n\tif (!bin->sects || !bin->symtab || !bin->symstr || !bin->indirectsyms) {\n\t\treturn NULL;\n\t}\n\n\tif (bin->dysymtab.nundefsym < 1 || bin->dysymtab.nundefsym > 0xfffff) {\n\t\treturn NULL;\n\t}\n\n\tstruct import_t *imports = calloc (bin->dysymtab.nundefsym + 1, sizeof (struct import_t));\n\tif (!imports) {\n\t\treturn NULL;\n\t}\n\tfor (i = j = 0; i < bin->dysymtab.nundefsym; i++) {\n\t\tidx = bin->dysymtab.iundefsym + i;\n\t\tif (idx < 0 || idx >= bin->nsymtab) {\n\t\t\tbprintf (\"WARNING: Imports index out of bounds. Ignoring relocs\\n\");\n\t\t\tfree (imports);\n\t\t\treturn NULL;\n\t\t}\n\t\tstridx = bin->symtab[idx].n_strx;\n\t\tchar *imp_name = get_name (bin, stridx, false);\n\t\tif (imp_name) {\n\t\t\tr_str_ncpy (imports[j].name, imp_name, R_BIN_MACH0_STRING_LENGTH - 1);\n\t\t\tfree (imp_name);\n\t\t} else {\n\t\t\t//imports[j].name[0] = 0;\n\t\t\tcontinue;\n\t\t}\n\t\timports[j].ord = i;\n\t\timports[j++].last = 0;\n\t}\n\timports[j].last = 1;\n\n\tif (!bin->imports_by_ord_size) {\n\t\tif (j > 0) {\n\t\t\tbin->imports_by_ord_size = j;\n\t\t\tbin->imports_by_ord = (RBinImport**)calloc (j, sizeof (RBinImport*));\n\t\t} else {\n\t\t\tbin->imports_by_ord_size = 0;\n\t\t\tbin->imports_by_ord = NULL;\n\t\t}\n\t}\n\n\treturn imports;\n}\n\nstatic int reloc_comparator(struct reloc_t *a, struct reloc_t *b) {\n\treturn a->addr - b->addr;\n}\n\nstatic void parse_relocation_info(struct MACH0_(obj_t) *bin, RSkipList *relocs, ut32 offset, ut32 num) {\n\tif (!num || !offset || (st32)num < 0) {\n\t\treturn;\n\t}\n\n\tut64 total_size = num * sizeof (struct relocation_info);\n\tif (offset > bin->size) {\n\t\treturn;\n\t}\n\tif (total_size > bin->size) {\n\t\ttotal_size = bin->size - offset;\n\t\tnum = total_size /= sizeof (struct relocation_info);\n\t}\n\tstruct relocation_info *info = calloc (num, sizeof (struct relocation_info));\n\tif (!info) {\n\t\treturn;\n\t}\n\n\tif (r_buf_read_at (bin->b, offset, (ut8 *) info, total_size) < total_size) {\n\t\tfree (info);\n\t\treturn;\n\t}\n\n\tsize_t i;\n\tfor (i = 0; i < num; i++) {\n\t\tstruct relocation_info a_info = info[i];\n\t\tut32 sym_num = a_info.r_symbolnum;\n\t\tif (sym_num >= bin->nsymtab) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tut32 stridx = bin->symtab[sym_num].n_strx;\n\t\tchar *sym_name = get_name (bin, stridx, false);\n\t\tif (!sym_name) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tstruct reloc_t *reloc = R_NEW0 (struct reloc_t);\n\t\tif (!reloc) {\n\t\t\tfree (info);\n\t\t\tfree (sym_name);\n\t\t\treturn;\n\t\t}\n\n\t\treloc->addr = offset_to_vaddr (bin, a_info.r_address);\n\t\treloc->offset = a_info.r_address;\n\t\treloc->ord = sym_num;\n\t\treloc->type = a_info.r_type; // enum RelocationInfoType\n\t\treloc->external = a_info.r_extern;\n\t\treloc->pc_relative = a_info.r_pcrel;\n\t\treloc->size = a_info.r_length;\n\t\tr_str_ncpy (reloc->name, sym_name, sizeof (reloc->name) - 1);\n\t\tr_skiplist_insert (relocs, reloc);\n\t\tfree (sym_name);\n\t}\n\tfree (info);\n}\n\nstatic bool walk_bind_chains_callback(void * context, RFixupEventDetails * event_details) {\n\tr_return_val_if_fail (event_details->type == R_FIXUP_EVENT_BIND || event_details->type == R_FIXUP_EVENT_BIND_AUTH, false);\n\tRWalkBindChainsContext *ctx = context;\n\tut8 *imports = ctx->imports;\n\tstruct MACH0_(obj_t) *bin = event_details->bin;\n\tut32 imports_count = bin->fixups_header.imports_count;\n\tut32 fixups_offset = bin->fixups_offset;\n\tut32 fixups_size = bin->fixups_size;\n\tut32 imports_format = bin->fixups_header.imports_format;\n\tut32 import_index = ((RFixupBindEventDetails *) event_details)->ordinal;\n\tut64 addend = 0;\n\tif (event_details->type != R_FIXUP_EVENT_BIND_AUTH) {\n\t\taddend = ((RFixupBindEventDetails *) event_details)->addend;\n\t}\n\n\tif (import_index < imports_count) {\n\t\tut64 name_offset;\n\t\tswitch (imports_format) {\n\t\t\tcase DYLD_CHAINED_IMPORT: {\n\t\t\t\tstruct dyld_chained_import * item = &((struct dyld_chained_import *) imports)[import_index];\n\t\t\t\tname_offset = item->name_offset;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase DYLD_CHAINED_IMPORT_ADDEND: {\n\t\t\t\tstruct dyld_chained_import_addend * item = &((struct dyld_chained_import_addend *) imports)[import_index];\n\t\t\t\tname_offset = item->name_offset;\n\t\t\t\taddend += item->addend;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase DYLD_CHAINED_IMPORT_ADDEND64: {\n\t\t\t\tstruct dyld_chained_import_addend64 * item = &((struct dyld_chained_import_addend64 *) imports)[import_index];\n\t\t\t\tname_offset = item->name_offset;\n\t\t\t\taddend += item->addend;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdefault:\n\t\t\t\tbprintf (\"Unsupported imports format\\n\");\n\t\t\t\treturn false;\n\t\t}\n\n\t\tut64 symbols_offset = bin->fixups_header.symbols_offset + fixups_offset;\n\n\t\tif (symbols_offset + name_offset + 1 < fixups_offset + fixups_size) {\n\t\t\tchar *name = r_buf_get_string (bin->b, symbols_offset + name_offset);\n\t\t\tif (name) {\n\t\t\t\tstruct reloc_t *reloc = R_NEW0 (struct reloc_t);\n\t\t\t\tif (!reloc) {\n\t\t\t\t\tfree (name);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\treloc->addr = offset_to_vaddr (bin, event_details->offset);\n\t\t\t\treloc->offset = event_details->offset;\n\t\t\t\treloc->ord = import_index;\n\t\t\t\treloc->type = R_BIN_RELOC_64;\n\t\t\t\treloc->size = 8;\n\t\t\t\treloc->addend = addend;\n\t\t\t\tr_str_ncpy (reloc->name, name, sizeof (reloc->name) - 1);\n\t\t\t\tr_skiplist_insert_autofree (ctx->relocs, reloc);\n\t\t\t\tfree (name);\n\t\t\t} else if (bin->verbose) {\n\t\t\t\teprintf (\"Malformed chained bind: failed to read name\\n\");\n\t\t\t}\n\t\t} else if (bin->verbose) {\n\t\t\teprintf (\"Malformed chained bind: name_offset out of bounds\\n\");\n\t\t}\n\t} else if (bin->verbose) {\n\t\teprintf (\"Malformed chained bind: import out of length\\n\");\n\t}\n\n\treturn true;\n}\n\nstatic void walk_bind_chains(struct MACH0_(obj_t) *bin, RSkipList *relocs) {\n\tr_return_if_fail (bin && bin->fixups_offset);\n\n\tut8 *imports = NULL;\n\n\tut32 imports_count = bin->fixups_header.imports_count;\n\tut32 fixups_offset = bin->fixups_offset;\n\tut32 imports_offset = bin->fixups_header.imports_offset;\n\tif (!imports_count || !imports_offset) {\n\t\treturn;\n\t}\n\tif (bin->fixups_header.symbols_format != 0) {\n\t\teprintf (\"Compressed fixups symbols not supported yet, please file a bug with a sample attached.\\n\");\n\t\treturn;\n\t}\n\n\tut32 imports_format = bin->fixups_header.imports_format;\n\tut64 imports_size;\n\tswitch (imports_format) {\n\t\tcase DYLD_CHAINED_IMPORT:\n\t\t\timports_size = sizeof (struct dyld_chained_import) * imports_count;\n\t\t\tbreak;\n\t\tcase DYLD_CHAINED_IMPORT_ADDEND:\n\t\t\timports_size = sizeof (struct dyld_chained_import_addend) * imports_count;\n\t\t\tbreak;\n\t\tcase DYLD_CHAINED_IMPORT_ADDEND64:\n\t\t\timports_size = sizeof (struct dyld_chained_import_addend64) * imports_count;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\teprintf (\"Unsupported chained imports format: %d\\n\", imports_format);\n\t\t\tgoto beach;\n\t}\n\n\timports = malloc (imports_size);\n\tif (!imports) {\n\t\tgoto beach;\n\t}\n\n\tswitch (imports_format) {\n\t\tcase DYLD_CHAINED_IMPORT:\n\t\t\tif (r_buf_fread_at (bin->b, fixups_offset + imports_offset,\n\t\t\t\t\timports, \"i\", imports_count) != imports_size) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase DYLD_CHAINED_IMPORT_ADDEND:\n\t\t\tif (r_buf_fread_at (bin->b, fixups_offset + imports_offset,\n\t\t\t\t\timports, \"ii\", imports_count) != imports_size) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase DYLD_CHAINED_IMPORT_ADDEND64:\n\t\t\tif (r_buf_fread_at (bin->b, fixups_offset + imports_offset,\n\t\t\t\t\timports, \"il\", imports_count) != imports_size) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tbreak;\n\t}\n\n\tRWalkBindChainsContext ctx;\n\tctx.imports = imports;\n\tctx.relocs = relocs;\n\n\tMACH0_(iterate_chained_fixups) (bin, 0, UT64_MAX, R_FIXUP_EVENT_MASK_BIND_ALL, &walk_bind_chains_callback, &ctx);\n\nbeach:\n\tfree (imports);\n}\n\nstatic bool is_valid_ordinal_table_size(ut64 size) {\n\treturn size > 0 && size <= UT16_MAX;\n}\n\nRSkipList *MACH0_(get_relocs)(struct MACH0_(obj_t) *bin) {\n\tRSkipList *relocs = NULL;\n\tRPVector *threaded_binds = NULL;\n\tsize_t wordsize = get_word_size (bin);\n\tif (bin->dyld_info) {\n\t\tut8 *opcodes, rel_type = 0;\n\t\tsize_t bind_size, lazy_size, weak_size;\n\n#define CASE(T) case ((T) / 8): rel_type = R_BIN_RELOC_ ## T; break\n\t\tswitch (wordsize) {\n\t\tCASE(8);\n\t\tCASE(16);\n\t\tCASE(32);\n\t\tCASE(64);\n\t\tdefault: return NULL;\n\t\t}\n#undef CASE\n\t\tbind_size = bin->dyld_info->bind_size;\n\t\tlazy_size = bin->dyld_info->lazy_bind_size;\n\t\tweak_size = bin->dyld_info->weak_bind_size;\n\n\t\tif (!bind_size && !lazy_size) {\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif ((bind_size + lazy_size)<1) {\n\t\t\treturn NULL;\n\t\t}\n\t\tif (bin->dyld_info->bind_off > bin->size || bin->dyld_info->bind_off + bind_size > bin->size) {\n\t\t\treturn NULL;\n\t\t}\n\t\tif (bin->dyld_info->lazy_bind_off > bin->size || \\\n\t\t\tbin->dyld_info->lazy_bind_off + lazy_size > bin->size) {\n\t\t\treturn NULL;\n\t\t}\n\t\tif (bin->dyld_info->bind_off + bind_size + lazy_size > bin->size) {\n\t\t\treturn NULL;\n\t\t}\n\t\tif (bin->dyld_info->weak_bind_off + weak_size > bin->size) {\n\t\t\treturn NULL;\n\t\t}\n\t\tut64 amount = bind_size + lazy_size + weak_size;\n\t\tif (amount == 0 || amount > UT32_MAX) {\n\t\t\treturn NULL;\n\t\t}\n\t\tif (!bin->segs) {\n\t\t\treturn NULL;\n\t\t}\n\t\trelocs = r_skiplist_new ((RListFree) &free, (RListComparator) &reloc_comparator);\n\t\tif (!relocs) {\n\t\t\treturn NULL;\n\t\t}\n\t\topcodes = calloc (1, amount + 1);\n\t\tif (!opcodes) {\n\t\t\tr_skiplist_free (relocs);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tint len = r_buf_read_at (bin->b, bin->dyld_info->bind_off, opcodes, bind_size);\n\t\tlen += r_buf_read_at (bin->b, bin->dyld_info->lazy_bind_off, opcodes + bind_size, lazy_size);\n\t\tlen += r_buf_read_at (bin->b, bin->dyld_info->weak_bind_off, opcodes + bind_size + lazy_size, weak_size);\n\t\tif (len < amount) {\n\t\t\tbprintf (\"Error: read (dyld_info bind) at 0x%08\"PFMT64x\"\\n\", (ut64)(size_t)bin->dyld_info->bind_off);\n\t\t\tR_FREE (opcodes);\n\t\t\tr_skiplist_free (relocs);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tsize_t partition_sizes[] = {bind_size, lazy_size, weak_size};\n\t\tsize_t pidx;\n\t\tint opcodes_offset = 0;\n\t\tfor (pidx = 0; pidx < R_ARRAY_SIZE (partition_sizes); pidx++) {\n\t\t\tsize_t partition_size = partition_sizes[pidx];\n\n\t\t\tut8 type = 0;\n\t\t\tint lib_ord = 0, seg_idx = -1, sym_ord = -1;\n\t\t\tchar *sym_name = NULL;\n\t\t\tsize_t j, count, skip;\n\t\t\tst64 addend = 0;\n\t\t\tut64 addr = bin->segs[0].vmaddr;\n\t\t\tut64 segment_size = bin->segs[0].filesize;\n\t\t\tif (bin->segs[0].filesize != bin->segs[0].vmsize) {\n\t\t\t\t// is probably invalid and we should warn the user\n\t\t\t}\n\t\t\tif (segment_size > bin->size) {\n\t\t\t\t// is probably invalid and we should warn the user\n\t\t\t\tsegment_size = bin->size;\n\t\t\t}\n\t\t\tut64 segment_end_addr = addr + segment_size;\n\n\t\t\tut8 *p = opcodes + opcodes_offset;\n\t\t\tut8 *end = p + partition_size;\n\t\t\tbool done = false;\n\t\t\twhile (!done && p < end) {\n\t\t\t\tut8 imm = *p & BIND_IMMEDIATE_MASK;\n\t\t\t\tut8 op = *p & BIND_OPCODE_MASK;\n\t\t\t\tp++;\n\t\t\t\tswitch (op) {\n\t\t\t\tcase BIND_OPCODE_DONE: {\n\t\t\t\t\tbool in_lazy_binds = pidx == 1;\n\t\t\t\t\tif (!in_lazy_binds) {\n\t\t\t\t\t\tdone = true;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase BIND_OPCODE_THREADED: {\n\t\t\t\t\tswitch (imm) {\n\t\t\t\t\tcase BIND_SUBOPCODE_THREADED_SET_BIND_ORDINAL_TABLE_SIZE_ULEB: {\n\t\t\t\t\t\tut64 table_size = read_uleb128 (&p, end);\n\t\t\t\t\t\tif (!is_valid_ordinal_table_size (table_size)) {\n\t\t\t\t\t\t\tbprintf (\"Error: BIND_SUBOPCODE_THREADED_SET_BIND_ORDINAL_TABLE_SIZE_ULEB size is wrong\\n\");\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (threaded_binds) {\n\t\t\t\t\t\t\tr_pvector_free (threaded_binds);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthreaded_binds = r_pvector_new_with_len ((RPVectorFree) &free, table_size);\n\t\t\t\t\t\tif (threaded_binds) {\n\t\t\t\t\t\t\tsym_ord = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcase BIND_SUBOPCODE_THREADED_APPLY:\n\t\t\t\t\t\tif (threaded_binds) {\n\t\t\t\t\t\t\tint cur_seg_idx = (seg_idx != -1)? seg_idx: 0;\n\t\t\t\t\t\t\tsize_t n_threaded_binds = r_pvector_len (threaded_binds);\n\t\t\t\t\t\t\twhile (addr < segment_end_addr) {\n\t\t\t\t\t\t\t\tut8 tmp[8];\n\t\t\t\t\t\t\t\tut64 paddr = addr - bin->segs[cur_seg_idx].vmaddr + bin->segs[cur_seg_idx].fileoff;\n\t\t\t\t\t\t\t\tbin->rebasing_buffer = true;\n\t\t\t\t\t\t\t\tif (r_buf_read_at (bin->b, paddr, tmp, 8) != 8) {\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbin->rebasing_buffer = false;\n\t\t\t\t\t\t\t\tut64 raw_ptr = r_read_le64 (tmp);\n\t\t\t\t\t\t\t\tbool is_auth = (raw_ptr & (1ULL << 63)) != 0;\n\t\t\t\t\t\t\t\tbool is_bind = (raw_ptr & (1ULL << 62)) != 0;\n\t\t\t\t\t\t\t\tint ordinal = -1;\n\t\t\t\t\t\t\t\tint addend = -1;\n\t\t\t\t\t\t\t\tut64 delta;\n\t\t\t\t\t\t\t\tif (is_auth && is_bind) {\n\t\t\t\t\t\t\t\t\tstruct dyld_chained_ptr_arm64e_auth_bind *p =\n\t\t\t\t\t\t\t\t\t\t\t(struct dyld_chained_ptr_arm64e_auth_bind *) &raw_ptr;\n\t\t\t\t\t\t\t\t\tdelta = p->next;\n\t\t\t\t\t\t\t\t\tordinal = p->ordinal;\n\t\t\t\t\t\t\t\t} else if (!is_auth && is_bind) {\n\t\t\t\t\t\t\t\t\tstruct dyld_chained_ptr_arm64e_bind *p =\n\t\t\t\t\t\t\t\t\t\t\t(struct dyld_chained_ptr_arm64e_bind *) &raw_ptr;\n\t\t\t\t\t\t\t\t\tdelta = p->next;\n\t\t\t\t\t\t\t\t\tordinal = p->ordinal;\n\t\t\t\t\t\t\t\t\taddend = p->addend;\n\t\t\t\t\t\t\t\t} else if (is_auth && !is_bind) {\n\t\t\t\t\t\t\t\t\tstruct dyld_chained_ptr_arm64e_auth_rebase *p =\n\t\t\t\t\t\t\t\t\t\t\t(struct dyld_chained_ptr_arm64e_auth_rebase *) &raw_ptr;\n\t\t\t\t\t\t\t\t\tdelta = p->next;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tstruct dyld_chained_ptr_arm64e_rebase *p =\n\t\t\t\t\t\t\t\t\t\t\t(struct dyld_chained_ptr_arm64e_rebase *) &raw_ptr;\n\t\t\t\t\t\t\t\t\tdelta = p->next;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (ordinal != -1) {\n\t\t\t\t\t\t\t\t\tif (ordinal >= n_threaded_binds) {\n\t\t\t\t\t\t\t\t\t\tbprintf (\"Error: Malformed bind chain\\n\");\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tstruct reloc_t *ref = r_pvector_at (threaded_binds, ordinal);\n\t\t\t\t\t\t\t\t\tif (!ref) {\n\t\t\t\t\t\t\t\t\t\tbprintf (\"Error: Inconsistent bind opcodes\\n\");\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tstruct reloc_t *reloc = R_NEW0 (struct reloc_t);\n\t\t\t\t\t\t\t\t\tif (!reloc) {\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t*reloc = *ref;\n\t\t\t\t\t\t\t\t\treloc->addr = addr;\n\t\t\t\t\t\t\t\t\treloc->offset = paddr;\n\t\t\t\t\t\t\t\t\tif (addend != -1) {\n\t\t\t\t\t\t\t\t\t\treloc->addend = addend;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tr_skiplist_insert (relocs, reloc);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\taddr += delta * wordsize;\n\t\t\t\t\t\t\t\tif (!delta) {\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tbprintf (\"Error: Unexpected BIND_OPCODE_THREADED sub-opcode: 0x%x\\n\", imm);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase BIND_OPCODE_SET_DYLIB_ORDINAL_IMM:\n\t\t\t\t\tlib_ord = imm;\n\t\t\t\t\tbreak;\n\t\t\t\tcase BIND_OPCODE_SET_DYLIB_ORDINAL_ULEB:\n\t\t\t\t\tlib_ord = read_uleb128 (&p, end);\n\t\t\t\t\tbreak;\n\t\t\t\tcase BIND_OPCODE_SET_DYLIB_SPECIAL_IMM:\n\t\t\t\t\tlib_ord = imm? (st8)(BIND_OPCODE_MASK | imm) : 0;\n\t\t\t\t\tbreak;\n\t\t\t\tcase BIND_OPCODE_SET_SYMBOL_TRAILING_FLAGS_IMM: {\n\t\t\t\t\tsym_name = (char*)p;\n\t\t\t\t\twhile (*p++ && p < end) {\n\t\t\t\t\t\t/* empty loop */\n\t\t\t\t\t}\n\t\t\t\t\tif (threaded_binds) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tsym_ord = -1;\n\t\t\t\t\tif (bin->symtab && bin->dysymtab.nundefsym < UT16_MAX) {\n\t\t\t\t\t\tfor (j = 0; j < bin->dysymtab.nundefsym; j++) {\n\t\t\t\t\t\t\tsize_t stridx = 0;\n\t\t\t\t\t\t\tbool found = false;\n\t\t\t\t\t\t\tint iundefsym = bin->dysymtab.iundefsym;\n\t\t\t\t\t\t\tif (iundefsym >= 0 && iundefsym < bin->nsymtab) {\n\t\t\t\t\t\t\t\tint sidx = iundefsym + j;\n\t\t\t\t\t\t\t\tif (sidx < 0 || sidx >= bin->nsymtab) {\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tstridx = bin->symtab[sidx].n_strx;\n\t\t\t\t\t\t\t\tif (stridx >= bin->symstrlen) {\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (found && !strcmp ((const char *)bin->symstr + stridx, sym_name)) {\n\t\t\t\t\t\t\t\tsym_ord = j;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase BIND_OPCODE_SET_TYPE_IMM:\n\t\t\t\t\ttype = imm;\n\t\t\t\t\tbreak;\n\t\t\t\tcase BIND_OPCODE_SET_ADDEND_SLEB:\n\t\t\t\t\taddend = r_sleb128 ((const ut8 **)&p, end);\n\t\t\t\t\tbreak;\n\t\t\t\tcase BIND_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB:\n\t\t\t\t\tseg_idx = imm;\n\t\t\t\t\tif (seg_idx >= bin->nsegs) {\n\t\t\t\t\t\tbprintf (\"Error: BIND_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB\"\n\t\t\t\t\t\t\t\" has unexistent segment %d\\n\", seg_idx);\n\t\t\t\t\t\tfree (opcodes);\n\t\t\t\t\t\tr_skiplist_free (relocs);\n\t\t\t\t\t\tr_pvector_free (threaded_binds);\n\t\t\t\t\t\treturn NULL; // early exit to avoid future mayhem\n\t\t\t\t\t}\n\t\t\t\t\taddr = bin->segs[seg_idx].vmaddr + read_uleb128 (&p, end);\n\t\t\t\t\tsegment_end_addr = bin->segs[seg_idx].vmaddr \\\n\t\t\t\t\t\t\t+ bin->segs[seg_idx].vmsize;\n\t\t\t\t\tbreak;\n\t\t\t\tcase BIND_OPCODE_ADD_ADDR_ULEB:\n\t\t\t\t\taddr += read_uleb128 (&p, end);\n\t\t\t\t\tbreak;\n#define DO_BIND() do {\\\n\tif (sym_ord < 0 && !sym_name) break;\\\n\tif (!threaded_binds) {\\\n\t\tif (seg_idx < 0 ) break;\\\n\t\tif (!addr) break;\\\n\t}\\\n\tstruct reloc_t *reloc = R_NEW0 (struct reloc_t);\\\n\treloc->addr = addr;\\\n\tif (seg_idx >= 0) {\\\n\t\treloc->offset = addr - bin->segs[seg_idx].vmaddr + bin->segs[seg_idx].fileoff;\\\n\t\tif (type == BIND_TYPE_TEXT_PCREL32)\\\n\t\t\treloc->addend = addend - (bin->baddr + addr);\\\n\t\telse\\\n\t\t\treloc->addend = addend;\\\n\t} else {\\\n\t\treloc->addend = addend;\\\n\t}\\\n\t/* library ordinal ??? */ \\\n\treloc->ord = lib_ord;\\\n\treloc->ord = sym_ord;\\\n\treloc->type = rel_type;\\\n\tif (sym_name)\\\n\t\tr_str_ncpy (reloc->name, sym_name, 256);\\\n\tif (threaded_binds)\\\n\t\tr_pvector_set (threaded_binds, sym_ord, reloc);\\\n\telse\\\n\t\tr_skiplist_insert (relocs, reloc);\\\n} while (0)\n\t\t\t\tcase BIND_OPCODE_DO_BIND:\n\t\t\t\t\tif (!threaded_binds && addr >= segment_end_addr) {\n\t\t\t\t\t\tbprintf (\"Error: Malformed DO bind opcode 0x%\"PFMT64x\"\\n\", addr);\n\t\t\t\t\t\tgoto beach;\n\t\t\t\t\t}\n\t\t\t\t\tDO_BIND ();\n\t\t\t\t\tif (!threaded_binds) {\n\t\t\t\t\t\taddr += wordsize;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsym_ord++;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase BIND_OPCODE_DO_BIND_ADD_ADDR_ULEB:\n\t\t\t\t\tif (addr >= segment_end_addr) {\n\t\t\t\t\t\tbprintf (\"Error: Malformed ADDR ULEB bind opcode\\n\");\n\t\t\t\t\t\tgoto beach;\n\t\t\t\t\t}\n\t\t\t\t\tDO_BIND ();\n\t\t\t\t\taddr += read_uleb128 (&p, end) + wordsize;\n\t\t\t\t\tbreak;\n\t\t\t\tcase BIND_OPCODE_DO_BIND_ADD_ADDR_IMM_SCALED:\n\t\t\t\t\tif (addr >= segment_end_addr) {\n\t\t\t\t\t\tbprintf (\"Error: Malformed IMM SCALED bind opcode\\n\");\n\t\t\t\t\t\tgoto beach;\n\t\t\t\t\t}\n\t\t\t\t\tDO_BIND ();\n\t\t\t\t\taddr += (ut64)imm * (ut64)wordsize + wordsize;\n\t\t\t\t\tbreak;\n\t\t\t\tcase BIND_OPCODE_DO_BIND_ULEB_TIMES_SKIPPING_ULEB:\n\t\t\t\t\tcount = read_uleb128 (&p, end);\n\t\t\t\t\tskip = read_uleb128 (&p, end);\n\t\t\t\t\tfor (j = 0; j < count; j++) {\n\t\t\t\t\t\tif (addr >= segment_end_addr) {\n\t\t\t\t\t\t\tbprintf (\"Error: Malformed ULEB TIMES bind opcode\\n\");\n\t\t\t\t\t\t\tgoto beach;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tDO_BIND ();\n\t\t\t\t\t\taddr += skip + wordsize;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n#undef DO_BIND\n\t\t\t\tdefault:\n\t\t\t\t\tbprintf (\"Error: unknown bind opcode 0x%02x in dyld_info\\n\", *p);\n\t\t\t\t\tR_FREE (opcodes);\n\t\t\t\t\tr_pvector_free (threaded_binds);\n\t\t\t\t\treturn relocs;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\topcodes_offset += partition_size;\n\t\t}\n\n\t\tR_FREE (opcodes);\n\t\tr_pvector_free (threaded_binds);\n\t\tthreaded_binds = NULL;\n\t}\n\n\tif (bin->symtab && bin->symstr && bin->sects && bin->indirectsyms) {\n\t\tint j;\n\t\tint amount = bin->dysymtab.nundefsym;\n\t\tif (amount < 0) {\n\t\t\tamount = 0;\n\t\t}\n\t\tif (!relocs) {\n\t\t\trelocs = r_skiplist_new ((RListFree) &free, (RListComparator) &reloc_comparator);\n\t\t\tif (!relocs) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t}\n\t\tfor (j = 0; j < amount; j++) {\n\t\t\tstruct reloc_t *reloc = R_NEW0 (struct reloc_t);\n\t\t\tif (!reloc) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (parse_import_ptr (bin, reloc, bin->dysymtab.iundefsym + j)) {\n\t\t\t\treloc->ord = j;\n\t\t\t\tr_skiplist_insert_autofree (relocs, reloc);\n\t\t\t} else {\n\t\t\t\tR_FREE (reloc);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (bin->symtab && bin->dysymtab.extreloff && bin->dysymtab.nextrel) {\n\t\tif (!relocs) {\n\t\t\trelocs = r_skiplist_new ((RListFree) &free, (RListComparator) &reloc_comparator);\n\t\t\tif (!relocs) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t}\n\t\tparse_relocation_info (bin, relocs, bin->dysymtab.extreloff, bin->dysymtab.nextrel);\n\t}\n\n\tif (!bin->dyld_info && bin->chained_starts && bin->nsegs && bin->fixups_offset) {\n\t\tif (!relocs) {\n\t\t\trelocs = r_skiplist_new ((RListFree) &free, (RListComparator) &reloc_comparator);\n\t\t\tif (!relocs) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t}\n\t\twalk_bind_chains (bin, relocs);\n\t}\nbeach:\n\tr_pvector_free (threaded_binds);\n\treturn relocs;\n}\n\nstruct addr_t *MACH0_(get_entrypoint)(struct MACH0_(obj_t) *bin) {\n\tr_return_val_if_fail (bin, NULL);\n\n\tut64 ea = entry_to_vaddr (bin);\n\tif (ea == 0 || ea == UT64_MAX) {\n\t\treturn NULL;\n\t}\n\tstruct addr_t *entry = R_NEW0 (struct addr_t);\n\tif (!entry) {\n\t\treturn NULL;\n\t}\n\tentry->addr = ea;\n\tentry->offset = addr_to_offset (bin, entry->addr);\n\tentry->haddr = sdb_num_get (bin->kv, \"mach0.entry.offset\", 0);\n\tsdb_num_set (bin->kv, \"mach0.entry.vaddr\", entry->addr, 0);\n\tsdb_num_set (bin->kv, \"mach0.entry.paddr\", bin->entry, 0);\n\n\tif (entry->offset == 0 && !bin->sects) {\n\t\tint i;\n\t\tfor (i = 0; i < bin->nsects; i++) {\n\t\t\t// XXX: section name shoudnt matter .. just check for exec flags\n\t\t\tif (!strncmp (bin->sects[i].sectname, \"__text\", 6)) {\n\t\t\t\tentry->offset = (ut64)bin->sects[i].offset;\n\t\t\t\tsdb_num_set (bin->kv, \"mach0.entry\", entry->offset, 0);\n\t\t\t\tentry->addr = (ut64)bin->sects[i].addr;\n\t\t\t\tif (!entry->addr) { // workaround for object files\n\t\t\t\t\teprintf (\"entrypoint is 0...\\n\");\n\t\t\t\t\t// XXX(lowlyw) there's technically not really entrypoints\n\t\t\t\t\t// for .o files, so ignore this...\n\t\t\t\t\t// entry->addr = entry->offset;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbin->entry = entry->addr;\n\t}\n\treturn entry;\n}\n\nvoid MACH0_(kv_loadlibs)(struct MACH0_(obj_t) *bin) {\n\tint i;\n\tchar lib_flagname[128];\n\tfor (i = 0; i < bin->nlibs; i++) {\n\t\tsnprintf (lib_flagname, sizeof (lib_flagname), \"libs.%d.name\", i);\n\t\tsdb_set (bin->kv, lib_flagname, bin->libs[i], 0);\n\t}\n}\n\nstruct lib_t *MACH0_(get_libs)(struct MACH0_(obj_t) *bin) {\n\tstruct lib_t *libs;\n\tint i;\n\tchar lib_flagname[128];\n\n\tif (!bin->nlibs) {\n\t\treturn NULL;\n\t}\n\tif (!(libs = calloc ((bin->nlibs + 1), sizeof (struct lib_t)))) {\n\t\treturn NULL;\n\t}\n\tfor (i = 0; i < bin->nlibs; i++) {\n\t\tsnprintf (lib_flagname, sizeof (lib_flagname), \"libs.%d.name\", i);\n\t\tsdb_set (bin->kv, lib_flagname, bin->libs[i], 0);\n\t\tr_str_ncpy (libs[i].name, bin->libs[i], R_BIN_MACH0_STRING_LENGTH - 1);\n\t\tlibs[i].last = 0;\n\t}\n\tlibs[i].last = 1;\n\treturn libs;\n}\n\nut64 MACH0_(get_baddr)(struct MACH0_(obj_t) *bin) {\n\tint i;\n\n\tif (bin->hdr.filetype != MH_EXECUTE && bin->hdr.filetype != MH_DYLINKER &&\n\t\t\tbin->hdr.filetype != MH_FILESET) {\n\t\treturn 0;\n\t}\n\tfor (i = 0; i < bin->nsegs; i++) {\n\t\tif (bin->segs[i].fileoff == 0 && bin->segs[i].filesize != 0) {\n\t\t\treturn bin->segs[i].vmaddr;\n\t\t}\n\t}\n\treturn 0;\n}\n\nchar *MACH0_(get_class)(struct MACH0_(obj_t) *bin) {\n#if R_BIN_MACH064\n\treturn r_str_new (\"MACH064\");\n#else\n\treturn r_str_new (\"MACH0\");\n#endif\n}\n\n//XXX we are mixing up bits from cpu and opcodes\n//since thumb use 16 bits opcode but run in 32 bits\n//cpus  so here we should only return 32 or 64\nint MACH0_(get_bits)(struct MACH0_(obj_t) *bin) {\n\tif (bin) {\n\t\tint bits = MACH0_(get_bits_from_hdr) (&bin->hdr);\n\t\tif (bin->hdr.cputype == CPU_TYPE_ARM && bin->entry & 1) {\n\t\t\treturn 16;\n\t\t}\n\t\treturn bits;\n\t}\n\treturn 32;\n}\n\nint MACH0_(get_bits_from_hdr)(struct MACH0_(mach_header) *hdr) {\n\tif (hdr->magic == MH_MAGIC_64 || hdr->magic == MH_CIGAM_64) {\n\t\treturn 64;\n\t}\n\tif (hdr->cputype == CPU_TYPE_ARM64_32) { // new apple watch aka arm64_32\n\t\treturn 64;\n\t}\n\tif ((hdr->cpusubtype & CPU_SUBTYPE_MASK) == (CPU_SUBTYPE_ARM_V7K << 24)) {\n\t\treturn 16;\n\t}\n\treturn 32;\n}\n\nbool MACH0_(is_big_endian)(struct MACH0_(obj_t) *bin) {\n\tif (bin) {\n\t\tconst int cpu = bin->hdr.cputype;\n\t\treturn cpu == CPU_TYPE_POWERPC || cpu == CPU_TYPE_POWERPC64;\n\t}\n\treturn false;\n}\n\nconst char *MACH0_(get_intrp)(struct MACH0_(obj_t) *bin) {\n\treturn bin? bin->intrp: NULL;\n}\n\nconst char *MACH0_(get_os)(struct MACH0_(obj_t) *bin) {\n\tif (bin) {\n\t\tswitch (bin->os) {\n\t\tcase 1: return \"macos\";\n\t\tcase 2: return \"ios\";\n\t\tcase 3: return \"watchos\";\n\t\tcase 4: return \"tvos\";\n\t\t}\n\t}\n\treturn \"darwin\";\n}\n\nconst char *MACH0_(get_cputype_from_hdr)(struct MACH0_(mach_header) *hdr) {\n\tconst char *archstr = \"unknown\";\n\tswitch (hdr->cputype) {\n\tcase CPU_TYPE_VAX:\n\t\tarchstr = \"vax\";\n\t\tbreak;\n\tcase CPU_TYPE_MC680x0:\n\t\tarchstr = \"mc680x0\";\n\t\tbreak;\n\tcase CPU_TYPE_I386:\n\tcase CPU_TYPE_X86_64:\n\t\tarchstr = \"x86\";\n\t\tbreak;\n\tcase CPU_TYPE_MC88000:\n\t\tarchstr = \"mc88000\";\n\t\tbreak;\n\tcase CPU_TYPE_MC98000:\n\t\tarchstr = \"mc98000\";\n\t\tbreak;\n\tcase CPU_TYPE_HPPA:\n\t\tarchstr = \"hppa\";\n\t\tbreak;\n\tcase CPU_TYPE_ARM:\n\tcase CPU_TYPE_ARM64:\n\tcase CPU_TYPE_ARM64_32:\n\t\tarchstr = \"arm\";\n\t\tbreak;\n\tcase CPU_TYPE_SPARC:\n\t\tarchstr = \"sparc\";\n\t\tbreak;\n\tcase CPU_TYPE_MIPS:\n\t\tarchstr = \"mips\";\n\t\tbreak;\n\tcase CPU_TYPE_I860:\n\t\tarchstr = \"i860\";\n\t\tbreak;\n\tcase CPU_TYPE_POWERPC:\n\tcase CPU_TYPE_POWERPC64:\n\t\tarchstr = \"ppc\";\n\t\tbreak;\n\tdefault:\n\t\teprintf (\"Unknown arch %d\\n\", hdr->cputype);\n\t\tbreak;\n\t}\n\treturn archstr;\n}\n\nconst char *MACH0_(get_cputype)(struct MACH0_(obj_t) *bin) {\n\treturn bin? MACH0_(get_cputype_from_hdr) (&bin->hdr): \"unknown\";\n}\n\nstatic const char *cpusubtype_tostring(ut32 cputype, ut32 cpusubtype) {\n\tswitch (cputype) {\n\tcase CPU_TYPE_VAX:\n\t\tswitch (cpusubtype) {\n\t\tcase CPU_SUBTYPE_VAX_ALL:\treturn \"all\";\n\t\tcase CPU_SUBTYPE_VAX780:\treturn \"vax780\";\n\t\tcase CPU_SUBTYPE_VAX785:\treturn \"vax785\";\n\t\tcase CPU_SUBTYPE_VAX750:\treturn \"vax750\";\n\t\tcase CPU_SUBTYPE_VAX730:\treturn \"vax730\";\n\t\tcase CPU_SUBTYPE_UVAXI:\t\treturn \"uvaxI\";\n\t\tcase CPU_SUBTYPE_UVAXII:\treturn \"uvaxII\";\n\t\tcase CPU_SUBTYPE_VAX8200:\treturn \"vax8200\";\n\t\tcase CPU_SUBTYPE_VAX8500:\treturn \"vax8500\";\n\t\tcase CPU_SUBTYPE_VAX8600:\treturn \"vax8600\";\n\t\tcase CPU_SUBTYPE_VAX8650:\treturn \"vax8650\";\n\t\tcase CPU_SUBTYPE_VAX8800:\treturn \"vax8800\";\n\t\tcase CPU_SUBTYPE_UVAXIII:\treturn \"uvaxIII\";\n\t\tdefault:\t\t\treturn \"Unknown vax subtype\";\n\t\t}\n\tcase CPU_TYPE_MC680x0:\n\t\tswitch (cpusubtype) {\n\t\tcase CPU_SUBTYPE_MC68030:\treturn \"mc68030\";\n\t\tcase CPU_SUBTYPE_MC68040:\treturn \"mc68040\";\n\t\tcase CPU_SUBTYPE_MC68030_ONLY:\treturn \"mc68030 only\";\n\t\tdefault:\t\t\treturn \"Unknown mc680x0 subtype\";\n\t\t}\n\tcase CPU_TYPE_I386:\n\t\tswitch (cpusubtype) {\n\t\tcase CPU_SUBTYPE_386: \t\t\treturn \"386\";\n\t\tcase CPU_SUBTYPE_486: \t\t\treturn \"486\";\n\t\tcase CPU_SUBTYPE_486SX: \t\treturn \"486sx\";\n\t\tcase CPU_SUBTYPE_PENT: \t\t\treturn \"Pentium\";\n\t\tcase CPU_SUBTYPE_PENTPRO: \t\treturn \"Pentium Pro\";\n\t\tcase CPU_SUBTYPE_PENTII_M3: \t\treturn \"Pentium 3 M3\";\n\t\tcase CPU_SUBTYPE_PENTII_M5: \t\treturn \"Pentium 3 M5\";\n\t\tcase CPU_SUBTYPE_CELERON: \t\treturn \"Celeron\";\n\t\tcase CPU_SUBTYPE_CELERON_MOBILE:\treturn \"Celeron Mobile\";\n\t\tcase CPU_SUBTYPE_PENTIUM_3:\t\treturn \"Pentium 3\";\n\t\tcase CPU_SUBTYPE_PENTIUM_3_M:\t\treturn \"Pentium 3 M\";\n\t\tcase CPU_SUBTYPE_PENTIUM_3_XEON:\treturn \"Pentium 3 Xeon\";\n\t\tcase CPU_SUBTYPE_PENTIUM_M:\t\treturn \"Pentium Mobile\";\n\t\tcase CPU_SUBTYPE_PENTIUM_4:\t\treturn \"Pentium 4\";\n\t\tcase CPU_SUBTYPE_PENTIUM_4_M:\t\treturn \"Pentium 4 M\";\n\t\tcase CPU_SUBTYPE_ITANIUM:\t\treturn \"Itanium\";\n\t\tcase CPU_SUBTYPE_ITANIUM_2:\t\treturn \"Itanium 2\";\n\t\tcase CPU_SUBTYPE_XEON:\t\t\treturn \"Xeon\";\n\t\tcase CPU_SUBTYPE_XEON_MP:\t\treturn \"Xeon MP\";\n\t\tdefault:\t\t\t\treturn \"Unknown i386 subtype\";\n\t\t}\n\tcase CPU_TYPE_X86_64:\n\t\tswitch (cpusubtype & 0xff) {\n\t\tcase CPU_SUBTYPE_X86_64_ALL:\treturn \"x86 64 all\";\n\t\tcase CPU_SUBTYPE_X86_ARCH1:\treturn \"x86 arch 1\";\n\t\tdefault:\t\t\treturn \"Unknown x86 subtype\";\n\t\t}\n\tcase CPU_TYPE_MC88000:\n\t\tswitch (cpusubtype & 0xff) {\n\t\tcase CPU_SUBTYPE_MC88000_ALL:\treturn \"all\";\n\t\tcase CPU_SUBTYPE_MC88100:\treturn \"mc88100\";\n\t\tcase CPU_SUBTYPE_MC88110:\treturn \"mc88110\";\n\t\tdefault:\t\t\treturn \"Unknown mc88000 subtype\";\n\t\t}\n\tcase CPU_TYPE_MC98000:\n\t\tswitch (cpusubtype & 0xff) {\n\t\tcase CPU_SUBTYPE_MC98000_ALL:\treturn \"all\";\n\t\tcase CPU_SUBTYPE_MC98601:\treturn \"mc98601\";\n\t\tdefault:\t\t\treturn \"Unknown mc98000 subtype\";\n\t\t}\n\tcase CPU_TYPE_HPPA:\n\t\tswitch (cpusubtype & 0xff) {\n\t\tcase CPU_SUBTYPE_HPPA_7100:\treturn \"hppa7100\";\n\t\tcase CPU_SUBTYPE_HPPA_7100LC:\treturn \"hppa7100LC\";\n\t\tdefault:\t\t\treturn \"Unknown hppa subtype\";\n\t\t}\n\tcase CPU_TYPE_ARM64:\n\t\tswitch (cpusubtype & 0xff) {\n\t\tcase CPU_SUBTYPE_ARM64_ALL:\treturn \"all\";\n\t\tcase CPU_SUBTYPE_ARM64_V8:\treturn \"arm64v8\";\n\t\tcase CPU_SUBTYPE_ARM64E:\treturn \"arm64e\";\n\t\tdefault:\t\t\treturn \"Unknown arm64 subtype\";\n\t\t}\n\tcase CPU_TYPE_ARM:\n\t\tswitch (cpusubtype & 0xff) {\n\t\tcase CPU_SUBTYPE_ARM_ALL:\n\t\t\treturn \"all\";\n\t\tcase CPU_SUBTYPE_ARM_V4T:\n\t\t\treturn \"v4t\";\n\t\tcase CPU_SUBTYPE_ARM_V5:\n\t\t\treturn \"v5\";\n\t\tcase CPU_SUBTYPE_ARM_V6:\n\t\t\treturn \"v6\";\n\t\tcase CPU_SUBTYPE_ARM_XSCALE:\n\t\t\treturn \"xscale\";\n\t\tcase CPU_SUBTYPE_ARM_V7:\n\t\t\treturn \"v7\";\n\t\tcase CPU_SUBTYPE_ARM_V7F:\n\t\t\treturn \"v7f\";\n\t\tcase CPU_SUBTYPE_ARM_V7S:\n\t\t\treturn \"v7s\";\n\t\tcase CPU_SUBTYPE_ARM_V7K:\n\t\t\treturn \"v7k\";\n\t\tcase CPU_SUBTYPE_ARM_V7M:\n\t\t\treturn \"v7m\";\n\t\tcase CPU_SUBTYPE_ARM_V7EM:\n\t\t\treturn \"v7em\";\n\t\tdefault:\n\t\t\teprintf (\"Unknown arm subtype %d\\n\", cpusubtype & 0xff);\n\t\t\treturn \"unknown arm subtype\";\n\t\t}\n\tcase CPU_TYPE_SPARC:\n\t\tswitch (cpusubtype & 0xff) {\n\t\tcase CPU_SUBTYPE_SPARC_ALL:\treturn \"all\";\n\t\tdefault:\t\t\treturn \"Unknown sparc subtype\";\n\t\t}\n\tcase CPU_TYPE_MIPS:\n\t\tswitch (cpusubtype & 0xff) {\n\t\tcase CPU_SUBTYPE_MIPS_ALL:\treturn \"all\";\n\t\tcase CPU_SUBTYPE_MIPS_R2300:\treturn \"r2300\";\n\t\tcase CPU_SUBTYPE_MIPS_R2600:\treturn \"r2600\";\n\t\tcase CPU_SUBTYPE_MIPS_R2800:\treturn \"r2800\";\n\t\tcase CPU_SUBTYPE_MIPS_R2000a:\treturn \"r2000a\";\n\t\tcase CPU_SUBTYPE_MIPS_R2000:\treturn \"r2000\";\n\t\tcase CPU_SUBTYPE_MIPS_R3000a:\treturn \"r3000a\";\n\t\tcase CPU_SUBTYPE_MIPS_R3000:\treturn \"r3000\";\n\t\tdefault:\t\t\treturn \"Unknown mips subtype\";\n\t\t}\n\tcase CPU_TYPE_I860:\n\t\tswitch (cpusubtype & 0xff) {\n\t\tcase CPU_SUBTYPE_I860_ALL:\treturn \"all\";\n\t\tcase CPU_SUBTYPE_I860_860:\treturn \"860\";\n\t\tdefault:\t\t\treturn \"Unknown i860 subtype\";\n\t\t}\n\tcase CPU_TYPE_POWERPC:\n\tcase CPU_TYPE_POWERPC64:\n\t\tswitch (cpusubtype & 0xff) {\n\t\tcase CPU_SUBTYPE_POWERPC_ALL:\treturn \"all\";\n\t\tcase CPU_SUBTYPE_POWERPC_601:\treturn \"601\";\n\t\tcase CPU_SUBTYPE_POWERPC_602:\treturn \"602\";\n\t\tcase CPU_SUBTYPE_POWERPC_603:\treturn \"603\";\n\t\tcase CPU_SUBTYPE_POWERPC_603e:\treturn \"603e\";\n\t\tcase CPU_SUBTYPE_POWERPC_603ev:\treturn \"603ev\";\n\t\tcase CPU_SUBTYPE_POWERPC_604:\treturn \"604\";\n\t\tcase CPU_SUBTYPE_POWERPC_604e:\treturn \"604e\";\n\t\tcase CPU_SUBTYPE_POWERPC_620:\treturn \"620\";\n\t\tcase CPU_SUBTYPE_POWERPC_750:\treturn \"750\";\n\t\tcase CPU_SUBTYPE_POWERPC_7400:\treturn \"7400\";\n\t\tcase CPU_SUBTYPE_POWERPC_7450:\treturn \"7450\";\n\t\tcase CPU_SUBTYPE_POWERPC_970:\treturn \"970\";\n\t\tdefault:\t\t\treturn \"Unknown ppc subtype\";\n\t\t}\n\t}\n\treturn \"Unknown cputype\";\n}\n\nchar *MACH0_(get_cpusubtype_from_hdr)(struct MACH0_(mach_header) *hdr) {\n\tr_return_val_if_fail (hdr, NULL);\n\treturn strdup (cpusubtype_tostring (hdr->cputype, hdr->cpusubtype));\n}\n\nchar *MACH0_(get_cpusubtype)(struct MACH0_(obj_t) *bin) {\n\treturn bin? MACH0_(get_cpusubtype_from_hdr) (&bin->hdr): strdup (\"Unknown\");\n}\n\nbool MACH0_(is_pie)(struct MACH0_(obj_t) *bin) {\n\treturn (bin && bin->hdr.filetype == MH_EXECUTE && bin->hdr.flags & MH_PIE);\n}\n\nbool MACH0_(has_nx)(struct MACH0_(obj_t) *bin) {\n\treturn (bin && bin->hdr.filetype == MH_EXECUTE &&\n\t\tbin->hdr.flags & MH_NO_HEAP_EXECUTION);\n}\n\nchar *MACH0_(get_filetype_from_hdr)(struct MACH0_(mach_header) *hdr) {\n\tconst char *mhtype = \"Unknown\";\n\tswitch (hdr->filetype) {\n\tcase MH_OBJECT:     mhtype = \"Relocatable object\"; break;\n\tcase MH_EXECUTE:    mhtype = \"Executable file\"; break;\n\tcase MH_FVMLIB:     mhtype = \"Fixed VM shared library\"; break;\n\tcase MH_CORE:       mhtype = \"Core file\"; break;\n\tcase MH_PRELOAD:    mhtype = \"Preloaded executable file\"; break;\n\tcase MH_DYLIB:      mhtype = \"Dynamically bound shared library\"; break;\n\tcase MH_DYLINKER:   mhtype = \"Dynamic link editor\"; break;\n\tcase MH_BUNDLE:     mhtype = \"Dynamically bound bundle file\"; break;\n\tcase MH_DYLIB_STUB: mhtype = \"Shared library stub for static linking (no sections)\"; break;\n\tcase MH_DSYM:       mhtype = \"Companion file with only debug sections\"; break;\n\tcase MH_KEXT_BUNDLE: mhtype = \"Kernel extension bundle file\"; break;\n\tcase MH_FILESET:    mhtype = \"Kernel cache file\"; break;\n\t}\n\treturn strdup (mhtype);\n}\n\nchar *MACH0_(get_filetype)(struct MACH0_(obj_t) *bin) {\n\treturn bin? MACH0_(get_filetype_from_hdr) (&bin->hdr): strdup (\"Unknown\");\n}\n\nut64 MACH0_(get_main)(struct MACH0_(obj_t) *bin) {\n\tut64 addr = UT64_MAX;\n\tint i;\n\n\t// 0 = sscanned but no main found\n\t// -1 = not scanned, so no main\n\t// other = valid main addr\n\tif (bin->main_addr == UT64_MAX) {\n#if FEATURE_SYMLIST\n\t\t (void)MACH0_(get_symbols_list) (bin);\n#else\n\t\t (void)MACH0_(get_symbols) (bin);\n#endif\n\t}\n\tif (bin->main_addr != 0 && bin->main_addr != UT64_MAX) {\n\t\treturn bin->main_addr;\n\t}\n\t// dummy call to initialize things\n\tfree (MACH0_(get_entrypoint)(bin));\n\n\tbin->main_addr = 0;\n\n\tif (addr == UT64_MAX && bin->main_cmd.cmd == LC_MAIN) {\n\t\taddr = bin->entry + bin->baddr;\n\t}\n\n\tif (!addr) {\n\t\tut8 b[128];\n\t\tut64 entry = addr_to_offset (bin, bin->entry);\n\t\t// XXX: X86 only and hacky!\n\t\tif (entry > bin->size || entry + sizeof (b) > bin->size) {\n\t\t\treturn UT64_MAX;\n\t\t}\n\t\ti = r_buf_read_at (bin->b, entry, b, sizeof (b));\n\t\tif (i < 80) {\n\t\t\treturn UT64_MAX;\n\t\t}\n\t\tfor (i = 0; i < 64; i++) {\n\t\t\tif (b[i] == 0xe8 && !b[i + 3] && !b[i + 4]) {\n\t\t\t\tint delta = b[i + 1] | (b[i + 2] << 8) | (b[i + 3] << 16) | (b[i + 4] << 24);\n\t\t\t\taddr = bin->entry + i + 5 + delta;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!addr) {\n\t\t\taddr = entry;\n\t\t}\n\t}\n\treturn bin->main_addr = addr;\n}\n\nvoid MACH0_(mach_headerfields)(RBinFile *bf) {\n\tPrintfCallback cb_printf = bf->rbin->cb_printf;\n\tif (!cb_printf) {\n\t\tcb_printf = printf;\n\t}\n\tRBuffer *buf = bf->buf;\n\tut64 length = r_buf_size (buf);\n\tint n = 0;\n\tstruct MACH0_(mach_header) *mh = MACH0_(get_hdr)(buf);\n\tif (!mh) {\n\t\treturn;\n\t}\n\tut64 pvaddr = pa2va (bf, 0);\n\tcb_printf (\"pf.mach0_header @ 0x%08\"PFMT64x\"\\n\", pvaddr);\n\tcb_printf (\"0x%08\"PFMT64x\"  Magic       0x%x\\n\", pvaddr, mh->magic);\n\tpvaddr += 4;\n\tcb_printf (\"0x%08\"PFMT64x\"  CpuType     0x%x\\n\", pvaddr, mh->cputype);\n\tpvaddr += 4;\n\tcb_printf (\"0x%08\"PFMT64x\"  CpuSubType  0x%x\\n\", pvaddr, mh->cpusubtype);\n\tpvaddr += 4;\n\tcb_printf (\"0x%08\"PFMT64x\"  FileType    0x%x\\n\", pvaddr, mh->filetype);\n\tpvaddr += 4;\n\tcb_printf (\"0x%08\"PFMT64x\"  nCmds       %d\\n\", pvaddr, mh->ncmds);\n\tpvaddr += 4;\n\tcb_printf (\"0x%08\"PFMT64x\"  sizeOfCmds  %d\\n\", pvaddr, mh->sizeofcmds);\n\tpvaddr += 4;\n\tcb_printf (\"0x%08\"PFMT64x\"  Flags       0x%x\\n\", pvaddr, mh->flags);\n\tpvaddr += 4;\n\tbool is64 = mh->cputype >> 16;\n\n\tut64 addr = 0x20 - 4;\n\tut32 word = 0;\n\tut8 wordbuf[sizeof (word)];\n\tbool isBe = false;\n\tswitch (mh->cputype) {\n\tcase CPU_TYPE_POWERPC:\n\tcase CPU_TYPE_POWERPC64:\n\t\tisBe = true;\n\t\tbreak;\n\t}\n#define READWORD() \\\n\t\tif (r_buf_read_at (buf, addr, (ut8*)wordbuf, 4) != 4) { \\\n\t\t\teprintf (\"Invalid address in buffer.\\n\"); \\\n\t\t\tbreak; \\\n\t\t} \\\n\t\taddr += 4; \\\n\t\tpvaddr += 4;\\\n\t\tword = isBe? r_read_be32 (wordbuf): r_read_le32 (wordbuf);\n\tif (is64) {\n\t\taddr += 4;\n\t\tpvaddr += 4;\n\t}\n\tfor (n = 0; n < mh->ncmds && addr < length; n++) {\n\t\tREADWORD ();\n\t\tut32 lcType = word;\n\t\tconst char *pf_definition = cmd_to_pf_definition (lcType);\n\t\tif (pf_definition) {\n\t\t\tcb_printf (\"pf.%s @ 0x%08\"PFMT64x\"\\n\", pf_definition, pvaddr - 4);\n\t\t}\n\t\tcb_printf (\"0x%08\"PFMT64x\"  cmd %7d 0x%x %s\\n\",\n\t\t\tpvaddr - 4, n, lcType, cmd_to_string (lcType));\n\t\tREADWORD ();\n\t\tif (addr > length) {\n\t\t\tbreak;\n\t\t}\n\t\tint lcSize = word;\n\t\tword &= 0xFFFFFF;\n\t\tcb_printf (\"0x%08\"PFMT64x\"  cmdsize     %d\\n\", pvaddr - 4, word);\n\t\tif (lcSize < 1) {\n\t\t\teprintf (\"Invalid size for a load command\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tswitch (lcType) {\n\t\tcase LC_BUILD_VERSION: {\n\t\t\tcb_printf (\"0x%08\"PFMT64x\"  platform    %s\\n\",\n\t\t\t\tpvaddr, build_version_platform_to_string (r_buf_read_le32_at (buf, addr)));\n\t\t\tcb_printf (\"0x%08\"PFMT64x\"  minos       %d.%d.%d\\n\",\n\t\t\t\tpvaddr + 4, r_buf_read_le16_at (buf, addr + 6), r_buf_read8_at (buf, addr + 5),\n\t\t\t\tr_buf_read8_at (buf, addr + 4));\n\t\t\tcb_printf (\"0x%08\"PFMT64x\"  sdk         %d.%d.%d\\n\",\n\t\t\t\tpvaddr + 8, r_buf_read_le16_at (buf, addr + 10), r_buf_read8_at (buf, addr + 9),\n\t\t\t\tr_buf_read8_at (buf, addr + 8));\n\t\t\tut32 ntools = r_buf_read_le32_at (buf, addr + 12);\n\t\t\tcb_printf (\"0x%08\"PFMT64x\"  ntools      %d\\n\",\n\t\t\t\tpvaddr + 12, ntools);\n\t\t\tut64 off = 16;\n\t\t\twhile (off < (lcSize - 8) && ntools--) {\n\t\t\t\tcb_printf (\"pf.mach0_build_version_tool @ 0x%08\"PFMT64x\"\\n\", pvaddr + off);\n\t\t\t\tcb_printf (\"0x%08\"PFMT64x\"  tool        %s\\n\",\n\t\t\t\t\tpvaddr + off, build_version_tool_to_string (r_buf_read_le32_at (buf, addr + off)));\n\t\t\t\toff += 4;\n\t\t\t\tif (off >= (lcSize - 8)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcb_printf (\"0x%08\"PFMT64x\"  version     %d.%d.%d\\n\",\n\t\t\t\t\tpvaddr + off, r_buf_read_le16_at (buf, addr + off + 2), r_buf_read8_at (buf, addr + off + 1),\n\t\t\t\t\tr_buf_read8_at (buf, addr + off));\n\t\t\t\toff += 4;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase LC_MAIN:\n\t\t\t{\n\t\t\t\tut8 data[64] = {0};\n\t\t\t\tr_buf_read_at (buf, addr, data, sizeof (data));\n#if R_BIN_MACH064\n\t\t\t\tut64 ep = r_read_ble64 (&data, false); //  bin->big_endian);\n\t\t\t\tcb_printf (\"0x%08\"PFMT64x\"  entry0      0x%\" PFMT64x \"\\n\", pvaddr, ep);\n\t\t\t\tut64 ss = r_read_ble64 (&data[8], false); //  bin->big_endian);\n\t\t\t\tcb_printf (\"0x%08\"PFMT64x\"  stacksize   0x%\" PFMT64x \"\\n\", pvaddr +  8, ss);\n#else\n\t\t\t\tut32 ep = r_read_ble32 (&data, false); //  bin->big_endian);\n\t\t\t\tcb_printf (\"0x%08\"PFMT32x\"  entry0      0x%\" PFMT32x \"\\n\", (ut32)pvaddr, ep);\n\t\t\t\tut32 ss = r_read_ble32 (&data[4], false); //  bin->big_endian);\n\t\t\t\tcb_printf (\"0x%08\"PFMT32x\"  stacksize   0x%\" PFMT32x \"\\n\", (ut32)pvaddr +  4, ss);\n#endif\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LC_SYMTAB:\n#if 0\n\t\t\t{\n\t\t\tchar *id = r_buf_get_string (buf, addr + 20);\n\t\t\tcb_printf (\"0x%08\"PFMT64x\"  id         0x%x\\n\", addr + 20, r_str_get (id));\n\t\t\tcb_printf (\"0x%08\"PFMT64x\"  symooff    0x%x\\n\", addr + 20, r_str_get (id));\n\t\t\tcb_printf (\"0x%08\"PFMT64x\"  nsyms      %d\\n\", addr + 20, r_str_get (id));\n\t\t\tcb_printf (\"0x%08\"PFMT64x\"  stroff     0x%x\\n\", addr + 20, r_str_get (id));\n\t\t\tcb_printf (\"0x%08\"PFMT64x\"  strsize    0x%x\\n\", addr + 20, r_str_get (id));\n\t\t\tfree (id);\n\t\t\t}\n#endif\n\t\t\tbreak;\n\t\tcase LC_ID_DYLIB: { // install_name_tool\n\t\t\tut32 str_off = r_buf_read_ble32_at (buf, addr, isBe);\n\t\t\tchar *id = r_buf_get_string (buf, addr + str_off - 8);\n\t\t\tcb_printf (\"0x%08\"PFMT64x\"  current     %d.%d.%d\\n\",\n\t\t\t\tpvaddr + 8, r_buf_read_le16_at (buf, addr + 10), r_buf_read8_at (buf, addr + 9),\n\t\t\t\tr_buf_read8_at (buf, addr + 8));\n\t\t\tcb_printf (\"0x%08\"PFMT64x\"  compat      %d.%d.%d\\n\",\n\t\t\t\tpvaddr + 12, r_buf_read_le16_at (buf, addr + 14), r_buf_read8_at (buf, addr + 13),\n\t\t\t\tr_buf_read8_at (buf, addr + 12));\n\t\t\tcb_printf (\"0x%08\"PFMT64x\"  id          %s\\n\",\n\t\t\t\tpvaddr + str_off - 8, r_str_get (id));\n\t\t\tif (id) {\n\t\t\t\tfree (id);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase LC_UUID:\n\t\t\t{\n\t\t\t\tut8 i, uuid[16];\n\t\t\t\tr_buf_read_at (buf, addr, uuid, sizeof (uuid));\n\t\t\t\tcb_printf (\"0x%08\"PFMT64x\"  uuid        \", pvaddr);\n\t\t\t\tfor (i = 0; i < sizeof (uuid); i++) {\n\t\t\t\t\tcb_printf (\"%02x\", uuid[i]);\n\t\t\t\t}\n\t\t\t\tcb_printf (\"\\n\");\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LC_SEGMENT:\n\t\tcase LC_SEGMENT_64:\n\t\t\t{\n\t\t\t\tut8 name[17] = {0};\n\t\t\t\tr_buf_read_at (buf, addr, name, sizeof (name) - 1);\n\t\t\t\tcb_printf (\"0x%08\"PFMT64x\"  name        %s\\n\", pvaddr, name);\n\t\t\t\tut32 nsects = r_buf_read_le32_at (buf, addr - 8 + (is64 ? 64 : 48));\n\t\t\t\tut64 off = is64 ? 72 : 56;\n\t\t\t\twhile (off < lcSize && nsects--) {\n\t\t\t\t\tif (is64) {\n\t\t\t\t\t\tcb_printf (\"pf.mach0_section64 @ 0x%08\"PFMT64x\"\\n\", pvaddr - 8 + off);\n\t\t\t\t\t\toff += 80;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcb_printf (\"pf.mach0_section @ 0x%08\"PFMT64x\"\\n\", pvaddr - 8 + off);\n\t\t\t\t\t\toff += 68;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LC_LOAD_DYLIB:\n\t\tcase LC_LOAD_WEAK_DYLIB: {\n\t\t\tut32 str_off = r_buf_read_ble32_at (buf, addr, isBe);\n\t\t\tchar *load_dylib = r_buf_get_string (buf, addr + str_off - 8);\n\t\t\tcb_printf (\"0x%08\"PFMT64x\"  current     %d.%d.%d\\n\",\n\t\t\t\tpvaddr + 8, r_buf_read_le16_at (buf, addr + 10), r_buf_read8_at (buf, addr + 9),\n\t\t\t\tr_buf_read8_at (buf, addr + 8));\n\t\t\tcb_printf (\"0x%08\"PFMT64x\"  compat      %d.%d.%d\\n\",\n\t\t\t\tpvaddr + 12, r_buf_read_le16_at (buf, addr + 14), r_buf_read8_at (buf, addr + 13),\n\t\t\t\tr_buf_read8_at (buf, addr + 12));\n\t\t\tcb_printf (\"0x%08\"PFMT64x\"  load_dylib  %s\\n\",\n\t\t\t\tpvaddr + str_off - 8, r_str_get (load_dylib));\n\t\t\tif (load_dylib) {\n\t\t\t\tfree (load_dylib);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase LC_RPATH: {\n\t\t\tchar *rpath = r_buf_get_string (buf, addr + 4);\n\t\t\tcb_printf (\"0x%08\" PFMT64x \"  rpath       %s\\n\",\n\t\t\t\tpvaddr + 4, r_str_get (rpath));\n\t\t\tif (rpath) {\n\t\t\t\tfree (rpath);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase LC_ENCRYPTION_INFO:\n\t\tcase LC_ENCRYPTION_INFO_64: {\n\t\t\tut32 word = r_buf_read_le32_at (buf, addr);\n\t\t\tcb_printf (\"0x%08\"PFMT64x\"  cryptoff   0x%08x\\n\", pvaddr, word);\n\t\t\tword = r_buf_read_le32_at (buf, addr + 4);\n\t\t\tcb_printf (\"0x%08\"PFMT64x\"  cryptsize  %d\\n\", pvaddr + 4, word);\n\t\t\tword = r_buf_read_le32_at (buf, addr + 8);\n\t\t\tcb_printf (\"0x%08\"PFMT64x\"  cryptid    %d\\n\", pvaddr + 8, word);\n\t\t\tbreak;\n\t\t}\n\t\tcase LC_CODE_SIGNATURE: {\n\t\t\tut32 words[2];\n\t\t\tr_buf_read_at (buf, addr, (ut8 *)words, sizeof (words));\n\t\t\tcb_printf (\"0x%08\"PFMT64x\"  dataoff     0x%08x\\n\", pvaddr, words[0]);\n\t\t\tcb_printf (\"0x%08\"PFMT64x\"  datasize    %d\\n\", pvaddr + 4, words[1]);\n\t\t\tcb_printf (\"# wtf mach0.sign %d @ 0x%x\\n\", words[1], words[0]);\n\t\t\tbreak;\n\t\t}\n\t\t}\n\t\taddr += word - 8;\n\t\tpvaddr += word - 8;\n\t}\n\tfree (mh);\n}\n\nRList *MACH0_(mach_fields)(RBinFile *bf) {\n\tRBuffer *buf = bf->buf;\n\tut64 length = r_buf_size (buf);\n\tstruct MACH0_(mach_header) *mh = MACH0_(get_hdr) (buf);\n\tif (!mh) {\n\t\treturn NULL;\n\t}\n\tRList *ret = r_list_new ();\n\tif (!ret) {\n\t\tfree (mh);\n\t\treturn NULL;\n\t}\n\tret->free = free;\n\tut64 addr = pa2va (bf, 0);\n\tut64 paddr = 0;\n\n\tr_list_append (ret, r_bin_field_new (addr, addr, 1, \"header\", \"mach0_header\", \"mach0_header\", true));\n\taddr += 0x20 - 4;\n\tpaddr += 0x20 - 4;\n\tbool is64 = mh->cputype >> 16;\n\tif (is64) {\n\t\taddr += 4;\n\t\tpaddr += 4;\n\t}\n\n\tbool isBe = false;\n\tswitch (mh->cputype) {\n\tcase CPU_TYPE_POWERPC:\n\tcase CPU_TYPE_POWERPC64:\n\t\tisBe = true;\n\t\tbreak;\n\t}\n\n\tint n;\n\tchar load_command_flagname[128];\n\tfor (n = 0; n < mh->ncmds && paddr < length; n++) {\n\t\tut32 lcType = r_buf_read_ble32_at (buf, paddr, isBe);\n\t\tut32 word = r_buf_read_ble32_at (buf, paddr + 4, isBe);\n\t\tif (paddr + 8 > length) {\n\t\t\tbreak;\n\t\t}\n\t\tut32 lcSize = word;\n\t\tword &= 0xFFFFFF;\n\t\tif (lcSize < 1) {\n\t\t\teprintf (\"Invalid size for a load command\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tif (word == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tconst char *pf_definition = cmd_to_pf_definition (lcType);\n\t\tif (pf_definition) {\n\t\t\tsnprintf (load_command_flagname, sizeof (load_command_flagname), \"load_command_%d_%s\", n, cmd_to_string (lcType));\n\t\t\tr_list_append (ret, r_bin_field_new (addr, addr, 1, load_command_flagname, pf_definition, pf_definition, true));\n\t\t}\n\t\tswitch (lcType) {\n\t\tcase LC_BUILD_VERSION: {\n\t\t\tut32 ntools = r_buf_read_le32_at (buf, paddr + 20);\n\t\t\tut64 off = 24;\n\t\t\tint j = 0;\n\t\t\tchar tool_flagname[32];\n\t\t\twhile (off < lcSize && ntools--) {\n\t\t\t\tsnprintf (tool_flagname, sizeof (tool_flagname), \"tool_%d\", j++);\n\t\t\t\tr_list_append (ret, r_bin_field_new (addr + off, addr + off, 1, tool_flagname, \"mach0_build_version_tool\", \"mach0_build_version_tool\", true));\n\t\t\t\toff += 8;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase LC_SEGMENT:\n\t\tcase LC_SEGMENT_64: {\n\t\t\tut32 nsects = r_buf_read_le32_at (buf, addr + (is64 ? 64 : 48));\n\t\t\tut64 off = is64 ? 72 : 56;\n\t\t\tsize_t i, j = 0;\n\t\t\tchar section_flagname[128];\n\t\t\tfor (i = 0; i < nsects && (addr + off) < length && off < lcSize; i++) {\n\t\t\t\tconst char *sname = is64? \"mach0_section64\": \"mach0_section\";\n\t\t\t\tsnprintf (section_flagname, sizeof (section_flagname), \"section_%u\", (ut32)j++);\n\t\t\t\tRBinField *f = r_bin_field_new (addr + off, addr + off, 1, section_flagname, sname, sname, true);\n\t\t\t\tr_list_append (ret, f);\n\t\t\t\toff += is64? 80: 68;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t// TODO\n\t\t\tbreak;\n\t\t}\n\t\t}\n\t\taddr += word;\n\t\tpaddr += word;\n\t}\n\tfree (mh);\n\treturn ret;\n}\n\nstruct MACH0_(mach_header) *MACH0_(get_hdr)(RBuffer *buf) {\n\tut8 magicbytes[sizeof (ut32)] = {0};\n\tut8 machohdrbytes[sizeof (struct MACH0_(mach_header))] = {0};\n\tint len;\n\tstruct MACH0_(mach_header) *macho_hdr = R_NEW0 (struct MACH0_(mach_header));\n\tbool big_endian = false;\n\tif (!macho_hdr) {\n\t\treturn NULL;\n\t}\n\tif (r_buf_read_at (buf, 0, magicbytes, 4) < 1) {\n\t\tfree (macho_hdr);\n\t\treturn false;\n\t}\n\n\tif (r_read_le32 (magicbytes) == 0xfeedface) {\n\t\tbig_endian = false;\n\t} else if (r_read_be32 (magicbytes) == 0xfeedface) {\n\t\tbig_endian = true;\n\t} else if (r_read_le32 (magicbytes) == FAT_MAGIC) {\n\t\tbig_endian = false;\n\t} else if (r_read_be32 (magicbytes) == FAT_MAGIC) {\n\t\tbig_endian = true;\n\t} else if (r_read_le32 (magicbytes) == 0xfeedfacf) {\n\t\tbig_endian = false;\n\t} else if (r_read_be32 (magicbytes) == 0xfeedfacf) {\n\t\tbig_endian = true;\n\t} else {\n\t\t/* also extract non-mach0s */\n#if 0\n\t\tfree (macho_hdr);\n\t\treturn NULL;\n#endif\n\t}\n\tlen = r_buf_read_at (buf, 0, machohdrbytes, sizeof (machohdrbytes));\n\tif (len != sizeof (struct MACH0_(mach_header))) {\n\t\tfree (macho_hdr);\n\t\treturn NULL;\n\t}\n\tmacho_hdr->magic = r_read_ble (&machohdrbytes[0], big_endian, 32);\n\tmacho_hdr->cputype = r_read_ble (&machohdrbytes[4], big_endian, 32);\n\tmacho_hdr->cpusubtype = r_read_ble (&machohdrbytes[8], big_endian, 32);\n\tmacho_hdr->filetype = r_read_ble (&machohdrbytes[12], big_endian, 32);\n\tmacho_hdr->ncmds = r_read_ble (&machohdrbytes[16], big_endian, 32);\n\tmacho_hdr->sizeofcmds = r_read_ble (&machohdrbytes[20], big_endian, 32);\n\tmacho_hdr->flags = r_read_ble (&machohdrbytes[24], big_endian, 32);\n#if R_BIN_MACH064\n\tmacho_hdr->reserved = r_read_ble (&machohdrbytes[28], big_endian, 32);\n#endif\n\treturn macho_hdr;\n}\n\nvoid MACH0_(iterate_chained_fixups)(struct MACH0_(obj_t) *bin, ut64 limit_start, ut64 limit_end, ut32 event_mask, RFixupCallback callback, void * context) {\n\tint i = 0;\n\tfor (; i < bin->nsegs && i < bin->segs_count; i++) {\n\t\tif (!bin->chained_starts[i]) {\n\t\t\tcontinue;\n\t\t}\n\t\tint page_size = bin->chained_starts[i]->page_size;\n\t\tif (page_size < 1) {\n\t\t\tpage_size = 4096;\n\t\t}\n\t\tut64 start = bin->segs[i].fileoff;\n\t\tut64 end = start + bin->segs[i].filesize;\n\t\tif (end >= limit_start && start <= limit_end) {\n\t\t\tut64 page_idx = (R_MAX (start, limit_start) - start) / page_size;\n\t\t\tut64 page_end_idx = (R_MIN (limit_end, end) - start) / page_size;\n\t\t\tfor (; page_idx <= page_end_idx; page_idx++) {\n\t\t\t\tif (page_idx >= bin->chained_starts[i]->page_count) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (!bin->chained_starts[i]->page_start) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tut16 page_start = bin->chained_starts[i]->page_start[page_idx];\n\t\t\t\tif (page_start == DYLD_CHAINED_PTR_START_NONE) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tut64 cursor = start + page_idx * page_size + page_start;\n\t\t\t\twhile (cursor < limit_end && cursor < end) {\n\t\t\t\t\tut8 tmp[8];\n\t\t\t\t\tbool previous_rebasing = bin->rebasing_buffer;\n\t\t\t\t\tbin->rebasing_buffer = true;\n\t\t\t\t\tif (r_buf_read_at (bin->b, cursor, tmp, 8) != 8) {\n\t\t\t\t\t\tbin->rebasing_buffer = previous_rebasing;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tbin->rebasing_buffer = previous_rebasing;\n\t\t\t\t\tut64 raw_ptr = r_read_le64 (tmp);\n\t\t\t\t\tut64 ptr_value = raw_ptr;\n\t\t\t\t\tut64 delta, stride, addend;\n\t\t\t\t\tut16 pointer_format = bin->chained_starts[i]->pointer_format;\n\t\t\t\t\tRFixupEvent event = R_FIXUP_EVENT_NONE;\n\t\t\t\t\tut8 key = 0, addr_div = 0;\n\t\t\t\t\tut16 diversity = 0;\n\t\t\t\t\tut32 ordinal = UT32_MAX;\n\t\t\t\t\tswitch (pointer_format) {\n\t\t\t\t\tcase DYLD_CHAINED_PTR_ARM64E:\n\t\t\t\t\t\t{\n\t\t\t\t\t\tstride = 8;\n\t\t\t\t\t\tbool is_auth = IS_PTR_AUTH (raw_ptr);\n\t\t\t\t\t\tbool is_bind = IS_PTR_BIND (raw_ptr);\n\t\t\t\t\t\tif (is_auth && is_bind) {\n\t\t\t\t\t\t\tstruct dyld_chained_ptr_arm64e_auth_bind *p =\n\t\t\t\t\t\t\t\t\t(struct dyld_chained_ptr_arm64e_auth_bind *) &raw_ptr;\n\t\t\t\t\t\t\tevent = R_FIXUP_EVENT_BIND_AUTH;\n\t\t\t\t\t\t\tdelta = p->next;\n\t\t\t\t\t\t\tordinal = p->ordinal;\n\t\t\t\t\t\t\tkey = p->key;\n\t\t\t\t\t\t\taddr_div = p->addrDiv;\n\t\t\t\t\t\t\tdiversity = p->diversity;\n\t\t\t\t\t\t} else if (!is_auth && is_bind) {\n\t\t\t\t\t\t\tstruct dyld_chained_ptr_arm64e_bind *p =\n\t\t\t\t\t\t\t\t\t(struct dyld_chained_ptr_arm64e_bind *) &raw_ptr;\n\t\t\t\t\t\t\tevent = R_FIXUP_EVENT_BIND;\n\t\t\t\t\t\t\tdelta = p->next;\n\t\t\t\t\t\t\tordinal = p->ordinal;\n\t\t\t\t\t\t\taddend = p->addend;\n\t\t\t\t\t\t} else if (is_auth && !is_bind) {\n\t\t\t\t\t\t\tstruct dyld_chained_ptr_arm64e_auth_rebase *p =\n\t\t\t\t\t\t\t\t\t(struct dyld_chained_ptr_arm64e_auth_rebase *) &raw_ptr;\n\t\t\t\t\t\t\tevent = R_FIXUP_EVENT_REBASE_AUTH;\n\t\t\t\t\t\t\tdelta = p->next;\n\t\t\t\t\t\t\tptr_value = p->target + bin->baddr;\n\t\t\t\t\t\t\tkey = p->key;\n\t\t\t\t\t\t\taddr_div = p->addrDiv;\n\t\t\t\t\t\t\tdiversity = p->diversity;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tstruct dyld_chained_ptr_arm64e_rebase *p =\n\t\t\t\t\t\t\t\t\t(struct dyld_chained_ptr_arm64e_rebase *) &raw_ptr;\n\t\t\t\t\t\t\tevent = R_FIXUP_EVENT_REBASE;\n\t\t\t\t\t\t\tdelta = p->next;\n\t\t\t\t\t\t\tptr_value = ((ut64)p->high8 << 56) | p->target;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase DYLD_CHAINED_PTR_ARM64E_USERLAND24:\n\t\t\t\t\t\t{\n\t\t\t\t\t\tstride = 8;\n\t\t\t\t\t\tstruct dyld_chained_ptr_arm64e_bind24 *bind =\n\t\t\t\t\t\t\t\t(struct dyld_chained_ptr_arm64e_bind24 *) &raw_ptr;\n\t\t\t\t\t\tif (bind->bind) {\n\t\t\t\t\t\t\tdelta = bind->next;\n\t\t\t\t\t\t\tif (bind->auth) {\n\t\t\t\t\t\t\t\tstruct dyld_chained_ptr_arm64e_auth_bind24 *p =\n\t\t\t\t\t\t\t\t\t\t(struct dyld_chained_ptr_arm64e_auth_bind24 *) &raw_ptr;\n\t\t\t\t\t\t\t\tevent = R_FIXUP_EVENT_BIND_AUTH;\n\t\t\t\t\t\t\t\tordinal = p->ordinal;\n\t\t\t\t\t\t\t\tkey = p->key;\n\t\t\t\t\t\t\t\taddr_div = p->addrDiv;\n\t\t\t\t\t\t\t\tdiversity = p->diversity;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tevent = R_FIXUP_EVENT_BIND;\n\t\t\t\t\t\t\t\tordinal = bind->ordinal;\n\t\t\t\t\t\t\t\taddend = bind->addend;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (bind->auth) {\n\t\t\t\t\t\t\t\tstruct dyld_chained_ptr_arm64e_auth_rebase *p =\n\t\t\t\t\t\t\t\t\t\t(struct dyld_chained_ptr_arm64e_auth_rebase *) &raw_ptr;\n\t\t\t\t\t\t\t\tevent = R_FIXUP_EVENT_REBASE_AUTH;\n\t\t\t\t\t\t\t\tdelta = p->next;\n\t\t\t\t\t\t\t\tptr_value = p->target + bin->baddr;\n\t\t\t\t\t\t\t\tkey = p->key;\n\t\t\t\t\t\t\t\taddr_div = p->addrDiv;\n\t\t\t\t\t\t\t\tdiversity = p->diversity;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tstruct dyld_chained_ptr_arm64e_rebase *p =\n\t\t\t\t\t\t\t\t\t(struct dyld_chained_ptr_arm64e_rebase *) &raw_ptr;\n\t\t\t\t\t\t\t\tevent = R_FIXUP_EVENT_REBASE;\n\t\t\t\t\t\t\t\tdelta = p->next;\n\t\t\t\t\t\t\t\tptr_value = bin->baddr + (((ut64)p->high8 << 56) | p->target);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase DYLD_CHAINED_PTR_64:\n\t\t\t\t\tcase DYLD_CHAINED_PTR_64_OFFSET:\n\t\t\t\t\t\t{\n\t\t\t\t\t\tstride = 4;\n\t\t\t\t\t\tstruct dyld_chained_ptr_64_bind *bind =\n\t\t\t\t\t\t\t\t(struct dyld_chained_ptr_64_bind *) &raw_ptr;\n\t\t\t\t\t\tif (bind->bind) {\n\t\t\t\t\t\t\tevent = R_FIXUP_EVENT_BIND;\n\t\t\t\t\t\t\tdelta = bind->next;\n\t\t\t\t\t\t\tordinal = bind->ordinal;\n\t\t\t\t\t\t\taddend = bind->addend;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tstruct dyld_chained_ptr_64_rebase *p =\n\t\t\t\t\t\t\t\t(struct dyld_chained_ptr_64_rebase *) &raw_ptr;\n\t\t\t\t\t\t\tevent = R_FIXUP_EVENT_REBASE;\n\t\t\t\t\t\t\tdelta = p->next;\n\t\t\t\t\t\t\tptr_value = ((ut64)p->high8 << 56) | p->target;\n\t\t\t\t\t\t\tif (pointer_format == DYLD_CHAINED_PTR_64_OFFSET) {\n\t\t\t\t\t\t\t\tptr_value += bin->baddr;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\teprintf (\"Unsupported chained pointer format %d\\n\", pointer_format);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tif (cursor >= limit_start && cursor <= limit_end - 8 && (event & event_mask) != 0) {\n\t\t\t\t\t\tbool carry_on;\n\t\t\t\t\t\tswitch (event) {\n\t\t\t\t\t\tcase R_FIXUP_EVENT_BIND: {\n\t\t\t\t\t\t\tRFixupBindEventDetails event_details;\n\n\t\t\t\t\t\t\tevent_details.type = event;\n\t\t\t\t\t\t\tevent_details.bin = bin;\n\t\t\t\t\t\t\tevent_details.offset = cursor;\n\t\t\t\t\t\t\tevent_details.raw_ptr = raw_ptr;\n\t\t\t\t\t\t\tevent_details.ordinal = ordinal;\n\t\t\t\t\t\t\tevent_details.addend = addend;\n\n\t\t\t\t\t\t\tcarry_on = callback (context, (RFixupEventDetails *) &event_details);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase R_FIXUP_EVENT_BIND_AUTH: {\n\t\t\t\t\t\t\tRFixupBindAuthEventDetails event_details;\n\n\t\t\t\t\t\t\tevent_details.type = event;\n\t\t\t\t\t\t\tevent_details.bin = bin;\n\t\t\t\t\t\t\tevent_details.offset = cursor;\n\t\t\t\t\t\t\tevent_details.raw_ptr = raw_ptr;\n\t\t\t\t\t\t\tevent_details.ordinal = ordinal;\n\t\t\t\t\t\t\tevent_details.key = key;\n\t\t\t\t\t\t\tevent_details.addr_div = addr_div;\n\t\t\t\t\t\t\tevent_details.diversity = diversity;\n\n\t\t\t\t\t\t\tcarry_on = callback (context, (RFixupEventDetails *) &event_details);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase R_FIXUP_EVENT_REBASE: {\n\t\t\t\t\t\t\tRFixupRebaseEventDetails event_details;\n\n\t\t\t\t\t\t\tevent_details.type = event;\n\t\t\t\t\t\t\tevent_details.bin = bin;\n\t\t\t\t\t\t\tevent_details.offset = cursor;\n\t\t\t\t\t\t\tevent_details.raw_ptr = raw_ptr;\n\t\t\t\t\t\t\tevent_details.ptr_value = ptr_value;\n\n\t\t\t\t\t\t\tcarry_on = callback (context, (RFixupEventDetails *) &event_details);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase R_FIXUP_EVENT_REBASE_AUTH: {\n\t\t\t\t\t\t\tRFixupRebaseAuthEventDetails event_details;\n\n\t\t\t\t\t\t\tevent_details.type = event;\n\t\t\t\t\t\t\tevent_details.bin = bin;\n\t\t\t\t\t\t\tevent_details.offset = cursor;\n\t\t\t\t\t\t\tevent_details.raw_ptr = raw_ptr;\n\t\t\t\t\t\t\tevent_details.ptr_value = ptr_value;\n\t\t\t\t\t\t\tevent_details.key = key;\n\t\t\t\t\t\t\tevent_details.addr_div = addr_div;\n\t\t\t\t\t\t\tevent_details.diversity = diversity;\n\n\t\t\t\t\t\t\tcarry_on = callback (context, (RFixupEventDetails *) &event_details);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\teprintf (\"Unexpected event while iterating chained fixups\\n\");\n\t\t\t\t\t\t\tcarry_on = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!carry_on) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcursor += delta * stride;\n\t\t\t\t\tif (!delta) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n"], "filenames": ["libr/bin/format/mach0/mach0.c"], "buggy_code_start_loc": [4582], "buggy_code_end_loc": [4582], "fixing_code_start_loc": [4583], "fixing_code_end_loc": [4586], "type": "CWE-787", "message": "Null pointer dereference in libr/bin/format/mach0/mach0.c in radareorg/radare2 in GitHub repository radareorg/radare2 prior to 5.7.0. It is likely to be exploitable. For more general description of heap buffer overflow, see [CWE](https://cwe.mitre.org/data/definitions/476.html).", "other": {"cve": {"id": "CVE-2022-1649", "sourceIdentifier": "security@huntr.dev", "published": "2022-05-10T17:15:07.993", "lastModified": "2022-05-16T16:27:22.627", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Null pointer dereference in libr/bin/format/mach0/mach0.c in radareorg/radare2 in GitHub repository radareorg/radare2 prior to 5.7.0. It is likely to be exploitable. For more general description of heap buffer overflow, see [CWE](https://cwe.mitre.org/data/definitions/476.html)."}, {"lang": "es", "value": "Una Desreferencia de puntero Null en el archivo libr/bin/format/mach0/mach0.c en radareorg/radare2 en el repositorio de GitHub radareorg/radare2 versiones anteriores a 5.7.0. Es probable que pueda ser explotada. Para una descripci\u00f3n m\u00e1s general del desbordamiento del b\u00fafer de la pila, vea [CWE](https://cwe.mitre.org/data/definitions/476.html)"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:L/I:L/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "HIGH", "baseScore": 7.6, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 4.7}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}, {"source": "security@huntr.dev", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-476"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:radare:radare2:*:*:*:*:*:*:*:*", "versionEndExcluding": "5.7.0", "matchCriteriaId": "A79BEA4D-5D5F-4593-B2CA-0CA4C22C1C0A"}]}]}], "references": [{"url": "https://github.com/radareorg/radare2/commit/a5aafb99c3965259c84ddcf45a91144bf7eb4cf1", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/c07e4918-cf86-4d2e-8969-5fb63575b449", "source": "security@huntr.dev", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/radareorg/radare2/commit/a5aafb99c3965259c84ddcf45a91144bf7eb4cf1"}}