{"buggy_code": ["package org.bouncycastle.pqc.crypto.gmss;\n\nimport java.security.SecureRandom;\nimport java.util.Vector;\n\nimport org.bouncycastle.crypto.AsymmetricCipherKeyPair;\nimport org.bouncycastle.crypto.AsymmetricCipherKeyPairGenerator;\nimport org.bouncycastle.crypto.Digest;\nimport org.bouncycastle.crypto.KeyGenerationParameters;\nimport org.bouncycastle.pqc.crypto.gmss.util.GMSSRandom;\nimport org.bouncycastle.pqc.crypto.gmss.util.WinternitzOTSVerify;\nimport org.bouncycastle.pqc.crypto.gmss.util.WinternitzOTSignature;\n\n\n/**\n * This class implements key pair generation of the generalized Merkle signature\n * scheme (GMSS).\n *\n * @see GMSSSigner\n */\npublic class GMSSKeyPairGenerator\n    implements AsymmetricCipherKeyPairGenerator\n{\n    /**\n     * The source of randomness for OTS private key generation\n     */\n    private GMSSRandom gmssRandom;\n\n    /**\n     * The hash function used for the construction of the authentication trees\n     */\n    private Digest messDigestTree;\n\n    /**\n     * An array of the seeds for the PRGN (for main tree, and all current\n     * subtrees)\n     */\n    private byte[][] currentSeeds;\n\n    /**\n     * An array of seeds for the PRGN (for all subtrees after next)\n     */\n    private byte[][] nextNextSeeds;\n\n    /**\n     * An array of the RootSignatures\n     */\n    private byte[][] currentRootSigs;\n\n    /**\n     * Class of hash function to use\n     */\n    private GMSSDigestProvider digestProvider;\n\n    /**\n     * The length of the seed for the PRNG\n     */\n    private int mdLength;\n\n    /**\n     * the number of Layers\n     */\n    private int numLayer;\n\n\n    /**\n     * Flag indicating if the class already has been initialized\n     */\n    private boolean initialized = false;\n\n    /**\n     * Instance of GMSSParameterset\n     */\n    private GMSSParameters gmssPS;\n\n    /**\n     * An array of the heights of the authentication trees of each layer\n     */\n    private int[] heightOfTrees;\n\n    /**\n     * An array of the Winternitz parameter 'w' of each layer\n     */\n    private int[] otsIndex;\n\n    /**\n     * The parameter K needed for the authentication path computation\n     */\n    private int[] K;\n\n    private GMSSKeyGenerationParameters gmssParams;\n\n    /**\n     * The GMSS OID.\n     */\n    public static final String OID = \"1.3.6.1.4.1.8301.3.1.3.3\";\n\n    /**\n     * The standard constructor tries to generate the GMSS algorithm identifier\n     * with the corresponding OID.\n     *\n     * @param digestProvider     provider for digest implementations.\n     */\n    public GMSSKeyPairGenerator(GMSSDigestProvider digestProvider)\n    {\n        this.digestProvider = digestProvider;\n        messDigestTree = digestProvider.get();\n\n        // set mdLength\n        this.mdLength = messDigestTree.getDigestSize();\n        // construct randomizer\n        this.gmssRandom = new GMSSRandom(messDigestTree);\n\n    }\n\n    /**\n     * Generates the GMSS key pair. The public key is an instance of\n     * JDKGMSSPublicKey, the private key is an instance of JDKGMSSPrivateKey.\n     *\n     * @return Key pair containing a JDKGMSSPublicKey and a JDKGMSSPrivateKey\n     */\n    private AsymmetricCipherKeyPair genKeyPair()\n    {\n        if (!initialized)\n        {\n            initializeDefault();\n        }\n\n        // initialize authenticationPaths and treehash instances\n        byte[][][] currentAuthPaths = new byte[numLayer][][];\n        byte[][][] nextAuthPaths = new byte[numLayer - 1][][];\n        Treehash[][] currentTreehash = new Treehash[numLayer][];\n        Treehash[][] nextTreehash = new Treehash[numLayer - 1][];\n\n        Vector[] currentStack = new Vector[numLayer];\n        Vector[] nextStack = new Vector[numLayer - 1];\n\n        Vector[][] currentRetain = new Vector[numLayer][];\n        Vector[][] nextRetain = new Vector[numLayer - 1][];\n\n        for (int i = 0; i < numLayer; i++)\n        {\n            currentAuthPaths[i] = new byte[heightOfTrees[i]][mdLength];\n            currentTreehash[i] = new Treehash[heightOfTrees[i] - K[i]];\n\n            if (i > 0)\n            {\n                nextAuthPaths[i - 1] = new byte[heightOfTrees[i]][mdLength];\n                nextTreehash[i - 1] = new Treehash[heightOfTrees[i] - K[i]];\n            }\n\n            currentStack[i] = new Vector();\n            if (i > 0)\n            {\n                nextStack[i - 1] = new Vector();\n            }\n        }\n\n        // initialize roots\n        byte[][] currentRoots = new byte[numLayer][mdLength];\n        byte[][] nextRoots = new byte[numLayer - 1][mdLength];\n        // initialize seeds\n        byte[][] seeds = new byte[numLayer][mdLength];\n        // initialize seeds[] by copying starting-seeds of first trees of each\n        // layer\n        for (int i = 0; i < numLayer; i++)\n        {\n            System.arraycopy(currentSeeds[i], 0, seeds[i], 0, mdLength);\n        }\n\n        // initialize rootSigs\n        currentRootSigs = new byte[numLayer - 1][mdLength];\n\n        // -------------------------\n        // -------------------------\n        // --- calculation of current authpaths and current rootsigs (AUTHPATHS,\n        // SIG)------\n        // from bottom up to the root\n        for (int h = numLayer - 1; h >= 0; h--)\n        {\n            GMSSRootCalc tree = new GMSSRootCalc(this.heightOfTrees[h], this.K[h], digestProvider);\n            try\n            {\n                // on lowest layer no lower root is available, so just call\n                // the method with null as first parameter\n                if (h == numLayer - 1)\n                {\n                    tree = this.generateCurrentAuthpathAndRoot(null, currentStack[h], seeds[h], h);\n                }\n                else\n                // otherwise call the method with the former computed root\n                // value\n                {\n                    tree = this.generateCurrentAuthpathAndRoot(currentRoots[h + 1], currentStack[h], seeds[h], h);\n                }\n\n            }\n            catch (Exception e1)\n            {\n                e1.printStackTrace();\n            }\n\n            // set initial values needed for the private key construction\n            for (int i = 0; i < heightOfTrees[h]; i++)\n            {\n                System.arraycopy(tree.getAuthPath()[i], 0, currentAuthPaths[h][i], 0, mdLength);\n            }\n            currentRetain[h] = tree.getRetain();\n            currentTreehash[h] = tree.getTreehash();\n            System.arraycopy(tree.getRoot(), 0, currentRoots[h], 0, mdLength);\n        }\n\n        // --- calculation of next authpaths and next roots (AUTHPATHS+, ROOTS+)\n        // ------\n        for (int h = numLayer - 2; h >= 0; h--)\n        {\n            GMSSRootCalc tree = this.generateNextAuthpathAndRoot(nextStack[h], seeds[h + 1], h + 1);\n\n            // set initial values needed for the private key construction\n            for (int i = 0; i < heightOfTrees[h + 1]; i++)\n            {\n                System.arraycopy(tree.getAuthPath()[i], 0, nextAuthPaths[h][i], 0, mdLength);\n            }\n            nextRetain[h] = tree.getRetain();\n            nextTreehash[h] = tree.getTreehash();\n            System.arraycopy(tree.getRoot(), 0, nextRoots[h], 0, mdLength);\n\n            // create seed for the Merkle tree after next (nextNextSeeds)\n            // SEEDs++\n            System.arraycopy(seeds[h + 1], 0, this.nextNextSeeds[h], 0, mdLength);\n        }\n        // ------------\n\n        // generate JDKGMSSPublicKey\n        GMSSPublicKeyParameters publicKey = new GMSSPublicKeyParameters(currentRoots[0], gmssPS);\n\n        // generate the JDKGMSSPrivateKey\n        GMSSPrivateKeyParameters privateKey = new GMSSPrivateKeyParameters(currentSeeds, nextNextSeeds, currentAuthPaths,\n            nextAuthPaths, currentTreehash, nextTreehash, currentStack, nextStack, currentRetain, nextRetain, nextRoots, currentRootSigs, gmssPS, digestProvider);\n\n        // return the KeyPair\n        return (new AsymmetricCipherKeyPair(publicKey, privateKey));\n    }\n\n    /**\n     * calculates the authpath for tree in layer h which starts with seed[h]\n     * additionally computes the rootSignature of underlaying root\n     *\n     * @param currentStack stack used for the treehash instance created by this method\n     * @param lowerRoot    stores the root of the lower tree\n     * @param seed        starting seeds\n     * @param h            actual layer\n     */\n    private GMSSRootCalc generateCurrentAuthpathAndRoot(byte[] lowerRoot, Vector currentStack, byte[] seed, int h)\n    {\n        byte[] help = new byte[mdLength];\n\n        byte[] OTSseed = new byte[mdLength];\n        OTSseed = gmssRandom.nextSeed(seed);\n\n        WinternitzOTSignature ots;\n\n        // data structure that constructs the whole tree and stores\n        // the initial values for treehash, Auth and retain\n        GMSSRootCalc treeToConstruct = new GMSSRootCalc(this.heightOfTrees[h], this.K[h], digestProvider);\n\n        treeToConstruct.initialize(currentStack);\n\n        // generate the first leaf\n        if (h == numLayer - 1)\n        {\n            ots = new WinternitzOTSignature(OTSseed, digestProvider.get(), otsIndex[h]);\n            help = ots.getPublicKey();\n        }\n        else\n        {\n            // for all layers except the lowest, generate the signature of the\n            // underlying root\n            // and reuse this signature to compute the first leaf of acual layer\n            // more efficiently (by verifiing the signature)\n            ots = new WinternitzOTSignature(OTSseed, digestProvider.get(), otsIndex[h]);\n            currentRootSigs[h] = ots.getSignature(lowerRoot);\n            WinternitzOTSVerify otsver = new WinternitzOTSVerify(digestProvider.get(), otsIndex[h]);\n            help = otsver.Verify(lowerRoot, currentRootSigs[h]);\n        }\n        // update the tree with the first leaf\n        treeToConstruct.update(help);\n\n        int seedForTreehashIndex = 3;\n        int count = 0;\n\n        // update the tree 2^(H) - 1 times, from the second to the last leaf\n        for (int i = 1; i < (1 << this.heightOfTrees[h]); i++)\n        {\n            // initialize the seeds for the leaf generation with index 3 * 2^h\n            if (i == seedForTreehashIndex && count < this.heightOfTrees[h] - this.K[h])\n            {\n                treeToConstruct.initializeTreehashSeed(seed, count);\n                seedForTreehashIndex *= 2;\n                count++;\n            }\n\n            OTSseed = gmssRandom.nextSeed(seed);\n            ots = new WinternitzOTSignature(OTSseed, digestProvider.get(), otsIndex[h]);\n            treeToConstruct.update(ots.getPublicKey());\n        }\n\n        if (treeToConstruct.wasFinished())\n        {\n            return treeToConstruct;\n        }\n        System.err.println(\"Baum noch nicht fertig konstruiert!!!\");\n        return null;\n    }\n\n    /**\n     * calculates the authpath and root for tree in layer h which starts with\n     * seed[h]\n     *\n     * @param nextStack stack used for the treehash instance created by this method\n     * @param seed      starting seeds\n     * @param h         actual layer\n     */\n    private GMSSRootCalc generateNextAuthpathAndRoot(Vector nextStack, byte[] seed, int h)\n    {\n        byte[] OTSseed = new byte[numLayer];\n        WinternitzOTSignature ots;\n\n        // data structure that constructs the whole tree and stores\n        // the initial values for treehash, Auth and retain\n        GMSSRootCalc treeToConstruct = new GMSSRootCalc(this.heightOfTrees[h], this.K[h], this.digestProvider);\n        treeToConstruct.initialize(nextStack);\n\n        int seedForTreehashIndex = 3;\n        int count = 0;\n\n        // update the tree 2^(H) times, from the first to the last leaf\n        for (int i = 0; i < (1 << this.heightOfTrees[h]); i++)\n        {\n            // initialize the seeds for the leaf generation with index 3 * 2^h\n            if (i == seedForTreehashIndex && count < this.heightOfTrees[h] - this.K[h])\n            {\n                treeToConstruct.initializeTreehashSeed(seed, count);\n                seedForTreehashIndex *= 2;\n                count++;\n            }\n\n            OTSseed = gmssRandom.nextSeed(seed);\n            ots = new WinternitzOTSignature(OTSseed, digestProvider.get(), otsIndex[h]);\n            treeToConstruct.update(ots.getPublicKey());\n        }\n\n        if (treeToConstruct.wasFinished())\n        {\n            return treeToConstruct;\n        }\n        System.err.println(\"N\ufffdchster Baum noch nicht fertig konstruiert!!!\");\n        return null;\n    }\n\n    /**\n     * This method initializes the GMSS KeyPairGenerator using an integer value\n     * <code>keySize</code> as input. It provides a simple use of the GMSS for\n     * testing demands.\n     * <p>\n     * A given <code>keysize</code> of less than 10 creates an amount 2^10\n     * signatures. A keySize between 10 and 20 creates 2^20 signatures. Given an\n     * integer greater than 20 the key pair generator creates 2^40 signatures.\n     *\n     * @param keySize      Assigns the parameters used for the GMSS signatures. There are\n     *                     3 choices:<br>\n     *                     1. keysize &lt;= 10: creates 2^10 signatures using the\n     *                     parameterset<br>\n     *                     P = (2, (5, 5), (3, 3), (3, 3))<br>\n     *                     2. keysize &gt; 10 and &lt;= 20: creates 2^20 signatures using the\n     *                     parameterset<br>\n     *                     P = (2, (10, 10), (5, 4), (2, 2))<br>\n     *                     3. keysize &gt; 20: creates 2^40 signatures using the\n     *                     parameterset<br>\n     *                     P = (2, (10, 10, 10, 10), (9, 9, 9, 3), (2, 2, 2, 2))\n     * @param secureRandom not used by GMSS, the SHA1PRNG of the SUN Provider is always\n     *                     used\n     */\n    public void initialize(int keySize, SecureRandom secureRandom)\n    {\n\n        KeyGenerationParameters kgp;\n        if (keySize <= 10)\n        { // create 2^10 keys\n            int[] defh = {10};\n            int[] defw = {3};\n            int[] defk = {2};\n            // XXX sec random neede?\n            kgp = new GMSSKeyGenerationParameters(secureRandom, new GMSSParameters(defh.length, defh, defw, defk));\n        }\n        else if (keySize <= 20)\n        { // create 2^20 keys\n            int[] defh = {10, 10};\n            int[] defw = {5, 4};\n            int[] defk = {2, 2};\n            kgp = new GMSSKeyGenerationParameters(secureRandom, new GMSSParameters(defh.length, defh, defw, defk));\n        }\n        else\n        { // create 2^40 keys, keygen lasts around 80 seconds\n            int[] defh = {10, 10, 10, 10};\n            int[] defw = {9, 9, 9, 3};\n            int[] defk = {2, 2, 2, 2};\n            kgp = new GMSSKeyGenerationParameters(secureRandom, new GMSSParameters(defh.length, defh, defw, defk));\n        }\n\n        // call the initializer with the chosen parameters\n        this.initialize(kgp);\n\n    }\n\n\n    /**\n     * Initalizes the key pair generator using a parameter set as input\n     */\n    public void initialize(KeyGenerationParameters param)\n    {\n\n        this.gmssParams = (GMSSKeyGenerationParameters)param;\n\n        // generate GMSSParameterset\n        this.gmssPS = new GMSSParameters(gmssParams.getParameters().getNumOfLayers(), gmssParams.getParameters().getHeightOfTrees(),\n            gmssParams.getParameters().getWinternitzParameter(), gmssParams.getParameters().getK());\n\n        this.numLayer = gmssPS.getNumOfLayers();\n        this.heightOfTrees = gmssPS.getHeightOfTrees();\n        this.otsIndex = gmssPS.getWinternitzParameter();\n        this.K = gmssPS.getK();\n\n        // seeds\n        this.currentSeeds = new byte[numLayer][mdLength];\n        this.nextNextSeeds = new byte[numLayer - 1][mdLength];\n\n        // construct SecureRandom for initial seed generation\n        SecureRandom secRan = new SecureRandom();\n\n        // generation of initial seeds\n        for (int i = 0; i < numLayer; i++)\n        {\n            secRan.nextBytes(currentSeeds[i]);\n            gmssRandom.nextSeed(currentSeeds[i]);\n        }\n\n        this.initialized = true;\n    }\n\n    /**\n     * This method is called by generateKeyPair() in case that no other\n     * initialization method has been called by the user\n     */\n    private void initializeDefault()\n    {\n        int[] defh = {10, 10, 10, 10};\n        int[] defw = {3, 3, 3, 3};\n        int[] defk = {2, 2, 2, 2};\n\n        KeyGenerationParameters kgp = new GMSSKeyGenerationParameters(new SecureRandom(), new GMSSParameters(defh.length, defh, defw, defk));\n        this.initialize(kgp);\n\n    }\n\n    public void init(KeyGenerationParameters param)\n    {\n        this.initialize(param);\n\n    }\n\n    public AsymmetricCipherKeyPair generateKeyPair()\n    {\n        return genKeyPair();\n    }\n}\n", "package org.bouncycastle.pqc.crypto.rainbow;\n\nimport org.bouncycastle.crypto.CipherParameters;\n\npublic class RainbowParameters\n    implements CipherParameters\n{\n\n    /**\n     * DEFAULT PARAMS\n     */\n    /*\n      * Vi = vinegars per layer whereas n is vu (vu = 33 = n) such that\n      *\n      * v1 = 6; o1 = 12-6 = 6\n      *\n      * v2 = 12; o2 = 17-12 = 5\n      *\n      * v3 = 17; o3 = 22-17 = 5\n      *\n      * v4 = 22; o4 = 33-22 = 11\n      *\n      * v5 = 33; (o5 = 0)\n      */\n    private final int[] DEFAULT_VI = {6, 12, 17, 22, 33};\n\n    private int[] vi;// set of vinegar vars per layer.\n\n    /**\n     * Default Constructor The elements of the array containing the number of\n     * Vinegar variables in each layer are set to the default values here.\n     */\n    public RainbowParameters()\n    {\n        this.vi = this.DEFAULT_VI;\n    }\n\n    /**\n     * Constructor with parameters\n     *\n     * @param vi The elements of the array containing the number of Vinegar\n     *           variables per layer are set to the values of the input array.\n     */\n    public RainbowParameters(int[] vi)\n    {\n        this.vi = vi;\n        try\n        {\n            checkParams();\n        }\n        catch (Exception e)\n        {\n            e.printStackTrace();\n        }\n    }\n\n    private void checkParams()\n        throws Exception\n    {\n        if (vi == null)\n        {\n            throw new Exception(\"no layers defined.\");\n        }\n        if (vi.length > 1)\n        {\n            for (int i = 0; i < vi.length - 1; i++)\n            {\n                if (vi[i] >= vi[i + 1])\n                {\n                    throw new Exception(\n                        \"v[i] has to be smaller than v[i+1]\");\n                }\n            }\n        }\n        else\n        {\n            throw new Exception(\n                \"Rainbow needs at least 1 layer, such that v1 < v2.\");\n        }\n    }\n\n    /**\n     * Getter for the number of layers\n     *\n     * @return the number of layers\n     */\n    public int getNumOfLayers()\n    {\n        return this.vi.length - 1;\n    }\n\n    /**\n     * Getter for the number of all the polynomials in Rainbow\n     *\n     * @return the number of the polynomials\n     */\n    public int getDocLength()\n    {\n        return vi[vi.length - 1] - vi[0];\n    }\n\n    /**\n     * Getter for the array containing the number of Vinegar-variables per layer\n     *\n     * @return the numbers of vinegars per layer\n     */\n    public int[] getVi()\n    {\n        return this.vi;\n    }\n}\n", "package org.bouncycastle.pqc.crypto.xmss;\n\nimport java.io.IOException;\n\nimport org.bouncycastle.crypto.params.AsymmetricKeyParameter;\nimport org.bouncycastle.util.Arrays;\n\n/**\n * XMSS^MT Private Key.\n */\npublic final class XMSSMTPrivateKeyParameters\n    extends AsymmetricKeyParameter\n    implements XMSSStoreableObjectInterface\n{\n\n    private final XMSSMTParameters params;\n    private final long index;\n    private final byte[] secretKeySeed;\n    private final byte[] secretKeyPRF;\n    private final byte[] publicSeed;\n    private final byte[] root;\n    private final BDSStateMap bdsState;\n\n    private XMSSMTPrivateKeyParameters(Builder builder)\n    {\n        super(true);\n        params = builder.params;\n        if (params == null)\n        {\n            throw new NullPointerException(\"params == null\");\n        }\n        int n = params.getDigestSize();\n        byte[] privateKey = builder.privateKey;\n        if (privateKey != null)\n        {\n            if (builder.xmss == null)\n            {\n                throw new NullPointerException(\"xmss == null\");\n            }\n            /* import */\n            int totalHeight = params.getHeight();\n            int indexSize = (totalHeight + 7) / 8;\n            int secretKeySize = n;\n            int secretKeyPRFSize = n;\n            int publicSeedSize = n;\n            int rootSize = n;\n            /*\n            int totalSize = indexSize + secretKeySize + secretKeyPRFSize + publicSeedSize + rootSize;\n\t\t\tif (privateKey.length != totalSize) {\n\t\t\t\tthrow new ParseException(\"private key has wrong size\", 0);\n\t\t\t}\n\t\t\t*/\n            int position = 0;\n            index = XMSSUtil.bytesToXBigEndian(privateKey, position, indexSize);\n            if (!XMSSUtil.isIndexValid(totalHeight, index))\n            {\n                throw new IllegalArgumentException(\"index out of bounds\");\n            }\n            position += indexSize;\n            secretKeySeed = XMSSUtil.extractBytesAtOffset(privateKey, position, secretKeySize);\n            position += secretKeySize;\n            secretKeyPRF = XMSSUtil.extractBytesAtOffset(privateKey, position, secretKeyPRFSize);\n            position += secretKeyPRFSize;\n            publicSeed = XMSSUtil.extractBytesAtOffset(privateKey, position, publicSeedSize);\n            position += publicSeedSize;\n            root = XMSSUtil.extractBytesAtOffset(privateKey, position, rootSize);\n            position += rootSize;\n\t\t\t/* import BDS state */\n            byte[] bdsStateBinary = XMSSUtil.extractBytesAtOffset(privateKey, position, privateKey.length - position);\n\n            BDSStateMap bdsImport = null;\n            try\n            {\n                bdsImport = (BDSStateMap)XMSSUtil.deserialize(bdsStateBinary);\n            }\n            catch (IOException e)\n            {\n                e.printStackTrace();\n            }\n            catch (ClassNotFoundException e)\n            {\n                e.printStackTrace();\n            }\n            bdsImport.setXMSS(builder.xmss);\n            bdsState = bdsImport;\n        }\n        else\n        {\n\t\t\t/* set */\n            index = builder.index;\n            byte[] tmpSecretKeySeed = builder.secretKeySeed;\n            if (tmpSecretKeySeed != null)\n            {\n                if (tmpSecretKeySeed.length != n)\n                {\n                    throw new IllegalArgumentException(\"size of secretKeySeed needs to be equal size of digest\");\n                }\n                secretKeySeed = tmpSecretKeySeed;\n            }\n            else\n            {\n                secretKeySeed = new byte[n];\n            }\n            byte[] tmpSecretKeyPRF = builder.secretKeyPRF;\n            if (tmpSecretKeyPRF != null)\n            {\n                if (tmpSecretKeyPRF.length != n)\n                {\n                    throw new IllegalArgumentException(\"size of secretKeyPRF needs to be equal size of digest\");\n                }\n                secretKeyPRF = tmpSecretKeyPRF;\n            }\n            else\n            {\n                secretKeyPRF = new byte[n];\n            }\n            byte[] tmpPublicSeed = builder.publicSeed;\n            if (tmpPublicSeed != null)\n            {\n                if (tmpPublicSeed.length != n)\n                {\n                    throw new IllegalArgumentException(\"size of publicSeed needs to be equal size of digest\");\n                }\n                publicSeed = tmpPublicSeed;\n            }\n            else\n            {\n                publicSeed = new byte[n];\n            }\n            byte[] tmpRoot = builder.root;\n            if (tmpRoot != null)\n            {\n                if (tmpRoot.length != n)\n                {\n                    throw new IllegalArgumentException(\"size of root needs to be equal size of digest\");\n                }\n                root = tmpRoot;\n            }\n            else\n            {\n                root = new byte[n];\n            }\n            BDSStateMap tmpBDSState = builder.bdsState;\n            if (tmpBDSState != null)\n            {\n                bdsState = tmpBDSState;\n            }\n            else\n            {\n                long globalIndex = builder.index;\n                int totalHeight = params.getHeight();\n\n                if (XMSSUtil.isIndexValid(totalHeight, globalIndex) && tmpPublicSeed != null && tmpSecretKeySeed != null)\n                {\n                    bdsState = new BDSStateMap(params, builder.index, tmpPublicSeed, tmpSecretKeySeed);\n                }\n                else\n                {\n                    bdsState = new BDSStateMap();\n                }\n            }\n        }\n    }\n\n    public static class Builder\n    {\n\n        /* mandatory */\n        private final XMSSMTParameters params;\n        /* optional */\n        private long index = 0L;\n        private byte[] secretKeySeed = null;\n        private byte[] secretKeyPRF = null;\n        private byte[] publicSeed = null;\n        private byte[] root = null;\n        private BDSStateMap bdsState = null;\n        private byte[] privateKey = null;\n        private XMSSParameters xmss = null;\n\n        public Builder(XMSSMTParameters params)\n        {\n            super();\n            this.params = params;\n        }\n\n        public Builder withIndex(long val)\n        {\n            index = val;\n            return this;\n        }\n\n        public Builder withSecretKeySeed(byte[] val)\n        {\n            secretKeySeed = XMSSUtil.cloneArray(val);\n            return this;\n        }\n\n        public Builder withSecretKeyPRF(byte[] val)\n        {\n            secretKeyPRF = XMSSUtil.cloneArray(val);\n            return this;\n        }\n\n        public Builder withPublicSeed(byte[] val)\n        {\n            publicSeed = XMSSUtil.cloneArray(val);\n            return this;\n        }\n\n        public Builder withRoot(byte[] val)\n        {\n            root = XMSSUtil.cloneArray(val);\n            return this;\n        }\n\n        public Builder withBDSState(BDSStateMap val)\n        {\n            bdsState = val;\n            return this;\n        }\n\n        public Builder withPrivateKey(byte[] privateKeyVal, XMSSParameters xmssVal)\n        {\n            privateKey = XMSSUtil.cloneArray(privateKeyVal);\n            xmss = xmssVal;\n            return this;\n        }\n\n        public XMSSMTPrivateKeyParameters build()\n        {\n            return new XMSSMTPrivateKeyParameters(this);\n        }\n    }\n\n    public byte[] toByteArray()\n    {\n\t\t/* index || secretKeySeed || secretKeyPRF || publicSeed || root */\n        int n = params.getDigestSize();\n        int indexSize = (params.getHeight() + 7) / 8;\n        int secretKeySize = n;\n        int secretKeyPRFSize = n;\n        int publicSeedSize = n;\n        int rootSize = n;\n        int totalSize = indexSize + secretKeySize + secretKeyPRFSize + publicSeedSize + rootSize;\n        byte[] out = new byte[totalSize];\n        int position = 0;\n\t\t/* copy index */\n        byte[] indexBytes = XMSSUtil.toBytesBigEndian(index, indexSize);\n        XMSSUtil.copyBytesAtOffset(out, indexBytes, position);\n        position += indexSize;\n\t\t/* copy secretKeySeed */\n        XMSSUtil.copyBytesAtOffset(out, secretKeySeed, position);\n        position += secretKeySize;\n\t\t/* copy secretKeyPRF */\n        XMSSUtil.copyBytesAtOffset(out, secretKeyPRF, position);\n        position += secretKeyPRFSize;\n\t\t/* copy publicSeed */\n        XMSSUtil.copyBytesAtOffset(out, publicSeed, position);\n        position += publicSeedSize;\n\t\t/* copy root */\n        XMSSUtil.copyBytesAtOffset(out, root, position);\n\t\t/* concatenate bdsState */\n        byte[] bdsStateOut = null;\n        try\n        {\n            bdsStateOut = XMSSUtil.serialize(bdsState);\n        }\n        catch (IOException e)\n        {\n            e.printStackTrace();\n            throw new RuntimeException(\"error serializing bds state\");\n        }\n        return Arrays.concatenate(out, bdsStateOut);\n    }\n\n    public long getIndex()\n    {\n        return index;\n    }\n\n    public byte[] getSecretKeySeed()\n    {\n        return XMSSUtil.cloneArray(secretKeySeed);\n    }\n\n    public byte[] getSecretKeyPRF()\n    {\n        return XMSSUtil.cloneArray(secretKeyPRF);\n    }\n\n    public byte[] getPublicSeed()\n    {\n        return XMSSUtil.cloneArray(publicSeed);\n    }\n\n    public byte[] getRoot()\n    {\n        return XMSSUtil.cloneArray(root);\n    }\n\n    BDSStateMap getBDSState()\n    {\n        return bdsState;\n    }\n\n    public XMSSMTParameters getParameters()\n    {\n        return params;\n    }\n\n    public XMSSMTPrivateKeyParameters getNextKey()\n    {\n        BDSStateMap newState = new BDSStateMap(bdsState, params, this.getIndex(), publicSeed, secretKeySeed);\n\n        return new XMSSMTPrivateKeyParameters.Builder(params).withIndex(index + 1)\n            .withSecretKeySeed(secretKeySeed).withSecretKeyPRF(secretKeyPRF)\n            .withPublicSeed(publicSeed).withRoot(root)\n            .withBDSState(newState).build();\n    }\n}\n", "package org.bouncycastle.pqc.crypto.xmss;\n\nimport java.io.IOException;\n\nimport org.bouncycastle.crypto.params.AsymmetricKeyParameter;\nimport org.bouncycastle.util.Arrays;\nimport org.bouncycastle.util.Pack;\n\n/**\n * XMSS Private Key.\n */\npublic final class XMSSPrivateKeyParameters\n    extends AsymmetricKeyParameter\n    implements XMSSStoreableObjectInterface\n{\n\n    /**\n     * XMSS parameters object.\n     */\n    private final XMSSParameters params;\n    /**\n     * Secret for the derivation of WOTS+ secret keys.\n     */\n    private final byte[] secretKeySeed;\n    /**\n     * Secret for the randomization of message digests during signature\n     * creation.\n     */\n    private final byte[] secretKeyPRF;\n    /**\n     * Public seed for the randomization of hashes.\n     */\n    private final byte[] publicSeed;\n    /**\n     * Public root of binary tree.\n     */\n    private final byte[] root;\n    /**\n     * BDS state.\n     */\n    private final BDS bdsState;\n\n    private XMSSPrivateKeyParameters(Builder builder)\n    {\n        super(true);\n        params = builder.params;\n        if (params == null)\n        {\n            throw new NullPointerException(\"params == null\");\n        }\n        int n = params.getDigestSize();\n        byte[] privateKey = builder.privateKey;\n        if (privateKey != null)\n        {\n            if (builder.xmss == null)\n            {\n                throw new NullPointerException(\"xmss == null\");\n            }\n            /* import */\n            int height = params.getHeight();\n            int indexSize = 4;\n            int secretKeySize = n;\n            int secretKeyPRFSize = n;\n            int publicSeedSize = n;\n            int rootSize = n;\n\t\t\t/*\n\t\t\tint totalSize = indexSize + secretKeySize + secretKeyPRFSize + publicSeedSize + rootSize;\n\t\t\tif (privateKey.length != totalSize) {\n\t\t\t\tthrow new ParseException(\"private key has wrong size\", 0);\n\t\t\t}\n\t\t\t*/\n            int position = 0;\n            int index = Pack.bigEndianToInt(privateKey, position);\n            if (!XMSSUtil.isIndexValid(height, index))\n            {\n                throw new IllegalArgumentException(\"index out of bounds\");\n            }\n            position += indexSize;\n            secretKeySeed = XMSSUtil.extractBytesAtOffset(privateKey, position, secretKeySize);\n            position += secretKeySize;\n            secretKeyPRF = XMSSUtil.extractBytesAtOffset(privateKey, position, secretKeyPRFSize);\n            position += secretKeyPRFSize;\n            publicSeed = XMSSUtil.extractBytesAtOffset(privateKey, position, publicSeedSize);\n            position += publicSeedSize;\n            root = XMSSUtil.extractBytesAtOffset(privateKey, position, rootSize);\n            position += rootSize;\n\t\t\t/* import BDS state */\n            byte[] bdsStateBinary = XMSSUtil.extractBytesAtOffset(privateKey, position, privateKey.length - position);\n            BDS bdsImport = null;\n            try\n            {\n                bdsImport = (BDS)XMSSUtil.deserialize(bdsStateBinary);\n            }\n            catch (IOException e)\n            {\n                e.printStackTrace();\n            }\n            catch (ClassNotFoundException e)\n            {\n                e.printStackTrace();\n            }\n            bdsImport.setXMSS(builder.xmss);\n            bdsImport.validate();\n            if (bdsImport.getIndex() != index)\n            {\n                throw new IllegalStateException(\"serialized BDS has wrong index\");\n            }\n            bdsState = bdsImport;\n        }\n        else\n        {\n\t\t\t/* set */\n            byte[] tmpSecretKeySeed = builder.secretKeySeed;\n            if (tmpSecretKeySeed != null)\n            {\n                if (tmpSecretKeySeed.length != n)\n                {\n                    throw new IllegalArgumentException(\"size of secretKeySeed needs to be equal size of digest\");\n                }\n                secretKeySeed = tmpSecretKeySeed;\n            }\n            else\n            {\n                secretKeySeed = new byte[n];\n            }\n            byte[] tmpSecretKeyPRF = builder.secretKeyPRF;\n            if (tmpSecretKeyPRF != null)\n            {\n                if (tmpSecretKeyPRF.length != n)\n                {\n                    throw new IllegalArgumentException(\"size of secretKeyPRF needs to be equal size of digest\");\n                }\n                secretKeyPRF = tmpSecretKeyPRF;\n            }\n            else\n            {\n                secretKeyPRF = new byte[n];\n            }\n            byte[] tmpPublicSeed = builder.publicSeed;\n            if (tmpPublicSeed != null)\n            {\n                if (tmpPublicSeed.length != n)\n                {\n                    throw new IllegalArgumentException(\"size of publicSeed needs to be equal size of digest\");\n                }\n                publicSeed = tmpPublicSeed;\n            }\n            else\n            {\n                publicSeed = new byte[n];\n            }\n            byte[] tmpRoot = builder.root;\n            if (tmpRoot != null)\n            {\n                if (tmpRoot.length != n)\n                {\n                    throw new IllegalArgumentException(\"size of root needs to be equal size of digest\");\n                }\n                root = tmpRoot;\n            }\n            else\n            {\n                root = new byte[n];\n            }\n            BDS tmpBDSState = builder.bdsState;\n            if (tmpBDSState != null)\n            {\n                bdsState = tmpBDSState;\n            }\n            else\n            {\n                if (builder.index < ((1 << params.getHeight()) - 2) && tmpPublicSeed != null && tmpSecretKeySeed != null)\n                {\n                    bdsState = new BDS(params, tmpPublicSeed, tmpSecretKeySeed, (OTSHashAddress)new OTSHashAddress.Builder().build(), builder.index);\n                }\n                else\n                {\n                    bdsState = new BDS(params, builder.index);\n                }\n            }\n        }\n    }\n\n    public static class Builder\n    {\n\n        /* mandatory */\n        private final XMSSParameters params;\n        /* optional */\n        private int index = 0;\n        private byte[] secretKeySeed = null;\n        private byte[] secretKeyPRF = null;\n        private byte[] publicSeed = null;\n        private byte[] root = null;\n        private BDS bdsState = null;\n        private byte[] privateKey = null;\n        private XMSSParameters xmss = null;\n\n        public Builder(XMSSParameters params)\n        {\n            super();\n            this.params = params;\n        }\n\n        public Builder withIndex(int val)\n        {\n            index = val;\n            return this;\n        }\n\n        public Builder withSecretKeySeed(byte[] val)\n        {\n            secretKeySeed = XMSSUtil.cloneArray(val);\n            return this;\n        }\n\n        public Builder withSecretKeyPRF(byte[] val)\n        {\n            secretKeyPRF = XMSSUtil.cloneArray(val);\n            return this;\n        }\n\n        public Builder withPublicSeed(byte[] val)\n        {\n            publicSeed = XMSSUtil.cloneArray(val);\n            return this;\n        }\n\n        public Builder withRoot(byte[] val)\n        {\n            root = XMSSUtil.cloneArray(val);\n            return this;\n        }\n\n        public Builder withBDSState(BDS valBDS)\n        {\n            bdsState = valBDS;\n            return this;\n        }\n\n        public Builder withPrivateKey(byte[] privateKeyVal, XMSSParameters xmssParameters)\n        {\n            privateKey = XMSSUtil.cloneArray(privateKeyVal);\n            xmss = xmssParameters;\n            return this;\n        }\n\n        public XMSSPrivateKeyParameters build()\n        {\n            return new XMSSPrivateKeyParameters(this);\n        }\n    }\n\n    public byte[] toByteArray()\n    {\n\t\t/* index || secretKeySeed || secretKeyPRF || publicSeed || root */\n        int n = params.getDigestSize();\n        int indexSize = 4;\n        int secretKeySize = n;\n        int secretKeyPRFSize = n;\n        int publicSeedSize = n;\n        int rootSize = n;\n        int totalSize = indexSize + secretKeySize + secretKeyPRFSize + publicSeedSize + rootSize;\n        byte[] out = new byte[totalSize];\n        int position = 0;\n\t\t/* copy index */\n        Pack.intToBigEndian(bdsState.getIndex(), out, position);\n        position += indexSize;\n\t\t/* copy secretKeySeed */\n        XMSSUtil.copyBytesAtOffset(out, secretKeySeed, position);\n        position += secretKeySize;\n\t\t/* copy secretKeyPRF */\n        XMSSUtil.copyBytesAtOffset(out, secretKeyPRF, position);\n        position += secretKeyPRFSize;\n\t\t/* copy publicSeed */\n        XMSSUtil.copyBytesAtOffset(out, publicSeed, position);\n        position += publicSeedSize;\n\t\t/* copy root */\n        XMSSUtil.copyBytesAtOffset(out, root, position);\n\t\t/* concatenate bdsState */\n        byte[] bdsStateOut = null;\n        try\n        {\n            bdsStateOut = XMSSUtil.serialize(bdsState);\n        }\n        catch (IOException e)\n        {\n            throw new RuntimeException(\"error serializing bds state: \" + e.getMessage());\n        }\n\n        return Arrays.concatenate(out, bdsStateOut);\n    }\n\n    public int getIndex()\n    {\n        return bdsState.getIndex();\n    }\n\n    public byte[] getSecretKeySeed()\n    {\n        return XMSSUtil.cloneArray(secretKeySeed);\n    }\n\n    public byte[] getSecretKeyPRF()\n    {\n        return XMSSUtil.cloneArray(secretKeyPRF);\n    }\n\n    public byte[] getPublicSeed()\n    {\n        return XMSSUtil.cloneArray(publicSeed);\n    }\n\n    public byte[] getRoot()\n    {\n        return XMSSUtil.cloneArray(root);\n    }\n\n    BDS getBDSState()\n    {\n        return bdsState;\n    }\n\n    public XMSSParameters getParameters()\n    {\n        return params;\n    }\n\n    public XMSSPrivateKeyParameters getNextKey()\n    {\n        /* prepare authentication path for next leaf */\n        int treeHeight = this.params.getHeight();\n        if (this.getIndex() < ((1 << treeHeight) - 1))\n        {\n            return new XMSSPrivateKeyParameters.Builder(params)\n                .withSecretKeySeed(secretKeySeed).withSecretKeyPRF(secretKeyPRF)\n                .withPublicSeed(publicSeed).withRoot(root)\n                .withBDSState(bdsState.getNextState(publicSeed, secretKeySeed, (OTSHashAddress)new OTSHashAddress.Builder().build())).build();\n        }\n        else\n        {\n            return new XMSSPrivateKeyParameters.Builder(params)\n                .withSecretKeySeed(secretKeySeed).withSecretKeyPRF(secretKeyPRF)\n                .withPublicSeed(publicSeed).withRoot(root)\n                .withBDSState(new BDS(params, getIndex() + 1)).build();  // no more nodes left.\n        }\n    }\n\n}\n", "package org.bouncycastle.pqc.crypto.xmss;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\n\nimport org.bouncycastle.crypto.Digest;\nimport org.bouncycastle.util.Arrays;\nimport org.bouncycastle.util.encoders.Hex;\n\n/**\n * Utils for XMSS implementation.\n */\npublic class XMSSUtil\n{\n\n    /**\n     * Calculates the logarithm base 2 for a given Integer.\n     *\n     * @param n Number.\n     * @return Logarithm to base 2 of {@code n}.\n     */\n    public static int log2(int n)\n    {\n        int log = 0;\n        while ((n >>= 1) != 0)\n        {\n            log++;\n        }\n        return log;\n    }\n\n    /**\n     * Convert int/long to n-byte array.\n     *\n     * @param value      int/long value.\n     * @param sizeInByte Size of byte array in byte.\n     * @return int/long as big-endian byte array of size {@code sizeInByte}.\n     */\n    public static byte[] toBytesBigEndian(long value, int sizeInByte)\n    {\n        byte[] out = new byte[sizeInByte];\n        for (int i = (sizeInByte - 1); i >= 0; i--)\n        {\n            out[i] = (byte)value;\n            value >>>= 8;\n        }\n        return out;\n    }\n\n    /*\n     * Copy long to byte array in big-endian at specific offset.\n     */\n    public static void longToBigEndian(long value, byte[] in, int offset)\n    {\n        if (in == null)\n        {\n            throw new NullPointerException(\"in == null\");\n        }\n        if ((in.length - offset) < 8)\n        {\n            throw new IllegalArgumentException(\"not enough space in array\");\n        }\n        in[offset] = (byte)((value >> 56) & 0xff);\n        in[offset + 1] = (byte)((value >> 48) & 0xff);\n        in[offset + 2] = (byte)((value >> 40) & 0xff);\n        in[offset + 3] = (byte)((value >> 32) & 0xff);\n        in[offset + 4] = (byte)((value >> 24) & 0xff);\n        in[offset + 5] = (byte)((value >> 16) & 0xff);\n        in[offset + 6] = (byte)((value >> 8) & 0xff);\n        in[offset + 7] = (byte)((value) & 0xff);\n    }\n\n    /*\n     * Generic convert from big endian byte array to long.\n     */\n    public static long bytesToXBigEndian(byte[] in, int offset, int size)\n    {\n        if (in == null)\n        {\n            throw new NullPointerException(\"in == null\");\n        }\n        long res = 0;\n        for (int i = offset; i < (offset + size); i++)\n        {\n            res = (res << 8) | (in[i] & 0xff);\n        }\n        return res;\n    }\n\n    /**\n     * Clone a byte array.\n     *\n     * @param in byte array.\n     * @return Copy of byte array.\n     */\n    public static byte[] cloneArray(byte[] in)\n    {\n        if (in == null)\n        {\n            throw new NullPointerException(\"in == null\");\n        }\n        byte[] out = new byte[in.length];\n        for (int i = 0; i < in.length; i++)\n        {\n            out[i] = in[i];\n        }\n        return out;\n    }\n\n    /**\n     * Clone a 2d byte array.\n     *\n     * @param in 2d byte array.\n     * @return Copy of 2d byte array.\n     */\n    public static byte[][] cloneArray(byte[][] in)\n    {\n        if (hasNullPointer(in))\n        {\n            throw new NullPointerException(\"in has null pointers\");\n        }\n        byte[][] out = new byte[in.length][];\n        for (int i = 0; i < in.length; i++)\n        {\n            out[i] = new byte[in[i].length];\n            for (int j = 0; j < in[i].length; j++)\n            {\n                out[i][j] = in[i][j];\n            }\n        }\n        return out;\n    }\n\n    /**\n     * Compares two 2d-byte arrays.\n     *\n     * @param a 2d-byte array 1.\n     * @param b 2d-byte array 2.\n     * @return true if all values in 2d-byte array are equal false else.\n     */\n    public static boolean areEqual(byte[][] a, byte[][] b)\n    {\n        if (hasNullPointer(a) || hasNullPointer(b))\n        {\n            throw new NullPointerException(\"a or b == null\");\n        }\n        for (int i = 0; i < a.length; i++)\n        {\n            if (!Arrays.areEqual(a[i], b[i]))\n            {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Dump content of 2d byte array.\n     *\n     * @param x byte array.\n     */\n    public static void dumpByteArray(byte[][] x)\n    {\n        if (hasNullPointer(x))\n        {\n            throw new NullPointerException(\"x has null pointers\");\n        }\n        for (int i = 0; i < x.length; i++)\n        {\n            System.out.println(Hex.toHexString(x[i]));\n        }\n    }\n\n    /**\n     * Checks whether 2d byte array has null pointers.\n     *\n     * @param in 2d byte array.\n     * @return true if at least one null pointer is found false else.\n     */\n    public static boolean hasNullPointer(byte[][] in)\n    {\n        if (in == null)\n        {\n            return true;\n        }\n        for (int i = 0; i < in.length; i++)\n        {\n            if (in[i] == null)\n            {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Copy src byte array to dst byte array at offset.\n     *\n     * @param dst    Destination.\n     * @param src    Source.\n     * @param offset Destination offset.\n     */\n    public static void copyBytesAtOffset(byte[] dst, byte[] src, int offset)\n    {\n        if (dst == null)\n        {\n            throw new NullPointerException(\"dst == null\");\n        }\n        if (src == null)\n        {\n            throw new NullPointerException(\"src == null\");\n        }\n        if (offset < 0)\n        {\n            throw new IllegalArgumentException(\"offset hast to be >= 0\");\n        }\n        if ((src.length + offset) > dst.length)\n        {\n            throw new IllegalArgumentException(\"src length + offset must not be greater than size of destination\");\n        }\n        for (int i = 0; i < src.length; i++)\n        {\n            dst[offset + i] = src[i];\n        }\n    }\n\n    /**\n     * Copy length bytes at position offset from src.\n     *\n     * @param src    Source byte array.\n     * @param offset Offset in source byte array.\n     * @param length Length of bytes to copy.\n     * @return New byte array.\n     */\n    public static byte[] extractBytesAtOffset(byte[] src, int offset, int length)\n    {\n        if (src == null)\n        {\n            throw new NullPointerException(\"src == null\");\n        }\n        if (offset < 0)\n        {\n            throw new IllegalArgumentException(\"offset hast to be >= 0\");\n        }\n        if (length < 0)\n        {\n            throw new IllegalArgumentException(\"length hast to be >= 0\");\n        }\n        if ((offset + length) > src.length)\n        {\n            throw new IllegalArgumentException(\"offset + length must not be greater then size of source array\");\n        }\n        byte[] out = new byte[length];\n        for (int i = 0; i < out.length; i++)\n        {\n            out[i] = src[offset + i];\n        }\n        return out;\n    }\n\n    /**\n     * Check whether an index is valid or not.\n     *\n     * @param height Height of binary tree.\n     * @param index  Index to validate.\n     * @return true if index is valid false else.\n     */\n    public static boolean isIndexValid(int height, long index)\n    {\n        if (index < 0)\n        {\n            throw new IllegalStateException(\"index must not be negative\");\n        }\n        return index < (1L << height);\n    }\n\n    /**\n     * Determine digest size of digest.\n     *\n     * @param digest Digest.\n     * @return Digest size.\n     */\n    public static int getDigestSize(Digest digest)\n    {\n        if (digest == null)\n        {\n            throw new NullPointerException(\"digest == null\");\n        }\n        String algorithmName = digest.getAlgorithmName();\n        if (algorithmName.equals(\"SHAKE128\"))\n        {\n            return 32;\n        }\n        if (algorithmName.equals(\"SHAKE256\"))\n        {\n            return 64;\n        }\n        return digest.getDigestSize();\n    }\n\n    public static long getTreeIndex(long index, int xmssTreeHeight)\n    {\n        return index >> xmssTreeHeight;\n    }\n\n    public static int getLeafIndex(long index, int xmssTreeHeight)\n    {\n        return (int)(index & ((1L << xmssTreeHeight) - 1L));\n    }\n\n    public static byte[] serialize(Object obj)\n        throws IOException\n    {\n        ByteArrayOutputStream out = new ByteArrayOutputStream();\n        ObjectOutputStream oos = new ObjectOutputStream(out);\n        oos.writeObject(obj);\n        oos.flush();\n        return out.toByteArray();\n    }\n\n    public static Object deserialize(byte[] data)\n        throws IOException, ClassNotFoundException\n    {\n        ByteArrayInputStream in = new ByteArrayInputStream(data);\n        ObjectInputStream is = new ObjectInputStream(in);\n        return is.readObject();\n    }\n\n    public static int calculateTau(int index, int height)\n    {\n        int tau = 0;\n        for (int i = 0; i < height; i++)\n        {\n            if (((index >> i) & 1) == 0)\n            {\n                tau = i;\n                break;\n            }\n        }\n        return tau;\n    }\n\n    public static boolean isNewBDSInitNeeded(long globalIndex, int xmssHeight, int layer)\n    {\n        if (globalIndex == 0)\n        {\n            return false;\n        }\n        return (globalIndex % (long)Math.pow((1 << xmssHeight), layer + 1) == 0) ? true : false;\n    }\n\n    public static boolean isNewAuthenticationPathNeeded(long globalIndex, int xmssHeight, int layer)\n    {\n        if (globalIndex == 0)\n        {\n            return false;\n        }\n        return ((globalIndex + 1) % (long)Math.pow((1 << xmssHeight), layer) == 0) ? true : false;\n    }\n}\n", "package org.bouncycastle.pqc.math.linearalgebra;\n\n\nimport java.security.SecureRandom;\nimport java.util.Vector;\n\n\n/**\n * This abstract class defines the finite field <i>GF(2<sup>n</sup>)</i>. It\n * holds the extension degree <i>n</i>, the characteristic, the irreducible\n * fieldpolynomial and conversion matrices. GF2nField is implemented by the\n * classes GF2nPolynomialField and GF2nONBField.\n *\n * @see GF2nONBField\n * @see GF2nPolynomialField\n */\npublic abstract class GF2nField\n{\n\n    protected final SecureRandom random;\n\n    /**\n     * the degree of this field\n     */\n    protected int mDegree;\n\n    /**\n     * the irreducible fieldPolynomial stored in normal order (also for ONB)\n     */\n    protected GF2Polynomial fieldPolynomial;\n\n    /**\n     * holds a list of GF2nFields to which elements have been converted and thus\n     * a COB-Matrix exists\n     */\n    protected Vector fields;\n\n    /**\n     * the COB matrices\n     */\n    protected Vector matrices;\n\n    protected GF2nField(SecureRandom random)\n    {\n        this.random = random;\n    }\n\n    /**\n     * Returns the degree <i>n</i> of this field.\n     *\n     * @return the degree <i>n</i> of this field\n     */\n    public final int getDegree()\n    {\n        return mDegree;\n    }\n\n    /**\n     * Returns the fieldpolynomial as a new Bitstring.\n     *\n     * @return a copy of the fieldpolynomial as a new Bitstring\n     */\n    public final GF2Polynomial getFieldPolynomial()\n    {\n        if (fieldPolynomial == null)\n        {\n            computeFieldPolynomial();\n        }\n        return new GF2Polynomial(fieldPolynomial);\n    }\n\n    /**\n     * Decides whether the given object <tt>other</tt> is the same as this\n     * field.\n     *\n     * @param other another object\n     * @return (this == other)\n     */\n    public final boolean equals(Object other)\n    {\n        if (other == null || !(other instanceof GF2nField))\n        {\n            return false;\n        }\n\n        GF2nField otherField = (GF2nField)other;\n\n        if (otherField.mDegree != mDegree)\n        {\n            return false;\n        }\n        if (!fieldPolynomial.equals(otherField.fieldPolynomial))\n        {\n            return false;\n        }\n        if ((this instanceof GF2nPolynomialField)\n            && !(otherField instanceof GF2nPolynomialField))\n        {\n            return false;\n        }\n        if ((this instanceof GF2nONBField)\n            && !(otherField instanceof GF2nONBField))\n        {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * @return the hash code of this field\n     */\n    public int hashCode()\n    {\n        return mDegree + fieldPolynomial.hashCode();\n    }\n\n    /**\n     * Computes a random root from the given irreducible fieldpolynomial\n     * according to IEEE 1363 algorithm A.5.6. This cal take very long for big\n     * degrees.\n     *\n     * @param B0FieldPolynomial the fieldpolynomial if the other basis as a Bitstring\n     * @return a random root of BOFieldPolynomial in representation according to\n     *         this field\n     * @see \"P1363 A.5.6, p103f\"\n     */\n    protected abstract GF2nElement getRandomRoot(GF2Polynomial B0FieldPolynomial);\n\n    /**\n     * Computes the change-of-basis matrix for basis conversion according to\n     * 1363. The result is stored in the lists fields and matrices.\n     *\n     * @param B1 the GF2nField to convert to\n     * @see \"P1363 A.7.3, p111ff\"\n     */\n    protected abstract void computeCOBMatrix(GF2nField B1);\n\n    /**\n     * Computes the fieldpolynomial. This can take a long time for big degrees.\n     */\n    protected abstract void computeFieldPolynomial();\n\n    /**\n     * Inverts the given matrix represented as bitstrings.\n     *\n     * @param matrix the matrix to invert as a Bitstring[]\n     * @return matrix^(-1)\n     */\n    protected final GF2Polynomial[] invertMatrix(GF2Polynomial[] matrix)\n    {\n        GF2Polynomial[] a = new GF2Polynomial[matrix.length];\n        GF2Polynomial[] inv = new GF2Polynomial[matrix.length];\n        GF2Polynomial dummy;\n        int i, j;\n        // initialize a as a copy of matrix and inv as E(inheitsmatrix)\n        for (i = 0; i < mDegree; i++)\n        {\n            try\n            {\n                a[i] = new GF2Polynomial(matrix[i]);\n                inv[i] = new GF2Polynomial(mDegree);\n                inv[i].setBit(mDegree - 1 - i);\n            }\n            catch (RuntimeException BDNEExc)\n            {\n                BDNEExc.printStackTrace();\n            }\n        }\n        // construct triangle matrix so that for each a[i] the first i bits are\n        // zero\n        for (i = 0; i < mDegree - 1; i++)\n        {\n            // find column where bit i is set\n            j = i;\n            while ((j < mDegree) && !a[j].testBit(mDegree - 1 - i))\n            {\n                j++;\n            }\n            if (j >= mDegree)\n            {\n                throw new RuntimeException(\n                    \"GF2nField.invertMatrix: Matrix cannot be inverted!\");\n            }\n            if (i != j)\n            { // swap a[i]/a[j] and inv[i]/inv[j]\n                dummy = a[i];\n                a[i] = a[j];\n                a[j] = dummy;\n                dummy = inv[i];\n                inv[i] = inv[j];\n                inv[j] = dummy;\n            }\n            for (j = i + 1; j < mDegree; j++)\n            { // add column i to all columns>i\n                // having their i-th bit set\n                if (a[j].testBit(mDegree - 1 - i))\n                {\n                    a[j].addToThis(a[i]);\n                    inv[j].addToThis(inv[i]);\n                }\n            }\n        }\n        // construct Einheitsmatrix from a\n        for (i = mDegree - 1; i > 0; i--)\n        {\n            for (j = i - 1; j >= 0; j--)\n            { // eliminate the i-th bit in all\n                // columns < i\n                if (a[j].testBit(mDegree - 1 - i))\n                {\n                    a[j].addToThis(a[i]);\n                    inv[j].addToThis(inv[i]);\n                }\n            }\n        }\n        return inv;\n    }\n\n    /**\n     * Converts the given element in representation according to this field to a\n     * new element in representation according to B1 using the change-of-basis\n     * matrix calculated by computeCOBMatrix.\n     *\n     * @param elem  the GF2nElement to convert\n     * @param basis the basis to convert <tt>elem</tt> to\n     * @return <tt>elem</tt> converted to a new element representation\n     *         according to <tt>basis</tt>\n     * @see GF2nField#computeCOBMatrix\n     * @see GF2nField#getRandomRoot\n     * @see GF2nPolynomial\n     * @see \"P1363 A.7 p109ff\"\n     */\n    public final GF2nElement convert(GF2nElement elem, GF2nField basis)\n        throws RuntimeException\n    {\n        if (basis == this)\n        {\n            return (GF2nElement)elem.clone();\n        }\n        if (fieldPolynomial.equals(basis.fieldPolynomial))\n        {\n            return (GF2nElement)elem.clone();\n        }\n        if (mDegree != basis.mDegree)\n        {\n            throw new RuntimeException(\"GF2nField.convert: B1 has a\"\n                + \" different degree and thus cannot be coverted to!\");\n        }\n\n        int i;\n        GF2Polynomial[] COBMatrix;\n        i = fields.indexOf(basis);\n        if (i == -1)\n        {\n            computeCOBMatrix(basis);\n            i = fields.indexOf(basis);\n        }\n        COBMatrix = (GF2Polynomial[])matrices.elementAt(i);\n\n        GF2nElement elemCopy = (GF2nElement)elem.clone();\n        if (elemCopy instanceof GF2nONBElement)\n        {\n            // remember: ONB treats its bits in reverse order\n            ((GF2nONBElement)elemCopy).reverseOrder();\n        }\n        GF2Polynomial bs = new GF2Polynomial(mDegree, elemCopy.toFlexiBigInt());\n        bs.expandN(mDegree);\n        GF2Polynomial result = new GF2Polynomial(mDegree);\n        for (i = 0; i < mDegree; i++)\n        {\n            if (bs.vectorMult(COBMatrix[i]))\n            {\n                result.setBit(mDegree - 1 - i);\n            }\n        }\n        if (basis instanceof GF2nPolynomialField)\n        {\n            return new GF2nPolynomialElement((GF2nPolynomialField)basis,\n                result);\n        }\n        else if (basis instanceof GF2nONBField)\n        {\n            GF2nONBElement res = new GF2nONBElement((GF2nONBField)basis,\n                result.toFlexiBigInt());\n            // TODO Remember: ONB treats its Bits in reverse order !!!\n            res.reverseOrder();\n            return res;\n        }\n        else\n        {\n            throw new RuntimeException(\n                \"GF2nField.convert: B1 must be an instance of \"\n                    + \"GF2nPolynomialField or GF2nONBField!\");\n        }\n\n    }\n\n}\n", "package org.bouncycastle.pqc.crypto.test;\n\nimport java.io.IOException;\nimport java.security.SecureRandom;\n\nimport junit.framework.TestCase;\nimport org.bouncycastle.crypto.digests.SHA256Digest;\nimport org.bouncycastle.pqc.crypto.xmss.XMSSMT;\nimport org.bouncycastle.pqc.crypto.xmss.XMSSMTParameters;\nimport org.bouncycastle.util.Arrays;\n\n/**\n * Test cases for XMSSMTPrivateKey class.\n */\npublic class XMSSMTPrivateKeyTest\n    extends TestCase\n{\n\n    public void testPrivateKeyParsingSHA256()\n        throws IOException, ClassNotFoundException\n    {\n        XMSSMTParameters params = new XMSSMTParameters(20, 10, new SHA256Digest());\n        XMSSMT mt = new XMSSMT(params, new SecureRandom());\n        mt.generateKeys();\n        byte[] privateKey = mt.exportPrivateKey();\n        byte[] publicKey = mt.exportPublicKey();\n\n        mt.importState(privateKey, publicKey);\n\n        assertTrue(Arrays.areEqual(privateKey, mt.exportPrivateKey()));\n    }\n}\n", "<html>\n<head>\n<title>Bouncy Castle Crypto Package - Release Notes</title>\n</head>\n\n<body bgcolor=\"#ffffff\" text=\"#000000#\">\n\n<center>\n<h1>Bouncy Castle Crypto Package - Release Notes</h1>\n<font size=1>\n<pre>\n</pre>\n</font>\n</center>\n<h2>1.0 Introduction</h2>\n<p>\nThe Bouncy Castle Crypto package is a Java implementation of \ncryptographic algorithms.  The package is organised so that it \ncontains a light-weight API suitable for use in any environment\n(including the J2ME) with the additional infrastructure\nto conform the algorithms to the JCE framework.\n</p>\n<h2>2.0 Release History</h2>\n\n<h3>2.1.1 Version</h3>\nRelease: 1.60<br/>\nDate:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2018\n<h3>2.1.2 Defects Fixed</h3>\n<ul>\n<li>Base64/UrlBase64 would throw an exception on a zero length string. This has been fixed.</li>\n</ul>\n<h3>2.1.3 Additional Features and Functionality</h3>\n<ul>\n<li>TLS: Extended CBC padding is now optional (and disabled by default).</li>\n<li>TLS: Now supports channel binding 'tls-server-end-point'.</li>\n<li>TLS: InterruptedIOException (e.g. socket timeout) during app-data reads no longer fails connection; handshake is optionally resumable after IIOE using 'TlsProtocol.setResumableHandshake()'.</li>\n<li>BCJSSE: Now supports system property 'jdk.tls.client.protocols'</li>\n<li>BCJSSE: Now supports SSLParameters.setSNIMatchers.</li>\n<li>BCJSSE: SNI can now be used in earlier JDKs via BC extensions.</li>\n<li>BCJSSE: Session context now holds sessions via soft references.</li>\n</ul>\n<h3>2.2.1 Version</h3>\nRelease: 1.59 <br/>\nDate:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2017, December 28\n<h3>2.2.2 Defects Fixed</h3>\n<ul>\n<li>Issues with using PQC based keys with the provided BC KeyStores have now been fixed.</li>\n<li>ECGOST-2012 public keys were being encoded with the wrong OID for the digest parameter in the algorithm parameter set. This has been fixed.</li>\n<li>SM3 has now been added as an acceptable algorithm for TSP timestamps.</li>\n<li>SM2 signatures were using the wrong default identity value. This has now been fixed.</li>\n<li>An edge condition in Blake2b for hashes on data with a length in the range of 2**64 - 127 to 2**64 has been identifed and fixed.</li>\n<li>The ISO Trailer for SHA512/256 used in X9.31 and ISO9796-2 signatures was incorrect. This has been fixed.</li>\n<li>The BCJSSE SSLEngine implementation now correctly wraps/unwraps application data only in whole records.</li>\n<li>The curve parameters for tc26_gost_3410_12_256_paramSetA were incorrect. These have been fixed.</li>\n<li>Further work has been done to try and prevent escaping exceptions on opening random files as BCFKS files or PKCS#12 files.</li>\n<li>An off-by-one error for the max N check for SCRYPT has been fixed. SCRYPT should now be compliant with RFC 7914.</li>\n<li>ASN1GeneralizedTime will now accept a broader range of input strings.</li>\n</ul>\n<h3>2.2.3 Additional Features and Functionality</h3>\n<ul>\n<li>GOST3410-94 private keys encoded using ASN.1 INTEGER are now accepted in private key info objects.</li>\n<li>SCRYPT is now supported as a SecretKeyFactory in the provider and in the PKCS8 APIs</li>\n<li>The BCJSSE provider now supports session resumption in clients.</li>\n<li>The BCJSSE provider now supports Server Name Indication.</li>\n<li>The BCJSSE provider now supports the jdk.tls.namedGroups system property.</li>\n<li>The BCJSSE provider now supports the org.bouncycastle.jsse.ec.disableChar2 system property, which optionally disables the use of characteristic-2 elliptic curves.</li>\n<li>EC key generation and signing now use cache-timing resistant table lookups.</li>\n<li>Performance of the DSTU algorithms has been greatly improved.</li>\n<li>Support has been added for generating certificates and signatures in the PKIX API using SHA-3 based digests.</li>\n<li>Further work has been done on improving SHA-3 performance.</li>\n<li>The organizationIdentifier (2.5.4.97) attribute has been added to BCStyle.</li>\n<li>GOST3412-2015 has been added to the JCE provider and the lightweight API.</li>\n<li>The Blake2s message digest has been added to the provider and the lightweight API.</li>\n<li>Unified Cofactor Diffie-Hellman (ECCDHU) is now supported for EC in the JCE and the lightweight API.</li>\n<li>A DEROtherInfo generator for key agreement using NewHope as the source of the shared private info has been added that can be used in conjunction with regular key agreement algorithms.</li>\n</ul>\n<h3>2.2.4 Security Related Changes and CVE's Addressed by this Release</h3>\n<ul>\n<li>CVE-2017-13098 (\"ROBOT\"), a Bleichenbacher oracle in TLS when RSA key exchange is negotiated. This potentially affected BCJSSE servers and any other TLS servers configured to use JCE for the underlying crypto - note the two TLS implementations using the BC lightweight APIs are not affected by this.</li>\n</ul>\n\n<h3>2.3.1 Version</h3>\nRelease: 1.58 <br/>\nDate:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2017, August 18\n<h3>2.3.2 Defects Fixed</h3>\n<ul>\n<li>NewHope and SPHINCS keys are now correctly created off certificates by the BC provider.</li>\n<li>Use of the seeded constructor with SecureRandom() and the BC provider in first position could cause a stack overflow error. This has been fixed.</li>\n<li>The boolean flag on ECDSAPublicKey in CVCertficate was hard coded. This has been fixed.</li>\n<li>An edge condition in IV processing for GOFB mode has been found and fixed.</li>\n<li>ANSSI named EC curves were not being recognised in PKCS#10 and certificate parsing. This has been fixed.</li>\n<li>BaseStreamCipher.engineSetMode() could sometimes throw an IllegalArgumentException rather than a NoSuchAlgorithmException. This has been fixed.</li>\n<li>Some class resolving used by the provider would fail if the BC jar was loaded on the boot class path. This has been fixed.</li>\n<li>An off-by-one range check in SM2Signer has been fixed.</li>\n<li>Retrieving an SM2 key from a certificate could result in a NullPointerException due to a problem with the curve lookup. This has been fixed.</li> \n<li>DTLS now supports records containing multiple handshake messages.</li>\n</ul>\n<h3>2.3.3 Additional Features and Functionality</h3>\n<ul>\n<li>An implementation of GOST3410-2012 has been added to light weight API and the JCA provider.</li>\n<li>Support for ECDH GOST3410-2012 and GOST3410-2001 have been added. The CMS API can also handle reading ECDH GOST3410 key transport messages.</li>\n<li>Additional mappings have been added for a range of CVC-ECDSA algorithms.</li>\n<li>XMMS and XMSSMT are now available via the BCPQC provider. Support has been added for using these keys in certificates as well.</li>\n<li>Support has been added for DSTU-7564 message digest and the DSTU-7624 ciphers, together with their associated modes.</li>\n<li>A new system property org.bouncycastle.asn1.allow_unsafe_integer has been added to allow parsing of malformed ASN.1 integers in a similar fashion to what BC 1.56 did. The default behavior remains as reject malformed integers.</li>\n<li>SignedMailValidator would only pick up the first email address in a DN, even when there was more than one. This has been fixed.</li>\n<li>PEMParser will now support a broader range of PBKDFs in encrypted private key files.</li>\n<li>Work has been done on speeding up the SHA-3 family. The functions are now 3 to 4 times faster.</li>\n<li>Some EC aliases in the provider had no corresponding implementations. These have been cleaned up.</li>\n<li>TimeStampResponses now support definite-length encoding to allow the preservation of order in certificates sets for legacy responses.</li>\n<li>The TSP API now supports SM2withSM3.</li>\n<li>The BCJSSE provider now has a FIPS mode.</li>\n<li>The BCJSSE provider now supports layered sockets.</li>\n<li>The new TLS API now has protocol/API support for the status_request extension (OCSP stapling).</li>\n<li>The new TLS API now supports RFC 7633 - X.509v3 TLS Feature Extension (e.g. \"must staple\"), enabled in default clients.</li>\n<li>TLS exceptions have been made more directly informative.</li>\n</ul>\n<h3>2.3.4 Removed Features and Functionality</h3>\n<ul>\n<li>Per RFC 7465, removed support for RC4 in the new TLS API.</li>\n<li>Per RFC 7568, removed support for SSLv3 in the new TLS API.</li>\n</ul>\n\n<h3>2.4.1 Version</h3>\nRelease: 1.57 <br/>\nDate:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2017, May 11\n<h3>2.4.2 Defects Fixed</h3>\n<ul>\n<li>A class cast exception for master certification removal in PGPPublicKey.removeCertification() by certification has been fixed.</li>\n<li>GOST GOFB 28147-89 mode had an edge condition concerning the incorrect calculation of N4 (see section 6.1 of RFC 5830) affecting about 1% of IVs. This has been fixed.</li>\n<li>The X.509 PolicyConstraints class was using implicit rather than explicit tagging for the SkipCerts field. This has been fixed.</li>\n<li>Key expiration in the OpenPGP is now calculated for ambiguous self signatures using the most recently created self-signature, in line with GPG and the recommendation in RFC 4880.</li>\n<li>Multiple validity periods in PGP keys were resolved in an adhoc fashion, in line with GPG's approach the PGP has been changed to return the most recent validity period signed.</li>\n<li>An occasional class cast exception that could occur with nested multi-parts in the S/MIME API has been fixed.</li>\n<li>A couple of bogus aliases associated AlgorithmParameters that did not resolve in the provider have been removed.</li>\n<li>The CMS API will now correctly verify PSS signatures with odd length salts.</li>\n<li>Choosing an invalid mode on a stream cipher in the JCE could result in an IllegalArgumentException. This has now been corrected to throw a NoSuchAlgorithmException.</li>\n<li>Optional parameters for ECDSA public keys in CVCertificates were hard coded to non-optional. This has been fixed.</li>\n<li>Passing a PKCS12 key to a Mac in the BC JCE always resulted in SHA-1 being used to process the password regardless of the underlying MAC algorithm. This has been fixed. An unrecognised HMAC will also now result in an exception.</li>\n<li>The Base64 encoder now explicitly validates 2 character padding as being \"==\".</li>\n<li>EC FixedPointCombMultiplier avoids 'infinity' point in lookup tables, reducing timing side-channels.</li>\n<li>Reuse of a Blake2b digest with a call to reset() rather than doFinal() could result in incorrect padding being introduced and the wrong digest result produced. This has been fixed.</li>\n</ul>\n<h3>2.4.3 Additional Features and Functionality</h3>\n<ul>\n<li>ARIA (RFC 5794) is now supported by the provider and the lightweight API.</li>\n<li>ARIA Key Wrapping (RFC 5649 style) is now supported by the provider and the lightweight API.</li>\n<li>SM2 signatures, key exchange, and public key encryption has been added to the lightweight API.</li>\n<li>XMSS has been added to the lightweight PQ API. Note: this should be treated as beta code.</li>\n<li>API support for client side EST (RFC 7030), as well as some CMC (RFC 5273) has been added to the PKIX API. A full set of ASN.1 classes for both protocols has been added as well.</li>\n<li>A test client for EST which will interop with the 7030 test server at http://testrfc7030.com/ has been added to the general test module in the current source tree.</li>\n<li>The BCJSSE provider now supports SSLContext.getDefault(), with very similar behaviour to the SunJSSE provider, including checks of the relevant javax.net.ssl.* system properties and auto-loading of jssecacerts or cacerts as the default trust store.</li>\n</ul>\n<h3>2.4.4 Security Related Changes</h3>\n<ul>\n<li>The default parameter sizes for DH and DSA are now 2048. If you have been relying on key pair generation without passing in parameters generated keys will now be larger.</li>\n<li>Further work has been done on preventing accidental re-use of a GCM cipher without first changing its key or iv.</li>\n</ul>\n\n<h3>2.5.1 Version</h3>\nRelease: 1.56 <br/>\nDate:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2016, December 23\n<h3>2.5.2 Defects Fixed</h3>\n<ul>\n<li>See section 2.1.4 for Security Defects.</li>\n<li>Using unknown status with the ASN.1 CertStatus primitive could result in an IllegalArgumentException on construction. This has been fixed.</li>\n<li>A potentional NullPointerException in a precomputation in WNafUtil has been removed.</li>\n<li>PGPUtil.getDecoderStream() would throw something other than an IOException for empty and very small data. This has been fixed.</li>\n</ul>\n<h3>2.5.3 Additional Features and Functionality</h3>\n<ul>\n<li>Support for the explicit setting of AlgorithmParameters has been added to the JceCMSContentEncryptorBuilder and the JceCMSMacCaculatorBuilder classes to allow configuration of the session cipher/MAC used.</li>\n<li>EC, ECGOST3410, and DSTU4145 Public keys are now validated on construction in the JCA/JCE and the light weight API.</li>\n<li>DSA Public keys are now validated on construction in the JCA/JCE and the light weight API.</li>\n<li>Diffie-Hellman public keys are now validated where parameters allow it.</li>\n<li>Some validations are now applied to RSA moduli and public exponents.</li>\n<li>The ASN.1 Object Identifier cache now uses a Concurrent HashMap for additional speed.</li>\n<li>AES-CCM MAC support has been added to the provider.</li>\n<li>Support for ChaCha7539 (ChaCha20 as defined in RFC 7539) and Poly1305 have been added to the provider.</li>\n<li>Support has been added for defining your own curves and making them available to the key generators and factories.</li>\n<li>Methods have been added for specifying that a PGPPublicKey/PGPPublicKeyRing is being encoded for export and trust packets are not required.</li>\n<li>Plain-ECDSA and SHA-3 support has been added to DefaultDigestAlgorithmIdentifierFinder.</li>\n<li>SHA-3 support has been added to BcDefaultDigestProvider.</li>\n<li>A higher level TLS API and JSSE provider have been added to the project.</li>\n</ul>\n<h3>2.5.4 Security Related Changes and CVE's Addressed by this Release</h3>\n<ul>\n<li>It is now possible to configure the provider to only import keys for specific named curves.</li>\n<li>Work has been done to improve the \"constant time\" behaviour of the RSA padding mechanisms.</li>\n<li>The GCM ciphers in the JCE and lightweight API will now fail if an attempt is made to use them for encryption after a doFinal or without changing the IV.</li>\n<li>The constructor for IESParameterSpec that allows the use of cipher without a nonce has been deleted. See also details for CVE-2016-1000344, CVE-2016-1000352.</li>\n<li>Strict encoding enforcement has been introduced for ASN1Integer.</li>\n<li>CVE-2016-1000338: DSA does not fully validate ASN.1 encoding of signature on verification. It is possible to inject extra elements in the sequence making up the signature and still have it validate, which in some cases may allow the introduction of \"invisible\" data into a signed structure.</li>\n<li>CVE-2016-1000339: AESFastEngine has a side channel leak if table accesses can be observed. The use of lookup large static lookup tables in AESFastEngine means that where data accesses by the CPU can be observed, it is possible to gain information about the key used to initialize the cipher. We now recommend not using AESFastEngine where this might be a concern. The BC provider is now using AESEngine by default.</li>\n<li>CVE-2016-1000340: Static ECDH vulnerable to carry propagation bug.\nCarry propagation bugs in the implementation of squaring for several raw math classes have been fixed (org.bouncycastle.math.raw.Nat???). These classes are used by our custom elliptic curve implementations (org.bouncycastle.math.ec.custom.**), so there was the possibility of rare (in general usage) spurious calculations for elliptic curve scalar multiplications. Such errors would have been detected with high probability by the output validation for our scalar multipliers.</li>\n<li>CVE-2016-1000341: DSA signature generation vulnerable to timing attack. Where timings can be closely observed for the generation of signatures, the lack of blinding in 1.55 or earlier, may allow an attacker to gain information about the signatures k value and ultimately the private value as well.</li>\n<li>CVE-2016-1000342: ECDSA does not fully validate ASN.1 encoding of signature on verification. It is possible to inject extra elements in the sequence making up the signature and still have it validate, which in some cases may allow the introduction of \"invisible\" data into a signed structure.</li>\n<li>CVE-2016-1000343: DSA key pair generator generates a weak private key if used with default values. If the JCA key pair generator is not explicitly initialised with DSA parameters, 1.55 and earlier generates a private value assuming a 1024 bit key size. In earlier releases this can be dealt with by explicitly passing parameters to the key pair generator.</li>\n<li>CVE-2016-1000344: DHIES allows the use of unsafe ECB mode. This algorithm is now removed from the provider.</li>\n<li>CVE-2016-1000345: DHIES/ECIES CBC mode vulnerable to padding oracle attack. For BC 1.55 and older, in an environment where timings can be easily observed, it is possible with enough observations to identify when the decryption is failing due to padding.</li>\n<li>CVE-2016-1000346: Other party DH public key not fully validated. This can cause issues as invalid keys can be used to reveal details about the other party's private key where static Diffie-Hellman is in use. As of this release the key parameters are checked on agreement calculation.</li>\n<li>CVE-2016-1000352: ECIES allows the use of unsafe ECB mode. This algorithm is now removed from the provider.</li>\n</ul>\n</ul>\n<h3>2.5.5 Security Advisory</h3>\n<ul>\n<li>We consider the carry propagation bugs fixed in this release to have been exploitable in previous releases (1.51-1.55), for static ECDH, to reveal the long-term key, per <a href=\"https://eprint.iacr.org/2011/633\">\"Practical realisation and elimination of an ECC-related software bug attack\", Brumley et.al.</a>. The most common case of this would be the non-ephemeral ECDH ciphersuites in TLS. These are not enabled by default in our TLS implementations, but they can be enabled explicitly by users. We recommend that users DO NOT enable static ECDH ciphersuites for TLS.</li>\n</ul>\n\n<h3>2.6.1 Version</h3>\nRelease: 1.55 <br/>\nDate:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2016, August 18\n<h3>2.6.2 Defects Fixed</h3>\n<ul>\n<li>Issues with cloning of blake digests with salts and personalisation strings have been fixed.</li>\n<li>The JceAsymmetricValueDecryptor in the CRMF package now attempts to recognise a wider range of parameters for the key wrapping algorithm, rather than relying on a default.</li>\n<li>GCM now fails if an attempt is made to go past 2^32-1 blocks.</li>\n<li>(r, k) ordering for Poly1305 has been modified to be brought into line with RFC 7539.</li>\n<li>An occasional error in Poly1305 due to sign-extension has been fixed.</li>\n<li>TimeStampRequest was always failing to validate if extensions were present. This has been fixed.</li>\n<li>ECIES/IES algorithm parameters encoding failed on default parameters. This has been fixed.</li>\n<li>PGPObjectFactory.iterator() could fail when called on data with multiple stream packets. This has been fixed.</li>\n<li>The McEliece implementation in the BCPQC provider has been revised and now has working key factories associated with it.</li>\n<li>The X.509 UserNotice class can now cope with empty sequences.</li>\n<li>Creation of multiple providers concurrently could cause issues with a non-synchronized Map in the provider. Code is now synchronized.</li>\n<li>If the lightweight OAEP encoder is fed oversized input it will now throw something more informative than an ArrayOutOfBoundsException or simply truncate.</li>\n<li>Attempting to use the PasswordRecipientInfoGenerator without explicitly setting the salt would cause a NullPointerException. This has been fixed.</li>\n<li>The BasicConstraintsValidation in the CertPath API would throw a NullPointerException on an unconstrained path length. This has been fixed.</li>\n<li>A shift error for > 24 bit numbers in TlsUtils has been fixed.</li>\n<li>OAEP encryption for a zero length message would create invalid cipher text. This has been fixed.</li>\n<li>Trying to use of non-default parameters for OAEP in CRMF would resort to the default parameter set. This has been fixed.</li>\n<li>If the BC provider was not registered, creating a CertificateFactory would cause a new provider object to be created. This has been fixed.</li>\n</ul>\n<h3>2.6.3 Additional Features and Functionality</h3>\n<ul>\n<li>The DANE API has been updated to reflect the latest standard changes.</li>\n<li>The signature algorithm SPHINCS-256 has been added to the post-quantum provider (BCPQC). Support is in place for SHA-512 and SHA3-512 (using trees based around SHA512_256 and SHA3_256 respectively).</li>\n<li>The key exchange algorithm NewHope has been added to the post-quantum provider (BCPQC). Support is in place for the regular configuration using SHA3-256 as the flattening algorithm for the agreed value.</li>\n<li>The CMS password recipient generator now allows the PRF to be changed to something other than SHA-1</li>\n<li>Direct support for the SignatureTarget packet has been added to the OpenPGP API.</li>\n<li>TLS: support for ClientHello Padding Extension (RFC 7685).</li>\n<li>TLS: support for ECDH_anon key exchange.</li>\n<li>Support has been added for HMAC SHA-3. Aliases have been added for NIST OIDs for SHA-3 HMAC as well.</li>\n<li>Support has been added for SHA-3 in DSA, ECDSA, DDSA, and ECDDSA. Aliases have been added for NIST OIDs for DSA and ECDSA as well.</li>\n<li>Support has been added for SHA-3 with RSA PKCS 1.5, PSS, and OAEP.</li>\n<li>Support has been added for GOST R 34.11-2012 to the provider and the lightweight API.</li>\n<li>PGP armored output can now be generated without a version string.</li>\n<li>The TimeStampTokenGenerator will now generate timestamps down to a millisecond resolution.</li>\n<li>Additional search methods have been added to PGP public and secret key rings.</li>\n</ul>\n\n<h3>2.7.1 Version</h3>\nRelease: 1.54 <br/>\nDate:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2015, December 29\n<h3>2.7.2 Defects Fixed</h3>\n<ul>\n<li>Blake2b-160, Blake2b-256, Blake2b-384, and Blake2b-512 are now actually in the provider and an issue with cloning Blake2b digests has been fixed.</li>\n<li>PKCS#5 Scheme 2 using DESede CBC is now supported by the PKCS#12 implementation.</li>\n<li>The IES engine would sometimes throw a \"too short\" exception on small messages which were the right length. This has been fixed.</li>\n<li>Cipher.getOutputSize() for IES ciphers would throw a ClassCastException. This has been fixed.</li>\n<li>It turns out, after advice one way and another that the NESSIE test vectors for Serpent are now what should be followed and that the vectors in the AES submission are regarded as an algorithm called Tnepres. The Serpent version now follows the NESSIE vectors, and the Tnepres cipher has been added to the provider and the lightweight API for compatibility.</li>\n<li>Problems with DTLS record-layer version handling were resolved, making version negotiation work properly.\n</ul>\n<h3>2.7.3 Additional Features and Functionality</h3>\n<ul>\n<li>Camellia and SEED key wrapping are now supported for CMS key agreement</li>\n<li>The BC TLS/DTLS code now includes a non-blocking API.</li>\n<li>CTR/SIC mode now support an internal counter. The internal counter can be turned on by passing an IV smaller than the block size of the cipher's algorithm.</li>\n<li>The lightweight CMS API operators now support CAST5 and RC2 CBC encryption.</li>\n<li>The CMS API now supports Diffie-Hellman as specified in RFC 3370.</li>\n<li>Support has been added to the CMS API for PKCS#7 ANY type encapsulated content where the encapsulated content is not an OCTET STRING.</li>\n<li>PSSSigner in the lightweight API now supports fixed salts.</li>\n</ul>\n<h3>2.7.4 Security Advisory</h3>\n<ul>\n<li>(D)TLS 1.2: Motivated by <a href=\"https://www.google.com/search?q=CVE-2015-7575\">CVE-2015-7575</a>, we have added validation that the signature algorithm received in DigitallySigned structures is actually one of those offered (in signature_algorithms extension or CertificateRequest). With our default TLS configuration, we do not believe there is an exploitable vulnerability in any earlier releases. Users that are customizing the signature_algorithms extension, or running a server supporting client authentication, are advised to double-check that they are not offering any signature algorithms involving MD5.</li>\n</ul>\n<h3>2.7.5 Notes</h3>\n<p>\nIf you have been using Serpent, you will need to either change to Tnepres, or take into account the fact that Serpent is now byte-swapped compared to what it was before.\n</p>\n\n<h3>2.8.1 Version</h3>\nRelease: 1.53 <br/>\nDate:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2015, October 10\n<h3>2.8.2 Defects Fixed</h3>\n<ul>\n<li>The BC JCE cipher implementations could sometimes fail when used in conjunction with the JSSE and NIO. This has been fixed.</li>\n<li>PGPPublicKey.getBitStrength() always returned 0 for EC keys. This has been fixed.</li>\n<li>A PKCS12 key store containing a looping certificate chain could cause an OutOfMemoryException. This has been fixed.</li>\n<li>A change in JDK 1.8 meant that X509Certificate.verify(PublicKey, Provider) would cause a stack overflow. This has been fixed.</li>\n<li>Nested multiparts with irregular post-amble could cause verification issues for the SMIMESigned classes. This has been fixed.</li>\n<li>CMSSignedData now supports verification of signed attributes where the calculated digest uses a different algorithm from the digest used in the signature.</li>\n<li>TRUSTED CERTIFICATE parsing in PEM files was ignoring the attribute block. A new class X509TrustedCertificateBlock is now returned containing both the certificate and the trust information.</li>\n<li>Adding a password to a PGP key which did not previously have one would result in an improperly formatted key. This has been fixed.</li>\n<li>ECIES/IES was only using a 4 byte label length for the MAC tag when it should have been an 8 byte one. This has now been fixed and OldECIES/OldIES has been added for backwards compatibility.</li>\n<li>The JceCRMFEncryptorBuilder was not recognising key size specific object identifiers properly. This has been fixed.</li>\n<li>The OpenPGP ClearSignedFileProcessor would not handle verification of single line files properly. This has been fixed.</li>\n<li>The BC X509Certificate class was no longer in agreement with the standard class for hashCode(). The BC X509Certificate class will now track the changes made in the standard Java distribution.</li>\n<li>PGP signature hashed sub-packets with long length encodings would fail to validate on signature checking. This has been fixed.</li>\n<li>The S/MIME API would occasionally leak InputStreams which could cause issues with custom DataSource implementations. This has been fixed.</li>\n<li>The PKCS#12 KeyStore implementation would sometimes leave orphaned chain certificates in the key store after private key deletion. This has been fixed.</li>\n<li>A bug in the DirectKeySignature OpenPGP example which could lead to extra data appearing in the signature has been fixed.</li>\n<li>Explicit configuration of a BcAsymmetricKeyWrapper with a SecureRandom was not properly propagated internally. This has been fixed.</li>\n<li>A CRL with a null certificate issuer would sometimes result in a NullPointerException during CertPathProcessing. This has been fixed.</li>\n<li>The CertPath processor would occasionally fail to match a DistributionPoint name correctly. This has been fixed.</li>\n<li>In order to avoid confusion about thread safety, BCrypt now uses a new instance for hash calculation every time it is invoked.</li>\n<li>Some decidedly odd argument casting in the PKIXCertPathValidator has been fixed to throw an InvalidAlgorithmParameterException.</li>\n<li>Presenting an empty array of certificates to the PKIXCertPathValidator would cause an IndexOutOfRangeException instead of a CertPathValidatorException. This has been fixed.</li>\n</ul>\n<h3>2.8.3 Additional Features and Functionality</h3>\n<ul>\n<li>It is now possible to specify that an unwrapped key must be usable by a software provider in the asymmetric unwrappers for CMS.</li>\n<li>A Blake2b implementation has been added to the provider and lightweight API.</li>\n<li>SHA3 has now been added to the provider and the lightweight API. SHAKE128 and SHAKE256 have also been added to the lightweight API. The original implementation of the draft standard has been renamed to Keccak.</li>\n<li>The CMS API now supports RFC 6211 for both SignedData and AuthenticatedData.</li>\n<li>The ASN.1 parser for ECGOST private keys will now parse keys encoded with a private value represented as an ASN.1 INTEGER.</li>\n<li>EAX mode and CMAC is now supported for ciphers such as SHACAL-2 and Threefish.</li>\n<li>The SM4 block cipher has been added to the provider and the lightweight API.</li>\n<li>X9.31, ISO9796/2, and PSS signature support has been added for SHA512/224, SHA512/256.</li>\n<li>SubjectPublicKeyInfoFactory now supports DSA parameters.</li>\n<li>A range of new algorithms are now support for EC key agreement.</li>\n<li>EC ContentSigners and EC ContentVerifiers have been added to the lightweight operator package in the PKIX APIs.</li>\n<li>The PKCS#12 key store will now garbage collect orphaned certificates on saving.</li>\n<li>Caching for ASN.1 ObjectIdentifiers has been rewritten to make use of an intern method. The \"usual suspects\" are now interned automatically, and the cache is used by the parser. Other OIDs can be added to the cache by calling ASN1ObjectIdentifier.intern().</li>\n</ul>\n<h3>2.8.4 Notes</h3>\n<p>\nIt turns out there was a similar, but different, issue in Crypto++ to the BC issue with ECIES. Crypto++ 6.0 now offers a corrected version of ECIES which is compatible with that which is now in BC.\n</p>\n\n<h3>2.9.1 Version</h3>\nRelease: 1.52<br/>\nDate:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2015, March 2\n<h3>2.9.2 Defects Fixed</h3>\n<ul>\n<li>GenericSigner in the lightweight API would fail if the digest started with a zero byte, occasionally causing a TLS negotiation to fail. This has been fixed.</li>\n<li>Some BC internal classes expected the BC provider to be accessible within the provider. This has been fixed.</li>\n<li>Email based policy constraints in CertPath validation did not include '@'domain.name as a possible match. This has been fixed.</li>\n<li>The Shacal2Engine would throw an ArrayIndexOutOfBoundsException if presented with input longer than a block size. This has been fixed.</li>\n<li>Using PKCS5/PKCS7 with pad values greater than 127 would result in an exception on decryption. This has been fixed.</li>\n<li>EC private key values could encode to an OCTET STRING which was shorter than that described in RFC 5915/SEC 1. This has been fixed.</li>\n<li>Providing multiple trust anchors to the CertPath validator could cause a StackOverflowError on an invalid CertPath. This has been fixed.</li>\n<li>TLS: bad-padding handling when encrypt-then-MAC enabled is now fixed.</li>\n<li>ECDH KeyAgreement.init() was not properly honoring the JCE API in respect to non-null parameters. This has been fixed.</li>\n<li>PKCS symmetric padding now takes into account pad lengths of more than 127 bytes.</li>\n<li>Corrupted input to RFC5649WrapEngine could cause an out of memory error. This has been fixed.</li>\n<li>OSGI import issues for bcmail have been fixed.</li>\n<li>A badly formed issuer in a X.509 certificate could cause a null pointer exception in X509CertificateHolder.toString(). This has been fixed.</li>\n<li>CMSSignedData.verifySignatures() could fail on a correct counter signature due to a mismatch of the SID. This has been fixed.</li>\n</ul>\n<h3>2.9.3 Additional Features and Functionality</h3>\n<ul>\n<li>The CMP support class CMPCertificate restricted the types of certificates that could be added. A more flexible method has been introduced to allow for other certificate types.</li>\n<li>Support classes have be added for DNS-based Authentication of Named Entities (DANE) to the PKIX distribution.</li>\n<li>Work has been done to reduce computation requirements for long skips associated with implementations of the SkippingCipher interface.</li>\n<li>AES GCM mode is now supported by CMS EnvelopedData.</li>\n<li>Iteration count is now settable in BcPKCS12MacCalculatorBuilder.</li>\n<li>Support for BCrypt and it's OpenBSD variant has been added to the lightweight API.</li>\n<li>It's now possible to specify the direction of the underlying cipher used for key wrapping with NIST/RFC3394 wrappers.</li>\n<li>TLS: server-side support for DHE key exchange.</li>\n<li>TLS: server-side support for PSK and SRP ciphersuites.</li>\n<li>TLS: (EC)DSA now supports signatures with non-SHA1 digests.</li>\n<li>TLS: support for ECDHE_ECDSA/AES/CCM ciphersuites from RFC 7251.</li>\n<li>Cipher.getIV() now returns nonces for AEAD modes.</li>\n<li>OIDs for dhPublicNumber and dhKeyAgreement are now supported by the provider.</li>\n<li>OIDs for several signature types using the RIPEMD family of digests have been added to the provider.</li>\n<li>JcaJceUtils.getDigestAlgName() has been added to assist in converting OIDs representing message digests into JCA algorithm names.</li>\n<li>BasicOCSPResp.getSignatureAlgorithmID() has been added to allow algorithm indentifier details to be returned from a basic OCSP response.</li>\n<li>Additional OIDs have been added for OCSP.</li>\n<li>X509CRLObject.getSignAlgName() now attempts to return an actual name, rather than an OID for, for the signature algorithm.</li>\n<li>SignedMailValidator now pays attention to the date in the PKIXParameters object if it is set.</li>\n<li>A missing signing time in a signature no longer causes SignedMailValidator to fail a signature, but provide a warning instead.</li>\n<li>An AlgorithmNameFinder implementation has been added to the PKIX API to provide \"human friendly\" translations of algorithm OIDs.</li>\n<li>Support has been added for X9.31-1998 DRBG and X9.31-1998 RSA signatures to the lightweight API and the provider.</li>\n<li>CertPath validator will now make use of the issuer key identifier and the issuer name if a key identifier is available for the issuer.</li>\n<li>Support for some JDK1.5+ language features has finally made its way into the repository.</li>\n</ul>\n<h3>2.9.4 Security Advisory</h3>\n<ul>\n<li>The CTR DRBGs would not populate some bytes in the requested block of random bytes if the size of the block requested was not an exact multiple of the block size of the underlying cipher being used in the DRBG. If you are using the CTR DRBGs with \"odd\" keysizes, we strongly advise upgrading to this release, or contacting us for a work around.</li>\n</ul>\n\n<h3>2.10.1 Version</h3>\nRelease: 1.51<br />\nDate:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2014, July 28\n<h3>2.10.2 Defects Fixed</h3>\n<ul>\n<li>The AEAD GCM AlgorithmParameters object was unable to return a GCMParameterSpec object. This has been fixed.</li>\n<li>Cipher.getIV() was returning null for AEAD mode ciphers. This has been fixed.</li>\n<li>CipherInputStream would fail for some AEAD mode ciphers if the message was over 4k in length. This has been fixed.</li>\n<li>The JCE provider will now produce simple RSAPrivateKey objects where CRT coefficients are not provided.</li>\n<li>PGP key signature certifications did not support DIRECT KEY signatures. This has been fixed.</li>\n<li>User Attribute subpackets in PGP with long length encodings could result in certification verification failing. This has been fixed.</li>\n<li>Calls to  CommandMap.setDefaultCommandMap() in the SMIME API are now wrapped in doPrivileged() blocks to allow them to work with a security manager.</li>\n<li>The encoding of the certificate_authorities field of a TLS CertificateRequest has been fixed.</li>\n<li>EC point formats are now strictly enforced in the TLS API.</li>\n<li>The provider implementation was failing to throw an exception if algorithm parameters were passed in when none were required for EC key agreement. This has been fixed.</li>\n<li>PKCS#12 files containing keys/certificates with empty attribute sets attached to them no longer cause an ArrayIndexOutOfBoundsException to be thrown.</li>\n<li>Issues with certificate verification and server side DTLS/TLS 1.2 have now been fixed.</li>\n</ul>\n<h3>2.10.3 Additional Features and Functionality</h3>\n<ul>\n<li>The range of key algorithm names that will be interpreted by KeyAgreement.generateSecret() has been expanded for ECDH derived algorithms in the provider. A KeyAgreement of ECDHwithSHA1KDF can now be explicitly created.</li>\n<li>ECIES now supports the use of IVs with the underlying block cipher and CBC mode in both the lightweight and the JCE APIs.</li>\n<li>Support has been add for RFC5649 key wrapping using AES.</li>\n<li>The PGP API now allows access and handling of User IDs as raw byte arrays, to deal with keyrings not using UTF-8.</li>\n<li>The PGP API now provides automatic conversion of embedded signatures in signature sub-packet vectors.</li>\n<li>The PGP API now fully supports ECDH as outlined in RFC 6637.</li>\n<li>GCM and GMAC now support tag lengths down to 32 bits.</li>\n<li>Custom implementations for many of the SEC Fp curves have been added, resulting in drastically improved performance. The current list includes all secp***k1 and secp***r1 curves from 192 to 521 bits. They can be accessed via the org.bouncycastle.crypto.ec.CustomNamedCurves class and are generally selected by other internal APIs in place of the generic implementations.</li>\n<li>Automatic EC point validation added, both for decoded inputs and multiplier outputs.</li>\n<li>A SkippingCipher interface has been added for ciphers that can be moved into a specific state for a given byte address. The lightweight class StreamBlockCipher has been generalised to support any BlockCipher object that can support a streaming mode.</li>\n<li>ASN.1 date/time objects now support the passing in of a Locale to allow for constructing the object using a Date interpreted from a different locale to the default for the JVM.</li>\n<li>The range of Diffie-Hellman OIDs recognised by the provider has been extended.</li>\n<li>Some utility methods for interpreting OIDs have been exposed in the JcaJceUtils class.</li>\n<li>A method has been added to CMSSignedData for replacing the OCSP responses associated with a signed message.</li>\n<li>Use of RC2/RC4 in the CMS is now provider independent.</li>\n<li>TlsInputStream now provides a means of supporting InputStream.available().</li>\n<li>Dependencies on the JCA have been removed from PGPObjectFactory.</li>\n<li>Further work has been done on improving key quality with EC and DSA algorithms.</li>\n<li>KDFCounterBytesGenerator now supports suffix and prefix fixed input data, as outlined in NIST SP 800-108.</li>\n<li>Support has been added to allow retrieval and resetting the internal state of the SHA/SHA-2 digests in the lightweight API using an encoded format.</li>\n<li>BSI plain ECDSA is now supported by the provider.</li>\n<li>The provider now advertises RSA PSS signature implementations directly using the standard naming.</li>\n<li>Full support is now provided for client-side auth in the D/TLS server code.</li>\n<li>Compatibility issues with some OSGI containers have been addressed.</li>\n</ul>\n<h3>2.10.4 Notes</h3>\n<ul>\n<li>Support for NTRUSigner has been deprecated as the algorithm has been withdrawn.</li>\n<li>Some changes have affected the return values of some methods. If you are migrating from an earlier release, it is recommended to recompile before using this release.</li>\n<li>There has been further clean out of deprecated methods in this release. If your code has previously been flagged as using a deprecated method you may need to change it. The OpenPGP API is the most heavily affected.</li>\n</ul>\n<h3>2.11.1 Version</h3>\nRelease: 1.50<br />\nDate:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2013, December 3\n<h3>2.11.2 Defects Fixed</h3>\n<ul>\n<li>The DualECSP800DRBG sometimes truncated the last block in the generated stream incorrectly. This has been fixed.</li>\n<li>Keys produced from RSA certificates with specialised parameters would lose the parameter settings. This has been fixed.</li>\n<li>OAEP parameters were being ignored on CMS key trans recipient processing. This has been fixed.</li>\n<li>OpenPGP NotationData was restricting the name and value lengths to 255 characters and truncating silently. This has been fixed.</li>\n<li>CTS mode is now in alignment with the errata for RFC 2040, as detailed in RFC 3962.</li>\n<li>Occasionally the provider implementation of DH KeyAgreement would drop a leading zero byte off the start of the shared secret (see RFC 2631 2.1.2). This has been fixed.</li>\n<li>RFC3394WrapEngine was ignoring the offset parameter inOff and using zero instead. This has been fixed.</li>\n<li>GOST keys would not encode using the CryptoPro parameter set, even if it was available. This has been fixed.</li>\n<li>The TimeStampRequest stream constructor was not setting the extensions field correctly. This has been fixed.</li>\n<li>Default RC2 parameters for 40 bit RC2 keys in CMSEnvelopedData were encoding incorrectly. This has been fixed.</li>\n<li>In case of a long hash the DSTU4145 implementation would sometimes remove one bit too much during truncation. This has been fixed.</li>\n</ul>\n<h3>2.11.3 Additional Features and Functionality</h3>\n<ul>\n<li>Additional work has been done on CMS recipient generation to simplify the generation of OAEP encrypted messages and allow for non-default parameters.</li>\n<li>OCB implementation updated to account for changes in draft-irtf-cfrg-ocb-03.</li>\n<li>RFC 6637 ECDSA and ECDH support has been added to the OpenPGP API.</li>\n<li>Implementations of Threefish and Skein have been added to the provider and the lightweight API.</li>\n<li>Implementations of the SM3 digest have been added to the provider and the lightweight API.</li>\n<li>The 3 MAC based KDF generators in NIST SP 800-108 have been added to the lightweight API.</li>\n<li>Support has been added for the GOST PKCS#5 PBKDF2 PBE function and handling of GOST PKCS#12 files.</li>\n<li>Support has been added for the CryptoPro GOST CFB mode key meshing.</li>\n<li>Implementations of XSalsa20 and ChaCha have been added. Support for reduced round Salas20 has been added.</li>\n<li>Support has been added for RFC 6979 Determinstic DSA/ECDSA to the provider and the lightweight API.</li>\n<li>Support for RC2 and RC4 in the CMS API has been generalised to work for other JCE providers.</li>\n<li>Support for the Poly1305 MAC has been added to the lightweight API and the JCE Provider.</li>\n<li>OpenSSL JcaPEMKeyConverter now supports OIDs for RSA and DSA as well as ECDSA.</li>\n<li>A simplified certificate path API has been added to the PKIX package. It is not fully NIST compliant yet, however it does provide a range of basic validations without having to use the JCA.</li>\n<li>Package version information is now included in the jar MANIFEST.MF.</li>\n<li>The JDK 1.5+ provider will now recognise and use GCMParameterSpec if it is run in a 1.7 JVM.</li>\n<li>Client side support and some server side support has been added for TLS/DTLS 1.2.</li>\n</ul>\n<h3>2.11.4 Notes</h3>\n<ul>\n<li>org.bouncycastle.crypto.DerivationFunction is now a base interface, the getDigest() method appears on DigestDerivationFunction.</li>\n<li>Recent developments at NIST indicate the SHA-3 may be changed before final standardisation. Please bare this in mind if you are using it.</li>\n<li>Other recent developments have raised concerns about the DualECDRBG. We have left the class in place for now, but it is now possible to provide your own parameter values, rather than using the NIST defined ones, if you choose to do so.</li>\n<li>Most deprecated methods have been removed from the PKIX API.</li>\n<li>As the IDEA patent has finally expired, IDEA is now supported by the standard provider.</li>\n<li>ECDH support for OpenPGP should still be regarded as experimental. It is still possible there will be compliance issues with other implementations.</li>\n</ul>\n\n<h3>2.12.1 Version</h3>\nRelease: 1.49<br />\nDate:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2013, May 31\n<h3>2.12.2 Defects Fixed</h3>\n<ul>\n<li>Occasional ArrayOutOfBounds exception in DSTU-4145 signature generation has been fixed.</li>\n<li>The handling of escaped characters in X500 names is much improved.</li>\n<li>The BC CertificateFactory no longer returns null for CertificateFactory.getCertPathEncodings().</li>\n<li>PKCS10CertificationRequestBuilder now encodes no attributes as empty by default. Encoding as absent is still available via a boolean flag.</li>\n<li>DERT61String has been reverted back to its previous implementation. A new class DERT61UTF8String has been introduced which defaults to UTF-8 encoding.</li>\n<li>OAEPEncoding could throw an array output bounds exception for small keys with large mask function digests. This has been fixed.</li>\n<li>PEMParser would throw a NullPointerException if it ran into explicit EC curve parameters, it would also throw an Exception if the named curve was not already defined. The parser now returns X9ECParmameters for explicit parameters and returns an ASN1ObjectIdentifier for a named curve.</li>\n<li>The V2TBSCertListGenerator was adding the wrong date type for CRL invalidity date extensions. This has been fixed.</li>\n</ul>\n<h3>2.12.3 Additional Features and Functionality</h3>\n<ul>\n<li>A SecretKeyFactory has been added that enables use of PBKDF2WithHmacSHA.</li>\n<li>Support has been added to PKCS12 KeyStores and PfxPdu to handle PKCS#5 encrypted private keys.</li>\n<li>Support has been added for SHA-512/224, SHA-512/256, as well as a general SHA-512/t in the lightweight API.</li>\n<li>The JcaPGPPrivateKey class has been added to provide better support in the PGP API for HSM private keys.</li>\n<li>A new KeyStore type, BKS-V1, has been added for people needing to create key stores compatible with earlier versions of Bouncy Castle.</li>\n<li>Some extra generation methods have been added to TimeStampResponseGenerator to allow more control in the generation of TimeStampResponses.</li>\n<li>It is now possible to override the SignerInfo attributes during TimeStampTokenGeneration.</li>\n<li>The TSP API now supports generation of certIDs based on digests other than SHA-1.</li>\n<li>OCSP responses can now be included in CMS SignedData objects.</li>\n<li>The SipHash MAC algorithm has been added to the lightweight API and the provider.</li>\n<li>ISO9796-2 PSS signatures can now be initialised with a signature to allow the signer to deal with odd recovered message lengths on verification.</li>\n<li>The 4 DRBGs described in NIST SP 800-90A have been added to the prng package together with SecureRandom builders.</li>\n<li>Support has been added for OCB mode in the lightweight API.</li>\n<li>DSA version 2 parameter and key generation is now supported in the provider and lightweight API.</li>\n<li>A new interface Memoable has been added for objects that can copy in and out their state. The digest classes now support this. A special\nclass NonMemoableDigest has been added which hides the Memoable interface where it should not be available.</li>\n<li>TDEA is now recognised as an alias for DESede.</li>\n<li>A new package org.bouncycastle.crypto.ec has been introduced to the light wieght API with a range of EC based cryptographic operators.</li>\n<li>The OpenPGP API now supports password changing on V3 keys if the appropriate PBEKeyEncryptor is used.</li>\n<li>The OpenPGP API now supports password changing on secret key rings where only the private keys for the subkeys have been exported.</li>\n<li>Support has been added to the lightweight API for RSA-KEM and ECIES-KEM.</li>\n<li>Support has been added for NIST SP 800-38D - GMAC to AES and other 128 bit block size algorithms.</li>\n<li>The org.bouncycastle.crypto.tls package has been extended to support client and server side TLS 1.1.</li>\n<li>The org.bouncycastle.crypto.tls package has been extended to support client and server side DTLS 1.0.</li>\n<li>A basic commitment package has been introduced into the lightweight API containing a digest based commitment scheme.</li>\n<li>It is now possible to set the NotAfter and NotBefore date in the CRMF CertificateRequestMessageBuilder class.</li>\n</ul>\n<h3>2.12.4 Notes</h3>\n<ul>\n<li>The NTRU implementation has been moved into the org.bouncycastle.pqc package hierarchy.</li>\n<li>The change to PEMParser to support explicit EC curves is not backward compatible. If you run into a named curve you need to use org.bouncycastle.asn1.x9.ECNamedCurveTable.getByOID() to look the curve up if required.</li>\n</ul>\n\n<h3>2.13.1 Version</h3>\nRelease: 1.48<br />\nDate:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2013, February 10\n<h3>2.13.2 Defects Fixed</h3>\n<ul>\n<li>Occasional key compatibility issues in IES due to variable length keys have been fixed.</li>\n<li>PEMWriter now recognises the new PKCS10CertificationRequest object.</li>\n<li>The provider implementation for RSA now resets when the init method is called.</li>\n<li>SignerInformation has been rewritten to better support signers without any associated signed attributes.</li>\n<li>An issue with an incorrect version number of SignedData associated with the use of SubjectKeyIdentifiers has now been fixed.</li>\n<li>An issue with the equals() check in BCStrictStyle has been fixed.</li>\n<li>The BC SSL implementation has been modified to deal with the \"Lucky Thirteen\" attack.</li>\n<li>A regression in 1.47 which prevented key wrapping with regular symmetric PBE algorihtms has been fixed.</li>\n</ul>\n\n<h3>2.13.3 Additional Features and Functionality</h3>\n<ul>\n<li>IES now supports auto generation of ephemeral keys in both the JCE and the lightweight APIs.</li>\n<li>A new class PEMParser has been added to return the new CertificateHolder and Request objects introduced recently.</li>\n<li>An implementation of Password Authenticated Key Exchange by Juggling (J-PAKE) has now been added to the lightweight API.</li>\n<li>Support has now been added for the DSTU-4145-2002 to the lightweight API and the provider.</li>\n<li>The BC X509Certificate implementation now provides support for the JCA methods X509Certificate.getSubjectAlternativeNames() and X509Certificate.getIssuerAlternativeNames().</li>\n<li>PEMReader can now be configured to support different providers for encyrption and public key decoding.</li>\n<li>Some extra DSA OIDs have been added to the supported list for the provider.</li>\n<li>The BC provider will now automatically try to interpret other provider software EC private keys. It is no longer necessary to use a KeyFactory for conversion.</li>\n<li>A new provider, the BCPQ (for BC Post Quantum) provider has been added with support for the Rainbow signature algorithm and the McEliece family of encryption algorithms.</li>\n<li>Support has been added for the SHA3 family of digests to both the provider and the lightweight API.</li>\n<li>T61String now uses UTF-8 encoding by default rather than a simple 8 bit transform.</li>\n</ul>\n\n<h3>2.14.1 Version</h3>\nRelease: 1.47<br/>\nDate:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2012, March 30\n<h3>2.14.2 Defects Fixed</h3>\n<ul>\n<li>OpenPGP ID based certifications now support UTF-8. Note: this may mean that some old certifications no longer validate - if this happens a retry can be added using by converting the ID using Strings.fromByteArray(Strings.toByteArray(id)) - this will strip out the top byte in each character.</li>\n<li>IPv4/IPv6 parsing in CIDR no longer assumes octet boundaries on a mask.</li>\n<li>The CRL PKIX routines will now only rebuild the CRL as a last resort when looking for the certificate issuer.</li>\n<li>The DEK-Info header in PEM generation was lower case. It is now upper case in accordance with RFC 1421.</li>\n<li>An occasional issue causing an OutOfMemoryException for PGP compressed data generation has now been fixed.</li>\n<li>An illegal argument exception that could occur with multi-valued RDNs in the X509v3CertificateBuilder has been fixed.</li>\n<li>Shared secret calculation in IES could occasionally add a leading zero byte. This has been fixed.</li>\n<li>PEMReader would choke on a private key with an empty password. This has been fixed.</li>\n<li>The default MAC for a BKS key store was 2 bytes, this has been upgraded to 20 bytes.</li>\n<li>BKS key store loading no longer freezes on negative iteration counts.</li>\n<li>A regression in 1.46 which prevented parsing of PEM files with extra text at the start has been fixed.</li>\n<li>CMS secret key generation now attempts to stop use of invalid lengths with OIDs that predefine a key length.</li>\n<li>Check of DH parameter L could reject some valid keys. This is now fixed.</li>\n</ul>\n\n<h3>2.14.3 Additional Features and Functionality</h3>\n<ul>\n<li>Support is now provided via the RepeatedKey class to enable IV only re-initialisation in the JCE layer. The same effect can be acheived in the light weight API by using null as the key parameter when creating a ParametersWithIV object.</li>\n<li>CRMF now supports empty poposkInput.</li>\n<li>The OpenPGP API now supports operator based interfaces for most operations and lightweight implementations have been added for JCE related functionality.</li>\n<li>JcaSignerId and JceRecipientId will now match on serial number, issuer, and the subject key identifier if it's available.</li>\n<li>CMS Enveloped and AuthenticatedData now support OriginatorInfo.</li>\n<li>NTRU encryption and signing is now provided in the lightweight source and the ext version of the provider.</li>\n<li>There is now API support for Extended Access Control (EAC).</li>\n<li>The performance of CertPath building and validation has been improved.</li>\n<li>The TLS Java Client API has been updated to make support for GSI GSSAPI possible.</li>\n<li>Support for ECDSA_fixed_ECDH authentication has been added to the TLS client.</li>\n<li>Support for the Features signature sub-packet has been added to the PGP API.</li>\n<li>The number of lightweight operators for PGP and CMS/SMIME has been increased.</li>\n<li>Classes involved in CRL manipulation have been rewritten to reduce memory requirements for handling and parsing extremely large CRLs.</li>\n<li>RFC 5751 changed the definition of the micalg parameters defined in RFC 3851. The SMIMESignedGenerator is now up to date with the latest micalg parameter set and a constructor has been added to allow the old micalg parameter set to be used.</li>\n<li>An operator based framework has been added for processing PKCS#8 and PKCS#12 files.</li>\n<li>The J2ME lcrypto release now includes higher level classes for handling PKCS, CMS, CRMF, CMP, EAC, OpenPGP, and certificate generation.</li>\n</ul>\n\n<h3>2.14.4 Other notes</h3>\n<p>\nOkay, so we have had to do another release. The issue we have run into is that we probably didn't go far enough in 1.46, but we are now confident that moving from this release to 2.0 should be largely just getting rid of deprecated methods. While this release does change a lot it is relatively straight forward to do a port and we have a <a href=\"http://www.bouncycastle.org/wiki/display/JA1/Porting+from+earlier+BC+releases+to+1.47+and+later\">porting guide</a> which explains the important ones. The area there has been the most change in is the ASN.1 library which was in bad need of a rewrite after 10 years of patching. On the bright side the rewrite did allow us to eliminate a few problems and bugs in the ASN.1 library, so we have some hope anyone porting to it will also have similar benefits. As with 1.46 the other point of emphasis has been making sure interface support is available for operations across the major APIs, so the lightweight API or some local role your own methods can be used instead for doing encryption and signing.\n</p>\n\n<h3>2.15.1 Version</h3>\nRelease: 1.46</br>\nDate:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2011, February 23\n<h3>2.15.2 Defects Fixed</h3>\n<ul>\n<li>An edge condition in ECDSA which could result in an invalid signature has been fixed.</li>\n<li>Exhaustive testing has been performed on the ASN.1 parser, eliminating another potential OutOfMemoryException and several escaping run time exceptions.</li>\n<li>BC generated certificates generated different hashCodes from other equivalent implementations. This has been fixed.</li>\n<li>Parsing an ESSCertIDv2 would fail if the object did not include an IssuerSerialNumber. This has been fixed.</li>\n<li>DERGeneralizedTime.getDate() would produce incorrect results for fractional seconds. This has been fixed.</li>\n<li>PSSSigner would produce incorrect results if the MGF digest and content digest were not the same. This has been fixed.</li>\n</ul>\n<h3>2.15.3 Additional Features and Functionality</h3>\n<ul>\n<li>A null genTime can be passed to TimeStampResponseGenerator.generate() to generate timeNotAvailable error responses.</li>\n<li>Support has been added for reading and writing of openssl PKCS#8 encrypted keys.</li>\n<li>New streams have been added for supporting general creation of PEM data, and allowing for estimation of output size on generation. Generators have been added for some of the standard OpenSSL objects.</li>\n<li>CRL searching for CertPath validation now supports the optional algorithm given in Section 6.3.3 of RFC 5280, allowing the latest CRL to be used for a set time providing the certificate is unexpired.</li>\n<li>AES-CMAC and DESede-CMAC have been added to the JCE provider.</li>\n<li>Support for CRMF (RFC 4211) and CMP (RFC 4210) has been added.</li>\n<li>BufferedBlockCipher will now always reset after a doFinal().</li>\n<li>Support for CMS TimeStampedData (RFC 5544) has been added.</li>\n<li>JCE EC keypairs are now serialisable.</li>\n<li>TLS now supports client-side authentication.</li>\n<li>TLS now supports compression.</li>\n<li>TLS now supports ECC cipher suites (RFC 4492).</li>\n<li>PGP public subkeys can now be separately decoded and encoded.</li>\n<li>An IV can now be passed to an ISO9797Alg3Mac.</li>\n</ul>\n<h3>2.15.4 Other notes</h3>\n<p>\nBaring security patches we expect 1.46 will be the last of the 1.* releases. The next release of\nBC will be version 2.0. For this reason a lot of things in 1.46 that relate to CMS have been deprecated and\nnew methods have been added to the CMS and certificate handling APIs which provide greater flexibility\nin how digest and signature algorithms get used. It is now possible to use the lightweight API or a simple\ncustom API with CMS and for certificate generation. In addition a lot of methods and some classes that were\ndeprecated for reasons of been confusing, or in some cases just plan wrong, have been removed. \n</p>\n<p>\nSo there are four things useful to know about this release:\n<ul>\n<li>It's not a simple drop in like previous releases, if you wish migrate to it you will need to recompile your application.</li>\n<li>If you avoid deprecated methods it should be relatively painless to move to version 2.0</li>\n<li>The X509Name class will utlimately be replacde with the X500Name class, the getInstance() methods on both these classes allow conversion from one type to another.</li>\n<li>The org.bouncycastle.cms.RecipientId class now has a collection of subclasses to allow for more specific recipient matching. If you are creating your own recipient ids you should use the constructors for the subclasses rather than relying on the set methods inherited from X509CertSelector. The dependencies on X509CertSelector and CertStore will be removed from the version 2 CMS API.</li>\n</ul>\n</p>\n<h3>2.16.1 Version</h3>\nRelease: 1.45<br/>\nDate:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2010, January 12\n<h3>2.16.2 Defects Fixed</h3>\n<ul>\n<li>OpenPGP now supports UTF-8 in file names for literal data.</li>\n<li>The ASN.1 library was losing track of the stream limit in a couple of places, leading to the potential of an OutOfMemoryError on a badly corrupted stream. This has been fixed.</li>\n<li>The provider now uses a privileged block for initialisation.</li>\n<li>JCE/JCA EC keys are now serialisable.</li>\n</ul>\n<h3>2.16.3 Additional Features and Functionality</h3>\n<ul>\n<li>Support for EC MQV has been added to the light weight API, provider, and the CMS/SMIME library.</li>\n</ul>\n<h3>2.16.4 Security Advisory</h3>\n<ul>\n<li>This version of the provider has been specifically reviewed to eliminate possible timing attacks on algorithms such as GCM and CCM mode.</li>\n</ul>\n\n<h3>2.17.1 Version</h3>\nRelease: 1.44<br/>\nDate:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2009, October 9\n<h3>2.17.2 Defects Fixed</h3>\n<ul>\n<li>The reset() method in BufferedAsymmetricBlockCipher is now fully clearing the buffer.</li>\n<li>Use of ImplicitlyCA with KeyFactory and Sun keyspec no longer causes NullPointerException.</li>\n<li>X509DefaultEntryConverter was not recognising telephone number as a PrintableString field. This has been fixed.</li>\n<li>The SecureRandom in the J2ME was not using a common seed source, which made cross seeeding of SecureRandom's impossible. This has been fixed.</li>\n<li>Occasional uses of \"private final\" on methods were causing issues with some J2ME platforms. The use of \"private final\" on methods has been removed.</li>\n<li>NONEwithDSA was not resetting correctly on verify() or sign(). This has been fixed.</li>\n<li>Fractional seconds in a GeneralisedTime were resulting in incorrect date conversions if more than 3 decimal places were included due to the Java date parser. Fractional seconds are now truncated to 3 decimal places on conversion.</li>\n<li>The micAlg in S/MIME signed messages was not always including the hash algorithm for previous signers. This has been fixed.</li>\n<li>SignedMailValidator was only including the From header and ignoring the Sender header in validating the email address. This has been fixed.</li>\n<li>The PKCS#12 keystore would throw a NullPointerException if a null password was passed in. This has been fixed.</li>\n<li>CertRepMessage.getResponse() was attempting to return the wrong underlying field in the structure. This has been fixed.</li>\n<li>PKIXCertPathReviewer.getTrustAnchor() could occasionally cause a null pointer exception or an exception due to conflicting trust anchors. This has been fixed.</li>\n<li>Handling of explicit CommandMap objects with the generation of S/MIME messages has been improved.</li>\n</ul>\n<h3>2.17.3 Additional Features and Functionality</h3>\n<ul>\n<li>PEMReader/PEMWriter now support encrypted EC keys.</li>\n<li>BC generated EC private keys now include optional fields required by OpenSSL.</li>\n<li>Support for PSS signatures has been added to CMS and S/MIME.</li>\n<li>CMS processing will attempt to recover if there is no AlgorithmParameters object for a provider and use an IvParameterSpec where possible.</li>\n<li>CertificateID always required a provider to be explicitly set. A null provider is now interpreted as a request to use the default provider.</li>\n<li>SubjectKeyIdentifier now supports both methods specified in RFC 3280, section 4.2.1.2 for generating the identifier.</li>\n<li>Performance of GCM mode has been greatly improved (on average 10x).</li>\n<li>The BC provider has been updated to support the JSSE in providing ECDH.</li>\n<li>Support for mac lengths of 96, 104, 112, and 120 bits has been added to existing support for 128 bits in GCMBlockCipher.</li>\n<li>General work has been done on trying to propagate exception causes more effectively.</li>\n<li>Support for loading GOST 34.10-2001 keys has been improved in the provider.</li>\n<li>Support for raw signatures has been extended to RSA and RSA-PSS in the provider. RSA support can be used in CMSSignedDataStreamGenerator to support signatures without signed attributes.</li>\n</ul>\n\n<h3>2.18.1 Version</h3>\nRelease: 1.43<br/>\nDate:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2009, April 13\n<h3>2.18.2 Defects Fixed</h3>\n<ul>\n<li>Multiple countersignature attributes are now correctly collected.</li>\n<li>Two bugs in HC-128 and HC-256 related to sign extension and byte swapping have been fixed. The implementations now pass the latest ecrypt vector tests.</li>\n<li>X509Name.hashCode() is now consistent with equals.</li>\n</ul>\n<h3>2.18.3 Security Advisory</h3>\n<ul>\n<li>The effect of the sign extension bug was to decrease the key space the HC-128 and HC-256 ciphers were operating in and the byte swapping inverted every 32 bits of the generated stream. If you are using either HC-128 or HC-256 you must upgrade to this release.</li>\n</ul>\n\n<h3>2.19.1 Version</h3>\nRelease: 1.42<br/>\nDate:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2009, March 16\n<h3>2.19.2 Defects Fixed</h3>\n<ul>\n<li>A NullPointer exception which could be result from generating a diffie-hellman key has been fixed.</li>\n<li>CertPath validation could occasionally mistakenly identify a delta CRL. This has been fixed.</li>\n<li>'=' inside a X509Name/X509Principal was not being properly escaped. This has been fixed.</li>\n<li>ApplicationSpecific ASN.1 tags are now recognised in BER data. The getObject() method now handles processing of arbitrary tags.</li>\n<li>X509CertStoreSelector.getInstance() was not propagating the subjectAlternativeNames attribute. This has been fixed.</li>\n<li>Use of the BC PKCS#12 implementation required the BC provider to be registered explicitly with the JCE. This has been fixed.</li>\n<li>OpenPGP now fully supports use of the Provider object.</li>\n<li>CMS now fully supports use of the Provider object.</li>\n<li>Multiplication by negative powers of two is fixed in BigInteger.</li>\n<li>OptionalValidity now encodes correctly.</li>\n</ul>\n<h3>2.19.3 Additional Features and Functionality</h3>\n<ul>\n<li>Support for NONEwithECDSA has been added.</li>\n<li>Support for Grainv1 and Grain128 has been added.</li>\n<li>Support for EAC algorithms has been added to CMS/SMIME.</li>\n<li>Support for basic CMS AuthenticatedData to the CMS package.</li>\n<li>Jars are now packaged using pack200 for JDK1.5 and JDK 1.6.</li>\n<li>ASN1Dump now supports a verbose mode for displaying the contents of octet and bit strings.</li>\n<li>Support for the SRP-6a protocol has been added to the lightweight API.</li>\n</ul>\n\n<h3>2.20.1 Version</h3>\nRelease: 1.41<br/>\nDate:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2008, October 1\n<h3>2.20.2 Defects Fixed</h3>\n<ul>\n<li>The GeneralName String constructor now supports IPv4 and IPv6 address parsing.</li>\n<li>An issue with nested-multiparts with postamble for S/MIME that was causing signatures to fail verification has been fixed.</li>\n<li>ESSCertIDv2 encoding now complies with RFC 5035.</li>\n<li>ECDSA now computes correct signatures for oversized hashes when the order of the base point is not a multiple of 8 in compliance with X9.62-2005.</li>\n<li>J2ME SecureRandom now provides additional protection against predictive and backtracking attacks when high volumes of random data are generated.</li>\n<li>Fix to regression from 1.38: PKIXCertPathCheckers were not being called on intermediate certificates.</li>\n<li>Standard name \"DiffieHellman\" is now supported in the provider.</li>\n<li>Better support for equality tests for '#' encoded entries has been added to X509Name.</li>\n</ul>\n<h3>2.20.3 Additional Features and Functionality</h3>\n<ul>\n<li>Camellia is now 12.5% faster than previously.</li>\n<li>A smaller version (around 8k compiled) of Camellia, CamelliaLightEngine has also been added.</li>\n<li>CMSSignedData generation now supports SubjectKeyIdentifier as well as use of issuer/serial.</li>\n<li>A CMSPBE key holder for UTF8 keys has been added to the CMS API.</li>\n<li>Salt and iteration count can now be recovered from PasswordRecipientInformation.</li>\n<li>Methods in the OpenPGP, CMS, and S/MIME APIs which previously could only take provider names can now take providers objects as well (JDK1.4 and greater).</li>\n<li>Support for reading and extracting personalised certificates in PGP Secret Key rings has been added.</li>\n</ul>\n\n<h3>2.21.1 Version</h3>\nRelease: 1.40<br/>\nDate:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2008, July 12\n<h3>2.21.2 Defects Fixed</h3>\n<ul>\n<li>EAX mode ciphers were not resetting correctly after a doFinal/reset. This has been fixed.</li>\n<li>The SMIME API was failing to verify doubly nested multipart objects in signatures correctly. This has been fixed.</li>\n<li>Some boolean parameters to IssuingDistributionPoint were being reversed. This has been fixed.</li>\n<li>A zero length RDN would cause an exception in an X509Name. This has been fixed.</li>\n<li>Passing a null to ExtendedPKIXParameters.setTrustedACIssuers() would cause a NullPointerException. This has been fixed.</li>\n<li>CertTemplate was incorrectly encoding issuer and subject fields when set.</li>\n<li>hashCode() for X509CertificateObject was very poor. This has been fixed.<li>\n<li>Specifying a greater than 32bit length for a stream and relying on the default BCPGOutputStream resulted in corrupted data. This has been fixed.</li>\n<li>PKCS7Padding validation would not fail if pad length was 0. This has been fixed.</li>\n<li>javax.crypto classes no longer appear in the JDK 1.3 provider jar.</li>\n<li>Signature creation time was not being properly initialised in new V4 PGP signature objects although the encoding was correct. This has been fixed.</li>\n<li>The '+' character can now be escaped or quoted in the constructor for X509Name, X509Prinicipal.</li>\n<li>Fix to regression from 1.38: PKIXCertPathValidatorResult.getPublicKey was returning the wrong public key when the BC certificate path validator was used.</li>\n</ul>\n<h3>2.21.3 Additional Features and Functionality</h3>\n<ul>\n<li>Galois/Counter Mode (GCM) has been added to the lightweight API and the JCE provider.</li>\n<li>SignedPublicKeyAndChallenge and PKCS10CertificationRequest can now take null providers if you need to fall back to the default provider mechanism.</li>\n<li>The TSP package now supports validation of responses with V2 signing certificate entries.</li>\n<li>Unnecessary local ID attributes on certificates in PKCS12 files are now automatically removed.</li>\n<li>The PKCS12 store types PKCS12-3DES-3DES and PKCS12-DEF-3DES-3DES have been added to support generation of PKCS12 files with both certificates and keys protected by 3DES.</li>\n</ul>\n<h3>2.21.4 Additional Notes</h3>\n<ul>\n<li>Due to problems for some users caused by the presence of the IDEA algorithm, an implementation is no longer included in the default signed jars. Only the providers of the form bcprov-ext-*-*.jar now include IDEA.</li>\n</ul>\n\n<h3>2.22.1 Version</h3>\nRelease: 1.39<br/>\nDate:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2008, March 29\n<h3>2.22.2 Defects Fixed</h3>\n<ul>\n<li>A bug causing the odd NullPointerException has been removed from the LocalizedMessage class.</li>\n<li>IV handling in CMS for the SEED and Camellia was incorrect. This has been fixed.</li>\n<li>ASN.1 stream parser now throws exceptions for unterminated sequences.</li>\n<li>EAX mode was not handling non-zero offsetted data correctly and failing. This has been fixed.</li>\n<li>The BC X509CertificateFactory now handles multiple certificates and CRLs in streams that don't support marking.</li>\n<li>The BC CRL implementation could lead to a NullPointer exception being thrown if critical extensions were missing. This has been fixed.</li>\n<li>Some ASN.1 structures would cause a class cast exception in AuthorityKeyIdentifier. This has been fixed.</li>\n<li>The CertID class used by the TSP library was incomplete. This has been fixed.</li>\n<li>A system property check in PKCS1Encoding to cause a AccessControlException under some circumstances. This has been fixed.</li>\n<li>A decoding issue with a mis-identified tagged object in CertRepMessage has been fixed.</li>\n<li>\\# is now properly recognised in the X509Name class.</li>\n</ul>\n<h3>2.22.3 Additional Features and Functionality</h3>\n<ul>\n<li>Certifications associated with user attributes can now be created, verified and removed in OpenPGP.</li>\n<li>API support now exists for CMS countersignature reading and production.</li>\n<li>The TSP package now supports parsing of responses with V2 signing certificate entries.</li>\n<li>Lazy evaluation of DER sequences has been introduced to ASN1InputStream to allow support for larger sequences.</li>\n<li>KeyPurposeId class has been updated for RFC 4945.</li>\n<li>CertPath processing has been further extended to encompass the NIST CertPath evaluation suite.</li>\n<li>Initial support has been added for HP_CERTIFICATE_REQUEST in the TLS API.</li>\n<li>Providers for JDK 1.4 and up now use SignatureSpi directly rather than extending Signature. This is more in track with the way dynamic provider selection now works.</li>\n<li>PGP example programs now handle blank names in literal data objects.</li>\n<li>The ProofOfPossession class now better supports the underlying ASN.1 structure.</li>\n<li>Support has been added to the provider for the VMPC MAC.</li>\n</ul>\n<h3>2.23.1 Version</h3>\nRelease: 1.38<br/>\nDate:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2007, November 7\n<h3>2.23.2 Defects Fixed</h3>\n<ul>\n<li>SMIME signatures containing non-standard quote-printable data could be altered by SMIME encryption. This has been fixed.</li>\n<li>CMS signatures that do not use signed attributes were vulnerable to one of Bleichenbacher's RSA signature forgery attacks. This has been fixed.</li>\n<li>The SMIMESignedParser(Part) constructor was not producing a content body part that cleared itself after writeTo() as indicated in the JavaDoc. This has been fixed.</li>\n<li>BCPGInputStream now handles data blocks in the 2**31->2**32-1 range.</li>\n<li>A bug causing second and later encrypted objects to be ignored in KeyBasedFileProcessor example has been fixed.</li>\n<li>Value of the TstInfo.Tsa field is now directly accessible from TimeStampTokenInfo.</li>\n<li>Generating an ECGOST-3410 key using an ECGenParameterSpec could cause a ClassCastException in the key generator. This has been fixed.</li>\n<li>Use of the parameters J and L in connection with Diffie-Hellman parameters in the light weight API was ambiguous and confusing. This has been dealt with.</li>\n<li>Some entities were not fully removed from a PKCS#12 file when deleted due to case issues. This has been fixed.</li>\n<li>Overwriting entities in a PKCS#12 file was not fully compliant with the JavaDoc for KeyStore. This has been fixed.</li>\n<li>TlsInputStream.read() could appear to return end of file when end of file had not been reached. This has been fixed.</li>\n</ul>\n<h3>2.23.3 Additional Features and Functionality</h3>\n<ul>\n<li>Buffering in the streaming CMS has been reworked. Throughput is now usually higher and the behaviour is more predictable.</li>\n<li>It's now possible to pass a table of hashes to a CMS detached signature rather than having to always pass the data.</li>\n<li>Classes supporting signature policy and signer attributes have been added to the ASN.1 ESS/ESF packages.</li>\n<li>Further work has been done on optimising memory usage in ASN1InputStream. In some cases memory usage has been reduced to 25% of previous.</li>\n<li>Pre-existing signers can now be added to the SMIMESignedGenerator.</li>\n<li>Support has been added to the provider for the VMPC stream cipher.</li>\n<li>CertPathReviewer has better handling for problem trust anchors.</li>\n<li>Base64 encoder now does initial size calculations to try to improve resource usage.</li>\n</ul>\n<h3>2.24.1 Version</h3>\nRelease: 1.37<br/>\nDate:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2007, June 15\n<h3>2.24.2 Defects Fixed</h3>\n<ul>\n<li>The ClearSignedFileProcessor example for OpenPGP did not take into account trailing white space in\nthe file to be signed. This has been fixed.</li>\n<li>A possible infinite loop in the CertPathBuilder and SignedMailValidator have been removed.</li>\n<li>Requesting DES, DESede, or Blowfish keys using regular Diffie-Hellman now returns the same length keys as the regular JCE provider.</li>\n<li>Some uncompressed EC certificates were being interpreted as compressed and causing an exception. This has been fixed.</li>\n<li>Adding a CRL with no revocations on it to the CRL generator could cause an exception to be thrown. This has been fixed.</li>\n<li>Using the default JDK provider with the CMS library would cause exceptions in some circumstances. This has been fixed.</li>\n<li>BC provider DSAKeys are now serializable.</li>\n<li>Using only a non-sha digest in S/MIME signed data would produce a corrupt MIME header. This has been fixed.</li>\n<li>The default private key length in the lightweght API for generated DiffieHellman parameters was absurdly small, this has been fixed.</li>\n<li>Cipher.getParameters() for PBEwithSHAAndTwofish-CBC was returning null after intialisation. This has been fixed.</li>\n</ul>\n<h3>2.24.3 Additional Features and Functionality</h3>\n<ul>\n<li>The block cipher mode CCM has been added to the provider and light weight API.</li>\n<li>The block cipher mode EAX has been added to the provider and light weight API.</li>\n<li>The stream cipher HC-128 and HC-256 has been added to the provider and lightwieght API.</li>\n<li>The stream cipher ISAAC has been added to the lightweight API.</li>\n<li>Support for producing and parsing notation data signature subpackets has been added to OpenPGP.</li>\n<li>Support for implicit tagging has been added to DERApplicationSpecific.</li>\n<li>CMS better supports basic Sun provider.</li>\n<li>A full set of SEC-2 EC curves is now provided in the SEC lookup table.</li>\n<li>Specifying a null provider in CMS now always uses the default provider, rather than causing an exception.</li>\n<li>Support has been added to the OpenPGP API for parsing experimental signatures</li>\n<li>CertPath validator now handles inherited DSA parameters and a wider range of name constraints.</li>\n<li>Further work has been done on improving the performance of ECDSA - it is now about two to six times faster depending on the curve.</li>\n<li>The Noekeon block cipher has been added to the provider and the lightweight API.</li>\n<li>Certificate generation now supports generation of certificates with an empty Subject if the subjectAlternativeName extension is present.</li>\n<li>The JCE provider now supports RIPEMD160withECDSA.</li>\n</ul>\n\n<h3>2.25.1 Version</h3>\nRelease: 1.36<br/>\nDate:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2007, March 16\n<h3>2.25.2 Defects Fixed</h3>\n<ul>\n<li>DSA key generator now checks range and keysize.</li>\n<li>Class loader issues with i18n classes should now be fixed.</li>\n<li>X.500 name serial number value now output as unambiguous long form SERIALNUMBER</li>\n<li>The fix for multipart messages with mixed content-transfer-encoding in 1.35 caused a\nregression for processing some messages with embedded multiparts that contained blank lines of preamble text - this should now be fixed.</li>\n<li>Another regression which sometimes affected the SMIMESignedParser has also been fixed.</li>\n<li>SharedFileInputStream compatibility issues with JavaMail 1.4 have been addressed.</li>\n<li>JDK 1.5 and later KeyFactory now accepts ECPublicKey/ECPrivateKey to translateKey.</li>\n<li>JDK 1.5 and later KeyFactory now produces ECPublicKeySpec/ECPrivateKeySpec on getKeySpec.</li>\n<li>Some surrogate pairs were not assembled correctly by the UTF8 decoder. This has been fixed.</li>\n<li>Alias resolution in PKCS#12 is now case insensitive.</li>\n</ul>\n<h3>2.25.3 Additional Features and Functionality</h3>\n<ul>\n<li>CMS/SMIME now supports basic EC KeyAgreement with X9.63.</li>\n<li>CMS/SMIME now supports RFC 3211 password based encryption.</li>\n<li>Support has been added for certificate, CRL, and certification request generation for the regular SHA algorithms with RSA-PSS.</li>\n<li>Further work has been done in speeding up prime number generation in the lightweight BigInteger class.</li>\n<li>Support for the SEED algorithm has been added to the provider and the lightweight API.</li>\n<li>Support for the Salsa20 algorithm has been added to the provider and the lightweight API.</li>\n<li>CMS/SMIME now support SEED and Camellia</li>\n<li>A table of TeleTrusT curves has been added.</li>\n<li>CMSSignedData creation and Collection CertStore now preserves the order of certificates/CRls if the backing collection is ordered.</li>\n<li>CMS Signed objects now use BER encoding for sets containing certificates and CRLs, allowing specific ordering to be specified for the objects contained.</li>\n<li>CMS enveloped now works around providers which throw UnsupportedOperationException if key wrap is attempted.</li>\n<li>DSASigner now handles long messages. SHA2 family digest support for DSA has been added to the provider.</li>\n</ul>\n\n<h3>2.26.1 Version</h3>\nRelease: 1.35<br/>\nDate:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2006, December 16\n<h3>2.26.2 Defects Fixed</h3>\n<ul>\n<li>Test data files are no longer in the provider jars.</li>\n<li>SMIMESignedParser now handles indefinite length data in SignerInfos.</li>\n<li>Under some circumstances the SMIME library was failing to canonicalize mixed-multipart data correctly. This has been fixed.</li>\n<li>The l parameter was being ignored for the DH and ElGamal key generation. This has been fixed.</li>\n<li>The ASN1Sequence constructor for OtherRecipientInfo was broken. It has been fixed</li>\n<li>Regression - DN fields SerialNumber and Country were changed to encode as UTF8String in 1.34 in the X509DefaultEntryConverter, these now encode as PrintableString.</li>\n<li>CMSSignedData.replaceSigners() was not replacing the digest set as well as the signers. This has been fixed.</li>\n<li>DERGeneralizedTime produced a time string without a GMT offset if they represented local time. This has been fixed.</li>\n<li>Some temp files were still being left on Windows by the SMIME library. All of the known problems have been fixed.</li>\n<li>Comparing ASN.1 object for equality would fail in some circumstances. This has been fixed.\n<li>The IESEngine could incorrectly encrypt data when used in block cipher mode. This has been fixed.\n<li>An error in the encoding of the KEKRecipientInfo has been fixed. Compatability warning: this may mean that versions of BC mail prior to 1.35 will have trouble processing KEK messages produced by 1.35 or later.\n</ul>\n<h3>2.26.3 Additional Features and Functionality</h3>\n<ul>\n<li>Further optimisations to elliptic curve math libraries.</li>\n<li>API now incorporates a CertStore which should be suitable for use with LDAP.</li>\n<li>The streaming ASN.1 API is now integrated into the base one, the sasn1 package has been deprecated.</li>\n<li>The OpenPGP implementation now supports SHA-224 and BZIP2.</li>\n<li>The OpenPGP implementation now supports SHA-1 checksumming on secret keys.</li>\n<li>The JCE provider now does RSA blinding by default.</li>\n<li>CMSSignedDataParser now provides methods for replacing signers and replacing certificates and CRLs.</li>\n<li>A generic store API has been added to support CRLs, Certificates and Attribute certificates.</li>\n<li>The CMS/SMIME API now supports inclusion and retrieval of version 2 attribute certificates.</li>\n<li>Support for generating CertificationRequests and Certificates has been added for GOST-3410-2001 (ECGOST)</li>\n<li>CMS/SMIME now support ECGOST</li>\n<li>Basic BER Octet Strings now encode in a canonical fashion by default.</li>\n<li>DERUTCTime can now return Date objects</li>\n<li>Validating constructors have been added to DERPrintableString, DERIA5String, and DERNumericString.</li>\n<li>A lightweight API for supporting TLS has been added.</li>\n<li>Implementations of the TEA and XTEA ciphers have been added to the light weight API and the provider.</li>\n<li>PEMReader now supports OpenSSL ECDSA key pairs.</li>\n<li>PGP packet streams can now be closed off using close() on the returned stream as well as closing the generator.</li>\n</ul>\n<h3>2.27.1 Version</h3>\nRelease: 1.34<br/>\nDate:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2006, October 2\n<h3>2.27.2 Defects Fixed</h3>\n<ul>\n<li>Endianess of integer conversion in KDF2BytesGenerator was incorrect. This has been fixed.\n<li>Generating critical signature subpackets in OpenPGP would result in a zero packet tag. This has been fixed.\n<li>Some flags in PKIFailure info were incorrect, and the range of values was incomplete. The range of values has been increased and the flags corrected.\n<li>The helper class for AuthorityKeyExtension generation was including the subject rather than the issuer DN of the CA certificate. This has been fixed.\n<li>SMIMESignedParser now avoids JavaMail quoted-printable recoding issue.\n<li>Verification of RSA signatures done with keys with public exponents of 3 was vunerable to\nBleichenbacher's RSA signature forgery attack. This has been fixed.\n<li>PGP Identity strings were only being interpreted as ASCII rather than UTF8. This has been fixed.\n<li>CertificateFactory.generateCRLs now returns a Collection rather than null.\n</ul>\n<h3>2.27.3 Additional Features and Functionality</h3>\n<ul>\n<li>An ISO18033KDFParameters class had been added to support ISO18033 KDF generators.\n<li>An implemention of the KDF1 bytes generator algorithm has been added.\n<li>An implementation of NaccacheStern encryption has been added to the lightweight API.\n<li>X509V2CRLGenerator can now be loaded from an existing CRL.\n<li>The CMS enveloped data generators will now attempt to use the default provider for encryption if the passed in provider can only handle key exchange.\n<li>OpenPGP file processing has been substantially speeded up.\n<li>The PKCS1Encoder would accept PKCS1 packets which were one byte oversize. By default this will now cause an error. However, as there are still implementations which still produce such packets the older behaviour can be turned on by setting the VM system property org.bouncycastle.pkcs1.strict to false before creating an RSA cipher using PKCS1 encoding.\n<li>A target has been added to the bc-build.xml to zip up the source code rather than leaving it in a directory tree.\nThe build scripts now run this target by default.\n<li>Use of toUpperCase and toLowerCase has been replaced with a locale independent converter where appropriate.\n<li>Support for retrieving the issuers of indirect CRLs has been added.\n<li>Classes for doing incremental path validation of PKIX cert paths have been added to the X.509 package and S/MIME.\n<li>Locale issues with String.toUpperCase() have now been worked around.\n<li>Optional limiting has been added to ASN1InputStream to avoid possible OutOfMemoryErrors on corrupted streams.\n<li>Support has been added for SHA224withECDSA, SHA256withECDSA, SHA384withECDSA, and SHA512withECDSA for the generation of signatures, certificates, CRLs, and certification requests.\n<li>Performance of the prime number generation in the BigInteger library has been further improved.\n<li>In line with RFC 3280 section 4.1.2.4 DN's are now encoded using UTF8String by default rather than PrintableString.\n</ul>\n<h3>2.27.4 Security Advisory</h3>\n<ul>\n<li>If you are using public exponents with the value three you *must* upgrade to this release, otherwise it\nwill be possible for attackers to exploit some of Bleichenbacher's RSA signature forgery attacks on your applications.</li>\n</ul>\n<h3>2.28.1 Version</h3>\nRelease: 1.33<br/>\nDate:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2006, May 3\n<h3>2.28.2 Defects Fixed</h3>\n<ul>\n<li>OCSPResponseData was including the default version in its encoding. This has been fixed.\n<li>BasicOCSPResp.getVersion() would throw a NullPointer exception if called on a default version response. This has been fixed.\n<li>Addition of an EC point under Fp could result in an ArithmeticException. This has been fixed.\n<li>The n value for prime192v2 was incorrect. This has been fixed.\n<li>ArmoredInputStream was not closing the underlying stream on close. This has been fixed.\n<li>Small base64 encoded strings with embedded white space could decode incorrectly using the Base64 class. This has been fixed.\n</ul>\n<h3>2.28.3 Additional Features and Functionality</h3>\n<ul>\n<li>The X509V2CRLGenerator now supports adding general extensions to CRL entries.\n<li>A RoleSyntax implementation has been added to the x509 ASN.1 package, and the AttributeCertificateHolder class now support the IssuerSerial option.\n<li>The CMS API now correctly recognises the OIW OID for DSA with SHA-1.\n<li>DERUTF8String now supports surrogate pairs.\n</ul>\n\n<h3>2.29.1 Version</h3>\nRelease: 1.32<br/>\nDate:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2006, March 27\n<h3>2.29.2 Defects Fixed</h3>\n<ul>\n<li>Further work has been done on RFC 3280 compliance.\n<li>The ASN1Sequence constructor for SemanticsInformation would sometimes throw a ClassCastException on reconstruction an object from a byte stream. This has been fixed.\n<li>The SharedInputStream.read(buf, 0, len) method would return 0 at EOF, rather than -1. This has been fixed.\n<li>X9FieldElement could fail to encode a Fp field element correctly. This has been fixed.\n<li>The streaming S/MIME API was occasionally leaving temporary files around. The SIMEUtil class responsible for creating the files now returns a FileBackedMimeBodyPart object\nwhich has a dispose method on it which should allow removal of the file backing the body part.\n<li>An encoding defect in EnvelopedData generation in the CMS streaming, S/MIME API has been fixed.\n<li>DER constructed octet strings could cause exceptions in the streaming ASN.1 library. This has been fixed.\n<li>Several compatibility issues connected with EnvelopedData decoding between the streaming CMS library and other libraries have been fixed.\n<li>JDK 1.4 and earlier would sometimes encode named curve parameters explicitly. This has been fixed.\n<li>An incorrect header for SHA-256 OpenPGP clear text signatures has been fixed.\n<li>An occasional bug that could result in invalid clear text signatures has been fixed.\n<li>OpenPGP clear text signatures containing '\\r' as line separators were not being correctly canonicalized. This has been fixed.\n</ul>\n\n<h3>2.29.3 Additional Features and Functionality</h3>\n<ul>\n<li>The ASN.1 library now includes classes for the ICAO Electronic Passport.\n<li>Support has been added to CMS and S/MIME for ECDSA.\n<li>Support has been added for the SEC/NIST elliptic curves.\n<li>Support has been added for elliptic curves over F2m.\n<li>Support has been added for repeated attributes in CMS and S/MIME messages.\n<li>A wider range of RSA-PSS signature types is now supported for CRL and Certificate verification.\n</ul>\n<h3>2.29.4 Possible compatibility issue</h3>\n<ul>\n<li>Previously elliptic curve keys and points were generated with point compression enabled by default.\nOwing to patent issues in some jurisdictions, they are now generated with point compression disabled by default.\n</ul>\n\n<h3>2.30.1 Version</h3>\nRelease: 1.31<br/>\nDate:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2005, December 29\n<h3>2.30.2 Defects Fixed</h3>\n<ul>\n<li>getCriticalExtensionOIDs on an X.509 attribute certificate was returning the non-critical set. This has been fixed.\n<li>Encoding uncompressed ECDSA keys could occasionally introduce an extra leading zero byte. This has been fixed.\n<li>Expiry times for OpenPGP master keys are now recognised across the range of possible certifications.\n<li>PGP 2 keys can now be decrypted by the the OpenPGP library.\n<li>PGP 2 signature packets threw an exception on trailer processing. This has been been fixed.\n<li>Attempting to retrieve signature subpackets from an OpenPGP version 3 signature would throw a null pointer exception. This has been fixed.\n<li>Another occasional defect in EC point encoding has been fixed.\n<li>In some cases AttributeCertificateHolder.getIssuer() would return an empty array for attribute certificates using the BaseCertificateID.\nThis has been fixed.\n<li>OIDs with extremely large components would sometimes reencode with unnecessary bytes in their encoding. The optimal DER encoding will now be produced instead.\n</ul>\n<h3>2.30.3 Additional Features and Functionality</h3>\n<ul>\n<li>The SMIME package now supports the large file streaming model as well.\n<li>Additional ASN.1 message support has been added for RFC 3739 in the org.bouncycastle.x509.qualified package.\n<li>Support has been added for Mac algorithm 3 from ISO 9797 to both the lightweight APIs and the provider.\n<li>The provider now supports the DESEDE64 MAC algorithm.\n<li>CertPathValidator has been updated to better support path validation as defined in RFC 3280.\n</ul>\n\n<h3>2.31.1 Version</h3>\nRelease: 1.30<br/>\nDate:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2005, September 18\n<h3>2.31.2 Defects Fixed</h3>\n<ul>\n<li>Whirlpool was calculating the wrong digest for 31 byte data and could throw an exception for some other data lengths. This has been fixed.\n<li>AlgorithmParameters for IVs were returning a default of RAW encoding of the parameters when they should have been returning an\nASN.1 encoding. This has been fixed.\n<li>Base64 encoded streams without armoring could cause an exception in PGPUtil.getDecoderStream(). This has been fixed.\n<li>PGPSecretKey.copyWithNewPassword() would incorrectly tag sub keys. This has been fixed.\n<li>PGPSecretKey.copyWithNewPassword() would not handle the NULL algorithm. This has been fixed.\n<li>Directly accessing the dates on an X.509 Attribute Certificate constructed from an InputStream would return null, not the date objects. This has been fixed.\n<li>KEKIdentifier would not handle OtherKeyAttribute objects correctly. This has been fixed.\n<li>GetCertificateChain on a PKCS12 keystore would return a single certificate chain rather than null if the alias passed in represented a certificate not a key. This has been fixed.\n</ul>\n<h3>2.31.3 Additional Features and Functionality</h3>\n<ul>\n<li>RSAEngine no longer assumes keys are byte aligned when checking for out of range input.\n<li>PGPSecretKeyRing.removeSecretKey and PGPSecretKeyRing.insertSecretKey have been added.\n<li>There is now a getter for the serial number on TimeStampTokenInfo.\n<li>Classes for dealing with CMS objects in a streaming fashion have been added to the CMS package.\n<li>PGPCompressedDataGenerator now supports partial packets on output.\n<li>OpenPGP Signature generation and verification now supports SHA-256, SHA-384, and SHA-512.\n<li>Both the lightweight API and the provider now support the Camellia encryption algorithm.\n</ul>\n\n<h3>2.32.1 Version</h3>\nRelease: 1.29<br/>\nDate:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2005, June 27\n<h3>2.32.2 Defects Fixed</h3>\n<ul>\n<li>HMac-SHA384 and HMac-SHA512 were not IETF compliant. This has been fixed.\n<li>The equals() method on ElGamalKeyParameters and DHKeyParameters in the lightweight API would sometimes\nreturn false when it should return true. This has been fixed.\n<li>Parse error for OpenSSL style PEM encoded certificate requests in the PEMReader has been fixed.\n<li>PGPPublicKey.getValidDays() now checks for the relevant signature for version 4 and later keys as well as using the\nversion 3 key valid days field.\n<li>ISO9796 signatures for full recovered messsages could incorrectly verify for similar messages in some circumstances. This has been fixed.\n<li>The occasional problem with decrypting PGP messages containing compressed streams now appears to be fixed.\n</ul>\n<h3>2.32.3 Additional Features and Functionality</h3>\n<ul>\n<li>Support has been added for the OIDs and key generation required for HMac-SHA224, HMac-SHA256, HMac-SHA384, and \nHMac-SHA512.\n<li>SignerInformation will used default implementation of message digest if signature provider doesn't support it.\n<li>The provider and the lightweight API now support the GOST-28147-94 MAC algorithm.\n<li>Headers are now settable for PGP armored output streams.\n</ul>\n<h3>2.32.4 Notes</h3>\n<ul>\n<li>The old versions of HMac-SHA384 and HMac-SHA512 can be invoked as OldHMacSHA384 and OldHMacSHA512, or by using the OldHMac class in the\nlightweight API.\n</ul> \n<h3>2.33.1 Version</h3>\nRelease: 1.28<br/>\nDate:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2005, April 20\n<h3>2.33.2 Defects Fixed</h3>\n<ul>\n<li>Signatures on binary encoded S/MIME messages could fail to validate when correct. This has been fixed.\n<li>getExtensionValue() on CRL Entries were returning the encoding of the inner object, rather than the octet string. This has been fixed.\n<li>CertPath implementation now returns an immutable list for a certificate path.\n<li>Generic sorting now takes place in the CertificateFactory.generateCertPath() rather than CertPathValidator.\n<li>DERGeneralizedTime can now handle time strings with milli-seconds.\n<li>Stateful CertPathCheckers were not being initialised in all cases, by the CertPathValidator. This has been fixed.\n<li>PGPUtil file processing methods were failing to close files after processing. This has been fixed.\n<li>A disordered set in a CMS signature could cause a CMS signature to fail to validate when it should. This has been fixed.\n<li>PKCS12 files where both the local key id and friendly name were set on a certificate would not parse correctly. This has been fixed.\n<li>Filetype for S/MIME compressed messages was incorrect. This has been fixed.\n<li>BigInteger class can now create negative numbers from byte arrays.\n</ul>\n<h3>2.33.3 Additional Features and Functionality</h3>\n<ul>\n<li>S/MIME now does canonicalization on non-binary input for signatures.\n<li>Micalgs for the new SHA schemes are now supported.\n<li>Provided and lightweight API now support ISO 7816-4 padding.\n<li>The S/MIME API now directly supports the creation of certificate management messages.\n<li>The provider and the light weight API now support the cipher GOST-28147, the signature algorithms GOST-3410 (GOST-3410 94) and EC GOST-3410 (GOST-3410 2001), the message digest GOST-3411 and the GOST OFB mode (use GOFB).\n<li>CMSSignedDataGenerator will used default implementation of message digest if signature provider doesn't support it.\n<li>Support has been added for the creation of ECDSA certificate requests.\n<li>The provider and the light weight API now support the WHIRLPOOL message digest.\n</ul>\n<h3>2.33.4 Notes</h3>\n<ul>\n<li>Patches for S/MIME binary signatures and canonicalization were actually applied in 1.27, but a couple of days after the release - if the class \nCMSProcessableBodyPartOutbound is present in the package org.bouncycastle.mail.smime you have the patched 1.27. We would recommend upgrading to 1.28 in any case\nas some S/MIME 3.1 recommendations have also been introduced for header creation.\n<li>GOST private keys are probably not encoding correctly and can be expected to change.\n</ul>\n<h3>2.34.1 Version</h3>\nRelease: 1.27<br/>\nDate:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2005, February 20\n<h3>2.34.2 Defects Fixed</h3>\n<ul>\n<li>Typos in the provider which pointed Signature algorithms SHA256WithRSA, SHA256WithRSAEncryption, SHA384WithRSA, SHA384WithRSAEncryption, SHA512WithRSA, and SHA512WithRSAEncryption at the PSS versions of the algorithms have been fixed. The correct names for the PSS algorithms are SHA256withRSAandMGF1, SHA384withRSAandMGF1, and SHA512withRSAandMGF1.\n<li>X509CertificateFactory failed under some circumstances to reset properly if the input stream being passed\nto generateCertificate(s)() changed, This has been fixed.\n<li>OpenPGP BitStrength for DSA keys was being calculated from the key's generator rather than prime. This has been fixed.\n<li>Possible infinite loop in ASN.1 SET sorting has been removed.\n<li>SHA512withRSAandMGF1 with a zero length salt would cause an exception if used with a 1024 bit RSA key. This has been fixed.\n<li>Adding an Exporter to a PGPSubpacketVector added a Revocable instead. This has been fixed.\n<li>AttributeCertificateIssuer.getPrincipal() could throw an ArrayStoreException. This has been fixed.\n<li>CertPathValidator now guarantees to call any CertPathCheckers passed in for each certificate.\n<li>TSP TimeStampToken was failing to validate time stamp tokens with the issuerSerial field set in the ESSCertID structure. This has been fixed.\n<li>Path validation in environments with frequently updated CRLs could occasionally reject a valid path. This has been fixed.\n</ul>\n<h3>2.34.3 Additional Features and Functionality</h3>\n<ul>\n<li>Full support has been added for the OAEPParameterSpec class to the JDK 1.5 povider.\n<li>Full support has been added for the PSSParameterSpec class to the JDK 1.4 and JDK 1.5 providers.\n<li>Support for PKCS1 signatures for SHA-256, SHA-384, and SHA-512 has been added to CMS.\n<li>PGPKeyRingCollection classes now support partial matching of user ID strings.\n<li>This release disables the quick check on the IV for a PGP public key encrypted message in order to help\nprevent applications being vunerable to oracle attacks.\n<li>The CertPath support classes now support PKCS #7 encoding.\n<li>Point compression can now be turned off when encoding elliptic curve keys.\n</ul>\n<h3>2.34.4 Changes that may affect compatibility</h3>\n<ul>\n<li>org.bouncycastle.jce.interfaces.ElGamalKey.getParams() has been changed to getParameters() to avoid clashes with\na JCE interface with the same method signature.\n<li>org.bouncycastle.jce.interfaces.ECKey.getParams() has been changed in JDK 1.5 to getParameters() to avoid clashes\nwith a JCE interface with the same method signature. The getParams() method in pre-1.5 has been deprecated.\n<li>SHA256WithRSAEncryption, SHA384WithRSAEncryption, SHA512WithRSAEncryption now refer to their PKCS #1 V1.5 implementations. If you\nwere using these previously you should use SHA256WithRSAAndMGF1, SHA384WithRSAAndMGF1, or SHA512WithRSAAndMGF1.\n</ul>\n<h3>2.35.1 Version</h3>\nRelease: 1.26<br/>\nDate:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2005, January 15\n<h3>2.35.2 Defects Fixed</h3>\n<ul>\n<li>The X.509 class UserNotice assumed some of the optional fields were not optional. This has been fixed.\n<li>BCPGInputStream would break on input packets of 8274 bytes in length. This has been fixed.\n<li>Public key fingerprints for PGP version 3 keys are now correctly calculated.\n<li>ISO9796-2 PSS would sometimes throw an exception on a correct signature. This has been fixed.\n<li>ASN1Sets now properly sort their contents when created from scratch.\n<li>A bug introduced in the CertPath validation in the last release which meant some certificate paths would validate if they were invalid has been fixed.\n</ul>\n<h3>2.35.3 Additional Features and Functionality</h3>\n<ul>\n<li>Support for JDK 1.5 naming conventions for OAEP encryption and PSS signing has been added.\n<li>Support for Time Stamp Protocol (RFC 3161) has been added.\n<li>Support for Mozilla's PublicKeyAndChallenge key certification message has been added.\n<li>OpenPGP now supports key rings containing GNU_DUMMY_S2K.\n<li>Support for the new versions (JDK 1.4 and later) of PBEKeySpec has been added to the providers.\n<li>PBEWithMD5AndRC2, PBEWithSHA1AndRC2 now generate keys rather than exceptions.\n<li>The BigInteger implementation has been further optimised to take more advantage of the Montgomery number capabilities.\n</ul>\n<h3>2.35.4 JDK 1.5 Changes</h3>\n<ul>\n<li>The JDK 1.5 version of the provider now supports the new Elliptic Curve classes found in the java.security packages. Note: while we have tried to preserve some backwards compatibility people using Elliptic curve are likely to find some minor code changes are required when moving code from JDK 1.4 to JDK 1.5 as the java.security APIs have changed.\n</ul>\n\n<h3>2.36.1 Version</h3>\nRelease: 1.25<br/>\nDate:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2004, October 1\n<h3>2.36.2 Defects Fixed</h3>\n<ul>\n<li>In some situations OpenPGP would overread when a stream had been\nbroken up into partial blocks. This has been fixed.\n<li>Explicitly setting a key size for RC4 in the CMS library would cause\nan exception. This has been fixed.\n<li>getSignatures() on PGPPublicKey would throw a ClassCastException in some cases. This has been fixed.\n<li>Encapsulated signed data was been generated with the wrong mime headers, this has been fixed.\n<li>The isSignature method on PGPSecretKey now correctly identifies signing keys.\n<li>An interoperability issue with DH key exchange between the Sun JCE provider and the BC provider, concerning sign bit expansion, has been fixed. \n<li>The X509CertificateFactory would fail to reset correctly after reading an ASN.1 certificate chain. This has been fixed.\n<li>CertPathValidator now handles unsorted lists of certs.\n<li>The PGPSignatureGenerator would sometimes throw an exception when adding hashed subpackets. This has been fixed.\n<li>Ordered equality in X509Name was not terminating as early as possible. This has been fixed.\n<li>getBitStrength for PGPPublicKeys was returning the wrong value for ElGamal keys. This has been fixed.\n<li>getKeyExpirationTime/getSignatureExpirationTime was returning a Date rather than a delta. This isn't meaningful as a Date and has been changed to a long.\n<li>the crlIssuer field in DistributionPoint name was encoding/decoding incorrectly. This has been fixed.\n<li>X509Name now recognises international characters in the input string and\nstores them as BMP strings.\n<li>Parsing a message with a zero length body with SMIMESigned would cause an exception. This has been fixed.\n<li>Some versions of PGP use zeros in the data stream rather than a replication of the last two bytes of the iv as specified in the RFC to determine if the correct decryption key has been found. The decryption classes will now cope with both.\n</ul>\n<h3>2.36.3 Additional Features and Functionality</h3>\n<ul>\n<li>Support for extracting signatures based on PGP user attributes has been\nadded to PGPPublicKey.\n<li>BCPGArmoredInputStream should cope with plain text files better.\n<li>The OpenPGP library can now create indefinite length streams and handle packets greater than (2^32 - 1) in length.\n<li>Direct support for adding SignerUserID and PrimaryUserID has been added to the PGPSignatureSubpacketGenerator.\n<li>Support for ISO-9796-2/PSS has been added to the lightweight API.\n<li>API support for extracting recovered messages from signatures that support\nmessage recovery has been added to the lightweight API.\n<li>String value conversion in a DN being processed by X509Name is now fully\nconfigurable.\n<li>It is now possible to create new versions of CMSSignedData objects without\nhaving to convert the original object down to its base ASN.1 equivalents.\n<li>Support for adding PGP revocations and other key signatures has been added.\n<li>Support for SHA-224 and SHA224withRSA has been added.\n<li>Trailing bit complement (TBC) padding has been added.\n<li>OID components of up to 2^63 bits are now supported.\n</ul>\n<h3>2.37.1 Version</h3>\nRelease: 1.24<br/>\nDate:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2004, June 12\n<h3>2.37.2 Defects Fixed</h3>\n<ul>\n<li>OpenPGP Secret key rings now parse key rings with user attribute packets in them correctly.\n<li>OpenPGP Secret key rings now parse key rings with GPG comment packets in them.\n<li>X509Name and X509Principal now correctly handle BitStrings.\n<li>OpenPGP now correctly recognises RSA signature only keys.\n<li>When re-encoding PGP public keys taken off secret keys getEncoded would\nsometimes throw a NullPointerException. This has been fixed.\n<li>A basic PKCS12 file with a single key and certificate, but no attributes, would cause a null pointer exception. This has been fixed.\n<li>Signature verification now handles signatures where the parameters block is missing rather than NULL.\n<li>Lightweight CBCBlockCipherMac was failing to add padding if padding was\nbeing explicitly provided and data length was a multiple of the block size. This has been fixed.\n<li>ZIP compression in PGP was failing to compress data in many cases. This has been fixed.\n<li>Signatures were occasionally produced with incorrect padding in their associated bit strings, this has been fixed.\n<li>An encoding error introduced in 1.23 which affected generation of the\nKeyUsage extension has been fixed.\n</ul>\n<h3>2.37.3 Additional Features and Functionality</h3>\n<ul>\n<li>PKCS12 keystore now handles single key/certificate files without any attributes present.\n<li>Support for creation of PGPKeyRings incorporating sub keys has been added.\n<li>ZeroPadding for encrypting ASCII data has been added.\n</ul>\n<h3>2.38.1 Version</h3>\nRelease: 1.23<br/>\nDate:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2004, April 10\n<h3>2.38.2 Defects Fixed</h3>\n<ul>\n<li>Reading a PGP Secret key file would sometimes cause a class cast exception. This has been fixed.\n<li>PGP will now read SecretKeys which are encrypted with the null algorithm.\n<li>PGP ObjectFactory will recognise Marker packets.\n<li>BasicConstraints class now handles default empty sequences correctly.\n<li>S2K Secret Key generation now supported in OpenPGP for keys greater than 160 bits, a bug causing\nit to occasionally generate the wrong key has been fixed.\n<li>OpenPGP implementation can now read PGP 8 keys.\n<li>Decoding issues with Secret Sub Keys should now be fixed.\n<li>PGP would occasionally unpack ElGamal encrypted data incorrectly, this has been fixed.\n<li>OCSP TBSRequest now uses abbreviated encoding if the default version is used.\n<li>X509Name class will now print names with nested pairs in component sets correctly.\n<li>RC4 now resets correctly on doFinal.\n</ul>\n<h3>2.38.3 Additional Features and Functionality</h3>\n<ul>\n<li>PGP V3 keys and V3 signature generation is now supported.\n<li>Collection classes have been added for representing files of PGP public and secret keys.\n<li>PEMReader now supports \"RSA PUBLIC KEY\".\n<li>RipeMD256 and RipeMD320 have been added.\n<li>Heuristic decoder stream has been added to OpenPGP which \"guesses\" how the input is\nconstructed.\n<li>ArmoredInputStream now recognises clear text signed files.\n<li>ArmoredOutputStream now provides support for generating clear text signed files.\n<li>Support has been added to CMS for RipeMD128, RipeMD160, and RipeMD256.\n<li>Support for generating certification directly and editing PGP public key\ncertifications has been added.\n<li>Support has been added for modification detection codes to the PGP library.\n<li>Examples have been rewritten to take advantage of the above.\n<li>SMIMESigned can now covert data straight into a mime message.\n<li>DERGeneralizedTime getTime() method now handles a broader range of input strings.\n</ul>\n\n<h3>2.39.1 Version</h3>\nRelease: 1.22<br/>\nDate:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2004, February 7\n<h3>2.39.2 Defects Fixed</h3>\n<ul>\n<li>Generating DSA signatures with PGP would cause a class cast exception, this has been fixed.\n<li>PGP Data in the 192 to 8383 byte length would sometimes be written with the wrong length header. This has been fixed.\n<li>The certificate factory would only parse the first certificate in a PKCS7 object. This has been fixed.\n<li>getRevocationReason() in RevokedStatus in OCSP would throw an exception for\na non-null reason, rather than a null one. This has been fixed.\n<li>PSS signature verification would fail approximately 0.5 % of the time on correct signatures. This has been fixed.\n<li>Encoding of CRL Distribution Points now always works.\n</ul>\n<h3>2.39.3 Additional Features and Functionality</h3>\n<ul>\n<li>Additional methods for getting public key information have been added to the PGP package.\n<li>Some support for user attributes and the image attribute tag has been added.\n<li>Support for the AuthorityInformationAccess extension has been added.\n<li>Support for ElGamal encryption/decryption has been added to the PGP package.\n</ul>\n\n<h3>2.40.1 Version</h3>\nRelease: 1.21<br/>\nDate:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2003, December 6\n<h3>2.40.2 Defects Fixed</h3>\n<ul>\n<li>The CertPath validator would fail for some valid CRLs. This has been  fixed.\n<li>AES OIDS for S/MIME were still incorrect, this has been fixed.\n<li>The CertPathBuilder would sometimes throw a NullPointerException looking for an issuer. This has been fixed.\n<li>The J2ME BigInteger class would sometimes go into an infinite loop generating prime numbers. This has been fixed.\n<li>DERBMPString.equals() would throw a class cast exception. This has been fixed.\n</ul>\n<h3>2.40.3 Additional Features and Functionality</h3>\n<ul>\n<li>PEMReader now handles public keys.\n<li>OpenPGP/BCPG should now handle partial input streams. Additional methods for reading subpackets off signatures.\n<li>The ASN.1 library now supports policy qualifiers and policy info objects.\n</ul>\n\n<h3>2.41.1 Version</h3>\nRelease: 1.20<br/>\nDate:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2003, October 8\n<h3>2.41.2 Defects Fixed</h3>\n<ul>\n<li>BigInteger toString() in J2ME/JDK1.0 now produces same output as the Sun one.\n<li>RSA would throw a NullPointer exception with doFinal without arguments. This has been fixed.\n<li>OCSP CertificateID would calculate wrong issuer hash if issuer cert was not self signed. This has been fixed.\n<li>Most of response generation in OCSP was broken. This has been fixed.\n<li>The CertPath builder would sometimes go into an infinite loop on some chains if the trust anchor was missing. This has been fixed.\n<li>AES OIDS were incorrect, this has been fixed.\n<li>In some cases BC generated private keys would not work with the JSSE. This has been fixed.\n</ul>\n<h3>2.41.3 Additional Features and Functionality</h3>\n<ul>\n<li>Support for reading/writing OpenPGP public/private keys and OpenPGP signatures has been added.\n<li>Support for generating OpenPGP PBE messages and public key encrypted messages has been added.\n<li>Support for decrypting OpenPGP messages has been added.\n<li>Addition of a Null block cipher to the light weight API.\n</ul>\n\n<h3>2.42.1 Version</h3>\nRelease: 1.19<br/>\nDate:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2003, June 7\n<h3>2.42.2 Defects Fixed</h3>\n<ul>\n<li>The PKCS12 store would throw an exception reading PFX files that had attributes with no values. This has been fixed.\n<li>RSA Private Keys would not serialise if they had PKCS12 bag attributes attached to them, this has been fixed.\n<li>GeneralName was encoding OtherName as explicitly tagged, rather than implicitly tagged. This has been fixed.\n<li>ASN1 parser would sometimes mistake an implicit null for an implicit empty\nsequence. This has been fixed.\n</ul>\n<h3>2.42.3 Additional Features and Functionality</h3>\n<ul>\n<li>S/MIME and CMS now support the draft standard for AES encryption.\n<li>S/MIME and CMS now support setable key sizes for the standard algorithms.\n<li>S/MIME and CMS now handle ARC4/RC4 encrypted messages.\n<li>The CertPath validator now passes the NIST test suite.\n<li>A basic OCSP implementation has been added which includes request generation\nand the processing of responses. Response generation is also provided, but should be treated as alpha quality code.\n<li>CMS now attempts to use JCA naming conventions in addition to the OID name\nin order to find algorithms.\n</ul>\n\n<h3>2.43.1 Version</h3>\nRelease: 1.18<br/>\nDate:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2003, February 8\n<h3>2.43.2 Defects Fixed</h3>\n<ul>\n<li>DESKeySpec.isParityAdjusted in the clean room JCE could go into an\ninfinite loop. This has been fixed.\n<li>The SMIME API would end up throwing a class cast exception if a\nMimeBodyPart was passed in containing a MimeMultipart. This is now fixed.\n<li>ASN1InputStream could go into an infinite loop reading a truncated\ninput stream. This has been fixed.\n<li>Seeding with longs in the SecureRandom for the J2ME and JDK 1.0,\nonly used 4 bytes of the seed value. This has been fixed.\n</ul>\n<h3>2.43.3 Additional Features and Functionality</h3>\n<ul>\n<li>The X.509 OID for RSA is now recognised by the provider as is the OID for RSA/OAEP.\n<li>Default iv's for DES are now handled correctly in CMS.\n<li>The ASN.1 classes have been updated to use the generic ASN1* classes where\npossible.\n<li>A constructor has been added to SMIMESigned to simplify the processing\nof \"application/pkcs7-mime; smime-type=signed-data;\" signatures.\n<li>Diffie-Hellman key generation is now faster in environments using the\nSun BigInteger library.\n</ul>\n<h3>2.44.1 Version</h3>\nRelease: 1.17<br/>\nDate:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2003, January 8\n<h3>2.44.2 Defects Fixed</h3>\n<ul>\n<li>Reuse of an CMSSignedObject could occasionally result in a class\ncast exception. This has been fixed.\n<li>The X.509 DistributionPointName occasionally encoded incorrectly. This has\nbeen fixed.\n<li>BasicConstraints construction would break if an ASN.1 sequence was used\nwith only the required parameter. This has been fixed.\n<li>The DERObject constructor in OriginatorIdentifierOrKey was leaving \nthe id field as null. This has been fixed.\n</ul>\n<h3>2.44.3 Additional Functionality and Features</h3>\n<ul>\n<li>RC2 now supports the full range of parameter versions and effective\nkey sizes.\n<li>CompressedData handling has been added to CMS/SMIME.\n<li>The 1.4 version now allows X500Principles to be generated directly\nfrom CRLs.\n<li>SMIME objects now support binary encoding. The number of signature\ntypes recognised has been increased. \n<li>CMS can create signed objects with encapsulated data. Note: while\nthis was been done we realised we could simplify things, we did and\nfor the most part people won't notice, other than the occasional\nreference to CMSSignable will need to be replaced with CMSProcessable.\n<li>X509Name and X509Principal now support forward and reverse X509Name\nto string conversion, with changeable lookup tables for converting OIDs\ninto strings. Both classes also now allow the direction of encoding to\nbe set when a string is converted as well as changeable lookup tables for\nstring to OID conversion.\n</ul>\n\n<h3>2.45.1 Version</h3>\nRelease: 1.16<br/>\nDate:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2002, November 30\n<h3>2.45.2 Defects Fixed</h3>\n<ul>\n<li>CRLS were only working for UTC time constructed Time objects, this has\nbeen fixed.\n<li>KeyUsage and ReasonFlags sometimes encoded longer than necessary. This\nhas been fixed.\n<li>BER encoded sets are now recognised and dealt with.\n<li>Encoding issues in CMS which were causing problems with backwards\ncompatibility with older CMS/SMIME clients have been fixed.\n<li>KeyFactory now allows for creation of RSAKey*Spec classes.\n<li>The X509CertSelector in the clean room CertPath API is now less likely\nto throw a NullPointerException at the wrong time.\n<li>Macs now clone correctly in the clean room JCE.\n</ul>\n<h3>2.45.3 Additional Functionality and Features</h3>\n<ul>\n<li>PGPCFB support has been added to the provider and the lightweight API.\n<li>There are now three versions of the AESEngine, all faster than before,\nwith the largest footprint one being the fastest. The JCE AES now refers\nto the fastest.\n<li>The 1.4 version of the library now allows for X500Principals to be\ngenerated directly from certificates.\n<li>X509Name has been extended to parse numeric oids, \"oid.\" oids, and to\nrecognise the LDAP UID.\n<li>Immutable sequences and sets have been introduced to the ASN.1 package.\n<li>The SMIME/CMS ASN.1 base classes have been rewritten to reduce the\nsize of the package for use with the lightweight API.\n<li>The SMIME/CMS api's have been rewritten to allow them to take advantage\nof the Cert Path API, remove code suited to inclusion in the provider,\nand to support multiple recipients/signers.\n</ul>\n<h3>2.46.1 Version</h3>\nRelease: 1.15<br/>\nDate:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2002, September 6\n<h3>2.46.2 Defects Fixed</h3>\n<ul>\n<li>The base string for the oids in asn1.x509.KeyPurposeId was incorrect. This\nhas been fixed.\n<li>MimeBodyParts in the SMIME Generator did not have their Content-Type\nproperly set up after decryption. This has been fixed.\n<li>If a X.509 certificate did not have all the keyUsage extension bits set,\nthe provider wasn't padding the return value of the key usage extension to\n8 booleans in length. This has been fixed.\n<li>In some cases the simple BC keystore allowed overwriting of an alias with\none of the same name. This has been fixed.\n<li>The key schedule for RC5-64 was not always being calculated correctly. This\nhas been fixed.\n<li>On reset buffered blockcipher was only partially erasing the previous buffer. This has been fixed.\n<li>All lightweight mac classes now do a reset on doFinal.\n<li>ASN.1 object identifiers wouldn't encode the first byte correctly if the\nOID started with 2 and the second number was greater than 47. This has been\nfixed.\n<li>If a key had PKCS9 attributes associated with it on storage they took\nprecedence over the local alias used to add the key to the PKCS12 key store.\nThe local name now takes precedence.\n<li>ReasonFlags now correctly encodes.\n</ul>\n<h3>2.46.3 Additional Functionality and Features</h3>\n<ul>\n<li>The PKCS12 key store now handles key bags in encryptedData bags.\n<li>The X509NameTokenizer now handles for '\\' and '\"' characters.\n<li>SMIME v2 compliance has been added. Use setVersion(2) in the generator classes.\n<li>The ASN.1 library now supports ENUMERATED, UniversalString and the X.509 library support for CRLs now includes CRLReason, and some elements of CertificatePolicies.\n<li>Both the provider and the lightweight library now support a basic SIC mode for block ciphers.\n</ul>\n<h3>2.47.1 Version</h3>\nRelease: 1.14<br/>\nDate:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2002, June 17\n<h3>2.47.2 Defects Fixed</h3>\n<ul>\n<li>there was a bug in the BigInteger right shifting for > 31 bit shifts.\nThis has been fixed.\n<li>x509 name had it's equality test based on the order of the directory\nelements, this has been fixed.\n<li>the mode used with the RSA cipher in KeyTransRecipientInfoParser in\nthe smime implementation was not compatible with the Sun JCE.\nThis has been fixed.\n<li>PKCS7 SignedData now supports single length signing chains.\n<li>When a root certificate had a different issuer id from the subject id, or\nhad it's own AuthorityKeyExtension the PKCS12 key store would drop the root\ncertificate from the certificate chain. This has been fixed.\n<li>The PKCS10 CertificationRequestInfo class always expected at least one\nattribute. This has been fixed.\n<li>UTF8 strings are now correctly recognised.\n<li>The Tiger implementation was producing results in reverse byte\norder for each of the 3 words making up the digest. This has been fixed.\n<li>asn1.x509.ExtendedKeyUsage used to through a null pointer exception\non construction. This has been fixed.\n</ul>\n<h3>2.47.3 Additional Functionality and Features</h3>\n<ul>\n<li>The BigInteger library now uses Montgomery numbers for modPow and is\nsubstantially faster.\n<li>SMIMECapabilities, and SMIMEEncryptionKeyPreference attributes added to S/MIME.\n<li>Increased range of key sizes available in S/MIME.\n<li>getInstance(ASN1TaggedObject, boolean) methods have been added to most ASN1 types.\nThese deal with implicit/explicit tagging ambiguities with constructed types.\n<li>Added EncryptedPrivateKeyInfo object to the clean room JCE.\n<li>A PEMReader has been added for handling some of the openSSL PEM files.\n<li>The X.509 certificate factory supports a wider range of encodings and\nobject identifiers.\n</ul>\n<h3>2.48.1 Version</h3>\nRelease: 1.13<br/>\nDate:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2002, April 19\n<h3>2.48.2 Defects Fixed</h3>\n<ul>\n    <li>The TBSCertificate object in the ASN.1 library now properly implements\n    the Time object, rather returning UTC time.\n    <li>The DESedeKeyGenerator now supports 112 and 168 bit key generation.\n    <li>Certificates with the keyId set to null in the AuthorityKeyIdentifier extensions would sometimes cause the PKCS12 store to throw a NullPointer exception. This has been fixed.\n    <li>toByteArray in the big integer class was not always producing correct\n    results for negative numbers. This has been Fixed.\n</ul>\n\n<h3>2.48.3 Additional Functionality and Features</h3>\n<ul>\n    <li>The key to keySpec handling of the secret key factories has been improved.\n    <li>There is now a SMIME implementation and a more complete CMS\n        implementation (see CONTRIBUTORS file for additonal details).\n    <li>A CertPath implementation that runs under jdk1.1 and jdk1.4 has also\n    being contributed. A work around to allow it to be used with jdk1.2 and\n    jdk1.3 has also been added. Note: the implementation is not quite complete\n    because policymapping, name and subtree constraints are not yet\n    implemented.\n    <li>The API now supports the generation of PKCS7 signed objects. Note: this\n    is still beta code - one known issue is that it doesn't support single\n    length certificate chains for signing keys.\n</ul>\n\n<h3>2.49.1 Version</h3>\nRelease: 1.12<br/>\nDate:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2002, February 8\n<h3>2.49.2 Defects Fixed</h3>\n<ul>\n    <li>The ASN.1 library was unable to read an empty set object. This has been fixed.\n    <li>Returning sets of critical and non-critical extensions on X.509 certificates could result in a null pointer exception if the certificate had no extensions. This has been fixed.\n    <li>The BC JKS implementation does not follow the conventional one - it has been renamed BKS, an attempt to create a JKS keystore using the BC provider will now result in an exception.\n    <li>The PKCS 10 generator verify(provider) method was ignoring the provider when generating the public key. This has been fixed.\n    <li>The PKCS12 store would throw an OutOfMemoryException if passed a non-PKCS12 file. This has been fixed.\n    <li>In the case where there was no AuthorityKeyIdentifier the PKCS12 store\n    would fail to find certificates further up the signing chain. The store now\n    uses the IssuerDN if no AuthorityKeyIdentifier is specified and the IssuerDN\n    is different from the SubjectDN,\n    <li>PKCS10/CertificationRequestInfo objects with only a single attribute wer\n    not being handled properly. This has been fixed.\n    <li>getExtensionValue for X.509 CRLs was returning the value of the\n    DER-Encoded octet string not the DER-Encoded octet string as required. This\n    has been fixed.\n    <li>the IV algorithm parameters class would improperly throw an exception\n    on initialisation. This has been fixed.\n</ul>\n<h3>2.49.3 Additional Functionality and Features</h3>\n<ul>\n    <li>The AESWrap ciphers will now take IV's.\n    <li>The DES-EDEWrap algorithm described in http://www.ietf.org/internet-drafts/draft-ietf-smime-key-wrap-01.txt is now supported.\n    <li>Support for the ExtendedKeyUsageExtension and the KeyPurposeId has been added.\n    <li>The OID based alias for DSA has been added to the JCE provider.\n    <li>BC key stores now implement the BCKeyStore interface so you can provide your own source of randomness to a key store.\n    <li>The ASN.1 library now supports GeneralizedTime.\n    <li>HMACSHA256, HMACSHA384, and HMACSHA512 are now added.\n    <li>PSS has been added to the JCE, PSS and ISO9796 signers in the lightweight api have been rewritten so they can be used incrementally. SHA256withRSA, SHA384withRSA, and SHA512withRSA have been added.\n    <li>Base support for CMS (RFC 2630) is now provided (see CONTRIBUTORS file\n    for details).\n</ul>\n<h3>2.50.1 Version</h3>\nRelease: 1.11<br/>\nDate:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2001, December 10\n<h3>2.50.2 Defects Fixed</h3>\n<ul>\n<li>X9.23 padding of MACs now works correctly with block size aligned data.\n<li>Loading a corrupted \"UBER\" key store would occasionally cause the\nappearance of hanging. This has been fixed.\n<li>Loading a PKCS12 store where not all certificates had PKCS9 attributes\nassigned to them would cause a NullPointerException. This has been fixed.\n<li>The PKCS12 store wasn't correctly recovering certificate chains of\nlength less than 2 on calling the getCertificateChain method. This has been\nfixed.\n<li>Lone certificates were not been stored in the PKCS12 store. This has been fixed.\n<li>CFB and OFB modes weren't padding iv's more than 1 byte less than the \nblock size of the cipher if the mode was reused with a shorter IV. This has\nbeen fixed.\n<li>IV handling and block size return values for CFB and OFB modes wasn't being handled in the same way as the Sun reference implementation. This has been fixed.\n<li>CertificateInfoRequests were not handling null attributes correctly. This\nhas been fixed.\n<li>Tags for the X.509 GeneralName structure were wrongly encoded. This has been\nfixed.\n<li>getExtensionValue for X.509 certificates was returning the value of the\nDER-Encoded octet string not the DER-Encoded octet string as required. This has\nbeen fixed.\n<li>reset on the version 3 X.509 certificate generator was not flushing the\nextensions. This has been fixed.\n<li>The NetscapeCert type bits were reversed! This has been fixed.\n</ul>\n<h3>2.50.3 Additional Functionality and Features</h3>\n<ul>\n<li>The lightweight API and the JCE provider now support ElGamal.\n<li>X509Principal, and X509Name now supports the \"DC\" attribute and the\ncreation of directory names from vectors.\n<li>RSA-PSS signature padding has been added to the lightweight API.\n<li>EC Public/Private keys are now encoded in accordance with SEC 1. The library\nwill still read older keys as well.\n<li>Added PKCS12-DEF a pkcs12 based key store which works around a bug in\nthe Sun keytool - it always uses the default provider for creating certificates.\n<li>A cut down version of the Rijndael has been added that provides the functionality required to conform the the AES. It is designed to fully support FIPS-197. A fips AES wrapper (AESWrap in the JCE, AESWrapEngine in the lightweight library has also been added).\n<li>Elliptic curve routines now handle uncompressed points as well as the\ncompressed ones.\n</ul>\n<h3>2.50.4 Other changes</h3>\n<ul>\n<li>As the range of public key types supported has expanded the getPublicKey\nmethod on the SubjectPublicKeyInfo class is not always going to work. The\nmore generic method getPublicKeyData has been added and getPublicKey now\nthrows an IOException if there is a problem.\n</ul>\n<h3>2.51.1 Version</h3>\nRelease: 1.10<br/>\nDate:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2001, October 20\n<h3>2.51.2 Defects Fixed</h3>\n<ul>\n<li>The PKCS12 Key Store now interoperates with the JDK key tool. <b>Note:</b> this does mean the the key name passed to the setKeyEntry calls has become\nsignificant.\n<li>The \"int\" constructor for DERInteger only supported ints up to 128. This\nhas been fixed.\n<li>The ASN.1 input streams now handle zero-tagged zero length objects correctly.\n</ul>\n<h3>2.51.3 Additional Functionality and Features</h3>\n<ul>\n<li>The JCE Provider and the lightweight API now support Serpent, CAST5, and CAST6.\n<li>The JCE provider and the lightweight API now has an implementation of ECIES.\n<b>Note:</b> this is based on a draft, don't use it for anything that needs to\nbe kept long term as it may be adjusted.\n<li>Further work has been done on performance - mainly in the symmetric ciphers.\n<li>Support for the generation of PKCS10 certification requests has been added.\n</ul>\n<h3>2.52.1 Version</h3>\nRelease: 1.09<br/>\nDate:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2001, October 6\n<h3>2.52.2 Defects Fixed</h3>\n<ul>\n<li>failure to pass in an RC5 parameters object now results in an exception\nat the upper level of the JCE, rather than falling over in the lightweight\nlibrary.\n<li>ISO10126Padding now incorporates the correct amount of random data.\n<li>The PKCS12 key store wasn't picking up certificate chains properly\nwhen being used to write PKCS12 files. This has been fixed.\n<li>The Twofish engine would call System.exit if the key was too large.\nThis has been fixed.\n<li>In some cases the ASN.1 library wouldn't handle implicit tagging properly.\nThis has been fixed.\n</ul>\n<h3>2.52.3 Additional Functionality and Features</h3>\n<ul>\n<li>Support for RC5-64 has been added to the JCE.\n<li>ISO9796-2 signatures have been added to the JCE and lightweight API.\n<li>A more general paddings packge for use with MACs and block ciphers had been aded to the lightweight API. MACs now allow you to specify padding.\n<li>X9.23 Padding has been added to the JCE and lightwieght API. The old\nPaddedBlockCipher class is now deprecated see org.bouncycastle.crypto.paddings for details.\n<li>SHA-256, SHA-384, and SHA-512 are now added. Note: while the public review\nperiod has finished, these algorithms have not yet been standardised, in the\nevent that final standardisation changes the algorithms these implementations\nwill be changed.\n<li>It's now possible to set bag attributes on items to go into a PKCS12 store,\nusing the org.bouncycastle.jce.interfaces.PKCS12BagAttributeCarrier interface.\n<li>More classses have been added to the ASN.1 package for dealing with\ncertificate extensions and CRLs including a CRL generator. Note: the\nCRL generators should be regarded as under development and subject to change.\n<li>There's now an examples package for the JCE (in addition to the examples\nin org.bouncycastle.jce.provider.test) - org.bouncycastle.jce.examples. It\ncurrently consists of a class showing how to generate a PKCS12 file.\n<li>The X.509 CertificateFactory now includes CRL support.  DER or PEM CRLs may be processed.\n<li>The BigInteger library has been written with a view to making it less\nresource hungry and faster - whether it's fast enough remains to be seen!\n</ul>\n\n<h3>2.53.1 Version</h3>\nRelease: 1.08<br/>\nDate:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2001, September 9\n<h3>2.53.2 Defects Fixed</h3>\n<ul>\n<li>It wasn't possible to specify an ordering for distinguished names in\nX509 certificates. This is now supported.\n<li>In some circumstances stream Ciphers in the JCE would cause null pointer\nexceptions on doFinal. This has been fixed.\n<li>Unpadded ciphers would sometimes buffer the last block of input, even\nif it could be processed. This has been fixed.\n<li>The netscape certificate request class wouldn't compile under JDK 1.1. This\nhas been fixed.\n</ul>\n<h3>2.53.3 Additional Functionality and Features</h3>\n<ul>\n<li>ISO 9796-1 padding is now supported with RSA in the lightweight\nAPI and the JCE.\n<li>support classes have been added for reading and writing PKCS 12 files,\nincluding a keystore for the JCA.\n<li>The message digests MD4, Tiger, and RIPEMD128 have been added to the\nJCE and the lightweight API. Note: MD4 and RIPEMD128 have been added for\ncompatibility purposes only - we recommend you don't use them for anything new!\n<li>The JDK 1.1 certificate classes didn't conform to the JDK 1.2 API as\nthe collections class was not present. Thanks to a donated collections API\nthis is fixed.\n</ul>\n<h3>2.54.1 Version</h3>\nRelease: 1.07<br/>\nDate:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2001, July 9\n<h3>2.54.2 Defects Fixed</h3>\n<ul>\n<li>It turned out that the setOddParity method in the DESParameter class\nwas indeed doing something odd but not what was intended. This is now\nfixed. <b>Note:</b>This will affect some PBE encryptions that were carried\nout with DES, equivalent PBE ciphers to the old PBE DES cipher can be\naccessed by prepending the work \"Broken\" in front of the original PBE cipher\ncall. If you want an example of how to deal with this as a migration issue\nhave a look in org.bouncycastle.jce.provider.JDKKeyStore lines 201-291.\n</ul>\n<h3>2.55.1 Version</h3>\nRelease: 1.06<br/>\nDate:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2001, July 2\n<h3>2.55.2 Defects Fixed</h3>\n<ul>\n<li>Diffie-Hellman keys are now properly serialisable as well as\nencodable.\n<li>Three of the semi-weak keys in the DESParameters, and the DESKeySpec look\nup table, were incorrect. This has been fixed.\n<li>DESEDE key generators now accept 112 and 168 as the key sizes, as well\nas 128 and 192 (for those people who don't like to count the parity bits).\n<li>Providing no strength parameter is passed to the DESede key generator in\nthe JCE provider, the provider now generates DESede keys in the k1-k2-k1\nformat (which is compatible with the Sun reference implementation), otherwise\nyou get what you ask for (3-DES or 2-DES in the minimum number of bytes).\n<li>Base Diffie-Hellman key agreement now works correctly for more than two\nparties.\n<li>Cipher.getAlgorithmParameters was returing null in cases where a cipher\nobject had generated it's own IV. This has been fixed.\n<li>An error in the key store occasionally caused checks of entry types to\nresult in a null pointer exception. This has been fixed.\n<li>RSA key generator in JCE now recognises RSAKeyGenerationParameterSpec.\n<li>Resetting and resusing HMacs in the lightweight and heavyweight libraries\ncaused a NullPointer exception. This has been fixed.\n</ul>\n\n<h3>2.55.3 Additional Functionality</h3>\n<ul>\n<li>ISO10126Padding is now recognised explicitly for block ciphers\nas well.\n<li>The Blowfish implementation is now somewhat faster.\n</ul>\n\n<h3>2.56.1 Version</h3>\nRelease: 1.05<br/>\nDate:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2001, April 17\n<h3>2.56.2 Defects Fixed</h3>\n<ul>\n<li>The DESEDE key generator can now be used to generate 2-Key-DESEDE\nkeys as well as 3-Key-DESEDE keys.\n<li>One of the weak keys in the DESParameters, and the DESKeySpec look\nup table, was incorrect. This has been fixed.\n<li>The PKCS12 generator was only generating the first 128-160 bits of the\nkey correctly (depending on the digest used). This has been fixed.\n<li>The ASN.1 library was skipping explicitly tagged objects of zero length.\nThis has been fixed.\n</ul>\n<h3>2.56.3 Additional Functionality</h3>\n<ul>\n<li>There is now an org.bouncycastle.jce.netscape package which has\na class in for dealing with Netscape Certificate Request objects.\n</ul>\n<h3>2.56.4 Additional Notes</h3>\n<p>\nConcerning the PKCS12 fix: in a few cases this may cause some backward\ncompatibility issues - if this happens to you, drop us a line at\n<a href=\"mailto:feedback-crypto@bouncycastle.org\">feedback-crypto@bouncycastle.org</a>\nand we will help you get it sorted out.\n\n<h3>2.57.1 Version</h3>\nRelease: 1.04<br/>\nDate:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2001, March 11\n<h3>2.57.2 Defects Fixed</h3>\n<ul>\n<li>Signatures generated by other providers that include optional null\nparameters in the AlgorithmIdentifier are now handled correctly by the\nprovider.\n<li>The JCE 1.2.1 states that the names of algorithms associated with the JCE\nare case insensitive. The class that matches algorithms to names now tries\nto match the name given with it's equivalent in upper case, before trying\nto match it as given. If you write a provider and include versions of your\nalgorithm names in uppercase only, this JCE implementation will always\nmatch a getInstance regardless of the case of the algorithm passed into\nthe getInstance method.\n<li>If the JCE API and the Provider were in a different class path, the\nclass loader being used sometimes failed to find classes for JCE Ciphers, etc.\nThis has been fixed.\n<li>An error in the ASN.1 library was causing problems serialising Diffie-Hellman keys. This has been fixed.\n<li>The agreement package was left out of the j2me bat file. This has been fixed.\n<li>The BigInteger class for 1.0 and the j2me wasn't able to generate random\nintegers (prime or otherwise). This has been fixed. \n<li>The BigInteger class would sometimes go into a death spiral if the any\n32nd bit of an exponent was set when modPow was called. This has been fixed. \n<li>Cipher.getInstance would treat \"//\" in a transformation as a single \"/\".\nThis has been fixed.\n<li>PBEWithSHAAndIDEA-CBC was throwing an exception on initialisation. This has\nbeen fixed.\n<li>The X509Name class in the asn1.x509 package wasn't initialising its local\nhash table when the hash table constructor was called. This has been fixed.\n</ul>\n\n<h3>2.57.3 Additional Functionality</h3>\n<ul>\n<li>Added Elliptic Curve DSA (X9.62) - ECDSA - to provider and lightweight\nlibrary.\n<li>Added Elliptic Curve basic Diffie-Hellman to provider and lightweight\nlibrary.\n<li>Added DSA support to the provider and the lightweight library.\n<li>Added super class interfaces for basic Diffie-Hellman agreement classes\nto lightweight library.\n<li>The certificate generators now support ECDSA and DSA certs as well.\n</ul>\n\n<h3>2.58.1 Version</h3>\nRelease: 1.03<br/>\nDate:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2001, January 7\n<h3>2.58.2 Defects Fixed</h3>\n<ul>\n<li>CFB and OFB modes when specified without padding would insist on input\nbeing block aligned. When specified without padding CFB and OFB now behave in a compatible \nfashion (a doFinal on a partial block will yield just the data that could\nbe processed).\nIn short, it provides another way of generating cipher text the same\nlength as the plain text.\n</ul>\n\n<h3>2.59.1 Version</h3>\nRelease: 1.02<br/>\nDate:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2000, November 7\n<h3>2.59.2 Defects Fixed</h3>\n<ul>\n<li>The RSA key pair generator occasionally produced keys 1 bit under the\nrequested size. This is now fixed.\n</ul>\n\n<h3>2.60.1 Version</h3>\nRelease: 1.01<br/>\nDate:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2000, October 15\n<h3>2.60.2 Defects Fixed</h3>\n\n<ul>\n<li>Buffered ciphers in lightweight library were not resetting correctly\non a doFinal. This has been fixed.\n</ul>\n\n<h3>2.61.1 Version</h3>\nRelease: 1.00<br/>\nDate:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2000, October 13\n<h3>2.61.2 Defects Fixed</h3>\n<p>\n<ul>\n<li>JDK1.2 version now works with keytool for certificate generation.\n<li>Certificate toString method no longer throws a null pointer exception\nif a group [3] extension has not been added.\n<li>Under some circumstances the NullCipher would throw a NullPointerException,\nthis has been fixed.\n<li>Under some circumstances CipherInputStream would throw a NullPointerException, this has been fixed.\n<li>OpenSSL/SSLeay private key encodings would cause an exception to be thrown\nby the RSA key factory. This is now fixed.\n<li>The Cipher class always used the default provider even when one was specified, this has been fixed.\n<li>Some DES PBE algorithms did not set the parity correctly in generated keys, this has been fixed.\n</ul>\n\n<h3>2.61.3 Additional functionality</h3>\n<p>\n<ul>\n<li>Argument validation is much improved.\n<li>An X509KeyUsage class has been added to the JCE class to make it easier\nto specify the KeyUsage extension on X.509 certificates.\n<li>The library now allows creation of version 1 certificates as well.\n</ul>\n\n<h3>3.0 Notes</h3>\n<p>\nThe J2ME is only supported under Windows.\n<p>\nIf you are trying to use the lightweight provider in a JDK 1.0 applet, you\nneed to change the package names for java.math.BigInteger, java.lang.IllegalStateException, and java.security.SecureRandom\n<p>\nThe RSA test under JDK 1.0 and J2ME takes a while to run...\n</body>\n</html>\n", "package org.bouncycastle.pqc.jcajce.provider.xmss;\n\nimport java.io.IOException;\nimport java.security.PrivateKey;\n\nimport org.bouncycastle.asn1.ASN1ObjectIdentifier;\nimport org.bouncycastle.asn1.pkcs.PrivateKeyInfo;\nimport org.bouncycastle.asn1.x509.AlgorithmIdentifier;\nimport org.bouncycastle.crypto.CipherParameters;\nimport org.bouncycastle.pqc.asn1.PQCObjectIdentifiers;\nimport org.bouncycastle.pqc.asn1.XMSSMTKeyParams;\nimport org.bouncycastle.pqc.asn1.XMSSMTPrivateKey;\nimport org.bouncycastle.pqc.asn1.XMSSPrivateKey;\nimport org.bouncycastle.pqc.crypto.xmss.BDSStateMap;\nimport org.bouncycastle.pqc.crypto.xmss.XMSSMTParameters;\nimport org.bouncycastle.pqc.crypto.xmss.XMSSMTPrivateKeyParameters;\nimport org.bouncycastle.pqc.crypto.xmss.XMSSUtil;\nimport org.bouncycastle.pqc.jcajce.interfaces.XMSSMTKey;\nimport org.bouncycastle.util.Arrays;\n\npublic class BCXMSSMTPrivateKey\n    implements PrivateKey, XMSSMTKey\n{\n    private final ASN1ObjectIdentifier treeDigest;\n    private final XMSSMTPrivateKeyParameters keyParams;\n\n    public BCXMSSMTPrivateKey(\n        ASN1ObjectIdentifier treeDigest,\n        XMSSMTPrivateKeyParameters keyParams)\n    {\n        this.treeDigest = treeDigest;\n        this.keyParams = keyParams;\n    }\n\n    public BCXMSSMTPrivateKey(PrivateKeyInfo keyInfo)\n        throws IOException\n    {\n        XMSSMTKeyParams keyParams = XMSSMTKeyParams.getInstance(keyInfo.getPrivateKeyAlgorithm().getParameters());\n        this.treeDigest = keyParams.getTreeDigest().getAlgorithm();\n\n        XMSSPrivateKey xmssMtPrivateKey = XMSSPrivateKey.getInstance(keyInfo.parsePrivateKey());\n\n        try\n        {\n            XMSSMTPrivateKeyParameters.Builder keyBuilder = new XMSSMTPrivateKeyParameters\n                .Builder(new XMSSMTParameters(keyParams.getHeight(), keyParams.getLayers(), DigestUtil.getDigest(treeDigest)))\n                .withIndex(xmssMtPrivateKey.getIndex())\n                .withSecretKeySeed(xmssMtPrivateKey.getSecretKeySeed())\n                .withSecretKeyPRF(xmssMtPrivateKey.getSecretKeyPRF())\n                .withPublicSeed(xmssMtPrivateKey.getPublicSeed())\n                .withRoot(xmssMtPrivateKey.getRoot());\n\n            if (xmssMtPrivateKey.getBdsState() != null)\n            {\n                keyBuilder.withBDSState((BDSStateMap)XMSSUtil.deserialize(xmssMtPrivateKey.getBdsState()));\n            }\n\n            this.keyParams = keyBuilder.build();\n        }\n        catch (ClassNotFoundException e)\n        {\n            throw new IOException(\"ClassNotFoundException processing BDS state: \" + e.getMessage());\n        }\n    }\n\n    public String getAlgorithm()\n    {\n        return \"XMSSMT\";\n    }\n\n    public String getFormat()\n    {\n        return \"PKCS#8\";\n    }\n\n    public byte[] getEncoded()\n    {\n        PrivateKeyInfo pki;\n        try\n        {\n            AlgorithmIdentifier algorithmIdentifier = new AlgorithmIdentifier(PQCObjectIdentifiers.xmss_mt, new XMSSMTKeyParams(keyParams.getParameters().getHeight(), keyParams.getParameters().getLayers(), new AlgorithmIdentifier(treeDigest)));\n            pki = new PrivateKeyInfo(algorithmIdentifier, createKeyStructure());\n\n            return pki.getEncoded();\n        }\n        catch (IOException e)\n        {\n            return null;\n        }\n    }\n\n    CipherParameters getKeyParams()\n    {\n        return keyParams;\n    }\n\n    public boolean equals(Object o)\n    {\n        if (o == this)\n        {\n            return true;\n        }\n\n        if (o instanceof BCXMSSMTPrivateKey)\n        {\n            BCXMSSMTPrivateKey otherKey = (BCXMSSMTPrivateKey)o;\n\n            return treeDigest.equals(otherKey.treeDigest) && Arrays.areEqual(keyParams.toByteArray(), otherKey.keyParams.toByteArray());\n        }\n\n        return false;\n    }\n\n    public int hashCode()\n    {\n        return treeDigest.hashCode() + 37 * Arrays.hashCode(keyParams.toByteArray());\n    }\n\n    private XMSSMTPrivateKey createKeyStructure()\n    {\n        byte[] keyData = keyParams.toByteArray();\n\n        int n = keyParams.getParameters().getDigestSize();\n        int totalHeight = keyParams.getParameters().getHeight();\n        int indexSize = (totalHeight + 7) / 8;\n        int secretKeySize = n;\n        int secretKeyPRFSize = n;\n        int publicSeedSize = n;\n        int rootSize = n;\n\n        int position = 0;\n        int index = (int)XMSSUtil.bytesToXBigEndian(keyData, position, indexSize);\n        if (!XMSSUtil.isIndexValid(totalHeight, index))\n        {\n            throw new IllegalArgumentException(\"index out of bounds\");\n        }\n        position += indexSize;\n        byte[] secretKeySeed = XMSSUtil.extractBytesAtOffset(keyData, position, secretKeySize);\n        position += secretKeySize;\n        byte[] secretKeyPRF = XMSSUtil.extractBytesAtOffset(keyData, position, secretKeyPRFSize);\n        position += secretKeyPRFSize;\n        byte[] publicSeed = XMSSUtil.extractBytesAtOffset(keyData, position, publicSeedSize);\n        position += publicSeedSize;\n        byte[] root = XMSSUtil.extractBytesAtOffset(keyData, position, rootSize);\n        position += rootSize;\n               /* import BDS state */\n        byte[] bdsStateBinary = XMSSUtil.extractBytesAtOffset(keyData, position, keyData.length - position);\n\n        return new XMSSMTPrivateKey(index, secretKeySeed, secretKeyPRF, publicSeed, root, bdsStateBinary);\n    }\n\n    ASN1ObjectIdentifier getTreeDigestOID()\n    {\n        return treeDigest;\n    }\n\n    public int getHeight()\n    {\n        return keyParams.getParameters().getHeight();\n    }\n\n    public int getLayers()\n    {\n        return keyParams.getParameters().getLayers();\n    }\n\n    public String getTreeDigest()\n    {\n        return DigestUtil.getXMSSDigestName(treeDigest);\n    }\n}\n", "package org.bouncycastle.pqc.jcajce.provider.xmss;\n\nimport java.io.IOException;\nimport java.security.PrivateKey;\n\nimport org.bouncycastle.asn1.ASN1ObjectIdentifier;\nimport org.bouncycastle.asn1.pkcs.PrivateKeyInfo;\nimport org.bouncycastle.asn1.x509.AlgorithmIdentifier;\nimport org.bouncycastle.crypto.CipherParameters;\nimport org.bouncycastle.pqc.asn1.PQCObjectIdentifiers;\nimport org.bouncycastle.pqc.asn1.XMSSKeyParams;\nimport org.bouncycastle.pqc.asn1.XMSSPrivateKey;\nimport org.bouncycastle.pqc.crypto.xmss.BDS;\nimport org.bouncycastle.pqc.crypto.xmss.XMSSParameters;\nimport org.bouncycastle.pqc.crypto.xmss.XMSSPrivateKeyParameters;\nimport org.bouncycastle.pqc.crypto.xmss.XMSSUtil;\nimport org.bouncycastle.pqc.jcajce.interfaces.XMSSKey;\nimport org.bouncycastle.util.Arrays;\n\npublic class BCXMSSPrivateKey\n    implements PrivateKey, XMSSKey\n{\n    private final XMSSPrivateKeyParameters keyParams;\n    private final ASN1ObjectIdentifier treeDigest;\n\n    public BCXMSSPrivateKey(\n        ASN1ObjectIdentifier treeDigest,\n        XMSSPrivateKeyParameters keyParams)\n    {\n        this.treeDigest = treeDigest;\n        this.keyParams = keyParams;\n    }\n\n    public BCXMSSPrivateKey(PrivateKeyInfo keyInfo)\n        throws IOException\n    {\n        XMSSKeyParams keyParams = XMSSKeyParams.getInstance(keyInfo.getPrivateKeyAlgorithm().getParameters());\n        this.treeDigest = keyParams.getTreeDigest().getAlgorithm();\n\n        XMSSPrivateKey xmssPrivateKey = XMSSPrivateKey.getInstance(keyInfo.parsePrivateKey());\n\n        try\n        {\n            XMSSPrivateKeyParameters.Builder keyBuilder = new XMSSPrivateKeyParameters\n                .Builder(new XMSSParameters(keyParams.getHeight(), DigestUtil.getDigest(treeDigest)))\n                .withIndex(xmssPrivateKey.getIndex())\n                .withSecretKeySeed(xmssPrivateKey.getSecretKeySeed())\n                .withSecretKeyPRF(xmssPrivateKey.getSecretKeyPRF())\n                .withPublicSeed(xmssPrivateKey.getPublicSeed())\n                .withRoot(xmssPrivateKey.getRoot());\n\n            if (xmssPrivateKey.getBdsState() != null)\n            {\n                keyBuilder.withBDSState((BDS)XMSSUtil.deserialize(xmssPrivateKey.getBdsState()));\n            }\n\n            this.keyParams = keyBuilder.build();\n        }\n        catch (ClassNotFoundException e)\n        {\n            throw new IOException(\"ClassNotFoundException processing BDS state: \" + e.getMessage());\n        }\n    }\n\n    public String getAlgorithm()\n    {\n        return \"XMSS\";\n    }\n\n    public String getFormat()\n    {\n        return \"PKCS#8\";\n    }\n\n    public byte[] getEncoded()\n    {\n        PrivateKeyInfo pki;\n        try\n        {\n            AlgorithmIdentifier algorithmIdentifier = new AlgorithmIdentifier(PQCObjectIdentifiers.xmss, new XMSSKeyParams(keyParams.getParameters().getHeight(), new AlgorithmIdentifier(treeDigest)));\n            pki = new PrivateKeyInfo(algorithmIdentifier, createKeyStructure());\n\n            return pki.getEncoded();\n        }\n        catch (IOException e)\n        {\n            return null;\n        }\n    }\n\n    public boolean equals(Object o)\n    {\n        if (o == this)\n        {\n            return true;\n        }\n\n        if (o instanceof BCXMSSPrivateKey)\n        {\n            BCXMSSPrivateKey otherKey = (BCXMSSPrivateKey)o;\n\n            return treeDigest.equals(otherKey.treeDigest) && Arrays.areEqual(keyParams.toByteArray(), otherKey.keyParams.toByteArray());\n        }\n\n        return false;\n    }\n\n    public int hashCode()\n    {\n        return treeDigest.hashCode() + 37 * Arrays.hashCode(keyParams.toByteArray());\n    }\n\n    CipherParameters getKeyParams()\n    {\n        return keyParams;\n    }\n\n    private XMSSPrivateKey createKeyStructure()\n    {\n        byte[] keyData = keyParams.toByteArray();\n\n        int n = keyParams.getParameters().getDigestSize();\n        int totalHeight = keyParams.getParameters().getHeight();\n        int indexSize = 4;\n        int secretKeySize = n;\n        int secretKeyPRFSize = n;\n        int publicSeedSize = n;\n        int rootSize = n;\n\n        int position = 0;\n        int index = (int)XMSSUtil.bytesToXBigEndian(keyData, position, indexSize);\n        if (!XMSSUtil.isIndexValid(totalHeight, index))\n        {\n            throw new IllegalArgumentException(\"index out of bounds\");\n        }\n        position += indexSize;\n        byte[] secretKeySeed = XMSSUtil.extractBytesAtOffset(keyData, position, secretKeySize);\n        position += secretKeySize;\n        byte[] secretKeyPRF = XMSSUtil.extractBytesAtOffset(keyData, position, secretKeyPRFSize);\n        position += secretKeyPRFSize;\n        byte[] publicSeed = XMSSUtil.extractBytesAtOffset(keyData, position, publicSeedSize);\n        position += publicSeedSize;\n        byte[] root = XMSSUtil.extractBytesAtOffset(keyData, position, rootSize);\n        position += rootSize;\n               /* import BDS state */\n        byte[] bdsStateBinary = XMSSUtil.extractBytesAtOffset(keyData, position, keyData.length - position);\n\n        return new XMSSPrivateKey(index, secretKeySeed, secretKeyPRF, publicSeed, root, bdsStateBinary);\n    }\n\n    ASN1ObjectIdentifier getTreeDigestOID()\n    {\n        return treeDigest;\n    }\n\n    public int getHeight()\n    {\n        return keyParams.getParameters().getHeight();\n    }\n\n    public String getTreeDigest()\n    {\n        return DigestUtil.getXMSSDigestName(treeDigest);\n    }\n}\n"], "fixing_code": ["package org.bouncycastle.pqc.crypto.gmss;\n\nimport java.security.SecureRandom;\nimport java.util.Vector;\n\nimport org.bouncycastle.crypto.AsymmetricCipherKeyPair;\nimport org.bouncycastle.crypto.AsymmetricCipherKeyPairGenerator;\nimport org.bouncycastle.crypto.Digest;\nimport org.bouncycastle.crypto.KeyGenerationParameters;\nimport org.bouncycastle.pqc.crypto.gmss.util.GMSSRandom;\nimport org.bouncycastle.pqc.crypto.gmss.util.WinternitzOTSVerify;\nimport org.bouncycastle.pqc.crypto.gmss.util.WinternitzOTSignature;\n\n\n/**\n * This class implements key pair generation of the generalized Merkle signature\n * scheme (GMSS).\n *\n * @see GMSSSigner\n */\npublic class GMSSKeyPairGenerator\n    implements AsymmetricCipherKeyPairGenerator\n{\n    /**\n     * The source of randomness for OTS private key generation\n     */\n    private GMSSRandom gmssRandom;\n\n    /**\n     * The hash function used for the construction of the authentication trees\n     */\n    private Digest messDigestTree;\n\n    /**\n     * An array of the seeds for the PRGN (for main tree, and all current\n     * subtrees)\n     */\n    private byte[][] currentSeeds;\n\n    /**\n     * An array of seeds for the PRGN (for all subtrees after next)\n     */\n    private byte[][] nextNextSeeds;\n\n    /**\n     * An array of the RootSignatures\n     */\n    private byte[][] currentRootSigs;\n\n    /**\n     * Class of hash function to use\n     */\n    private GMSSDigestProvider digestProvider;\n\n    /**\n     * The length of the seed for the PRNG\n     */\n    private int mdLength;\n\n    /**\n     * the number of Layers\n     */\n    private int numLayer;\n\n\n    /**\n     * Flag indicating if the class already has been initialized\n     */\n    private boolean initialized = false;\n\n    /**\n     * Instance of GMSSParameterset\n     */\n    private GMSSParameters gmssPS;\n\n    /**\n     * An array of the heights of the authentication trees of each layer\n     */\n    private int[] heightOfTrees;\n\n    /**\n     * An array of the Winternitz parameter 'w' of each layer\n     */\n    private int[] otsIndex;\n\n    /**\n     * The parameter K needed for the authentication path computation\n     */\n    private int[] K;\n\n    private GMSSKeyGenerationParameters gmssParams;\n\n    /**\n     * The GMSS OID.\n     */\n    public static final String OID = \"1.3.6.1.4.1.8301.3.1.3.3\";\n\n    /**\n     * The standard constructor tries to generate the GMSS algorithm identifier\n     * with the corresponding OID.\n     *\n     * @param digestProvider     provider for digest implementations.\n     */\n    public GMSSKeyPairGenerator(GMSSDigestProvider digestProvider)\n    {\n        this.digestProvider = digestProvider;\n        messDigestTree = digestProvider.get();\n\n        // set mdLength\n        this.mdLength = messDigestTree.getDigestSize();\n        // construct randomizer\n        this.gmssRandom = new GMSSRandom(messDigestTree);\n\n    }\n\n    /**\n     * Generates the GMSS key pair. The public key is an instance of\n     * JDKGMSSPublicKey, the private key is an instance of JDKGMSSPrivateKey.\n     *\n     * @return Key pair containing a JDKGMSSPublicKey and a JDKGMSSPrivateKey\n     */\n    private AsymmetricCipherKeyPair genKeyPair()\n    {\n        if (!initialized)\n        {\n            initializeDefault();\n        }\n\n        // initialize authenticationPaths and treehash instances\n        byte[][][] currentAuthPaths = new byte[numLayer][][];\n        byte[][][] nextAuthPaths = new byte[numLayer - 1][][];\n        Treehash[][] currentTreehash = new Treehash[numLayer][];\n        Treehash[][] nextTreehash = new Treehash[numLayer - 1][];\n\n        Vector[] currentStack = new Vector[numLayer];\n        Vector[] nextStack = new Vector[numLayer - 1];\n\n        Vector[][] currentRetain = new Vector[numLayer][];\n        Vector[][] nextRetain = new Vector[numLayer - 1][];\n\n        for (int i = 0; i < numLayer; i++)\n        {\n            currentAuthPaths[i] = new byte[heightOfTrees[i]][mdLength];\n            currentTreehash[i] = new Treehash[heightOfTrees[i] - K[i]];\n\n            if (i > 0)\n            {\n                nextAuthPaths[i - 1] = new byte[heightOfTrees[i]][mdLength];\n                nextTreehash[i - 1] = new Treehash[heightOfTrees[i] - K[i]];\n            }\n\n            currentStack[i] = new Vector();\n            if (i > 0)\n            {\n                nextStack[i - 1] = new Vector();\n            }\n        }\n\n        // initialize roots\n        byte[][] currentRoots = new byte[numLayer][mdLength];\n        byte[][] nextRoots = new byte[numLayer - 1][mdLength];\n        // initialize seeds\n        byte[][] seeds = new byte[numLayer][mdLength];\n        // initialize seeds[] by copying starting-seeds of first trees of each\n        // layer\n        for (int i = 0; i < numLayer; i++)\n        {\n            System.arraycopy(currentSeeds[i], 0, seeds[i], 0, mdLength);\n        }\n\n        // initialize rootSigs\n        currentRootSigs = new byte[numLayer - 1][mdLength];\n\n        // -------------------------\n        // -------------------------\n        // --- calculation of current authpaths and current rootsigs (AUTHPATHS,\n        // SIG)------\n        // from bottom up to the root\n        for (int h = numLayer - 1; h >= 0; h--)\n        {\n            GMSSRootCalc tree;\n\n            // on lowest layer no lower root is available, so just call\n            // the method with null as first parameter\n            if (h == numLayer - 1)\n            {\n                tree = this.generateCurrentAuthpathAndRoot(null, currentStack[h], seeds[h], h);\n            }\n            else\n            // otherwise call the method with the former computed root\n            // value\n            {\n                tree = this.generateCurrentAuthpathAndRoot(currentRoots[h + 1], currentStack[h], seeds[h], h);\n            }\n\n            // set initial values needed for the private key construction\n            for (int i = 0; i < heightOfTrees[h]; i++)\n            {\n                System.arraycopy(tree.getAuthPath()[i], 0, currentAuthPaths[h][i], 0, mdLength);\n            }\n            currentRetain[h] = tree.getRetain();\n            currentTreehash[h] = tree.getTreehash();\n            System.arraycopy(tree.getRoot(), 0, currentRoots[h], 0, mdLength);\n        }\n\n        // --- calculation of next authpaths and next roots (AUTHPATHS+, ROOTS+)\n        // ------\n        for (int h = numLayer - 2; h >= 0; h--)\n        {\n            GMSSRootCalc tree = this.generateNextAuthpathAndRoot(nextStack[h], seeds[h + 1], h + 1);\n\n            // set initial values needed for the private key construction\n            for (int i = 0; i < heightOfTrees[h + 1]; i++)\n            {\n                System.arraycopy(tree.getAuthPath()[i], 0, nextAuthPaths[h][i], 0, mdLength);\n            }\n            nextRetain[h] = tree.getRetain();\n            nextTreehash[h] = tree.getTreehash();\n            System.arraycopy(tree.getRoot(), 0, nextRoots[h], 0, mdLength);\n\n            // create seed for the Merkle tree after next (nextNextSeeds)\n            // SEEDs++\n            System.arraycopy(seeds[h + 1], 0, this.nextNextSeeds[h], 0, mdLength);\n        }\n        // ------------\n\n        // generate JDKGMSSPublicKey\n        GMSSPublicKeyParameters publicKey = new GMSSPublicKeyParameters(currentRoots[0], gmssPS);\n\n        // generate the JDKGMSSPrivateKey\n        GMSSPrivateKeyParameters privateKey = new GMSSPrivateKeyParameters(currentSeeds, nextNextSeeds, currentAuthPaths,\n            nextAuthPaths, currentTreehash, nextTreehash, currentStack, nextStack, currentRetain, nextRetain, nextRoots, currentRootSigs, gmssPS, digestProvider);\n\n        // return the KeyPair\n        return (new AsymmetricCipherKeyPair(publicKey, privateKey));\n    }\n\n    /**\n     * calculates the authpath for tree in layer h which starts with seed[h]\n     * additionally computes the rootSignature of underlaying root\n     *\n     * @param currentStack stack used for the treehash instance created by this method\n     * @param lowerRoot    stores the root of the lower tree\n     * @param seed        starting seeds\n     * @param h            actual layer\n     */\n    private GMSSRootCalc generateCurrentAuthpathAndRoot(byte[] lowerRoot, Vector currentStack, byte[] seed, int h)\n    {\n        byte[] help = new byte[mdLength];\n\n        byte[] OTSseed = new byte[mdLength];\n        OTSseed = gmssRandom.nextSeed(seed);\n\n        WinternitzOTSignature ots;\n\n        // data structure that constructs the whole tree and stores\n        // the initial values for treehash, Auth and retain\n        GMSSRootCalc treeToConstruct = new GMSSRootCalc(this.heightOfTrees[h], this.K[h], digestProvider);\n\n        treeToConstruct.initialize(currentStack);\n\n        // generate the first leaf\n        if (h == numLayer - 1)\n        {\n            ots = new WinternitzOTSignature(OTSseed, digestProvider.get(), otsIndex[h]);\n            help = ots.getPublicKey();\n        }\n        else\n        {\n            // for all layers except the lowest, generate the signature of the\n            // underlying root\n            // and reuse this signature to compute the first leaf of acual layer\n            // more efficiently (by verifiing the signature)\n            ots = new WinternitzOTSignature(OTSseed, digestProvider.get(), otsIndex[h]);\n            currentRootSigs[h] = ots.getSignature(lowerRoot);\n            WinternitzOTSVerify otsver = new WinternitzOTSVerify(digestProvider.get(), otsIndex[h]);\n            help = otsver.Verify(lowerRoot, currentRootSigs[h]);\n        }\n        // update the tree with the first leaf\n        treeToConstruct.update(help);\n\n        int seedForTreehashIndex = 3;\n        int count = 0;\n\n        // update the tree 2^(H) - 1 times, from the second to the last leaf\n        for (int i = 1; i < (1 << this.heightOfTrees[h]); i++)\n        {\n            // initialize the seeds for the leaf generation with index 3 * 2^h\n            if (i == seedForTreehashIndex && count < this.heightOfTrees[h] - this.K[h])\n            {\n                treeToConstruct.initializeTreehashSeed(seed, count);\n                seedForTreehashIndex *= 2;\n                count++;\n            }\n\n            OTSseed = gmssRandom.nextSeed(seed);\n            ots = new WinternitzOTSignature(OTSseed, digestProvider.get(), otsIndex[h]);\n            treeToConstruct.update(ots.getPublicKey());\n        }\n\n        if (treeToConstruct.wasFinished())\n        {\n            return treeToConstruct;\n        }\n        System.err.println(\"Baum noch nicht fertig konstruiert!!!\");\n        return null;\n    }\n\n    /**\n     * calculates the authpath and root for tree in layer h which starts with\n     * seed[h]\n     *\n     * @param nextStack stack used for the treehash instance created by this method\n     * @param seed      starting seeds\n     * @param h         actual layer\n     */\n    private GMSSRootCalc generateNextAuthpathAndRoot(Vector nextStack, byte[] seed, int h)\n    {\n        byte[] OTSseed = new byte[numLayer];\n        WinternitzOTSignature ots;\n\n        // data structure that constructs the whole tree and stores\n        // the initial values for treehash, Auth and retain\n        GMSSRootCalc treeToConstruct = new GMSSRootCalc(this.heightOfTrees[h], this.K[h], this.digestProvider);\n        treeToConstruct.initialize(nextStack);\n\n        int seedForTreehashIndex = 3;\n        int count = 0;\n\n        // update the tree 2^(H) times, from the first to the last leaf\n        for (int i = 0; i < (1 << this.heightOfTrees[h]); i++)\n        {\n            // initialize the seeds for the leaf generation with index 3 * 2^h\n            if (i == seedForTreehashIndex && count < this.heightOfTrees[h] - this.K[h])\n            {\n                treeToConstruct.initializeTreehashSeed(seed, count);\n                seedForTreehashIndex *= 2;\n                count++;\n            }\n\n            OTSseed = gmssRandom.nextSeed(seed);\n            ots = new WinternitzOTSignature(OTSseed, digestProvider.get(), otsIndex[h]);\n            treeToConstruct.update(ots.getPublicKey());\n        }\n\n        if (treeToConstruct.wasFinished())\n        {\n            return treeToConstruct;\n        }\n        System.err.println(\"N\ufffdchster Baum noch nicht fertig konstruiert!!!\");\n        return null;\n    }\n\n    /**\n     * This method initializes the GMSS KeyPairGenerator using an integer value\n     * <code>keySize</code> as input. It provides a simple use of the GMSS for\n     * testing demands.\n     * <p>\n     * A given <code>keysize</code> of less than 10 creates an amount 2^10\n     * signatures. A keySize between 10 and 20 creates 2^20 signatures. Given an\n     * integer greater than 20 the key pair generator creates 2^40 signatures.\n     *\n     * @param keySize      Assigns the parameters used for the GMSS signatures. There are\n     *                     3 choices:<br>\n     *                     1. keysize &lt;= 10: creates 2^10 signatures using the\n     *                     parameterset<br>\n     *                     P = (2, (5, 5), (3, 3), (3, 3))<br>\n     *                     2. keysize &gt; 10 and &lt;= 20: creates 2^20 signatures using the\n     *                     parameterset<br>\n     *                     P = (2, (10, 10), (5, 4), (2, 2))<br>\n     *                     3. keysize &gt; 20: creates 2^40 signatures using the\n     *                     parameterset<br>\n     *                     P = (2, (10, 10, 10, 10), (9, 9, 9, 3), (2, 2, 2, 2))\n     * @param secureRandom not used by GMSS, the SHA1PRNG of the SUN Provider is always\n     *                     used\n     */\n    public void initialize(int keySize, SecureRandom secureRandom)\n    {\n\n        KeyGenerationParameters kgp;\n        if (keySize <= 10)\n        { // create 2^10 keys\n            int[] defh = {10};\n            int[] defw = {3};\n            int[] defk = {2};\n            // XXX sec random neede?\n            kgp = new GMSSKeyGenerationParameters(secureRandom, new GMSSParameters(defh.length, defh, defw, defk));\n        }\n        else if (keySize <= 20)\n        { // create 2^20 keys\n            int[] defh = {10, 10};\n            int[] defw = {5, 4};\n            int[] defk = {2, 2};\n            kgp = new GMSSKeyGenerationParameters(secureRandom, new GMSSParameters(defh.length, defh, defw, defk));\n        }\n        else\n        { // create 2^40 keys, keygen lasts around 80 seconds\n            int[] defh = {10, 10, 10, 10};\n            int[] defw = {9, 9, 9, 3};\n            int[] defk = {2, 2, 2, 2};\n            kgp = new GMSSKeyGenerationParameters(secureRandom, new GMSSParameters(defh.length, defh, defw, defk));\n        }\n\n        // call the initializer with the chosen parameters\n        this.initialize(kgp);\n\n    }\n\n\n    /**\n     * Initalizes the key pair generator using a parameter set as input\n     */\n    public void initialize(KeyGenerationParameters param)\n    {\n\n        this.gmssParams = (GMSSKeyGenerationParameters)param;\n\n        // generate GMSSParameterset\n        this.gmssPS = new GMSSParameters(gmssParams.getParameters().getNumOfLayers(), gmssParams.getParameters().getHeightOfTrees(),\n            gmssParams.getParameters().getWinternitzParameter(), gmssParams.getParameters().getK());\n\n        this.numLayer = gmssPS.getNumOfLayers();\n        this.heightOfTrees = gmssPS.getHeightOfTrees();\n        this.otsIndex = gmssPS.getWinternitzParameter();\n        this.K = gmssPS.getK();\n\n        // seeds\n        this.currentSeeds = new byte[numLayer][mdLength];\n        this.nextNextSeeds = new byte[numLayer - 1][mdLength];\n\n        // construct SecureRandom for initial seed generation\n        SecureRandom secRan = new SecureRandom();\n\n        // generation of initial seeds\n        for (int i = 0; i < numLayer; i++)\n        {\n            secRan.nextBytes(currentSeeds[i]);\n            gmssRandom.nextSeed(currentSeeds[i]);\n        }\n\n        this.initialized = true;\n    }\n\n    /**\n     * This method is called by generateKeyPair() in case that no other\n     * initialization method has been called by the user\n     */\n    private void initializeDefault()\n    {\n        int[] defh = {10, 10, 10, 10};\n        int[] defw = {3, 3, 3, 3};\n        int[] defk = {2, 2, 2, 2};\n\n        KeyGenerationParameters kgp = new GMSSKeyGenerationParameters(new SecureRandom(), new GMSSParameters(defh.length, defh, defw, defk));\n        this.initialize(kgp);\n\n    }\n\n    public void init(KeyGenerationParameters param)\n    {\n        this.initialize(param);\n\n    }\n\n    public AsymmetricCipherKeyPair generateKeyPair()\n    {\n        return genKeyPair();\n    }\n}\n", "package org.bouncycastle.pqc.crypto.rainbow;\n\nimport org.bouncycastle.crypto.CipherParameters;\n\npublic class RainbowParameters\n    implements CipherParameters\n{\n\n    /**\n     * DEFAULT PARAMS\n     */\n    /*\n      * Vi = vinegars per layer whereas n is vu (vu = 33 = n) such that\n      *\n      * v1 = 6; o1 = 12-6 = 6\n      *\n      * v2 = 12; o2 = 17-12 = 5\n      *\n      * v3 = 17; o3 = 22-17 = 5\n      *\n      * v4 = 22; o4 = 33-22 = 11\n      *\n      * v5 = 33; (o5 = 0)\n      */\n    private final int[] DEFAULT_VI = {6, 12, 17, 22, 33};\n\n    private int[] vi;// set of vinegar vars per layer.\n\n    /**\n     * Default Constructor The elements of the array containing the number of\n     * Vinegar variables in each layer are set to the default values here.\n     */\n    public RainbowParameters()\n    {\n        this.vi = this.DEFAULT_VI;\n    }\n\n    /**\n     * Constructor with parameters\n     *\n     * @param vi The elements of the array containing the number of Vinegar\n     *           variables per layer are set to the values of the input array.\n     */\n    public RainbowParameters(int[] vi)\n    {\n        this.vi = vi;\n\n        checkParams();\n    }\n\n    private void checkParams()\n    {\n        if (vi == null)\n        {\n            throw new IllegalArgumentException(\"no layers defined.\");\n        }\n        if (vi.length > 1)\n        {\n            for (int i = 0; i < vi.length - 1; i++)\n            {\n                if (vi[i] >= vi[i + 1])\n                {\n                    throw new IllegalArgumentException(\n                        \"v[i] has to be smaller than v[i+1]\");\n                }\n            }\n        }\n        else\n        {\n            throw new IllegalArgumentException(\n                \"Rainbow needs at least 1 layer, such that v1 < v2.\");\n        }\n    }\n\n    /**\n     * Getter for the number of layers\n     *\n     * @return the number of layers\n     */\n    public int getNumOfLayers()\n    {\n        return this.vi.length - 1;\n    }\n\n    /**\n     * Getter for the number of all the polynomials in Rainbow\n     *\n     * @return the number of the polynomials\n     */\n    public int getDocLength()\n    {\n        return vi[vi.length - 1] - vi[0];\n    }\n\n    /**\n     * Getter for the array containing the number of Vinegar-variables per layer\n     *\n     * @return the numbers of vinegars per layer\n     */\n    public int[] getVi()\n    {\n        return this.vi;\n    }\n}\n", "package org.bouncycastle.pqc.crypto.xmss;\n\nimport java.io.IOException;\n\nimport org.bouncycastle.crypto.params.AsymmetricKeyParameter;\nimport org.bouncycastle.util.Arrays;\n\n/**\n * XMSS^MT Private Key.\n */\npublic final class XMSSMTPrivateKeyParameters\n    extends AsymmetricKeyParameter\n    implements XMSSStoreableObjectInterface\n{\n\n    private final XMSSMTParameters params;\n    private final long index;\n    private final byte[] secretKeySeed;\n    private final byte[] secretKeyPRF;\n    private final byte[] publicSeed;\n    private final byte[] root;\n    private final BDSStateMap bdsState;\n\n    private XMSSMTPrivateKeyParameters(Builder builder)\n    {\n        super(true);\n        params = builder.params;\n        if (params == null)\n        {\n            throw new NullPointerException(\"params == null\");\n        }\n        int n = params.getDigestSize();\n        byte[] privateKey = builder.privateKey;\n        if (privateKey != null)\n        {\n            if (builder.xmss == null)\n            {\n                throw new NullPointerException(\"xmss == null\");\n            }\n            /* import */\n            int totalHeight = params.getHeight();\n            int indexSize = (totalHeight + 7) / 8;\n            int secretKeySize = n;\n            int secretKeyPRFSize = n;\n            int publicSeedSize = n;\n            int rootSize = n;\n            /*\n            int totalSize = indexSize + secretKeySize + secretKeyPRFSize + publicSeedSize + rootSize;\n\t\t\tif (privateKey.length != totalSize) {\n\t\t\t\tthrow new ParseException(\"private key has wrong size\", 0);\n\t\t\t}\n\t\t\t*/\n            int position = 0;\n            index = XMSSUtil.bytesToXBigEndian(privateKey, position, indexSize);\n            if (!XMSSUtil.isIndexValid(totalHeight, index))\n            {\n                throw new IllegalArgumentException(\"index out of bounds\");\n            }\n            position += indexSize;\n            secretKeySeed = XMSSUtil.extractBytesAtOffset(privateKey, position, secretKeySize);\n            position += secretKeySize;\n            secretKeyPRF = XMSSUtil.extractBytesAtOffset(privateKey, position, secretKeyPRFSize);\n            position += secretKeyPRFSize;\n            publicSeed = XMSSUtil.extractBytesAtOffset(privateKey, position, publicSeedSize);\n            position += publicSeedSize;\n            root = XMSSUtil.extractBytesAtOffset(privateKey, position, rootSize);\n            position += rootSize;\n\t\t\t/* import BDS state */\n            byte[] bdsStateBinary = XMSSUtil.extractBytesAtOffset(privateKey, position, privateKey.length - position);\n\n            try\n            {\n                BDSStateMap bdsImport = (BDSStateMap)XMSSUtil.deserialize(bdsStateBinary, BDSStateMap.class);\n\n                bdsImport.setXMSS(builder.xmss);\n                bdsState = bdsImport;\n            }\n            catch (IOException e)\n            {\n                throw new IllegalArgumentException(e.getMessage(), e);\n            }\n            catch (ClassNotFoundException e)\n            {\n                throw new IllegalArgumentException(e.getMessage(), e);\n            }\n        }\n        else\n        {\n\t\t\t/* set */\n            index = builder.index;\n            byte[] tmpSecretKeySeed = builder.secretKeySeed;\n            if (tmpSecretKeySeed != null)\n            {\n                if (tmpSecretKeySeed.length != n)\n                {\n                    throw new IllegalArgumentException(\"size of secretKeySeed needs to be equal size of digest\");\n                }\n                secretKeySeed = tmpSecretKeySeed;\n            }\n            else\n            {\n                secretKeySeed = new byte[n];\n            }\n            byte[] tmpSecretKeyPRF = builder.secretKeyPRF;\n            if (tmpSecretKeyPRF != null)\n            {\n                if (tmpSecretKeyPRF.length != n)\n                {\n                    throw new IllegalArgumentException(\"size of secretKeyPRF needs to be equal size of digest\");\n                }\n                secretKeyPRF = tmpSecretKeyPRF;\n            }\n            else\n            {\n                secretKeyPRF = new byte[n];\n            }\n            byte[] tmpPublicSeed = builder.publicSeed;\n            if (tmpPublicSeed != null)\n            {\n                if (tmpPublicSeed.length != n)\n                {\n                    throw new IllegalArgumentException(\"size of publicSeed needs to be equal size of digest\");\n                }\n                publicSeed = tmpPublicSeed;\n            }\n            else\n            {\n                publicSeed = new byte[n];\n            }\n            byte[] tmpRoot = builder.root;\n            if (tmpRoot != null)\n            {\n                if (tmpRoot.length != n)\n                {\n                    throw new IllegalArgumentException(\"size of root needs to be equal size of digest\");\n                }\n                root = tmpRoot;\n            }\n            else\n            {\n                root = new byte[n];\n            }\n            BDSStateMap tmpBDSState = builder.bdsState;\n            if (tmpBDSState != null)\n            {\n                bdsState = tmpBDSState;\n            }\n            else\n            {\n                long globalIndex = builder.index;\n                int totalHeight = params.getHeight();\n\n                if (XMSSUtil.isIndexValid(totalHeight, globalIndex) && tmpPublicSeed != null && tmpSecretKeySeed != null)\n                {\n                    bdsState = new BDSStateMap(params, builder.index, tmpPublicSeed, tmpSecretKeySeed);\n                }\n                else\n                {\n                    bdsState = new BDSStateMap();\n                }\n            }\n        }\n    }\n\n    public static class Builder\n    {\n\n        /* mandatory */\n        private final XMSSMTParameters params;\n        /* optional */\n        private long index = 0L;\n        private byte[] secretKeySeed = null;\n        private byte[] secretKeyPRF = null;\n        private byte[] publicSeed = null;\n        private byte[] root = null;\n        private BDSStateMap bdsState = null;\n        private byte[] privateKey = null;\n        private XMSSParameters xmss = null;\n\n        public Builder(XMSSMTParameters params)\n        {\n            super();\n            this.params = params;\n        }\n\n        public Builder withIndex(long val)\n        {\n            index = val;\n            return this;\n        }\n\n        public Builder withSecretKeySeed(byte[] val)\n        {\n            secretKeySeed = XMSSUtil.cloneArray(val);\n            return this;\n        }\n\n        public Builder withSecretKeyPRF(byte[] val)\n        {\n            secretKeyPRF = XMSSUtil.cloneArray(val);\n            return this;\n        }\n\n        public Builder withPublicSeed(byte[] val)\n        {\n            publicSeed = XMSSUtil.cloneArray(val);\n            return this;\n        }\n\n        public Builder withRoot(byte[] val)\n        {\n            root = XMSSUtil.cloneArray(val);\n            return this;\n        }\n\n        public Builder withBDSState(BDSStateMap val)\n        {\n            bdsState = val;\n            return this;\n        }\n\n        public Builder withPrivateKey(byte[] privateKeyVal, XMSSParameters xmssVal)\n        {\n            privateKey = XMSSUtil.cloneArray(privateKeyVal);\n            xmss = xmssVal;\n            return this;\n        }\n\n        public XMSSMTPrivateKeyParameters build()\n        {\n            return new XMSSMTPrivateKeyParameters(this);\n        }\n    }\n\n    public byte[] toByteArray()\n    {\n\t\t/* index || secretKeySeed || secretKeyPRF || publicSeed || root */\n        int n = params.getDigestSize();\n        int indexSize = (params.getHeight() + 7) / 8;\n        int secretKeySize = n;\n        int secretKeyPRFSize = n;\n        int publicSeedSize = n;\n        int rootSize = n;\n        int totalSize = indexSize + secretKeySize + secretKeyPRFSize + publicSeedSize + rootSize;\n        byte[] out = new byte[totalSize];\n        int position = 0;\n\t\t/* copy index */\n        byte[] indexBytes = XMSSUtil.toBytesBigEndian(index, indexSize);\n        XMSSUtil.copyBytesAtOffset(out, indexBytes, position);\n        position += indexSize;\n\t\t/* copy secretKeySeed */\n        XMSSUtil.copyBytesAtOffset(out, secretKeySeed, position);\n        position += secretKeySize;\n\t\t/* copy secretKeyPRF */\n        XMSSUtil.copyBytesAtOffset(out, secretKeyPRF, position);\n        position += secretKeyPRFSize;\n\t\t/* copy publicSeed */\n        XMSSUtil.copyBytesAtOffset(out, publicSeed, position);\n        position += publicSeedSize;\n\t\t/* copy root */\n        XMSSUtil.copyBytesAtOffset(out, root, position);\n\t\t/* concatenate bdsState */\n        try\n        {\n            return Arrays.concatenate(out, XMSSUtil.serialize(bdsState));\n        }\n        catch (IOException e)\n        {\n            throw new IllegalStateException(\"error serializing bds state: \" + e.getMessage(), e);\n        }\n    }\n\n    public long getIndex()\n    {\n        return index;\n    }\n\n    public byte[] getSecretKeySeed()\n    {\n        return XMSSUtil.cloneArray(secretKeySeed);\n    }\n\n    public byte[] getSecretKeyPRF()\n    {\n        return XMSSUtil.cloneArray(secretKeyPRF);\n    }\n\n    public byte[] getPublicSeed()\n    {\n        return XMSSUtil.cloneArray(publicSeed);\n    }\n\n    public byte[] getRoot()\n    {\n        return XMSSUtil.cloneArray(root);\n    }\n\n    BDSStateMap getBDSState()\n    {\n        return bdsState;\n    }\n\n    public XMSSMTParameters getParameters()\n    {\n        return params;\n    }\n\n    public XMSSMTPrivateKeyParameters getNextKey()\n    {\n        BDSStateMap newState = new BDSStateMap(bdsState, params, this.getIndex(), publicSeed, secretKeySeed);\n\n        return new XMSSMTPrivateKeyParameters.Builder(params).withIndex(index + 1)\n            .withSecretKeySeed(secretKeySeed).withSecretKeyPRF(secretKeyPRF)\n            .withPublicSeed(publicSeed).withRoot(root)\n            .withBDSState(newState).build();\n    }\n}\n", "package org.bouncycastle.pqc.crypto.xmss;\n\nimport java.io.IOException;\n\nimport org.bouncycastle.crypto.params.AsymmetricKeyParameter;\nimport org.bouncycastle.util.Arrays;\nimport org.bouncycastle.util.Pack;\n\n/**\n * XMSS Private Key.\n */\npublic final class XMSSPrivateKeyParameters\n    extends AsymmetricKeyParameter\n    implements XMSSStoreableObjectInterface\n{\n\n    /**\n     * XMSS parameters object.\n     */\n    private final XMSSParameters params;\n    /**\n     * Secret for the derivation of WOTS+ secret keys.\n     */\n    private final byte[] secretKeySeed;\n    /**\n     * Secret for the randomization of message digests during signature\n     * creation.\n     */\n    private final byte[] secretKeyPRF;\n    /**\n     * Public seed for the randomization of hashes.\n     */\n    private final byte[] publicSeed;\n    /**\n     * Public root of binary tree.\n     */\n    private final byte[] root;\n    /**\n     * BDS state.\n     */\n    private final BDS bdsState;\n\n    private XMSSPrivateKeyParameters(Builder builder)\n    {\n        super(true);\n        params = builder.params;\n        if (params == null)\n        {\n            throw new NullPointerException(\"params == null\");\n        }\n        int n = params.getDigestSize();\n        byte[] privateKey = builder.privateKey;\n        if (privateKey != null)\n        {\n            if (builder.xmss == null)\n            {\n                throw new NullPointerException(\"xmss == null\");\n            }\n            /* import */\n            int height = params.getHeight();\n            int indexSize = 4;\n            int secretKeySize = n;\n            int secretKeyPRFSize = n;\n            int publicSeedSize = n;\n            int rootSize = n;\n\t\t\t/*\n\t\t\tint totalSize = indexSize + secretKeySize + secretKeyPRFSize + publicSeedSize + rootSize;\n\t\t\tif (privateKey.length != totalSize) {\n\t\t\t\tthrow new ParseException(\"private key has wrong size\", 0);\n\t\t\t}\n\t\t\t*/\n            int position = 0;\n            int index = Pack.bigEndianToInt(privateKey, position);\n            if (!XMSSUtil.isIndexValid(height, index))\n            {\n                throw new IllegalArgumentException(\"index out of bounds\");\n            }\n            position += indexSize;\n            secretKeySeed = XMSSUtil.extractBytesAtOffset(privateKey, position, secretKeySize);\n            position += secretKeySize;\n            secretKeyPRF = XMSSUtil.extractBytesAtOffset(privateKey, position, secretKeyPRFSize);\n            position += secretKeyPRFSize;\n            publicSeed = XMSSUtil.extractBytesAtOffset(privateKey, position, publicSeedSize);\n            position += publicSeedSize;\n            root = XMSSUtil.extractBytesAtOffset(privateKey, position, rootSize);\n            position += rootSize;\n\t\t\t/* import BDS state */\n            byte[] bdsStateBinary = XMSSUtil.extractBytesAtOffset(privateKey, position, privateKey.length - position);\n            try\n            {\n                BDS bdsImport = (BDS)XMSSUtil.deserialize(bdsStateBinary, BDS.class);\n                bdsImport.setXMSS(builder.xmss);\n                bdsImport.validate();\n                if (bdsImport.getIndex() != index)\n                {\n                    throw new IllegalStateException(\"serialized BDS has wrong index\");\n                }\n                bdsState = bdsImport;\n            }\n            catch (IOException e)\n            {\n                throw new IllegalArgumentException(e.getMessage(), e);\n            }\n            catch (ClassNotFoundException e)\n            {\n                throw new IllegalArgumentException(e.getMessage(), e);\n            }\n        }\n        else\n        {\n\t\t\t/* set */\n            byte[] tmpSecretKeySeed = builder.secretKeySeed;\n            if (tmpSecretKeySeed != null)\n            {\n                if (tmpSecretKeySeed.length != n)\n                {\n                    throw new IllegalArgumentException(\"size of secretKeySeed needs to be equal size of digest\");\n                }\n                secretKeySeed = tmpSecretKeySeed;\n            }\n            else\n            {\n                secretKeySeed = new byte[n];\n            }\n            byte[] tmpSecretKeyPRF = builder.secretKeyPRF;\n            if (tmpSecretKeyPRF != null)\n            {\n                if (tmpSecretKeyPRF.length != n)\n                {\n                    throw new IllegalArgumentException(\"size of secretKeyPRF needs to be equal size of digest\");\n                }\n                secretKeyPRF = tmpSecretKeyPRF;\n            }\n            else\n            {\n                secretKeyPRF = new byte[n];\n            }\n            byte[] tmpPublicSeed = builder.publicSeed;\n            if (tmpPublicSeed != null)\n            {\n                if (tmpPublicSeed.length != n)\n                {\n                    throw new IllegalArgumentException(\"size of publicSeed needs to be equal size of digest\");\n                }\n                publicSeed = tmpPublicSeed;\n            }\n            else\n            {\n                publicSeed = new byte[n];\n            }\n            byte[] tmpRoot = builder.root;\n            if (tmpRoot != null)\n            {\n                if (tmpRoot.length != n)\n                {\n                    throw new IllegalArgumentException(\"size of root needs to be equal size of digest\");\n                }\n                root = tmpRoot;\n            }\n            else\n            {\n                root = new byte[n];\n            }\n            BDS tmpBDSState = builder.bdsState;\n            if (tmpBDSState != null)\n            {\n                bdsState = tmpBDSState;\n            }\n            else\n            {\n                if (builder.index < ((1 << params.getHeight()) - 2) && tmpPublicSeed != null && tmpSecretKeySeed != null)\n                {\n                    bdsState = new BDS(params, tmpPublicSeed, tmpSecretKeySeed, (OTSHashAddress)new OTSHashAddress.Builder().build(), builder.index);\n                }\n                else\n                {\n                    bdsState = new BDS(params, builder.index);\n                }\n            }\n        }\n    }\n\n    public static class Builder\n    {\n\n        /* mandatory */\n        private final XMSSParameters params;\n        /* optional */\n        private int index = 0;\n        private byte[] secretKeySeed = null;\n        private byte[] secretKeyPRF = null;\n        private byte[] publicSeed = null;\n        private byte[] root = null;\n        private BDS bdsState = null;\n        private byte[] privateKey = null;\n        private XMSSParameters xmss = null;\n\n        public Builder(XMSSParameters params)\n        {\n            super();\n            this.params = params;\n        }\n\n        public Builder withIndex(int val)\n        {\n            index = val;\n            return this;\n        }\n\n        public Builder withSecretKeySeed(byte[] val)\n        {\n            secretKeySeed = XMSSUtil.cloneArray(val);\n            return this;\n        }\n\n        public Builder withSecretKeyPRF(byte[] val)\n        {\n            secretKeyPRF = XMSSUtil.cloneArray(val);\n            return this;\n        }\n\n        public Builder withPublicSeed(byte[] val)\n        {\n            publicSeed = XMSSUtil.cloneArray(val);\n            return this;\n        }\n\n        public Builder withRoot(byte[] val)\n        {\n            root = XMSSUtil.cloneArray(val);\n            return this;\n        }\n\n        public Builder withBDSState(BDS valBDS)\n        {\n            bdsState = valBDS;\n            return this;\n        }\n\n        public Builder withPrivateKey(byte[] privateKeyVal, XMSSParameters xmssParameters)\n        {\n            privateKey = XMSSUtil.cloneArray(privateKeyVal);\n            xmss = xmssParameters;\n            return this;\n        }\n\n        public XMSSPrivateKeyParameters build()\n        {\n            return new XMSSPrivateKeyParameters(this);\n        }\n    }\n\n    public byte[] toByteArray()\n    {\n\t\t/* index || secretKeySeed || secretKeyPRF || publicSeed || root */\n        int n = params.getDigestSize();\n        int indexSize = 4;\n        int secretKeySize = n;\n        int secretKeyPRFSize = n;\n        int publicSeedSize = n;\n        int rootSize = n;\n        int totalSize = indexSize + secretKeySize + secretKeyPRFSize + publicSeedSize + rootSize;\n        byte[] out = new byte[totalSize];\n        int position = 0;\n\t\t/* copy index */\n        Pack.intToBigEndian(bdsState.getIndex(), out, position);\n        position += indexSize;\n\t\t/* copy secretKeySeed */\n        XMSSUtil.copyBytesAtOffset(out, secretKeySeed, position);\n        position += secretKeySize;\n\t\t/* copy secretKeyPRF */\n        XMSSUtil.copyBytesAtOffset(out, secretKeyPRF, position);\n        position += secretKeyPRFSize;\n\t\t/* copy publicSeed */\n        XMSSUtil.copyBytesAtOffset(out, publicSeed, position);\n        position += publicSeedSize;\n\t\t/* copy root */\n        XMSSUtil.copyBytesAtOffset(out, root, position);\n\t\t/* concatenate bdsState */\n        byte[] bdsStateOut = null;\n        try\n        {\n            bdsStateOut = XMSSUtil.serialize(bdsState);\n        }\n        catch (IOException e)\n        {\n            throw new RuntimeException(\"error serializing bds state: \" + e.getMessage());\n        }\n\n        return Arrays.concatenate(out, bdsStateOut);\n    }\n\n    public int getIndex()\n    {\n        return bdsState.getIndex();\n    }\n\n    public byte[] getSecretKeySeed()\n    {\n        return XMSSUtil.cloneArray(secretKeySeed);\n    }\n\n    public byte[] getSecretKeyPRF()\n    {\n        return XMSSUtil.cloneArray(secretKeyPRF);\n    }\n\n    public byte[] getPublicSeed()\n    {\n        return XMSSUtil.cloneArray(publicSeed);\n    }\n\n    public byte[] getRoot()\n    {\n        return XMSSUtil.cloneArray(root);\n    }\n\n    BDS getBDSState()\n    {\n        return bdsState;\n    }\n\n    public XMSSParameters getParameters()\n    {\n        return params;\n    }\n\n    public XMSSPrivateKeyParameters getNextKey()\n    {\n        /* prepare authentication path for next leaf */\n        int treeHeight = this.params.getHeight();\n        if (this.getIndex() < ((1 << treeHeight) - 1))\n        {\n            return new XMSSPrivateKeyParameters.Builder(params)\n                .withSecretKeySeed(secretKeySeed).withSecretKeyPRF(secretKeyPRF)\n                .withPublicSeed(publicSeed).withRoot(root)\n                .withBDSState(bdsState.getNextState(publicSeed, secretKeySeed, (OTSHashAddress)new OTSHashAddress.Builder().build())).build();\n        }\n        else\n        {\n            return new XMSSPrivateKeyParameters.Builder(params)\n                .withSecretKeySeed(secretKeySeed).withSecretKeyPRF(secretKeyPRF)\n                .withPublicSeed(publicSeed).withRoot(root)\n                .withBDSState(new BDS(params, getIndex() + 1)).build();  // no more nodes left.\n        }\n    }\n\n}\n", "package org.bouncycastle.pqc.crypto.xmss;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\n\nimport org.bouncycastle.crypto.Digest;\nimport org.bouncycastle.util.Arrays;\nimport org.bouncycastle.util.encoders.Hex;\n\n/**\n * Utils for XMSS implementation.\n */\npublic class XMSSUtil\n{\n\n    /**\n     * Calculates the logarithm base 2 for a given Integer.\n     *\n     * @param n Number.\n     * @return Logarithm to base 2 of {@code n}.\n     */\n    public static int log2(int n)\n    {\n        int log = 0;\n        while ((n >>= 1) != 0)\n        {\n            log++;\n        }\n        return log;\n    }\n\n    /**\n     * Convert int/long to n-byte array.\n     *\n     * @param value      int/long value.\n     * @param sizeInByte Size of byte array in byte.\n     * @return int/long as big-endian byte array of size {@code sizeInByte}.\n     */\n    public static byte[] toBytesBigEndian(long value, int sizeInByte)\n    {\n        byte[] out = new byte[sizeInByte];\n        for (int i = (sizeInByte - 1); i >= 0; i--)\n        {\n            out[i] = (byte)value;\n            value >>>= 8;\n        }\n        return out;\n    }\n\n    /*\n     * Copy long to byte array in big-endian at specific offset.\n     */\n    public static void longToBigEndian(long value, byte[] in, int offset)\n    {\n        if (in == null)\n        {\n            throw new NullPointerException(\"in == null\");\n        }\n        if ((in.length - offset) < 8)\n        {\n            throw new IllegalArgumentException(\"not enough space in array\");\n        }\n        in[offset] = (byte)((value >> 56) & 0xff);\n        in[offset + 1] = (byte)((value >> 48) & 0xff);\n        in[offset + 2] = (byte)((value >> 40) & 0xff);\n        in[offset + 3] = (byte)((value >> 32) & 0xff);\n        in[offset + 4] = (byte)((value >> 24) & 0xff);\n        in[offset + 5] = (byte)((value >> 16) & 0xff);\n        in[offset + 6] = (byte)((value >> 8) & 0xff);\n        in[offset + 7] = (byte)((value) & 0xff);\n    }\n\n    /*\n     * Generic convert from big endian byte array to long.\n     */\n    public static long bytesToXBigEndian(byte[] in, int offset, int size)\n    {\n        if (in == null)\n        {\n            throw new NullPointerException(\"in == null\");\n        }\n        long res = 0;\n        for (int i = offset; i < (offset + size); i++)\n        {\n            res = (res << 8) | (in[i] & 0xff);\n        }\n        return res;\n    }\n\n    /**\n     * Clone a byte array.\n     *\n     * @param in byte array.\n     * @return Copy of byte array.\n     */\n    public static byte[] cloneArray(byte[] in)\n    {\n        if (in == null)\n        {\n            throw new NullPointerException(\"in == null\");\n        }\n        byte[] out = new byte[in.length];\n        for (int i = 0; i < in.length; i++)\n        {\n            out[i] = in[i];\n        }\n        return out;\n    }\n\n    /**\n     * Clone a 2d byte array.\n     *\n     * @param in 2d byte array.\n     * @return Copy of 2d byte array.\n     */\n    public static byte[][] cloneArray(byte[][] in)\n    {\n        if (hasNullPointer(in))\n        {\n            throw new NullPointerException(\"in has null pointers\");\n        }\n        byte[][] out = new byte[in.length][];\n        for (int i = 0; i < in.length; i++)\n        {\n            out[i] = new byte[in[i].length];\n            for (int j = 0; j < in[i].length; j++)\n            {\n                out[i][j] = in[i][j];\n            }\n        }\n        return out;\n    }\n\n    /**\n     * Compares two 2d-byte arrays.\n     *\n     * @param a 2d-byte array 1.\n     * @param b 2d-byte array 2.\n     * @return true if all values in 2d-byte array are equal false else.\n     */\n    public static boolean areEqual(byte[][] a, byte[][] b)\n    {\n        if (hasNullPointer(a) || hasNullPointer(b))\n        {\n            throw new NullPointerException(\"a or b == null\");\n        }\n        for (int i = 0; i < a.length; i++)\n        {\n            if (!Arrays.areEqual(a[i], b[i]))\n            {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Dump content of 2d byte array.\n     *\n     * @param x byte array.\n     */\n    public static void dumpByteArray(byte[][] x)\n    {\n        if (hasNullPointer(x))\n        {\n            throw new NullPointerException(\"x has null pointers\");\n        }\n        for (int i = 0; i < x.length; i++)\n        {\n            System.out.println(Hex.toHexString(x[i]));\n        }\n    }\n\n    /**\n     * Checks whether 2d byte array has null pointers.\n     *\n     * @param in 2d byte array.\n     * @return true if at least one null pointer is found false else.\n     */\n    public static boolean hasNullPointer(byte[][] in)\n    {\n        if (in == null)\n        {\n            return true;\n        }\n        for (int i = 0; i < in.length; i++)\n        {\n            if (in[i] == null)\n            {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Copy src byte array to dst byte array at offset.\n     *\n     * @param dst    Destination.\n     * @param src    Source.\n     * @param offset Destination offset.\n     */\n    public static void copyBytesAtOffset(byte[] dst, byte[] src, int offset)\n    {\n        if (dst == null)\n        {\n            throw new NullPointerException(\"dst == null\");\n        }\n        if (src == null)\n        {\n            throw new NullPointerException(\"src == null\");\n        }\n        if (offset < 0)\n        {\n            throw new IllegalArgumentException(\"offset hast to be >= 0\");\n        }\n        if ((src.length + offset) > dst.length)\n        {\n            throw new IllegalArgumentException(\"src length + offset must not be greater than size of destination\");\n        }\n        for (int i = 0; i < src.length; i++)\n        {\n            dst[offset + i] = src[i];\n        }\n    }\n\n    /**\n     * Copy length bytes at position offset from src.\n     *\n     * @param src    Source byte array.\n     * @param offset Offset in source byte array.\n     * @param length Length of bytes to copy.\n     * @return New byte array.\n     */\n    public static byte[] extractBytesAtOffset(byte[] src, int offset, int length)\n    {\n        if (src == null)\n        {\n            throw new NullPointerException(\"src == null\");\n        }\n        if (offset < 0)\n        {\n            throw new IllegalArgumentException(\"offset hast to be >= 0\");\n        }\n        if (length < 0)\n        {\n            throw new IllegalArgumentException(\"length hast to be >= 0\");\n        }\n        if ((offset + length) > src.length)\n        {\n            throw new IllegalArgumentException(\"offset + length must not be greater then size of source array\");\n        }\n        byte[] out = new byte[length];\n        for (int i = 0; i < out.length; i++)\n        {\n            out[i] = src[offset + i];\n        }\n        return out;\n    }\n\n    /**\n     * Check whether an index is valid or not.\n     *\n     * @param height Height of binary tree.\n     * @param index  Index to validate.\n     * @return true if index is valid false else.\n     */\n    public static boolean isIndexValid(int height, long index)\n    {\n        if (index < 0)\n        {\n            throw new IllegalStateException(\"index must not be negative\");\n        }\n        return index < (1L << height);\n    }\n\n    /**\n     * Determine digest size of digest.\n     *\n     * @param digest Digest.\n     * @return Digest size.\n     */\n    public static int getDigestSize(Digest digest)\n    {\n        if (digest == null)\n        {\n            throw new NullPointerException(\"digest == null\");\n        }\n        String algorithmName = digest.getAlgorithmName();\n        if (algorithmName.equals(\"SHAKE128\"))\n        {\n            return 32;\n        }\n        if (algorithmName.equals(\"SHAKE256\"))\n        {\n            return 64;\n        }\n        return digest.getDigestSize();\n    }\n\n    public static long getTreeIndex(long index, int xmssTreeHeight)\n    {\n        return index >> xmssTreeHeight;\n    }\n\n    public static int getLeafIndex(long index, int xmssTreeHeight)\n    {\n        return (int)(index & ((1L << xmssTreeHeight) - 1L));\n    }\n\n    public static byte[] serialize(Object obj)\n        throws IOException\n    {\n        ByteArrayOutputStream out = new ByteArrayOutputStream();\n        ObjectOutputStream oos = new ObjectOutputStream(out);\n        oos.writeObject(obj);\n        oos.flush();\n        return out.toByteArray();\n    }\n\n    public static Object deserialize(byte[] data, Class clazz)\n        throws IOException, ClassNotFoundException\n    {\n        ByteArrayInputStream in = new ByteArrayInputStream(data);\n        ObjectInputStream is = new ObjectInputStream(in);\n        Object obj = is.readObject();\n\n        if (is.available() != 0)\n        {\n            throw new IOException(\"unexpected data found at end of ObjectInputStream\");\n        }\n        if (clazz.isInstance(obj))\n        {\n            return obj;\n        }\n        else\n        {\n            throw new IOException(\"unexpected class found in ObjectInputStream\");\n        }\n    }\n\n    public static int calculateTau(int index, int height)\n    {\n        int tau = 0;\n        for (int i = 0; i < height; i++)\n        {\n            if (((index >> i) & 1) == 0)\n            {\n                tau = i;\n                break;\n            }\n        }\n        return tau;\n    }\n\n    public static boolean isNewBDSInitNeeded(long globalIndex, int xmssHeight, int layer)\n    {\n        if (globalIndex == 0)\n        {\n            return false;\n        }\n        return (globalIndex % (long)Math.pow((1 << xmssHeight), layer + 1) == 0) ? true : false;\n    }\n\n    public static boolean isNewAuthenticationPathNeeded(long globalIndex, int xmssHeight, int layer)\n    {\n        if (globalIndex == 0)\n        {\n            return false;\n        }\n        return ((globalIndex + 1) % (long)Math.pow((1 << xmssHeight), layer) == 0) ? true : false;\n    }\n}\n", "package org.bouncycastle.pqc.math.linearalgebra;\n\n\nimport java.security.SecureRandom;\nimport java.util.Vector;\n\n\n/**\n * This abstract class defines the finite field <i>GF(2<sup>n</sup>)</i>. It\n * holds the extension degree <i>n</i>, the characteristic, the irreducible\n * fieldpolynomial and conversion matrices. GF2nField is implemented by the\n * classes GF2nPolynomialField and GF2nONBField.\n *\n * @see GF2nONBField\n * @see GF2nPolynomialField\n */\npublic abstract class GF2nField\n{\n\n    protected final SecureRandom random;\n\n    /**\n     * the degree of this field\n     */\n    protected int mDegree;\n\n    /**\n     * the irreducible fieldPolynomial stored in normal order (also for ONB)\n     */\n    protected GF2Polynomial fieldPolynomial;\n\n    /**\n     * holds a list of GF2nFields to which elements have been converted and thus\n     * a COB-Matrix exists\n     */\n    protected Vector fields;\n\n    /**\n     * the COB matrices\n     */\n    protected Vector matrices;\n\n    protected GF2nField(SecureRandom random)\n    {\n        this.random = random;\n    }\n\n    /**\n     * Returns the degree <i>n</i> of this field.\n     *\n     * @return the degree <i>n</i> of this field\n     */\n    public final int getDegree()\n    {\n        return mDegree;\n    }\n\n    /**\n     * Returns the fieldpolynomial as a new Bitstring.\n     *\n     * @return a copy of the fieldpolynomial as a new Bitstring\n     */\n    public final GF2Polynomial getFieldPolynomial()\n    {\n        if (fieldPolynomial == null)\n        {\n            computeFieldPolynomial();\n        }\n        return new GF2Polynomial(fieldPolynomial);\n    }\n\n    /**\n     * Decides whether the given object <tt>other</tt> is the same as this\n     * field.\n     *\n     * @param other another object\n     * @return (this == other)\n     */\n    public final boolean equals(Object other)\n    {\n        if (other == null || !(other instanceof GF2nField))\n        {\n            return false;\n        }\n\n        GF2nField otherField = (GF2nField)other;\n\n        if (otherField.mDegree != mDegree)\n        {\n            return false;\n        }\n        if (!fieldPolynomial.equals(otherField.fieldPolynomial))\n        {\n            return false;\n        }\n        if ((this instanceof GF2nPolynomialField)\n            && !(otherField instanceof GF2nPolynomialField))\n        {\n            return false;\n        }\n        if ((this instanceof GF2nONBField)\n            && !(otherField instanceof GF2nONBField))\n        {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * @return the hash code of this field\n     */\n    public int hashCode()\n    {\n        return mDegree + fieldPolynomial.hashCode();\n    }\n\n    /**\n     * Computes a random root from the given irreducible fieldpolynomial\n     * according to IEEE 1363 algorithm A.5.6. This cal take very long for big\n     * degrees.\n     *\n     * @param B0FieldPolynomial the fieldpolynomial if the other basis as a Bitstring\n     * @return a random root of BOFieldPolynomial in representation according to\n     *         this field\n     * @see \"P1363 A.5.6, p103f\"\n     */\n    protected abstract GF2nElement getRandomRoot(GF2Polynomial B0FieldPolynomial);\n\n    /**\n     * Computes the change-of-basis matrix for basis conversion according to\n     * 1363. The result is stored in the lists fields and matrices.\n     *\n     * @param B1 the GF2nField to convert to\n     * @see \"P1363 A.7.3, p111ff\"\n     */\n    protected abstract void computeCOBMatrix(GF2nField B1);\n\n    /**\n     * Computes the fieldpolynomial. This can take a long time for big degrees.\n     */\n    protected abstract void computeFieldPolynomial();\n\n    /**\n     * Inverts the given matrix represented as bitstrings.\n     *\n     * @param matrix the matrix to invert as a Bitstring[]\n     * @return matrix^(-1)\n     */\n    protected final GF2Polynomial[] invertMatrix(GF2Polynomial[] matrix)\n    {\n        GF2Polynomial[] a = new GF2Polynomial[matrix.length];\n        GF2Polynomial[] inv = new GF2Polynomial[matrix.length];\n        GF2Polynomial dummy;\n        int i, j;\n        // initialize a as a copy of matrix and inv as E(inheitsmatrix)\n        for (i = 0; i < mDegree; i++)\n        {\n            a[i] = new GF2Polynomial(matrix[i]);\n            inv[i] = new GF2Polynomial(mDegree);\n            inv[i].setBit(mDegree - 1 - i);\n        }\n        // construct triangle matrix so that for each a[i] the first i bits are\n        // zero\n        for (i = 0; i < mDegree - 1; i++)\n        {\n            // find column where bit i is set\n            j = i;\n            while ((j < mDegree) && !a[j].testBit(mDegree - 1 - i))\n            {\n                j++;\n            }\n            if (j >= mDegree)\n            {\n                throw new RuntimeException(\n                    \"GF2nField.invertMatrix: Matrix cannot be inverted!\");\n            }\n            if (i != j)\n            { // swap a[i]/a[j] and inv[i]/inv[j]\n                dummy = a[i];\n                a[i] = a[j];\n                a[j] = dummy;\n                dummy = inv[i];\n                inv[i] = inv[j];\n                inv[j] = dummy;\n            }\n            for (j = i + 1; j < mDegree; j++)\n            { // add column i to all columns>i\n                // having their i-th bit set\n                if (a[j].testBit(mDegree - 1 - i))\n                {\n                    a[j].addToThis(a[i]);\n                    inv[j].addToThis(inv[i]);\n                }\n            }\n        }\n        // construct Einheitsmatrix from a\n        for (i = mDegree - 1; i > 0; i--)\n        {\n            for (j = i - 1; j >= 0; j--)\n            { // eliminate the i-th bit in all\n                // columns < i\n                if (a[j].testBit(mDegree - 1 - i))\n                {\n                    a[j].addToThis(a[i]);\n                    inv[j].addToThis(inv[i]);\n                }\n            }\n        }\n        return inv;\n    }\n\n    /**\n     * Converts the given element in representation according to this field to a\n     * new element in representation according to B1 using the change-of-basis\n     * matrix calculated by computeCOBMatrix.\n     *\n     * @param elem  the GF2nElement to convert\n     * @param basis the basis to convert <tt>elem</tt> to\n     * @return <tt>elem</tt> converted to a new element representation\n     *         according to <tt>basis</tt>\n     * @see GF2nField#computeCOBMatrix\n     * @see GF2nField#getRandomRoot\n     * @see GF2nPolynomial\n     * @see \"P1363 A.7 p109ff\"\n     */\n    public final GF2nElement convert(GF2nElement elem, GF2nField basis)\n        throws RuntimeException\n    {\n        if (basis == this)\n        {\n            return (GF2nElement)elem.clone();\n        }\n        if (fieldPolynomial.equals(basis.fieldPolynomial))\n        {\n            return (GF2nElement)elem.clone();\n        }\n        if (mDegree != basis.mDegree)\n        {\n            throw new RuntimeException(\"GF2nField.convert: B1 has a\"\n                + \" different degree and thus cannot be coverted to!\");\n        }\n\n        int i;\n        GF2Polynomial[] COBMatrix;\n        i = fields.indexOf(basis);\n        if (i == -1)\n        {\n            computeCOBMatrix(basis);\n            i = fields.indexOf(basis);\n        }\n        COBMatrix = (GF2Polynomial[])matrices.elementAt(i);\n\n        GF2nElement elemCopy = (GF2nElement)elem.clone();\n        if (elemCopy instanceof GF2nONBElement)\n        {\n            // remember: ONB treats its bits in reverse order\n            ((GF2nONBElement)elemCopy).reverseOrder();\n        }\n        GF2Polynomial bs = new GF2Polynomial(mDegree, elemCopy.toFlexiBigInt());\n        bs.expandN(mDegree);\n        GF2Polynomial result = new GF2Polynomial(mDegree);\n        for (i = 0; i < mDegree; i++)\n        {\n            if (bs.vectorMult(COBMatrix[i]))\n            {\n                result.setBit(mDegree - 1 - i);\n            }\n        }\n        if (basis instanceof GF2nPolynomialField)\n        {\n            return new GF2nPolynomialElement((GF2nPolynomialField)basis,\n                result);\n        }\n        else if (basis instanceof GF2nONBField)\n        {\n            GF2nONBElement res = new GF2nONBElement((GF2nONBField)basis,\n                result.toFlexiBigInt());\n            // TODO Remember: ONB treats its Bits in reverse order !!!\n            res.reverseOrder();\n            return res;\n        }\n        else\n        {\n            throw new RuntimeException(\n                \"GF2nField.convert: B1 must be an instance of \"\n                    + \"GF2nPolynomialField or GF2nONBField!\");\n        }\n\n    }\n\n}\n", "package org.bouncycastle.pqc.crypto.test;\n\nimport java.io.IOException;\nimport java.security.SecureRandom;\n\nimport junit.framework.TestCase;\nimport org.bouncycastle.crypto.digests.SHA256Digest;\nimport org.bouncycastle.pqc.crypto.xmss.XMSS;\nimport org.bouncycastle.pqc.crypto.xmss.XMSSMT;\nimport org.bouncycastle.pqc.crypto.xmss.XMSSMTParameters;\nimport org.bouncycastle.pqc.crypto.xmss.XMSSParameters;\nimport org.bouncycastle.pqc.crypto.xmss.XMSSPrivateKeyParameters;\nimport org.bouncycastle.util.Arrays;\nimport org.bouncycastle.util.encoders.Base64;\n\n/**\n * Test cases for XMSSMTPrivateKey class.\n */\npublic class XMSSMTPrivateKeyTest\n    extends TestCase\n{\n    public void testPrivateKeySerialisation()\n        throws Exception\n    {\n        String stream = \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAArO0ABXNyACJzdW4ucm1pLnNlcnZlci5BY3RpdmF0aW9uR3JvdXBJbXBsT+r9SAwuMqcCAARaAA1ncm91cEluYWN0aXZlTAAGYWN0aXZldAAVTGphdmEvdXRpbC9IYXNodGFibGU7TAAHZ3JvdXBJRHQAJ0xqYXZhL3JtaS9hY3RpdmF0aW9uL0FjdGl2YXRpb25Hcm91cElEO0wACWxvY2tlZElEc3QAEExqYXZhL3V0aWwvTGlzdDt4cgAjamF2YS5ybWkuYWN0aXZhdGlvbi5BY3RpdmF0aW9uR3JvdXCVLvKwBSnVVAIAA0oAC2luY2FybmF0aW9uTAAHZ3JvdXBJRHEAfgACTAAHbW9uaXRvcnQAJ0xqYXZhL3JtaS9hY3RpdmF0aW9uL0FjdGl2YXRpb25Nb25pdG9yO3hyACNqYXZhLnJtaS5zZXJ2ZXIuVW5pY2FzdFJlbW90ZU9iamVjdEUJEhX14n4xAgADSQAEcG9ydEwAA2NzZnQAKExqYXZhL3JtaS9zZXJ2ZXIvUk1JQ2xpZW50U29ja2V0RmFjdG9yeTtMAANzc2Z0AChMamF2YS9ybWkvc2VydmVyL1JNSVNlcnZlclNvY2tldEZhY3Rvcnk7eHIAHGphdmEucm1pLnNlcnZlci5SZW1vdGVTZXJ2ZXLHGQcSaPM5+wIAAHhyABxqYXZhLnJtaS5zZXJ2ZXIuUmVtb3RlT2JqZWN002G0kQxhMx4DAAB4cHcSABBVbmljYXN0U2VydmVyUmVmeAAAFbNwcAAAAAAAAAAAcHAAcHBw\";\n\n        XMSSParameters params = new XMSSParameters(10, new SHA256Digest());\n\n        byte[] output = Base64.decode(new String(stream).getBytes(\"UTF-8\"));\n\n\n        //Simple Exploit\n\n        try\n        {\n            new XMSSPrivateKeyParameters.Builder(params).withPrivateKey(output, params).build();\n        }\n        catch (IllegalArgumentException e)\n        {\n            assertTrue(e.getCause() instanceof IOException);\n        }\n\n        //Same Exploit other method\n\n        XMSS xmss2 = new XMSS(params, new SecureRandom());\n\n        xmss2.generateKeys();\n\n        byte[] publicKey = xmss2.exportPublicKey();\n\n        try\n        {\n            xmss2.importState(output, publicKey);\n        }\n        catch (IllegalArgumentException e)\n        {\n            assertTrue(e.getCause() instanceof IOException);\n        }\n    }\n\n    public void testPrivateKeyParsingSHA256()\n        throws Exception\n    {\n        XMSSMTParameters params = new XMSSMTParameters(20, 10, new SHA256Digest());\n        XMSSMT mt = new XMSSMT(params, new SecureRandom());\n        mt.generateKeys();\n        byte[] privateKey = mt.exportPrivateKey();\n        byte[] publicKey = mt.exportPublicKey();\n\n        mt.importState(privateKey, publicKey);\n\n        assertTrue(Arrays.areEqual(privateKey, mt.exportPrivateKey()));\n    }\n}\n", "<html>\n<head>\n<title>Bouncy Castle Crypto Package - Release Notes</title>\n</head>\n\n<body bgcolor=\"#ffffff\" text=\"#000000#\">\n\n<center>\n<h1>Bouncy Castle Crypto Package - Release Notes</h1>\n<font size=1>\n<pre>\n</pre>\n</font>\n</center>\n<h2>1.0 Introduction</h2>\n<p>\nThe Bouncy Castle Crypto package is a Java implementation of \ncryptographic algorithms.  The package is organised so that it \ncontains a light-weight API suitable for use in any environment\n(including the J2ME) with the additional infrastructure\nto conform the algorithms to the JCE framework.\n</p>\n<h2>2.0 Release History</h2>\n\n<h3>2.1.1 Version</h3>\nRelease: 1.60<br/>\nDate:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2018\n<h3>2.1.2 Defects Fixed</h3>\n<ul>\n<li>Base64/UrlBase64 would throw an exception on a zero length string. This has been fixed.</li>\n<li>XMSS applies further validation to deserialisation of the BDS tree so that failure occurs as soon as tampering is detected.</li>\n</ul>\n<h3>2.1.3 Additional Features and Functionality</h3>\n<ul>\n<li>TLS: Extended CBC padding is now optional (and disabled by default).</li>\n<li>TLS: Now supports channel binding 'tls-server-end-point'.</li>\n<li>TLS: InterruptedIOException (e.g. socket timeout) during app-data reads no longer fails connection; handshake is optionally resumable after IIOE using 'TlsProtocol.setResumableHandshake()'.</li>\n<li>BCJSSE: Now supports system property 'jdk.tls.client.protocols'</li>\n<li>BCJSSE: Now supports SSLParameters.setSNIMatchers.</li>\n<li>BCJSSE: SNI can now be used in earlier JDKs via BC extensions.</li>\n<li>BCJSSE: Session context now holds sessions via soft references.</li>\n</ul>\n<h3>2.2.1 Version</h3>\nRelease: 1.59 <br/>\nDate:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2017, December 28\n<h3>2.2.2 Defects Fixed</h3>\n<ul>\n<li>Issues with using PQC based keys with the provided BC KeyStores have now been fixed.</li>\n<li>ECGOST-2012 public keys were being encoded with the wrong OID for the digest parameter in the algorithm parameter set. This has been fixed.</li>\n<li>SM3 has now been added as an acceptable algorithm for TSP timestamps.</li>\n<li>SM2 signatures were using the wrong default identity value. This has now been fixed.</li>\n<li>An edge condition in Blake2b for hashes on data with a length in the range of 2**64 - 127 to 2**64 has been identifed and fixed.</li>\n<li>The ISO Trailer for SHA512/256 used in X9.31 and ISO9796-2 signatures was incorrect. This has been fixed.</li>\n<li>The BCJSSE SSLEngine implementation now correctly wraps/unwraps application data only in whole records.</li>\n<li>The curve parameters for tc26_gost_3410_12_256_paramSetA were incorrect. These have been fixed.</li>\n<li>Further work has been done to try and prevent escaping exceptions on opening random files as BCFKS files or PKCS#12 files.</li>\n<li>An off-by-one error for the max N check for SCRYPT has been fixed. SCRYPT should now be compliant with RFC 7914.</li>\n<li>ASN1GeneralizedTime will now accept a broader range of input strings.</li>\n</ul>\n<h3>2.2.3 Additional Features and Functionality</h3>\n<ul>\n<li>GOST3410-94 private keys encoded using ASN.1 INTEGER are now accepted in private key info objects.</li>\n<li>SCRYPT is now supported as a SecretKeyFactory in the provider and in the PKCS8 APIs</li>\n<li>The BCJSSE provider now supports session resumption in clients.</li>\n<li>The BCJSSE provider now supports Server Name Indication.</li>\n<li>The BCJSSE provider now supports the jdk.tls.namedGroups system property.</li>\n<li>The BCJSSE provider now supports the org.bouncycastle.jsse.ec.disableChar2 system property, which optionally disables the use of characteristic-2 elliptic curves.</li>\n<li>EC key generation and signing now use cache-timing resistant table lookups.</li>\n<li>Performance of the DSTU algorithms has been greatly improved.</li>\n<li>Support has been added for generating certificates and signatures in the PKIX API using SHA-3 based digests.</li>\n<li>Further work has been done on improving SHA-3 performance.</li>\n<li>The organizationIdentifier (2.5.4.97) attribute has been added to BCStyle.</li>\n<li>GOST3412-2015 has been added to the JCE provider and the lightweight API.</li>\n<li>The Blake2s message digest has been added to the provider and the lightweight API.</li>\n<li>Unified Cofactor Diffie-Hellman (ECCDHU) is now supported for EC in the JCE and the lightweight API.</li>\n<li>A DEROtherInfo generator for key agreement using NewHope as the source of the shared private info has been added that can be used in conjunction with regular key agreement algorithms.</li>\n</ul>\n<h3>2.2.4 Security Related Changes and CVE's Addressed by this Release</h3>\n<ul>\n<li>CVE-2017-13098 (\"ROBOT\"), a Bleichenbacher oracle in TLS when RSA key exchange is negotiated. This potentially affected BCJSSE servers and any other TLS servers configured to use JCE for the underlying crypto - note the two TLS implementations using the BC lightweight APIs are not affected by this.</li>\n</ul>\n\n<h3>2.3.1 Version</h3>\nRelease: 1.58 <br/>\nDate:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2017, August 18\n<h3>2.3.2 Defects Fixed</h3>\n<ul>\n<li>NewHope and SPHINCS keys are now correctly created off certificates by the BC provider.</li>\n<li>Use of the seeded constructor with SecureRandom() and the BC provider in first position could cause a stack overflow error. This has been fixed.</li>\n<li>The boolean flag on ECDSAPublicKey in CVCertficate was hard coded. This has been fixed.</li>\n<li>An edge condition in IV processing for GOFB mode has been found and fixed.</li>\n<li>ANSSI named EC curves were not being recognised in PKCS#10 and certificate parsing. This has been fixed.</li>\n<li>BaseStreamCipher.engineSetMode() could sometimes throw an IllegalArgumentException rather than a NoSuchAlgorithmException. This has been fixed.</li>\n<li>Some class resolving used by the provider would fail if the BC jar was loaded on the boot class path. This has been fixed.</li>\n<li>An off-by-one range check in SM2Signer has been fixed.</li>\n<li>Retrieving an SM2 key from a certificate could result in a NullPointerException due to a problem with the curve lookup. This has been fixed.</li> \n<li>DTLS now supports records containing multiple handshake messages.</li>\n</ul>\n<h3>2.3.3 Additional Features and Functionality</h3>\n<ul>\n<li>An implementation of GOST3410-2012 has been added to light weight API and the JCA provider.</li>\n<li>Support for ECDH GOST3410-2012 and GOST3410-2001 have been added. The CMS API can also handle reading ECDH GOST3410 key transport messages.</li>\n<li>Additional mappings have been added for a range of CVC-ECDSA algorithms.</li>\n<li>XMMS and XMSSMT are now available via the BCPQC provider. Support has been added for using these keys in certificates as well.</li>\n<li>Support has been added for DSTU-7564 message digest and the DSTU-7624 ciphers, together with their associated modes.</li>\n<li>A new system property org.bouncycastle.asn1.allow_unsafe_integer has been added to allow parsing of malformed ASN.1 integers in a similar fashion to what BC 1.56 did. The default behavior remains as reject malformed integers.</li>\n<li>SignedMailValidator would only pick up the first email address in a DN, even when there was more than one. This has been fixed.</li>\n<li>PEMParser will now support a broader range of PBKDFs in encrypted private key files.</li>\n<li>Work has been done on speeding up the SHA-3 family. The functions are now 3 to 4 times faster.</li>\n<li>Some EC aliases in the provider had no corresponding implementations. These have been cleaned up.</li>\n<li>TimeStampResponses now support definite-length encoding to allow the preservation of order in certificates sets for legacy responses.</li>\n<li>The TSP API now supports SM2withSM3.</li>\n<li>The BCJSSE provider now has a FIPS mode.</li>\n<li>The BCJSSE provider now supports layered sockets.</li>\n<li>The new TLS API now has protocol/API support for the status_request extension (OCSP stapling).</li>\n<li>The new TLS API now supports RFC 7633 - X.509v3 TLS Feature Extension (e.g. \"must staple\"), enabled in default clients.</li>\n<li>TLS exceptions have been made more directly informative.</li>\n</ul>\n<h3>2.3.4 Removed Features and Functionality</h3>\n<ul>\n<li>Per RFC 7465, removed support for RC4 in the new TLS API.</li>\n<li>Per RFC 7568, removed support for SSLv3 in the new TLS API.</li>\n</ul>\n\n<h3>2.4.1 Version</h3>\nRelease: 1.57 <br/>\nDate:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2017, May 11\n<h3>2.4.2 Defects Fixed</h3>\n<ul>\n<li>A class cast exception for master certification removal in PGPPublicKey.removeCertification() by certification has been fixed.</li>\n<li>GOST GOFB 28147-89 mode had an edge condition concerning the incorrect calculation of N4 (see section 6.1 of RFC 5830) affecting about 1% of IVs. This has been fixed.</li>\n<li>The X.509 PolicyConstraints class was using implicit rather than explicit tagging for the SkipCerts field. This has been fixed.</li>\n<li>Key expiration in the OpenPGP is now calculated for ambiguous self signatures using the most recently created self-signature, in line with GPG and the recommendation in RFC 4880.</li>\n<li>Multiple validity periods in PGP keys were resolved in an adhoc fashion, in line with GPG's approach the PGP has been changed to return the most recent validity period signed.</li>\n<li>An occasional class cast exception that could occur with nested multi-parts in the S/MIME API has been fixed.</li>\n<li>A couple of bogus aliases associated AlgorithmParameters that did not resolve in the provider have been removed.</li>\n<li>The CMS API will now correctly verify PSS signatures with odd length salts.</li>\n<li>Choosing an invalid mode on a stream cipher in the JCE could result in an IllegalArgumentException. This has now been corrected to throw a NoSuchAlgorithmException.</li>\n<li>Optional parameters for ECDSA public keys in CVCertificates were hard coded to non-optional. This has been fixed.</li>\n<li>Passing a PKCS12 key to a Mac in the BC JCE always resulted in SHA-1 being used to process the password regardless of the underlying MAC algorithm. This has been fixed. An unrecognised HMAC will also now result in an exception.</li>\n<li>The Base64 encoder now explicitly validates 2 character padding as being \"==\".</li>\n<li>EC FixedPointCombMultiplier avoids 'infinity' point in lookup tables, reducing timing side-channels.</li>\n<li>Reuse of a Blake2b digest with a call to reset() rather than doFinal() could result in incorrect padding being introduced and the wrong digest result produced. This has been fixed.</li>\n</ul>\n<h3>2.4.3 Additional Features and Functionality</h3>\n<ul>\n<li>ARIA (RFC 5794) is now supported by the provider and the lightweight API.</li>\n<li>ARIA Key Wrapping (RFC 5649 style) is now supported by the provider and the lightweight API.</li>\n<li>SM2 signatures, key exchange, and public key encryption has been added to the lightweight API.</li>\n<li>XMSS has been added to the lightweight PQ API. Note: this should be treated as beta code.</li>\n<li>API support for client side EST (RFC 7030), as well as some CMC (RFC 5273) has been added to the PKIX API. A full set of ASN.1 classes for both protocols has been added as well.</li>\n<li>A test client for EST which will interop with the 7030 test server at http://testrfc7030.com/ has been added to the general test module in the current source tree.</li>\n<li>The BCJSSE provider now supports SSLContext.getDefault(), with very similar behaviour to the SunJSSE provider, including checks of the relevant javax.net.ssl.* system properties and auto-loading of jssecacerts or cacerts as the default trust store.</li>\n</ul>\n<h3>2.4.4 Security Related Changes</h3>\n<ul>\n<li>The default parameter sizes for DH and DSA are now 2048. If you have been relying on key pair generation without passing in parameters generated keys will now be larger.</li>\n<li>Further work has been done on preventing accidental re-use of a GCM cipher without first changing its key or iv.</li>\n</ul>\n\n<h3>2.5.1 Version</h3>\nRelease: 1.56 <br/>\nDate:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2016, December 23\n<h3>2.5.2 Defects Fixed</h3>\n<ul>\n<li>See section 2.1.4 for Security Defects.</li>\n<li>Using unknown status with the ASN.1 CertStatus primitive could result in an IllegalArgumentException on construction. This has been fixed.</li>\n<li>A potentional NullPointerException in a precomputation in WNafUtil has been removed.</li>\n<li>PGPUtil.getDecoderStream() would throw something other than an IOException for empty and very small data. This has been fixed.</li>\n</ul>\n<h3>2.5.3 Additional Features and Functionality</h3>\n<ul>\n<li>Support for the explicit setting of AlgorithmParameters has been added to the JceCMSContentEncryptorBuilder and the JceCMSMacCaculatorBuilder classes to allow configuration of the session cipher/MAC used.</li>\n<li>EC, ECGOST3410, and DSTU4145 Public keys are now validated on construction in the JCA/JCE and the light weight API.</li>\n<li>DSA Public keys are now validated on construction in the JCA/JCE and the light weight API.</li>\n<li>Diffie-Hellman public keys are now validated where parameters allow it.</li>\n<li>Some validations are now applied to RSA moduli and public exponents.</li>\n<li>The ASN.1 Object Identifier cache now uses a Concurrent HashMap for additional speed.</li>\n<li>AES-CCM MAC support has been added to the provider.</li>\n<li>Support for ChaCha7539 (ChaCha20 as defined in RFC 7539) and Poly1305 have been added to the provider.</li>\n<li>Support has been added for defining your own curves and making them available to the key generators and factories.</li>\n<li>Methods have been added for specifying that a PGPPublicKey/PGPPublicKeyRing is being encoded for export and trust packets are not required.</li>\n<li>Plain-ECDSA and SHA-3 support has been added to DefaultDigestAlgorithmIdentifierFinder.</li>\n<li>SHA-3 support has been added to BcDefaultDigestProvider.</li>\n<li>A higher level TLS API and JSSE provider have been added to the project.</li>\n</ul>\n<h3>2.5.4 Security Related Changes and CVE's Addressed by this Release</h3>\n<ul>\n<li>It is now possible to configure the provider to only import keys for specific named curves.</li>\n<li>Work has been done to improve the \"constant time\" behaviour of the RSA padding mechanisms.</li>\n<li>The GCM ciphers in the JCE and lightweight API will now fail if an attempt is made to use them for encryption after a doFinal or without changing the IV.</li>\n<li>The constructor for IESParameterSpec that allows the use of cipher without a nonce has been deleted. See also details for CVE-2016-1000344, CVE-2016-1000352.</li>\n<li>Strict encoding enforcement has been introduced for ASN1Integer.</li>\n<li>CVE-2016-1000338: DSA does not fully validate ASN.1 encoding of signature on verification. It is possible to inject extra elements in the sequence making up the signature and still have it validate, which in some cases may allow the introduction of \"invisible\" data into a signed structure.</li>\n<li>CVE-2016-1000339: AESFastEngine has a side channel leak if table accesses can be observed. The use of lookup large static lookup tables in AESFastEngine means that where data accesses by the CPU can be observed, it is possible to gain information about the key used to initialize the cipher. We now recommend not using AESFastEngine where this might be a concern. The BC provider is now using AESEngine by default.</li>\n<li>CVE-2016-1000340: Static ECDH vulnerable to carry propagation bug.\nCarry propagation bugs in the implementation of squaring for several raw math classes have been fixed (org.bouncycastle.math.raw.Nat???). These classes are used by our custom elliptic curve implementations (org.bouncycastle.math.ec.custom.**), so there was the possibility of rare (in general usage) spurious calculations for elliptic curve scalar multiplications. Such errors would have been detected with high probability by the output validation for our scalar multipliers.</li>\n<li>CVE-2016-1000341: DSA signature generation vulnerable to timing attack. Where timings can be closely observed for the generation of signatures, the lack of blinding in 1.55 or earlier, may allow an attacker to gain information about the signatures k value and ultimately the private value as well.</li>\n<li>CVE-2016-1000342: ECDSA does not fully validate ASN.1 encoding of signature on verification. It is possible to inject extra elements in the sequence making up the signature and still have it validate, which in some cases may allow the introduction of \"invisible\" data into a signed structure.</li>\n<li>CVE-2016-1000343: DSA key pair generator generates a weak private key if used with default values. If the JCA key pair generator is not explicitly initialised with DSA parameters, 1.55 and earlier generates a private value assuming a 1024 bit key size. In earlier releases this can be dealt with by explicitly passing parameters to the key pair generator.</li>\n<li>CVE-2016-1000344: DHIES allows the use of unsafe ECB mode. This algorithm is now removed from the provider.</li>\n<li>CVE-2016-1000345: DHIES/ECIES CBC mode vulnerable to padding oracle attack. For BC 1.55 and older, in an environment where timings can be easily observed, it is possible with enough observations to identify when the decryption is failing due to padding.</li>\n<li>CVE-2016-1000346: Other party DH public key not fully validated. This can cause issues as invalid keys can be used to reveal details about the other party's private key where static Diffie-Hellman is in use. As of this release the key parameters are checked on agreement calculation.</li>\n<li>CVE-2016-1000352: ECIES allows the use of unsafe ECB mode. This algorithm is now removed from the provider.</li>\n</ul>\n</ul>\n<h3>2.5.5 Security Advisory</h3>\n<ul>\n<li>We consider the carry propagation bugs fixed in this release to have been exploitable in previous releases (1.51-1.55), for static ECDH, to reveal the long-term key, per <a href=\"https://eprint.iacr.org/2011/633\">\"Practical realisation and elimination of an ECC-related software bug attack\", Brumley et.al.</a>. The most common case of this would be the non-ephemeral ECDH ciphersuites in TLS. These are not enabled by default in our TLS implementations, but they can be enabled explicitly by users. We recommend that users DO NOT enable static ECDH ciphersuites for TLS.</li>\n</ul>\n\n<h3>2.6.1 Version</h3>\nRelease: 1.55 <br/>\nDate:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2016, August 18\n<h3>2.6.2 Defects Fixed</h3>\n<ul>\n<li>Issues with cloning of blake digests with salts and personalisation strings have been fixed.</li>\n<li>The JceAsymmetricValueDecryptor in the CRMF package now attempts to recognise a wider range of parameters for the key wrapping algorithm, rather than relying on a default.</li>\n<li>GCM now fails if an attempt is made to go past 2^32-1 blocks.</li>\n<li>(r, k) ordering for Poly1305 has been modified to be brought into line with RFC 7539.</li>\n<li>An occasional error in Poly1305 due to sign-extension has been fixed.</li>\n<li>TimeStampRequest was always failing to validate if extensions were present. This has been fixed.</li>\n<li>ECIES/IES algorithm parameters encoding failed on default parameters. This has been fixed.</li>\n<li>PGPObjectFactory.iterator() could fail when called on data with multiple stream packets. This has been fixed.</li>\n<li>The McEliece implementation in the BCPQC provider has been revised and now has working key factories associated with it.</li>\n<li>The X.509 UserNotice class can now cope with empty sequences.</li>\n<li>Creation of multiple providers concurrently could cause issues with a non-synchronized Map in the provider. Code is now synchronized.</li>\n<li>If the lightweight OAEP encoder is fed oversized input it will now throw something more informative than an ArrayOutOfBoundsException or simply truncate.</li>\n<li>Attempting to use the PasswordRecipientInfoGenerator without explicitly setting the salt would cause a NullPointerException. This has been fixed.</li>\n<li>The BasicConstraintsValidation in the CertPath API would throw a NullPointerException on an unconstrained path length. This has been fixed.</li>\n<li>A shift error for > 24 bit numbers in TlsUtils has been fixed.</li>\n<li>OAEP encryption for a zero length message would create invalid cipher text. This has been fixed.</li>\n<li>Trying to use of non-default parameters for OAEP in CRMF would resort to the default parameter set. This has been fixed.</li>\n<li>If the BC provider was not registered, creating a CertificateFactory would cause a new provider object to be created. This has been fixed.</li>\n</ul>\n<h3>2.6.3 Additional Features and Functionality</h3>\n<ul>\n<li>The DANE API has been updated to reflect the latest standard changes.</li>\n<li>The signature algorithm SPHINCS-256 has been added to the post-quantum provider (BCPQC). Support is in place for SHA-512 and SHA3-512 (using trees based around SHA512_256 and SHA3_256 respectively).</li>\n<li>The key exchange algorithm NewHope has been added to the post-quantum provider (BCPQC). Support is in place for the regular configuration using SHA3-256 as the flattening algorithm for the agreed value.</li>\n<li>The CMS password recipient generator now allows the PRF to be changed to something other than SHA-1</li>\n<li>Direct support for the SignatureTarget packet has been added to the OpenPGP API.</li>\n<li>TLS: support for ClientHello Padding Extension (RFC 7685).</li>\n<li>TLS: support for ECDH_anon key exchange.</li>\n<li>Support has been added for HMAC SHA-3. Aliases have been added for NIST OIDs for SHA-3 HMAC as well.</li>\n<li>Support has been added for SHA-3 in DSA, ECDSA, DDSA, and ECDDSA. Aliases have been added for NIST OIDs for DSA and ECDSA as well.</li>\n<li>Support has been added for SHA-3 with RSA PKCS 1.5, PSS, and OAEP.</li>\n<li>Support has been added for GOST R 34.11-2012 to the provider and the lightweight API.</li>\n<li>PGP armored output can now be generated without a version string.</li>\n<li>The TimeStampTokenGenerator will now generate timestamps down to a millisecond resolution.</li>\n<li>Additional search methods have been added to PGP public and secret key rings.</li>\n</ul>\n\n<h3>2.7.1 Version</h3>\nRelease: 1.54 <br/>\nDate:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2015, December 29\n<h3>2.7.2 Defects Fixed</h3>\n<ul>\n<li>Blake2b-160, Blake2b-256, Blake2b-384, and Blake2b-512 are now actually in the provider and an issue with cloning Blake2b digests has been fixed.</li>\n<li>PKCS#5 Scheme 2 using DESede CBC is now supported by the PKCS#12 implementation.</li>\n<li>The IES engine would sometimes throw a \"too short\" exception on small messages which were the right length. This has been fixed.</li>\n<li>Cipher.getOutputSize() for IES ciphers would throw a ClassCastException. This has been fixed.</li>\n<li>It turns out, after advice one way and another that the NESSIE test vectors for Serpent are now what should be followed and that the vectors in the AES submission are regarded as an algorithm called Tnepres. The Serpent version now follows the NESSIE vectors, and the Tnepres cipher has been added to the provider and the lightweight API for compatibility.</li>\n<li>Problems with DTLS record-layer version handling were resolved, making version negotiation work properly.\n</ul>\n<h3>2.7.3 Additional Features and Functionality</h3>\n<ul>\n<li>Camellia and SEED key wrapping are now supported for CMS key agreement</li>\n<li>The BC TLS/DTLS code now includes a non-blocking API.</li>\n<li>CTR/SIC mode now support an internal counter. The internal counter can be turned on by passing an IV smaller than the block size of the cipher's algorithm.</li>\n<li>The lightweight CMS API operators now support CAST5 and RC2 CBC encryption.</li>\n<li>The CMS API now supports Diffie-Hellman as specified in RFC 3370.</li>\n<li>Support has been added to the CMS API for PKCS#7 ANY type encapsulated content where the encapsulated content is not an OCTET STRING.</li>\n<li>PSSSigner in the lightweight API now supports fixed salts.</li>\n</ul>\n<h3>2.7.4 Security Advisory</h3>\n<ul>\n<li>(D)TLS 1.2: Motivated by <a href=\"https://www.google.com/search?q=CVE-2015-7575\">CVE-2015-7575</a>, we have added validation that the signature algorithm received in DigitallySigned structures is actually one of those offered (in signature_algorithms extension or CertificateRequest). With our default TLS configuration, we do not believe there is an exploitable vulnerability in any earlier releases. Users that are customizing the signature_algorithms extension, or running a server supporting client authentication, are advised to double-check that they are not offering any signature algorithms involving MD5.</li>\n</ul>\n<h3>2.7.5 Notes</h3>\n<p>\nIf you have been using Serpent, you will need to either change to Tnepres, or take into account the fact that Serpent is now byte-swapped compared to what it was before.\n</p>\n\n<h3>2.8.1 Version</h3>\nRelease: 1.53 <br/>\nDate:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2015, October 10\n<h3>2.8.2 Defects Fixed</h3>\n<ul>\n<li>The BC JCE cipher implementations could sometimes fail when used in conjunction with the JSSE and NIO. This has been fixed.</li>\n<li>PGPPublicKey.getBitStrength() always returned 0 for EC keys. This has been fixed.</li>\n<li>A PKCS12 key store containing a looping certificate chain could cause an OutOfMemoryException. This has been fixed.</li>\n<li>A change in JDK 1.8 meant that X509Certificate.verify(PublicKey, Provider) would cause a stack overflow. This has been fixed.</li>\n<li>Nested multiparts with irregular post-amble could cause verification issues for the SMIMESigned classes. This has been fixed.</li>\n<li>CMSSignedData now supports verification of signed attributes where the calculated digest uses a different algorithm from the digest used in the signature.</li>\n<li>TRUSTED CERTIFICATE parsing in PEM files was ignoring the attribute block. A new class X509TrustedCertificateBlock is now returned containing both the certificate and the trust information.</li>\n<li>Adding a password to a PGP key which did not previously have one would result in an improperly formatted key. This has been fixed.</li>\n<li>ECIES/IES was only using a 4 byte label length for the MAC tag when it should have been an 8 byte one. This has now been fixed and OldECIES/OldIES has been added for backwards compatibility.</li>\n<li>The JceCRMFEncryptorBuilder was not recognising key size specific object identifiers properly. This has been fixed.</li>\n<li>The OpenPGP ClearSignedFileProcessor would not handle verification of single line files properly. This has been fixed.</li>\n<li>The BC X509Certificate class was no longer in agreement with the standard class for hashCode(). The BC X509Certificate class will now track the changes made in the standard Java distribution.</li>\n<li>PGP signature hashed sub-packets with long length encodings would fail to validate on signature checking. This has been fixed.</li>\n<li>The S/MIME API would occasionally leak InputStreams which could cause issues with custom DataSource implementations. This has been fixed.</li>\n<li>The PKCS#12 KeyStore implementation would sometimes leave orphaned chain certificates in the key store after private key deletion. This has been fixed.</li>\n<li>A bug in the DirectKeySignature OpenPGP example which could lead to extra data appearing in the signature has been fixed.</li>\n<li>Explicit configuration of a BcAsymmetricKeyWrapper with a SecureRandom was not properly propagated internally. This has been fixed.</li>\n<li>A CRL with a null certificate issuer would sometimes result in a NullPointerException during CertPathProcessing. This has been fixed.</li>\n<li>The CertPath processor would occasionally fail to match a DistributionPoint name correctly. This has been fixed.</li>\n<li>In order to avoid confusion about thread safety, BCrypt now uses a new instance for hash calculation every time it is invoked.</li>\n<li>Some decidedly odd argument casting in the PKIXCertPathValidator has been fixed to throw an InvalidAlgorithmParameterException.</li>\n<li>Presenting an empty array of certificates to the PKIXCertPathValidator would cause an IndexOutOfRangeException instead of a CertPathValidatorException. This has been fixed.</li>\n</ul>\n<h3>2.8.3 Additional Features and Functionality</h3>\n<ul>\n<li>It is now possible to specify that an unwrapped key must be usable by a software provider in the asymmetric unwrappers for CMS.</li>\n<li>A Blake2b implementation has been added to the provider and lightweight API.</li>\n<li>SHA3 has now been added to the provider and the lightweight API. SHAKE128 and SHAKE256 have also been added to the lightweight API. The original implementation of the draft standard has been renamed to Keccak.</li>\n<li>The CMS API now supports RFC 6211 for both SignedData and AuthenticatedData.</li>\n<li>The ASN.1 parser for ECGOST private keys will now parse keys encoded with a private value represented as an ASN.1 INTEGER.</li>\n<li>EAX mode and CMAC is now supported for ciphers such as SHACAL-2 and Threefish.</li>\n<li>The SM4 block cipher has been added to the provider and the lightweight API.</li>\n<li>X9.31, ISO9796/2, and PSS signature support has been added for SHA512/224, SHA512/256.</li>\n<li>SubjectPublicKeyInfoFactory now supports DSA parameters.</li>\n<li>A range of new algorithms are now support for EC key agreement.</li>\n<li>EC ContentSigners and EC ContentVerifiers have been added to the lightweight operator package in the PKIX APIs.</li>\n<li>The PKCS#12 key store will now garbage collect orphaned certificates on saving.</li>\n<li>Caching for ASN.1 ObjectIdentifiers has been rewritten to make use of an intern method. The \"usual suspects\" are now interned automatically, and the cache is used by the parser. Other OIDs can be added to the cache by calling ASN1ObjectIdentifier.intern().</li>\n</ul>\n<h3>2.8.4 Notes</h3>\n<p>\nIt turns out there was a similar, but different, issue in Crypto++ to the BC issue with ECIES. Crypto++ 6.0 now offers a corrected version of ECIES which is compatible with that which is now in BC.\n</p>\n\n<h3>2.9.1 Version</h3>\nRelease: 1.52<br/>\nDate:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2015, March 2\n<h3>2.9.2 Defects Fixed</h3>\n<ul>\n<li>GenericSigner in the lightweight API would fail if the digest started with a zero byte, occasionally causing a TLS negotiation to fail. This has been fixed.</li>\n<li>Some BC internal classes expected the BC provider to be accessible within the provider. This has been fixed.</li>\n<li>Email based policy constraints in CertPath validation did not include '@'domain.name as a possible match. This has been fixed.</li>\n<li>The Shacal2Engine would throw an ArrayIndexOutOfBoundsException if presented with input longer than a block size. This has been fixed.</li>\n<li>Using PKCS5/PKCS7 with pad values greater than 127 would result in an exception on decryption. This has been fixed.</li>\n<li>EC private key values could encode to an OCTET STRING which was shorter than that described in RFC 5915/SEC 1. This has been fixed.</li>\n<li>Providing multiple trust anchors to the CertPath validator could cause a StackOverflowError on an invalid CertPath. This has been fixed.</li>\n<li>TLS: bad-padding handling when encrypt-then-MAC enabled is now fixed.</li>\n<li>ECDH KeyAgreement.init() was not properly honoring the JCE API in respect to non-null parameters. This has been fixed.</li>\n<li>PKCS symmetric padding now takes into account pad lengths of more than 127 bytes.</li>\n<li>Corrupted input to RFC5649WrapEngine could cause an out of memory error. This has been fixed.</li>\n<li>OSGI import issues for bcmail have been fixed.</li>\n<li>A badly formed issuer in a X.509 certificate could cause a null pointer exception in X509CertificateHolder.toString(). This has been fixed.</li>\n<li>CMSSignedData.verifySignatures() could fail on a correct counter signature due to a mismatch of the SID. This has been fixed.</li>\n</ul>\n<h3>2.9.3 Additional Features and Functionality</h3>\n<ul>\n<li>The CMP support class CMPCertificate restricted the types of certificates that could be added. A more flexible method has been introduced to allow for other certificate types.</li>\n<li>Support classes have be added for DNS-based Authentication of Named Entities (DANE) to the PKIX distribution.</li>\n<li>Work has been done to reduce computation requirements for long skips associated with implementations of the SkippingCipher interface.</li>\n<li>AES GCM mode is now supported by CMS EnvelopedData.</li>\n<li>Iteration count is now settable in BcPKCS12MacCalculatorBuilder.</li>\n<li>Support for BCrypt and it's OpenBSD variant has been added to the lightweight API.</li>\n<li>It's now possible to specify the direction of the underlying cipher used for key wrapping with NIST/RFC3394 wrappers.</li>\n<li>TLS: server-side support for DHE key exchange.</li>\n<li>TLS: server-side support for PSK and SRP ciphersuites.</li>\n<li>TLS: (EC)DSA now supports signatures with non-SHA1 digests.</li>\n<li>TLS: support for ECDHE_ECDSA/AES/CCM ciphersuites from RFC 7251.</li>\n<li>Cipher.getIV() now returns nonces for AEAD modes.</li>\n<li>OIDs for dhPublicNumber and dhKeyAgreement are now supported by the provider.</li>\n<li>OIDs for several signature types using the RIPEMD family of digests have been added to the provider.</li>\n<li>JcaJceUtils.getDigestAlgName() has been added to assist in converting OIDs representing message digests into JCA algorithm names.</li>\n<li>BasicOCSPResp.getSignatureAlgorithmID() has been added to allow algorithm indentifier details to be returned from a basic OCSP response.</li>\n<li>Additional OIDs have been added for OCSP.</li>\n<li>X509CRLObject.getSignAlgName() now attempts to return an actual name, rather than an OID for, for the signature algorithm.</li>\n<li>SignedMailValidator now pays attention to the date in the PKIXParameters object if it is set.</li>\n<li>A missing signing time in a signature no longer causes SignedMailValidator to fail a signature, but provide a warning instead.</li>\n<li>An AlgorithmNameFinder implementation has been added to the PKIX API to provide \"human friendly\" translations of algorithm OIDs.</li>\n<li>Support has been added for X9.31-1998 DRBG and X9.31-1998 RSA signatures to the lightweight API and the provider.</li>\n<li>CertPath validator will now make use of the issuer key identifier and the issuer name if a key identifier is available for the issuer.</li>\n<li>Support for some JDK1.5+ language features has finally made its way into the repository.</li>\n</ul>\n<h3>2.9.4 Security Advisory</h3>\n<ul>\n<li>The CTR DRBGs would not populate some bytes in the requested block of random bytes if the size of the block requested was not an exact multiple of the block size of the underlying cipher being used in the DRBG. If you are using the CTR DRBGs with \"odd\" keysizes, we strongly advise upgrading to this release, or contacting us for a work around.</li>\n</ul>\n\n<h3>2.10.1 Version</h3>\nRelease: 1.51<br />\nDate:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2014, July 28\n<h3>2.10.2 Defects Fixed</h3>\n<ul>\n<li>The AEAD GCM AlgorithmParameters object was unable to return a GCMParameterSpec object. This has been fixed.</li>\n<li>Cipher.getIV() was returning null for AEAD mode ciphers. This has been fixed.</li>\n<li>CipherInputStream would fail for some AEAD mode ciphers if the message was over 4k in length. This has been fixed.</li>\n<li>The JCE provider will now produce simple RSAPrivateKey objects where CRT coefficients are not provided.</li>\n<li>PGP key signature certifications did not support DIRECT KEY signatures. This has been fixed.</li>\n<li>User Attribute subpackets in PGP with long length encodings could result in certification verification failing. This has been fixed.</li>\n<li>Calls to  CommandMap.setDefaultCommandMap() in the SMIME API are now wrapped in doPrivileged() blocks to allow them to work with a security manager.</li>\n<li>The encoding of the certificate_authorities field of a TLS CertificateRequest has been fixed.</li>\n<li>EC point formats are now strictly enforced in the TLS API.</li>\n<li>The provider implementation was failing to throw an exception if algorithm parameters were passed in when none were required for EC key agreement. This has been fixed.</li>\n<li>PKCS#12 files containing keys/certificates with empty attribute sets attached to them no longer cause an ArrayIndexOutOfBoundsException to be thrown.</li>\n<li>Issues with certificate verification and server side DTLS/TLS 1.2 have now been fixed.</li>\n</ul>\n<h3>2.10.3 Additional Features and Functionality</h3>\n<ul>\n<li>The range of key algorithm names that will be interpreted by KeyAgreement.generateSecret() has been expanded for ECDH derived algorithms in the provider. A KeyAgreement of ECDHwithSHA1KDF can now be explicitly created.</li>\n<li>ECIES now supports the use of IVs with the underlying block cipher and CBC mode in both the lightweight and the JCE APIs.</li>\n<li>Support has been add for RFC5649 key wrapping using AES.</li>\n<li>The PGP API now allows access and handling of User IDs as raw byte arrays, to deal with keyrings not using UTF-8.</li>\n<li>The PGP API now provides automatic conversion of embedded signatures in signature sub-packet vectors.</li>\n<li>The PGP API now fully supports ECDH as outlined in RFC 6637.</li>\n<li>GCM and GMAC now support tag lengths down to 32 bits.</li>\n<li>Custom implementations for many of the SEC Fp curves have been added, resulting in drastically improved performance. The current list includes all secp***k1 and secp***r1 curves from 192 to 521 bits. They can be accessed via the org.bouncycastle.crypto.ec.CustomNamedCurves class and are generally selected by other internal APIs in place of the generic implementations.</li>\n<li>Automatic EC point validation added, both for decoded inputs and multiplier outputs.</li>\n<li>A SkippingCipher interface has been added for ciphers that can be moved into a specific state for a given byte address. The lightweight class StreamBlockCipher has been generalised to support any BlockCipher object that can support a streaming mode.</li>\n<li>ASN.1 date/time objects now support the passing in of a Locale to allow for constructing the object using a Date interpreted from a different locale to the default for the JVM.</li>\n<li>The range of Diffie-Hellman OIDs recognised by the provider has been extended.</li>\n<li>Some utility methods for interpreting OIDs have been exposed in the JcaJceUtils class.</li>\n<li>A method has been added to CMSSignedData for replacing the OCSP responses associated with a signed message.</li>\n<li>Use of RC2/RC4 in the CMS is now provider independent.</li>\n<li>TlsInputStream now provides a means of supporting InputStream.available().</li>\n<li>Dependencies on the JCA have been removed from PGPObjectFactory.</li>\n<li>Further work has been done on improving key quality with EC and DSA algorithms.</li>\n<li>KDFCounterBytesGenerator now supports suffix and prefix fixed input data, as outlined in NIST SP 800-108.</li>\n<li>Support has been added to allow retrieval and resetting the internal state of the SHA/SHA-2 digests in the lightweight API using an encoded format.</li>\n<li>BSI plain ECDSA is now supported by the provider.</li>\n<li>The provider now advertises RSA PSS signature implementations directly using the standard naming.</li>\n<li>Full support is now provided for client-side auth in the D/TLS server code.</li>\n<li>Compatibility issues with some OSGI containers have been addressed.</li>\n</ul>\n<h3>2.10.4 Notes</h3>\n<ul>\n<li>Support for NTRUSigner has been deprecated as the algorithm has been withdrawn.</li>\n<li>Some changes have affected the return values of some methods. If you are migrating from an earlier release, it is recommended to recompile before using this release.</li>\n<li>There has been further clean out of deprecated methods in this release. If your code has previously been flagged as using a deprecated method you may need to change it. The OpenPGP API is the most heavily affected.</li>\n</ul>\n<h3>2.11.1 Version</h3>\nRelease: 1.50<br />\nDate:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2013, December 3\n<h3>2.11.2 Defects Fixed</h3>\n<ul>\n<li>The DualECSP800DRBG sometimes truncated the last block in the generated stream incorrectly. This has been fixed.</li>\n<li>Keys produced from RSA certificates with specialised parameters would lose the parameter settings. This has been fixed.</li>\n<li>OAEP parameters were being ignored on CMS key trans recipient processing. This has been fixed.</li>\n<li>OpenPGP NotationData was restricting the name and value lengths to 255 characters and truncating silently. This has been fixed.</li>\n<li>CTS mode is now in alignment with the errata for RFC 2040, as detailed in RFC 3962.</li>\n<li>Occasionally the provider implementation of DH KeyAgreement would drop a leading zero byte off the start of the shared secret (see RFC 2631 2.1.2). This has been fixed.</li>\n<li>RFC3394WrapEngine was ignoring the offset parameter inOff and using zero instead. This has been fixed.</li>\n<li>GOST keys would not encode using the CryptoPro parameter set, even if it was available. This has been fixed.</li>\n<li>The TimeStampRequest stream constructor was not setting the extensions field correctly. This has been fixed.</li>\n<li>Default RC2 parameters for 40 bit RC2 keys in CMSEnvelopedData were encoding incorrectly. This has been fixed.</li>\n<li>In case of a long hash the DSTU4145 implementation would sometimes remove one bit too much during truncation. This has been fixed.</li>\n</ul>\n<h3>2.11.3 Additional Features and Functionality</h3>\n<ul>\n<li>Additional work has been done on CMS recipient generation to simplify the generation of OAEP encrypted messages and allow for non-default parameters.</li>\n<li>OCB implementation updated to account for changes in draft-irtf-cfrg-ocb-03.</li>\n<li>RFC 6637 ECDSA and ECDH support has been added to the OpenPGP API.</li>\n<li>Implementations of Threefish and Skein have been added to the provider and the lightweight API.</li>\n<li>Implementations of the SM3 digest have been added to the provider and the lightweight API.</li>\n<li>The 3 MAC based KDF generators in NIST SP 800-108 have been added to the lightweight API.</li>\n<li>Support has been added for the GOST PKCS#5 PBKDF2 PBE function and handling of GOST PKCS#12 files.</li>\n<li>Support has been added for the CryptoPro GOST CFB mode key meshing.</li>\n<li>Implementations of XSalsa20 and ChaCha have been added. Support for reduced round Salas20 has been added.</li>\n<li>Support has been added for RFC 6979 Determinstic DSA/ECDSA to the provider and the lightweight API.</li>\n<li>Support for RC2 and RC4 in the CMS API has been generalised to work for other JCE providers.</li>\n<li>Support for the Poly1305 MAC has been added to the lightweight API and the JCE Provider.</li>\n<li>OpenSSL JcaPEMKeyConverter now supports OIDs for RSA and DSA as well as ECDSA.</li>\n<li>A simplified certificate path API has been added to the PKIX package. It is not fully NIST compliant yet, however it does provide a range of basic validations without having to use the JCA.</li>\n<li>Package version information is now included in the jar MANIFEST.MF.</li>\n<li>The JDK 1.5+ provider will now recognise and use GCMParameterSpec if it is run in a 1.7 JVM.</li>\n<li>Client side support and some server side support has been added for TLS/DTLS 1.2.</li>\n</ul>\n<h3>2.11.4 Notes</h3>\n<ul>\n<li>org.bouncycastle.crypto.DerivationFunction is now a base interface, the getDigest() method appears on DigestDerivationFunction.</li>\n<li>Recent developments at NIST indicate the SHA-3 may be changed before final standardisation. Please bare this in mind if you are using it.</li>\n<li>Other recent developments have raised concerns about the DualECDRBG. We have left the class in place for now, but it is now possible to provide your own parameter values, rather than using the NIST defined ones, if you choose to do so.</li>\n<li>Most deprecated methods have been removed from the PKIX API.</li>\n<li>As the IDEA patent has finally expired, IDEA is now supported by the standard provider.</li>\n<li>ECDH support for OpenPGP should still be regarded as experimental. It is still possible there will be compliance issues with other implementations.</li>\n</ul>\n\n<h3>2.12.1 Version</h3>\nRelease: 1.49<br />\nDate:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2013, May 31\n<h3>2.12.2 Defects Fixed</h3>\n<ul>\n<li>Occasional ArrayOutOfBounds exception in DSTU-4145 signature generation has been fixed.</li>\n<li>The handling of escaped characters in X500 names is much improved.</li>\n<li>The BC CertificateFactory no longer returns null for CertificateFactory.getCertPathEncodings().</li>\n<li>PKCS10CertificationRequestBuilder now encodes no attributes as empty by default. Encoding as absent is still available via a boolean flag.</li>\n<li>DERT61String has been reverted back to its previous implementation. A new class DERT61UTF8String has been introduced which defaults to UTF-8 encoding.</li>\n<li>OAEPEncoding could throw an array output bounds exception for small keys with large mask function digests. This has been fixed.</li>\n<li>PEMParser would throw a NullPointerException if it ran into explicit EC curve parameters, it would also throw an Exception if the named curve was not already defined. The parser now returns X9ECParmameters for explicit parameters and returns an ASN1ObjectIdentifier for a named curve.</li>\n<li>The V2TBSCertListGenerator was adding the wrong date type for CRL invalidity date extensions. This has been fixed.</li>\n</ul>\n<h3>2.12.3 Additional Features and Functionality</h3>\n<ul>\n<li>A SecretKeyFactory has been added that enables use of PBKDF2WithHmacSHA.</li>\n<li>Support has been added to PKCS12 KeyStores and PfxPdu to handle PKCS#5 encrypted private keys.</li>\n<li>Support has been added for SHA-512/224, SHA-512/256, as well as a general SHA-512/t in the lightweight API.</li>\n<li>The JcaPGPPrivateKey class has been added to provide better support in the PGP API for HSM private keys.</li>\n<li>A new KeyStore type, BKS-V1, has been added for people needing to create key stores compatible with earlier versions of Bouncy Castle.</li>\n<li>Some extra generation methods have been added to TimeStampResponseGenerator to allow more control in the generation of TimeStampResponses.</li>\n<li>It is now possible to override the SignerInfo attributes during TimeStampTokenGeneration.</li>\n<li>The TSP API now supports generation of certIDs based on digests other than SHA-1.</li>\n<li>OCSP responses can now be included in CMS SignedData objects.</li>\n<li>The SipHash MAC algorithm has been added to the lightweight API and the provider.</li>\n<li>ISO9796-2 PSS signatures can now be initialised with a signature to allow the signer to deal with odd recovered message lengths on verification.</li>\n<li>The 4 DRBGs described in NIST SP 800-90A have been added to the prng package together with SecureRandom builders.</li>\n<li>Support has been added for OCB mode in the lightweight API.</li>\n<li>DSA version 2 parameter and key generation is now supported in the provider and lightweight API.</li>\n<li>A new interface Memoable has been added for objects that can copy in and out their state. The digest classes now support this. A special\nclass NonMemoableDigest has been added which hides the Memoable interface where it should not be available.</li>\n<li>TDEA is now recognised as an alias for DESede.</li>\n<li>A new package org.bouncycastle.crypto.ec has been introduced to the light wieght API with a range of EC based cryptographic operators.</li>\n<li>The OpenPGP API now supports password changing on V3 keys if the appropriate PBEKeyEncryptor is used.</li>\n<li>The OpenPGP API now supports password changing on secret key rings where only the private keys for the subkeys have been exported.</li>\n<li>Support has been added to the lightweight API for RSA-KEM and ECIES-KEM.</li>\n<li>Support has been added for NIST SP 800-38D - GMAC to AES and other 128 bit block size algorithms.</li>\n<li>The org.bouncycastle.crypto.tls package has been extended to support client and server side TLS 1.1.</li>\n<li>The org.bouncycastle.crypto.tls package has been extended to support client and server side DTLS 1.0.</li>\n<li>A basic commitment package has been introduced into the lightweight API containing a digest based commitment scheme.</li>\n<li>It is now possible to set the NotAfter and NotBefore date in the CRMF CertificateRequestMessageBuilder class.</li>\n</ul>\n<h3>2.12.4 Notes</h3>\n<ul>\n<li>The NTRU implementation has been moved into the org.bouncycastle.pqc package hierarchy.</li>\n<li>The change to PEMParser to support explicit EC curves is not backward compatible. If you run into a named curve you need to use org.bouncycastle.asn1.x9.ECNamedCurveTable.getByOID() to look the curve up if required.</li>\n</ul>\n\n<h3>2.13.1 Version</h3>\nRelease: 1.48<br />\nDate:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2013, February 10\n<h3>2.13.2 Defects Fixed</h3>\n<ul>\n<li>Occasional key compatibility issues in IES due to variable length keys have been fixed.</li>\n<li>PEMWriter now recognises the new PKCS10CertificationRequest object.</li>\n<li>The provider implementation for RSA now resets when the init method is called.</li>\n<li>SignerInformation has been rewritten to better support signers without any associated signed attributes.</li>\n<li>An issue with an incorrect version number of SignedData associated with the use of SubjectKeyIdentifiers has now been fixed.</li>\n<li>An issue with the equals() check in BCStrictStyle has been fixed.</li>\n<li>The BC SSL implementation has been modified to deal with the \"Lucky Thirteen\" attack.</li>\n<li>A regression in 1.47 which prevented key wrapping with regular symmetric PBE algorihtms has been fixed.</li>\n</ul>\n\n<h3>2.13.3 Additional Features and Functionality</h3>\n<ul>\n<li>IES now supports auto generation of ephemeral keys in both the JCE and the lightweight APIs.</li>\n<li>A new class PEMParser has been added to return the new CertificateHolder and Request objects introduced recently.</li>\n<li>An implementation of Password Authenticated Key Exchange by Juggling (J-PAKE) has now been added to the lightweight API.</li>\n<li>Support has now been added for the DSTU-4145-2002 to the lightweight API and the provider.</li>\n<li>The BC X509Certificate implementation now provides support for the JCA methods X509Certificate.getSubjectAlternativeNames() and X509Certificate.getIssuerAlternativeNames().</li>\n<li>PEMReader can now be configured to support different providers for encyrption and public key decoding.</li>\n<li>Some extra DSA OIDs have been added to the supported list for the provider.</li>\n<li>The BC provider will now automatically try to interpret other provider software EC private keys. It is no longer necessary to use a KeyFactory for conversion.</li>\n<li>A new provider, the BCPQ (for BC Post Quantum) provider has been added with support for the Rainbow signature algorithm and the McEliece family of encryption algorithms.</li>\n<li>Support has been added for the SHA3 family of digests to both the provider and the lightweight API.</li>\n<li>T61String now uses UTF-8 encoding by default rather than a simple 8 bit transform.</li>\n</ul>\n\n<h3>2.14.1 Version</h3>\nRelease: 1.47<br/>\nDate:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2012, March 30\n<h3>2.14.2 Defects Fixed</h3>\n<ul>\n<li>OpenPGP ID based certifications now support UTF-8. Note: this may mean that some old certifications no longer validate - if this happens a retry can be added using by converting the ID using Strings.fromByteArray(Strings.toByteArray(id)) - this will strip out the top byte in each character.</li>\n<li>IPv4/IPv6 parsing in CIDR no longer assumes octet boundaries on a mask.</li>\n<li>The CRL PKIX routines will now only rebuild the CRL as a last resort when looking for the certificate issuer.</li>\n<li>The DEK-Info header in PEM generation was lower case. It is now upper case in accordance with RFC 1421.</li>\n<li>An occasional issue causing an OutOfMemoryException for PGP compressed data generation has now been fixed.</li>\n<li>An illegal argument exception that could occur with multi-valued RDNs in the X509v3CertificateBuilder has been fixed.</li>\n<li>Shared secret calculation in IES could occasionally add a leading zero byte. This has been fixed.</li>\n<li>PEMReader would choke on a private key with an empty password. This has been fixed.</li>\n<li>The default MAC for a BKS key store was 2 bytes, this has been upgraded to 20 bytes.</li>\n<li>BKS key store loading no longer freezes on negative iteration counts.</li>\n<li>A regression in 1.46 which prevented parsing of PEM files with extra text at the start has been fixed.</li>\n<li>CMS secret key generation now attempts to stop use of invalid lengths with OIDs that predefine a key length.</li>\n<li>Check of DH parameter L could reject some valid keys. This is now fixed.</li>\n</ul>\n\n<h3>2.14.3 Additional Features and Functionality</h3>\n<ul>\n<li>Support is now provided via the RepeatedKey class to enable IV only re-initialisation in the JCE layer. The same effect can be acheived in the light weight API by using null as the key parameter when creating a ParametersWithIV object.</li>\n<li>CRMF now supports empty poposkInput.</li>\n<li>The OpenPGP API now supports operator based interfaces for most operations and lightweight implementations have been added for JCE related functionality.</li>\n<li>JcaSignerId and JceRecipientId will now match on serial number, issuer, and the subject key identifier if it's available.</li>\n<li>CMS Enveloped and AuthenticatedData now support OriginatorInfo.</li>\n<li>NTRU encryption and signing is now provided in the lightweight source and the ext version of the provider.</li>\n<li>There is now API support for Extended Access Control (EAC).</li>\n<li>The performance of CertPath building and validation has been improved.</li>\n<li>The TLS Java Client API has been updated to make support for GSI GSSAPI possible.</li>\n<li>Support for ECDSA_fixed_ECDH authentication has been added to the TLS client.</li>\n<li>Support for the Features signature sub-packet has been added to the PGP API.</li>\n<li>The number of lightweight operators for PGP and CMS/SMIME has been increased.</li>\n<li>Classes involved in CRL manipulation have been rewritten to reduce memory requirements for handling and parsing extremely large CRLs.</li>\n<li>RFC 5751 changed the definition of the micalg parameters defined in RFC 3851. The SMIMESignedGenerator is now up to date with the latest micalg parameter set and a constructor has been added to allow the old micalg parameter set to be used.</li>\n<li>An operator based framework has been added for processing PKCS#8 and PKCS#12 files.</li>\n<li>The J2ME lcrypto release now includes higher level classes for handling PKCS, CMS, CRMF, CMP, EAC, OpenPGP, and certificate generation.</li>\n</ul>\n\n<h3>2.14.4 Other notes</h3>\n<p>\nOkay, so we have had to do another release. The issue we have run into is that we probably didn't go far enough in 1.46, but we are now confident that moving from this release to 2.0 should be largely just getting rid of deprecated methods. While this release does change a lot it is relatively straight forward to do a port and we have a <a href=\"http://www.bouncycastle.org/wiki/display/JA1/Porting+from+earlier+BC+releases+to+1.47+and+later\">porting guide</a> which explains the important ones. The area there has been the most change in is the ASN.1 library which was in bad need of a rewrite after 10 years of patching. On the bright side the rewrite did allow us to eliminate a few problems and bugs in the ASN.1 library, so we have some hope anyone porting to it will also have similar benefits. As with 1.46 the other point of emphasis has been making sure interface support is available for operations across the major APIs, so the lightweight API or some local role your own methods can be used instead for doing encryption and signing.\n</p>\n\n<h3>2.15.1 Version</h3>\nRelease: 1.46</br>\nDate:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2011, February 23\n<h3>2.15.2 Defects Fixed</h3>\n<ul>\n<li>An edge condition in ECDSA which could result in an invalid signature has been fixed.</li>\n<li>Exhaustive testing has been performed on the ASN.1 parser, eliminating another potential OutOfMemoryException and several escaping run time exceptions.</li>\n<li>BC generated certificates generated different hashCodes from other equivalent implementations. This has been fixed.</li>\n<li>Parsing an ESSCertIDv2 would fail if the object did not include an IssuerSerialNumber. This has been fixed.</li>\n<li>DERGeneralizedTime.getDate() would produce incorrect results for fractional seconds. This has been fixed.</li>\n<li>PSSSigner would produce incorrect results if the MGF digest and content digest were not the same. This has been fixed.</li>\n</ul>\n<h3>2.15.3 Additional Features and Functionality</h3>\n<ul>\n<li>A null genTime can be passed to TimeStampResponseGenerator.generate() to generate timeNotAvailable error responses.</li>\n<li>Support has been added for reading and writing of openssl PKCS#8 encrypted keys.</li>\n<li>New streams have been added for supporting general creation of PEM data, and allowing for estimation of output size on generation. Generators have been added for some of the standard OpenSSL objects.</li>\n<li>CRL searching for CertPath validation now supports the optional algorithm given in Section 6.3.3 of RFC 5280, allowing the latest CRL to be used for a set time providing the certificate is unexpired.</li>\n<li>AES-CMAC and DESede-CMAC have been added to the JCE provider.</li>\n<li>Support for CRMF (RFC 4211) and CMP (RFC 4210) has been added.</li>\n<li>BufferedBlockCipher will now always reset after a doFinal().</li>\n<li>Support for CMS TimeStampedData (RFC 5544) has been added.</li>\n<li>JCE EC keypairs are now serialisable.</li>\n<li>TLS now supports client-side authentication.</li>\n<li>TLS now supports compression.</li>\n<li>TLS now supports ECC cipher suites (RFC 4492).</li>\n<li>PGP public subkeys can now be separately decoded and encoded.</li>\n<li>An IV can now be passed to an ISO9797Alg3Mac.</li>\n</ul>\n<h3>2.15.4 Other notes</h3>\n<p>\nBaring security patches we expect 1.46 will be the last of the 1.* releases. The next release of\nBC will be version 2.0. For this reason a lot of things in 1.46 that relate to CMS have been deprecated and\nnew methods have been added to the CMS and certificate handling APIs which provide greater flexibility\nin how digest and signature algorithms get used. It is now possible to use the lightweight API or a simple\ncustom API with CMS and for certificate generation. In addition a lot of methods and some classes that were\ndeprecated for reasons of been confusing, or in some cases just plan wrong, have been removed. \n</p>\n<p>\nSo there are four things useful to know about this release:\n<ul>\n<li>It's not a simple drop in like previous releases, if you wish migrate to it you will need to recompile your application.</li>\n<li>If you avoid deprecated methods it should be relatively painless to move to version 2.0</li>\n<li>The X509Name class will utlimately be replacde with the X500Name class, the getInstance() methods on both these classes allow conversion from one type to another.</li>\n<li>The org.bouncycastle.cms.RecipientId class now has a collection of subclasses to allow for more specific recipient matching. If you are creating your own recipient ids you should use the constructors for the subclasses rather than relying on the set methods inherited from X509CertSelector. The dependencies on X509CertSelector and CertStore will be removed from the version 2 CMS API.</li>\n</ul>\n</p>\n<h3>2.16.1 Version</h3>\nRelease: 1.45<br/>\nDate:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2010, January 12\n<h3>2.16.2 Defects Fixed</h3>\n<ul>\n<li>OpenPGP now supports UTF-8 in file names for literal data.</li>\n<li>The ASN.1 library was losing track of the stream limit in a couple of places, leading to the potential of an OutOfMemoryError on a badly corrupted stream. This has been fixed.</li>\n<li>The provider now uses a privileged block for initialisation.</li>\n<li>JCE/JCA EC keys are now serialisable.</li>\n</ul>\n<h3>2.16.3 Additional Features and Functionality</h3>\n<ul>\n<li>Support for EC MQV has been added to the light weight API, provider, and the CMS/SMIME library.</li>\n</ul>\n<h3>2.16.4 Security Advisory</h3>\n<ul>\n<li>This version of the provider has been specifically reviewed to eliminate possible timing attacks on algorithms such as GCM and CCM mode.</li>\n</ul>\n\n<h3>2.17.1 Version</h3>\nRelease: 1.44<br/>\nDate:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2009, October 9\n<h3>2.17.2 Defects Fixed</h3>\n<ul>\n<li>The reset() method in BufferedAsymmetricBlockCipher is now fully clearing the buffer.</li>\n<li>Use of ImplicitlyCA with KeyFactory and Sun keyspec no longer causes NullPointerException.</li>\n<li>X509DefaultEntryConverter was not recognising telephone number as a PrintableString field. This has been fixed.</li>\n<li>The SecureRandom in the J2ME was not using a common seed source, which made cross seeeding of SecureRandom's impossible. This has been fixed.</li>\n<li>Occasional uses of \"private final\" on methods were causing issues with some J2ME platforms. The use of \"private final\" on methods has been removed.</li>\n<li>NONEwithDSA was not resetting correctly on verify() or sign(). This has been fixed.</li>\n<li>Fractional seconds in a GeneralisedTime were resulting in incorrect date conversions if more than 3 decimal places were included due to the Java date parser. Fractional seconds are now truncated to 3 decimal places on conversion.</li>\n<li>The micAlg in S/MIME signed messages was not always including the hash algorithm for previous signers. This has been fixed.</li>\n<li>SignedMailValidator was only including the From header and ignoring the Sender header in validating the email address. This has been fixed.</li>\n<li>The PKCS#12 keystore would throw a NullPointerException if a null password was passed in. This has been fixed.</li>\n<li>CertRepMessage.getResponse() was attempting to return the wrong underlying field in the structure. This has been fixed.</li>\n<li>PKIXCertPathReviewer.getTrustAnchor() could occasionally cause a null pointer exception or an exception due to conflicting trust anchors. This has been fixed.</li>\n<li>Handling of explicit CommandMap objects with the generation of S/MIME messages has been improved.</li>\n</ul>\n<h3>2.17.3 Additional Features and Functionality</h3>\n<ul>\n<li>PEMReader/PEMWriter now support encrypted EC keys.</li>\n<li>BC generated EC private keys now include optional fields required by OpenSSL.</li>\n<li>Support for PSS signatures has been added to CMS and S/MIME.</li>\n<li>CMS processing will attempt to recover if there is no AlgorithmParameters object for a provider and use an IvParameterSpec where possible.</li>\n<li>CertificateID always required a provider to be explicitly set. A null provider is now interpreted as a request to use the default provider.</li>\n<li>SubjectKeyIdentifier now supports both methods specified in RFC 3280, section 4.2.1.2 for generating the identifier.</li>\n<li>Performance of GCM mode has been greatly improved (on average 10x).</li>\n<li>The BC provider has been updated to support the JSSE in providing ECDH.</li>\n<li>Support for mac lengths of 96, 104, 112, and 120 bits has been added to existing support for 128 bits in GCMBlockCipher.</li>\n<li>General work has been done on trying to propagate exception causes more effectively.</li>\n<li>Support for loading GOST 34.10-2001 keys has been improved in the provider.</li>\n<li>Support for raw signatures has been extended to RSA and RSA-PSS in the provider. RSA support can be used in CMSSignedDataStreamGenerator to support signatures without signed attributes.</li>\n</ul>\n\n<h3>2.18.1 Version</h3>\nRelease: 1.43<br/>\nDate:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2009, April 13\n<h3>2.18.2 Defects Fixed</h3>\n<ul>\n<li>Multiple countersignature attributes are now correctly collected.</li>\n<li>Two bugs in HC-128 and HC-256 related to sign extension and byte swapping have been fixed. The implementations now pass the latest ecrypt vector tests.</li>\n<li>X509Name.hashCode() is now consistent with equals.</li>\n</ul>\n<h3>2.18.3 Security Advisory</h3>\n<ul>\n<li>The effect of the sign extension bug was to decrease the key space the HC-128 and HC-256 ciphers were operating in and the byte swapping inverted every 32 bits of the generated stream. If you are using either HC-128 or HC-256 you must upgrade to this release.</li>\n</ul>\n\n<h3>2.19.1 Version</h3>\nRelease: 1.42<br/>\nDate:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2009, March 16\n<h3>2.19.2 Defects Fixed</h3>\n<ul>\n<li>A NullPointer exception which could be result from generating a diffie-hellman key has been fixed.</li>\n<li>CertPath validation could occasionally mistakenly identify a delta CRL. This has been fixed.</li>\n<li>'=' inside a X509Name/X509Principal was not being properly escaped. This has been fixed.</li>\n<li>ApplicationSpecific ASN.1 tags are now recognised in BER data. The getObject() method now handles processing of arbitrary tags.</li>\n<li>X509CertStoreSelector.getInstance() was not propagating the subjectAlternativeNames attribute. This has been fixed.</li>\n<li>Use of the BC PKCS#12 implementation required the BC provider to be registered explicitly with the JCE. This has been fixed.</li>\n<li>OpenPGP now fully supports use of the Provider object.</li>\n<li>CMS now fully supports use of the Provider object.</li>\n<li>Multiplication by negative powers of two is fixed in BigInteger.</li>\n<li>OptionalValidity now encodes correctly.</li>\n</ul>\n<h3>2.19.3 Additional Features and Functionality</h3>\n<ul>\n<li>Support for NONEwithECDSA has been added.</li>\n<li>Support for Grainv1 and Grain128 has been added.</li>\n<li>Support for EAC algorithms has been added to CMS/SMIME.</li>\n<li>Support for basic CMS AuthenticatedData to the CMS package.</li>\n<li>Jars are now packaged using pack200 for JDK1.5 and JDK 1.6.</li>\n<li>ASN1Dump now supports a verbose mode for displaying the contents of octet and bit strings.</li>\n<li>Support for the SRP-6a protocol has been added to the lightweight API.</li>\n</ul>\n\n<h3>2.20.1 Version</h3>\nRelease: 1.41<br/>\nDate:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2008, October 1\n<h3>2.20.2 Defects Fixed</h3>\n<ul>\n<li>The GeneralName String constructor now supports IPv4 and IPv6 address parsing.</li>\n<li>An issue with nested-multiparts with postamble for S/MIME that was causing signatures to fail verification has been fixed.</li>\n<li>ESSCertIDv2 encoding now complies with RFC 5035.</li>\n<li>ECDSA now computes correct signatures for oversized hashes when the order of the base point is not a multiple of 8 in compliance with X9.62-2005.</li>\n<li>J2ME SecureRandom now provides additional protection against predictive and backtracking attacks when high volumes of random data are generated.</li>\n<li>Fix to regression from 1.38: PKIXCertPathCheckers were not being called on intermediate certificates.</li>\n<li>Standard name \"DiffieHellman\" is now supported in the provider.</li>\n<li>Better support for equality tests for '#' encoded entries has been added to X509Name.</li>\n</ul>\n<h3>2.20.3 Additional Features and Functionality</h3>\n<ul>\n<li>Camellia is now 12.5% faster than previously.</li>\n<li>A smaller version (around 8k compiled) of Camellia, CamelliaLightEngine has also been added.</li>\n<li>CMSSignedData generation now supports SubjectKeyIdentifier as well as use of issuer/serial.</li>\n<li>A CMSPBE key holder for UTF8 keys has been added to the CMS API.</li>\n<li>Salt and iteration count can now be recovered from PasswordRecipientInformation.</li>\n<li>Methods in the OpenPGP, CMS, and S/MIME APIs which previously could only take provider names can now take providers objects as well (JDK1.4 and greater).</li>\n<li>Support for reading and extracting personalised certificates in PGP Secret Key rings has been added.</li>\n</ul>\n\n<h3>2.21.1 Version</h3>\nRelease: 1.40<br/>\nDate:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2008, July 12\n<h3>2.21.2 Defects Fixed</h3>\n<ul>\n<li>EAX mode ciphers were not resetting correctly after a doFinal/reset. This has been fixed.</li>\n<li>The SMIME API was failing to verify doubly nested multipart objects in signatures correctly. This has been fixed.</li>\n<li>Some boolean parameters to IssuingDistributionPoint were being reversed. This has been fixed.</li>\n<li>A zero length RDN would cause an exception in an X509Name. This has been fixed.</li>\n<li>Passing a null to ExtendedPKIXParameters.setTrustedACIssuers() would cause a NullPointerException. This has been fixed.</li>\n<li>CertTemplate was incorrectly encoding issuer and subject fields when set.</li>\n<li>hashCode() for X509CertificateObject was very poor. This has been fixed.<li>\n<li>Specifying a greater than 32bit length for a stream and relying on the default BCPGOutputStream resulted in corrupted data. This has been fixed.</li>\n<li>PKCS7Padding validation would not fail if pad length was 0. This has been fixed.</li>\n<li>javax.crypto classes no longer appear in the JDK 1.3 provider jar.</li>\n<li>Signature creation time was not being properly initialised in new V4 PGP signature objects although the encoding was correct. This has been fixed.</li>\n<li>The '+' character can now be escaped or quoted in the constructor for X509Name, X509Prinicipal.</li>\n<li>Fix to regression from 1.38: PKIXCertPathValidatorResult.getPublicKey was returning the wrong public key when the BC certificate path validator was used.</li>\n</ul>\n<h3>2.21.3 Additional Features and Functionality</h3>\n<ul>\n<li>Galois/Counter Mode (GCM) has been added to the lightweight API and the JCE provider.</li>\n<li>SignedPublicKeyAndChallenge and PKCS10CertificationRequest can now take null providers if you need to fall back to the default provider mechanism.</li>\n<li>The TSP package now supports validation of responses with V2 signing certificate entries.</li>\n<li>Unnecessary local ID attributes on certificates in PKCS12 files are now automatically removed.</li>\n<li>The PKCS12 store types PKCS12-3DES-3DES and PKCS12-DEF-3DES-3DES have been added to support generation of PKCS12 files with both certificates and keys protected by 3DES.</li>\n</ul>\n<h3>2.21.4 Additional Notes</h3>\n<ul>\n<li>Due to problems for some users caused by the presence of the IDEA algorithm, an implementation is no longer included in the default signed jars. Only the providers of the form bcprov-ext-*-*.jar now include IDEA.</li>\n</ul>\n\n<h3>2.22.1 Version</h3>\nRelease: 1.39<br/>\nDate:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2008, March 29\n<h3>2.22.2 Defects Fixed</h3>\n<ul>\n<li>A bug causing the odd NullPointerException has been removed from the LocalizedMessage class.</li>\n<li>IV handling in CMS for the SEED and Camellia was incorrect. This has been fixed.</li>\n<li>ASN.1 stream parser now throws exceptions for unterminated sequences.</li>\n<li>EAX mode was not handling non-zero offsetted data correctly and failing. This has been fixed.</li>\n<li>The BC X509CertificateFactory now handles multiple certificates and CRLs in streams that don't support marking.</li>\n<li>The BC CRL implementation could lead to a NullPointer exception being thrown if critical extensions were missing. This has been fixed.</li>\n<li>Some ASN.1 structures would cause a class cast exception in AuthorityKeyIdentifier. This has been fixed.</li>\n<li>The CertID class used by the TSP library was incomplete. This has been fixed.</li>\n<li>A system property check in PKCS1Encoding to cause a AccessControlException under some circumstances. This has been fixed.</li>\n<li>A decoding issue with a mis-identified tagged object in CertRepMessage has been fixed.</li>\n<li>\\# is now properly recognised in the X509Name class.</li>\n</ul>\n<h3>2.22.3 Additional Features and Functionality</h3>\n<ul>\n<li>Certifications associated with user attributes can now be created, verified and removed in OpenPGP.</li>\n<li>API support now exists for CMS countersignature reading and production.</li>\n<li>The TSP package now supports parsing of responses with V2 signing certificate entries.</li>\n<li>Lazy evaluation of DER sequences has been introduced to ASN1InputStream to allow support for larger sequences.</li>\n<li>KeyPurposeId class has been updated for RFC 4945.</li>\n<li>CertPath processing has been further extended to encompass the NIST CertPath evaluation suite.</li>\n<li>Initial support has been added for HP_CERTIFICATE_REQUEST in the TLS API.</li>\n<li>Providers for JDK 1.4 and up now use SignatureSpi directly rather than extending Signature. This is more in track with the way dynamic provider selection now works.</li>\n<li>PGP example programs now handle blank names in literal data objects.</li>\n<li>The ProofOfPossession class now better supports the underlying ASN.1 structure.</li>\n<li>Support has been added to the provider for the VMPC MAC.</li>\n</ul>\n<h3>2.23.1 Version</h3>\nRelease: 1.38<br/>\nDate:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2007, November 7\n<h3>2.23.2 Defects Fixed</h3>\n<ul>\n<li>SMIME signatures containing non-standard quote-printable data could be altered by SMIME encryption. This has been fixed.</li>\n<li>CMS signatures that do not use signed attributes were vulnerable to one of Bleichenbacher's RSA signature forgery attacks. This has been fixed.</li>\n<li>The SMIMESignedParser(Part) constructor was not producing a content body part that cleared itself after writeTo() as indicated in the JavaDoc. This has been fixed.</li>\n<li>BCPGInputStream now handles data blocks in the 2**31->2**32-1 range.</li>\n<li>A bug causing second and later encrypted objects to be ignored in KeyBasedFileProcessor example has been fixed.</li>\n<li>Value of the TstInfo.Tsa field is now directly accessible from TimeStampTokenInfo.</li>\n<li>Generating an ECGOST-3410 key using an ECGenParameterSpec could cause a ClassCastException in the key generator. This has been fixed.</li>\n<li>Use of the parameters J and L in connection with Diffie-Hellman parameters in the light weight API was ambiguous and confusing. This has been dealt with.</li>\n<li>Some entities were not fully removed from a PKCS#12 file when deleted due to case issues. This has been fixed.</li>\n<li>Overwriting entities in a PKCS#12 file was not fully compliant with the JavaDoc for KeyStore. This has been fixed.</li>\n<li>TlsInputStream.read() could appear to return end of file when end of file had not been reached. This has been fixed.</li>\n</ul>\n<h3>2.23.3 Additional Features and Functionality</h3>\n<ul>\n<li>Buffering in the streaming CMS has been reworked. Throughput is now usually higher and the behaviour is more predictable.</li>\n<li>It's now possible to pass a table of hashes to a CMS detached signature rather than having to always pass the data.</li>\n<li>Classes supporting signature policy and signer attributes have been added to the ASN.1 ESS/ESF packages.</li>\n<li>Further work has been done on optimising memory usage in ASN1InputStream. In some cases memory usage has been reduced to 25% of previous.</li>\n<li>Pre-existing signers can now be added to the SMIMESignedGenerator.</li>\n<li>Support has been added to the provider for the VMPC stream cipher.</li>\n<li>CertPathReviewer has better handling for problem trust anchors.</li>\n<li>Base64 encoder now does initial size calculations to try to improve resource usage.</li>\n</ul>\n<h3>2.24.1 Version</h3>\nRelease: 1.37<br/>\nDate:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2007, June 15\n<h3>2.24.2 Defects Fixed</h3>\n<ul>\n<li>The ClearSignedFileProcessor example for OpenPGP did not take into account trailing white space in\nthe file to be signed. This has been fixed.</li>\n<li>A possible infinite loop in the CertPathBuilder and SignedMailValidator have been removed.</li>\n<li>Requesting DES, DESede, or Blowfish keys using regular Diffie-Hellman now returns the same length keys as the regular JCE provider.</li>\n<li>Some uncompressed EC certificates were being interpreted as compressed and causing an exception. This has been fixed.</li>\n<li>Adding a CRL with no revocations on it to the CRL generator could cause an exception to be thrown. This has been fixed.</li>\n<li>Using the default JDK provider with the CMS library would cause exceptions in some circumstances. This has been fixed.</li>\n<li>BC provider DSAKeys are now serializable.</li>\n<li>Using only a non-sha digest in S/MIME signed data would produce a corrupt MIME header. This has been fixed.</li>\n<li>The default private key length in the lightweght API for generated DiffieHellman parameters was absurdly small, this has been fixed.</li>\n<li>Cipher.getParameters() for PBEwithSHAAndTwofish-CBC was returning null after intialisation. This has been fixed.</li>\n</ul>\n<h3>2.24.3 Additional Features and Functionality</h3>\n<ul>\n<li>The block cipher mode CCM has been added to the provider and light weight API.</li>\n<li>The block cipher mode EAX has been added to the provider and light weight API.</li>\n<li>The stream cipher HC-128 and HC-256 has been added to the provider and lightwieght API.</li>\n<li>The stream cipher ISAAC has been added to the lightweight API.</li>\n<li>Support for producing and parsing notation data signature subpackets has been added to OpenPGP.</li>\n<li>Support for implicit tagging has been added to DERApplicationSpecific.</li>\n<li>CMS better supports basic Sun provider.</li>\n<li>A full set of SEC-2 EC curves is now provided in the SEC lookup table.</li>\n<li>Specifying a null provider in CMS now always uses the default provider, rather than causing an exception.</li>\n<li>Support has been added to the OpenPGP API for parsing experimental signatures</li>\n<li>CertPath validator now handles inherited DSA parameters and a wider range of name constraints.</li>\n<li>Further work has been done on improving the performance of ECDSA - it is now about two to six times faster depending on the curve.</li>\n<li>The Noekeon block cipher has been added to the provider and the lightweight API.</li>\n<li>Certificate generation now supports generation of certificates with an empty Subject if the subjectAlternativeName extension is present.</li>\n<li>The JCE provider now supports RIPEMD160withECDSA.</li>\n</ul>\n\n<h3>2.25.1 Version</h3>\nRelease: 1.36<br/>\nDate:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2007, March 16\n<h3>2.25.2 Defects Fixed</h3>\n<ul>\n<li>DSA key generator now checks range and keysize.</li>\n<li>Class loader issues with i18n classes should now be fixed.</li>\n<li>X.500 name serial number value now output as unambiguous long form SERIALNUMBER</li>\n<li>The fix for multipart messages with mixed content-transfer-encoding in 1.35 caused a\nregression for processing some messages with embedded multiparts that contained blank lines of preamble text - this should now be fixed.</li>\n<li>Another regression which sometimes affected the SMIMESignedParser has also been fixed.</li>\n<li>SharedFileInputStream compatibility issues with JavaMail 1.4 have been addressed.</li>\n<li>JDK 1.5 and later KeyFactory now accepts ECPublicKey/ECPrivateKey to translateKey.</li>\n<li>JDK 1.5 and later KeyFactory now produces ECPublicKeySpec/ECPrivateKeySpec on getKeySpec.</li>\n<li>Some surrogate pairs were not assembled correctly by the UTF8 decoder. This has been fixed.</li>\n<li>Alias resolution in PKCS#12 is now case insensitive.</li>\n</ul>\n<h3>2.25.3 Additional Features and Functionality</h3>\n<ul>\n<li>CMS/SMIME now supports basic EC KeyAgreement with X9.63.</li>\n<li>CMS/SMIME now supports RFC 3211 password based encryption.</li>\n<li>Support has been added for certificate, CRL, and certification request generation for the regular SHA algorithms with RSA-PSS.</li>\n<li>Further work has been done in speeding up prime number generation in the lightweight BigInteger class.</li>\n<li>Support for the SEED algorithm has been added to the provider and the lightweight API.</li>\n<li>Support for the Salsa20 algorithm has been added to the provider and the lightweight API.</li>\n<li>CMS/SMIME now support SEED and Camellia</li>\n<li>A table of TeleTrusT curves has been added.</li>\n<li>CMSSignedData creation and Collection CertStore now preserves the order of certificates/CRls if the backing collection is ordered.</li>\n<li>CMS Signed objects now use BER encoding for sets containing certificates and CRLs, allowing specific ordering to be specified for the objects contained.</li>\n<li>CMS enveloped now works around providers which throw UnsupportedOperationException if key wrap is attempted.</li>\n<li>DSASigner now handles long messages. SHA2 family digest support for DSA has been added to the provider.</li>\n</ul>\n\n<h3>2.26.1 Version</h3>\nRelease: 1.35<br/>\nDate:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2006, December 16\n<h3>2.26.2 Defects Fixed</h3>\n<ul>\n<li>Test data files are no longer in the provider jars.</li>\n<li>SMIMESignedParser now handles indefinite length data in SignerInfos.</li>\n<li>Under some circumstances the SMIME library was failing to canonicalize mixed-multipart data correctly. This has been fixed.</li>\n<li>The l parameter was being ignored for the DH and ElGamal key generation. This has been fixed.</li>\n<li>The ASN1Sequence constructor for OtherRecipientInfo was broken. It has been fixed</li>\n<li>Regression - DN fields SerialNumber and Country were changed to encode as UTF8String in 1.34 in the X509DefaultEntryConverter, these now encode as PrintableString.</li>\n<li>CMSSignedData.replaceSigners() was not replacing the digest set as well as the signers. This has been fixed.</li>\n<li>DERGeneralizedTime produced a time string without a GMT offset if they represented local time. This has been fixed.</li>\n<li>Some temp files were still being left on Windows by the SMIME library. All of the known problems have been fixed.</li>\n<li>Comparing ASN.1 object for equality would fail in some circumstances. This has been fixed.\n<li>The IESEngine could incorrectly encrypt data when used in block cipher mode. This has been fixed.\n<li>An error in the encoding of the KEKRecipientInfo has been fixed. Compatability warning: this may mean that versions of BC mail prior to 1.35 will have trouble processing KEK messages produced by 1.35 or later.\n</ul>\n<h3>2.26.3 Additional Features and Functionality</h3>\n<ul>\n<li>Further optimisations to elliptic curve math libraries.</li>\n<li>API now incorporates a CertStore which should be suitable for use with LDAP.</li>\n<li>The streaming ASN.1 API is now integrated into the base one, the sasn1 package has been deprecated.</li>\n<li>The OpenPGP implementation now supports SHA-224 and BZIP2.</li>\n<li>The OpenPGP implementation now supports SHA-1 checksumming on secret keys.</li>\n<li>The JCE provider now does RSA blinding by default.</li>\n<li>CMSSignedDataParser now provides methods for replacing signers and replacing certificates and CRLs.</li>\n<li>A generic store API has been added to support CRLs, Certificates and Attribute certificates.</li>\n<li>The CMS/SMIME API now supports inclusion and retrieval of version 2 attribute certificates.</li>\n<li>Support for generating CertificationRequests and Certificates has been added for GOST-3410-2001 (ECGOST)</li>\n<li>CMS/SMIME now support ECGOST</li>\n<li>Basic BER Octet Strings now encode in a canonical fashion by default.</li>\n<li>DERUTCTime can now return Date objects</li>\n<li>Validating constructors have been added to DERPrintableString, DERIA5String, and DERNumericString.</li>\n<li>A lightweight API for supporting TLS has been added.</li>\n<li>Implementations of the TEA and XTEA ciphers have been added to the light weight API and the provider.</li>\n<li>PEMReader now supports OpenSSL ECDSA key pairs.</li>\n<li>PGP packet streams can now be closed off using close() on the returned stream as well as closing the generator.</li>\n</ul>\n<h3>2.27.1 Version</h3>\nRelease: 1.34<br/>\nDate:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2006, October 2\n<h3>2.27.2 Defects Fixed</h3>\n<ul>\n<li>Endianess of integer conversion in KDF2BytesGenerator was incorrect. This has been fixed.\n<li>Generating critical signature subpackets in OpenPGP would result in a zero packet tag. This has been fixed.\n<li>Some flags in PKIFailure info were incorrect, and the range of values was incomplete. The range of values has been increased and the flags corrected.\n<li>The helper class for AuthorityKeyExtension generation was including the subject rather than the issuer DN of the CA certificate. This has been fixed.\n<li>SMIMESignedParser now avoids JavaMail quoted-printable recoding issue.\n<li>Verification of RSA signatures done with keys with public exponents of 3 was vunerable to\nBleichenbacher's RSA signature forgery attack. This has been fixed.\n<li>PGP Identity strings were only being interpreted as ASCII rather than UTF8. This has been fixed.\n<li>CertificateFactory.generateCRLs now returns a Collection rather than null.\n</ul>\n<h3>2.27.3 Additional Features and Functionality</h3>\n<ul>\n<li>An ISO18033KDFParameters class had been added to support ISO18033 KDF generators.\n<li>An implemention of the KDF1 bytes generator algorithm has been added.\n<li>An implementation of NaccacheStern encryption has been added to the lightweight API.\n<li>X509V2CRLGenerator can now be loaded from an existing CRL.\n<li>The CMS enveloped data generators will now attempt to use the default provider for encryption if the passed in provider can only handle key exchange.\n<li>OpenPGP file processing has been substantially speeded up.\n<li>The PKCS1Encoder would accept PKCS1 packets which were one byte oversize. By default this will now cause an error. However, as there are still implementations which still produce such packets the older behaviour can be turned on by setting the VM system property org.bouncycastle.pkcs1.strict to false before creating an RSA cipher using PKCS1 encoding.\n<li>A target has been added to the bc-build.xml to zip up the source code rather than leaving it in a directory tree.\nThe build scripts now run this target by default.\n<li>Use of toUpperCase and toLowerCase has been replaced with a locale independent converter where appropriate.\n<li>Support for retrieving the issuers of indirect CRLs has been added.\n<li>Classes for doing incremental path validation of PKIX cert paths have been added to the X.509 package and S/MIME.\n<li>Locale issues with String.toUpperCase() have now been worked around.\n<li>Optional limiting has been added to ASN1InputStream to avoid possible OutOfMemoryErrors on corrupted streams.\n<li>Support has been added for SHA224withECDSA, SHA256withECDSA, SHA384withECDSA, and SHA512withECDSA for the generation of signatures, certificates, CRLs, and certification requests.\n<li>Performance of the prime number generation in the BigInteger library has been further improved.\n<li>In line with RFC 3280 section 4.1.2.4 DN's are now encoded using UTF8String by default rather than PrintableString.\n</ul>\n<h3>2.27.4 Security Advisory</h3>\n<ul>\n<li>If you are using public exponents with the value three you *must* upgrade to this release, otherwise it\nwill be possible for attackers to exploit some of Bleichenbacher's RSA signature forgery attacks on your applications.</li>\n</ul>\n<h3>2.28.1 Version</h3>\nRelease: 1.33<br/>\nDate:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2006, May 3\n<h3>2.28.2 Defects Fixed</h3>\n<ul>\n<li>OCSPResponseData was including the default version in its encoding. This has been fixed.\n<li>BasicOCSPResp.getVersion() would throw a NullPointer exception if called on a default version response. This has been fixed.\n<li>Addition of an EC point under Fp could result in an ArithmeticException. This has been fixed.\n<li>The n value for prime192v2 was incorrect. This has been fixed.\n<li>ArmoredInputStream was not closing the underlying stream on close. This has been fixed.\n<li>Small base64 encoded strings with embedded white space could decode incorrectly using the Base64 class. This has been fixed.\n</ul>\n<h3>2.28.3 Additional Features and Functionality</h3>\n<ul>\n<li>The X509V2CRLGenerator now supports adding general extensions to CRL entries.\n<li>A RoleSyntax implementation has been added to the x509 ASN.1 package, and the AttributeCertificateHolder class now support the IssuerSerial option.\n<li>The CMS API now correctly recognises the OIW OID for DSA with SHA-1.\n<li>DERUTF8String now supports surrogate pairs.\n</ul>\n\n<h3>2.29.1 Version</h3>\nRelease: 1.32<br/>\nDate:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2006, March 27\n<h3>2.29.2 Defects Fixed</h3>\n<ul>\n<li>Further work has been done on RFC 3280 compliance.\n<li>The ASN1Sequence constructor for SemanticsInformation would sometimes throw a ClassCastException on reconstruction an object from a byte stream. This has been fixed.\n<li>The SharedInputStream.read(buf, 0, len) method would return 0 at EOF, rather than -1. This has been fixed.\n<li>X9FieldElement could fail to encode a Fp field element correctly. This has been fixed.\n<li>The streaming S/MIME API was occasionally leaving temporary files around. The SIMEUtil class responsible for creating the files now returns a FileBackedMimeBodyPart object\nwhich has a dispose method on it which should allow removal of the file backing the body part.\n<li>An encoding defect in EnvelopedData generation in the CMS streaming, S/MIME API has been fixed.\n<li>DER constructed octet strings could cause exceptions in the streaming ASN.1 library. This has been fixed.\n<li>Several compatibility issues connected with EnvelopedData decoding between the streaming CMS library and other libraries have been fixed.\n<li>JDK 1.4 and earlier would sometimes encode named curve parameters explicitly. This has been fixed.\n<li>An incorrect header for SHA-256 OpenPGP clear text signatures has been fixed.\n<li>An occasional bug that could result in invalid clear text signatures has been fixed.\n<li>OpenPGP clear text signatures containing '\\r' as line separators were not being correctly canonicalized. This has been fixed.\n</ul>\n\n<h3>2.29.3 Additional Features and Functionality</h3>\n<ul>\n<li>The ASN.1 library now includes classes for the ICAO Electronic Passport.\n<li>Support has been added to CMS and S/MIME for ECDSA.\n<li>Support has been added for the SEC/NIST elliptic curves.\n<li>Support has been added for elliptic curves over F2m.\n<li>Support has been added for repeated attributes in CMS and S/MIME messages.\n<li>A wider range of RSA-PSS signature types is now supported for CRL and Certificate verification.\n</ul>\n<h3>2.29.4 Possible compatibility issue</h3>\n<ul>\n<li>Previously elliptic curve keys and points were generated with point compression enabled by default.\nOwing to patent issues in some jurisdictions, they are now generated with point compression disabled by default.\n</ul>\n\n<h3>2.30.1 Version</h3>\nRelease: 1.31<br/>\nDate:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2005, December 29\n<h3>2.30.2 Defects Fixed</h3>\n<ul>\n<li>getCriticalExtensionOIDs on an X.509 attribute certificate was returning the non-critical set. This has been fixed.\n<li>Encoding uncompressed ECDSA keys could occasionally introduce an extra leading zero byte. This has been fixed.\n<li>Expiry times for OpenPGP master keys are now recognised across the range of possible certifications.\n<li>PGP 2 keys can now be decrypted by the the OpenPGP library.\n<li>PGP 2 signature packets threw an exception on trailer processing. This has been been fixed.\n<li>Attempting to retrieve signature subpackets from an OpenPGP version 3 signature would throw a null pointer exception. This has been fixed.\n<li>Another occasional defect in EC point encoding has been fixed.\n<li>In some cases AttributeCertificateHolder.getIssuer() would return an empty array for attribute certificates using the BaseCertificateID.\nThis has been fixed.\n<li>OIDs with extremely large components would sometimes reencode with unnecessary bytes in their encoding. The optimal DER encoding will now be produced instead.\n</ul>\n<h3>2.30.3 Additional Features and Functionality</h3>\n<ul>\n<li>The SMIME package now supports the large file streaming model as well.\n<li>Additional ASN.1 message support has been added for RFC 3739 in the org.bouncycastle.x509.qualified package.\n<li>Support has been added for Mac algorithm 3 from ISO 9797 to both the lightweight APIs and the provider.\n<li>The provider now supports the DESEDE64 MAC algorithm.\n<li>CertPathValidator has been updated to better support path validation as defined in RFC 3280.\n</ul>\n\n<h3>2.31.1 Version</h3>\nRelease: 1.30<br/>\nDate:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2005, September 18\n<h3>2.31.2 Defects Fixed</h3>\n<ul>\n<li>Whirlpool was calculating the wrong digest for 31 byte data and could throw an exception for some other data lengths. This has been fixed.\n<li>AlgorithmParameters for IVs were returning a default of RAW encoding of the parameters when they should have been returning an\nASN.1 encoding. This has been fixed.\n<li>Base64 encoded streams without armoring could cause an exception in PGPUtil.getDecoderStream(). This has been fixed.\n<li>PGPSecretKey.copyWithNewPassword() would incorrectly tag sub keys. This has been fixed.\n<li>PGPSecretKey.copyWithNewPassword() would not handle the NULL algorithm. This has been fixed.\n<li>Directly accessing the dates on an X.509 Attribute Certificate constructed from an InputStream would return null, not the date objects. This has been fixed.\n<li>KEKIdentifier would not handle OtherKeyAttribute objects correctly. This has been fixed.\n<li>GetCertificateChain on a PKCS12 keystore would return a single certificate chain rather than null if the alias passed in represented a certificate not a key. This has been fixed.\n</ul>\n<h3>2.31.3 Additional Features and Functionality</h3>\n<ul>\n<li>RSAEngine no longer assumes keys are byte aligned when checking for out of range input.\n<li>PGPSecretKeyRing.removeSecretKey and PGPSecretKeyRing.insertSecretKey have been added.\n<li>There is now a getter for the serial number on TimeStampTokenInfo.\n<li>Classes for dealing with CMS objects in a streaming fashion have been added to the CMS package.\n<li>PGPCompressedDataGenerator now supports partial packets on output.\n<li>OpenPGP Signature generation and verification now supports SHA-256, SHA-384, and SHA-512.\n<li>Both the lightweight API and the provider now support the Camellia encryption algorithm.\n</ul>\n\n<h3>2.32.1 Version</h3>\nRelease: 1.29<br/>\nDate:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2005, June 27\n<h3>2.32.2 Defects Fixed</h3>\n<ul>\n<li>HMac-SHA384 and HMac-SHA512 were not IETF compliant. This has been fixed.\n<li>The equals() method on ElGamalKeyParameters and DHKeyParameters in the lightweight API would sometimes\nreturn false when it should return true. This has been fixed.\n<li>Parse error for OpenSSL style PEM encoded certificate requests in the PEMReader has been fixed.\n<li>PGPPublicKey.getValidDays() now checks for the relevant signature for version 4 and later keys as well as using the\nversion 3 key valid days field.\n<li>ISO9796 signatures for full recovered messsages could incorrectly verify for similar messages in some circumstances. This has been fixed.\n<li>The occasional problem with decrypting PGP messages containing compressed streams now appears to be fixed.\n</ul>\n<h3>2.32.3 Additional Features and Functionality</h3>\n<ul>\n<li>Support has been added for the OIDs and key generation required for HMac-SHA224, HMac-SHA256, HMac-SHA384, and \nHMac-SHA512.\n<li>SignerInformation will used default implementation of message digest if signature provider doesn't support it.\n<li>The provider and the lightweight API now support the GOST-28147-94 MAC algorithm.\n<li>Headers are now settable for PGP armored output streams.\n</ul>\n<h3>2.32.4 Notes</h3>\n<ul>\n<li>The old versions of HMac-SHA384 and HMac-SHA512 can be invoked as OldHMacSHA384 and OldHMacSHA512, or by using the OldHMac class in the\nlightweight API.\n</ul> \n<h3>2.33.1 Version</h3>\nRelease: 1.28<br/>\nDate:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2005, April 20\n<h3>2.33.2 Defects Fixed</h3>\n<ul>\n<li>Signatures on binary encoded S/MIME messages could fail to validate when correct. This has been fixed.\n<li>getExtensionValue() on CRL Entries were returning the encoding of the inner object, rather than the octet string. This has been fixed.\n<li>CertPath implementation now returns an immutable list for a certificate path.\n<li>Generic sorting now takes place in the CertificateFactory.generateCertPath() rather than CertPathValidator.\n<li>DERGeneralizedTime can now handle time strings with milli-seconds.\n<li>Stateful CertPathCheckers were not being initialised in all cases, by the CertPathValidator. This has been fixed.\n<li>PGPUtil file processing methods were failing to close files after processing. This has been fixed.\n<li>A disordered set in a CMS signature could cause a CMS signature to fail to validate when it should. This has been fixed.\n<li>PKCS12 files where both the local key id and friendly name were set on a certificate would not parse correctly. This has been fixed.\n<li>Filetype for S/MIME compressed messages was incorrect. This has been fixed.\n<li>BigInteger class can now create negative numbers from byte arrays.\n</ul>\n<h3>2.33.3 Additional Features and Functionality</h3>\n<ul>\n<li>S/MIME now does canonicalization on non-binary input for signatures.\n<li>Micalgs for the new SHA schemes are now supported.\n<li>Provided and lightweight API now support ISO 7816-4 padding.\n<li>The S/MIME API now directly supports the creation of certificate management messages.\n<li>The provider and the light weight API now support the cipher GOST-28147, the signature algorithms GOST-3410 (GOST-3410 94) and EC GOST-3410 (GOST-3410 2001), the message digest GOST-3411 and the GOST OFB mode (use GOFB).\n<li>CMSSignedDataGenerator will used default implementation of message digest if signature provider doesn't support it.\n<li>Support has been added for the creation of ECDSA certificate requests.\n<li>The provider and the light weight API now support the WHIRLPOOL message digest.\n</ul>\n<h3>2.33.4 Notes</h3>\n<ul>\n<li>Patches for S/MIME binary signatures and canonicalization were actually applied in 1.27, but a couple of days after the release - if the class \nCMSProcessableBodyPartOutbound is present in the package org.bouncycastle.mail.smime you have the patched 1.27. We would recommend upgrading to 1.28 in any case\nas some S/MIME 3.1 recommendations have also been introduced for header creation.\n<li>GOST private keys are probably not encoding correctly and can be expected to change.\n</ul>\n<h3>2.34.1 Version</h3>\nRelease: 1.27<br/>\nDate:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2005, February 20\n<h3>2.34.2 Defects Fixed</h3>\n<ul>\n<li>Typos in the provider which pointed Signature algorithms SHA256WithRSA, SHA256WithRSAEncryption, SHA384WithRSA, SHA384WithRSAEncryption, SHA512WithRSA, and SHA512WithRSAEncryption at the PSS versions of the algorithms have been fixed. The correct names for the PSS algorithms are SHA256withRSAandMGF1, SHA384withRSAandMGF1, and SHA512withRSAandMGF1.\n<li>X509CertificateFactory failed under some circumstances to reset properly if the input stream being passed\nto generateCertificate(s)() changed, This has been fixed.\n<li>OpenPGP BitStrength for DSA keys was being calculated from the key's generator rather than prime. This has been fixed.\n<li>Possible infinite loop in ASN.1 SET sorting has been removed.\n<li>SHA512withRSAandMGF1 with a zero length salt would cause an exception if used with a 1024 bit RSA key. This has been fixed.\n<li>Adding an Exporter to a PGPSubpacketVector added a Revocable instead. This has been fixed.\n<li>AttributeCertificateIssuer.getPrincipal() could throw an ArrayStoreException. This has been fixed.\n<li>CertPathValidator now guarantees to call any CertPathCheckers passed in for each certificate.\n<li>TSP TimeStampToken was failing to validate time stamp tokens with the issuerSerial field set in the ESSCertID structure. This has been fixed.\n<li>Path validation in environments with frequently updated CRLs could occasionally reject a valid path. This has been fixed.\n</ul>\n<h3>2.34.3 Additional Features and Functionality</h3>\n<ul>\n<li>Full support has been added for the OAEPParameterSpec class to the JDK 1.5 povider.\n<li>Full support has been added for the PSSParameterSpec class to the JDK 1.4 and JDK 1.5 providers.\n<li>Support for PKCS1 signatures for SHA-256, SHA-384, and SHA-512 has been added to CMS.\n<li>PGPKeyRingCollection classes now support partial matching of user ID strings.\n<li>This release disables the quick check on the IV for a PGP public key encrypted message in order to help\nprevent applications being vunerable to oracle attacks.\n<li>The CertPath support classes now support PKCS #7 encoding.\n<li>Point compression can now be turned off when encoding elliptic curve keys.\n</ul>\n<h3>2.34.4 Changes that may affect compatibility</h3>\n<ul>\n<li>org.bouncycastle.jce.interfaces.ElGamalKey.getParams() has been changed to getParameters() to avoid clashes with\na JCE interface with the same method signature.\n<li>org.bouncycastle.jce.interfaces.ECKey.getParams() has been changed in JDK 1.5 to getParameters() to avoid clashes\nwith a JCE interface with the same method signature. The getParams() method in pre-1.5 has been deprecated.\n<li>SHA256WithRSAEncryption, SHA384WithRSAEncryption, SHA512WithRSAEncryption now refer to their PKCS #1 V1.5 implementations. If you\nwere using these previously you should use SHA256WithRSAAndMGF1, SHA384WithRSAAndMGF1, or SHA512WithRSAAndMGF1.\n</ul>\n<h3>2.35.1 Version</h3>\nRelease: 1.26<br/>\nDate:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2005, January 15\n<h3>2.35.2 Defects Fixed</h3>\n<ul>\n<li>The X.509 class UserNotice assumed some of the optional fields were not optional. This has been fixed.\n<li>BCPGInputStream would break on input packets of 8274 bytes in length. This has been fixed.\n<li>Public key fingerprints for PGP version 3 keys are now correctly calculated.\n<li>ISO9796-2 PSS would sometimes throw an exception on a correct signature. This has been fixed.\n<li>ASN1Sets now properly sort their contents when created from scratch.\n<li>A bug introduced in the CertPath validation in the last release which meant some certificate paths would validate if they were invalid has been fixed.\n</ul>\n<h3>2.35.3 Additional Features and Functionality</h3>\n<ul>\n<li>Support for JDK 1.5 naming conventions for OAEP encryption and PSS signing has been added.\n<li>Support for Time Stamp Protocol (RFC 3161) has been added.\n<li>Support for Mozilla's PublicKeyAndChallenge key certification message has been added.\n<li>OpenPGP now supports key rings containing GNU_DUMMY_S2K.\n<li>Support for the new versions (JDK 1.4 and later) of PBEKeySpec has been added to the providers.\n<li>PBEWithMD5AndRC2, PBEWithSHA1AndRC2 now generate keys rather than exceptions.\n<li>The BigInteger implementation has been further optimised to take more advantage of the Montgomery number capabilities.\n</ul>\n<h3>2.35.4 JDK 1.5 Changes</h3>\n<ul>\n<li>The JDK 1.5 version of the provider now supports the new Elliptic Curve classes found in the java.security packages. Note: while we have tried to preserve some backwards compatibility people using Elliptic curve are likely to find some minor code changes are required when moving code from JDK 1.4 to JDK 1.5 as the java.security APIs have changed.\n</ul>\n\n<h3>2.36.1 Version</h3>\nRelease: 1.25<br/>\nDate:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2004, October 1\n<h3>2.36.2 Defects Fixed</h3>\n<ul>\n<li>In some situations OpenPGP would overread when a stream had been\nbroken up into partial blocks. This has been fixed.\n<li>Explicitly setting a key size for RC4 in the CMS library would cause\nan exception. This has been fixed.\n<li>getSignatures() on PGPPublicKey would throw a ClassCastException in some cases. This has been fixed.\n<li>Encapsulated signed data was been generated with the wrong mime headers, this has been fixed.\n<li>The isSignature method on PGPSecretKey now correctly identifies signing keys.\n<li>An interoperability issue with DH key exchange between the Sun JCE provider and the BC provider, concerning sign bit expansion, has been fixed. \n<li>The X509CertificateFactory would fail to reset correctly after reading an ASN.1 certificate chain. This has been fixed.\n<li>CertPathValidator now handles unsorted lists of certs.\n<li>The PGPSignatureGenerator would sometimes throw an exception when adding hashed subpackets. This has been fixed.\n<li>Ordered equality in X509Name was not terminating as early as possible. This has been fixed.\n<li>getBitStrength for PGPPublicKeys was returning the wrong value for ElGamal keys. This has been fixed.\n<li>getKeyExpirationTime/getSignatureExpirationTime was returning a Date rather than a delta. This isn't meaningful as a Date and has been changed to a long.\n<li>the crlIssuer field in DistributionPoint name was encoding/decoding incorrectly. This has been fixed.\n<li>X509Name now recognises international characters in the input string and\nstores them as BMP strings.\n<li>Parsing a message with a zero length body with SMIMESigned would cause an exception. This has been fixed.\n<li>Some versions of PGP use zeros in the data stream rather than a replication of the last two bytes of the iv as specified in the RFC to determine if the correct decryption key has been found. The decryption classes will now cope with both.\n</ul>\n<h3>2.36.3 Additional Features and Functionality</h3>\n<ul>\n<li>Support for extracting signatures based on PGP user attributes has been\nadded to PGPPublicKey.\n<li>BCPGArmoredInputStream should cope with plain text files better.\n<li>The OpenPGP library can now create indefinite length streams and handle packets greater than (2^32 - 1) in length.\n<li>Direct support for adding SignerUserID and PrimaryUserID has been added to the PGPSignatureSubpacketGenerator.\n<li>Support for ISO-9796-2/PSS has been added to the lightweight API.\n<li>API support for extracting recovered messages from signatures that support\nmessage recovery has been added to the lightweight API.\n<li>String value conversion in a DN being processed by X509Name is now fully\nconfigurable.\n<li>It is now possible to create new versions of CMSSignedData objects without\nhaving to convert the original object down to its base ASN.1 equivalents.\n<li>Support for adding PGP revocations and other key signatures has been added.\n<li>Support for SHA-224 and SHA224withRSA has been added.\n<li>Trailing bit complement (TBC) padding has been added.\n<li>OID components of up to 2^63 bits are now supported.\n</ul>\n<h3>2.37.1 Version</h3>\nRelease: 1.24<br/>\nDate:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2004, June 12\n<h3>2.37.2 Defects Fixed</h3>\n<ul>\n<li>OpenPGP Secret key rings now parse key rings with user attribute packets in them correctly.\n<li>OpenPGP Secret key rings now parse key rings with GPG comment packets in them.\n<li>X509Name and X509Principal now correctly handle BitStrings.\n<li>OpenPGP now correctly recognises RSA signature only keys.\n<li>When re-encoding PGP public keys taken off secret keys getEncoded would\nsometimes throw a NullPointerException. This has been fixed.\n<li>A basic PKCS12 file with a single key and certificate, but no attributes, would cause a null pointer exception. This has been fixed.\n<li>Signature verification now handles signatures where the parameters block is missing rather than NULL.\n<li>Lightweight CBCBlockCipherMac was failing to add padding if padding was\nbeing explicitly provided and data length was a multiple of the block size. This has been fixed.\n<li>ZIP compression in PGP was failing to compress data in many cases. This has been fixed.\n<li>Signatures were occasionally produced with incorrect padding in their associated bit strings, this has been fixed.\n<li>An encoding error introduced in 1.23 which affected generation of the\nKeyUsage extension has been fixed.\n</ul>\n<h3>2.37.3 Additional Features and Functionality</h3>\n<ul>\n<li>PKCS12 keystore now handles single key/certificate files without any attributes present.\n<li>Support for creation of PGPKeyRings incorporating sub keys has been added.\n<li>ZeroPadding for encrypting ASCII data has been added.\n</ul>\n<h3>2.38.1 Version</h3>\nRelease: 1.23<br/>\nDate:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2004, April 10\n<h3>2.38.2 Defects Fixed</h3>\n<ul>\n<li>Reading a PGP Secret key file would sometimes cause a class cast exception. This has been fixed.\n<li>PGP will now read SecretKeys which are encrypted with the null algorithm.\n<li>PGP ObjectFactory will recognise Marker packets.\n<li>BasicConstraints class now handles default empty sequences correctly.\n<li>S2K Secret Key generation now supported in OpenPGP for keys greater than 160 bits, a bug causing\nit to occasionally generate the wrong key has been fixed.\n<li>OpenPGP implementation can now read PGP 8 keys.\n<li>Decoding issues with Secret Sub Keys should now be fixed.\n<li>PGP would occasionally unpack ElGamal encrypted data incorrectly, this has been fixed.\n<li>OCSP TBSRequest now uses abbreviated encoding if the default version is used.\n<li>X509Name class will now print names with nested pairs in component sets correctly.\n<li>RC4 now resets correctly on doFinal.\n</ul>\n<h3>2.38.3 Additional Features and Functionality</h3>\n<ul>\n<li>PGP V3 keys and V3 signature generation is now supported.\n<li>Collection classes have been added for representing files of PGP public and secret keys.\n<li>PEMReader now supports \"RSA PUBLIC KEY\".\n<li>RipeMD256 and RipeMD320 have been added.\n<li>Heuristic decoder stream has been added to OpenPGP which \"guesses\" how the input is\nconstructed.\n<li>ArmoredInputStream now recognises clear text signed files.\n<li>ArmoredOutputStream now provides support for generating clear text signed files.\n<li>Support has been added to CMS for RipeMD128, RipeMD160, and RipeMD256.\n<li>Support for generating certification directly and editing PGP public key\ncertifications has been added.\n<li>Support has been added for modification detection codes to the PGP library.\n<li>Examples have been rewritten to take advantage of the above.\n<li>SMIMESigned can now covert data straight into a mime message.\n<li>DERGeneralizedTime getTime() method now handles a broader range of input strings.\n</ul>\n\n<h3>2.39.1 Version</h3>\nRelease: 1.22<br/>\nDate:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2004, February 7\n<h3>2.39.2 Defects Fixed</h3>\n<ul>\n<li>Generating DSA signatures with PGP would cause a class cast exception, this has been fixed.\n<li>PGP Data in the 192 to 8383 byte length would sometimes be written with the wrong length header. This has been fixed.\n<li>The certificate factory would only parse the first certificate in a PKCS7 object. This has been fixed.\n<li>getRevocationReason() in RevokedStatus in OCSP would throw an exception for\na non-null reason, rather than a null one. This has been fixed.\n<li>PSS signature verification would fail approximately 0.5 % of the time on correct signatures. This has been fixed.\n<li>Encoding of CRL Distribution Points now always works.\n</ul>\n<h3>2.39.3 Additional Features and Functionality</h3>\n<ul>\n<li>Additional methods for getting public key information have been added to the PGP package.\n<li>Some support for user attributes and the image attribute tag has been added.\n<li>Support for the AuthorityInformationAccess extension has been added.\n<li>Support for ElGamal encryption/decryption has been added to the PGP package.\n</ul>\n\n<h3>2.40.1 Version</h3>\nRelease: 1.21<br/>\nDate:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2003, December 6\n<h3>2.40.2 Defects Fixed</h3>\n<ul>\n<li>The CertPath validator would fail for some valid CRLs. This has been  fixed.\n<li>AES OIDS for S/MIME were still incorrect, this has been fixed.\n<li>The CertPathBuilder would sometimes throw a NullPointerException looking for an issuer. This has been fixed.\n<li>The J2ME BigInteger class would sometimes go into an infinite loop generating prime numbers. This has been fixed.\n<li>DERBMPString.equals() would throw a class cast exception. This has been fixed.\n</ul>\n<h3>2.40.3 Additional Features and Functionality</h3>\n<ul>\n<li>PEMReader now handles public keys.\n<li>OpenPGP/BCPG should now handle partial input streams. Additional methods for reading subpackets off signatures.\n<li>The ASN.1 library now supports policy qualifiers and policy info objects.\n</ul>\n\n<h3>2.41.1 Version</h3>\nRelease: 1.20<br/>\nDate:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2003, October 8\n<h3>2.41.2 Defects Fixed</h3>\n<ul>\n<li>BigInteger toString() in J2ME/JDK1.0 now produces same output as the Sun one.\n<li>RSA would throw a NullPointer exception with doFinal without arguments. This has been fixed.\n<li>OCSP CertificateID would calculate wrong issuer hash if issuer cert was not self signed. This has been fixed.\n<li>Most of response generation in OCSP was broken. This has been fixed.\n<li>The CertPath builder would sometimes go into an infinite loop on some chains if the trust anchor was missing. This has been fixed.\n<li>AES OIDS were incorrect, this has been fixed.\n<li>In some cases BC generated private keys would not work with the JSSE. This has been fixed.\n</ul>\n<h3>2.41.3 Additional Features and Functionality</h3>\n<ul>\n<li>Support for reading/writing OpenPGP public/private keys and OpenPGP signatures has been added.\n<li>Support for generating OpenPGP PBE messages and public key encrypted messages has been added.\n<li>Support for decrypting OpenPGP messages has been added.\n<li>Addition of a Null block cipher to the light weight API.\n</ul>\n\n<h3>2.42.1 Version</h3>\nRelease: 1.19<br/>\nDate:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2003, June 7\n<h3>2.42.2 Defects Fixed</h3>\n<ul>\n<li>The PKCS12 store would throw an exception reading PFX files that had attributes with no values. This has been fixed.\n<li>RSA Private Keys would not serialise if they had PKCS12 bag attributes attached to them, this has been fixed.\n<li>GeneralName was encoding OtherName as explicitly tagged, rather than implicitly tagged. This has been fixed.\n<li>ASN1 parser would sometimes mistake an implicit null for an implicit empty\nsequence. This has been fixed.\n</ul>\n<h3>2.42.3 Additional Features and Functionality</h3>\n<ul>\n<li>S/MIME and CMS now support the draft standard for AES encryption.\n<li>S/MIME and CMS now support setable key sizes for the standard algorithms.\n<li>S/MIME and CMS now handle ARC4/RC4 encrypted messages.\n<li>The CertPath validator now passes the NIST test suite.\n<li>A basic OCSP implementation has been added which includes request generation\nand the processing of responses. Response generation is also provided, but should be treated as alpha quality code.\n<li>CMS now attempts to use JCA naming conventions in addition to the OID name\nin order to find algorithms.\n</ul>\n\n<h3>2.43.1 Version</h3>\nRelease: 1.18<br/>\nDate:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2003, February 8\n<h3>2.43.2 Defects Fixed</h3>\n<ul>\n<li>DESKeySpec.isParityAdjusted in the clean room JCE could go into an\ninfinite loop. This has been fixed.\n<li>The SMIME API would end up throwing a class cast exception if a\nMimeBodyPart was passed in containing a MimeMultipart. This is now fixed.\n<li>ASN1InputStream could go into an infinite loop reading a truncated\ninput stream. This has been fixed.\n<li>Seeding with longs in the SecureRandom for the J2ME and JDK 1.0,\nonly used 4 bytes of the seed value. This has been fixed.\n</ul>\n<h3>2.43.3 Additional Features and Functionality</h3>\n<ul>\n<li>The X.509 OID for RSA is now recognised by the provider as is the OID for RSA/OAEP.\n<li>Default iv's for DES are now handled correctly in CMS.\n<li>The ASN.1 classes have been updated to use the generic ASN1* classes where\npossible.\n<li>A constructor has been added to SMIMESigned to simplify the processing\nof \"application/pkcs7-mime; smime-type=signed-data;\" signatures.\n<li>Diffie-Hellman key generation is now faster in environments using the\nSun BigInteger library.\n</ul>\n<h3>2.44.1 Version</h3>\nRelease: 1.17<br/>\nDate:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2003, January 8\n<h3>2.44.2 Defects Fixed</h3>\n<ul>\n<li>Reuse of an CMSSignedObject could occasionally result in a class\ncast exception. This has been fixed.\n<li>The X.509 DistributionPointName occasionally encoded incorrectly. This has\nbeen fixed.\n<li>BasicConstraints construction would break if an ASN.1 sequence was used\nwith only the required parameter. This has been fixed.\n<li>The DERObject constructor in OriginatorIdentifierOrKey was leaving \nthe id field as null. This has been fixed.\n</ul>\n<h3>2.44.3 Additional Functionality and Features</h3>\n<ul>\n<li>RC2 now supports the full range of parameter versions and effective\nkey sizes.\n<li>CompressedData handling has been added to CMS/SMIME.\n<li>The 1.4 version now allows X500Principles to be generated directly\nfrom CRLs.\n<li>SMIME objects now support binary encoding. The number of signature\ntypes recognised has been increased. \n<li>CMS can create signed objects with encapsulated data. Note: while\nthis was been done we realised we could simplify things, we did and\nfor the most part people won't notice, other than the occasional\nreference to CMSSignable will need to be replaced with CMSProcessable.\n<li>X509Name and X509Principal now support forward and reverse X509Name\nto string conversion, with changeable lookup tables for converting OIDs\ninto strings. Both classes also now allow the direction of encoding to\nbe set when a string is converted as well as changeable lookup tables for\nstring to OID conversion.\n</ul>\n\n<h3>2.45.1 Version</h3>\nRelease: 1.16<br/>\nDate:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2002, November 30\n<h3>2.45.2 Defects Fixed</h3>\n<ul>\n<li>CRLS were only working for UTC time constructed Time objects, this has\nbeen fixed.\n<li>KeyUsage and ReasonFlags sometimes encoded longer than necessary. This\nhas been fixed.\n<li>BER encoded sets are now recognised and dealt with.\n<li>Encoding issues in CMS which were causing problems with backwards\ncompatibility with older CMS/SMIME clients have been fixed.\n<li>KeyFactory now allows for creation of RSAKey*Spec classes.\n<li>The X509CertSelector in the clean room CertPath API is now less likely\nto throw a NullPointerException at the wrong time.\n<li>Macs now clone correctly in the clean room JCE.\n</ul>\n<h3>2.45.3 Additional Functionality and Features</h3>\n<ul>\n<li>PGPCFB support has been added to the provider and the lightweight API.\n<li>There are now three versions of the AESEngine, all faster than before,\nwith the largest footprint one being the fastest. The JCE AES now refers\nto the fastest.\n<li>The 1.4 version of the library now allows for X500Principals to be\ngenerated directly from certificates.\n<li>X509Name has been extended to parse numeric oids, \"oid.\" oids, and to\nrecognise the LDAP UID.\n<li>Immutable sequences and sets have been introduced to the ASN.1 package.\n<li>The SMIME/CMS ASN.1 base classes have been rewritten to reduce the\nsize of the package for use with the lightweight API.\n<li>The SMIME/CMS api's have been rewritten to allow them to take advantage\nof the Cert Path API, remove code suited to inclusion in the provider,\nand to support multiple recipients/signers.\n</ul>\n<h3>2.46.1 Version</h3>\nRelease: 1.15<br/>\nDate:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2002, September 6\n<h3>2.46.2 Defects Fixed</h3>\n<ul>\n<li>The base string for the oids in asn1.x509.KeyPurposeId was incorrect. This\nhas been fixed.\n<li>MimeBodyParts in the SMIME Generator did not have their Content-Type\nproperly set up after decryption. This has been fixed.\n<li>If a X.509 certificate did not have all the keyUsage extension bits set,\nthe provider wasn't padding the return value of the key usage extension to\n8 booleans in length. This has been fixed.\n<li>In some cases the simple BC keystore allowed overwriting of an alias with\none of the same name. This has been fixed.\n<li>The key schedule for RC5-64 was not always being calculated correctly. This\nhas been fixed.\n<li>On reset buffered blockcipher was only partially erasing the previous buffer. This has been fixed.\n<li>All lightweight mac classes now do a reset on doFinal.\n<li>ASN.1 object identifiers wouldn't encode the first byte correctly if the\nOID started with 2 and the second number was greater than 47. This has been\nfixed.\n<li>If a key had PKCS9 attributes associated with it on storage they took\nprecedence over the local alias used to add the key to the PKCS12 key store.\nThe local name now takes precedence.\n<li>ReasonFlags now correctly encodes.\n</ul>\n<h3>2.46.3 Additional Functionality and Features</h3>\n<ul>\n<li>The PKCS12 key store now handles key bags in encryptedData bags.\n<li>The X509NameTokenizer now handles for '\\' and '\"' characters.\n<li>SMIME v2 compliance has been added. Use setVersion(2) in the generator classes.\n<li>The ASN.1 library now supports ENUMERATED, UniversalString and the X.509 library support for CRLs now includes CRLReason, and some elements of CertificatePolicies.\n<li>Both the provider and the lightweight library now support a basic SIC mode for block ciphers.\n</ul>\n<h3>2.47.1 Version</h3>\nRelease: 1.14<br/>\nDate:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2002, June 17\n<h3>2.47.2 Defects Fixed</h3>\n<ul>\n<li>there was a bug in the BigInteger right shifting for > 31 bit shifts.\nThis has been fixed.\n<li>x509 name had it's equality test based on the order of the directory\nelements, this has been fixed.\n<li>the mode used with the RSA cipher in KeyTransRecipientInfoParser in\nthe smime implementation was not compatible with the Sun JCE.\nThis has been fixed.\n<li>PKCS7 SignedData now supports single length signing chains.\n<li>When a root certificate had a different issuer id from the subject id, or\nhad it's own AuthorityKeyExtension the PKCS12 key store would drop the root\ncertificate from the certificate chain. This has been fixed.\n<li>The PKCS10 CertificationRequestInfo class always expected at least one\nattribute. This has been fixed.\n<li>UTF8 strings are now correctly recognised.\n<li>The Tiger implementation was producing results in reverse byte\norder for each of the 3 words making up the digest. This has been fixed.\n<li>asn1.x509.ExtendedKeyUsage used to through a null pointer exception\non construction. This has been fixed.\n</ul>\n<h3>2.47.3 Additional Functionality and Features</h3>\n<ul>\n<li>The BigInteger library now uses Montgomery numbers for modPow and is\nsubstantially faster.\n<li>SMIMECapabilities, and SMIMEEncryptionKeyPreference attributes added to S/MIME.\n<li>Increased range of key sizes available in S/MIME.\n<li>getInstance(ASN1TaggedObject, boolean) methods have been added to most ASN1 types.\nThese deal with implicit/explicit tagging ambiguities with constructed types.\n<li>Added EncryptedPrivateKeyInfo object to the clean room JCE.\n<li>A PEMReader has been added for handling some of the openSSL PEM files.\n<li>The X.509 certificate factory supports a wider range of encodings and\nobject identifiers.\n</ul>\n<h3>2.48.1 Version</h3>\nRelease: 1.13<br/>\nDate:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2002, April 19\n<h3>2.48.2 Defects Fixed</h3>\n<ul>\n    <li>The TBSCertificate object in the ASN.1 library now properly implements\n    the Time object, rather returning UTC time.\n    <li>The DESedeKeyGenerator now supports 112 and 168 bit key generation.\n    <li>Certificates with the keyId set to null in the AuthorityKeyIdentifier extensions would sometimes cause the PKCS12 store to throw a NullPointer exception. This has been fixed.\n    <li>toByteArray in the big integer class was not always producing correct\n    results for negative numbers. This has been Fixed.\n</ul>\n\n<h3>2.48.3 Additional Functionality and Features</h3>\n<ul>\n    <li>The key to keySpec handling of the secret key factories has been improved.\n    <li>There is now a SMIME implementation and a more complete CMS\n        implementation (see CONTRIBUTORS file for additonal details).\n    <li>A CertPath implementation that runs under jdk1.1 and jdk1.4 has also\n    being contributed. A work around to allow it to be used with jdk1.2 and\n    jdk1.3 has also been added. Note: the implementation is not quite complete\n    because policymapping, name and subtree constraints are not yet\n    implemented.\n    <li>The API now supports the generation of PKCS7 signed objects. Note: this\n    is still beta code - one known issue is that it doesn't support single\n    length certificate chains for signing keys.\n</ul>\n\n<h3>2.49.1 Version</h3>\nRelease: 1.12<br/>\nDate:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2002, February 8\n<h3>2.49.2 Defects Fixed</h3>\n<ul>\n    <li>The ASN.1 library was unable to read an empty set object. This has been fixed.\n    <li>Returning sets of critical and non-critical extensions on X.509 certificates could result in a null pointer exception if the certificate had no extensions. This has been fixed.\n    <li>The BC JKS implementation does not follow the conventional one - it has been renamed BKS, an attempt to create a JKS keystore using the BC provider will now result in an exception.\n    <li>The PKCS 10 generator verify(provider) method was ignoring the provider when generating the public key. This has been fixed.\n    <li>The PKCS12 store would throw an OutOfMemoryException if passed a non-PKCS12 file. This has been fixed.\n    <li>In the case where there was no AuthorityKeyIdentifier the PKCS12 store\n    would fail to find certificates further up the signing chain. The store now\n    uses the IssuerDN if no AuthorityKeyIdentifier is specified and the IssuerDN\n    is different from the SubjectDN,\n    <li>PKCS10/CertificationRequestInfo objects with only a single attribute wer\n    not being handled properly. This has been fixed.\n    <li>getExtensionValue for X.509 CRLs was returning the value of the\n    DER-Encoded octet string not the DER-Encoded octet string as required. This\n    has been fixed.\n    <li>the IV algorithm parameters class would improperly throw an exception\n    on initialisation. This has been fixed.\n</ul>\n<h3>2.49.3 Additional Functionality and Features</h3>\n<ul>\n    <li>The AESWrap ciphers will now take IV's.\n    <li>The DES-EDEWrap algorithm described in http://www.ietf.org/internet-drafts/draft-ietf-smime-key-wrap-01.txt is now supported.\n    <li>Support for the ExtendedKeyUsageExtension and the KeyPurposeId has been added.\n    <li>The OID based alias for DSA has been added to the JCE provider.\n    <li>BC key stores now implement the BCKeyStore interface so you can provide your own source of randomness to a key store.\n    <li>The ASN.1 library now supports GeneralizedTime.\n    <li>HMACSHA256, HMACSHA384, and HMACSHA512 are now added.\n    <li>PSS has been added to the JCE, PSS and ISO9796 signers in the lightweight api have been rewritten so they can be used incrementally. SHA256withRSA, SHA384withRSA, and SHA512withRSA have been added.\n    <li>Base support for CMS (RFC 2630) is now provided (see CONTRIBUTORS file\n    for details).\n</ul>\n<h3>2.50.1 Version</h3>\nRelease: 1.11<br/>\nDate:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2001, December 10\n<h3>2.50.2 Defects Fixed</h3>\n<ul>\n<li>X9.23 padding of MACs now works correctly with block size aligned data.\n<li>Loading a corrupted \"UBER\" key store would occasionally cause the\nappearance of hanging. This has been fixed.\n<li>Loading a PKCS12 store where not all certificates had PKCS9 attributes\nassigned to them would cause a NullPointerException. This has been fixed.\n<li>The PKCS12 store wasn't correctly recovering certificate chains of\nlength less than 2 on calling the getCertificateChain method. This has been\nfixed.\n<li>Lone certificates were not been stored in the PKCS12 store. This has been fixed.\n<li>CFB and OFB modes weren't padding iv's more than 1 byte less than the \nblock size of the cipher if the mode was reused with a shorter IV. This has\nbeen fixed.\n<li>IV handling and block size return values for CFB and OFB modes wasn't being handled in the same way as the Sun reference implementation. This has been fixed.\n<li>CertificateInfoRequests were not handling null attributes correctly. This\nhas been fixed.\n<li>Tags for the X.509 GeneralName structure were wrongly encoded. This has been\nfixed.\n<li>getExtensionValue for X.509 certificates was returning the value of the\nDER-Encoded octet string not the DER-Encoded octet string as required. This has\nbeen fixed.\n<li>reset on the version 3 X.509 certificate generator was not flushing the\nextensions. This has been fixed.\n<li>The NetscapeCert type bits were reversed! This has been fixed.\n</ul>\n<h3>2.50.3 Additional Functionality and Features</h3>\n<ul>\n<li>The lightweight API and the JCE provider now support ElGamal.\n<li>X509Principal, and X509Name now supports the \"DC\" attribute and the\ncreation of directory names from vectors.\n<li>RSA-PSS signature padding has been added to the lightweight API.\n<li>EC Public/Private keys are now encoded in accordance with SEC 1. The library\nwill still read older keys as well.\n<li>Added PKCS12-DEF a pkcs12 based key store which works around a bug in\nthe Sun keytool - it always uses the default provider for creating certificates.\n<li>A cut down version of the Rijndael has been added that provides the functionality required to conform the the AES. It is designed to fully support FIPS-197. A fips AES wrapper (AESWrap in the JCE, AESWrapEngine in the lightweight library has also been added).\n<li>Elliptic curve routines now handle uncompressed points as well as the\ncompressed ones.\n</ul>\n<h3>2.50.4 Other changes</h3>\n<ul>\n<li>As the range of public key types supported has expanded the getPublicKey\nmethod on the SubjectPublicKeyInfo class is not always going to work. The\nmore generic method getPublicKeyData has been added and getPublicKey now\nthrows an IOException if there is a problem.\n</ul>\n<h3>2.51.1 Version</h3>\nRelease: 1.10<br/>\nDate:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2001, October 20\n<h3>2.51.2 Defects Fixed</h3>\n<ul>\n<li>The PKCS12 Key Store now interoperates with the JDK key tool. <b>Note:</b> this does mean the the key name passed to the setKeyEntry calls has become\nsignificant.\n<li>The \"int\" constructor for DERInteger only supported ints up to 128. This\nhas been fixed.\n<li>The ASN.1 input streams now handle zero-tagged zero length objects correctly.\n</ul>\n<h3>2.51.3 Additional Functionality and Features</h3>\n<ul>\n<li>The JCE Provider and the lightweight API now support Serpent, CAST5, and CAST6.\n<li>The JCE provider and the lightweight API now has an implementation of ECIES.\n<b>Note:</b> this is based on a draft, don't use it for anything that needs to\nbe kept long term as it may be adjusted.\n<li>Further work has been done on performance - mainly in the symmetric ciphers.\n<li>Support for the generation of PKCS10 certification requests has been added.\n</ul>\n<h3>2.52.1 Version</h3>\nRelease: 1.09<br/>\nDate:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2001, October 6\n<h3>2.52.2 Defects Fixed</h3>\n<ul>\n<li>failure to pass in an RC5 parameters object now results in an exception\nat the upper level of the JCE, rather than falling over in the lightweight\nlibrary.\n<li>ISO10126Padding now incorporates the correct amount of random data.\n<li>The PKCS12 key store wasn't picking up certificate chains properly\nwhen being used to write PKCS12 files. This has been fixed.\n<li>The Twofish engine would call System.exit if the key was too large.\nThis has been fixed.\n<li>In some cases the ASN.1 library wouldn't handle implicit tagging properly.\nThis has been fixed.\n</ul>\n<h3>2.52.3 Additional Functionality and Features</h3>\n<ul>\n<li>Support for RC5-64 has been added to the JCE.\n<li>ISO9796-2 signatures have been added to the JCE and lightweight API.\n<li>A more general paddings packge for use with MACs and block ciphers had been aded to the lightweight API. MACs now allow you to specify padding.\n<li>X9.23 Padding has been added to the JCE and lightwieght API. The old\nPaddedBlockCipher class is now deprecated see org.bouncycastle.crypto.paddings for details.\n<li>SHA-256, SHA-384, and SHA-512 are now added. Note: while the public review\nperiod has finished, these algorithms have not yet been standardised, in the\nevent that final standardisation changes the algorithms these implementations\nwill be changed.\n<li>It's now possible to set bag attributes on items to go into a PKCS12 store,\nusing the org.bouncycastle.jce.interfaces.PKCS12BagAttributeCarrier interface.\n<li>More classses have been added to the ASN.1 package for dealing with\ncertificate extensions and CRLs including a CRL generator. Note: the\nCRL generators should be regarded as under development and subject to change.\n<li>There's now an examples package for the JCE (in addition to the examples\nin org.bouncycastle.jce.provider.test) - org.bouncycastle.jce.examples. It\ncurrently consists of a class showing how to generate a PKCS12 file.\n<li>The X.509 CertificateFactory now includes CRL support.  DER or PEM CRLs may be processed.\n<li>The BigInteger library has been written with a view to making it less\nresource hungry and faster - whether it's fast enough remains to be seen!\n</ul>\n\n<h3>2.53.1 Version</h3>\nRelease: 1.08<br/>\nDate:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2001, September 9\n<h3>2.53.2 Defects Fixed</h3>\n<ul>\n<li>It wasn't possible to specify an ordering for distinguished names in\nX509 certificates. This is now supported.\n<li>In some circumstances stream Ciphers in the JCE would cause null pointer\nexceptions on doFinal. This has been fixed.\n<li>Unpadded ciphers would sometimes buffer the last block of input, even\nif it could be processed. This has been fixed.\n<li>The netscape certificate request class wouldn't compile under JDK 1.1. This\nhas been fixed.\n</ul>\n<h3>2.53.3 Additional Functionality and Features</h3>\n<ul>\n<li>ISO 9796-1 padding is now supported with RSA in the lightweight\nAPI and the JCE.\n<li>support classes have been added for reading and writing PKCS 12 files,\nincluding a keystore for the JCA.\n<li>The message digests MD4, Tiger, and RIPEMD128 have been added to the\nJCE and the lightweight API. Note: MD4 and RIPEMD128 have been added for\ncompatibility purposes only - we recommend you don't use them for anything new!\n<li>The JDK 1.1 certificate classes didn't conform to the JDK 1.2 API as\nthe collections class was not present. Thanks to a donated collections API\nthis is fixed.\n</ul>\n<h3>2.54.1 Version</h3>\nRelease: 1.07<br/>\nDate:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2001, July 9\n<h3>2.54.2 Defects Fixed</h3>\n<ul>\n<li>It turned out that the setOddParity method in the DESParameter class\nwas indeed doing something odd but not what was intended. This is now\nfixed. <b>Note:</b>This will affect some PBE encryptions that were carried\nout with DES, equivalent PBE ciphers to the old PBE DES cipher can be\naccessed by prepending the work \"Broken\" in front of the original PBE cipher\ncall. If you want an example of how to deal with this as a migration issue\nhave a look in org.bouncycastle.jce.provider.JDKKeyStore lines 201-291.\n</ul>\n<h3>2.55.1 Version</h3>\nRelease: 1.06<br/>\nDate:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2001, July 2\n<h3>2.55.2 Defects Fixed</h3>\n<ul>\n<li>Diffie-Hellman keys are now properly serialisable as well as\nencodable.\n<li>Three of the semi-weak keys in the DESParameters, and the DESKeySpec look\nup table, were incorrect. This has been fixed.\n<li>DESEDE key generators now accept 112 and 168 as the key sizes, as well\nas 128 and 192 (for those people who don't like to count the parity bits).\n<li>Providing no strength parameter is passed to the DESede key generator in\nthe JCE provider, the provider now generates DESede keys in the k1-k2-k1\nformat (which is compatible with the Sun reference implementation), otherwise\nyou get what you ask for (3-DES or 2-DES in the minimum number of bytes).\n<li>Base Diffie-Hellman key agreement now works correctly for more than two\nparties.\n<li>Cipher.getAlgorithmParameters was returing null in cases where a cipher\nobject had generated it's own IV. This has been fixed.\n<li>An error in the key store occasionally caused checks of entry types to\nresult in a null pointer exception. This has been fixed.\n<li>RSA key generator in JCE now recognises RSAKeyGenerationParameterSpec.\n<li>Resetting and resusing HMacs in the lightweight and heavyweight libraries\ncaused a NullPointer exception. This has been fixed.\n</ul>\n\n<h3>2.55.3 Additional Functionality</h3>\n<ul>\n<li>ISO10126Padding is now recognised explicitly for block ciphers\nas well.\n<li>The Blowfish implementation is now somewhat faster.\n</ul>\n\n<h3>2.56.1 Version</h3>\nRelease: 1.05<br/>\nDate:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2001, April 17\n<h3>2.56.2 Defects Fixed</h3>\n<ul>\n<li>The DESEDE key generator can now be used to generate 2-Key-DESEDE\nkeys as well as 3-Key-DESEDE keys.\n<li>One of the weak keys in the DESParameters, and the DESKeySpec look\nup table, was incorrect. This has been fixed.\n<li>The PKCS12 generator was only generating the first 128-160 bits of the\nkey correctly (depending on the digest used). This has been fixed.\n<li>The ASN.1 library was skipping explicitly tagged objects of zero length.\nThis has been fixed.\n</ul>\n<h3>2.56.3 Additional Functionality</h3>\n<ul>\n<li>There is now an org.bouncycastle.jce.netscape package which has\na class in for dealing with Netscape Certificate Request objects.\n</ul>\n<h3>2.56.4 Additional Notes</h3>\n<p>\nConcerning the PKCS12 fix: in a few cases this may cause some backward\ncompatibility issues - if this happens to you, drop us a line at\n<a href=\"mailto:feedback-crypto@bouncycastle.org\">feedback-crypto@bouncycastle.org</a>\nand we will help you get it sorted out.\n\n<h3>2.57.1 Version</h3>\nRelease: 1.04<br/>\nDate:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2001, March 11\n<h3>2.57.2 Defects Fixed</h3>\n<ul>\n<li>Signatures generated by other providers that include optional null\nparameters in the AlgorithmIdentifier are now handled correctly by the\nprovider.\n<li>The JCE 1.2.1 states that the names of algorithms associated with the JCE\nare case insensitive. The class that matches algorithms to names now tries\nto match the name given with it's equivalent in upper case, before trying\nto match it as given. If you write a provider and include versions of your\nalgorithm names in uppercase only, this JCE implementation will always\nmatch a getInstance regardless of the case of the algorithm passed into\nthe getInstance method.\n<li>If the JCE API and the Provider were in a different class path, the\nclass loader being used sometimes failed to find classes for JCE Ciphers, etc.\nThis has been fixed.\n<li>An error in the ASN.1 library was causing problems serialising Diffie-Hellman keys. This has been fixed.\n<li>The agreement package was left out of the j2me bat file. This has been fixed.\n<li>The BigInteger class for 1.0 and the j2me wasn't able to generate random\nintegers (prime or otherwise). This has been fixed. \n<li>The BigInteger class would sometimes go into a death spiral if the any\n32nd bit of an exponent was set when modPow was called. This has been fixed. \n<li>Cipher.getInstance would treat \"//\" in a transformation as a single \"/\".\nThis has been fixed.\n<li>PBEWithSHAAndIDEA-CBC was throwing an exception on initialisation. This has\nbeen fixed.\n<li>The X509Name class in the asn1.x509 package wasn't initialising its local\nhash table when the hash table constructor was called. This has been fixed.\n</ul>\n\n<h3>2.57.3 Additional Functionality</h3>\n<ul>\n<li>Added Elliptic Curve DSA (X9.62) - ECDSA - to provider and lightweight\nlibrary.\n<li>Added Elliptic Curve basic Diffie-Hellman to provider and lightweight\nlibrary.\n<li>Added DSA support to the provider and the lightweight library.\n<li>Added super class interfaces for basic Diffie-Hellman agreement classes\nto lightweight library.\n<li>The certificate generators now support ECDSA and DSA certs as well.\n</ul>\n\n<h3>2.58.1 Version</h3>\nRelease: 1.03<br/>\nDate:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2001, January 7\n<h3>2.58.2 Defects Fixed</h3>\n<ul>\n<li>CFB and OFB modes when specified without padding would insist on input\nbeing block aligned. When specified without padding CFB and OFB now behave in a compatible \nfashion (a doFinal on a partial block will yield just the data that could\nbe processed).\nIn short, it provides another way of generating cipher text the same\nlength as the plain text.\n</ul>\n\n<h3>2.59.1 Version</h3>\nRelease: 1.02<br/>\nDate:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2000, November 7\n<h3>2.59.2 Defects Fixed</h3>\n<ul>\n<li>The RSA key pair generator occasionally produced keys 1 bit under the\nrequested size. This is now fixed.\n</ul>\n\n<h3>2.60.1 Version</h3>\nRelease: 1.01<br/>\nDate:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2000, October 15\n<h3>2.60.2 Defects Fixed</h3>\n\n<ul>\n<li>Buffered ciphers in lightweight library were not resetting correctly\non a doFinal. This has been fixed.\n</ul>\n\n<h3>2.61.1 Version</h3>\nRelease: 1.00<br/>\nDate:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2000, October 13\n<h3>2.61.2 Defects Fixed</h3>\n<p>\n<ul>\n<li>JDK1.2 version now works with keytool for certificate generation.\n<li>Certificate toString method no longer throws a null pointer exception\nif a group [3] extension has not been added.\n<li>Under some circumstances the NullCipher would throw a NullPointerException,\nthis has been fixed.\n<li>Under some circumstances CipherInputStream would throw a NullPointerException, this has been fixed.\n<li>OpenSSL/SSLeay private key encodings would cause an exception to be thrown\nby the RSA key factory. This is now fixed.\n<li>The Cipher class always used the default provider even when one was specified, this has been fixed.\n<li>Some DES PBE algorithms did not set the parity correctly in generated keys, this has been fixed.\n</ul>\n\n<h3>2.61.3 Additional functionality</h3>\n<p>\n<ul>\n<li>Argument validation is much improved.\n<li>An X509KeyUsage class has been added to the JCE class to make it easier\nto specify the KeyUsage extension on X.509 certificates.\n<li>The library now allows creation of version 1 certificates as well.\n</ul>\n\n<h3>3.0 Notes</h3>\n<p>\nThe J2ME is only supported under Windows.\n<p>\nIf you are trying to use the lightweight provider in a JDK 1.0 applet, you\nneed to change the package names for java.math.BigInteger, java.lang.IllegalStateException, and java.security.SecureRandom\n<p>\nThe RSA test under JDK 1.0 and J2ME takes a while to run...\n</body>\n</html>\n", "package org.bouncycastle.pqc.jcajce.provider.xmss;\n\nimport java.io.IOException;\nimport java.security.PrivateKey;\n\nimport org.bouncycastle.asn1.ASN1ObjectIdentifier;\nimport org.bouncycastle.asn1.pkcs.PrivateKeyInfo;\nimport org.bouncycastle.asn1.x509.AlgorithmIdentifier;\nimport org.bouncycastle.crypto.CipherParameters;\nimport org.bouncycastle.pqc.asn1.PQCObjectIdentifiers;\nimport org.bouncycastle.pqc.asn1.XMSSMTKeyParams;\nimport org.bouncycastle.pqc.asn1.XMSSMTPrivateKey;\nimport org.bouncycastle.pqc.asn1.XMSSPrivateKey;\nimport org.bouncycastle.pqc.crypto.xmss.BDSStateMap;\nimport org.bouncycastle.pqc.crypto.xmss.XMSSMTParameters;\nimport org.bouncycastle.pqc.crypto.xmss.XMSSMTPrivateKeyParameters;\nimport org.bouncycastle.pqc.crypto.xmss.XMSSUtil;\nimport org.bouncycastle.pqc.jcajce.interfaces.XMSSMTKey;\nimport org.bouncycastle.util.Arrays;\n\npublic class BCXMSSMTPrivateKey\n    implements PrivateKey, XMSSMTKey\n{\n    private final ASN1ObjectIdentifier treeDigest;\n    private final XMSSMTPrivateKeyParameters keyParams;\n\n    public BCXMSSMTPrivateKey(\n        ASN1ObjectIdentifier treeDigest,\n        XMSSMTPrivateKeyParameters keyParams)\n    {\n        this.treeDigest = treeDigest;\n        this.keyParams = keyParams;\n    }\n\n    public BCXMSSMTPrivateKey(PrivateKeyInfo keyInfo)\n        throws IOException\n    {\n        XMSSMTKeyParams keyParams = XMSSMTKeyParams.getInstance(keyInfo.getPrivateKeyAlgorithm().getParameters());\n        this.treeDigest = keyParams.getTreeDigest().getAlgorithm();\n\n        XMSSPrivateKey xmssMtPrivateKey = XMSSPrivateKey.getInstance(keyInfo.parsePrivateKey());\n\n        try\n        {\n            XMSSMTPrivateKeyParameters.Builder keyBuilder = new XMSSMTPrivateKeyParameters\n                .Builder(new XMSSMTParameters(keyParams.getHeight(), keyParams.getLayers(), DigestUtil.getDigest(treeDigest)))\n                .withIndex(xmssMtPrivateKey.getIndex())\n                .withSecretKeySeed(xmssMtPrivateKey.getSecretKeySeed())\n                .withSecretKeyPRF(xmssMtPrivateKey.getSecretKeyPRF())\n                .withPublicSeed(xmssMtPrivateKey.getPublicSeed())\n                .withRoot(xmssMtPrivateKey.getRoot());\n\n            if (xmssMtPrivateKey.getBdsState() != null)\n            {\n                keyBuilder.withBDSState((BDSStateMap)XMSSUtil.deserialize(xmssMtPrivateKey.getBdsState(), BDSStateMap.class));\n            }\n\n            this.keyParams = keyBuilder.build();\n        }\n        catch (ClassNotFoundException e)\n        {\n            throw new IOException(\"ClassNotFoundException processing BDS state: \" + e.getMessage());\n        }\n    }\n\n    public String getAlgorithm()\n    {\n        return \"XMSSMT\";\n    }\n\n    public String getFormat()\n    {\n        return \"PKCS#8\";\n    }\n\n    public byte[] getEncoded()\n    {\n        PrivateKeyInfo pki;\n        try\n        {\n            AlgorithmIdentifier algorithmIdentifier = new AlgorithmIdentifier(PQCObjectIdentifiers.xmss_mt, new XMSSMTKeyParams(keyParams.getParameters().getHeight(), keyParams.getParameters().getLayers(), new AlgorithmIdentifier(treeDigest)));\n            pki = new PrivateKeyInfo(algorithmIdentifier, createKeyStructure());\n\n            return pki.getEncoded();\n        }\n        catch (IOException e)\n        {\n            return null;\n        }\n    }\n\n    CipherParameters getKeyParams()\n    {\n        return keyParams;\n    }\n\n    public boolean equals(Object o)\n    {\n        if (o == this)\n        {\n            return true;\n        }\n\n        if (o instanceof BCXMSSMTPrivateKey)\n        {\n            BCXMSSMTPrivateKey otherKey = (BCXMSSMTPrivateKey)o;\n\n            return treeDigest.equals(otherKey.treeDigest) && Arrays.areEqual(keyParams.toByteArray(), otherKey.keyParams.toByteArray());\n        }\n\n        return false;\n    }\n\n    public int hashCode()\n    {\n        return treeDigest.hashCode() + 37 * Arrays.hashCode(keyParams.toByteArray());\n    }\n\n    private XMSSMTPrivateKey createKeyStructure()\n    {\n        byte[] keyData = keyParams.toByteArray();\n\n        int n = keyParams.getParameters().getDigestSize();\n        int totalHeight = keyParams.getParameters().getHeight();\n        int indexSize = (totalHeight + 7) / 8;\n        int secretKeySize = n;\n        int secretKeyPRFSize = n;\n        int publicSeedSize = n;\n        int rootSize = n;\n\n        int position = 0;\n        int index = (int)XMSSUtil.bytesToXBigEndian(keyData, position, indexSize);\n        if (!XMSSUtil.isIndexValid(totalHeight, index))\n        {\n            throw new IllegalArgumentException(\"index out of bounds\");\n        }\n        position += indexSize;\n        byte[] secretKeySeed = XMSSUtil.extractBytesAtOffset(keyData, position, secretKeySize);\n        position += secretKeySize;\n        byte[] secretKeyPRF = XMSSUtil.extractBytesAtOffset(keyData, position, secretKeyPRFSize);\n        position += secretKeyPRFSize;\n        byte[] publicSeed = XMSSUtil.extractBytesAtOffset(keyData, position, publicSeedSize);\n        position += publicSeedSize;\n        byte[] root = XMSSUtil.extractBytesAtOffset(keyData, position, rootSize);\n        position += rootSize;\n               /* import BDS state */\n        byte[] bdsStateBinary = XMSSUtil.extractBytesAtOffset(keyData, position, keyData.length - position);\n\n        return new XMSSMTPrivateKey(index, secretKeySeed, secretKeyPRF, publicSeed, root, bdsStateBinary);\n    }\n\n    ASN1ObjectIdentifier getTreeDigestOID()\n    {\n        return treeDigest;\n    }\n\n    public int getHeight()\n    {\n        return keyParams.getParameters().getHeight();\n    }\n\n    public int getLayers()\n    {\n        return keyParams.getParameters().getLayers();\n    }\n\n    public String getTreeDigest()\n    {\n        return DigestUtil.getXMSSDigestName(treeDigest);\n    }\n}\n", "package org.bouncycastle.pqc.jcajce.provider.xmss;\n\nimport java.io.IOException;\nimport java.security.PrivateKey;\n\nimport org.bouncycastle.asn1.ASN1ObjectIdentifier;\nimport org.bouncycastle.asn1.pkcs.PrivateKeyInfo;\nimport org.bouncycastle.asn1.x509.AlgorithmIdentifier;\nimport org.bouncycastle.crypto.CipherParameters;\nimport org.bouncycastle.pqc.asn1.PQCObjectIdentifiers;\nimport org.bouncycastle.pqc.asn1.XMSSKeyParams;\nimport org.bouncycastle.pqc.asn1.XMSSPrivateKey;\nimport org.bouncycastle.pqc.crypto.xmss.BDS;\nimport org.bouncycastle.pqc.crypto.xmss.XMSSParameters;\nimport org.bouncycastle.pqc.crypto.xmss.XMSSPrivateKeyParameters;\nimport org.bouncycastle.pqc.crypto.xmss.XMSSUtil;\nimport org.bouncycastle.pqc.jcajce.interfaces.XMSSKey;\nimport org.bouncycastle.util.Arrays;\n\npublic class BCXMSSPrivateKey\n    implements PrivateKey, XMSSKey\n{\n    private final XMSSPrivateKeyParameters keyParams;\n    private final ASN1ObjectIdentifier treeDigest;\n\n    public BCXMSSPrivateKey(\n        ASN1ObjectIdentifier treeDigest,\n        XMSSPrivateKeyParameters keyParams)\n    {\n        this.treeDigest = treeDigest;\n        this.keyParams = keyParams;\n    }\n\n    public BCXMSSPrivateKey(PrivateKeyInfo keyInfo)\n        throws IOException\n    {\n        XMSSKeyParams keyParams = XMSSKeyParams.getInstance(keyInfo.getPrivateKeyAlgorithm().getParameters());\n        this.treeDigest = keyParams.getTreeDigest().getAlgorithm();\n\n        XMSSPrivateKey xmssPrivateKey = XMSSPrivateKey.getInstance(keyInfo.parsePrivateKey());\n\n        try\n        {\n            XMSSPrivateKeyParameters.Builder keyBuilder = new XMSSPrivateKeyParameters\n                .Builder(new XMSSParameters(keyParams.getHeight(), DigestUtil.getDigest(treeDigest)))\n                .withIndex(xmssPrivateKey.getIndex())\n                .withSecretKeySeed(xmssPrivateKey.getSecretKeySeed())\n                .withSecretKeyPRF(xmssPrivateKey.getSecretKeyPRF())\n                .withPublicSeed(xmssPrivateKey.getPublicSeed())\n                .withRoot(xmssPrivateKey.getRoot());\n\n            if (xmssPrivateKey.getBdsState() != null)\n            {\n                keyBuilder.withBDSState((BDS)XMSSUtil.deserialize(xmssPrivateKey.getBdsState(), BDS.class));\n            }\n\n            this.keyParams = keyBuilder.build();\n        }\n        catch (ClassNotFoundException e)\n        {\n            throw new IOException(\"ClassNotFoundException processing BDS state: \" + e.getMessage());\n        }\n    }\n\n    public String getAlgorithm()\n    {\n        return \"XMSS\";\n    }\n\n    public String getFormat()\n    {\n        return \"PKCS#8\";\n    }\n\n    public byte[] getEncoded()\n    {\n        PrivateKeyInfo pki;\n        try\n        {\n            AlgorithmIdentifier algorithmIdentifier = new AlgorithmIdentifier(PQCObjectIdentifiers.xmss, new XMSSKeyParams(keyParams.getParameters().getHeight(), new AlgorithmIdentifier(treeDigest)));\n            pki = new PrivateKeyInfo(algorithmIdentifier, createKeyStructure());\n\n            return pki.getEncoded();\n        }\n        catch (IOException e)\n        {\n            return null;\n        }\n    }\n\n    public boolean equals(Object o)\n    {\n        if (o == this)\n        {\n            return true;\n        }\n\n        if (o instanceof BCXMSSPrivateKey)\n        {\n            BCXMSSPrivateKey otherKey = (BCXMSSPrivateKey)o;\n\n            return treeDigest.equals(otherKey.treeDigest) && Arrays.areEqual(keyParams.toByteArray(), otherKey.keyParams.toByteArray());\n        }\n\n        return false;\n    }\n\n    public int hashCode()\n    {\n        return treeDigest.hashCode() + 37 * Arrays.hashCode(keyParams.toByteArray());\n    }\n\n    CipherParameters getKeyParams()\n    {\n        return keyParams;\n    }\n\n    private XMSSPrivateKey createKeyStructure()\n    {\n        byte[] keyData = keyParams.toByteArray();\n\n        int n = keyParams.getParameters().getDigestSize();\n        int totalHeight = keyParams.getParameters().getHeight();\n        int indexSize = 4;\n        int secretKeySize = n;\n        int secretKeyPRFSize = n;\n        int publicSeedSize = n;\n        int rootSize = n;\n\n        int position = 0;\n        int index = (int)XMSSUtil.bytesToXBigEndian(keyData, position, indexSize);\n        if (!XMSSUtil.isIndexValid(totalHeight, index))\n        {\n            throw new IllegalArgumentException(\"index out of bounds\");\n        }\n        position += indexSize;\n        byte[] secretKeySeed = XMSSUtil.extractBytesAtOffset(keyData, position, secretKeySize);\n        position += secretKeySize;\n        byte[] secretKeyPRF = XMSSUtil.extractBytesAtOffset(keyData, position, secretKeyPRFSize);\n        position += secretKeyPRFSize;\n        byte[] publicSeed = XMSSUtil.extractBytesAtOffset(keyData, position, publicSeedSize);\n        position += publicSeedSize;\n        byte[] root = XMSSUtil.extractBytesAtOffset(keyData, position, rootSize);\n        position += rootSize;\n               /* import BDS state */\n        byte[] bdsStateBinary = XMSSUtil.extractBytesAtOffset(keyData, position, keyData.length - position);\n\n        return new XMSSPrivateKey(index, secretKeySeed, secretKeyPRF, publicSeed, root, bdsStateBinary);\n    }\n\n    ASN1ObjectIdentifier getTreeDigestOID()\n    {\n        return treeDigest;\n    }\n\n    public int getHeight()\n    {\n        return keyParams.getParameters().getHeight();\n    }\n\n    public String getTreeDigest()\n    {\n        return DigestUtil.getXMSSDigestName(treeDigest);\n    }\n}\n"], "filenames": ["core/src/main/java/org/bouncycastle/pqc/crypto/gmss/GMSSKeyPairGenerator.java", "core/src/main/java/org/bouncycastle/pqc/crypto/rainbow/RainbowParameters.java", "core/src/main/java/org/bouncycastle/pqc/crypto/xmss/XMSSMTPrivateKeyParameters.java", "core/src/main/java/org/bouncycastle/pqc/crypto/xmss/XMSSPrivateKeyParameters.java", "core/src/main/java/org/bouncycastle/pqc/crypto/xmss/XMSSUtil.java", "core/src/main/java/org/bouncycastle/pqc/math/linearalgebra/GF2nField.java", "core/src/test/java/org/bouncycastle/pqc/crypto/test/XMSSMTPrivateKeyTest.java", "docs/releasenotes.html", "prov/src/main/java/org/bouncycastle/pqc/jcajce/provider/xmss/BCXMSSMTPrivateKey.java", "prov/src/main/java/org/bouncycastle/pqc/jcajce/provider/xmss/BCXMSSPrivateKey.java"], "buggy_code_start_loc": [181, 47, 71, 89, 324, 158, 7, 30, 55, 54], "buggy_code_end_loc": [201, 78, 274, 109, 330, 168, 21, 30, 56, 55], "fixing_code_start_loc": [181, 47, 70, 88, 324, 158, 8, 31, 55, 54], "fixing_code_end_loc": [194, 71, 271, 108, 343, 161, 63, 32, 56, 55], "type": "CWE-470", "message": "Legion of the Bouncy Castle Legion of the Bouncy Castle Java Cryptography APIs 1.58 up to but not including 1.60 contains a CWE-470: Use of Externally-Controlled Input to Select Classes or Code ('Unsafe Reflection') vulnerability in XMSS/XMSS^MT private key deserialization that can result in Deserializing an XMSS/XMSS^MT private key can result in the execution of unexpected code. This attack appear to be exploitable via A handcrafted private key can include references to unexpected classes which will be picked up from the class path for the executing application. This vulnerability appears to have been fixed in 1.60 and later.", "other": {"cve": {"id": "CVE-2018-1000613", "sourceIdentifier": "cve@mitre.org", "published": "2018-07-09T20:29:00.283", "lastModified": "2022-01-14T15:20:35.167", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Legion of the Bouncy Castle Legion of the Bouncy Castle Java Cryptography APIs 1.58 up to but not including 1.60 contains a CWE-470: Use of Externally-Controlled Input to Select Classes or Code ('Unsafe Reflection') vulnerability in XMSS/XMSS^MT private key deserialization that can result in Deserializing an XMSS/XMSS^MT private key can result in the execution of unexpected code. This attack appear to be exploitable via A handcrafted private key can include references to unexpected classes which will be picked up from the class path for the executing application. This vulnerability appears to have been fixed in 1.60 and later."}, {"lang": "es", "value": "Las API Legion of the Bouncy Castle Java Cryptography de Legion of the Bouncy Castle en versiones hasta 1.58 pero sin incluir la versi\u00f3n 1.60, contiene una debilidad CWE-470: Use of Externally-Controlled Input to Select Classes or Code ('Unsafe Reflection'), vulnerabilidad en la deserializaci\u00f3n de la clave privada XMSS/XMSS^MT que puede resultar en desrealizar una clave privada XMSS/XMSS^MT puede resultar en la ejecuci\u00f3n de c\u00f3digo inesperado. Este ataque parece ser explotable por medio de una clave privada artesanal que puede incluir referencias a clases inesperadas que se recoger\u00e1n del class path para la aplicaci\u00f3n en ejecuci\u00f3n. Esta vulnerabilidad parece haber sido solucionada en la versi\u00f3n 1.60 y versiones posteriores."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-470"}, {"lang": "en", "value": "CWE-502"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:bouncycastle:legion-of-the-bouncy-castle-java-crytography-api:*:*:*:*:*:*:*:*", "versionStartIncluding": "1.58", "versionEndExcluding": "1.60", "matchCriteriaId": "103B84A1-259F-499D-BF18-BC356433F826"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:netapp:oncommand_workflow_automation:-:*:*:*:*:*:*:*", "matchCriteriaId": "5735E553-9731-4AAC-BCFF-989377F817B3"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:leap:15.1:*:*:*:*:*:*:*", "matchCriteriaId": "B620311B-34A3-48A6-82DF-6F078D7A4493"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:oracle:api_gateway:11.1.2.4.0:*:*:*:*:*:*:*", "matchCriteriaId": "A5553591-073B-45E3-999F-21B8BA2EEE22"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:banking_platform:2.6.0:*:*:*:*:*:*:*", "matchCriteriaId": "8972497F-6E24-45A9-9A18-EB0E842CB1D4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:banking_platform:2.6.1:*:*:*:*:*:*:*", "matchCriteriaId": "400509A8-D6F2-432C-A2F1-AD5B8778D0D9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:banking_platform:2.6.2:*:*:*:*:*:*:*", "matchCriteriaId": "132CE62A-FBFC-4001-81EC-35D81F73AF48"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:business_process_management_suite:11.1.1.9.0:*:*:*:*:*:*:*", "matchCriteriaId": "013043A2-0765-4AF5-ABFC-6A8960FFBFD2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:business_process_management_suite:12.1.3.0.0:*:*:*:*:*:*:*", "matchCriteriaId": "B887E174-57AB-449D-AEE4-82DD1A3E5C84"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:business_process_management_suite:12.2.1.3.0:*:*:*:*:*:*:*", "matchCriteriaId": "E869C417-C0E6-4FC3-B406-45598A1D1906"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:business_transaction_management:12.1.0:*:*:*:*:*:*:*", "matchCriteriaId": "FD9D7511-2934-4974-9C9E-3BE03B846734"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:communications_application_session_controller:3.7.1:*:*:*:*:*:*:*", "matchCriteriaId": "CC967A48-D834-4E9B-8CEC-057E7D5B8174"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:communications_application_session_controller:3.8.0:*:*:*:*:*:*:*", "matchCriteriaId": "F920CDE4-DF29-4611-93E9-A386C89EDB62"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:communications_converged_application_server:*:*:*:*:*:*:*:*", "versionEndExcluding": "7.0.0.1", "matchCriteriaId": "EC361999-AAD8-4CB3-B00E-E3990C3529B4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:communications_converged_application_server:7.0.0.1:*:*:*:*:*:*:*", "matchCriteriaId": "5BDED89A-7C6F-41E9-A91F-9B09D401F85D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:communications_convergence:3.0.2:*:*:*:*:*:*:*", "matchCriteriaId": "19E630B9-B5E5-442A-B75C-1E4771072A03"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:communications_diameter_signaling_router:8.0.0:*:*:*:*:*:*:*", "matchCriteriaId": "A9317C01-22AA-452B-BBBF-5FAFFFB8BEA4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:communications_diameter_signaling_router:8.1:*:*:*:*:*:*:*", "matchCriteriaId": "C4534CF9-D9FD-4936-9D8C-077387028A05"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:communications_diameter_signaling_router:8.2:*:*:*:*:*:*:*", "matchCriteriaId": "D60384BD-284C-4A68-9EEF-0FAFDF0C21F3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:communications_diameter_signaling_router:8.2.1:*:*:*:*:*:*:*", "matchCriteriaId": "FCA44E38-EB8C-4E2D-8611-B201F47520E9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:communications_webrtc_session_controller:*:*:*:*:*:*:*:*", "versionEndExcluding": "7.2", "matchCriteriaId": "77120A3C-9A48-45FC-A620-5072AF325ACF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:communications_webrtc_session_controller:7.2:*:*:*:*:*:*:*", "matchCriteriaId": "726DB59B-00C7-444E-83F7-CB31032482AB"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:data_integrator:12.2.1.3.0:*:*:*:*:*:*:*", "matchCriteriaId": "9901F6BA-78D5-45B8-9409-07FF1C6DDD38"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:enterprise_manager_base_platform:12.1.0.5.0:*:*:*:*:*:*:*", "matchCriteriaId": "98F3E643-4B65-4668-BB11-C61ED54D5A53"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:enterprise_manager_base_platform:13.2.0.0:*:*:*:*:*:*:*", "matchCriteriaId": "1FEB8446-7EAC-4A8D-B6EE-3AAC2294C324"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:enterprise_manager_base_platform:13.3.0.0:*:*:*:*:*:*:*", "matchCriteriaId": "7582B307-3899-4BBB-B868-BC912A4D0109"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:enterprise_manager_for_fusion_middleware:13.2.0.0:*:*:*:*:*:*:*", "matchCriteriaId": "6F4E0F9A-D925-43FB-A1B7-452EEAE6BE2D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:enterprise_manager_for_fusion_middleware:13.3.0.0:*:*:*:*:*:*:*", "matchCriteriaId": "96B35E9A-5557-4D77-AE53-816B3C481E02"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:enterprise_repository:11.1.1.7.0:*:*:*:*:*:*:*", "matchCriteriaId": "69300B13-8C0F-4433-A6E8-B2CE32C4723D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:enterprise_repository:12.1.3.0.0:*:*:*:*:*:*:*", "matchCriteriaId": "F9E13DD9-F456-4802-84AD-A2A1F12FE999"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:managed_file_transfer:12.1.3.0.0:*:*:*:*:*:*:*", "matchCriteriaId": "AEB446C9-1AC2-4D7D-83DE-08934DDFC8B4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:managed_file_transfer:12.2.1.3.0:*:*:*:*:*:*:*", "matchCriteriaId": "A2E3E923-E2AD-400D-A618-26ADF7F841A2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:peoplesoft_enterprise_peopletools:8.55:*:*:*:*:*:*:*", "matchCriteriaId": "45CB30A1-B2C9-4BF5-B510-1F2F18B60C64"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:peoplesoft_enterprise_peopletools:8.56:*:*:*:*:*:*:*", "matchCriteriaId": "D0A735B4-4F3C-416B-8C08-9CB21BAD2889"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:peoplesoft_enterprise_peopletools:8.57:*:*:*:*:*:*:*", "matchCriteriaId": "7E1E416B-920B-49A0-9523-382898C2979D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:retail_convenience_and_fuel_pos_software:2.8.1:*:*:*:*:*:*:*", "matchCriteriaId": "78DE9DFD-BB57-4BCF-BF73-FFCFF62420D5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:retail_xstore_point_of_service:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "2F87FC90-16D0-4051-8280-B0DD4441F10B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:retail_xstore_point_of_service:7.1:*:*:*:*:*:*:*", "matchCriteriaId": "A0ED83E3-E6BF-4EAA-AF8F-33485A88A218"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:soa_suite:12.1.3.0.0:*:*:*:*:*:*:*", "matchCriteriaId": "AF4C318C-5D1E-479B-9597-9FAD9E186111"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:soa_suite:12.2.1.3.0:*:*:*:*:*:*:*", "matchCriteriaId": "65994DC4-C9C0-48B0-88AB-E2958B4EB9E3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:utilities_network_management_system:1.12.0.3:*:*:*:*:*:*:*", "matchCriteriaId": "EE188B12-D28E-490C-9948-F5305A7D55BF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:utilities_network_management_system:2.3.0.0:*:*:*:*:*:*:*", "matchCriteriaId": "51D7B9B6-B41A-4DEA-9946-59A84FAC57E5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:utilities_network_management_system:2.3.0.1:*:*:*:*:*:*:*", "matchCriteriaId": "1EB1CD1A-E760-4357-AF51-B38A852FA980"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:utilities_network_management_system:2.3.0.2:*:*:*:*:*:*:*", "matchCriteriaId": "693C97B5-25B4-4DF3-A7D7-02C722A3DD88"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:webcenter_portal:11.1.1.9.0:*:*:*:*:*:*:*", "matchCriteriaId": "D7756147-7168-4E03-93EE-31379F6BE88E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:webcenter_portal:12.2.1.3.0:*:*:*:*:*:*:*", "matchCriteriaId": "D6A4F71A-4269-40FC-8F61-1D1301F2B728"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:weblogic_server:12.2.1.3:*:*:*:*:*:*:*", "matchCriteriaId": "CBFF04EF-B1C3-4601-878A-35EA6A15EF0C"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-security-announce/2020-05/msg00011.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://github.com/bcgit/bc-java/commit/4092ede58da51af9a21e4825fbad0d9a3ef5a223#diff-2c06e2edef41db889ee14899e12bd574", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/bcgit/bc-java/commit/cd98322b171b15b3f88c5ec871175147893c31e6#diff-148a6c098af0199192d6aede960f45dc", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/rf1bbc0ea4a9f014cf94df9a12a6477d24a27f52741dbc87f2fd52ff2@%3Cissues.geode.apache.org%3E", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20190204-0003/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.oracle.com/security-alerts/cpuApr2021.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.oracle.com/security-alerts/cpuapr2020.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.oracle.com/security-alerts/cpuoct2020.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.oracle.com/technetwork/security-advisory/cpuapr2019-5072813.html", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://www.oracle.com/technetwork/security-advisory/cpujan2019-5072801.html", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://www.oracle.com/technetwork/security-advisory/cpujul2019-5072835.html", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/bcgit/bc-java/commit/4092ede58da51af9a21e4825fbad0d9a3ef5a223#diff-2c06e2edef41db889ee14899e12bd574"}}