{"buggy_code": ["<?php\n/**\n * Created by PhpStorm.\n * User: msyk\n * Date: 2017/04/24\n * Time: 17:41\n */\n// First of all, the FMDataAPI.php file has to be included. All classes are defined in it.\ninclude_once \"../FMDataAPI.php\";\n\n// For your convenience, the main class name FMDataAPI is defined at the current namespace.\nuse INTERMediator\\FileMakerServer\\RESTAPI\\FMDataAPI as FMDataAPI;\n\n// FMDataAPI class handles an error as an exception by default.\ntry {\n    // Instantiate the class FMDataAPI with database name, user name, password and host.\n    // Although the port number and protocol can be set in parameters of constructor,\n    // these parameters can be omitted with default values.\n    $fmdb = new FMDataAPI(\"TestDB\", \"web\", \"password\", \"localhost\");\n\n    //==============================\n    //$fmdb = new FMDataAPI(\"TestDB\", \"web\", \"password\", \"localserver\");\n    // \"localserver\" is added on Ver.2 and it's a magic term for FMDataAPI. It happens direct connect to\n    // FileMaker Server in the same host. I've refered Atsushi Matsuo's script below and I got his way\n    // to be able to connect port number 3000.\n    // https://gist.github.com/matsuo/ef5cb7c98bb494d507731886883bcbc1\n    //==============================\n\n    // If you want to try this program just right now, it's convinient to download the FileMaker database file:\n    // https://github.com/INTER-Mediator/INTER-Mediator/blob/master/dist-docs/TestDB.fmp12?raw=true\n\n    // You can turn off to throw an exception in case of error. You have to handle errors with checking result error.\n    $fmdb->setThrowException(false);\n\n    // If you call with true, the debug mode is activated. Debug mode echos the contents of communication\n    // such as request and response.\n    $fmdb->setDebug(true);\n\n    // If you call with true, the certificate from the server is going to verify.\n    // In case of self-signed one (usually default situation), you don't have to call this method.\n    //$fmdb->setCertValidating(true);\n\n    // Metadata API is the new feature of FMS18.\n    $pInfo = var_export($fmdb->getProductInfo(), true);\n    echo \"Product Info: {$pInfo}<hr>\";\n    $pInfo = var_export($fmdb->getDatabaseNames(), true);\n    echo \"Database Names: {$pInfo}<hr>\";\n    $pInfo = var_export($fmdb->getLayoutNames(), true);\n    echo \"Layout Names: {$pInfo}<hr>\";\n    $pInfo = var_export($fmdb->getScriptNames(), true);\n    echo \"Script Names: {$pInfo}<hr>\";\n    $result = $fmdb->person_layout->getMetadata();\n    $pInfo = var_export($result, true);\n    echo \"Layout Metadata: {$pInfo}<hr>\";\n    $result = $fmdb->person_layout->getMetadataOld();\n    $pInfo = var_export($result, true);\n    echo \"Layout Metadata (Old): {$pInfo}<hr>\";\n\n    // The FMDataAPI has the property as the same name of layout. This sample database has the 'person_layout' layout,\n    // so '$fmdb->person_layout' refers FMLayout object fo the proxy of the layout. FMLayout class has the 'query' method\n    // and returns FileMakerRelation class's object. The condition spefied in parameter is same as FileMaker's Find Record API.\n    $result = $fmdb->person_layout->query(/*array(array(\"id\" => \">1\"))*/);\n\n    // The 'httpStatus()' method returns the HTTP status code in the latest response.\n    echo \"HTTP Status: {$fmdb->httpStatus()}<hr>\";\n\n    // The following two methods return the error code and message of the latest API call which is submitted in query() method.\n    // You can check API calling succeed or fail if error code is or isn't 0 every after API calling methods.\n    echo \"Error Code: {$fmdb->errorCode()}<hr>\";\n    echo \"Error Message: {$fmdb->errorMessage()}<hr>\";\n\n    // If the query is succeed, the following information can be detected.\n    echo \"Target Table: {$fmdb->getTargetTable()}<hr>\";\n    echo \"Total Count: {$fmdb->getTotalCount()}<hr>\";\n    echo \"Found Count: {$fmdb->getFoundCount()}<hr>\";\n    echo \"Returned Count: {$fmdb->getReturnedCount()}<hr>\";\n\n    // The FileMakerRelation class implements the Iterator interface and it can repeat with 'foreach.'\n    // The $record also refers a FileMakerRelation object but it is for single record.\n    // This layout has fields as like 'id', 'name', 'mail' and so on, and the field name can be handle\n    // as a property name of the the record referring with $record.\n    if (!is_null($result)) {\n        // If the query is succeed, the following information can be detected.\n        echo \"Target Table: {$result->getTargetTable()}<hr>\";\n        echo \"Total Count: {$result->getTotalCount()}<hr>\";\n        echo \"Found Count: {$result->getFoundCount()}<hr>\";\n        echo \"Returned Count: {$result->getReturnedCount()}<hr>\";\n        foreach ($result as $record) {\n            echo \"id: {$record->id},\";\n            echo \"name: {$record->name},\";\n            echo \"mail: {$record->mail}<hr>\";\n            // If you named field name as not variable friendly, you can use field('field_name') method or\n            // set the name to any variable such as $fname = 'field_name'; echo $record->$fname;.\n\n            // In case of a related field but outside of portal, the field method is available as below:\n            // echo $record->field(\"summary\", \"contact_to\");\n\n            // A portal name property returns records of portal as FileMakerRelation object.\n            $contacts = $record->contact_to;\n\n            // If the query is succeed, the following information can be detected.\n            echo \"Target Table: {$contacts->getTargetTable()}<hr>\";\n            echo \"Total Count: {$contacts->getTotalCount()}<hr>\";\n            echo \"Found Count: {$contacts->getFoundCount()}<hr>\";\n            echo \"Returned Count: {$contacts->getReturnedCount()}<hr>\";\n\n            // You can repeat with foreach for the portal records.\n            foreach ($contacts as $item) {\n                // Technically portal field has to be refered as \"contact_to::id\" but it can be an indentifier in PHP.\n                // In this case you can call field method as like 'field(\"summary\", \"contact_to\").'\n                // If the field belongs to the table occurrence for the portal, you can refer the field as like '$item->id.'\n                // If the field belongs to another table occurrence, you have to call the 'field()' method.\n                echo \"[PORTAL(contact_to)] id: {$item->field(\"id\", \"contact_to\")},\";\n                echo \"summary: {$item->field(\"summary\", \"contact_to\")}<hr>\";\n                // If the object name of the portal is blank, it can be referred as the table occurrence name.\n                // If the object name is specified, you have to access with the object name and it means you have to\n                // call 'field()' method to get the value.\n            }\n            echo \"<hr>\";\n        }\n\n        // Move to pointer to the first record.\n        $result->rewind();\n\n        // The FileMakerRelation object from 'query()' method can be accessed as like the 'cursor' style repeating.\n        // The 'count()' method returns the number of records in response. The variable $result referes current\n        // record and you can get the field value with the propaty having the same field name.\n        // The portal can be done with same way. The 'next()' method steps forward the pointer of current record.\n        for ($i = 0; $i < $result->count(); $i++) {\n            echo \"id: {$result->id},\";\n            echo \"name: {$result->name},\";\n            echo \"mail: {$result->mail}<hr>\";\n            $contacts = $result->contact_to;\n\n            for ($j = 0; $j < $contacts->count(); $j++) {\n                echo \"[PORTAL(contact_to)] id: {$contacts->field(\"id\", \"contact_to\")},\";\n                echo \"summary: {$contacts->field(\"summary\", \"contact_to\")}<hr>\";\n                $contacts->next();\n            }\n            $result->next();\n        }\n    }\n    // The 'create()' method creates a record with values in parameter.\n    // The associated array of the parameter has to be a series of field name key and its value.\n    $recId = $fmdb->postalcode->create(array(\"f3\" => \"field 3 data\", \"f7\" => \"field 7 data\"));\n\n    // The 'getRecord()' method query the record with the recordId of the parameter.\n    // It returns the FileMakerRelation object and you can handle it with the return value from 'query()' method.\n    $result = $fmdb->postalcode->getRecord($recId);\n    if (!is_null($result)) {\n        foreach ($result as $record) {\n            echo \"f3: {$record->f3},\";\n            echo \"f7: {$record->f7},\";\n            echo \"f8: {$record->f8}<hr>\";\n            echo \"<hr>\";\n        }\n    }\n\n    // The 'update()' method modifies fields in a record. You have to set parameters as the recordId of target\n    // record and associated array to specify the modified data.\n    $fmdb->postalcode->update($recId, array(\"f3\" => \"field 3 modifed\", \"f8\" => \"field 8 update\"));\n    $result = $fmdb->postalcode->getRecord($recId);\n    if (!is_null($result)) {\n        foreach ($result as $record) {\n            echo \"f3: {$record->f3},\";\n            echo \"f7: {$record->f7},\";\n            echo \"f8: {$record->f8}<hr>\";\n            echo \"<hr>\";\n        }\n    }\n    // The 'delete()' method deletes the record specified by the parameter.\n    $fmdb->postalcode->delete($recId);\n\n    // Call script\n    $result = $fmdb->person_layout->query(null, null, -1, 1, null, [\"script\" => \"TestScript\", \"script.param\" => \"ok\"]);\n    if (!is_null($result)) {\n        echo \"Script Error: {$fmdb->person_layout->getScriptError()}<hr>\";\n        echo \"Script Result: {$fmdb->person_layout->getScriptResult()}<hr>\";\n    }\n    $result = $fmdb->person_layout->query(null, null, -1, 1, null, [\"script.prerequest\" => \"TestScript\", \"script.prerequest.param\" => \"ok\"]);\n    if (!is_null($result)) {\n        echo \"Script Error: {$fmdb->person_layout->getScriptErrorPrerequest()}<hr>\";\n        echo \"Script Result: {$fmdb->person_layout->getScriptResultPrerequest()}<hr>\";\n    }\n    $result = $fmdb->person_layout->query(null, null, -1, 1, null, [\"script\" => \"TestScript\", \"script.param\" => \"not\"]);\n    if (!is_null($result)) {\n        echo \"Script Error: {$fmdb->person_layout->getScriptError()}<hr>\";\n        echo \"Script Result: {$fmdb->person_layout->getScriptResult()}<hr>\";\n    }\n    $result = $fmdb->person_layout->query(null, null, -1, 1);\n    if (!is_null($result)) {\n        echo \"Script Error: {$fmdb->person_layout->getScriptError()}<hr>\";\n        echo \"Script Result: {$fmdb->person_layout->getScriptResult()}<hr>\";\n    }\n\n    // A new record is created in \"testtable\" table.\n    $recId = $fmdb->testtable->create();\n    // The \"testtable\" table has a container filed \"vc1\". One image file is going to be uploaded to it.\n    // The file path, record id and field name are required.\n    $fmdb->testtable->uploadFile(\"cat.jpg\", $recId, \"vc1\");\n    // What kind of data does the container field which inserted an image return?\n    // For example, the returned value was like this:\n    // https://localhost/Streaming_SSL/MainDB/6A4A253F7CE33465DCDFBFF0704B34C0993D54AD85702396920E85249BD0271A.jpg?RCType=EmbeddedRCFileProcessor\n    // This url can get the content of the container field, and it means you can download with file_put_content() function and so on.\n    $result = $fmdb->testtable->getRecord($recId);\n    echo \"Target Table(getRecord): {$result->getTargetTable()}<hr>\";\n    echo \"Total Count(getRecord): {$result->getTotalCount()}<hr>\";\n    echo \"Found Count(getRecord): {$result->getFoundCount()}<hr>\";\n    echo \"Returned Count(getRecord): {$result->getReturnedCount()}<hr>\";\n\n    if (!is_null($result)) {\n        foreach ($result as $record) {\n            echo \"vc1: {$record->vc1}<hr>\";\n            echo \"<p><img src='data:image/jpeg;base64,\" . $record->getContainerData('vc1') . \"'></p>\";\n        }\n    }\n\n    // If you call the 'startCommunication()' method, you can describe a series of database operation\n    // calls. This means the authentication is going to be done at the 'startCommunication()' method,\n    // and the token is going to be shared with following statements. The 'endCommunication()' calls\n    // logout REST API call and invalidate the shared token.\n    $recIds = array();\n    $fmdb->postalcode->startCommunication();\n    $recIds[] = $fmdb->postalcode->create(array(\"f3\" => \"field 3 data 1\", \"f7\" => \"field 7 data\"));\n    $recIds[] = $fmdb->postalcode->create(array(\"f3\" => \"field 3 data 2\", \"f7\" => \"field 7 data\"));\n    $recIds[] = $fmdb->postalcode->create(array(\"f3\" => \"field 3 data 3\", \"f7\" => \"field 7 data\"));\n    $recIds[] = $fmdb->postalcode->create(array(\"f3\" => \"field 3 data 4\", \"f7\" => \"field 7 data\"));\n    $recIds[] = $fmdb->postalcode->create(array(\"f3\" => \"field 3 data 5\", \"f7\" => \"field 7 data\"));\n    $recIds[] = $fmdb->postalcode->create(array(\"f3\" => \"field 3 data 6\", \"f7\" => \"field 7 data\"));\n    $recIds[] = $fmdb->postalcode->create(array(\"f3\" => \"field 3 data 7\", \"f7\" => \"field 7 data\"));\n    $fmdb->postalcode->endCommunication();\n    var_export($recIds);\n    echo \"<hr>\";\n\n    // The 'query()' method can have several parameters. The portal specification has to be an array\n    // with the object name of the portal not the table occurrence name.\n    $portal = array(\"contact_to\");\n    $result = $fmdb->person_layout->query(array(array(\"id\" => \"1\")), null, 1, -1, $portal);\n    if (!is_null($result)) {\n        foreach ($result as $record) {\n            $recordId = $record->getRecordId();\n            $partialResult = $fmdb->person_layout->getRecord($recordId, $portal);\n            var_export($partialResult);\n            echo \"<hr>\";\n        }\n    }\n    // The 'query()' method can have several parameters. The second parameter is for sorting.\n    $portal = array(\"contact_to\");\n    $result = $fmdb->person_layout->query(array(array(\"id\" => \"1...\")), array(array(\"id\", \"descend\")), 1, -1, $portal);\n    if (!is_null($result)) {\n        foreach ($result as $record) {\n            $recordId = $record->getRecordId();\n            $partialResult = $fmdb->person_layout->getRecord($recordId, $portal);\n            var_export($partialResult);\n            echo \"<hr>\";\n        }\n    }\n    // The 'query()' method can have several parameters. The forth parameter is limit record number to query, and third is offset.\n    $result = $fmdb->person_layout->query(null, null, 2, 2);\n    if (!is_null($result)) {\n        foreach ($result as $record) {\n            $recordId = $record->getRecordId();\n            $partialResult = $fmdb->person_layout->getRecord($recordId, $portal);\n            var_export($partialResult);\n            echo \"<hr>\";\n        }\n    }\n} catch (Exception $e) {\n    echo '<div><h3>\u4f8b\u5916\u767a\u751f</h3>', $e->getMessage(), \"<div>\";\n}\n"], "fixing_code": ["<?php\n/**\n * Created by PhpStorm.\n * User: msyk\n * Date: 2017/04/24\n * Time: 17:41\n */\n// First of all, the FMDataAPI.php file has to be included. All classes are defined in it.\ninclude_once \"../FMDataAPI.php\";\n\n// For your convenience, the main class name FMDataAPI is defined at the current namespace.\nuse INTERMediator\\FileMakerServer\\RESTAPI\\FMDataAPI as FMDataAPI;\n\n// FMDataAPI class handles an error as an exception by default.\ntry {\n    // Instantiate the class FMDataAPI with database name, user name, password and host.\n    // Although the port number and protocol can be set in parameters of constructor,\n    // these parameters can be omitted with default values.\n    $fmdb = new FMDataAPI(\"TestDB\", \"web\", \"password\", \"localhost\");\n\n    //==============================\n    //$fmdb = new FMDataAPI(\"TestDB\", \"web\", \"password\", \"localserver\");\n    // \"localserver\" is added on Ver.2 and it's a magic term for FMDataAPI. It happens direct connect to\n    // FileMaker Server in the same host. I've refered Atsushi Matsuo's script below and I got his way\n    // to be able to connect port number 3000.\n    // https://gist.github.com/matsuo/ef5cb7c98bb494d507731886883bcbc1\n    //==============================\n\n    // If you want to try this program just right now, it's convinient to download the FileMaker database file:\n    // https://github.com/INTER-Mediator/INTER-Mediator/blob/master/dist-docs/TestDB.fmp12?raw=true\n\n    // You can turn off to throw an exception in case of error. You have to handle errors with checking result error.\n    $fmdb->setThrowException(false);\n\n    // If you call with true, the debug mode is activated. Debug mode echos the contents of communication\n    // such as request and response.\n    $fmdb->setDebug(true);\n\n    // If you call with true, the certificate from the server is going to verify.\n    // In case of self-signed one (usually default situation), you don't have to call this method.\n    //$fmdb->setCertValidating(true);\n\n    // Metadata API is the new feature of FMS18.\n    $pInfo = var_export($fmdb->getProductInfo(), true);\n    echo htmlspecialchars(\"Product Info: {$pInfo}\", ENT_QUOTES, \"UTF-8\") . \"<hr>\";\n    $pInfo = var_export($fmdb->getDatabaseNames(), true);\n    echo htmlspecialchars(\"Database Names: {$pInfo}\", ENT_QUOTES, \"UTF-8\") . \"<hr>\";\n    $pInfo = var_export($fmdb->getLayoutNames(), true);\n    echo htmlspecialchars(\"Layout Names: {$pInfo}\", ENT_QUOTES, \"UTF-8\") . \"<hr>\";\n    $pInfo = var_export($fmdb->getScriptNames(), true);\n    echo htmlspecialchars(\"Script Names: {$pInfo}\", ENT_QUOTES, \"UTF-8\") . \"<hr>\";\n    $result = $fmdb->person_layout->getMetadata();\n    $pInfo = var_export($result, true);\n    echo htmlspecialchars(\"Layout Metadata: {$pInfo}\", ENT_QUOTES, \"UTF-8\") . \"<hr>\";\n    $result = $fmdb->person_layout->getMetadataOld();\n    $pInfo = var_export($result, true);\n    echo htmlspecialchars(\"Layout Metadata (Old): {$pInfo}\", ENT_QUOTES, \"UTF-8\") . \"<hr>\";\n\n    // The FMDataAPI has the property as the same name of layout. This sample database has the 'person_layout' layout,\n    // so '$fmdb->person_layout' refers FMLayout object fo the proxy of the layout. FMLayout class has the 'query' method\n    // and returns FileMakerRelation class's object. The condition spefied in parameter is same as FileMaker's Find Record API.\n    $result = $fmdb->person_layout->query(/*array(array(\"id\" => \">1\"))*/);\n\n    // The 'httpStatus()' method returns the HTTP status code in the latest response.\n    echo htmlspecialchars(\"HTTP Status: {$fmdb->httpStatus()}\", ENT_QUOTES, \"UTF-8\") . \"<hr>\";\n\n    // The following two methods return the error code and message of the latest API call which is submitted in query() method.\n    // You can check API calling succeed or fail if error code is or isn't 0 every after API calling methods.\n    echo htmlspecialchars(\"Error Code: {$fmdb->errorCode()}\", ENT_QUOTES, \"UTF-8\") . \"<hr>\";\n    echo htmlspecialchars(\"Error Message: {$fmdb->errorMessage()}\", ENT_QUOTES, \"UTF-8\") . \"<hr>\";\n\n    // If the query is succeed, the following information can be detected.\n    echo htmlspecialchars(\"Target Table: {$fmdb->getTargetTable()}\", ENT_QUOTES, \"UTF-8\") . \"<hr>\";\n    echo htmlspecialchars(\"Total Count: {$fmdb->getTotalCount()}\", ENT_QUOTES, \"UTF-8\") . \"<hr>\";\n    echo htmlspecialchars(\"Found Count: {$fmdb->getFoundCount()}\", ENT_QUOTES, \"UTF-8\") . \"<hr>\";\n    echo htmlspecialchars(\"Returned Count: {$fmdb->getReturnedCount()}\", ENT_QUOTES, \"UTF-8\") . \"<hr>\";\n\n    // The FileMakerRelation class implements the Iterator interface and it can repeat with 'foreach.'\n    // The $record also refers a FileMakerRelation object but it is for single record.\n    // This layout has fields as like 'id', 'name', 'mail' and so on, and the field name can be handle\n    // as a property name of the the record referring with $record.\n    if (!is_null($result)) {\n        // If the query is succeed, the following information can be detected.\n        echo htmlspecialchars(\"Target Table: {$result->getTargetTable()}\", ENT_QUOTES, \"UTF-8\") . \"<hr>\";\n        echo htmlspecialchars(\"Total Count: {$result->getTotalCount()}\", ENT_QUOTES, \"UTF-8\") . \"<hr>\";\n        echo htmlspecialchars(\"Found Count: {$result->getFoundCount()}\", ENT_QUOTES, \"UTF-8\") . \"<hr>\";\n        echo htmlspecialchars(\"Returned Count: {$result->getReturnedCount()}\", ENT_QUOTES, \"UTF-8\") . \"<hr>\";\n        foreach ($result as $record) {\n            echo htmlspecialchars(\"id: {$record->id},\", ENT_QUOTES, \"UTF-8\");\n            echo htmlspecialchars(\"name: {$record->name},\", ENT_QUOTES, \"UTF-8\");\n            echo htmlspecialchars(\"mail: {$record->mail}\", ENT_QUOTES, \"UTF-8\") . \"<hr>\";\n            // If you named field name as not variable friendly, you can use field('field_name') method or\n            // set the name to any variable such as $fname = 'field_name'; echo $record->$fname;.\n\n            // In case of a related field but outside of portal, the field method is available as below:\n            // echo $record->field(\"summary\", \"contact_to\");\n\n            // A portal name property returns records of portal as FileMakerRelation object.\n            $contacts = $record->Contact;\n\n            // If the query is succeed, the following information can be detected.\n            echo htmlspecialchars(\"Target Table: {$contacts->getTargetTable()}\", ENT_QUOTES, \"UTF-8\") . \"<hr>\";\n            echo htmlspecialchars(\"Total Count: {$contacts->getTotalCount()}\", ENT_QUOTES, \"UTF-8\") . \"<hr>\";\n            echo htmlspecialchars(\"Found Count: {$contacts->getFoundCount()}\", ENT_QUOTES, \"UTF-8\") . \"<hr>\";\n            echo htmlspecialchars(\"Returned Count: {$contacts->getReturnedCount()}\", ENT_QUOTES, \"UTF-8\") . \"<hr>\";\n\n            // You can repeat with foreach for the portal records.\n            foreach ($contacts as $item) {\n                // Technically portal field has to be refered as \"contact_to::id\" but it can be an indentifier in PHP.\n                // In this case you can call field method as like 'field(\"summary\", \"contact_to\").'\n                // If the field belongs to the table occurrence for the portal, you can refer the field as like '$item->id.'\n                // If the field belongs to another table occurrence, you have to call the 'field()' method.\n                echo htmlspecialchars(\"[PORTAL(contact_to)] id: {$item->field(\"id\", \"contact_to\")},\", ENT_QUOTES, \"UTF-8\");\n                echo htmlspecialchars(\"summary: {$item->field(\"summary\", \"contact_to\")}\", ENT_QUOTES, \"UTF-8\") . \"<hr>\";\n                // If the object name of the portal is blank, it can be referred as the table occurrence name.\n                // If the object name is specified, you have to access with the object name and it means you have to\n                // call 'field()' method to get the value.\n            }\n            echo \"<hr>\";\n        }\n\n        // Move to pointer to the first record.\n        $result->rewind();\n\n        // The FileMakerRelation object from 'query()' method can be accessed as like the 'cursor' style repeating.\n        // The 'count()' method returns the number of records in response. The variable $result referes current\n        // record and you can get the field value with the propaty having the same field name.\n        // The portal can be done with same way. The 'next()' method steps forward the pointer of current record.\n        for ($i = 0; $i < $result->count(); $i++) {\n            echo htmlspecialchars(\"id: {$result->id},\", ENT_QUOTES, \"UTF-8\");\n            echo htmlspecialchars(\"name: {$result->name},\", ENT_QUOTES, \"UTF-8\");\n            echo htmlspecialchars(\"mail: {$result->mail}\", ENT_QUOTES, \"UTF-8\") . \"<hr>\";\n            $contacts = $result->Contact;\n\n            for ($j = 0; $j < $contacts->count(); $j++) {\n                echo htmlspecialchars(\"[PORTAL(contact_to)] id: {$contacts->field(\"id\", \"contact_to\")},\", ENT_QUOTES, \"UTF-8\");\n                echo htmlspecialchars(\"summary: {$contacts->field(\"summary\", \"contact_to\")}\", ENT_QUOTES, \"UTF-8\") . \"<hr>\";\n                $contacts->next();\n            }\n            $result->next();\n        }\n    }\n    // The 'create()' method creates a record with values in parameter.\n    // The associated array of the parameter has to be a series of field name key and its value.\n    $recId = $fmdb->postalcode->create(array(\"f3\" => \"field 3 data\", \"f7\" => \"field 7 data\"));\n\n    // The 'getRecord()' method query the record with the recordId of the parameter.\n    // It returns the FileMakerRelation object and you can handle it with the return value from 'query()' method.\n    $result = $fmdb->postalcode->getRecord($recId);\n    if (!is_null($result)) {\n        foreach ($result as $record) {\n            echo htmlspecialchars(\"f3: {$record->f3},\", ENT_QUOTES, \"UTF-8\");\n            echo htmlspecialchars(\"f7: {$record->f7},\", ENT_QUOTES, \"UTF-8\");\n            echo htmlspecialchars(\"f8: {$record->f8}\", ENT_QUOTES, \"UTF-8\") . \"<hr>\";\n            echo \"<hr>\";\n        }\n    }\n\n    // The 'update()' method modifies fields in a record. You have to set parameters as the recordId of target\n    // record and associated array to specify the modified data.\n    $fmdb->postalcode->update($recId, array(\"f3\" => \"field 3 modifed\", \"f8\" => \"field 8 update\"));\n    $result = $fmdb->postalcode->getRecord($recId);\n    if (!is_null($result)) {\n        foreach ($result as $record) {\n            echo htmlspecialchars(\"f3: {$record->f3},\", ENT_QUOTES, \"UTF-8\");\n            echo htmlspecialchars(\"f7: {$record->f7},\", ENT_QUOTES, \"UTF-8\");\n            echo htmlspecialchars(\"f8: {$record->f8}\", ENT_QUOTES, \"UTF-8\") . \"<hr>\";\n            echo \"<hr>\";\n        }\n    }\n    // The 'delete()' method deletes the record specified by the parameter.\n    $fmdb->postalcode->delete($recId);\n\n    // Call script\n    $result = $fmdb->person_layout->query(null, null, -1, 1, null, [\"script\" => \"TestScript\", \"script.param\" => \"ok\"]);\n    if (!is_null($result)) {\n        echo htmlspecialchars(\"Script Error: {$fmdb->person_layout->getScriptError()}\", ENT_QUOTES, \"UTF-8\") . \"<hr>\";\n        echo htmlspecialchars(\"Script Result: {$fmdb->person_layout->getScriptResult()}\", ENT_QUOTES, \"UTF-8\") . \"<hr>\";\n    }\n    $result = $fmdb->person_layout->query(null, null, -1, 1, null, [\"script.prerequest\" => \"TestScript\", \"script.prerequest.param\" => \"ok\"]);\n    if (!is_null($result)) {\n        echo htmlspecialchars(\"Script Error: {$fmdb->person_layout->getScriptErrorPrerequest()}\", ENT_QUOTES, \"UTF-8\") . \"<hr>\";\n        echo htmlspecialchars(\"Script Result: {$fmdb->person_layout->getScriptResultPrerequest()}\", ENT_QUOTES, \"UTF-8\") . \"<hr>\";\n    }\n    $result = $fmdb->person_layout->query(null, null, -1, 1, null, [\"script\" => \"TestScript\", \"script.param\" => \"not\"]);\n    if (!is_null($result)) {\n        echo htmlspecialchars(\"Script Error: {$fmdb->person_layout->getScriptError()}\", ENT_QUOTES, \"UTF-8\") . \"<hr>\";\n        echo htmlspecialchars(\"Script Result: {$fmdb->person_layout->getScriptResult()}\", ENT_QUOTES, \"UTF-8\") . \"<hr>\";\n    }\n    $result = $fmdb->person_layout->query(null, null, -1, 1);\n    if (!is_null($result)) {\n        echo htmlspecialchars(\"Script Error: {$fmdb->person_layout->getScriptError()}\", ENT_QUOTES, \"UTF-8\") . \"<hr>\";\n        echo htmlspecialchars(\"Script Result: {$fmdb->person_layout->getScriptResult()}\", ENT_QUOTES, \"UTF-8\") . \"<hr>\";\n    }\n\n    // A new record is created in \"testtable\" table.\n    $recId = $fmdb->testtable->create();\n    // The \"testtable\" table has a container filed \"vc1\". One image file is going to be uploaded to it.\n    // The file path, record id and field name are required.\n    $fmdb->testtable->uploadFile(\"cat.jpg\", $recId, \"vc1\");\n    // What kind of data does the container field which inserted an image return?\n    // For example, the returned value was like this:\n    // https://localhost/Streaming_SSL/MainDB/6A4A253F7CE33465DCDFBFF0704B34C0993D54AD85702396920E85249BD0271A.jpg?RCType=EmbeddedRCFileProcessor\n    // This url can get the content of the container field, and it means you can download with file_put_content() function and so on.\n    $result = $fmdb->testtable->getRecord($recId);\n    echo htmlspecialchars(\"Target Table(getRecord): {$result->getTargetTable()}\", ENT_QUOTES, \"UTF-8\") . \"<hr>\";\n    echo htmlspecialchars(\"Total Count(getRecord): {$result->getTotalCount()}\", ENT_QUOTES, \"UTF-8\") . \"<hr>\";\n    echo htmlspecialchars(\"Found Count(getRecord): {$result->getFoundCount()}\", ENT_QUOTES, \"UTF-8\") . \"<hr>\";\n    echo htmlspecialchars(\"Returned Count(getRecord): {$result->getReturnedCount()}\", ENT_QUOTES, \"UTF-8\") . \"<hr>\";\n\n    if (!is_null($result)) {\n        foreach ($result as $record) {\n            echo htmlspecialchars(\"vc1: {$record->vc1}\", ENT_QUOTES, \"UTF-8\") . \"<hr>\";\n            echo \"<p><img src='data:image/jpeg;base64,\" . $record->getContainerData('vc1') . \"'></p>\";\n        }\n    }\n\n    // If you call the 'startCommunication()' method, you can describe a series of database operation\n    // calls. This means the authentication is going to be done at the 'startCommunication()' method,\n    // and the token is going to be shared with following statements. The 'endCommunication()' calls\n    // logout REST API call and invalidate the shared token.\n    $recIds = array();\n    $fmdb->postalcode->startCommunication();\n    $recIds[] = $fmdb->postalcode->create(array(\"f3\" => \"field 3 data 1\", \"f7\" => \"field 7 data\"));\n    $recIds[] = $fmdb->postalcode->create(array(\"f3\" => \"field 3 data 2\", \"f7\" => \"field 7 data\"));\n    $recIds[] = $fmdb->postalcode->create(array(\"f3\" => \"field 3 data 3\", \"f7\" => \"field 7 data\"));\n    $recIds[] = $fmdb->postalcode->create(array(\"f3\" => \"field 3 data 4\", \"f7\" => \"field 7 data\"));\n    $recIds[] = $fmdb->postalcode->create(array(\"f3\" => \"field 3 data 5\", \"f7\" => \"field 7 data\"));\n    $recIds[] = $fmdb->postalcode->create(array(\"f3\" => \"field 3 data 6\", \"f7\" => \"field 7 data\"));\n    $recIds[] = $fmdb->postalcode->create(array(\"f3\" => \"field 3 data 7\", \"f7\" => \"field 7 data\"));\n    $fmdb->postalcode->endCommunication();\n    var_export($recIds);\n    echo \"<hr>\";\n\n    // The 'query()' method can have several parameters. The portal specification has to be an array\n    // with the object name of the portal not the table occurrence name.\n    $portal = array(\"contact_to\");\n    $result = $fmdb->person_layout->query(array(array(\"id\" => \"1\")), null, 1, -1, $portal);\n    if (!is_null($result)) {\n        foreach ($result as $record) {\n            $recordId = $record->getRecordId();\n            $partialResult = $fmdb->person_layout->getRecord($recordId, $portal);\n            var_export($partialResult);\n            echo \"<hr>\";\n        }\n    }\n    // The 'query()' method can have several parameters. The second parameter is for sorting.\n    $portal = array(\"contact_to\");\n    $result = $fmdb->person_layout->query(array(array(\"id\" => \"1...\")), array(array(\"id\", \"descend\")), 1, -1, $portal);\n    if (!is_null($result)) {\n        foreach ($result as $record) {\n            $recordId = $record->getRecordId();\n            $partialResult = $fmdb->person_layout->getRecord($recordId, $portal);\n            var_export($partialResult);\n            echo \"<hr>\";\n        }\n    }\n    // The 'query()' method can have several parameters. The forth parameter is limit record number to query, and third is offset.\n    $result = $fmdb->person_layout->query(null, null, 2, 2);\n    if (!is_null($result)) {\n        foreach ($result as $record) {\n            $recordId = $record->getRecordId();\n            $partialResult = $fmdb->person_layout->getRecord($recordId, $portal);\n            var_export($partialResult);\n            echo \"<hr>\";\n        }\n    }\n} catch (Exception $e) {\n    echo '<div><h3>\u4f8b\u5916\u767a\u751f</h3>', htmlspecialchars($e->getMessage(), ENT_QUOTES, \"UTF-8\"), \"<div>\";\n}\n"], "filenames": ["samples/FMDataAPI_Sample.php"], "buggy_code_start_loc": [45], "buggy_code_end_loc": [270], "fixing_code_start_loc": [45], "fixing_code_end_loc": [270], "type": "CWE-79", "message": "A vulnerability classified as problematic has been found in msyk FMDataAPI up to 22. Affected is an unknown function of the file FMDataAPI_Sample.php. The manipulation leads to cross site scripting. It is possible to launch the attack remotely. Upgrading to version 23 is able to address this issue. The patch is identified as 3bd1709a8f7b1720529bf5dfc9855ad609f436cf. It is recommended to upgrade the affected component. VDB-244494 is the identifier assigned to this vulnerability.", "other": {"cve": {"id": "CVE-2021-4431", "sourceIdentifier": "cna@vuldb.com", "published": "2023-11-07T11:15:10.070", "lastModified": "2024-02-29T01:33:11.550", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "A vulnerability classified as problematic has been found in msyk FMDataAPI up to 22. Affected is an unknown function of the file FMDataAPI_Sample.php. The manipulation leads to cross site scripting. It is possible to launch the attack remotely. Upgrading to version 23 is able to address this issue. The patch is identified as 3bd1709a8f7b1720529bf5dfc9855ad609f436cf. It is recommended to upgrade the affected component. VDB-244494 is the identifier assigned to this vulnerability."}, {"lang": "es", "value": "Una vulnerabilidad ha sido encontrada en msyk FMDataAPI hasta 22 y clasificada como problem\u00e1tica. Una funci\u00f3n desconocida del archivo FMDataAPI_Sample.php es afectada por esta vulnerabilidad. La manipulaci\u00f3n conduce a Cross-Site Scripting (XSS). Es posible lanzar el ataque de forma remota. La actualizaci\u00f3n a la versi\u00f3n 23 puede solucionar este problema. El parche se identifica como 3bd1709a8f7b1720529bf5dfc9855ad609f436cf. Se recomienda actualizar el componente afectado. VDB-244494 es el identificador asignado a esta vulnerabilidad."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.7}, {"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:R/S:U/C:N/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 3.5, "baseSeverity": "LOW"}, "exploitabilityScore": 2.1, "impactScore": 1.4}], "cvssMetricV2": [{"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 4.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "cna@vuldb.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:msyk:fmdataapi:*:*:*:*:*:*:*:*", "versionEndIncluding": "22", "matchCriteriaId": "20B1C398-1089-4235-8982-FFBEBC3A3CDA"}]}]}], "references": [{"url": "https://github.com/msyk/FMDataAPI/commit/3bd1709a8f7b1720529bf5dfc9855ad609f436cf", "source": "cna@vuldb.com", "tags": ["Patch"]}, {"url": "https://github.com/msyk/FMDataAPI/pull/54", "source": "cna@vuldb.com", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://github.com/msyk/FMDataAPI/releases/tag/23", "source": "cna@vuldb.com", "tags": ["Release Notes"]}, {"url": "https://vuldb.com/?ctiid.244494", "source": "cna@vuldb.com", "tags": ["Permissions Required", "Third Party Advisory", "VDB Entry"]}, {"url": "https://vuldb.com/?id.244494", "source": "cna@vuldb.com", "tags": ["Permissions Required", "Third Party Advisory", "VDB Entry"]}]}, "github_commit_url": "https://github.com/msyk/FMDataAPI/commit/3bd1709a8f7b1720529bf5dfc9855ad609f436cf"}}