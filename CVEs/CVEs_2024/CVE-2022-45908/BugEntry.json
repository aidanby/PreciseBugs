{"buggy_code": ["# Copyright (c) 2022 PaddlePaddle Authors. All Rights Reserved\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\nimport math\nfrom typing import List\nfrom typing import Tuple\nfrom typing import Union\n\nimport paddle\nfrom paddle import Tensor\n\n\ndef _cat(x: List[Tensor], data_type: str) -> Tensor:\n    l = [paddle.to_tensor(_, data_type) for _ in x]\n    return paddle.concat(l)\n\n\ndef _acosh(x: Union[Tensor, float]) -> Tensor:\n    if isinstance(x, float):\n        return math.log(x + math.sqrt(x**2 - 1))\n    return paddle.log(x + paddle.sqrt(paddle.square(x) - 1))\n\n\ndef _extend(M: int, sym: bool) -> bool:\n    \"\"\"Extend window by 1 sample if needed for DFT-even symmetry.\"\"\"\n    if not sym:\n        return M + 1, True\n    else:\n        return M, False\n\n\ndef _len_guards(M: int) -> bool:\n    \"\"\"Handle small or incorrect window lengths.\"\"\"\n    if int(M) != M or M < 0:\n        raise ValueError('Window length M must be a non-negative integer')\n\n    return M <= 1\n\n\ndef _truncate(w: Tensor, needed: bool) -> Tensor:\n    \"\"\"Truncate window by 1 sample if needed for DFT-even symmetry.\"\"\"\n    if needed:\n        return w[:-1]\n    else:\n        return w\n\n\ndef _general_gaussian(\n    M: int, p, sig, sym: bool = True, dtype: str = 'float64'\n) -> Tensor:\n    \"\"\"Compute a window with a generalized Gaussian shape.\n    This function is consistent with scipy.signal.windows.general_gaussian().\n    \"\"\"\n    if _len_guards(M):\n        return paddle.ones((M,), dtype=dtype)\n    M, needs_trunc = _extend(M, sym)\n\n    n = paddle.arange(0, M, dtype=dtype) - (M - 1.0) / 2.0\n    w = paddle.exp(-0.5 * paddle.abs(n / sig) ** (2 * p))\n\n    return _truncate(w, needs_trunc)\n\n\ndef _general_cosine(\n    M: int, a: float, sym: bool = True, dtype: str = 'float64'\n) -> Tensor:\n    \"\"\"Compute a generic weighted sum of cosine terms window.\n    This function is consistent with scipy.signal.windows.general_cosine().\n    \"\"\"\n    if _len_guards(M):\n        return paddle.ones((M,), dtype=dtype)\n    M, needs_trunc = _extend(M, sym)\n    fac = paddle.linspace(-math.pi, math.pi, M, dtype=dtype)\n    w = paddle.zeros((M,), dtype=dtype)\n    for k in range(len(a)):\n        w += a[k] * paddle.cos(k * fac)\n    return _truncate(w, needs_trunc)\n\n\ndef _general_hamming(\n    M: int, alpha: float, sym: bool = True, dtype: str = 'float64'\n) -> Tensor:\n    \"\"\"Compute a generalized Hamming window.\n    This function is consistent with scipy.signal.windows.general_hamming()\n    \"\"\"\n    return _general_cosine(M, [alpha, 1.0 - alpha], sym, dtype=dtype)\n\n\ndef _taylor(\n    M: int, nbar=4, sll=30, norm=True, sym: bool = True, dtype: str = 'float64'\n) -> Tensor:\n    \"\"\"Compute a Taylor window.\n    The Taylor window taper function approximates the Dolph-Chebyshev window's\n    constant sidelobe level for a parameterized number of near-in sidelobes.\n    \"\"\"\n    if _len_guards(M):\n        return paddle.ones((M,), dtype=dtype)\n    M, needs_trunc = _extend(M, sym)\n    # Original text uses a negative sidelobe level parameter and then negates\n    # it in the calculation of B. To keep consistent with other methods we\n    # assume the sidelobe level parameter to be positive.\n    B = 10 ** (sll / 20)\n    A = _acosh(B) / math.pi\n    s2 = nbar**2 / (A**2 + (nbar - 0.5) ** 2)\n    ma = paddle.arange(1, nbar, dtype=dtype)\n\n    Fm = paddle.empty((nbar - 1,), dtype=dtype)\n    signs = paddle.empty_like(ma)\n    signs[::2] = 1\n    signs[1::2] = -1\n    m2 = ma * ma\n    for mi in range(len(ma)):\n        numer = signs[mi] * paddle.prod(\n            1 - m2[mi] / s2 / (A**2 + (ma - 0.5) ** 2)\n        )\n        if mi == 0:\n            denom = 2 * paddle.prod(1 - m2[mi] / m2[mi + 1 :])\n        elif mi == len(ma) - 1:\n            denom = 2 * paddle.prod(1 - m2[mi] / m2[:mi])\n        else:\n            denom = (\n                2\n                * paddle.prod(1 - m2[mi] / m2[:mi])\n                * paddle.prod(1 - m2[mi] / m2[mi + 1 :])\n            )\n\n        Fm[mi] = numer / denom\n\n    def W(n):\n        return 1 + 2 * paddle.matmul(\n            Fm.unsqueeze(0),\n            paddle.cos(2 * math.pi * ma.unsqueeze(1) * (n - M / 2.0 + 0.5) / M),\n        )\n\n    w = W(paddle.arange(0, M, dtype=dtype))\n\n    # normalize (Note that this is not described in the original text [1])\n    if norm:\n        scale = 1.0 / W((M - 1) / 2)\n        w *= scale\n    w = w.squeeze()\n    return _truncate(w, needs_trunc)\n\n\ndef _hamming(M: int, sym: bool = True, dtype: str = 'float64') -> Tensor:\n    \"\"\"Compute a Hamming window.\n    The Hamming window is a taper formed by using a raised cosine with\n    non-zero endpoints, optimized to minimize the nearest side lobe.\n    \"\"\"\n    return _general_hamming(M, 0.54, sym, dtype=dtype)\n\n\ndef _hann(M: int, sym: bool = True, dtype: str = 'float64') -> Tensor:\n    \"\"\"Compute a Hann window.\n    The Hann window is a taper formed by using a raised cosine or sine-squared\n    with ends that touch zero.\n    \"\"\"\n    return _general_hamming(M, 0.5, sym, dtype=dtype)\n\n\ndef _tukey(\n    M: int, alpha=0.5, sym: bool = True, dtype: str = 'float64'\n) -> Tensor:\n    \"\"\"Compute a Tukey window.\n    The Tukey window is also known as a tapered cosine window.\n    \"\"\"\n    if _len_guards(M):\n        return paddle.ones((M,), dtype=dtype)\n\n    if alpha <= 0:\n        return paddle.ones((M,), dtype=dtype)\n    elif alpha >= 1.0:\n        return hann(M, sym=sym)\n\n    M, needs_trunc = _extend(M, sym)\n\n    n = paddle.arange(0, M, dtype=dtype)\n    width = int(alpha * (M - 1) / 2.0)\n    n1 = n[0 : width + 1]\n    n2 = n[width + 1 : M - width - 1]\n    n3 = n[M - width - 1 :]\n\n    w1 = 0.5 * (1 + paddle.cos(math.pi * (-1 + 2.0 * n1 / alpha / (M - 1))))\n    w2 = paddle.ones(n2.shape, dtype=dtype)\n    w3 = 0.5 * (\n        1\n        + paddle.cos(math.pi * (-2.0 / alpha + 1 + 2.0 * n3 / alpha / (M - 1)))\n    )\n    w = paddle.concat([w1, w2, w3])\n\n    return _truncate(w, needs_trunc)\n\n\ndef _kaiser(\n    M: int, beta: float, sym: bool = True, dtype: str = 'float64'\n) -> Tensor:\n    \"\"\"Compute a Kaiser window.\n    The Kaiser window is a taper formed by using a Bessel function.\n    \"\"\"\n    raise NotImplementedError()\n\n\ndef _gaussian(\n    M: int, std: float, sym: bool = True, dtype: str = 'float64'\n) -> Tensor:\n    \"\"\"Compute a Gaussian window.\n    The Gaussian widows has a Gaussian shape defined by the standard deviation(std).\n    \"\"\"\n    if _len_guards(M):\n        return paddle.ones((M,), dtype=dtype)\n    M, needs_trunc = _extend(M, sym)\n\n    n = paddle.arange(0, M, dtype=dtype) - (M - 1.0) / 2.0\n    sig2 = 2 * std * std\n    w = paddle.exp(-(n**2) / sig2)\n\n    return _truncate(w, needs_trunc)\n\n\ndef _exponential(\n    M: int, center=None, tau=1.0, sym: bool = True, dtype: str = 'float64'\n) -> Tensor:\n    \"\"\"Compute an exponential (or Poisson) window.\"\"\"\n    if sym and center is not None:\n        raise ValueError(\"If sym==True, center must be None.\")\n    if _len_guards(M):\n        return paddle.ones((M,), dtype=dtype)\n    M, needs_trunc = _extend(M, sym)\n\n    if center is None:\n        center = (M - 1) / 2\n\n    n = paddle.arange(0, M, dtype=dtype)\n    w = paddle.exp(-paddle.abs(n - center) / tau)\n\n    return _truncate(w, needs_trunc)\n\n\ndef _triang(M: int, sym: bool = True, dtype: str = 'float64') -> Tensor:\n    \"\"\"Compute a triangular window.\"\"\"\n    if _len_guards(M):\n        return paddle.ones((M,), dtype=dtype)\n    M, needs_trunc = _extend(M, sym)\n\n    n = paddle.arange(1, (M + 1) // 2 + 1, dtype=dtype)\n    if M % 2 == 0:\n        w = (2 * n - 1.0) / M\n        w = paddle.concat([w, w[::-1]])\n    else:\n        w = 2 * n / (M + 1.0)\n        w = paddle.concat([w, w[-2::-1]])\n\n    return _truncate(w, needs_trunc)\n\n\ndef _bohman(M: int, sym: bool = True, dtype: str = 'float64') -> Tensor:\n    \"\"\"Compute a Bohman window.\n    The Bohman window is the autocorrelation of a cosine window.\n    \"\"\"\n    if _len_guards(M):\n        return paddle.ones((M,), dtype=dtype)\n    M, needs_trunc = _extend(M, sym)\n\n    fac = paddle.abs(paddle.linspace(-1, 1, M, dtype=dtype)[1:-1])\n    w = (1 - fac) * paddle.cos(math.pi * fac) + 1.0 / math.pi * paddle.sin(\n        math.pi * fac\n    )\n    w = _cat([0, w, 0], dtype)\n\n    return _truncate(w, needs_trunc)\n\n\ndef _blackman(M: int, sym: bool = True, dtype: str = 'float64') -> Tensor:\n    \"\"\"Compute a Blackman window.\n    The Blackman window is a taper formed by using the first three terms of\n    a summation of cosines. It was designed to have close to the minimal\n    leakage possible.  It is close to optimal, only slightly worse than a\n    Kaiser window.\n    \"\"\"\n    return _general_cosine(M, [0.42, 0.50, 0.08], sym, dtype=dtype)\n\n\ndef _cosine(M: int, sym: bool = True, dtype: str = 'float64') -> Tensor:\n    \"\"\"Compute a window with a simple cosine shape.\"\"\"\n    if _len_guards(M):\n        return paddle.ones((M,), dtype=dtype)\n    M, needs_trunc = _extend(M, sym)\n    w = paddle.sin(math.pi / M * (paddle.arange(0, M, dtype=dtype) + 0.5))\n\n    return _truncate(w, needs_trunc)\n\n\ndef get_window(\n    window: Union[str, Tuple[str, float]],\n    win_length: int,\n    fftbins: bool = True,\n    dtype: str = 'float64',\n) -> Tensor:\n    \"\"\"Return a window of a given length and type.\n\n    Args:\n        window (Union[str, Tuple[str, float]]): The window function applied to the signal before the Fourier transform. Supported window functions: 'hamming', 'hann', 'kaiser', 'gaussian', 'exponential', 'triang', 'bohman', 'blackman', 'cosine', 'tukey', 'taylor'.\n        win_length (int): Number of samples.\n        fftbins (bool, optional): If True, create a \"periodic\" window. Otherwise, create a \"symmetric\" window, for use in filter design. Defaults to True.\n        dtype (str, optional): The data type of the return window. Defaults to 'float64'.\n\n    Returns:\n        Tensor: The window represented as a tensor.\n\n    Examples:\n        .. code-block:: python\n\n            import paddle\n\n            n_fft = 512\n            cosine_window = paddle.audio.functional.get_window('cosine', n_fft)\n\n            std = 7\n            gussian_window = paddle.audio.functional.get_window(('gaussian',std), n_fft)\n    \"\"\"\n    sym = not fftbins\n\n    args = ()\n    if isinstance(window, tuple):\n        winstr = window[0]\n        if len(window) > 1:\n            args = window[1:]\n    elif isinstance(window, str):\n        if window in ['gaussian', 'exponential']:\n            raise ValueError(\n                \"The '\" + window + \"' window needs one or \"\n                \"more parameters -- pass a tuple.\"\n            )\n        else:\n            winstr = window\n    else:\n        raise ValueError(\n            \"%s as window type is not supported.\" % str(type(window))\n        )\n\n    try:\n        winfunc = eval('_' + winstr)\n    except NameError as e:\n        raise ValueError(\"Unknown window type.\") from e\n\n    params = (win_length,) + args\n    kwargs = {'sym': sym}\n    return winfunc(*params, dtype=dtype, **kwargs)\n"], "fixing_code": ["# Copyright (c) 2022 PaddlePaddle Authors. All Rights Reserved\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\nimport math\nfrom typing import List\nfrom typing import Tuple\nfrom typing import Union\n\nimport paddle\nfrom paddle import Tensor\n\n\nclass WindowFunctionRegister(object):\n    def __init__(self):\n        self._functions_dict = dict()\n\n    def register(self, func=None):\n        def add_subfunction(func):\n            name = func.__name__\n            self._functions_dict[name] = func\n            return func\n\n        return add_subfunction\n\n    def get(self, name):\n        return self._functions_dict[name]\n\n\nwindow_function_register = WindowFunctionRegister()\n\n\n@window_function_register.register()\ndef _cat(x: List[Tensor], data_type: str) -> Tensor:\n    l = [paddle.to_tensor(_, data_type) for _ in x]\n    return paddle.concat(l)\n\n\n@window_function_register.register()\ndef _acosh(x: Union[Tensor, float]) -> Tensor:\n    if isinstance(x, float):\n        return math.log(x + math.sqrt(x**2 - 1))\n    return paddle.log(x + paddle.sqrt(paddle.square(x) - 1))\n\n\n@window_function_register.register()\ndef _extend(M: int, sym: bool) -> bool:\n    \"\"\"Extend window by 1 sample if needed for DFT-even symmetry.\"\"\"\n    if not sym:\n        return M + 1, True\n    else:\n        return M, False\n\n\n@window_function_register.register()\ndef _len_guards(M: int) -> bool:\n    \"\"\"Handle small or incorrect window lengths.\"\"\"\n    if int(M) != M or M < 0:\n        raise ValueError('Window length M must be a non-negative integer')\n\n    return M <= 1\n\n\n@window_function_register.register()\ndef _truncate(w: Tensor, needed: bool) -> Tensor:\n    \"\"\"Truncate window by 1 sample if needed for DFT-even symmetry.\"\"\"\n    if needed:\n        return w[:-1]\n    else:\n        return w\n\n\n@window_function_register.register()\ndef _general_gaussian(\n    M: int, p, sig, sym: bool = True, dtype: str = 'float64'\n) -> Tensor:\n    \"\"\"Compute a window with a generalized Gaussian shape.\n    This function is consistent with scipy.signal.windows.general_gaussian().\n    \"\"\"\n    if _len_guards(M):\n        return paddle.ones((M,), dtype=dtype)\n    M, needs_trunc = _extend(M, sym)\n\n    n = paddle.arange(0, M, dtype=dtype) - (M - 1.0) / 2.0\n    w = paddle.exp(-0.5 * paddle.abs(n / sig) ** (2 * p))\n\n    return _truncate(w, needs_trunc)\n\n\n@window_function_register.register()\ndef _general_cosine(\n    M: int, a: float, sym: bool = True, dtype: str = 'float64'\n) -> Tensor:\n    \"\"\"Compute a generic weighted sum of cosine terms window.\n    This function is consistent with scipy.signal.windows.general_cosine().\n    \"\"\"\n    if _len_guards(M):\n        return paddle.ones((M,), dtype=dtype)\n    M, needs_trunc = _extend(M, sym)\n    fac = paddle.linspace(-math.pi, math.pi, M, dtype=dtype)\n    w = paddle.zeros((M,), dtype=dtype)\n    for k in range(len(a)):\n        w += a[k] * paddle.cos(k * fac)\n    return _truncate(w, needs_trunc)\n\n\n@window_function_register.register()\ndef _general_hamming(\n    M: int, alpha: float, sym: bool = True, dtype: str = 'float64'\n) -> Tensor:\n    \"\"\"Compute a generalized Hamming window.\n    This function is consistent with scipy.signal.windows.general_hamming()\n    \"\"\"\n    return _general_cosine(M, [alpha, 1.0 - alpha], sym, dtype=dtype)\n\n\n@window_function_register.register()\ndef _taylor(\n    M: int, nbar=4, sll=30, norm=True, sym: bool = True, dtype: str = 'float64'\n) -> Tensor:\n    \"\"\"Compute a Taylor window.\n    The Taylor window taper function approximates the Dolph-Chebyshev window's\n    constant sidelobe level for a parameterized number of near-in sidelobes.\n    \"\"\"\n    if _len_guards(M):\n        return paddle.ones((M,), dtype=dtype)\n    M, needs_trunc = _extend(M, sym)\n    # Original text uses a negative sidelobe level parameter and then negates\n    # it in the calculation of B. To keep consistent with other methods we\n    # assume the sidelobe level parameter to be positive.\n    B = 10 ** (sll / 20)\n    A = _acosh(B) / math.pi\n    s2 = nbar**2 / (A**2 + (nbar - 0.5) ** 2)\n    ma = paddle.arange(1, nbar, dtype=dtype)\n\n    Fm = paddle.empty((nbar - 1,), dtype=dtype)\n    signs = paddle.empty_like(ma)\n    signs[::2] = 1\n    signs[1::2] = -1\n    m2 = ma * ma\n    for mi in range(len(ma)):\n        numer = signs[mi] * paddle.prod(\n            1 - m2[mi] / s2 / (A**2 + (ma - 0.5) ** 2)\n        )\n        if mi == 0:\n            denom = 2 * paddle.prod(1 - m2[mi] / m2[mi + 1 :])\n        elif mi == len(ma) - 1:\n            denom = 2 * paddle.prod(1 - m2[mi] / m2[:mi])\n        else:\n            denom = (\n                2\n                * paddle.prod(1 - m2[mi] / m2[:mi])\n                * paddle.prod(1 - m2[mi] / m2[mi + 1 :])\n            )\n\n        Fm[mi] = numer / denom\n\n    def W(n):\n        return 1 + 2 * paddle.matmul(\n            Fm.unsqueeze(0),\n            paddle.cos(2 * math.pi * ma.unsqueeze(1) * (n - M / 2.0 + 0.5) / M),\n        )\n\n    w = W(paddle.arange(0, M, dtype=dtype))\n\n    # normalize (Note that this is not described in the original text [1])\n    if norm:\n        scale = 1.0 / W((M - 1) / 2)\n        w *= scale\n    w = w.squeeze()\n    return _truncate(w, needs_trunc)\n\n\n@window_function_register.register()\ndef _hamming(M: int, sym: bool = True, dtype: str = 'float64') -> Tensor:\n    \"\"\"Compute a Hamming window.\n    The Hamming window is a taper formed by using a raised cosine with\n    non-zero endpoints, optimized to minimize the nearest side lobe.\n    \"\"\"\n    return _general_hamming(M, 0.54, sym, dtype=dtype)\n\n\n@window_function_register.register()\ndef _hann(M: int, sym: bool = True, dtype: str = 'float64') -> Tensor:\n    \"\"\"Compute a Hann window.\n    The Hann window is a taper formed by using a raised cosine or sine-squared\n    with ends that touch zero.\n    \"\"\"\n    return _general_hamming(M, 0.5, sym, dtype=dtype)\n\n\n@window_function_register.register()\ndef _tukey(\n    M: int, alpha=0.5, sym: bool = True, dtype: str = 'float64'\n) -> Tensor:\n    \"\"\"Compute a Tukey window.\n    The Tukey window is also known as a tapered cosine window.\n    \"\"\"\n    if _len_guards(M):\n        return paddle.ones((M,), dtype=dtype)\n\n    if alpha <= 0:\n        return paddle.ones((M,), dtype=dtype)\n    elif alpha >= 1.0:\n        return hann(M, sym=sym)\n\n    M, needs_trunc = _extend(M, sym)\n\n    n = paddle.arange(0, M, dtype=dtype)\n    width = int(alpha * (M - 1) / 2.0)\n    n1 = n[0 : width + 1]\n    n2 = n[width + 1 : M - width - 1]\n    n3 = n[M - width - 1 :]\n\n    w1 = 0.5 * (1 + paddle.cos(math.pi * (-1 + 2.0 * n1 / alpha / (M - 1))))\n    w2 = paddle.ones(n2.shape, dtype=dtype)\n    w3 = 0.5 * (\n        1\n        + paddle.cos(math.pi * (-2.0 / alpha + 1 + 2.0 * n3 / alpha / (M - 1)))\n    )\n    w = paddle.concat([w1, w2, w3])\n\n    return _truncate(w, needs_trunc)\n\n\n@window_function_register.register()\ndef _kaiser(\n    M: int, beta: float, sym: bool = True, dtype: str = 'float64'\n) -> Tensor:\n    \"\"\"Compute a Kaiser window.\n    The Kaiser window is a taper formed by using a Bessel function.\n    \"\"\"\n    raise NotImplementedError()\n\n\n@window_function_register.register()\ndef _gaussian(\n    M: int, std: float, sym: bool = True, dtype: str = 'float64'\n) -> Tensor:\n    \"\"\"Compute a Gaussian window.\n    The Gaussian widows has a Gaussian shape defined by the standard deviation(std).\n    \"\"\"\n    if _len_guards(M):\n        return paddle.ones((M,), dtype=dtype)\n    M, needs_trunc = _extend(M, sym)\n\n    n = paddle.arange(0, M, dtype=dtype) - (M - 1.0) / 2.0\n    sig2 = 2 * std * std\n    w = paddle.exp(-(n**2) / sig2)\n\n    return _truncate(w, needs_trunc)\n\n\n@window_function_register.register()\ndef _exponential(\n    M: int, center=None, tau=1.0, sym: bool = True, dtype: str = 'float64'\n) -> Tensor:\n    \"\"\"Compute an exponential (or Poisson) window.\"\"\"\n    if sym and center is not None:\n        raise ValueError(\"If sym==True, center must be None.\")\n    if _len_guards(M):\n        return paddle.ones((M,), dtype=dtype)\n    M, needs_trunc = _extend(M, sym)\n\n    if center is None:\n        center = (M - 1) / 2\n\n    n = paddle.arange(0, M, dtype=dtype)\n    w = paddle.exp(-paddle.abs(n - center) / tau)\n\n    return _truncate(w, needs_trunc)\n\n\n@window_function_register.register()\ndef _triang(M: int, sym: bool = True, dtype: str = 'float64') -> Tensor:\n    \"\"\"Compute a triangular window.\"\"\"\n    if _len_guards(M):\n        return paddle.ones((M,), dtype=dtype)\n    M, needs_trunc = _extend(M, sym)\n\n    n = paddle.arange(1, (M + 1) // 2 + 1, dtype=dtype)\n    if M % 2 == 0:\n        w = (2 * n - 1.0) / M\n        w = paddle.concat([w, w[::-1]])\n    else:\n        w = 2 * n / (M + 1.0)\n        w = paddle.concat([w, w[-2::-1]])\n\n    return _truncate(w, needs_trunc)\n\n\n@window_function_register.register()\ndef _bohman(M: int, sym: bool = True, dtype: str = 'float64') -> Tensor:\n    \"\"\"Compute a Bohman window.\n    The Bohman window is the autocorrelation of a cosine window.\n    \"\"\"\n    if _len_guards(M):\n        return paddle.ones((M,), dtype=dtype)\n    M, needs_trunc = _extend(M, sym)\n\n    fac = paddle.abs(paddle.linspace(-1, 1, M, dtype=dtype)[1:-1])\n    w = (1 - fac) * paddle.cos(math.pi * fac) + 1.0 / math.pi * paddle.sin(\n        math.pi * fac\n    )\n    w = _cat([0, w, 0], dtype)\n\n    return _truncate(w, needs_trunc)\n\n\n@window_function_register.register()\ndef _blackman(M: int, sym: bool = True, dtype: str = 'float64') -> Tensor:\n    \"\"\"Compute a Blackman window.\n    The Blackman window is a taper formed by using the first three terms of\n    a summation of cosines. It was designed to have close to the minimal\n    leakage possible.  It is close to optimal, only slightly worse than a\n    Kaiser window.\n    \"\"\"\n    return _general_cosine(M, [0.42, 0.50, 0.08], sym, dtype=dtype)\n\n\n@window_function_register.register()\ndef _cosine(M: int, sym: bool = True, dtype: str = 'float64') -> Tensor:\n    \"\"\"Compute a window with a simple cosine shape.\"\"\"\n    if _len_guards(M):\n        return paddle.ones((M,), dtype=dtype)\n    M, needs_trunc = _extend(M, sym)\n    w = paddle.sin(math.pi / M * (paddle.arange(0, M, dtype=dtype) + 0.5))\n\n    return _truncate(w, needs_trunc)\n\n\ndef get_window(\n    window: Union[str, Tuple[str, float]],\n    win_length: int,\n    fftbins: bool = True,\n    dtype: str = 'float64',\n) -> Tensor:\n    \"\"\"Return a window of a given length and type.\n\n    Args:\n        window (Union[str, Tuple[str, float]]): The window function applied to the signal before the Fourier transform. Supported window functions: 'hamming', 'hann', 'kaiser', 'gaussian', 'general_gaussian', 'exponential', 'triang', 'bohman', 'blackman', 'cosine', 'tukey', 'taylor'.\n        win_length (int): Number of samples.\n        fftbins (bool, optional): If True, create a \"periodic\" window. Otherwise, create a \"symmetric\" window, for use in filter design. Defaults to True.\n        dtype (str, optional): The data type of the return window. Defaults to 'float64'.\n\n    Returns:\n        Tensor: The window represented as a tensor.\n\n    Examples:\n        .. code-block:: python\n\n            import paddle\n\n            n_fft = 512\n            cosine_window = paddle.audio.functional.get_window('cosine', n_fft)\n\n            std = 7\n            gussian_window = paddle.audio.functional.get_window(('gaussian',std), n_fft)\n    \"\"\"\n    sym = not fftbins\n\n    args = ()\n    if isinstance(window, tuple):\n        winstr = window[0]\n        if len(window) > 1:\n            args = window[1:]\n    elif isinstance(window, str):\n        if window in ['gaussian', 'exponential']:\n            raise ValueError(\n                \"The '\" + window + \"' window needs one or \"\n                \"more parameters -- pass a tuple.\"\n            )\n        else:\n            winstr = window\n    else:\n        raise ValueError(\n            \"%s as window type is not supported.\" % str(type(window))\n        )\n\n    try:\n        winfunc = window_function_register.get('_' + winstr)\n    except KeyError as e:\n        raise ValueError(\"Unknown window type.\") from e\n\n    params = (win_length,) + args\n    kwargs = {'sym': sym}\n    return winfunc(*params, dtype=dtype, **kwargs)\n"], "filenames": ["python/paddle/audio/functional/window.py"], "buggy_code_start_loc": [21], "buggy_code_end_loc": [353], "fixing_code_start_loc": [22], "fixing_code_end_loc": [391], "type": "CWE-94", "message": "In PaddlePaddle before 2.4, paddle.audio.functional.get_window is vulnerable to code injection because it calls eval on a user-supplied winstr. This may lead to arbitrary code execution.", "other": {"cve": {"id": "CVE-2022-45908", "sourceIdentifier": "cve@mitre.org", "published": "2022-11-26T02:15:10.323", "lastModified": "2022-12-01T17:59:35.947", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In PaddlePaddle before 2.4, paddle.audio.functional.get_window is vulnerable to code injection because it calls eval on a user-supplied winstr. This may lead to arbitrary code execution."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-94"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:paddlepaddle:paddlepaddle:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.4", "matchCriteriaId": "C504B33B-35BC-4217-A38C-FDB036BA39A6"}]}]}], "references": [{"url": "https://github.com/PaddlePaddle/Paddle/blob/develop/security/advisory/pdsa-2022-002.md", "source": "cve@mitre.org", "tags": ["Exploit", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/PaddlePaddle/Paddle/commit/26c419ca386aeae3c461faf2b828d00b48e908eb", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/PaddlePaddle/Paddle/commit/26c419ca386aeae3c461faf2b828d00b48e908eb"}}