{"buggy_code": ["package restful\n\n// Copyright 2013 Ernest Micklei. All rights reserved.\n// Use of this source code is governed by a license\n// that can be found in the LICENSE file.\n\nimport (\n\t\"regexp\"\n\t\"strconv\"\n\t\"strings\"\n)\n\n// CrossOriginResourceSharing is used to create a Container Filter that implements CORS.\n// Cross-origin resource sharing (CORS) is a mechanism that allows JavaScript on a web page\n// to make XMLHttpRequests to another domain, not the domain the JavaScript originated from.\n//\n// http://en.wikipedia.org/wiki/Cross-origin_resource_sharing\n// http://enable-cors.org/server.html\n// http://www.html5rocks.com/en/tutorials/cors/#toc-handling-a-not-so-simple-request\ntype CrossOriginResourceSharing struct {\n\tExposeHeaders  []string // list of Header names\n\tAllowedHeaders []string // list of Header names\n\tAllowedDomains []string // list of allowed values for Http Origin. An allowed value can be a regular expression to support subdomain matching. If empty all are allowed.\n\tAllowedMethods []string\n\tMaxAge         int // number of seconds before requiring new Options request\n\tCookiesAllowed bool\n\tContainer      *Container\n\n\tallowedOriginPatterns []*regexp.Regexp // internal field for origin regexp check.\n}\n\n// Filter is a filter function that implements the CORS flow as documented on http://enable-cors.org/server.html\n// and http://www.html5rocks.com/static/images/cors_server_flowchart.png\nfunc (c CrossOriginResourceSharing) Filter(req *Request, resp *Response, chain *FilterChain) {\n\torigin := req.Request.Header.Get(HEADER_Origin)\n\tif len(origin) == 0 {\n\t\tif trace {\n\t\t\ttraceLogger.Print(\"no Http header Origin set\")\n\t\t}\n\t\tchain.ProcessFilter(req, resp)\n\t\treturn\n\t}\n\tif !c.isOriginAllowed(origin) { // check whether this origin is allowed\n\t\tif trace {\n\t\t\ttraceLogger.Printf(\"HTTP Origin:%s is not part of %v, neither matches any part of %v\", origin, c.AllowedDomains, c.allowedOriginPatterns)\n\t\t}\n\t\tchain.ProcessFilter(req, resp)\n\t\treturn\n\t}\n\tif req.Request.Method != \"OPTIONS\" {\n\t\tc.doActualRequest(req, resp)\n\t\tchain.ProcessFilter(req, resp)\n\t\treturn\n\t}\n\tif acrm := req.Request.Header.Get(HEADER_AccessControlRequestMethod); acrm != \"\" {\n\t\tc.doPreflightRequest(req, resp)\n\t} else {\n\t\tc.doActualRequest(req, resp)\n\t\tchain.ProcessFilter(req, resp)\n\t\treturn\n\t}\n}\n\nfunc (c CrossOriginResourceSharing) doActualRequest(req *Request, resp *Response) {\n\tc.setOptionsHeaders(req, resp)\n\t// continue processing the response\n}\n\nfunc (c *CrossOriginResourceSharing) doPreflightRequest(req *Request, resp *Response) {\n\tif len(c.AllowedMethods) == 0 {\n\t\tif c.Container == nil {\n\t\t\tc.AllowedMethods = DefaultContainer.computeAllowedMethods(req)\n\t\t} else {\n\t\t\tc.AllowedMethods = c.Container.computeAllowedMethods(req)\n\t\t}\n\t}\n\n\tacrm := req.Request.Header.Get(HEADER_AccessControlRequestMethod)\n\tif !c.isValidAccessControlRequestMethod(acrm, c.AllowedMethods) {\n\t\tif trace {\n\t\t\ttraceLogger.Printf(\"Http header %s:%s is not in %v\",\n\t\t\t\tHEADER_AccessControlRequestMethod,\n\t\t\t\tacrm,\n\t\t\t\tc.AllowedMethods)\n\t\t}\n\t\treturn\n\t}\n\tacrhs := req.Request.Header.Get(HEADER_AccessControlRequestHeaders)\n\tif len(acrhs) > 0 {\n\t\tfor _, each := range strings.Split(acrhs, \",\") {\n\t\t\tif !c.isValidAccessControlRequestHeader(strings.Trim(each, \" \")) {\n\t\t\t\tif trace {\n\t\t\t\t\ttraceLogger.Printf(\"Http header %s:%s is not in %v\",\n\t\t\t\t\t\tHEADER_AccessControlRequestHeaders,\n\t\t\t\t\t\tacrhs,\n\t\t\t\t\t\tc.AllowedHeaders)\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}\n\tresp.AddHeader(HEADER_AccessControlAllowMethods, strings.Join(c.AllowedMethods, \",\"))\n\tresp.AddHeader(HEADER_AccessControlAllowHeaders, acrhs)\n\tc.setOptionsHeaders(req, resp)\n\n\t// return http 200 response, no body\n}\n\nfunc (c CrossOriginResourceSharing) setOptionsHeaders(req *Request, resp *Response) {\n\tc.checkAndSetExposeHeaders(resp)\n\tc.setAllowOriginHeader(req, resp)\n\tc.checkAndSetAllowCredentials(resp)\n\tif c.MaxAge > 0 {\n\t\tresp.AddHeader(HEADER_AccessControlMaxAge, strconv.Itoa(c.MaxAge))\n\t}\n}\n\nfunc (c CrossOriginResourceSharing) isOriginAllowed(origin string) bool {\n\tif len(origin) == 0 {\n\t\treturn false\n\t}\n\tif len(c.AllowedDomains) == 0 {\n\t\treturn true\n\t}\n\n\tallowed := false\n\tfor _, domain := range c.AllowedDomains {\n\t\tif domain == origin {\n\t\t\tallowed = true\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif !allowed {\n\t\tif len(c.allowedOriginPatterns) == 0 {\n\t\t\t// compile allowed domains to allowed origin patterns\n\t\t\tallowedOriginRegexps, err := compileRegexps(c.AllowedDomains)\n\t\t\tif err != nil {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tc.allowedOriginPatterns = allowedOriginRegexps\n\t\t}\n\n\t\tfor _, pattern := range c.allowedOriginPatterns {\n\t\t\tif allowed = pattern.MatchString(origin); allowed {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\n\treturn allowed\n}\n\nfunc (c CrossOriginResourceSharing) setAllowOriginHeader(req *Request, resp *Response) {\n\torigin := req.Request.Header.Get(HEADER_Origin)\n\tif c.isOriginAllowed(origin) {\n\t\tresp.AddHeader(HEADER_AccessControlAllowOrigin, origin)\n\t}\n}\n\nfunc (c CrossOriginResourceSharing) checkAndSetExposeHeaders(resp *Response) {\n\tif len(c.ExposeHeaders) > 0 {\n\t\tresp.AddHeader(HEADER_AccessControlExposeHeaders, strings.Join(c.ExposeHeaders, \",\"))\n\t}\n}\n\nfunc (c CrossOriginResourceSharing) checkAndSetAllowCredentials(resp *Response) {\n\tif c.CookiesAllowed {\n\t\tresp.AddHeader(HEADER_AccessControlAllowCredentials, \"true\")\n\t}\n}\n\nfunc (c CrossOriginResourceSharing) isValidAccessControlRequestMethod(method string, allowedMethods []string) bool {\n\tfor _, each := range allowedMethods {\n\t\tif each == method {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\nfunc (c CrossOriginResourceSharing) isValidAccessControlRequestHeader(header string) bool {\n\tfor _, each := range c.AllowedHeaders {\n\t\tif strings.ToLower(each) == strings.ToLower(header) {\n\t\t\treturn true\n\t\t}\n\t\tif each == \"*\" {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n// Take a list of strings and compile them into a list of regular expressions.\nfunc compileRegexps(regexpStrings []string) ([]*regexp.Regexp, error) {\n\tregexps := []*regexp.Regexp{}\n\tfor _, regexpStr := range regexpStrings {\n\t\tr, err := regexp.Compile(regexpStr)\n\t\tif err != nil {\n\t\t\treturn regexps, err\n\t\t}\n\t\tregexps = append(regexps, r)\n\t}\n\treturn regexps, nil\n}\n", "package restful\n\nimport (\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"testing\"\n)\n\n// go test -v -test.run TestCORSFilter_Preflight ...restful\n// http://www.html5rocks.com/en/tutorials/cors/#toc-handling-a-not-so-simple-request\nfunc TestCORSFilter_Preflight(t *testing.T) {\n\ttearDown()\n\tws := new(WebService)\n\tws.Route(ws.PUT(\"/cors\").To(dummy))\n\tAdd(ws)\n\n\tcors := CrossOriginResourceSharing{\n\t\tExposeHeaders:  []string{\"X-Custom-Header\"},\n\t\tAllowedHeaders: []string{\"X-Custom-Header\", \"X-Additional-Header\"},\n\t\tCookiesAllowed: true,\n\t\tContainer:      DefaultContainer}\n\tFilter(cors.Filter)\n\n\t// Preflight\n\thttpRequest, _ := http.NewRequest(\"OPTIONS\", \"http://api.alice.com/cors\", nil)\n\thttpRequest.Method = \"OPTIONS\"\n\thttpRequest.Header.Set(HEADER_Origin, \"http://api.bob.com\")\n\thttpRequest.Header.Set(HEADER_AccessControlRequestMethod, \"PUT\")\n\thttpRequest.Header.Set(HEADER_AccessControlRequestHeaders, \"X-Custom-Header, X-Additional-Header\")\n\n\thttpWriter := httptest.NewRecorder()\n\tDefaultContainer.Dispatch(httpWriter, httpRequest)\n\n\tactual := httpWriter.Header().Get(HEADER_AccessControlAllowOrigin)\n\tif \"http://api.bob.com\" != actual {\n\t\tt.Fatal(\"expected: http://api.bob.com but got:\" + actual)\n\t}\n\tactual = httpWriter.Header().Get(HEADER_AccessControlAllowMethods)\n\tif \"PUT\" != actual {\n\t\tt.Fatal(\"expected: PUT but got:\" + actual)\n\t}\n\tactual = httpWriter.Header().Get(HEADER_AccessControlAllowHeaders)\n\tif \"X-Custom-Header, X-Additional-Header\" != actual {\n\t\tt.Fatal(\"expected: X-Custom-Header, X-Additional-Header but got:\" + actual)\n\t}\n\n\tif !cors.isOriginAllowed(\"somewhere\") {\n\t\tt.Fatal(\"origin expected to be allowed\")\n\t}\n\tcors.AllowedDomains = []string{\"overthere.com\"}\n\tif cors.isOriginAllowed(\"somewhere\") {\n\t\tt.Fatal(\"origin [somewhere] expected NOT to be allowed\")\n\t}\n\tif !cors.isOriginAllowed(\"overthere.com\") {\n\t\tt.Fatal(\"origin [overthere] expected to be allowed\")\n\t}\n\n}\n\n// go test -v -test.run TestCORSFilter_Actual ...restful\n// http://www.html5rocks.com/en/tutorials/cors/#toc-handling-a-not-so-simple-request\nfunc TestCORSFilter_Actual(t *testing.T) {\n\ttearDown()\n\tws := new(WebService)\n\tws.Route(ws.PUT(\"/cors\").To(dummy))\n\tAdd(ws)\n\n\tcors := CrossOriginResourceSharing{\n\t\tExposeHeaders:  []string{\"X-Custom-Header\"},\n\t\tAllowedHeaders: []string{\"X-Custom-Header\", \"X-Additional-Header\"},\n\t\tCookiesAllowed: true,\n\t\tContainer:      DefaultContainer}\n\tFilter(cors.Filter)\n\n\t// Actual\n\thttpRequest, _ := http.NewRequest(\"PUT\", \"http://api.alice.com/cors\", nil)\n\thttpRequest.Header.Set(HEADER_Origin, \"http://api.bob.com\")\n\thttpRequest.Header.Set(\"X-Custom-Header\", \"value\")\n\n\thttpWriter := httptest.NewRecorder()\n\tDefaultContainer.Dispatch(httpWriter, httpRequest)\n\tactual := httpWriter.Header().Get(HEADER_AccessControlAllowOrigin)\n\tif \"http://api.bob.com\" != actual {\n\t\tt.Fatal(\"expected: http://api.bob.com but got:\" + actual)\n\t}\n\tif httpWriter.Body.String() != \"dummy\" {\n\t\tt.Fatal(\"expected: dummy but got:\" + httpWriter.Body.String())\n\t}\n}\n\nvar allowedDomainInput = []struct {\n\tdomains []string\n\torigin  string\n\tallowed bool\n}{\n\t{[]string{}, \"http://anything.com\", true},\n\t{[]string{\"example.com\"}, \"example.com\", true},\n\t{[]string{\"example.com\"}, \"not-allowed\", false},\n\t{[]string{\"not-matching.com\", \"example.com\"}, \"example.com\", true},\n\t{[]string{\".*\"}, \"example.com\", true},\n}\n\n// go test -v -test.run TestCORSFilter_AllowedDomains ...restful\nfunc TestCORSFilter_AllowedDomains(t *testing.T) {\n\tfor _, each := range allowedDomainInput {\n\t\ttearDown()\n\t\tws := new(WebService)\n\t\tws.Route(ws.PUT(\"/cors\").To(dummy))\n\t\tAdd(ws)\n\n\t\tcors := CrossOriginResourceSharing{\n\t\t\tAllowedDomains: each.domains,\n\t\t\tCookiesAllowed: true,\n\t\t\tContainer:      DefaultContainer}\n\t\tFilter(cors.Filter)\n\n\t\thttpRequest, _ := http.NewRequest(\"PUT\", \"http://api.his.com/cors\", nil)\n\t\thttpRequest.Header.Set(HEADER_Origin, each.origin)\n\t\thttpWriter := httptest.NewRecorder()\n\t\tDefaultContainer.Dispatch(httpWriter, httpRequest)\n\t\tactual := httpWriter.Header().Get(HEADER_AccessControlAllowOrigin)\n\t\tif actual != each.origin && each.allowed {\n\t\t\tt.Fatal(\"expected to be accepted\")\n\t\t}\n\t\tif actual == each.origin && !each.allowed {\n\t\t\tt.Fatal(\"did not expect to be accepted\")\n\t\t}\n\t}\n}\n"], "fixing_code": ["package restful\n\n// Copyright 2013 Ernest Micklei. All rights reserved.\n// Use of this source code is governed by a license\n// that can be found in the LICENSE file.\n\nimport (\n\t\"regexp\"\n\t\"strconv\"\n\t\"strings\"\n)\n\n// CrossOriginResourceSharing is used to create a Container Filter that implements CORS.\n// Cross-origin resource sharing (CORS) is a mechanism that allows JavaScript on a web page\n// to make XMLHttpRequests to another domain, not the domain the JavaScript originated from.\n//\n// http://en.wikipedia.org/wiki/Cross-origin_resource_sharing\n// http://enable-cors.org/server.html\n// http://www.html5rocks.com/en/tutorials/cors/#toc-handling-a-not-so-simple-request\ntype CrossOriginResourceSharing struct {\n\tExposeHeaders []string // list of Header names\n\n\t// AllowedHeaders is alist of Header names. Checking is case-insensitive.\n\t// The list may contain the special wildcard string \".*\" ; all is allowed\n\tAllowedHeaders []string\n\n\t// AllowedDomains is a list of allowed values for Http Origin.\n\t// The list may contain the special wildcard string \".*\" ; all is allowed\n\t// If empty all are allowed.\n\tAllowedDomains []string\n\n\t// AllowedDomainFunc is optional and is a function that will do the check\n\t// when the origin is not part of the AllowedDomains and it does not contain the wildcard \".*\".\n\tAllowedDomainFunc func(origin string) bool\n\n\t// AllowedMethods is either empty or has a list of http methods names. Checking is case-insensitive.\n\tAllowedMethods []string\n\tMaxAge         int // number of seconds before requiring new Options request\n\tCookiesAllowed bool\n\tContainer      *Container\n\n\tallowedOriginPatterns []*regexp.Regexp // internal field for origin regexp check.\n}\n\n// Filter is a filter function that implements the CORS flow as documented on http://enable-cors.org/server.html\n// and http://www.html5rocks.com/static/images/cors_server_flowchart.png\nfunc (c CrossOriginResourceSharing) Filter(req *Request, resp *Response, chain *FilterChain) {\n\torigin := req.Request.Header.Get(HEADER_Origin)\n\tif len(origin) == 0 {\n\t\tif trace {\n\t\t\ttraceLogger.Print(\"no Http header Origin set\")\n\t\t}\n\t\tchain.ProcessFilter(req, resp)\n\t\treturn\n\t}\n\tif !c.isOriginAllowed(origin) { // check whether this origin is allowed\n\t\tif trace {\n\t\t\ttraceLogger.Printf(\"HTTP Origin:%s is not part of %v, neither matches any part of %v\", origin, c.AllowedDomains, c.allowedOriginPatterns)\n\t\t}\n\t\tchain.ProcessFilter(req, resp)\n\t\treturn\n\t}\n\tif req.Request.Method != \"OPTIONS\" {\n\t\tc.doActualRequest(req, resp)\n\t\tchain.ProcessFilter(req, resp)\n\t\treturn\n\t}\n\tif acrm := req.Request.Header.Get(HEADER_AccessControlRequestMethod); acrm != \"\" {\n\t\tc.doPreflightRequest(req, resp)\n\t} else {\n\t\tc.doActualRequest(req, resp)\n\t\tchain.ProcessFilter(req, resp)\n\t\treturn\n\t}\n}\n\nfunc (c CrossOriginResourceSharing) doActualRequest(req *Request, resp *Response) {\n\tc.setOptionsHeaders(req, resp)\n\t// continue processing the response\n}\n\nfunc (c *CrossOriginResourceSharing) doPreflightRequest(req *Request, resp *Response) {\n\tif len(c.AllowedMethods) == 0 {\n\t\tif c.Container == nil {\n\t\t\tc.AllowedMethods = DefaultContainer.computeAllowedMethods(req)\n\t\t} else {\n\t\t\tc.AllowedMethods = c.Container.computeAllowedMethods(req)\n\t\t}\n\t}\n\n\tacrm := req.Request.Header.Get(HEADER_AccessControlRequestMethod)\n\tif !c.isValidAccessControlRequestMethod(acrm, c.AllowedMethods) {\n\t\tif trace {\n\t\t\ttraceLogger.Printf(\"Http header %s:%s is not in %v\",\n\t\t\t\tHEADER_AccessControlRequestMethod,\n\t\t\t\tacrm,\n\t\t\t\tc.AllowedMethods)\n\t\t}\n\t\treturn\n\t}\n\tacrhs := req.Request.Header.Get(HEADER_AccessControlRequestHeaders)\n\tif len(acrhs) > 0 {\n\t\tfor _, each := range strings.Split(acrhs, \",\") {\n\t\t\tif !c.isValidAccessControlRequestHeader(strings.Trim(each, \" \")) {\n\t\t\t\tif trace {\n\t\t\t\t\ttraceLogger.Printf(\"Http header %s:%s is not in %v\",\n\t\t\t\t\t\tHEADER_AccessControlRequestHeaders,\n\t\t\t\t\t\tacrhs,\n\t\t\t\t\t\tc.AllowedHeaders)\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}\n\tresp.AddHeader(HEADER_AccessControlAllowMethods, strings.Join(c.AllowedMethods, \",\"))\n\tresp.AddHeader(HEADER_AccessControlAllowHeaders, acrhs)\n\tc.setOptionsHeaders(req, resp)\n\n\t// return http 200 response, no body\n}\n\nfunc (c CrossOriginResourceSharing) setOptionsHeaders(req *Request, resp *Response) {\n\tc.checkAndSetExposeHeaders(resp)\n\tc.setAllowOriginHeader(req, resp)\n\tc.checkAndSetAllowCredentials(resp)\n\tif c.MaxAge > 0 {\n\t\tresp.AddHeader(HEADER_AccessControlMaxAge, strconv.Itoa(c.MaxAge))\n\t}\n}\n\nfunc (c CrossOriginResourceSharing) isOriginAllowed(origin string) bool {\n\tif len(origin) == 0 {\n\t\treturn false\n\t}\n\tlowerOrigin := strings.ToLower(origin)\n\tif len(c.AllowedDomains) == 0 {\n\t\tif c.AllowedDomainFunc != nil {\n\t\t\treturn c.AllowedDomainFunc(lowerOrigin)\n\t\t}\n\t\treturn true\n\t}\n\n\t// exact match on each allowed domain\n\tfor _, domain := range c.AllowedDomains {\n\t\tif domain == \".*\" || strings.ToLower(domain) == lowerOrigin {\n\t\t\treturn true\n\t\t}\n\t}\n\tif c.AllowedDomainFunc != nil {\n\t\treturn c.AllowedDomainFunc(origin)\n\t}\n\treturn false\n}\n\nfunc (c CrossOriginResourceSharing) setAllowOriginHeader(req *Request, resp *Response) {\n\torigin := req.Request.Header.Get(HEADER_Origin)\n\tif c.isOriginAllowed(origin) {\n\t\tresp.AddHeader(HEADER_AccessControlAllowOrigin, origin)\n\t}\n}\n\nfunc (c CrossOriginResourceSharing) checkAndSetExposeHeaders(resp *Response) {\n\tif len(c.ExposeHeaders) > 0 {\n\t\tresp.AddHeader(HEADER_AccessControlExposeHeaders, strings.Join(c.ExposeHeaders, \",\"))\n\t}\n}\n\nfunc (c CrossOriginResourceSharing) checkAndSetAllowCredentials(resp *Response) {\n\tif c.CookiesAllowed {\n\t\tresp.AddHeader(HEADER_AccessControlAllowCredentials, \"true\")\n\t}\n}\n\nfunc (c CrossOriginResourceSharing) isValidAccessControlRequestMethod(method string, allowedMethods []string) bool {\n\tfor _, each := range allowedMethods {\n\t\tif each == method {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\nfunc (c CrossOriginResourceSharing) isValidAccessControlRequestHeader(header string) bool {\n\tfor _, each := range c.AllowedHeaders {\n\t\tif strings.ToLower(each) == strings.ToLower(header) {\n\t\t\treturn true\n\t\t}\n\t\tif each == \"*\" {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n", "package restful\n\nimport (\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"testing\"\n)\n\n// go test -v -test.run TestCORSFilter_Preflight ...restful\n// http://www.html5rocks.com/en/tutorials/cors/#toc-handling-a-not-so-simple-request\nfunc TestCORSFilter_Preflight(t *testing.T) {\n\ttearDown()\n\tws := new(WebService)\n\tws.Route(ws.PUT(\"/cors\").To(dummy))\n\tAdd(ws)\n\n\tcors := CrossOriginResourceSharing{\n\t\tExposeHeaders:  []string{\"X-Custom-Header\"},\n\t\tAllowedHeaders: []string{\"X-Custom-Header\", \"X-Additional-Header\"},\n\t\tCookiesAllowed: true,\n\t\tContainer:      DefaultContainer}\n\tFilter(cors.Filter)\n\n\t// Preflight\n\thttpRequest, _ := http.NewRequest(\"OPTIONS\", \"http://api.alice.com/cors\", nil)\n\thttpRequest.Method = \"OPTIONS\"\n\thttpRequest.Header.Set(HEADER_Origin, \"http://api.bob.com\")\n\thttpRequest.Header.Set(HEADER_AccessControlRequestMethod, \"PUT\")\n\thttpRequest.Header.Set(HEADER_AccessControlRequestHeaders, \"X-Custom-Header, X-Additional-Header\")\n\n\thttpWriter := httptest.NewRecorder()\n\tDefaultContainer.Dispatch(httpWriter, httpRequest)\n\n\tactual := httpWriter.Header().Get(HEADER_AccessControlAllowOrigin)\n\tif \"http://api.bob.com\" != actual {\n\t\tt.Fatal(\"expected: http://api.bob.com but got:\" + actual)\n\t}\n\tactual = httpWriter.Header().Get(HEADER_AccessControlAllowMethods)\n\tif \"PUT\" != actual {\n\t\tt.Fatal(\"expected: PUT but got:\" + actual)\n\t}\n\tactual = httpWriter.Header().Get(HEADER_AccessControlAllowHeaders)\n\tif \"X-Custom-Header, X-Additional-Header\" != actual {\n\t\tt.Fatal(\"expected: X-Custom-Header, X-Additional-Header but got:\" + actual)\n\t}\n\n\tif !cors.isOriginAllowed(\"somewhere\") {\n\t\tt.Fatal(\"origin expected to be allowed\")\n\t}\n\tcors.AllowedDomains = []string{\"overthere.com\"}\n\tif cors.isOriginAllowed(\"somewhere\") {\n\t\tt.Fatal(\"origin [somewhere] expected NOT to be allowed\")\n\t}\n\tif !cors.isOriginAllowed(\"overthere.com\") {\n\t\tt.Fatal(\"origin [overthere] expected to be allowed\")\n\t}\n\n}\n\n// go test -v -test.run TestCORSFilter_Actual ...restful\n// http://www.html5rocks.com/en/tutorials/cors/#toc-handling-a-not-so-simple-request\nfunc TestCORSFilter_Actual(t *testing.T) {\n\ttearDown()\n\tws := new(WebService)\n\tws.Route(ws.PUT(\"/cors\").To(dummy))\n\tAdd(ws)\n\n\tcors := CrossOriginResourceSharing{\n\t\tExposeHeaders:  []string{\"X-Custom-Header\"},\n\t\tAllowedHeaders: []string{\"X-Custom-Header\", \"X-Additional-Header\"},\n\t\tCookiesAllowed: true,\n\t\tContainer:      DefaultContainer}\n\tFilter(cors.Filter)\n\n\t// Actual\n\thttpRequest, _ := http.NewRequest(\"PUT\", \"http://api.alice.com/cors\", nil)\n\thttpRequest.Header.Set(HEADER_Origin, \"http://api.bob.com\")\n\thttpRequest.Header.Set(\"X-Custom-Header\", \"value\")\n\n\thttpWriter := httptest.NewRecorder()\n\tDefaultContainer.Dispatch(httpWriter, httpRequest)\n\tactual := httpWriter.Header().Get(HEADER_AccessControlAllowOrigin)\n\tif \"http://api.bob.com\" != actual {\n\t\tt.Fatal(\"expected: http://api.bob.com but got:\" + actual)\n\t}\n\tif httpWriter.Body.String() != \"dummy\" {\n\t\tt.Fatal(\"expected: dummy but got:\" + httpWriter.Body.String())\n\t}\n}\n\nvar allowedDomainInput = []struct {\n\tdomains []string\n\torigin  string\n\tallowed bool\n}{\n\t{[]string{}, \"http://anything.com\", true},\n\t{[]string{\"example.com\"}, \"example.com\", true},\n\t{[]string{\"example.com\"}, \"not-allowed\", false},\n\t{[]string{\"not-matching.com\", \"example.com\"}, \"example.com\", true},\n\t{[]string{\".*\"}, \"example.com\", true},\n}\n\n// go test -v -test.run TestCORSFilter_AllowedDomains ...restful\nfunc TestCORSFilter_AllowedDomains(t *testing.T) {\n\tfor _, each := range allowedDomainInput {\n\t\ttearDown()\n\t\tws := new(WebService)\n\t\tws.Route(ws.PUT(\"/cors\").To(dummy))\n\t\tAdd(ws)\n\n\t\tcors := CrossOriginResourceSharing{\n\t\t\tAllowedDomains: each.domains,\n\t\t\tCookiesAllowed: true,\n\t\t\tContainer:      DefaultContainer}\n\t\tFilter(cors.Filter)\n\n\t\thttpRequest, _ := http.NewRequest(\"PUT\", \"http://api.his.com/cors\", nil)\n\t\thttpRequest.Header.Set(HEADER_Origin, each.origin)\n\t\thttpWriter := httptest.NewRecorder()\n\t\tDefaultContainer.Dispatch(httpWriter, httpRequest)\n\t\tactual := httpWriter.Header().Get(HEADER_AccessControlAllowOrigin)\n\t\tif actual != each.origin && each.allowed {\n\t\t\tt.Error(\"expected to be accepted\", each)\n\t\t}\n\t\tif actual == each.origin && !each.allowed {\n\t\t\tt.Error(\"did not expect to be accepted\")\n\t\t}\n\t}\n}\n\nfunc TestCORSFilter_AllowedDomainFunc(t *testing.T) {\n\tcors := CrossOriginResourceSharing{\n\t\tAllowedDomains: []string{\"here\", \"there\"},\n\t\tAllowedDomainFunc: func(origin string) bool {\n\t\t\treturn \"where\" == origin\n\t\t},\n\t}\n\tif got, want := cors.isOriginAllowed(\"here\"), true; got != want {\n\t\tt.Errorf(\"got [%v:%T] want [%v:%T]\", got, got, want, want)\n\t}\n\tif got, want := cors.isOriginAllowed(\"HERE\"), true; got != want {\n\t\tt.Errorf(\"got [%v:%T] want [%v:%T]\", got, got, want, want)\n\t}\n\tif got, want := cors.isOriginAllowed(\"there\"), true; got != want {\n\t\tt.Errorf(\"got [%v:%T] want [%v:%T]\", got, got, want, want)\n\t}\n\tif got, want := cors.isOriginAllowed(\"where\"), true; got != want {\n\t\tt.Errorf(\"got [%v:%T] want [%v:%T]\", got, got, want, want)\n\t}\n\tif got, want := cors.isOriginAllowed(\"nowhere\"), false; got != want {\n\t\tt.Errorf(\"got [%v:%T] want [%v:%T]\", got, got, want, want)\n\t}\n\t// just func\n\tcors.AllowedDomains = []string{}\n\tif got, want := cors.isOriginAllowed(\"here\"), false; got != want {\n\t\tt.Errorf(\"got [%v:%T] want [%v:%T]\", got, got, want, want)\n\t}\n\tif got, want := cors.isOriginAllowed(\"where\"), true; got != want {\n\t\tt.Errorf(\"got [%v:%T] want [%v:%T]\", got, got, want, want)\n\t}\n\t// empty domain\n\tif got, want := cors.isOriginAllowed(\"\"), false; got != want {\n\t\tt.Errorf(\"got [%v:%T] want [%v:%T]\", got, got, want, want)\n\t}\n}\n"], "filenames": ["cors_filter.go", "cors_filter_test.go"], "buggy_code_start_loc": [21, 123], "buggy_code_end_loc": [206, 129], "fixing_code_start_loc": [21, 123], "fixing_code_end_loc": [193, 166], "type": "CWE-639", "message": "Authorization Bypass Through User-Controlled Key in GitHub repository emicklei/go-restful prior to v3.8.0.", "other": {"cve": {"id": "CVE-2022-1996", "sourceIdentifier": "security@huntr.dev", "published": "2022-06-08T13:15:07.987", "lastModified": "2023-02-23T04:15:11.723", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Authorization Bypass Through User-Controlled Key in GitHub repository emicklei/go-restful prior to v3.8.0."}, {"lang": "es", "value": "Una Omisi\u00f3n de la Autorizaci\u00f3n Mediante una Clave Controlada por el Usuario en el repositorio GitHub emicklei/go-restful versiones anteriores a v3.8.0"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 9.1, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.2}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:C/C:H/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 9.3, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 2.8, "impactScore": 5.8}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 6.4}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-639"}]}, {"source": "nvd@nist.gov", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-639"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:go-restful_project:go-restful:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.16.0", "matchCriteriaId": "23CD29C7-E4EC-47EF-8D44-4976CC43789C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:go-restful_project:go-restful:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.0.0", "versionEndExcluding": "3.8.0", "matchCriteriaId": "9244D03B-7D8E-4215-9BBC-0E78B70C4EEC"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:35:*:*:*:*:*:*:*", "matchCriteriaId": "80E516C0-98A4-4ADE-B69F-66A772E2BAAA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:36:*:*:*:*:*:*:*", "matchCriteriaId": "5C675112-476C-4D7C-BCB9-A2FB2D0BC9FD"}]}]}], "references": [{"url": "https://github.com/emicklei/go-restful/commit/fd3c327a379ce08c68ef18765bdc925f5d9bad10", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/be837427-415c-4d8c-808b-62ce20aa84f1", "source": "security@huntr.dev", "tags": ["Exploit", "Patch", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/575BLJ3Y2EQBRNTFR2OSQQ6L2W6UCST3/", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/OBDD3Q23RCGAGHIXUCWBU6N3S4RNAKXB/", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/RQXU752ALW53OJAF5MG3WMR5CCZVLWW6/", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/SO5QC2JFW2PXBWAE27OYYYL5SPFUBHTY/", "source": "security@huntr.dev"}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/W56PP46JVZEKCANBKXFKRVSBBRRMCY6V/", "source": "security@huntr.dev"}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/Z55VUVGO7E5PJFXIOVAY373NZRHBNCI5/", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/ZGQKWD6SE75PFBPFVSZYAKAVXKBZXKWS/", "source": "security@huntr.dev"}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/ZY2SLWOQR4ZURQ7UBRZ7JIX6H6F5JHJR/", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20220923-0005/", "source": "security@huntr.dev", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/emicklei/go-restful/commit/fd3c327a379ce08c68ef18765bdc925f5d9bad10"}}