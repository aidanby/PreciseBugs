{"buggy_code": ["/**\n * @file resolve.c\n * @author Michal Vasko <mvasko@cesnet.cz>\n * @brief libyang resolve functions\n *\n * Copyright (c) 2015 - 2018 CESNET, z.s.p.o.\n *\n * This source code is licensed under BSD 3-Clause License (the \"License\").\n * You may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://opensource.org/licenses/BSD-3-Clause\n */\n\n#define _GNU_SOURCE\n\n#include <stdlib.h>\n#include <assert.h>\n#include <string.h>\n#include <ctype.h>\n#include <limits.h>\n\n#include \"libyang.h\"\n#include \"resolve.h\"\n#include \"common.h\"\n#include \"xpath.h\"\n#include \"parser.h\"\n#include \"parser_yang.h\"\n#include \"xml_internal.h\"\n#include \"hash_table.h\"\n#include \"tree_internal.h\"\n#include \"extensions.h\"\n#include \"validation.h\"\n\n/* internal parsed predicate structure */\nstruct parsed_pred {\n    const struct lys_node *schema;\n    int len;\n    struct {\n        const char *mod_name;\n        int mod_name_len;\n        const char *name;\n        int nam_len;\n        const char *value;\n        int val_len;\n    } *pred;\n};\n\nint\nparse_range_dec64(const char **str_num, uint8_t dig, int64_t *num)\n{\n    const char *ptr;\n    int minus = 0;\n    int64_t ret = 0, prev_ret;\n    int8_t str_exp, str_dig = -1, trailing_zeros = 0;\n\n    ptr = *str_num;\n\n    if (ptr[0] == '-') {\n        minus = 1;\n        ++ptr;\n    } else if (ptr[0] == '+') {\n        ++ptr;\n    }\n\n    if (!isdigit(ptr[0])) {\n        /* there must be at least one */\n        return 1;\n    }\n\n    for (str_exp = 0; isdigit(ptr[0]) || ((ptr[0] == '.') && (str_dig < 0)); ++ptr) {\n        if (str_exp > 18) {\n            return 1;\n        }\n\n        if (ptr[0] == '.') {\n            if (ptr[1] == '.') {\n                /* it's the next interval */\n                break;\n            }\n            ++str_dig;\n        } else {\n            prev_ret = ret;\n            if (minus) {\n                ret = ret * 10 - (ptr[0] - '0');\n                if (ret > prev_ret) {\n                    return 1;\n                }\n            } else {\n                ret = ret * 10 + (ptr[0] - '0');\n                if (ret < prev_ret) {\n                    return 1;\n                }\n            }\n            if (str_dig > -1) {\n                ++str_dig;\n                if (ptr[0] == '0') {\n                    /* possibly trailing zero */\n                    trailing_zeros++;\n                } else {\n                    trailing_zeros = 0;\n                }\n            }\n            ++str_exp;\n        }\n    }\n    if (str_dig == 0) {\n        /* no digits after '.' */\n        return 1;\n    } else if (str_dig == -1) {\n        /* there are 0 numbers after the floating point */\n        str_dig = 0;\n    }\n    /* remove trailing zeros */\n    if (trailing_zeros) {\n        str_dig -= trailing_zeros;\n        str_exp -= trailing_zeros;\n        ret = ret / dec_pow(trailing_zeros);\n    }\n\n    /* it's parsed, now adjust the number based on fraction-digits, if needed */\n    if (str_dig < dig) {\n        if ((str_exp - 1) + (dig - str_dig) > 18) {\n            return 1;\n        }\n        prev_ret = ret;\n        ret *= dec_pow(dig - str_dig);\n        if ((minus && (ret > prev_ret)) || (!minus && (ret < prev_ret))) {\n            return 1;\n        }\n\n    }\n    if (str_dig > dig) {\n        return 1;\n    }\n\n    *str_num = ptr;\n    *num = ret;\n\n    return 0;\n}\n\n/**\n * @brief Parse an identifier.\n *\n * ;; An identifier MUST NOT start with (('X'|'x') ('M'|'m') ('L'|'l'))\n * identifier          = (ALPHA / \"_\")\n *                       *(ALPHA / DIGIT / \"_\" / \"-\" / \".\")\n *\n * @param[in] id Identifier to use.\n *\n * @return Number of characters successfully parsed.\n */\nunsigned int\nparse_identifier(const char *id)\n{\n    unsigned int parsed = 0;\n\n    assert(id);\n\n    if (!isalpha(id[0]) && (id[0] != '_')) {\n        return -parsed;\n    }\n\n    ++parsed;\n    ++id;\n\n    while (isalnum(id[0]) || (id[0] == '_') || (id[0] == '-') || (id[0] == '.')) {\n        ++parsed;\n        ++id;\n    }\n\n    return parsed;\n}\n\n/**\n * @brief Parse a node-identifier.\n *\n * node-identifier     = [module-name \":\"] identifier\n *\n * @param[in] id Identifier to use.\n * @param[out] mod_name Points to the module name, NULL if there is not any.\n * @param[out] mod_name_len Length of the module name, 0 if there is not any.\n * @param[out] name Points to the node name.\n * @param[out] nam_len Length of the node name.\n * @param[out] all_desc Whether the path starts with '/', only supported in extended paths.\n * @param[in] extended Whether to accept an extended path (support for [prefix:]*, /[prefix:]*, /[prefix:]., prefix:#identifier).\n *\n * @return Number of characters successfully parsed,\n *         positive on success, negative on failure.\n */\nstatic int\nparse_node_identifier(const char *id, const char **mod_name, int *mod_name_len, const char **name, int *nam_len,\n                      int *all_desc, int extended)\n{\n    int parsed = 0, ret, all_desc_local = 0, first_id_len;\n    const char *first_id;\n\n    assert(id);\n    assert((mod_name && mod_name_len) || (!mod_name && !mod_name_len));\n    assert((name && nam_len) || (!name && !nam_len));\n\n    if (mod_name) {\n        *mod_name = NULL;\n        *mod_name_len = 0;\n    }\n    if (name) {\n        *name = NULL;\n        *nam_len = 0;\n    }\n\n    if (extended) {\n        /* try to parse only the extended expressions */\n        if (id[parsed] == '/') {\n            if (all_desc) {\n                *all_desc = 1;\n            }\n            all_desc_local = 1;\n        } else {\n            if (all_desc) {\n                *all_desc = 0;\n            }\n        }\n\n        /* is there a prefix? */\n        ret = parse_identifier(id + all_desc_local);\n        if (ret > 0) {\n            if (id[all_desc_local + ret] != ':') {\n                /* this is not a prefix, so not an extended id */\n                goto standard_id;\n            }\n\n            if (mod_name) {\n                *mod_name = id + all_desc_local;\n                *mod_name_len = ret;\n            }\n\n            /* \"/\" and \":\" */\n            ret += all_desc_local + 1;\n        } else {\n            ret = all_desc_local;\n        }\n\n        /* parse either \"*\" or \".\" */\n        if (*(id + ret) == '*') {\n            if (name) {\n                *name = id + ret;\n                *nam_len = 1;\n            }\n            ++ret;\n\n            return ret;\n        } else if (*(id + ret) == '.') {\n            if (!all_desc_local) {\n                /* /. is redundant expression, we do not accept it */\n                return -ret;\n            }\n\n            if (name) {\n                *name = id + ret;\n                *nam_len = 1;\n            }\n            ++ret;\n\n            return ret;\n        } else if (*(id + ret) == '#') {\n            if (all_desc_local || !ret) {\n                /* no prefix */\n                return 0;\n            }\n            parsed = ret + 1;\n            if ((ret = parse_identifier(id + parsed)) < 1) {\n                return -parsed + ret;\n            }\n            *name = id + parsed - 1;\n            *nam_len = ret + 1;\n            return parsed + ret;\n        }\n        /* else a standard id, parse it all again */\n    }\n\nstandard_id:\n    if ((ret = parse_identifier(id)) < 1) {\n        return ret;\n    }\n\n    first_id = id;\n    first_id_len = ret;\n\n    parsed += ret;\n    id += ret;\n\n    /* there is prefix */\n    if (id[0] == ':') {\n        ++parsed;\n        ++id;\n\n    /* there isn't */\n    } else {\n        if (name) {\n            *name = first_id;\n            *nam_len = first_id_len;\n        }\n\n        return parsed;\n    }\n\n    /* identifier (node name) */\n    if ((ret = parse_identifier(id)) < 1) {\n        return -parsed + ret;\n    }\n\n    if (mod_name) {\n        *mod_name = first_id;\n        *mod_name_len = first_id_len;\n    }\n    if (name) {\n        *name = id;\n        *nam_len = ret;\n    }\n\n    return parsed + ret;\n}\n\n/**\n * @brief Parse a path-predicate (leafref).\n *\n * path-predicate      = \"[\" *WSP path-equality-expr *WSP \"]\"\n * path-equality-expr  = node-identifier *WSP \"=\" *WSP path-key-expr\n *\n * @param[in] id Identifier to use.\n * @param[out] prefix Points to the prefix, NULL if there is not any.\n * @param[out] pref_len Length of the prefix, 0 if there is not any.\n * @param[out] name Points to the node name.\n * @param[out] nam_len Length of the node name.\n * @param[out] path_key_expr Points to the path-key-expr.\n * @param[out] pke_len Length of the path-key-expr.\n * @param[out] has_predicate Flag to mark whether there is another predicate following.\n *\n * @return Number of characters successfully parsed,\n *         positive on success, negative on failure.\n */\nstatic int\nparse_path_predicate(const char *id, const char **prefix, int *pref_len, const char **name, int *nam_len,\n                     const char **path_key_expr, int *pke_len, int *has_predicate)\n{\n    const char *ptr;\n    int parsed = 0, ret;\n\n    assert(id);\n    if (prefix) {\n        *prefix = NULL;\n    }\n    if (pref_len) {\n        *pref_len = 0;\n    }\n    if (name) {\n        *name = NULL;\n    }\n    if (nam_len) {\n        *nam_len = 0;\n    }\n    if (path_key_expr) {\n        *path_key_expr = NULL;\n    }\n    if (pke_len) {\n        *pke_len = 0;\n    }\n    if (has_predicate) {\n        *has_predicate = 0;\n    }\n\n    if (id[0] != '[') {\n        return -parsed;\n    }\n\n    ++parsed;\n    ++id;\n\n    while (isspace(id[0])) {\n        ++parsed;\n        ++id;\n    }\n\n    if ((ret = parse_node_identifier(id, prefix, pref_len, name, nam_len, NULL, 0)) < 1) {\n        return -parsed+ret;\n    }\n\n    parsed += ret;\n    id += ret;\n\n    while (isspace(id[0])) {\n        ++parsed;\n        ++id;\n    }\n\n    if (id[0] != '=') {\n        return -parsed;\n    }\n\n    ++parsed;\n    ++id;\n\n    while (isspace(id[0])) {\n        ++parsed;\n        ++id;\n    }\n\n    if ((ptr = strchr(id, ']')) == NULL) {\n        return -parsed;\n    }\n\n    --ptr;\n    while (isspace(ptr[0])) {\n        --ptr;\n    }\n    ++ptr;\n\n    ret = ptr-id;\n    if (path_key_expr) {\n        *path_key_expr = id;\n    }\n    if (pke_len) {\n        *pke_len = ret;\n    }\n\n    parsed += ret;\n    id += ret;\n\n    while (isspace(id[0])) {\n        ++parsed;\n        ++id;\n    }\n\n    assert(id[0] == ']');\n\n    if (id[1] == '[') {\n        *has_predicate = 1;\n    }\n\n    return parsed+1;\n}\n\n/**\n * @brief Parse a path-key-expr (leafref). First call parses \"current()\", all\n *        the \"..\" and the first node-identifier, other calls parse a single\n *        node-identifier each.\n *\n * path-key-expr       = current-function-invocation *WSP \"/\" *WSP\n *                       rel-path-keyexpr\n * rel-path-keyexpr    = 1*(\"..\" *WSP \"/\" *WSP)\n *                       *(node-identifier *WSP \"/\" *WSP)\n *                       node-identifier\n *\n * @param[in] id Identifier to use.\n * @param[out] prefix Points to the prefix, NULL if there is not any.\n * @param[out] pref_len Length of the prefix, 0 if there is not any.\n * @param[out] name Points to the node name.\n * @param[out] nam_len Length of the node name.\n * @param[out] parent_times Number of \"..\" in the path. Must be 0 on the first call,\n *                          must not be changed between consecutive calls.\n * @return Number of characters successfully parsed,\n *         positive on success, negative on failure.\n */\nstatic int\nparse_path_key_expr(const char *id, const char **prefix, int *pref_len, const char **name, int *nam_len,\n                    int *parent_times)\n{\n    int parsed = 0, ret, par_times = 0;\n\n    assert(id);\n    assert(parent_times);\n    if (prefix) {\n        *prefix = NULL;\n    }\n    if (pref_len) {\n        *pref_len = 0;\n    }\n    if (name) {\n        *name = NULL;\n    }\n    if (nam_len) {\n        *nam_len = 0;\n    }\n\n    if (!*parent_times) {\n        /* current-function-invocation *WSP \"/\" *WSP rel-path-keyexpr */\n        if (strncmp(id, \"current()\", 9)) {\n            return -parsed;\n        }\n\n        parsed += 9;\n        id += 9;\n\n        while (isspace(id[0])) {\n            ++parsed;\n            ++id;\n        }\n\n        if (id[0] != '/') {\n            return -parsed;\n        }\n\n        ++parsed;\n        ++id;\n\n        while (isspace(id[0])) {\n            ++parsed;\n            ++id;\n        }\n\n        /* rel-path-keyexpr */\n        if (strncmp(id, \"..\", 2)) {\n            return -parsed;\n        }\n        ++par_times;\n\n        parsed += 2;\n        id += 2;\n\n        while (isspace(id[0])) {\n            ++parsed;\n            ++id;\n        }\n    }\n\n    /* 1*(\"..\" *WSP \"/\" *WSP) *(node-identifier *WSP \"/\" *WSP) node-identifier\n     *\n     * first parent reference with whitespaces already parsed\n     */\n    if (id[0] != '/') {\n        return -parsed;\n    }\n\n    ++parsed;\n    ++id;\n\n    while (isspace(id[0])) {\n        ++parsed;\n        ++id;\n    }\n\n    while (!strncmp(id, \"..\", 2) && !*parent_times) {\n        ++par_times;\n\n        parsed += 2;\n        id += 2;\n\n        while (isspace(id[0])) {\n            ++parsed;\n            ++id;\n        }\n\n        if (id[0] != '/') {\n            return -parsed;\n        }\n\n        ++parsed;\n        ++id;\n\n        while (isspace(id[0])) {\n            ++parsed;\n            ++id;\n        }\n    }\n\n    if (!*parent_times) {\n        *parent_times = par_times;\n    }\n\n    /* all parent references must be parsed at this point */\n    if ((ret = parse_node_identifier(id, prefix, pref_len, name, nam_len, NULL, 0)) < 1) {\n        return -parsed + ret;\n    }\n\n    parsed += ret;\n    id += ret;\n\n    return parsed;\n}\n\n/**\n * @brief Parse path-arg (leafref).\n *\n * path-arg            = absolute-path / relative-path\n * absolute-path       = 1*(\"/\" (node-identifier *path-predicate))\n * relative-path       = 1*(\"..\" \"/\") descendant-path\n *\n * @param[in] mod Module of the context node to get correct prefix in case it is not explicitly specified\n * @param[in] id Identifier to use.\n * @param[out] prefix Points to the prefix, NULL if there is not any.\n * @param[out] pref_len Length of the prefix, 0 if there is not any.\n * @param[out] name Points to the node name.\n * @param[out] nam_len Length of the node name.\n * @param[out] parent_times Number of \"..\" in the path. Must be 0 on the first call,\n *                          must not be changed between consecutive calls. -1 if the\n *                          path is relative.\n * @param[out] has_predicate Flag to mark whether there is a predicate specified.\n *\n * @return Number of characters successfully parsed,\n *         positive on success, negative on failure.\n */\nstatic int\nparse_path_arg(const struct lys_module *mod, const char *id, const char **prefix, int *pref_len,\n               const char **name, int *nam_len, int *parent_times, int *has_predicate)\n{\n    int parsed = 0, ret, par_times = 0;\n\n    assert(id);\n    assert(parent_times);\n    if (prefix) {\n        *prefix = NULL;\n    }\n    if (pref_len) {\n        *pref_len = 0;\n    }\n    if (name) {\n        *name = NULL;\n    }\n    if (nam_len) {\n        *nam_len = 0;\n    }\n    if (has_predicate) {\n        *has_predicate = 0;\n    }\n\n    if (!*parent_times && !strncmp(id, \"..\", 2)) {\n        ++par_times;\n\n        parsed += 2;\n        id += 2;\n\n        while (!strncmp(id, \"/..\", 3)) {\n            ++par_times;\n\n            parsed += 3;\n            id += 3;\n        }\n    }\n\n    if (!*parent_times) {\n        if (par_times) {\n            *parent_times = par_times;\n        } else {\n            *parent_times = -1;\n        }\n    }\n\n    if (id[0] != '/') {\n        return -parsed;\n    }\n\n    /* skip '/' */\n    ++parsed;\n    ++id;\n\n    /* node-identifier ([prefix:]identifier) */\n    if ((ret = parse_node_identifier(id, prefix, pref_len, name, nam_len, NULL, 0)) < 1) {\n        return -parsed - ret;\n    }\n    if (prefix && !(*prefix)) {\n        /* actually we always need prefix even it is not specified */\n        *prefix = lys_main_module(mod)->name;\n        *pref_len = strlen(*prefix);\n    }\n\n    parsed += ret;\n    id += ret;\n\n    /* there is no predicate */\n    if ((id[0] == '/') || !id[0]) {\n        return parsed;\n    } else if (id[0] != '[') {\n        return -parsed;\n    }\n\n    if (has_predicate) {\n        *has_predicate = 1;\n    }\n\n    return parsed;\n}\n\n/**\n * @brief Parse instance-identifier in JSON data format. That means that prefixes\n *        are actually model names.\n *\n * instance-identifier = 1*(\"/\" (node-identifier *predicate))\n *\n * @param[in] id Identifier to use.\n * @param[out] model Points to the model name.\n * @param[out] mod_len Length of the model name.\n * @param[out] name Points to the node name.\n * @param[out] nam_len Length of the node name.\n * @param[out] has_predicate Flag to mark whether there is a predicate specified.\n *\n * @return Number of characters successfully parsed,\n *         positive on success, negative on failure.\n */\nstatic int\nparse_instance_identifier(const char *id, const char **model, int *mod_len, const char **name, int *nam_len,\n                          int *has_predicate)\n{\n    int parsed = 0, ret;\n\n    assert(id && model && mod_len && name && nam_len);\n\n    if (has_predicate) {\n        *has_predicate = 0;\n    }\n\n    if (id[0] != '/') {\n        return -parsed;\n    }\n\n    ++parsed;\n    ++id;\n\n    if ((ret = parse_identifier(id)) < 1) {\n        return ret;\n    }\n\n    *name = id;\n    *nam_len = ret;\n\n    parsed += ret;\n    id += ret;\n\n    if (id[0] == ':') {\n        /* we have prefix */\n        *model = *name;\n        *mod_len = *nam_len;\n\n        ++parsed;\n        ++id;\n\n        if ((ret = parse_identifier(id)) < 1) {\n            return ret;\n        }\n\n        *name = id;\n        *nam_len = ret;\n\n        parsed += ret;\n        id += ret;\n    }\n\n    if (id[0] == '[' && has_predicate) {\n        *has_predicate = 1;\n    }\n\n    return parsed;\n}\n\n/**\n * @brief Parse predicate (instance-identifier) in JSON data format. That means that prefixes\n *        (which are mandatory) are actually model names.\n *\n * predicate           = \"[\" *WSP (predicate-expr / pos) *WSP \"]\"\n * predicate-expr      = (node-identifier / \".\") *WSP \"=\" *WSP\n *                       ((DQUOTE string DQUOTE) /\n *                        (SQUOTE string SQUOTE))\n * pos                 = non-negative-integer-value\n *\n * @param[in] id Identifier to use.\n * @param[out] model Points to the model name.\n * @param[out] mod_len Length of the model name.\n * @param[out] name Points to the node name. Can be identifier (from node-identifier), \".\" or pos.\n * @param[out] nam_len Length of the node name.\n * @param[out] value Value the node-identifier must have (string from the grammar),\n *                   NULL if there is not any.\n * @param[out] val_len Length of the value, 0 if there is not any.\n * @param[out] has_predicate Flag to mark whether there is a predicate specified.\n *\n * @return Number of characters successfully parsed,\n *         positive on success, negative on failure.\n */\nstatic int\nparse_predicate(const char *id, const char **model, int *mod_len, const char **name, int *nam_len,\n                const char **value, int *val_len, int *has_predicate)\n{\n    const char *ptr;\n    int parsed = 0, ret;\n    char quote;\n\n    assert(id);\n    if (model) {\n        assert(mod_len);\n        *model = NULL;\n        *mod_len = 0;\n    }\n    if (name) {\n        assert(nam_len);\n        *name = NULL;\n        *nam_len = 0;\n    }\n    if (value) {\n        assert(val_len);\n        *value = NULL;\n        *val_len = 0;\n    }\n    if (has_predicate) {\n        *has_predicate = 0;\n    }\n\n    if (id[0] != '[') {\n        return -parsed;\n    }\n\n    ++parsed;\n    ++id;\n\n    while (isspace(id[0])) {\n        ++parsed;\n        ++id;\n    }\n\n    /* pos */\n    if (isdigit(id[0])) {\n        if (name) {\n            *name = id;\n        }\n\n        if (id[0] == '0') {\n            return -parsed;\n        }\n\n        while (isdigit(id[0])) {\n            ++parsed;\n            ++id;\n        }\n\n        if (nam_len) {\n            *nam_len = id-(*name);\n        }\n\n    /* \".\" or node-identifier */\n    } else {\n        if (id[0] == '.') {\n            if (name) {\n                *name = id;\n            }\n            if (nam_len) {\n                *nam_len = 1;\n            }\n\n            ++parsed;\n            ++id;\n\n        } else {\n            if ((ret = parse_node_identifier(id, model, mod_len, name, nam_len, NULL, 0)) < 1) {\n                return -parsed + ret;\n            }\n\n            parsed += ret;\n            id += ret;\n        }\n\n        while (isspace(id[0])) {\n            ++parsed;\n            ++id;\n        }\n\n        if (id[0] != '=') {\n            return -parsed;\n        }\n\n        ++parsed;\n        ++id;\n\n        while (isspace(id[0])) {\n            ++parsed;\n            ++id;\n        }\n\n        /* ((DQUOTE string DQUOTE) / (SQUOTE string SQUOTE)) */\n        if ((id[0] == '\\\"') || (id[0] == '\\'')) {\n            quote = id[0];\n\n            ++parsed;\n            ++id;\n\n            if ((ptr = strchr(id, quote)) == NULL) {\n                return -parsed;\n            }\n            ret = ptr - id;\n\n            if (value) {\n                *value = id;\n            }\n            if (val_len) {\n                *val_len = ret;\n            }\n\n            parsed += ret + 1;\n            id += ret + 1;\n        } else {\n            return -parsed;\n        }\n    }\n\n    while (isspace(id[0])) {\n        ++parsed;\n        ++id;\n    }\n\n    if (id[0] != ']') {\n        return -parsed;\n    }\n\n    ++parsed;\n    ++id;\n\n    if ((id[0] == '[') && has_predicate) {\n        *has_predicate = 1;\n    }\n\n    return parsed;\n}\n\n/**\n * @brief Parse schema-nodeid.\n *\n * schema-nodeid       = absolute-schema-nodeid /\n *                       descendant-schema-nodeid\n * absolute-schema-nodeid = 1*(\"/\" node-identifier)\n * descendant-schema-nodeid = [\".\" \"/\"]\n *                       node-identifier\n *                       absolute-schema-nodeid\n *\n * @param[in] id Identifier to use.\n * @param[out] mod_name Points to the module name, NULL if there is not any.\n * @param[out] mod_name_len Length of the module name, 0 if there is not any.\n * @param[out] name Points to the node name.\n * @param[out] nam_len Length of the node name.\n * @param[out] is_relative Flag to mark whether the nodeid is absolute or descendant. Must be -1\n *                         on the first call, must not be changed between consecutive calls.\n * @param[out] has_predicate Flag to mark whether there is a predicate specified. It cannot be\n *                           based on the grammar, in those cases use NULL.\n * @param[in] extended Whether to accept an extended path (support for /[prefix:]*, //[prefix:]*, //[prefix:].).\n *\n * @return Number of characters successfully parsed,\n *         positive on success, negative on failure.\n */\nint\nparse_schema_nodeid(const char *id, const char **mod_name, int *mod_name_len, const char **name, int *nam_len,\n                    int *is_relative, int *has_predicate, int *all_desc, int extended)\n{\n    int parsed = 0, ret;\n\n    assert(id);\n    assert(is_relative);\n\n    if (has_predicate) {\n        *has_predicate = 0;\n    }\n\n    if (id[0] != '/') {\n        if (*is_relative != -1) {\n            return -parsed;\n        } else {\n            *is_relative = 1;\n        }\n        if (!strncmp(id, \"./\", 2)) {\n            parsed += 2;\n            id += 2;\n        }\n    } else {\n        if (*is_relative == -1) {\n            *is_relative = 0;\n        }\n        ++parsed;\n        ++id;\n    }\n\n    if ((ret = parse_node_identifier(id, mod_name, mod_name_len, name, nam_len, all_desc, extended)) < 1) {\n        return -parsed + ret;\n    }\n\n    parsed += ret;\n    id += ret;\n\n    if ((id[0] == '[') && has_predicate) {\n        *has_predicate = 1;\n    }\n\n    return parsed;\n}\n\n/**\n * @brief Parse schema predicate (special format internally used).\n *\n * predicate           = \"[\" *WSP predicate-expr *WSP \"]\"\n * predicate-expr      = \".\" / [prefix:]identifier / positive-integer / key-with-value\n * key-with-value      = identifier *WSP \"=\" *WSP\n *                       ((DQUOTE string DQUOTE) /\n *                        (SQUOTE string SQUOTE))\n *\n * @param[in] id Identifier to use.\n * @param[out] mod_name Points to the list key module name.\n * @param[out] mod_name_len Length of \\p mod_name.\n * @param[out] name Points to the list key name.\n * @param[out] nam_len Length of \\p name.\n * @param[out] value Points to the key value. If specified, key-with-value is expected.\n * @param[out] val_len Length of \\p value.\n * @param[out] has_predicate Flag to mark whether there is another predicate specified.\n */\nint\nparse_schema_json_predicate(const char *id, const char **mod_name, int *mod_name_len, const char **name, int *nam_len,\n                            const char **value, int *val_len, int *has_predicate)\n{\n    const char *ptr;\n    int parsed = 0, ret;\n    char quote;\n\n    assert(id);\n    if (mod_name) {\n        *mod_name = NULL;\n    }\n    if (mod_name_len) {\n        *mod_name_len = 0;\n    }\n    if (name) {\n        *name = NULL;\n    }\n    if (nam_len) {\n        *nam_len = 0;\n    }\n    if (value) {\n        *value = NULL;\n    }\n    if (val_len) {\n        *val_len = 0;\n    }\n    if (has_predicate) {\n        *has_predicate = 0;\n    }\n\n    if (id[0] != '[') {\n        return -parsed;\n    }\n\n    ++parsed;\n    ++id;\n\n    while (isspace(id[0])) {\n        ++parsed;\n        ++id;\n    }\n\n    /* identifier */\n    if (id[0] == '.') {\n        ret = 1;\n\n        if (name) {\n            *name = id;\n        }\n        if (nam_len) {\n            *nam_len = ret;\n        }\n    } else if (isdigit(id[0])) {\n        if (id[0] == '0') {\n            return -parsed;\n        }\n        ret = 1;\n        while (isdigit(id[ret])) {\n            ++ret;\n        }\n\n        if (name) {\n            *name = id;\n        }\n        if (nam_len) {\n            *nam_len = ret;\n        }\n    } else if ((ret = parse_node_identifier(id, mod_name, mod_name_len, name, nam_len, NULL, 0)) < 1) {\n        return -parsed + ret;\n    }\n\n    parsed += ret;\n    id += ret;\n\n    while (isspace(id[0])) {\n        ++parsed;\n        ++id;\n    }\n\n    /* there is value as well */\n    if (id[0] == '=') {\n        if (name && isdigit(**name)) {\n            return -parsed;\n        }\n\n        ++parsed;\n        ++id;\n\n        while (isspace(id[0])) {\n            ++parsed;\n            ++id;\n        }\n\n        /* ((DQUOTE string DQUOTE) / (SQUOTE string SQUOTE)) */\n        if ((id[0] == '\\\"') || (id[0] == '\\'')) {\n            quote = id[0];\n\n            ++parsed;\n            ++id;\n\n            if ((ptr = strchr(id, quote)) == NULL) {\n                return -parsed;\n            }\n            ret = ptr - id;\n\n            if (value) {\n                *value = id;\n            }\n            if (val_len) {\n                *val_len = ret;\n            }\n\n            parsed += ret + 1;\n            id += ret + 1;\n        } else {\n            return -parsed;\n        }\n\n        while (isspace(id[0])) {\n            ++parsed;\n            ++id;\n        }\n    }\n\n    if (id[0] != ']') {\n        return -parsed;\n    }\n\n    ++parsed;\n    ++id;\n\n    if ((id[0] == '[') && has_predicate) {\n        *has_predicate = 1;\n    }\n\n    return parsed;\n}\n\n#ifdef LY_ENABLED_CACHE\n\nstatic int\nresolve_hash_table_find_equal(void *val1_p, void *val2_p, int mod, void *UNUSED(cb_data))\n{\n    struct lyd_node *val2, *elem2;\n    struct parsed_pred pp;\n    const char *str;\n    int i;\n\n    assert(!mod);\n    (void)mod;\n\n    pp = *((struct parsed_pred *)val1_p);\n    val2 = *((struct lyd_node **)val2_p);\n\n    if (val2->schema != pp.schema) {\n        return 0;\n    }\n\n    switch (val2->schema->nodetype) {\n    case LYS_CONTAINER:\n    case LYS_LEAF:\n    case LYS_ANYXML:\n    case LYS_ANYDATA:\n        return 1;\n    case LYS_LEAFLIST:\n        str = ((struct lyd_node_leaf_list *)val2)->value_str;\n        if (!strncmp(str, pp.pred[0].value, pp.pred[0].val_len) && !str[pp.pred[0].val_len]) {\n            return 1;\n        }\n        return 0;\n    case LYS_LIST:\n        assert(((struct lys_node_list *)val2->schema)->keys_size);\n        assert(((struct lys_node_list *)val2->schema)->keys_size == pp.len);\n\n        /* lists with keys, their equivalence is based on their keys */\n        elem2 = val2->child;\n        /* the exact data order is guaranteed */\n        for (i = 0; elem2 && (i < pp.len); ++i) {\n            /* module check */\n            if (pp.pred[i].mod_name) {\n                if (strncmp(lyd_node_module(elem2)->name, pp.pred[i].mod_name, pp.pred[i].mod_name_len)\n                        || lyd_node_module(elem2)->name[pp.pred[i].mod_name_len]) {\n                    break;\n                }\n            } else {\n                if (lyd_node_module(elem2) != lys_node_module(pp.schema)) {\n                    break;\n                }\n            }\n\n            /* name check */\n            if (strncmp(elem2->schema->name, pp.pred[i].name, pp.pred[i].nam_len) || elem2->schema->name[pp.pred[i].nam_len]) {\n                break;\n            }\n\n            /* value check */\n            str = ((struct lyd_node_leaf_list *)elem2)->value_str;\n            if (strncmp(str, pp.pred[i].value, pp.pred[i].val_len) || str[pp.pred[i].val_len]) {\n                break;\n            }\n\n            /* next key */\n            elem2 = elem2->next;\n        }\n        if (i == pp.len) {\n            return 1;\n        }\n        return 0;\n    default:\n        break;\n    }\n\n    LOGINT(val2->schema->module->ctx);\n    return 0;\n}\n\nstatic struct lyd_node *\nresolve_json_data_node_hash(struct lyd_node *parent, struct parsed_pred pp)\n{\n    values_equal_cb prev_cb;\n    struct lyd_node **ret = NULL;\n    uint32_t hash;\n    int i;\n\n    assert(parent && parent->hash);\n\n    /* set our value equivalence callback that does not require data nodes */\n    prev_cb = lyht_set_cb(parent->ht, resolve_hash_table_find_equal);\n\n    /* get the hash of the searched node */\n    hash = dict_hash_multi(0, lys_node_module(pp.schema)->name, strlen(lys_node_module(pp.schema)->name));\n    hash = dict_hash_multi(hash, pp.schema->name, strlen(pp.schema->name));\n    if (pp.schema->nodetype == LYS_LEAFLIST) {\n        assert((pp.len == 1) && (pp.pred[0].name[0] == '.') && (pp.pred[0].nam_len == 1));\n        /* leaf-list value in predicate */\n        hash = dict_hash_multi(hash, pp.pred[0].value, pp.pred[0].val_len);\n    } else if (pp.schema->nodetype == LYS_LIST) {\n        /* list keys in predicates */\n        for (i = 0; i < pp.len; ++i) {\n            hash = dict_hash_multi(hash, pp.pred[i].value, pp.pred[i].val_len);\n        }\n    }\n    hash = dict_hash_multi(hash, NULL, 0);\n\n    /* try to find the node */\n    i = lyht_find(parent->ht, &pp, hash, (void **)&ret);\n    assert(i || *ret);\n\n    /* restore the original callback */\n    lyht_set_cb(parent->ht, prev_cb);\n\n    return (i ? NULL : *ret);\n}\n\n#endif\n\n/**\n * @brief Resolve (find) a feature definition. Logs directly.\n *\n * @param[in] feat_name Feature name to resolve.\n * @param[in] len Length of \\p feat_name.\n * @param[in] node Node with the if-feature expression.\n * @param[out] feature Pointer to be set to point to the feature definition, if feature not found\n * (return code 1), the pointer is untouched.\n *\n * @return 0 on success, 1 on forward reference, -1 on error.\n */\nstatic int\nresolve_feature(const char *feat_name, uint16_t len, const struct lys_node *node, struct lys_feature **feature)\n{\n    char *str;\n    const char *mod_name, *name;\n    int mod_name_len, nam_len, i, j;\n    const struct lys_module *module;\n\n    assert(feature);\n\n    /* check prefix */\n    if ((i = parse_node_identifier(feat_name, &mod_name, &mod_name_len, &name, &nam_len, NULL, 0)) < 1) {\n        LOGVAL(node->module->ctx, LYE_INCHAR, LY_VLOG_NONE, NULL, feat_name[-i], &feat_name[-i]);\n        return -1;\n    }\n\n    module = lyp_get_module(lys_node_module(node), NULL, 0, mod_name, mod_name_len, 0);\n    if (!module) {\n        /* identity refers unknown data model */\n        LOGVAL(node->module->ctx, LYE_INMOD_LEN, LY_VLOG_NONE, NULL, mod_name_len, mod_name);\n        return -1;\n    }\n\n    if (module != node->module && module == lys_node_module(node)) {\n        /* first, try to search directly in submodule where the feature was mentioned */\n        for (j = 0; j < node->module->features_size; j++) {\n            if (!strncmp(name, node->module->features[j].name, nam_len) && !node->module->features[j].name[nam_len]) {\n                /* check status */\n                if (lyp_check_status(node->flags, lys_node_module(node), node->name, node->module->features[j].flags,\n                                     node->module->features[j].module, node->module->features[j].name, NULL)) {\n                    return -1;\n                }\n                *feature = &node->module->features[j];\n                return 0;\n            }\n        }\n    }\n\n    /* search in the identified module ... */\n    for (j = 0; j < module->features_size; j++) {\n        if (!strncmp(name, module->features[j].name, nam_len) && !module->features[j].name[nam_len]) {\n            /* check status */\n            if (lyp_check_status(node->flags, lys_node_module(node), node->name, module->features[j].flags,\n                                 module->features[j].module, module->features[j].name, NULL)) {\n                return -1;\n            }\n            *feature = &module->features[j];\n            return 0;\n        }\n    }\n    /* ... and all its submodules */\n    for (i = 0; i < module->inc_size && module->inc[i].submodule; i++) {\n        for (j = 0; j < module->inc[i].submodule->features_size; j++) {\n            if (!strncmp(name, module->inc[i].submodule->features[j].name, nam_len)\n                    && !module->inc[i].submodule->features[j].name[nam_len]) {\n                /* check status */\n                if (lyp_check_status(node->flags, lys_node_module(node), node->name,\n                                     module->inc[i].submodule->features[j].flags,\n                                     module->inc[i].submodule->features[j].module,\n                                     module->inc[i].submodule->features[j].name, NULL)) {\n                    return -1;\n                }\n                *feature = &module->inc[i].submodule->features[j];\n                return 0;\n            }\n        }\n    }\n\n    /* not found */\n    str = strndup(feat_name, len);\n    LOGVAL(node->module->ctx, LYE_INRESOLV, LY_VLOG_NONE, NULL, \"feature\", str);\n    free(str);\n    return 1;\n}\n\n/*\n * @return\n *  -  1 if enabled\n *  -  0 if disabled\n */\nstatic int\nresolve_feature_value(const struct lys_feature *feat)\n{\n    int i;\n\n    for (i = 0; i < feat->iffeature_size; i++) {\n        if (!resolve_iffeature(&feat->iffeature[i])) {\n            return 0;\n        }\n    }\n\n    return feat->flags & LYS_FENABLED ? 1 : 0;\n}\n\nstatic int\nresolve_iffeature_recursive(struct lys_iffeature *expr, int *index_e, int *index_f)\n{\n    uint8_t op;\n    int a, b;\n\n    op = iff_getop(expr->expr, *index_e);\n    (*index_e)++;\n\n    switch (op) {\n    case LYS_IFF_F:\n        /* resolve feature */\n        return resolve_feature_value(expr->features[(*index_f)++]);\n    case LYS_IFF_NOT:\n        /* invert result */\n        return resolve_iffeature_recursive(expr, index_e, index_f) ? 0 : 1;\n    case LYS_IFF_AND:\n    case LYS_IFF_OR:\n        a = resolve_iffeature_recursive(expr, index_e, index_f);\n        b = resolve_iffeature_recursive(expr, index_e, index_f);\n        if (op == LYS_IFF_AND) {\n            return a && b;\n        } else { /* LYS_IFF_OR */\n            return a || b;\n        }\n    }\n\n    return 0;\n}\n\nint\nresolve_iffeature(struct lys_iffeature *expr)\n{\n    int index_e = 0, index_f = 0;\n\n    if (expr->expr) {\n        return resolve_iffeature_recursive(expr, &index_e, &index_f);\n    }\n    return 0;\n}\n\nstruct iff_stack {\n    int size;\n    int index;     /* first empty item */\n    uint8_t *stack;\n};\n\nstatic int\niff_stack_push(struct iff_stack *stack, uint8_t value)\n{\n    if (stack->index == stack->size) {\n        stack->size += 4;\n        stack->stack = ly_realloc(stack->stack, stack->size * sizeof *stack->stack);\n        LY_CHECK_ERR_RETURN(!stack->stack, LOGMEM(NULL); stack->size = 0, EXIT_FAILURE);\n    }\n\n    stack->stack[stack->index++] = value;\n    return EXIT_SUCCESS;\n}\n\nstatic uint8_t\niff_stack_pop(struct iff_stack *stack)\n{\n    stack->index--;\n    return stack->stack[stack->index];\n}\n\nstatic void\niff_stack_clean(struct iff_stack *stack)\n{\n    stack->size = 0;\n    free(stack->stack);\n}\n\nstatic void\niff_setop(uint8_t *list, uint8_t op, int pos)\n{\n    uint8_t *item;\n    uint8_t mask = 3;\n\n    assert(pos >= 0);\n    assert(op <= 3); /* max 2 bits */\n\n    item = &list[pos / 4];\n    mask = mask << 2 * (pos % 4);\n    *item = (*item) & ~mask;\n    *item = (*item) | (op << 2 * (pos % 4));\n}\n\nuint8_t\niff_getop(uint8_t *list, int pos)\n{\n    uint8_t *item;\n    uint8_t mask = 3, result;\n\n    assert(pos >= 0);\n\n    item = &list[pos / 4];\n    result = (*item) & (mask << 2 * (pos % 4));\n    return result >> 2 * (pos % 4);\n}\n\n#define LYS_IFF_LP 0x04 /* ( */\n#define LYS_IFF_RP 0x08 /* ) */\n\n/* internal structure for passing data for UNRES_IFFEAT */\nstruct unres_iffeat_data {\n    struct lys_node *node;\n    const char *fname;\n    int infeature;\n};\n\nvoid\nresolve_iffeature_getsizes(struct lys_iffeature *iffeat, unsigned int *expr_size, unsigned int *feat_size)\n{\n    unsigned int e = 0, f = 0, r = 0;\n    uint8_t op;\n\n    assert(iffeat);\n\n    if (!iffeat->expr) {\n        goto result;\n    }\n\n    do {\n        op = iff_getop(iffeat->expr, e++);\n        switch (op) {\n        case LYS_IFF_NOT:\n            if (!r) {\n                r += 1;\n            }\n            break;\n        case LYS_IFF_AND:\n        case LYS_IFF_OR:\n            if (!r) {\n                r += 2;\n            } else {\n                r += 1;\n            }\n            break;\n        case LYS_IFF_F:\n            f++;\n            if (r) {\n                r--;\n            }\n            break;\n        }\n    } while(r);\n\nresult:\n    if (expr_size) {\n        *expr_size = e;\n    }\n    if (feat_size) {\n        *feat_size = f;\n    }\n}\n\nint\nresolve_iffeature_compile(struct lys_iffeature *iffeat_expr, const char *value, struct lys_node *node,\n                          int infeature, struct unres_schema *unres)\n{\n    const char *c = value;\n    int r, rc = EXIT_FAILURE;\n    int i, j, last_not, checkversion = 0;\n    unsigned int f_size = 0, expr_size = 0, f_exp = 1;\n    uint8_t op;\n    struct iff_stack stack = {0, 0, NULL};\n    struct unres_iffeat_data *iff_data;\n    struct ly_ctx *ctx = node->module->ctx;\n\n    assert(c);\n\n    if (isspace(c[0])) {\n        LOGVAL(ctx, LYE_INCHAR, LY_VLOG_NONE, NULL, c[0], c);\n        return EXIT_FAILURE;\n    }\n\n    /* pre-parse the expression to get sizes for arrays, also do some syntax checks of the expression */\n    for (i = j = last_not = 0; c[i]; i++) {\n        if (c[i] == '(') {\n            checkversion = 1;\n            j++;\n            continue;\n        } else if (c[i] == ')') {\n            j--;\n            continue;\n        } else if (isspace(c[i])) {\n            continue;\n        }\n\n        if (!strncmp(&c[i], \"not\", r = 3) || !strncmp(&c[i], \"and\", r = 3) || !strncmp(&c[i], \"or\", r = 2)) {\n            if (c[i + r] == '\\0') {\n                LOGVAL(ctx, LYE_INARG, LY_VLOG_NONE, NULL, value, \"if-feature\");\n                return EXIT_FAILURE;\n            } else if (!isspace(c[i + r])) {\n                /* feature name starting with the not/and/or */\n                last_not = 0;\n                f_size++;\n            } else if (c[i] == 'n') { /* not operation */\n                if (last_not) {\n                    /* double not */\n                    expr_size = expr_size - 2;\n                    last_not = 0;\n                } else {\n                    last_not = 1;\n                }\n            } else { /* and, or */\n                f_exp++;\n                /* not a not operation */\n                last_not = 0;\n            }\n            i += r;\n        } else {\n            f_size++;\n            last_not = 0;\n        }\n        expr_size++;\n\n        while (!isspace(c[i])) {\n            if (c[i] == '(') {\n                LOGVAL(ctx, LYE_INARG, LY_VLOG_NONE, NULL, value, \"if-feature\");\n                return EXIT_FAILURE;\n            } else if (!c[i] || c[i] == ')') {\n                i--;\n                break;\n            }\n            i++;\n        }\n    }\n    if (j || f_exp != f_size) {\n        /* not matching count of ( and ) */\n        LOGVAL(ctx, LYE_INARG, LY_VLOG_NONE, NULL, value, \"if-feature\");\n        return EXIT_FAILURE;\n    }\n\n    if (checkversion || expr_size > 1) {\n        /* check that we have 1.1 module */\n        if (node->module->version != LYS_VERSION_1_1) {\n            LOGVAL(ctx, LYE_INARG, LY_VLOG_NONE, NULL, value, \"if-feature\");\n            LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"YANG 1.1 if-feature expression found in 1.0 module.\");\n            return EXIT_FAILURE;\n        }\n    }\n\n    /* allocate the memory */\n    iffeat_expr->expr = calloc((j = (expr_size / 4) + ((expr_size % 4) ? 1 : 0)), sizeof *iffeat_expr->expr);\n    iffeat_expr->features = calloc(f_size, sizeof *iffeat_expr->features);\n    stack.stack = malloc(expr_size * sizeof *stack.stack);\n    LY_CHECK_ERR_GOTO(!stack.stack || !iffeat_expr->expr || !iffeat_expr->features, LOGMEM(ctx), error);\n    stack.size = expr_size;\n    f_size--; expr_size--; /* used as indexes from now */\n\n    for (i--; i >= 0; i--) {\n        if (c[i] == ')') {\n            /* push it on stack */\n            iff_stack_push(&stack, LYS_IFF_RP);\n            continue;\n        } else if (c[i] == '(') {\n            /* pop from the stack into result all operators until ) */\n            while((op = iff_stack_pop(&stack)) != LYS_IFF_RP) {\n                iff_setop(iffeat_expr->expr, op, expr_size--);\n            }\n            continue;\n        } else if (isspace(c[i])) {\n            continue;\n        }\n\n        /* end operator or operand -> find beginning and get what is it */\n        j = i + 1;\n        while (i >= 0 && !isspace(c[i]) && c[i] != '(') {\n            i--;\n        }\n        i++; /* get back by one step */\n\n        if (!strncmp(&c[i], \"not\", 3) && isspace(c[i + 3])) {\n            if (stack.index && stack.stack[stack.index - 1] == LYS_IFF_NOT) {\n                /* double not */\n                iff_stack_pop(&stack);\n            } else {\n                /* not has the highest priority, so do not pop from the stack\n                 * as in case of AND and OR */\n                iff_stack_push(&stack, LYS_IFF_NOT);\n            }\n        } else if (!strncmp(&c[i], \"and\", 3) && isspace(c[i + 3])) {\n            /* as for OR - pop from the stack all operators with the same or higher\n             * priority and store them to the result, then push the AND to the stack */\n            while (stack.index && stack.stack[stack.index - 1] <= LYS_IFF_AND) {\n                op = iff_stack_pop(&stack);\n                iff_setop(iffeat_expr->expr, op, expr_size--);\n            }\n            iff_stack_push(&stack, LYS_IFF_AND);\n        } else if (!strncmp(&c[i], \"or\", 2) && isspace(c[i + 2])) {\n            while (stack.index && stack.stack[stack.index - 1] <= LYS_IFF_OR) {\n                op = iff_stack_pop(&stack);\n                iff_setop(iffeat_expr->expr, op, expr_size--);\n            }\n            iff_stack_push(&stack, LYS_IFF_OR);\n        } else {\n            /* feature name, length is j - i */\n\n            /* add it to the result */\n            iff_setop(iffeat_expr->expr, LYS_IFF_F, expr_size--);\n\n            /* now get the link to the feature definition. Since it can be\n             * forward referenced, we have to keep the feature name in auxiliary\n             * structure passed into unres */\n            iff_data = malloc(sizeof *iff_data);\n            LY_CHECK_ERR_GOTO(!iff_data, LOGMEM(ctx), error);\n            iff_data->node = node;\n            iff_data->fname = lydict_insert(node->module->ctx, &c[i], j - i);\n            iff_data->infeature = infeature;\n            r = unres_schema_add_node(node->module, unres, &iffeat_expr->features[f_size], UNRES_IFFEAT,\n                                      (struct lys_node *)iff_data);\n            f_size--;\n\n            if (r == -1) {\n                lydict_remove(node->module->ctx, iff_data->fname);\n                free(iff_data);\n                goto error;\n            }\n        }\n    }\n    while (stack.index) {\n        op = iff_stack_pop(&stack);\n        iff_setop(iffeat_expr->expr, op, expr_size--);\n    }\n\n    if (++expr_size || ++f_size) {\n        /* not all expected operators and operands found */\n        LOGVAL(ctx, LYE_INARG, LY_VLOG_NONE, NULL, value, \"if-feature\");\n        rc = EXIT_FAILURE;\n    } else {\n        rc = EXIT_SUCCESS;\n    }\n\nerror:\n    /* cleanup */\n    iff_stack_clean(&stack);\n\n    return rc;\n}\n\n/**\n * @brief Resolve (find) a data node based on a schema-nodeid.\n *\n * Used for resolving unique statements - so id is expected to be relative and local (without reference to a different\n * module).\n *\n */\nstruct lyd_node *\nresolve_data_descendant_schema_nodeid(const char *nodeid, struct lyd_node *start)\n{\n    char *str, *token, *p;\n    struct lyd_node *result = NULL, *iter;\n    const struct lys_node *schema = NULL;\n\n    assert(nodeid && start);\n\n    if (nodeid[0] == '/') {\n        return NULL;\n    }\n\n    str = p = strdup(nodeid);\n    LY_CHECK_ERR_RETURN(!str, LOGMEM(start->schema->module->ctx), NULL);\n\n    while (p) {\n        token = p;\n        p = strchr(p, '/');\n        if (p) {\n            *p = '\\0';\n            p++;\n        }\n\n        if (p) {\n            /* inner node */\n            if (resolve_descendant_schema_nodeid(token, schema ? schema->child : start->schema,\n                                                 LYS_CONTAINER | LYS_CHOICE | LYS_CASE | LYS_LEAF, 0, &schema)\n                    || !schema) {\n                result = NULL;\n                break;\n            }\n\n            if (schema->nodetype & (LYS_CHOICE | LYS_CASE)) {\n                continue;\n            }\n        } else {\n            /* final node */\n            if (resolve_descendant_schema_nodeid(token, schema ? schema->child : start->schema, LYS_LEAF, 0, &schema)\n                    || !schema) {\n                result = NULL;\n                break;\n            }\n        }\n        LY_TREE_FOR(result ? result->child : start, iter) {\n            if (iter->schema == schema) {\n                /* move in data tree according to returned schema */\n                result = iter;\n                break;\n            }\n        }\n        if (!iter) {\n            /* instance not found */\n            result = NULL;\n            break;\n        }\n    }\n    free(str);\n\n    return result;\n}\n\nint\nschema_nodeid_siblingcheck(const struct lys_node *sibling, const struct lys_module *cur_module, const char *mod_name,\n                           int mod_name_len, const char *name, int nam_len)\n{\n    const struct lys_module *prefix_mod;\n\n    /* handle special names */\n    if (name[0] == '*') {\n        return 2;\n    } else if (name[0] == '.') {\n        return 3;\n    }\n\n    /* name check */\n    if (strncmp(name, sibling->name, nam_len) || sibling->name[nam_len]) {\n        return 1;\n    }\n\n    /* module check */\n    if (mod_name) {\n        prefix_mod = lyp_get_module(cur_module, NULL, 0, mod_name, mod_name_len, 0);\n        if (!prefix_mod) {\n            return -1;\n        }\n    } else {\n        prefix_mod = cur_module;\n    }\n    if (prefix_mod != lys_node_module(sibling)) {\n        return 1;\n    }\n\n    /* match */\n    return 0;\n}\n\n/* keys do not have to be ordered and do not have to be all of them */\nstatic int\nresolve_extended_schema_nodeid_predicate(const char *nodeid, const struct lys_node *node,\n                                         const struct lys_module *cur_module, int *nodeid_end)\n{\n    int mod_len, nam_len, has_predicate, r, i;\n    const char *model, *name;\n    struct lys_node_list *list;\n\n    if (!(node->nodetype & (LYS_LIST | LYS_LEAFLIST))) {\n        return 1;\n    }\n\n    list = (struct lys_node_list *)node;\n    do {\n        r = parse_schema_json_predicate(nodeid, &model, &mod_len, &name, &nam_len, NULL, NULL, &has_predicate);\n        if (r < 1) {\n            LOGVAL(cur_module->ctx, LYE_PATH_INCHAR, LY_VLOG_NONE, NULL, nodeid[r], &nodeid[r]);\n            return -1;\n        }\n        nodeid += r;\n\n        if (node->nodetype == LYS_LEAFLIST) {\n            /* just check syntax */\n            if (model || !name || (name[0] != '.') || has_predicate) {\n                return 1;\n            }\n            break;\n        } else {\n            /* check the key */\n            for (i = 0; i < list->keys_size; ++i) {\n                if (strncmp(list->keys[i]->name, name, nam_len) || list->keys[i]->name[nam_len]) {\n                    continue;\n                }\n                if (model) {\n                    if (strncmp(lys_node_module((struct lys_node *)list->keys[i])->name, model, mod_len)\n                            || lys_node_module((struct lys_node *)list->keys[i])->name[mod_len]) {\n                        continue;\n                    }\n                } else {\n                    if (lys_node_module((struct lys_node *)list->keys[i]) != cur_module) {\n                        continue;\n                    }\n                }\n\n                /* match */\n                break;\n            }\n\n            if (i == list->keys_size) {\n                return 1;\n            }\n        }\n    } while (has_predicate);\n\n    if (!nodeid[0]) {\n        *nodeid_end = 1;\n    }\n    return 0;\n}\n\n/* start_parent - relative, module - absolute, -1 error (logged), EXIT_SUCCESS ok\n */\nint\nresolve_schema_nodeid(const char *nodeid, const struct lys_node *start_parent, const struct lys_module *cur_module,\n                      struct ly_set **ret, int extended, int no_node_error)\n{\n    const char *name, *mod_name, *id, *backup_mod_name = NULL, *yang_data_name = NULL;\n    const struct lys_node *sibling, *next, *elem;\n    struct lys_node_augment *last_aug;\n    int r, nam_len, mod_name_len = 0, is_relative = -1, all_desc, has_predicate, nodeid_end = 0;\n    int yang_data_name_len, backup_mod_name_len = 0;\n    /* resolved import module from the start module, it must match the next node-name-match sibling */\n    const struct lys_module *start_mod, *aux_mod = NULL;\n    char *str;\n    struct ly_ctx *ctx;\n\n    assert(nodeid && (start_parent || cur_module) && ret);\n    *ret = NULL;\n\n    if (!cur_module) {\n        cur_module = lys_node_module(start_parent);\n    }\n    ctx = cur_module->ctx;\n    id = nodeid;\n\n    r = parse_schema_nodeid(id, &mod_name, &mod_name_len, &name, &nam_len, &is_relative, NULL, NULL, 1);\n    if (r < 1) {\n        LOGVAL(ctx, LYE_PATH_INCHAR, LY_VLOG_NONE, NULL, id[r], &id[r]);\n        return -1;\n    }\n\n    if (name[0] == '#') {\n        if (is_relative) {\n            LOGVAL(ctx, LYE_PATH_INCHAR, LY_VLOG_NONE, NULL, '#', name);\n            return -1;\n        }\n        yang_data_name = name + 1;\n        yang_data_name_len = nam_len - 1;\n        backup_mod_name = mod_name;\n        backup_mod_name_len = mod_name_len;\n        id += r;\n    } else {\n        is_relative = -1;\n    }\n\n    r = parse_schema_nodeid(id, &mod_name, &mod_name_len, &name, &nam_len, &is_relative, &has_predicate,\n                            (extended ? &all_desc : NULL), extended);\n    if (r < 1) {\n        LOGVAL(ctx, LYE_PATH_INCHAR, LY_VLOG_NONE, NULL, id[r], &id[r]);\n        return -1;\n    }\n    id += r;\n\n    if (backup_mod_name) {\n        mod_name = backup_mod_name;\n        mod_name_len = backup_mod_name_len;\n    }\n\n    if (is_relative && !start_parent) {\n        LOGVAL(ctx, LYE_SPEC, LY_VLOG_STR, nodeid, \"Starting node must be provided for relative paths.\");\n        return -1;\n    }\n\n    /* descendant-schema-nodeid */\n    if (is_relative) {\n        cur_module = start_mod = lys_node_module(start_parent);\n\n    /* absolute-schema-nodeid */\n    } else {\n        start_mod = lyp_get_module(cur_module, NULL, 0, mod_name, mod_name_len, 0);\n        if (!start_mod) {\n            str = strndup(mod_name, mod_name_len);\n            LOGVAL(ctx, LYE_PATH_INMOD, LY_VLOG_STR, str);\n            free(str);\n            return -1;\n        }\n        start_parent = NULL;\n        if (yang_data_name) {\n            start_parent = lyp_get_yang_data_template(start_mod, yang_data_name, yang_data_name_len);\n            if (!start_parent) {\n                str = strndup(nodeid, (yang_data_name + yang_data_name_len) - nodeid);\n                LOGVAL(ctx, LYE_PATH_INNODE, LY_VLOG_STR, str);\n                free(str);\n                return -1;\n            }\n        }\n    }\n\n    while (1) {\n        sibling = NULL;\n        last_aug = NULL;\n\n        if (start_parent) {\n            if (mod_name && (strncmp(mod_name, cur_module->name, mod_name_len)\n                    || (mod_name_len != (signed)strlen(cur_module->name)))) {\n                /* we are getting into another module (augment) */\n                aux_mod = lyp_get_module(cur_module, NULL, 0, mod_name, mod_name_len, 0);\n                if (!aux_mod) {\n                    str = strndup(mod_name, mod_name_len);\n                    LOGVAL(ctx, LYE_PATH_INMOD, LY_VLOG_STR, str);\n                    free(str);\n                    return -1;\n                }\n            } else {\n                /* there is no mod_name, so why are we checking augments again?\n                 * because this module may be not implemented and it augments something in another module and\n                 * there is another augment augmenting that previous one */\n                aux_mod = cur_module;\n            }\n\n            /* look into augments */\n            if (!extended) {\nget_next_augment:\n                last_aug = lys_getnext_target_aug(last_aug, aux_mod, start_parent);\n            }\n        }\n\n        while ((sibling = lys_getnext(sibling, (last_aug ? (struct lys_node *)last_aug : start_parent), start_mod,\n                LYS_GETNEXT_WITHCHOICE | LYS_GETNEXT_WITHCASE | LYS_GETNEXT_WITHINOUT | LYS_GETNEXT_PARENTUSES | LYS_GETNEXT_NOSTATECHECK))) {\n            r = schema_nodeid_siblingcheck(sibling, cur_module, mod_name, mod_name_len, name, nam_len);\n\n            /* resolve predicate */\n            if (extended && ((r == 0) || (r == 2) || (r == 3)) && has_predicate) {\n                r = resolve_extended_schema_nodeid_predicate(id, sibling, cur_module, &nodeid_end);\n                if (r == 1) {\n                    continue;\n                } else if (r == -1) {\n                    return -1;\n                }\n            } else if (!id[0]) {\n                nodeid_end = 1;\n            }\n\n            if (r == 0) {\n                /* one matching result */\n                if (nodeid_end) {\n                    *ret = ly_set_new();\n                    LY_CHECK_ERR_RETURN(!*ret, LOGMEM(ctx), -1);\n                    ly_set_add(*ret, (void *)sibling, LY_SET_OPT_USEASLIST);\n                } else {\n                    if (sibling->nodetype & (LYS_LEAF | LYS_LEAFLIST | LYS_ANYDATA)) {\n                        return -1;\n                    }\n                    start_parent = sibling;\n                }\n                break;\n            } else if (r == 1) {\n                continue;\n            } else if (r == 2) {\n                /* \"*\" */\n                if (!*ret) {\n                    *ret = ly_set_new();\n                    LY_CHECK_ERR_RETURN(!*ret, LOGMEM(ctx), -1);\n                }\n                ly_set_add(*ret, (void *)sibling, LY_SET_OPT_USEASLIST);\n                if (all_desc) {\n                    LY_TREE_DFS_BEGIN(sibling, next, elem) {\n                        if (elem != sibling) {\n                            ly_set_add(*ret, (void *)elem, LY_SET_OPT_USEASLIST);\n                        }\n\n                        LY_TREE_DFS_END(sibling, next, elem);\n                    }\n                }\n            } else if (r == 3) {\n                /* \".\" */\n                if (!*ret) {\n                    *ret = ly_set_new();\n                    LY_CHECK_ERR_RETURN(!*ret, LOGMEM(ctx), -1);\n                    ly_set_add(*ret, (void *)start_parent, LY_SET_OPT_USEASLIST);\n                }\n                ly_set_add(*ret, (void *)sibling, LY_SET_OPT_USEASLIST);\n                if (all_desc) {\n                    LY_TREE_DFS_BEGIN(sibling, next, elem) {\n                        if (elem != sibling) {\n                            ly_set_add(*ret, (void *)elem, LY_SET_OPT_USEASLIST);\n                        }\n\n                        LY_TREE_DFS_END(sibling, next, elem);\n                    }\n                }\n            } else {\n                LOGINT(ctx);\n                return -1;\n            }\n        }\n\n        /* skip predicate */\n        if (extended && has_predicate) {\n            while (id[0] == '[') {\n                id = strchr(id, ']');\n                if (!id) {\n                    LOGINT(ctx);\n                    return -1;\n                }\n                ++id;\n            }\n        }\n\n        if (nodeid_end && ((r == 0) || (r == 2) || (r == 3))) {\n            return EXIT_SUCCESS;\n        }\n\n        /* no match */\n        if (!sibling) {\n            if (last_aug) {\n                /* it still could be in another augment */\n                goto get_next_augment;\n            }\n            if (no_node_error) {\n                str = strndup(nodeid, (name - nodeid) + nam_len);\n                LOGVAL(ctx, LYE_PATH_INNODE, LY_VLOG_STR, str);\n                free(str);\n                return -1;\n            }\n            *ret = NULL;\n            return EXIT_SUCCESS;\n        }\n\n        r = parse_schema_nodeid(id, &mod_name, &mod_name_len, &name, &nam_len, &is_relative, &has_predicate,\n                                (extended ? &all_desc : NULL), extended);\n        if (r < 1) {\n            LOGVAL(ctx, LYE_PATH_INCHAR, LY_VLOG_NONE, NULL, id[r], &id[r]);\n            return -1;\n        }\n        id += r;\n    }\n\n    /* cannot get here */\n    LOGINT(ctx);\n    return -1;\n}\n\n/* unique, refine,\n * >0  - unexpected char on position (ret - 1),\n *  0  - ok (but ret can still be NULL),\n * -1  - error,\n * -2  - violated no_innerlist  */\nint\nresolve_descendant_schema_nodeid(const char *nodeid, const struct lys_node *start, int ret_nodetype,\n                                 int no_innerlist, const struct lys_node **ret)\n{\n    const char *name, *mod_name, *id;\n    const struct lys_node *sibling, *start_parent;\n    int r, nam_len, mod_name_len, is_relative = -1;\n    /* resolved import module from the start module, it must match the next node-name-match sibling */\n    const struct lys_module *module;\n\n    assert(nodeid && ret);\n    assert(!(ret_nodetype & (LYS_USES | LYS_AUGMENT | LYS_GROUPING)));\n\n    if (!start) {\n        /* leaf not found */\n        return 0;\n    }\n\n    id = nodeid;\n    module = lys_node_module(start);\n\n    if ((r = parse_schema_nodeid(id, &mod_name, &mod_name_len, &name, &nam_len, &is_relative, NULL, NULL, 0)) < 1) {\n        return ((id - nodeid) - r) + 1;\n    }\n    id += r;\n\n    if (!is_relative) {\n        return -1;\n    }\n\n    start_parent = lys_parent(start);\n    while ((start_parent->nodetype == LYS_USES) && lys_parent(start_parent)) {\n        start_parent = lys_parent(start_parent);\n    }\n\n    while (1) {\n        sibling = NULL;\n        while ((sibling = lys_getnext(sibling, start_parent, module,\n                LYS_GETNEXT_WITHCHOICE | LYS_GETNEXT_WITHCASE | LYS_GETNEXT_PARENTUSES | LYS_GETNEXT_NOSTATECHECK))) {\n            r = schema_nodeid_siblingcheck(sibling, module, mod_name, mod_name_len, name, nam_len);\n            if (r == 0) {\n                if (!id[0]) {\n                    if (!(sibling->nodetype & ret_nodetype)) {\n                        /* wrong node type, too bad */\n                        continue;\n                    }\n                    *ret = sibling;\n                    return EXIT_SUCCESS;\n                }\n                start_parent = sibling;\n                break;\n            } else if (r == 1) {\n                continue;\n            } else {\n                return -1;\n            }\n        }\n\n        /* no match */\n        if (!sibling) {\n            *ret = NULL;\n            return EXIT_SUCCESS;\n        } else if (no_innerlist && sibling->nodetype == LYS_LIST) {\n            *ret = NULL;\n            return -2;\n        }\n\n        if ((r = parse_schema_nodeid(id, &mod_name, &mod_name_len, &name, &nam_len, &is_relative, NULL, NULL, 0)) < 1) {\n            return ((id - nodeid) - r) + 1;\n        }\n        id += r;\n    }\n\n    /* cannot get here */\n    LOGINT(module->ctx);\n    return -1;\n}\n\n/* choice default */\nint\nresolve_choice_default_schema_nodeid(const char *nodeid, const struct lys_node *start, const struct lys_node **ret)\n{\n    /* cannot actually be a path */\n    if (strchr(nodeid, '/')) {\n        return -1;\n    }\n\n    return resolve_descendant_schema_nodeid(nodeid, start, LYS_NO_RPC_NOTIF_NODE, 0, ret);\n}\n\n/* uses, -1 error, EXIT_SUCCESS ok (but ret can still be NULL), >0 unexpected char on ret - 1 */\nstatic int\nresolve_uses_schema_nodeid(const char *nodeid, const struct lys_node *start, const struct lys_node_grp **ret)\n{\n    const struct lys_module *module;\n    const char *mod_prefix, *name;\n    int i, mod_prefix_len, nam_len;\n\n    /* parse the identifier, it must be parsed on one call */\n    if (((i = parse_node_identifier(nodeid, &mod_prefix, &mod_prefix_len, &name, &nam_len, NULL, 0)) < 1) || nodeid[i]) {\n        return -i + 1;\n    }\n\n    module = lyp_get_module(start->module, mod_prefix, mod_prefix_len, NULL, 0, 0);\n    if (!module) {\n        return -1;\n    }\n    if (module != lys_main_module(start->module)) {\n        start = module->data;\n    }\n\n    *ret = lys_find_grouping_up(name, (struct lys_node *)start);\n\n    return EXIT_SUCCESS;\n}\n\nint\nresolve_absolute_schema_nodeid(const char *nodeid, const struct lys_module *module, int ret_nodetype,\n                               const struct lys_node **ret)\n{\n    const char *name, *mod_name, *id;\n    const struct lys_node *sibling, *start_parent;\n    int r, nam_len, mod_name_len, is_relative = -1;\n    const struct lys_module *abs_start_mod;\n\n    assert(nodeid && module && ret);\n    assert(!(ret_nodetype & (LYS_USES | LYS_AUGMENT)) && ((ret_nodetype == LYS_GROUPING) || !(ret_nodetype & LYS_GROUPING)));\n\n    id = nodeid;\n    start_parent = NULL;\n\n    if ((r = parse_schema_nodeid(id, &mod_name, &mod_name_len, &name, &nam_len, &is_relative, NULL, NULL, 0)) < 1) {\n        return ((id - nodeid) - r) + 1;\n    }\n    id += r;\n\n    if (is_relative) {\n        return -1;\n    }\n\n    abs_start_mod = lyp_get_module(module, NULL, 0, mod_name, mod_name_len, 0);\n    if (!abs_start_mod) {\n        return -1;\n    }\n\n    while (1) {\n        sibling = NULL;\n        while ((sibling = lys_getnext(sibling, start_parent, abs_start_mod, LYS_GETNEXT_WITHCHOICE\n                | LYS_GETNEXT_WITHCASE | LYS_GETNEXT_WITHINOUT | LYS_GETNEXT_WITHGROUPING | LYS_GETNEXT_NOSTATECHECK))) {\n            r = schema_nodeid_siblingcheck(sibling, module, mod_name, mod_name_len, name, nam_len);\n            if (r == 0) {\n                if (!id[0]) {\n                    if (!(sibling->nodetype & ret_nodetype)) {\n                        /* wrong node type, too bad */\n                        continue;\n                    }\n                    *ret = sibling;\n                    return EXIT_SUCCESS;\n                }\n                start_parent = sibling;\n                break;\n            } else if (r == 1) {\n                continue;\n            } else {\n                return -1;\n            }\n        }\n\n        /* no match */\n        if (!sibling) {\n            *ret = NULL;\n            return EXIT_SUCCESS;\n        }\n\n        if ((r = parse_schema_nodeid(id, &mod_name, &mod_name_len, &name, &nam_len, &is_relative, NULL, NULL, 0)) < 1) {\n            return ((id - nodeid) - r) + 1;\n        }\n        id += r;\n    }\n\n    /* cannot get here */\n    LOGINT(module->ctx);\n    return -1;\n}\n\nstatic int\nresolve_json_schema_list_predicate(const char *predicate, const struct lys_node_list *list, int *parsed)\n{\n    const char *mod_name, *name;\n    int mod_name_len, nam_len, has_predicate, i;\n    struct lys_node *key;\n\n    if (((i = parse_schema_json_predicate(predicate, &mod_name, &mod_name_len, &name, &nam_len, NULL, NULL, &has_predicate)) < 1)\n            || !strncmp(name, \".\", nam_len)) {\n        LOGVAL(list->module->ctx, LYE_PATH_INCHAR, LY_VLOG_NONE, NULL, predicate[-i], &predicate[-i]);\n        return -1;\n    }\n\n    predicate += i;\n    *parsed += i;\n\n    if (!isdigit(name[0])) {\n        for (i = 0; i < list->keys_size; ++i) {\n            key = (struct lys_node *)list->keys[i];\n            if (!strncmp(key->name, name, nam_len) && !key->name[nam_len]) {\n                break;\n            }\n        }\n\n        if (i == list->keys_size) {\n            LOGVAL(list->module->ctx, LYE_PATH_INKEY, LY_VLOG_NONE, NULL, name);\n            return -1;\n        }\n    }\n\n    /* more predicates? */\n    if (has_predicate) {\n        return resolve_json_schema_list_predicate(predicate, list, parsed);\n    }\n\n    return 0;\n}\n\n/* cannot return LYS_GROUPING, LYS_AUGMENT, LYS_USES, logs directly */\nconst struct lys_node *\nresolve_json_nodeid(const char *nodeid, struct ly_ctx *ctx, const struct lys_node *start, int output)\n{\n    char *str;\n    const char *name, *mod_name, *id, *backup_mod_name = NULL, *yang_data_name = NULL;\n    const struct lys_node *sibling, *start_parent, *parent;\n    int r, nam_len, mod_name_len, is_relative = -1, has_predicate;\n    int yang_data_name_len, backup_mod_name_len;\n    /* resolved import module from the start module, it must match the next node-name-match sibling */\n    const struct lys_module *prefix_mod, *module, *prev_mod;\n\n    assert(nodeid && (ctx || start));\n    if (!ctx) {\n        ctx = start->module->ctx;\n    }\n\n    id = nodeid;\n\n    if ((r = parse_schema_nodeid(id, &mod_name, &mod_name_len, &name, &nam_len, &is_relative, NULL, NULL, 1)) < 1) {\n        LOGVAL(ctx, LYE_PATH_INCHAR, LY_VLOG_NONE, NULL, id[-r], &id[-r]);\n        return NULL;\n    }\n\n    if (name[0] == '#') {\n        if (is_relative) {\n            LOGVAL(ctx, LYE_PATH_INCHAR, LY_VLOG_NONE, NULL, '#', name);\n            return NULL;\n        }\n        yang_data_name = name + 1;\n        yang_data_name_len = nam_len - 1;\n        backup_mod_name = mod_name;\n        backup_mod_name_len = mod_name_len;\n        id += r;\n    } else {\n        is_relative = -1;\n    }\n\n    if ((r = parse_schema_nodeid(id, &mod_name, &mod_name_len, &name, &nam_len, &is_relative, &has_predicate, NULL, 0)) < 1) {\n        LOGVAL(ctx, LYE_PATH_INCHAR, LY_VLOG_NONE, NULL, id[-r], &id[-r]);\n        return NULL;\n    }\n    id += r;\n\n    if (backup_mod_name) {\n        mod_name = backup_mod_name;\n        mod_name_len = backup_mod_name_len;\n    }\n\n    if (is_relative) {\n        assert(start);\n        start_parent = start;\n        while (start_parent && (start_parent->nodetype == LYS_USES)) {\n            start_parent = lys_parent(start_parent);\n        }\n        module = start->module;\n    } else {\n        if (!mod_name) {\n            str = strndup(nodeid, (name + nam_len) - nodeid);\n            LOGVAL(ctx, LYE_PATH_MISSMOD, LY_VLOG_STR, nodeid);\n            free(str);\n            return NULL;\n        }\n\n        str = strndup(mod_name, mod_name_len);\n        module = ly_ctx_get_module(ctx, str, NULL, 1);\n        free(str);\n\n        if (!module) {\n            str = strndup(nodeid, (mod_name + mod_name_len) - nodeid);\n            LOGVAL(ctx, LYE_PATH_INMOD, LY_VLOG_STR, str);\n            free(str);\n            return NULL;\n        }\n        start_parent = NULL;\n        if (yang_data_name) {\n            start_parent = lyp_get_yang_data_template(module, yang_data_name, yang_data_name_len);\n            if (!start_parent) {\n                str = strndup(nodeid, (yang_data_name + yang_data_name_len) - nodeid);\n                LOGVAL(ctx, LYE_PATH_INNODE, LY_VLOG_STR, str);\n                free(str);\n                return NULL;\n            }\n        }\n\n        /* now it's as if there was no module name */\n        mod_name = NULL;\n        mod_name_len = 0;\n    }\n\n    prev_mod = module;\n\n    while (1) {\n        sibling = NULL;\n        while ((sibling = lys_getnext(sibling, start_parent, module, 0))) {\n            /* name match */\n            if (sibling->name && !strncmp(name, sibling->name, nam_len) && !sibling->name[nam_len]) {\n                /* output check */\n                for (parent = lys_parent(sibling); parent && !(parent->nodetype & (LYS_INPUT | LYS_OUTPUT)); parent = lys_parent(parent));\n                if (parent) {\n                    if (output && (parent->nodetype == LYS_INPUT)) {\n                        continue;\n                    } else if (!output && (parent->nodetype == LYS_OUTPUT)) {\n                        continue;\n                    }\n                }\n\n                /* module check */\n                if (mod_name) {\n                    /* will also find an augment module */\n                    prefix_mod = ly_ctx_nget_module(ctx, mod_name, mod_name_len, NULL, 1);\n\n                    if (!prefix_mod) {\n                        str = strndup(nodeid, (mod_name + mod_name_len) - nodeid);\n                        LOGVAL(ctx, LYE_PATH_INMOD, LY_VLOG_STR, str);\n                        free(str);\n                        return NULL;\n                    }\n                } else {\n                    prefix_mod = prev_mod;\n                }\n                if (prefix_mod != lys_node_module(sibling)) {\n                    continue;\n                }\n\n                /* do we have some predicates on it? */\n                if (has_predicate) {\n                    r = 0;\n                    if (sibling->nodetype & (LYS_LEAF | LYS_LEAFLIST)) {\n                        if ((r = parse_schema_json_predicate(id, NULL, NULL, NULL, NULL, NULL, NULL, &has_predicate)) < 1) {\n                            LOGVAL(ctx, LYE_PATH_INCHAR, LY_VLOG_NONE, NULL, id[-r], &id[-r]);\n                            return NULL;\n                        }\n                    } else if (sibling->nodetype == LYS_LIST) {\n                        if (resolve_json_schema_list_predicate(id, (const struct lys_node_list *)sibling, &r)) {\n                            return NULL;\n                        }\n                    } else {\n                        LOGVAL(ctx, LYE_PATH_INCHAR, LY_VLOG_NONE, NULL, id[0], id);\n                        return NULL;\n                    }\n                    id += r;\n                }\n\n                /* the result node? */\n                if (!id[0]) {\n                    return sibling;\n                }\n\n                /* move down the tree, if possible */\n                if (sibling->nodetype & (LYS_LEAF | LYS_LEAFLIST | LYS_ANYDATA)) {\n                    LOGVAL(ctx, LYE_PATH_INCHAR, LY_VLOG_NONE, NULL, id[0], id);\n                    return NULL;\n                }\n                start_parent = sibling;\n\n                /* update prev mod */\n                prev_mod = (start_parent->child ? lys_node_module(start_parent->child) : module);\n                break;\n            }\n        }\n\n        /* no match */\n        if (!sibling) {\n            str = strndup(nodeid, (name + nam_len) - nodeid);\n            LOGVAL(ctx, LYE_PATH_INNODE, LY_VLOG_STR, str);\n            free(str);\n            return NULL;\n        }\n\n        if ((r = parse_schema_nodeid(id, &mod_name, &mod_name_len, &name, &nam_len, &is_relative, &has_predicate, NULL, 0)) < 1) {\n            LOGVAL(ctx, LYE_PATH_INCHAR, LY_VLOG_NONE, NULL, id[-r], &id[-r]);\n            return NULL;\n        }\n        id += r;\n    }\n\n    /* cannot get here */\n    LOGINT(ctx);\n    return NULL;\n}\n\nstatic int\nresolve_partial_json_data_list_predicate(struct parsed_pred pp, struct lyd_node *node, int position)\n{\n    uint16_t i;\n    char *val_str;\n    struct lyd_node_leaf_list *key;\n    struct lys_node_list *slist;\n    struct ly_ctx *ctx;\n\n    assert(node);\n    assert(node->schema->nodetype == LYS_LIST);\n    assert(pp.len);\n\n    ctx = node->schema->module->ctx;\n    slist = (struct lys_node_list *)node->schema;\n\n    /* is the predicate a number? */\n    if (isdigit(pp.pred[0].name[0])) {\n        if (position == atoi(pp.pred[0].name)) {\n            /* match */\n            return 0;\n        } else {\n            /* not a match */\n            return 1;\n        }\n    }\n\n    key = (struct lyd_node_leaf_list *)node->child;\n    if (!key) {\n        /* it is not a position, so we need a key for it to be a match */\n        return 1;\n    }\n\n    /* go through all the keys */\n    for (i = 0; i < slist->keys_size; ++i) {\n        if (strncmp(key->schema->name, pp.pred[i].name, pp.pred[i].nam_len) || key->schema->name[pp.pred[i].nam_len]) {\n            LOGVAL(ctx, LYE_PATH_INKEY, LY_VLOG_NONE, NULL, pp.pred[i].name);\n            return -1;\n        }\n\n        if (pp.pred[i].mod_name) {\n            /* specific module, check that the found key is from that module */\n            if (strncmp(lyd_node_module((struct lyd_node *)key)->name, pp.pred[i].mod_name, pp.pred[i].mod_name_len)\n                    || lyd_node_module((struct lyd_node *)key)->name[pp.pred[i].mod_name_len]) {\n                LOGVAL(ctx, LYE_PATH_INKEY, LY_VLOG_NONE, NULL, pp.pred[i].name);\n                return -1;\n            }\n\n            /* but if the module is the same as the parent, it should have been omitted */\n            if (lyd_node_module((struct lyd_node *)key) == lyd_node_module(node)) {\n                LOGVAL(ctx, LYE_PATH_INKEY, LY_VLOG_NONE, NULL, pp.pred[i].name);\n                return -1;\n            }\n        } else {\n            /* no module, so it must be the same as the list (parent) */\n            if (lyd_node_module((struct lyd_node *)key) != lyd_node_module(node)) {\n                LOGVAL(ctx, LYE_PATH_INKEY, LY_VLOG_NONE, NULL, pp.pred[i].name);\n                return -1;\n            }\n        }\n\n        /* get canonical value */\n        val_str = lyd_make_canonical(key->schema, pp.pred[i].value, pp.pred[i].val_len);\n        if (!val_str) {\n            return -1;\n        }\n\n        /* value does not match */\n        if (strcmp(key->value_str, val_str)) {\n            free(val_str);\n            return 1;\n        }\n        free(val_str);\n\n        key = (struct lyd_node_leaf_list *)key->next;\n    }\n\n    return 0;\n}\n\n/**\n * @brief get the closest parent of the node (or the node itself) identified by the nodeid (path)\n *\n * @param[in] nodeid Node data path to find\n * @param[in] llist_value If the \\p nodeid identifies leaf-list, this is expected value of the leaf-list instance.\n * @param[in] options Bitmask of options flags, see @ref pathoptions.\n * @param[out] parsed Number of characters processed in \\p id\n * @return The closes parent (or the node itself) from the path\n */\nstruct lyd_node *\nresolve_partial_json_data_nodeid(const char *nodeid, const char *llist_value, struct lyd_node *start, int options,\n                                 int *parsed)\n{\n    const char *id, *mod_name, *name, *data_val, *llval;\n    int r, ret, mod_name_len, nam_len, is_relative = -1, list_instance_position;\n    int has_predicate, last_parsed = 0, llval_len;\n    struct lyd_node *sibling, *last_match = NULL;\n    struct lyd_node_leaf_list *llist;\n    const struct lys_module *prev_mod;\n    struct ly_ctx *ctx;\n    const struct lys_node *ssibling, *sparent;\n    struct lys_node_list *slist;\n    struct parsed_pred pp;\n\n    assert(nodeid && start && parsed);\n\n    memset(&pp, 0, sizeof pp);\n    ctx = start->schema->module->ctx;\n    id = nodeid;\n\n    /* parse first nodeid in case it is yang-data extension */\n    if ((r = parse_schema_nodeid(id, &mod_name, &mod_name_len, &name, &nam_len, &is_relative, NULL, NULL, 1)) < 1) {\n        LOGVAL(ctx, LYE_PATH_INCHAR, LY_VLOG_NONE, NULL, id[-r], &id[-r]);\n        goto error;\n    }\n\n    if (name[0] == '#') {\n        if (is_relative) {\n            LOGVAL(ctx, LYE_PATH_INCHAR, LY_VLOG_NONE, NULL, '#', name);\n            goto error;\n        }\n        id += r;\n        last_parsed = r;\n    } else {\n        is_relative = -1;\n    }\n\n    /* parse first nodeid */\n    if ((r = parse_schema_nodeid(id, &mod_name, &mod_name_len, &name, &nam_len, &is_relative, &has_predicate, NULL, 0)) < 1) {\n        LOGVAL(ctx, LYE_PATH_INCHAR, LY_VLOG_NONE, NULL, id[-r], &id[-r]);\n        goto error;\n    }\n    id += r;\n    /* add it to parsed only after the data node was actually found */\n    last_parsed += r;\n\n    if (is_relative) {\n        prev_mod = lyd_node_module(start);\n        start = (start->schema->nodetype & (LYS_CONTAINER | LYS_LIST | LYS_RPC | LYS_ACTION | LYS_NOTIF)) ? start->child : NULL;\n    } else {\n        for (; start->parent; start = start->parent);\n        prev_mod = lyd_node_module(start);\n    }\n    if (!start) {\n        /* there are no siblings to search */\n        return NULL;\n    }\n\n    /* do not duplicate code, use predicate parsing from the loop */\n    goto parse_predicates;\n\n    while (1) {\n        /* find the correct schema node first */\n        ssibling = NULL;\n        sparent = (start && start->parent) ? start->parent->schema : NULL;\n        while ((ssibling = lys_getnext(ssibling, sparent, prev_mod, 0))) {\n            /* skip invalid input/output nodes */\n            if (sparent && (sparent->nodetype & (LYS_RPC | LYS_ACTION))) {\n                if (options & LYD_PATH_OPT_OUTPUT) {\n                    if (lys_parent(ssibling)->nodetype == LYS_INPUT) {\n                        continue;\n                    }\n                } else {\n                    if (lys_parent(ssibling)->nodetype == LYS_OUTPUT) {\n                        continue;\n                    }\n                }\n            }\n\n            if (!schema_nodeid_siblingcheck(ssibling, prev_mod, mod_name, mod_name_len, name, nam_len)) {\n                break;\n            }\n        }\n        if (!ssibling) {\n            /* there is not even such a schema node */\n            free(pp.pred);\n            return last_match;\n        }\n        pp.schema = ssibling;\n\n        /* unify leaf-list value - it is possible to specify last-node value as both a predicate or parameter if\n         * is a leaf-list, unify both cases and the value will in both cases be in the predicate structure */\n        if (!id[0] && !pp.len && (ssibling->nodetype == LYS_LEAFLIST)) {\n            pp.len = 1;\n            pp.pred = calloc(1, sizeof *pp.pred);\n            LY_CHECK_ERR_GOTO(!pp.pred, LOGMEM(ctx), error);\n\n            pp.pred[0].name = \".\";\n            pp.pred[0].nam_len = 1;\n            pp.pred[0].value = (llist_value ? llist_value : \"\");\n            pp.pred[0].val_len = strlen(pp.pred[0].value);\n        }\n\n        if (ssibling->nodetype & (LYS_LEAFLIST | LYS_LEAF)) {\n            /* check leaf/leaf-list predicate */\n            if (pp.len > 1) {\n                LOGVAL(ctx, LYE_PATH_PREDTOOMANY, LY_VLOG_NONE, NULL);\n                goto error;\n            } else if (pp.len) {\n                if ((pp.pred[0].name[0] != '.') || (pp.pred[0].nam_len != 1)) {\n                    LOGVAL(ctx, LYE_PATH_INCHAR, LY_VLOG_NONE, NULL, pp.pred[0].name[0], pp.pred[0].name);\n                    goto error;\n                }\n                if ((((struct lys_node_leaf *)ssibling)->type.base == LY_TYPE_IDENT) && !strnchr(pp.pred[0].value, ':', pp.pred[0].val_len)) {\n                    LOGVAL(ctx, LYE_PATH_INIDENTREF, LY_VLOG_LYS, ssibling, pp.pred[0].val_len, pp.pred[0].value);\n                    goto error;\n                }\n            }\n        } else if (ssibling->nodetype == LYS_LIST) {\n            /* list should have predicates for all the keys or position */\n            slist = (struct lys_node_list *)ssibling;\n            if (!pp.len) {\n                /* none match */\n                return last_match;\n            } else if (!isdigit(pp.pred[0].name[0])) {\n                /* list predicate is not a position, so there must be all the keys */\n                if (pp.len > slist->keys_size) {\n                    LOGVAL(ctx, LYE_PATH_PREDTOOMANY, LY_VLOG_NONE, NULL);\n                    goto error;\n                } else if (pp.len < slist->keys_size) {\n                    LOGVAL(ctx, LYE_PATH_MISSKEY, LY_VLOG_NONE, NULL, slist->keys[pp.len]->name);\n                    goto error;\n                }\n                /* check that all identityrefs have module name, otherwise the hash of the list instance will never match!! */\n                for (r = 0; r < pp.len; ++r) {\n                    if ((slist->keys[r]->type.base == LY_TYPE_IDENT) && !strnchr(pp.pred[r].value, ':', pp.pred[r].val_len)) {\n                        LOGVAL(ctx, LYE_PATH_INIDENTREF, LY_VLOG_LYS, slist->keys[r], pp.pred[r].val_len, pp.pred[r].value);\n                        goto error;\n                    }\n                }\n            }\n        } else if (pp.pred) {\n            /* no other nodes allow predicates */\n            LOGVAL(ctx, LYE_PATH_PREDTOOMANY, LY_VLOG_NONE, NULL);\n            goto error;\n        }\n\n#ifdef LY_ENABLED_CACHE\n        /* we will not be matching keyless lists or state leaf-lists this way */\n        if (start->parent && start->parent->ht && ((pp.schema->nodetype != LYS_LIST) || ((struct lys_node_list *)pp.schema)->keys_size)\n                && ((pp.schema->nodetype != LYS_LEAFLIST) || (pp.schema->flags & LYS_CONFIG_W))) {\n            sibling = resolve_json_data_node_hash(start->parent, pp);\n        } else\n#endif\n        {\n            list_instance_position = 0;\n            LY_TREE_FOR(start, sibling) {\n                /* RPC/action data check, return simply invalid argument, because the data tree is invalid */\n                if (lys_parent(sibling->schema)) {\n                    if (options & LYD_PATH_OPT_OUTPUT) {\n                        if (lys_parent(sibling->schema)->nodetype == LYS_INPUT) {\n                            LOGERR(ctx, LY_EINVAL, \"Provided data tree includes some RPC input nodes (%s).\", sibling->schema->name);\n                            goto error;\n                        }\n                    } else {\n                        if (lys_parent(sibling->schema)->nodetype == LYS_OUTPUT) {\n                            LOGERR(ctx, LY_EINVAL, \"Provided data tree includes some RPC output nodes (%s).\", sibling->schema->name);\n                            goto error;\n                        }\n                    }\n                }\n\n                if (sibling->schema != ssibling) {\n                    /* wrong schema node */\n                    continue;\n                }\n\n                /* leaf-list, did we find it with the correct value or not? */\n                if (ssibling->nodetype == LYS_LEAFLIST) {\n                    if (ssibling->flags & LYS_CONFIG_R) {\n                        /* state leaf-lists will never match */\n                        continue;\n                    }\n\n                    llist = (struct lyd_node_leaf_list *)sibling;\n\n                    /* get the expected leaf-list value */\n                    llval = NULL;\n                    llval_len = 0;\n                    if (pp.pred) {\n                        /* it was already checked that it is correct */\n                        llval = pp.pred[0].value;\n                        llval_len = pp.pred[0].val_len;\n\n                    }\n\n                    /* make value canonical (remove module name prefix) unless it was specified with it */\n                    if (llval && !strchr(llval, ':') && (llist->value_type & LY_TYPE_IDENT)\n                            && !strncmp(llist->value_str, lyd_node_module(sibling)->name, strlen(lyd_node_module(sibling)->name))\n                            && (llist->value_str[strlen(lyd_node_module(sibling)->name)] == ':')) {\n                        data_val = llist->value_str + strlen(lyd_node_module(sibling)->name) + 1;\n                    } else {\n                        data_val = llist->value_str;\n                    }\n\n                    if ((!llval && data_val && data_val[0]) || (llval && (strncmp(llval, data_val, llval_len)\n                            || data_val[llval_len]))) {\n                        continue;\n                    }\n\n                } else if (ssibling->nodetype == LYS_LIST) {\n                    /* list, we likely need predicates'n'stuff then, but if without a predicate, we are always creating it */\n                    ++list_instance_position;\n                    ret = resolve_partial_json_data_list_predicate(pp, sibling, list_instance_position);\n                    if (ret == -1) {\n                        goto error;\n                    } else if (ret == 1) {\n                        /* this list instance does not match */\n                        continue;\n                    }\n                }\n\n                break;\n            }\n        }\n\n        /* no match, return last match */\n        if (!sibling) {\n            free(pp.pred);\n            return last_match;\n        }\n\n        /* we found a next matching node */\n        *parsed += last_parsed;\n        last_match = sibling;\n        prev_mod = lyd_node_module(sibling);\n\n        /* the result node? */\n        if (!id[0]) {\n            free(pp.pred);\n            return last_match;\n        }\n\n        /* move down the tree, if possible, and continue */\n        if (ssibling->nodetype & (LYS_LEAF | LYS_LEAFLIST | LYS_ANYDATA)) {\n            /* there can be no children even through expected, error */\n            LOGVAL(ctx, LYE_PATH_INCHAR, LY_VLOG_NONE, NULL, id[0], id);\n            goto error;\n        } else if (!sibling->child) {\n            /* there could be some children, but are not, return what we found so far */\n            free(pp.pred);\n            return last_match;\n        }\n        start = sibling->child;\n\n        /* parse nodeid */\n        if ((r = parse_schema_nodeid(id, &mod_name, &mod_name_len, &name, &nam_len, &is_relative, &has_predicate, NULL, 0)) < 1) {\n            LOGVAL(ctx, LYE_PATH_INCHAR, LY_VLOG_NONE, NULL, id[-r], &id[-r]);\n            goto error;\n        }\n        id += r;\n        last_parsed = r;\n\nparse_predicates:\n        /* parse all the predicates */\n        free(pp.pred);\n        pp.schema = NULL;\n        pp.len = 0;\n        pp.pred = NULL;\n        while (has_predicate) {\n            ++pp.len;\n            pp.pred = ly_realloc(pp.pred, pp.len * sizeof *pp.pred);\n            LY_CHECK_ERR_GOTO(!pp.pred, LOGMEM(ctx), error);\n            if ((r = parse_schema_json_predicate(id, &pp.pred[pp.len - 1].mod_name, &pp.pred[pp.len - 1].mod_name_len,\n                                                 &pp.pred[pp.len - 1].name, &pp.pred[pp.len - 1].nam_len, &pp.pred[pp.len - 1].value,\n                                                 &pp.pred[pp.len - 1].val_len, &has_predicate)) < 1) {\n                LOGVAL(ctx, LYE_PATH_INCHAR, LY_VLOG_NONE, NULL, id[0], id);\n                goto error;\n            }\n\n            id += r;\n            last_parsed += r;\n        }\n    }\n\nerror:\n    *parsed = -1;\n    free(pp.pred);\n    return NULL;\n}\n\n/**\n * @brief Resolves length or range intervals. Does not log.\n * Syntax is assumed to be correct, *ret MUST be NULL.\n *\n * @param[in] ctx Context for errors.\n * @param[in] str_restr Restriction as a string.\n * @param[in] type Type of the restriction.\n * @param[out] ret Final interval structure that starts with\n * the interval of the initial type, continues with intervals\n * of any superior types derived from the initial one, and\n * finishes with intervals from our \\p type.\n *\n * @return EXIT_SUCCESS on succes, -1 on error.\n */\nint\nresolve_len_ran_interval(struct ly_ctx *ctx, const char *str_restr, struct lys_type *type, struct len_ran_intv **ret)\n{\n    /* 0 - unsigned, 1 - signed, 2 - floating point */\n    int kind;\n    int64_t local_smin = 0, local_smax = 0, local_fmin, local_fmax;\n    uint64_t local_umin, local_umax = 0;\n    uint8_t local_fdig = 0;\n    const char *seg_ptr, *ptr;\n    struct len_ran_intv *local_intv = NULL, *tmp_local_intv = NULL, *tmp_intv, *intv = NULL;\n\n    switch (type->base) {\n    case LY_TYPE_BINARY:\n        kind = 0;\n        local_umin = 0;\n        local_umax = 18446744073709551615UL;\n\n        if (!str_restr && type->info.binary.length) {\n            str_restr = type->info.binary.length->expr;\n        }\n        break;\n    case LY_TYPE_DEC64:\n        kind = 2;\n        local_fmin = __INT64_C(-9223372036854775807) - __INT64_C(1);\n        local_fmax = __INT64_C(9223372036854775807);\n        local_fdig = type->info.dec64.dig;\n\n        if (!str_restr && type->info.dec64.range) {\n            str_restr = type->info.dec64.range->expr;\n        }\n        break;\n    case LY_TYPE_INT8:\n        kind = 1;\n        local_smin = __INT64_C(-128);\n        local_smax = __INT64_C(127);\n\n        if (!str_restr && type->info.num.range) {\n            str_restr = type->info.num.range->expr;\n        }\n        break;\n    case LY_TYPE_INT16:\n        kind = 1;\n        local_smin = __INT64_C(-32768);\n        local_smax = __INT64_C(32767);\n\n        if (!str_restr && type->info.num.range) {\n            str_restr = type->info.num.range->expr;\n        }\n        break;\n    case LY_TYPE_INT32:\n        kind = 1;\n        local_smin = __INT64_C(-2147483648);\n        local_smax = __INT64_C(2147483647);\n\n        if (!str_restr && type->info.num.range) {\n            str_restr = type->info.num.range->expr;\n        }\n        break;\n    case LY_TYPE_INT64:\n        kind = 1;\n        local_smin = __INT64_C(-9223372036854775807) - __INT64_C(1);\n        local_smax = __INT64_C(9223372036854775807);\n\n        if (!str_restr && type->info.num.range) {\n            str_restr = type->info.num.range->expr;\n        }\n        break;\n    case LY_TYPE_UINT8:\n        kind = 0;\n        local_umin = __UINT64_C(0);\n        local_umax = __UINT64_C(255);\n\n        if (!str_restr && type->info.num.range) {\n            str_restr = type->info.num.range->expr;\n        }\n        break;\n    case LY_TYPE_UINT16:\n        kind = 0;\n        local_umin = __UINT64_C(0);\n        local_umax = __UINT64_C(65535);\n\n        if (!str_restr && type->info.num.range) {\n            str_restr = type->info.num.range->expr;\n        }\n        break;\n    case LY_TYPE_UINT32:\n        kind = 0;\n        local_umin = __UINT64_C(0);\n        local_umax = __UINT64_C(4294967295);\n\n        if (!str_restr && type->info.num.range) {\n            str_restr = type->info.num.range->expr;\n        }\n        break;\n    case LY_TYPE_UINT64:\n        kind = 0;\n        local_umin = __UINT64_C(0);\n        local_umax = __UINT64_C(18446744073709551615);\n\n        if (!str_restr && type->info.num.range) {\n            str_restr = type->info.num.range->expr;\n        }\n        break;\n    case LY_TYPE_STRING:\n        kind = 0;\n        local_umin = __UINT64_C(0);\n        local_umax = __UINT64_C(18446744073709551615);\n\n        if (!str_restr && type->info.str.length) {\n            str_restr = type->info.str.length->expr;\n        }\n        break;\n    default:\n        return -1;\n    }\n\n    /* process superior types */\n    if (type->der) {\n        if (resolve_len_ran_interval(ctx, NULL, &type->der->type, &intv)) {\n            return -1;\n        }\n        assert(!intv || (intv->kind == kind));\n    }\n\n    if (!str_restr) {\n        /* we do not have any restriction, return superior ones */\n        *ret = intv;\n        return EXIT_SUCCESS;\n    }\n\n    /* adjust local min and max */\n    if (intv) {\n        tmp_intv = intv;\n\n        if (kind == 0) {\n            local_umin = tmp_intv->value.uval.min;\n        } else if (kind == 1) {\n            local_smin = tmp_intv->value.sval.min;\n        } else if (kind == 2) {\n            local_fmin = tmp_intv->value.fval.min;\n        }\n\n        while (tmp_intv->next) {\n            tmp_intv = tmp_intv->next;\n        }\n\n        if (kind == 0) {\n            local_umax = tmp_intv->value.uval.max;\n        } else if (kind == 1) {\n            local_smax = tmp_intv->value.sval.max;\n        } else if (kind == 2) {\n            local_fmax = tmp_intv->value.fval.max;\n        }\n    }\n\n    /* finally parse our restriction */\n    seg_ptr = str_restr;\n    tmp_intv = NULL;\n    while (1) {\n        if (!tmp_local_intv) {\n            assert(!local_intv);\n            local_intv = malloc(sizeof *local_intv);\n            tmp_local_intv = local_intv;\n        } else {\n            tmp_local_intv->next = malloc(sizeof *tmp_local_intv);\n            tmp_local_intv = tmp_local_intv->next;\n        }\n        LY_CHECK_ERR_GOTO(!tmp_local_intv, LOGMEM(ctx), error);\n\n        tmp_local_intv->kind = kind;\n        tmp_local_intv->type = type;\n        tmp_local_intv->next = NULL;\n\n        /* min */\n        ptr = seg_ptr;\n        while (isspace(ptr[0])) {\n            ++ptr;\n        }\n        if (isdigit(ptr[0]) || (ptr[0] == '+') || (ptr[0] == '-')) {\n            if (kind == 0) {\n                tmp_local_intv->value.uval.min = strtoull(ptr, (char **)&ptr, 10);\n            } else if (kind == 1) {\n                tmp_local_intv->value.sval.min = strtoll(ptr, (char **)&ptr, 10);\n            } else if (kind == 2) {\n                if (parse_range_dec64(&ptr, local_fdig, &tmp_local_intv->value.fval.min)) {\n                    LOGVAL(ctx, LYE_INARG, LY_VLOG_NONE, NULL, ptr, \"range\");\n                    goto error;\n                }\n            }\n        } else if (!strncmp(ptr, \"min\", 3)) {\n            if (kind == 0) {\n                tmp_local_intv->value.uval.min = local_umin;\n            } else if (kind == 1) {\n                tmp_local_intv->value.sval.min = local_smin;\n            } else if (kind == 2) {\n                tmp_local_intv->value.fval.min = local_fmin;\n            }\n\n            ptr += 3;\n        } else if (!strncmp(ptr, \"max\", 3)) {\n            if (kind == 0) {\n                tmp_local_intv->value.uval.min = local_umax;\n            } else if (kind == 1) {\n                tmp_local_intv->value.sval.min = local_smax;\n            } else if (kind == 2) {\n                tmp_local_intv->value.fval.min = local_fmax;\n            }\n\n            ptr += 3;\n        } else {\n            goto error;\n        }\n\n        while (isspace(ptr[0])) {\n            ptr++;\n        }\n\n        /* no interval or interval */\n        if ((ptr[0] == '|') || !ptr[0]) {\n            if (kind == 0) {\n                tmp_local_intv->value.uval.max = tmp_local_intv->value.uval.min;\n            } else if (kind == 1) {\n                tmp_local_intv->value.sval.max = tmp_local_intv->value.sval.min;\n            } else if (kind == 2) {\n                tmp_local_intv->value.fval.max = tmp_local_intv->value.fval.min;\n            }\n        } else if (!strncmp(ptr, \"..\", 2)) {\n            /* skip \"..\" */\n            ptr += 2;\n            while (isspace(ptr[0])) {\n                ++ptr;\n            }\n\n            /* max */\n            if (isdigit(ptr[0]) || (ptr[0] == '+') || (ptr[0] == '-')) {\n                if (kind == 0) {\n                    tmp_local_intv->value.uval.max = strtoull(ptr, (char **)&ptr, 10);\n                } else if (kind == 1) {\n                    tmp_local_intv->value.sval.max = strtoll(ptr, (char **)&ptr, 10);\n                } else if (kind == 2) {\n                    if (parse_range_dec64(&ptr, local_fdig, &tmp_local_intv->value.fval.max)) {\n                        LOGVAL(ctx, LYE_INARG, LY_VLOG_NONE, NULL, ptr, \"range\");\n                        goto error;\n                    }\n                }\n            } else if (!strncmp(ptr, \"max\", 3)) {\n                if (kind == 0) {\n                    tmp_local_intv->value.uval.max = local_umax;\n                } else if (kind == 1) {\n                    tmp_local_intv->value.sval.max = local_smax;\n                } else if (kind == 2) {\n                    tmp_local_intv->value.fval.max = local_fmax;\n                }\n            } else {\n                goto error;\n            }\n        } else {\n            goto error;\n        }\n\n        /* check min and max in correct order */\n        if (kind == 0) {\n            /* current segment */\n            if (tmp_local_intv->value.uval.min > tmp_local_intv->value.uval.max) {\n                goto error;\n            }\n            if (tmp_local_intv->value.uval.min < local_umin || tmp_local_intv->value.uval.max > local_umax) {\n                goto error;\n            }\n            /* segments sholud be ascending order */\n            if (tmp_intv && (tmp_intv->value.uval.max >= tmp_local_intv->value.uval.min)) {\n                goto error;\n            }\n        } else if (kind == 1) {\n            if (tmp_local_intv->value.sval.min > tmp_local_intv->value.sval.max) {\n                goto error;\n            }\n            if (tmp_local_intv->value.sval.min < local_smin || tmp_local_intv->value.sval.max > local_smax) {\n                goto error;\n            }\n            if (tmp_intv && (tmp_intv->value.sval.max >= tmp_local_intv->value.sval.min)) {\n                goto error;\n            }\n        } else if (kind == 2) {\n            if (tmp_local_intv->value.fval.min > tmp_local_intv->value.fval.max) {\n                goto error;\n            }\n            if (tmp_local_intv->value.fval.min < local_fmin || tmp_local_intv->value.fval.max > local_fmax) {\n                goto error;\n            }\n            if (tmp_intv && (tmp_intv->value.fval.max >= tmp_local_intv->value.fval.min)) {\n                /* fraction-digits value is always the same (it cannot be changed in derived types) */\n                goto error;\n            }\n        }\n\n        /* next segment (next OR) */\n        seg_ptr = strchr(seg_ptr, '|');\n        if (!seg_ptr) {\n            break;\n        }\n        seg_ptr++;\n        tmp_intv = tmp_local_intv;\n    }\n\n    /* check local restrictions against superior ones */\n    if (intv) {\n        tmp_intv = intv;\n        tmp_local_intv = local_intv;\n\n        while (tmp_local_intv && tmp_intv) {\n            /* reuse local variables */\n            if (kind == 0) {\n                local_umin = tmp_local_intv->value.uval.min;\n                local_umax = tmp_local_intv->value.uval.max;\n\n                /* it must be in this interval */\n                if ((local_umin >= tmp_intv->value.uval.min) && (local_umin <= tmp_intv->value.uval.max)) {\n                    /* this interval is covered, next one */\n                    if (local_umax <= tmp_intv->value.uval.max) {\n                        tmp_local_intv = tmp_local_intv->next;\n                        continue;\n                    /* ascending order of restrictions -> fail */\n                    } else {\n                        goto error;\n                    }\n                }\n            } else if (kind == 1) {\n                local_smin = tmp_local_intv->value.sval.min;\n                local_smax = tmp_local_intv->value.sval.max;\n\n                if ((local_smin >= tmp_intv->value.sval.min) && (local_smin <= tmp_intv->value.sval.max)) {\n                    if (local_smax <= tmp_intv->value.sval.max) {\n                        tmp_local_intv = tmp_local_intv->next;\n                        continue;\n                    } else {\n                        goto error;\n                    }\n                }\n            } else if (kind == 2) {\n                local_fmin = tmp_local_intv->value.fval.min;\n                local_fmax = tmp_local_intv->value.fval.max;\n\n                 if ((dec64cmp(local_fmin, local_fdig, tmp_intv->value.fval.min, local_fdig) > -1)\n                        && (dec64cmp(local_fmin, local_fdig, tmp_intv->value.fval.max, local_fdig) < 1)) {\n                    if (dec64cmp(local_fmax, local_fdig, tmp_intv->value.fval.max, local_fdig) < 1) {\n                        tmp_local_intv = tmp_local_intv->next;\n                        continue;\n                    } else {\n                        goto error;\n                    }\n                }\n            }\n\n            tmp_intv = tmp_intv->next;\n        }\n\n        /* some interval left uncovered -> fail */\n        if (tmp_local_intv) {\n            goto error;\n        }\n    }\n\n    /* append the local intervals to all the intervals of the superior types, return it all */\n    if (intv) {\n        for (tmp_intv = intv; tmp_intv->next; tmp_intv = tmp_intv->next);\n        tmp_intv->next = local_intv;\n    } else {\n        intv = local_intv;\n    }\n    *ret = intv;\n\n    return EXIT_SUCCESS;\n\nerror:\n    while (intv) {\n        tmp_intv = intv->next;\n        free(intv);\n        intv = tmp_intv;\n    }\n    while (local_intv) {\n        tmp_local_intv = local_intv->next;\n        free(local_intv);\n        local_intv = tmp_local_intv;\n    }\n\n    return -1;\n}\n\nstatic int\nresolve_superior_type_check(struct lys_type *type)\n{\n    uint32_t i;\n\n    if (type->base == LY_TYPE_DER) {\n        /* check that the referenced typedef is resolved */\n        return EXIT_FAILURE;\n    } else if (type->base == LY_TYPE_UNION) {\n        /* check that all union types are resolved */\n        for (i = 0; i < type->info.uni.count; ++i) {\n            if (resolve_superior_type_check(&type->info.uni.types[i])) {\n                return EXIT_FAILURE;\n            }\n        }\n    } else if (type->base == LY_TYPE_LEAFREF) {\n        /* check there is path in some derived type */\n        while (!type->info.lref.path) {\n            assert(type->der);\n            type = &type->der->type;\n        }\n    }\n\n    return EXIT_SUCCESS;\n}\n\n/**\n * @brief Resolve a typedef, return only resolved typedefs if derived. If leafref, it must be\n * resolved for this function to return it. Does not log.\n *\n * @param[in] name Typedef name.\n * @param[in] mod_name Typedef name module name.\n * @param[in] module Main module.\n * @param[in] parent Parent of the resolved type definition.\n * @param[out] ret Pointer to the resolved typedef. Can be NULL.\n *\n * @return EXIT_SUCCESS on success, EXIT_FAILURE on forward reference, -1 on error.\n */\nint\nresolve_superior_type(const char *name, const char *mod_name, const struct lys_module *module,\n                      const struct lys_node *parent, struct lys_tpdf **ret)\n{\n    int i, j;\n    struct lys_tpdf *tpdf, *match;\n    int tpdf_size;\n\n    if (!mod_name) {\n        /* no prefix, try built-in types */\n        for (i = 1; i < LY_DATA_TYPE_COUNT; i++) {\n            if (!strcmp(ly_types[i]->name, name)) {\n                if (ret) {\n                    *ret = ly_types[i];\n                }\n                return EXIT_SUCCESS;\n            }\n        }\n    } else {\n        if (!strcmp(mod_name, module->name)) {\n            /* prefix refers to the current module, ignore it */\n            mod_name = NULL;\n        }\n    }\n\n    if (!mod_name && parent) {\n        /* search in local typedefs */\n        while (parent) {\n            switch (parent->nodetype) {\n            case LYS_CONTAINER:\n                tpdf_size = ((struct lys_node_container *)parent)->tpdf_size;\n                tpdf = ((struct lys_node_container *)parent)->tpdf;\n                break;\n\n            case LYS_LIST:\n                tpdf_size = ((struct lys_node_list *)parent)->tpdf_size;\n                tpdf = ((struct lys_node_list *)parent)->tpdf;\n                break;\n\n            case LYS_GROUPING:\n                tpdf_size = ((struct lys_node_grp *)parent)->tpdf_size;\n                tpdf = ((struct lys_node_grp *)parent)->tpdf;\n                break;\n\n            case LYS_RPC:\n            case LYS_ACTION:\n                tpdf_size = ((struct lys_node_rpc_action *)parent)->tpdf_size;\n                tpdf = ((struct lys_node_rpc_action *)parent)->tpdf;\n                break;\n\n            case LYS_NOTIF:\n                tpdf_size = ((struct lys_node_notif *)parent)->tpdf_size;\n                tpdf = ((struct lys_node_notif *)parent)->tpdf;\n                break;\n\n            case LYS_INPUT:\n            case LYS_OUTPUT:\n                tpdf_size = ((struct lys_node_inout *)parent)->tpdf_size;\n                tpdf = ((struct lys_node_inout *)parent)->tpdf;\n                break;\n\n            default:\n                parent = lys_parent(parent);\n                continue;\n            }\n\n            for (i = 0; i < tpdf_size; i++) {\n                if (!strcmp(tpdf[i].name, name)) {\n                    match = &tpdf[i];\n                    goto check_typedef;\n                }\n            }\n\n            parent = lys_parent(parent);\n        }\n    } else {\n        /* get module where to search */\n        module = lyp_get_module(module, NULL, 0, mod_name, 0, 0);\n        if (!module) {\n            return -1;\n        }\n    }\n\n    /* search in top level typedefs */\n    for (i = 0; i < module->tpdf_size; i++) {\n        if (!strcmp(module->tpdf[i].name, name)) {\n            match = &module->tpdf[i];\n            goto check_typedef;\n        }\n    }\n\n    /* search in submodules */\n    for (i = 0; i < module->inc_size && module->inc[i].submodule; i++) {\n        for (j = 0; j < module->inc[i].submodule->tpdf_size; j++) {\n            if (!strcmp(module->inc[i].submodule->tpdf[j].name, name)) {\n                match = &module->inc[i].submodule->tpdf[j];\n                goto check_typedef;\n            }\n        }\n    }\n\n    return EXIT_FAILURE;\n\ncheck_typedef:\n    if (resolve_superior_type_check(&match->type)) {\n        return EXIT_FAILURE;\n    }\n\n    if (ret) {\n        *ret = match;\n    }\n    return EXIT_SUCCESS;\n}\n\n/**\n * @brief Check the default \\p value of the \\p type. Logs directly.\n *\n * @param[in] type Type definition to use.\n * @param[in] value Default value to check.\n * @param[in] module Type module.\n *\n * @return EXIT_SUCCESS on success, EXIT_FAILURE on forward reference, -1 on error.\n */\nstatic int\ncheck_default(struct lys_type *type, const char **value, struct lys_module *module, int tpdf)\n{\n    struct lys_tpdf *base_tpdf = NULL;\n    struct lyd_node_leaf_list node;\n    const char *dflt = NULL;\n    char *s;\n    int ret = EXIT_SUCCESS, r;\n    struct ly_ctx *ctx = module->ctx;\n\n    assert(value);\n    memset(&node, 0, sizeof node);\n\n    if (type->base <= LY_TYPE_DER) {\n        /* the type was not resolved yet, nothing to do for now */\n        ret = EXIT_FAILURE;\n        goto cleanup;\n    } else if (!tpdf && !module->implemented) {\n        /* do not check defaults in not implemented module's data */\n        goto cleanup;\n    } else if (tpdf && !module->implemented && type->base == LY_TYPE_IDENT) {\n        /* identityrefs are checked when instantiated in data instead of typedef,\n         * but in typedef the value has to be modified to include the prefix */\n        if (*value) {\n            if (strchr(*value, ':')) {\n                dflt = transform_schema2json(module, *value);\n            } else {\n                /* default prefix of the module where the typedef is defined */\n                if (asprintf(&s, \"%s:%s\", lys_main_module(module)->name, *value) == -1) {\n                    LOGMEM(ctx);\n                    ret = -1;\n                    goto cleanup;\n                }\n                dflt = lydict_insert_zc(ctx, s);\n            }\n            lydict_remove(ctx, *value);\n            *value = dflt;\n            dflt = NULL;\n        }\n        goto cleanup;\n    } else if (type->base == LY_TYPE_LEAFREF && tpdf) {\n        /* leafref in typedef cannot be checked */\n        goto cleanup;\n    }\n\n    dflt = lydict_insert(ctx, *value, 0);\n    if (!dflt) {\n        /* we do not have a new default value, so is there any to check even, in some base type? */\n        for (base_tpdf = type->der; base_tpdf->type.der; base_tpdf = base_tpdf->type.der) {\n            if (base_tpdf->dflt) {\n                dflt = lydict_insert(ctx, base_tpdf->dflt, 0);\n                break;\n            }\n        }\n\n        if (!dflt) {\n            /* no default value, nothing to check, all is well */\n            goto cleanup;\n        }\n\n        /* so there is a default value in a base type, but can the default value be no longer valid (did we define some new restrictions)? */\n        switch (type->base) {\n        case LY_TYPE_IDENT:\n            if (lys_main_module(base_tpdf->type.parent->module)->implemented) {\n                goto cleanup;\n            } else {\n                /* check the default value from typedef, but use also the typedef's module\n                 * due to possible searching in imported modules which is expected in\n                 * typedef's module instead of module where the typedef is used */\n                module = base_tpdf->module;\n            }\n            break;\n        case LY_TYPE_INST:\n        case LY_TYPE_LEAFREF:\n        case LY_TYPE_BOOL:\n        case LY_TYPE_EMPTY:\n            /* these have no restrictions, so we would do the exact same work as the unres in the base typedef */\n            goto cleanup;\n        case LY_TYPE_BITS:\n            /* the default value must match the restricted list of values, if the type was restricted */\n            if (type->info.bits.count) {\n                break;\n            }\n            goto cleanup;\n        case LY_TYPE_ENUM:\n            /* the default value must match the restricted list of values, if the type was restricted */\n            if (type->info.enums.count) {\n                break;\n            }\n            goto cleanup;\n        case LY_TYPE_DEC64:\n            if (type->info.dec64.range) {\n                break;\n            }\n            goto cleanup;\n        case LY_TYPE_BINARY:\n            if (type->info.binary.length) {\n                break;\n            }\n            goto cleanup;\n        case LY_TYPE_INT8:\n        case LY_TYPE_INT16:\n        case LY_TYPE_INT32:\n        case LY_TYPE_INT64:\n        case LY_TYPE_UINT8:\n        case LY_TYPE_UINT16:\n        case LY_TYPE_UINT32:\n        case LY_TYPE_UINT64:\n            if (type->info.num.range) {\n                break;\n            }\n            goto cleanup;\n        case LY_TYPE_STRING:\n            if (type->info.str.length || type->info.str.patterns) {\n                break;\n            }\n            goto cleanup;\n        case LY_TYPE_UNION:\n            /* way too much trouble learning whether we need to check the default again, so just do it */\n            break;\n        default:\n            LOGINT(ctx);\n            ret = -1;\n            goto cleanup;\n        }\n    } else if (type->base == LY_TYPE_EMPTY) {\n        LOGVAL(ctx, LYE_INCHILDSTMT, LY_VLOG_NONE, NULL, \"default\", type->parent->name);\n        LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"The \\\"empty\\\" data type cannot have a default value.\");\n        ret = -1;\n        goto cleanup;\n    }\n\n    /* dummy leaf */\n    memset(&node, 0, sizeof node);\n    node.value_str = lydict_insert(ctx, dflt, 0);\n    node.value_type = type->base;\n\n    if (tpdf) {\n        node.schema = calloc(1, sizeof (struct lys_node_leaf));\n        if (!node.schema) {\n            LOGMEM(ctx);\n            ret = -1;\n            goto cleanup;\n        }\n        r = asprintf((char **)&node.schema->name, \"typedef-%s-default\", ((struct lys_tpdf *)type->parent)->name);\n        if (r == -1) {\n            LOGMEM(ctx);\n            ret = -1;\n            goto cleanup;\n        }\n        node.schema->module = module;\n        memcpy(&((struct lys_node_leaf *)node.schema)->type, type, sizeof *type);\n    } else {\n        node.schema = (struct lys_node *)type->parent;\n    }\n\n    if (type->base == LY_TYPE_LEAFREF) {\n        if (!type->info.lref.target) {\n            ret = EXIT_FAILURE;\n            LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Default value \\\"%s\\\" cannot be checked in an unresolved leafref.\",\n                   dflt);\n            goto cleanup;\n        }\n        ret = check_default(&type->info.lref.target->type, &dflt, module, 0);\n        if (!ret) {\n            /* adopt possibly changed default value to its canonical form */\n            if (*value) {\n                lydict_remove(ctx, *value);\n                *value = dflt;\n                dflt = NULL;\n            }\n        }\n    } else {\n        if (!lyp_parse_value(type, &node.value_str, NULL, &node, NULL, module, 1, 1, 0)) {\n            /* possible forward reference */\n            ret = EXIT_FAILURE;\n            if (base_tpdf) {\n                /* default value is defined in some base typedef */\n                if ((type->base == LY_TYPE_BITS && type->der->type.der) ||\n                        (type->base == LY_TYPE_ENUM && type->der->type.der)) {\n                    /* we have refined bits/enums */\n                    LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL,\n                           \"Invalid value \\\"%s\\\" of the default statement inherited to \\\"%s\\\" from \\\"%s\\\" base type.\",\n                           dflt, type->parent->name, base_tpdf->name);\n                }\n            }\n        } else {\n            /* success - adopt canonical form from the node into the default value */\n            if (!ly_strequal(dflt, node.value_str, 1)) {\n                /* this can happen only if we have non-inherited default value,\n                 * inherited default values are already in canonical form */\n                assert(ly_strequal(dflt, *value, 1));\n\n                lydict_remove(ctx, *value);\n                *value = node.value_str;\n                node.value_str = NULL;\n            }\n        }\n    }\n\ncleanup:\n    lyd_free_value(node.value, node.value_type, node.value_flags, type, node.value_str, NULL, NULL, NULL);\n    lydict_remove(ctx, node.value_str);\n    if (tpdf && node.schema) {\n        free((char *)node.schema->name);\n        free(node.schema);\n    }\n    lydict_remove(ctx, dflt);\n\n    return ret;\n}\n\n/**\n * @brief Check a key for mandatory attributes. Logs directly.\n *\n * @param[in] key The key to check.\n * @param[in] flags What flags to check.\n * @param[in] list The list of all the keys.\n * @param[in] index Index of the key in the key list.\n * @param[in] name The name of the keys.\n * @param[in] len The name length.\n *\n * @return EXIT_SUCCESS on success, -1 on error.\n */\nstatic int\ncheck_key(struct lys_node_list *list, int index, const char *name, int len)\n{\n    struct lys_node_leaf *key = list->keys[index];\n    char *dup = NULL;\n    int j;\n    struct ly_ctx *ctx = list->module->ctx;\n\n    /* existence */\n    if (!key) {\n        if (name[len] != '\\0') {\n            dup = strdup(name);\n            LY_CHECK_ERR_RETURN(!dup, LOGMEM(ctx), -1);\n            dup[len] = '\\0';\n            name = dup;\n        }\n        LOGVAL(ctx, LYE_KEY_MISS, LY_VLOG_LYS, list, name);\n        free(dup);\n        return -1;\n    }\n\n    /* uniqueness */\n    for (j = index - 1; j >= 0; j--) {\n        if (key == list->keys[j]) {\n            LOGVAL(ctx, LYE_KEY_DUP, LY_VLOG_LYS, list, key->name);\n            return -1;\n        }\n    }\n\n    /* key is a leaf */\n    if (key->nodetype != LYS_LEAF) {\n        LOGVAL(ctx, LYE_KEY_NLEAF, LY_VLOG_LYS, list, key->name);\n        return -1;\n    }\n\n    /* type of the leaf is not built-in empty */\n    if (key->type.base == LY_TYPE_EMPTY && key->module->version < LYS_VERSION_1_1) {\n        LOGVAL(ctx, LYE_KEY_TYPE, LY_VLOG_LYS, list, key->name);\n        return -1;\n    }\n\n    /* config attribute is the same as of the list */\n    if ((key->flags & LYS_CONFIG_MASK) && (list->flags & LYS_CONFIG_MASK)\n            && ((list->flags & LYS_CONFIG_MASK) != (key->flags & LYS_CONFIG_MASK))) {\n        LOGVAL(ctx, LYE_KEY_CONFIG, LY_VLOG_LYS, list, key->name);\n        return -1;\n    }\n\n    /* key is not placed from augment */\n    if (key->parent->nodetype == LYS_AUGMENT) {\n        LOGVAL(ctx, LYE_KEY_MISS, LY_VLOG_LYS, key, key->name);\n        LOGVAL(ctx, LYE_SPEC, LY_VLOG_PREV, NULL, \"Key inserted from augment.\");\n        return -1;\n    }\n\n    /* key is not when/if-feature -conditional */\n    j = 0;\n    if (key->when || (key->iffeature_size && (j = 1))) {\n        LOGVAL(ctx, LYE_INCHILDSTMT, LY_VLOG_LYS, key, j ? \"if-feature\" : \"when\", \"leaf\");\n        LOGVAL(ctx, LYE_SPEC, LY_VLOG_PREV, NULL, \"Key definition cannot depend on a \\\"%s\\\" condition.\",\n               j ? \"if-feature\" : \"when\");\n        return -1;\n    }\n\n    return EXIT_SUCCESS;\n}\n\n/**\n * @brief Resolve (test the target exists) unique. Logs directly.\n *\n * @param[in] parent The parent node of the unique structure.\n * @param[in] uniq_str_path One path from the unique string.\n *\n * @return EXIT_SUCCESS on succes, EXIT_FAILURE on forward reference, -1 on error.\n */\nint\nresolve_unique(struct lys_node *parent, const char *uniq_str_path, uint8_t *trg_type)\n{\n    int rc;\n    const struct lys_node *leaf = NULL;\n    struct ly_ctx *ctx = parent->module->ctx;\n\n    rc = resolve_descendant_schema_nodeid(uniq_str_path, *lys_child(parent, LYS_LEAF), LYS_LEAF, 1, &leaf);\n    if (rc || !leaf) {\n        if (rc) {\n            LOGVAL(ctx, LYE_INARG, LY_VLOG_LYS, parent, uniq_str_path, \"unique\");\n            if (rc > 0) {\n                LOGVAL(ctx, LYE_INCHAR, LY_VLOG_PREV, NULL, uniq_str_path[rc - 1], &uniq_str_path[rc - 1]);\n            } else if (rc == -2) {\n                LOGVAL(ctx, LYE_SPEC, LY_VLOG_PREV, NULL, \"Unique argument references list.\");\n            }\n            rc = -1;\n        } else {\n            LOGVAL(ctx, LYE_INARG, LY_VLOG_LYS, parent, uniq_str_path, \"unique\");\n            LOGVAL(ctx, LYE_SPEC, LY_VLOG_PREV, NULL, \"Target leaf not found.\");\n            rc = EXIT_FAILURE;\n        }\n        goto error;\n    }\n    if (leaf->nodetype != LYS_LEAF) {\n        LOGVAL(ctx, LYE_INARG, LY_VLOG_LYS, parent, uniq_str_path, \"unique\");\n        LOGVAL(ctx, LYE_SPEC, LY_VLOG_PREV, NULL, \"Target is not a leaf.\");\n        return -1;\n    }\n\n    /* check status */\n    if (parent->nodetype != LYS_EXT && lyp_check_status(parent->flags, parent->module, parent->name,\n                                                        leaf->flags, leaf->module, leaf->name, leaf)) {\n        return -1;\n    }\n\n    /* check that all unique's targets are of the same config type */\n    if (*trg_type) {\n        if (((*trg_type == 1) && (leaf->flags & LYS_CONFIG_R)) || ((*trg_type == 2) && (leaf->flags & LYS_CONFIG_W))) {\n            LOGVAL(ctx, LYE_INARG, LY_VLOG_LYS, parent, uniq_str_path, \"unique\");\n            LOGVAL(ctx, LYE_SPEC, LY_VLOG_PREV, NULL,\n                   \"Leaf \\\"%s\\\" referenced in unique statement is config %s, but previous referenced leaf is config %s.\",\n                   uniq_str_path, *trg_type == 1 ? \"false\" : \"true\", *trg_type == 1 ? \"true\" : \"false\");\n            return -1;\n        }\n    } else {\n        /* first unique */\n        if (leaf->flags & LYS_CONFIG_W) {\n            *trg_type = 1;\n        } else {\n            *trg_type = 2;\n        }\n    }\n\n    /* set leaf's unique flag */\n    ((struct lys_node_leaf *)leaf)->flags |= LYS_UNIQUE;\n\n    return EXIT_SUCCESS;\n\nerror:\n\n    return rc;\n}\n\nvoid\nunres_data_del(struct unres_data *unres, uint32_t i)\n{\n    /* there are items after the one deleted */\n    if (i+1 < unres->count) {\n        /* we only move the data, memory is left allocated, why bother */\n        memmove(&unres->node[i], &unres->node[i+1], (unres->count-(i+1)) * sizeof *unres->node);\n\n    /* deleting the last item */\n    } else if (i == 0) {\n        free(unres->node);\n        unres->node = NULL;\n    }\n\n    /* if there are no items after and it is not the last one, just move the counter */\n    --unres->count;\n}\n\n/**\n * @brief Resolve (find) a data node from a specific module. Does not log.\n *\n * @param[in] mod Module to search in.\n * @param[in] name Name of the data node.\n * @param[in] nam_len Length of the name.\n * @param[in] start Data node to start the search from.\n * @param[in,out] parents Resolved nodes. If there are some parents,\n *                        they are replaced (!!) with the resolvents.\n *\n * @return EXIT_SUCCESS on success, EXIT_FAILURE on forward reference, -1 on error.\n */\nstatic int\nresolve_data(const struct lys_module *mod, const char *name, int nam_len, struct lyd_node *start, struct unres_data *parents)\n{\n    struct lyd_node *node;\n    int flag;\n    uint32_t i;\n\n    if (!parents->count) {\n        parents->count = 1;\n        parents->node = malloc(sizeof *parents->node);\n        LY_CHECK_ERR_RETURN(!parents->node, LOGMEM(mod->ctx), -1);\n        parents->node[0] = NULL;\n    }\n    for (i = 0; i < parents->count;) {\n        if (parents->node[i] && (parents->node[i]->schema->nodetype & (LYS_LEAF | LYS_LEAFLIST | LYS_ANYDATA))) {\n            /* skip */\n            ++i;\n            continue;\n        }\n        flag = 0;\n        LY_TREE_FOR(parents->node[i] ? parents->node[i]->child : start, node) {\n            if (lyd_node_module(node) == mod && !strncmp(node->schema->name, name, nam_len)\n                    && node->schema->name[nam_len] == '\\0') {\n                /* matching target */\n                if (!flag) {\n                    /* put node instead of the current parent */\n                    parents->node[i] = node;\n                    flag = 1;\n                } else {\n                    /* multiple matching, so create a new node */\n                    ++parents->count;\n                    parents->node = ly_realloc(parents->node, parents->count * sizeof *parents->node);\n                    LY_CHECK_ERR_RETURN(!parents->node, LOGMEM(mod->ctx), EXIT_FAILURE);\n                    parents->node[parents->count-1] = node;\n                    ++i;\n                }\n            }\n        }\n\n        if (!flag) {\n            /* remove item from the parents list */\n            unres_data_del(parents, i);\n        } else {\n            ++i;\n        }\n    }\n\n    return parents->count ? EXIT_SUCCESS : EXIT_FAILURE;\n}\n\nstatic int\nresolve_schema_leafref_valid_dep_flag(const struct lys_node *op_node, const struct lys_module *local_mod,\n                                      const struct lys_node *first_node, int abs_path)\n{\n    int dep1, dep2;\n    const struct lys_node *node;\n\n    if (!op_node) {\n        /* leafref pointing to a different module */\n        if (local_mod != lys_node_module(first_node)) {\n            return 1;\n        }\n    } else if (lys_parent(op_node)) {\n        /* inner operation (notif/action) */\n        if (abs_path) {\n            return 1;\n        } else {\n            /* compare depth of both nodes */\n            for (dep1 = 0, node = op_node; lys_parent(node); node = lys_parent(node));\n            for (dep2 = 0, node = first_node; lys_parent(node); node = lys_parent(node));\n            if ((dep2 > dep1) || ((dep2 == dep1) && (op_node != first_node))) {\n                return 1;\n            }\n        }\n    } else {\n        /* top-level operation (notif/rpc) */\n        if (op_node != first_node) {\n            return 1;\n        }\n    }\n\n    return 0;\n}\n\n/**\n * @brief Resolve a path (leafref) predicate in JSON schema context. Logs directly.\n *\n * @param[in] path Path to use.\n * @param[in] context_node Predicate context node (where the predicate is placed).\n * @param[in] parent Path context node (where the path begins/is placed).\n * @param[in] node_set Set where to add nodes whose parent chain must be implemented.\n *\n * @return 0 on forward reference, otherwise the number\n *         of characters successfully parsed,\n *         positive on success, negative on failure.\n */\nstatic int\nresolve_schema_leafref_predicate(const char *path, const struct lys_node *context_node, struct lys_node *parent,\n                                 struct ly_set *node_set)\n{\n    const struct lys_module *trg_mod;\n    const struct lys_node *src_node, *dst_node, *tmp_parent;\n    struct lys_node_augment *last_aug;\n    const char *path_key_expr, *source, *sour_pref, *dest, *dest_pref;\n    int pke_len, sour_len, sour_pref_len, dest_len, dest_pref_len, pke_parsed, parsed = 0;\n    int has_predicate, dest_parent_times, i, rc;\n    struct ly_ctx *ctx = context_node->module->ctx;\n\n    do {\n        if ((i = parse_path_predicate(path, &sour_pref, &sour_pref_len, &source, &sour_len, &path_key_expr,\n                                      &pke_len, &has_predicate)) < 1) {\n            LOGVAL(ctx, LYE_INCHAR, LY_VLOG_LYS, parent, path[-i], path - i);\n            return -parsed + i;\n        }\n        parsed += i;\n        path += i;\n\n        /* source (must be leaf) */\n        if (sour_pref) {\n            trg_mod = lyp_get_module(lys_node_module(parent), NULL, 0, sour_pref, sour_pref_len, 0);\n        } else {\n            trg_mod = lys_node_module(parent);\n        }\n        rc = lys_getnext_data(trg_mod, context_node, source, sour_len, LYS_LEAF | LYS_LEAFLIST, LYS_GETNEXT_NOSTATECHECK,\n                              &src_node);\n        if (rc) {\n            LOGVAL(ctx, LYE_NORESOLV, LY_VLOG_LYS, parent, \"leafref predicate\", path-parsed);\n            return 0;\n        }\n\n        /* destination */\n        dest_parent_times = 0;\n        pke_parsed = 0;\n        if ((i = parse_path_key_expr(path_key_expr, &dest_pref, &dest_pref_len, &dest, &dest_len,\n                                     &dest_parent_times)) < 1) {\n            LOGVAL(ctx, LYE_INCHAR, LY_VLOG_LYS, parent, path_key_expr[-i], path_key_expr-i);\n            return -parsed;\n        }\n        pke_parsed += i;\n\n        for (i = 0, dst_node = parent; i < dest_parent_times; ++i) {\n            if (!dst_node) {\n                /* we went too much into parents, there is no parent anymore */\n                LOGVAL(ctx, LYE_NORESOLV, LY_VLOG_LYS, parent, \"leafref predicate\", path_key_expr);\n                return 0;\n            }\n\n            if (dst_node->parent && (dst_node->parent->nodetype == LYS_AUGMENT)\n                    && !((struct lys_node_augment *)dst_node->parent)->target) {\n                /* we are in an unresolved augment, cannot evaluate */\n                LOGVAL(ctx, LYE_SPEC, LY_VLOG_LYS, dst_node->parent,\n                       \"Cannot resolve leafref predicate \\\"%s\\\" because it is in an unresolved augment.\", path_key_expr);\n                return 0;\n            }\n\n            /* path is supposed to be evaluated in data tree, so we have to skip\n             * all schema nodes that cannot be instantiated in data tree */\n            for (dst_node = lys_parent(dst_node);\n                 dst_node && !(dst_node->nodetype & (LYS_CONTAINER | LYS_LIST | LYS_ACTION | LYS_NOTIF | LYS_RPC));\n                 dst_node = lys_parent(dst_node));\n        }\n        while (1) {\n            last_aug = NULL;\n\n            if (dest_pref) {\n                trg_mod = lyp_get_module(lys_node_module(parent), NULL, 0, dest_pref, dest_pref_len, 0);\n            } else {\n                trg_mod = lys_node_module(parent);\n            }\n\n            if (!trg_mod->implemented && dst_node) {\n    get_next_augment:\n                last_aug = lys_getnext_target_aug(last_aug, trg_mod, dst_node);\n            }\n\n            tmp_parent = (last_aug ? (struct lys_node *)last_aug : dst_node);\n            rc = lys_getnext_data(trg_mod, tmp_parent, dest, dest_len, LYS_CONTAINER | LYS_LIST | LYS_LEAF,\n                                  LYS_GETNEXT_NOSTATECHECK, &dst_node);\n            if (rc) {\n                if (last_aug) {\n                    /* restore the correct augment target */\n                    dst_node = last_aug->target;\n                    goto get_next_augment;\n                }\n                LOGVAL(ctx, LYE_NORESOLV, LY_VLOG_LYS, parent, \"leafref predicate\", path_key_expr);\n                return 0;\n            }\n\n            if (pke_len == pke_parsed) {\n                break;\n            }\n\n            if ((i = parse_path_key_expr(path_key_expr + pke_parsed, &dest_pref, &dest_pref_len, &dest, &dest_len,\n                                         &dest_parent_times)) < 1) {\n                LOGVAL(ctx, LYE_INCHAR, LY_VLOG_LYS, parent,\n                       (path_key_expr + pke_parsed)[-i], (path_key_expr + pke_parsed) - i);\n                return -parsed;\n            }\n            pke_parsed += i;\n        }\n\n        /* check source - dest match */\n        if (dst_node->nodetype != src_node->nodetype) {\n            LOGVAL(ctx, LYE_NORESOLV, LY_VLOG_LYS, parent, \"leafref predicate\", path - parsed);\n            LOGVAL(ctx, LYE_SPEC, LY_VLOG_PREV, NULL, \"Destination node is not a %s, but a %s.\",\n                   strnodetype(src_node->nodetype), strnodetype(dst_node->nodetype));\n            return -parsed;\n        }\n\n        /* add both nodes into node set */\n        ly_set_add(node_set, (void *)dst_node, 0);\n        ly_set_add(node_set, (void *)src_node, 0);\n    } while (has_predicate);\n\n    return parsed;\n}\n\nstatic int\ncheck_leafref_features(struct lys_type *type)\n{\n    struct lys_node *iter;\n    struct ly_set *src_parents, *trg_parents, *features;\n    struct lys_node_augment *aug;\n    struct ly_ctx *ctx = ((struct lys_tpdf *)type->parent)->module->ctx;\n    unsigned int i, j, size, x;\n    int ret = EXIT_SUCCESS;\n\n    assert(type->parent);\n\n    src_parents = ly_set_new();\n    trg_parents = ly_set_new();\n    features = ly_set_new();\n\n    /* get parents chain of source (leafref) */\n    for (iter = (struct lys_node *)type->parent; iter; iter = lys_parent(iter)) {\n        if (iter->nodetype & (LYS_INPUT | LYS_OUTPUT)) {\n            continue;\n        }\n        if (iter->parent && (iter->parent->nodetype == LYS_AUGMENT)) {\n            aug = (struct lys_node_augment *)iter->parent;\n            if ((aug->module->implemented && (aug->flags & LYS_NOTAPPLIED)) || !aug->target) {\n                /* unresolved augment, wait until it's resolved */\n                LOGVAL(ctx, LYE_SPEC, LY_VLOG_LYS, aug,\n                       \"Cannot check leafref \\\"%s\\\" if-feature consistency because of an unresolved augment.\", type->info.lref.path);\n                ret = EXIT_FAILURE;\n                goto cleanup;\n            }\n            /* also add this augment */\n            ly_set_add(src_parents, aug, LY_SET_OPT_USEASLIST);\n        }\n        ly_set_add(src_parents, iter, LY_SET_OPT_USEASLIST);\n    }\n    /* get parents chain of target */\n    for (iter = (struct lys_node *)type->info.lref.target; iter; iter = lys_parent(iter)) {\n        if (iter->nodetype & (LYS_INPUT | LYS_OUTPUT)) {\n            continue;\n        }\n        if (iter->parent && (iter->parent->nodetype == LYS_AUGMENT)) {\n            aug = (struct lys_node_augment *)iter->parent;\n            if ((aug->module->implemented && (aug->flags & LYS_NOTAPPLIED)) || !aug->target) {\n                /* unresolved augment, wait until it's resolved */\n                LOGVAL(ctx, LYE_SPEC, LY_VLOG_LYS, aug,\n                       \"Cannot check leafref \\\"%s\\\" if-feature consistency because of an unresolved augment.\", type->info.lref.path);\n                ret = EXIT_FAILURE;\n                goto cleanup;\n            }\n        }\n        ly_set_add(trg_parents, iter, LY_SET_OPT_USEASLIST);\n    }\n\n    /* compare the features used in if-feature statements in the rest of both\n     * chains of parents. The set of features used for target must be a subset\n     * of features used for the leafref. This is not a perfect, we should compare\n     * the truth tables but it could require too much resources, so we simplify that */\n    for (i = 0; i < src_parents->number; i++) {\n        iter = src_parents->set.s[i]; /* shortcut */\n        if (!iter->iffeature_size) {\n            continue;\n        }\n        for (j = 0; j < iter->iffeature_size; j++) {\n            resolve_iffeature_getsizes(&iter->iffeature[j], NULL, &size);\n            for (; size; size--) {\n                if (!iter->iffeature[j].features[size - 1]) {\n                    /* not yet resolved feature, postpone this check */\n                    ret = EXIT_FAILURE;\n                    goto cleanup;\n                }\n                ly_set_add(features, iter->iffeature[j].features[size - 1], 0);\n            }\n        }\n    }\n    x = features->number;\n    for (i = 0; i < trg_parents->number; i++) {\n        iter = trg_parents->set.s[i]; /* shortcut */\n        if (!iter->iffeature_size) {\n            continue;\n        }\n        for (j = 0; j < iter->iffeature_size; j++) {\n            resolve_iffeature_getsizes(&iter->iffeature[j], NULL, &size);\n            for (; size; size--) {\n                if (!iter->iffeature[j].features[size - 1]) {\n                    /* not yet resolved feature, postpone this check */\n                    ret = EXIT_FAILURE;\n                    goto cleanup;\n                }\n                if ((unsigned)ly_set_add(features, iter->iffeature[j].features[size - 1], 0) >= x) {\n                    /* the feature is not present in features set of target's parents chain */\n                    LOGVAL(ctx, LYE_NORESOLV, LY_VLOG_LYS, type->parent, \"leafref\", type->info.lref.path);\n                    LOGVAL(ctx, LYE_SPEC, LY_VLOG_PREV, NULL,\n                           \"Leafref is not conditional based on \\\"%s\\\" feature as its target.\",\n                           iter->iffeature[j].features[size - 1]->name);\n                    ret = -1;\n                    goto cleanup;\n                }\n            }\n        }\n    }\n\ncleanup:\n    ly_set_free(features);\n    ly_set_free(src_parents);\n    ly_set_free(trg_parents);\n\n    return ret;\n}\n\n/**\n * @brief Resolve a path (leafref) in JSON schema context. Logs directly.\n *\n * @param[in] path Path to use.\n * @param[in] parent_node Parent of the leafref.\n * @param[out] ret Pointer to the resolved schema node. Can be NULL.\n *\n * @return EXIT_SUCCESS on success, EXIT_FAILURE on forward reference, -1 on error.\n */\nstatic int\nresolve_schema_leafref(struct lys_type *type, struct lys_node *parent, struct unres_schema *unres)\n{\n    const struct lys_node *node, *op_node = NULL, *tmp_parent;\n    struct ly_set *node_set;\n    struct lys_node_augment *last_aug;\n    const struct lys_module *tmp_mod, *cur_module;\n    const char *id, *prefix, *name;\n    int pref_len, nam_len, parent_times, has_predicate;\n    int i, first_iter;\n    struct ly_ctx *ctx = parent->module->ctx;\n\n    first_iter = 1;\n    parent_times = 0;\n    id = type->info.lref.path;\n    node_set = ly_set_new();\n    if (!node_set) {\n        LOGMEM(ctx);\n        return -1;\n    }\n\n    /* find operation schema we are in */\n    for (op_node = lys_parent(parent);\n        op_node && !(op_node->nodetype & (LYS_ACTION | LYS_NOTIF | LYS_RPC));\n        op_node = lys_parent(op_node));\n\n    cur_module = lys_node_module(parent);\n    do {\n        if ((i = parse_path_arg(cur_module, id, &prefix, &pref_len, &name, &nam_len, &parent_times, &has_predicate)) < 1) {\n            LOGVAL(ctx, LYE_INCHAR, LY_VLOG_LYS, parent, id[-i], &id[-i]);\n            ly_set_free(node_set);\n            return -1;\n        }\n        id += i;\n\n        /* get the current module */\n        tmp_mod = prefix ? lyp_get_module(cur_module, NULL, 0, prefix, pref_len, 0) : cur_module;\n        if (!tmp_mod) {\n            LOGVAL(ctx, LYE_NORESOLV, LY_VLOG_LYS, parent, \"leafref\", type->info.lref.path);\n            ly_set_free(node_set);\n            return EXIT_FAILURE;\n        }\n        last_aug = NULL;\n\n        if (first_iter) {\n            if (parent_times == -1) {\n                /* use module data */\n                node = NULL;\n\n            } else if (parent_times > 0) {\n                /* we are looking for the right parent */\n                for (i = 0, node = parent; i < parent_times; i++) {\n                    if (node->parent && (node->parent->nodetype == LYS_AUGMENT)\n                            && !((struct lys_node_augment *)node->parent)->target) {\n                        /* we are in an unresolved augment, cannot evaluate */\n                        LOGVAL(ctx, LYE_SPEC, LY_VLOG_LYS, node->parent,\n                            \"Cannot resolve leafref \\\"%s\\\" because it is in an unresolved augment.\", type->info.lref.path);\n                        ly_set_free(node_set);\n                        return EXIT_FAILURE;\n                    }\n\n                    /* path is supposed to be evaluated in data tree, so we have to skip\n                     * all schema nodes that cannot be instantiated in data tree */\n                    for (node = lys_parent(node);\n                        node && !(node->nodetype & (LYS_CONTAINER | LYS_LIST | LYS_ACTION | LYS_NOTIF | LYS_RPC));\n                        node = lys_parent(node));\n\n                    if (!node) {\n                        if (i == parent_times - 1) {\n                            /* top-level */\n                            break;\n                        }\n\n                        /* higher than top-level */\n                        LOGVAL(ctx, LYE_NORESOLV, LY_VLOG_LYS, parent, \"leafref\", type->info.lref.path);\n                        ly_set_free(node_set);\n                        return EXIT_FAILURE;\n                    }\n                }\n            } else {\n                LOGINT(ctx);\n                ly_set_free(node_set);\n                return -1;\n            }\n        }\n\n        /* find the next node (either in unconnected augment or as a schema sibling, node is NULL for top-level node -\n         * - useless to search for that in augments) */\n        if (!tmp_mod->implemented && node) {\n    get_next_augment:\n            last_aug = lys_getnext_target_aug(last_aug, tmp_mod, node);\n        }\n\n        tmp_parent = (last_aug ? (struct lys_node *)last_aug : node);\n        node = NULL;\n        while ((node = lys_getnext(node, tmp_parent, tmp_mod, LYS_GETNEXT_NOSTATECHECK))) {\n            if (lys_node_module(node) != lys_main_module(tmp_mod)) {\n                continue;\n            }\n            if (strncmp(node->name, name, nam_len) || node->name[nam_len]) {\n                continue;\n            }\n            /* match */\n            break;\n        }\n        if (!node) {\n            if (last_aug) {\n                /* restore the correct augment target */\n                node = last_aug->target;\n                goto get_next_augment;\n            }\n            LOGVAL(ctx, LYE_NORESOLV, LY_VLOG_LYS, parent, \"leafref\", type->info.lref.path);\n            ly_set_free(node_set);\n            return EXIT_FAILURE;\n        }\n\n        if (first_iter) {\n            /* set external dependency flag, we can decide based on the first found node */\n            if (resolve_schema_leafref_valid_dep_flag(op_node, cur_module, node, (parent_times == -1 ? 1 : 0))) {\n                parent->flags |= LYS_LEAFREF_DEP;\n            }\n            first_iter = 0;\n        }\n\n        if (has_predicate) {\n            /* we have predicate, so the current result must be list */\n            if (node->nodetype != LYS_LIST) {\n                LOGVAL(ctx, LYE_NORESOLV, LY_VLOG_LYS, parent, \"leafref\", type->info.lref.path);\n                ly_set_free(node_set);\n                return -1;\n            }\n\n            i = resolve_schema_leafref_predicate(id, node, parent, node_set);\n            if (!i) {\n                ly_set_free(node_set);\n                return EXIT_FAILURE;\n            } else if (i < 0) {\n                ly_set_free(node_set);\n                return -1;\n            }\n            id += i;\n            has_predicate = 0;\n        }\n    } while (id[0]);\n\n    /* the target must be leaf or leaf-list (in YANG 1.1 only) */\n    if ((node->nodetype != LYS_LEAF) && (node->nodetype != LYS_LEAFLIST)) {\n        LOGVAL(ctx, LYE_NORESOLV, LY_VLOG_LYS, parent, \"leafref\", type->info.lref.path);\n        LOGVAL(ctx, LYE_SPEC, LY_VLOG_PREV, NULL, \"Leafref target \\\"%s\\\" is not a leaf nor a leaf-list.\", type->info.lref.path);\n        ly_set_free(node_set);\n        return -1;\n    }\n\n    /* check status */\n    if (lyp_check_status(parent->flags, parent->module, parent->name,\n                    node->flags, node->module, node->name, node)) {\n        ly_set_free(node_set);\n        return -1;\n    }\n\n    /* assign */\n    type->info.lref.target = (struct lys_node_leaf *)node;\n\n    /* add the target node into a set so its parent chain modules can be implemented */\n    ly_set_add(node_set, (void *)node, 0);\n\n    /* as the last thing traverse this leafref and make targets on the path implemented */\n    if (lys_node_module(parent)->implemented) {\n        /* make all the modules in the path implemented */\n        for (i = 0; (unsigned)i < node_set->number; ++i) {\n            for (node = node_set->set.s[i]; node; node = lys_parent(node)) {\n                if (!lys_node_module(node)->implemented) {\n                    lys_node_module(node)->implemented = 1;\n                    if (unres_schema_add_node(lys_node_module(node), unres, NULL, UNRES_MOD_IMPLEMENT, NULL) == -1) {\n                        ly_set_free(node_set);\n                        return -1;\n                    }\n                }\n            }\n        }\n\n        /* store the backlink from leafref target */\n        if (lys_leaf_add_leafref_target(type->info.lref.target, (struct lys_node *)type->parent)) {\n            ly_set_free(node_set);\n            return -1;\n        }\n    }\n    ly_set_free(node_set);\n\n    /* check if leafref and its target are under common if-features */\n    return check_leafref_features(type);\n}\n\n/**\n * @brief Compare 2 data node values.\n *\n * Comparison performed on canonical forms, the first value\n * is first transformed into canonical form.\n *\n * @param[in] node Leaf/leaf-list with these values.\n * @param[in] noncan_val Non-canonical value.\n * @param[in] noncan_val_len Length of \\p noncal_val.\n * @param[in] can_val Canonical value.\n * @return 1 if equal, 0 if not, -1 on error (logged).\n */\nstatic int\nvalequal(struct lys_node *node, const char *noncan_val, int noncan_val_len, const char *can_val)\n{\n    int ret;\n    struct lyd_node_leaf_list leaf;\n    struct lys_node_leaf *sleaf = (struct lys_node_leaf*)node;\n\n    /* dummy leaf */\n    memset(&leaf, 0, sizeof leaf);\n    leaf.value_str = lydict_insert(node->module->ctx, noncan_val, noncan_val_len);\n\nrepeat:\n    leaf.value_type = sleaf->type.base;\n    leaf.schema = node;\n\n    if (leaf.value_type == LY_TYPE_LEAFREF) {\n        if (!sleaf->type.info.lref.target) {\n            /* it should either be unresolved leafref (leaf.value_type are ORed flags) or it will be resolved */\n            LOGINT(node->module->ctx);\n            ret = -1;\n            goto finish;\n        }\n        sleaf = sleaf->type.info.lref.target;\n        goto repeat;\n    } else {\n        if (!lyp_parse_value(&sleaf->type, &leaf.value_str, NULL, &leaf, NULL, NULL, 0, 0, 0)) {\n            ret = -1;\n            goto finish;\n        }\n    }\n\n    if (!strcmp(leaf.value_str, can_val)) {\n        ret = 1;\n    } else {\n        ret = 0;\n    }\n\nfinish:\n    lydict_remove(node->module->ctx, leaf.value_str);\n    return ret;\n}\n\n/**\n * @brief Resolve instance-identifier predicate in JSON data format.\n *        Does not log.\n *\n * @param[in] prev_mod Previous module to use in case there is no prefix.\n * @param[in] pred Predicate to use.\n * @param[in,out] node Node matching the restriction without\n *                     the predicate. If it does not satisfy the predicate,\n *                     it is set to NULL.\n *\n * @return Number of characters successfully parsed,\n *         positive on success, negative on failure.\n */\nstatic int\nresolve_instid_predicate(const struct lys_module *prev_mod, const char *pred, struct lyd_node **node, int cur_idx)\n{\n    /* ... /node[key=value] ... */\n    struct lyd_node_leaf_list *key;\n    struct lys_node_leaf **list_keys = NULL;\n    struct lys_node_list *slist = NULL;\n    const char *model, *name, *value;\n    int mod_len, nam_len, val_len, i, has_predicate, parsed;\n    struct ly_ctx *ctx = prev_mod->ctx;\n\n    assert(pred && node && *node);\n\n    parsed = 0;\n    do {\n        if ((i = parse_predicate(pred + parsed, &model, &mod_len, &name, &nam_len, &value, &val_len, &has_predicate)) < 1) {\n            return -parsed + i;\n        }\n        parsed += i;\n\n        if (!(*node)) {\n            /* just parse it all */\n            continue;\n        }\n\n        /* target */\n        if (name[0] == '.') {\n            /* leaf-list value */\n            if ((*node)->schema->nodetype != LYS_LEAFLIST) {\n                LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Instance identifier expects leaf-list, but have %s \\\"%s\\\".\",\n                       strnodetype((*node)->schema->nodetype), (*node)->schema->name);\n                parsed = -1;\n                goto cleanup;\n            }\n\n            /* check the value */\n            if (!valequal((*node)->schema, value, val_len, ((struct lyd_node_leaf_list *)*node)->value_str)) {\n                *node = NULL;\n                goto cleanup;\n            }\n\n        } else if (isdigit(name[0])) {\n            assert(!value);\n\n            /* keyless list position */\n            if ((*node)->schema->nodetype != LYS_LIST) {\n                LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Instance identifier expects list, but have %s \\\"%s\\\".\",\n                       strnodetype((*node)->schema->nodetype), (*node)->schema->name);\n                parsed = -1;\n                goto cleanup;\n            }\n\n            if (((struct lys_node_list *)(*node)->schema)->keys) {\n                LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Instance identifier expects list without keys, but have list \\\"%s\\\".\",\n                       (*node)->schema->name);\n                parsed = -1;\n                goto cleanup;\n            }\n\n            /* check the index */\n            if (atoi(name) != cur_idx) {\n                *node = NULL;\n                goto cleanup;\n            }\n\n        } else {\n            /* list key value */\n            if ((*node)->schema->nodetype != LYS_LIST) {\n                LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Instance identifier expects list, but have %s \\\"%s\\\".\",\n                       strnodetype((*node)->schema->nodetype), (*node)->schema->name);\n                parsed = -1;\n                goto cleanup;\n            }\n            slist = (struct lys_node_list *)(*node)->schema;\n\n            /* prepare key array */\n            if (!list_keys) {\n                list_keys = malloc(slist->keys_size * sizeof *list_keys);\n                LY_CHECK_ERR_RETURN(!list_keys, LOGMEM(ctx), -1);\n                for (i = 0; i < slist->keys_size; ++i) {\n                    list_keys[i] = slist->keys[i];\n                }\n            }\n\n            /* find the schema key leaf */\n            for (i = 0; i < slist->keys_size; ++i) {\n                if (list_keys[i] && !strncmp(list_keys[i]->name, name, nam_len) && !list_keys[i]->name[nam_len]) {\n                    break;\n                }\n            }\n            if (i == slist->keys_size) {\n                /* this list has no such key */\n                LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Instance identifier expects list with the key \\\"%.*s\\\",\"\n                       \" but list \\\"%s\\\" does not define it.\", nam_len, name, slist->name);\n                parsed = -1;\n                goto cleanup;\n            }\n\n            /* check module */\n            if (model) {\n                if (strncmp(list_keys[i]->module->name, model, mod_len) || list_keys[i]->module->name[mod_len]) {\n                    LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Instance identifier expects key \\\"%s\\\" from module \\\"%.*s\\\", not \\\"%s\\\".\",\n                           list_keys[i]->name, model, mod_len, list_keys[i]->module->name);\n                    parsed = -1;\n                    goto cleanup;\n                }\n            } else {\n                if (list_keys[i]->module != prev_mod) {\n                    LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Instance identifier expects key \\\"%s\\\" from module \\\"%s\\\", not \\\"%s\\\".\",\n                           list_keys[i]->name, prev_mod->name, list_keys[i]->module->name);\n                    parsed = -1;\n                    goto cleanup;\n                }\n            }\n\n            /* find the actual data key */\n            for (key = (struct lyd_node_leaf_list *)(*node)->child; key; key = (struct lyd_node_leaf_list *)key->next) {\n                if (key->schema == (struct lys_node *)list_keys[i]) {\n                    break;\n                }\n            }\n            if (!key) {\n                /* list instance is missing a key? definitely should not happen */\n                LOGINT(ctx);\n                parsed = -1;\n                goto cleanup;\n            }\n\n            /* check the value */\n            if (!valequal(key->schema, value, val_len, key->value_str)) {\n                *node = NULL;\n                /* we still want to parse the whole predicate */\n                continue;\n            }\n\n            /* everything is fine, mark this key as resolved */\n            list_keys[i] = NULL;\n        }\n    } while (has_predicate);\n\n    /* check that all list keys were specified */\n    if (*node && list_keys) {\n        for (i = 0; i < slist->keys_size; ++i) {\n            if (list_keys[i]) {\n                LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Instance identifier is missing list key \\\"%s\\\".\", list_keys[i]->name);\n                parsed = -1;\n                goto cleanup;\n            }\n        }\n    }\n\ncleanup:\n    free(list_keys);\n    return parsed;\n}\n\nstatic int\ncheck_xpath(struct lys_node *node, int check_place)\n{\n    struct lys_node *parent;\n    struct lyxp_set set;\n    enum int_log_opts prev_ilo;\n\n    if (check_place) {\n        parent = node;\n        while (parent) {\n            if (parent->nodetype == LYS_GROUPING) {\n                /* unresolved grouping, skip for now (will be checked later) */\n                return EXIT_SUCCESS;\n            }\n            if (parent->nodetype == LYS_AUGMENT) {\n                if (!((struct lys_node_augment *)parent)->target) {\n                    /* unresolved augment, skip for now (will be checked later) */\n                    return EXIT_FAILURE;\n                } else {\n                    parent = ((struct lys_node_augment *)parent)->target;\n                    continue;\n                }\n            }\n            parent = parent->parent;\n        }\n    }\n\n    memset(&set, 0, sizeof set);\n\n    /* produce just warnings */\n    ly_ilo_change(NULL, ILO_ERR2WRN, &prev_ilo, NULL);\n    lyxp_node_atomize(node, &set, 1);\n    ly_ilo_restore(NULL, prev_ilo, NULL, 0);\n\n    if (set.val.snodes) {\n        free(set.val.snodes);\n    }\n    return EXIT_SUCCESS;\n}\n\nstatic int\ncheck_leafref_config(struct lys_node_leaf *leaf, struct lys_type *type)\n{\n    unsigned int i;\n\n    if (type->base == LY_TYPE_LEAFREF) {\n        if ((leaf->flags & LYS_CONFIG_W) && type->info.lref.target && type->info.lref.req != -1 &&\n                (type->info.lref.target->flags & LYS_CONFIG_R)) {\n            LOGVAL(leaf->module->ctx, LYE_SPEC, LY_VLOG_LYS, leaf, \"The leafref %s is config but refers to a non-config %s.\",\n                   strnodetype(leaf->nodetype), strnodetype(type->info.lref.target->nodetype));\n            return -1;\n        }\n        /* we can skip the test in case the leafref is not yet resolved. In that case the test is done in the time\n         * of leafref resolving (lys_leaf_add_leafref_target()) */\n    } else if (type->base == LY_TYPE_UNION) {\n        for (i = 0; i < type->info.uni.count; i++) {\n            if (check_leafref_config(leaf, &type->info.uni.types[i])) {\n                return -1;\n            }\n        }\n    }\n    return 0;\n}\n\n/**\n * @brief Passes config flag down to children, skips nodes without config flags.\n * Logs.\n *\n * @param[in] node Siblings and their children to have flags changed.\n * @param[in] clear Flag to clear all config flags if parent is LYS_NOTIF, LYS_INPUT, LYS_OUTPUT, LYS_RPC.\n * @param[in] flags Flags to assign to all the nodes.\n * @param[in,out] unres List of unresolved items.\n *\n * @return 0 on success, -1 on error.\n */\nint\ninherit_config_flag(struct lys_node *node, int flags, int clear)\n{\n    struct lys_node_leaf *leaf;\n    struct ly_ctx *ctx;\n\n    if (!node) {\n        return 0;\n    }\n\n    assert(!(flags ^ (flags & LYS_CONFIG_MASK)));\n    ctx = node->module->ctx;\n\n    LY_TREE_FOR(node, node) {\n        if (clear) {\n            node->flags &= ~LYS_CONFIG_MASK;\n            node->flags &= ~LYS_CONFIG_SET;\n        } else {\n            if (node->flags & LYS_CONFIG_SET) {\n                /* skip nodes with an explicit config value */\n                if ((flags & LYS_CONFIG_R) && (node->flags & LYS_CONFIG_W)) {\n                    LOGVAL(ctx, LYE_INARG, LY_VLOG_LYS, node, \"true\", \"config\");\n                    LOGVAL(ctx, LYE_SPEC, LY_VLOG_PREV, NULL, \"State nodes cannot have configuration nodes as children.\");\n                    return -1;\n                }\n                continue;\n            }\n\n            if (!(node->nodetype & (LYS_USES | LYS_GROUPING))) {\n                node->flags = (node->flags & ~LYS_CONFIG_MASK) | flags;\n                /* check that configuration lists have keys */\n                if ((node->nodetype == LYS_LIST) && (node->flags & LYS_CONFIG_W)\n                        && !((struct lys_node_list *)node)->keys_size) {\n                    LOGVAL(ctx, LYE_MISSCHILDSTMT, LY_VLOG_LYS, node, \"key\", \"list\");\n                    return -1;\n                }\n            }\n        }\n        if (!(node->nodetype & (LYS_LEAF | LYS_LEAFLIST | LYS_ANYDATA))) {\n            if (inherit_config_flag(node->child, flags, clear)) {\n                return -1;\n            }\n        } else if (node->nodetype & (LYS_LEAF | LYS_LEAFLIST)) {\n            leaf = (struct lys_node_leaf *)node;\n            if (check_leafref_config(leaf, &leaf->type)) {\n                return -1;\n            }\n        }\n    }\n\n    return 0;\n}\n\n/**\n * @brief Resolve augment target. Logs directly.\n *\n * @param[in] aug Augment to use.\n * @param[in] uses Parent where to start the search in. If set, uses augment, if not, standalone augment.\n * @param[in,out] unres List of unresolved items.\n *\n * @return EXIT_SUCCESS on success, EXIT_FAILURE on forward reference, -1 on error.\n */\nstatic int\nresolve_augment(struct lys_node_augment *aug, struct lys_node *uses, struct unres_schema *unres)\n{\n    int rc;\n    struct lys_node *sub;\n    struct lys_module *mod;\n    struct ly_set *set;\n    struct ly_ctx *ctx;\n\n    assert(aug);\n    mod = lys_main_module(aug->module);\n    ctx = mod->ctx;\n\n    /* set it as not applied for now */\n    aug->flags |= LYS_NOTAPPLIED;\n\n    /* it can already be resolved in case we returned EXIT_FAILURE from if block below */\n    if (!aug->target) {\n        /* resolve target node */\n        rc = resolve_schema_nodeid(aug->target_name, uses, (uses ? NULL : lys_node_module((struct lys_node *)aug)), &set, 0, 0);\n        if (rc == -1) {\n            LOGVAL(ctx, LYE_PATH, LY_VLOG_LYS, aug);\n            return -1;\n        }\n        if (!set) {\n            LOGVAL(ctx, LYE_INRESOLV, LY_VLOG_LYS, aug, \"augment\", aug->target_name);\n            return EXIT_FAILURE;\n        }\n        aug->target = set->set.s[0];\n        ly_set_free(set);\n    }\n\n    /* make this module implemented if the target module is (if the target is in an unimplemented module,\n     * it is fine because when we will be making that module implemented, its augment will be applied\n     * and that augment target module made implemented, recursively) */\n    if (mod->implemented && !lys_node_module(aug->target)->implemented) {\n        lys_node_module(aug->target)->implemented = 1;\n        if (unres_schema_add_node(lys_node_module(aug->target), unres, NULL, UNRES_MOD_IMPLEMENT, NULL) == -1) {\n            return -1;\n        }\n    }\n\n    /* check for mandatory nodes - if the target node is in another module\n     * the added nodes cannot be mandatory\n     */\n    if (!aug->parent && (lys_node_module((struct lys_node *)aug) != lys_node_module(aug->target))\n            && (rc = lyp_check_mandatory_augment(aug, aug->target))) {\n        return rc;\n    }\n\n    /* check augment target type and then augment nodes type */\n    if (aug->target->nodetype & (LYS_CONTAINER | LYS_LIST)) {\n        LY_TREE_FOR(aug->child, sub) {\n            if (!(sub->nodetype & (LYS_ANYDATA | LYS_CONTAINER | LYS_LEAF | LYS_LIST | LYS_LEAFLIST | LYS_USES\n                                   | LYS_CHOICE | LYS_ACTION | LYS_NOTIF))) {\n                LOGVAL(ctx, LYE_INCHILDSTMT, LY_VLOG_LYS, aug, strnodetype(sub->nodetype), \"augment\");\n                LOGVAL(ctx, LYE_SPEC, LY_VLOG_PREV, NULL, \"Cannot augment \\\"%s\\\" with a \\\"%s\\\".\",\n                       strnodetype(aug->target->nodetype), strnodetype(sub->nodetype));\n                return -1;\n            }\n        }\n    } else if (aug->target->nodetype & (LYS_CASE | LYS_INPUT | LYS_OUTPUT | LYS_NOTIF)) {\n        LY_TREE_FOR(aug->child, sub) {\n            if (!(sub->nodetype & (LYS_ANYDATA | LYS_CONTAINER | LYS_LEAF | LYS_LIST | LYS_LEAFLIST | LYS_USES | LYS_CHOICE))) {\n                LOGVAL(ctx, LYE_INCHILDSTMT, LY_VLOG_LYS, aug, strnodetype(sub->nodetype), \"augment\");\n                LOGVAL(ctx, LYE_SPEC, LY_VLOG_PREV, NULL, \"Cannot augment \\\"%s\\\" with a \\\"%s\\\".\",\n                       strnodetype(aug->target->nodetype), strnodetype(sub->nodetype));\n                return -1;\n            }\n        }\n    } else if (aug->target->nodetype == LYS_CHOICE) {\n        LY_TREE_FOR(aug->child, sub) {\n            if (!(sub->nodetype & (LYS_CASE | LYS_ANYDATA | LYS_CONTAINER | LYS_LEAF | LYS_LIST | LYS_LEAFLIST))) {\n                LOGVAL(ctx, LYE_INCHILDSTMT, LY_VLOG_LYS, aug, strnodetype(sub->nodetype), \"augment\");\n                LOGVAL(ctx, LYE_SPEC, LY_VLOG_PREV, NULL, \"Cannot augment \\\"%s\\\" with a \\\"%s\\\".\",\n                       strnodetype(aug->target->nodetype), strnodetype(sub->nodetype));\n                return -1;\n            }\n        }\n    } else {\n        LOGVAL(ctx, LYE_INARG, LY_VLOG_LYS, aug, aug->target_name, \"target-node\");\n        LOGVAL(ctx, LYE_SPEC, LY_VLOG_PREV, NULL, \"Invalid augment target node type \\\"%s\\\".\", strnodetype(aug->target->nodetype));\n        return -1;\n    }\n\n    /* check identifier uniqueness as in lys_node_addchild() */\n    LY_TREE_FOR(aug->child, sub) {\n        if (lys_check_id(sub, aug->target, NULL)) {\n            return -1;\n        }\n    }\n\n    if (!aug->child) {\n        /* empty augment, nothing to connect, but it is techincally applied */\n        LOGWRN(ctx, \"Augment \\\"%s\\\" without children.\", aug->target_name);\n        aug->flags &= ~LYS_NOTAPPLIED;\n    } else if ((aug->parent || mod->implemented) && apply_aug(aug, unres)) {\n        /* we try to connect the augment only in case the module is implemented or\n         * the augment applies on the used grouping, anyway we failed here */\n        return -1;\n    }\n\n    return EXIT_SUCCESS;\n}\n\nstatic int\nresolve_extension(struct unres_ext *info, struct lys_ext_instance **ext, struct unres_schema *unres)\n{\n    enum LY_VLOG_ELEM vlog_type;\n    void *vlog_node;\n    unsigned int i, j;\n    struct lys_ext *e;\n    char *ext_name, *ext_prefix, *tmp;\n    struct lyxml_elem *next_yin, *yin;\n    const struct lys_module *mod;\n    struct lys_ext_instance *tmp_ext;\n    struct ly_ctx *ctx = NULL;\n    LYEXT_TYPE etype;\n\n    switch (info->parent_type) {\n    case LYEXT_PAR_NODE:\n        vlog_node = info->parent;\n        vlog_type = LY_VLOG_LYS;\n        break;\n    case LYEXT_PAR_MODULE:\n    case LYEXT_PAR_IMPORT:\n    case LYEXT_PAR_INCLUDE:\n        vlog_node = NULL;\n        vlog_type = LY_VLOG_LYS;\n        break;\n    default:\n        vlog_node = NULL;\n        vlog_type = LY_VLOG_NONE;\n        break;\n    }\n\n    if (info->datatype == LYS_IN_YIN) {\n        /* YIN */\n\n        /* get the module where the extension is supposed to be defined */\n        mod = lyp_get_import_module_ns(info->mod, info->data.yin->ns->value);\n        if (!mod) {\n            LOGVAL(ctx, LYE_INSTMT, vlog_type, vlog_node, info->data.yin->name);\n            return EXIT_FAILURE;\n        }\n        ctx = mod->ctx;\n\n        /* find the extension definition */\n        e = NULL;\n        for (i = 0; i < mod->extensions_size; i++) {\n            if (ly_strequal(mod->extensions[i].name, info->data.yin->name, 1)) {\n                e = &mod->extensions[i];\n                break;\n            }\n        }\n        /* try submodules */\n        for (j = 0; !e && j < mod->inc_size; j++) {\n            for (i = 0; i < mod->inc[j].submodule->extensions_size; i++) {\n                if (ly_strequal(mod->inc[j].submodule->extensions[i].name, info->data.yin->name, 1)) {\n                    e = &mod->inc[j].submodule->extensions[i];\n                    break;\n                }\n            }\n        }\n        if (!e) {\n            LOGVAL(ctx, LYE_INSTMT, vlog_type, vlog_node, info->data.yin->name);\n            return EXIT_FAILURE;\n        }\n\n        /* we have the extension definition, so now it cannot be forward referenced and error is always fatal */\n\n        if (e->plugin && e->plugin->check_position) {\n            /* common part - we have plugin with position checking function, use it first */\n            if ((*e->plugin->check_position)(info->parent, info->parent_type, info->substmt)) {\n                /* extension is not allowed here */\n                LOGVAL(ctx, LYE_INSTMT, vlog_type, vlog_node, e->name);\n                return -1;\n            }\n        }\n\n        /* extension type-specific part - allocation */\n        if (e->plugin) {\n            etype = e->plugin->type;\n        } else {\n            /* default type */\n            etype = LYEXT_FLAG;\n        }\n        switch (etype) {\n        case LYEXT_FLAG:\n            (*ext) = calloc(1, sizeof(struct lys_ext_instance));\n            break;\n        case LYEXT_COMPLEX:\n            (*ext) = calloc(1, ((struct lyext_plugin_complex*)e->plugin)->instance_size);\n            break;\n        case LYEXT_ERR:\n            /* we never should be here */\n            LOGINT(ctx);\n            return -1;\n        }\n        LY_CHECK_ERR_RETURN(!*ext, LOGMEM(ctx), -1);\n\n        /* common part for all extension types */\n        (*ext)->def = e;\n        (*ext)->parent = info->parent;\n        (*ext)->parent_type = info->parent_type;\n        (*ext)->insubstmt = info->substmt;\n        (*ext)->insubstmt_index = info->substmt_index;\n        (*ext)->ext_type = e->plugin ? e->plugin->type : LYEXT_FLAG;\n        (*ext)->flags |= e->plugin ? e->plugin->flags : 0;\n\n        if (e->argument) {\n            if (!(e->flags & LYS_YINELEM)) {\n                (*ext)->arg_value = lyxml_get_attr(info->data.yin, e->argument, NULL);\n                if (!(*ext)->arg_value) {\n                    LOGVAL(ctx, LYE_MISSARG, LY_VLOG_NONE, NULL, e->argument, info->data.yin->name);\n                    return -1;\n                }\n\n                (*ext)->arg_value = lydict_insert(mod->ctx, (*ext)->arg_value, 0);\n            } else {\n                LY_TREE_FOR_SAFE(info->data.yin->child, next_yin, yin) {\n                    if (ly_strequal(yin->name, e->argument, 1)) {\n                        (*ext)->arg_value = lydict_insert(mod->ctx, yin->content, 0);\n                        lyxml_free(mod->ctx, yin);\n                        break;\n                    }\n                }\n            }\n        }\n\n        if ((*ext)->flags & LYEXT_OPT_VALID &&\n            (info->parent_type == LYEXT_PAR_NODE || info->parent_type == LYEXT_PAR_TPDF)) {\n            ((struct lys_node *)info->parent)->flags |= LYS_VALID_EXT;\n        }\n\n        (*ext)->nodetype = LYS_EXT;\n        (*ext)->module = info->mod;\n\n        /* extension type-specific part - parsing content */\n        switch (etype) {\n        case LYEXT_FLAG:\n            LY_TREE_FOR_SAFE(info->data.yin->child, next_yin, yin) {\n                if (!yin->ns) {\n                    /* garbage */\n                    lyxml_free(mod->ctx, yin);\n                    continue;\n                } else if (!strcmp(yin->ns->value, LY_NSYIN)) {\n                    /* standard YANG statements are not expected here */\n                    LOGVAL(ctx, LYE_INCHILDSTMT, vlog_type, vlog_node, yin->name, info->data.yin->name);\n                    return -1;\n                } else if (yin->ns == info->data.yin->ns &&\n                        (e->flags & LYS_YINELEM) && ly_strequal(yin->name, e->argument, 1)) {\n                    /* we have the extension's argument */\n                    if ((*ext)->arg_value) {\n                        LOGVAL(ctx, LYE_TOOMANY, vlog_type, vlog_node, yin->name, info->data.yin->name);\n                        return -1;\n                    }\n                    (*ext)->arg_value = yin->content;\n                    yin->content = NULL;\n                    lyxml_free(mod->ctx, yin);\n                } else {\n                    /* extension instance */\n                    if (lyp_yin_parse_subnode_ext(info->mod, *ext, LYEXT_PAR_EXTINST, yin,\n                                                  LYEXT_SUBSTMT_SELF, 0, unres)) {\n                        return -1;\n                    }\n\n                    continue;\n                }\n            }\n            break;\n        case LYEXT_COMPLEX:\n            ((struct lys_ext_instance_complex*)(*ext))->substmt = ((struct lyext_plugin_complex*)e->plugin)->substmt;\n            if (lyp_yin_parse_complex_ext(info->mod, (struct lys_ext_instance_complex*)(*ext), info->data.yin, unres)) {\n                /* TODO memory cleanup */\n                return -1;\n            }\n            break;\n        default:\n            break;\n        }\n\n        /* TODO - lyext_check_result_clb, other than LYEXT_FLAG plugins */\n\n    } else {\n        /* YANG */\n\n        ext_prefix = (char *)(*ext)->def;\n        tmp = strchr(ext_prefix, ':');\n        if (!tmp) {\n            LOGVAL(ctx, LYE_INSTMT, vlog_type, vlog_node, ext_prefix);\n            goto error;\n        }\n        ext_name = tmp + 1;\n\n        /* get the module where the extension is supposed to be defined */\n        mod = lyp_get_module(info->mod, ext_prefix, tmp - ext_prefix, NULL, 0, 0);\n        if (!mod) {\n            LOGVAL(ctx, LYE_INSTMT, vlog_type, vlog_node, ext_prefix);\n            return EXIT_FAILURE;\n        }\n        ctx = mod->ctx;\n\n        /* find the extension definition */\n        e = NULL;\n        for (i = 0; i < mod->extensions_size; i++) {\n            if (ly_strequal(mod->extensions[i].name, ext_name, 0)) {\n                e = &mod->extensions[i];\n                break;\n            }\n        }\n        /* try submodules */\n        for (j = 0; !e && j < mod->inc_size; j++) {\n            for (i = 0; i < mod->inc[j].submodule->extensions_size; i++) {\n                if (ly_strequal(mod->inc[j].submodule->extensions[i].name, ext_name, 0)) {\n                    e = &mod->inc[j].submodule->extensions[i];\n                    break;\n                }\n            }\n        }\n        if (!e) {\n            LOGVAL(ctx, LYE_INSTMT, vlog_type, vlog_node, ext_prefix);\n            return EXIT_FAILURE;\n        }\n\n        (*ext)->flags &= ~LYEXT_OPT_YANG;\n        (*ext)->def = NULL;\n\n        /* we have the extension definition, so now it cannot be forward referenced and error is always fatal */\n\n        if (e->plugin && e->plugin->check_position) {\n            /* common part - we have plugin with position checking function, use it first */\n            if ((*e->plugin->check_position)(info->parent, info->parent_type, info->substmt)) {\n                /* extension is not allowed here */\n                LOGVAL(ctx, LYE_INSTMT, vlog_type, vlog_node, e->name);\n                goto error;\n            }\n        }\n\n        if (e->argument && !(*ext)->arg_value) {\n            LOGVAL(ctx, LYE_MISSARG, LY_VLOG_NONE, NULL, e->argument, ext_name);\n            goto error;\n        }\n\n        /* extension common part */\n        (*ext)->def = e;\n        (*ext)->parent = info->parent;\n        (*ext)->ext_type = e->plugin ? e->plugin->type : LYEXT_FLAG;\n        (*ext)->flags |= e->plugin ? e->plugin->flags : 0;\n\n        if ((*ext)->flags & LYEXT_OPT_VALID &&\n            (info->parent_type == LYEXT_PAR_NODE || info->parent_type == LYEXT_PAR_TPDF)) {\n            ((struct lys_node *)info->parent)->flags |= LYS_VALID_EXT;\n        }\n\n        (*ext)->module = info->mod;\n        (*ext)->nodetype = LYS_EXT;\n\n        /* extension type-specific part */\n        if (e->plugin) {\n            etype = e->plugin->type;\n        } else {\n            /* default type */\n            etype = LYEXT_FLAG;\n        }\n        switch (etype) {\n        case LYEXT_FLAG:\n            /* nothing change */\n            break;\n        case LYEXT_COMPLEX:\n            tmp_ext = realloc(*ext, ((struct lyext_plugin_complex*)e->plugin)->instance_size);\n            LY_CHECK_ERR_GOTO(!tmp_ext, LOGMEM(ctx), error);\n            memset((char *)tmp_ext + offsetof(struct lys_ext_instance_complex, content), 0,\n                   ((struct lyext_plugin_complex*)e->plugin)->instance_size - offsetof(struct lys_ext_instance_complex, content));\n            (*ext) = tmp_ext;\n            ((struct lys_ext_instance_complex*)(*ext))->substmt = ((struct lyext_plugin_complex*)e->plugin)->substmt;\n            if (info->data.yang) {\n                *tmp = ':';\n                if (yang_parse_ext_substatement(info->mod, unres, info->data.yang->ext_substmt, ext_prefix,\n                                                (struct lys_ext_instance_complex*)(*ext))) {\n                    goto error;\n                }\n                if (yang_fill_extcomplex_module(info->mod->ctx, (struct lys_ext_instance_complex*)(*ext), ext_prefix,\n                                                info->data.yang->ext_modules, info->mod->implemented)) {\n                    goto error;\n                }\n            }\n            if (lyp_mand_check_ext((struct lys_ext_instance_complex*)(*ext), ext_prefix)) {\n                goto error;\n            }\n            break;\n        case LYEXT_ERR:\n            /* we never should be here */\n            LOGINT(ctx);\n            goto error;\n        }\n\n        if (yang_check_ext_instance(info->mod, &(*ext)->ext, (*ext)->ext_size, *ext, unres)) {\n            goto error;\n        }\n        free(ext_prefix);\n    }\n\n    return EXIT_SUCCESS;\nerror:\n    free(ext_prefix);\n    return -1;\n}\n\n/**\n * @brief Resolve (find) choice default case. Does not log.\n *\n * @param[in] choic Choice to use.\n * @param[in] dflt Name of the default case.\n *\n * @return Pointer to the default node or NULL.\n */\nstatic struct lys_node *\nresolve_choice_dflt(struct lys_node_choice *choic, const char *dflt)\n{\n    struct lys_node *child, *ret;\n\n    LY_TREE_FOR(choic->child, child) {\n        if (child->nodetype == LYS_USES) {\n            ret = resolve_choice_dflt((struct lys_node_choice *)child, dflt);\n            if (ret) {\n                return ret;\n            }\n        }\n\n        if (ly_strequal(child->name, dflt, 1) && (child->nodetype & (LYS_ANYDATA | LYS_CASE\n                | LYS_CONTAINER | LYS_LEAF | LYS_LEAFLIST | LYS_LIST | LYS_CHOICE))) {\n            return child;\n        }\n    }\n\n    return NULL;\n}\n\n/**\n * @brief Resolve uses, apply augments, refines. Logs directly.\n *\n * @param[in] uses Uses to use.\n * @param[in,out] unres List of unresolved items.\n *\n * @return EXIT_SUCCESS on success, -1 on error.\n */\nstatic int\nresolve_uses(struct lys_node_uses *uses, struct unres_schema *unres)\n{\n    struct ly_ctx *ctx = uses->module->ctx; /* shortcut */\n    struct lys_node *node = NULL, *next, *iter, **refine_nodes = NULL;\n    struct lys_node *node_aux, *parent, *tmp;\n    struct lys_node_leaflist *llist;\n    struct lys_node_leaf *leaf;\n    struct lys_refine *rfn;\n    struct lys_restr *must, **old_must;\n    struct lys_iffeature *iff, **old_iff;\n    int i, j, k, rc;\n    uint8_t size, *old_size;\n    unsigned int usize, usize1, usize2;\n\n    assert(uses->grp);\n\n    /* check that the grouping is resolved (no unresolved uses inside) */\n    assert(!uses->grp->unres_count);\n\n    /* copy the data nodes from grouping into the uses context */\n    LY_TREE_FOR(uses->grp->child, node_aux) {\n        if (node_aux->nodetype & LYS_GROUPING) {\n            /* do not instantiate groupings from groupings */\n            continue;\n        }\n        node = lys_node_dup(uses->module, (struct lys_node *)uses, node_aux, unres, 0);\n        if (!node) {\n            LOGVAL(ctx, LYE_INARG, LY_VLOG_LYS, uses, uses->grp->name, \"uses\");\n            LOGVAL(ctx, LYE_SPEC, LY_VLOG_PREV, NULL, \"Copying data from grouping failed.\");\n            goto fail;\n        }\n        /* test the name of siblings */\n        LY_TREE_FOR((uses->parent) ? *lys_child(uses->parent, LYS_USES) : lys_main_module(uses->module)->data, tmp) {\n            if (!(tmp->nodetype & (LYS_USES | LYS_GROUPING | LYS_CASE)) && ly_strequal(tmp->name, node_aux->name, 1)) {\n                goto fail;\n            }\n        }\n    }\n\n    /* we managed to copy the grouping, the rest must be possible to resolve */\n\n    if (uses->refine_size) {\n        refine_nodes = malloc(uses->refine_size * sizeof *refine_nodes);\n        LY_CHECK_ERR_GOTO(!refine_nodes, LOGMEM(ctx), fail);\n    }\n\n    /* apply refines */\n    for (i = 0; i < uses->refine_size; i++) {\n        rfn = &uses->refine[i];\n        rc = resolve_descendant_schema_nodeid(rfn->target_name, uses->child,\n                                              LYS_NO_RPC_NOTIF_NODE | LYS_ACTION | LYS_NOTIF,\n                                              0, (const struct lys_node **)&node);\n        if (rc || !node) {\n            LOGVAL(ctx, LYE_INARG, LY_VLOG_LYS, uses, rfn->target_name, \"refine\");\n            goto fail;\n        }\n\n        if (rfn->target_type && !(node->nodetype & rfn->target_type)) {\n            LOGVAL(ctx, LYE_INARG, LY_VLOG_LYS, uses, rfn->target_name, \"refine\");\n            LOGVAL(ctx, LYE_SPEC, LY_VLOG_PREV, NULL, \"Refine substatements not applicable to the target-node.\");\n            goto fail;\n        }\n        refine_nodes[i] = node;\n\n        /* description on any nodetype */\n        if (rfn->dsc) {\n            lydict_remove(ctx, node->dsc);\n            node->dsc = lydict_insert(ctx, rfn->dsc, 0);\n        }\n\n        /* reference on any nodetype */\n        if (rfn->ref) {\n            lydict_remove(ctx, node->ref);\n            node->ref = lydict_insert(ctx, rfn->ref, 0);\n        }\n\n        /* config on any nodetype,\n         * in case of notification or rpc/action, the config is not applicable (there is no config status) */\n        if ((rfn->flags & LYS_CONFIG_MASK) && (node->flags & LYS_CONFIG_MASK)) {\n            node->flags &= ~LYS_CONFIG_MASK;\n            node->flags |= (rfn->flags & LYS_CONFIG_MASK);\n        }\n\n        /* default value ... */\n        if (rfn->dflt_size) {\n            if (node->nodetype == LYS_LEAF) {\n                /* leaf */\n                leaf = (struct lys_node_leaf *)node;\n\n                /* replace default value */\n                lydict_remove(ctx, leaf->dflt);\n                leaf->dflt = lydict_insert(ctx, rfn->dflt[0], 0);\n\n                /* check the default value */\n                if (unres_schema_add_node(leaf->module, unres, &leaf->type, UNRES_TYPE_DFLT,\n                                          (struct lys_node *)(&leaf->dflt)) == -1) {\n                    goto fail;\n                }\n            } else if (node->nodetype == LYS_LEAFLIST) {\n                /* leaf-list */\n                llist = (struct lys_node_leaflist *)node;\n\n                /* remove complete set of defaults in target */\n                for (j = 0; j < llist->dflt_size; j++) {\n                    lydict_remove(ctx, llist->dflt[j]);\n                }\n                free(llist->dflt);\n\n                /* copy the default set from refine */\n                llist->dflt = malloc(rfn->dflt_size * sizeof *llist->dflt);\n                LY_CHECK_ERR_GOTO(!llist->dflt, LOGMEM(ctx), fail);\n                llist->dflt_size = rfn->dflt_size;\n                for (j = 0; j < llist->dflt_size; j++) {\n                    llist->dflt[j] = lydict_insert(ctx, rfn->dflt[j], 0);\n                }\n\n                /* check default value */\n                for (j = 0; j < llist->dflt_size; j++) {\n                    if (unres_schema_add_node(llist->module, unres, &llist->type, UNRES_TYPE_DFLT,\n                                              (struct lys_node *)(&llist->dflt[j])) == -1) {\n                        goto fail;\n                    }\n                }\n            }\n        }\n\n        /* mandatory on leaf, anyxml or choice */\n        if (rfn->flags & LYS_MAND_MASK) {\n            /* remove current value */\n            node->flags &= ~LYS_MAND_MASK;\n\n            /* set new value */\n            node->flags |= (rfn->flags & LYS_MAND_MASK);\n\n            if (rfn->flags & LYS_MAND_TRUE) {\n                /* check if node has default value */\n                if ((node->nodetype & LYS_LEAF) && ((struct lys_node_leaf *)node)->dflt) {\n                    LOGVAL(ctx, LYE_SPEC, LY_VLOG_LYS, uses,\n                           \"The \\\"mandatory\\\" statement is forbidden on leaf with \\\"default\\\".\");\n                    goto fail;\n                }\n                if ((node->nodetype & LYS_CHOICE) && ((struct lys_node_choice *)node)->dflt) {\n                    LOGVAL(ctx, LYE_SPEC, LY_VLOG_LYS, uses,\n                           \"The \\\"mandatory\\\" statement is forbidden on choices with \\\"default\\\".\");\n                    goto fail;\n                }\n            }\n        }\n\n        /* presence on container */\n        if ((node->nodetype & LYS_CONTAINER) && rfn->mod.presence) {\n            lydict_remove(ctx, ((struct lys_node_container *)node)->presence);\n            ((struct lys_node_container *)node)->presence = lydict_insert(ctx, rfn->mod.presence, 0);\n        }\n\n        /* min/max-elements on list or leaf-list */\n        if (node->nodetype == LYS_LIST) {\n            if (rfn->flags & LYS_RFN_MINSET) {\n                ((struct lys_node_list *)node)->min = rfn->mod.list.min;\n            }\n            if (rfn->flags & LYS_RFN_MAXSET) {\n                ((struct lys_node_list *)node)->max = rfn->mod.list.max;\n            }\n        } else if (node->nodetype == LYS_LEAFLIST) {\n            if (rfn->flags & LYS_RFN_MINSET) {\n                ((struct lys_node_leaflist *)node)->min = rfn->mod.list.min;\n            }\n            if (rfn->flags & LYS_RFN_MAXSET) {\n                ((struct lys_node_leaflist *)node)->max = rfn->mod.list.max;\n            }\n        }\n\n        /* must in leaf, leaf-list, list, container or anyxml */\n        if (rfn->must_size) {\n            switch (node->nodetype) {\n            case LYS_LEAF:\n                old_size = &((struct lys_node_leaf *)node)->must_size;\n                old_must = &((struct lys_node_leaf *)node)->must;\n                break;\n            case LYS_LEAFLIST:\n                old_size = &((struct lys_node_leaflist *)node)->must_size;\n                old_must = &((struct lys_node_leaflist *)node)->must;\n                break;\n            case LYS_LIST:\n                old_size = &((struct lys_node_list *)node)->must_size;\n                old_must = &((struct lys_node_list *)node)->must;\n                break;\n            case LYS_CONTAINER:\n                old_size = &((struct lys_node_container *)node)->must_size;\n                old_must = &((struct lys_node_container *)node)->must;\n                break;\n            case LYS_ANYXML:\n            case LYS_ANYDATA:\n                old_size = &((struct lys_node_anydata *)node)->must_size;\n                old_must = &((struct lys_node_anydata *)node)->must;\n                break;\n            default:\n                LOGINT(ctx);\n                goto fail;\n            }\n\n            size = *old_size + rfn->must_size;\n            must = realloc(*old_must, size * sizeof *rfn->must);\n            LY_CHECK_ERR_GOTO(!must, LOGMEM(ctx), fail);\n            for (k = 0, j = *old_size; k < rfn->must_size; k++, j++) {\n                must[j].ext_size = rfn->must[k].ext_size;\n                lys_ext_dup(ctx, rfn->module, rfn->must[k].ext, rfn->must[k].ext_size, &rfn->must[k], LYEXT_PAR_RESTR,\n                            &must[j].ext, 0, unres);\n                must[j].expr = lydict_insert(ctx, rfn->must[k].expr, 0);\n                must[j].dsc = lydict_insert(ctx, rfn->must[k].dsc, 0);\n                must[j].ref = lydict_insert(ctx, rfn->must[k].ref, 0);\n                must[j].eapptag = lydict_insert(ctx, rfn->must[k].eapptag, 0);\n                must[j].emsg = lydict_insert(ctx, rfn->must[k].emsg, 0);\n                must[j].flags = rfn->must[k].flags;\n            }\n\n            *old_must = must;\n            *old_size = size;\n\n            /* check XPath dependencies again */\n            if (unres_schema_add_node(node->module, unres, node, UNRES_XPATH, NULL) == -1) {\n                goto fail;\n            }\n        }\n\n        /* if-feature in leaf, leaf-list, list, container or anyxml */\n        if (rfn->iffeature_size) {\n            old_size = &node->iffeature_size;\n            old_iff = &node->iffeature;\n\n            size = *old_size + rfn->iffeature_size;\n            iff = realloc(*old_iff, size * sizeof *rfn->iffeature);\n            LY_CHECK_ERR_GOTO(!iff, LOGMEM(ctx), fail);\n            *old_iff = iff;\n\n            for (k = 0, j = *old_size; k < rfn->iffeature_size; k++, j++) {\n                resolve_iffeature_getsizes(&rfn->iffeature[k], &usize1, &usize2);\n                if (usize1) {\n                    /* there is something to duplicate */\n                    /* duplicate compiled expression */\n                    usize = (usize1 / 4) + (usize1 % 4) ? 1 : 0;\n                    iff[j].expr = malloc(usize * sizeof *iff[j].expr);\n                    LY_CHECK_ERR_GOTO(!iff[j].expr, LOGMEM(ctx), fail);\n                    memcpy(iff[j].expr, rfn->iffeature[k].expr, usize * sizeof *iff[j].expr);\n\n                    /* duplicate list of feature pointers */\n                    iff[j].features = malloc(usize2 * sizeof *iff[k].features);\n                    LY_CHECK_ERR_GOTO(!iff[j].expr, LOGMEM(ctx), fail);\n                    memcpy(iff[j].features, rfn->iffeature[k].features, usize2 * sizeof *iff[j].features);\n\n                    /* duplicate extensions */\n                    iff[j].ext_size = rfn->iffeature[k].ext_size;\n                    lys_ext_dup(ctx, rfn->module, rfn->iffeature[k].ext, rfn->iffeature[k].ext_size,\n                                &rfn->iffeature[k], LYEXT_PAR_IFFEATURE, &iff[j].ext, 0, unres);\n                }\n                (*old_size)++;\n            }\n            assert(*old_size == size);\n        }\n    }\n\n    /* apply augments */\n    for (i = 0; i < uses->augment_size; i++) {\n        rc = resolve_augment(&uses->augment[i], (struct lys_node *)uses, unres);\n        if (rc) {\n            goto fail;\n        }\n    }\n\n    /* check refines */\n    for (i = 0; i < uses->refine_size; i++) {\n        node = refine_nodes[i];\n        rfn = &uses->refine[i];\n\n        /* config on any nodetype */\n        if ((rfn->flags & LYS_CONFIG_MASK) && (node->flags & LYS_CONFIG_MASK)) {\n            for (parent = lys_parent(node); parent && parent->nodetype == LYS_USES; parent = lys_parent(parent));\n            if (parent && parent->nodetype != LYS_GROUPING && (parent->flags & LYS_CONFIG_MASK) &&\n                    ((parent->flags & LYS_CONFIG_MASK) != (rfn->flags & LYS_CONFIG_MASK)) &&\n                    (rfn->flags & LYS_CONFIG_W)) {\n                /* setting config true under config false is prohibited */\n                LOGVAL(ctx, LYE_INARG, LY_VLOG_LYS, uses, \"config\", \"refine\");\n                LOGVAL(ctx, LYE_SPEC, LY_VLOG_PREV, NULL,\n                       \"changing config from 'false' to 'true' is prohibited while \"\n                       \"the target's parent is still config 'false'.\");\n                goto fail;\n            }\n\n            /* inherit config change to the target children */\n            LY_TREE_DFS_BEGIN(node->child, next, iter) {\n                if (rfn->flags & LYS_CONFIG_W) {\n                    if (iter->flags & LYS_CONFIG_SET) {\n                        /* config is set explicitely, go to next sibling */\n                        next = NULL;\n                        goto nextsibling;\n                    }\n                } else { /* LYS_CONFIG_R */\n                    if ((iter->flags & LYS_CONFIG_SET) && (iter->flags & LYS_CONFIG_W)) {\n                        /* error - we would have config data under status data */\n                        LOGVAL(ctx, LYE_INARG, LY_VLOG_LYS, uses, \"config\", \"refine\");\n                        LOGVAL(ctx, LYE_SPEC, LY_VLOG_PREV, NULL,\n                               \"changing config from 'true' to 'false' is prohibited while the target \"\n                               \"has still a children with explicit config 'true'.\");\n                        goto fail;\n                    }\n                }\n                /* change config */\n                iter->flags &= ~LYS_CONFIG_MASK;\n                iter->flags |= (rfn->flags & LYS_CONFIG_MASK);\n\n                /* select next iter - modified LY_TREE_DFS_END */\n                if (iter->nodetype & (LYS_LEAF | LYS_LEAFLIST | LYS_ANYDATA)) {\n                    next = NULL;\n                } else {\n                    next = iter->child;\n                }\nnextsibling:\n                if (!next) {\n                    /* try siblings */\n                    next = iter->next;\n                }\n                while (!next) {\n                    /* parent is already processed, go to its sibling */\n                    iter = lys_parent(iter);\n\n                    /* no siblings, go back through parents */\n                    if (iter == node) {\n                        /* we are done, no next element to process */\n                        break;\n                    }\n                    next = iter->next;\n                }\n            }\n        }\n\n        /* default value */\n        if (rfn->dflt_size) {\n            if (node->nodetype == LYS_CHOICE) {\n                /* choice */\n                ((struct lys_node_choice *)node)->dflt = resolve_choice_dflt((struct lys_node_choice *)node,\n                                                                             rfn->dflt[0]);\n                if (!((struct lys_node_choice *)node)->dflt) {\n                    LOGVAL(ctx, LYE_INARG, LY_VLOG_LYS, uses, rfn->dflt[0], \"default\");\n                    goto fail;\n                }\n                if (lyp_check_mandatory_choice(node)) {\n                    goto fail;\n                }\n            }\n        }\n\n        /* min/max-elements on list or leaf-list */\n        if (node->nodetype == LYS_LIST && ((struct lys_node_list *)node)->max) {\n            if (((struct lys_node_list *)node)->min > ((struct lys_node_list *)node)->max) {\n                LOGVAL(ctx, LYE_SPEC, LY_VLOG_LYS, uses, \"Invalid value \\\"%d\\\" of \\\"%s\\\".\", rfn->mod.list.min, \"min-elements\");\n                LOGVAL(ctx, LYE_SPEC, LY_VLOG_PREV, NULL, \"\\\"min-elements\\\" is bigger than \\\"max-elements\\\".\");\n                goto fail;\n            }\n        } else if (node->nodetype == LYS_LEAFLIST && ((struct lys_node_leaflist *)node)->max) {\n            if (((struct lys_node_leaflist *)node)->min > ((struct lys_node_leaflist *)node)->max) {\n                LOGVAL(ctx, LYE_SPEC, LY_VLOG_LYS, uses, \"Invalid value \\\"%d\\\" of \\\"%s\\\".\", rfn->mod.list.min, \"min-elements\");\n                LOGVAL(ctx, LYE_SPEC, LY_VLOG_PREV, NULL, \"\\\"min-elements\\\" is bigger than \\\"max-elements\\\".\");\n                goto fail;\n            }\n        }\n\n        /* additional checks */\n        /* default value with mandatory/min-elements */\n        if (node->nodetype == LYS_LEAFLIST) {\n            llist = (struct lys_node_leaflist *)node;\n            if (llist->dflt_size && llist->min) {\n                LOGVAL(ctx, LYE_INCHILDSTMT, LY_VLOG_LYS, uses, rfn->dflt_size ? \"default\" : \"min-elements\", \"refine\");\n                LOGVAL(ctx, LYE_SPEC, LY_VLOG_PREV, NULL,\n                       \"The \\\"min-elements\\\" statement with non-zero value is forbidden on leaf-lists with the \\\"default\\\" statement.\");\n                goto fail;\n            }\n        } else if (node->nodetype == LYS_LEAF) {\n            leaf = (struct lys_node_leaf *)node;\n            if (leaf->dflt && (leaf->flags & LYS_MAND_TRUE)) {\n                LOGVAL(ctx, LYE_INCHILDSTMT, LY_VLOG_LYS, uses, rfn->dflt_size ? \"default\" : \"mandatory\", \"refine\");\n                LOGVAL(ctx, LYE_SPEC, LY_VLOG_PREV, NULL,\n                       \"The \\\"mandatory\\\" statement is forbidden on leafs with the \\\"default\\\" statement.\");\n                goto fail;\n            }\n        }\n\n        /* check for mandatory node in default case, first find the closest parent choice to the changed node */\n        if ((rfn->flags & LYS_MAND_TRUE) || rfn->mod.list.min) {\n            for (parent = node->parent;\n                 parent && !(parent->nodetype & (LYS_CHOICE | LYS_GROUPING | LYS_ACTION | LYS_USES));\n                 parent = parent->parent) {\n                if (parent->nodetype == LYS_CONTAINER && ((struct lys_node_container *)parent)->presence) {\n                    /* stop also on presence containers */\n                    break;\n                }\n            }\n            /* and if it is a choice with the default case, check it for presence of a mandatory node in it */\n            if (parent && parent->nodetype == LYS_CHOICE && ((struct lys_node_choice *)parent)->dflt) {\n                if (lyp_check_mandatory_choice(parent)) {\n                    goto fail;\n                }\n            }\n        }\n    }\n    free(refine_nodes);\n\n    return EXIT_SUCCESS;\n\nfail:\n    LY_TREE_FOR_SAFE(uses->child, next, iter) {\n        lys_node_free(iter, NULL, 0);\n    }\n    free(refine_nodes);\n    return -1;\n}\n\nvoid\nresolve_identity_backlink_update(struct lys_ident *der, struct lys_ident *base)\n{\n    int i;\n\n    assert(der && base);\n\n    if (!base->der) {\n        /* create a set for backlinks if it does not exist */\n        base->der = ly_set_new();\n    }\n    /* store backlink */\n    ly_set_add(base->der, der, LY_SET_OPT_USEASLIST);\n\n    /* do it recursively */\n    for (i = 0; i < base->base_size; i++) {\n        resolve_identity_backlink_update(der, base->base[i]);\n    }\n}\n\n/**\n * @brief Resolve base identity recursively. Does not log.\n *\n * @param[in] module Main module.\n * @param[in] ident Identity to use.\n * @param[in] basename Base name of the identity.\n * @param[out] ret Pointer to the resolved identity. Can be NULL.\n *\n * @return EXIT_SUCCESS on success, EXIT_FAILURE on forward reference, -1 on crucial error.\n */\nstatic int\nresolve_base_ident_sub(const struct lys_module *module, struct lys_ident *ident, const char *basename,\n                       struct unres_schema *unres, struct lys_ident **ret)\n{\n    uint32_t i, j;\n    struct lys_ident *base = NULL;\n    struct ly_ctx *ctx = module->ctx;\n\n    assert(ret);\n\n    /* search module */\n    for (i = 0; i < module->ident_size; i++) {\n        if (!strcmp(basename, module->ident[i].name)) {\n\n            if (!ident) {\n                /* just search for type, so do not modify anything, just return\n                 * the base identity pointer */\n                *ret = &module->ident[i];\n                return EXIT_SUCCESS;\n            }\n\n            base = &module->ident[i];\n            goto matchfound;\n        }\n    }\n\n    /* search submodules */\n    for (j = 0; j < module->inc_size && module->inc[j].submodule; j++) {\n        for (i = 0; i < module->inc[j].submodule->ident_size; i++) {\n            if (!strcmp(basename, module->inc[j].submodule->ident[i].name)) {\n\n                if (!ident) {\n                    *ret = &module->inc[j].submodule->ident[i];\n                    return EXIT_SUCCESS;\n                }\n\n                base = &module->inc[j].submodule->ident[i];\n                goto matchfound;\n            }\n        }\n    }\n\nmatchfound:\n    /* we found it somewhere */\n    if (base) {\n        /* is it already completely resolved? */\n        for (i = 0; i < unres->count; i++) {\n            if ((unres->item[i] == base) && (unres->type[i] == UNRES_IDENT)) {\n                /* identity found, but not yet resolved, so do not return it in *res and try it again later */\n\n                /* simple check for circular reference,\n                 * the complete check is done as a side effect of using only completely\n                 * resolved identities (previous check of unres content) */\n                if (ly_strequal((const char *)unres->str_snode[i], ident->name, 1)) {\n                    LOGVAL(ctx, LYE_INARG, LY_VLOG_NONE, NULL, basename, \"base\");\n                    LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Circular reference of \\\"%s\\\" identity.\", basename);\n                    return -1;\n                }\n\n                return EXIT_FAILURE;\n            }\n        }\n\n        /* checks done, store the result */\n        *ret = base;\n        return EXIT_SUCCESS;\n    }\n\n    /* base not found (maybe a forward reference) */\n    return EXIT_FAILURE;\n}\n\n/**\n * @brief Resolve base identity. Logs directly.\n *\n * @param[in] module Main module.\n * @param[in] ident Identity to use.\n * @param[in] basename Base name of the identity.\n * @param[in] parent Either \"type\" or \"identity\".\n * @param[in,out] type Type structure where we want to resolve identity. Can be NULL.\n *\n * @return EXIT_SUCCESS on success, EXIT_FAILURE on forward reference, -1 on error.\n */\nstatic int\nresolve_base_ident(const struct lys_module *module, struct lys_ident *ident, const char *basename, const char *parent,\n                   struct lys_type *type, struct unres_schema *unres)\n{\n    const char *name;\n    int mod_name_len = 0, rc;\n    struct lys_ident *target, **ret;\n    uint16_t flags;\n    struct lys_module *mod;\n    struct ly_ctx *ctx = module->ctx;\n\n    assert((ident && !type) || (!ident && type));\n\n    if (!type) {\n        /* have ident to resolve */\n        ret = &target;\n        flags = ident->flags;\n        mod = ident->module;\n    } else {\n        /* have type to fill */\n        ++type->info.ident.count;\n        type->info.ident.ref = ly_realloc(type->info.ident.ref, type->info.ident.count * sizeof *type->info.ident.ref);\n        LY_CHECK_ERR_RETURN(!type->info.ident.ref, LOGMEM(ctx), -1);\n\n        ret = &type->info.ident.ref[type->info.ident.count - 1];\n        flags = type->parent->flags;\n        mod = type->parent->module;\n    }\n    *ret = NULL;\n\n    /* search for the base identity */\n    name = strchr(basename, ':');\n    if (name) {\n        /* set name to correct position after colon */\n        mod_name_len = name - basename;\n        name++;\n\n        if (!strncmp(basename, module->name, mod_name_len) && !module->name[mod_name_len]) {\n            /* prefix refers to the current module, ignore it */\n            mod_name_len = 0;\n        }\n    } else {\n        name = basename;\n    }\n\n    /* get module where to search */\n    module = lyp_get_module(module, NULL, 0, mod_name_len ? basename : NULL, mod_name_len, 0);\n    if (!module) {\n        /* identity refers unknown data model */\n        LOGVAL(ctx, LYE_INMOD, LY_VLOG_NONE, NULL, basename);\n        return -1;\n    }\n\n    /* search in the identified module ... */\n    rc = resolve_base_ident_sub(module, ident, name, unres, ret);\n    if (!rc) {\n        assert(*ret);\n\n        /* check status */\n        if (lyp_check_status(flags, mod, ident ? ident->name : \"of type\",\n                             (*ret)->flags, (*ret)->module, (*ret)->name, NULL)) {\n            rc = -1;\n        } else if (ident) {\n            ident->base[ident->base_size++] = *ret;\n            if (lys_main_module(mod)->implemented) {\n                /* in case of the implemented identity, maintain backlinks to it\n                 * from the base identities to make it available when resolving\n                 * data with the identity values (not implemented identity is not\n                 * allowed as an identityref value). */\n                resolve_identity_backlink_update(ident, *ret);\n            }\n        }\n    } else if (rc == EXIT_FAILURE) {\n        LOGVAL(ctx, LYE_INRESOLV, LY_VLOG_NONE, NULL, parent, basename);\n        if (type) {\n            --type->info.ident.count;\n        }\n    }\n\n    return rc;\n}\n\n/*\n * 1 - true (der is derived from base)\n * 0 - false (der is not derived from base)\n */\nstatic int\nsearch_base_identity(struct lys_ident *der, struct lys_ident *base)\n{\n    int i;\n\n    if (der == base) {\n        return 1;\n    } else {\n        for(i = 0; i < der->base_size; i++) {\n            if (search_base_identity(der->base[i], base) == 1) {\n                return 1;\n            }\n        }\n    }\n\n    return 0;\n}\n\n/**\n * @brief Resolve JSON data format identityref. Logs directly.\n *\n * @param[in] type Identityref type.\n * @param[in] ident_name Identityref name.\n * @param[in] node Node where the identityref is being resolved\n * @param[in] dflt flag if we are resolving default value in the schema\n *\n * @return Pointer to the identity resolvent, NULL on error.\n */\nstruct lys_ident *\nresolve_identref(struct lys_type *type, const char *ident_name, struct lyd_node *node, struct lys_module *mod, int dflt)\n{\n    const char *mod_name, *name;\n    char *str;\n    int mod_name_len, nam_len, rc;\n    int need_implemented = 0;\n    unsigned int i, j;\n    struct lys_ident *der, *cur;\n    struct lys_module *imod = NULL, *m, *tmod;\n    struct ly_ctx *ctx;\n\n    assert(type && ident_name && mod);\n    ctx = mod->ctx;\n\n    if (!type || (!type->info.ident.count && !type->der) || !ident_name) {\n        return NULL;\n    }\n\n    rc = parse_node_identifier(ident_name, &mod_name, &mod_name_len, &name, &nam_len, NULL, 0);\n    if (rc < 1) {\n        LOGVAL(ctx, LYE_INCHAR, node ? LY_VLOG_LYD : LY_VLOG_NONE, node, ident_name[-rc], &ident_name[-rc]);\n        return NULL;\n    } else if (rc < (signed)strlen(ident_name)) {\n        LOGVAL(ctx, LYE_INCHAR, node ? LY_VLOG_LYD : LY_VLOG_NONE, node, ident_name[rc], &ident_name[rc]);\n        return NULL;\n    }\n\n    m = lys_main_module(mod); /* shortcut */\n    if (!mod_name || (!strncmp(mod_name, m->name, mod_name_len) && !m->name[mod_name_len])) {\n        /* identity is defined in the same module as node */\n        imod = m;\n    } else if (dflt) {\n        /* solving identityref in default definition in schema -\n         * find the identity's module in the imported modules list to have a correct revision */\n        for (i = 0; i < mod->imp_size; i++) {\n            if (!strncmp(mod_name, mod->imp[i].module->name, mod_name_len) && !mod->imp[i].module->name[mod_name_len]) {\n                imod = mod->imp[i].module;\n                break;\n            }\n        }\n\n        /* We may need to pull it from the module that the typedef came from */\n        if (!imod && type && type->der) {\n            tmod = type->der->module;\n            for (i = 0; i < tmod->imp_size; i++) {\n                if (!strncmp(mod_name, tmod->imp[i].module->name, mod_name_len) && !tmod->imp[i].module->name[mod_name_len]) {\n                    imod = tmod->imp[i].module;\n                    break;\n                }\n            }\n        }\n    } else {\n        /* solving identityref in data - get the module from the context */\n        for (i = 0; i < (unsigned)mod->ctx->models.used; ++i) {\n            imod = mod->ctx->models.list[i];\n            if (!strncmp(mod_name, imod->name, mod_name_len) && !imod->name[mod_name_len]) {\n                break;\n            }\n            imod = NULL;\n        }\n        if (!imod && mod->ctx->models.parsing_sub_modules_count) {\n            /* we are currently parsing some module and checking XPath or a default value,\n             * so take this module into account */\n            for (i = 0; i < mod->ctx->models.parsing_sub_modules_count; i++) {\n                imod = mod->ctx->models.parsing_sub_modules[i];\n                if (imod->type) {\n                    /* skip submodules */\n                    continue;\n                }\n                if (!strncmp(mod_name, imod->name, mod_name_len) && !imod->name[mod_name_len]) {\n                    break;\n                }\n                imod = NULL;\n            }\n        }\n    }\n\n    if (!dflt && (!imod || !imod->implemented) && ctx->data_clb) {\n        /* the needed module was not found, but it may have been expected so call the data callback */\n        if (imod) {\n            ctx->data_clb(ctx, imod->name, imod->ns, LY_MODCLB_NOT_IMPLEMENTED, ctx->data_clb_data);\n        } else if (mod_name) {\n            str = strndup(mod_name, mod_name_len);\n            imod = (struct lys_module *)ctx->data_clb(ctx, str, NULL, 0, ctx->data_clb_data);\n            free(str);\n        }\n    }\n    if (!imod) {\n        goto fail;\n    }\n\n    if (m != imod || lys_main_module(type->parent->module) != mod) {\n        /* the type is not referencing the same schema,\n         * THEN, we may need to make the module with the identity implemented, but only if it really\n         * contains the identity */\n        if (!imod->implemented) {\n            cur = NULL;\n            /* get the identity in the module */\n            for (i = 0; i < imod->ident_size; i++) {\n                if (!strcmp(name, imod->ident[i].name)) {\n                    cur = &imod->ident[i];\n                    break;\n                }\n            }\n            if (!cur) {\n                /* go through includes */\n                for (j = 0; j < imod->inc_size; j++) {\n                    for (i = 0; i < imod->inc[j].submodule->ident_size; i++) {\n                        if (!strcmp(name, imod->inc[j].submodule->ident[i].name)) {\n                            cur = &imod->inc[j].submodule->ident[i];\n                            break;\n                        }\n                    }\n                }\n                if (!cur) {\n                    goto fail;\n                }\n            }\n\n            /* check that identity is derived from one of the type's base */\n            while (type->der) {\n                for (i = 0; i < type->info.ident.count; i++) {\n                    if (search_base_identity(cur, type->info.ident.ref[i])) {\n                        /* cur's base matches the type's base */\n                        need_implemented = 1;\n                        goto match;\n                    }\n                }\n                type = &type->der->type;\n            }\n            /* matching base not found */\n            LOGVAL(ctx, LYE_SPEC, node ? LY_VLOG_LYD : LY_VLOG_NONE, node, \"Identity used as identityref value is not implemented.\");\n            goto fail;\n        }\n    }\n\n    /* go through all the derived types of all the bases */\n    while (type->der) {\n        for (i = 0; i < type->info.ident.count; ++i) {\n            cur = type->info.ident.ref[i];\n\n            if (cur->der) {\n                /* there are some derived identities */\n                for (j = 0; j < cur->der->number; j++) {\n                    der = (struct lys_ident *)cur->der->set.g[j]; /* shortcut */\n                    if (!strcmp(der->name, name) && lys_main_module(der->module) == imod) {\n                        /* we have match */\n                        cur = der;\n                        goto match;\n                    }\n                }\n            }\n        }\n        type = &type->der->type;\n    }\n\nfail:\n    LOGVAL(ctx, LYE_INRESOLV, node ? LY_VLOG_LYD : LY_VLOG_NONE, node, \"identityref\", ident_name);\n    return NULL;\n\nmatch:\n    for (i = 0; i < cur->iffeature_size; i++) {\n        if (!resolve_iffeature(&cur->iffeature[i])) {\n            if (node) {\n                LOGVAL(ctx, LYE_INVAL, LY_VLOG_LYD, node, cur->name, node->schema->name);\n            }\n            LOGVAL(ctx, LYE_SPEC, LY_VLOG_PREV, NULL, \"Identity \\\"%s\\\" is disabled by its if-feature condition.\", cur->name);\n            return NULL;\n        }\n    }\n    if (need_implemented) {\n        if (dflt) {\n            /* later try to make the module implemented */\n            LOGVRB(\"Making \\\"%s\\\" module implemented because of identityref default value \\\"%s\\\" used in the implemented \\\"%s\\\" module\",\n                   imod->name, cur->name, mod->name);\n            /* to be more effective we should use UNRES_MOD_IMPLEMENT but that would require changing prototype of\n             * several functions with little gain */\n            if (lys_set_implemented(imod)) {\n                LOGERR(ctx, ly_errno, \"Setting the module \\\"%s\\\" implemented because of used default identity \\\"%s\\\" failed.\",\n                       imod->name, cur->name);\n                goto fail;\n            }\n        } else {\n            /* just say that it was found, but in a non-implemented module */\n            LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Identity found, but in a non-implemented module \\\"%s\\\".\",\n                   lys_main_module(cur->module)->name);\n            goto fail;\n        }\n    }\n    return cur;\n}\n\n/**\n * @brief Resolve unresolved uses. Logs directly.\n *\n * @param[in] uses Uses to use.\n * @param[in] unres Specific unres item.\n *\n * @return EXIT_SUCCESS on success, EXIT_FAILURE on forward reference, -1 on error.\n */\nstatic int\nresolve_unres_schema_uses(struct lys_node_uses *uses, struct unres_schema *unres)\n{\n    int rc;\n    struct lys_node *par_grp;\n    struct ly_ctx *ctx = uses->module->ctx;\n\n    /* HACK: when a grouping has uses inside, all such uses have to be resolved before the grouping itself is used\n     *       in some uses. When we see such a uses, the grouping's unres counter is used to store number of so far\n     *       unresolved uses. The grouping cannot be used unless this counter is decreased back to 0. To remember\n     *       that the uses already increased grouping's counter, the LYS_USESGRP flag is used. */\n    for (par_grp = lys_parent((struct lys_node *)uses); par_grp && (par_grp->nodetype != LYS_GROUPING); par_grp = lys_parent(par_grp));\n    if (par_grp && ly_strequal(par_grp->name, uses->name, 1)) {\n        LOGVAL(ctx, LYE_INRESOLV, LY_VLOG_LYS, uses, \"uses\", uses->name);\n        return -1;\n    }\n\n    if (!uses->grp) {\n        rc = resolve_uses_schema_nodeid(uses->name, (const struct lys_node *)uses, (const struct lys_node_grp **)&uses->grp);\n        if (rc == -1) {\n            LOGVAL(ctx, LYE_INRESOLV, LY_VLOG_LYS, uses, \"uses\", uses->name);\n            return -1;\n        } else if (rc > 0) {\n            LOGVAL(ctx, LYE_INCHAR, LY_VLOG_LYS, uses, uses->name[rc - 1], &uses->name[rc - 1]);\n            return -1;\n        } else if (!uses->grp) {\n            if (par_grp && !(uses->flags & LYS_USESGRP)) {\n                if (++((struct lys_node_grp *)par_grp)->unres_count == 0) {\n                    LOGERR(ctx, LY_EINT, \"Too many unresolved items (uses) inside a grouping.\");\n                    return -1;\n                }\n                uses->flags |= LYS_USESGRP;\n            }\n            LOGVAL(ctx, LYE_INRESOLV, LY_VLOG_LYS, uses, \"uses\", uses->name);\n            return EXIT_FAILURE;\n        }\n    }\n\n    if (uses->grp->unres_count) {\n        if (par_grp && !(uses->flags & LYS_USESGRP)) {\n            if (++((struct lys_node_grp *)par_grp)->unres_count == 0) {\n                LOGERR(ctx, LY_EINT, \"Too many unresolved items (uses) inside a grouping.\");\n                return -1;\n            }\n            uses->flags |= LYS_USESGRP;\n        } else {\n            /* instantiate grouping only when it is completely resolved */\n            uses->grp = NULL;\n        }\n        LOGVAL(ctx, LYE_INRESOLV, LY_VLOG_LYS, uses, \"uses\", uses->name);\n        return EXIT_FAILURE;\n    }\n\n    rc = resolve_uses(uses, unres);\n    if (!rc) {\n        /* decrease unres count only if not first try */\n        if (par_grp && (uses->flags & LYS_USESGRP)) {\n            assert(((struct lys_node_grp *)par_grp)->unres_count);\n            ((struct lys_node_grp *)par_grp)->unres_count--;\n            uses->flags &= ~LYS_USESGRP;\n        }\n\n        /* check status */\n        if (lyp_check_status(uses->flags, uses->module, \"of uses\",\n                         uses->grp->flags, uses->grp->module, uses->grp->name,\n                         (struct lys_node *)uses)) {\n            return -1;\n        }\n\n        return EXIT_SUCCESS;\n    }\n\n    return rc;\n}\n\n/**\n * @brief Resolve list keys. Logs directly.\n *\n * @param[in] list List to use.\n * @param[in] keys_str Keys node value.\n *\n * @return EXIT_SUCCESS on success, EXIT_FAILURE on forward reference, -1 on error.\n */\nstatic int\nresolve_list_keys(struct lys_node_list *list, const char *keys_str)\n{\n    int i, len, rc;\n    const char *value;\n    char *s = NULL;\n    struct ly_ctx *ctx = list->module->ctx;\n\n    for (i = 0; i < list->keys_size; ++i) {\n        assert(keys_str);\n\n        if (!list->child) {\n            /* no child, possible forward reference */\n            LOGVAL(ctx, LYE_INRESOLV, LY_VLOG_LYS, list, \"list keys\", keys_str);\n            return EXIT_FAILURE;\n        }\n        /* get the key name */\n        if ((value = strpbrk(keys_str, \" \\t\\n\"))) {\n            len = value - keys_str;\n            while (isspace(value[0])) {\n                value++;\n            }\n        } else {\n            len = strlen(keys_str);\n        }\n\n        rc = lys_getnext_data(lys_node_module((struct lys_node *)list), (struct lys_node *)list, keys_str, len, LYS_LEAF,\n                              LYS_GETNEXT_NOSTATECHECK, (const struct lys_node **)&list->keys[i]);\n        if (rc) {\n            LOGVAL(ctx, LYE_INRESOLV, LY_VLOG_LYS, list, \"list key\", keys_str);\n            return EXIT_FAILURE;\n        }\n\n        if (check_key(list, i, keys_str, len)) {\n            /* check_key logs */\n            return -1;\n        }\n\n        /* check status */\n        if (lyp_check_status(list->flags, list->module, list->name,\n                             list->keys[i]->flags, list->keys[i]->module, list->keys[i]->name,\n                             (struct lys_node *)list->keys[i])) {\n            return -1;\n        }\n\n        /* default value - is ignored, keep it but print a warning */\n        if (list->keys[i]->dflt) {\n            /* log is not hidden only in case this resolving fails and in such a case\n             * we cannot get here\n             */\n            assert(log_opt == ILO_STORE);\n            log_opt = ILO_LOG;\n            LOGWRN(ctx, \"Default value \\\"%s\\\" in the list key \\\"%s\\\" is ignored. (%s)\", list->keys[i]->dflt,\n                   list->keys[i]->name, s = lys_path((struct lys_node*)list, LYS_PATH_FIRST_PREFIX));\n            log_opt = ILO_STORE;\n            free(s);\n        }\n\n        /* prepare for next iteration */\n        while (value && isspace(value[0])) {\n            value++;\n        }\n        keys_str = value;\n    }\n\n    return EXIT_SUCCESS;\n}\n\n/**\n * @brief Resolve (check) all must conditions of \\p node.\n * Logs directly.\n *\n * @param[in] node Data node with optional must statements.\n * @param[in] inout_parent If set, must in input or output parent of node->schema will be resolved.\n *\n * @return EXIT_SUCCESS on pass, EXIT_FAILURE on fail, -1 on error.\n */\nstatic int\nresolve_must(struct lyd_node *node, int inout_parent, int ignore_fail)\n{\n    uint8_t i, must_size;\n    struct lys_node *schema;\n    struct lys_restr *must;\n    struct lyxp_set set;\n    struct ly_ctx *ctx = node->schema->module->ctx;\n\n    assert(node);\n    memset(&set, 0, sizeof set);\n\n    if (inout_parent) {\n        for (schema = lys_parent(node->schema);\n             schema && (schema->nodetype & (LYS_CHOICE | LYS_CASE | LYS_USES));\n             schema = lys_parent(schema));\n        if (!schema || !(schema->nodetype & (LYS_INPUT | LYS_OUTPUT))) {\n            LOGINT(ctx);\n            return -1;\n        }\n        must_size = ((struct lys_node_inout *)schema)->must_size;\n        must = ((struct lys_node_inout *)schema)->must;\n\n        /* context node is the RPC/action */\n        node = node->parent;\n        if (!(node->schema->nodetype & (LYS_RPC | LYS_ACTION))) {\n            LOGINT(ctx);\n            return -1;\n        }\n    } else {\n        switch (node->schema->nodetype) {\n        case LYS_CONTAINER:\n            must_size = ((struct lys_node_container *)node->schema)->must_size;\n            must = ((struct lys_node_container *)node->schema)->must;\n            break;\n        case LYS_LEAF:\n            must_size = ((struct lys_node_leaf *)node->schema)->must_size;\n            must = ((struct lys_node_leaf *)node->schema)->must;\n            break;\n        case LYS_LEAFLIST:\n            must_size = ((struct lys_node_leaflist *)node->schema)->must_size;\n            must = ((struct lys_node_leaflist *)node->schema)->must;\n            break;\n        case LYS_LIST:\n            must_size = ((struct lys_node_list *)node->schema)->must_size;\n            must = ((struct lys_node_list *)node->schema)->must;\n            break;\n        case LYS_ANYXML:\n        case LYS_ANYDATA:\n            must_size = ((struct lys_node_anydata *)node->schema)->must_size;\n            must = ((struct lys_node_anydata *)node->schema)->must;\n            break;\n        case LYS_NOTIF:\n            must_size = ((struct lys_node_notif *)node->schema)->must_size;\n            must = ((struct lys_node_notif *)node->schema)->must;\n            break;\n        default:\n            must_size = 0;\n            break;\n        }\n    }\n\n    for (i = 0; i < must_size; ++i) {\n        if (lyxp_eval(must[i].expr, node, LYXP_NODE_ELEM, lyd_node_module(node), &set, LYXP_MUST)) {\n            return -1;\n        }\n\n        lyxp_set_cast(&set, LYXP_SET_BOOLEAN, node, lyd_node_module(node), LYXP_MUST);\n\n        if (!set.val.bool) {\n            if ((ignore_fail == 1) || ((must[i].flags & (LYS_XPCONF_DEP | LYS_XPSTATE_DEP)) && (ignore_fail == 2))) {\n                LOGVRB(\"Must condition \\\"%s\\\" not satisfied, but it is not required.\", must[i].expr);\n            } else {\n                LOGVAL(ctx, LYE_NOMUST, LY_VLOG_LYD, node, must[i].expr);\n                if (must[i].emsg) {\n                    ly_vlog_str(ctx, LY_VLOG_PREV, must[i].emsg);\n                }\n                if (must[i].eapptag) {\n                    ly_err_last_set_apptag(ctx, must[i].eapptag);\n                }\n                return 1;\n            }\n        }\n    }\n\n    return EXIT_SUCCESS;\n}\n\n/**\n * @brief Resolve (find) when condition schema context node. Does not log.\n *\n * @param[in] schema Schema node with the when condition.\n * @param[out] ctx_snode When schema context node.\n * @param[out] ctx_snode_type Schema context node type.\n */\nvoid\nresolve_when_ctx_snode(const struct lys_node *schema, struct lys_node **ctx_snode, enum lyxp_node_type *ctx_snode_type)\n{\n    const struct lys_node *sparent;\n\n    /* find a not schema-only node */\n    *ctx_snode_type = LYXP_NODE_ELEM;\n    while (schema->nodetype & (LYS_USES | LYS_CHOICE | LYS_CASE | LYS_AUGMENT | LYS_INPUT | LYS_OUTPUT)) {\n        if (schema->nodetype == LYS_AUGMENT) {\n            sparent = ((struct lys_node_augment *)schema)->target;\n        } else {\n            sparent = schema->parent;\n        }\n        if (!sparent) {\n            /* context node is the document root (fake root in our case) */\n            if (schema->flags & LYS_CONFIG_W) {\n                *ctx_snode_type = LYXP_NODE_ROOT_CONFIG;\n            } else {\n                *ctx_snode_type = LYXP_NODE_ROOT;\n            }\n            /* we need the first top-level sibling, but no uses or groupings */\n            schema = lys_getnext(NULL, NULL, lys_node_module(schema), LYS_GETNEXT_NOSTATECHECK);\n            break;\n        }\n        schema = sparent;\n    }\n\n    *ctx_snode = (struct lys_node *)schema;\n}\n\n/**\n * @brief Resolve (find) when condition context node. Does not log.\n *\n * @param[in] node Data node, whose conditional definition is being decided.\n * @param[in] schema Schema node with the when condition.\n * @param[out] ctx_node Context node.\n * @param[out] ctx_node_type Context node type.\n *\n * @return EXIT_SUCCESS on success, -1 on error.\n */\nstatic int\nresolve_when_ctx_node(struct lyd_node *node, struct lys_node *schema, struct lyd_node **ctx_node,\n                      enum lyxp_node_type *ctx_node_type)\n{\n    struct lyd_node *parent;\n    struct lys_node *sparent;\n    enum lyxp_node_type node_type;\n    uint16_t i, data_depth, schema_depth;\n\n    resolve_when_ctx_snode(schema, &schema, &node_type);\n\n    if (node_type == LYXP_NODE_ELEM) {\n        /* standard element context node */\n        for (parent = node, data_depth = 0; parent; parent = parent->parent, ++data_depth);\n        for (sparent = schema, schema_depth = 0;\n                sparent;\n                sparent = (sparent->nodetype == LYS_AUGMENT ? ((struct lys_node_augment *)sparent)->target : sparent->parent)) {\n            if (sparent->nodetype & (LYS_CONTAINER | LYS_LEAF | LYS_LEAFLIST | LYS_LIST | LYS_ANYDATA | LYS_NOTIF | LYS_RPC)) {\n                ++schema_depth;\n            }\n        }\n        if (data_depth < schema_depth) {\n            return -1;\n        }\n\n        /* find the corresponding data node */\n        for (i = 0; i < data_depth - schema_depth; ++i) {\n            node = node->parent;\n        }\n        if (node->schema != schema) {\n            return -1;\n        }\n    } else {\n        /* root context node */\n        while (node->parent) {\n            node = node->parent;\n        }\n        while (node->prev->next) {\n            node = node->prev;\n        }\n    }\n\n    *ctx_node = node;\n    *ctx_node_type = node_type;\n    return EXIT_SUCCESS;\n}\n\n/**\n * @brief Temporarily unlink nodes as per YANG 1.1 RFC section 7.21.5 for when XPath evaluation.\n * The context node is adjusted if needed.\n *\n * @param[in] snode Schema node, whose children instances need to be unlinked.\n * @param[in,out] node Data siblings where to look for the children of \\p snode. If it is unlinked,\n * it is moved to point to another sibling still in the original tree.\n * @param[in,out] ctx_node When context node, adjusted if needed.\n * @param[in] ctx_node_type Context node type, just for information to detect invalid situations.\n * @param[out] unlinked_nodes Unlinked siblings. Can be safely appended to \\p node afterwards.\n * Ordering may change, but there will be no semantic change.\n *\n * @return EXIT_SUCCESS on success, -1 on error.\n */\nstatic int\nresolve_when_unlink_nodes(struct lys_node *snode, struct lyd_node **node, struct lyd_node **ctx_node,\n                          enum lyxp_node_type ctx_node_type, struct lyd_node **unlinked_nodes)\n{\n    struct lyd_node *next, *elem;\n    const struct lys_node *slast;\n    struct ly_ctx *ctx = snode->module->ctx;\n\n    switch (snode->nodetype) {\n    case LYS_AUGMENT:\n    case LYS_USES:\n    case LYS_CHOICE:\n    case LYS_CASE:\n        slast = NULL;\n        while ((slast = lys_getnext(slast, snode, NULL, LYS_GETNEXT_PARENTUSES))) {\n            if (slast->nodetype & (LYS_ACTION | LYS_NOTIF)) {\n                continue;\n            }\n\n            if (resolve_when_unlink_nodes((struct lys_node *)slast, node, ctx_node, ctx_node_type, unlinked_nodes)) {\n                return -1;\n            }\n        }\n        break;\n    case LYS_CONTAINER:\n    case LYS_LIST:\n    case LYS_LEAF:\n    case LYS_LEAFLIST:\n    case LYS_ANYXML:\n    case LYS_ANYDATA:\n        LY_TREE_FOR_SAFE(lyd_first_sibling(*node), next, elem) {\n            if (elem->schema == snode) {\n\n                if (elem == *ctx_node) {\n                    /* We are going to unlink our context node! This normally cannot happen,\n                     * but we use normal top-level data nodes for faking a document root node,\n                     * so if this is the context node, we just use the next top-level node.\n                     * Additionally, it can even happen that there are no top-level data nodes left,\n                     * all were unlinked, so in this case we pass NULL as the context node/data tree,\n                     * lyxp_eval() can handle this special situation.\n                     */\n                    if (ctx_node_type == LYXP_NODE_ELEM) {\n                        LOGINT(ctx);\n                        return -1;\n                    }\n\n                    if (elem->prev == elem) {\n                        /* unlinking last top-level element, use an empty data tree */\n                        *ctx_node = NULL;\n                    } else {\n                        /* in this case just use the previous/last top-level data node */\n                        *ctx_node = elem->prev;\n                    }\n                } else if (elem == *node) {\n                    /* We are going to unlink the currently processed node. This does not matter that\n                     * much, but we would lose access to the original data tree, so just move our\n                     * pointer somewhere still inside it.\n                     */\n                    if ((*node)->prev != *node) {\n                        *node = (*node)->prev;\n                    } else {\n                        /* the processed node with sibings were all unlinked, oh well */\n                        *node = NULL;\n                    }\n                }\n\n                /* temporarily unlink the node */\n                lyd_unlink_internal(elem, 0);\n                if (*unlinked_nodes) {\n                    if (lyd_insert_after((*unlinked_nodes)->prev, elem)) {\n                        LOGINT(ctx);\n                        return -1;\n                    }\n                } else {\n                    *unlinked_nodes = elem;\n                }\n\n                if (snode->nodetype & (LYS_CONTAINER | LYS_LEAF | LYS_ANYDATA)) {\n                    /* there can be only one instance */\n                    break;\n                }\n            }\n        }\n        break;\n    default:\n        LOGINT(ctx);\n        return -1;\n    }\n\n    return EXIT_SUCCESS;\n}\n\n/**\n * @brief Relink the unlinked nodes back.\n *\n * @param[in] node Data node to link the nodes back to. It can actually be the adjusted context node,\n * we simply need a sibling from the original data tree.\n * @param[in] unlinked_nodes Unlinked nodes to relink to \\p node.\n * @param[in] ctx_node_type Context node type to distinguish between \\p node being the parent\n * or the sibling of \\p unlinked_nodes.\n *\n * @return EXIT_SUCCESS on success, -1 on error.\n */\nstatic int\nresolve_when_relink_nodes(struct lyd_node *node, struct lyd_node *unlinked_nodes, enum lyxp_node_type ctx_node_type)\n{\n    struct lyd_node *elem;\n\n    LY_TREE_FOR_SAFE(unlinked_nodes, unlinked_nodes, elem) {\n        lyd_unlink_internal(elem, 0);\n        if (ctx_node_type == LYXP_NODE_ELEM) {\n            if (lyd_insert_common(node, NULL, elem, 0)) {\n                return -1;\n            }\n        } else {\n            if (lyd_insert_nextto(node, elem, 0, 0)) {\n                return -1;\n            }\n        }\n    }\n\n    return EXIT_SUCCESS;\n}\n\nint\nresolve_applies_must(const struct lyd_node *node)\n{\n    int ret = 0;\n    uint8_t must_size;\n    struct lys_node *schema, *iter;\n\n    assert(node);\n\n    schema = node->schema;\n\n    /* their own must */\n    switch (schema->nodetype) {\n    case LYS_CONTAINER:\n        must_size = ((struct lys_node_container *)schema)->must_size;\n        break;\n    case LYS_LEAF:\n        must_size = ((struct lys_node_leaf *)schema)->must_size;\n        break;\n    case LYS_LEAFLIST:\n        must_size = ((struct lys_node_leaflist *)schema)->must_size;\n        break;\n    case LYS_LIST:\n        must_size = ((struct lys_node_list *)schema)->must_size;\n        break;\n    case LYS_ANYXML:\n    case LYS_ANYDATA:\n        must_size = ((struct lys_node_anydata *)schema)->must_size;\n        break;\n    case LYS_NOTIF:\n        must_size = ((struct lys_node_notif *)schema)->must_size;\n        break;\n    default:\n        must_size = 0;\n        break;\n    }\n\n    if (must_size) {\n        ++ret;\n    }\n\n    /* schema may be a direct data child of input/output with must (but it must be first, it needs to be evaluated only once) */\n    if (!node->prev->next) {\n        for (iter = lys_parent(schema); iter && (iter->nodetype & (LYS_CHOICE | LYS_CASE | LYS_USES)); iter = lys_parent(iter));\n        if (iter && (iter->nodetype & (LYS_INPUT | LYS_OUTPUT))) {\n            ret += 0x2;\n        }\n    }\n\n    return ret;\n}\n\nstatic struct lys_when *\nsnode_get_when(const struct lys_node *schema)\n{\n    switch (schema->nodetype) {\n    case LYS_CONTAINER:\n        return ((struct lys_node_container *)schema)->when;\n    case LYS_CHOICE:\n        return ((struct lys_node_choice *)schema)->when;\n    case LYS_LEAF:\n        return ((struct lys_node_leaf *)schema)->when;\n    case LYS_LEAFLIST:\n        return ((struct lys_node_leaflist *)schema)->when;\n    case LYS_LIST:\n        return ((struct lys_node_list *)schema)->when;\n    case LYS_ANYDATA:\n    case LYS_ANYXML:\n        return ((struct lys_node_anydata *)schema)->when;\n    case LYS_CASE:\n        return ((struct lys_node_case *)schema)->when;\n    case LYS_USES:\n        return ((struct lys_node_uses *)schema)->when;\n    case LYS_AUGMENT:\n        return ((struct lys_node_augment *)schema)->when;\n    default:\n        return NULL;\n    }\n}\n\nint\nresolve_applies_when(const struct lys_node *schema, int mode, const struct lys_node *stop)\n{\n    const struct lys_node *parent;\n\n    assert(schema);\n\n    if (!(schema->nodetype & (LYS_NOTIF | LYS_RPC)) && snode_get_when(schema)) {\n        return 1;\n    }\n\n    parent = schema;\n    goto check_augment;\n\n    while (parent) {\n        /* stop conditions */\n        if (!mode) {\n            /* stop on node that can be instantiated in data tree */\n            if (!(parent->nodetype & (LYS_USES | LYS_CHOICE | LYS_CASE))) {\n                break;\n            }\n        } else {\n            /* stop on the specified node */\n            if (parent == stop) {\n                break;\n            }\n        }\n\n        if (snode_get_when(parent)) {\n            return 1;\n        }\ncheck_augment:\n\n        if (parent->parent && (parent->parent->nodetype == LYS_AUGMENT) && snode_get_when(parent->parent)) {\n            return 1;\n        }\n        parent = lys_parent(parent);\n    }\n\n    return 0;\n}\n\n/**\n * @brief Resolve (check) all when conditions relevant for \\p node.\n * Logs directly.\n *\n * @param[in] node Data node, whose conditional reference, if such, is being decided.\n * @param[in] ignore_fail 1 if when does not have to be satisfied, 2 if it does not have to be satisfied\n * only when requiring external dependencies.\n *\n * @return\n *  -1 - error, ly_errno is set\n *   0 - all \"when\" statements true\n *   0, ly_vecode = LYVE_NOWHEN - some \"when\" statement false, returned in failed_when\n *   1, ly_vecode = LYVE_INWHEN - nodes needed to resolve are conditional and not yet resolved (under another \"when\")\n */\nint\nresolve_when(struct lyd_node *node, int ignore_fail, struct lys_when **failed_when)\n{\n    struct lyd_node *ctx_node = NULL, *unlinked_nodes, *tmp_node;\n    struct lys_node *sparent;\n    struct lyxp_set set;\n    enum lyxp_node_type ctx_node_type;\n    struct ly_ctx *ctx = node->schema->module->ctx;\n    int rc = 0;\n\n    assert(node);\n    memset(&set, 0, sizeof set);\n\n    if (!(node->schema->nodetype & (LYS_NOTIF | LYS_RPC | LYS_ACTION)) && snode_get_when(node->schema)) {\n        /* make the node dummy for the evaluation */\n        node->validity |= LYD_VAL_INUSE;\n        rc = lyxp_eval(snode_get_when(node->schema)->cond, node, LYXP_NODE_ELEM, lyd_node_module(node),\n                       &set, LYXP_WHEN);\n        node->validity &= ~LYD_VAL_INUSE;\n        if (rc) {\n            if (rc == 1) {\n                LOGVAL(ctx, LYE_INWHEN, LY_VLOG_LYD, node, snode_get_when(node->schema)->cond);\n            }\n            goto cleanup;\n        }\n\n        /* set boolean result of the condition */\n        lyxp_set_cast(&set, LYXP_SET_BOOLEAN, node, lyd_node_module(node), LYXP_WHEN);\n        if (!set.val.bool) {\n            node->when_status |= LYD_WHEN_FALSE;\n            if ((ignore_fail == 1) || ((snode_get_when(node->schema)->flags & (LYS_XPCONF_DEP | LYS_XPSTATE_DEP))\n                    && (ignore_fail == 2))) {\n                LOGVRB(\"When condition \\\"%s\\\" is not satisfied, but it is not required.\", snode_get_when(node->schema)->cond);\n            } else {\n                LOGVAL(ctx, LYE_NOWHEN, LY_VLOG_LYD, node, snode_get_when(node->schema)->cond);\n                if (failed_when) {\n                    *failed_when = snode_get_when(node->schema);\n                }\n                goto cleanup;\n            }\n        }\n\n        /* free xpath set content */\n        lyxp_set_cast(&set, LYXP_SET_EMPTY, node, lyd_node_module(node), 0);\n    }\n\n    sparent = node->schema;\n    goto check_augment;\n\n    /* check when in every schema node that affects node */\n    while (sparent && (sparent->nodetype & (LYS_USES | LYS_CHOICE | LYS_CASE))) {\n        if (snode_get_when(sparent)) {\n            if (!ctx_node) {\n                rc = resolve_when_ctx_node(node, sparent, &ctx_node, &ctx_node_type);\n                if (rc) {\n                    LOGINT(ctx);\n                    goto cleanup;\n                }\n            }\n\n            unlinked_nodes = NULL;\n            /* we do not want our node pointer to change */\n            tmp_node = node;\n            rc = resolve_when_unlink_nodes(sparent, &tmp_node, &ctx_node, ctx_node_type, &unlinked_nodes);\n            if (rc) {\n                goto cleanup;\n            }\n\n            rc = lyxp_eval(snode_get_when(sparent)->cond, ctx_node, ctx_node_type, lys_node_module(sparent),\n                           &set, LYXP_WHEN);\n\n            if (unlinked_nodes && ctx_node) {\n                if (resolve_when_relink_nodes(ctx_node, unlinked_nodes, ctx_node_type)) {\n                    rc = -1;\n                    goto cleanup;\n                }\n            }\n\n            if (rc) {\n                if (rc == 1) {\n                    LOGVAL(ctx, LYE_INWHEN, LY_VLOG_LYD, node, snode_get_when(sparent)->cond);\n                }\n                goto cleanup;\n            }\n\n            lyxp_set_cast(&set, LYXP_SET_BOOLEAN, ctx_node, lys_node_module(sparent), LYXP_WHEN);\n            if (!set.val.bool) {\n                if ((ignore_fail == 1) || ((snode_get_when(sparent)->flags & (LYS_XPCONF_DEP | LYS_XPSTATE_DEP))\n                        && (ignore_fail == 2))) {\n                    LOGVRB(\"When condition \\\"%s\\\" is not satisfied, but it is not required.\", snode_get_when(sparent)->cond);\n                } else {\n                    node->when_status |= LYD_WHEN_FALSE;\n                    LOGVAL(ctx, LYE_NOWHEN, LY_VLOG_LYD, node, snode_get_when(sparent)->cond);\n                    if (failed_when) {\n                        *failed_when = snode_get_when(sparent);\n                    }\n                    goto cleanup;\n                }\n            }\n\n            /* free xpath set content */\n            lyxp_set_cast(&set, LYXP_SET_EMPTY, ctx_node, lys_node_module(sparent), 0);\n        }\n\ncheck_augment:\n        if ((sparent->parent && (sparent->parent->nodetype == LYS_AUGMENT) && snode_get_when(sparent->parent))) {\n            if (!ctx_node) {\n                rc = resolve_when_ctx_node(node, sparent->parent, &ctx_node, &ctx_node_type);\n                if (rc) {\n                    LOGINT(ctx);\n                    goto cleanup;\n                }\n            }\n\n            unlinked_nodes = NULL;\n            tmp_node = node;\n            rc = resolve_when_unlink_nodes(sparent->parent, &tmp_node, &ctx_node, ctx_node_type, &unlinked_nodes);\n            if (rc) {\n                goto cleanup;\n            }\n\n            rc = lyxp_eval(snode_get_when(sparent->parent)->cond, ctx_node, ctx_node_type,\n                           lys_node_module(sparent->parent), &set, LYXP_WHEN);\n\n            /* reconnect nodes, if ctx_node is NULL then all the nodes were unlinked, but linked together,\n             * so the tree did not actually change and there is nothing for us to do\n             */\n            if (unlinked_nodes && ctx_node) {\n                if (resolve_when_relink_nodes(ctx_node, unlinked_nodes, ctx_node_type)) {\n                    rc = -1;\n                    goto cleanup;\n                }\n            }\n\n            if (rc) {\n                if (rc == 1) {\n                    LOGVAL(ctx, LYE_INWHEN, LY_VLOG_LYD, node, snode_get_when(sparent->parent)->cond);\n                }\n                goto cleanup;\n            }\n\n            lyxp_set_cast(&set, LYXP_SET_BOOLEAN, ctx_node, lys_node_module(sparent->parent), LYXP_WHEN);\n            if (!set.val.bool) {\n                node->when_status |= LYD_WHEN_FALSE;\n                if ((ignore_fail == 1) || ((snode_get_when(sparent->parent)->flags & (LYS_XPCONF_DEP | LYS_XPSTATE_DEP))\n                        && (ignore_fail == 2))) {\n                    LOGVRB(\"When condition \\\"%s\\\" is not satisfied, but it is not required.\",\n                           snode_get_when(sparent->parent)->cond);\n                } else {\n                    LOGVAL(ctx, LYE_NOWHEN, LY_VLOG_LYD, node, snode_get_when(sparent->parent)->cond);\n                    if (failed_when) {\n                        *failed_when = snode_get_when(sparent->parent);\n                    }\n                    goto cleanup;\n                }\n            }\n\n            /* free xpath set content */\n            lyxp_set_cast(&set, LYXP_SET_EMPTY, ctx_node, lys_node_module(sparent->parent), 0);\n        }\n\n        sparent = lys_parent(sparent);\n    }\n\n    node->when_status |= LYD_WHEN_TRUE;\n\ncleanup:\n    /* free xpath set content */\n    lyxp_set_cast(&set, LYXP_SET_EMPTY, ctx_node ? ctx_node : node, NULL, 0);\n    return rc;\n}\n\nstatic int\ncheck_type_union_leafref(struct lys_type *type)\n{\n    uint8_t i;\n\n    if ((type->base == LY_TYPE_UNION) && type->info.uni.count) {\n        /* go through unions and look for leafref */\n        for (i = 0; i < type->info.uni.count; ++i) {\n            switch (type->info.uni.types[i].base) {\n            case LY_TYPE_LEAFREF:\n                return 1;\n            case LY_TYPE_UNION:\n                if (check_type_union_leafref(&type->info.uni.types[i])) {\n                    return 1;\n                }\n                break;\n            default:\n                break;\n            }\n        }\n\n        return 0;\n    }\n\n    /* just inherit the flag value */\n    return type->der->has_union_leafref;\n}\n\n/**\n * @brief Resolve a single unres schema item. Logs indirectly.\n *\n * @param[in] mod Main module.\n * @param[in] item Item to resolve. Type determined by \\p type.\n * @param[in] type Type of the unresolved item.\n * @param[in] str_snode String, a schema node, or NULL.\n * @param[in] unres Unres schema structure to use.\n * @param[in] final_fail Whether we are just printing errors of the failed unres items.\n *\n * @return EXIT_SUCCESS on success, EXIT_FAILURE on forward reference, -1 on error.\n */\nstatic int\nresolve_unres_schema_item(struct lys_module *mod, void *item, enum UNRES_ITEM type, void *str_snode,\n                          struct unres_schema *unres)\n{\n    /* has_str - whether the str_snode is a string in a dictionary that needs to be freed */\n    int rc = -1, has_str = 0, parent_type = 0, i, k;\n    unsigned int j;\n    struct ly_ctx * ctx = mod->ctx;\n    struct lys_node *root, *next, *node, *par_grp;\n    const char *expr;\n    uint8_t *u;\n\n    struct ly_set *refs, *procs;\n    struct lys_feature *ref, *feat;\n    struct lys_ident *ident;\n    struct lys_type *stype;\n    struct lys_node_choice *choic;\n    struct lyxml_elem *yin;\n    struct yang_type *yang;\n    struct unres_list_uniq *unique_info;\n    struct unres_iffeat_data *iff_data;\n    struct unres_ext *ext_data;\n    struct lys_ext_instance *ext, **extlist;\n    struct lyext_plugin *eplugin;\n\n    switch (type) {\n    case UNRES_IDENT:\n        expr = str_snode;\n        has_str = 1;\n        ident = item;\n\n        rc = resolve_base_ident(mod, ident, expr, \"identity\", NULL, unres);\n        break;\n    case UNRES_TYPE_IDENTREF:\n        expr = str_snode;\n        has_str = 1;\n        stype = item;\n\n        rc = resolve_base_ident(mod, NULL, expr, \"type\", stype, unres);\n        break;\n    case UNRES_TYPE_LEAFREF:\n        node = str_snode;\n        stype = item;\n\n        rc = resolve_schema_leafref(stype, node, unres);\n        break;\n    case UNRES_TYPE_DER_EXT:\n        parent_type++;\n        /* falls through */\n    case UNRES_TYPE_DER_TPDF:\n        parent_type++;\n        /* falls through */\n    case UNRES_TYPE_DER:\n        /* parent */\n        node = str_snode;\n        stype = item;\n\n        /* HACK type->der is temporarily unparsed type statement */\n        yin = (struct lyxml_elem *)stype->der;\n        stype->der = NULL;\n\n        if (yin->flags & LY_YANG_STRUCTURE_FLAG) {\n            yang = (struct yang_type *)yin;\n            rc = yang_check_type(mod, node, yang, stype, parent_type, unres);\n\n            if (rc) {\n                /* may try again later */\n                stype->der = (struct lys_tpdf *)yang;\n            } else {\n                /* we need to always be able to free this, it's safe only in this case */\n                lydict_remove(ctx, yang->name);\n                free(yang);\n            }\n\n        } else {\n            rc = fill_yin_type(mod, node, yin, stype, parent_type, unres);\n            if (!rc || rc == -1) {\n                /* we need to always be able to free this, it's safe only in this case */\n                lyxml_free(ctx, yin);\n            } else {\n                /* may try again later, put all back how it was */\n                stype->der = (struct lys_tpdf *)yin;\n            }\n        }\n        if (rc == EXIT_SUCCESS) {\n            /* it does not make sense to have leaf-list of empty type */\n            if (!parent_type && node->nodetype == LYS_LEAFLIST && stype->base == LY_TYPE_EMPTY) {\n                LOGWRN(ctx, \"The leaf-list \\\"%s\\\" is of \\\"empty\\\" type, which does not make sense.\", node->name);\n            }\n\n            if ((type == UNRES_TYPE_DER_TPDF) && (stype->base == LY_TYPE_UNION)) {\n                /* fill typedef union leafref flag */\n                ((struct lys_tpdf *)stype->parent)->has_union_leafref = check_type_union_leafref(stype);\n            } else if ((type == UNRES_TYPE_DER) && stype->der->has_union_leafref) {\n                /* copy the type in case it has union leafref flag */\n                if (lys_copy_union_leafrefs(mod, node, stype, NULL, unres)) {\n                    LOGERR(ctx, LY_EINT, \"Failed to duplicate type.\");\n                    return -1;\n                }\n            }\n        } else if (rc == EXIT_FAILURE && !(stype->value_flags & LY_VALUE_UNRESGRP)) {\n            /* forward reference - in case the type is in grouping, we have to make the grouping unusable\n             * by uses statement until the type is resolved. We do that the same way as uses statements inside\n             * grouping. The grouping cannot be used unless the unres counter is 0.\n             * To remember that the grouping already increased the counter, the LYTYPE_GRP is used as value\n             * of the type's base member. */\n            for (par_grp = node; par_grp && (par_grp->nodetype != LYS_GROUPING); par_grp = lys_parent(par_grp));\n            if (par_grp) {\n                if (++((struct lys_node_grp *)par_grp)->unres_count == 0) {\n                    LOGERR(ctx, LY_EINT, \"Too many unresolved items (type) inside a grouping.\");\n                    return -1;\n                }\n                stype->value_flags |= LY_VALUE_UNRESGRP;\n            }\n        }\n        break;\n    case UNRES_IFFEAT:\n        iff_data = str_snode;\n        rc = resolve_feature(iff_data->fname, strlen(iff_data->fname), iff_data->node, item);\n        if (!rc) {\n            /* success */\n            if (iff_data->infeature) {\n                /* store backlink into the target feature to allow reverse changes in case of changing feature status */\n                feat = *((struct lys_feature **)item);\n                if (!feat->depfeatures) {\n                    feat->depfeatures = ly_set_new();\n                }\n                ly_set_add(feat->depfeatures, iff_data->node, LY_SET_OPT_USEASLIST);\n            }\n            /* cleanup temporary data */\n            lydict_remove(ctx, iff_data->fname);\n            free(iff_data);\n        }\n        break;\n    case UNRES_FEATURE:\n        feat = (struct lys_feature *)item;\n\n        if (feat->iffeature_size) {\n            refs = ly_set_new();\n            procs = ly_set_new();\n            ly_set_add(procs, feat, 0);\n\n            while (procs->number) {\n                ref = procs->set.g[procs->number - 1];\n                ly_set_rm_index(procs, procs->number - 1);\n\n                for (i = 0; i < ref->iffeature_size; i++) {\n                    resolve_iffeature_getsizes(&ref->iffeature[i], NULL, &j);\n                    for (; j > 0 ; j--) {\n                        if (ref->iffeature[i].features[j - 1]) {\n                            if (ref->iffeature[i].features[j - 1] == feat) {\n                                LOGVAL(ctx, LYE_CIRC_FEATURES, LY_VLOG_NONE, NULL, feat->name);\n                                goto featurecheckdone;\n                            }\n\n                            if (ref->iffeature[i].features[j - 1]->iffeature_size) {\n                                k = refs->number;\n                                if (ly_set_add(refs, ref->iffeature[i].features[j - 1], 0) == k) {\n                                    /* not yet seen feature, add it for processing */\n                                    ly_set_add(procs, ref->iffeature[i].features[j - 1], 0);\n                                }\n                            }\n                        } else {\n                            /* forward reference */\n                            rc = EXIT_FAILURE;\n                            goto featurecheckdone;\n                        }\n                    }\n\n                }\n            }\n            rc = EXIT_SUCCESS;\n\nfeaturecheckdone:\n            ly_set_free(refs);\n            ly_set_free(procs);\n        }\n\n        break;\n    case UNRES_USES:\n        rc = resolve_unres_schema_uses(item, unres);\n        break;\n    case UNRES_TYPEDEF_DFLT:\n        parent_type++;\n        /* falls through */\n    case UNRES_TYPE_DFLT:\n        stype = item;\n        rc = check_default(stype, (const char **)str_snode, mod, parent_type);\n        if ((rc == EXIT_FAILURE) && !parent_type && (stype->base == LY_TYPE_LEAFREF)) {\n            for (par_grp = (struct lys_node *)stype->parent;\n                 par_grp && (par_grp->nodetype != LYS_GROUPING);\n                 par_grp = lys_parent(par_grp));\n            if (par_grp) {\n                /* checking default value in a grouping finished with forward reference means we cannot check the value */\n                rc = EXIT_SUCCESS;\n            }\n        }\n        break;\n    case UNRES_CHOICE_DFLT:\n        expr = str_snode;\n        has_str = 1;\n        choic = item;\n\n        if (!choic->dflt) {\n            choic->dflt = resolve_choice_dflt(choic, expr);\n        }\n        if (choic->dflt) {\n            rc = lyp_check_mandatory_choice((struct lys_node *)choic);\n        } else {\n            rc = EXIT_FAILURE;\n        }\n        break;\n    case UNRES_LIST_KEYS:\n        rc = resolve_list_keys(item, ((struct lys_node_list *)item)->keys_str);\n        break;\n    case UNRES_LIST_UNIQ:\n        unique_info = (struct unres_list_uniq *)item;\n        rc = resolve_unique(unique_info->list, unique_info->expr, unique_info->trg_type);\n        break;\n    case UNRES_AUGMENT:\n        rc = resolve_augment(item, NULL, unres);\n        break;\n    case UNRES_XPATH:\n        node = (struct lys_node *)item;\n        rc = check_xpath(node, 1);\n        break;\n    case UNRES_MOD_IMPLEMENT:\n        rc = lys_make_implemented_r(mod, unres);\n        break;\n    case UNRES_EXT:\n        ext_data = (struct unres_ext *)str_snode;\n        extlist = &(*(struct lys_ext_instance ***)item)[ext_data->ext_index];\n        rc = resolve_extension(ext_data, extlist, unres);\n        if (!rc) {\n            /* success */\n            /* is there a callback to be done to finalize the extension? */\n            eplugin = extlist[0]->def->plugin;\n            if (eplugin) {\n                if (eplugin->check_result || (eplugin->flags & LYEXT_OPT_INHERIT)) {\n                    u = malloc(sizeof *u);\n                    LY_CHECK_ERR_RETURN(!u, LOGMEM(ctx), -1);\n                    (*u) = ext_data->ext_index;\n                    if (unres_schema_add_node(mod, unres, item, UNRES_EXT_FINALIZE, (struct lys_node *)u) == -1) {\n                        /* something really bad happend since the extension finalization is not actually\n                         * being resolved while adding into unres, so something more serious with the unres\n                         * list itself must happened */\n                        return -1;\n                    }\n                }\n            }\n        }\n        if (!rc || rc == -1) {\n            /* cleanup on success or fatal error */\n            if (ext_data->datatype == LYS_IN_YIN) {\n                /* YIN */\n                lyxml_free(ctx, ext_data->data.yin);\n            } else {\n                /* YANG */\n                yang_free_ext_data(ext_data->data.yang);\n            }\n            free(ext_data);\n        }\n        break;\n    case UNRES_EXT_FINALIZE:\n        u = (uint8_t *)str_snode;\n        ext = (*(struct lys_ext_instance ***)item)[*u];\n        free(u);\n\n        eplugin = ext->def->plugin;\n\n        /* inherit */\n        if ((eplugin->flags & LYEXT_OPT_INHERIT) && (ext->parent_type == LYEXT_PAR_NODE)) {\n            root = (struct lys_node *)ext->parent;\n            if (!(root->nodetype & (LYS_LEAF | LYS_LEAFLIST | LYS_ANYDATA))) {\n                LY_TREE_DFS_BEGIN(root->child, next, node) {\n                    /* first, check if the node already contain instance of the same extension,\n                     * in such a case we won't inherit. In case the node was actually defined as\n                     * augment data, we are supposed to check the same way also the augment node itself */\n                    if (lys_ext_instance_presence(ext->def, node->ext, node->ext_size) != -1) {\n                        goto inherit_dfs_sibling;\n                    } else if (node->parent != root && node->parent->nodetype == LYS_AUGMENT &&\n                            lys_ext_instance_presence(ext->def, node->parent->ext, node->parent->ext_size) != -1) {\n                        goto inherit_dfs_sibling;\n                    }\n\n                    if (eplugin->check_inherit) {\n                        /* we have a callback to check the inheritance, use it */\n                        switch ((rc = (*eplugin->check_inherit)(ext, node))) {\n                        case 0:\n                            /* yes - continue with the inheriting code */\n                            break;\n                        case 1:\n                            /* no - continue with the node's sibling */\n                            goto inherit_dfs_sibling;\n                        case 2:\n                            /* no, but continue with the children, just skip the inheriting code for this node */\n                            goto inherit_dfs_child;\n                        default:\n                            LOGERR(ctx, LY_EINT, \"Plugin's (%s:%s) check_inherit callback returns invalid value (%d),\",\n                                   ext->def->module->name, ext->def->name, rc);\n                        }\n                    }\n\n                    /* inherit the extension */\n                    extlist = realloc(node->ext, (node->ext_size + 1) * sizeof *node->ext);\n                    LY_CHECK_ERR_RETURN(!extlist, LOGMEM(ctx), -1);\n                    extlist[node->ext_size] = malloc(sizeof **extlist);\n                    LY_CHECK_ERR_RETURN(!extlist[node->ext_size], LOGMEM(ctx); node->ext = extlist, -1);\n                    memcpy(extlist[node->ext_size], ext, sizeof *ext);\n                    extlist[node->ext_size]->flags |= LYEXT_OPT_INHERIT;\n\n                    node->ext = extlist;\n                    node->ext_size++;\n\ninherit_dfs_child:\n                    /* modification of - select element for the next run - children first */\n                    if (node->nodetype & (LYS_LEAF | LYS_LEAFLIST | LYS_ANYDATA)) {\n                        next = NULL;\n                    } else {\n                        next = node->child;\n                    }\n                    if (!next) {\ninherit_dfs_sibling:\n                        /* no children, try siblings */\n                        next = node->next;\n                    }\n                    while (!next) {\n                        /* go to the parent */\n                        node = lys_parent(node);\n\n                        /* we are done if we are back in the root (the starter's parent */\n                        if (node == root) {\n                            break;\n                        }\n\n                        /* parent is already processed, go to its sibling */\n                        next = node->next;\n                    }\n                }\n            }\n        }\n\n        /* final check */\n        if (eplugin->check_result) {\n            if ((*eplugin->check_result)(ext)) {\n                LOGERR(ctx, LY_EPLUGIN, \"Resolving extension failed.\");\n                return -1;\n            }\n        }\n\n        rc = 0;\n        break;\n    default:\n        LOGINT(ctx);\n        break;\n    }\n\n    if (has_str && !rc) {\n        /* the string is no more needed in case of success.\n         * In case of forward reference, we will try to resolve the string later */\n        lydict_remove(ctx, str_snode);\n    }\n\n    return rc;\n}\n\n/* logs directly */\nstatic void\nprint_unres_schema_item_fail(void *item, enum UNRES_ITEM type, void *str_node)\n{\n    struct lyxml_elem *xml;\n    struct lyxml_attr *attr;\n    struct unres_iffeat_data *iff_data;\n    const char *name = NULL;\n    struct unres_ext *extinfo;\n\n    switch (type) {\n    case UNRES_IDENT:\n        LOGVRB(\"Resolving %s \\\"%s\\\" failed, it will be attempted later.\", \"identity\", (char *)str_node);\n        break;\n    case UNRES_TYPE_IDENTREF:\n        LOGVRB(\"Resolving %s \\\"%s\\\" failed, it will be attempted later.\", \"identityref\", (char *)str_node);\n        break;\n    case UNRES_TYPE_LEAFREF:\n        LOGVRB(\"Resolving %s \\\"%s\\\" failed, it will be attempted later.\", \"leafref\",\n               ((struct lys_type *)item)->info.lref.path);\n        break;\n    case UNRES_TYPE_DER_EXT:\n    case UNRES_TYPE_DER_TPDF:\n    case UNRES_TYPE_DER:\n        xml = (struct lyxml_elem *)((struct lys_type *)item)->der;\n        if (xml->flags & LY_YANG_STRUCTURE_FLAG) {\n            name = ((struct yang_type *)xml)->name;\n        } else {\n            LY_TREE_FOR(xml->attr, attr) {\n                if ((attr->type == LYXML_ATTR_STD) && !strcmp(attr->name, \"name\")) {\n                    name = attr->value;\n                    break;\n                }\n            }\n            assert(attr);\n        }\n        LOGVRB(\"Resolving %s \\\"%s\\\" failed, it will be attempted later.\", \"derived type\", name);\n        break;\n    case UNRES_IFFEAT:\n        iff_data = str_node;\n        LOGVRB(\"Resolving %s \\\"%s\\\" failed, it will be attempted later.\", \"if-feature\", iff_data->fname);\n        break;\n    case UNRES_FEATURE:\n        LOGVRB(\"There are unresolved if-features for \\\"%s\\\" feature circular dependency check, it will be attempted later\",\n               ((struct lys_feature *)item)->name);\n        break;\n    case UNRES_USES:\n        LOGVRB(\"Resolving %s \\\"%s\\\" failed, it will be attempted later.\", \"uses\", ((struct lys_node_uses *)item)->name);\n        break;\n    case UNRES_TYPEDEF_DFLT:\n    case UNRES_TYPE_DFLT:\n        if (*(char **)str_node) {\n            LOGVRB(\"Resolving %s \\\"%s\\\" failed, it will be attempted later.\", \"type default\", *(char **)str_node);\n        }   /* else no default value in the type itself, but we are checking some restrictions against\n             *  possible default value of some base type. The failure is caused by not resolved base type,\n             *  so it was already reported */\n        break;\n    case UNRES_CHOICE_DFLT:\n        LOGVRB(\"Resolving %s \\\"%s\\\" failed, it will be attempted later.\", \"choice default\", (char *)str_node);\n        break;\n    case UNRES_LIST_KEYS:\n        LOGVRB(\"Resolving %s \\\"%s\\\" failed, it will be attempted later.\", \"list keys\", (char *)str_node);\n        break;\n    case UNRES_LIST_UNIQ:\n        LOGVRB(\"Resolving %s \\\"%s\\\" failed, it will be attempted later.\", \"list unique\", (char *)str_node);\n        break;\n    case UNRES_AUGMENT:\n        LOGVRB(\"Resolving %s \\\"%s\\\" failed, it will be attempted later.\", \"augment target\",\n               ((struct lys_node_augment *)item)->target_name);\n        break;\n    case UNRES_XPATH:\n        LOGVRB(\"Resolving %s \\\"%s\\\" failed, it will be attempted later.\", \"XPath expressions of\",\n               ((struct lys_node *)item)->name);\n        break;\n    case UNRES_EXT:\n        extinfo = (struct unres_ext *)str_node;\n        name = extinfo->datatype == LYS_IN_YIN ? extinfo->data.yin->name : NULL; /* TODO YANG extension */\n        LOGVRB(\"Resolving extension \\\"%s\\\" failed, it will be attempted later.\", name);\n        break;\n    default:\n        LOGINT(NULL);\n        break;\n    }\n}\n\nstatic int\nresolve_unres_schema_types(struct unres_schema *unres, enum UNRES_ITEM types, struct ly_ctx *ctx, int forward_ref,\n                           int print_all_errors, uint32_t *resolved)\n{\n    uint32_t i, unres_count, res_count;\n    int ret = 0, rc;\n    struct ly_err_item *prev_eitem;\n    enum int_log_opts prev_ilo;\n    LY_ERR prev_ly_errno;\n\n    /* if there can be no forward references, every failure is final, so we can print it directly */\n    if (forward_ref) {\n        prev_ly_errno = ly_errno;\n        ly_ilo_change(ctx, ILO_STORE, &prev_ilo, &prev_eitem);\n    }\n\n    do {\n        unres_count = 0;\n        res_count = 0;\n\n        for (i = 0; i < unres->count; ++i) {\n            /* UNRES_TYPE_LEAFREF must be resolved (for storing leafref target pointers);\n             * if-features are resolved here to make sure that we will have all if-features for\n             * later check of feature circular dependency */\n            if (unres->type[i] & types) {\n                ++unres_count;\n                rc = resolve_unres_schema_item(unres->module[i], unres->item[i], unres->type[i], unres->str_snode[i], unres);\n                if (unres->type[i] == UNRES_EXT_FINALIZE) {\n                    /* to avoid double free */\n                    unres->type[i] = UNRES_RESOLVED;\n                }\n                if (!rc || (unres->type[i] == UNRES_XPATH)) {\n                    /* invalid XPath can never cause an error, only a warning */\n                    if (unres->type[i] == UNRES_LIST_UNIQ) {\n                        /* free the allocated structure */\n                        free(unres->item[i]);\n                    }\n\n                    unres->type[i] = UNRES_RESOLVED;\n                    ++(*resolved);\n                    ++res_count;\n                } else if ((rc == EXIT_FAILURE) && forward_ref) {\n                    /* forward reference, erase errors */\n                    ly_err_free_next(ctx, prev_eitem);\n                } else if (print_all_errors) {\n                    /* just so that we quit the loop */\n                    ++res_count;\n                    ret = -1;\n                } else {\n                    if (forward_ref) {\n                        ly_ilo_restore(ctx, prev_ilo, prev_eitem, 1);\n                    }\n                    return -1;\n                }\n            }\n        }\n    } while (res_count && (res_count < unres_count));\n\n    if (res_count < unres_count) {\n        assert(forward_ref);\n        /* just print the errors (but we must free the ones we have and get them again :-/ ) */\n        ly_ilo_restore(ctx, prev_ilo, prev_eitem, 0);\n\n        for (i = 0; i < unres->count; ++i) {\n            if (unres->type[i] & types) {\n                resolve_unres_schema_item(unres->module[i], unres->item[i], unres->type[i], unres->str_snode[i], unres);\n            }\n        }\n        return -1;\n    }\n\n    if (forward_ref) {\n        /* restore log */\n        ly_ilo_restore(ctx, prev_ilo, prev_eitem, 0);\n        ly_errno = prev_ly_errno;\n    }\n\n    return ret;\n}\n\n/**\n * @brief Resolve every unres schema item in the structure. Logs directly.\n *\n * @param[in] mod Main module.\n * @param[in] unres Unres schema structure to use.\n *\n * @return EXIT_SUCCESS on success, -1 on error.\n */\nint\nresolve_unres_schema(struct lys_module *mod, struct unres_schema *unres)\n{\n    uint32_t resolved = 0;\n\n    assert(unres);\n\n    LOGVRB(\"Resolving \\\"%s\\\" unresolved schema nodes and their constraints...\", mod->name);\n\n    /* UNRES_TYPE_LEAFREF must be resolved (for storing leafref target pointers);\n     * if-features are resolved here to make sure that we will have all if-features for\n     * later check of feature circular dependency */\n    if (resolve_unres_schema_types(unres, UNRES_USES | UNRES_IFFEAT | UNRES_TYPE_DER | UNRES_TYPE_DER_TPDF | UNRES_TYPE_DER_TPDF\n                                   | UNRES_TYPE_LEAFREF | UNRES_MOD_IMPLEMENT | UNRES_AUGMENT | UNRES_CHOICE_DFLT | UNRES_IDENT,\n                                   mod->ctx, 1, 0, &resolved)) {\n        return -1;\n    }\n\n    /* another batch of resolved items */\n    if (resolve_unres_schema_types(unres, UNRES_TYPE_IDENTREF | UNRES_FEATURE | UNRES_TYPEDEF_DFLT | UNRES_TYPE_DFLT\n                                   | UNRES_LIST_KEYS | UNRES_LIST_UNIQ | UNRES_EXT, mod->ctx, 1, 0, &resolved)) {\n        return -1;\n    }\n\n    /* print xpath warnings and finalize extensions, keep it last to provide the complete schema tree information to the plugin's checkers */\n    if (resolve_unres_schema_types(unres, UNRES_XPATH | UNRES_EXT_FINALIZE, mod->ctx, 0, 1, &resolved)) {\n        return -1;\n    }\n\n    LOGVRB(\"All \\\"%s\\\" schema nodes and constraints resolved.\", mod->name);\n    unres->count = 0;\n    return EXIT_SUCCESS;\n}\n\n/**\n * @brief Try to resolve an unres schema item with a string argument. Logs indirectly.\n *\n * @param[in] mod Main module.\n * @param[in] unres Unres schema structure to use.\n * @param[in] item Item to resolve. Type determined by \\p type.\n * @param[in] type Type of the unresolved item.\n * @param[in] str String argument.\n *\n * @return EXIT_SUCCESS on success, EXIT_FAILURE on storing the item in unres, -1 on error.\n */\nint\nunres_schema_add_str(struct lys_module *mod, struct unres_schema *unres, void *item, enum UNRES_ITEM type,\n                     const char *str)\n{\n    int rc;\n    const char *dictstr;\n\n    dictstr = lydict_insert(mod->ctx, str, 0);\n    rc = unres_schema_add_node(mod, unres, item, type, (struct lys_node *)dictstr);\n\n    if (rc < 0) {\n        lydict_remove(mod->ctx, dictstr);\n    }\n    return rc;\n}\n\n/**\n * @brief Try to resolve an unres schema item with a schema node argument. Logs indirectly.\n *\n * @param[in] mod Main module.\n * @param[in] unres Unres schema structure to use.\n * @param[in] item Item to resolve. Type determined by \\p type.\n * @param[in] type Type of the unresolved item. UNRES_TYPE_DER is handled specially!\n * @param[in] snode Schema node argument.\n *\n * @return EXIT_SUCCESS on success, EXIT_FAILURE on storing the item in unres, -1 on error.\n */\nint\nunres_schema_add_node(struct lys_module *mod, struct unres_schema *unres, void *item, enum UNRES_ITEM type,\n                      struct lys_node *snode)\n{\n    int rc;\n    uint32_t u;\n    enum int_log_opts prev_ilo;\n    struct ly_err_item *prev_eitem;\n    LY_ERR prev_ly_errno;\n    struct lyxml_elem *yin;\n    struct ly_ctx *ctx = mod->ctx;\n\n    assert(unres && (item || (type == UNRES_MOD_IMPLEMENT)) && ((type != UNRES_LEAFREF) && (type != UNRES_INSTID)\n           && (type != UNRES_WHEN) && (type != UNRES_MUST)));\n\n    /* check for duplicities in unres */\n    for (u = 0; u < unres->count; u++) {\n        if (unres->type[u] == type && unres->item[u] == item &&\n                unres->str_snode[u] == snode && unres->module[u] == mod) {\n            /* duplication can happen when the node contains multiple statements of the same type to check,\n             * this can happen for example when refinement is being applied, so we just postpone the processing\n             * and do not duplicate the information */\n            return EXIT_FAILURE;\n        }\n    }\n\n    if ((type == UNRES_EXT_FINALIZE) || (type == UNRES_XPATH) || (type == UNRES_MOD_IMPLEMENT)) {\n        /* extension finalization is not even tried when adding the item into the inres list,\n         * xpath is not tried because it would hide some potential warnings,\n         * implementing module must be deferred because some other nodes can be added that will need to be traversed\n         * and their targets made implemented */\n        rc = EXIT_FAILURE;\n    } else {\n        prev_ly_errno = ly_errno;\n        ly_ilo_change(ctx, ILO_STORE, &prev_ilo, &prev_eitem);\n\n        rc = resolve_unres_schema_item(mod, item, type, snode, unres);\n        if (rc != EXIT_FAILURE) {\n            ly_ilo_restore(ctx, prev_ilo, prev_eitem, rc == -1 ? 1 : 0);\n            if (rc != -1) {\n                ly_errno = prev_ly_errno;\n            }\n\n            if (type == UNRES_LIST_UNIQ) {\n                /* free the allocated structure */\n                free(item);\n            } else if (rc == -1 && type == UNRES_IFFEAT) {\n                /* free the allocated resources */\n                free(*((char **)item));\n            }\n            return rc;\n        } else {\n            /* erase info about validation errors */\n            ly_ilo_restore(ctx, prev_ilo, prev_eitem, 0);\n            ly_errno = prev_ly_errno;\n        }\n\n        print_unres_schema_item_fail(item, type, snode);\n\n        /* HACK unlinking is performed here so that we do not do any (NS) copying in vain */\n        if (type == UNRES_TYPE_DER || type == UNRES_TYPE_DER_TPDF) {\n            yin = (struct lyxml_elem *)((struct lys_type *)item)->der;\n            if (!(yin->flags & LY_YANG_STRUCTURE_FLAG)) {\n                lyxml_unlink_elem(mod->ctx, yin, 1);\n                ((struct lys_type *)item)->der = (struct lys_tpdf *)yin;\n            }\n        }\n    }\n\n    unres->count++;\n    unres->item = ly_realloc(unres->item, unres->count*sizeof *unres->item);\n    LY_CHECK_ERR_RETURN(!unres->item, LOGMEM(ctx), -1);\n    unres->item[unres->count-1] = item;\n    unres->type = ly_realloc(unres->type, unres->count*sizeof *unres->type);\n    LY_CHECK_ERR_RETURN(!unres->type, LOGMEM(ctx), -1);\n    unres->type[unres->count-1] = type;\n    unres->str_snode = ly_realloc(unres->str_snode, unres->count*sizeof *unres->str_snode);\n    LY_CHECK_ERR_RETURN(!unres->str_snode, LOGMEM(ctx), -1);\n    unres->str_snode[unres->count-1] = snode;\n    unres->module = ly_realloc(unres->module, unres->count*sizeof *unres->module);\n    LY_CHECK_ERR_RETURN(!unres->module, LOGMEM(ctx), -1);\n    unres->module[unres->count-1] = mod;\n\n    return rc;\n}\n\n/**\n * @brief Duplicate an unres schema item. Logs indirectly.\n *\n * @param[in] mod Main module.\n * @param[in] unres Unres schema structure to use.\n * @param[in] item Old item to be resolved.\n * @param[in] type Type of the old unresolved item.\n * @param[in] new_item New item to use in the duplicate.\n *\n * @return EXIT_SUCCESS on success, EXIT_FAILURE if item is not in unres, -1 on error.\n */\nint\nunres_schema_dup(struct lys_module *mod, struct unres_schema *unres, void *item, enum UNRES_ITEM type, void *new_item)\n{\n    int i;\n    struct unres_list_uniq aux_uniq;\n    struct unres_iffeat_data *iff_data;\n\n    assert(item && new_item && ((type != UNRES_LEAFREF) && (type != UNRES_INSTID) && (type != UNRES_WHEN)));\n\n    /* hack for UNRES_LIST_UNIQ, which stores multiple items behind its item */\n    if (type == UNRES_LIST_UNIQ) {\n        aux_uniq.list = item;\n        aux_uniq.expr = ((struct unres_list_uniq *)new_item)->expr;\n        item = &aux_uniq;\n    }\n    i = unres_schema_find(unres, -1, item, type);\n\n    if (i == -1) {\n        if (type == UNRES_LIST_UNIQ) {\n            free(new_item);\n        }\n        return EXIT_FAILURE;\n    }\n\n    if ((type == UNRES_TYPE_LEAFREF) || (type == UNRES_USES) || (type == UNRES_TYPE_DFLT) ||\n            (type == UNRES_FEATURE) || (type == UNRES_LIST_UNIQ)) {\n        if (unres_schema_add_node(mod, unres, new_item, type, unres->str_snode[i]) == -1) {\n            LOGINT(mod->ctx);\n            return -1;\n        }\n    } else if (type == UNRES_IFFEAT) {\n        /* duplicate unres_iffeature_data */\n        iff_data = malloc(sizeof *iff_data);\n        LY_CHECK_ERR_RETURN(!iff_data, LOGMEM(mod->ctx), -1);\n        iff_data->fname = lydict_insert(mod->ctx, ((struct unres_iffeat_data *)unres->str_snode[i])->fname, 0);\n        iff_data->node = ((struct unres_iffeat_data *)unres->str_snode[i])->node;\n        if (unres_schema_add_node(mod, unres, new_item, type, (struct lys_node *)iff_data) == -1) {\n            LOGINT(mod->ctx);\n            return -1;\n        }\n    } else {\n        if (unres_schema_add_str(mod, unres, new_item, type, unres->str_snode[i]) == -1) {\n            LOGINT(mod->ctx);\n            return -1;\n        }\n    }\n\n    return EXIT_SUCCESS;\n}\n\n/* does not log */\nint\nunres_schema_find(struct unres_schema *unres, int start_on_backwards, void *item, enum UNRES_ITEM type)\n{\n    int i;\n    struct unres_list_uniq *aux_uniq1, *aux_uniq2;\n\n    if (!unres->count) {\n        return -1;\n    }\n\n    if (start_on_backwards >= 0) {\n        i = start_on_backwards;\n    } else {\n        i = unres->count - 1;\n    }\n    for (; i > -1; i--) {\n        if (unres->type[i] != type) {\n            continue;\n        }\n        if (type != UNRES_LIST_UNIQ) {\n            if (unres->item[i] == item) {\n                break;\n            }\n        } else {\n            aux_uniq1 = (struct unres_list_uniq *)unres->item[i];\n            aux_uniq2 = (struct unres_list_uniq *)item;\n            if ((aux_uniq1->list == aux_uniq2->list) && ly_strequal(aux_uniq1->expr, aux_uniq2->expr, 0)) {\n                break;\n            }\n        }\n    }\n\n    return i;\n}\n\nstatic void\nunres_schema_free_item(struct ly_ctx *ctx, struct unres_schema *unres, uint32_t i)\n{\n    struct lyxml_elem *yin;\n    struct yang_type *yang;\n    struct unres_iffeat_data *iff_data;\n\n    switch (unres->type[i]) {\n    case UNRES_TYPE_DER_TPDF:\n    case UNRES_TYPE_DER:\n        yin = (struct lyxml_elem *)((struct lys_type *)unres->item[i])->der;\n        if (yin->flags & LY_YANG_STRUCTURE_FLAG) {\n            yang =(struct yang_type *)yin;\n            ((struct lys_type *)unres->item[i])->base = yang->base;\n            lydict_remove(ctx, yang->name);\n            free(yang);\n            if (((struct lys_type *)unres->item[i])->base == LY_TYPE_UNION) {\n                yang_free_type_union(ctx, (struct lys_type *)unres->item[i]);\n            }\n        } else {\n            lyxml_free(ctx, yin);\n        }\n        break;\n    case UNRES_IFFEAT:\n        iff_data = (struct unres_iffeat_data *)unres->str_snode[i];\n        lydict_remove(ctx, iff_data->fname);\n        free(unres->str_snode[i]);\n        break;\n    case UNRES_IDENT:\n    case UNRES_TYPE_IDENTREF:\n    case UNRES_CHOICE_DFLT:\n    case UNRES_LIST_KEYS:\n        lydict_remove(ctx, (const char *)unres->str_snode[i]);\n        break;\n    case UNRES_LIST_UNIQ:\n        free(unres->item[i]);\n        break;\n    case UNRES_EXT:\n        free(unres->str_snode[i]);\n        break;\n    case UNRES_EXT_FINALIZE:\n        free(unres->str_snode[i]);\n    default:\n        break;\n    }\n    unres->type[i] = UNRES_RESOLVED;\n}\n\nvoid\nunres_schema_free(struct lys_module *module, struct unres_schema **unres, int all)\n{\n    uint32_t i;\n    unsigned int unresolved = 0;\n\n    if (!unres || !(*unres)) {\n        return;\n    }\n\n    assert(module || ((*unres)->count == 0));\n\n    for (i = 0; i < (*unres)->count; ++i) {\n        if (!all && ((*unres)->module[i] != module)) {\n            if ((*unres)->type[i] != UNRES_RESOLVED) {\n                unresolved++;\n            }\n            continue;\n        }\n\n        /* free heap memory for the specific item */\n        unres_schema_free_item(module->ctx, *unres, i);\n    }\n\n    /* free it all */\n    if (!module || all || (!unresolved && !module->type)) {\n        free((*unres)->item);\n        free((*unres)->type);\n        free((*unres)->str_snode);\n        free((*unres)->module);\n        free((*unres));\n        (*unres) = NULL;\n    }\n}\n\n/* check whether instance-identifier points outside its data subtree (for operation it is any node\n * outside the operation subtree, otherwise it is a node from a foreign model) */\nstatic int\ncheck_instid_ext_dep(const struct lys_node *sleaf, const char *json_instid)\n{\n    const struct lys_node *op_node, *first_node;\n    enum int_log_opts prev_ilo;\n    char *buf, *tmp;\n\n    if (!json_instid || !json_instid[0]) {\n        /* no/empty value */\n        return 0;\n    }\n\n    for (op_node = lys_parent(sleaf);\n         op_node && !(op_node->nodetype & (LYS_NOTIF | LYS_RPC | LYS_ACTION));\n         op_node = lys_parent(op_node));\n\n    if (op_node && lys_parent(op_node)) {\n        /* nested operation - any absolute path is external */\n        return 1;\n    }\n\n    /* get the first node from the instid */\n    tmp = strchr(json_instid + 1, '/');\n    buf = strndup(json_instid, tmp ? (size_t)(tmp - json_instid) : strlen(json_instid));\n    if (!buf) {\n        /* so that we do not have to bother with logging, say it is not external */\n        return 0;\n    }\n\n    /* find the first schema node, do not log */\n    ly_ilo_change(NULL, ILO_IGNORE, &prev_ilo, NULL);\n    first_node = ly_ctx_get_node(NULL, sleaf, buf, 0);\n    ly_ilo_restore(NULL, prev_ilo, NULL, 0);\n\n    free(buf);\n    if (!first_node) {\n        /* unknown path, say it is external */\n        return 1;\n    }\n\n    /* based on the first schema node in the path we can decide whether it points to an external tree or not */\n\n    if (op_node) {\n        if (op_node != first_node) {\n            /* it is a top-level operation, so we're good if it points somewhere inside it */\n            return 1;\n        }\n    } else {\n        if (lys_node_module(sleaf) != lys_node_module(first_node)) {\n            /* modules differ */\n            return 1;\n        }\n    }\n\n    return 0;\n}\n\n/**\n * @brief Resolve instance-identifier in JSON data format. Logs directly.\n *\n * @param[in] data Data node where the path is used\n * @param[in] path Instance-identifier node value.\n * @param[in,out] ret Resolved instance or NULL.\n *\n * @return 0 on success (even if unresolved and \\p ret is NULL), -1 on error.\n */\nstatic int\nresolve_instid(struct lyd_node *data, const char *path, int req_inst, struct lyd_node **ret)\n{\n    int i = 0, j, parsed, cur_idx;\n    const struct lys_module *mod, *prev_mod = NULL;\n    struct ly_ctx *ctx = data->schema->module->ctx;\n    struct lyd_node *root, *node;\n    const char *model = NULL, *name;\n    char *str;\n    int mod_len, name_len, has_predicate;\n    struct unres_data node_match;\n\n    memset(&node_match, 0, sizeof node_match);\n    *ret = NULL;\n\n    /* we need root to resolve absolute path */\n    for (root = data; root->parent; root = root->parent);\n    /* we're still parsing it and the pointer is not correct yet */\n    if (root->prev) {\n        for (; root->prev->next; root = root->prev);\n    }\n\n    /* search for the instance node */\n    while (path[i]) {\n        j = parse_instance_identifier(&path[i], &model, &mod_len, &name, &name_len, &has_predicate);\n        if (j <= 0) {\n            LOGVAL(ctx, LYE_INCHAR, LY_VLOG_LYD, data, path[i-j], &path[i-j]);\n            goto error;\n        }\n        i += j;\n\n        if (model) {\n            str = strndup(model, mod_len);\n            if (!str) {\n                LOGMEM(ctx);\n                goto error;\n            }\n            mod = ly_ctx_get_module(ctx, str, NULL, 1);\n            if (ctx->data_clb) {\n                if (!mod) {\n                    mod = ctx->data_clb(ctx, str, NULL, 0, ctx->data_clb_data);\n                } else if (!mod->implemented) {\n                    mod = ctx->data_clb(ctx, mod->name, mod->ns, LY_MODCLB_NOT_IMPLEMENTED, ctx->data_clb_data);\n                }\n            }\n            free(str);\n\n            if (!mod || !mod->implemented || mod->disabled) {\n                break;\n            }\n        } else if (!prev_mod) {\n            /* first iteration and we are missing module name */\n            LOGVAL(ctx, LYE_INELEM_LEN, LY_VLOG_LYD, data, name_len, name);\n            LOGVAL(ctx, LYE_SPEC, LY_VLOG_PREV, NULL, \"Instance-identifier is missing prefix in the first node.\");\n            goto error;\n        } else {\n            mod = prev_mod;\n        }\n\n        if (resolve_data(mod, name, name_len, root, &node_match)) {\n            /* no instance exists */\n            break;\n        }\n\n        if (has_predicate) {\n            /* we have predicate, so the current results must be list or leaf-list */\n            parsed = j = 0;\n            /* index of the current node (for lists with position predicates) */\n            cur_idx = 1;\n            while (j < (signed)node_match.count) {\n                node = node_match.node[j];\n                parsed = resolve_instid_predicate(mod, &path[i], &node, cur_idx);\n                if (parsed < 1) {\n                    LOGVAL(ctx, LYE_INPRED, LY_VLOG_LYD, data, &path[i - parsed]);\n                    goto error;\n                }\n\n                if (!node) {\n                    /* current node does not satisfy the predicate */\n                    unres_data_del(&node_match, j);\n                } else {\n                    ++j;\n                }\n                ++cur_idx;\n            }\n\n            i += parsed;\n        } else if (node_match.count) {\n            /* check that we are not addressing lists */\n            for (j = 0; (unsigned)j < node_match.count; ++j) {\n                if (node_match.node[j]->schema->nodetype == LYS_LIST) {\n                    unres_data_del(&node_match, j--);\n                }\n            }\n            if (!node_match.count) {\n                LOGVAL(ctx, LYE_SPEC, LY_VLOG_LYD, data, \"Instance identifier is missing list keys.\");\n            }\n        }\n\n        prev_mod = mod;\n    }\n\n    if (!node_match.count) {\n        /* no instance exists */\n        if (req_inst > -1) {\n            LOGVAL(ctx, LYE_NOREQINS, LY_VLOG_LYD, data, path);\n            return EXIT_FAILURE;\n        }\n        LOGVRB(\"There is no instance of \\\"%s\\\", but it is not required.\", path);\n        return EXIT_SUCCESS;\n    } else if (node_match.count > 1) {\n        /* instance identifier must resolve to a single node */\n        LOGVAL(ctx, LYE_TOOMANY, LY_VLOG_LYD, data, path, \"data tree\");\n        goto error;\n    } else {\n        /* we have required result, remember it and cleanup */\n        *ret = node_match.node[0];\n        free(node_match.node);\n        return EXIT_SUCCESS;\n    }\n\nerror:\n    /* cleanup */\n    free(node_match.node);\n    return -1;\n}\n\nstatic int\nresolve_leafref(struct lyd_node_leaf_list *leaf, const char *path, int req_inst, struct lyd_node **ret)\n{\n    struct lyxp_set xp_set;\n    uint32_t i;\n\n    memset(&xp_set, 0, sizeof xp_set);\n    *ret = NULL;\n\n    /* syntax was already checked, so just evaluate the path using standard XPath */\n    if (lyxp_eval(path, (struct lyd_node *)leaf, LYXP_NODE_ELEM, lyd_node_module((struct lyd_node *)leaf), &xp_set, 0) != EXIT_SUCCESS) {\n        return -1;\n    }\n\n    if (xp_set.type == LYXP_SET_NODE_SET) {\n        for (i = 0; i < xp_set.used; ++i) {\n            if ((xp_set.val.nodes[i].type != LYXP_NODE_ELEM) || !(xp_set.val.nodes[i].node->schema->nodetype & (LYS_LEAF | LYS_LEAFLIST))) {\n                continue;\n            }\n\n            /* not that the value is already in canonical form since the parsers does the conversion,\n             * so we can simply compare just the values */\n            if (ly_strequal(leaf->value_str, ((struct lyd_node_leaf_list *)xp_set.val.nodes[i].node)->value_str, 1)) {\n                /* we have the match */\n                *ret = xp_set.val.nodes[i].node;\n                break;\n            }\n        }\n    }\n\n    lyxp_set_cast(&xp_set, LYXP_SET_EMPTY, (struct lyd_node *)leaf, NULL, 0);\n\n    if (!*ret) {\n        /* reference not found */\n        if (req_inst > -1) {\n            LOGVAL(leaf->schema->module->ctx, LYE_NOLEAFREF, LY_VLOG_LYD, leaf, path, leaf->value_str);\n            return EXIT_FAILURE;\n        } else {\n            LOGVRB(\"There is no leafref \\\"%s\\\" with the value \\\"%s\\\", but it is not required.\", path, leaf->value_str);\n        }\n    }\n\n    return EXIT_SUCCESS;\n}\n\n/* ignore fail because we are parsing edit-config, get, or get-config - but only if the union includes leafref or instid */\nint\nresolve_union(struct lyd_node_leaf_list *leaf, struct lys_type *type, int store, int ignore_fail,\n              struct lys_type **resolved_type)\n{\n    struct ly_ctx *ctx = leaf->schema->module->ctx;\n    struct lys_type *t;\n    struct lyd_node *ret;\n    enum int_log_opts prev_ilo;\n    int found, success = 0, ext_dep, req_inst;\n    const char *json_val = NULL;\n\n    assert(type->base == LY_TYPE_UNION);\n\n    if ((leaf->value_type == LY_TYPE_UNION) || ((leaf->value_type == LY_TYPE_INST) && (leaf->value_flags & LY_VALUE_UNRES))) {\n        /* either NULL or instid previously converted to JSON */\n        json_val = lydict_insert(ctx, leaf->value.string, 0);\n    }\n\n    if (store) {\n        lyd_free_value(leaf->value, leaf->value_type, leaf->value_flags, &((struct lys_node_leaf *)leaf->schema)->type,\n                       leaf->value_str, NULL, NULL, NULL);\n        memset(&leaf->value, 0, sizeof leaf->value);\n    }\n\n    /* turn logging off, we are going to try to validate the value with all the types in order */\n    ly_ilo_change(NULL, ILO_IGNORE, &prev_ilo, 0);\n\n    t = NULL;\n    found = 0;\n    while ((t = lyp_get_next_union_type(type, t, &found))) {\n        found = 0;\n\n        switch (t->base) {\n        case LY_TYPE_LEAFREF:\n            if ((ignore_fail == 1) || ((leaf->schema->flags & LYS_LEAFREF_DEP) && (ignore_fail == 2))) {\n                req_inst = -1;\n            } else {\n                req_inst = t->info.lref.req;\n            }\n\n            if (!resolve_leafref(leaf, t->info.lref.path, req_inst, &ret)) {\n                if (store) {\n                    if (ret && !(leaf->schema->flags & LYS_LEAFREF_DEP)) {\n                        /* valid resolved */\n                        leaf->value.leafref = ret;\n                        leaf->value_type = LY_TYPE_LEAFREF;\n                    } else {\n                        /* valid unresolved */\n                        ly_ilo_restore(NULL, prev_ilo, NULL, 0);\n                        if (!lyp_parse_value(t, &leaf->value_str, NULL, leaf, NULL, NULL, 1, 0, 0)) {\n                            return -1;\n                        }\n                        ly_ilo_change(NULL, ILO_IGNORE, &prev_ilo, NULL);\n                    }\n                }\n\n                success = 1;\n            }\n            break;\n        case LY_TYPE_INST:\n            ext_dep = check_instid_ext_dep(leaf->schema, (json_val ? json_val : leaf->value_str));\n            if ((ignore_fail == 1) || (ext_dep && (ignore_fail == 2))) {\n                req_inst = -1;\n            } else {\n                req_inst = t->info.inst.req;\n            }\n\n            if (!resolve_instid((struct lyd_node *)leaf, (json_val ? json_val : leaf->value_str), req_inst, &ret)) {\n                if (store) {\n                    if (ret && !ext_dep) {\n                        /* valid resolved */\n                        leaf->value.instance = ret;\n                        leaf->value_type = LY_TYPE_INST;\n\n                        if (json_val) {\n                            lydict_remove(leaf->schema->module->ctx, leaf->value_str);\n                            leaf->value_str = json_val;\n                            json_val = NULL;\n                        }\n                    } else {\n                        /* valid unresolved */\n                        if (json_val) {\n                            /* put the JSON val back */\n                            leaf->value.string = json_val;\n                            json_val = NULL;\n                        } else {\n                            leaf->value.instance = NULL;\n                        }\n                        leaf->value_type = LY_TYPE_INST;\n                        leaf->value_flags |= LY_VALUE_UNRES;\n                    }\n                }\n\n                success = 1;\n            }\n            break;\n        default:\n            if (lyp_parse_value(t, &leaf->value_str, NULL, leaf, NULL, NULL, store, 0, 0)) {\n                success = 1;\n            }\n            break;\n        }\n\n        if (success) {\n            break;\n        }\n\n        /* erase possible present and invalid value data */\n        if (store) {\n            lyd_free_value(leaf->value, leaf->value_type, leaf->value_flags, t, leaf->value_str, NULL, NULL, NULL);\n            memset(&leaf->value, 0, sizeof leaf->value);\n        }\n    }\n\n    /* turn logging back on */\n    ly_ilo_restore(NULL, prev_ilo, NULL, 0);\n\n    if (json_val) {\n        if (!success) {\n            /* put the value back for now */\n            assert(leaf->value_type == LY_TYPE_UNION);\n            leaf->value.string = json_val;\n        } else {\n            /* value was ultimately useless, but we could not have known */\n            lydict_remove(leaf->schema->module->ctx, json_val);\n        }\n    }\n\n    if (success) {\n        if (resolved_type) {\n            *resolved_type = t;\n        }\n    } else if (!ignore_fail || !type->info.uni.has_ptr_type) {\n        /* not found and it is required */\n        LOGVAL(ctx, LYE_INVAL, LY_VLOG_LYD, leaf, leaf->value_str ? leaf->value_str : \"\", leaf->schema->name);\n        return EXIT_FAILURE;\n    }\n\n    return EXIT_SUCCESS;\n\n}\n\n/**\n * @brief Resolve a single unres data item. Logs directly.\n *\n * @param[in] node Data node to resolve.\n * @param[in] type Type of the unresolved item.\n * @param[in] ignore_fail 0 - no, 1 - yes, 2 - yes, but only for external dependencies.\n *\n * @return EXIT_SUCCESS on success, EXIT_FAILURE on forward reference, -1 on error.\n */\nint\nresolve_unres_data_item(struct lyd_node *node, enum UNRES_ITEM type, int ignore_fail, struct lys_when **failed_when)\n{\n    int rc, req_inst, ext_dep;\n    struct lyd_node_leaf_list *leaf;\n    struct lyd_node *ret;\n    struct lys_node_leaf *sleaf;\n\n    leaf = (struct lyd_node_leaf_list *)node;\n    sleaf = (struct lys_node_leaf *)leaf->schema;\n\n    switch (type) {\n    case UNRES_LEAFREF:\n        assert(sleaf->type.base == LY_TYPE_LEAFREF);\n        assert(leaf->validity & LYD_VAL_LEAFREF);\n        if ((ignore_fail == 1) || ((leaf->schema->flags & LYS_LEAFREF_DEP) && (ignore_fail == 2))) {\n            req_inst = -1;\n        } else {\n            req_inst = sleaf->type.info.lref.req;\n        }\n        rc = resolve_leafref(leaf, sleaf->type.info.lref.path, req_inst, &ret);\n        if (!rc) {\n            if (ret && !(leaf->schema->flags & LYS_LEAFREF_DEP)) {\n                /* valid resolved */\n                if (leaf->value_type == LY_TYPE_BITS) {\n                    free(leaf->value.bit);\n                }\n                leaf->value.leafref = ret;\n                leaf->value_type = LY_TYPE_LEAFREF;\n                leaf->value_flags &= ~LY_VALUE_UNRES;\n            } else {\n                /* valid unresolved */\n                if (!(leaf->value_flags & LY_VALUE_UNRES)) {\n                    if (!lyp_parse_value(&sleaf->type, &leaf->value_str, NULL, leaf, NULL, NULL, 1, 0, 0)) {\n                        return -1;\n                    }\n                }\n            }\n            leaf->validity &= ~LYD_VAL_LEAFREF;\n        } else {\n            return rc;\n        }\n        break;\n\n    case UNRES_INSTID:\n        assert(sleaf->type.base == LY_TYPE_INST);\n        ext_dep = check_instid_ext_dep(leaf->schema, leaf->value_str);\n        if (ext_dep == -1) {\n            return -1;\n        }\n\n        if ((ignore_fail == 1) || (ext_dep && (ignore_fail == 2))) {\n            req_inst = -1;\n        } else {\n            req_inst = sleaf->type.info.inst.req;\n        }\n        rc = resolve_instid(node, leaf->value_str, req_inst, &ret);\n        if (!rc) {\n            if (ret && !ext_dep) {\n                /* valid resolved */\n                leaf->value.instance = ret;\n                leaf->value_type = LY_TYPE_INST;\n                leaf->value_flags &= ~LY_VALUE_UNRES;\n            } else {\n                /* valid unresolved */\n                leaf->value.instance = NULL;\n                leaf->value_type = LY_TYPE_INST;\n                leaf->value_flags |= LY_VALUE_UNRES;\n            }\n        } else {\n            return rc;\n        }\n        break;\n\n    case UNRES_UNION:\n        assert(sleaf->type.base == LY_TYPE_UNION);\n        return resolve_union(leaf, &sleaf->type, 1, ignore_fail, NULL);\n\n    case UNRES_WHEN:\n        if ((rc = resolve_when(node, ignore_fail, failed_when))) {\n            return rc;\n        }\n        break;\n\n    case UNRES_MUST:\n        if ((rc = resolve_must(node, 0, ignore_fail))) {\n            return rc;\n        }\n        break;\n\n    case UNRES_MUST_INOUT:\n        if ((rc = resolve_must(node, 1, ignore_fail))) {\n            return rc;\n        }\n        break;\n\n    case UNRES_UNIQ_LEAVES:\n        if (lyv_data_unique(node)) {\n            return -1;\n        }\n        break;\n\n    default:\n        LOGINT(NULL);\n        return -1;\n    }\n\n    return EXIT_SUCCESS;\n}\n\n/**\n * @brief add data unres item\n *\n * @param[in] unres Unres data structure to use.\n * @param[in] node Data node to use.\n *\n * @return 0 on success, -1 on error.\n */\nint\nunres_data_add(struct unres_data *unres, struct lyd_node *node, enum UNRES_ITEM type)\n{\n    assert(unres && node);\n    assert((type == UNRES_LEAFREF) || (type == UNRES_INSTID) || (type == UNRES_WHEN) || (type == UNRES_MUST)\n           || (type == UNRES_MUST_INOUT) || (type == UNRES_UNION) || (type == UNRES_UNIQ_LEAVES));\n\n    unres->count++;\n    unres->node = ly_realloc(unres->node, unres->count * sizeof *unres->node);\n    LY_CHECK_ERR_RETURN(!unres->node, LOGMEM(NULL), -1);\n    unres->node[unres->count - 1] = node;\n    unres->type = ly_realloc(unres->type, unres->count * sizeof *unres->type);\n    LY_CHECK_ERR_RETURN(!unres->type, LOGMEM(NULL), -1);\n    unres->type[unres->count - 1] = type;\n\n    return 0;\n}\n\nstatic void\nresolve_unres_data_autodel_diff(struct unres_data *unres, uint32_t unres_i)\n{\n    struct lyd_node *next, *child, *parent;\n    uint32_t i;\n\n    for (i = 0; i < unres->diff_idx; ++i) {\n        if (unres->diff->type[i] == LYD_DIFF_DELETED) {\n            /* only leaf(-list) default could be removed and there is nothing to be checked in that case */\n            continue;\n        }\n\n        if (unres->diff->second[i] == unres->node[unres_i]) {\n            /* 1) default value was supposed to be created, but is disabled by when\n             * -> remove it from diff altogether\n             */\n            unres_data_diff_rem(unres, i);\n            /* if diff type is CREATED, the value was just a pointer, it can be freed normally (unlike in 4) */\n            return;\n        } else {\n            parent = unres->diff->second[i]->parent;\n            while (parent && (parent != unres->node[unres_i])) {\n                parent = parent->parent;\n            }\n            if (parent) {\n                /* 2) default value was supposed to be created but is disabled by when in some parent\n                 * -> remove this default subtree and add the rest into diff as deleted instead in 4)\n                 */\n                unres_data_diff_rem(unres, i);\n                break;\n            }\n\n            LY_TREE_DFS_BEGIN(unres->diff->second[i]->parent, next, child) {\n                if (child == unres->node[unres_i]) {\n                    /* 3) some default child of a default value was supposed to be created but has false when\n                     * -> the subtree will be freed later and automatically disconnected from the diff parent node\n                     */\n                    return;\n                }\n\n                LY_TREE_DFS_END(unres->diff->second[i]->parent, next, child);\n            }\n        }\n    }\n\n    /* 4) it does not overlap with created default values in any way\n     * -> just add it into diff as deleted\n     */\n    unres_data_diff_new(unres, unres->node[unres_i], unres->node[unres_i]->parent, 0);\n    lyd_unlink(unres->node[unres_i]);\n\n    /* should not be freed anymore */\n    unres->node[unres_i] = NULL;\n}\n\n/**\n * @brief Resolve every unres data item in the structure. Logs directly.\n *\n * If options include #LYD_OPT_TRUSTED, the data are considered trusted (must conditions are not expected,\n * unresolved leafrefs/instids are accepted, when conditions are normally resolved because at least some implicit\n * non-presence containers may need to be deleted).\n *\n * If options includes #LYD_OPT_WHENAUTODEL, the non-default nodes with false when conditions are auto-deleted.\n *\n * @param[in] ctx Context used.\n * @param[in] unres Unres data structure to use.\n * @param[in,out] root Root node of the data tree, can be changed due to autodeletion.\n * @param[in] options Data options as described above.\n *\n * @return EXIT_SUCCESS on success, -1 on error.\n */\nint\nresolve_unres_data(struct ly_ctx *ctx, struct unres_data *unres, struct lyd_node **root, int options)\n{\n    uint32_t i, j, first, resolved, del_items, stmt_count;\n    uint8_t prev_when_status;\n    int rc, progress, ignore_fail;\n    enum int_log_opts prev_ilo;\n    struct ly_err_item *prev_eitem;\n    LY_ERR prev_ly_errno = ly_errno;\n    struct lyd_node *parent;\n    struct lys_when *when;\n\n    assert(root);\n    assert(unres);\n\n    if (!unres->count) {\n        return EXIT_SUCCESS;\n    }\n\n    if (options & (LYD_OPT_NOTIF_FILTER | LYD_OPT_GET | LYD_OPT_GETCONFIG | LYD_OPT_EDIT)) {\n        ignore_fail = 1;\n    } else if (options & LYD_OPT_NOEXTDEPS) {\n        ignore_fail = 2;\n    } else {\n        ignore_fail = 0;\n    }\n\n    LOGVRB(\"Resolving unresolved data nodes and their constraints...\");\n    if (!ignore_fail) {\n        /* remember logging state only if errors are generated and valid */\n        ly_ilo_change(ctx, ILO_STORE, &prev_ilo, &prev_eitem);\n    }\n\n    /*\n     * when-stmt first\n     */\n    first = 1;\n    stmt_count = 0;\n    resolved = 0;\n    del_items = 0;\n    do {\n        if (!ignore_fail) {\n            ly_err_free_next(ctx, prev_eitem);\n        }\n        progress = 0;\n        for (i = 0; i < unres->count; i++) {\n            if (unres->type[i] != UNRES_WHEN) {\n                continue;\n            }\n            if (first) {\n                /* count when-stmt nodes in unres list */\n                stmt_count++;\n            }\n\n            /* resolve when condition only when all parent when conditions are already resolved */\n            for (parent = unres->node[i]->parent;\n                 parent && LYD_WHEN_DONE(parent->when_status);\n                 parent = parent->parent) {\n                if (!parent->parent && (parent->when_status & LYD_WHEN_FALSE)) {\n                    /* the parent node was already unlinked, do not resolve this node,\n                     * it will be removed anyway, so just mark it as resolved\n                     */\n                    unres->node[i]->when_status |= LYD_WHEN_FALSE;\n                    unres->type[i] = UNRES_RESOLVED;\n                    resolved++;\n                    break;\n                }\n            }\n            if (parent) {\n                continue;\n            }\n\n            prev_when_status = unres->node[i]->when_status;\n            rc = resolve_unres_data_item(unres->node[i], unres->type[i], ignore_fail, &when);\n            if (!rc) {\n                /* finish with error/delete the node only if when was changed from true to false, an external\n                 * dependency was not required, or it was not provided (the flag would not be passed down otherwise,\n                 * checked in upper functions) */\n                if ((unres->node[i]->when_status & LYD_WHEN_FALSE)\n                        && (!(when->flags & (LYS_XPCONF_DEP | LYS_XPSTATE_DEP)) || !(options & LYD_OPT_NOEXTDEPS))) {\n                    if ((!(prev_when_status & LYD_WHEN_TRUE) || !(options & LYD_OPT_WHENAUTODEL)) && !unres->node[i]->dflt) {\n                        /* false when condition */\n                        goto error;\n                    } /* follows else */\n\n                    /* auto-delete */\n                    LOGVRB(\"Auto-deleting node \\\"%s\\\" due to when condition (%s)\", ly_errpath(ctx), when->cond);\n\n                    /* only unlink now, the subtree can contain another nodes stored in the unres list */\n                    /* if it has parent non-presence containers that would be empty, we should actually\n                     * remove the container\n                     */\n                    for (parent = unres->node[i];\n                            parent->parent && parent->parent->schema->nodetype == LYS_CONTAINER;\n                            parent = parent->parent) {\n                        if (((struct lys_node_container *)parent->parent->schema)->presence) {\n                            /* presence container */\n                            break;\n                        }\n                        if (parent->next || parent->prev != parent) {\n                            /* non empty (the child we are in and we are going to remove is not the only child) */\n                            break;\n                        }\n                    }\n                    unres->node[i] = parent;\n\n                    if (*root && *root == unres->node[i]) {\n                        *root = (*root)->next;\n                    }\n\n                    lyd_unlink(unres->node[i]);\n                    unres->type[i] = UNRES_DELETE;\n                    del_items++;\n\n                    /* update the rest of unres items */\n                    for (j = 0; j < unres->count; j++) {\n                        if (unres->type[j] == UNRES_RESOLVED || unres->type[j] == UNRES_DELETE) {\n                            continue;\n                        }\n\n                        /* test if the node is in subtree to be deleted */\n                        for (parent = unres->node[j]; parent; parent = parent->parent) {\n                            if (parent == unres->node[i]) {\n                                /* yes, it is */\n                                unres->type[j] = UNRES_RESOLVED;\n                                resolved++;\n                                break;\n                            }\n                        }\n                    }\n                } else {\n                    unres->type[i] = UNRES_RESOLVED;\n                }\n                if (!ignore_fail) {\n                    ly_err_free_next(ctx, prev_eitem);\n                }\n                resolved++;\n                progress = 1;\n            } else if (rc == -1) {\n                goto error;\n            } /* else forward reference */\n        }\n        first = 0;\n    } while (progress && resolved < stmt_count);\n\n    /* do we have some unresolved when-stmt? */\n    if (stmt_count > resolved) {\n        goto error;\n    }\n\n    for (i = 0; del_items && i < unres->count; i++) {\n        /* we had some when-stmt resulted to false, so now we have to sanitize the unres list */\n        if (unres->type[i] != UNRES_DELETE) {\n            continue;\n        }\n        if (!unres->node[i]) {\n            unres->type[i] = UNRES_RESOLVED;\n            del_items--;\n            continue;\n        }\n\n        if (unres->store_diff) {\n            resolve_unres_data_autodel_diff(unres, i);\n        }\n\n        /* really remove the complete subtree */\n        lyd_free(unres->node[i]);\n        unres->type[i] = UNRES_RESOLVED;\n        del_items--;\n    }\n\n    /*\n     * now leafrefs\n     */\n    if (options & LYD_OPT_TRUSTED) {\n        /* we want to attempt to resolve leafrefs */\n        assert(!ignore_fail);\n        ignore_fail = 1;\n\n        ly_ilo_restore(ctx, prev_ilo, prev_eitem, 0);\n        ly_errno = prev_ly_errno;\n    }\n    first = 1;\n    stmt_count = 0;\n    resolved = 0;\n    do {\n        progress = 0;\n        for (i = 0; i < unres->count; i++) {\n            if (unres->type[i] != UNRES_LEAFREF) {\n                continue;\n            }\n            if (first) {\n                /* count leafref nodes in unres list */\n                stmt_count++;\n            }\n\n            rc = resolve_unres_data_item(unres->node[i], unres->type[i], ignore_fail, NULL);\n            if (!rc) {\n                unres->type[i] = UNRES_RESOLVED;\n                if (!ignore_fail) {\n                    ly_err_free_next(ctx, prev_eitem);\n                }\n                resolved++;\n                progress = 1;\n            } else if (rc == -1) {\n                goto error;\n            } /* else forward reference */\n        }\n        first = 0;\n    } while (progress && resolved < stmt_count);\n\n    /* do we have some unresolved leafrefs? */\n    if (stmt_count > resolved) {\n        goto error;\n    }\n\n    if (!ignore_fail) {\n        /* log normally now, throw away irrelevant errors */\n        ly_ilo_restore(ctx, prev_ilo, prev_eitem, 0);\n        ly_errno = prev_ly_errno;\n    }\n\n    /*\n     * rest\n     */\n    for (i = 0; i < unres->count; ++i) {\n        if (unres->type[i] == UNRES_RESOLVED) {\n            continue;\n        }\n        assert(!(options & LYD_OPT_TRUSTED) || ((unres->type[i] != UNRES_MUST) && (unres->type[i] != UNRES_MUST_INOUT)));\n\n        rc = resolve_unres_data_item(unres->node[i], unres->type[i], ignore_fail, NULL);\n        if (rc) {\n            /* since when was already resolved, a forward reference is an error */\n            return -1;\n        }\n\n        unres->type[i] = UNRES_RESOLVED;\n    }\n\n    LOGVRB(\"All data nodes and constraints resolved.\");\n    unres->count = 0;\n    return EXIT_SUCCESS;\n\nerror:\n    if (!ignore_fail) {\n        /* print all the new errors */\n        ly_ilo_restore(ctx, prev_ilo, prev_eitem, 1);\n        /* do not restore ly_errno, it was udpated properly */\n    }\n    return -1;\n}\n"], "fixing_code": ["/**\n * @file resolve.c\n * @author Michal Vasko <mvasko@cesnet.cz>\n * @brief libyang resolve functions\n *\n * Copyright (c) 2015 - 2018 CESNET, z.s.p.o.\n *\n * This source code is licensed under BSD 3-Clause License (the \"License\").\n * You may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://opensource.org/licenses/BSD-3-Clause\n */\n\n#define _GNU_SOURCE\n\n#include <stdlib.h>\n#include <assert.h>\n#include <string.h>\n#include <ctype.h>\n#include <limits.h>\n\n#include \"libyang.h\"\n#include \"resolve.h\"\n#include \"common.h\"\n#include \"xpath.h\"\n#include \"parser.h\"\n#include \"parser_yang.h\"\n#include \"xml_internal.h\"\n#include \"hash_table.h\"\n#include \"tree_internal.h\"\n#include \"extensions.h\"\n#include \"validation.h\"\n\n/* internal parsed predicate structure */\nstruct parsed_pred {\n    const struct lys_node *schema;\n    int len;\n    struct {\n        const char *mod_name;\n        int mod_name_len;\n        const char *name;\n        int nam_len;\n        const char *value;\n        int val_len;\n    } *pred;\n};\n\nint\nparse_range_dec64(const char **str_num, uint8_t dig, int64_t *num)\n{\n    const char *ptr;\n    int minus = 0;\n    int64_t ret = 0, prev_ret;\n    int8_t str_exp, str_dig = -1, trailing_zeros = 0;\n\n    ptr = *str_num;\n\n    if (ptr[0] == '-') {\n        minus = 1;\n        ++ptr;\n    } else if (ptr[0] == '+') {\n        ++ptr;\n    }\n\n    if (!isdigit(ptr[0])) {\n        /* there must be at least one */\n        return 1;\n    }\n\n    for (str_exp = 0; isdigit(ptr[0]) || ((ptr[0] == '.') && (str_dig < 0)); ++ptr) {\n        if (str_exp > 18) {\n            return 1;\n        }\n\n        if (ptr[0] == '.') {\n            if (ptr[1] == '.') {\n                /* it's the next interval */\n                break;\n            }\n            ++str_dig;\n        } else {\n            prev_ret = ret;\n            if (minus) {\n                ret = ret * 10 - (ptr[0] - '0');\n                if (ret > prev_ret) {\n                    return 1;\n                }\n            } else {\n                ret = ret * 10 + (ptr[0] - '0');\n                if (ret < prev_ret) {\n                    return 1;\n                }\n            }\n            if (str_dig > -1) {\n                ++str_dig;\n                if (ptr[0] == '0') {\n                    /* possibly trailing zero */\n                    trailing_zeros++;\n                } else {\n                    trailing_zeros = 0;\n                }\n            }\n            ++str_exp;\n        }\n    }\n    if (str_dig == 0) {\n        /* no digits after '.' */\n        return 1;\n    } else if (str_dig == -1) {\n        /* there are 0 numbers after the floating point */\n        str_dig = 0;\n    }\n    /* remove trailing zeros */\n    if (trailing_zeros) {\n        str_dig -= trailing_zeros;\n        str_exp -= trailing_zeros;\n        ret = ret / dec_pow(trailing_zeros);\n    }\n\n    /* it's parsed, now adjust the number based on fraction-digits, if needed */\n    if (str_dig < dig) {\n        if ((str_exp - 1) + (dig - str_dig) > 18) {\n            return 1;\n        }\n        prev_ret = ret;\n        ret *= dec_pow(dig - str_dig);\n        if ((minus && (ret > prev_ret)) || (!minus && (ret < prev_ret))) {\n            return 1;\n        }\n\n    }\n    if (str_dig > dig) {\n        return 1;\n    }\n\n    *str_num = ptr;\n    *num = ret;\n\n    return 0;\n}\n\n/**\n * @brief Parse an identifier.\n *\n * ;; An identifier MUST NOT start with (('X'|'x') ('M'|'m') ('L'|'l'))\n * identifier          = (ALPHA / \"_\")\n *                       *(ALPHA / DIGIT / \"_\" / \"-\" / \".\")\n *\n * @param[in] id Identifier to use.\n *\n * @return Number of characters successfully parsed.\n */\nunsigned int\nparse_identifier(const char *id)\n{\n    unsigned int parsed = 0;\n\n    assert(id);\n\n    if (!isalpha(id[0]) && (id[0] != '_')) {\n        return -parsed;\n    }\n\n    ++parsed;\n    ++id;\n\n    while (isalnum(id[0]) || (id[0] == '_') || (id[0] == '-') || (id[0] == '.')) {\n        ++parsed;\n        ++id;\n    }\n\n    return parsed;\n}\n\n/**\n * @brief Parse a node-identifier.\n *\n * node-identifier     = [module-name \":\"] identifier\n *\n * @param[in] id Identifier to use.\n * @param[out] mod_name Points to the module name, NULL if there is not any.\n * @param[out] mod_name_len Length of the module name, 0 if there is not any.\n * @param[out] name Points to the node name.\n * @param[out] nam_len Length of the node name.\n * @param[out] all_desc Whether the path starts with '/', only supported in extended paths.\n * @param[in] extended Whether to accept an extended path (support for [prefix:]*, /[prefix:]*, /[prefix:]., prefix:#identifier).\n *\n * @return Number of characters successfully parsed,\n *         positive on success, negative on failure.\n */\nstatic int\nparse_node_identifier(const char *id, const char **mod_name, int *mod_name_len, const char **name, int *nam_len,\n                      int *all_desc, int extended)\n{\n    int parsed = 0, ret, all_desc_local = 0, first_id_len;\n    const char *first_id;\n\n    assert(id);\n    assert((mod_name && mod_name_len) || (!mod_name && !mod_name_len));\n    assert((name && nam_len) || (!name && !nam_len));\n\n    if (mod_name) {\n        *mod_name = NULL;\n        *mod_name_len = 0;\n    }\n    if (name) {\n        *name = NULL;\n        *nam_len = 0;\n    }\n\n    if (extended) {\n        /* try to parse only the extended expressions */\n        if (id[parsed] == '/') {\n            if (all_desc) {\n                *all_desc = 1;\n            }\n            all_desc_local = 1;\n        } else {\n            if (all_desc) {\n                *all_desc = 0;\n            }\n        }\n\n        /* is there a prefix? */\n        ret = parse_identifier(id + all_desc_local);\n        if (ret > 0) {\n            if (id[all_desc_local + ret] != ':') {\n                /* this is not a prefix, so not an extended id */\n                goto standard_id;\n            }\n\n            if (mod_name) {\n                *mod_name = id + all_desc_local;\n                *mod_name_len = ret;\n            }\n\n            /* \"/\" and \":\" */\n            ret += all_desc_local + 1;\n        } else {\n            ret = all_desc_local;\n        }\n\n        /* parse either \"*\" or \".\" */\n        if (*(id + ret) == '*') {\n            if (name) {\n                *name = id + ret;\n                *nam_len = 1;\n            }\n            ++ret;\n\n            return ret;\n        } else if (*(id + ret) == '.') {\n            if (!all_desc_local) {\n                /* /. is redundant expression, we do not accept it */\n                return -ret;\n            }\n\n            if (name) {\n                *name = id + ret;\n                *nam_len = 1;\n            }\n            ++ret;\n\n            return ret;\n        } else if (*(id + ret) == '#') {\n            if (all_desc_local || !ret) {\n                /* no prefix */\n                return 0;\n            }\n            parsed = ret + 1;\n            if ((ret = parse_identifier(id + parsed)) < 1) {\n                return -parsed + ret;\n            }\n            *name = id + parsed - 1;\n            *nam_len = ret + 1;\n            return parsed + ret;\n        }\n        /* else a standard id, parse it all again */\n    }\n\nstandard_id:\n    if ((ret = parse_identifier(id)) < 1) {\n        return ret;\n    }\n\n    first_id = id;\n    first_id_len = ret;\n\n    parsed += ret;\n    id += ret;\n\n    /* there is prefix */\n    if (id[0] == ':') {\n        ++parsed;\n        ++id;\n\n    /* there isn't */\n    } else {\n        if (name) {\n            *name = first_id;\n            *nam_len = first_id_len;\n        }\n\n        return parsed;\n    }\n\n    /* identifier (node name) */\n    if ((ret = parse_identifier(id)) < 1) {\n        return -parsed + ret;\n    }\n\n    if (mod_name) {\n        *mod_name = first_id;\n        *mod_name_len = first_id_len;\n    }\n    if (name) {\n        *name = id;\n        *nam_len = ret;\n    }\n\n    return parsed + ret;\n}\n\n/**\n * @brief Parse a path-predicate (leafref).\n *\n * path-predicate      = \"[\" *WSP path-equality-expr *WSP \"]\"\n * path-equality-expr  = node-identifier *WSP \"=\" *WSP path-key-expr\n *\n * @param[in] id Identifier to use.\n * @param[out] prefix Points to the prefix, NULL if there is not any.\n * @param[out] pref_len Length of the prefix, 0 if there is not any.\n * @param[out] name Points to the node name.\n * @param[out] nam_len Length of the node name.\n * @param[out] path_key_expr Points to the path-key-expr.\n * @param[out] pke_len Length of the path-key-expr.\n * @param[out] has_predicate Flag to mark whether there is another predicate following.\n *\n * @return Number of characters successfully parsed,\n *         positive on success, negative on failure.\n */\nstatic int\nparse_path_predicate(const char *id, const char **prefix, int *pref_len, const char **name, int *nam_len,\n                     const char **path_key_expr, int *pke_len, int *has_predicate)\n{\n    const char *ptr;\n    int parsed = 0, ret;\n\n    assert(id);\n    if (prefix) {\n        *prefix = NULL;\n    }\n    if (pref_len) {\n        *pref_len = 0;\n    }\n    if (name) {\n        *name = NULL;\n    }\n    if (nam_len) {\n        *nam_len = 0;\n    }\n    if (path_key_expr) {\n        *path_key_expr = NULL;\n    }\n    if (pke_len) {\n        *pke_len = 0;\n    }\n    if (has_predicate) {\n        *has_predicate = 0;\n    }\n\n    if (id[0] != '[') {\n        return -parsed;\n    }\n\n    ++parsed;\n    ++id;\n\n    while (isspace(id[0])) {\n        ++parsed;\n        ++id;\n    }\n\n    if ((ret = parse_node_identifier(id, prefix, pref_len, name, nam_len, NULL, 0)) < 1) {\n        return -parsed+ret;\n    }\n\n    parsed += ret;\n    id += ret;\n\n    while (isspace(id[0])) {\n        ++parsed;\n        ++id;\n    }\n\n    if (id[0] != '=') {\n        return -parsed;\n    }\n\n    ++parsed;\n    ++id;\n\n    while (isspace(id[0])) {\n        ++parsed;\n        ++id;\n    }\n\n    if ((ptr = strchr(id, ']')) == NULL) {\n        return -parsed;\n    }\n\n    --ptr;\n    while (isspace(ptr[0])) {\n        --ptr;\n    }\n    ++ptr;\n\n    ret = ptr-id;\n    if (path_key_expr) {\n        *path_key_expr = id;\n    }\n    if (pke_len) {\n        *pke_len = ret;\n    }\n\n    parsed += ret;\n    id += ret;\n\n    while (isspace(id[0])) {\n        ++parsed;\n        ++id;\n    }\n\n    assert(id[0] == ']');\n\n    if (id[1] == '[') {\n        *has_predicate = 1;\n    }\n\n    return parsed+1;\n}\n\n/**\n * @brief Parse a path-key-expr (leafref). First call parses \"current()\", all\n *        the \"..\" and the first node-identifier, other calls parse a single\n *        node-identifier each.\n *\n * path-key-expr       = current-function-invocation *WSP \"/\" *WSP\n *                       rel-path-keyexpr\n * rel-path-keyexpr    = 1*(\"..\" *WSP \"/\" *WSP)\n *                       *(node-identifier *WSP \"/\" *WSP)\n *                       node-identifier\n *\n * @param[in] id Identifier to use.\n * @param[out] prefix Points to the prefix, NULL if there is not any.\n * @param[out] pref_len Length of the prefix, 0 if there is not any.\n * @param[out] name Points to the node name.\n * @param[out] nam_len Length of the node name.\n * @param[out] parent_times Number of \"..\" in the path. Must be 0 on the first call,\n *                          must not be changed between consecutive calls.\n * @return Number of characters successfully parsed,\n *         positive on success, negative on failure.\n */\nstatic int\nparse_path_key_expr(const char *id, const char **prefix, int *pref_len, const char **name, int *nam_len,\n                    int *parent_times)\n{\n    int parsed = 0, ret, par_times = 0;\n\n    assert(id);\n    assert(parent_times);\n    if (prefix) {\n        *prefix = NULL;\n    }\n    if (pref_len) {\n        *pref_len = 0;\n    }\n    if (name) {\n        *name = NULL;\n    }\n    if (nam_len) {\n        *nam_len = 0;\n    }\n\n    if (!*parent_times) {\n        /* current-function-invocation *WSP \"/\" *WSP rel-path-keyexpr */\n        if (strncmp(id, \"current()\", 9)) {\n            return -parsed;\n        }\n\n        parsed += 9;\n        id += 9;\n\n        while (isspace(id[0])) {\n            ++parsed;\n            ++id;\n        }\n\n        if (id[0] != '/') {\n            return -parsed;\n        }\n\n        ++parsed;\n        ++id;\n\n        while (isspace(id[0])) {\n            ++parsed;\n            ++id;\n        }\n\n        /* rel-path-keyexpr */\n        if (strncmp(id, \"..\", 2)) {\n            return -parsed;\n        }\n        ++par_times;\n\n        parsed += 2;\n        id += 2;\n\n        while (isspace(id[0])) {\n            ++parsed;\n            ++id;\n        }\n    }\n\n    /* 1*(\"..\" *WSP \"/\" *WSP) *(node-identifier *WSP \"/\" *WSP) node-identifier\n     *\n     * first parent reference with whitespaces already parsed\n     */\n    if (id[0] != '/') {\n        return -parsed;\n    }\n\n    ++parsed;\n    ++id;\n\n    while (isspace(id[0])) {\n        ++parsed;\n        ++id;\n    }\n\n    while (!strncmp(id, \"..\", 2) && !*parent_times) {\n        ++par_times;\n\n        parsed += 2;\n        id += 2;\n\n        while (isspace(id[0])) {\n            ++parsed;\n            ++id;\n        }\n\n        if (id[0] != '/') {\n            return -parsed;\n        }\n\n        ++parsed;\n        ++id;\n\n        while (isspace(id[0])) {\n            ++parsed;\n            ++id;\n        }\n    }\n\n    if (!*parent_times) {\n        *parent_times = par_times;\n    }\n\n    /* all parent references must be parsed at this point */\n    if ((ret = parse_node_identifier(id, prefix, pref_len, name, nam_len, NULL, 0)) < 1) {\n        return -parsed + ret;\n    }\n\n    parsed += ret;\n    id += ret;\n\n    return parsed;\n}\n\n/**\n * @brief Parse path-arg (leafref).\n *\n * path-arg            = absolute-path / relative-path\n * absolute-path       = 1*(\"/\" (node-identifier *path-predicate))\n * relative-path       = 1*(\"..\" \"/\") descendant-path\n *\n * @param[in] mod Module of the context node to get correct prefix in case it is not explicitly specified\n * @param[in] id Identifier to use.\n * @param[out] prefix Points to the prefix, NULL if there is not any.\n * @param[out] pref_len Length of the prefix, 0 if there is not any.\n * @param[out] name Points to the node name.\n * @param[out] nam_len Length of the node name.\n * @param[out] parent_times Number of \"..\" in the path. Must be 0 on the first call,\n *                          must not be changed between consecutive calls. -1 if the\n *                          path is relative.\n * @param[out] has_predicate Flag to mark whether there is a predicate specified.\n *\n * @return Number of characters successfully parsed,\n *         positive on success, negative on failure.\n */\nstatic int\nparse_path_arg(const struct lys_module *mod, const char *id, const char **prefix, int *pref_len,\n               const char **name, int *nam_len, int *parent_times, int *has_predicate)\n{\n    int parsed = 0, ret, par_times = 0;\n\n    assert(id);\n    assert(parent_times);\n    if (prefix) {\n        *prefix = NULL;\n    }\n    if (pref_len) {\n        *pref_len = 0;\n    }\n    if (name) {\n        *name = NULL;\n    }\n    if (nam_len) {\n        *nam_len = 0;\n    }\n    if (has_predicate) {\n        *has_predicate = 0;\n    }\n\n    if (!*parent_times && !strncmp(id, \"..\", 2)) {\n        ++par_times;\n\n        parsed += 2;\n        id += 2;\n\n        while (!strncmp(id, \"/..\", 3)) {\n            ++par_times;\n\n            parsed += 3;\n            id += 3;\n        }\n    }\n\n    if (!*parent_times) {\n        if (par_times) {\n            *parent_times = par_times;\n        } else {\n            *parent_times = -1;\n        }\n    }\n\n    if (id[0] != '/') {\n        return -parsed;\n    }\n\n    /* skip '/' */\n    ++parsed;\n    ++id;\n\n    /* node-identifier ([prefix:]identifier) */\n    if ((ret = parse_node_identifier(id, prefix, pref_len, name, nam_len, NULL, 0)) < 1) {\n        return -parsed - ret;\n    }\n    if (prefix && !(*prefix)) {\n        /* actually we always need prefix even it is not specified */\n        *prefix = lys_main_module(mod)->name;\n        *pref_len = strlen(*prefix);\n    }\n\n    parsed += ret;\n    id += ret;\n\n    /* there is no predicate */\n    if ((id[0] == '/') || !id[0]) {\n        return parsed;\n    } else if (id[0] != '[') {\n        return -parsed;\n    }\n\n    if (has_predicate) {\n        *has_predicate = 1;\n    }\n\n    return parsed;\n}\n\n/**\n * @brief Parse instance-identifier in JSON data format. That means that prefixes\n *        are actually model names.\n *\n * instance-identifier = 1*(\"/\" (node-identifier *predicate))\n *\n * @param[in] id Identifier to use.\n * @param[out] model Points to the model name.\n * @param[out] mod_len Length of the model name.\n * @param[out] name Points to the node name.\n * @param[out] nam_len Length of the node name.\n * @param[out] has_predicate Flag to mark whether there is a predicate specified.\n *\n * @return Number of characters successfully parsed,\n *         positive on success, negative on failure.\n */\nstatic int\nparse_instance_identifier(const char *id, const char **model, int *mod_len, const char **name, int *nam_len,\n                          int *has_predicate)\n{\n    int parsed = 0, ret;\n\n    assert(id && model && mod_len && name && nam_len);\n\n    if (has_predicate) {\n        *has_predicate = 0;\n    }\n\n    if (id[0] != '/') {\n        return -parsed;\n    }\n\n    ++parsed;\n    ++id;\n\n    if ((ret = parse_identifier(id)) < 1) {\n        return ret;\n    }\n\n    *name = id;\n    *nam_len = ret;\n\n    parsed += ret;\n    id += ret;\n\n    if (id[0] == ':') {\n        /* we have prefix */\n        *model = *name;\n        *mod_len = *nam_len;\n\n        ++parsed;\n        ++id;\n\n        if ((ret = parse_identifier(id)) < 1) {\n            return ret;\n        }\n\n        *name = id;\n        *nam_len = ret;\n\n        parsed += ret;\n        id += ret;\n    }\n\n    if (id[0] == '[' && has_predicate) {\n        *has_predicate = 1;\n    }\n\n    return parsed;\n}\n\n/**\n * @brief Parse predicate (instance-identifier) in JSON data format. That means that prefixes\n *        (which are mandatory) are actually model names.\n *\n * predicate           = \"[\" *WSP (predicate-expr / pos) *WSP \"]\"\n * predicate-expr      = (node-identifier / \".\") *WSP \"=\" *WSP\n *                       ((DQUOTE string DQUOTE) /\n *                        (SQUOTE string SQUOTE))\n * pos                 = non-negative-integer-value\n *\n * @param[in] id Identifier to use.\n * @param[out] model Points to the model name.\n * @param[out] mod_len Length of the model name.\n * @param[out] name Points to the node name. Can be identifier (from node-identifier), \".\" or pos.\n * @param[out] nam_len Length of the node name.\n * @param[out] value Value the node-identifier must have (string from the grammar),\n *                   NULL if there is not any.\n * @param[out] val_len Length of the value, 0 if there is not any.\n * @param[out] has_predicate Flag to mark whether there is a predicate specified.\n *\n * @return Number of characters successfully parsed,\n *         positive on success, negative on failure.\n */\nstatic int\nparse_predicate(const char *id, const char **model, int *mod_len, const char **name, int *nam_len,\n                const char **value, int *val_len, int *has_predicate)\n{\n    const char *ptr;\n    int parsed = 0, ret;\n    char quote;\n\n    assert(id);\n    if (model) {\n        assert(mod_len);\n        *model = NULL;\n        *mod_len = 0;\n    }\n    if (name) {\n        assert(nam_len);\n        *name = NULL;\n        *nam_len = 0;\n    }\n    if (value) {\n        assert(val_len);\n        *value = NULL;\n        *val_len = 0;\n    }\n    if (has_predicate) {\n        *has_predicate = 0;\n    }\n\n    if (id[0] != '[') {\n        return -parsed;\n    }\n\n    ++parsed;\n    ++id;\n\n    while (isspace(id[0])) {\n        ++parsed;\n        ++id;\n    }\n\n    /* pos */\n    if (isdigit(id[0])) {\n        if (name) {\n            *name = id;\n        }\n\n        if (id[0] == '0') {\n            return -parsed;\n        }\n\n        while (isdigit(id[0])) {\n            ++parsed;\n            ++id;\n        }\n\n        if (nam_len) {\n            *nam_len = id-(*name);\n        }\n\n    /* \".\" or node-identifier */\n    } else {\n        if (id[0] == '.') {\n            if (name) {\n                *name = id;\n            }\n            if (nam_len) {\n                *nam_len = 1;\n            }\n\n            ++parsed;\n            ++id;\n\n        } else {\n            if ((ret = parse_node_identifier(id, model, mod_len, name, nam_len, NULL, 0)) < 1) {\n                return -parsed + ret;\n            }\n\n            parsed += ret;\n            id += ret;\n        }\n\n        while (isspace(id[0])) {\n            ++parsed;\n            ++id;\n        }\n\n        if (id[0] != '=') {\n            return -parsed;\n        }\n\n        ++parsed;\n        ++id;\n\n        while (isspace(id[0])) {\n            ++parsed;\n            ++id;\n        }\n\n        /* ((DQUOTE string DQUOTE) / (SQUOTE string SQUOTE)) */\n        if ((id[0] == '\\\"') || (id[0] == '\\'')) {\n            quote = id[0];\n\n            ++parsed;\n            ++id;\n\n            if ((ptr = strchr(id, quote)) == NULL) {\n                return -parsed;\n            }\n            ret = ptr - id;\n\n            if (value) {\n                *value = id;\n            }\n            if (val_len) {\n                *val_len = ret;\n            }\n\n            parsed += ret + 1;\n            id += ret + 1;\n        } else {\n            return -parsed;\n        }\n    }\n\n    while (isspace(id[0])) {\n        ++parsed;\n        ++id;\n    }\n\n    if (id[0] != ']') {\n        return -parsed;\n    }\n\n    ++parsed;\n    ++id;\n\n    if ((id[0] == '[') && has_predicate) {\n        *has_predicate = 1;\n    }\n\n    return parsed;\n}\n\n/**\n * @brief Parse schema-nodeid.\n *\n * schema-nodeid       = absolute-schema-nodeid /\n *                       descendant-schema-nodeid\n * absolute-schema-nodeid = 1*(\"/\" node-identifier)\n * descendant-schema-nodeid = [\".\" \"/\"]\n *                       node-identifier\n *                       absolute-schema-nodeid\n *\n * @param[in] id Identifier to use.\n * @param[out] mod_name Points to the module name, NULL if there is not any.\n * @param[out] mod_name_len Length of the module name, 0 if there is not any.\n * @param[out] name Points to the node name.\n * @param[out] nam_len Length of the node name.\n * @param[out] is_relative Flag to mark whether the nodeid is absolute or descendant. Must be -1\n *                         on the first call, must not be changed between consecutive calls.\n * @param[out] has_predicate Flag to mark whether there is a predicate specified. It cannot be\n *                           based on the grammar, in those cases use NULL.\n * @param[in] extended Whether to accept an extended path (support for /[prefix:]*, //[prefix:]*, //[prefix:].).\n *\n * @return Number of characters successfully parsed,\n *         positive on success, negative on failure.\n */\nint\nparse_schema_nodeid(const char *id, const char **mod_name, int *mod_name_len, const char **name, int *nam_len,\n                    int *is_relative, int *has_predicate, int *all_desc, int extended)\n{\n    int parsed = 0, ret;\n\n    assert(id);\n    assert(is_relative);\n\n    if (has_predicate) {\n        *has_predicate = 0;\n    }\n\n    if (id[0] != '/') {\n        if (*is_relative != -1) {\n            return -parsed;\n        } else {\n            *is_relative = 1;\n        }\n        if (!strncmp(id, \"./\", 2)) {\n            parsed += 2;\n            id += 2;\n        }\n    } else {\n        if (*is_relative == -1) {\n            *is_relative = 0;\n        }\n        ++parsed;\n        ++id;\n    }\n\n    if ((ret = parse_node_identifier(id, mod_name, mod_name_len, name, nam_len, all_desc, extended)) < 1) {\n        return -parsed + ret;\n    }\n\n    parsed += ret;\n    id += ret;\n\n    if ((id[0] == '[') && has_predicate) {\n        *has_predicate = 1;\n    }\n\n    return parsed;\n}\n\n/**\n * @brief Parse schema predicate (special format internally used).\n *\n * predicate           = \"[\" *WSP predicate-expr *WSP \"]\"\n * predicate-expr      = \".\" / [prefix:]identifier / positive-integer / key-with-value\n * key-with-value      = identifier *WSP \"=\" *WSP\n *                       ((DQUOTE string DQUOTE) /\n *                        (SQUOTE string SQUOTE))\n *\n * @param[in] id Identifier to use.\n * @param[out] mod_name Points to the list key module name.\n * @param[out] mod_name_len Length of \\p mod_name.\n * @param[out] name Points to the list key name.\n * @param[out] nam_len Length of \\p name.\n * @param[out] value Points to the key value. If specified, key-with-value is expected.\n * @param[out] val_len Length of \\p value.\n * @param[out] has_predicate Flag to mark whether there is another predicate specified.\n */\nint\nparse_schema_json_predicate(const char *id, const char **mod_name, int *mod_name_len, const char **name, int *nam_len,\n                            const char **value, int *val_len, int *has_predicate)\n{\n    const char *ptr;\n    int parsed = 0, ret;\n    char quote;\n\n    assert(id);\n    if (mod_name) {\n        *mod_name = NULL;\n    }\n    if (mod_name_len) {\n        *mod_name_len = 0;\n    }\n    if (name) {\n        *name = NULL;\n    }\n    if (nam_len) {\n        *nam_len = 0;\n    }\n    if (value) {\n        *value = NULL;\n    }\n    if (val_len) {\n        *val_len = 0;\n    }\n    if (has_predicate) {\n        *has_predicate = 0;\n    }\n\n    if (id[0] != '[') {\n        return -parsed;\n    }\n\n    ++parsed;\n    ++id;\n\n    while (isspace(id[0])) {\n        ++parsed;\n        ++id;\n    }\n\n    /* identifier */\n    if (id[0] == '.') {\n        ret = 1;\n\n        if (name) {\n            *name = id;\n        }\n        if (nam_len) {\n            *nam_len = ret;\n        }\n    } else if (isdigit(id[0])) {\n        if (id[0] == '0') {\n            return -parsed;\n        }\n        ret = 1;\n        while (isdigit(id[ret])) {\n            ++ret;\n        }\n\n        if (name) {\n            *name = id;\n        }\n        if (nam_len) {\n            *nam_len = ret;\n        }\n    } else if ((ret = parse_node_identifier(id, mod_name, mod_name_len, name, nam_len, NULL, 0)) < 1) {\n        return -parsed + ret;\n    }\n\n    parsed += ret;\n    id += ret;\n\n    while (isspace(id[0])) {\n        ++parsed;\n        ++id;\n    }\n\n    /* there is value as well */\n    if (id[0] == '=') {\n        if (name && isdigit(**name)) {\n            return -parsed;\n        }\n\n        ++parsed;\n        ++id;\n\n        while (isspace(id[0])) {\n            ++parsed;\n            ++id;\n        }\n\n        /* ((DQUOTE string DQUOTE) / (SQUOTE string SQUOTE)) */\n        if ((id[0] == '\\\"') || (id[0] == '\\'')) {\n            quote = id[0];\n\n            ++parsed;\n            ++id;\n\n            if ((ptr = strchr(id, quote)) == NULL) {\n                return -parsed;\n            }\n            ret = ptr - id;\n\n            if (value) {\n                *value = id;\n            }\n            if (val_len) {\n                *val_len = ret;\n            }\n\n            parsed += ret + 1;\n            id += ret + 1;\n        } else {\n            return -parsed;\n        }\n\n        while (isspace(id[0])) {\n            ++parsed;\n            ++id;\n        }\n    }\n\n    if (id[0] != ']') {\n        return -parsed;\n    }\n\n    ++parsed;\n    ++id;\n\n    if ((id[0] == '[') && has_predicate) {\n        *has_predicate = 1;\n    }\n\n    return parsed;\n}\n\n#ifdef LY_ENABLED_CACHE\n\nstatic int\nresolve_hash_table_find_equal(void *val1_p, void *val2_p, int mod, void *UNUSED(cb_data))\n{\n    struct lyd_node *val2, *elem2;\n    struct parsed_pred pp;\n    const char *str;\n    int i;\n\n    assert(!mod);\n    (void)mod;\n\n    pp = *((struct parsed_pred *)val1_p);\n    val2 = *((struct lyd_node **)val2_p);\n\n    if (val2->schema != pp.schema) {\n        return 0;\n    }\n\n    switch (val2->schema->nodetype) {\n    case LYS_CONTAINER:\n    case LYS_LEAF:\n    case LYS_ANYXML:\n    case LYS_ANYDATA:\n        return 1;\n    case LYS_LEAFLIST:\n        str = ((struct lyd_node_leaf_list *)val2)->value_str;\n        if (!strncmp(str, pp.pred[0].value, pp.pred[0].val_len) && !str[pp.pred[0].val_len]) {\n            return 1;\n        }\n        return 0;\n    case LYS_LIST:\n        assert(((struct lys_node_list *)val2->schema)->keys_size);\n        assert(((struct lys_node_list *)val2->schema)->keys_size == pp.len);\n\n        /* lists with keys, their equivalence is based on their keys */\n        elem2 = val2->child;\n        /* the exact data order is guaranteed */\n        for (i = 0; elem2 && (i < pp.len); ++i) {\n            /* module check */\n            if (pp.pred[i].mod_name) {\n                if (strncmp(lyd_node_module(elem2)->name, pp.pred[i].mod_name, pp.pred[i].mod_name_len)\n                        || lyd_node_module(elem2)->name[pp.pred[i].mod_name_len]) {\n                    break;\n                }\n            } else {\n                if (lyd_node_module(elem2) != lys_node_module(pp.schema)) {\n                    break;\n                }\n            }\n\n            /* name check */\n            if (strncmp(elem2->schema->name, pp.pred[i].name, pp.pred[i].nam_len) || elem2->schema->name[pp.pred[i].nam_len]) {\n                break;\n            }\n\n            /* value check */\n            str = ((struct lyd_node_leaf_list *)elem2)->value_str;\n            if (strncmp(str, pp.pred[i].value, pp.pred[i].val_len) || str[pp.pred[i].val_len]) {\n                break;\n            }\n\n            /* next key */\n            elem2 = elem2->next;\n        }\n        if (i == pp.len) {\n            return 1;\n        }\n        return 0;\n    default:\n        break;\n    }\n\n    LOGINT(val2->schema->module->ctx);\n    return 0;\n}\n\nstatic struct lyd_node *\nresolve_json_data_node_hash(struct lyd_node *parent, struct parsed_pred pp)\n{\n    values_equal_cb prev_cb;\n    struct lyd_node **ret = NULL;\n    uint32_t hash;\n    int i;\n\n    assert(parent && parent->hash);\n\n    /* set our value equivalence callback that does not require data nodes */\n    prev_cb = lyht_set_cb(parent->ht, resolve_hash_table_find_equal);\n\n    /* get the hash of the searched node */\n    hash = dict_hash_multi(0, lys_node_module(pp.schema)->name, strlen(lys_node_module(pp.schema)->name));\n    hash = dict_hash_multi(hash, pp.schema->name, strlen(pp.schema->name));\n    if (pp.schema->nodetype == LYS_LEAFLIST) {\n        assert((pp.len == 1) && (pp.pred[0].name[0] == '.') && (pp.pred[0].nam_len == 1));\n        /* leaf-list value in predicate */\n        hash = dict_hash_multi(hash, pp.pred[0].value, pp.pred[0].val_len);\n    } else if (pp.schema->nodetype == LYS_LIST) {\n        /* list keys in predicates */\n        for (i = 0; i < pp.len; ++i) {\n            hash = dict_hash_multi(hash, pp.pred[i].value, pp.pred[i].val_len);\n        }\n    }\n    hash = dict_hash_multi(hash, NULL, 0);\n\n    /* try to find the node */\n    i = lyht_find(parent->ht, &pp, hash, (void **)&ret);\n    assert(i || *ret);\n\n    /* restore the original callback */\n    lyht_set_cb(parent->ht, prev_cb);\n\n    return (i ? NULL : *ret);\n}\n\n#endif\n\n/**\n * @brief Resolve (find) a feature definition. Logs directly.\n *\n * @param[in] feat_name Feature name to resolve.\n * @param[in] len Length of \\p feat_name.\n * @param[in] node Node with the if-feature expression.\n * @param[out] feature Pointer to be set to point to the feature definition, if feature not found\n * (return code 1), the pointer is untouched.\n *\n * @return 0 on success, 1 on forward reference, -1 on error.\n */\nstatic int\nresolve_feature(const char *feat_name, uint16_t len, const struct lys_node *node, struct lys_feature **feature)\n{\n    char *str;\n    const char *mod_name, *name;\n    int mod_name_len, nam_len, i, j;\n    const struct lys_module *module;\n\n    assert(feature);\n\n    /* check prefix */\n    if ((i = parse_node_identifier(feat_name, &mod_name, &mod_name_len, &name, &nam_len, NULL, 0)) < 1) {\n        LOGVAL(node->module->ctx, LYE_INCHAR, LY_VLOG_NONE, NULL, feat_name[-i], &feat_name[-i]);\n        return -1;\n    }\n\n    module = lyp_get_module(lys_node_module(node), NULL, 0, mod_name, mod_name_len, 0);\n    if (!module) {\n        /* identity refers unknown data model */\n        LOGVAL(node->module->ctx, LYE_INMOD_LEN, LY_VLOG_NONE, NULL, mod_name_len, mod_name);\n        return -1;\n    }\n\n    if (module != node->module && module == lys_node_module(node)) {\n        /* first, try to search directly in submodule where the feature was mentioned */\n        for (j = 0; j < node->module->features_size; j++) {\n            if (!strncmp(name, node->module->features[j].name, nam_len) && !node->module->features[j].name[nam_len]) {\n                /* check status */\n                if (lyp_check_status(node->flags, lys_node_module(node), node->name, node->module->features[j].flags,\n                                     node->module->features[j].module, node->module->features[j].name, NULL)) {\n                    return -1;\n                }\n                *feature = &node->module->features[j];\n                return 0;\n            }\n        }\n    }\n\n    /* search in the identified module ... */\n    for (j = 0; j < module->features_size; j++) {\n        if (!strncmp(name, module->features[j].name, nam_len) && !module->features[j].name[nam_len]) {\n            /* check status */\n            if (lyp_check_status(node->flags, lys_node_module(node), node->name, module->features[j].flags,\n                                 module->features[j].module, module->features[j].name, NULL)) {\n                return -1;\n            }\n            *feature = &module->features[j];\n            return 0;\n        }\n    }\n    /* ... and all its submodules */\n    for (i = 0; i < module->inc_size && module->inc[i].submodule; i++) {\n        for (j = 0; j < module->inc[i].submodule->features_size; j++) {\n            if (!strncmp(name, module->inc[i].submodule->features[j].name, nam_len)\n                    && !module->inc[i].submodule->features[j].name[nam_len]) {\n                /* check status */\n                if (lyp_check_status(node->flags, lys_node_module(node), node->name,\n                                     module->inc[i].submodule->features[j].flags,\n                                     module->inc[i].submodule->features[j].module,\n                                     module->inc[i].submodule->features[j].name, NULL)) {\n                    return -1;\n                }\n                *feature = &module->inc[i].submodule->features[j];\n                return 0;\n            }\n        }\n    }\n\n    /* not found */\n    str = strndup(feat_name, len);\n    LOGVAL(node->module->ctx, LYE_INRESOLV, LY_VLOG_NONE, NULL, \"feature\", str);\n    free(str);\n    return 1;\n}\n\n/*\n * @return\n *  -  1 if enabled\n *  -  0 if disabled\n */\nstatic int\nresolve_feature_value(const struct lys_feature *feat)\n{\n    int i;\n\n    for (i = 0; i < feat->iffeature_size; i++) {\n        if (!resolve_iffeature(&feat->iffeature[i])) {\n            return 0;\n        }\n    }\n\n    return feat->flags & LYS_FENABLED ? 1 : 0;\n}\n\nstatic int\nresolve_iffeature_recursive(struct lys_iffeature *expr, int *index_e, int *index_f)\n{\n    uint8_t op;\n    int a, b;\n\n    op = iff_getop(expr->expr, *index_e);\n    (*index_e)++;\n\n    switch (op) {\n    case LYS_IFF_F:\n        /* resolve feature */\n        return resolve_feature_value(expr->features[(*index_f)++]);\n    case LYS_IFF_NOT:\n        /* invert result */\n        return resolve_iffeature_recursive(expr, index_e, index_f) ? 0 : 1;\n    case LYS_IFF_AND:\n    case LYS_IFF_OR:\n        a = resolve_iffeature_recursive(expr, index_e, index_f);\n        b = resolve_iffeature_recursive(expr, index_e, index_f);\n        if (op == LYS_IFF_AND) {\n            return a && b;\n        } else { /* LYS_IFF_OR */\n            return a || b;\n        }\n    }\n\n    return 0;\n}\n\nint\nresolve_iffeature(struct lys_iffeature *expr)\n{\n    int index_e = 0, index_f = 0;\n\n    if (expr->expr && expr->features[0]) {\n        return resolve_iffeature_recursive(expr, &index_e, &index_f);\n    }\n    return 0;\n}\n\nstruct iff_stack {\n    int size;\n    int index;     /* first empty item */\n    uint8_t *stack;\n};\n\nstatic int\niff_stack_push(struct iff_stack *stack, uint8_t value)\n{\n    if (stack->index == stack->size) {\n        stack->size += 4;\n        stack->stack = ly_realloc(stack->stack, stack->size * sizeof *stack->stack);\n        LY_CHECK_ERR_RETURN(!stack->stack, LOGMEM(NULL); stack->size = 0, EXIT_FAILURE);\n    }\n\n    stack->stack[stack->index++] = value;\n    return EXIT_SUCCESS;\n}\n\nstatic uint8_t\niff_stack_pop(struct iff_stack *stack)\n{\n    stack->index--;\n    return stack->stack[stack->index];\n}\n\nstatic void\niff_stack_clean(struct iff_stack *stack)\n{\n    stack->size = 0;\n    free(stack->stack);\n}\n\nstatic void\niff_setop(uint8_t *list, uint8_t op, int pos)\n{\n    uint8_t *item;\n    uint8_t mask = 3;\n\n    assert(pos >= 0);\n    assert(op <= 3); /* max 2 bits */\n\n    item = &list[pos / 4];\n    mask = mask << 2 * (pos % 4);\n    *item = (*item) & ~mask;\n    *item = (*item) | (op << 2 * (pos % 4));\n}\n\nuint8_t\niff_getop(uint8_t *list, int pos)\n{\n    uint8_t *item;\n    uint8_t mask = 3, result;\n\n    assert(pos >= 0);\n\n    item = &list[pos / 4];\n    result = (*item) & (mask << 2 * (pos % 4));\n    return result >> 2 * (pos % 4);\n}\n\n#define LYS_IFF_LP 0x04 /* ( */\n#define LYS_IFF_RP 0x08 /* ) */\n\n/* internal structure for passing data for UNRES_IFFEAT */\nstruct unres_iffeat_data {\n    struct lys_node *node;\n    const char *fname;\n    int infeature;\n};\n\nvoid\nresolve_iffeature_getsizes(struct lys_iffeature *iffeat, unsigned int *expr_size, unsigned int *feat_size)\n{\n    unsigned int e = 0, f = 0, r = 0;\n    uint8_t op;\n\n    assert(iffeat);\n\n    if (!iffeat->expr) {\n        goto result;\n    }\n\n    do {\n        op = iff_getop(iffeat->expr, e++);\n        switch (op) {\n        case LYS_IFF_NOT:\n            if (!r) {\n                r += 1;\n            }\n            break;\n        case LYS_IFF_AND:\n        case LYS_IFF_OR:\n            if (!r) {\n                r += 2;\n            } else {\n                r += 1;\n            }\n            break;\n        case LYS_IFF_F:\n            f++;\n            if (r) {\n                r--;\n            }\n            break;\n        }\n    } while(r);\n\nresult:\n    if (expr_size) {\n        *expr_size = e;\n    }\n    if (feat_size) {\n        *feat_size = f;\n    }\n}\n\nint\nresolve_iffeature_compile(struct lys_iffeature *iffeat_expr, const char *value, struct lys_node *node,\n                          int infeature, struct unres_schema *unres)\n{\n    const char *c = value;\n    int r, rc = EXIT_FAILURE;\n    int i, j, last_not, checkversion = 0;\n    unsigned int f_size = 0, expr_size = 0, f_exp = 1;\n    uint8_t op;\n    struct iff_stack stack = {0, 0, NULL};\n    struct unres_iffeat_data *iff_data;\n    struct ly_ctx *ctx = node->module->ctx;\n\n    assert(c);\n\n    if (isspace(c[0])) {\n        LOGVAL(ctx, LYE_INCHAR, LY_VLOG_NONE, NULL, c[0], c);\n        return EXIT_FAILURE;\n    }\n\n    /* pre-parse the expression to get sizes for arrays, also do some syntax checks of the expression */\n    for (i = j = last_not = 0; c[i]; i++) {\n        if (c[i] == '(') {\n            checkversion = 1;\n            j++;\n            continue;\n        } else if (c[i] == ')') {\n            j--;\n            continue;\n        } else if (isspace(c[i])) {\n            continue;\n        }\n\n        if (!strncmp(&c[i], \"not\", r = 3) || !strncmp(&c[i], \"and\", r = 3) || !strncmp(&c[i], \"or\", r = 2)) {\n            if (c[i + r] == '\\0') {\n                LOGVAL(ctx, LYE_INARG, LY_VLOG_NONE, NULL, value, \"if-feature\");\n                return EXIT_FAILURE;\n            } else if (!isspace(c[i + r])) {\n                /* feature name starting with the not/and/or */\n                last_not = 0;\n                f_size++;\n            } else if (c[i] == 'n') { /* not operation */\n                if (last_not) {\n                    /* double not */\n                    expr_size = expr_size - 2;\n                    last_not = 0;\n                } else {\n                    last_not = 1;\n                }\n            } else { /* and, or */\n                f_exp++;\n                /* not a not operation */\n                last_not = 0;\n            }\n            i += r;\n        } else {\n            f_size++;\n            last_not = 0;\n        }\n        expr_size++;\n\n        while (!isspace(c[i])) {\n            if (c[i] == '(') {\n                LOGVAL(ctx, LYE_INARG, LY_VLOG_NONE, NULL, value, \"if-feature\");\n                return EXIT_FAILURE;\n            } else if (!c[i] || c[i] == ')') {\n                i--;\n                break;\n            }\n            i++;\n        }\n    }\n    if (j || f_exp != f_size) {\n        /* not matching count of ( and ) */\n        LOGVAL(ctx, LYE_INARG, LY_VLOG_NONE, NULL, value, \"if-feature\");\n        return EXIT_FAILURE;\n    }\n\n    if (checkversion || expr_size > 1) {\n        /* check that we have 1.1 module */\n        if (node->module->version != LYS_VERSION_1_1) {\n            LOGVAL(ctx, LYE_INARG, LY_VLOG_NONE, NULL, value, \"if-feature\");\n            LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"YANG 1.1 if-feature expression found in 1.0 module.\");\n            return EXIT_FAILURE;\n        }\n    }\n\n    /* allocate the memory */\n    iffeat_expr->expr = calloc((j = (expr_size / 4) + ((expr_size % 4) ? 1 : 0)), sizeof *iffeat_expr->expr);\n    iffeat_expr->features = calloc(f_size, sizeof *iffeat_expr->features);\n    stack.stack = malloc(expr_size * sizeof *stack.stack);\n    LY_CHECK_ERR_GOTO(!stack.stack || !iffeat_expr->expr || !iffeat_expr->features, LOGMEM(ctx), error);\n    stack.size = expr_size;\n    f_size--; expr_size--; /* used as indexes from now */\n\n    for (i--; i >= 0; i--) {\n        if (c[i] == ')') {\n            /* push it on stack */\n            iff_stack_push(&stack, LYS_IFF_RP);\n            continue;\n        } else if (c[i] == '(') {\n            /* pop from the stack into result all operators until ) */\n            while((op = iff_stack_pop(&stack)) != LYS_IFF_RP) {\n                iff_setop(iffeat_expr->expr, op, expr_size--);\n            }\n            continue;\n        } else if (isspace(c[i])) {\n            continue;\n        }\n\n        /* end operator or operand -> find beginning and get what is it */\n        j = i + 1;\n        while (i >= 0 && !isspace(c[i]) && c[i] != '(') {\n            i--;\n        }\n        i++; /* get back by one step */\n\n        if (!strncmp(&c[i], \"not\", 3) && isspace(c[i + 3])) {\n            if (stack.index && stack.stack[stack.index - 1] == LYS_IFF_NOT) {\n                /* double not */\n                iff_stack_pop(&stack);\n            } else {\n                /* not has the highest priority, so do not pop from the stack\n                 * as in case of AND and OR */\n                iff_stack_push(&stack, LYS_IFF_NOT);\n            }\n        } else if (!strncmp(&c[i], \"and\", 3) && isspace(c[i + 3])) {\n            /* as for OR - pop from the stack all operators with the same or higher\n             * priority and store them to the result, then push the AND to the stack */\n            while (stack.index && stack.stack[stack.index - 1] <= LYS_IFF_AND) {\n                op = iff_stack_pop(&stack);\n                iff_setop(iffeat_expr->expr, op, expr_size--);\n            }\n            iff_stack_push(&stack, LYS_IFF_AND);\n        } else if (!strncmp(&c[i], \"or\", 2) && isspace(c[i + 2])) {\n            while (stack.index && stack.stack[stack.index - 1] <= LYS_IFF_OR) {\n                op = iff_stack_pop(&stack);\n                iff_setop(iffeat_expr->expr, op, expr_size--);\n            }\n            iff_stack_push(&stack, LYS_IFF_OR);\n        } else {\n            /* feature name, length is j - i */\n\n            /* add it to the result */\n            iff_setop(iffeat_expr->expr, LYS_IFF_F, expr_size--);\n\n            /* now get the link to the feature definition. Since it can be\n             * forward referenced, we have to keep the feature name in auxiliary\n             * structure passed into unres */\n            iff_data = malloc(sizeof *iff_data);\n            LY_CHECK_ERR_GOTO(!iff_data, LOGMEM(ctx), error);\n            iff_data->node = node;\n            iff_data->fname = lydict_insert(node->module->ctx, &c[i], j - i);\n            iff_data->infeature = infeature;\n            r = unres_schema_add_node(node->module, unres, &iffeat_expr->features[f_size], UNRES_IFFEAT,\n                                      (struct lys_node *)iff_data);\n            f_size--;\n\n            if (r == -1) {\n                lydict_remove(node->module->ctx, iff_data->fname);\n                free(iff_data);\n                goto error;\n            }\n        }\n    }\n    while (stack.index) {\n        op = iff_stack_pop(&stack);\n        iff_setop(iffeat_expr->expr, op, expr_size--);\n    }\n\n    if (++expr_size || ++f_size) {\n        /* not all expected operators and operands found */\n        LOGVAL(ctx, LYE_INARG, LY_VLOG_NONE, NULL, value, \"if-feature\");\n        rc = EXIT_FAILURE;\n    } else {\n        rc = EXIT_SUCCESS;\n    }\n\nerror:\n    /* cleanup */\n    iff_stack_clean(&stack);\n\n    return rc;\n}\n\n/**\n * @brief Resolve (find) a data node based on a schema-nodeid.\n *\n * Used for resolving unique statements - so id is expected to be relative and local (without reference to a different\n * module).\n *\n */\nstruct lyd_node *\nresolve_data_descendant_schema_nodeid(const char *nodeid, struct lyd_node *start)\n{\n    char *str, *token, *p;\n    struct lyd_node *result = NULL, *iter;\n    const struct lys_node *schema = NULL;\n\n    assert(nodeid && start);\n\n    if (nodeid[0] == '/') {\n        return NULL;\n    }\n\n    str = p = strdup(nodeid);\n    LY_CHECK_ERR_RETURN(!str, LOGMEM(start->schema->module->ctx), NULL);\n\n    while (p) {\n        token = p;\n        p = strchr(p, '/');\n        if (p) {\n            *p = '\\0';\n            p++;\n        }\n\n        if (p) {\n            /* inner node */\n            if (resolve_descendant_schema_nodeid(token, schema ? schema->child : start->schema,\n                                                 LYS_CONTAINER | LYS_CHOICE | LYS_CASE | LYS_LEAF, 0, &schema)\n                    || !schema) {\n                result = NULL;\n                break;\n            }\n\n            if (schema->nodetype & (LYS_CHOICE | LYS_CASE)) {\n                continue;\n            }\n        } else {\n            /* final node */\n            if (resolve_descendant_schema_nodeid(token, schema ? schema->child : start->schema, LYS_LEAF, 0, &schema)\n                    || !schema) {\n                result = NULL;\n                break;\n            }\n        }\n        LY_TREE_FOR(result ? result->child : start, iter) {\n            if (iter->schema == schema) {\n                /* move in data tree according to returned schema */\n                result = iter;\n                break;\n            }\n        }\n        if (!iter) {\n            /* instance not found */\n            result = NULL;\n            break;\n        }\n    }\n    free(str);\n\n    return result;\n}\n\nint\nschema_nodeid_siblingcheck(const struct lys_node *sibling, const struct lys_module *cur_module, const char *mod_name,\n                           int mod_name_len, const char *name, int nam_len)\n{\n    const struct lys_module *prefix_mod;\n\n    /* handle special names */\n    if (name[0] == '*') {\n        return 2;\n    } else if (name[0] == '.') {\n        return 3;\n    }\n\n    /* name check */\n    if (strncmp(name, sibling->name, nam_len) || sibling->name[nam_len]) {\n        return 1;\n    }\n\n    /* module check */\n    if (mod_name) {\n        prefix_mod = lyp_get_module(cur_module, NULL, 0, mod_name, mod_name_len, 0);\n        if (!prefix_mod) {\n            return -1;\n        }\n    } else {\n        prefix_mod = cur_module;\n    }\n    if (prefix_mod != lys_node_module(sibling)) {\n        return 1;\n    }\n\n    /* match */\n    return 0;\n}\n\n/* keys do not have to be ordered and do not have to be all of them */\nstatic int\nresolve_extended_schema_nodeid_predicate(const char *nodeid, const struct lys_node *node,\n                                         const struct lys_module *cur_module, int *nodeid_end)\n{\n    int mod_len, nam_len, has_predicate, r, i;\n    const char *model, *name;\n    struct lys_node_list *list;\n\n    if (!(node->nodetype & (LYS_LIST | LYS_LEAFLIST))) {\n        return 1;\n    }\n\n    list = (struct lys_node_list *)node;\n    do {\n        r = parse_schema_json_predicate(nodeid, &model, &mod_len, &name, &nam_len, NULL, NULL, &has_predicate);\n        if (r < 1) {\n            LOGVAL(cur_module->ctx, LYE_PATH_INCHAR, LY_VLOG_NONE, NULL, nodeid[r], &nodeid[r]);\n            return -1;\n        }\n        nodeid += r;\n\n        if (node->nodetype == LYS_LEAFLIST) {\n            /* just check syntax */\n            if (model || !name || (name[0] != '.') || has_predicate) {\n                return 1;\n            }\n            break;\n        } else {\n            /* check the key */\n            for (i = 0; i < list->keys_size; ++i) {\n                if (strncmp(list->keys[i]->name, name, nam_len) || list->keys[i]->name[nam_len]) {\n                    continue;\n                }\n                if (model) {\n                    if (strncmp(lys_node_module((struct lys_node *)list->keys[i])->name, model, mod_len)\n                            || lys_node_module((struct lys_node *)list->keys[i])->name[mod_len]) {\n                        continue;\n                    }\n                } else {\n                    if (lys_node_module((struct lys_node *)list->keys[i]) != cur_module) {\n                        continue;\n                    }\n                }\n\n                /* match */\n                break;\n            }\n\n            if (i == list->keys_size) {\n                return 1;\n            }\n        }\n    } while (has_predicate);\n\n    if (!nodeid[0]) {\n        *nodeid_end = 1;\n    }\n    return 0;\n}\n\n/* start_parent - relative, module - absolute, -1 error (logged), EXIT_SUCCESS ok\n */\nint\nresolve_schema_nodeid(const char *nodeid, const struct lys_node *start_parent, const struct lys_module *cur_module,\n                      struct ly_set **ret, int extended, int no_node_error)\n{\n    const char *name, *mod_name, *id, *backup_mod_name = NULL, *yang_data_name = NULL;\n    const struct lys_node *sibling, *next, *elem;\n    struct lys_node_augment *last_aug;\n    int r, nam_len, mod_name_len = 0, is_relative = -1, all_desc, has_predicate, nodeid_end = 0;\n    int yang_data_name_len, backup_mod_name_len = 0;\n    /* resolved import module from the start module, it must match the next node-name-match sibling */\n    const struct lys_module *start_mod, *aux_mod = NULL;\n    char *str;\n    struct ly_ctx *ctx;\n\n    assert(nodeid && (start_parent || cur_module) && ret);\n    *ret = NULL;\n\n    if (!cur_module) {\n        cur_module = lys_node_module(start_parent);\n    }\n    ctx = cur_module->ctx;\n    id = nodeid;\n\n    r = parse_schema_nodeid(id, &mod_name, &mod_name_len, &name, &nam_len, &is_relative, NULL, NULL, 1);\n    if (r < 1) {\n        LOGVAL(ctx, LYE_PATH_INCHAR, LY_VLOG_NONE, NULL, id[r], &id[r]);\n        return -1;\n    }\n\n    if (name[0] == '#') {\n        if (is_relative) {\n            LOGVAL(ctx, LYE_PATH_INCHAR, LY_VLOG_NONE, NULL, '#', name);\n            return -1;\n        }\n        yang_data_name = name + 1;\n        yang_data_name_len = nam_len - 1;\n        backup_mod_name = mod_name;\n        backup_mod_name_len = mod_name_len;\n        id += r;\n    } else {\n        is_relative = -1;\n    }\n\n    r = parse_schema_nodeid(id, &mod_name, &mod_name_len, &name, &nam_len, &is_relative, &has_predicate,\n                            (extended ? &all_desc : NULL), extended);\n    if (r < 1) {\n        LOGVAL(ctx, LYE_PATH_INCHAR, LY_VLOG_NONE, NULL, id[r], &id[r]);\n        return -1;\n    }\n    id += r;\n\n    if (backup_mod_name) {\n        mod_name = backup_mod_name;\n        mod_name_len = backup_mod_name_len;\n    }\n\n    if (is_relative && !start_parent) {\n        LOGVAL(ctx, LYE_SPEC, LY_VLOG_STR, nodeid, \"Starting node must be provided for relative paths.\");\n        return -1;\n    }\n\n    /* descendant-schema-nodeid */\n    if (is_relative) {\n        cur_module = start_mod = lys_node_module(start_parent);\n\n    /* absolute-schema-nodeid */\n    } else {\n        start_mod = lyp_get_module(cur_module, NULL, 0, mod_name, mod_name_len, 0);\n        if (!start_mod) {\n            str = strndup(mod_name, mod_name_len);\n            LOGVAL(ctx, LYE_PATH_INMOD, LY_VLOG_STR, str);\n            free(str);\n            return -1;\n        }\n        start_parent = NULL;\n        if (yang_data_name) {\n            start_parent = lyp_get_yang_data_template(start_mod, yang_data_name, yang_data_name_len);\n            if (!start_parent) {\n                str = strndup(nodeid, (yang_data_name + yang_data_name_len) - nodeid);\n                LOGVAL(ctx, LYE_PATH_INNODE, LY_VLOG_STR, str);\n                free(str);\n                return -1;\n            }\n        }\n    }\n\n    while (1) {\n        sibling = NULL;\n        last_aug = NULL;\n\n        if (start_parent) {\n            if (mod_name && (strncmp(mod_name, cur_module->name, mod_name_len)\n                    || (mod_name_len != (signed)strlen(cur_module->name)))) {\n                /* we are getting into another module (augment) */\n                aux_mod = lyp_get_module(cur_module, NULL, 0, mod_name, mod_name_len, 0);\n                if (!aux_mod) {\n                    str = strndup(mod_name, mod_name_len);\n                    LOGVAL(ctx, LYE_PATH_INMOD, LY_VLOG_STR, str);\n                    free(str);\n                    return -1;\n                }\n            } else {\n                /* there is no mod_name, so why are we checking augments again?\n                 * because this module may be not implemented and it augments something in another module and\n                 * there is another augment augmenting that previous one */\n                aux_mod = cur_module;\n            }\n\n            /* look into augments */\n            if (!extended) {\nget_next_augment:\n                last_aug = lys_getnext_target_aug(last_aug, aux_mod, start_parent);\n            }\n        }\n\n        while ((sibling = lys_getnext(sibling, (last_aug ? (struct lys_node *)last_aug : start_parent), start_mod,\n                LYS_GETNEXT_WITHCHOICE | LYS_GETNEXT_WITHCASE | LYS_GETNEXT_WITHINOUT | LYS_GETNEXT_PARENTUSES | LYS_GETNEXT_NOSTATECHECK))) {\n            r = schema_nodeid_siblingcheck(sibling, cur_module, mod_name, mod_name_len, name, nam_len);\n\n            /* resolve predicate */\n            if (extended && ((r == 0) || (r == 2) || (r == 3)) && has_predicate) {\n                r = resolve_extended_schema_nodeid_predicate(id, sibling, cur_module, &nodeid_end);\n                if (r == 1) {\n                    continue;\n                } else if (r == -1) {\n                    return -1;\n                }\n            } else if (!id[0]) {\n                nodeid_end = 1;\n            }\n\n            if (r == 0) {\n                /* one matching result */\n                if (nodeid_end) {\n                    *ret = ly_set_new();\n                    LY_CHECK_ERR_RETURN(!*ret, LOGMEM(ctx), -1);\n                    ly_set_add(*ret, (void *)sibling, LY_SET_OPT_USEASLIST);\n                } else {\n                    if (sibling->nodetype & (LYS_LEAF | LYS_LEAFLIST | LYS_ANYDATA)) {\n                        return -1;\n                    }\n                    start_parent = sibling;\n                }\n                break;\n            } else if (r == 1) {\n                continue;\n            } else if (r == 2) {\n                /* \"*\" */\n                if (!*ret) {\n                    *ret = ly_set_new();\n                    LY_CHECK_ERR_RETURN(!*ret, LOGMEM(ctx), -1);\n                }\n                ly_set_add(*ret, (void *)sibling, LY_SET_OPT_USEASLIST);\n                if (all_desc) {\n                    LY_TREE_DFS_BEGIN(sibling, next, elem) {\n                        if (elem != sibling) {\n                            ly_set_add(*ret, (void *)elem, LY_SET_OPT_USEASLIST);\n                        }\n\n                        LY_TREE_DFS_END(sibling, next, elem);\n                    }\n                }\n            } else if (r == 3) {\n                /* \".\" */\n                if (!*ret) {\n                    *ret = ly_set_new();\n                    LY_CHECK_ERR_RETURN(!*ret, LOGMEM(ctx), -1);\n                    ly_set_add(*ret, (void *)start_parent, LY_SET_OPT_USEASLIST);\n                }\n                ly_set_add(*ret, (void *)sibling, LY_SET_OPT_USEASLIST);\n                if (all_desc) {\n                    LY_TREE_DFS_BEGIN(sibling, next, elem) {\n                        if (elem != sibling) {\n                            ly_set_add(*ret, (void *)elem, LY_SET_OPT_USEASLIST);\n                        }\n\n                        LY_TREE_DFS_END(sibling, next, elem);\n                    }\n                }\n            } else {\n                LOGINT(ctx);\n                return -1;\n            }\n        }\n\n        /* skip predicate */\n        if (extended && has_predicate) {\n            while (id[0] == '[') {\n                id = strchr(id, ']');\n                if (!id) {\n                    LOGINT(ctx);\n                    return -1;\n                }\n                ++id;\n            }\n        }\n\n        if (nodeid_end && ((r == 0) || (r == 2) || (r == 3))) {\n            return EXIT_SUCCESS;\n        }\n\n        /* no match */\n        if (!sibling) {\n            if (last_aug) {\n                /* it still could be in another augment */\n                goto get_next_augment;\n            }\n            if (no_node_error) {\n                str = strndup(nodeid, (name - nodeid) + nam_len);\n                LOGVAL(ctx, LYE_PATH_INNODE, LY_VLOG_STR, str);\n                free(str);\n                return -1;\n            }\n            *ret = NULL;\n            return EXIT_SUCCESS;\n        }\n\n        r = parse_schema_nodeid(id, &mod_name, &mod_name_len, &name, &nam_len, &is_relative, &has_predicate,\n                                (extended ? &all_desc : NULL), extended);\n        if (r < 1) {\n            LOGVAL(ctx, LYE_PATH_INCHAR, LY_VLOG_NONE, NULL, id[r], &id[r]);\n            return -1;\n        }\n        id += r;\n    }\n\n    /* cannot get here */\n    LOGINT(ctx);\n    return -1;\n}\n\n/* unique, refine,\n * >0  - unexpected char on position (ret - 1),\n *  0  - ok (but ret can still be NULL),\n * -1  - error,\n * -2  - violated no_innerlist  */\nint\nresolve_descendant_schema_nodeid(const char *nodeid, const struct lys_node *start, int ret_nodetype,\n                                 int no_innerlist, const struct lys_node **ret)\n{\n    const char *name, *mod_name, *id;\n    const struct lys_node *sibling, *start_parent;\n    int r, nam_len, mod_name_len, is_relative = -1;\n    /* resolved import module from the start module, it must match the next node-name-match sibling */\n    const struct lys_module *module;\n\n    assert(nodeid && ret);\n    assert(!(ret_nodetype & (LYS_USES | LYS_AUGMENT | LYS_GROUPING)));\n\n    if (!start) {\n        /* leaf not found */\n        return 0;\n    }\n\n    id = nodeid;\n    module = lys_node_module(start);\n\n    if ((r = parse_schema_nodeid(id, &mod_name, &mod_name_len, &name, &nam_len, &is_relative, NULL, NULL, 0)) < 1) {\n        return ((id - nodeid) - r) + 1;\n    }\n    id += r;\n\n    if (!is_relative) {\n        return -1;\n    }\n\n    start_parent = lys_parent(start);\n    while ((start_parent->nodetype == LYS_USES) && lys_parent(start_parent)) {\n        start_parent = lys_parent(start_parent);\n    }\n\n    while (1) {\n        sibling = NULL;\n        while ((sibling = lys_getnext(sibling, start_parent, module,\n                LYS_GETNEXT_WITHCHOICE | LYS_GETNEXT_WITHCASE | LYS_GETNEXT_PARENTUSES | LYS_GETNEXT_NOSTATECHECK))) {\n            r = schema_nodeid_siblingcheck(sibling, module, mod_name, mod_name_len, name, nam_len);\n            if (r == 0) {\n                if (!id[0]) {\n                    if (!(sibling->nodetype & ret_nodetype)) {\n                        /* wrong node type, too bad */\n                        continue;\n                    }\n                    *ret = sibling;\n                    return EXIT_SUCCESS;\n                }\n                start_parent = sibling;\n                break;\n            } else if (r == 1) {\n                continue;\n            } else {\n                return -1;\n            }\n        }\n\n        /* no match */\n        if (!sibling) {\n            *ret = NULL;\n            return EXIT_SUCCESS;\n        } else if (no_innerlist && sibling->nodetype == LYS_LIST) {\n            *ret = NULL;\n            return -2;\n        }\n\n        if ((r = parse_schema_nodeid(id, &mod_name, &mod_name_len, &name, &nam_len, &is_relative, NULL, NULL, 0)) < 1) {\n            return ((id - nodeid) - r) + 1;\n        }\n        id += r;\n    }\n\n    /* cannot get here */\n    LOGINT(module->ctx);\n    return -1;\n}\n\n/* choice default */\nint\nresolve_choice_default_schema_nodeid(const char *nodeid, const struct lys_node *start, const struct lys_node **ret)\n{\n    /* cannot actually be a path */\n    if (strchr(nodeid, '/')) {\n        return -1;\n    }\n\n    return resolve_descendant_schema_nodeid(nodeid, start, LYS_NO_RPC_NOTIF_NODE, 0, ret);\n}\n\n/* uses, -1 error, EXIT_SUCCESS ok (but ret can still be NULL), >0 unexpected char on ret - 1 */\nstatic int\nresolve_uses_schema_nodeid(const char *nodeid, const struct lys_node *start, const struct lys_node_grp **ret)\n{\n    const struct lys_module *module;\n    const char *mod_prefix, *name;\n    int i, mod_prefix_len, nam_len;\n\n    /* parse the identifier, it must be parsed on one call */\n    if (((i = parse_node_identifier(nodeid, &mod_prefix, &mod_prefix_len, &name, &nam_len, NULL, 0)) < 1) || nodeid[i]) {\n        return -i + 1;\n    }\n\n    module = lyp_get_module(start->module, mod_prefix, mod_prefix_len, NULL, 0, 0);\n    if (!module) {\n        return -1;\n    }\n    if (module != lys_main_module(start->module)) {\n        start = module->data;\n    }\n\n    *ret = lys_find_grouping_up(name, (struct lys_node *)start);\n\n    return EXIT_SUCCESS;\n}\n\nint\nresolve_absolute_schema_nodeid(const char *nodeid, const struct lys_module *module, int ret_nodetype,\n                               const struct lys_node **ret)\n{\n    const char *name, *mod_name, *id;\n    const struct lys_node *sibling, *start_parent;\n    int r, nam_len, mod_name_len, is_relative = -1;\n    const struct lys_module *abs_start_mod;\n\n    assert(nodeid && module && ret);\n    assert(!(ret_nodetype & (LYS_USES | LYS_AUGMENT)) && ((ret_nodetype == LYS_GROUPING) || !(ret_nodetype & LYS_GROUPING)));\n\n    id = nodeid;\n    start_parent = NULL;\n\n    if ((r = parse_schema_nodeid(id, &mod_name, &mod_name_len, &name, &nam_len, &is_relative, NULL, NULL, 0)) < 1) {\n        return ((id - nodeid) - r) + 1;\n    }\n    id += r;\n\n    if (is_relative) {\n        return -1;\n    }\n\n    abs_start_mod = lyp_get_module(module, NULL, 0, mod_name, mod_name_len, 0);\n    if (!abs_start_mod) {\n        return -1;\n    }\n\n    while (1) {\n        sibling = NULL;\n        while ((sibling = lys_getnext(sibling, start_parent, abs_start_mod, LYS_GETNEXT_WITHCHOICE\n                | LYS_GETNEXT_WITHCASE | LYS_GETNEXT_WITHINOUT | LYS_GETNEXT_WITHGROUPING | LYS_GETNEXT_NOSTATECHECK))) {\n            r = schema_nodeid_siblingcheck(sibling, module, mod_name, mod_name_len, name, nam_len);\n            if (r == 0) {\n                if (!id[0]) {\n                    if (!(sibling->nodetype & ret_nodetype)) {\n                        /* wrong node type, too bad */\n                        continue;\n                    }\n                    *ret = sibling;\n                    return EXIT_SUCCESS;\n                }\n                start_parent = sibling;\n                break;\n            } else if (r == 1) {\n                continue;\n            } else {\n                return -1;\n            }\n        }\n\n        /* no match */\n        if (!sibling) {\n            *ret = NULL;\n            return EXIT_SUCCESS;\n        }\n\n        if ((r = parse_schema_nodeid(id, &mod_name, &mod_name_len, &name, &nam_len, &is_relative, NULL, NULL, 0)) < 1) {\n            return ((id - nodeid) - r) + 1;\n        }\n        id += r;\n    }\n\n    /* cannot get here */\n    LOGINT(module->ctx);\n    return -1;\n}\n\nstatic int\nresolve_json_schema_list_predicate(const char *predicate, const struct lys_node_list *list, int *parsed)\n{\n    const char *mod_name, *name;\n    int mod_name_len, nam_len, has_predicate, i;\n    struct lys_node *key;\n\n    if (((i = parse_schema_json_predicate(predicate, &mod_name, &mod_name_len, &name, &nam_len, NULL, NULL, &has_predicate)) < 1)\n            || !strncmp(name, \".\", nam_len)) {\n        LOGVAL(list->module->ctx, LYE_PATH_INCHAR, LY_VLOG_NONE, NULL, predicate[-i], &predicate[-i]);\n        return -1;\n    }\n\n    predicate += i;\n    *parsed += i;\n\n    if (!isdigit(name[0])) {\n        for (i = 0; i < list->keys_size; ++i) {\n            key = (struct lys_node *)list->keys[i];\n            if (!strncmp(key->name, name, nam_len) && !key->name[nam_len]) {\n                break;\n            }\n        }\n\n        if (i == list->keys_size) {\n            LOGVAL(list->module->ctx, LYE_PATH_INKEY, LY_VLOG_NONE, NULL, name);\n            return -1;\n        }\n    }\n\n    /* more predicates? */\n    if (has_predicate) {\n        return resolve_json_schema_list_predicate(predicate, list, parsed);\n    }\n\n    return 0;\n}\n\n/* cannot return LYS_GROUPING, LYS_AUGMENT, LYS_USES, logs directly */\nconst struct lys_node *\nresolve_json_nodeid(const char *nodeid, struct ly_ctx *ctx, const struct lys_node *start, int output)\n{\n    char *str;\n    const char *name, *mod_name, *id, *backup_mod_name = NULL, *yang_data_name = NULL;\n    const struct lys_node *sibling, *start_parent, *parent;\n    int r, nam_len, mod_name_len, is_relative = -1, has_predicate;\n    int yang_data_name_len, backup_mod_name_len;\n    /* resolved import module from the start module, it must match the next node-name-match sibling */\n    const struct lys_module *prefix_mod, *module, *prev_mod;\n\n    assert(nodeid && (ctx || start));\n    if (!ctx) {\n        ctx = start->module->ctx;\n    }\n\n    id = nodeid;\n\n    if ((r = parse_schema_nodeid(id, &mod_name, &mod_name_len, &name, &nam_len, &is_relative, NULL, NULL, 1)) < 1) {\n        LOGVAL(ctx, LYE_PATH_INCHAR, LY_VLOG_NONE, NULL, id[-r], &id[-r]);\n        return NULL;\n    }\n\n    if (name[0] == '#') {\n        if (is_relative) {\n            LOGVAL(ctx, LYE_PATH_INCHAR, LY_VLOG_NONE, NULL, '#', name);\n            return NULL;\n        }\n        yang_data_name = name + 1;\n        yang_data_name_len = nam_len - 1;\n        backup_mod_name = mod_name;\n        backup_mod_name_len = mod_name_len;\n        id += r;\n    } else {\n        is_relative = -1;\n    }\n\n    if ((r = parse_schema_nodeid(id, &mod_name, &mod_name_len, &name, &nam_len, &is_relative, &has_predicate, NULL, 0)) < 1) {\n        LOGVAL(ctx, LYE_PATH_INCHAR, LY_VLOG_NONE, NULL, id[-r], &id[-r]);\n        return NULL;\n    }\n    id += r;\n\n    if (backup_mod_name) {\n        mod_name = backup_mod_name;\n        mod_name_len = backup_mod_name_len;\n    }\n\n    if (is_relative) {\n        assert(start);\n        start_parent = start;\n        while (start_parent && (start_parent->nodetype == LYS_USES)) {\n            start_parent = lys_parent(start_parent);\n        }\n        module = start->module;\n    } else {\n        if (!mod_name) {\n            str = strndup(nodeid, (name + nam_len) - nodeid);\n            LOGVAL(ctx, LYE_PATH_MISSMOD, LY_VLOG_STR, nodeid);\n            free(str);\n            return NULL;\n        }\n\n        str = strndup(mod_name, mod_name_len);\n        module = ly_ctx_get_module(ctx, str, NULL, 1);\n        free(str);\n\n        if (!module) {\n            str = strndup(nodeid, (mod_name + mod_name_len) - nodeid);\n            LOGVAL(ctx, LYE_PATH_INMOD, LY_VLOG_STR, str);\n            free(str);\n            return NULL;\n        }\n        start_parent = NULL;\n        if (yang_data_name) {\n            start_parent = lyp_get_yang_data_template(module, yang_data_name, yang_data_name_len);\n            if (!start_parent) {\n                str = strndup(nodeid, (yang_data_name + yang_data_name_len) - nodeid);\n                LOGVAL(ctx, LYE_PATH_INNODE, LY_VLOG_STR, str);\n                free(str);\n                return NULL;\n            }\n        }\n\n        /* now it's as if there was no module name */\n        mod_name = NULL;\n        mod_name_len = 0;\n    }\n\n    prev_mod = module;\n\n    while (1) {\n        sibling = NULL;\n        while ((sibling = lys_getnext(sibling, start_parent, module, 0))) {\n            /* name match */\n            if (sibling->name && !strncmp(name, sibling->name, nam_len) && !sibling->name[nam_len]) {\n                /* output check */\n                for (parent = lys_parent(sibling); parent && !(parent->nodetype & (LYS_INPUT | LYS_OUTPUT)); parent = lys_parent(parent));\n                if (parent) {\n                    if (output && (parent->nodetype == LYS_INPUT)) {\n                        continue;\n                    } else if (!output && (parent->nodetype == LYS_OUTPUT)) {\n                        continue;\n                    }\n                }\n\n                /* module check */\n                if (mod_name) {\n                    /* will also find an augment module */\n                    prefix_mod = ly_ctx_nget_module(ctx, mod_name, mod_name_len, NULL, 1);\n\n                    if (!prefix_mod) {\n                        str = strndup(nodeid, (mod_name + mod_name_len) - nodeid);\n                        LOGVAL(ctx, LYE_PATH_INMOD, LY_VLOG_STR, str);\n                        free(str);\n                        return NULL;\n                    }\n                } else {\n                    prefix_mod = prev_mod;\n                }\n                if (prefix_mod != lys_node_module(sibling)) {\n                    continue;\n                }\n\n                /* do we have some predicates on it? */\n                if (has_predicate) {\n                    r = 0;\n                    if (sibling->nodetype & (LYS_LEAF | LYS_LEAFLIST)) {\n                        if ((r = parse_schema_json_predicate(id, NULL, NULL, NULL, NULL, NULL, NULL, &has_predicate)) < 1) {\n                            LOGVAL(ctx, LYE_PATH_INCHAR, LY_VLOG_NONE, NULL, id[-r], &id[-r]);\n                            return NULL;\n                        }\n                    } else if (sibling->nodetype == LYS_LIST) {\n                        if (resolve_json_schema_list_predicate(id, (const struct lys_node_list *)sibling, &r)) {\n                            return NULL;\n                        }\n                    } else {\n                        LOGVAL(ctx, LYE_PATH_INCHAR, LY_VLOG_NONE, NULL, id[0], id);\n                        return NULL;\n                    }\n                    id += r;\n                }\n\n                /* the result node? */\n                if (!id[0]) {\n                    return sibling;\n                }\n\n                /* move down the tree, if possible */\n                if (sibling->nodetype & (LYS_LEAF | LYS_LEAFLIST | LYS_ANYDATA)) {\n                    LOGVAL(ctx, LYE_PATH_INCHAR, LY_VLOG_NONE, NULL, id[0], id);\n                    return NULL;\n                }\n                start_parent = sibling;\n\n                /* update prev mod */\n                prev_mod = (start_parent->child ? lys_node_module(start_parent->child) : module);\n                break;\n            }\n        }\n\n        /* no match */\n        if (!sibling) {\n            str = strndup(nodeid, (name + nam_len) - nodeid);\n            LOGVAL(ctx, LYE_PATH_INNODE, LY_VLOG_STR, str);\n            free(str);\n            return NULL;\n        }\n\n        if ((r = parse_schema_nodeid(id, &mod_name, &mod_name_len, &name, &nam_len, &is_relative, &has_predicate, NULL, 0)) < 1) {\n            LOGVAL(ctx, LYE_PATH_INCHAR, LY_VLOG_NONE, NULL, id[-r], &id[-r]);\n            return NULL;\n        }\n        id += r;\n    }\n\n    /* cannot get here */\n    LOGINT(ctx);\n    return NULL;\n}\n\nstatic int\nresolve_partial_json_data_list_predicate(struct parsed_pred pp, struct lyd_node *node, int position)\n{\n    uint16_t i;\n    char *val_str;\n    struct lyd_node_leaf_list *key;\n    struct lys_node_list *slist;\n    struct ly_ctx *ctx;\n\n    assert(node);\n    assert(node->schema->nodetype == LYS_LIST);\n    assert(pp.len);\n\n    ctx = node->schema->module->ctx;\n    slist = (struct lys_node_list *)node->schema;\n\n    /* is the predicate a number? */\n    if (isdigit(pp.pred[0].name[0])) {\n        if (position == atoi(pp.pred[0].name)) {\n            /* match */\n            return 0;\n        } else {\n            /* not a match */\n            return 1;\n        }\n    }\n\n    key = (struct lyd_node_leaf_list *)node->child;\n    if (!key) {\n        /* it is not a position, so we need a key for it to be a match */\n        return 1;\n    }\n\n    /* go through all the keys */\n    for (i = 0; i < slist->keys_size; ++i) {\n        if (strncmp(key->schema->name, pp.pred[i].name, pp.pred[i].nam_len) || key->schema->name[pp.pred[i].nam_len]) {\n            LOGVAL(ctx, LYE_PATH_INKEY, LY_VLOG_NONE, NULL, pp.pred[i].name);\n            return -1;\n        }\n\n        if (pp.pred[i].mod_name) {\n            /* specific module, check that the found key is from that module */\n            if (strncmp(lyd_node_module((struct lyd_node *)key)->name, pp.pred[i].mod_name, pp.pred[i].mod_name_len)\n                    || lyd_node_module((struct lyd_node *)key)->name[pp.pred[i].mod_name_len]) {\n                LOGVAL(ctx, LYE_PATH_INKEY, LY_VLOG_NONE, NULL, pp.pred[i].name);\n                return -1;\n            }\n\n            /* but if the module is the same as the parent, it should have been omitted */\n            if (lyd_node_module((struct lyd_node *)key) == lyd_node_module(node)) {\n                LOGVAL(ctx, LYE_PATH_INKEY, LY_VLOG_NONE, NULL, pp.pred[i].name);\n                return -1;\n            }\n        } else {\n            /* no module, so it must be the same as the list (parent) */\n            if (lyd_node_module((struct lyd_node *)key) != lyd_node_module(node)) {\n                LOGVAL(ctx, LYE_PATH_INKEY, LY_VLOG_NONE, NULL, pp.pred[i].name);\n                return -1;\n            }\n        }\n\n        /* get canonical value */\n        val_str = lyd_make_canonical(key->schema, pp.pred[i].value, pp.pred[i].val_len);\n        if (!val_str) {\n            return -1;\n        }\n\n        /* value does not match */\n        if (strcmp(key->value_str, val_str)) {\n            free(val_str);\n            return 1;\n        }\n        free(val_str);\n\n        key = (struct lyd_node_leaf_list *)key->next;\n    }\n\n    return 0;\n}\n\n/**\n * @brief get the closest parent of the node (or the node itself) identified by the nodeid (path)\n *\n * @param[in] nodeid Node data path to find\n * @param[in] llist_value If the \\p nodeid identifies leaf-list, this is expected value of the leaf-list instance.\n * @param[in] options Bitmask of options flags, see @ref pathoptions.\n * @param[out] parsed Number of characters processed in \\p id\n * @return The closes parent (or the node itself) from the path\n */\nstruct lyd_node *\nresolve_partial_json_data_nodeid(const char *nodeid, const char *llist_value, struct lyd_node *start, int options,\n                                 int *parsed)\n{\n    const char *id, *mod_name, *name, *data_val, *llval;\n    int r, ret, mod_name_len, nam_len, is_relative = -1, list_instance_position;\n    int has_predicate, last_parsed = 0, llval_len;\n    struct lyd_node *sibling, *last_match = NULL;\n    struct lyd_node_leaf_list *llist;\n    const struct lys_module *prev_mod;\n    struct ly_ctx *ctx;\n    const struct lys_node *ssibling, *sparent;\n    struct lys_node_list *slist;\n    struct parsed_pred pp;\n\n    assert(nodeid && start && parsed);\n\n    memset(&pp, 0, sizeof pp);\n    ctx = start->schema->module->ctx;\n    id = nodeid;\n\n    /* parse first nodeid in case it is yang-data extension */\n    if ((r = parse_schema_nodeid(id, &mod_name, &mod_name_len, &name, &nam_len, &is_relative, NULL, NULL, 1)) < 1) {\n        LOGVAL(ctx, LYE_PATH_INCHAR, LY_VLOG_NONE, NULL, id[-r], &id[-r]);\n        goto error;\n    }\n\n    if (name[0] == '#') {\n        if (is_relative) {\n            LOGVAL(ctx, LYE_PATH_INCHAR, LY_VLOG_NONE, NULL, '#', name);\n            goto error;\n        }\n        id += r;\n        last_parsed = r;\n    } else {\n        is_relative = -1;\n    }\n\n    /* parse first nodeid */\n    if ((r = parse_schema_nodeid(id, &mod_name, &mod_name_len, &name, &nam_len, &is_relative, &has_predicate, NULL, 0)) < 1) {\n        LOGVAL(ctx, LYE_PATH_INCHAR, LY_VLOG_NONE, NULL, id[-r], &id[-r]);\n        goto error;\n    }\n    id += r;\n    /* add it to parsed only after the data node was actually found */\n    last_parsed += r;\n\n    if (is_relative) {\n        prev_mod = lyd_node_module(start);\n        start = (start->schema->nodetype & (LYS_CONTAINER | LYS_LIST | LYS_RPC | LYS_ACTION | LYS_NOTIF)) ? start->child : NULL;\n    } else {\n        for (; start->parent; start = start->parent);\n        prev_mod = lyd_node_module(start);\n    }\n    if (!start) {\n        /* there are no siblings to search */\n        return NULL;\n    }\n\n    /* do not duplicate code, use predicate parsing from the loop */\n    goto parse_predicates;\n\n    while (1) {\n        /* find the correct schema node first */\n        ssibling = NULL;\n        sparent = (start && start->parent) ? start->parent->schema : NULL;\n        while ((ssibling = lys_getnext(ssibling, sparent, prev_mod, 0))) {\n            /* skip invalid input/output nodes */\n            if (sparent && (sparent->nodetype & (LYS_RPC | LYS_ACTION))) {\n                if (options & LYD_PATH_OPT_OUTPUT) {\n                    if (lys_parent(ssibling)->nodetype == LYS_INPUT) {\n                        continue;\n                    }\n                } else {\n                    if (lys_parent(ssibling)->nodetype == LYS_OUTPUT) {\n                        continue;\n                    }\n                }\n            }\n\n            if (!schema_nodeid_siblingcheck(ssibling, prev_mod, mod_name, mod_name_len, name, nam_len)) {\n                break;\n            }\n        }\n        if (!ssibling) {\n            /* there is not even such a schema node */\n            free(pp.pred);\n            return last_match;\n        }\n        pp.schema = ssibling;\n\n        /* unify leaf-list value - it is possible to specify last-node value as both a predicate or parameter if\n         * is a leaf-list, unify both cases and the value will in both cases be in the predicate structure */\n        if (!id[0] && !pp.len && (ssibling->nodetype == LYS_LEAFLIST)) {\n            pp.len = 1;\n            pp.pred = calloc(1, sizeof *pp.pred);\n            LY_CHECK_ERR_GOTO(!pp.pred, LOGMEM(ctx), error);\n\n            pp.pred[0].name = \".\";\n            pp.pred[0].nam_len = 1;\n            pp.pred[0].value = (llist_value ? llist_value : \"\");\n            pp.pred[0].val_len = strlen(pp.pred[0].value);\n        }\n\n        if (ssibling->nodetype & (LYS_LEAFLIST | LYS_LEAF)) {\n            /* check leaf/leaf-list predicate */\n            if (pp.len > 1) {\n                LOGVAL(ctx, LYE_PATH_PREDTOOMANY, LY_VLOG_NONE, NULL);\n                goto error;\n            } else if (pp.len) {\n                if ((pp.pred[0].name[0] != '.') || (pp.pred[0].nam_len != 1)) {\n                    LOGVAL(ctx, LYE_PATH_INCHAR, LY_VLOG_NONE, NULL, pp.pred[0].name[0], pp.pred[0].name);\n                    goto error;\n                }\n                if ((((struct lys_node_leaf *)ssibling)->type.base == LY_TYPE_IDENT) && !strnchr(pp.pred[0].value, ':', pp.pred[0].val_len)) {\n                    LOGVAL(ctx, LYE_PATH_INIDENTREF, LY_VLOG_LYS, ssibling, pp.pred[0].val_len, pp.pred[0].value);\n                    goto error;\n                }\n            }\n        } else if (ssibling->nodetype == LYS_LIST) {\n            /* list should have predicates for all the keys or position */\n            slist = (struct lys_node_list *)ssibling;\n            if (!pp.len) {\n                /* none match */\n                return last_match;\n            } else if (!isdigit(pp.pred[0].name[0])) {\n                /* list predicate is not a position, so there must be all the keys */\n                if (pp.len > slist->keys_size) {\n                    LOGVAL(ctx, LYE_PATH_PREDTOOMANY, LY_VLOG_NONE, NULL);\n                    goto error;\n                } else if (pp.len < slist->keys_size) {\n                    LOGVAL(ctx, LYE_PATH_MISSKEY, LY_VLOG_NONE, NULL, slist->keys[pp.len]->name);\n                    goto error;\n                }\n                /* check that all identityrefs have module name, otherwise the hash of the list instance will never match!! */\n                for (r = 0; r < pp.len; ++r) {\n                    if ((slist->keys[r]->type.base == LY_TYPE_IDENT) && !strnchr(pp.pred[r].value, ':', pp.pred[r].val_len)) {\n                        LOGVAL(ctx, LYE_PATH_INIDENTREF, LY_VLOG_LYS, slist->keys[r], pp.pred[r].val_len, pp.pred[r].value);\n                        goto error;\n                    }\n                }\n            }\n        } else if (pp.pred) {\n            /* no other nodes allow predicates */\n            LOGVAL(ctx, LYE_PATH_PREDTOOMANY, LY_VLOG_NONE, NULL);\n            goto error;\n        }\n\n#ifdef LY_ENABLED_CACHE\n        /* we will not be matching keyless lists or state leaf-lists this way */\n        if (start->parent && start->parent->ht && ((pp.schema->nodetype != LYS_LIST) || ((struct lys_node_list *)pp.schema)->keys_size)\n                && ((pp.schema->nodetype != LYS_LEAFLIST) || (pp.schema->flags & LYS_CONFIG_W))) {\n            sibling = resolve_json_data_node_hash(start->parent, pp);\n        } else\n#endif\n        {\n            list_instance_position = 0;\n            LY_TREE_FOR(start, sibling) {\n                /* RPC/action data check, return simply invalid argument, because the data tree is invalid */\n                if (lys_parent(sibling->schema)) {\n                    if (options & LYD_PATH_OPT_OUTPUT) {\n                        if (lys_parent(sibling->schema)->nodetype == LYS_INPUT) {\n                            LOGERR(ctx, LY_EINVAL, \"Provided data tree includes some RPC input nodes (%s).\", sibling->schema->name);\n                            goto error;\n                        }\n                    } else {\n                        if (lys_parent(sibling->schema)->nodetype == LYS_OUTPUT) {\n                            LOGERR(ctx, LY_EINVAL, \"Provided data tree includes some RPC output nodes (%s).\", sibling->schema->name);\n                            goto error;\n                        }\n                    }\n                }\n\n                if (sibling->schema != ssibling) {\n                    /* wrong schema node */\n                    continue;\n                }\n\n                /* leaf-list, did we find it with the correct value or not? */\n                if (ssibling->nodetype == LYS_LEAFLIST) {\n                    if (ssibling->flags & LYS_CONFIG_R) {\n                        /* state leaf-lists will never match */\n                        continue;\n                    }\n\n                    llist = (struct lyd_node_leaf_list *)sibling;\n\n                    /* get the expected leaf-list value */\n                    llval = NULL;\n                    llval_len = 0;\n                    if (pp.pred) {\n                        /* it was already checked that it is correct */\n                        llval = pp.pred[0].value;\n                        llval_len = pp.pred[0].val_len;\n\n                    }\n\n                    /* make value canonical (remove module name prefix) unless it was specified with it */\n                    if (llval && !strchr(llval, ':') && (llist->value_type & LY_TYPE_IDENT)\n                            && !strncmp(llist->value_str, lyd_node_module(sibling)->name, strlen(lyd_node_module(sibling)->name))\n                            && (llist->value_str[strlen(lyd_node_module(sibling)->name)] == ':')) {\n                        data_val = llist->value_str + strlen(lyd_node_module(sibling)->name) + 1;\n                    } else {\n                        data_val = llist->value_str;\n                    }\n\n                    if ((!llval && data_val && data_val[0]) || (llval && (strncmp(llval, data_val, llval_len)\n                            || data_val[llval_len]))) {\n                        continue;\n                    }\n\n                } else if (ssibling->nodetype == LYS_LIST) {\n                    /* list, we likely need predicates'n'stuff then, but if without a predicate, we are always creating it */\n                    ++list_instance_position;\n                    ret = resolve_partial_json_data_list_predicate(pp, sibling, list_instance_position);\n                    if (ret == -1) {\n                        goto error;\n                    } else if (ret == 1) {\n                        /* this list instance does not match */\n                        continue;\n                    }\n                }\n\n                break;\n            }\n        }\n\n        /* no match, return last match */\n        if (!sibling) {\n            free(pp.pred);\n            return last_match;\n        }\n\n        /* we found a next matching node */\n        *parsed += last_parsed;\n        last_match = sibling;\n        prev_mod = lyd_node_module(sibling);\n\n        /* the result node? */\n        if (!id[0]) {\n            free(pp.pred);\n            return last_match;\n        }\n\n        /* move down the tree, if possible, and continue */\n        if (ssibling->nodetype & (LYS_LEAF | LYS_LEAFLIST | LYS_ANYDATA)) {\n            /* there can be no children even through expected, error */\n            LOGVAL(ctx, LYE_PATH_INCHAR, LY_VLOG_NONE, NULL, id[0], id);\n            goto error;\n        } else if (!sibling->child) {\n            /* there could be some children, but are not, return what we found so far */\n            free(pp.pred);\n            return last_match;\n        }\n        start = sibling->child;\n\n        /* parse nodeid */\n        if ((r = parse_schema_nodeid(id, &mod_name, &mod_name_len, &name, &nam_len, &is_relative, &has_predicate, NULL, 0)) < 1) {\n            LOGVAL(ctx, LYE_PATH_INCHAR, LY_VLOG_NONE, NULL, id[-r], &id[-r]);\n            goto error;\n        }\n        id += r;\n        last_parsed = r;\n\nparse_predicates:\n        /* parse all the predicates */\n        free(pp.pred);\n        pp.schema = NULL;\n        pp.len = 0;\n        pp.pred = NULL;\n        while (has_predicate) {\n            ++pp.len;\n            pp.pred = ly_realloc(pp.pred, pp.len * sizeof *pp.pred);\n            LY_CHECK_ERR_GOTO(!pp.pred, LOGMEM(ctx), error);\n            if ((r = parse_schema_json_predicate(id, &pp.pred[pp.len - 1].mod_name, &pp.pred[pp.len - 1].mod_name_len,\n                                                 &pp.pred[pp.len - 1].name, &pp.pred[pp.len - 1].nam_len, &pp.pred[pp.len - 1].value,\n                                                 &pp.pred[pp.len - 1].val_len, &has_predicate)) < 1) {\n                LOGVAL(ctx, LYE_PATH_INCHAR, LY_VLOG_NONE, NULL, id[0], id);\n                goto error;\n            }\n\n            id += r;\n            last_parsed += r;\n        }\n    }\n\nerror:\n    *parsed = -1;\n    free(pp.pred);\n    return NULL;\n}\n\n/**\n * @brief Resolves length or range intervals. Does not log.\n * Syntax is assumed to be correct, *ret MUST be NULL.\n *\n * @param[in] ctx Context for errors.\n * @param[in] str_restr Restriction as a string.\n * @param[in] type Type of the restriction.\n * @param[out] ret Final interval structure that starts with\n * the interval of the initial type, continues with intervals\n * of any superior types derived from the initial one, and\n * finishes with intervals from our \\p type.\n *\n * @return EXIT_SUCCESS on succes, -1 on error.\n */\nint\nresolve_len_ran_interval(struct ly_ctx *ctx, const char *str_restr, struct lys_type *type, struct len_ran_intv **ret)\n{\n    /* 0 - unsigned, 1 - signed, 2 - floating point */\n    int kind;\n    int64_t local_smin = 0, local_smax = 0, local_fmin, local_fmax;\n    uint64_t local_umin, local_umax = 0;\n    uint8_t local_fdig = 0;\n    const char *seg_ptr, *ptr;\n    struct len_ran_intv *local_intv = NULL, *tmp_local_intv = NULL, *tmp_intv, *intv = NULL;\n\n    switch (type->base) {\n    case LY_TYPE_BINARY:\n        kind = 0;\n        local_umin = 0;\n        local_umax = 18446744073709551615UL;\n\n        if (!str_restr && type->info.binary.length) {\n            str_restr = type->info.binary.length->expr;\n        }\n        break;\n    case LY_TYPE_DEC64:\n        kind = 2;\n        local_fmin = __INT64_C(-9223372036854775807) - __INT64_C(1);\n        local_fmax = __INT64_C(9223372036854775807);\n        local_fdig = type->info.dec64.dig;\n\n        if (!str_restr && type->info.dec64.range) {\n            str_restr = type->info.dec64.range->expr;\n        }\n        break;\n    case LY_TYPE_INT8:\n        kind = 1;\n        local_smin = __INT64_C(-128);\n        local_smax = __INT64_C(127);\n\n        if (!str_restr && type->info.num.range) {\n            str_restr = type->info.num.range->expr;\n        }\n        break;\n    case LY_TYPE_INT16:\n        kind = 1;\n        local_smin = __INT64_C(-32768);\n        local_smax = __INT64_C(32767);\n\n        if (!str_restr && type->info.num.range) {\n            str_restr = type->info.num.range->expr;\n        }\n        break;\n    case LY_TYPE_INT32:\n        kind = 1;\n        local_smin = __INT64_C(-2147483648);\n        local_smax = __INT64_C(2147483647);\n\n        if (!str_restr && type->info.num.range) {\n            str_restr = type->info.num.range->expr;\n        }\n        break;\n    case LY_TYPE_INT64:\n        kind = 1;\n        local_smin = __INT64_C(-9223372036854775807) - __INT64_C(1);\n        local_smax = __INT64_C(9223372036854775807);\n\n        if (!str_restr && type->info.num.range) {\n            str_restr = type->info.num.range->expr;\n        }\n        break;\n    case LY_TYPE_UINT8:\n        kind = 0;\n        local_umin = __UINT64_C(0);\n        local_umax = __UINT64_C(255);\n\n        if (!str_restr && type->info.num.range) {\n            str_restr = type->info.num.range->expr;\n        }\n        break;\n    case LY_TYPE_UINT16:\n        kind = 0;\n        local_umin = __UINT64_C(0);\n        local_umax = __UINT64_C(65535);\n\n        if (!str_restr && type->info.num.range) {\n            str_restr = type->info.num.range->expr;\n        }\n        break;\n    case LY_TYPE_UINT32:\n        kind = 0;\n        local_umin = __UINT64_C(0);\n        local_umax = __UINT64_C(4294967295);\n\n        if (!str_restr && type->info.num.range) {\n            str_restr = type->info.num.range->expr;\n        }\n        break;\n    case LY_TYPE_UINT64:\n        kind = 0;\n        local_umin = __UINT64_C(0);\n        local_umax = __UINT64_C(18446744073709551615);\n\n        if (!str_restr && type->info.num.range) {\n            str_restr = type->info.num.range->expr;\n        }\n        break;\n    case LY_TYPE_STRING:\n        kind = 0;\n        local_umin = __UINT64_C(0);\n        local_umax = __UINT64_C(18446744073709551615);\n\n        if (!str_restr && type->info.str.length) {\n            str_restr = type->info.str.length->expr;\n        }\n        break;\n    default:\n        return -1;\n    }\n\n    /* process superior types */\n    if (type->der) {\n        if (resolve_len_ran_interval(ctx, NULL, &type->der->type, &intv)) {\n            return -1;\n        }\n        assert(!intv || (intv->kind == kind));\n    }\n\n    if (!str_restr) {\n        /* we do not have any restriction, return superior ones */\n        *ret = intv;\n        return EXIT_SUCCESS;\n    }\n\n    /* adjust local min and max */\n    if (intv) {\n        tmp_intv = intv;\n\n        if (kind == 0) {\n            local_umin = tmp_intv->value.uval.min;\n        } else if (kind == 1) {\n            local_smin = tmp_intv->value.sval.min;\n        } else if (kind == 2) {\n            local_fmin = tmp_intv->value.fval.min;\n        }\n\n        while (tmp_intv->next) {\n            tmp_intv = tmp_intv->next;\n        }\n\n        if (kind == 0) {\n            local_umax = tmp_intv->value.uval.max;\n        } else if (kind == 1) {\n            local_smax = tmp_intv->value.sval.max;\n        } else if (kind == 2) {\n            local_fmax = tmp_intv->value.fval.max;\n        }\n    }\n\n    /* finally parse our restriction */\n    seg_ptr = str_restr;\n    tmp_intv = NULL;\n    while (1) {\n        if (!tmp_local_intv) {\n            assert(!local_intv);\n            local_intv = malloc(sizeof *local_intv);\n            tmp_local_intv = local_intv;\n        } else {\n            tmp_local_intv->next = malloc(sizeof *tmp_local_intv);\n            tmp_local_intv = tmp_local_intv->next;\n        }\n        LY_CHECK_ERR_GOTO(!tmp_local_intv, LOGMEM(ctx), error);\n\n        tmp_local_intv->kind = kind;\n        tmp_local_intv->type = type;\n        tmp_local_intv->next = NULL;\n\n        /* min */\n        ptr = seg_ptr;\n        while (isspace(ptr[0])) {\n            ++ptr;\n        }\n        if (isdigit(ptr[0]) || (ptr[0] == '+') || (ptr[0] == '-')) {\n            if (kind == 0) {\n                tmp_local_intv->value.uval.min = strtoull(ptr, (char **)&ptr, 10);\n            } else if (kind == 1) {\n                tmp_local_intv->value.sval.min = strtoll(ptr, (char **)&ptr, 10);\n            } else if (kind == 2) {\n                if (parse_range_dec64(&ptr, local_fdig, &tmp_local_intv->value.fval.min)) {\n                    LOGVAL(ctx, LYE_INARG, LY_VLOG_NONE, NULL, ptr, \"range\");\n                    goto error;\n                }\n            }\n        } else if (!strncmp(ptr, \"min\", 3)) {\n            if (kind == 0) {\n                tmp_local_intv->value.uval.min = local_umin;\n            } else if (kind == 1) {\n                tmp_local_intv->value.sval.min = local_smin;\n            } else if (kind == 2) {\n                tmp_local_intv->value.fval.min = local_fmin;\n            }\n\n            ptr += 3;\n        } else if (!strncmp(ptr, \"max\", 3)) {\n            if (kind == 0) {\n                tmp_local_intv->value.uval.min = local_umax;\n            } else if (kind == 1) {\n                tmp_local_intv->value.sval.min = local_smax;\n            } else if (kind == 2) {\n                tmp_local_intv->value.fval.min = local_fmax;\n            }\n\n            ptr += 3;\n        } else {\n            goto error;\n        }\n\n        while (isspace(ptr[0])) {\n            ptr++;\n        }\n\n        /* no interval or interval */\n        if ((ptr[0] == '|') || !ptr[0]) {\n            if (kind == 0) {\n                tmp_local_intv->value.uval.max = tmp_local_intv->value.uval.min;\n            } else if (kind == 1) {\n                tmp_local_intv->value.sval.max = tmp_local_intv->value.sval.min;\n            } else if (kind == 2) {\n                tmp_local_intv->value.fval.max = tmp_local_intv->value.fval.min;\n            }\n        } else if (!strncmp(ptr, \"..\", 2)) {\n            /* skip \"..\" */\n            ptr += 2;\n            while (isspace(ptr[0])) {\n                ++ptr;\n            }\n\n            /* max */\n            if (isdigit(ptr[0]) || (ptr[0] == '+') || (ptr[0] == '-')) {\n                if (kind == 0) {\n                    tmp_local_intv->value.uval.max = strtoull(ptr, (char **)&ptr, 10);\n                } else if (kind == 1) {\n                    tmp_local_intv->value.sval.max = strtoll(ptr, (char **)&ptr, 10);\n                } else if (kind == 2) {\n                    if (parse_range_dec64(&ptr, local_fdig, &tmp_local_intv->value.fval.max)) {\n                        LOGVAL(ctx, LYE_INARG, LY_VLOG_NONE, NULL, ptr, \"range\");\n                        goto error;\n                    }\n                }\n            } else if (!strncmp(ptr, \"max\", 3)) {\n                if (kind == 0) {\n                    tmp_local_intv->value.uval.max = local_umax;\n                } else if (kind == 1) {\n                    tmp_local_intv->value.sval.max = local_smax;\n                } else if (kind == 2) {\n                    tmp_local_intv->value.fval.max = local_fmax;\n                }\n            } else {\n                goto error;\n            }\n        } else {\n            goto error;\n        }\n\n        /* check min and max in correct order */\n        if (kind == 0) {\n            /* current segment */\n            if (tmp_local_intv->value.uval.min > tmp_local_intv->value.uval.max) {\n                goto error;\n            }\n            if (tmp_local_intv->value.uval.min < local_umin || tmp_local_intv->value.uval.max > local_umax) {\n                goto error;\n            }\n            /* segments sholud be ascending order */\n            if (tmp_intv && (tmp_intv->value.uval.max >= tmp_local_intv->value.uval.min)) {\n                goto error;\n            }\n        } else if (kind == 1) {\n            if (tmp_local_intv->value.sval.min > tmp_local_intv->value.sval.max) {\n                goto error;\n            }\n            if (tmp_local_intv->value.sval.min < local_smin || tmp_local_intv->value.sval.max > local_smax) {\n                goto error;\n            }\n            if (tmp_intv && (tmp_intv->value.sval.max >= tmp_local_intv->value.sval.min)) {\n                goto error;\n            }\n        } else if (kind == 2) {\n            if (tmp_local_intv->value.fval.min > tmp_local_intv->value.fval.max) {\n                goto error;\n            }\n            if (tmp_local_intv->value.fval.min < local_fmin || tmp_local_intv->value.fval.max > local_fmax) {\n                goto error;\n            }\n            if (tmp_intv && (tmp_intv->value.fval.max >= tmp_local_intv->value.fval.min)) {\n                /* fraction-digits value is always the same (it cannot be changed in derived types) */\n                goto error;\n            }\n        }\n\n        /* next segment (next OR) */\n        seg_ptr = strchr(seg_ptr, '|');\n        if (!seg_ptr) {\n            break;\n        }\n        seg_ptr++;\n        tmp_intv = tmp_local_intv;\n    }\n\n    /* check local restrictions against superior ones */\n    if (intv) {\n        tmp_intv = intv;\n        tmp_local_intv = local_intv;\n\n        while (tmp_local_intv && tmp_intv) {\n            /* reuse local variables */\n            if (kind == 0) {\n                local_umin = tmp_local_intv->value.uval.min;\n                local_umax = tmp_local_intv->value.uval.max;\n\n                /* it must be in this interval */\n                if ((local_umin >= tmp_intv->value.uval.min) && (local_umin <= tmp_intv->value.uval.max)) {\n                    /* this interval is covered, next one */\n                    if (local_umax <= tmp_intv->value.uval.max) {\n                        tmp_local_intv = tmp_local_intv->next;\n                        continue;\n                    /* ascending order of restrictions -> fail */\n                    } else {\n                        goto error;\n                    }\n                }\n            } else if (kind == 1) {\n                local_smin = tmp_local_intv->value.sval.min;\n                local_smax = tmp_local_intv->value.sval.max;\n\n                if ((local_smin >= tmp_intv->value.sval.min) && (local_smin <= tmp_intv->value.sval.max)) {\n                    if (local_smax <= tmp_intv->value.sval.max) {\n                        tmp_local_intv = tmp_local_intv->next;\n                        continue;\n                    } else {\n                        goto error;\n                    }\n                }\n            } else if (kind == 2) {\n                local_fmin = tmp_local_intv->value.fval.min;\n                local_fmax = tmp_local_intv->value.fval.max;\n\n                 if ((dec64cmp(local_fmin, local_fdig, tmp_intv->value.fval.min, local_fdig) > -1)\n                        && (dec64cmp(local_fmin, local_fdig, tmp_intv->value.fval.max, local_fdig) < 1)) {\n                    if (dec64cmp(local_fmax, local_fdig, tmp_intv->value.fval.max, local_fdig) < 1) {\n                        tmp_local_intv = tmp_local_intv->next;\n                        continue;\n                    } else {\n                        goto error;\n                    }\n                }\n            }\n\n            tmp_intv = tmp_intv->next;\n        }\n\n        /* some interval left uncovered -> fail */\n        if (tmp_local_intv) {\n            goto error;\n        }\n    }\n\n    /* append the local intervals to all the intervals of the superior types, return it all */\n    if (intv) {\n        for (tmp_intv = intv; tmp_intv->next; tmp_intv = tmp_intv->next);\n        tmp_intv->next = local_intv;\n    } else {\n        intv = local_intv;\n    }\n    *ret = intv;\n\n    return EXIT_SUCCESS;\n\nerror:\n    while (intv) {\n        tmp_intv = intv->next;\n        free(intv);\n        intv = tmp_intv;\n    }\n    while (local_intv) {\n        tmp_local_intv = local_intv->next;\n        free(local_intv);\n        local_intv = tmp_local_intv;\n    }\n\n    return -1;\n}\n\nstatic int\nresolve_superior_type_check(struct lys_type *type)\n{\n    uint32_t i;\n\n    if (type->base == LY_TYPE_DER) {\n        /* check that the referenced typedef is resolved */\n        return EXIT_FAILURE;\n    } else if (type->base == LY_TYPE_UNION) {\n        /* check that all union types are resolved */\n        for (i = 0; i < type->info.uni.count; ++i) {\n            if (resolve_superior_type_check(&type->info.uni.types[i])) {\n                return EXIT_FAILURE;\n            }\n        }\n    } else if (type->base == LY_TYPE_LEAFREF) {\n        /* check there is path in some derived type */\n        while (!type->info.lref.path) {\n            assert(type->der);\n            type = &type->der->type;\n        }\n    }\n\n    return EXIT_SUCCESS;\n}\n\n/**\n * @brief Resolve a typedef, return only resolved typedefs if derived. If leafref, it must be\n * resolved for this function to return it. Does not log.\n *\n * @param[in] name Typedef name.\n * @param[in] mod_name Typedef name module name.\n * @param[in] module Main module.\n * @param[in] parent Parent of the resolved type definition.\n * @param[out] ret Pointer to the resolved typedef. Can be NULL.\n *\n * @return EXIT_SUCCESS on success, EXIT_FAILURE on forward reference, -1 on error.\n */\nint\nresolve_superior_type(const char *name, const char *mod_name, const struct lys_module *module,\n                      const struct lys_node *parent, struct lys_tpdf **ret)\n{\n    int i, j;\n    struct lys_tpdf *tpdf, *match;\n    int tpdf_size;\n\n    if (!mod_name) {\n        /* no prefix, try built-in types */\n        for (i = 1; i < LY_DATA_TYPE_COUNT; i++) {\n            if (!strcmp(ly_types[i]->name, name)) {\n                if (ret) {\n                    *ret = ly_types[i];\n                }\n                return EXIT_SUCCESS;\n            }\n        }\n    } else {\n        if (!strcmp(mod_name, module->name)) {\n            /* prefix refers to the current module, ignore it */\n            mod_name = NULL;\n        }\n    }\n\n    if (!mod_name && parent) {\n        /* search in local typedefs */\n        while (parent) {\n            switch (parent->nodetype) {\n            case LYS_CONTAINER:\n                tpdf_size = ((struct lys_node_container *)parent)->tpdf_size;\n                tpdf = ((struct lys_node_container *)parent)->tpdf;\n                break;\n\n            case LYS_LIST:\n                tpdf_size = ((struct lys_node_list *)parent)->tpdf_size;\n                tpdf = ((struct lys_node_list *)parent)->tpdf;\n                break;\n\n            case LYS_GROUPING:\n                tpdf_size = ((struct lys_node_grp *)parent)->tpdf_size;\n                tpdf = ((struct lys_node_grp *)parent)->tpdf;\n                break;\n\n            case LYS_RPC:\n            case LYS_ACTION:\n                tpdf_size = ((struct lys_node_rpc_action *)parent)->tpdf_size;\n                tpdf = ((struct lys_node_rpc_action *)parent)->tpdf;\n                break;\n\n            case LYS_NOTIF:\n                tpdf_size = ((struct lys_node_notif *)parent)->tpdf_size;\n                tpdf = ((struct lys_node_notif *)parent)->tpdf;\n                break;\n\n            case LYS_INPUT:\n            case LYS_OUTPUT:\n                tpdf_size = ((struct lys_node_inout *)parent)->tpdf_size;\n                tpdf = ((struct lys_node_inout *)parent)->tpdf;\n                break;\n\n            default:\n                parent = lys_parent(parent);\n                continue;\n            }\n\n            for (i = 0; i < tpdf_size; i++) {\n                if (!strcmp(tpdf[i].name, name)) {\n                    match = &tpdf[i];\n                    goto check_typedef;\n                }\n            }\n\n            parent = lys_parent(parent);\n        }\n    } else {\n        /* get module where to search */\n        module = lyp_get_module(module, NULL, 0, mod_name, 0, 0);\n        if (!module) {\n            return -1;\n        }\n    }\n\n    /* search in top level typedefs */\n    for (i = 0; i < module->tpdf_size; i++) {\n        if (!strcmp(module->tpdf[i].name, name)) {\n            match = &module->tpdf[i];\n            goto check_typedef;\n        }\n    }\n\n    /* search in submodules */\n    for (i = 0; i < module->inc_size && module->inc[i].submodule; i++) {\n        for (j = 0; j < module->inc[i].submodule->tpdf_size; j++) {\n            if (!strcmp(module->inc[i].submodule->tpdf[j].name, name)) {\n                match = &module->inc[i].submodule->tpdf[j];\n                goto check_typedef;\n            }\n        }\n    }\n\n    return EXIT_FAILURE;\n\ncheck_typedef:\n    if (resolve_superior_type_check(&match->type)) {\n        return EXIT_FAILURE;\n    }\n\n    if (ret) {\n        *ret = match;\n    }\n    return EXIT_SUCCESS;\n}\n\n/**\n * @brief Check the default \\p value of the \\p type. Logs directly.\n *\n * @param[in] type Type definition to use.\n * @param[in] value Default value to check.\n * @param[in] module Type module.\n *\n * @return EXIT_SUCCESS on success, EXIT_FAILURE on forward reference, -1 on error.\n */\nstatic int\ncheck_default(struct lys_type *type, const char **value, struct lys_module *module, int tpdf)\n{\n    struct lys_tpdf *base_tpdf = NULL;\n    struct lyd_node_leaf_list node;\n    const char *dflt = NULL;\n    char *s;\n    int ret = EXIT_SUCCESS, r;\n    struct ly_ctx *ctx = module->ctx;\n\n    assert(value);\n    memset(&node, 0, sizeof node);\n\n    if (type->base <= LY_TYPE_DER) {\n        /* the type was not resolved yet, nothing to do for now */\n        ret = EXIT_FAILURE;\n        goto cleanup;\n    } else if (!tpdf && !module->implemented) {\n        /* do not check defaults in not implemented module's data */\n        goto cleanup;\n    } else if (tpdf && !module->implemented && type->base == LY_TYPE_IDENT) {\n        /* identityrefs are checked when instantiated in data instead of typedef,\n         * but in typedef the value has to be modified to include the prefix */\n        if (*value) {\n            if (strchr(*value, ':')) {\n                dflt = transform_schema2json(module, *value);\n            } else {\n                /* default prefix of the module where the typedef is defined */\n                if (asprintf(&s, \"%s:%s\", lys_main_module(module)->name, *value) == -1) {\n                    LOGMEM(ctx);\n                    ret = -1;\n                    goto cleanup;\n                }\n                dflt = lydict_insert_zc(ctx, s);\n            }\n            lydict_remove(ctx, *value);\n            *value = dflt;\n            dflt = NULL;\n        }\n        goto cleanup;\n    } else if (type->base == LY_TYPE_LEAFREF && tpdf) {\n        /* leafref in typedef cannot be checked */\n        goto cleanup;\n    }\n\n    dflt = lydict_insert(ctx, *value, 0);\n    if (!dflt) {\n        /* we do not have a new default value, so is there any to check even, in some base type? */\n        for (base_tpdf = type->der; base_tpdf->type.der; base_tpdf = base_tpdf->type.der) {\n            if (base_tpdf->dflt) {\n                dflt = lydict_insert(ctx, base_tpdf->dflt, 0);\n                break;\n            }\n        }\n\n        if (!dflt) {\n            /* no default value, nothing to check, all is well */\n            goto cleanup;\n        }\n\n        /* so there is a default value in a base type, but can the default value be no longer valid (did we define some new restrictions)? */\n        switch (type->base) {\n        case LY_TYPE_IDENT:\n            if (lys_main_module(base_tpdf->type.parent->module)->implemented) {\n                goto cleanup;\n            } else {\n                /* check the default value from typedef, but use also the typedef's module\n                 * due to possible searching in imported modules which is expected in\n                 * typedef's module instead of module where the typedef is used */\n                module = base_tpdf->module;\n            }\n            break;\n        case LY_TYPE_INST:\n        case LY_TYPE_LEAFREF:\n        case LY_TYPE_BOOL:\n        case LY_TYPE_EMPTY:\n            /* these have no restrictions, so we would do the exact same work as the unres in the base typedef */\n            goto cleanup;\n        case LY_TYPE_BITS:\n            /* the default value must match the restricted list of values, if the type was restricted */\n            if (type->info.bits.count) {\n                break;\n            }\n            goto cleanup;\n        case LY_TYPE_ENUM:\n            /* the default value must match the restricted list of values, if the type was restricted */\n            if (type->info.enums.count) {\n                break;\n            }\n            goto cleanup;\n        case LY_TYPE_DEC64:\n            if (type->info.dec64.range) {\n                break;\n            }\n            goto cleanup;\n        case LY_TYPE_BINARY:\n            if (type->info.binary.length) {\n                break;\n            }\n            goto cleanup;\n        case LY_TYPE_INT8:\n        case LY_TYPE_INT16:\n        case LY_TYPE_INT32:\n        case LY_TYPE_INT64:\n        case LY_TYPE_UINT8:\n        case LY_TYPE_UINT16:\n        case LY_TYPE_UINT32:\n        case LY_TYPE_UINT64:\n            if (type->info.num.range) {\n                break;\n            }\n            goto cleanup;\n        case LY_TYPE_STRING:\n            if (type->info.str.length || type->info.str.patterns) {\n                break;\n            }\n            goto cleanup;\n        case LY_TYPE_UNION:\n            /* way too much trouble learning whether we need to check the default again, so just do it */\n            break;\n        default:\n            LOGINT(ctx);\n            ret = -1;\n            goto cleanup;\n        }\n    } else if (type->base == LY_TYPE_EMPTY) {\n        LOGVAL(ctx, LYE_INCHILDSTMT, LY_VLOG_NONE, NULL, \"default\", type->parent->name);\n        LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"The \\\"empty\\\" data type cannot have a default value.\");\n        ret = -1;\n        goto cleanup;\n    }\n\n    /* dummy leaf */\n    memset(&node, 0, sizeof node);\n    node.value_str = lydict_insert(ctx, dflt, 0);\n    node.value_type = type->base;\n\n    if (tpdf) {\n        node.schema = calloc(1, sizeof (struct lys_node_leaf));\n        if (!node.schema) {\n            LOGMEM(ctx);\n            ret = -1;\n            goto cleanup;\n        }\n        r = asprintf((char **)&node.schema->name, \"typedef-%s-default\", ((struct lys_tpdf *)type->parent)->name);\n        if (r == -1) {\n            LOGMEM(ctx);\n            ret = -1;\n            goto cleanup;\n        }\n        node.schema->module = module;\n        memcpy(&((struct lys_node_leaf *)node.schema)->type, type, sizeof *type);\n    } else {\n        node.schema = (struct lys_node *)type->parent;\n    }\n\n    if (type->base == LY_TYPE_LEAFREF) {\n        if (!type->info.lref.target) {\n            ret = EXIT_FAILURE;\n            LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Default value \\\"%s\\\" cannot be checked in an unresolved leafref.\",\n                   dflt);\n            goto cleanup;\n        }\n        ret = check_default(&type->info.lref.target->type, &dflt, module, 0);\n        if (!ret) {\n            /* adopt possibly changed default value to its canonical form */\n            if (*value) {\n                lydict_remove(ctx, *value);\n                *value = dflt;\n                dflt = NULL;\n            }\n        }\n    } else {\n        if (!lyp_parse_value(type, &node.value_str, NULL, &node, NULL, module, 1, 1, 0)) {\n            /* possible forward reference */\n            ret = EXIT_FAILURE;\n            if (base_tpdf) {\n                /* default value is defined in some base typedef */\n                if ((type->base == LY_TYPE_BITS && type->der->type.der) ||\n                        (type->base == LY_TYPE_ENUM && type->der->type.der)) {\n                    /* we have refined bits/enums */\n                    LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL,\n                           \"Invalid value \\\"%s\\\" of the default statement inherited to \\\"%s\\\" from \\\"%s\\\" base type.\",\n                           dflt, type->parent->name, base_tpdf->name);\n                }\n            }\n        } else {\n            /* success - adopt canonical form from the node into the default value */\n            if (!ly_strequal(dflt, node.value_str, 1)) {\n                /* this can happen only if we have non-inherited default value,\n                 * inherited default values are already in canonical form */\n                assert(ly_strequal(dflt, *value, 1));\n\n                lydict_remove(ctx, *value);\n                *value = node.value_str;\n                node.value_str = NULL;\n            }\n        }\n    }\n\ncleanup:\n    lyd_free_value(node.value, node.value_type, node.value_flags, type, node.value_str, NULL, NULL, NULL);\n    lydict_remove(ctx, node.value_str);\n    if (tpdf && node.schema) {\n        free((char *)node.schema->name);\n        free(node.schema);\n    }\n    lydict_remove(ctx, dflt);\n\n    return ret;\n}\n\n/**\n * @brief Check a key for mandatory attributes. Logs directly.\n *\n * @param[in] key The key to check.\n * @param[in] flags What flags to check.\n * @param[in] list The list of all the keys.\n * @param[in] index Index of the key in the key list.\n * @param[in] name The name of the keys.\n * @param[in] len The name length.\n *\n * @return EXIT_SUCCESS on success, -1 on error.\n */\nstatic int\ncheck_key(struct lys_node_list *list, int index, const char *name, int len)\n{\n    struct lys_node_leaf *key = list->keys[index];\n    char *dup = NULL;\n    int j;\n    struct ly_ctx *ctx = list->module->ctx;\n\n    /* existence */\n    if (!key) {\n        if (name[len] != '\\0') {\n            dup = strdup(name);\n            LY_CHECK_ERR_RETURN(!dup, LOGMEM(ctx), -1);\n            dup[len] = '\\0';\n            name = dup;\n        }\n        LOGVAL(ctx, LYE_KEY_MISS, LY_VLOG_LYS, list, name);\n        free(dup);\n        return -1;\n    }\n\n    /* uniqueness */\n    for (j = index - 1; j >= 0; j--) {\n        if (key == list->keys[j]) {\n            LOGVAL(ctx, LYE_KEY_DUP, LY_VLOG_LYS, list, key->name);\n            return -1;\n        }\n    }\n\n    /* key is a leaf */\n    if (key->nodetype != LYS_LEAF) {\n        LOGVAL(ctx, LYE_KEY_NLEAF, LY_VLOG_LYS, list, key->name);\n        return -1;\n    }\n\n    /* type of the leaf is not built-in empty */\n    if (key->type.base == LY_TYPE_EMPTY && key->module->version < LYS_VERSION_1_1) {\n        LOGVAL(ctx, LYE_KEY_TYPE, LY_VLOG_LYS, list, key->name);\n        return -1;\n    }\n\n    /* config attribute is the same as of the list */\n    if ((key->flags & LYS_CONFIG_MASK) && (list->flags & LYS_CONFIG_MASK)\n            && ((list->flags & LYS_CONFIG_MASK) != (key->flags & LYS_CONFIG_MASK))) {\n        LOGVAL(ctx, LYE_KEY_CONFIG, LY_VLOG_LYS, list, key->name);\n        return -1;\n    }\n\n    /* key is not placed from augment */\n    if (key->parent->nodetype == LYS_AUGMENT) {\n        LOGVAL(ctx, LYE_KEY_MISS, LY_VLOG_LYS, key, key->name);\n        LOGVAL(ctx, LYE_SPEC, LY_VLOG_PREV, NULL, \"Key inserted from augment.\");\n        return -1;\n    }\n\n    /* key is not when/if-feature -conditional */\n    j = 0;\n    if (key->when || (key->iffeature_size && (j = 1))) {\n        LOGVAL(ctx, LYE_INCHILDSTMT, LY_VLOG_LYS, key, j ? \"if-feature\" : \"when\", \"leaf\");\n        LOGVAL(ctx, LYE_SPEC, LY_VLOG_PREV, NULL, \"Key definition cannot depend on a \\\"%s\\\" condition.\",\n               j ? \"if-feature\" : \"when\");\n        return -1;\n    }\n\n    return EXIT_SUCCESS;\n}\n\n/**\n * @brief Resolve (test the target exists) unique. Logs directly.\n *\n * @param[in] parent The parent node of the unique structure.\n * @param[in] uniq_str_path One path from the unique string.\n *\n * @return EXIT_SUCCESS on succes, EXIT_FAILURE on forward reference, -1 on error.\n */\nint\nresolve_unique(struct lys_node *parent, const char *uniq_str_path, uint8_t *trg_type)\n{\n    int rc;\n    const struct lys_node *leaf = NULL;\n    struct ly_ctx *ctx = parent->module->ctx;\n\n    rc = resolve_descendant_schema_nodeid(uniq_str_path, *lys_child(parent, LYS_LEAF), LYS_LEAF, 1, &leaf);\n    if (rc || !leaf) {\n        if (rc) {\n            LOGVAL(ctx, LYE_INARG, LY_VLOG_LYS, parent, uniq_str_path, \"unique\");\n            if (rc > 0) {\n                LOGVAL(ctx, LYE_INCHAR, LY_VLOG_PREV, NULL, uniq_str_path[rc - 1], &uniq_str_path[rc - 1]);\n            } else if (rc == -2) {\n                LOGVAL(ctx, LYE_SPEC, LY_VLOG_PREV, NULL, \"Unique argument references list.\");\n            }\n            rc = -1;\n        } else {\n            LOGVAL(ctx, LYE_INARG, LY_VLOG_LYS, parent, uniq_str_path, \"unique\");\n            LOGVAL(ctx, LYE_SPEC, LY_VLOG_PREV, NULL, \"Target leaf not found.\");\n            rc = EXIT_FAILURE;\n        }\n        goto error;\n    }\n    if (leaf->nodetype != LYS_LEAF) {\n        LOGVAL(ctx, LYE_INARG, LY_VLOG_LYS, parent, uniq_str_path, \"unique\");\n        LOGVAL(ctx, LYE_SPEC, LY_VLOG_PREV, NULL, \"Target is not a leaf.\");\n        return -1;\n    }\n\n    /* check status */\n    if (parent->nodetype != LYS_EXT && lyp_check_status(parent->flags, parent->module, parent->name,\n                                                        leaf->flags, leaf->module, leaf->name, leaf)) {\n        return -1;\n    }\n\n    /* check that all unique's targets are of the same config type */\n    if (*trg_type) {\n        if (((*trg_type == 1) && (leaf->flags & LYS_CONFIG_R)) || ((*trg_type == 2) && (leaf->flags & LYS_CONFIG_W))) {\n            LOGVAL(ctx, LYE_INARG, LY_VLOG_LYS, parent, uniq_str_path, \"unique\");\n            LOGVAL(ctx, LYE_SPEC, LY_VLOG_PREV, NULL,\n                   \"Leaf \\\"%s\\\" referenced in unique statement is config %s, but previous referenced leaf is config %s.\",\n                   uniq_str_path, *trg_type == 1 ? \"false\" : \"true\", *trg_type == 1 ? \"true\" : \"false\");\n            return -1;\n        }\n    } else {\n        /* first unique */\n        if (leaf->flags & LYS_CONFIG_W) {\n            *trg_type = 1;\n        } else {\n            *trg_type = 2;\n        }\n    }\n\n    /* set leaf's unique flag */\n    ((struct lys_node_leaf *)leaf)->flags |= LYS_UNIQUE;\n\n    return EXIT_SUCCESS;\n\nerror:\n\n    return rc;\n}\n\nvoid\nunres_data_del(struct unres_data *unres, uint32_t i)\n{\n    /* there are items after the one deleted */\n    if (i+1 < unres->count) {\n        /* we only move the data, memory is left allocated, why bother */\n        memmove(&unres->node[i], &unres->node[i+1], (unres->count-(i+1)) * sizeof *unres->node);\n\n    /* deleting the last item */\n    } else if (i == 0) {\n        free(unres->node);\n        unres->node = NULL;\n    }\n\n    /* if there are no items after and it is not the last one, just move the counter */\n    --unres->count;\n}\n\n/**\n * @brief Resolve (find) a data node from a specific module. Does not log.\n *\n * @param[in] mod Module to search in.\n * @param[in] name Name of the data node.\n * @param[in] nam_len Length of the name.\n * @param[in] start Data node to start the search from.\n * @param[in,out] parents Resolved nodes. If there are some parents,\n *                        they are replaced (!!) with the resolvents.\n *\n * @return EXIT_SUCCESS on success, EXIT_FAILURE on forward reference, -1 on error.\n */\nstatic int\nresolve_data(const struct lys_module *mod, const char *name, int nam_len, struct lyd_node *start, struct unres_data *parents)\n{\n    struct lyd_node *node;\n    int flag;\n    uint32_t i;\n\n    if (!parents->count) {\n        parents->count = 1;\n        parents->node = malloc(sizeof *parents->node);\n        LY_CHECK_ERR_RETURN(!parents->node, LOGMEM(mod->ctx), -1);\n        parents->node[0] = NULL;\n    }\n    for (i = 0; i < parents->count;) {\n        if (parents->node[i] && (parents->node[i]->schema->nodetype & (LYS_LEAF | LYS_LEAFLIST | LYS_ANYDATA))) {\n            /* skip */\n            ++i;\n            continue;\n        }\n        flag = 0;\n        LY_TREE_FOR(parents->node[i] ? parents->node[i]->child : start, node) {\n            if (lyd_node_module(node) == mod && !strncmp(node->schema->name, name, nam_len)\n                    && node->schema->name[nam_len] == '\\0') {\n                /* matching target */\n                if (!flag) {\n                    /* put node instead of the current parent */\n                    parents->node[i] = node;\n                    flag = 1;\n                } else {\n                    /* multiple matching, so create a new node */\n                    ++parents->count;\n                    parents->node = ly_realloc(parents->node, parents->count * sizeof *parents->node);\n                    LY_CHECK_ERR_RETURN(!parents->node, LOGMEM(mod->ctx), EXIT_FAILURE);\n                    parents->node[parents->count-1] = node;\n                    ++i;\n                }\n            }\n        }\n\n        if (!flag) {\n            /* remove item from the parents list */\n            unres_data_del(parents, i);\n        } else {\n            ++i;\n        }\n    }\n\n    return parents->count ? EXIT_SUCCESS : EXIT_FAILURE;\n}\n\nstatic int\nresolve_schema_leafref_valid_dep_flag(const struct lys_node *op_node, const struct lys_module *local_mod,\n                                      const struct lys_node *first_node, int abs_path)\n{\n    int dep1, dep2;\n    const struct lys_node *node;\n\n    if (!op_node) {\n        /* leafref pointing to a different module */\n        if (local_mod != lys_node_module(first_node)) {\n            return 1;\n        }\n    } else if (lys_parent(op_node)) {\n        /* inner operation (notif/action) */\n        if (abs_path) {\n            return 1;\n        } else {\n            /* compare depth of both nodes */\n            for (dep1 = 0, node = op_node; lys_parent(node); node = lys_parent(node));\n            for (dep2 = 0, node = first_node; lys_parent(node); node = lys_parent(node));\n            if ((dep2 > dep1) || ((dep2 == dep1) && (op_node != first_node))) {\n                return 1;\n            }\n        }\n    } else {\n        /* top-level operation (notif/rpc) */\n        if (op_node != first_node) {\n            return 1;\n        }\n    }\n\n    return 0;\n}\n\n/**\n * @brief Resolve a path (leafref) predicate in JSON schema context. Logs directly.\n *\n * @param[in] path Path to use.\n * @param[in] context_node Predicate context node (where the predicate is placed).\n * @param[in] parent Path context node (where the path begins/is placed).\n * @param[in] node_set Set where to add nodes whose parent chain must be implemented.\n *\n * @return 0 on forward reference, otherwise the number\n *         of characters successfully parsed,\n *         positive on success, negative on failure.\n */\nstatic int\nresolve_schema_leafref_predicate(const char *path, const struct lys_node *context_node, struct lys_node *parent,\n                                 struct ly_set *node_set)\n{\n    const struct lys_module *trg_mod;\n    const struct lys_node *src_node, *dst_node, *tmp_parent;\n    struct lys_node_augment *last_aug;\n    const char *path_key_expr, *source, *sour_pref, *dest, *dest_pref;\n    int pke_len, sour_len, sour_pref_len, dest_len, dest_pref_len, pke_parsed, parsed = 0;\n    int has_predicate, dest_parent_times, i, rc;\n    struct ly_ctx *ctx = context_node->module->ctx;\n\n    do {\n        if ((i = parse_path_predicate(path, &sour_pref, &sour_pref_len, &source, &sour_len, &path_key_expr,\n                                      &pke_len, &has_predicate)) < 1) {\n            LOGVAL(ctx, LYE_INCHAR, LY_VLOG_LYS, parent, path[-i], path - i);\n            return -parsed + i;\n        }\n        parsed += i;\n        path += i;\n\n        /* source (must be leaf) */\n        if (sour_pref) {\n            trg_mod = lyp_get_module(lys_node_module(parent), NULL, 0, sour_pref, sour_pref_len, 0);\n        } else {\n            trg_mod = lys_node_module(parent);\n        }\n        rc = lys_getnext_data(trg_mod, context_node, source, sour_len, LYS_LEAF | LYS_LEAFLIST, LYS_GETNEXT_NOSTATECHECK,\n                              &src_node);\n        if (rc) {\n            LOGVAL(ctx, LYE_NORESOLV, LY_VLOG_LYS, parent, \"leafref predicate\", path-parsed);\n            return 0;\n        }\n\n        /* destination */\n        dest_parent_times = 0;\n        pke_parsed = 0;\n        if ((i = parse_path_key_expr(path_key_expr, &dest_pref, &dest_pref_len, &dest, &dest_len,\n                                     &dest_parent_times)) < 1) {\n            LOGVAL(ctx, LYE_INCHAR, LY_VLOG_LYS, parent, path_key_expr[-i], path_key_expr-i);\n            return -parsed;\n        }\n        pke_parsed += i;\n\n        for (i = 0, dst_node = parent; i < dest_parent_times; ++i) {\n            if (!dst_node) {\n                /* we went too much into parents, there is no parent anymore */\n                LOGVAL(ctx, LYE_NORESOLV, LY_VLOG_LYS, parent, \"leafref predicate\", path_key_expr);\n                return 0;\n            }\n\n            if (dst_node->parent && (dst_node->parent->nodetype == LYS_AUGMENT)\n                    && !((struct lys_node_augment *)dst_node->parent)->target) {\n                /* we are in an unresolved augment, cannot evaluate */\n                LOGVAL(ctx, LYE_SPEC, LY_VLOG_LYS, dst_node->parent,\n                       \"Cannot resolve leafref predicate \\\"%s\\\" because it is in an unresolved augment.\", path_key_expr);\n                return 0;\n            }\n\n            /* path is supposed to be evaluated in data tree, so we have to skip\n             * all schema nodes that cannot be instantiated in data tree */\n            for (dst_node = lys_parent(dst_node);\n                 dst_node && !(dst_node->nodetype & (LYS_CONTAINER | LYS_LIST | LYS_ACTION | LYS_NOTIF | LYS_RPC));\n                 dst_node = lys_parent(dst_node));\n        }\n        while (1) {\n            last_aug = NULL;\n\n            if (dest_pref) {\n                trg_mod = lyp_get_module(lys_node_module(parent), NULL, 0, dest_pref, dest_pref_len, 0);\n            } else {\n                trg_mod = lys_node_module(parent);\n            }\n\n            if (!trg_mod->implemented && dst_node) {\n    get_next_augment:\n                last_aug = lys_getnext_target_aug(last_aug, trg_mod, dst_node);\n            }\n\n            tmp_parent = (last_aug ? (struct lys_node *)last_aug : dst_node);\n            rc = lys_getnext_data(trg_mod, tmp_parent, dest, dest_len, LYS_CONTAINER | LYS_LIST | LYS_LEAF,\n                                  LYS_GETNEXT_NOSTATECHECK, &dst_node);\n            if (rc) {\n                if (last_aug) {\n                    /* restore the correct augment target */\n                    dst_node = last_aug->target;\n                    goto get_next_augment;\n                }\n                LOGVAL(ctx, LYE_NORESOLV, LY_VLOG_LYS, parent, \"leafref predicate\", path_key_expr);\n                return 0;\n            }\n\n            if (pke_len == pke_parsed) {\n                break;\n            }\n\n            if ((i = parse_path_key_expr(path_key_expr + pke_parsed, &dest_pref, &dest_pref_len, &dest, &dest_len,\n                                         &dest_parent_times)) < 1) {\n                LOGVAL(ctx, LYE_INCHAR, LY_VLOG_LYS, parent,\n                       (path_key_expr + pke_parsed)[-i], (path_key_expr + pke_parsed) - i);\n                return -parsed;\n            }\n            pke_parsed += i;\n        }\n\n        /* check source - dest match */\n        if (dst_node->nodetype != src_node->nodetype) {\n            LOGVAL(ctx, LYE_NORESOLV, LY_VLOG_LYS, parent, \"leafref predicate\", path - parsed);\n            LOGVAL(ctx, LYE_SPEC, LY_VLOG_PREV, NULL, \"Destination node is not a %s, but a %s.\",\n                   strnodetype(src_node->nodetype), strnodetype(dst_node->nodetype));\n            return -parsed;\n        }\n\n        /* add both nodes into node set */\n        ly_set_add(node_set, (void *)dst_node, 0);\n        ly_set_add(node_set, (void *)src_node, 0);\n    } while (has_predicate);\n\n    return parsed;\n}\n\nstatic int\ncheck_leafref_features(struct lys_type *type)\n{\n    struct lys_node *iter;\n    struct ly_set *src_parents, *trg_parents, *features;\n    struct lys_node_augment *aug;\n    struct ly_ctx *ctx = ((struct lys_tpdf *)type->parent)->module->ctx;\n    unsigned int i, j, size, x;\n    int ret = EXIT_SUCCESS;\n\n    assert(type->parent);\n\n    src_parents = ly_set_new();\n    trg_parents = ly_set_new();\n    features = ly_set_new();\n\n    /* get parents chain of source (leafref) */\n    for (iter = (struct lys_node *)type->parent; iter; iter = lys_parent(iter)) {\n        if (iter->nodetype & (LYS_INPUT | LYS_OUTPUT)) {\n            continue;\n        }\n        if (iter->parent && (iter->parent->nodetype == LYS_AUGMENT)) {\n            aug = (struct lys_node_augment *)iter->parent;\n            if ((aug->module->implemented && (aug->flags & LYS_NOTAPPLIED)) || !aug->target) {\n                /* unresolved augment, wait until it's resolved */\n                LOGVAL(ctx, LYE_SPEC, LY_VLOG_LYS, aug,\n                       \"Cannot check leafref \\\"%s\\\" if-feature consistency because of an unresolved augment.\", type->info.lref.path);\n                ret = EXIT_FAILURE;\n                goto cleanup;\n            }\n            /* also add this augment */\n            ly_set_add(src_parents, aug, LY_SET_OPT_USEASLIST);\n        }\n        ly_set_add(src_parents, iter, LY_SET_OPT_USEASLIST);\n    }\n    /* get parents chain of target */\n    for (iter = (struct lys_node *)type->info.lref.target; iter; iter = lys_parent(iter)) {\n        if (iter->nodetype & (LYS_INPUT | LYS_OUTPUT)) {\n            continue;\n        }\n        if (iter->parent && (iter->parent->nodetype == LYS_AUGMENT)) {\n            aug = (struct lys_node_augment *)iter->parent;\n            if ((aug->module->implemented && (aug->flags & LYS_NOTAPPLIED)) || !aug->target) {\n                /* unresolved augment, wait until it's resolved */\n                LOGVAL(ctx, LYE_SPEC, LY_VLOG_LYS, aug,\n                       \"Cannot check leafref \\\"%s\\\" if-feature consistency because of an unresolved augment.\", type->info.lref.path);\n                ret = EXIT_FAILURE;\n                goto cleanup;\n            }\n        }\n        ly_set_add(trg_parents, iter, LY_SET_OPT_USEASLIST);\n    }\n\n    /* compare the features used in if-feature statements in the rest of both\n     * chains of parents. The set of features used for target must be a subset\n     * of features used for the leafref. This is not a perfect, we should compare\n     * the truth tables but it could require too much resources, so we simplify that */\n    for (i = 0; i < src_parents->number; i++) {\n        iter = src_parents->set.s[i]; /* shortcut */\n        if (!iter->iffeature_size) {\n            continue;\n        }\n        for (j = 0; j < iter->iffeature_size; j++) {\n            resolve_iffeature_getsizes(&iter->iffeature[j], NULL, &size);\n            for (; size; size--) {\n                if (!iter->iffeature[j].features[size - 1]) {\n                    /* not yet resolved feature, postpone this check */\n                    ret = EXIT_FAILURE;\n                    goto cleanup;\n                }\n                ly_set_add(features, iter->iffeature[j].features[size - 1], 0);\n            }\n        }\n    }\n    x = features->number;\n    for (i = 0; i < trg_parents->number; i++) {\n        iter = trg_parents->set.s[i]; /* shortcut */\n        if (!iter->iffeature_size) {\n            continue;\n        }\n        for (j = 0; j < iter->iffeature_size; j++) {\n            resolve_iffeature_getsizes(&iter->iffeature[j], NULL, &size);\n            for (; size; size--) {\n                if (!iter->iffeature[j].features[size - 1]) {\n                    /* not yet resolved feature, postpone this check */\n                    ret = EXIT_FAILURE;\n                    goto cleanup;\n                }\n                if ((unsigned)ly_set_add(features, iter->iffeature[j].features[size - 1], 0) >= x) {\n                    /* the feature is not present in features set of target's parents chain */\n                    LOGVAL(ctx, LYE_NORESOLV, LY_VLOG_LYS, type->parent, \"leafref\", type->info.lref.path);\n                    LOGVAL(ctx, LYE_SPEC, LY_VLOG_PREV, NULL,\n                           \"Leafref is not conditional based on \\\"%s\\\" feature as its target.\",\n                           iter->iffeature[j].features[size - 1]->name);\n                    ret = -1;\n                    goto cleanup;\n                }\n            }\n        }\n    }\n\ncleanup:\n    ly_set_free(features);\n    ly_set_free(src_parents);\n    ly_set_free(trg_parents);\n\n    return ret;\n}\n\n/**\n * @brief Resolve a path (leafref) in JSON schema context. Logs directly.\n *\n * @param[in] path Path to use.\n * @param[in] parent_node Parent of the leafref.\n * @param[out] ret Pointer to the resolved schema node. Can be NULL.\n *\n * @return EXIT_SUCCESS on success, EXIT_FAILURE on forward reference, -1 on error.\n */\nstatic int\nresolve_schema_leafref(struct lys_type *type, struct lys_node *parent, struct unres_schema *unres)\n{\n    const struct lys_node *node, *op_node = NULL, *tmp_parent;\n    struct ly_set *node_set;\n    struct lys_node_augment *last_aug;\n    const struct lys_module *tmp_mod, *cur_module;\n    const char *id, *prefix, *name;\n    int pref_len, nam_len, parent_times, has_predicate;\n    int i, first_iter;\n    struct ly_ctx *ctx = parent->module->ctx;\n\n    first_iter = 1;\n    parent_times = 0;\n    id = type->info.lref.path;\n    node_set = ly_set_new();\n    if (!node_set) {\n        LOGMEM(ctx);\n        return -1;\n    }\n\n    /* find operation schema we are in */\n    for (op_node = lys_parent(parent);\n        op_node && !(op_node->nodetype & (LYS_ACTION | LYS_NOTIF | LYS_RPC));\n        op_node = lys_parent(op_node));\n\n    cur_module = lys_node_module(parent);\n    do {\n        if ((i = parse_path_arg(cur_module, id, &prefix, &pref_len, &name, &nam_len, &parent_times, &has_predicate)) < 1) {\n            LOGVAL(ctx, LYE_INCHAR, LY_VLOG_LYS, parent, id[-i], &id[-i]);\n            ly_set_free(node_set);\n            return -1;\n        }\n        id += i;\n\n        /* get the current module */\n        tmp_mod = prefix ? lyp_get_module(cur_module, NULL, 0, prefix, pref_len, 0) : cur_module;\n        if (!tmp_mod) {\n            LOGVAL(ctx, LYE_NORESOLV, LY_VLOG_LYS, parent, \"leafref\", type->info.lref.path);\n            ly_set_free(node_set);\n            return EXIT_FAILURE;\n        }\n        last_aug = NULL;\n\n        if (first_iter) {\n            if (parent_times == -1) {\n                /* use module data */\n                node = NULL;\n\n            } else if (parent_times > 0) {\n                /* we are looking for the right parent */\n                for (i = 0, node = parent; i < parent_times; i++) {\n                    if (node->parent && (node->parent->nodetype == LYS_AUGMENT)\n                            && !((struct lys_node_augment *)node->parent)->target) {\n                        /* we are in an unresolved augment, cannot evaluate */\n                        LOGVAL(ctx, LYE_SPEC, LY_VLOG_LYS, node->parent,\n                            \"Cannot resolve leafref \\\"%s\\\" because it is in an unresolved augment.\", type->info.lref.path);\n                        ly_set_free(node_set);\n                        return EXIT_FAILURE;\n                    }\n\n                    /* path is supposed to be evaluated in data tree, so we have to skip\n                     * all schema nodes that cannot be instantiated in data tree */\n                    for (node = lys_parent(node);\n                        node && !(node->nodetype & (LYS_CONTAINER | LYS_LIST | LYS_ACTION | LYS_NOTIF | LYS_RPC));\n                        node = lys_parent(node));\n\n                    if (!node) {\n                        if (i == parent_times - 1) {\n                            /* top-level */\n                            break;\n                        }\n\n                        /* higher than top-level */\n                        LOGVAL(ctx, LYE_NORESOLV, LY_VLOG_LYS, parent, \"leafref\", type->info.lref.path);\n                        ly_set_free(node_set);\n                        return EXIT_FAILURE;\n                    }\n                }\n            } else {\n                LOGINT(ctx);\n                ly_set_free(node_set);\n                return -1;\n            }\n        }\n\n        /* find the next node (either in unconnected augment or as a schema sibling, node is NULL for top-level node -\n         * - useless to search for that in augments) */\n        if (!tmp_mod->implemented && node) {\n    get_next_augment:\n            last_aug = lys_getnext_target_aug(last_aug, tmp_mod, node);\n        }\n\n        tmp_parent = (last_aug ? (struct lys_node *)last_aug : node);\n        node = NULL;\n        while ((node = lys_getnext(node, tmp_parent, tmp_mod, LYS_GETNEXT_NOSTATECHECK))) {\n            if (lys_node_module(node) != lys_main_module(tmp_mod)) {\n                continue;\n            }\n            if (strncmp(node->name, name, nam_len) || node->name[nam_len]) {\n                continue;\n            }\n            /* match */\n            break;\n        }\n        if (!node) {\n            if (last_aug) {\n                /* restore the correct augment target */\n                node = last_aug->target;\n                goto get_next_augment;\n            }\n            LOGVAL(ctx, LYE_NORESOLV, LY_VLOG_LYS, parent, \"leafref\", type->info.lref.path);\n            ly_set_free(node_set);\n            return EXIT_FAILURE;\n        }\n\n        if (first_iter) {\n            /* set external dependency flag, we can decide based on the first found node */\n            if (resolve_schema_leafref_valid_dep_flag(op_node, cur_module, node, (parent_times == -1 ? 1 : 0))) {\n                parent->flags |= LYS_LEAFREF_DEP;\n            }\n            first_iter = 0;\n        }\n\n        if (has_predicate) {\n            /* we have predicate, so the current result must be list */\n            if (node->nodetype != LYS_LIST) {\n                LOGVAL(ctx, LYE_NORESOLV, LY_VLOG_LYS, parent, \"leafref\", type->info.lref.path);\n                ly_set_free(node_set);\n                return -1;\n            }\n\n            i = resolve_schema_leafref_predicate(id, node, parent, node_set);\n            if (!i) {\n                ly_set_free(node_set);\n                return EXIT_FAILURE;\n            } else if (i < 0) {\n                ly_set_free(node_set);\n                return -1;\n            }\n            id += i;\n            has_predicate = 0;\n        }\n    } while (id[0]);\n\n    /* the target must be leaf or leaf-list (in YANG 1.1 only) */\n    if ((node->nodetype != LYS_LEAF) && (node->nodetype != LYS_LEAFLIST)) {\n        LOGVAL(ctx, LYE_NORESOLV, LY_VLOG_LYS, parent, \"leafref\", type->info.lref.path);\n        LOGVAL(ctx, LYE_SPEC, LY_VLOG_PREV, NULL, \"Leafref target \\\"%s\\\" is not a leaf nor a leaf-list.\", type->info.lref.path);\n        ly_set_free(node_set);\n        return -1;\n    }\n\n    /* check status */\n    if (lyp_check_status(parent->flags, parent->module, parent->name,\n                    node->flags, node->module, node->name, node)) {\n        ly_set_free(node_set);\n        return -1;\n    }\n\n    /* assign */\n    type->info.lref.target = (struct lys_node_leaf *)node;\n\n    /* add the target node into a set so its parent chain modules can be implemented */\n    ly_set_add(node_set, (void *)node, 0);\n\n    /* as the last thing traverse this leafref and make targets on the path implemented */\n    if (lys_node_module(parent)->implemented) {\n        /* make all the modules in the path implemented */\n        for (i = 0; (unsigned)i < node_set->number; ++i) {\n            for (node = node_set->set.s[i]; node; node = lys_parent(node)) {\n                if (!lys_node_module(node)->implemented) {\n                    lys_node_module(node)->implemented = 1;\n                    if (unres_schema_add_node(lys_node_module(node), unres, NULL, UNRES_MOD_IMPLEMENT, NULL) == -1) {\n                        ly_set_free(node_set);\n                        return -1;\n                    }\n                }\n            }\n        }\n\n        /* store the backlink from leafref target */\n        if (lys_leaf_add_leafref_target(type->info.lref.target, (struct lys_node *)type->parent)) {\n            ly_set_free(node_set);\n            return -1;\n        }\n    }\n    ly_set_free(node_set);\n\n    /* check if leafref and its target are under common if-features */\n    return check_leafref_features(type);\n}\n\n/**\n * @brief Compare 2 data node values.\n *\n * Comparison performed on canonical forms, the first value\n * is first transformed into canonical form.\n *\n * @param[in] node Leaf/leaf-list with these values.\n * @param[in] noncan_val Non-canonical value.\n * @param[in] noncan_val_len Length of \\p noncal_val.\n * @param[in] can_val Canonical value.\n * @return 1 if equal, 0 if not, -1 on error (logged).\n */\nstatic int\nvalequal(struct lys_node *node, const char *noncan_val, int noncan_val_len, const char *can_val)\n{\n    int ret;\n    struct lyd_node_leaf_list leaf;\n    struct lys_node_leaf *sleaf = (struct lys_node_leaf*)node;\n\n    /* dummy leaf */\n    memset(&leaf, 0, sizeof leaf);\n    leaf.value_str = lydict_insert(node->module->ctx, noncan_val, noncan_val_len);\n\nrepeat:\n    leaf.value_type = sleaf->type.base;\n    leaf.schema = node;\n\n    if (leaf.value_type == LY_TYPE_LEAFREF) {\n        if (!sleaf->type.info.lref.target) {\n            /* it should either be unresolved leafref (leaf.value_type are ORed flags) or it will be resolved */\n            LOGINT(node->module->ctx);\n            ret = -1;\n            goto finish;\n        }\n        sleaf = sleaf->type.info.lref.target;\n        goto repeat;\n    } else {\n        if (!lyp_parse_value(&sleaf->type, &leaf.value_str, NULL, &leaf, NULL, NULL, 0, 0, 0)) {\n            ret = -1;\n            goto finish;\n        }\n    }\n\n    if (!strcmp(leaf.value_str, can_val)) {\n        ret = 1;\n    } else {\n        ret = 0;\n    }\n\nfinish:\n    lydict_remove(node->module->ctx, leaf.value_str);\n    return ret;\n}\n\n/**\n * @brief Resolve instance-identifier predicate in JSON data format.\n *        Does not log.\n *\n * @param[in] prev_mod Previous module to use in case there is no prefix.\n * @param[in] pred Predicate to use.\n * @param[in,out] node Node matching the restriction without\n *                     the predicate. If it does not satisfy the predicate,\n *                     it is set to NULL.\n *\n * @return Number of characters successfully parsed,\n *         positive on success, negative on failure.\n */\nstatic int\nresolve_instid_predicate(const struct lys_module *prev_mod, const char *pred, struct lyd_node **node, int cur_idx)\n{\n    /* ... /node[key=value] ... */\n    struct lyd_node_leaf_list *key;\n    struct lys_node_leaf **list_keys = NULL;\n    struct lys_node_list *slist = NULL;\n    const char *model, *name, *value;\n    int mod_len, nam_len, val_len, i, has_predicate, parsed;\n    struct ly_ctx *ctx = prev_mod->ctx;\n\n    assert(pred && node && *node);\n\n    parsed = 0;\n    do {\n        if ((i = parse_predicate(pred + parsed, &model, &mod_len, &name, &nam_len, &value, &val_len, &has_predicate)) < 1) {\n            return -parsed + i;\n        }\n        parsed += i;\n\n        if (!(*node)) {\n            /* just parse it all */\n            continue;\n        }\n\n        /* target */\n        if (name[0] == '.') {\n            /* leaf-list value */\n            if ((*node)->schema->nodetype != LYS_LEAFLIST) {\n                LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Instance identifier expects leaf-list, but have %s \\\"%s\\\".\",\n                       strnodetype((*node)->schema->nodetype), (*node)->schema->name);\n                parsed = -1;\n                goto cleanup;\n            }\n\n            /* check the value */\n            if (!valequal((*node)->schema, value, val_len, ((struct lyd_node_leaf_list *)*node)->value_str)) {\n                *node = NULL;\n                goto cleanup;\n            }\n\n        } else if (isdigit(name[0])) {\n            assert(!value);\n\n            /* keyless list position */\n            if ((*node)->schema->nodetype != LYS_LIST) {\n                LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Instance identifier expects list, but have %s \\\"%s\\\".\",\n                       strnodetype((*node)->schema->nodetype), (*node)->schema->name);\n                parsed = -1;\n                goto cleanup;\n            }\n\n            if (((struct lys_node_list *)(*node)->schema)->keys) {\n                LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Instance identifier expects list without keys, but have list \\\"%s\\\".\",\n                       (*node)->schema->name);\n                parsed = -1;\n                goto cleanup;\n            }\n\n            /* check the index */\n            if (atoi(name) != cur_idx) {\n                *node = NULL;\n                goto cleanup;\n            }\n\n        } else {\n            /* list key value */\n            if ((*node)->schema->nodetype != LYS_LIST) {\n                LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Instance identifier expects list, but have %s \\\"%s\\\".\",\n                       strnodetype((*node)->schema->nodetype), (*node)->schema->name);\n                parsed = -1;\n                goto cleanup;\n            }\n            slist = (struct lys_node_list *)(*node)->schema;\n\n            /* prepare key array */\n            if (!list_keys) {\n                list_keys = malloc(slist->keys_size * sizeof *list_keys);\n                LY_CHECK_ERR_RETURN(!list_keys, LOGMEM(ctx), -1);\n                for (i = 0; i < slist->keys_size; ++i) {\n                    list_keys[i] = slist->keys[i];\n                }\n            }\n\n            /* find the schema key leaf */\n            for (i = 0; i < slist->keys_size; ++i) {\n                if (list_keys[i] && !strncmp(list_keys[i]->name, name, nam_len) && !list_keys[i]->name[nam_len]) {\n                    break;\n                }\n            }\n            if (i == slist->keys_size) {\n                /* this list has no such key */\n                LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Instance identifier expects list with the key \\\"%.*s\\\",\"\n                       \" but list \\\"%s\\\" does not define it.\", nam_len, name, slist->name);\n                parsed = -1;\n                goto cleanup;\n            }\n\n            /* check module */\n            if (model) {\n                if (strncmp(list_keys[i]->module->name, model, mod_len) || list_keys[i]->module->name[mod_len]) {\n                    LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Instance identifier expects key \\\"%s\\\" from module \\\"%.*s\\\", not \\\"%s\\\".\",\n                           list_keys[i]->name, model, mod_len, list_keys[i]->module->name);\n                    parsed = -1;\n                    goto cleanup;\n                }\n            } else {\n                if (list_keys[i]->module != prev_mod) {\n                    LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Instance identifier expects key \\\"%s\\\" from module \\\"%s\\\", not \\\"%s\\\".\",\n                           list_keys[i]->name, prev_mod->name, list_keys[i]->module->name);\n                    parsed = -1;\n                    goto cleanup;\n                }\n            }\n\n            /* find the actual data key */\n            for (key = (struct lyd_node_leaf_list *)(*node)->child; key; key = (struct lyd_node_leaf_list *)key->next) {\n                if (key->schema == (struct lys_node *)list_keys[i]) {\n                    break;\n                }\n            }\n            if (!key) {\n                /* list instance is missing a key? definitely should not happen */\n                LOGINT(ctx);\n                parsed = -1;\n                goto cleanup;\n            }\n\n            /* check the value */\n            if (!valequal(key->schema, value, val_len, key->value_str)) {\n                *node = NULL;\n                /* we still want to parse the whole predicate */\n                continue;\n            }\n\n            /* everything is fine, mark this key as resolved */\n            list_keys[i] = NULL;\n        }\n    } while (has_predicate);\n\n    /* check that all list keys were specified */\n    if (*node && list_keys) {\n        for (i = 0; i < slist->keys_size; ++i) {\n            if (list_keys[i]) {\n                LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Instance identifier is missing list key \\\"%s\\\".\", list_keys[i]->name);\n                parsed = -1;\n                goto cleanup;\n            }\n        }\n    }\n\ncleanup:\n    free(list_keys);\n    return parsed;\n}\n\nstatic int\ncheck_xpath(struct lys_node *node, int check_place)\n{\n    struct lys_node *parent;\n    struct lyxp_set set;\n    enum int_log_opts prev_ilo;\n\n    if (check_place) {\n        parent = node;\n        while (parent) {\n            if (parent->nodetype == LYS_GROUPING) {\n                /* unresolved grouping, skip for now (will be checked later) */\n                return EXIT_SUCCESS;\n            }\n            if (parent->nodetype == LYS_AUGMENT) {\n                if (!((struct lys_node_augment *)parent)->target) {\n                    /* unresolved augment, skip for now (will be checked later) */\n                    return EXIT_FAILURE;\n                } else {\n                    parent = ((struct lys_node_augment *)parent)->target;\n                    continue;\n                }\n            }\n            parent = parent->parent;\n        }\n    }\n\n    memset(&set, 0, sizeof set);\n\n    /* produce just warnings */\n    ly_ilo_change(NULL, ILO_ERR2WRN, &prev_ilo, NULL);\n    lyxp_node_atomize(node, &set, 1);\n    ly_ilo_restore(NULL, prev_ilo, NULL, 0);\n\n    if (set.val.snodes) {\n        free(set.val.snodes);\n    }\n    return EXIT_SUCCESS;\n}\n\nstatic int\ncheck_leafref_config(struct lys_node_leaf *leaf, struct lys_type *type)\n{\n    unsigned int i;\n\n    if (type->base == LY_TYPE_LEAFREF) {\n        if ((leaf->flags & LYS_CONFIG_W) && type->info.lref.target && type->info.lref.req != -1 &&\n                (type->info.lref.target->flags & LYS_CONFIG_R)) {\n            LOGVAL(leaf->module->ctx, LYE_SPEC, LY_VLOG_LYS, leaf, \"The leafref %s is config but refers to a non-config %s.\",\n                   strnodetype(leaf->nodetype), strnodetype(type->info.lref.target->nodetype));\n            return -1;\n        }\n        /* we can skip the test in case the leafref is not yet resolved. In that case the test is done in the time\n         * of leafref resolving (lys_leaf_add_leafref_target()) */\n    } else if (type->base == LY_TYPE_UNION) {\n        for (i = 0; i < type->info.uni.count; i++) {\n            if (check_leafref_config(leaf, &type->info.uni.types[i])) {\n                return -1;\n            }\n        }\n    }\n    return 0;\n}\n\n/**\n * @brief Passes config flag down to children, skips nodes without config flags.\n * Logs.\n *\n * @param[in] node Siblings and their children to have flags changed.\n * @param[in] clear Flag to clear all config flags if parent is LYS_NOTIF, LYS_INPUT, LYS_OUTPUT, LYS_RPC.\n * @param[in] flags Flags to assign to all the nodes.\n * @param[in,out] unres List of unresolved items.\n *\n * @return 0 on success, -1 on error.\n */\nint\ninherit_config_flag(struct lys_node *node, int flags, int clear)\n{\n    struct lys_node_leaf *leaf;\n    struct ly_ctx *ctx;\n\n    if (!node) {\n        return 0;\n    }\n\n    assert(!(flags ^ (flags & LYS_CONFIG_MASK)));\n    ctx = node->module->ctx;\n\n    LY_TREE_FOR(node, node) {\n        if (clear) {\n            node->flags &= ~LYS_CONFIG_MASK;\n            node->flags &= ~LYS_CONFIG_SET;\n        } else {\n            if (node->flags & LYS_CONFIG_SET) {\n                /* skip nodes with an explicit config value */\n                if ((flags & LYS_CONFIG_R) && (node->flags & LYS_CONFIG_W)) {\n                    LOGVAL(ctx, LYE_INARG, LY_VLOG_LYS, node, \"true\", \"config\");\n                    LOGVAL(ctx, LYE_SPEC, LY_VLOG_PREV, NULL, \"State nodes cannot have configuration nodes as children.\");\n                    return -1;\n                }\n                continue;\n            }\n\n            if (!(node->nodetype & (LYS_USES | LYS_GROUPING))) {\n                node->flags = (node->flags & ~LYS_CONFIG_MASK) | flags;\n                /* check that configuration lists have keys */\n                if ((node->nodetype == LYS_LIST) && (node->flags & LYS_CONFIG_W)\n                        && !((struct lys_node_list *)node)->keys_size) {\n                    LOGVAL(ctx, LYE_MISSCHILDSTMT, LY_VLOG_LYS, node, \"key\", \"list\");\n                    return -1;\n                }\n            }\n        }\n        if (!(node->nodetype & (LYS_LEAF | LYS_LEAFLIST | LYS_ANYDATA))) {\n            if (inherit_config_flag(node->child, flags, clear)) {\n                return -1;\n            }\n        } else if (node->nodetype & (LYS_LEAF | LYS_LEAFLIST)) {\n            leaf = (struct lys_node_leaf *)node;\n            if (check_leafref_config(leaf, &leaf->type)) {\n                return -1;\n            }\n        }\n    }\n\n    return 0;\n}\n\n/**\n * @brief Resolve augment target. Logs directly.\n *\n * @param[in] aug Augment to use.\n * @param[in] uses Parent where to start the search in. If set, uses augment, if not, standalone augment.\n * @param[in,out] unres List of unresolved items.\n *\n * @return EXIT_SUCCESS on success, EXIT_FAILURE on forward reference, -1 on error.\n */\nstatic int\nresolve_augment(struct lys_node_augment *aug, struct lys_node *uses, struct unres_schema *unres)\n{\n    int rc;\n    struct lys_node *sub;\n    struct lys_module *mod;\n    struct ly_set *set;\n    struct ly_ctx *ctx;\n\n    assert(aug);\n    mod = lys_main_module(aug->module);\n    ctx = mod->ctx;\n\n    /* set it as not applied for now */\n    aug->flags |= LYS_NOTAPPLIED;\n\n    /* it can already be resolved in case we returned EXIT_FAILURE from if block below */\n    if (!aug->target) {\n        /* resolve target node */\n        rc = resolve_schema_nodeid(aug->target_name, uses, (uses ? NULL : lys_node_module((struct lys_node *)aug)), &set, 0, 0);\n        if (rc == -1) {\n            LOGVAL(ctx, LYE_PATH, LY_VLOG_LYS, aug);\n            return -1;\n        }\n        if (!set) {\n            LOGVAL(ctx, LYE_INRESOLV, LY_VLOG_LYS, aug, \"augment\", aug->target_name);\n            return EXIT_FAILURE;\n        }\n        aug->target = set->set.s[0];\n        ly_set_free(set);\n    }\n\n    /* make this module implemented if the target module is (if the target is in an unimplemented module,\n     * it is fine because when we will be making that module implemented, its augment will be applied\n     * and that augment target module made implemented, recursively) */\n    if (mod->implemented && !lys_node_module(aug->target)->implemented) {\n        lys_node_module(aug->target)->implemented = 1;\n        if (unres_schema_add_node(lys_node_module(aug->target), unres, NULL, UNRES_MOD_IMPLEMENT, NULL) == -1) {\n            return -1;\n        }\n    }\n\n    /* check for mandatory nodes - if the target node is in another module\n     * the added nodes cannot be mandatory\n     */\n    if (!aug->parent && (lys_node_module((struct lys_node *)aug) != lys_node_module(aug->target))\n            && (rc = lyp_check_mandatory_augment(aug, aug->target))) {\n        return rc;\n    }\n\n    /* check augment target type and then augment nodes type */\n    if (aug->target->nodetype & (LYS_CONTAINER | LYS_LIST)) {\n        LY_TREE_FOR(aug->child, sub) {\n            if (!(sub->nodetype & (LYS_ANYDATA | LYS_CONTAINER | LYS_LEAF | LYS_LIST | LYS_LEAFLIST | LYS_USES\n                                   | LYS_CHOICE | LYS_ACTION | LYS_NOTIF))) {\n                LOGVAL(ctx, LYE_INCHILDSTMT, LY_VLOG_LYS, aug, strnodetype(sub->nodetype), \"augment\");\n                LOGVAL(ctx, LYE_SPEC, LY_VLOG_PREV, NULL, \"Cannot augment \\\"%s\\\" with a \\\"%s\\\".\",\n                       strnodetype(aug->target->nodetype), strnodetype(sub->nodetype));\n                return -1;\n            }\n        }\n    } else if (aug->target->nodetype & (LYS_CASE | LYS_INPUT | LYS_OUTPUT | LYS_NOTIF)) {\n        LY_TREE_FOR(aug->child, sub) {\n            if (!(sub->nodetype & (LYS_ANYDATA | LYS_CONTAINER | LYS_LEAF | LYS_LIST | LYS_LEAFLIST | LYS_USES | LYS_CHOICE))) {\n                LOGVAL(ctx, LYE_INCHILDSTMT, LY_VLOG_LYS, aug, strnodetype(sub->nodetype), \"augment\");\n                LOGVAL(ctx, LYE_SPEC, LY_VLOG_PREV, NULL, \"Cannot augment \\\"%s\\\" with a \\\"%s\\\".\",\n                       strnodetype(aug->target->nodetype), strnodetype(sub->nodetype));\n                return -1;\n            }\n        }\n    } else if (aug->target->nodetype == LYS_CHOICE) {\n        LY_TREE_FOR(aug->child, sub) {\n            if (!(sub->nodetype & (LYS_CASE | LYS_ANYDATA | LYS_CONTAINER | LYS_LEAF | LYS_LIST | LYS_LEAFLIST))) {\n                LOGVAL(ctx, LYE_INCHILDSTMT, LY_VLOG_LYS, aug, strnodetype(sub->nodetype), \"augment\");\n                LOGVAL(ctx, LYE_SPEC, LY_VLOG_PREV, NULL, \"Cannot augment \\\"%s\\\" with a \\\"%s\\\".\",\n                       strnodetype(aug->target->nodetype), strnodetype(sub->nodetype));\n                return -1;\n            }\n        }\n    } else {\n        LOGVAL(ctx, LYE_INARG, LY_VLOG_LYS, aug, aug->target_name, \"target-node\");\n        LOGVAL(ctx, LYE_SPEC, LY_VLOG_PREV, NULL, \"Invalid augment target node type \\\"%s\\\".\", strnodetype(aug->target->nodetype));\n        return -1;\n    }\n\n    /* check identifier uniqueness as in lys_node_addchild() */\n    LY_TREE_FOR(aug->child, sub) {\n        if (lys_check_id(sub, aug->target, NULL)) {\n            return -1;\n        }\n    }\n\n    if (!aug->child) {\n        /* empty augment, nothing to connect, but it is techincally applied */\n        LOGWRN(ctx, \"Augment \\\"%s\\\" without children.\", aug->target_name);\n        aug->flags &= ~LYS_NOTAPPLIED;\n    } else if ((aug->parent || mod->implemented) && apply_aug(aug, unres)) {\n        /* we try to connect the augment only in case the module is implemented or\n         * the augment applies on the used grouping, anyway we failed here */\n        return -1;\n    }\n\n    return EXIT_SUCCESS;\n}\n\nstatic int\nresolve_extension(struct unres_ext *info, struct lys_ext_instance **ext, struct unres_schema *unres)\n{\n    enum LY_VLOG_ELEM vlog_type;\n    void *vlog_node;\n    unsigned int i, j;\n    struct lys_ext *e;\n    char *ext_name, *ext_prefix, *tmp;\n    struct lyxml_elem *next_yin, *yin;\n    const struct lys_module *mod;\n    struct lys_ext_instance *tmp_ext;\n    struct ly_ctx *ctx = NULL;\n    LYEXT_TYPE etype;\n\n    switch (info->parent_type) {\n    case LYEXT_PAR_NODE:\n        vlog_node = info->parent;\n        vlog_type = LY_VLOG_LYS;\n        break;\n    case LYEXT_PAR_MODULE:\n    case LYEXT_PAR_IMPORT:\n    case LYEXT_PAR_INCLUDE:\n        vlog_node = NULL;\n        vlog_type = LY_VLOG_LYS;\n        break;\n    default:\n        vlog_node = NULL;\n        vlog_type = LY_VLOG_NONE;\n        break;\n    }\n\n    if (info->datatype == LYS_IN_YIN) {\n        /* YIN */\n\n        /* get the module where the extension is supposed to be defined */\n        mod = lyp_get_import_module_ns(info->mod, info->data.yin->ns->value);\n        if (!mod) {\n            LOGVAL(ctx, LYE_INSTMT, vlog_type, vlog_node, info->data.yin->name);\n            return EXIT_FAILURE;\n        }\n        ctx = mod->ctx;\n\n        /* find the extension definition */\n        e = NULL;\n        for (i = 0; i < mod->extensions_size; i++) {\n            if (ly_strequal(mod->extensions[i].name, info->data.yin->name, 1)) {\n                e = &mod->extensions[i];\n                break;\n            }\n        }\n        /* try submodules */\n        for (j = 0; !e && j < mod->inc_size; j++) {\n            for (i = 0; i < mod->inc[j].submodule->extensions_size; i++) {\n                if (ly_strequal(mod->inc[j].submodule->extensions[i].name, info->data.yin->name, 1)) {\n                    e = &mod->inc[j].submodule->extensions[i];\n                    break;\n                }\n            }\n        }\n        if (!e) {\n            LOGVAL(ctx, LYE_INSTMT, vlog_type, vlog_node, info->data.yin->name);\n            return EXIT_FAILURE;\n        }\n\n        /* we have the extension definition, so now it cannot be forward referenced and error is always fatal */\n\n        if (e->plugin && e->plugin->check_position) {\n            /* common part - we have plugin with position checking function, use it first */\n            if ((*e->plugin->check_position)(info->parent, info->parent_type, info->substmt)) {\n                /* extension is not allowed here */\n                LOGVAL(ctx, LYE_INSTMT, vlog_type, vlog_node, e->name);\n                return -1;\n            }\n        }\n\n        /* extension type-specific part - allocation */\n        if (e->plugin) {\n            etype = e->plugin->type;\n        } else {\n            /* default type */\n            etype = LYEXT_FLAG;\n        }\n        switch (etype) {\n        case LYEXT_FLAG:\n            (*ext) = calloc(1, sizeof(struct lys_ext_instance));\n            break;\n        case LYEXT_COMPLEX:\n            (*ext) = calloc(1, ((struct lyext_plugin_complex*)e->plugin)->instance_size);\n            break;\n        case LYEXT_ERR:\n            /* we never should be here */\n            LOGINT(ctx);\n            return -1;\n        }\n        LY_CHECK_ERR_RETURN(!*ext, LOGMEM(ctx), -1);\n\n        /* common part for all extension types */\n        (*ext)->def = e;\n        (*ext)->parent = info->parent;\n        (*ext)->parent_type = info->parent_type;\n        (*ext)->insubstmt = info->substmt;\n        (*ext)->insubstmt_index = info->substmt_index;\n        (*ext)->ext_type = e->plugin ? e->plugin->type : LYEXT_FLAG;\n        (*ext)->flags |= e->plugin ? e->plugin->flags : 0;\n\n        if (e->argument) {\n            if (!(e->flags & LYS_YINELEM)) {\n                (*ext)->arg_value = lyxml_get_attr(info->data.yin, e->argument, NULL);\n                if (!(*ext)->arg_value) {\n                    LOGVAL(ctx, LYE_MISSARG, LY_VLOG_NONE, NULL, e->argument, info->data.yin->name);\n                    return -1;\n                }\n\n                (*ext)->arg_value = lydict_insert(mod->ctx, (*ext)->arg_value, 0);\n            } else {\n                LY_TREE_FOR_SAFE(info->data.yin->child, next_yin, yin) {\n                    if (ly_strequal(yin->name, e->argument, 1)) {\n                        (*ext)->arg_value = lydict_insert(mod->ctx, yin->content, 0);\n                        lyxml_free(mod->ctx, yin);\n                        break;\n                    }\n                }\n            }\n        }\n\n        if ((*ext)->flags & LYEXT_OPT_VALID &&\n            (info->parent_type == LYEXT_PAR_NODE || info->parent_type == LYEXT_PAR_TPDF)) {\n            ((struct lys_node *)info->parent)->flags |= LYS_VALID_EXT;\n        }\n\n        (*ext)->nodetype = LYS_EXT;\n        (*ext)->module = info->mod;\n\n        /* extension type-specific part - parsing content */\n        switch (etype) {\n        case LYEXT_FLAG:\n            LY_TREE_FOR_SAFE(info->data.yin->child, next_yin, yin) {\n                if (!yin->ns) {\n                    /* garbage */\n                    lyxml_free(mod->ctx, yin);\n                    continue;\n                } else if (!strcmp(yin->ns->value, LY_NSYIN)) {\n                    /* standard YANG statements are not expected here */\n                    LOGVAL(ctx, LYE_INCHILDSTMT, vlog_type, vlog_node, yin->name, info->data.yin->name);\n                    return -1;\n                } else if (yin->ns == info->data.yin->ns &&\n                        (e->flags & LYS_YINELEM) && ly_strequal(yin->name, e->argument, 1)) {\n                    /* we have the extension's argument */\n                    if ((*ext)->arg_value) {\n                        LOGVAL(ctx, LYE_TOOMANY, vlog_type, vlog_node, yin->name, info->data.yin->name);\n                        return -1;\n                    }\n                    (*ext)->arg_value = yin->content;\n                    yin->content = NULL;\n                    lyxml_free(mod->ctx, yin);\n                } else {\n                    /* extension instance */\n                    if (lyp_yin_parse_subnode_ext(info->mod, *ext, LYEXT_PAR_EXTINST, yin,\n                                                  LYEXT_SUBSTMT_SELF, 0, unres)) {\n                        return -1;\n                    }\n\n                    continue;\n                }\n            }\n            break;\n        case LYEXT_COMPLEX:\n            ((struct lys_ext_instance_complex*)(*ext))->substmt = ((struct lyext_plugin_complex*)e->plugin)->substmt;\n            if (lyp_yin_parse_complex_ext(info->mod, (struct lys_ext_instance_complex*)(*ext), info->data.yin, unres)) {\n                /* TODO memory cleanup */\n                return -1;\n            }\n            break;\n        default:\n            break;\n        }\n\n        /* TODO - lyext_check_result_clb, other than LYEXT_FLAG plugins */\n\n    } else {\n        /* YANG */\n\n        ext_prefix = (char *)(*ext)->def;\n        tmp = strchr(ext_prefix, ':');\n        if (!tmp) {\n            LOGVAL(ctx, LYE_INSTMT, vlog_type, vlog_node, ext_prefix);\n            goto error;\n        }\n        ext_name = tmp + 1;\n\n        /* get the module where the extension is supposed to be defined */\n        mod = lyp_get_module(info->mod, ext_prefix, tmp - ext_prefix, NULL, 0, 0);\n        if (!mod) {\n            LOGVAL(ctx, LYE_INSTMT, vlog_type, vlog_node, ext_prefix);\n            return EXIT_FAILURE;\n        }\n        ctx = mod->ctx;\n\n        /* find the extension definition */\n        e = NULL;\n        for (i = 0; i < mod->extensions_size; i++) {\n            if (ly_strequal(mod->extensions[i].name, ext_name, 0)) {\n                e = &mod->extensions[i];\n                break;\n            }\n        }\n        /* try submodules */\n        for (j = 0; !e && j < mod->inc_size; j++) {\n            for (i = 0; i < mod->inc[j].submodule->extensions_size; i++) {\n                if (ly_strequal(mod->inc[j].submodule->extensions[i].name, ext_name, 0)) {\n                    e = &mod->inc[j].submodule->extensions[i];\n                    break;\n                }\n            }\n        }\n        if (!e) {\n            LOGVAL(ctx, LYE_INSTMT, vlog_type, vlog_node, ext_prefix);\n            return EXIT_FAILURE;\n        }\n\n        (*ext)->flags &= ~LYEXT_OPT_YANG;\n        (*ext)->def = NULL;\n\n        /* we have the extension definition, so now it cannot be forward referenced and error is always fatal */\n\n        if (e->plugin && e->plugin->check_position) {\n            /* common part - we have plugin with position checking function, use it first */\n            if ((*e->plugin->check_position)(info->parent, info->parent_type, info->substmt)) {\n                /* extension is not allowed here */\n                LOGVAL(ctx, LYE_INSTMT, vlog_type, vlog_node, e->name);\n                goto error;\n            }\n        }\n\n        if (e->argument && !(*ext)->arg_value) {\n            LOGVAL(ctx, LYE_MISSARG, LY_VLOG_NONE, NULL, e->argument, ext_name);\n            goto error;\n        }\n\n        /* extension common part */\n        (*ext)->def = e;\n        (*ext)->parent = info->parent;\n        (*ext)->ext_type = e->plugin ? e->plugin->type : LYEXT_FLAG;\n        (*ext)->flags |= e->plugin ? e->plugin->flags : 0;\n\n        if ((*ext)->flags & LYEXT_OPT_VALID &&\n            (info->parent_type == LYEXT_PAR_NODE || info->parent_type == LYEXT_PAR_TPDF)) {\n            ((struct lys_node *)info->parent)->flags |= LYS_VALID_EXT;\n        }\n\n        (*ext)->module = info->mod;\n        (*ext)->nodetype = LYS_EXT;\n\n        /* extension type-specific part */\n        if (e->plugin) {\n            etype = e->plugin->type;\n        } else {\n            /* default type */\n            etype = LYEXT_FLAG;\n        }\n        switch (etype) {\n        case LYEXT_FLAG:\n            /* nothing change */\n            break;\n        case LYEXT_COMPLEX:\n            tmp_ext = realloc(*ext, ((struct lyext_plugin_complex*)e->plugin)->instance_size);\n            LY_CHECK_ERR_GOTO(!tmp_ext, LOGMEM(ctx), error);\n            memset((char *)tmp_ext + offsetof(struct lys_ext_instance_complex, content), 0,\n                   ((struct lyext_plugin_complex*)e->plugin)->instance_size - offsetof(struct lys_ext_instance_complex, content));\n            (*ext) = tmp_ext;\n            ((struct lys_ext_instance_complex*)(*ext))->substmt = ((struct lyext_plugin_complex*)e->plugin)->substmt;\n            if (info->data.yang) {\n                *tmp = ':';\n                if (yang_parse_ext_substatement(info->mod, unres, info->data.yang->ext_substmt, ext_prefix,\n                                                (struct lys_ext_instance_complex*)(*ext))) {\n                    goto error;\n                }\n                if (yang_fill_extcomplex_module(info->mod->ctx, (struct lys_ext_instance_complex*)(*ext), ext_prefix,\n                                                info->data.yang->ext_modules, info->mod->implemented)) {\n                    goto error;\n                }\n            }\n            if (lyp_mand_check_ext((struct lys_ext_instance_complex*)(*ext), ext_prefix)) {\n                goto error;\n            }\n            break;\n        case LYEXT_ERR:\n            /* we never should be here */\n            LOGINT(ctx);\n            goto error;\n        }\n\n        if (yang_check_ext_instance(info->mod, &(*ext)->ext, (*ext)->ext_size, *ext, unres)) {\n            goto error;\n        }\n        free(ext_prefix);\n    }\n\n    return EXIT_SUCCESS;\nerror:\n    free(ext_prefix);\n    return -1;\n}\n\n/**\n * @brief Resolve (find) choice default case. Does not log.\n *\n * @param[in] choic Choice to use.\n * @param[in] dflt Name of the default case.\n *\n * @return Pointer to the default node or NULL.\n */\nstatic struct lys_node *\nresolve_choice_dflt(struct lys_node_choice *choic, const char *dflt)\n{\n    struct lys_node *child, *ret;\n\n    LY_TREE_FOR(choic->child, child) {\n        if (child->nodetype == LYS_USES) {\n            ret = resolve_choice_dflt((struct lys_node_choice *)child, dflt);\n            if (ret) {\n                return ret;\n            }\n        }\n\n        if (ly_strequal(child->name, dflt, 1) && (child->nodetype & (LYS_ANYDATA | LYS_CASE\n                | LYS_CONTAINER | LYS_LEAF | LYS_LEAFLIST | LYS_LIST | LYS_CHOICE))) {\n            return child;\n        }\n    }\n\n    return NULL;\n}\n\n/**\n * @brief Resolve uses, apply augments, refines. Logs directly.\n *\n * @param[in] uses Uses to use.\n * @param[in,out] unres List of unresolved items.\n *\n * @return EXIT_SUCCESS on success, -1 on error.\n */\nstatic int\nresolve_uses(struct lys_node_uses *uses, struct unres_schema *unres)\n{\n    struct ly_ctx *ctx = uses->module->ctx; /* shortcut */\n    struct lys_node *node = NULL, *next, *iter, **refine_nodes = NULL;\n    struct lys_node *node_aux, *parent, *tmp;\n    struct lys_node_leaflist *llist;\n    struct lys_node_leaf *leaf;\n    struct lys_refine *rfn;\n    struct lys_restr *must, **old_must;\n    struct lys_iffeature *iff, **old_iff;\n    int i, j, k, rc;\n    uint8_t size, *old_size;\n    unsigned int usize, usize1, usize2;\n\n    assert(uses->grp);\n\n    /* check that the grouping is resolved (no unresolved uses inside) */\n    assert(!uses->grp->unres_count);\n\n    /* copy the data nodes from grouping into the uses context */\n    LY_TREE_FOR(uses->grp->child, node_aux) {\n        if (node_aux->nodetype & LYS_GROUPING) {\n            /* do not instantiate groupings from groupings */\n            continue;\n        }\n        node = lys_node_dup(uses->module, (struct lys_node *)uses, node_aux, unres, 0);\n        if (!node) {\n            LOGVAL(ctx, LYE_INARG, LY_VLOG_LYS, uses, uses->grp->name, \"uses\");\n            LOGVAL(ctx, LYE_SPEC, LY_VLOG_PREV, NULL, \"Copying data from grouping failed.\");\n            goto fail;\n        }\n        /* test the name of siblings */\n        LY_TREE_FOR((uses->parent) ? *lys_child(uses->parent, LYS_USES) : lys_main_module(uses->module)->data, tmp) {\n            if (!(tmp->nodetype & (LYS_USES | LYS_GROUPING | LYS_CASE)) && ly_strequal(tmp->name, node_aux->name, 1)) {\n                goto fail;\n            }\n        }\n    }\n\n    /* we managed to copy the grouping, the rest must be possible to resolve */\n\n    if (uses->refine_size) {\n        refine_nodes = malloc(uses->refine_size * sizeof *refine_nodes);\n        LY_CHECK_ERR_GOTO(!refine_nodes, LOGMEM(ctx), fail);\n    }\n\n    /* apply refines */\n    for (i = 0; i < uses->refine_size; i++) {\n        rfn = &uses->refine[i];\n        rc = resolve_descendant_schema_nodeid(rfn->target_name, uses->child,\n                                              LYS_NO_RPC_NOTIF_NODE | LYS_ACTION | LYS_NOTIF,\n                                              0, (const struct lys_node **)&node);\n        if (rc || !node) {\n            LOGVAL(ctx, LYE_INARG, LY_VLOG_LYS, uses, rfn->target_name, \"refine\");\n            goto fail;\n        }\n\n        if (rfn->target_type && !(node->nodetype & rfn->target_type)) {\n            LOGVAL(ctx, LYE_INARG, LY_VLOG_LYS, uses, rfn->target_name, \"refine\");\n            LOGVAL(ctx, LYE_SPEC, LY_VLOG_PREV, NULL, \"Refine substatements not applicable to the target-node.\");\n            goto fail;\n        }\n        refine_nodes[i] = node;\n\n        /* description on any nodetype */\n        if (rfn->dsc) {\n            lydict_remove(ctx, node->dsc);\n            node->dsc = lydict_insert(ctx, rfn->dsc, 0);\n        }\n\n        /* reference on any nodetype */\n        if (rfn->ref) {\n            lydict_remove(ctx, node->ref);\n            node->ref = lydict_insert(ctx, rfn->ref, 0);\n        }\n\n        /* config on any nodetype,\n         * in case of notification or rpc/action, the config is not applicable (there is no config status) */\n        if ((rfn->flags & LYS_CONFIG_MASK) && (node->flags & LYS_CONFIG_MASK)) {\n            node->flags &= ~LYS_CONFIG_MASK;\n            node->flags |= (rfn->flags & LYS_CONFIG_MASK);\n        }\n\n        /* default value ... */\n        if (rfn->dflt_size) {\n            if (node->nodetype == LYS_LEAF) {\n                /* leaf */\n                leaf = (struct lys_node_leaf *)node;\n\n                /* replace default value */\n                lydict_remove(ctx, leaf->dflt);\n                leaf->dflt = lydict_insert(ctx, rfn->dflt[0], 0);\n\n                /* check the default value */\n                if (unres_schema_add_node(leaf->module, unres, &leaf->type, UNRES_TYPE_DFLT,\n                                          (struct lys_node *)(&leaf->dflt)) == -1) {\n                    goto fail;\n                }\n            } else if (node->nodetype == LYS_LEAFLIST) {\n                /* leaf-list */\n                llist = (struct lys_node_leaflist *)node;\n\n                /* remove complete set of defaults in target */\n                for (j = 0; j < llist->dflt_size; j++) {\n                    lydict_remove(ctx, llist->dflt[j]);\n                }\n                free(llist->dflt);\n\n                /* copy the default set from refine */\n                llist->dflt = malloc(rfn->dflt_size * sizeof *llist->dflt);\n                LY_CHECK_ERR_GOTO(!llist->dflt, LOGMEM(ctx), fail);\n                llist->dflt_size = rfn->dflt_size;\n                for (j = 0; j < llist->dflt_size; j++) {\n                    llist->dflt[j] = lydict_insert(ctx, rfn->dflt[j], 0);\n                }\n\n                /* check default value */\n                for (j = 0; j < llist->dflt_size; j++) {\n                    if (unres_schema_add_node(llist->module, unres, &llist->type, UNRES_TYPE_DFLT,\n                                              (struct lys_node *)(&llist->dflt[j])) == -1) {\n                        goto fail;\n                    }\n                }\n            }\n        }\n\n        /* mandatory on leaf, anyxml or choice */\n        if (rfn->flags & LYS_MAND_MASK) {\n            /* remove current value */\n            node->flags &= ~LYS_MAND_MASK;\n\n            /* set new value */\n            node->flags |= (rfn->flags & LYS_MAND_MASK);\n\n            if (rfn->flags & LYS_MAND_TRUE) {\n                /* check if node has default value */\n                if ((node->nodetype & LYS_LEAF) && ((struct lys_node_leaf *)node)->dflt) {\n                    LOGVAL(ctx, LYE_SPEC, LY_VLOG_LYS, uses,\n                           \"The \\\"mandatory\\\" statement is forbidden on leaf with \\\"default\\\".\");\n                    goto fail;\n                }\n                if ((node->nodetype & LYS_CHOICE) && ((struct lys_node_choice *)node)->dflt) {\n                    LOGVAL(ctx, LYE_SPEC, LY_VLOG_LYS, uses,\n                           \"The \\\"mandatory\\\" statement is forbidden on choices with \\\"default\\\".\");\n                    goto fail;\n                }\n            }\n        }\n\n        /* presence on container */\n        if ((node->nodetype & LYS_CONTAINER) && rfn->mod.presence) {\n            lydict_remove(ctx, ((struct lys_node_container *)node)->presence);\n            ((struct lys_node_container *)node)->presence = lydict_insert(ctx, rfn->mod.presence, 0);\n        }\n\n        /* min/max-elements on list or leaf-list */\n        if (node->nodetype == LYS_LIST) {\n            if (rfn->flags & LYS_RFN_MINSET) {\n                ((struct lys_node_list *)node)->min = rfn->mod.list.min;\n            }\n            if (rfn->flags & LYS_RFN_MAXSET) {\n                ((struct lys_node_list *)node)->max = rfn->mod.list.max;\n            }\n        } else if (node->nodetype == LYS_LEAFLIST) {\n            if (rfn->flags & LYS_RFN_MINSET) {\n                ((struct lys_node_leaflist *)node)->min = rfn->mod.list.min;\n            }\n            if (rfn->flags & LYS_RFN_MAXSET) {\n                ((struct lys_node_leaflist *)node)->max = rfn->mod.list.max;\n            }\n        }\n\n        /* must in leaf, leaf-list, list, container or anyxml */\n        if (rfn->must_size) {\n            switch (node->nodetype) {\n            case LYS_LEAF:\n                old_size = &((struct lys_node_leaf *)node)->must_size;\n                old_must = &((struct lys_node_leaf *)node)->must;\n                break;\n            case LYS_LEAFLIST:\n                old_size = &((struct lys_node_leaflist *)node)->must_size;\n                old_must = &((struct lys_node_leaflist *)node)->must;\n                break;\n            case LYS_LIST:\n                old_size = &((struct lys_node_list *)node)->must_size;\n                old_must = &((struct lys_node_list *)node)->must;\n                break;\n            case LYS_CONTAINER:\n                old_size = &((struct lys_node_container *)node)->must_size;\n                old_must = &((struct lys_node_container *)node)->must;\n                break;\n            case LYS_ANYXML:\n            case LYS_ANYDATA:\n                old_size = &((struct lys_node_anydata *)node)->must_size;\n                old_must = &((struct lys_node_anydata *)node)->must;\n                break;\n            default:\n                LOGINT(ctx);\n                goto fail;\n            }\n\n            size = *old_size + rfn->must_size;\n            must = realloc(*old_must, size * sizeof *rfn->must);\n            LY_CHECK_ERR_GOTO(!must, LOGMEM(ctx), fail);\n            for (k = 0, j = *old_size; k < rfn->must_size; k++, j++) {\n                must[j].ext_size = rfn->must[k].ext_size;\n                lys_ext_dup(ctx, rfn->module, rfn->must[k].ext, rfn->must[k].ext_size, &rfn->must[k], LYEXT_PAR_RESTR,\n                            &must[j].ext, 0, unres);\n                must[j].expr = lydict_insert(ctx, rfn->must[k].expr, 0);\n                must[j].dsc = lydict_insert(ctx, rfn->must[k].dsc, 0);\n                must[j].ref = lydict_insert(ctx, rfn->must[k].ref, 0);\n                must[j].eapptag = lydict_insert(ctx, rfn->must[k].eapptag, 0);\n                must[j].emsg = lydict_insert(ctx, rfn->must[k].emsg, 0);\n                must[j].flags = rfn->must[k].flags;\n            }\n\n            *old_must = must;\n            *old_size = size;\n\n            /* check XPath dependencies again */\n            if (unres_schema_add_node(node->module, unres, node, UNRES_XPATH, NULL) == -1) {\n                goto fail;\n            }\n        }\n\n        /* if-feature in leaf, leaf-list, list, container or anyxml */\n        if (rfn->iffeature_size) {\n            old_size = &node->iffeature_size;\n            old_iff = &node->iffeature;\n\n            size = *old_size + rfn->iffeature_size;\n            iff = realloc(*old_iff, size * sizeof *rfn->iffeature);\n            LY_CHECK_ERR_GOTO(!iff, LOGMEM(ctx), fail);\n            *old_iff = iff;\n\n            for (k = 0, j = *old_size; k < rfn->iffeature_size; k++, j++) {\n                resolve_iffeature_getsizes(&rfn->iffeature[k], &usize1, &usize2);\n                if (usize1) {\n                    /* there is something to duplicate */\n                    /* duplicate compiled expression */\n                    usize = (usize1 / 4) + (usize1 % 4) ? 1 : 0;\n                    iff[j].expr = malloc(usize * sizeof *iff[j].expr);\n                    LY_CHECK_ERR_GOTO(!iff[j].expr, LOGMEM(ctx), fail);\n                    memcpy(iff[j].expr, rfn->iffeature[k].expr, usize * sizeof *iff[j].expr);\n\n                    /* duplicate list of feature pointers */\n                    iff[j].features = malloc(usize2 * sizeof *iff[k].features);\n                    LY_CHECK_ERR_GOTO(!iff[j].expr, LOGMEM(ctx), fail);\n                    memcpy(iff[j].features, rfn->iffeature[k].features, usize2 * sizeof *iff[j].features);\n\n                    /* duplicate extensions */\n                    iff[j].ext_size = rfn->iffeature[k].ext_size;\n                    lys_ext_dup(ctx, rfn->module, rfn->iffeature[k].ext, rfn->iffeature[k].ext_size,\n                                &rfn->iffeature[k], LYEXT_PAR_IFFEATURE, &iff[j].ext, 0, unres);\n                }\n                (*old_size)++;\n            }\n            assert(*old_size == size);\n        }\n    }\n\n    /* apply augments */\n    for (i = 0; i < uses->augment_size; i++) {\n        rc = resolve_augment(&uses->augment[i], (struct lys_node *)uses, unres);\n        if (rc) {\n            goto fail;\n        }\n    }\n\n    /* check refines */\n    for (i = 0; i < uses->refine_size; i++) {\n        node = refine_nodes[i];\n        rfn = &uses->refine[i];\n\n        /* config on any nodetype */\n        if ((rfn->flags & LYS_CONFIG_MASK) && (node->flags & LYS_CONFIG_MASK)) {\n            for (parent = lys_parent(node); parent && parent->nodetype == LYS_USES; parent = lys_parent(parent));\n            if (parent && parent->nodetype != LYS_GROUPING && (parent->flags & LYS_CONFIG_MASK) &&\n                    ((parent->flags & LYS_CONFIG_MASK) != (rfn->flags & LYS_CONFIG_MASK)) &&\n                    (rfn->flags & LYS_CONFIG_W)) {\n                /* setting config true under config false is prohibited */\n                LOGVAL(ctx, LYE_INARG, LY_VLOG_LYS, uses, \"config\", \"refine\");\n                LOGVAL(ctx, LYE_SPEC, LY_VLOG_PREV, NULL,\n                       \"changing config from 'false' to 'true' is prohibited while \"\n                       \"the target's parent is still config 'false'.\");\n                goto fail;\n            }\n\n            /* inherit config change to the target children */\n            LY_TREE_DFS_BEGIN(node->child, next, iter) {\n                if (rfn->flags & LYS_CONFIG_W) {\n                    if (iter->flags & LYS_CONFIG_SET) {\n                        /* config is set explicitely, go to next sibling */\n                        next = NULL;\n                        goto nextsibling;\n                    }\n                } else { /* LYS_CONFIG_R */\n                    if ((iter->flags & LYS_CONFIG_SET) && (iter->flags & LYS_CONFIG_W)) {\n                        /* error - we would have config data under status data */\n                        LOGVAL(ctx, LYE_INARG, LY_VLOG_LYS, uses, \"config\", \"refine\");\n                        LOGVAL(ctx, LYE_SPEC, LY_VLOG_PREV, NULL,\n                               \"changing config from 'true' to 'false' is prohibited while the target \"\n                               \"has still a children with explicit config 'true'.\");\n                        goto fail;\n                    }\n                }\n                /* change config */\n                iter->flags &= ~LYS_CONFIG_MASK;\n                iter->flags |= (rfn->flags & LYS_CONFIG_MASK);\n\n                /* select next iter - modified LY_TREE_DFS_END */\n                if (iter->nodetype & (LYS_LEAF | LYS_LEAFLIST | LYS_ANYDATA)) {\n                    next = NULL;\n                } else {\n                    next = iter->child;\n                }\nnextsibling:\n                if (!next) {\n                    /* try siblings */\n                    next = iter->next;\n                }\n                while (!next) {\n                    /* parent is already processed, go to its sibling */\n                    iter = lys_parent(iter);\n\n                    /* no siblings, go back through parents */\n                    if (iter == node) {\n                        /* we are done, no next element to process */\n                        break;\n                    }\n                    next = iter->next;\n                }\n            }\n        }\n\n        /* default value */\n        if (rfn->dflt_size) {\n            if (node->nodetype == LYS_CHOICE) {\n                /* choice */\n                ((struct lys_node_choice *)node)->dflt = resolve_choice_dflt((struct lys_node_choice *)node,\n                                                                             rfn->dflt[0]);\n                if (!((struct lys_node_choice *)node)->dflt) {\n                    LOGVAL(ctx, LYE_INARG, LY_VLOG_LYS, uses, rfn->dflt[0], \"default\");\n                    goto fail;\n                }\n                if (lyp_check_mandatory_choice(node)) {\n                    goto fail;\n                }\n            }\n        }\n\n        /* min/max-elements on list or leaf-list */\n        if (node->nodetype == LYS_LIST && ((struct lys_node_list *)node)->max) {\n            if (((struct lys_node_list *)node)->min > ((struct lys_node_list *)node)->max) {\n                LOGVAL(ctx, LYE_SPEC, LY_VLOG_LYS, uses, \"Invalid value \\\"%d\\\" of \\\"%s\\\".\", rfn->mod.list.min, \"min-elements\");\n                LOGVAL(ctx, LYE_SPEC, LY_VLOG_PREV, NULL, \"\\\"min-elements\\\" is bigger than \\\"max-elements\\\".\");\n                goto fail;\n            }\n        } else if (node->nodetype == LYS_LEAFLIST && ((struct lys_node_leaflist *)node)->max) {\n            if (((struct lys_node_leaflist *)node)->min > ((struct lys_node_leaflist *)node)->max) {\n                LOGVAL(ctx, LYE_SPEC, LY_VLOG_LYS, uses, \"Invalid value \\\"%d\\\" of \\\"%s\\\".\", rfn->mod.list.min, \"min-elements\");\n                LOGVAL(ctx, LYE_SPEC, LY_VLOG_PREV, NULL, \"\\\"min-elements\\\" is bigger than \\\"max-elements\\\".\");\n                goto fail;\n            }\n        }\n\n        /* additional checks */\n        /* default value with mandatory/min-elements */\n        if (node->nodetype == LYS_LEAFLIST) {\n            llist = (struct lys_node_leaflist *)node;\n            if (llist->dflt_size && llist->min) {\n                LOGVAL(ctx, LYE_INCHILDSTMT, LY_VLOG_LYS, uses, rfn->dflt_size ? \"default\" : \"min-elements\", \"refine\");\n                LOGVAL(ctx, LYE_SPEC, LY_VLOG_PREV, NULL,\n                       \"The \\\"min-elements\\\" statement with non-zero value is forbidden on leaf-lists with the \\\"default\\\" statement.\");\n                goto fail;\n            }\n        } else if (node->nodetype == LYS_LEAF) {\n            leaf = (struct lys_node_leaf *)node;\n            if (leaf->dflt && (leaf->flags & LYS_MAND_TRUE)) {\n                LOGVAL(ctx, LYE_INCHILDSTMT, LY_VLOG_LYS, uses, rfn->dflt_size ? \"default\" : \"mandatory\", \"refine\");\n                LOGVAL(ctx, LYE_SPEC, LY_VLOG_PREV, NULL,\n                       \"The \\\"mandatory\\\" statement is forbidden on leafs with the \\\"default\\\" statement.\");\n                goto fail;\n            }\n        }\n\n        /* check for mandatory node in default case, first find the closest parent choice to the changed node */\n        if ((rfn->flags & LYS_MAND_TRUE) || rfn->mod.list.min) {\n            for (parent = node->parent;\n                 parent && !(parent->nodetype & (LYS_CHOICE | LYS_GROUPING | LYS_ACTION | LYS_USES));\n                 parent = parent->parent) {\n                if (parent->nodetype == LYS_CONTAINER && ((struct lys_node_container *)parent)->presence) {\n                    /* stop also on presence containers */\n                    break;\n                }\n            }\n            /* and if it is a choice with the default case, check it for presence of a mandatory node in it */\n            if (parent && parent->nodetype == LYS_CHOICE && ((struct lys_node_choice *)parent)->dflt) {\n                if (lyp_check_mandatory_choice(parent)) {\n                    goto fail;\n                }\n            }\n        }\n    }\n    free(refine_nodes);\n\n    return EXIT_SUCCESS;\n\nfail:\n    LY_TREE_FOR_SAFE(uses->child, next, iter) {\n        lys_node_free(iter, NULL, 0);\n    }\n    free(refine_nodes);\n    return -1;\n}\n\nvoid\nresolve_identity_backlink_update(struct lys_ident *der, struct lys_ident *base)\n{\n    int i;\n\n    assert(der && base);\n\n    if (!base->der) {\n        /* create a set for backlinks if it does not exist */\n        base->der = ly_set_new();\n    }\n    /* store backlink */\n    ly_set_add(base->der, der, LY_SET_OPT_USEASLIST);\n\n    /* do it recursively */\n    for (i = 0; i < base->base_size; i++) {\n        resolve_identity_backlink_update(der, base->base[i]);\n    }\n}\n\n/**\n * @brief Resolve base identity recursively. Does not log.\n *\n * @param[in] module Main module.\n * @param[in] ident Identity to use.\n * @param[in] basename Base name of the identity.\n * @param[out] ret Pointer to the resolved identity. Can be NULL.\n *\n * @return EXIT_SUCCESS on success, EXIT_FAILURE on forward reference, -1 on crucial error.\n */\nstatic int\nresolve_base_ident_sub(const struct lys_module *module, struct lys_ident *ident, const char *basename,\n                       struct unres_schema *unres, struct lys_ident **ret)\n{\n    uint32_t i, j;\n    struct lys_ident *base = NULL;\n    struct ly_ctx *ctx = module->ctx;\n\n    assert(ret);\n\n    /* search module */\n    for (i = 0; i < module->ident_size; i++) {\n        if (!strcmp(basename, module->ident[i].name)) {\n\n            if (!ident) {\n                /* just search for type, so do not modify anything, just return\n                 * the base identity pointer */\n                *ret = &module->ident[i];\n                return EXIT_SUCCESS;\n            }\n\n            base = &module->ident[i];\n            goto matchfound;\n        }\n    }\n\n    /* search submodules */\n    for (j = 0; j < module->inc_size && module->inc[j].submodule; j++) {\n        for (i = 0; i < module->inc[j].submodule->ident_size; i++) {\n            if (!strcmp(basename, module->inc[j].submodule->ident[i].name)) {\n\n                if (!ident) {\n                    *ret = &module->inc[j].submodule->ident[i];\n                    return EXIT_SUCCESS;\n                }\n\n                base = &module->inc[j].submodule->ident[i];\n                goto matchfound;\n            }\n        }\n    }\n\nmatchfound:\n    /* we found it somewhere */\n    if (base) {\n        /* is it already completely resolved? */\n        for (i = 0; i < unres->count; i++) {\n            if ((unres->item[i] == base) && (unres->type[i] == UNRES_IDENT)) {\n                /* identity found, but not yet resolved, so do not return it in *res and try it again later */\n\n                /* simple check for circular reference,\n                 * the complete check is done as a side effect of using only completely\n                 * resolved identities (previous check of unres content) */\n                if (ly_strequal((const char *)unres->str_snode[i], ident->name, 1)) {\n                    LOGVAL(ctx, LYE_INARG, LY_VLOG_NONE, NULL, basename, \"base\");\n                    LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Circular reference of \\\"%s\\\" identity.\", basename);\n                    return -1;\n                }\n\n                return EXIT_FAILURE;\n            }\n        }\n\n        /* checks done, store the result */\n        *ret = base;\n        return EXIT_SUCCESS;\n    }\n\n    /* base not found (maybe a forward reference) */\n    return EXIT_FAILURE;\n}\n\n/**\n * @brief Resolve base identity. Logs directly.\n *\n * @param[in] module Main module.\n * @param[in] ident Identity to use.\n * @param[in] basename Base name of the identity.\n * @param[in] parent Either \"type\" or \"identity\".\n * @param[in,out] type Type structure where we want to resolve identity. Can be NULL.\n *\n * @return EXIT_SUCCESS on success, EXIT_FAILURE on forward reference, -1 on error.\n */\nstatic int\nresolve_base_ident(const struct lys_module *module, struct lys_ident *ident, const char *basename, const char *parent,\n                   struct lys_type *type, struct unres_schema *unres)\n{\n    const char *name;\n    int mod_name_len = 0, rc;\n    struct lys_ident *target, **ret;\n    uint16_t flags;\n    struct lys_module *mod;\n    struct ly_ctx *ctx = module->ctx;\n\n    assert((ident && !type) || (!ident && type));\n\n    if (!type) {\n        /* have ident to resolve */\n        ret = &target;\n        flags = ident->flags;\n        mod = ident->module;\n    } else {\n        /* have type to fill */\n        ++type->info.ident.count;\n        type->info.ident.ref = ly_realloc(type->info.ident.ref, type->info.ident.count * sizeof *type->info.ident.ref);\n        LY_CHECK_ERR_RETURN(!type->info.ident.ref, LOGMEM(ctx), -1);\n\n        ret = &type->info.ident.ref[type->info.ident.count - 1];\n        flags = type->parent->flags;\n        mod = type->parent->module;\n    }\n    *ret = NULL;\n\n    /* search for the base identity */\n    name = strchr(basename, ':');\n    if (name) {\n        /* set name to correct position after colon */\n        mod_name_len = name - basename;\n        name++;\n\n        if (!strncmp(basename, module->name, mod_name_len) && !module->name[mod_name_len]) {\n            /* prefix refers to the current module, ignore it */\n            mod_name_len = 0;\n        }\n    } else {\n        name = basename;\n    }\n\n    /* get module where to search */\n    module = lyp_get_module(module, NULL, 0, mod_name_len ? basename : NULL, mod_name_len, 0);\n    if (!module) {\n        /* identity refers unknown data model */\n        LOGVAL(ctx, LYE_INMOD, LY_VLOG_NONE, NULL, basename);\n        return -1;\n    }\n\n    /* search in the identified module ... */\n    rc = resolve_base_ident_sub(module, ident, name, unres, ret);\n    if (!rc) {\n        assert(*ret);\n\n        /* check status */\n        if (lyp_check_status(flags, mod, ident ? ident->name : \"of type\",\n                             (*ret)->flags, (*ret)->module, (*ret)->name, NULL)) {\n            rc = -1;\n        } else if (ident) {\n            ident->base[ident->base_size++] = *ret;\n            if (lys_main_module(mod)->implemented) {\n                /* in case of the implemented identity, maintain backlinks to it\n                 * from the base identities to make it available when resolving\n                 * data with the identity values (not implemented identity is not\n                 * allowed as an identityref value). */\n                resolve_identity_backlink_update(ident, *ret);\n            }\n        }\n    } else if (rc == EXIT_FAILURE) {\n        LOGVAL(ctx, LYE_INRESOLV, LY_VLOG_NONE, NULL, parent, basename);\n        if (type) {\n            --type->info.ident.count;\n        }\n    }\n\n    return rc;\n}\n\n/*\n * 1 - true (der is derived from base)\n * 0 - false (der is not derived from base)\n */\nstatic int\nsearch_base_identity(struct lys_ident *der, struct lys_ident *base)\n{\n    int i;\n\n    if (der == base) {\n        return 1;\n    } else {\n        for(i = 0; i < der->base_size; i++) {\n            if (search_base_identity(der->base[i], base) == 1) {\n                return 1;\n            }\n        }\n    }\n\n    return 0;\n}\n\n/**\n * @brief Resolve JSON data format identityref. Logs directly.\n *\n * @param[in] type Identityref type.\n * @param[in] ident_name Identityref name.\n * @param[in] node Node where the identityref is being resolved\n * @param[in] dflt flag if we are resolving default value in the schema\n *\n * @return Pointer to the identity resolvent, NULL on error.\n */\nstruct lys_ident *\nresolve_identref(struct lys_type *type, const char *ident_name, struct lyd_node *node, struct lys_module *mod, int dflt)\n{\n    const char *mod_name, *name;\n    char *str;\n    int mod_name_len, nam_len, rc;\n    int need_implemented = 0;\n    unsigned int i, j;\n    struct lys_ident *der, *cur;\n    struct lys_module *imod = NULL, *m, *tmod;\n    struct ly_ctx *ctx;\n\n    assert(type && ident_name && mod);\n    ctx = mod->ctx;\n\n    if (!type || (!type->info.ident.count && !type->der) || !ident_name) {\n        return NULL;\n    }\n\n    rc = parse_node_identifier(ident_name, &mod_name, &mod_name_len, &name, &nam_len, NULL, 0);\n    if (rc < 1) {\n        LOGVAL(ctx, LYE_INCHAR, node ? LY_VLOG_LYD : LY_VLOG_NONE, node, ident_name[-rc], &ident_name[-rc]);\n        return NULL;\n    } else if (rc < (signed)strlen(ident_name)) {\n        LOGVAL(ctx, LYE_INCHAR, node ? LY_VLOG_LYD : LY_VLOG_NONE, node, ident_name[rc], &ident_name[rc]);\n        return NULL;\n    }\n\n    m = lys_main_module(mod); /* shortcut */\n    if (!mod_name || (!strncmp(mod_name, m->name, mod_name_len) && !m->name[mod_name_len])) {\n        /* identity is defined in the same module as node */\n        imod = m;\n    } else if (dflt) {\n        /* solving identityref in default definition in schema -\n         * find the identity's module in the imported modules list to have a correct revision */\n        for (i = 0; i < mod->imp_size; i++) {\n            if (!strncmp(mod_name, mod->imp[i].module->name, mod_name_len) && !mod->imp[i].module->name[mod_name_len]) {\n                imod = mod->imp[i].module;\n                break;\n            }\n        }\n\n        /* We may need to pull it from the module that the typedef came from */\n        if (!imod && type && type->der) {\n            tmod = type->der->module;\n            for (i = 0; i < tmod->imp_size; i++) {\n                if (!strncmp(mod_name, tmod->imp[i].module->name, mod_name_len) && !tmod->imp[i].module->name[mod_name_len]) {\n                    imod = tmod->imp[i].module;\n                    break;\n                }\n            }\n        }\n    } else {\n        /* solving identityref in data - get the module from the context */\n        for (i = 0; i < (unsigned)mod->ctx->models.used; ++i) {\n            imod = mod->ctx->models.list[i];\n            if (!strncmp(mod_name, imod->name, mod_name_len) && !imod->name[mod_name_len]) {\n                break;\n            }\n            imod = NULL;\n        }\n        if (!imod && mod->ctx->models.parsing_sub_modules_count) {\n            /* we are currently parsing some module and checking XPath or a default value,\n             * so take this module into account */\n            for (i = 0; i < mod->ctx->models.parsing_sub_modules_count; i++) {\n                imod = mod->ctx->models.parsing_sub_modules[i];\n                if (imod->type) {\n                    /* skip submodules */\n                    continue;\n                }\n                if (!strncmp(mod_name, imod->name, mod_name_len) && !imod->name[mod_name_len]) {\n                    break;\n                }\n                imod = NULL;\n            }\n        }\n    }\n\n    if (!dflt && (!imod || !imod->implemented) && ctx->data_clb) {\n        /* the needed module was not found, but it may have been expected so call the data callback */\n        if (imod) {\n            ctx->data_clb(ctx, imod->name, imod->ns, LY_MODCLB_NOT_IMPLEMENTED, ctx->data_clb_data);\n        } else if (mod_name) {\n            str = strndup(mod_name, mod_name_len);\n            imod = (struct lys_module *)ctx->data_clb(ctx, str, NULL, 0, ctx->data_clb_data);\n            free(str);\n        }\n    }\n    if (!imod) {\n        goto fail;\n    }\n\n    if (m != imod || lys_main_module(type->parent->module) != mod) {\n        /* the type is not referencing the same schema,\n         * THEN, we may need to make the module with the identity implemented, but only if it really\n         * contains the identity */\n        if (!imod->implemented) {\n            cur = NULL;\n            /* get the identity in the module */\n            for (i = 0; i < imod->ident_size; i++) {\n                if (!strcmp(name, imod->ident[i].name)) {\n                    cur = &imod->ident[i];\n                    break;\n                }\n            }\n            if (!cur) {\n                /* go through includes */\n                for (j = 0; j < imod->inc_size; j++) {\n                    for (i = 0; i < imod->inc[j].submodule->ident_size; i++) {\n                        if (!strcmp(name, imod->inc[j].submodule->ident[i].name)) {\n                            cur = &imod->inc[j].submodule->ident[i];\n                            break;\n                        }\n                    }\n                }\n                if (!cur) {\n                    goto fail;\n                }\n            }\n\n            /* check that identity is derived from one of the type's base */\n            while (type->der) {\n                for (i = 0; i < type->info.ident.count; i++) {\n                    if (search_base_identity(cur, type->info.ident.ref[i])) {\n                        /* cur's base matches the type's base */\n                        need_implemented = 1;\n                        goto match;\n                    }\n                }\n                type = &type->der->type;\n            }\n            /* matching base not found */\n            LOGVAL(ctx, LYE_SPEC, node ? LY_VLOG_LYD : LY_VLOG_NONE, node, \"Identity used as identityref value is not implemented.\");\n            goto fail;\n        }\n    }\n\n    /* go through all the derived types of all the bases */\n    while (type->der) {\n        for (i = 0; i < type->info.ident.count; ++i) {\n            cur = type->info.ident.ref[i];\n\n            if (cur->der) {\n                /* there are some derived identities */\n                for (j = 0; j < cur->der->number; j++) {\n                    der = (struct lys_ident *)cur->der->set.g[j]; /* shortcut */\n                    if (!strcmp(der->name, name) && lys_main_module(der->module) == imod) {\n                        /* we have match */\n                        cur = der;\n                        goto match;\n                    }\n                }\n            }\n        }\n        type = &type->der->type;\n    }\n\nfail:\n    LOGVAL(ctx, LYE_INRESOLV, node ? LY_VLOG_LYD : LY_VLOG_NONE, node, \"identityref\", ident_name);\n    return NULL;\n\nmatch:\n    for (i = 0; i < cur->iffeature_size; i++) {\n        if (!resolve_iffeature(&cur->iffeature[i])) {\n            if (node) {\n                LOGVAL(ctx, LYE_INVAL, LY_VLOG_LYD, node, cur->name, node->schema->name);\n            }\n            LOGVAL(ctx, LYE_SPEC, LY_VLOG_PREV, NULL, \"Identity \\\"%s\\\" is disabled by its if-feature condition.\", cur->name);\n            return NULL;\n        }\n    }\n    if (need_implemented) {\n        if (dflt) {\n            /* later try to make the module implemented */\n            LOGVRB(\"Making \\\"%s\\\" module implemented because of identityref default value \\\"%s\\\" used in the implemented \\\"%s\\\" module\",\n                   imod->name, cur->name, mod->name);\n            /* to be more effective we should use UNRES_MOD_IMPLEMENT but that would require changing prototype of\n             * several functions with little gain */\n            if (lys_set_implemented(imod)) {\n                LOGERR(ctx, ly_errno, \"Setting the module \\\"%s\\\" implemented because of used default identity \\\"%s\\\" failed.\",\n                       imod->name, cur->name);\n                goto fail;\n            }\n        } else {\n            /* just say that it was found, but in a non-implemented module */\n            LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Identity found, but in a non-implemented module \\\"%s\\\".\",\n                   lys_main_module(cur->module)->name);\n            goto fail;\n        }\n    }\n    return cur;\n}\n\n/**\n * @brief Resolve unresolved uses. Logs directly.\n *\n * @param[in] uses Uses to use.\n * @param[in] unres Specific unres item.\n *\n * @return EXIT_SUCCESS on success, EXIT_FAILURE on forward reference, -1 on error.\n */\nstatic int\nresolve_unres_schema_uses(struct lys_node_uses *uses, struct unres_schema *unres)\n{\n    int rc;\n    struct lys_node *par_grp;\n    struct ly_ctx *ctx = uses->module->ctx;\n\n    /* HACK: when a grouping has uses inside, all such uses have to be resolved before the grouping itself is used\n     *       in some uses. When we see such a uses, the grouping's unres counter is used to store number of so far\n     *       unresolved uses. The grouping cannot be used unless this counter is decreased back to 0. To remember\n     *       that the uses already increased grouping's counter, the LYS_USESGRP flag is used. */\n    for (par_grp = lys_parent((struct lys_node *)uses); par_grp && (par_grp->nodetype != LYS_GROUPING); par_grp = lys_parent(par_grp));\n    if (par_grp && ly_strequal(par_grp->name, uses->name, 1)) {\n        LOGVAL(ctx, LYE_INRESOLV, LY_VLOG_LYS, uses, \"uses\", uses->name);\n        return -1;\n    }\n\n    if (!uses->grp) {\n        rc = resolve_uses_schema_nodeid(uses->name, (const struct lys_node *)uses, (const struct lys_node_grp **)&uses->grp);\n        if (rc == -1) {\n            LOGVAL(ctx, LYE_INRESOLV, LY_VLOG_LYS, uses, \"uses\", uses->name);\n            return -1;\n        } else if (rc > 0) {\n            LOGVAL(ctx, LYE_INCHAR, LY_VLOG_LYS, uses, uses->name[rc - 1], &uses->name[rc - 1]);\n            return -1;\n        } else if (!uses->grp) {\n            if (par_grp && !(uses->flags & LYS_USESGRP)) {\n                if (++((struct lys_node_grp *)par_grp)->unres_count == 0) {\n                    LOGERR(ctx, LY_EINT, \"Too many unresolved items (uses) inside a grouping.\");\n                    return -1;\n                }\n                uses->flags |= LYS_USESGRP;\n            }\n            LOGVAL(ctx, LYE_INRESOLV, LY_VLOG_LYS, uses, \"uses\", uses->name);\n            return EXIT_FAILURE;\n        }\n    }\n\n    if (uses->grp->unres_count) {\n        if (par_grp && !(uses->flags & LYS_USESGRP)) {\n            if (++((struct lys_node_grp *)par_grp)->unres_count == 0) {\n                LOGERR(ctx, LY_EINT, \"Too many unresolved items (uses) inside a grouping.\");\n                return -1;\n            }\n            uses->flags |= LYS_USESGRP;\n        } else {\n            /* instantiate grouping only when it is completely resolved */\n            uses->grp = NULL;\n        }\n        LOGVAL(ctx, LYE_INRESOLV, LY_VLOG_LYS, uses, \"uses\", uses->name);\n        return EXIT_FAILURE;\n    }\n\n    rc = resolve_uses(uses, unres);\n    if (!rc) {\n        /* decrease unres count only if not first try */\n        if (par_grp && (uses->flags & LYS_USESGRP)) {\n            assert(((struct lys_node_grp *)par_grp)->unres_count);\n            ((struct lys_node_grp *)par_grp)->unres_count--;\n            uses->flags &= ~LYS_USESGRP;\n        }\n\n        /* check status */\n        if (lyp_check_status(uses->flags, uses->module, \"of uses\",\n                         uses->grp->flags, uses->grp->module, uses->grp->name,\n                         (struct lys_node *)uses)) {\n            return -1;\n        }\n\n        return EXIT_SUCCESS;\n    }\n\n    return rc;\n}\n\n/**\n * @brief Resolve list keys. Logs directly.\n *\n * @param[in] list List to use.\n * @param[in] keys_str Keys node value.\n *\n * @return EXIT_SUCCESS on success, EXIT_FAILURE on forward reference, -1 on error.\n */\nstatic int\nresolve_list_keys(struct lys_node_list *list, const char *keys_str)\n{\n    int i, len, rc;\n    const char *value;\n    char *s = NULL;\n    struct ly_ctx *ctx = list->module->ctx;\n\n    for (i = 0; i < list->keys_size; ++i) {\n        assert(keys_str);\n\n        if (!list->child) {\n            /* no child, possible forward reference */\n            LOGVAL(ctx, LYE_INRESOLV, LY_VLOG_LYS, list, \"list keys\", keys_str);\n            return EXIT_FAILURE;\n        }\n        /* get the key name */\n        if ((value = strpbrk(keys_str, \" \\t\\n\"))) {\n            len = value - keys_str;\n            while (isspace(value[0])) {\n                value++;\n            }\n        } else {\n            len = strlen(keys_str);\n        }\n\n        rc = lys_getnext_data(lys_node_module((struct lys_node *)list), (struct lys_node *)list, keys_str, len, LYS_LEAF,\n                              LYS_GETNEXT_NOSTATECHECK, (const struct lys_node **)&list->keys[i]);\n        if (rc) {\n            LOGVAL(ctx, LYE_INRESOLV, LY_VLOG_LYS, list, \"list key\", keys_str);\n            return EXIT_FAILURE;\n        }\n\n        if (check_key(list, i, keys_str, len)) {\n            /* check_key logs */\n            return -1;\n        }\n\n        /* check status */\n        if (lyp_check_status(list->flags, list->module, list->name,\n                             list->keys[i]->flags, list->keys[i]->module, list->keys[i]->name,\n                             (struct lys_node *)list->keys[i])) {\n            return -1;\n        }\n\n        /* default value - is ignored, keep it but print a warning */\n        if (list->keys[i]->dflt) {\n            /* log is not hidden only in case this resolving fails and in such a case\n             * we cannot get here\n             */\n            assert(log_opt == ILO_STORE);\n            log_opt = ILO_LOG;\n            LOGWRN(ctx, \"Default value \\\"%s\\\" in the list key \\\"%s\\\" is ignored. (%s)\", list->keys[i]->dflt,\n                   list->keys[i]->name, s = lys_path((struct lys_node*)list, LYS_PATH_FIRST_PREFIX));\n            log_opt = ILO_STORE;\n            free(s);\n        }\n\n        /* prepare for next iteration */\n        while (value && isspace(value[0])) {\n            value++;\n        }\n        keys_str = value;\n    }\n\n    return EXIT_SUCCESS;\n}\n\n/**\n * @brief Resolve (check) all must conditions of \\p node.\n * Logs directly.\n *\n * @param[in] node Data node with optional must statements.\n * @param[in] inout_parent If set, must in input or output parent of node->schema will be resolved.\n *\n * @return EXIT_SUCCESS on pass, EXIT_FAILURE on fail, -1 on error.\n */\nstatic int\nresolve_must(struct lyd_node *node, int inout_parent, int ignore_fail)\n{\n    uint8_t i, must_size;\n    struct lys_node *schema;\n    struct lys_restr *must;\n    struct lyxp_set set;\n    struct ly_ctx *ctx = node->schema->module->ctx;\n\n    assert(node);\n    memset(&set, 0, sizeof set);\n\n    if (inout_parent) {\n        for (schema = lys_parent(node->schema);\n             schema && (schema->nodetype & (LYS_CHOICE | LYS_CASE | LYS_USES));\n             schema = lys_parent(schema));\n        if (!schema || !(schema->nodetype & (LYS_INPUT | LYS_OUTPUT))) {\n            LOGINT(ctx);\n            return -1;\n        }\n        must_size = ((struct lys_node_inout *)schema)->must_size;\n        must = ((struct lys_node_inout *)schema)->must;\n\n        /* context node is the RPC/action */\n        node = node->parent;\n        if (!(node->schema->nodetype & (LYS_RPC | LYS_ACTION))) {\n            LOGINT(ctx);\n            return -1;\n        }\n    } else {\n        switch (node->schema->nodetype) {\n        case LYS_CONTAINER:\n            must_size = ((struct lys_node_container *)node->schema)->must_size;\n            must = ((struct lys_node_container *)node->schema)->must;\n            break;\n        case LYS_LEAF:\n            must_size = ((struct lys_node_leaf *)node->schema)->must_size;\n            must = ((struct lys_node_leaf *)node->schema)->must;\n            break;\n        case LYS_LEAFLIST:\n            must_size = ((struct lys_node_leaflist *)node->schema)->must_size;\n            must = ((struct lys_node_leaflist *)node->schema)->must;\n            break;\n        case LYS_LIST:\n            must_size = ((struct lys_node_list *)node->schema)->must_size;\n            must = ((struct lys_node_list *)node->schema)->must;\n            break;\n        case LYS_ANYXML:\n        case LYS_ANYDATA:\n            must_size = ((struct lys_node_anydata *)node->schema)->must_size;\n            must = ((struct lys_node_anydata *)node->schema)->must;\n            break;\n        case LYS_NOTIF:\n            must_size = ((struct lys_node_notif *)node->schema)->must_size;\n            must = ((struct lys_node_notif *)node->schema)->must;\n            break;\n        default:\n            must_size = 0;\n            break;\n        }\n    }\n\n    for (i = 0; i < must_size; ++i) {\n        if (lyxp_eval(must[i].expr, node, LYXP_NODE_ELEM, lyd_node_module(node), &set, LYXP_MUST)) {\n            return -1;\n        }\n\n        lyxp_set_cast(&set, LYXP_SET_BOOLEAN, node, lyd_node_module(node), LYXP_MUST);\n\n        if (!set.val.bool) {\n            if ((ignore_fail == 1) || ((must[i].flags & (LYS_XPCONF_DEP | LYS_XPSTATE_DEP)) && (ignore_fail == 2))) {\n                LOGVRB(\"Must condition \\\"%s\\\" not satisfied, but it is not required.\", must[i].expr);\n            } else {\n                LOGVAL(ctx, LYE_NOMUST, LY_VLOG_LYD, node, must[i].expr);\n                if (must[i].emsg) {\n                    ly_vlog_str(ctx, LY_VLOG_PREV, must[i].emsg);\n                }\n                if (must[i].eapptag) {\n                    ly_err_last_set_apptag(ctx, must[i].eapptag);\n                }\n                return 1;\n            }\n        }\n    }\n\n    return EXIT_SUCCESS;\n}\n\n/**\n * @brief Resolve (find) when condition schema context node. Does not log.\n *\n * @param[in] schema Schema node with the when condition.\n * @param[out] ctx_snode When schema context node.\n * @param[out] ctx_snode_type Schema context node type.\n */\nvoid\nresolve_when_ctx_snode(const struct lys_node *schema, struct lys_node **ctx_snode, enum lyxp_node_type *ctx_snode_type)\n{\n    const struct lys_node *sparent;\n\n    /* find a not schema-only node */\n    *ctx_snode_type = LYXP_NODE_ELEM;\n    while (schema->nodetype & (LYS_USES | LYS_CHOICE | LYS_CASE | LYS_AUGMENT | LYS_INPUT | LYS_OUTPUT)) {\n        if (schema->nodetype == LYS_AUGMENT) {\n            sparent = ((struct lys_node_augment *)schema)->target;\n        } else {\n            sparent = schema->parent;\n        }\n        if (!sparent) {\n            /* context node is the document root (fake root in our case) */\n            if (schema->flags & LYS_CONFIG_W) {\n                *ctx_snode_type = LYXP_NODE_ROOT_CONFIG;\n            } else {\n                *ctx_snode_type = LYXP_NODE_ROOT;\n            }\n            /* we need the first top-level sibling, but no uses or groupings */\n            schema = lys_getnext(NULL, NULL, lys_node_module(schema), LYS_GETNEXT_NOSTATECHECK);\n            break;\n        }\n        schema = sparent;\n    }\n\n    *ctx_snode = (struct lys_node *)schema;\n}\n\n/**\n * @brief Resolve (find) when condition context node. Does not log.\n *\n * @param[in] node Data node, whose conditional definition is being decided.\n * @param[in] schema Schema node with the when condition.\n * @param[out] ctx_node Context node.\n * @param[out] ctx_node_type Context node type.\n *\n * @return EXIT_SUCCESS on success, -1 on error.\n */\nstatic int\nresolve_when_ctx_node(struct lyd_node *node, struct lys_node *schema, struct lyd_node **ctx_node,\n                      enum lyxp_node_type *ctx_node_type)\n{\n    struct lyd_node *parent;\n    struct lys_node *sparent;\n    enum lyxp_node_type node_type;\n    uint16_t i, data_depth, schema_depth;\n\n    resolve_when_ctx_snode(schema, &schema, &node_type);\n\n    if (node_type == LYXP_NODE_ELEM) {\n        /* standard element context node */\n        for (parent = node, data_depth = 0; parent; parent = parent->parent, ++data_depth);\n        for (sparent = schema, schema_depth = 0;\n                sparent;\n                sparent = (sparent->nodetype == LYS_AUGMENT ? ((struct lys_node_augment *)sparent)->target : sparent->parent)) {\n            if (sparent->nodetype & (LYS_CONTAINER | LYS_LEAF | LYS_LEAFLIST | LYS_LIST | LYS_ANYDATA | LYS_NOTIF | LYS_RPC)) {\n                ++schema_depth;\n            }\n        }\n        if (data_depth < schema_depth) {\n            return -1;\n        }\n\n        /* find the corresponding data node */\n        for (i = 0; i < data_depth - schema_depth; ++i) {\n            node = node->parent;\n        }\n        if (node->schema != schema) {\n            return -1;\n        }\n    } else {\n        /* root context node */\n        while (node->parent) {\n            node = node->parent;\n        }\n        while (node->prev->next) {\n            node = node->prev;\n        }\n    }\n\n    *ctx_node = node;\n    *ctx_node_type = node_type;\n    return EXIT_SUCCESS;\n}\n\n/**\n * @brief Temporarily unlink nodes as per YANG 1.1 RFC section 7.21.5 for when XPath evaluation.\n * The context node is adjusted if needed.\n *\n * @param[in] snode Schema node, whose children instances need to be unlinked.\n * @param[in,out] node Data siblings where to look for the children of \\p snode. If it is unlinked,\n * it is moved to point to another sibling still in the original tree.\n * @param[in,out] ctx_node When context node, adjusted if needed.\n * @param[in] ctx_node_type Context node type, just for information to detect invalid situations.\n * @param[out] unlinked_nodes Unlinked siblings. Can be safely appended to \\p node afterwards.\n * Ordering may change, but there will be no semantic change.\n *\n * @return EXIT_SUCCESS on success, -1 on error.\n */\nstatic int\nresolve_when_unlink_nodes(struct lys_node *snode, struct lyd_node **node, struct lyd_node **ctx_node,\n                          enum lyxp_node_type ctx_node_type, struct lyd_node **unlinked_nodes)\n{\n    struct lyd_node *next, *elem;\n    const struct lys_node *slast;\n    struct ly_ctx *ctx = snode->module->ctx;\n\n    switch (snode->nodetype) {\n    case LYS_AUGMENT:\n    case LYS_USES:\n    case LYS_CHOICE:\n    case LYS_CASE:\n        slast = NULL;\n        while ((slast = lys_getnext(slast, snode, NULL, LYS_GETNEXT_PARENTUSES))) {\n            if (slast->nodetype & (LYS_ACTION | LYS_NOTIF)) {\n                continue;\n            }\n\n            if (resolve_when_unlink_nodes((struct lys_node *)slast, node, ctx_node, ctx_node_type, unlinked_nodes)) {\n                return -1;\n            }\n        }\n        break;\n    case LYS_CONTAINER:\n    case LYS_LIST:\n    case LYS_LEAF:\n    case LYS_LEAFLIST:\n    case LYS_ANYXML:\n    case LYS_ANYDATA:\n        LY_TREE_FOR_SAFE(lyd_first_sibling(*node), next, elem) {\n            if (elem->schema == snode) {\n\n                if (elem == *ctx_node) {\n                    /* We are going to unlink our context node! This normally cannot happen,\n                     * but we use normal top-level data nodes for faking a document root node,\n                     * so if this is the context node, we just use the next top-level node.\n                     * Additionally, it can even happen that there are no top-level data nodes left,\n                     * all were unlinked, so in this case we pass NULL as the context node/data tree,\n                     * lyxp_eval() can handle this special situation.\n                     */\n                    if (ctx_node_type == LYXP_NODE_ELEM) {\n                        LOGINT(ctx);\n                        return -1;\n                    }\n\n                    if (elem->prev == elem) {\n                        /* unlinking last top-level element, use an empty data tree */\n                        *ctx_node = NULL;\n                    } else {\n                        /* in this case just use the previous/last top-level data node */\n                        *ctx_node = elem->prev;\n                    }\n                } else if (elem == *node) {\n                    /* We are going to unlink the currently processed node. This does not matter that\n                     * much, but we would lose access to the original data tree, so just move our\n                     * pointer somewhere still inside it.\n                     */\n                    if ((*node)->prev != *node) {\n                        *node = (*node)->prev;\n                    } else {\n                        /* the processed node with sibings were all unlinked, oh well */\n                        *node = NULL;\n                    }\n                }\n\n                /* temporarily unlink the node */\n                lyd_unlink_internal(elem, 0);\n                if (*unlinked_nodes) {\n                    if (lyd_insert_after((*unlinked_nodes)->prev, elem)) {\n                        LOGINT(ctx);\n                        return -1;\n                    }\n                } else {\n                    *unlinked_nodes = elem;\n                }\n\n                if (snode->nodetype & (LYS_CONTAINER | LYS_LEAF | LYS_ANYDATA)) {\n                    /* there can be only one instance */\n                    break;\n                }\n            }\n        }\n        break;\n    default:\n        LOGINT(ctx);\n        return -1;\n    }\n\n    return EXIT_SUCCESS;\n}\n\n/**\n * @brief Relink the unlinked nodes back.\n *\n * @param[in] node Data node to link the nodes back to. It can actually be the adjusted context node,\n * we simply need a sibling from the original data tree.\n * @param[in] unlinked_nodes Unlinked nodes to relink to \\p node.\n * @param[in] ctx_node_type Context node type to distinguish between \\p node being the parent\n * or the sibling of \\p unlinked_nodes.\n *\n * @return EXIT_SUCCESS on success, -1 on error.\n */\nstatic int\nresolve_when_relink_nodes(struct lyd_node *node, struct lyd_node *unlinked_nodes, enum lyxp_node_type ctx_node_type)\n{\n    struct lyd_node *elem;\n\n    LY_TREE_FOR_SAFE(unlinked_nodes, unlinked_nodes, elem) {\n        lyd_unlink_internal(elem, 0);\n        if (ctx_node_type == LYXP_NODE_ELEM) {\n            if (lyd_insert_common(node, NULL, elem, 0)) {\n                return -1;\n            }\n        } else {\n            if (lyd_insert_nextto(node, elem, 0, 0)) {\n                return -1;\n            }\n        }\n    }\n\n    return EXIT_SUCCESS;\n}\n\nint\nresolve_applies_must(const struct lyd_node *node)\n{\n    int ret = 0;\n    uint8_t must_size;\n    struct lys_node *schema, *iter;\n\n    assert(node);\n\n    schema = node->schema;\n\n    /* their own must */\n    switch (schema->nodetype) {\n    case LYS_CONTAINER:\n        must_size = ((struct lys_node_container *)schema)->must_size;\n        break;\n    case LYS_LEAF:\n        must_size = ((struct lys_node_leaf *)schema)->must_size;\n        break;\n    case LYS_LEAFLIST:\n        must_size = ((struct lys_node_leaflist *)schema)->must_size;\n        break;\n    case LYS_LIST:\n        must_size = ((struct lys_node_list *)schema)->must_size;\n        break;\n    case LYS_ANYXML:\n    case LYS_ANYDATA:\n        must_size = ((struct lys_node_anydata *)schema)->must_size;\n        break;\n    case LYS_NOTIF:\n        must_size = ((struct lys_node_notif *)schema)->must_size;\n        break;\n    default:\n        must_size = 0;\n        break;\n    }\n\n    if (must_size) {\n        ++ret;\n    }\n\n    /* schema may be a direct data child of input/output with must (but it must be first, it needs to be evaluated only once) */\n    if (!node->prev->next) {\n        for (iter = lys_parent(schema); iter && (iter->nodetype & (LYS_CHOICE | LYS_CASE | LYS_USES)); iter = lys_parent(iter));\n        if (iter && (iter->nodetype & (LYS_INPUT | LYS_OUTPUT))) {\n            ret += 0x2;\n        }\n    }\n\n    return ret;\n}\n\nstatic struct lys_when *\nsnode_get_when(const struct lys_node *schema)\n{\n    switch (schema->nodetype) {\n    case LYS_CONTAINER:\n        return ((struct lys_node_container *)schema)->when;\n    case LYS_CHOICE:\n        return ((struct lys_node_choice *)schema)->when;\n    case LYS_LEAF:\n        return ((struct lys_node_leaf *)schema)->when;\n    case LYS_LEAFLIST:\n        return ((struct lys_node_leaflist *)schema)->when;\n    case LYS_LIST:\n        return ((struct lys_node_list *)schema)->when;\n    case LYS_ANYDATA:\n    case LYS_ANYXML:\n        return ((struct lys_node_anydata *)schema)->when;\n    case LYS_CASE:\n        return ((struct lys_node_case *)schema)->when;\n    case LYS_USES:\n        return ((struct lys_node_uses *)schema)->when;\n    case LYS_AUGMENT:\n        return ((struct lys_node_augment *)schema)->when;\n    default:\n        return NULL;\n    }\n}\n\nint\nresolve_applies_when(const struct lys_node *schema, int mode, const struct lys_node *stop)\n{\n    const struct lys_node *parent;\n\n    assert(schema);\n\n    if (!(schema->nodetype & (LYS_NOTIF | LYS_RPC)) && snode_get_when(schema)) {\n        return 1;\n    }\n\n    parent = schema;\n    goto check_augment;\n\n    while (parent) {\n        /* stop conditions */\n        if (!mode) {\n            /* stop on node that can be instantiated in data tree */\n            if (!(parent->nodetype & (LYS_USES | LYS_CHOICE | LYS_CASE))) {\n                break;\n            }\n        } else {\n            /* stop on the specified node */\n            if (parent == stop) {\n                break;\n            }\n        }\n\n        if (snode_get_when(parent)) {\n            return 1;\n        }\ncheck_augment:\n\n        if (parent->parent && (parent->parent->nodetype == LYS_AUGMENT) && snode_get_when(parent->parent)) {\n            return 1;\n        }\n        parent = lys_parent(parent);\n    }\n\n    return 0;\n}\n\n/**\n * @brief Resolve (check) all when conditions relevant for \\p node.\n * Logs directly.\n *\n * @param[in] node Data node, whose conditional reference, if such, is being decided.\n * @param[in] ignore_fail 1 if when does not have to be satisfied, 2 if it does not have to be satisfied\n * only when requiring external dependencies.\n *\n * @return\n *  -1 - error, ly_errno is set\n *   0 - all \"when\" statements true\n *   0, ly_vecode = LYVE_NOWHEN - some \"when\" statement false, returned in failed_when\n *   1, ly_vecode = LYVE_INWHEN - nodes needed to resolve are conditional and not yet resolved (under another \"when\")\n */\nint\nresolve_when(struct lyd_node *node, int ignore_fail, struct lys_when **failed_when)\n{\n    struct lyd_node *ctx_node = NULL, *unlinked_nodes, *tmp_node;\n    struct lys_node *sparent;\n    struct lyxp_set set;\n    enum lyxp_node_type ctx_node_type;\n    struct ly_ctx *ctx = node->schema->module->ctx;\n    int rc = 0;\n\n    assert(node);\n    memset(&set, 0, sizeof set);\n\n    if (!(node->schema->nodetype & (LYS_NOTIF | LYS_RPC | LYS_ACTION)) && snode_get_when(node->schema)) {\n        /* make the node dummy for the evaluation */\n        node->validity |= LYD_VAL_INUSE;\n        rc = lyxp_eval(snode_get_when(node->schema)->cond, node, LYXP_NODE_ELEM, lyd_node_module(node),\n                       &set, LYXP_WHEN);\n        node->validity &= ~LYD_VAL_INUSE;\n        if (rc) {\n            if (rc == 1) {\n                LOGVAL(ctx, LYE_INWHEN, LY_VLOG_LYD, node, snode_get_when(node->schema)->cond);\n            }\n            goto cleanup;\n        }\n\n        /* set boolean result of the condition */\n        lyxp_set_cast(&set, LYXP_SET_BOOLEAN, node, lyd_node_module(node), LYXP_WHEN);\n        if (!set.val.bool) {\n            node->when_status |= LYD_WHEN_FALSE;\n            if ((ignore_fail == 1) || ((snode_get_when(node->schema)->flags & (LYS_XPCONF_DEP | LYS_XPSTATE_DEP))\n                    && (ignore_fail == 2))) {\n                LOGVRB(\"When condition \\\"%s\\\" is not satisfied, but it is not required.\", snode_get_when(node->schema)->cond);\n            } else {\n                LOGVAL(ctx, LYE_NOWHEN, LY_VLOG_LYD, node, snode_get_when(node->schema)->cond);\n                if (failed_when) {\n                    *failed_when = snode_get_when(node->schema);\n                }\n                goto cleanup;\n            }\n        }\n\n        /* free xpath set content */\n        lyxp_set_cast(&set, LYXP_SET_EMPTY, node, lyd_node_module(node), 0);\n    }\n\n    sparent = node->schema;\n    goto check_augment;\n\n    /* check when in every schema node that affects node */\n    while (sparent && (sparent->nodetype & (LYS_USES | LYS_CHOICE | LYS_CASE))) {\n        if (snode_get_when(sparent)) {\n            if (!ctx_node) {\n                rc = resolve_when_ctx_node(node, sparent, &ctx_node, &ctx_node_type);\n                if (rc) {\n                    LOGINT(ctx);\n                    goto cleanup;\n                }\n            }\n\n            unlinked_nodes = NULL;\n            /* we do not want our node pointer to change */\n            tmp_node = node;\n            rc = resolve_when_unlink_nodes(sparent, &tmp_node, &ctx_node, ctx_node_type, &unlinked_nodes);\n            if (rc) {\n                goto cleanup;\n            }\n\n            rc = lyxp_eval(snode_get_when(sparent)->cond, ctx_node, ctx_node_type, lys_node_module(sparent),\n                           &set, LYXP_WHEN);\n\n            if (unlinked_nodes && ctx_node) {\n                if (resolve_when_relink_nodes(ctx_node, unlinked_nodes, ctx_node_type)) {\n                    rc = -1;\n                    goto cleanup;\n                }\n            }\n\n            if (rc) {\n                if (rc == 1) {\n                    LOGVAL(ctx, LYE_INWHEN, LY_VLOG_LYD, node, snode_get_when(sparent)->cond);\n                }\n                goto cleanup;\n            }\n\n            lyxp_set_cast(&set, LYXP_SET_BOOLEAN, ctx_node, lys_node_module(sparent), LYXP_WHEN);\n            if (!set.val.bool) {\n                if ((ignore_fail == 1) || ((snode_get_when(sparent)->flags & (LYS_XPCONF_DEP | LYS_XPSTATE_DEP))\n                        && (ignore_fail == 2))) {\n                    LOGVRB(\"When condition \\\"%s\\\" is not satisfied, but it is not required.\", snode_get_when(sparent)->cond);\n                } else {\n                    node->when_status |= LYD_WHEN_FALSE;\n                    LOGVAL(ctx, LYE_NOWHEN, LY_VLOG_LYD, node, snode_get_when(sparent)->cond);\n                    if (failed_when) {\n                        *failed_when = snode_get_when(sparent);\n                    }\n                    goto cleanup;\n                }\n            }\n\n            /* free xpath set content */\n            lyxp_set_cast(&set, LYXP_SET_EMPTY, ctx_node, lys_node_module(sparent), 0);\n        }\n\ncheck_augment:\n        if ((sparent->parent && (sparent->parent->nodetype == LYS_AUGMENT) && snode_get_when(sparent->parent))) {\n            if (!ctx_node) {\n                rc = resolve_when_ctx_node(node, sparent->parent, &ctx_node, &ctx_node_type);\n                if (rc) {\n                    LOGINT(ctx);\n                    goto cleanup;\n                }\n            }\n\n            unlinked_nodes = NULL;\n            tmp_node = node;\n            rc = resolve_when_unlink_nodes(sparent->parent, &tmp_node, &ctx_node, ctx_node_type, &unlinked_nodes);\n            if (rc) {\n                goto cleanup;\n            }\n\n            rc = lyxp_eval(snode_get_when(sparent->parent)->cond, ctx_node, ctx_node_type,\n                           lys_node_module(sparent->parent), &set, LYXP_WHEN);\n\n            /* reconnect nodes, if ctx_node is NULL then all the nodes were unlinked, but linked together,\n             * so the tree did not actually change and there is nothing for us to do\n             */\n            if (unlinked_nodes && ctx_node) {\n                if (resolve_when_relink_nodes(ctx_node, unlinked_nodes, ctx_node_type)) {\n                    rc = -1;\n                    goto cleanup;\n                }\n            }\n\n            if (rc) {\n                if (rc == 1) {\n                    LOGVAL(ctx, LYE_INWHEN, LY_VLOG_LYD, node, snode_get_when(sparent->parent)->cond);\n                }\n                goto cleanup;\n            }\n\n            lyxp_set_cast(&set, LYXP_SET_BOOLEAN, ctx_node, lys_node_module(sparent->parent), LYXP_WHEN);\n            if (!set.val.bool) {\n                node->when_status |= LYD_WHEN_FALSE;\n                if ((ignore_fail == 1) || ((snode_get_when(sparent->parent)->flags & (LYS_XPCONF_DEP | LYS_XPSTATE_DEP))\n                        && (ignore_fail == 2))) {\n                    LOGVRB(\"When condition \\\"%s\\\" is not satisfied, but it is not required.\",\n                           snode_get_when(sparent->parent)->cond);\n                } else {\n                    LOGVAL(ctx, LYE_NOWHEN, LY_VLOG_LYD, node, snode_get_when(sparent->parent)->cond);\n                    if (failed_when) {\n                        *failed_when = snode_get_when(sparent->parent);\n                    }\n                    goto cleanup;\n                }\n            }\n\n            /* free xpath set content */\n            lyxp_set_cast(&set, LYXP_SET_EMPTY, ctx_node, lys_node_module(sparent->parent), 0);\n        }\n\n        sparent = lys_parent(sparent);\n    }\n\n    node->when_status |= LYD_WHEN_TRUE;\n\ncleanup:\n    /* free xpath set content */\n    lyxp_set_cast(&set, LYXP_SET_EMPTY, ctx_node ? ctx_node : node, NULL, 0);\n    return rc;\n}\n\nstatic int\ncheck_type_union_leafref(struct lys_type *type)\n{\n    uint8_t i;\n\n    if ((type->base == LY_TYPE_UNION) && type->info.uni.count) {\n        /* go through unions and look for leafref */\n        for (i = 0; i < type->info.uni.count; ++i) {\n            switch (type->info.uni.types[i].base) {\n            case LY_TYPE_LEAFREF:\n                return 1;\n            case LY_TYPE_UNION:\n                if (check_type_union_leafref(&type->info.uni.types[i])) {\n                    return 1;\n                }\n                break;\n            default:\n                break;\n            }\n        }\n\n        return 0;\n    }\n\n    /* just inherit the flag value */\n    return type->der->has_union_leafref;\n}\n\n/**\n * @brief Resolve a single unres schema item. Logs indirectly.\n *\n * @param[in] mod Main module.\n * @param[in] item Item to resolve. Type determined by \\p type.\n * @param[in] type Type of the unresolved item.\n * @param[in] str_snode String, a schema node, or NULL.\n * @param[in] unres Unres schema structure to use.\n * @param[in] final_fail Whether we are just printing errors of the failed unres items.\n *\n * @return EXIT_SUCCESS on success, EXIT_FAILURE on forward reference, -1 on error.\n */\nstatic int\nresolve_unres_schema_item(struct lys_module *mod, void *item, enum UNRES_ITEM type, void *str_snode,\n                          struct unres_schema *unres)\n{\n    /* has_str - whether the str_snode is a string in a dictionary that needs to be freed */\n    int rc = -1, has_str = 0, parent_type = 0, i, k;\n    unsigned int j;\n    struct ly_ctx * ctx = mod->ctx;\n    struct lys_node *root, *next, *node, *par_grp;\n    const char *expr;\n    uint8_t *u;\n\n    struct ly_set *refs, *procs;\n    struct lys_feature *ref, *feat;\n    struct lys_ident *ident;\n    struct lys_type *stype;\n    struct lys_node_choice *choic;\n    struct lyxml_elem *yin;\n    struct yang_type *yang;\n    struct unres_list_uniq *unique_info;\n    struct unres_iffeat_data *iff_data;\n    struct unres_ext *ext_data;\n    struct lys_ext_instance *ext, **extlist;\n    struct lyext_plugin *eplugin;\n\n    switch (type) {\n    case UNRES_IDENT:\n        expr = str_snode;\n        has_str = 1;\n        ident = item;\n\n        rc = resolve_base_ident(mod, ident, expr, \"identity\", NULL, unres);\n        break;\n    case UNRES_TYPE_IDENTREF:\n        expr = str_snode;\n        has_str = 1;\n        stype = item;\n\n        rc = resolve_base_ident(mod, NULL, expr, \"type\", stype, unres);\n        break;\n    case UNRES_TYPE_LEAFREF:\n        node = str_snode;\n        stype = item;\n\n        rc = resolve_schema_leafref(stype, node, unres);\n        break;\n    case UNRES_TYPE_DER_EXT:\n        parent_type++;\n        /* falls through */\n    case UNRES_TYPE_DER_TPDF:\n        parent_type++;\n        /* falls through */\n    case UNRES_TYPE_DER:\n        /* parent */\n        node = str_snode;\n        stype = item;\n\n        /* HACK type->der is temporarily unparsed type statement */\n        yin = (struct lyxml_elem *)stype->der;\n        stype->der = NULL;\n\n        if (yin->flags & LY_YANG_STRUCTURE_FLAG) {\n            yang = (struct yang_type *)yin;\n            rc = yang_check_type(mod, node, yang, stype, parent_type, unres);\n\n            if (rc) {\n                /* may try again later */\n                stype->der = (struct lys_tpdf *)yang;\n            } else {\n                /* we need to always be able to free this, it's safe only in this case */\n                lydict_remove(ctx, yang->name);\n                free(yang);\n            }\n\n        } else {\n            rc = fill_yin_type(mod, node, yin, stype, parent_type, unres);\n            if (!rc || rc == -1) {\n                /* we need to always be able to free this, it's safe only in this case */\n                lyxml_free(ctx, yin);\n            } else {\n                /* may try again later, put all back how it was */\n                stype->der = (struct lys_tpdf *)yin;\n            }\n        }\n        if (rc == EXIT_SUCCESS) {\n            /* it does not make sense to have leaf-list of empty type */\n            if (!parent_type && node->nodetype == LYS_LEAFLIST && stype->base == LY_TYPE_EMPTY) {\n                LOGWRN(ctx, \"The leaf-list \\\"%s\\\" is of \\\"empty\\\" type, which does not make sense.\", node->name);\n            }\n\n            if ((type == UNRES_TYPE_DER_TPDF) && (stype->base == LY_TYPE_UNION)) {\n                /* fill typedef union leafref flag */\n                ((struct lys_tpdf *)stype->parent)->has_union_leafref = check_type_union_leafref(stype);\n            } else if ((type == UNRES_TYPE_DER) && stype->der->has_union_leafref) {\n                /* copy the type in case it has union leafref flag */\n                if (lys_copy_union_leafrefs(mod, node, stype, NULL, unres)) {\n                    LOGERR(ctx, LY_EINT, \"Failed to duplicate type.\");\n                    return -1;\n                }\n            }\n        } else if (rc == EXIT_FAILURE && !(stype->value_flags & LY_VALUE_UNRESGRP)) {\n            /* forward reference - in case the type is in grouping, we have to make the grouping unusable\n             * by uses statement until the type is resolved. We do that the same way as uses statements inside\n             * grouping. The grouping cannot be used unless the unres counter is 0.\n             * To remember that the grouping already increased the counter, the LYTYPE_GRP is used as value\n             * of the type's base member. */\n            for (par_grp = node; par_grp && (par_grp->nodetype != LYS_GROUPING); par_grp = lys_parent(par_grp));\n            if (par_grp) {\n                if (++((struct lys_node_grp *)par_grp)->unres_count == 0) {\n                    LOGERR(ctx, LY_EINT, \"Too many unresolved items (type) inside a grouping.\");\n                    return -1;\n                }\n                stype->value_flags |= LY_VALUE_UNRESGRP;\n            }\n        }\n        break;\n    case UNRES_IFFEAT:\n        iff_data = str_snode;\n        rc = resolve_feature(iff_data->fname, strlen(iff_data->fname), iff_data->node, item);\n        if (!rc) {\n            /* success */\n            if (iff_data->infeature) {\n                /* store backlink into the target feature to allow reverse changes in case of changing feature status */\n                feat = *((struct lys_feature **)item);\n                if (!feat->depfeatures) {\n                    feat->depfeatures = ly_set_new();\n                }\n                ly_set_add(feat->depfeatures, iff_data->node, LY_SET_OPT_USEASLIST);\n            }\n            /* cleanup temporary data */\n            lydict_remove(ctx, iff_data->fname);\n            free(iff_data);\n        }\n        break;\n    case UNRES_FEATURE:\n        feat = (struct lys_feature *)item;\n\n        if (feat->iffeature_size) {\n            refs = ly_set_new();\n            procs = ly_set_new();\n            ly_set_add(procs, feat, 0);\n\n            while (procs->number) {\n                ref = procs->set.g[procs->number - 1];\n                ly_set_rm_index(procs, procs->number - 1);\n\n                for (i = 0; i < ref->iffeature_size; i++) {\n                    resolve_iffeature_getsizes(&ref->iffeature[i], NULL, &j);\n                    for (; j > 0 ; j--) {\n                        if (ref->iffeature[i].features[j - 1]) {\n                            if (ref->iffeature[i].features[j - 1] == feat) {\n                                LOGVAL(ctx, LYE_CIRC_FEATURES, LY_VLOG_NONE, NULL, feat->name);\n                                goto featurecheckdone;\n                            }\n\n                            if (ref->iffeature[i].features[j - 1]->iffeature_size) {\n                                k = refs->number;\n                                if (ly_set_add(refs, ref->iffeature[i].features[j - 1], 0) == k) {\n                                    /* not yet seen feature, add it for processing */\n                                    ly_set_add(procs, ref->iffeature[i].features[j - 1], 0);\n                                }\n                            }\n                        } else {\n                            /* forward reference */\n                            rc = EXIT_FAILURE;\n                            goto featurecheckdone;\n                        }\n                    }\n\n                }\n            }\n            rc = EXIT_SUCCESS;\n\nfeaturecheckdone:\n            ly_set_free(refs);\n            ly_set_free(procs);\n        }\n\n        break;\n    case UNRES_USES:\n        rc = resolve_unres_schema_uses(item, unres);\n        break;\n    case UNRES_TYPEDEF_DFLT:\n        parent_type++;\n        /* falls through */\n    case UNRES_TYPE_DFLT:\n        stype = item;\n        rc = check_default(stype, (const char **)str_snode, mod, parent_type);\n        if ((rc == EXIT_FAILURE) && !parent_type && (stype->base == LY_TYPE_LEAFREF)) {\n            for (par_grp = (struct lys_node *)stype->parent;\n                 par_grp && (par_grp->nodetype != LYS_GROUPING);\n                 par_grp = lys_parent(par_grp));\n            if (par_grp) {\n                /* checking default value in a grouping finished with forward reference means we cannot check the value */\n                rc = EXIT_SUCCESS;\n            }\n        }\n        break;\n    case UNRES_CHOICE_DFLT:\n        expr = str_snode;\n        has_str = 1;\n        choic = item;\n\n        if (!choic->dflt) {\n            choic->dflt = resolve_choice_dflt(choic, expr);\n        }\n        if (choic->dflt) {\n            rc = lyp_check_mandatory_choice((struct lys_node *)choic);\n        } else {\n            rc = EXIT_FAILURE;\n        }\n        break;\n    case UNRES_LIST_KEYS:\n        rc = resolve_list_keys(item, ((struct lys_node_list *)item)->keys_str);\n        break;\n    case UNRES_LIST_UNIQ:\n        unique_info = (struct unres_list_uniq *)item;\n        rc = resolve_unique(unique_info->list, unique_info->expr, unique_info->trg_type);\n        break;\n    case UNRES_AUGMENT:\n        rc = resolve_augment(item, NULL, unres);\n        break;\n    case UNRES_XPATH:\n        node = (struct lys_node *)item;\n        rc = check_xpath(node, 1);\n        break;\n    case UNRES_MOD_IMPLEMENT:\n        rc = lys_make_implemented_r(mod, unres);\n        break;\n    case UNRES_EXT:\n        ext_data = (struct unres_ext *)str_snode;\n        extlist = &(*(struct lys_ext_instance ***)item)[ext_data->ext_index];\n        rc = resolve_extension(ext_data, extlist, unres);\n        if (!rc) {\n            /* success */\n            /* is there a callback to be done to finalize the extension? */\n            eplugin = extlist[0]->def->plugin;\n            if (eplugin) {\n                if (eplugin->check_result || (eplugin->flags & LYEXT_OPT_INHERIT)) {\n                    u = malloc(sizeof *u);\n                    LY_CHECK_ERR_RETURN(!u, LOGMEM(ctx), -1);\n                    (*u) = ext_data->ext_index;\n                    if (unres_schema_add_node(mod, unres, item, UNRES_EXT_FINALIZE, (struct lys_node *)u) == -1) {\n                        /* something really bad happend since the extension finalization is not actually\n                         * being resolved while adding into unres, so something more serious with the unres\n                         * list itself must happened */\n                        return -1;\n                    }\n                }\n            }\n        }\n        if (!rc || rc == -1) {\n            /* cleanup on success or fatal error */\n            if (ext_data->datatype == LYS_IN_YIN) {\n                /* YIN */\n                lyxml_free(ctx, ext_data->data.yin);\n            } else {\n                /* YANG */\n                yang_free_ext_data(ext_data->data.yang);\n            }\n            free(ext_data);\n        }\n        break;\n    case UNRES_EXT_FINALIZE:\n        u = (uint8_t *)str_snode;\n        ext = (*(struct lys_ext_instance ***)item)[*u];\n        free(u);\n\n        eplugin = ext->def->plugin;\n\n        /* inherit */\n        if ((eplugin->flags & LYEXT_OPT_INHERIT) && (ext->parent_type == LYEXT_PAR_NODE)) {\n            root = (struct lys_node *)ext->parent;\n            if (!(root->nodetype & (LYS_LEAF | LYS_LEAFLIST | LYS_ANYDATA))) {\n                LY_TREE_DFS_BEGIN(root->child, next, node) {\n                    /* first, check if the node already contain instance of the same extension,\n                     * in such a case we won't inherit. In case the node was actually defined as\n                     * augment data, we are supposed to check the same way also the augment node itself */\n                    if (lys_ext_instance_presence(ext->def, node->ext, node->ext_size) != -1) {\n                        goto inherit_dfs_sibling;\n                    } else if (node->parent != root && node->parent->nodetype == LYS_AUGMENT &&\n                            lys_ext_instance_presence(ext->def, node->parent->ext, node->parent->ext_size) != -1) {\n                        goto inherit_dfs_sibling;\n                    }\n\n                    if (eplugin->check_inherit) {\n                        /* we have a callback to check the inheritance, use it */\n                        switch ((rc = (*eplugin->check_inherit)(ext, node))) {\n                        case 0:\n                            /* yes - continue with the inheriting code */\n                            break;\n                        case 1:\n                            /* no - continue with the node's sibling */\n                            goto inherit_dfs_sibling;\n                        case 2:\n                            /* no, but continue with the children, just skip the inheriting code for this node */\n                            goto inherit_dfs_child;\n                        default:\n                            LOGERR(ctx, LY_EINT, \"Plugin's (%s:%s) check_inherit callback returns invalid value (%d),\",\n                                   ext->def->module->name, ext->def->name, rc);\n                        }\n                    }\n\n                    /* inherit the extension */\n                    extlist = realloc(node->ext, (node->ext_size + 1) * sizeof *node->ext);\n                    LY_CHECK_ERR_RETURN(!extlist, LOGMEM(ctx), -1);\n                    extlist[node->ext_size] = malloc(sizeof **extlist);\n                    LY_CHECK_ERR_RETURN(!extlist[node->ext_size], LOGMEM(ctx); node->ext = extlist, -1);\n                    memcpy(extlist[node->ext_size], ext, sizeof *ext);\n                    extlist[node->ext_size]->flags |= LYEXT_OPT_INHERIT;\n\n                    node->ext = extlist;\n                    node->ext_size++;\n\ninherit_dfs_child:\n                    /* modification of - select element for the next run - children first */\n                    if (node->nodetype & (LYS_LEAF | LYS_LEAFLIST | LYS_ANYDATA)) {\n                        next = NULL;\n                    } else {\n                        next = node->child;\n                    }\n                    if (!next) {\ninherit_dfs_sibling:\n                        /* no children, try siblings */\n                        next = node->next;\n                    }\n                    while (!next) {\n                        /* go to the parent */\n                        node = lys_parent(node);\n\n                        /* we are done if we are back in the root (the starter's parent */\n                        if (node == root) {\n                            break;\n                        }\n\n                        /* parent is already processed, go to its sibling */\n                        next = node->next;\n                    }\n                }\n            }\n        }\n\n        /* final check */\n        if (eplugin->check_result) {\n            if ((*eplugin->check_result)(ext)) {\n                LOGERR(ctx, LY_EPLUGIN, \"Resolving extension failed.\");\n                return -1;\n            }\n        }\n\n        rc = 0;\n        break;\n    default:\n        LOGINT(ctx);\n        break;\n    }\n\n    if (has_str && !rc) {\n        /* the string is no more needed in case of success.\n         * In case of forward reference, we will try to resolve the string later */\n        lydict_remove(ctx, str_snode);\n    }\n\n    return rc;\n}\n\n/* logs directly */\nstatic void\nprint_unres_schema_item_fail(void *item, enum UNRES_ITEM type, void *str_node)\n{\n    struct lyxml_elem *xml;\n    struct lyxml_attr *attr;\n    struct unres_iffeat_data *iff_data;\n    const char *name = NULL;\n    struct unres_ext *extinfo;\n\n    switch (type) {\n    case UNRES_IDENT:\n        LOGVRB(\"Resolving %s \\\"%s\\\" failed, it will be attempted later.\", \"identity\", (char *)str_node);\n        break;\n    case UNRES_TYPE_IDENTREF:\n        LOGVRB(\"Resolving %s \\\"%s\\\" failed, it will be attempted later.\", \"identityref\", (char *)str_node);\n        break;\n    case UNRES_TYPE_LEAFREF:\n        LOGVRB(\"Resolving %s \\\"%s\\\" failed, it will be attempted later.\", \"leafref\",\n               ((struct lys_type *)item)->info.lref.path);\n        break;\n    case UNRES_TYPE_DER_EXT:\n    case UNRES_TYPE_DER_TPDF:\n    case UNRES_TYPE_DER:\n        xml = (struct lyxml_elem *)((struct lys_type *)item)->der;\n        if (xml->flags & LY_YANG_STRUCTURE_FLAG) {\n            name = ((struct yang_type *)xml)->name;\n        } else {\n            LY_TREE_FOR(xml->attr, attr) {\n                if ((attr->type == LYXML_ATTR_STD) && !strcmp(attr->name, \"name\")) {\n                    name = attr->value;\n                    break;\n                }\n            }\n            assert(attr);\n        }\n        LOGVRB(\"Resolving %s \\\"%s\\\" failed, it will be attempted later.\", \"derived type\", name);\n        break;\n    case UNRES_IFFEAT:\n        iff_data = str_node;\n        LOGVRB(\"Resolving %s \\\"%s\\\" failed, it will be attempted later.\", \"if-feature\", iff_data->fname);\n        break;\n    case UNRES_FEATURE:\n        LOGVRB(\"There are unresolved if-features for \\\"%s\\\" feature circular dependency check, it will be attempted later\",\n               ((struct lys_feature *)item)->name);\n        break;\n    case UNRES_USES:\n        LOGVRB(\"Resolving %s \\\"%s\\\" failed, it will be attempted later.\", \"uses\", ((struct lys_node_uses *)item)->name);\n        break;\n    case UNRES_TYPEDEF_DFLT:\n    case UNRES_TYPE_DFLT:\n        if (*(char **)str_node) {\n            LOGVRB(\"Resolving %s \\\"%s\\\" failed, it will be attempted later.\", \"type default\", *(char **)str_node);\n        }   /* else no default value in the type itself, but we are checking some restrictions against\n             *  possible default value of some base type. The failure is caused by not resolved base type,\n             *  so it was already reported */\n        break;\n    case UNRES_CHOICE_DFLT:\n        LOGVRB(\"Resolving %s \\\"%s\\\" failed, it will be attempted later.\", \"choice default\", (char *)str_node);\n        break;\n    case UNRES_LIST_KEYS:\n        LOGVRB(\"Resolving %s \\\"%s\\\" failed, it will be attempted later.\", \"list keys\", (char *)str_node);\n        break;\n    case UNRES_LIST_UNIQ:\n        LOGVRB(\"Resolving %s \\\"%s\\\" failed, it will be attempted later.\", \"list unique\", (char *)str_node);\n        break;\n    case UNRES_AUGMENT:\n        LOGVRB(\"Resolving %s \\\"%s\\\" failed, it will be attempted later.\", \"augment target\",\n               ((struct lys_node_augment *)item)->target_name);\n        break;\n    case UNRES_XPATH:\n        LOGVRB(\"Resolving %s \\\"%s\\\" failed, it will be attempted later.\", \"XPath expressions of\",\n               ((struct lys_node *)item)->name);\n        break;\n    case UNRES_EXT:\n        extinfo = (struct unres_ext *)str_node;\n        name = extinfo->datatype == LYS_IN_YIN ? extinfo->data.yin->name : NULL; /* TODO YANG extension */\n        LOGVRB(\"Resolving extension \\\"%s\\\" failed, it will be attempted later.\", name);\n        break;\n    default:\n        LOGINT(NULL);\n        break;\n    }\n}\n\nstatic int\nresolve_unres_schema_types(struct unres_schema *unres, enum UNRES_ITEM types, struct ly_ctx *ctx, int forward_ref,\n                           int print_all_errors, uint32_t *resolved)\n{\n    uint32_t i, unres_count, res_count;\n    int ret = 0, rc;\n    struct ly_err_item *prev_eitem;\n    enum int_log_opts prev_ilo;\n    LY_ERR prev_ly_errno;\n\n    /* if there can be no forward references, every failure is final, so we can print it directly */\n    if (forward_ref) {\n        prev_ly_errno = ly_errno;\n        ly_ilo_change(ctx, ILO_STORE, &prev_ilo, &prev_eitem);\n    }\n\n    do {\n        unres_count = 0;\n        res_count = 0;\n\n        for (i = 0; i < unres->count; ++i) {\n            /* UNRES_TYPE_LEAFREF must be resolved (for storing leafref target pointers);\n             * if-features are resolved here to make sure that we will have all if-features for\n             * later check of feature circular dependency */\n            if (unres->type[i] & types) {\n                ++unres_count;\n                rc = resolve_unres_schema_item(unres->module[i], unres->item[i], unres->type[i], unres->str_snode[i], unres);\n                if (unres->type[i] == UNRES_EXT_FINALIZE) {\n                    /* to avoid double free */\n                    unres->type[i] = UNRES_RESOLVED;\n                }\n                if (!rc || (unres->type[i] == UNRES_XPATH)) {\n                    /* invalid XPath can never cause an error, only a warning */\n                    if (unres->type[i] == UNRES_LIST_UNIQ) {\n                        /* free the allocated structure */\n                        free(unres->item[i]);\n                    }\n\n                    unres->type[i] = UNRES_RESOLVED;\n                    ++(*resolved);\n                    ++res_count;\n                } else if ((rc == EXIT_FAILURE) && forward_ref) {\n                    /* forward reference, erase errors */\n                    ly_err_free_next(ctx, prev_eitem);\n                } else if (print_all_errors) {\n                    /* just so that we quit the loop */\n                    ++res_count;\n                    ret = -1;\n                } else {\n                    if (forward_ref) {\n                        ly_ilo_restore(ctx, prev_ilo, prev_eitem, 1);\n                    }\n                    return -1;\n                }\n            }\n        }\n    } while (res_count && (res_count < unres_count));\n\n    if (res_count < unres_count) {\n        assert(forward_ref);\n        /* just print the errors (but we must free the ones we have and get them again :-/ ) */\n        ly_ilo_restore(ctx, prev_ilo, prev_eitem, 0);\n\n        for (i = 0; i < unres->count; ++i) {\n            if (unres->type[i] & types) {\n                resolve_unres_schema_item(unres->module[i], unres->item[i], unres->type[i], unres->str_snode[i], unres);\n            }\n        }\n        return -1;\n    }\n\n    if (forward_ref) {\n        /* restore log */\n        ly_ilo_restore(ctx, prev_ilo, prev_eitem, 0);\n        ly_errno = prev_ly_errno;\n    }\n\n    return ret;\n}\n\n/**\n * @brief Resolve every unres schema item in the structure. Logs directly.\n *\n * @param[in] mod Main module.\n * @param[in] unres Unres schema structure to use.\n *\n * @return EXIT_SUCCESS on success, -1 on error.\n */\nint\nresolve_unres_schema(struct lys_module *mod, struct unres_schema *unres)\n{\n    uint32_t resolved = 0;\n\n    assert(unres);\n\n    LOGVRB(\"Resolving \\\"%s\\\" unresolved schema nodes and their constraints...\", mod->name);\n\n    /* UNRES_TYPE_LEAFREF must be resolved (for storing leafref target pointers);\n     * if-features are resolved here to make sure that we will have all if-features for\n     * later check of feature circular dependency */\n    if (resolve_unres_schema_types(unres, UNRES_USES | UNRES_IFFEAT | UNRES_TYPE_DER | UNRES_TYPE_DER_TPDF | UNRES_TYPE_DER_TPDF\n                                   | UNRES_TYPE_LEAFREF | UNRES_MOD_IMPLEMENT | UNRES_AUGMENT | UNRES_CHOICE_DFLT | UNRES_IDENT,\n                                   mod->ctx, 1, 0, &resolved)) {\n        return -1;\n    }\n\n    /* another batch of resolved items */\n    if (resolve_unres_schema_types(unres, UNRES_TYPE_IDENTREF | UNRES_FEATURE | UNRES_TYPEDEF_DFLT | UNRES_TYPE_DFLT\n                                   | UNRES_LIST_KEYS | UNRES_LIST_UNIQ | UNRES_EXT, mod->ctx, 1, 0, &resolved)) {\n        return -1;\n    }\n\n    /* print xpath warnings and finalize extensions, keep it last to provide the complete schema tree information to the plugin's checkers */\n    if (resolve_unres_schema_types(unres, UNRES_XPATH | UNRES_EXT_FINALIZE, mod->ctx, 0, 1, &resolved)) {\n        return -1;\n    }\n\n    LOGVRB(\"All \\\"%s\\\" schema nodes and constraints resolved.\", mod->name);\n    unres->count = 0;\n    return EXIT_SUCCESS;\n}\n\n/**\n * @brief Try to resolve an unres schema item with a string argument. Logs indirectly.\n *\n * @param[in] mod Main module.\n * @param[in] unres Unres schema structure to use.\n * @param[in] item Item to resolve. Type determined by \\p type.\n * @param[in] type Type of the unresolved item.\n * @param[in] str String argument.\n *\n * @return EXIT_SUCCESS on success, EXIT_FAILURE on storing the item in unres, -1 on error.\n */\nint\nunres_schema_add_str(struct lys_module *mod, struct unres_schema *unres, void *item, enum UNRES_ITEM type,\n                     const char *str)\n{\n    int rc;\n    const char *dictstr;\n\n    dictstr = lydict_insert(mod->ctx, str, 0);\n    rc = unres_schema_add_node(mod, unres, item, type, (struct lys_node *)dictstr);\n\n    if (rc < 0) {\n        lydict_remove(mod->ctx, dictstr);\n    }\n    return rc;\n}\n\n/**\n * @brief Try to resolve an unres schema item with a schema node argument. Logs indirectly.\n *\n * @param[in] mod Main module.\n * @param[in] unres Unres schema structure to use.\n * @param[in] item Item to resolve. Type determined by \\p type.\n * @param[in] type Type of the unresolved item. UNRES_TYPE_DER is handled specially!\n * @param[in] snode Schema node argument.\n *\n * @return EXIT_SUCCESS on success, EXIT_FAILURE on storing the item in unres, -1 on error.\n */\nint\nunres_schema_add_node(struct lys_module *mod, struct unres_schema *unres, void *item, enum UNRES_ITEM type,\n                      struct lys_node *snode)\n{\n    int rc;\n    uint32_t u;\n    enum int_log_opts prev_ilo;\n    struct ly_err_item *prev_eitem;\n    LY_ERR prev_ly_errno;\n    struct lyxml_elem *yin;\n    struct ly_ctx *ctx = mod->ctx;\n\n    assert(unres && (item || (type == UNRES_MOD_IMPLEMENT)) && ((type != UNRES_LEAFREF) && (type != UNRES_INSTID)\n           && (type != UNRES_WHEN) && (type != UNRES_MUST)));\n\n    /* check for duplicities in unres */\n    for (u = 0; u < unres->count; u++) {\n        if (unres->type[u] == type && unres->item[u] == item &&\n                unres->str_snode[u] == snode && unres->module[u] == mod) {\n            /* duplication can happen when the node contains multiple statements of the same type to check,\n             * this can happen for example when refinement is being applied, so we just postpone the processing\n             * and do not duplicate the information */\n            return EXIT_FAILURE;\n        }\n    }\n\n    if ((type == UNRES_EXT_FINALIZE) || (type == UNRES_XPATH) || (type == UNRES_MOD_IMPLEMENT)) {\n        /* extension finalization is not even tried when adding the item into the inres list,\n         * xpath is not tried because it would hide some potential warnings,\n         * implementing module must be deferred because some other nodes can be added that will need to be traversed\n         * and their targets made implemented */\n        rc = EXIT_FAILURE;\n    } else {\n        prev_ly_errno = ly_errno;\n        ly_ilo_change(ctx, ILO_STORE, &prev_ilo, &prev_eitem);\n\n        rc = resolve_unres_schema_item(mod, item, type, snode, unres);\n        if (rc != EXIT_FAILURE) {\n            ly_ilo_restore(ctx, prev_ilo, prev_eitem, rc == -1 ? 1 : 0);\n            if (rc != -1) {\n                ly_errno = prev_ly_errno;\n            }\n\n            if (type == UNRES_LIST_UNIQ) {\n                /* free the allocated structure */\n                free(item);\n            } else if (rc == -1 && type == UNRES_IFFEAT) {\n                /* free the allocated resources */\n                free(*((char **)item));\n            }\n            return rc;\n        } else {\n            /* erase info about validation errors */\n            ly_ilo_restore(ctx, prev_ilo, prev_eitem, 0);\n            ly_errno = prev_ly_errno;\n        }\n\n        print_unres_schema_item_fail(item, type, snode);\n\n        /* HACK unlinking is performed here so that we do not do any (NS) copying in vain */\n        if (type == UNRES_TYPE_DER || type == UNRES_TYPE_DER_TPDF) {\n            yin = (struct lyxml_elem *)((struct lys_type *)item)->der;\n            if (!(yin->flags & LY_YANG_STRUCTURE_FLAG)) {\n                lyxml_unlink_elem(mod->ctx, yin, 1);\n                ((struct lys_type *)item)->der = (struct lys_tpdf *)yin;\n            }\n        }\n    }\n\n    unres->count++;\n    unres->item = ly_realloc(unres->item, unres->count*sizeof *unres->item);\n    LY_CHECK_ERR_RETURN(!unres->item, LOGMEM(ctx), -1);\n    unres->item[unres->count-1] = item;\n    unres->type = ly_realloc(unres->type, unres->count*sizeof *unres->type);\n    LY_CHECK_ERR_RETURN(!unres->type, LOGMEM(ctx), -1);\n    unres->type[unres->count-1] = type;\n    unres->str_snode = ly_realloc(unres->str_snode, unres->count*sizeof *unres->str_snode);\n    LY_CHECK_ERR_RETURN(!unres->str_snode, LOGMEM(ctx), -1);\n    unres->str_snode[unres->count-1] = snode;\n    unres->module = ly_realloc(unres->module, unres->count*sizeof *unres->module);\n    LY_CHECK_ERR_RETURN(!unres->module, LOGMEM(ctx), -1);\n    unres->module[unres->count-1] = mod;\n\n    return rc;\n}\n\n/**\n * @brief Duplicate an unres schema item. Logs indirectly.\n *\n * @param[in] mod Main module.\n * @param[in] unres Unres schema structure to use.\n * @param[in] item Old item to be resolved.\n * @param[in] type Type of the old unresolved item.\n * @param[in] new_item New item to use in the duplicate.\n *\n * @return EXIT_SUCCESS on success, EXIT_FAILURE if item is not in unres, -1 on error.\n */\nint\nunres_schema_dup(struct lys_module *mod, struct unres_schema *unres, void *item, enum UNRES_ITEM type, void *new_item)\n{\n    int i;\n    struct unres_list_uniq aux_uniq;\n    struct unres_iffeat_data *iff_data;\n\n    assert(item && new_item && ((type != UNRES_LEAFREF) && (type != UNRES_INSTID) && (type != UNRES_WHEN)));\n\n    /* hack for UNRES_LIST_UNIQ, which stores multiple items behind its item */\n    if (type == UNRES_LIST_UNIQ) {\n        aux_uniq.list = item;\n        aux_uniq.expr = ((struct unres_list_uniq *)new_item)->expr;\n        item = &aux_uniq;\n    }\n    i = unres_schema_find(unres, -1, item, type);\n\n    if (i == -1) {\n        if (type == UNRES_LIST_UNIQ) {\n            free(new_item);\n        }\n        return EXIT_FAILURE;\n    }\n\n    if ((type == UNRES_TYPE_LEAFREF) || (type == UNRES_USES) || (type == UNRES_TYPE_DFLT) ||\n            (type == UNRES_FEATURE) || (type == UNRES_LIST_UNIQ)) {\n        if (unres_schema_add_node(mod, unres, new_item, type, unres->str_snode[i]) == -1) {\n            LOGINT(mod->ctx);\n            return -1;\n        }\n    } else if (type == UNRES_IFFEAT) {\n        /* duplicate unres_iffeature_data */\n        iff_data = malloc(sizeof *iff_data);\n        LY_CHECK_ERR_RETURN(!iff_data, LOGMEM(mod->ctx), -1);\n        iff_data->fname = lydict_insert(mod->ctx, ((struct unres_iffeat_data *)unres->str_snode[i])->fname, 0);\n        iff_data->node = ((struct unres_iffeat_data *)unres->str_snode[i])->node;\n        if (unres_schema_add_node(mod, unres, new_item, type, (struct lys_node *)iff_data) == -1) {\n            LOGINT(mod->ctx);\n            return -1;\n        }\n    } else {\n        if (unres_schema_add_str(mod, unres, new_item, type, unres->str_snode[i]) == -1) {\n            LOGINT(mod->ctx);\n            return -1;\n        }\n    }\n\n    return EXIT_SUCCESS;\n}\n\n/* does not log */\nint\nunres_schema_find(struct unres_schema *unres, int start_on_backwards, void *item, enum UNRES_ITEM type)\n{\n    int i;\n    struct unres_list_uniq *aux_uniq1, *aux_uniq2;\n\n    if (!unres->count) {\n        return -1;\n    }\n\n    if (start_on_backwards >= 0) {\n        i = start_on_backwards;\n    } else {\n        i = unres->count - 1;\n    }\n    for (; i > -1; i--) {\n        if (unres->type[i] != type) {\n            continue;\n        }\n        if (type != UNRES_LIST_UNIQ) {\n            if (unres->item[i] == item) {\n                break;\n            }\n        } else {\n            aux_uniq1 = (struct unres_list_uniq *)unres->item[i];\n            aux_uniq2 = (struct unres_list_uniq *)item;\n            if ((aux_uniq1->list == aux_uniq2->list) && ly_strequal(aux_uniq1->expr, aux_uniq2->expr, 0)) {\n                break;\n            }\n        }\n    }\n\n    return i;\n}\n\nstatic void\nunres_schema_free_item(struct ly_ctx *ctx, struct unres_schema *unres, uint32_t i)\n{\n    struct lyxml_elem *yin;\n    struct yang_type *yang;\n    struct unres_iffeat_data *iff_data;\n\n    switch (unres->type[i]) {\n    case UNRES_TYPE_DER_TPDF:\n    case UNRES_TYPE_DER:\n        yin = (struct lyxml_elem *)((struct lys_type *)unres->item[i])->der;\n        if (yin->flags & LY_YANG_STRUCTURE_FLAG) {\n            yang =(struct yang_type *)yin;\n            ((struct lys_type *)unres->item[i])->base = yang->base;\n            lydict_remove(ctx, yang->name);\n            free(yang);\n            if (((struct lys_type *)unres->item[i])->base == LY_TYPE_UNION) {\n                yang_free_type_union(ctx, (struct lys_type *)unres->item[i]);\n            }\n        } else {\n            lyxml_free(ctx, yin);\n        }\n        break;\n    case UNRES_IFFEAT:\n        iff_data = (struct unres_iffeat_data *)unres->str_snode[i];\n        lydict_remove(ctx, iff_data->fname);\n        free(unres->str_snode[i]);\n        break;\n    case UNRES_IDENT:\n    case UNRES_TYPE_IDENTREF:\n    case UNRES_CHOICE_DFLT:\n    case UNRES_LIST_KEYS:\n        lydict_remove(ctx, (const char *)unres->str_snode[i]);\n        break;\n    case UNRES_LIST_UNIQ:\n        free(unres->item[i]);\n        break;\n    case UNRES_EXT:\n        free(unres->str_snode[i]);\n        break;\n    case UNRES_EXT_FINALIZE:\n        free(unres->str_snode[i]);\n    default:\n        break;\n    }\n    unres->type[i] = UNRES_RESOLVED;\n}\n\nvoid\nunres_schema_free(struct lys_module *module, struct unres_schema **unres, int all)\n{\n    uint32_t i;\n    unsigned int unresolved = 0;\n\n    if (!unres || !(*unres)) {\n        return;\n    }\n\n    assert(module || ((*unres)->count == 0));\n\n    for (i = 0; i < (*unres)->count; ++i) {\n        if (!all && ((*unres)->module[i] != module)) {\n            if ((*unres)->type[i] != UNRES_RESOLVED) {\n                unresolved++;\n            }\n            continue;\n        }\n\n        /* free heap memory for the specific item */\n        unres_schema_free_item(module->ctx, *unres, i);\n    }\n\n    /* free it all */\n    if (!module || all || (!unresolved && !module->type)) {\n        free((*unres)->item);\n        free((*unres)->type);\n        free((*unres)->str_snode);\n        free((*unres)->module);\n        free((*unres));\n        (*unres) = NULL;\n    }\n}\n\n/* check whether instance-identifier points outside its data subtree (for operation it is any node\n * outside the operation subtree, otherwise it is a node from a foreign model) */\nstatic int\ncheck_instid_ext_dep(const struct lys_node *sleaf, const char *json_instid)\n{\n    const struct lys_node *op_node, *first_node;\n    enum int_log_opts prev_ilo;\n    char *buf, *tmp;\n\n    if (!json_instid || !json_instid[0]) {\n        /* no/empty value */\n        return 0;\n    }\n\n    for (op_node = lys_parent(sleaf);\n         op_node && !(op_node->nodetype & (LYS_NOTIF | LYS_RPC | LYS_ACTION));\n         op_node = lys_parent(op_node));\n\n    if (op_node && lys_parent(op_node)) {\n        /* nested operation - any absolute path is external */\n        return 1;\n    }\n\n    /* get the first node from the instid */\n    tmp = strchr(json_instid + 1, '/');\n    buf = strndup(json_instid, tmp ? (size_t)(tmp - json_instid) : strlen(json_instid));\n    if (!buf) {\n        /* so that we do not have to bother with logging, say it is not external */\n        return 0;\n    }\n\n    /* find the first schema node, do not log */\n    ly_ilo_change(NULL, ILO_IGNORE, &prev_ilo, NULL);\n    first_node = ly_ctx_get_node(NULL, sleaf, buf, 0);\n    ly_ilo_restore(NULL, prev_ilo, NULL, 0);\n\n    free(buf);\n    if (!first_node) {\n        /* unknown path, say it is external */\n        return 1;\n    }\n\n    /* based on the first schema node in the path we can decide whether it points to an external tree or not */\n\n    if (op_node) {\n        if (op_node != first_node) {\n            /* it is a top-level operation, so we're good if it points somewhere inside it */\n            return 1;\n        }\n    } else {\n        if (lys_node_module(sleaf) != lys_node_module(first_node)) {\n            /* modules differ */\n            return 1;\n        }\n    }\n\n    return 0;\n}\n\n/**\n * @brief Resolve instance-identifier in JSON data format. Logs directly.\n *\n * @param[in] data Data node where the path is used\n * @param[in] path Instance-identifier node value.\n * @param[in,out] ret Resolved instance or NULL.\n *\n * @return 0 on success (even if unresolved and \\p ret is NULL), -1 on error.\n */\nstatic int\nresolve_instid(struct lyd_node *data, const char *path, int req_inst, struct lyd_node **ret)\n{\n    int i = 0, j, parsed, cur_idx;\n    const struct lys_module *mod, *prev_mod = NULL;\n    struct ly_ctx *ctx = data->schema->module->ctx;\n    struct lyd_node *root, *node;\n    const char *model = NULL, *name;\n    char *str;\n    int mod_len, name_len, has_predicate;\n    struct unres_data node_match;\n\n    memset(&node_match, 0, sizeof node_match);\n    *ret = NULL;\n\n    /* we need root to resolve absolute path */\n    for (root = data; root->parent; root = root->parent);\n    /* we're still parsing it and the pointer is not correct yet */\n    if (root->prev) {\n        for (; root->prev->next; root = root->prev);\n    }\n\n    /* search for the instance node */\n    while (path[i]) {\n        j = parse_instance_identifier(&path[i], &model, &mod_len, &name, &name_len, &has_predicate);\n        if (j <= 0) {\n            LOGVAL(ctx, LYE_INCHAR, LY_VLOG_LYD, data, path[i-j], &path[i-j]);\n            goto error;\n        }\n        i += j;\n\n        if (model) {\n            str = strndup(model, mod_len);\n            if (!str) {\n                LOGMEM(ctx);\n                goto error;\n            }\n            mod = ly_ctx_get_module(ctx, str, NULL, 1);\n            if (ctx->data_clb) {\n                if (!mod) {\n                    mod = ctx->data_clb(ctx, str, NULL, 0, ctx->data_clb_data);\n                } else if (!mod->implemented) {\n                    mod = ctx->data_clb(ctx, mod->name, mod->ns, LY_MODCLB_NOT_IMPLEMENTED, ctx->data_clb_data);\n                }\n            }\n            free(str);\n\n            if (!mod || !mod->implemented || mod->disabled) {\n                break;\n            }\n        } else if (!prev_mod) {\n            /* first iteration and we are missing module name */\n            LOGVAL(ctx, LYE_INELEM_LEN, LY_VLOG_LYD, data, name_len, name);\n            LOGVAL(ctx, LYE_SPEC, LY_VLOG_PREV, NULL, \"Instance-identifier is missing prefix in the first node.\");\n            goto error;\n        } else {\n            mod = prev_mod;\n        }\n\n        if (resolve_data(mod, name, name_len, root, &node_match)) {\n            /* no instance exists */\n            break;\n        }\n\n        if (has_predicate) {\n            /* we have predicate, so the current results must be list or leaf-list */\n            parsed = j = 0;\n            /* index of the current node (for lists with position predicates) */\n            cur_idx = 1;\n            while (j < (signed)node_match.count) {\n                node = node_match.node[j];\n                parsed = resolve_instid_predicate(mod, &path[i], &node, cur_idx);\n                if (parsed < 1) {\n                    LOGVAL(ctx, LYE_INPRED, LY_VLOG_LYD, data, &path[i - parsed]);\n                    goto error;\n                }\n\n                if (!node) {\n                    /* current node does not satisfy the predicate */\n                    unres_data_del(&node_match, j);\n                } else {\n                    ++j;\n                }\n                ++cur_idx;\n            }\n\n            i += parsed;\n        } else if (node_match.count) {\n            /* check that we are not addressing lists */\n            for (j = 0; (unsigned)j < node_match.count; ++j) {\n                if (node_match.node[j]->schema->nodetype == LYS_LIST) {\n                    unres_data_del(&node_match, j--);\n                }\n            }\n            if (!node_match.count) {\n                LOGVAL(ctx, LYE_SPEC, LY_VLOG_LYD, data, \"Instance identifier is missing list keys.\");\n            }\n        }\n\n        prev_mod = mod;\n    }\n\n    if (!node_match.count) {\n        /* no instance exists */\n        if (req_inst > -1) {\n            LOGVAL(ctx, LYE_NOREQINS, LY_VLOG_LYD, data, path);\n            return EXIT_FAILURE;\n        }\n        LOGVRB(\"There is no instance of \\\"%s\\\", but it is not required.\", path);\n        return EXIT_SUCCESS;\n    } else if (node_match.count > 1) {\n        /* instance identifier must resolve to a single node */\n        LOGVAL(ctx, LYE_TOOMANY, LY_VLOG_LYD, data, path, \"data tree\");\n        goto error;\n    } else {\n        /* we have required result, remember it and cleanup */\n        *ret = node_match.node[0];\n        free(node_match.node);\n        return EXIT_SUCCESS;\n    }\n\nerror:\n    /* cleanup */\n    free(node_match.node);\n    return -1;\n}\n\nstatic int\nresolve_leafref(struct lyd_node_leaf_list *leaf, const char *path, int req_inst, struct lyd_node **ret)\n{\n    struct lyxp_set xp_set;\n    uint32_t i;\n\n    memset(&xp_set, 0, sizeof xp_set);\n    *ret = NULL;\n\n    /* syntax was already checked, so just evaluate the path using standard XPath */\n    if (lyxp_eval(path, (struct lyd_node *)leaf, LYXP_NODE_ELEM, lyd_node_module((struct lyd_node *)leaf), &xp_set, 0) != EXIT_SUCCESS) {\n        return -1;\n    }\n\n    if (xp_set.type == LYXP_SET_NODE_SET) {\n        for (i = 0; i < xp_set.used; ++i) {\n            if ((xp_set.val.nodes[i].type != LYXP_NODE_ELEM) || !(xp_set.val.nodes[i].node->schema->nodetype & (LYS_LEAF | LYS_LEAFLIST))) {\n                continue;\n            }\n\n            /* not that the value is already in canonical form since the parsers does the conversion,\n             * so we can simply compare just the values */\n            if (ly_strequal(leaf->value_str, ((struct lyd_node_leaf_list *)xp_set.val.nodes[i].node)->value_str, 1)) {\n                /* we have the match */\n                *ret = xp_set.val.nodes[i].node;\n                break;\n            }\n        }\n    }\n\n    lyxp_set_cast(&xp_set, LYXP_SET_EMPTY, (struct lyd_node *)leaf, NULL, 0);\n\n    if (!*ret) {\n        /* reference not found */\n        if (req_inst > -1) {\n            LOGVAL(leaf->schema->module->ctx, LYE_NOLEAFREF, LY_VLOG_LYD, leaf, path, leaf->value_str);\n            return EXIT_FAILURE;\n        } else {\n            LOGVRB(\"There is no leafref \\\"%s\\\" with the value \\\"%s\\\", but it is not required.\", path, leaf->value_str);\n        }\n    }\n\n    return EXIT_SUCCESS;\n}\n\n/* ignore fail because we are parsing edit-config, get, or get-config - but only if the union includes leafref or instid */\nint\nresolve_union(struct lyd_node_leaf_list *leaf, struct lys_type *type, int store, int ignore_fail,\n              struct lys_type **resolved_type)\n{\n    struct ly_ctx *ctx = leaf->schema->module->ctx;\n    struct lys_type *t;\n    struct lyd_node *ret;\n    enum int_log_opts prev_ilo;\n    int found, success = 0, ext_dep, req_inst;\n    const char *json_val = NULL;\n\n    assert(type->base == LY_TYPE_UNION);\n\n    if ((leaf->value_type == LY_TYPE_UNION) || ((leaf->value_type == LY_TYPE_INST) && (leaf->value_flags & LY_VALUE_UNRES))) {\n        /* either NULL or instid previously converted to JSON */\n        json_val = lydict_insert(ctx, leaf->value.string, 0);\n    }\n\n    if (store) {\n        lyd_free_value(leaf->value, leaf->value_type, leaf->value_flags, &((struct lys_node_leaf *)leaf->schema)->type,\n                       leaf->value_str, NULL, NULL, NULL);\n        memset(&leaf->value, 0, sizeof leaf->value);\n    }\n\n    /* turn logging off, we are going to try to validate the value with all the types in order */\n    ly_ilo_change(NULL, ILO_IGNORE, &prev_ilo, 0);\n\n    t = NULL;\n    found = 0;\n    while ((t = lyp_get_next_union_type(type, t, &found))) {\n        found = 0;\n\n        switch (t->base) {\n        case LY_TYPE_LEAFREF:\n            if ((ignore_fail == 1) || ((leaf->schema->flags & LYS_LEAFREF_DEP) && (ignore_fail == 2))) {\n                req_inst = -1;\n            } else {\n                req_inst = t->info.lref.req;\n            }\n\n            if (!resolve_leafref(leaf, t->info.lref.path, req_inst, &ret)) {\n                if (store) {\n                    if (ret && !(leaf->schema->flags & LYS_LEAFREF_DEP)) {\n                        /* valid resolved */\n                        leaf->value.leafref = ret;\n                        leaf->value_type = LY_TYPE_LEAFREF;\n                    } else {\n                        /* valid unresolved */\n                        ly_ilo_restore(NULL, prev_ilo, NULL, 0);\n                        if (!lyp_parse_value(t, &leaf->value_str, NULL, leaf, NULL, NULL, 1, 0, 0)) {\n                            return -1;\n                        }\n                        ly_ilo_change(NULL, ILO_IGNORE, &prev_ilo, NULL);\n                    }\n                }\n\n                success = 1;\n            }\n            break;\n        case LY_TYPE_INST:\n            ext_dep = check_instid_ext_dep(leaf->schema, (json_val ? json_val : leaf->value_str));\n            if ((ignore_fail == 1) || (ext_dep && (ignore_fail == 2))) {\n                req_inst = -1;\n            } else {\n                req_inst = t->info.inst.req;\n            }\n\n            if (!resolve_instid((struct lyd_node *)leaf, (json_val ? json_val : leaf->value_str), req_inst, &ret)) {\n                if (store) {\n                    if (ret && !ext_dep) {\n                        /* valid resolved */\n                        leaf->value.instance = ret;\n                        leaf->value_type = LY_TYPE_INST;\n\n                        if (json_val) {\n                            lydict_remove(leaf->schema->module->ctx, leaf->value_str);\n                            leaf->value_str = json_val;\n                            json_val = NULL;\n                        }\n                    } else {\n                        /* valid unresolved */\n                        if (json_val) {\n                            /* put the JSON val back */\n                            leaf->value.string = json_val;\n                            json_val = NULL;\n                        } else {\n                            leaf->value.instance = NULL;\n                        }\n                        leaf->value_type = LY_TYPE_INST;\n                        leaf->value_flags |= LY_VALUE_UNRES;\n                    }\n                }\n\n                success = 1;\n            }\n            break;\n        default:\n            if (lyp_parse_value(t, &leaf->value_str, NULL, leaf, NULL, NULL, store, 0, 0)) {\n                success = 1;\n            }\n            break;\n        }\n\n        if (success) {\n            break;\n        }\n\n        /* erase possible present and invalid value data */\n        if (store) {\n            lyd_free_value(leaf->value, leaf->value_type, leaf->value_flags, t, leaf->value_str, NULL, NULL, NULL);\n            memset(&leaf->value, 0, sizeof leaf->value);\n        }\n    }\n\n    /* turn logging back on */\n    ly_ilo_restore(NULL, prev_ilo, NULL, 0);\n\n    if (json_val) {\n        if (!success) {\n            /* put the value back for now */\n            assert(leaf->value_type == LY_TYPE_UNION);\n            leaf->value.string = json_val;\n        } else {\n            /* value was ultimately useless, but we could not have known */\n            lydict_remove(leaf->schema->module->ctx, json_val);\n        }\n    }\n\n    if (success) {\n        if (resolved_type) {\n            *resolved_type = t;\n        }\n    } else if (!ignore_fail || !type->info.uni.has_ptr_type) {\n        /* not found and it is required */\n        LOGVAL(ctx, LYE_INVAL, LY_VLOG_LYD, leaf, leaf->value_str ? leaf->value_str : \"\", leaf->schema->name);\n        return EXIT_FAILURE;\n    }\n\n    return EXIT_SUCCESS;\n\n}\n\n/**\n * @brief Resolve a single unres data item. Logs directly.\n *\n * @param[in] node Data node to resolve.\n * @param[in] type Type of the unresolved item.\n * @param[in] ignore_fail 0 - no, 1 - yes, 2 - yes, but only for external dependencies.\n *\n * @return EXIT_SUCCESS on success, EXIT_FAILURE on forward reference, -1 on error.\n */\nint\nresolve_unres_data_item(struct lyd_node *node, enum UNRES_ITEM type, int ignore_fail, struct lys_when **failed_when)\n{\n    int rc, req_inst, ext_dep;\n    struct lyd_node_leaf_list *leaf;\n    struct lyd_node *ret;\n    struct lys_node_leaf *sleaf;\n\n    leaf = (struct lyd_node_leaf_list *)node;\n    sleaf = (struct lys_node_leaf *)leaf->schema;\n\n    switch (type) {\n    case UNRES_LEAFREF:\n        assert(sleaf->type.base == LY_TYPE_LEAFREF);\n        assert(leaf->validity & LYD_VAL_LEAFREF);\n        if ((ignore_fail == 1) || ((leaf->schema->flags & LYS_LEAFREF_DEP) && (ignore_fail == 2))) {\n            req_inst = -1;\n        } else {\n            req_inst = sleaf->type.info.lref.req;\n        }\n        rc = resolve_leafref(leaf, sleaf->type.info.lref.path, req_inst, &ret);\n        if (!rc) {\n            if (ret && !(leaf->schema->flags & LYS_LEAFREF_DEP)) {\n                /* valid resolved */\n                if (leaf->value_type == LY_TYPE_BITS) {\n                    free(leaf->value.bit);\n                }\n                leaf->value.leafref = ret;\n                leaf->value_type = LY_TYPE_LEAFREF;\n                leaf->value_flags &= ~LY_VALUE_UNRES;\n            } else {\n                /* valid unresolved */\n                if (!(leaf->value_flags & LY_VALUE_UNRES)) {\n                    if (!lyp_parse_value(&sleaf->type, &leaf->value_str, NULL, leaf, NULL, NULL, 1, 0, 0)) {\n                        return -1;\n                    }\n                }\n            }\n            leaf->validity &= ~LYD_VAL_LEAFREF;\n        } else {\n            return rc;\n        }\n        break;\n\n    case UNRES_INSTID:\n        assert(sleaf->type.base == LY_TYPE_INST);\n        ext_dep = check_instid_ext_dep(leaf->schema, leaf->value_str);\n        if (ext_dep == -1) {\n            return -1;\n        }\n\n        if ((ignore_fail == 1) || (ext_dep && (ignore_fail == 2))) {\n            req_inst = -1;\n        } else {\n            req_inst = sleaf->type.info.inst.req;\n        }\n        rc = resolve_instid(node, leaf->value_str, req_inst, &ret);\n        if (!rc) {\n            if (ret && !ext_dep) {\n                /* valid resolved */\n                leaf->value.instance = ret;\n                leaf->value_type = LY_TYPE_INST;\n                leaf->value_flags &= ~LY_VALUE_UNRES;\n            } else {\n                /* valid unresolved */\n                leaf->value.instance = NULL;\n                leaf->value_type = LY_TYPE_INST;\n                leaf->value_flags |= LY_VALUE_UNRES;\n            }\n        } else {\n            return rc;\n        }\n        break;\n\n    case UNRES_UNION:\n        assert(sleaf->type.base == LY_TYPE_UNION);\n        return resolve_union(leaf, &sleaf->type, 1, ignore_fail, NULL);\n\n    case UNRES_WHEN:\n        if ((rc = resolve_when(node, ignore_fail, failed_when))) {\n            return rc;\n        }\n        break;\n\n    case UNRES_MUST:\n        if ((rc = resolve_must(node, 0, ignore_fail))) {\n            return rc;\n        }\n        break;\n\n    case UNRES_MUST_INOUT:\n        if ((rc = resolve_must(node, 1, ignore_fail))) {\n            return rc;\n        }\n        break;\n\n    case UNRES_UNIQ_LEAVES:\n        if (lyv_data_unique(node)) {\n            return -1;\n        }\n        break;\n\n    default:\n        LOGINT(NULL);\n        return -1;\n    }\n\n    return EXIT_SUCCESS;\n}\n\n/**\n * @brief add data unres item\n *\n * @param[in] unres Unres data structure to use.\n * @param[in] node Data node to use.\n *\n * @return 0 on success, -1 on error.\n */\nint\nunres_data_add(struct unres_data *unres, struct lyd_node *node, enum UNRES_ITEM type)\n{\n    assert(unres && node);\n    assert((type == UNRES_LEAFREF) || (type == UNRES_INSTID) || (type == UNRES_WHEN) || (type == UNRES_MUST)\n           || (type == UNRES_MUST_INOUT) || (type == UNRES_UNION) || (type == UNRES_UNIQ_LEAVES));\n\n    unres->count++;\n    unres->node = ly_realloc(unres->node, unres->count * sizeof *unres->node);\n    LY_CHECK_ERR_RETURN(!unres->node, LOGMEM(NULL), -1);\n    unres->node[unres->count - 1] = node;\n    unres->type = ly_realloc(unres->type, unres->count * sizeof *unres->type);\n    LY_CHECK_ERR_RETURN(!unres->type, LOGMEM(NULL), -1);\n    unres->type[unres->count - 1] = type;\n\n    return 0;\n}\n\nstatic void\nresolve_unres_data_autodel_diff(struct unres_data *unres, uint32_t unres_i)\n{\n    struct lyd_node *next, *child, *parent;\n    uint32_t i;\n\n    for (i = 0; i < unres->diff_idx; ++i) {\n        if (unres->diff->type[i] == LYD_DIFF_DELETED) {\n            /* only leaf(-list) default could be removed and there is nothing to be checked in that case */\n            continue;\n        }\n\n        if (unres->diff->second[i] == unres->node[unres_i]) {\n            /* 1) default value was supposed to be created, but is disabled by when\n             * -> remove it from diff altogether\n             */\n            unres_data_diff_rem(unres, i);\n            /* if diff type is CREATED, the value was just a pointer, it can be freed normally (unlike in 4) */\n            return;\n        } else {\n            parent = unres->diff->second[i]->parent;\n            while (parent && (parent != unres->node[unres_i])) {\n                parent = parent->parent;\n            }\n            if (parent) {\n                /* 2) default value was supposed to be created but is disabled by when in some parent\n                 * -> remove this default subtree and add the rest into diff as deleted instead in 4)\n                 */\n                unres_data_diff_rem(unres, i);\n                break;\n            }\n\n            LY_TREE_DFS_BEGIN(unres->diff->second[i]->parent, next, child) {\n                if (child == unres->node[unres_i]) {\n                    /* 3) some default child of a default value was supposed to be created but has false when\n                     * -> the subtree will be freed later and automatically disconnected from the diff parent node\n                     */\n                    return;\n                }\n\n                LY_TREE_DFS_END(unres->diff->second[i]->parent, next, child);\n            }\n        }\n    }\n\n    /* 4) it does not overlap with created default values in any way\n     * -> just add it into diff as deleted\n     */\n    unres_data_diff_new(unres, unres->node[unres_i], unres->node[unres_i]->parent, 0);\n    lyd_unlink(unres->node[unres_i]);\n\n    /* should not be freed anymore */\n    unres->node[unres_i] = NULL;\n}\n\n/**\n * @brief Resolve every unres data item in the structure. Logs directly.\n *\n * If options include #LYD_OPT_TRUSTED, the data are considered trusted (must conditions are not expected,\n * unresolved leafrefs/instids are accepted, when conditions are normally resolved because at least some implicit\n * non-presence containers may need to be deleted).\n *\n * If options includes #LYD_OPT_WHENAUTODEL, the non-default nodes with false when conditions are auto-deleted.\n *\n * @param[in] ctx Context used.\n * @param[in] unres Unres data structure to use.\n * @param[in,out] root Root node of the data tree, can be changed due to autodeletion.\n * @param[in] options Data options as described above.\n *\n * @return EXIT_SUCCESS on success, -1 on error.\n */\nint\nresolve_unres_data(struct ly_ctx *ctx, struct unres_data *unres, struct lyd_node **root, int options)\n{\n    uint32_t i, j, first, resolved, del_items, stmt_count;\n    uint8_t prev_when_status;\n    int rc, progress, ignore_fail;\n    enum int_log_opts prev_ilo;\n    struct ly_err_item *prev_eitem;\n    LY_ERR prev_ly_errno = ly_errno;\n    struct lyd_node *parent;\n    struct lys_when *when;\n\n    assert(root);\n    assert(unres);\n\n    if (!unres->count) {\n        return EXIT_SUCCESS;\n    }\n\n    if (options & (LYD_OPT_NOTIF_FILTER | LYD_OPT_GET | LYD_OPT_GETCONFIG | LYD_OPT_EDIT)) {\n        ignore_fail = 1;\n    } else if (options & LYD_OPT_NOEXTDEPS) {\n        ignore_fail = 2;\n    } else {\n        ignore_fail = 0;\n    }\n\n    LOGVRB(\"Resolving unresolved data nodes and their constraints...\");\n    if (!ignore_fail) {\n        /* remember logging state only if errors are generated and valid */\n        ly_ilo_change(ctx, ILO_STORE, &prev_ilo, &prev_eitem);\n    }\n\n    /*\n     * when-stmt first\n     */\n    first = 1;\n    stmt_count = 0;\n    resolved = 0;\n    del_items = 0;\n    do {\n        if (!ignore_fail) {\n            ly_err_free_next(ctx, prev_eitem);\n        }\n        progress = 0;\n        for (i = 0; i < unres->count; i++) {\n            if (unres->type[i] != UNRES_WHEN) {\n                continue;\n            }\n            if (first) {\n                /* count when-stmt nodes in unres list */\n                stmt_count++;\n            }\n\n            /* resolve when condition only when all parent when conditions are already resolved */\n            for (parent = unres->node[i]->parent;\n                 parent && LYD_WHEN_DONE(parent->when_status);\n                 parent = parent->parent) {\n                if (!parent->parent && (parent->when_status & LYD_WHEN_FALSE)) {\n                    /* the parent node was already unlinked, do not resolve this node,\n                     * it will be removed anyway, so just mark it as resolved\n                     */\n                    unres->node[i]->when_status |= LYD_WHEN_FALSE;\n                    unres->type[i] = UNRES_RESOLVED;\n                    resolved++;\n                    break;\n                }\n            }\n            if (parent) {\n                continue;\n            }\n\n            prev_when_status = unres->node[i]->when_status;\n            rc = resolve_unres_data_item(unres->node[i], unres->type[i], ignore_fail, &when);\n            if (!rc) {\n                /* finish with error/delete the node only if when was changed from true to false, an external\n                 * dependency was not required, or it was not provided (the flag would not be passed down otherwise,\n                 * checked in upper functions) */\n                if ((unres->node[i]->when_status & LYD_WHEN_FALSE)\n                        && (!(when->flags & (LYS_XPCONF_DEP | LYS_XPSTATE_DEP)) || !(options & LYD_OPT_NOEXTDEPS))) {\n                    if ((!(prev_when_status & LYD_WHEN_TRUE) || !(options & LYD_OPT_WHENAUTODEL)) && !unres->node[i]->dflt) {\n                        /* false when condition */\n                        goto error;\n                    } /* follows else */\n\n                    /* auto-delete */\n                    LOGVRB(\"Auto-deleting node \\\"%s\\\" due to when condition (%s)\", ly_errpath(ctx), when->cond);\n\n                    /* only unlink now, the subtree can contain another nodes stored in the unres list */\n                    /* if it has parent non-presence containers that would be empty, we should actually\n                     * remove the container\n                     */\n                    for (parent = unres->node[i];\n                            parent->parent && parent->parent->schema->nodetype == LYS_CONTAINER;\n                            parent = parent->parent) {\n                        if (((struct lys_node_container *)parent->parent->schema)->presence) {\n                            /* presence container */\n                            break;\n                        }\n                        if (parent->next || parent->prev != parent) {\n                            /* non empty (the child we are in and we are going to remove is not the only child) */\n                            break;\n                        }\n                    }\n                    unres->node[i] = parent;\n\n                    if (*root && *root == unres->node[i]) {\n                        *root = (*root)->next;\n                    }\n\n                    lyd_unlink(unres->node[i]);\n                    unres->type[i] = UNRES_DELETE;\n                    del_items++;\n\n                    /* update the rest of unres items */\n                    for (j = 0; j < unres->count; j++) {\n                        if (unres->type[j] == UNRES_RESOLVED || unres->type[j] == UNRES_DELETE) {\n                            continue;\n                        }\n\n                        /* test if the node is in subtree to be deleted */\n                        for (parent = unres->node[j]; parent; parent = parent->parent) {\n                            if (parent == unres->node[i]) {\n                                /* yes, it is */\n                                unres->type[j] = UNRES_RESOLVED;\n                                resolved++;\n                                break;\n                            }\n                        }\n                    }\n                } else {\n                    unres->type[i] = UNRES_RESOLVED;\n                }\n                if (!ignore_fail) {\n                    ly_err_free_next(ctx, prev_eitem);\n                }\n                resolved++;\n                progress = 1;\n            } else if (rc == -1) {\n                goto error;\n            } /* else forward reference */\n        }\n        first = 0;\n    } while (progress && resolved < stmt_count);\n\n    /* do we have some unresolved when-stmt? */\n    if (stmt_count > resolved) {\n        goto error;\n    }\n\n    for (i = 0; del_items && i < unres->count; i++) {\n        /* we had some when-stmt resulted to false, so now we have to sanitize the unres list */\n        if (unres->type[i] != UNRES_DELETE) {\n            continue;\n        }\n        if (!unres->node[i]) {\n            unres->type[i] = UNRES_RESOLVED;\n            del_items--;\n            continue;\n        }\n\n        if (unres->store_diff) {\n            resolve_unres_data_autodel_diff(unres, i);\n        }\n\n        /* really remove the complete subtree */\n        lyd_free(unres->node[i]);\n        unres->type[i] = UNRES_RESOLVED;\n        del_items--;\n    }\n\n    /*\n     * now leafrefs\n     */\n    if (options & LYD_OPT_TRUSTED) {\n        /* we want to attempt to resolve leafrefs */\n        assert(!ignore_fail);\n        ignore_fail = 1;\n\n        ly_ilo_restore(ctx, prev_ilo, prev_eitem, 0);\n        ly_errno = prev_ly_errno;\n    }\n    first = 1;\n    stmt_count = 0;\n    resolved = 0;\n    do {\n        progress = 0;\n        for (i = 0; i < unres->count; i++) {\n            if (unres->type[i] != UNRES_LEAFREF) {\n                continue;\n            }\n            if (first) {\n                /* count leafref nodes in unres list */\n                stmt_count++;\n            }\n\n            rc = resolve_unres_data_item(unres->node[i], unres->type[i], ignore_fail, NULL);\n            if (!rc) {\n                unres->type[i] = UNRES_RESOLVED;\n                if (!ignore_fail) {\n                    ly_err_free_next(ctx, prev_eitem);\n                }\n                resolved++;\n                progress = 1;\n            } else if (rc == -1) {\n                goto error;\n            } /* else forward reference */\n        }\n        first = 0;\n    } while (progress && resolved < stmt_count);\n\n    /* do we have some unresolved leafrefs? */\n    if (stmt_count > resolved) {\n        goto error;\n    }\n\n    if (!ignore_fail) {\n        /* log normally now, throw away irrelevant errors */\n        ly_ilo_restore(ctx, prev_ilo, prev_eitem, 0);\n        ly_errno = prev_ly_errno;\n    }\n\n    /*\n     * rest\n     */\n    for (i = 0; i < unres->count; ++i) {\n        if (unres->type[i] == UNRES_RESOLVED) {\n            continue;\n        }\n        assert(!(options & LYD_OPT_TRUSTED) || ((unres->type[i] != UNRES_MUST) && (unres->type[i] != UNRES_MUST_INOUT)));\n\n        rc = resolve_unres_data_item(unres->node[i], unres->type[i], ignore_fail, NULL);\n        if (rc) {\n            /* since when was already resolved, a forward reference is an error */\n            return -1;\n        }\n\n        unres->type[i] = UNRES_RESOLVED;\n    }\n\n    LOGVRB(\"All data nodes and constraints resolved.\");\n    unres->count = 0;\n    return EXIT_SUCCESS;\n\nerror:\n    if (!ignore_fail) {\n        /* print all the new errors */\n        ly_ilo_restore(ctx, prev_ilo, prev_eitem, 1);\n        /* do not restore ly_errno, it was udpated properly */\n    }\n    return -1;\n}\n"], "filenames": ["src/resolve.c"], "buggy_code_start_loc": [1405], "buggy_code_end_loc": [1406], "fixing_code_start_loc": [1405], "fixing_code_end_loc": [1406], "type": "CWE-119", "message": "An invalid memory access flaw is present in libyang before v1.0-r3 in the function resolve_feature_value() when an if-feature statement is used inside a bit. Applications that use libyang to parse untrusted input yang files may crash.", "other": {"cve": {"id": "CVE-2019-20391", "sourceIdentifier": "cve@mitre.org", "published": "2020-01-22T22:15:10.080", "lastModified": "2020-01-23T21:16:27.040", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An invalid memory access flaw is present in libyang before v1.0-r3 in the function resolve_feature_value() when an if-feature statement is used inside a bit. Applications that use libyang to parse untrusted input yang files may crash."}, {"lang": "es", "value": "Un fallo de acceso a memoria no v\u00e1lida est\u00e1 presente en libyang versiones anteriores a v1.0-r3, en la funci\u00f3n resolve_feature_value() cuando es usada una sentencia if-feature dentro de un bit. Las aplicaciones que usan libyang para analizar archivos de entrada yang no confiables pueden bloquearse."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-119"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:cesnet:libyang:0.11:r1:*:*:*:*:*:*", "matchCriteriaId": "65E91322-5F67-43C2-8112-5ECAEC2A3C12"}, {"vulnerable": true, "criteria": "cpe:2.3:a:cesnet:libyang:0.11:r2:*:*:*:*:*:*", "matchCriteriaId": "80A88DE4-93F8-40C3-AA52-A5F353F028AA"}, {"vulnerable": true, "criteria": "cpe:2.3:a:cesnet:libyang:0.12:r1:*:*:*:*:*:*", "matchCriteriaId": "05C120CA-50EF-4B6D-92C9-ED736219DB07"}, {"vulnerable": true, "criteria": "cpe:2.3:a:cesnet:libyang:0.12:r2:*:*:*:*:*:*", "matchCriteriaId": "99D1FA55-3F56-4E09-B41E-B05C199B96B8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:cesnet:libyang:0.13:r1:*:*:*:*:*:*", "matchCriteriaId": "35D48EC4-58D2-49C6-8049-920787733587"}, {"vulnerable": true, "criteria": "cpe:2.3:a:cesnet:libyang:0.13:r2:*:*:*:*:*:*", "matchCriteriaId": "B57F3953-49D6-413C-A4AE-03125935FC77"}, {"vulnerable": true, "criteria": "cpe:2.3:a:cesnet:libyang:0.14:r1:*:*:*:*:*:*", "matchCriteriaId": "DD62411F-A524-4E80-B540-780EA39CB6A4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:cesnet:libyang:0.15:r1:*:*:*:*:*:*", "matchCriteriaId": "FEF091B1-978A-4881-B1FC-6848CD1A7BBF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:cesnet:libyang:0.16:r1:*:*:*:*:*:*", "matchCriteriaId": "0C50D690-9A4D-4B78-BF4E-A4D9B4074216"}, {"vulnerable": true, "criteria": "cpe:2.3:a:cesnet:libyang:0.16:r2:*:*:*:*:*:*", "matchCriteriaId": "124A5D30-7451-4516-9AA2-963AE62DD679"}, {"vulnerable": true, "criteria": "cpe:2.3:a:cesnet:libyang:0.16:r3:*:*:*:*:*:*", "matchCriteriaId": "C260D13B-82E9-4596-9116-61073B42D661"}, {"vulnerable": true, "criteria": "cpe:2.3:a:cesnet:libyang:1.0:r1:*:*:*:*:*:*", "matchCriteriaId": "5F8D5FC0-959E-4014-9CB7-91378CC8B2BA"}, {"vulnerable": true, "criteria": "cpe:2.3:a:cesnet:libyang:1.0:r2:*:*:*:*:*:*", "matchCriteriaId": "DCBDA519-805B-4193-8092-75E2748A7BC3"}]}]}], "references": [{"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1793934", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/CESNET/libyang/commit/bdb596ddc07596fa212f231135b87d0b9178f6f8", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/CESNET/libyang/compare/v1.0-r2...v1.0-r3", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/CESNET/libyang/issues/772", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/CESNET/libyang/commit/bdb596ddc07596fa212f231135b87d0b9178f6f8"}}