{"buggy_code": ["/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * Handling of regular expressions: vim_regcomp(), vim_regexec(), vim_regsub()\n */\n\n// By default: do not create debugging logs or files related to regular\n// expressions, even when compiling with -DDEBUG.\n// Uncomment the second line to get the regexp debugging.\n#undef DEBUG\n// #define DEBUG\n\n#include \"vim.h\"\n\n#ifdef DEBUG\n// show/save debugging data when BT engine is used\n# define BT_REGEXP_DUMP\n// save the debugging data to a file instead of displaying it\n# define BT_REGEXP_LOG\n# define BT_REGEXP_DEBUG_LOG\n# define BT_REGEXP_DEBUG_LOG_NAME\t\"bt_regexp_debug.log\"\n#endif\n\n#ifdef FEAT_RELTIME\nstatic sig_atomic_t dummy_timeout_flag = 0;\nstatic volatile sig_atomic_t *timeout_flag = &dummy_timeout_flag;\n#endif\n\n/*\n * Magic characters have a special meaning, they don't match literally.\n * Magic characters are negative.  This separates them from literal characters\n * (possibly multi-byte).  Only ASCII characters can be Magic.\n */\n#define Magic(x)\t((int)(x) - 256)\n#define un_Magic(x)\t((x) + 256)\n#define is_Magic(x)\t((x) < 0)\n\n    static int\nno_Magic(int x)\n{\n    if (is_Magic(x))\n\treturn un_Magic(x);\n    return x;\n}\n\n    static int\ntoggle_Magic(int x)\n{\n    if (is_Magic(x))\n\treturn un_Magic(x);\n    return Magic(x);\n}\n\n#ifdef FEAT_RELTIME\n    void\ninit_regexp_timeout(long msec)\n{\n    timeout_flag = start_timeout(msec);\n}\n\n    void\ndisable_regexp_timeout(void)\n{\n    stop_timeout();\n    timeout_flag = &dummy_timeout_flag;\n}\n#endif\n\n/*\n * The first byte of the BT regexp internal \"program\" is actually this magic\n * number; the start node begins in the second byte.  It's used to catch the\n * most severe mutilation of the program by the caller.\n */\n\n#define REGMAGIC\t0234\n\n/*\n * Utility definitions.\n */\n#define UCHARAT(p)\t((int)*(char_u *)(p))\n\n// Used for an error (down from) vim_regcomp(): give the error message, set\n// rc_did_emsg and return NULL\n#define EMSG_RET_NULL(m) return (emsg((m)), rc_did_emsg = TRUE, (void *)NULL)\n#define IEMSG_RET_NULL(m) return (iemsg((m)), rc_did_emsg = TRUE, (void *)NULL)\n#define EMSG_RET_FAIL(m) return (emsg((m)), rc_did_emsg = TRUE, FAIL)\n#define EMSG2_RET_NULL(m, c) return (semsg((const char *)(m), (c) ? \"\" : \"\\\\\"), rc_did_emsg = TRUE, (void *)NULL)\n#define EMSG3_RET_NULL(m, c, a) return (semsg((const char *)(m), (c) ? \"\" : \"\\\\\", (a)), rc_did_emsg = TRUE, (void *)NULL)\n#define EMSG2_RET_FAIL(m, c) return (semsg((const char *)(m), (c) ? \"\" : \"\\\\\"), rc_did_emsg = TRUE, FAIL)\n#define EMSG_ONE_RET_NULL EMSG2_RET_NULL(_(e_invalid_item_in_str_brackets), reg_magic == MAGIC_ALL)\n\n\n#define MAX_LIMIT\t(32767L << 16L)\n\n#define NOT_MULTI\t0\n#define MULTI_ONE\t1\n#define MULTI_MULT\t2\n\n// return values for regmatch()\n#define RA_FAIL\t\t1\t// something failed, abort\n#define RA_CONT\t\t2\t// continue in inner loop\n#define RA_BREAK\t3\t// break inner loop\n#define RA_MATCH\t4\t// successful match\n#define RA_NOMATCH\t5\t// didn't match\n\n/*\n * Return NOT_MULTI if c is not a \"multi\" operator.\n * Return MULTI_ONE if c is a single \"multi\" operator.\n * Return MULTI_MULT if c is a multi \"multi\" operator.\n */\n    static int\nre_multi_type(int c)\n{\n    if (c == Magic('@') || c == Magic('=') || c == Magic('?'))\n\treturn MULTI_ONE;\n    if (c == Magic('*') || c == Magic('+') || c == Magic('{'))\n\treturn MULTI_MULT;\n    return NOT_MULTI;\n}\n\nstatic char_u\t\t*reg_prev_sub = NULL;\n\n/*\n * REGEXP_INRANGE contains all characters which are always special in a []\n * range after '\\'.\n * REGEXP_ABBR contains all characters which act as abbreviations after '\\'.\n * These are:\n *  \\n\t- New line (NL).\n *  \\r\t- Carriage Return (CR).\n *  \\t\t- Tab (TAB).\n *  \\e\t- Escape (ESC).\n *  \\b\t- Backspace (Ctrl_H).\n *  \\d  - Character code in decimal, eg \\d123\n *  \\o\t- Character code in octal, eg \\o80\n *  \\x\t- Character code in hex, eg \\x4a\n *  \\u\t- Multibyte character code, eg \\u20ac\n *  \\U\t- Long multibyte character code, eg \\U12345678\n */\nstatic char_u REGEXP_INRANGE[] = \"]^-n\\\\\";\nstatic char_u REGEXP_ABBR[] = \"nrtebdoxuU\";\n\n/*\n * Translate '\\x' to its control character, except \"\\n\", which is Magic.\n */\n    static int\nbackslash_trans(int c)\n{\n    switch (c)\n    {\n\tcase 'r':   return CAR;\n\tcase 't':   return TAB;\n\tcase 'e':   return ESC;\n\tcase 'b':   return BS;\n    }\n    return c;\n}\n\n/*\n * Check for a character class name \"[:name:]\".  \"pp\" points to the '['.\n * Returns one of the CLASS_ items. CLASS_NONE means that no item was\n * recognized.  Otherwise \"pp\" is advanced to after the item.\n */\n    static int\nget_char_class(char_u **pp)\n{\n    static const char *(class_names[]) =\n    {\n\t\"alnum:]\",\n#define CLASS_ALNUM 0\n\t\"alpha:]\",\n#define CLASS_ALPHA 1\n\t\"blank:]\",\n#define CLASS_BLANK 2\n\t\"cntrl:]\",\n#define CLASS_CNTRL 3\n\t\"digit:]\",\n#define CLASS_DIGIT 4\n\t\"graph:]\",\n#define CLASS_GRAPH 5\n\t\"lower:]\",\n#define CLASS_LOWER 6\n\t\"print:]\",\n#define CLASS_PRINT 7\n\t\"punct:]\",\n#define CLASS_PUNCT 8\n\t\"space:]\",\n#define CLASS_SPACE 9\n\t\"upper:]\",\n#define CLASS_UPPER 10\n\t\"xdigit:]\",\n#define CLASS_XDIGIT 11\n\t\"tab:]\",\n#define CLASS_TAB 12\n\t\"return:]\",\n#define CLASS_RETURN 13\n\t\"backspace:]\",\n#define CLASS_BACKSPACE 14\n\t\"escape:]\",\n#define CLASS_ESCAPE 15\n\t\"ident:]\",\n#define CLASS_IDENT 16\n\t\"keyword:]\",\n#define CLASS_KEYWORD 17\n\t\"fname:]\",\n#define CLASS_FNAME 18\n    };\n#define CLASS_NONE 99\n    int i;\n\n    if ((*pp)[1] == ':')\n    {\n\tfor (i = 0; i < (int)ARRAY_LENGTH(class_names); ++i)\n\t    if (STRNCMP(*pp + 2, class_names[i], STRLEN(class_names[i])) == 0)\n\t    {\n\t\t*pp += STRLEN(class_names[i]) + 2;\n\t\treturn i;\n\t    }\n    }\n    return CLASS_NONE;\n}\n\n/*\n * Specific version of character class functions.\n * Using a table to keep this fast.\n */\nstatic short\tclass_tab[256];\n\n#define\t    RI_DIGIT\t0x01\n#define\t    RI_HEX\t0x02\n#define\t    RI_OCTAL\t0x04\n#define\t    RI_WORD\t0x08\n#define\t    RI_HEAD\t0x10\n#define\t    RI_ALPHA\t0x20\n#define\t    RI_LOWER\t0x40\n#define\t    RI_UPPER\t0x80\n#define\t    RI_WHITE\t0x100\n\n    static void\ninit_class_tab(void)\n{\n    int\t\ti;\n    static int\tdone = FALSE;\n\n    if (done)\n\treturn;\n\n    for (i = 0; i < 256; ++i)\n    {\n\tif (i >= '0' && i <= '7')\n\t    class_tab[i] = RI_DIGIT + RI_HEX + RI_OCTAL + RI_WORD;\n\telse if (i >= '8' && i <= '9')\n\t    class_tab[i] = RI_DIGIT + RI_HEX + RI_WORD;\n\telse if (i >= 'a' && i <= 'f')\n\t    class_tab[i] = RI_HEX + RI_WORD + RI_HEAD + RI_ALPHA + RI_LOWER;\n\telse if (i >= 'g' && i <= 'z')\n\t    class_tab[i] = RI_WORD + RI_HEAD + RI_ALPHA + RI_LOWER;\n\telse if (i >= 'A' && i <= 'F')\n\t    class_tab[i] = RI_HEX + RI_WORD + RI_HEAD + RI_ALPHA + RI_UPPER;\n\telse if (i >= 'G' && i <= 'Z')\n\t    class_tab[i] = RI_WORD + RI_HEAD + RI_ALPHA + RI_UPPER;\n\telse if (i == '_')\n\t    class_tab[i] = RI_WORD + RI_HEAD;\n\telse\n\t    class_tab[i] = 0;\n    }\n    class_tab[' '] |= RI_WHITE;\n    class_tab['\\t'] |= RI_WHITE;\n    done = TRUE;\n}\n\n#define ri_digit(c)\t((c) < 0x100 && (class_tab[c] & RI_DIGIT))\n#define ri_hex(c)\t((c) < 0x100 && (class_tab[c] & RI_HEX))\n#define ri_octal(c)\t((c) < 0x100 && (class_tab[c] & RI_OCTAL))\n#define ri_word(c)\t((c) < 0x100 && (class_tab[c] & RI_WORD))\n#define ri_head(c)\t((c) < 0x100 && (class_tab[c] & RI_HEAD))\n#define ri_alpha(c)\t((c) < 0x100 && (class_tab[c] & RI_ALPHA))\n#define ri_lower(c)\t((c) < 0x100 && (class_tab[c] & RI_LOWER))\n#define ri_upper(c)\t((c) < 0x100 && (class_tab[c] & RI_UPPER))\n#define ri_white(c)\t((c) < 0x100 && (class_tab[c] & RI_WHITE))\n\n// flags for regflags\n#define RF_ICASE    1\t// ignore case\n#define RF_NOICASE  2\t// don't ignore case\n#define RF_HASNL    4\t// can match a NL\n#define RF_ICOMBINE 8\t// ignore combining characters\n#define RF_LOOKBH   16\t// uses \"\\@<=\" or \"\\@<!\"\n\n/*\n * Global work variables for vim_regcomp().\n */\n\nstatic char_u\t*regparse;\t// Input-scan pointer.\nstatic int\tregnpar;\t// () count.\nstatic int\twants_nfa;\t// regex should use NFA engine\n#ifdef FEAT_SYN_HL\nstatic int\tregnzpar;\t// \\z() count.\nstatic int\tre_has_z;\t// \\z item detected\n#endif\nstatic unsigned\tregflags;\t// RF_ flags for prog\n#if defined(FEAT_SYN_HL) || defined(PROTO)\nstatic int\thad_eol;\t// TRUE when EOL found by vim_regcomp()\n#endif\n\nstatic magic_T\treg_magic;\t// magicness of the pattern\n\nstatic int\treg_string;\t// matching with a string instead of a buffer\n\t\t\t\t// line\nstatic int\treg_strict;\t// \"[abc\" is illegal\n\n/*\n * META contains all characters that may be magic, except '^' and '$'.\n */\n\n// META[] is used often enough to justify turning it into a table.\nstatic char_u META_flags[] = {\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n//\t\t   %  &     (  )  *  +\t      .\n    0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 1, 0,\n//     1  2  3\t4  5  6  7  8  9\t<  =  >  ?\n    0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1,\n//  @  A     C\tD     F     H  I     K\tL  M\t O\n    1, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 0, 1,\n//  P\t     S\t   U  V  W  X\t  Z  [\t\t _\n    1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1,\n//     a     c\td     f     h  i     k\tl  m  n  o\n    0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1,\n//  p\t     s\t   u  v  w  x\t  z  {\t|     ~\n    1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1\n};\n\nstatic int\tcurchr;\t\t// currently parsed character\n// Previous character.  Note: prevchr is sometimes -1 when we are not at the\n// start, eg in /[ ^I]^ the pattern was never found even if it existed,\n// because ^ was taken to be magic -- webb\nstatic int\tprevchr;\nstatic int\tprevprevchr;\t// previous-previous character\nstatic int\tnextchr;\t// used for ungetchr()\n\n// arguments for reg()\n#define REG_NOPAREN\t0\t// toplevel reg()\n#define REG_PAREN\t1\t// \\(\\)\n#define REG_ZPAREN\t2\t// \\z(\\)\n#define REG_NPAREN\t3\t// \\%(\\)\n\ntypedef struct\n{\n     char_u\t*regparse;\n     int\tprevchr_len;\n     int\tcurchr;\n     int\tprevchr;\n     int\tprevprevchr;\n     int\tnextchr;\n     int\tat_start;\n     int\tprev_at_start;\n     int\tregnpar;\n} parse_state_T;\n\nstatic void\tinitchr(char_u *);\nstatic int\tgetchr(void);\nstatic void\tskipchr_keepstart(void);\nstatic int\tpeekchr(void);\nstatic void\tskipchr(void);\nstatic void\tungetchr(void);\nstatic long\tgethexchrs(int maxinputlen);\nstatic long\tgetoctchrs(void);\nstatic long\tgetdecchrs(void);\nstatic int\tcoll_get_char(void);\nstatic int\tprog_magic_wrong(void);\nstatic int\tcstrncmp(char_u *s1, char_u *s2, int *n);\nstatic char_u\t*cstrchr(char_u *, int);\nstatic int\tre_mult_next(char *what);\nstatic int\treg_iswordc(int);\n#ifdef FEAT_EVAL\nstatic void report_re_switch(char_u *pat);\n#endif\n\nstatic regengine_T bt_regengine;\nstatic regengine_T nfa_regengine;\n\n/*\n * Return TRUE if compiled regular expression \"prog\" can match a line break.\n */\n    int\nre_multiline(regprog_T *prog)\n{\n    return (prog->regflags & RF_HASNL);\n}\n\n/*\n * Check for an equivalence class name \"[=a=]\".  \"pp\" points to the '['.\n * Returns a character representing the class. Zero means that no item was\n * recognized.  Otherwise \"pp\" is advanced to after the item.\n */\n    static int\nget_equi_class(char_u **pp)\n{\n    int\t\tc;\n    int\t\tl = 1;\n    char_u\t*p = *pp;\n\n    if (p[1] == '=' && p[2] != NUL)\n    {\n\tif (has_mbyte)\n\t    l = (*mb_ptr2len)(p + 2);\n\tif (p[l + 2] == '=' && p[l + 3] == ']')\n\t{\n\t    if (has_mbyte)\n\t\tc = mb_ptr2char(p + 2);\n\t    else\n\t\tc = p[2];\n\t    *pp += l + 4;\n\t    return c;\n\t}\n    }\n    return 0;\n}\n\n/*\n * Check for a collating element \"[.a.]\".  \"pp\" points to the '['.\n * Returns a character. Zero means that no item was recognized.  Otherwise\n * \"pp\" is advanced to after the item.\n * Currently only single characters are recognized!\n */\n    static int\nget_coll_element(char_u **pp)\n{\n    int\t\tc;\n    int\t\tl = 1;\n    char_u\t*p = *pp;\n\n    if (p[0] != NUL && p[1] == '.' && p[2] != NUL)\n    {\n\tif (has_mbyte)\n\t    l = (*mb_ptr2len)(p + 2);\n\tif (p[l + 2] == '.' && p[l + 3] == ']')\n\t{\n\t    if (has_mbyte)\n\t\tc = mb_ptr2char(p + 2);\n\t    else\n\t\tc = p[2];\n\t    *pp += l + 4;\n\t    return c;\n\t}\n    }\n    return 0;\n}\n\nstatic int reg_cpo_lit; // 'cpoptions' contains 'l' flag\nstatic int reg_cpo_bsl; // 'cpoptions' contains '\\' flag\n\n    static void\nget_cpo_flags(void)\n{\n    reg_cpo_lit = vim_strchr(p_cpo, CPO_LITERAL) != NULL;\n    reg_cpo_bsl = vim_strchr(p_cpo, CPO_BACKSL) != NULL;\n}\n\n/*\n * Skip over a \"[]\" range.\n * \"p\" must point to the character after the '['.\n * The returned pointer is on the matching ']', or the terminating NUL.\n */\n    static char_u *\nskip_anyof(char_u *p)\n{\n    int\t\tl;\n\n    if (*p == '^')\t// Complement of range.\n\t++p;\n    if (*p == ']' || *p == '-')\n\t++p;\n    while (*p != NUL && *p != ']')\n    {\n\tif (has_mbyte && (l = (*mb_ptr2len)(p)) > 1)\n\t    p += l;\n\telse\n\t    if (*p == '-')\n\t    {\n\t\t++p;\n\t\tif (*p != ']' && *p != NUL)\n\t\t    MB_PTR_ADV(p);\n\t    }\n\telse if (*p == '\\\\'\n\t\t&& !reg_cpo_bsl\n\t\t&& (vim_strchr(REGEXP_INRANGE, p[1]) != NULL\n\t\t    || (!reg_cpo_lit && vim_strchr(REGEXP_ABBR, p[1]) != NULL)))\n\t    p += 2;\n\telse if (*p == '[')\n\t{\n\t    if (get_char_class(&p) == CLASS_NONE\n\t\t    && get_equi_class(&p) == 0\n\t\t    && get_coll_element(&p) == 0\n\t\t    && *p != NUL)\n\t\t++p; // it is not a class name and not NUL\n\t}\n\telse\n\t    ++p;\n    }\n\n    return p;\n}\n\n/*\n * Skip past regular expression.\n * Stop at end of \"startp\" or where \"delim\" is found ('/', '?', etc).\n * Take care of characters with a backslash in front of it.\n * Skip strings inside [ and ].\n */\n    char_u *\nskip_regexp(\n    char_u\t*startp,\n    int\t\tdelim,\n    int\t\tmagic)\n{\n    return skip_regexp_ex(startp, delim, magic, NULL, NULL, NULL);\n}\n\n/*\n * Call skip_regexp() and when the delimiter does not match give an error and\n * return NULL.\n */\n    char_u *\nskip_regexp_err(\n    char_u\t*startp,\n    int\t\tdelim,\n    int\t\tmagic)\n{\n    char_u *p = skip_regexp(startp, delim, magic);\n\n    if (*p != delim)\n    {\n\tsemsg(_(e_missing_delimiter_after_search_pattern_str), startp);\n\treturn NULL;\n    }\n    return p;\n}\n\n/*\n * skip_regexp() with extra arguments:\n * When \"newp\" is not NULL and \"dirc\" is '?', make an allocated copy of the\n * expression and change \"\\?\" to \"?\".  If \"*newp\" is not NULL the expression\n * is changed in-place.\n * If a \"\\?\" is changed to \"?\" then \"dropped\" is incremented, unless NULL.\n * If \"magic_val\" is not NULL, returns the effective magicness of the pattern\n */\n    char_u *\nskip_regexp_ex(\n    char_u\t*startp,\n    int\t\tdirc,\n    int\t\tmagic,\n    char_u\t**newp,\n    int\t\t*dropped,\n    magic_T\t*magic_val)\n{\n    magic_T\tmymagic;\n    char_u\t*p = startp;\n\n    if (magic)\n\tmymagic = MAGIC_ON;\n    else\n\tmymagic = MAGIC_OFF;\n    get_cpo_flags();\n\n    for (; p[0] != NUL; MB_PTR_ADV(p))\n    {\n\tif (p[0] == dirc)\t// found end of regexp\n\t    break;\n\tif ((p[0] == '[' && mymagic >= MAGIC_ON)\n\t\t|| (p[0] == '\\\\' && p[1] == '[' && mymagic <= MAGIC_OFF))\n\t{\n\t    p = skip_anyof(p + 1);\n\t    if (p[0] == NUL)\n\t\tbreak;\n\t}\n\telse if (p[0] == '\\\\' && p[1] != NUL)\n\t{\n\t    if (dirc == '?' && newp != NULL && p[1] == '?')\n\t    {\n\t\t// change \"\\?\" to \"?\", make a copy first.\n\t\tif (*newp == NULL)\n\t\t{\n\t\t    *newp = vim_strsave(startp);\n\t\t    if (*newp != NULL)\n\t\t\tp = *newp + (p - startp);\n\t\t}\n\t\tif (dropped != NULL)\n\t\t    ++*dropped;\n\t\tif (*newp != NULL)\n\t\t    STRMOVE(p, p + 1);\n\t\telse\n\t\t    ++p;\n\t    }\n\t    else\n\t\t++p;    // skip next character\n\t    if (*p == 'v')\n\t\tmymagic = MAGIC_ALL;\n\t    else if (*p == 'V')\n\t\tmymagic = MAGIC_NONE;\n\t}\n    }\n    if (magic_val != NULL)\n\t*magic_val = mymagic;\n    return p;\n}\n\n/*\n * Functions for getting characters from the regexp input.\n */\nstatic int\tprevchr_len;\t// byte length of previous char\nstatic int\tat_start;\t// True when on the first character\nstatic int\tprev_at_start;  // True when on the second character\n\n/*\n * Start parsing at \"str\".\n */\n    static void\ninitchr(char_u *str)\n{\n    regparse = str;\n    prevchr_len = 0;\n    curchr = prevprevchr = prevchr = nextchr = -1;\n    at_start = TRUE;\n    prev_at_start = FALSE;\n}\n\n/*\n * Save the current parse state, so that it can be restored and parsing\n * starts in the same state again.\n */\n    static void\nsave_parse_state(parse_state_T *ps)\n{\n    ps->regparse = regparse;\n    ps->prevchr_len = prevchr_len;\n    ps->curchr = curchr;\n    ps->prevchr = prevchr;\n    ps->prevprevchr = prevprevchr;\n    ps->nextchr = nextchr;\n    ps->at_start = at_start;\n    ps->prev_at_start = prev_at_start;\n    ps->regnpar = regnpar;\n}\n\n/*\n * Restore a previously saved parse state.\n */\n    static void\nrestore_parse_state(parse_state_T *ps)\n{\n    regparse = ps->regparse;\n    prevchr_len = ps->prevchr_len;\n    curchr = ps->curchr;\n    prevchr = ps->prevchr;\n    prevprevchr = ps->prevprevchr;\n    nextchr = ps->nextchr;\n    at_start = ps->at_start;\n    prev_at_start = ps->prev_at_start;\n    regnpar = ps->regnpar;\n}\n\n\n/*\n * Get the next character without advancing.\n */\n    static int\npeekchr(void)\n{\n    static int\tafter_slash = FALSE;\n\n    if (curchr == -1)\n    {\n\tswitch (curchr = regparse[0])\n\t{\n\tcase '.':\n\tcase '[':\n\tcase '~':\n\t    // magic when 'magic' is on\n\t    if (reg_magic >= MAGIC_ON)\n\t\tcurchr = Magic(curchr);\n\t    break;\n\tcase '(':\n\tcase ')':\n\tcase '{':\n\tcase '%':\n\tcase '+':\n\tcase '=':\n\tcase '?':\n\tcase '@':\n\tcase '!':\n\tcase '&':\n\tcase '|':\n\tcase '<':\n\tcase '>':\n\tcase '#':\t// future ext.\n\tcase '\"':\t// future ext.\n\tcase '\\'':\t// future ext.\n\tcase ',':\t// future ext.\n\tcase '-':\t// future ext.\n\tcase ':':\t// future ext.\n\tcase ';':\t// future ext.\n\tcase '`':\t// future ext.\n\tcase '/':\t// Can't be used in / command\n\t    // magic only after \"\\v\"\n\t    if (reg_magic == MAGIC_ALL)\n\t\tcurchr = Magic(curchr);\n\t    break;\n\tcase '*':\n\t    // * is not magic as the very first character, eg \"?*ptr\", when\n\t    // after '^', eg \"/^*ptr\" and when after \"\\(\", \"\\|\", \"\\&\".  But\n\t    // \"\\(\\*\" is not magic, thus must be magic if \"after_slash\"\n\t    if (reg_magic >= MAGIC_ON\n\t\t    && !at_start\n\t\t    && !(prev_at_start && prevchr == Magic('^'))\n\t\t    && (after_slash\n\t\t\t|| (prevchr != Magic('(')\n\t\t\t    && prevchr != Magic('&')\n\t\t\t    && prevchr != Magic('|'))))\n\t\tcurchr = Magic('*');\n\t    break;\n\tcase '^':\n\t    // '^' is only magic as the very first character and if it's after\n\t    // \"\\(\", \"\\|\", \"\\&' or \"\\n\"\n\t    if (reg_magic >= MAGIC_OFF\n\t\t    && (at_start\n\t\t\t|| reg_magic == MAGIC_ALL\n\t\t\t|| prevchr == Magic('(')\n\t\t\t|| prevchr == Magic('|')\n\t\t\t|| prevchr == Magic('&')\n\t\t\t|| prevchr == Magic('n')\n\t\t\t|| (no_Magic(prevchr) == '('\n\t\t\t    && prevprevchr == Magic('%'))))\n\t    {\n\t\tcurchr = Magic('^');\n\t\tat_start = TRUE;\n\t\tprev_at_start = FALSE;\n\t    }\n\t    break;\n\tcase '$':\n\t    // '$' is only magic as the very last char and if it's in front of\n\t    // either \"\\|\", \"\\)\", \"\\&\", or \"\\n\"\n\t    if (reg_magic >= MAGIC_OFF)\n\t    {\n\t\tchar_u *p = regparse + 1;\n\t\tint is_magic_all = (reg_magic == MAGIC_ALL);\n\n\t\t// ignore \\c \\C \\m \\M \\v \\V and \\Z after '$'\n\t\twhile (p[0] == '\\\\' && (p[1] == 'c' || p[1] == 'C'\n\t\t\t\t|| p[1] == 'm' || p[1] == 'M'\n\t\t\t\t|| p[1] == 'v' || p[1] == 'V' || p[1] == 'Z'))\n\t\t{\n\t\t    if (p[1] == 'v')\n\t\t\tis_magic_all = TRUE;\n\t\t    else if (p[1] == 'm' || p[1] == 'M' || p[1] == 'V')\n\t\t\tis_magic_all = FALSE;\n\t\t    p += 2;\n\t\t}\n\t\tif (p[0] == NUL\n\t\t\t|| (p[0] == '\\\\'\n\t\t\t    && (p[1] == '|' || p[1] == '&' || p[1] == ')'\n\t\t\t\t|| p[1] == 'n'))\n\t\t\t|| (is_magic_all\n\t\t\t       && (p[0] == '|' || p[0] == '&' || p[0] == ')'))\n\t\t\t|| reg_magic == MAGIC_ALL)\n\t\t    curchr = Magic('$');\n\t    }\n\t    break;\n\tcase '\\\\':\n\t    {\n\t\tint c = regparse[1];\n\n\t\tif (c == NUL)\n\t\t    curchr = '\\\\';\t// trailing '\\'\n\t\telse if (c <= '~' && META_flags[c])\n\t\t{\n\t\t    /*\n\t\t     * META contains everything that may be magic sometimes,\n\t\t     * except ^ and $ (\"\\^\" and \"\\$\" are only magic after\n\t\t     * \"\\V\").  We now fetch the next character and toggle its\n\t\t     * magicness.  Therefore, \\ is so meta-magic that it is\n\t\t     * not in META.\n\t\t     */\n\t\t    curchr = -1;\n\t\t    prev_at_start = at_start;\n\t\t    at_start = FALSE;\t// be able to say \"/\\*ptr\"\n\t\t    ++regparse;\n\t\t    ++after_slash;\n\t\t    peekchr();\n\t\t    --regparse;\n\t\t    --after_slash;\n\t\t    curchr = toggle_Magic(curchr);\n\t\t}\n\t\telse if (vim_strchr(REGEXP_ABBR, c))\n\t\t{\n\t\t    /*\n\t\t     * Handle abbreviations, like \"\\t\" for TAB -- webb\n\t\t     */\n\t\t    curchr = backslash_trans(c);\n\t\t}\n\t\telse if (reg_magic == MAGIC_NONE && (c == '$' || c == '^'))\n\t\t    curchr = toggle_Magic(c);\n\t\telse\n\t\t{\n\t\t    /*\n\t\t     * Next character can never be (made) magic?\n\t\t     * Then backslashing it won't do anything.\n\t\t     */\n\t\t    if (has_mbyte)\n\t\t\tcurchr = (*mb_ptr2char)(regparse + 1);\n\t\t    else\n\t\t\tcurchr = c;\n\t\t}\n\t\tbreak;\n\t    }\n\n\tdefault:\n\t    if (has_mbyte)\n\t\tcurchr = (*mb_ptr2char)(regparse);\n\t}\n    }\n\n    return curchr;\n}\n\n/*\n * Eat one lexed character.  Do this in a way that we can undo it.\n */\n    static void\nskipchr(void)\n{\n    // peekchr() eats a backslash, do the same here\n    if (*regparse == '\\\\')\n\tprevchr_len = 1;\n    else\n\tprevchr_len = 0;\n    if (regparse[prevchr_len] != NUL)\n    {\n\tif (enc_utf8)\n\t    // exclude composing chars that mb_ptr2len does include\n\t    prevchr_len += utf_ptr2len(regparse + prevchr_len);\n\telse if (has_mbyte)\n\t    prevchr_len += (*mb_ptr2len)(regparse + prevchr_len);\n\telse\n\t    ++prevchr_len;\n    }\n    regparse += prevchr_len;\n    prev_at_start = at_start;\n    at_start = FALSE;\n    prevprevchr = prevchr;\n    prevchr = curchr;\n    curchr = nextchr;\t    // use previously unget char, or -1\n    nextchr = -1;\n}\n\n/*\n * Skip a character while keeping the value of prev_at_start for at_start.\n * prevchr and prevprevchr are also kept.\n */\n    static void\nskipchr_keepstart(void)\n{\n    int as = prev_at_start;\n    int pr = prevchr;\n    int prpr = prevprevchr;\n\n    skipchr();\n    at_start = as;\n    prevchr = pr;\n    prevprevchr = prpr;\n}\n\n/*\n * Get the next character from the pattern. We know about magic and such, so\n * therefore we need a lexical analyzer.\n */\n    static int\ngetchr(void)\n{\n    int chr = peekchr();\n\n    skipchr();\n    return chr;\n}\n\n/*\n * put character back.  Works only once!\n */\n    static void\nungetchr(void)\n{\n    nextchr = curchr;\n    curchr = prevchr;\n    prevchr = prevprevchr;\n    at_start = prev_at_start;\n    prev_at_start = FALSE;\n\n    // Backup regparse, so that it's at the same position as before the\n    // getchr().\n    regparse -= prevchr_len;\n}\n\n/*\n * Get and return the value of the hex string at the current position.\n * Return -1 if there is no valid hex number.\n * The position is updated:\n *     blahblah\\%x20asdf\n *\t   before-^ ^-after\n * The parameter controls the maximum number of input characters. This will be\n * 2 when reading a \\%x20 sequence and 4 when reading a \\%u20AC sequence.\n */\n    static long\ngethexchrs(int maxinputlen)\n{\n    long_u\tnr = 0;\n    int\t\tc;\n    int\t\ti;\n\n    for (i = 0; i < maxinputlen; ++i)\n    {\n\tc = regparse[0];\n\tif (!vim_isxdigit(c))\n\t    break;\n\tnr <<= 4;\n\tnr |= hex2nr(c);\n\t++regparse;\n    }\n\n    if (i == 0)\n\treturn -1;\n    return (long)nr;\n}\n\n/*\n * Get and return the value of the decimal string immediately after the\n * current position. Return -1 for invalid.  Consumes all digits.\n */\n    static long\ngetdecchrs(void)\n{\n    long_u\tnr = 0;\n    int\t\tc;\n    int\t\ti;\n\n    for (i = 0; ; ++i)\n    {\n\tc = regparse[0];\n\tif (c < '0' || c > '9')\n\t    break;\n\tnr *= 10;\n\tnr += c - '0';\n\t++regparse;\n\tcurchr = -1; // no longer valid\n    }\n\n    if (i == 0)\n\treturn -1;\n    return (long)nr;\n}\n\n/*\n * get and return the value of the octal string immediately after the current\n * position. Return -1 for invalid, or 0-255 for valid. Smart enough to handle\n * numbers > 377 correctly (for example, 400 is treated as 40) and doesn't\n * treat 8 or 9 as recognised characters. Position is updated:\n *     blahblah\\%o210asdf\n *\t   before-^  ^-after\n */\n    static long\ngetoctchrs(void)\n{\n    long_u\tnr = 0;\n    int\t\tc;\n    int\t\ti;\n\n    for (i = 0; i < 3 && nr < 040; ++i)\n    {\n\tc = regparse[0];\n\tif (c < '0' || c > '7')\n\t    break;\n\tnr <<= 3;\n\tnr |= hex2nr(c);\n\t++regparse;\n    }\n\n    if (i == 0)\n\treturn -1;\n    return (long)nr;\n}\n\n/*\n * read_limits - Read two integers to be taken as a minimum and maximum.\n * If the first character is '-', then the range is reversed.\n * Should end with 'end'.  If minval is missing, zero is default, if maxval is\n * missing, a very big number is the default.\n */\n    static int\nread_limits(long *minval, long *maxval)\n{\n    int\t\treverse = FALSE;\n    char_u\t*first_char;\n    long\ttmp;\n\n    if (*regparse == '-')\n    {\n\t// Starts with '-', so reverse the range later\n\tregparse++;\n\treverse = TRUE;\n    }\n    first_char = regparse;\n    *minval = getdigits(&regparse);\n    if (*regparse == ',')\t    // There is a comma\n    {\n\tif (vim_isdigit(*++regparse))\n\t    *maxval = getdigits(&regparse);\n\telse\n\t    *maxval = MAX_LIMIT;\n    }\n    else if (VIM_ISDIGIT(*first_char))\n\t*maxval = *minval;\t    // It was \\{n} or \\{-n}\n    else\n\t*maxval = MAX_LIMIT;\t    // It was \\{} or \\{-}\n    if (*regparse == '\\\\')\n\tregparse++;\t// Allow either \\{...} or \\{...\\}\n    if (*regparse != '}')\n\tEMSG2_RET_FAIL(_(e_syntax_error_in_str_curlies),\n\t\t\t\t\t\t       reg_magic == MAGIC_ALL);\n\n    /*\n     * Reverse the range if there was a '-', or make sure it is in the right\n     * order otherwise.\n     */\n    if ((!reverse && *minval > *maxval) || (reverse && *minval < *maxval))\n    {\n\ttmp = *minval;\n\t*minval = *maxval;\n\t*maxval = tmp;\n    }\n    skipchr();\t\t// let's be friends with the lexer again\n    return OK;\n}\n\n/*\n * vim_regexec and friends\n */\n\n/*\n * Global work variables for vim_regexec().\n */\n\nstatic void\tcleanup_subexpr(void);\n#ifdef FEAT_SYN_HL\nstatic void\tcleanup_zsubexpr(void);\n#endif\nstatic void\treg_nextline(void);\nstatic int\tmatch_with_backref(linenr_T start_lnum, colnr_T start_col, linenr_T end_lnum, colnr_T end_col, int *bytelen);\n\n/*\n * Sometimes need to save a copy of a line.  Since alloc()/free() is very\n * slow, we keep one allocated piece of memory and only re-allocate it when\n * it's too small.  It's freed in bt_regexec_both() when finished.\n */\nstatic char_u\t*reg_tofree = NULL;\nstatic unsigned\treg_tofreelen;\n\n/*\n * Structure used to store the execution state of the regex engine.\n * Which ones are set depends on whether a single-line or multi-line match is\n * done:\n *\t\t\tsingle-line\t\tmulti-line\n * reg_match\t\t&regmatch_T\t\tNULL\n * reg_mmatch\t\tNULL\t\t\t&regmmatch_T\n * reg_startp\t\treg_match->startp\t<invalid>\n * reg_endp\t\treg_match->endp\t\t<invalid>\n * reg_startpos\t\t<invalid>\t\treg_mmatch->startpos\n * reg_endpos\t\t<invalid>\t\treg_mmatch->endpos\n * reg_win\t\tNULL\t\t\twindow in which to search\n * reg_buf\t\tcurbuf\t\t\tbuffer in which to search\n * reg_firstlnum\t<invalid>\t\tfirst line in which to search\n * reg_maxline\t\t0\t\t\tlast line nr\n * reg_line_lbr\t\tFALSE or TRUE\t\tFALSE\n */\ntypedef struct {\n    regmatch_T\t\t*reg_match;\n    regmmatch_T\t\t*reg_mmatch;\n    char_u\t\t**reg_startp;\n    char_u\t\t**reg_endp;\n    lpos_T\t\t*reg_startpos;\n    lpos_T\t\t*reg_endpos;\n    win_T\t\t*reg_win;\n    buf_T\t\t*reg_buf;\n    linenr_T\t\treg_firstlnum;\n    linenr_T\t\treg_maxline;\n    int\t\t\treg_line_lbr;\t// \"\\n\" in string is line break\n\n    // The current match-position is stord in these variables:\n    linenr_T\tlnum;\t\t// line number, relative to first line\n    char_u\t*line;\t\t// start of current line\n    char_u\t*input;\t\t// current input, points into \"line\"\n\n    int\tneed_clear_subexpr;\t// subexpressions still need to be cleared\n#ifdef FEAT_SYN_HL\n    int\tneed_clear_zsubexpr;\t// extmatch subexpressions still need to be\n\t\t\t\t// cleared\n#endif\n\n    // Internal copy of 'ignorecase'.  It is set at each call to vim_regexec().\n    // Normally it gets the value of \"rm_ic\" or \"rmm_ic\", but when the pattern\n    // contains '\\c' or '\\C' the value is overruled.\n    int\t\t\treg_ic;\n\n    // Similar to \"reg_ic\", but only for 'combining' characters.  Set with \\Z\n    // flag in the regexp.  Defaults to false, always.\n    int\t\t\treg_icombine;\n\n    // Copy of \"rmm_maxcol\": maximum column to search for a match.  Zero when\n    // there is no maximum.\n    colnr_T\t\treg_maxcol;\n\n    // State for the NFA engine regexec.\n    int nfa_has_zend;\t    // NFA regexp \\ze operator encountered.\n    int nfa_has_backref;    // NFA regexp \\1 .. \\9 encountered.\n    int nfa_nsubexpr;\t    // Number of sub expressions actually being used\n\t\t\t    // during execution. 1 if only the whole match\n\t\t\t    // (subexpr 0) is used.\n    // listid is global, so that it increases on recursive calls to\n    // nfa_regmatch(), which means we don't have to clear the lastlist field of\n    // all the states.\n    int nfa_listid;\n    int nfa_alt_listid;\n\n#ifdef FEAT_SYN_HL\n    int nfa_has_zsubexpr;   // NFA regexp has \\z( ), set zsubexpr.\n#endif\n} regexec_T;\n\nstatic regexec_T\trex;\nstatic int\t\trex_in_use = FALSE;\n\n/*\n * Return TRUE if character 'c' is included in 'iskeyword' option for\n * \"reg_buf\" buffer.\n */\n    static int\nreg_iswordc(int c)\n{\n    return vim_iswordc_buf(c, rex.reg_buf);\n}\n\n/*\n * Get pointer to the line \"lnum\", which is relative to \"reg_firstlnum\".\n */\n    static char_u *\nreg_getline(linenr_T lnum)\n{\n    // when looking behind for a match/no-match lnum is negative.  But we\n    // can't go before line 1\n    if (rex.reg_firstlnum + lnum < 1)\n\treturn NULL;\n    if (lnum > rex.reg_maxline)\n\t// Must have matched the \"\\n\" in the last line.\n\treturn (char_u *)\"\";\n    return ml_get_buf(rex.reg_buf, rex.reg_firstlnum + lnum, FALSE);\n}\n\n#ifdef FEAT_SYN_HL\nstatic char_u\t*reg_startzp[NSUBEXP];\t// Workspace to mark beginning\nstatic char_u\t*reg_endzp[NSUBEXP];\t//   and end of \\z(...\\) matches\nstatic lpos_T\treg_startzpos[NSUBEXP];\t// idem, beginning pos\nstatic lpos_T\treg_endzpos[NSUBEXP];\t// idem, end pos\n#endif\n\n// TRUE if using multi-line regexp.\n#define REG_MULTI\t(rex.reg_match == NULL)\n\n#ifdef FEAT_SYN_HL\n/*\n * Create a new extmatch and mark it as referenced once.\n */\n    static reg_extmatch_T *\nmake_extmatch(void)\n{\n    reg_extmatch_T\t*em;\n\n    em = ALLOC_CLEAR_ONE(reg_extmatch_T);\n    if (em != NULL)\n\tem->refcnt = 1;\n    return em;\n}\n\n/*\n * Add a reference to an extmatch.\n */\n    reg_extmatch_T *\nref_extmatch(reg_extmatch_T *em)\n{\n    if (em != NULL)\n\tem->refcnt++;\n    return em;\n}\n\n/*\n * Remove a reference to an extmatch.  If there are no references left, free\n * the info.\n */\n    void\nunref_extmatch(reg_extmatch_T *em)\n{\n    int i;\n\n    if (em != NULL && --em->refcnt <= 0)\n    {\n\tfor (i = 0; i < NSUBEXP; ++i)\n\t    vim_free(em->matches[i]);\n\tvim_free(em);\n    }\n}\n#endif\n\n/*\n * Get class of previous character.\n */\n    static int\nreg_prev_class(void)\n{\n    if (rex.input > rex.line)\n\treturn mb_get_class_buf(rex.input - 1\n\t\t       - (*mb_head_off)(rex.line, rex.input - 1), rex.reg_buf);\n    return -1;\n}\n\n/*\n * Return TRUE if the current rex.input position matches the Visual area.\n */\n    static int\nreg_match_visual(void)\n{\n    pos_T\ttop, bot;\n    linenr_T    lnum;\n    colnr_T\tcol;\n    win_T\t*wp = rex.reg_win == NULL ? curwin : rex.reg_win;\n    int\t\tmode;\n    colnr_T\tstart, end;\n    colnr_T\tstart2, end2;\n    colnr_T\tcols;\n    colnr_T\tcurswant;\n\n    // Check if the buffer is the current buffer and not using a string.\n    if (rex.reg_buf != curbuf || VIsual.lnum == 0 || !REG_MULTI)\n\treturn FALSE;\n\n    if (VIsual_active)\n    {\n\tif (LT_POS(VIsual, wp->w_cursor))\n\t{\n\t    top = VIsual;\n\t    bot = wp->w_cursor;\n\t}\n\telse\n\t{\n\t    top = wp->w_cursor;\n\t    bot = VIsual;\n\t}\n\tmode = VIsual_mode;\n\tcurswant = wp->w_curswant;\n    }\n    else\n    {\n\tif (LT_POS(curbuf->b_visual.vi_start, curbuf->b_visual.vi_end))\n\t{\n\t    top = curbuf->b_visual.vi_start;\n\t    bot = curbuf->b_visual.vi_end;\n\t}\n\telse\n\t{\n\t    top = curbuf->b_visual.vi_end;\n\t    bot = curbuf->b_visual.vi_start;\n\t}\n\tmode = curbuf->b_visual.vi_mode;\n\tcurswant = curbuf->b_visual.vi_curswant;\n    }\n    lnum = rex.lnum + rex.reg_firstlnum;\n    if (lnum < top.lnum || lnum > bot.lnum)\n\treturn FALSE;\n\n    col = (colnr_T)(rex.input - rex.line);\n    if (mode == 'v')\n    {\n\tif ((lnum == top.lnum && col < top.col)\n\t\t|| (lnum == bot.lnum && col >= bot.col + (*p_sel != 'e')))\n\t    return FALSE;\n    }\n    else if (mode == Ctrl_V)\n    {\n\tgetvvcol(wp, &top, &start, NULL, &end);\n\tgetvvcol(wp, &bot, &start2, NULL, &end2);\n\tif (start2 < start)\n\t    start = start2;\n\tif (end2 > end)\n\t    end = end2;\n\tif (top.col == MAXCOL || bot.col == MAXCOL || curswant == MAXCOL)\n\t    end = MAXCOL;\n\n\t// getvvcol() flushes rex.line, need to get it again\n\trex.line = reg_getline(rex.lnum);\n\trex.input = rex.line + col;\n\n\tcols = win_linetabsize(wp, rex.reg_firstlnum + rex.lnum, rex.line, col);\n\tif (cols < start || cols > end - (*p_sel == 'e'))\n\t    return FALSE;\n    }\n    return TRUE;\n}\n\n/*\n * Check the regexp program for its magic number.\n * Return TRUE if it's wrong.\n */\n    static int\nprog_magic_wrong(void)\n{\n    regprog_T\t*prog;\n\n    prog = REG_MULTI ? rex.reg_mmatch->regprog : rex.reg_match->regprog;\n    if (prog->engine == &nfa_regengine)\n\t// For NFA matcher we don't check the magic\n\treturn FALSE;\n\n    if (UCHARAT(((bt_regprog_T *)prog)->program) != REGMAGIC)\n    {\n\temsg(_(e_corrupted_regexp_program));\n\treturn TRUE;\n    }\n    return FALSE;\n}\n\n/*\n * Cleanup the subexpressions, if this wasn't done yet.\n * This construction is used to clear the subexpressions only when they are\n * used (to increase speed).\n */\n    static void\ncleanup_subexpr(void)\n{\n    if (rex.need_clear_subexpr)\n    {\n\tif (REG_MULTI)\n\t{\n\t    // Use 0xff to set lnum to -1\n\t    vim_memset(rex.reg_startpos, 0xff, sizeof(lpos_T) * NSUBEXP);\n\t    vim_memset(rex.reg_endpos, 0xff, sizeof(lpos_T) * NSUBEXP);\n\t}\n\telse\n\t{\n\t    vim_memset(rex.reg_startp, 0, sizeof(char_u *) * NSUBEXP);\n\t    vim_memset(rex.reg_endp, 0, sizeof(char_u *) * NSUBEXP);\n\t}\n\trex.need_clear_subexpr = FALSE;\n    }\n}\n\n#ifdef FEAT_SYN_HL\n    static void\ncleanup_zsubexpr(void)\n{\n    if (rex.need_clear_zsubexpr)\n    {\n\tif (REG_MULTI)\n\t{\n\t    // Use 0xff to set lnum to -1\n\t    vim_memset(reg_startzpos, 0xff, sizeof(lpos_T) * NSUBEXP);\n\t    vim_memset(reg_endzpos, 0xff, sizeof(lpos_T) * NSUBEXP);\n\t}\n\telse\n\t{\n\t    vim_memset(reg_startzp, 0, sizeof(char_u *) * NSUBEXP);\n\t    vim_memset(reg_endzp, 0, sizeof(char_u *) * NSUBEXP);\n\t}\n\trex.need_clear_zsubexpr = FALSE;\n    }\n}\n#endif\n\n/*\n * Advance rex.lnum, rex.line and rex.input to the next line.\n */\n    static void\nreg_nextline(void)\n{\n    rex.line = reg_getline(++rex.lnum);\n    rex.input = rex.line;\n    fast_breakcheck();\n}\n\n/*\n * Check whether a backreference matches.\n * Returns RA_FAIL, RA_NOMATCH or RA_MATCH.\n * If \"bytelen\" is not NULL, it is set to the byte length of the match in the\n * last line.\n */\n    static int\nmatch_with_backref(\n    linenr_T start_lnum,\n    colnr_T  start_col,\n    linenr_T end_lnum,\n    colnr_T  end_col,\n    int\t     *bytelen)\n{\n    linenr_T\tclnum = start_lnum;\n    colnr_T\tccol = start_col;\n    int\t\tlen;\n    char_u\t*p;\n\n    if (bytelen != NULL)\n\t*bytelen = 0;\n    for (;;)\n    {\n\t// Since getting one line may invalidate the other, need to make copy.\n\t// Slow!\n\tif (rex.line != reg_tofree)\n\t{\n\t    len = (int)STRLEN(rex.line);\n\t    if (reg_tofree == NULL || len >= (int)reg_tofreelen)\n\t    {\n\t\tlen += 50;\t// get some extra\n\t\tvim_free(reg_tofree);\n\t\treg_tofree = alloc(len);\n\t\tif (reg_tofree == NULL)\n\t\t    return RA_FAIL; // out of memory!\n\t\treg_tofreelen = len;\n\t    }\n\t    STRCPY(reg_tofree, rex.line);\n\t    rex.input = reg_tofree + (rex.input - rex.line);\n\t    rex.line = reg_tofree;\n\t}\n\n\t// Get the line to compare with.\n\tp = reg_getline(clnum);\n\tif (clnum == end_lnum)\n\t    len = end_col - ccol;\n\telse\n\t    len = (int)STRLEN(p + ccol);\n\n\tif (cstrncmp(p + ccol, rex.input, &len) != 0)\n\t    return RA_NOMATCH;  // doesn't match\n\tif (bytelen != NULL)\n\t    *bytelen += len;\n\tif (clnum == end_lnum)\n\t    break;\t\t// match and at end!\n\tif (rex.lnum >= rex.reg_maxline)\n\t    return RA_NOMATCH;  // text too short\n\n\t// Advance to next line.\n\treg_nextline();\n\tif (bytelen != NULL)\n\t    *bytelen = 0;\n\t++clnum;\n\tccol = 0;\n\tif (got_int)\n\t    return RA_FAIL;\n    }\n\n    // found a match!  Note that rex.line may now point to a copy of the line,\n    // that should not matter.\n    return RA_MATCH;\n}\n\n/*\n * Used in a place where no * or \\+ can follow.\n */\n    static int\nre_mult_next(char *what)\n{\n    if (re_multi_type(peekchr()) == MULTI_MULT)\n    {\n       semsg(_(e_nfa_regexp_cannot_repeat_str), what);\n       rc_did_emsg = TRUE;\n       return FAIL;\n    }\n    return OK;\n}\n\ntypedef struct\n{\n    int a, b, c;\n} decomp_T;\n\n\n// 0xfb20 - 0xfb4f\nstatic decomp_T decomp_table[0xfb4f-0xfb20+1] =\n{\n    {0x5e2,0,0},\t\t// 0xfb20\talt ayin\n    {0x5d0,0,0},\t\t// 0xfb21\talt alef\n    {0x5d3,0,0},\t\t// 0xfb22\talt dalet\n    {0x5d4,0,0},\t\t// 0xfb23\talt he\n    {0x5db,0,0},\t\t// 0xfb24\talt kaf\n    {0x5dc,0,0},\t\t// 0xfb25\talt lamed\n    {0x5dd,0,0},\t\t// 0xfb26\talt mem-sofit\n    {0x5e8,0,0},\t\t// 0xfb27\talt resh\n    {0x5ea,0,0},\t\t// 0xfb28\talt tav\n    {'+', 0, 0},\t\t// 0xfb29\talt plus\n    {0x5e9, 0x5c1, 0},\t\t// 0xfb2a\tshin+shin-dot\n    {0x5e9, 0x5c2, 0},\t\t// 0xfb2b\tshin+sin-dot\n    {0x5e9, 0x5c1, 0x5bc},\t// 0xfb2c\tshin+shin-dot+dagesh\n    {0x5e9, 0x5c2, 0x5bc},\t// 0xfb2d\tshin+sin-dot+dagesh\n    {0x5d0, 0x5b7, 0},\t\t// 0xfb2e\talef+patah\n    {0x5d0, 0x5b8, 0},\t\t// 0xfb2f\talef+qamats\n    {0x5d0, 0x5b4, 0},\t\t// 0xfb30\talef+hiriq\n    {0x5d1, 0x5bc, 0},\t\t// 0xfb31\tbet+dagesh\n    {0x5d2, 0x5bc, 0},\t\t// 0xfb32\tgimel+dagesh\n    {0x5d3, 0x5bc, 0},\t\t// 0xfb33\tdalet+dagesh\n    {0x5d4, 0x5bc, 0},\t\t// 0xfb34\the+dagesh\n    {0x5d5, 0x5bc, 0},\t\t// 0xfb35\tvav+dagesh\n    {0x5d6, 0x5bc, 0},\t\t// 0xfb36\tzayin+dagesh\n    {0xfb37, 0, 0},\t\t// 0xfb37 -- UNUSED\n    {0x5d8, 0x5bc, 0},\t\t// 0xfb38\ttet+dagesh\n    {0x5d9, 0x5bc, 0},\t\t// 0xfb39\tyud+dagesh\n    {0x5da, 0x5bc, 0},\t\t// 0xfb3a\tkaf sofit+dagesh\n    {0x5db, 0x5bc, 0},\t\t// 0xfb3b\tkaf+dagesh\n    {0x5dc, 0x5bc, 0},\t\t// 0xfb3c\tlamed+dagesh\n    {0xfb3d, 0, 0},\t\t// 0xfb3d -- UNUSED\n    {0x5de, 0x5bc, 0},\t\t// 0xfb3e\tmem+dagesh\n    {0xfb3f, 0, 0},\t\t// 0xfb3f -- UNUSED\n    {0x5e0, 0x5bc, 0},\t\t// 0xfb40\tnun+dagesh\n    {0x5e1, 0x5bc, 0},\t\t// 0xfb41\tsamech+dagesh\n    {0xfb42, 0, 0},\t\t// 0xfb42 -- UNUSED\n    {0x5e3, 0x5bc, 0},\t\t// 0xfb43\tpe sofit+dagesh\n    {0x5e4, 0x5bc,0},\t\t// 0xfb44\tpe+dagesh\n    {0xfb45, 0, 0},\t\t// 0xfb45 -- UNUSED\n    {0x5e6, 0x5bc, 0},\t\t// 0xfb46\ttsadi+dagesh\n    {0x5e7, 0x5bc, 0},\t\t// 0xfb47\tqof+dagesh\n    {0x5e8, 0x5bc, 0},\t\t// 0xfb48\tresh+dagesh\n    {0x5e9, 0x5bc, 0},\t\t// 0xfb49\tshin+dagesh\n    {0x5ea, 0x5bc, 0},\t\t// 0xfb4a\ttav+dagesh\n    {0x5d5, 0x5b9, 0},\t\t// 0xfb4b\tvav+holam\n    {0x5d1, 0x5bf, 0},\t\t// 0xfb4c\tbet+rafe\n    {0x5db, 0x5bf, 0},\t\t// 0xfb4d\tkaf+rafe\n    {0x5e4, 0x5bf, 0},\t\t// 0xfb4e\tpe+rafe\n    {0x5d0, 0x5dc, 0}\t\t// 0xfb4f\talef-lamed\n};\n\n    static void\nmb_decompose(int c, int *c1, int *c2, int *c3)\n{\n    decomp_T d;\n\n    if (c >= 0xfb20 && c <= 0xfb4f)\n    {\n\td = decomp_table[c - 0xfb20];\n\t*c1 = d.a;\n\t*c2 = d.b;\n\t*c3 = d.c;\n    }\n    else\n    {\n\t*c1 = c;\n\t*c2 = *c3 = 0;\n    }\n}\n\n/*\n * Compare two strings, ignore case if rex.reg_ic set.\n * Return 0 if strings match, non-zero otherwise.\n * Correct the length \"*n\" when composing characters are ignored.\n */\n    static int\ncstrncmp(char_u *s1, char_u *s2, int *n)\n{\n    int\t\tresult;\n\n    if (!rex.reg_ic)\n\tresult = STRNCMP(s1, s2, *n);\n    else\n\tresult = MB_STRNICMP(s1, s2, *n);\n\n    // if it failed and it's utf8 and we want to combineignore:\n    if (result != 0 && enc_utf8 && rex.reg_icombine)\n    {\n\tchar_u\t*str1, *str2;\n\tint\tc1, c2, c11, c12;\n\tint\tjunk;\n\n\t// we have to handle the strcmp ourselves, since it is necessary to\n\t// deal with the composing characters by ignoring them:\n\tstr1 = s1;\n\tstr2 = s2;\n\tc1 = c2 = 0;\n\twhile ((int)(str1 - s1) < *n)\n\t{\n\t    c1 = mb_ptr2char_adv(&str1);\n\t    c2 = mb_ptr2char_adv(&str2);\n\n\t    // Decompose the character if necessary, into 'base' characters.\n\t    // Currently hard-coded for Hebrew, Arabic to be done...\n\t    if (c1 != c2 && (!rex.reg_ic || utf_fold(c1) != utf_fold(c2)))\n\t    {\n\t\t// decomposition necessary?\n\t\tmb_decompose(c1, &c11, &junk, &junk);\n\t\tmb_decompose(c2, &c12, &junk, &junk);\n\t\tc1 = c11;\n\t\tc2 = c12;\n\t\tif (c11 != c12\n\t\t\t    && (!rex.reg_ic || utf_fold(c11) != utf_fold(c12)))\n\t\t    break;\n\t    }\n\t}\n\tresult = c2 - c1;\n\tif (result == 0)\n\t    *n = (int)(str2 - s2);\n    }\n\n    return result;\n}\n\n/*\n * cstrchr: This function is used a lot for simple searches, keep it fast!\n */\n    static char_u *\ncstrchr(char_u *s, int c)\n{\n    char_u\t*p;\n    int\t\tcc;\n\n    if (!rex.reg_ic || (!enc_utf8 && mb_char2len(c) > 1))\n\treturn vim_strchr(s, c);\n\n    // tolower() and toupper() can be slow, comparing twice should be a lot\n    // faster (esp. when using MS Visual C++!).\n    // For UTF-8 need to use folded case.\n    if (enc_utf8 && c > 0x80)\n\tcc = utf_fold(c);\n    else\n\t if (MB_ISUPPER(c))\n\tcc = MB_TOLOWER(c);\n    else if (MB_ISLOWER(c))\n\tcc = MB_TOUPPER(c);\n    else\n\treturn vim_strchr(s, c);\n\n    if (has_mbyte)\n    {\n\tfor (p = s; *p != NUL; p += (*mb_ptr2len)(p))\n\t{\n\t    if (enc_utf8 && c > 0x80)\n\t    {\n\t\tif (utf_fold(utf_ptr2char(p)) == cc)\n\t\t    return p;\n\t    }\n\t    else if (*p == c || *p == cc)\n\t\treturn p;\n\t}\n    }\n    else\n\t// Faster version for when there are no multi-byte characters.\n\tfor (p = s; *p != NUL; ++p)\n\t    if (*p == c || *p == cc)\n\t\treturn p;\n\n    return NULL;\n}\n\n////////////////////////////////////////////////////////////////\n//\t\t      regsub stuff\t\t\t      //\n////////////////////////////////////////////////////////////////\n\n/*\n * We should define ftpr as a pointer to a function returning a pointer to\n * a function returning a pointer to a function ...\n * This is impossible, so we declare a pointer to a function returning a\n * void pointer. This should work for all compilers.\n */\ntypedef void (*(*fptr_T)(int *, int));\n\nstatic int vim_regsub_both(char_u *source, typval_T *expr, char_u *dest, int destlen, int flags);\n\n    static fptr_T\ndo_upper(int *d, int c)\n{\n    *d = MB_TOUPPER(c);\n\n    return (fptr_T)NULL;\n}\n\n    static fptr_T\ndo_Upper(int *d, int c)\n{\n    *d = MB_TOUPPER(c);\n\n    return (fptr_T)do_Upper;\n}\n\n    static fptr_T\ndo_lower(int *d, int c)\n{\n    *d = MB_TOLOWER(c);\n\n    return (fptr_T)NULL;\n}\n\n    static fptr_T\ndo_Lower(int *d, int c)\n{\n    *d = MB_TOLOWER(c);\n\n    return (fptr_T)do_Lower;\n}\n\n/*\n * regtilde(): Replace tildes in the pattern by the old pattern.\n *\n * Short explanation of the tilde: It stands for the previous replacement\n * pattern.  If that previous pattern also contains a ~ we should go back a\n * step further...  But we insert the previous pattern into the current one\n * and remember that.\n * This still does not handle the case where \"magic\" changes.  So require the\n * user to keep his hands off of \"magic\".\n *\n * The tildes are parsed once before the first call to vim_regsub().\n */\n    char_u *\nregtilde(char_u *source, int magic)\n{\n    char_u\t*newsub = source;\n    char_u\t*tmpsub;\n    char_u\t*p;\n    int\t\tlen;\n    int\t\tprevlen;\n\n    for (p = newsub; *p; ++p)\n    {\n\tif ((*p == '~' && magic) || (*p == '\\\\' && *(p + 1) == '~' && !magic))\n\t{\n\t    if (reg_prev_sub != NULL)\n\t    {\n\t\t// length = len(newsub) - 1 + len(prev_sub) + 1\n\t\tprevlen = (int)STRLEN(reg_prev_sub);\n\t\ttmpsub = alloc(STRLEN(newsub) + prevlen);\n\t\tif (tmpsub != NULL)\n\t\t{\n\t\t    // copy prefix\n\t\t    len = (int)(p - newsub);\t// not including ~\n\t\t    mch_memmove(tmpsub, newsub, (size_t)len);\n\t\t    // interpret tilde\n\t\t    mch_memmove(tmpsub + len, reg_prev_sub, (size_t)prevlen);\n\t\t    // copy postfix\n\t\t    if (!magic)\n\t\t\t++p;\t\t\t// back off backslash\n\t\t    STRCPY(tmpsub + len + prevlen, p + 1);\n\n\t\t    if (newsub != source)\t// already allocated newsub\n\t\t\tvim_free(newsub);\n\t\t    newsub = tmpsub;\n\t\t    p = newsub + len + prevlen;\n\t\t}\n\t    }\n\t    else if (magic)\n\t\tSTRMOVE(p, p + 1);\t// remove '~'\n\t    else\n\t\tSTRMOVE(p, p + 2);\t// remove '\\~'\n\t    --p;\n\t}\n\telse\n\t{\n\t    if (*p == '\\\\' && p[1])\t\t// skip escaped characters\n\t\t++p;\n\t    if (has_mbyte)\n\t\tp += (*mb_ptr2len)(p) - 1;\n\t}\n    }\n\n    // Store a copy of newsub  in reg_prev_sub.  It is always allocated,\n    // because recursive calls may make the returned string invalid.\n    vim_free(reg_prev_sub);\n    reg_prev_sub = vim_strsave(newsub);\n\n    return newsub;\n}\n\n#ifdef FEAT_EVAL\nstatic int can_f_submatch = FALSE;\t// TRUE when submatch() can be used\n\n// These pointers are used for reg_submatch().  Needed for when the\n// substitution string is an expression that contains a call to substitute()\n// and submatch().\ntypedef struct {\n    regmatch_T\t*sm_match;\n    regmmatch_T\t*sm_mmatch;\n    linenr_T\tsm_firstlnum;\n    linenr_T\tsm_maxline;\n    int\t\tsm_line_lbr;\n} regsubmatch_T;\n\nstatic regsubmatch_T rsm;  // can only be used when can_f_submatch is TRUE\n#endif\n\n#ifdef FEAT_EVAL\n\n/*\n * Put the submatches in \"argv[argskip]\" which is a list passed into\n * call_func() by vim_regsub_both().\n */\n    static int\nfill_submatch_list(int argc UNUSED, typval_T *argv, int argskip, int argcount)\n{\n    listitem_T\t*li;\n    int\t\ti;\n    char_u\t*s;\n    typval_T\t*listarg = argv + argskip;\n\n    if (argcount == argskip)\n\t// called function doesn't take a submatches argument\n\treturn argskip;\n\n    // Relies on sl_list to be the first item in staticList10_T.\n    init_static_list((staticList10_T *)(listarg->vval.v_list));\n\n    // There are always 10 list items in staticList10_T.\n    li = listarg->vval.v_list->lv_first;\n    for (i = 0; i < 10; ++i)\n    {\n\ts = rsm.sm_match->startp[i];\n\tif (s == NULL || rsm.sm_match->endp[i] == NULL)\n\t    s = NULL;\n\telse\n\t    s = vim_strnsave(s, rsm.sm_match->endp[i] - s);\n\tli->li_tv.v_type = VAR_STRING;\n\tli->li_tv.vval.v_string = s;\n\tli = li->li_next;\n    }\n    return argskip + 1;\n}\n\n    static void\nclear_submatch_list(staticList10_T *sl)\n{\n    int i;\n\n    for (i = 0; i < 10; ++i)\n\tvim_free(sl->sl_items[i].li_tv.vval.v_string);\n}\n#endif\n\n/*\n * vim_regsub() - perform substitutions after a vim_regexec() or\n * vim_regexec_multi() match.\n *\n * If \"flags\" has REGSUB_COPY really copy into \"dest[destlen]\".\n * Oterwise nothing is copied, only compue the length of the result.\n *\n * If \"flags\" has REGSUB_MAGIC then behave like 'magic' is set.\n *\n * If \"flags\" has REGSUB_BACKSLASH a backslash will be removed later, need to\n * double them to keep them, and insert a backslash before a CR to avoid it\n * being replaced with a line break later.\n *\n * Note: The matched text must not change between the call of\n * vim_regexec()/vim_regexec_multi() and vim_regsub()!  It would make the back\n * references invalid!\n *\n * Returns the size of the replacement, including terminating NUL.\n */\n    int\nvim_regsub(\n    regmatch_T\t*rmp,\n    char_u\t*source,\n    typval_T\t*expr,\n    char_u\t*dest,\n    int\t\tdestlen,\n    int\t\tflags)\n{\n    int\t\tresult;\n    regexec_T\trex_save;\n    int\t\trex_in_use_save = rex_in_use;\n\n    if (rex_in_use)\n\t// Being called recursively, save the state.\n\trex_save = rex;\n    rex_in_use = TRUE;\n\n    rex.reg_match = rmp;\n    rex.reg_mmatch = NULL;\n    rex.reg_maxline = 0;\n    rex.reg_buf = curbuf;\n    rex.reg_line_lbr = TRUE;\n    result = vim_regsub_both(source, expr, dest, destlen, flags);\n\n    rex_in_use = rex_in_use_save;\n    if (rex_in_use)\n\trex = rex_save;\n\n    return result;\n}\n\n    int\nvim_regsub_multi(\n    regmmatch_T\t*rmp,\n    linenr_T\tlnum,\n    char_u\t*source,\n    char_u\t*dest,\n    int\t\tdestlen,\n    int\t\tflags)\n{\n    int\t\tresult;\n    regexec_T\trex_save;\n    int\t\trex_in_use_save = rex_in_use;\n\n    if (rex_in_use)\n\t// Being called recursively, save the state.\n\trex_save = rex;\n    rex_in_use = TRUE;\n\n    rex.reg_match = NULL;\n    rex.reg_mmatch = rmp;\n    rex.reg_buf = curbuf;\t// always works on the current buffer!\n    rex.reg_firstlnum = lnum;\n    rex.reg_maxline = curbuf->b_ml.ml_line_count - lnum;\n    rex.reg_line_lbr = FALSE;\n    result = vim_regsub_both(source, NULL, dest, destlen, flags);\n\n    rex_in_use = rex_in_use_save;\n    if (rex_in_use)\n\trex = rex_save;\n\n    return result;\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n// When nesting more than a couple levels it's probably a mistake.\n# define MAX_REGSUB_NESTING 4\nstatic char_u   *eval_result[MAX_REGSUB_NESTING] = {NULL, NULL, NULL, NULL};\n\n# if defined(EXITFREE) || defined(PROTO)\n    void\nfree_resub_eval_result(void)\n{\n    int i;\n\n    for (i = 0; i < MAX_REGSUB_NESTING; ++i)\n\tVIM_CLEAR(eval_result[i]);\n}\n# endif\n#endif\n\n    static int\nvim_regsub_both(\n    char_u\t*source,\n    typval_T\t*expr,\n    char_u\t*dest,\n    int\t\tdestlen,\n    int\t\tflags)\n{\n    char_u\t*src;\n    char_u\t*dst;\n    char_u\t*s;\n    int\t\tc;\n    int\t\tcc;\n    int\t\tno = -1;\n    fptr_T\tfunc_all = (fptr_T)NULL;\n    fptr_T\tfunc_one = (fptr_T)NULL;\n    linenr_T\tclnum = 0;\t// init for GCC\n    int\t\tlen = 0;\t// init for GCC\n#ifdef FEAT_EVAL\n    static int  nesting = 0;\n    int\t\tnested;\n#endif\n    int\t\tcopy = flags & REGSUB_COPY;\n\n    // Be paranoid...\n    if ((source == NULL && expr == NULL) || dest == NULL)\n    {\n\temsg(_(e_null_argument));\n\treturn 0;\n    }\n    if (prog_magic_wrong())\n\treturn 0;\n#ifdef FEAT_EVAL\n    if (nesting == MAX_REGSUB_NESTING)\n    {\n\temsg(_(e_substitute_nesting_too_deep));\n\treturn 0;\n    }\n    nested = nesting;\n#endif\n    src = source;\n    dst = dest;\n\n    /*\n     * When the substitute part starts with \"\\=\" evaluate it as an expression.\n     */\n    if (expr != NULL || (source[0] == '\\\\' && source[1] == '='))\n    {\n#ifdef FEAT_EVAL\n\t// To make sure that the length doesn't change between checking the\n\t// length and copying the string, and to speed up things, the\n\t// resulting string is saved from the call with\n\t// \"flags & REGSUB_COPY\" == 0 to the call with\n\t// \"flags & REGSUB_COPY\" != 0.\n\tif (copy)\n\t{\n\t    if (eval_result[nested] != NULL)\n\t    {\n\t\tSTRCPY(dest, eval_result[nested]);\n\t\tdst += STRLEN(eval_result[nested]);\n\t\tVIM_CLEAR(eval_result[nested]);\n\t    }\n\t}\n\telse\n\t{\n\t    int\t\t    prev_can_f_submatch = can_f_submatch;\n\t    regsubmatch_T   rsm_save;\n\n\t    VIM_CLEAR(eval_result[nested]);\n\n\t    // The expression may contain substitute(), which calls us\n\t    // recursively.  Make sure submatch() gets the text from the first\n\t    // level.\n\t    if (can_f_submatch)\n\t\trsm_save = rsm;\n\t    can_f_submatch = TRUE;\n\t    rsm.sm_match = rex.reg_match;\n\t    rsm.sm_mmatch = rex.reg_mmatch;\n\t    rsm.sm_firstlnum = rex.reg_firstlnum;\n\t    rsm.sm_maxline = rex.reg_maxline;\n\t    rsm.sm_line_lbr = rex.reg_line_lbr;\n\n\t    // Although unlikely, it is possible that the expression invokes a\n\t    // substitute command (it might fail, but still).  Therefore keep\n\t    // an array of eval results.\n\t    ++nesting;\n\n\t    if (expr != NULL)\n\t    {\n\t\ttypval_T\targv[2];\n\t\tchar_u\t\tbuf[NUMBUFLEN];\n\t\ttypval_T\trettv;\n\t\tstaticList10_T\tmatchList;\n\t\tfuncexe_T\tfuncexe;\n\n\t\trettv.v_type = VAR_STRING;\n\t\trettv.vval.v_string = NULL;\n\t\targv[0].v_type = VAR_LIST;\n\t\targv[0].vval.v_list = &matchList.sl_list;\n\t\tmatchList.sl_list.lv_len = 0;\n\t\tCLEAR_FIELD(funcexe);\n\t\tfuncexe.fe_argv_func = fill_submatch_list;\n\t\tfuncexe.fe_evaluate = TRUE;\n\t\tif (expr->v_type == VAR_FUNC)\n\t\t{\n\t\t    s = expr->vval.v_string;\n\t\t    call_func(s, -1, &rettv, 1, argv, &funcexe);\n\t\t}\n\t\telse if (expr->v_type == VAR_PARTIAL)\n\t\t{\n\t\t    partial_T   *partial = expr->vval.v_partial;\n\n\t\t    s = partial_name(partial);\n\t\t    funcexe.fe_partial = partial;\n\t\t    call_func(s, -1, &rettv, 1, argv, &funcexe);\n\t\t}\n\t\telse if (expr->v_type == VAR_INSTR)\n\t\t{\n\t\t    exe_typval_instr(expr, &rettv);\n\t\t}\n\t\tif (matchList.sl_list.lv_len > 0)\n\t\t    // fill_submatch_list() was called\n\t\t    clear_submatch_list(&matchList);\n\n\t\tif (rettv.v_type == VAR_UNKNOWN)\n\t\t    // something failed, no need to report another error\n\t\t    eval_result[nested] = NULL;\n\t\telse\n\t\t{\n\t\t    eval_result[nested] = tv_get_string_buf_chk(&rettv, buf);\n\t\t    if (eval_result[nested] != NULL)\n\t\t\teval_result[nested] = vim_strsave(eval_result[nested]);\n\t\t}\n\t\tclear_tv(&rettv);\n\t    }\n\t    else if (substitute_instr != NULL)\n\t\t// Execute instructions from ISN_SUBSTITUTE.\n\t\teval_result[nested] = exe_substitute_instr();\n\t    else\n\t\teval_result[nested] = eval_to_string(source + 2, TRUE);\n\t    --nesting;\n\n\t    if (eval_result[nested] != NULL)\n\t    {\n\t\tint had_backslash = FALSE;\n\n\t\tfor (s = eval_result[nested]; *s != NUL; MB_PTR_ADV(s))\n\t\t{\n\t\t    // Change NL to CR, so that it becomes a line break,\n\t\t    // unless called from vim_regexec_nl().\n\t\t    // Skip over a backslashed character.\n\t\t    if (*s == NL && !rsm.sm_line_lbr)\n\t\t\t*s = CAR;\n\t\t    else if (*s == '\\\\' && s[1] != NUL)\n\t\t    {\n\t\t\t++s;\n\t\t\t/* Change NL to CR here too, so that this works:\n\t\t\t * :s/abc\\\\\\ndef/\\=\"aaa\\\\\\nbbb\"/  on text:\n\t\t\t *   abc\\\n\t\t\t *   def\n\t\t\t * Not when called from vim_regexec_nl().\n\t\t\t */\n\t\t\tif (*s == NL && !rsm.sm_line_lbr)\n\t\t\t    *s = CAR;\n\t\t\thad_backslash = TRUE;\n\t\t    }\n\t\t}\n\t\tif (had_backslash && (flags & REGSUB_BACKSLASH))\n\t\t{\n\t\t    // Backslashes will be consumed, need to double them.\n\t\t    s = vim_strsave_escaped(eval_result[nested], (char_u *)\"\\\\\");\n\t\t    if (s != NULL)\n\t\t    {\n\t\t\tvim_free(eval_result[nested]);\n\t\t\teval_result[nested] = s;\n\t\t    }\n\t\t}\n\n\t\tdst += STRLEN(eval_result[nested]);\n\t    }\n\n\t    can_f_submatch = prev_can_f_submatch;\n\t    if (can_f_submatch)\n\t\trsm = rsm_save;\n\t}\n#endif\n    }\n    else\n      while ((c = *src++) != NUL)\n      {\n\tif (c == '&' && (flags & REGSUB_MAGIC))\n\t    no = 0;\n\telse if (c == '\\\\' && *src != NUL)\n\t{\n\t    if (*src == '&' && !(flags & REGSUB_MAGIC))\n\t    {\n\t\t++src;\n\t\tno = 0;\n\t    }\n\t    else if ('0' <= *src && *src <= '9')\n\t    {\n\t\tno = *src++ - '0';\n\t    }\n\t    else if (vim_strchr((char_u *)\"uUlLeE\", *src))\n\t    {\n\t\tswitch (*src++)\n\t\t{\n\t\tcase 'u':   func_one = (fptr_T)do_upper;\n\t\t\t    continue;\n\t\tcase 'U':   func_all = (fptr_T)do_Upper;\n\t\t\t    continue;\n\t\tcase 'l':   func_one = (fptr_T)do_lower;\n\t\t\t    continue;\n\t\tcase 'L':   func_all = (fptr_T)do_Lower;\n\t\t\t    continue;\n\t\tcase 'e':\n\t\tcase 'E':   func_one = func_all = (fptr_T)NULL;\n\t\t\t    continue;\n\t\t}\n\t    }\n\t}\n\tif (no < 0)\t      // Ordinary character.\n\t{\n\t    if (c == K_SPECIAL && src[0] != NUL && src[1] != NUL)\n\t    {\n\t\t// Copy a special key as-is.\n\t\tif (copy)\n\t\t{\n\t\t    if (dst + 3 > dest + destlen)\n\t\t    {\n\t\t\tiemsg(\"vim_regsub_both(): not enough space\");\n\t\t\treturn 0;\n\t\t    }\n\t\t    *dst++ = c;\n\t\t    *dst++ = *src++;\n\t\t    *dst++ = *src++;\n\t\t}\n\t\telse\n\t\t{\n\t\t    dst += 3;\n\t\t    src += 2;\n\t\t}\n\t\tcontinue;\n\t    }\n\n\t    if (c == '\\\\' && *src != NUL)\n\t    {\n\t\t// Check for abbreviations -- webb\n\t\tswitch (*src)\n\t\t{\n\t\t    case 'r':\tc = CAR;\t++src;\tbreak;\n\t\t    case 'n':\tc = NL;\t\t++src;\tbreak;\n\t\t    case 't':\tc = TAB;\t++src;\tbreak;\n\t\t // Oh no!  \\e already has meaning in subst pat :-(\n\t\t // case 'e':   c = ESC;\t++src;\tbreak;\n\t\t    case 'b':\tc = Ctrl_H;\t++src;\tbreak;\n\n\t\t    // If \"backslash\" is TRUE the backslash will be removed\n\t\t    // later.  Used to insert a literal CR.\n\t\t    default:\tif (flags & REGSUB_BACKSLASH)\n\t\t\t\t{\n\t\t\t\t    if (copy)\n\t\t\t\t    {\n\t\t\t\t\tif (dst + 1 > dest + destlen)\n\t\t\t\t\t{\n\t\t\t\t\t    iemsg(\"vim_regsub_both(): not enough space\");\n\t\t\t\t\t    return 0;\n\t\t\t\t\t}\n\t\t\t\t\t*dst = '\\\\';\n\t\t\t\t    }\n\t\t\t\t    ++dst;\n\t\t\t\t}\n\t\t\t\tc = *src++;\n\t\t}\n\t    }\n\t    else if (has_mbyte)\n\t\tc = mb_ptr2char(src - 1);\n\n\t    // Write to buffer, if copy is set.\n\t    if (func_one != (fptr_T)NULL)\n\t\t// Turbo C complains without the typecast\n\t\tfunc_one = (fptr_T)(func_one(&cc, c));\n\t    else if (func_all != (fptr_T)NULL)\n\t\t// Turbo C complains without the typecast\n\t\tfunc_all = (fptr_T)(func_all(&cc, c));\n\t    else // just copy\n\t\tcc = c;\n\n\t    if (has_mbyte)\n\t    {\n\t\tint totlen = mb_ptr2len(src - 1);\n\t\tint charlen = mb_char2len(cc);\n\n\t\tif (copy)\n\t\t{\n\t\t    if (dst + charlen > dest + destlen)\n\t\t    {\n\t\t\tiemsg(\"vim_regsub_both(): not enough space\");\n\t\t\treturn 0;\n\t\t    }\n\t\t    mb_char2bytes(cc, dst);\n\t\t}\n\t\tdst += charlen - 1;\n\t\tif (enc_utf8)\n\t\t{\n\t\t    int clen = utf_ptr2len(src - 1);\n\n\t\t    // If the character length is shorter than \"totlen\", there\n\t\t    // are composing characters; copy them as-is.\n\t\t    if (clen < totlen)\n\t\t    {\n\t\t\tif (copy)\n\t\t\t{\n\t\t\t    if (dst + totlen - clen > dest + destlen)\n\t\t\t    {\n\t\t\t\tiemsg(\"vim_regsub_both(): not enough space\");\n\t\t\t\treturn 0;\n\t\t\t    }\n\t\t\t    mch_memmove(dst + 1, src - 1 + clen,\n\t\t\t\t\t\t     (size_t)(totlen - clen));\n\t\t\t}\n\t\t\tdst += totlen - clen;\n\t\t    }\n\t\t}\n\t\tsrc += totlen - 1;\n\t    }\n\t    else if (copy)\n\t    {\n\t\tif (dst + 1 > dest + destlen)\n\t\t{\n\t\t    iemsg(\"vim_regsub_both(): not enough space\");\n\t\t    return 0;\n\t\t}\n\t\t*dst = cc;\n\t    }\n\t    dst++;\n\t}\n\telse\n\t{\n\t    if (REG_MULTI)\n\t    {\n\t\tclnum = rex.reg_mmatch->startpos[no].lnum;\n\t\tif (clnum < 0 || rex.reg_mmatch->endpos[no].lnum < 0)\n\t\t    s = NULL;\n\t\telse\n\t\t{\n\t\t    s = reg_getline(clnum) + rex.reg_mmatch->startpos[no].col;\n\t\t    if (rex.reg_mmatch->endpos[no].lnum == clnum)\n\t\t\tlen = rex.reg_mmatch->endpos[no].col\n\t\t\t\t\t    - rex.reg_mmatch->startpos[no].col;\n\t\t    else\n\t\t\tlen = (int)STRLEN(s);\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\ts = rex.reg_match->startp[no];\n\t\tif (rex.reg_match->endp[no] == NULL)\n\t\t    s = NULL;\n\t\telse\n\t\t    len = (int)(rex.reg_match->endp[no] - s);\n\t    }\n\t    if (s != NULL)\n\t    {\n\t\tfor (;;)\n\t\t{\n\t\t    if (len == 0)\n\t\t    {\n\t\t\tif (REG_MULTI)\n\t\t\t{\n\t\t\t    if (rex.reg_mmatch->endpos[no].lnum == clnum)\n\t\t\t\tbreak;\n\t\t\t    if (copy)\n\t\t\t    {\n\t\t\t\tif (dst + 1 > dest + destlen)\n\t\t\t\t{\n\t\t\t\t    iemsg(\"vim_regsub_both(): not enough space\");\n\t\t\t\t    return 0;\n\t\t\t\t}\n\t\t\t\t*dst = CAR;\n\t\t\t    }\n\t\t\t    ++dst;\n\t\t\t    s = reg_getline(++clnum);\n\t\t\t    if (rex.reg_mmatch->endpos[no].lnum == clnum)\n\t\t\t\tlen = rex.reg_mmatch->endpos[no].col;\n\t\t\t    else\n\t\t\t\tlen = (int)STRLEN(s);\n\t\t\t}\n\t\t\telse\n\t\t\t    break;\n\t\t    }\n\t\t    else if (*s == NUL) // we hit NUL.\n\t\t    {\n\t\t\tif (copy)\n\t\t\t    iemsg(_(e_damaged_match_string));\n\t\t\tgoto exit;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tif ((flags & REGSUB_BACKSLASH)\n\t\t\t\t\t\t  && (*s == CAR || *s == '\\\\'))\n\t\t\t{\n\t\t\t    /*\n\t\t\t     * Insert a backslash in front of a CR, otherwise\n\t\t\t     * it will be replaced by a line break.\n\t\t\t     * Number of backslashes will be halved later,\n\t\t\t     * double them here.\n\t\t\t     */\n\t\t\t    if (copy)\n\t\t\t    {\n\t\t\t\tif (dst + 2 > dest + destlen)\n\t\t\t\t{\n\t\t\t\t    iemsg(\"vim_regsub_both(): not enough space\");\n\t\t\t\t    return 0;\n\t\t\t\t}\n\t\t\t\tdst[0] = '\\\\';\n\t\t\t\tdst[1] = *s;\n\t\t\t    }\n\t\t\t    dst += 2;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    if (has_mbyte)\n\t\t\t\tc = mb_ptr2char(s);\n\t\t\t    else\n\t\t\t\tc = *s;\n\n\t\t\t    if (func_one != (fptr_T)NULL)\n\t\t\t\t// Turbo C complains without the typecast\n\t\t\t\tfunc_one = (fptr_T)(func_one(&cc, c));\n\t\t\t    else if (func_all != (fptr_T)NULL)\n\t\t\t\t// Turbo C complains without the typecast\n\t\t\t\tfunc_all = (fptr_T)(func_all(&cc, c));\n\t\t\t    else // just copy\n\t\t\t\tcc = c;\n\n\t\t\t    if (has_mbyte)\n\t\t\t    {\n\t\t\t\tint l;\n\t\t\t\tint charlen;\n\n\t\t\t\t// Copy composing characters separately, one\n\t\t\t\t// at a time.\n\t\t\t\tif (enc_utf8)\n\t\t\t\t    l = utf_ptr2len(s) - 1;\n\t\t\t\telse\n\t\t\t\t    l = mb_ptr2len(s) - 1;\n\n\t\t\t\ts += l;\n\t\t\t\tlen -= l;\n\t\t\t\tcharlen = mb_char2len(cc);\n\t\t\t\tif (copy)\n\t\t\t\t{\n\t\t\t\t    if (dst + charlen > dest + destlen)\n\t\t\t\t    {\n\t\t\t\t\tiemsg(\"vim_regsub_both(): not enough space\");\n\t\t\t\t\treturn 0;\n\t\t\t\t    }\n\t\t\t\t    mb_char2bytes(cc, dst);\n\t\t\t\t}\n\t\t\t\tdst += charlen - 1;\n\t\t\t    }\n\t\t\t    else if (copy)\n\t\t\t    {\n\t\t\t\tif (dst + 1 > dest + destlen)\n\t\t\t\t{\n\t\t\t\t    iemsg(\"vim_regsub_both(): not enough space\");\n\t\t\t\t    return 0;\n\t\t\t\t}\n\t\t\t\t*dst = cc;\n\t\t\t    }\n\t\t\t    dst++;\n\t\t\t}\n\n\t\t\t++s;\n\t\t\t--len;\n\t\t    }\n\t\t}\n\t    }\n\t    no = -1;\n\t}\n      }\n    if (copy)\n\t*dst = NUL;\n\nexit:\n    return (int)((dst - dest) + 1);\n}\n\n#ifdef FEAT_EVAL\n/*\n * Call reg_getline() with the line numbers from the submatch.  If a\n * substitute() was used the reg_maxline and other values have been\n * overwritten.\n */\n    static char_u *\nreg_getline_submatch(linenr_T lnum)\n{\n    char_u *s;\n    linenr_T save_first = rex.reg_firstlnum;\n    linenr_T save_max = rex.reg_maxline;\n\n    rex.reg_firstlnum = rsm.sm_firstlnum;\n    rex.reg_maxline = rsm.sm_maxline;\n\n    s = reg_getline(lnum);\n\n    rex.reg_firstlnum = save_first;\n    rex.reg_maxline = save_max;\n    return s;\n}\n\n/*\n * Used for the submatch() function: get the string from the n'th submatch in\n * allocated memory.\n * Returns NULL when not in a \":s\" command and for a non-existing submatch.\n */\n    char_u *\nreg_submatch(int no)\n{\n    char_u\t*retval = NULL;\n    char_u\t*s;\n    int\t\tlen;\n    int\t\tround;\n    linenr_T\tlnum;\n\n    if (!can_f_submatch || no < 0)\n\treturn NULL;\n\n    if (rsm.sm_match == NULL)\n    {\n\t/*\n\t * First round: compute the length and allocate memory.\n\t * Second round: copy the text.\n\t */\n\tfor (round = 1; round <= 2; ++round)\n\t{\n\t    lnum = rsm.sm_mmatch->startpos[no].lnum;\n\t    if (lnum < 0 || rsm.sm_mmatch->endpos[no].lnum < 0)\n\t\treturn NULL;\n\n\t    s = reg_getline_submatch(lnum);\n\t    if (s == NULL)  // anti-crash check, cannot happen?\n\t\tbreak;\n\t    s += rsm.sm_mmatch->startpos[no].col;\n\t    if (rsm.sm_mmatch->endpos[no].lnum == lnum)\n\t    {\n\t\t// Within one line: take form start to end col.\n\t\tlen = rsm.sm_mmatch->endpos[no].col\n\t\t\t\t\t  - rsm.sm_mmatch->startpos[no].col;\n\t\tif (round == 2)\n\t\t    vim_strncpy(retval, s, len);\n\t\t++len;\n\t    }\n\t    else\n\t    {\n\t\t// Multiple lines: take start line from start col, middle\n\t\t// lines completely and end line up to end col.\n\t\tlen = (int)STRLEN(s);\n\t\tif (round == 2)\n\t\t{\n\t\t    STRCPY(retval, s);\n\t\t    retval[len] = '\\n';\n\t\t}\n\t\t++len;\n\t\t++lnum;\n\t\twhile (lnum < rsm.sm_mmatch->endpos[no].lnum)\n\t\t{\n\t\t    s = reg_getline_submatch(lnum++);\n\t\t    if (round == 2)\n\t\t\tSTRCPY(retval + len, s);\n\t\t    len += (int)STRLEN(s);\n\t\t    if (round == 2)\n\t\t\tretval[len] = '\\n';\n\t\t    ++len;\n\t\t}\n\t\tif (round == 2)\n\t\t    STRNCPY(retval + len, reg_getline_submatch(lnum),\n\t\t\t\t\t     rsm.sm_mmatch->endpos[no].col);\n\t\tlen += rsm.sm_mmatch->endpos[no].col;\n\t\tif (round == 2)\n\t\t    retval[len] = NUL;\n\t\t++len;\n\t    }\n\n\t    if (retval == NULL)\n\t    {\n\t\tretval = alloc(len);\n\t\tif (retval == NULL)\n\t\t    return NULL;\n\t    }\n\t}\n    }\n    else\n    {\n\ts = rsm.sm_match->startp[no];\n\tif (s == NULL || rsm.sm_match->endp[no] == NULL)\n\t    retval = NULL;\n\telse\n\t    retval = vim_strnsave(s, rsm.sm_match->endp[no] - s);\n    }\n\n    return retval;\n}\n\n/*\n * Used for the submatch() function with the optional non-zero argument: get\n * the list of strings from the n'th submatch in allocated memory with NULs\n * represented in NLs.\n * Returns a list of allocated strings.  Returns NULL when not in a \":s\"\n * command, for a non-existing submatch and for any error.\n */\n    list_T *\nreg_submatch_list(int no)\n{\n    char_u\t*s;\n    linenr_T\tslnum;\n    linenr_T\telnum;\n    colnr_T\tscol;\n    colnr_T\tecol;\n    int\t\ti;\n    list_T\t*list;\n    int\t\terror = FALSE;\n\n    if (!can_f_submatch || no < 0)\n\treturn NULL;\n\n    if (rsm.sm_match == NULL)\n    {\n\tslnum = rsm.sm_mmatch->startpos[no].lnum;\n\telnum = rsm.sm_mmatch->endpos[no].lnum;\n\tif (slnum < 0 || elnum < 0)\n\t    return NULL;\n\n\tscol = rsm.sm_mmatch->startpos[no].col;\n\tecol = rsm.sm_mmatch->endpos[no].col;\n\n\tlist = list_alloc();\n\tif (list == NULL)\n\t    return NULL;\n\n\ts = reg_getline_submatch(slnum) + scol;\n\tif (slnum == elnum)\n\t{\n\t    if (list_append_string(list, s, ecol - scol) == FAIL)\n\t\terror = TRUE;\n\t}\n\telse\n\t{\n\t    if (list_append_string(list, s, -1) == FAIL)\n\t\terror = TRUE;\n\t    for (i = 1; i < elnum - slnum; i++)\n\t    {\n\t\ts = reg_getline_submatch(slnum + i);\n\t\tif (list_append_string(list, s, -1) == FAIL)\n\t\t    error = TRUE;\n\t    }\n\t    s = reg_getline_submatch(elnum);\n\t    if (list_append_string(list, s, ecol) == FAIL)\n\t\terror = TRUE;\n\t}\n    }\n    else\n    {\n\ts = rsm.sm_match->startp[no];\n\tif (s == NULL || rsm.sm_match->endp[no] == NULL)\n\t    return NULL;\n\tlist = list_alloc();\n\tif (list == NULL)\n\t    return NULL;\n\tif (list_append_string(list, s,\n\t\t\t\t (int)(rsm.sm_match->endp[no] - s)) == FAIL)\n\t    error = TRUE;\n    }\n\n    if (error)\n    {\n\tlist_free(list);\n\treturn NULL;\n    }\n    ++list->lv_refcount;\n    return list;\n}\n#endif\n\n/*\n * Initialize the values used for matching against multiple lines\n */\n    static void\ninit_regexec_multi(\n\tregmmatch_T\t*rmp,\n\twin_T\t\t*win,\t// window in which to search or NULL\n\tbuf_T\t\t*buf,\t// buffer in which to search\n\tlinenr_T\tlnum)\t// nr of line to start looking for match\n{\n    rex.reg_match = NULL;\n    rex.reg_mmatch = rmp;\n    rex.reg_buf = buf;\n    rex.reg_win = win;\n    rex.reg_firstlnum = lnum;\n    rex.reg_maxline = rex.reg_buf->b_ml.ml_line_count - lnum;\n    rex.reg_line_lbr = FALSE;\n    rex.reg_ic = rmp->rmm_ic;\n    rex.reg_icombine = FALSE;\n    rex.reg_maxcol = rmp->rmm_maxcol;\n}\n\n#include \"regexp_bt.c\"\n\nstatic regengine_T bt_regengine =\n{\n    bt_regcomp,\n    bt_regfree,\n    bt_regexec_nl,\n    bt_regexec_multi,\n};\n\n#include \"regexp_nfa.c\"\n\nstatic regengine_T nfa_regengine =\n{\n    nfa_regcomp,\n    nfa_regfree,\n    nfa_regexec_nl,\n    nfa_regexec_multi,\n};\n\n// Which regexp engine to use? Needed for vim_regcomp().\n// Must match with 'regexpengine'.\nstatic int regexp_engine = 0;\n\n#ifdef DEBUG\nstatic char_u regname[][30] = {\n\t\t    \"AUTOMATIC Regexp Engine\",\n\t\t    \"BACKTRACKING Regexp Engine\",\n\t\t    \"NFA Regexp Engine\"\n\t\t\t    };\n#endif\n\n/*\n * Compile a regular expression into internal code.\n * Returns the program in allocated memory.\n * Use vim_regfree() to free the memory.\n * Returns NULL for an error.\n */\n    regprog_T *\nvim_regcomp(char_u *expr_arg, int re_flags)\n{\n    regprog_T   *prog = NULL;\n    char_u\t*expr = expr_arg;\n    int\t\tcalled_emsg_before;\n\n    regexp_engine = p_re;\n\n    // Check for prefix \"\\%#=\", that sets the regexp engine\n    if (STRNCMP(expr, \"\\\\%#=\", 4) == 0)\n    {\n\tint newengine = expr[4] - '0';\n\n\tif (newengine == AUTOMATIC_ENGINE\n\t    || newengine == BACKTRACKING_ENGINE\n\t    || newengine == NFA_ENGINE)\n\t{\n\t    regexp_engine = expr[4] - '0';\n\t    expr += 5;\n#ifdef DEBUG\n\t    smsg(\"New regexp mode selected (%d): %s\",\n\t\t\t\t\t   regexp_engine, regname[newengine]);\n#endif\n\t}\n\telse\n\t{\n\t    emsg(_(e_percent_hash_can_only_be_followed_by_zero_one_two_automatic_engine_will_be_used));\n\t    regexp_engine = AUTOMATIC_ENGINE;\n\t}\n    }\n#ifdef DEBUG\n    bt_regengine.expr = expr;\n    nfa_regengine.expr = expr;\n#endif\n    // reg_iswordc() uses rex.reg_buf\n    rex.reg_buf = curbuf;\n\n    /*\n     * First try the NFA engine, unless backtracking was requested.\n     */\n    called_emsg_before = called_emsg;\n    if (regexp_engine != BACKTRACKING_ENGINE)\n\tprog = nfa_regengine.regcomp(expr,\n\t\tre_flags + (regexp_engine == AUTOMATIC_ENGINE ? RE_AUTO : 0));\n    else\n\tprog = bt_regengine.regcomp(expr, re_flags);\n\n    // Check for error compiling regexp with initial engine.\n    if (prog == NULL)\n    {\n#ifdef BT_REGEXP_DEBUG_LOG\n\tif (regexp_engine == BACKTRACKING_ENGINE)   // debugging log for BT engine\n\t{\n\t    FILE *f;\n\t    f = fopen(BT_REGEXP_DEBUG_LOG_NAME, \"a\");\n\t    if (f)\n\t    {\n\t\tfprintf(f, \"Syntax error in \\\"%s\\\"\\n\", expr);\n\t\tfclose(f);\n\t    }\n\t    else\n\t\tsemsg(\"(NFA) Could not open \\\"%s\\\" to write !!!\",\n\t\t\tBT_REGEXP_DEBUG_LOG_NAME);\n\t}\n#endif\n\t/*\n\t * If the NFA engine failed, try the backtracking engine.\n\t * The NFA engine also fails for patterns that it can't handle well\n\t * but are still valid patterns, thus a retry should work.\n\t * But don't try if an error message was given.\n\t */\n\tif (regexp_engine == AUTOMATIC_ENGINE\n\t\t\t\t\t  && called_emsg == called_emsg_before)\n\t{\n\t    regexp_engine = BACKTRACKING_ENGINE;\n#ifdef FEAT_EVAL\n\t    report_re_switch(expr);\n#endif\n\t    prog = bt_regengine.regcomp(expr, re_flags);\n\t}\n    }\n\n    if (prog != NULL)\n    {\n\t// Store the info needed to call regcomp() again when the engine turns\n\t// out to be very slow when executing it.\n\tprog->re_engine = regexp_engine;\n\tprog->re_flags  = re_flags;\n    }\n\n    return prog;\n}\n\n/*\n * Free a compiled regexp program, returned by vim_regcomp().\n */\n    void\nvim_regfree(regprog_T *prog)\n{\n    if (prog != NULL)\n\tprog->engine->regfree(prog);\n}\n\n#if defined(EXITFREE) || defined(PROTO)\n    void\nfree_regexp_stuff(void)\n{\n    ga_clear(&regstack);\n    ga_clear(&backpos);\n    vim_free(reg_tofree);\n    vim_free(reg_prev_sub);\n}\n#endif\n\n#ifdef FEAT_EVAL\n    static void\nreport_re_switch(char_u *pat)\n{\n    if (p_verbose > 0)\n    {\n\tverbose_enter();\n\tmsg_puts(_(\"Switching to backtracking RE engine for pattern: \"));\n\tmsg_puts((char *)pat);\n\tverbose_leave();\n    }\n}\n#endif\n\n#if defined(FEAT_X11) || defined(PROTO)\n/*\n * Return whether \"prog\" is currently being executed.\n */\n    int\nregprog_in_use(regprog_T *prog)\n{\n    return prog->re_in_use;\n}\n#endif\n\n/*\n * Match a regexp against a string.\n * \"rmp->regprog\" must be a compiled regexp as returned by vim_regcomp().\n * Note: \"rmp->regprog\" may be freed and changed.\n * Uses curbuf for line count and 'iskeyword'.\n * When \"nl\" is TRUE consider a \"\\n\" in \"line\" to be a line break.\n *\n * Return TRUE if there is a match, FALSE if not.\n */\n    static int\nvim_regexec_string(\n    regmatch_T\t*rmp,\n    char_u\t*line,  // string to match against\n    colnr_T\tcol,    // column to start looking for match\n    int\t\tnl)\n{\n    int\t\tresult;\n    regexec_T\trex_save;\n    int\t\trex_in_use_save = rex_in_use;\n\n    // Cannot use the same prog recursively, it contains state.\n    if (rmp->regprog->re_in_use)\n    {\n\temsg(_(e_cannot_use_pattern_recursively));\n\treturn FALSE;\n    }\n    rmp->regprog->re_in_use = TRUE;\n\n    if (rex_in_use)\n\t// Being called recursively, save the state.\n\trex_save = rex;\n    rex_in_use = TRUE;\n\n    rex.reg_startp = NULL;\n    rex.reg_endp = NULL;\n    rex.reg_startpos = NULL;\n    rex.reg_endpos = NULL;\n\n    result = rmp->regprog->engine->regexec_nl(rmp, line, col, nl);\n    rmp->regprog->re_in_use = FALSE;\n\n    // NFA engine aborted because it's very slow.\n    if (rmp->regprog->re_engine == AUTOMATIC_ENGINE\n\t\t\t\t\t       && result == NFA_TOO_EXPENSIVE)\n    {\n\tint    save_p_re = p_re;\n\tint    re_flags = rmp->regprog->re_flags;\n\tchar_u *pat = vim_strsave(((nfa_regprog_T *)rmp->regprog)->pattern);\n\n\tp_re = BACKTRACKING_ENGINE;\n\tvim_regfree(rmp->regprog);\n\tif (pat != NULL)\n\t{\n#ifdef FEAT_EVAL\n\t    report_re_switch(pat);\n#endif\n\t    rmp->regprog = vim_regcomp(pat, re_flags);\n\t    if (rmp->regprog != NULL)\n\t    {\n\t\trmp->regprog->re_in_use = TRUE;\n\t\tresult = rmp->regprog->engine->regexec_nl(rmp, line, col, nl);\n\t\trmp->regprog->re_in_use = FALSE;\n\t    }\n\t    vim_free(pat);\n\t}\n\n\tp_re = save_p_re;\n    }\n\n    rex_in_use = rex_in_use_save;\n    if (rex_in_use)\n\trex = rex_save;\n\n    return result > 0;\n}\n\n/*\n * Note: \"*prog\" may be freed and changed.\n * Return TRUE if there is a match, FALSE if not.\n */\n    int\nvim_regexec_prog(\n    regprog_T\t**prog,\n    int\t\tignore_case,\n    char_u\t*line,\n    colnr_T\tcol)\n{\n    int\t\tr;\n    regmatch_T\tregmatch;\n\n    regmatch.regprog = *prog;\n    regmatch.rm_ic = ignore_case;\n    r = vim_regexec_string(&regmatch, line, col, FALSE);\n    *prog = regmatch.regprog;\n    return r;\n}\n\n/*\n * Note: \"rmp->regprog\" may be freed and changed.\n * Return TRUE if there is a match, FALSE if not.\n */\n    int\nvim_regexec(regmatch_T *rmp, char_u *line, colnr_T col)\n{\n    return vim_regexec_string(rmp, line, col, FALSE);\n}\n\n/*\n * Like vim_regexec(), but consider a \"\\n\" in \"line\" to be a line break.\n * Note: \"rmp->regprog\" may be freed and changed.\n * Return TRUE if there is a match, FALSE if not.\n */\n    int\nvim_regexec_nl(regmatch_T *rmp, char_u *line, colnr_T col)\n{\n    return vim_regexec_string(rmp, line, col, TRUE);\n}\n\n/*\n * Match a regexp against multiple lines.\n * \"rmp->regprog\" must be a compiled regexp as returned by vim_regcomp().\n * Note: \"rmp->regprog\" may be freed and changed, even set to NULL.\n * Uses curbuf for line count and 'iskeyword'.\n *\n * Return zero if there is no match.  Return number of lines contained in the\n * match otherwise.\n */\n    long\nvim_regexec_multi(\n    regmmatch_T *rmp,\n    win_T       *win,\t\t// window in which to search or NULL\n    buf_T       *buf,\t\t// buffer in which to search\n    linenr_T\tlnum,\t\t// nr of line to start looking for match\n    colnr_T\tcol,\t\t// column to start looking for match\n    int\t\t*timed_out)\t// flag is set when timeout limit reached\n{\n    int\t\tresult;\n    regexec_T\trex_save;\n    int\t\trex_in_use_save = rex_in_use;\n\n    // Cannot use the same prog recursively, it contains state.\n    if (rmp->regprog->re_in_use)\n    {\n\temsg(_(e_cannot_use_pattern_recursively));\n\treturn FALSE;\n    }\n    rmp->regprog->re_in_use = TRUE;\n\n    if (rex_in_use)\n\t// Being called recursively, save the state.\n\trex_save = rex;\n    rex_in_use = TRUE;\n\n    result = rmp->regprog->engine->regexec_multi(\n\t\t\t\t      rmp, win, buf, lnum, col, timed_out);\n    rmp->regprog->re_in_use = FALSE;\n\n    // NFA engine aborted because it's very slow.\n    if (rmp->regprog->re_engine == AUTOMATIC_ENGINE\n\t\t\t\t\t       && result == NFA_TOO_EXPENSIVE)\n    {\n\tint    save_p_re = p_re;\n\tint    re_flags = rmp->regprog->re_flags;\n\tchar_u *pat = vim_strsave(((nfa_regprog_T *)rmp->regprog)->pattern);\n\n\tp_re = BACKTRACKING_ENGINE;\n\tif (pat != NULL)\n\t{\n\t    regprog_T *prev_prog = rmp->regprog;\n\n#ifdef FEAT_EVAL\n\t    report_re_switch(pat);\n#endif\n#ifdef FEAT_SYN_HL\n\t    // checking for \\z misuse was already done when compiling for NFA,\n\t    // allow all here\n\t    reg_do_extmatch = REX_ALL;\n#endif\n\t    rmp->regprog = vim_regcomp(pat, re_flags);\n#ifdef FEAT_SYN_HL\n\t    reg_do_extmatch = 0;\n#endif\n\t    if (rmp->regprog == NULL)\n\t    {\n\t\t// Somehow compiling the pattern failed now, put back the\n\t\t// previous one to avoid \"regprog\" becoming NULL.\n\t\trmp->regprog = prev_prog;\n\t    }\n\t    else\n\t    {\n\t\tvim_regfree(prev_prog);\n\n\t\trmp->regprog->re_in_use = TRUE;\n\t\tresult = rmp->regprog->engine->regexec_multi(\n\t\t\t\t      rmp, win, buf, lnum, col, timed_out);\n\t\trmp->regprog->re_in_use = FALSE;\n\t    }\n\t    vim_free(pat);\n\t}\n\tp_re = save_p_re;\n    }\n\n    rex_in_use = rex_in_use_save;\n    if (rex_in_use)\n\trex = rex_save;\n\n    return result <= 0 ? 0 : result;\n}\n", "\" Tests for regexp in utf8 encoding\n\nfunc s:equivalence_test()\n  let str = \"A\u0413\u0496\u0413\u0492\u0413\u04ee\u0413\u0493\u0413\u201e\u0413\u2026\u0414\u0496\u0414\u04ee\u0414\u201e\u0417\u049a\u0417\u04bb\u0417\u00a0\u0417\u04d9\u0418\u04ee\u0418\u04b0\u0418\u04d9\u0431\u0451\u0496\u0431\u04d9\u00a0\u0431\u04d9\u045e\u0431\u04d9\u04e8\u0431\u04d9\u04b0\u0431\u04d9\u0401\u0431\u04d9\u04d8\u0431\u04d9\u00ac\u0431\u04d9\u00ae\u0431\u04d9\u00b0\u0431\u04d9\u0406\u0431\u04d9\u0499\u0431\u04d9\u00b6 B\u0416\u0492\u0419\u0493\u0431\u0451\u04ee\u0431\u0451\u201e\u0431\u0451\u04b6 C\u0413\u04ae\u0414\u04b6\u0414\u04b2\u0414\u04a0\u0414\u04a2\u0416\u04ae\u0418\u00bb\u0431\u0451\u04b2\u043a\u04bb\u2019 D\u0414\u04ba\u0414\u0497\u0416\u04a0\u0431\u0451\u04a0\u0431\u0451\u04a2\u0431\u0451\u04ba\u0431\u0451\u0497\u0431\u0451\u2019 E\u0413\u04b2\u0413\u04af\u0413\u04a0\u0413\u04e2\u0414\u2019\u0414\u201d\u0414\u2013\u0414\u04b3\u0414\u04a1\u0418\u201e\u0418\u04b6\u0418\u0401\u0419\u04b6\u0431\u0451\u201d\u0431\u0451\u2013\u0431\u0451\u04b3\u0431\u0451\u04a1\u0431\u0451\u04a3\u0431\u04d9\u0451\u0431\u04d9\u04d9\u0431\u04d9\u0458\u0431\u04d9\u04ab\u0431\u00bb\u0496\u0431\u00bb\u04ee\u0431\u00bb\u201e\u0431\u00bb\u04b6 F\u0416\u2018\u0431\u0451\u04bb\u043a\u04bb\u04b3 G\u0414\u04a3\u0414\u04bb\u0414\u00a0\u0414\u045e\u0416\u201c\u0417\u04e8\u0417\u04b0\u0417\u0499\u0431\u0451\u00a0\u043a\u04bb\u00a0 H\u0414\u04e8\u0414\u04b0\u0418\u04bb\u0431\u0451\u045e\u0431\u0451\u04e8\u0431\u0451\u04b0\u0431\u0451\u0401\u0431\u0451\u04d8\u0432\u04b1\u00a7 I\u0413\u04a2\u0413\u049a\u0413\u04ba\u0413\u04b8\u0414\u0401\u0414\u04d8\u0414\u00ac\u0414\u00ae\u0414\u00b0\u0416\u2014\u0417\u04b8\u0418\u04b2\u0418\u04a0\u0431\u0451\u00ac\u0431\u0451\u00ae\u0431\u00bb\u04b2\u0431\u00bb\u04a0 J\u0414\u0499\u0419\u04b2 K\u0414\u00b6\u0416\u04b3\u0417\u0401\u0431\u0451\u00b0\u0431\u0451\u0406\u0431\u0451\u0499\u0432\u04b1\u00a9\u043a\u049b\u0496 L\u0414\u2116\u0414\u00bb\u0414\u04aa\u0414\u049d\u0415\u0492\u0418\u04aa\u0431\u0451\u00b6\u0431\u0451\u0451\u0431\u0451\u04d9\u0431\u0451\u0458\u0432\u04b1\u00a0 M\u0431\u0451\u04ab\u0431\u2116\u0496\u0431\u2116\u04ee N\u0413\u2018\u0415\u0493\u0415\u2026\u0415\u04ae\u0417\u0451\u0431\u2116\u201e\u0431\u2116\u04b6\u0431\u2116\u04b2\u0431\u2116\u04a0\u043a\u04bb\u04e8 O\u0413\u2019\u0413\u201c\u0413\u201d\u0413\u2022\u0413\u2013\u0413\u04b3\u0415\u04a2\u0415\u04ba\u0415\u0497\u0416\u04b9\u0416\u00a0\u0417\u2018\u0417\u04d8\u0417\u00ac\u0417\u04ab\u0418\u04a2\u0418\u04ba\u0418\u04d8\u0418\u00ac\u0418\u00ae\u0418\u00b0\u0431\u2116\u04a2\u0431\u2116\u04ba\u0431\u2116\u0497\u0431\u2116\u2019\u0431\u00bb\u04a2\u0431\u00bb\u04ba\u0431\u00bb\u0497\u0431\u00bb\u2019\u0431\u00bb\u201d\u0431\u00bb\u2013\u0431\u00bb\u04b3\u0431\u00bb\u04a1\u0431\u00bb\u04a3\u0431\u00bb\u04bb\u0431\u00bb\u00a0\u0431\u00bb\u045e P\u0416\u04e8\u0431\u2116\u201d\u0431\u2116\u2013\u0432\u04b1\u0408 Q\u0419\u04a0 R\u0415\u201d\u0415\u2013\u0415\u04b3\u0418\u0497\u0418\u2019\u0419\u04a2\u0431\u2116\u04b3\u0431\u2116\u04a1\u0431\u2116\u04a3\u0431\u2116\u04bb\u0432\u04b1\u04e8\u043a\u04bb\u04b0 S\u0415\u04a1\u0415\u04a3\u0415\u04bb\u0415\u00a0\u0418\u04b3\u0431\u2116\u00a0\u0431\u2116\u045e\u0431\u2116\u04e8\u0431\u2116\u04b0\u0431\u2116\u0401\u0432\u04b1\u04ab\u043a\u04bb\u0401 T\u0415\u045e\u0415\u04e8\u0415\u04b0\u0416\u00ac\u0416\u00ae\u0418\u04a1\u0418\u04ab\u0431\u2116\u04d8\u0431\u2116\u00ac\u0431\u2116\u00ae\u0431\u2116\u00b0 U\u0413\u04b7\u0413\u04a1\u0413\u04e3\u0413\u04a3\u0415\u0401\u0415\u04d8\u0415\u00ac\u0415\u00ae\u0415\u00b0\u0416\u049c\u0417\u2022\u0417\u04b7\u0417\u04e3\u0417\u201c\u0417\u2014\u0418\u201d\u0418\u2013\u0419\u201e\u0431\u2116\u0406\u0431\u2116\u0499\u0431\u2116\u00b6\u0431\u2116\u0451\u0431\u2116\u04d9\u0431\u00bb\u04e8\u0431\u00bb\u04b0\u0431\u00bb\u0401\u0431\u00bb\u04d8\u0431\u00bb\u00ac\u0431\u00bb\u00ae\u0431\u00bb\u00b0  V\u0416\u0406\u0431\u2116\u0458\u0431\u2116\u04ab W\u0415\u0499\u0431\u04d9\u0496\u0431\u04d9\u04ee\u0431\u04d9\u201e\u0431\u04d9\u04b6\u0431\u04d9\u04b2 X\u0431\u04d9\u04a0\u0431\u04d9\u04a2 Y\u0413\u049b\u0415\u00b6\u0415\u0451\u0416\u0456\u0418\u0406\u0419\u04ba\u0431\u04d9\u04ba\u0431\u00bb\u0406\u0431\u00bb\u0499\u0431\u00bb\u00b6\u0431\u00bb\u0451 Z\u0415\u2116\u0415\u00bb\u0415\u04aa\u0416\u04e9\u0431\u04d9\u0497\u0431\u04d9\u2019\u0431\u04d9\u201d\u0432\u04b1\u00ab a\u0413\u00a0\u0413\u040e\u0413\u045e\u0413\u0408\u0413\u04e8\u0413\u0498\u0414\u0492\u0414\u0493\u0414\u2026\u0417\u04ba\u0417\u04b9\u0417\u040e\u0417\u00bb\u0418\u0493\u0418\u00a7\u0431\u00b6\u04b8\u0431\u0451\u0492\u0431\u04d9\u04a1\u0431\u04d9\u040e\u0431\u04d9\u0408\u0431\u04d9\u0498\u0431\u04d9\u00a7\u0431\u04d9\u00a9\u0431\u04d9\u00ab\u0431\u04d9\u04ef\u0431\u04d9\u049c\u0431\u04d9\u04b1\u0431\u04d9\u0456\u0431\u04d9\u04e9\u0431\u04d9\u00b7\u0432\u04b1\u0498 b\u0416\u0496\u0419\u201c\u0431\u04e9\u00ac\u0431\u00b6\u0496\u0431\u0451\u0493\u0431\u0451\u2026\u0431\u0451\u04ae c\u0413\u00a7\u0414\u04ae\u0414\u04af\u0414\u04e2\u0414\u049a\u0416\u04b2\u0418\u0458\u0431\u0451\u04af\u043a\u04bb\u201c\u043a\u04bb\u201d d\u0414\u04b8\u0414\u2018\u0419\u2014\u0431\u04e9\u04ef\u0431\u00b6\u0492\u0431\u00b6\u2018\u0431\u0451\u04e2\u0431\u0451\u049a\u0431\u0451\u04b8\u0431\u0451\u2018\u0431\u0451\u201c e\u0413\u0401\u0413\u00a9\u0413\u04d8\u0413\u00ab\u0414\u201c\u0414\u2022\u0414\u2014\u0414\u04b7\u0414\u04e3\u0418\u2026\u0418\u04ae\u0418\u00a9\u0419\u04ae\u0431\u00b6\u2019\u0431\u0451\u2022\u0431\u0451\u2014\u0431\u0451\u04b7\u0431\u0451\u04e3\u0431\u0451\u049b\u0431\u04d9\u2116\u0431\u04d9\u00bb\u0431\u04d9\u04aa\u0431\u04d9\u049d\u0431\u00bb\u0492\u0431\u00bb\u0493\u0431\u00bb\u2026\u0431\u00bb\u04ae f\u0416\u2019\u0431\u04e9\u00ae\u0431\u00b6\u04ee\u0431\u0451\u04b9\u043a\u04bb\u04b7 g\u0414\u049b\u0414\u04b9\u0414\u040e\u0414\u0408\u0417\u0498\u0417\u00a7\u0417\u04e9\u0419\u00a0\u0431\u00b6\u0493\u0431\u0451\u040e\u043a\u04bb\u040e h\u0414\u0498\u0414\u00a7\u0418\u04b9\u0431\u0451\u0408\u0431\u0451\u0498\u0431\u0451\u00a7\u0431\u0451\u00a9\u0431\u0451\u00ab\u0431\u04d9\u2013\u0432\u04b1\u0401\u043a\u04bb\u2022 i\u0413\u00ac\u0413\u04ef\u0413\u00ae\u0413\u049c\u0414\u00a9\u0414\u00ab\u0414\u04ef\u0414\u049c\u0417\u0497\u0418\u04af\u0418\u04e2\u0419\u0401\u0431\u00b6\u2013\u0431\u0451\u04ef\u0431\u0451\u049c\u0431\u00bb\u04af\u0431\u00bb\u04e2 j\u0414\u04e9\u0417\u00b0\u0419\u04af k\u0414\u00b7\u0416\u04b7\u0417\u00a9\u0431\u00b6\u201e\u0431\u0451\u04b1\u0431\u0451\u0456\u0431\u0451\u04e9\u0432\u04b1\u04d8\u043a\u049b\u0492 l\u0414\u04d9\u0414\u0458\u0414\u04ab\u0415\u0496\u0415\u04ee\u0416\u04a1\u0431\u0451\u00b7\u0431\u0451\u2116\u0431\u0451\u00bb\u0431\u0451\u04aa\u0432\u04b1\u040e m\u0431\u04e9\u049c\u0431\u0451\u049d\u0431\u2116\u0492\u0431\u2116\u0493 n\u0413\u04b1\u0415\u201e\u0415\u04b6\u0415\u04b2\u0415\u04af\u0417\u2116\u0431\u04e9\u00b0\u0431\u00b6\u04ae\u0431\u2116\u2026\u0431\u2116\u04ae\u0431\u2116\u04af\u0431\u2116\u04e2\u043a\u04bb\u0498 o\u0413\u0406\u0413\u0456\u0413\u0499\u0413\u04e9\u0413\u00b6\u0413\u0451\u0415\u049a\u0415\u04b8\u0415\u2018\u0416\u040e\u0417\u2019\u0417\u00ab\u0417\u04ef\u0417\u049d\u0418\u049a\u0418\u04b8\u0418\u00ab\u0418\u04ef\u0418\u049c\u0418\u04b1\u0419\u04e9\u0431\u2116\u049a\u0431\u2116\u04b8\u0431\u2116\u2018\u0431\u2116\u201c\u0431\u00bb\u049a\u0431\u00bb\u04b8\u0431\u00bb\u2018\u0431\u00bb\u201c\u0431\u00bb\u2022\u0431\u00bb\u2014\u0431\u00bb\u04b7\u0431\u00bb\u04e3\u0431\u00bb\u049b\u0431\u00bb\u04b9\u0431\u00bb\u040e\u0431\u00bb\u0408 p\u0416\u0498\u0431\u04e9\u04b1\u0431\u04e9\u04aa\u0431\u00b6\u04b2\u0431\u2116\u2022\u0431\u2116\u2014 q\u0419\u04e2\u041a\u00a0 r\u0415\u2022\u0415\u2014\u0415\u04b7\u0418\u2018\u0418\u201c\u0419\u049a\u0419\u04aa\u0431\u04e9\u0406\u0431\u04e9\u0456\u0431\u00b6\u04af\u0431\u2116\u04e3\u0431\u2116\u049b\u0431\u2116\u04b9\u043a\u04bb\u00a7 s\u0415\u04e3\u0415\u049b\u0415\u04b9\u0415\u040e\u0418\u04b7\u0418\u049d\u0431\u04e9\u0499\u0431\u00b6\u04a0\u0431\u2116\u040e\u0431\u2116\u0408\u0431\u2116\u0498\u0431\u2116\u00a7\u0431\u2116\u00a9\u043a\u04bb\u00a9 t\u0415\u0408\u0415\u0498\u0415\u00a7\u0416\u00ab\u0416\u04ef\u0418\u04e3\u041a\u04b2\u0431\u04e9\u04e9\u0431\u2116\u00ab\u0431\u2116\u04ef\u0431\u2116\u049c\u0431\u2116\u04b1\u0431\u04d9\u2014\u0432\u04b1\u04b0 u\u0413\u2116\u0413\u04d9\u0413\u00bb\u0413\u0458\u0415\u00a9\u0415\u00ab\u0415\u04ef\u0415\u049c\u0415\u04b1\u0415\u0456\u0417\u04a1\u0417\u2013\u0416\u00b0\u0417\u201d\u0417\u04b3\u0417\u04a3\u0418\u2022\u0418\u2014\u041a\u04af\u0431\u04e9\u04ab\u0431\u00b6\u04b7\u0431\u2116\u0456\u0431\u2116\u04e9\u0431\u2116\u00b7\u0431\u2116\u2116\u0431\u2116\u00bb\u0431\u00bb\u0498\u0431\u00bb\u00a7\u0431\u00bb\u00a9\u0431\u00bb\u00ab\u0431\u00bb\u04ef\u0431\u00bb\u049c\u0431\u00bb\u04b1 v\u041a\u04e2\u0431\u00b6\u04a2\u0431\u2116\u04aa\u0431\u2116\u049d w\u0415\u04e9\u0431\u04d9\u0492\u0431\u04d9\u0493\u0431\u04d9\u2026\u0431\u04d9\u04ae\u0431\u04d9\u04af\u0431\u04d9\u04b3 x\u0431\u04d9\u04e2\u0431\u04d9\u049a y\u0413\u04aa\u0413\u049d\u0415\u00b7\u0416\u0499\u0418\u0456\u0419\u04b8\u0431\u04d9\u04b8\u0431\u04d9\u04b7\u0431\u00bb\u0456\u0431\u00bb\u04e9\u0431\u00bb\u00b7\u0431\u00bb\u2116 z\u0415\u04d9\u0415\u0458\u0415\u04ab\u0416\u00b6\u0431\u04e9\u00b6\u0431\u00b6\u04ba\u0431\u04d9\u2018\u0431\u04d9\u201c\u0431\u04d9\u2022\u0432\u04b1\u00ac\"\n  let groups = split(str)\n  for group1 in groups\n      for c in split(group1, '\\zs')\n\t\" next statement confirms that equivalence class matches every\n\t\" character in group\n        call assert_match('^[[=' .. c .. '=]]*$', group1)\n        for group2 in groups\n          if group2 != group1\n\t    \" next statement converts that equivalence class doesn't match\n\t    \" character in any other group\n            call assert_equal(-1, match(group2, '[[=' .. c .. '=]]'), c)\n          endif\n        endfor\n      endfor\n  endfor\nendfunc\n\nfunc Test_equivalence_re1()\n  set re=1\n  call s:equivalence_test()\n  set re=0\nendfunc\n\nfunc Test_equivalence_re2()\n  set re=2\n  call s:equivalence_test()\n  set re=0\nendfunc\n\nfunc s:classes_test()\n  if has('win32')\n    set iskeyword=@,48-57,_,192-255\n  endif\n  set isprint=@,161-255\n  call assert_equal('Mot\u0413\u00b6rhead', matchstr('Mot\u0413\u00b6rhead', '[[:print:]]\\+'))\n\n  let alnumchars = ''\n  let alphachars = ''\n  let backspacechar = ''\n  let blankchars = ''\n  let cntrlchars = ''\n  let digitchars = ''\n  let escapechar = ''\n  let graphchars = ''\n  let lowerchars = ''\n  let printchars = ''\n  let punctchars = ''\n  let returnchar = ''\n  let spacechars = ''\n  let tabchar = ''\n  let upperchars = ''\n  let xdigitchars = ''\n  let identchars = ''\n  let identchars1 = ''\n  let kwordchars = ''\n  let kwordchars1 = ''\n  let fnamechars = ''\n  let fnamechars1 = ''\n  let i = 1\n  while i <= 255\n    let c = nr2char(i)\n    if c =~ '[[:alpha:]]'\n      let alphachars .= c\n    endif\n    if c =~ '[[:alnum:]]'\n      let alnumchars .= c\n    endif\n    if c =~ '[[:backspace:]]'\n      let backspacechar .= c\n    endif\n    if c =~ '[[:blank:]]'\n      let blankchars .= c\n    endif\n    if c =~ '[[:cntrl:]]'\n      let cntrlchars .= c\n    endif\n    if c =~ '[[:digit:]]'\n      let digitchars .= c\n    endif\n    if c =~ '[[:escape:]]'\n      let escapechar .= c\n    endif\n    if c =~ '[[:graph:]]'\n      let graphchars .= c\n    endif\n    if c =~ '[[:lower:]]'\n      let lowerchars .= c\n    endif\n    if c =~ '[[:print:]]'\n      let printchars .= c\n    endif\n    if c =~ '[[:punct:]]'\n      let punctchars .= c\n    endif\n    if c =~ '[[:return:]]'\n      let returnchar .= c\n    endif\n    if c =~ '[[:space:]]'\n      let spacechars .= c\n    endif\n    if c =~ '[[:tab:]]'\n      let tabchar .= c\n    endif\n    if c =~ '[[:upper:]]'\n      let upperchars .= c\n    endif\n    if c =~ '[[:xdigit:]]'\n      let xdigitchars .= c\n    endif\n    if c =~ '[[:ident:]]'\n      let identchars .= c\n    endif\n    if c =~ '\\i'\n      let identchars1 .= c\n    endif\n    if c =~ '[[:keyword:]]'\n      let kwordchars .= c\n    endif\n    if c =~ '\\k'\n      let kwordchars1 .= c\n    endif\n    if c =~ '[[:fname:]]'\n      let fnamechars .= c\n    endif\n    if c =~ '\\f'\n      let fnamechars1 .= c\n    endif\n    let i += 1\n  endwhile\n\n  call assert_equal('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz', alphachars)\n  call assert_equal('0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz', alnumchars)\n  call assert_equal(\"\\b\", backspacechar)\n  call assert_equal(\"\\t \", blankchars)\n  call assert_equal(\"\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\b\\t\\n\\x0b\\f\\r\\x0e\\x0f\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\\x18\\x19\\x1a\\e\\x1c\\x1d\\x1e\\x1f\\x7f\", cntrlchars)\n  call assert_equal(\"0123456789\", digitchars)\n  call assert_equal(\"\\<Esc>\", escapechar)\n  call assert_equal('!\"#$%&''()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~', graphchars)\n  call assert_equal('abcdefghijklmnopqrstuvwxyz\u0412\u04e9\u0413\u04b9\u0413\u00a0\u0413\u040e\u0413\u045e\u0413\u0408\u0413\u04e8\u0413\u0498\u0413\u04b0\u0413\u00a7\u0413\u0401\u0413\u00a9\u0413\u04d8\u0413\u00ab\u0413\u00ac\u0413\u04ef\u0413\u00ae\u0413\u049c\u0413\u00b0\u0413\u04b1\u0413\u0406\u0413\u0456\u0413\u0499\u0413\u04e9\u0413\u00b6\u0413\u0451\u0413\u2116\u0413\u04d9\u0413\u00bb\u0413\u0458\u0413\u04aa\u0413\u04ab\u0413\u049d', lowerchars)\n  call assert_equal(' !\"#$%&''()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\u0412\u00a0\u0412\u040e\u0412\u045e\u0412\u0408\u0412\u04e8\u0412\u0498\u0412\u04b0\u0412\u00a7\u0412\u0401\u0412\u00a9\u0412\u04d8\u0412\u00ab\u0412\u00ac\u0412\u04ef\u0412\u00ae\u0412\u049c\u0412\u00b0\u0412\u04b1\u0412\u0406\u0412\u0456\u0412\u0499\u0412\u04e9\u0412\u00b6\u0412\u00b7\u0412\u0451\u0412\u2116\u0412\u04d9\u0412\u00bb\u0412\u0458\u0412\u04aa\u0412\u04ab\u0412\u049d\u0413\u0496\u0413\u0492\u0413\u04ee\u0413\u0493\u0413\u201e\u0413\u2026\u0413\u04b6\u0413\u04ae\u0413\u04b2\u0413\u04af\u0413\u04a0\u0413\u04e2\u0413\u04a2\u0413\u049a\u0413\u04ba\u0413\u04b8\u0413\u0497\u0413\u2018\u0413\u2019\u0413\u201c\u0413\u201d\u0413\u2022\u0413\u2013\u0413\u2014\u0413\u04b3\u0413\u04b7\u0413\u04a1\u0413\u04e3\u0413\u04a3\u0413\u049b\u0413\u04bb\u0413\u04b9\u0413\u00a0\u0413\u040e\u0413\u045e\u0413\u0408\u0413\u04e8\u0413\u0498\u0413\u04b0\u0413\u00a7\u0413\u0401\u0413\u00a9\u0413\u04d8\u0413\u00ab\u0413\u00ac\u0413\u04ef\u0413\u00ae\u0413\u049c\u0413\u00b0\u0413\u04b1\u0413\u0406\u0413\u0456\u0413\u0499\u0413\u04e9\u0413\u00b6\u0413\u00b7\u0413\u0451\u0413\u2116\u0413\u04d9\u0413\u00bb\u0413\u0458\u0413\u04aa\u0413\u04ab\u0413\u049d', printchars)\n  call assert_equal('!\"#$%&''()*+,-./:;<=>?@[\\]^_`{|}~', punctchars)\n  call assert_equal('ABCDEFGHIJKLMNOPQRSTUVWXYZ\u0413\u0496\u0413\u0492\u0413\u04ee\u0413\u0493\u0413\u201e\u0413\u2026\u0413\u04b6\u0413\u04ae\u0413\u04b2\u0413\u04af\u0413\u04a0\u0413\u04e2\u0413\u04a2\u0413\u049a\u0413\u04ba\u0413\u04b8\u0413\u0497\u0413\u2018\u0413\u2019\u0413\u201c\u0413\u201d\u0413\u2022\u0413\u2013\u0413\u04b3\u0413\u04b7\u0413\u04a1\u0413\u04e3\u0413\u04a3\u0413\u049b\u0413\u04bb', upperchars)\n  call assert_equal(\"\\r\", returnchar)\n  call assert_equal(\"\\t\\n\\x0b\\f\\r \", spacechars)\n  call assert_equal(\"\\t\", tabchar)\n  call assert_equal('0123456789ABCDEFabcdef', xdigitchars)\n\n  if has('win32')\n    let identchars_ok = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz\u0412\u0496\u0412\u0492\u0412\u04ee\u0412\u0493\u0412\u201e\u0412\u2026\u0412\u04b6\u0412\u04ae\u0412\u04b2\u0412\u04af\u0412\u04a0\u0412\u04e2\u0412\u04a2\u0412\u049a\u0412\u04ba\u0412\u04b8\u0412\u0497\u0412\u2018\u0412\u2019\u0412\u201c\u0412\u201d\u0412\u2022\u0412\u2013\u0412\u2014\u0412\u04b3\u0412\u04b7\u0412\u04a1\u0412\u04e3\u0412\u04a3\u0412\u049b\u0412\u04bb\u0412\u04b9\u0412\u00a0\u0412\u040e\u0412\u045e\u0412\u0408\u0412\u04e8\u0412\u0498\u0412\u04b0\u0412\u00a7\u0412\u04e9\u0413\u0496\u0413\u0492\u0413\u04ee\u0413\u0493\u0413\u201e\u0413\u2026\u0413\u04b6\u0413\u04ae\u0413\u04b2\u0413\u04af\u0413\u04a0\u0413\u04e2\u0413\u04a2\u0413\u049a\u0413\u04ba\u0413\u04b8\u0413\u0497\u0413\u2018\u0413\u2019\u0413\u201c\u0413\u201d\u0413\u2022\u0413\u2013\u0413\u04b3\u0413\u04b7\u0413\u04a1\u0413\u04e3\u0413\u04a3\u0413\u049b\u0413\u04bb\u0413\u04b9\u0413\u00a0\u0413\u040e\u0413\u045e\u0413\u0408\u0413\u04e8\u0413\u0498\u0413\u04b0\u0413\u00a7\u0413\u0401\u0413\u00a9\u0413\u04d8\u0413\u00ab\u0413\u00ac\u0413\u04ef\u0413\u00ae\u0413\u049c\u0413\u00b0\u0413\u04b1\u0413\u0406\u0413\u0456\u0413\u0499\u0413\u04e9\u0413\u00b6\u0413\u0451\u0413\u2116\u0413\u04d9\u0413\u00bb\u0413\u0458\u0413\u04aa\u0413\u04ab\u0413\u049d'\n    let kwordchars_ok = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz\u0412\u04e9\u0413\u0496\u0413\u0492\u0413\u04ee\u0413\u0493\u0413\u201e\u0413\u2026\u0413\u04b6\u0413\u04ae\u0413\u04b2\u0413\u04af\u0413\u04a0\u0413\u04e2\u0413\u04a2\u0413\u049a\u0413\u04ba\u0413\u04b8\u0413\u0497\u0413\u2018\u0413\u2019\u0413\u201c\u0413\u201d\u0413\u2022\u0413\u2013\u0413\u2014\u0413\u04b3\u0413\u04b7\u0413\u04a1\u0413\u04e3\u0413\u04a3\u0413\u049b\u0413\u04bb\u0413\u04b9\u0413\u00a0\u0413\u040e\u0413\u045e\u0413\u0408\u0413\u04e8\u0413\u0498\u0413\u04b0\u0413\u00a7\u0413\u0401\u0413\u00a9\u0413\u04d8\u0413\u00ab\u0413\u00ac\u0413\u04ef\u0413\u00ae\u0413\u049c\u0413\u00b0\u0413\u04b1\u0413\u0406\u0413\u0456\u0413\u0499\u0413\u04e9\u0413\u00b6\u0413\u00b7\u0413\u0451\u0413\u2116\u0413\u04d9\u0413\u00bb\u0413\u0458\u0413\u04aa\u0413\u04ab\u0413\u049d'\n  else\n    let identchars_ok = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz\u0412\u04e9\u0413\u0496\u0413\u0492\u0413\u04ee\u0413\u0493\u0413\u201e\u0413\u2026\u0413\u04b6\u0413\u04ae\u0413\u04b2\u0413\u04af\u0413\u04a0\u0413\u04e2\u0413\u04a2\u0413\u049a\u0413\u04ba\u0413\u04b8\u0413\u0497\u0413\u2018\u0413\u2019\u0413\u201c\u0413\u201d\u0413\u2022\u0413\u2013\u0413\u2014\u0413\u04b3\u0413\u04b7\u0413\u04a1\u0413\u04e3\u0413\u04a3\u0413\u049b\u0413\u04bb\u0413\u04b9\u0413\u00a0\u0413\u040e\u0413\u045e\u0413\u0408\u0413\u04e8\u0413\u0498\u0413\u04b0\u0413\u00a7\u0413\u0401\u0413\u00a9\u0413\u04d8\u0413\u00ab\u0413\u00ac\u0413\u04ef\u0413\u00ae\u0413\u049c\u0413\u00b0\u0413\u04b1\u0413\u0406\u0413\u0456\u0413\u0499\u0413\u04e9\u0413\u00b6\u0413\u00b7\u0413\u0451\u0413\u2116\u0413\u04d9\u0413\u00bb\u0413\u0458\u0413\u04aa\u0413\u04ab\u0413\u049d'\n    let kwordchars_ok = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz\u0412\u04e9\u0413\u0496\u0413\u0492\u0413\u04ee\u0413\u0493\u0413\u201e\u0413\u2026\u0413\u04b6\u0413\u04ae\u0413\u04b2\u0413\u04af\u0413\u04a0\u0413\u04e2\u0413\u04a2\u0413\u049a\u0413\u04ba\u0413\u04b8\u0413\u0497\u0413\u2018\u0413\u2019\u0413\u201c\u0413\u201d\u0413\u2022\u0413\u2013\u0413\u2014\u0413\u04b3\u0413\u04b7\u0413\u04a1\u0413\u04e3\u0413\u04a3\u0413\u049b\u0413\u04bb\u0413\u04b9\u0413\u00a0\u0413\u040e\u0413\u045e\u0413\u0408\u0413\u04e8\u0413\u0498\u0413\u04b0\u0413\u00a7\u0413\u0401\u0413\u00a9\u0413\u04d8\u0413\u00ab\u0413\u00ac\u0413\u04ef\u0413\u00ae\u0413\u049c\u0413\u00b0\u0413\u04b1\u0413\u0406\u0413\u0456\u0413\u0499\u0413\u04e9\u0413\u00b6\u0413\u00b7\u0413\u0451\u0413\u2116\u0413\u04d9\u0413\u00bb\u0413\u0458\u0413\u04aa\u0413\u04ab\u0413\u049d'\n  endif\n\n  if has('win32')\n    let fnamechars_ok = '!#$%+,-./0123456789:=@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]_abcdefghijklmnopqrstuvwxyz{}~\u0412\u00a0\u0412\u040e\u0412\u045e\u0412\u0408\u0412\u04e8\u0412\u0498\u0412\u04b0\u0412\u00a7\u0412\u0401\u0412\u00a9\u0412\u04d8\u0412\u00ab\u0412\u00ac\u0412\u04ef\u0412\u00ae\u0412\u049c\u0412\u00b0\u0412\u04b1\u0412\u0406\u0412\u0456\u0412\u0499\u0412\u04e9\u0412\u00b6\u0412\u00b7\u0412\u0451\u0412\u2116\u0412\u04d9\u0412\u00bb\u0412\u0458\u0412\u04aa\u0412\u04ab\u0412\u049d\u0413\u0496\u0413\u0492\u0413\u04ee\u0413\u0493\u0413\u201e\u0413\u2026\u0413\u04b6\u0413\u04ae\u0413\u04b2\u0413\u04af\u0413\u04a0\u0413\u04e2\u0413\u04a2\u0413\u049a\u0413\u04ba\u0413\u04b8\u0413\u0497\u0413\u2018\u0413\u2019\u0413\u201c\u0413\u201d\u0413\u2022\u0413\u2013\u0413\u2014\u0413\u04b3\u0413\u04b7\u0413\u04a1\u0413\u04e3\u0413\u04a3\u0413\u049b\u0413\u04bb\u0413\u04b9\u0413\u00a0\u0413\u040e\u0413\u045e\u0413\u0408\u0413\u04e8\u0413\u0498\u0413\u04b0\u0413\u00a7\u0413\u0401\u0413\u00a9\u0413\u04d8\u0413\u00ab\u0413\u00ac\u0413\u04ef\u0413\u00ae\u0413\u049c\u0413\u00b0\u0413\u04b1\u0413\u0406\u0413\u0456\u0413\u0499\u0413\u04e9\u0413\u00b6\u0413\u00b7\u0413\u0451\u0413\u2116\u0413\u04d9\u0413\u00bb\u0413\u0458\u0413\u04aa\u0413\u04ab\u0413\u049d'\n  elseif has('amiga')\n    let fnamechars_ok = '$+,-./0123456789:ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz~\u0412\u00a0\u0412\u040e\u0412\u045e\u0412\u0408\u0412\u04e8\u0412\u0498\u0412\u04b0\u0412\u00a7\u0412\u0401\u0412\u00a9\u0412\u04d8\u0412\u00ab\u0412\u00ac\u0412\u04ef\u0412\u00ae\u0412\u049c\u0412\u00b0\u0412\u04b1\u0412\u0406\u0412\u0456\u0412\u0499\u0412\u04e9\u0412\u00b6\u0412\u00b7\u0412\u0451\u0412\u2116\u0412\u04d9\u0412\u00bb\u0412\u0458\u0412\u04aa\u0412\u04ab\u0412\u049d\u0413\u0496\u0413\u0492\u0413\u04ee\u0413\u0493\u0413\u201e\u0413\u2026\u0413\u04b6\u0413\u04ae\u0413\u04b2\u0413\u04af\u0413\u04a0\u0413\u04e2\u0413\u04a2\u0413\u049a\u0413\u04ba\u0413\u04b8\u0413\u0497\u0413\u2018\u0413\u2019\u0413\u201c\u0413\u201d\u0413\u2022\u0413\u2013\u0413\u2014\u0413\u04b3\u0413\u04b7\u0413\u04a1\u0413\u04e3\u0413\u04a3\u0413\u049b\u0413\u04bb\u0413\u04b9\u0413\u00a0\u0413\u040e\u0413\u045e\u0413\u0408\u0413\u04e8\u0413\u0498\u0413\u04b0\u0413\u00a7\u0413\u0401\u0413\u00a9\u0413\u04d8\u0413\u00ab\u0413\u00ac\u0413\u04ef\u0413\u00ae\u0413\u049c\u0413\u00b0\u0413\u04b1\u0413\u0406\u0413\u0456\u0413\u0499\u0413\u04e9\u0413\u00b6\u0413\u00b7\u0413\u0451\u0413\u2116\u0413\u04d9\u0413\u00bb\u0413\u0458\u0413\u04aa\u0413\u04ab\u0413\u049d'\n  elseif has('vms')\n    let fnamechars_ok = '#$%+,-./0123456789:;<>ABCDEFGHIJKLMNOPQRSTUVWXYZ[]_abcdefghijklmnopqrstuvwxyz~\u0412\u00a0\u0412\u040e\u0412\u045e\u0412\u0408\u0412\u04e8\u0412\u0498\u0412\u04b0\u0412\u00a7\u0412\u0401\u0412\u00a9\u0412\u04d8\u0412\u00ab\u0412\u00ac\u0412\u04ef\u0412\u00ae\u0412\u049c\u0412\u00b0\u0412\u04b1\u0412\u0406\u0412\u0456\u0412\u0499\u0412\u04e9\u0412\u00b6\u0412\u00b7\u0412\u0451\u0412\u2116\u0412\u04d9\u0412\u00bb\u0412\u0458\u0412\u04aa\u0412\u04ab\u0412\u049d\u0413\u0496\u0413\u0492\u0413\u04ee\u0413\u0493\u0413\u201e\u0413\u2026\u0413\u04b6\u0413\u04ae\u0413\u04b2\u0413\u04af\u0413\u04a0\u0413\u04e2\u0413\u04a2\u0413\u049a\u0413\u04ba\u0413\u04b8\u0413\u0497\u0413\u2018\u0413\u2019\u0413\u201c\u0413\u201d\u0413\u2022\u0413\u2013\u0413\u2014\u0413\u04b3\u0413\u04b7\u0413\u04a1\u0413\u04e3\u0413\u04a3\u0413\u049b\u0413\u04bb\u0413\u04b9\u0413\u00a0\u0413\u040e\u0413\u045e\u0413\u0408\u0413\u04e8\u0413\u0498\u0413\u04b0\u0413\u00a7\u0413\u0401\u0413\u00a9\u0413\u04d8\u0413\u00ab\u0413\u00ac\u0413\u04ef\u0413\u00ae\u0413\u049c\u0413\u00b0\u0413\u04b1\u0413\u0406\u0413\u0456\u0413\u0499\u0413\u04e9\u0413\u00b6\u0413\u00b7\u0413\u0451\u0413\u2116\u0413\u04d9\u0413\u00bb\u0413\u0458\u0413\u04aa\u0413\u04ab\u0413\u049d'\n  else\n    let fnamechars_ok = '#$%+,-./0123456789=ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz~\u0412\u00a0\u0412\u040e\u0412\u045e\u0412\u0408\u0412\u04e8\u0412\u0498\u0412\u04b0\u0412\u00a7\u0412\u0401\u0412\u00a9\u0412\u04d8\u0412\u00ab\u0412\u00ac\u0412\u04ef\u0412\u00ae\u0412\u049c\u0412\u00b0\u0412\u04b1\u0412\u0406\u0412\u0456\u0412\u0499\u0412\u04e9\u0412\u00b6\u0412\u00b7\u0412\u0451\u0412\u2116\u0412\u04d9\u0412\u00bb\u0412\u0458\u0412\u04aa\u0412\u04ab\u0412\u049d\u0413\u0496\u0413\u0492\u0413\u04ee\u0413\u0493\u0413\u201e\u0413\u2026\u0413\u04b6\u0413\u04ae\u0413\u04b2\u0413\u04af\u0413\u04a0\u0413\u04e2\u0413\u04a2\u0413\u049a\u0413\u04ba\u0413\u04b8\u0413\u0497\u0413\u2018\u0413\u2019\u0413\u201c\u0413\u201d\u0413\u2022\u0413\u2013\u0413\u2014\u0413\u04b3\u0413\u04b7\u0413\u04a1\u0413\u04e3\u0413\u04a3\u0413\u049b\u0413\u04bb\u0413\u04b9\u0413\u00a0\u0413\u040e\u0413\u045e\u0413\u0408\u0413\u04e8\u0413\u0498\u0413\u04b0\u0413\u00a7\u0413\u0401\u0413\u00a9\u0413\u04d8\u0413\u00ab\u0413\u00ac\u0413\u04ef\u0413\u00ae\u0413\u049c\u0413\u00b0\u0413\u04b1\u0413\u0406\u0413\u0456\u0413\u0499\u0413\u04e9\u0413\u00b6\u0413\u00b7\u0413\u0451\u0413\u2116\u0413\u04d9\u0413\u00bb\u0413\u0458\u0413\u04aa\u0413\u04ab\u0413\u049d'\n  endif\n\n  call assert_equal(identchars_ok, identchars)\n  call assert_equal(kwordchars_ok, kwordchars)\n  call assert_equal(fnamechars_ok, fnamechars)\n\n  call assert_equal(identchars1, identchars)\n  call assert_equal(kwordchars1, kwordchars)\n  call assert_equal(fnamechars1, fnamechars)\nendfunc\n\nfunc Test_classes_re1()\n  set re=1\n  call s:classes_test()\n  set re=0\nendfunc\n\nfunc Test_classes_re2()\n  set re=2\n  call s:classes_test()\n  set re=0\nendfunc\n\nfunc Test_reversed_range()\n  for re in range(0, 2)\n    exe 'set re=' . re\n    call assert_fails('call match(\"abc def\", \"[c-a]\")', 'E944:', re)\n  endfor\n  set re=0\nendfunc\n\nfunc Test_large_class()\n  set re=1\n  call assert_fails('call match(\"abc def\", \"[\\u3000-\\u4000]\")', 'E945:')\n  set re=2\n  call assert_equal(0, 'abc def' =~# '[\\u3000-\\u4000]')\n  call assert_equal(1, \"\\u3042\" =~# '[\\u3000-\\u4000]')\n  set re=0\nendfunc\n\nfunc Test_optmatch_toolong()\n  set re=1\n  \" Can only handle about 8000 characters.\n  let pat = '\\\\%[' .. repeat('x', 9000) .. ']'\n  call assert_fails('call match(\"abc def\", \"' .. pat .. '\")', 'E339:')\n  set re=0\nendfunc\n\n\" Test for regexp patterns with multi-byte support, using utf-8.\nfunc Test_multibyte_chars()\n  \" tl is a List of Lists with:\n  \"    2: test auto/old/new  0: test auto/old  1: test auto/new\n  \"    regexp pattern\n  \"    text to test the pattern on\n  \"    expected match (optional)\n  \"    expected submatch 1 (optional)\n  \"    expected submatch 2 (optional)\n  \"    etc.\n  \"  When there is no match use only the first two items.\n  let tl = []\n\n  \" Multi-byte character tests. These will fail unless vim is compiled\n  \" with Multibyte (FEAT_MBYTE) or BIG/HUGE features.\n  call add(tl, [2, '[[:alpha:][=a=]]\\+', '879 aia\u0413\u0408\u0413\u045eaiuvna ', 'aia\u0413\u0408\u0413\u045eaiuvna'])\n  call add(tl, [2, '[[=a=]]\\+', 'dda\u0413\u0408\u0413\u045ebcd', 'a\u0413\u0408\u0413\u045e'])\t\t\t\t\t\t\t\t\" equivalence classes\n  call add(tl, [2, '[^\u0430\u0451\u040e ]\\+', '\u0430\u0451\u040e\u0430\u0451\u040e oijasoifjos ifjoisj f osij j \u0430\u0451\u040e\u0430\u0451\u040e\u0430\u0451\u040e\u0430\u0451\u040e\u0430\u0451\u040e abcd', 'oijasoifjos'])\n  call add(tl, [2, ' [^ ]\\+', 'start \u0430\u0451\u040eabcd\u0430\u0451\u040e ', ' \u0430\u0451\u040eabcd\u0430\u0451\u040e'])\n  call add(tl, [2, '[\u0430\u0451\u040e[:alpha:][=a=]]\\+', '879 aia\u0413\u0408\u0430\u0451\u040e\u0413\u045e\u0430\u0451\u040eaiuvna ', 'aia\u0413\u0408\u0430\u0451\u040e\u0413\u045e\u0430\u0451\u040eaiuvna'])\n\n  \" this is not a normal \"i\" but 0xec\n  call add(tl, [2, '\\p\\+', '\u0413\u00aca', '\u0413\u00aca'])\n  call add(tl, [2, '\\p*', 'a\u0433\u0492\u04ee', 'a\u0433\u0492\u04ee'])\n\n  \" Test recognition of some character classes\n  call add(tl, [2, '\\i\\+', '&*\u0412\u0401xx ', 'xx'])\n  call add(tl, [2, '\\f\\+', '&*\u0412\u04b9fname ', 'fname'])\n\n  \" Test composing character matching\n  call add(tl, [2, '.\u0430\u0451\u040e', 'x\u0430\u0451\u040e\u0430\u2116\u04b2x y\u0430\u0451\u040ey', 'y\u0430\u0451\u040e'])\n  call add(tl, [2, '.\u0430\u0451\u040e\u0430\u2116\u04b2', 'x\u0430\u0451\u040e\u0430\u2116\u04b2x y\u0430\u0451\u040ey', 'x\u0430\u0451\u040e\u0430\u2116\u04b2'])\n  call add(tl, [2, \"\\u05b9\", \" x\\u05b9 \", \"x\\u05b9\"])\n  call add(tl, [2, \".\\u05b9\", \" x\\u05b9 \", \"x\\u05b9\"])\n  call add(tl, [2, \"\\u05b9\\u05bb\", \" x\\u05b9\\u05bb \", \"x\\u05b9\\u05bb\"])\n  call add(tl, [2, \".\\u05b9\\u05bb\", \" x\\u05b9\\u05bb \", \"x\\u05b9\\u05bb\"])\n  call add(tl, [2, \"\\u05bb\\u05b9\", \" x\\u05b9\\u05bb \", \"x\\u05b9\\u05bb\"])\n  call add(tl, [2, \".\\u05bb\\u05b9\", \" x\\u05b9\\u05bb \", \"x\\u05b9\\u05bb\"])\n  call add(tl, [2, \"\\u05b9\", \" y\\u05bb x\\u05b9 \", \"x\\u05b9\"])\n  call add(tl, [2, \".\\u05b9\", \" y\\u05bb x\\u05b9 \", \"x\\u05b9\"])\n  call add(tl, [2, \"\\u05b9\", \" y\\u05bb\\u05b9 x\\u05b9 \", \"y\\u05bb\\u05b9\"])\n  call add(tl, [2, \".\\u05b9\", \" y\\u05bb\\u05b9 x\\u05b9 \", \"y\\u05bb\\u05b9\"])\n  call add(tl, [1, \"\\u05b9\\u05bb\", \" y\\u05b9 x\\u05b9\\u05bb \", \"x\\u05b9\\u05bb\"])\n  call add(tl, [2, \".\\u05b9\\u05bb\", \" y\\u05bb x\\u05b9\\u05bb \", \"x\\u05b9\\u05bb\"])\n  call add(tl, [2, \"a\", \"ca\\u0300t\"])\n  call add(tl, [2, \"ca\", \"ca\\u0300t\"])\n  call add(tl, [2, \"a\\u0300\", \"ca\\u0300t\", \"a\\u0300\"])\n  call add(tl, [2, 'a\\%C', \"ca\\u0300t\", \"a\\u0300\"])\n  call add(tl, [2, 'ca\\%C', \"ca\\u0300t\", \"ca\\u0300\"])\n  call add(tl, [2, 'ca\\%Ct', \"ca\\u0300t\", \"ca\\u0300t\"])\n\n  \" Test \\Z\n  call add(tl, [2, '\u0413\u04d9\\Z', 'x'])\n  call add(tl, [2, '\u0427\u04b7\u0427\u201d\u0427\u2022\u0427\u201d\\Z', '\u0427\u04b7\u0427\u201d\u0427\u2022\u0427\u201d', '\u0427\u04b7\u0427\u201d\u0427\u2022\u0427\u201d'])\n  call add(tl, [2, '\u0427\u04b7\u0426\u00b0\u0427\u201d\u0427\u2022\u0426\u0451\u0427\u201d\\Z', '\u0427\u04b7\u0427\u201d\u0427\u2022\u0427\u201d', '\u0427\u04b7\u0427\u201d\u0427\u2022\u0427\u201d'])\n  call add(tl, [2, '\u0427\u04b7\u0427\u201d\u0427\u2022\u0427\u201d\\Z', '\u0427\u04b7\u0426\u00b0\u0427\u201d\u0427\u2022\u0426\u0451\u0427\u201d', '\u0427\u04b7\u0426\u00b0\u0427\u201d\u0427\u2022\u0426\u0451\u0427\u201d'])\n  call add(tl, [2, '\u0427\u04b7\u0426\u00b0\u0427\u201d\u0427\u2022\u0426\u0451\u0427\u201d\\Z', '\u0427\u04b7\u0426\u00b0\u0427\u201d\u0427\u2022\u0426\u0451\u0427\u201d', '\u0427\u04b7\u0426\u00b0\u0427\u201d\u0427\u2022\u0426\u0451\u0427\u201d'])\n  call add(tl, [2, '\u0427\u04b7\u0426\u00b0\\Z', '\u0427\u2022\u0426\u00b0\u0427\u04b7\u0426\u00b7', '\u0427\u04b7\u0426\u00b7'])\n  call add(tl, [2, \"\u0427\u00a7\\u200d\\u05b9x\\\\Z\", \"x\u0427\u00a7\\u200d\\u05b9xy\", \"\u0427\u00a7\\u200d\\u05b9x\"])\n  call add(tl, [2, \"\u0427\u00a7\\u200d\\u05b9x\\\\Z\", \"x\u0427\u00a7\\u200dxy\", \"\u0427\u00a7\\u200dx\"])\n  call add(tl, [2, \"\u0427\u00a7\\u200dx\\\\Z\", \"x\u0427\u00a7\\u200d\\u05b9xy\", \"\u0427\u00a7\\u200d\\u05b9x\"])\n  call add(tl, [2, \"\u0427\u00a7\\u200dx\\\\Z\", \"x\u0427\u00a7\\u200dxy\", \"\u0427\u00a7\\u200dx\"])\n  call add(tl, [2, \"\\u05b9\\\\Z\", \"xyz\"])\n  call add(tl, [2, \"\\\\Z\\u05b9\", \"xyz\"])\n  call add(tl, [2, \"\\u05b9\\\\Z\", \"xy\\u05b9z\", \"y\\u05b9\"])\n  call add(tl, [2, \"\\\\Z\\u05b9\", \"xy\\u05b9z\", \"y\\u05b9\"])\n  call add(tl, [1, \"\\u05b9\\\\+\\\\Z\", \"xy\\u05b9z\\u05b9 \", \"y\\u05b9z\\u05b9\"])\n  call add(tl, [1, \"\\\\Z\\u05b9\\\\+\", \"xy\\u05b9z\\u05b9 \", \"y\\u05b9z\\u05b9\"])\n\n  \" Combining different tests and features\n  call add(tl, [2, '[^[=a=]]\\+', 'dda\u0413\u0408\u0413\u045ebcd', 'dd'])\n\n  \" Run the tests\n  for t in tl\n    let re = t[0]\n    let pat = t[1]\n    let text = t[2]\n    let matchidx = 3\n    for engine in [0, 1, 2]\n      if engine == 2 && re == 0 || engine == 1 && re == 1\n        continue\n      endif\n      let &regexpengine = engine\n      try\n        let l = matchlist(text, pat)\n      catch\n        call assert_report('Error ' . engine . ': pat: \\\"' . pat .\n\t\t    \\ '\\\", text: \\\"' . text .\n\t\t    \\ '\\\", caused an exception: \\\"' . v:exception . '\\\"')\n      endtry\n      \" check the match itself\n      if len(l) == 0 && len(t) > matchidx\n        call assert_report('Error ' . engine . ': pat: \\\"' . pat .\n\t\t    \\ '\\\", text: \\\"' . text .\n\t\t    \\ '\\\", did not match, expected: \\\"' . t[matchidx] . '\\\"')\n      elseif len(l) > 0 && len(t) == matchidx\n        call assert_report('Error ' . engine . ': pat: \\\"' . pat .\n\t\t    \\ '\\\", text: \\\"' . text . '\\\", match: \\\"' . l[0] .\n\t\t    \\ '\\\", expected no match')\n      elseif len(t) > matchidx && l[0] != t[matchidx]\n        call assert_report('Error ' . engine . ': pat: \\\"' . pat .\n\t\t    \\ '\\\", text: \\\"' . text . '\\\", match: \\\"' . l[0] .\n\t\t    \\ '\\\", expected: \\\"' . t[matchidx] . '\\\"')\n      else\n        \" Test passed\n      endif\n      if len(l) > 0\n        \" check all the nine submatches\n        for i in range(1, 9)\n          if len(t) <= matchidx + i\n            let e = ''\n          else\n            let e = t[matchidx + i]\n          endif\n          if l[i] != e\n            call assert_report('Error ' . engine . ': pat: \\\"' . pat .\n                  \\ '\\\", text: \\\"' . text . '\\\", submatch ' . i .\n                  \\ ': \\\"' . l[i] . '\\\", expected: \\\"' . e . '\\\"')\n          endif\n        endfor\n        unlet i\n      endif\n    endfor\n  endfor\n  set regexpengine&\nendfunc\n\n\" check that 'ambiwidth' does not change the meaning of \\p\nfunc Test_ambiwidth()\n  set regexpengine=1 ambiwidth=single\n  call assert_equal(0, match(\"\\u00EC\", '\\p'))\n  set regexpengine=1 ambiwidth=double\n  call assert_equal(0, match(\"\\u00EC\", '\\p'))\n  set regexpengine=2 ambiwidth=single\n  call assert_equal(0, match(\"\\u00EC\", '\\p'))\n  set regexpengine=2 ambiwidth=double\n  call assert_equal(0, match(\"\\u00EC\", '\\p'))\n  set regexpengine& ambiwidth&\nendfunc\n\nfunc Run_regexp_ignore_case()\n  call assert_equal('iI\u0414\u00b0', substitute('iI\u0414\u00b0', '\\([iI\u0414\u00b0]\\)', '\\1', 'g'))\n\n  call assert_equal('iIx', substitute('iI\u0414\u00b0', '\\c\\([\u0414\u00b0]\\)', 'x', 'g'))\n  call assert_equal('xx\u0414\u00b0', substitute('iI\u0414\u00b0', '\\(i\\c\\)', 'x', 'g'))\n  call assert_equal('iIx', substitute('iI\u0414\u00b0', '\\(\u0414\u00b0\\c\\)', 'x', 'g'))\n  call assert_equal('iIx', substitute('iI\u0414\u00b0', '\\c\\(\\%u0130\\)', 'x', 'g'))\n  call assert_equal('iIx', substitute('iI\u0414\u00b0', '\\c\\([\\u0130]\\)', 'x', 'g'))\n  call assert_equal('iIx', substitute('iI\u0414\u00b0', '\\c\\([\\u012f-\\u0131]\\)', 'x', 'g'))\nendfunc\n\nfunc Test_regexp_ignore_case()\n  set regexpengine=1\n  call Run_regexp_ignore_case()\n  set regexpengine=2\n  call Run_regexp_ignore_case()\n  set regexpengine&\nendfunc\n\n\" Tests for regexp with multi-byte encoding and various magic settings\nfunc Run_regexp_multibyte_magic()\n  let text =<< trim END\n    1 a aa abb abbccc\n    2 d dd dee deefff\n    3 g gg ghh ghhiii\n    4 j jj jkk jkklll\n    5 m mm mnn mnnooo\n    6 x ^aa$ x\n    7 (a)(b) abbaa\n    8 axx [ab]xx\n    9 \u0430\u0451\u00ab\u0430\u0451\u040e\u0430\u2116\u04b2x \u0430\u0451\u04ef\u0430\u0451\u040ex\n    a \u0430\u0451\u04ef\u0430\u0451\u040ex \u0430\u0451\u00ab\u0430\u0451\u040e\u0430\u2116\u04b2x\n    b \u0433\u0492\u040e\u0433\u04ee\u00ab\u0433\u0493\u0401\u0433\u0492\u049c\n    c x \u0412\u00ac\u0432\u04ee\u00acx\n    d \u0435\u04e8\u00a9\u0434\u04aa\u049dx\n    e \u044c\u2019\u049a\u2026\u04b7\u0451y\n    f \u044c\u2019\u049a\u04a0\u049c\u049az\n    g a\u0435\u2022\u00b7bb\n    j 0123\u0432\u049b\u04e8x\n    k combinations\n    l \u0413\u04e8\u0413\u00b6 \u0413\u0458\u041e\u04b1\u041c\u201e\u041c\u04b6\u041c\u0492\n  END\n\n  new\n  call setline(1, text)\n  exe 'normal /a*b\\{2}c\\+/e' .. \"\\<CR>x\"\n  call assert_equal('1 a aa abb abbcc', getline('.'))\n  exe 'normal /\\Md\\*e\\{2}f\\+/e' .. \"\\<CR>x\"\n  call assert_equal('2 d dd dee deeff', getline('.'))\n  set nomagic\n  exe 'normal /g\\*h\\{2}i\\+/e' .. \"\\<CR>x\"\n  call assert_equal('3 g gg ghh ghhii', getline('.'))\n  exe 'normal /\\mj*k\\{2}l\\+/e' .. \"\\<CR>x\"\n  call assert_equal('4 j jj jkk jkkll', getline('.'))\n  exe 'normal /\\vm*n{2}o+/e' .. \"\\<CR>x\"\n  call assert_equal('5 m mm mnn mnnoo', getline('.'))\n  exe 'normal /\\V^aa$/' .. \"\\<CR>x\"\n  call assert_equal('6 x aa$ x', getline('.'))\n  set magic\n  exe 'normal /\\v(a)(b)\\2\\1\\1/e' .. \"\\<CR>x\"\n  call assert_equal('7 (a)(b) abba', getline('.'))\n  exe 'normal /\\V[ab]\\(\\[xy]\\)\\1' .. \"\\<CR>x\"\n  call assert_equal('8 axx ab]xx', getline('.'))\n\n  \" search for multi-byte without composing char\n  exe 'normal /\u0430\u0451\u040e' .. \"\\<CR>x\"\n  call assert_equal('9 \u0430\u0451\u00ab\u0430\u0451\u040e\u0430\u2116\u04b2x \u0430\u0451\u04efx', getline('.'))\n\n  \" search for multi-byte with composing char\n  exe 'normal /\u0430\u0451\u040e\u0430\u2116\u04b2' .. \"\\<CR>x\"\n  call assert_equal('a \u0430\u0451\u04ef\u0430\u0451\u040ex \u0430\u0451\u00abx', getline('.'))\n\n  \" find word by change of word class\n  exe 'normal /\u0433\u0492\u040e\\<\u0433\u04ee\u00ab\u0433\u0493\u0401\\>\u0433\u0492\u049c' .. \"\\<CR>x\"\n  call assert_equal('b \u0433\u04ee\u00ab\u0433\u0493\u0401\u0433\u0492\u049c', getline('.'))\n\n  \" Test \\%u, [\\u] and friends\n  \" c\n  exe 'normal /\\%u20ac' .. \"\\<CR>x\"\n  call assert_equal('c x \u0412\u00acx', getline('.'))\n  \" d\n  exe 'normal /[\\u4f7f\\u5929]\\+' .. \"\\<CR>x\"\n  call assert_equal('d \u0434\u04aa\u049dx', getline('.'))\n  \" e\n  exe 'normal /\\%U12345678' .. \"\\<CR>x\"\n  call assert_equal('e y', getline('.'))\n  \" f\n  exe 'normal /[\\U1234abcd\\u1234\\uabcd]' .. \"\\<CR>x\"\n  call assert_equal('f z', getline('.'))\n  \" g\n  exe 'normal /\\%d21879b' .. \"\\<CR>x\"\n  call assert_equal('g abb', getline('.'))\n\n  \" j Test backwards search from a multi-byte char\n  exe \"normal /x\\<CR>x?.\\<CR>x\"\n  call assert_equal('j 012\u0432\u049b\u04e8', getline('.'))\n  \" k\n  let @w=':%s#comb[i]nations#\u0415\u201c\u041c\u201e\u0431\u2116\u0408\u041c\u0492m\u041c\u0498\u041c\u201e\u041e\u04b1\u041c\u201e\u041c\u04b6\u041c\u0492#g'\n  @w\n  call assert_equal('k \u0415\u201c\u041c\u201e\u0431\u2116\u0408\u041c\u0492m\u041c\u0498\u041c\u201e\u041e\u04b1\u041c\u201e\u041c\u04b6\u041c\u0492', getline(18))\n\n  close!\nendfunc\n\nfunc Test_regexp_multibyte_magic()\n  set regexpengine=1\n  call Run_regexp_multibyte_magic()\n  set regexpengine=2\n  call Run_regexp_multibyte_magic()\n  set regexpengine&\nendfunc\n\n\" Test for 7.3.192\n\" command \":s/ \\?/ /g\" splits multi-byte characters into bytes\nfunc Test_split_multibyte_to_bytes()\n  new\n  call setline(1, 'l \u0413\u04e8\u0413\u00b6 \u0413\u0458\u041e\u04b1\u041c\u201e\u041c\u04b6\u041c\u0492')\n  s/ \\?/ /g\n  call assert_equal(' l \u0413\u04e8 \u0413\u00b6 \u0413\u0458 \u041e\u04b1\u041c\u201e\u041c\u04b6\u041c\u0492', getline(1))\n  close!\nendfunc\n\n\" Test for matchstr() with multibyte characters\nfunc Test_matchstr_multibyte()\n  new\n  call assert_equal('\u0427\u2018', matchstr(\"\u0427\u0497\u0427\u2018\u0427\u2019\u0427\u201c\", \".\", 0, 2))\n  call assert_equal('\u0427\u2018\u0427\u2019', matchstr(\"\u0427\u0497\u0427\u2018\u0427\u2019\u0427\u201c\", \"..\", 0, 2))\n  call assert_equal('\u0427\u0497', matchstr(\"\u0427\u0497\u0427\u2018\u0427\u2019\u0427\u201c\", \".\", 0, 0))\n  call assert_equal('\u0427\u2019', matchstr(\"\u0427\u0497\u0427\u2018\u0427\u2019\u0427\u201c\", \".\", 4, -1))\n  close!\nendfunc\n\n\" Test for 7.4.636\n\" A search with end offset gets stuck at end of file.\nfunc Test_search_with_end_offset()\n  new\n  call setline(1, ['', 'dog(a', 'cat('])\n  exe \"normal /(/e+\\<CR>\"\n  normal n\"ayn\n  call assert_equal(\"a\\ncat(\", @a)\n  close!\nendfunc\n\n\" Check that \"^\" matches even when the line starts with a combining char\nfunc Test_match_start_of_line_combining()\n  new\n  call setline(1, ['', \"\\u05ae\", ''])\n  exe \"normal gg/^\\<CR>\"\n  call assert_equal(2, getcurpos()[1])\n  bwipe!\nendfunc\n\n\" Check that [[:upper:]] matches for automatic engine\nfunc Test_match_char_class_upper()\n  new\n\n  \" Test 1: [[:upper:]]\\{2,\\}\n  set regexpengine=0\n  call setline(1, ['05. \u0420\u04b9\u0420\u2022\u0420\u040e\u0420\u049b\u0420\u049c \u0420\u04bb \u0420\u201c\u0420\u2022\u0420\u00a0\u0420\u04bb\u0420\u049c\u0420\u0498 \u0420\u0458\u0421\u0493\u0420\u00b7. \u0420\u0497. \u0420\u201d\u0420\u00b0\u0420\u0406\u0420\u0451\u0420\u0499\u0420\u04e9\u0420\u04aa\u0420\u04d9\u0420\u04ab, \u0420\u04a3. \u0420\u04a1\u0420\u04ab\u0420\u0406\u0420\u00b0\u0420\u00bb\u0421\u04b8 \u0420\u0451 \u0420\u2018. \u0420\u0401\u0420\u04e9\u0421\u2026\u0421\u04ee\u0420\u04e9\u0421\u0496\u0420\u00b0 ...', '05. PJESNJA O GJEROJAKH mus. A. Davidjenko, M. Kovalja i B. Shjekhtjera ...'])\n  call cursor(1,1)\n  let search_cmd='norm /\\<[[:upper:]]\\{2,\\}\\>' .. \"\\<CR>\"\n  exe search_cmd\n  call assert_equal(4, searchcount().total, 'TEST 1')\n  set regexpengine=1\n  exe search_cmd\n  call assert_equal(2, searchcount().total, 'TEST 1')\n  set regexpengine=2\n  exe search_cmd\n  call assert_equal(4, searchcount().total, 'TEST 1')\n\n  \" Test 2: [[:upper:]].\\+\n  let search_cmd='norm /\\<[[:upper:]].\\+\\>' .. \"\\<CR>\"\n  set regexpengine=0\n  exe search_cmd\n  call assert_equal(2, searchcount().total, 'TEST 2')\n  set regexpengine=1\n  exe search_cmd\n  call assert_equal(1, searchcount().total, 'TEST 2')\n  set regexpengine=2\n  exe search_cmd\n  call assert_equal(2, searchcount().total, 'TEST 2')\n\n  \" Test 3: [[:lower:]]\\+\n  let search_cmd='norm /\\<[[:lower:]]\\+\\>' .. \"\\<CR>\"\n  set regexpengine=0\n  exe search_cmd\n  call assert_equal(4, searchcount().total, 'TEST 3 lower')\n  set regexpengine=1\n  exe search_cmd\n  call assert_equal(2, searchcount().total, 'TEST 3 lower')\n  set regexpengine=2\n  exe search_cmd\n  call assert_equal(4, searchcount().total, 'TEST 3 lower')\n\n  \" clean up\n  set regexpengine=0\n  bwipe!\nendfunc\n\nfunc Test_match_invalid_byte()\n  call writefile(0z630a.765d30aa0a.2e0a.790a.4030, 'Xinvalid')\n  new\n  source Xinvalid\n  bwipe!\n  call delete('Xinvalid')\nendfunc\n\nfunc Test_match_too_complicated()\n  set regexpengine=1\n  exe \"noswapfile vsplit \\xeb\\xdb\\x99\"\n  silent! buf \\&\\zs*\\zs*0\n  bwipe!\n  set regexpengine=0\nendfunc\n\n\n\" vim: shiftwidth=2 sts=2 expandtab\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\t\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n#include \"vim.h\"\n\n/*\n * Vim originated from Stevie version 3.6 (Fish disk 217) by GRWalter (Fred)\n * It has been changed beyond recognition since then.\n *\n * Differences between version 8.2 and 9.0 can be found with \":help version9\".\n * Differences between version 7.4 and 8.x can be found with \":help version8\".\n * Differences between version 6.4 and 7.x can be found with \":help version7\".\n * Differences between version 5.8 and 6.x can be found with \":help version6\".\n * Differences between version 4.x and 5.x can be found with \":help version5\".\n * Differences between version 3.0 and 4.x can be found with \":help version4\".\n * All the remarks about older versions have been removed, they are not very\n * interesting.\n */\n\n#include \"version.h\"\n\nchar\t\t*Version = VIM_VERSION_SHORT;\nstatic char\t*mediumVersion = VIM_VERSION_MEDIUM;\n\n#if defined(HAVE_DATE_TIME) || defined(PROTO)\n# if (defined(VMS) && defined(VAXC)) || defined(PROTO)\nchar\tlongVersion[sizeof(VIM_VERSION_LONG_DATE) + sizeof(__DATE__)\n\t\t\t\t\t\t      + sizeof(__TIME__) + 3];\n\n    void\ninit_longVersion(void)\n{\n    /*\n     * Construct the long version string.  Necessary because\n     * VAX C can't concatenate strings in the preprocessor.\n     */\n    strcpy(longVersion, VIM_VERSION_LONG_DATE);\n#ifdef BUILD_DATE\n    strcat(longVersion, BUILD_DATE);\n#else\n    strcat(longVersion, __DATE__);\n    strcat(longVersion, \" \");\n    strcat(longVersion, __TIME__);\n#endif\n    strcat(longVersion, \")\");\n}\n\n# else\nchar\t*longVersion = NULL;\n\n    void\ninit_longVersion(void)\n{\n    if (longVersion == NULL)\n    {\n#ifdef BUILD_DATE\n\tchar *date_time = BUILD_DATE;\n#else\n\tchar *date_time = __DATE__ \" \" __TIME__;\n#endif\n\tchar *msg = _(\"%s (%s, compiled %s)\");\n\tsize_t len = strlen(msg)\n\t\t    + strlen(VIM_VERSION_LONG_ONLY)\n\t\t    + strlen(VIM_VERSION_DATE_ONLY)\n\t\t    + strlen(date_time);\n\n\tlongVersion = alloc(len);\n\tif (longVersion == NULL)\n\t    longVersion = VIM_VERSION_LONG;\n\telse\n\t    vim_snprintf(longVersion, len, msg,\n\t\t      VIM_VERSION_LONG_ONLY, VIM_VERSION_DATE_ONLY, date_time);\n    }\n}\n# endif\n#else\nchar\t*longVersion = VIM_VERSION_LONG;\n\n    void\ninit_longVersion(void)\n{\n    // nothing to do\n}\n#endif\n\nstatic char *(features[]) =\n{\n#ifdef HAVE_ACL\n\t\"+acl\",\n#else\n\t\"-acl\",\n#endif\n#ifdef AMIGA\t\t// only for Amiga systems\n# ifdef FEAT_ARP\n\t\"+ARP\",\n# else\n\t\"-ARP\",\n# endif\n#endif\n#ifdef FEAT_ARABIC\n\t\"+arabic\",\n#else\n\t\"-arabic\",\n#endif\n\t\"+autocmd\",\n#ifdef FEAT_AUTOCHDIR\n       \"+autochdir\",\n#else\n       \"-autochdir\",\n#endif\n#ifdef FEAT_AUTOSERVERNAME\n\t\"+autoservername\",\n#else\n\t\"-autoservername\",\n#endif\n#ifdef FEAT_BEVAL_GUI\n\t\"+balloon_eval\",\n#else\n\t\"-balloon_eval\",\n#endif\n#ifdef FEAT_BEVAL_TERM\n\t\"+balloon_eval_term\",\n#else\n\t\"-balloon_eval_term\",\n#endif\n#ifdef FEAT_BROWSE\n\t\"+browse\",\n#else\n\t\"-browse\",\n#endif\n#ifdef NO_BUILTIN_TCAPS\n\t\"-builtin_terms\",\n#endif\n#ifdef SOME_BUILTIN_TCAPS\n\t\"+builtin_terms\",\n#endif\n#ifdef ALL_BUILTIN_TCAPS\n\t\"++builtin_terms\",\n#endif\n#ifdef FEAT_BYTEOFF\n\t\"+byte_offset\",\n#else\n\t\"-byte_offset\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+channel\",\n#else\n\t\"-channel\",\n#endif\n\t\"+cindent\",\n#ifdef FEAT_CLIENTSERVER\n\t\"+clientserver\",\n#else\n\t\"-clientserver\",\n#endif\n#ifdef FEAT_CLIPBOARD\n\t\"+clipboard\",\n#else\n\t\"-clipboard\",\n#endif\n\t\"+cmdline_compl\",\n\t\"+cmdline_hist\",\n#ifdef FEAT_CMDL_INFO\n\t\"+cmdline_info\",\n#else\n\t\"-cmdline_info\",\n#endif\n\t\"+comments\",\n#ifdef FEAT_CONCEAL\n\t\"+conceal\",\n#else\n\t\"-conceal\",\n#endif\n#ifdef FEAT_CRYPT\n\t\"+cryptv\",\n#else\n\t\"-cryptv\",\n#endif\n#ifdef FEAT_CSCOPE\n\t\"+cscope\",\n#else\n\t\"-cscope\",\n#endif\n\t\"+cursorbind\",\n#ifdef CURSOR_SHAPE\n\t\"+cursorshape\",\n#else\n\t\"-cursorshape\",\n#endif\n#if defined(FEAT_CON_DIALOG) && defined(FEAT_GUI_DIALOG)\n\t\"+dialog_con_gui\",\n#else\n# if defined(FEAT_CON_DIALOG)\n\t\"+dialog_con\",\n# else\n#  if defined(FEAT_GUI_DIALOG)\n\t\"+dialog_gui\",\n#  else\n\t\"-dialog\",\n#  endif\n# endif\n#endif\n#ifdef FEAT_DIFF\n\t\"+diff\",\n#else\n\t\"-diff\",\n#endif\n#ifdef FEAT_DIGRAPHS\n\t\"+digraphs\",\n#else\n\t\"-digraphs\",\n#endif\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_DIRECTX\n\t\"+directx\",\n# else\n\t\"-directx\",\n# endif\n#endif\n#ifdef FEAT_DND\n\t\"+dnd\",\n#else\n\t\"-dnd\",\n#endif\n\t\"-ebcdic\",\n#ifdef FEAT_EMACS_TAGS\n\t\"+emacs_tags\",\n#else\n\t\"-emacs_tags\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+eval\",\n#else\n\t\"-eval\",\n#endif\n\t\"+ex_extra\",\n#ifdef FEAT_SEARCH_EXTRA\n\t\"+extra_search\",\n#else\n\t\"-extra_search\",\n#endif\n\t\"-farsi\",\n#ifdef FEAT_SEARCHPATH\n\t\"+file_in_path\",\n#else\n\t\"-file_in_path\",\n#endif\n#ifdef FEAT_FIND_ID\n\t\"+find_in_path\",\n#else\n\t\"-find_in_path\",\n#endif\n#ifdef FEAT_FLOAT\n\t\"+float\",\n#else\n\t\"-float\",\n#endif\n#ifdef FEAT_FOLDING\n\t\"+folding\",\n#else\n\t\"-folding\",\n#endif\n#ifdef FEAT_FOOTER\n\t\"+footer\",\n#else\n\t\"-footer\",\n#endif\n\t    // only interesting on Unix systems\n#if !defined(USE_SYSTEM) && defined(UNIX)\n\t\"+fork()\",\n#endif\n#ifdef FEAT_GETTEXT\n# ifdef DYNAMIC_GETTEXT\n\t\"+gettext/dyn\",\n# else\n\t\"+gettext\",\n# endif\n#else\n\t\"-gettext\",\n#endif\n\t\"-hangul_input\",\n#if (defined(HAVE_ICONV_H) && defined(USE_ICONV)) || defined(DYNAMIC_ICONV)\n# ifdef DYNAMIC_ICONV\n\t\"+iconv/dyn\",\n# else\n\t\"+iconv\",\n# endif\n#else\n\t\"-iconv\",\n#endif\n\t\"+insert_expand\",\n#ifdef FEAT_IPV6\n\t\"+ipv6\",\n#else\n\t\"-ipv6\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+job\",\n#else\n\t\"-job\",\n#endif\n\t\"+jumplist\",\n#ifdef FEAT_KEYMAP\n\t\"+keymap\",\n#else\n\t\"-keymap\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+lambda\",\n#else\n\t\"-lambda\",\n#endif\n#ifdef FEAT_LANGMAP\n\t\"+langmap\",\n#else\n\t\"-langmap\",\n#endif\n#ifdef FEAT_LIBCALL\n\t\"+libcall\",\n#else\n\t\"-libcall\",\n#endif\n#ifdef FEAT_LINEBREAK\n\t\"+linebreak\",\n#else\n\t\"-linebreak\",\n#endif\n\t\"+lispindent\",\n\t\"+listcmds\",\n\t\"+localmap\",\n#ifdef FEAT_LUA\n# ifdef DYNAMIC_LUA\n\t\"+lua/dyn\",\n# else\n\t\"+lua\",\n# endif\n#else\n\t\"-lua\",\n#endif\n#ifdef FEAT_MENU\n\t\"+menu\",\n#else\n\t\"-menu\",\n#endif\n#ifdef FEAT_SESSION\n\t\"+mksession\",\n#else\n\t\"-mksession\",\n#endif\n\t\"+modify_fname\",\n\t\"+mouse\",\n#ifdef FEAT_MOUSESHAPE\n\t\"+mouseshape\",\n#else\n\t\"-mouseshape\",\n#endif\n\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_MOUSE_DEC\n\t\"+mouse_dec\",\n# else\n\t\"-mouse_dec\",\n# endif\n# ifdef FEAT_MOUSE_GPM\n#  ifdef DYNAMIC_GPM\n\t\"+mouse_gpm/dyn\",\n#  else\n\t\"+mouse_gpm\",\n#  endif\n# else\n\t\"-mouse_gpm\",\n# endif\n# ifdef FEAT_MOUSE_JSB\n\t\"+mouse_jsbterm\",\n# else\n\t\"-mouse_jsbterm\",\n# endif\n# ifdef FEAT_MOUSE_NET\n\t\"+mouse_netterm\",\n# else\n\t\"-mouse_netterm\",\n# endif\n#endif\n\n#ifdef __QNX__\n# ifdef FEAT_MOUSE_PTERM\n\t\"+mouse_pterm\",\n# else\n\t\"-mouse_pterm\",\n# endif\n#endif\n\n#if defined(UNIX) || defined(VMS)\n\t\"+mouse_sgr\",\n# ifdef FEAT_SYSMOUSE\n\t\"+mouse_sysmouse\",\n# else\n\t\"-mouse_sysmouse\",\n# endif\n# ifdef FEAT_MOUSE_URXVT\n\t\"+mouse_urxvt\",\n# else\n\t\"-mouse_urxvt\",\n# endif\n\t\"+mouse_xterm\",\n#endif\n\n#ifdef FEAT_MBYTE_IME\n# ifdef DYNAMIC_IME\n\t\"+multi_byte_ime/dyn\",\n# else\n\t\"+multi_byte_ime\",\n# endif\n#else\n\t\"+multi_byte\",\n#endif\n#ifdef FEAT_MULTI_LANG\n\t\"+multi_lang\",\n#else\n\t\"-multi_lang\",\n#endif\n#ifdef FEAT_MZSCHEME\n# ifdef DYNAMIC_MZSCHEME\n\t\"+mzscheme/dyn\",\n# else\n\t\"+mzscheme\",\n# endif\n#else\n\t\"-mzscheme\",\n#endif\n#ifdef FEAT_NETBEANS_INTG\n\t\"+netbeans_intg\",\n#else\n\t\"-netbeans_intg\",\n#endif\n\t\"+num64\",\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_OLE\n\t\"+ole\",\n# else\n\t\"-ole\",\n# endif\n#endif\n#ifdef FEAT_EVAL\n\t\"+packages\",\n#else\n\t\"-packages\",\n#endif\n#ifdef FEAT_PATH_EXTRA\n\t\"+path_extra\",\n#else\n\t\"-path_extra\",\n#endif\n#ifdef FEAT_PERL\n# ifdef DYNAMIC_PERL\n\t\"+perl/dyn\",\n# else\n\t\"+perl\",\n# endif\n#else\n\t\"-perl\",\n#endif\n#ifdef FEAT_PERSISTENT_UNDO\n\t\"+persistent_undo\",\n#else\n\t\"-persistent_undo\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+popupwin\",\n#else\n\t\"-popupwin\",\n#endif\n#ifdef FEAT_PRINTER\n# ifdef FEAT_POSTSCRIPT\n\t\"+postscript\",\n# else\n\t\"-postscript\",\n# endif\n\t\"+printer\",\n#else\n\t\"-printer\",\n#endif\n#ifdef FEAT_PROFILE\n\t\"+profile\",\n#else\n\t\"-profile\",\n#endif\n#ifdef FEAT_PYTHON\n# ifdef DYNAMIC_PYTHON\n\t\"+python/dyn\",\n# else\n\t\"+python\",\n# endif\n#else\n\t\"-python\",\n#endif\n#ifdef FEAT_PYTHON3\n# ifdef DYNAMIC_PYTHON3\n\t\"+python3/dyn\",\n# else\n\t\"+python3\",\n# endif\n#else\n\t\"-python3\",\n#endif\n#ifdef FEAT_QUICKFIX\n\t\"+quickfix\",\n#else\n\t\"-quickfix\",\n#endif\n#ifdef FEAT_RELTIME\n\t\"+reltime\",\n#else\n\t\"-reltime\",\n#endif\n#ifdef FEAT_RIGHTLEFT\n\t\"+rightleft\",\n#else\n\t\"-rightleft\",\n#endif\n#ifdef FEAT_RUBY\n# ifdef DYNAMIC_RUBY\n\t\"+ruby/dyn\",\n# else\n\t\"+ruby\",\n# endif\n#else\n\t\"-ruby\",\n#endif\n\t\"+scrollbind\",\n#ifdef FEAT_SIGNS\n\t\"+signs\",\n#else\n\t\"-signs\",\n#endif\n\t\"+smartindent\",\n#ifdef FEAT_SODIUM\n# ifdef DYNAMIC_SODIUM\n\t\"+sodium/dyn\",\n# else\n\t\"+sodium\",\n# endif\n#else\n\t\"-sodium\",\n#endif\n#ifdef FEAT_SOUND\n\t\"+sound\",\n#else\n\t\"-sound\",\n#endif\n#ifdef FEAT_SPELL\n\t\"+spell\",\n#else\n\t\"-spell\",\n#endif\n#ifdef STARTUPTIME\n\t\"+startuptime\",\n#else\n\t\"-startuptime\",\n#endif\n#ifdef FEAT_STL_OPT\n\t\"+statusline\",\n#else\n\t\"-statusline\",\n#endif\n\t\"-sun_workshop\",\n#ifdef FEAT_SYN_HL\n\t\"+syntax\",\n#else\n\t\"-syntax\",\n#endif\n\t    // only interesting on Unix systems\n#if defined(USE_SYSTEM) && defined(UNIX)\n\t\"+system()\",\n#endif\n\t\"+tag_binary\",\n\t\"-tag_old_static\",\n\t\"-tag_any_white\",\n#ifdef FEAT_TCL\n# ifdef DYNAMIC_TCL\n\t\"+tcl/dyn\",\n# else\n\t\"+tcl\",\n# endif\n#else\n\t\"-tcl\",\n#endif\n#ifdef FEAT_TERMGUICOLORS\n\t\"+termguicolors\",\n#else\n\t\"-termguicolors\",\n#endif\n#ifdef FEAT_TERMINAL\n\t\"+terminal\",\n#else\n\t\"-terminal\",\n#endif\n#if defined(UNIX)\n// only Unix can have terminfo instead of termcap\n# ifdef TERMINFO\n\t\"+terminfo\",\n# else\n\t\"-terminfo\",\n# endif\n#endif\n#ifdef FEAT_TERMRESPONSE\n\t\"+termresponse\",\n#else\n\t\"-termresponse\",\n#endif\n#ifdef FEAT_TEXTOBJ\n\t\"+textobjects\",\n#else\n\t\"-textobjects\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+textprop\",\n#else\n\t\"-textprop\",\n#endif\n#if !defined(UNIX)\n// unix always includes termcap support\n# ifdef HAVE_TGETENT\n\t\"+tgetent\",\n# else\n\t\"-tgetent\",\n# endif\n#endif\n#ifdef FEAT_TIMERS\n\t\"+timers\",\n#else\n\t\"-timers\",\n#endif\n\t\"+title\",\n#ifdef FEAT_TOOLBAR\n\t\"+toolbar\",\n#else\n\t\"-toolbar\",\n#endif\n\t\"+user_commands\",\n#ifdef FEAT_VARTABS\n\t\"+vartabs\",\n#else\n\t\"-vartabs\",\n#endif\n\t\"+vertsplit\",\n\t\"+vim9script\",\n#ifdef FEAT_VIMINFO\n\t\"+viminfo\",\n#else\n\t\"-viminfo\",\n#endif\n\t\"+virtualedit\",\n\t\"+visual\",\n\t\"+visualextra\",\n\t\"+vreplace\",\n#ifdef MSWIN\n# ifdef FEAT_VTP\n\t\"+vtp\",\n# else\n\t\"-vtp\",\n# endif\n#endif\n#ifdef FEAT_WILDIGN\n\t\"+wildignore\",\n#else\n\t\"-wildignore\",\n#endif\n#ifdef FEAT_WILDMENU\n\t\"+wildmenu\",\n#else\n\t\"-wildmenu\",\n#endif\n\t\"+windows\",\n#ifdef FEAT_WRITEBACKUP\n\t\"+writebackup\",\n#else\n\t\"-writebackup\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_X11\n\t\"+X11\",\n# else\n\t\"-X11\",\n# endif\n#endif\n#ifdef FEAT_XFONTSET\n\t\"+xfontset\",\n#else\n\t\"-xfontset\",\n#endif\n#ifdef FEAT_XIM\n\t\"+xim\",\n#else\n\t\"-xim\",\n#endif\n#if defined(MSWIN)\n# ifdef FEAT_XPM_W32\n\t\"+xpm_w32\",\n# else\n\t\"-xpm_w32\",\n# endif\n#elif defined(HAVE_XPM)\n\t\"+xpm\",\n#else\n\t\"-xpm\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# if defined(USE_XSMP_INTERACT)\n\t\"+xsmp_interact\",\n# elif defined(USE_XSMP)\n\t\"+xsmp\",\n# else\n\t\"-xsmp\",\n# endif\n# ifdef FEAT_XCLIPBOARD\n\t\"+xterm_clipboard\",\n# else\n\t\"-xterm_clipboard\",\n# endif\n#endif\n#ifdef FEAT_XTERM_SAVE\n\t\"+xterm_save\",\n#else\n\t\"-xterm_save\",\n#endif\n\tNULL\n};\n\nstatic int included_patches[] =\n{   /* Add new patch number below this line */\n/**/\n    104,\n/**/\n    103,\n/**/\n    102,\n/**/\n    101,\n/**/\n    100,\n/**/\n    99,\n/**/\n    98,\n/**/\n    97,\n/**/\n    96,\n/**/\n    95,\n/**/\n    94,\n/**/\n    93,\n/**/\n    92,\n/**/\n    91,\n/**/\n    90,\n/**/\n    89,\n/**/\n    88,\n/**/\n    87,\n/**/\n    86,\n/**/\n    85,\n/**/\n    84,\n/**/\n    83,\n/**/\n    82,\n/**/\n    81,\n/**/\n    80,\n/**/\n    79,\n/**/\n    78,\n/**/\n    77,\n/**/\n    76,\n/**/\n    75,\n/**/\n    74,\n/**/\n    73,\n/**/\n    72,\n/**/\n    71,\n/**/\n    70,\n/**/\n    69,\n/**/\n    68,\n/**/\n    67,\n/**/\n    66,\n/**/\n    65,\n/**/\n    64,\n/**/\n    63,\n/**/\n    62,\n/**/\n    61,\n/**/\n    60,\n/**/\n    59,\n/**/\n    58,\n/**/\n    57,\n/**/\n    56,\n/**/\n    55,\n/**/\n    54,\n/**/\n    53,\n/**/\n    52,\n/**/\n    51,\n/**/\n    50,\n/**/\n    49,\n/**/\n    48,\n/**/\n    47,\n/**/\n    46,\n/**/\n    45,\n/**/\n    44,\n/**/\n    43,\n/**/\n    42,\n/**/\n    41,\n/**/\n    40,\n/**/\n    39,\n/**/\n    38,\n/**/\n    37,\n/**/\n    36,\n/**/\n    35,\n/**/\n    34,\n/**/\n    33,\n/**/\n    32,\n/**/\n    31,\n/**/\n    30,\n/**/\n    29,\n/**/\n    28,\n/**/\n    27,\n/**/\n    26,\n/**/\n    25,\n/**/\n    24,\n/**/\n    23,\n/**/\n    22,\n/**/\n    21,\n/**/\n    20,\n/**/\n    19,\n/**/\n    18,\n/**/\n    17,\n/**/\n    16,\n/**/\n    15,\n/**/\n    14,\n/**/\n    13,\n/**/\n    12,\n/**/\n    11,\n/**/\n    10,\n/**/\n    9,\n/**/\n    8,\n/**/\n    7,\n/**/\n    6,\n/**/\n    5,\n/**/\n    4,\n/**/\n    3,\n/**/\n    2,\n/**/\n    1,\n/**/\n    0\n};\n\n/*\n * Place to put a short description when adding a feature with a patch.\n * Keep it short, e.g.,: \"relative numbers\", \"persistent undo\".\n * Also add a comment marker to separate the lines.\n * See the official Vim patches for the diff format: It must use a context of\n * one line only.  Create it by hand or use \"diff -C2\" and edit the patch.\n */\nstatic char *(extra_patches[]) =\n{   /* Add your patch description below this line */\n/**/\n    NULL\n};\n\n    int\nhighest_patch(void)\n{\n    // this relies on the highest patch number to be the first entry\n    return included_patches[0];\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return TRUE if patch \"n\" has been included.\n */\n    int\nhas_patch(int n)\n{\n    int\t\th, m, l;\n\n    // Perform a binary search.\n    l = 0;\n    h = (int)ARRAY_LENGTH(included_patches) - 1;\n    for (;;)\n    {\n\tm = (l + h) / 2;\n\tif (included_patches[m] == n)\n\t    return TRUE;\n\tif (l == h)\n\t    break;\n\tif (included_patches[m] < n)\n\t    h = m;\n\telse\n\t    l = m + 1;\n    }\n    return FALSE;\n}\n#endif\n\n    void\nex_version(exarg_T *eap)\n{\n    /*\n     * Ignore a \":version 9.99\" command.\n     */\n    if (*eap->arg == NUL)\n    {\n\tmsg_putchar('\\n');\n\tlist_version();\n    }\n}\n\n/*\n * Output a string for the version message.  If it's going to wrap, output a\n * newline, unless the message is too long to fit on the screen anyway.\n * When \"wrap\" is TRUE wrap the string in [].\n */\n    static void\nversion_msg_wrap(char_u *s, int wrap)\n{\n    int\t\tlen = vim_strsize(s) + (wrap ? 2 : 0);\n\n    if (!got_int && len < (int)Columns && msg_col + len >= (int)Columns\n\t\t\t\t\t\t\t\t&& *s != '\\n')\n\tmsg_putchar('\\n');\n    if (!got_int)\n    {\n\tif (wrap)\n\t    msg_puts(\"[\");\n\tmsg_puts((char *)s);\n\tif (wrap)\n\t    msg_puts(\"]\");\n    }\n}\n\n    static void\nversion_msg(char *s)\n{\n    version_msg_wrap((char_u *)s, FALSE);\n}\n\n/*\n * List all features aligned in columns, dictionary style.\n */\n    static void\nlist_features(void)\n{\n    list_in_columns((char_u **)features, -1, -1);\n}\n\n/*\n * List string items nicely aligned in columns.\n * When \"size\" is < 0 then the last entry is marked with NULL.\n * The entry with index \"current\" is inclosed in [].\n */\n    void\nlist_in_columns(char_u **items, int size, int current)\n{\n    int\t\ti;\n    int\t\tncol;\n    int\t\tnrow;\n    int\t\tcur_row = 1;\n    int\t\titem_count = 0;\n    int\t\twidth = 0;\n#ifdef FEAT_SYN_HL\n    int\t\tuse_highlight = (items == (char_u **)features);\n#endif\n\n    // Find the length of the longest item, use that + 1 as the column\n    // width.\n    for (i = 0; size < 0 ? items[i] != NULL : i < size; ++i)\n    {\n\tint l = vim_strsize(items[i]) + (i == current ? 2 : 0);\n\n\tif (l > width)\n\t    width = l;\n\t++item_count;\n    }\n    width += 1;\n\n    if (Columns < width)\n    {\n\t// Not enough screen columns - show one per line\n\tfor (i = 0; i < item_count; ++i)\n\t{\n\t    version_msg_wrap(items[i], i == current);\n\t    if (msg_col > 0 && i < item_count - 1)\n\t\tmsg_putchar('\\n');\n\t}\n\treturn;\n    }\n\n    // The rightmost column doesn't need a separator.\n    // Sacrifice it to fit in one more column if possible.\n    ncol = (int) (Columns + 1) / width;\n    nrow = item_count / ncol + ((item_count % ncol) ? 1 : 0);\n\n    // \"i\" counts columns then rows.  \"idx\" counts rows then columns.\n    for (i = 0; !got_int && i < nrow * ncol; ++i)\n    {\n\tint idx = (i / ncol) + (i % ncol) * nrow;\n\n\tif (idx < item_count)\n\t{\n\t    int last_col = (i + 1) % ncol == 0;\n\n\t    if (idx == current)\n\t\tmsg_putchar('[');\n#ifdef FEAT_SYN_HL\n\t    if (use_highlight && items[idx][0] == '-')\n\t\tmsg_puts_attr((char *)items[idx], HL_ATTR(HLF_W));\n\t    else\n#endif\n\t\tmsg_puts((char *)items[idx]);\n\t    if (idx == current)\n\t\tmsg_putchar(']');\n\t    if (last_col)\n\t    {\n\t\tif (msg_col > 0 && cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t    else\n\t    {\n\t\twhile (msg_col % width)\n\t\t    msg_putchar(' ');\n\t    }\n\t}\n\telse\n\t{\n\t    // this row is out of items, thus at the end of the row\n\t    if (msg_col > 0)\n\t    {\n\t\tif (cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t}\n    }\n}\n\n    void\nlist_version(void)\n{\n    int\t\ti;\n    int\t\tfirst;\n    char\t*s = \"\";\n\n    /*\n     * When adding features here, don't forget to update the list of\n     * internal variables in eval.c!\n     */\n    init_longVersion();\n    msg(longVersion);\n#ifdef MSWIN\n# ifdef FEAT_GUI_MSWIN\n#  ifdef VIMDLL\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI/console version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI/console version\"));\n#   endif\n#  else\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI version\"));\n#   endif\n#  endif\n#  ifdef FEAT_OLE\n    msg_puts(_(\" with OLE support\"));\n#  endif\n# else\n#  ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit console version\"));\n#  else\n    msg_puts(_(\"\\nMS-Windows 32-bit console version\"));\n#  endif\n# endif\n#endif\n#if defined(MACOS_X)\n# if defined(MACOS_X_DARWIN)\n    msg_puts(_(\"\\nmacOS version\"));\n# else\n    msg_puts(_(\"\\nmacOS version w/o darwin feat.\"));\n# endif\n# if defined(__arm64__)\n    msg_puts(\" - arm64\");\n# elif defined(__x86_64__)\n    msg_puts(\" - x86_64\");\n# endif\n#endif\n\n#ifdef VMS\n    msg_puts(_(\"\\nOpenVMS version\"));\n# ifdef HAVE_PATHDEF\n    if (*compiled_arch != NUL)\n    {\n\tmsg_puts(\" - \");\n\tmsg_puts((char *)compiled_arch);\n    }\n# endif\n\n#endif\n\n    // Print the list of patch numbers if there is at least one.\n    // Print a range when patches are consecutive: \"1-10, 12, 15-40, 42-45\"\n    if (included_patches[0] != 0)\n    {\n\tmsg_puts(_(\"\\nIncluded patches: \"));\n\tfirst = -1;\n\ti = (int)ARRAY_LENGTH(included_patches) - 1;\n\twhile (--i >= 0)\n\t{\n\t    if (first < 0)\n\t\tfirst = included_patches[i];\n\t    if (i == 0 || included_patches[i - 1] != included_patches[i] + 1)\n\t    {\n\t\tmsg_puts(s);\n\t\ts = \", \";\n\t\tmsg_outnum((long)first);\n\t\tif (first != included_patches[i])\n\t\t{\n\t\t    msg_puts(\"-\");\n\t\t    msg_outnum((long)included_patches[i]);\n\t\t}\n\t\tfirst = -1;\n\t    }\n\t}\n    }\n\n    // Print the list of extra patch descriptions if there is at least one.\n    if (extra_patches[0] != NULL)\n    {\n\tmsg_puts(_(\"\\nExtra patches: \"));\n\ts = \"\";\n\tfor (i = 0; extra_patches[i] != NULL; ++i)\n\t{\n\t    msg_puts(s);\n\t    s = \", \";\n\t    msg_puts(extra_patches[i]);\n\t}\n    }\n\n#ifdef MODIFIED_BY\n    msg_puts(\"\\n\");\n    msg_puts(_(\"Modified by \"));\n    msg_puts(MODIFIED_BY);\n#endif\n\n#ifdef HAVE_PATHDEF\n    if (*compiled_user != NUL || *compiled_sys != NUL)\n    {\n\tmsg_puts(_(\"\\nCompiled \"));\n\tif (*compiled_user != NUL)\n\t{\n\t    msg_puts(_(\"by \"));\n\t    msg_puts((char *)compiled_user);\n\t}\n\tif (*compiled_sys != NUL)\n\t{\n\t    msg_puts(\"@\");\n\t    msg_puts((char *)compiled_sys);\n\t}\n    }\n#endif\n\n#if defined(FEAT_HUGE)\n    msg_puts(_(\"\\nHuge version \"));\n#elif defined(FEAT_BIG)\n    msg_puts(_(\"\\nBig version \"));\n#elif defined(FEAT_NORMAL)\n    msg_puts(_(\"\\nNormal version \"));\n#elif defined(FEAT_SMALL)\n    msg_puts(_(\"\\nSmall version \"));\n#else\n    msg_puts(_(\"\\nTiny version \"));\n#endif\n#if !defined(FEAT_GUI)\n    msg_puts(_(\"without GUI.\"));\n#elif defined(FEAT_GUI_GTK)\n# if defined(USE_GTK3)\n    msg_puts(_(\"with GTK3 GUI.\"));\n# elif defined(FEAT_GUI_GNOME)\n     msg_puts(_(\"with GTK2-GNOME GUI.\"));\n# else\n     msg_puts(_(\"with GTK2 GUI.\"));\n# endif\n#elif defined(FEAT_GUI_MOTIF)\n    msg_puts(_(\"with X11-Motif GUI.\"));\n#elif defined(FEAT_GUI_HAIKU)\n    msg_puts(_(\"with Haiku GUI.\"));\n#elif defined(FEAT_GUI_PHOTON)\n    msg_puts(_(\"with Photon GUI.\"));\n#elif defined(MSWIN)\n    msg_puts(_(\"with GUI.\"));\n#endif\n    version_msg(_(\"  Features included (+) or not (-):\\n\"));\n\n    list_features();\n    if (msg_col > 0)\n\tmsg_putchar('\\n');\n\n#ifdef SYS_VIMRC_FILE\n    version_msg(_(\"   system vimrc file: \\\"\"));\n    version_msg(SYS_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE\n    version_msg(_(\"     user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE2\n    version_msg(_(\" 2nd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE3\n    version_msg(_(\" 3rd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE\n    version_msg(_(\"      user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE2\n    version_msg(_(\"  2nd user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef FEAT_GUI\n# ifdef SYS_GVIMRC_FILE\n    version_msg(_(\"  system gvimrc file: \\\"\"));\n    version_msg(SYS_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n    version_msg(_(\"    user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# ifdef USR_GVIMRC_FILE2\n    version_msg(_(\"2nd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n# endif\n# ifdef USR_GVIMRC_FILE3\n    version_msg(_(\"3rd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n    version_msg(_(\"       defaults file: \\\"\"));\n    version_msg(VIM_DEFAULTS_FILE);\n    version_msg(\"\\\"\\n\");\n#ifdef FEAT_GUI\n# ifdef SYS_MENU_FILE\n    version_msg(_(\"    system menu file: \\\"\"));\n    version_msg(SYS_MENU_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n#ifdef HAVE_PATHDEF\n    if (*default_vim_dir != NUL)\n    {\n\tversion_msg(_(\"  fall-back for $VIM: \\\"\"));\n\tversion_msg((char *)default_vim_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    if (*default_vimruntime_dir != NUL)\n    {\n\tversion_msg(_(\" f-b for $VIMRUNTIME: \\\"\"));\n\tversion_msg((char *)default_vimruntime_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    version_msg(_(\"Compilation: \"));\n    version_msg((char *)all_cflags);\n    version_msg(\"\\n\");\n#ifdef VMS\n    if (*compiler_version != NUL)\n    {\n\tversion_msg(_(\"Compiler: \"));\n\tversion_msg((char *)compiler_version);\n\tversion_msg(\"\\n\");\n    }\n#endif\n    version_msg(_(\"Linking: \"));\n    version_msg((char *)all_lflags);\n#endif\n#ifdef DEBUG\n    version_msg(\"\\n\");\n    version_msg(_(\"  DEBUG BUILD\"));\n#endif\n}\n\nstatic void do_intro_line(int row, char_u *mesg, int add_version, int attr);\nstatic void intro_message(int colon);\n\n/*\n * Show the intro message when not editing a file.\n */\n    void\nmaybe_intro_message(void)\n{\n    if (BUFEMPTY()\n\t    && curbuf->b_fname == NULL\n\t    && firstwin->w_next == NULL\n\t    && vim_strchr(p_shm, SHM_INTRO) == NULL)\n\tintro_message(FALSE);\n}\n\n/*\n * Give an introductory message about Vim.\n * Only used when starting Vim on an empty file, without a file name.\n * Or with the \":intro\" command (for Sven :-).\n */\n    static void\nintro_message(\n    int\t\tcolon)\t\t// TRUE for \":intro\"\n{\n    int\t\ti;\n    int\t\trow;\n    int\t\tblanklines;\n    int\t\tsponsor;\n    char\t*p;\n    static char\t*(lines[]) =\n    {\n\tN_(\"VIM - Vi IMproved\"),\n\t\"\",\n\tN_(\"version \"),\n\tN_(\"by Bram Moolenaar et al.\"),\n#ifdef MODIFIED_BY\n\t\" \",\n#endif\n\tN_(\"Vim is open source and freely distributable\"),\n\t\"\",\n\tN_(\"Help poor children in Uganda!\"),\n\tN_(\"type  :help iccf<Enter>       for information \"),\n\t\"\",\n\tN_(\"type  :q<Enter>               to exit         \"),\n\tN_(\"type  :help<Enter>  or  <F1>  for on-line help\"),\n\tN_(\"type  :help version9<Enter>   for version info\"),\n\tNULL,\n\t\"\",\n\tN_(\"Running in Vi compatible mode\"),\n\tN_(\"type  :set nocp<Enter>        for Vim defaults\"),\n\tN_(\"type  :help cp-default<Enter> for info on this\"),\n    };\n#ifdef FEAT_GUI\n    static char\t*(gui_lines[]) =\n    {\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n#ifdef MODIFIED_BY\n\tNULL,\n#endif\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Help->Orphans           for information    \"),\n\tNULL,\n\tN_(\"Running modeless, typed text is inserted\"),\n\tN_(\"menu  Edit->Global Settings->Toggle Insert Mode  \"),\n\tN_(\"                              for two modes      \"),\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Edit->Global Settings->Toggle Vi Compatible\"),\n\tN_(\"                              for Vim defaults   \"),\n    };\n#endif\n\n    // blanklines = screen height - # message lines\n    blanklines = (int)Rows - (ARRAY_LENGTH(lines) - 1);\n    if (!p_cp)\n\tblanklines += 4;  // add 4 for not showing \"Vi compatible\" message\n\n    // Don't overwrite a statusline.  Depends on 'cmdheight'.\n    if (p_ls > 1)\n\tblanklines -= Rows - topframe->fr_height;\n    if (blanklines < 0)\n\tblanklines = 0;\n\n    // Show the sponsor and register message one out of four times, the Uganda\n    // message two out of four times.\n    sponsor = (int)time(NULL);\n    sponsor = ((sponsor & 2) == 0) - ((sponsor & 4) == 0);\n\n    // start displaying the message lines after half of the blank lines\n    row = blanklines / 2;\n    if ((row >= 2 && Columns >= 50) || colon)\n    {\n\tfor (i = 0; i < (int)ARRAY_LENGTH(lines); ++i)\n\t{\n\t    p = lines[i];\n#ifdef FEAT_GUI\n\t    if (p_im && gui.in_use && gui_lines[i] != NULL)\n\t\tp = gui_lines[i];\n#endif\n\t    if (p == NULL)\n\t    {\n\t\tif (!p_cp)\n\t\t    break;\n\t\tcontinue;\n\t    }\n\t    if (sponsor != 0)\n\t    {\n\t\tif (strstr(p, \"children\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"Sponsor Vim development!\")\n\t\t\t: N_(\"Become a registered Vim user!\");\n\t\telse if (strstr(p, \"iccf\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"type  :help sponsor<Enter>    for information \")\n\t\t\t: N_(\"type  :help register<Enter>   for information \");\n\t\telse if (strstr(p, \"Orphans\") != NULL)\n\t\t    p = N_(\"menu  Help->Sponsor/Register  for information    \");\n\t    }\n\t    if (*p != NUL)\n\t\tdo_intro_line(row, (char_u *)_(p), i == 2, 0);\n\t    ++row;\n\t}\n    }\n\n    // Make the wait-return message appear just below the text.\n    if (colon)\n\tmsg_row = row;\n}\n\n    static void\ndo_intro_line(\n    int\t\trow,\n    char_u\t*mesg,\n    int\t\tadd_version,\n    int\t\tattr)\n{\n    char_u\tvers[20];\n    int\t\tcol;\n    char_u\t*p;\n    int\t\tl;\n    int\t\tclen;\n#ifdef MODIFIED_BY\n# define MODBY_LEN 150\n    char_u\tmodby[MODBY_LEN];\n\n    if (*mesg == ' ')\n    {\n\tvim_strncpy(modby, (char_u *)_(\"Modified by \"), MODBY_LEN - 1);\n\tl = (int)STRLEN(modby);\n\tvim_strncpy(modby + l, (char_u *)MODIFIED_BY, MODBY_LEN - l - 1);\n\tmesg = modby;\n    }\n#endif\n\n    // Center the message horizontally.\n    col = vim_strsize(mesg);\n    if (add_version)\n    {\n\tSTRCPY(vers, mediumVersion);\n\tif (highest_patch())\n\t{\n\t    // Check for 9.9x or 9.9xx, alpha/beta version\n\t    if (isalpha((int)vers[3]))\n\t    {\n\t\tint len = (isalpha((int)vers[4])) ? 5 : 4;\n\t\tsprintf((char *)vers + len, \".%d%s\", highest_patch(),\n\t\t\t\t\t\t\t mediumVersion + len);\n\t    }\n\t    else\n\t\tsprintf((char *)vers + 3, \".%d\", highest_patch());\n\t}\n\tcol += (int)STRLEN(vers);\n    }\n    col = (Columns - col) / 2;\n    if (col < 0)\n\tcol = 0;\n\n    // Split up in parts to highlight <> items differently.\n    for (p = mesg; *p != NUL; p += l)\n    {\n\tclen = 0;\n\tfor (l = 0; p[l] != NUL\n\t\t\t && (l == 0 || (p[l] != '<' && p[l - 1] != '>')); ++l)\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tclen += ptr2cells(p + l);\n\t\tl += (*mb_ptr2len)(p + l) - 1;\n\t    }\n\t    else\n\t\tclen += byte2cells(p[l]);\n\t}\n\tscreen_puts_len(p, l, row, col, *p == '<' ? HL_ATTR(HLF_8) : attr);\n\tcol += clen;\n    }\n\n    // Add the version number to the version line.\n    if (add_version)\n\tscreen_puts(vers, row, col, 0);\n}\n\n/*\n * \":intro\": clear screen, display intro screen and wait for return.\n */\n    void\nex_intro(exarg_T *eap UNUSED)\n{\n    screenclear();\n    intro_message(TRUE);\n    wait_return(TRUE);\n}\n"], "fixing_code": ["/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * Handling of regular expressions: vim_regcomp(), vim_regexec(), vim_regsub()\n */\n\n// By default: do not create debugging logs or files related to regular\n// expressions, even when compiling with -DDEBUG.\n// Uncomment the second line to get the regexp debugging.\n#undef DEBUG\n// #define DEBUG\n\n#include \"vim.h\"\n\n#ifdef DEBUG\n// show/save debugging data when BT engine is used\n# define BT_REGEXP_DUMP\n// save the debugging data to a file instead of displaying it\n# define BT_REGEXP_LOG\n# define BT_REGEXP_DEBUG_LOG\n# define BT_REGEXP_DEBUG_LOG_NAME\t\"bt_regexp_debug.log\"\n#endif\n\n#ifdef FEAT_RELTIME\nstatic sig_atomic_t dummy_timeout_flag = 0;\nstatic volatile sig_atomic_t *timeout_flag = &dummy_timeout_flag;\n#endif\n\n/*\n * Magic characters have a special meaning, they don't match literally.\n * Magic characters are negative.  This separates them from literal characters\n * (possibly multi-byte).  Only ASCII characters can be Magic.\n */\n#define Magic(x)\t((int)(x) - 256)\n#define un_Magic(x)\t((x) + 256)\n#define is_Magic(x)\t((x) < 0)\n\n    static int\nno_Magic(int x)\n{\n    if (is_Magic(x))\n\treturn un_Magic(x);\n    return x;\n}\n\n    static int\ntoggle_Magic(int x)\n{\n    if (is_Magic(x))\n\treturn un_Magic(x);\n    return Magic(x);\n}\n\n#ifdef FEAT_RELTIME\n    void\ninit_regexp_timeout(long msec)\n{\n    timeout_flag = start_timeout(msec);\n}\n\n    void\ndisable_regexp_timeout(void)\n{\n    stop_timeout();\n    timeout_flag = &dummy_timeout_flag;\n}\n#endif\n\n/*\n * The first byte of the BT regexp internal \"program\" is actually this magic\n * number; the start node begins in the second byte.  It's used to catch the\n * most severe mutilation of the program by the caller.\n */\n\n#define REGMAGIC\t0234\n\n/*\n * Utility definitions.\n */\n#define UCHARAT(p)\t((int)*(char_u *)(p))\n\n// Used for an error (down from) vim_regcomp(): give the error message, set\n// rc_did_emsg and return NULL\n#define EMSG_RET_NULL(m) return (emsg((m)), rc_did_emsg = TRUE, (void *)NULL)\n#define IEMSG_RET_NULL(m) return (iemsg((m)), rc_did_emsg = TRUE, (void *)NULL)\n#define EMSG_RET_FAIL(m) return (emsg((m)), rc_did_emsg = TRUE, FAIL)\n#define EMSG2_RET_NULL(m, c) return (semsg((const char *)(m), (c) ? \"\" : \"\\\\\"), rc_did_emsg = TRUE, (void *)NULL)\n#define EMSG3_RET_NULL(m, c, a) return (semsg((const char *)(m), (c) ? \"\" : \"\\\\\", (a)), rc_did_emsg = TRUE, (void *)NULL)\n#define EMSG2_RET_FAIL(m, c) return (semsg((const char *)(m), (c) ? \"\" : \"\\\\\"), rc_did_emsg = TRUE, FAIL)\n#define EMSG_ONE_RET_NULL EMSG2_RET_NULL(_(e_invalid_item_in_str_brackets), reg_magic == MAGIC_ALL)\n\n\n#define MAX_LIMIT\t(32767L << 16L)\n\n#define NOT_MULTI\t0\n#define MULTI_ONE\t1\n#define MULTI_MULT\t2\n\n// return values for regmatch()\n#define RA_FAIL\t\t1\t// something failed, abort\n#define RA_CONT\t\t2\t// continue in inner loop\n#define RA_BREAK\t3\t// break inner loop\n#define RA_MATCH\t4\t// successful match\n#define RA_NOMATCH\t5\t// didn't match\n\n/*\n * Return NOT_MULTI if c is not a \"multi\" operator.\n * Return MULTI_ONE if c is a single \"multi\" operator.\n * Return MULTI_MULT if c is a multi \"multi\" operator.\n */\n    static int\nre_multi_type(int c)\n{\n    if (c == Magic('@') || c == Magic('=') || c == Magic('?'))\n\treturn MULTI_ONE;\n    if (c == Magic('*') || c == Magic('+') || c == Magic('{'))\n\treturn MULTI_MULT;\n    return NOT_MULTI;\n}\n\nstatic char_u\t\t*reg_prev_sub = NULL;\n\n/*\n * REGEXP_INRANGE contains all characters which are always special in a []\n * range after '\\'.\n * REGEXP_ABBR contains all characters which act as abbreviations after '\\'.\n * These are:\n *  \\n\t- New line (NL).\n *  \\r\t- Carriage Return (CR).\n *  \\t\t- Tab (TAB).\n *  \\e\t- Escape (ESC).\n *  \\b\t- Backspace (Ctrl_H).\n *  \\d  - Character code in decimal, eg \\d123\n *  \\o\t- Character code in octal, eg \\o80\n *  \\x\t- Character code in hex, eg \\x4a\n *  \\u\t- Multibyte character code, eg \\u20ac\n *  \\U\t- Long multibyte character code, eg \\U12345678\n */\nstatic char_u REGEXP_INRANGE[] = \"]^-n\\\\\";\nstatic char_u REGEXP_ABBR[] = \"nrtebdoxuU\";\n\n/*\n * Translate '\\x' to its control character, except \"\\n\", which is Magic.\n */\n    static int\nbackslash_trans(int c)\n{\n    switch (c)\n    {\n\tcase 'r':   return CAR;\n\tcase 't':   return TAB;\n\tcase 'e':   return ESC;\n\tcase 'b':   return BS;\n    }\n    return c;\n}\n\n/*\n * Check for a character class name \"[:name:]\".  \"pp\" points to the '['.\n * Returns one of the CLASS_ items. CLASS_NONE means that no item was\n * recognized.  Otherwise \"pp\" is advanced to after the item.\n */\n    static int\nget_char_class(char_u **pp)\n{\n    static const char *(class_names[]) =\n    {\n\t\"alnum:]\",\n#define CLASS_ALNUM 0\n\t\"alpha:]\",\n#define CLASS_ALPHA 1\n\t\"blank:]\",\n#define CLASS_BLANK 2\n\t\"cntrl:]\",\n#define CLASS_CNTRL 3\n\t\"digit:]\",\n#define CLASS_DIGIT 4\n\t\"graph:]\",\n#define CLASS_GRAPH 5\n\t\"lower:]\",\n#define CLASS_LOWER 6\n\t\"print:]\",\n#define CLASS_PRINT 7\n\t\"punct:]\",\n#define CLASS_PUNCT 8\n\t\"space:]\",\n#define CLASS_SPACE 9\n\t\"upper:]\",\n#define CLASS_UPPER 10\n\t\"xdigit:]\",\n#define CLASS_XDIGIT 11\n\t\"tab:]\",\n#define CLASS_TAB 12\n\t\"return:]\",\n#define CLASS_RETURN 13\n\t\"backspace:]\",\n#define CLASS_BACKSPACE 14\n\t\"escape:]\",\n#define CLASS_ESCAPE 15\n\t\"ident:]\",\n#define CLASS_IDENT 16\n\t\"keyword:]\",\n#define CLASS_KEYWORD 17\n\t\"fname:]\",\n#define CLASS_FNAME 18\n    };\n#define CLASS_NONE 99\n    int i;\n\n    if ((*pp)[1] == ':')\n    {\n\tfor (i = 0; i < (int)ARRAY_LENGTH(class_names); ++i)\n\t    if (STRNCMP(*pp + 2, class_names[i], STRLEN(class_names[i])) == 0)\n\t    {\n\t\t*pp += STRLEN(class_names[i]) + 2;\n\t\treturn i;\n\t    }\n    }\n    return CLASS_NONE;\n}\n\n/*\n * Specific version of character class functions.\n * Using a table to keep this fast.\n */\nstatic short\tclass_tab[256];\n\n#define\t    RI_DIGIT\t0x01\n#define\t    RI_HEX\t0x02\n#define\t    RI_OCTAL\t0x04\n#define\t    RI_WORD\t0x08\n#define\t    RI_HEAD\t0x10\n#define\t    RI_ALPHA\t0x20\n#define\t    RI_LOWER\t0x40\n#define\t    RI_UPPER\t0x80\n#define\t    RI_WHITE\t0x100\n\n    static void\ninit_class_tab(void)\n{\n    int\t\ti;\n    static int\tdone = FALSE;\n\n    if (done)\n\treturn;\n\n    for (i = 0; i < 256; ++i)\n    {\n\tif (i >= '0' && i <= '7')\n\t    class_tab[i] = RI_DIGIT + RI_HEX + RI_OCTAL + RI_WORD;\n\telse if (i >= '8' && i <= '9')\n\t    class_tab[i] = RI_DIGIT + RI_HEX + RI_WORD;\n\telse if (i >= 'a' && i <= 'f')\n\t    class_tab[i] = RI_HEX + RI_WORD + RI_HEAD + RI_ALPHA + RI_LOWER;\n\telse if (i >= 'g' && i <= 'z')\n\t    class_tab[i] = RI_WORD + RI_HEAD + RI_ALPHA + RI_LOWER;\n\telse if (i >= 'A' && i <= 'F')\n\t    class_tab[i] = RI_HEX + RI_WORD + RI_HEAD + RI_ALPHA + RI_UPPER;\n\telse if (i >= 'G' && i <= 'Z')\n\t    class_tab[i] = RI_WORD + RI_HEAD + RI_ALPHA + RI_UPPER;\n\telse if (i == '_')\n\t    class_tab[i] = RI_WORD + RI_HEAD;\n\telse\n\t    class_tab[i] = 0;\n    }\n    class_tab[' '] |= RI_WHITE;\n    class_tab['\\t'] |= RI_WHITE;\n    done = TRUE;\n}\n\n#define ri_digit(c)\t((c) < 0x100 && (class_tab[c] & RI_DIGIT))\n#define ri_hex(c)\t((c) < 0x100 && (class_tab[c] & RI_HEX))\n#define ri_octal(c)\t((c) < 0x100 && (class_tab[c] & RI_OCTAL))\n#define ri_word(c)\t((c) < 0x100 && (class_tab[c] & RI_WORD))\n#define ri_head(c)\t((c) < 0x100 && (class_tab[c] & RI_HEAD))\n#define ri_alpha(c)\t((c) < 0x100 && (class_tab[c] & RI_ALPHA))\n#define ri_lower(c)\t((c) < 0x100 && (class_tab[c] & RI_LOWER))\n#define ri_upper(c)\t((c) < 0x100 && (class_tab[c] & RI_UPPER))\n#define ri_white(c)\t((c) < 0x100 && (class_tab[c] & RI_WHITE))\n\n// flags for regflags\n#define RF_ICASE    1\t// ignore case\n#define RF_NOICASE  2\t// don't ignore case\n#define RF_HASNL    4\t// can match a NL\n#define RF_ICOMBINE 8\t// ignore combining characters\n#define RF_LOOKBH   16\t// uses \"\\@<=\" or \"\\@<!\"\n\n/*\n * Global work variables for vim_regcomp().\n */\n\nstatic char_u\t*regparse;\t// Input-scan pointer.\nstatic int\tregnpar;\t// () count.\nstatic int\twants_nfa;\t// regex should use NFA engine\n#ifdef FEAT_SYN_HL\nstatic int\tregnzpar;\t// \\z() count.\nstatic int\tre_has_z;\t// \\z item detected\n#endif\nstatic unsigned\tregflags;\t// RF_ flags for prog\n#if defined(FEAT_SYN_HL) || defined(PROTO)\nstatic int\thad_eol;\t// TRUE when EOL found by vim_regcomp()\n#endif\n\nstatic magic_T\treg_magic;\t// magicness of the pattern\n\nstatic int\treg_string;\t// matching with a string instead of a buffer\n\t\t\t\t// line\nstatic int\treg_strict;\t// \"[abc\" is illegal\n\n/*\n * META contains all characters that may be magic, except '^' and '$'.\n */\n\n// META[] is used often enough to justify turning it into a table.\nstatic char_u META_flags[] = {\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n//\t\t   %  &     (  )  *  +\t      .\n    0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 1, 0,\n//     1  2  3\t4  5  6  7  8  9\t<  =  >  ?\n    0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1,\n//  @  A     C\tD     F     H  I     K\tL  M\t O\n    1, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 0, 1,\n//  P\t     S\t   U  V  W  X\t  Z  [\t\t _\n    1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1,\n//     a     c\td     f     h  i     k\tl  m  n  o\n    0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1,\n//  p\t     s\t   u  v  w  x\t  z  {\t|     ~\n    1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1\n};\n\nstatic int\tcurchr;\t\t// currently parsed character\n// Previous character.  Note: prevchr is sometimes -1 when we are not at the\n// start, eg in /[ ^I]^ the pattern was never found even if it existed,\n// because ^ was taken to be magic -- webb\nstatic int\tprevchr;\nstatic int\tprevprevchr;\t// previous-previous character\nstatic int\tnextchr;\t// used for ungetchr()\n\n// arguments for reg()\n#define REG_NOPAREN\t0\t// toplevel reg()\n#define REG_PAREN\t1\t// \\(\\)\n#define REG_ZPAREN\t2\t// \\z(\\)\n#define REG_NPAREN\t3\t// \\%(\\)\n\ntypedef struct\n{\n     char_u\t*regparse;\n     int\tprevchr_len;\n     int\tcurchr;\n     int\tprevchr;\n     int\tprevprevchr;\n     int\tnextchr;\n     int\tat_start;\n     int\tprev_at_start;\n     int\tregnpar;\n} parse_state_T;\n\nstatic void\tinitchr(char_u *);\nstatic int\tgetchr(void);\nstatic void\tskipchr_keepstart(void);\nstatic int\tpeekchr(void);\nstatic void\tskipchr(void);\nstatic void\tungetchr(void);\nstatic long\tgethexchrs(int maxinputlen);\nstatic long\tgetoctchrs(void);\nstatic long\tgetdecchrs(void);\nstatic int\tcoll_get_char(void);\nstatic int\tprog_magic_wrong(void);\nstatic int\tcstrncmp(char_u *s1, char_u *s2, int *n);\nstatic char_u\t*cstrchr(char_u *, int);\nstatic int\tre_mult_next(char *what);\nstatic int\treg_iswordc(int);\n#ifdef FEAT_EVAL\nstatic void report_re_switch(char_u *pat);\n#endif\n\nstatic regengine_T bt_regengine;\nstatic regengine_T nfa_regengine;\n\n/*\n * Return TRUE if compiled regular expression \"prog\" can match a line break.\n */\n    int\nre_multiline(regprog_T *prog)\n{\n    return (prog->regflags & RF_HASNL);\n}\n\n/*\n * Check for an equivalence class name \"[=a=]\".  \"pp\" points to the '['.\n * Returns a character representing the class. Zero means that no item was\n * recognized.  Otherwise \"pp\" is advanced to after the item.\n */\n    static int\nget_equi_class(char_u **pp)\n{\n    int\t\tc;\n    int\t\tl = 1;\n    char_u\t*p = *pp;\n\n    if (p[1] == '=' && p[2] != NUL)\n    {\n\tif (has_mbyte)\n\t    l = (*mb_ptr2len)(p + 2);\n\tif (p[l + 2] == '=' && p[l + 3] == ']')\n\t{\n\t    if (has_mbyte)\n\t\tc = mb_ptr2char(p + 2);\n\t    else\n\t\tc = p[2];\n\t    *pp += l + 4;\n\t    return c;\n\t}\n    }\n    return 0;\n}\n\n/*\n * Check for a collating element \"[.a.]\".  \"pp\" points to the '['.\n * Returns a character. Zero means that no item was recognized.  Otherwise\n * \"pp\" is advanced to after the item.\n * Currently only single characters are recognized!\n */\n    static int\nget_coll_element(char_u **pp)\n{\n    int\t\tc;\n    int\t\tl = 1;\n    char_u\t*p = *pp;\n\n    if (p[0] != NUL && p[1] == '.' && p[2] != NUL)\n    {\n\tif (has_mbyte)\n\t    l = (*mb_ptr2len)(p + 2);\n\tif (p[l + 2] == '.' && p[l + 3] == ']')\n\t{\n\t    if (has_mbyte)\n\t\tc = mb_ptr2char(p + 2);\n\t    else\n\t\tc = p[2];\n\t    *pp += l + 4;\n\t    return c;\n\t}\n    }\n    return 0;\n}\n\nstatic int reg_cpo_lit; // 'cpoptions' contains 'l' flag\nstatic int reg_cpo_bsl; // 'cpoptions' contains '\\' flag\n\n    static void\nget_cpo_flags(void)\n{\n    reg_cpo_lit = vim_strchr(p_cpo, CPO_LITERAL) != NULL;\n    reg_cpo_bsl = vim_strchr(p_cpo, CPO_BACKSL) != NULL;\n}\n\n/*\n * Skip over a \"[]\" range.\n * \"p\" must point to the character after the '['.\n * The returned pointer is on the matching ']', or the terminating NUL.\n */\n    static char_u *\nskip_anyof(char_u *p)\n{\n    int\t\tl;\n\n    if (*p == '^')\t// Complement of range.\n\t++p;\n    if (*p == ']' || *p == '-')\n\t++p;\n    while (*p != NUL && *p != ']')\n    {\n\tif (has_mbyte && (l = (*mb_ptr2len)(p)) > 1)\n\t    p += l;\n\telse\n\t    if (*p == '-')\n\t    {\n\t\t++p;\n\t\tif (*p != ']' && *p != NUL)\n\t\t    MB_PTR_ADV(p);\n\t    }\n\telse if (*p == '\\\\'\n\t\t&& !reg_cpo_bsl\n\t\t&& (vim_strchr(REGEXP_INRANGE, p[1]) != NULL\n\t\t    || (!reg_cpo_lit && vim_strchr(REGEXP_ABBR, p[1]) != NULL)))\n\t    p += 2;\n\telse if (*p == '[')\n\t{\n\t    if (get_char_class(&p) == CLASS_NONE\n\t\t    && get_equi_class(&p) == 0\n\t\t    && get_coll_element(&p) == 0\n\t\t    && *p != NUL)\n\t\t++p; // it is not a class name and not NUL\n\t}\n\telse\n\t    ++p;\n    }\n\n    return p;\n}\n\n/*\n * Skip past regular expression.\n * Stop at end of \"startp\" or where \"delim\" is found ('/', '?', etc).\n * Take care of characters with a backslash in front of it.\n * Skip strings inside [ and ].\n */\n    char_u *\nskip_regexp(\n    char_u\t*startp,\n    int\t\tdelim,\n    int\t\tmagic)\n{\n    return skip_regexp_ex(startp, delim, magic, NULL, NULL, NULL);\n}\n\n/*\n * Call skip_regexp() and when the delimiter does not match give an error and\n * return NULL.\n */\n    char_u *\nskip_regexp_err(\n    char_u\t*startp,\n    int\t\tdelim,\n    int\t\tmagic)\n{\n    char_u *p = skip_regexp(startp, delim, magic);\n\n    if (*p != delim)\n    {\n\tsemsg(_(e_missing_delimiter_after_search_pattern_str), startp);\n\treturn NULL;\n    }\n    return p;\n}\n\n/*\n * skip_regexp() with extra arguments:\n * When \"newp\" is not NULL and \"dirc\" is '?', make an allocated copy of the\n * expression and change \"\\?\" to \"?\".  If \"*newp\" is not NULL the expression\n * is changed in-place.\n * If a \"\\?\" is changed to \"?\" then \"dropped\" is incremented, unless NULL.\n * If \"magic_val\" is not NULL, returns the effective magicness of the pattern\n */\n    char_u *\nskip_regexp_ex(\n    char_u\t*startp,\n    int\t\tdirc,\n    int\t\tmagic,\n    char_u\t**newp,\n    int\t\t*dropped,\n    magic_T\t*magic_val)\n{\n    magic_T\tmymagic;\n    char_u\t*p = startp;\n\n    if (magic)\n\tmymagic = MAGIC_ON;\n    else\n\tmymagic = MAGIC_OFF;\n    get_cpo_flags();\n\n    for (; p[0] != NUL; MB_PTR_ADV(p))\n    {\n\tif (p[0] == dirc)\t// found end of regexp\n\t    break;\n\tif ((p[0] == '[' && mymagic >= MAGIC_ON)\n\t\t|| (p[0] == '\\\\' && p[1] == '[' && mymagic <= MAGIC_OFF))\n\t{\n\t    p = skip_anyof(p + 1);\n\t    if (p[0] == NUL)\n\t\tbreak;\n\t}\n\telse if (p[0] == '\\\\' && p[1] != NUL)\n\t{\n\t    if (dirc == '?' && newp != NULL && p[1] == '?')\n\t    {\n\t\t// change \"\\?\" to \"?\", make a copy first.\n\t\tif (*newp == NULL)\n\t\t{\n\t\t    *newp = vim_strsave(startp);\n\t\t    if (*newp != NULL)\n\t\t\tp = *newp + (p - startp);\n\t\t}\n\t\tif (dropped != NULL)\n\t\t    ++*dropped;\n\t\tif (*newp != NULL)\n\t\t    STRMOVE(p, p + 1);\n\t\telse\n\t\t    ++p;\n\t    }\n\t    else\n\t\t++p;    // skip next character\n\t    if (*p == 'v')\n\t\tmymagic = MAGIC_ALL;\n\t    else if (*p == 'V')\n\t\tmymagic = MAGIC_NONE;\n\t}\n    }\n    if (magic_val != NULL)\n\t*magic_val = mymagic;\n    return p;\n}\n\n/*\n * Functions for getting characters from the regexp input.\n */\nstatic int\tprevchr_len;\t// byte length of previous char\nstatic int\tat_start;\t// True when on the first character\nstatic int\tprev_at_start;  // True when on the second character\n\n/*\n * Start parsing at \"str\".\n */\n    static void\ninitchr(char_u *str)\n{\n    regparse = str;\n    prevchr_len = 0;\n    curchr = prevprevchr = prevchr = nextchr = -1;\n    at_start = TRUE;\n    prev_at_start = FALSE;\n}\n\n/*\n * Save the current parse state, so that it can be restored and parsing\n * starts in the same state again.\n */\n    static void\nsave_parse_state(parse_state_T *ps)\n{\n    ps->regparse = regparse;\n    ps->prevchr_len = prevchr_len;\n    ps->curchr = curchr;\n    ps->prevchr = prevchr;\n    ps->prevprevchr = prevprevchr;\n    ps->nextchr = nextchr;\n    ps->at_start = at_start;\n    ps->prev_at_start = prev_at_start;\n    ps->regnpar = regnpar;\n}\n\n/*\n * Restore a previously saved parse state.\n */\n    static void\nrestore_parse_state(parse_state_T *ps)\n{\n    regparse = ps->regparse;\n    prevchr_len = ps->prevchr_len;\n    curchr = ps->curchr;\n    prevchr = ps->prevchr;\n    prevprevchr = ps->prevprevchr;\n    nextchr = ps->nextchr;\n    at_start = ps->at_start;\n    prev_at_start = ps->prev_at_start;\n    regnpar = ps->regnpar;\n}\n\n\n/*\n * Get the next character without advancing.\n */\n    static int\npeekchr(void)\n{\n    static int\tafter_slash = FALSE;\n\n    if (curchr == -1)\n    {\n\tswitch (curchr = regparse[0])\n\t{\n\tcase '.':\n\tcase '[':\n\tcase '~':\n\t    // magic when 'magic' is on\n\t    if (reg_magic >= MAGIC_ON)\n\t\tcurchr = Magic(curchr);\n\t    break;\n\tcase '(':\n\tcase ')':\n\tcase '{':\n\tcase '%':\n\tcase '+':\n\tcase '=':\n\tcase '?':\n\tcase '@':\n\tcase '!':\n\tcase '&':\n\tcase '|':\n\tcase '<':\n\tcase '>':\n\tcase '#':\t// future ext.\n\tcase '\"':\t// future ext.\n\tcase '\\'':\t// future ext.\n\tcase ',':\t// future ext.\n\tcase '-':\t// future ext.\n\tcase ':':\t// future ext.\n\tcase ';':\t// future ext.\n\tcase '`':\t// future ext.\n\tcase '/':\t// Can't be used in / command\n\t    // magic only after \"\\v\"\n\t    if (reg_magic == MAGIC_ALL)\n\t\tcurchr = Magic(curchr);\n\t    break;\n\tcase '*':\n\t    // * is not magic as the very first character, eg \"?*ptr\", when\n\t    // after '^', eg \"/^*ptr\" and when after \"\\(\", \"\\|\", \"\\&\".  But\n\t    // \"\\(\\*\" is not magic, thus must be magic if \"after_slash\"\n\t    if (reg_magic >= MAGIC_ON\n\t\t    && !at_start\n\t\t    && !(prev_at_start && prevchr == Magic('^'))\n\t\t    && (after_slash\n\t\t\t|| (prevchr != Magic('(')\n\t\t\t    && prevchr != Magic('&')\n\t\t\t    && prevchr != Magic('|'))))\n\t\tcurchr = Magic('*');\n\t    break;\n\tcase '^':\n\t    // '^' is only magic as the very first character and if it's after\n\t    // \"\\(\", \"\\|\", \"\\&' or \"\\n\"\n\t    if (reg_magic >= MAGIC_OFF\n\t\t    && (at_start\n\t\t\t|| reg_magic == MAGIC_ALL\n\t\t\t|| prevchr == Magic('(')\n\t\t\t|| prevchr == Magic('|')\n\t\t\t|| prevchr == Magic('&')\n\t\t\t|| prevchr == Magic('n')\n\t\t\t|| (no_Magic(prevchr) == '('\n\t\t\t    && prevprevchr == Magic('%'))))\n\t    {\n\t\tcurchr = Magic('^');\n\t\tat_start = TRUE;\n\t\tprev_at_start = FALSE;\n\t    }\n\t    break;\n\tcase '$':\n\t    // '$' is only magic as the very last char and if it's in front of\n\t    // either \"\\|\", \"\\)\", \"\\&\", or \"\\n\"\n\t    if (reg_magic >= MAGIC_OFF)\n\t    {\n\t\tchar_u *p = regparse + 1;\n\t\tint is_magic_all = (reg_magic == MAGIC_ALL);\n\n\t\t// ignore \\c \\C \\m \\M \\v \\V and \\Z after '$'\n\t\twhile (p[0] == '\\\\' && (p[1] == 'c' || p[1] == 'C'\n\t\t\t\t|| p[1] == 'm' || p[1] == 'M'\n\t\t\t\t|| p[1] == 'v' || p[1] == 'V' || p[1] == 'Z'))\n\t\t{\n\t\t    if (p[1] == 'v')\n\t\t\tis_magic_all = TRUE;\n\t\t    else if (p[1] == 'm' || p[1] == 'M' || p[1] == 'V')\n\t\t\tis_magic_all = FALSE;\n\t\t    p += 2;\n\t\t}\n\t\tif (p[0] == NUL\n\t\t\t|| (p[0] == '\\\\'\n\t\t\t    && (p[1] == '|' || p[1] == '&' || p[1] == ')'\n\t\t\t\t|| p[1] == 'n'))\n\t\t\t|| (is_magic_all\n\t\t\t       && (p[0] == '|' || p[0] == '&' || p[0] == ')'))\n\t\t\t|| reg_magic == MAGIC_ALL)\n\t\t    curchr = Magic('$');\n\t    }\n\t    break;\n\tcase '\\\\':\n\t    {\n\t\tint c = regparse[1];\n\n\t\tif (c == NUL)\n\t\t    curchr = '\\\\';\t// trailing '\\'\n\t\telse if (c <= '~' && META_flags[c])\n\t\t{\n\t\t    /*\n\t\t     * META contains everything that may be magic sometimes,\n\t\t     * except ^ and $ (\"\\^\" and \"\\$\" are only magic after\n\t\t     * \"\\V\").  We now fetch the next character and toggle its\n\t\t     * magicness.  Therefore, \\ is so meta-magic that it is\n\t\t     * not in META.\n\t\t     */\n\t\t    curchr = -1;\n\t\t    prev_at_start = at_start;\n\t\t    at_start = FALSE;\t// be able to say \"/\\*ptr\"\n\t\t    ++regparse;\n\t\t    ++after_slash;\n\t\t    peekchr();\n\t\t    --regparse;\n\t\t    --after_slash;\n\t\t    curchr = toggle_Magic(curchr);\n\t\t}\n\t\telse if (vim_strchr(REGEXP_ABBR, c))\n\t\t{\n\t\t    /*\n\t\t     * Handle abbreviations, like \"\\t\" for TAB -- webb\n\t\t     */\n\t\t    curchr = backslash_trans(c);\n\t\t}\n\t\telse if (reg_magic == MAGIC_NONE && (c == '$' || c == '^'))\n\t\t    curchr = toggle_Magic(c);\n\t\telse\n\t\t{\n\t\t    /*\n\t\t     * Next character can never be (made) magic?\n\t\t     * Then backslashing it won't do anything.\n\t\t     */\n\t\t    if (has_mbyte)\n\t\t\tcurchr = (*mb_ptr2char)(regparse + 1);\n\t\t    else\n\t\t\tcurchr = c;\n\t\t}\n\t\tbreak;\n\t    }\n\n\tdefault:\n\t    if (has_mbyte)\n\t\tcurchr = (*mb_ptr2char)(regparse);\n\t}\n    }\n\n    return curchr;\n}\n\n/*\n * Eat one lexed character.  Do this in a way that we can undo it.\n */\n    static void\nskipchr(void)\n{\n    // peekchr() eats a backslash, do the same here\n    if (*regparse == '\\\\')\n\tprevchr_len = 1;\n    else\n\tprevchr_len = 0;\n    if (regparse[prevchr_len] != NUL)\n    {\n\tif (enc_utf8)\n\t    // exclude composing chars that mb_ptr2len does include\n\t    prevchr_len += utf_ptr2len(regparse + prevchr_len);\n\telse if (has_mbyte)\n\t    prevchr_len += (*mb_ptr2len)(regparse + prevchr_len);\n\telse\n\t    ++prevchr_len;\n    }\n    regparse += prevchr_len;\n    prev_at_start = at_start;\n    at_start = FALSE;\n    prevprevchr = prevchr;\n    prevchr = curchr;\n    curchr = nextchr;\t    // use previously unget char, or -1\n    nextchr = -1;\n}\n\n/*\n * Skip a character while keeping the value of prev_at_start for at_start.\n * prevchr and prevprevchr are also kept.\n */\n    static void\nskipchr_keepstart(void)\n{\n    int as = prev_at_start;\n    int pr = prevchr;\n    int prpr = prevprevchr;\n\n    skipchr();\n    at_start = as;\n    prevchr = pr;\n    prevprevchr = prpr;\n}\n\n/*\n * Get the next character from the pattern. We know about magic and such, so\n * therefore we need a lexical analyzer.\n */\n    static int\ngetchr(void)\n{\n    int chr = peekchr();\n\n    skipchr();\n    return chr;\n}\n\n/*\n * put character back.  Works only once!\n */\n    static void\nungetchr(void)\n{\n    nextchr = curchr;\n    curchr = prevchr;\n    prevchr = prevprevchr;\n    at_start = prev_at_start;\n    prev_at_start = FALSE;\n\n    // Backup regparse, so that it's at the same position as before the\n    // getchr().\n    regparse -= prevchr_len;\n}\n\n/*\n * Get and return the value of the hex string at the current position.\n * Return -1 if there is no valid hex number.\n * The position is updated:\n *     blahblah\\%x20asdf\n *\t   before-^ ^-after\n * The parameter controls the maximum number of input characters. This will be\n * 2 when reading a \\%x20 sequence and 4 when reading a \\%u20AC sequence.\n */\n    static long\ngethexchrs(int maxinputlen)\n{\n    long_u\tnr = 0;\n    int\t\tc;\n    int\t\ti;\n\n    for (i = 0; i < maxinputlen; ++i)\n    {\n\tc = regparse[0];\n\tif (!vim_isxdigit(c))\n\t    break;\n\tnr <<= 4;\n\tnr |= hex2nr(c);\n\t++regparse;\n    }\n\n    if (i == 0)\n\treturn -1;\n    return (long)nr;\n}\n\n/*\n * Get and return the value of the decimal string immediately after the\n * current position. Return -1 for invalid.  Consumes all digits.\n */\n    static long\ngetdecchrs(void)\n{\n    long_u\tnr = 0;\n    int\t\tc;\n    int\t\ti;\n\n    for (i = 0; ; ++i)\n    {\n\tc = regparse[0];\n\tif (c < '0' || c > '9')\n\t    break;\n\tnr *= 10;\n\tnr += c - '0';\n\t++regparse;\n\tcurchr = -1; // no longer valid\n    }\n\n    if (i == 0)\n\treturn -1;\n    return (long)nr;\n}\n\n/*\n * get and return the value of the octal string immediately after the current\n * position. Return -1 for invalid, or 0-255 for valid. Smart enough to handle\n * numbers > 377 correctly (for example, 400 is treated as 40) and doesn't\n * treat 8 or 9 as recognised characters. Position is updated:\n *     blahblah\\%o210asdf\n *\t   before-^  ^-after\n */\n    static long\ngetoctchrs(void)\n{\n    long_u\tnr = 0;\n    int\t\tc;\n    int\t\ti;\n\n    for (i = 0; i < 3 && nr < 040; ++i)\n    {\n\tc = regparse[0];\n\tif (c < '0' || c > '7')\n\t    break;\n\tnr <<= 3;\n\tnr |= hex2nr(c);\n\t++regparse;\n    }\n\n    if (i == 0)\n\treturn -1;\n    return (long)nr;\n}\n\n/*\n * read_limits - Read two integers to be taken as a minimum and maximum.\n * If the first character is '-', then the range is reversed.\n * Should end with 'end'.  If minval is missing, zero is default, if maxval is\n * missing, a very big number is the default.\n */\n    static int\nread_limits(long *minval, long *maxval)\n{\n    int\t\treverse = FALSE;\n    char_u\t*first_char;\n    long\ttmp;\n\n    if (*regparse == '-')\n    {\n\t// Starts with '-', so reverse the range later\n\tregparse++;\n\treverse = TRUE;\n    }\n    first_char = regparse;\n    *minval = getdigits(&regparse);\n    if (*regparse == ',')\t    // There is a comma\n    {\n\tif (vim_isdigit(*++regparse))\n\t    *maxval = getdigits(&regparse);\n\telse\n\t    *maxval = MAX_LIMIT;\n    }\n    else if (VIM_ISDIGIT(*first_char))\n\t*maxval = *minval;\t    // It was \\{n} or \\{-n}\n    else\n\t*maxval = MAX_LIMIT;\t    // It was \\{} or \\{-}\n    if (*regparse == '\\\\')\n\tregparse++;\t// Allow either \\{...} or \\{...\\}\n    if (*regparse != '}')\n\tEMSG2_RET_FAIL(_(e_syntax_error_in_str_curlies),\n\t\t\t\t\t\t       reg_magic == MAGIC_ALL);\n\n    /*\n     * Reverse the range if there was a '-', or make sure it is in the right\n     * order otherwise.\n     */\n    if ((!reverse && *minval > *maxval) || (reverse && *minval < *maxval))\n    {\n\ttmp = *minval;\n\t*minval = *maxval;\n\t*maxval = tmp;\n    }\n    skipchr();\t\t// let's be friends with the lexer again\n    return OK;\n}\n\n/*\n * vim_regexec and friends\n */\n\n/*\n * Global work variables for vim_regexec().\n */\n\nstatic void\tcleanup_subexpr(void);\n#ifdef FEAT_SYN_HL\nstatic void\tcleanup_zsubexpr(void);\n#endif\nstatic void\treg_nextline(void);\nstatic int\tmatch_with_backref(linenr_T start_lnum, colnr_T start_col, linenr_T end_lnum, colnr_T end_col, int *bytelen);\n\n/*\n * Sometimes need to save a copy of a line.  Since alloc()/free() is very\n * slow, we keep one allocated piece of memory and only re-allocate it when\n * it's too small.  It's freed in bt_regexec_both() when finished.\n */\nstatic char_u\t*reg_tofree = NULL;\nstatic unsigned\treg_tofreelen;\n\n/*\n * Structure used to store the execution state of the regex engine.\n * Which ones are set depends on whether a single-line or multi-line match is\n * done:\n *\t\t\tsingle-line\t\tmulti-line\n * reg_match\t\t&regmatch_T\t\tNULL\n * reg_mmatch\t\tNULL\t\t\t&regmmatch_T\n * reg_startp\t\treg_match->startp\t<invalid>\n * reg_endp\t\treg_match->endp\t\t<invalid>\n * reg_startpos\t\t<invalid>\t\treg_mmatch->startpos\n * reg_endpos\t\t<invalid>\t\treg_mmatch->endpos\n * reg_win\t\tNULL\t\t\twindow in which to search\n * reg_buf\t\tcurbuf\t\t\tbuffer in which to search\n * reg_firstlnum\t<invalid>\t\tfirst line in which to search\n * reg_maxline\t\t0\t\t\tlast line nr\n * reg_line_lbr\t\tFALSE or TRUE\t\tFALSE\n */\ntypedef struct {\n    regmatch_T\t\t*reg_match;\n    regmmatch_T\t\t*reg_mmatch;\n    char_u\t\t**reg_startp;\n    char_u\t\t**reg_endp;\n    lpos_T\t\t*reg_startpos;\n    lpos_T\t\t*reg_endpos;\n    win_T\t\t*reg_win;\n    buf_T\t\t*reg_buf;\n    linenr_T\t\treg_firstlnum;\n    linenr_T\t\treg_maxline;\n    int\t\t\treg_line_lbr;\t// \"\\n\" in string is line break\n\n    // The current match-position is stord in these variables:\n    linenr_T\tlnum;\t\t// line number, relative to first line\n    char_u\t*line;\t\t// start of current line\n    char_u\t*input;\t\t// current input, points into \"line\"\n\n    int\tneed_clear_subexpr;\t// subexpressions still need to be cleared\n#ifdef FEAT_SYN_HL\n    int\tneed_clear_zsubexpr;\t// extmatch subexpressions still need to be\n\t\t\t\t// cleared\n#endif\n\n    // Internal copy of 'ignorecase'.  It is set at each call to vim_regexec().\n    // Normally it gets the value of \"rm_ic\" or \"rmm_ic\", but when the pattern\n    // contains '\\c' or '\\C' the value is overruled.\n    int\t\t\treg_ic;\n\n    // Similar to \"reg_ic\", but only for 'combining' characters.  Set with \\Z\n    // flag in the regexp.  Defaults to false, always.\n    int\t\t\treg_icombine;\n\n    // Copy of \"rmm_maxcol\": maximum column to search for a match.  Zero when\n    // there is no maximum.\n    colnr_T\t\treg_maxcol;\n\n    // State for the NFA engine regexec.\n    int nfa_has_zend;\t    // NFA regexp \\ze operator encountered.\n    int nfa_has_backref;    // NFA regexp \\1 .. \\9 encountered.\n    int nfa_nsubexpr;\t    // Number of sub expressions actually being used\n\t\t\t    // during execution. 1 if only the whole match\n\t\t\t    // (subexpr 0) is used.\n    // listid is global, so that it increases on recursive calls to\n    // nfa_regmatch(), which means we don't have to clear the lastlist field of\n    // all the states.\n    int nfa_listid;\n    int nfa_alt_listid;\n\n#ifdef FEAT_SYN_HL\n    int nfa_has_zsubexpr;   // NFA regexp has \\z( ), set zsubexpr.\n#endif\n} regexec_T;\n\nstatic regexec_T\trex;\nstatic int\t\trex_in_use = FALSE;\n\n/*\n * Return TRUE if character 'c' is included in 'iskeyword' option for\n * \"reg_buf\" buffer.\n */\n    static int\nreg_iswordc(int c)\n{\n    return vim_iswordc_buf(c, rex.reg_buf);\n}\n\n/*\n * Get pointer to the line \"lnum\", which is relative to \"reg_firstlnum\".\n */\n    static char_u *\nreg_getline(linenr_T lnum)\n{\n    // when looking behind for a match/no-match lnum is negative.  But we\n    // can't go before line 1\n    if (rex.reg_firstlnum + lnum < 1)\n\treturn NULL;\n    if (lnum > rex.reg_maxline)\n\t// Must have matched the \"\\n\" in the last line.\n\treturn (char_u *)\"\";\n    return ml_get_buf(rex.reg_buf, rex.reg_firstlnum + lnum, FALSE);\n}\n\n#ifdef FEAT_SYN_HL\nstatic char_u\t*reg_startzp[NSUBEXP];\t// Workspace to mark beginning\nstatic char_u\t*reg_endzp[NSUBEXP];\t//   and end of \\z(...\\) matches\nstatic lpos_T\treg_startzpos[NSUBEXP];\t// idem, beginning pos\nstatic lpos_T\treg_endzpos[NSUBEXP];\t// idem, end pos\n#endif\n\n// TRUE if using multi-line regexp.\n#define REG_MULTI\t(rex.reg_match == NULL)\n\n#ifdef FEAT_SYN_HL\n/*\n * Create a new extmatch and mark it as referenced once.\n */\n    static reg_extmatch_T *\nmake_extmatch(void)\n{\n    reg_extmatch_T\t*em;\n\n    em = ALLOC_CLEAR_ONE(reg_extmatch_T);\n    if (em != NULL)\n\tem->refcnt = 1;\n    return em;\n}\n\n/*\n * Add a reference to an extmatch.\n */\n    reg_extmatch_T *\nref_extmatch(reg_extmatch_T *em)\n{\n    if (em != NULL)\n\tem->refcnt++;\n    return em;\n}\n\n/*\n * Remove a reference to an extmatch.  If there are no references left, free\n * the info.\n */\n    void\nunref_extmatch(reg_extmatch_T *em)\n{\n    int i;\n\n    if (em != NULL && --em->refcnt <= 0)\n    {\n\tfor (i = 0; i < NSUBEXP; ++i)\n\t    vim_free(em->matches[i]);\n\tvim_free(em);\n    }\n}\n#endif\n\n/*\n * Get class of previous character.\n */\n    static int\nreg_prev_class(void)\n{\n    if (rex.input > rex.line)\n\treturn mb_get_class_buf(rex.input - 1\n\t\t       - (*mb_head_off)(rex.line, rex.input - 1), rex.reg_buf);\n    return -1;\n}\n\n/*\n * Return TRUE if the current rex.input position matches the Visual area.\n */\n    static int\nreg_match_visual(void)\n{\n    pos_T\ttop, bot;\n    linenr_T    lnum;\n    colnr_T\tcol;\n    win_T\t*wp = rex.reg_win == NULL ? curwin : rex.reg_win;\n    int\t\tmode;\n    colnr_T\tstart, end;\n    colnr_T\tstart2, end2;\n    colnr_T\tcols;\n    colnr_T\tcurswant;\n\n    // Check if the buffer is the current buffer and not using a string.\n    if (rex.reg_buf != curbuf || VIsual.lnum == 0 || !REG_MULTI)\n\treturn FALSE;\n\n    if (VIsual_active)\n    {\n\tif (LT_POS(VIsual, wp->w_cursor))\n\t{\n\t    top = VIsual;\n\t    bot = wp->w_cursor;\n\t}\n\telse\n\t{\n\t    top = wp->w_cursor;\n\t    bot = VIsual;\n\t}\n\tmode = VIsual_mode;\n\tcurswant = wp->w_curswant;\n    }\n    else\n    {\n\tif (LT_POS(curbuf->b_visual.vi_start, curbuf->b_visual.vi_end))\n\t{\n\t    top = curbuf->b_visual.vi_start;\n\t    bot = curbuf->b_visual.vi_end;\n\t}\n\telse\n\t{\n\t    top = curbuf->b_visual.vi_end;\n\t    bot = curbuf->b_visual.vi_start;\n\t}\n\tmode = curbuf->b_visual.vi_mode;\n\tcurswant = curbuf->b_visual.vi_curswant;\n    }\n    lnum = rex.lnum + rex.reg_firstlnum;\n    if (lnum < top.lnum || lnum > bot.lnum)\n\treturn FALSE;\n\n    col = (colnr_T)(rex.input - rex.line);\n    if (mode == 'v')\n    {\n\tif ((lnum == top.lnum && col < top.col)\n\t\t|| (lnum == bot.lnum && col >= bot.col + (*p_sel != 'e')))\n\t    return FALSE;\n    }\n    else if (mode == Ctrl_V)\n    {\n\tgetvvcol(wp, &top, &start, NULL, &end);\n\tgetvvcol(wp, &bot, &start2, NULL, &end2);\n\tif (start2 < start)\n\t    start = start2;\n\tif (end2 > end)\n\t    end = end2;\n\tif (top.col == MAXCOL || bot.col == MAXCOL || curswant == MAXCOL)\n\t    end = MAXCOL;\n\n\t// getvvcol() flushes rex.line, need to get it again\n\trex.line = reg_getline(rex.lnum);\n\trex.input = rex.line + col;\n\n\tcols = win_linetabsize(wp, rex.reg_firstlnum + rex.lnum, rex.line, col);\n\tif (cols < start || cols > end - (*p_sel == 'e'))\n\t    return FALSE;\n    }\n    return TRUE;\n}\n\n/*\n * Check the regexp program for its magic number.\n * Return TRUE if it's wrong.\n */\n    static int\nprog_magic_wrong(void)\n{\n    regprog_T\t*prog;\n\n    prog = REG_MULTI ? rex.reg_mmatch->regprog : rex.reg_match->regprog;\n    if (prog->engine == &nfa_regengine)\n\t// For NFA matcher we don't check the magic\n\treturn FALSE;\n\n    if (UCHARAT(((bt_regprog_T *)prog)->program) != REGMAGIC)\n    {\n\temsg(_(e_corrupted_regexp_program));\n\treturn TRUE;\n    }\n    return FALSE;\n}\n\n/*\n * Cleanup the subexpressions, if this wasn't done yet.\n * This construction is used to clear the subexpressions only when they are\n * used (to increase speed).\n */\n    static void\ncleanup_subexpr(void)\n{\n    if (rex.need_clear_subexpr)\n    {\n\tif (REG_MULTI)\n\t{\n\t    // Use 0xff to set lnum to -1\n\t    vim_memset(rex.reg_startpos, 0xff, sizeof(lpos_T) * NSUBEXP);\n\t    vim_memset(rex.reg_endpos, 0xff, sizeof(lpos_T) * NSUBEXP);\n\t}\n\telse\n\t{\n\t    vim_memset(rex.reg_startp, 0, sizeof(char_u *) * NSUBEXP);\n\t    vim_memset(rex.reg_endp, 0, sizeof(char_u *) * NSUBEXP);\n\t}\n\trex.need_clear_subexpr = FALSE;\n    }\n}\n\n#ifdef FEAT_SYN_HL\n    static void\ncleanup_zsubexpr(void)\n{\n    if (rex.need_clear_zsubexpr)\n    {\n\tif (REG_MULTI)\n\t{\n\t    // Use 0xff to set lnum to -1\n\t    vim_memset(reg_startzpos, 0xff, sizeof(lpos_T) * NSUBEXP);\n\t    vim_memset(reg_endzpos, 0xff, sizeof(lpos_T) * NSUBEXP);\n\t}\n\telse\n\t{\n\t    vim_memset(reg_startzp, 0, sizeof(char_u *) * NSUBEXP);\n\t    vim_memset(reg_endzp, 0, sizeof(char_u *) * NSUBEXP);\n\t}\n\trex.need_clear_zsubexpr = FALSE;\n    }\n}\n#endif\n\n/*\n * Advance rex.lnum, rex.line and rex.input to the next line.\n */\n    static void\nreg_nextline(void)\n{\n    rex.line = reg_getline(++rex.lnum);\n    rex.input = rex.line;\n    fast_breakcheck();\n}\n\n/*\n * Check whether a backreference matches.\n * Returns RA_FAIL, RA_NOMATCH or RA_MATCH.\n * If \"bytelen\" is not NULL, it is set to the byte length of the match in the\n * last line.\n */\n    static int\nmatch_with_backref(\n    linenr_T start_lnum,\n    colnr_T  start_col,\n    linenr_T end_lnum,\n    colnr_T  end_col,\n    int\t     *bytelen)\n{\n    linenr_T\tclnum = start_lnum;\n    colnr_T\tccol = start_col;\n    int\t\tlen;\n    char_u\t*p;\n\n    if (bytelen != NULL)\n\t*bytelen = 0;\n    for (;;)\n    {\n\t// Since getting one line may invalidate the other, need to make copy.\n\t// Slow!\n\tif (rex.line != reg_tofree)\n\t{\n\t    len = (int)STRLEN(rex.line);\n\t    if (reg_tofree == NULL || len >= (int)reg_tofreelen)\n\t    {\n\t\tlen += 50;\t// get some extra\n\t\tvim_free(reg_tofree);\n\t\treg_tofree = alloc(len);\n\t\tif (reg_tofree == NULL)\n\t\t    return RA_FAIL; // out of memory!\n\t\treg_tofreelen = len;\n\t    }\n\t    STRCPY(reg_tofree, rex.line);\n\t    rex.input = reg_tofree + (rex.input - rex.line);\n\t    rex.line = reg_tofree;\n\t}\n\n\t// Get the line to compare with.\n\tp = reg_getline(clnum);\n\tif (clnum == end_lnum)\n\t    len = end_col - ccol;\n\telse\n\t    len = (int)STRLEN(p + ccol);\n\n\tif (cstrncmp(p + ccol, rex.input, &len) != 0)\n\t    return RA_NOMATCH;  // doesn't match\n\tif (bytelen != NULL)\n\t    *bytelen += len;\n\tif (clnum == end_lnum)\n\t    break;\t\t// match and at end!\n\tif (rex.lnum >= rex.reg_maxline)\n\t    return RA_NOMATCH;  // text too short\n\n\t// Advance to next line.\n\treg_nextline();\n\tif (bytelen != NULL)\n\t    *bytelen = 0;\n\t++clnum;\n\tccol = 0;\n\tif (got_int)\n\t    return RA_FAIL;\n    }\n\n    // found a match!  Note that rex.line may now point to a copy of the line,\n    // that should not matter.\n    return RA_MATCH;\n}\n\n/*\n * Used in a place where no * or \\+ can follow.\n */\n    static int\nre_mult_next(char *what)\n{\n    if (re_multi_type(peekchr()) == MULTI_MULT)\n    {\n       semsg(_(e_nfa_regexp_cannot_repeat_str), what);\n       rc_did_emsg = TRUE;\n       return FAIL;\n    }\n    return OK;\n}\n\ntypedef struct\n{\n    int a, b, c;\n} decomp_T;\n\n\n// 0xfb20 - 0xfb4f\nstatic decomp_T decomp_table[0xfb4f-0xfb20+1] =\n{\n    {0x5e2,0,0},\t\t// 0xfb20\talt ayin\n    {0x5d0,0,0},\t\t// 0xfb21\talt alef\n    {0x5d3,0,0},\t\t// 0xfb22\talt dalet\n    {0x5d4,0,0},\t\t// 0xfb23\talt he\n    {0x5db,0,0},\t\t// 0xfb24\talt kaf\n    {0x5dc,0,0},\t\t// 0xfb25\talt lamed\n    {0x5dd,0,0},\t\t// 0xfb26\talt mem-sofit\n    {0x5e8,0,0},\t\t// 0xfb27\talt resh\n    {0x5ea,0,0},\t\t// 0xfb28\talt tav\n    {'+', 0, 0},\t\t// 0xfb29\talt plus\n    {0x5e9, 0x5c1, 0},\t\t// 0xfb2a\tshin+shin-dot\n    {0x5e9, 0x5c2, 0},\t\t// 0xfb2b\tshin+sin-dot\n    {0x5e9, 0x5c1, 0x5bc},\t// 0xfb2c\tshin+shin-dot+dagesh\n    {0x5e9, 0x5c2, 0x5bc},\t// 0xfb2d\tshin+sin-dot+dagesh\n    {0x5d0, 0x5b7, 0},\t\t// 0xfb2e\talef+patah\n    {0x5d0, 0x5b8, 0},\t\t// 0xfb2f\talef+qamats\n    {0x5d0, 0x5b4, 0},\t\t// 0xfb30\talef+hiriq\n    {0x5d1, 0x5bc, 0},\t\t// 0xfb31\tbet+dagesh\n    {0x5d2, 0x5bc, 0},\t\t// 0xfb32\tgimel+dagesh\n    {0x5d3, 0x5bc, 0},\t\t// 0xfb33\tdalet+dagesh\n    {0x5d4, 0x5bc, 0},\t\t// 0xfb34\the+dagesh\n    {0x5d5, 0x5bc, 0},\t\t// 0xfb35\tvav+dagesh\n    {0x5d6, 0x5bc, 0},\t\t// 0xfb36\tzayin+dagesh\n    {0xfb37, 0, 0},\t\t// 0xfb37 -- UNUSED\n    {0x5d8, 0x5bc, 0},\t\t// 0xfb38\ttet+dagesh\n    {0x5d9, 0x5bc, 0},\t\t// 0xfb39\tyud+dagesh\n    {0x5da, 0x5bc, 0},\t\t// 0xfb3a\tkaf sofit+dagesh\n    {0x5db, 0x5bc, 0},\t\t// 0xfb3b\tkaf+dagesh\n    {0x5dc, 0x5bc, 0},\t\t// 0xfb3c\tlamed+dagesh\n    {0xfb3d, 0, 0},\t\t// 0xfb3d -- UNUSED\n    {0x5de, 0x5bc, 0},\t\t// 0xfb3e\tmem+dagesh\n    {0xfb3f, 0, 0},\t\t// 0xfb3f -- UNUSED\n    {0x5e0, 0x5bc, 0},\t\t// 0xfb40\tnun+dagesh\n    {0x5e1, 0x5bc, 0},\t\t// 0xfb41\tsamech+dagesh\n    {0xfb42, 0, 0},\t\t// 0xfb42 -- UNUSED\n    {0x5e3, 0x5bc, 0},\t\t// 0xfb43\tpe sofit+dagesh\n    {0x5e4, 0x5bc,0},\t\t// 0xfb44\tpe+dagesh\n    {0xfb45, 0, 0},\t\t// 0xfb45 -- UNUSED\n    {0x5e6, 0x5bc, 0},\t\t// 0xfb46\ttsadi+dagesh\n    {0x5e7, 0x5bc, 0},\t\t// 0xfb47\tqof+dagesh\n    {0x5e8, 0x5bc, 0},\t\t// 0xfb48\tresh+dagesh\n    {0x5e9, 0x5bc, 0},\t\t// 0xfb49\tshin+dagesh\n    {0x5ea, 0x5bc, 0},\t\t// 0xfb4a\ttav+dagesh\n    {0x5d5, 0x5b9, 0},\t\t// 0xfb4b\tvav+holam\n    {0x5d1, 0x5bf, 0},\t\t// 0xfb4c\tbet+rafe\n    {0x5db, 0x5bf, 0},\t\t// 0xfb4d\tkaf+rafe\n    {0x5e4, 0x5bf, 0},\t\t// 0xfb4e\tpe+rafe\n    {0x5d0, 0x5dc, 0}\t\t// 0xfb4f\talef-lamed\n};\n\n    static void\nmb_decompose(int c, int *c1, int *c2, int *c3)\n{\n    decomp_T d;\n\n    if (c >= 0xfb20 && c <= 0xfb4f)\n    {\n\td = decomp_table[c - 0xfb20];\n\t*c1 = d.a;\n\t*c2 = d.b;\n\t*c3 = d.c;\n    }\n    else\n    {\n\t*c1 = c;\n\t*c2 = *c3 = 0;\n    }\n}\n\n/*\n * Compare two strings, ignore case if rex.reg_ic set.\n * Return 0 if strings match, non-zero otherwise.\n * Correct the length \"*n\" when composing characters are ignored.\n */\n    static int\ncstrncmp(char_u *s1, char_u *s2, int *n)\n{\n    int\t\tresult;\n\n    if (!rex.reg_ic)\n\tresult = STRNCMP(s1, s2, *n);\n    else\n\tresult = MB_STRNICMP(s1, s2, *n);\n\n    // if it failed and it's utf8 and we want to combineignore:\n    if (result != 0 && enc_utf8 && rex.reg_icombine)\n    {\n\tchar_u\t*str1, *str2;\n\tint\tc1, c2, c11, c12;\n\tint\tjunk;\n\n\t// we have to handle the strcmp ourselves, since it is necessary to\n\t// deal with the composing characters by ignoring them:\n\tstr1 = s1;\n\tstr2 = s2;\n\tc1 = c2 = 0;\n\twhile ((int)(str1 - s1) < *n)\n\t{\n\t    c1 = mb_ptr2char_adv(&str1);\n\t    c2 = mb_ptr2char_adv(&str2);\n\n\t    // Decompose the character if necessary, into 'base' characters.\n\t    // Currently hard-coded for Hebrew, Arabic to be done...\n\t    if (c1 != c2 && (!rex.reg_ic || utf_fold(c1) != utf_fold(c2)))\n\t    {\n\t\t// decomposition necessary?\n\t\tmb_decompose(c1, &c11, &junk, &junk);\n\t\tmb_decompose(c2, &c12, &junk, &junk);\n\t\tc1 = c11;\n\t\tc2 = c12;\n\t\tif (c11 != c12\n\t\t\t    && (!rex.reg_ic || utf_fold(c11) != utf_fold(c12)))\n\t\t    break;\n\t    }\n\t}\n\tresult = c2 - c1;\n\tif (result == 0)\n\t    *n = (int)(str2 - s2);\n    }\n\n    return result;\n}\n\n/*\n * cstrchr: This function is used a lot for simple searches, keep it fast!\n */\n    static char_u *\ncstrchr(char_u *s, int c)\n{\n    char_u\t*p;\n    int\t\tcc;\n\n    if (!rex.reg_ic || (!enc_utf8 && mb_char2len(c) > 1))\n\treturn vim_strchr(s, c);\n\n    // tolower() and toupper() can be slow, comparing twice should be a lot\n    // faster (esp. when using MS Visual C++!).\n    // For UTF-8 need to use folded case.\n    if (enc_utf8 && c > 0x80)\n\tcc = utf_fold(c);\n    else\n\t if (MB_ISUPPER(c))\n\tcc = MB_TOLOWER(c);\n    else if (MB_ISLOWER(c))\n\tcc = MB_TOUPPER(c);\n    else\n\treturn vim_strchr(s, c);\n\n    if (has_mbyte)\n    {\n\tfor (p = s; *p != NUL; p += (*mb_ptr2len)(p))\n\t{\n\t    if (enc_utf8 && c > 0x80)\n\t    {\n\t\tint uc = utf_ptr2char(p);\n\n\t\t// Do not match an illegal byte.  E.g. 0xff matches 0xc3 0xbf,\n\t\t// not 0xff.\n\t\tif ((uc < 0x80 || uc != *p) && utf_fold(uc) == cc)\n\t\t    return p;\n\t    }\n\t    else if (*p == c || *p == cc)\n\t\treturn p;\n\t}\n    }\n    else\n\t// Faster version for when there are no multi-byte characters.\n\tfor (p = s; *p != NUL; ++p)\n\t    if (*p == c || *p == cc)\n\t\treturn p;\n\n    return NULL;\n}\n\n////////////////////////////////////////////////////////////////\n//\t\t      regsub stuff\t\t\t      //\n////////////////////////////////////////////////////////////////\n\n/*\n * We should define ftpr as a pointer to a function returning a pointer to\n * a function returning a pointer to a function ...\n * This is impossible, so we declare a pointer to a function returning a\n * void pointer. This should work for all compilers.\n */\ntypedef void (*(*fptr_T)(int *, int));\n\nstatic int vim_regsub_both(char_u *source, typval_T *expr, char_u *dest, int destlen, int flags);\n\n    static fptr_T\ndo_upper(int *d, int c)\n{\n    *d = MB_TOUPPER(c);\n\n    return (fptr_T)NULL;\n}\n\n    static fptr_T\ndo_Upper(int *d, int c)\n{\n    *d = MB_TOUPPER(c);\n\n    return (fptr_T)do_Upper;\n}\n\n    static fptr_T\ndo_lower(int *d, int c)\n{\n    *d = MB_TOLOWER(c);\n\n    return (fptr_T)NULL;\n}\n\n    static fptr_T\ndo_Lower(int *d, int c)\n{\n    *d = MB_TOLOWER(c);\n\n    return (fptr_T)do_Lower;\n}\n\n/*\n * regtilde(): Replace tildes in the pattern by the old pattern.\n *\n * Short explanation of the tilde: It stands for the previous replacement\n * pattern.  If that previous pattern also contains a ~ we should go back a\n * step further...  But we insert the previous pattern into the current one\n * and remember that.\n * This still does not handle the case where \"magic\" changes.  So require the\n * user to keep his hands off of \"magic\".\n *\n * The tildes are parsed once before the first call to vim_regsub().\n */\n    char_u *\nregtilde(char_u *source, int magic)\n{\n    char_u\t*newsub = source;\n    char_u\t*tmpsub;\n    char_u\t*p;\n    int\t\tlen;\n    int\t\tprevlen;\n\n    for (p = newsub; *p; ++p)\n    {\n\tif ((*p == '~' && magic) || (*p == '\\\\' && *(p + 1) == '~' && !magic))\n\t{\n\t    if (reg_prev_sub != NULL)\n\t    {\n\t\t// length = len(newsub) - 1 + len(prev_sub) + 1\n\t\tprevlen = (int)STRLEN(reg_prev_sub);\n\t\ttmpsub = alloc(STRLEN(newsub) + prevlen);\n\t\tif (tmpsub != NULL)\n\t\t{\n\t\t    // copy prefix\n\t\t    len = (int)(p - newsub);\t// not including ~\n\t\t    mch_memmove(tmpsub, newsub, (size_t)len);\n\t\t    // interpret tilde\n\t\t    mch_memmove(tmpsub + len, reg_prev_sub, (size_t)prevlen);\n\t\t    // copy postfix\n\t\t    if (!magic)\n\t\t\t++p;\t\t\t// back off backslash\n\t\t    STRCPY(tmpsub + len + prevlen, p + 1);\n\n\t\t    if (newsub != source)\t// already allocated newsub\n\t\t\tvim_free(newsub);\n\t\t    newsub = tmpsub;\n\t\t    p = newsub + len + prevlen;\n\t\t}\n\t    }\n\t    else if (magic)\n\t\tSTRMOVE(p, p + 1);\t// remove '~'\n\t    else\n\t\tSTRMOVE(p, p + 2);\t// remove '\\~'\n\t    --p;\n\t}\n\telse\n\t{\n\t    if (*p == '\\\\' && p[1])\t\t// skip escaped characters\n\t\t++p;\n\t    if (has_mbyte)\n\t\tp += (*mb_ptr2len)(p) - 1;\n\t}\n    }\n\n    // Store a copy of newsub  in reg_prev_sub.  It is always allocated,\n    // because recursive calls may make the returned string invalid.\n    vim_free(reg_prev_sub);\n    reg_prev_sub = vim_strsave(newsub);\n\n    return newsub;\n}\n\n#ifdef FEAT_EVAL\nstatic int can_f_submatch = FALSE;\t// TRUE when submatch() can be used\n\n// These pointers are used for reg_submatch().  Needed for when the\n// substitution string is an expression that contains a call to substitute()\n// and submatch().\ntypedef struct {\n    regmatch_T\t*sm_match;\n    regmmatch_T\t*sm_mmatch;\n    linenr_T\tsm_firstlnum;\n    linenr_T\tsm_maxline;\n    int\t\tsm_line_lbr;\n} regsubmatch_T;\n\nstatic regsubmatch_T rsm;  // can only be used when can_f_submatch is TRUE\n#endif\n\n#ifdef FEAT_EVAL\n\n/*\n * Put the submatches in \"argv[argskip]\" which is a list passed into\n * call_func() by vim_regsub_both().\n */\n    static int\nfill_submatch_list(int argc UNUSED, typval_T *argv, int argskip, int argcount)\n{\n    listitem_T\t*li;\n    int\t\ti;\n    char_u\t*s;\n    typval_T\t*listarg = argv + argskip;\n\n    if (argcount == argskip)\n\t// called function doesn't take a submatches argument\n\treturn argskip;\n\n    // Relies on sl_list to be the first item in staticList10_T.\n    init_static_list((staticList10_T *)(listarg->vval.v_list));\n\n    // There are always 10 list items in staticList10_T.\n    li = listarg->vval.v_list->lv_first;\n    for (i = 0; i < 10; ++i)\n    {\n\ts = rsm.sm_match->startp[i];\n\tif (s == NULL || rsm.sm_match->endp[i] == NULL)\n\t    s = NULL;\n\telse\n\t    s = vim_strnsave(s, rsm.sm_match->endp[i] - s);\n\tli->li_tv.v_type = VAR_STRING;\n\tli->li_tv.vval.v_string = s;\n\tli = li->li_next;\n    }\n    return argskip + 1;\n}\n\n    static void\nclear_submatch_list(staticList10_T *sl)\n{\n    int i;\n\n    for (i = 0; i < 10; ++i)\n\tvim_free(sl->sl_items[i].li_tv.vval.v_string);\n}\n#endif\n\n/*\n * vim_regsub() - perform substitutions after a vim_regexec() or\n * vim_regexec_multi() match.\n *\n * If \"flags\" has REGSUB_COPY really copy into \"dest[destlen]\".\n * Oterwise nothing is copied, only compue the length of the result.\n *\n * If \"flags\" has REGSUB_MAGIC then behave like 'magic' is set.\n *\n * If \"flags\" has REGSUB_BACKSLASH a backslash will be removed later, need to\n * double them to keep them, and insert a backslash before a CR to avoid it\n * being replaced with a line break later.\n *\n * Note: The matched text must not change between the call of\n * vim_regexec()/vim_regexec_multi() and vim_regsub()!  It would make the back\n * references invalid!\n *\n * Returns the size of the replacement, including terminating NUL.\n */\n    int\nvim_regsub(\n    regmatch_T\t*rmp,\n    char_u\t*source,\n    typval_T\t*expr,\n    char_u\t*dest,\n    int\t\tdestlen,\n    int\t\tflags)\n{\n    int\t\tresult;\n    regexec_T\trex_save;\n    int\t\trex_in_use_save = rex_in_use;\n\n    if (rex_in_use)\n\t// Being called recursively, save the state.\n\trex_save = rex;\n    rex_in_use = TRUE;\n\n    rex.reg_match = rmp;\n    rex.reg_mmatch = NULL;\n    rex.reg_maxline = 0;\n    rex.reg_buf = curbuf;\n    rex.reg_line_lbr = TRUE;\n    result = vim_regsub_both(source, expr, dest, destlen, flags);\n\n    rex_in_use = rex_in_use_save;\n    if (rex_in_use)\n\trex = rex_save;\n\n    return result;\n}\n\n    int\nvim_regsub_multi(\n    regmmatch_T\t*rmp,\n    linenr_T\tlnum,\n    char_u\t*source,\n    char_u\t*dest,\n    int\t\tdestlen,\n    int\t\tflags)\n{\n    int\t\tresult;\n    regexec_T\trex_save;\n    int\t\trex_in_use_save = rex_in_use;\n\n    if (rex_in_use)\n\t// Being called recursively, save the state.\n\trex_save = rex;\n    rex_in_use = TRUE;\n\n    rex.reg_match = NULL;\n    rex.reg_mmatch = rmp;\n    rex.reg_buf = curbuf;\t// always works on the current buffer!\n    rex.reg_firstlnum = lnum;\n    rex.reg_maxline = curbuf->b_ml.ml_line_count - lnum;\n    rex.reg_line_lbr = FALSE;\n    result = vim_regsub_both(source, NULL, dest, destlen, flags);\n\n    rex_in_use = rex_in_use_save;\n    if (rex_in_use)\n\trex = rex_save;\n\n    return result;\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n// When nesting more than a couple levels it's probably a mistake.\n# define MAX_REGSUB_NESTING 4\nstatic char_u   *eval_result[MAX_REGSUB_NESTING] = {NULL, NULL, NULL, NULL};\n\n# if defined(EXITFREE) || defined(PROTO)\n    void\nfree_resub_eval_result(void)\n{\n    int i;\n\n    for (i = 0; i < MAX_REGSUB_NESTING; ++i)\n\tVIM_CLEAR(eval_result[i]);\n}\n# endif\n#endif\n\n    static int\nvim_regsub_both(\n    char_u\t*source,\n    typval_T\t*expr,\n    char_u\t*dest,\n    int\t\tdestlen,\n    int\t\tflags)\n{\n    char_u\t*src;\n    char_u\t*dst;\n    char_u\t*s;\n    int\t\tc;\n    int\t\tcc;\n    int\t\tno = -1;\n    fptr_T\tfunc_all = (fptr_T)NULL;\n    fptr_T\tfunc_one = (fptr_T)NULL;\n    linenr_T\tclnum = 0;\t// init for GCC\n    int\t\tlen = 0;\t// init for GCC\n#ifdef FEAT_EVAL\n    static int  nesting = 0;\n    int\t\tnested;\n#endif\n    int\t\tcopy = flags & REGSUB_COPY;\n\n    // Be paranoid...\n    if ((source == NULL && expr == NULL) || dest == NULL)\n    {\n\temsg(_(e_null_argument));\n\treturn 0;\n    }\n    if (prog_magic_wrong())\n\treturn 0;\n#ifdef FEAT_EVAL\n    if (nesting == MAX_REGSUB_NESTING)\n    {\n\temsg(_(e_substitute_nesting_too_deep));\n\treturn 0;\n    }\n    nested = nesting;\n#endif\n    src = source;\n    dst = dest;\n\n    /*\n     * When the substitute part starts with \"\\=\" evaluate it as an expression.\n     */\n    if (expr != NULL || (source[0] == '\\\\' && source[1] == '='))\n    {\n#ifdef FEAT_EVAL\n\t// To make sure that the length doesn't change between checking the\n\t// length and copying the string, and to speed up things, the\n\t// resulting string is saved from the call with\n\t// \"flags & REGSUB_COPY\" == 0 to the call with\n\t// \"flags & REGSUB_COPY\" != 0.\n\tif (copy)\n\t{\n\t    if (eval_result[nested] != NULL)\n\t    {\n\t\tSTRCPY(dest, eval_result[nested]);\n\t\tdst += STRLEN(eval_result[nested]);\n\t\tVIM_CLEAR(eval_result[nested]);\n\t    }\n\t}\n\telse\n\t{\n\t    int\t\t    prev_can_f_submatch = can_f_submatch;\n\t    regsubmatch_T   rsm_save;\n\n\t    VIM_CLEAR(eval_result[nested]);\n\n\t    // The expression may contain substitute(), which calls us\n\t    // recursively.  Make sure submatch() gets the text from the first\n\t    // level.\n\t    if (can_f_submatch)\n\t\trsm_save = rsm;\n\t    can_f_submatch = TRUE;\n\t    rsm.sm_match = rex.reg_match;\n\t    rsm.sm_mmatch = rex.reg_mmatch;\n\t    rsm.sm_firstlnum = rex.reg_firstlnum;\n\t    rsm.sm_maxline = rex.reg_maxline;\n\t    rsm.sm_line_lbr = rex.reg_line_lbr;\n\n\t    // Although unlikely, it is possible that the expression invokes a\n\t    // substitute command (it might fail, but still).  Therefore keep\n\t    // an array of eval results.\n\t    ++nesting;\n\n\t    if (expr != NULL)\n\t    {\n\t\ttypval_T\targv[2];\n\t\tchar_u\t\tbuf[NUMBUFLEN];\n\t\ttypval_T\trettv;\n\t\tstaticList10_T\tmatchList;\n\t\tfuncexe_T\tfuncexe;\n\n\t\trettv.v_type = VAR_STRING;\n\t\trettv.vval.v_string = NULL;\n\t\targv[0].v_type = VAR_LIST;\n\t\targv[0].vval.v_list = &matchList.sl_list;\n\t\tmatchList.sl_list.lv_len = 0;\n\t\tCLEAR_FIELD(funcexe);\n\t\tfuncexe.fe_argv_func = fill_submatch_list;\n\t\tfuncexe.fe_evaluate = TRUE;\n\t\tif (expr->v_type == VAR_FUNC)\n\t\t{\n\t\t    s = expr->vval.v_string;\n\t\t    call_func(s, -1, &rettv, 1, argv, &funcexe);\n\t\t}\n\t\telse if (expr->v_type == VAR_PARTIAL)\n\t\t{\n\t\t    partial_T   *partial = expr->vval.v_partial;\n\n\t\t    s = partial_name(partial);\n\t\t    funcexe.fe_partial = partial;\n\t\t    call_func(s, -1, &rettv, 1, argv, &funcexe);\n\t\t}\n\t\telse if (expr->v_type == VAR_INSTR)\n\t\t{\n\t\t    exe_typval_instr(expr, &rettv);\n\t\t}\n\t\tif (matchList.sl_list.lv_len > 0)\n\t\t    // fill_submatch_list() was called\n\t\t    clear_submatch_list(&matchList);\n\n\t\tif (rettv.v_type == VAR_UNKNOWN)\n\t\t    // something failed, no need to report another error\n\t\t    eval_result[nested] = NULL;\n\t\telse\n\t\t{\n\t\t    eval_result[nested] = tv_get_string_buf_chk(&rettv, buf);\n\t\t    if (eval_result[nested] != NULL)\n\t\t\teval_result[nested] = vim_strsave(eval_result[nested]);\n\t\t}\n\t\tclear_tv(&rettv);\n\t    }\n\t    else if (substitute_instr != NULL)\n\t\t// Execute instructions from ISN_SUBSTITUTE.\n\t\teval_result[nested] = exe_substitute_instr();\n\t    else\n\t\teval_result[nested] = eval_to_string(source + 2, TRUE);\n\t    --nesting;\n\n\t    if (eval_result[nested] != NULL)\n\t    {\n\t\tint had_backslash = FALSE;\n\n\t\tfor (s = eval_result[nested]; *s != NUL; MB_PTR_ADV(s))\n\t\t{\n\t\t    // Change NL to CR, so that it becomes a line break,\n\t\t    // unless called from vim_regexec_nl().\n\t\t    // Skip over a backslashed character.\n\t\t    if (*s == NL && !rsm.sm_line_lbr)\n\t\t\t*s = CAR;\n\t\t    else if (*s == '\\\\' && s[1] != NUL)\n\t\t    {\n\t\t\t++s;\n\t\t\t/* Change NL to CR here too, so that this works:\n\t\t\t * :s/abc\\\\\\ndef/\\=\"aaa\\\\\\nbbb\"/  on text:\n\t\t\t *   abc\\\n\t\t\t *   def\n\t\t\t * Not when called from vim_regexec_nl().\n\t\t\t */\n\t\t\tif (*s == NL && !rsm.sm_line_lbr)\n\t\t\t    *s = CAR;\n\t\t\thad_backslash = TRUE;\n\t\t    }\n\t\t}\n\t\tif (had_backslash && (flags & REGSUB_BACKSLASH))\n\t\t{\n\t\t    // Backslashes will be consumed, need to double them.\n\t\t    s = vim_strsave_escaped(eval_result[nested], (char_u *)\"\\\\\");\n\t\t    if (s != NULL)\n\t\t    {\n\t\t\tvim_free(eval_result[nested]);\n\t\t\teval_result[nested] = s;\n\t\t    }\n\t\t}\n\n\t\tdst += STRLEN(eval_result[nested]);\n\t    }\n\n\t    can_f_submatch = prev_can_f_submatch;\n\t    if (can_f_submatch)\n\t\trsm = rsm_save;\n\t}\n#endif\n    }\n    else\n      while ((c = *src++) != NUL)\n      {\n\tif (c == '&' && (flags & REGSUB_MAGIC))\n\t    no = 0;\n\telse if (c == '\\\\' && *src != NUL)\n\t{\n\t    if (*src == '&' && !(flags & REGSUB_MAGIC))\n\t    {\n\t\t++src;\n\t\tno = 0;\n\t    }\n\t    else if ('0' <= *src && *src <= '9')\n\t    {\n\t\tno = *src++ - '0';\n\t    }\n\t    else if (vim_strchr((char_u *)\"uUlLeE\", *src))\n\t    {\n\t\tswitch (*src++)\n\t\t{\n\t\tcase 'u':   func_one = (fptr_T)do_upper;\n\t\t\t    continue;\n\t\tcase 'U':   func_all = (fptr_T)do_Upper;\n\t\t\t    continue;\n\t\tcase 'l':   func_one = (fptr_T)do_lower;\n\t\t\t    continue;\n\t\tcase 'L':   func_all = (fptr_T)do_Lower;\n\t\t\t    continue;\n\t\tcase 'e':\n\t\tcase 'E':   func_one = func_all = (fptr_T)NULL;\n\t\t\t    continue;\n\t\t}\n\t    }\n\t}\n\tif (no < 0)\t      // Ordinary character.\n\t{\n\t    if (c == K_SPECIAL && src[0] != NUL && src[1] != NUL)\n\t    {\n\t\t// Copy a special key as-is.\n\t\tif (copy)\n\t\t{\n\t\t    if (dst + 3 > dest + destlen)\n\t\t    {\n\t\t\tiemsg(\"vim_regsub_both(): not enough space\");\n\t\t\treturn 0;\n\t\t    }\n\t\t    *dst++ = c;\n\t\t    *dst++ = *src++;\n\t\t    *dst++ = *src++;\n\t\t}\n\t\telse\n\t\t{\n\t\t    dst += 3;\n\t\t    src += 2;\n\t\t}\n\t\tcontinue;\n\t    }\n\n\t    if (c == '\\\\' && *src != NUL)\n\t    {\n\t\t// Check for abbreviations -- webb\n\t\tswitch (*src)\n\t\t{\n\t\t    case 'r':\tc = CAR;\t++src;\tbreak;\n\t\t    case 'n':\tc = NL;\t\t++src;\tbreak;\n\t\t    case 't':\tc = TAB;\t++src;\tbreak;\n\t\t // Oh no!  \\e already has meaning in subst pat :-(\n\t\t // case 'e':   c = ESC;\t++src;\tbreak;\n\t\t    case 'b':\tc = Ctrl_H;\t++src;\tbreak;\n\n\t\t    // If \"backslash\" is TRUE the backslash will be removed\n\t\t    // later.  Used to insert a literal CR.\n\t\t    default:\tif (flags & REGSUB_BACKSLASH)\n\t\t\t\t{\n\t\t\t\t    if (copy)\n\t\t\t\t    {\n\t\t\t\t\tif (dst + 1 > dest + destlen)\n\t\t\t\t\t{\n\t\t\t\t\t    iemsg(\"vim_regsub_both(): not enough space\");\n\t\t\t\t\t    return 0;\n\t\t\t\t\t}\n\t\t\t\t\t*dst = '\\\\';\n\t\t\t\t    }\n\t\t\t\t    ++dst;\n\t\t\t\t}\n\t\t\t\tc = *src++;\n\t\t}\n\t    }\n\t    else if (has_mbyte)\n\t\tc = mb_ptr2char(src - 1);\n\n\t    // Write to buffer, if copy is set.\n\t    if (func_one != (fptr_T)NULL)\n\t\t// Turbo C complains without the typecast\n\t\tfunc_one = (fptr_T)(func_one(&cc, c));\n\t    else if (func_all != (fptr_T)NULL)\n\t\t// Turbo C complains without the typecast\n\t\tfunc_all = (fptr_T)(func_all(&cc, c));\n\t    else // just copy\n\t\tcc = c;\n\n\t    if (has_mbyte)\n\t    {\n\t\tint totlen = mb_ptr2len(src - 1);\n\t\tint charlen = mb_char2len(cc);\n\n\t\tif (copy)\n\t\t{\n\t\t    if (dst + charlen > dest + destlen)\n\t\t    {\n\t\t\tiemsg(\"vim_regsub_both(): not enough space\");\n\t\t\treturn 0;\n\t\t    }\n\t\t    mb_char2bytes(cc, dst);\n\t\t}\n\t\tdst += charlen - 1;\n\t\tif (enc_utf8)\n\t\t{\n\t\t    int clen = utf_ptr2len(src - 1);\n\n\t\t    // If the character length is shorter than \"totlen\", there\n\t\t    // are composing characters; copy them as-is.\n\t\t    if (clen < totlen)\n\t\t    {\n\t\t\tif (copy)\n\t\t\t{\n\t\t\t    if (dst + totlen - clen > dest + destlen)\n\t\t\t    {\n\t\t\t\tiemsg(\"vim_regsub_both(): not enough space\");\n\t\t\t\treturn 0;\n\t\t\t    }\n\t\t\t    mch_memmove(dst + 1, src - 1 + clen,\n\t\t\t\t\t\t     (size_t)(totlen - clen));\n\t\t\t}\n\t\t\tdst += totlen - clen;\n\t\t    }\n\t\t}\n\t\tsrc += totlen - 1;\n\t    }\n\t    else if (copy)\n\t    {\n\t\tif (dst + 1 > dest + destlen)\n\t\t{\n\t\t    iemsg(\"vim_regsub_both(): not enough space\");\n\t\t    return 0;\n\t\t}\n\t\t*dst = cc;\n\t    }\n\t    dst++;\n\t}\n\telse\n\t{\n\t    if (REG_MULTI)\n\t    {\n\t\tclnum = rex.reg_mmatch->startpos[no].lnum;\n\t\tif (clnum < 0 || rex.reg_mmatch->endpos[no].lnum < 0)\n\t\t    s = NULL;\n\t\telse\n\t\t{\n\t\t    s = reg_getline(clnum) + rex.reg_mmatch->startpos[no].col;\n\t\t    if (rex.reg_mmatch->endpos[no].lnum == clnum)\n\t\t\tlen = rex.reg_mmatch->endpos[no].col\n\t\t\t\t\t    - rex.reg_mmatch->startpos[no].col;\n\t\t    else\n\t\t\tlen = (int)STRLEN(s);\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\ts = rex.reg_match->startp[no];\n\t\tif (rex.reg_match->endp[no] == NULL)\n\t\t    s = NULL;\n\t\telse\n\t\t    len = (int)(rex.reg_match->endp[no] - s);\n\t    }\n\t    if (s != NULL)\n\t    {\n\t\tfor (;;)\n\t\t{\n\t\t    if (len == 0)\n\t\t    {\n\t\t\tif (REG_MULTI)\n\t\t\t{\n\t\t\t    if (rex.reg_mmatch->endpos[no].lnum == clnum)\n\t\t\t\tbreak;\n\t\t\t    if (copy)\n\t\t\t    {\n\t\t\t\tif (dst + 1 > dest + destlen)\n\t\t\t\t{\n\t\t\t\t    iemsg(\"vim_regsub_both(): not enough space\");\n\t\t\t\t    return 0;\n\t\t\t\t}\n\t\t\t\t*dst = CAR;\n\t\t\t    }\n\t\t\t    ++dst;\n\t\t\t    s = reg_getline(++clnum);\n\t\t\t    if (rex.reg_mmatch->endpos[no].lnum == clnum)\n\t\t\t\tlen = rex.reg_mmatch->endpos[no].col;\n\t\t\t    else\n\t\t\t\tlen = (int)STRLEN(s);\n\t\t\t}\n\t\t\telse\n\t\t\t    break;\n\t\t    }\n\t\t    else if (*s == NUL) // we hit NUL.\n\t\t    {\n\t\t\tif (copy)\n\t\t\t    iemsg(_(e_damaged_match_string));\n\t\t\tgoto exit;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tif ((flags & REGSUB_BACKSLASH)\n\t\t\t\t\t\t  && (*s == CAR || *s == '\\\\'))\n\t\t\t{\n\t\t\t    /*\n\t\t\t     * Insert a backslash in front of a CR, otherwise\n\t\t\t     * it will be replaced by a line break.\n\t\t\t     * Number of backslashes will be halved later,\n\t\t\t     * double them here.\n\t\t\t     */\n\t\t\t    if (copy)\n\t\t\t    {\n\t\t\t\tif (dst + 2 > dest + destlen)\n\t\t\t\t{\n\t\t\t\t    iemsg(\"vim_regsub_both(): not enough space\");\n\t\t\t\t    return 0;\n\t\t\t\t}\n\t\t\t\tdst[0] = '\\\\';\n\t\t\t\tdst[1] = *s;\n\t\t\t    }\n\t\t\t    dst += 2;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    if (has_mbyte)\n\t\t\t\tc = mb_ptr2char(s);\n\t\t\t    else\n\t\t\t\tc = *s;\n\n\t\t\t    if (func_one != (fptr_T)NULL)\n\t\t\t\t// Turbo C complains without the typecast\n\t\t\t\tfunc_one = (fptr_T)(func_one(&cc, c));\n\t\t\t    else if (func_all != (fptr_T)NULL)\n\t\t\t\t// Turbo C complains without the typecast\n\t\t\t\tfunc_all = (fptr_T)(func_all(&cc, c));\n\t\t\t    else // just copy\n\t\t\t\tcc = c;\n\n\t\t\t    if (has_mbyte)\n\t\t\t    {\n\t\t\t\tint l;\n\t\t\t\tint charlen;\n\n\t\t\t\t// Copy composing characters separately, one\n\t\t\t\t// at a time.\n\t\t\t\tif (enc_utf8)\n\t\t\t\t    l = utf_ptr2len(s) - 1;\n\t\t\t\telse\n\t\t\t\t    l = mb_ptr2len(s) - 1;\n\n\t\t\t\ts += l;\n\t\t\t\tlen -= l;\n\t\t\t\tcharlen = mb_char2len(cc);\n\t\t\t\tif (copy)\n\t\t\t\t{\n\t\t\t\t    if (dst + charlen > dest + destlen)\n\t\t\t\t    {\n\t\t\t\t\tiemsg(\"vim_regsub_both(): not enough space\");\n\t\t\t\t\treturn 0;\n\t\t\t\t    }\n\t\t\t\t    mb_char2bytes(cc, dst);\n\t\t\t\t}\n\t\t\t\tdst += charlen - 1;\n\t\t\t    }\n\t\t\t    else if (copy)\n\t\t\t    {\n\t\t\t\tif (dst + 1 > dest + destlen)\n\t\t\t\t{\n\t\t\t\t    iemsg(\"vim_regsub_both(): not enough space\");\n\t\t\t\t    return 0;\n\t\t\t\t}\n\t\t\t\t*dst = cc;\n\t\t\t    }\n\t\t\t    dst++;\n\t\t\t}\n\n\t\t\t++s;\n\t\t\t--len;\n\t\t    }\n\t\t}\n\t    }\n\t    no = -1;\n\t}\n      }\n    if (copy)\n\t*dst = NUL;\n\nexit:\n    return (int)((dst - dest) + 1);\n}\n\n#ifdef FEAT_EVAL\n/*\n * Call reg_getline() with the line numbers from the submatch.  If a\n * substitute() was used the reg_maxline and other values have been\n * overwritten.\n */\n    static char_u *\nreg_getline_submatch(linenr_T lnum)\n{\n    char_u *s;\n    linenr_T save_first = rex.reg_firstlnum;\n    linenr_T save_max = rex.reg_maxline;\n\n    rex.reg_firstlnum = rsm.sm_firstlnum;\n    rex.reg_maxline = rsm.sm_maxline;\n\n    s = reg_getline(lnum);\n\n    rex.reg_firstlnum = save_first;\n    rex.reg_maxline = save_max;\n    return s;\n}\n\n/*\n * Used for the submatch() function: get the string from the n'th submatch in\n * allocated memory.\n * Returns NULL when not in a \":s\" command and for a non-existing submatch.\n */\n    char_u *\nreg_submatch(int no)\n{\n    char_u\t*retval = NULL;\n    char_u\t*s;\n    int\t\tlen;\n    int\t\tround;\n    linenr_T\tlnum;\n\n    if (!can_f_submatch || no < 0)\n\treturn NULL;\n\n    if (rsm.sm_match == NULL)\n    {\n\t/*\n\t * First round: compute the length and allocate memory.\n\t * Second round: copy the text.\n\t */\n\tfor (round = 1; round <= 2; ++round)\n\t{\n\t    lnum = rsm.sm_mmatch->startpos[no].lnum;\n\t    if (lnum < 0 || rsm.sm_mmatch->endpos[no].lnum < 0)\n\t\treturn NULL;\n\n\t    s = reg_getline_submatch(lnum);\n\t    if (s == NULL)  // anti-crash check, cannot happen?\n\t\tbreak;\n\t    s += rsm.sm_mmatch->startpos[no].col;\n\t    if (rsm.sm_mmatch->endpos[no].lnum == lnum)\n\t    {\n\t\t// Within one line: take form start to end col.\n\t\tlen = rsm.sm_mmatch->endpos[no].col\n\t\t\t\t\t  - rsm.sm_mmatch->startpos[no].col;\n\t\tif (round == 2)\n\t\t    vim_strncpy(retval, s, len);\n\t\t++len;\n\t    }\n\t    else\n\t    {\n\t\t// Multiple lines: take start line from start col, middle\n\t\t// lines completely and end line up to end col.\n\t\tlen = (int)STRLEN(s);\n\t\tif (round == 2)\n\t\t{\n\t\t    STRCPY(retval, s);\n\t\t    retval[len] = '\\n';\n\t\t}\n\t\t++len;\n\t\t++lnum;\n\t\twhile (lnum < rsm.sm_mmatch->endpos[no].lnum)\n\t\t{\n\t\t    s = reg_getline_submatch(lnum++);\n\t\t    if (round == 2)\n\t\t\tSTRCPY(retval + len, s);\n\t\t    len += (int)STRLEN(s);\n\t\t    if (round == 2)\n\t\t\tretval[len] = '\\n';\n\t\t    ++len;\n\t\t}\n\t\tif (round == 2)\n\t\t    STRNCPY(retval + len, reg_getline_submatch(lnum),\n\t\t\t\t\t     rsm.sm_mmatch->endpos[no].col);\n\t\tlen += rsm.sm_mmatch->endpos[no].col;\n\t\tif (round == 2)\n\t\t    retval[len] = NUL;\n\t\t++len;\n\t    }\n\n\t    if (retval == NULL)\n\t    {\n\t\tretval = alloc(len);\n\t\tif (retval == NULL)\n\t\t    return NULL;\n\t    }\n\t}\n    }\n    else\n    {\n\ts = rsm.sm_match->startp[no];\n\tif (s == NULL || rsm.sm_match->endp[no] == NULL)\n\t    retval = NULL;\n\telse\n\t    retval = vim_strnsave(s, rsm.sm_match->endp[no] - s);\n    }\n\n    return retval;\n}\n\n/*\n * Used for the submatch() function with the optional non-zero argument: get\n * the list of strings from the n'th submatch in allocated memory with NULs\n * represented in NLs.\n * Returns a list of allocated strings.  Returns NULL when not in a \":s\"\n * command, for a non-existing submatch and for any error.\n */\n    list_T *\nreg_submatch_list(int no)\n{\n    char_u\t*s;\n    linenr_T\tslnum;\n    linenr_T\telnum;\n    colnr_T\tscol;\n    colnr_T\tecol;\n    int\t\ti;\n    list_T\t*list;\n    int\t\terror = FALSE;\n\n    if (!can_f_submatch || no < 0)\n\treturn NULL;\n\n    if (rsm.sm_match == NULL)\n    {\n\tslnum = rsm.sm_mmatch->startpos[no].lnum;\n\telnum = rsm.sm_mmatch->endpos[no].lnum;\n\tif (slnum < 0 || elnum < 0)\n\t    return NULL;\n\n\tscol = rsm.sm_mmatch->startpos[no].col;\n\tecol = rsm.sm_mmatch->endpos[no].col;\n\n\tlist = list_alloc();\n\tif (list == NULL)\n\t    return NULL;\n\n\ts = reg_getline_submatch(slnum) + scol;\n\tif (slnum == elnum)\n\t{\n\t    if (list_append_string(list, s, ecol - scol) == FAIL)\n\t\terror = TRUE;\n\t}\n\telse\n\t{\n\t    if (list_append_string(list, s, -1) == FAIL)\n\t\terror = TRUE;\n\t    for (i = 1; i < elnum - slnum; i++)\n\t    {\n\t\ts = reg_getline_submatch(slnum + i);\n\t\tif (list_append_string(list, s, -1) == FAIL)\n\t\t    error = TRUE;\n\t    }\n\t    s = reg_getline_submatch(elnum);\n\t    if (list_append_string(list, s, ecol) == FAIL)\n\t\terror = TRUE;\n\t}\n    }\n    else\n    {\n\ts = rsm.sm_match->startp[no];\n\tif (s == NULL || rsm.sm_match->endp[no] == NULL)\n\t    return NULL;\n\tlist = list_alloc();\n\tif (list == NULL)\n\t    return NULL;\n\tif (list_append_string(list, s,\n\t\t\t\t (int)(rsm.sm_match->endp[no] - s)) == FAIL)\n\t    error = TRUE;\n    }\n\n    if (error)\n    {\n\tlist_free(list);\n\treturn NULL;\n    }\n    ++list->lv_refcount;\n    return list;\n}\n#endif\n\n/*\n * Initialize the values used for matching against multiple lines\n */\n    static void\ninit_regexec_multi(\n\tregmmatch_T\t*rmp,\n\twin_T\t\t*win,\t// window in which to search or NULL\n\tbuf_T\t\t*buf,\t// buffer in which to search\n\tlinenr_T\tlnum)\t// nr of line to start looking for match\n{\n    rex.reg_match = NULL;\n    rex.reg_mmatch = rmp;\n    rex.reg_buf = buf;\n    rex.reg_win = win;\n    rex.reg_firstlnum = lnum;\n    rex.reg_maxline = rex.reg_buf->b_ml.ml_line_count - lnum;\n    rex.reg_line_lbr = FALSE;\n    rex.reg_ic = rmp->rmm_ic;\n    rex.reg_icombine = FALSE;\n    rex.reg_maxcol = rmp->rmm_maxcol;\n}\n\n#include \"regexp_bt.c\"\n\nstatic regengine_T bt_regengine =\n{\n    bt_regcomp,\n    bt_regfree,\n    bt_regexec_nl,\n    bt_regexec_multi,\n};\n\n#include \"regexp_nfa.c\"\n\nstatic regengine_T nfa_regengine =\n{\n    nfa_regcomp,\n    nfa_regfree,\n    nfa_regexec_nl,\n    nfa_regexec_multi,\n};\n\n// Which regexp engine to use? Needed for vim_regcomp().\n// Must match with 'regexpengine'.\nstatic int regexp_engine = 0;\n\n#ifdef DEBUG\nstatic char_u regname[][30] = {\n\t\t    \"AUTOMATIC Regexp Engine\",\n\t\t    \"BACKTRACKING Regexp Engine\",\n\t\t    \"NFA Regexp Engine\"\n\t\t\t    };\n#endif\n\n/*\n * Compile a regular expression into internal code.\n * Returns the program in allocated memory.\n * Use vim_regfree() to free the memory.\n * Returns NULL for an error.\n */\n    regprog_T *\nvim_regcomp(char_u *expr_arg, int re_flags)\n{\n    regprog_T   *prog = NULL;\n    char_u\t*expr = expr_arg;\n    int\t\tcalled_emsg_before;\n\n    regexp_engine = p_re;\n\n    // Check for prefix \"\\%#=\", that sets the regexp engine\n    if (STRNCMP(expr, \"\\\\%#=\", 4) == 0)\n    {\n\tint newengine = expr[4] - '0';\n\n\tif (newengine == AUTOMATIC_ENGINE\n\t    || newengine == BACKTRACKING_ENGINE\n\t    || newengine == NFA_ENGINE)\n\t{\n\t    regexp_engine = expr[4] - '0';\n\t    expr += 5;\n#ifdef DEBUG\n\t    smsg(\"New regexp mode selected (%d): %s\",\n\t\t\t\t\t   regexp_engine, regname[newengine]);\n#endif\n\t}\n\telse\n\t{\n\t    emsg(_(e_percent_hash_can_only_be_followed_by_zero_one_two_automatic_engine_will_be_used));\n\t    regexp_engine = AUTOMATIC_ENGINE;\n\t}\n    }\n#ifdef DEBUG\n    bt_regengine.expr = expr;\n    nfa_regengine.expr = expr;\n#endif\n    // reg_iswordc() uses rex.reg_buf\n    rex.reg_buf = curbuf;\n\n    /*\n     * First try the NFA engine, unless backtracking was requested.\n     */\n    called_emsg_before = called_emsg;\n    if (regexp_engine != BACKTRACKING_ENGINE)\n\tprog = nfa_regengine.regcomp(expr,\n\t\tre_flags + (regexp_engine == AUTOMATIC_ENGINE ? RE_AUTO : 0));\n    else\n\tprog = bt_regengine.regcomp(expr, re_flags);\n\n    // Check for error compiling regexp with initial engine.\n    if (prog == NULL)\n    {\n#ifdef BT_REGEXP_DEBUG_LOG\n\tif (regexp_engine == BACKTRACKING_ENGINE)   // debugging log for BT engine\n\t{\n\t    FILE *f;\n\t    f = fopen(BT_REGEXP_DEBUG_LOG_NAME, \"a\");\n\t    if (f)\n\t    {\n\t\tfprintf(f, \"Syntax error in \\\"%s\\\"\\n\", expr);\n\t\tfclose(f);\n\t    }\n\t    else\n\t\tsemsg(\"(NFA) Could not open \\\"%s\\\" to write !!!\",\n\t\t\tBT_REGEXP_DEBUG_LOG_NAME);\n\t}\n#endif\n\t/*\n\t * If the NFA engine failed, try the backtracking engine.\n\t * The NFA engine also fails for patterns that it can't handle well\n\t * but are still valid patterns, thus a retry should work.\n\t * But don't try if an error message was given.\n\t */\n\tif (regexp_engine == AUTOMATIC_ENGINE\n\t\t\t\t\t  && called_emsg == called_emsg_before)\n\t{\n\t    regexp_engine = BACKTRACKING_ENGINE;\n#ifdef FEAT_EVAL\n\t    report_re_switch(expr);\n#endif\n\t    prog = bt_regengine.regcomp(expr, re_flags);\n\t}\n    }\n\n    if (prog != NULL)\n    {\n\t// Store the info needed to call regcomp() again when the engine turns\n\t// out to be very slow when executing it.\n\tprog->re_engine = regexp_engine;\n\tprog->re_flags  = re_flags;\n    }\n\n    return prog;\n}\n\n/*\n * Free a compiled regexp program, returned by vim_regcomp().\n */\n    void\nvim_regfree(regprog_T *prog)\n{\n    if (prog != NULL)\n\tprog->engine->regfree(prog);\n}\n\n#if defined(EXITFREE) || defined(PROTO)\n    void\nfree_regexp_stuff(void)\n{\n    ga_clear(&regstack);\n    ga_clear(&backpos);\n    vim_free(reg_tofree);\n    vim_free(reg_prev_sub);\n}\n#endif\n\n#ifdef FEAT_EVAL\n    static void\nreport_re_switch(char_u *pat)\n{\n    if (p_verbose > 0)\n    {\n\tverbose_enter();\n\tmsg_puts(_(\"Switching to backtracking RE engine for pattern: \"));\n\tmsg_puts((char *)pat);\n\tverbose_leave();\n    }\n}\n#endif\n\n#if defined(FEAT_X11) || defined(PROTO)\n/*\n * Return whether \"prog\" is currently being executed.\n */\n    int\nregprog_in_use(regprog_T *prog)\n{\n    return prog->re_in_use;\n}\n#endif\n\n/*\n * Match a regexp against a string.\n * \"rmp->regprog\" must be a compiled regexp as returned by vim_regcomp().\n * Note: \"rmp->regprog\" may be freed and changed.\n * Uses curbuf for line count and 'iskeyword'.\n * When \"nl\" is TRUE consider a \"\\n\" in \"line\" to be a line break.\n *\n * Return TRUE if there is a match, FALSE if not.\n */\n    static int\nvim_regexec_string(\n    regmatch_T\t*rmp,\n    char_u\t*line,  // string to match against\n    colnr_T\tcol,    // column to start looking for match\n    int\t\tnl)\n{\n    int\t\tresult;\n    regexec_T\trex_save;\n    int\t\trex_in_use_save = rex_in_use;\n\n    // Cannot use the same prog recursively, it contains state.\n    if (rmp->regprog->re_in_use)\n    {\n\temsg(_(e_cannot_use_pattern_recursively));\n\treturn FALSE;\n    }\n    rmp->regprog->re_in_use = TRUE;\n\n    if (rex_in_use)\n\t// Being called recursively, save the state.\n\trex_save = rex;\n    rex_in_use = TRUE;\n\n    rex.reg_startp = NULL;\n    rex.reg_endp = NULL;\n    rex.reg_startpos = NULL;\n    rex.reg_endpos = NULL;\n\n    result = rmp->regprog->engine->regexec_nl(rmp, line, col, nl);\n    rmp->regprog->re_in_use = FALSE;\n\n    // NFA engine aborted because it's very slow.\n    if (rmp->regprog->re_engine == AUTOMATIC_ENGINE\n\t\t\t\t\t       && result == NFA_TOO_EXPENSIVE)\n    {\n\tint    save_p_re = p_re;\n\tint    re_flags = rmp->regprog->re_flags;\n\tchar_u *pat = vim_strsave(((nfa_regprog_T *)rmp->regprog)->pattern);\n\n\tp_re = BACKTRACKING_ENGINE;\n\tvim_regfree(rmp->regprog);\n\tif (pat != NULL)\n\t{\n#ifdef FEAT_EVAL\n\t    report_re_switch(pat);\n#endif\n\t    rmp->regprog = vim_regcomp(pat, re_flags);\n\t    if (rmp->regprog != NULL)\n\t    {\n\t\trmp->regprog->re_in_use = TRUE;\n\t\tresult = rmp->regprog->engine->regexec_nl(rmp, line, col, nl);\n\t\trmp->regprog->re_in_use = FALSE;\n\t    }\n\t    vim_free(pat);\n\t}\n\n\tp_re = save_p_re;\n    }\n\n    rex_in_use = rex_in_use_save;\n    if (rex_in_use)\n\trex = rex_save;\n\n    return result > 0;\n}\n\n/*\n * Note: \"*prog\" may be freed and changed.\n * Return TRUE if there is a match, FALSE if not.\n */\n    int\nvim_regexec_prog(\n    regprog_T\t**prog,\n    int\t\tignore_case,\n    char_u\t*line,\n    colnr_T\tcol)\n{\n    int\t\tr;\n    regmatch_T\tregmatch;\n\n    regmatch.regprog = *prog;\n    regmatch.rm_ic = ignore_case;\n    r = vim_regexec_string(&regmatch, line, col, FALSE);\n    *prog = regmatch.regprog;\n    return r;\n}\n\n/*\n * Note: \"rmp->regprog\" may be freed and changed.\n * Return TRUE if there is a match, FALSE if not.\n */\n    int\nvim_regexec(regmatch_T *rmp, char_u *line, colnr_T col)\n{\n    return vim_regexec_string(rmp, line, col, FALSE);\n}\n\n/*\n * Like vim_regexec(), but consider a \"\\n\" in \"line\" to be a line break.\n * Note: \"rmp->regprog\" may be freed and changed.\n * Return TRUE if there is a match, FALSE if not.\n */\n    int\nvim_regexec_nl(regmatch_T *rmp, char_u *line, colnr_T col)\n{\n    return vim_regexec_string(rmp, line, col, TRUE);\n}\n\n/*\n * Match a regexp against multiple lines.\n * \"rmp->regprog\" must be a compiled regexp as returned by vim_regcomp().\n * Note: \"rmp->regprog\" may be freed and changed, even set to NULL.\n * Uses curbuf for line count and 'iskeyword'.\n *\n * Return zero if there is no match.  Return number of lines contained in the\n * match otherwise.\n */\n    long\nvim_regexec_multi(\n    regmmatch_T *rmp,\n    win_T       *win,\t\t// window in which to search or NULL\n    buf_T       *buf,\t\t// buffer in which to search\n    linenr_T\tlnum,\t\t// nr of line to start looking for match\n    colnr_T\tcol,\t\t// column to start looking for match\n    int\t\t*timed_out)\t// flag is set when timeout limit reached\n{\n    int\t\tresult;\n    regexec_T\trex_save;\n    int\t\trex_in_use_save = rex_in_use;\n\n    // Cannot use the same prog recursively, it contains state.\n    if (rmp->regprog->re_in_use)\n    {\n\temsg(_(e_cannot_use_pattern_recursively));\n\treturn FALSE;\n    }\n    rmp->regprog->re_in_use = TRUE;\n\n    if (rex_in_use)\n\t// Being called recursively, save the state.\n\trex_save = rex;\n    rex_in_use = TRUE;\n\n    result = rmp->regprog->engine->regexec_multi(\n\t\t\t\t      rmp, win, buf, lnum, col, timed_out);\n    rmp->regprog->re_in_use = FALSE;\n\n    // NFA engine aborted because it's very slow.\n    if (rmp->regprog->re_engine == AUTOMATIC_ENGINE\n\t\t\t\t\t       && result == NFA_TOO_EXPENSIVE)\n    {\n\tint    save_p_re = p_re;\n\tint    re_flags = rmp->regprog->re_flags;\n\tchar_u *pat = vim_strsave(((nfa_regprog_T *)rmp->regprog)->pattern);\n\n\tp_re = BACKTRACKING_ENGINE;\n\tif (pat != NULL)\n\t{\n\t    regprog_T *prev_prog = rmp->regprog;\n\n#ifdef FEAT_EVAL\n\t    report_re_switch(pat);\n#endif\n#ifdef FEAT_SYN_HL\n\t    // checking for \\z misuse was already done when compiling for NFA,\n\t    // allow all here\n\t    reg_do_extmatch = REX_ALL;\n#endif\n\t    rmp->regprog = vim_regcomp(pat, re_flags);\n#ifdef FEAT_SYN_HL\n\t    reg_do_extmatch = 0;\n#endif\n\t    if (rmp->regprog == NULL)\n\t    {\n\t\t// Somehow compiling the pattern failed now, put back the\n\t\t// previous one to avoid \"regprog\" becoming NULL.\n\t\trmp->regprog = prev_prog;\n\t    }\n\t    else\n\t    {\n\t\tvim_regfree(prev_prog);\n\n\t\trmp->regprog->re_in_use = TRUE;\n\t\tresult = rmp->regprog->engine->regexec_multi(\n\t\t\t\t      rmp, win, buf, lnum, col, timed_out);\n\t\trmp->regprog->re_in_use = FALSE;\n\t    }\n\t    vim_free(pat);\n\t}\n\tp_re = save_p_re;\n    }\n\n    rex_in_use = rex_in_use_save;\n    if (rex_in_use)\n\trex = rex_save;\n\n    return result <= 0 ? 0 : result;\n}\n", "\" Tests for regexp in utf8 encoding\n\nsource shared.vim\n\nfunc s:equivalence_test()\n  let str = \"A\u0413\u0496\u0413\u0492\u0413\u04ee\u0413\u0493\u0413\u201e\u0413\u2026\u0414\u0496\u0414\u04ee\u0414\u201e\u0417\u049a\u0417\u04bb\u0417\u00a0\u0417\u04d9\u0418\u04ee\u0418\u04b0\u0418\u04d9\u0431\u0451\u0496\u0431\u04d9\u00a0\u0431\u04d9\u045e\u0431\u04d9\u04e8\u0431\u04d9\u04b0\u0431\u04d9\u0401\u0431\u04d9\u04d8\u0431\u04d9\u00ac\u0431\u04d9\u00ae\u0431\u04d9\u00b0\u0431\u04d9\u0406\u0431\u04d9\u0499\u0431\u04d9\u00b6 B\u0416\u0492\u0419\u0493\u0431\u0451\u04ee\u0431\u0451\u201e\u0431\u0451\u04b6 C\u0413\u04ae\u0414\u04b6\u0414\u04b2\u0414\u04a0\u0414\u04a2\u0416\u04ae\u0418\u00bb\u0431\u0451\u04b2\u043a\u04bb\u2019 D\u0414\u04ba\u0414\u0497\u0416\u04a0\u0431\u0451\u04a0\u0431\u0451\u04a2\u0431\u0451\u04ba\u0431\u0451\u0497\u0431\u0451\u2019 E\u0413\u04b2\u0413\u04af\u0413\u04a0\u0413\u04e2\u0414\u2019\u0414\u201d\u0414\u2013\u0414\u04b3\u0414\u04a1\u0418\u201e\u0418\u04b6\u0418\u0401\u0419\u04b6\u0431\u0451\u201d\u0431\u0451\u2013\u0431\u0451\u04b3\u0431\u0451\u04a1\u0431\u0451\u04a3\u0431\u04d9\u0451\u0431\u04d9\u04d9\u0431\u04d9\u0458\u0431\u04d9\u04ab\u0431\u00bb\u0496\u0431\u00bb\u04ee\u0431\u00bb\u201e\u0431\u00bb\u04b6 F\u0416\u2018\u0431\u0451\u04bb\u043a\u04bb\u04b3 G\u0414\u04a3\u0414\u04bb\u0414\u00a0\u0414\u045e\u0416\u201c\u0417\u04e8\u0417\u04b0\u0417\u0499\u0431\u0451\u00a0\u043a\u04bb\u00a0 H\u0414\u04e8\u0414\u04b0\u0418\u04bb\u0431\u0451\u045e\u0431\u0451\u04e8\u0431\u0451\u04b0\u0431\u0451\u0401\u0431\u0451\u04d8\u0432\u04b1\u00a7 I\u0413\u04a2\u0413\u049a\u0413\u04ba\u0413\u04b8\u0414\u0401\u0414\u04d8\u0414\u00ac\u0414\u00ae\u0414\u00b0\u0416\u2014\u0417\u04b8\u0418\u04b2\u0418\u04a0\u0431\u0451\u00ac\u0431\u0451\u00ae\u0431\u00bb\u04b2\u0431\u00bb\u04a0 J\u0414\u0499\u0419\u04b2 K\u0414\u00b6\u0416\u04b3\u0417\u0401\u0431\u0451\u00b0\u0431\u0451\u0406\u0431\u0451\u0499\u0432\u04b1\u00a9\u043a\u049b\u0496 L\u0414\u2116\u0414\u00bb\u0414\u04aa\u0414\u049d\u0415\u0492\u0418\u04aa\u0431\u0451\u00b6\u0431\u0451\u0451\u0431\u0451\u04d9\u0431\u0451\u0458\u0432\u04b1\u00a0 M\u0431\u0451\u04ab\u0431\u2116\u0496\u0431\u2116\u04ee N\u0413\u2018\u0415\u0493\u0415\u2026\u0415\u04ae\u0417\u0451\u0431\u2116\u201e\u0431\u2116\u04b6\u0431\u2116\u04b2\u0431\u2116\u04a0\u043a\u04bb\u04e8 O\u0413\u2019\u0413\u201c\u0413\u201d\u0413\u2022\u0413\u2013\u0413\u04b3\u0415\u04a2\u0415\u04ba\u0415\u0497\u0416\u04b9\u0416\u00a0\u0417\u2018\u0417\u04d8\u0417\u00ac\u0417\u04ab\u0418\u04a2\u0418\u04ba\u0418\u04d8\u0418\u00ac\u0418\u00ae\u0418\u00b0\u0431\u2116\u04a2\u0431\u2116\u04ba\u0431\u2116\u0497\u0431\u2116\u2019\u0431\u00bb\u04a2\u0431\u00bb\u04ba\u0431\u00bb\u0497\u0431\u00bb\u2019\u0431\u00bb\u201d\u0431\u00bb\u2013\u0431\u00bb\u04b3\u0431\u00bb\u04a1\u0431\u00bb\u04a3\u0431\u00bb\u04bb\u0431\u00bb\u00a0\u0431\u00bb\u045e P\u0416\u04e8\u0431\u2116\u201d\u0431\u2116\u2013\u0432\u04b1\u0408 Q\u0419\u04a0 R\u0415\u201d\u0415\u2013\u0415\u04b3\u0418\u0497\u0418\u2019\u0419\u04a2\u0431\u2116\u04b3\u0431\u2116\u04a1\u0431\u2116\u04a3\u0431\u2116\u04bb\u0432\u04b1\u04e8\u043a\u04bb\u04b0 S\u0415\u04a1\u0415\u04a3\u0415\u04bb\u0415\u00a0\u0418\u04b3\u0431\u2116\u00a0\u0431\u2116\u045e\u0431\u2116\u04e8\u0431\u2116\u04b0\u0431\u2116\u0401\u0432\u04b1\u04ab\u043a\u04bb\u0401 T\u0415\u045e\u0415\u04e8\u0415\u04b0\u0416\u00ac\u0416\u00ae\u0418\u04a1\u0418\u04ab\u0431\u2116\u04d8\u0431\u2116\u00ac\u0431\u2116\u00ae\u0431\u2116\u00b0 U\u0413\u04b7\u0413\u04a1\u0413\u04e3\u0413\u04a3\u0415\u0401\u0415\u04d8\u0415\u00ac\u0415\u00ae\u0415\u00b0\u0416\u049c\u0417\u2022\u0417\u04b7\u0417\u04e3\u0417\u201c\u0417\u2014\u0418\u201d\u0418\u2013\u0419\u201e\u0431\u2116\u0406\u0431\u2116\u0499\u0431\u2116\u00b6\u0431\u2116\u0451\u0431\u2116\u04d9\u0431\u00bb\u04e8\u0431\u00bb\u04b0\u0431\u00bb\u0401\u0431\u00bb\u04d8\u0431\u00bb\u00ac\u0431\u00bb\u00ae\u0431\u00bb\u00b0  V\u0416\u0406\u0431\u2116\u0458\u0431\u2116\u04ab W\u0415\u0499\u0431\u04d9\u0496\u0431\u04d9\u04ee\u0431\u04d9\u201e\u0431\u04d9\u04b6\u0431\u04d9\u04b2 X\u0431\u04d9\u04a0\u0431\u04d9\u04a2 Y\u0413\u049b\u0415\u00b6\u0415\u0451\u0416\u0456\u0418\u0406\u0419\u04ba\u0431\u04d9\u04ba\u0431\u00bb\u0406\u0431\u00bb\u0499\u0431\u00bb\u00b6\u0431\u00bb\u0451 Z\u0415\u2116\u0415\u00bb\u0415\u04aa\u0416\u04e9\u0431\u04d9\u0497\u0431\u04d9\u2019\u0431\u04d9\u201d\u0432\u04b1\u00ab a\u0413\u00a0\u0413\u040e\u0413\u045e\u0413\u0408\u0413\u04e8\u0413\u0498\u0414\u0492\u0414\u0493\u0414\u2026\u0417\u04ba\u0417\u04b9\u0417\u040e\u0417\u00bb\u0418\u0493\u0418\u00a7\u0431\u00b6\u04b8\u0431\u0451\u0492\u0431\u04d9\u04a1\u0431\u04d9\u040e\u0431\u04d9\u0408\u0431\u04d9\u0498\u0431\u04d9\u00a7\u0431\u04d9\u00a9\u0431\u04d9\u00ab\u0431\u04d9\u04ef\u0431\u04d9\u049c\u0431\u04d9\u04b1\u0431\u04d9\u0456\u0431\u04d9\u04e9\u0431\u04d9\u00b7\u0432\u04b1\u0498 b\u0416\u0496\u0419\u201c\u0431\u04e9\u00ac\u0431\u00b6\u0496\u0431\u0451\u0493\u0431\u0451\u2026\u0431\u0451\u04ae c\u0413\u00a7\u0414\u04ae\u0414\u04af\u0414\u04e2\u0414\u049a\u0416\u04b2\u0418\u0458\u0431\u0451\u04af\u043a\u04bb\u201c\u043a\u04bb\u201d d\u0414\u04b8\u0414\u2018\u0419\u2014\u0431\u04e9\u04ef\u0431\u00b6\u0492\u0431\u00b6\u2018\u0431\u0451\u04e2\u0431\u0451\u049a\u0431\u0451\u04b8\u0431\u0451\u2018\u0431\u0451\u201c e\u0413\u0401\u0413\u00a9\u0413\u04d8\u0413\u00ab\u0414\u201c\u0414\u2022\u0414\u2014\u0414\u04b7\u0414\u04e3\u0418\u2026\u0418\u04ae\u0418\u00a9\u0419\u04ae\u0431\u00b6\u2019\u0431\u0451\u2022\u0431\u0451\u2014\u0431\u0451\u04b7\u0431\u0451\u04e3\u0431\u0451\u049b\u0431\u04d9\u2116\u0431\u04d9\u00bb\u0431\u04d9\u04aa\u0431\u04d9\u049d\u0431\u00bb\u0492\u0431\u00bb\u0493\u0431\u00bb\u2026\u0431\u00bb\u04ae f\u0416\u2019\u0431\u04e9\u00ae\u0431\u00b6\u04ee\u0431\u0451\u04b9\u043a\u04bb\u04b7 g\u0414\u049b\u0414\u04b9\u0414\u040e\u0414\u0408\u0417\u0498\u0417\u00a7\u0417\u04e9\u0419\u00a0\u0431\u00b6\u0493\u0431\u0451\u040e\u043a\u04bb\u040e h\u0414\u0498\u0414\u00a7\u0418\u04b9\u0431\u0451\u0408\u0431\u0451\u0498\u0431\u0451\u00a7\u0431\u0451\u00a9\u0431\u0451\u00ab\u0431\u04d9\u2013\u0432\u04b1\u0401\u043a\u04bb\u2022 i\u0413\u00ac\u0413\u04ef\u0413\u00ae\u0413\u049c\u0414\u00a9\u0414\u00ab\u0414\u04ef\u0414\u049c\u0417\u0497\u0418\u04af\u0418\u04e2\u0419\u0401\u0431\u00b6\u2013\u0431\u0451\u04ef\u0431\u0451\u049c\u0431\u00bb\u04af\u0431\u00bb\u04e2 j\u0414\u04e9\u0417\u00b0\u0419\u04af k\u0414\u00b7\u0416\u04b7\u0417\u00a9\u0431\u00b6\u201e\u0431\u0451\u04b1\u0431\u0451\u0456\u0431\u0451\u04e9\u0432\u04b1\u04d8\u043a\u049b\u0492 l\u0414\u04d9\u0414\u0458\u0414\u04ab\u0415\u0496\u0415\u04ee\u0416\u04a1\u0431\u0451\u00b7\u0431\u0451\u2116\u0431\u0451\u00bb\u0431\u0451\u04aa\u0432\u04b1\u040e m\u0431\u04e9\u049c\u0431\u0451\u049d\u0431\u2116\u0492\u0431\u2116\u0493 n\u0413\u04b1\u0415\u201e\u0415\u04b6\u0415\u04b2\u0415\u04af\u0417\u2116\u0431\u04e9\u00b0\u0431\u00b6\u04ae\u0431\u2116\u2026\u0431\u2116\u04ae\u0431\u2116\u04af\u0431\u2116\u04e2\u043a\u04bb\u0498 o\u0413\u0406\u0413\u0456\u0413\u0499\u0413\u04e9\u0413\u00b6\u0413\u0451\u0415\u049a\u0415\u04b8\u0415\u2018\u0416\u040e\u0417\u2019\u0417\u00ab\u0417\u04ef\u0417\u049d\u0418\u049a\u0418\u04b8\u0418\u00ab\u0418\u04ef\u0418\u049c\u0418\u04b1\u0419\u04e9\u0431\u2116\u049a\u0431\u2116\u04b8\u0431\u2116\u2018\u0431\u2116\u201c\u0431\u00bb\u049a\u0431\u00bb\u04b8\u0431\u00bb\u2018\u0431\u00bb\u201c\u0431\u00bb\u2022\u0431\u00bb\u2014\u0431\u00bb\u04b7\u0431\u00bb\u04e3\u0431\u00bb\u049b\u0431\u00bb\u04b9\u0431\u00bb\u040e\u0431\u00bb\u0408 p\u0416\u0498\u0431\u04e9\u04b1\u0431\u04e9\u04aa\u0431\u00b6\u04b2\u0431\u2116\u2022\u0431\u2116\u2014 q\u0419\u04e2\u041a\u00a0 r\u0415\u2022\u0415\u2014\u0415\u04b7\u0418\u2018\u0418\u201c\u0419\u049a\u0419\u04aa\u0431\u04e9\u0406\u0431\u04e9\u0456\u0431\u00b6\u04af\u0431\u2116\u04e3\u0431\u2116\u049b\u0431\u2116\u04b9\u043a\u04bb\u00a7 s\u0415\u04e3\u0415\u049b\u0415\u04b9\u0415\u040e\u0418\u04b7\u0418\u049d\u0431\u04e9\u0499\u0431\u00b6\u04a0\u0431\u2116\u040e\u0431\u2116\u0408\u0431\u2116\u0498\u0431\u2116\u00a7\u0431\u2116\u00a9\u043a\u04bb\u00a9 t\u0415\u0408\u0415\u0498\u0415\u00a7\u0416\u00ab\u0416\u04ef\u0418\u04e3\u041a\u04b2\u0431\u04e9\u04e9\u0431\u2116\u00ab\u0431\u2116\u04ef\u0431\u2116\u049c\u0431\u2116\u04b1\u0431\u04d9\u2014\u0432\u04b1\u04b0 u\u0413\u2116\u0413\u04d9\u0413\u00bb\u0413\u0458\u0415\u00a9\u0415\u00ab\u0415\u04ef\u0415\u049c\u0415\u04b1\u0415\u0456\u0417\u04a1\u0417\u2013\u0416\u00b0\u0417\u201d\u0417\u04b3\u0417\u04a3\u0418\u2022\u0418\u2014\u041a\u04af\u0431\u04e9\u04ab\u0431\u00b6\u04b7\u0431\u2116\u0456\u0431\u2116\u04e9\u0431\u2116\u00b7\u0431\u2116\u2116\u0431\u2116\u00bb\u0431\u00bb\u0498\u0431\u00bb\u00a7\u0431\u00bb\u00a9\u0431\u00bb\u00ab\u0431\u00bb\u04ef\u0431\u00bb\u049c\u0431\u00bb\u04b1 v\u041a\u04e2\u0431\u00b6\u04a2\u0431\u2116\u04aa\u0431\u2116\u049d w\u0415\u04e9\u0431\u04d9\u0492\u0431\u04d9\u0493\u0431\u04d9\u2026\u0431\u04d9\u04ae\u0431\u04d9\u04af\u0431\u04d9\u04b3 x\u0431\u04d9\u04e2\u0431\u04d9\u049a y\u0413\u04aa\u0413\u049d\u0415\u00b7\u0416\u0499\u0418\u0456\u0419\u04b8\u0431\u04d9\u04b8\u0431\u04d9\u04b7\u0431\u00bb\u0456\u0431\u00bb\u04e9\u0431\u00bb\u00b7\u0431\u00bb\u2116 z\u0415\u04d9\u0415\u0458\u0415\u04ab\u0416\u00b6\u0431\u04e9\u00b6\u0431\u00b6\u04ba\u0431\u04d9\u2018\u0431\u04d9\u201c\u0431\u04d9\u2022\u0432\u04b1\u00ac\"\n  let groups = split(str)\n  for group1 in groups\n      for c in split(group1, '\\zs')\n\t\" next statement confirms that equivalence class matches every\n\t\" character in group\n        call assert_match('^[[=' .. c .. '=]]*$', group1)\n        for group2 in groups\n          if group2 != group1\n\t    \" next statement converts that equivalence class doesn't match\n\t    \" character in any other group\n            call assert_equal(-1, match(group2, '[[=' .. c .. '=]]'), c)\n          endif\n        endfor\n      endfor\n  endfor\nendfunc\n\nfunc Test_equivalence_re1()\n  set re=1\n  call s:equivalence_test()\n  set re=0\nendfunc\n\nfunc Test_equivalence_re2()\n  set re=2\n  call s:equivalence_test()\n  set re=0\nendfunc\n\nfunc s:classes_test()\n  if has('win32')\n    set iskeyword=@,48-57,_,192-255\n  endif\n  set isprint=@,161-255\n  call assert_equal('Mot\u0413\u00b6rhead', matchstr('Mot\u0413\u00b6rhead', '[[:print:]]\\+'))\n\n  let alnumchars = ''\n  let alphachars = ''\n  let backspacechar = ''\n  let blankchars = ''\n  let cntrlchars = ''\n  let digitchars = ''\n  let escapechar = ''\n  let graphchars = ''\n  let lowerchars = ''\n  let printchars = ''\n  let punctchars = ''\n  let returnchar = ''\n  let spacechars = ''\n  let tabchar = ''\n  let upperchars = ''\n  let xdigitchars = ''\n  let identchars = ''\n  let identchars1 = ''\n  let kwordchars = ''\n  let kwordchars1 = ''\n  let fnamechars = ''\n  let fnamechars1 = ''\n  let i = 1\n  while i <= 255\n    let c = nr2char(i)\n    if c =~ '[[:alpha:]]'\n      let alphachars .= c\n    endif\n    if c =~ '[[:alnum:]]'\n      let alnumchars .= c\n    endif\n    if c =~ '[[:backspace:]]'\n      let backspacechar .= c\n    endif\n    if c =~ '[[:blank:]]'\n      let blankchars .= c\n    endif\n    if c =~ '[[:cntrl:]]'\n      let cntrlchars .= c\n    endif\n    if c =~ '[[:digit:]]'\n      let digitchars .= c\n    endif\n    if c =~ '[[:escape:]]'\n      let escapechar .= c\n    endif\n    if c =~ '[[:graph:]]'\n      let graphchars .= c\n    endif\n    if c =~ '[[:lower:]]'\n      let lowerchars .= c\n    endif\n    if c =~ '[[:print:]]'\n      let printchars .= c\n    endif\n    if c =~ '[[:punct:]]'\n      let punctchars .= c\n    endif\n    if c =~ '[[:return:]]'\n      let returnchar .= c\n    endif\n    if c =~ '[[:space:]]'\n      let spacechars .= c\n    endif\n    if c =~ '[[:tab:]]'\n      let tabchar .= c\n    endif\n    if c =~ '[[:upper:]]'\n      let upperchars .= c\n    endif\n    if c =~ '[[:xdigit:]]'\n      let xdigitchars .= c\n    endif\n    if c =~ '[[:ident:]]'\n      let identchars .= c\n    endif\n    if c =~ '\\i'\n      let identchars1 .= c\n    endif\n    if c =~ '[[:keyword:]]'\n      let kwordchars .= c\n    endif\n    if c =~ '\\k'\n      let kwordchars1 .= c\n    endif\n    if c =~ '[[:fname:]]'\n      let fnamechars .= c\n    endif\n    if c =~ '\\f'\n      let fnamechars1 .= c\n    endif\n    let i += 1\n  endwhile\n\n  call assert_equal('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz', alphachars)\n  call assert_equal('0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz', alnumchars)\n  call assert_equal(\"\\b\", backspacechar)\n  call assert_equal(\"\\t \", blankchars)\n  call assert_equal(\"\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\b\\t\\n\\x0b\\f\\r\\x0e\\x0f\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\\x18\\x19\\x1a\\e\\x1c\\x1d\\x1e\\x1f\\x7f\", cntrlchars)\n  call assert_equal(\"0123456789\", digitchars)\n  call assert_equal(\"\\<Esc>\", escapechar)\n  call assert_equal('!\"#$%&''()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~', graphchars)\n  call assert_equal('abcdefghijklmnopqrstuvwxyz\u0412\u04e9\u0413\u04b9\u0413\u00a0\u0413\u040e\u0413\u045e\u0413\u0408\u0413\u04e8\u0413\u0498\u0413\u04b0\u0413\u00a7\u0413\u0401\u0413\u00a9\u0413\u04d8\u0413\u00ab\u0413\u00ac\u0413\u04ef\u0413\u00ae\u0413\u049c\u0413\u00b0\u0413\u04b1\u0413\u0406\u0413\u0456\u0413\u0499\u0413\u04e9\u0413\u00b6\u0413\u0451\u0413\u2116\u0413\u04d9\u0413\u00bb\u0413\u0458\u0413\u04aa\u0413\u04ab\u0413\u049d', lowerchars)\n  call assert_equal(' !\"#$%&''()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\u0412\u00a0\u0412\u040e\u0412\u045e\u0412\u0408\u0412\u04e8\u0412\u0498\u0412\u04b0\u0412\u00a7\u0412\u0401\u0412\u00a9\u0412\u04d8\u0412\u00ab\u0412\u00ac\u0412\u04ef\u0412\u00ae\u0412\u049c\u0412\u00b0\u0412\u04b1\u0412\u0406\u0412\u0456\u0412\u0499\u0412\u04e9\u0412\u00b6\u0412\u00b7\u0412\u0451\u0412\u2116\u0412\u04d9\u0412\u00bb\u0412\u0458\u0412\u04aa\u0412\u04ab\u0412\u049d\u0413\u0496\u0413\u0492\u0413\u04ee\u0413\u0493\u0413\u201e\u0413\u2026\u0413\u04b6\u0413\u04ae\u0413\u04b2\u0413\u04af\u0413\u04a0\u0413\u04e2\u0413\u04a2\u0413\u049a\u0413\u04ba\u0413\u04b8\u0413\u0497\u0413\u2018\u0413\u2019\u0413\u201c\u0413\u201d\u0413\u2022\u0413\u2013\u0413\u2014\u0413\u04b3\u0413\u04b7\u0413\u04a1\u0413\u04e3\u0413\u04a3\u0413\u049b\u0413\u04bb\u0413\u04b9\u0413\u00a0\u0413\u040e\u0413\u045e\u0413\u0408\u0413\u04e8\u0413\u0498\u0413\u04b0\u0413\u00a7\u0413\u0401\u0413\u00a9\u0413\u04d8\u0413\u00ab\u0413\u00ac\u0413\u04ef\u0413\u00ae\u0413\u049c\u0413\u00b0\u0413\u04b1\u0413\u0406\u0413\u0456\u0413\u0499\u0413\u04e9\u0413\u00b6\u0413\u00b7\u0413\u0451\u0413\u2116\u0413\u04d9\u0413\u00bb\u0413\u0458\u0413\u04aa\u0413\u04ab\u0413\u049d', printchars)\n  call assert_equal('!\"#$%&''()*+,-./:;<=>?@[\\]^_`{|}~', punctchars)\n  call assert_equal('ABCDEFGHIJKLMNOPQRSTUVWXYZ\u0413\u0496\u0413\u0492\u0413\u04ee\u0413\u0493\u0413\u201e\u0413\u2026\u0413\u04b6\u0413\u04ae\u0413\u04b2\u0413\u04af\u0413\u04a0\u0413\u04e2\u0413\u04a2\u0413\u049a\u0413\u04ba\u0413\u04b8\u0413\u0497\u0413\u2018\u0413\u2019\u0413\u201c\u0413\u201d\u0413\u2022\u0413\u2013\u0413\u04b3\u0413\u04b7\u0413\u04a1\u0413\u04e3\u0413\u04a3\u0413\u049b\u0413\u04bb', upperchars)\n  call assert_equal(\"\\r\", returnchar)\n  call assert_equal(\"\\t\\n\\x0b\\f\\r \", spacechars)\n  call assert_equal(\"\\t\", tabchar)\n  call assert_equal('0123456789ABCDEFabcdef', xdigitchars)\n\n  if has('win32')\n    let identchars_ok = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz\u0412\u0496\u0412\u0492\u0412\u04ee\u0412\u0493\u0412\u201e\u0412\u2026\u0412\u04b6\u0412\u04ae\u0412\u04b2\u0412\u04af\u0412\u04a0\u0412\u04e2\u0412\u04a2\u0412\u049a\u0412\u04ba\u0412\u04b8\u0412\u0497\u0412\u2018\u0412\u2019\u0412\u201c\u0412\u201d\u0412\u2022\u0412\u2013\u0412\u2014\u0412\u04b3\u0412\u04b7\u0412\u04a1\u0412\u04e3\u0412\u04a3\u0412\u049b\u0412\u04bb\u0412\u04b9\u0412\u00a0\u0412\u040e\u0412\u045e\u0412\u0408\u0412\u04e8\u0412\u0498\u0412\u04b0\u0412\u00a7\u0412\u04e9\u0413\u0496\u0413\u0492\u0413\u04ee\u0413\u0493\u0413\u201e\u0413\u2026\u0413\u04b6\u0413\u04ae\u0413\u04b2\u0413\u04af\u0413\u04a0\u0413\u04e2\u0413\u04a2\u0413\u049a\u0413\u04ba\u0413\u04b8\u0413\u0497\u0413\u2018\u0413\u2019\u0413\u201c\u0413\u201d\u0413\u2022\u0413\u2013\u0413\u04b3\u0413\u04b7\u0413\u04a1\u0413\u04e3\u0413\u04a3\u0413\u049b\u0413\u04bb\u0413\u04b9\u0413\u00a0\u0413\u040e\u0413\u045e\u0413\u0408\u0413\u04e8\u0413\u0498\u0413\u04b0\u0413\u00a7\u0413\u0401\u0413\u00a9\u0413\u04d8\u0413\u00ab\u0413\u00ac\u0413\u04ef\u0413\u00ae\u0413\u049c\u0413\u00b0\u0413\u04b1\u0413\u0406\u0413\u0456\u0413\u0499\u0413\u04e9\u0413\u00b6\u0413\u0451\u0413\u2116\u0413\u04d9\u0413\u00bb\u0413\u0458\u0413\u04aa\u0413\u04ab\u0413\u049d'\n    let kwordchars_ok = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz\u0412\u04e9\u0413\u0496\u0413\u0492\u0413\u04ee\u0413\u0493\u0413\u201e\u0413\u2026\u0413\u04b6\u0413\u04ae\u0413\u04b2\u0413\u04af\u0413\u04a0\u0413\u04e2\u0413\u04a2\u0413\u049a\u0413\u04ba\u0413\u04b8\u0413\u0497\u0413\u2018\u0413\u2019\u0413\u201c\u0413\u201d\u0413\u2022\u0413\u2013\u0413\u2014\u0413\u04b3\u0413\u04b7\u0413\u04a1\u0413\u04e3\u0413\u04a3\u0413\u049b\u0413\u04bb\u0413\u04b9\u0413\u00a0\u0413\u040e\u0413\u045e\u0413\u0408\u0413\u04e8\u0413\u0498\u0413\u04b0\u0413\u00a7\u0413\u0401\u0413\u00a9\u0413\u04d8\u0413\u00ab\u0413\u00ac\u0413\u04ef\u0413\u00ae\u0413\u049c\u0413\u00b0\u0413\u04b1\u0413\u0406\u0413\u0456\u0413\u0499\u0413\u04e9\u0413\u00b6\u0413\u00b7\u0413\u0451\u0413\u2116\u0413\u04d9\u0413\u00bb\u0413\u0458\u0413\u04aa\u0413\u04ab\u0413\u049d'\n  else\n    let identchars_ok = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz\u0412\u04e9\u0413\u0496\u0413\u0492\u0413\u04ee\u0413\u0493\u0413\u201e\u0413\u2026\u0413\u04b6\u0413\u04ae\u0413\u04b2\u0413\u04af\u0413\u04a0\u0413\u04e2\u0413\u04a2\u0413\u049a\u0413\u04ba\u0413\u04b8\u0413\u0497\u0413\u2018\u0413\u2019\u0413\u201c\u0413\u201d\u0413\u2022\u0413\u2013\u0413\u2014\u0413\u04b3\u0413\u04b7\u0413\u04a1\u0413\u04e3\u0413\u04a3\u0413\u049b\u0413\u04bb\u0413\u04b9\u0413\u00a0\u0413\u040e\u0413\u045e\u0413\u0408\u0413\u04e8\u0413\u0498\u0413\u04b0\u0413\u00a7\u0413\u0401\u0413\u00a9\u0413\u04d8\u0413\u00ab\u0413\u00ac\u0413\u04ef\u0413\u00ae\u0413\u049c\u0413\u00b0\u0413\u04b1\u0413\u0406\u0413\u0456\u0413\u0499\u0413\u04e9\u0413\u00b6\u0413\u00b7\u0413\u0451\u0413\u2116\u0413\u04d9\u0413\u00bb\u0413\u0458\u0413\u04aa\u0413\u04ab\u0413\u049d'\n    let kwordchars_ok = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz\u0412\u04e9\u0413\u0496\u0413\u0492\u0413\u04ee\u0413\u0493\u0413\u201e\u0413\u2026\u0413\u04b6\u0413\u04ae\u0413\u04b2\u0413\u04af\u0413\u04a0\u0413\u04e2\u0413\u04a2\u0413\u049a\u0413\u04ba\u0413\u04b8\u0413\u0497\u0413\u2018\u0413\u2019\u0413\u201c\u0413\u201d\u0413\u2022\u0413\u2013\u0413\u2014\u0413\u04b3\u0413\u04b7\u0413\u04a1\u0413\u04e3\u0413\u04a3\u0413\u049b\u0413\u04bb\u0413\u04b9\u0413\u00a0\u0413\u040e\u0413\u045e\u0413\u0408\u0413\u04e8\u0413\u0498\u0413\u04b0\u0413\u00a7\u0413\u0401\u0413\u00a9\u0413\u04d8\u0413\u00ab\u0413\u00ac\u0413\u04ef\u0413\u00ae\u0413\u049c\u0413\u00b0\u0413\u04b1\u0413\u0406\u0413\u0456\u0413\u0499\u0413\u04e9\u0413\u00b6\u0413\u00b7\u0413\u0451\u0413\u2116\u0413\u04d9\u0413\u00bb\u0413\u0458\u0413\u04aa\u0413\u04ab\u0413\u049d'\n  endif\n\n  if has('win32')\n    let fnamechars_ok = '!#$%+,-./0123456789:=@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]_abcdefghijklmnopqrstuvwxyz{}~\u0412\u00a0\u0412\u040e\u0412\u045e\u0412\u0408\u0412\u04e8\u0412\u0498\u0412\u04b0\u0412\u00a7\u0412\u0401\u0412\u00a9\u0412\u04d8\u0412\u00ab\u0412\u00ac\u0412\u04ef\u0412\u00ae\u0412\u049c\u0412\u00b0\u0412\u04b1\u0412\u0406\u0412\u0456\u0412\u0499\u0412\u04e9\u0412\u00b6\u0412\u00b7\u0412\u0451\u0412\u2116\u0412\u04d9\u0412\u00bb\u0412\u0458\u0412\u04aa\u0412\u04ab\u0412\u049d\u0413\u0496\u0413\u0492\u0413\u04ee\u0413\u0493\u0413\u201e\u0413\u2026\u0413\u04b6\u0413\u04ae\u0413\u04b2\u0413\u04af\u0413\u04a0\u0413\u04e2\u0413\u04a2\u0413\u049a\u0413\u04ba\u0413\u04b8\u0413\u0497\u0413\u2018\u0413\u2019\u0413\u201c\u0413\u201d\u0413\u2022\u0413\u2013\u0413\u2014\u0413\u04b3\u0413\u04b7\u0413\u04a1\u0413\u04e3\u0413\u04a3\u0413\u049b\u0413\u04bb\u0413\u04b9\u0413\u00a0\u0413\u040e\u0413\u045e\u0413\u0408\u0413\u04e8\u0413\u0498\u0413\u04b0\u0413\u00a7\u0413\u0401\u0413\u00a9\u0413\u04d8\u0413\u00ab\u0413\u00ac\u0413\u04ef\u0413\u00ae\u0413\u049c\u0413\u00b0\u0413\u04b1\u0413\u0406\u0413\u0456\u0413\u0499\u0413\u04e9\u0413\u00b6\u0413\u00b7\u0413\u0451\u0413\u2116\u0413\u04d9\u0413\u00bb\u0413\u0458\u0413\u04aa\u0413\u04ab\u0413\u049d'\n  elseif has('amiga')\n    let fnamechars_ok = '$+,-./0123456789:ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz~\u0412\u00a0\u0412\u040e\u0412\u045e\u0412\u0408\u0412\u04e8\u0412\u0498\u0412\u04b0\u0412\u00a7\u0412\u0401\u0412\u00a9\u0412\u04d8\u0412\u00ab\u0412\u00ac\u0412\u04ef\u0412\u00ae\u0412\u049c\u0412\u00b0\u0412\u04b1\u0412\u0406\u0412\u0456\u0412\u0499\u0412\u04e9\u0412\u00b6\u0412\u00b7\u0412\u0451\u0412\u2116\u0412\u04d9\u0412\u00bb\u0412\u0458\u0412\u04aa\u0412\u04ab\u0412\u049d\u0413\u0496\u0413\u0492\u0413\u04ee\u0413\u0493\u0413\u201e\u0413\u2026\u0413\u04b6\u0413\u04ae\u0413\u04b2\u0413\u04af\u0413\u04a0\u0413\u04e2\u0413\u04a2\u0413\u049a\u0413\u04ba\u0413\u04b8\u0413\u0497\u0413\u2018\u0413\u2019\u0413\u201c\u0413\u201d\u0413\u2022\u0413\u2013\u0413\u2014\u0413\u04b3\u0413\u04b7\u0413\u04a1\u0413\u04e3\u0413\u04a3\u0413\u049b\u0413\u04bb\u0413\u04b9\u0413\u00a0\u0413\u040e\u0413\u045e\u0413\u0408\u0413\u04e8\u0413\u0498\u0413\u04b0\u0413\u00a7\u0413\u0401\u0413\u00a9\u0413\u04d8\u0413\u00ab\u0413\u00ac\u0413\u04ef\u0413\u00ae\u0413\u049c\u0413\u00b0\u0413\u04b1\u0413\u0406\u0413\u0456\u0413\u0499\u0413\u04e9\u0413\u00b6\u0413\u00b7\u0413\u0451\u0413\u2116\u0413\u04d9\u0413\u00bb\u0413\u0458\u0413\u04aa\u0413\u04ab\u0413\u049d'\n  elseif has('vms')\n    let fnamechars_ok = '#$%+,-./0123456789:;<>ABCDEFGHIJKLMNOPQRSTUVWXYZ[]_abcdefghijklmnopqrstuvwxyz~\u0412\u00a0\u0412\u040e\u0412\u045e\u0412\u0408\u0412\u04e8\u0412\u0498\u0412\u04b0\u0412\u00a7\u0412\u0401\u0412\u00a9\u0412\u04d8\u0412\u00ab\u0412\u00ac\u0412\u04ef\u0412\u00ae\u0412\u049c\u0412\u00b0\u0412\u04b1\u0412\u0406\u0412\u0456\u0412\u0499\u0412\u04e9\u0412\u00b6\u0412\u00b7\u0412\u0451\u0412\u2116\u0412\u04d9\u0412\u00bb\u0412\u0458\u0412\u04aa\u0412\u04ab\u0412\u049d\u0413\u0496\u0413\u0492\u0413\u04ee\u0413\u0493\u0413\u201e\u0413\u2026\u0413\u04b6\u0413\u04ae\u0413\u04b2\u0413\u04af\u0413\u04a0\u0413\u04e2\u0413\u04a2\u0413\u049a\u0413\u04ba\u0413\u04b8\u0413\u0497\u0413\u2018\u0413\u2019\u0413\u201c\u0413\u201d\u0413\u2022\u0413\u2013\u0413\u2014\u0413\u04b3\u0413\u04b7\u0413\u04a1\u0413\u04e3\u0413\u04a3\u0413\u049b\u0413\u04bb\u0413\u04b9\u0413\u00a0\u0413\u040e\u0413\u045e\u0413\u0408\u0413\u04e8\u0413\u0498\u0413\u04b0\u0413\u00a7\u0413\u0401\u0413\u00a9\u0413\u04d8\u0413\u00ab\u0413\u00ac\u0413\u04ef\u0413\u00ae\u0413\u049c\u0413\u00b0\u0413\u04b1\u0413\u0406\u0413\u0456\u0413\u0499\u0413\u04e9\u0413\u00b6\u0413\u00b7\u0413\u0451\u0413\u2116\u0413\u04d9\u0413\u00bb\u0413\u0458\u0413\u04aa\u0413\u04ab\u0413\u049d'\n  else\n    let fnamechars_ok = '#$%+,-./0123456789=ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz~\u0412\u00a0\u0412\u040e\u0412\u045e\u0412\u0408\u0412\u04e8\u0412\u0498\u0412\u04b0\u0412\u00a7\u0412\u0401\u0412\u00a9\u0412\u04d8\u0412\u00ab\u0412\u00ac\u0412\u04ef\u0412\u00ae\u0412\u049c\u0412\u00b0\u0412\u04b1\u0412\u0406\u0412\u0456\u0412\u0499\u0412\u04e9\u0412\u00b6\u0412\u00b7\u0412\u0451\u0412\u2116\u0412\u04d9\u0412\u00bb\u0412\u0458\u0412\u04aa\u0412\u04ab\u0412\u049d\u0413\u0496\u0413\u0492\u0413\u04ee\u0413\u0493\u0413\u201e\u0413\u2026\u0413\u04b6\u0413\u04ae\u0413\u04b2\u0413\u04af\u0413\u04a0\u0413\u04e2\u0413\u04a2\u0413\u049a\u0413\u04ba\u0413\u04b8\u0413\u0497\u0413\u2018\u0413\u2019\u0413\u201c\u0413\u201d\u0413\u2022\u0413\u2013\u0413\u2014\u0413\u04b3\u0413\u04b7\u0413\u04a1\u0413\u04e3\u0413\u04a3\u0413\u049b\u0413\u04bb\u0413\u04b9\u0413\u00a0\u0413\u040e\u0413\u045e\u0413\u0408\u0413\u04e8\u0413\u0498\u0413\u04b0\u0413\u00a7\u0413\u0401\u0413\u00a9\u0413\u04d8\u0413\u00ab\u0413\u00ac\u0413\u04ef\u0413\u00ae\u0413\u049c\u0413\u00b0\u0413\u04b1\u0413\u0406\u0413\u0456\u0413\u0499\u0413\u04e9\u0413\u00b6\u0413\u00b7\u0413\u0451\u0413\u2116\u0413\u04d9\u0413\u00bb\u0413\u0458\u0413\u04aa\u0413\u04ab\u0413\u049d'\n  endif\n\n  call assert_equal(identchars_ok, identchars)\n  call assert_equal(kwordchars_ok, kwordchars)\n  call assert_equal(fnamechars_ok, fnamechars)\n\n  call assert_equal(identchars1, identchars)\n  call assert_equal(kwordchars1, kwordchars)\n  call assert_equal(fnamechars1, fnamechars)\nendfunc\n\nfunc Test_classes_re1()\n  set re=1\n  call s:classes_test()\n  set re=0\nendfunc\n\nfunc Test_classes_re2()\n  set re=2\n  call s:classes_test()\n  set re=0\nendfunc\n\nfunc Test_reversed_range()\n  for re in range(0, 2)\n    exe 'set re=' . re\n    call assert_fails('call match(\"abc def\", \"[c-a]\")', 'E944:', re)\n  endfor\n  set re=0\nendfunc\n\nfunc Test_large_class()\n  set re=1\n  call assert_fails('call match(\"abc def\", \"[\\u3000-\\u4000]\")', 'E945:')\n  set re=2\n  call assert_equal(0, 'abc def' =~# '[\\u3000-\\u4000]')\n  call assert_equal(1, \"\\u3042\" =~# '[\\u3000-\\u4000]')\n  set re=0\nendfunc\n\nfunc Test_optmatch_toolong()\n  set re=1\n  \" Can only handle about 8000 characters.\n  let pat = '\\\\%[' .. repeat('x', 9000) .. ']'\n  call assert_fails('call match(\"abc def\", \"' .. pat .. '\")', 'E339:')\n  set re=0\nendfunc\n\n\" Test for regexp patterns with multi-byte support, using utf-8.\nfunc Test_multibyte_chars()\n  \" tl is a List of Lists with:\n  \"    2: test auto/old/new  0: test auto/old  1: test auto/new\n  \"    regexp pattern\n  \"    text to test the pattern on\n  \"    expected match (optional)\n  \"    expected submatch 1 (optional)\n  \"    expected submatch 2 (optional)\n  \"    etc.\n  \"  When there is no match use only the first two items.\n  let tl = []\n\n  \" Multi-byte character tests. These will fail unless vim is compiled\n  \" with Multibyte (FEAT_MBYTE) or BIG/HUGE features.\n  call add(tl, [2, '[[:alpha:][=a=]]\\+', '879 aia\u0413\u0408\u0413\u045eaiuvna ', 'aia\u0413\u0408\u0413\u045eaiuvna'])\n  call add(tl, [2, '[[=a=]]\\+', 'dda\u0413\u0408\u0413\u045ebcd', 'a\u0413\u0408\u0413\u045e'])\t\t\t\t\t\t\t\t\" equivalence classes\n  call add(tl, [2, '[^\u0430\u0451\u040e ]\\+', '\u0430\u0451\u040e\u0430\u0451\u040e oijasoifjos ifjoisj f osij j \u0430\u0451\u040e\u0430\u0451\u040e\u0430\u0451\u040e\u0430\u0451\u040e\u0430\u0451\u040e abcd', 'oijasoifjos'])\n  call add(tl, [2, ' [^ ]\\+', 'start \u0430\u0451\u040eabcd\u0430\u0451\u040e ', ' \u0430\u0451\u040eabcd\u0430\u0451\u040e'])\n  call add(tl, [2, '[\u0430\u0451\u040e[:alpha:][=a=]]\\+', '879 aia\u0413\u0408\u0430\u0451\u040e\u0413\u045e\u0430\u0451\u040eaiuvna ', 'aia\u0413\u0408\u0430\u0451\u040e\u0413\u045e\u0430\u0451\u040eaiuvna'])\n\n  \" this is not a normal \"i\" but 0xec\n  call add(tl, [2, '\\p\\+', '\u0413\u00aca', '\u0413\u00aca'])\n  call add(tl, [2, '\\p*', 'a\u0433\u0492\u04ee', 'a\u0433\u0492\u04ee'])\n\n  \" Test recognition of some character classes\n  call add(tl, [2, '\\i\\+', '&*\u0412\u0401xx ', 'xx'])\n  call add(tl, [2, '\\f\\+', '&*\u0412\u04b9fname ', 'fname'])\n\n  \" Test composing character matching\n  call add(tl, [2, '.\u0430\u0451\u040e', 'x\u0430\u0451\u040e\u0430\u2116\u04b2x y\u0430\u0451\u040ey', 'y\u0430\u0451\u040e'])\n  call add(tl, [2, '.\u0430\u0451\u040e\u0430\u2116\u04b2', 'x\u0430\u0451\u040e\u0430\u2116\u04b2x y\u0430\u0451\u040ey', 'x\u0430\u0451\u040e\u0430\u2116\u04b2'])\n  call add(tl, [2, \"\\u05b9\", \" x\\u05b9 \", \"x\\u05b9\"])\n  call add(tl, [2, \".\\u05b9\", \" x\\u05b9 \", \"x\\u05b9\"])\n  call add(tl, [2, \"\\u05b9\\u05bb\", \" x\\u05b9\\u05bb \", \"x\\u05b9\\u05bb\"])\n  call add(tl, [2, \".\\u05b9\\u05bb\", \" x\\u05b9\\u05bb \", \"x\\u05b9\\u05bb\"])\n  call add(tl, [2, \"\\u05bb\\u05b9\", \" x\\u05b9\\u05bb \", \"x\\u05b9\\u05bb\"])\n  call add(tl, [2, \".\\u05bb\\u05b9\", \" x\\u05b9\\u05bb \", \"x\\u05b9\\u05bb\"])\n  call add(tl, [2, \"\\u05b9\", \" y\\u05bb x\\u05b9 \", \"x\\u05b9\"])\n  call add(tl, [2, \".\\u05b9\", \" y\\u05bb x\\u05b9 \", \"x\\u05b9\"])\n  call add(tl, [2, \"\\u05b9\", \" y\\u05bb\\u05b9 x\\u05b9 \", \"y\\u05bb\\u05b9\"])\n  call add(tl, [2, \".\\u05b9\", \" y\\u05bb\\u05b9 x\\u05b9 \", \"y\\u05bb\\u05b9\"])\n  call add(tl, [1, \"\\u05b9\\u05bb\", \" y\\u05b9 x\\u05b9\\u05bb \", \"x\\u05b9\\u05bb\"])\n  call add(tl, [2, \".\\u05b9\\u05bb\", \" y\\u05bb x\\u05b9\\u05bb \", \"x\\u05b9\\u05bb\"])\n  call add(tl, [2, \"a\", \"ca\\u0300t\"])\n  call add(tl, [2, \"ca\", \"ca\\u0300t\"])\n  call add(tl, [2, \"a\\u0300\", \"ca\\u0300t\", \"a\\u0300\"])\n  call add(tl, [2, 'a\\%C', \"ca\\u0300t\", \"a\\u0300\"])\n  call add(tl, [2, 'ca\\%C', \"ca\\u0300t\", \"ca\\u0300\"])\n  call add(tl, [2, 'ca\\%Ct', \"ca\\u0300t\", \"ca\\u0300t\"])\n\n  \" Test \\Z\n  call add(tl, [2, '\u0413\u04d9\\Z', 'x'])\n  call add(tl, [2, '\u0427\u04b7\u0427\u201d\u0427\u2022\u0427\u201d\\Z', '\u0427\u04b7\u0427\u201d\u0427\u2022\u0427\u201d', '\u0427\u04b7\u0427\u201d\u0427\u2022\u0427\u201d'])\n  call add(tl, [2, '\u0427\u04b7\u0426\u00b0\u0427\u201d\u0427\u2022\u0426\u0451\u0427\u201d\\Z', '\u0427\u04b7\u0427\u201d\u0427\u2022\u0427\u201d', '\u0427\u04b7\u0427\u201d\u0427\u2022\u0427\u201d'])\n  call add(tl, [2, '\u0427\u04b7\u0427\u201d\u0427\u2022\u0427\u201d\\Z', '\u0427\u04b7\u0426\u00b0\u0427\u201d\u0427\u2022\u0426\u0451\u0427\u201d', '\u0427\u04b7\u0426\u00b0\u0427\u201d\u0427\u2022\u0426\u0451\u0427\u201d'])\n  call add(tl, [2, '\u0427\u04b7\u0426\u00b0\u0427\u201d\u0427\u2022\u0426\u0451\u0427\u201d\\Z', '\u0427\u04b7\u0426\u00b0\u0427\u201d\u0427\u2022\u0426\u0451\u0427\u201d', '\u0427\u04b7\u0426\u00b0\u0427\u201d\u0427\u2022\u0426\u0451\u0427\u201d'])\n  call add(tl, [2, '\u0427\u04b7\u0426\u00b0\\Z', '\u0427\u2022\u0426\u00b0\u0427\u04b7\u0426\u00b7', '\u0427\u04b7\u0426\u00b7'])\n  call add(tl, [2, \"\u0427\u00a7\\u200d\\u05b9x\\\\Z\", \"x\u0427\u00a7\\u200d\\u05b9xy\", \"\u0427\u00a7\\u200d\\u05b9x\"])\n  call add(tl, [2, \"\u0427\u00a7\\u200d\\u05b9x\\\\Z\", \"x\u0427\u00a7\\u200dxy\", \"\u0427\u00a7\\u200dx\"])\n  call add(tl, [2, \"\u0427\u00a7\\u200dx\\\\Z\", \"x\u0427\u00a7\\u200d\\u05b9xy\", \"\u0427\u00a7\\u200d\\u05b9x\"])\n  call add(tl, [2, \"\u0427\u00a7\\u200dx\\\\Z\", \"x\u0427\u00a7\\u200dxy\", \"\u0427\u00a7\\u200dx\"])\n  call add(tl, [2, \"\\u05b9\\\\Z\", \"xyz\"])\n  call add(tl, [2, \"\\\\Z\\u05b9\", \"xyz\"])\n  call add(tl, [2, \"\\u05b9\\\\Z\", \"xy\\u05b9z\", \"y\\u05b9\"])\n  call add(tl, [2, \"\\\\Z\\u05b9\", \"xy\\u05b9z\", \"y\\u05b9\"])\n  call add(tl, [1, \"\\u05b9\\\\+\\\\Z\", \"xy\\u05b9z\\u05b9 \", \"y\\u05b9z\\u05b9\"])\n  call add(tl, [1, \"\\\\Z\\u05b9\\\\+\", \"xy\\u05b9z\\u05b9 \", \"y\\u05b9z\\u05b9\"])\n\n  \" Combining different tests and features\n  call add(tl, [2, '[^[=a=]]\\+', 'dda\u0413\u0408\u0413\u045ebcd', 'dd'])\n\n  \" Run the tests\n  for t in tl\n    let re = t[0]\n    let pat = t[1]\n    let text = t[2]\n    let matchidx = 3\n    for engine in [0, 1, 2]\n      if engine == 2 && re == 0 || engine == 1 && re == 1\n        continue\n      endif\n      let &regexpengine = engine\n      try\n        let l = matchlist(text, pat)\n      catch\n        call assert_report('Error ' . engine . ': pat: \\\"' . pat .\n\t\t    \\ '\\\", text: \\\"' . text .\n\t\t    \\ '\\\", caused an exception: \\\"' . v:exception . '\\\"')\n      endtry\n      \" check the match itself\n      if len(l) == 0 && len(t) > matchidx\n        call assert_report('Error ' . engine . ': pat: \\\"' . pat .\n\t\t    \\ '\\\", text: \\\"' . text .\n\t\t    \\ '\\\", did not match, expected: \\\"' . t[matchidx] . '\\\"')\n      elseif len(l) > 0 && len(t) == matchidx\n        call assert_report('Error ' . engine . ': pat: \\\"' . pat .\n\t\t    \\ '\\\", text: \\\"' . text . '\\\", match: \\\"' . l[0] .\n\t\t    \\ '\\\", expected no match')\n      elseif len(t) > matchidx && l[0] != t[matchidx]\n        call assert_report('Error ' . engine . ': pat: \\\"' . pat .\n\t\t    \\ '\\\", text: \\\"' . text . '\\\", match: \\\"' . l[0] .\n\t\t    \\ '\\\", expected: \\\"' . t[matchidx] . '\\\"')\n      else\n        \" Test passed\n      endif\n      if len(l) > 0\n        \" check all the nine submatches\n        for i in range(1, 9)\n          if len(t) <= matchidx + i\n            let e = ''\n          else\n            let e = t[matchidx + i]\n          endif\n          if l[i] != e\n            call assert_report('Error ' . engine . ': pat: \\\"' . pat .\n                  \\ '\\\", text: \\\"' . text . '\\\", submatch ' . i .\n                  \\ ': \\\"' . l[i] . '\\\", expected: \\\"' . e . '\\\"')\n          endif\n        endfor\n        unlet i\n      endif\n    endfor\n  endfor\n  set regexpengine&\nendfunc\n\n\" check that 'ambiwidth' does not change the meaning of \\p\nfunc Test_ambiwidth()\n  set regexpengine=1 ambiwidth=single\n  call assert_equal(0, match(\"\\u00EC\", '\\p'))\n  set regexpengine=1 ambiwidth=double\n  call assert_equal(0, match(\"\\u00EC\", '\\p'))\n  set regexpengine=2 ambiwidth=single\n  call assert_equal(0, match(\"\\u00EC\", '\\p'))\n  set regexpengine=2 ambiwidth=double\n  call assert_equal(0, match(\"\\u00EC\", '\\p'))\n  set regexpengine& ambiwidth&\nendfunc\n\nfunc Run_regexp_ignore_case()\n  call assert_equal('iI\u0414\u00b0', substitute('iI\u0414\u00b0', '\\([iI\u0414\u00b0]\\)', '\\1', 'g'))\n\n  call assert_equal('iIx', substitute('iI\u0414\u00b0', '\\c\\([\u0414\u00b0]\\)', 'x', 'g'))\n  call assert_equal('xx\u0414\u00b0', substitute('iI\u0414\u00b0', '\\(i\\c\\)', 'x', 'g'))\n  call assert_equal('iIx', substitute('iI\u0414\u00b0', '\\(\u0414\u00b0\\c\\)', 'x', 'g'))\n  call assert_equal('iIx', substitute('iI\u0414\u00b0', '\\c\\(\\%u0130\\)', 'x', 'g'))\n  call assert_equal('iIx', substitute('iI\u0414\u00b0', '\\c\\([\\u0130]\\)', 'x', 'g'))\n  call assert_equal('iIx', substitute('iI\u0414\u00b0', '\\c\\([\\u012f-\\u0131]\\)', 'x', 'g'))\nendfunc\n\nfunc Test_regexp_ignore_case()\n  set regexpengine=1\n  call Run_regexp_ignore_case()\n  set regexpengine=2\n  call Run_regexp_ignore_case()\n  set regexpengine&\nendfunc\n\n\" Tests for regexp with multi-byte encoding and various magic settings\nfunc Run_regexp_multibyte_magic()\n  let text =<< trim END\n    1 a aa abb abbccc\n    2 d dd dee deefff\n    3 g gg ghh ghhiii\n    4 j jj jkk jkklll\n    5 m mm mnn mnnooo\n    6 x ^aa$ x\n    7 (a)(b) abbaa\n    8 axx [ab]xx\n    9 \u0430\u0451\u00ab\u0430\u0451\u040e\u0430\u2116\u04b2x \u0430\u0451\u04ef\u0430\u0451\u040ex\n    a \u0430\u0451\u04ef\u0430\u0451\u040ex \u0430\u0451\u00ab\u0430\u0451\u040e\u0430\u2116\u04b2x\n    b \u0433\u0492\u040e\u0433\u04ee\u00ab\u0433\u0493\u0401\u0433\u0492\u049c\n    c x \u0412\u00ac\u0432\u04ee\u00acx\n    d \u0435\u04e8\u00a9\u0434\u04aa\u049dx\n    e \u044c\u2019\u049a\u2026\u04b7\u0451y\n    f \u044c\u2019\u049a\u04a0\u049c\u049az\n    g a\u0435\u2022\u00b7bb\n    j 0123\u0432\u049b\u04e8x\n    k combinations\n    l \u0413\u04e8\u0413\u00b6 \u0413\u0458\u041e\u04b1\u041c\u201e\u041c\u04b6\u041c\u0492\n  END\n\n  new\n  call setline(1, text)\n  exe 'normal /a*b\\{2}c\\+/e' .. \"\\<CR>x\"\n  call assert_equal('1 a aa abb abbcc', getline('.'))\n  exe 'normal /\\Md\\*e\\{2}f\\+/e' .. \"\\<CR>x\"\n  call assert_equal('2 d dd dee deeff', getline('.'))\n  set nomagic\n  exe 'normal /g\\*h\\{2}i\\+/e' .. \"\\<CR>x\"\n  call assert_equal('3 g gg ghh ghhii', getline('.'))\n  exe 'normal /\\mj*k\\{2}l\\+/e' .. \"\\<CR>x\"\n  call assert_equal('4 j jj jkk jkkll', getline('.'))\n  exe 'normal /\\vm*n{2}o+/e' .. \"\\<CR>x\"\n  call assert_equal('5 m mm mnn mnnoo', getline('.'))\n  exe 'normal /\\V^aa$/' .. \"\\<CR>x\"\n  call assert_equal('6 x aa$ x', getline('.'))\n  set magic\n  exe 'normal /\\v(a)(b)\\2\\1\\1/e' .. \"\\<CR>x\"\n  call assert_equal('7 (a)(b) abba', getline('.'))\n  exe 'normal /\\V[ab]\\(\\[xy]\\)\\1' .. \"\\<CR>x\"\n  call assert_equal('8 axx ab]xx', getline('.'))\n\n  \" search for multi-byte without composing char\n  exe 'normal /\u0430\u0451\u040e' .. \"\\<CR>x\"\n  call assert_equal('9 \u0430\u0451\u00ab\u0430\u0451\u040e\u0430\u2116\u04b2x \u0430\u0451\u04efx', getline('.'))\n\n  \" search for multi-byte with composing char\n  exe 'normal /\u0430\u0451\u040e\u0430\u2116\u04b2' .. \"\\<CR>x\"\n  call assert_equal('a \u0430\u0451\u04ef\u0430\u0451\u040ex \u0430\u0451\u00abx', getline('.'))\n\n  \" find word by change of word class\n  exe 'normal /\u0433\u0492\u040e\\<\u0433\u04ee\u00ab\u0433\u0493\u0401\\>\u0433\u0492\u049c' .. \"\\<CR>x\"\n  call assert_equal('b \u0433\u04ee\u00ab\u0433\u0493\u0401\u0433\u0492\u049c', getline('.'))\n\n  \" Test \\%u, [\\u] and friends\n  \" c\n  exe 'normal /\\%u20ac' .. \"\\<CR>x\"\n  call assert_equal('c x \u0412\u00acx', getline('.'))\n  \" d\n  exe 'normal /[\\u4f7f\\u5929]\\+' .. \"\\<CR>x\"\n  call assert_equal('d \u0434\u04aa\u049dx', getline('.'))\n  \" e\n  exe 'normal /\\%U12345678' .. \"\\<CR>x\"\n  call assert_equal('e y', getline('.'))\n  \" f\n  exe 'normal /[\\U1234abcd\\u1234\\uabcd]' .. \"\\<CR>x\"\n  call assert_equal('f z', getline('.'))\n  \" g\n  exe 'normal /\\%d21879b' .. \"\\<CR>x\"\n  call assert_equal('g abb', getline('.'))\n\n  \" j Test backwards search from a multi-byte char\n  exe \"normal /x\\<CR>x?.\\<CR>x\"\n  call assert_equal('j 012\u0432\u049b\u04e8', getline('.'))\n  \" k\n  let @w=':%s#comb[i]nations#\u0415\u201c\u041c\u201e\u0431\u2116\u0408\u041c\u0492m\u041c\u0498\u041c\u201e\u041e\u04b1\u041c\u201e\u041c\u04b6\u041c\u0492#g'\n  @w\n  call assert_equal('k \u0415\u201c\u041c\u201e\u0431\u2116\u0408\u041c\u0492m\u041c\u0498\u041c\u201e\u041e\u04b1\u041c\u201e\u041c\u04b6\u041c\u0492', getline(18))\n\n  close!\nendfunc\n\nfunc Test_regexp_multibyte_magic()\n  set regexpengine=1\n  call Run_regexp_multibyte_magic()\n  set regexpengine=2\n  call Run_regexp_multibyte_magic()\n  set regexpengine&\nendfunc\n\n\" Test for 7.3.192\n\" command \":s/ \\?/ /g\" splits multi-byte characters into bytes\nfunc Test_split_multibyte_to_bytes()\n  new\n  call setline(1, 'l \u0413\u04e8\u0413\u00b6 \u0413\u0458\u041e\u04b1\u041c\u201e\u041c\u04b6\u041c\u0492')\n  s/ \\?/ /g\n  call assert_equal(' l \u0413\u04e8 \u0413\u00b6 \u0413\u0458 \u041e\u04b1\u041c\u201e\u041c\u04b6\u041c\u0492', getline(1))\n  close!\nendfunc\n\n\" Test for matchstr() with multibyte characters\nfunc Test_matchstr_multibyte()\n  new\n  call assert_equal('\u0427\u2018', matchstr(\"\u0427\u0497\u0427\u2018\u0427\u2019\u0427\u201c\", \".\", 0, 2))\n  call assert_equal('\u0427\u2018\u0427\u2019', matchstr(\"\u0427\u0497\u0427\u2018\u0427\u2019\u0427\u201c\", \"..\", 0, 2))\n  call assert_equal('\u0427\u0497', matchstr(\"\u0427\u0497\u0427\u2018\u0427\u2019\u0427\u201c\", \".\", 0, 0))\n  call assert_equal('\u0427\u2019', matchstr(\"\u0427\u0497\u0427\u2018\u0427\u2019\u0427\u201c\", \".\", 4, -1))\n  close!\nendfunc\n\n\" Test for 7.4.636\n\" A search with end offset gets stuck at end of file.\nfunc Test_search_with_end_offset()\n  new\n  call setline(1, ['', 'dog(a', 'cat('])\n  exe \"normal /(/e+\\<CR>\"\n  normal n\"ayn\n  call assert_equal(\"a\\ncat(\", @a)\n  close!\nendfunc\n\n\" Check that \"^\" matches even when the line starts with a combining char\nfunc Test_match_start_of_line_combining()\n  new\n  call setline(1, ['', \"\\u05ae\", ''])\n  exe \"normal gg/^\\<CR>\"\n  call assert_equal(2, getcurpos()[1])\n  bwipe!\nendfunc\n\n\" Check that [[:upper:]] matches for automatic engine\nfunc Test_match_char_class_upper()\n  new\n\n  \" Test 1: [[:upper:]]\\{2,\\}\n  set regexpengine=0\n  call setline(1, ['05. \u0420\u04b9\u0420\u2022\u0420\u040e\u0420\u049b\u0420\u049c \u0420\u04bb \u0420\u201c\u0420\u2022\u0420\u00a0\u0420\u04bb\u0420\u049c\u0420\u0498 \u0420\u0458\u0421\u0493\u0420\u00b7. \u0420\u0497. \u0420\u201d\u0420\u00b0\u0420\u0406\u0420\u0451\u0420\u0499\u0420\u04e9\u0420\u04aa\u0420\u04d9\u0420\u04ab, \u0420\u04a3. \u0420\u04a1\u0420\u04ab\u0420\u0406\u0420\u00b0\u0420\u00bb\u0421\u04b8 \u0420\u0451 \u0420\u2018. \u0420\u0401\u0420\u04e9\u0421\u2026\u0421\u04ee\u0420\u04e9\u0421\u0496\u0420\u00b0 ...', '05. PJESNJA O GJEROJAKH mus. A. Davidjenko, M. Kovalja i B. Shjekhtjera ...'])\n  call cursor(1,1)\n  let search_cmd='norm /\\<[[:upper:]]\\{2,\\}\\>' .. \"\\<CR>\"\n  exe search_cmd\n  call assert_equal(4, searchcount().total, 'TEST 1')\n  set regexpengine=1\n  exe search_cmd\n  call assert_equal(2, searchcount().total, 'TEST 1')\n  set regexpengine=2\n  exe search_cmd\n  call assert_equal(4, searchcount().total, 'TEST 1')\n\n  \" Test 2: [[:upper:]].\\+\n  let search_cmd='norm /\\<[[:upper:]].\\+\\>' .. \"\\<CR>\"\n  set regexpengine=0\n  exe search_cmd\n  call assert_equal(2, searchcount().total, 'TEST 2')\n  set regexpengine=1\n  exe search_cmd\n  call assert_equal(1, searchcount().total, 'TEST 2')\n  set regexpengine=2\n  exe search_cmd\n  call assert_equal(2, searchcount().total, 'TEST 2')\n\n  \" Test 3: [[:lower:]]\\+\n  let search_cmd='norm /\\<[[:lower:]]\\+\\>' .. \"\\<CR>\"\n  set regexpengine=0\n  exe search_cmd\n  call assert_equal(4, searchcount().total, 'TEST 3 lower')\n  set regexpengine=1\n  exe search_cmd\n  call assert_equal(2, searchcount().total, 'TEST 3 lower')\n  set regexpengine=2\n  exe search_cmd\n  call assert_equal(4, searchcount().total, 'TEST 3 lower')\n\n  \" clean up\n  set regexpengine=0\n  bwipe!\nendfunc\n\nfunc Test_match_invalid_byte()\n  call writefile(0z630a.765d30aa0a.2e0a.790a.4030, 'Xinvalid')\n  new\n  source Xinvalid\n  bwipe!\n  call delete('Xinvalid')\nendfunc\n\nfunc Test_match_illegal_byte()\n  let lines =<< trim END\n      silent! buffer \u0413\u049d\\c\n      next \u0413\u049d\n      0scriptnames\n      source\n  END\n  call writefile(lines, 'Xregexp')\n  call system(GetVimCommand() .. ' -X -Z -e -s -S Xregexp -c qa!')\n\n  call delete('Xregexp')\nendfunc\n\nfunc Test_match_too_complicated()\n  set regexpengine=1\n  exe \"noswapfile vsplit \\xeb\\xdb\\x99\"\n  silent! buf \\&\\zs*\\zs*0\n  bwipe!\n  set regexpengine=0\nendfunc\n\n\n\" vim: shiftwidth=2 sts=2 expandtab\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\t\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n#include \"vim.h\"\n\n/*\n * Vim originated from Stevie version 3.6 (Fish disk 217) by GRWalter (Fred)\n * It has been changed beyond recognition since then.\n *\n * Differences between version 8.2 and 9.0 can be found with \":help version9\".\n * Differences between version 7.4 and 8.x can be found with \":help version8\".\n * Differences between version 6.4 and 7.x can be found with \":help version7\".\n * Differences between version 5.8 and 6.x can be found with \":help version6\".\n * Differences between version 4.x and 5.x can be found with \":help version5\".\n * Differences between version 3.0 and 4.x can be found with \":help version4\".\n * All the remarks about older versions have been removed, they are not very\n * interesting.\n */\n\n#include \"version.h\"\n\nchar\t\t*Version = VIM_VERSION_SHORT;\nstatic char\t*mediumVersion = VIM_VERSION_MEDIUM;\n\n#if defined(HAVE_DATE_TIME) || defined(PROTO)\n# if (defined(VMS) && defined(VAXC)) || defined(PROTO)\nchar\tlongVersion[sizeof(VIM_VERSION_LONG_DATE) + sizeof(__DATE__)\n\t\t\t\t\t\t      + sizeof(__TIME__) + 3];\n\n    void\ninit_longVersion(void)\n{\n    /*\n     * Construct the long version string.  Necessary because\n     * VAX C can't concatenate strings in the preprocessor.\n     */\n    strcpy(longVersion, VIM_VERSION_LONG_DATE);\n#ifdef BUILD_DATE\n    strcat(longVersion, BUILD_DATE);\n#else\n    strcat(longVersion, __DATE__);\n    strcat(longVersion, \" \");\n    strcat(longVersion, __TIME__);\n#endif\n    strcat(longVersion, \")\");\n}\n\n# else\nchar\t*longVersion = NULL;\n\n    void\ninit_longVersion(void)\n{\n    if (longVersion == NULL)\n    {\n#ifdef BUILD_DATE\n\tchar *date_time = BUILD_DATE;\n#else\n\tchar *date_time = __DATE__ \" \" __TIME__;\n#endif\n\tchar *msg = _(\"%s (%s, compiled %s)\");\n\tsize_t len = strlen(msg)\n\t\t    + strlen(VIM_VERSION_LONG_ONLY)\n\t\t    + strlen(VIM_VERSION_DATE_ONLY)\n\t\t    + strlen(date_time);\n\n\tlongVersion = alloc(len);\n\tif (longVersion == NULL)\n\t    longVersion = VIM_VERSION_LONG;\n\telse\n\t    vim_snprintf(longVersion, len, msg,\n\t\t      VIM_VERSION_LONG_ONLY, VIM_VERSION_DATE_ONLY, date_time);\n    }\n}\n# endif\n#else\nchar\t*longVersion = VIM_VERSION_LONG;\n\n    void\ninit_longVersion(void)\n{\n    // nothing to do\n}\n#endif\n\nstatic char *(features[]) =\n{\n#ifdef HAVE_ACL\n\t\"+acl\",\n#else\n\t\"-acl\",\n#endif\n#ifdef AMIGA\t\t// only for Amiga systems\n# ifdef FEAT_ARP\n\t\"+ARP\",\n# else\n\t\"-ARP\",\n# endif\n#endif\n#ifdef FEAT_ARABIC\n\t\"+arabic\",\n#else\n\t\"-arabic\",\n#endif\n\t\"+autocmd\",\n#ifdef FEAT_AUTOCHDIR\n       \"+autochdir\",\n#else\n       \"-autochdir\",\n#endif\n#ifdef FEAT_AUTOSERVERNAME\n\t\"+autoservername\",\n#else\n\t\"-autoservername\",\n#endif\n#ifdef FEAT_BEVAL_GUI\n\t\"+balloon_eval\",\n#else\n\t\"-balloon_eval\",\n#endif\n#ifdef FEAT_BEVAL_TERM\n\t\"+balloon_eval_term\",\n#else\n\t\"-balloon_eval_term\",\n#endif\n#ifdef FEAT_BROWSE\n\t\"+browse\",\n#else\n\t\"-browse\",\n#endif\n#ifdef NO_BUILTIN_TCAPS\n\t\"-builtin_terms\",\n#endif\n#ifdef SOME_BUILTIN_TCAPS\n\t\"+builtin_terms\",\n#endif\n#ifdef ALL_BUILTIN_TCAPS\n\t\"++builtin_terms\",\n#endif\n#ifdef FEAT_BYTEOFF\n\t\"+byte_offset\",\n#else\n\t\"-byte_offset\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+channel\",\n#else\n\t\"-channel\",\n#endif\n\t\"+cindent\",\n#ifdef FEAT_CLIENTSERVER\n\t\"+clientserver\",\n#else\n\t\"-clientserver\",\n#endif\n#ifdef FEAT_CLIPBOARD\n\t\"+clipboard\",\n#else\n\t\"-clipboard\",\n#endif\n\t\"+cmdline_compl\",\n\t\"+cmdline_hist\",\n#ifdef FEAT_CMDL_INFO\n\t\"+cmdline_info\",\n#else\n\t\"-cmdline_info\",\n#endif\n\t\"+comments\",\n#ifdef FEAT_CONCEAL\n\t\"+conceal\",\n#else\n\t\"-conceal\",\n#endif\n#ifdef FEAT_CRYPT\n\t\"+cryptv\",\n#else\n\t\"-cryptv\",\n#endif\n#ifdef FEAT_CSCOPE\n\t\"+cscope\",\n#else\n\t\"-cscope\",\n#endif\n\t\"+cursorbind\",\n#ifdef CURSOR_SHAPE\n\t\"+cursorshape\",\n#else\n\t\"-cursorshape\",\n#endif\n#if defined(FEAT_CON_DIALOG) && defined(FEAT_GUI_DIALOG)\n\t\"+dialog_con_gui\",\n#else\n# if defined(FEAT_CON_DIALOG)\n\t\"+dialog_con\",\n# else\n#  if defined(FEAT_GUI_DIALOG)\n\t\"+dialog_gui\",\n#  else\n\t\"-dialog\",\n#  endif\n# endif\n#endif\n#ifdef FEAT_DIFF\n\t\"+diff\",\n#else\n\t\"-diff\",\n#endif\n#ifdef FEAT_DIGRAPHS\n\t\"+digraphs\",\n#else\n\t\"-digraphs\",\n#endif\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_DIRECTX\n\t\"+directx\",\n# else\n\t\"-directx\",\n# endif\n#endif\n#ifdef FEAT_DND\n\t\"+dnd\",\n#else\n\t\"-dnd\",\n#endif\n\t\"-ebcdic\",\n#ifdef FEAT_EMACS_TAGS\n\t\"+emacs_tags\",\n#else\n\t\"-emacs_tags\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+eval\",\n#else\n\t\"-eval\",\n#endif\n\t\"+ex_extra\",\n#ifdef FEAT_SEARCH_EXTRA\n\t\"+extra_search\",\n#else\n\t\"-extra_search\",\n#endif\n\t\"-farsi\",\n#ifdef FEAT_SEARCHPATH\n\t\"+file_in_path\",\n#else\n\t\"-file_in_path\",\n#endif\n#ifdef FEAT_FIND_ID\n\t\"+find_in_path\",\n#else\n\t\"-find_in_path\",\n#endif\n#ifdef FEAT_FLOAT\n\t\"+float\",\n#else\n\t\"-float\",\n#endif\n#ifdef FEAT_FOLDING\n\t\"+folding\",\n#else\n\t\"-folding\",\n#endif\n#ifdef FEAT_FOOTER\n\t\"+footer\",\n#else\n\t\"-footer\",\n#endif\n\t    // only interesting on Unix systems\n#if !defined(USE_SYSTEM) && defined(UNIX)\n\t\"+fork()\",\n#endif\n#ifdef FEAT_GETTEXT\n# ifdef DYNAMIC_GETTEXT\n\t\"+gettext/dyn\",\n# else\n\t\"+gettext\",\n# endif\n#else\n\t\"-gettext\",\n#endif\n\t\"-hangul_input\",\n#if (defined(HAVE_ICONV_H) && defined(USE_ICONV)) || defined(DYNAMIC_ICONV)\n# ifdef DYNAMIC_ICONV\n\t\"+iconv/dyn\",\n# else\n\t\"+iconv\",\n# endif\n#else\n\t\"-iconv\",\n#endif\n\t\"+insert_expand\",\n#ifdef FEAT_IPV6\n\t\"+ipv6\",\n#else\n\t\"-ipv6\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+job\",\n#else\n\t\"-job\",\n#endif\n\t\"+jumplist\",\n#ifdef FEAT_KEYMAP\n\t\"+keymap\",\n#else\n\t\"-keymap\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+lambda\",\n#else\n\t\"-lambda\",\n#endif\n#ifdef FEAT_LANGMAP\n\t\"+langmap\",\n#else\n\t\"-langmap\",\n#endif\n#ifdef FEAT_LIBCALL\n\t\"+libcall\",\n#else\n\t\"-libcall\",\n#endif\n#ifdef FEAT_LINEBREAK\n\t\"+linebreak\",\n#else\n\t\"-linebreak\",\n#endif\n\t\"+lispindent\",\n\t\"+listcmds\",\n\t\"+localmap\",\n#ifdef FEAT_LUA\n# ifdef DYNAMIC_LUA\n\t\"+lua/dyn\",\n# else\n\t\"+lua\",\n# endif\n#else\n\t\"-lua\",\n#endif\n#ifdef FEAT_MENU\n\t\"+menu\",\n#else\n\t\"-menu\",\n#endif\n#ifdef FEAT_SESSION\n\t\"+mksession\",\n#else\n\t\"-mksession\",\n#endif\n\t\"+modify_fname\",\n\t\"+mouse\",\n#ifdef FEAT_MOUSESHAPE\n\t\"+mouseshape\",\n#else\n\t\"-mouseshape\",\n#endif\n\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_MOUSE_DEC\n\t\"+mouse_dec\",\n# else\n\t\"-mouse_dec\",\n# endif\n# ifdef FEAT_MOUSE_GPM\n#  ifdef DYNAMIC_GPM\n\t\"+mouse_gpm/dyn\",\n#  else\n\t\"+mouse_gpm\",\n#  endif\n# else\n\t\"-mouse_gpm\",\n# endif\n# ifdef FEAT_MOUSE_JSB\n\t\"+mouse_jsbterm\",\n# else\n\t\"-mouse_jsbterm\",\n# endif\n# ifdef FEAT_MOUSE_NET\n\t\"+mouse_netterm\",\n# else\n\t\"-mouse_netterm\",\n# endif\n#endif\n\n#ifdef __QNX__\n# ifdef FEAT_MOUSE_PTERM\n\t\"+mouse_pterm\",\n# else\n\t\"-mouse_pterm\",\n# endif\n#endif\n\n#if defined(UNIX) || defined(VMS)\n\t\"+mouse_sgr\",\n# ifdef FEAT_SYSMOUSE\n\t\"+mouse_sysmouse\",\n# else\n\t\"-mouse_sysmouse\",\n# endif\n# ifdef FEAT_MOUSE_URXVT\n\t\"+mouse_urxvt\",\n# else\n\t\"-mouse_urxvt\",\n# endif\n\t\"+mouse_xterm\",\n#endif\n\n#ifdef FEAT_MBYTE_IME\n# ifdef DYNAMIC_IME\n\t\"+multi_byte_ime/dyn\",\n# else\n\t\"+multi_byte_ime\",\n# endif\n#else\n\t\"+multi_byte\",\n#endif\n#ifdef FEAT_MULTI_LANG\n\t\"+multi_lang\",\n#else\n\t\"-multi_lang\",\n#endif\n#ifdef FEAT_MZSCHEME\n# ifdef DYNAMIC_MZSCHEME\n\t\"+mzscheme/dyn\",\n# else\n\t\"+mzscheme\",\n# endif\n#else\n\t\"-mzscheme\",\n#endif\n#ifdef FEAT_NETBEANS_INTG\n\t\"+netbeans_intg\",\n#else\n\t\"-netbeans_intg\",\n#endif\n\t\"+num64\",\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_OLE\n\t\"+ole\",\n# else\n\t\"-ole\",\n# endif\n#endif\n#ifdef FEAT_EVAL\n\t\"+packages\",\n#else\n\t\"-packages\",\n#endif\n#ifdef FEAT_PATH_EXTRA\n\t\"+path_extra\",\n#else\n\t\"-path_extra\",\n#endif\n#ifdef FEAT_PERL\n# ifdef DYNAMIC_PERL\n\t\"+perl/dyn\",\n# else\n\t\"+perl\",\n# endif\n#else\n\t\"-perl\",\n#endif\n#ifdef FEAT_PERSISTENT_UNDO\n\t\"+persistent_undo\",\n#else\n\t\"-persistent_undo\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+popupwin\",\n#else\n\t\"-popupwin\",\n#endif\n#ifdef FEAT_PRINTER\n# ifdef FEAT_POSTSCRIPT\n\t\"+postscript\",\n# else\n\t\"-postscript\",\n# endif\n\t\"+printer\",\n#else\n\t\"-printer\",\n#endif\n#ifdef FEAT_PROFILE\n\t\"+profile\",\n#else\n\t\"-profile\",\n#endif\n#ifdef FEAT_PYTHON\n# ifdef DYNAMIC_PYTHON\n\t\"+python/dyn\",\n# else\n\t\"+python\",\n# endif\n#else\n\t\"-python\",\n#endif\n#ifdef FEAT_PYTHON3\n# ifdef DYNAMIC_PYTHON3\n\t\"+python3/dyn\",\n# else\n\t\"+python3\",\n# endif\n#else\n\t\"-python3\",\n#endif\n#ifdef FEAT_QUICKFIX\n\t\"+quickfix\",\n#else\n\t\"-quickfix\",\n#endif\n#ifdef FEAT_RELTIME\n\t\"+reltime\",\n#else\n\t\"-reltime\",\n#endif\n#ifdef FEAT_RIGHTLEFT\n\t\"+rightleft\",\n#else\n\t\"-rightleft\",\n#endif\n#ifdef FEAT_RUBY\n# ifdef DYNAMIC_RUBY\n\t\"+ruby/dyn\",\n# else\n\t\"+ruby\",\n# endif\n#else\n\t\"-ruby\",\n#endif\n\t\"+scrollbind\",\n#ifdef FEAT_SIGNS\n\t\"+signs\",\n#else\n\t\"-signs\",\n#endif\n\t\"+smartindent\",\n#ifdef FEAT_SODIUM\n# ifdef DYNAMIC_SODIUM\n\t\"+sodium/dyn\",\n# else\n\t\"+sodium\",\n# endif\n#else\n\t\"-sodium\",\n#endif\n#ifdef FEAT_SOUND\n\t\"+sound\",\n#else\n\t\"-sound\",\n#endif\n#ifdef FEAT_SPELL\n\t\"+spell\",\n#else\n\t\"-spell\",\n#endif\n#ifdef STARTUPTIME\n\t\"+startuptime\",\n#else\n\t\"-startuptime\",\n#endif\n#ifdef FEAT_STL_OPT\n\t\"+statusline\",\n#else\n\t\"-statusline\",\n#endif\n\t\"-sun_workshop\",\n#ifdef FEAT_SYN_HL\n\t\"+syntax\",\n#else\n\t\"-syntax\",\n#endif\n\t    // only interesting on Unix systems\n#if defined(USE_SYSTEM) && defined(UNIX)\n\t\"+system()\",\n#endif\n\t\"+tag_binary\",\n\t\"-tag_old_static\",\n\t\"-tag_any_white\",\n#ifdef FEAT_TCL\n# ifdef DYNAMIC_TCL\n\t\"+tcl/dyn\",\n# else\n\t\"+tcl\",\n# endif\n#else\n\t\"-tcl\",\n#endif\n#ifdef FEAT_TERMGUICOLORS\n\t\"+termguicolors\",\n#else\n\t\"-termguicolors\",\n#endif\n#ifdef FEAT_TERMINAL\n\t\"+terminal\",\n#else\n\t\"-terminal\",\n#endif\n#if defined(UNIX)\n// only Unix can have terminfo instead of termcap\n# ifdef TERMINFO\n\t\"+terminfo\",\n# else\n\t\"-terminfo\",\n# endif\n#endif\n#ifdef FEAT_TERMRESPONSE\n\t\"+termresponse\",\n#else\n\t\"-termresponse\",\n#endif\n#ifdef FEAT_TEXTOBJ\n\t\"+textobjects\",\n#else\n\t\"-textobjects\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+textprop\",\n#else\n\t\"-textprop\",\n#endif\n#if !defined(UNIX)\n// unix always includes termcap support\n# ifdef HAVE_TGETENT\n\t\"+tgetent\",\n# else\n\t\"-tgetent\",\n# endif\n#endif\n#ifdef FEAT_TIMERS\n\t\"+timers\",\n#else\n\t\"-timers\",\n#endif\n\t\"+title\",\n#ifdef FEAT_TOOLBAR\n\t\"+toolbar\",\n#else\n\t\"-toolbar\",\n#endif\n\t\"+user_commands\",\n#ifdef FEAT_VARTABS\n\t\"+vartabs\",\n#else\n\t\"-vartabs\",\n#endif\n\t\"+vertsplit\",\n\t\"+vim9script\",\n#ifdef FEAT_VIMINFO\n\t\"+viminfo\",\n#else\n\t\"-viminfo\",\n#endif\n\t\"+virtualedit\",\n\t\"+visual\",\n\t\"+visualextra\",\n\t\"+vreplace\",\n#ifdef MSWIN\n# ifdef FEAT_VTP\n\t\"+vtp\",\n# else\n\t\"-vtp\",\n# endif\n#endif\n#ifdef FEAT_WILDIGN\n\t\"+wildignore\",\n#else\n\t\"-wildignore\",\n#endif\n#ifdef FEAT_WILDMENU\n\t\"+wildmenu\",\n#else\n\t\"-wildmenu\",\n#endif\n\t\"+windows\",\n#ifdef FEAT_WRITEBACKUP\n\t\"+writebackup\",\n#else\n\t\"-writebackup\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_X11\n\t\"+X11\",\n# else\n\t\"-X11\",\n# endif\n#endif\n#ifdef FEAT_XFONTSET\n\t\"+xfontset\",\n#else\n\t\"-xfontset\",\n#endif\n#ifdef FEAT_XIM\n\t\"+xim\",\n#else\n\t\"-xim\",\n#endif\n#if defined(MSWIN)\n# ifdef FEAT_XPM_W32\n\t\"+xpm_w32\",\n# else\n\t\"-xpm_w32\",\n# endif\n#elif defined(HAVE_XPM)\n\t\"+xpm\",\n#else\n\t\"-xpm\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# if defined(USE_XSMP_INTERACT)\n\t\"+xsmp_interact\",\n# elif defined(USE_XSMP)\n\t\"+xsmp\",\n# else\n\t\"-xsmp\",\n# endif\n# ifdef FEAT_XCLIPBOARD\n\t\"+xterm_clipboard\",\n# else\n\t\"-xterm_clipboard\",\n# endif\n#endif\n#ifdef FEAT_XTERM_SAVE\n\t\"+xterm_save\",\n#else\n\t\"-xterm_save\",\n#endif\n\tNULL\n};\n\nstatic int included_patches[] =\n{   /* Add new patch number below this line */\n/**/\n    105,\n/**/\n    104,\n/**/\n    103,\n/**/\n    102,\n/**/\n    101,\n/**/\n    100,\n/**/\n    99,\n/**/\n    98,\n/**/\n    97,\n/**/\n    96,\n/**/\n    95,\n/**/\n    94,\n/**/\n    93,\n/**/\n    92,\n/**/\n    91,\n/**/\n    90,\n/**/\n    89,\n/**/\n    88,\n/**/\n    87,\n/**/\n    86,\n/**/\n    85,\n/**/\n    84,\n/**/\n    83,\n/**/\n    82,\n/**/\n    81,\n/**/\n    80,\n/**/\n    79,\n/**/\n    78,\n/**/\n    77,\n/**/\n    76,\n/**/\n    75,\n/**/\n    74,\n/**/\n    73,\n/**/\n    72,\n/**/\n    71,\n/**/\n    70,\n/**/\n    69,\n/**/\n    68,\n/**/\n    67,\n/**/\n    66,\n/**/\n    65,\n/**/\n    64,\n/**/\n    63,\n/**/\n    62,\n/**/\n    61,\n/**/\n    60,\n/**/\n    59,\n/**/\n    58,\n/**/\n    57,\n/**/\n    56,\n/**/\n    55,\n/**/\n    54,\n/**/\n    53,\n/**/\n    52,\n/**/\n    51,\n/**/\n    50,\n/**/\n    49,\n/**/\n    48,\n/**/\n    47,\n/**/\n    46,\n/**/\n    45,\n/**/\n    44,\n/**/\n    43,\n/**/\n    42,\n/**/\n    41,\n/**/\n    40,\n/**/\n    39,\n/**/\n    38,\n/**/\n    37,\n/**/\n    36,\n/**/\n    35,\n/**/\n    34,\n/**/\n    33,\n/**/\n    32,\n/**/\n    31,\n/**/\n    30,\n/**/\n    29,\n/**/\n    28,\n/**/\n    27,\n/**/\n    26,\n/**/\n    25,\n/**/\n    24,\n/**/\n    23,\n/**/\n    22,\n/**/\n    21,\n/**/\n    20,\n/**/\n    19,\n/**/\n    18,\n/**/\n    17,\n/**/\n    16,\n/**/\n    15,\n/**/\n    14,\n/**/\n    13,\n/**/\n    12,\n/**/\n    11,\n/**/\n    10,\n/**/\n    9,\n/**/\n    8,\n/**/\n    7,\n/**/\n    6,\n/**/\n    5,\n/**/\n    4,\n/**/\n    3,\n/**/\n    2,\n/**/\n    1,\n/**/\n    0\n};\n\n/*\n * Place to put a short description when adding a feature with a patch.\n * Keep it short, e.g.,: \"relative numbers\", \"persistent undo\".\n * Also add a comment marker to separate the lines.\n * See the official Vim patches for the diff format: It must use a context of\n * one line only.  Create it by hand or use \"diff -C2\" and edit the patch.\n */\nstatic char *(extra_patches[]) =\n{   /* Add your patch description below this line */\n/**/\n    NULL\n};\n\n    int\nhighest_patch(void)\n{\n    // this relies on the highest patch number to be the first entry\n    return included_patches[0];\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return TRUE if patch \"n\" has been included.\n */\n    int\nhas_patch(int n)\n{\n    int\t\th, m, l;\n\n    // Perform a binary search.\n    l = 0;\n    h = (int)ARRAY_LENGTH(included_patches) - 1;\n    for (;;)\n    {\n\tm = (l + h) / 2;\n\tif (included_patches[m] == n)\n\t    return TRUE;\n\tif (l == h)\n\t    break;\n\tif (included_patches[m] < n)\n\t    h = m;\n\telse\n\t    l = m + 1;\n    }\n    return FALSE;\n}\n#endif\n\n    void\nex_version(exarg_T *eap)\n{\n    /*\n     * Ignore a \":version 9.99\" command.\n     */\n    if (*eap->arg == NUL)\n    {\n\tmsg_putchar('\\n');\n\tlist_version();\n    }\n}\n\n/*\n * Output a string for the version message.  If it's going to wrap, output a\n * newline, unless the message is too long to fit on the screen anyway.\n * When \"wrap\" is TRUE wrap the string in [].\n */\n    static void\nversion_msg_wrap(char_u *s, int wrap)\n{\n    int\t\tlen = vim_strsize(s) + (wrap ? 2 : 0);\n\n    if (!got_int && len < (int)Columns && msg_col + len >= (int)Columns\n\t\t\t\t\t\t\t\t&& *s != '\\n')\n\tmsg_putchar('\\n');\n    if (!got_int)\n    {\n\tif (wrap)\n\t    msg_puts(\"[\");\n\tmsg_puts((char *)s);\n\tif (wrap)\n\t    msg_puts(\"]\");\n    }\n}\n\n    static void\nversion_msg(char *s)\n{\n    version_msg_wrap((char_u *)s, FALSE);\n}\n\n/*\n * List all features aligned in columns, dictionary style.\n */\n    static void\nlist_features(void)\n{\n    list_in_columns((char_u **)features, -1, -1);\n}\n\n/*\n * List string items nicely aligned in columns.\n * When \"size\" is < 0 then the last entry is marked with NULL.\n * The entry with index \"current\" is inclosed in [].\n */\n    void\nlist_in_columns(char_u **items, int size, int current)\n{\n    int\t\ti;\n    int\t\tncol;\n    int\t\tnrow;\n    int\t\tcur_row = 1;\n    int\t\titem_count = 0;\n    int\t\twidth = 0;\n#ifdef FEAT_SYN_HL\n    int\t\tuse_highlight = (items == (char_u **)features);\n#endif\n\n    // Find the length of the longest item, use that + 1 as the column\n    // width.\n    for (i = 0; size < 0 ? items[i] != NULL : i < size; ++i)\n    {\n\tint l = vim_strsize(items[i]) + (i == current ? 2 : 0);\n\n\tif (l > width)\n\t    width = l;\n\t++item_count;\n    }\n    width += 1;\n\n    if (Columns < width)\n    {\n\t// Not enough screen columns - show one per line\n\tfor (i = 0; i < item_count; ++i)\n\t{\n\t    version_msg_wrap(items[i], i == current);\n\t    if (msg_col > 0 && i < item_count - 1)\n\t\tmsg_putchar('\\n');\n\t}\n\treturn;\n    }\n\n    // The rightmost column doesn't need a separator.\n    // Sacrifice it to fit in one more column if possible.\n    ncol = (int) (Columns + 1) / width;\n    nrow = item_count / ncol + ((item_count % ncol) ? 1 : 0);\n\n    // \"i\" counts columns then rows.  \"idx\" counts rows then columns.\n    for (i = 0; !got_int && i < nrow * ncol; ++i)\n    {\n\tint idx = (i / ncol) + (i % ncol) * nrow;\n\n\tif (idx < item_count)\n\t{\n\t    int last_col = (i + 1) % ncol == 0;\n\n\t    if (idx == current)\n\t\tmsg_putchar('[');\n#ifdef FEAT_SYN_HL\n\t    if (use_highlight && items[idx][0] == '-')\n\t\tmsg_puts_attr((char *)items[idx], HL_ATTR(HLF_W));\n\t    else\n#endif\n\t\tmsg_puts((char *)items[idx]);\n\t    if (idx == current)\n\t\tmsg_putchar(']');\n\t    if (last_col)\n\t    {\n\t\tif (msg_col > 0 && cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t    else\n\t    {\n\t\twhile (msg_col % width)\n\t\t    msg_putchar(' ');\n\t    }\n\t}\n\telse\n\t{\n\t    // this row is out of items, thus at the end of the row\n\t    if (msg_col > 0)\n\t    {\n\t\tif (cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t}\n    }\n}\n\n    void\nlist_version(void)\n{\n    int\t\ti;\n    int\t\tfirst;\n    char\t*s = \"\";\n\n    /*\n     * When adding features here, don't forget to update the list of\n     * internal variables in eval.c!\n     */\n    init_longVersion();\n    msg(longVersion);\n#ifdef MSWIN\n# ifdef FEAT_GUI_MSWIN\n#  ifdef VIMDLL\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI/console version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI/console version\"));\n#   endif\n#  else\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI version\"));\n#   endif\n#  endif\n#  ifdef FEAT_OLE\n    msg_puts(_(\" with OLE support\"));\n#  endif\n# else\n#  ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit console version\"));\n#  else\n    msg_puts(_(\"\\nMS-Windows 32-bit console version\"));\n#  endif\n# endif\n#endif\n#if defined(MACOS_X)\n# if defined(MACOS_X_DARWIN)\n    msg_puts(_(\"\\nmacOS version\"));\n# else\n    msg_puts(_(\"\\nmacOS version w/o darwin feat.\"));\n# endif\n# if defined(__arm64__)\n    msg_puts(\" - arm64\");\n# elif defined(__x86_64__)\n    msg_puts(\" - x86_64\");\n# endif\n#endif\n\n#ifdef VMS\n    msg_puts(_(\"\\nOpenVMS version\"));\n# ifdef HAVE_PATHDEF\n    if (*compiled_arch != NUL)\n    {\n\tmsg_puts(\" - \");\n\tmsg_puts((char *)compiled_arch);\n    }\n# endif\n\n#endif\n\n    // Print the list of patch numbers if there is at least one.\n    // Print a range when patches are consecutive: \"1-10, 12, 15-40, 42-45\"\n    if (included_patches[0] != 0)\n    {\n\tmsg_puts(_(\"\\nIncluded patches: \"));\n\tfirst = -1;\n\ti = (int)ARRAY_LENGTH(included_patches) - 1;\n\twhile (--i >= 0)\n\t{\n\t    if (first < 0)\n\t\tfirst = included_patches[i];\n\t    if (i == 0 || included_patches[i - 1] != included_patches[i] + 1)\n\t    {\n\t\tmsg_puts(s);\n\t\ts = \", \";\n\t\tmsg_outnum((long)first);\n\t\tif (first != included_patches[i])\n\t\t{\n\t\t    msg_puts(\"-\");\n\t\t    msg_outnum((long)included_patches[i]);\n\t\t}\n\t\tfirst = -1;\n\t    }\n\t}\n    }\n\n    // Print the list of extra patch descriptions if there is at least one.\n    if (extra_patches[0] != NULL)\n    {\n\tmsg_puts(_(\"\\nExtra patches: \"));\n\ts = \"\";\n\tfor (i = 0; extra_patches[i] != NULL; ++i)\n\t{\n\t    msg_puts(s);\n\t    s = \", \";\n\t    msg_puts(extra_patches[i]);\n\t}\n    }\n\n#ifdef MODIFIED_BY\n    msg_puts(\"\\n\");\n    msg_puts(_(\"Modified by \"));\n    msg_puts(MODIFIED_BY);\n#endif\n\n#ifdef HAVE_PATHDEF\n    if (*compiled_user != NUL || *compiled_sys != NUL)\n    {\n\tmsg_puts(_(\"\\nCompiled \"));\n\tif (*compiled_user != NUL)\n\t{\n\t    msg_puts(_(\"by \"));\n\t    msg_puts((char *)compiled_user);\n\t}\n\tif (*compiled_sys != NUL)\n\t{\n\t    msg_puts(\"@\");\n\t    msg_puts((char *)compiled_sys);\n\t}\n    }\n#endif\n\n#if defined(FEAT_HUGE)\n    msg_puts(_(\"\\nHuge version \"));\n#elif defined(FEAT_BIG)\n    msg_puts(_(\"\\nBig version \"));\n#elif defined(FEAT_NORMAL)\n    msg_puts(_(\"\\nNormal version \"));\n#elif defined(FEAT_SMALL)\n    msg_puts(_(\"\\nSmall version \"));\n#else\n    msg_puts(_(\"\\nTiny version \"));\n#endif\n#if !defined(FEAT_GUI)\n    msg_puts(_(\"without GUI.\"));\n#elif defined(FEAT_GUI_GTK)\n# if defined(USE_GTK3)\n    msg_puts(_(\"with GTK3 GUI.\"));\n# elif defined(FEAT_GUI_GNOME)\n     msg_puts(_(\"with GTK2-GNOME GUI.\"));\n# else\n     msg_puts(_(\"with GTK2 GUI.\"));\n# endif\n#elif defined(FEAT_GUI_MOTIF)\n    msg_puts(_(\"with X11-Motif GUI.\"));\n#elif defined(FEAT_GUI_HAIKU)\n    msg_puts(_(\"with Haiku GUI.\"));\n#elif defined(FEAT_GUI_PHOTON)\n    msg_puts(_(\"with Photon GUI.\"));\n#elif defined(MSWIN)\n    msg_puts(_(\"with GUI.\"));\n#endif\n    version_msg(_(\"  Features included (+) or not (-):\\n\"));\n\n    list_features();\n    if (msg_col > 0)\n\tmsg_putchar('\\n');\n\n#ifdef SYS_VIMRC_FILE\n    version_msg(_(\"   system vimrc file: \\\"\"));\n    version_msg(SYS_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE\n    version_msg(_(\"     user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE2\n    version_msg(_(\" 2nd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE3\n    version_msg(_(\" 3rd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE\n    version_msg(_(\"      user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE2\n    version_msg(_(\"  2nd user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef FEAT_GUI\n# ifdef SYS_GVIMRC_FILE\n    version_msg(_(\"  system gvimrc file: \\\"\"));\n    version_msg(SYS_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n    version_msg(_(\"    user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# ifdef USR_GVIMRC_FILE2\n    version_msg(_(\"2nd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n# endif\n# ifdef USR_GVIMRC_FILE3\n    version_msg(_(\"3rd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n    version_msg(_(\"       defaults file: \\\"\"));\n    version_msg(VIM_DEFAULTS_FILE);\n    version_msg(\"\\\"\\n\");\n#ifdef FEAT_GUI\n# ifdef SYS_MENU_FILE\n    version_msg(_(\"    system menu file: \\\"\"));\n    version_msg(SYS_MENU_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n#ifdef HAVE_PATHDEF\n    if (*default_vim_dir != NUL)\n    {\n\tversion_msg(_(\"  fall-back for $VIM: \\\"\"));\n\tversion_msg((char *)default_vim_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    if (*default_vimruntime_dir != NUL)\n    {\n\tversion_msg(_(\" f-b for $VIMRUNTIME: \\\"\"));\n\tversion_msg((char *)default_vimruntime_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    version_msg(_(\"Compilation: \"));\n    version_msg((char *)all_cflags);\n    version_msg(\"\\n\");\n#ifdef VMS\n    if (*compiler_version != NUL)\n    {\n\tversion_msg(_(\"Compiler: \"));\n\tversion_msg((char *)compiler_version);\n\tversion_msg(\"\\n\");\n    }\n#endif\n    version_msg(_(\"Linking: \"));\n    version_msg((char *)all_lflags);\n#endif\n#ifdef DEBUG\n    version_msg(\"\\n\");\n    version_msg(_(\"  DEBUG BUILD\"));\n#endif\n}\n\nstatic void do_intro_line(int row, char_u *mesg, int add_version, int attr);\nstatic void intro_message(int colon);\n\n/*\n * Show the intro message when not editing a file.\n */\n    void\nmaybe_intro_message(void)\n{\n    if (BUFEMPTY()\n\t    && curbuf->b_fname == NULL\n\t    && firstwin->w_next == NULL\n\t    && vim_strchr(p_shm, SHM_INTRO) == NULL)\n\tintro_message(FALSE);\n}\n\n/*\n * Give an introductory message about Vim.\n * Only used when starting Vim on an empty file, without a file name.\n * Or with the \":intro\" command (for Sven :-).\n */\n    static void\nintro_message(\n    int\t\tcolon)\t\t// TRUE for \":intro\"\n{\n    int\t\ti;\n    int\t\trow;\n    int\t\tblanklines;\n    int\t\tsponsor;\n    char\t*p;\n    static char\t*(lines[]) =\n    {\n\tN_(\"VIM - Vi IMproved\"),\n\t\"\",\n\tN_(\"version \"),\n\tN_(\"by Bram Moolenaar et al.\"),\n#ifdef MODIFIED_BY\n\t\" \",\n#endif\n\tN_(\"Vim is open source and freely distributable\"),\n\t\"\",\n\tN_(\"Help poor children in Uganda!\"),\n\tN_(\"type  :help iccf<Enter>       for information \"),\n\t\"\",\n\tN_(\"type  :q<Enter>               to exit         \"),\n\tN_(\"type  :help<Enter>  or  <F1>  for on-line help\"),\n\tN_(\"type  :help version9<Enter>   for version info\"),\n\tNULL,\n\t\"\",\n\tN_(\"Running in Vi compatible mode\"),\n\tN_(\"type  :set nocp<Enter>        for Vim defaults\"),\n\tN_(\"type  :help cp-default<Enter> for info on this\"),\n    };\n#ifdef FEAT_GUI\n    static char\t*(gui_lines[]) =\n    {\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n#ifdef MODIFIED_BY\n\tNULL,\n#endif\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Help->Orphans           for information    \"),\n\tNULL,\n\tN_(\"Running modeless, typed text is inserted\"),\n\tN_(\"menu  Edit->Global Settings->Toggle Insert Mode  \"),\n\tN_(\"                              for two modes      \"),\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Edit->Global Settings->Toggle Vi Compatible\"),\n\tN_(\"                              for Vim defaults   \"),\n    };\n#endif\n\n    // blanklines = screen height - # message lines\n    blanklines = (int)Rows - (ARRAY_LENGTH(lines) - 1);\n    if (!p_cp)\n\tblanklines += 4;  // add 4 for not showing \"Vi compatible\" message\n\n    // Don't overwrite a statusline.  Depends on 'cmdheight'.\n    if (p_ls > 1)\n\tblanklines -= Rows - topframe->fr_height;\n    if (blanklines < 0)\n\tblanklines = 0;\n\n    // Show the sponsor and register message one out of four times, the Uganda\n    // message two out of four times.\n    sponsor = (int)time(NULL);\n    sponsor = ((sponsor & 2) == 0) - ((sponsor & 4) == 0);\n\n    // start displaying the message lines after half of the blank lines\n    row = blanklines / 2;\n    if ((row >= 2 && Columns >= 50) || colon)\n    {\n\tfor (i = 0; i < (int)ARRAY_LENGTH(lines); ++i)\n\t{\n\t    p = lines[i];\n#ifdef FEAT_GUI\n\t    if (p_im && gui.in_use && gui_lines[i] != NULL)\n\t\tp = gui_lines[i];\n#endif\n\t    if (p == NULL)\n\t    {\n\t\tif (!p_cp)\n\t\t    break;\n\t\tcontinue;\n\t    }\n\t    if (sponsor != 0)\n\t    {\n\t\tif (strstr(p, \"children\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"Sponsor Vim development!\")\n\t\t\t: N_(\"Become a registered Vim user!\");\n\t\telse if (strstr(p, \"iccf\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"type  :help sponsor<Enter>    for information \")\n\t\t\t: N_(\"type  :help register<Enter>   for information \");\n\t\telse if (strstr(p, \"Orphans\") != NULL)\n\t\t    p = N_(\"menu  Help->Sponsor/Register  for information    \");\n\t    }\n\t    if (*p != NUL)\n\t\tdo_intro_line(row, (char_u *)_(p), i == 2, 0);\n\t    ++row;\n\t}\n    }\n\n    // Make the wait-return message appear just below the text.\n    if (colon)\n\tmsg_row = row;\n}\n\n    static void\ndo_intro_line(\n    int\t\trow,\n    char_u\t*mesg,\n    int\t\tadd_version,\n    int\t\tattr)\n{\n    char_u\tvers[20];\n    int\t\tcol;\n    char_u\t*p;\n    int\t\tl;\n    int\t\tclen;\n#ifdef MODIFIED_BY\n# define MODBY_LEN 150\n    char_u\tmodby[MODBY_LEN];\n\n    if (*mesg == ' ')\n    {\n\tvim_strncpy(modby, (char_u *)_(\"Modified by \"), MODBY_LEN - 1);\n\tl = (int)STRLEN(modby);\n\tvim_strncpy(modby + l, (char_u *)MODIFIED_BY, MODBY_LEN - l - 1);\n\tmesg = modby;\n    }\n#endif\n\n    // Center the message horizontally.\n    col = vim_strsize(mesg);\n    if (add_version)\n    {\n\tSTRCPY(vers, mediumVersion);\n\tif (highest_patch())\n\t{\n\t    // Check for 9.9x or 9.9xx, alpha/beta version\n\t    if (isalpha((int)vers[3]))\n\t    {\n\t\tint len = (isalpha((int)vers[4])) ? 5 : 4;\n\t\tsprintf((char *)vers + len, \".%d%s\", highest_patch(),\n\t\t\t\t\t\t\t mediumVersion + len);\n\t    }\n\t    else\n\t\tsprintf((char *)vers + 3, \".%d\", highest_patch());\n\t}\n\tcol += (int)STRLEN(vers);\n    }\n    col = (Columns - col) / 2;\n    if (col < 0)\n\tcol = 0;\n\n    // Split up in parts to highlight <> items differently.\n    for (p = mesg; *p != NUL; p += l)\n    {\n\tclen = 0;\n\tfor (l = 0; p[l] != NUL\n\t\t\t && (l == 0 || (p[l] != '<' && p[l - 1] != '>')); ++l)\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tclen += ptr2cells(p + l);\n\t\tl += (*mb_ptr2len)(p + l) - 1;\n\t    }\n\t    else\n\t\tclen += byte2cells(p[l]);\n\t}\n\tscreen_puts_len(p, l, row, col, *p == '<' ? HL_ATTR(HLF_8) : attr);\n\tcol += clen;\n    }\n\n    // Add the version number to the version line.\n    if (add_version)\n\tscreen_puts(vers, row, col, 0);\n}\n\n/*\n * \":intro\": clear screen, display intro screen and wait for return.\n */\n    void\nex_intro(exarg_T *eap UNUSED)\n{\n    screenclear();\n    intro_message(TRUE);\n    wait_return(TRUE);\n}\n"], "filenames": ["src/regexp.c", "src/testdir/test_regexp_utf8.vim", "src/version.c"], "buggy_code_start_loc": [1644, 1, 737], "buggy_code_end_loc": [1645, 562, 737], "fixing_code_start_loc": [1644, 2, 738], "fixing_code_end_loc": [1649, 578, 740], "type": "CWE-125", "message": "Out-of-bounds Read in GitHub repository vim/vim prior to 9.0.0104.", "other": {"cve": {"id": "CVE-2022-2581", "sourceIdentifier": "security@huntr.dev", "published": "2022-08-01T15:15:09.520", "lastModified": "2022-08-04T23:30:00.973", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Out-of-bounds Read in GitHub repository vim/vim prior to 9.0.0104."}, {"lang": "es", "value": "Una Lectura Fuera de L\u00edmites en el repositorio de GitHub vim/vim versiones anteriores a 9.0.0104"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:vim:vim:*:*:*:*:*:*:*:*", "versionEndExcluding": "9.0.0104", "matchCriteriaId": "22C1B824-A312-45C5-814A-04602A219935"}]}]}], "references": [{"url": "https://github.com/vim/vim/commit/f50940531dd57135fe60aa393ac9d3281f352d88", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/0bedbae2-82ae-46ae-aa68-1c28b309b60b", "source": "security@huntr.dev", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/vim/vim/commit/f50940531dd57135fe60aa393ac9d3281f352d88"}}