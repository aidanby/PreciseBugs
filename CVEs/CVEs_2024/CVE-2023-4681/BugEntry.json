{"buggy_code": ["/*\n *\t\t\tGPAC - Multimedia Framework C SDK\n *\n *\t\t\tAuthors: Jean Le Feuvre\n *\t\t\tCopyright (c) Telecom ParisTech 2018-2023\n *\t\t\t\t\tAll rights reserved\n *\n *  This file is part of GPAC / MPEG-DASH/HLS segmenter\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n#include <gpac/filters.h>\n#include <gpac/constants.h>\n#include <gpac/iso639.h>\n#include <gpac/mpd.h>\n#include <gpac/internal/media_dev.h>\n#include <gpac/base_coding.h>\n#include <gpac/network.h>\n#include <gpac/crypt_tools.h>\n\n#ifndef GPAC_DISABLE_DASHER\n\n#define DEFAULT_PERIOD_ID\t \"_gf_dash_def_period\"\n\ntypedef struct\n{\n\tGF_List *streams;\n\n\t//period element we will fill\n\tGF_MPD_Period *period;\n} GF_DasherPeriod;\n\nenum\n{\n\tDASHER_BS_SWITCH_DEF=0,\n\tDASHER_BS_SWITCH_OFF,\n\tDASHER_BS_SWITCH_ON,\n\tDASHER_BS_SWITCH_INBAND,\n\tDASHER_BS_SWITCH_INBAND_PPS,\n\tDASHER_BS_SWITCH_BOTH,\n\tDASHER_BS_SWITCH_FORCE,\n\tDASHER_BS_SWITCH_MULTI,\n};\n\ntypedef enum\n{\n\tDASHER_UTCREF_NONE=0,\n\tDASHER_UTCREF_NTP,\n\tDASHER_UTCREF_HTTP_HEAD,\n\tDASHER_UTCREF_ISO,\n\tDASHER_UTCREF_XSDATE,\n\tDASHER_UTCREF_INBAND,\n} DasherUTCTimingType;\n\nenum\n{\n\tDASHER_NTP_REM=0,\n\tDASHER_NTP_YES,\n\tDASHER_NTP_KEEP,\n};\n\nenum\n{\n\tDASHER_SAP_OFF=0,\n\tDASHER_SAP_SIG,\n\tDASHER_SAP_ON,\n\tDASHER_SAP_INTRA_ONLY,\n};\n\nenum\n{\n\tDASHER_BOUNDS_OUT=0,\n\tDASHER_BOUNDS_CLOSEST,\n\tDASHER_BOUNDS_IN,\n};\n\nenum\n{\n\tDASHER_MUX_ISOM=0,\n\tDASHER_MUX_TS,\n\tDASHER_MUX_MKV,\n\tDASHER_MUX_WEBM,\n\tDASHER_MUX_OGG,\n\tDASHER_MUX_RAW,\n\tDASHER_MUX_AUTO,\n};\n\nenum\n{\n\tDASHER_MPHA_NO=0,\n\tDASHER_MPHA_COMP_ONLY,\n\tDASHER_MPHA_ALL\n};\n\nenum\n{\n\tDASHER_FWD_NO = 0,\n\tDASHER_FWD_SEGS,\n\tDASHER_FWD_ALL,\n};\n\nenum\n{\n\t//unknown samples sync state at startup\n\tDASHER_SYNC_UNKNOWN=0,\n\t//all samples sync\n\tDASHER_SYNC_NONE,\n\t//some samples sync\n\tDASHER_SYNC_PRESENT,\n};\n\nenum\n{\n\tDASHER_CMAF_NONE=0,\n\tDASHER_CMAF_CMFC,\n\tDASHER_CMAF_CMF2\n};\n\nenum\n{\n\tDASHER_DEFKID_OFF=0,\n\tDASHER_DEFKID_ON,\n\tDASHER_DEFKID_AUTO\n};\n\nenum\n{\n\tDASHER_PSWITCH_SINGLE=0,\n\tDASHER_PSWITCH_FORCE,\n\tDASHER_PSWITCH_STSD\n};\nenum\n{\n\tDASHER_SEGSYNC_NO=0,\n\tDASHER_SEGSYNC_YES,\n\tDASHER_SEGSYNC_AUTO\n};\n\nenum\n{\n\tIDXMODE_NONE=0,\n\tIDXMODE_ALL,\n\tIDXMODE_MANIFEST,\n\tIDXMODE_CHILD,\n\tIDXMODE_INIT,\n\tIDXMODE_SEG,\n};\n\ntypedef struct\n{\n\tu32 bs_switch, profile, spd, cp, ntp;\n\ts32 subs_sidx;\n\ts32 buf, timescale;\n\tBool sfile, sseg, no_sar, mix_codecs, stl, tpl, align, sap, no_frag_def, sidx, split, hlsc, strict_cues, force_flush, last_seg_merge;\n\tu32 mha_compat;\n\tu32 strict_sap;\n\tu32 pssh;\n\tu32 cmaf;\n\tu32 dkid;\n\tGF_Fraction segdur;\n\tu32 dmode;\n\tchar *template;\n\tchar *segext;\n\tchar *initext;\n\tu32 muxtype;\n\tBool rawsub;\n\tchar *profX;\n\tDouble asto;\n\tchar *ast;\n\tchar *state;\n\tchar *cues;\n\tchar *title, *source, *info, *cprt, *lang;\n\tchar *chain, *chain_fbk;\n\tGF_PropStringList location, base;\n\tBool check_dur, skip_seg, loop, reschedule, scope_deps, keep_src, tpl_force;\n\tDouble refresh, tsb, subdur;\n\tu64 *_p_gentime, *_p_mpdtime;\n\tBool cmpd, dual, sreg;\n\tchar *styp;\n\tBool sigfrag;\n\tu32 sbound, pswitch;\n\tchar *utcs;\n\tchar *mname;\n\tchar *hlsdrm;\n\tchar *ckurl;\n\tGF_PropStringList hlsx;\n\tu32 llhls;\n\t//inherited from mp4mx\n\tGF_Fraction cdur;\n\tBool ll_preload_hint, ll_rend_rep;\n\tBool gencues, force_init, gxns;\n\tDouble ll_part_hb;\n\tu32 hls_absu, seg_sync;\n\n\t//internal\n\tBool in_error;\n\n\t//Manifest output pid\n\tGF_FilterPid *opid;\n\n\tGF_FilterPid *opid_alt;\n\tGF_Filter *alt_dst;\n\tBool opid_alt_m3u8;\n\n\tGF_MPD *mpd;\n\n\tGF_DasherPeriod *current_period, *next_period;\n\tGF_List *pids;\n\tBool template_use_source;\n\ts32 period_idx;\n\n\tGF_List *tpl_records;\n\tBool use_xlink, use_cenc, check_main_role, use_clearkey;\n\n\t//options for muxers, constrained by profile\n\tBool no_fragments_defaults;\n\n\tBool is_eos;\n\tu32 nb_seg_url_pending;\n\tu64 last_evt_check_time;\n\tBool on_demand_done;\n\tBool subdur_done;\n\tchar *out_path;\n\n\tGF_Err setup_failure;\n\n\tDouble nb_secs_to_discard;\n\tBool first_context_load, store_init_params;\n\tBool do_m3u8, do_mpd;\n\tu32 do_index;\n\tBool is_period_restore, is_empty_period;\n\n\tBool store_seg_states;\n\n\tGF_List *postponed_pids;\n\tu32 last_dyn_period_id;\n\tu32 next_pid_id_in_period;\n\tBool post_play_events;\n\n\tBool force_period_switch;\n\tBool period_not_ready;\n\tBool check_connections;\n\n\t//-1 forces report update, otherwise this is a packet count\n\ts32 update_report;\n\n\tBool purge_segments;\n\n\tBool is_playing;\n\n\tBool no_seg_dur;\n\n\tu32 utc_initialized;\n#ifdef GPAC_USE_DOWNLOADER\n\tGF_DownloadSession *utc_sess;\n#endif\n\n\tDasherUTCTimingType utc_timing_type;\n\ts32 utc_diff;\n\n\tBool is_route;\n\n\tBool force_hls_ll_manifest;\n\n\tu32 forward_mode;\n\t\n\tu8 last_hls_signature[GF_SHA1_DIGEST_SIZE], last_mpd_signature[GF_SHA1_DIGEST_SIZE], last_hls2_signature[GF_SHA1_DIGEST_SIZE];\n\n\tGF_CryptInfo *cinfo;\n\n\tBool use_cues;\n\tBool dyn_rate;\n\n\tu64 min_segment_start_time, last_min_segment_start_time;\n\n\tu32 def_max_seg_dur;\n\n\tu32 index_max_seg_dur;\n\tu64 index_media_duration;\n\tGF_Fraction64 min_cts_period;\n\n\tu32 from_index;\n\tu32 def_template;\n\n\tBool move_to_static;\n} GF_DasherCtx;\n\ntypedef enum\n{\n\tDASHER_HDR_NONE=0,\n\tDASHER_HDR_PQ10,\n\tDASHER_HDR_HLG,\n} DasherHDRType;\n\ntypedef struct _dash_stream\n{\n\tGF_FilterPid *ipid, *opid;\n\n\t//stream properties\n\tu32 codec_id, timescale, stream_type, dsi_crc, dsi_enh_crc, id, dep_id, src_id;\n\tGF_Fraction sar, fps;\n\tu32 width, height;\n\tu32 sr, nb_ch;\n\tchar *lang;\n\tBool interlaced, rawmux;\n\tconst GF_PropertyValue *p_role;\n\tconst GF_PropertyValue *p_period_desc;\n\tconst GF_PropertyValue *p_as_desc;\n\tconst GF_PropertyValue *p_as_any_desc;\n\tconst GF_PropertyValue *p_rep_desc;\n\tconst GF_PropertyValue *p_base_url;\n\tchar *template;\n\tchar *xlink;\n\tchar *hls_vp_name;\n\tu32 nb_surround, nb_lfe, atmos_complexity_type;\n\tu64 ch_layout;\n\tGF_PropVec4i srd;\n\tDasherHDRType hdr_type;\n\tBool sscale;\n\n\t//TODO: get the values for all below\n\tu32 view_id;\n\t//end of TODO\n\n\n\tu32 bitrate;\n\tGF_DasherPeriod *period;\n\tGF_MPD_Period *last_period;\n\n\tGF_Fraction dash_dur;\n\n\tchar *period_id;\n\tchar *period_continuity_id;\n\tGF_Fraction64 period_start;\n\tGF_Fraction64 period_dur;\n\t//0: not done, 1: eos/abort, 2: subdur exceeded\n\tu32 done;\n\tBool seg_done;\n\n\tu32 nb_comp, nb_comp_done;\n\n\tBool is_av;\n\n\tu32 nb_rep, nb_rep_done;\n\tDouble set_seg_duration;\n\n\t//repID for this stream, generated if not found\n\tchar *rep_id;\n\t//AS ID for this stream, may be 0\n\tu32 as_id;\n\tu32 sync_as_id;\n\tstruct _dash_stream *muxed_base;\n\tGF_List *complementary_streams;\n\tGF_List *comp_pids;\n\n\t//the one and only representation element\n\tGF_MPD_Representation *rep;\n\t//the parent adaptation set\n\tGF_MPD_AdaptationSet *set;\n\tBool owns_set;\n\t//set to 1 if full inband params, 2 if pps/aps only, 3 if both inband and outband, 0 otherwise\n\tu32 inband_params;\n\tGF_List *multi_pids;\n\tGF_List *multi_tracks;\n\t//in case we share the same init segment, we MUST use the same timescale\n\tu32 force_timescale;\n\n\n\tu32 startNumber, seg_number;\n\tBool rep_init;\n\tBool forced_period_switch;\n\tu64 first_cts;\n\tu64 first_dts;\n\ts64 pts_minus_cts;\n\tBool is_encrypted;\n\t//only used for SegmentTimeline\n\tu64 presentation_time_offset;\n\n\t//target MPD timescale\n\tu32 mpd_timescale;\n\t//segment start time in target MPD timescale\n\tu64 seg_start_time;\n\tBool split_set_names;\n\tBool skip_tpl_reuse;\n\tu64 max_period_dur;\n\n\tGF_Filter *dst_filter;\n\n\tchar *src_url;\n\n\tchar *init_seg, *seg_template, *idx_template;\n\tu32 nb_sap_3, nb_sap_4;\n\t//ID of output pid (renumbered), used for content component and making sure output muxers use the same IDs\n\tu32 pid_id;\n\t//dependency ID of output pid (renumbered)\n\tu32 dep_pid_id;\n\tu32 nb_samples_in_source;\n\tu32 sync_points_type;\n\t//seg urls not yet handled (waiting for size/index callbacks)\n\tGF_List *pending_segment_urls;\n\t//segment states not yet handled (waiting for size/index/etc callbacks), used for M3U8 and state mode\n\tGF_List *pending_segment_states;\n\t//next segment start time in this stream timescale (NOT MPD timescale)\n\tu64 next_seg_start;\n\t//adjusted next segment start time in this stream timescale (NOT MPD timescale)\n\t//the value is the same as next_seg_start until the end of segment is found (SAP)\n\t//in which case it is adjusted to the SAP time\n\tu64 adjusted_next_seg_start;\n\n\t//force representation time end in this stream timescale (NOT MPD timescale)\n\tu64 force_rep_end;\n\n\tBool segment_started;\n\tu64 first_cts_in_seg;\n\tu64 first_cts_in_next_seg;\n\tu64 min_cts_in_seg_plus_one;\n\t//used for last segment computation of segmentTimeline\n\tu64 est_first_cts_in_next_seg;\n\tu64 last_cts, last_dts;\n\tu64 cumulated_dur;\n\tDouble cumulated_subdur;\n\tBool subdur_done;\n\tu64 subdur_forced_use_period_dur;\n\tu64 nb_pck;\n\tu64 est_next_dts;\n\tu64 seek_to_pck;\n\tu64 ts_offset;\n\tu32 nb_repeat;\n\n\tBool splitable;\n\tu32 loop_state;\n\tu32 split_dur_next;\n\n\tu32 moof_sn_inc, moof_sn;\n\tGF_Fraction64 clamped_dur;\n\n\tu32 nb_segments_purged;\n\tDouble dur_purged;\n\tBool tile_base;\n\tBool tile_dep_id_merged;\n\tstruct _dash_stream *merged_tile_dep;\n\n\tu32 cues_timescale;\n\tu32 nb_cues;\n\tGF_DASHCueInfo *cues;\n\tBool cues_use_edits;\n\ts32 cues_ts_offset;\n\tBool inband_cues;\n\t\n\tBool clamp_done;\n\tu32 dcd_not_ready;\n\n\tBool reschedule;\n\n\tGF_Fraction64 duration;\n\tGF_List *packet_queue;\n\tu32 nb_sap_in_queue;\n\tu32 sbound;\n\n\tu32 request_period_switch;\n\n\t//gm_ for gen manifest\n\tDouble gm_duration_total, gm_duration_min, gm_duration_max;\n\tu32 gm_nb_segments;\n\n\tBool no_seg_dur;\n\t//for route\n\tu64 hls_ref_id;\n\tGF_DASH_SegmentContext *current_seg_state;\n\n\tBool transcode_detected;\n\n\t//HLS full seg encryption\n\tGF_CryptInfo *cinfo;\n\tGF_TrackCryptInfo *tci;\n\tu64 iv_low, iv_high;\n\tu32 key_idx;\n\tu32 nb_crypt_seg;\n\n\tBool dyn_bitrate;\n\tu64 rate_first_dts_plus_one, rate_last_dts;\n\tu64 rate_media_size;\n\n\tu64 period_continuity_next_cts;\n\n\tu64 last_min_segment_start_time;\n\tBool stl;\n\n\tBool set_period_switch;\n\tu32 all_stsd_crc;\n\n\tu64 frag_start_offset, frag_first_ftdt;\n} GF_DashStream;\n\nstatic void dasher_flush_segment(GF_DasherCtx *ctx, GF_DashStream *ds, Bool is_last_in_period);\nstatic void dasher_update_rep(GF_DasherCtx *ctx, GF_DashStream *ds);\nstatic void dasher_reset_stream(GF_Filter *filter, GF_DashStream *ds, Bool is_destroy);\nstatic void dasher_update_period_duration(GF_DasherCtx *ctx, Bool is_period_switch);\nstatic GF_Err dasher_setup_period(GF_Filter *filter, GF_DasherCtx *ctx, GF_DashStream *for_ds);\nstatic GF_Err dasher_setup_profile(GF_DasherCtx *ctx);\n\nstatic GF_DasherPeriod *dasher_new_period()\n{\n\tGF_DasherPeriod *period;\n\tGF_SAFEALLOC(period, GF_DasherPeriod);\n\tif (period)\n\t\tperiod->streams = gf_list_new();\n\treturn period;\n}\n\n#ifndef GPAC_DISABLE_AV_PARSERS\nstatic GF_Err dasher_get_audio_info_with_m4a_sbr_ps(GF_DashStream *ds, const GF_PropertyValue *dsi, u32 *SampleRate, u32 *Channels)\n{\n\tGF_M4ADecSpecInfo a_cfg;\n\tGF_Err e;\n\tif (SampleRate) *SampleRate = ds->sr;\n\tif (Channels) *Channels = ds->nb_ch;\n\n\tif (!dsi) {\n\t\tif (!ds->dcd_not_ready) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_DASH, (\"[Dasher] missing AAC config\\n\"));\n\t\t}\n\t\treturn GF_OK;\n\t}\n\te = gf_m4a_get_config(dsi->value.data.ptr, dsi->value.data.size, &a_cfg);\n\tif (e) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_DASH, (\"[Dasher] corrupted AAC Config, %s\\n\", gf_error_to_string(e)));\n\t\treturn GF_NOT_SUPPORTED;\n\t}\n\tif (SampleRate && a_cfg.has_sbr) {\n\t\t*SampleRate = a_cfg.sbr_sr;\n\t}\n\tif (Channels) *Channels = a_cfg.nb_chan;\n\treturn e;\n}\n#endif\n\n\nstatic void dasher_check_outpath(GF_DasherCtx *ctx)\n{\n\tif (!ctx->out_path) {\n\t\tctx->out_path = gf_filter_pid_get_destination(ctx->opid);\n\t\tif (!ctx->out_path) return;\n\n\t\tif (ctx->mname) {\n\t\t\tchar *sep = strstr(ctx->out_path, \"://\");\n\t\t\tif (sep) {\n\t\t\t\tchar *opath = gf_url_concatenate(ctx->out_path, ctx->mname);\n\t\t\t\tif (opath) {\n\t\t\t\t\tgf_free(ctx->out_path);\n\t\t\t\t\tctx->out_path = opath;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//check if we have a route/atsc output, in which we will case assign hls ref prop\n\t\tif (!strncmp(ctx->out_path, \"route://\", 8) || !strncmp(ctx->out_path, \"atsc://\", 7))\n\t\t\tctx->is_route = GF_TRUE;\n\t}\n\t//for routeout\n\tif (ctx->opid)\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_URL, &PROP_STRING(ctx->out_path) );\n\tif (ctx->opid_alt)\n\t\tgf_filter_pid_set_property(ctx->opid_alt, GF_PROP_PID_URL, &PROP_STRING(ctx->out_path) );\n}\n\n\nstatic GF_Err dasher_hls_setup_crypto(GF_DasherCtx *ctx, GF_DashStream *ds)\n{\n#ifndef GPAC_DISABLE_CRYPTO\n\tGF_Err e;\n\tu32 pid_id=1;\n\tu32 i, count;\n\tconst GF_PropertyValue *p;\n\tGF_CryptInfo *cinfo = NULL;\n\tconst char *drm = ctx->hlsdrm;\n\tif (!ctx->do_m3u8) return GF_OK;\n\tif (ds->is_encrypted) return GF_OK;\n\tp = gf_filter_pid_get_property(ds->ipid, GF_PROP_PID_CRYPT_INFO);\n\tif (p)\n\t\tdrm = p->value.string;\n\telse\n\t\tcinfo = ctx->cinfo;\n\tif (!drm && !cinfo) return GF_OK;\n\n\tif (ctx->sfile) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_DASH, (\"[Dasher] Cannot use HLS segment encryption with single file output\\n\"));\n\t\treturn GF_BAD_PARAM;\n\t}\n\n\tif (!cinfo) {\n\t\tcinfo = gf_crypt_info_load(drm, &e);\n\t\tif (!cinfo) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_DASH, (\"[Dasher] Cannot load HLS DRM file %s\\n\", drm ));\n\t\t\treturn e;\n\t\t}\n\t\tif (p) {\n\t\t\tif (ds->cinfo) gf_crypt_info_del(ds->cinfo);\n\t\t\tds->cinfo = cinfo;\n\t\t} else {\n\t\t\tctx->cinfo = cinfo;\n\t\t}\n\t}\n\tds->tci = NULL;\n\tp = gf_filter_pid_get_property(ds->ipid, GF_PROP_PID_ID);\n\tif (p) pid_id = p->value.uint;\n\tcount = gf_list_count(cinfo->tcis);\n\tfor (i=0; i<count; i++) {\n\t\tGF_TrackCryptInfo *tci = gf_list_get(cinfo->tcis, i);\n\t\tif (tci->trackID && (tci->trackID != pid_id)) continue;\n\n\t\tds->tci = tci;\n\t\tbreak;\n\t}\n\tif (!ds->tci) return GF_OK;\n\n\tds->key_idx = 0;\n\tds->iv_low = ds->iv_high = 0;\n\tfor (i=0; i<8; i++) {\n\t\tds->iv_high |= ds->tci->keys[ds->key_idx].IV[i];\n\t\tds->iv_low |= ds->tci->keys[ds->key_idx].IV[i + 8];\n\t\tif (i<7) {\n\t\t\tds->iv_high <<= 8;\n\t\t\tds->iv_low <<= 8;\n\t\t}\n\t}\n\treturn GF_OK;\n#else\n\treturn GF_NOT_SUPPORTED;\n#endif\n}\n\nstatic u32 dasher_get_dep_bitrate(GF_DasherCtx *ctx, GF_DashStream *ds)\n{\n\tu32 bitrate = ds->bitrate;\n\tif (ds->dep_id) {\n\t\tu32 i, count = gf_list_count(ctx->current_period->streams);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tGF_DashStream *a_ds = gf_list_get(ctx->current_period->streams, i);\n\t\t\tif (a_ds == ds) continue;\n\n\t\t\tif (gf_list_find(a_ds->complementary_streams, ds)>=0) {\n\n\t\t\t\tbitrate += dasher_get_dep_bitrate(ctx, a_ds);\n\t\t\t}\n\t\t}\n\t}\n\treturn bitrate;\n}\n\nstatic void dasher_update_bitrate(GF_DasherCtx *ctx, GF_DashStream *ds)\n{\n\tu64 rate;\n\tu32 scaler;\n\tif (!ds->dyn_bitrate || ds->bitrate) {\n\t\treturn;\n\t}\n\n\tif (!ds->rate_first_dts_plus_one) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_DASH, (\"[Dasher] Couldn't compute bitrate of PID %s in time for manifest generation, please specify #Bitrate property\\n\", gf_filter_pid_get_name(ds->ipid)));\n\t\treturn;\n\t}\n\n\trate = ds->rate_media_size;\n\trate *= 8;\n\tif (ds->rate_last_dts > ds->rate_first_dts_plus_one - 1) {\n\t\trate *= ds->timescale;\n\t\trate /= (ds->rate_last_dts - ds->rate_first_dts_plus_one + 1);\n\t} else {\n\t\trate *= ds->dash_dur.den;\n\t\trate /= ds->dash_dur.num;\n\t}\n\t//express rates in 100kbps or 10kbps, and if ds is done, trust the average, otherwise add 10%\n\tscaler = (rate > 1000000) ? 100000 : 10000;\n\tif (rate > 10*scaler) {\n\t\trate /= scaler;\n\t\tif (!ds->done) scaler = 11 * scaler / 10;\n\t\trate *= scaler;\n\t}\n\n\tds->bitrate = (u32) rate;\n\n\tif (ds->rep) {\n\t\tds->rep->bandwidth = ds->bitrate;\n\n\t\tif (ds->dep_id) {\n\t\t\tds->rep->bandwidth = dasher_get_dep_bitrate(ctx, ds);\n\t\t} else if (ds->nb_comp && !ds->muxed_base) {\n\t\t\tu32 i, count = gf_list_count(ctx->current_period->streams);\n\t\t\tfor (i=0; i<count; i++) {\n\t\t\t\tGF_DashStream *a_ds = gf_list_get(ctx->current_period->streams, i);\n\t\t\t\tif (ds == a_ds) continue;\n\t\t\t\tif (a_ds->muxed_base != ds) continue;\n\t\t\t\tif (a_ds->dyn_bitrate) {\n\t\t\t\t\tdasher_update_bitrate(ctx, a_ds);\n\t\t\t\t}\n\t\t\t\tds->rep->bandwidth += a_ds->bitrate;\n\t\t\t}\n\t\t}\n\t}\n\n\t//keep refreshing our rate estimation\n\tif (!ds->done && (ds->dyn_bitrate==1))\n\t\tds->bitrate = 0;\n}\n\n\nstatic GF_Err dasher_stream_period_changed(GF_Filter *filter, GF_DasherCtx *ctx, GF_DashStream *ds, Bool is_new_period_request)\n{\n\tGF_Err e = GF_OK;\n\t//period switching, check the stream is still scheduled - if so and not done, flush it, update period duration\n\ts32 res = gf_list_find(ctx->current_period->streams, ds);\n\t//force end of segment if stream is not yet done and in current period\n\tif ((res>=0) && !ds->done && !ds->seg_done) {\n\t\tGF_DashStream *base_ds;\n\n\t\tbase_ds = ds->muxed_base ? ds->muxed_base : ds;\n\t\tif (is_new_period_request) {\n\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_DASH, (\"[Dasher] New period requested during PID %s reconfiguration\\n\", gf_filter_pid_get_name(ds->ipid) ));\n\t\t} else {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_DASH, (\"[Dasher] PID %s config changed during active period, forcing period switch\\n\", gf_filter_pid_get_name(ds->ipid) ));\n\t\t}\n\t\tds->seg_done = GF_TRUE;\n\t\tif(base_ds->nb_comp_done >= base_ds->nb_comp) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_DASH, (\"[Dasher] Invalid new period: %u components processed (max %u expected)\\n\", base_ds->nb_comp_done, base_ds->nb_comp));\n\t\t\te = GF_BAD_PARAM;\n\t\t\tgoto exit;\n\t\t}\n\t\tbase_ds->nb_comp_done ++;\n\t\tds->first_cts_in_next_seg = ds->est_first_cts_in_next_seg;\n\n\t\tif (base_ds->nb_comp_done == base_ds->nb_comp) {\n\t\t\tdasher_flush_segment(ctx, base_ds, GF_TRUE);\n\t\t}\n\n\t\tctx->force_period_switch = GF_TRUE;\n\t\tdasher_update_period_duration(ctx, GF_TRUE);\n\t}\n\t//remove stream from period\n\tif (res>=0) {\n\t\t//force an EOS on this stream for ondemand / side index generation flush\n\t\tif (ds->opid)\n\t\t\tgf_filter_pid_set_eos(ds->opid);\n\t\tds->rep_init = GF_FALSE;\n\t\t//indicate this input is moved to next period. If a scheduled input is muxed with this one in the current period\n\t\t//it will abort its current segment\n\t\tds->forced_period_switch = GF_TRUE;\n\t\tds->presentation_time_offset = 0;\n\t\tgf_list_rem(ctx->current_period->streams, res);\n\t} else {\n\t\t//stream is not in current period, and this is not an explicit new period request\n\t\t//if the period was not ready (not yet setup), add to current streams\n\t\t//this is needed for cases such as HEVC tiling where secondary pids are added after the main pid is configured\n\t\t//see issue 1849\n\t\tif (!is_new_period_request && ctx->period_not_ready && !ds->rep) {\n\t\t\tgf_list_add(ctx->current_period->streams, ds);\n\t\t\tds->period = ctx->current_period;\n\t\t\tds->request_period_switch = 0;\n\t\t\te = GF_OK;\n\t\t\tgoto exit;\n\t\t}\n\t}\n\tds->request_period_switch = 0;\n\n\t//this is tricky, when reassigning period IDs in the middle of a stream, we may have cases where some streams\n\t//are ready several packets before other streams due to processing delay, which results in period switch signal not\n\t//happening at the same time\n\tif (is_new_period_request && !ds->rep && ctx->current_period->period && gf_list_count(ctx->current_period->streams)) {\n\t\tBool inject_in_period = GF_FALSE;\n\t\tif (ds->period_id && ctx->current_period->period->ID && !strcmp(ds->period_id, ctx->current_period->period->ID))\n\t\t\tinject_in_period = GF_TRUE;\n\t\telse if ((ctx->period_idx>0) && (ds->period_start.num<0) && ((s32) -ds->period_start.num == ctx->period_idx))\n\t\t\tinject_in_period = GF_TRUE;\n\t\telse if (ds->period_start.num * 1000 == ctx->current_period->period->start * ds->period_start.den)\n\t\t\tinject_in_period = GF_TRUE;\n\n\t\tif (inject_in_period) {\n\t\t\tgf_list_add(ctx->current_period->streams, ds);\n\t\t\tds->period = ctx->current_period;\n\t\t\tdasher_setup_period(filter, ctx, ds);\n\t\t\t//force a MPD publish asap\n\t\t\tif (ctx->dmode != GF_DASH_STATIC)\n\t\t\t\tctx->mpd->publishTime = 0;\n\t\t\te = GF_OK;\n\t\t\tgoto exit;\n\t\t}\n\t}\n\tgf_list_add(ctx->next_period->streams, ds);\n\tds->period = ctx->next_period;\n\nexit:\n\n\tds->stl = ctx->stl;\n\tif (ctx->sigfrag) {\n\t\tconst GF_PropertyValue *p = gf_filter_pid_get_property_str(ds->ipid, \"source_template\");\n\t\tif (p) {\n\t\t\tp = gf_filter_pid_get_property_str(ds->ipid, \"stl_timescale\");\n\t\t\tif (p && p->value.uint) {\n\t\t\t\tds->stl = GF_TRUE;\n\t\t\t\tds->mpd_timescale = p->value.uint;\n\t\t\t} else if (ctx->stl) {\n\t\t\t\tds->mpd_timescale = ds->timescale;\n\t\t\t}\n\t\t}\n\t}\n\treturn e;\n}\n\nstatic void dasher_get_dash_dur(GF_DasherCtx *ctx, GF_DashStream *ds)\n{\n\tds->dash_dur = ctx->segdur;\n\tconst GF_PropertyValue *p = gf_filter_pid_get_property(ds->ipid, GF_PROP_PID_DASH_DUR);\n\tif (p) {\n\t\tds->dash_dur = p->value.frac;\n\t\tds->no_seg_dur = GF_FALSE;\n\t\tif (!ds->dash_dur.num || !ds->dash_dur.den) {\n\t\t\tds->dash_dur.num = 1;\n\t\t\tds->dash_dur.den = 1;\n\t\t}\n\t}\n\t//this avoids very weird cases where (u64) (dash_dur*timescale) is 0. we limit the max segment duration to 1M sec, a bit more than 11.5 days\n\tif ((u64) ds->dash_dur.num > (u64)ds->dash_dur.den * 1000000) {\n\t\tds->dash_dur.num = 1000000;\n\t\tds->dash_dur.den = 1;\n\t}\n}\n\nstatic void dasher_send_encode_hints(GF_DasherCtx *ctx, GF_DashStream *ds)\n{\n\tif (!ctx->sfile && !ds->stl && !ctx->use_cues) {\n\t\tGF_FilterEvent evt;\n\t\tGF_FEVT_INIT(evt, GF_FEVT_ENCODE_HINTS, ds->ipid)\n\t\tif (!ds->dash_dur.num)\n\t\t\tdasher_get_dash_dur(ctx, ds);\n\n\t\tswitch (ctx->from_index) {\n\t\tcase IDXMODE_NONE:\n\t\t\tevt.encode_hints.intra_period = ds->dash_dur;\n\t\t\tbreak;\n\t\tcase IDXMODE_SEG:\n\t\tcase IDXMODE_CHILD:\n\t\t\tbreak;\n\t\tcase IDXMODE_ALL:\n\t\tcase IDXMODE_INIT:\n\t\tcase IDXMODE_MANIFEST:\n\t\t\tevt.encode_hints.gen_dsi_only = GF_TRUE;\n\t\t\tbreak;\n\t\t}\n\n\t\tgf_filter_pid_send_event(ds->ipid, &evt);\n\t}\n}\n\nstatic Bool dasher_template_use_source_url(const char *template)\n{\n\tif (!template) return GF_FALSE;\n\tif (strstr(template, \"$File$\") != NULL) return GF_TRUE;\n\telse if (strstr(template, \"$FSRC$\") != NULL) return GF_TRUE;\n\telse if (strstr(template, \"$SourcePath$\") != NULL) return GF_TRUE;\n\telse if (strstr(template, \"$FURL$\") != NULL) return GF_TRUE;\n\telse if (strstr(template, \"$URL$\") != NULL) return GF_TRUE;\n\treturn GF_FALSE;\n}\n\nstatic GF_Err dasher_configure_pid(GF_Filter *filter, GF_FilterPid *pid, Bool is_remove)\n{\n\tBool period_switch = GF_FALSE;\n\tconst GF_PropertyValue *p, *dsi=NULL;\n\tu32 dc_crc, dc_enh_crc;\n\tGF_Err e;\n\tGF_DashStream *ds;\n\tBool old_period_switch;\n\tu32 prev_stream_type;\n\tBool new_period_request = GF_FALSE;\n\tconst char *cue_file=NULL;\n\ts64 old_clamp_dur = 0;\n\tGF_DasherCtx *ctx = gf_filter_get_udta(filter);\n\n\tif (is_remove) {\n\t\tds = gf_filter_pid_get_udta(pid);\n\t\tif (ds) {\n\t\t\tif (ds->dyn_bitrate) dasher_update_bitrate(ctx, ds);\n\t\t\tgf_list_del_item(ctx->pids, ds);\n\t\t\tgf_list_del_item(ctx->current_period->streams, ds);\n\t\t\tif (ctx->next_period)\n\t\t\t\tgf_list_del_item(ctx->next_period->streams, ds);\n\t\t\tdasher_reset_stream(filter, ds, GF_TRUE);\n\t\t\tgf_free(ds);\n\t\t}\n\t\treturn GF_OK;\n\t}\n\tctx->check_connections = GF_TRUE;\n\tif (!ctx->opid && !ctx->gencues) {\n\t\tu32 i, nb_opids = ctx->dual ? 2 : 1;\n\t\tfor (i=0; i < nb_opids; i++) {\n\t\t\tchar *segext=NULL;\n\t\t\tchar *force_ext=NULL;\n\t\t\tGF_FilterPid *opid;\n\t\t\tif (i==0) {\n\t\t\t\tctx->opid = gf_filter_pid_new(filter);\n\t\t\t\tgf_filter_pid_set_name(ctx->opid, \"MANIFEST\");\n\t\t\t\topid = ctx->opid;\n\t\t\t} else {\n\t\t\t\tif (!ctx->alt_dst && ctx->out_path) {\n\t\t\t\t\tchar szSRC[100];\n\t\t\t\t\tGF_FileIO *gfio = NULL;\n\t\t\t\t\tchar *mpath = ctx->out_path;\n\t\t\t\t\tu32 len;\n\t\t\t\t\tif (!strncmp(mpath, \"gfio://\", 7)) {\n\t\t\t\t\t\tgfio = gf_fileio_from_url(mpath);\n\t\t\t\t\t\tif (!gfio) return GF_BAD_PARAM;\n\t\t\t\t\t\t//only use basename as we will create the new resource through factory\n\t\t\t\t\t\tmpath = (char *) gf_file_basename(gf_fileio_resource_url(gfio));\n\t\t\t\t\t\tif (!mpath) return GF_OUT_OF_MEM;\n\t\t\t\t\t}\n\n\t\t\t\t\tlen = (u32) strlen(mpath);\n\t\t\t\t\tchar *out_path = gf_malloc(len+10);\n\t\t\t\t\tif (!out_path) return GF_OUT_OF_MEM;\n\t\t\t\t\tmemcpy(out_path, mpath, len);\n\t\t\t\t\tout_path[len]=0;\n\t\t\t\t\tchar *sep = gf_file_ext_start(out_path);\n\t\t\t\t\tif (sep) sep[0] = 0;\n\t\t\t\t\tif (ctx->do_m3u8) {\n\t\t\t\t\t\tstrcat(out_path, \".mpd\");\n\t\t\t\t\t\tforce_ext = \"mpd\";\n\t\t\t\t\t} else {\n\t\t\t\t\t\tctx->opid_alt_m3u8 = GF_TRUE;\n\t\t\t\t\t\tctx->do_m3u8 = GF_TRUE;\n\t\t\t\t\t\tstrcat(out_path, \".m3u8\");\n\t\t\t\t\t\tforce_ext = \"m3u8\";\n\t\t\t\t\t}\n\t\t\t\t\tif (gfio) {\n\t\t\t\t\t\tconst char *rel = gf_fileio_factory(gfio, out_path);\n\t\t\t\t\t\tgf_free(out_path);\n\t\t\t\t\t\tout_path = gf_strdup(rel);\n\t\t\t\t\t\tif (!out_path) return GF_OUT_OF_MEM;\n\t\t\t\t\t}\n\n\t\t\t\t\tctx->alt_dst = gf_filter_connect_destination(filter, out_path, &e);\n\t\t\t\t\tif (e) {\n\t\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_DASH, (\"[Dasher] Couldn't create secondary manifest output %s: %s\\n\", out_path, gf_error_to_string(e) ));\n\t\t\t\t\t\tgf_free(out_path);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tgf_free(out_path);\n\n\t\t\t\t\t//reset any sourceID given in the dst_arg and assign sourceID to be the dasher filter\n\t\t\t\t\tgf_filter_reset_source(ctx->alt_dst);\n\t\t\t\t\tsnprintf(szSRC, 100, \"MuxSrc%cdasher_%p\", gf_filter_get_sep(filter, GF_FS_SEP_NAME), ctx->alt_dst);\n\t\t\t\t\tgf_filter_set_source(ctx->alt_dst, filter, szSRC);\n\n\t\t\t\t\tctx->opid_alt = gf_filter_pid_new(filter);\n\t\t\t\t\tgf_filter_pid_set_name(ctx->opid_alt, \"MANIFEST_ALT\");\n\n\t\t\t\t\tsnprintf(szSRC, 100, \"dasher_%p\", ctx->alt_dst);\n\t\t\t\t\tgf_filter_pid_set_property(ctx->opid_alt, GF_PROP_PID_MUX_SRC, &PROP_STRING(szSRC) );\n\t\t\t\t\t//we also need to set the property on main output just to avoid the connection\n\t\t\t\t\tsnprintf(szSRC, 100, \"dasher_%p\", ctx);\n\t\t\t\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_MUX_SRC, &PROP_STRING(szSRC) );\n\t\t\t\t}\n\t\t\t\topid = ctx->opid_alt;\n\t\t\t}\n\t\t\tif (!opid)\n\t\t\t\tcontinue;\n\n\t\t\t//copy properties at init or reconfig\n\t\t\tgf_filter_pid_copy_properties(opid, pid);\n\t\t\tgf_filter_pid_set_property(opid, GF_PROP_PID_DECODER_CONFIG, NULL);\n\t\t\tgf_filter_pid_set_property(opid, GF_PROP_PID_DECODER_CONFIG_ENHANCEMENT, NULL);\n\t\t\tgf_filter_pid_set_property(opid, GF_PROP_PID_CODECID, NULL);\n\t\t\tgf_filter_pid_set_property(opid, GF_PROP_PID_UNFRAMED, NULL);\n\t\t\tgf_filter_pid_set_property(opid, GF_PROP_PID_STREAM_TYPE, &PROP_UINT(GF_STREAM_FILE) );\n\t\t\t//for routeout\n\t\t\tgf_filter_pid_set_property(opid, GF_PROP_PID_PREMUX_STREAM_TYPE, &PROP_UINT(GF_STREAM_FILE) );\n\n\t\t\tdasher_check_outpath(ctx);\n\n\t\t\tp = gf_filter_pid_caps_query(pid, GF_PROP_PID_FILE_EXT);\n\t\t\tif (p) {\n\t\t\t\tgf_filter_pid_set_property(opid, GF_PROP_PID_FILE_EXT, p );\n\t\t\t\tsegext = p->value.string;\n\t\t\t} else {\n\t\t\t\tsegext = NULL;\n\t\t\t\tif (ctx->out_path) {\n\t\t\t\t\tsegext = gf_file_ext_start(ctx->out_path);\n\t\t\t\t} else if (ctx->mname) {\n\t\t\t\t\tsegext = gf_file_ext_start(ctx->mname);\n\t\t\t\t}\n\t\t\t\tif (!segext) segext = \"mpd\";\n\t\t\t\telse segext++;\n\t\t\t\tif (force_ext)\n\t\t\t\t\tsegext = force_ext;\n\t\t\t\tgf_filter_pid_set_property(opid, GF_PROP_PID_FILE_EXT, &PROP_STRING(segext) );\n\n\t\t\t\tif (!strcmp(segext, \"m3u8\")) {\n\t\t\t\t\tgf_filter_pid_set_property(opid, GF_PROP_PID_MIME, &PROP_STRING(\"video/mpegurl\"));\n\t\t\t\t} else if (!strcmp(segext, \"ghi\")) {\n\t\t\t\t\tgf_filter_pid_set_property(opid, GF_PROP_PID_MIME, &PROP_STRING(\"application/x-gpac-ghi\"));\n\t\t\t\t} else if (!strcmp(segext, \"ghix\")) {\n\t\t\t\t\tgf_filter_pid_set_property(opid, GF_PROP_PID_MIME, &PROP_STRING(\"application/x-gpac-ghix\"));\n\t\t\t\t} else {\n\t\t\t\t\tgf_filter_pid_set_property(opid, GF_PROP_PID_MIME, &PROP_STRING(\"application/dash+xml\"));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tu32 manifest_type = 0;\n\t\t\tif (!strcmp(segext, \"m3u8\")) {\n\t\t\t\tctx->do_m3u8 = GF_TRUE;\n\t\t\t\tgf_filter_pid_set_name(opid, \"manifest_m3u8\" );\n\t\t\t\tmanifest_type = 2;\n\t\t\t} else if (!strcmp(segext, \"ghix\") || !strcmp(segext, \"ghi\")) {\n\t\t\t\tctx->do_index = !strcmp(segext, \"ghix\") ? 2 : 1;\n\t\t\t\tctx->sigfrag = GF_FALSE;\n\t\t\t\tctx->align = ctx->sap = GF_TRUE;\n\t\t\t\tctx->sseg = ctx->sfile = ctx->tpl = GF_FALSE;\n\t\t\t\tif (ctx->state) {\n\t\t\t\t\tgf_free(ctx->state);\n\t\t\t\t\tctx->state = NULL;\n\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_DASH, (\"[Dasher] Index generation mode, disabling state\\n\" ));\n\t\t\t\t}\n\t\t\t\tif (!ctx->template)\n\t\t\t\t\tctx->template = gf_strdup(\"$RepresentationID$-$Number$$Init=init$\");\n\n\t\t\t\tgf_filter_pid_set_name(opid, \"dash_index\" );\n\t\t\t\tmanifest_type = 3;\n\t\t\t} else {\n\t\t\t\tctx->do_mpd = GF_TRUE;\n\t\t\t\tgf_filter_pid_set_name(opid, \"manifest_mpd\" );\n\t\t\t\tmanifest_type = 1;\n\t\t\t}\n\t\t\tgf_filter_pid_set_property(opid, GF_PROP_PID_IS_MANIFEST, &PROP_UINT(manifest_type));\n\t\t}\n\n\t\tctx->store_seg_states = GF_FALSE;\n\t\t//in m3u8 mode, always store all seg states. In MPD only if state, not ondemand\n\t\tif (((ctx->state || ctx->purge_segments) && !ctx->sseg) || ctx->do_m3u8) ctx->store_seg_states = GF_TRUE;\n\t}\n\n\tds = gf_filter_pid_get_udta(pid);\n\tif (!ds) {\n\t\tGF_SAFEALLOC(ds, GF_DashStream);\n\t\tif (!ds) return GF_OUT_OF_MEM;\n\t\tds->ipid = pid;\n\t\tgf_list_add(ctx->pids, ds);\n\t\tds->complementary_streams = gf_list_new();\n\t\tperiod_switch = GF_TRUE;\n\t\tgf_filter_pid_set_udta(pid, ds);\n\t\tds->sbound = ctx->sbound;\n\t\tds->startNumber = 1;\n\t\tif (ctx->sbound!=DASHER_BOUNDS_OUT)\n\t\t\tds->packet_queue = gf_list_new();\n\n\t\t/*initial connection and we already have sent play event, send a PLAY on this new PID\n\t\tTODO: we need to send STOP/PLAY depending on period\n\t\t*/\n\t\tif (ctx->is_playing) {\n\t\t\tGF_FilterEvent evt;\n\n\t\t\tdasher_send_encode_hints(ctx, ds);\n\n\t\t\tGF_FEVT_INIT(evt, GF_FEVT_PLAY, ds->ipid);\n\t\t\tevt.play.speed = 1.0;\n\t\t\tgf_filter_pid_send_event(ds->ipid, &evt);\n\t\t}\n\t\t//don't create pid at this time except in gencues mode\n\n\t\tif (ctx->gencues) {\n\t\t\tds->opid = gf_filter_pid_new(filter);\n\t\t\tgf_filter_pid_copy_properties(ds->opid, pid);\n\t\t\tgf_filter_pid_set_property(ds->opid, GF_PROP_PID_DASH_CUE, &PROP_STRING(\"inband\") );\n\t\t}\n\t}\n\n\tgf_filter_pid_set_framing_mode(pid, GF_TRUE);\n\n#define CHECK_PROP(_type, _mem, _e) \\\n\tp = gf_filter_pid_get_property(pid, _type); \\\n\tif (!p && (_e<=0) ) return _e; \\\n\tif (p && (p->value.uint != _mem) && _mem) period_switch = GF_TRUE; \\\n\tif (p) _mem = p->value.uint; \\\n\n#define CHECK_PROPL(_type, _mem, _e) \\\n\tp = gf_filter_pid_get_property(pid, _type); \\\n\tif (!p && (_e<=0) ) return _e; \\\n\tif (p && (p->value.longuint != _mem) && _mem) period_switch = GF_TRUE; \\\n\tif (p) _mem = p->value.longuint; \\\n\n#define CHECK_PROP_BOOL(_type, _mem, _e) \\\n\tp = gf_filter_pid_get_property(pid, _type); \\\n\tif (!p && (_e<=0) ) return _e; \\\n\tif (p && (p->value.boolean != _mem) && _mem) period_switch = GF_TRUE; \\\n\tif (p) _mem = p->value.uint; \\\n\n#define CHECK_PROP_FRAC(_type, _mem, _e) \\\n\tp = gf_filter_pid_get_property(pid, _type); \\\n\tif (!p && (_e<=0) ) return _e; \\\n\tif (p && (p->value.frac.num * _mem.den != p->value.frac.den * _mem.num) && _mem.den && _mem.num) period_switch = GF_TRUE; \\\n\tif (p) _mem = p->value.frac; \\\n\n#define CHECK_PROP_FRAC64(_type, _mem, _e) \\\n\tp = gf_filter_pid_get_property(pid, _type); \\\n\tif (!p && (_e<=0) ) return _e; \\\n\tif (p && (p->value.lfrac.num * _mem.den != p->value.lfrac.den * _mem.num) && _mem.den && _mem.num) period_switch = GF_TRUE; \\\n\tif (p) _mem = p->value.lfrac; \\\n\n\n#define CHECK_PROP_STR(_type, _mem, _e) \\\n\tp = gf_filter_pid_get_property(pid, _type); \\\n\tif (!p && (_e<=0) ) return _e; \\\n\tif (p && p->value.string && _mem && strcmp(_mem, p->value.string)) period_switch = GF_TRUE; \\\n\tif (p) { \\\n\t\tif (_mem) gf_free(_mem); \\\n\t\t_mem = gf_strdup(p->value.string); \\\n\t}\\\n\n\n#define CHECK_PROP_PROP(_type, _mem, _e) \\\n\tp = gf_filter_pid_get_property(pid, _type); \\\n\tif (!p && (_e<=0) ) return _e; \\\n\tif (p != _mem) period_switch = GF_TRUE;\\\n\t_mem = p; \\\n\n\n\tprev_stream_type = ds->stream_type;\n\tCHECK_PROP(GF_PROP_PID_STREAM_TYPE, ds->stream_type, GF_NOT_SUPPORTED)\n\n\tif (ctx->sigfrag) {\n\t\tp = gf_filter_pid_get_property_str(pid, \"nofrag\");\n\t\tif (p && p->value.boolean) {\n\t\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_URL);\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[IsoMedia] sigfrag requested but file %s is not fragmented\\n\", p->value.string));\n\t\t\treturn GF_BAD_PARAM;\n\t\t}\n\t}\n\n\tds->tile_base = GF_FALSE;\n\n\tif (ds->stream_type != GF_STREAM_FILE) {\n\t\tu32 prev_bitrate = ds->bitrate;\n\t\tif (ds->stream_type==GF_STREAM_ENCRYPTED) {\n\t\t\tCHECK_PROP(GF_PROP_PID_ORIG_STREAM_TYPE, ds->stream_type, GF_EOS)\n\t\t\tds->is_encrypted = GF_TRUE;\n\t\t}\n\t\tif (prev_stream_type==ds->stream_type)\n\t\t\tperiod_switch = GF_FALSE;\n\n\t\tCHECK_PROP(GF_PROP_PID_BITRATE, ds->bitrate, GF_EOS)\n\t\tif (!ds->bitrate && prev_bitrate) {\n\t\t\tds->bitrate = prev_bitrate;\n\t\t\tperiod_switch = GF_FALSE;\n\t\t}\n\t\tif (ds->bitrate && period_switch) {\n\t\t\t//allow 20% variation in bitrate, otherwise force period switch\n\t\t\tif ((ds->bitrate <= 120 * prev_bitrate / 100) && (ds->bitrate >= 80 * prev_bitrate / 100)) {\n\t\t\t\tperiod_switch = GF_FALSE;\n\t\t\t}\n\t\t}\n\n\t\tCHECK_PROP(GF_PROP_PID_CODECID, ds->codec_id, GF_NOT_SUPPORTED)\n\t\tCHECK_PROP(GF_PROP_PID_TIMESCALE, ds->timescale, GF_NOT_SUPPORTED)\n\n\t\tif (ds->stream_type==GF_STREAM_VISUAL) {\n\t\t\tCHECK_PROP(GF_PROP_PID_WIDTH, ds->width, GF_EOS)\n\t\t\tCHECK_PROP(GF_PROP_PID_HEIGHT, ds->height, GF_EOS)\n\t\t\t//don't return if not defined\n\t\t\tCHECK_PROP_FRAC(GF_PROP_PID_SAR, ds->sar, GF_EOS)\n\t\t\tif (!ds->sar.num) ds->sar.num = ds->sar.den = 1;\n\t\t\tCHECK_PROP_FRAC(GF_PROP_PID_FPS, ds->fps, GF_EOS)\n\n\n\t\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_TILE_BASE);\n\t\t\tif (p) {\n\t\t\t\tds->srd.x = ds->srd.y = 0;\n\t\t\t\tds->srd.z = ds->width;\n\t\t\t\tds->srd.w = ds->height;\n\t\t\t\tds->tile_base = GF_TRUE;\n\t\t\t} else {\n\t\t\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_CROP_POS);\n\t\t\t\tif (p && ((p->value.vec2i.x != ds->srd.x) || (p->value.vec2i.y != ds->srd.y) ) ) period_switch = GF_TRUE;\n\t\t\t\tif (p) {\n\t\t\t\t\tds->srd.x = p->value.vec2i.x;\n\t\t\t\t\tds->srd.y = p->value.vec2i.y;\n\t\t\t\t\tds->srd.z = ds->width;\n\t\t\t\t\tds->srd.w = ds->height;\n\t\t\t\t} else {\n\t\t\t\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_SRD);\n\t\t\t\t\tif (p && (\n\t\t\t\t\t\t(p->value.vec4i.x != ds->srd.x)\n\t\t\t\t\t\t|| (p->value.vec4i.y != ds->srd.y)\n\t\t\t\t\t\t|| (p->value.vec4i.z != ds->srd.z)\n\t\t\t\t\t\t|| (p->value.vec4i.w != ds->srd.w)\n\t\t\t\t\t) )\n\t\t\t\t\t\tperiod_switch = GF_TRUE;\n\n\t\t\t\t\tif (p) {\n\t\t\t\t\t\tds->srd.x = p->value.vec4i.x;\n\t\t\t\t\t\tds->srd.y = p->value.vec4i.y;\n\t\t\t\t\t\tds->srd.z = p->value.vec4i.z;\n\t\t\t\t\t\tds->srd.w = p->value.vec4i.w;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (ds->stream_type==GF_STREAM_AUDIO) {\n\t\t\tCHECK_PROP(GF_PROP_PID_SAMPLE_RATE, ds->sr, GF_EOS)\n\t\t\tCHECK_PROP(GF_PROP_PID_NUM_CHANNELS, ds->nb_ch, GF_EOS)\n\t\t\tCHECK_PROPL(GF_PROP_PID_CHANNEL_LAYOUT, ds->ch_layout, GF_EOS)\n\t\t}\n\n\t\told_period_switch = period_switch;\n\n\t\t//these ones can change without triggering period switch\n\t\tCHECK_PROP(GF_PROP_PID_NB_FRAMES, ds->nb_samples_in_source, GF_EOS)\n\t\tCHECK_PROP_FRAC64(GF_PROP_PID_DURATION, ds->duration, GF_EOS)\n\t\tCHECK_PROP_STR(GF_PROP_PID_URL, ds->src_url, GF_EOS)\n\t\tperiod_switch = old_period_switch;\n\t\tif (ds->duration.num<0) ds->duration.num = 0;\n\n\t\tCHECK_PROP(GF_PROP_PID_ID, ds->id, GF_EOS)\n\t\tCHECK_PROP(GF_PROP_PID_DEPENDENCY_ID, ds->dep_id, GF_EOS)\n\n\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_HAS_SYNC);\n\t\tu32 sync_type = DASHER_SYNC_UNKNOWN;\n\t\tif (p) sync_type = p->value.boolean ? DASHER_SYNC_PRESENT : DASHER_SYNC_NONE;\n\t\tif ((sync_type != DASHER_SYNC_UNKNOWN) && (sync_type != ds->sync_points_type)) {\n\t\t\tperiod_switch = GF_TRUE;\n\t\t\tds->sync_points_type = sync_type;\n\t\t}\n\t\t\n\t\tif (ds->inband_cues)\n\t\t\tperiod_switch = old_period_switch;\n\n\t\tif (ctx->scope_deps) {\n\t\t\tconst char *src_args = gf_filter_pid_orig_src_args(pid, GF_TRUE);\n\t\t\tif (src_args) {\n\t\t\t\tds->src_id = gf_crc_32(src_args, (u32) strlen(src_args));\n\t\t\t}\n\t\t}\n\n\t\t//check if we had up-front declarations of codec configs\n\t\tif (ctx->pswitch==DASHER_PSWITCH_STSD) {\n\t\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_ISOM_STSD_ALL_TEMPLATES);\n\t\t\tif (p) {\n\t\t\t\tu32 all_stsd_crc = gf_crc_32(p->value.data.ptr, p->value.data.size);\n\t\t\t\t//same config, we assume the muxer dealt with this at setup, reset dsi crc to skip period switch test below\n\t\t\t\tif (all_stsd_crc==ds->all_stsd_crc) {\n\t\t\t\t\tds->dsi_crc = 0;\n\t\t\t\t\tds->dsi_enh_crc = 0;\n\t\t\t\t} else {\n\t\t\t\t\tds->all_stsd_crc = all_stsd_crc;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tds->all_stsd_crc = 0;\n\t\t\t}\n\t\t}\n\n\t\tdc_crc = 0;\n\t\tdsi = p = gf_filter_pid_get_property(pid, GF_PROP_PID_DECODER_CONFIG);\n\t\tif (p && (p->type==GF_PROP_DATA))\n\t\t\tdc_crc = gf_crc_32(p->value.data.ptr, p->value.data.size);\n\n\t\tdc_enh_crc = 0;\n\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_DECODER_CONFIG_ENHANCEMENT);\n\t\tif (p && (p->type==GF_PROP_DATA)) dc_enh_crc = gf_crc_32(p->value.data.ptr, p->value.data.size);\n\n\t\tif (((dc_crc != ds->dsi_crc) && ds->dsi_crc)\n\t\t\t|| ((dc_enh_crc != ds->dsi_enh_crc) && ds->dsi_enh_crc)\n\t\t) {\n\t\t\t//check which codecs can support inband param sets\n\t\t\tswitch (ds->codec_id) {\n\t\t\tcase GF_CODECID_AVC:\n\t\t\tcase GF_CODECID_SVC:\n\t\t\tcase GF_CODECID_MVC:\n\t\t\tcase GF_CODECID_HEVC:\n\t\t\tcase GF_CODECID_LHVC:\n\t\t\t\tif (!ctx->bs_switch)\n\t\t\t\t\tperiod_switch = GF_TRUE;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tperiod_switch = GF_TRUE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t//check if input is ready\n\t\tds->dcd_not_ready = 0;\n\t\tif (!dc_crc && !dc_enh_crc) {\n\t\t\tswitch (ds->codec_id) {\n\t\t\tcase GF_CODECID_AVC:\n\t\t\tcase GF_CODECID_SVC:\n\t\t\tcase GF_CODECID_MVC:\n\t\t\tcase GF_CODECID_HEVC:\n\t\t\tcase GF_CODECID_LHVC:\n\t\t\tcase GF_CODECID_AAC_MPEG4:\n\t\t\tcase GF_CODECID_AAC_MPEG2_MP:\n\t\t\tcase GF_CODECID_AAC_MPEG2_LCP:\n\t\t\tcase GF_CODECID_AAC_MPEG2_SSRP:\n\t\t\tcase GF_CODECID_USAC:\n\t\t\tcase GF_CODECID_AC3:\n\t\t\tcase GF_CODECID_EAC3:\n\t\t\tcase GF_CODECID_AV1:\n\t\t\tcase GF_CODECID_VP8:\n\t\t\tcase GF_CODECID_VP9:\n\t\t\t\tds->dcd_not_ready = gf_sys_clock();\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tds->dsi_crc = dc_crc;\n\n\t\tCHECK_PROP_STR(GF_PROP_PID_TEMPLATE, ds->template, GF_EOS)\n\t\tCHECK_PROP_STR(GF_PROP_PID_LANGUAGE, ds->lang, GF_EOS)\n\t\tCHECK_PROP_BOOL(GF_PROP_PID_INTERLACED, ds->interlaced, GF_EOS)\n\t\tCHECK_PROP_PROP(GF_PROP_PID_AS_COND_DESC, ds->p_as_desc, GF_EOS)\n\t\tCHECK_PROP_PROP(GF_PROP_PID_AS_ANY_DESC, ds->p_as_any_desc, GF_EOS)\n\t\tCHECK_PROP_PROP(GF_PROP_PID_REP_DESC, ds->p_rep_desc, GF_EOS)\n\t\tCHECK_PROP_PROP(GF_PROP_PID_BASE_URL, ds->p_base_url, GF_EOS)\n\t\tCHECK_PROP_PROP(GF_PROP_PID_ROLE, ds->p_role, GF_EOS)\n\t\tCHECK_PROP_STR(GF_PROP_PID_HLS_PLAYLIST, ds->hls_vp_name, GF_EOS)\n\t\tCHECK_PROP_BOOL(GF_PROP_PID_SINGLE_SCALE, ds->sscale, GF_EOS)\n\n\t\t//if manifest generation mode with template and no template at PID or filter level, switch to main profile\n\t\tif (ctx->sigfrag && ctx->tpl && !ctx->template && !ds->template) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_DASH, (\"[Dasher] Warning, manifest generation only mode requested for live-based profile but no template provided, switching to main profile.\\n\"));\n\t\t\tctx->profile = GF_DASH_PROFILE_MAIN;\n\t\t\tctx->tpl = GF_FALSE;\n\t\t\tdasher_setup_profile(ctx);\n\t\t\t//we force single file in this mode, but we will replace byte ranges by source URL\n\t\t\tctx->sfile = GF_TRUE;\n\t\t}\n\n\t\tif (ds->rate_first_dts_plus_one)\n\t\t\tdasher_update_bitrate(ctx, ds);\n\n\t\tif (!ds->bitrate) {\n\t\t\tchar *tpl = ds->template ? ds->template : ctx->template;\n\t\t\tif (tpl && strstr(tpl, \"$Bandwidth$\")) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_DASH, (\"[Dasher] No bitrate property assigned to PID %s but template uses $Bandwidth$, cannot initialize !\\n\\tTry specifying bitrate property after your source, e.g. -i source.raw:#Bitrate=VAL\\n\", gf_filter_pid_get_name(ds->ipid)));\n\t\t\t\tctx->in_error = GF_TRUE;\n\t\t\t\treturn GF_BAD_PARAM;\n\t\t\t} else {\n\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_DASH, (\"[Dasher] No bitrate property assigned to PID %s, computing from bitstream\\n\", gf_filter_pid_get_name(ds->ipid)));\n\t\t\t\tds->dyn_bitrate = GF_TRUE;\n\t\t\t\tds->rate_first_dts_plus_one = 0;\n\t\t\t\tds->rate_media_size = 0;\n\t\t\t}\n\t\t} else {\n\t\t\tds->dyn_bitrate = GF_FALSE;\n\t\t}\n\n\t\tif (!ds->src_url)\n\t\t\tds->src_url = gf_strdup(\"file\");\n\n\t\tCHECK_PROP(GF_PROP_PID_START_NUMBER, ds->startNumber, GF_EOS)\n\n\t\tds->no_seg_dur = ctx->no_seg_dur;\n\t\tdasher_get_dash_dur(ctx, ds);\n\n\t\tds->splitable = GF_FALSE;\n\t\tds->is_av = GF_FALSE;\n\t\tswitch (ds->stream_type) {\n\t\tcase GF_STREAM_TEXT:\n\t\tcase GF_STREAM_METADATA:\n\t\tcase GF_STREAM_OD:\n\t\tcase GF_STREAM_SCENE:\n\t\t\tds->splitable = ctx->split;\n\t\t\tbreak;\n\t\tcase GF_STREAM_VISUAL:\n\t\tcase GF_STREAM_AUDIO:\n\t\t\tds->is_av = GF_TRUE;\n\t\t\tbreak;\n\t\t}\n\n\t\told_clamp_dur = ds->clamped_dur.num;\n\t\tds->clamped_dur.num = 0;\n\t\tds->clamped_dur.den = 1;\n\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_CLAMP_DUR);\n\t\tif (p && p->value.lfrac.den) ds->clamped_dur = p->value.lfrac;\n\n\t\t//HDR\n#if !defined(GPAC_DISABLE_AV_PARSERS)\n\t\tif (dsi) {\n\t\t\tif (ds->codec_id == GF_CODECID_LHVC || ds->codec_id == GF_CODECID_HEVC_TILES || ds->codec_id == GF_CODECID_HEVC) {\n\t\t\t\tGF_HEVCConfig* hevccfg = gf_odf_hevc_cfg_read(dsi->value.data.ptr, dsi->value.data.size, GF_FALSE);\n\t\t\t\tif (hevccfg) {\n\t\t\t\t\tBool is_interlaced;\n\t\t\t\t\tHEVCState hevc;\n\t\t\t\t\tHEVC_SPS* sps;\n\t\t\t\t\tmemset(&hevc, 0, sizeof(HEVCState));\n\t\t\t\t\tgf_hevc_parse_ps(hevccfg, &hevc, GF_HEVC_NALU_VID_PARAM);\n\t\t\t\t\tgf_hevc_parse_ps(hevccfg, &hevc, GF_HEVC_NALU_SEQ_PARAM);\n\t\t\t\t\tsps = &hevc.sps[hevc.sps_active_idx];\n\t\t\t\t\tif (sps && sps->colour_description_present_flag) {\n\t\t\t\t\t\tDasherHDRType old_hdr_type = ds->hdr_type;\n\t\t\t\t\t\tif (sps->colour_primaries == 9 && sps->matrix_coeffs == 9) {\n\t\t\t\t\t\t\tif (sps->transfer_characteristic == 14) ds->hdr_type = DASHER_HDR_HLG; //TODO: parse alternative_transfer_characteristics SEI\n\t\t\t\t\t\t\tif (sps->transfer_characteristic == 16) ds->hdr_type = DASHER_HDR_PQ10;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (old_hdr_type != ds->hdr_type) period_switch = GF_TRUE;\n\t\t\t\t\t}\n\t\t\t\t\tis_interlaced = hevccfg->interlaced_source_flag ? GF_TRUE : GF_FALSE;\n\t\t\t\t\tif (ds->interlaced != is_interlaced) period_switch = GF_TRUE;\n\t\t\t\t\tds->interlaced = is_interlaced;\n\n\t\t\t\t\tgf_odf_hevc_cfg_del(hevccfg);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (ds->codec_id == GF_CODECID_AVC || ds->codec_id == GF_CODECID_SVC || ds->codec_id == GF_CODECID_MVC) {\n\t\t\t\tAVCState avc;\n\t\t\t\tGF_AVCConfig* avccfg = gf_odf_avc_cfg_read(dsi->value.data.ptr, dsi->value.data.size);\n\t\t\t\tif (avccfg) {\n\t\t\t\t\tGF_NALUFFParam *sl = (GF_NALUFFParam *)gf_list_get(avccfg->sequenceParameterSets, 0);\n\t\t\t\t\tif (sl) {\n\t\t\t\t\t\ts32 idx;\n\t\t\t\t\t\tmemset(&avc, 0, sizeof(AVCState));\n\t\t\t\t\t\tidx = gf_avc_read_sps(sl->data, sl->size, &avc, 0, NULL);\n\t\t\t\t\t\tif (idx>=0) {\n\t\t\t\t\t\t\tBool is_interlaced = avc.sps[idx].frame_mbs_only_flag ? GF_FALSE : GF_TRUE;\n\t\t\t\t\t\t\tif (ds->interlaced != is_interlaced) period_switch = GF_TRUE;\n\t\t\t\t\t\t\tds->interlaced = is_interlaced;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tgf_odf_avc_cfg_del(avccfg);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n#endif /*!GPAC_DISABLE_AV_PARSERS*/\n\n\t\tif (ds->stream_type==GF_STREAM_AUDIO) {\n\t\t\tu32 _sr=0, _nb_ch=0;\n#ifndef GPAC_DISABLE_AV_PARSERS\n\t\t\tswitch (ds->codec_id) {\n\t\t\tcase GF_CODECID_AAC_MPEG4:\n\t\t\tcase GF_CODECID_AAC_MPEG2_MP:\n\t\t\tcase GF_CODECID_AAC_MPEG2_LCP:\n\t\t\tcase GF_CODECID_AAC_MPEG2_SSRP:\n\t\t\tcase GF_CODECID_USAC:\n\t\t\t\t//DASH-IF and MPEG disagree here:\n\t\t\t\tif ((ctx->profile == GF_DASH_PROFILE_AVC264_LIVE)\n\t\t\t\t\t|| (ctx->profile == GF_DASH_PROFILE_AVC264_ONDEMAND)\n\t\t\t\t\t|| (ctx->profile == GF_DASH_PROFILE_DASHIF_LL)\n\t\t\t\t) {\n\t\t\t\t\tGF_Err res = dasher_get_audio_info_with_m4a_sbr_ps(ds, dsi, &_sr, &_nb_ch);\n\t\t\t\t\tif (res) {\n\t\t\t\t\t\t//DASH-IF IOP 3.3 mandates the SBR/PS info\n\t\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_DASH, (\"[Dasher] Could not get AAC info, %s\\n\", gf_error_to_string(res)));\n\t\t\t\t\t}\n\t\t\t\t} else if (dsi) {\n\t\t\t\t\tdasher_get_audio_info_with_m4a_sbr_ps(ds, dsi, NULL, &_nb_ch);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase GF_CODECID_AC3:\n\t\t\tcase GF_CODECID_EAC3:\n\t\t\t\tif (dsi) {\n\t\t\t\t\tGF_AC3Config ac3;\n\t\t\t\t\tgf_odf_ac3_config_parse(dsi->value.data.ptr, dsi->value.data.size, (ds->codec_id==GF_CODECID_EAC3) ? GF_TRUE : GF_FALSE, &ac3);\n\n\t\t\t\t\tds->nb_lfe = ac3.streams[0].lfon ? 1 : 0;\n\t\t\t\t\tds->nb_surround = gf_ac3_get_surround_channels(ac3.streams[0].acmod);\n\t\t\t\t\tds->atmos_complexity_type = ac3.is_ec3 ? ac3.complexity_index_type : 0;\n\t\t\t\t\t_nb_ch = gf_ac3_get_total_channels(ac3.streams[0].acmod);\n\t\t\t\t\tif (ac3.streams[0].nb_dep_sub) {\n\t\t\t\t\t\t_nb_ch += gf_eac3_get_chan_loc_count(ac3.streams[0].chan_loc);\n\t\t\t\t\t}\n                    if (ds->nb_lfe) _nb_ch++;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n#endif\n\t\t\tif (_sr > ds->sr) ds->sr = _sr;\n\t\t\tif (_nb_ch > ds->nb_ch) ds->nb_ch = _nb_ch;\n\t\t}\n\n\n\t\tds->pts_minus_cts = 0;\n\t\tp = gf_filter_pid_get_property(ds->ipid, GF_PROP_PID_DELAY);\n\t\tif (p && p->value.longsint) {\n\t\t\tds->pts_minus_cts = p->value.longsint;\n\t\t}\n\n\t\t//only reload queues if we detected a period switch\n\t\tif (period_switch) {\n\t\t\tcue_file = ctx->cues;\n\t\t\tif (!cue_file || strcmp(cue_file, \"none\") ) {\n\t\t\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_DASH_CUE);\n\t\t\t\tif (p) cue_file = p->value.string;\n\t\t\t}\n\n\t\t\tif (ds->cues) gf_free(ds->cues);\n\t\t\tds->cues = NULL;\n\t\t\tds->nb_cues = 0;\n\t\t\tds->inband_cues = GF_FALSE;\n\t\t\tif (cue_file) {\n\t\t\t\tif (!strcmp(cue_file, \"inband\")) {\n\t\t\t\t\tds->inband_cues = GF_TRUE;\n\t\t\t\t\t//if manifest generation mode, do not setup dash forward mode\n\t\t\t\t\tif (!ctx->sigfrag) {\n\t\t\t\t\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_DASH_FWD);\n\t\t\t\t\t\tif (p && p->value.uint)\n\t\t\t\t\t\t\tctx->forward_mode = p->value.uint;\n\t\t\t\t\t}\n\t\t\t\t} else if (!strcmp(cue_file, \"idx_all\")) {\n\t\t\t\t\tds->inband_cues = GF_TRUE;\n\t\t\t\t\tctx->from_index = IDXMODE_ALL;\n\t\t\t\t} else if (!strcmp(cue_file, \"idx_man\")) {\n\t\t\t\t\tds->inband_cues = GF_TRUE;\n\t\t\t\t\tctx->from_index = IDXMODE_MANIFEST;\n\t\t\t\t} else if (!strcmp(cue_file, \"idx_init\")) {\n\t\t\t\t\tds->inband_cues = GF_TRUE;\n\t\t\t\t\tctx->from_index = IDXMODE_INIT;\n\t\t\t\t} else if (!strcmp(cue_file, \"idx_child\")) {\n\t\t\t\t\tds->inband_cues = GF_TRUE;\n\t\t\t\t\tctx->from_index = IDXMODE_CHILD;\n\t\t\t\t} else if (!strcmp(cue_file, \"idx_seg\")) {\n\t\t\t\t\tds->inband_cues = GF_TRUE;\n\t\t\t\t\tctx->from_index = IDXMODE_SEG;\n\t\t\t\t} else if (strcmp(cue_file, \"none\")) {\n\t\t\t\t\te = gf_mpd_load_cues(cue_file, ds->id, &ds->cues_timescale, &ds->cues_use_edits, &ds->cues_ts_offset, &ds->cues, &ds->nb_cues);\n\t\t\t\t\tif (e) return e;\n\t\t\t\t\tif (!ds->cues_timescale)\n\t\t\t\t\t\tds->cues_timescale = ds->timescale;\n\t\t\t\t}\n\n\n\t\t\t\tif (ctx->from_index==IDXMODE_CHILD) {\n\t\t\t\t\tp = gf_filter_pid_get_property_str(ds->ipid, \"idx_out\");\n\t\t\t\t\tif (p) {\n\t\t\t\t\t\tif (ds->hls_vp_name) gf_free(ds->hls_vp_name);\n\t\t\t\t\t\tds->hls_vp_name = gf_strdup(p->value.string);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t} else {\n\n\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_URL);\n\t\tif (!p) p = gf_filter_pid_get_property(pid, GF_PROP_PID_FILEPATH);\n\t\tif (p) return GF_NOT_SUPPORTED;\n\n\t\tCHECK_PROP_STR(GF_PROP_PID_XLINK, ds->xlink, GF_EOS)\n\t}\n\n\n\tif (ctx->do_index || ctx->from_index) {\n\t\tif (!ds->template && ctx->def_template) {\n\t\t\tp = gf_filter_pid_get_property_str(ds->ipid, \"idx_template\");\n\t\t\tif (p) {\n\t\t\t\tds->template = gf_strdup(p->value.string);\n\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_DASH, (\"[Dasher] Using template from index pass %s\\n\", ds->template));\n\t\t\t}\n\t\t}\n\t\tchar *template = ds->template;\n\n\t\tif (!ds->template) {\n\t\t\tif ((ctx->def_template==1) && ctx->do_index) {\n\t\t\t\tgf_free(ctx->template);\n\t\t\t\tctx->template = gf_strdup(\"$RepresentationID$-$Number$$Init=init$\");\n\t\t\t\tctx->def_template = 2;\n\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_DASH, (\"[Dasher] No template assigned in index mode, using %s\\n\", ctx->template));\n\t\t\t}\n\t\t\ttemplate = ctx->template;\n\t\t}\n\n\t\tif (dasher_template_use_source_url(template)) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_DASH, (\"[Dasher] Cannot use file-based templates with index mode\\n\"));\n\t\t\treturn GF_BAD_PARAM;\n\t\t}\n\t}\n\n\t//stream representation was not yet setup but is scheduled for this period, do not trigger period switch\n\t//this typically happens when we post-poned representation setup waiting for the decoder config\n\tif (!ds->rep && (gf_list_find(ctx->current_period->streams, ds)>=0))\n\t\tperiod_switch = GF_FALSE;\n\n\told_period_switch = period_switch;\n\tperiod_switch = GF_FALSE;\n\tCHECK_PROP_STR(GF_PROP_PID_PERIOD_ID, ds->period_id, GF_EOS)\n\tCHECK_PROP_PROP(GF_PROP_PID_PERIOD_DESC, ds->p_period_desc, GF_EOS)\n\tif (!period_switch && (ctx->pswitch==DASHER_PSWITCH_FORCE))\n\t\tperiod_switch = GF_TRUE;\n\n\tif (gf_filter_pid_get_property_str(pid, \"period_switch\"))\n\t\tperiod_switch = GF_TRUE;\n\n\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_PERIOD_START);\n\tif (p) {\n\t\tif (ds->period_start.num * p->value.lfrac.den != p->value.lfrac.num * ds->period_start.den) period_switch = GF_TRUE;\n\t\tds->period_start = p->value.lfrac;\n\t} else {\n\t\tif (ds->period_start.num) period_switch = GF_TRUE;\n\t\tds->period_start.num = 0;\n\t\tds->period_start.den = 1000;\n\t}\n\tassert(ds->period_start.den);\n\n\tif (period_switch) {\n\t\tnew_period_request = GF_TRUE;\n\t} else {\n\t\tperiod_switch = old_period_switch;\n\t}\n\n\tif (ds->period_continuity_id) gf_free(ds->period_continuity_id);\n\tds->period_continuity_id = NULL;\n\tp = gf_filter_pid_get_property_str(ds->ipid, \"period_resume\");\n\tif (!ctx->mpd || (gf_list_find(ctx->mpd->periods, ds->last_period)<0))\n\t\tds->last_period = NULL;\n\n\tif (p && p->value.string && ds->last_period) {\n\t\tif (!ds->last_period->ID) {\n\t\t\tif (p->value.string[0]) {\n\t\t\t\tds->last_period->ID = p->value.string;\n\t\t\t} else {\n\t\t\t\tchar szPName[50];\n\t\t\t\tsprintf(szPName, \"P%d\", 1 + gf_list_find(ctx->mpd->periods, ds->last_period));\n\t\t\t\tds->last_period->ID = gf_strdup(szPName);\n\t\t\t}\n\t\t}\n\t\tif (ds->set && (ds->set->id<0)) {\n\t\t\t//period may be NULL (no longer scheduled)\n\t\t\tif (!ds->as_id && ds->period && ds->period->period)\n\t\t\t\tds->as_id = gf_list_find(ds->period->period->adaptation_sets, ds->set) + 1;\n\t\t\tds->set->id = ds->as_id;\n\t\t}\n\t\tds->period_continuity_id = gf_strdup(ds->last_period->ID);\n\t}\n\tds->last_period = NULL;\n\n\tds->period_dur.num = 0;\n\tds->period_dur.den = 1;\n\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_PERIOD_DUR);\n\tif (p) ds->period_dur = p->value.lfrac;\n\n\tp = gf_filter_pid_get_property_str(pid, \"max_seg_dur\");\n\tctx->index_max_seg_dur = p ? p->value.uint : 0;\n\tp = gf_filter_pid_get_property_str(pid, \"mpd_duration\");\n\tctx->index_media_duration = p ? p->value.longuint : 0;\n\n\tif (ds->stream_type==GF_STREAM_FILE) {\n\t\tif (!ds->xlink && !ds->period_start.num && !ds->period_dur.num) {\n\t\t\tds->done = 1;\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_DASH, (\"[Dasher] null PID specified without any XLINK/start/duration, ignoring\\n\"));\n\t\t} else if (ds->xlink) {\n\t\t\tctx->use_xlink = GF_TRUE;\n\t\t}\n\t} else {\n\t\tif (ds->xlink) gf_free(ds->xlink);\n\t\tds->xlink = NULL;\n\t\tCHECK_PROP_STR(GF_PROP_PID_XLINK, ds->xlink, GF_EOS)\n\t\tif (ds->xlink)\n\t\t\tctx->use_xlink = GF_TRUE;\n\t}\n\n\t//input was done due to clamp but forced to new period, reschedule\n\tif (new_period_request && ds->done && old_clamp_dur) {\n\t\tgf_list_del_item(ctx->next_period->streams, ds);\n\t\t//reset discard, blocking mode on output (set by EOS) and reset dasher EOS state\n\t\tgf_filter_pid_set_discard(ds->ipid, GF_FALSE);\n\t\tif (ds->opid && !ctx->gencues) {\n\t\t\tgf_filter_pid_discard_block(ds->opid);\n\t\t\tgf_filter_pid_remove(ds->opid);\n\t\t\tds->opid = NULL;\n\t\t}\n\t\tif (ctx->is_eos) {\n\t\t\tctx->is_eos = GF_FALSE;\n\t\t\tgf_filter_pid_discard_block(ctx->opid);\n\t\t\tif (ctx->opid_alt)\n\t\t\tgf_filter_pid_discard_block(ctx->opid_alt);\n\t\t}\n\t\tds->rep_init = GF_FALSE;\n\t\tds->presentation_time_offset = 0;\n\t\tds->rep = NULL;\n\t\tds->set = NULL;\n\t\tds->period = NULL;\n\t\tds->done = 0;\n//\t\tgf_filter_post_process_task(filter);\n//\t\tdasher_reset_stream(filter, ds, GF_FALSE);\n\t}\n\n\t//our stream is already scheduled for next period, don't do anything\n\tif (gf_list_find(ctx->next_period->streams, ds)>=0)\n\t\tperiod_switch = GF_FALSE;\n\n\t//assign default ID\n\tif (!ds->period_id)\n\t\tds->period_id = gf_strdup(DEFAULT_PERIOD_ID);\n\n\te = dasher_hls_setup_crypto(ctx, ds);\n\tif (e) return e;\n\n\tif (!period_switch) {\n\t\tif (ds->opid) {\n\t\t\tgf_filter_pid_copy_properties(ds->opid, pid);\n\t\t\t//for route out\n\t\t\tif (ctx->is_route && ctx->do_m3u8)\n\t\t\t\tgf_filter_pid_set_property(ds->opid, GF_PROP_PCK_HLS_REF, &PROP_LONGUINT( ds->hls_ref_id ) );\n\t\t\tif (ctx->llhls)\n\t\t\t\tgf_filter_pid_set_property(ds->opid, GF_PROP_PID_LLHLS, &PROP_UINT(ctx->llhls) );\n\n\t\t\tif (ctx->gencues)\n\t\t\t\tgf_filter_pid_set_property(ds->opid, GF_PROP_PID_DASH_CUE, &PROP_STRING(\"inband\") );\n\t\t}\n\t\tif (ds->rep)\n\t\t\tdasher_update_rep(ctx, ds);\n\t\treturn GF_OK;\n\t}\n\t//period switch !\n\n\t//we have queued packets (sbound modes), we cannot switch period for this stream now, force queue flush\n\tif (gf_list_count(ds->packet_queue)) {\n\t\tds->request_period_switch = new_period_request ? 2 : 1;\n\t\treturn GF_OK;\n\t}\n\t//done for this stream\n\treturn dasher_stream_period_changed(filter, ctx, ds, new_period_request);\n}\n\nstatic void\tdasher_check_chaining(GF_DasherCtx *ctx, char *scheme_id, char *url)\n{\n\tGF_MPD_Descriptor *d = gf_mpd_get_descriptor(ctx->mpd->supplemental_properties, scheme_id);\n\tif (!d && !url) return;\n\tif (!url) {\n\t\tgf_list_del_item(ctx->mpd->supplemental_properties, d);\n\t\tgf_mpd_descriptor_free(d);\n\t\treturn;\n\t}\n\tif (d) {\n\t\tgf_free(d->value);\n\t\td->value = gf_strdup(url);\n\t\treturn;\n\t}\n\td = gf_mpd_descriptor_new(NULL, scheme_id, url);\n\tif (!ctx->mpd->supplemental_properties)\n\t\tctx->mpd->supplemental_properties = gf_list_new();\n\n\tgf_list_add(ctx->mpd->supplemental_properties, d);\n}\n\n\nstatic GF_Err dasher_update_mpd(GF_DasherCtx *ctx)\n{\n\tchar profiles_string[GF_MAX_PATH];\n\tGF_XMLAttribute *cenc_att = NULL;\n\tGF_XMLAttribute *xlink_att = NULL;\n\tGF_XMLAttribute *ck_att = NULL;\n\n\tu32 i, count=gf_list_count(ctx->mpd->x_attributes);\n\tfor (i=0; i<count; i++) {\n\t\tGF_XMLAttribute * att = gf_list_get(ctx->mpd->x_attributes, i);\n\t\tif (!strcmp(att->name, \"xmlns:cenc\")) cenc_att = att;\n\t\tif (!strcmp(att->name, \"xmlns:xlink\")) xlink_att = att;\n\t\tif (!strcmp(att->name, \"xmlns:ck\")) ck_att = att;\n\t}\n\tif (ctx->dmode==GF_MPD_TYPE_DYNAMIC) {\n\t\tctx->mpd->type = GF_MPD_TYPE_DYNAMIC;\n\t} else {\n\t\tctx->mpd->type = GF_MPD_TYPE_STATIC;\n\t\tctx->mpd->availabilityStartTime = 0;\n\t}\n\n\tBool is_m2ts = (ctx->muxtype==DASHER_MUX_TS) ? GF_TRUE : GF_FALSE;\n\tif (ctx->profile==GF_DASH_PROFILE_LIVE) {\n\t\tif (ctx->use_xlink && !is_m2ts) {\n\t\t\tstrcpy(profiles_string, \"urn:mpeg:dash:profile:isoff-segext-live:2014\");\n\t\t} else {\n\t\t\tsprintf(profiles_string, \"urn:mpeg:dash:profile:%s:2011\", is_m2ts ? \"mp2t-simple\" : \"isoff-live\");\n\t\t}\n\t} else if (ctx->profile==GF_DASH_PROFILE_ONDEMAND) {\n\t\tif (ctx->use_xlink) {\n\t\t\tstrcpy(profiles_string, \"urn:mpeg:dash:profile:isoff-segext-on-demand:2014\");\n\t\t} else {\n\t\t\tstrcpy(profiles_string, \"urn:mpeg:dash:profile:isoff-on-demand:2011\");\n\t\t}\n\t} else if (ctx->profile==GF_DASH_PROFILE_MAIN) {\n\t\tsprintf(profiles_string, \"urn:mpeg:dash:profile:%s:2011\", is_m2ts ? \"mp2t-main\" : \"isoff-main\");\n\t} else if (ctx->profile==GF_DASH_PROFILE_HBBTV_1_5_ISOBMF_LIVE) {\n\t\tstrcpy(profiles_string, \"urn:hbbtv:dash:profile:isoff-live:2012\");\n\t} else if (ctx->profile==GF_DASH_PROFILE_AVC264_LIVE) {\n\t\tstrcpy(profiles_string, \"urn:mpeg:dash:profile:isoff-live:2011,http://dashif.org/guidelines/dash264\");\n\t} else if (ctx->profile==GF_DASH_PROFILE_AVC264_ONDEMAND) {\n\t\tstrcpy(profiles_string, \"urn:mpeg:dash:profile:isoff-on-demand:2011,http://dashif.org/guidelines/dash264\");\n\t} else if (ctx->profile==GF_DASH_PROFILE_DASHIF_LL) {\n\t\tstrcpy(profiles_string, \"urn:mpeg:dash:profile:isoff-live:2011,http://www.dashif.org/guidelines/low-latency-live-v5\");\n\t} else {\n\t\tstrcpy(profiles_string, \"urn:mpeg:dash:profile:full:2011\");\n\t}\n\n\tif (ctx->cmaf) {\n\t\tconst size_t offset = strlen(profiles_string);\n\t\tstrncat(profiles_string+offset, \",urn:mpeg:dash:profile:cmaf:2019\", GF_MAX_PATH-offset-1);\n\t}\n\n\tif (ctx->profX) {\n\t\tif (ctx->profX[0] == '+') {\n\t\t\tif (ctx->mpd->profiles) gf_free(ctx->mpd->profiles);\n\t\t\tctx->mpd->profiles = gf_strdup(ctx->profX+1);\n\t\t\tctx->mpd->profiles = gf_strdup(ctx->profX+1);\n\t\t} else {\n\t\t\tchar profiles_w_ext[GF_MAX_PATH+256];\n\t\t\tsprintf(profiles_w_ext, \"%s,%s\", profiles_string, ctx->profX);\n\t\t\tif (ctx->mpd->profiles) gf_free(ctx->mpd->profiles);\n\t\t\tctx->mpd->profiles = gf_strdup(profiles_w_ext);\n\t\t}\n\t} else {\n\t\tif (ctx->mpd->profiles) gf_free(ctx->mpd->profiles);\n\t\tctx->mpd->profiles = gf_strdup(profiles_string);\n\t}\n\n\tif (ctx->use_cenc && !cenc_att) {\n\t\tcenc_att = gf_xml_dom_create_attribute(\"xmlns:cenc\", \"urn:mpeg:cenc:2013\");\n\t\tgf_list_add(ctx->mpd->x_attributes, cenc_att);\n\t}\n\tif (ctx->use_xlink && !xlink_att) {\n\t\txlink_att = gf_xml_dom_create_attribute(\"xmlns:xlink\", \"http://www.w3.org/1999/xlink\");\n\t\tgf_list_add(ctx->mpd->x_attributes, xlink_att);\n\t}\n\tif (ctx->use_clearkey && !ck_att) {\n\t\tck_att = gf_xml_dom_create_attribute(\"xmlns:ck\", \"http://dashif.org/guidelines/clearKey\");\n\t\tgf_list_add(ctx->mpd->x_attributes, ck_att);\n\t}\n\n\tctx->mpd->time_shift_buffer_depth = 0;\n\tctx->mpd->minimum_update_period = 0;\n\n\tif (ctx->dmode==GF_MPD_TYPE_DYNAMIC) {\n\t\tctx->mpd->time_shift_buffer_depth = (u32) -1;\n\t\tif (ctx->tsb>=0) ctx->mpd->time_shift_buffer_depth = (u32) (1000*ctx->tsb);\n\t\tif (ctx->spd>0) ctx->mpd->suggested_presentation_delay = ctx->spd;\n\n\t\tif (ctx->refresh>=0) {\n\t\t\tif (ctx->refresh) {\n\t\t\t\tctx->mpd->minimum_update_period = (u32) (1000*ctx->refresh);\n\t\t\t} else {\n\t\t\t\tctx->mpd->minimum_update_period = ctx->segdur.num * 1000;\n\t\t\t\tctx->mpd->minimum_update_period /= ctx->segdur.den;\n\t\t\t}\n\t\t} else {\n\t\t\tctx->mpd->minimum_update_period = 0;\n\t\t}\n\t}\n\tdasher_check_chaining(ctx, \"urn:mpeg:dash:mpd-chaining:2016\", ctx->chain);\n\tdasher_check_chaining(ctx, \"urn:mpeg:dash:fallback:2016\", ctx->chain_fbk);\n\treturn GF_OK;\n}\nstatic GF_Err dasher_setup_mpd(GF_DasherCtx *ctx)\n{\n\tu32 i, count;\n\tGF_MPD_ProgramInfo *info;\n\tctx->mpd = gf_mpd_new();\n\tctx->mpd->index_mode = ctx->do_index;\n\tctx->mpd->segment_duration = (u32) gf_timestamp_rescale(ctx->segdur.num, ctx->segdur.den, 1000);\n\tctx->mpd->xml_namespace = \"urn:mpeg:dash:schema:mpd:2011\";\n\tctx->mpd->base_URLs = gf_list_new();\n\tctx->mpd->locations = gf_list_new();\n\tctx->mpd->program_infos = gf_list_new();\n\tctx->mpd->periods = gf_list_new();\n\tctx->mpd->use_gpac_ext = ctx->gxns;\n\t//created by default because we store xmlns in it\n\tctx->mpd->x_attributes = gf_list_new();\n\tif (ctx->buf<0) {\n\t\tGF_Fraction segdur = ctx->segdur;\n\t\ts32 buf = -ctx->buf;\n\t\tif (ctx->no_seg_dur && ctx->from_index) {\n\t\t\tGF_DashStream *ds = gf_list_get(ctx->current_period->streams, 0);\n\t\t\tif (ds && ds->dash_dur.num && ds->dash_dur.den)\n\t\t\t\tsegdur = ds->dash_dur;\n\t\t}\n\t\tctx->mpd->min_buffer_time = (u32) ( segdur.num * 10 * buf / segdur.den); //*1000 (ms) / 100 (percent)\n\t} else\n\t\tctx->mpd->min_buffer_time = ctx->buf;\n\n\tGF_SAFEALLOC(info, GF_MPD_ProgramInfo);\n\tif (info) {\n\t\tgf_list_add(ctx->mpd->program_infos, info);\n\t\tif (ctx->title)\n\t\t\tinfo->title = gf_strdup(ctx->title);\n\t\telse {\n\t\t\tchar tmp[256];\n\t\t\tconst char *name = NULL;\n\t\t\tif (ctx->out_path) {\n\t\t\t\tconst char *url = ctx->out_path;\n\t\t\t\tif (!strncmp(ctx->out_path, \"gfio://\", 7)) {\n\t\t\t\t\turl = gf_fileio_translate_url(ctx->out_path);\n\t\t\t\t\tif (!url) url = \"\";\n\t\t\t\t}\n\t\t\t\tname = strrchr(url, '/');\n\t\t\t\tif (!name) name = strrchr(url, '\\\\');\n\t\t\t\tif (!name) name = url;\n\t\t\t\telse name++;\n\t\t\t}\n\t\t\tsnprintf(tmp, 255, \"%s generated by GPAC\", name ? name : \"\");\n\t\t\ttmp[255]=0;\n\t\t\tinfo->title = gf_strdup(tmp);\n\t\t}\n\t\tif (ctx->cprt) info->copyright = gf_strdup(ctx->cprt);\n\t\tif (ctx->info) info->more_info_url = gf_strdup(ctx->info);\n\t\telse info->more_info_url = gf_strdup(\"http://gpac.io\");\n\t\tif (ctx->source) info->source = gf_strdup(ctx->source);\n\t\tif (ctx->lang) info->lang = gf_strdup(ctx->lang);\n\t}\n\n\tcount = ctx->location.nb_items;\n\tfor (i=0; i<count; i++) {\n\t\tchar *l = ctx->location.vals[i];\n\t\tgf_list_add(ctx->mpd->locations, gf_strdup(l));\n\t}\n\tcount = ctx->base.nb_items;\n\tfor (i=0; i<count; i++) {\n\t\tGF_MPD_BaseURL *base;\n\t\tchar *b = ctx->base.vals[i];\n\t\tGF_SAFEALLOC(base, GF_MPD_BaseURL);\n\t\tif (base) {\n\t\t\tbase->URL = gf_strdup(b);\n\t\t\tgf_list_add(ctx->mpd->base_URLs, base);\n\t\t}\n\t}\n\treturn dasher_update_mpd(ctx);\n}\n\n\nstatic GF_Err dasher_get_rfc_6381_codec_name(GF_DasherCtx *ctx, GF_DashStream *ds, char *szCodec, Bool force_inband, Bool force_sbr)\n{\n\tconst GF_PropertyValue *tile_base_dcd = NULL;\n\tif (ds->codec_id==GF_CODECID_HEVC_TILES) {\n\t\tconst GF_PropertyValue *dcd = gf_filter_pid_get_property(ds->ipid, GF_PROP_PID_DECODER_CONFIG);\n\t\tif (!dcd && ds->dep_id) {\n\t\t\tu32 i, count = gf_list_count(ctx->current_period->streams);\n\t\t\tfor (i=0; i<count; i++) {\n\t\t\t\tGF_DashStream *a_ds = gf_list_get(ctx->current_period->streams, i);\n\t\t\t\tif (a_ds->id != ds->dep_id) continue;\n\t\t\t\ttile_base_dcd = gf_filter_pid_get_property(a_ds->ipid, GF_PROP_PID_DECODER_CONFIG);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!force_inband) {\n\t\tforce_inband = ds->inband_params;\n\t}\n\treturn gf_filter_pid_get_rfc_6381_codec_string(ds->ipid, szCodec, force_inband, force_sbr, tile_base_dcd, &ds->inband_params);\n}\n\nstatic GF_DashStream *get_base_ds(GF_DasherCtx *ctx, GF_DashStream *for_ds)\n{\n\tu32 i, count;\n\tif (!for_ds->dep_id) return NULL;\n\tcount = gf_list_count(ctx->pids);\n\tfor (i=0; i<count; i++) {\n\t\tGF_DashStream *ds = gf_list_get(ctx->pids, i);\n\t\tif (ds->id == for_ds->dep_id)\n\t\t\treturn ds;\n\t}\n\treturn NULL;\n}\n\nstatic void get_canon_urn(bin128 URN, char *res)\n{\n\tchar sres[4];\n\tu32 i;\n\t/* Output canonical UIID form */\n\tstrcpy(res, \"\");\n\tfor (i=0; i<4; i++) { sprintf(sres, \"%02x\", URN[i]); strcat(res, sres); }\n\tstrcat(res, \"-\");\n\tfor (i=4; i<6; i++) { sprintf(sres, \"%02x\", URN[i]); strcat(res, sres); }\n\tstrcat(res, \"-\");\n\tfor (i=6; i<8; i++) { sprintf(sres, \"%02x\", URN[i]); strcat(res, sres); }\n\tstrcat(res, \"-\");\n\tfor (i=8; i<10; i++) { sprintf(sres, \"%02x\", URN[i]); strcat(res, sres); }\n\tstrcat(res, \"-\");\n\tfor (i=10; i<16; i++) { sprintf(sres, \"%02x\", URN[i]); strcat(res, sres); }\n}\n\nstatic const char *get_drm_kms_name(const char *canURN)\n{\n\tif (!stricmp(canURN, \"67706163-6365-6E63-6472-6D746F6F6C31\")) return \"GPAC1.0\";\n\telse if (!stricmp(canURN, \"5E629AF5-38DA-4063-8977-97FFBD9902D4\")) return \"Marlin1.0\";\n\telse if (!strcmp(canURN, \"adb41c24-2dbf-4a6d-958b-4457c0d27b95\")) return \"MediaAccess3.0\";\n\telse if (!strcmp(canURN, \"A68129D3-575B-4F1A-9CBA-3223846CF7C3\")) return \"VideoGuard\";\n\telse if (!strcmp(canURN, \"9a04f079-9840-4286-ab92-e65be0885f95\")) return \"PlayReady\";\n\telse if (!strcmp(canURN, \"9a27dd82-fde2-4725-8cbc-4234aa06ec09\")) return \"VCAS\";\n\telse if (!strcmp(canURN, \"F239E769-EFA3-4850-9C16-A903C6932EFB\")) return \"Adobe\";\n\telse if (!strcmp(canURN, \"1f83e1e8-6ee9-4f0d-ba2f-5ec4e3ed1a66\")) return \"SecureMedia\";\n\telse if (!strcmp(canURN, \"644FE7B5-260F-4FAD-949A-0762FFB054B4\")) return \"CMLA (OMA DRM)\";\n\telse if (!strcmp(canURN, \"6a99532d-869f-5922-9a91-113ab7b1e2f3\")) return \"MobiTVDRM\";\n\telse if (!strcmp(canURN, \"35BF197B-530E-42D7-8B65-1B4BF415070F\")) return \"DivX DRM\";\n\telse if (!strcmp(canURN, \"B4413586-C58C-FFB0-94A5-D4896C1AF6C3\")) return \"VODRM\";\n\telse if (!strcmp(canURN, \"edef8ba9-79d6-4ace-a3c8-27dcd51d21ed\")) return \"Widevine\";\n\telse if (!strcmp(canURN, \"80a6be7e-1448-4c37-9e70-d5aebe04c8d2\")) return \"Irdeto\";\n\telse if (!strcmp(canURN, \"dcf4e3e3-62f1-5818-7ba6-0a6fe33ff3dd\")) return \"CA 1.0, DRM+ 2.0\";\n\telse if (!strcmp(canURN, \"45d481cb-8fe0-49c0-ada9-ab2d2455b2f2\")) return \"CoreCrypt\";\n\telse if (!strcmp(canURN, \"616C7469-6361-7374-2D50-726F74656374\")) return \"altiProtect\";\n\telse if (!strcmp(canURN, \"992c46e6-c437-4899-b6a0-50fa91ad0e39\")) return \"Arris SecureMedia SteelKnot version 1\";\n\telse if (!strcmp(canURN, \"1077efec-c0b2-4d02-ace3-3c1e52e2fb4b\")) return \"cenc initData\";\n\telse if (!strcmp(canURN, \"e2719d58-a985-b3c9-781a-b030af78d30e\")) return \"ClearKey1.0\";\n\telse if (!strcmp(canURN, \"94CE86FB-07FF-4F43-ADB8-93D2FA968CA2\")) return \"FairPlay\";\n\telse if (!strcmp(canURN, \"279fe473-512c-48fe-ade8-d176fee6b40f\")) return \"Arris Titanium\";\n\telse if (!strcmp(canURN, \"aa11967f-cc01-4a4a-8e99-c5d3dddfea2d\")) return \"UDRM\";\n\treturn \"unknown\";\n}\n\nstatic GF_List *dasher_get_content_protection_desc(GF_DasherCtx *ctx, GF_DashStream *ds, GF_MPD_AdaptationSet *for_set)\n{\n\tu32 prot_scheme=0;\n\tu32 i, count;\n\tconst GF_PropertyValue *p;\n\tGF_List *res = NULL;\n\tGF_BitStream *bs_r;\n\n\tcount = gf_list_count(ctx->current_period->streams);\n\tbs_r = gf_bs_new((const char *) &count, 1, GF_BITSTREAM_READ);\n\n\tfor (i=0; i<count; i++) {\n\t\tGF_MPD_Descriptor *desc;\n\t\tGF_DashStream *a_ds = gf_list_get(ctx->current_period->streams, i);\n\t\tif (!a_ds->is_encrypted) continue;\n\n\t\tif (for_set) {\n\t\t\tif (a_ds->set != for_set) continue;\n\t\t\t//for now only insert for the stream holding the set\n\t\t\tif (!a_ds->owns_set) continue;\n\t\t} else if ((a_ds != ds) && (a_ds->muxed_base != ds) ) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tp = gf_filter_pid_get_property(a_ds->ipid, GF_PROP_PID_PROTECTION_SCHEME_TYPE);\n\t\tif (p) prot_scheme = p->value.uint;\n\n\n#ifndef GPAC_DISABLE_ISOM\n\t\tif ((prot_scheme==GF_ISOM_CENC_SCHEME) || (prot_scheme==GF_ISOM_CBC_SCHEME) || (prot_scheme==GF_ISOM_CENS_SCHEME) || (prot_scheme==GF_ISOM_CBCS_SCHEME)\n\t\t) {\n\t\t\tchar sCan[40];\n\t\t\tconst GF_PropertyValue *ki;\n\t\t\tu32 j, nb_pssh;\n\t\t\tBool add_kid=GF_FALSE;\n\t\t\tGF_XMLAttribute *att;\n\t\t\tchar szVal[GF_MAX_PATH];\n\n\t\t\tctx->use_cenc = GF_TRUE;\n\n\t\t\tki = gf_filter_pid_get_property(a_ds->ipid, GF_PROP_PID_CENC_KEY_INFO);\n\t\t\tif (!ki || !ki->value.data.ptr) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!res) res = gf_list_new();\n\t\t\tdesc = gf_mpd_descriptor_new(NULL, \"urn:mpeg:dash:mp4protection:2011\", gf_4cc_to_str(prot_scheme));\n\t\t\tgf_list_add(res, desc);\n\n\t\t\tif (ctx->dkid==DASHER_DEFKID_ON) {\n\t\t\t\tadd_kid = GF_TRUE;\n\t\t\t} else if (ctx->dkid==DASHER_DEFKID_AUTO) {\n\t\t\t\tp = gf_filter_pid_get_property(a_ds->ipid, GF_PROP_PID_CENC_HAS_ROLL);\n\t\t\t\tif (!p || !p->value.boolean) add_kid = GF_TRUE;\n\t\t\t}\n\n\t\t\tif (add_kid) {\n\t\t\t\tget_canon_urn(ki->value.data.ptr + 4, sCan);\n\t\t\t\tatt = gf_xml_dom_create_attribute(\"cenc:default_KID\", sCan);\n\t\t\t\tif (!desc->x_attributes) desc->x_attributes = gf_list_new();\n\t\t\t\tgf_list_add(desc->x_attributes, att);\n\t\t\t}\n\n\t\t\tchar *ck_url = ctx->ckurl;\n\t\t\tp = gf_filter_pid_get_property(a_ds->ipid, GF_PROP_PID_CLEARKEY_URI);\n\t\t\tif (p && p->value.string) ck_url = p->value.string;\n\t\t\tif (ck_url) {\n\t\t\t\tdesc = gf_mpd_descriptor_new(NULL, \"urn:uuid:e2719d58-a985-b3c9-781a-b030af78d30e\", \"ClearKey1.0\");\n\t\t\t\tgf_list_add(res, desc);\n\t\t\t\tGF_XMLNode *ck = gf_xml_dom_node_new(\"ck\", \"Laurl\");\n\n\t\t\t\tif (!desc->x_children) desc->x_children = gf_list_new();\n\t\t\t\tgf_list_add(desc->x_children, ck);\n\n\t\t\t\tGF_XMLNode *val = gf_xml_dom_node_new(NULL, NULL);\n\t\t\t\tval->type = GF_XML_TEXT_TYPE;\n\t\t\t\tval->name = gf_strdup(ck_url);\n\t\t\t\tif (!ck->content) ck->content = gf_list_new();\n\t\t\t\tgf_list_add(ck->content, val);\n\t\t\t\tctx->use_clearkey = GF_TRUE;\n\t\t\t}\n\n\n\t\t\tif ((ctx->pssh <= GF_DASH_PSSH_MOOF) || (ctx->pssh == GF_DASH_PSSH_NONE)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t//(data) binary blob containing (u32)N [(bin128)SystemID(u32)version(u32)KID_count[(bin128)keyID](u32)priv_size(char*priv_size)priv_data]\n\t\t\tp = gf_filter_pid_get_property(a_ds->ipid, GF_PROP_PID_CENC_PSSH);\n\t\t\tif (!p) continue;\n\n\t\t\tgf_bs_reassign_buffer(bs_r, p->value.data.ptr, p->value.data.size);\n\t\t\tnb_pssh = gf_bs_read_u32(bs_r);\n\n\t\t\t//add pssh\n\t\t\tfor (j=0; j<nb_pssh; j++) {\n\t\t\t\tu32 pssh_idx;\n\t\t\t\tbin128 sysID;\n\t\t\t\tGF_XMLNode *node;\n\t\t\t\tu32 version, k_count;\n\t\t\t\tu8 *pssh_data=NULL;\n\t\t\t\tu32 pssh_len, size_64;\n\t\t\t\tGF_BitStream *bs_w = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\n\t\t\t\t//rewrite PSSH box\n\t\t\t\tgf_bs_write_u32(bs_w, 0);\n\t\t\t\tgf_bs_write_u32(bs_w, GF_ISOM_BOX_TYPE_PSSH);\n\n\t\t\t\tgf_bs_read_data(bs_r, sysID, 16);\n\t\t\t\tversion = gf_bs_read_u32(bs_r);\n\n\t\t\t\tk_count = version ? gf_bs_read_u32(bs_r) : 0;\n\t\t\t\tgf_bs_write_u8(bs_w, version);\n\t\t\t\tgf_bs_write_u24(bs_w, 0);\n\t\t\t\tgf_bs_write_data(bs_w, sysID, 16);\n\t\t\t\tif (version) {\n\t\t\t\t\tgf_bs_write_u32(bs_w, k_count);\n\t\t\t\t\tfor (j=0; j<k_count; j++) {\n\t\t\t\t\t\tbin128 keyID;\n\t\t\t\t\t\tgf_bs_read_data(bs_r, keyID, 16);\n\t\t\t\t\t\tgf_bs_write_data(bs_w, keyID, 16);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tk_count = gf_bs_read_u32(bs_r);\n\t\t\t\tgf_bs_write_u32(bs_w, k_count);\n\t\t\t\tfor (pssh_idx=0; pssh_idx<k_count; pssh_idx++) {\n\t\t\t\t\tgf_bs_write_u8(bs_w, gf_bs_read_u8(bs_r) );\n\t\t\t\t}\n\t\t\t\tpssh_len = (u32) gf_bs_get_position(bs_w);\n\t\t\t\tgf_bs_seek(bs_w, 0);\n\t\t\t\tgf_bs_write_u32(bs_w, pssh_len);\n\t\t\t\tgf_bs_seek(bs_w, pssh_len);\n\t\t\t\tgf_bs_get_content(bs_w, &pssh_data, &pssh_len);\n\t\t\t\tgf_bs_del(bs_w);\n\n\t\t\t\tget_canon_urn(sysID, sCan);\n\t\t\t\tdesc = gf_mpd_descriptor_new(NULL, NULL, NULL);\n\t\t\t\tdesc->x_children = gf_list_new();\n\t\t\t\tsprintf(szVal, \"urn:uuid:%s\", sCan);\n\t\t\t\tdesc->scheme_id_uri = gf_strdup(szVal);\n\t\t\t\tdesc->value = gf_strdup(get_drm_kms_name(sCan));\n\t\t\t\tgf_list_add(res, desc);\n\n\t\t\t\tGF_SAFEALLOC(node, GF_XMLNode);\n\t\t\t\tif (node) {\n\t\t\t\t\tGF_XMLNode *pnode;\n\t\t\t\t\tnode->type = GF_XML_NODE_TYPE;\n\t\t\t\t\tnode->name = gf_strdup(\"cenc:pssh\");\n\t\t\t\t\tnode->content = gf_list_new();\n\t\t\t\t\tgf_list_add(desc->x_children, node);\n\n\t\t\t\t\tGF_SAFEALLOC(pnode, GF_XMLNode);\n\t\t\t\t\tif (pnode) {\n\t\t\t\t\t\tpnode->type = GF_XML_TEXT_TYPE;\n\t\t\t\t\t\tgf_list_add(node->content, pnode);\n\n\t\t\t\t\t\tsize_64 = 2*pssh_len + 3;\n\t\t\t\t\t\tpnode->name = gf_malloc(sizeof(char) * size_64);\n\t\t\t\t\t\tif (pnode->name) {\n\t\t\t\t\t\t\tsize_64 = gf_base64_encode((const char *)pssh_data, pssh_len, (char *)pnode->name, size_64);\n\t\t\t\t\t\t\tpnode->name[size_64] = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tgf_free(pssh_data);\n\t\t\t}\n\t\t} else\n#endif // GPAC_DISABLE_ISOM\n\t\t{\n\t\t\tif (ctx->do_mpd) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_DASH, (\"[Dasher] Protection scheme %s has no official DASH mapping, using URI \\\"urn:gpac:dash:mp4protection:2018\\\"\\n\", gf_4cc_to_str(prot_scheme)));\n\t\t\t}\n\t\t\tif (!res) res = gf_list_new();\n\t\t\tdesc = gf_mpd_descriptor_new(NULL, \"urn:gpac:dash:mp4protection:2018\", gf_4cc_to_str(prot_scheme));\n\t\t\tgf_list_add(res, desc);\n\t\t}\n\t}\n\tgf_bs_del(bs_r);\n\treturn res;\n}\n\nstatic void dasher_get_mime_and_ext(GF_DasherCtx *ctx, GF_DashStream *ds, const char **out_subtype, const char **out_ext)\n{\n\tconst char *subtype = NULL;\n\tconst char *mux_ext = NULL;\n\tconst char *cstr;\n\n\tif (ctx->muxtype!=DASHER_MUX_AUTO) {\n\t\tswitch (ctx->muxtype) {\n\t\tcase DASHER_MUX_ISOM: subtype = \"mp4\"; mux_ext = \"mp4\"; break;\n\t\tcase DASHER_MUX_TS: subtype = \"mp2t\"; mux_ext = \"ts\"; break;\n\t\tcase DASHER_MUX_MKV: subtype = \"x-matroska\"; mux_ext = \"mkv\"; break;\n\t\tcase DASHER_MUX_WEBM: subtype = \"webm\"; mux_ext = \"webm\"; break;\n\t\tcase DASHER_MUX_OGG: subtype = \"ogg\"; mux_ext = \"ogg\"; break;\n\t\tcase DASHER_MUX_RAW:\n\t\t\tcstr = gf_codecid_mime(ds->codec_id);\n\t\t\tif (cstr) {\n\t\t\t\tsubtype = strchr(cstr, '/');\n\t\t\t\tif (subtype) subtype++;\n\t\t\t\telse subtype = \"raw\";\n\t\t\t}\n\t\t\tif (out_ext) {\n\t\t\t\tcstr = gf_codecid_file_ext(ds->codec_id);\n\t\t\t\tif (cstr) *out_ext = cstr;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t} else if (ctx->initext) {\n\t\tmux_ext = ctx->initext;\n\t\tif (!strcmp(ctx->initext, \"ts\") || !strcmp(ctx->initext, \"m2ts\")) {\n\t\t\tsubtype = \"mp2t\";\n\t\t\tctx->muxtype = DASHER_MUX_TS;\n\t\t} else if (!strcmp(ctx->initext, \"mkv\") || !strcmp(ctx->initext, \"mka\") || !strcmp(ctx->initext, \"mks\") || !strcmp(ctx->initext, \"mk3d\")) {\n\t\t\tsubtype = \"x-matroska\";\n\t\t\tctx->muxtype = DASHER_MUX_MKV;\n\t\t} else if (!strcmp(ctx->initext, \"webm\") || !strcmp(ctx->initext, \"weba\")) {\n\t\t\tsubtype = \"webm\";\n\t\t\tctx->muxtype = DASHER_MUX_WEBM;\n\t\t} else if (!strcmp(ctx->initext, \"ogg\") || !strcmp(ctx->initext, \"oga\") || !strcmp(ctx->initext, \"ogv\") || !strcmp(ctx->initext, \"spx\") || !strcmp(ctx->initext, \"oggm\") || !strcmp(ctx->initext, \"opus\")) {\n\t\t\tsubtype = \"ogg\";\n\t\t\tctx->muxtype = DASHER_MUX_OGG;\n\t\t}\n\t\telse if (!strcmp(ctx->initext, \"null\")) {\n\t\t\tmux_ext = \"mp4\";\n\t\t\tctx->muxtype = DASHER_MUX_ISOM;\n\t\t}\n\t}\n\tif (!subtype) subtype = \"mp4\";\n\tif (out_subtype) *out_subtype = subtype;\n\tif (!mux_ext) mux_ext = \"mp4\";\n\tif (out_ext) *out_ext = mux_ext;\n}\n\n\nstatic void dasher_update_rep(GF_DasherCtx *ctx, GF_DashStream *ds)\n{\n\tchar szCodec[RFC6381_CODEC_NAME_SIZE_MAX];\n\n\t//Outputs are not yet connected, derive mime from init segment extension\n\tif (!ds->rep->mime_type) {\n\t\tconst char *subtype = NULL;\n\t\tdasher_get_mime_and_ext(ctx, ds, &subtype, NULL);\n\n\t\tif (ds->stream_type==GF_STREAM_VISUAL)\n\t\t\tgf_dynstrcat(&ds->rep->mime_type, \"video/\", NULL);\n\t\telse if (ds->stream_type==GF_STREAM_AUDIO)\n\t\t\tgf_dynstrcat(&ds->rep->mime_type, \"audio/\", NULL);\n\t\telse\n\t\t\tgf_dynstrcat(&ds->rep->mime_type, \"application/\", NULL);\n\n\t\tgf_dynstrcat(&ds->rep->mime_type, subtype, NULL);\n\t}\n\n\tds->rep->bandwidth = ds->bitrate;\n\tif (ds->stream_type==GF_STREAM_VISUAL) {\n\t\tds->rep->width = ds->width;\n\t\tds->rep->height = ds->height;\n\n\n\t\tif (!ds->rep->sar) {\n\t\t\tGF_SAFEALLOC(ds->rep->sar, GF_MPD_Fractional);\n\t\t}\n\t\tif (ds->rep->sar) {\n\t\t\tds->rep->sar->num = ds->sar.num;\n\t\t\tds->rep->sar->den = ds->sar.den;\n\t\t}\n\t\tif (ds->fps.num && ds->fps.den) {\n\t\t\tif (!ds->rep->framerate) {\n\t\t\t\tGF_SAFEALLOC(ds->rep->framerate, GF_MPD_Fractional);\n\t\t\t}\n\t\t\tif (ds->rep->framerate) {\n\t\t\t\tds->rep->framerate->num = ds->fps.num;\n\t\t\t\tds->rep->framerate->den = ds->fps.den;\n\t\t\t\tgf_media_get_reduced_frame_rate(&ds->rep->framerate->num, &ds->rep->framerate->den);\n\t\t\t}\n\t\t}\n\t}\n\telse if (ds->stream_type==GF_STREAM_AUDIO) {\n\t\tBool use_cicp = GF_FALSE;\n\t\tBool use_dolbyx = GF_FALSE;\n\t\tGF_MPD_Descriptor *desc;\n\t\tchar value[256];\n\t\tds->rep->samplerate = ds->sr;\n\n\t\tif (ds->nb_surround || ds->nb_lfe) use_cicp = GF_TRUE;\n\t\tif ((ds->codec_id==GF_CODECID_MHAS) || (ds->codec_id==GF_CODECID_MPHA)) use_cicp = GF_TRUE;\n\t\tif ((ds->codec_id==GF_CODECID_DTS_EXPRESS_LBR) || (ds->codec_id==GF_CODECID_DTS_CA) || (ds->codec_id==GF_CODECID_DTS_HD_HR_MASTER)\n\t\t    || (ds->codec_id==GF_CODECID_DTS_HD_LOSSLESS) || (ds->codec_id==GF_CODECID_DTS_X) || (ds->codec_id==GF_CODECID_DTS_Y))\n\t\t\tuse_cicp = GF_TRUE;\n\n\t\tif ((ds->codec_id==GF_CODECID_AC3) || (ds->codec_id==GF_CODECID_EAC3)) {\n\t\t\t//if regular MPEG-DASH, use CICP, otherwise use Dolby signaling\n\t\t\tif (ctx->profile > GF_DASH_PROFILE_FULL) {\n\t\t\t\tuse_dolbyx = GF_TRUE;\n\t\t\t}\n\t\t}\n\t\tif (use_dolbyx) {\n\t\t\tu32 cicp_layout = 0;\n\t\t\tif (ds->ch_layout)\n\t\t\t\tcicp_layout = gf_audio_fmt_get_cicp_from_layout(ds->ch_layout);\n\t\t\tif (!cicp_layout)\n\t\t\t\tcicp_layout = gf_audio_fmt_get_cicp_layout(ds->nb_ch, ds->nb_surround, ds->nb_lfe);\n\n\t\t\tsprintf(value, \"%X\", gf_audio_fmt_get_dolby_chanmap(cicp_layout) );\n\t\t\tdesc = gf_mpd_descriptor_new(NULL, \"tag:dolby.com,2014:dash:audio_channel_configuration:2011\", value);\n\t\t}\n\t\telse if (!use_cicp) {\n\t\t\tsprintf(value, \"%d\", ds->nb_ch);\n\t\t\tdesc = gf_mpd_descriptor_new(NULL, \"urn:mpeg:dash:23003:3:audio_channel_configuration:2011\", value);\n\t\t} else {\n\t\t\tsprintf(value, \"%d\", gf_audio_fmt_get_cicp_layout(ds->nb_ch, ds->nb_surround, ds->nb_lfe));\n\t\t\tdesc = gf_mpd_descriptor_new(NULL, \"urn:mpeg:mpegB:cicp:ChannelConfiguration\", value);\n\t\t}\n\n\t\tgf_mpd_del_list(ds->rep->audio_channels, gf_mpd_descriptor_free, GF_TRUE);\n\n\t\tgf_list_add(ds->rep->audio_channels, desc);\n\t\tif (ds->atmos_complexity_type) {\n\t\t\tdesc = gf_mpd_descriptor_new(NULL, \"tag:dolby.com,2018:dash:EC3_ExtensionType:2018\", \"JOC\");\n\t\t\tgf_list_add(ds->rep->supplemental_properties, desc);\n\n\t\t\tsprintf(value, \"%d\", ds->atmos_complexity_type);\n\t\t\tdesc = gf_mpd_descriptor_new(NULL, \"tag:dolby.com,2018:dash:EC3_ExtensionComplexityIndex:2018\", value);\n\t\t\tgf_list_add(ds->rep->supplemental_properties, desc);\n\t\t}\n\t} else {\n\t}\n\n\tif (ctx->from_index <= IDXMODE_MANIFEST) {\n\t\tdasher_get_rfc_6381_codec_name(ctx, ds, szCodec, ((ctx->bs_switch==DASHER_BS_SWITCH_INBAND) || (ctx->bs_switch==DASHER_BS_SWITCH_INBAND_PPS)) ? GF_TRUE : GF_FALSE, GF_TRUE);\n\t\tif (ds->rep->codecs) gf_free(ds->rep->codecs);\n\t\tds->rep->codecs = gf_strdup(szCodec);\n\t}\n\n\tif (ds->interlaced) ds->rep->scan_type = GF_MPD_SCANTYPE_INTERLACED;\n\telse {\n\t\t//profiles forcing scanType=progressive for progressive\n\t\tswitch (ctx->profile) {\n\t\tcase GF_DASH_PROFILE_HBBTV_1_5_ISOBMF_LIVE:\n\t\t\tds->rep->scan_type = GF_MPD_SCANTYPE_PROGRESSIVE;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (ctx->cp!=GF_DASH_CPMODE_ADAPTATION_SET) {\n\t\tgf_mpd_del_list(ds->rep->content_protection, gf_mpd_descriptor_free, 0);\n\t\tds->rep->content_protection = dasher_get_content_protection_desc(ctx, ds, NULL);\n\t}\n}\n\nstatic void dasher_setup_rep(GF_DasherCtx *ctx, GF_DashStream *ds, u32 *srd_rep_idx)\n{\n\tconst GF_PropertyValue *p;\n\n\tassert(ds->rep==NULL);\n\tds->rep = gf_mpd_representation_new();\n\tds->rep->playback.udta = ds;\n\tif (ds->tci)\n\t\tds->rep->crypto_type = 1;\n\telse\n\t\tds->rep->crypto_type = ds->is_encrypted ? 2 : 0;\n\n\tdasher_update_rep(ctx, ds);\n\tds->rep->streamtype = ds->stream_type;\n\n\tp = gf_filter_pid_get_property(ds->ipid, GF_PROP_PID_AS_ID);\n\t//do not reset as id in case of period continuity\n\tif (p) {\n\t\tif (ds->as_id != p->value.uint) {\n\t\t\tif (ds->period_continuity_id) gf_free(ds->period_continuity_id);\n\t\t\tds->period_continuity_id = NULL;\n\t\t}\n\t\tds->as_id = p->value.uint;\n\t}\n\n\tp = gf_filter_pid_get_property(ds->ipid, GF_PROP_PID_REP_ID);\n\tif (p) {\n\t\tif (ds->rep_id) gf_free(ds->rep_id);\n\n\t\tif (!ds->tile_base && (ds->srd.w || ds->srd.z) && !ctx->sseg && !ctx->sfile) {\n\t\t\tchar *rep_name = gf_malloc(sizeof(char) * (strlen(p->value.string) + 15) );\n\t\t\tsprintf(rep_name, \"%s_%d\", p->value.string, *srd_rep_idx);\n\t\t\tds->rep_id = rep_name;\n\t\t\t(*srd_rep_idx) ++;\n\t\t} else {\n\t\t\tds->rep_id = gf_strdup(p->value.string);\n\t\t}\n\n\t} else if (!ds->rep_id) {\n\t\tchar szRepID[20];\n\t\tsprintf(szRepID, \"%d\", 1 + gf_list_find(ctx->pids, ds));\n\t\tds->rep_id = gf_strdup(szRepID);\n\t}\n\tds->rep->id = gf_strdup(ds->rep_id);\n\n\tp = gf_filter_pid_get_property(ds->ipid, GF_PROP_PID_HLS_EXT_MASTER);\n\tif (p) {\n\t\tds->rep->nb_hls_master_tags = p->value.string_list.nb_items;\n\t\tds->rep->hls_master_tags = (const char **) p->value.string_list.vals;\n\t}\n\tp = gf_filter_pid_get_property(ds->ipid, GF_PROP_PID_HLS_EXT_VARIANT);\n\tif (p) {\n\t\tds->rep->nb_hls_variant_tags = p->value.string_list.nb_items;\n\t\tds->rep->hls_variant_tags = (const char **) p->value.string_list.vals;\n\t}\n\n\tp = gf_filter_pid_get_property(ds->ipid, GF_PROP_PID_URL);\n\tif (p && ctx->do_index) {\n\t\tchar *dst = gf_filter_pid_get_destination(ctx->opid);\n\t\tif (dst) {\n\t\t\tchar *opath=NULL, *ipath=NULL;\n\t\t\tif (gf_url_is_relative(p->value.string) && (p->value.string[0]!='.'))\n\t\t\t\tgf_dynstrcat(&opath, \"./\", NULL);\n\t\t\tgf_dynstrcat(&opath, p->value.string, NULL);\n\t\t\tif (gf_url_is_relative(dst) && (dst[0]!='.'))\n\t\t\t\tgf_dynstrcat(&ipath, \"./\", NULL);\n\t\t\tgf_dynstrcat(&ipath, dst, NULL);\n\n\t\t\tds->rep->res_url = gf_url_concatenate_parent(ipath, opath);\n\t\t\tgf_free(ipath);\n\t\t\tgf_free(opath);\n\t\t} else {\n\t\t\tds->rep->res_url = gf_strdup(p->value.string);\n\t\t}\n\t\tif (dst) gf_free(dst);\n\t\tp = gf_filter_pid_get_property(ds->ipid, GF_PROP_PID_ID);\n\t\tds->rep->trackID = p ? p->value.uint : 0;\n\n\t\tif (ctx->do_index==2) {\n\t\t\tif (!ds->rep->x_children) ds->rep->x_children = gf_list_new();\n\t\t\tu32 idx=0;\n\t\t\tchar *obuf=NULL;\n\t\t\tu32 obuf_alloc = 0;\n\t\t\twhile (1) {\n\t\t\t\tu32 p4cc;\n\t\t\t\tconst char *pname;\n\t\t\t\tp = gf_filter_pid_enum_properties(ds->ipid, &idx, &p4cc, &pname);\n\t\t\t\tif (!p) break;\n\t\t\t\tswitch (p4cc) {\n\t\t\t\tcase GF_PROP_PID_ID:\n\t\t\t\tcase GF_PROP_PID_URL:\n\t\t\t\tcase GF_PROP_PID_FILEPATH:\n\t\t\t\tcase GF_PROP_PID_FILE_EXT:\n\t\t\t\tcase GF_PROP_PID_FILE_CACHED:\n\t\t\t\tcase GF_PROP_PID_DOWN_SIZE:\n\t\t\t\tcase GF_PROP_PID_DOWNLOAD_SESSION:\n\t\t\t\tcase GF_PROP_PID_TRACK_NUM:\n\t\t\t\tcase GF_PROP_PID_MEDIA_DATA_SIZE:\n\t\t\t\tcase GF_PROP_PID_MAX_FRAME_SIZE:\n\t\t\t\tcase GF_PROP_PID_AVG_FRAME_SIZE:\n\t\t\t\tcase GF_PROP_PID_MAX_TS_DELTA:\n\t\t\t\tcase GF_PROP_PID_CONSTANT_DURATION:\n\t\t\t\tcase GF_PROP_PID_PLAYBACK_MODE:\n\t\t\t\tcase GF_PROP_PID_CHAP_TIMES:\n\t\t\t\tcase GF_PROP_PID_CHAP_NAMES:\n\t\t\t\tcase GF_PROP_PID_ISOM_UDTA:\n\t\t\t\t\tcontinue;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (p->type == GF_PROP_POINTER) continue;\n\n\t\t\t\tGF_XMLNode *prop = gf_xml_dom_node_new(NULL, \"prop\");\n\t\t\t\tprop->attributes = gf_list_new();\n\t\t\t\tgf_list_add(ds->rep->x_children,  prop);\n\t\t\t\tprop->orig_pos = -1;\n\t\t\t\tGF_XMLAttribute *att;\n\t\t\t\tif (p4cc) {\n\t\t\t\t\tatt = gf_xml_dom_create_attribute(\"type\", gf_props_4cc_get_name(p4cc));\n\t\t\t\t\tgf_list_add(prop->attributes, att);\n\t\t\t\t} else {\n\t\t\t\t\tatt = gf_xml_dom_create_attribute(\"name\", pname);\n\t\t\t\t\tgf_list_add(prop->attributes, att);\n\t\t\t\t\tatt = gf_xml_dom_create_attribute(\"ptype\", gf_props_get_type_name(p->type));\n\t\t\t\t\tgf_list_add(prop->attributes, att);\n\t\t\t\t}\n\t\t\t\tchar szDump[GF_PROP_DUMP_ARG_SIZE];\n\t\t\t\tu32 res, obuf_size, j;\n\t\t\t\tchar *cdata=NULL;\n\n\t\t\t\tswitch (p->type) {\n\t\t\t\tcase GF_PROP_DATA:\n\t\t\t\tcase GF_PROP_DATA_NO_COPY:\n\t\t\t\tcase GF_PROP_CONST_DATA:\n\t\t\t\t\tobuf_size = p->value.data.size*3;\n\t\t\t\t\tif (obuf_size>obuf_alloc) {\n\t\t\t\t\t\tobuf = gf_realloc(obuf, sizeof(char)*obuf_size);\n\t\t\t\t\t\tobuf_alloc = obuf_size;\n\t\t\t\t\t}\n\t\t\t\t\tres = gf_base64_encode(p->value.data.ptr, p->value.data.size, obuf, obuf_size);\n\t\t\t\t\tobuf[res] = 0;\n\t\t\t\t\tatt = gf_xml_dom_create_attribute(\"value\", obuf);\n\t\t\t\t\tgf_list_add(prop->attributes, att);\n\t\t\t\t\tbreak;\n\t\t\t\tcase GF_PROP_STRING_LIST:\n\t\t\t\t\tfor (j=0; j<p->value.string_list.nb_items; j++) {\n\t\t\t\t\t\tgf_dynstrcat( &cdata, p->value.string_list.vals[j], \",\");\n\t\t\t\t\t}\n\t\t\t\t\tj = (u32) (strlen(cdata)+1);\n\t\t\t\t\tobuf_size = j*3;\n\t\t\t\t\tif (obuf_size>obuf_alloc) {\n\t\t\t\t\t\tobuf = gf_realloc(obuf, sizeof(char)*obuf_size);\n\t\t\t\t\t\tobuf_alloc = obuf_size;\n\t\t\t\t\t}\n\t\t\t\t\tres = gf_base64_encode(cdata, j, obuf, obuf_size);\n\t\t\t\t\tobuf[res] = 0;\n\t\t\t\t\tatt = gf_xml_dom_create_attribute(\"value\", obuf);\n\t\t\t\t\tgf_list_add(prop->attributes, att);\n\t\t\t\t\tgf_free(cdata);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tatt = gf_xml_dom_create_attribute(\"value\", gf_props_dump(p4cc, p, szDump, GF_PROP_DUMP_NO_REDUCE));\n\t\t\t\t\tgf_list_add(prop->attributes, att);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (obuf) gf_free(obuf);\n\t\t}\n\t}\n}\n\nstatic Bool dasher_same_roles(GF_DashStream *ds1, GF_DashStream *ds2)\n{\n\tconst GF_PropStringList *slist;\n\tif (ds1->p_role && ds2->p_role) {\n\t\tif (gf_props_equal(ds1->p_role, ds2->p_role)) return GF_TRUE;\n\t}\n\tif (!ds1->p_role && !ds2->p_role)\n\t\treturn GF_TRUE;\n\n\t//special case, if one is set and the other is not, compare with \"main\" role\n\tslist = ds2->p_role ?  &ds2->p_role->value.string_list : &ds1->p_role->value.string_list;\n\tif (slist->nb_items==1) {\n\t\tif (!strcmp(slist->vals[0], \"main\")) return GF_TRUE;\n\t}\n\treturn GF_FALSE;\n}\n\nstatic u32 dasher_get_next_as_id(GF_DasherCtx *ctx)\n{\n\tu32 check_id = 1;\n\tu32 i, count = gf_list_count(ctx->current_period->streams);\n\tfor (i=0; i<count; i++) {\n\t\tGF_DashStream *ds = gf_list_get(ctx->current_period->streams, i);\n\t\tif (ds->as_id == check_id) {\n\t\t\tcheck_id++;\n\t\t\ti = -1;\n\t\t\tcontinue;\n\t\t}\n\t}\n\treturn check_id;\n}\n\nstatic Bool dasher_same_adaptation_set(GF_DasherCtx *ctx, GF_DashStream *ds, GF_DashStream *ds_test)\n{\n\tconst char *lang1, *lang2;\n\tconst GF_PropertyValue *p1, *p2;\n\n\t//in all forward mode we don't rewrite the manifest, make each source file a single as\n\tif (ctx->forward_mode==DASHER_FWD_ALL)\n\t\treturn GF_FALSE;\n\t\t\n\t//muxed representations\n\tif (ds_test->muxed_base) {\n\t\tif (ds_test->muxed_base == ds)\n\t\t\treturn GF_TRUE;\n\t\t//if muxed base rep has been registered with this AdaptationSet, also register this stream\n\t\tif (gf_list_find(ds->set->representations, ds_test->muxed_base->rep)>=0)\n\t\t\treturn GF_TRUE;\n\t}\n\n\t//otherwise we have to be of same type\n\tif (ds->stream_type != ds_test->stream_type) return GF_FALSE;\n\n\t//not the same roles\n\tif (!dasher_same_roles(ds, ds_test)) return GF_FALSE;\n\n\t//avoid text streams with no roles and same language to be in the same AS\n\tif (ds->stream_type==GF_STREAM_TEXT) {\n\t\tif (ds->codec_id==ds_test->codec_id) return GF_FALSE;\n\t}\n\n\t//intra-only trick mode belongs to a separate AS\n\tif ((ds->stream_type == GF_STREAM_VISUAL) && (ds->sync_points_type != ds_test->sync_points_type)) {\n\t\t//assign trickmode as id for dashif\n\t\tif (ds_test->sync_points_type == DASHER_SYNC_NONE) {\n\t\t\tif (!ds->as_id) ds->as_id = dasher_get_next_as_id(ctx);\n\t\t\tds_test->sync_as_id = ds->as_id;\n\t\t}\n\t\telse if (ds->sync_points_type == DASHER_SYNC_NONE) {\n\t\t\tif (!ds_test->as_id) ds_test->as_id = dasher_get_next_as_id(ctx);\n\t\t\tds->sync_as_id = ds_test->as_id;\n\t\t}\n\t\treturn GF_FALSE;\n\t}\n\n\t/* if two inputs don't have the same (number and value) as_desc they don't belong to the same AdaptationSet\n\t   (use c_as_desc for AdaptationSet descriptors common to all inputs in an AS) */\n\tif (!ds->p_as_desc && ds_test->p_as_desc)\n\t\treturn GF_FALSE;\n\tif (ds->p_as_desc && !ds_test->p_as_desc)\n\t\treturn GF_FALSE;\n\tif (ds->p_as_desc && ! gf_props_equal(ds->p_as_desc, ds_test->p_as_desc))\n\t\treturn GF_FALSE;\n\n\t//need same AS ID if specified\n\tif (ds->as_id && ds_test->as_id &&(ds->as_id != ds_test->as_id) )\n\t\treturn GF_FALSE;\n\n\t//need same dash duration if aligned\n\tif (ctx->align) {\n\t\tif ((u64) ds->dash_dur.num * ds_test->dash_dur.den != (u64) ds_test->dash_dur.num * ds->dash_dur.den) return GF_FALSE;\n\t}\n\n\t//if one of the pid is marked with period resume and the other is not, one is a spliced media the other no\n\t//cf flist filter\n\tp1 = gf_filter_pid_get_property_str(ds->ipid, \"period_resume\");\n\tp2 = gf_filter_pid_get_property_str(ds_test->ipid, \"period_resume\");\n\tif ((!p1 && p2) || (p1 && !p2) || (p1 && gf_props_equal(p1, p2)))\n\t\treturn GF_FALSE;\n\n\tif (ds->srd.x != ds_test->srd.x) return GF_FALSE;\n\tif (ds->srd.y != ds_test->srd.y) return GF_FALSE;\n\tif (ds->srd.z != ds_test->srd.z) return GF_FALSE;\n\tif (ds->srd.w != ds_test->srd.w) return GF_FALSE;\n\n\tif (ds->view_id != ds_test->view_id) return GF_FALSE;\n\t//according to DASH spec mixing interlaced and progressive is OK\n\t//if (ds->interlaced != ds_test->interlaced) return GF_FALSE;\n\tif (ds->nb_ch != ds_test->nb_ch) return GF_FALSE;\n\n\tlang1 = ds->lang ? ds->lang : \"und\";\n\tlang2 = ds_test->lang ? ds_test->lang : \"und\";\n\tif (strcmp(lang1, lang2)) return GF_FALSE;\n\n\tif (ds->stream_type==GF_STREAM_VISUAL) {\n\t\tu32 w, h, tw, th;\n\t\tif (ctx->no_sar) {\n\t\t\tw = ds->width;\n\t\t\th = ds->height;\n\t\t\ttw = ds_test->width;\n\t\t\tth = ds_test->height;\n\t\t} else {\n\t\t\tw = ds->width * ds->sar.num;\n\t\t\th = ds->height * ds->sar.den;\n\t\t\ttw = ds_test->width * ds_test->sar.num;\n\t\t\tth = ds_test->height * ds_test->sar.den;\n\t\t}\n\n\t\t//not the same aspect ratio\n\t\tif (w * th != h * tw)\n\t\t\treturn GF_FALSE;\n\t} else if (ds->stream_type==GF_STREAM_AUDIO) {\n\t\tif (!ctx->mix_codecs && (ds->codec_id != ds_test->codec_id) )\n\t\t\treturn GF_FALSE;\n\t\t//we allow mix of channels config\n\t} else {\n\t\tif (!ctx->mix_codecs && strcmp(ds->rep->codecs, ds_test->rep->codecs)) return GF_FALSE;\n\t\treturn GF_TRUE;\n\t}\n\t//ok, we are video or audio with mixed codecs\n\tif (ctx->mix_codecs) return GF_TRUE;\n\t//we need dependencies, unless SRD case\n\tif (!ds_test->srd.z && !ds_test->srd.w) {\n\t\tif (ds_test->dep_id && (ds_test->src_id==ds->src_id) && gf_list_find(ds->complementary_streams, ds_test) < 0) {\n\t\t\treturn GF_FALSE;\n\t\t}\n\t}\n\t//we should be good\n\treturn GF_TRUE;\n}\n\nstatic void dasher_add_descriptors(GF_List **p_dst_list, const GF_PropertyValue *desc_val)\n{\n\tu32 j, count;\n\tGF_List *dst_list;\n\tif (!desc_val) return;\n\tif (desc_val->type != GF_PROP_STRING_LIST) return;\n\tcount = desc_val->value.string_list.nb_items;\n\tif (!count) return;\n\tif ( ! (*p_dst_list)) *p_dst_list = gf_list_new();\n\tdst_list = *p_dst_list;\n\tfor (j=0; j<count; j++) {\n\t\tchar *desc = desc_val->value.string_list.vals[j];\n\t\tif (desc[0] == '<') {\n\t\t\tGF_XMLNode *d;\n\t\t\tGF_SAFEALLOC(d, GF_XMLNode);\n\t\t\tif (d) {\n\t\t\t\td->type = GF_XML_TEXT_TYPE;\n\t\t\t\td->name = gf_strdup(desc);\n\t\t\t\tgf_list_add(dst_list, d);\n\t\t\t}\n\t\t} else {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_DASH, (\"[Dasher] Invalid descriptor %s, expecting '<' as first character\\n\", desc));\n\t\t}\n\t}\n}\n\nstatic void dasher_setup_set_defaults(GF_DasherCtx *ctx, GF_MPD_AdaptationSet *set)\n{\n\tu32 i, count;\n\tBool main_role_set = GF_FALSE;\n\t//by default setup alignment\n\tif (ctx->sseg) set->subsegment_alignment = ctx->align;\n\telse set->segment_alignment = ctx->align;\n\n\t//startWithSAP is set when the first packet comes in\n\n\t//the rest depends on the various profiles/iop, to check\n\tcount = gf_list_count(set->representations);\n\tfor (i=0; i<count; i++) {\n\t\tGF_MPD_Representation *rep = gf_list_get(set->representations, i);\n\t\tGF_DashStream *ds = rep->playback.udta;\n\n\t\tif (set->max_width < ds->width) set->max_width = ds->width;\n\t\tif (set->max_height < ds->height) set->max_height = ds->height;\n/*\t\tif (set->max_bandwidth < ds->rep->bandwidth) set->max_bandwidth = ds->rep->bandwidth;\n\t\tif (set->max_framerate * ds->fps.den < ds->fps.num) set->max_framerate = (u32) (ds->fps.num / ds->fps.den);\n*/\n\n\t\t/*set trick mode*/\n\t\tif (set->intra_only && (ds->stream_type==GF_STREAM_VISUAL)) {\n\t\t\tchar value[256];\n\t\t\tGF_MPD_Descriptor* desc;\n\t\t\tsprintf(value, \"%d\", ds->sync_as_id);\n\t\t\tdesc = gf_mpd_descriptor_new(NULL, \"http://dashif.org/guidelines/trickmode\", value);\n\t\t\tgf_list_add(set->essential_properties, desc);\n\t\t}\n\t\t/*set role*/\n\t\tif (ds->p_role) {\n\t\t\tu32 j, role_count;\n\t\t\trole_count = ds->p_role->value.string_list.nb_items;\n\t\t\tfor (j=0; j<role_count; j++) {\n\t\t\t\tchar *role = ds->p_role->value.string_list.vals[j];\n\t\t\t\tGF_MPD_Descriptor *desc=NULL;\n\t\t\t\tchar *uri=NULL;\n\t\t\t\t//all roles defined by dash 5th edition\n\t\t\t\tif (!strcmp(role, \"caption\") || !strcmp(role, \"subtitle\") || !strcmp(role, \"main\")\n\t\t\t        || !strcmp(role, \"alternate\") || !strcmp(role, \"supplementary\") || !strcmp(role, \"commentary\")\n\t\t\t        || !strcmp(role, \"dub\") || !strcmp(role, \"description\") || !strcmp(role, \"sign\")\n\t\t\t\t\t || !strcmp(role, \"metadata\") || !strcmp(role, \"enhanced-audio-intelligibility\")\n\t\t\t\t\t || !strcmp(role, \"emergency\") || !strcmp(role, \"forced-subtitle\")\n\t\t\t\t\t || !strcmp(role, \"easyreader\") || !strcmp(role, \"karaoke\")\n\t\t\t\t) {\n\t\t\t\t\turi = \"urn:mpeg:dash:role:2011\";\n\t\t\t\t\tif (!strcmp(role, \"main\")) main_role_set = GF_TRUE;\n\t\t\t\t} else {\n\t\t\t\t\tchar *sep = strrchr(role, ':');\n\t\t\t\t\tif (sep) {\n\t\t\t\t\t\tsep[0] = 0;\n\t\t\t\t\t\tdesc = gf_mpd_descriptor_new(NULL, role, sep+1);\n\t\t\t\t\t\tsep[0] = ':';\n\t\t\t\t\t} else {\n\t\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_DASH, (\"[Dasher] Unrecognized role %s - using GPAC urn for schemaID\\n\", role));\n\t\t\t\t\t\turi = \"urn:gpac:dash:role:2013\";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!desc)\n\t\t\t\t\tdesc = gf_mpd_descriptor_new(NULL, uri, role);\n\n\t\t\t\tgf_list_add(set->role, desc);\n\t\t\t}\n\t\t}\n\t\t//set SRD\n\t\tif (!i && ds->srd.z && ds->srd.w) {\n\t\t\tchar value[256];\n\t\t\tGF_MPD_Descriptor *desc;\n\t\t\tif (ds->dep_id) {\n\t\t\t\tsprintf(value, \"1,%d,%d,%d,%d\", ds->srd.x, ds->srd.y, ds->srd.z, ds->srd.w);\n\t\t\t\tdesc = gf_mpd_descriptor_new(NULL, \"urn:mpeg:dash:srd:2014\", value);\n\t\t\t\tgf_list_add(set->supplemental_properties, desc);\n\t\t\t} else {\n\t\t\t\tif (ds->tile_base) {\n\t\t\t\t\tsprintf(value, \"1,0,0,0,0,%d,%d\", ds->srd.z, ds->srd.w);\n\t\t\t\t} else {\n\t\t\t\t\tconst GF_PropertyValue *p = gf_filter_pid_get_property(ds->ipid, GF_PROP_PID_SRD_REF);\n\t\t\t\t\tif (p) {\n\t\t\t\t\t\tsprintf(value, \"1,%d,%d,%d,%d,%d,%d\", ds->srd.x, ds->srd.y, ds->srd.z, ds->srd.w, p->value.vec2i.x, p->value.vec2i.y);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsprintf(value, \"1,%d,%d,%d,%d\", ds->srd.x, ds->srd.y, ds->srd.z, ds->srd.w);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdesc = gf_mpd_descriptor_new(NULL, \"urn:mpeg:dash:srd:2014\", value);\n\t\t\t\tgf_list_add(set->essential_properties, desc);\n\t\t\t}\n\t\t}\n\t\t//set HDR\n\t\tif (ds->hdr_type > DASHER_HDR_NONE) {\n\t\t\tchar value[256];\n\t\t\tGF_MPD_Descriptor* desc;\n\t\t\tsprintf(value, \"9\");\n\t\t\tdesc = gf_mpd_descriptor_new(NULL, \"urn:mpeg:mpegB:cicp:ColourPrimaries\", value);\n\t\t\tgf_list_add(set->essential_properties, desc);\n\t\t\tsprintf(value, \"9\");\n\t\t\tdesc = gf_mpd_descriptor_new(NULL, \"urn:mpeg:mpegB:cicp:MatrixCoefficients\", value);\n\t\t\tgf_list_add(set->essential_properties, desc);\n\n\t\t\tif (ds->hdr_type==DASHER_HDR_PQ10) {\n\t\t\t\tsprintf(value, \"16\");\n\t\t\t\tdesc = gf_mpd_descriptor_new(NULL, \"urn:mpeg:mpegB:cicp:TransferCharacteristics\", value);\n\t\t\t\tgf_list_add(set->essential_properties, desc);\n\t\t\t}\n\n\t\t\tif (ds->hdr_type == DASHER_HDR_HLG) {\n\t\t\t\tsprintf(value, \"14\");\n\t\t\t\tdesc = gf_mpd_descriptor_new(NULL, \"urn:mpeg:mpegB:cicp:TransferCharacteristics\", value);\n\t\t\t\tgf_list_add(set->essential_properties, desc);\n\t\t\t\tsprintf(value, \"18\");\n\t\t\t\tdesc = gf_mpd_descriptor_new(NULL, \"urn:mpeg:mpegB:cicp:TransferCharacteristics\", value);\n\t\t\t\tgf_list_add(set->supplemental_properties, desc);\n\t\t\t}\n\t\t}\n\t}\n\tif (ctx->check_main_role && !main_role_set) {\n\t\tGF_MPD_Descriptor *desc;\n\t\tdesc = gf_mpd_descriptor_new(NULL, \"urn:mpeg:dash:role:2011\", \"main\");\n\t\tgf_list_add(set->role, desc);\n\t}\n}\n\nstatic void rewrite_dep_ids(GF_DasherCtx *ctx, GF_DashStream *base_ds)\n{\n\tu32 i, count = gf_list_count(ctx->pids);\n\tfor (i=0; i<count; i++) {\n\t\tGF_DashStream *ds = gf_list_get(ctx->pids, i);\n\t\tif (ds->src_id != base_ds->src_id) continue;\n\t\tif (!ds->dep_id || !ds->rep) continue;\n\t\tif (ds->dep_id != base_ds->id) continue;\n\n\t\tds->tile_dep_id_merged = GF_TRUE;\n\t\tif (ds->rep->dependency_id) gf_free(ds->rep->dependency_id);\n\t\tds->rep->dependency_id = gf_strdup(base_ds->merged_tile_dep->rep->id);\n\t}\n}\n\nstatic void dasher_check_bitstream_swicthing(GF_DasherCtx *ctx, GF_MPD_AdaptationSet *set)\n{\n\tu32 i, j, count;\n\tBool use_inband = ((ctx->bs_switch==DASHER_BS_SWITCH_INBAND) || (ctx->bs_switch==DASHER_BS_SWITCH_INBAND_PPS) || (ctx->bs_switch==DASHER_BS_SWITCH_BOTH)) ? GF_TRUE : GF_FALSE;\n\tBool use_multi = (ctx->bs_switch==DASHER_BS_SWITCH_MULTI) ? GF_TRUE : GF_FALSE;\n\tGF_MPD_Representation *base_rep = gf_list_get(set->representations, 0);\n\tGF_DashStream *base_ds;\n\n\tswitch (ctx->muxtype) {\n\tcase DASHER_MUX_TS:\n\tcase DASHER_MUX_OGG:\n\tcase DASHER_MUX_RAW:\n\t\tset->bitstream_switching = GF_TRUE;\n\t\treturn;\n\t//other formats use an init segment\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (ctx->bs_switch==DASHER_BS_SWITCH_OFF) return;\n\tif (!base_rep) return;\n\tbase_ds = base_rep->playback.udta;\n\n\tcount = gf_list_count(set->representations);\n\tif (count==1) {\n\t\tif (ctx->bs_switch==DASHER_BS_SWITCH_FORCE) set->bitstream_switching=GF_TRUE;\n\t\telse if (use_inband) {\n\t\t\tbase_ds->inband_params = ctx->bs_switch==DASHER_BS_SWITCH_BOTH ? 3 : 1;\n\t\t\tif (base_ds->codec_id==GF_CODECID_VVC && ctx->bs_switch==DASHER_BS_SWITCH_INBAND_PPS)\n\t\t\t\tbase_ds->inband_params = 2;\n\t\t}\n\t\treturn;\n\t}\n\n\tfor (i=1; i<count; i++) {\n\t\tGF_MPD_Representation *rep = gf_list_get(set->representations, i);\n\t\tGF_DashStream *ds = rep->playback.udta;\n\t\t//same codec ID\n\t\tif (ds->codec_id == base_ds->codec_id) {\n\t\t\t//we will use inband params, so bs switching is OK\n\t\t\tif (use_inband || use_multi) continue;\n\t\t\t//we have deps, cannot use bitstream switching except for merged tile base\n\t\t\tif (ds->dep_id) {\n\t\t\t\tif (ds->codec_id==GF_CODECID_HEVC_TILES) {\n\t\t\t\t\tu32 id;\n\t\t\t\t\tGF_DashStream *tile_base = get_base_ds(ctx, ds);\n\t\t\t\t\tif (!tile_base) return;\n\t\t\t\t\tid = tile_base->merged_tile_dep ? tile_base->merged_tile_dep->id : tile_base->id;\n\t\t\t\t\tif (base_ds->dep_id==id) continue;\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t//we consider we can switch in non-inband only if we have same CRC for the decoder config\n\t\t\tif (base_ds->dsi_crc == ds->dsi_crc) continue;\n\t\t\t//not the same config, no BS switching\n\t\t\treturn;\n\t\t}\n\t\t//dependencies / different codec IDs, cannot use bitstream switching\n\t\treturn;\n\t}\n\t//ok we can use BS switching, ensure we use the same timescale for every stream\n\tset->bitstream_switching = GF_TRUE;\n\n\tfor (i=0; i<count; i++) {\n\t\tGF_MPD_Representation *rep = gf_list_get(set->representations, i);\n\t\tGF_DashStream *ds = rep->playback.udta;\n\t\tif (base_ds->tile_base && ds->tile_base && (base_ds != ds) ) {\n\t\t\tds->merged_tile_dep = base_ds;\n\t\t\tif (ds->rep) {\n\t\t\t\tgf_list_rem(set->representations, i);\n\t\t\t\ti--;\n\t\t\t\tcount--;\n\t\t\t\tgf_mpd_representation_free(ds->rep);\n\t\t\t\tds->rep = NULL;\n\t\t\t\t//switch dependencyID of all reps depending on this one to the new base\n\t\t\t\trewrite_dep_ids(ctx, ds);\n\t\t\t\t//and ignore this rep while flushing segments\n\t\t\t\tbase_ds->nb_rep--;\n\t\t\t}\n\t\t}\n\t\tfor (j=i+1; j<count; j++) {\n\t\t\tGF_DashStream *a_ds;\n\t\t\trep = gf_list_get(set->representations, j);\n\t\t\ta_ds = rep->playback.udta;\n\t\t\tif (a_ds->stream_type != ds->stream_type) continue;\n\t\t\tif (a_ds->timescale != ds->timescale)\n\t\t\t\ta_ds->force_timescale = ds->timescale;\n\t\t}\n\t}\n}\n\nGF_Err gf_cryptfout_push_key(GF_Filter *filter, bin128 *key, bin128 *IV);\n\nenum\n{\n\t//init segment valid\n\tDASH_INITSEG_PRESENT=0,\n\t//no init segment for given format\n\tDASH_INITSEG_NONE,\n\t//init segment for given format but skipped due to bitstream switching constraints\n\tDASH_INITSEG_SKIP\n};\n\nstatic void dasher_open_destination(GF_Filter *filter, GF_DasherCtx *ctx, GF_MPD_Representation *rep, const char *szInitURL, u32 trash_init)\n{\n\tGF_Err e;\n\tBool has_frag=GF_FALSE;\n\tBool has_subs=GF_FALSE;\n\tBool has_strun=GF_FALSE;\n\tBool has_vodcache=GF_FALSE;\n\tBool has_cmaf=GF_FALSE;\n\tBool has_psshs=GF_FALSE;\n\tconst GF_PropertyValue *p;\n\tchar sep_args = gf_filter_get_sep(filter, GF_FS_SEP_ARGS);\n\tchar sep_name = gf_filter_get_sep(filter, GF_FS_SEP_NAME);\n\tconst char *dst_args, *trailer_args=NULL, *dst_forced=NULL;\n\tchar *szDST = NULL;\n\tchar szSRC[100];\n\n\tif (ctx->sigfrag || ctx->gencues || ctx->do_index)\n\t\treturn;\n\n\tGF_DashStream *ds = rep->playback.udta;\n\tif (ds->muxed_base) return;\n\n\tswitch (ctx->from_index) {\n\tcase IDXMODE_MANIFEST:\n\tcase IDXMODE_CHILD:\n\t\tif (trash_init==DASH_INITSEG_NONE) return;\n\t\ttrash_init = DASH_INITSEG_SKIP;\n\t\tbreak;\n\tcase IDXMODE_ALL:\n\t\tif (trash_init==DASH_INITSEG_NONE) return;\n\t\tbreak;\n\tcase IDXMODE_INIT:\n\t\tif (trash_init==DASH_INITSEG_NONE) return;\n\t\tp = gf_filter_pid_get_property_str(ds->ipid, \"idx_out\");\n\t\tif (p) dst_forced = p->value.string;\n\t\tbreak;\n\t}\n\n\tctx->check_connections = GF_TRUE;\n\tif (dst_forced) {\n\t\tgf_dynstrcat(&szDST, dst_forced, NULL);\n\t\tszInitURL = dst_forced; //for logs\n\t}\n\telse if (ctx->out_path) {\n\t\tchar *rel = NULL;\n\t\tif (ctx->do_m3u8 && ds->hls_vp_name) {\n\t\t\tchar *tmp = gf_url_concatenate(ctx->out_path, ds->hls_vp_name);\n\t\t\tif (tmp) {\n\t\t\t\trel = gf_url_concatenate(tmp, szInitURL);\n\t\t\t\tgf_free(tmp);\n\t\t\t}\n\t\t}\n\t\tif (!rel)\n\t\t\trel = gf_url_concatenate(ctx->out_path, szInitURL);\n\t\tif (rel) {\n\t\t\tszDST = rel;\n\t\t}\n\t}\n\telse\n\t\tgf_dynstrcat(&szDST, szInitURL, NULL);\n\n\n\tif (ds->tci) {\n\t\tchar *tmp = szDST;\n\t\tszDST = NULL;\n\t\tgf_dynstrcat(&szDST, \"gcryp://\", NULL);\n\t\tgf_dynstrcat(&szDST, tmp, NULL);\n\t\tgf_free(tmp);\n\t}\n\n\tsprintf(szSRC, \"%cgfopt\", sep_args);\n\tgf_dynstrcat(&szDST, szSRC, NULL);\n\n\tdst_args = gf_filter_get_dst_args(filter);\n\tif (dst_args) {\n\t\tchar szKey[20], *sep;\n\t\tsprintf(szSRC, \"%c\", sep_args);\n\t\tgf_dynstrcat(&szDST, szSRC, NULL);\n\t\t\n\t\tgf_dynstrcat(&szDST, dst_args, NULL);\n\t\tsprintf(szKey, \"%c%c\", sep_args, sep_args);\n\t\tsep = strstr(szDST, szKey);\n\t\tif (sep) {\n\t\t\tsep[0] = 0;\n\t\t\ttrailer_args = strstr(dst_args, szKey);\n\t\t}\n\t\t//look for frag arg\n\t\tsprintf(szKey, \"%cfrag\", sep_args);\n\t\tif (strstr(dst_args, szKey)) has_frag = GF_TRUE;\n\t\telse {\n\t\t\tsprintf(szKey, \"%csfrag\", sep_args);\n\t\t\tif (strstr(dst_args, szKey)) has_frag = GF_TRUE;\n\t\t}\n\t\t//look for subs_sidx arg\n\t\tsprintf(szKey, \"%csubs_sidx\", sep_args);\n\t\tif (strstr(dst_args, szKey)) has_subs = GF_TRUE;\n\n\t\tsprintf(szKey, \"%cstrun\", sep_args);\n\t\tif (strstr(dst_args, szKey)) has_strun = GF_TRUE;\n\n\t\tsprintf(szKey, \"%cvodcache\", sep_args);\n\t\tif (strstr(dst_args, szKey)) has_vodcache = GF_TRUE;\n\n\t\tsprintf(szKey, \"%ccmaf\", sep_args);\n\t\tif (strstr(dst_args, szKey)) has_cmaf = GF_TRUE;\n\n\t\tsprintf(szKey, \"%cpsshs\", sep_args);\n\t\tif (strstr(dst_args, szKey)) has_psshs = GF_TRUE;\n\t}\n\tif ((ctx->from_index==IDXMODE_SEG) && !gf_sys_is_test_mode())\n\t\ttrash_init = DASH_INITSEG_SKIP;\n\n\tif (trash_init) {\n\t\tif (ds->rawmux)\n\t\t\tsprintf(szSRC, \"%cnoinitraw\", sep_args);\n\t\telse\n\t\t\tsprintf(szSRC, \"%cnoinit\", sep_args);\n\t\tgf_dynstrcat(&szDST, szSRC, NULL);\n\t}\n\tif (!has_frag) {\n\t\tsprintf(szSRC, \"%cfrag\", sep_args);\n\t\tgf_dynstrcat(&szDST, szSRC, NULL);\n\t}\n\tif (!ctx->forward_mode) {\n\t\tif (!has_subs && ctx->sseg) {\n\t\t\tsprintf(szSRC, \"%csubs_sidx%c0\", sep_args, sep_name);\n\t\t\tgf_dynstrcat(&szDST, szSRC, NULL);\n\t\t}\n\t\tif (ctx->cues && !has_strun) {\n\t\t\tsprintf(szSRC, \"%cstrun\", sep_args);\n\t\t\tgf_dynstrcat(&szDST, szSRC, NULL);\n\t\t}\n\t\tif (ctx->styp) {\n\t\t\tsprintf(szSRC, \"%cstyp=%s\", sep_args, ctx->styp);\n\t\t\tgf_dynstrcat(&szDST, szSRC, NULL);\n\t\t}\n\t}\n\n\t{\n\t\t//override xps inband declaration in args\n\t\tchar *xps_inband;\n\t\tswitch (ds->inband_params) {\n\t\tcase 1: xps_inband = \"all\"; break;\n\t\tcase 2: xps_inband = \"pps\"; break;\n\t\tcase 3: xps_inband = \"both\"; break;\n\t\tdefault: xps_inband = \"no\"; break;\n\t\t}\n\t\tsprintf(szSRC, \"%cxps_inband%c%s\", sep_args, sep_name, xps_inband);\n\t}\n\tgf_dynstrcat(&szDST, szSRC, NULL);\n\n\tif (ctx->no_fragments_defaults) {\n\t\tsprintf(szSRC, \"%cnofragdef\", sep_args );\n\t\tgf_dynstrcat(&szDST, szSRC, NULL);\n\t}\n\tif (!has_psshs) {\n\t\tswitch (ctx->pssh) {\n\t\tcase GF_DASH_PSSH_MPD:\n\t\tcase GF_DASH_PSSH_NONE:\n\t\t\tsprintf(szSRC, \"%cpsshs%cnone\", sep_args, sep_name);\n\t\t\tbreak;\n\t\tcase GF_DASH_PSSH_MOOF:\n\t\tcase GF_DASH_PSSH_MOOF_MPD:\n\t\t\tp = gf_filter_pid_get_property(ds->ipid, GF_PROP_PID_CENC_HAS_ROLL);\n\t\t\t//dual moov+moof only for dash\n\t\t\tif (!ctx->do_mpd) p = NULL;\n\t\t\tif (p && p->value.boolean) {\n\t\t\t\tsprintf(szSRC, \"%cpsshs%cboth\", sep_args, sep_name);\n\t\t\t} else {\n\t\t\t\tsprintf(szSRC, \"%cpsshs%cmoof\", sep_args, sep_name);\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tp = gf_filter_pid_get_property(ds->ipid, GF_PROP_PID_CENC_HAS_ROLL);\n\t\t\t//dual moov+moof only for dash\n\t\t\tif (!ctx->do_mpd) p = NULL;\n\t\t\tif (p && p->value.boolean) {\n\t\t\t\tsprintf(szSRC, \"%cpsshs%cboth\", sep_args, sep_name);\n\t\t\t} else {\n\t\t\t\tsprintf(szSRC, \"%cpsshs%cmoov\", sep_args, sep_name);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tgf_dynstrcat(&szDST, szSRC, NULL);\n\t}\n\n\t//patch for old arch: make sure we don't have any extra free box before the sidx\n\t//we could also use vodcache=insert but this might break http outputs\n\tif (gf_sys_old_arch_compat() && !has_vodcache && ctx->sseg) {\n\t\tsprintf(szSRC, \"%cvodcache%con\", sep_args, sep_name );\n\t\tif (!strstr(szDST, szSRC))\n\t\t\tgf_dynstrcat(&szDST, szSRC, NULL);\n\t}\n\n\t//we don't append mime in case of raw streams, raw format (writegen doesn't use mime types for raw media, only file ext)\n\tif (!ds->rawmux && ((ctx->muxtype!=DASHER_MUX_RAW) || (ds->codec_id != GF_CODECID_RAW)) ) {\n\t\tsprintf(szSRC, \"%cmime%c%s\", sep_args, sep_name, rep->mime_type);\n\t\tgf_dynstrcat(&szDST, szSRC, NULL);\n\t}\n\n\tif (ds->moof_sn>1) {\n\t\tsprintf(szSRC, \"%cmsn%c%d\", sep_args, sep_name, ds->moof_sn);\n\t\tgf_dynstrcat(&szDST, szSRC, NULL);\n\t}\n\tif (ds->moof_sn_inc>1) {\n\t\tsprintf(szSRC, \"%cmsninc%c%d\", sep_args, sep_name, ds->moof_sn_inc);\n\t\tgf_dynstrcat(&szDST, szSRC, NULL);\n\t}\n\tif (ds->sscale) {\n\t\tsprintf(szSRC, \"%cmoovts%c-1\", sep_args, sep_name);\n\t\tgf_dynstrcat(&szDST, szSRC, NULL);\n\t}\n\n\tif (!has_cmaf && ctx->cmaf) {\n\t\tsprintf(szSRC, \"%ccmaf%c%s\", sep_args, sep_name, (ctx->cmaf==DASHER_CMAF_CMF2) ? \"cmf2\" : \"cmfc\");\n\t\tgf_dynstrcat(&szDST, szSRC, NULL);\n\t}\n\n\n\tif (trailer_args)\n\t\tgf_dynstrcat(&szDST, trailer_args, NULL);\n\t\t\n\tds->dst_filter = gf_filter_connect_destination(filter, szDST, &e);\n\tgf_free(szDST);\n\tszDST = NULL;\n\tif (e) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_DASH, (\"[Dasher] Couldn't create output file %s: %s\\n\", szInitURL, gf_error_to_string(e) ));\n\t\tctx->in_error = GF_TRUE;\n\t\treturn;\n\t}\n\t//reset any sourceID given in the dst_arg and assign sourceID to be the dasher filter\n\tsprintf(szSRC, \"MuxSrc%cdasher_%p\", sep_name, ds->dst_filter);\n\tgf_filter_reset_source(ds->dst_filter);\n\tgf_filter_set_source(ds->dst_filter, filter, szSRC);\n\n\tif (ds->tci && !trash_init) {\n\t\t//push NULL key, we are not encrypting the init segment\n\t\tgf_cryptfout_push_key(ds->dst_filter, NULL, NULL);\n\t}\n}\n\nstatic void dasher_gather_deps(GF_DasherCtx *ctx, u32 dependency_id, GF_List *multi_tracks)\n{\n\tu32 i, count = gf_list_count(ctx->current_period->streams);\n\tfor (i=0; i<count; i++) {\n\t\tGF_DashStream *ds = gf_list_get(ctx->current_period->streams, i);\n\t\tif (ds->id == dependency_id) {\n\t\t\tif (ds->tile_base) continue;\n\n\t\t\tassert(ds->opid);\n\t\t\tgf_list_insert(multi_tracks, ds->opid, 0);\n\t\t\tif (ds->dep_id) dasher_gather_deps(ctx, ds->dep_id, multi_tracks);\n\t\t}\n\t}\n}\n\nstatic void dasher_update_dep_list(GF_DasherCtx *ctx, GF_DashStream *ds, const char *ref_type)\n{\n\tu32 i, j, count, base_id;\n\tGF_PropertyValue *p = (GF_PropertyValue *) gf_filter_pid_get_property_str(ds->opid, ref_type);\n\tif (!p) return;\n\tbase_id = ds->dep_id ? ds->dep_id : ds->id;\n\tcount = gf_list_count(ctx->current_period->streams);\n\tfor (i=0; i<p->value.uint_list.nb_items; i++) {\n\t\tfor (j=0; j<count; j++) {\n\t\t\tGF_DashStream *a_ds = gf_list_get(ctx->current_period->streams, j);\n\t\t\tif (a_ds->dep_id != base_id) continue;\n\t\t\tif ((a_ds->id == p->value.uint_list.vals[i]) && a_ds->pid_id) {\n\t\t\t\tp->value.uint_list.vals[i] = a_ds->pid_id;\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic void dasher_open_pid(GF_Filter *filter, GF_DasherCtx *ctx, GF_DashStream *ds, GF_List *multi_pids, Bool init_trashed)\n{\n\tGF_DashStream *base_ds = ds->muxed_base ? ds->muxed_base : ds;\n\tchar szSRC[1024];\n\n\tif (ctx->sigfrag || ctx->in_error || ctx->gencues || ctx->do_index)\n\t\treturn;\n\n\tswitch (ctx->from_index) {\n\tcase IDXMODE_MANIFEST:\n\tcase IDXMODE_CHILD:\n\tcase IDXMODE_ALL:\n\tcase IDXMODE_INIT:\n\t\tif (init_trashed) return;\n\t\tif (ds->muxed_base && !base_ds->dst_filter) return;\n\t\tbreak;\n\t}\n\n\tassert(!ds->opid);\n\tassert(base_ds->dst_filter);\n\n\tif (ds->tile_base && !init_trashed) {\n\t\ts32 res = gf_list_find(ctx->postponed_pids, ds);\n\t\tif (res < 0) {\n\t\t\tgf_list_add(ctx->postponed_pids, ds);\n\t\t\treturn;\n\t\t} else {\n\t\t\tgf_list_rem(ctx->postponed_pids, res);\n\t\t}\n\t} else if (!ds->tile_base) {\n\t\tgf_list_del_item(ctx->postponed_pids, ds);\n\t}\n\n\t//tile base not live profile, make sure all our deps are ready\n\tif (ds->tile_base && !ctx->sseg) {\n\t\tu32 i, count = gf_list_count(ds->complementary_streams);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tGF_DashStream *a_ds = gf_list_get(ds->complementary_streams, i);\n\t\t\t//dep not ready\n\t\t\tif (!a_ds->opid) {\n\t\t\t\tif (gf_list_find(ctx->postponed_pids, a_ds)<0) {\n\t\t\t\t\tgf_list_add(ctx->postponed_pids, a_ds);\n\t\t\t\t}\n\t\t\t\tgf_list_del_item(ctx->postponed_pids, ds);\n\t\t\t\tgf_list_add(ctx->postponed_pids, ds);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\tsprintf(szSRC, \"dasher_%p\", base_ds->dst_filter);\n\tds->opid = gf_filter_pid_new(filter);\n\n#ifdef GPAC_64_BITS\n\tds->hls_ref_id = (u64) ds->opid;\n#else\n\tds->hls_ref_id = (u64) ((u32) ds->opid);\n#endif\n\n\tgf_filter_pid_copy_properties(ds->opid, ds->ipid);\n\tif (!ds->muxed_base) {\n\t\tgf_filter_pid_set_property(ds->opid, GF_PROP_PID_FILE_EXT, &PROP_STRING(\"*\"));\n\t\tgf_filter_pid_set_property(ds->opid, GF_PROP_PID_MIME, &PROP_STRING(ds->rep->mime_type));\n\t}\n\tif (ds->nb_cues) {\n\t\tu32 ncues = ds->nb_cues;\n\t\tif ((ds->cues[0].sample_num>0) || (ds->cues[0].cts>0) || (ds->cues[0].dts>0))\n\t\t\tncues++;\n\t\tgf_filter_pid_set_property(ds->opid, GF_PROP_PID_DASH_SEGMENTS, &PROP_UINT(ncues) );\n\t}\n\t//for route out\n\tif (ctx->is_route) {\n\t\tif (ctx->do_m3u8)\n\t\t\tgf_filter_pid_set_property(ds->opid, GF_PROP_PCK_HLS_REF, &PROP_LONGUINT( ds->hls_ref_id ) );\n\n\t\tgf_filter_pid_set_property(ds->opid, GF_PROP_PID_REP_ID, &PROP_STRING( ds->rep->id ) );\n\n\n\t\tgf_filter_pid_set_property(ds->opid, GF_PROP_PID_DASH_DUR, &PROP_FRAC( ds->dash_dur ) );\n\t}\n\n\tgf_filter_pid_require_source_id(ds->opid);\n\n\tif (ctx->pssh == GF_DASH_PSSH_MPD) {\n\t\tgf_filter_pid_set_property(ds->opid, GF_PROP_PID_CENC_PSSH, NULL);\n\t}\n\t//multi-stsd disabled, remove sdsd template (only needed at init)\n\tif (ctx->pswitch != DASHER_PSWITCH_STSD) {\n\t\tgf_filter_pid_set_property(ds->opid, GF_PROP_PID_ISOM_STSD_ALL_TEMPLATES, NULL);\n\t}\n\n\t//force PID ID\n\tgf_filter_pid_set_property(ds->opid, GF_PROP_PID_ID, &PROP_UINT(ds->pid_id) );\n\tif (ds->dep_pid_id)\n\t\tgf_filter_pid_set_property(ds->opid, GF_PROP_PID_DEPENDENCY_ID, &PROP_UINT(ds->dep_pid_id) );\n\n\tif (ctx->from_index || ctx->state)\n\t\tgf_filter_pid_set_property(ds->opid, GF_PROP_PID_DASH_SPARSE, &PROP_BOOL(GF_TRUE) );\n\n\tgf_filter_pid_set_property(ds->opid, GF_PROP_PID_MUX_SRC, &PROP_STRING(szSRC) );\n\tgf_filter_pid_set_property(ds->opid, GF_PROP_PID_DASH_MODE, &PROP_UINT(ctx->sseg ? 2 : 1) );\n\tgf_filter_pid_set_property(ds->opid, GF_PROP_PID_DASH_DUR, &PROP_FRAC(ds->dash_dur) );\n\tswitch (ctx->seg_sync) {\n\tcase DASHER_SEGSYNC_AUTO:\n\t\t//if not HLS or test mode, don't wait for seg sync\n\t\tif (!ctx->do_m3u8 || gf_sys_is_test_mode()) break;\n\t\t//fallthrough\n\tcase DASHER_SEGSYNC_YES:\n\t\tgf_filter_pid_set_property(ds->opid, GF_PROP_PID_FORCE_SEG_SYNC, &PROP_BOOL(GF_TRUE) );\n\t\tbreak;\n\tcase DASHER_SEGSYNC_NO:\n\t\tbreak;\n\t}\n\n\tif (init_trashed)\n\t\tgf_filter_pid_set_property(ds->opid, GF_PROP_PID_NO_INIT, &PROP_BOOL(GF_TRUE));\n\t//for routeout\n\tgf_filter_pid_set_property(ds->opid, GF_PROP_PID_PREMUX_STREAM_TYPE, &PROP_UINT(ds->stream_type) );\n\n\tif (ds->id != ds->pid_id) {\n\t\tdasher_update_dep_list(ctx, ds, \"isom:scal\");\n\t\tdasher_update_dep_list(ctx, ds, \"isom:sabt\");\n\t}\n\n\t/*timescale forced (bitstream switching) */\n\tif (ds->force_timescale)\n\t\tgf_filter_pid_set_property(ds->opid, GF_PROP_PID_TIMESCALE, &PROP_UINT(ds->force_timescale) );\n\n\tif (ds->rep && ds->rep->segment_template)\n\t\tgf_filter_pid_set_property(ds->opid, GF_PROP_PID_TEMPLATE, &PROP_STRING(ds->rep->segment_template->media));\n\telse if (ds->set && ds->set->segment_template)\n\t\tgf_filter_pid_set_property(ds->opid, GF_PROP_PID_TEMPLATE, &PROP_STRING(ds->set->segment_template->media));\n\n\tgf_filter_pid_set_property(ds->opid, GF_PROP_PID_BITRATE, &PROP_UINT(ds->bitrate));\n\tgf_filter_pid_set_property(ds->opid, GF_PROP_PCK_FILENAME, &PROP_STRING(ds->init_seg));\n\n\tif (ds->rep && ds->rep->codecs)\n\t\tgf_filter_pid_set_property(ds->opid, GF_PROP_PID_CODEC, &PROP_STRING(ds->rep->codecs));\n\n\n\tif (multi_pids) {\n\t\ts32 idx = 1+gf_list_find(multi_pids, ds->ipid);\n\t\tassert(idx>0);\n\t\tgf_filter_pid_set_property(ds->opid, GF_PROP_PID_DASH_MULTI_PID, &PROP_POINTER(multi_pids) );\n\t\tgf_filter_pid_set_property(ds->opid, GF_PROP_PID_DASH_MULTI_PID_IDX, &PROP_UINT(idx) );\n\t}\n\n\n\tif (ds->tile_base && !ctx->sseg && !ctx->sfile) {\n\t\tu32 i, count = gf_list_count(ds->complementary_streams);\n\t\tif (!ds->multi_tracks) ds->multi_tracks = gf_list_new();\n\t\tgf_list_reset(ds->multi_tracks);\n\n\t\t//gather all streams depending on our base\n\t\tfor (i=0; i<count; i++) {\n\t\t\tGF_DashStream *a_ds = gf_list_get(ds->complementary_streams, i);\n\t\t\tassert(a_ds->opid);\n\t\t\tgf_list_add(ds->multi_tracks, a_ds->opid);\n\t\t}\n\t\tgf_filter_pid_set_property(ds->opid, GF_PROP_PID_DASH_MULTI_TRACK, &PROP_POINTER(ds->multi_tracks) );\n\t}\n\tif (ds->dep_id && !init_trashed) {\n\t\tif (!ds->multi_tracks) ds->multi_tracks = gf_list_new();\n\t\tgf_list_reset(ds->multi_tracks);\n\t\tdasher_gather_deps(ctx, ds->dep_id, ds->multi_tracks);\n\t\tif (gf_list_count(ds->multi_tracks)) {\n\t\t\tgf_filter_pid_set_property(ds->opid, GF_PROP_PID_DASH_MULTI_TRACK, &PROP_POINTER(ds->multi_tracks) );\n\t\t} else {\n\t\t\tgf_list_del(ds->multi_tracks);\n\t\t\tds->multi_tracks = NULL;\n\t\t}\n\t}\n\n\tif (ctx->llhls) {\n\t\tgf_filter_pid_set_property(ds->opid, GF_PROP_PID_LLHLS, &PROP_UINT(ctx->llhls) );\n\t}\n\n\tif ((ctx->dmode > GF_DASH_STATIC) && (ctx->tsb>=0)) {\n\t\tu32 tsb_seg = ds->dash_dur.num ? ((u32) (ctx->tsb * ds->dash_dur.den / ds->dash_dur.num)) : 0;\n\t\ttsb_seg++;\n\t\tgf_filter_pid_set_property(ds->opid, GF_PROP_PID_TIMESHIFT_SEGS, &PROP_UINT(tsb_seg) );\n\t} else {\n\t\tgf_filter_pid_set_property(ds->opid, GF_PROP_PID_TIMESHIFT_SEGS, NULL);\n\t}\n}\n\nstatic void dasher_set_content_components(GF_DashStream *ds)\n{\n\tGF_MPD_ContentComponent *component;\n\tGF_DashStream *base_ds = ds->muxed_base ? ds->muxed_base : ds;\n\tu32 i=0;\n\twhile ((component = gf_list_enum(base_ds->set->content_component, &i))) {\n\t\tif (component->id == ds->pid_id) return;\n\t}\n\n\tGF_SAFEALLOC(component, GF_MPD_ContentComponent);\n\tif (!component) return;\n\n\tcomponent->id = ds->pid_id;\n\tswitch (ds->stream_type) {\n\tcase GF_STREAM_TEXT:\n\t\tcomponent->type = gf_strdup(\"text\");\n\t\tbreak;\n\tcase GF_STREAM_VISUAL:\n\t\tcomponent->type = gf_strdup(\"video\");\n\t\tbreak;\n\tcase GF_STREAM_AUDIO:\n\t\tcomponent->type = gf_strdup(\"audio\");\n\t\tbreak;\n\tcase GF_STREAM_SCENE:\n\tcase GF_STREAM_OD:\n\tdefault:\n\t\tcomponent->type = gf_strdup(\"application\");\n\t\tbreak;\n\t}\n\t/*if lang not specified at adaptationSet level, put it here*/\n\tif (!base_ds->set->lang && ds->lang && strcmp(ds->lang, \"und\")) {\n\t\tcomponent->lang = gf_strdup(ds->lang);\n\t}\n\tgf_list_add(base_ds->set->content_component, component);\n}\n\ntypedef struct\n{\n\t//this is not the template string, this is the resolved segment name for first segment, startNumber=0 and time=0\n\tchar *tpl;\n\tu32 nb_reused;\n} DashTemplateRecord;\n\nstatic u32 dasher_check_template_reuse(GF_DasherCtx *ctx, const char *tpl)\n{\n\tDashTemplateRecord *tr;\n\tu32 i, count = gf_list_count(ctx->tpl_records);\n\tfor (i=0; i<count; i++) {\n\t\ttr = gf_list_get(ctx->tpl_records, i);\n\t\tif (!strcmp(tr->tpl, tpl)) {\n\t\t\ttr->nb_reused++;\n\t\t\treturn tr->nb_reused;\n\t\t}\n\t}\n\tGF_SAFEALLOC(tr, DashTemplateRecord)\n\ttr->tpl = gf_strdup(tpl);\n\tgf_list_add(ctx->tpl_records, tr);\n\treturn 0;\n}\n\nstatic void dasher_setup_sources(GF_Filter *filter, GF_DasherCtx *ctx, GF_MPD_AdaptationSet *set)\n{\n\tchar szDASHTemplate[GF_MAX_PATH];\n\tchar szTemplate[GF_MAX_PATH];\n\tchar szSegmentName[GF_MAX_PATH];\n\tchar szInitSegmentTemplate[GF_MAX_PATH];\n\tchar szInitSegmentFilename[GF_MAX_PATH];\n\tchar szIndexSegmentName[GF_MAX_PATH];\n\tchar szSetFileSuffix[200], szDASHSuffix[220];\n\tconst char *template = NULL;\n\tu32 as_id = 0;\n\tBool single_template = GF_TRUE;\n\tu32 i, j, count, nb_base, nb_streams;\n\tGF_List *multi_pids = NULL;\n\tu32 set_timescale = 0;\n\tBool init_template_done=GF_FALSE;\n\tBool use_inband = ((ctx->bs_switch==DASHER_BS_SWITCH_INBAND) || (ctx->bs_switch==DASHER_BS_SWITCH_INBAND_PPS) || (ctx->bs_switch==DASHER_BS_SWITCH_BOTH)) ? GF_TRUE : GF_FALSE;\n\tBool template_use_source = GF_FALSE;\n\tBool split_rep_names = GF_FALSE;\n\tBool split_set_names = GF_FALSE;\n\tu32 force_ds_id;\n\tGF_DashStream *ds;\n\tGF_MPD_Representation *rep = gf_list_get(set->representations, 0);\n\tif (!rep) {\n\t\tassert(0);\n\t\treturn;\n\t}\n\tds = rep->playback.udta;\n\n\tcount = gf_list_count(set->representations);\n\n\tif (!ctx->sigfrag) {\n\t\tassert(ctx->template);\n\t\ttemplate = ((GF_DashStream *)set->udta)->template;\n\t}\n\n\tfor (i=0; i<count; i++) {\n\t\trep = gf_list_get(set->representations, i);\n\t\tds = rep->playback.udta;\n\t\tif (!ds->template && !template) {}\n\t\telse if (ds->template && template && !strcmp(ds->template, template) ) {\n\t\t} else {\n\t\t\tsingle_template = GF_FALSE;\n\t\t}\n\t\tif (ds->template) template_use_source = dasher_template_use_source_url(ds->template);\n\n\t\tif (template_use_source) {\n\t\t\tsingle_template = GF_FALSE;\n\t\t}\n\n\t\tif (ds->as_id && !as_id)\n\t\t\tas_id = ds->as_id;\n\n\t\tif (ds->fps.den && ( (ds->fps.num*set->max_framerate.den) >= (s32) (set->max_framerate.num*ds->fps.den) )) {\n\t\t\tset->max_framerate.num = ds->fps.num;\n\t\t\tset->max_framerate.den = ds->fps.den;\n\t\t\tgf_media_get_reduced_frame_rate(&set->max_framerate.num, &set->max_framerate.den);\n\t\t}\n\t\tif (ds->width && ds->height) {\n\t\t\tif (!set->par) {\n\t\t\t\tGF_SAFEALLOC(set->par, GF_MPD_Fractional);\n\t\t\t}\n\t\t\tif (set->par) {\n\t\t\t\tset->par->num = ds->width * ds->sar.num;\n\t\t\t\tset->par->den = ds->height * ds->sar.den;\n\t\t\t\tgf_media_reduce_aspect_ratio(&set->par->num, &set->par->den);\n\t\t\t}\n\t\t}\n\t}\n\tif (!template) template = ctx->template;\n\n\tif (as_id) {\n\t\tset->id = ds->as_id;\n\t}\n\tif (ctx->sseg) {\n\t\tset->segment_alignment = GF_TRUE;\n\t\tset->starts_with_sap = 1;\n\t}\n\n\tif (count==1)\n\t\tsingle_template = GF_TRUE;\n\telse if (single_template) {\n\t\t//for regular reps, if we depend on filename we cannot mutualize the template\n\t\tif (dasher_template_use_source_url(template) ) {\n\t\t\tsingle_template = GF_FALSE;\n\t\t}\n\t\t//and for scalable reps, if we don't have bandwidth /repID we cannot mutualize the template\n\t\telse if (gf_list_count(ds->complementary_streams) ) {\n\t\t\tif (strstr(template, \"$Bandwidth$\") != NULL) single_template = GF_FALSE;\n\t\t\telse if (strstr(template, \"$RepresentationId$\") != NULL) single_template = GF_FALSE;\n\t\t}\n\t}\n\n\tif (set->lang) gf_free(set->lang);\n\tset->lang = gf_strdup(ds->lang ? ds->lang : \"und\");\n\n\t//check all streams in active period not in this set\n\tforce_ds_id = ds->id;\n\tnb_streams = gf_list_count(ctx->current_period->streams);\n\tfor (i=0; i<nb_streams; i++) {\n\t\tchar *frag_uri;\n\t\tu32 len1, len2;\n\t\tGF_DashStream *ads = gf_list_get(ctx->current_period->streams, i);\n\n\t\tif (force_ds_id && (ads != ds) && (ads->id == ds->id)) {\n\t\t\tforce_ds_id = 0;\n\t\t}\n\n\t\tif (ads->set == set) continue;\n\t\tfrag_uri = strrchr(ds->src_url, '#');\n\t\tif (frag_uri) len1 = (u32) (frag_uri-1 - ds->src_url);\n\t\telse len1 = (u32) strlen(ds->src_url);\n\t\tfrag_uri = strrchr(ads->src_url, '#');\n\t\tif (frag_uri) len2 = (u32) (frag_uri-1 - ads->src_url);\n\t\telse len2 = (u32) strlen(ads->src_url);\n\n\t\tif ((len1==len2) && !strncmp(ds->src_url, ads->src_url, len1)) {\n\t\t\tsplit_set_names = GF_TRUE;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (ctx->timescale>0) {\n\t\tset_timescale = ctx->timescale;\n\t} else {\n\t\tu32 first_timescale;\n\t\trep = gf_list_get(set->representations, 0);\n\t\tds = rep->playback.udta;\n\t\tfirst_timescale = ds->timescale;\n\t\tfor (i=1; i<count; i++) {\n\t\t\trep = gf_list_get(set->representations, i);\n\t\t\tds = rep->playback.udta;\n\t\t\tif (ds->timescale != first_timescale) {\n\t\t\t\t//we cannot use a single template if enforcing timescales which are not identical\n\t\t\t\tsingle_template = GF_FALSE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (i=0; i<count; i++) {\n\t\tif (ctx->sigfrag)\n\t\t\tbreak;\n\n\t\trep = gf_list_get(set->representations, i);\n\t\tds = rep->playback.udta;\n\n\t\tif (!dasher_template_use_source_url(template))\n\t\t\tcontinue;\n\n\t\tif (ds->muxed_base)\n\t\t\tcontinue;\n\n\t\tfor (j=i+1; j<count; j++) {\n\t\t\tconst GF_PropertyValue *p1, *p2;\n\t\t\tGF_DashStream *a_ds;\n\t\t\trep = gf_list_get(set->representations, j);\n\t\t\ta_ds = rep->playback.udta;\n\n\t\t\tif (a_ds->muxed_base == ds)\n\t\t\t\tcontinue;\n\n\t\t\tp1 = gf_filter_pid_get_property(ds->ipid, GF_PROP_PID_FILEPATH);\n\t\t\tp2 = gf_filter_pid_get_property(a_ds->ipid, GF_PROP_PID_FILEPATH);\n\t\t\tif (p1 && p2 && gf_props_equal(p1, p2)) split_rep_names = GF_TRUE;\n\t\t\telse if (!p1 && !p2) split_rep_names = GF_TRUE;\n\t\t\tp1 = gf_filter_pid_get_property(ds->ipid, GF_PROP_PID_URL);\n\t\t\tp2 = gf_filter_pid_get_property(a_ds->ipid, GF_PROP_PID_URL);\n\t\t\tif (p1 && p2 && gf_props_equal(p1, p2)) split_rep_names = GF_TRUE;\n\t\t\telse if (!p1 && !p2) split_rep_names = GF_TRUE;\n\n\t\t\tif (split_rep_names) break;\n\t\t}\n\t\tif (split_rep_names) break;\n\t}\n\n\tif (split_set_names) {\n\t\tif (!force_ds_id) {\n\t\t\tif (split_rep_names || !ds->split_set_names)\n\t\t\t\tforce_ds_id = ds->id;\n\t\t\telse\n\t\t\t\tforce_ds_id = gf_list_find(ctx->pids, ds) + 1;\n\t\t}\n\t\tsprintf(szSetFileSuffix, \"_track%d_\", force_ds_id);\n\t}\n\n\t//assign PID IDs - we assume only one component of a given media type per adaptation set\n\t//and assign the same PID ID for each component of the same type\n\t//we could refine this using roles, but most HAS solutions don't use roles at the mulitplexed level\n\tfor (i=0; i<count; i++) {\n\t\tBool is_bs_switching;\n\t\trep = gf_list_get(set->representations, i);\n\t\tds = rep->playback.udta;\n\t\tif (ds->pid_id) continue;\n\t\t//in bitstream switching mode, ensure each track in the set has the same ID\n\t\t//except when tile merge is used\n\t\tis_bs_switching = ds->tile_dep_id_merged ? GF_FALSE : set->bitstream_switching;\n\t\tif (is_bs_switching) {\n\t\t\tctx->next_pid_id_in_period++;\n\t\t\t//except for base tile track where we force using input PID ID\n\t\t\t//to avoid messing up sabt/tbas references\n\t\t\tif (ds->tile_base) {\n\t\t\t\tds->pid_id = ds->id;\n\t\t\t\tif (ctx->next_pid_id_in_period <= ds->pid_id)\n\t\t\t\t\tctx->next_pid_id_in_period = ds->pid_id;\n\t\t\t} else {\n\t\t\t\tds->pid_id = ctx->next_pid_id_in_period;\n\t\t\t}\n\n\t\t\tfor (j=i+1; j<count; j++) {\n\t\t\t\tGF_DashStream *a_ds;\n\t\t\t\trep = gf_list_get(set->representations, j);\n\t\t\t\ta_ds = rep->playback.udta;\n\t\t\t\tif (a_ds->pid_id) continue;\n\t\t\t\tif (a_ds->dep_id) continue;\n\t\t\t\tif (a_ds->stream_type == ds->stream_type) a_ds->pid_id = ds->pid_id;\n\t\t\t}\n\t\t}\n\t\t//otherwise copy over the source PID\n\t\telse {\n\t\t\tds->pid_id = ds->id;\n\t\t}\n\t}\n\n\tfor (i=0; i<count; i++) {\n\t\trep = gf_list_get(set->representations, i);\n\t\tds = rep->playback.udta;\n\t\tif (!ds->dep_id) continue;\n\n\t\tfor (j=i+1; j<count; j++) {\n\t\t\tGF_DashStream *a_ds;\n\t\t\trep = gf_list_get(set->representations, j);\n\t\t\ta_ds = rep->playback.udta;\n\t\t\tif (ds->dep_id == a_ds->id) {\n\t\t\t\tds->dep_pid_id = a_ds->pid_id;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t//this is crude because we don't copy the properties, we just pass a list of pids to the destination muxer !!\n\t//we should cleanup one of these days\n\tif (set->bitstream_switching && (ctx->bs_switch==DASHER_BS_SWITCH_MULTI)) {\n\t\tmulti_pids = gf_list_new();\n\t\tfor (i=0; i<count; i++) {\n\t\t\trep = gf_list_get(set->representations, i);\n\t\t\tds = rep->playback.udta;\n\t\t\tif (ds->owns_set) ds->multi_pids = multi_pids;\n\t\t\tgf_list_add(multi_pids, ds->ipid);\n\t\t}\n\t}\n\n\tif (ctx->cp!=GF_DASH_CPMODE_REPRESENTATION) {\n\t\tgf_mpd_del_list(set->content_protection, gf_mpd_descriptor_free, 0);\n\t\tset->content_protection = dasher_get_content_protection_desc(ctx, NULL, set);\n\t}\n\n\tfor (i=0; i<count; i++) {\n\t\tGF_Err e;\n\t\tchar szRawExt[20];\n\t\tBool use_dash_suffix = GF_FALSE;\n\t\tBool is_source_template = GF_FALSE;\n\t\tconst char *seg_ext, *init_ext, *idx_ext, *force_init_seg_tpl;\n#if 0\n\t\tGF_MPD_URL *force_init_seg_sl;\n#endif\n\t\tu32 skip_init_type = DASH_INITSEG_PRESENT;\n\t\tGF_DashStream *tile_base_ds = NULL;\n\t\tBool is_bs_switch;\n\t\tu32 reused_template_idx;\n\t\tu32 init_template_mode = GF_DASH_TEMPLATE_INITIALIZATION_TEMPLATE;\n\t\trep = gf_list_get(set->representations, i);\n\t\tds = rep->playback.udta;\n\n\t\t//remove representations for streams muxed with others, but still open the output\n\t\tif (ds->muxed_base) {\n\t\t\tGF_DashStream *ds_set = set->udta;\n\t\t\tgf_list_rem(set->representations, i);\n\t\t\ti--;\n\t\t\tcount--;\n\t\t\tassert(ds_set->nb_rep);\n\t\t\tds_set->nb_rep--;\n\t\t\tassert(ctx->sigfrag || ds->muxed_base->dst_filter || ctx->from_index);\n\t\t\tgf_list_transfer(ds->muxed_base->rep->audio_channels, rep->audio_channels);\n\t\t\tgf_list_transfer(ds->muxed_base->rep->base_URLs, rep->base_URLs);\n\t\t\tgf_list_transfer(ds->muxed_base->rep->content_protection , rep->content_protection);\n\t\t\tgf_list_transfer(ds->muxed_base->rep->essential_properties , rep->essential_properties);\n\t\t\tgf_list_transfer(ds->muxed_base->rep->frame_packing , rep->frame_packing);\n\t\t\tif (rep->x_children) {\n\t\t\t\tif (!ds->muxed_base->rep->x_children) ds->muxed_base->rep->x_children = gf_list_new();\n\t\t\t\tgf_list_transfer(ds->muxed_base->rep->x_children, rep->x_children);\n\t\t\t}\n\t\t\tgf_list_transfer(ds->muxed_base->rep->supplemental_properties , rep->supplemental_properties);\n\n\t\t\tgf_mpd_representation_free(ds->rep);\n\t\t\tds->rep = NULL;\n\n\t\t\tif (!gf_list_count(ds->set->content_component)) {\n\t\t\t\tdasher_set_content_components(ds->muxed_base);\n\t\t\t}\n\t\t\tdasher_set_content_components(ds);\n\t\t\tassert(!multi_pids);\n\t\t\t//open PID\n\t\t\tdasher_open_pid(filter, ctx, ds, NULL, GF_FALSE);\n\t\t\tcontinue;\n\t\t}\n\t\tif (ds->template) {\n\t\t\tstrcpy(szTemplate, ds->template);\n\t\t\tif (ctx->sigfrag) {\n\t\t\t\tconst GF_PropertyValue *p = gf_filter_pid_get_property_str(ds->ipid, \"source_template\");\n\t\t\t\tif (p && p->value.boolean)\n\t\t\t\t\tis_source_template = GF_TRUE;\n\t\t\t}\n\t\t} else {\n\t\t\tstrcpy(szTemplate, ctx->template ? ctx->template : \"\");\n\t\t}\n\n\t\tif (use_inband) {\n\t\t\tds->inband_params = ctx->bs_switch==DASHER_BS_SWITCH_BOTH ? 3 : 1;\n\t\t\tif ((ds->codec_id==GF_CODECID_VVC) && (ctx->bs_switch==DASHER_BS_SWITCH_INBAND_PPS))\n\t\t\t\tds->inband_params = 2;\n\t\t}\n\n\t\t//if bitstream switching and templating, only set for the first one\n\t\tif (i && set->bitstream_switching && ds->stl && single_template) continue;\n\n\t\tif (!set_timescale) set_timescale = ds->timescale;\n\n\t\tif (ctx->timescale<0) ds->mpd_timescale = ds->timescale;\n\t\telse ds->mpd_timescale = set_timescale;\n\n\t\tif (ctx->sigfrag && gf_filter_pid_get_property_str(ds->ipid, \"source_template\")) {\n\t\t\tconst GF_PropertyValue *p = gf_filter_pid_get_property_str(ds->ipid, \"stl_timescale\");\n\t\t\tif (p && p->value.uint) {\n\t\t\t\tds->mpd_timescale = p->value.uint;\n\t\t\t}\n\t\t}\n\n\t\tif (ds->nb_repeat && !ctx->loop) {\n\t\t\tif (split_set_names) {\n\t\t\t\tsprintf(szDASHSuffix, \"%sp%d_\", szSetFileSuffix, ds->nb_repeat+1);\n\t\t\t} else {\n\t\t\t\tsprintf(szDASHSuffix, \"p%d_\", ds->nb_repeat);\n\t\t\t}\n\t\t\tuse_dash_suffix = GF_TRUE;\n\t\t} else if (split_set_names) {\n\t\t\tstrcpy(szDASHSuffix, szSetFileSuffix);\n\t\t\tuse_dash_suffix = GF_TRUE;\n\t\t}\n\t\t//we need dash suffix in template, but the template may be user-provided without dash suffix. If so add it\n\t\t//we don't add suffic if we have $RepresentationID or $Path set, we assume the user knows what he's doing\n\t\tif (!ctx->tpl_force && use_dash_suffix && !strstr(szTemplate, \"$FS$\") && !strstr(szTemplate, \"$RepresentationID$\") && !strstr(szTemplate, \"$Path=\")) {\n\t\t\tstrcat(szTemplate, \"$FS$\");\n\t\t}\n\n\t\t//resolve segment template\n\t\te = gf_filter_pid_resolve_file_template(ds->ipid, szTemplate, szDASHTemplate, 0, use_dash_suffix ? szDASHSuffix : NULL);\n\t\tif (e) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_DASH, (\"[Dasher] Cannot resolve template name %s, cannot derive output segment names, disabling rep %s\\n\", szTemplate, ds->src_url));\n\t\t\tgf_filter_pid_set_discard(ds->ipid, GF_TRUE);\n\t\t\tds->done = 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!ctx->tpl_force) {\n\t\t\tif (single_template && ds->split_set_names && !use_dash_suffix) {\n\t\t\t\tchar szStrName[20];\n\t\t\t\tsprintf(szStrName, \"_set%d\", 1 + gf_list_find(ctx->current_period->period->adaptation_sets, set)  );\n\t\t\t\tstrcat(szDASHTemplate, szStrName);\n\t\t\t}\n\t\t\telse if (split_rep_names) {\n\t\t\t\tchar szStrName[20];\n\t\t\t\tsprintf(szStrName, \"_rep%d\", 1 + gf_list_find(set->representations, ds->rep)  );\n\t\t\t\tstrcat(szDASHTemplate, szStrName);\n\t\t\t}\n\t\t}\n\n\t\tds->rawmux = GF_FALSE;\n\t\tidx_ext = NULL;\n\n\n\t\tconst char *def_ext = NULL;\n\t\tseg_ext = init_ext = NULL;\n\n\t\tif (ctx->muxtype==DASHER_MUX_TS) {\n\t\t\tdef_ext = seg_ext = init_ext = \"ts\";\n\t\t\tif (!ctx->do_m3u8 && (ctx->subs_sidx>=0) )\n\t\t\t\tidx_ext = \"idx\";\n\t\t}\n\t\telse if (ctx->muxtype==DASHER_MUX_MKV) def_ext = \"mkv\";\n\t\telse if (ctx->muxtype==DASHER_MUX_WEBM) def_ext = \"webm\";\n\t\telse if (ctx->muxtype==DASHER_MUX_OGG) def_ext = \"ogg\";\n\t\telse if (ctx->muxtype==DASHER_MUX_RAW) {\n\t\t\tchar *ext = (char *) gf_codecid_file_ext(ds->codec_id);\n\t\t\tif (ds->codec_id==GF_CODECID_RAW) {\n\t\t\t\tconst GF_PropertyValue *p;\n\t\t\t\tif (ds->stream_type==GF_STREAM_VISUAL) {\n\t\t\t\t\tp = gf_filter_pid_get_property(ds->ipid, GF_PROP_PIXFMT);\n\t\t\t\t\tif (p) ext = (char *) gf_pixel_fmt_sname(p->value.uint);\n\t\t\t\t}\n\t\t\t\telse if (ds->stream_type==GF_STREAM_AUDIO) {\n\t\t\t\t\tp = gf_filter_pid_get_property(ds->ipid, GF_PROP_PID_AUDIO_FORMAT);\n\t\t\t\t\tif (p) ext = (char *) gf_audio_fmt_sname(p->value.uint);\n\t\t\t\t}\n\t\t\t}\n\t\t\tstrncpy(szRawExt, ext ? ext : \"raw\", 19);\n\t\t\tszRawExt[19] = 0;\n\t\t\text = strchr(szRawExt, '|');\n\t\t\tif (ext) ext[0] = 0;\n\t\t\tdef_ext = szRawExt;\n\t\t}\n\n\t\tif (!ds->muxed_base && ctx->rawsub && (ds->stream_type==GF_STREAM_TEXT) ) {\n\t\t\tchar *ext_sub = (char *) gf_codecid_file_ext(ds->codec_id);\n\t\t\tif (ext_sub) {\n\t\t\t\tif (!strcmp(ext_sub, \"subx\"))\n\t\t\t\t\text_sub = \"ttml\";\n\t\t\t\tif (!strcmp(ext_sub, \"tx3g\"))\n\t\t\t\t\text_sub = \"srt\";\n\n\t\t\t\tstrncpy(szRawExt, ext_sub, 19);\n\t\t\t\tszRawExt[19] = 0;\n\t\t\t\text_sub = strchr(szRawExt, '|');\n\t\t\t\tif (ext_sub) ext_sub[0] = 0;\n\t\t\t\tdef_ext = szRawExt;\n\t\t\t\tskip_init_type = DASH_INITSEG_NONE;\n\t\t\t\tds->rawmux = GF_TRUE;\n\n\t\t\t\tif (ds->rep->mime_type) gf_free(ds->rep->mime_type);\n\t\t\t\tconst char *mime = gf_codecid_mime(ds->codec_id);\n\t\t\t\tif (!mime) mime = \"text/plain\";\n\t\t\t\tds->rep->mime_type = gf_strdup(mime);\n\n\t\t\t\tif (ds->rep->codecs) {\n\t\t\t\t\tgf_free(ds->rep->codecs);\n\t\t\t\t\tds->rep->codecs = NULL;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (ctx->segext && !stricmp(ctx->segext, \"null\")) {\n\t\t\tseg_ext = NULL;\n\t\t} else {\n\t\t\tseg_ext = ctx->segext;\n\t\t\tif (!seg_ext) seg_ext = def_ext ? def_ext : \"m4s\";\n\t\t}\n\t\tif (ctx->initext && !stricmp(ctx->initext, \"null\")) {\n\t\t\tinit_ext = NULL;\n\t\t} else {\n\t\t\tinit_ext = ctx->initext;\n\t\t\tif (!init_ext) init_ext = def_ext ? def_ext : \"mp4\";\n\t\t}\n\n\t\t//source template is used, do not use any extensions, they are present in the template\n\t\tif (is_source_template) {\n\t\t\tdef_ext = NULL;\n\t\t\tinit_ext = NULL;\n\t\t\tseg_ext = NULL;\n\t\t}\n\n\t\tis_bs_switch = set->bitstream_switching;\n\t\t//only used to force _init in default templates\n\t\tif (ds->tile_base) is_bs_switch = GF_FALSE;\n\n\n\t\t//check we are not reusing an existing template from previous periods, if so append a suffix\n\t\t//we check the final init name\n\t\tif (!ds->skip_tpl_reuse) {\n\t\t\t//1- init will not work in tiling as the base track and the first rep could end up having the same\n\t\t\t//segment template since base uses \"init\" while tile tracks don't for the init template\n\t\t\t//2- because of that, all evaluated templates must be the segment ones, otherwise we may check the audio init template\n\t\t\t//against a tile segment template, which will not match even though they use the same base template...\n\t\t\t//ex: template: seg_ => seg_trackN_init.mp4 for non-tiled vs seg_trackN_$number$.m4s for tiled, resulting in same N\n\t\t\t//being used for 2 track\n\t\t\t//cf issue 1849\n\t\t\t//we however don't want to change templates if they are indeed reused but resolve to something different due to representationID\n\t\t\t//we therefore resolve the segment template with startNumber 0 time 0, use this resolved name as base check.\n\n\t\t\tgf_media_mpd_format_segment_name(GF_DASH_TEMPLATE_SEGMENT, is_bs_switch, szInitSegmentFilename, ds->rep_id, NULL, szDASHTemplate, is_source_template ? NULL : \"mp4\", 0, ds->bitrate, 0, ds->stl, ctx->tpl_force);\n\n\t\t\treused_template_idx = dasher_check_template_reuse(ctx, szInitSegmentFilename);\n\t\t\tif (reused_template_idx) {\n\t\t\t\tchar szExName[20];\n\t\t\t\tsprintf(szExName, \"_r%d_\", reused_template_idx);\n\t\t\t\tstrcat(szDASHTemplate, szExName);\n\t\t\t\t//force template at representation level if more than one rep and templates have been reused\n\t\t\t\tif (gf_list_count(ds->set->representations)>1)\n\t\t\t\t\tsingle_template = GF_FALSE;\n\t\t\t}\n\t\t}\n\n\t\t//get final segment template with path resolution - output file name is NULL, we already have solved this\n\t\tgf_media_mpd_format_segment_name(GF_DASH_TEMPLATE_TEMPLATE_WITH_PATH, is_bs_switch, szSegmentName, ds->rep_id, NULL, szDASHTemplate, seg_ext, 0, 0, 0, ds->stl, ctx->tpl_force);\n\t\tds->seg_template = gf_strdup(szSegmentName);\n\n\t\t//get final segment template - output file name is NULL, we already have solved this\n\t\tgf_media_mpd_format_segment_name(GF_DASH_TEMPLATE_TEMPLATE, is_bs_switch, szSegmentName, ds->rep_id, NULL, szDASHTemplate, seg_ext, 0, 0, 0, ds->stl, ctx->tpl_force);\n\n\n\t\t//get index templates\n\t\tif (idx_ext) {\n\t\t\tgf_media_mpd_format_segment_name(GF_DASH_TEMPLATE_REPINDEX_TEMPLATE_WITH_PATH, is_bs_switch, szIndexSegmentName, ds->rep_id, NULL, szDASHTemplate, idx_ext, 0, 0, 0, ds->stl, ctx->tpl_force);\n\t\t\tds->idx_template = gf_strdup(szIndexSegmentName);\n\n\t\t\tgf_media_mpd_format_segment_name(GF_DASH_TEMPLATE_REPINDEX_TEMPLATE, is_bs_switch, szIndexSegmentName, ds->rep_id, NULL, szDASHTemplate, idx_ext, 0, 0, 0, ds->stl, ctx->tpl_force);\n\t\t}\n\n\t\t//get final init name - output file name is NULL, we already have solved this\n\t\tgf_media_mpd_format_segment_name(GF_DASH_TEMPLATE_INITIALIZATION, is_bs_switch, szInitSegmentFilename, ds->rep_id, NULL, szDASHTemplate, init_ext, 0, ds->bitrate, 0, ds->stl, ctx->tpl_force);\n\n\t\t//get final init template name - output file name is NULL, we already have solved this\n\t\tgf_media_mpd_format_segment_name(init_template_mode, is_bs_switch, szInitSegmentTemplate, ds->rep_id, NULL, szDASHTemplate, init_ext, 0, 0, 0, ds->stl, ctx->tpl_force);\n\n\t\tif (ctx->sigfrag) {\n\t\t\tif (ctx->template || ds->template) {\n\t\t\t\t if (is_source_template) {\n\t\t\t\t\tconst GF_PropertyValue *mpd_url = gf_filter_pid_get_property_str(ds->ipid, \"manifest_url\");\n\t\t\t\t\tstrcpy(szInitSegmentFilename, gf_file_basename(ds->src_url));\n\n\t\t\t\t\tif (ctx->out_path && mpd_url) {\n\t\t\t\t\t\tBool keep_src = GF_FALSE;\n\t\t\t\t\t\tchar *url, *mpd_out, *mpd_src_alloc=NULL;\n\t\t\t\t\t\tmpd_out = gf_file_basename(ctx->out_path);\n\t\t\t\t\t\tu32 len = (u32) (mpd_out - ctx->out_path);\n\t\t\t\t\t\tchar *mpd_src = mpd_url->value.string;\n\t\t\t\t\t\tif (ctx->keep_src) {\n\t\t\t\t\t\t\tkeep_src = GF_TRUE;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (!strncmp(ctx->out_path, mpd_url->value.string, len))\n\t\t\t\t\t\t\tmpd_src += len;\n\t\t\t\t\t\telse if (gf_url_is_relative(ctx->out_path) && gf_url_is_relative(mpd_src)) {\n\t\t\t\t\t\t\tchar *opath=NULL, *ipath=NULL;\n\t\t\t\t\t\t\tif (ctx->out_path[0]!='.') gf_dynstrcat(&opath, \"./\", NULL);\n\t\t\t\t\t\t\tgf_dynstrcat(&opath, ctx->out_path, NULL);\n\t\t\t\t\t\t\tif (mpd_src[0]!='.') gf_dynstrcat(&ipath, \"./\", NULL);\n\t\t\t\t\t\t\tgf_dynstrcat(&ipath, mpd_src, NULL);\n\n\t\t\t\t\t\t\tmpd_src_alloc = gf_url_concatenate_parent(opath, ipath);\n\t\t\t\t\t\t\tmpd_src = mpd_src_alloc;\n\t\t\t\t\t\t\tif (opath) gf_free(opath);\n\t\t\t\t\t\t\tif (ipath) gf_free(ipath);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_DASH, (\"[Dasher] Non-relative URLs used in manifest generation mode, cannot determine output locations. Source URLs will be kept\\n\"));\n\t\t\t\t\t\t\tkeep_src = GF_TRUE;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (mpd_src && !strncmp(mpd_src, \"./\", 2)) mpd_src+=2;\n\n\t\t\t\t\t\tchar *init_url=NULL;\n\t\t\t\t\t\tconst GF_PropertyValue *p = gf_filter_pid_get_property_str(ds->ipid, \"init_url\");\n\t\t\t\t\t\tconst GF_PropertyValue *hls_variant = gf_filter_pid_get_property_str(ds->ipid, \"hls_variant_name\");\n\t\t\t\t\t\tif (p) {\n\t\t\t\t\t\t\tif (hls_variant) {\n\t\t\t\t\t\t\t\tinit_url = gf_url_concatenate(hls_variant->value.string, p->value.string);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tinit_url = gf_strdup(p->value.string);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (keep_src) {\n\t\t\t\t\t\t\tstrcpy(szInitSegmentFilename, init_url);\n\t\t\t\t\t\t\tstrcpy(szInitSegmentTemplate, init_url);\n\t\t\t\t\t\t\tstrcpy(szSegmentName, ds->template);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (init_url) {\n\t\t\t\t\t\t\t\turl = gf_url_concatenate(mpd_src, init_url);\n\t\t\t\t\t\t\t\tstrcpy(szInitSegmentFilename, url);\n\t\t\t\t\t\t\t\tstrcpy(szInitSegmentTemplate, url);\n\t\t\t\t\t\t\t\tgf_free(url);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t//no init segment URL\n\t\t\t\t\t\t\t\tstrcpy(szInitSegmentFilename, \"\");\n\t\t\t\t\t\t\t\tstrcpy(szInitSegmentTemplate, \"\");\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (hls_variant) {\n\t\t\t\t\t\t\t\tchar *tpl_int = gf_url_concatenate(hls_variant->value.string, ds->template);\n\t\t\t\t\t\t\t\turl = gf_url_concatenate(mpd_src, tpl_int);\n\t\t\t\t\t\t\t\tgf_free(tpl_int);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\turl = gf_url_concatenate(mpd_src, ds->template);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tstrcpy(szSegmentName, url);\n\t\t\t\t\t\t\tgf_free(url);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (init_url) gf_free(init_url);\n\t\t\t\t\t\tif (mpd_src_alloc) gf_free(mpd_src_alloc);\n\t\t\t\t\t}\n\t\t\t\t }\n\t\t\t} else {\n\t\t\t\tstrcpy(szInitSegmentFilename, gf_file_basename(ds->src_url));\n\t\t\t\tstrcpy(szSegmentName, gf_file_basename(ds->src_url));\n\t\t\t}\n\t\t}\n\n\t\tif (ctx->store_seg_states) {\n\t\t\tassert(!ds->pending_segment_states);\n\t\t\tds->pending_segment_states = gf_list_new();\n\t\t}\n\t\t/* baseURLs */\n\t\tnb_base = ds->p_base_url ? ds->p_base_url->value.string_list.nb_items : 0;\n\t\tfor (j=0; j<nb_base; j++) {\n\t\t\tGF_MPD_BaseURL *base_url;\n\t\t\tchar *url = ds->p_base_url->value.string_list.vals[j];\n\t\t\tGF_SAFEALLOC(base_url, GF_MPD_BaseURL);\n\t\t\tif (base_url) {\n\t\t\t\tbase_url->URL = gf_strdup(url);\n\t\t\t\tgf_list_add(rep->base_URLs, base_url);\n\t\t\t}\n\t\t}\n\n\t\tforce_init_seg_tpl = NULL;\n#if 0\n\t\tforce_init_seg_sl = NULL;\n#endif\n\t\tif (ds->codec_id==GF_CODECID_HEVC_TILES) {\n\t\t\ttile_base_ds = get_base_ds(ctx, ds);\n\t\t\tskip_init_type = DASH_INITSEG_SKIP;\n\t\t\tif (tile_base_ds->rep->segment_template) force_init_seg_tpl = tile_base_ds->rep->segment_template->initialization;\n\t\t\tif (!force_init_seg_tpl && tile_base_ds->set->segment_template) force_init_seg_tpl = tile_base_ds->set->segment_template->initialization;\n\n#if 0\n\t\t\tif (tile_base_ds->rep->segment_list) force_init_seg_sl = tile_base_ds->rep->segment_list->initialization_segment;\n\t\t\tif (!force_init_seg_sl && tile_base_ds->set->segment_list) force_init_seg_sl = tile_base_ds->set->segment_list->initialization_segment;\n#endif\n\t\t}\n\t\tif (ctx->muxtype==DASHER_MUX_RAW) skip_init_type = DASH_INITSEG_NONE;\n\t\telse if (ctx->muxtype==DASHER_MUX_TS) skip_init_type = DASH_INITSEG_NONE;\n\t\telse if (ctx->muxtype==DASHER_MUX_OGG) skip_init_type = DASH_INITSEG_NONE;\n\n\n\t\t//forward mode, change segment names\n\t\tif (ctx->forward_mode) {\n\t\t\tu32 k, nb_pids = gf_list_count(ctx->pids);\n\t\t\tchar *src = NULL;\n\t\t\tconst GF_PropertyValue *p = gf_filter_pid_get_property(ds->ipid, GF_PROP_PCK_FILENAME);\n\n\t\t\tif (!p || !p->value.string) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_DASH, (\"[Dasher] Couldn't fetch source URL in forward mode, cannot forward\\n\"));\n\t\t\t\tctx->in_error = GF_TRUE;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tsrc = p->value.string;\n\n\t\t\tfor (k=0; k<nb_pids; k++) {\n\t\t\t\tGF_DashStream *a_ds = gf_list_get(ctx->pids, k);\n\t\t\t\tif (ds == a_ds) continue;\n\t\t\t\tif (!a_ds->dst_filter) continue;\n\n\t\t\t\tp = gf_filter_pid_get_property(a_ds->ipid, GF_PROP_PCK_FILENAME);\n\t\t\t\tif (!p || !p->value.string) {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_DASH, (\"[Dasher] Couldn't fetch source URL in forward mode, cannot forward\\n\"));\n\t\t\t\t\tctx->in_error = GF_TRUE;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t//same init segment used (bs switching)\n\t\t\t\tif (!strcmp(p->value.string, src))\n\t\t\t\t\tskip_init_type = DASH_INITSEG_SKIP;\n\t\t\t}\n\t\t\tstrcpy(szInitSegmentFilename, src);\n\t\t\tstrcpy(szInitSegmentTemplate, src);\n\n\t\t\tif (ctx->tpl) {\n\t\t\t\tp = gf_filter_pid_get_property(ds->ipid, GF_PROP_PID_TEMPLATE);\n\t\t\t\tif (!p || !p->value.string) {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_DASH, (\"[Dasher] Couldn't fetch source template in forward mode, cannot forward\\n\"));\n\t\t\t\t\tctx->in_error = GF_TRUE;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tstrcpy(szSegmentName, p->value.string);\n\t\t\t}\n\t\t}\n\n\t\tds->init_seg = gf_strdup(szInitSegmentFilename);\n\n\t\t//we use segment template\n\t\tif (ctx->tpl) {\n\t\t\tBool use_single_init, force_init_template=GF_FALSE;\n\t\t\tGF_MPD_SegmentTemplate *seg_template;\n\t\t\tu32 start_number = ds->startNumber ? ds->startNumber : 1;\n\t\t\tu64 seg_duration = (u64)(ds->dash_dur.num) * ds->mpd_timescale / ds->dash_dur.den;\n\n\t\t\tif (ds->inband_params && (ctx->bs_switch==DASHER_BS_SWITCH_INBAND_PPS)) {\n\t\t\t\tuse_single_init = GF_FALSE;\n\t\t\t\tsingle_template = GF_FALSE;\n\t\t\t} else {\n\t\t\t\tuse_single_init = (set->bitstream_switching || single_template) ? GF_TRUE : GF_FALSE;\n\t\t\t\tif (is_bs_switch && ctx->force_init) {\n\t\t\t\t\tuse_single_init = GF_FALSE;\n\t\t\t\t\tsingle_template = GF_FALSE;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//first rep in set and bs switching or single template, create segment template at set level\n\t\t\tif (!i && use_single_init ) {\n\t\t\t\tinit_template_done = GF_TRUE;\n\t\t\t\tseg_template = NULL;\n\t\t\t\tif (!skip_init_type || force_init_seg_tpl || single_template) {\n\t\t\t\t\tGF_SAFEALLOC(seg_template, GF_MPD_SegmentTemplate);\n\t\t\t\t\tif (seg_template) {\n\t\t\t\t\t\tif (skip_init_type) {\n\t\t\t\t\t\t\tseg_template->initialization = force_init_seg_tpl ? gf_strdup(force_init_seg_tpl) : NULL;\n\t\t\t\t\t\t\tseg_template->hls_init_name = force_init_seg_tpl ? tile_base_ds->init_seg : NULL;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t//bs switching, if we have still template fields init segment template use resolved init file name - cf #2141\n\t\t\t\t\t\t\tif (!force_init_template && is_bs_switch && strchr(szInitSegmentTemplate, '$'))\n\t\t\t\t\t\t\t\tseg_template->initialization = gf_strdup(szInitSegmentFilename);\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tseg_template->initialization = gf_strdup(szInitSegmentTemplate);\n\t\t\t\t\t\t\tseg_template->hls_init_name = ds->init_seg;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tset->segment_template = seg_template;\n\n\t\t\t\tdasher_open_destination(filter, ctx, rep, szInitSegmentFilename, skip_init_type);\n\n\t\t\t\tif (single_template) {\n\t\t\t\t\tseg_template->media = gf_strdup(szSegmentName);\n\t\t\t\t\tif (ds->idx_template)\n\t\t\t\t\t\tseg_template->index = gf_strdup(szIndexSegmentName);\n\n\t\t\t\t\tseg_template->timescale = ds->mpd_timescale;\n\t\t\t\t\tseg_template->start_number = start_number;\n\t\t\t\t\tseg_template->duration = seg_duration;\n\n\t\t\t\t\tif (ctx->asto>0) {\n\t\t\t\t\t\tseg_template->availability_time_offset = ctx->asto;\n\t\t\t\t\t}\n\t\t\t\t} else if (seg_template) {\n\t\t\t\t\tseg_template->start_number = (u32)-1;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//non-first rep in set and single template, only open destination\n\t\t\tif (i && single_template) {\n\t\t\t\tdasher_open_destination(filter, ctx, rep, szInitSegmentFilename,\n\t\t\t\t\t(skip_init_type==DASH_INITSEG_NONE) ? DASH_INITSEG_NONE : (set->bitstream_switching ? DASH_INITSEG_SKIP : DASH_INITSEG_PRESENT));\n\t\t\t}\n\t\t\t//first rep in set and no bs switching or mutliple templates, create segment template at rep level\n\t\t\telse if (i || !single_template) {\n\t\t\t\tGF_SAFEALLOC(seg_template, GF_MPD_SegmentTemplate);\n\t\t\t\tif (seg_template) {\n\t\t\t\t\trep->segment_template = seg_template;\n\t\t\t\t\tif (!init_template_done) {\n\t\t\t\t\t\tif (skip_init_type) {\n\t\t\t\t\t\t\tseg_template->initialization = force_init_seg_tpl ? gf_strdup(force_init_seg_tpl) : NULL;\n\t\t\t\t\t\t\tseg_template->hls_init_name = force_init_seg_tpl ? tile_base_ds->init_seg : NULL;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tseg_template->initialization = gf_strdup(szInitSegmentTemplate);\n\t\t\t\t\t\t\tseg_template->hls_init_name = ds->init_seg;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdasher_open_destination(filter, ctx, rep, szInitSegmentFilename, skip_init_type);\n\t\t\t\t\t} else if (i) {\n\t\t\t\t\t\tdasher_open_destination(filter, ctx, rep, szInitSegmentFilename,\n\t\t\t\t\t\t\t(skip_init_type==DASH_INITSEG_NONE) ? DASH_INITSEG_NONE : (set->bitstream_switching ? DASH_INITSEG_SKIP : DASH_INITSEG_PRESENT) );\n\t\t\t\t\t}\n\t\t\t\t\tseg_template->media = gf_strdup(szSegmentName);\n\t\t\t\t\tif (ds->idx_template)\n\t\t\t\t\t\tseg_template->index = gf_strdup(szIndexSegmentName);\n\t\t\t\t\tseg_template->duration = seg_duration;\n\t\t\t\t\tseg_template->timescale = ds->mpd_timescale;\n\t\t\t\t\tseg_template->start_number = start_number;\n\t\t\t\t\tif (ctx->asto > 0) {\n\t\t\t\t\t\tseg_template->availability_time_offset = ctx->asto;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*we are using a single file or segment, use base url*/\n\t\telse if (ctx->sseg || ctx->sfile) {\n\t\t\tGF_MPD_BaseURL *baseURL;\n\n\t\t\tif (ds->init_seg) gf_free(ds->init_seg);\n\t\t\tds->init_seg = gf_strdup(szInitSegmentFilename);\n\n\t\t\tGF_SAFEALLOC(baseURL, GF_MPD_BaseURL);\n\t\t\tif (!baseURL) continue;\n\n\t\t\tif (!rep->base_URLs) rep->base_URLs = gf_list_new();\n\t\t\tgf_list_add(rep->base_URLs, baseURL);\n\n\t\t\tif (ctx->sseg) {\n\t\t\t\tGF_MPD_SegmentBase *segment_base;\n\t\t\t\tbaseURL->URL = gf_strdup(szInitSegmentFilename);\n\t\t\t\tGF_SAFEALLOC(segment_base, GF_MPD_SegmentBase);\n\t\t\t\tif (!segment_base) continue;\n\t\t\t\trep->segment_base = segment_base;\n\t\t\t\tdasher_open_destination(filter, ctx, rep, szInitSegmentFilename, 0);\n\t\t\t} else {\n\t\t\t\tGF_MPD_SegmentList *seg_list;\n\t\t\t\tGF_SAFEALLOC(seg_list, GF_MPD_SegmentList);\n\t\t\t\tif (!seg_list) continue;\n\t\t\t\tGF_SAFEALLOC(seg_list->initialization_segment, GF_MPD_URL);\n\t\t\t\tif (!seg_list->initialization_segment) continue;\n\t\t\t\tseg_list->start_number = (u32) -1;\n\t\t\t\tbaseURL->URL = gf_strdup(szInitSegmentFilename);\n\t\t\t\tseg_list->dasher_segment_name = gf_strdup(szSegmentName);\n\t\t\t\tseg_list->timescale = ds->mpd_timescale;\n\t\t\t\tseg_list->duration = (u64) (ds->dash_dur.num) * ds->mpd_timescale / ds->dash_dur.den;\n\t\t\t\tseg_list->segment_URLs = gf_list_new();\n\t\t\t\trep->segment_list = seg_list;\n\t\t\t\tds->pending_segment_urls = gf_list_new();\n\n\t\t\t\tdasher_open_destination(filter, ctx, rep, szInitSegmentFilename, skip_init_type);\n\t\t\t}\n\t\t}\n\t\t//no template, no single file, we need a file list\n\t\telse {\n\t\t\tGF_MPD_SegmentList *seg_list;\n\t\t\tGF_SAFEALLOC(seg_list, GF_MPD_SegmentList);\n\t\t\tif (!seg_list) continue;\n\n\t\t\tif (!skip_init_type) {\n\t\t\t\tGF_SAFEALLOC(seg_list->initialization_segment, GF_MPD_URL);\n\t\t\t\tif (!seg_list->initialization_segment) continue;\n\n\t\t\t\tseg_list->initialization_segment->sourceURL = gf_strdup(szInitSegmentFilename);\n\t\t\t}\n\t\t\tseg_list->dasher_segment_name = gf_strdup(szSegmentName);\n\t\t\tseg_list->timescale = ds->mpd_timescale;\n\t\t\tseg_list->segment_URLs = gf_list_new();\n\t\t\tseg_list->start_number = (u32) -1;\n\t\t\tseg_list->duration = (u64) (ds->dash_dur.num) * ds->mpd_timescale / ds->dash_dur.den;\n\t\t\trep->segment_list = seg_list;\n\t\t\tds->pending_segment_urls = gf_list_new();\n\n\t\t\tdasher_open_destination(filter, ctx, rep, szInitSegmentFilename, skip_init_type);\n\t\t}\n\n\t\t//open PID\n\t\tdasher_open_pid(filter, ctx, ds, multi_pids, skip_init_type ? GF_TRUE : GF_FALSE);\n\t}\n}\n\nstatic void dasher_purge_segment_timeline(GF_DashStream *ds, GF_MPD_SegmentTimeline *stl, GF_DASH_SegmentContext *sctx)\n{\n\tGF_MPD_SegmentTimelineEntry *stl_e = gf_list_get(stl->entries, 0);\n\tif (!stl_e) return;\n\n\tif (stl_e->repeat_count) {\n\t\tstl_e->repeat_count--;\n\t\tstl_e->start_time += stl_e->duration;\n\t} else {\n\t\tu64 start_time = stl_e->start_time + stl_e->duration;\n\t\tgf_list_rem(stl->entries, 0);\n\t\tgf_free(stl_e);\n\t\tstl_e = gf_list_get(stl->entries, 0);\n\t\tif (!stl_e) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_DASH, (\"[Dasher] No timeline entry after currently removed segment, cannot update start time\\n\" ));\n\t\t\treturn;\n\t\t}\n\n\t\tif (!stl_e->start_time) stl_e->start_time = start_time;\n\t\telse if (stl_e->start_time != start_time) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_DASH, (\"[Dasher] Mismatch in segment timeline while purging, new start time \"LLU\" but entry indicates \"LLU\", keeping original one\\n\", start_time, stl_e->start_time ));\n\t\t}\n\t}\n}\n\nstatic void dasher_purge_segments(GF_DasherCtx *ctx, u64 *period_dur)\n{\n\tDouble min_valid_mpd_time;\n\tu64 max_rem_dur = 0;\n\tu32 i, count;\n\n\t//non-static mode, purge segments\n\tif (ctx->dmode == GF_MPD_TYPE_STATIC) return;\n\tif (ctx->tsb<0) return;\n\n\n\tmin_valid_mpd_time = (Double) *period_dur;\n\tmin_valid_mpd_time /= 1000;\n\tmin_valid_mpd_time -= ctx->tsb;\n\t//negative asto, we produce segments earlier but we don't want to delete them before the asto\n\tif (ctx->asto<0) {\n\t\tmin_valid_mpd_time += ctx->asto;\n\t}\n\tif (min_valid_mpd_time<=0) return;\n\n\tcount = gf_list_count(ctx->current_period->streams);\n\tfor (i=0; i<count; i++) {\n\t\tGF_DashStream *ds = gf_list_get(ctx->current_period->streams, i);\n\t\tif (ds->muxed_base) continue;\n\t\tif (!ds->rep) continue;\n\t\tif (!ds->rep->state_seg_list) continue;\n\n\t\twhile (1) {\n\t\t\tDouble time, dur;\n\t\t\tBool seg_url_found = GF_FALSE;\n\t\t\tBool has_seg_list = GF_FALSE;\n\t\t\tGF_DASH_SegmentContext *sctx = gf_list_get(ds->rep->state_seg_list, 0);\n\t\t\tif (!sctx) break;\n\t\t\t/*not yet flushed*/\n\t\t\tif (gf_list_find(ds->pending_segment_states, sctx)>=0) break;\n\t\t\ttime = (Double) sctx->time;\n\t\t\ttime /= ds->mpd_timescale;\n\t\t\tdur = (Double) sctx->dur;\n\t\t\tdur/= ds->timescale;\n\t\t\tif (time + dur >= min_valid_mpd_time) break;\n\t\t\tif (sctx->filepath) {\n\t\t\t\tGF_FilterEvent evt;\n\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_DASH, (\"[Dasher] removing segment %s\\n\", sctx->filename ? sctx->filename : sctx->filepath));\n\n\t\t\t\tGF_FEVT_INIT(evt, GF_FEVT_FILE_DELETE, ds->opid);\n\t\t\t\tevt.file_del.url = sctx->filepath;\n\t\t\t\tgf_filter_pid_send_event(ds->opid, &evt);\n\t\t\t\tgf_free(sctx->filepath);\n\t\t\t}\n\n\t\t\tif (ds->rep->segment_list) {\n\t\t\t\tGF_MPD_SegmentURL *surl = gf_list_pop_front(ds->rep->segment_list->segment_URLs);\n\t\t\t\thas_seg_list = GF_TRUE;\n\t\t\t\t//can be NULL if we mutualize everything at AdaptatioSet level\n\t\t\t\tif (surl) {\n\t\t\t\t\tgf_mpd_segment_url_free(surl);\n\t\t\t\t\tseg_url_found = GF_TRUE;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//not an else due to inheritance\n\t\t\tif (ds->owns_set && ds->set->segment_list) {\n\t\t\t\tGF_MPD_SegmentURL *surl = gf_list_pop_front(ds->set->segment_list->segment_URLs);\n\t\t\t\thas_seg_list = GF_TRUE;\n\t\t\t\t//can be NULL if we don't mutualize at AdaptatioSet level\n\t\t\t\tif (surl) {\n\t\t\t\t\tgf_mpd_segment_url_free(surl);\n\t\t\t\t\tseg_url_found = GF_TRUE;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//but we must have at least one segment URL entry\n\t\t\tif (has_seg_list && !seg_url_found) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_DASH, (\"[Dasher] purging segment %s for AS %d rep %s but segment list is empty!\\n\",\n\t\t\t\t\t\tsctx->filename ? sctx->filename : \"\", ds->set->id, ds->rep->id));\n\t\t\t}\n\n\t\t\tif (ds->rep->segment_template) {\n\t\t\t\tif (ds->rep->segment_template->segment_timeline) {\n\t\t\t\t\tdasher_purge_segment_timeline(ds, ds->rep->segment_template->segment_timeline, sctx);\n\t\t\t\t}\n\t\t\t}\n\t\t\t//not an else due to inheritance\n\t\t\tif (ds->owns_set && ds->set->segment_template) {\n\t\t\t\tif (ds->set->segment_template->segment_timeline) {\n\t\t\t\t\tdasher_purge_segment_timeline(ds, ds->set->segment_template->segment_timeline, sctx);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tds->nb_segments_purged ++;\n\t\t\tds->dur_purged += dur;\n\t\t\tassert(gf_list_find(ds->pending_segment_states, sctx)<0);\n\t\t\tif (sctx->filename) gf_free(sctx->filename);\n\t\t\tif (sctx->hls_key_uri) gf_free(sctx->hls_key_uri);\n\t\t\tgf_free(sctx);\n\t\t\tgf_list_rem(ds->rep->state_seg_list, 0);\n\t\t}\n\t\tif (max_rem_dur < ds->dur_purged*1000) max_rem_dur = (u64) (ds->dur_purged * 1000);\n\t\t//final flush to static of live session: update start number\n\t\tif (ctx->dmode!=GF_MPD_TYPE_DYNAMIC) {\n\t\t\tif (ds->owns_set && ds->set && ds->set->segment_template) {\n\t\t\t\tds->set->segment_template->start_number += ds->nb_segments_purged;\n\t\t\t} else if (ds->rep && ds->rep->segment_template) {\n\t\t\t\tds->rep->segment_template->start_number += ds->nb_segments_purged;\n\t\t\t}\n\t\t\tds->nb_segments_purged = 0;\n\t\t}\n\t}\n\t//final flush to static of live session: update period duration\n\tif (ctx->dmode!=GF_MPD_TYPE_DYNAMIC) {\n\t\tif (max_rem_dur > *period_dur) *period_dur = 0;\n\t\telse *period_dur = *period_dur - max_rem_dur;\n\t}\n}\n\nstatic void dasher_update_period_duration(GF_DasherCtx *ctx, Bool is_period_switch)\n{\n\tu32 i, count;\n\tu64 pdur = 0;\n\tu64 min_dur = 0;\n\tu64 p_start=0;\n\tGF_MPD_Period *prev_p = NULL;\n\tcount = gf_list_count(ctx->current_period->streams);\n\tfor (i=0; i<count; i++) {\n\t\tGF_DashStream *ds = gf_list_get(ctx->current_period->streams, i);\n\t\tif (ds->muxed_base) continue;\n\n\t\tif (ds->xlink && (ds->stream_type==GF_STREAM_FILE) ) {\n\t\t\tpdur = (u32) (1000*(s64)ds->period_dur.num / ds->period_dur.den);\n\t\t} else {\n\t\t\tu64 ds_dur = ds->max_period_dur;\n\n\t\t\t//we had to generate one extra segment to unlock looping, but we don't want to advertise it in the manifest duration\n\t\t\t//because other sets may not be ready for this time interval\n\t\t\tif (ds->subdur_forced_use_period_dur)\n\t\t\t\tds_dur = ds->subdur_forced_use_period_dur;\n\n\t\t\tif (ds->clamped_dur.num && !ctx->loop) {\n\t\t\t\tu64 clamp_dur = (u64) (ds->clamped_dur.num * 1000);\n\t\t\t\tif (clamp_dur < ds->clamped_dur.den * ds_dur) ds_dur = clamp_dur / ds->clamped_dur.den;\n\t\t\t}\n\n\t\t\tif (ds->dur_purged && (ctx->mpd->type != GF_MPD_TYPE_DYNAMIC)) {\n\t\t\t\tu64 rem_dur = (u64) (ds->dur_purged * 1000);\n\t\t\t\tif (ds_dur>rem_dur) ds_dur -= rem_dur;\n\t\t\t\telse ds_dur = 0;\n\t\t\t}\n\n\t\t\tif (!min_dur || (min_dur > ds_dur)) min_dur = ds->max_period_dur;\n\t\t\tif (pdur < ds_dur) pdur = ds_dur;\n\t\t}\n\t}\n\n\tif (!count) {\n\t\tif (ctx->current_period->period && ctx->current_period->period->duration)\n\t\t\tpdur = ctx->current_period->period->duration;\n\t}\n\n\tif (!ctx->check_dur) {\n\t\ts32 diff = (s32) ((s64) pdur - (s64) min_dur);\n\t\tif (ABS(diff)>2000) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_DASH, (\"[Dasher] Adaptation sets in period are of unequal duration min %g max %g seconds\\n\", ((Double)min_dur)/1000, ((Double)pdur)/1000));\n\t\t}\n\t}\n\n\tdasher_purge_segments(ctx, &pdur);\n\n\tif (ctx->current_period->period && !ctx->index_media_duration) {\n\t\tctx->current_period->period->duration = pdur;\n\n\t\t//update MPD duration in any case\n\t\tif (ctx->current_period->period->start) {\n\t\t\tctx->mpd->media_presentation_duration = ctx->current_period->period->start + pdur;\n\t\t} else {\n\t\t\tu32 k, pcount = gf_list_count(ctx->mpd->periods);\n\t\t\tctx->mpd->media_presentation_duration = 0;\n\t\t\tfor (k=0; k<pcount; k++) {\n\t\t\t\tGF_MPD_Period *p = gf_list_get(ctx->mpd->periods, k);\n\t\t\t\tif (p->start)\n\t\t\t\t\tctx->mpd->media_presentation_duration = p->start + p->duration;\n\t\t\t\telse\n\t\t\t\t\tctx->mpd->media_presentation_duration += p->duration;\n\t\t\t\tif (p==ctx->current_period->period)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (ctx->refresh<0)\n\t\tctx->mpd->media_presentation_duration = (u32) ( (-ctx->refresh) * 1000 );\n\n\t//static mode, done\n\tif (ctx->dmode != GF_MPD_TYPE_DYNAMIC) {\n\t\treturn;\n\t}\n\tassert(ctx->current_period->period);\n\t//dynamic mode only, reset durations\n\n\tctx->mpd->gpac_mpd_time = ctx->mpd->media_presentation_duration;\n\n\t//not done yet for this period, keep duration to 0\n\tif (ctx->subdur_done) {\n\t\tif (ctx->mpd->media_presentation_duration > ctx->current_period->period->duration)\n\t\t\tctx->mpd->media_presentation_duration -= ctx->current_period->period->duration;\n\t\telse\n\t\t\tctx->mpd->media_presentation_duration = 0;\n\t\tctx->current_period->period->duration = 0;\n\t}\n\n\tctx->mpd->gpac_next_ntp_ms = ctx->mpd->gpac_init_ntp_ms + ctx->mpd->gpac_mpd_time;\n\tif (ctx->asto<0)\n\t\tctx->mpd->gpac_next_ntp_ms -= (u64) (-ctx->asto * 1000);\n\tif (ctx->_p_gentime) (*ctx->_p_gentime) = ctx->mpd->gpac_next_ntp_ms;\n\tif (ctx->_p_mpdtime) (*ctx->_p_mpdtime) = ctx->mpd->gpac_mpd_time;\n\n\tGF_LOG(GF_LOG_INFO, GF_LOG_DASH, (\"[Dasher] updated period %s duration \"LLU\" MPD time \"LLU\"\\n\", ctx->current_period->period->ID, pdur, ctx->mpd->gpac_mpd_time ));\n\n\tcount = gf_list_count(ctx->mpd->periods);\n\tfor (i=0; i<count; i++) {\n\t\tGF_MPD_Period *p = gf_list_get(ctx->mpd->periods, i);\n\t\tif (p->start) {\n\t\t\tp_start = p->start;\n\t\t} else {\n\t\t\tp->start = p_start;\n\t\t}\n\t\tif (prev_p && (prev_p->start + prev_p->duration == p_start)) {\n\t\t\tprev_p->duration = 0;\n\t\t}\n\t\tp_start += p->duration;\n\t\tprev_p = p;\n\t}\n}\n\nstatic void dasher_transfer_file(FILE *f, GF_FilterPid *opid, const char *name, GF_DashStream *ds)\n{\n\tGF_FilterPacket *pck;\n\tu32 size, nb_read;\n\tu8 *output;\n\n\tsize = (u32) gf_fsize(f);\n\n\tpck = gf_filter_pck_new_alloc(opid, size, &output);\n\tif (!pck) return;\n\n\tnb_read = (u32) gf_fread(output, size, f);\n\tif (nb_read != size) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_DASH, (\"[Dasher] Error reading temp MPD file, read %d bytes but file size is %d\\n\", nb_read, size ));\n\t}\n\n\tgf_filter_pck_set_framing(pck, GF_TRUE, GF_TRUE);\n\tgf_filter_pck_set_seek_flag(pck, GF_TRUE);\n\tif (name) {\n\t\tgf_filter_pck_set_property(pck, GF_PROP_PCK_FILENAME, &PROP_STRING(name) );\n\t}\n\tif (ds) {\n\t\tgf_filter_pck_set_property(pck, GF_PROP_PCK_HLS_REF, &PROP_LONGUINT( ds->hls_ref_id ) );\n\t}\n\tgf_filter_pck_send(pck);\n}\n\n\nstatic u64 dasher_get_utc(GF_DasherCtx *ctx)\n{\n\treturn gf_net_get_utc() - ctx->utc_diff;\n}\n\nstatic void dasher_get_set_and_rep(GF_MPD_Period *period, const char *repid, GF_MPD_AdaptationSet **out_set, GF_MPD_Representation **out_rep)\n{\n\tu32 i, nb_sets = gf_list_count(period->adaptation_sets);\n\tfor (i=0; i<nb_sets; i++) {\n\t\tu32 j, nb_reps;\n\t\tGF_MPD_AdaptationSet *set = gf_list_get(period->adaptation_sets, i);\n\t\tnb_reps = gf_list_count(set->representations);\n\t\tfor (j=0; j<nb_reps; j++) {\n\t\t\tGF_MPD_Representation *rep = gf_list_get(set->representations, j);\n\t\t\tif (rep->id && !strcmp(rep->id, repid)) {\n\t\t\t\t*out_set = set;\n\t\t\t\t*out_rep = rep;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic Bool dasher_merge_rep(GF_DashStream *ds, GF_MPD_Representation *rep)\n{\n\tBool transcode_detected = GF_FALSE;\n\tBool recompute_set = GF_FALSE;\n\tGF_MPD_Representation *n_rep = ds->rep;\n\n\t//TODO: copy other properties in case we transcode ?\n\n#define CHECK_VAL(_name, _v) if (rep->_name != n_rep->_name) { rep->_name = n_rep->_name; transcode_detected = GF_TRUE; if (_v) recompute_set = GF_TRUE; }\n\n#define CHECK_STR(_name) if (rep->_name && n_rep->_name && !strcmp(rep->_name, n_rep->_name)) {} \\\n\telse if (!rep->_name && !n_rep->_name) {}\\\n\telse { \\\n\t\tif (rep->_name) gf_free(rep->_name); \\\n\t\trep->_name = n_rep->_name ? gf_strdup(n_rep->_name) : NULL; \\\n\t\ttranscode_detected = GF_TRUE; \\\n\t}\n\n//for frac, if not set on source PID, consider it unchanged\n#define CHECK_FRAC(_name) if (rep->_name && n_rep->_name && (rep->_name->num * n_rep->_name->den == rep->_name->den * n_rep->_name->num)) {} \\\n\telse if (!n_rep->_name) {}\\\n\telse { \\\n\t\tif (rep->_name) gf_free(rep->_name); \\\n\t\tif (n_rep->_name) { rep->_name = gf_malloc(sizeof(GF_MPD_Fractional)); memcpy(rep->_name, n_rep->_name, sizeof(GF_MPD_Fractional)); } \\\n\t\telse rep->_name = NULL; \\\n\t\ttranscode_detected = GF_TRUE; \\\n\t}\n\n\tCHECK_STR(codecs)\n\tCHECK_STR(profiles)\n\tCHECK_STR(mime_type)\n\tCHECK_STR(segmentProfiles)\n\tCHECK_VAL(width, 1)\n\tCHECK_VAL(height, 1)\n\tCHECK_VAL(bandwidth, 0)\n\tCHECK_VAL(samplerate, 0)\n\tCHECK_VAL(scan_type, 0)\n\tCHECK_FRAC(sar)\n\tCHECK_FRAC(framerate)\n\n\tif (transcode_detected && !ds->transcode_detected) {\n\t\tds->transcode_detected = GF_TRUE;\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_DASH, (\"[Dasher] Transcoded detected in forward mode, not fully tested !\\n\"));\n\t}\n#undef CHECK_VAL\n#undef CHECK_STR\n#undef CHECK_FRAC\n\n\treturn recompute_set;\n}\nstatic void dasher_forward_manifest_raw(GF_DasherCtx *ctx, GF_DashStream *ds, const char *manifest, const char *manifest_name)\n{\n\tGF_FilterPacket *pck;\n\tu32 size;\n\tu8 *output;\n\n\tsize = (u32) strlen(manifest);\n\n\tpck = gf_filter_pck_new_alloc(ctx->opid, size+1, &output);\n\tif (!pck) return;\n\n\tmemcpy(output, manifest, size);\n\toutput[size] = 0;\n\tgf_filter_pck_set_framing(pck, GF_TRUE, GF_TRUE);\n\tgf_filter_pck_set_seek_flag(pck, GF_TRUE);\n\tif (manifest_name) {\n\t\tif (ctx->out_path) {\n\t\t\tchar *url = gf_url_concatenate(ctx->out_path, manifest_name);\n\t\t\tgf_filter_pck_set_property(pck, GF_PROP_PCK_FILENAME, &PROP_STRING_NO_COPY(url) );\n\t\t} else {\n\t\t\tgf_filter_pck_set_property(pck, GF_PROP_PCK_FILENAME, &PROP_STRING(manifest_name) );\n\t\t}\n\t\tif (ds)\n\t\t\tgf_filter_pck_set_property(pck, GF_PROP_PCK_HLS_REF, &PROP_LONGUINT( ds->hls_ref_id ) );\n\t}\n\tgf_filter_pck_send(pck);\n}\n\n\nstatic void dasher_forward_mpd(GF_DasherCtx *ctx, const char *manifest)\n{\n\tu32 i, count, nb_periods, nb_streams;\n\tGF_XMLAttribute *cenc_att = NULL;\n\tGF_XMLAttribute *xlink_att = NULL;\n\tGF_XMLAttribute *ck_att = NULL;\n\tFILE *tmp = NULL;\n\tGF_MPD *mpd = gf_mpd_new();\n\tGF_List *recompute_sets = NULL;\n\tGF_DOMParser *dom = gf_xml_dom_new();\n\tGF_Err e = gf_xml_dom_parse_string(dom, (char *)manifest);\n\tif (e) goto err_exit;\n\n\te = gf_mpd_init_from_dom(gf_xml_dom_get_root(dom), mpd, NULL);\n\tif (e) goto err_exit;\n\n\tnb_streams = gf_list_count(ctx->pids);\n\tnb_periods = gf_list_count(mpd->periods);\n\tfor (i=0; i<nb_periods; i++) {\n\t\tu32 j;\n\t\tGF_MPD_AdaptationSet *set = NULL;\n\t\tGF_MPD_Representation *rep = NULL;\n\t\tGF_MPD_Period *period = gf_list_get(mpd->periods, i);\n\t\tfor (j=0; j<nb_streams; j++) {\n\t\t\tBool invalidate_set;\n\t\t\tGF_DashStream *ds = gf_list_get(ctx->pids, j);\n\t\t\tif (ds->muxed_base) continue;\n\t\t\tconst GF_PropertyValue *ps = gf_filter_pid_get_property(ds->ipid, GF_PROP_PID_DASH_PERIOD_START);\n\t\t\tconst GF_PropertyValue *repid = gf_filter_pid_get_property(ds->ipid, GF_PROP_PID_REP_ID);\n\t\t\tif (!ps || !repid) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_DASH, (\"[Dasher] Couldn't fetch period start or rep ID in forward mode, cannot forward\\n\"));\n\t\t\t\tgoto err_exit;\n\t\t\t}\n\t\t\tif (period->start != ps->value.longuint) continue;\n\t\t\tdasher_get_set_and_rep(period, repid->value.string, &set, &rep);\n\t\t\tif (!set || !rep) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_DASH, (\"[Dasher] Couldn't locate adaptation set and period in source manifest in forward mode, cannot forward\\n\"));\n\t\t\t\tgoto err_exit;\n\t\t\t}\n\t\t\t//copy/reset common encryption\n\t\t\tif (set->content_protection) {\n\t\t\t\tgf_mpd_del_list(set->content_protection, gf_mpd_descriptor_free, 1);\n\t\t\t}\n\t\t\tif (rep->content_protection) {\n\t\t\t\tgf_mpd_del_list(rep->content_protection, gf_mpd_descriptor_free, 1);\n\t\t\t}\n\t\t\tif (gf_list_count(ds->rep->content_protection)) {\n\t\t\t\tgf_list_del(rep->content_protection);\n\t\t\t\trep->content_protection = dasher_get_content_protection_desc(ctx, ds, NULL);\n\t\t\t}\n\t\t\tif (gf_list_count(ds->set->content_protection)) {\n\t\t\t\tgf_list_del(set->content_protection);\n\t\t\t\tset->content_protection = dasher_get_content_protection_desc(ctx, ds, ds->set);\n\t\t\t}\n\t\t\tinvalidate_set = dasher_merge_rep(ds, rep);\n\t\t\t//wait until we are all done\n\t\t\tif (invalidate_set) {\n\t\t\t\tif (!recompute_sets) recompute_sets = gf_list_new();\n\t\t\t\tif (gf_list_find(recompute_sets, set)<0)\n\t\t\t\t\tgf_list_add(recompute_sets, set);\n\t\t\t}\n\t\t}\n\t}\n\t//update sets - TODO\n\n\t//insert xmlns if needed\n\tcount = gf_list_count(mpd->x_attributes);\n\tfor (i=0; i<count; i++) {\n\t\tGF_XMLAttribute * att = gf_list_get(mpd->x_attributes, i);\n\t\tif (!strcmp(att->name, \"xmlns:cenc\")) cenc_att = att;\n\t\tif (!strcmp(att->name, \"xmlns:xlink\")) xlink_att = att;\n\t\tif (!strcmp(att->name, \"xmlns:ck\")) ck_att = att;\n\n\t}\n\tif (ctx->use_cenc && !cenc_att) {\n\t\tcenc_att = gf_xml_dom_create_attribute(\"xmlns:cenc\", \"urn:mpeg:cenc:2013\");\n\t\tgf_list_add(mpd->x_attributes, cenc_att);\n\t}\n\tif (ctx->use_xlink && !xlink_att) {\n\t\txlink_att = gf_xml_dom_create_attribute(\"xmlns:xlink\", \"http://www.w3.org/1999/xlink\");\n\t\tgf_list_add(mpd->x_attributes, xlink_att);\n\t}\n\tif (ctx->use_clearkey && !ck_att) {\n\t\tck_att = gf_xml_dom_create_attribute(\"xmlns:ck\", \"http://dashif.org/guidelines/clearKey\");\n\t\tgf_list_add(mpd->x_attributes, ck_att);\n\t}\n\n\n\tdasher_check_chaining(ctx, \"urn:mpeg:dash:mpd-chaining:2016\", ctx->chain);\n\tdasher_check_chaining(ctx, \"urn:mpeg:dash:fallback:2016\", ctx->chain_fbk);\n\n\n\t//and send\n\ttmp = gf_file_temp(NULL);\n\tmpd->xml_namespace = ctx->mpd->xml_namespace;\n\tmpd->publishTime = dasher_get_utc(ctx);\n\te = gf_mpd_write(mpd, tmp, ctx->cmpd);\n\tif (e) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_DASH, (\"[Dasher] Error serializing manifest in forward mode: %s\\n\", gf_error_to_string(e) ));\n\t\te = GF_OK;\n\t\tgoto err_exit;\n\t}\n\tdasher_transfer_file(tmp, ctx->opid, NULL, NULL);\n\nerr_exit:\n\tif (tmp) gf_fclose(tmp);\n\tgf_mpd_del(mpd);\n\tgf_xml_dom_del(dom);\n\tgf_list_del(recompute_sets);\n\tif (e)\n\t\tctx->in_error = GF_TRUE;\n}\n\nstatic GF_Err dasher_write_index(GF_DasherCtx *ctx, GF_FilterPid *opid)\n{\n\tu8 *data;\n\tu32 i, pos, count = gf_list_count(ctx->pids);\n\tu32 nb_rep_pos, nb_reps=0;\n\tGF_BitStream *bs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\n\tgf_bs_write_u32(bs, GF_4CC('G','H','I','D'));\n\tgf_bs_write_u32(bs, 0); //for future ext ?\n\tgf_bs_write_u32 (bs, ctx->mpd->segment_duration);\n\tgf_bs_write_u32 (bs, ctx->mpd->max_segment_duration);\n\tgf_bs_write_u64 (bs, ctx->mpd->media_presentation_duration);\n\tgf_bs_write_u64(bs, ctx->current_period->period->duration);\n\tgf_bs_write_utf8(bs, ctx->mpd->segment_template);\n\n\tnb_rep_pos = (u32) gf_bs_get_position(bs);\n\tgf_bs_write_u32(bs, 0);\n\n\tfor (i=0; i<count; i++) {\n\t\tu8 flags=0;\n\t\tu32 j, nb_segs, rep_start;\n\t\tu32 props_start;\n\t\tGF_MPD_SegmentURL *s;\n\t\tGF_DashStream *ds = gf_list_get(ctx->pids, i);\n\t\tif (!ds || !ds->rep || !ds->rep->res_url || !ds->rep->segment_list) continue;\n\n\t\tnb_reps++;\n\t\trep_start = (u32) gf_bs_get_position(bs);\n\t\tgf_bs_write_u32(bs, 0);\n\n\t\tgf_bs_write_utf8(bs, ds->rep->id);\n\t\tgf_bs_write_utf8(bs, ds->rep->res_url);\n\t\tgf_bs_write_u32(bs, ds->rep->trackID);\n\t\ts = gf_list_get(ds->rep->segment_list->segment_URLs, 0);\n\t\tgf_bs_write_u32(bs, s ? (u32) s->frag_start_offset : 0);\n\t\tgf_bs_write_u32(bs, ds->timescale);\n\t\tgf_bs_write_u32(bs, ds->rep->segment_list->timescale);\n\t\tgf_bs_write_u32(bs, ds->rep->bandwidth);\n\t\tgf_bs_write_u32(bs, (ds->pts_minus_cts<0) ? (u32) (-ds->pts_minus_cts) : 0);\n\t\tgf_bs_write_u32(bs, ds->rep->segment_list->sample_duration);\n\t\tgf_bs_write_u32(bs, ds->rep->segment_list->first_cts_offset);\n\t\tgf_bs_write_u32(bs, gf_list_count(ds->rep->segment_list->segment_URLs) );\n\n\t\tGF_MPD_SegmentURL *surl = gf_list_last(ds->rep->segment_list->segment_URLs);\n\t\tgf_bs_write_u8(bs, ds->set ? ds->set->starts_with_sap : ds->rep->starts_with_sap);\n\t\tif (surl->first_tfdt>0xFFFFFFFFUL) {\n\t\t\tflags |= 1;\n\t\t}\n\t\tif (surl->first_pck_seq>0xFFFFFFFFUL) {\n\t\t\tflags |= 1<<1;\n\t\t}\n\t\tif (ds->frag_start_offset) {\n\t\t\tflags |= 1<<2;\n\t\t\tif (surl->frag_start_offset > 0xFFFFFFFFUL) {\n\t\t\t\tflags |= 1<<3;\n\t\t\t}\n\t\t}\n\t\tif (ds->frag_first_ftdt) {\n\t\t\tflags |= 1<<4;\n\t\t\tif (surl->frag_tfdt > 0xFFFFFFFFUL) {\n\t\t\t\tflags |= 1<<5;\n\t\t\t}\n\t\t}\n\t\tif (ds->rep->segment_list->use_split_dur) {\n\t\t\tflags |= 1<<6;\n\t\t}\n\t\tgf_bs_write_u8(bs, flags);\n\t\tgf_bs_write_u16(bs, 0);\n\t\t//serialize all props\n\t\tprops_start = (u32) gf_bs_get_position(bs);\n\t\tgf_bs_write_u32(bs, 0);\n\n\t\tu32 idx=0;\n\t\twhile (1) {\n\t\t\tu32 k;\n\t\t\tu32 p4cc;\n\t\t\tconst char *pname;\n\t\t\tconst GF_PropertyValue *p = gf_filter_pid_enum_properties(ds->ipid, &idx, &p4cc, &pname);\n\t\t\tif (!p) break;\n\t\t\tswitch (p4cc) {\n\t\t\tcase GF_PROP_PID_ID:\n\t\t\tcase GF_PROP_PID_URL:\n\t\t\tcase GF_PROP_PID_FILEPATH:\n\t\t\tcase GF_PROP_PID_FILE_EXT:\n\t\t\tcase GF_PROP_PID_FILE_CACHED:\n\t\t\tcase GF_PROP_PID_DOWN_SIZE:\n\t\t\tcase GF_PROP_PID_DOWNLOAD_SESSION:\n\t\t\tcase GF_PROP_PID_TRACK_NUM:\n\t\t\tcase GF_PROP_PID_MEDIA_DATA_SIZE:\n\t\t\tcase GF_PROP_PID_MAX_FRAME_SIZE:\n\t\t\tcase GF_PROP_PID_AVG_FRAME_SIZE:\n\t\t\tcase GF_PROP_PID_MAX_TS_DELTA:\n\t\t\tcase GF_PROP_PID_CONSTANT_DURATION:\n\t\t\tcase GF_PROP_PID_PLAYBACK_MODE:\n\t\t\tcase GF_PROP_PID_CHAP_TIMES:\n\t\t\tcase GF_PROP_PID_CHAP_NAMES:\n\t\t\t\tcontinue;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (p->type == GF_PROP_POINTER) continue;\n\n\t\t\tif (p4cc) gf_bs_write_u32(bs, p4cc);\n\t\t\telse {\n\t\t\t\tgf_bs_write_u32(bs, 0);\n\t\t\t\tgf_bs_write_utf8(bs, pname);\n\t\t\t\tgf_bs_write_u32(bs, p->type);\n\t\t\t}\n\n\t\t\tswitch (p->type) {\n\t\t\tcase GF_PROP_SINT:\n\t\t\tcase GF_PROP_UINT:\n\t\t\tcase GF_PROP_4CC:\n\t\t\t\tgf_bs_write_u32(bs, p->value.uint);\n\t\t\t\tbreak;\n\t\t\tcase GF_PROP_LSINT:\n\t\t\tcase GF_PROP_LUINT:\n\t\t\t\tgf_bs_write_u64(bs, p->value.longuint);\n\t\t\t\tbreak;\n\t\t\tcase GF_PROP_BOOL:\n\t\t\t\tgf_bs_write_u8(bs, p->value.boolean ? 1 : 0);\n\t\t\t\tbreak;\n\t\t\tcase GF_PROP_FRACTION:\n\t\t\t\tgf_bs_write_u32(bs, p->value.frac.num);\n\t\t\t\tgf_bs_write_u32(bs, p->value.frac.den);\n\t\t\t\tbreak;\n\t\t\tcase GF_PROP_FRACTION64:\n\t\t\t\tgf_bs_write_u64(bs, p->value.lfrac.num);\n\t\t\t\tgf_bs_write_u64(bs, p->value.lfrac.den);\n\t\t\t\tbreak;\n\t\t\tcase GF_PROP_FLOAT:\n\t\t\t\tgf_bs_write_float(bs, FIX2FLT(p->value.fnumber) );\n\t\t\t\tbreak;\n\t\t\tcase GF_PROP_DOUBLE:\n\t\t\t\tgf_bs_write_double(bs, p->value.number);\n\t\t\t\tbreak;\n\t\t\tcase GF_PROP_VEC2I:\n\t\t\t\tgf_bs_write_u32(bs, p->value.vec2i.x);\n\t\t\t\tgf_bs_write_u32(bs, p->value.vec2i.y);\n\t\t\t\tbreak;\n\t\t\tcase GF_PROP_VEC2:\n\t\t\t\tgf_bs_write_double(bs, p->value.vec2.x);\n\t\t\t\tgf_bs_write_double(bs, p->value.vec2.y);\n\t\t\t\tbreak;\n\t\t\tcase GF_PROP_VEC3I:\n\t\t\t\tgf_bs_write_u32(bs, p->value.vec3i.x);\n\t\t\t\tgf_bs_write_u32(bs, p->value.vec3i.y);\n\t\t\t\tgf_bs_write_u32(bs, p->value.vec3i.z);\n\t\t\t\tbreak;\n\t\t\tcase GF_PROP_VEC4I:\n\t\t\t\tgf_bs_write_u32(bs, p->value.vec4i.x);\n\t\t\t\tgf_bs_write_u32(bs, p->value.vec4i.y);\n\t\t\t\tgf_bs_write_u32(bs, p->value.vec4i.z);\n\t\t\t\tgf_bs_write_u32(bs, p->value.vec4i.w);\n\t\t\t\tbreak;\n\t\t\tcase GF_PROP_STRING:\n\t\t\tcase GF_PROP_STRING_NO_COPY:\n\t\t\tcase GF_PROP_NAME:\n\t\t\t\tif (p4cc == GF_PROP_PID_DECODER_CONFIG_ENHANCEMENT) {\n\t\t\t\t\tu32 len = (u32) strlen(p->value.string)+1;\n\t\t\t\t\tgf_bs_write_u32(bs, len);\n\t\t\t\t\tgf_bs_write_data(bs, p->value.string, len);\n\t\t\t\t} else {\n\t\t\t\t\tgf_bs_write_utf8(bs, p->value.string);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase GF_PROP_DATA:\n\t\t\tcase GF_PROP_DATA_NO_COPY:\n\t\t\tcase GF_PROP_CONST_DATA:\n\t\t\t\tgf_bs_write_u32(bs, p->value.data.size);\n\t\t\t\tgf_bs_write_data(bs, p->value.data.ptr, p->value.data.size);\n\t\t\t\tbreak;\n\n\t\t\t//string list: memory is ALWAYS duplicated\n\t\t\tcase GF_PROP_STRING_LIST:\n\t\t\t\tgf_bs_write_u32(bs, p->value.string_list.nb_items);\n\t\t\t\tfor (k=0; k<p->value.string_list.nb_items; k++) {\n\t\t\t\t\tconst char *str = p->value.string_list.vals[k];\n\t\t\t\t\tgf_bs_write_utf8(bs, str);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase GF_PROP_UINT_LIST:\n\t\t\tcase GF_PROP_SINT_LIST:\n\t\t\tcase GF_PROP_4CC_LIST:\n\t\t\t\tgf_bs_write_u32(bs, p->value.uint_list.nb_items);\n\t\t\t\tfor (k=0; k<p->value.uint_list.nb_items; k++) {\n\t\t\t\t\tgf_bs_write_u32(bs, p->value.uint_list.vals[k]);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase GF_PROP_VEC2I_LIST:\n\t\t\t\tgf_bs_write_u32(bs, p->value.v2i_list.nb_items);\n\t\t\t\tfor (k=0; k<p->value.uint_list.nb_items; k++) {\n\t\t\t\t\tgf_bs_write_u32(bs, p->value.v2i_list.vals[k].x );\n\t\t\t\t\tgf_bs_write_u32(bs, p->value.v2i_list.vals[k].y );\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t//last prop\n\t\tgf_bs_write_u32(bs, 0xFFFFFFFF);\n\n\t\tpos = (u32) gf_bs_get_position(bs);\n\t\tu32 psize = pos - props_start;\n\t\tgf_bs_seek(bs, props_start);\n\t\tgf_bs_write_u32(bs, psize);\n\t\tgf_bs_seek(bs, pos);\n\n\t\t//serialize all segments\n\t\tnb_segs = gf_list_count(ds->rep->segment_list->segment_URLs);\n\t\tfor (j=0; j<nb_segs; j++) {\n\t\t\ts = gf_list_get(ds->rep->segment_list->segment_URLs, j);\n\n\t\t\tif (flags & 1) gf_bs_write_u64(bs, s->first_tfdt);\n\t\t\telse gf_bs_write_u32(bs, (u32) s->first_tfdt);\n\n\t\t\tif (flags & (1<<1)) gf_bs_write_u64(bs, s->first_pck_seq);\n\t\t\telse gf_bs_write_u32(bs, (u32) s->first_pck_seq);\n\n\t\t\tgf_bs_write_u32(bs, (u32) s->duration);\n\n\t\t\tif (flags & (1<<2)) {\n\t\t\t\tif (flags & (1<<3)) gf_bs_write_u64(bs, s->frag_start_offset);\n\t\t\t\telse gf_bs_write_u32(bs, (u32) s->frag_start_offset);\n\t\t\t}\n\t\t\tif (flags & (1<<4)) {\n\t\t\t\tif (flags & (1<<5)) gf_bs_write_u64(bs, s->frag_tfdt);\n\t\t\t\telse gf_bs_write_u32(bs, (u32) s->frag_tfdt);\n\t\t\t}\n\t\t\tif (flags & (1<<6)) {\n\t\t\t\tgf_bs_write_u32(bs, s->split_first_dur);\n\t\t\t\tgf_bs_write_u32(bs, s->split_last_dur);\n\t\t\t}\n\t\t}\n\n\t\tpos = (u32) gf_bs_get_position(bs);\n\t\tpsize = pos - rep_start;\n\t\tgf_bs_seek(bs, rep_start);\n\t\tgf_bs_write_u32(bs, psize);\n\t\tgf_bs_seek(bs, pos);\n\t}\n\n\tpos = (u32) gf_bs_get_position(bs);\n\tgf_bs_seek(bs, nb_rep_pos);\n\tgf_bs_write_u32(bs, nb_reps);\n\tgf_bs_seek(bs, pos);\n\n\tGF_FilterPacket *dst = gf_filter_pck_new_alloc(opid, 1, &data);\n\tgf_free(data);\n\tu32 osize;\n\tgf_bs_get_content(bs, &data, &osize);\n\tgf_filter_pck_check_realloc(dst, data, osize);\n\tgf_filter_pck_set_framing(dst, GF_TRUE, GF_TRUE);\n\tgf_filter_pck_send(dst);\n\tgf_bs_del(bs);\n\tctx->mpd->segment_template = NULL;\n\treturn GF_OK;\n}\n\n\nstatic GF_Err dasher_write_and_send_manifest(GF_DasherCtx *ctx, u64 last_period_dur, Bool do_m3u8, Bool m3u8_second_pass, GF_FilterPid *opid, char *alt_name)\n{\n\tvoid *last_signature;\n\tu8 sig[GF_SHA1_DIGEST_SIZE];\n\tGF_Err e;\n\tFILE *tmp;\n\n\tctx->mpd->segment_template = ctx->template;\n\tif (ctx->do_index==1) {\n\t\treturn dasher_write_index(ctx, opid);\n\t}\n\tif (ctx->from_index)\n\t\tctx->mpd->m3u8_use_repid = GF_TRUE;\n\n\ttmp = gf_file_temp(NULL);\n\tif (do_m3u8) {\n\t\tGF_M3U8WriteMode mode = GF_M3U8_WRITE_ALL;\n\t\tif (ctx->from_index==IDXMODE_MANIFEST) mode = GF_M3U8_WRITE_MASTER;\n\t\telse if (ctx->from_index==IDXMODE_CHILD) mode = GF_M3U8_WRITE_CHILD;\n\n\t\tctx->mpd->m3u8_time = ctx->hlsc;\n\t\tctx->mpd->nb_hls_ext_master = ctx->hlsx.nb_items;\n\t\tctx->mpd->hls_ext_master = (const char **) ctx->hlsx.vals;\n\t\tctx->mpd->llhls_preload = ctx->ll_preload_hint;\n\t\tctx->mpd->llhls_rendition_reports = ctx->ll_rend_rep;\n\t\tctx->mpd->llhls_part_holdback = ctx->ll_part_hb;\n\t\tctx->mpd->hls_abs_url = ctx->hls_absu;\n\n\t\tif (ctx->llhls==3)\n\t\t\tctx->mpd->force_llhls_mode = m3u8_second_pass ? 2 : 1;\n\t\telse\n\t\t\tctx->mpd->force_llhls_mode = 0;\n\n\t\tif (m3u8_second_pass) {\n\t\t\te = gf_mpd_write_m3u8_master_playlist(ctx->mpd, tmp, ctx->out_path, gf_list_last(ctx->mpd->periods), mode);\n\t\t} else {\n\t\t\te = gf_mpd_write_m3u8_master_playlist(ctx->mpd, tmp, ctx->out_path, gf_list_last(ctx->mpd->periods), mode);\n\t\t}\n\t} else {\n\t\te = gf_mpd_write(ctx->mpd, tmp, ctx->cmpd);\n\t}\n\tctx->mpd->segment_template = NULL;\n\n\tif (e) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_DASH, (\"[Dasher] failed to write %s file: %s\\n\", do_m3u8 ? \"M3U8\" : \"MPD\", gf_error_to_string(e) ));\n\t\tgf_fclose(tmp);\n\t\tif (ctx->current_period->period)\n\t\t\tctx->current_period->period->duration = last_period_dur;\n\t\treturn e;\n\t}\n\n\tif (ctx->profile == GF_DASH_PROFILE_HBBTV_1_5_ISOBMF_LIVE) {\n\t\tif (gf_ftell(tmp) > 100 * 1024)\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_DASH, (\"[Dasher] manifest MPD is too big for HbbTV 1.5. Limit is 100kB, current size is \"LLU\"kB\\n\", gf_ftell(tmp) / 1024));\n\t}\n\n\tgf_sha1_file_ptr(tmp, sig);\n\tif (do_m3u8) {\n\t\tlast_signature = (void *) m3u8_second_pass ? ctx->last_hls2_signature : ctx->last_hls_signature;\n\t} else {\n\t\tlast_signature = (void *) ctx->last_mpd_signature;\n\t}\n\n\tif (memcmp(sig, last_signature, GF_SHA1_DIGEST_SIZE)) {\n\t\tmemcpy(last_signature, sig, GF_SHA1_DIGEST_SIZE);\n\n\t\tif (ctx->from_index!=IDXMODE_CHILD)\n\t\t\tdasher_transfer_file(tmp, opid, alt_name, NULL);\n\t}\n\tgf_fclose(tmp);\n\treturn GF_OK;\n}\n\nstatic void dasher_update_dyn_bitrates(GF_DasherCtx *ctx)\n{\n\tu32 i, count = gf_list_count(ctx->current_period->streams);\n\tfor (i=0; i<count; i++) {\n\t\tGF_DashStream *ds = gf_list_get(ctx->current_period->streams, i);\n\t\tif (ds->dyn_bitrate) dasher_update_bitrate(ctx, ds);\n\t}\n}\n\nGF_Err dasher_send_manifest(GF_Filter *filter, GF_DasherCtx *ctx, Bool for_mpd_only)\n{\n\tGF_Err e;\n\tu32 i, max_opid;\n\tFILE *tmp;\n\tu64 store_mpd_dur=0;\n\tu64 max_seg_dur=0;\n\tu64 last_period_dur;\n\n\t//manifest forwarding\n\tif (ctx->forward_mode == DASHER_FWD_ALL)\n\t\treturn GF_OK;\n\n\tif (ctx->from_index>=IDXMODE_INIT)\n\t\treturn GF_OK;\n\n\tif (ctx->dyn_rate)\n\t\tdasher_update_dyn_bitrates(ctx);\n\n\t//UGLY PATCH, to remove - we don't have the same algos in old arch and new arch, which result in slightly different max segment duration\n\t//on audio for our test suite - patch it manually to avoid hash failures :(\n\t//TODO, remove as soon as we switch archs\n\tif (gf_sys_old_arch_compat() && (ctx->mpd->max_segment_duration==1022) && (ctx->mpd->media_presentation_duration==10160) ) {\n\t\tctx->mpd->max_segment_duration = 1080;\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_DASH, (\"[Dasher] patch for old regression tests hit, changing max seg dur from 1022 to 1080\\nPlease notify GPAC devs to remove this, and do not use fot_test modes in dash filter\\n\"));\n\t}\n\n\tctx->mpd->publishTime = dasher_get_utc(ctx);\n\tif (ctx->utc_timing_type==DASHER_UTCREF_INBAND) {\n\t\tGF_MPD_Descriptor *d = gf_list_get(ctx->mpd->utc_timings, 0);\n\t\tif (d) {\n\t\t\ttime_t gtime;\n\t\t\tstruct tm *t;\n\t\t\tu32 sec;\n\t\t\tu32 ms;\n\t\t\tchar szTime[100];\n\t\t\tif (d->value) gf_free(d->value);\n\n\t\t\tgtime = ctx->mpd->publishTime / 1000;\n\t\t\tsec = (u32)(ctx->mpd->publishTime / 1000);\n\t\t\tms = (u32)(ctx->mpd->publishTime - ((u64)sec) * 1000);\n\n\t\t\tt = gf_gmtime(&gtime);\n\t\t\tsec = t->tm_sec;\n\t\t\t//see issue #859, no clue how this happened...\n\t\t\tif (sec > 60)\n\t\t\t\tsec = 60;\n\t\t\tsnprintf(szTime, 100, \"%d-%02d-%02dT%02d:%02d:%02d.%03dZ\", 1900 + t->tm_year, t->tm_mon + 1, t->tm_mday, t->tm_hour, t->tm_min, sec, ms);\n\t\t\td->value = gf_strdup(szTime);\n\t\t}\n\t}\n\n\tdasher_update_mpd(ctx);\n\tctx->mpd->write_context = GF_FALSE;\n\tctx->mpd->was_dynamic = GF_FALSE;\n\tif (ctx->dmode==GF_DASH_DYNAMIC_LAST)\n\t\tctx->mpd->was_dynamic = GF_TRUE;\n\n\tif ((ctx->refresh>=0) && (ctx->dmode==GF_DASH_DYNAMIC)) {\n\t\tstore_mpd_dur= ctx->mpd->media_presentation_duration;\n\t}\n\n\tif (ctx->sseg && ctx->mpd->max_segment_duration) {\n\t\tmax_seg_dur = ctx->mpd->max_subsegment_duration = ctx->mpd->max_segment_duration;\n\t\tctx->mpd->max_segment_duration = 0;\n\t}\n\n\tlast_period_dur = 0;\n\tif (ctx->current_period->period) {\n\t\tlast_period_dur = ctx->current_period->period->duration;\n\t\tif (ctx->dmode==GF_DASH_DYNAMIC) {\n\t\t\tctx->current_period->period->duration = 0;\n\t\t\tctx->mpd->media_presentation_duration = 0;\n\t\t}\n\t}\n\n\tif (ctx->index_max_seg_dur) {\n\t\tctx->mpd->max_segment_duration = ctx->index_max_seg_dur;\n\t\tctx->mpd->allow_empty_reps = 1;\n\t}\n\tif (ctx->index_media_duration)\n\t\tctx->mpd->media_presentation_duration = ctx->index_media_duration;\n\n\tmax_opid = (ctx->dual && ctx->opid_alt) ? 2 : 1;\n\tfor (i=0; i < max_opid; i++) {\n\t\tBool do_m3u8 = GF_FALSE;\n\t\tGF_FilterPid *opid;\n\n\t\tif (i==0) {\n\t\t\tif (max_opid>1) {\n\t\t\t\tdo_m3u8 = ctx->opid_alt_m3u8 ? GF_FALSE : GF_TRUE;\n\t\t\t} else {\n\t\t\t\tdo_m3u8 = ctx->do_m3u8;\n\t\t\t}\n\t\t\topid = ctx->opid;\n\t\t} else {\n\t\t\tdo_m3u8 = ctx->opid_alt_m3u8;\n\t\t\topid = ctx->opid_alt;\n\t\t}\n\t\tif (do_m3u8 && for_mpd_only) {\n\t\t\tcontinue;\n\t\t}\n\t\tif ((ctx->llhls==3) && do_m3u8)\n\t\t\tctx->mpd->force_llhls_mode = 1;\n\t\te = dasher_write_and_send_manifest(ctx, last_period_dur, do_m3u8, GF_FALSE, opid, NULL);\n\t\tif (e) return e;\n\n\t\tctx->mpd->force_llhls_mode = 0;\n\t}\n\n\tif (ctx->current_period->period)\n\t\tctx->current_period->period->duration = last_period_dur;\n\n\tif (store_mpd_dur) {\n\t\tctx->mpd->media_presentation_duration = store_mpd_dur;\n\t}\n\n\tif (max_seg_dur) {\n\t\tctx->mpd->max_segment_duration = (u32) max_seg_dur;\n\t\tctx->mpd->max_subsegment_duration = 0;\n\t}\n\tif (ctx->def_max_seg_dur)\n\t\tctx->mpd->max_segment_duration = (u32) ctx->def_max_seg_dur;\n\n\tif (ctx->do_m3u8) {\n\t\tBool m3u8_second_pass = GF_FALSE;\n\t\tu32 j;\n\t\tGF_MPD_Period *period = gf_list_last(ctx->mpd->periods);\n\t\tGF_MPD_AdaptationSet *as;\n\t\tGF_MPD_Representation *rep;\n\t\tGF_FilterPid *opid;\n\t\tassert(period);\n\t\tif (ctx->opid_alt_m3u8) opid = ctx->opid_alt;\n\t\telse opid = ctx->opid;\n\nresend:\n\t\ti=0;\n\t\twhile ( (as = (GF_MPD_AdaptationSet *) gf_list_enum(period->adaptation_sets, &i))) {\n\t\t\tj=0;\n\t\t\twhile ( (rep = (GF_MPD_Representation *) gf_list_enum(as->representations, &j))) {\n\t\t\t\tif (rep->m3u8_var_file) {\n\t\t\t\t\tGF_DashStream *ds;\n\t\t\t\t\tchar *outfile = rep->m3u8_var_name;\n\t\t\t\t\tBool do_free = GF_FALSE;\n\n\t\t\t\t\tif (rep->m3u8_name) {\n\t\t\t\t\t\toutfile = (char *) rep->m3u8_name;\n\t\t\t\t\t\tif (ctx->out_path && (ctx->from_index<=IDXMODE_ALL)) {\n\t\t\t\t\t\t\toutfile = gf_url_concatenate(ctx->out_path, rep->m3u8_name);\n\t\t\t\t\t\t\tdo_free = GF_TRUE;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (m3u8_second_pass) {\n\t\t\t\t\t\tchar *sep;\n\t\t\t\t\t\tchar *new_name = gf_strdup(outfile);\n\n\t\t\t\t\t\tsep = gf_file_ext_start(new_name);\n\t\t\t\t\t\tif (sep) sep[0] = 0;\n\t\t\t\t\t\tgf_dynstrcat(&new_name, \"_IF\", NULL);\n\t\t\t\t\t\tsep = gf_file_ext_start(outfile);\n\t\t\t\t\t\tif (sep)\n\t\t\t\t\t\t\tgf_dynstrcat(&new_name, sep, NULL);\n\n\t\t\t\t\t\tif (do_free) gf_free(outfile);\n\t\t\t\t\t\toutfile = new_name;\n\t\t\t\t\t\tdo_free = GF_TRUE;\n\t\t\t\t\t}\n\t\t\t\t\tds = rep->playback.udta;\n\t\t\t\t\tdasher_transfer_file(rep->m3u8_var_file, opid, outfile, ds);\n\t\t\t\t\tgf_fclose(rep->m3u8_var_file);\n\t\t\t\t\trep->m3u8_var_file = NULL;\n\t\t\t\t\tif (do_free) gf_free(outfile);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ((ctx->llhls==3) && !m3u8_second_pass && ctx->out_path) {\n\t\t\tchar *sep;\n\t\t\tchar szAltName[GF_MAX_PATH];\n\t\t\tstrcpy(szAltName, ctx->out_path);\n\t\t\tsep = gf_file_ext_start(szAltName);\n\t\t\tif (sep) sep[0] = 0;\n\t\t\tstrcat(szAltName, \"_IF\");\n\t\t\tsep = gf_file_ext_start(ctx->out_path);\n\t\t\tif (sep) strcat(szAltName, sep);\n\n\t\t\tctx->mpd->force_llhls_mode = 2;\n\t\t\te = dasher_write_and_send_manifest(ctx, last_period_dur, GF_TRUE, GF_TRUE, ctx->opid, szAltName);\n\t\t\tif (e) return e;\n\n\t\t\tm3u8_second_pass = GF_TRUE;\n\t\t\tgoto resend;\n\n\t\t}\n\t}\n\n\n\tif (ctx->state) {\n\t\ttmp = gf_fopen(ctx->state, \"w\");\n\t\tif (!tmp) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_DASH, (\"[Dasher] failed to open context MPD %s for write\\n\", ctx->state ));\n\t\t\treturn GF_IO_ERR;\n\t\t}\n\t\tctx->mpd->write_context = GF_TRUE;\n\t\te = gf_mpd_write(ctx->mpd, tmp, ctx->cmpd);\n\t\tgf_fclose(tmp);\n\t\tctx->mpd->write_context = GF_FALSE;\n\t\tif (e) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_DASH, (\"[Dasher] failed to write MPD file: %s\\n\", gf_error_to_string(e) ));\n\t\t}\n\t}\n\n\tif (ctx->def_max_seg_dur)\n\t\tctx->mpd->max_segment_duration = 0;\n\treturn GF_OK;\n}\n\nstatic void dasher_reset_stream(GF_Filter *filter, GF_DashStream *ds, Bool is_destroy)\n{\n\t//we do not remove the destination filter, it will be removed automatically once all remove_pids are called\n\t//removing it explicitly will discard the upper chain and any packets not yet processed\n\n\tds->dst_filter = NULL;\n\tif (ds->seg_template) gf_free(ds->seg_template);\n\tif (ds->idx_template) gf_free(ds->idx_template);\n\tif (ds->init_seg) gf_free(ds->init_seg);\n\tif (ds->multi_pids) gf_list_del(ds->multi_pids);\n\tds->multi_pids = NULL;\n\tif (ds->multi_tracks) gf_list_del(ds->multi_tracks);\n\tds->multi_tracks = NULL;\n\n\tif (ds->pending_segment_urls) gf_list_del(ds->pending_segment_urls);\n\tds->pending_segment_urls = NULL;\n\tif (ds->pending_segment_states) gf_list_del(ds->pending_segment_states);\n\tds->pending_segment_states = NULL;\n\n\tif (is_destroy) {\n\t\tif (ds->cues) gf_free(ds->cues);\n\t\tgf_list_del(ds->complementary_streams);\n\t\tgf_free(ds->rep_id);\n\t\t//string properties are locally copied\n#define RESET_PROP_STR(_prop) \\\n\t\tif (_prop) gf_free(_prop);\n\n\t\tRESET_PROP_STR(ds->src_url)\n\t\tRESET_PROP_STR(ds->template)\n\t\tRESET_PROP_STR(ds->lang)\n\t\tRESET_PROP_STR(ds->hls_vp_name)\n\t\tRESET_PROP_STR(ds->xlink)\n\t\tRESET_PROP_STR(ds->period_id)\n\t\tRESET_PROP_STR(ds->period_continuity_id)\n\n#undef RESET_PROP_STR\n\t\treturn;\n\t}\n\tds->init_seg = ds->seg_template = ds->idx_template = NULL;\n\tds->split_set_names = GF_FALSE;\n\tds->nb_sap_3 = 0;\n\tds->nb_sap_4 = 0;\n\tds->pid_id = 0;\n\tds->force_timescale = 0;\n\tds->set = NULL;\n\tds->owns_set = GF_FALSE;\n\tds->rep = NULL;\n\tds->muxed_base = NULL;\n\tds->nb_comp = ds->nb_comp_done = 0;\n\tgf_list_reset(ds->complementary_streams);\n\tds->inband_params = 0;\n\tds->seg_start_time = 0;\n\tds->seg_number = ds->startNumber;\n\tds->nb_segments_purged = 0;\n\tds->dur_purged = 0;\n\tds->moof_sn_inc = 0;\n\tds->moof_sn = 0;\n\tds->seg_done = 0;\n\tds->subdur_done = 0;\n\tif (ds->packet_queue) {\n\t\twhile (gf_list_count(ds->packet_queue)) {\n\t\t\tGF_FilterPacket *pck = gf_list_pop_front(ds->packet_queue);\n\t\t\tgf_filter_pck_unref(pck);\n\t\t}\n\t\tds->nb_sap_in_queue = 0;\n\t}\n\tds->forced_period_switch = GF_FALSE;\n}\n\nvoid dasher_context_update_period_end(GF_DasherCtx *ctx)\n{\n\tu32 i, count;\n\n\tif (!ctx->mpd) return;\n\n\tcount = gf_list_count(ctx->current_period->streams);\n\tfor (i=0; i<count; i++) {\n\t\tGF_DashStream *ds = gf_list_get(ctx->current_period->streams, i);\n\t\tif (!ds->rep) continue;\n\t\tif (!ds->rep->dasher_ctx) continue;\n\t\tif (ds->done == 1) {\n\t\t\tds->rep->dasher_ctx->done = 1;\n\t\t} else {\n\t\t\t//store all dynamic parameters of the rep\n\t\t\tds->rep->dasher_ctx->last_pck_idx = ds->nb_pck;\n\t\t\tds->seek_to_pck = ds->nb_pck;\n\t\t\tds->rep->dasher_ctx->seg_number = ds->seg_number;\n\t\t\tds->rep->dasher_ctx->next_seg_start = ds->next_seg_start;\n\t\t\tds->rep->dasher_ctx->first_cts = ds->first_cts;\n\t\t\tds->rep->dasher_ctx->first_dts = ds->first_dts;\n\t\t\tds->rep->dasher_ctx->ts_offset = ds->ts_offset;\n\t\t\tds->rep->dasher_ctx->segs_purged = ds->nb_segments_purged;\n\t\t\tds->rep->dasher_ctx->dur_purged = ds->dur_purged;\n\t\t\tds->rep->dasher_ctx->moof_sn = ds->moof_sn;\n\t\t\tds->rep->dasher_ctx->moof_sn_inc = ds->moof_sn_inc;\n\t\t\tds->rep->dasher_ctx->subdur_forced = ds->subdur_forced_use_period_dur ? GF_TRUE : GF_FALSE;\n\t\t}\n\t\tif (ctx->subdur) {\n\t\t\tds->rep->dasher_ctx->cumulated_subdur = ds->cumulated_subdur + ctx->subdur;\n\t\t\tds->rep->dasher_ctx->cumulated_dur = ((Double)ds->cumulated_dur) / ds->timescale;\n\n\t\t}\n\t\tds->rep->dasher_ctx->nb_repeat = ds->nb_repeat;\n\t\tds->rep->dasher_ctx->est_next_dts = ds->est_next_dts;\n\t\tds->rep->dasher_ctx->source_pid = ds->id;\n\t\tds->rep->dasher_ctx->mpd_timescale = ds->mpd_timescale;\n\t\tds->rep->dasher_ctx->last_dyn_period_id = ctx->last_dyn_period_id;\n\n\t\tassert(ds->rep->dasher_ctx->init_seg);\n\t\tassert(ds->rep->dasher_ctx->src_url);\n\t\tassert(ds->rep->dasher_ctx->template_seg);\n\t}\n}\n\nvoid dasher_context_update_period_start(GF_DasherCtx *ctx)\n{\n\tu32 i, j, count;\n\n\tif (!ctx->mpd) return;\n\tcount = gf_list_count(ctx->current_period->streams);\n\tfor (i=0; i<count; i++) {\n\t\tGF_DashStream *ds = gf_list_get(ctx->current_period->streams, i);\n\t\tif (!ds->rep) continue;\n\t\tif (ds->rep->dasher_ctx) continue;\n\n\t\t//store all static parameters of the rep\n\t\tGF_SAFEALLOC(ds->rep->dasher_ctx, GF_DASH_SegmenterContext);\n\t\tif (!ds->rep->dasher_ctx) return;\n\n\t\tds->rep->dasher_ctx->done = 0;\n\n\t\tassert(ds->init_seg);\n\t\tds->rep->dasher_ctx->init_seg = gf_strdup(ds->init_seg);\n\t\tassert(ds->src_url);\n\t\tds->rep->dasher_ctx->src_url = gf_strdup(ds->src_url);\n\t\tassert(ds->seg_template);\n\t\tds->rep->dasher_ctx->template_seg = gf_strdup(ds->seg_template);\n\t\tif (ds->idx_template)\n\t\t\tds->rep->dasher_ctx->template_idx = gf_strdup(ds->idx_template);\n\n\t\tds->rep->dasher_ctx->pid_id = ds->pid_id;\n\t\tds->rep->dasher_ctx->dep_pid_id = ds->dep_pid_id;\n\t\tds->rep->dasher_ctx->period_start = ds->period_start;\n\t\tds->rep->dasher_ctx->period_duration = ds->period_dur;\n\t\tds->rep->dasher_ctx->multi_pids = ds->multi_pids ? GF_TRUE : GF_FALSE;\n\t\tds->rep->dasher_ctx->dash_dur = ds->dash_dur;\n\n\t\tif (strcmp(ds->period_id, DEFAULT_PERIOD_ID))\n\t\t\tds->rep->dasher_ctx->period_id = ds->period_id;\n\n\t\tds->rep->dasher_ctx->owns_set = (ds->set->udta == ds) ? GF_TRUE : GF_FALSE;\n\n\t\tif (ds->rep->dasher_ctx->mux_pids) gf_free(ds->rep->dasher_ctx->mux_pids);\n\t\tds->rep->dasher_ctx->mux_pids = NULL;\n\t\tfor (j=0; j<count; j++) {\n\t\t\tchar szMuxPID[10];\n\t\t\tGF_DashStream *a_ds = gf_list_get(ctx->current_period->streams, j);\n\t\t\tif (a_ds==ds) continue;\n\t\t\tif (a_ds->muxed_base != ds) continue;\n\n\t\t\tif (ds->rep->dasher_ctx->mux_pids)\n\t\t\t\tsprintf(szMuxPID, \" %d\", a_ds->id);\n\t\t\telse\n\t\t\t\tsprintf(szMuxPID, \"%d\", a_ds->id);\n\n\t\t\tgf_dynstrcat(&ds->rep->dasher_ctx->mux_pids, szMuxPID, NULL);\n\t\t}\n\n\t}\n}\n\nstatic GF_DashStream *dasher_get_stream(GF_DasherCtx *ctx, const char *src_url, u32 original_pid, u32 pid_id)\n{\n\tu32 i, count = gf_list_count(ctx->pids);\n\tfor (i=0; i<count; i++) {\n\t\tGF_DashStream *ds = gf_list_get(ctx->pids, i);\n\t\tif (pid_id && (ds->pid_id==pid_id)) return ds;\n\t\tif (src_url && ds->src_url && !strcmp(ds->src_url, src_url) && (ds->id == original_pid) ) return ds;\n\t}\n\treturn NULL;\n}\n\nstatic GF_Err dasher_reload_muxed_comp(GF_DasherCtx *ctx, GF_DashStream *base_ds, char *mux_pids, Bool check_only)\n{\n\tGF_Err e = GF_OK;\n\twhile (mux_pids) {\n\t\tu32 pid_id;\n\t\tGF_DashStream *ds;\n\t\tchar *sep = strchr(mux_pids, ' ');\n\t\tif (sep) sep[0] = 0;\n\n\t\tpid_id = atoi(mux_pids);\n\t\tds = dasher_get_stream(ctx, base_ds->src_url, pid_id, 0);\n\t\tif (ds) {\n\t\t\tif (!check_only) {\n\t\t\t\tif (ds->rep) gf_mpd_representation_free(ds->rep);\n\t\t\t\tds->rep = NULL;\n\t\t\t\tds->set = base_ds->set;\n\t\t\t\tds->muxed_base = base_ds;\n\t\t\t\tbase_ds->nb_comp ++;\n\t\t\t\tds->nb_comp = 1;\n\t\t\t\tds->done = base_ds->done;\n\t\t\t\tds->subdur_done = base_ds->subdur_done;\n\t\t\t\tds->period = ctx->current_period;\n\n\t\t\t\tgf_list_del_item(ctx->next_period->streams, ds);\n\t\t\t\tgf_list_add(ctx->current_period->streams, ds);\n\t\t\t}\n\t\t} else {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_DASH, (\"[Dasher] Couldn't find muxed PID %d in source %s, did you modify the source ?\\n\", pid_id, base_ds->src_url));\n\t\t\te = GF_BAD_PARAM;\n\t\t}\n\n\t\tif (!sep) break;\n\t\tsep[0] = ' ';\n\t\tmux_pids = sep+1;\n\n\t\tif (e) return e;\n\t}\n\treturn GF_OK;\n}\n\nstatic GF_Err dasher_reload_context(GF_Filter *filter, GF_DasherCtx *ctx)\n{\n\tGF_Err e;\n\tBool last_period_active = GF_FALSE;\n\tu32 i, j, k, nb_p, nb_as, nb_rep, count;\n\tGF_DOMParser *mpd_parser;\n\n\tctx->first_context_load = GF_FALSE;\n\n\tif (!gf_file_exists(ctx->state)) return GF_OK;\n\n\t/* parse the MPD */\n\tmpd_parser = gf_xml_dom_new();\n\te = gf_xml_dom_parse(mpd_parser, ctx->state, NULL, NULL);\n\n\tif (e != GF_OK) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_DASH, (\"[Dasher] Cannot parse MPD state %s: %s\\n\", ctx->state, gf_xml_dom_get_error(mpd_parser) ));\n\t\tgf_xml_dom_del(mpd_parser);\n\t\treturn GF_URL_ERROR;\n\t}\n\tif (ctx->mpd) gf_mpd_del(ctx->mpd);\n\tctx->mpd = gf_mpd_new();\n\te = gf_mpd_init_from_dom(gf_xml_dom_get_root(mpd_parser), ctx->mpd, ctx->state);\n\tgf_xml_dom_del(mpd_parser);\n\t//test mode, strip URL path\n\tif (gf_sys_is_test_mode()) {\n\t\tcount = gf_list_count(ctx->mpd->program_infos);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tGF_MPD_ProgramInfo *info = gf_list_get(ctx->mpd->program_infos, i);\n\t\t\tif (info->title && strstr(info->title, \"generated by GPAC\")) {\n\t\t\t\tgf_free(info->title);\n\t\t\t\tchar tmp[256];\n\t\t\t\tchar *name = strrchr(ctx->out_path, '/');\n\t\t\t\tif (!name) name = strrchr(ctx->out_path, '\\\\');\n\t\t\t\tif (!name) name = ctx->out_path;\n\t\t\t\telse name++;\n\t\t\t\tsprintf(tmp, \"%s generated by GPAC\", name);\n\t\t\t\tinfo->title = gf_strdup(tmp);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!ctx->mpd->xml_namespace)\n\t\tctx->mpd->xml_namespace = \"urn:mpeg:dash:schema:mpd:2011\";\n\n\tif (e != GF_OK) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_DASH, (\"[Dasher] Cannot reload MPD state %s: %s\\n\", ctx->state, gf_error_to_string(e) ));\n\t\tgf_mpd_del(ctx->mpd);\n\t\tctx->mpd = NULL;\n\t\treturn GF_URL_ERROR;\n\t}\n\n\t//do a first pass to detect any potential changes in input config, if so consider the period over.\n\tnb_p = gf_list_count(ctx->mpd->periods);\n\tfor (i=0; i<nb_p; i++) {\n\t\tu32 nb_done_in_period = 0;\n\t\tu32 nb_remain_in_period = 0;\n\t\tGF_MPD_Period *p = gf_list_get(ctx->mpd->periods, i);\n\t\tnb_as = gf_list_count(p->adaptation_sets);\n\t\tfor (j=0; j<nb_as; j++) {\n\t\t\tGF_MPD_AdaptationSet *set = gf_list_get(p->adaptation_sets, j);\n\t\t\tnb_rep = gf_list_count(set->representations);\n\t\t\tfor (k=0; k<nb_rep; k++) {\n\t\t\t\tGF_DashStream *ds;\n\t\t\t\tchar *p_id;\n\t\t\t\tGF_MPD_Representation *rep = gf_list_get(set->representations, k);\n\t\t\t\tif (! rep->dasher_ctx) continue;\n\n\t\t\t\t//ensure we have the same settings - if not consider the dash stream has been resetup for a new period\n\t\t\t\tds = dasher_get_stream(ctx, rep->dasher_ctx->src_url, rep->dasher_ctx->source_pid, 0);\n\t\t\t\tif (!ds) {\n\t\t\t\t\trep->dasher_ctx->done = 1;\n\t\t\t\t\tnb_done_in_period++;\n\t\t\t\t\tif (rep->dasher_ctx->last_dyn_period_id >= ctx->last_dyn_period_id)\n\t\t\t\t\t\tctx->last_dyn_period_id = 1 + rep->dasher_ctx->last_dyn_period_id;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (rep->dasher_ctx->done) {\n\t\t\t\t\tnb_done_in_period++;\n\t\t\t\t\tds->nb_repeat = rep->dasher_ctx->nb_repeat + 1;\n\t\t\t\t\tif (rep->dasher_ctx->last_dyn_period_id > ctx->last_dyn_period_id)\n\t\t\t\t\t\tctx->last_dyn_period_id = rep->dasher_ctx->last_dyn_period_id;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tp_id = DEFAULT_PERIOD_ID;\n\t\t\t\tif (rep->dasher_ctx->period_id) p_id = rep->dasher_ctx->period_id;\n\n\t\t\t\tif (ds->period_id && p_id && !strcmp(ds->period_id, p_id)) {\n\t\t\t\t} else if (!ds->period_id && !rep->dasher_ctx->period_id) {\n\t\t\t\t} else {\n\t\t\t\t\trep->dasher_ctx->done = 1;\n\t\t\t\t\tnb_done_in_period++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (ds->period_start.num * rep->dasher_ctx->period_start.den != rep->dasher_ctx->period_start.num * ds->period_start.den) {\n\t\t\t\t\trep->dasher_ctx->done = 1;\n\t\t\t\t\tnb_done_in_period++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (ds->period_dur.num * rep->dasher_ctx->period_duration.den != rep->dasher_ctx->period_duration.num * ds->period_dur.den) {\n\t\t\t\t\trep->dasher_ctx->done = 1;\n\t\t\t\t\tnb_done_in_period++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t//check we can reload muxed components - if not consider this source as removed\n\t\t\t\tif (rep->dasher_ctx->mux_pids) {\n\t\t\t\t\te = dasher_reload_muxed_comp(ctx, ds, rep->dasher_ctx->mux_pids, GF_TRUE);\n\t\t\t\t\tif (e) {\n\t\t\t\t\t\trep->dasher_ctx->done = 1;\n\t\t\t\t\t\tnb_done_in_period++;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tnb_remain_in_period++;\n\t\t\t}\n\t\t}\n\t\tif (nb_remain_in_period) {\n\t\t\tassert(i+1==nb_p);\n\t\t\tlast_period_active = GF_TRUE;\n\t\t}\n\t\telse if (nb_done_in_period && ctx->subdur  ) {\n\t\t\t//we are done but we loop the entire streams\n\t\t\tfor (j=0; j<gf_list_count(ctx->pids); j++) {\n\t\t\t\tGF_DashStream *ds = gf_list_get(ctx->pids, j);\n\t\t\t\tds->done = 0;\n\t\t\t\tds->segment_started = GF_FALSE;\n\t\t\t\tds->seg_done = GF_FALSE;\n\t\t\t\tds->cumulated_dur = 0;\n\t\t\t\tds->cumulated_subdur = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!last_period_active) return GF_OK;\n\tctx->current_period->period = gf_list_last(ctx->mpd->periods);\n\tgf_list_reset(ctx->current_period->streams);\n\tgf_list_del(ctx->next_period->streams);\n\tctx->next_period->streams = gf_list_clone(ctx->pids);\n\n\tif (ctx->current_period->period->duration) {\n\t\t//reset last period duration and cumulated dur of MPD\n\t\tif (ctx->mpd->media_presentation_duration>ctx->current_period->period->duration)\n\t\t\tctx->mpd->media_presentation_duration -= ctx->current_period->period->duration;\n\t\telse\n\t\t\tctx->mpd->media_presentation_duration = 0;\n\t\tctx->current_period->period->duration = 0;\n\t}\n\n\tnb_as = gf_list_count(ctx->current_period->period->adaptation_sets);\n\tfor (j=0; j<nb_as; j++) {\n\t\tGF_DashStream *set_ds = NULL;\n\t\tGF_List *multi_pids = NULL;\n\t\tBool use_multi_pid_init = GF_FALSE;\n\t\tGF_MPD_AdaptationSet *set = gf_list_get(ctx->current_period->period->adaptation_sets, j);\n\t\tnb_rep = gf_list_count(set->representations);\n\t\tfor (k=0; k<nb_rep; k++) {\n\t\t\tGF_DashStream *ds;\n\t\t\tGF_MPD_Representation *rep = gf_list_get(set->representations, k);\n\t\t\tif (! rep->dasher_ctx) continue;\n\n\t\t\tds = dasher_get_stream(ctx, rep->dasher_ctx->src_url, rep->dasher_ctx->source_pid, 0);\n\t\t\tif (!ds) continue;\n\n\t\t\t//restore everything\n\t\t\tds->done = rep->dasher_ctx->done;\n\t\t\tds->seg_number = rep->dasher_ctx->seg_number;\n\n\t\t\tif (ds->init_seg) gf_free(ds->init_seg);\n\t\t\tds->init_seg = gf_strdup(rep->dasher_ctx->init_seg);\n\n\t\t\tif (ds->seg_template) gf_free(ds->seg_template);\n\t\t\tds->seg_template = gf_strdup(rep->dasher_ctx->template_seg);\n\n\t\t\tif (ds->idx_template) gf_free(ds->idx_template);\n\t\t\tds->idx_template = rep->dasher_ctx->template_idx ? gf_strdup(rep->dasher_ctx->template_idx) : NULL;\n\n\t\t\tif (rep->dasher_ctx->period_id) {\n\t\t\t\tif (ds->period_id) gf_free(ds->period_id);\n\t\t\t\tds->period_id = gf_strdup(rep->dasher_ctx->period_id);\n\t\t\t}\n\n\t\t\tds->period_start = rep->dasher_ctx->period_start;\n\t\t\tif (!ds->period_start.den) {\n\t\t\t\tds->period_start.num = 0;\n\t\t\t\tds->period_start.den = 1000;\n\t\t\t}\n\t\t\tds->period_dur = rep->dasher_ctx->period_duration;\n\t\t\tif (!ds->period_dur.den) {\n\t\t\t\tds->period_dur.num = 0;\n\t\t\t\tds->period_dur.den = 1;\n\t\t\t}\n\t\t\tds->pid_id = rep->dasher_ctx->pid_id;\n\t\t\tds->dep_pid_id = rep->dasher_ctx->dep_pid_id;\n\t\t\tds->seek_to_pck = rep->dasher_ctx->last_pck_idx;\n\t\t\tds->dash_dur = rep->dasher_ctx->dash_dur;\n\t\t\tif (!ds->dash_dur.den) {\n\t\t\t\tds->dash_dur.num = 0;\n\t\t\t\tds->dash_dur.den = 1;\n\t\t\t}\n\t\t\tds->next_seg_start = rep->dasher_ctx->next_seg_start;\n\t\t\tds->adjusted_next_seg_start = ds->next_seg_start;\n\t\t\tds->first_cts = rep->dasher_ctx->first_cts;\n\t\t\tds->first_dts = rep->dasher_ctx->first_dts;\n\t\t\tds->ts_offset = rep->dasher_ctx->ts_offset;\n\t\t\tds->est_next_dts = rep->dasher_ctx->est_next_dts;\n\t\t\tds->mpd_timescale = rep->dasher_ctx->mpd_timescale;\n\t\t\tds->cumulated_dur = (u64) (rep->dasher_ctx->cumulated_dur * ds->timescale);\n\t\t\tds->cumulated_subdur = rep->dasher_ctx->cumulated_subdur;\n\t\t\tds->rep_init = GF_TRUE;\n\t\t\tds->subdur_done = rep->dasher_ctx->subdur_forced ? GF_TRUE : GF_FALSE;\n\t\t\tds->subdur_forced_use_period_dur = 0;\n\t\t\tds->nb_pck = 0;\n\t\t\tif (!ctx->subdur) {\n\t\t\t\tds->nb_pck = ds->seek_to_pck;\n\t\t\t\tds->seek_to_pck = 0;\n\t\t\t}\n\t\t\tds->nb_segments_purged = rep->dasher_ctx->segs_purged;\n\t\t\tds->dur_purged = rep->dasher_ctx->dur_purged;\n\t\t\tds->moof_sn = rep->dasher_ctx->moof_sn;\n\t\t\tds->moof_sn_inc = rep->dasher_ctx->moof_sn_inc;\n\t\t\tctx->last_dyn_period_id = rep->dasher_ctx->last_dyn_period_id;\n\n\t\t\tif (ctx->store_seg_states && !ds->pending_segment_states)\n\t\t\t\tds->pending_segment_states = gf_list_new();\n\n\t\t\tif (rep->segment_list && !ds->pending_segment_urls)\n\t\t\t\tds->pending_segment_urls = gf_list_new();\n\n\t\t\tds->owns_set = rep->dasher_ctx->owns_set;\n\t\t\tif (ds->owns_set) set_ds = ds;\n\n\t\t\tif (rep->dasher_ctx->done) {\n\t\t\t\tds->done = 1;\n\t\t\t\tif (ds->rep) gf_mpd_representation_free(ds->rep);\n\t\t\t\tds->rep = NULL;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tds->nb_comp = 1;\n\n\t\t\tif (ds->rep) gf_mpd_representation_free(ds->rep);\n\t\t\tds->rep = rep;\n\t\t\tds->set = set;\n\t\t\trep->playback.udta = ds;\n\t\t\tif (ds->owns_set)\n\t\t\t\tset->udta = ds;\n\t\t\tif (rep->dasher_ctx->multi_pids)\n\t\t\t\tuse_multi_pid_init = GF_TRUE;\n\n\t\t\tds->period = ctx->current_period;\n\t\t\tif ((ds->codec_id==GF_CODECID_MHAS) || (ds->codec_id==GF_CODECID_MPHA)) {\n\t\t\t\tconst GF_PropertyValue *prop = gf_filter_pid_get_property(ds->ipid, GF_PROP_PID_MHA_COMPATIBLE_PROFILES);\n\t\t\t\tif (prop) {\n\t\t\t\t\tds->set->nb_alt_mha_profiles = prop->value.uint_list.nb_items;\n\t\t\t\t\tds->set->alt_mha_profiles = prop->value.uint_list.vals;\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t\tgf_list_del_item(ctx->next_period->streams, ds);\n\n\t\t\t//non-muxed component or main comp of muxed goes first in the list\n\t\t\tif (ds->nb_comp>1) {\n\t\t\t\tgf_list_insert(ctx->current_period->streams, ds, 0);\n\t\t\t} else {\n\t\t\t\tgf_list_add(ctx->current_period->streams, ds);\n\t\t\t}\n\n\t\t\tif (rep->dasher_ctx->mux_pids) {\n\t\t\t\te = dasher_reload_muxed_comp(ctx, ds, rep->dasher_ctx->mux_pids, GF_FALSE);\n\t\t\t\tif (e) return e;\n\t\t\t}\n\t\t}\n\t\tassert(set_ds);\n\t\tset_ds->nb_rep = gf_list_count(set->representations);\n\n\t\t//if multi PID init, gather pids\n\t\tif (use_multi_pid_init) {\n\t\t\tmulti_pids = gf_list_new();\n\t\t\tfor (i=0; i<nb_rep; i++) {\n\t\t\t\tGF_MPD_Representation *rep = gf_list_get(set->representations, i);\n\t\t\t\tGF_DashStream *ds = rep->playback.udta;\n\t\t\t\tif (ds->owns_set) ds->multi_pids = multi_pids;\n\t\t\t\tgf_list_add(multi_pids, ds->ipid);\n\t\t\t}\n\t\t}\n\t\tcount = gf_list_count(ctx->current_period->streams);\n\t\tfor (i=0; i<nb_rep; i++) {\n\t\t\tGF_MPD_Representation *rep = gf_list_get(set->representations, i);\n\t\t\tGF_DashStream *ds = rep->playback.udta;\n\t\t\tif (!ds || ds->done) continue;\n\t\t\t//happens when reloading context without closing the filter\n\t\t\tif (ds->dst_filter || ds->opid) continue;\n\n\t\t\t//open destination, trashing init\n\t\t\tassert(!ds->muxed_base);\n\t\t\tdasher_open_destination(filter, ctx, rep, ds->init_seg, GF_TRUE);\n\n\t\t\tdasher_open_pid(filter, ctx, ds, multi_pids, GF_TRUE);\n\n\t\t\tfor (j=0; j<count; j++) {\n\t\t\t\tGF_DashStream *a_ds = gf_list_get(ctx->current_period->streams, j);\n\t\t\t\tif (a_ds->muxed_base != ds) continue;\n\n\t\t\t\tdasher_open_pid(filter, ctx, a_ds, multi_pids, GF_TRUE);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn GF_OK;\n}\n\nstatic void dasher_udpate_periods_and_manifest(GF_Filter *filter, GF_DasherCtx *ctx)\n{\n\tif (!ctx->subdur_done) {\n\t\tctx->last_dyn_period_id++;\n\t\tctx->next_pid_id_in_period = 0;\n\t}\n\t//update duration\n\tdasher_update_period_duration(ctx, GF_TRUE);\n\n\tif (ctx->state)\n\t\tdasher_context_update_period_end(ctx);\n\n\t//we have a MPD ready, flush it\n\tif (!ctx->gencues && ctx->mpd)\n\t\tdasher_send_manifest(filter, ctx, GF_FALSE);\n}\n\ntypedef struct\n{\n\tGF_Fraction64 period_start;\n\tconst char *period_id;\n} PeriodInfo;\n\nstatic u32 dasher_period_count(GF_List *streams_in /*GF_DashStream*/)\n{\n\tu32 nb_periods, i, j;\n\tPeriodInfo *info;\n\tGF_List *pinfos = gf_list_new();\n\n\tfor (i=0; i < gf_list_count(streams_in); i++) {\n\t\tBool same_period = GF_FALSE;\n\t\tGF_DashStream *ds = gf_list_get(streams_in, i);\n\t\t//check if we already have a period info with same ID or same start time\n\t\tnb_periods = gf_list_count(pinfos);\n\t\tfor (j=0; j < nb_periods; j++) {\n\t\t\tinfo = gf_list_get(pinfos, j);\n\t\t\tif (info->period_start.num * ds->period_start.den == ds->period_start.num * info->period_start.den) {\n\t\t\t\tsame_period = GF_TRUE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (info->period_id && ds->period_id && !strcmp(info->period_id, ds->period_id)) {\n\t\t\t\tsame_period = GF_TRUE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t//nope, register it\n\t\tif (!same_period) {\n\t\t\tGF_SAFEALLOC(info, PeriodInfo);\n\t\t\tif (info) {\n\t\t\t\tinfo->period_start = ds->period_start;\n\t\t\t\tinfo->period_id = ds->period_id;\n\t\t\t\tgf_list_add(pinfos, info);\n\t\t\t}\n\t\t}\n\t}\n\tnb_periods = gf_list_count(pinfos);\n\twhile (1) {\n\t\tinfo = gf_list_pop_back(pinfos);\n\t\tif (!info) break;\n\t\tgf_free(info);\n\t}\n\tgf_list_del(pinfos);\n\n\treturn nb_periods;\n}\n\nstatic void dasher_init_utc(GF_Filter *filter, GF_DasherCtx *ctx)\n{\n\tu8 *data=NULL;\n\tu64 remote_utc;\n#ifdef GPAC_USE_DOWNLOADER\n\tGF_Err e;\n\tconst char *cache_name;\n\tu32 size;\n#endif\n\tGF_DownloadManager *dm;\n\tchar *url;\n\tDasherUTCTimingType def_type = DASHER_UTCREF_NONE;\n\n\tctx->utc_initialized = GF_TRUE;\n\tctx->utc_timing_type = DASHER_UTCREF_NONE;\n\tif (!ctx->utcs) {\n\t\treturn;\n\t}\n\turl = ctx->utcs;\n\tif (!strncmp(url, \"xsd@\", 4)) {\n\t\tdef_type = DASHER_UTCREF_XSDATE;\n\t\turl += 4;\n\t}\n\n\tif (!strcmp(ctx->utcs, \"inband\")) {\n\t\tctx->utc_timing_type = DASHER_UTCREF_INBAND;\n\t\treturn;\n\t}\n#ifndef GPAC_USE_DOWNLOADER\n\tGF_LOG(GF_LOG_WARNING, GF_LOG_DASH, (\"[DASH] No download manager, cannot sync to remote UTC clock\\n\"));\n\tctx->utc_timing_type = DASHER_UTCREF_NONE;\n\treturn;\n#else\n\t//create session\n\tif (!ctx->utc_sess) {\n\t\tdm  = gf_filter_get_download_manager(filter);\n\t\tif (!dm) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_DASH, (\"[DASH] Failed to get download manager, cannot sync to remote UTC clock\\n\"));\n\t\t\treturn;\n\t\t}\n\t\tctx->utc_sess = gf_dm_sess_new(dm, url, GF_NETIO_SESSION_MEMORY_CACHE, NULL, NULL, &e);\n\t\tif (e) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_DASH, (\"[DASH] Failed to create session for remote UTC source %s: %s - local clock will be used instead\\n\", url, gf_error_to_string(e) ));\n\t\t\treturn;\n\t\t}\n\t\te = gf_dm_sess_process(ctx->utc_sess);\n\t\tif (e==GF_IP_NETWORK_EMPTY) {\n\t\t\tctx->utc_initialized = GF_FALSE;\n\t\t\treturn;\n\t\t}\n\t}\n\t//check we are done\n\tGF_NetIOStatus status;\n\te = gf_dm_sess_get_stats(ctx->utc_sess, NULL, NULL, NULL, NULL, NULL, &status);\n\tif (status==GF_NETIO_DATA_TRANSFERED) e = GF_OK;\n\telse if (status==GF_NETIO_DATA_EXCHANGE) e = GF_NOT_READY;\n\telse if (status==GF_NETIO_STATE_ERROR) {}\n\telse if ((status==GF_NETIO_DISCONNECTED) && (e>=GF_OK))\n\t\te = GF_OK;\n\telse\n\t\te = GF_NOT_READY;\n\n\tif (e==GF_NOT_READY) {\n\t\tctx->utc_initialized = GF_FALSE;\n\t\treturn;\n\t}\n\tif (e<0) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_DASH, (\"[DASH] Failed to fetch remote UTC source %s: %s\\n\", url, gf_error_to_string(e) ));\n\t\tgf_dm_sess_del(ctx->utc_sess);\n\t\tctx->utc_sess = NULL;\n\t\treturn;\n\t}\n\tcache_name = gf_dm_sess_get_cache_name(ctx->utc_sess);\n\tgf_blob_get(cache_name, &data, &size, NULL);\n\n\tif (data) {\n\t\t//xsDate or isoDate - we always signal using iso\n\t\tif (strchr(data, 'T')) {\n\t\t\tremote_utc = gf_net_parse_date(data);\n\t\t\tif (remote_utc)\n\t\t\t\tctx->utc_timing_type = def_type ? def_type : DASHER_UTCREF_ISO;\n\t\t}\n\t\t//ntp\n\t\telse if (sscanf(data, LLU, &remote_utc) == 1) {\n\t\t\t//ntp value not counted since 1900, assume format is seconds till 1 jan 1970\n\t\t\tif (remote_utc<=GF_NTP_SEC_1900_TO_1970) {\n\t\t\t\tremote_utc = remote_utc*1000;\n\t\t\t} else {\n\t\t\t\tremote_utc = gf_net_ntp_to_utc(remote_utc);\n\t\t\t}\n\t\t\tif (remote_utc)\n\t\t\t\tctx->utc_timing_type = DASHER_UTCREF_NTP;\n\t\t}\n\t}\n\tgf_blob_release(cache_name);\n\n\t//not match, try http date\n\tif (!ctx->utc_timing_type) {\n\t\tconst char *hdr = gf_dm_sess_get_header(ctx->utc_sess, \"Date\");\n\t\tif (hdr) {\n\t\t\t//http-head\n\t\t\tremote_utc = gf_net_parse_date(hdr);\n\t\t\tif (remote_utc)\n\t\t\t\tctx->utc_timing_type = DASHER_UTCREF_HTTP_HEAD;\n\t\t}\n\t}\n\n\tif (!ctx->utc_timing_type) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_DASH, (\"[DASH] Failed to parse response %s from remote UTC source %s\\n\", data, url ));\n\t} else {\n\t\tctx->utc_diff = (s32) ( (s64) gf_net_get_utc() - (s64) remote_utc );\n\t\tif (ABS(ctx->utc_diff) > 3600000) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_DASH, (\"[Dasher] Diff between local clock and remote %s is %d, way too large! Assuming 0 ms UTC diff\\n\", url, ctx->utc_diff));\n\t\t\tctx->utc_diff = 0;\n\t\t} else {\n\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_DASH, (\"[Dasher] Synchronized clock to remote %s - UTC diff (local - remote) %d ms\\n\", url, ctx->utc_diff));\n\t\t}\n\t}\n\tgf_dm_sess_del(ctx->utc_sess);\n#endif\n}\n\n\nstatic GF_Err dasher_switch_period(GF_Filter *filter, GF_DasherCtx *ctx)\n{\n\tu32 i, count, nb_done;\n\tchar *period_id;\n\tconst char *remote_xlink = NULL;\n\tconst char *period_xlink = NULL;\n\tu64 remote_dur = 0;\n\tGF_DasherPeriod *p;\n\tGF_Fraction64 period_start, next_period_start;\n\tGF_DashStream *first_in_period=NULL;\n\tp = ctx->current_period;\n\n\tif (!ctx->gencues) {\n\t\tif (!ctx->out_path) {\n\t\t\tdasher_check_outpath(ctx);\n\t\t}\n\t\tif (ctx->current_period->period) {\n\t\t\tif (ctx->dyn_rate)\n\t\t\t\tdasher_update_dyn_bitrates(ctx);\n\n\t\t\tdasher_udpate_periods_and_manifest(filter, ctx);\n\t\t}\n\t}\n\n\tif (ctx->subdur_done || (ctx->current_period->period && (ctx->dmode == GF_MPD_TYPE_DYNAMIC_LAST)) )\n\t\treturn GF_EOS;\n\n\tif (ctx->current_period->period) {\n\t\tGF_LOG(GF_LOG_INFO, GF_LOG_DASH, (\"[Dasher] End of Period %s\\n\", ctx->current_period->period->ID ? ctx->current_period->period->ID : \"\"));\n\t}\n\tctx->is_period_restore = GF_FALSE;\n\tctx->is_empty_period = GF_FALSE;\n\n\t//safety check at period switch, probe each first packet in case we have a reconfigure pending\n\tcount = gf_list_count(ctx->pids);\n\tfor (i=0; i<count;i++) {\n\t\tGF_DashStream *ds = gf_list_get(ctx->pids, i);\n\t\tgf_filter_pid_get_packet(ds->ipid);\n\t}\n\n\t//reset - don't destroy, it is in the MPD\n\tctx->current_period->period = NULL;\n\t//switch\n\tctx->current_period = ctx->next_period;\n\tctx->next_period = p;\n\tctx->on_demand_done = GF_FALSE;\n\tctx->min_segment_start_time = ctx->last_min_segment_start_time = 0;\n\n\t//reset input pids and detach output pids\n\tcount = gf_list_count(ctx->current_period->streams);\n\tfor (i=0; i<count;i++) {\n\t\tGF_DashStream *ds = gf_list_get(ctx->current_period->streams, i);\n\t\tif (ds->opid && !ctx->gencues) {\n\t\t\tgf_filter_pid_remove(ds->opid);\n\t\t\tds->opid = NULL;\n\t\t}\n\t\tdasher_reset_stream(filter, ds, GF_FALSE);\n\t\tif (ds->reschedule) {\n\t\t\tds->reschedule = GF_FALSE;\n\t\t\tds->done = 0;\n\t\t}\n\t}\n\n\t//figure out next period\n\tcount = gf_list_count(ctx->current_period->streams);\n\tctx->period_idx = 0;\n\tperiod_start.num = -1;\n\tperiod_start.den = 1;\n\tfor (i=0; i<count; i++) {\n\t\tGF_DashStream *ds = gf_list_get(ctx->current_period->streams, i);\n\n\t\tif (ds->done) continue;\n\t\tif (ds->period_start.num < 0) {\n\t\t\ts32 pstart = (s32) -ds->period_start.num;\n\t\t\tif (!ctx->period_idx || (pstart < ctx->period_idx)) ctx->period_idx = pstart;\n\t\t} else {\n\t\t\tif ((period_start.num<0) || (ds->period_start.num * period_start.den < period_start.num * ds->period_start.den)) {\n\t\t\t\tperiod_start = ds->period_start;\n\t\t\t\tassert(ds->period_start.den);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (period_start.num >= 0)\n\t\tctx->period_idx = 0;\n\n\tif (ctx->first_context_load) {\n\t\tGF_Err e = dasher_reload_context(filter, ctx);\n\t\tif (e) {\n\t\t\tctx->setup_failure = e;\n\t\t\treturn e;\n\t\t}\n\t\tif (ctx->current_period->period) ctx->is_period_restore = GF_TRUE;\n\n\t\tif (ctx->dmode==GF_DASH_DYNAMIC_LAST) {\n\t\t\tdasher_udpate_periods_and_manifest(filter, ctx);\n\t\t\tcount = gf_list_count(ctx->pids);\n\t\t\tfor (i=0; i<count; i++) {\n\t\t\t\tGF_DashStream *ds = gf_list_get(ctx->pids, i);\n\t\t\t\tgf_filter_pid_set_discard(ds->ipid, GF_TRUE);\n\t\t\t}\n\t\t\treturn GF_EOS;\n\t\t}\n\t}\n\n\t//filter out PIDs not for this period\n\tcount = gf_list_count(ctx->current_period->streams);\n\tperiod_id = NULL;\n\tfor (i=0; i<count; i++) {\n\t\tBool in_period=GF_TRUE;\n\t\tGF_DashStream *ds = gf_list_get(ctx->current_period->streams, i);\n\n\t\tif (ds->done) {\n\t\t\tin_period=GF_FALSE;\n\t\t} else if (!period_id) {\n\t\t\tperiod_id = ds->period_id;\n\t\t\tfirst_in_period = ds;\n\t\t} else if (strcmp(period_id, ds->period_id)) {\n\t\t\tin_period = GF_FALSE;\n\t\t}\n\t\tif (in_period) {\n\t\t\tif ((period_start.num>=0) && (ds->period_start.num * period_start.den != period_start.num * ds->period_start.den))\n\t\t\t\tin_period = GF_FALSE;\n\t\t\telse if ((ctx->period_idx>0) && ((s32) -ds->period_start.num != ctx->period_idx))\n\t\t\t\tin_period = GF_FALSE;\n\n\t\t\tif (!in_period && (first_in_period == ds))\n\t\t\t\tperiod_id = NULL;\n\t\t}\n\n\t\t//if not in period, move to next period\n\t\tif (!in_period) {\n\t\t\tgf_list_rem(ctx->current_period->streams, i);\n\t\t\ti--;\n\t\t\tcount--;\n\t\t\tds->period = NULL;\n\t\t\tgf_list_add(ctx->next_period->streams, ds);\n\t\t\tcontinue;\n\t\t}\n\t\tif (ds->stream_type == GF_STREAM_FILE) {\n\t\t\tif (ds->xlink) remote_xlink = ds->xlink;\n\t\t\telse ctx->is_empty_period = GF_TRUE;\n\t\t\tremote_dur = 0;\n\t\t\tif (ds->period_dur.den)\n\t\t\t\tremote_dur = (u64) (ds->period_dur.num * 1000) / ds->period_dur.den;\n\t\t} else if (!ctx->is_period_restore) {\n\t\t\tif (ds->xlink)\n\t\t\t\tperiod_xlink = ds->xlink;\n\n\t\t\tif (ctx->post_play_events) {\n\t\t\t\tGF_FilterEvent evt;\n\n\t\t\t\tGF_FEVT_INIT(evt, GF_FEVT_STOP, ds->ipid);\n\t\t\t\tgf_filter_pid_send_event(ds->ipid, &evt);\n\n\t\t\t\tgf_filter_pid_set_discard(ds->ipid, GF_FALSE);\n\n\t\t\t\tdasher_send_encode_hints(ctx, ds);\n\n\t\t\t\tGF_FEVT_INIT(evt, GF_FEVT_PLAY, ds->ipid);\n\t\t\t\tevt.play.speed = 1.0;\n\t\t\t\tgf_filter_pid_send_event(ds->ipid, &evt);\n\t\t\t}\n\t\t}\n\t}\n\tctx->post_play_events = GF_FALSE;\n\n\tcount = gf_list_count(ctx->current_period->streams);\n\tif (!count) {\n\t\tcount = gf_list_count(ctx->next_period->streams);\n\t\tnb_done = 0;\n\t\tfor (i=0; i<count; i++)\t {\n\t\t\tGF_DashStream *ds = gf_list_get(ctx->next_period->streams, i);\n\t\t\tif (ds->done) nb_done++;\n\t\t}\n\t\tif (nb_done == count) {\n\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_DASH, (\"[Dasher] End of MPD (no more active streams)\\n\"));\n\t\t\tctx->on_demand_done = GF_TRUE;\n\t\t\treturn GF_EOS;\n\t\t}\n\t}\n\n\t//we need a new period unless created during reload, create it\n\tif (!ctx->is_period_restore) {\n\t\tctx->current_period->period = gf_mpd_period_new();\n\t\tif (!ctx->mpd) dasher_setup_mpd(ctx);\n\t\tgf_list_add(ctx->mpd->periods, ctx->current_period->period);\n\t}\n\n\n\tif (remote_xlink) {\n\t\tctx->current_period->period->xlink_href = gf_strdup(remote_xlink);\n\t\tctx->current_period->period->duration = remote_dur;\n\t}\n\telse if (period_xlink) {\n\t\tctx->current_period->period->xlink_href = gf_strdup(period_xlink);\n\t}\n\n\n\tassert(period_id);\n\n\tnext_period_start.num = -1;\n\tnext_period_start.den = 1;\n\tif (period_start.num >= 0) {\n\t\tctx->current_period->period->start = (u64)(period_start.num*1000 / period_start.den);\n\t\t//check next period start\n\t\tcount = gf_list_count(ctx->next_period->streams);\n\t\tfor (i=0; i<count; i++)\t {\n\t\t\tGF_DashStream *ds = gf_list_get(ctx->next_period->streams, i);\n\t\t\tif (ds->done) continue;\n\t\t\tif (ds->period_start.num * period_start.den < period_start.num * ds->period_start.den) continue;\n\t\t\tif ((next_period_start.num<0) || (next_period_start.num * ds->period_start.den > ds->period_start.num * next_period_start.den)) {\n\t\t\t\tnext_period_start = ds->period_start;\n\t\t\t}\n\t\t}\n\t\t//check current period dur\n\t\tcount = gf_list_count(ctx->current_period->streams);\n\t\tfor (i=0; i<count; i++)\t {\n\t\t\tGF_Fraction64 dur;\n\t\t\tGF_DashStream *ds = gf_list_get(ctx->current_period->streams, i);\n\t\t\tif (!ds->period_dur.den) continue;\n\t\t\tdur = period_start;\n\t\t\tif (ds->period_dur.den) {\n\t\t\t\tif (dur.den != ds->period_dur.den)\n\t\t\t\t\tdur.num += ds->period_dur.num * dur.den / ds->period_dur.den;\n\t\t\t\telse\n\t\t\t\t\tdur.num += ds->period_dur.num;\n\t\t\t}\n\t\t\t\n\t\t\tif ((next_period_start.num < 0) || (next_period_start.num * dur.den > dur.num * next_period_start.den))\n\t\t\t\tnext_period_start = dur;\n\t\t}\n\t\tif (next_period_start.num > 0) {\n\t\t\tu64 next = next_period_start.num;\n\t\t\tif (next_period_start.den != period_start.den) {\n\t\t\t\tnext *= period_start.den;\n\t\t\t\tnext /= next_period_start.den;\n\t\t\t}\n\t\t\tctx->current_period->period->duration = (u32) ( (next - period_start.num) * 1000 / period_start.den);\n\t\t}\n\t}\n\n\t//assign period ID if none specified\n\tif (strcmp(period_id, DEFAULT_PERIOD_ID))\n\t\tctx->current_period->period->ID = gf_strdup(period_id);\n\t//assign ID if dynamic - if dash_ctx also assign ID since we could have moved from dynamic to static\n\telse if (!ctx->current_period->period->ID && ((ctx->dmode != GF_MPD_TYPE_STATIC) || ctx->state) ) {\n\t\tchar szPName[50];\n\t\tsprintf(szPName, \"DID%d\", ctx->last_dyn_period_id + 1);\n\t\tctx->current_period->period->ID = gf_strdup(szPName);\n\t}\n\n\t//check all streams are ready\n\tctx->period_not_ready = GF_FALSE;\n\tcount = gf_list_count(ctx->current_period->streams);\n\tfor (i=0; i<count; i++) {\n\t\tGF_DashStream *ds = gf_list_get(ctx->current_period->streams, i);\n\t\t//assign force_rep_end\n\t\tif (next_period_start.num > 0) {\n\t\t\tu64 next = next_period_start.num;\n\t\t\tif (next_period_start.den != period_start.den) {\n\t\t\t\tnext *= period_start.den;\n\t\t\t\tnext /= next_period_start.den;\n\t\t\t}\n\n\t\t\tds->force_rep_end = (u64) ((next - period_start.num) * ds->timescale / period_start.den);\n\t\t}\n\t\tif (ds->dcd_not_ready) {\n\t\t\tctx->period_not_ready = GF_TRUE;\n\t\t}\n\t}\n\t//not all streams are ready, cannot setup period yet\n\tif (ctx->period_not_ready)\n\t\treturn GF_OK;\n\n\treturn dasher_setup_period(filter, ctx, NULL);\n}\n\nstatic GF_Err dasher_setup_period(GF_Filter *filter, GF_DasherCtx *ctx, GF_DashStream *inject_ds)\n{\n\tu32 i, count, j, nb_sets;\n\tBool has_muxed_bases=GF_FALSE;\n\tconst char *remote_xlink = NULL;\n\tBool has_as_id = GF_FALSE;\n\tBool has_deps = GF_FALSE;\n\tconst GF_PropertyValue *prop;\n\tGF_Fraction64 min_dur, min_adur, max_adur;\n\tu32 srd_rep_idx;\n\n\tctx->dyn_rate = GF_FALSE;\n\tctx->use_cues = GF_FALSE;\n\tmin_dur.num = min_adur.num = max_adur.num = 0;\n\tmin_dur.den = min_adur.den = max_adur.den = 1;\n\tsrd_rep_idx = 2; //2 for compat with old arch\n\tctx->min_cts_period.num = 0;\n\tctx->min_cts_period.den = 0;\n\n\tcount = gf_list_count(ctx->current_period->streams);\n\t//setup representations\n\tfor (i=0; i<count; i++) {\n\t\tGF_DashStream *ds = gf_list_get(ctx->current_period->streams, i);\n\t\tif (inject_ds && (ds != inject_ds))\n\t\t\tcontinue;\n\n\t\tif (ds->stream_type == GF_STREAM_FILE) {\n\t\t\tif (ds->xlink) remote_xlink = ds->xlink;\n\t\t} else if (!ctx->is_period_restore) {\n\t\t\t//setup representation - the representation is created independently from the period\n\t\t\tdasher_setup_rep(ctx, ds, &srd_rep_idx);\n\t\t}\n\t}\n\n\t//setup representation dependency / components (muxed)\n\tfor (i=0; i<count; i++) {\n\t\tBool remove = GF_FALSE;\n\t\tGF_DashStream *ds_video=NULL;\n\t\tGF_DashStream *ds = gf_list_get(ctx->current_period->streams, i);\n\t\tif (inject_ds && (ds != inject_ds))\n\t\t\tcontinue;\n\n\t\tds->period = ctx->current_period;\n\t\tds->last_period = ds->period->period;\n\n\t\tif (ds->dyn_bitrate) ctx->dyn_rate = GF_TRUE;\n\t\tif (ds->inband_cues || ds->cues)\n\t\t\tctx->use_cues = GF_TRUE;\n\n\t\tif (ctx->loop) {\n\t\t\tprop = gf_filter_pid_get_property(ds->ipid, GF_PROP_PID_DURATION);\n\t\t\t//only check true media dur\n\t\t\tif (prop && prop->value.lfrac.den && (prop->value.lfrac.num>0)) {\n\t\t\t\tGF_Fraction64 d;\n\t\t\t\td.num = prop->value.lfrac.num;\n\t\t\t\td.den = prop->value.lfrac.den;\n\t\t\t\tif (ds->clamped_dur.num && (ds->clamped_dur.num * d.den < d.num * ds->clamped_dur.den)) {\n\t\t\t\t\td = ds->clamped_dur;\n\t\t\t\t}\n\n\t\t\t\tif (ds->stream_type == GF_STREAM_AUDIO) {\n\t\t\t\t\tif (d.num * max_adur.den > max_adur.num * d.den) max_adur = d;\n\t\t\t\t\tif (!min_adur.num || (d.num * min_adur.den < min_adur.num * d.den)) min_adur = d;\n\t\t\t\t} else {\n\t\t\t\t\tif (!min_dur.num || (d.num * min_dur.den < min_dur.num * d.den)) min_dur = d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (ds->stream_type == GF_STREAM_FILE) {\n\t\t\tremove = GF_TRUE;\n\t\t} else if (remote_xlink) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_DASH, (\"[Dasher] period uses xlink but other media source %s, ignoring source\\n\", ds->src_url));\n\t\t\tremove = GF_TRUE;\n\t\t} else if (ctx->is_empty_period) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_DASH, (\"[Dasher] empty period defined but other media source %s, ignoring source\\n\", ds->src_url));\n\t\t\tremove = GF_TRUE;\n\t\t}\n\n\t\tif (remove) {\n\t\t\tds->done = 1;\n\t\t\tds->period = NULL;\n\t\t\tgf_list_rem(ctx->current_period->streams, i);\n\t\t\tgf_list_add(ctx->next_period->streams, ds);\n\t\t\ti--;\n\t\t\tcount--;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (ctx->gencues)\n\t\t\tds->set_period_switch = GF_TRUE;\n\n\t\tif (ctx->is_period_restore) continue;\n\n\t\t//add period descriptors\n\t\tdasher_add_descriptors(&ctx->current_period->period->x_children, ds->p_period_desc);\n\t\t//add representation descriptors\n\t\tdasher_add_descriptors(&ds->rep->x_children, ds->p_rep_desc);\n\n\t\tif (ds->muxed_base) continue;\n\n\t\tif (ds->stream_type==GF_STREAM_VISUAL)\n\t\t\tds_video = ds;\n\n\t\tds->skip_tpl_reuse = GF_FALSE;\n\t\t// period resume (end of content replacement/splice/...): if using templates, check if period ID is used, if not force startNumber to resume\n\t\tprop = gf_filter_pid_get_property_str(ds->ipid, \"period_resume\");\n\t\tif (prop && prop->value.string && ctx->tpl && ds->mpd_timescale) {\n\t\t\tchar *template = ds->template;\n\t\t\tif (!template) template = ctx->template;\n\t\t\tif (\n\t\t\t\t//undefined period name\n\t\t\t\t!prop->value.string[0]\n\t\t\t\t//template dor not resolve against period name\n\t\t\t\t|| (template && !strstr(template, \"$Period$\"))\n\t\t\t) {\n\t\t\t\tu64 seg_duration = (u64)(ds->dash_dur.num) * ds->mpd_timescale / ds->dash_dur.den;\n\t\t\t\tu64 period_start = ds->mpd_timescale * ctx->mpd->media_presentation_duration / 1000;\n\t\t\t\tu64 num = period_start / seg_duration;\n\t\t\t\tif (num * seg_duration < period_start)\n\t\t\t\t\tnum++;\n\t\t\t\tds->startNumber = (u32) (num+1);\n\t\t\t\tds->skip_tpl_reuse = GF_TRUE;\n\t\t\t}\n\t\t}\n\n\t\tds->nb_comp = 1;\n\n\t\tfor (j=0; j<count; j++) {\n\t\t\tGF_DashStream *a_ds;\n\t\t\tif (i==j) continue;\n\t\t\ta_ds = gf_list_get(ctx->current_period->streams, j);\n\t\t\tif (a_ds->dep_id && (a_ds->src_id==ds->src_id) && (a_ds->dep_id==ds->id) ) {\n\t\t\t\tgf_list_add(ds->complementary_streams, a_ds);\n\t\t\t\thas_deps = GF_TRUE;\n\t\t\t\tif (!a_ds->rep->dependency_id) {\n\t\t\t\t\ta_ds->rep->dependency_id = gf_strdup(ds->rep->id);\n\t\t\t\t}\n\t\t\t}\n\t\t\t//check if this rep should be muxed: same rep ID, not raw format, not CMAF\n\t\t\tif (a_ds->muxed_base) {\n\t\t\t\t//happens when we switch base_ds to use video one\n\t\t\t\tif (a_ds->muxed_base == ds) ds->nb_comp++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (ctx->muxtype==DASHER_MUX_RAW) continue;\n\t\t\tif (ctx->cmaf) continue;\n\t\t\tif (strcmp(a_ds->rep_id, ds->rep_id)) continue;\n\t\t\telse if (ctx->sigfrag) {\n\t\t\t\tif (a_ds->src_url && ds->src_url && strcmp(a_ds->src_url, ds->src_url)) continue;\n\t\t\t}\n\t\t\tif (a_ds->template && ds->template && strcmp(a_ds->template, ds->template)) continue;\n\n\n\t\t\tif (!ds_video && (a_ds->stream_type==GF_STREAM_VISUAL))\n\t\t\t\tds_video = a_ds;\n\n\t\t\ta_ds->muxed_base = ds;\n\t\t\ta_ds->dash_dur = ds->dash_dur;\n\t\t\thas_muxed_bases = GF_TRUE;\n\t\t\tds->nb_comp++;\n\n\t\t\tif (ctx->bs_switch==DASHER_BS_SWITCH_MULTI) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_DASH, (\"[Dasher] Bitstream Swicthing mode \\\"multi\\\" is not supported with multiplexed representations, disabling bitstream switching\\n\"));\n\t\t\t\tctx->bs_switch = DASHER_BS_SWITCH_OFF;\n\t\t\t}\n\t\t\tif (!ds->rep->codecs || !strstr(ds->rep->codecs, a_ds->rep->codecs)) {\n\t\t\t\tgf_dynstrcat(&ds->rep->codecs, a_ds->rep->codecs, \",\");\n\t\t\t}\n\n\t\t\tif (ctx->profile == GF_DASH_PROFILE_AVC264_LIVE) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_DASH, (\"[Dasher] Muxed representations not allowed in DASH-IF AVC264 live profile\\n\\tswitching to regular live profile\\n\"));\n\t\t\t\tctx->profile = GF_DASH_PROFILE_LIVE;\n\t\t\t} else if (ctx->profile == GF_DASH_PROFILE_HBBTV_1_5_ISOBMF_LIVE) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_DASH, (\"[Dasher] Muxed representations not allowed in HbbTV 1.5 ISOBMFF live profile\\n\\tswitching to regular live profile\\n\"));\n\t\t\t\tctx->profile = GF_DASH_PROFILE_LIVE;\n\t\t\t} else if (ctx->profile == GF_DASH_PROFILE_AVC264_ONDEMAND) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_DASH, (\"[Dasher] Muxed representations not allowed in DASH-IF AVC264 onDemand profile\\n\\tswitching to regular onDemand profile\\n\"));\n\t\t\t\tctx->profile = GF_DASH_PROFILE_ONDEMAND;\n\t\t\t} else if (ctx->profile == GF_DASH_PROFILE_DASHIF_LL) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_DASH, (\"[Dasher] Muxed representations not allowed in DASH-IF Low Latency profile\\n\\tswitching to regular live profile\\n\"));\n\t\t\t\tctx->profile = GF_DASH_PROFILE_LIVE;\n\t\t\t}\n\t\t}\n\t\t//use video as main stream for segmentation of muxed sources\n\t\tif (ds_video && (ds_video != ds)) {\n\t\t\tu32 nb_comp = ds->nb_comp;\n\t\t\tfor (j=0; j<count; j++) {\n\t\t\t\tGF_DashStream *a_ds = gf_list_get(ctx->current_period->streams, j);\n\t\t\t\tif ((a_ds->muxed_base==ds) || (a_ds==ds)) {\n\t\t\t\t\tif (a_ds == ds_video) {\n\t\t\t\t\t\ta_ds->muxed_base = NULL;\n\t\t\t\t\t\ta_ds->nb_comp = nb_comp;\n\t\t\t\t\t\tif (a_ds->rep->codecs) gf_free(a_ds->rep->codecs);\n\t\t\t\t\t\ta_ds->rep->codecs = ds->rep->codecs;\n\t\t\t\t\t\tds->rep->codecs = NULL;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ta_ds->muxed_base = ds_video;\n\t\t\t\t\t\ta_ds->nb_comp = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ((u32) ds->dash_dur.num * 1000 > ctx->def_max_seg_dur * ds->dash_dur.den )\n\t\t\tctx->def_max_seg_dur = (u32) ((ds->dash_dur.num * 1000) / ds->dash_dur.den);\n\t}\n\n\tif (ctx->sigfrag) {\n\t\tBool has_rep_conflict = GF_FALSE;\n\t\t//make sure all representation have unique ids\n\t\tfor (i=0; i<count; i++) {\n\t\t\tu32 nb_changed=0;\n\t\t\tGF_DashStream *ds = gf_list_get(ctx->current_period->streams, i);\n\t\t\tif (ds->muxed_base) continue;\n\t\t\tfor (j=0; j<count; j++) {\n\t\t\t\tchar szRep[20];\n\t\t\t\tGF_DashStream *a_ds;\n\t\t\t\tif (j == i) continue;\n\t\t\t\ta_ds = gf_list_get(ctx->current_period->streams, j);\n\t\t\t\tif (a_ds->muxed_base) continue;\n\n\t\t\t\tif (strcmp(ds->rep_id, a_ds->rep_id)) continue;\n\t\t\t\tif (ds->template && strstr(ds->template, \"$RepresentationID$\")) {\n\t\t\t\t\thas_rep_conflict = GF_TRUE;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tnb_changed++;\n\t\t\t\tsprintf(szRep, \"%d\", nb_changed);\n\t\t\t\tgf_free(a_ds->rep_id);\n\t\t\t\ta_ds->rep_id = NULL;\n\t\t\t\tgf_dynstrcat(&a_ds->rep_id, ds->rep_id, NULL);\n\t\t\t\tgf_dynstrcat(&a_ds->rep_id, \"_\", NULL);\n\t\t\t\tgf_dynstrcat(&a_ds->rep_id, szRep, NULL);\n\t\t\t\tgf_free(a_ds->rep->id);\n\t\t\t\ta_ds->rep->id = gf_strdup(a_ds->rep_id);\n\t\t\t}\n\t\t}\n\t\tif (has_rep_conflict && ctx->do_mpd) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_DASH, (\"[Dasher] Several representations with same ID and using $RepresentationID$ template, cannot change IDs. Resulting MPD is not strictly DASH compliant\\n\"));\n\t\t}\n\t}\n\n\tif (ctx->loop && max_adur.num) {\n\t\tif (max_adur.num * min_adur.den != min_adur.num * max_adur.den) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_DASH, (\"[Dasher] Audio streams in the period have different durations (min \"LLU\"/\"LLD\", max \"LLU\"/\"LLD\"), may result in bad synchronization while looping\\n\", min_adur.num, min_adur.den, max_adur.num, max_adur.den));\n\t\t}\n\t\tfor (i=0; i<count; i++) {\n\t\t\tGF_DashStream *ds = gf_list_get(ctx->current_period->streams, i);\n\t\t\tif (ds->duration.num * max_adur.den > max_adur.num * ds->duration.den) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_DASH, (\"[Dasher] Input %s: max audio duration \"LLU\"/\"LLD\" in the period is less than duration \"LLU\"/\"LLD\", clamping will happen\\n\", ds->src_url, max_adur.num, max_adur.den, ds->duration.num, ds->duration.den ));\n\t\t\t}\n\t\t\tds->clamped_dur = max_adur;\n\t\t}\n\t}\n\n\n\tif (ctx->is_period_restore) return GF_OK;\n\n\tif (has_deps) {\n\t\tfor (i=0; i<count; i++) {\n\t\t\tGF_DashStream *ds = gf_list_get(ctx->current_period->streams, i);\n\t\t\t//assign rep bitrates\n\t\t\tif (ds->dep_id)\n\t\t\t\tds->rep->bandwidth = dasher_get_dep_bitrate(ctx, ds);\n\n\t\t\tif (gf_list_count(ds->complementary_streams)) {\n\t\t\t\tu32 nb_str = gf_list_count(ds->complementary_streams);\n\t\t\t\tds->moof_sn_inc = 1+nb_str;\n\t\t\t\tds->moof_sn = 1;\n\t\t\t\tfor (j=0; j<nb_str; j++) {\n\t\t\t\t\tGF_DashStream *a_ds = gf_list_get(ds->complementary_streams, j);\n\t\t\t\t\ta_ds->moof_sn_inc = ds->moof_sn_inc;\n\t\t\t\t\ta_ds->moof_sn = ds->moof_sn + 1 + j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t//moved all mux components after the base one, so that we do the segmentation on the main component\n\tif (has_muxed_bases) {\n\t\t//setup reps in adaptation sets\n\t\tfor (i=0; i<count; i++) {\n\t\t\tGF_DashStream *ds = gf_list_get(ctx->current_period->streams, i);\n\t\t\tif (!ds->muxed_base) continue;\n\t\t\tgf_list_rem(ctx->current_period->streams, i);\n\t\t\tgf_list_add(ctx->current_period->streams, ds);\n\t\t}\n\t}\n\n\t//setup reps in adaptation sets\n\tfor (i=0; i<count; i++) {\n\t\tGF_DashStream *ds = gf_list_get(ctx->current_period->streams, i);\n\t\tif (ds->muxed_base) continue;\n\t\t//already setup\n\t\tif (ds->set) continue;\n\n\t\t//not setup, create new AS\n\t\tds->set = gf_mpd_adaptation_set_new();\n\t\tds->owns_set = GF_TRUE;\n\t\t//only set hls intra for visual stream if we have know for sure\n\t\tif ((ds->stream_type==GF_STREAM_VISUAL) && (ds->sync_points_type==DASHER_SYNC_NONE)) {\n\t\t\tds->set->intra_only = GF_TRUE;\n\t\t}\n\t\tif (ctx->llhls) {\n\t\t\tds->set->use_hls_ll = GF_TRUE;\n\t\t\tif (ctx->cdur.den)\n\t\t\t\tds->set->hls_ll_target_frag_dur = ((Double)ctx->cdur.num) / ctx->cdur.den;\n\t\t}\n\t\tds->set->udta = ds;\n\t\tif (ds->period_continuity_id) {\n\t\t\tGF_FilterPacket *pck = gf_filter_pid_get_packet(ds->ipid);\n\t\t\tif (pck && (gf_filter_pck_get_cts(pck) != ds->period_continuity_next_cts)) {\n\t\t\t\tgf_free(ds->period_continuity_id);\n\t\t\t\tds->period_continuity_id = NULL;\n\t\t\t} else {\n\t\t\t\tGF_MPD_Descriptor *desc = gf_mpd_descriptor_new(NULL, \"urn:mpeg:dash:period-continuity:2015\", ds->period_continuity_id);\n\t\t\t\tgf_list_add(ds->set->supplemental_properties, desc);\n\t\t\t}\n\t\t}\n\t\tds->period_continuity_next_cts = 0;\n\t\tprop = gf_filter_pid_get_property_str(ds->ipid, \"start_with_sap\");\n\t\tif (prop) ds->set->starts_with_sap = prop->value.uint;\n\n\n\t\tif (ctx->mha_compat && ((ds->codec_id==GF_CODECID_MHAS) || (ds->codec_id==GF_CODECID_MPHA))) {\n\t\t\tprop = gf_filter_pid_get_property(ds->ipid, GF_PROP_PID_MHA_COMPATIBLE_PROFILES);\n\t\t\tif (prop) {\n\t\t\t\tds->set->nb_alt_mha_profiles = prop->value.uint_list.nb_items;\n\t\t\t\tds->set->alt_mha_profiles = prop->value.uint_list.vals;\n\t\t\t\tds->set->alt_mha_profiles_only = (ctx->mha_compat==DASHER_MPHA_COMP_ONLY) ? GF_TRUE : GF_FALSE;\n\t\t\t}\n\t\t}\n\n\t\tif (!ds->set->representations)\n\t\t\tds->set->representations = gf_list_new();\n\t\tif (!ds->period->period->adaptation_sets)\n\t\t\tds->period->period->adaptation_sets = gf_list_new();\n\t\tgf_list_add(ds->period->period->adaptation_sets, ds->set);\n\n\t\tgf_list_add(ds->set->representations, ds->rep);\n\t\tds->nb_rep = 1;\n\n\t\t//add non-conditional adaptation set descriptors\n\t\tdasher_add_descriptors(&ds->set->x_children, ds->p_as_any_desc);\n\t\t//new AS, add conditional adaptation set descriptors\n\t\tdasher_add_descriptors(&ds->set->x_children, ds->p_as_desc);\n\n\t\tif (ds->as_id) has_as_id = GF_TRUE;\n\t\t//for each following, check if same AS is possible\n\t\tfor (j=i+1; j<count; j++) {\n\t\t\tGF_DashStream *a_ds;\n\t\t\ta_ds = gf_list_get(ctx->current_period->streams, j);\n\t\t\t//we add to the adaptation set even if shared rep, we will remove it when assigning templates and pids\n\t\t\tif (dasher_same_adaptation_set(ctx, ds, a_ds)) {\n\t\t\t\ta_ds->set = ds->set;\n\n\t\t\t\tgf_list_add(ds->set->representations, a_ds->rep);\n\t\t\t\tds->nb_rep++;\n\t\t\t\t//add non-conditional adaptation set descriptors\n\t\t\t\tdasher_add_descriptors(&ds->set->x_children, a_ds->p_as_any_desc);\n\t\t\t}\n\t\t}\n\t}\n\tif (has_as_id) {\n\t\tfor (i=0; i<count; i++) {\n\t\t\tGF_DashStream *ds = gf_list_get(ctx->current_period->streams, i);\n\t\t\tif (!ds->owns_set) continue;\n\t\t\tfor (j=i+1; j<count; j++) {\n\t\t\t\tGF_DashStream *a_ds = gf_list_get(ctx->current_period->streams, j);\n\t\t\t\t//avoid as id duplicates\n\t\t\t\tif (ds->owns_set && a_ds->owns_set && (a_ds->as_id == ds->as_id)) {\n\t\t\t\t\ta_ds->as_id = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t//we need a pass on adaptation sets to figure out if they share the same source URL\n\t//in case we use file name in templates\n\tnb_sets = gf_list_count(ctx->current_period->period->adaptation_sets);\n\tfor (i=0; i<nb_sets; i++) {\n\t\tGF_DashStream *ds;\n\t\tGF_MPD_Representation *rep;\n\t\tGF_MPD_AdaptationSet *set;\n\n\t\tif (ctx->sigfrag)\n\t\t\tbreak;\n\n\t\tset = gf_list_get(ctx->current_period->period->adaptation_sets, i);\n\t\tassert(set);\n\t\trep = gf_list_get(set->representations, 0);\n\t\tassert(rep);\n\t\tds = rep->playback.udta;\n\n\t\tif (inject_ds && (ds != inject_ds))\n\t\t\tcontinue;\n\n\t\tif (!dasher_template_use_source_url(ds->template ? ds->template : ctx->template))\n\t\t\tcontinue;\n\n\t\tfor (j=i+1; j<nb_sets; j++) {\n\t\t\tBool split_init = GF_FALSE;\n\t\t\tconst GF_PropertyValue *p1, *p2;\n\t\t\tGF_DashStream *a_ds;\n\n\t\t\tset = gf_list_get(ctx->current_period->period->adaptation_sets, j);\n\t\t\trep = gf_list_get(set->representations, 0);\n\t\t\tassert(rep);\n\t\t\ta_ds = rep->playback.udta;\n\n\t\t\tif (!dasher_template_use_source_url(a_ds->template ? a_ds->template : ctx->template))\n\t\t\t\tcontinue;\n\n\t\t\tp1 = gf_filter_pid_get_property(ds->ipid, GF_PROP_PID_URL);\n\t\t\tp2 = gf_filter_pid_get_property(a_ds->ipid, GF_PROP_PID_URL);\n\t\t\tif (p1 && p2) {\n\t\t\t\tif (gf_props_equal(p1, p2)) split_init = GF_TRUE;\n\t\t\t} else {\n\t\t\t\tp1 = gf_filter_pid_get_property(ds->ipid, GF_PROP_PID_FILEPATH);\n\t\t\t\tp2 = gf_filter_pid_get_property(a_ds->ipid, GF_PROP_PID_FILEPATH);\n\t\t\t\tif (p1 && p2 && gf_props_equal(p1, p2)) split_init = GF_TRUE;\n\t\t\t}\n\t\t\t\n\t\t\tif (split_init) {\n\t\t\t\tds->split_set_names = GF_TRUE;\n\t\t\t\ta_ds->split_set_names = GF_TRUE;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*HbbTV 1.5 ISO live specific checks*/\n\tif (ctx->profile == GF_DASH_PROFILE_HBBTV_1_5_ISOBMF_LIVE) {\n\t\tu32 nb_periods = dasher_period_count(ctx->current_period->streams);\n\t\tif (nb_sets > 16) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_DASH, (\"[DASH] Max 16 adaptation sets in HbbTV 1.5 ISO live profile\\n\\tswitching to DASH AVC/264 live profile\\n\"));\n\t\t\tctx->profile = GF_DASH_PROFILE_AVC264_LIVE;\n\t\t}\n\t\tif (nb_periods > 32) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_DASH, (\"[DASH] Max 32 periods in HbbTV 1.5 ISO live profile\\n\\tswitching to regular DASH AVC/264 live profile\\n\"));\n\t\t\tctx->profile = GF_DASH_PROFILE_AVC264_LIVE;\n\t\t}\n\t\tif (ctx->segdur.num < (s32) ctx->segdur.den) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_DASH, (\"[DASH] Min segment duration 1s in HbbTV 1.5 ISO live profile\\n\\tcapping to 1s\\n\"));\n\t\t\tctx->segdur.num = 1;\n\t\t\tctx->segdur.den = 1;\n\t\t}\n\t\tif (ctx->segdur.num > 15 * (s32) ctx->segdur.den) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_DASH, (\"[DASH] Max segment duration 15s in HbbTV 1.5 ISO live profile\\n\\tcapping to 15s\\n\"));\n\t\t\tctx->segdur.num = 15;\n\t\t\tctx->segdur.den = 1;\n\t\t}\n\t}\n\n\t//init UTC reference time for dynamic\n\tif (!ctx->mpd->availabilityStartTime && (ctx->dmode!=GF_MPD_TYPE_STATIC) && !inject_ds) {\n\t\tu64 dash_start_date = ctx->ast ? gf_net_parse_date(ctx->ast) : 0;\n\n\t\tif (ctx->utc_timing_type != DASHER_UTCREF_NONE) {\n\t\t\tif (!gf_list_count(ctx->mpd->utc_timings) ) {\n\t\t\t\tBool dashif_ok = GF_FALSE;\n\t\t\t\tGF_MPD_Descriptor *utc_t;\n\t\t\t\tchar *url = ctx->utcs;\n\t\t\t\tif (!strncmp(url, \"xsd@\", 4)) url += 4;\n\n\t\t\t\tGF_SAFEALLOC(utc_t, GF_MPD_Descriptor);\n\t\t\t\tutc_t->value = gf_strdup(url);\n\t\t\t\tswitch (ctx->utc_timing_type) {\n\t\t\t\tcase DASHER_UTCREF_HTTP_HEAD:\n\t\t\t\t\tutc_t->scheme_id_uri = gf_strdup(\"urn:mpeg:dash:utc:http-head:2014\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase DASHER_UTCREF_XSDATE:\n\t\t\t\t\tutc_t->scheme_id_uri = gf_strdup(\"urn:mpeg:dash:utc:http-xsdate:2014\");\n\t\t\t\t\tdashif_ok = GF_TRUE;\n\t\t\t\t\tbreak;\n\t\t\t\tcase DASHER_UTCREF_ISO:\n\t\t\t\t\tutc_t->scheme_id_uri = gf_strdup(\"urn:mpeg:dash:utc:http-iso:2014\");\n\t\t\t\t\tdashif_ok = GF_TRUE;\n\t\t\t\t\tbreak;\n\t\t\t\tcase DASHER_UTCREF_NTP:\n\t\t\t\t\tutc_t->scheme_id_uri = gf_strdup(\"urn:mpeg:dash:utc:http-ntp:2014\");\n\t\t\t\t\tdashif_ok = GF_TRUE;\n\t\t\t\t\tbreak;\n\t\t\t\tcase DASHER_UTCREF_INBAND:\n\t\t\t\t\tutc_t->scheme_id_uri = gf_strdup(\"urn:mpeg:dash:utc:direct:2014\");\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (!dashif_ok && (ctx->profile==GF_DASH_PROFILE_DASHIF_LL)) {\n\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_DASH, (\"[Dasher] UTC reference %s allowed in DASH-IF Low Latency profile\\n\\tswitching to regular live profile\\n\", utc_t->scheme_id_uri));\n\t\t\t\t\tctx->profile = GF_DASH_PROFILE_LIVE;\n\t\t\t\t}\n\t\t\t\tif (!ctx->mpd->utc_timings)\n\t\t\t\t\tctx->mpd->utc_timings = gf_list_new();\n\t\t\t\tgf_list_add(ctx->mpd->utc_timings, utc_t);\n\t\t\t}\n\t\t}\n\n\t\t//setup service description\n\t\tif (ctx->profile == GF_DASH_PROFILE_DASHIF_LL) {\n\t\t\tctx->mpd->inject_service_desc = GF_TRUE;\n\t\t}\n\n\t\tctx->mpd->gpac_init_ntp_ms = gf_net_get_ntp_ms();\n\t\tctx->mpd->availabilityStartTime = dasher_get_utc(ctx);\n\t\tGF_LOG(GF_LOG_INFO, GF_LOG_DASH, (\"[Dasher] MPD Availability start time initialized to \"LLU\" ms\\n\", ctx->mpd->availabilityStartTime));\n\n\t\tif (dash_start_date && (dash_start_date < ctx->mpd->availabilityStartTime)) {\n\t\t\tu64 start_date_sec_ntp, secs;\n\t\t\tDouble ms;\n\t\t\t//recompute NTP init time matching the required ast\n\t\t\tsecs = dash_start_date/1000;\n\t\t\tstart_date_sec_ntp = (u32) secs;\n\t\t\tstart_date_sec_ntp += GF_NTP_SEC_1900_TO_1970;\n\t\t\tms = (Double) (dash_start_date - secs*1000);\n\t\t\tms /= 1000.0;\n\t\t\tctx->mpd->gpac_init_ntp_ms = (u64) (start_date_sec_ntp * 1000 + ms);\n\t\t\t//compute number of seconds to discard\n\t\t\tctx->nb_secs_to_discard = (Double) (ctx->mpd->availabilityStartTime - dash_start_date);\n\t\t\tctx->nb_secs_to_discard /= 1000;\n\t\t\t//don't discard TSB, this will be done automatically\n\n\t\t\tctx->mpd->availabilityStartTime = dash_start_date;\n\n\t\t} else if (dash_start_date) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_DASH, (\"[Dasher] specified AST %s seems in the future, ignoring it\\n\", ctx->ast));\n\t\t}\n\t}\n\n\t//setup adaptation sets bitstream switching\n\tfor (i=0; i<count; i++) {\n\t\tGF_DashStream *ds = gf_list_get(ctx->current_period->streams, i);\n\t\tif (!ds->owns_set) continue;\n\t\tif (inject_ds && (ds != inject_ds))\n\t\t\tcontinue;\n\t\t//check bitstream switching\n\t\tdasher_check_bitstream_swicthing(ctx, ds->set);\n\t\t//setup AS defaults, roles and co\n\t\tdasher_setup_set_defaults(ctx, ds->set);\n\t\t//setup sources, templates & co\n\t\tdasher_setup_sources(filter, ctx, ds->set);\n\t}\n\n\twhile (gf_list_count(ctx->postponed_pids)) {\n\t\tGF_DashStream *ds = gf_list_get(ctx->postponed_pids, 0);\n\t\tdasher_open_pid(filter, ctx, ds, ds->multi_pids, GF_FALSE);\n\t}\n\n\t//good to go !\n\tfor (i=0; i<count; i++) {\n\t\tGF_DashStream *ds = gf_list_get(ctx->current_period->streams, i);\n\t\tif (inject_ds && (ds != inject_ds))\n\t\t\tcontinue;\n\t\t//setup segmentation\n\t\tds->rep_init = GF_FALSE;\n\t\tds->presentation_time_offset = 0;\n\t\tds->seg_done = GF_FALSE;\n\t\tds->next_seg_start = (u32) ( ((u64) ds->dash_dur.num * ds->timescale) / ds->dash_dur.den);\n\n\t\t//in sbound=0 mode, if stream has sync and non-sync and uses skip samples, allow spliting\n\t\t//slightly before - typically needed for audio with sync points (usac, mpegh) where the segment duration is set\n\t\t//to the intra interval, we need to take into account the skip samples\n\t\tif (!ctx->sbound && !ds->cues && (ds->sync_points_type==DASHER_SYNC_PRESENT)\n\t\t\t&& (ds->pts_minus_cts<0) && (ds->next_seg_start > (u32) -ds->pts_minus_cts)\n\t\t) {\n\t\t\tds->next_seg_start -= (u32) -ds->pts_minus_cts;\n\t\t}\n\n\t\tds->adjusted_next_seg_start = ds->next_seg_start;\n\t\tds->segment_started = GF_FALSE;\n\t\tds->seg_number = ds->startNumber;\n\t\tds->first_cts = ds->first_dts = ds->max_period_dur = 0;\n\n\t\t//simulate N loops of the source\n\t\tif (ctx->nb_secs_to_discard) {\n\t\t\tu64 period_dur, seg_dur;\n\t\t\tu32 nb_skip=0;\n\n\t\t\tperiod_dur = (u64) (ctx->nb_secs_to_discard * ds->timescale);\n\t\t\tseg_dur = (u64) (ds->dash_dur.num) * ds->timescale / ds->dash_dur.den;\n\n\t\t\tnb_skip = (u32) (period_dur / seg_dur);\n\t\t\tds->ts_offset += nb_skip*seg_dur;\n\t\t\tds->seg_number += nb_skip;\n\n\t\t\tds->max_period_dur = ds->cumulated_dur;\n\t\t\tds->adjusted_next_seg_start += ds->ts_offset;\n\t\t\tds->next_seg_start += ds->ts_offset;\n\t\t}\n\t}\n\n\tctx->nb_secs_to_discard = 0;\n\n\tif (ctx->state)\n\t\tdasher_context_update_period_start(ctx);\n\n\treturn GF_OK;\n}\n\nstatic void dasher_insert_timeline_entry(GF_DasherCtx *ctx, GF_DashStream *ds)\n{\n\tGF_MPD_SegmentTimelineEntry *s;\n\tu64 duration, pto, prev_patch_dur=0;\n\tBool is_first = GF_FALSE;\n\tBool seg_align = GF_FALSE;\n\tGF_MPD_SegmentTimeline *tl=NULL;\n\n\t//we only store segment timeline for the main component in the representation\n\tif (ds->muxed_base) return;\n\n\tif (ds->rep && ds->rep->state_seg_list) {\n\t\tGF_DASH_SegmentContext *sctx = gf_list_last(ds->rep->state_seg_list);\n\t\tif (sctx)\n\t\t\tsctx->dur = ds->first_cts_in_next_seg - ds->first_cts_in_seg;\n\t}\n\t//we only use segment timeline with templates\n\tif (!ds->stl && !ctx->do_index) return;\n\n\tif (gf_list_find(ds->set->representations, ds->rep)==0) is_first = GF_TRUE;\n\tassert(ds->first_cts_in_next_seg > ds->first_cts_in_seg);\n\tduration = ds->first_cts_in_next_seg - ds->first_cts_in_seg;\n\n\t\t//handle sap time adjustment (first_cts_in_seg is the SAP cts, we may have lower cts whith sap 2 or 3)\n\tif (ds->min_cts_in_seg_plus_one && (ds->min_cts_in_seg_plus_one-1 < ds->first_cts_in_seg)) {\n\t\tprev_patch_dur = ds->first_cts_in_seg - (ds->min_cts_in_seg_plus_one-1);\n\t\tif (ds->timescale != ds->mpd_timescale)\n\t\t\tprev_patch_dur = gf_timestamp_rescale(prev_patch_dur, ds->timescale, ds->mpd_timescale);\n\t\tds->first_cts_in_seg = ds->min_cts_in_seg_plus_one-1;\n\t\tduration += prev_patch_dur;\n\t\tds->seg_start_time -= prev_patch_dur;\n\t}\n\n\tpto = ds->presentation_time_offset;\n\tif (ds->timescale != ds->mpd_timescale) {\n\t\tduration = gf_timestamp_rescale(duration, ds->timescale, ds->mpd_timescale);\n\n\t\tpto = gf_timestamp_rescale(pto, ds->timescale, ds->mpd_timescale);\n\t}\n\tseg_align = (ds->set->segment_alignment || ds->set->subsegment_alignment) ? GF_TRUE : GF_FALSE;\n\t//not first and segment alignment, ignore\n\tif (!is_first && seg_align) {\n\t\treturn;\n\t}\n\tif (ctx->do_index) {\n\t\tGF_MPD_SegmentURL *surl = gf_list_last(ds->rep->segment_list->segment_URLs);\n\t\tsurl->duration = duration;\n\t}\n\tif (!ds->stl) return;\n\n\t//no segment alignment store in each rep\n\tif (!seg_align) {\n\t\tGF_MPD_SegmentTimeline **p_tl=NULL;\n\t\tif (!ds->rep) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_DASH, (\"[Dasher] failed to store timeline entry, no representation assigned !\\n\"));\n\t\t\treturn;\n\t\t}\n\n\t\tif (ctx->tpl) {\n\t\t\tp_tl = &ds->rep->segment_template->segment_timeline;\n\t\t\tds->rep->segment_template->duration = 0;\n\t\t} else {\n\t\t\tp_tl = &ds->rep->segment_list->segment_timeline;\n\t\t\tds->rep->segment_list->duration = 0;\n\t\t}\n\t\tif (! (*p_tl)) {\n\t\t\t(*p_tl) = gf_mpd_segmentimeline_new();\n\t\t}\n\t\ttl = (*p_tl);\n\t} else {\n\t\tBool new_tl = GF_FALSE;\n\t\tGF_MPD_SegmentTimeline **p_tl=NULL;\n\n\t\tif (!ds->set) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_DASH, (\"[Dasher] failed to store timeline entry, no AdpatationSet assigned !\\n\"));\n\t\t\treturn;\n\t\t}\n\t\tassert(ds->set);\n\t\tif (ctx->tpl) {\n\t\t\t//in case we had no template at set level\n\t\t\tif (!ds->set->segment_template) {\n\t\t\t\tGF_SAFEALLOC(ds->set->segment_template, GF_MPD_SegmentTemplate);\n\t\t\t\tif (ds->set->segment_template) {\n\t\t\t\t\tds->set->segment_template->start_number = (u32) -1;\n\t\t\t\t\tds->set->segment_template->timescale = ds->mpd_timescale;\n\t\t\t\t\tds->set->segment_template->presentation_time_offset = pto;\n\t\t\t\t}\n\t\t\t\tnew_tl = GF_TRUE;\n\t\t\t}\n\t\t\tp_tl = &ds->set->segment_template->segment_timeline;\n\t\t\tds->set->segment_template->duration = 0;\n\t\t} else {\n\t\t\t//in case we had no template at set level\n\t\t\tif (!ds->set->segment_list) {\n\t\t\t\tGF_SAFEALLOC(ds->set->segment_list, GF_MPD_SegmentList);\n\t\t\t\tif (ds->set->segment_list) {\n\t\t\t\t\tds->set->segment_list->start_number = (u32) -1;\n\t\t\t\t\tds->set->segment_list->timescale = ds->mpd_timescale;\n\t\t\t\t\tds->set->segment_list->presentation_time_offset = pto;\n\t\t\t\t}\n\t\t\t\tnew_tl = GF_TRUE;\n\t\t\t}\n\t\t\tp_tl = &ds->set->segment_list->segment_timeline;\n\t\t\tds->set->segment_list->duration = 0;\n\t\t}\n\n\t\tif (! (*p_tl) ) {\n\t\t\t(*p_tl)  = gf_mpd_segmentimeline_new();\n\t\t}\n\t\ttl = (*p_tl);\n\t\tif (new_tl) {\n\t\t\tu32 i, count = gf_list_count(ds->set->representations);\n\t\t\tfor (i=0; i<count; i++) {\n\t\t\t\tGF_MPD_Representation *arep = gf_list_get(ds->set->representations, i);\n\t\t\t\tif (arep && arep->segment_template) arep->segment_template->duration = 0;\n\t\t\t\tif (arep && arep->segment_list) arep->segment_list->duration = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\t//append to previous entry if possible\n\ts = gf_list_last(tl->entries);\n\n\tif (prev_patch_dur) {\n\t\tu32 nb_ent = gf_list_count(tl->entries);\n\t\t//split entry\n\t\tif (s->repeat_count) {\n\t\t\tGF_MPD_SegmentTimelineEntry *next;\n\t\t\ts->repeat_count--;\n\t\t\tGF_SAFEALLOC(next, GF_MPD_SegmentTimelineEntry);\n\t\t\tif (!next) return;\n\t\t\tnext->duration = (u32) (s->duration - prev_patch_dur);\n\t\t\tnext->start_time = s->start_time + (s->repeat_count+1) * s->duration;\n\t\t\tgf_list_add(tl->entries, next);\n\t\t\ts = next;\n\t\t} else {\n\t\t\t//update entry\n\t\t\ts->duration -= (u32) prev_patch_dur;\n\t\t\t//merge with old one if possible\n\t\t\tGF_MPD_SegmentTimelineEntry *prev = (nb_ent>1) ? gf_list_get(tl->entries, nb_ent-2) : NULL;\n\t\t\tif (prev && (prev->duration==s->duration) && (prev->start_time + (prev->repeat_count+1) * prev->duration == s->start_time)) {\n\t\t\t\tprev->repeat_count++;\n\t\t\t\tgf_list_pop_back(tl->entries);\n\t\t\t\tgf_free(s);\n\t\t\t\ts=prev;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (s && (s->duration == duration) && (s->start_time + (s->repeat_count+1) * s->duration == ds->seg_start_time + pto)) {\n\t\ts->repeat_count++;\n\t\treturn;\n\t}\n\n\t//nope, allocate\n\tGF_SAFEALLOC(s, GF_MPD_SegmentTimelineEntry);\n\tif (!s) return;\n\ts->start_time = ds->seg_start_time + pto;\n\ts->duration = (u32) duration;\n\tgf_list_add(tl->entries, s);\n}\n\nstatic void dasher_copy_segment_timelines(GF_DasherCtx *ctx, GF_MPD_AdaptationSet *set)\n{\n\tGF_MPD_SegmentTimeline *src_tl = NULL;\n\tu32 i, j, count, nb_s;\n\t//get as level segment timeline, set it to NULL, reassign it to first rep and clone for other reps\n\tif (ctx->tpl) {\n\t\tassert(set->segment_template->segment_timeline);\n\t\tsrc_tl = set->segment_template->segment_timeline;\n\t\tset->segment_template->segment_timeline = NULL;\n\t} else {\n\t\tassert(set->segment_list->segment_timeline);\n\t\tsrc_tl = set->segment_list->segment_timeline;\n\t\tset->segment_list->segment_timeline = NULL;\n\t}\n\tnb_s = gf_list_count(src_tl->entries);\n\n\tcount = gf_list_count(set->representations);\n\tfor (i=0; i<count; i++) {\n\t\tGF_MPD_SegmentTimeline *tl = NULL;\n\t\tGF_MPD_Representation *rep = gf_list_get(set->representations, i);\n\t\tif (ctx->tpl) {\n\t\t\tif (!rep->segment_template) {\n\t\t\t\tGF_SAFEALLOC(rep->segment_template, GF_MPD_SegmentTemplate);\n\t\t\t\tif (!rep->segment_template) continue;\n\t\t\t}\n\t\t\tif (!i) {\n\t\t\t\trep->segment_template->segment_timeline = src_tl;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!rep->segment_template->segment_timeline) {\n\t\t\t\trep->segment_template->segment_timeline = gf_mpd_segmentimeline_new();\n\t\t\t}\n\t\t\ttl = rep->segment_template->segment_timeline;\n\t\t} else {\n\t\t\tif (!rep->segment_list) {\n\t\t\t\tGF_SAFEALLOC(rep->segment_list, GF_MPD_SegmentList);\n\t\t\t\tif (!rep->segment_list) continue;\n\t\t\t\trep->segment_list->start_number = (u32) -1;\n\t\t\t}\n\t\t\tif (!i) {\n\t\t\t\trep->segment_list->segment_timeline = src_tl;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!rep->segment_list->segment_timeline) {\n\t\t\t\trep->segment_list->segment_timeline = gf_mpd_segmentimeline_new();\n\t\t\t}\n\t\t\ttl = rep->segment_list->segment_timeline;\n\t\t}\n\t\tassert(tl);\n\t\tfor (j=0; j<nb_s; j++) {\n\t\t\tGF_MPD_SegmentTimelineEntry *s;\n\t\t\tGF_MPD_SegmentTimelineEntry *src_s = gf_list_get(src_tl->entries, j);\n\t\t\tGF_SAFEALLOC(s, GF_MPD_SegmentTimelineEntry);\n\t\t\tif (!s) continue;\n\n\t\t\ts->duration = src_s->duration;\n\t\t\ts->repeat_count = src_s->repeat_count;\n\t\t\ts->start_time = src_s->start_time;\n\t\t\tgf_list_add(tl->entries, s);\n\t\t}\n\t}\n}\n\nstatic void dasher_flush_segment(GF_DasherCtx *ctx, GF_DashStream *ds, Bool is_last_in_period)\n{\n\tu32 i, count;\n\tGF_DashStream *ds_done = NULL, *ds_not_done = NULL;\n\tGF_DashStream *set_ds = ds->set->udta;\n\tGF_DashStream *base_ds = ds->muxed_base ? ds->muxed_base : ds;\n\tBool has_ds_done = GF_FALSE;\n\tu32 seg_dur_ms=0;\n\tGF_DashStream *ds_log = NULL;\n\tu64 first_cts_in_cur_seg=0;\n\n\t//these are ignored\n\tif (ds->merged_tile_dep)\n\t\treturn;\n\n\tctx->update_report = -1;\n\n\tif (ds->segment_started) {\n\t\tDouble seg_duration;\n\t\tu64 seg_duration_unscale = base_ds->first_cts_in_next_seg - ds->first_cts_in_seg;\n\t\t//seg_duration /= base_ds->timescale;\n\t\tif (!seg_duration_unscale) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_DASH, (\"[Dasher] Segment %d is empty - pid end of stream %d\\n\", ds->seg_number, gf_filter_pid_is_eos(ds->ipid) ));\n\t\t}\n\t\tseg_dur_ms = (u32) (seg_duration_unscale*1000 / base_ds->timescale);\n\t\tif (seg_dur_ms * base_ds->timescale < seg_duration_unscale* 1000) seg_dur_ms++;\n\n\t\tfirst_cts_in_cur_seg = ds->first_cts_in_seg;\n\t\tif (ctx->mpd->max_segment_duration < seg_dur_ms)\n\t\t\tctx->mpd->max_segment_duration = seg_dur_ms;\n\t\tctx->def_max_seg_dur = 0;\n\n\t\tseg_duration = (Double) base_ds->first_cts_in_next_seg - ds->first_cts_in_seg;\n\t\tseg_duration /= base_ds->timescale;\n\n\t\tif (ctx->sigfrag) {\n\t\t\tif (ds->no_seg_dur) {\n\t\t\t\tds->gm_duration_total += seg_duration;\n\t\t\t\tds->gm_nb_segments++;\n\t\t\t\tif (!ds->gm_duration_min || (ds->gm_duration_min>seg_duration) )\n\t\t\t\t\tds->gm_duration_min = seg_duration;\n\t\t\t\tif (ds->gm_duration_max<seg_duration)\n\t\t\t\t\tds->gm_duration_max = seg_duration;\n\t\t\t\tds->dash_dur.num = (s32) (1000.0 * ds->gm_duration_total / ds->gm_nb_segments);\n\t\t\t\tds->dash_dur.den = 1000;\n\t\t\t\tds->rep->dash_dur = ds->dash_dur;\n\t\t\t}\n\n\t\t\tif (ds->rep->segment_list && (ds->rep->segment_list->duration * ds->dash_dur.den != ds->dash_dur.num) ) {\n\t\t\t\tds->rep->segment_list->duration = (u64) (ds->dash_dur.num) * ds->rep->segment_list->timescale / ds->dash_dur.den;\n\t\t\t}\n\t\t\tif (ds->set->segment_list && (ds->set->segment_list->duration * ds->dash_dur.den != ds->dash_dur.num) ) {\n\t\t\t\tds->set->segment_list->duration = (u64) (ds->dash_dur.num) * ds->set->segment_list->timescale / ds->dash_dur.den;\n\t\t\t}\n\t\t\tif (ds->rep->segment_template && (ds->rep->segment_template->duration * ds->dash_dur.den != ds->dash_dur.num) ) {\n\t\t\t\tds->rep->segment_template->duration = (u64) (ds->dash_dur.num) * ds->rep->segment_template->timescale / ds->dash_dur.den;\n\t\t\t}\n\t\t\tif (ds->set && ds->set->segment_template && (ds->set->segment_template->duration * ds->dash_dur.den != ds->dash_dur.num) ) {\n\t\t\t\tds->set->segment_template->duration = (u64) (ds->dash_dur.num) * ds->set->segment_template->timescale / ds->dash_dur.den;\n\t\t\t}\n\t\t}\n\t\tif (!base_ds->done && !base_ds->stl && ctx->tpl && !ctx->cues && !ctx->forward_mode && !is_last_in_period) {\n\n\t\t\tif (2 * seg_duration * ds->dash_dur.den < ds->dash_dur.num) {\n\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_DASH, (\"[Dasher] Segment %d duration %g less than half DASH duration, consider reencoding or using segment timeline\\n\", ds->seg_number, seg_duration));\n\t\t\t} else if (2 * seg_duration * ds->dash_dur.den > 3 * ds->dash_dur.num) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_DASH, (\"[Dasher] Segment %d duration %g more than 3/2 DASH duration, consider reencoding or using segment timeline\\n\", ds->seg_number, seg_duration));\n\t\t\t}\n\t\t}\n\t\tdasher_insert_timeline_entry(ctx, base_ds);\n\n\t\tif (ctx->do_m3u8) {\n\t\t\tu64 segdur = base_ds->first_cts_in_next_seg - ds->first_cts_in_seg;\n\t\t\tif (gf_timestamp_less(base_ds->rep->hls_max_seg_dur.num, base_ds->rep->hls_max_seg_dur.den, segdur, base_ds->timescale)) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_DASH, (\"[Dasher] Changing HLS target duration from %u to %u, either increase the segment duration or re-encode the content\\n\",\n\t\t\t\t\t\t(u32) gf_ceil( ((Double) base_ds->rep->hls_max_seg_dur.num) / base_ds->rep->hls_max_seg_dur.den),\n\t\t\t\t\t\t(u32) gf_ceil( ((Double) segdur) / base_ds->timescale)\n\t\t\t\t));\n\n\t\t\t\tbase_ds->rep->hls_max_seg_dur.num = (s32) segdur;\n\t\t\t\tbase_ds->rep->hls_max_seg_dur.den = base_ds->timescale;\n\t\t\t}\n\t\t}\n\n\t\tif (ctx->align) {\n\t\t\tif (!set_ds->nb_rep_done || !set_ds->set_seg_duration) {\n\t\t\t\tset_ds->set_seg_duration = seg_duration;\n\t\t\t} else {\n\t\t\t\tDouble diff = set_ds->set_seg_duration - seg_duration;\n\n\t\t\t\tif (ABS(diff) > 0.001) {\n\t\t\t\t\tif (set_ds->set->segment_alignment || set_ds->set->subsegment_alignment) {\n\t\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_DASH, (\"[Dasher] Segments are not aligned across representations: first rep segment duration %g but new segment duration %g for the same segment %d\\n\", set_ds->set_seg_duration, seg_duration, set_ds->seg_number));\n\t\t\t\t\t}\n\t\t\t\t\tif (ctx->profile != GF_DASH_PROFILE_FULL) {\n\t\t\t\t\t\tset_ds->set->segment_alignment = GF_FALSE;\n\t\t\t\t\t\tset_ds->set->subsegment_alignment = GF_FALSE;\n\t\t\t\t\t\tctx->profile = GF_DASH_PROFILE_FULL;\n\t\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_DASH, (\"[Dasher] No segment alignment, switching to full profile\\n\"));\n\n\t\t\t\t\t\tif (set_ds->stl)\n\t\t\t\t\t\t\tdasher_copy_segment_timelines(ctx, set_ds->set);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tset_ds->nb_rep_done++;\n\t\t\tif (set_ds->nb_rep_done < set_ds->nb_rep) {\n\t\t\t\tif (ctx->subdur && (ds->cumulated_dur >= 0.8 * (ds->cumulated_subdur + ctx->subdur) * ds->timescale))\n\t\t\t\t\tds->subdur_done = GF_TRUE;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tset_ds->set_seg_duration = 0;\n\t\t\tset_ds->nb_rep_done = 0;\n\t\t}\n\n\t\tds_log = ds;\n\t} else {\n\t\tif (ctx->align) {\n\t\t\tset_ds->nb_rep_done++;\n\t\t\tif (set_ds->nb_rep_done < set_ds->nb_rep) return;\n\n\t\t\tset_ds->set_seg_duration = 0;\n\t\t\tset_ds->nb_rep_done = 0;\n\t\t}\n\t}\n\n\tif (ctx->subdur && (ds->cumulated_dur >= 0.8 * (ds->cumulated_subdur + ctx->subdur) * ds->timescale))\n\t\tds->subdur_done = GF_TRUE;\n\n\tcount = gf_list_count(ctx->current_period->streams);\n\n\tif (ctx->subdur) {\n\t\tu32 nb_sub_done=0;\n\t\tif (ctx->subdur_done) return;\n\t\tfor (i=0; i<count; i++) {\n\t\t\tGF_DashStream *a_ds = gf_list_get(ctx->current_period->streams, i);\n\t\t\tif (a_ds->muxed_base) {\n\t\t\t\tif (a_ds->muxed_base->subdur_done) a_ds->subdur_done = GF_TRUE;\n\t\t\t}\n\n\t\t\tif (a_ds->subdur_done) {\n\t\t\t\tnb_sub_done++;\n\t\t\t}\n\t\t}\n\t\t// if one of the AS is done and we are at 30% of target subdur, abort\n\t\tif (nb_sub_done && !ds->subdur_done\n\t\t \t&& (ctx->subdur && (ds->cumulated_dur >= (0.7 * (ds->cumulated_subdur + ctx->subdur)) * ds->timescale))\n\t\t) {\n\t\t\tds->subdur_done = GF_TRUE;\n\t\t\tnb_sub_done++;\n\t\t}\n\t\tif (nb_sub_done==count)\n \t\t\tctx->subdur_done = GF_TRUE;\n\t}\n\n\t//reset all streams from our rep or our set\n\tfor (i=0; i<count; i++) {\n\t\tds = gf_list_get(ctx->current_period->streams, i);\n\t\t//reset all in set if segment alignment\n\t\tif (ctx->align) {\n\t\t\tif (ds->set != set_ds->set) continue;\n\t\t} else {\n\t\t\t//otherwise reset only media components for this rep\n\t\t\tif ((ds->muxed_base != base_ds) && (ds != base_ds)) continue;\n\t\t}\n\n\t\tif (!ds->done) {\n\t\t\tds->first_cts_in_next_seg = ds->first_cts_in_seg = ds->est_first_cts_in_next_seg = 0;\n\t\t\tds->min_cts_in_seg_plus_one = 0;\n\t\t}\n\n\t\tif (ds->muxed_base) {\n\t\t\tif (!ds->done) {\n\t\t\t\tds->segment_started = GF_FALSE;\n\t\t\t\tds->seg_done = GF_FALSE;\n\t\t\t} else {\n\t\t\t\thas_ds_done = GF_TRUE;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tbase_ds = ds;\n\n\t\tif (base_ds->done)\n\t\t\tds_done = base_ds;\n\t\telse if (base_ds->nb_comp_done==base_ds->nb_comp) ds_not_done = base_ds;\n\n\t\tif (!base_ds->done && base_ds->seg_done) {\n\t\t\tbase_ds->seg_done = GF_FALSE;\n\t\t\tbase_ds->nb_comp_done = 0;\n\n#ifndef GPAC_DISABLE_LOG\n\t\t\tif (ctx->dmode>=GF_DASH_DYNAMIC) {\n\t\t\t\tu32 asid;\n\t\t\t\ts64 ast_diff;\n\t\t\t\tu64 seg_ast = ctx->mpd->availabilityStartTime;\n\t\t\t\tseg_ast += ctx->current_period->period->start;\n\t\t\t\tseg_ast += gf_timestamp_rescale(base_ds->adjusted_next_seg_start, base_ds->timescale, 1000);\n\n\t\t\t\t//if theoretical AST of the segment is less than the current UTC, we are producing the segment too late.\n\t\t\t\tast_diff = (s64) dasher_get_utc(ctx);\n\t\t\t\tast_diff -= seg_ast;\n\n\t\t\t\tasid = base_ds->set->id;\n\t\t\t\tif (!asid)\n\t\t\t\t\tasid = gf_list_find(ctx->current_period->period->adaptation_sets, base_ds->set) + 1;\n\n\t\t\t\tif (ast_diff>10) {\n\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_DASH, (\"[Dasher] AS%d Rep %s segment %d done TOO LATE by %d ms\\n\", asid, base_ds->rep->id, base_ds->seg_number, (s32) ast_diff));\n\t\t\t\t} else {\n\t\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_DASH, (\"[Dasher] AS%d Rep %s segment %d done %d ms %s UTC due time\\n\", asid, base_ds->rep->id, base_ds->seg_number, ABS(ast_diff), (ast_diff<0) ? \"before\" : \"after\"));\n\t\t\t\t}\n\t\t\t}\n#endif\n\n\t\t\t//it may happen that we get a reconfigure triggered while no segment is active\n\t\t\tif (base_ds->segment_started) {\n\t\t\t\tbase_ds->segment_started = GF_FALSE;\n\n\t\t\t\tbase_ds->next_seg_start += (u64) (base_ds->dash_dur.num) * base_ds->timescale / base_ds->dash_dur.den;\n\t\t\t\twhile (base_ds->next_seg_start <= base_ds->adjusted_next_seg_start) {\n\t\t\t\t\tbase_ds->next_seg_start += (u64) (base_ds->dash_dur.num) * base_ds->timescale / base_ds->dash_dur.den;\n\t\t\t\t\tif (ctx->skip_seg)\n\t\t\t\t\t\tbase_ds->seg_number ++;\n\t\t\t\t}\n\t\t\t\tbase_ds->adjusted_next_seg_start = base_ds->next_seg_start;\n\t\t\t\tbase_ds->seg_number ++;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (ds_log) {\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_DASH, (\"[Dasher] Rep#%s flush seg %d start %g duration %g next seg end time %g\\n\", ds_log->rep->id, ds_log->seg_number-1, ((Double)first_cts_in_cur_seg)/ds_log->timescale, ((Double)seg_dur_ms)/1000, ((Double)ds_log->adjusted_next_seg_start)/ds_log->timescale));\n\t}\n\n\t//muxed representation with unaligned duration, report all done reps to number of components done\n\tif (has_ds_done) {\n\t\tbase_ds->nb_comp_done = 0;\n\t\tfor (i=0; i<count; i++) {\n\t\t\tds = gf_list_get(ctx->current_period->streams, i);\n\t\t\t//otherwise reset only media components for this rep\n\t\t\tif ((ds->muxed_base != base_ds) && (ds != base_ds)) continue;\n\n\t\t\tif (ds->done && (base_ds->nb_comp_done < base_ds->nb_comp)) {\n\t\t\t\tbase_ds->nb_comp_done++;\n\t\t\t}\n\t\t}\n\t}\n\telse if (ds->muxed_base) {\n\t\t//force reset if muxed base and no rep is over\n\t\tbase_ds->nb_comp_done = 0;\n\t}\n\n\t//some reps are done, other not, force a max time on all AS in the period\n\tif (ds_done && ds_not_done) {\n\t\tfor (i=0; i<count; i++) {\n\t\t\tds = gf_list_get(ctx->current_period->streams, i);\n\n\t\t\tif (ds->done) {\n\t\t\t\tif (ds->set->udta == set_ds)\n\t\t\t\t\tset_ds->nb_rep_done++;\n\t\t\t} else if (ctx->check_dur && !ds->force_rep_end) {\n\t\t\t\tds->force_rep_end = gf_timestamp_rescale(ds_done->first_cts_in_next_seg, ds_done->timescale, ds->timescale );\n\t\t\t}\n\t\t}\n\t}\n}\n\n//seg_name is relative to the source manifest (MPD or master HLS) for segments\nstatic char *dasher_strip_base(GF_DasherCtx *ctx, GF_DashStream *ds, char *seg_url, char *seg_name)\n{\n\tif (ctx->keep_src) return gf_strdup(seg_name);\n\n\tconst GF_PropertyValue *mpd_url = gf_filter_pid_get_property_str(ds->ipid, \"manifest_url\");\n\tif (!mpd_url || !ctx->out_path) return gf_strdup(seg_url);\n\n\tBool gf_url_is_relative(const char *pathName);\n\tchar *url, *mpd_out, *mpd_src_alloc=NULL;\n\tmpd_out = gf_file_basename(ctx->out_path);\n\tu32 len = (u32) (mpd_out - ctx->out_path);\n\tchar *mpd_src = mpd_url->value.string;\n\n\tif (!strncmp(ctx->out_path, mpd_url->value.string, len)) {\n\t\tmpd_src += len;\n\t} else if (gf_url_is_relative(ctx->out_path) && gf_url_is_relative(mpd_src)) {\n\t\tchar *opath=NULL, *ipath=NULL;\n\t\tif (ctx->out_path[0]!='.') gf_dynstrcat(&opath, \"./\", NULL);\n\t\tgf_dynstrcat(&opath, ctx->out_path, NULL);\n\t\tif (mpd_src[0]!='.') gf_dynstrcat(&ipath, \"./\", NULL);\n\t\tgf_dynstrcat(&ipath, mpd_src, NULL);\n\n\t\tmpd_src_alloc = gf_url_concatenate_parent(opath, ipath);\n\t\tmpd_src = mpd_src_alloc;\n\t\tif (opath) gf_free(opath);\n\t\tif (ipath) gf_free(ipath);\n\t} else {\n\t\treturn gf_strdup(seg_name);\n\t}\n\n\turl = gf_url_concatenate(mpd_src, seg_name);\n\treturn url;\n}\n\nstatic GFINLINE\nu64 dasher_translate_cts(GF_DashStream *ds, u64 cts)\n{\n\tif (ds->cues) {\n\t\tcts -= ds->first_cts;\n\t} else if (cts < ds->first_dts) {\n\t\tcts = 0;\n\t} else if (ds->pts_minus_cts<0) {\n\t\tif ((s64) (cts - ds->first_dts) >= -ds->pts_minus_cts) {\n\t\t\tcts = cts - ds->first_dts + ds->pts_minus_cts;\n\t\t} else {\n\t\t\tcts = 0;\n\t\t}\n\t} else {\n\t\tcts -= ds->first_cts;\n\t}\n\treturn cts;\n}\n\nstatic void dasher_mark_segment_start(GF_DasherCtx *ctx, GF_DashStream *ds, GF_FilterPacket *pck, GF_FilterPacket *in_pck)\n{\n\tBool no_concat;\n\tGF_DASH_SegmentContext *seg_state=NULL;\n\tchar szSegmentName[GF_MAX_PATH], szSegmentFullPath[GF_MAX_PATH], szIndexName[GF_MAX_PATH];\n\tGF_DashStream *base_ds = ds->muxed_base ? ds->muxed_base : ds;\n\n\tif (ctx->forward_mode) {\n\t\tconst GF_PropertyValue *p_fname, *p_manifest;\n\n\t\tp_fname = gf_filter_pck_get_property(in_pck, GF_PROP_PCK_FILENAME);\n\t\tp_manifest = gf_filter_pck_get_property(in_pck, GF_PROP_PCK_FILENUM);\n\t\tif (!p_fname || !p_fname->value.string || !p_manifest) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_DASH, (\"[Dasher] Couldn't fetch source URL / idx of segment in forward mode, cannot forward\\n\"));\n\t\t\tctx->in_error = GF_TRUE;\n\t\t\treturn;\n\t\t}\n\t\tstrcpy(szSegmentName, p_fname->value.string);\n\t\t//remove filename property\n\t\tif (pck)\n\t\t\tgf_filter_pck_set_property(pck, GF_PROP_PCK_FILENAME, NULL);\n\n\t\t//check for manifest update\n\t\tp_manifest = gf_filter_pck_get_property(in_pck, GF_PROP_PCK_DASH_MANIFEST);\n\t\tif (p_manifest) {\n\t\t\tif (p_manifest->value.string) {\n\t\t\t\tif (strstr(p_manifest->value.string, \"<MPD\")) {\n\t\t\t\t\tif (ctx->do_m3u8) {\n\t\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_DASH, (\"[Dasher] Manifest forward mode got DASH MPD but output is HLS M3U8, cannot operate - change formats or dasher forward mode\\n\"));\n\t\t\t\t\t\tctx->in_error = GF_TRUE;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdasher_forward_mpd(ctx, p_manifest->value.string);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (ctx->do_mpd) {\n\t\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_DASH, (\"[Dasher] Manifest forward mode got M3U8 but output is DASH MPD, cannot operate - change formats or dasher forward mode\\n\"));\n\t\t\t\t\t\tctx->in_error = GF_TRUE;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdasher_forward_manifest_raw(ctx, ds, p_manifest->value.string, NULL);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pck)\n\t\t\t\tgf_filter_pck_set_property(pck, GF_PROP_PCK_DASH_MANIFEST, NULL);\n\t\t}\n\n\t\t//check for HLS child playlist update\n\t\tp_manifest = gf_filter_pck_get_property(in_pck, GF_PROP_PCK_HLS_VARIANT);\n\t\tp_fname = gf_filter_pck_get_property(in_pck, GF_PROP_PCK_HLS_VARIANT_NAME);\n\t\tif (p_manifest && p_fname && (p_fname->value.string_list.nb_items==p_manifest->value.string_list.nb_items)) {\n\t\t\tu32 i, count = p_fname->value.string_list.nb_items;\n\t\t\tfor (i=0; i<count; i++)\n\t\t\t\tdasher_forward_manifest_raw(ctx, ds, p_manifest->value.string_list.vals[i], p_fname->value.string_list.vals[i]);\n\t\t}\n\t\tif (pck) {\n\t\t\tif (p_manifest)\n\t\t\t\tgf_filter_pck_set_property(pck, GF_PROP_PCK_HLS_VARIANT, NULL);\n\t\t\tif (p_fname)\n\t\t\t\tgf_filter_pck_set_property(pck, GF_PROP_PCK_HLS_VARIANT_NAME, NULL);\n\t\t}\n\n\t\t//we need to move from segment name to output name\n\t\tif (ctx->forward_mode==DASHER_FWD_ALL)\n\t\t\tgoto send_packet;\n\t}\n\n\tif (pck) {\n\t\tif (ctx->ntp==DASHER_NTP_YES) {\n\t\t\tu64 ntpts = gf_net_get_ntp_ts();\n\t\t\tgf_filter_pck_set_property(pck, GF_PROP_PCK_SENDER_NTP, &PROP_LONGUINT(ntpts));\n\t\t} else if (ctx->ntp==DASHER_NTP_REM) {\n\t\t\tgf_filter_pck_set_property(pck, GF_PROP_PCK_SENDER_NTP, NULL);\n\t\t}\n\t\tif (!ctx->gencues) {\n\t\t\tgf_filter_pck_set_property(pck, GF_PROP_PCK_FILENUM, NULL );\n\t\t\tgf_filter_pck_set_property(pck, GF_PROP_PCK_IDXFILENAME, NULL );\n\t\t\tgf_filter_pck_set_property(pck, GF_PROP_PCK_FILENAME, NULL );\n\t\t}\n\n\t\tgf_filter_pck_set_property(pck, GF_PROP_PCK_FILENUM, &PROP_UINT(base_ds->seg_number ) );\n\n\t\tif (ctx->gencues) {\n\t\t\tgf_filter_pck_set_property(pck, GF_PROP_PCK_CUE_START, &PROP_BOOL(GF_TRUE));\n\t\t\tif (ds->set_period_switch) {\n\t\t\t\tds->set_period_switch = GF_FALSE;\n\t\t\t\tgf_filter_pck_set_property(pck, GF_PROP_PID_DASH_PERIOD_START, &PROP_LONGUINT(0) );\n\t\t\t}\n\t\t}\n\t}\n\n\t//only signal file name & insert timelines on one stream for muxed representations\n\tif (ds->muxed_base) return;\n\n\tds->seg_start_time = ds->first_cts_in_seg;\n\tif (ds->timescale != ds->mpd_timescale) {\n\t\tds->seg_start_time = gf_timestamp_rescale(ds->seg_start_time, ds->timescale, ds->mpd_timescale);\n\t}\n\tds->last_min_segment_start_time = ds->first_cts_in_seg;\n\tds->last_min_segment_start_time *= 1000;\n\tds->last_min_segment_start_time /= ds->timescale;\n\n\tif (ds->last_min_segment_start_time > ctx->min_segment_start_time)\n\t\tctx->min_segment_start_time = ds->last_min_segment_start_time;\n\n\tif (ctx->store_seg_states) {\n\t\tchar *kms_uri;\n\t\tconst GF_PropertyValue *p;\n\t\tassert(!ctx->gencues);\n\t\tif (!ds->rep->state_seg_list) {\n\t\t\tds->rep->state_seg_list = gf_list_new();\n\t\t}\n\t\tif (!ds->rep->dash_dur.num) {\n\t\t\tds->rep->timescale = ds->timescale;\n\t\t\tds->rep->streamtype = ds->stream_type;\n\t\t\tds->rep->timescale_mpd = ds->mpd_timescale;\n\t\t\tp = gf_filter_pid_get_property(ds->ipid, GF_PROP_PID_HLS_GROUPID);\n\t\t\tif (p)\n\t\t\t\tds->rep->groupID = p->value.string;\n\n\t\t\tds->rep->dash_dur = ds->dash_dur;\n\t\t\tds->rep->hls_max_seg_dur = ds->dash_dur;\n\n\t\t\tif (!ds->rep->hls_single_file_name) {\n\t\t\t\tswitch (ctx->muxtype) {\n\t\t\t\tcase DASHER_MUX_TS:\n\t\t\t\tcase DASHER_MUX_OGG:\n\t\t\t\tcase DASHER_MUX_RAW:\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tif (ds->set->bitstream_switching && ds->set->segment_template)\n\t\t\t\t\t\tds->rep->hls_single_file_name = ds->set->segment_template->hls_init_name;\n\t\t\t\t\telse\n\t\t\t\t\t\tds->rep->hls_single_file_name = ds->init_seg;\n\t\t\t\t}\n\t\t\t}\n\t\t\tds->rep->nb_chan = ds->nb_ch;\n\t\t\tds->rep->m3u8_name = ds->hls_vp_name;\n\t\t\tif (ds->fps.den) {\n\t\t\t\tds->rep->fps = ds->fps.num;\n\t\t\t\tds->rep->fps /= ds->fps.den;\n\t\t\t}\n\t\t}\n\t\tGF_SAFEALLOC(seg_state, GF_DASH_SegmentContext);\n\t\tif (!seg_state) return;\n\t\tseg_state->time = ds->seg_start_time;\n\t\tseg_state->seg_num = ds->seg_number;\n\t\tseg_state->llhls_mode = ctx->llhls;\n\t\tds->current_seg_state = seg_state;\n\t\tseg_state->encrypted = GF_FALSE;\n\n\t\tp = gf_filter_pid_get_property(ds->ipid, GF_PROP_PID_HLS_KMS);\n\t\tkms_uri = (p && p->value.string) ? p->value.string : NULL;\n\t\tif (ds->tci) {\n\t\t\tu32 s;\n\t\t\tds->iv_low++;\n\t\t\tif (ds->iv_low == 0)\n\t\t\t\tds->iv_high++;\n\t\t\tfor (s=0; s<8; s++)\n\t\t\t\tseg_state->hls_iv[s] = (ds->iv_high >> 8*(7-s) ) & 0xFF;\n\t\t\tfor (s=0; s<8; s++)\n\t\t\t\tseg_state->hls_iv[s+8] = (ds->iv_low >> 8*(7-s) ) & 0xFF;\n\n\t\t\tseg_state->encrypted = GF_TRUE;\n\t\t\tgf_cryptfout_push_key(ds->dst_filter, & ds->tci->keys[ds->key_idx].key, &seg_state->hls_iv);\n\n\t\t\tif (ds->tci->keys[ds->key_idx].hls_info)\n\t\t\t\tkms_uri = ds->tci->keys[ds->key_idx].hls_info;\n\n\t\t\tds->nb_crypt_seg++;\n\t\t\tif (ds->tci->keyRoll) {\n\t\t\t\tif (ds->nb_crypt_seg == ds->tci->keyRoll) {\n\t\t\t\t\tds->nb_crypt_seg = 0;\n\t\t\t\t\tds->key_idx = (ds->key_idx+1) % ds->tci->nb_keys;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//we need a hard copy as the pid may reconfigure before we flush the segment\n\t\tif (kms_uri) {\n\t\t\t//insert IV if not mp4\n\t\t\tif (!ds->tci && !strstr(kms_uri, \"IV=\") && (ctx->muxtype!=DASHER_MUX_ISOM)) {\n\t\t\t\tp = gf_filter_pid_get_property(ds->ipid, GF_PROP_PID_CENC_KEY_INFO);\n\t\t\t\tif (p && (p->value.data.size==37)) {\n\t\t\t\t\tchar *kms_iv=NULL;\n\t\t\t\t\tu8 *iv=p->value.data.ptr + 21;\n\t\t\t\t\tchar szIV[40];\n\t\t\t\t\tu32 i;\n\t\t\t\t\tstrcpy(szIV, \"IV=0x\");\n\t\t\t\t\tfor (i=0; i<16; i++) {\n\t\t\t\t\t\tchar szVal[3];\n\t\t\t\t\t\tsprintf(szVal, \"%02X\", iv[i]);\n\t\t\t\t\t\tstrcat(szIV, szVal);\n\t\t\t\t\t}\n\t\t\t\t\tif (!strstr(kms_uri, \"URI=\")) {\n\t\t\t\t\t\tgf_dynstrcat(&kms_iv, \"URI=\\\"\", NULL);\n\t\t\t\t\t\tgf_dynstrcat(&kms_iv, kms_uri, NULL);\n\t\t\t\t\t\tgf_dynstrcat(&kms_iv, \"\\\"\", NULL);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tgf_dynstrcat(&kms_iv, kms_uri, NULL);\n\t\t\t\t\t}\n\t\t\t\t\tgf_dynstrcat(&kms_iv, szIV, \",\");\n\t\t\t\t\tseg_state->hls_key_uri = kms_iv;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!seg_state->hls_key_uri) {\n\t\t\t\tif (!strstr(kms_uri, \"URI=\")) {\n\t\t\t\t\tgf_dynstrcat(&seg_state->hls_key_uri, \"URI=\\\"\", NULL);\n\t\t\t\t\tgf_dynstrcat(&seg_state->hls_key_uri, kms_uri, NULL);\n\t\t\t\t\tgf_dynstrcat(&seg_state->hls_key_uri, \"\\\"\", NULL);\n\t\t\t\t} else {\n\t\t\t\t\tseg_state->hls_key_uri = gf_strdup(kms_uri);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tgf_list_add(ds->rep->state_seg_list, seg_state);\n\t\tif (ctx->sigfrag) {\n\t\t\tconst GF_PropertyValue *frag_range = gf_filter_pck_get_property(in_pck, GF_PROP_PCK_FRAG_RANGE);\n\t\t\tconst GF_PropertyValue *frag_url = gf_filter_pck_get_property(in_pck, GF_PROP_PID_URL);\n\t\t\tconst GF_PropertyValue *frag_name = gf_filter_pck_get_property(in_pck, GF_PROP_PCK_FILENAME);\n\n\t\t\tif (frag_url && frag_name) {\n\t\t\t\tseg_state->filename = dasher_strip_base(ctx, ds, frag_url->value.string, frag_name->value.string);\n\t\t\t} else if (frag_range) {\n\t\t\t\tseg_state->file_offset = frag_range->value.lfrac.num;\n\t\t\t\tseg_state->file_size = (u32) (frag_range->value.lfrac.den - seg_state->file_offset);\n\n\t\t\t\tif (ds->rep->segment_base && !ds->rep->segment_base->initialization_segment) {\n\t\t\t\t\tGF_MPD_URL *url;\n\t\t\t\t\tGF_SAFEALLOC(url, GF_MPD_URL);\n\t\t\t\t\tif (url) {\n\t\t\t\t\t\tGF_SAFEALLOC(url->byte_range, GF_MPD_ByteRange);\n\t\t\t\t\t\tif (url->byte_range) {\n\t\t\t\t\t\t\turl->byte_range->start_range = 0;\n\t\t\t\t\t\t\turl->byte_range->end_range = seg_state->file_offset-1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tds->rep->segment_base->initialization_segment = url;\n\n\t\t\t\t\t//first seg, remove sidx if present\n\t\t\t\t\t//our frag_range includes sidx\n\t\t\t\t\tconst GF_PropertyValue *sidx_range = gf_filter_pck_get_property(in_pck, GF_PROP_PCK_SIDX_RANGE);\n\t\t\t\t\tif (sidx_range) {\n\t\t\t\t\t\tu64 sidx_size = (u64)sidx_range->value.lfrac.den;\n\t\t\t\t\t\tsidx_size -= (u64) sidx_range->value.lfrac.num;\n\t\t\t\t\t\tseg_state->file_offset += sidx_size;\n\t\t\t\t\t\tseg_state->file_size -= (u32) sidx_size;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tgf_list_del_item(ds->rep->state_seg_list, seg_state);\n\t\t\t\tgf_free(seg_state);\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_DASH, (\"[Dasher] Manifest generation only but not fragment information in packet, source demux not properly configured\\n\"));\n\t\t\t\tctx->in_error = GF_TRUE;\n\t\t\t}\n\t\t} else if (!ctx->index_media_duration) {\n\t\t\tgf_list_add(ds->pending_segment_states, seg_state);\n\t\t\tctx->nb_seg_url_pending++;\n\t\t}\n\t}\n\n\tszIndexName[0] = 0;\n\tif (ds->idx_template) {\n\t\t//get final segment template - output file name is NULL, we already have solved this in source_setup\n\t\tgf_media_mpd_format_segment_name(GF_DASH_TEMPLATE_REPINDEX, ds->set->bitstream_switching, szIndexName, base_ds->rep_id, NULL, base_ds->idx_template, NULL, base_ds->seg_start_time, base_ds->rep->bandwidth, base_ds->seg_number, base_ds->stl, ctx->tpl_force);\n\n\t\tstrcpy(szSegmentFullPath, szIndexName);\n\t\tif (ctx->out_path) {\n\t\t\tchar *rel = gf_url_concatenate(ctx->out_path, szIndexName);\n\t\t\tif (rel) {\n\t\t\t\tstrcpy(szSegmentFullPath, rel);\n\t\t\t\tgf_free(rel);\n\t\t\t}\n\t\t}\n\t\tif (pck)\n\t\t\tgf_filter_pck_set_property(pck, GF_PROP_PCK_IDXFILENAME, &PROP_STRING(szSegmentFullPath) );\n\t}\n\n\tif (ctx->sseg) {\n\t\tif (ctx->gencues) return;\n\n\t\tif (ctx->sigfrag) {\n\t\t\tBool has_root_sidx = GF_TRUE;\n\t\t\tconst GF_PropertyValue *p = gf_filter_pid_get_property(ds->ipid, GF_PROP_PCK_SIDX_RANGE);\n\t\t\tif (!p) {\n\t\t\t\tp = gf_filter_pck_get_property(in_pck, GF_PROP_PCK_SIDX_RANGE);\n\t\t\t\thas_root_sidx = GF_FALSE;\n\t\t\t}\n\n\n\t\t\tif (p) {\n\t\t\t\tif (ds->rep->segment_base && !ds->rep->segment_base->index_range) {\n\t\t\t\t\tGF_SAFEALLOC(ds->rep->segment_base->index_range, GF_MPD_ByteRange);\n\t\t\t\t\tif (ds->rep->segment_base->index_range) {\n\t\t\t\t\t\tds->rep->segment_base->index_range->start_range = p->value.lfrac.num;\n\t\t\t\t\t\tds->rep->segment_base->index_range->end_range = p->value.lfrac.den-1;\n\t\t\t\t\t\tds->rep->segment_base->index_range_exact = GF_TRUE;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!ds->rep->segment_base->initialization_segment) {\n\t\t\t\t\t\tGF_SAFEALLOC(ds->rep->segment_base->initialization_segment, GF_MPD_URL);\n\t\t\t\t\t}\n\t\t\t\t\tif (ds->rep->segment_base->initialization_segment && !ds->rep->segment_base->initialization_segment->byte_range) {\n\t\t\t\t\t\tGF_SAFEALLOC(ds->rep->segment_base->initialization_segment->byte_range, GF_MPD_ByteRange);\n\t\t\t\t\t\tif (ds->rep->segment_base->initialization_segment->byte_range) {\n\t\t\t\t\t\t\tds->rep->segment_base->initialization_segment->byte_range->start_range = 0;\n\t\t\t\t\t\t\tds->rep->segment_base->initialization_segment->byte_range->end_range = p->value.lfrac.num-1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if (!has_root_sidx) {\n\t\t\t\t\tctx->in_error = GF_TRUE;\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_DASH, (\"[Dasher] Several SIDX found but trying to regenerate an on-demand MPD, source file is not compatible. Try re-dashing the content or use main or full profiles\\n\"));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\n\tif (ctx->sfile) {\n\t\tGF_MPD_SegmentURL *seg_url;\n\t\tassert(ds->rep->segment_list);\n\n\t\tif (ctx->gencues) return;\n\n\t\tGF_SAFEALLOC(seg_url, GF_MPD_SegmentURL);\n\t\tif (!seg_url) return;\n\n\t\tgf_list_add(ds->rep->segment_list->segment_URLs, seg_url);\n\t\tif (szIndexName[0])\n\t\t\tseg_url->index = gf_strdup(szIndexName);\n\n\t\tif (ctx->sigfrag) {\n\t\t\tconst GF_PropertyValue *frag_range = gf_filter_pck_get_property(in_pck, GF_PROP_PCK_FRAG_RANGE);\n\t\t\tconst GF_PropertyValue *frag_url = gf_filter_pck_get_property(in_pck, GF_PROP_PID_URL);\n\t\t\tconst GF_PropertyValue *frag_name = gf_filter_pck_get_property(in_pck, GF_PROP_PCK_FILENAME);\n\t\t\tif (frag_url && frag_name) {\n\t\t\t\tseg_url->media = dasher_strip_base(ctx, ds, frag_url->value.string, frag_name->value.string);\n\t\t\t\tif (ds->rep->segment_list && ds->rep->segment_list->initialization_segment && !ds->rep->segment_list->initialization_segment->sourceURL) {\n\n\t\t\t\t\tfrag_url = gf_filter_pid_get_property(ds->ipid, GF_PROP_PID_URL);\n\t\t\t\t\tfrag_name = gf_filter_pid_get_property_str(ds->ipid, \"init_url\");\n\t\t\t\t\tif (frag_url && frag_name) {\n\t\t\t\t\t\tu32 j, nb_base;\n\t\t\t\t\t\tds->rep->segment_list->initialization_segment->sourceURL = dasher_strip_base(ctx, ds, frag_url->value.string, frag_name->value.string);\n\n\t\t\t\t\t\tnb_base = gf_list_count(ds->rep->base_URLs);\n\t\t\t\t\t\tfor (j=0; j<nb_base; j++) {\n\t\t\t\t\t\t\tGF_MPD_BaseURL *burl = gf_list_get(ds->rep->base_URLs, j);\n\t\t\t\t\t\t\tif (! strcmp(burl->URL, frag_url->value.string)) {\n\t\t\t\t\t\t\t\tgf_list_rem(ds->rep->base_URLs, j);\n\t\t\t\t\t\t\t\tgf_mpd_base_url_free(burl);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (frag_range) {\n\t\t\t\tGF_SAFEALLOC(seg_url->media_range, GF_MPD_ByteRange);\n\t\t\t\tif (seg_url->media_range) {\n\t\t\t\t\tseg_url->media_range->start_range = frag_range->value.lfrac.num;\n\t\t\t\t\tseg_url->media_range->end_range = frag_range->value.lfrac.den - 1;\n\t\t\t\t}\n\t\t\t\tif (ds->rep->segment_list && ds->rep->segment_list->initialization_segment && !ds->rep->segment_list->initialization_segment->byte_range) {\n\t\t\t\t\tGF_SAFEALLOC(ds->rep->segment_list->initialization_segment->byte_range, GF_MPD_ByteRange);\n\t\t\t\t\tif (ds->rep->segment_list->initialization_segment->byte_range) {\n\t\t\t\t\t\tds->rep->segment_list->initialization_segment->byte_range->start_range = 0;\n\t\t\t\t\t\tds->rep->segment_list->initialization_segment->byte_range->end_range = frag_range->value.lfrac.num-1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tgf_list_add(ds->pending_segment_urls, seg_url);\n\t\t\tctx->nb_seg_url_pending++;\n\t\t}\n\t\treturn;\n\t}\n\n\tif (!ds->stl && !ctx->cues && !ctx->forward_mode && (pck || in_pck) ) {\n\t\tDouble drift, seg_start = (Double) ds->seg_start_time;\n\t\tseg_start /= ds->mpd_timescale;\n\t\tdrift = seg_start - ((Double)(ds->seg_number - ds->startNumber)) * ds->dash_dur.num / ds->dash_dur.den;\n\n\t\tif ((ds->dash_dur.num>0) && (ABS(drift) * 2 * ds->dash_dur.den > ds->dash_dur.num)) {\n\t\t\tu64 cts = 0;\n\t\t\tif (pck) {\n\t\t\t\tcts = dasher_translate_cts(ds, gf_filter_pck_get_cts(pck) );\n\t\t\t} else if (in_pck) {\n\t\t\t\tcts = gf_filter_pck_get_cts(in_pck);\n\t\t\t}\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_DASH, (\"[Dasher] First CTS \"LLU\" in segment %d drifting by %g (more than half a segment duration) from segment time, consider reencoding or using segment timeline\\n\", cts, ds->seg_number,  drift));\n\t\t}\n\t}\n\n\tif (!ctx->forward_mode) {\n\t\t/*get final segment template - output file name is NULL, we already have solved this in source_setup\n\t\tsegment time must be PTO-adjusted !*/\n\t\tu64 pto = ds->presentation_time_offset;\n\t\tif (base_ds->timescale != base_ds->mpd_timescale) {\n\t\t\tpto = gf_timestamp_rescale(pto, base_ds->timescale, base_ds->mpd_timescale);\n\t\t}\n\n\t\tgf_media_mpd_format_segment_name(GF_DASH_TEMPLATE_SEGMENT, ds->set->bitstream_switching, szSegmentName, base_ds->rep_id, NULL, base_ds->seg_template, NULL, base_ds->seg_start_time + pto, base_ds->rep->bandwidth, base_ds->seg_number, ds->stl, ctx->tpl_force);\n\n\t}\n\n\nsend_packet:\n\n\tno_concat=GF_FALSE;\n\tif (ctx->from_index==IDXMODE_SEG) {\n\t\tconst GF_PropertyValue *p = gf_filter_pid_get_property_str(ds->ipid, \"idx_out\");\n\t\tif (p) {\n\t\t\tstrcpy(szSegmentName, p->value.string);\n\t\t\tstrcpy(szSegmentFullPath, p->value.string);\n\t\t\tno_concat = GF_TRUE;\n\t\t}\n\t}\n\tif (!no_concat)\n\t\tstrcpy(szSegmentFullPath, szSegmentName);\n\n\tif (!no_concat && ctx->out_path) {\n\t\tchar *rel = NULL;\n\t\tif (ctx->do_m3u8 && ds->hls_vp_name && !ctx->forward_mode) {\n\t\t\tchar *tmp = gf_url_concatenate(ctx->out_path, ds->hls_vp_name);\n\t\t\tif (tmp) {\n\t\t\t\trel = gf_url_concatenate(tmp, szSegmentName);\n\t\t\t\tgf_free(tmp);\n\t\t\t}\n\t\t}\n\t\tif (!rel)\n\t\t\trel = gf_url_concatenate(ctx->out_path, szSegmentName);\n\n\t\tif (rel) {\n\t\t\tstrcpy(szSegmentFullPath, rel);\n\t\t\tgf_free(rel);\n\t\t}\n\t}\n\n\tif (seg_state && !ctx->sigfrag) {\n\t\tseg_state->filepath = gf_strdup(szSegmentFullPath);\n\t\tseg_state->filename = gf_strdup(szSegmentName);\n\t}\n\n\tif (ds->rep->segment_list && (ctx->forward_mode!=DASHER_FWD_ALL) && !ctx->gencues) {\n\t\tGF_MPD_SegmentURL *seg_url;\n\t\tGF_SAFEALLOC(seg_url, GF_MPD_SegmentURL);\n\t\tif (seg_url) {\n\t\t\tgf_list_add(ds->rep->segment_list->segment_URLs, seg_url);\n\t\t\tif (!ctx->do_index) {\n\t\t\t\tseg_url->media = gf_strdup(szSegmentName);\n\t\t\t\tif (!ctx->index_media_duration) {\n\t\t\t\t\tgf_list_add(ds->pending_segment_urls, seg_url);\n\t\t\t\t\tctx->nb_seg_url_pending++;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tseg_url->first_tfdt = in_pck ? gf_filter_pck_get_dts(in_pck) : 0;\n\t\t\t\tseg_url->first_pck_seq = in_pck ? ds->nb_pck : 0;\n\t\t\t\tseg_url->frag_start_offset = ds->frag_start_offset;\n\t\t\t\tseg_url->frag_tfdt = ds->frag_first_ftdt;\n\t\t\t\t//set constant duration to first packet duration (as used by mp4mx to compute defaults)\n\t\t\t\t//this will avoid generating trex with different default duration if working with or without sample\n\t\t\t\tif (!ds->rep->segment_list->sample_duration) {\n\t\t\t\t\tif (in_pck) {\n\t\t\t\t\t\tds->rep->segment_list->sample_duration = gf_filter_pck_get_duration(in_pck);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconst GF_PropertyValue *p = gf_filter_pid_get_property(ds->ipid, GF_PROP_PID_CONSTANT_DURATION);\n\t\t\t\t\t\tif (p) ds->rep->segment_list->sample_duration = p->value.uint;\n\t\t\t\t\t}\n\n\t\t\t\t\tds->rep->segment_list->index_mode = GF_TRUE;\n\t\t\t\t\tif (ds->pts_minus_cts<0)\n\t\t\t\t\t\tds->rep->segment_list->pid_delay = (u32) (-ds->pts_minus_cts);\n\t\t\t\t\tds->rep->segment_list->src_timescale = ds->timescale;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (szIndexName[0])\n\t\t\t\tseg_url->index = gf_strdup(szIndexName);\n\t\t}\n\t}\n\tif (pck)\n\t\tgf_filter_pck_set_property(pck, GF_PROP_PCK_FILENAME, &PROP_STRING(szSegmentFullPath) );\n}\n\nstatic Bool dasher_check_loop(GF_DasherCtx *ctx, GF_DashStream *ds)\n{\n\tu32 i, count;\n\tu32 pmode = GF_PLAYBACK_MODE_NONE;\n\tu64 ts_offset, max_ts_offset, max_ts_scale;\n\tconst GF_PropertyValue *p;\n\tif (!ds->src_url) return GF_FALSE;\n\n\t//loop requested\n\tif (ds->loop_state==2) return GF_TRUE;\n\n\tcount = gf_list_count(ctx->current_period->streams);\n\tif (!ds->loop_state) {\n\t\tfor (i=0; i<count; i++) {\n\t\t\tGF_DashStream *a_ds = gf_list_get(ctx->current_period->streams, i);\n\n\t\t\tp = gf_filter_pid_get_property(a_ds->ipid, GF_PROP_PID_PLAYBACK_MODE);\n\t\t\tif (p) pmode = p->value.uint;\n\t\t\tif (pmode == GF_PLAYBACK_MODE_NONE) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_DASH, (\"[Dasher] Loop requested in subdur mode, but source cannot seek, defaulting to multi period for all streams\\n\"));\n\t\t\t\tctx->loop = GF_FALSE;\n\t\t\t\treturn GF_FALSE;\n\t\t\t}\n\t\t}\n\t\tds->loop_state = 1;\n\t}\n\n\tmax_ts_offset = 0;\n\tmax_ts_scale = 1;\n\t//check all input media duration\n\tfor (i=0; i<count; i++) {\n\t\tGF_DashStream *a_ds = gf_list_get(ctx->current_period->streams, i);\n\n\t\t//one pid is waiting for loop while another has done its subdur and won't process any new segment until the next subdur call, which\n\t\t//will never happen since the first PID waits for loop. We must force early generation in this case\n\t\tif (a_ds->subdur_done) {\n\t\t\ta_ds->subdur_done = GF_FALSE;\n\t\t\t//remember the max period dur before this forced segment generation\n\t\t\ta_ds->subdur_forced_use_period_dur = a_ds->max_period_dur;\n\t\t}\n\n\t\t//wait for each input to query loop\n\t\tif (!a_ds->loop_state) {\n\t\t\ta_ds->done = 0;\n\t\t\treturn GF_TRUE;\n\t\t}\n\n\t\t//get max duration\n\t\tts_offset = a_ds->est_next_dts;\n\n\t\tif (gf_timestamp_less(max_ts_offset, max_ts_scale, ts_offset, a_ds->timescale)) {\n\t\t\tmax_ts_offset = ts_offset;\n\t\t\tmax_ts_scale = a_ds->timescale;\n\t\t}\n\t}\n\n\t//assign ts offset and send stop/play\n\tfor (i=0; i<count; i++) {\n\t\tGF_DashStream *a_ds = gf_list_get(ctx->current_period->streams, i);\n\n\t\tif (a_ds->subdur_done)\n\t\t\tcontinue;\n\n\t\tts_offset = gf_timestamp_rescale(max_ts_offset, max_ts_scale, a_ds->timescale);\n\n\t\ta_ds->ts_offset = ts_offset;\n\t\tif (a_ds->done) continue;\n\t\tif (a_ds->ts_offset > a_ds->est_next_dts) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_DASH, (\"[Dasher] Looping streams of unequal duration, inserting \"LLU\" us of timestamp delay in pid %s from %s\\n\", ((a_ds->ts_offset - a_ds->est_next_dts) * 1000000) / a_ds->timescale, gf_filter_pid_get_name(a_ds->ipid), a_ds->src_url));\n\t\t}\n\n\t\ta_ds->seek_to_pck = 0;\n\t\ta_ds->nb_pck = 0;\n\t\ta_ds->clamp_done = GF_FALSE;\n\n\t\ta_ds->loop_state = 2;\n\n\t\tif (ctx->subdur) {\n\t\t\tGF_FilterEvent evt;\n\n\t\t\tGF_FEVT_INIT(evt, GF_FEVT_STOP, a_ds->ipid);\n\t\t\tgf_filter_pid_send_event(a_ds->ipid, &evt);\n\n\t\t\tgf_filter_pid_set_discard(a_ds->ipid, GF_FALSE);\n\n\t\t\tdasher_send_encode_hints(ctx, ds);\n\n\t\t\tGF_FEVT_INIT(evt, GF_FEVT_PLAY, a_ds->ipid);\n\t\t\tevt.play.speed = 1.0;\n\t\t\tgf_filter_pid_send_event(a_ds->ipid, &evt);\n\t\t}\n\t}\n\n\treturn GF_TRUE;\n}\n\n//depending on input formats, streams may be declared with or without DCD. For streams requiring the config, wait for it\nstatic Bool dasher_check_period_ready(GF_DasherCtx *ctx, Bool is_session_end)\n{\n\tu32 i=0;\n\tGF_DashStream *ds;\n\tctx->period_not_ready = GF_FALSE;\n\twhile ((ds = gf_list_enum(ctx->current_period->streams, &i))) {\n\n\t\tif (is_session_end)\n\t\t\tgf_filter_pid_set_discard(ds->ipid, GF_TRUE);\n\n\t\tif (ds->dcd_not_ready) {\n\t\t\tGF_FilterPacket *pck;\n\t\t\tu32 prev = ds->dcd_not_ready;\n\t\t\tds->dcd_not_ready = 0;\n\t\t\tpck = gf_filter_pid_get_packet(ds->ipid);\n\t\t\tif (!pck) {\n\t\t\t\tu32 diff = gf_sys_clock() - prev;\n\t\t\t\tif (diff > 10000) {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_DASH, (\"[Dasher] Failed to initialize PID %s, no packets after %d ms, aborting\\n\", gf_filter_pid_get_name(ds->ipid), diff));\n\t\t\t\t\tctx->in_error = GF_TRUE;\n\t\t\t\t\treturn GF_FALSE;\n\t\t\t\t}\n\t\t\t\tds->dcd_not_ready = prev;\n\t\t\t\tctx->period_not_ready = GF_TRUE;\n\t\t\t\treturn GF_FALSE;\n\t\t\t}\n\t\t}\n\t}\n\treturn GF_TRUE;\n}\n\nvoid dasher_format_report(GF_Filter *filter, GF_DasherCtx *ctx)\n{\n\tu32 i, count, nb_pc=0;\n\tDouble max_ts=0;\n\tu32 total_pc = 0;\n\tchar szDS[200];\n\tchar *szStatus = NULL;\n\n\tif (!gf_filter_reporting_enabled(filter))\n\t\treturn;\n\tif (!ctx->update_report)\n\t\treturn;\n\t//don't update at each packet, this would be too much\n\tif ((ctx->update_report>0) && (ctx->update_report < 20))\n\t\treturn;\n\n\tctx->update_report = 0;\n\n\tsprintf(szDS, \"P%s\", ctx->current_period->period->ID ? ctx->current_period->period->ID : \"1\");\n\tgf_dynstrcat(&szStatus, szDS, NULL);\n\n\tcount = gf_list_count(ctx->current_period->streams);\n\tfor (i=0; i<count; i++) {\n\t\ts32 pc=-1;\n\t\tDouble mpdtime;\n\t\tu32 set_idx;\n\t\tu32 rep_idx;\n\t\tu8 stype;\n\t\tGF_DashStream *ds = gf_list_get(ctx->current_period->streams, i);\n\t\tif (ds->muxed_base) continue;\n\n\t\tset_idx = 1 + gf_list_find(ctx->current_period->period->adaptation_sets, ds->set);\n\t\trep_idx = 1 + gf_list_find(ds->set->representations, ds->rep);\n\t\tif (ds->stream_type==GF_STREAM_VISUAL) stype='V';\n\t\telse if (ds->stream_type==GF_STREAM_AUDIO) stype='A';\n\t\telse if (ds->stream_type==GF_STREAM_TEXT) stype='T';\n\t\telse stype='M';\n\n\t\tif (ds->done || ds->subdur_done) {\n\t\t\tsprintf(szDS, \"AS#%d.%d(%c) done (%d segs)\", set_idx, rep_idx, stype, ds->seg_number);\n\t\t\tpc = 10000;\n\t\t} else {\n\t\t\tDouble done;\n\t\t\tif (ctx->cues) {\n\t\t\t\tdone = (Double) (ds->last_dts);\n\t\t\t\tdone /= ds->timescale;\n\t\t\t\tsnprintf(szDS, 200, \"AS#%d.%d(%c) seg #%d %02.2fs\", set_idx, rep_idx, stype, ds->seg_number, done);\n\t\t\t} else {\n\t\t\t\tDouble pcent, ddur;\n\t\t\t\tdone = (Double) ds->adjusted_next_seg_start;\n\t\t\t\tdone -= (Double) ds->last_dts;\n\t\t\t\tif (done<0)\n\t\t\t\t\tdone=0;\n\t\t\t\tdone /= ds->timescale;\n\t\t\t\tddur = ((Double)ds->dash_dur.num) / ds->dash_dur.den;\n\t\t\t\tdone = ddur - done;\n\t\t\t\t//this may happen since we don't print info at segment start\n\t\t\t\tif (done<0)\n\t\t\t\t\tdone=0;\n\t\t\t\tpcent = done / ddur;\n\t\t\t\tpc = (s32) (done * 10000);\n\t\t\t\tsnprintf(szDS, 200, \"AS#%d.%d(%c) seg #%d %02.2fs (%02.2f %%)\", set_idx, rep_idx, stype, ds->seg_number, done, 100*pcent);\n\t\t\t}\n\n\t\t\tmpdtime = (Double) ds->last_dts;\n\t\t\tmpdtime -= (Double) ds->first_dts;\n\t\t\tif (mpdtime<0) mpdtime=0;\n\t\t\tmpdtime /= ds->timescale;\n\n\t\t\tif (ds->duration.den && ds->duration.num) {\n\t\t\t\tdone = mpdtime;\n\n\t\t\t\tdone *= ds->duration.den;\n\t\t\t\tdone /= ds->duration.num;\n\t\t\t\tpc = (u32) (10000*done);\n\t\t\t}\n\t\t\tif (max_ts<mpdtime)\n\t\t\t\tmax_ts = mpdtime;\n\t\t}\n\t\t//don't use max, do an average\n\t\ttotal_pc += pc;\n\t\tnb_pc++;\n\t\tgf_dynstrcat(&szStatus, szDS, \" \");\n\t}\n\tif (nb_pc)\n\t\ttotal_pc /= nb_pc;\n\n\tif (total_pc!=10000) {\n\t\tsprintf(szDS, \" / MPD %.2fs %d %%\", max_ts, total_pc/100);\n\t\tgf_dynstrcat(&szStatus, szDS, NULL);\n\t}\n\tgf_filter_update_status(filter, total_pc, szStatus);\n\tgf_free(szStatus);\n}\n\nstatic void dasher_drop_input(GF_DasherCtx *ctx, GF_DashStream *ds, Bool discard_all)\n{\n\tif (ds->sbound) {\n\t\twhile (gf_list_count(ds->packet_queue)) {\n\t\t\tGF_FilterPacket *pck = gf_list_pop_front(ds->packet_queue);\n\t\t\tif (gf_filter_pck_get_sap(pck)) {\n\t\t\t\tassert(ds->nb_sap_in_queue);\n\t\t\t\tds->nb_sap_in_queue --;\n\t\t\t}\n\t\t\tgf_filter_pck_unref(pck);\n\t\t\tif (!discard_all) break;\n\t\t}\n\t} else {\n\t\tgf_filter_pid_drop_packet(ds->ipid);\n\t}\n\tif (discard_all) {\n\t\tgf_filter_pid_set_discard(ds->ipid, GF_TRUE);\n\t}\n}\n\nstatic void dasher_inject_eods(GF_DasherCtx *ctx, GF_DashStream *ds, Bool forced)\n{\n\t//in dynamic mode, send end of dash segment marker to flush segment right away, otherwise we will\n\t//flush the segment at next segment start which could be after the segment AST => 404\n\t//\n\t//if subdur no need to do so as we will close the muxer right after\n\t//if sigfrag no need to do so since we don't generate media packets\n\tif (!ctx->subdur && ((ctx->dmode>=GF_DASH_DYNAMIC) || forced) && !ctx->sigfrag && !ctx->do_index) {\n\t\tGF_FilterPacket *eods_pck;\n\t\teods_pck = gf_filter_pck_new_alloc(ds->opid, 0, NULL);\n\t\tif (eods_pck) {\n\t\t\tgf_filter_pck_set_property(eods_pck, GF_PROP_PCK_EODS, &PROP_BOOL(GF_TRUE) );\n\t\t\tgf_filter_pck_send(eods_pck);\n\t\t}\n\t}\n}\n\nstatic const char *empty_ttml = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n<tt xmlns=\\\"http://www.w3.org/ns/ttml\\\" xml:lang=\\\"en\\\">\\n<head/>\\n<body/>\\n</tt>\";\n\nstatic void dasher_send_empty_segment(GF_DasherCtx *ctx, GF_DashStream *ds)\n{\n\tGF_FilterPacket *pck=NULL;\n\tu8 *data;\n\n\tif (ds->segment_started) {\n\t\tu64 next_cts = ds->first_cts_in_seg + gf_timestamp_rescale(ds->dash_dur.num, ds->dash_dur.den, ds->timescale);\n\t\tds->first_cts_in_next_seg = next_cts;\n\t\tassert(ds->nb_comp_done < ds->nb_comp);\n\t\tds->nb_comp_done ++;\n\t\tds->split_dur_next = 0;\n\t\tds->seg_done = GF_TRUE;\n\n\t\tdasher_inject_eods(ctx, ds, GF_FALSE);\n\n\t\t//force to be last rep in set to be done\n\t\tds->nb_rep_done = ds->nb_rep-1;\n\t\tdasher_flush_segment(ctx, ds, GF_FALSE);\n\n\t\tds->first_cts_in_seg = next_cts;\n\t\tds->split_dur_next = 0;\n\t}\n\n\tif (ds->opid && (!ctx->from_index || (ctx->from_index==IDXMODE_SEG) )) {\n\n\t\tif (ds->codec_id == GF_CODECID_SUBS_XML) {\n\t\t\t//write empty TTML doc\n\t\t\tu32 len = (u32) strlen(empty_ttml);\n\t\t\tpck = gf_filter_pck_new_alloc(ds->opid, len+1, &data);\n\t\t\tmemcpy(data, empty_ttml, len);\n\t\t\tdata[len] = 0;\n\t\t} else if (ds->codec_id == GF_CODECID_WEBVTT) {\n\t\t\t//write empty cue box, 8 byte size of type vtte\n\t\t\tpck = gf_filter_pck_new_alloc(ds->opid, 8, &data);\n\t\t\tdata[0] = data[1] = data[2] = 0; data[3] = 8;\n\t\t\tdata[4] = 'v'; data[5] = 't'; data[6] = 't'; data[7] = 'e';\n\t\t} else if (ds->codec_id == GF_CODECID_TX3G) {\n\t\t\t//write empty tx3g sample, 2 bytes text len=0\n\t\t\tpck = gf_filter_pck_new_alloc(ds->opid, 2, &data);\n\t\t\tdata[0] = data[1] = 0;\n\t\t} else {\n\t\t\tpck = gf_filter_pck_new_alloc(ds->opid, 0, &data);\n\t\t}\n\n\t\tgf_filter_pck_set_dts(pck, ds->first_cts_in_seg);\n\t\tgf_filter_pck_set_cts(pck, ds->first_cts_in_seg);\n\t\tgf_filter_pck_set_sap(pck, GF_FILTER_SAP_1);\n\t\t//we don't assign a duration\n\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_DASH, (\"[Dasher] Sending empty text packet CTS \"LLU\"/%d\\n\", ds->first_cts_in_seg, ds->timescale));\n\t}\n\n\tdasher_mark_segment_start(ctx, ds, pck, NULL);\n\tds->segment_started = GF_TRUE;\n\tif (pck)\n\t\tgf_filter_pck_send(pck);\n\n\tif (ctx->do_index) {\n\t\tGF_MPD_SegmentURL *s = gf_list_last(ds->rep->segment_list->segment_URLs);\n\t\ts->first_tfdt = ds->first_cts_in_seg;\n\t}\n\n\tds->first_cts_in_next_seg = ds->first_cts_in_seg + gf_timestamp_rescale(ds->dash_dur.num, ds->dash_dur.den, ds->timescale);\n\tds->est_first_cts_in_next_seg = ds->first_cts_in_next_seg;\n}\n\n\n\nstatic GF_Err dasher_process(GF_Filter *filter)\n{\n\tu32 i, count, nb_init, has_init, nb_reg_done;\n\tGF_DasherCtx *ctx = gf_filter_get_udta(filter);\n\tGF_Err e;\n\tBool seg_done = GF_FALSE;\n\tu32 nb_seg_waiting = 0;\n\tu32 nb_seg_active = 0;\n\n\tif (ctx->in_error) {\n\t\tgf_filter_abort(filter);\n\t\treturn GF_SERVICE_ERROR;\n\t}\n\tif (!ctx->utc_initialized) {\n\t\tdasher_init_utc(filter, ctx);\n\t\tif (!ctx->utc_initialized) return GF_OK;\n\t}\n\n\t//session regulation is on and we have a an MPD (setup done) and a next time (first seg processed)\n\t//check if we have reached the next time\n\tif (ctx->sreg && !ctx->state && ctx->mpd && ctx->mpd->gpac_next_ntp_ms) {\n\t\ts64 diff = (s64) ctx->mpd->gpac_next_ntp_ms;\n\t\tdiff -= (s64) gf_net_get_ntp_ms();\n\t\tif (diff>100) {\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_DASH, (\"[Dasher] Next generation scheduled in %d ms, nothing to do\\n\", diff));\n\t\t\tgf_filter_ask_rt_reschedule(filter, (u32) (diff*1000));\n\t\t\treturn GF_OK;\n\t\t}\n\t}\n\n\t//streams in period are not all ready, wait for them\n\tif (ctx->period_not_ready) {\n\t\tBool is_eos;\n\t\t//potpone until no pending connections, otherwise we may add input streams in the wrong period\n\t\tif (gf_filter_connections_pending(filter))\n\t\t\treturn GF_OK;\n\n\t\tis_eos = gf_filter_end_of_session(filter);\n\t\tif (! dasher_check_period_ready(ctx, is_eos)) {\n\t\t\treturn is_eos ? GF_SERVICE_ERROR : GF_OK;\n\t\t}\n\t\te = dasher_setup_period(filter, ctx, NULL);\n\t\tif (e) return e;\n\t}\n\tif (ctx->check_connections) {\n\t\tif (gf_filter_connections_pending(filter))\n\t\t\treturn GF_OK;\n\t\tctx->check_connections = GF_FALSE;\n\t}\n\n\tif (ctx->is_eos)\n\t\treturn GF_EOS;\n\tif (ctx->setup_failure) return ctx->setup_failure;\n\n\tcount = gf_list_count(ctx->current_period->streams);\n\tif (!ctx->min_cts_period.den) {\n\t\tu64 min_ts=0, min_timescale = 0;\n\t\tu32 num_ready=0, num_blocked=0;\n\t\tfor (i=0; i<count; i++) {\n\t\t\tGF_DashStream *ds = gf_list_get(ctx->current_period->streams, i);\n\t\t\tGF_FilterPacket *pck = gf_filter_pid_get_packet(ds->ipid);\n\t\t\tif (!pck) continue;\n\t\t\tu64 ts = gf_filter_pck_get_cts(pck);\n\t\t\t//only adjust if delay is negative (skip), otherwise (delay) keep mints as is.\n\t\t\t//Not doing so will set the rep PTO to the delay, canceling the delay ...\n\t\t\tif (ds->pts_minus_cts<0)\n\t\t\t\tts = ts + ds->pts_minus_cts;\n\t\t\tif (!min_ts || gf_timestamp_less(ts, ds->timescale, min_ts, min_timescale)) {\n\t\t\t\tmin_ts = ts;\n\t\t\t\tmin_timescale = ds->timescale;\n\t\t\t}\n\t\t\tnum_ready++;\n\t\t\tif (gf_filter_pid_would_block(ds->ipid)) num_blocked++;\n\t\t}\n\t\tif (count) {\n\t\t\tif (num_ready < num_blocked) return GF_OK;\n\t\t}\n\t\tctx->min_cts_period.num = min_ts;\n\t\tctx->min_cts_period.den = min_timescale;\n\t}\n\n\tnb_init = has_init = nb_reg_done = 0;\n\n\tfor (i=0; i<count; i++) {\n\t\tGF_DashStream *base_ds;\n\t\tGF_DashStream *ds = gf_list_get(ctx->current_period->streams, i);\n\t\tassert(ds);\n\t\tif (ds->done) continue;\n\t\tbase_ds = ds->muxed_base ? ds->muxed_base : ds;\n\t\t//subdur mode abort, don't process\n\t\tif (ds->subdur_done) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (ds->seg_done) continue;\n\n\t\tif (ctx->dmode == GF_MPD_TYPE_DYNAMIC_LAST) {\n\t\t\tif (!ds->done && ds->opid) gf_filter_pid_set_eos(ds->opid);\n\t\t\tds->done = 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\t//flush as much as possible\n\t\twhile (1) {\n\t\t\tu32 sap_type, dur, o_dur, split_dur;\n\t\t\ts32 check_dur;\n\t\t\tu64 cts, orig_cts, dts, split_dur_next, pcont_cts;\n\t\t\tBool seg_over = GF_FALSE;\n\t\t\tBool is_packet_split = GF_FALSE;\n\t\t\tBool is_queue_flush = GF_FALSE;\n\t\t\tGF_FilterPacket *dst;\n\t\t\tGF_FilterPacket *pck = NULL;\n\n\t\t\tif (!ds->request_period_switch) {\n\t\t\t\tassert(ds->period == ctx->current_period);\n\t\t\t\tpck = gf_filter_pid_get_packet(ds->ipid);\n\t\t\t\t//we may change period after a packet fetch (reconfigure of input pid)\n\t\t\t\tif ((ds->period != ctx->current_period) || ds->request_period_switch) {\n\t\t\t\t\t//in closest mode, flush queue\n\t\t\t\t\tif (!ds->sbound || !gf_list_count(ds->packet_queue)) {\n\t\t\t\t\t\tassert(gf_list_find(ctx->current_period->streams, ds)<0);\n\t\t\t\t\t\tcount = gf_list_count(ctx->current_period->streams);\n\t\t\t\t\t\ti--;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tis_queue_flush = GF_TRUE;\n\t\t\t\t}\n\n\t\t\t\t/*text streams, insert an empty segment if we are one segment behind last produced segment on other pids\n\t\t\t\t- we don't generate if behind this last time in case a next packet comes in\n\t\t\t\t- we only insert an empty segment if PID is done (eos) or if we generate for real-time\n\n\t\t\t\tWe cannot apply this in non real-time before end of stream, as we would end up starting a segment while next packet could be in the past (previous seg)\n\n\t\t\t\tTODO: extend this to send empty segments for other streams (audio, video) in case of signal loss ??\n\t\t\t\t*/\n\t\t\t\tif (!pck\n\t\t\t\t\t&& (ds->stream_type==GF_STREAM_TEXT)\n\t\t\t\t\t&& !ds->muxed_base\n\t\t\t\t\t&& (gf_filter_pid_is_eos(ds->ipid) || (ctx->dmode==GF_MPD_TYPE_DYNAMIC))\n\t\t\t\t) {\n\t\t\t\t\tu64 ddur_ms = (1000*ds->dash_dur.num)/ds->dash_dur.den;\n\t\t\t\t\twhile (ds->last_min_segment_start_time + ddur_ms < ctx->last_min_segment_start_time) {\n\t\t\t\t\t\tdasher_send_empty_segment(ctx, ds);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tis_queue_flush = GF_TRUE;\n\t\t\t}\n\t\t\tif (ds->sbound && pck && gf_filter_pck_is_blocking_ref(pck)) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_DASH, (\"[Dasher] Cannot use `sbound` with blocking input packet references, disabling packet buffering for PID %s\\n\", gf_filter_pid_get_name(ds->ipid) ));\n\t\t\t\tds->sbound = DASHER_BOUNDS_OUT;\n\t\t\t}\n\n\t\t\t//skipped merged tile base\n\t\t\tif (ds->merged_tile_dep) {\n\t\t\t\tif (pck) gf_filter_pid_drop_packet(ds->ipid);\n\t\t\t\tpck = NULL;\n\t\t\t}\n\t\t\t//queue mode\n\t\t\telse if (ds->sbound) {\n\t\t\t\tif (!is_queue_flush && pck) {\n\t\t\t\t\tgf_filter_pck_ref(&pck);\n\t\t\t\t\tgf_filter_pid_drop_packet(ds->ipid);\n\t\t\t\t\tgf_list_add(ds->packet_queue, pck);\n\t\t\t\t\tif (gf_filter_pck_get_sap(pck))\n\t\t\t\t\t\tds->nb_sap_in_queue ++;\n\t\t\t\t}\n\t\t\t\tif (\n\t\t\t\t\t//we are flushing due to period switch\n\t\t\t\t\tis_queue_flush\n\t\t\t\t\t//we are flushing due to end of stream\n\t\t\t\t\t|| gf_filter_pid_is_eos(ds->ipid) || ds->clamp_done\n\t\t\t\t) {\n\t\t\t\t\tpck = gf_list_get(ds->packet_queue, 0);\n\t\t\t\t\tis_queue_flush = GF_TRUE;\n\t\t\t\t} else if (\n\t\t\t\t\t//if current segment is not started, always get packet from queue\n\t\t\t\t\t!ds->segment_started\n\t\t\t\t\t//wait until we have more than 2 saps to get packet from queue, to check if next sap will be closer or not\n\t\t\t\t\t|| (ds->nb_sap_in_queue>=2)\n\t\t\t\t) {\n\t\t\t\t\tpck = gf_list_get(ds->packet_queue, 0);\n\t\t\t\t} else {\n\t\t\t\t\tpck = NULL;\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t\tif (!pck) {\n\t\t\t\tBool ds_is_done=GF_FALSE;\n\t\t\t\tif (ds->request_period_switch) {\n\t\t\t\t\te = dasher_stream_period_changed(filter, ctx, ds, (ds->request_period_switch==2) ? GF_TRUE : GF_FALSE);\n\t\t\t\t\tif (e < 0) {\n\t\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_DASH, (\"[Dasher] Period switch request failed.\\n\"));\n\t\t\t\t\t\ti--;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tassert(gf_list_find(ctx->current_period->streams, ds)<0);\n\t\t\t\t\tcount = gf_list_count(ctx->current_period->streams);\n\t\t\t\t\ti--;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (ds->clamp_done) ds_is_done=GF_TRUE;\n\t\t\t\telse if (gf_filter_pid_is_eos(ds->ipid)) {\n\t\t\t\t\tif (gf_filter_pid_is_flush_eos(ds->ipid)) {\n\t\t\t\t\t\tif (ds->segment_started && !ds->seg_done) {\n\t\t\t\t\t\t\tds->seg_done = GF_TRUE;\n\t\t\t\t\t\t\tds->first_cts_in_next_seg = ds->est_first_cts_in_next_seg;\n\t\t\t\t\t\t\tds->est_first_cts_in_next_seg = 0;\n\t\t\t\t\t\t\tassert(base_ds->nb_comp_done < base_ds->nb_comp);\n\t\t\t\t\t\t\tbase_ds->nb_comp_done ++;\n\t\t\t\t\t\t\tif (base_ds->nb_comp_done == base_ds->nb_comp) {\n\t\t\t\t\t\t\t\tdasher_flush_segment(ctx, base_ds, GF_FALSE);\n\t\t\t\t\t\t\t\tdasher_inject_eods(ctx, base_ds, GF_TRUE);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n \t\t\t\t\t} else {\n\t\t\t\t\t\tds_is_done=GF_TRUE;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (ds_is_done) {\n\t\t\t\t\tu32 ds_done = 1;\n\n\t\t\t\t\tif (!ds->clamp_done && !ds->muxed_base && (ds->stream_type==GF_STREAM_TEXT)) {\n\t\t\t\t\t\tu32 s_idx;\n\t\t\t\t\t\tu64 ddur_ms;\n\t\t\t\t\t\tBool over = GF_TRUE;\n\t\t\t\t\t\tfor (s_idx=0; s_idx<count; s_idx++) {\n\t\t\t\t\t\t\tGF_DashStream *a_ds = gf_list_get(ctx->current_period->streams, s_idx);\n\t\t\t\t\t\t\tif (a_ds == ds) continue;\n\t\t\t\t\t\t\tif (a_ds->stream_type==GF_STREAM_TEXT) continue;\n\t\t\t\t\t\t\tif (!a_ds->done) {\n\t\t\t\t\t\t\t\tover = GF_FALSE;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!over)\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t//text streams, insert empty segments if we are one segment behind (and including) last produced segment on other pids\n\t\t\t\t\t\tddur_ms = (1000*ds->dash_dur.num)/ds->dash_dur.den;\n\t\t\t\t\t\twhile (ds->last_min_segment_start_time + ddur_ms <= ctx->min_segment_start_time) {\n\t\t\t\t\t\t\tdasher_send_empty_segment(ctx, ds);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\n\t\t\t\t\tif (ctx->loop && dasher_check_loop(ctx, ds)) {\n\t\t\t\t\t\tif (ctx->subdur)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t//loop on the entire source, consider the stream not done for segment flush\n\t\t\t\t\t\tds_done = 0;\n\t\t\t\t\t}\n\n\t\t\t\t\tds->clamp_done = GF_FALSE;\n\n\t\t\t\t\tctx->update_report = -1;\n\t\t\t\t\t//opid may be NULL for skipped tile rep\n\t\t\t\t\tif (!ctx->sigfrag && ds->opid)\n\t\t\t\t\t\tgf_filter_pid_set_eos(ds->opid);\n\n\t\t\t\t\tif (!ds->done) ds->done = ds_done;\n\t\t\t\t\tds->seg_done = GF_TRUE;\n\t\t\t\t\tseg_done = GF_TRUE;\n\t\t\t\t\tds->first_cts_in_next_seg = ds->est_first_cts_in_next_seg;\n\t\t\t\t\tds->est_first_cts_in_next_seg = 0;\n\t\t\t\t\tassert(base_ds->nb_comp_done < base_ds->nb_comp);\n\t\t\t\t\tbase_ds->nb_comp_done ++;\n\t\t\t\t\tif (base_ds->nb_comp_done == base_ds->nb_comp) {\n\t\t\t\t\t\tdasher_flush_segment(ctx, base_ds, GF_FALSE);\n\t\t\t\t\t}\n\t\t\t\t\t//loop on the entire source, mark as done for subdur and check if all other streams are done\n\t\t\t\t\tif (!ds->done) {\n\t\t\t\t\t\tu32 j;\n\t\t\t\t\t\tds->done = 2;\n\t\t\t\t\t\tds->subdur_done = GF_TRUE;\n\t\t\t\t\t\tu32 nb_sub_done=0;\n\t\t\t\t\t\tfor (j=0; j<count; j++) {\n\t\t\t\t\t\t\tGF_DashStream *a_ds = gf_list_get(ctx->current_period->streams, j);\n\t\t\t\t\t\t\tif (a_ds->muxed_base) a_ds = a_ds->muxed_base;\n\t\t\t\t\t\t\tif (a_ds->subdur_done) {\n\t\t\t\t\t\t\t\tnb_sub_done++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (nb_sub_done==count)\n\t\t\t\t\t\t\tctx->subdur_done = GF_TRUE;\n\t\t\t\t\t} else if (ctx->reschedule && !ctx->loop && (ctx->dmode==GF_MPD_TYPE_DYNAMIC) && !strcmp(ds->period_id, DEFAULT_PERIOD_ID) ) {\n\t\t\t\t\t\tif (gf_list_find(ctx->next_period->streams, ds)<0) {\n\t\t\t\t\t\t\tgf_list_add(ctx->next_period->streams, ds);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tctx->post_play_events = GF_TRUE;\n\t\t\t\t\t\tds->nb_repeat++;\n\t\t\t\t\t\tds->reschedule = GF_TRUE;\n\t\t\t\t\t\tgf_filter_pid_discard_block(ds->opid);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//no packet, muxed rep and base DS done, flush - required if no packet is present for the segment\n\t\t\t\t//typically for subs\n\t\t\t\telse if (ds->muxed_base && base_ds->seg_done && !ds->seg_done && !ds->is_av) {\n\t\t\t\t\tds->seg_done = GF_TRUE;\n\t\t\t\t\tds->first_cts_in_next_seg = ds->est_first_cts_in_next_seg;\n\t\t\t\t\tds->est_first_cts_in_next_seg = 0;\n\t\t\t\t\tassert(base_ds->nb_comp_done < base_ds->nb_comp);\n\t\t\t\t\tbase_ds->nb_comp_done ++;\n\t\t\t\t\tif (base_ds->nb_comp_done == base_ds->nb_comp) {\n\t\t\t\t\t\tdasher_flush_segment(ctx, base_ds, GF_FALSE);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (ds->seek_to_pck) {\n\t\t\t\tu32 sn = gf_filter_pck_get_seq_num(pck);\n\t\t\t\tif (sn) {\n\t\t\t\t\tif (sn <= ds->seek_to_pck) {\n\t\t\t\t\t\tdasher_drop_input(ctx, ds, GF_FALSE);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tds->nb_pck = sn-1;\n\t\t\t\t} else {\n\t\t\t\t\t//no sn signaled, this implies we played from the beginning\n\t\t\t\t\tif (ds->nb_pck < ds->seek_to_pck) {\n\t\t\t\t\t\tds->nb_pck ++;\n\t\t\t\t\t\tdasher_drop_input(ctx, ds, GF_FALSE);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tsap_type = gf_filter_pck_get_sap(pck);\n\t\t\tds->loop_state = 0;\n\n\t\t\tcts = gf_filter_pck_get_cts(pck);\n\t\t\tdts = gf_filter_pck_get_dts(pck);\n\t\t\tif (dts==GF_FILTER_NO_TS) dts = cts;\n\n\t\t\tif (!sap_type && (ds->sync_points_type != DASHER_SYNC_PRESENT)) {\n\t\t\t\tds->sync_points_type = DASHER_SYNC_PRESENT;\n\t\t\t\t//cf setup_period: in sbound=0 mode, if stream has sync and non-sync and uses skip samples, allow spliting\n\t\t\t\t//slightly before - typically needed for audio with sync points (usac, mpegh) where the segment duration is set\n\t\t\t\t//to the intra interval, we need to take into account the skip samples\n\t\t\t\tif (!ctx->sbound && !ds->cues\n\t\t\t\t\t&& (ds->pts_minus_cts<0) && (ds->next_seg_start> (u32) -ds->pts_minus_cts)\n\t\t\t\t) {\n\t\t\t\t\tds->next_seg_start -= (u32) -ds->pts_minus_cts;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ((ctx->strict_sap==DASHER_SAP_INTRA_ONLY) && (sap_type>=4))\n\t\t\t\tsap_type = 0;\n\n\t\t\tpcont_cts = cts;\n\n\t\t\tif (!ds->rep_init) {\n\t\t\t\tu32 set_start_with_sap;\n\t\t\t\t//for video, resync on sap 1 or 2 if not full profile\n\t\t\t\tif ((ds->stream_type==GF_STREAM_VISUAL) && (ctx->profile != GF_DASH_PROFILE_FULL)) {\n\t\t\t\t\tif ((sap_type!=GF_FILTER_SAP_1) && (sap_type!=GF_FILTER_SAP_2))\n\t\t\t\t\t\tsap_type = 0;\n\t\t\t\t}\n\t\t\t\tif (!sap_type) {\n\t\t\t\t\t//remember our timing\n\t\t\t\t\tif (!ds->presentation_time_offset)\n\t\t\t\t\t\tds->presentation_time_offset = cts + 1;\n\n\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_DASH, (\"[Dasher] Representation not initialized, dropping non-SAP1/2 packet CTS \"LLU\"/%d\\n\", cts, ds->timescale));\n\t\t\t\t\tdasher_drop_input(ctx, ds, GF_FALSE);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tset_start_with_sap = ctx->sseg ? base_ds->set->subsegment_starts_with_sap : base_ds->set->starts_with_sap;\n\t\t\t\tif (!ds->muxed_base) {\n\t\t\t\t\tu64 check_ts;\n\t\t\t\t\t//force sap type to 1 for non-visual streams if strict_sap is set to off\n\t\t\t\t\tif ((ds->stream_type!=GF_STREAM_VISUAL) && (ctx->strict_sap==DASHER_SAP_OFF) ) {\n\t\t\t\t\t\tswitch (ds->codec_id) {\n\t\t\t\t\t\t//MPEG-H requires saps\n\t\t\t\t\t\tcase GF_CODECID_MPHA:\n\t\t\t\t\t\tcase GF_CODECID_MHAS:\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tsap_type = 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t//set AS sap type\n\t\t\t\t\tif (!set_start_with_sap) {\n\t\t\t\t\t\t//don't set SAP type if not a base rep - could be further checked\n\t\t\t\t\t\t//if (!gf_list_count(ds->complementary_streams) )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (ctx->sseg) {\n\t\t\t\t\t\t\t\tds->set->subsegment_starts_with_sap = sap_type;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tds->set->starts_with_sap = sap_type;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if (set_start_with_sap != sap_type) {\n\t\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_DASH, (\"[Dasher] Segments do not start with the same SAP types: set initialized with %d but first packet got %d - bitstream will not be compliant\\n\", set_start_with_sap, sap_type));\n\t\t\t\t\t}\n\n\t\t\t\t\tcheck_ts = cts;\n\t\t\t\t\t//in case we droped frames\n\t\t\t\t\tif (ds->presentation_time_offset)\n\t\t\t\t\t\tcheck_ts = ds->presentation_time_offset - 1;\n\t\t\t\t\tds->presentation_time_offset = 0;\n\t\t\t\t\t//The code below assumes that the first frame in the stream has a presentation time of 0\n\t\t\t\t\tif ((s64) check_ts + ds->pts_minus_cts > 0) {\n\t\t\t\t\t\tu64 pto = check_ts + ds->pts_minus_cts;\n\t\t\t\t\t\tu64 pto_adj = pto;\n\t\t\t\t\t\tif (ds->timescale != ds->mpd_timescale) {\n\t\t\t\t\t\t\tpto_adj = gf_timestamp_rescale(pto_adj, ds->timescale, ds->mpd_timescale);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (ctx->min_cts_period.den) {\n\t\t\t\t\t\t\tu64 diff = gf_timestamp_rescale(ctx->min_cts_period.num, ctx->min_cts_period.den, ds->mpd_timescale);\n\t\t\t\t\t\t\tpto_adj = diff;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (ds->rep->segment_list)\n\t\t\t\t\t\t\tds->rep->segment_list->presentation_time_offset = pto_adj;\n\t\t\t\t\t\telse if (ds->rep->segment_template)\n\t\t\t\t\t\t\tds->rep->segment_template->presentation_time_offset = pto_adj;\n\t\t\t\t\t\telse if (ds->set->segment_template)\n\t\t\t\t\t\t\tds->set->segment_template->presentation_time_offset = pto_adj;\n\t\t\t\t\t\telse if (ds->set->segment_list)\n\t\t\t\t\t\t\tds->set->segment_list->presentation_time_offset = pto_adj;\n\t\t\t\t\t\telse if (ds->rep->segment_base) {\n\t\t\t\t\t\t\tds->rep->segment_base->presentation_time_offset = pto_adj;\n\t\t\t\t\t\t\tds->rep->segment_base->timescale = ds->mpd_timescale;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tds->presentation_time_offset = pto;\n\t\t\t\t\t}\n\t\t\t\t\t//period continuity, skip priming in new periods\n\t\t\t\t\tif (ds->period_continuity_id)\n\t\t\t\t\t\tds->pts_minus_cts = 0;\n\t\t\t\t}\n\n\t\t\t\tds->first_cts = cts;\n\t\t\t\tds->first_dts = dts;\n\t\t\t\tif (ctx->do_index) {\n\t\t\t\t\tds->rep->segment_list->first_cts_offset = (s32) ((s64) ds->first_cts - (s64) ds->first_dts);\n\t\t\t\t}\n\t\t\t\tds->rep_init++;\n\t\t\t\thas_init++;\n\t\t\t}\n\n\t\t\tnb_init++;\n\n\t\t\tif (ds->ts_offset) {\n\t\t\t\tcts += ds->ts_offset;\n\t\t\t\tdts += ds->ts_offset;\n\t\t\t}\n\n\t\t\t//ready to write MPD for the first time in dynamic mode with template\n\t\t\tif (has_init && (nb_init==count) && (ctx->dmode==GF_MPD_TYPE_DYNAMIC) && ctx->tpl && ctx->do_mpd && !ctx->dyn_rate) {\n\t\t\t\te = dasher_send_manifest(filter, ctx, GF_TRUE);\n\t\t\t\tif (e) return e;\n\t\t\t}\n\n\t\t\tcts = dasher_translate_cts(ds, cts);\n\t\t\tdts -= ds->first_dts;\n\n\t\t\tif (ctx->sreg && ctx->mpd->gpac_mpd_time && gf_timestamp_greater(dts, ds->timescale, ctx->mpd->gpac_mpd_time, 1000)) {\n\t\t\t\tnb_reg_done++;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tdur = o_dur = gf_filter_pck_get_duration(pck);\n\t\t\tpcont_cts += dur;\n\t\t\tif (ds->period_continuity_next_cts < pcont_cts)\n\t\t\t\tds->period_continuity_next_cts = pcont_cts;\n\n\t\t\tsplit_dur = 0;\n\t\t\tsplit_dur_next = 0;\n\n\t\t\t//patch to align old arch with new\n\t\t\tcheck_dur = 0;\n\t\t\tif (ds->stream_type==GF_STREAM_AUDIO)\n\t\t\t\tcheck_dur = dur;\n\n\t\t\t//perform regulation of inputs to avoid dashing one stream faster than the others\n\t\t\t//this is needed when inputs are not realtime and we have text streams for which we must decide\n\t\t\t//if we insert empty segments\n\t\t\tif (!base_ds->segment_started && ctx->min_segment_start_time) {\n\t\t\t\torig_cts = cts;\n\t\t\t\tif (ds->split_dur_next)\n\t\t\t\t\tcts += ds->split_dur_next;\n\n\t\t\t\tif (gf_timestamp_greater(cts, ds->timescale, ctx->min_segment_start_time, 1000)) {\n\t\t\t\t\tnb_seg_waiting++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcts = orig_cts;\n\t\t\t}\n\t\t\tnb_seg_active++;\n\n\t\t\t//adjust duration and cts\n\t\t\torig_cts = cts;\n\t\t\tif (ds->split_dur_next) {\n\t\t\t\tcts += ds->split_dur_next;\n\t\t\t\tassert(dur > ds->split_dur_next);\n\t\t\t\tdur -= ds->split_dur_next;\n\t\t\t\tsplit_dur_next = ds->split_dur_next;\n\t\t\t\tds->split_dur_next = 0;\n\t\t\t\tis_packet_split = GF_TRUE;\n\t\t\t}\n\n\t\t\tif (ds->splitable && !ds->split_dur_next && !ds->cues && !ds->inband_cues) {\n\t\t\t\tBool do_split = GF_FALSE;\n\t\t\t\t//adding this sample would exceed the segment duration\n\t\t\t\tif (gf_sys_old_arch_compat()) {\n\t\t\t\t\tif (gf_timestamp_greater_or_equal(cts + dur, ds->timescale, base_ds->adjusted_next_seg_start, base_ds->timescale))\n\t\t\t\t\t\tdo_split = GF_TRUE;\n\t\t\t\t} else {\n\t\t\t\t\tif ( gf_timestamp_greater(cts + dur, ds->timescale, base_ds->adjusted_next_seg_start, base_ds->timescale))\n\t\t\t\t\t\tdo_split = GF_TRUE;\n\t\t\t\t}\n\t\t\t\tif (do_split) {\n\t\t\t\t\t//this sample starts in the current segment - split it\n\t\t\t\t\tif (gf_timestamp_less(cts, ds->timescale, base_ds->adjusted_next_seg_start, base_ds->timescale) ) {\n\t\t\t\t\t\tsplit_dur = (u32) (gf_timestamp_rescale(base_ds->adjusted_next_seg_start, base_ds->timescale, ds->timescale) - ds->last_cts);\n\n\t\t\t\t\t\tif (gf_sys_old_arch_compat() && (split_dur==dur))\n\t\t\t\t\t\t\tsplit_dur=0;\n\n\t\t\t\t\t\tif (split_dur>=dur)\n\t\t\t\t\t\t\tsplit_dur=0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//mux rep, wait for a CTS more than our base if base not yet over\n\t\t\tif ((base_ds != ds) && !base_ds->seg_done && gf_timestamp_greater(cts, ds->timescale, base_ds->last_cts, base_ds->timescale) )\n\t\t\t\tbreak;\n\n\t\t\tif (ds->seek_to_pck) {\n\t\t\t\tds->seek_to_pck = 0;\n\t\t\t}\n\t\t\t//base rep has been forced to another period, we switch asap\n\t\t\telse if (base_ds->forced_period_switch) {\n\t\t\t\tds->seg_done = GF_TRUE;\n\t\t\t\tdasher_inject_eods(ctx, ds, GF_FALSE);\n\t\t\t\tseg_done = GF_TRUE;\n\t\t\t\tdasher_stream_period_changed(filter, ctx, ds, GF_FALSE);\n\t\t\t\ti--;\n\t\t\t\tcount--;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t//force flush mode, segment is done upon eos\n\t\t\telse if (ctx->force_flush) {\n\t\t\t}\n\t\t\t//source-driven fragmentation check for segment start\n\t\t\telse if (ctx->sigfrag) {\n\t\t\t\tconst GF_PropertyValue *p = gf_filter_pck_get_property(pck, GF_PROP_PCK_FRAG_START);\n\t\t\t\tif (p && (p->value.uint>=1) && base_ds->segment_started) {\n\t\t\t\t\tseg_over = GF_TRUE;\n\t\t\t\t\tif (ds == base_ds) {\n\t\t\t\t\t\tbase_ds->adjusted_next_seg_start = cts;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t//inband-cue based segmentation\n\t\t\telse if (ds->inband_cues) {\n\t\t\t\tconst GF_PropertyValue *p = gf_filter_pck_get_property(pck, GF_PROP_PCK_CUE_START);\n\t\t\t\tif (p && p->value.boolean) {\n\t\t\t\t\tu32 size;\n\t\t\t\t\tgf_filter_pck_get_data(pck, &size);\n\t\t\t\t\tif (base_ds->segment_started) {\n\t\t\t\t\t\tseg_over = GF_TRUE;\n\t\t\t\t\t\tif (ds == base_ds) {\n\t\t\t\t\t\t\tbase_ds->adjusted_next_seg_start = cts;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t//packet with no size, used by GHI demuxer:\n\t\t\t\t\t//- if seek flag is set, this is a dummy packet sent to generate segment timeline / child HLS\n\t\t\t\t\t//- if seek flag is not set, this is an empty segment for sparse streams\n\t\t\t\t\telse if (!size) {\n\t\t\t\t\t\tif (!gf_filter_pck_get_seek_flag(pck) ) {\n\t\t\t\t\t\t\tds->first_cts_in_seg = gf_filter_pck_get_cts(pck);\n\t\t\t\t\t\t\tdasher_send_empty_segment(ctx, ds);\n\t\t\t\t\t\t\tdasher_drop_input(ctx, ds, GF_TRUE);\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tp = gf_filter_pck_get_property(pck, GF_PROP_PCK_SPLIT_START);\n\t\t\t\t\tif (p) {\n\t\t\t\t\t\tcts += p->value.uint;\n\t\t\t\t\t\tassert(dur > p->value.uint);\n\t\t\t\t\t\tdur -= p->value.uint;\n\t\t\t\t\t\tsplit_dur_next = p->value.uint;\n\t\t\t\t\t\tds->split_dur_next = 0;\n\t\t\t\t\t\tis_packet_split = GF_TRUE;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tp = gf_filter_pck_get_property(pck, GF_PROP_PCK_SPLIT_END);\n\t\t\t\tif (p) {\n\t\t\t\t\tassert(dur > p->value.uint);\n\t\t\t\t\tdur -= p->value.uint;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//cue-list based segmentation\n\t\t\telse if (ds->cues) {\n\t\t\t\tu32 cidx;\n\t\t\t\tGF_DASHCueInfo *cue=NULL;\n\t\t\t\tBool is_cue_split = GF_FALSE;\n\t\t\t\ts32 has_mismatch = -1;\n\n\t\t\t\tfor (cidx=0;cidx<ds->nb_cues; cidx++) {\n\t\t\t\t\tcue = &ds->cues[cidx];\n\t\t\t\t\tif (cue->sample_num) {\n\t\t\t\t\t\tif (cue->sample_num == ds->nb_pck + 1) {\n\t\t\t\t\t\t\tis_cue_split = GF_TRUE;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t} else if (cue->sample_num < ds->nb_pck) {\n\t\t\t\t\t\t\thas_mismatch = cidx;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if (cue->dts) {\n\t\t\t\t\t\tu64 ts = (cue->dts - ds->cues_ts_offset) * ds->timescale;\n\t\t\t\t\t\tu64 ts2 = dts * ds->cues_timescale;\n\t\t\t\t\t\tif (ts == ts2) {\n\t\t\t\t\t\t\tis_cue_split = GF_TRUE;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t} else if (ts < ts2) {\n\t\t\t\t\t\t\thas_mismatch = cidx;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if (cue->cts) {\n\t\t\t\t\t\ts64 ts = (cue->cts - ds->cues_ts_offset) * ds->timescale;\n\t\t\t\t\t\ts64 ts2 = (cts + ds->first_cts) * ds->cues_timescale;\n\n\t\t\t\t\t\t//cues are given in track timeline (presentation time), subtract the media time to pres time offset\n\t\t\t\t\t\tif (ds->cues_use_edits) {\n\t\t\t\t\t\t\tts2 += (s64) (ds->pts_minus_cts) * ds->cues_timescale;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (ts == ts2) {\n\t\t\t\t\t\t\tis_cue_split = GF_TRUE;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t} else if (ts < ts2) {\n\t\t\t\t\t\t\thas_mismatch = cidx;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//start of first segment\n\t\t\t\tif (is_cue_split && !ds->segment_started) {\n\t\t\t\t\tmemmove(ds->cues, &ds->cues[cidx+1], (ds->nb_cues-cidx-1) * sizeof(GF_DASHCueInfo));\n\t\t\t\t\tds->nb_cues -= cidx+1;\n\t\t\t\t\tis_cue_split = 0;\n\t\t\t\t}\n\n\t\t\t\tif (is_cue_split) {\n\t\t\t\t\tif (!sap_type) {\n\t\t\t\t\t\tGF_LOG(ctx->strict_cues ?  GF_LOG_ERROR : GF_LOG_WARNING, GF_LOG_DASH, (\"[DASH] cue found (sn %d - dts \"LLD\" - cts \"LLD\") for PID %s but packet %d is not RAP !\\n\", cue->sample_num, cue->dts, cue->cts, gf_filter_pid_get_name(ds->ipid), ds->nb_pck));\n\t\t\t\t\t\tif (ctx->strict_cues) {\n\t\t\t\t\t\t\tgf_filter_pid_drop_packet(ds->ipid);\n\t\t\t\t\t\t\tgf_filter_pid_set_discard(ds->ipid, GF_TRUE);\n\t\t\t\t\t\t\treturn GF_BAD_PARAM;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tmemmove(ds->cues, &ds->cues[cidx+1], (ds->nb_cues-cidx-1) * sizeof(GF_DASHCueInfo));\n\t\t\t\t\tds->nb_cues -= cidx+1;\n\n\t\t\t\t\tif (sap_type==3)\n\t\t\t\t\t\tds->nb_sap_3 ++;\n\t\t\t\t\telse if (sap_type>3)\n\t\t\t\t\t\tds->nb_sap_4 ++;\n\n\t\t\t\t\t/*check requested profiles can be generated, or adjust them*/\n\t\t\t\t\tif (\n\t\t\t\t\t\t(ds->nb_sap_4 || (ds->nb_sap_3 > 1))\n\t\t\t\t\t\t&& (ctx->profile != GF_DASH_PROFILE_FULL)\n\t\t\t\t\t\t/*TODO: store at DS level whether the usage of sap4 is ok or not (eg roll info for AAC is OK, not for xHEAAC-v2)\n\t\t\t\t\t\tfor now we only complain for video*/\n\t\t\t\t\t\t&& ((ds->stream_type==GF_STREAM_VISUAL) || (ctx->strict_sap==DASHER_SAP_ON) )\n\t\t\t\t\t) {\n\t\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_DASH, (\"[Dasher] WARNING! Max SAP type %d detected - switching to FULL profile\\n\", ds->nb_sap_4 ? 4 : 3));\n\t\t\t\t\t\tctx->profile = GF_DASH_PROFILE_FULL;\n\t\t\t\t\t\tif (ctx->sseg)\n\t\t\t\t\t\t\tds->set->subsegment_starts_with_sap = sap_type;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tds->set->starts_with_sap = sap_type;\n\t\t\t\t\t}\n\n\n\t\t\t\t\tseg_over = GF_TRUE;\n\t\t\t\t\tif (ds == base_ds) {\n\t\t\t\t\t\tbase_ds->adjusted_next_seg_start = cts;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (has_mismatch>=0) {\n\t\t\t\t\tcue = &ds->cues[has_mismatch];\n\t\t\t\t\tGF_LOG(ctx->strict_cues ?  GF_LOG_ERROR : GF_LOG_WARNING, GF_LOG_DASH, (\"[DASH] found cue (sn %d - dts \"LLD\" - cts \"LLD\") in stream %s before current packet (sn %d - dts \"LLD\" - cts \"LLD\") , buggy source cues ?\\n\", cue->sample_num, cue->dts, cue->cts, gf_filter_pid_get_name(ds->ipid), ds->nb_pck+1, dts + ds->first_cts, cts + ds->first_cts));\n\t\t\t\t\tif (ctx->strict_cues) {\n\t\t\t\t\t\tgf_filter_pid_drop_packet(ds->ipid);\n\t\t\t\t\t\tgf_filter_pid_set_discard(ds->ipid, GF_TRUE);\n\t\t\t\t\t\treturn GF_BAD_PARAM;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t//forcing max time\n\t\t\telse if (\n\t\t\t\t(base_ds->force_rep_end && gf_timestamp_greater_or_equal(cts, ds->timescale, base_ds->force_rep_end, base_ds->timescale) )\n\t\t\t\t|| (base_ds->clamped_dur.num && (cts + o_dur > ds->ts_offset + base_ds->clamped_dur.num * ds->timescale / base_ds->clamped_dur.den))\n\t\t\t) {\n\t\t\t\tif (!base_ds->period->period->duration && base_ds->force_rep_end) {\n\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_DASH, (\"[Dasher] Inputs duration do not match, %s truncated to %g duration\\n\", ds->src_url, ((Double)base_ds->force_rep_end)/base_ds->timescale ));\n\t\t\t\t}\n\t\t\t\tdasher_drop_input(ctx, ds, GF_TRUE);\n\t\t\t\tds->clamp_done = GF_TRUE;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t//we have a SAP and we work in closest mode: check the next SAP in the queue, and decide if we\n\t\t\t//split the segment at this SAP or wait for the next one\n\t\t\telse if (ds->segment_started && ds->sbound && sap_type) {\n\t\t\t\tu32 idx, nb_queued, nb_pck = gf_list_count(ds->packet_queue);\n\t\t\t\tnb_queued = nb_pck;\n\t\t\t\tif (is_queue_flush) nb_queued += 1;\n\t\t\t\t\n\t\t\t\tfor (idx=1; idx<nb_queued; idx++) {\n\t\t\t\t\tGF_FilterPacket *next;\n\t\t\t\t\tif (idx==nb_pck) {\n\t\t\t\t\t\tnext = gf_list_last(ds->packet_queue);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnext = gf_list_get(ds->packet_queue, idx);\n\t\t\t\t\t\tu32 sap_next = gf_filter_pck_get_sap(next);\n\t\t\t\t\t\tif (!sap_next) continue;\n\t\t\t\t\t}\n\t\t\t\t\tu32 next_dur = gf_filter_pck_get_duration(next);\n\t\t\t\t\t//compute cts next\n\t\t\t\t\tu64 cts_next = gf_filter_pck_get_cts(next);\n\t\t\t\t\tif (ds->ts_offset) {\n\t\t\t\t\t\tcts_next += ds->ts_offset;\n\t\t\t\t\t}\n\t\t\t\t\tcts_next = dasher_translate_cts(ds, cts_next);\n\n\t\t\t\t\tif ((idx==nb_pck) && ctx->last_seg_merge) {\n\t\t\t\t\t\tu64 next_seg_dur = (cts_next + next_dur - cts);\n\t\t\t\t\t\tif (next_seg_dur * ds->dash_dur.den < (u64) ds->dash_dur.num * ds->timescale / 2)\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\t//same rule as above\n\t\t\t\t\tif (gf_timestamp_greater_or_equal(cts_next + next_dur, ds->timescale, base_ds->adjusted_next_seg_start, base_ds->timescale)) {\n\t\t\t\t\t\tBool force_seg_flush = GF_FALSE;\n\t\t\t\t\t\ts64 diff_next = gf_timestamp_rescale(cts_next, ds->timescale, base_ds->timescale);\n\t\t\t\t\t\tdiff_next -= base_ds->adjusted_next_seg_start;\n\t\t\t\t\t\t//bounds at closest: if this SAP is closer to the target next segment start than the next SAP, split at this packet\n\t\t\t\t\t\tif (ds->sbound==DASHER_BOUNDS_CLOSEST) {\n\t\t\t\t\t\t\ts64 diff = gf_timestamp_rescale(cts, ds->timescale, base_ds->timescale);\n\t\t\t\t\t\t\tdiff -= base_ds->adjusted_next_seg_start;\n\t\t\t\t\t\t\t//this one may be negative, but we always want diff_next positive (next SAP in next segment)\n\t\t\t\t\t\t\tif (diff<0)\n\t\t\t\t\t\t\t\tdiff = -diff;\n\t\t\t\t\t\t\t//old arch was only using closest for tracks with sync points\n\t\t\t\t\t\t\tif (gf_sys_old_arch_compat() && (base_ds->sync_points_type==DASHER_SYNC_NONE) ) {\n\t\t\t\t\t\t\t\tif (diff_next > 0) {\n\t\t\t\t\t\t\t\t\tforce_seg_flush = GF_TRUE;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (diff<diff_next) {\n\t\t\t\t\t\t\t\tforce_seg_flush = GF_TRUE;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//bounds always in: if the next SAP is strictly greater than the target next segment start, split at this packet\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tif (diff_next > 0) {\n\t\t\t\t\t\t\t\tforce_seg_flush = GF_TRUE;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (force_seg_flush) {\n\t\t\t\t\t\t\tseg_over = GF_TRUE;\n\t\t\t\t\t\t\tif (ds == base_ds) {\n\t\t\t\t\t\t\t\tbase_ds->adjusted_next_seg_start = cts;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t//we exceed segment duration - if segment was started, check if we need to stop segment\n\t\t\t//if segment was not started we insert the packet anyway\n\t\t\telse if (!ds->sbound && ds->segment_started && gf_timestamp_greater_or_equal(cts + check_dur, ds->timescale, base_ds->adjusted_next_seg_start, base_ds->timescale) ) {\n\n\n\t\t\t\t//we have a base (muxed rep) and it is not yet done, and we exceed estimated next seg start on base\n\t\t\t\t//wait for the base to be done as the next seg estimate may change if next segment duration is quite\n\t\t\t\t//different from requested duration - cf #2488\n\t\t\t\tif ((ds != base_ds) && !base_ds->seg_done) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t//no sap, segment is over\n\t\t\t\tif (! ctx->sap) {\n\t\t\t\t\tseg_over = GF_TRUE;\n\t\t\t\t}\n\t\t\t\telse if ((ds->stream_type==GF_STREAM_AUDIO)\n\t\t\t\t\t&& gf_timestamp_equal(cts + check_dur, ds->timescale, base_ds->adjusted_next_seg_start, base_ds->timescale)\n\t\t\t\t) {\n\n\t\t\t\t}\n\t\t\t\t// sap, segment is over\n\t\t\t\telse if (sap_type) {\n\n\t\t\t\t\tif (sap_type==3)\n\t\t\t\t\t\tds->nb_sap_3 ++;\n\t\t\t\t\telse if (sap_type>3)\n\t\t\t\t\t\tds->nb_sap_4 ++;\n\n\t\t\t\t\t/*check requested profiles can be generated, or adjust them*/\n\t\t\t\t\tif ((ctx->profile != GF_DASH_PROFILE_FULL)\n\t\t\t\t\t\t&& (ds->nb_sap_4 || (ds->nb_sap_3 > 1))\n\t\t\t\t\t\t/*TODO: store at DS level whether the usage of sap4 is ok or not (eg roll info for AAC is OK, not for xHEAAC-v2)\n\t\t\t\t\t\tfor now we only complain for video*/\n\t\t\t\t\t\t&& ((ds->stream_type==GF_STREAM_VISUAL) || (ctx->strict_sap==DASHER_SAP_ON) )\n\t\t\t\t\t) {\n\t\t\t\t\t\tif ((sap_type == GF_FILTER_SAP_3)\n\t\t\t\t\t\t\t&& (ds->codec_id==GF_CODECID_VVC)\n\t\t\t\t\t\t\t&& (ds->inband_params==2)\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tif (ds->set->starts_with_sap<3) {\n\t\t\t\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_DASH, (\"[Dasher] Using VVC with SAP type 3 and inband PPS, profile not yet defined\\n\", ds->nb_sap_4 ? 4 : 3));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_DASH, (\"[Dasher] WARNING! Max SAP type %d detected - switching to FULL profile\\n\", ds->nb_sap_4 ? 4 : 3));\n\t\t\t\t\t\t\tctx->profile = GF_DASH_PROFILE_FULL;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (ctx->sseg)\n\t\t\t\t\t\t\tds->set->subsegment_starts_with_sap = sap_type;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tds->set->starts_with_sap = sap_type;\n\t\t\t\t\t}\n\n\t\t\t\t\t//if sap2, silently move startWithSAP to 2 if previsouly 0,1 or 2\n\t\t\t\t\tif (sap_type == GF_FILTER_SAP_2) {\n\t\t\t\t\t\tif (ctx->sseg)\n\t\t\t\t\t\t\tds->set->subsegment_starts_with_sap = MAX(ds->set->subsegment_starts_with_sap, sap_type);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tds->set->starts_with_sap = MAX(ds->set->starts_with_sap, sap_type);\n\t\t\t\t\t}\n\n\t\t\t\t\tseg_over = GF_TRUE;\n\t\t\t\t\tif (ds == base_ds) {\n\t\t\t\t\t\tbase_ds->adjusted_next_seg_start = cts;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t\tif (ds->muxed_base && ds->muxed_base->done) {\n\t\t\t\tseg_over = GF_FALSE;\n\t\t\t}\n\t\t\t//if flushing now will result in a one sample fragment afterwards\n\t\t\t//because this is the before-last sample, don't flush unless:\n\t\t\t//- we have an asto set (low latency)\n\t\t\t//- this is not an audio stream or all samples are SAPs\n\t\t\t//- we use cues\n\t\t\t//- we use strict_sap=intra mode\n\t\t\telse if (seg_over && ds->nb_samples_in_source && !ctx->loop\n\t\t\t\t&& (ds->nb_pck+1 == ds->nb_samples_in_source)\n\t\t\t\t&& !ds->inband_cues && !ds->cues\n\t\t\t\t&& !ctx->asto\n\t\t\t\t&& ! ((ds->sync_points_type==DASHER_SYNC_NONE) && (ds->stream_type!=GF_STREAM_AUDIO))\n\t\t\t\t&& (ctx->strict_sap!=DASHER_SAP_INTRA_ONLY)\n\t\t\t) {\n\t\t\t\tseg_over = GF_FALSE;\n\t\t\t}\n\t\t\t//if dur=0 (some text streams), don't flush segment\n\t\t\tif (seg_over && dur) {\n\t\t\t\tassert(!ds->seg_done);\n\n\t\t\t\tif (ds->request_period_switch && !gf_list_count(ds->packet_queue)) {\n\t\t\t\t\te = dasher_stream_period_changed(filter, ctx, ds, (ds->request_period_switch==2) ? GF_TRUE : GF_FALSE);\n\t\t\t\t\tif (e < 0) {\n\t\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_DASH, (\"[Dasher] Period switch request failed.\\n\"));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tassert(gf_list_find(ctx->current_period->streams, ds)<0);\n\t\t\t\t\tcount = gf_list_count(ctx->current_period->streams);\n\t\t\t\t\ti--;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tds->seg_done = GF_TRUE;\n\t\t\t\tif (split_dur_next && ctx->do_index) {\n\t\t\t\t\tGF_MPD_SegmentURL *s = gf_list_last(ds->rep->segment_list->segment_URLs);\n\t\t\t\t\ts->split_last_dur = dur;\n\t\t\t\t\tassert(gf_filter_pck_get_duration(pck) > dur);\n\t\t\t\t\tds->rep->segment_list->use_split_dur = GF_TRUE;\n\t\t\t\t}\n\n\t\t\t\tdasher_inject_eods(ctx, ds, GF_FALSE);\n\n\t\t\t\tds->first_cts_in_next_seg = cts;\n\t\t\t\tassert(base_ds->nb_comp_done < base_ds->nb_comp);\n\t\t\t\tbase_ds->nb_comp_done ++;\n\n\t\t\t\tif (split_dur_next)\n\t\t\t\t\tds->split_dur_next = (u32) split_dur_next;\n\n\t\t\t\tif (base_ds->nb_comp_done == base_ds->nb_comp) {\n\t\t\t\t\tdasher_flush_segment(ctx, base_ds, GF_FALSE);\n\t\t\t\t\tseg_done = GF_TRUE;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (cts==GF_FILTER_NO_TS) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_DASH, (\"[Dasher] WARNING! Source packet has no timestamp !\\n\"));\n\n\t\t\t\tcts = ds->last_cts;\n\t\t\t\tdts = ds->last_dts;\n\t\t\t} else {\n\t\t\t\tu64 ncts = cts + (split_dur ? split_dur : dur);\n\t\t\t\tif (ncts>ds->est_first_cts_in_next_seg)\n\t\t\t\t\tds->est_first_cts_in_next_seg = ncts;\n\n\t\t\t\tncts = gf_timestamp_rescale(ncts, ds->timescale, 1000);\n\t\t\t\tif (ncts>base_ds->max_period_dur)\n\t\t\t\t\tbase_ds->max_period_dur = ncts;\n\n\t\t\t\tds->last_cts = cts + (split_dur ? split_dur : dur);\n\t\t\t\tds->last_dts = dts;\n\t\t\t\tds->est_next_dts = dts + o_dur;\n\t\t\t}\n\n\t\t\tif (!is_packet_split)\n\t\t\t\tds->nb_pck ++;\n\n\t\t\tif (!ds->min_cts_in_seg_plus_one)\n\t\t\t\tds->min_cts_in_seg_plus_one = cts+1;\n\t\t\telse if (ds->min_cts_in_seg_plus_one - 1 > cts)\n\t\t\t\tds->min_cts_in_seg_plus_one = cts+1;\n\n\n\t\t\tif (ctx->sigfrag) {\n\t\t\t\tif (!ds->segment_started) {\n\t\t\t\t\tds->first_cts_in_seg = cts;\n\t\t\t\t\tdasher_mark_segment_start(ctx, ds, NULL, pck);\n\t\t\t\t\tds->segment_started = GF_TRUE;\n\t\t\t\t}\n\n\t\t\t\tds->cumulated_dur += dur;\n\n\t\t\t\t//drop packet if not splitting\n\t\t\t\tif (!ds->split_dur_next)\n\t\t\t\t\tgf_filter_pid_drop_packet(ds->ipid);\n\n\t\t\t\tif (ctx->in_error) {\n\t\t\t\t\tgf_filter_pid_set_discard(ds->ipid, GF_TRUE);\n\t\t\t\t\tgf_filter_pid_set_eos(ctx->opid);\n\t\t\t\t\treturn GF_BAD_PARAM;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (ctx->do_index) {\n\t\t\t\t//frag range may be set for TS and other sources\n\t\t\t\tconst GF_PropertyValue *p = gf_filter_pck_get_property(pck, GF_PROP_PCK_FRAG_RANGE);\n\t\t\t\tif (p) {\n\t\t\t\t\tds->frag_start_offset = p->value.lfrac.num;\n\t\t\t\t\t//frag start only for fmp4\n\t\t\t\t\tp = gf_filter_pck_get_property(pck, GF_PROP_PCK_FRAG_START);\n\t\t\t\t\tif (p && p->value.boolean) {\n\t\t\t\t\t\tp = gf_filter_pck_get_property(pck, GF_PROP_PCK_FRAG_TFDT);\n\t\t\t\t\t\tif (p)\n\t\t\t\t\t\t\tds->frag_first_ftdt = p->value.longuint;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t//create new ref to input\n\t\t\tdst = NULL;\n\t\t\tif (!ctx->do_index && !ctx->index_media_duration) {\n\t\t\t\tdst = gf_filter_pck_new_ref(ds->opid, 0, 0, pck);\n\t\t\t\tif (!dst) return GF_OUT_OF_MEM;\n\n\t\t\t\t//merge all props\n\t\t\t\tgf_filter_pck_merge_properties(pck, dst);\n\t\t\t\t//we have ts offset, use computed cts and dts\n\t\t\t\tif (ds->ts_offset) {\n\t\t\t\t\tgf_filter_pck_set_cts(dst, gf_filter_pck_get_cts(pck) + ds->ts_offset);\n\t\t\t\t\tgf_filter_pck_set_dts(dst, gf_filter_pck_get_dts(pck) + ds->ts_offset);\n\t\t\t\t}\n\n\t\t\t\tif (gf_sys_old_arch_compat() && ds->clamped_dur.num && ctx->loop\n\t\t\t\t\t&& (cts + 2*o_dur >= ds->ts_offset + base_ds->clamped_dur.num * ds->timescale / base_ds->clamped_dur.den)\n\t\t\t\t) {\n\t\t\t\t\tu32 _dur = dur;\n\t\t\t\t\t/* simple round with (int)+.5 to avoid trucating .99999 to 0 */\n\t\t\t\t\tdur = (u32) (ds->clamped_dur.num * ds->timescale / ds->clamped_dur.den - (dts - ds->ts_offset) + 0.5);\n\t\t\t\t\t//it may happen that the sample duration is 0 if the clamp duration is right after the sample DTS and timescale is not big enough to express it - force to 1\n\t\t\t\t\tif (dur==0)\n\t\t\t\t\t\tdur=1;\n\n\t\t\t\t\tgf_filter_pck_set_duration(dst, dur);\n\t\t\t\t\tds->est_next_dts += (s32) dur - (s32) _dur;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!ds->segment_started) {\n\t\t\t\tds->first_cts_in_seg = cts;\n\t\t\t\tif (split_dur_next && (ctx->from_index==IDXMODE_SEG)) {\n\t\t\t\t\tds->first_cts_in_seg -= split_dur_next;\n\t\t\t\t}\n\t\t\t\tdasher_mark_segment_start(ctx, ds, dst, pck);\n\t\t\t\tds->segment_started = GF_TRUE;\n\t\t\t\tif (split_dur_next && ctx->do_index) {\n\t\t\t\t\tGF_MPD_SegmentURL *s = gf_list_last(ds->rep->segment_list->segment_URLs);\n\t\t\t\t\ts->split_first_dur = (u32) split_dur_next;\n\t\t\t\t\tassert(gf_filter_pck_get_duration(pck) > split_dur_next);\n\t\t\t\t\tds->rep->segment_list->use_split_dur = GF_TRUE;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//prev packet was split\n\t\t\tif (is_packet_split) {\n\t\t\t\tu64 diff=0;\n\t\t\t\tu8 dep_flags = gf_filter_pck_get_dependency_flags(pck);\n\t\t\t\tu64 ts = gf_filter_pck_get_cts(pck);\n\t\t\t\tif (ts != GF_FILTER_NO_TS) {\n\t\t\t\t\tcts += ds->first_cts;\n\t\t\t\t\tassert(cts >= ts);\n\t\t\t\t\tdiff = cts - ts;\n\t\t\t\t} else {\n\t\t\t\t\tcts = ds->last_cts;\n\t\t\t\t}\n\t\t\t\tif (dst) {\n\t\t\t\t\tgf_filter_pck_set_cts(dst, cts + ds->ts_offset);\n\n\t\t\t\t\tts = gf_filter_pck_get_dts(pck);\n\t\t\t\t\tif (ts != GF_FILTER_NO_TS)\n\t\t\t\t\t\tgf_filter_pck_set_dts(dst, ts + diff + ds->ts_offset);\n\n\t\t\t\t\t//add sample is redundant flag\n\t\t\t\t\tdep_flags |= 0x1;\n\t\t\t\t\tgf_filter_pck_set_dependency_flags(dst, dep_flags);\n\t\t\t\t\t//this one might be incorrect of this split packet is also split, but we update the duration right below\n\t\t\t\t\tgf_filter_pck_set_duration(dst, dur);\n\t\t\t\t}\n\n\t\t\t\t//undo cts shift, we use it just below to compute cumulated dur using orig_cts (stored before shift)\n\t\t\t\tif (diff)\n\t\t\t\t\tcts -= ds->first_cts;\n\t\t\t}\n\n\t\t\t//if split, adjust duration - this may happen on a split packet, if it covered 3 or more segments\n\t\t\tif (split_dur) {\n\t\t\t\tu32 cumulated_split_dur = split_dur;\n\t\t\t\tif (dst)\n\t\t\t\t\tgf_filter_pck_set_duration(dst, split_dur);\n\t\t\t\t//adjust dur\n\t\t\t\tcumulated_split_dur += (u32) (cts - orig_cts);\n\t\t\t\tassert( dur > split_dur);\n\t\t\t\tassert( cumulated_split_dur <= gf_filter_pck_get_duration(pck) );\n\t\t\t\tds->split_dur_next = cumulated_split_dur;\n\t\t\t\tdur = split_dur;\n\t\t\t}\n\n\t\t\t//remove NTP\n\t\t\tif (dst && (ctx->ntp != DASHER_NTP_KEEP))\n\t\t\t\tgf_filter_pck_set_property(dst, GF_PROP_PCK_SENDER_NTP, NULL);\n\n\t\t\t//change packet times\n\t\t\tif (ds->force_timescale && dst) {\n\t\t\t\tu64 ats;\n\t\t\t\tats = gf_filter_pck_get_dts(dst);\n\t\t\t\tif (ats!=GF_FILTER_NO_TS) {\n\t\t\t\t\tats = gf_timestamp_rescale(ats, ds->timescale, ds->force_timescale);\n\t\t\t\t\tgf_filter_pck_set_dts(dst, ats);\n\t\t\t\t}\n\t\t\t\tats = gf_filter_pck_get_cts(dst);\n\t\t\t\tif (ats!=GF_FILTER_NO_TS) {\n\t\t\t\t\tats = gf_timestamp_rescale(ats, ds->timescale, ds->force_timescale);\n\t\t\t\t\tgf_filter_pck_set_cts(dst, ats);\n\t\t\t\t}\n\t\t\t\tats = (u64) gf_filter_pck_get_duration(dst);\n\t\t\t\tif (ats) {\n\t\t\t\t\tats = gf_timestamp_rescale(ats, ds->timescale, ds->force_timescale);\n\t\t\t\t\tgf_filter_pck_set_duration(dst, (u32) ats);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tds->cumulated_dur += dur;\n\n\t\t\tif (ds->current_seg_state && gf_filter_pck_get_crypt_flags(pck))\n\t\t\t\tds->current_seg_state->encrypted = GF_TRUE;\n\t\t\t//TODO check drift between MPD start time and min CTS in segment (not just first CTS in segment)\n\n\t\t\tif (ctx->gxns && dst && !ds->rep->first_tfdt_plus_one && !ds->muxed_base) {\n\t\t\t\tds->rep->first_tfdt_plus_one = 1 + gf_filter_pck_get_dts(dst);\n\t\t\t\tds->rep->first_tfdt_timescale = ds->timescale;\n\t\t\t}\n\t\t\t//send packet\n\t\t\tif (dst)\n\t\t\t\tgf_filter_pck_send(dst);\n\n\t\t\tif (ctx->update_report>=0)\n\t\t\t\tctx->update_report++;\n\n\t\t\tif (ds->dyn_bitrate) {\n\t\t\t\tu32 dsize;\n\t\t\t\tu64 rdts = gf_filter_pck_get_dts(pck);\n\t\t\t\tgf_filter_pck_get_data(pck, &dsize);\n\t\t\t\tif (!ds->rate_first_dts_plus_one)\n\t\t\t\t\tds->rate_first_dts_plus_one = 1 + rdts;\n\t\t\t\tds->rate_last_dts = rdts;\n\t\t\t\tds->rate_media_size += dsize;\n\t\t\t}\n\n\t\t\t//drop packet if not splitting\n\t\t\tif (!ds->split_dur_next)\n\t\t\t\tdasher_drop_input(ctx, ds, GF_FALSE);\n\n\t\t}\n\t}\n\n\tif (nb_seg_waiting && !nb_seg_active) {\n\t\tctx->last_min_segment_start_time = ctx->min_segment_start_time;\n\t\tctx->min_segment_start_time = 0;\n\t\treturn GF_OK;\n\t}\n\n\tnb_init = 0;\n\tfor (i=0; i<count; i++) {\n\t\tGF_DashStream *ds = gf_list_get(ctx->current_period->streams, i);\n\t\t//if (ds->muxed_base) ds = ds->muxed_base;\n\t\tif (ds->done || ds->subdur_done) nb_init++;\n\t\telse if (ds->seg_done && ctx->force_period_switch) nb_init++;\n\t\telse if (ds->seg_done && ds->muxed_base && ds->muxed_base->done) {\n\t\t\tnb_init++;\n\t\t\tif (!ds->done && ds->opid) gf_filter_pid_set_eos(ds->opid);\n\t\t\tds->done = 1;\n\t\t}\n\t}\n\n\tif (nb_reg_done && (nb_reg_done == count)) {\n\t\tctx->mpd->gpac_mpd_time = 0;\n\t}\n\n\tdasher_format_report(filter, ctx);\n\n\tif (seg_done) {\n\t\tBool update_period = GF_FALSE;\n\t\tBool update_manifest = GF_FALSE;\n\t\tif (ctx->purge_segments) update_period = GF_TRUE;\n\t\tif (ctx->mpd) {\n\t\t\t//segment timeline used, always update manifest\n\t\t\tif (ctx->stl)\n\t\t\t\tupdate_manifest = GF_TRUE;\n\t\t\telse if (ctx->dmode==GF_DASH_DYNAMIC) {\n\t\t\t\t//publish time not set, we never send the manifest, do it\n\t\t\t\tif (!ctx->mpd->publishTime) {\n\t\t\t\t\tupdate_manifest = GF_TRUE;\n\t\t\t\t}\n\t\t\t\t//whenever we have a new seg in HLS, push new manifest\n\t\t\t\telse if (ctx->do_m3u8) {\n\t\t\t\t\tupdate_manifest = GF_TRUE;\n\t\t\t\t}\n\t\t\t\t//we have a minimum ipdate period\n\t\t\t\telse if (ctx->mpd->minimum_update_period) {\n\t\t\t\t\tu64 diff = dasher_get_utc(ctx) - ctx->mpd->publishTime;\n\t\t\t\t\tif (diff >= ctx->mpd->minimum_update_period)\n\t\t\t\t\t\tupdate_manifest = GF_TRUE;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (update_period)\n\t\t\t\tdasher_update_period_duration(ctx, GF_FALSE);\n\n\t\t\tif (update_manifest)\n\t\t\t\tdasher_send_manifest(filter, ctx, GF_FALSE);\n\t\t}\n\t} else if (ctx->force_hls_ll_manifest) {\n\t\tctx->force_hls_ll_manifest = GF_FALSE;\n\t\tdasher_send_manifest(filter, ctx, GF_FALSE);\n\t}\n\n\t//still some running streams in period - do not ask for reschedule, wait for input packets to be available\n\tif (count && (nb_init<count)) {\n\t\treturn GF_OK;\n\t}\n\n\t//in subdur mode once we are done, flush output pids and discard all input packets\n\t//this is done at the end to be able to resume dashing when loop is requested\n\tif (ctx->subdur) {\n\t\tfor (i=0; i<count; i++) {\n\t\t\tGF_FilterPacket *eods_pck;\n\t\t\tGF_DashStream *ds = gf_list_get(ctx->current_period->streams, i);\n\t\t\tif (ds->done) continue;\n\t\t\teods_pck = gf_filter_pck_new_alloc(ds->opid, 0, NULL);\n\t\t\tif (!eods_pck) return GF_OUT_OF_MEM;\n\t\t\tds->done = 2;\n\t\t\tds->subdur_done = GF_TRUE;\n\t\t\tgf_filter_pck_set_property(eods_pck, GF_PROP_PCK_EODS, &PROP_BOOL(GF_TRUE) );\n\t\t\tgf_filter_pck_send(eods_pck);\n\n\t\t\tdasher_drop_input(ctx, ds, GF_TRUE);\n\t\t}\n\t}\n\n\t//we need to wait for full flush of packets before switching periods in order to get the\n\t//proper segment size for segment_list+byte_range mode\n\tif (ctx->nb_seg_url_pending) {\n\t\tu64 diff;\n\t\tif (!ctx->last_evt_check_time) {\n\t\t\tctx->last_evt_check_time = gf_sys_clock_high_res();\n\t\t\tgf_filter_prevent_blocking(filter, GF_TRUE);\n\t\t}\n\n\t\tdiff = gf_sys_clock_high_res() - ctx->last_evt_check_time;\n\t\tif (diff < 10000000) {\n\t\t\tgf_filter_ask_rt_reschedule(filter, 1000);\n\t\t\treturn GF_OK;\n\t\t}\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_DASH, (\"[Dasher] timeout %d segment info still pending but no event from muxer after \"LLU\" us, aborting\\n\", ctx->nb_seg_url_pending, diff));\n\t\tctx->nb_seg_url_pending = 0;\n\t\treturn GF_SERVICE_ERROR;\n\t}\n\tif (ctx->sseg && !ctx->on_demand_done && !ctx->sigfrag && !ctx->do_index && !ctx->index_media_duration) {\n\t\treturn GF_OK;\n\t}\n\tgf_filter_prevent_blocking(filter, GF_FALSE);\n\tctx->force_period_switch = GF_FALSE;\n\t//done with this period, do period switch - this will update the MPD if needed\n\te = dasher_switch_period(filter, ctx);\n\t//no more periods\n\tif (e==GF_EOS) {\n\t\tif (!ctx->is_eos) {\n\t\t\tif (ctx->move_to_static) {\n\t\t\t\tctx->dmode = GF_MPD_TYPE_DYNAMIC_LAST;\n\t\t\t\tif (ctx->mpd) {\n\t\t\t\t\tctx->mpd->type = ctx->dmode;\n\t\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_DASH, (\"[Dasher] EOS, flushing manifest as static\\n\"));\n\t\t\t\t\tdasher_send_manifest(filter, ctx, GF_FALSE);\n\t\t\t\t}\n\t\t\t\tctx->move_to_static = GF_FALSE;\n\t\t\t}\n\t\t\tctx->is_eos = GF_TRUE;\n\t\t\tgf_filter_pid_set_eos(ctx->opid);\n\t\t}\n\t}\n\treturn e;\n}\n\n\n\nstatic void dasher_resume_subdur(GF_Filter *filter, GF_DasherCtx *ctx)\n{\n\tGF_FilterEvent evt;\n\tu32 i, count;\n\tBool is_last = (ctx->dmode == GF_MPD_TYPE_DYNAMIC_LAST) ? GF_TRUE : GF_FALSE;\n\tif (!ctx->state) return;\n\n\tcount = gf_list_count(ctx->pids);\n\tfor (i=0; i<count; i++) {\n\t\tGF_DashStream *ds = gf_list_get(ctx->pids, i);\n\t\tds->rep = NULL;\n\t\tif ((ds->done==1) && !ctx->subdur && ctx->loop) {}\n\t\telse if (ds->reschedule) {\n\t\t\t//we possibly dispatched end of stream on all outputs, we need to force unblockink to get called again\n\t\t\tgf_filter_pid_discard_block(ds->opid);\n\t\t\tcontinue;\n\t\t}\n\t\telse if (ds->done != 2) continue;\n\n\t\tif (is_last) continue;\n\n\t\tgf_filter_pid_set_discard(ds->ipid, GF_FALSE);\n\n\t\t//send stop and play\n\t\tGF_FEVT_INIT(evt, GF_FEVT_STOP, ds->ipid);\n\t\tgf_filter_pid_send_event(ds->ipid, &evt);\n\n\t\tdasher_send_encode_hints(ctx, ds);\n\t\tGF_FEVT_INIT(evt, GF_FEVT_PLAY, ds->ipid);\n\t\tevt.play.speed = 1.0;\n\t\tif (!ctx->subdur || !ctx->loop) {\n\t\t\tds->seek_to_pck = 0;\n\t\t} else {\n\t\t\t//request start after the last packet we processed\n\t\t\tevt.play.from_pck = (u32) ds->seek_to_pck+1;\n\t\t}\n\t\tgf_filter_pid_send_event(ds->ipid, &evt);\n\n\t\t//full stream looping\n\t\tif (ds->subdur_done && !ctx->subdur) {\n\t\t\tds->loop_state = 0;\n\t\t\t//mark as subdur done to force a context reload through period switch\n\t\t\tds->done = 2;\n\t\t\tds->seg_done = GF_FALSE;\n\t\t\tds->subdur_done = GF_FALSE;\n\t\t}\n\t}\n\n\tctx->subdur_done = GF_FALSE;\n\tctx->is_eos = GF_FALSE;\n\tif (!ctx->post_play_events && !is_last) {\n\t\tctx->current_period->period = NULL;\n\t\tctx->first_context_load = GF_TRUE;\n\t\tctx->post_play_events = GF_TRUE;\n\t}\n\tgf_filter_post_process_task(filter);\n}\n\nstatic void dasher_process_hls_ll(GF_DasherCtx *ctx, const GF_FilterEvent *evt)\n{\n\tu32 i, count = gf_list_count(ctx->pids);\n\tGF_DASH_SegmentContext *sctx;\n\tGF_DashStream *ds = NULL;\n\n\tif (ctx->forward_mode)\n\t\treturn;\n\n\tif (!ctx->store_seg_states) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_DASH, (\"[Dasher] Received fragment size info event but no associated segment state\\n\"));\n\t\treturn;\n\t}\n\tfor (i=0; i<count; i++) {\n\t\tds = gf_list_get(ctx->pids, i);\n\t\tif (ds->opid == evt->base.on_pid) break;\n\t\tds = NULL;\n\t}\n\tif (!ds) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_DASH, (\"[Dasher] Received fragment size info event but no associated pid\\n\"));\n\t\treturn;\n\t}\n\tif (ds->muxed_base)\n\t\tds = ds->muxed_base;\n\n\tsctx = gf_list_get(ds->pending_segment_states, 0);\n\tif (!sctx || !ctx->nb_seg_url_pending) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_DASH, (\"[Dasher] Received segment size info event but no pending segments\\n\"));\n\t\treturn;\n\t}\n\tsctx->frags = gf_realloc(sctx->frags, sizeof (GF_DASH_FragmentContext) * (sctx->nb_frags+1));\n\tif (!sctx->frags) {\n\t\tsctx->nb_frags = 0;\n\t\treturn;\n\t}\n\tsctx->frags[sctx->nb_frags].size = evt->frag_size.size;\n\tsctx->frags[sctx->nb_frags].offset = evt->frag_size.offset;\n\tif (evt->frag_size.duration.den) {\n\t\tsctx->frags[sctx->nb_frags].duration = (u32) ((u64) evt->frag_size.duration.num * ds->rep->timescale / evt->frag_size.duration.den);\n\t} else {\n\t\tsctx->frags[sctx->nb_frags].duration = 0;\n\t}\n\n\tsctx->frags[sctx->nb_frags].independent = evt->frag_size.independent;\n\tsctx->nb_frags++;\n\tif (evt->frag_size.is_last) {\n\t\tsctx->llhls_done = GF_TRUE;\n\t} else {\n\t\tctx->force_hls_ll_manifest = GF_TRUE;\n\t}\n}\n\nstatic Bool dasher_process_event(GF_Filter *filter, const GF_FilterEvent *evt)\n{\n\tu32 i, count;\n\tBool flush_mpd = GF_FALSE;\n\tGF_DasherCtx *ctx = gf_filter_get_udta(filter);\n\n\tctx->last_evt_check_time = 0;\n\n\tif (evt->base.type == GF_FEVT_RESUME) {\n\t\t//only process resume event when coming from main output PID, but always cancel it\n\t\t//this is needed in case the output filter where the resume event was initiated consumes both\n\t\t//manifest and segment PIDs, as is the case with httpout\n\t\tif (evt->base.on_pid == ctx->opid)\n\t\t\tdasher_resume_subdur(filter, ctx);\n\t\treturn GF_TRUE;\n\t}\n\tif (evt->base.type == GF_FEVT_CONNECT_FAIL) {\n\t\tctx->in_error = GF_TRUE;\n\t\tgf_filter_pid_set_eos(ctx->opid);\n\t\tif (ctx->opid_alt)\n\t\t\tgf_filter_pid_set_eos(ctx->opid_alt);\n\t\treturn GF_TRUE;\n\t}\n\n\tif (evt->base.type == GF_FEVT_PLAY) {\n\t\tctx->is_playing = GF_TRUE;\n\t\tif (!ctx->sfile && !ctx->stl && !ctx->use_cues) {\n\t\t\tGF_FilterEvent anevt;\n\t\t\tGF_FEVT_INIT(anevt, GF_FEVT_ENCODE_HINTS, NULL)\n\t\t\tcount = gf_list_count(ctx->pids);\n\t\t\tfor (i=0; i<count; i++) {\n\t\t\t\tGF_DashStream *ds = gf_list_get(ctx->pids, i);\n\t\t\t\tanevt.base.on_pid = ds->ipid;\n\t\t\t\tswitch (ctx->from_index) {\n\t\t\t\tcase IDXMODE_NONE:\n\t\t\t\t\tanevt.encode_hints.intra_period = ds->dash_dur;\n\t\t\t\t\tbreak;\n\t\t\t\tcase IDXMODE_SEG:\n\t\t\t\tcase IDXMODE_CHILD:\n\t\t\t\t\tbreak;\n\t\t\t\tcase IDXMODE_ALL:\n\t\t\t\tcase IDXMODE_INIT:\n\t\t\t\tcase IDXMODE_MANIFEST:\n\t\t\t\t\tanevt.encode_hints.gen_dsi_only = GF_TRUE;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tgf_filter_pid_send_event(ds->ipid, &anevt);\n\t\t\t}\n\t\t}\n\t\treturn GF_FALSE;\n\t}\n\tif (evt->base.type == GF_FEVT_STOP) {\n\t\tctx->is_playing = GF_FALSE;\n\t\treturn GF_FALSE;\n\t}\n\n\tif (evt->base.type == GF_FEVT_FRAGMENT_SIZE) {\n\t\tdasher_process_hls_ll(ctx, evt);\n\t\treturn GF_TRUE;\n\t}\n\tif (evt->base.type != GF_FEVT_SEGMENT_SIZE) return GF_FALSE;\n\n\tif (ctx->forward_mode==DASHER_FWD_ALL)\n\t\treturn GF_TRUE;\n\n\tcount = gf_list_count(ctx->pids);\n\tfor (i=0; i<count; i++) {\n\t\tu64 r_start, r_end;\n\t\tGF_DashStream *ds = gf_list_get(ctx->pids, i);\n\t\tif (ds->opid != evt->base.on_pid) continue;\n\n\t\tif (ds->muxed_base)\n\t\t\tds = ds->muxed_base;\n\n\t\tif (ctx->store_seg_states && !evt->seg_size.is_init) {\n\t\t\tGF_DASH_SegmentContext *sctx = gf_list_pop_front(ds->pending_segment_states);\n\t\t\tif (!sctx || !ctx->nb_seg_url_pending) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_DASH, (\"[Dasher] Broken muxer, received segment size info event but no pending segments\\n\"));\n\t\t\t\treturn GF_TRUE;\n\t\t\t}\n\t\t\tassert(sctx);\n\t\t\tassert(ctx->nb_seg_url_pending);\n\t\t\tctx->nb_seg_url_pending--;\n\t\t\tgf_filter_post_process_task(filter);\n\t\t\tsctx->file_size = 1 + (u32) (evt->seg_size.media_range_end - evt->seg_size.media_range_start);\n\t\t\tsctx->file_offset = evt->seg_size.media_range_start;\n\t\t\tsctx->index_size = 1 + (u32) (evt->seg_size.idx_range_end - evt->seg_size.idx_range_start);\n\t\t\tsctx->index_offset = evt->seg_size.idx_range_start;\n\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_DASH, (\"[Dasher] Got segment size event for %s\\n\", sctx->filename));\n\n\t\t\tif (sctx->llhls_mode) {\n\t\t\t\tsctx->llhls_done = GF_TRUE;\n\t\t\t\t//reset frags of past segments\n\t\t\t\ts32 idx, reset_until = gf_list_find(ds->rep->state_seg_list, sctx);\n\t\t\t\tfor (idx=reset_until-4; idx>=0; idx--) {\n\t\t\t\t\tGF_DASH_SegmentContext *prev_sctx = gf_list_get(ds->rep->state_seg_list, idx);\n\t\t\t\t\tif (!prev_sctx->llhls_mode)\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t//send file delete events\n\t\t\t\t\tif (prev_sctx->llhls_mode>1) {\n\t\t\t\t\t\tu32 k;\n\t\t\t\t\t\tfor (k=0; k<prev_sctx->nb_frags; k++) {\n\t\t\t\t\t\t\tGF_FilterEvent anevt;\n\t\t\t\t\t\t\tchar szPath[GF_MAX_PATH];\n\t\t\t\t\t\t\tsprintf(szPath, \"%s.%d\", prev_sctx->filepath, k+1);\n\t\t\t\t\t\t\tGF_FEVT_INIT(anevt, GF_FEVT_FILE_DELETE, ds->opid);\n\t\t\t\t\t\t\tanevt.file_del.url = szPath;\n\t\t\t\t\t\t\tgf_filter_pid_send_event(ds->opid, &anevt);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tprev_sctx->llhls_mode = 0;\n\t\t\t\t}\n\t\t\t\tctx->force_hls_ll_manifest = GF_TRUE;\n\t\t\t}\n\t\t}\n\n\t\t//in state mode we store everything\n\t\t//don't set segment sizes in template mode\n\t\tif (ctx->tpl) continue;\n\t\t//only set size/index size for init segment when doing onDemand/single index\n\t\tif (ctx->sseg && !evt->seg_size.is_init) continue;\n\n\t\tif (evt->seg_size.media_range_end) {\n\t\t\tr_start = evt->seg_size.media_range_start;\n\t\t\tr_end = evt->seg_size.media_range_end;\n\t\t} else {\n\t\t\tr_start = evt->seg_size.idx_range_start;\n\t\t\tr_end = evt->seg_size.idx_range_end;\n\t\t}\n\t\t//init segment or representation index, set it in on demand and main single source\n\t\tif ((ctx->sfile || ctx->sseg) && (evt->seg_size.is_init==1))  {\n\t\t\tGF_MPD_URL *url, **s_url;\n\n\t\t\tif (evt->seg_size.is_shift) {\n\t\t\t\tu32 j, nb_segs = gf_list_count(ds->rep->state_seg_list);\n\t\t\t\t//we assume the shifted index start range is the previous init segment end range\n\t\t\t\t//which is always the case for isobmf muxer (the only one using is_shift)\n\t\t\t\tu64 diff = 1 + (u32) (evt->seg_size.idx_range_end - evt->seg_size.idx_range_start);\n\n\t\t\t\tfor (j=0; j<nb_segs; j++) {\n\t\t\t\t\tGF_DASH_SegmentContext *sctx = gf_list_get(ds->rep->state_seg_list, j);\n\t\t\t\t\tsctx->file_offset += diff;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (ds->rep->segment_list) {\n\t\t\t\tif (!evt->seg_size.media_range_start && !evt->seg_size.media_range_end) {\n\t\t\t\t\tif (ds->rep->segment_list->initialization_segment) {\n\t\t\t\t\t\tgf_mpd_url_free(ds->rep->segment_list->initialization_segment);\n\t\t\t\t\t\tds->rep->segment_list->initialization_segment = NULL;\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (ds->rep->segment_base && !evt->seg_size.media_range_end) {\n\t\t\t\tif (! ds->rep->segment_base->index_range) {\n\t\t\t\t\tGF_SAFEALLOC(ds->rep->segment_base->index_range, GF_MPD_ByteRange);\n\t\t\t\t}\n\t\t\t\tif (ds->rep->segment_base->index_range) {\n\t\t\t\t\tds->rep->segment_base->index_range->start_range = r_start;\n\t\t\t\t\tds->rep->segment_base->index_range->end_range = r_end;\n\t\t\t\t\tds->rep->segment_base->index_range_exact = GF_TRUE;\n\t\t\t\t}\n\t\t\t\tflush_mpd = GF_TRUE;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tGF_SAFEALLOC(url, GF_MPD_URL);\n\t\t\tif (!url) return GF_TRUE;\n\n\t\t\tGF_SAFEALLOC(url->byte_range, GF_MPD_ByteRange);\n\t\t\tif (!url->byte_range) return GF_TRUE;\n\t\t\turl->byte_range->start_range = r_start;\n\t\t\turl->byte_range->end_range = r_end;\n\n\t\t\ts_url = NULL;\n\t\t\tif (ds->rep->segment_base) {\n\t\t\t\tif (evt->seg_size.media_range_end) s_url = &ds->rep->segment_base->initialization_segment;\n\t\t\t} else {\n\t\t\t\tassert(ds->rep->segment_list);\n\t\t\t\tif (evt->seg_size.media_range_end) s_url = &ds->rep->segment_list->initialization_segment;\n\t\t\t\telse s_url = &ds->rep->segment_list->representation_index;\n\t\t\t}\n\t\t\tassert(s_url);\n\t\t\tif (*s_url) gf_mpd_url_free(*s_url);\n\t\t\t*s_url = url;\n\t\t} else if (ds->rep->segment_list && !evt->seg_size.is_init) {\n\t\t\tGF_MPD_SegmentURL *url = gf_list_pop_front(ds->pending_segment_urls);\n\t\t\tif (!url || !ctx->nb_seg_url_pending) {\n\t\t\t\tif (!ds->done) {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_DASH, (\"[Dasher] Broken muxer, received segment size info event but no pending segments\\n\"));\n\t\t\t\t}\n\t\t\t\treturn GF_TRUE;\n\t\t\t}\n\t\t\tctx->nb_seg_url_pending--;\n\n\t\t\tif (!url->media && ctx->sfile) {\n\t\t\t\tGF_SAFEALLOC(url->media_range, GF_MPD_ByteRange);\n\t\t\t\tif (url->media_range) {\n\t\t\t\t\turl->media_range->start_range = evt->seg_size.media_range_start;\n\t\t\t\t\turl->media_range->end_range = evt->seg_size.media_range_end;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//patch in test mode, old arch was not generating the index size for segment lists\n\t\t\tif (evt->seg_size.idx_range_end && (!gf_sys_old_arch_compat() || ctx->sfile) ) {\n\t\t\t\tGF_SAFEALLOC(url->index_range, GF_MPD_ByteRange);\n\t\t\t\tif (url->index_range) {\n\t\t\t\t\turl->index_range->start_range = evt->seg_size.idx_range_start;\n\t\t\t\t\turl->index_range->end_range = evt->seg_size.idx_range_end;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (!ctx->sseg || !flush_mpd) return GF_TRUE;\n\n\tflush_mpd = GF_TRUE;\n\tfor (i=0; i<count; i++) {\n\t\tGF_DashStream *ds = gf_list_get(ctx->pids, i);\n\t\tif (!ds->rep) continue;\n\t\tif (! ds->rep->segment_base) continue;\n\t\tif (ds->rep->segment_base->index_range) continue;\n\t\tflush_mpd = GF_FALSE;\n\t\tbreak;\n\t}\n\tif (flush_mpd) {\n\t\tctx->on_demand_done = GF_TRUE;\n\t\tgf_filter_post_process_task(filter);\n\t}\n\treturn GF_TRUE;\n}\n\nstatic GF_Err dasher_setup_profile(GF_DasherCtx *ctx)\n{\n\tswitch (ctx->profile) {\n\tcase GF_DASH_PROFILE_AVC264_LIVE:\n\tcase GF_DASH_PROFILE_AVC264_ONDEMAND:\n\tcase GF_DASH_PROFILE_DASHIF_LL:\n\t\tif (ctx->cp == GF_DASH_CPMODE_REPRESENTATION) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_DASH, (\"[Dasher] ERROR! The selected DASH profile (DASH-IF IOP) requires the ContentProtection element to be present in the AdaptationSet element, updating.\\n\"));\n\t\t\tctx->cp = GF_DASH_CPMODE_ADAPTATION_SET;\n\t\t}\n\tdefault:\n\t\tbreak;\n\t}\n\tif (ctx->muxtype==DASHER_MUX_TS) {\n\t\tswitch (ctx->profile) {\n\t\tcase GF_DASH_PROFILE_HBBTV_1_5_ISOBMF_LIVE:\n\t\tcase GF_DASH_PROFILE_AVC264_LIVE:\n\t\tcase GF_DASH_PROFILE_DASHIF_LL:\n\t\t\tctx->profile = GF_DASH_PROFILE_LIVE;\n\t\t\tbreak;\n\t\tcase GF_DASH_PROFILE_ONDEMAND:\n\t\tcase GF_DASH_PROFILE_AVC264_ONDEMAND:\n\t\t\tctx->profile = GF_DASH_PROFILE_ONDEMAND;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/*adjust params based on profiles*/\n\tswitch (ctx->profile) {\n\tcase GF_DASH_PROFILE_LIVE:\n\t\tctx->sseg = ctx->sfile = GF_FALSE;\n\t\tctx->tpl = ctx->align = ctx->sap = GF_TRUE;\n\t\tbreak;\n\tcase GF_DASH_PROFILE_HBBTV_1_5_ISOBMF_LIVE:\n\t\tctx->check_main_role = GF_TRUE;\n\t\tctx->bs_switch = DASHER_BS_SWITCH_MULTI;\n\t\t//FALLTHROUGH\n\tcase GF_DASH_PROFILE_AVC264_LIVE:\n\t\tctx->sseg = ctx->sfile = GF_FALSE;\n\t\tctx->no_fragments_defaults = ctx->align = ctx->tpl = ctx->sap = GF_TRUE;\n\t\tbreak;\n\tcase GF_DASH_PROFILE_AVC264_ONDEMAND:\n\t\tctx->tpl = GF_FALSE;\n\t\tctx->no_fragments_defaults = ctx->align = ctx->sseg = ctx->sap = GF_TRUE;\n\t\tbreak;\n\tcase GF_DASH_PROFILE_ONDEMAND:\n\t\tctx->sseg = ctx->align = ctx->sap = ctx->sfile = GF_TRUE;\n\t\tctx->tpl = GF_FALSE;\n\n\t\tif (ctx->muxtype==DASHER_MUX_TS) {\n\t\t\tctx->sseg = GF_FALSE;\n\t\t\tctx->tpl = GF_TRUE;\n\t\t\tctx->profile = GF_DASH_PROFILE_MAIN;\n\t\t} else {\n\t\t\tif ((ctx->bs_switch != DASHER_BS_SWITCH_DEF) && (ctx->bs_switch != DASHER_BS_SWITCH_OFF)) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_DASH, (\"[Dasher] onDemand profile, bitstream switching mode cannot be used, defaulting to off.\\n\"));\n\t\t\t}\n\t\t}\n\t\t/*BS switching is meaningless in onDemand profile*/\n\t\tctx->bs_switch = DASHER_BS_SWITCH_OFF;\n\t\tbreak;\n\tcase GF_DASH_PROFILE_MAIN:\n\t\tctx->align = ctx->sap = GF_TRUE;\n\t\tctx->sseg = ctx->tpl = GF_FALSE;\n\t\tbreak;\n\tcase GF_DASH_PROFILE_DASHIF_LL:\n\t\tctx->sseg = ctx->sfile = GF_FALSE;\n\t\tctx->no_fragments_defaults = ctx->align = ctx->tpl = ctx->sap = GF_TRUE;\n\t\tif (!ctx->utcs) {\n\t\t\tconst char *default_utc_timing_server = \"https://time.akamai.com/?iso&ms\";\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_DASH, (\"[Dasher] DASH-IF LL requires UTCTiming but none specified, using %s \\n\", default_utc_timing_server));\n\t\t\tctx->utcs = gf_strdup(default_utc_timing_server);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif ((ctx->bs_switch == DASHER_BS_SWITCH_MULTI) && (ctx->pswitch == DASHER_PSWITCH_STSD)) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_DASH, (\"[Dasher] Cannot use `stsd` period switch with `multi` bitstream switching, disabling pswitch\\n\"));\n\t\tctx->pswitch = DASHER_PSWITCH_SINGLE;\n\t}\n\n\tif (ctx->sseg)\n\t\tctx->tpl = GF_FALSE;\n\n\tif (ctx->bs_switch == DASHER_BS_SWITCH_DEF) {\n\t\tctx->bs_switch = DASHER_BS_SWITCH_ON;\n\t}\n\n\tif (ctx->cmaf) {\n\t\tctx->align = GF_TRUE;\n\t\tctx->sap = GF_TRUE;\n\t}\n\n\tif (! ctx->align) {\n\t\tif (ctx->profile != GF_DASH_PROFILE_FULL) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_DASH, (\"[Dasher] Segments are not time-aligned in each representation of each period\\n\\tswitching to FULL profile\\n\"));\n\t\t\tctx->profile = GF_DASH_PROFILE_FULL;\n\t\t}\n\t\t//commented out, this does not seem correct since BS switching is orthogonal to segment alignment\n\t\t//one could have inband params working even in non time-aligned setup\n#if 0\n\t\tif (ctx->bs_switch != DASHER_BS_SWITCH_OFF) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_DASH, (\"[Dasher] Segments are not time-aligned in each representation of each period\\n\\tdisabling bitstream switching\\n\"));\n\t\t\tctx->bs_switch = DASHER_BS_SWITCH_OFF;\n\t\t}\n#endif\n\n\t}\n\n\t//check we have a segment template\n\tif (!ctx->template) {\n\t\tif (!ctx->sigfrag) {\n\t\t\tctx->template = gf_strdup( ctx->sfile ? \"$File$$FS$_dash\" : (ctx->stl ? \"$File$_dash$FS$$Time$\" : \"$File$_dash$FS$$Number$\") );\n\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_DASH, (\"[Dasher] No template assigned, using %s\\n\", ctx->template));\n\t\t\tctx->def_template = 1;\n\t\t}\n\n\t\tif (ctx->profile == GF_DASH_PROFILE_FULL) {\n\t\t\tctx->sfile = GF_TRUE;\n\t\t}\n\t}\n\t//backward compatibility with old arch using %s\n\telse {\n\t\tchar *sep = strstr(ctx->template, \"%s\");\n\t\tif (sep) {\n\t\t\tchar *new_template = NULL;\n\t\t\tsep[0] = 0;\n\t\t\tgf_dynstrcat(&new_template, ctx->template, NULL);\n\t\t\tgf_dynstrcat(&new_template, \"$File$\", NULL);\n\t\t\tgf_dynstrcat(&new_template, sep+2, NULL);\n\t\t\tgf_free(ctx->template);\n\t\t\tctx->template = new_template;\n\t\t}\n\n\t}\n\treturn GF_OK;\n}\n\nstatic GF_Err dasher_initialize(GF_Filter *filter)\n{\n\tGF_Err e;\n\tGF_DasherCtx *ctx = gf_filter_get_udta(filter);\n\tgf_filter_set_max_extra_input_pids(filter, -1);\n\n\tctx->pids = gf_list_new();\n\tctx->postponed_pids = gf_list_new();\n\tctx->tpl_records = gf_list_new();\n\tif (!ctx->initext && (ctx->muxtype==DASHER_MUX_AUTO))\n\t\tctx->muxtype = DASHER_MUX_ISOM;\n\n\tif ((ctx->segdur.num <= 0) || !ctx->segdur.den) {\n\t\tctx->segdur.num = 1;\n\t\tctx->segdur.den = 1;\n\t\tctx->no_seg_dur = GF_TRUE;\n\t}\n\tif (ctx->dmode==GF_DASH_DYNAMIC_LAST+1) {\n\t\tctx->dmode = GF_DASH_DYNAMIC;\n\t\tctx->move_to_static = GF_TRUE;\n\t}\n\n\te = dasher_setup_profile(ctx);\n\tif (e) return e;\n\n\tif (ctx->sfile && ctx->tpl)\n\t\tctx->tpl = GF_FALSE;\n\n\tctx->current_period = dasher_new_period();\n\tctx->next_period = dasher_new_period();\n\tctx->on_demand_done = GF_TRUE;\n\n\tif (ctx->state) {\n\t\tctx->first_context_load = GF_TRUE;\n\t}\n\tif (ctx->subdur && !ctx->state) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_DASH, (\"[Dasher] subdur mode specified but no context set, will only dash %g seconds of media\\n\", ctx->subdur));\n\t}\n\t//we build manifest from input frag/seg, always use single frag\n\tif (ctx->sigfrag) {\n\t\tif (ctx->tpl) {\n\t\t\tctx->sseg = GF_FALSE;\n\t\t\tctx->sfile = GF_FALSE;\n\t\t} else {\n\t\t\tif (!ctx->sseg)\n\t\t\t\tctx->sfile = GF_TRUE;\n\t\t}\n\t\tif (ctx->gencues) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_DASH, (\"[Dasher] `sigfrag` and `gencues` options cannot be used together, disabling gencies\\n\"));\n\t\t\tctx->gencues = GF_FALSE;\n\t\t}\n\t}\n\n\tif (!ctx->sap || ctx->sigfrag || ctx->cues)\n\t\tctx->sbound = DASHER_BOUNDS_OUT;\n\n\tif ((ctx->tsb>=0) && (ctx->dmode!=GF_DASH_STATIC))\n\t\tctx->purge_segments = GF_TRUE;\n\n\tif (ctx->state && ctx->sreg) {\n\t\tu32 diff;\n\t\tu64 next_gen_ntp;\n\t\tGF_Err dash_state_check_timing(const char *dash_state, u64 *next_gen_ntp_ms, u32 *next_time_ms);\n\n\t\te = dash_state_check_timing(ctx->state, &next_gen_ntp, &diff);\n\t\tif (e<0) return e;\n\t\tif (e==GF_EOS) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_DASH, (\"[Dasher] generation called too early by %d ms\\n\", (s32) diff));\n\t\t\treturn e;\n\t\t}\n\t}\n\n\n\tdasher_init_utc(filter, ctx);\n\n#ifdef GPAC_CONFIG_EMSCRIPTEN\n\t//we need to read the state file so we must run on main thread\n\tif (ctx->state)\n\t\tgf_filter_force_main_thread(filter, GF_TRUE);\n#endif\n\treturn GF_OK;\n}\n\n\nstatic void dasher_finalize(GF_Filter *filter)\n{\n\tGF_DasherCtx *ctx = gf_filter_get_udta(filter);\n\n\twhile (gf_list_count(ctx->pids)) {\n\t\tGF_DashStream *ds = gf_list_pop_back(ctx->pids);\n\t\tdasher_reset_stream(filter, ds, GF_TRUE);\n\t\tif (ds->packet_queue) gf_list_del(ds->packet_queue);\n#ifndef GPAC_DISABLE_CRYPTO\n\t\tif (ds->cinfo) gf_crypt_info_del(ds->cinfo);\n#endif\n\t\tgf_free(ds);\n\t}\n\tgf_list_del(ctx->pids);\n\tif (ctx->mpd) gf_mpd_del(ctx->mpd);\n\n\twhile (gf_list_count(ctx->tpl_records)) {\n\t\tDashTemplateRecord *tr = gf_list_pop_back(ctx->tpl_records);\n\t\tgf_free(tr->tpl);\n\t\tgf_free(tr);\n\t}\n\tgf_list_del(ctx->tpl_records);\n\n\tif (ctx->next_period->period) gf_mpd_period_free(ctx->next_period->period);\n\tgf_list_del(ctx->current_period->streams);\n\tgf_free(ctx->current_period);\n\tgf_list_del(ctx->next_period->streams);\n\tgf_free(ctx->next_period);\n\tif (ctx->out_path) gf_free(ctx->out_path);\n\tgf_list_del(ctx->postponed_pids);\n#ifndef GPAC_DISABLE_CRYPTO\n\tif (ctx->cinfo) gf_crypt_info_del(ctx->cinfo);\n#endif\n}\n\n#define MPD_EXTS \"mpd|m3u8|3gm|ism|ghix|ghi\"\n#define MPD_MIMES \"application/dash+xml|video/vnd.3gpp.mpd|audio/vnd.3gpp.mpd|video/vnd.mpeg.dash.mpd|audio/vnd.mpeg.dash.mpd|audio/mpegurl|video/mpegurl|application/vnd.ms-sstr+xml|application/x-gpac-ghi|application/x-gpac-ghix\"\n\nstatic const GF_FilterCapability DasherCaps[] =\n{\n\t//we accept files as input, but only for NULL file (no source)\n\tCAP_UINT(GF_CAPS_INPUT,  GF_PROP_PID_STREAM_TYPE, GF_STREAM_FILE),\n\t//only with no source\n\tCAP_STRING(GF_CAPS_INPUT_EXCLUDED, GF_PROP_PID_URL, \"*\"),\n\tCAP_STRING(GF_CAPS_INPUT_EXCLUDED, GF_PROP_PID_FILEPATH, \"*\"),\n\n\tCAP_UINT(GF_CAPS_OUTPUT, GF_PROP_PID_STREAM_TYPE, GF_STREAM_FILE),\n\tCAP_STRING(GF_CAPS_OUTPUT, GF_PROP_PID_FILE_EXT, MPD_EXTS),\n\tCAP_STRING(GF_CAPS_OUTPUT, GF_PROP_PID_MIME, MPD_MIMES),\n\t{0},\n\t//anything AV pid framed result in manifest PID\n\tCAP_UINT(GF_CAPS_INPUT,  GF_PROP_PID_STREAM_TYPE, GF_STREAM_VISUAL),\n\tCAP_UINT(GF_CAPS_INPUT,  GF_PROP_PID_STREAM_TYPE, GF_STREAM_AUDIO),\n\tCAP_UINT(GF_CAPS_INPUT_EXCLUDED, GF_PROP_PID_CODECID, GF_CODECID_NONE),\n\tCAP_BOOL(GF_CAPS_INPUT_EXCLUDED, GF_PROP_PID_UNFRAMED, GF_TRUE),\n\n\tCAP_UINT(GF_CAPS_OUTPUT, GF_PROP_PID_STREAM_TYPE, GF_STREAM_FILE),\n\tCAP_STRING(GF_CAPS_OUTPUT, GF_PROP_PID_FILE_EXT, MPD_EXTS),\n\tCAP_STRING(GF_CAPS_OUTPUT, GF_PROP_PID_MIME, MPD_MIMES),\n\t{0},\n\t//anything else (not file, not AV and framed) in compressed format result in manifest PID\n\t//we cannot handle RAW format for such streams as these are in-memory data (scene graph, decoded text, etc ..)\n\tCAP_UINT(GF_CAPS_INPUT_EXCLUDED,  GF_PROP_PID_STREAM_TYPE, GF_STREAM_FILE),\n\tCAP_UINT(GF_CAPS_INPUT_EXCLUDED,  GF_PROP_PID_STREAM_TYPE, GF_STREAM_VISUAL),\n\tCAP_UINT(GF_CAPS_INPUT_EXCLUDED,  GF_PROP_PID_STREAM_TYPE, GF_STREAM_AUDIO),\n\tCAP_UINT(GF_CAPS_INPUT_EXCLUDED, GF_PROP_PID_CODECID, GF_CODECID_RAW),\n\tCAP_BOOL(GF_CAPS_INPUT_EXCLUDED, GF_PROP_PID_UNFRAMED, GF_TRUE),\n\n\tCAP_UINT(GF_CAPS_OUTPUT, GF_PROP_PID_STREAM_TYPE, GF_STREAM_FILE),\n\tCAP_STRING(GF_CAPS_OUTPUT, GF_PROP_PID_FILE_EXT, MPD_EXTS),\n\tCAP_STRING(GF_CAPS_OUTPUT, GF_PROP_PID_MIME, MPD_MIMES),\n\t{0},\n\t//anything else (not file and framed) result in media pids not file\n\tCAP_UINT(GF_CAPS_INPUT_EXCLUDED | GF_CAPFLAG_LOADED_FILTER,  GF_PROP_PID_STREAM_TYPE, GF_STREAM_FILE),\n\tCAP_UINT(GF_CAPS_INPUT_EXCLUDED | GF_CAPFLAG_LOADED_FILTER, GF_PROP_PID_CODECID, GF_CODECID_NONE),\n\tCAP_BOOL(GF_CAPS_INPUT_EXCLUDED | GF_CAPFLAG_LOADED_FILTER, GF_PROP_PID_UNFRAMED, GF_TRUE),\n\tCAP_UINT(GF_CAPS_OUTPUT_EXCLUDED | GF_CAPFLAG_LOADED_FILTER, GF_PROP_PID_STREAM_TYPE, GF_STREAM_FILE),\n\n};\n\n\n#define OFFS(_n)\t#_n, offsetof(GF_DasherCtx, _n)\nstatic const GF_FilterArgs DasherArgs[] =\n{\n\t{ OFFS(segdur), \"target segment duration in seconds. A value less than or equal to 0 defaults to 1.0 second\", GF_PROP_FRACTION, \"0/0\", NULL, 0},\n\t{ OFFS(tpl), \"use template mode (multiple segment, template URLs)\", GF_PROP_BOOL, \"true\", NULL, 0},\n\t{ OFFS(stl), \"use segment timeline (ignored in on_demand mode)\", GF_PROP_BOOL, \"false\", NULL, 0},\n\t{ OFFS(dmode), \"dash content mode\\n\"\n\t\t\"- static: static content\\n\"\n\t\t\"- dynamic: live generation\\n\"\n\t\t\"- dynlast: last call for live, will turn the MPD into static\\n\"\n\t\t\"- dynauto: live generation and move to static manifest upon end of stream\"\n\t\t\"\", GF_PROP_UINT, \"static\", \"static|dynamic|dynlast|dynauto\", GF_FS_ARG_UPDATE},\n\t{ OFFS(sseg), \"single segment is used\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(sfile), \"use a single file for all segments (default in on_demand)\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(align), \"enable segment time alignment between representations\", GF_PROP_BOOL, \"true\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(sap), \"enable splitting segments at SAP boundaries\", GF_PROP_BOOL, \"true\", NULL, 0},\n\t{ OFFS(mix_codecs), \"enable mixing different codecs in an adaptation set\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_EXPERT},\n\t{ OFFS(ntp), \"insert/override NTP clock at the beginning of each segment\\n\"\n\t\"- rem: removes NTP from all input packets\\n\"\n\t\"- yes: inserts NTP at each segment start\\n\"\n\t\"- keep: leaves input packet NTP untouched\", GF_PROP_UINT, \"rem\", \"rem|yes|keep\", GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(no_sar), \"do not check for identical sample aspect ratio for adaptation sets\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_EXPERT},\n\t{ OFFS(bs_switch), \"bitstream switching mode (single init segment)\\n\"\n\t\"- def: resolves to off for onDemand and inband for live\\n\"\n\t\"- off: disables BS switching\\n\"\n\t\"- on: enables it if same decoder configuration is possible\\n\"\n\t\"- inband: moves decoder config inband if possible\\n\"\n\t\"- both: inband and outband parameter sets\\n\"\n\t\"- pps: moves PPS and APS inband, keep VPS,SPS and DCI out of band (used for VVC RPR)\\n\"\n\t\"- force: enables it even if only one representation\\n\"\n\t\"- multi: uses multiple stsd entries in ISOBMFF\", GF_PROP_UINT, \"def\", \"def|off|on|inband|pps|both|force|multi\", GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(template), \"template string to use to generate segment name\", GF_PROP_STRING, NULL, NULL, 0},\n\t{ OFFS(segext), \"file extension to use for segments\", GF_PROP_STRING, NULL, NULL, 0},\n\t{ OFFS(initext), \"file extension to use for the init segment\", GF_PROP_STRING, NULL, NULL, 0},\n\t{ OFFS(muxtype), \"muxtype to use for the segments\\n\"\n\t\t\"- mp4: uses ISOBMFF format\\n\"\n\t\t\"- ts: uses MPEG-2 TS format\\n\"\n\t\t\"- mkv: uses Matroska format\\n\"\n\t\t\"- webm: uses WebM format\\n\"\n\t\t\"- ogg: uses OGG format\\n\"\n\t\t\"- raw: uses raw media format (disables multiplexed representations)\\n\"\n\t\t\"- auto: guess format based on extension, default to mp4 if no extension\", GF_PROP_UINT, \"auto\", \"mp4|ts|mkv|webm|ogg|raw|auto\", 0},\n\t{ OFFS(rawsub), \"use raw subtitle format instead of encapsulating in container\", GF_PROP_BOOL, \"no\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(asto), \"availabilityStartTimeOffset to use in seconds. A negative value simply increases the AST, a positive value sets the ASToffset to representations\", GF_PROP_DOUBLE, \"0\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(profile), \"target DASH profile. This will set default option values to ensure conformance to the desired profile. For MPEG-2 TS, only main and live are used, others default to main\\n\"\n\t\t\"- auto: turns profile to live for dynamic and full for non-dynamic\\n\"\n\t\t\"- live: DASH live profile, using segment template\\n\"\n\t\t\"- onDemand: MPEG-DASH live profile\\n\"\n\t\t\"- main: MPEG-DASH main profile, using segment list\\n\"\n\t\t\"- full: MPEG-DASH full profile\\n\"\n\t\t\"- hbbtv1.5.live: HBBTV 1.5 DASH profile\\n\"\n\t\t\"- dashavc264.live: DASH-IF live profile\\n\"\n\t\t\"- dashavc264.onDemand: DASH-IF onDemand profile\\n\"\n\t\t\"- dashif.ll: DASH IF low-latency profile (set UTC server to time.akamai.com if none set)\"\n\t\t\"\", GF_PROP_UINT, \"auto\", \"auto|live|onDemand|main|full|hbbtv1.5.live|dashavc264.live|dashavc264.onDemand|dashif.ll\", 0 },\n\t{ OFFS(profX), \"list of profile extensions, as used by DASH-IF and DVB. The string will be colon-concatenated with the profile used. If starting with `+`, the profile string by default is erased and `+` is skipped\", GF_PROP_STRING, NULL, NULL, GF_FS_ARG_HINT_ADVANCED },\n\t{ OFFS(cp), \"content protection element location\\n\"\n\t\"- set: in adaptation set element\\n\"\n\t\"- rep: in representation element\\n\"\n\t\"- both: in both adaptation set and representation elements\"\n\t\"\", GF_PROP_UINT, \"set\", \"set|rep|both\", GF_FS_ARG_HINT_ADVANCED },\n\t{ OFFS(pssh), \"storage mode for PSSH box\\n\"\n\t\"- f: stores in movie fragment only\\n\"\n\t\"- v: stores in movie only, or movie and fragments if key roll is detected\\n\"\n\t\"- m: stores in mpd only\\n\"\n\t\"- mf: stores in mpd and movie fragment\\n\"\n\t\"- mv: stores in mpd and movie\\n\"\n\t\"- n: discard pssh from mpd and segments\", GF_PROP_UINT, \"v\", \"v|f|mv|mf|m|n\", GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(buf), \"min buffer duration in ms. negative value means percent of segment duration (e.g. -150 = 1.5*seg_dur)\", GF_PROP_SINT, \"-100\", NULL, 0},\n\t{ OFFS(spd), \"suggested presentation delay in ms\", GF_PROP_SINT, \"0\", NULL, 0},\n\t{ OFFS(timescale), \"set timescale for timeline and segment list/template. A value of 0 picks up the first timescale of the first stream in an adaptation set. A negative value forces using stream timescales for each timed element (multiplication of segment list/template/timelines). A positive value enforces the MPD timescale\", GF_PROP_SINT, \"0\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(check_dur), \"check duration of sources in period, trying to have roughly equal duration. Enforced whenever period start times are used\", GF_PROP_BOOL, \"true\", NULL, 0},\n\t{ OFFS(skip_seg), \"increment segment number whenever an empty segment would be produced - NOT DASH COMPLIANT\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_EXPERT},\n\t{ OFFS(title), \"MPD title\", GF_PROP_STRING, NULL, NULL, 0},\n\t{ OFFS(source), \"MPD Source\", GF_PROP_STRING, NULL, NULL, 0},\n\t{ OFFS(info), \"MPD info url\", GF_PROP_STRING, NULL, NULL, 0},\n\t{ OFFS(cprt), \"MPD copyright string\", GF_PROP_STRING, NULL, NULL, 0},\n\t{ OFFS(lang), \"language of MPD Info\", GF_PROP_STRING, NULL, NULL, 0},\n\t{ OFFS(location), \"set MPD locations to given URL\", GF_PROP_STRING_LIST, NULL, NULL, 0},\n\t{ OFFS(base), \"set base URLs of MPD\", GF_PROP_STRING_LIST, NULL, NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(refresh), \"refresh rate for dynamic manifests, in seconds (a negative value sets the MPD duration, value 0 uses dash duration)\", GF_PROP_DOUBLE, \"0\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(tsb), \"time-shift buffer depth in seconds (a negative value means infinity)\", GF_PROP_DOUBLE, \"30\", NULL, 0},\n\t{ OFFS(subdur), \"maximum duration of the input file to be segmented. This does not change the segment duration, segmentation stops once segments produced exceeded the duration\", GF_PROP_DOUBLE, \"0\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(ast), \"set start date (as xs:date, e.g. YYYY-MM-DDTHH:MM:SSZ) for live mode. Default is now. !! Do not use with multiple periods, nor when DASH duration is not a multiple of GOP size !!\", GF_PROP_STRING, NULL, NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(state), \"path to file used to store/reload state info when simulating live. This is stored as a valid MPD with GPAC XML extensions\", GF_PROP_STRING, NULL, NULL, GF_FS_ARG_HINT_EXPERT},\n\t{ OFFS(loop), \"loop sources when dashing with subdur and state. If not set, a new period is created once the sources are over\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(split), \"enable cloning samples for text/metadata/scene description streams, marking further clones as redundant\", GF_PROP_BOOL, \"true\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(hlsc), \"insert clock reference in variant playlist in live HLS\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_EXPERT},\n\t{ OFFS(cues), \"set cue file\", GF_PROP_STRING, NULL, NULL, GF_FS_ARG_HINT_EXPERT},\n\t{ OFFS(strict_cues), \"strict mode for cues, complains if splitting is not on SAP type 1/2/3 or if unused cue is found\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_EXPERT},\n\t{ OFFS(strict_sap), \"strict mode for sap\\n\"\n\t\"- off: ignore SAP types for PID other than video, enforcing _startsWithSAP=1_\\n\"\n\t\"- sig: same as [-off]() but keep _startsWithSAP_ to the true SAP value\\n\"\n\t\"- on: warn if any PID uses SAP 3 or 4 and switch to FULL profile\\n\"\n\t\"- intra: ignore SAP types greater than 3 on all media types\"\n\t, GF_PROP_UINT, \"off\", \"off|sig|on|intra\", GF_FS_ARG_HINT_EXPERT},\n\n\t{ OFFS(subs_sidx), \"number of subsegments per sidx. negative value disables sidx. Only used to inherit sidx option of destination\", GF_PROP_SINT, \"-1\", NULL, GF_FS_ARG_HINT_EXPERT},\n\t{ OFFS(cmpd), \"skip line feed and spaces in MPD XML for compactness\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_EXPERT},\n\t{ OFFS(styp), \"indicate the 4CC to use for styp boxes when using ISOBMFF output\", GF_PROP_STRING, NULL, NULL, GF_FS_ARG_HINT_EXPERT},\n\t{ OFFS(dual), \"indicate to produce both MPD and M3U files\", GF_PROP_BOOL, NULL, NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(sigfrag), \"use manifest generation only mode\", GF_PROP_BOOL, NULL, NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(_p_gentime), \"pointer to u64 holding the ntp clock in ms of next DASH generation in live mode\", GF_PROP_POINTER, NULL, NULL, GF_FS_ARG_HINT_HIDE},\n\t{ OFFS(_p_mpdtime), \"pointer to u64 holding the mpd time in ms of the last generated segment\", GF_PROP_POINTER, NULL, NULL, GF_FS_ARG_HINT_HIDE},\n\t{ OFFS(sbound), \"indicate how the theoretical segment start `TSS (= segment_number * duration)` should be handled\\n\"\n\t\t\t\t\"- out: segment split as soon as `TSS` is exceeded (`TSS` <= segment_start)\\n\"\n\t\t\t\t\"- closest: segment split at closest SAP to theoretical bound\\n\"\n\t\t\t\t\"- in: `TSS` is always in segment (`TSS` >= segment_start)\", GF_PROP_UINT, \"out\", \"out|closest|in\", GF_FS_ARG_HINT_EXPERT},\n\t{ OFFS(reschedule), \"reschedule sources with no period ID assigned once done (dynamic mode only)\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_EXPERT},\n\t{ OFFS(sreg), \"regulate the session\\n\"\n\t\"- when using subdur and context, only generate segments from the past up to live edge\\n\"\n\t\"- otherwise in dynamic mode without context, do not generate segments ahead of time\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_EXPERT},\n\t{ OFFS(scope_deps), \"scope PID dependencies to be within source. If disabled, PID dependencies will be checked across all input PIDs regardless of their sources\", GF_PROP_BOOL, \"true\", NULL, GF_FS_ARG_HINT_EXPERT},\n\t{ OFFS(utcs), \"URL to use as time server / UTCTiming source. Special value `inband` enables inband UTC (same as publishTime), special prefix `xsd@` uses xsDateTime schemeURI rather than ISO\", GF_PROP_STRING, NULL, NULL, GF_FS_ARG_HINT_EXPERT},\n\t{ OFFS(force_flush), \"force generating a single segment for each input. This can be useful in batch mode when average source duration is known and used as segment duration but actual duration may sometimes be greater\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_EXPERT},\n\t{ OFFS(last_seg_merge), \"force merging last segment if less than half the target duration\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_EXPERT},\n\t{ OFFS(mha_compat), \"adaptation set generation mode for compatible MPEG-H Audio profile\\n\"\n\t\t\"- no: only generate the adaptation set for the main profile\\n\"\n\t\t\"- comp: only generate the adaptation sets for all compatible profiles\\n\"\n\t\t\"- all: generate the adaptation set for the main profile and all compatible profiles\"\n\t\t, GF_PROP_UINT, \"no\", \"no|comp|all\", GF_FS_ARG_HINT_EXPERT},\n\t{ OFFS(mname), \"output manifest name for ATSC3 multiplexing\", GF_PROP_STRING, NULL, NULL, GF_FS_ARG_HINT_EXPERT},\n\t{ OFFS(llhls), \"HLS low latency type\\n\"\n\t\t\"- off: do not use LL-HLS\\n\"\n\t\t\"- br: use LL-HLS with byte-range for segment parts, pointing to full segment (DASH-LL compatible)\\n\"\n\t\t\"- sf: use separate files for segment parts (post-fixed .1, .2 etc.)\\n\"\n\t\t\"- brsf: generate two sets of manifest, one for byte-range and one for files (`_IF` added before extension of manifest)\", GF_PROP_UINT, \"off\", \"off|br|sf|brsf\", GF_FS_ARG_HINT_EXPERT},\n\t{ OFFS(cdur), \"chunk duration for fragmentation modes\", GF_PROP_FRACTION, \"-1/1\", NULL, GF_FS_ARG_HINT_HIDE},\n\t{ OFFS(hlsdrm), \"cryp file info for HLS full segment encryption\", GF_PROP_STRING, NULL, NULL, GF_FS_ARG_HINT_EXPERT},\n\t{ OFFS(hlsx), \"list of string to append to master HLS header before variants with `['#foo','#bar=val']` added as `#foo \\\\n #bar=val`\", GF_PROP_STRING_LIST, NULL, NULL, GF_FS_ARG_HINT_EXPERT},\n\t{ OFFS(ll_preload_hint), \"inject preload hint for LL-HLS\", GF_PROP_BOOL, \"true\", NULL, GF_FS_ARG_HINT_EXPERT},\n\t{ OFFS(ll_rend_rep), \"inject rendition reports for LL-HLS\", GF_PROP_BOOL, \"true\", NULL, GF_FS_ARG_HINT_EXPERT},\n\t{ OFFS(ll_part_hb), \"user-defined part hold-back for LLHLS, negative value means 3 times max part duration in session\", GF_PROP_DOUBLE, \"-1\", NULL, GF_FS_ARG_HINT_EXPERT},\n\t{ OFFS(ckurl), \"set the ClearKey URL common to all encrypted streams (overriden by `CKUrl` pid property)\", GF_PROP_STRING, NULL, NULL, GF_FS_ARG_HINT_EXPERT},\n\n\t{ OFFS(hls_absu), \"use absolute url in HLS generation using first URL in [base]()\\n\"\n\t\"- no: do not use absolute URL\\n\"\n\t\"- var: use absolute URL only in variant playlists\\n\"\n\t\"- mas: use absolute URL only in master playlist\\n\"\n\t\"- both: use absolute URL everywhere\"\n\t\t, GF_PROP_UINT, \"no\", \"no|var|mas|both\", GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(seg_sync), \"control how waiting on last packet P of fragment/segment to be written impacts segment injection in manifest\\n\"\n\t\"- no: do not wait for P\\n\"\n\t\"- yes: wait for P\\n\"\n\t\"- auto: wait for P if HLS is used\"\n\t, GF_PROP_UINT, \"auto\", \"no|yes|auto\", GF_FS_ARG_HINT_EXPERT},\n\n\t{ OFFS(cmaf), \"use cmaf guidelines\\n\"\n\t\t\"- no: CMAF not enforced\\n\"\n\t\t\"- cmfc: use CMAF `cmfc` guidelines\\n\"\n\t\t\"- cmf2: use CMAF `cmf2` guidelines\"\n\t\t, GF_PROP_UINT, \"no\", \"no|cmfc|cmf2\", GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(pswitch), \"period switch control mode\\n\"\n\t\t\"- single: change period if PID configuration changes\\n\"\n\t\t\"- force: force period switch at each PID reconfiguration instead of absorbing PID reconfiguration (for splicing or add insertion not using periodID)\\n\"\n\t\t\"- stsd: change period if PID configuration changes unless new configuration was advertised in initial config\", GF_PROP_UINT, \"single\", \"single|force|stsd\", GF_FS_ARG_HINT_EXPERT},\n\t{ OFFS(chain), \"URL of next MPD for regular chaining\", GF_PROP_STRING, NULL, NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(chain_fbk), \"URL of fallback MPD\", GF_PROP_STRING, NULL, NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(gencues), \"only insert segment boundaries and do not generate manifests\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(force_init), \"force init segment creation in bitstream switching mode\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_EXPERT},\n\t{ OFFS(keep_src), \"keep source URLs in manifest generation mode\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_EXPERT},\n\t{ OFFS(gxns), \"insert some gpac extensions in manifest (for now, only tfdt of first segment)\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_EXPERT},\n\t{ OFFS(dkid), \"control injection of default KID in MPD\\n\"\n\t\t\"- off: default KID not injected\\n\"\n\t\t\"- on: default KID always injected\\n\"\n\t\t\"- auto: default KID only injected if no key roll is detected (as per DASH-IF guidelines)\"\n\t\t, GF_PROP_UINT, \"auto\", \"off|on|auto\", GF_FS_ARG_HINT_EXPERT},\n\t{ OFFS(tpl_force), \"use template string as is without trying to add extension or solve conflicts in names\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_EXPERT},\n\n\t{0}\n};\n\n\nGF_FilterRegister DasherRegister = {\n\t.name = \"dasher\",\n\tGF_FS_SET_DESCRIPTION(\"DASH and HLS segmenter\")\n\tGF_FS_SET_HELP(\n\"This filter provides segmentation and manifest generation for MPEG-DASH and HLS formats.\\n\"\n\"The segmenter currently supports:\\n\"\n\"- MPD and m3u8 generation (potentially in parallel)\\n\"\n\"- ISOBMFF, MPEG-2 TS, MKV and raw bitstream segment formats\\n\"\n\"- override of profiles and levels in manifest for codecs\\n\"\n\"- most MPEG-DASH profiles\\n\"\n\"- static and dynamic (live) manifest offering\\n\"\n\"- context store and reload for batch processing of live/dynamic sessions\\n\"\n\"\\n\"\n\"The filter does perform per-segment real-time regulation using [-sreg]().\\n\"\n\"If you need per-frame real-time regulation on non-real-time inputs, insert a [reframer](reframer) before to perform real-time regulation.\\n\"\n\"EX gpac -i file.mp4 reframer:rt=on -o live.mpd:dmode=dynamic\\n\"\n\"## Template strings\\n\"\n\"The segmenter uses templates to derive output file names, regardless of the DASH mode (even when templates are not used). \"\n\"The default one is `$File$_dash` for ondemand and single file modes, and `$File$_$Number$` for separate segment files\\n\"\n\"EX template=Great_$File$_$Width$_$Number$\\n\"\n\"If input is `foo.mp4` with `640x360` video resolution, this will resolve in `Great_foo_640_$Number$` for the DASH template.\\n\"\n\"EX template=Great_$File$_$Width$\\n\"\n\"If input is `foo.mp4` with `640x360` video resolution, this will resolve in `Great_foo_640.mp4` for onDemand case.\\n\"\n\"\\n\"\n\"Standard DASH replacement strings: \\n\"\n\"- $Number[%%0Nd]$: replaced by the segment number, possibly prefixed with 0\\n\"\n\"- $RepresentationID$: replaced by representation name\\n\"\n\"- $Time$: replaced by segment start time\\n\"\n\"- $Bandwidth$: replaced by representation bandwidth.\\n\"\n\"Note: these strings are not replaced in the manifest templates elements.\\n\"\n\"\\n\"\n\"Additional replacement strings (not DASH, not generic GPAC replacements but may occur multiple times in template):\\n\"\n\"- $Init=NAME$: replaced by NAME for init segment, ignored otherwise\\n\"\n\"- $XInit=NAME$: complete replace by NAME for init segment, ignored otherwise\\n\"\n\"- $InitExt=EXT$: replaced by EXT for init segment file extensions, ignored otherwise\\n\"\n\"- $Index=NAME$: replaced by NAME for index segments, ignored otherwise\\n\"\n\"- $Path=PATH$: replaced by PATH when creating segments, ignored otherwise\\n\"\n\"- $Segment=NAME$: replaced by NAME for media segments, ignored for init segments\\n\"\n\"- $SegExt=EXT$: replaced by EXT for media segment file extensions, ignored for init segments\\n\"\n\"- $FS$ (FileSuffix): replaced by `_trackN` in case the input is an AV multiplex, or kept empty otherwise\\n\"\n\"Note: these strings are replaced in the manifest templates elements.\\n\"\n\"\\n\"\n\"## PID assignment and configuration\\n\"\n\"To assign PIDs into periods and adaptation sets and configure the session, the segmenter looks for the following properties on each input PID:\\n\"\n\"- `Representation`: assigns representation ID to input PID. If not set, the default behavior is to have each media component in different adaptation sets. Setting the `Representation` allows explicit multiplexing of the source(s)\\n\"\n\"- `Period`: assigns period ID to input PID. If not set, the default behavior is to have all media in the same period with the same start time\\n\"\n\"- `PStart`: assigns period start. If not set, 0 is assumed, and periods appear in the Period ID declaration order. If negative, this gives the period order (-1 first, then -2 ...). If positive, this gives the true start time and will abort DASHing at period end\\n\"\n\"Note: When both positive and negative values are found, the by-order periods (negative) will be inserted AFTER the timed period (positive)\\n\"\n\"- `ASID`: assigns parent adaptation set ID. If not 0, only sources with same AS ID will be in the same adaptation set\\n\"\n\"Note: If multiple streams in source, only the first stream will have an AS ID assigned\\n\"\n\"- `xlink`: for remote periods, only checked for null PID\\n\"\n\"- `Role`, `PDesc`, `ASDesc`, `ASCDesc`, `RDesc`: various descriptors to set for period, AS or representation\\n\"\n\"- `BUrl`: overrides segmenter [-base] with a set of BaseURLs to use for the PID (per representation)\\n\"\n\"- `Template`: overrides segmenter [-template]() for this PID\\n\"\n\"- `DashDur`: overrides segmenter segment duration for this PID\\n\"\n\"- `StartNumber`: sets the start number for the first segment in the PID, default is 1\\n\"\n\"- `IntraOnly`: indicates input PID follows HLS EXT-X-I-FRAMES-ONLY guidelines\\n\"\n\"- `CropOrigin`: indicates x and y coordinates of video for SRD (size is video size)\\n\"\n\"- `SRD`: indicates SRD position and size of video for SRD, ignored if `CropOrigin` is set\\n\"\n\"- `SRDRef`: indicates global width and height of SRD, ignored if `CropOrigin` is set\\n\"\n\"- `HLSMExt`: list of extensions to add to master playlist entries, ['foo','bar=val'] added as `,foo,bar=val`\\n\"\n\"- `HLSVExt`: list of extensions to add to variant playlist, ['#foo','#bar=val'] added as `#foo \\\\n #bar=val`\\n\"\n\"- Non-dash properties: `Bitrate`, `SAR`, `Language`, `Width`, `Height`, `SampleRate`, `NumChannels`, `Language`, `ID`, `DependencyID`, `FPS`, `Interlaced`, `Codec`. These properties are used to setup each representation and can be overridden on input PIDs using the general PID property settings (cf global help).\\n\"\n\"  \\n\"\n\"EX gpac -i test.mp4:#Bitrate=1M -o test.mpd\\n\"\n\"This will force declaring a bitrate of 1M for the representation, regardless of actual input bitrate.\\n\"\n\"EX gpac -i muxav.mp4 -o test.mpd\\n\"\n\"This will create un-multiplexed DASH segments.\\n\"\n\"EX gpac -i muxav.mp4:#Representation=1 -o test.mpd\\n\"\n\"This will create multiplexed DASH segments.\\n\"\n\"EX gpac -i m1.mp4 -i m2.mp4:#Period=Yep -o test.mpd\\n\"\n\"This will put src `m1.mp4` in first period, `m2.mp4` in second period.\\n\"\n\"EX gpac -i m1.mp4:#BUrl=http://foo/bar -o test.mpd\\n\"\n\"This will assign a baseURL to src `m1.mp4`.\\n\"\n\"EX gpac -i m1.mp4:#ASCDesc=<ElemName val=\\\"attval\\\">text</ElemName> -o test.mpd\\n\"\n\"This will assign the specified XML descriptor to the adaptation set.\\n\"\n\"Note:  this can be used to inject most DASH descriptors not natively handled by the segmenter.\\n\"\n\"The segmenter handles the XML descriptor as a string and does not attempt to validate it. Descriptors, as well as some segmenter filter arguments, are string lists (comma-separated by default), so that multiple descriptors can be added:\\n\"\n\"EX gpac -i m1.mp4:#RDesc=<Elem attribute=\\\"1\\\"/>,<Elem2>text</Elem2> -o test.mpd\\n\"\n\"This will insert two descriptors in the representation(s) of `m1.mp4`.\\n\"\n\"EX gpac -i video.mp4:#Template=foo$Number$ -i audio.mp4:#Template=bar$Number$ -o test.mpd\\n\"\n\"This will assign different templates to the audio and video sources.\\n\"\n\"EX gpac -i null:#xlink=http://foo/bar.xml:#PDur=4 -i m.mp4:#PStart=-1 -o test.mpd\\n\"\n\"This will insert an create an MPD with first a remote period then a regular one.\\n\"\n\"EX gpac -i null:#xlink=http://foo/bar.xml:#PStart=6 -i m.mp4 -o test.mpd\\n\"\n\"This will create an MPD with first a regular period, dashing only 6s of content, then a remote one.\\n\"\n\"EX gpac -i v1:#SRD=0x0x1280x360:#SRDRef=1280x720 -i v2:#SRD=0x360x1280x360 -o test.mpd\\n\"\n\"This will layout the `v2` below `v1` using a global SRD size of 1280x720.\\n\"\n\"\\n\"\n\"The segmenter will create multiplexing filter chains for each representation and will reassign PID IDs so that each media component (video, audio, ...) in an adaptation set has the same ID.\\n\"\n\"\\n\"\n\"For HLS, the output PID will deliver the master playlist **and** the variant playlists.\\n\"\n\"The default variant playlist are $NAME_$N.m3u8, where $NAME is the radical of the output file name and $N is the 1-based index of the variant.\\n\"\n\"\\n\"\n\"## Segmentation\\n\"\n\"The default behavior of the segmenter is to estimate the theoretical start time of each segment based on target segment duration, and start a new segment when a packet with SAP type 1,2,3 or 4 with time greater than the theoretical time is found.\\n\"\n\"This behavior can be changed to find the best SAP packet around a segment theoretical boundary using [-sbound]():\\n\"\n\"- `closest` mode: the segment will start at the closest SAP of the theoretical boundary\\n\"\n\"- `in` mode: the segment will start at or before the theoretical boundary\\n\"\n\"Warning: These modes will introduce delay in the segmenter (typically buffering of one GOP) and should not be used for low-latency modes.\\n\"\n\"The segmenter can also be configured to:\\n\"\n\"- completely ignore SAP when segmenting using [-sap]().\\n\"\n\"- ignore SAP on non-video streams when segmenting using [-strict_sap]().\\n\"\n\"\\n\"\n\"When [-seg_sync]() is disabled, the segmenter will by default announce a new segment in the manifest(s) as soon as its size/offset is known or its name is known, but the segment (or part in LL-HLS) may still not be completely written/sent.\\n\"\n\"This may result in temporary mismatches between segment/part size currently received versus size as advertized in manifest.\\n\"\n\"When [-seg_sync]() is enabled, the segmenter will wait for the last byte of the fragment/segment to be pushed before announcing a new segment in the manifest(s). This can however slightly increase the latency in MPEG-DASH low-latency.\\n\"\n\"\\n\"\n\"## Dynamic (real-time live) Mode\\n\"\n\"The dasher does not perform real-time regulation by default.\\n\"\n\"For regular segmentation, you should enable segment regulation [-sreg]() if your sources are not real-time.\\n\"\n\"EX gpac -i source.mp4 -o live.mpd:segdur=2:profile=live:dmode=dynamic:sreg\\n\"\n\"\\n\"\n\"For low latency segmentation with fMP4, you will need to specify the following options:\\n\"\n\"- cdur: set the fMP4 fragment duration\\n\"\n\"- asto: set the availability time offset for DASH. This value should be equal or slightly greater than segment duration minus cdur\\n\"\n\"- llhls: enable low latency for HLS\\n\"\n\"\\n\"\n\"Note: [-llhls]() does not force `cmaf` mode to allow for multiplexed media in segments but it enforces to `tfdt_traf` in the muxer.\\n\"\n\"\\n\"\n\"If your sources are not real-time, insert a reframer filter with real-time regulation\\n\"\n\"EX gpac -i source.mp4 reframer:rt=on -o live.mpd:segdur=2:cdur=0.2:asto=1.8:profile=live:dmode=dynamic\\n\"\n\"This will create DASH segments of 2 seconds made of fragments of 200 ms and indicate to the client that requests can be made 1.8 seconds earlier than segment complete availability on server.\\n\"\n\"EX gpac -i source.mp4 reframer:rt=on -o live.m3u8:segdur=2:cdur=0.2:llhls=br:dmode=dynamic\\n\"\n\"This will create DASH segments of 2 seconds made of fragments of 200 ms and produce HLS low latency parts using byte ranges in the final segment.\\n\"\n\"EX gpac -i source.mp4 reframer:rt=on -o live.m3u8:segdur=2:cdur=0.2:llhls=sf:dmode=dynamic\\n\"\n\"This will create DASH segments of 2 seconds made of fragments of 200 ms and produce HLS low latency parts using dedicated files.\\n\"\n\"\\n\"\n\"You can combine LL-HLS and DASH-LL generation:\\n\"\n\"EX gpac -i source.mp4 reframer:rt=on -o live.mpd:dual:segdur=2:cdur=0.2:asto=1.8:llhls=br:profile=live:dmode=dynamic\\n\"\n\"\\n\"\n\"For DASH, the filter will use the local clock for UTC anchor points in DASH.\\n\"\n\"The filter can fetch and signal clock in other ways using [-utcs]().\\n\"\n\"EX [opts]:utcs=inband\\n\"\n\"This will use the local clock and insert in the MPD a UTCTiming descriptor containing the local clock.\\n\"\n\"EX [opts]::utcs=http://time.akamai.com[::opts]\\n\"\n\"This will fetch time from `http://time.akamai.com`, use it as the UTC reference for segment generation and insert in the MPD a UTCTiming descriptor containing the time server URL.\\n\"\n\"Note: if not set as a global option using `--utcs=`, you must escape the url using double `::` or use other separators.\\n\"\n\"\\n\"\n\"## Cue-driven segmentation\\n\"\n\"The segmenter can take a list of instructions, or Cues, to use for the segmentation process, in which case only these are used to derive segment boundaries. Cues can be set through XML files or injected in input packets.\\n\"\n\"\\n\"\n\"Cue files can be specified for the entire segmenter, or per PID using `DashCue` property.\\n\"\n\"Cues are given in an XML file with a root element called <DASHCues>, with currently no attribute specified. The children are one or more <Stream> elements, with attributes:\\n\"\n\"- id: integer for stream/track/PID ID\\n\"\n\"- timescale: integer giving the units of following timestamps\\n\"\n\"- mode: if present and value is `edit`, the timestamp are in presentation time (edit list applied) otherwise they are in media time\\n\"\n\"- ts_offset: integer giving a value (in timescale) to subtract to the DTS/CTS values listed\\n\"\n\"\\nThe children of <Stream> are one or more <Cue> elements, with attributes:\\n\"\n\"- sample: integer giving the sample/frame number of a sample at which splitting shall happen\\n\"\n\"- dts: long integer giving the decoding time stamp of a sample at which splitting shall happen\\n\"\n\"- cts: long integer giving the composition / presentation time stamp of a sample at which splitting shall happen\\n\"\n\"Warning: Cues shall be listed in decoding order.\\n\"\n\"\\n\"\n\"If the `DashCue` property of a PID equals `inband`, the PID will be segmented according to the `CueStart` property of input packets.\\n\"\n\"This feature is typically combined with a list of files as input:\\n\"\n\"EX gpac -i list.m3u:sigcues -o res/live.mpd\\n\"\n\"This will load the `flist` filter in cue mode, generating continuous timelines from the sources and injecting a `CueStart` property at each new file.\\n\"\n\"\\n\"\n\"If the [-cues]() option equals `none`, the `DashCue` property of input PIDs will be ignored.\\n\"\n\"\\n\"\n\"## Manifest Generation only mode\\n\"\n\"The segmenter can be used to generate manifests from already fragmented ISOBMFF inputs using [-sigfrag]().\\n\"\n\"In this case, segment boundaries are attached to each packet starting a segment and used to drive the segmentation.\\n\"\n\"This can be used with single-track ISOBMFF sources, either single file or multi file.\\n\"\n\"For single file source:\\n\"\n\"- if onDemand [-profile]() is requested, sources have to be formatted as a DASH self-initializing media segment with the proper sidx.\\n\"\n\"- templates are disabled.\\n\"\n\"- [-sseg]() is forced for all profiles except onDemand ones.\\n\"\n\"For multi files source:\\n\"\n\"- input shall be a playlist containing the initial file followed by the ordered list of segments.\\n\"\n\"- if no [-template]() is provided, the full or main [-profile]() will be used\\n\"\n\"- if [-template]() is provided, it shall be correct: the filter will not try to guess one from the input file names and will not validate it either.\\n\"\n\"\\n\"\n\"The manifest generation-only mode supports both MPD and HLS generation.\\n\"\n\"\\n\"\n\"EX gpac -i ondemand_src.mp4 -o dash.mpd:sigfrag:profile=onDemand\\n\"\n\"This will generate a DASH manifest for onDemand Profile based on the input file.\\n\"\n\"EX gpac -i ondemand_src.mp4 -o dash.m3u8:sigfrag\\n\"\n\"This will generate a HLS manifest based on the input file.\\n\"\n\"EX gpac -i seglist.txt -o dash.mpd:sigfrag\\n\"\n\"This will generate a DASH manifest in Main Profile based on the input files.\\n\"\n\"EX gpac -i seglist.txt:Template=$XInit=init$$q1/$Number$ -o dash.mpd:sigfrag:profile=live\\n\"\n\"This will generate a DASH manifest in live Profile based on the input files. The input file will contain `init.mp4`, `q1/1.m4s`, `q1/2.m4s`...\\n\"\n\"\\n\"\n\"## Cue Generation only mode\\n\"\n\"The segmenter can be used to only generate segment boundaries from a set of inputs using [-gencues](), without generating manifests or output files.\\n\"\n\"In this mode, output PIDs are declared directly rather than redirected to media segment files.\\n\"\n\"The segmentation logic is not changed, and packets are forwarded with the same information and timing as in regular mode.\\n\"\n\"\\n\"\n\"Output PIDs are forwarded with `DashCue=inband` property, so that any subsequent dasher follows the same segmentation process (see above).\\n\"\n\"\\n\"\n\"The first packet in a segment has:\\n\"\n\"- property `FileNumber` (and, if multiple files, `FileName`) set as usual\\n\"\n\"- property `CueStart` set\\n\"\n\"- property `DFPStart=0` set if this is the first packet in a period\\n\"\n\"\\n\"\n\"This mode can be used to pre-segment the streams for later processing that must take place before final dashing.\\n\"\n\"EX gpac -i source.mp4 dasher:gencues cecrypt:cfile=roll_seg.xml -o live.mpd\\n\"\n\"This will allow the encrypter to locate dash boundaries and roll keys at segment boundaries.\\n\"\n\"EX gpac -i s1.mp4 -i s2.mp4:#CryptInfo=clear:#Period=3 -i s3.mp4:#Period=3 dasher:gencues cecrypt:cfile=roll_period.xml -o live.mpd\\n\"\n\"If the DRM file uses `keyRoll=period`, this will generate:\\n\"\n\"- first period crypted with one key\\n\"\n\"- second period clear\\n\"\n\"- third period crypted with another key\\n\"\n\"\\n\"\n\"## Forced-Template mode\\n\"\n\"When [-tpl_force]() is set, the [-template]() string is not analyzed nor modified for missing elements.\\n\"\n\"This is typically used to redirect segments to a given destination regardless of the dash profile.\\n\"\n\"EX gpac -i SRC -o null:ext=mpd:tpl_force --template=pipe://mypipe\\n\"\n\"This will trash the manifest and open `mypipe` as destination for the muxer result.\\n\"\n\"Warning: Options for segment destination cannot be set through the [-template](), global options must be used.\\n\"\n\"\\n\"\n\"## Multiplexer development considerations\\n\"\n\"Output multiplexers allowing segmented output must obey the following:\\n\"\n\"- inspect packet properties\\n\"\n\" - FileNumber: if set, indicate the start of a new DASH segment\\n\"\n\" - FileName: if set, indicate the file name. If not present, output shall be a single file. This is only set for packet carrying the `FileNumber` property, and only on one PID (usually the first) for multiplexed outputs\\n\"\n\" - IDXName: gives the optional index name. If not present, index shall be in the same file as dash segment. Only used for MPEG-2 TS for now\\n\"\n\" - EODS: property is set on packets with no payload and no timestamp to signal the end of a DASH segment. This is only used when stopping/resuming the segmentation process, in order to flush segments without dispatching an EOS (see [-subdur]() )\\n\"\n\"- for each segment done, send a downstream event on the first connected PID signaling the size of the segment and the size of its index if any\\n\"\n\"- for multiplexers with init data, send a downstream event signaling the size of the init and the size of the global index if any\\n\"\n\"- the following filter options are passed to multiplexers, which should declare them as arguments:\\n\"\n\" - noinit: disables output of init segment for the multiplexer (used to handle bitstream switching with single init in DASH)\\n\"\n\" - frag: indicates multiplexer shall use fragmented format (used for ISOBMFF mostly)\\n\"\n\" - subs_sidx=0: indicates an SIDX shall be generated - only added if not already specified by user\\n\"\n\" - xps_inband=all|no|both: indicates AVC/HEVC/... parameter sets shall be sent inband, out of band, or both\\n\"\n\" - nofragdef: indicates fragment defaults should be set in each segment rather than in init segment\\n\"\n\"\\n\"\n\"The segmenter adds the following properties to the output PIDs:\\n\"\n\"- DashMode: identifies VoD (single file with global index) or regular DASH mode used by segmenter\\n\"\n\"- DashDur: identifies target DASH segment duration - this can be used to estimate the SIDX size for example\\n\"\n\"- LLHLS: identifies LLHLS is used; the multiplexer must send fragment size events back to the dasher, and set `LLHLSFragNum` on the first packet of each fragment\\n\"\n\"- SegSync: indicates that fragments/segments must be completely flushed before sending back size events\\n\"\n\t\t\t)\n\t.private_size = sizeof(GF_DasherCtx),\n\t.args = DasherArgs,\n\t.initialize = dasher_initialize,\n\t.finalize = dasher_finalize,\n\tSETCAPS(DasherCaps),\n\t.flags = GF_FS_REG_REQUIRES_RESOLVER,\n\t.configure_pid = dasher_configure_pid,\n\t.process = dasher_process,\n\t.process_event = dasher_process_event,\n};\n\n\nconst GF_FilterRegister *dasher_register(GF_FilterSession *session)\n{\n\treturn &DasherRegister;\n}\n#else\nconst GF_FilterRegister *dasher_register(GF_FilterSession *session)\n{\n\treturn NULL;\n}\n#endif // GPAC_DISABLE_DASHER\n", "/*\n *  avilib.c\n *\n *  Copyright (C) Thomas ostreich - June 2001\n *  multiple audio track support Copyright (C) 2002 Thomas ostreich\n *\n *  Original code:\n *  Copyright (C) 1999 Rainer Johanni <Rainer@Johanni.de>\n *\n *  This file is part of transcode, a linux video stream processing tool\n *\n *  transcode is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  transcode is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License aint with this library; see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n#include <gpac/setup.h>\n\n#ifndef GPAC_DISABLE_AVILIB\n\n#include <gpac/internal/avilib.h>\n\n\n#define INFO_LIST\n\n// add a new riff chunk after XX MB\n#define NEW_RIFF_THRES (1900*1024*1024)\n\n// Maximum number of indices per stream\n#define NR_IXNN_CHUNKS 96\n\n\n#define DEBUG_ODML\n#undef DEBUG_ODML\n\n/* The following variable indicates the kind of error */\n\nint AVI_errno = 0;\n\n#define MAX_INFO_STRLEN 64\nstatic char id_str[MAX_INFO_STRLEN];\n\n#define FRAME_RATE_SCALE 1000000\n\n/*******************************************************************\n *                                                                 *\n *    Utilities for writing an AVI File                            *\n *                                                                 *\n *******************************************************************/\n\nstatic u32 avi_read(FILE *fd, char *buf, u32 len)\n{\n\tu32 r = 0;\n\n\twhile (r < len) {\n\t\ts32 n = (s32) gf_fread(buf + r, len - r, fd);\n\t\tif (n == 0) break;\n\t\tif (n < 0) return r;\n\t\tr += n;\n\t}\n\n\treturn r;\n}\n\nstatic u32 avi_write (FILE *fd, char *buf, u32 len)\n{\n\tu32 r = 0;\n\n\twhile (r < len) {\n\t\ts32 n = (u32) gf_fwrite (buf + r, len - r, fd);\n\t\tif (n < 0)\n\t\t\treturn n;\n\n\t\tr += n;\n\t}\n\treturn r;\n}\n\n/* HEADERBYTES: The number of bytes to reserve for the header */\n\n#define HEADERBYTES 2048\n\n/* AVI_MAX_LEN: The maximum length of an AVI file, we stay a bit below\n    the 2GB limit (Remember: 2*10^9 is smaller than 2 GB) */\n\n#define AVI_MAX_LEN (UINT_MAX-(1<<20)*16-HEADERBYTES)\n\n#define PAD_EVEN(x) ( ((x)+1) & ~1 )\n\n\n/* Copy n into dst as a 4 or 2 byte, little endian number.\n   Should also work on big endian machines */\n\nstatic void long2str(unsigned char *dst, s32 n)\n{\n\tdst[0] = (n    )&0xff;\n\tdst[1] = (n>> 8)&0xff;\n\tdst[2] = (n>>16)&0xff;\n\tdst[3] = (n>>24)&0xff;\n}\n\n#ifdef WORDS_BIGENDIAN\nstatic void short2str(unsigned char *dst, s32 n)\n{\n\tdst[0] = (n    )&0xff;\n\tdst[1] = (n>> 8)&0xff;\n}\n#endif\n\n/* Convert a string of 4 or 2 bytes to a number,\n   also working on big endian machines */\n\nstatic u64 str2ullong(unsigned char *str)\n{\n\tu64 r = ((u32)str[0] | ((u32)str[1]<<8) | ((u32)str[2]<<16) | ((u32)str[3]<<24));\n\tu64 s = ((u32)str[4] | ((u32)str[5]<<8) | ((u32)str[6]<<16) | ((u32)str[7]<<24));\n#ifdef __GNUC__\n\treturn ((s<<32)&0xffffffff00000000ULL)|(r&0xffffffff);\n#else\n\treturn ((s<<32)&0xffffffff00000000)|(r&0xffffffff);\n#endif\n}\n\nstatic u32 str2ulong(unsigned char *str)\n{\n\treturn ( (u32)str[0] | ((u32)str[1]<<8) | ((u32)str[2]<<16) | ((u32)str[3]<<24) );\n}\nstatic u32 str2ushort(unsigned char *str)\n{\n\treturn ( (u32)str[0] | ((u32)str[1]<<8) );\n}\n\n// bit 31 denotes a keyframe\nstatic u32 str2ulong_len (unsigned char *str)\n{\n\treturn str2ulong(str) & 0x7fffffff;\n}\n\n\n// if bit 31 is 0, its a keyframe\nstatic u32 str2ulong_key (unsigned char *str)\n{\n\tu32 c = str2ulong(str);\n\tc &= 0x80000000;\n\tif (c == 0) return 0x10;\n\telse return 0;\n}\n\n/* Calculate audio sample size from number of bits and number of channels.\n   This may have to be adjusted for eg. 12 bits and stereo */\n\nstatic int avi_sampsize(avi_t *AVI, int j)\n{\n\tint s;\n\ts = ((AVI->track[j].a_bits+7)/8)*AVI->track[j].a_chans;\n\t//   if(s==0) s=1; /* avoid possible zero divisions */\n\tif(s<4) s=4; /* avoid possible zero divisions */\n\treturn s;\n}\n\n/* Add a chunk (=tag and data) to the AVI file,\n   returns -1 on write error, 0 on success */\n\nstatic int avi_add_chunk(avi_t *AVI, unsigned char *tag, unsigned char *data, u32 length)\n{\n\tunsigned char c[8];\n\tchar p=0;\n\n\t/* Copy tag and length int c, so that we need only 1 write system call\n\t   for these two values */\n\n\tmemcpy(c,tag,4);\n\tlong2str(c+4,length);\n\n\t/* Output tag, length and data, restore previous position\n\t   if the write fails */\n\n\tif( avi_write(AVI->fdes,(char *)c,8) != 8 ||\n\t        avi_write(AVI->fdes,(char *)data,length) != length ||\n\t        avi_write(AVI->fdes,&p,length&1) != (length&1)) // if len is uneven, write a pad byte\n\t{\n\t\tgf_fseek(AVI->fdes,AVI->pos,SEEK_SET);\n\t\tAVI_errno = AVI_ERR_WRITE;\n\t\treturn -1;\n\t}\n\n\t/* Update file position */\n\n\tAVI->pos += 8 + PAD_EVEN(length);\n\n\t//GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] pos=%lu %s\\n\", AVI->pos, tag));\n\n\treturn 0;\n}\n\n#define OUTD(n) long2str((unsigned char*) (ix00+bl),(s32)n); bl+=4\n#define OUTW(n) ix00[bl] = (n)&0xff; ix00[bl+1] = (n>>8)&0xff; bl+=2\n#define OUTC(n) ix00[bl] = (n)&0xff; bl+=1\n#define OUTS(s) memcpy(ix00+bl,s,4); bl+=4\n\n// this does the physical writeout of the ix## structure\nstatic int avi_ixnn_entry(avi_t *AVI, avistdindex_chunk *ch, avisuperindex_entry *en)\n{\n\tint bl;\n\tu32 k;\n\tunsigned int max = ch->nEntriesInUse * sizeof (u32) * ch->wLongsPerEntry + 24; // header\n\tchar *ix00 = (char *)gf_malloc (max);\n\tchar dfcc[5];\n\tmemcpy (dfcc, ch->fcc, 4);\n\tdfcc[4] = 0;\n\n\tbl = 0;\n\n\tif (en) {\n\t\ten->qwOffset = AVI->pos;\n\t\ten->dwSize = max;\n\t\t//en->dwDuration = ch->nEntriesInUse -1; // NUMBER OF stream ticks == frames for video/samples for audio\n\t}\n\n#ifdef DEBUG_ODML\n\t//GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] ODML Write %s: Entries %ld size %d \\n\", dfcc, ch->nEntriesInUse, max));\n#endif\n\n\t//OUTS(ch->fcc);\n\t//OUTD(max);\n\tOUTW(ch->wLongsPerEntry);\n\tOUTC(ch->bIndexSubType);\n\tOUTC(ch->bIndexType);\n\tOUTD(ch->nEntriesInUse);\n\tOUTS(ch->dwChunkId);\n\tOUTD(ch->qwBaseOffset&0xffffffff);\n\tOUTD((ch->qwBaseOffset>>32)&0xffffffff);\n\tOUTD(ch->dwReserved3);\n\n\tfor (k = 0; k < ch->nEntriesInUse; k++) {\n\t\tOUTD(ch->aIndex[k].dwOffset);\n\t\tOUTD(ch->aIndex[k].dwSize);\n\n\t}\n\tavi_add_chunk (AVI, (unsigned char*)ch->fcc, (unsigned char*)ix00, max);\n\n\tgf_free(ix00);\n\n\treturn 0;\n}\n#undef OUTS\n#undef OUTW\n#undef OUTD\n#undef OUTC\n\n// inits a super index structure including its enclosed stdindex\nstatic int avi_init_super_index(avi_t *AVI, unsigned char *idxtag, avisuperindex_chunk **si)\n{\n\tint k;\n\n\tavisuperindex_chunk *sil = NULL;\n\n\tif ((sil = (avisuperindex_chunk *) gf_malloc (sizeof (avisuperindex_chunk))) == NULL) {\n\t\tAVI_errno = AVI_ERR_NO_MEM;\n\t\treturn -1;\n\t}\n\tmemcpy (sil->fcc, \"indx\", 4);\n\tsil->dwSize = 0; // size of this chunk\n\tsil->wLongsPerEntry = 4;\n\tsil->bIndexSubType = 0;\n\tsil->bIndexType = AVI_INDEX_OF_INDEXES;\n\tsil->nEntriesInUse = 0; // none are in use\n\tmemcpy (sil->dwChunkId, idxtag, 4);\n\tmemset (sil->dwReserved, 0, sizeof (sil->dwReserved));\n\n\t// NR_IXNN_CHUNKS == allow 32 indices which means 32 GB files -- arbitrary\n\tsil->aIndex = (avisuperindex_entry *) gf_malloc (sil->wLongsPerEntry * NR_IXNN_CHUNKS * sizeof (void*));\n\tif (!sil->aIndex) {\n\t\tAVI_errno = AVI_ERR_NO_MEM;\n\t\treturn -1;\n\t}\n\tmemset (sil->aIndex, 0, sil->wLongsPerEntry * NR_IXNN_CHUNKS * sizeof (u32));\n\n\tsil->stdindex = (avistdindex_chunk **)gf_malloc (NR_IXNN_CHUNKS * sizeof (avistdindex_chunk *));\n\tif (!sil->stdindex) {\n\t\tAVI_errno = AVI_ERR_NO_MEM;\n\t\treturn -1;\n\t}\n\tfor (k = 0; k < NR_IXNN_CHUNKS; k++) {\n\t\tsil->stdindex[k] = (avistdindex_chunk *) gf_malloc (sizeof (avistdindex_chunk));\n\t\t// gets rewritten later\n\t\tsil->stdindex[k]->qwBaseOffset = (u64)k * AVI->new_riff_threshold;\n\t\tsil->stdindex[k]->aIndex = NULL;\n\t}\n\n\t*si = sil;\n\n\treturn 0;\n}\n\n// fills an alloc'ed stdindex structure and mallocs some entries for the actual chunks\nstatic int avi_add_std_index(avi_t *AVI, unsigned char *idxtag, unsigned char *strtag,\n                             avistdindex_chunk *stdil)\n{\n\n\tmemcpy (stdil->fcc, idxtag, 4);\n\tstdil->dwSize = 4096;\n\tstdil->wLongsPerEntry = 2; //sizeof(avistdindex_entry)/sizeof(u32);\n\tstdil->bIndexSubType = 0;\n\tstdil->bIndexType = AVI_INDEX_OF_CHUNKS;\n\tstdil->nEntriesInUse = 0;\n\n\t// cp 00db ChunkId\n\tmemcpy(stdil->dwChunkId, strtag, 4);\n\n\t//stdil->qwBaseOffset = AVI->video_superindex->aIndex[ cur_std_idx ]->qwOffset;\n\n\tstdil->aIndex = (avistdindex_entry *)gf_malloc(stdil->dwSize * sizeof (u32) * stdil->wLongsPerEntry);\n\n\tif (!stdil->aIndex) {\n\t\tAVI_errno = AVI_ERR_NO_MEM;\n\t\treturn -1;\n\t}\n\n\n\treturn 0;\n}\n\nstatic int avi_add_odml_index_entry_core(avi_t *AVI, int flags, u64 pos, unsigned int len, avistdindex_chunk *si)\n{\n\tu32 cur_chunk_idx;\n\t// put new chunk into index\n\tsi->nEntriesInUse++;\n\tcur_chunk_idx = si->nEntriesInUse-1;\n\n\t// need to fetch more memory\n\tif (cur_chunk_idx >= si->dwSize) {\n\t\tsi->dwSize += 4096;\n\t\tsi->aIndex = (avistdindex_entry *)gf_realloc ( si->aIndex, si->dwSize * sizeof (u32) * si->wLongsPerEntry);\n\t}\n\n\tif(len>AVI->max_len) AVI->max_len=len;\n\n\t// if bit 31 is set, it is NOT a keyframe\n\tif (flags != 0x10) {\n\t\tlen |= 0x80000000;\n\t}\n\n\tsi->aIndex [ cur_chunk_idx ].dwSize = len;\n\tsi->aIndex [ cur_chunk_idx ].dwOffset = (u32) (pos - si->qwBaseOffset + 8);\n\n\t//GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] ODML: POS: 0x%lX\\n\", si->aIndex [ cur_chunk_idx ].dwOffset));\n\n\treturn 0;\n}\n\nstatic int avi_add_odml_index_entry(avi_t *AVI, unsigned char *tag, int flags, u64 pos, unsigned int len)\n{\n\tchar fcc[5];\n\n\tint audio = (strchr ((char*)tag, 'w')?1:0);\n\tint video = !audio;\n\n\tunsigned int cur_std_idx;\n\tu32 audtr;\n\ts64 towrite = 0;\n\n\tif (video) {\n\n\t\tif (!AVI->video_superindex) {\n\t\t\tif (avi_init_super_index(AVI, (unsigned char *)\"ix00\", &AVI->video_superindex) < 0) return -1;\n\t\t\tAVI->video_superindex->nEntriesInUse++;\n\t\t\tcur_std_idx = AVI->video_superindex->nEntriesInUse-1;\n\n\t\t\tif (avi_add_std_index (AVI, (unsigned char *)\"ix00\", (unsigned char *)\"00db\", AVI->video_superindex->stdindex[ cur_std_idx ]) < 0)\n\t\t\t\treturn -1;\n\t\t} // init\n\n\t} // video\n\n\tif (audio) {\n\n\t\tfcc[0] = 'i';\n\t\tfcc[1] = 'x';\n\t\tfcc[2] = tag[0];\n\t\tfcc[3] = tag[1];\n\t\tfcc[4] = '\\0';\n\t\tif (!AVI->track[AVI->aptr].audio_superindex) {\n\n#ifdef DEBUG_ODML\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] ODML: fcc = %s\\n\", fcc));\n#endif\n\t\t\tif (avi_init_super_index(AVI, (unsigned char *)fcc, &AVI->track[AVI->aptr].audio_superindex) < 0) return -1;\n\n\n\t\t\tAVI->track[AVI->aptr].audio_superindex->nEntriesInUse++;\n\n\t\t\tsprintf(fcc, \"ix%02d\", AVI->aptr+1);\n\t\t\tif (avi_add_std_index (AVI, (unsigned char *)fcc, tag, AVI->track[AVI->aptr].audio_superindex->stdindex[\n\t\t\t                           AVI->track[AVI->aptr].audio_superindex->nEntriesInUse - 1 ]) < 0\n\t\t\t   ) return -1;\n\t\t} // init\n\n\t}\n\n\ttowrite = 0;\n\tif (AVI->video_superindex) {\n\n\t\tcur_std_idx = AVI->video_superindex->nEntriesInUse-1;\n\t\ttowrite += AVI->video_superindex->stdindex[cur_std_idx]->nEntriesInUse*8\n\t\t           + 4+4+2+1+1+4+4+8+4;\n\t\tif (cur_std_idx == 0) {\n\t\t\ttowrite += AVI->n_idx*16 + 8;\n\t\t\ttowrite += HEADERBYTES;\n\t\t}\n\t}\n\n\tfor (audtr=0; audtr<AVI->anum; audtr++) {\n\t\tif (AVI->track[audtr].audio_superindex) {\n\t\t\tcur_std_idx = AVI->track[audtr].audio_superindex->nEntriesInUse-1;\n\t\t\ttowrite += AVI->track[audtr].audio_superindex->stdindex[cur_std_idx]->nEntriesInUse*8\n\t\t\t           + 4+4+2+1+1+4+4+8+4;\n\t\t}\n\t}\n\ttowrite += len + (len&1) + 8;\n\n\t//GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] ODML: towrite = 0x%llX = %\"LLD\"\\n\", towrite, towrite));\n\n\tif (AVI->video_superindex &&\n\t        (s64)(AVI->pos+towrite) > (s64)((s64) AVI->new_riff_threshold*AVI->video_superindex->nEntriesInUse)) {\n\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] Adding a new RIFF chunk: %d\\n\", AVI->video_superindex->nEntriesInUse));\n\n\t\t// rotate ALL indices\n\t\tAVI->video_superindex->nEntriesInUse++;\n\t\tcur_std_idx = AVI->video_superindex->nEntriesInUse-1;\n\n\t\tif (AVI->video_superindex->nEntriesInUse > NR_IXNN_CHUNKS) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[avilib] Internal error in avilib - redefine NR_IXNN_CHUNKS\\n\"));\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] cur_std_idx=%d NR_IXNN_CHUNKS=%d\"\n\t\t\t                                        \"POS=%\"LLD\" towrite=%\"LLD\"\\n\",\n\t\t\t                                        cur_std_idx,NR_IXNN_CHUNKS, AVI->pos, towrite));\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (avi_add_std_index (AVI, (unsigned char *)\"ix00\", (unsigned char *)\"00db\", AVI->video_superindex->stdindex[ cur_std_idx ]) < 0)\n\t\t\treturn -1;\n\n\t\tfor (audtr = 0; audtr < AVI->anum; audtr++) {\n\t\t\tchar aud[5];\n\t\t\tif (!AVI->track[audtr].audio_superindex) {\n\t\t\t\t// not initialized -> no index\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tAVI->track[audtr].audio_superindex->nEntriesInUse++;\n\n\t\t\tsprintf(fcc, \"ix%02d\", audtr+1);\n\t\t\tsprintf(aud, \"0%01dwb\", audtr+1);\n\t\t\tif (avi_add_std_index (AVI, (unsigned char *)fcc, (unsigned char *)aud, AVI->track[audtr].audio_superindex->stdindex[\n\t\t\t                           AVI->track[audtr].audio_superindex->nEntriesInUse - 1 ]) < 0\n\t\t\t   ) return -1;\n\t\t}\n\n\t\t// write the new riff;\n\t\tif (cur_std_idx > 0) {\n\n\t\t\t// dump the _previous_ == already finished index\n\t\t\tavi_ixnn_entry (AVI, AVI->video_superindex->stdindex[cur_std_idx - 1],\n\t\t\t                &AVI->video_superindex->aIndex[cur_std_idx - 1]);\n\t\t\tAVI->video_superindex->aIndex[cur_std_idx - 1].dwDuration =\n\t\t\t    AVI->video_superindex->stdindex[cur_std_idx - 1]->nEntriesInUse - 1;\n\n\t\t\tfor (audtr = 0; audtr < AVI->anum; audtr++) {\n\n\t\t\t\tif (!AVI->track[audtr].audio_superindex) {\n\t\t\t\t\t// not initialized -> no index\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tavi_ixnn_entry (AVI, AVI->track[audtr].audio_superindex->stdindex[cur_std_idx - 1],\n\t\t\t\t                &AVI->track[audtr].audio_superindex->aIndex[cur_std_idx - 1]);\n\n\t\t\t\tAVI->track[audtr].audio_superindex->aIndex[cur_std_idx - 1].dwDuration =\n\t\t\t\t    AVI->track[audtr].audio_superindex->stdindex[cur_std_idx - 1]->nEntriesInUse - 1;\n\t\t\t\tif (AVI->track[audtr].a_fmt == 0x1) {\n\t\t\t\t\tAVI->track[audtr].audio_superindex->aIndex[cur_std_idx - 1].dwDuration *=\n\t\t\t\t\t    AVI->track[audtr].a_bits*AVI->track[audtr].a_rate*AVI->track[audtr].a_chans/800;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// XXX: dump idx1 structure\n\t\t\tif (cur_std_idx == 1) {\n\t\t\t\tavi_add_chunk(AVI, (unsigned char *)\"idx1\", (unsigned char *)AVI->idx, AVI->n_idx*16);\n\t\t\t\t// qwBaseOffset will contain the start of the second riff chunk\n\t\t\t}\n\t\t\t// Fix the Offsets later at closing time\n\t\t\tavi_add_chunk(AVI, (unsigned char *)\"RIFF\", (unsigned char *)\"AVIXLIST\\0\\0\\0\\0movi\", 16);\n\n\t\t\tAVI->video_superindex->stdindex[ cur_std_idx ]->qwBaseOffset = AVI->pos -16 -8;\n#ifdef DEBUG_ODML\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] ODML: RIFF No.%02d at Offset 0x%llX\\n\", cur_std_idx, AVI->pos -16 -8));\n#endif\n\n\t\t\tfor (audtr = 0; audtr < AVI->anum; audtr++) {\n\t\t\t\tif (AVI->track[audtr].audio_superindex)\n\t\t\t\t\tAVI->track[audtr].audio_superindex->stdindex[ cur_std_idx ]->qwBaseOffset =\n\t\t\t\t\t    AVI->pos -16 -8;\n\n\t\t\t}\n\n\t\t\t// now we can be sure\n\t\t\tAVI->is_opendml++;\n\t\t}\n\n\t}\n\n\n\tif (video) {\n\t\tavi_add_odml_index_entry_core(AVI, flags, AVI->pos, len,\n\t\t                              AVI->video_superindex->stdindex[ AVI->video_superindex->nEntriesInUse-1 ]);\n\n\t\tAVI->total_frames++;\n\t} // video\n\n\tif (audio) {\n\t\tavi_add_odml_index_entry_core(AVI, flags, AVI->pos, len,\n\t\t                              AVI->track[AVI->aptr].audio_superindex->stdindex[\n\t\t                                  AVI->track[AVI->aptr].audio_superindex->nEntriesInUse-1 ]);\n\t}\n\n\n\treturn 0;\n}\n\n// #undef NR_IXNN_CHUNKS\n\nstatic int avi_add_index_entry(avi_t *AVI, unsigned char *tag, int flags, u64 pos, u64 len)\n{\n\tif(AVI->n_idx>=AVI->max_idx) {\n\t\tvoid *ptr = gf_realloc((void *)AVI->idx,(AVI->max_idx+4096)*16);\n\n\t\tif(ptr == 0) {\n\t\t\tAVI_errno = AVI_ERR_NO_MEM;\n\t\t\treturn -1;\n\t\t}\n\t\tAVI->max_idx += 4096;\n\t\tAVI->idx = (unsigned char((*)[16]) ) ptr;\n\t}\n\n\t/* Add index entry */\n\n\t//   GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] INDEX %s %ld %lu %lu\\n\", tag, flags, pos, len));\n\n\tmemcpy(AVI->idx[AVI->n_idx],tag,4);\n\tlong2str(AVI->idx[AVI->n_idx]+ 4,flags);\n\tlong2str(AVI->idx[AVI->n_idx]+ 8, (s32) pos);\n\tlong2str(AVI->idx[AVI->n_idx]+12, (s32) len);\n\n\t/* Update counter */\n\n\tAVI->n_idx++;\n\n\tif(len>AVI->max_len) AVI->max_len=(u32) len;\n\n\treturn 0;\n}\n\n#if 0\n/* Returns 1 if more audio is in that video junk */\nint AVI_can_read_audio(avi_t *AVI)\n{\n\tif(AVI->mode==AVI_MODE_WRITE) {\n\t\treturn -1;\n\t}\n\tif(!AVI->video_index)         {\n\t\treturn -1;\n\t}\n\tif(!AVI->track[AVI->aptr].audio_index)         {\n\t\treturn -1;\n\t}\n\n\t// is it -1? the last ones got left out --tibit\n\t//if (AVI->track[AVI->aptr].audio_posc>=AVI->track[AVI->aptr].audio_chunks-1) {\n\tif (AVI->track[AVI->aptr].audio_posc>=AVI->track[AVI->aptr].audio_chunks) {\n\t\treturn 0;\n\t}\n\n\tif (AVI->video_pos >= AVI->video_frames) return 1;\n\n\tif (AVI->track[AVI->aptr].audio_index[AVI->track[AVI->aptr].audio_posc].pos < AVI->video_index[AVI->video_pos].pos) return 1;\n\telse return 0;\n}\n#endif\n\n/*\n   AVI_open_output_file: Open an AVI File and write a bunch\n                         of zero bytes as space for the header.\n\n   returns a pointer to avi_t on success, a zero pointer on error\n*/\n\nGF_EXPORT\navi_t* AVI_open_output_file(char * filename, u64 opendml_threshold)\n{\n\tavi_t *AVI;\n\tint i;\n\n\tunsigned char AVI_header[HEADERBYTES];\n\n\t/* Allocate the avi_t struct and zero it */\n\n\tAVI = (avi_t *) gf_malloc(sizeof(avi_t));\n\tif(AVI==0)\n\t{\n\t\tAVI_errno = AVI_ERR_NO_MEM;\n\t\treturn 0;\n\t}\n\tmemset((void *)AVI,0,sizeof(avi_t));\n\n\tAVI->fdes = gf_fopen(filename, \"w+b\");\n\tif (!AVI->fdes )\n\t{\n\t\tAVI_errno = AVI_ERR_OPEN;\n\t\tgf_free(AVI);\n\t\treturn 0;\n\t}\n\n\t/* Write out HEADERBYTES bytes, the header will go here\n\t   when we are finished with writing */\n\n\tfor (i=0; i<HEADERBYTES; i++) AVI_header[i] = 0;\n\ti = avi_write(AVI->fdes,(char *)AVI_header,HEADERBYTES);\n\tif (i != HEADERBYTES)\n\t{\n\t\tgf_fclose(AVI->fdes);\n\t\tAVI_errno = AVI_ERR_WRITE;\n\t\tgf_free(AVI);\n\t\treturn 0;\n\t}\n\n\tAVI->pos  = HEADERBYTES;\n\tAVI->mode = AVI_MODE_WRITE; /* open for writing */\n\tif (opendml_threshold)\n\t\tAVI->new_riff_threshold = opendml_threshold;\n\telse\n\t\tAVI->new_riff_threshold = (1900*1024*1024);\n\n\t//init\n\tAVI->anum = 0;\n\tAVI->aptr = 0;\n\n\treturn AVI;\n}\n\nGF_EXPORT\nvoid AVI_set_video(avi_t *AVI, int width, int height, double fps, char *compressor)\n{\n\t/* may only be called if file is open for writing */\n\n\tif(AVI->mode==AVI_MODE_READ) return;\n\n\tAVI->width  = width;\n\tAVI->height = height;\n\tAVI->fps    = fps;\n\n\tif(strncmp(compressor, \"RGB\", 3)==0) {\n\t\tmemset(AVI->compressor, 0, 4);\n\t} else {\n\t\tmemcpy(AVI->compressor,compressor,4);\n\t}\n\n\tAVI->compressor[4] = 0;\n\n\tavi_update_header(AVI);\n}\n\nGF_EXPORT\nvoid AVI_set_audio(avi_t *AVI, int channels, int rate, int bits, int format, int mp3rate)\n{\n\t/* may only be called if file is open for writing */\n\n\tif(AVI->mode==AVI_MODE_READ) return;\n\n\t//inc audio tracks\n\tAVI->aptr=AVI->anum;\n\t++AVI->anum;\n\n\tif(AVI->anum > AVI_MAX_TRACKS) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[avilib] error - only %d audio tracks supported\\n\", AVI_MAX_TRACKS));\n\t\texit(1);\n\t}\n\n\tAVI->track[AVI->aptr].a_chans = channels;\n\tAVI->track[AVI->aptr].a_rate  = rate;\n\tAVI->track[AVI->aptr].a_bits  = bits;\n\tAVI->track[AVI->aptr].a_fmt   = format;\n\tAVI->track[AVI->aptr].mp3rate = mp3rate;\n\n\tavi_update_header(AVI);\n}\n\n#define OUT4CC(s) \\\n   if(nhb<=HEADERBYTES-4) memcpy(AVI_header+nhb,s,4); \\\n   nhb += 4\n\n#define OUTLONG(n) \\\n   if(nhb<=HEADERBYTES-4) long2str(AVI_header+nhb, (s32)(n)); \\\n   nhb += 4\n\n#define OUTSHRT(n) \\\n   if(nhb<=HEADERBYTES-2) { \\\n      AVI_header[nhb  ] = (u8) ((n   )&0xff); \\\n      AVI_header[nhb+1] = (u8) ((n>>8)&0xff); \\\n   } \\\n   nhb += 2\n\n#define OUTCHR(n) \\\n   if(nhb<=HEADERBYTES-1) { \\\n      AVI_header[nhb  ] = (n   )&0xff; \\\n   } \\\n   nhb += 1\n\n#define OUTMEM(d, s) \\\n   { \\\n     u32 s_ = (u32) (s); \\\n     if(nhb + s_ <= HEADERBYTES) \\\n        memcpy(AVI_header+nhb, (d), s_); \\\n     nhb += s_; \\\n   }\n\n\n//ThOe write preliminary AVI file header: 0 frames, max vid/aud size\nint avi_update_header(avi_t *AVI)\n{\n\tint njunk, ms_per_frame, frate, flag;\n\tint movi_len, hdrl_start, strl_start;\n\tu32 j;\n\tunsigned char AVI_header[HEADERBYTES];\n\tu32 nhb;\n\tunsigned int xd_size, xd_size_align2;\n\n\t//assume max size\n\tmovi_len = AVI_MAX_LEN - HEADERBYTES + 4;\n\n\t//assume index will be written\n//\tint hasIndex=1;\n\n\tif(AVI->fps < 0.001) {\n\t\tfrate=0;\n\t\tms_per_frame=0;\n\t} else {\n\t\tfrate = (int) (FRAME_RATE_SCALE*AVI->fps + 0.5);\n\t\tms_per_frame=(int) (1000000/AVI->fps + 0.5);\n\t}\n\n\t/* Prepare the file header */\n\n\tnhb = 0;\n\n\t/* The RIFF header */\n\n\tOUT4CC (\"RIFF\");\n\tOUTLONG(movi_len);    // assume max size\n\tOUT4CC (\"AVI \");\n\n\t/* Start the header list */\n\n\tOUT4CC (\"LIST\");\n\tOUTLONG(0);        /* Length of list in bytes, don't know yet */\n\thdrl_start = nhb;  /* Store start position */\n\tOUT4CC (\"hdrl\");\n\n\t/* The main AVI header */\n\n\t/* The Flags in AVI File header */\n\n#define AVIF_HASINDEX           0x00000010      /* Index at end of file */\n#define AVIF_MUSTUSEINDEX       0x00000020\n#define AVIF_ISINTERLEAVED      0x00000100\n#define AVIF_TRUSTCKTYPE        0x00000800      /* Use CKType to find key frames */\n#define AVIF_WASCAPTUREFILE     0x00010000\n#define AVIF_COPYRIGHTED        0x00020000\n\n\tOUT4CC (\"avih\");\n\tOUTLONG(56);                 /* # of bytes to follow */\n\tOUTLONG(ms_per_frame);       /* Microseconds per frame */\n\t//ThOe ->0\n\t//   OUTLONG(10000000);           /* MaxBytesPerSec, I hope this will never be used */\n\tOUTLONG(0);\n\tOUTLONG(0);                  /* PaddingGranularity (whatever that might be) */\n\t/* Other sources call it 'reserved' */\n\tflag = AVIF_ISINTERLEAVED;\n\t//if (hasIndex)\n\t\tflag |= AVIF_HASINDEX;\n\tif (/*hasIndex && */AVI->must_use_index)\n\t\tflag |= AVIF_MUSTUSEINDEX;\n\tOUTLONG(flag);               /* Flags */\n\tOUTLONG(0);                  // no frames yet\n\tOUTLONG(0);                  /* InitialFrames */\n\n\tOUTLONG(AVI->anum+1);\n\n\tOUTLONG(0);                  /* SuggestedBufferSize */\n\tOUTLONG(AVI->width);         /* Width */\n\tOUTLONG(AVI->height);        /* Height */\n\t/* MS calls the following 'reserved': */\n\tOUTLONG(0);                  /* TimeScale:  Unit used to measure time */\n\tOUTLONG(0);                  /* DataRate:   Data rate of playback     */\n\tOUTLONG(0);                  /* StartTime:  Starting time of AVI data */\n\tOUTLONG(0);                  /* DataLength: Size of AVI data chunk    */\n\n\n\t/* Start the video stream list ---------------------------------- */\n\n\tOUT4CC (\"LIST\");\n\tOUTLONG(0);        /* Length of list in bytes, don't know yet */\n\tstrl_start = nhb;  /* Store start position */\n\tOUT4CC (\"strl\");\n\n\t/* The video stream header */\n\n\tOUT4CC (\"strh\");\n\tOUTLONG(56);                 /* # of bytes to follow */\n\tOUT4CC (\"vids\");             /* Type */\n\tOUT4CC (AVI->compressor);    /* Handler */\n\tOUTLONG(0);                  /* Flags */\n\tOUTLONG(0);                  /* Reserved, MS says: wPriority, wLanguage */\n\tOUTLONG(0);                  /* InitialFrames */\n\tOUTLONG(FRAME_RATE_SCALE);              /* Scale */\n\tOUTLONG(frate);              /* Rate: Rate/Scale == samples/second */\n\tOUTLONG(0);                  /* Start */\n\tOUTLONG(0);                  // no frames yet\n\tOUTLONG(0);                  /* SuggestedBufferSize */\n\tOUTLONG(-1);                 /* Quality */\n\tOUTLONG(0);                  /* SampleSize */\n\tOUTLONG(0);                  /* Frame */\n\tOUTLONG(0);                  /* Frame */\n\t//   OUTLONG(0);                  /* Frame */\n\t//OUTLONG(0);                  /* Frame */\n\n\t/* The video stream format */\n\n\txd_size        = AVI->extradata_size;\n\txd_size_align2 = (AVI->extradata_size+1) & ~1;\n\n\tOUT4CC (\"strf\");\n\tOUTLONG(40 + xd_size_align2);/* # of bytes to follow */\n\tOUTLONG(40 + xd_size);\t/* Size */\n\tOUTLONG(AVI->width);         /* Width */\n\tOUTLONG(AVI->height);        /* Height */\n\tOUTSHRT(1);\n\tOUTSHRT(24);     /* Planes, Count */\n\tOUT4CC (AVI->compressor);    /* Compression */\n\t// ThOe (*3)\n\tOUTLONG(AVI->width*AVI->height*3);  /* SizeImage (in bytes?) */\n\tOUTLONG(0);                  /* XPelsPerMeter */\n\tOUTLONG(0);                  /* YPelsPerMeter */\n\tOUTLONG(0);                  /* ClrUsed: Number of colors used */\n\tOUTLONG(0);                  /* ClrImportant: Number of colors important */\n\n\t// write extradata\n\tif (xd_size > 0 && AVI->extradata) {\n\t\tOUTMEM(AVI->extradata, xd_size);\n\t\tif (xd_size != xd_size_align2) {\n\t\t\tOUTCHR(0);\n\t\t}\n\t}\n\n\t/* Finish stream list, i.e. put number of bytes in the list to proper pos */\n\n\tlong2str(AVI_header+strl_start-4,nhb-strl_start);\n\n\n\t/* Start the audio stream list ---------------------------------- */\n\n\tfor(j=0; j<AVI->anum; ++j) {\n\t\tint sampsize = avi_sampsize(AVI, j);\n\n\t\tOUT4CC (\"LIST\");\n\t\tOUTLONG(0);        /* Length of list in bytes, don't know yet */\n\t\tstrl_start = nhb;  /* Store start position */\n\t\tOUT4CC (\"strl\");\n\n\t\t/* The audio stream header */\n\n\t\tOUT4CC (\"strh\");\n\t\tOUTLONG(56);            /* # of bytes to follow */\n\t\tOUT4CC (\"auds\");\n\n\t\t// -----------\n\t\t// ThOe\n\t\tOUTLONG(0);             /* Format (Optionally) */\n\t\t// -----------\n\n\t\tOUTLONG(0);             /* Flags */\n\t\tOUTLONG(0);             /* Reserved, MS says: wPriority, wLanguage */\n\t\tOUTLONG(0);             /* InitialFrames */\n\n\t\t// ThOe /4\n\t\tOUTLONG(sampsize/4);      /* Scale */\n\t\tOUTLONG(1000*AVI->track[j].mp3rate/8);\n\t\tOUTLONG(0);             /* Start */\n\t\tOUTLONG(4*AVI->track[j].audio_bytes/sampsize);   /* Length */\n\t\tOUTLONG(0);             /* SuggestedBufferSize */\n\t\tOUTLONG(-1);            /* Quality */\n\n\t\t// ThOe /4\n\t\tOUTLONG(sampsize/4);    /* SampleSize */\n\n\t\tOUTLONG(0);             /* Frame */\n\t\tOUTLONG(0);             /* Frame */\n\t\t//       OUTLONG(0);             /* Frame */\n\t\t//OUTLONG(0);             /* Frame */\n\n\t\t/* The audio stream format */\n\n\t\tOUT4CC (\"strf\");\n\t\tOUTLONG(16);                   /* # of bytes to follow */\n\t\tOUTSHRT(AVI->track[j].a_fmt);           /* Format */\n\t\tOUTSHRT(AVI->track[j].a_chans);         /* Number of channels */\n\t\tOUTLONG(AVI->track[j].a_rate);          /* SamplesPerSec */\n\t\t// ThOe\n\t\tOUTLONG(1000*AVI->track[j].mp3rate/8);\n\t\t//ThOe (/4)\n\n\t\tOUTSHRT(sampsize/4);           /* BlockAlign */\n\n\n\t\tOUTSHRT(AVI->track[j].a_bits);          /* BitsPerSample */\n\n\t\t/* Finish stream list, i.e. put number of bytes in the list to proper pos */\n\n\t\tlong2str(AVI_header+strl_start-4,nhb-strl_start);\n\t}\n\n\t/* Finish header list */\n\n\tlong2str(AVI_header+hdrl_start-4,nhb-hdrl_start);\n\n\n\t/* Calculate the needed amount of junk bytes, output junk */\n\n\tnjunk = HEADERBYTES - nhb - 8 - 12;\n\n\t/* Safety first: if njunk <= 0, somebody has played with\n\t   HEADERBYTES without knowing what (s)he did.\n\t   This is a fatal error */\n\n\tif(njunk<=0)\n\t{\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[avilib] AVI_close_output_file: # of header bytes too small\\n\"));\n\t\texit(1);\n\t}\n\n\tOUT4CC (\"JUNK\");\n\tOUTLONG(njunk);\n\tmemset(AVI_header+nhb,0,njunk);\n\n\tnhb += njunk;\n\n\t/* Start the movi list */\n\n\tOUT4CC (\"LIST\");\n\tOUTLONG(movi_len); /* Length of list in bytes */\n\tOUT4CC (\"movi\");\n\n\t/* Output the header, truncate the file to the number of bytes\n\t   actually written, report an error if someting goes wrong */\n\n\tif ( (gf_fseek(AVI->fdes, 0, SEEK_SET) ==(u64)-1) ||\n\t        avi_write(AVI->fdes,(char *)AVI_header,HEADERBYTES)!=HEADERBYTES ||\n\t        (gf_fseek(AVI->fdes,AVI->pos,SEEK_SET)==(u64)-1)\n\t   ) {\n\t\tAVI_errno = AVI_ERR_CLOSE;\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\n\n//SLM\n#ifndef S_IRUSR\n#define S_IRWXU       00700       /* read, write, execute: owner */\n#define S_IRUSR       00400       /* read permission: owner */\n#define S_IWUSR       00200       /* write permission: owner */\n#define S_IXUSR       00100       /* execute permission: owner */\n#define S_IRWXG       00070       /* read, write, execute: group */\n#define S_IRGRP       00040       /* read permission: group */\n#define S_IWGRP       00020       /* write permission: group */\n#define S_IXGRP       00010       /* execute permission: group */\n#define S_IRWXO       00007       /* read, write, execute: other */\n#define S_IROTH       00004       /* read permission: other */\n#define S_IWOTH       00002       /* write permission: other */\n#define S_IXOTH       00001       /* execute permission: other */\n#endif\n\n/*\n  Write the header of an AVI file and close it.\n  returns 0 on success, -1 on write error.\n*/\n\nstatic int avi_close_output_file(avi_t *AVI)\n{\n\tint njunk, hasIndex, ms_per_frame, frate, idxerror, flag;\n\tu64 movi_len;\n\tint hdrl_start, strl_start;\n\tu32 j;\n\tunsigned char AVI_header[HEADERBYTES];\n\tint nhb;\n\tunsigned int xd_size, xd_size_align2;\n\n#ifdef INFO_LIST\n\tint info_len;\n\tint id_len, real_id_len;\n\tint info_start_pos;\n//   time_t calptr;\n#endif\n\n\t/* Calculate length of movi list */\n\n\t// dump the rest of the index\n\tif (AVI->is_opendml) {\n\t\tint cur_std_idx = AVI->video_superindex->nEntriesInUse-1;\n\t\tu32 audtr;\n\n#ifdef DEBUG_ODML\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] ODML dump the rest indices\\n\"));\n#endif\n\t\tavi_ixnn_entry (AVI, AVI->video_superindex->stdindex[cur_std_idx],\n\t\t                &AVI->video_superindex->aIndex[cur_std_idx]);\n\n\t\tAVI->video_superindex->aIndex[cur_std_idx].dwDuration =\n\t\t    AVI->video_superindex->stdindex[cur_std_idx]->nEntriesInUse - 1;\n\n\t\tfor (audtr = 0; audtr < AVI->anum; audtr++) {\n\t\t\tif (!AVI->track[audtr].audio_superindex) {\n\t\t\t\t// not initialized -> no index\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tavi_ixnn_entry (AVI, AVI->track[audtr].audio_superindex->stdindex[cur_std_idx],\n\t\t\t                &AVI->track[audtr].audio_superindex->aIndex[cur_std_idx]);\n\t\t\tAVI->track[audtr].audio_superindex->aIndex[cur_std_idx].dwDuration =\n\t\t\t    AVI->track[audtr].audio_superindex->stdindex[cur_std_idx]->nEntriesInUse - 1;\n\t\t\tif (AVI->track[audtr].a_fmt == 0x1) {\n\t\t\t\tAVI->track[audtr].audio_superindex->aIndex[cur_std_idx].dwDuration *=\n\t\t\t\t    AVI->track[audtr].a_bits*AVI->track[audtr].a_rate*AVI->track[audtr].a_chans/800;\n\t\t\t}\n\t\t}\n\t\t// The AVI->video_superindex->nEntriesInUse contains the offset\n\t\tAVI->video_superindex->stdindex[ cur_std_idx+1 ]->qwBaseOffset = AVI->pos;\n\n\t\t// Correct!\n\t\tmovi_len = AVI->video_superindex->stdindex[ 1 ]->qwBaseOffset - HEADERBYTES+4 - AVI->n_idx*16 - 8;\n\t} else {\n\t\tmovi_len = AVI->pos - HEADERBYTES + 4;\n\t}\n\n\n\t/* Try to output the index entries. This may fail e.g. if no space\n\t   is left on device. We will report this as an error, but we still\n\t   try to write the header correctly (so that the file still may be\n\t   readable in the most cases */\n\n\tidxerror = 0;\n\thasIndex = 1;\n\tif (!AVI->is_opendml) {\n\t\t//   GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] pos=%lu, index_len=%ld             \\n\", AVI->pos, AVI->n_idx*16));\n\t\tint ret = avi_add_chunk(AVI, (unsigned char *)\"idx1\", (unsigned char *)AVI->idx, AVI->n_idx*16);\n\t\thasIndex = (ret==0);\n\t\t//GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] pos=%lu, index_len=%d\\n\", AVI->pos, hasIndex));\n\n\t\tif(ret) {\n\t\t\tidxerror = 1;\n\t\t\tAVI_errno = AVI_ERR_WRITE_INDEX;\n\t\t}\n\t}\n\n\t/* Calculate Microseconds per frame */\n\n\tif(AVI->fps < 0.001) {\n\t\tfrate=0;\n\t\tms_per_frame=0;\n\t} else {\n\t\tfrate = (int) (FRAME_RATE_SCALE*AVI->fps + 0.5);\n\t\tms_per_frame=(int) (1000000/AVI->fps + 0.5);\n\t}\n\n\t/* Prepare the file header */\n\n\tnhb = 0;\n\n\t/* The RIFF header */\n\n\tOUT4CC (\"RIFF\");\n\tif (AVI->is_opendml) {\n\t\tOUTLONG(AVI->video_superindex->stdindex[ 1 ]->qwBaseOffset - 8);    /* # of bytes to follow */\n\t} else {\n\t\tOUTLONG(AVI->pos - 8);    /* # of bytes to follow */\n\t}\n\n\tOUT4CC (\"AVI \");\n\n\t/* Start the header list */\n\n\tOUT4CC (\"LIST\");\n\tOUTLONG(0);        /* Length of list in bytes, don't know yet */\n\thdrl_start = nhb;  /* Store start position */\n\tOUT4CC (\"hdrl\");\n\n\t/* The main AVI header */\n\n\t/* The Flags in AVI File header */\n\n#define AVIF_HASINDEX           0x00000010      /* Index at end of file */\n#define AVIF_MUSTUSEINDEX       0x00000020\n#define AVIF_ISINTERLEAVED      0x00000100\n#define AVIF_TRUSTCKTYPE        0x00000800      /* Use CKType to find key frames */\n#define AVIF_WASCAPTUREFILE     0x00010000\n#define AVIF_COPYRIGHTED        0x00020000\n\n\tOUT4CC (\"avih\");\n\tOUTLONG(56);                 /* # of bytes to follow */\n\tOUTLONG(ms_per_frame);       /* Microseconds per frame */\n\t//ThOe ->0\n\t//   OUTLONG(10000000);           /* MaxBytesPerSec, I hope this will never be used */\n\tOUTLONG(0);\n\tOUTLONG(0);                  /* PaddingGranularity (whatever that might be) */\n\t/* Other sources call it 'reserved' */\n\tflag = AVIF_ISINTERLEAVED;\n\tif(hasIndex) flag |= AVIF_HASINDEX;\n\tif(hasIndex && AVI->must_use_index) flag |= AVIF_MUSTUSEINDEX;\n\tOUTLONG(flag);               /* Flags */\n\tOUTLONG(AVI->video_frames);  /* TotalFrames */\n\tOUTLONG(0);                  /* InitialFrames */\n\n\tOUTLONG(AVI->anum+1);\n//   if (AVI->track[0].audio_bytes)\n//      { OUTLONG(2); }           /* Streams */\n//   else\n//      { OUTLONG(1); }           /* Streams */\n\n\tOUTLONG(0);                  /* SuggestedBufferSize */\n\tOUTLONG(AVI->width);         /* Width */\n\tOUTLONG(AVI->height);        /* Height */\n\t/* MS calls the following 'reserved': */\n\tOUTLONG(0);                  /* TimeScale:  Unit used to measure time */\n\tOUTLONG(0);                  /* DataRate:   Data rate of playback     */\n\tOUTLONG(0);                  /* StartTime:  Starting time of AVI data */\n\tOUTLONG(0);                  /* DataLength: Size of AVI data chunk    */\n\n\n\t/* Start the video stream list ---------------------------------- */\n\n\tOUT4CC (\"LIST\");\n\tOUTLONG(0);        /* Length of list in bytes, don't know yet */\n\tstrl_start = nhb;  /* Store start position */\n\tOUT4CC (\"strl\");\n\n\t/* The video stream header */\n\n\tOUT4CC (\"strh\");\n\tOUTLONG(56);                 /* # of bytes to follow */\n\tOUT4CC (\"vids\");             /* Type */\n\tOUT4CC (AVI->compressor);    /* Handler */\n\tOUTLONG(0);                  /* Flags */\n\tOUTLONG(0);                  /* Reserved, MS says: wPriority, wLanguage */\n\tOUTLONG(0);                  /* InitialFrames */\n\tOUTLONG(FRAME_RATE_SCALE);   /* Scale */\n\tOUTLONG(frate);              /* Rate: Rate/Scale == samples/second */\n\tOUTLONG(0);                  /* Start */\n\tOUTLONG(AVI->video_frames);  /* Length */\n\tOUTLONG(AVI->max_len);       /* SuggestedBufferSize */\n\tOUTLONG(0);                  /* Quality */\n\tOUTLONG(0);                  /* SampleSize */\n\tOUTLONG(0);                  /* Frame */\n\tOUTLONG(0);                  /* Frame */\n\t//OUTLONG(0);                  /* Frame */\n\t//OUTLONG(0);                  /* Frame */\n\n\t/* The video stream format */\n\n\txd_size        = AVI->extradata_size;\n\txd_size_align2 = (AVI->extradata_size+1) & ~1;\n\n\tOUT4CC (\"strf\");\n\tOUTLONG(40 + xd_size_align2);/* # of bytes to follow */\n\tOUTLONG(40 + xd_size);\t/* Size */\n\tOUTLONG(AVI->width);         /* Width */\n\tOUTLONG(AVI->height);        /* Height */\n\tOUTSHRT(1);\n\tOUTSHRT(24);     /* Planes, Count */\n\tOUT4CC (AVI->compressor);    /* Compression */\n\t// ThOe (*3)\n\tOUTLONG(AVI->width*AVI->height*3);  /* SizeImage (in bytes?) */\n\tOUTLONG(0);                  /* XPelsPerMeter */\n\tOUTLONG(0);                  /* YPelsPerMeter */\n\tOUTLONG(0);                  /* ClrUsed: Number of colors used */\n\tOUTLONG(0);                  /* ClrImportant: Number of colors important */\n\n\t// write extradata if present\n\tif (xd_size > 0 && AVI->extradata) {\n\t\tOUTMEM(AVI->extradata, xd_size);\n\t\tif (xd_size != xd_size_align2) {\n\t\t\tOUTCHR(0);\n\t\t}\n\t}\n\n\t// dump index of indices for audio\n\tif (AVI->is_opendml) {\n\t\tu32 k;\n\n\t\tOUT4CC(AVI->video_superindex->fcc);\n\t\tOUTLONG(2+1+1+4+4+3*4 + AVI->video_superindex->nEntriesInUse * (8+4+4));\n\t\tOUTSHRT(AVI->video_superindex->wLongsPerEntry);\n\t\tOUTCHR(AVI->video_superindex->bIndexSubType);\n\t\tOUTCHR(AVI->video_superindex->bIndexType);\n\t\tOUTLONG(AVI->video_superindex->nEntriesInUse);\n\t\tOUT4CC(AVI->video_superindex->dwChunkId);\n\t\tOUTLONG(0);\n\t\tOUTLONG(0);\n\t\tOUTLONG(0);\n\n\n\t\tfor (k = 0; k < AVI->video_superindex->nEntriesInUse; k++) {\n\t\t\tu32 r = (u32) ((AVI->video_superindex->aIndex[k].qwOffset >> 32) & 0xffffffff);\n\t\t\tu32 s = (u32) ((AVI->video_superindex->aIndex[k].qwOffset) & 0xffffffff);\n\n\t\t\tOUTLONG(s);\n\t\t\tOUTLONG(r);\n\t\t\tOUTLONG(AVI->video_superindex->aIndex[k].dwSize);\n\t\t\tOUTLONG(AVI->video_superindex->aIndex[k].dwDuration);\n\t\t}\n\n\t}\n\n\t/* Finish stream list, i.e. put number of bytes in the list to proper pos */\n\n\tlong2str(AVI_header+strl_start-4,nhb-strl_start);\n\n\t/* Start the audio stream list ---------------------------------- */\n\n\tfor(j=0; j<AVI->anum; ++j) {\n\n\t\t//if (AVI->track[j].a_chans && AVI->track[j].audio_bytes)\n\t\t{\n\t\t\tunsigned int nBlockAlign = 0;\n\t\t\tunsigned int avgbsec = 0;\n\t\t\tunsigned int scalerate = 0;\n\n\t\t\tint sampsize = avi_sampsize(AVI, j);\n\t\t\tsampsize = AVI->track[j].a_fmt==0x1?sampsize*4:sampsize;\n\n\t\t\tnBlockAlign = (AVI->track[j].a_rate<32000)?576:1152;\n\t\t\t/*\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] XXX sampsize (%d) block (%ld) rate (%ld) audio_bytes (%ld) mp3rate(%ld,%ld)\\n\",\n\t\t\t sampsize, nBlockAlign, AVI->track[j].a_rate,\n\t\t\t (int int)AVI->track[j].audio_bytes,\n\t\t\t 1000*AVI->track[j].mp3rate/8, AVI->track[j].mp3rate));\n\t\t\t */\n\n\t\t\tif (AVI->track[j].a_fmt==0x1) {\n\t\t\t\tsampsize = (AVI->track[j].a_chans<2)?sampsize/2:sampsize;\n\t\t\t\tavgbsec = AVI->track[j].a_rate*sampsize/4;\n\t\t\t\tscalerate = AVI->track[j].a_rate*sampsize/4;\n\t\t\t} else  {\n\t\t\t\tavgbsec = 1000*AVI->track[j].mp3rate/8;\n\t\t\t\tscalerate = 1000*AVI->track[j].mp3rate/8;\n\t\t\t}\n\n\t\t\tOUT4CC (\"LIST\");\n\t\t\tOUTLONG(0);        /* Length of list in bytes, don't know yet */\n\t\t\tstrl_start = nhb;  /* Store start position */\n\t\t\tOUT4CC (\"strl\");\n\n\t\t\t/* The audio stream header */\n\n\t\t\tOUT4CC (\"strh\");\n\t\t\tOUTLONG(56);            /* # of bytes to follow */\n\t\t\tOUT4CC (\"auds\");\n\n\t\t\t// -----------\n\t\t\t// ThOe\n\t\t\tOUTLONG(0);             /* Format (Optionally) */\n\t\t\t// -----------\n\n\t\t\tOUTLONG(0);             /* Flags */\n\t\t\tOUTLONG(0);             /* Reserved, MS says: wPriority, wLanguage */\n\t\t\tOUTLONG(0);             /* InitialFrames */\n\n\t\t\t// VBR\n\t\t\tif (AVI->track[j].a_fmt == 0x55 && AVI->track[j].a_vbr) {\n\t\t\t\tOUTLONG(nBlockAlign);                   /* Scale */\n\t\t\t\tOUTLONG(AVI->track[j].a_rate);          /* Rate */\n\t\t\t\tOUTLONG(0);                             /* Start */\n\t\t\t\tOUTLONG(AVI->track[j].audio_chunks);    /* Length */\n\t\t\t\tOUTLONG(0);                      /* SuggestedBufferSize */\n\t\t\t\tOUTLONG(0);                             /* Quality */\n\t\t\t\tOUTLONG(0);                             /* SampleSize */\n\t\t\t\tOUTLONG(0);                             /* Frame */\n\t\t\t\tOUTLONG(0);                             /* Frame */\n\t\t\t} else {\n\t\t\t\tOUTLONG(sampsize/4);                    /* Scale */\n\t\t\t\tOUTLONG(scalerate);  /* Rate */\n\t\t\t\tOUTLONG(0);                             /* Start */\n\t\t\t\tOUTLONG(4*AVI->track[j].audio_bytes/sampsize);   /* Length */\n\t\t\t\tOUTLONG(0);                             /* SuggestedBufferSize */\n\t\t\t\tOUTLONG(0xffffffff);                             /* Quality */\n\t\t\t\tOUTLONG(sampsize/4);                    /* SampleSize */\n\t\t\t\tOUTLONG(0);                             /* Frame */\n\t\t\t\tOUTLONG(0);                             /* Frame */\n\t\t\t}\n\n\t\t\t/* The audio stream format */\n\n\t\t\tOUT4CC (\"strf\");\n\n\t\t\tif (AVI->track[j].a_fmt == 0x55 && AVI->track[j].a_vbr) {\n\n\t\t\t\tOUTLONG(30);                            /* # of bytes to follow */ // mplayer writes 28\n\t\t\t\tOUTSHRT(AVI->track[j].a_fmt);           /* Format */                  // 2\n\t\t\t\tOUTSHRT(AVI->track[j].a_chans);         /* Number of channels */      // 2\n\t\t\t\tOUTLONG(AVI->track[j].a_rate);          /* SamplesPerSec */           // 4\n\t\t\t\t//ThOe/tibit\n\t\t\t\tOUTLONG(1000*AVI->track[j].mp3rate/8);  /* maybe we should write an avg. */ // 4\n\t\t\t\tOUTSHRT(nBlockAlign);                   /* BlockAlign */              // 2\n\t\t\t\tOUTSHRT(AVI->track[j].a_bits);          /* BitsPerSample */           // 2\n\n\t\t\t\tOUTSHRT(12);                           /* cbSize */                   // 2\n\t\t\t\tOUTSHRT(1);                            /* wID */                      // 2\n\t\t\t\tOUTLONG(2);                            /* fdwFlags */                 // 4\n\t\t\t\tOUTSHRT(nBlockAlign);                  /* nBlockSize */               // 2\n\t\t\t\tOUTSHRT(1);                            /* nFramesPerBlock */          // 2\n\t\t\t\tOUTSHRT(0);                            /* nCodecDelay */              // 2\n\n\t\t\t} else if (AVI->track[j].a_fmt == 0x55 && !AVI->track[j].a_vbr) {\n\n\t\t\t\tOUTLONG(30);                            /* # of bytes to follow */\n\t\t\t\tOUTSHRT(AVI->track[j].a_fmt);           /* Format */\n\t\t\t\tOUTSHRT(AVI->track[j].a_chans);         /* Number of channels */\n\t\t\t\tOUTLONG(AVI->track[j].a_rate);          /* SamplesPerSec */\n\t\t\t\t//ThOe/tibit\n\t\t\t\tOUTLONG(1000*AVI->track[j].mp3rate/8);\n\t\t\t\tOUTSHRT(sampsize/4);                    /* BlockAlign */\n\t\t\t\tOUTSHRT(AVI->track[j].a_bits);          /* BitsPerSample */\n\n\t\t\t\tOUTSHRT(12);                           /* cbSize */\n\t\t\t\tOUTSHRT(1);                            /* wID */\n\t\t\t\tOUTLONG(2);                            /* fdwFlags */\n\t\t\t\tOUTSHRT(nBlockAlign);                  /* nBlockSize */\n\t\t\t\tOUTSHRT(1);                            /* nFramesPerBlock */\n\t\t\t\tOUTSHRT(0);                            /* nCodecDelay */\n\n\t\t\t} else {\n\n\t\t\t\tOUTLONG(18);                   /* # of bytes to follow */\n\t\t\t\tOUTSHRT(AVI->track[j].a_fmt);           /* Format */\n\t\t\t\tOUTSHRT(AVI->track[j].a_chans);         /* Number of channels */\n\t\t\t\tOUTLONG(AVI->track[j].a_rate);          /* SamplesPerSec */\n\t\t\t\t//ThOe/tibit\n\t\t\t\tOUTLONG(avgbsec);  /* Avg bytes/sec */\n\t\t\t\tOUTSHRT(sampsize/4);                    /* BlockAlign */\n\t\t\t\tOUTSHRT(AVI->track[j].a_bits);          /* BitsPerSample */\n\t\t\t\tOUTSHRT(0);                           /* cbSize */\n\n\t\t\t}\n\t\t}\n\t\tif (AVI->is_opendml) {\n\t\t\tu32 k;\n\n\t\t\tif (!AVI->track[j].audio_superindex) {\n\t\t\t\t// not initialized -> no index\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tOUT4CC(AVI->track[j].audio_superindex->fcc);    /* \"indx\" */\n\t\t\tOUTLONG(2+1+1+4+4+3*4 + AVI->track[j].audio_superindex->nEntriesInUse * (8+4+4));\n\t\t\tOUTSHRT(AVI->track[j].audio_superindex->wLongsPerEntry);\n\t\t\tOUTCHR(AVI->track[j].audio_superindex->bIndexSubType);\n\t\t\tOUTCHR(AVI->track[j].audio_superindex->bIndexType);\n\t\t\tOUTLONG(AVI->track[j].audio_superindex->nEntriesInUse);\n\t\t\tOUT4CC(AVI->track[j].audio_superindex->dwChunkId);\n\t\t\tOUTLONG(0);\n\t\t\tOUTLONG(0);\n\t\t\tOUTLONG(0);\n\n\t\t\tfor (k = 0; k < AVI->track[j].audio_superindex->nEntriesInUse; k++) {\n\t\t\t\tu32 r = (u32) ((AVI->track[j].audio_superindex->aIndex[k].qwOffset >> 32) & 0xffffffff);\n\t\t\t\tu32 s = (u32) ((AVI->track[j].audio_superindex->aIndex[k].qwOffset) & 0xffffffff);\n\n\t\t\t\t/*\n\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] AUD[%d] NrEntries %d/%ld (%c%c%c%c) |0x%llX|%ld|%ld| \\n\",  j, k,\n\t\t\t\t        AVI->track[j].audio_superindex->nEntriesInUse,\n\t\t\t\t    AVI->track[j].audio_superindex->dwChunkId[0], AVI->track[j].audio_superindex->dwChunkId[1],\n\t\t\t\t    AVI->track[j].audio_superindex->dwChunkId[2], AVI->track[j].audio_superindex->dwChunkId[3],\n\t\t\t\t    AVI->track[j].audio_superindex->aIndex[k].qwOffset,\n\t\t\t\t    AVI->track[j].audio_superindex->aIndex[k].dwSize,\n\t\t\t\t    AVI->track[j].audio_superindex->aIndex[k].dwDuration\n\t\t\t\t  ));\n\t\t\t\t  */\n\n\t\t\t\tOUTLONG(s);\n\t\t\t\tOUTLONG(r);\n\t\t\t\tOUTLONG(AVI->track[j].audio_superindex->aIndex[k].dwSize);\n\t\t\t\tOUTLONG(AVI->track[j].audio_superindex->aIndex[k].dwDuration);\n\t\t\t}\n\t\t}\n\t\t/* Finish stream list, i.e. put number of bytes in the list to proper pos */\n\t\tlong2str(AVI_header+strl_start-4,nhb-strl_start);\n\t}\n\n\tif (AVI->is_opendml) {\n\t\tOUT4CC(\"LIST\");\n\t\tOUTLONG(16);\n\t\tOUT4CC(\"odml\");\n\t\tOUT4CC(\"dmlh\");\n\t\tOUTLONG(4);\n\t\tOUTLONG(AVI->total_frames);\n\t}\n\n\t/* Finish header list */\n\n\tlong2str(AVI_header+hdrl_start-4,nhb-hdrl_start);\n\n\n\t// add INFO list --- (0.6.0pre4)\n\n#ifdef INFO_LIST\n\tOUT4CC (\"LIST\");\n\n\tinfo_start_pos = nhb;\n\tinfo_len = MAX_INFO_STRLEN + 12;\n\tOUTLONG(info_len); // rewritten later\n\tOUT4CC (\"INFO\");\n\n\tOUT4CC (\"ISFT\");\n\t//OUTLONG(MAX_INFO_STRLEN);\n\tmemset(id_str, 0, MAX_INFO_STRLEN);\n\tif (gf_sys_is_test_mode()) {\n\t\tsnprintf(id_str, MAX_INFO_STRLEN, \"GPAC/avilib\");\n\t} else {\n\t\tsnprintf(id_str, MAX_INFO_STRLEN, \"GPAC/avilib-%s\", gf_gpac_version());\n\t}\n\treal_id_len = id_len = (u32) strlen(id_str)+1;\n\tif (id_len&1) id_len++;\n\n\tOUTLONG(real_id_len);\n\n\tmemset(AVI_header+nhb, 0, id_len);\n\tmemcpy(AVI_header+nhb, id_str, id_len);\n\tnhb += id_len;\n\n\tinfo_len = 0;\n\n\t// write correct len\n\tlong2str(AVI_header+info_start_pos, info_len + id_len + 4+4+4);\n\n\tnhb += info_len;\n\n//   OUT4CC (\"ICMT\");\n//   OUTLONG(MAX_INFO_STRLEN);\n\n//   calptr=time(NULL);\n//   sprintf(id_str, \"\\t%s %s\", ctime(&calptr), \"\");\n//   memset(AVI_header+nhb, 0, MAX_INFO_STRLEN);\n//   memcpy(AVI_header+nhb, id_str, 25);\n//   nhb += MAX_INFO_STRLEN;\n#endif\n\n\t// ----------------------------\n\n\t/* Calculate the needed amount of junk bytes, output junk */\n\n\tnjunk = HEADERBYTES - nhb - 8 - 12;\n\n\t/* Safety first: if njunk <= 0, somebody has played with\n\t   HEADERBYTES without knowing what (s)he did.\n\t   This is a fatal error */\n\n\tif(njunk<=0)\n\t{\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[avilib] AVI_close_output_file: # of header bytes too small\\n\"));\n\t\texit(1);\n\t}\n\n\tOUT4CC (\"JUNK\");\n\tOUTLONG(njunk);\n\tmemset(AVI_header+nhb,0,njunk);\n\n\tnhb += njunk;\n\n\t/* Start the movi list */\n\n\tOUT4CC (\"LIST\");\n\tOUTLONG(movi_len); /* Length of list in bytes */\n\tOUT4CC (\"movi\");\n\n\t/* Output the header, truncate the file to the number of bytes\n\t   actually written, report an error if someting goes wrong */\n\n\tif ( (gf_fseek(AVI->fdes,0,SEEK_SET)==(u64)-1) ||\n\t        avi_write(AVI->fdes,(char *)AVI_header,HEADERBYTES)!=HEADERBYTES\n//\t\t|| ftruncate(AVI->fdes,AVI->pos)<0\n\t   )\n\t{\n\t\tAVI_errno = AVI_ERR_CLOSE;\n\t\treturn -1;\n\t}\n\n\n\t// Fix up the empty additional RIFF and LIST chunks\n\tif (AVI->is_opendml) {\n\t\tu32 k;\n\t\tchar f[4];\n\t\tu32 len;\n\n\t\tfor (k=1; k<AVI->video_superindex->nEntriesInUse; k++) {\n\t\t\t// the len of the RIFF Chunk\n\t\t\tgf_fseek(AVI->fdes, AVI->video_superindex->stdindex[k]->qwBaseOffset+4, SEEK_SET);\n\t\t\tlen = (u32) (AVI->video_superindex->stdindex[k+1]->qwBaseOffset - AVI->video_superindex->stdindex[k]->qwBaseOffset - 8);\n\t\t\tlong2str((unsigned char *)f, len);\n\t\t\tavi_write(AVI->fdes, f, 4);\n\n\t\t\t// len of the LIST/movi chunk\n\t\t\tgf_fseek(AVI->fdes, 8, SEEK_CUR);\n\t\t\tlen -= 12;\n\t\t\tlong2str((unsigned char *)f, len);\n\t\t\tavi_write(AVI->fdes, f, 4);\n\t\t}\n\t}\n\n\n\tif(idxerror) return -1;\n\n\treturn 0;\n}\n\n/*\n   AVI_write_data:\n   Add video or audio data to the file;\n\n   Return values:\n    0    No error;\n   -1    Error, AVI_errno is set appropriatly;\n\n*/\n\nstatic int avi_write_data(avi_t *AVI, char *data, unsigned int length, int audio, int keyframe)\n{\n\tint n = 0;\n\n\tunsigned char astr[5];\n\n\t// transcode core itself checks for the size -- unneeded and\n\t// does harm to xvid 2pass encodes where the first pass can get\n\t// _very_ large -- tibit.\n\n#if 0\n\t/* Check for maximum file length */\n\n\tif ( (AVI->pos + 8 + length + 8 + (AVI->n_idx+1)*16) > AVI_MAX_LEN ) {\n\t\tAVI_errno = AVI_ERR_SIZELIM;\n\t\treturn -1;\n\t}\n#endif\n\n\t/* Add index entry */\n\n\t//set tag for current audio track\n\tsprintf((char *)astr, \"0%1dwb\", (int)(AVI->aptr+1));\n\n\tif(audio) {\n\t\tif (!AVI->is_opendml) n = avi_add_index_entry(AVI,astr,0x10,AVI->pos,length);\n\t\tn += avi_add_odml_index_entry(AVI,astr,0x10,AVI->pos,length);\n\t} else {\n\t\tif (!AVI->is_opendml) n = avi_add_index_entry(AVI,(unsigned char *)\"00db\",((keyframe)?0x10:0x0),AVI->pos,length);\n\t\tn += avi_add_odml_index_entry(AVI,(unsigned char *)\"00db\",((keyframe)?0x10:0x0),AVI->pos,length);\n\t}\n\n\tif(n) return -1;\n\n\t/* Output tag and data */\n\n\tif(audio)\n\t\tn = avi_add_chunk(AVI,(unsigned char *)astr, (unsigned char *)data, length);\n\telse\n\t\tn = avi_add_chunk(AVI,(unsigned char *)\"00db\", (unsigned char *)data, length);\n\n\tif (n) return -1;\n\n\treturn 0;\n}\n\nGF_EXPORT\nint AVI_write_frame(avi_t *AVI, u8 *data, int bytes, int keyframe)\n{\n\ts64 pos;\n\n\tif(AVI->mode==AVI_MODE_READ) {\n\t\tAVI_errno = AVI_ERR_NOT_PERM;\n\t\treturn -1;\n\t}\n\n\tpos = AVI->pos;\n\n\tif(avi_write_data(AVI,data,bytes,0,keyframe)) return -1;\n\n\tAVI->last_pos = pos;\n\tAVI->last_len = bytes;\n\tAVI->video_frames++;\n\treturn 0;\n}\n\n#if 0 //unused\nint AVI_dup_frame(avi_t *AVI)\n{\n\tif(AVI->mode==AVI_MODE_READ) {\n\t\tAVI_errno = AVI_ERR_NOT_PERM;\n\t\treturn -1;\n\t}\n\n\tif(AVI->last_pos==0) return 0; /* No previous real frame */\n\tif(avi_add_index_entry(AVI,(unsigned char *)\"00db\",0x10,AVI->last_pos,AVI->last_len)) return -1;\n\tAVI->video_frames++;\n\tAVI->must_use_index = 1;\n\treturn 0;\n}\n#endif\n\nGF_EXPORT\nint AVI_write_audio(avi_t *AVI, u8 *data, int bytes)\n{\n\tif(AVI->mode==AVI_MODE_READ) {\n\t\tAVI_errno = AVI_ERR_NOT_PERM;\n\t\treturn -1;\n\t}\n\n\tif( avi_write_data(AVI,data,bytes,1,0) ) return -1;\n\tAVI->track[AVI->aptr].audio_bytes += bytes;\n\tAVI->track[AVI->aptr].audio_chunks++;\n\treturn 0;\n}\n\n#if 0 //unused\n\nint AVI_append_audio(avi_t *AVI, u8 *data, int bytes)\n{\n\n\t// won't work for >2gb\n\tint i, length, pos;\n\tunsigned char c[4];\n\n\tif(AVI->mode==AVI_MODE_READ) {\n\t\tAVI_errno = AVI_ERR_NOT_PERM;\n\t\treturn -1;\n\t}\n\n\t// update last index entry:\n\n\t--AVI->n_idx;\n\tlength = str2ulong(AVI->idx[AVI->n_idx]+12);\n\tpos    = str2ulong(AVI->idx[AVI->n_idx]+8);\n\n\t//update;\n\tlong2str(AVI->idx[AVI->n_idx]+12,length+bytes);\n\n\t++AVI->n_idx;\n\n\tAVI->track[AVI->aptr].audio_bytes += bytes;\n\n\t//update chunk header\n\tgf_fseek(AVI->fdes, pos+4, SEEK_SET);\n\tlong2str(c, length+bytes);\n\tavi_write(AVI->fdes, (char *)c, 4);\n\n\tgf_fseek(AVI->fdes, pos+8+length, SEEK_SET);\n\n\ti=PAD_EVEN(length + bytes);\n\n\tbytes = i - length;\n\tavi_write(AVI->fdes, data, bytes);\n\tAVI->pos = pos + 8 + i;\n\n\treturn 0;\n}\n\nu64 AVI_bytes_remain(avi_t *AVI)\n{\n\tif(AVI->mode==AVI_MODE_READ) return 0;\n\n\treturn ( AVI_MAX_LEN - (AVI->pos + 8 + 16*AVI->n_idx));\n}\n\nu64 AVI_bytes_written(avi_t *AVI)\n{\n\tif(AVI->mode==AVI_MODE_READ) return 0;\n\n\treturn (AVI->pos + 8 + 16*AVI->n_idx);\n}\n#endif\n\nint AVI_set_audio_track(avi_t *AVI, u32 track)\n{\n\n\tif (track + 1 > AVI->anum) return(-1);\n\n\t//this info is not written to file anyway\n\tAVI->aptr=track;\n\treturn 0;\n}\n\nint AVI_get_audio_track(avi_t *AVI)\n{\n\treturn(AVI->aptr);\n}\n\n#if 0 //unused\nvoid AVI_set_audio_vbr(avi_t *AVI, int is_vbr)\n{\n\tAVI->track[AVI->aptr].a_vbr = is_vbr;\n}\n\nint AVI_get_audio_vbr(avi_t *AVI)\n{\n\treturn(AVI->track[AVI->aptr].a_vbr);\n}\n#endif\n\n\n/*******************************************************************\n *                                                                 *\n *    Utilities for reading video and audio from an AVI File       *\n *                                                                 *\n *******************************************************************/\n\nGF_EXPORT\nint AVI_close(avi_t *AVI)\n{\n\tint ret;\n\tu32 j;\n\n\t/* If the file was open for writing, the header and index still have\n\t   to be written */\n\n\tif(AVI->mode == AVI_MODE_WRITE)\n\t\tret = avi_close_output_file(AVI);\n\telse\n\t\tret = 0;\n\n\t/* Even if there happened an error, we first clean up */\n\n\tgf_fclose(AVI->fdes);\n\tif(AVI->idx) gf_free(AVI->idx);\n\tif(AVI->video_index) gf_free(AVI->video_index);\n\tif(AVI->video_superindex) {\n\t\tif(AVI->video_superindex->aIndex) gf_free(AVI->video_superindex->aIndex);\n\t\tif (AVI->video_superindex->stdindex) {\n\t\t\tfor (j=0; j < NR_IXNN_CHUNKS; j++) {\n\t\t\t\tif (AVI->video_superindex->stdindex[j]->aIndex)\n\t\t\t\t\tgf_free(AVI->video_superindex->stdindex[j]->aIndex);\n\t\t\t\tgf_free(AVI->video_superindex->stdindex[j]);\n\t\t\t}\n\t\t\tgf_free(AVI->video_superindex->stdindex);\n\t\t}\n\t\tgf_free(AVI->video_superindex);\n\t}\n\n\tfor (j=0; j<AVI->anum; j++)\n\t{\n\t\tif(AVI->track[j].audio_index) gf_free(AVI->track[j].audio_index);\n\t\tif(AVI->track[j].audio_superindex) {\n\t\t\tavisuperindex_chunk *asi = AVI->track[j].audio_superindex;\n\t\t\tif (asi->aIndex) gf_free(asi->aIndex);\n\n\t\t\tif (asi->stdindex) {\n\t\t\t\tfor (j=0; j < NR_IXNN_CHUNKS; j++) {\n\t\t\t\t\tif (asi->stdindex[j]->aIndex)\n\t\t\t\t\t\tgf_free(asi->stdindex[j]->aIndex);\n\t\t\t\t\tgf_free(asi->stdindex[j]);\n\t\t\t\t}\n\t\t\t\tgf_free(asi->stdindex);\n\t\t\t}\n\t\t\tgf_free(asi);\n\t\t}\n\t}\n\n\tif (AVI->bitmap_info_header)\n\t\tgf_free(AVI->bitmap_info_header);\n\tfor (j = 0; j < AVI->anum; j++)\n\t\tif (AVI->wave_format_ex[j])\n\t\t\tgf_free(AVI->wave_format_ex[j]);\n\tif (AVI->extradata)\n\t\tgf_free(AVI->extradata);\n\n\tgf_free(AVI);\n\treturn ret;\n}\n\n\n#define ERR_EXIT(x) \\\n{ \\\n   AVI_close(AVI); \\\n   AVI_errno = x; \\\n   return 0; \\\n}\n\n\navi_t *AVI_open_input_file(char *filename, int getIndex)\n{\n\tavi_t *AVI;\n\n\t/* Create avi_t structure */\n\n\tAVI = (avi_t *) gf_malloc(sizeof(avi_t));\n\tif(AVI==NULL)\n\t{\n\t\tAVI_errno = AVI_ERR_NO_MEM;\n\t\treturn 0;\n\t}\n\tmemset((void *)AVI,0,sizeof(avi_t));\n\n\tAVI->mode = AVI_MODE_READ; /* open for reading */\n\n\t/* Open the file */\n\n\tAVI->fdes = gf_fopen(filename,\"rb\");\n\tif(!AVI->fdes )\n\t{\n\t\tAVI_errno = AVI_ERR_OPEN;\n\t\tgf_free(AVI);\n\t\treturn 0;\n\t}\n\n\tAVI_errno = 0;\n\tavi_parse_input_file(AVI, getIndex);\n\n\tif (AVI != NULL && !AVI_errno) {\n\t\tAVI->aptr=0; //reset\n\t}\n\n\tif (AVI_errno) return NULL;\n\n\treturn AVI;\n}\n\n#if 0\navi_t *AVI_open_fd(FILE *fd, int getIndex)\n{\n\tavi_t *AVI=NULL;\n\n\t/* Create avi_t structure */\n\n\tAVI = (avi_t *) gf_malloc(sizeof(avi_t));\n\tif(AVI==NULL)\n\t{\n\t\tAVI_errno = AVI_ERR_NO_MEM;\n\t\treturn 0;\n\t}\n\tmemset((void *)AVI,0,sizeof(avi_t));\n\n\tAVI->mode = AVI_MODE_READ; /* open for reading */\n\n\t// file alread open\n\tAVI->fdes = fd;\n\n\tAVI_errno = 0;\n\tavi_parse_input_file(AVI, getIndex);\n\n\tif (AVI != NULL && !AVI_errno) {\n\t\tAVI->aptr=0; //reset\n\t}\n\n\tif (AVI_errno)\n\t\treturn AVI=NULL;\n\telse\n\t\treturn AVI;\n}\n#endif\n\nint avi_parse_input_file(avi_t *AVI, int getIndex)\n{\n\tint rate, scale, idx_type;\n\ts64 n, i;\n\tunsigned char *hdrl_data;\n\tu64 header_offset=0;\n\tint hdrl_len=0;\n\tint nvi, nai[AVI_MAX_TRACKS], ioff;\n\tu64 tot[AVI_MAX_TRACKS];\n\tu32 j;\n\tint lasttag = 0;\n\tint vids_strh_seen = 0;\n\tint vids_strf_seen = 0;\n\tint auds_strh_seen = 0;\n\t//  int auds_strf_seen = 0;\n\tint num_stream = 0;\n\tchar data[256];\n\ts64 oldpos=-1, newpos=-1;\n\n\tint aud_chunks = 0;\n\tif (!AVI) {\n\t   AVI_errno = AVI_ERR_OPEN;\n\t   return 0;\n\t}\n\n\t/* Read first 12 bytes and check that this is an AVI file */\n\tif (avi_read(AVI->fdes,data,12) != 12 )\n\t\tERR_EXIT(AVI_ERR_READ)\n\n\tif (strnicmp(data  ,\"RIFF\",4) !=0 || strnicmp(data+8,\"AVI \",4) !=0 )\n\t\tERR_EXIT(AVI_ERR_NO_AVI)\n\n\t/* Go through the AVI file and extract the header list,\n\t   the start position of the 'movi' list and an optionally\n\t   present idx1 tag */\n\n\thdrl_data = 0;\n\n\twhile(1)\n\t{\n\t\tif( avi_read(AVI->fdes,data,8) != 8 ) break; /* We assume it's EOF */\n\t\tnewpos = gf_ftell(AVI->fdes);\n\t\tif(oldpos==newpos) {\n\t\t\t/* This is a broken AVI stream... */\n\t\t\treturn -1;\n\t\t}\n\t\toldpos=newpos;\n\n\t\tn = str2ulong((unsigned char *)data+4);\n\t\tn = PAD_EVEN(n);\n\n\t\tif(strnicmp(data,\"LIST\",4) == 0)\n\t\t{\n\t\t\tif( avi_read(AVI->fdes,data,4) != 4 ) ERR_EXIT(AVI_ERR_READ)\n\t\t\t\tn -= 4;\n\t\t\tif(strnicmp(data,\"hdrl\",4) == 0)\n\t\t\t{\n\t\t\t\tif (n>0xFFFFFFFF) ERR_EXIT(AVI_ERR_READ)\n\t\t\t\thdrl_len = (u32) n;\n\t\t\t\thdrl_data = (unsigned char *) gf_malloc((u32)n);\n\t\t\t\tif(hdrl_data==0) ERR_EXIT(AVI_ERR_NO_MEM);\n\n\t\t\t\t// offset of header\n\n\t\t\t\theader_offset = gf_ftell(AVI->fdes);\n\n\t\t\t\tif( avi_read(AVI->fdes,(char *)hdrl_data, (u32) n) != n ) ERR_EXIT(AVI_ERR_READ)\n\t\t\t\t}\n\t\t\telse if(strnicmp(data,\"movi\",4) == 0)\n\t\t\t{\n\t\t\t\tAVI->movi_start = gf_ftell(AVI->fdes);\n\t\t\t\tif (gf_fseek(AVI->fdes,n,SEEK_CUR)==(u64)-1) break;\n\t\t\t}\n\t\t\telse if (gf_fseek(AVI->fdes,n,SEEK_CUR)==(u64)-1) break;\n\t\t}\n\t\telse if(strnicmp(data,\"idx1\",4) == 0)\n\t\t{\n\t\t\t/* n must be a multiple of 16, but the reading does not\n\t\t\t   break if this is not the case */\n\n\t\t\tAVI->n_idx = AVI->max_idx = (u32) (n/16);\n\t\t\tAVI->idx = (unsigned  char((*)[16]) ) gf_malloc((u32)n);\n\t\t\tif(AVI->idx==0) ERR_EXIT(AVI_ERR_NO_MEM)\n\t\t\t\tif(avi_read(AVI->fdes, (char *) AVI->idx, (u32) n) != n ) {\n\t\t\t\t\tgf_free( AVI->idx);\n\t\t\t\t\tAVI->idx=NULL;\n\t\t\t\t\tAVI->n_idx = 0;\n\t\t\t\t}\n\t\t}\n\t\telse\n\t\t\tgf_fseek(AVI->fdes,n,SEEK_CUR);\n\t}\n\n\tif(!hdrl_data      ) ERR_EXIT(AVI_ERR_NO_HDRL)\n\t\tif(!AVI->movi_start) ERR_EXIT(AVI_ERR_NO_MOVI)\n\n\t\t\t/* Interpret the header list */\n\n\t\t\tfor(i=0; i<hdrl_len;)\n\t\t\t{\n\t\t\t\t/* List tags are completly ignored */\n\n#ifdef DEBUG_ODML\n\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] TAG %c%c%c%c\\n\", (hdrl_data+i)[0], (hdrl_data+i)[1], (hdrl_data+i)[2], (hdrl_data+i)[3]));\n#endif\n\n\t\t\t\tif(strnicmp((char *)hdrl_data+i,\"LIST\",4)==0) {\n\t\t\t\t\ti+= 12;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tn = str2ulong(hdrl_data+i+4);\n\t\t\t\tn = PAD_EVEN(n);\n\t\t\t\tif (i+n>hdrl_len) ERR_EXIT(AVI_ERR_READ)\n\n\n\t\t\t\t/* Interpret the tag and its args */\n\n\t\t\t\tif(strnicmp((char *)hdrl_data+i,\"strh\",4)==0)\n\t\t\t\t{\n\t\t\t\t\ti += 8;\n#ifdef DEBUG_ODML\n\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] TAG   %c%c%c%c\\n\", (hdrl_data+i)[0], (hdrl_data+i)[1], (hdrl_data+i)[2], (hdrl_data+i)[3]));\n#endif\n\t\t\t\t\tif(strnicmp((char *)hdrl_data+i,\"vids\",4) == 0 && !vids_strh_seen)\n\t\t\t\t\t{\n\t\t\t\t\t\tmemcpy(AVI->compressor,hdrl_data+i+4,4);\n\t\t\t\t\t\tAVI->compressor[4] = 0;\n\n\t\t\t\t\t\t// ThOe\n\t\t\t\t\t\tAVI->v_codech_off = header_offset + i+4;\n\n\t\t\t\t\t\tscale = str2ulong(hdrl_data+i+20);\n\t\t\t\t\t\trate  = str2ulong(hdrl_data+i+24);\n\t\t\t\t\t\tif(scale!=0) AVI->fps = (double)rate/(double)scale;\n\t\t\t\t\t\tAVI->video_frames = str2ulong(hdrl_data+i+32);\n\t\t\t\t\t\tAVI->video_strn = num_stream;\n\t\t\t\t\t\tAVI->max_len = 0;\n\t\t\t\t\t\tvids_strh_seen = 1;\n\t\t\t\t\t\tlasttag = 1; /* vids */\n\t\t\t\t\t\tmemcpy(&AVI->video_stream_header, hdrl_data + i,\n\t\t\t\t\t\t       sizeof(alAVISTREAMHEADER));\n\t\t\t\t\t}\n\t\t\t\t\telse if (strnicmp ((char *)hdrl_data+i,\"auds\",4) ==0 && ! auds_strh_seen)\n\t\t\t\t\t{\n\n\t\t\t\t\t\t//inc audio tracks\n\t\t\t\t\t\tAVI->aptr=AVI->anum;\n\t\t\t\t\t\t++AVI->anum;\n\n\t\t\t\t\t\tif(AVI->anum > AVI_MAX_TRACKS) {\n\t\t\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[avilib] error - only %d audio tracks supported\\n\", AVI_MAX_TRACKS));\n\t\t\t\t\t\t\treturn(-1);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tAVI->track[AVI->aptr].audio_bytes = str2ulong(hdrl_data+i+32)*avi_sampsize(AVI, 0);\n\t\t\t\t\t\tAVI->track[AVI->aptr].audio_strn = num_stream;\n\n\t\t\t\t\t\t// if samplesize==0 -> vbr\n\t\t\t\t\t\tAVI->track[AVI->aptr].a_vbr = !str2ulong(hdrl_data+i+44);\n\n\t\t\t\t\t\tAVI->track[AVI->aptr].padrate = str2ulong(hdrl_data+i+24);\n\t\t\t\t\t\tmemcpy(&AVI->stream_headers[AVI->aptr], hdrl_data + i,\n\t\t\t\t\t\t       sizeof(alAVISTREAMHEADER));\n\n\t\t\t\t\t\t//\t   auds_strh_seen = 1;\n\t\t\t\t\t\tlasttag = 2; /* auds */\n\n\t\t\t\t\t\t// ThOe\n\t\t\t\t\t\tAVI->track[AVI->aptr].a_codech_off = header_offset + i;\n\n\t\t\t\t\t}\n\t\t\t\t\telse if (strnicmp ((char*)hdrl_data+i,\"iavs\",4) ==0 && ! auds_strh_seen) {\n\t\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[avilib] AVILIB: error - DV AVI Type 1 no supported\\n\"));\n\t\t\t\t\t\treturn (-1);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tlasttag = 0;\n\t\t\t\t\tnum_stream++;\n\t\t\t\t}\n\t\t\t\telse if(strnicmp((char*)hdrl_data+i,\"dmlh\",4) == 0) {\n\t\t\t\t\tAVI->total_frames = str2ulong(hdrl_data+i+8);\n#ifdef DEBUG_ODML\n\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] real number of frames %d\\n\", AVI->total_frames));\n#endif\n\t\t\t\t\ti += 8;\n\t\t\t\t}\n\t\t\t\telse if(strnicmp((char *)hdrl_data+i,\"strf\",4)==0)\n\t\t\t\t{\n\t\t\t\t\ti += 8;\n\t\t\t\t\tif(lasttag == 1)\n\t\t\t\t\t{\n\t\t\t\t\t\talBITMAPINFOHEADER bih;\n\n\t\t\t\t\t\tmemcpy(&bih, hdrl_data + i, sizeof(alBITMAPINFOHEADER));\n\t\t\t\t\t\tbih.bi_size = str2ulong((unsigned char *)&bih.bi_size);\n\n\t\t\t\t\t\tif (i + bih.bi_size > hdrl_len) ERR_EXIT(AVI_ERR_READ)\n\n\t\t\t\t\t\tAVI->bitmap_info_header = (alBITMAPINFOHEADER *) gf_malloc(bih.bi_size);\n\t\t\t\t\t\tif (AVI->bitmap_info_header != NULL)\n\t\t\t\t\t\t\tmemcpy(AVI->bitmap_info_header, hdrl_data + i, bih.bi_size);\n\n\t\t\t\t\t\tAVI->width  = str2ulong(hdrl_data+i+4);\n\t\t\t\t\t\tAVI->height = str2ulong(hdrl_data+i+8);\n\t\t\t\t\t\tvids_strf_seen = 1;\n\t\t\t\t\t\t//ThOe\n\t\t\t\t\t\tAVI->v_codecf_off = header_offset + i+16;\n\n\t\t\t\t\t\tmemcpy(AVI->compressor2, hdrl_data+i+16, 4);\n\t\t\t\t\t\tAVI->compressor2[4] = 0;\n\n\t\t\t\t\t\tif (n>40) {\n\t\t\t\t\t\t\tif (n>0xFFFFFFFF) ERR_EXIT(AVI_ERR_READ)\n\t\t\t\t\t\t\tAVI->extradata_size = (u32) (n - 40);\n\t\t\t\t\t\t\tAVI->extradata = gf_malloc(sizeof(u8)* AVI->extradata_size);\n\t\t\t\t\t\t\tif (!AVI->extradata) ERR_EXIT(AVI_ERR_NO_MEM)\n\t\t\t\t\t\t\tmemcpy(AVI->extradata, hdrl_data + i + 40, AVI->extradata_size);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\t\t\t\t\telse if(lasttag == 2)\n\t\t\t\t\t{\n\t\t\t\t\t\talWAVEFORMATEX *wfe;\n\t\t\t\t\t\tchar *nwfe;\n\t\t\t\t\t\tint wfes;\n\n\t\t\t\t\t\tif ((u32) (hdrl_len - i) < sizeof(alWAVEFORMATEX))\n\t\t\t\t\t\t\twfes = (int) (hdrl_len - i);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\twfes = sizeof(alWAVEFORMATEX);\n\t\t\t\t\t\twfe = (alWAVEFORMATEX *)gf_malloc(sizeof(alWAVEFORMATEX));\n\t\t\t\t\t\tif (wfe != NULL) {\n\t\t\t\t\t\t\tmemset(wfe, 0, sizeof(alWAVEFORMATEX));\n\t\t\t\t\t\t\tmemcpy(wfe, hdrl_data + i, wfes);\n\t\t\t\t\t\t\tif (str2ushort((unsigned char *)&wfe->cb_size) != 0) {\n\t\t\t\t\t\t\t\tnwfe = (char *)\n\t\t\t\t\t\t\t\t       gf_realloc(wfe, sizeof(alWAVEFORMATEX) +\n\t\t\t\t\t\t\t\t                  str2ushort((unsigned char *)&wfe->cb_size));\n\t\t\t\t\t\t\t\tif (nwfe != 0) {\n\t\t\t\t\t\t\t\t\ts64 lpos = gf_ftell(AVI->fdes);\n\t\t\t\t\t\t\t\t\tgf_fseek(AVI->fdes, header_offset + i + sizeof(alWAVEFORMATEX),\n\t\t\t\t\t\t\t\t\t         SEEK_SET);\n\t\t\t\t\t\t\t\t\twfe = (alWAVEFORMATEX *)nwfe;\n\t\t\t\t\t\t\t\t\tnwfe = &nwfe[sizeof(alWAVEFORMATEX)];\n\t\t\t\t\t\t\t\t\tavi_read(AVI->fdes, nwfe,\n\t\t\t\t\t\t\t\t\t         str2ushort((unsigned char *)&wfe->cb_size));\n\t\t\t\t\t\t\t\t\tgf_fseek(AVI->fdes, lpos, SEEK_SET);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tAVI->wave_format_ex[AVI->aptr] = wfe;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tAVI->track[AVI->aptr].a_fmt   = str2ushort(hdrl_data+i  );\n\n\t\t\t\t\t\t//ThOe\n\t\t\t\t\t\tAVI->track[AVI->aptr].a_codecf_off = header_offset + i;\n\n\t\t\t\t\t\tAVI->track[AVI->aptr].a_chans = str2ushort(hdrl_data+i+2);\n\t\t\t\t\t\tAVI->track[AVI->aptr].a_rate  = str2ulong (hdrl_data+i+4);\n\t\t\t\t\t\t//ThOe: read mp3bitrate\n\t\t\t\t\t\tAVI->track[AVI->aptr].mp3rate = 8*str2ulong(hdrl_data+i+8)/1000;\n\t\t\t\t\t\t//:ThOe\n\t\t\t\t\t\tAVI->track[AVI->aptr].a_bits  = str2ushort(hdrl_data+i+14);\n\t\t\t\t\t\t//            auds_strf_seen = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(strnicmp((char*)hdrl_data+i,\"indx\",4) == 0) {\n\t\t\t\t\tchar *a;\n\n\t\t\t\t\tif(lasttag == 1) // V I D E O\n\t\t\t\t\t{\n\n\t\t\t\t\t\ta = (char*)hdrl_data+i;\n\t\t\t\t\t\tint avail = hdrl_len-i;\n\t\t\t\t\t\tif (avail<32) ERR_EXIT(AVI_ERR_READ)\n\n\t\t\t\t\t\tAVI->video_superindex = (avisuperindex_chunk *) gf_malloc (sizeof (avisuperindex_chunk));\n\t\t\t\t\t\tmemset(AVI->video_superindex, 0, sizeof (avisuperindex_chunk));\n\t\t\t\t\t\tmemcpy (AVI->video_superindex->fcc, a, 4);\n\t\t\t\t\t\ta += 4;\n\t\t\t\t\t\tAVI->video_superindex->dwSize = str2ulong((unsigned char *)a);\n\t\t\t\t\t\ta += 4;\n\t\t\t\t\t\tAVI->video_superindex->wLongsPerEntry = str2ushort((unsigned char *)a);\n\t\t\t\t\t\ta += 2;\n\t\t\t\t\t\tAVI->video_superindex->bIndexSubType = *a;\n\t\t\t\t\t\ta += 1;\n\t\t\t\t\t\tAVI->video_superindex->bIndexType = *a;\n\t\t\t\t\t\ta += 1;\n\t\t\t\t\t\tAVI->video_superindex->nEntriesInUse = str2ulong((unsigned char *)a);\n\t\t\t\t\t\ta += 4;\n\t\t\t\t\t\tmemcpy (AVI->video_superindex->dwChunkId, a, 4);\n\t\t\t\t\t\ta += 4;\n\n\t\t\t\t\t\t// 3 * reserved\n\t\t\t\t\t\ta += 4;\n\t\t\t\t\t\ta += 4;\n\t\t\t\t\t\ta += 4;\n\n\t\t\t\t\t\tif (AVI->video_superindex->bIndexSubType != 0) {\n\t\t\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[avilib] Invalid Header, bIndexSubType != 0\\n\"));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tavail -= 32;\n\t\t\t\t\t\tif (avail < AVI->video_superindex->nEntriesInUse*16) ERR_EXIT(AVI_ERR_READ)\n\n\t\t\t\t\t\tAVI->video_superindex->aIndex = (avisuperindex_entry*)\n\t\t\t\t\t\t                                gf_malloc (AVI->video_superindex->wLongsPerEntry * AVI->video_superindex->nEntriesInUse * sizeof (u32));\n\n\t\t\t\t\t\t// position of ix## chunks\n\t\t\t\t\t\tfor (j=0; j<AVI->video_superindex->nEntriesInUse; ++j) {\n\t\t\t\t\t\t\tAVI->video_superindex->aIndex[j].qwOffset = str2ullong ((unsigned char*)a);\n\t\t\t\t\t\t\ta += 8;\n\t\t\t\t\t\t\tAVI->video_superindex->aIndex[j].dwSize = str2ulong ((unsigned char*)a);\n\t\t\t\t\t\t\ta += 4;\n\t\t\t\t\t\t\tAVI->video_superindex->aIndex[j].dwDuration = str2ulong ((unsigned char*)a);\n\t\t\t\t\t\t\ta += 4;\n\n#ifdef DEBUG_ODML\n\t\t\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] [%d] 0x%llx 0x%lx %lu\\n\", j,\n\t\t\t\t\t\t\t                                        (unsigned int long)AVI->video_superindex->aIndex[j].qwOffset,\n\t\t\t\t\t\t\t                                        (unsigned long)AVI->video_superindex->aIndex[j].dwSize,\n\t\t\t\t\t\t\t                                        (unsigned long)AVI->video_superindex->aIndex[j].dwDuration));\n#endif\n\t\t\t\t\t\t}\n\n\n#ifdef DEBUG_ODML\n\t\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] FOURCC \\\"%c%c%c%c\\\"\\n\", AVI->video_superindex->fcc[0], AVI->video_superindex->fcc[1],\n\t\t\t\t\t\t                                        AVI->video_superindex->fcc[2], AVI->video_superindex->fcc[3]));\n\t\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] LEN \\\"%ld\\\"\\n\", (long)AVI->video_superindex->dwSize));\n\t\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] wLongsPerEntry \\\"%d\\\"\\n\", AVI->video_superindex->wLongsPerEntry));\n\t\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] bIndexSubType \\\"%d\\\"\\n\", AVI->video_superindex->bIndexSubType));\n\t\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] bIndexType \\\"%d\\\"\\n\", AVI->video_superindex->bIndexType));\n\t\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] nEntriesInUse \\\"%ld\\\"\\n\", (long)AVI->video_superindex->nEntriesInUse));\n\t\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] dwChunkId \\\"%c%c%c%c\\\"\\n\", AVI->video_superindex->dwChunkId[0], AVI->video_superindex->dwChunkId[1],\n\t\t\t\t\t\t                                        AVI->video_superindex->dwChunkId[2], AVI->video_superindex->dwChunkId[3]));\n#endif\n\n\t\t\t\t\t\tAVI->is_opendml = 1;\n\n\t\t\t\t\t}\n\t\t\t\t\telse if(lasttag == 2) // A U D I O\n\t\t\t\t\t{\n\n\t\t\t\t\t\ta = (char*) hdrl_data+i;\n\t\t\t\t\t\tint avail = hdrl_len-i;\n\t\t\t\t\t\tif (avail<32) ERR_EXIT(AVI_ERR_READ)\n\n\t\t\t\t\t\tAVI->track[AVI->aptr].audio_superindex = (avisuperindex_chunk *) gf_malloc (sizeof (avisuperindex_chunk));\n\t\t\t\t\t\tmemcpy (AVI->track[AVI->aptr].audio_superindex->fcc, a, 4);\n\t\t\t\t\t\ta += 4;\n\t\t\t\t\t\tAVI->track[AVI->aptr].audio_superindex->dwSize = str2ulong((unsigned char*)a);\n\t\t\t\t\t\ta += 4;\n\t\t\t\t\t\tAVI->track[AVI->aptr].audio_superindex->wLongsPerEntry = str2ushort((unsigned char*)a);\n\t\t\t\t\t\ta += 2;\n\t\t\t\t\t\tAVI->track[AVI->aptr].audio_superindex->bIndexSubType = *a;\n\t\t\t\t\t\ta += 1;\n\t\t\t\t\t\tAVI->track[AVI->aptr].audio_superindex->bIndexType = *a;\n\t\t\t\t\t\ta += 1;\n\t\t\t\t\t\tAVI->track[AVI->aptr].audio_superindex->nEntriesInUse = str2ulong((unsigned char*)a);\n\t\t\t\t\t\ta += 4;\n\t\t\t\t\t\tmemcpy (AVI->track[AVI->aptr].audio_superindex->dwChunkId, a, 4);\n\t\t\t\t\t\ta += 4;\n\n\t\t\t\t\t\t// 3 * reserved\n\t\t\t\t\t\ta += 4;\n\t\t\t\t\t\ta += 4;\n\t\t\t\t\t\ta += 4;\n\n\t\t\t\t\t\tif (AVI->track[AVI->aptr].audio_superindex->bIndexSubType != 0) {\n\t\t\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[avilib] Invalid Header, bIndexSubType != 0\\n\"));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tavail -= 32;\n\t\t\t\t\t\tif (avail < AVI->track[AVI->aptr].audio_superindex->nEntriesInUse*16) ERR_EXIT(AVI_ERR_READ)\n\n\t\t\t\t\t\tAVI->track[AVI->aptr].audio_superindex->aIndex = (avisuperindex_entry*)\n\t\t\t\t\t\t        gf_malloc (AVI->track[AVI->aptr].audio_superindex->wLongsPerEntry *\n\t\t\t\t\t\t                   AVI->track[AVI->aptr].audio_superindex->nEntriesInUse * sizeof (u32));\n\n\t\t\t\t\t\t// position of ix## chunks\n\t\t\t\t\t\tfor (j=0; j<AVI->track[AVI->aptr].audio_superindex->nEntriesInUse; ++j) {\n\t\t\t\t\t\t\tAVI->track[AVI->aptr].audio_superindex->aIndex[j].qwOffset = str2ullong ((unsigned char*)a);\n\t\t\t\t\t\t\ta += 8;\n\t\t\t\t\t\t\tAVI->track[AVI->aptr].audio_superindex->aIndex[j].dwSize = str2ulong ((unsigned char*)a);\n\t\t\t\t\t\t\ta += 4;\n\t\t\t\t\t\t\tAVI->track[AVI->aptr].audio_superindex->aIndex[j].dwDuration = str2ulong ((unsigned char*)a);\n\t\t\t\t\t\t\ta += 4;\n\n#ifdef DEBUG_ODML\n\t\t\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] [%d] 0x%llx 0x%lx %lu\\n\", j,\n\t\t\t\t\t\t\t                                        (unsigned int long)AVI->track[AVI->aptr].audio_superindex->aIndex[j].qwOffset,\n\t\t\t\t\t\t\t                                        (unsigned long)AVI->track[AVI->aptr].audio_superindex->aIndex[j].dwSize,\n\t\t\t\t\t\t\t                                        (unsigned long)AVI->track[AVI->aptr].audio_superindex->aIndex[j].dwDuration));\n#endif\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tAVI->track[AVI->aptr].audio_superindex->stdindex = NULL;\n\n#ifdef DEBUG_ODML\n\t\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] FOURCC \\\"%.4s\\\"\\n\", AVI->track[AVI->aptr].audio_superindex->fcc));\n\t\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] LEN \\\"%ld\\\"\\n\", (long)AVI->track[AVI->aptr].audio_superindex->dwSize));\n\t\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] wLongsPerEntry \\\"%d\\\"\\n\", AVI->track[AVI->aptr].audio_superindex->wLongsPerEntry));\n\t\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] bIndexSubType \\\"%d\\\"\\n\", AVI->track[AVI->aptr].audio_superindex->bIndexSubType));\n\t\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] bIndexType \\\"%d\\\"\\n\", AVI->track[AVI->aptr].audio_superindex->bIndexType));\n\t\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] nEntriesInUse \\\"%ld\\\"\\n\", (long)AVI->track[AVI->aptr].audio_superindex->nEntriesInUse));\n\t\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] dwChunkId \\\"%.4s\\\"\\n\", AVI->track[AVI->aptr].audio_superindex->dwChunkId[0]));\n#endif\n\n\t\t\t\t\t}\n\t\t\t\t\ti += 8;\n\t\t\t\t}\n\t\t\t\telse if((strnicmp((char*)hdrl_data+i,\"JUNK\",4) == 0) ||\n\t\t\t\t        (strnicmp((char*)hdrl_data+i,\"strn\",4) == 0) ||\n\t\t\t\t        (strnicmp((char*)hdrl_data+i,\"vprp\",4) == 0)) {\n\t\t\t\t\ti += 8;\n\t\t\t\t\t// do not reset lasttag\n\t\t\t\t} else\n\t\t\t\t{\n\t\t\t\t\ti += 8;\n\t\t\t\t\tlasttag = 0;\n\t\t\t\t}\n\t\t\t\t//GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] adding %ld bytes\\n\", (int int)n));\n\n\t\t\t\ti += (u32) n;\n\t\t\t}\n\n\tgf_free(hdrl_data);\n\n\tif(!vids_strh_seen || !vids_strf_seen) ERR_EXIT(AVI_ERR_NO_VIDS)\n\n\t\tAVI->video_tag[0] = AVI->video_strn/10 + '0';\n\tAVI->video_tag[1] = AVI->video_strn%10 + '0';\n\tAVI->video_tag[2] = 'd';\n\tAVI->video_tag[3] = 'b';\n\n\t/* Audio tag is set to \"99wb\" if no audio present */\n\tif(!AVI->track[0].a_chans) AVI->track[0].audio_strn = 99;\n\n\t{\n\t\tint tk=0;\n\t\tfor(j=0; j<AVI->anum+1; ++j) {\n\t\t\tif (j == AVI->video_strn) continue;\n\t\t\tAVI->track[tk].audio_tag[0] = j/10 + '0';\n\t\t\tAVI->track[tk].audio_tag[1] = j%10 + '0';\n\t\t\tAVI->track[tk].audio_tag[2] = 'w';\n\t\t\tAVI->track[tk].audio_tag[3] = 'b';\n\t\t\t++tk;\n\t\t}\n\t}\n\n\tgf_fseek(AVI->fdes,AVI->movi_start,SEEK_SET);\n\n\tif(!getIndex) return(0);\n\n\t/* if the file has an idx1, check if this is relative\n\t   to the start of the file or to the start of the movi list */\n\n\tidx_type = 0;\n\n\tif(AVI->idx)\n\t{\n\t\ts64 pos, len;\n\n\t\t/* Search the first videoframe in the idx1 and look where\n\t\t   it is in the file */\n\n\t\tfor(i=0; i<AVI->n_idx; i++)\n\t\t\tif( strnicmp((char *)AVI->idx[i],(char *)AVI->video_tag,3)==0 ) break;\n\t\tif(i>=AVI->n_idx) ERR_EXIT(AVI_ERR_NO_VIDS)\n\n\t\t\tpos = str2ulong(AVI->idx[i]+ 8);\n\t\tlen = str2ulong(AVI->idx[i]+12);\n\n\t\tgf_fseek(AVI->fdes,pos,SEEK_SET);\n\t\tif(avi_read(AVI->fdes,data,8)!=8) ERR_EXIT(AVI_ERR_READ)\n\t\t\tif( strnicmp(data,(char *)AVI->idx[i],4)==0 && str2ulong((unsigned char *)data+4)==len )\n\t\t\t{\n\t\t\t\tidx_type = 1; /* Index from start of file */\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tgf_fseek(AVI->fdes,pos+AVI->movi_start-4,SEEK_SET);\n\t\t\t\tif(avi_read(AVI->fdes,data,8)!=8) ERR_EXIT(AVI_ERR_READ)\n\t\t\t\t\tif( strnicmp(data,(char *)AVI->idx[i],4)==0 && str2ulong((unsigned char *)data+4)==len )\n\t\t\t\t\t{\n\t\t\t\t\t\tidx_type = 2; /* Index from start of movi list */\n\t\t\t\t\t}\n\t\t\t}\n\t\t/* idx_type remains 0 if neither of the two tests above succeeds */\n\t}\n\n\n\tif(idx_type == 0 && !AVI->is_opendml && !AVI->total_frames)\n\t{\n\t\t/* we must search through the file to get the index */\n\n\t\tgf_fseek(AVI->fdes, AVI->movi_start, SEEK_SET);\n\n\t\tAVI->n_idx = 0;\n\n\t\twhile(1)\n\t\t{\n\t\t\tif( avi_read(AVI->fdes,data,8) != 8 ) break;\n\t\t\tn = str2ulong((unsigned char *)data+4);\n\n\t\t\t/* The movi list may contain sub-lists, ignore them */\n\n\t\t\tif(strnicmp(data,\"LIST\",4)==0)\n\t\t\t{\n\t\t\t\tgf_fseek(AVI->fdes,4,SEEK_CUR);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* Check if we got a tag ##db, ##dc or ##wb */\n\n\t\t\tif( ( (data[2]=='d' || data[2]=='D') &&\n\t\t\t        (data[3]=='b' || data[3]=='B' || data[3]=='c' || data[3]=='C') )\n\t\t\t        || ( (data[2]=='w' || data[2]=='W') &&\n\t\t\t             (data[3]=='b' || data[3]=='B') ) )\n\t\t\t{\n\t\t\t\tu64 __pos = gf_ftell(AVI->fdes) - 8;\n\t\t\t\tavi_add_index_entry(AVI,(unsigned char *)data,0,__pos,n);\n\t\t\t}\n\n\t\t\tgf_fseek(AVI->fdes,PAD_EVEN(n),SEEK_CUR);\n\t\t}\n\t\tidx_type = 1;\n\t}\n\n\t// ************************\n\t// OPENDML\n\t// ************************\n\n\t// read extended index chunks\n\tif (AVI->is_opendml) {\n\t\tu64 offset = 0;\n\t\thdrl_len = 4+4+2+1+1+4+4+8+4;\n\t\tchar *en, *chunk_start;\n\t\tint k = 0;\n\t\tu32 audtr = 0;\n\t\tu32 nrEntries = 0;\n\n\t\tAVI->video_index = NULL;\n\n\t\tnvi = 0;\n\t\tfor(audtr=0; audtr<AVI->anum; ++audtr) {\n\t\t\tnai[audtr] = 0;\n\t\t\ttot[audtr] = 0;\n\t\t}\n\n\t\t// ************************\n\t\t// VIDEO\n\t\t// ************************\n\n\t\tfor (j=0; j<AVI->video_superindex->nEntriesInUse; j++) {\n\n\t\t\t// read from file\n\t\t\tchunk_start = en = (char*) gf_malloc ((u32) (AVI->video_superindex->aIndex[j].dwSize+hdrl_len) );\n\n\t\t\tif (gf_fseek(AVI->fdes, AVI->video_superindex->aIndex[j].qwOffset, SEEK_SET) == (u64)-1) {\n\t\t\t\tgf_free(chunk_start);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (avi_read(AVI->fdes, en, (u32) (AVI->video_superindex->aIndex[j].dwSize+hdrl_len) ) <= 0) {\n\t\t\t\tgf_free(chunk_start);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tnrEntries = str2ulong((unsigned char*)en + 12);\n#ifdef DEBUG_ODML\n\t\t\t//GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] [%d:0] Video nrEntries %ld\\n\", j, nrEntries));\n#endif\n\t\t\toffset = str2ullong((unsigned char*)en + 20);\n\n\t\t\t// skip header\n\t\t\ten += hdrl_len;\n\t\t\tnvi += nrEntries;\n\t\t\tAVI->video_index = (video_index_entry *) gf_realloc (AVI->video_index, nvi * sizeof (video_index_entry));\n\t\t\tif (!AVI->video_index) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[avilib] out of mem (size = %ld)\\n\", nvi * sizeof (video_index_entry)));\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\twhile (k < nvi) {\n\n\t\t\t\tAVI->video_index[k].pos = offset + str2ulong((unsigned char*)en);\n\t\t\t\ten += 4;\n\t\t\t\tAVI->video_index[k].len = str2ulong_len((unsigned char*)en);\n\t\t\t\tAVI->video_index[k].key = str2ulong_key((unsigned char*)en);\n\t\t\t\ten += 4;\n\n\t\t\t\t// completely empty chunk\n\t\t\t\tif (AVI->video_index[k].pos-offset == 0 && AVI->video_index[k].len == 0) {\n\t\t\t\t\tk--;\n\t\t\t\t\tnvi--;\n\t\t\t\t}\n\n#ifdef DEBUG_ODML\n\t\t\t\t/*\n\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] [%d] POS 0x%llX len=%d key=%s offset (%llx) (%ld)\\n\", k,\n\t\t\t\t  AVI->video_index[k].pos,\n\t\t\t\t  (int)AVI->video_index[k].len,\n\t\t\t\t  AVI->video_index[k].key?\"yes\":\"no \", offset,\n\t\t\t\t  AVI->video_superindex->aIndex[j].dwSize));\n\t\t\t\t  */\n#endif\n\n\t\t\t\tk++;\n\t\t\t}\n\n\t\t\tgf_free(chunk_start);\n\t\t}\n\n\t\tAVI->video_frames = nvi;\n\t\t// this should deal with broken 'rec ' odml files.\n\t\tif (AVI->video_frames == 0) {\n\t\t\tAVI->is_opendml=0;\n\t\t\tgoto multiple_riff;\n\t\t}\n\n\t\t// ************************\n\t\t// AUDIO\n\t\t// ************************\n\n\t\tfor(audtr=0; audtr<AVI->anum; ++audtr) {\n\n\t\t\tk = 0;\n\t\t\tif (!AVI->track[audtr].audio_superindex) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[avilib] (%s) cannot read audio index for track %d\\n\", __FILE__, audtr));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor (j=0; j<AVI->track[audtr].audio_superindex->nEntriesInUse; j++) {\n\n\t\t\t\t// read from file\n\t\t\t\tchunk_start = en = (char*)gf_malloc ((u32) (AVI->track[audtr].audio_superindex->aIndex[j].dwSize+hdrl_len));\n\n\t\t\t\tif (gf_fseek(AVI->fdes, AVI->track[audtr].audio_superindex->aIndex[j].qwOffset, SEEK_SET) == (u64)-1) {\n\t\t\t\t\tgf_free(chunk_start);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (avi_read(AVI->fdes, en, (u32) (AVI->track[audtr].audio_superindex->aIndex[j].dwSize+hdrl_len)) <= 0) {\n\t\t\t\t\tgf_free(chunk_start);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tnrEntries = str2ulong((unsigned char*)en + 12);\n\t\t\t\t//if (nrEntries > 50) nrEntries = 2; // XXX\n#ifdef DEBUG_ODML\n\t\t\t\t//GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] [%d:%d] Audio nrEntries %ld\\n\", j, audtr, nrEntries));\n#endif\n\t\t\t\toffset = str2ullong((unsigned char*)en + 20);\n\n\t\t\t\t// skip header\n\t\t\t\ten += hdrl_len;\n\t\t\t\tnai[audtr] += nrEntries;\n\t\t\t\tAVI->track[audtr].audio_index = (audio_index_entry *) gf_realloc (AVI->track[audtr].audio_index, nai[audtr] * sizeof (audio_index_entry));\n\n\t\t\t\twhile (k < nai[audtr]) {\n\n\t\t\t\t\tAVI->track[audtr].audio_index[k].pos = offset + str2ulong((unsigned char*)en);\n\t\t\t\t\ten += 4;\n\t\t\t\t\tAVI->track[audtr].audio_index[k].len = str2ulong_len((unsigned char*)en);\n\t\t\t\t\ten += 4;\n\t\t\t\t\tAVI->track[audtr].audio_index[k].tot = tot[audtr];\n\t\t\t\t\ttot[audtr] += AVI->track[audtr].audio_index[k].len;\n\n#ifdef DEBUG_ODML\n\t\t\t\t\t/*\n\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] [%d:%d] POS 0x%llX len=%d offset (%llx) (%ld)\\n\", k, audtr,\n\t\t\t\t\t  AVI->track[audtr].audio_index[k].pos,\n\t\t\t\t\t  (int)AVI->track[audtr].audio_index[k].len,\n\t\t\t\t\t  offset, AVI->track[audtr].audio_superindex->aIndex[j].dwSize));\n\t\t\t\t\t  */\n#endif\n\n\t\t\t\t\t++k;\n\t\t\t\t}\n\n\t\t\t\tgf_free(chunk_start);\n\t\t\t}\n\n\t\t\tAVI->track[audtr].audio_chunks = nai[audtr];\n\t\t\tAVI->track[audtr].audio_bytes = tot[audtr];\n\t\t}\n\t} // is opendml\n\n\telse if (AVI->total_frames && !AVI->is_opendml && idx_type==0) {\n\n\t\t// *********************\n\t\t// MULTIPLE RIFF CHUNKS (and no index)\n\t\t// *********************\n\nmultiple_riff:\n\n\t\tgf_fseek(AVI->fdes, AVI->movi_start, SEEK_SET);\n\n\t\tAVI->n_idx = 0;\n\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] Reconstructing index...\"));\n\n\t\t// Number of frames; only one audio track supported\n\t\tnvi = AVI->video_frames = AVI->total_frames;\n\t\tnai[0] = AVI->track[0].audio_chunks = AVI->total_frames;\n\t\tfor(j=1; j<AVI->anum; ++j) AVI->track[j].audio_chunks = 0;\n\n\t\tAVI->video_index = (video_index_entry *) gf_malloc(nvi*sizeof(video_index_entry));\n\n\t\tif(AVI->video_index==0) ERR_EXIT(AVI_ERR_NO_MEM);\n\n\t\tfor(j=0; j<AVI->anum; ++j) {\n\t\t\tif(AVI->track[j].audio_chunks) {\n\t\t\t\tAVI->track[j].audio_index = (audio_index_entry *) gf_malloc((nai[j]+1)*sizeof(audio_index_entry));\n\t\t\t\tmemset(AVI->track[j].audio_index, 0, (nai[j]+1)*(sizeof(audio_index_entry)));\n\t\t\t\tif(AVI->track[j].audio_index==0) ERR_EXIT(AVI_ERR_NO_MEM);\n\t\t\t}\n\t\t}\n\n\t\tnvi = 0;\n\t\tfor(j=0; j<AVI->anum; ++j) {\n\t\t\tnai[j] = 0;\n\t\t\ttot[j] = 0;\n\t\t}\n\n\t\taud_chunks = AVI->total_frames;\n\n\t\twhile(1)\n\t\t{\n\t\t\tif (nvi >= AVI->total_frames) break;\n\n\t\t\tif( avi_read(AVI->fdes,data,8) != 8 ) break;\n\t\t\tn = str2ulong((unsigned char *)data+4);\n\n\n\t\t\tj=0;\n\n\t\t\tif (aud_chunks - nai[j] -1 <= 0) {\n\t\t\t\taud_chunks += AVI->total_frames;\n\t\t\t\tAVI->track[j].audio_index = (audio_index_entry *)\n\t\t\t\t                            gf_realloc( AVI->track[j].audio_index, (aud_chunks+1)*sizeof(audio_index_entry));\n\t\t\t\tif (!AVI->track[j].audio_index) {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[avilib] Internal error in avilib -- no mem\\n\"));\n\t\t\t\t\tAVI_errno = AVI_ERR_NO_MEM;\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* Check if we got a tag ##db, ##dc or ##wb */\n\n\t\t\t// VIDEO\n\t\t\tif(\n\t\t\t    (data[0]=='0' || data[1]=='0') &&\n\t\t\t    (data[2]=='d' || data[2]=='D') &&\n\t\t\t    (data[3]=='b' || data[3]=='B' || data[3]=='c' || data[3]=='C') ) {\n\n\t\t\t\tAVI->video_index[nvi].key = 0x0;\n\t\t\t\tAVI->video_index[nvi].pos = gf_ftell(AVI->fdes);\n\t\t\t\tAVI->video_index[nvi].len = (u32) n;\n\n\t\t\t\t/*\n\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] Frame %ld pos %\"LLD\" len %\"LLD\" key %ld\\n\",\n\t\t\t\t    nvi, AVI->video_index[nvi].pos,  AVI->video_index[nvi].len, (long)AVI->video_index[nvi].key));\n\t\t\t\t    */\n\t\t\t\tnvi++;\n\t\t\t\tgf_fseek(AVI->fdes,PAD_EVEN(n),SEEK_CUR);\n\t\t\t}\n\n\t\t\t//AUDIO\n\t\t\telse if(\n\t\t\t    (data[0]=='0' || data[1]=='1') &&\n\t\t\t    (data[2]=='w' || data[2]=='W') &&\n\t\t\t    (data[3]=='b' || data[3]=='B') ) {\n\n\n\t\t\t\tAVI->track[j].audio_index[nai[j]].pos = gf_ftell(AVI->fdes);\n\t\t\t\tAVI->track[j].audio_index[nai[j]].len = (u32) n;\n\t\t\t\tAVI->track[j].audio_index[nai[j]].tot = tot[j];\n\t\t\t\ttot[j] += AVI->track[j].audio_index[nai[j]].len;\n\t\t\t\tnai[j]++;\n\n\t\t\t\tgf_fseek(AVI->fdes,PAD_EVEN(n),SEEK_CUR);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tgf_fseek(AVI->fdes,-4,SEEK_CUR);\n\t\t\t}\n\n\t\t}\n\t\tif (nvi < AVI->total_frames) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[avilib] Uh? Some frames seems missing (%ld/%d)\\n\",\n\t\t\t        nvi,  AVI->total_frames));\n\t\t}\n\n\n\t\tAVI->video_frames = nvi;\n\t\tAVI->track[0].audio_chunks = nai[0];\n\n\t\tfor(j=0; j<AVI->anum; ++j) AVI->track[j].audio_bytes = tot[j];\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] done. nvi=%ld nai=%ld tot=%ld\\n\", nvi, nai[0], tot[0]));\n\n\t} // total_frames but no indx chunk (xawtv does this)\n\n\telse\n\n\t{\n\t\t// ******************\n\t\t// NO OPENDML\n\t\t// ******************\n\n\t\t/* Now generate the video index and audio index arrays */\n\n\t\tnvi = 0;\n\t\tfor(j=0; j<AVI->anum; ++j) nai[j] = 0;\n\n\t\tfor(i=0; i<AVI->n_idx; i++) {\n\n\t\t\tif(strnicmp((char *)AVI->idx[i],AVI->video_tag,3) == 0) nvi++;\n\n\t\t\tfor(j=0; j<AVI->anum; ++j) if(strnicmp((char *)AVI->idx[i], AVI->track[j].audio_tag,4) == 0) nai[j]++;\n\t\t}\n\n\t\tAVI->video_frames = nvi;\n\t\tfor(j=0; j<AVI->anum; ++j) AVI->track[j].audio_chunks = nai[j];\n\n\n\t\tif(AVI->video_frames==0) ERR_EXIT(AVI_ERR_NO_VIDS);\n\t\tAVI->video_index = (video_index_entry *) gf_malloc(nvi*sizeof(video_index_entry));\n\t\tif(AVI->video_index==0) ERR_EXIT(AVI_ERR_NO_MEM);\n\n\t\tfor(j=0; j<AVI->anum; ++j) {\n\t\t\tif(AVI->track[j].audio_chunks) {\n\t\t\t\tAVI->track[j].audio_index = (audio_index_entry *) gf_malloc((nai[j]+1)*sizeof(audio_index_entry));\n\t\t\t\tmemset(AVI->track[j].audio_index, 0, (nai[j]+1)*(sizeof(audio_index_entry)));\n\t\t\t\tif(AVI->track[j].audio_index==0) ERR_EXIT(AVI_ERR_NO_MEM);\n\t\t\t}\n\t\t}\n\n\t\tnvi = 0;\n\t\tfor(j=0; j<AVI->anum; ++j) {\n\t\t\tnai[j] = 0;\n\t\t\ttot[j] = 0;\n\t\t}\n\n\t\tioff = idx_type == 1 ? 8 : (u32)AVI->movi_start+4;\n\n\t\tfor(i=0; i<AVI->n_idx; i++) {\n\n\t\t\t//video\n\t\t\tif(strnicmp((char *)AVI->idx[i],AVI->video_tag,3) == 0) {\n\t\t\t\tAVI->video_index[nvi].key = str2ulong(AVI->idx[i]+ 4);\n\t\t\t\tAVI->video_index[nvi].pos = str2ulong(AVI->idx[i]+ 8)+ioff;\n\t\t\t\tAVI->video_index[nvi].len = str2ulong(AVI->idx[i]+12);\n\t\t\t\tnvi++;\n\t\t\t}\n\n\t\t\t//audio\n\t\t\tfor(j=0; j<AVI->anum; ++j) {\n\n\t\t\t\tif(strnicmp((char *)AVI->idx[i],AVI->track[j].audio_tag,4) == 0) {\n\t\t\t\t\tAVI->track[j].audio_index[nai[j]].pos = str2ulong(AVI->idx[i]+ 8)+ioff;\n\t\t\t\t\tAVI->track[j].audio_index[nai[j]].len = str2ulong(AVI->idx[i]+12);\n\t\t\t\t\tAVI->track[j].audio_index[nai[j]].tot = tot[j];\n\t\t\t\t\ttot[j] += AVI->track[j].audio_index[nai[j]].len;\n\t\t\t\t\tnai[j]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\t\tfor(j=0; j<AVI->anum; ++j) AVI->track[j].audio_bytes = tot[j];\n\n\t} // is no opendml\n\n\t/* Reposition the file */\n\n\tgf_fseek(AVI->fdes,AVI->movi_start,SEEK_SET);\n\tAVI->video_pos = 0;\n\n\treturn(0);\n}\n\nint AVI_video_frames(avi_t *AVI)\n{\n\treturn AVI->video_frames;\n}\nint  AVI_video_width(avi_t *AVI)\n{\n\treturn AVI->width;\n}\nint  AVI_video_height(avi_t *AVI)\n{\n\treturn AVI->height;\n}\ndouble AVI_frame_rate(avi_t *AVI)\n{\n\treturn AVI->fps;\n}\nchar* AVI_video_compressor(avi_t *AVI)\n{\n\treturn AVI->compressor2;\n}\n\n#if 0\nint AVI_max_video_chunk(avi_t *AVI)\n{\n\treturn AVI->max_len;\n}\n#endif\n\nint AVI_audio_tracks(avi_t *AVI)\n{\n\treturn(AVI->anum);\n}\n\nint AVI_audio_channels(avi_t *AVI)\n{\n\treturn AVI->track[AVI->aptr].a_chans;\n}\n\nint AVI_audio_mp3rate(avi_t *AVI)\n{\n\treturn AVI->track[AVI->aptr].mp3rate;\n}\n\n#if 0 //unused\nint AVI_audio_padrate(avi_t *AVI)\n{\n\treturn AVI->track[AVI->aptr].padrate;\n}\n#endif\n\nint AVI_audio_bits(avi_t *AVI)\n{\n\treturn AVI->track[AVI->aptr].a_bits;\n}\n\nint AVI_audio_format(avi_t *AVI)\n{\n\treturn AVI->track[AVI->aptr].a_fmt;\n}\n\nint AVI_audio_rate(avi_t *AVI)\n{\n\treturn AVI->track[AVI->aptr].a_rate;\n}\n\n\nint AVI_frame_size(avi_t *AVI, int frame)\n{\n\tif(AVI->mode==AVI_MODE_WRITE) {\n\t\tAVI_errno = AVI_ERR_NOT_PERM;\n\t\treturn -1;\n\t}\n\tif(!AVI->video_index)         {\n\t\tAVI_errno = AVI_ERR_NO_IDX;\n\t\treturn -1;\n\t}\n\n\tif(frame < 0 || frame >= AVI->video_frames) return 0;\n\treturn (u32) (AVI->video_index[frame].len);\n}\n\nint AVI_audio_size(avi_t *AVI, int frame)\n{\n\tif(AVI->mode==AVI_MODE_WRITE) {\n\t\tAVI_errno = AVI_ERR_NOT_PERM;\n\t\treturn -1;\n\t}\n\tif(!AVI->track[AVI->aptr].audio_index)         {\n\t\tAVI_errno = AVI_ERR_NO_IDX;\n\t\treturn -1;\n\t}\n\n\tif(frame < 0 || frame >= AVI->track[AVI->aptr].audio_chunks) return -1;\n\treturn (u32) (AVI->track[AVI->aptr].audio_index[frame].len);\n}\n\nu64 AVI_get_video_position(avi_t *AVI, int frame)\n{\n\tif(AVI->mode==AVI_MODE_WRITE) {\n\t\tAVI_errno = AVI_ERR_NOT_PERM;\n\t\treturn (u64) -1;\n\t}\n\tif(!AVI->video_index)         {\n\t\tAVI_errno = AVI_ERR_NO_IDX;\n\t\treturn (u64) -1;\n\t}\n\n\tif(frame < 0 || frame >= AVI->video_frames) return 0;\n\treturn(AVI->video_index[frame].pos);\n}\n\n\nint AVI_seek_start(avi_t *AVI)\n{\n\tif(AVI->mode==AVI_MODE_WRITE) {\n\t\tAVI_errno = AVI_ERR_NOT_PERM;\n\t\treturn -1;\n\t}\n\n\tgf_fseek(AVI->fdes,AVI->movi_start,SEEK_SET);\n\tAVI->video_pos = 0;\n\treturn 0;\n}\n\nint AVI_set_video_position(avi_t *AVI, int frame)\n{\n\tif(AVI->mode==AVI_MODE_WRITE) {\n\t\tAVI_errno = AVI_ERR_NOT_PERM;\n\t\treturn -1;\n\t}\n\tif(!AVI->video_index)         {\n\t\tAVI_errno = AVI_ERR_NO_IDX;\n\t\treturn -1;\n\t}\n\n\tif (frame < 0 ) frame = 0;\n\tAVI->video_pos = frame;\n\treturn 0;\n}\n\n#if 0 //unused\nint AVI_set_audio_bitrate(avi_t *AVI, int bitrate)\n{\n\tif(AVI->mode==AVI_MODE_READ) {\n\t\tAVI_errno = AVI_ERR_NOT_PERM;\n\t\treturn -1;\n\t}\n\n\tAVI->track[AVI->aptr].mp3rate = bitrate;\n\treturn 0;\n}\n#endif\n\nint AVI_read_frame(avi_t *AVI, u8 *vidbuf, int *keyframe)\n{\n\tint n;\n\n\tif(AVI->mode==AVI_MODE_WRITE) {\n\t\tAVI_errno = AVI_ERR_NOT_PERM;\n\t\treturn -1;\n\t}\n\tif(!AVI->video_index)         {\n\t\tAVI_errno = AVI_ERR_NO_IDX;\n\t\treturn -1;\n\t}\n\n\tif(AVI->video_pos < 0 || AVI->video_pos >= AVI->video_frames) return -1;\n\tn = (u32) AVI->video_index[AVI->video_pos].len;\n\n\t*keyframe = (AVI->video_index[AVI->video_pos].key==0x10) ? 1:0;\n\n\tif (vidbuf == NULL) {\n\t\tAVI->video_pos++;\n\t\treturn n;\n\t}\n\n\tgf_fseek(AVI->fdes, AVI->video_index[AVI->video_pos].pos, SEEK_SET);\n\tAVI->video_pos++;\n\n\tif (avi_read(AVI->fdes,vidbuf,n) != (u32) n)\n\t{\n\t\tAVI_errno = AVI_ERR_READ;\n\t\treturn -1;\n\t}\n\n\treturn n;\n}\n\n#if 0 //unused\nint AVI_get_audio_position_index(avi_t *AVI)\n{\n\tif(AVI->mode==AVI_MODE_WRITE) {\n\t\tAVI_errno = AVI_ERR_NOT_PERM;\n\t\treturn -1;\n\t}\n\tif(!AVI->track[AVI->aptr].audio_index) {\n\t\tAVI_errno = AVI_ERR_NO_IDX;\n\t\treturn -1;\n\t}\n\n\treturn (AVI->track[AVI->aptr].audio_posc);\n}\n\nint AVI_set_audio_position_index(avi_t *AVI, int indexpos)\n{\n\tif(AVI->mode==AVI_MODE_WRITE) {\n\t\tAVI_errno = AVI_ERR_NOT_PERM;\n\t\treturn -1;\n\t}\n\tif(!AVI->track[AVI->aptr].audio_index)         {\n\t\tAVI_errno = AVI_ERR_NO_IDX;\n\t\treturn -1;\n\t}\n\tif(indexpos > AVI->track[AVI->aptr].audio_chunks)     {\n\t\tAVI_errno = AVI_ERR_NO_IDX;\n\t\treturn -1;\n\t}\n\n\tAVI->track[AVI->aptr].audio_posc = indexpos;\n\tAVI->track[AVI->aptr].audio_posb = 0;\n\n\treturn 0;\n}\n#endif\n\n\nint AVI_set_audio_position(avi_t *AVI, int byte)\n{\n\tint n0, n1;\n\n\tif(AVI->mode==AVI_MODE_WRITE) {\n\t\tAVI_errno = AVI_ERR_NOT_PERM;\n\t\treturn -1;\n\t}\n\tif(!AVI->track[AVI->aptr].audio_index)         {\n\t\tAVI_errno = AVI_ERR_NO_IDX;\n\t\treturn -1;\n\t}\n\n\tif(byte < 0) byte = 0;\n\n\t/* Binary search in the audio chunks */\n\n\tn0 = 0;\n\tn1 = AVI->track[AVI->aptr].audio_chunks;\n\n\twhile(n0<n1-1)\n\t{\n\t\tint n = (n0+n1)/2;\n\t\tif(AVI->track[AVI->aptr].audio_index[n].tot>(u32) byte)\n\t\t\tn1 = n;\n\t\telse\n\t\t\tn0 = n;\n\t}\n\n\tAVI->track[AVI->aptr].audio_posc = n0;\n\tAVI->track[AVI->aptr].audio_posb = (u32) (byte - AVI->track[AVI->aptr].audio_index[n0].tot);\n\n\treturn 0;\n}\n\n\nint AVI_read_audio(avi_t *AVI, u8 *audbuf, int bytes, int *continuous)\n{\n\tint nr, todo;\n\ts64 pos;\n\n\tif(AVI->mode==AVI_MODE_WRITE) {\n\t\tAVI_errno = AVI_ERR_NOT_PERM;\n\t\treturn -1;\n\t}\n\tif(!AVI->track[AVI->aptr].audio_index)         {\n\t\tAVI_errno = AVI_ERR_NO_IDX;\n\t\treturn -1;\n\t}\n\n\tnr = 0; /* total number of bytes read */\n\n\tif (bytes==0) {\n\t\tAVI->track[AVI->aptr].audio_posc++;\n\t\tAVI->track[AVI->aptr].audio_posb = 0;\n\t}\n\n\t*continuous = 1;\n\twhile(bytes>0)\n\t{\n\t\ts64 ret;\n\t\tint left = (int) (AVI->track[AVI->aptr].audio_index[AVI->track[AVI->aptr].audio_posc].len - AVI->track[AVI->aptr].audio_posb);\n\t\tif(left==0)\n\t\t{\n\t\t\tif(AVI->track[AVI->aptr].audio_posc>=AVI->track[AVI->aptr].audio_chunks-1) return nr;\n\t\t\tAVI->track[AVI->aptr].audio_posc++;\n\t\t\tAVI->track[AVI->aptr].audio_posb = 0;\n\t\t\t*continuous = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif(bytes<left)\n\t\t\ttodo = bytes;\n\t\telse\n\t\t\ttodo = left;\n\t\tpos = AVI->track[AVI->aptr].audio_index[AVI->track[AVI->aptr].audio_posc].pos + AVI->track[AVI->aptr].audio_posb;\n\t\tgf_fseek(AVI->fdes, pos, SEEK_SET);\n\t\tAVI->track[AVI->aptr].audio_posb += todo;\n\t\tif ( (ret = avi_read(AVI->fdes,audbuf+nr,todo)) != todo)\n\t\t{\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[avilib] XXX pos = %\"LLD\", ret = %\"LLD\", todo = %ld\\n\", pos, ret, todo));\n\t\t\tAVI_errno = AVI_ERR_READ;\n\t\t\treturn -1;\n\t\t}\n\t\tbytes -= todo;\n\t\tnr    += todo;\n\t}\n\n\treturn nr;\n}\n\n\n#if 0 //unused\n/* AVI_read_data: Special routine for reading the next audio or video chunk\n                  without having an index of the file. */\n\nint AVI_read_data(avi_t *AVI, char *vidbuf, int max_vidbuf,\n                  char *audbuf, int max_audbuf,\n                  int *len)\n{\n\n\t/*\n\t * Return codes:\n\t *\n\t *    1 = video data read\n\t *    2 = audio data read\n\t *    0 = reached EOF\n\t *   -1 = video buffer too small\n\t *   -2 = audio buffer too small\n\t */\n\n\ts64 n;\n\tchar data[8];\n\n\tif(AVI->mode==AVI_MODE_WRITE) return 0;\n\n\twhile(1)\n\t{\n\t\t/* Read tag and length */\n\n\t\tif( avi_read(AVI->fdes,data,8) != 8 ) return 0;\n\n\t\t/* if we got a list tag, ignore it */\n\n\t\tif(strnicmp(data,\"LIST\",4) == 0)\n\t\t{\n\t\t\tgf_fseek(AVI->fdes,4,SEEK_CUR);\n\t\t\tcontinue;\n\t\t}\n\n\t\tn = PAD_EVEN(str2ulong((unsigned char *)data+4));\n\n\t\tif(strnicmp(data,AVI->video_tag,3) == 0)\n\t\t{\n\t\t\t*len = (u32) n;\n\t\t\tAVI->video_pos++;\n\t\t\tif(n>max_vidbuf)\n\t\t\t{\n\t\t\t\tgf_fseek(AVI->fdes,n,SEEK_CUR);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif(avi_read(AVI->fdes,vidbuf, (u32) n) != n ) return 0;\n\t\t\treturn 1;\n\t\t}\n\t\telse if(strnicmp(data,AVI->track[AVI->aptr].audio_tag,4) == 0)\n\t\t{\n\t\t\t*len = (u32) n;\n\t\t\tif(n>max_audbuf)\n\t\t\t{\n\t\t\t\tgf_fseek(AVI->fdes,n,SEEK_CUR);\n\t\t\t\treturn -2;\n\t\t\t}\n\t\t\tif(avi_read(AVI->fdes,audbuf, (u32) n) != n ) return 0;\n\t\t\treturn 2;\n\t\t\tbreak;\n\t\t}\n\t\telse if(gf_fseek(AVI->fdes,n,SEEK_CUR) == (u64) -1)  return 0;\n\t}\n}\n\nu64 AVI_max_size(void)\n{\n\treturn((u64) AVI_MAX_LEN);\n}\n#endif\n\n\n#endif /*GPAC_DISABLE_AVILIB*/\n", "/*\n * The contents of this file are subject to the Mozilla Public\n * License Version 1.1 (the \"License\"); you may not use this file\n * except in compliance with the License. You may obtain a copy of\n * the License at http://www.mozilla.org/MPL/\n *\n * Software distributed under the License is distributed on an \"AS\n * IS\" basis, WITHOUT WARRANTY OF ANY KIND, either express or\n * implied. See the License for the specific language governing\n * rights and limitations under the License.\n *\n * The Original Code is MPEG4IP.\n *\n * The Initial Developer of the Original Code is Cisco Systems Inc.\n * Portions created by Cisco Systems Inc. are\n * Copyright (C) Cisco Systems Inc. 2004.  All Rights Reserved.\n *\n * Contributor(s):\n *\t\tBill May wmay@cisco.com\n */\n\n/*\n * mpeg2ps.c - parse program stream and vob files\n */\n#include \"mpeg2_ps.h\"\n\n#ifndef GPAC_DISABLE_MPEG2PS\n\n\nstatic GFINLINE u16 convert16 (u8 *p)\n{\n#ifdef GPAC_BIG_ENDIAN\n\treturn *(u16 *)p;\n#else\n\tu16 val = p[0];\n\tval <<= 8;\n\treturn (val | p[1]);\n#endif\n}\n\nstatic GFINLINE u32 convert32 (u8 *p)\n{\n#ifdef GPAC_BIG_ENDIAN\n\treturn *(u32 *)p;\n#else\n\tu32 val;\n\tval = p[0];\n\tval <<= 8;\n\tval |= p[1];\n\tval <<= 8;\n\tval |= p[2];\n\tval <<= 8;\n\tval |= p[3];\n\treturn val;\n#endif\n}\n\n#define FDNULL 0\n\n/*\n * structure for passing timestamps around\n */\ntypedef struct mpeg2ps_ts_t\n{\n\tBool have_pts;\n\tBool have_dts;\n\tu64 pts;\n\tu64 dts;\n} mpeg2ps_ts_t;\n\ntypedef struct mpeg2ps_record_pes_t\n{\n\tstruct mpeg2ps_record_pes_t *next_rec;\n\tu64 dts;\n\tu64 location;\n} mpeg2ps_record_pes_t;\n\n/*\n * information about reading a stream\n */\ntypedef struct mpeg2ps_stream_t\n{\n\tmpeg2ps_record_pes_t *record_first, *record_last;\n\tFILE *m_fd;\n\tBool is_video;\n\tu8 m_stream_id;    // program stream id\n\tu8 m_substream_id; // substream, for program stream id == 0xbd\n\n\tmpeg2ps_ts_t next_pes_ts, frame_ts;\n\tu32 frames_since_last_ts;\n\tu64 last_ts;\n\n\tBool have_frame_loaded;\n\t/*\n\t * pes_buffer processing.  this contains the raw elementary stream data\n\t */\n\tu8 *pes_buffer;\n\tu32 pes_buffer_size;\n\tu32 pes_buffer_size_max;\n\tu32 pes_buffer_on;\n\tu32 frame_len;\n\tu32 pict_header_offset; // for mpeg video\n\n\t// timing information and locations.\n\ts64 first_pes_loc;\n\tu64 start_dts;\n\tBool first_pes_has_dts;\n\ts64    end_dts_loc;\n\tu64 end_dts;\n\t// audio stuff\n\tu32 freq;\n\tu32 channels;\n\tu32 bitrate;\n\tu32 samples_per_frame;\n\tu32 layer;\n\t// video stuff\n\tu32 h, w, par;\n\tDouble frame_rate;\n\ts32 have_mpeg2;\n\tDouble bit_rate;\n\tu64 ticks_per_frame;\n\n} mpeg2ps_stream_t;\n\n/*\n * main interface structure - contains stream pointers and other\n * information\n */\nstruct mpeg2ps_ {\n\tmpeg2ps_stream_t *video_streams[16];\n\tmpeg2ps_stream_t *audio_streams[32];\n\tchar *filename;\n\tFILE *fd;\n\tu64 first_dts;\n\tu32 audio_cnt, video_cnt;\n\ts64 end_loc;\n\tu64 max_dts;\n\tu64 max_time;  // time is in msec.\n};\n\n/*************************************************************************\n * File access routines.  Could all be inline\n *************************************************************************/\nstatic FILE *file_open (const char *name)\n{\n\treturn gf_fopen(name, \"rb\");\n}\n\nstatic Bool file_okay (FILE *fd)\n{\n\treturn (fd!=NULL) ? 1 : 0;\n}\n\nstatic void file_close (FILE *fd)\n{\n\tgf_fclose(fd);\n}\n\nstatic Bool file_read_bytes(FILE *fd,\n                            u8 *buffer,\n                            u32 len)\n{\n\tu32 readval = (u32) gf_fread(buffer, len, fd);\n\treturn readval == len;\n}\n\n// note: len could be negative.\nstatic void file_skip_bytes (FILE *fd, s32 len)\n{\n\tgf_fseek(fd, len, SEEK_CUR);\n}\n\n#define file_location(__f) gf_ftell(__f)\n#define file_seek_to(__f, __off) gf_fseek(__f, __off, SEEK_SET)\n\nstatic u64 file_size(FILE *fd)\n{\n\treturn gf_fsize(fd);\n}\n\nstatic mpeg2ps_record_pes_t *create_record (s64 loc, u64 ts)\n{\n\tmpeg2ps_record_pes_t *ret;\n\tGF_SAFEALLOC(ret, mpeg2ps_record_pes_t);\n\tif (!ret) return NULL;\n\tret->next_rec = NULL;\n\tret->dts = ts;\n\tret->location = loc;\n\treturn ret;\n}\n\n#define MPEG2PS_RECORD_TIME ((u64) (5 * 90000))\nvoid mpeg2ps_record_pts (mpeg2ps_stream_t *sptr, s64 location, mpeg2ps_ts_t *pTs)\n{\n\tu64 ts;\n\tmpeg2ps_record_pes_t *p, *q;\n\tif (sptr->is_video) {\n\t\tif (pTs->have_dts == 0) return;\n\t\tts = pTs->dts;\n\t} else {\n\t\tif (pTs->have_pts == 0) return;\n\t\tts = pTs->pts;\n\t}\n\n\tif (sptr->record_first == NULL) {\n\t\tsptr->record_first = sptr->record_last = create_record(location, ts);\n\t\treturn;\n\t}\n\tif (ts > sptr->record_last->dts) {\n\t\tif (ts < MPEG2PS_RECORD_TIME + sptr->record_last->dts) return;\n\t\tsptr->record_last->next_rec = create_record(location, ts);\n\t\tsptr->record_last = sptr->record_last->next_rec;\n\t\treturn;\n\t}\n\tif (ts < sptr->record_first->dts) {\n\t\tif (ts < MPEG2PS_RECORD_TIME + sptr->record_first->dts) return;\n\t\tp = create_record(location, ts);\n\t\tp->next_rec = sptr->record_first;\n\t\tsptr->record_first = p;\n\t\treturn;\n\t}\n\tp = sptr->record_first;\n\tq = p->next_rec;\n\n\twhile (q != NULL && q->dts < ts) {\n\t\tp = q;\n\t\tq = q->next_rec;\n\t}\n\tif (q) {\n\t\tif (p->dts + MPEG2PS_RECORD_TIME <= ts &&\n\t\t\t\tts + MPEG2PS_RECORD_TIME <= q->dts) {\n\t\t\tp->next_rec = create_record(location, ts);\n\t\t\tp->next_rec->next_rec = q;\n\t\t}\n\t}\n}\nstatic Double mpeg12_frame_rate_table[16] =\n{\n\t0.0,   /* Pad */\n\t24000.0/1001.0,       /* Official frame rates */\n\t24.0,\n\t25.0,\n\t30000.0/1001.0,\n\t30.0,\n\t50.0,\n\t((60.0*1000.0)/1001.0),\n\t60.0,\n\n\t1,                    /* Unofficial economy rates */\n\t5,\n\t10,\n\t12,\n\t15,\n\t0,\n\t0,\n};\n\n#define SEQ_ID 1\nint MPEG12_ParseSeqHdr(unsigned char *pbuffer, u32 buflen, s32 *have_mpeg2, u32 *height, u32 *width,\n                       Double *frame_rate, Double *bitrate, u32 *aspect_ratio)\n{\n\tu32 aspect_code;\n\tu32 framerate_code;\n\tu32 bitrate_int;\n\tu32 bitrate_ext;\n\tu32 scode, ix;\n\ts32 found = -1;\n\t*have_mpeg2 = 0;\n\tbuflen -= 6;\n\tbitrate_int = 0;\n\tfor (ix = 0; ix < buflen; ix++, pbuffer++) {\n\t\tscode = ((u32)pbuffer[0] << 24) | (pbuffer[1] << 16) | (pbuffer[2] << 8) |\n\t\t        pbuffer[3];\n\n\t\tif (scode == MPEG12_SEQUENCE_START_CODE) {\n\t\t\tpbuffer += sizeof(u32);\n\t\t\t*width = (pbuffer[0]);\n\t\t\t*width <<= 4;\n\t\t\t*width |= ((pbuffer[1] >> 4) &0xf);\n\t\t\t*height = (pbuffer[1] & 0xf);\n\t\t\t*height <<= 8;\n\t\t\t*height |= pbuffer[2];\n\t\t\taspect_code = (pbuffer[3] >> 4) & 0xf;\n\t\t\tif (aspect_ratio != NULL) {\n\t\t\t\tu32 par = 0;\n\t\t\t\tswitch (aspect_code) {\n\t\t\t\tdefault:\n\t\t\t\t\t*aspect_ratio = 0;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\tpar = 4;\n\t\t\t\t\tpar<<=16;\n\t\t\t\t\tpar |= 3;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 3:\n\t\t\t\t\tpar = 16;\n\t\t\t\t\tpar<<=16;\n\t\t\t\t\tpar |= 9;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 4:\n\t\t\t\t\tpar = 2;\n\t\t\t\t\tpar<<=16;\n\t\t\t\t\tpar |= 21;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t*aspect_ratio = par;\n\t\t\t}\n\n\n\t\t\tframerate_code = pbuffer[3] & 0xf;\n\t\t\t*frame_rate = mpeg12_frame_rate_table[framerate_code];\n\t\t\t// 18 bits\n\t\t\tbitrate_int = (pbuffer[4] << 10) |\n\t\t\t              (pbuffer[5] << 2) |\n\t\t\t              ((pbuffer[6] >> 6) & 0x3);\n\t\t\t*bitrate = bitrate_int;\n\t\t\t*bitrate *= 400.0;\n\t\t\tix += sizeof(u32) + 7;\n\t\t\tpbuffer += 7;\n\t\t\tfound = 0;\n\t\t} else if (found == 0) {\n\t\t\tif (scode == MPEG12_EXT_START_CODE) {\n\t\t\t\tpbuffer += sizeof(u32);\n\t\t\t\tix += sizeof(u32);\n\t\t\t\tswitch ((pbuffer[0] >> 4) & 0xf) {\n\t\t\t\tcase SEQ_ID:\n\t\t\t\t\t*have_mpeg2 = 1;\n\t\t\t\t\t*height = ((pbuffer[1] & 0x1) << 13) |\n\t\t\t\t\t          ((pbuffer[2] & 0x80) << 5) |\n\t\t\t\t\t          (*height & 0x0fff);\n\t\t\t\t\t*width = (((pbuffer[2] >> 5) & 0x3) << 12) | (*width & 0x0fff);\n\t\t\t\t\tbitrate_ext = (pbuffer[2] & 0x1f) << 7;\n\t\t\t\t\tbitrate_ext |= (pbuffer[3] >> 1) & 0x7f;\n\t\t\t\t\tbitrate_int |= (bitrate_ext << 18);\n\t\t\t\t\t*bitrate = bitrate_int;\n\t\t\t\t\t*bitrate *= 400.0;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tpbuffer++;\n\t\t\t\tix++;\n\t\t\t} else if (scode == MPEG12_PICTURE_START_CODE) {\n\t\t\t\treturn found;\n\t\t\t}\n\t\t}\n\t}\n\treturn found;\n}\n\n\ns32 MPEG12_PictHdrType (unsigned char *pbuffer)\n{\n\tpbuffer += sizeof(u32);\n\treturn ((pbuffer[1] >> 3) & 0x7);\n}\n\n#if 0 //unused\nu16 MPEG12_PictHdrTempRef(unsigned char *pbuffer)\n{\n\tpbuffer += sizeof(u32);\n\treturn ((pbuffer[0] << 2) | ((pbuffer[1] >> 6) & 0x3));\n}\n#endif\n\n\nstatic u64 read_pts (u8 *pak)\n{\n\tu64 pts;\n\tu16 temp;\n\n\tpts = ((pak[0] >> 1) & 0x7);\n\tpts <<= 15;\n\ttemp = convert16(&pak[1]) >> 1;\n\tpts |= temp;\n\tpts <<= 15;\n\ttemp = convert16(&pak[3]) >> 1;\n\tpts |= temp;\n\treturn pts;\n}\n\n\nstatic mpeg2ps_stream_t *mpeg2ps_stream_create (u8 stream_id,\n        u8 substream)\n{\n\tmpeg2ps_stream_t *ptr;\n\tGF_SAFEALLOC(ptr, mpeg2ps_stream_t);\n\tif (!ptr) return NULL;\n\tptr->m_stream_id = stream_id;\n\tptr->m_substream_id = substream;\n\tptr->is_video = stream_id >= 0xe0;\n\tptr->pes_buffer = (u8 *)gf_malloc(4*4096);\n\tptr->pes_buffer_size_max = 4 * 4096;\n\treturn ptr;\n}\n\nstatic void mpeg2ps_stream_destroy (mpeg2ps_stream_t *sptr)\n{\n\tmpeg2ps_record_pes_t *p;\n\twhile (sptr->record_first != NULL) {\n\t\tp = sptr->record_first;\n\t\tsptr->record_first = p->next_rec;\n\t\tgf_free(p);\n\t}\n\tif (sptr->m_fd != FDNULL) {\n\t\tfile_close(sptr->m_fd);\n\t\tsptr->m_fd = FDNULL;\n\t}\n\tif (sptr->pes_buffer) gf_free(sptr->pes_buffer);\n\tgf_free(sptr);\n}\n\n\n/*\n * adv_past_pack_hdr - read the pack header, advance past it\n * we don't do anything with the data\n */\nstatic void adv_past_pack_hdr (FILE *fd,\n                               u8 *pak,\n                               u32 read_from_start)\n{\n\tu8 stuffed;\n\tu8 readbyte;\n\tu8 val;\n\tif (read_from_start < 5) {\n\t\tfile_skip_bytes(fd, 5 - read_from_start);\n\t\tfile_read_bytes(fd, &readbyte, 1);\n\t\tval = readbyte;\n\t} else {\n\t\tval = pak[4];\n\t}\n\n\t// we've read 6 bytes\n\tif ((val & 0xc0) != 0x40) {\n\t\t// mpeg1\n\t\tfile_skip_bytes(fd, 12 - read_from_start); // skip 6 more bytes\n\t\treturn;\n\t}\n\tfile_skip_bytes(fd, 13 - read_from_start);\n\tfile_read_bytes(fd, &readbyte, 1);\n\tstuffed = readbyte & 0x7;\n\tfile_skip_bytes(fd, stuffed);\n}\n\n/*\n * find_pack_start\n * look for the pack start code in the file - read 512 bytes at a time,\n * searching for that code.\n * Note: we may also be okay looking for >= 00 00 01 bb\n */\nstatic Bool find_pack_start (FILE *fd,\n                             u8 *saved,\n                             u32 len)\n{\n\tu8 buffer[512];\n\tu32 buffer_on = 0, new_offset, scode;\n\tmemcpy(buffer, saved, len);\n\tif (file_read_bytes(fd, buffer + len, sizeof(buffer) - len) == 0) {\n\t\treturn 0;\n\t}\n\twhile (1) {\n\t\tif (gf_mv12_next_start_code(buffer + buffer_on,\n\t\t                            sizeof(buffer) - buffer_on,\n\t\t                            &new_offset,\n\t\t                            &scode) >= 0) {\n\t\t\tbuffer_on += new_offset;\n\t\t\tif (scode == MPEG2_PS_PACKSTART) {\n\t\t\t\tfile_skip_bytes(fd, buffer_on - 512); // go back to header\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tbuffer_on += 1;\n\t\t} else {\n\t\t\tlen = 0;\n\t\t\tif (buffer[sizeof(buffer) - 3] == 0 &&\n\t\t\t        buffer[sizeof(buffer) - 2] == 0 &&\n\t\t\t        buffer[sizeof(buffer) - 1] == 1) {\n\t\t\t\tbuffer[0] = 0;\n\t\t\t\tbuffer[1] = 0;\n\t\t\t\tbuffer[2] = 1;\n\t\t\t\tlen = 3;\n\t\t\t} else if (*(u16 *)(buffer + sizeof(buffer) - 2) == 0) {\n\t\t\t\tbuffer[0] = 0;\n\t\t\t\tbuffer[1] = 0;\n\t\t\t\tlen = 2;\n\t\t\t} else if (buffer[sizeof(buffer) - 1] == 0) {\n\t\t\t\tbuffer[0] = 0;\n\t\t\t\tlen = 1;\n\t\t\t}\n\t\t\tif (file_read_bytes(fd, buffer + len, sizeof(buffer) - len) == 0) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tbuffer_on = 0;\n\t\t}\n\t}\n\treturn 0;\n}\n\n/*\n * copy_bytes_to_pes_buffer - read pes_len bytes into the buffer,\n * adjusting it if we need it\n */\nstatic void copy_bytes_to_pes_buffer (mpeg2ps_stream_t *sptr,\n                                      u16 pes_len)\n{\n\tu32 to_move;\n\n\tif (sptr->pes_buffer_size + pes_len > sptr->pes_buffer_size_max) {\n\t\t// if no room in the buffer, we'll move it - otherwise, just fill\n\t\t// note - we might want a better strategy about moving the buffer -\n\t\t// right now, we might be moving a number of bytes if we have a large\n\t\t// followed by large frame.\n\t\tto_move = sptr->pes_buffer_size - sptr->pes_buffer_on;\n\t\tmemmove(sptr->pes_buffer,\n\t\t        sptr->pes_buffer + sptr->pes_buffer_on,\n\t\t        to_move);\n\t\tsptr->pes_buffer_size = to_move;\n\t\tsptr->pes_buffer_on = 0;\n\t\tif (to_move + pes_len > sptr->pes_buffer_size_max) {\n\t\t\tsptr->pes_buffer = (u8 *)gf_realloc(sptr->pes_buffer,\n\t\t\t                                    to_move + pes_len + 2048);\n\t\t\tsptr->pes_buffer_size_max = to_move + pes_len + 2048;\n\t\t}\n\t}\n\tfile_read_bytes(sptr->m_fd, sptr->pes_buffer + sptr->pes_buffer_size, pes_len);\n\tsptr->pes_buffer_size += pes_len;\n}\n\n/*\n * read_to_next_pes_header - read the file, look for the next valid\n * pes header.  We will skip over PACK headers, but not over any of the\n * headers listed in 13818-1, table 2-18 - basically, anything with the\n * 00 00 01 and the next byte > 0xbb.\n * We return the pes len to read, and the \"next byte\"\n */\nstatic Bool read_to_next_pes_header (FILE *fd,\n                                     u8 *stream_id,\n                                     u16 *pes_len)\n{\n\tu32 hdr;\n\tu8 local[6];\n\n\twhile (1) {\n\t\t// read the pes header\n\t\tif (file_read_bytes(fd, local, 6) == 0) {\n\t\t\treturn 0;\n\t\t}\n\n\t\thdr = convert32(local);\n\t\t// if we're not a 00 00 01, read until we get the next pack start\n\t\t// we might want to also read until next PES - look into that.\n\t\tif (((hdr & MPEG2_PS_START_MASK) != MPEG2_PS_START) ||\n\t\t        (hdr < MPEG2_PS_END)) {\n\t\t\tif (find_pack_start(fd, local, 6) == 0) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (hdr == MPEG2_PS_PACKSTART) {\n\t\t\t// pack start code - we can skip down\n\t\t\tadv_past_pack_hdr(fd, local, 6);\n\t\t\tcontinue;\n\t\t}\n\t\tif (hdr == MPEG2_PS_END) {\n\t\t\tfile_skip_bytes(fd, -2);\n\t\t\tcontinue;\n\t\t}\n\n\t\t// we should have a valid stream and pes_len here...\n\t\t*stream_id = hdr & 0xff;\n\t\t*pes_len = convert16(local + 4);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n/*\n * read_pes_header_data\n * this should read past the pes header for the audio and video streams\n * it will store the timestamps if it reads them\n */\nstatic Bool read_pes_header_data (FILE *fd,\n                                  u16 orig_pes_len,\n                                  u16 *pes_left,\n                                  Bool *have_ts,\n                                  mpeg2ps_ts_t *ts)\n{\n\tu16 pes_len = orig_pes_len;\n\tu8 local[10];\n\tu32 hdr_len;\n\n\tts->have_pts = 0;\n\tts->have_dts = 0;\n\tif (have_ts) *have_ts = 0;\n\tif (file_read_bytes(fd, local, 1) == 0) {\n\t\treturn 0;\n\t}\n\tpes_len--; // remove this first byte from length\n\twhile (*local == 0xff) {\n\t\tif (file_read_bytes(fd, local, 1) == 0) {\n\t\t\treturn 0;\n\t\t}\n\t\tpes_len--;\n\t\tif (pes_len == 0) {\n\t\t\t*pes_left = 0;\n\t\t\treturn 1;\n\t\t}\n\t}\n\tif ((*local & 0xc0) == 0x40) {\n\t\t// buffer scale & size\n\t\tfile_skip_bytes(fd, 1);\n\t\tif (file_read_bytes(fd, local, 1) == 0) {\n\t\t\treturn 0;\n\t\t}\n\t\tpes_len -= 2;\n\t}\n\n\tif ((*local & 0xf0) == 0x20) {\n\t\t// mpeg-1 with pts\n\t\tif (file_read_bytes(fd, local + 1, 4) == 0) {\n\t\t\treturn 0;\n\t\t}\n\t\tts->have_pts = 1;\n\t\tts->pts = ts->dts = read_pts(local);\n\t\t*have_ts = 1;\n\t\tpes_len -= 4;\n\t} else if ((*local & 0xf0) == 0x30) {\n\t\t// have mpeg 1 pts and dts\n\t\tif (file_read_bytes(fd, local + 1, 9) == 0) {\n\t\t\treturn 0;\n\t\t}\n\t\tts->have_pts = 1;\n\t\tts->have_dts = 1;\n\t\t*have_ts = 1;\n\t\tts->pts = read_pts(local);\n\t\tts->dts = read_pts(local + 5);\n\t\tpes_len -= 9;\n\t} else if ((*local & 0xc0) == 0x80) {\n\t\t// mpeg2 pes header  - we're pointing at the flags field now\n\t\tif (file_read_bytes(fd, local + 1, 2) == 0) {\n\t\t\treturn 0;\n\t\t}\n\t\thdr_len = local[2];\n\t\tpes_len -= hdr_len + 2; // first byte removed already\n\t\tif ((local[1] & 0xc0) == 0x80) {\n\t\t\t// just pts\n\t\t\tts->have_pts = 1;\n\t\t\tfile_read_bytes(fd, local, 5);\n\t\t\tts->pts = ts->dts = read_pts(local);\n\t\t\t*have_ts = 1;\n\t\t\thdr_len -= 5;\n\t\t} else if ((local[1] & 0xc0) == 0xc0) {\n\t\t\t// pts and dts\n\t\t\tts->have_pts = 1;\n\t\t\tts->have_dts = 1;\n\t\t\t*have_ts = 1;\n\t\t\tfile_read_bytes(fd, local, 10);\n\t\t\tts->pts = read_pts(local);\n\t\t\tts->dts = read_pts(local  + 5);\n\t\t\thdr_len -= 10;\n\t\t}\n\t\tfile_skip_bytes(fd, hdr_len);\n\t} else if (*local != 0xf) {\n\t\tfile_skip_bytes(fd, pes_len);\n\t\tpes_len = 0;\n\t}\n\t*pes_left = pes_len;\n\treturn 1;\n}\n\nstatic Bool search_for_next_pes_header (mpeg2ps_stream_t *sptr,\n                                        u16 *pes_len,\n                                        Bool *have_ts,\n                                        s64 *found_loc)\n{\n\tu8 stream_id;\n\tu8 local;\n\ts64 loc;\n\twhile (1) {\n\t\t// this will read until we find the next pes.  We don't know if the\n\t\t// stream matches - this will read over pack headers\n\t\tif (read_to_next_pes_header(sptr->m_fd, &stream_id, pes_len) == 0) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (stream_id != sptr->m_stream_id) {\n\t\t\tfile_skip_bytes(sptr->m_fd, *pes_len);\n\t\t\tcontinue;\n\t\t}\n\t\tloc = file_location(sptr->m_fd) - 6;\n\t\t// advance past header, reading pts\n\t\tif (read_pes_header_data(sptr->m_fd,\n\t\t                         *pes_len,\n\t\t                         pes_len,\n\t\t                         have_ts,\n\t\t                         &sptr->next_pes_ts) == 0) {\n\t\t\treturn 0;\n\t\t}\n\n\t\t// If we're looking at a private stream, make sure that the sub-stream\n\t\t// matches.\n\t\tif (sptr->m_stream_id == 0xbd) {\n\t\t\t// ac3 or pcm\n\t\t\tfile_read_bytes(sptr->m_fd, &local, 1);\n\t\t\t*pes_len -= 1;\n\t\t\tif (local != sptr->m_substream_id) {\n\t\t\t\tfile_skip_bytes(sptr->m_fd, *pes_len);\n\t\t\t\tcontinue; // skip to the next one\n\t\t\t}\n\t\t\t*pes_len -= 3;\n\t\t\tfile_skip_bytes(sptr->m_fd, 3); // 4 bytes - we don't need now...\n\t\t\t// we need more here...\n\t\t}\n\t\tif (have_ts) {\n\t\t\tmpeg2ps_record_pts(sptr, loc, &sptr->next_pes_ts);\n\t\t}\n\t\tif (found_loc != NULL) *found_loc = loc;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n/*\n * mpeg2ps_stream_read_next_pes_buffer - for the given stream,\n * go forward in the file until the next PES for the stream is read.  Read\n * the header (pts, dts), and read the data into the pes_buffer pointer\n */\nstatic Bool mpeg2ps_stream_read_next_pes_buffer (mpeg2ps_stream_t *sptr)\n{\n\tu16 pes_len;\n\tBool have_ts;\n\n\tif (search_for_next_pes_header(sptr, &pes_len, &have_ts, NULL) == 0) {\n\t\treturn 0;\n\t}\n\n\tcopy_bytes_to_pes_buffer(sptr, pes_len);\n\n\treturn 1;\n}\n\n\n/***************************************************************************\n * Frame reading routine.  For each stream, the fd's should be different.\n * we will read from the pes stream, and save it in the stream's pes buffer.\n * This will give us raw data that we can search through for frame headers,\n * and the like.  We shouldn't read more than we need - when we need to read,\n * we'll put the whole next pes buffer in the buffer\n *\n * Audio routines are of the format:\n *   look for header\n *   determine length\n *   make sure length is in buffer\n *\n * Video routines\n *   look for start header (GOP, SEQ, Picture)\n *   look for pict header\n *   look for next start (END, GOP, SEQ, Picture)\n *\n ***************************************************************************/\n#define IS_MPEG_START(a) ((a) == 0xb3 || (a) == 0x00 || (a) == 0xb8)\n\nstatic Bool\nmpeg2ps_stream_find_mpeg_video_frame (mpeg2ps_stream_t *sptr)\n{\n\tu32 offset, scode;\n\tBool have_pict;\n\tBool started_new_pes = 0;\n\tu32 start;\n\t/*\n\t * First thing - determine if we have enough bytes to read the header.\n\t * if we do, we have the correct timestamp.  If not, we read the new\n\t * pes, so we'd want to use the timestamp we read.\n\t */\n\tsptr->frame_ts = sptr->next_pes_ts;\n\tif (sptr->pes_buffer_size <= sptr->pes_buffer_on + 4) {\n\t\tif (sptr->pes_buffer_size != sptr->pes_buffer_on)\n\t\t\tstarted_new_pes = 1;\n\t\tif (mpeg2ps_stream_read_next_pes_buffer(sptr) == 0) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\twhile (gf_mv12_next_start_code(sptr->pes_buffer + sptr->pes_buffer_on,\n\t                               sptr->pes_buffer_size - sptr->pes_buffer_on,\n\t                               &offset,\n\t                               &scode) < 0 ||\n\t        (!IS_MPEG_START(scode & 0xff))) {\n\t\tif (sptr->pes_buffer_size > 3)\n\t\t\tsptr->pes_buffer_on = sptr->pes_buffer_size - 3;\n\t\telse {\n\t\t\tsptr->pes_buffer_on = sptr->pes_buffer_size;\n\t\t\tstarted_new_pes = 1;\n\t\t}\n\t\tif (mpeg2ps_stream_read_next_pes_buffer(sptr) == 0) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\tsptr->pes_buffer_on += offset;\n\tif (offset == 0 && started_new_pes) {\n\t\t// nothing...  we've copied the timestamp already.\n\t} else {\n\t\t// we found the new start, but we pulled in a new pes header before\n\t\t// starting.  So, we want to use the header that we read.\n\t\tsptr->frame_ts = sptr->next_pes_ts; // set timestamp after searching\n\t\t// clear timestamp indication\n\t\tsptr->next_pes_ts.have_pts = sptr->next_pes_ts.have_dts = 0;\n\t}\n\n\tif (scode == MPEG12_PICTURE_START_CODE) {\n\t\tsptr->pict_header_offset = sptr->pes_buffer_on;\n\t\thave_pict = 1;\n\t} else have_pict = 0;\n\n\tstart = 4 + sptr->pes_buffer_on;\n\twhile (1) {\n\n\t\tif (gf_mv12_next_start_code(sptr->pes_buffer + start,\n\t\t                            sptr->pes_buffer_size - start,\n\t\t                            &offset,\n\t\t                            &scode) < 0) {\n\t\t\tstart = sptr->pes_buffer_size - 3;\n\t\t\tstart -= sptr->pes_buffer_on;\n\t\t\tsptr->pict_header_offset -= sptr->pes_buffer_on;\n\t\t\tif (mpeg2ps_stream_read_next_pes_buffer(sptr) == 0) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tstart += sptr->pes_buffer_on;\n\t\t\tsptr->pict_header_offset += sptr->pes_buffer_on;\n\t\t} else {\n\t\t\tstart += offset;\n\t\t\tif (have_pict == 0) {\n\t\t\t\tif (scode == MPEG12_PICTURE_START_CODE) {\n\t\t\t\t\thave_pict = 1;\n\t\t\t\t\tsptr->pict_header_offset = start;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (IS_MPEG_START(scode & 0xff) ||\n\t\t\t\t        scode == MPEG12_SEQUENCE_END_START_CODE) {\n\t\t\t\t\tsptr->frame_len = start - sptr->pes_buffer_on;\n\t\t\t\t\tsptr->have_frame_loaded = 1;\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tstart += 4;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic Bool mpeg2ps_stream_find_ac3_frame (mpeg2ps_stream_t *sptr)\n{\n\tu32 diff;\n\tBool started_new_pes = 0;\n\tGF_AC3Config hdr;\n\tmemset(&hdr, 0, sizeof(GF_AC3Config));\n\tsptr->frame_ts = sptr->next_pes_ts; // set timestamp after searching\n\tif (sptr->pes_buffer_size <= sptr->pes_buffer_on + 6) {\n\t\tif (sptr->pes_buffer_size != sptr->pes_buffer_on)\n\t\t\tstarted_new_pes = 1;\n\t\tif (mpeg2ps_stream_read_next_pes_buffer(sptr) == 0) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\twhile (gf_ac3_parser(sptr->pes_buffer + sptr->pes_buffer_on,\n\t                     sptr->pes_buffer_size - sptr->pes_buffer_on,\n\t                     &diff,\n\t                     &hdr, 0) <= 0) {\n\t\t// don't have frame\n\t\tif (sptr->pes_buffer_size > 6) {\n\t\t\tsptr->pes_buffer_on = sptr->pes_buffer_size - 6;\n\t\t\tstarted_new_pes = 1;\n\t\t} else {\n\t\t\tsptr->pes_buffer_on = sptr->pes_buffer_size;\n\t\t}\n\t\tif (mpeg2ps_stream_read_next_pes_buffer(sptr) == 0) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\tsptr->frame_len = hdr.framesize;\n\tsptr->pes_buffer_on += diff;\n\tif (diff == 0 && started_new_pes) {\n\t\t// we might have a new PTS - but it's not here\n\t} else {\n\t\tsptr->frame_ts = sptr->next_pes_ts;\n\t\tsptr->next_pes_ts.have_dts = sptr->next_pes_ts.have_pts = 0;\n\t}\n\twhile (sptr->pes_buffer_size - sptr->pes_buffer_on < sptr->frame_len) {\n\t\tif (mpeg2ps_stream_read_next_pes_buffer(sptr) == 0) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\tsptr->have_frame_loaded = 1;\n\treturn 1;\n}\n\nstatic Bool mpeg2ps_stream_find_mp3_frame (mpeg2ps_stream_t *sptr)\n{\n\tu32 diff, hdr;\n\tBool started_new_pes = 0;\n\n\tsptr->frame_ts = sptr->next_pes_ts;\n\tif (sptr->pes_buffer_size <= sptr->pes_buffer_on + 4) {\n\t\tif (sptr->pes_buffer_size != sptr->pes_buffer_on)\n\t\t\tstarted_new_pes = 1;\n\t\tif (mpeg2ps_stream_read_next_pes_buffer(sptr) == 0) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\twhile ((hdr=gf_mp3_get_next_header_mem(sptr->pes_buffer + sptr->pes_buffer_on,\n\t                                       sptr->pes_buffer_size - sptr->pes_buffer_on,\n\t                                       &diff) ) == 0) {\n\t\t// don't have frame\n\t\tif (sptr->pes_buffer_size > 3) {\n\t\t\tif (sptr->pes_buffer_on != sptr->pes_buffer_size) {\n\t\t\t\tsptr->pes_buffer_on = sptr->pes_buffer_size - 3;\n\t\t\t}\n\t\t\tstarted_new_pes = 1; // we have left over bytes...\n\t\t} else {\n\t\t\tsptr->pes_buffer_on = sptr->pes_buffer_size;\n\t\t}\n\t\tif (mpeg2ps_stream_read_next_pes_buffer(sptr) == 0) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\t// have frame.\n\tsptr->frame_len = gf_mp3_frame_size(hdr);\n\tsptr->pes_buffer_on += diff;\n\tif (diff == 0 && started_new_pes) {\n\n\t} else {\n\t\tsptr->frame_ts = sptr->next_pes_ts;\n\t\tsptr->next_pes_ts.have_dts = sptr->next_pes_ts.have_pts = 0;\n\t}\n\twhile (sptr->pes_buffer_size - sptr->pes_buffer_on < sptr->frame_len) {\n\t\tif (mpeg2ps_stream_read_next_pes_buffer(sptr) == 0) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\tsptr->have_frame_loaded = 1;\n\treturn 1;\n}\n\n/*\n * mpeg2ps_stream_read_frame.  read the correct frame based on stream type.\n * advance_pointers is 0 when we want to use the data\n */\nstatic Bool mpeg2ps_stream_read_frame (mpeg2ps_stream_t *sptr,\n                                       u8 **buffer,\n                                       u32 *buflen,\n                                       Bool advance_pointers)\n{\n\t//  Bool done = 0;\n\tif (sptr->is_video) {\n\t\tif (mpeg2ps_stream_find_mpeg_video_frame(sptr)) {\n\t\t\t*buffer = sptr->pes_buffer + sptr->pes_buffer_on;\n\t\t\t*buflen = sptr->frame_len;\n\t\t\tif (advance_pointers) {\n\t\t\t\tsptr->pes_buffer_on += sptr->frame_len;\n\t\t\t}\n\t\t\treturn 1;\n\t\t}\n\t\treturn 0;\n\t} else if (sptr->m_stream_id == 0xbd) {\n\t\t// would need to handle LPCM here\n\t\tif (mpeg2ps_stream_find_ac3_frame(sptr)) {\n\t\t\t*buffer = sptr->pes_buffer + sptr->pes_buffer_on;\n\t\t\t*buflen = sptr->frame_len;\n\t\t\tif (advance_pointers)\n\t\t\t\tsptr->pes_buffer_on += sptr->frame_len;\n\t\t\treturn 1;\n\t\t}\n\t\treturn 0;\n\t} else if (mpeg2ps_stream_find_mp3_frame(sptr)) {\n\t\t*buffer = sptr->pes_buffer + sptr->pes_buffer_on;\n\t\t*buflen = sptr->frame_len;\n\t\tif (advance_pointers)\n\t\t\tsptr->pes_buffer_on += sptr->frame_len;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n/*\n * get_info_from_frame - we have a frame, get the info from it.\n */\nstatic void get_info_from_frame (mpeg2ps_stream_t *sptr,\n                                 u8 *buffer,\n                                 u32 buflen)\n{\n\tif (sptr->is_video) {\n\t\tif (MPEG12_ParseSeqHdr(buffer, buflen,\n\t\t                       &sptr->have_mpeg2,\n\t\t                       &sptr->h,\n\t\t                       &sptr->w,\n\t\t                       &sptr->frame_rate,\n\t\t                       &sptr->bit_rate,\n\t\t                       &sptr->par) < 0) {\n\t\t\tsptr->m_stream_id = 0;\n\t\t\tsptr->m_fd = FDNULL;\n\t\t}\n\t\tsptr->ticks_per_frame = (u64)(90000.0 / sptr->frame_rate);\n\t\treturn;\n\t}\n\n\tif (sptr->m_stream_id >= 0xc0) {\n\t\t// mpeg audio\n\t\tu32 hdr = GF_4CC((u32)buffer[0],buffer[1],buffer[2],buffer[3]);\n\n\t\tsptr->channels = gf_mp3_num_channels(hdr);\n\t\tsptr->freq = gf_mp3_sampling_rate(hdr);\n\t\tsptr->samples_per_frame = gf_mp3_window_size(hdr);\n\t\tsptr->bitrate = gf_mp3_bit_rate(hdr) * 1000; // give bps, not kbps\n\t\tsptr->layer = gf_mp3_layer(hdr);\n\t} else if (sptr->m_stream_id == 0xbd) {\n\t\tif (sptr->m_substream_id >= 0xa0) {\n\t\t\t// PCM - ???\n\t\t} else if (sptr->m_substream_id >= 0x80) {\n\t\t\tu32 pos;\n\t\t\tGF_AC3Config hdr;\n\t\t\tmemset(&hdr, 0, sizeof(GF_AC3Config));\n\t\t\tgf_ac3_parser(buffer, buflen, &pos, &hdr, 0);\n\t\t\tsptr->bitrate = gf_ac3_get_bitrate(hdr.brcode);\n\t\t\tsptr->freq = hdr.sample_rate;\n\t\t\tsptr->channels = hdr.streams[0].channels;\n\t\t\tsptr->samples_per_frame = 256 * 6;\n\t\t} else {\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\treturn;\n\t}\n}\n\n/*\n * clear_stream_buffer - called when we seek to clear out any data in\n * the buffers\n */\nstatic void clear_stream_buffer (mpeg2ps_stream_t *sptr)\n{\n\tsptr->pes_buffer_on = sptr->pes_buffer_size = 0;\n\tsptr->frame_len = 0;\n\tsptr->have_frame_loaded = 0;\n\tsptr->next_pes_ts.have_dts = sptr->next_pes_ts.have_pts = 0;\n\tsptr->frame_ts.have_dts = sptr->frame_ts.have_pts = 0;\n}\n\n/*\n * convert_to_msec - convert ts (at 90000) to msec, based on base_ts and\n * frames_since_last_ts.\n */\nstatic u64 convert_ts (mpeg2ps_stream_t *sptr,\n                       mpeg2ps_ts_type_t ts_type,\n                       u64 ts,\n                       u64 base_ts,\n                       u32 frames_since_ts)\n{\n\tu64 ret, calc;\n\tret = ts - base_ts;\n\tif (sptr->is_video) {\n\t\t// video\n\t\tret += frames_since_ts * sptr->ticks_per_frame;\n\t} else if (sptr->freq) {\n\t\t// audio\n\t\tcalc = (frames_since_ts * 90000 * sptr->samples_per_frame) / sptr->freq;\n\t\tret += calc;\n\t}\n\tif (ts_type == TS_MSEC)\n\t\tret /= (u64) (90); // * 1000 / 90000\n\n\treturn ret;\n}\n\n/*\n * find_stream_from_id - given the stream, get the sptr.\n * only used in inital set up, really.  APIs use index into\n * video_streams and audio_streams arrays.\n */\nstatic mpeg2ps_stream_t *find_stream_from_id (mpeg2ps_t *ps,\n        u8 stream_id,\n        u8 substream)\n{\n\tu8 ix;\n\tif (stream_id >= 0xe0) {\n\t\tfor (ix = 0; ix < ps->video_cnt; ix++) {\n\t\t\tif (ps->video_streams[ix]->m_stream_id == stream_id) {\n\t\t\t\treturn ps->video_streams[ix];\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfor (ix = 0; ix < ps->audio_cnt; ix++) {\n\t\t\tif (ps->audio_streams[ix]->m_stream_id == stream_id &&\n\t\t\t        (stream_id != 0xbd ||\n\t\t\t         substream == ps->audio_streams[ix]->m_substream_id)) {\n\t\t\t\treturn ps->audio_streams[ix];\n\t\t\t}\n\t\t}\n\t}\n\treturn NULL;\n}\n\n/*\n * add_stream - add a new stream\n */\nstatic Bool add_stream (mpeg2ps_t *ps,\n                        u8 stream_id,\n                        u8 substream,\n                        s64 first_loc,\n                        mpeg2ps_ts_t *ts)\n{\n\tmpeg2ps_stream_t *sptr;\n\n\tsptr = find_stream_from_id(ps, stream_id, substream);\n\tif (sptr != NULL) return 0;\n\n\t// need to add\n\n\tsptr = mpeg2ps_stream_create(stream_id, substream);\n\tsptr->first_pes_loc = first_loc;\n\tif (ts == NULL ||\n\t        (ts->have_dts == 0 && ts->have_pts == 0)) {\n\t\tsptr->first_pes_has_dts = 0;\n\t} else {\n\t\tsptr->start_dts = ts->have_dts ? ts->dts : ts->pts;\n\t\tsptr->first_pes_has_dts = 1;\n\t}\n\tif (sptr->is_video) {\n\t\t// can't be more than 16 - e0 to ef...\n\t\tps->video_streams[ps->video_cnt] = sptr;\n\t\tps->video_cnt++;\n\t} else {\n\t\tif (ps->audio_cnt >= 32) {\n\t\t\tmpeg2ps_stream_destroy(sptr);\n\t\t\treturn 0;\n\t\t}\n\t\tps->audio_streams[ps->audio_cnt] = sptr;\n\t\tps->audio_cnt++;\n\t}\n\treturn 1;\n}\n\nstatic void check_fd_for_stream (mpeg2ps_t *ps,\n                                 mpeg2ps_stream_t *sptr)\n{\n\tif (sptr->m_fd != FDNULL) return;\n\n\tsptr->m_fd = file_open(ps->filename);\n}\n\n/*\n * advance_frame - when we're reading frames, this indicates that we're\n * done.  We will call this when we read a frame, but not when we\n * seek.  It allows us to leave the last frame we're seeking in the\n * buffer\n */\nstatic void advance_frame (mpeg2ps_stream_t *sptr)\n{\n\tsptr->pes_buffer_on += sptr->frame_len;\n\tsptr->have_frame_loaded = 0;\n\tif (sptr->frame_ts.have_dts || sptr->frame_ts.have_pts) {\n\t\tif (sptr->frame_ts.have_dts)\n\t\t\tsptr->last_ts = sptr->frame_ts.dts;\n\t\telse\n\t\t\tsptr->last_ts = sptr->frame_ts.pts;\n\t\tsptr->frames_since_last_ts = 0;\n\t} else {\n\t\tsptr->frames_since_last_ts++;\n\t}\n}\n/*\n * get_info_for_all_streams - loop through found streams - read an\n * figure out the info\n */\nstatic void get_info_for_all_streams (mpeg2ps_t *ps)\n{\n\tu8 stream_ix, max_ix, av;\n\tmpeg2ps_stream_t *sptr;\n\tu8 *buffer;\n\tu32 buflen;\n\n\tfile_seek_to(ps->fd, 0);\n\n\t// av will be 0 for video streams, 1 for audio streams\n\t// av is just so I don't have to dup a lot of code that does the\n\t// same thing.\n\tfor (av = 0; av < 2; av++) {\n\t\tif (av == 0) max_ix = ps->video_cnt;\n\t\telse max_ix = ps->audio_cnt;\n\t\tfor (stream_ix = 0; stream_ix < max_ix; stream_ix++) {\n\t\t\tif (av == 0) sptr = ps->video_streams[stream_ix];\n\t\t\telse sptr = ps->audio_streams[stream_ix];\n\n\t\t\t// we don't open a separate file descriptor yet (only when they\n\t\t\t// start reading or seeking).  Use the one from the ps.\n\t\t\tsptr->m_fd = ps->fd; // for now\n\t\t\tclear_stream_buffer(sptr);\n\t\t\tif (mpeg2ps_stream_read_frame(sptr,\n\t\t\t                              &buffer,\n\t\t\t                              &buflen,\n\t\t\t                              0) == 0) {\n\t\t\t\tsptr->m_stream_id = 0;\n\t\t\t\tsptr->m_fd = FDNULL;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tget_info_from_frame(sptr, buffer, buflen);\n\t\t\t// here - if (sptr->first_pes_has_dts == 0) should be processed\n\t\t\tif (sptr->first_pes_has_dts == 0) {\n\t\t\t\tu32 frames_from_beg = 0;\n\t\t\t\tBool have_frame;\n\t\t\t\tdo {\n\t\t\t\t\tadvance_frame(sptr);\n\t\t\t\t\thave_frame =\n\t\t\t\t\t    mpeg2ps_stream_read_frame(sptr, &buffer, &buflen, 0);\n\t\t\t\t\tframes_from_beg++;\n\t\t\t\t} while (have_frame &&\n\t\t\t\t         sptr->frame_ts.have_dts == 0 &&\n\t\t\t\t         sptr->frame_ts.have_pts == 0 &&\n\t\t\t\t         frames_from_beg < 1000);\n\t\t\t\tif (have_frame == 0 ||\n\t\t\t\t        (sptr->frame_ts.have_dts == 0 &&\n\t\t\t\t         sptr->frame_ts.have_pts == 0)) {\n\t\t\t\t} else {\n\t\t\t\t\tsptr->start_dts = sptr->frame_ts.have_dts ? sptr->frame_ts.dts :\n\t\t\t\t\t                  sptr->frame_ts.pts;\n\t\t\t\t\tif (sptr->is_video) {\n\t\t\t\t\t\tsptr->start_dts -= frames_from_beg * sptr->ticks_per_frame;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tu64 conv;\n\t\t\t\t\t\tconv = sptr->samples_per_frame * 90000;\n\t\t\t\t\t\tconv /= (u64)sptr->freq;\n\t\t\t\t\t\tsptr->start_dts -= conv;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tclear_stream_buffer(sptr);\n\t\t\tsptr->m_fd = FDNULL;\n\t\t}\n\t}\n}\n\n/*\n * mpeg2ps_scan_file - read file, grabbing all the information that\n * we can out of it (what streams exist, timing, etc).\n */\nstatic void mpeg2ps_scan_file (mpeg2ps_t *ps)\n{\n\tu8 stream_id, stream_ix, substream, av_ix, max_cnt;\n\tu16 pes_len, pes_left;\n\tmpeg2ps_ts_t ts;\n\ts64 loc, first_video_loc = 0, first_audio_loc = 0;\n\ts64 check, orig_check;\n\tmpeg2ps_stream_t *sptr;\n\tBool valid_stream;\n\tu8 *buffer;\n\tu32 buflen;\n\tBool have_ts;\n\n\tps->end_loc = file_size(ps->fd);\n\torig_check = check = MAX(ps->end_loc / 50, 200 * 1024);\n\n\t/*\n\t * This part reads and finds the streams.  We check up until we\n\t * find audio and video plus a little, with a max of either 200K or\n\t * the file size / 50\n\t */\n\tloc = 0;\n\twhile (read_to_next_pes_header(ps->fd, &stream_id, &pes_len) &&\n\t        loc < check) {\n\t\tpes_left = pes_len;\n\t\tif (stream_id >= 0xbd && stream_id < 0xf0) {\n\t\t\tloc = file_location(ps->fd) - 6;\n\t\t\tif (read_pes_header_data(ps->fd,\n\t\t\t                         pes_len,\n\t\t\t                         &pes_left,\n\t\t\t                         &have_ts,\n\t\t\t                         &ts) == 0) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvalid_stream = 0;\n\t\t\tsubstream = 0;\n\t\t\tif (stream_id == 0xbd) {\n\t\t\t\tif (file_read_bytes(ps->fd, &substream, 1) == 0) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tpes_left--; // remove byte we just read\n\t\t\t\tif ((substream >= 0x80 && substream < 0x90) ||\n\t\t\t\t        (substream >= 0xa0 && substream < 0xb0)) {\n\t\t\t\t\tvalid_stream = 1;\n\t\t\t\t}\n\t\t\t} else if (stream_id >= 0xc0) {\n\t\t\t\t// audio and video\n\t\t\t\tvalid_stream = 1;\n\t\t\t}\n\t\t\tif (valid_stream) {\n\t\t\t\tif (add_stream(ps, stream_id, substream, loc, &ts)) {\n\t\t\t\t\t// added\n\t\t\t\t\tif (stream_id >= 0xe0) {\n\t\t\t\t\t\tif (ps->video_cnt == 1) {\n\t\t\t\t\t\t\tfirst_video_loc = loc;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (ps->audio_cnt == 1) {\n\t\t\t\t\t\tfirst_audio_loc = loc;\n\t\t\t\t\t}\n\t\t\t\t\tif (ps->audio_cnt > 0 && ps->video_cnt > 0) {\n\t\t\t\t\t\ts64 diff;\n\t\t\t\t\t\tif (first_audio_loc > first_video_loc)\n\t\t\t\t\t\t\tdiff = first_audio_loc - first_video_loc;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tdiff = first_video_loc - first_audio_loc;\n\t\t\t\t\t\tdiff *= 2;\n\t\t\t\t\t\tdiff += first_video_loc;\n\t\t\t\t\t\tif (diff < check) {\n\t\t\t\t\t\t\tcheck = diff;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfile_skip_bytes(ps->fd, pes_left);\n\t}\n\tif (ps->video_cnt == 0 && ps->audio_cnt == 0) {\n\t\treturn;\n\t}\n\t/*\n\t * Now, we go to close to the end, and try to find the last\n\t * dts that we can\n\t */\n\tfile_seek_to(ps->fd, ps->end_loc - orig_check);\n\n\twhile (read_to_next_pes_header(ps->fd, &stream_id, &pes_len)) {\n\t\tloc = file_location(ps->fd) - 6;\n\t\tif (stream_id == 0xbd || (stream_id >= 0xc0 && stream_id < 0xf0)) {\n\t\t\tif (read_pes_header_data(ps->fd,\n\t\t\t                         pes_len,\n\t\t\t                         &pes_left,\n\t\t\t                         &have_ts,\n\t\t\t                         &ts) == 0) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (stream_id == 0xbd) {\n\t\t\t\tif (file_read_bytes(ps->fd, &substream, 1) == 0) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tpes_left--; // remove byte we just read\n\t\t\t\tif (!((substream >= 0x80 && substream < 0x90) ||\n\t\t\t\t        (substream >= 0xa0 && substream < 0xb0))) {\n\t\t\t\t\tfile_skip_bytes(ps->fd, pes_left);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tsubstream = 0;\n\t\t\t}\n\t\t\tsptr = find_stream_from_id(ps, stream_id, substream);\n\t\t\tif (sptr == NULL) {\n\t\t\t\tadd_stream(ps, stream_id, substream, 0, NULL);\n\t\t\t\tsptr = find_stream_from_id(ps, stream_id, substream);\n\t\t\t}\n\t\t\tif (sptr != NULL && have_ts) {\n\t\t\t\tsptr->end_dts = ts.have_dts ? ts.dts : ts.pts;\n\t\t\t\tsptr->end_dts_loc = loc;\n\t\t\t}\n\t\t\tfile_skip_bytes(ps->fd, pes_left);\n\t\t}\n\t}\n\n\t/*\n\t * Now, get the info for all streams, so we can use it again\n\t * we could do this before the above, I suppose\n\t */\n\tget_info_for_all_streams(ps);\n\n\tps->first_dts = (u64) -1;\n\n\t/*\n\t * we need to find the earliest start pts - we use that to calc\n\t * the rest of the timing, so we're 0 based.\n\t */\n\tfor (av_ix = 0; av_ix < 2; av_ix++) {\n\t\tif (av_ix == 0) max_cnt = ps->video_cnt;\n\t\telse max_cnt = ps->audio_cnt;\n\n\t\tfor (stream_ix = 0; stream_ix < max_cnt; stream_ix++) {\n\t\t\tsptr = av_ix == 0 ? ps->video_streams[stream_ix] :\n\t\t\t       ps->audio_streams[stream_ix];\n\t\t\tif (sptr != NULL && sptr->start_dts < ps->first_dts) {\n\t\t\t\tps->first_dts = sptr->start_dts;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * Now, for each thread, we'll start at the last pts location, and\n\t * read the number of frames.  This will give us a max time\n\t */\n\tfor (av_ix = 0; av_ix < 2; av_ix++) {\n\t\tif (av_ix == 0) max_cnt = ps->video_cnt;\n\t\telse max_cnt = ps->audio_cnt;\n\t\tfor (stream_ix = 0; stream_ix < max_cnt; stream_ix++) {\n\t\t\tu32 frame_cnt_since_last;\n\t\t\tsptr = av_ix == 0 ? ps->video_streams[stream_ix] :\n\t\t\t       ps->audio_streams[stream_ix];\n\n\t\t\t// pick up here - find the final time...\n\t\t\tif (sptr && (sptr->end_dts_loc != 0)) {\n\t\t\t\tfile_seek_to(ps->fd, sptr->end_dts_loc);\n\t\t\t\tsptr->m_fd = ps->fd;\n\t\t\t\tframe_cnt_since_last = 0;\n\t\t\t\tclear_stream_buffer(sptr);\n\t\t\t\twhile (mpeg2ps_stream_read_frame(sptr,\n\t\t\t\t                                 &buffer,\n\t\t\t\t                                 &buflen,\n\t\t\t\t                                 1)) {\n\t\t\t\t\tframe_cnt_since_last++;\n\t\t\t\t}\n\t\t\t\tsptr->m_fd = FDNULL;\n\t\t\t\tclear_stream_buffer(sptr);\n\t\t\t\tps->max_time = MAX(ps->max_time,\n\t\t\t\t                   convert_ts(sptr,\n\t\t\t\t                              TS_MSEC,\n\t\t\t\t                              sptr->end_dts,\n\t\t\t\t                              ps->first_dts,\n\t\t\t\t                              frame_cnt_since_last));\n\t\t\t}\n\t\t}\n\t}\n\n\tps->max_dts = (ps->max_time * 90) + ps->first_dts;\n\tfile_seek_to(ps->fd, 0);\n}\n\n/*************************************************************************\n * API routines\n *************************************************************************/\nu64 mpeg2ps_get_max_time_msec (mpeg2ps_t *ps)\n{\n\treturn ps->max_time;\n}\n\nu32 mpeg2ps_get_video_stream_count (mpeg2ps_t *ps)\n{\n\treturn ps->video_cnt;\n}\n\n#define NUM_ELEMENTS_IN_ARRAY(name) ((sizeof((name))) / (sizeof(*(name))))\n\n// routine to check stream number passed.\nstatic Bool invalid_video_streamno (mpeg2ps_t *ps, u32 streamno)\n{\n\tif (streamno >= NUM_ELEMENTS_IN_ARRAY(ps->video_streams)) return 1;\n\tif (ps->video_streams[streamno] == NULL) return 1;\n\treturn 0;\n}\n\n#if 0 //unused\nconst char *mpeg2ps_get_video_stream_name (mpeg2ps_t *ps, u32 streamno)\n{\n\tif (invalid_video_streamno(ps, streamno)) {\n\t\treturn 0;\n\t}\n\tif (ps->video_streams[streamno]->have_mpeg2) {\n\t\treturn \"Mpeg-2\";\n\t}\n\treturn \"Mpeg-1\";\n}\n#endif\n\nmpeg2ps_video_type_t mpeg2ps_get_video_stream_type (mpeg2ps_t *ps,\n        u32 streamno)\n{\n\tif (invalid_video_streamno(ps, streamno)) {\n\t\treturn MPEG_VIDEO_UNKNOWN;\n\t}\n\treturn ps->video_streams[streamno]->have_mpeg2 ? MPEG_VIDEO_MPEG2 : MPEG_VIDEO_MPEG1;\n}\n\nu32 mpeg2ps_get_video_stream_width (mpeg2ps_t *ps, u32 streamno)\n{\n\tif (invalid_video_streamno(ps, streamno)) {\n\t\treturn 0;\n\t}\n\treturn ps->video_streams[streamno]->w;\n}\n\nu32 mpeg2ps_get_video_stream_height (mpeg2ps_t *ps, u32 streamno)\n{\n\tif (invalid_video_streamno(ps, streamno)) {\n\t\treturn 0;\n\t}\n\treturn ps->video_streams[streamno]->h;\n}\n\nu32 mpeg2ps_get_video_stream_aspect_ratio (mpeg2ps_t *ps, u32 streamno)\n{\n\tif (invalid_video_streamno(ps, streamno)) {\n\t\treturn 0;\n\t}\n\treturn ps->video_streams[streamno]->par;\n}\n\nDouble mpeg2ps_get_video_stream_bitrate (mpeg2ps_t *ps, u32 streamno)\n{\n\tif (invalid_video_streamno(ps, streamno)) {\n\t\treturn 0;\n\t}\n\treturn ps->video_streams[streamno]->bit_rate;\n}\n\nDouble mpeg2ps_get_video_stream_framerate (mpeg2ps_t *ps, u32 streamno)\n{\n\tif (invalid_video_streamno(ps, streamno)) {\n\t\treturn 0;\n\t}\n\treturn ps->video_streams[streamno]->frame_rate;\n}\n\nu32 mpeg2ps_get_video_stream_id(mpeg2ps_t *ps, u32 streamno)\n{\n\tif (invalid_video_streamno(ps, streamno)) {\n\t\treturn 0;\n\t}\n\treturn ps->video_streams[streamno]->m_stream_id;\n}\n\nstatic Bool invalid_audio_streamno (mpeg2ps_t *ps, u32 streamno)\n{\n\tif (streamno >= NUM_ELEMENTS_IN_ARRAY(ps->audio_streams)) return 1;\n\tif (ps->audio_streams[streamno] == NULL) return 1;\n\treturn 0;\n}\n\nu32 mpeg2ps_get_audio_stream_count (mpeg2ps_t *ps)\n{\n\treturn ps->audio_cnt;\n}\n\n#if 0 //unused\nconst char *mpeg2ps_get_audio_stream_name (mpeg2ps_t *ps,\n        u32 streamno)\n{\n\tif (invalid_audio_streamno(ps, streamno)) {\n\t\treturn \"none\";\n\t}\n\tif (ps->audio_streams[streamno]->m_stream_id >= 0xc0) {\n\t\tswitch (ps->audio_streams[streamno]->layer) {\n\t\tcase 1:\n\t\t\treturn \"MP1\";\n\t\tcase 2:\n\t\t\treturn \"MP2\";\n\t\tcase 3:\n\t\t\treturn \"MP3\";\n\t\t}\n\t\treturn \"unknown mpeg layer\";\n\t}\n\tif (ps->audio_streams[streamno]->m_substream_id >= 0x80 &&\n\t        ps->audio_streams[streamno]->m_substream_id < 0x90)\n\t\treturn \"AC3\";\n\n\treturn \"LPCM\";\n}\n#endif\n\nmpeg2ps_audio_type_t mpeg2ps_get_audio_stream_type (mpeg2ps_t *ps,\n        u32 streamno)\n{\n\tif (invalid_audio_streamno(ps, streamno)) {\n\t\treturn MPEG_AUDIO_UNKNOWN;\n\t}\n\tif (ps->audio_streams[streamno]->m_stream_id >= 0xc0) {\n\t\treturn MPEG_AUDIO_MPEG;\n\t}\n\tif (ps->audio_streams[streamno]->m_substream_id >= 0x80 &&\n\t        ps->audio_streams[streamno]->m_substream_id < 0x90)\n\t\treturn MPEG_AUDIO_AC3;\n\n\treturn MPEG_AUDIO_LPCM;\n}\n\nu32 mpeg2ps_get_audio_stream_sample_freq (mpeg2ps_t *ps, u32 streamno)\n{\n\tif (invalid_audio_streamno(ps, streamno)) {\n\t\treturn 0;\n\t}\n\treturn ps->audio_streams[streamno]->freq;\n}\n\nu32 mpeg2ps_get_audio_stream_channels (mpeg2ps_t *ps, u32 streamno)\n{\n\tif (invalid_audio_streamno(ps, streamno)) {\n\t\treturn 0;\n\t}\n\treturn ps->audio_streams[streamno]->channels;\n}\n\nu32 mpeg2ps_get_audio_stream_bitrate (mpeg2ps_t *ps, u32 streamno)\n{\n\tif (invalid_audio_streamno(ps, streamno)) {\n\t\treturn 0;\n\t}\n\treturn ps->audio_streams[streamno]->bitrate;\n}\n\nu32 mpeg2ps_get_audio_stream_id (mpeg2ps_t *ps, u32 streamno)\n{\n\tif (invalid_audio_streamno(ps, streamno)) {\n\t\treturn 0;\n\t}\n\treturn ps->audio_streams[streamno]->m_stream_id;\n}\n\n\nmpeg2ps_t *mpeg2ps_init (const char *filename)\n{\n\tmpeg2ps_t *ps;\n\tGF_SAFEALLOC(ps, mpeg2ps_t);\n\n\tif (ps == NULL) {\n\t\treturn NULL;\n\t}\n\tmemset(ps, 0, sizeof(*ps));\n\tps->fd = file_open(filename);\n\tif (file_okay(ps->fd) == 0) {\n\t\tgf_free(ps);\n\t\treturn NULL;\n\t}\n\n\tps->filename = gf_strdup(filename);\n\tmpeg2ps_scan_file(ps);\n\tif (ps->video_cnt == 0 && ps->audio_cnt == 0) {\n\t\tmpeg2ps_close(ps);\n\t\treturn NULL;\n\t}\n\treturn ps;\n}\n\nvoid mpeg2ps_close (mpeg2ps_t *ps)\n{\n\tu32 ix;\n\tif (ps == NULL) return;\n\tfor (ix = 0; ix < ps->video_cnt; ix++) {\n\t\tmpeg2ps_stream_destroy(ps->video_streams[ix]);\n\t\tps->video_streams[ix] = NULL;\n\t}\n\tfor (ix = 0; ix < ps->audio_cnt; ix++) {\n\t\tmpeg2ps_stream_destroy(ps->audio_streams[ix]);\n\t\tps->audio_streams[ix] = NULL;\n\t}\n\n\tif (ps->filename) gf_free(ps->filename);\n\tif (ps->fd) file_close(ps->fd);\n\tgf_free(ps);\n}\n\n/*\n * check_fd_for_stream will make sure we have a fd for the stream we're\n * trying to read - we use a different fd for each stream\n */\n\n/*\n * stream_convert_frame_ts_to_msec - given a \"read\" frame, we'll\n * calculate the msec and freq timestamps.  This can be called more\n * than 1 time, if needed, without changing any variables, such as\n * frames_since_last_ts, which gets updated in advance_frame\n */\nstatic u64 stream_convert_frame_ts_to_msec (mpeg2ps_stream_t *sptr,\n        mpeg2ps_ts_type_t ts_type,\n        u64 base_dts,\n        u32 *freq_ts)\n{\n\tu64 calc_ts;\n\tu32 frames_since_last = 0;\n\tu64 freq_conv;\n\n\tcalc_ts = sptr->last_ts;\n\tif (sptr->frame_ts.have_dts) calc_ts = sptr->frame_ts.dts;\n\telse if (sptr->frame_ts.have_pts) calc_ts = sptr->frame_ts.dts;\n\telse frames_since_last = sptr->frames_since_last_ts + 1;\n\n\tif (freq_ts != NULL) {\n\t\tfreq_conv = calc_ts - base_dts;\n\t\tfreq_conv *= sptr->freq;\n\t\tfreq_conv /= 90000;\n\t\tfreq_conv += frames_since_last * sptr->samples_per_frame;\n\t\t*freq_ts = (u32) (freq_conv & 0xffffffff);\n\t}\n\treturn convert_ts(sptr, ts_type, calc_ts, base_dts, frames_since_last);\n}\n\n/*\n * mpeg2ps_get_video_frame - gets the next frame\n */\nBool mpeg2ps_get_video_frame(mpeg2ps_t *ps, u32 streamno,\n                             u8 **buffer,\n                             u32 *buflen,\n                             u8 *frame_type,\n                             mpeg2ps_ts_type_t ts_type,\n                             u64 *decode_timestamp, u64 *compose_timestamp)\n{\n\tu64 dts, cts;\n\tmpeg2ps_stream_t *sptr;\n\tif (invalid_video_streamno(ps, streamno)) return 0;\n\n\tsptr = ps->video_streams[streamno];\n\tcheck_fd_for_stream(ps, sptr);\n\n\tif (sptr->have_frame_loaded == 0) {\n\t\t// if we don't have the frame in the buffer (like after a seek),\n\t\t// read the next frame\n\t\tif (mpeg2ps_stream_find_mpeg_video_frame(sptr) == 0) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\t*buffer = sptr->pes_buffer + sptr->pes_buffer_on;\n\t*buflen = sptr->frame_len;\n\t// determine frame type\n\tif (frame_type != NULL) {\n\t\t*frame_type = MPEG12_PictHdrType(sptr->pes_buffer +\n\t\t                                 sptr->pict_header_offset);\n\t}\n\n\t// set the timestamps\n\tif (sptr->frame_ts.have_pts)\n\t\tcts = sptr->frame_ts.pts;\n\telse\n\t\tcts = sptr->last_ts + (1+sptr->frames_since_last_ts) * sptr->ticks_per_frame;\n\tif (sptr->frame_ts.have_dts)\n\t\tdts = sptr->frame_ts.dts;\n\telse\n\t\tdts = cts;\n\n\tif (decode_timestamp) *decode_timestamp = dts;\n\tif (compose_timestamp) *compose_timestamp = cts;\n\n\t//indicate that we read this frame - get ready for the next one.\n\tadvance_frame(sptr);\n\n\n\treturn 1;\n}\n\n\n// see above comments\nBool mpeg2ps_get_audio_frame(mpeg2ps_t *ps, u32 streamno,\n                             u8 **buffer,\n                             u32 *buflen,\n                             mpeg2ps_ts_type_t ts_type,\n                             u32 *freq_timestamp,\n                             u64 *timestamp)\n{\n\tmpeg2ps_stream_t *sptr;\n\tif (invalid_audio_streamno(ps, streamno)) return 0;\n\n\tsptr = ps->audio_streams[streamno];\n\tcheck_fd_for_stream(ps, sptr);\n\n\tif (sptr->have_frame_loaded == 0) {\n\t\tif (mpeg2ps_stream_read_frame(sptr, buffer, buflen, 0) == 0)\n\t\t\treturn 0;\n\t}\n\n\tif (freq_timestamp) {\n\t\t/*ts = */stream_convert_frame_ts_to_msec(sptr,\n\t\t                                     ts_type,\n\t\t                                     ps->first_dts,\n\t\t                                     freq_timestamp);\n\t}\n\tif (timestamp != NULL) {\n\t\t*timestamp = sptr->frame_ts.have_pts ? sptr->frame_ts.pts : sptr->frame_ts.dts;\n\t}\n\tadvance_frame(sptr);\n\treturn 1;\n}\n\n#if 0 //unused\nu64 mpeg2ps_get_ps_size(mpeg2ps_t *ps)\n{\n\treturn file_size(ps->fd);\n}\ns64 mpeg2ps_get_video_pos(mpeg2ps_t *ps, u32 streamno)\n{\n\tif (invalid_video_streamno(ps, streamno)) return 0;\n\treturn gf_ftell(ps->video_streams[streamno]->m_fd);\n}\ns64 mpeg2ps_get_audio_pos(mpeg2ps_t *ps, u32 streamno)\n{\n\tif (invalid_audio_streamno(ps, streamno)) return 0;\n\treturn gf_ftell(ps->audio_streams[streamno]->m_fd);\n}\n#endif\n\n\n/***************************************************************************\n * seek routines\n ***************************************************************************/\n/*\n * mpeg2ps_binary_seek - look for a pts that's close to the one that\n * we're looking for.  We have a start ts and location, an end ts and\n * location, and what we're looking for\n */\nstatic void mpeg2ps_binary_seek (mpeg2ps_t *ps,\n\t\t\t\t mpeg2ps_stream_t *sptr,\n\t\t\t\t u64 search_dts,\n\t\t\t\t u64 start_dts,\n\t\t\t\t u64 start_loc,\n\t\t\t\t u64 end_dts,\n\t\t\t\tu64 end_loc)\n{\n  u64 dts_perc;\n  u64 loc;\n  u16 pes_len;\n  Bool have_ts = GF_FALSE;\n  u64 found_loc;\n  u64 found_dts;\n\n  while (1) {\n    /*\n     * It's not a binary search as much as using a percentage between\n     * the start and end dts to start.  We subtract off a bit, so we\n     * approach from the beginning of the file - we're more likely to\n     * hit a pts that way\n     */\n    dts_perc = (search_dts - start_dts) * 1000 / (end_dts - start_dts);\n    dts_perc -= dts_perc % 10;\n\n    loc = ((end_loc - start_loc) * dts_perc) / 1000;\n\n    if (loc == start_loc || loc == end_loc) return;\n\n    clear_stream_buffer(sptr);\n    file_seek_to(sptr->m_fd, start_loc + loc);\n\n    // we'll look for the next pes header for this stream that has a ts.\n    do {\n      if (search_for_next_pes_header(sptr,\n\t\t\t\t     &pes_len,\n\t\t\t\t     &have_ts,\n\t\t\t\t     &found_loc) == GF_FALSE) {\n\treturn;\n      }\n      if (have_ts == GF_FALSE) {\n\tfile_skip_bytes(sptr->m_fd, pes_len);\n      }\n    } while (have_ts == GF_FALSE);\n\n    // record that spot...\n    mpeg2ps_record_pts(sptr, found_loc, &sptr->next_pes_ts);\n\n    found_dts = sptr->next_pes_ts.have_dts ?\n      sptr->next_pes_ts.dts : sptr->next_pes_ts.pts;\n    /*\n     * Now, if we're before the search ts, and within 5 seconds,\n     * we'll say we're close enough\n     */\n    if (found_dts + (5 * 90000) > search_dts &&\n\tfound_dts < search_dts) {\n      file_seek_to(sptr->m_fd, found_loc);\n      return; // found it - we can seek from here\n    }\n    /*\n     * otherwise, move the head or the tail (most likely the head).\n     */\n    if (found_dts > search_dts) {\n      if (found_dts >= end_dts) {\n\tfile_seek_to(sptr->m_fd, found_loc);\n\treturn;\n      }\n      end_loc = found_loc;\n      end_dts = found_dts;\n    } else {\n      if (found_dts <= start_dts) {\n\tfile_seek_to(sptr->m_fd, found_loc);\n\treturn;\n      }\n      start_loc = found_loc;\n      start_dts = found_dts;\n    }\n  }\n}\n\n\n\nstatic mpeg2ps_record_pes_t *search_for_ts (mpeg2ps_stream_t *sptr,\n\t\t\t\t     u64 dts)\n{\n  mpeg2ps_record_pes_t *p, *q;\n  u64 p_diff, q_diff;\n  if (sptr->record_last == NULL) return NULL;\n\n  if (dts > sptr->record_last->dts) return sptr->record_last;\n\n  if (dts < sptr->record_first->dts) return NULL;\n  if (dts == sptr->record_first->dts) return sptr->record_first;\n\n  p = sptr->record_first;\n  q = p->next_rec;\n\n  while (q != NULL && q->dts > dts) {\n    p = q;\n    q = q->next_rec;\n  }\n  if (q == NULL) {\n    return sptr->record_last;\n  }\n\n  p_diff = dts - p->dts;\n  q_diff = q->dts - dts;\n\n  if (p_diff < q_diff) return p;\n  if (q_diff > 90000) return p;\n\n  return q;\n}\n\n\n/*\n * mpeg2ps_seek_frame - seek to the next timestamp after the search timestamp\n * First, find a close DTS (usually minus 5 seconds or closer), then\n * read frames until we get the frame after the timestamp.\n */\nstatic Bool mpeg2ps_seek_frame (mpeg2ps_t *ps,\n\t\t\t\tmpeg2ps_stream_t *sptr,\n\t\t\t\tu64 search_msec_timestamp)\n{\n  u64 dts;\n  mpeg2ps_record_pes_t *rec;\n  u64 msec_ts;\n  u8 *buffer;\n  u32 buflen;\n\n  check_fd_for_stream(ps, sptr);\n  clear_stream_buffer(sptr);\n\n  if (search_msec_timestamp <= 1000) { // first second, start from begin...\n    file_seek_to(sptr->m_fd, sptr->first_pes_loc);\n    return GF_TRUE;\n  }\n  dts = search_msec_timestamp * 90; // 1000 timescale to 90000 timescale\n  dts += ps->first_dts;\n\n  /*\n   * see if the recorded data has anything close\n   */\n  rec = search_for_ts(sptr, dts);\n  if (rec != NULL) {\n    // see if it is close\n    // if we're plus or minus a second, seek to that.\n    if (rec->dts + 90000 >= dts && rec->dts <= dts + 90000) {\n      file_seek_to(sptr->m_fd, rec->location);\n      return GF_TRUE;\n    }\n    // at this point, rec is > a distance.  If within 5 or so seconds,\n\n    if (rec->dts + (5 * 90000) < dts) {\n      // more than 5 seconds away - skip and search\n      if (rec->next_rec == NULL) {\n\t\t  mpeg2ps_binary_seek(ps, sptr, dts,\n\t\t\t    rec->dts, rec->location,\n\t\t\t    sptr->end_dts, sptr->end_dts_loc);\n      } else {\n\t\t  mpeg2ps_binary_seek(ps, sptr, dts,\n\t\t\t    rec->dts, rec->location,\n\t\t\t    rec->next_rec->dts, rec->next_rec->location);\n      }\n    }\n    // otherwise, frame by frame search...\n  } else {\n    // we weren't able to find anything from the recording\n    mpeg2ps_binary_seek(ps, sptr, dts,\n\t\t\tsptr->start_dts, sptr->first_pes_loc,\n\t\t\tsptr->end_dts, sptr->end_dts_loc);\n  }\n  /*\n   * Now, the fun part - read frames until we're just past the time\n   */\n  clear_stream_buffer(sptr); // clear out any data, so we can read it\n  do {\n    if (mpeg2ps_stream_read_frame(sptr, &buffer, &buflen, GF_FALSE) == GF_FALSE)\n      return GF_FALSE;\n\n    msec_ts = stream_convert_frame_ts_to_msec(sptr, TS_MSEC,\n\t\t\t\t\t      ps->first_dts, NULL);\n\n    if (msec_ts < search_msec_timestamp) {\n      // only advance the frame if we're not greater than the timestamp\n      advance_frame(sptr);\n    }\n  } while (msec_ts < search_msec_timestamp);\n\n  return GF_TRUE;\n}\n\n\n/*\n * mpeg2ps_seek_video_frame - seek to the location that we're interested\n * in, then scroll up to the next I frame\n */\nBool mpeg2ps_seek_video_frame (mpeg2ps_t *ps, u32 streamno,\n\t\t\t       u64 msec_timestamp)\n{\n  mpeg2ps_stream_t *sptr;\n\n  if (invalid_video_streamno(ps, streamno)) return GF_FALSE;\n\n  sptr = ps->video_streams[streamno];\n  if (mpeg2ps_seek_frame(ps,\n\t\t\t sptr,\n\t\t\t msec_timestamp)\n\t\t\t  == GF_FALSE) return GF_FALSE;\n\n  if (sptr->have_frame_loaded == GF_FALSE) {\n    return GF_FALSE;\n  }\n  return GF_TRUE;\n}\n/*\n * mpeg2ps_seek_audio_frame - go to the closest audio frame after the\n * timestamp\n */\nBool mpeg2ps_seek_audio_frame (mpeg2ps_t *ps,\n\t\t\t       u32 streamno,\n\t\t\t       u64 msec_timestamp)\n{\n  //  off_t closest_pes;\n  mpeg2ps_stream_t *sptr;\n\n  if (invalid_audio_streamno(ps, streamno)) return GF_FALSE;\n\n  sptr = ps->audio_streams[streamno];\n  if (mpeg2ps_seek_frame(ps,\n\t\t\t sptr,\n\t\t\t msec_timestamp) == GF_FALSE) return GF_FALSE;\n\n  return GF_TRUE;\n}\n\nu64 mpeg2ps_get_first_cts(mpeg2ps_t *ps)\n{\n\treturn ps->first_dts;\n}\n\n\n#endif /*GPAC_DISABLE_MPEG2PS*/\n"], "fixing_code": ["/*\n *\t\t\tGPAC - Multimedia Framework C SDK\n *\n *\t\t\tAuthors: Jean Le Feuvre\n *\t\t\tCopyright (c) Telecom ParisTech 2018-2023\n *\t\t\t\t\tAll rights reserved\n *\n *  This file is part of GPAC / MPEG-DASH/HLS segmenter\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n#include <gpac/filters.h>\n#include <gpac/constants.h>\n#include <gpac/iso639.h>\n#include <gpac/mpd.h>\n#include <gpac/internal/media_dev.h>\n#include <gpac/base_coding.h>\n#include <gpac/network.h>\n#include <gpac/crypt_tools.h>\n\n#ifndef GPAC_DISABLE_DASHER\n\n#define DEFAULT_PERIOD_ID\t \"_gf_dash_def_period\"\n\ntypedef struct\n{\n\tGF_List *streams;\n\n\t//period element we will fill\n\tGF_MPD_Period *period;\n} GF_DasherPeriod;\n\nenum\n{\n\tDASHER_BS_SWITCH_DEF=0,\n\tDASHER_BS_SWITCH_OFF,\n\tDASHER_BS_SWITCH_ON,\n\tDASHER_BS_SWITCH_INBAND,\n\tDASHER_BS_SWITCH_INBAND_PPS,\n\tDASHER_BS_SWITCH_BOTH,\n\tDASHER_BS_SWITCH_FORCE,\n\tDASHER_BS_SWITCH_MULTI,\n};\n\ntypedef enum\n{\n\tDASHER_UTCREF_NONE=0,\n\tDASHER_UTCREF_NTP,\n\tDASHER_UTCREF_HTTP_HEAD,\n\tDASHER_UTCREF_ISO,\n\tDASHER_UTCREF_XSDATE,\n\tDASHER_UTCREF_INBAND,\n} DasherUTCTimingType;\n\nenum\n{\n\tDASHER_NTP_REM=0,\n\tDASHER_NTP_YES,\n\tDASHER_NTP_KEEP,\n};\n\nenum\n{\n\tDASHER_SAP_OFF=0,\n\tDASHER_SAP_SIG,\n\tDASHER_SAP_ON,\n\tDASHER_SAP_INTRA_ONLY,\n};\n\nenum\n{\n\tDASHER_BOUNDS_OUT=0,\n\tDASHER_BOUNDS_CLOSEST,\n\tDASHER_BOUNDS_IN,\n};\n\nenum\n{\n\tDASHER_MUX_ISOM=0,\n\tDASHER_MUX_TS,\n\tDASHER_MUX_MKV,\n\tDASHER_MUX_WEBM,\n\tDASHER_MUX_OGG,\n\tDASHER_MUX_RAW,\n\tDASHER_MUX_AUTO,\n};\n\nenum\n{\n\tDASHER_MPHA_NO=0,\n\tDASHER_MPHA_COMP_ONLY,\n\tDASHER_MPHA_ALL\n};\n\nenum\n{\n\tDASHER_FWD_NO = 0,\n\tDASHER_FWD_SEGS,\n\tDASHER_FWD_ALL,\n};\n\nenum\n{\n\t//unknown samples sync state at startup\n\tDASHER_SYNC_UNKNOWN=0,\n\t//all samples sync\n\tDASHER_SYNC_NONE,\n\t//some samples sync\n\tDASHER_SYNC_PRESENT,\n};\n\nenum\n{\n\tDASHER_CMAF_NONE=0,\n\tDASHER_CMAF_CMFC,\n\tDASHER_CMAF_CMF2\n};\n\nenum\n{\n\tDASHER_DEFKID_OFF=0,\n\tDASHER_DEFKID_ON,\n\tDASHER_DEFKID_AUTO\n};\n\nenum\n{\n\tDASHER_PSWITCH_SINGLE=0,\n\tDASHER_PSWITCH_FORCE,\n\tDASHER_PSWITCH_STSD\n};\nenum\n{\n\tDASHER_SEGSYNC_NO=0,\n\tDASHER_SEGSYNC_YES,\n\tDASHER_SEGSYNC_AUTO\n};\n\nenum\n{\n\tIDXMODE_NONE=0,\n\tIDXMODE_ALL,\n\tIDXMODE_MANIFEST,\n\tIDXMODE_CHILD,\n\tIDXMODE_INIT,\n\tIDXMODE_SEG,\n};\n\ntypedef struct\n{\n\tu32 bs_switch, profile, spd, cp, ntp;\n\ts32 subs_sidx;\n\ts32 buf, timescale;\n\tBool sfile, sseg, no_sar, mix_codecs, stl, tpl, align, sap, no_frag_def, sidx, split, hlsc, strict_cues, force_flush, last_seg_merge;\n\tu32 mha_compat;\n\tu32 strict_sap;\n\tu32 pssh;\n\tu32 cmaf;\n\tu32 dkid;\n\tGF_Fraction segdur;\n\tu32 dmode;\n\tchar *template;\n\tchar *segext;\n\tchar *initext;\n\tu32 muxtype;\n\tBool rawsub;\n\tchar *profX;\n\tDouble asto;\n\tchar *ast;\n\tchar *state;\n\tchar *cues;\n\tchar *title, *source, *info, *cprt, *lang;\n\tchar *chain, *chain_fbk;\n\tGF_PropStringList location, base;\n\tBool check_dur, skip_seg, loop, reschedule, scope_deps, keep_src, tpl_force;\n\tDouble refresh, tsb, subdur;\n\tu64 *_p_gentime, *_p_mpdtime;\n\tBool cmpd, dual, sreg;\n\tchar *styp;\n\tBool sigfrag;\n\tu32 sbound, pswitch;\n\tchar *utcs;\n\tchar *mname;\n\tchar *hlsdrm;\n\tchar *ckurl;\n\tGF_PropStringList hlsx;\n\tu32 llhls;\n\t//inherited from mp4mx\n\tGF_Fraction cdur;\n\tBool ll_preload_hint, ll_rend_rep;\n\tBool gencues, force_init, gxns;\n\tDouble ll_part_hb;\n\tu32 hls_absu, seg_sync;\n\n\t//internal\n\tBool in_error;\n\n\t//Manifest output pid\n\tGF_FilterPid *opid;\n\n\tGF_FilterPid *opid_alt;\n\tGF_Filter *alt_dst;\n\tBool opid_alt_m3u8;\n\n\tGF_MPD *mpd;\n\n\tGF_DasherPeriod *current_period, *next_period;\n\tGF_List *pids;\n\tBool template_use_source;\n\ts32 period_idx;\n\n\tGF_List *tpl_records;\n\tBool use_xlink, use_cenc, check_main_role, use_clearkey;\n\n\t//options for muxers, constrained by profile\n\tBool no_fragments_defaults;\n\n\tBool is_eos;\n\tu32 nb_seg_url_pending;\n\tu64 last_evt_check_time;\n\tBool on_demand_done;\n\tBool subdur_done;\n\tchar *out_path;\n\n\tGF_Err setup_failure;\n\n\tDouble nb_secs_to_discard;\n\tBool first_context_load, store_init_params;\n\tBool do_m3u8, do_mpd;\n\tu32 do_index;\n\tBool is_period_restore, is_empty_period;\n\n\tBool store_seg_states;\n\n\tGF_List *postponed_pids;\n\tu32 last_dyn_period_id;\n\tu32 next_pid_id_in_period;\n\tBool post_play_events;\n\n\tBool force_period_switch;\n\tBool period_not_ready;\n\tBool check_connections;\n\n\t//-1 forces report update, otherwise this is a packet count\n\ts32 update_report;\n\n\tBool purge_segments;\n\n\tBool is_playing;\n\n\tBool no_seg_dur;\n\n\tu32 utc_initialized;\n#ifdef GPAC_USE_DOWNLOADER\n\tGF_DownloadSession *utc_sess;\n#endif\n\n\tDasherUTCTimingType utc_timing_type;\n\ts32 utc_diff;\n\n\tBool is_route;\n\n\tBool force_hls_ll_manifest;\n\n\tu32 forward_mode;\n\t\n\tu8 last_hls_signature[GF_SHA1_DIGEST_SIZE], last_mpd_signature[GF_SHA1_DIGEST_SIZE], last_hls2_signature[GF_SHA1_DIGEST_SIZE];\n\n\tGF_CryptInfo *cinfo;\n\n\tBool use_cues;\n\tBool dyn_rate;\n\n\tu64 min_segment_start_time, last_min_segment_start_time;\n\n\tu32 def_max_seg_dur;\n\n\tu32 index_max_seg_dur;\n\tu64 index_media_duration;\n\tGF_Fraction64 min_cts_period;\n\n\tu32 from_index;\n\tu32 def_template;\n\n\tBool move_to_static;\n} GF_DasherCtx;\n\ntypedef enum\n{\n\tDASHER_HDR_NONE=0,\n\tDASHER_HDR_PQ10,\n\tDASHER_HDR_HLG,\n} DasherHDRType;\n\ntypedef struct _dash_stream\n{\n\tGF_FilterPid *ipid, *opid;\n\n\t//stream properties\n\tu32 codec_id, timescale, stream_type, dsi_crc, dsi_enh_crc, id, dep_id, src_id;\n\tGF_Fraction sar, fps;\n\tu32 width, height;\n\tu32 sr, nb_ch;\n\tchar *lang;\n\tBool interlaced, rawmux;\n\tconst GF_PropertyValue *p_role;\n\tconst GF_PropertyValue *p_period_desc;\n\tconst GF_PropertyValue *p_as_desc;\n\tconst GF_PropertyValue *p_as_any_desc;\n\tconst GF_PropertyValue *p_rep_desc;\n\tconst GF_PropertyValue *p_base_url;\n\tchar *template;\n\tchar *xlink;\n\tchar *hls_vp_name;\n\tu32 nb_surround, nb_lfe, atmos_complexity_type;\n\tu64 ch_layout;\n\tGF_PropVec4i srd;\n\tDasherHDRType hdr_type;\n\tBool sscale;\n\n\t//TODO: get the values for all below\n\tu32 view_id;\n\t//end of TODO\n\n\n\tu32 bitrate;\n\tGF_DasherPeriod *period;\n\tGF_MPD_Period *last_period;\n\n\tGF_Fraction dash_dur;\n\n\tchar *period_id;\n\tchar *period_continuity_id;\n\tGF_Fraction64 period_start;\n\tGF_Fraction64 period_dur;\n\t//0: not done, 1: eos/abort, 2: subdur exceeded\n\tu32 done;\n\tBool seg_done;\n\n\tu32 nb_comp, nb_comp_done;\n\n\tBool is_av;\n\n\tu32 nb_rep, nb_rep_done;\n\tDouble set_seg_duration;\n\n\t//repID for this stream, generated if not found\n\tchar *rep_id;\n\t//AS ID for this stream, may be 0\n\tu32 as_id;\n\tu32 sync_as_id;\n\tstruct _dash_stream *muxed_base;\n\tGF_List *complementary_streams;\n\tGF_List *comp_pids;\n\n\t//the one and only representation element\n\tGF_MPD_Representation *rep;\n\t//the parent adaptation set\n\tGF_MPD_AdaptationSet *set;\n\tBool owns_set;\n\t//set to 1 if full inband params, 2 if pps/aps only, 3 if both inband and outband, 0 otherwise\n\tu32 inband_params;\n\tGF_List *multi_pids;\n\tGF_List *multi_tracks;\n\t//in case we share the same init segment, we MUST use the same timescale\n\tu32 force_timescale;\n\n\n\tu32 startNumber, seg_number;\n\tBool rep_init;\n\tBool forced_period_switch;\n\tu64 first_cts;\n\tu64 first_dts;\n\ts64 pts_minus_cts;\n\tBool is_encrypted;\n\t//only used for SegmentTimeline\n\tu64 presentation_time_offset;\n\n\t//target MPD timescale\n\tu32 mpd_timescale;\n\t//segment start time in target MPD timescale\n\tu64 seg_start_time;\n\tBool split_set_names;\n\tBool skip_tpl_reuse;\n\tu64 max_period_dur;\n\n\tGF_Filter *dst_filter;\n\n\tchar *src_url;\n\n\tchar *init_seg, *seg_template, *idx_template;\n\tu32 nb_sap_3, nb_sap_4;\n\t//ID of output pid (renumbered), used for content component and making sure output muxers use the same IDs\n\tu32 pid_id;\n\t//dependency ID of output pid (renumbered)\n\tu32 dep_pid_id;\n\tu32 nb_samples_in_source;\n\tu32 sync_points_type;\n\t//seg urls not yet handled (waiting for size/index callbacks)\n\tGF_List *pending_segment_urls;\n\t//segment states not yet handled (waiting for size/index/etc callbacks), used for M3U8 and state mode\n\tGF_List *pending_segment_states;\n\t//next segment start time in this stream timescale (NOT MPD timescale)\n\tu64 next_seg_start;\n\t//adjusted next segment start time in this stream timescale (NOT MPD timescale)\n\t//the value is the same as next_seg_start until the end of segment is found (SAP)\n\t//in which case it is adjusted to the SAP time\n\tu64 adjusted_next_seg_start;\n\n\t//force representation time end in this stream timescale (NOT MPD timescale)\n\tu64 force_rep_end;\n\n\tBool segment_started;\n\tu64 first_cts_in_seg;\n\tu64 first_cts_in_next_seg;\n\tu64 min_cts_in_seg_plus_one;\n\t//used for last segment computation of segmentTimeline\n\tu64 est_first_cts_in_next_seg;\n\tu64 last_cts, last_dts;\n\tu64 cumulated_dur;\n\tDouble cumulated_subdur;\n\tBool subdur_done;\n\tu64 subdur_forced_use_period_dur;\n\tu64 nb_pck;\n\tu64 est_next_dts;\n\tu64 seek_to_pck;\n\tu64 ts_offset;\n\tu32 nb_repeat;\n\n\tBool splitable;\n\tu32 loop_state;\n\tu32 split_dur_next;\n\n\tu32 moof_sn_inc, moof_sn;\n\tGF_Fraction64 clamped_dur;\n\n\tu32 nb_segments_purged;\n\tDouble dur_purged;\n\tBool tile_base;\n\tBool tile_dep_id_merged;\n\tstruct _dash_stream *merged_tile_dep;\n\n\tu32 cues_timescale;\n\tu32 nb_cues;\n\tGF_DASHCueInfo *cues;\n\tBool cues_use_edits;\n\ts32 cues_ts_offset;\n\tBool inband_cues;\n\t\n\tBool clamp_done;\n\tu32 dcd_not_ready;\n\n\tBool reschedule;\n\n\tGF_Fraction64 duration;\n\tGF_List *packet_queue;\n\tu32 nb_sap_in_queue;\n\tu32 sbound;\n\n\tu32 request_period_switch;\n\n\t//gm_ for gen manifest\n\tDouble gm_duration_total, gm_duration_min, gm_duration_max;\n\tu32 gm_nb_segments;\n\n\tBool no_seg_dur;\n\t//for route\n\tu64 hls_ref_id;\n\tGF_DASH_SegmentContext *current_seg_state;\n\n\tBool transcode_detected;\n\n\t//HLS full seg encryption\n\tGF_CryptInfo *cinfo;\n\tGF_TrackCryptInfo *tci;\n\tu64 iv_low, iv_high;\n\tu32 key_idx;\n\tu32 nb_crypt_seg;\n\n\tBool dyn_bitrate;\n\tu64 rate_first_dts_plus_one, rate_last_dts;\n\tu64 rate_media_size;\n\n\tu64 period_continuity_next_cts;\n\n\tu64 last_min_segment_start_time;\n\tBool stl;\n\n\tBool set_period_switch;\n\tu32 all_stsd_crc;\n\n\tu64 frag_start_offset, frag_first_ftdt;\n} GF_DashStream;\n\nstatic void dasher_flush_segment(GF_DasherCtx *ctx, GF_DashStream *ds, Bool is_last_in_period);\nstatic void dasher_update_rep(GF_DasherCtx *ctx, GF_DashStream *ds);\nstatic void dasher_reset_stream(GF_Filter *filter, GF_DashStream *ds, Bool is_destroy);\nstatic void dasher_update_period_duration(GF_DasherCtx *ctx, Bool is_period_switch);\nstatic GF_Err dasher_setup_period(GF_Filter *filter, GF_DasherCtx *ctx, GF_DashStream *for_ds);\nstatic GF_Err dasher_setup_profile(GF_DasherCtx *ctx);\n\nstatic GF_DasherPeriod *dasher_new_period()\n{\n\tGF_DasherPeriod *period;\n\tGF_SAFEALLOC(period, GF_DasherPeriod);\n\tif (period)\n\t\tperiod->streams = gf_list_new();\n\treturn period;\n}\n\n#ifndef GPAC_DISABLE_AV_PARSERS\nstatic GF_Err dasher_get_audio_info_with_m4a_sbr_ps(GF_DashStream *ds, const GF_PropertyValue *dsi, u32 *SampleRate, u32 *Channels)\n{\n\tGF_M4ADecSpecInfo a_cfg;\n\tGF_Err e;\n\tif (SampleRate) *SampleRate = ds->sr;\n\tif (Channels) *Channels = ds->nb_ch;\n\n\tif (!dsi) {\n\t\tif (!ds->dcd_not_ready) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_DASH, (\"[Dasher] missing AAC config\\n\"));\n\t\t}\n\t\treturn GF_OK;\n\t}\n\te = gf_m4a_get_config(dsi->value.data.ptr, dsi->value.data.size, &a_cfg);\n\tif (e) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_DASH, (\"[Dasher] corrupted AAC Config, %s\\n\", gf_error_to_string(e)));\n\t\treturn GF_NOT_SUPPORTED;\n\t}\n\tif (SampleRate && a_cfg.has_sbr) {\n\t\t*SampleRate = a_cfg.sbr_sr;\n\t}\n\tif (Channels) *Channels = a_cfg.nb_chan;\n\treturn e;\n}\n#endif\n\n\nstatic void dasher_check_outpath(GF_DasherCtx *ctx)\n{\n\tif (!ctx->out_path) {\n\t\tctx->out_path = gf_filter_pid_get_destination(ctx->opid);\n\t\tif (!ctx->out_path) return;\n\n\t\tif (ctx->mname) {\n\t\t\tchar *sep = strstr(ctx->out_path, \"://\");\n\t\t\tif (sep) {\n\t\t\t\tchar *opath = gf_url_concatenate(ctx->out_path, ctx->mname);\n\t\t\t\tif (opath) {\n\t\t\t\t\tgf_free(ctx->out_path);\n\t\t\t\t\tctx->out_path = opath;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//check if we have a route/atsc output, in which we will case assign hls ref prop\n\t\tif (!strncmp(ctx->out_path, \"route://\", 8) || !strncmp(ctx->out_path, \"atsc://\", 7))\n\t\t\tctx->is_route = GF_TRUE;\n\t}\n\t//for routeout\n\tif (ctx->opid)\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_URL, &PROP_STRING(ctx->out_path) );\n\tif (ctx->opid_alt)\n\t\tgf_filter_pid_set_property(ctx->opid_alt, GF_PROP_PID_URL, &PROP_STRING(ctx->out_path) );\n}\n\n\nstatic GF_Err dasher_hls_setup_crypto(GF_DasherCtx *ctx, GF_DashStream *ds)\n{\n#ifndef GPAC_DISABLE_CRYPTO\n\tGF_Err e;\n\tu32 pid_id=1;\n\tu32 i, count;\n\tconst GF_PropertyValue *p;\n\tGF_CryptInfo *cinfo = NULL;\n\tconst char *drm = ctx->hlsdrm;\n\tif (!ctx->do_m3u8) return GF_OK;\n\tif (ds->is_encrypted) return GF_OK;\n\tp = gf_filter_pid_get_property(ds->ipid, GF_PROP_PID_CRYPT_INFO);\n\tif (p)\n\t\tdrm = p->value.string;\n\telse\n\t\tcinfo = ctx->cinfo;\n\tif (!drm && !cinfo) return GF_OK;\n\n\tif (ctx->sfile) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_DASH, (\"[Dasher] Cannot use HLS segment encryption with single file output\\n\"));\n\t\treturn GF_BAD_PARAM;\n\t}\n\n\tif (!cinfo) {\n\t\tcinfo = gf_crypt_info_load(drm, &e);\n\t\tif (!cinfo) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_DASH, (\"[Dasher] Cannot load HLS DRM file %s\\n\", drm ));\n\t\t\treturn e;\n\t\t}\n\t\tif (p) {\n\t\t\tif (ds->cinfo) gf_crypt_info_del(ds->cinfo);\n\t\t\tds->cinfo = cinfo;\n\t\t} else {\n\t\t\tctx->cinfo = cinfo;\n\t\t}\n\t}\n\tds->tci = NULL;\n\tp = gf_filter_pid_get_property(ds->ipid, GF_PROP_PID_ID);\n\tif (p) pid_id = p->value.uint;\n\tcount = gf_list_count(cinfo->tcis);\n\tfor (i=0; i<count; i++) {\n\t\tGF_TrackCryptInfo *tci = gf_list_get(cinfo->tcis, i);\n\t\tif (tci->trackID && (tci->trackID != pid_id)) continue;\n\n\t\tds->tci = tci;\n\t\tbreak;\n\t}\n\tif (!ds->tci) return GF_OK;\n\n\tds->key_idx = 0;\n\tds->iv_low = ds->iv_high = 0;\n\tfor (i=0; i<8; i++) {\n\t\tds->iv_high |= ds->tci->keys[ds->key_idx].IV[i];\n\t\tds->iv_low |= ds->tci->keys[ds->key_idx].IV[i + 8];\n\t\tif (i<7) {\n\t\t\tds->iv_high <<= 8;\n\t\t\tds->iv_low <<= 8;\n\t\t}\n\t}\n\treturn GF_OK;\n#else\n\treturn GF_NOT_SUPPORTED;\n#endif\n}\n\nstatic u32 dasher_get_dep_bitrate(GF_DasherCtx *ctx, GF_DashStream *ds)\n{\n\tu32 bitrate = ds->bitrate;\n\tif (ds->dep_id) {\n\t\tu32 i, count = gf_list_count(ctx->current_period->streams);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tGF_DashStream *a_ds = gf_list_get(ctx->current_period->streams, i);\n\t\t\tif (a_ds == ds) continue;\n\n\t\t\tif (gf_list_find(a_ds->complementary_streams, ds)>=0) {\n\n\t\t\t\tbitrate += dasher_get_dep_bitrate(ctx, a_ds);\n\t\t\t}\n\t\t}\n\t}\n\treturn bitrate;\n}\n\nstatic void dasher_update_bitrate(GF_DasherCtx *ctx, GF_DashStream *ds)\n{\n\tu64 rate;\n\tu32 scaler;\n\tif (!ds->dyn_bitrate || ds->bitrate) {\n\t\treturn;\n\t}\n\n\tif (!ds->rate_first_dts_plus_one) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_DASH, (\"[Dasher] Couldn't compute bitrate of PID %s in time for manifest generation, please specify #Bitrate property\\n\", gf_filter_pid_get_name(ds->ipid)));\n\t\treturn;\n\t}\n\n\trate = ds->rate_media_size;\n\trate *= 8;\n\tif (ds->rate_last_dts > ds->rate_first_dts_plus_one - 1) {\n\t\trate *= ds->timescale;\n\t\trate /= (ds->rate_last_dts - ds->rate_first_dts_plus_one + 1);\n\t} else {\n\t\trate *= ds->dash_dur.den;\n\t\trate /= ds->dash_dur.num;\n\t}\n\t//express rates in 100kbps or 10kbps, and if ds is done, trust the average, otherwise add 10%\n\tscaler = (rate > 1000000) ? 100000 : 10000;\n\tif (rate > 10*scaler) {\n\t\trate /= scaler;\n\t\tif (!ds->done) scaler = 11 * scaler / 10;\n\t\trate *= scaler;\n\t}\n\n\tds->bitrate = (u32) rate;\n\n\tif (ds->rep) {\n\t\tds->rep->bandwidth = ds->bitrate;\n\n\t\tif (ds->dep_id) {\n\t\t\tds->rep->bandwidth = dasher_get_dep_bitrate(ctx, ds);\n\t\t} else if (ds->nb_comp && !ds->muxed_base) {\n\t\t\tu32 i, count = gf_list_count(ctx->current_period->streams);\n\t\t\tfor (i=0; i<count; i++) {\n\t\t\t\tGF_DashStream *a_ds = gf_list_get(ctx->current_period->streams, i);\n\t\t\t\tif (ds == a_ds) continue;\n\t\t\t\tif (a_ds->muxed_base != ds) continue;\n\t\t\t\tif (a_ds->dyn_bitrate) {\n\t\t\t\t\tdasher_update_bitrate(ctx, a_ds);\n\t\t\t\t}\n\t\t\t\tds->rep->bandwidth += a_ds->bitrate;\n\t\t\t}\n\t\t}\n\t}\n\n\t//keep refreshing our rate estimation\n\tif (!ds->done && (ds->dyn_bitrate==1))\n\t\tds->bitrate = 0;\n}\n\n\nstatic GF_Err dasher_stream_period_changed(GF_Filter *filter, GF_DasherCtx *ctx, GF_DashStream *ds, Bool is_new_period_request)\n{\n\tGF_Err e = GF_OK;\n\t//period switching, check the stream is still scheduled - if so and not done, flush it, update period duration\n\ts32 res = gf_list_find(ctx->current_period->streams, ds);\n\t//force end of segment if stream is not yet done and in current period\n\tif ((res>=0) && !ds->done && !ds->seg_done) {\n\t\tGF_DashStream *base_ds;\n\n\t\tbase_ds = ds->muxed_base ? ds->muxed_base : ds;\n\t\tif (is_new_period_request) {\n\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_DASH, (\"[Dasher] New period requested during PID %s reconfiguration\\n\", gf_filter_pid_get_name(ds->ipid) ));\n\t\t} else {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_DASH, (\"[Dasher] PID %s config changed during active period, forcing period switch\\n\", gf_filter_pid_get_name(ds->ipid) ));\n\t\t}\n\t\tds->seg_done = GF_TRUE;\n\t\tif(base_ds->nb_comp_done >= base_ds->nb_comp) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_DASH, (\"[Dasher] Invalid new period: %u components processed (max %u expected)\\n\", base_ds->nb_comp_done, base_ds->nb_comp));\n\t\t\te = GF_BAD_PARAM;\n\t\t\tgoto exit;\n\t\t}\n\t\tbase_ds->nb_comp_done ++;\n\t\tds->first_cts_in_next_seg = ds->est_first_cts_in_next_seg;\n\n\t\tif (base_ds->nb_comp_done == base_ds->nb_comp) {\n\t\t\tdasher_flush_segment(ctx, base_ds, GF_TRUE);\n\t\t}\n\n\t\tctx->force_period_switch = GF_TRUE;\n\t\tdasher_update_period_duration(ctx, GF_TRUE);\n\t}\n\t//remove stream from period\n\tif (res>=0) {\n\t\t//force an EOS on this stream for ondemand / side index generation flush\n\t\tif (ds->opid)\n\t\t\tgf_filter_pid_set_eos(ds->opid);\n\t\tds->rep_init = GF_FALSE;\n\t\t//indicate this input is moved to next period. If a scheduled input is muxed with this one in the current period\n\t\t//it will abort its current segment\n\t\tds->forced_period_switch = GF_TRUE;\n\t\tds->presentation_time_offset = 0;\n\t\tgf_list_rem(ctx->current_period->streams, res);\n\t} else {\n\t\t//stream is not in current period, and this is not an explicit new period request\n\t\t//if the period was not ready (not yet setup), add to current streams\n\t\t//this is needed for cases such as HEVC tiling where secondary pids are added after the main pid is configured\n\t\t//see issue 1849\n\t\tif (!is_new_period_request && ctx->period_not_ready && !ds->rep) {\n\t\t\tgf_list_add(ctx->current_period->streams, ds);\n\t\t\tds->period = ctx->current_period;\n\t\t\tds->request_period_switch = 0;\n\t\t\te = GF_OK;\n\t\t\tgoto exit;\n\t\t}\n\t}\n\tds->request_period_switch = 0;\n\n\t//this is tricky, when reassigning period IDs in the middle of a stream, we may have cases where some streams\n\t//are ready several packets before other streams due to processing delay, which results in period switch signal not\n\t//happening at the same time\n\tif (is_new_period_request && !ds->rep && ctx->current_period->period && gf_list_count(ctx->current_period->streams)) {\n\t\tBool inject_in_period = GF_FALSE;\n\t\tif (ds->period_id && ctx->current_period->period->ID && !strcmp(ds->period_id, ctx->current_period->period->ID))\n\t\t\tinject_in_period = GF_TRUE;\n\t\telse if ((ctx->period_idx>0) && (ds->period_start.num<0) && ((s32) -ds->period_start.num == ctx->period_idx))\n\t\t\tinject_in_period = GF_TRUE;\n\t\telse if (ds->period_start.num * 1000 == ctx->current_period->period->start * ds->period_start.den)\n\t\t\tinject_in_period = GF_TRUE;\n\n\t\tif (inject_in_period) {\n\t\t\tgf_list_add(ctx->current_period->streams, ds);\n\t\t\tds->period = ctx->current_period;\n\t\t\tdasher_setup_period(filter, ctx, ds);\n\t\t\t//force a MPD publish asap\n\t\t\tif (ctx->dmode != GF_DASH_STATIC)\n\t\t\t\tctx->mpd->publishTime = 0;\n\t\t\te = GF_OK;\n\t\t\tgoto exit;\n\t\t}\n\t}\n\tgf_list_add(ctx->next_period->streams, ds);\n\tds->period = ctx->next_period;\n\nexit:\n\n\tds->stl = ctx->stl;\n\tif (ctx->sigfrag) {\n\t\tconst GF_PropertyValue *p = gf_filter_pid_get_property_str(ds->ipid, \"source_template\");\n\t\tif (p) {\n\t\t\tp = gf_filter_pid_get_property_str(ds->ipid, \"stl_timescale\");\n\t\t\tif (p && p->value.uint) {\n\t\t\t\tds->stl = GF_TRUE;\n\t\t\t\tds->mpd_timescale = p->value.uint;\n\t\t\t} else if (ctx->stl) {\n\t\t\t\tds->mpd_timescale = ds->timescale;\n\t\t\t}\n\t\t}\n\t}\n\treturn e;\n}\n\nstatic void dasher_get_dash_dur(GF_DasherCtx *ctx, GF_DashStream *ds)\n{\n\tds->dash_dur = ctx->segdur;\n\tconst GF_PropertyValue *p = gf_filter_pid_get_property(ds->ipid, GF_PROP_PID_DASH_DUR);\n\tif (p) {\n\t\tds->dash_dur = p->value.frac;\n\t\tds->no_seg_dur = GF_FALSE;\n\t\tif (!ds->dash_dur.num || !ds->dash_dur.den) {\n\t\t\tds->dash_dur.num = 1;\n\t\t\tds->dash_dur.den = 1;\n\t\t}\n\t}\n\t//this avoids very weird cases where (u64) (dash_dur*timescale) is 0. we limit the max segment duration to 1M sec, a bit more than 11.5 days\n\tif ((u64) ds->dash_dur.num > (u64)ds->dash_dur.den * 1000000) {\n\t\tds->dash_dur.num = 1000000;\n\t\tds->dash_dur.den = 1;\n\t}\n}\n\nstatic void dasher_send_encode_hints(GF_DasherCtx *ctx, GF_DashStream *ds)\n{\n\tif (!ctx->sfile && !ds->stl && !ctx->use_cues) {\n\t\tGF_FilterEvent evt;\n\t\tGF_FEVT_INIT(evt, GF_FEVT_ENCODE_HINTS, ds->ipid)\n\t\tif (!ds->dash_dur.num)\n\t\t\tdasher_get_dash_dur(ctx, ds);\n\n\t\tswitch (ctx->from_index) {\n\t\tcase IDXMODE_NONE:\n\t\t\tevt.encode_hints.intra_period = ds->dash_dur;\n\t\t\tbreak;\n\t\tcase IDXMODE_SEG:\n\t\tcase IDXMODE_CHILD:\n\t\t\tbreak;\n\t\tcase IDXMODE_ALL:\n\t\tcase IDXMODE_INIT:\n\t\tcase IDXMODE_MANIFEST:\n\t\t\tevt.encode_hints.gen_dsi_only = GF_TRUE;\n\t\t\tbreak;\n\t\t}\n\n\t\tgf_filter_pid_send_event(ds->ipid, &evt);\n\t}\n}\n\nstatic Bool dasher_template_use_source_url(const char *template)\n{\n\tif (!template) return GF_FALSE;\n\tif (strstr(template, \"$File$\") != NULL) return GF_TRUE;\n\telse if (strstr(template, \"$FSRC$\") != NULL) return GF_TRUE;\n\telse if (strstr(template, \"$SourcePath$\") != NULL) return GF_TRUE;\n\telse if (strstr(template, \"$FURL$\") != NULL) return GF_TRUE;\n\telse if (strstr(template, \"$URL$\") != NULL) return GF_TRUE;\n\treturn GF_FALSE;\n}\n\nstatic GF_Err dasher_configure_pid(GF_Filter *filter, GF_FilterPid *pid, Bool is_remove)\n{\n\tBool period_switch = GF_FALSE;\n\tconst GF_PropertyValue *p, *dsi=NULL;\n\tu32 dc_crc, dc_enh_crc;\n\tGF_Err e;\n\tGF_DashStream *ds;\n\tBool old_period_switch;\n\tu32 prev_stream_type;\n\tBool new_period_request = GF_FALSE;\n\tconst char *cue_file=NULL;\n\ts64 old_clamp_dur = 0;\n\tGF_DasherCtx *ctx = gf_filter_get_udta(filter);\n\n\tif (is_remove) {\n\t\tds = gf_filter_pid_get_udta(pid);\n\t\tif (ds) {\n\t\t\tif (ds->dyn_bitrate) dasher_update_bitrate(ctx, ds);\n\t\t\tgf_list_del_item(ctx->pids, ds);\n\t\t\tgf_list_del_item(ctx->current_period->streams, ds);\n\t\t\tif (ctx->next_period)\n\t\t\t\tgf_list_del_item(ctx->next_period->streams, ds);\n\t\t\tdasher_reset_stream(filter, ds, GF_TRUE);\n\t\t\tgf_free(ds);\n\t\t}\n\t\treturn GF_OK;\n\t}\n\tctx->check_connections = GF_TRUE;\n\tif (!ctx->opid && !ctx->gencues) {\n\t\tu32 i, nb_opids = ctx->dual ? 2 : 1;\n\t\tfor (i=0; i < nb_opids; i++) {\n\t\t\tchar *segext=NULL;\n\t\t\tchar *force_ext=NULL;\n\t\t\tGF_FilterPid *opid;\n\t\t\tif (i==0) {\n\t\t\t\tctx->opid = gf_filter_pid_new(filter);\n\t\t\t\tgf_filter_pid_set_name(ctx->opid, \"MANIFEST\");\n\t\t\t\topid = ctx->opid;\n\t\t\t} else {\n\t\t\t\tif (!ctx->alt_dst && ctx->out_path) {\n\t\t\t\t\tchar szSRC[100];\n\t\t\t\t\tGF_FileIO *gfio = NULL;\n\t\t\t\t\tchar *mpath = ctx->out_path;\n\t\t\t\t\tu32 len;\n\t\t\t\t\tif (!strncmp(mpath, \"gfio://\", 7)) {\n\t\t\t\t\t\tgfio = gf_fileio_from_url(mpath);\n\t\t\t\t\t\tif (!gfio) return GF_BAD_PARAM;\n\t\t\t\t\t\t//only use basename as we will create the new resource through factory\n\t\t\t\t\t\tmpath = (char *) gf_file_basename(gf_fileio_resource_url(gfio));\n\t\t\t\t\t\tif (!mpath) return GF_OUT_OF_MEM;\n\t\t\t\t\t}\n\n\t\t\t\t\tlen = (u32) strlen(mpath);\n\t\t\t\t\tchar *out_path = gf_malloc(len+10);\n\t\t\t\t\tif (!out_path) return GF_OUT_OF_MEM;\n\t\t\t\t\tmemcpy(out_path, mpath, len);\n\t\t\t\t\tout_path[len]=0;\n\t\t\t\t\tchar *sep = gf_file_ext_start(out_path);\n\t\t\t\t\tif (sep) sep[0] = 0;\n\t\t\t\t\tif (ctx->do_m3u8) {\n\t\t\t\t\t\tstrcat(out_path, \".mpd\");\n\t\t\t\t\t\tforce_ext = \"mpd\";\n\t\t\t\t\t} else {\n\t\t\t\t\t\tctx->opid_alt_m3u8 = GF_TRUE;\n\t\t\t\t\t\tctx->do_m3u8 = GF_TRUE;\n\t\t\t\t\t\tstrcat(out_path, \".m3u8\");\n\t\t\t\t\t\tforce_ext = \"m3u8\";\n\t\t\t\t\t}\n\t\t\t\t\tif (gfio) {\n\t\t\t\t\t\tconst char *rel = gf_fileio_factory(gfio, out_path);\n\t\t\t\t\t\tgf_free(out_path);\n\t\t\t\t\t\tout_path = gf_strdup(rel);\n\t\t\t\t\t\tif (!out_path) return GF_OUT_OF_MEM;\n\t\t\t\t\t}\n\n\t\t\t\t\tctx->alt_dst = gf_filter_connect_destination(filter, out_path, &e);\n\t\t\t\t\tif (e) {\n\t\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_DASH, (\"[Dasher] Couldn't create secondary manifest output %s: %s\\n\", out_path, gf_error_to_string(e) ));\n\t\t\t\t\t\tgf_free(out_path);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tgf_free(out_path);\n\n\t\t\t\t\t//reset any sourceID given in the dst_arg and assign sourceID to be the dasher filter\n\t\t\t\t\tgf_filter_reset_source(ctx->alt_dst);\n\t\t\t\t\tsnprintf(szSRC, 100, \"MuxSrc%cdasher_%p\", gf_filter_get_sep(filter, GF_FS_SEP_NAME), ctx->alt_dst);\n\t\t\t\t\tgf_filter_set_source(ctx->alt_dst, filter, szSRC);\n\n\t\t\t\t\tctx->opid_alt = gf_filter_pid_new(filter);\n\t\t\t\t\tgf_filter_pid_set_name(ctx->opid_alt, \"MANIFEST_ALT\");\n\n\t\t\t\t\tsnprintf(szSRC, 100, \"dasher_%p\", ctx->alt_dst);\n\t\t\t\t\tgf_filter_pid_set_property(ctx->opid_alt, GF_PROP_PID_MUX_SRC, &PROP_STRING(szSRC) );\n\t\t\t\t\t//we also need to set the property on main output just to avoid the connection\n\t\t\t\t\tsnprintf(szSRC, 100, \"dasher_%p\", ctx);\n\t\t\t\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_MUX_SRC, &PROP_STRING(szSRC) );\n\t\t\t\t}\n\t\t\t\topid = ctx->opid_alt;\n\t\t\t}\n\t\t\tif (!opid)\n\t\t\t\tcontinue;\n\n\t\t\t//copy properties at init or reconfig\n\t\t\tgf_filter_pid_copy_properties(opid, pid);\n\t\t\tgf_filter_pid_set_property(opid, GF_PROP_PID_DECODER_CONFIG, NULL);\n\t\t\tgf_filter_pid_set_property(opid, GF_PROP_PID_DECODER_CONFIG_ENHANCEMENT, NULL);\n\t\t\tgf_filter_pid_set_property(opid, GF_PROP_PID_CODECID, NULL);\n\t\t\tgf_filter_pid_set_property(opid, GF_PROP_PID_UNFRAMED, NULL);\n\t\t\tgf_filter_pid_set_property(opid, GF_PROP_PID_STREAM_TYPE, &PROP_UINT(GF_STREAM_FILE) );\n\t\t\t//for routeout\n\t\t\tgf_filter_pid_set_property(opid, GF_PROP_PID_PREMUX_STREAM_TYPE, &PROP_UINT(GF_STREAM_FILE) );\n\n\t\t\tdasher_check_outpath(ctx);\n\n\t\t\tp = gf_filter_pid_caps_query(pid, GF_PROP_PID_FILE_EXT);\n\t\t\tif (p) {\n\t\t\t\tgf_filter_pid_set_property(opid, GF_PROP_PID_FILE_EXT, p );\n\t\t\t\tsegext = p->value.string;\n\t\t\t} else {\n\t\t\t\tsegext = NULL;\n\t\t\t\tif (ctx->out_path) {\n\t\t\t\t\tsegext = gf_file_ext_start(ctx->out_path);\n\t\t\t\t} else if (ctx->mname) {\n\t\t\t\t\tsegext = gf_file_ext_start(ctx->mname);\n\t\t\t\t}\n\t\t\t\tif (!segext) segext = \"mpd\";\n\t\t\t\telse segext++;\n\t\t\t\tif (force_ext)\n\t\t\t\t\tsegext = force_ext;\n\t\t\t\tgf_filter_pid_set_property(opid, GF_PROP_PID_FILE_EXT, &PROP_STRING(segext) );\n\n\t\t\t\tif (!strcmp(segext, \"m3u8\")) {\n\t\t\t\t\tgf_filter_pid_set_property(opid, GF_PROP_PID_MIME, &PROP_STRING(\"video/mpegurl\"));\n\t\t\t\t} else if (!strcmp(segext, \"ghi\")) {\n\t\t\t\t\tgf_filter_pid_set_property(opid, GF_PROP_PID_MIME, &PROP_STRING(\"application/x-gpac-ghi\"));\n\t\t\t\t} else if (!strcmp(segext, \"ghix\")) {\n\t\t\t\t\tgf_filter_pid_set_property(opid, GF_PROP_PID_MIME, &PROP_STRING(\"application/x-gpac-ghix\"));\n\t\t\t\t} else {\n\t\t\t\t\tgf_filter_pid_set_property(opid, GF_PROP_PID_MIME, &PROP_STRING(\"application/dash+xml\"));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tu32 manifest_type = 0;\n\t\t\tif (!strcmp(segext, \"m3u8\")) {\n\t\t\t\tctx->do_m3u8 = GF_TRUE;\n\t\t\t\tgf_filter_pid_set_name(opid, \"manifest_m3u8\" );\n\t\t\t\tmanifest_type = 2;\n\t\t\t} else if (!strcmp(segext, \"ghix\") || !strcmp(segext, \"ghi\")) {\n\t\t\t\tctx->do_index = !strcmp(segext, \"ghix\") ? 2 : 1;\n\t\t\t\tctx->sigfrag = GF_FALSE;\n\t\t\t\tctx->align = ctx->sap = GF_TRUE;\n\t\t\t\tctx->sseg = ctx->sfile = ctx->tpl = GF_FALSE;\n\t\t\t\tif (ctx->state) {\n\t\t\t\t\tgf_free(ctx->state);\n\t\t\t\t\tctx->state = NULL;\n\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_DASH, (\"[Dasher] Index generation mode, disabling state\\n\" ));\n\t\t\t\t}\n\t\t\t\tif (!ctx->template)\n\t\t\t\t\tctx->template = gf_strdup(\"$RepresentationID$-$Number$$Init=init$\");\n\n\t\t\t\tgf_filter_pid_set_name(opid, \"dash_index\" );\n\t\t\t\tmanifest_type = 3;\n\t\t\t} else {\n\t\t\t\tctx->do_mpd = GF_TRUE;\n\t\t\t\tgf_filter_pid_set_name(opid, \"manifest_mpd\" );\n\t\t\t\tmanifest_type = 1;\n\t\t\t}\n\t\t\tgf_filter_pid_set_property(opid, GF_PROP_PID_IS_MANIFEST, &PROP_UINT(manifest_type));\n\t\t}\n\n\t\tctx->store_seg_states = GF_FALSE;\n\t\t//in m3u8 mode, always store all seg states. In MPD only if state, not ondemand\n\t\tif (((ctx->state || ctx->purge_segments) && !ctx->sseg) || ctx->do_m3u8) ctx->store_seg_states = GF_TRUE;\n\t}\n\n\tds = gf_filter_pid_get_udta(pid);\n\tif (!ds) {\n\t\tGF_SAFEALLOC(ds, GF_DashStream);\n\t\tif (!ds) return GF_OUT_OF_MEM;\n\t\tds->ipid = pid;\n\t\tgf_list_add(ctx->pids, ds);\n\t\tds->complementary_streams = gf_list_new();\n\t\tperiod_switch = GF_TRUE;\n\t\tgf_filter_pid_set_udta(pid, ds);\n\t\tds->sbound = ctx->sbound;\n\t\tds->startNumber = 1;\n\t\tif (ctx->sbound!=DASHER_BOUNDS_OUT)\n\t\t\tds->packet_queue = gf_list_new();\n\n\t\t/*initial connection and we already have sent play event, send a PLAY on this new PID\n\t\tTODO: we need to send STOP/PLAY depending on period\n\t\t*/\n\t\tif (ctx->is_playing) {\n\t\t\tGF_FilterEvent evt;\n\n\t\t\tdasher_send_encode_hints(ctx, ds);\n\n\t\t\tGF_FEVT_INIT(evt, GF_FEVT_PLAY, ds->ipid);\n\t\t\tevt.play.speed = 1.0;\n\t\t\tgf_filter_pid_send_event(ds->ipid, &evt);\n\t\t}\n\t\t//don't create pid at this time except in gencues mode\n\n\t\tif (ctx->gencues) {\n\t\t\tds->opid = gf_filter_pid_new(filter);\n\t\t\tgf_filter_pid_copy_properties(ds->opid, pid);\n\t\t\tgf_filter_pid_set_property(ds->opid, GF_PROP_PID_DASH_CUE, &PROP_STRING(\"inband\") );\n\t\t}\n\t}\n\n\tgf_filter_pid_set_framing_mode(pid, GF_TRUE);\n\n#define CHECK_PROP(_type, _mem, _e) \\\n\tp = gf_filter_pid_get_property(pid, _type); \\\n\tif (!p && (_e<=0) ) return _e; \\\n\tif (p && (p->value.uint != _mem) && _mem) period_switch = GF_TRUE; \\\n\tif (p) _mem = p->value.uint; \\\n\n#define CHECK_PROPL(_type, _mem, _e) \\\n\tp = gf_filter_pid_get_property(pid, _type); \\\n\tif (!p && (_e<=0) ) return _e; \\\n\tif (p && (p->value.longuint != _mem) && _mem) period_switch = GF_TRUE; \\\n\tif (p) _mem = p->value.longuint; \\\n\n#define CHECK_PROP_BOOL(_type, _mem, _e) \\\n\tp = gf_filter_pid_get_property(pid, _type); \\\n\tif (!p && (_e<=0) ) return _e; \\\n\tif (p && (p->value.boolean != _mem) && _mem) period_switch = GF_TRUE; \\\n\tif (p) _mem = p->value.uint; \\\n\n#define CHECK_PROP_FRAC(_type, _mem, _e) \\\n\tp = gf_filter_pid_get_property(pid, _type); \\\n\tif (!p && (_e<=0) ) return _e; \\\n\tif (p && (p->value.frac.num * _mem.den != p->value.frac.den * _mem.num) && _mem.den && _mem.num) period_switch = GF_TRUE; \\\n\tif (p) _mem = p->value.frac; \\\n\n#define CHECK_PROP_FRAC64(_type, _mem, _e) \\\n\tp = gf_filter_pid_get_property(pid, _type); \\\n\tif (!p && (_e<=0) ) return _e; \\\n\tif (p && (p->value.lfrac.num * _mem.den != p->value.lfrac.den * _mem.num) && _mem.den && _mem.num) period_switch = GF_TRUE; \\\n\tif (p) _mem = p->value.lfrac; \\\n\n\n#define CHECK_PROP_STR(_type, _mem, _e) \\\n\tp = gf_filter_pid_get_property(pid, _type); \\\n\tif (!p && (_e<=0) ) return _e; \\\n\tif (p && p->value.string && _mem && strcmp(_mem, p->value.string)) period_switch = GF_TRUE; \\\n\tif (p) { \\\n\t\tif (_mem) gf_free(_mem); \\\n\t\t_mem = gf_strdup(p->value.string); \\\n\t}\\\n\n\n#define CHECK_PROP_PROP(_type, _mem, _e) \\\n\tp = gf_filter_pid_get_property(pid, _type); \\\n\tif (!p && (_e<=0) ) return _e; \\\n\tif (p != _mem) period_switch = GF_TRUE;\\\n\t_mem = p; \\\n\n\n\tprev_stream_type = ds->stream_type;\n\tCHECK_PROP(GF_PROP_PID_STREAM_TYPE, ds->stream_type, GF_NOT_SUPPORTED)\n\n\tif (ctx->sigfrag) {\n\t\tp = gf_filter_pid_get_property_str(pid, \"nofrag\");\n\t\tif (p && p->value.boolean) {\n\t\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_URL);\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[IsoMedia] sigfrag requested but file %s is not fragmented\\n\", p->value.string));\n\t\t\treturn GF_BAD_PARAM;\n\t\t}\n\t}\n\n\tds->tile_base = GF_FALSE;\n\n\tif (ds->stream_type != GF_STREAM_FILE) {\n\t\tu32 prev_bitrate = ds->bitrate;\n\t\tif (ds->stream_type==GF_STREAM_ENCRYPTED) {\n\t\t\tCHECK_PROP(GF_PROP_PID_ORIG_STREAM_TYPE, ds->stream_type, GF_EOS)\n\t\t\tds->is_encrypted = GF_TRUE;\n\t\t}\n\t\tif (prev_stream_type==ds->stream_type)\n\t\t\tperiod_switch = GF_FALSE;\n\n\t\tCHECK_PROP(GF_PROP_PID_BITRATE, ds->bitrate, GF_EOS)\n\t\tif (!ds->bitrate && prev_bitrate) {\n\t\t\tds->bitrate = prev_bitrate;\n\t\t\tperiod_switch = GF_FALSE;\n\t\t}\n\t\tif (ds->bitrate && period_switch) {\n\t\t\t//allow 20% variation in bitrate, otherwise force period switch\n\t\t\tif ((ds->bitrate <= 120 * prev_bitrate / 100) && (ds->bitrate >= 80 * prev_bitrate / 100)) {\n\t\t\t\tperiod_switch = GF_FALSE;\n\t\t\t}\n\t\t}\n\n\t\tCHECK_PROP(GF_PROP_PID_CODECID, ds->codec_id, GF_NOT_SUPPORTED)\n\t\tCHECK_PROP(GF_PROP_PID_TIMESCALE, ds->timescale, GF_NOT_SUPPORTED)\n\n\t\tif (ds->stream_type==GF_STREAM_VISUAL) {\n\t\t\tCHECK_PROP(GF_PROP_PID_WIDTH, ds->width, GF_EOS)\n\t\t\tCHECK_PROP(GF_PROP_PID_HEIGHT, ds->height, GF_EOS)\n\t\t\t//don't return if not defined\n\t\t\tCHECK_PROP_FRAC(GF_PROP_PID_SAR, ds->sar, GF_EOS)\n\t\t\tif (!ds->sar.num) ds->sar.num = ds->sar.den = 1;\n\t\t\tCHECK_PROP_FRAC(GF_PROP_PID_FPS, ds->fps, GF_EOS)\n\n\n\t\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_TILE_BASE);\n\t\t\tif (p) {\n\t\t\t\tds->srd.x = ds->srd.y = 0;\n\t\t\t\tds->srd.z = ds->width;\n\t\t\t\tds->srd.w = ds->height;\n\t\t\t\tds->tile_base = GF_TRUE;\n\t\t\t} else {\n\t\t\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_CROP_POS);\n\t\t\t\tif (p && ((p->value.vec2i.x != ds->srd.x) || (p->value.vec2i.y != ds->srd.y) ) ) period_switch = GF_TRUE;\n\t\t\t\tif (p) {\n\t\t\t\t\tds->srd.x = p->value.vec2i.x;\n\t\t\t\t\tds->srd.y = p->value.vec2i.y;\n\t\t\t\t\tds->srd.z = ds->width;\n\t\t\t\t\tds->srd.w = ds->height;\n\t\t\t\t} else {\n\t\t\t\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_SRD);\n\t\t\t\t\tif (p && (\n\t\t\t\t\t\t(p->value.vec4i.x != ds->srd.x)\n\t\t\t\t\t\t|| (p->value.vec4i.y != ds->srd.y)\n\t\t\t\t\t\t|| (p->value.vec4i.z != ds->srd.z)\n\t\t\t\t\t\t|| (p->value.vec4i.w != ds->srd.w)\n\t\t\t\t\t) )\n\t\t\t\t\t\tperiod_switch = GF_TRUE;\n\n\t\t\t\t\tif (p) {\n\t\t\t\t\t\tds->srd.x = p->value.vec4i.x;\n\t\t\t\t\t\tds->srd.y = p->value.vec4i.y;\n\t\t\t\t\t\tds->srd.z = p->value.vec4i.z;\n\t\t\t\t\t\tds->srd.w = p->value.vec4i.w;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (ds->stream_type==GF_STREAM_AUDIO) {\n\t\t\tCHECK_PROP(GF_PROP_PID_SAMPLE_RATE, ds->sr, GF_EOS)\n\t\t\tCHECK_PROP(GF_PROP_PID_NUM_CHANNELS, ds->nb_ch, GF_EOS)\n\t\t\tCHECK_PROPL(GF_PROP_PID_CHANNEL_LAYOUT, ds->ch_layout, GF_EOS)\n\t\t}\n\n\t\told_period_switch = period_switch;\n\n\t\t//these ones can change without triggering period switch\n\t\tCHECK_PROP(GF_PROP_PID_NB_FRAMES, ds->nb_samples_in_source, GF_EOS)\n\t\tCHECK_PROP_FRAC64(GF_PROP_PID_DURATION, ds->duration, GF_EOS)\n\t\tCHECK_PROP_STR(GF_PROP_PID_URL, ds->src_url, GF_EOS)\n\t\tperiod_switch = old_period_switch;\n\t\tif (ds->duration.num<0) ds->duration.num = 0;\n\n\t\tCHECK_PROP(GF_PROP_PID_ID, ds->id, GF_EOS)\n\t\tCHECK_PROP(GF_PROP_PID_DEPENDENCY_ID, ds->dep_id, GF_EOS)\n\n\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_HAS_SYNC);\n\t\tu32 sync_type = DASHER_SYNC_UNKNOWN;\n\t\tif (p) sync_type = p->value.boolean ? DASHER_SYNC_PRESENT : DASHER_SYNC_NONE;\n\t\tif ((sync_type != DASHER_SYNC_UNKNOWN) && (sync_type != ds->sync_points_type)) {\n\t\t\tperiod_switch = GF_TRUE;\n\t\t\tds->sync_points_type = sync_type;\n\t\t}\n\t\t\n\t\tif (ds->inband_cues)\n\t\t\tperiod_switch = old_period_switch;\n\n\t\tif (ctx->scope_deps) {\n\t\t\tconst char *src_args = gf_filter_pid_orig_src_args(pid, GF_TRUE);\n\t\t\tif (src_args) {\n\t\t\t\tds->src_id = gf_crc_32(src_args, (u32) strlen(src_args));\n\t\t\t}\n\t\t}\n\n\t\t//check if we had up-front declarations of codec configs\n\t\tif (ctx->pswitch==DASHER_PSWITCH_STSD) {\n\t\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_ISOM_STSD_ALL_TEMPLATES);\n\t\t\tif (p) {\n\t\t\t\tu32 all_stsd_crc = gf_crc_32(p->value.data.ptr, p->value.data.size);\n\t\t\t\t//same config, we assume the muxer dealt with this at setup, reset dsi crc to skip period switch test below\n\t\t\t\tif (all_stsd_crc==ds->all_stsd_crc) {\n\t\t\t\t\tds->dsi_crc = 0;\n\t\t\t\t\tds->dsi_enh_crc = 0;\n\t\t\t\t} else {\n\t\t\t\t\tds->all_stsd_crc = all_stsd_crc;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tds->all_stsd_crc = 0;\n\t\t\t}\n\t\t}\n\n\t\tdc_crc = 0;\n\t\tdsi = p = gf_filter_pid_get_property(pid, GF_PROP_PID_DECODER_CONFIG);\n\t\tif (p && (p->type==GF_PROP_DATA))\n\t\t\tdc_crc = gf_crc_32(p->value.data.ptr, p->value.data.size);\n\n\t\tdc_enh_crc = 0;\n\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_DECODER_CONFIG_ENHANCEMENT);\n\t\tif (p && (p->type==GF_PROP_DATA)) dc_enh_crc = gf_crc_32(p->value.data.ptr, p->value.data.size);\n\n\t\tif (((dc_crc != ds->dsi_crc) && ds->dsi_crc)\n\t\t\t|| ((dc_enh_crc != ds->dsi_enh_crc) && ds->dsi_enh_crc)\n\t\t) {\n\t\t\t//check which codecs can support inband param sets\n\t\t\tswitch (ds->codec_id) {\n\t\t\tcase GF_CODECID_AVC:\n\t\t\tcase GF_CODECID_SVC:\n\t\t\tcase GF_CODECID_MVC:\n\t\t\tcase GF_CODECID_HEVC:\n\t\t\tcase GF_CODECID_LHVC:\n\t\t\t\tif (!ctx->bs_switch)\n\t\t\t\t\tperiod_switch = GF_TRUE;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tperiod_switch = GF_TRUE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t//check if input is ready\n\t\tds->dcd_not_ready = 0;\n\t\tif (!dc_crc && !dc_enh_crc) {\n\t\t\tswitch (ds->codec_id) {\n\t\t\tcase GF_CODECID_AVC:\n\t\t\tcase GF_CODECID_SVC:\n\t\t\tcase GF_CODECID_MVC:\n\t\t\tcase GF_CODECID_HEVC:\n\t\t\tcase GF_CODECID_LHVC:\n\t\t\tcase GF_CODECID_AAC_MPEG4:\n\t\t\tcase GF_CODECID_AAC_MPEG2_MP:\n\t\t\tcase GF_CODECID_AAC_MPEG2_LCP:\n\t\t\tcase GF_CODECID_AAC_MPEG2_SSRP:\n\t\t\tcase GF_CODECID_USAC:\n\t\t\tcase GF_CODECID_AC3:\n\t\t\tcase GF_CODECID_EAC3:\n\t\t\tcase GF_CODECID_AV1:\n\t\t\tcase GF_CODECID_VP8:\n\t\t\tcase GF_CODECID_VP9:\n\t\t\t\tds->dcd_not_ready = gf_sys_clock();\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tds->dsi_crc = dc_crc;\n\n\t\tCHECK_PROP_STR(GF_PROP_PID_TEMPLATE, ds->template, GF_EOS)\n\t\tCHECK_PROP_STR(GF_PROP_PID_LANGUAGE, ds->lang, GF_EOS)\n\t\tCHECK_PROP_BOOL(GF_PROP_PID_INTERLACED, ds->interlaced, GF_EOS)\n\t\tCHECK_PROP_PROP(GF_PROP_PID_AS_COND_DESC, ds->p_as_desc, GF_EOS)\n\t\tCHECK_PROP_PROP(GF_PROP_PID_AS_ANY_DESC, ds->p_as_any_desc, GF_EOS)\n\t\tCHECK_PROP_PROP(GF_PROP_PID_REP_DESC, ds->p_rep_desc, GF_EOS)\n\t\tCHECK_PROP_PROP(GF_PROP_PID_BASE_URL, ds->p_base_url, GF_EOS)\n\t\tCHECK_PROP_PROP(GF_PROP_PID_ROLE, ds->p_role, GF_EOS)\n\t\tCHECK_PROP_STR(GF_PROP_PID_HLS_PLAYLIST, ds->hls_vp_name, GF_EOS)\n\t\tCHECK_PROP_BOOL(GF_PROP_PID_SINGLE_SCALE, ds->sscale, GF_EOS)\n\n\t\t//if manifest generation mode with template and no template at PID or filter level, switch to main profile\n\t\tif (ctx->sigfrag && ctx->tpl && !ctx->template && !ds->template) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_DASH, (\"[Dasher] Warning, manifest generation only mode requested for live-based profile but no template provided, switching to main profile.\\n\"));\n\t\t\tctx->profile = GF_DASH_PROFILE_MAIN;\n\t\t\tctx->tpl = GF_FALSE;\n\t\t\tdasher_setup_profile(ctx);\n\t\t\t//we force single file in this mode, but we will replace byte ranges by source URL\n\t\t\tctx->sfile = GF_TRUE;\n\t\t}\n\n\t\tif (ds->rate_first_dts_plus_one)\n\t\t\tdasher_update_bitrate(ctx, ds);\n\n\t\tif (!ds->bitrate) {\n\t\t\tchar *tpl = ds->template ? ds->template : ctx->template;\n\t\t\tif (tpl && strstr(tpl, \"$Bandwidth$\")) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_DASH, (\"[Dasher] No bitrate property assigned to PID %s but template uses $Bandwidth$, cannot initialize !\\n\\tTry specifying bitrate property after your source, e.g. -i source.raw:#Bitrate=VAL\\n\", gf_filter_pid_get_name(ds->ipid)));\n\t\t\t\tctx->in_error = GF_TRUE;\n\t\t\t\treturn GF_BAD_PARAM;\n\t\t\t} else {\n\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_DASH, (\"[Dasher] No bitrate property assigned to PID %s, computing from bitstream\\n\", gf_filter_pid_get_name(ds->ipid)));\n\t\t\t\tds->dyn_bitrate = GF_TRUE;\n\t\t\t\tds->rate_first_dts_plus_one = 0;\n\t\t\t\tds->rate_media_size = 0;\n\t\t\t}\n\t\t} else {\n\t\t\tds->dyn_bitrate = GF_FALSE;\n\t\t}\n\n\t\tif (!ds->src_url)\n\t\t\tds->src_url = gf_strdup(\"file\");\n\n\t\tCHECK_PROP(GF_PROP_PID_START_NUMBER, ds->startNumber, GF_EOS)\n\n\t\tds->no_seg_dur = ctx->no_seg_dur;\n\t\tdasher_get_dash_dur(ctx, ds);\n\n\t\tds->splitable = GF_FALSE;\n\t\tds->is_av = GF_FALSE;\n\t\tswitch (ds->stream_type) {\n\t\tcase GF_STREAM_TEXT:\n\t\tcase GF_STREAM_METADATA:\n\t\tcase GF_STREAM_OD:\n\t\tcase GF_STREAM_SCENE:\n\t\t\tds->splitable = ctx->split;\n\t\t\tbreak;\n\t\tcase GF_STREAM_VISUAL:\n\t\tcase GF_STREAM_AUDIO:\n\t\t\tds->is_av = GF_TRUE;\n\t\t\tbreak;\n\t\t}\n\n\t\told_clamp_dur = ds->clamped_dur.num;\n\t\tds->clamped_dur.num = 0;\n\t\tds->clamped_dur.den = 1;\n\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_CLAMP_DUR);\n\t\tif (p && p->value.lfrac.den) ds->clamped_dur = p->value.lfrac;\n\n\t\t//HDR\n#if !defined(GPAC_DISABLE_AV_PARSERS)\n\t\tif (dsi) {\n\t\t\tif (ds->codec_id == GF_CODECID_LHVC || ds->codec_id == GF_CODECID_HEVC_TILES || ds->codec_id == GF_CODECID_HEVC) {\n\t\t\t\tGF_HEVCConfig* hevccfg = gf_odf_hevc_cfg_read(dsi->value.data.ptr, dsi->value.data.size, GF_FALSE);\n\t\t\t\tif (hevccfg) {\n\t\t\t\t\tBool is_interlaced;\n\t\t\t\t\tHEVCState hevc;\n\t\t\t\t\tHEVC_SPS* sps;\n\t\t\t\t\tmemset(&hevc, 0, sizeof(HEVCState));\n\t\t\t\t\tgf_hevc_parse_ps(hevccfg, &hevc, GF_HEVC_NALU_VID_PARAM);\n\t\t\t\t\tgf_hevc_parse_ps(hevccfg, &hevc, GF_HEVC_NALU_SEQ_PARAM);\n\t\t\t\t\tsps = &hevc.sps[hevc.sps_active_idx];\n\t\t\t\t\tif (sps && sps->colour_description_present_flag) {\n\t\t\t\t\t\tDasherHDRType old_hdr_type = ds->hdr_type;\n\t\t\t\t\t\tif (sps->colour_primaries == 9 && sps->matrix_coeffs == 9) {\n\t\t\t\t\t\t\tif (sps->transfer_characteristic == 14) ds->hdr_type = DASHER_HDR_HLG; //TODO: parse alternative_transfer_characteristics SEI\n\t\t\t\t\t\t\tif (sps->transfer_characteristic == 16) ds->hdr_type = DASHER_HDR_PQ10;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (old_hdr_type != ds->hdr_type) period_switch = GF_TRUE;\n\t\t\t\t\t}\n\t\t\t\t\tis_interlaced = hevccfg->interlaced_source_flag ? GF_TRUE : GF_FALSE;\n\t\t\t\t\tif (ds->interlaced != is_interlaced) period_switch = GF_TRUE;\n\t\t\t\t\tds->interlaced = is_interlaced;\n\n\t\t\t\t\tgf_odf_hevc_cfg_del(hevccfg);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (ds->codec_id == GF_CODECID_AVC || ds->codec_id == GF_CODECID_SVC || ds->codec_id == GF_CODECID_MVC) {\n\t\t\t\tAVCState avc;\n\t\t\t\tGF_AVCConfig* avccfg = gf_odf_avc_cfg_read(dsi->value.data.ptr, dsi->value.data.size);\n\t\t\t\tif (avccfg) {\n\t\t\t\t\tGF_NALUFFParam *sl = (GF_NALUFFParam *)gf_list_get(avccfg->sequenceParameterSets, 0);\n\t\t\t\t\tif (sl) {\n\t\t\t\t\t\ts32 idx;\n\t\t\t\t\t\tmemset(&avc, 0, sizeof(AVCState));\n\t\t\t\t\t\tidx = gf_avc_read_sps(sl->data, sl->size, &avc, 0, NULL);\n\t\t\t\t\t\tif (idx>=0) {\n\t\t\t\t\t\t\tBool is_interlaced = avc.sps[idx].frame_mbs_only_flag ? GF_FALSE : GF_TRUE;\n\t\t\t\t\t\t\tif (ds->interlaced != is_interlaced) period_switch = GF_TRUE;\n\t\t\t\t\t\t\tds->interlaced = is_interlaced;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tgf_odf_avc_cfg_del(avccfg);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n#endif /*!GPAC_DISABLE_AV_PARSERS*/\n\n\t\tif (ds->stream_type==GF_STREAM_AUDIO) {\n\t\t\tu32 _sr=0, _nb_ch=0;\n#ifndef GPAC_DISABLE_AV_PARSERS\n\t\t\tswitch (ds->codec_id) {\n\t\t\tcase GF_CODECID_AAC_MPEG4:\n\t\t\tcase GF_CODECID_AAC_MPEG2_MP:\n\t\t\tcase GF_CODECID_AAC_MPEG2_LCP:\n\t\t\tcase GF_CODECID_AAC_MPEG2_SSRP:\n\t\t\tcase GF_CODECID_USAC:\n\t\t\t\t//DASH-IF and MPEG disagree here:\n\t\t\t\tif ((ctx->profile == GF_DASH_PROFILE_AVC264_LIVE)\n\t\t\t\t\t|| (ctx->profile == GF_DASH_PROFILE_AVC264_ONDEMAND)\n\t\t\t\t\t|| (ctx->profile == GF_DASH_PROFILE_DASHIF_LL)\n\t\t\t\t) {\n\t\t\t\t\tGF_Err res = dasher_get_audio_info_with_m4a_sbr_ps(ds, dsi, &_sr, &_nb_ch);\n\t\t\t\t\tif (res) {\n\t\t\t\t\t\t//DASH-IF IOP 3.3 mandates the SBR/PS info\n\t\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_DASH, (\"[Dasher] Could not get AAC info, %s\\n\", gf_error_to_string(res)));\n\t\t\t\t\t}\n\t\t\t\t} else if (dsi) {\n\t\t\t\t\tdasher_get_audio_info_with_m4a_sbr_ps(ds, dsi, NULL, &_nb_ch);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase GF_CODECID_AC3:\n\t\t\tcase GF_CODECID_EAC3:\n\t\t\t\tif (dsi) {\n\t\t\t\t\tGF_AC3Config ac3;\n\t\t\t\t\tgf_odf_ac3_config_parse(dsi->value.data.ptr, dsi->value.data.size, (ds->codec_id==GF_CODECID_EAC3) ? GF_TRUE : GF_FALSE, &ac3);\n\n\t\t\t\t\tds->nb_lfe = ac3.streams[0].lfon ? 1 : 0;\n\t\t\t\t\tds->nb_surround = gf_ac3_get_surround_channels(ac3.streams[0].acmod);\n\t\t\t\t\tds->atmos_complexity_type = ac3.is_ec3 ? ac3.complexity_index_type : 0;\n\t\t\t\t\t_nb_ch = gf_ac3_get_total_channels(ac3.streams[0].acmod);\n\t\t\t\t\tif (ac3.streams[0].nb_dep_sub) {\n\t\t\t\t\t\t_nb_ch += gf_eac3_get_chan_loc_count(ac3.streams[0].chan_loc);\n\t\t\t\t\t}\n                    if (ds->nb_lfe) _nb_ch++;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n#endif\n\t\t\tif (_sr > ds->sr) ds->sr = _sr;\n\t\t\tif (_nb_ch > ds->nb_ch) ds->nb_ch = _nb_ch;\n\t\t}\n\n\n\t\tds->pts_minus_cts = 0;\n\t\tp = gf_filter_pid_get_property(ds->ipid, GF_PROP_PID_DELAY);\n\t\tif (p && p->value.longsint) {\n\t\t\tds->pts_minus_cts = p->value.longsint;\n\t\t}\n\n\t\t//only reload queues if we detected a period switch\n\t\tif (period_switch) {\n\t\t\tcue_file = ctx->cues;\n\t\t\tif (!cue_file || strcmp(cue_file, \"none\") ) {\n\t\t\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_DASH_CUE);\n\t\t\t\tif (p) cue_file = p->value.string;\n\t\t\t}\n\n\t\t\tif (ds->cues) gf_free(ds->cues);\n\t\t\tds->cues = NULL;\n\t\t\tds->nb_cues = 0;\n\t\t\tds->inband_cues = GF_FALSE;\n\t\t\tif (cue_file) {\n\t\t\t\tif (!strcmp(cue_file, \"inband\")) {\n\t\t\t\t\tds->inband_cues = GF_TRUE;\n\t\t\t\t\t//if manifest generation mode, do not setup dash forward mode\n\t\t\t\t\tif (!ctx->sigfrag) {\n\t\t\t\t\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_DASH_FWD);\n\t\t\t\t\t\tif (p && p->value.uint)\n\t\t\t\t\t\t\tctx->forward_mode = p->value.uint;\n\t\t\t\t\t}\n\t\t\t\t} else if (!strcmp(cue_file, \"idx_all\")) {\n\t\t\t\t\tds->inband_cues = GF_TRUE;\n\t\t\t\t\tctx->from_index = IDXMODE_ALL;\n\t\t\t\t} else if (!strcmp(cue_file, \"idx_man\")) {\n\t\t\t\t\tds->inband_cues = GF_TRUE;\n\t\t\t\t\tctx->from_index = IDXMODE_MANIFEST;\n\t\t\t\t} else if (!strcmp(cue_file, \"idx_init\")) {\n\t\t\t\t\tds->inband_cues = GF_TRUE;\n\t\t\t\t\tctx->from_index = IDXMODE_INIT;\n\t\t\t\t} else if (!strcmp(cue_file, \"idx_child\")) {\n\t\t\t\t\tds->inband_cues = GF_TRUE;\n\t\t\t\t\tctx->from_index = IDXMODE_CHILD;\n\t\t\t\t} else if (!strcmp(cue_file, \"idx_seg\")) {\n\t\t\t\t\tds->inband_cues = GF_TRUE;\n\t\t\t\t\tctx->from_index = IDXMODE_SEG;\n\t\t\t\t} else if (strcmp(cue_file, \"none\")) {\n\t\t\t\t\te = gf_mpd_load_cues(cue_file, ds->id, &ds->cues_timescale, &ds->cues_use_edits, &ds->cues_ts_offset, &ds->cues, &ds->nb_cues);\n\t\t\t\t\tif (e) return e;\n\t\t\t\t\tif (!ds->cues_timescale)\n\t\t\t\t\t\tds->cues_timescale = ds->timescale;\n\t\t\t\t}\n\n\n\t\t\t\tif (ctx->from_index==IDXMODE_CHILD) {\n\t\t\t\t\tp = gf_filter_pid_get_property_str(ds->ipid, \"idx_out\");\n\t\t\t\t\tif (p) {\n\t\t\t\t\t\tif (ds->hls_vp_name) gf_free(ds->hls_vp_name);\n\t\t\t\t\t\tds->hls_vp_name = gf_strdup(p->value.string);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t} else {\n\n\t\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_URL);\n\t\tif (!p) p = gf_filter_pid_get_property(pid, GF_PROP_PID_FILEPATH);\n\t\tif (p) return GF_NOT_SUPPORTED;\n\n\t\tCHECK_PROP_STR(GF_PROP_PID_XLINK, ds->xlink, GF_EOS)\n\t}\n\n\n\tif (ctx->do_index || ctx->from_index) {\n\t\tif (!ds->template && ctx->def_template) {\n\t\t\tp = gf_filter_pid_get_property_str(ds->ipid, \"idx_template\");\n\t\t\tif (p) {\n\t\t\t\tds->template = gf_strdup(p->value.string);\n\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_DASH, (\"[Dasher] Using template from index pass %s\\n\", ds->template));\n\t\t\t}\n\t\t}\n\t\tchar *template = ds->template;\n\n\t\tif (!ds->template) {\n\t\t\tif ((ctx->def_template==1) && ctx->do_index) {\n\t\t\t\tgf_free(ctx->template);\n\t\t\t\tctx->template = gf_strdup(\"$RepresentationID$-$Number$$Init=init$\");\n\t\t\t\tctx->def_template = 2;\n\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_DASH, (\"[Dasher] No template assigned in index mode, using %s\\n\", ctx->template));\n\t\t\t}\n\t\t\ttemplate = ctx->template;\n\t\t}\n\n\t\tif (dasher_template_use_source_url(template)) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_DASH, (\"[Dasher] Cannot use file-based templates with index mode\\n\"));\n\t\t\treturn GF_BAD_PARAM;\n\t\t}\n\t}\n\n\t//stream representation was not yet setup but is scheduled for this period, do not trigger period switch\n\t//this typically happens when we post-poned representation setup waiting for the decoder config\n\tif (!ds->rep && (gf_list_find(ctx->current_period->streams, ds)>=0))\n\t\tperiod_switch = GF_FALSE;\n\n\told_period_switch = period_switch;\n\tperiod_switch = GF_FALSE;\n\tCHECK_PROP_STR(GF_PROP_PID_PERIOD_ID, ds->period_id, GF_EOS)\n\tCHECK_PROP_PROP(GF_PROP_PID_PERIOD_DESC, ds->p_period_desc, GF_EOS)\n\tif (!period_switch && (ctx->pswitch==DASHER_PSWITCH_FORCE))\n\t\tperiod_switch = GF_TRUE;\n\n\tif (gf_filter_pid_get_property_str(pid, \"period_switch\"))\n\t\tperiod_switch = GF_TRUE;\n\n\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_PERIOD_START);\n\tif (p) {\n\t\tif (ds->period_start.num * p->value.lfrac.den != p->value.lfrac.num * ds->period_start.den) period_switch = GF_TRUE;\n\t\tds->period_start = p->value.lfrac;\n\t} else {\n\t\tif (ds->period_start.num) period_switch = GF_TRUE;\n\t\tds->period_start.num = 0;\n\t\tds->period_start.den = 1000;\n\t}\n\tassert(ds->period_start.den);\n\n\tif (period_switch) {\n\t\tnew_period_request = GF_TRUE;\n\t} else {\n\t\tperiod_switch = old_period_switch;\n\t}\n\n\tif (ds->period_continuity_id) gf_free(ds->period_continuity_id);\n\tds->period_continuity_id = NULL;\n\tp = gf_filter_pid_get_property_str(ds->ipid, \"period_resume\");\n\tif (!ctx->mpd || (gf_list_find(ctx->mpd->periods, ds->last_period)<0))\n\t\tds->last_period = NULL;\n\n\tif (p && p->value.string && ds->last_period) {\n\t\tif (!ds->last_period->ID) {\n\t\t\tif (p->value.string[0]) {\n\t\t\t\tds->last_period->ID = p->value.string;\n\t\t\t} else {\n\t\t\t\tchar szPName[50];\n\t\t\t\tsprintf(szPName, \"P%d\", 1 + gf_list_find(ctx->mpd->periods, ds->last_period));\n\t\t\t\tds->last_period->ID = gf_strdup(szPName);\n\t\t\t}\n\t\t}\n\t\tif (ds->set && (ds->set->id<0)) {\n\t\t\t//period may be NULL (no longer scheduled)\n\t\t\tif (!ds->as_id && ds->period && ds->period->period)\n\t\t\t\tds->as_id = gf_list_find(ds->period->period->adaptation_sets, ds->set) + 1;\n\t\t\tds->set->id = ds->as_id;\n\t\t}\n\t\tds->period_continuity_id = gf_strdup(ds->last_period->ID);\n\t}\n\tds->last_period = NULL;\n\n\tds->period_dur.num = 0;\n\tds->period_dur.den = 1;\n\tp = gf_filter_pid_get_property(pid, GF_PROP_PID_PERIOD_DUR);\n\tif (p) ds->period_dur = p->value.lfrac;\n\n\tp = gf_filter_pid_get_property_str(pid, \"max_seg_dur\");\n\tctx->index_max_seg_dur = p ? p->value.uint : 0;\n\tp = gf_filter_pid_get_property_str(pid, \"mpd_duration\");\n\tctx->index_media_duration = p ? p->value.longuint : 0;\n\n\tif (ds->stream_type==GF_STREAM_FILE) {\n\t\tif (!ds->xlink && !ds->period_start.num && !ds->period_dur.num) {\n\t\t\tds->done = 1;\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_DASH, (\"[Dasher] null PID specified without any XLINK/start/duration, ignoring\\n\"));\n\t\t} else if (ds->xlink) {\n\t\t\tctx->use_xlink = GF_TRUE;\n\t\t}\n\t} else {\n\t\tif (ds->xlink) gf_free(ds->xlink);\n\t\tds->xlink = NULL;\n\t\tCHECK_PROP_STR(GF_PROP_PID_XLINK, ds->xlink, GF_EOS)\n\t\tif (ds->xlink)\n\t\t\tctx->use_xlink = GF_TRUE;\n\t}\n\n\t//input was done due to clamp but forced to new period, reschedule\n\tif (new_period_request && ds->done && old_clamp_dur) {\n\t\tgf_list_del_item(ctx->next_period->streams, ds);\n\t\t//reset discard, blocking mode on output (set by EOS) and reset dasher EOS state\n\t\tgf_filter_pid_set_discard(ds->ipid, GF_FALSE);\n\t\tif (ds->opid && !ctx->gencues) {\n\t\t\tgf_filter_pid_discard_block(ds->opid);\n\t\t\tgf_filter_pid_remove(ds->opid);\n\t\t\tds->opid = NULL;\n\t\t}\n\t\tif (ctx->is_eos) {\n\t\t\tctx->is_eos = GF_FALSE;\n\t\t\tgf_filter_pid_discard_block(ctx->opid);\n\t\t\tif (ctx->opid_alt)\n\t\t\tgf_filter_pid_discard_block(ctx->opid_alt);\n\t\t}\n\t\tds->rep_init = GF_FALSE;\n\t\tds->presentation_time_offset = 0;\n\t\tds->rep = NULL;\n\t\tds->set = NULL;\n\t\tds->period = NULL;\n\t\tds->done = 0;\n//\t\tgf_filter_post_process_task(filter);\n//\t\tdasher_reset_stream(filter, ds, GF_FALSE);\n\t}\n\n\t//our stream is already scheduled for next period, don't do anything\n\tif (gf_list_find(ctx->next_period->streams, ds)>=0)\n\t\tperiod_switch = GF_FALSE;\n\n\t//assign default ID\n\tif (!ds->period_id)\n\t\tds->period_id = gf_strdup(DEFAULT_PERIOD_ID);\n\n\te = dasher_hls_setup_crypto(ctx, ds);\n\tif (e) return e;\n\n\tif (!period_switch) {\n\t\tif (ds->opid) {\n\t\t\tgf_filter_pid_copy_properties(ds->opid, pid);\n\t\t\t//for route out\n\t\t\tif (ctx->is_route && ctx->do_m3u8)\n\t\t\t\tgf_filter_pid_set_property(ds->opid, GF_PROP_PCK_HLS_REF, &PROP_LONGUINT( ds->hls_ref_id ) );\n\t\t\tif (ctx->llhls)\n\t\t\t\tgf_filter_pid_set_property(ds->opid, GF_PROP_PID_LLHLS, &PROP_UINT(ctx->llhls) );\n\n\t\t\tif (ctx->gencues)\n\t\t\t\tgf_filter_pid_set_property(ds->opid, GF_PROP_PID_DASH_CUE, &PROP_STRING(\"inband\") );\n\t\t}\n\t\tif (ds->rep)\n\t\t\tdasher_update_rep(ctx, ds);\n\t\treturn GF_OK;\n\t}\n\t//period switch !\n\n\t//we have queued packets (sbound modes), we cannot switch period for this stream now, force queue flush\n\tif (gf_list_count(ds->packet_queue)) {\n\t\tds->request_period_switch = new_period_request ? 2 : 1;\n\t\treturn GF_OK;\n\t}\n\t//done for this stream\n\treturn dasher_stream_period_changed(filter, ctx, ds, new_period_request);\n}\n\nstatic void\tdasher_check_chaining(GF_DasherCtx *ctx, char *scheme_id, char *url)\n{\n\tGF_MPD_Descriptor *d = gf_mpd_get_descriptor(ctx->mpd->supplemental_properties, scheme_id);\n\tif (!d && !url) return;\n\tif (!url) {\n\t\tgf_list_del_item(ctx->mpd->supplemental_properties, d);\n\t\tgf_mpd_descriptor_free(d);\n\t\treturn;\n\t}\n\tif (d) {\n\t\tgf_free(d->value);\n\t\td->value = gf_strdup(url);\n\t\treturn;\n\t}\n\td = gf_mpd_descriptor_new(NULL, scheme_id, url);\n\tif (!ctx->mpd->supplemental_properties)\n\t\tctx->mpd->supplemental_properties = gf_list_new();\n\n\tgf_list_add(ctx->mpd->supplemental_properties, d);\n}\n\n\nstatic GF_Err dasher_update_mpd(GF_DasherCtx *ctx)\n{\n\tchar profiles_string[GF_MAX_PATH];\n\tGF_XMLAttribute *cenc_att = NULL;\n\tGF_XMLAttribute *xlink_att = NULL;\n\tGF_XMLAttribute *ck_att = NULL;\n\n\tu32 i, count=gf_list_count(ctx->mpd->x_attributes);\n\tfor (i=0; i<count; i++) {\n\t\tGF_XMLAttribute * att = gf_list_get(ctx->mpd->x_attributes, i);\n\t\tif (!strcmp(att->name, \"xmlns:cenc\")) cenc_att = att;\n\t\tif (!strcmp(att->name, \"xmlns:xlink\")) xlink_att = att;\n\t\tif (!strcmp(att->name, \"xmlns:ck\")) ck_att = att;\n\t}\n\tif (ctx->dmode==GF_MPD_TYPE_DYNAMIC) {\n\t\tctx->mpd->type = GF_MPD_TYPE_DYNAMIC;\n\t} else {\n\t\tctx->mpd->type = GF_MPD_TYPE_STATIC;\n\t\tctx->mpd->availabilityStartTime = 0;\n\t}\n\n\tBool is_m2ts = (ctx->muxtype==DASHER_MUX_TS) ? GF_TRUE : GF_FALSE;\n\tif (ctx->profile==GF_DASH_PROFILE_LIVE) {\n\t\tif (ctx->use_xlink && !is_m2ts) {\n\t\t\tstrcpy(profiles_string, \"urn:mpeg:dash:profile:isoff-segext-live:2014\");\n\t\t} else {\n\t\t\tsprintf(profiles_string, \"urn:mpeg:dash:profile:%s:2011\", is_m2ts ? \"mp2t-simple\" : \"isoff-live\");\n\t\t}\n\t} else if (ctx->profile==GF_DASH_PROFILE_ONDEMAND) {\n\t\tif (ctx->use_xlink) {\n\t\t\tstrcpy(profiles_string, \"urn:mpeg:dash:profile:isoff-segext-on-demand:2014\");\n\t\t} else {\n\t\t\tstrcpy(profiles_string, \"urn:mpeg:dash:profile:isoff-on-demand:2011\");\n\t\t}\n\t} else if (ctx->profile==GF_DASH_PROFILE_MAIN) {\n\t\tsprintf(profiles_string, \"urn:mpeg:dash:profile:%s:2011\", is_m2ts ? \"mp2t-main\" : \"isoff-main\");\n\t} else if (ctx->profile==GF_DASH_PROFILE_HBBTV_1_5_ISOBMF_LIVE) {\n\t\tstrcpy(profiles_string, \"urn:hbbtv:dash:profile:isoff-live:2012\");\n\t} else if (ctx->profile==GF_DASH_PROFILE_AVC264_LIVE) {\n\t\tstrcpy(profiles_string, \"urn:mpeg:dash:profile:isoff-live:2011,http://dashif.org/guidelines/dash264\");\n\t} else if (ctx->profile==GF_DASH_PROFILE_AVC264_ONDEMAND) {\n\t\tstrcpy(profiles_string, \"urn:mpeg:dash:profile:isoff-on-demand:2011,http://dashif.org/guidelines/dash264\");\n\t} else if (ctx->profile==GF_DASH_PROFILE_DASHIF_LL) {\n\t\tstrcpy(profiles_string, \"urn:mpeg:dash:profile:isoff-live:2011,http://www.dashif.org/guidelines/low-latency-live-v5\");\n\t} else {\n\t\tstrcpy(profiles_string, \"urn:mpeg:dash:profile:full:2011\");\n\t}\n\n\tif (ctx->cmaf) {\n\t\tconst size_t offset = strlen(profiles_string);\n\t\tstrncat(profiles_string+offset, \",urn:mpeg:dash:profile:cmaf:2019\", GF_MAX_PATH-offset-1);\n\t}\n\n\tif (ctx->profX) {\n\t\tif (ctx->profX[0] == '+') {\n\t\t\tif (ctx->mpd->profiles) gf_free(ctx->mpd->profiles);\n\t\t\tctx->mpd->profiles = gf_strdup(ctx->profX+1);\n\t\t\tctx->mpd->profiles = gf_strdup(ctx->profX+1);\n\t\t} else {\n\t\t\tchar profiles_w_ext[GF_MAX_PATH+256];\n\t\t\tsprintf(profiles_w_ext, \"%s,%s\", profiles_string, ctx->profX);\n\t\t\tif (ctx->mpd->profiles) gf_free(ctx->mpd->profiles);\n\t\t\tctx->mpd->profiles = gf_strdup(profiles_w_ext);\n\t\t}\n\t} else {\n\t\tif (ctx->mpd->profiles) gf_free(ctx->mpd->profiles);\n\t\tctx->mpd->profiles = gf_strdup(profiles_string);\n\t}\n\n\tif (ctx->use_cenc && !cenc_att) {\n\t\tcenc_att = gf_xml_dom_create_attribute(\"xmlns:cenc\", \"urn:mpeg:cenc:2013\");\n\t\tgf_list_add(ctx->mpd->x_attributes, cenc_att);\n\t}\n\tif (ctx->use_xlink && !xlink_att) {\n\t\txlink_att = gf_xml_dom_create_attribute(\"xmlns:xlink\", \"http://www.w3.org/1999/xlink\");\n\t\tgf_list_add(ctx->mpd->x_attributes, xlink_att);\n\t}\n\tif (ctx->use_clearkey && !ck_att) {\n\t\tck_att = gf_xml_dom_create_attribute(\"xmlns:ck\", \"http://dashif.org/guidelines/clearKey\");\n\t\tgf_list_add(ctx->mpd->x_attributes, ck_att);\n\t}\n\n\tctx->mpd->time_shift_buffer_depth = 0;\n\tctx->mpd->minimum_update_period = 0;\n\n\tif (ctx->dmode==GF_MPD_TYPE_DYNAMIC) {\n\t\tctx->mpd->time_shift_buffer_depth = (u32) -1;\n\t\tif (ctx->tsb>=0) ctx->mpd->time_shift_buffer_depth = (u32) (1000*ctx->tsb);\n\t\tif (ctx->spd>0) ctx->mpd->suggested_presentation_delay = ctx->spd;\n\n\t\tif (ctx->refresh>=0) {\n\t\t\tif (ctx->refresh) {\n\t\t\t\tctx->mpd->minimum_update_period = (u32) (1000*ctx->refresh);\n\t\t\t} else {\n\t\t\t\tctx->mpd->minimum_update_period = ctx->segdur.num * 1000;\n\t\t\t\tctx->mpd->minimum_update_period /= ctx->segdur.den;\n\t\t\t}\n\t\t} else {\n\t\t\tctx->mpd->minimum_update_period = 0;\n\t\t}\n\t}\n\tdasher_check_chaining(ctx, \"urn:mpeg:dash:mpd-chaining:2016\", ctx->chain);\n\tdasher_check_chaining(ctx, \"urn:mpeg:dash:fallback:2016\", ctx->chain_fbk);\n\treturn GF_OK;\n}\nstatic GF_Err dasher_setup_mpd(GF_DasherCtx *ctx)\n{\n\tu32 i, count;\n\tGF_MPD_ProgramInfo *info;\n\tctx->mpd = gf_mpd_new();\n\tctx->mpd->index_mode = ctx->do_index;\n\tctx->mpd->segment_duration = (u32) gf_timestamp_rescale(ctx->segdur.num, ctx->segdur.den, 1000);\n\tctx->mpd->xml_namespace = \"urn:mpeg:dash:schema:mpd:2011\";\n\tctx->mpd->base_URLs = gf_list_new();\n\tctx->mpd->locations = gf_list_new();\n\tctx->mpd->program_infos = gf_list_new();\n\tctx->mpd->periods = gf_list_new();\n\tctx->mpd->use_gpac_ext = ctx->gxns;\n\t//created by default because we store xmlns in it\n\tctx->mpd->x_attributes = gf_list_new();\n\tif (ctx->buf<0) {\n\t\tGF_Fraction segdur = ctx->segdur;\n\t\ts32 buf = -ctx->buf;\n\t\tif (ctx->no_seg_dur && ctx->from_index) {\n\t\t\tGF_DashStream *ds = gf_list_get(ctx->current_period->streams, 0);\n\t\t\tif (ds && ds->dash_dur.num && ds->dash_dur.den)\n\t\t\t\tsegdur = ds->dash_dur;\n\t\t}\n\t\tctx->mpd->min_buffer_time = (u32) ( segdur.num * 10 * buf / segdur.den); //*1000 (ms) / 100 (percent)\n\t} else\n\t\tctx->mpd->min_buffer_time = ctx->buf;\n\n\tGF_SAFEALLOC(info, GF_MPD_ProgramInfo);\n\tif (info) {\n\t\tgf_list_add(ctx->mpd->program_infos, info);\n\t\tif (ctx->title)\n\t\t\tinfo->title = gf_strdup(ctx->title);\n\t\telse {\n\t\t\tchar tmp[256];\n\t\t\tconst char *name = NULL;\n\t\t\tif (ctx->out_path) {\n\t\t\t\tconst char *url = ctx->out_path;\n\t\t\t\tif (!strncmp(ctx->out_path, \"gfio://\", 7)) {\n\t\t\t\t\turl = gf_fileio_translate_url(ctx->out_path);\n\t\t\t\t\tif (!url) url = \"\";\n\t\t\t\t}\n\t\t\t\tname = strrchr(url, '/');\n\t\t\t\tif (!name) name = strrchr(url, '\\\\');\n\t\t\t\tif (!name) name = url;\n\t\t\t\telse name++;\n\t\t\t}\n\t\t\tsnprintf(tmp, 255, \"%s generated by GPAC\", name ? name : \"\");\n\t\t\ttmp[255]=0;\n\t\t\tinfo->title = gf_strdup(tmp);\n\t\t}\n\t\tif (ctx->cprt) info->copyright = gf_strdup(ctx->cprt);\n\t\tif (ctx->info) info->more_info_url = gf_strdup(ctx->info);\n\t\telse info->more_info_url = gf_strdup(\"http://gpac.io\");\n\t\tif (ctx->source) info->source = gf_strdup(ctx->source);\n\t\tif (ctx->lang) info->lang = gf_strdup(ctx->lang);\n\t}\n\n\tcount = ctx->location.nb_items;\n\tfor (i=0; i<count; i++) {\n\t\tchar *l = ctx->location.vals[i];\n\t\tgf_list_add(ctx->mpd->locations, gf_strdup(l));\n\t}\n\tcount = ctx->base.nb_items;\n\tfor (i=0; i<count; i++) {\n\t\tGF_MPD_BaseURL *base;\n\t\tchar *b = ctx->base.vals[i];\n\t\tGF_SAFEALLOC(base, GF_MPD_BaseURL);\n\t\tif (base) {\n\t\t\tbase->URL = gf_strdup(b);\n\t\t\tgf_list_add(ctx->mpd->base_URLs, base);\n\t\t}\n\t}\n\treturn dasher_update_mpd(ctx);\n}\n\n\nstatic GF_Err dasher_get_rfc_6381_codec_name(GF_DasherCtx *ctx, GF_DashStream *ds, char *szCodec, Bool force_inband, Bool force_sbr)\n{\n\tconst GF_PropertyValue *tile_base_dcd = NULL;\n\tif (ds->codec_id==GF_CODECID_HEVC_TILES) {\n\t\tconst GF_PropertyValue *dcd = gf_filter_pid_get_property(ds->ipid, GF_PROP_PID_DECODER_CONFIG);\n\t\tif (!dcd && ds->dep_id) {\n\t\t\tu32 i, count = gf_list_count(ctx->current_period->streams);\n\t\t\tfor (i=0; i<count; i++) {\n\t\t\t\tGF_DashStream *a_ds = gf_list_get(ctx->current_period->streams, i);\n\t\t\t\tif (a_ds->id != ds->dep_id) continue;\n\t\t\t\ttile_base_dcd = gf_filter_pid_get_property(a_ds->ipid, GF_PROP_PID_DECODER_CONFIG);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!force_inband) {\n\t\tforce_inband = ds->inband_params;\n\t}\n\treturn gf_filter_pid_get_rfc_6381_codec_string(ds->ipid, szCodec, force_inband, force_sbr, tile_base_dcd, &ds->inband_params);\n}\n\nstatic GF_DashStream *get_base_ds(GF_DasherCtx *ctx, GF_DashStream *for_ds)\n{\n\tu32 i, count;\n\tif (!for_ds->dep_id) return NULL;\n\tcount = gf_list_count(ctx->pids);\n\tfor (i=0; i<count; i++) {\n\t\tGF_DashStream *ds = gf_list_get(ctx->pids, i);\n\t\tif (ds->id == for_ds->dep_id)\n\t\t\treturn ds;\n\t}\n\treturn NULL;\n}\n\nstatic void get_canon_urn(bin128 URN, char *res)\n{\n\tchar sres[4];\n\tu32 i;\n\t/* Output canonical UIID form */\n\tstrcpy(res, \"\");\n\tfor (i=0; i<4; i++) { sprintf(sres, \"%02x\", URN[i]); strcat(res, sres); }\n\tstrcat(res, \"-\");\n\tfor (i=4; i<6; i++) { sprintf(sres, \"%02x\", URN[i]); strcat(res, sres); }\n\tstrcat(res, \"-\");\n\tfor (i=6; i<8; i++) { sprintf(sres, \"%02x\", URN[i]); strcat(res, sres); }\n\tstrcat(res, \"-\");\n\tfor (i=8; i<10; i++) { sprintf(sres, \"%02x\", URN[i]); strcat(res, sres); }\n\tstrcat(res, \"-\");\n\tfor (i=10; i<16; i++) { sprintf(sres, \"%02x\", URN[i]); strcat(res, sres); }\n}\n\nstatic const char *get_drm_kms_name(const char *canURN)\n{\n\tif (!stricmp(canURN, \"67706163-6365-6E63-6472-6D746F6F6C31\")) return \"GPAC1.0\";\n\telse if (!stricmp(canURN, \"5E629AF5-38DA-4063-8977-97FFBD9902D4\")) return \"Marlin1.0\";\n\telse if (!strcmp(canURN, \"adb41c24-2dbf-4a6d-958b-4457c0d27b95\")) return \"MediaAccess3.0\";\n\telse if (!strcmp(canURN, \"A68129D3-575B-4F1A-9CBA-3223846CF7C3\")) return \"VideoGuard\";\n\telse if (!strcmp(canURN, \"9a04f079-9840-4286-ab92-e65be0885f95\")) return \"PlayReady\";\n\telse if (!strcmp(canURN, \"9a27dd82-fde2-4725-8cbc-4234aa06ec09\")) return \"VCAS\";\n\telse if (!strcmp(canURN, \"F239E769-EFA3-4850-9C16-A903C6932EFB\")) return \"Adobe\";\n\telse if (!strcmp(canURN, \"1f83e1e8-6ee9-4f0d-ba2f-5ec4e3ed1a66\")) return \"SecureMedia\";\n\telse if (!strcmp(canURN, \"644FE7B5-260F-4FAD-949A-0762FFB054B4\")) return \"CMLA (OMA DRM)\";\n\telse if (!strcmp(canURN, \"6a99532d-869f-5922-9a91-113ab7b1e2f3\")) return \"MobiTVDRM\";\n\telse if (!strcmp(canURN, \"35BF197B-530E-42D7-8B65-1B4BF415070F\")) return \"DivX DRM\";\n\telse if (!strcmp(canURN, \"B4413586-C58C-FFB0-94A5-D4896C1AF6C3\")) return \"VODRM\";\n\telse if (!strcmp(canURN, \"edef8ba9-79d6-4ace-a3c8-27dcd51d21ed\")) return \"Widevine\";\n\telse if (!strcmp(canURN, \"80a6be7e-1448-4c37-9e70-d5aebe04c8d2\")) return \"Irdeto\";\n\telse if (!strcmp(canURN, \"dcf4e3e3-62f1-5818-7ba6-0a6fe33ff3dd\")) return \"CA 1.0, DRM+ 2.0\";\n\telse if (!strcmp(canURN, \"45d481cb-8fe0-49c0-ada9-ab2d2455b2f2\")) return \"CoreCrypt\";\n\telse if (!strcmp(canURN, \"616C7469-6361-7374-2D50-726F74656374\")) return \"altiProtect\";\n\telse if (!strcmp(canURN, \"992c46e6-c437-4899-b6a0-50fa91ad0e39\")) return \"Arris SecureMedia SteelKnot version 1\";\n\telse if (!strcmp(canURN, \"1077efec-c0b2-4d02-ace3-3c1e52e2fb4b\")) return \"cenc initData\";\n\telse if (!strcmp(canURN, \"e2719d58-a985-b3c9-781a-b030af78d30e\")) return \"ClearKey1.0\";\n\telse if (!strcmp(canURN, \"94CE86FB-07FF-4F43-ADB8-93D2FA968CA2\")) return \"FairPlay\";\n\telse if (!strcmp(canURN, \"279fe473-512c-48fe-ade8-d176fee6b40f\")) return \"Arris Titanium\";\n\telse if (!strcmp(canURN, \"aa11967f-cc01-4a4a-8e99-c5d3dddfea2d\")) return \"UDRM\";\n\treturn \"unknown\";\n}\n\nstatic GF_List *dasher_get_content_protection_desc(GF_DasherCtx *ctx, GF_DashStream *ds, GF_MPD_AdaptationSet *for_set)\n{\n\tu32 prot_scheme=0;\n\tu32 i, count;\n\tconst GF_PropertyValue *p;\n\tGF_List *res = NULL;\n\tGF_BitStream *bs_r;\n\n\tcount = gf_list_count(ctx->current_period->streams);\n\tbs_r = gf_bs_new((const char *) &count, 1, GF_BITSTREAM_READ);\n\n\tfor (i=0; i<count; i++) {\n\t\tGF_MPD_Descriptor *desc;\n\t\tGF_DashStream *a_ds = gf_list_get(ctx->current_period->streams, i);\n\t\tif (!a_ds->is_encrypted) continue;\n\n\t\tif (for_set) {\n\t\t\tif (a_ds->set != for_set) continue;\n\t\t\t//for now only insert for the stream holding the set\n\t\t\tif (!a_ds->owns_set) continue;\n\t\t} else if ((a_ds != ds) && (a_ds->muxed_base != ds) ) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tp = gf_filter_pid_get_property(a_ds->ipid, GF_PROP_PID_PROTECTION_SCHEME_TYPE);\n\t\tif (p) prot_scheme = p->value.uint;\n\n\n#ifndef GPAC_DISABLE_ISOM\n\t\tif ((prot_scheme==GF_ISOM_CENC_SCHEME) || (prot_scheme==GF_ISOM_CBC_SCHEME) || (prot_scheme==GF_ISOM_CENS_SCHEME) || (prot_scheme==GF_ISOM_CBCS_SCHEME)\n\t\t) {\n\t\t\tchar sCan[40];\n\t\t\tconst GF_PropertyValue *ki;\n\t\t\tu32 j, nb_pssh;\n\t\t\tBool add_kid=GF_FALSE;\n\t\t\tGF_XMLAttribute *att;\n\t\t\tchar szVal[GF_MAX_PATH];\n\n\t\t\tctx->use_cenc = GF_TRUE;\n\n\t\t\tki = gf_filter_pid_get_property(a_ds->ipid, GF_PROP_PID_CENC_KEY_INFO);\n\t\t\tif (!ki || !ki->value.data.ptr) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!res) res = gf_list_new();\n\t\t\tdesc = gf_mpd_descriptor_new(NULL, \"urn:mpeg:dash:mp4protection:2011\", gf_4cc_to_str(prot_scheme));\n\t\t\tgf_list_add(res, desc);\n\n\t\t\tif (ctx->dkid==DASHER_DEFKID_ON) {\n\t\t\t\tadd_kid = GF_TRUE;\n\t\t\t} else if (ctx->dkid==DASHER_DEFKID_AUTO) {\n\t\t\t\tp = gf_filter_pid_get_property(a_ds->ipid, GF_PROP_PID_CENC_HAS_ROLL);\n\t\t\t\tif (!p || !p->value.boolean) add_kid = GF_TRUE;\n\t\t\t}\n\n\t\t\tif (add_kid) {\n\t\t\t\tget_canon_urn(ki->value.data.ptr + 4, sCan);\n\t\t\t\tatt = gf_xml_dom_create_attribute(\"cenc:default_KID\", sCan);\n\t\t\t\tif (!desc->x_attributes) desc->x_attributes = gf_list_new();\n\t\t\t\tgf_list_add(desc->x_attributes, att);\n\t\t\t}\n\n\t\t\tchar *ck_url = ctx->ckurl;\n\t\t\tp = gf_filter_pid_get_property(a_ds->ipid, GF_PROP_PID_CLEARKEY_URI);\n\t\t\tif (p && p->value.string) ck_url = p->value.string;\n\t\t\tif (ck_url) {\n\t\t\t\tdesc = gf_mpd_descriptor_new(NULL, \"urn:uuid:e2719d58-a985-b3c9-781a-b030af78d30e\", \"ClearKey1.0\");\n\t\t\t\tgf_list_add(res, desc);\n\t\t\t\tGF_XMLNode *ck = gf_xml_dom_node_new(\"ck\", \"Laurl\");\n\n\t\t\t\tif (!desc->x_children) desc->x_children = gf_list_new();\n\t\t\t\tgf_list_add(desc->x_children, ck);\n\n\t\t\t\tGF_XMLNode *val = gf_xml_dom_node_new(NULL, NULL);\n\t\t\t\tval->type = GF_XML_TEXT_TYPE;\n\t\t\t\tval->name = gf_strdup(ck_url);\n\t\t\t\tif (!ck->content) ck->content = gf_list_new();\n\t\t\t\tgf_list_add(ck->content, val);\n\t\t\t\tctx->use_clearkey = GF_TRUE;\n\t\t\t}\n\n\n\t\t\tif ((ctx->pssh <= GF_DASH_PSSH_MOOF) || (ctx->pssh == GF_DASH_PSSH_NONE)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t//(data) binary blob containing (u32)N [(bin128)SystemID(u32)version(u32)KID_count[(bin128)keyID](u32)priv_size(char*priv_size)priv_data]\n\t\t\tp = gf_filter_pid_get_property(a_ds->ipid, GF_PROP_PID_CENC_PSSH);\n\t\t\tif (!p) continue;\n\n\t\t\tgf_bs_reassign_buffer(bs_r, p->value.data.ptr, p->value.data.size);\n\t\t\tnb_pssh = gf_bs_read_u32(bs_r);\n\n\t\t\t//add pssh\n\t\t\tfor (j=0; j<nb_pssh; j++) {\n\t\t\t\tu32 pssh_idx;\n\t\t\t\tbin128 sysID;\n\t\t\t\tGF_XMLNode *node;\n\t\t\t\tu32 version, k_count;\n\t\t\t\tu8 *pssh_data=NULL;\n\t\t\t\tu32 pssh_len, size_64;\n\t\t\t\tGF_BitStream *bs_w = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\n\t\t\t\t//rewrite PSSH box\n\t\t\t\tgf_bs_write_u32(bs_w, 0);\n\t\t\t\tgf_bs_write_u32(bs_w, GF_ISOM_BOX_TYPE_PSSH);\n\n\t\t\t\tgf_bs_read_data(bs_r, sysID, 16);\n\t\t\t\tversion = gf_bs_read_u32(bs_r);\n\n\t\t\t\tk_count = version ? gf_bs_read_u32(bs_r) : 0;\n\t\t\t\tgf_bs_write_u8(bs_w, version);\n\t\t\t\tgf_bs_write_u24(bs_w, 0);\n\t\t\t\tgf_bs_write_data(bs_w, sysID, 16);\n\t\t\t\tif (version) {\n\t\t\t\t\tgf_bs_write_u32(bs_w, k_count);\n\t\t\t\t\tfor (j=0; j<k_count; j++) {\n\t\t\t\t\t\tbin128 keyID;\n\t\t\t\t\t\tgf_bs_read_data(bs_r, keyID, 16);\n\t\t\t\t\t\tgf_bs_write_data(bs_w, keyID, 16);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tk_count = gf_bs_read_u32(bs_r);\n\t\t\t\tgf_bs_write_u32(bs_w, k_count);\n\t\t\t\tfor (pssh_idx=0; pssh_idx<k_count; pssh_idx++) {\n\t\t\t\t\tgf_bs_write_u8(bs_w, gf_bs_read_u8(bs_r) );\n\t\t\t\t}\n\t\t\t\tpssh_len = (u32) gf_bs_get_position(bs_w);\n\t\t\t\tgf_bs_seek(bs_w, 0);\n\t\t\t\tgf_bs_write_u32(bs_w, pssh_len);\n\t\t\t\tgf_bs_seek(bs_w, pssh_len);\n\t\t\t\tgf_bs_get_content(bs_w, &pssh_data, &pssh_len);\n\t\t\t\tgf_bs_del(bs_w);\n\n\t\t\t\tget_canon_urn(sysID, sCan);\n\t\t\t\tdesc = gf_mpd_descriptor_new(NULL, NULL, NULL);\n\t\t\t\tdesc->x_children = gf_list_new();\n\t\t\t\tsprintf(szVal, \"urn:uuid:%s\", sCan);\n\t\t\t\tdesc->scheme_id_uri = gf_strdup(szVal);\n\t\t\t\tdesc->value = gf_strdup(get_drm_kms_name(sCan));\n\t\t\t\tgf_list_add(res, desc);\n\n\t\t\t\tGF_SAFEALLOC(node, GF_XMLNode);\n\t\t\t\tif (node) {\n\t\t\t\t\tGF_XMLNode *pnode;\n\t\t\t\t\tnode->type = GF_XML_NODE_TYPE;\n\t\t\t\t\tnode->name = gf_strdup(\"cenc:pssh\");\n\t\t\t\t\tnode->content = gf_list_new();\n\t\t\t\t\tgf_list_add(desc->x_children, node);\n\n\t\t\t\t\tGF_SAFEALLOC(pnode, GF_XMLNode);\n\t\t\t\t\tif (pnode) {\n\t\t\t\t\t\tpnode->type = GF_XML_TEXT_TYPE;\n\t\t\t\t\t\tgf_list_add(node->content, pnode);\n\n\t\t\t\t\t\tsize_64 = 2*pssh_len + 3;\n\t\t\t\t\t\tpnode->name = gf_malloc(sizeof(char) * size_64);\n\t\t\t\t\t\tif (pnode->name) {\n\t\t\t\t\t\t\tsize_64 = gf_base64_encode((const char *)pssh_data, pssh_len, (char *)pnode->name, size_64);\n\t\t\t\t\t\t\tpnode->name[size_64] = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tgf_free(pssh_data);\n\t\t\t}\n\t\t} else\n#endif // GPAC_DISABLE_ISOM\n\t\t{\n\t\t\tif (ctx->do_mpd) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_DASH, (\"[Dasher] Protection scheme %s has no official DASH mapping, using URI \\\"urn:gpac:dash:mp4protection:2018\\\"\\n\", gf_4cc_to_str(prot_scheme)));\n\t\t\t}\n\t\t\tif (!res) res = gf_list_new();\n\t\t\tdesc = gf_mpd_descriptor_new(NULL, \"urn:gpac:dash:mp4protection:2018\", gf_4cc_to_str(prot_scheme));\n\t\t\tgf_list_add(res, desc);\n\t\t}\n\t}\n\tgf_bs_del(bs_r);\n\treturn res;\n}\n\nstatic void dasher_get_mime_and_ext(GF_DasherCtx *ctx, GF_DashStream *ds, const char **out_subtype, const char **out_ext)\n{\n\tconst char *subtype = NULL;\n\tconst char *mux_ext = NULL;\n\tconst char *cstr;\n\n\tif (ctx->muxtype!=DASHER_MUX_AUTO) {\n\t\tswitch (ctx->muxtype) {\n\t\tcase DASHER_MUX_ISOM: subtype = \"mp4\"; mux_ext = \"mp4\"; break;\n\t\tcase DASHER_MUX_TS: subtype = \"mp2t\"; mux_ext = \"ts\"; break;\n\t\tcase DASHER_MUX_MKV: subtype = \"x-matroska\"; mux_ext = \"mkv\"; break;\n\t\tcase DASHER_MUX_WEBM: subtype = \"webm\"; mux_ext = \"webm\"; break;\n\t\tcase DASHER_MUX_OGG: subtype = \"ogg\"; mux_ext = \"ogg\"; break;\n\t\tcase DASHER_MUX_RAW:\n\t\t\tcstr = gf_codecid_mime(ds->codec_id);\n\t\t\tif (cstr) {\n\t\t\t\tsubtype = strchr(cstr, '/');\n\t\t\t\tif (subtype) subtype++;\n\t\t\t\telse subtype = \"raw\";\n\t\t\t}\n\t\t\tif (out_ext) {\n\t\t\t\tcstr = gf_codecid_file_ext(ds->codec_id);\n\t\t\t\tif (cstr) *out_ext = cstr;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t} else if (ctx->initext) {\n\t\tmux_ext = ctx->initext;\n\t\tif (!strcmp(ctx->initext, \"ts\") || !strcmp(ctx->initext, \"m2ts\")) {\n\t\t\tsubtype = \"mp2t\";\n\t\t\tctx->muxtype = DASHER_MUX_TS;\n\t\t} else if (!strcmp(ctx->initext, \"mkv\") || !strcmp(ctx->initext, \"mka\") || !strcmp(ctx->initext, \"mks\") || !strcmp(ctx->initext, \"mk3d\")) {\n\t\t\tsubtype = \"x-matroska\";\n\t\t\tctx->muxtype = DASHER_MUX_MKV;\n\t\t} else if (!strcmp(ctx->initext, \"webm\") || !strcmp(ctx->initext, \"weba\")) {\n\t\t\tsubtype = \"webm\";\n\t\t\tctx->muxtype = DASHER_MUX_WEBM;\n\t\t} else if (!strcmp(ctx->initext, \"ogg\") || !strcmp(ctx->initext, \"oga\") || !strcmp(ctx->initext, \"ogv\") || !strcmp(ctx->initext, \"spx\") || !strcmp(ctx->initext, \"oggm\") || !strcmp(ctx->initext, \"opus\")) {\n\t\t\tsubtype = \"ogg\";\n\t\t\tctx->muxtype = DASHER_MUX_OGG;\n\t\t}\n\t\telse if (!strcmp(ctx->initext, \"null\")) {\n\t\t\tmux_ext = \"mp4\";\n\t\t\tctx->muxtype = DASHER_MUX_ISOM;\n\t\t}\n\t}\n\tif (!subtype) subtype = \"mp4\";\n\tif (out_subtype) *out_subtype = subtype;\n\tif (!mux_ext) mux_ext = \"mp4\";\n\tif (out_ext) *out_ext = mux_ext;\n}\n\n\nstatic void dasher_update_rep(GF_DasherCtx *ctx, GF_DashStream *ds)\n{\n\tchar szCodec[RFC6381_CODEC_NAME_SIZE_MAX];\n\n\t//Outputs are not yet connected, derive mime from init segment extension\n\tif (!ds->rep->mime_type) {\n\t\tconst char *subtype = NULL;\n\t\tdasher_get_mime_and_ext(ctx, ds, &subtype, NULL);\n\n\t\tif (ds->stream_type==GF_STREAM_VISUAL)\n\t\t\tgf_dynstrcat(&ds->rep->mime_type, \"video/\", NULL);\n\t\telse if (ds->stream_type==GF_STREAM_AUDIO)\n\t\t\tgf_dynstrcat(&ds->rep->mime_type, \"audio/\", NULL);\n\t\telse\n\t\t\tgf_dynstrcat(&ds->rep->mime_type, \"application/\", NULL);\n\n\t\tgf_dynstrcat(&ds->rep->mime_type, subtype, NULL);\n\t}\n\n\tds->rep->bandwidth = ds->bitrate;\n\tif (ds->stream_type==GF_STREAM_VISUAL) {\n\t\tds->rep->width = ds->width;\n\t\tds->rep->height = ds->height;\n\n\n\t\tif (!ds->rep->sar) {\n\t\t\tGF_SAFEALLOC(ds->rep->sar, GF_MPD_Fractional);\n\t\t}\n\t\tif (ds->rep->sar) {\n\t\t\tds->rep->sar->num = ds->sar.num;\n\t\t\tds->rep->sar->den = ds->sar.den;\n\t\t}\n\t\tif (ds->fps.num && ds->fps.den) {\n\t\t\tif (!ds->rep->framerate) {\n\t\t\t\tGF_SAFEALLOC(ds->rep->framerate, GF_MPD_Fractional);\n\t\t\t}\n\t\t\tif (ds->rep->framerate) {\n\t\t\t\tds->rep->framerate->num = ds->fps.num;\n\t\t\t\tds->rep->framerate->den = ds->fps.den;\n\t\t\t\tgf_media_get_reduced_frame_rate(&ds->rep->framerate->num, &ds->rep->framerate->den);\n\t\t\t}\n\t\t}\n\t}\n\telse if (ds->stream_type==GF_STREAM_AUDIO) {\n\t\tBool use_cicp = GF_FALSE;\n\t\tBool use_dolbyx = GF_FALSE;\n\t\tGF_MPD_Descriptor *desc;\n\t\tchar value[256];\n\t\tds->rep->samplerate = ds->sr;\n\n\t\tif (ds->nb_surround || ds->nb_lfe) use_cicp = GF_TRUE;\n\t\tif ((ds->codec_id==GF_CODECID_MHAS) || (ds->codec_id==GF_CODECID_MPHA)) use_cicp = GF_TRUE;\n\t\tif ((ds->codec_id==GF_CODECID_DTS_EXPRESS_LBR) || (ds->codec_id==GF_CODECID_DTS_CA) || (ds->codec_id==GF_CODECID_DTS_HD_HR_MASTER)\n\t\t    || (ds->codec_id==GF_CODECID_DTS_HD_LOSSLESS) || (ds->codec_id==GF_CODECID_DTS_X) || (ds->codec_id==GF_CODECID_DTS_Y))\n\t\t\tuse_cicp = GF_TRUE;\n\n\t\tif ((ds->codec_id==GF_CODECID_AC3) || (ds->codec_id==GF_CODECID_EAC3)) {\n\t\t\t//if regular MPEG-DASH, use CICP, otherwise use Dolby signaling\n\t\t\tif (ctx->profile > GF_DASH_PROFILE_FULL) {\n\t\t\t\tuse_dolbyx = GF_TRUE;\n\t\t\t}\n\t\t}\n\t\tif (use_dolbyx) {\n\t\t\tu32 cicp_layout = 0;\n\t\t\tif (ds->ch_layout)\n\t\t\t\tcicp_layout = gf_audio_fmt_get_cicp_from_layout(ds->ch_layout);\n\t\t\tif (!cicp_layout)\n\t\t\t\tcicp_layout = gf_audio_fmt_get_cicp_layout(ds->nb_ch, ds->nb_surround, ds->nb_lfe);\n\n\t\t\tsprintf(value, \"%X\", gf_audio_fmt_get_dolby_chanmap(cicp_layout) );\n\t\t\tdesc = gf_mpd_descriptor_new(NULL, \"tag:dolby.com,2014:dash:audio_channel_configuration:2011\", value);\n\t\t}\n\t\telse if (!use_cicp) {\n\t\t\tsprintf(value, \"%d\", ds->nb_ch);\n\t\t\tdesc = gf_mpd_descriptor_new(NULL, \"urn:mpeg:dash:23003:3:audio_channel_configuration:2011\", value);\n\t\t} else {\n\t\t\tsprintf(value, \"%d\", gf_audio_fmt_get_cicp_layout(ds->nb_ch, ds->nb_surround, ds->nb_lfe));\n\t\t\tdesc = gf_mpd_descriptor_new(NULL, \"urn:mpeg:mpegB:cicp:ChannelConfiguration\", value);\n\t\t}\n\n\t\tgf_mpd_del_list(ds->rep->audio_channels, gf_mpd_descriptor_free, GF_TRUE);\n\n\t\tgf_list_add(ds->rep->audio_channels, desc);\n\t\tif (ds->atmos_complexity_type) {\n\t\t\tdesc = gf_mpd_descriptor_new(NULL, \"tag:dolby.com,2018:dash:EC3_ExtensionType:2018\", \"JOC\");\n\t\t\tgf_list_add(ds->rep->supplemental_properties, desc);\n\n\t\t\tsprintf(value, \"%d\", ds->atmos_complexity_type);\n\t\t\tdesc = gf_mpd_descriptor_new(NULL, \"tag:dolby.com,2018:dash:EC3_ExtensionComplexityIndex:2018\", value);\n\t\t\tgf_list_add(ds->rep->supplemental_properties, desc);\n\t\t}\n\t} else {\n\t}\n\n\tif (ctx->from_index <= IDXMODE_MANIFEST) {\n\t\tdasher_get_rfc_6381_codec_name(ctx, ds, szCodec, ((ctx->bs_switch==DASHER_BS_SWITCH_INBAND) || (ctx->bs_switch==DASHER_BS_SWITCH_INBAND_PPS)) ? GF_TRUE : GF_FALSE, GF_TRUE);\n\t\tif (ds->rep->codecs) gf_free(ds->rep->codecs);\n\t\tds->rep->codecs = gf_strdup(szCodec);\n\t}\n\n\tif (ds->interlaced) ds->rep->scan_type = GF_MPD_SCANTYPE_INTERLACED;\n\telse {\n\t\t//profiles forcing scanType=progressive for progressive\n\t\tswitch (ctx->profile) {\n\t\tcase GF_DASH_PROFILE_HBBTV_1_5_ISOBMF_LIVE:\n\t\t\tds->rep->scan_type = GF_MPD_SCANTYPE_PROGRESSIVE;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (ctx->cp!=GF_DASH_CPMODE_ADAPTATION_SET) {\n\t\tgf_mpd_del_list(ds->rep->content_protection, gf_mpd_descriptor_free, 0);\n\t\tds->rep->content_protection = dasher_get_content_protection_desc(ctx, ds, NULL);\n\t}\n}\n\nstatic void dasher_setup_rep(GF_DasherCtx *ctx, GF_DashStream *ds, u32 *srd_rep_idx)\n{\n\tconst GF_PropertyValue *p;\n\n\tassert(ds->rep==NULL);\n\tds->rep = gf_mpd_representation_new();\n\tds->rep->playback.udta = ds;\n\tif (ds->tci)\n\t\tds->rep->crypto_type = 1;\n\telse\n\t\tds->rep->crypto_type = ds->is_encrypted ? 2 : 0;\n\n\tdasher_update_rep(ctx, ds);\n\tds->rep->streamtype = ds->stream_type;\n\n\tp = gf_filter_pid_get_property(ds->ipid, GF_PROP_PID_AS_ID);\n\t//do not reset as id in case of period continuity\n\tif (p) {\n\t\tif (ds->as_id != p->value.uint) {\n\t\t\tif (ds->period_continuity_id) gf_free(ds->period_continuity_id);\n\t\t\tds->period_continuity_id = NULL;\n\t\t}\n\t\tds->as_id = p->value.uint;\n\t}\n\n\tp = gf_filter_pid_get_property(ds->ipid, GF_PROP_PID_REP_ID);\n\tif (p) {\n\t\tif (ds->rep_id) gf_free(ds->rep_id);\n\n\t\tif (!ds->tile_base && (ds->srd.w || ds->srd.z) && !ctx->sseg && !ctx->sfile) {\n\t\t\tchar *rep_name = gf_malloc(sizeof(char) * (strlen(p->value.string) + 15) );\n\t\t\tsprintf(rep_name, \"%s_%d\", p->value.string, *srd_rep_idx);\n\t\t\tds->rep_id = rep_name;\n\t\t\t(*srd_rep_idx) ++;\n\t\t} else {\n\t\t\tds->rep_id = gf_strdup(p->value.string);\n\t\t}\n\n\t} else if (!ds->rep_id) {\n\t\tchar szRepID[20];\n\t\tsprintf(szRepID, \"%d\", 1 + gf_list_find(ctx->pids, ds));\n\t\tds->rep_id = gf_strdup(szRepID);\n\t}\n\tds->rep->id = gf_strdup(ds->rep_id);\n\n\tp = gf_filter_pid_get_property(ds->ipid, GF_PROP_PID_HLS_EXT_MASTER);\n\tif (p) {\n\t\tds->rep->nb_hls_master_tags = p->value.string_list.nb_items;\n\t\tds->rep->hls_master_tags = (const char **) p->value.string_list.vals;\n\t}\n\tp = gf_filter_pid_get_property(ds->ipid, GF_PROP_PID_HLS_EXT_VARIANT);\n\tif (p) {\n\t\tds->rep->nb_hls_variant_tags = p->value.string_list.nb_items;\n\t\tds->rep->hls_variant_tags = (const char **) p->value.string_list.vals;\n\t}\n\n\tp = gf_filter_pid_get_property(ds->ipid, GF_PROP_PID_URL);\n\tif (p && ctx->do_index) {\n\t\tchar *dst = gf_filter_pid_get_destination(ctx->opid);\n\t\tif (dst) {\n\t\t\tchar *opath=NULL, *ipath=NULL;\n\t\t\tif (gf_url_is_relative(p->value.string) && (p->value.string[0]!='.'))\n\t\t\t\tgf_dynstrcat(&opath, \"./\", NULL);\n\t\t\tgf_dynstrcat(&opath, p->value.string, NULL);\n\t\t\tif (gf_url_is_relative(dst) && (dst[0]!='.'))\n\t\t\t\tgf_dynstrcat(&ipath, \"./\", NULL);\n\t\t\tgf_dynstrcat(&ipath, dst, NULL);\n\n\t\t\tds->rep->res_url = gf_url_concatenate_parent(ipath, opath);\n\t\t\tgf_free(ipath);\n\t\t\tgf_free(opath);\n\t\t} else {\n\t\t\tds->rep->res_url = gf_strdup(p->value.string);\n\t\t}\n\t\tif (dst) gf_free(dst);\n\t\tp = gf_filter_pid_get_property(ds->ipid, GF_PROP_PID_ID);\n\t\tds->rep->trackID = p ? p->value.uint : 0;\n\n\t\tif (ctx->do_index==2) {\n\t\t\tif (!ds->rep->x_children) ds->rep->x_children = gf_list_new();\n\t\t\tu32 idx=0;\n\t\t\tchar *obuf=NULL;\n\t\t\tu32 obuf_alloc = 0;\n\t\t\twhile (1) {\n\t\t\t\tu32 p4cc;\n\t\t\t\tconst char *pname;\n\t\t\t\tp = gf_filter_pid_enum_properties(ds->ipid, &idx, &p4cc, &pname);\n\t\t\t\tif (!p) break;\n\t\t\t\tswitch (p4cc) {\n\t\t\t\tcase GF_PROP_PID_ID:\n\t\t\t\tcase GF_PROP_PID_URL:\n\t\t\t\tcase GF_PROP_PID_FILEPATH:\n\t\t\t\tcase GF_PROP_PID_FILE_EXT:\n\t\t\t\tcase GF_PROP_PID_FILE_CACHED:\n\t\t\t\tcase GF_PROP_PID_DOWN_SIZE:\n\t\t\t\tcase GF_PROP_PID_DOWNLOAD_SESSION:\n\t\t\t\tcase GF_PROP_PID_TRACK_NUM:\n\t\t\t\tcase GF_PROP_PID_MEDIA_DATA_SIZE:\n\t\t\t\tcase GF_PROP_PID_MAX_FRAME_SIZE:\n\t\t\t\tcase GF_PROP_PID_AVG_FRAME_SIZE:\n\t\t\t\tcase GF_PROP_PID_MAX_TS_DELTA:\n\t\t\t\tcase GF_PROP_PID_CONSTANT_DURATION:\n\t\t\t\tcase GF_PROP_PID_PLAYBACK_MODE:\n\t\t\t\tcase GF_PROP_PID_CHAP_TIMES:\n\t\t\t\tcase GF_PROP_PID_CHAP_NAMES:\n\t\t\t\tcase GF_PROP_PID_ISOM_UDTA:\n\t\t\t\t\tcontinue;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (p->type == GF_PROP_POINTER) continue;\n\n\t\t\t\tGF_XMLNode *prop = gf_xml_dom_node_new(NULL, \"prop\");\n\t\t\t\tprop->attributes = gf_list_new();\n\t\t\t\tgf_list_add(ds->rep->x_children,  prop);\n\t\t\t\tprop->orig_pos = -1;\n\t\t\t\tGF_XMLAttribute *att;\n\t\t\t\tif (p4cc) {\n\t\t\t\t\tatt = gf_xml_dom_create_attribute(\"type\", gf_props_4cc_get_name(p4cc));\n\t\t\t\t\tgf_list_add(prop->attributes, att);\n\t\t\t\t} else {\n\t\t\t\t\tatt = gf_xml_dom_create_attribute(\"name\", pname);\n\t\t\t\t\tgf_list_add(prop->attributes, att);\n\t\t\t\t\tatt = gf_xml_dom_create_attribute(\"ptype\", gf_props_get_type_name(p->type));\n\t\t\t\t\tgf_list_add(prop->attributes, att);\n\t\t\t\t}\n\t\t\t\tchar szDump[GF_PROP_DUMP_ARG_SIZE];\n\t\t\t\tu32 res, obuf_size, j;\n\t\t\t\tchar *cdata=NULL;\n\n\t\t\t\tswitch (p->type) {\n\t\t\t\tcase GF_PROP_DATA:\n\t\t\t\tcase GF_PROP_DATA_NO_COPY:\n\t\t\t\tcase GF_PROP_CONST_DATA:\n\t\t\t\t\tobuf_size = p->value.data.size*3;\n\t\t\t\t\tif (obuf_size>obuf_alloc) {\n\t\t\t\t\t\tobuf = gf_realloc(obuf, sizeof(char)*obuf_size);\n\t\t\t\t\t\tobuf_alloc = obuf_size;\n\t\t\t\t\t}\n\t\t\t\t\tres = gf_base64_encode(p->value.data.ptr, p->value.data.size, obuf, obuf_size);\n\t\t\t\t\tobuf[res] = 0;\n\t\t\t\t\tatt = gf_xml_dom_create_attribute(\"value\", obuf);\n\t\t\t\t\tgf_list_add(prop->attributes, att);\n\t\t\t\t\tbreak;\n\t\t\t\tcase GF_PROP_STRING_LIST:\n\t\t\t\t\tfor (j=0; j<p->value.string_list.nb_items; j++) {\n\t\t\t\t\t\tgf_dynstrcat( &cdata, p->value.string_list.vals[j], \",\");\n\t\t\t\t\t}\n\t\t\t\t\tj = (u32) (strlen(cdata)+1);\n\t\t\t\t\tobuf_size = j*3;\n\t\t\t\t\tif (obuf_size>obuf_alloc) {\n\t\t\t\t\t\tobuf = gf_realloc(obuf, sizeof(char)*obuf_size);\n\t\t\t\t\t\tobuf_alloc = obuf_size;\n\t\t\t\t\t}\n\t\t\t\t\tres = gf_base64_encode(cdata, j, obuf, obuf_size);\n\t\t\t\t\tobuf[res] = 0;\n\t\t\t\t\tatt = gf_xml_dom_create_attribute(\"value\", obuf);\n\t\t\t\t\tgf_list_add(prop->attributes, att);\n\t\t\t\t\tgf_free(cdata);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tatt = gf_xml_dom_create_attribute(\"value\", gf_props_dump(p4cc, p, szDump, GF_PROP_DUMP_NO_REDUCE));\n\t\t\t\t\tgf_list_add(prop->attributes, att);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (obuf) gf_free(obuf);\n\t\t}\n\t}\n}\n\nstatic Bool dasher_same_roles(GF_DashStream *ds1, GF_DashStream *ds2)\n{\n\tconst GF_PropStringList *slist;\n\tif (ds1->p_role && ds2->p_role) {\n\t\tif (gf_props_equal(ds1->p_role, ds2->p_role)) return GF_TRUE;\n\t}\n\tif (!ds1->p_role && !ds2->p_role)\n\t\treturn GF_TRUE;\n\n\t//special case, if one is set and the other is not, compare with \"main\" role\n\tslist = ds2->p_role ?  &ds2->p_role->value.string_list : &ds1->p_role->value.string_list;\n\tif (slist->nb_items==1) {\n\t\tif (!strcmp(slist->vals[0], \"main\")) return GF_TRUE;\n\t}\n\treturn GF_FALSE;\n}\n\nstatic u32 dasher_get_next_as_id(GF_DasherCtx *ctx)\n{\n\tu32 check_id = 1;\n\tu32 i, count = gf_list_count(ctx->current_period->streams);\n\tfor (i=0; i<count; i++) {\n\t\tGF_DashStream *ds = gf_list_get(ctx->current_period->streams, i);\n\t\tif (ds->as_id == check_id) {\n\t\t\tcheck_id++;\n\t\t\ti = -1;\n\t\t\tcontinue;\n\t\t}\n\t}\n\treturn check_id;\n}\n\nstatic Bool dasher_same_adaptation_set(GF_DasherCtx *ctx, GF_DashStream *ds, GF_DashStream *ds_test)\n{\n\tconst char *lang1, *lang2;\n\tconst GF_PropertyValue *p1, *p2;\n\n\t//in all forward mode we don't rewrite the manifest, make each source file a single as\n\tif (ctx->forward_mode==DASHER_FWD_ALL)\n\t\treturn GF_FALSE;\n\t\t\n\t//muxed representations\n\tif (ds_test->muxed_base) {\n\t\tif (ds_test->muxed_base == ds)\n\t\t\treturn GF_TRUE;\n\t\t//if muxed base rep has been registered with this AdaptationSet, also register this stream\n\t\tif (gf_list_find(ds->set->representations, ds_test->muxed_base->rep)>=0)\n\t\t\treturn GF_TRUE;\n\t}\n\n\t//otherwise we have to be of same type\n\tif (ds->stream_type != ds_test->stream_type) return GF_FALSE;\n\n\t//not the same roles\n\tif (!dasher_same_roles(ds, ds_test)) return GF_FALSE;\n\n\t//avoid text streams with no roles and same language to be in the same AS\n\tif (ds->stream_type==GF_STREAM_TEXT) {\n\t\tif (ds->codec_id==ds_test->codec_id) return GF_FALSE;\n\t}\n\n\t//intra-only trick mode belongs to a separate AS\n\tif ((ds->stream_type == GF_STREAM_VISUAL) && (ds->sync_points_type != ds_test->sync_points_type)) {\n\t\t//assign trickmode as id for dashif\n\t\tif (ds_test->sync_points_type == DASHER_SYNC_NONE) {\n\t\t\tif (!ds->as_id) ds->as_id = dasher_get_next_as_id(ctx);\n\t\t\tds_test->sync_as_id = ds->as_id;\n\t\t}\n\t\telse if (ds->sync_points_type == DASHER_SYNC_NONE) {\n\t\t\tif (!ds_test->as_id) ds_test->as_id = dasher_get_next_as_id(ctx);\n\t\t\tds->sync_as_id = ds_test->as_id;\n\t\t}\n\t\treturn GF_FALSE;\n\t}\n\n\t/* if two inputs don't have the same (number and value) as_desc they don't belong to the same AdaptationSet\n\t   (use c_as_desc for AdaptationSet descriptors common to all inputs in an AS) */\n\tif (!ds->p_as_desc && ds_test->p_as_desc)\n\t\treturn GF_FALSE;\n\tif (ds->p_as_desc && !ds_test->p_as_desc)\n\t\treturn GF_FALSE;\n\tif (ds->p_as_desc && ! gf_props_equal(ds->p_as_desc, ds_test->p_as_desc))\n\t\treturn GF_FALSE;\n\n\t//need same AS ID if specified\n\tif (ds->as_id && ds_test->as_id &&(ds->as_id != ds_test->as_id) )\n\t\treturn GF_FALSE;\n\n\t//need same dash duration if aligned\n\tif (ctx->align) {\n\t\tif ((u64) ds->dash_dur.num * ds_test->dash_dur.den != (u64) ds_test->dash_dur.num * ds->dash_dur.den) return GF_FALSE;\n\t}\n\n\t//if one of the pid is marked with period resume and the other is not, one is a spliced media the other no\n\t//cf flist filter\n\tp1 = gf_filter_pid_get_property_str(ds->ipid, \"period_resume\");\n\tp2 = gf_filter_pid_get_property_str(ds_test->ipid, \"period_resume\");\n\tif ((!p1 && p2) || (p1 && !p2) || (p1 && gf_props_equal(p1, p2)))\n\t\treturn GF_FALSE;\n\n\tif (ds->srd.x != ds_test->srd.x) return GF_FALSE;\n\tif (ds->srd.y != ds_test->srd.y) return GF_FALSE;\n\tif (ds->srd.z != ds_test->srd.z) return GF_FALSE;\n\tif (ds->srd.w != ds_test->srd.w) return GF_FALSE;\n\n\tif (ds->view_id != ds_test->view_id) return GF_FALSE;\n\t//according to DASH spec mixing interlaced and progressive is OK\n\t//if (ds->interlaced != ds_test->interlaced) return GF_FALSE;\n\tif (ds->nb_ch != ds_test->nb_ch) return GF_FALSE;\n\n\tlang1 = ds->lang ? ds->lang : \"und\";\n\tlang2 = ds_test->lang ? ds_test->lang : \"und\";\n\tif (strcmp(lang1, lang2)) return GF_FALSE;\n\n\tif (ds->stream_type==GF_STREAM_VISUAL) {\n\t\tu32 w, h, tw, th;\n\t\tif (ctx->no_sar) {\n\t\t\tw = ds->width;\n\t\t\th = ds->height;\n\t\t\ttw = ds_test->width;\n\t\t\tth = ds_test->height;\n\t\t} else {\n\t\t\tw = ds->width * ds->sar.num;\n\t\t\th = ds->height * ds->sar.den;\n\t\t\ttw = ds_test->width * ds_test->sar.num;\n\t\t\tth = ds_test->height * ds_test->sar.den;\n\t\t}\n\n\t\t//not the same aspect ratio\n\t\tif (w * th != h * tw)\n\t\t\treturn GF_FALSE;\n\t} else if (ds->stream_type==GF_STREAM_AUDIO) {\n\t\tif (!ctx->mix_codecs && (ds->codec_id != ds_test->codec_id) )\n\t\t\treturn GF_FALSE;\n\t\t//we allow mix of channels config\n\t} else {\n\t\tif (!ctx->mix_codecs && strcmp(ds->rep->codecs, ds_test->rep->codecs)) return GF_FALSE;\n\t\treturn GF_TRUE;\n\t}\n\t//ok, we are video or audio with mixed codecs\n\tif (ctx->mix_codecs) return GF_TRUE;\n\t//we need dependencies, unless SRD case\n\tif (!ds_test->srd.z && !ds_test->srd.w) {\n\t\tif (ds_test->dep_id && (ds_test->src_id==ds->src_id) && gf_list_find(ds->complementary_streams, ds_test) < 0) {\n\t\t\treturn GF_FALSE;\n\t\t}\n\t}\n\t//we should be good\n\treturn GF_TRUE;\n}\n\nstatic void dasher_add_descriptors(GF_List **p_dst_list, const GF_PropertyValue *desc_val)\n{\n\tu32 j, count;\n\tGF_List *dst_list;\n\tif (!desc_val) return;\n\tif (desc_val->type != GF_PROP_STRING_LIST) return;\n\tcount = desc_val->value.string_list.nb_items;\n\tif (!count) return;\n\tif ( ! (*p_dst_list)) *p_dst_list = gf_list_new();\n\tdst_list = *p_dst_list;\n\tfor (j=0; j<count; j++) {\n\t\tchar *desc = desc_val->value.string_list.vals[j];\n\t\tif (desc[0] == '<') {\n\t\t\tGF_XMLNode *d;\n\t\t\tGF_SAFEALLOC(d, GF_XMLNode);\n\t\t\tif (d) {\n\t\t\t\td->type = GF_XML_TEXT_TYPE;\n\t\t\t\td->name = gf_strdup(desc);\n\t\t\t\tgf_list_add(dst_list, d);\n\t\t\t}\n\t\t} else {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_DASH, (\"[Dasher] Invalid descriptor %s, expecting '<' as first character\\n\", desc));\n\t\t}\n\t}\n}\n\nstatic void dasher_setup_set_defaults(GF_DasherCtx *ctx, GF_MPD_AdaptationSet *set)\n{\n\tu32 i, count;\n\tBool main_role_set = GF_FALSE;\n\t//by default setup alignment\n\tif (ctx->sseg) set->subsegment_alignment = ctx->align;\n\telse set->segment_alignment = ctx->align;\n\n\t//startWithSAP is set when the first packet comes in\n\n\t//the rest depends on the various profiles/iop, to check\n\tcount = gf_list_count(set->representations);\n\tfor (i=0; i<count; i++) {\n\t\tGF_MPD_Representation *rep = gf_list_get(set->representations, i);\n\t\tGF_DashStream *ds = rep->playback.udta;\n\n\t\tif (set->max_width < ds->width) set->max_width = ds->width;\n\t\tif (set->max_height < ds->height) set->max_height = ds->height;\n/*\t\tif (set->max_bandwidth < ds->rep->bandwidth) set->max_bandwidth = ds->rep->bandwidth;\n\t\tif (set->max_framerate * ds->fps.den < ds->fps.num) set->max_framerate = (u32) (ds->fps.num / ds->fps.den);\n*/\n\n\t\t/*set trick mode*/\n\t\tif (set->intra_only && (ds->stream_type==GF_STREAM_VISUAL)) {\n\t\t\tchar value[256];\n\t\t\tGF_MPD_Descriptor* desc;\n\t\t\tsprintf(value, \"%d\", ds->sync_as_id);\n\t\t\tdesc = gf_mpd_descriptor_new(NULL, \"http://dashif.org/guidelines/trickmode\", value);\n\t\t\tgf_list_add(set->essential_properties, desc);\n\t\t}\n\t\t/*set role*/\n\t\tif (ds->p_role) {\n\t\t\tu32 j, role_count;\n\t\t\trole_count = ds->p_role->value.string_list.nb_items;\n\t\t\tfor (j=0; j<role_count; j++) {\n\t\t\t\tchar *role = ds->p_role->value.string_list.vals[j];\n\t\t\t\tGF_MPD_Descriptor *desc=NULL;\n\t\t\t\tchar *uri=NULL;\n\t\t\t\t//all roles defined by dash 5th edition\n\t\t\t\tif (!strcmp(role, \"caption\") || !strcmp(role, \"subtitle\") || !strcmp(role, \"main\")\n\t\t\t        || !strcmp(role, \"alternate\") || !strcmp(role, \"supplementary\") || !strcmp(role, \"commentary\")\n\t\t\t        || !strcmp(role, \"dub\") || !strcmp(role, \"description\") || !strcmp(role, \"sign\")\n\t\t\t\t\t || !strcmp(role, \"metadata\") || !strcmp(role, \"enhanced-audio-intelligibility\")\n\t\t\t\t\t || !strcmp(role, \"emergency\") || !strcmp(role, \"forced-subtitle\")\n\t\t\t\t\t || !strcmp(role, \"easyreader\") || !strcmp(role, \"karaoke\")\n\t\t\t\t) {\n\t\t\t\t\turi = \"urn:mpeg:dash:role:2011\";\n\t\t\t\t\tif (!strcmp(role, \"main\")) main_role_set = GF_TRUE;\n\t\t\t\t} else {\n\t\t\t\t\tchar *sep = strrchr(role, ':');\n\t\t\t\t\tif (sep) {\n\t\t\t\t\t\tsep[0] = 0;\n\t\t\t\t\t\tdesc = gf_mpd_descriptor_new(NULL, role, sep+1);\n\t\t\t\t\t\tsep[0] = ':';\n\t\t\t\t\t} else {\n\t\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_DASH, (\"[Dasher] Unrecognized role %s - using GPAC urn for schemaID\\n\", role));\n\t\t\t\t\t\turi = \"urn:gpac:dash:role:2013\";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!desc)\n\t\t\t\t\tdesc = gf_mpd_descriptor_new(NULL, uri, role);\n\n\t\t\t\tgf_list_add(set->role, desc);\n\t\t\t}\n\t\t}\n\t\t//set SRD\n\t\tif (!i && ds->srd.z && ds->srd.w) {\n\t\t\tchar value[256];\n\t\t\tGF_MPD_Descriptor *desc;\n\t\t\tif (ds->dep_id) {\n\t\t\t\tsprintf(value, \"1,%d,%d,%d,%d\", ds->srd.x, ds->srd.y, ds->srd.z, ds->srd.w);\n\t\t\t\tdesc = gf_mpd_descriptor_new(NULL, \"urn:mpeg:dash:srd:2014\", value);\n\t\t\t\tgf_list_add(set->supplemental_properties, desc);\n\t\t\t} else {\n\t\t\t\tif (ds->tile_base) {\n\t\t\t\t\tsprintf(value, \"1,0,0,0,0,%d,%d\", ds->srd.z, ds->srd.w);\n\t\t\t\t} else {\n\t\t\t\t\tconst GF_PropertyValue *p = gf_filter_pid_get_property(ds->ipid, GF_PROP_PID_SRD_REF);\n\t\t\t\t\tif (p) {\n\t\t\t\t\t\tsprintf(value, \"1,%d,%d,%d,%d,%d,%d\", ds->srd.x, ds->srd.y, ds->srd.z, ds->srd.w, p->value.vec2i.x, p->value.vec2i.y);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsprintf(value, \"1,%d,%d,%d,%d\", ds->srd.x, ds->srd.y, ds->srd.z, ds->srd.w);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdesc = gf_mpd_descriptor_new(NULL, \"urn:mpeg:dash:srd:2014\", value);\n\t\t\t\tgf_list_add(set->essential_properties, desc);\n\t\t\t}\n\t\t}\n\t\t//set HDR\n\t\tif (ds->hdr_type > DASHER_HDR_NONE) {\n\t\t\tchar value[256];\n\t\t\tGF_MPD_Descriptor* desc;\n\t\t\tsprintf(value, \"9\");\n\t\t\tdesc = gf_mpd_descriptor_new(NULL, \"urn:mpeg:mpegB:cicp:ColourPrimaries\", value);\n\t\t\tgf_list_add(set->essential_properties, desc);\n\t\t\tsprintf(value, \"9\");\n\t\t\tdesc = gf_mpd_descriptor_new(NULL, \"urn:mpeg:mpegB:cicp:MatrixCoefficients\", value);\n\t\t\tgf_list_add(set->essential_properties, desc);\n\n\t\t\tif (ds->hdr_type==DASHER_HDR_PQ10) {\n\t\t\t\tsprintf(value, \"16\");\n\t\t\t\tdesc = gf_mpd_descriptor_new(NULL, \"urn:mpeg:mpegB:cicp:TransferCharacteristics\", value);\n\t\t\t\tgf_list_add(set->essential_properties, desc);\n\t\t\t}\n\n\t\t\tif (ds->hdr_type == DASHER_HDR_HLG) {\n\t\t\t\tsprintf(value, \"14\");\n\t\t\t\tdesc = gf_mpd_descriptor_new(NULL, \"urn:mpeg:mpegB:cicp:TransferCharacteristics\", value);\n\t\t\t\tgf_list_add(set->essential_properties, desc);\n\t\t\t\tsprintf(value, \"18\");\n\t\t\t\tdesc = gf_mpd_descriptor_new(NULL, \"urn:mpeg:mpegB:cicp:TransferCharacteristics\", value);\n\t\t\t\tgf_list_add(set->supplemental_properties, desc);\n\t\t\t}\n\t\t}\n\t}\n\tif (ctx->check_main_role && !main_role_set) {\n\t\tGF_MPD_Descriptor *desc;\n\t\tdesc = gf_mpd_descriptor_new(NULL, \"urn:mpeg:dash:role:2011\", \"main\");\n\t\tgf_list_add(set->role, desc);\n\t}\n}\n\nstatic void rewrite_dep_ids(GF_DasherCtx *ctx, GF_DashStream *base_ds)\n{\n\tu32 i, count = gf_list_count(ctx->pids);\n\tfor (i=0; i<count; i++) {\n\t\tGF_DashStream *ds = gf_list_get(ctx->pids, i);\n\t\tif (ds->src_id != base_ds->src_id) continue;\n\t\tif (!ds->dep_id || !ds->rep) continue;\n\t\tif (ds->dep_id != base_ds->id) continue;\n\n\t\tds->tile_dep_id_merged = GF_TRUE;\n\t\tif (ds->rep->dependency_id) gf_free(ds->rep->dependency_id);\n\t\tds->rep->dependency_id = gf_strdup(base_ds->merged_tile_dep->rep->id);\n\t}\n}\n\nstatic void dasher_check_bitstream_swicthing(GF_DasherCtx *ctx, GF_MPD_AdaptationSet *set)\n{\n\tu32 i, j, count;\n\tBool use_inband = ((ctx->bs_switch==DASHER_BS_SWITCH_INBAND) || (ctx->bs_switch==DASHER_BS_SWITCH_INBAND_PPS) || (ctx->bs_switch==DASHER_BS_SWITCH_BOTH)) ? GF_TRUE : GF_FALSE;\n\tBool use_multi = (ctx->bs_switch==DASHER_BS_SWITCH_MULTI) ? GF_TRUE : GF_FALSE;\n\tGF_MPD_Representation *base_rep = gf_list_get(set->representations, 0);\n\tGF_DashStream *base_ds;\n\n\tswitch (ctx->muxtype) {\n\tcase DASHER_MUX_TS:\n\tcase DASHER_MUX_OGG:\n\tcase DASHER_MUX_RAW:\n\t\tset->bitstream_switching = GF_TRUE;\n\t\treturn;\n\t//other formats use an init segment\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (ctx->bs_switch==DASHER_BS_SWITCH_OFF) return;\n\tif (!base_rep) return;\n\tbase_ds = base_rep->playback.udta;\n\n\tcount = gf_list_count(set->representations);\n\tif (count==1) {\n\t\tif (ctx->bs_switch==DASHER_BS_SWITCH_FORCE) set->bitstream_switching=GF_TRUE;\n\t\telse if (use_inband) {\n\t\t\tbase_ds->inband_params = ctx->bs_switch==DASHER_BS_SWITCH_BOTH ? 3 : 1;\n\t\t\tif (base_ds->codec_id==GF_CODECID_VVC && ctx->bs_switch==DASHER_BS_SWITCH_INBAND_PPS)\n\t\t\t\tbase_ds->inband_params = 2;\n\t\t}\n\t\treturn;\n\t}\n\n\tfor (i=1; i<count; i++) {\n\t\tGF_MPD_Representation *rep = gf_list_get(set->representations, i);\n\t\tGF_DashStream *ds = rep->playback.udta;\n\t\t//same codec ID\n\t\tif (ds->codec_id == base_ds->codec_id) {\n\t\t\t//we will use inband params, so bs switching is OK\n\t\t\tif (use_inband || use_multi) continue;\n\t\t\t//we have deps, cannot use bitstream switching except for merged tile base\n\t\t\tif (ds->dep_id) {\n\t\t\t\tif (ds->codec_id==GF_CODECID_HEVC_TILES) {\n\t\t\t\t\tu32 id;\n\t\t\t\t\tGF_DashStream *tile_base = get_base_ds(ctx, ds);\n\t\t\t\t\tif (!tile_base) return;\n\t\t\t\t\tid = tile_base->merged_tile_dep ? tile_base->merged_tile_dep->id : tile_base->id;\n\t\t\t\t\tif (base_ds->dep_id==id) continue;\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t//we consider we can switch in non-inband only if we have same CRC for the decoder config\n\t\t\tif (base_ds->dsi_crc == ds->dsi_crc) continue;\n\t\t\t//not the same config, no BS switching\n\t\t\treturn;\n\t\t}\n\t\t//dependencies / different codec IDs, cannot use bitstream switching\n\t\treturn;\n\t}\n\t//ok we can use BS switching, ensure we use the same timescale for every stream\n\tset->bitstream_switching = GF_TRUE;\n\n\tfor (i=0; i<count; i++) {\n\t\tGF_MPD_Representation *rep = gf_list_get(set->representations, i);\n\t\tGF_DashStream *ds = rep->playback.udta;\n\t\tif (base_ds->tile_base && ds->tile_base && (base_ds != ds) ) {\n\t\t\tds->merged_tile_dep = base_ds;\n\t\t\tif (ds->rep) {\n\t\t\t\tgf_list_rem(set->representations, i);\n\t\t\t\ti--;\n\t\t\t\tcount--;\n\t\t\t\tgf_mpd_representation_free(ds->rep);\n\t\t\t\tds->rep = NULL;\n\t\t\t\t//switch dependencyID of all reps depending on this one to the new base\n\t\t\t\trewrite_dep_ids(ctx, ds);\n\t\t\t\t//and ignore this rep while flushing segments\n\t\t\t\tbase_ds->nb_rep--;\n\t\t\t}\n\t\t}\n\t\tfor (j=i+1; j<count; j++) {\n\t\t\tGF_DashStream *a_ds;\n\t\t\trep = gf_list_get(set->representations, j);\n\t\t\ta_ds = rep->playback.udta;\n\t\t\tif (a_ds->stream_type != ds->stream_type) continue;\n\t\t\tif (a_ds->timescale != ds->timescale)\n\t\t\t\ta_ds->force_timescale = ds->timescale;\n\t\t}\n\t}\n}\n\nGF_Err gf_cryptfout_push_key(GF_Filter *filter, bin128 *key, bin128 *IV);\n\nenum\n{\n\t//init segment valid\n\tDASH_INITSEG_PRESENT=0,\n\t//no init segment for given format\n\tDASH_INITSEG_NONE,\n\t//init segment for given format but skipped due to bitstream switching constraints\n\tDASH_INITSEG_SKIP\n};\n\nstatic void dasher_open_destination(GF_Filter *filter, GF_DasherCtx *ctx, GF_MPD_Representation *rep, const char *szInitURL, u32 trash_init)\n{\n\tGF_Err e;\n\tBool has_frag=GF_FALSE;\n\tBool has_subs=GF_FALSE;\n\tBool has_strun=GF_FALSE;\n\tBool has_vodcache=GF_FALSE;\n\tBool has_cmaf=GF_FALSE;\n\tBool has_psshs=GF_FALSE;\n\tconst GF_PropertyValue *p;\n\tchar sep_args = gf_filter_get_sep(filter, GF_FS_SEP_ARGS);\n\tchar sep_name = gf_filter_get_sep(filter, GF_FS_SEP_NAME);\n\tconst char *dst_args, *trailer_args=NULL, *dst_forced=NULL;\n\tchar *szDST = NULL;\n\tchar szSRC[100];\n\n\tif (ctx->sigfrag || ctx->gencues || ctx->do_index)\n\t\treturn;\n\n\tGF_DashStream *ds = rep->playback.udta;\n\tif (ds->muxed_base) return;\n\n\tswitch (ctx->from_index) {\n\tcase IDXMODE_MANIFEST:\n\tcase IDXMODE_CHILD:\n\t\tif (trash_init==DASH_INITSEG_NONE) return;\n\t\ttrash_init = DASH_INITSEG_SKIP;\n\t\tbreak;\n\tcase IDXMODE_ALL:\n\t\tif (trash_init==DASH_INITSEG_NONE) return;\n\t\tbreak;\n\tcase IDXMODE_INIT:\n\t\tif (trash_init==DASH_INITSEG_NONE) return;\n\t\tp = gf_filter_pid_get_property_str(ds->ipid, \"idx_out\");\n\t\tif (p) dst_forced = p->value.string;\n\t\tbreak;\n\t}\n\n\tctx->check_connections = GF_TRUE;\n\tif (dst_forced) {\n\t\tgf_dynstrcat(&szDST, dst_forced, NULL);\n\t\tszInitURL = dst_forced; //for logs\n\t}\n\telse if (ctx->out_path) {\n\t\tchar *rel = NULL;\n\t\tif (ctx->do_m3u8 && ds->hls_vp_name) {\n\t\t\tchar *tmp = gf_url_concatenate(ctx->out_path, ds->hls_vp_name);\n\t\t\tif (tmp) {\n\t\t\t\trel = gf_url_concatenate(tmp, szInitURL);\n\t\t\t\tgf_free(tmp);\n\t\t\t}\n\t\t}\n\t\tif (!rel)\n\t\t\trel = gf_url_concatenate(ctx->out_path, szInitURL);\n\t\tif (rel) {\n\t\t\tszDST = rel;\n\t\t}\n\t}\n\telse\n\t\tgf_dynstrcat(&szDST, szInitURL, NULL);\n\n\n\tif (ds->tci) {\n\t\tchar *tmp = szDST;\n\t\tszDST = NULL;\n\t\tgf_dynstrcat(&szDST, \"gcryp://\", NULL);\n\t\tgf_dynstrcat(&szDST, tmp, NULL);\n\t\tgf_free(tmp);\n\t}\n\n\tsprintf(szSRC, \"%cgfopt\", sep_args);\n\tgf_dynstrcat(&szDST, szSRC, NULL);\n\n\tdst_args = gf_filter_get_dst_args(filter);\n\tif (dst_args) {\n\t\tchar szKey[20], *sep;\n\t\tsprintf(szSRC, \"%c\", sep_args);\n\t\tgf_dynstrcat(&szDST, szSRC, NULL);\n\t\t\n\t\tgf_dynstrcat(&szDST, dst_args, NULL);\n\t\tsprintf(szKey, \"%c%c\", sep_args, sep_args);\n\t\tsep = strstr(szDST, szKey);\n\t\tif (sep) {\n\t\t\tsep[0] = 0;\n\t\t\ttrailer_args = strstr(dst_args, szKey);\n\t\t}\n\t\t//look for frag arg\n\t\tsprintf(szKey, \"%cfrag\", sep_args);\n\t\tif (strstr(dst_args, szKey)) has_frag = GF_TRUE;\n\t\telse {\n\t\t\tsprintf(szKey, \"%csfrag\", sep_args);\n\t\t\tif (strstr(dst_args, szKey)) has_frag = GF_TRUE;\n\t\t}\n\t\t//look for subs_sidx arg\n\t\tsprintf(szKey, \"%csubs_sidx\", sep_args);\n\t\tif (strstr(dst_args, szKey)) has_subs = GF_TRUE;\n\n\t\tsprintf(szKey, \"%cstrun\", sep_args);\n\t\tif (strstr(dst_args, szKey)) has_strun = GF_TRUE;\n\n\t\tsprintf(szKey, \"%cvodcache\", sep_args);\n\t\tif (strstr(dst_args, szKey)) has_vodcache = GF_TRUE;\n\n\t\tsprintf(szKey, \"%ccmaf\", sep_args);\n\t\tif (strstr(dst_args, szKey)) has_cmaf = GF_TRUE;\n\n\t\tsprintf(szKey, \"%cpsshs\", sep_args);\n\t\tif (strstr(dst_args, szKey)) has_psshs = GF_TRUE;\n\t}\n\tif ((ctx->from_index==IDXMODE_SEG) && !gf_sys_is_test_mode())\n\t\ttrash_init = DASH_INITSEG_SKIP;\n\n\tif (trash_init) {\n\t\tif (ds->rawmux)\n\t\t\tsprintf(szSRC, \"%cnoinitraw\", sep_args);\n\t\telse\n\t\t\tsprintf(szSRC, \"%cnoinit\", sep_args);\n\t\tgf_dynstrcat(&szDST, szSRC, NULL);\n\t}\n\tif (!has_frag) {\n\t\tsprintf(szSRC, \"%cfrag\", sep_args);\n\t\tgf_dynstrcat(&szDST, szSRC, NULL);\n\t}\n\tif (!ctx->forward_mode) {\n\t\tif (!has_subs && ctx->sseg) {\n\t\t\tsprintf(szSRC, \"%csubs_sidx%c0\", sep_args, sep_name);\n\t\t\tgf_dynstrcat(&szDST, szSRC, NULL);\n\t\t}\n\t\tif (ctx->cues && !has_strun) {\n\t\t\tsprintf(szSRC, \"%cstrun\", sep_args);\n\t\t\tgf_dynstrcat(&szDST, szSRC, NULL);\n\t\t}\n\t\tif (ctx->styp) {\n\t\t\tsprintf(szSRC, \"%cstyp=%s\", sep_args, ctx->styp);\n\t\t\tgf_dynstrcat(&szDST, szSRC, NULL);\n\t\t}\n\t}\n\n\t{\n\t\t//override xps inband declaration in args\n\t\tchar *xps_inband;\n\t\tswitch (ds->inband_params) {\n\t\tcase 1: xps_inband = \"all\"; break;\n\t\tcase 2: xps_inband = \"pps\"; break;\n\t\tcase 3: xps_inband = \"both\"; break;\n\t\tdefault: xps_inband = \"no\"; break;\n\t\t}\n\t\tsprintf(szSRC, \"%cxps_inband%c%s\", sep_args, sep_name, xps_inband);\n\t}\n\tgf_dynstrcat(&szDST, szSRC, NULL);\n\n\tif (ctx->no_fragments_defaults) {\n\t\tsprintf(szSRC, \"%cnofragdef\", sep_args );\n\t\tgf_dynstrcat(&szDST, szSRC, NULL);\n\t}\n\tif (!has_psshs) {\n\t\tswitch (ctx->pssh) {\n\t\tcase GF_DASH_PSSH_MPD:\n\t\tcase GF_DASH_PSSH_NONE:\n\t\t\tsprintf(szSRC, \"%cpsshs%cnone\", sep_args, sep_name);\n\t\t\tbreak;\n\t\tcase GF_DASH_PSSH_MOOF:\n\t\tcase GF_DASH_PSSH_MOOF_MPD:\n\t\t\tp = gf_filter_pid_get_property(ds->ipid, GF_PROP_PID_CENC_HAS_ROLL);\n\t\t\t//dual moov+moof only for dash\n\t\t\tif (!ctx->do_mpd) p = NULL;\n\t\t\tif (p && p->value.boolean) {\n\t\t\t\tsprintf(szSRC, \"%cpsshs%cboth\", sep_args, sep_name);\n\t\t\t} else {\n\t\t\t\tsprintf(szSRC, \"%cpsshs%cmoof\", sep_args, sep_name);\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tp = gf_filter_pid_get_property(ds->ipid, GF_PROP_PID_CENC_HAS_ROLL);\n\t\t\t//dual moov+moof only for dash\n\t\t\tif (!ctx->do_mpd) p = NULL;\n\t\t\tif (p && p->value.boolean) {\n\t\t\t\tsprintf(szSRC, \"%cpsshs%cboth\", sep_args, sep_name);\n\t\t\t} else {\n\t\t\t\tsprintf(szSRC, \"%cpsshs%cmoov\", sep_args, sep_name);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tgf_dynstrcat(&szDST, szSRC, NULL);\n\t}\n\n\t//patch for old arch: make sure we don't have any extra free box before the sidx\n\t//we could also use vodcache=insert but this might break http outputs\n\tif (gf_sys_old_arch_compat() && !has_vodcache && ctx->sseg) {\n\t\tsprintf(szSRC, \"%cvodcache%con\", sep_args, sep_name );\n\t\tif (!strstr(szDST, szSRC))\n\t\t\tgf_dynstrcat(&szDST, szSRC, NULL);\n\t}\n\n\t//we don't append mime in case of raw streams, raw format (writegen doesn't use mime types for raw media, only file ext)\n\tif (!ds->rawmux && ((ctx->muxtype!=DASHER_MUX_RAW) || (ds->codec_id != GF_CODECID_RAW)) ) {\n\t\tsprintf(szSRC, \"%cmime%c%s\", sep_args, sep_name, rep->mime_type);\n\t\tgf_dynstrcat(&szDST, szSRC, NULL);\n\t}\n\n\tif (ds->moof_sn>1) {\n\t\tsprintf(szSRC, \"%cmsn%c%d\", sep_args, sep_name, ds->moof_sn);\n\t\tgf_dynstrcat(&szDST, szSRC, NULL);\n\t}\n\tif (ds->moof_sn_inc>1) {\n\t\tsprintf(szSRC, \"%cmsninc%c%d\", sep_args, sep_name, ds->moof_sn_inc);\n\t\tgf_dynstrcat(&szDST, szSRC, NULL);\n\t}\n\tif (ds->sscale) {\n\t\tsprintf(szSRC, \"%cmoovts%c-1\", sep_args, sep_name);\n\t\tgf_dynstrcat(&szDST, szSRC, NULL);\n\t}\n\n\tif (!has_cmaf && ctx->cmaf) {\n\t\tsprintf(szSRC, \"%ccmaf%c%s\", sep_args, sep_name, (ctx->cmaf==DASHER_CMAF_CMF2) ? \"cmf2\" : \"cmfc\");\n\t\tgf_dynstrcat(&szDST, szSRC, NULL);\n\t}\n\n\n\tif (trailer_args)\n\t\tgf_dynstrcat(&szDST, trailer_args, NULL);\n\t\t\n\tds->dst_filter = gf_filter_connect_destination(filter, szDST, &e);\n\tgf_free(szDST);\n\tszDST = NULL;\n\tif (e) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_DASH, (\"[Dasher] Couldn't create output file %s: %s\\n\", szInitURL, gf_error_to_string(e) ));\n\t\tctx->in_error = GF_TRUE;\n\t\treturn;\n\t}\n\t//reset any sourceID given in the dst_arg and assign sourceID to be the dasher filter\n\tsprintf(szSRC, \"MuxSrc%cdasher_%p\", sep_name, ds->dst_filter);\n\tgf_filter_reset_source(ds->dst_filter);\n\tgf_filter_set_source(ds->dst_filter, filter, szSRC);\n\n\tif (ds->tci && !trash_init) {\n\t\t//push NULL key, we are not encrypting the init segment\n\t\tgf_cryptfout_push_key(ds->dst_filter, NULL, NULL);\n\t}\n}\n\nstatic void dasher_gather_deps(GF_DasherCtx *ctx, u32 dependency_id, GF_List *multi_tracks)\n{\n\tu32 i, count = gf_list_count(ctx->current_period->streams);\n\tfor (i=0; i<count; i++) {\n\t\tGF_DashStream *ds = gf_list_get(ctx->current_period->streams, i);\n\t\tif (ds->id == dependency_id) {\n\t\t\tif (ds->tile_base) continue;\n\n\t\t\tassert(ds->opid);\n\t\t\tgf_list_insert(multi_tracks, ds->opid, 0);\n\t\t\tif (ds->dep_id) dasher_gather_deps(ctx, ds->dep_id, multi_tracks);\n\t\t}\n\t}\n}\n\nstatic void dasher_update_dep_list(GF_DasherCtx *ctx, GF_DashStream *ds, const char *ref_type)\n{\n\tu32 i, j, count, base_id;\n\tGF_PropertyValue *p = (GF_PropertyValue *) gf_filter_pid_get_property_str(ds->opid, ref_type);\n\tif (!p) return;\n\tbase_id = ds->dep_id ? ds->dep_id : ds->id;\n\tcount = gf_list_count(ctx->current_period->streams);\n\tfor (i=0; i<p->value.uint_list.nb_items; i++) {\n\t\tfor (j=0; j<count; j++) {\n\t\t\tGF_DashStream *a_ds = gf_list_get(ctx->current_period->streams, j);\n\t\t\tif (a_ds->dep_id != base_id) continue;\n\t\t\tif ((a_ds->id == p->value.uint_list.vals[i]) && a_ds->pid_id) {\n\t\t\t\tp->value.uint_list.vals[i] = a_ds->pid_id;\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic void dasher_open_pid(GF_Filter *filter, GF_DasherCtx *ctx, GF_DashStream *ds, GF_List *multi_pids, Bool init_trashed)\n{\n\tGF_DashStream *base_ds = ds->muxed_base ? ds->muxed_base : ds;\n\tchar szSRC[1024];\n\n\tif (ctx->sigfrag || ctx->in_error || ctx->gencues || ctx->do_index)\n\t\treturn;\n\n\tswitch (ctx->from_index) {\n\tcase IDXMODE_MANIFEST:\n\tcase IDXMODE_CHILD:\n\tcase IDXMODE_ALL:\n\tcase IDXMODE_INIT:\n\t\tif (init_trashed) return;\n\t\tif (ds->muxed_base && !base_ds->dst_filter) return;\n\t\tbreak;\n\t}\n\n\tassert(!ds->opid);\n\tassert(base_ds->dst_filter);\n\n\tif (ds->tile_base && !init_trashed) {\n\t\ts32 res = gf_list_find(ctx->postponed_pids, ds);\n\t\tif (res < 0) {\n\t\t\tgf_list_add(ctx->postponed_pids, ds);\n\t\t\treturn;\n\t\t} else {\n\t\t\tgf_list_rem(ctx->postponed_pids, res);\n\t\t}\n\t} else if (!ds->tile_base) {\n\t\tgf_list_del_item(ctx->postponed_pids, ds);\n\t}\n\n\t//tile base not live profile, make sure all our deps are ready\n\tif (ds->tile_base && !ctx->sseg) {\n\t\tu32 i, count = gf_list_count(ds->complementary_streams);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tGF_DashStream *a_ds = gf_list_get(ds->complementary_streams, i);\n\t\t\t//dep not ready\n\t\t\tif (!a_ds->opid) {\n\t\t\t\tif (gf_list_find(ctx->postponed_pids, a_ds)<0) {\n\t\t\t\t\tgf_list_add(ctx->postponed_pids, a_ds);\n\t\t\t\t}\n\t\t\t\tgf_list_del_item(ctx->postponed_pids, ds);\n\t\t\t\tgf_list_add(ctx->postponed_pids, ds);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\tsprintf(szSRC, \"dasher_%p\", base_ds->dst_filter);\n\tds->opid = gf_filter_pid_new(filter);\n\n#ifdef GPAC_64_BITS\n\tds->hls_ref_id = (u64) ds->opid;\n#else\n\tds->hls_ref_id = (u64) ((u32) ds->opid);\n#endif\n\n\tgf_filter_pid_copy_properties(ds->opid, ds->ipid);\n\tif (!ds->muxed_base) {\n\t\tgf_filter_pid_set_property(ds->opid, GF_PROP_PID_FILE_EXT, &PROP_STRING(\"*\"));\n\t\tgf_filter_pid_set_property(ds->opid, GF_PROP_PID_MIME, &PROP_STRING(ds->rep->mime_type));\n\t}\n\tif (ds->nb_cues) {\n\t\tu32 ncues = ds->nb_cues;\n\t\tif ((ds->cues[0].sample_num>0) || (ds->cues[0].cts>0) || (ds->cues[0].dts>0))\n\t\t\tncues++;\n\t\tgf_filter_pid_set_property(ds->opid, GF_PROP_PID_DASH_SEGMENTS, &PROP_UINT(ncues) );\n\t}\n\t//for route out\n\tif (ctx->is_route) {\n\t\tif (ctx->do_m3u8)\n\t\t\tgf_filter_pid_set_property(ds->opid, GF_PROP_PCK_HLS_REF, &PROP_LONGUINT( ds->hls_ref_id ) );\n\n\t\tgf_filter_pid_set_property(ds->opid, GF_PROP_PID_REP_ID, &PROP_STRING( ds->rep->id ) );\n\n\n\t\tgf_filter_pid_set_property(ds->opid, GF_PROP_PID_DASH_DUR, &PROP_FRAC( ds->dash_dur ) );\n\t}\n\n\tgf_filter_pid_require_source_id(ds->opid);\n\n\tif (ctx->pssh == GF_DASH_PSSH_MPD) {\n\t\tgf_filter_pid_set_property(ds->opid, GF_PROP_PID_CENC_PSSH, NULL);\n\t}\n\t//multi-stsd disabled, remove sdsd template (only needed at init)\n\tif (ctx->pswitch != DASHER_PSWITCH_STSD) {\n\t\tgf_filter_pid_set_property(ds->opid, GF_PROP_PID_ISOM_STSD_ALL_TEMPLATES, NULL);\n\t}\n\n\t//force PID ID\n\tgf_filter_pid_set_property(ds->opid, GF_PROP_PID_ID, &PROP_UINT(ds->pid_id) );\n\tif (ds->dep_pid_id)\n\t\tgf_filter_pid_set_property(ds->opid, GF_PROP_PID_DEPENDENCY_ID, &PROP_UINT(ds->dep_pid_id) );\n\n\tif (ctx->from_index || ctx->state)\n\t\tgf_filter_pid_set_property(ds->opid, GF_PROP_PID_DASH_SPARSE, &PROP_BOOL(GF_TRUE) );\n\n\tgf_filter_pid_set_property(ds->opid, GF_PROP_PID_MUX_SRC, &PROP_STRING(szSRC) );\n\tgf_filter_pid_set_property(ds->opid, GF_PROP_PID_DASH_MODE, &PROP_UINT(ctx->sseg ? 2 : 1) );\n\tgf_filter_pid_set_property(ds->opid, GF_PROP_PID_DASH_DUR, &PROP_FRAC(ds->dash_dur) );\n\tswitch (ctx->seg_sync) {\n\tcase DASHER_SEGSYNC_AUTO:\n\t\t//if not HLS or test mode, don't wait for seg sync\n\t\tif (!ctx->do_m3u8 || gf_sys_is_test_mode()) break;\n\t\t//fallthrough\n\tcase DASHER_SEGSYNC_YES:\n\t\tgf_filter_pid_set_property(ds->opid, GF_PROP_PID_FORCE_SEG_SYNC, &PROP_BOOL(GF_TRUE) );\n\t\tbreak;\n\tcase DASHER_SEGSYNC_NO:\n\t\tbreak;\n\t}\n\n\tif (init_trashed)\n\t\tgf_filter_pid_set_property(ds->opid, GF_PROP_PID_NO_INIT, &PROP_BOOL(GF_TRUE));\n\t//for routeout\n\tgf_filter_pid_set_property(ds->opid, GF_PROP_PID_PREMUX_STREAM_TYPE, &PROP_UINT(ds->stream_type) );\n\n\tif (ds->id != ds->pid_id) {\n\t\tdasher_update_dep_list(ctx, ds, \"isom:scal\");\n\t\tdasher_update_dep_list(ctx, ds, \"isom:sabt\");\n\t}\n\n\t/*timescale forced (bitstream switching) */\n\tif (ds->force_timescale)\n\t\tgf_filter_pid_set_property(ds->opid, GF_PROP_PID_TIMESCALE, &PROP_UINT(ds->force_timescale) );\n\n\tif (ds->rep && ds->rep->segment_template)\n\t\tgf_filter_pid_set_property(ds->opid, GF_PROP_PID_TEMPLATE, &PROP_STRING(ds->rep->segment_template->media));\n\telse if (ds->set && ds->set->segment_template)\n\t\tgf_filter_pid_set_property(ds->opid, GF_PROP_PID_TEMPLATE, &PROP_STRING(ds->set->segment_template->media));\n\n\tgf_filter_pid_set_property(ds->opid, GF_PROP_PID_BITRATE, &PROP_UINT(ds->bitrate));\n\tgf_filter_pid_set_property(ds->opid, GF_PROP_PCK_FILENAME, &PROP_STRING(ds->init_seg));\n\n\tif (ds->rep && ds->rep->codecs)\n\t\tgf_filter_pid_set_property(ds->opid, GF_PROP_PID_CODEC, &PROP_STRING(ds->rep->codecs));\n\n\n\tif (multi_pids) {\n\t\ts32 idx = 1+gf_list_find(multi_pids, ds->ipid);\n\t\tassert(idx>0);\n\t\tgf_filter_pid_set_property(ds->opid, GF_PROP_PID_DASH_MULTI_PID, &PROP_POINTER(multi_pids) );\n\t\tgf_filter_pid_set_property(ds->opid, GF_PROP_PID_DASH_MULTI_PID_IDX, &PROP_UINT(idx) );\n\t}\n\n\n\tif (ds->tile_base && !ctx->sseg && !ctx->sfile) {\n\t\tu32 i, count = gf_list_count(ds->complementary_streams);\n\t\tif (!ds->multi_tracks) ds->multi_tracks = gf_list_new();\n\t\tgf_list_reset(ds->multi_tracks);\n\n\t\t//gather all streams depending on our base\n\t\tfor (i=0; i<count; i++) {\n\t\t\tGF_DashStream *a_ds = gf_list_get(ds->complementary_streams, i);\n\t\t\tassert(a_ds->opid);\n\t\t\tgf_list_add(ds->multi_tracks, a_ds->opid);\n\t\t}\n\t\tgf_filter_pid_set_property(ds->opid, GF_PROP_PID_DASH_MULTI_TRACK, &PROP_POINTER(ds->multi_tracks) );\n\t}\n\tif (ds->dep_id && !init_trashed) {\n\t\tif (!ds->multi_tracks) ds->multi_tracks = gf_list_new();\n\t\tgf_list_reset(ds->multi_tracks);\n\t\tdasher_gather_deps(ctx, ds->dep_id, ds->multi_tracks);\n\t\tif (gf_list_count(ds->multi_tracks)) {\n\t\t\tgf_filter_pid_set_property(ds->opid, GF_PROP_PID_DASH_MULTI_TRACK, &PROP_POINTER(ds->multi_tracks) );\n\t\t} else {\n\t\t\tgf_list_del(ds->multi_tracks);\n\t\t\tds->multi_tracks = NULL;\n\t\t}\n\t}\n\n\tif (ctx->llhls) {\n\t\tgf_filter_pid_set_property(ds->opid, GF_PROP_PID_LLHLS, &PROP_UINT(ctx->llhls) );\n\t}\n\n\tif ((ctx->dmode > GF_DASH_STATIC) && (ctx->tsb>=0)) {\n\t\tu32 tsb_seg = ds->dash_dur.num ? ((u32) (ctx->tsb * ds->dash_dur.den / ds->dash_dur.num)) : 0;\n\t\ttsb_seg++;\n\t\tgf_filter_pid_set_property(ds->opid, GF_PROP_PID_TIMESHIFT_SEGS, &PROP_UINT(tsb_seg) );\n\t} else {\n\t\tgf_filter_pid_set_property(ds->opid, GF_PROP_PID_TIMESHIFT_SEGS, NULL);\n\t}\n}\n\nstatic void dasher_set_content_components(GF_DashStream *ds)\n{\n\tGF_MPD_ContentComponent *component;\n\tGF_DashStream *base_ds = ds->muxed_base ? ds->muxed_base : ds;\n\tu32 i=0;\n\twhile ((component = gf_list_enum(base_ds->set->content_component, &i))) {\n\t\tif (component->id == ds->pid_id) return;\n\t}\n\n\tGF_SAFEALLOC(component, GF_MPD_ContentComponent);\n\tif (!component) return;\n\n\tcomponent->id = ds->pid_id;\n\tswitch (ds->stream_type) {\n\tcase GF_STREAM_TEXT:\n\t\tcomponent->type = gf_strdup(\"text\");\n\t\tbreak;\n\tcase GF_STREAM_VISUAL:\n\t\tcomponent->type = gf_strdup(\"video\");\n\t\tbreak;\n\tcase GF_STREAM_AUDIO:\n\t\tcomponent->type = gf_strdup(\"audio\");\n\t\tbreak;\n\tcase GF_STREAM_SCENE:\n\tcase GF_STREAM_OD:\n\tdefault:\n\t\tcomponent->type = gf_strdup(\"application\");\n\t\tbreak;\n\t}\n\t/*if lang not specified at adaptationSet level, put it here*/\n\tif (!base_ds->set->lang && ds->lang && strcmp(ds->lang, \"und\")) {\n\t\tcomponent->lang = gf_strdup(ds->lang);\n\t}\n\tgf_list_add(base_ds->set->content_component, component);\n}\n\ntypedef struct\n{\n\t//this is not the template string, this is the resolved segment name for first segment, startNumber=0 and time=0\n\tchar *tpl;\n\tu32 nb_reused;\n} DashTemplateRecord;\n\nstatic u32 dasher_check_template_reuse(GF_DasherCtx *ctx, const char *tpl)\n{\n\tDashTemplateRecord *tr;\n\tu32 i, count = gf_list_count(ctx->tpl_records);\n\tfor (i=0; i<count; i++) {\n\t\ttr = gf_list_get(ctx->tpl_records, i);\n\t\tif (!strcmp(tr->tpl, tpl)) {\n\t\t\ttr->nb_reused++;\n\t\t\treturn tr->nb_reused;\n\t\t}\n\t}\n\tGF_SAFEALLOC(tr, DashTemplateRecord)\n\ttr->tpl = gf_strdup(tpl);\n\tgf_list_add(ctx->tpl_records, tr);\n\treturn 0;\n}\n\nstatic void dasher_setup_sources(GF_Filter *filter, GF_DasherCtx *ctx, GF_MPD_AdaptationSet *set)\n{\n\tchar szDASHTemplate[GF_MAX_PATH];\n\tchar szTemplate[GF_MAX_PATH];\n\tchar szSegmentName[GF_MAX_PATH];\n\tchar szInitSegmentTemplate[GF_MAX_PATH];\n\tchar szInitSegmentFilename[GF_MAX_PATH];\n\tchar szIndexSegmentName[GF_MAX_PATH];\n\tchar szSetFileSuffix[200], szDASHSuffix[220];\n\tconst char *template = NULL;\n\tu32 as_id = 0;\n\tBool single_template = GF_TRUE;\n\tu32 i, j, count, nb_base, nb_streams;\n\tGF_List *multi_pids = NULL;\n\tu32 set_timescale = 0;\n\tBool init_template_done=GF_FALSE;\n\tBool use_inband = ((ctx->bs_switch==DASHER_BS_SWITCH_INBAND) || (ctx->bs_switch==DASHER_BS_SWITCH_INBAND_PPS) || (ctx->bs_switch==DASHER_BS_SWITCH_BOTH)) ? GF_TRUE : GF_FALSE;\n\tBool template_use_source = GF_FALSE;\n\tBool split_rep_names = GF_FALSE;\n\tBool split_set_names = GF_FALSE;\n\tu32 force_ds_id;\n\tGF_DashStream *ds;\n\tGF_MPD_Representation *rep = gf_list_get(set->representations, 0);\n\tif (!rep) {\n\t\tassert(0);\n\t\treturn;\n\t}\n\tds = rep->playback.udta;\n\n\tcount = gf_list_count(set->representations);\n\n\tif (!ctx->sigfrag) {\n\t\tassert(ctx->template);\n\t\ttemplate = ((GF_DashStream *)set->udta)->template;\n\t}\n\n\tfor (i=0; i<count; i++) {\n\t\trep = gf_list_get(set->representations, i);\n\t\tds = rep->playback.udta;\n\t\tif (!ds->template && !template) {}\n\t\telse if (ds->template && template && !strcmp(ds->template, template) ) {\n\t\t} else {\n\t\t\tsingle_template = GF_FALSE;\n\t\t}\n\t\tif (ds->template) template_use_source = dasher_template_use_source_url(ds->template);\n\n\t\tif (template_use_source) {\n\t\t\tsingle_template = GF_FALSE;\n\t\t}\n\n\t\tif (ds->as_id && !as_id)\n\t\t\tas_id = ds->as_id;\n\n\t\tif (ds->fps.den && ( (ds->fps.num*set->max_framerate.den) >= (s32) (set->max_framerate.num*ds->fps.den) )) {\n\t\t\tset->max_framerate.num = ds->fps.num;\n\t\t\tset->max_framerate.den = ds->fps.den;\n\t\t\tgf_media_get_reduced_frame_rate(&set->max_framerate.num, &set->max_framerate.den);\n\t\t}\n\t\tif (ds->width && ds->height) {\n\t\t\tif (!set->par) {\n\t\t\t\tGF_SAFEALLOC(set->par, GF_MPD_Fractional);\n\t\t\t}\n\t\t\tif (set->par) {\n\t\t\t\tset->par->num = ds->width * ds->sar.num;\n\t\t\t\tset->par->den = ds->height * ds->sar.den;\n\t\t\t\tgf_media_reduce_aspect_ratio(&set->par->num, &set->par->den);\n\t\t\t}\n\t\t}\n\t}\n\tif (!template) template = ctx->template;\n\n\tif (as_id) {\n\t\tset->id = ds->as_id;\n\t}\n\tif (ctx->sseg) {\n\t\tset->segment_alignment = GF_TRUE;\n\t\tset->starts_with_sap = 1;\n\t}\n\n\tif (count==1)\n\t\tsingle_template = GF_TRUE;\n\telse if (single_template) {\n\t\t//for regular reps, if we depend on filename we cannot mutualize the template\n\t\tif (dasher_template_use_source_url(template) ) {\n\t\t\tsingle_template = GF_FALSE;\n\t\t}\n\t\t//and for scalable reps, if we don't have bandwidth /repID we cannot mutualize the template\n\t\telse if (gf_list_count(ds->complementary_streams) ) {\n\t\t\tif (strstr(template, \"$Bandwidth$\") != NULL) single_template = GF_FALSE;\n\t\t\telse if (strstr(template, \"$RepresentationId$\") != NULL) single_template = GF_FALSE;\n\t\t}\n\t}\n\n\tif (set->lang) gf_free(set->lang);\n\tset->lang = gf_strdup(ds->lang ? ds->lang : \"und\");\n\n\t//check all streams in active period not in this set\n\tforce_ds_id = ds->id;\n\tnb_streams = gf_list_count(ctx->current_period->streams);\n\tfor (i=0; i<nb_streams; i++) {\n\t\tchar *frag_uri;\n\t\tu32 len1, len2;\n\t\tGF_DashStream *ads = gf_list_get(ctx->current_period->streams, i);\n\n\t\tif (force_ds_id && (ads != ds) && (ads->id == ds->id)) {\n\t\t\tforce_ds_id = 0;\n\t\t}\n\n\t\tif (ads->set == set) continue;\n\t\tfrag_uri = strrchr(ds->src_url, '#');\n\t\tif (frag_uri) len1 = (u32) (frag_uri-1 - ds->src_url);\n\t\telse len1 = (u32) strlen(ds->src_url);\n\t\tfrag_uri = strrchr(ads->src_url, '#');\n\t\tif (frag_uri) len2 = (u32) (frag_uri-1 - ads->src_url);\n\t\telse len2 = (u32) strlen(ads->src_url);\n\n\t\tif ((len1==len2) && !strncmp(ds->src_url, ads->src_url, len1)) {\n\t\t\tsplit_set_names = GF_TRUE;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (ctx->timescale>0) {\n\t\tset_timescale = ctx->timescale;\n\t} else {\n\t\tu32 first_timescale;\n\t\trep = gf_list_get(set->representations, 0);\n\t\tds = rep->playback.udta;\n\t\tfirst_timescale = ds->timescale;\n\t\tfor (i=1; i<count; i++) {\n\t\t\trep = gf_list_get(set->representations, i);\n\t\t\tds = rep->playback.udta;\n\t\t\tif (ds->timescale != first_timescale) {\n\t\t\t\t//we cannot use a single template if enforcing timescales which are not identical\n\t\t\t\tsingle_template = GF_FALSE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (i=0; i<count; i++) {\n\t\tif (ctx->sigfrag)\n\t\t\tbreak;\n\n\t\trep = gf_list_get(set->representations, i);\n\t\tds = rep->playback.udta;\n\n\t\tif (!dasher_template_use_source_url(template))\n\t\t\tcontinue;\n\n\t\tif (ds->muxed_base)\n\t\t\tcontinue;\n\n\t\tfor (j=i+1; j<count; j++) {\n\t\t\tconst GF_PropertyValue *p1, *p2;\n\t\t\tGF_DashStream *a_ds;\n\t\t\trep = gf_list_get(set->representations, j);\n\t\t\ta_ds = rep->playback.udta;\n\n\t\t\tif (a_ds->muxed_base == ds)\n\t\t\t\tcontinue;\n\n\t\t\tp1 = gf_filter_pid_get_property(ds->ipid, GF_PROP_PID_FILEPATH);\n\t\t\tp2 = gf_filter_pid_get_property(a_ds->ipid, GF_PROP_PID_FILEPATH);\n\t\t\tif (p1 && p2 && gf_props_equal(p1, p2)) split_rep_names = GF_TRUE;\n\t\t\telse if (!p1 && !p2) split_rep_names = GF_TRUE;\n\t\t\tp1 = gf_filter_pid_get_property(ds->ipid, GF_PROP_PID_URL);\n\t\t\tp2 = gf_filter_pid_get_property(a_ds->ipid, GF_PROP_PID_URL);\n\t\t\tif (p1 && p2 && gf_props_equal(p1, p2)) split_rep_names = GF_TRUE;\n\t\t\telse if (!p1 && !p2) split_rep_names = GF_TRUE;\n\n\t\t\tif (split_rep_names) break;\n\t\t}\n\t\tif (split_rep_names) break;\n\t}\n\n\tif (split_set_names) {\n\t\tif (!force_ds_id) {\n\t\t\tif (split_rep_names || !ds->split_set_names)\n\t\t\t\tforce_ds_id = ds->id;\n\t\t\telse\n\t\t\t\tforce_ds_id = gf_list_find(ctx->pids, ds) + 1;\n\t\t}\n\t\tsprintf(szSetFileSuffix, \"_track%d_\", force_ds_id);\n\t}\n\n\t//assign PID IDs - we assume only one component of a given media type per adaptation set\n\t//and assign the same PID ID for each component of the same type\n\t//we could refine this using roles, but most HAS solutions don't use roles at the mulitplexed level\n\tfor (i=0; i<count; i++) {\n\t\tBool is_bs_switching;\n\t\trep = gf_list_get(set->representations, i);\n\t\tds = rep->playback.udta;\n\t\tif (ds->pid_id) continue;\n\t\t//in bitstream switching mode, ensure each track in the set has the same ID\n\t\t//except when tile merge is used\n\t\tis_bs_switching = ds->tile_dep_id_merged ? GF_FALSE : set->bitstream_switching;\n\t\tif (is_bs_switching) {\n\t\t\tctx->next_pid_id_in_period++;\n\t\t\t//except for base tile track where we force using input PID ID\n\t\t\t//to avoid messing up sabt/tbas references\n\t\t\tif (ds->tile_base) {\n\t\t\t\tds->pid_id = ds->id;\n\t\t\t\tif (ctx->next_pid_id_in_period <= ds->pid_id)\n\t\t\t\t\tctx->next_pid_id_in_period = ds->pid_id;\n\t\t\t} else {\n\t\t\t\tds->pid_id = ctx->next_pid_id_in_period;\n\t\t\t}\n\n\t\t\tfor (j=i+1; j<count; j++) {\n\t\t\t\tGF_DashStream *a_ds;\n\t\t\t\trep = gf_list_get(set->representations, j);\n\t\t\t\ta_ds = rep->playback.udta;\n\t\t\t\tif (a_ds->pid_id) continue;\n\t\t\t\tif (a_ds->dep_id) continue;\n\t\t\t\tif (a_ds->stream_type == ds->stream_type) a_ds->pid_id = ds->pid_id;\n\t\t\t}\n\t\t}\n\t\t//otherwise copy over the source PID\n\t\telse {\n\t\t\tds->pid_id = ds->id;\n\t\t}\n\t}\n\n\tfor (i=0; i<count; i++) {\n\t\trep = gf_list_get(set->representations, i);\n\t\tds = rep->playback.udta;\n\t\tif (!ds->dep_id) continue;\n\n\t\tfor (j=i+1; j<count; j++) {\n\t\t\tGF_DashStream *a_ds;\n\t\t\trep = gf_list_get(set->representations, j);\n\t\t\ta_ds = rep->playback.udta;\n\t\t\tif (ds->dep_id == a_ds->id) {\n\t\t\t\tds->dep_pid_id = a_ds->pid_id;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t//this is crude because we don't copy the properties, we just pass a list of pids to the destination muxer !!\n\t//we should cleanup one of these days\n\tif (set->bitstream_switching && (ctx->bs_switch==DASHER_BS_SWITCH_MULTI)) {\n\t\tmulti_pids = gf_list_new();\n\t\tfor (i=0; i<count; i++) {\n\t\t\trep = gf_list_get(set->representations, i);\n\t\t\tds = rep->playback.udta;\n\t\t\tif (ds->owns_set) ds->multi_pids = multi_pids;\n\t\t\tgf_list_add(multi_pids, ds->ipid);\n\t\t}\n\t}\n\n\tif (ctx->cp!=GF_DASH_CPMODE_REPRESENTATION) {\n\t\tgf_mpd_del_list(set->content_protection, gf_mpd_descriptor_free, 0);\n\t\tset->content_protection = dasher_get_content_protection_desc(ctx, NULL, set);\n\t}\n\n\tfor (i=0; i<count; i++) {\n\t\tGF_Err e;\n\t\tchar szRawExt[20];\n\t\tBool use_dash_suffix = GF_FALSE;\n\t\tBool is_source_template = GF_FALSE;\n\t\tconst char *seg_ext, *init_ext, *idx_ext, *force_init_seg_tpl;\n#if 0\n\t\tGF_MPD_URL *force_init_seg_sl;\n#endif\n\t\tu32 skip_init_type = DASH_INITSEG_PRESENT;\n\t\tGF_DashStream *tile_base_ds = NULL;\n\t\tBool is_bs_switch;\n\t\tu32 reused_template_idx;\n\t\tu32 init_template_mode = GF_DASH_TEMPLATE_INITIALIZATION_TEMPLATE;\n\t\trep = gf_list_get(set->representations, i);\n\t\tds = rep->playback.udta;\n\n\t\t//remove representations for streams muxed with others, but still open the output\n\t\tif (ds->muxed_base) {\n\t\t\tGF_DashStream *ds_set = set->udta;\n\t\t\tgf_list_rem(set->representations, i);\n\t\t\ti--;\n\t\t\tcount--;\n\t\t\tassert(ds_set->nb_rep);\n\t\t\tds_set->nb_rep--;\n\t\t\tassert(ctx->sigfrag || ds->muxed_base->dst_filter || ctx->from_index);\n\t\t\tgf_list_transfer(ds->muxed_base->rep->audio_channels, rep->audio_channels);\n\t\t\tgf_list_transfer(ds->muxed_base->rep->base_URLs, rep->base_URLs);\n\t\t\tgf_list_transfer(ds->muxed_base->rep->content_protection , rep->content_protection);\n\t\t\tgf_list_transfer(ds->muxed_base->rep->essential_properties , rep->essential_properties);\n\t\t\tgf_list_transfer(ds->muxed_base->rep->frame_packing , rep->frame_packing);\n\t\t\tif (rep->x_children) {\n\t\t\t\tif (!ds->muxed_base->rep->x_children) ds->muxed_base->rep->x_children = gf_list_new();\n\t\t\t\tgf_list_transfer(ds->muxed_base->rep->x_children, rep->x_children);\n\t\t\t}\n\t\t\tgf_list_transfer(ds->muxed_base->rep->supplemental_properties , rep->supplemental_properties);\n\n\t\t\tgf_mpd_representation_free(ds->rep);\n\t\t\tds->rep = NULL;\n\n\t\t\tif (!gf_list_count(ds->set->content_component)) {\n\t\t\t\tdasher_set_content_components(ds->muxed_base);\n\t\t\t}\n\t\t\tdasher_set_content_components(ds);\n\t\t\tassert(!multi_pids);\n\t\t\t//open PID\n\t\t\tdasher_open_pid(filter, ctx, ds, NULL, GF_FALSE);\n\t\t\tcontinue;\n\t\t}\n\t\tif (ds->template) {\n\t\t\tstrcpy(szTemplate, ds->template);\n\t\t\tif (ctx->sigfrag) {\n\t\t\t\tconst GF_PropertyValue *p = gf_filter_pid_get_property_str(ds->ipid, \"source_template\");\n\t\t\t\tif (p && p->value.boolean)\n\t\t\t\t\tis_source_template = GF_TRUE;\n\t\t\t}\n\t\t} else {\n\t\t\tstrcpy(szTemplate, ctx->template ? ctx->template : \"\");\n\t\t}\n\n\t\tif (use_inband) {\n\t\t\tds->inband_params = ctx->bs_switch==DASHER_BS_SWITCH_BOTH ? 3 : 1;\n\t\t\tif ((ds->codec_id==GF_CODECID_VVC) && (ctx->bs_switch==DASHER_BS_SWITCH_INBAND_PPS))\n\t\t\t\tds->inband_params = 2;\n\t\t}\n\n\t\t//if bitstream switching and templating, only set for the first one\n\t\tif (i && set->bitstream_switching && ds->stl && single_template) continue;\n\n\t\tif (!set_timescale) set_timescale = ds->timescale;\n\n\t\tif (ctx->timescale<0) ds->mpd_timescale = ds->timescale;\n\t\telse ds->mpd_timescale = set_timescale;\n\n\t\tif (ctx->sigfrag && gf_filter_pid_get_property_str(ds->ipid, \"source_template\")) {\n\t\t\tconst GF_PropertyValue *p = gf_filter_pid_get_property_str(ds->ipid, \"stl_timescale\");\n\t\t\tif (p && p->value.uint) {\n\t\t\t\tds->mpd_timescale = p->value.uint;\n\t\t\t}\n\t\t}\n\n\t\tif (ds->nb_repeat && !ctx->loop) {\n\t\t\tif (split_set_names) {\n\t\t\t\tsprintf(szDASHSuffix, \"%sp%d_\", szSetFileSuffix, ds->nb_repeat+1);\n\t\t\t} else {\n\t\t\t\tsprintf(szDASHSuffix, \"p%d_\", ds->nb_repeat);\n\t\t\t}\n\t\t\tuse_dash_suffix = GF_TRUE;\n\t\t} else if (split_set_names) {\n\t\t\tstrcpy(szDASHSuffix, szSetFileSuffix);\n\t\t\tuse_dash_suffix = GF_TRUE;\n\t\t}\n\t\t//we need dash suffix in template, but the template may be user-provided without dash suffix. If so add it\n\t\t//we don't add suffic if we have $RepresentationID or $Path set, we assume the user knows what he's doing\n\t\tif (!ctx->tpl_force && use_dash_suffix && !strstr(szTemplate, \"$FS$\") && !strstr(szTemplate, \"$RepresentationID$\") && !strstr(szTemplate, \"$Path=\")) {\n\t\t\tstrcat(szTemplate, \"$FS$\");\n\t\t}\n\n\t\t//resolve segment template\n\t\te = gf_filter_pid_resolve_file_template(ds->ipid, szTemplate, szDASHTemplate, 0, use_dash_suffix ? szDASHSuffix : NULL);\n\t\tif (e) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_DASH, (\"[Dasher] Cannot resolve template name %s, cannot derive output segment names, disabling rep %s\\n\", szTemplate, ds->src_url));\n\t\t\tgf_filter_pid_set_discard(ds->ipid, GF_TRUE);\n\t\t\tds->done = 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!ctx->tpl_force) {\n\t\t\tif (single_template && ds->split_set_names && !use_dash_suffix) {\n\t\t\t\tchar szStrName[20];\n\t\t\t\tsprintf(szStrName, \"_set%d\", 1 + gf_list_find(ctx->current_period->period->adaptation_sets, set)  );\n\t\t\t\tstrcat(szDASHTemplate, szStrName);\n\t\t\t}\n\t\t\telse if (split_rep_names) {\n\t\t\t\tchar szStrName[20];\n\t\t\t\tsprintf(szStrName, \"_rep%d\", 1 + gf_list_find(set->representations, ds->rep)  );\n\t\t\t\tstrcat(szDASHTemplate, szStrName);\n\t\t\t}\n\t\t}\n\n\t\tds->rawmux = GF_FALSE;\n\t\tidx_ext = NULL;\n\n\n\t\tconst char *def_ext = NULL;\n\t\tseg_ext = init_ext = NULL;\n\n\t\tif (ctx->muxtype==DASHER_MUX_TS) {\n\t\t\tdef_ext = seg_ext = init_ext = \"ts\";\n\t\t\tif (!ctx->do_m3u8 && (ctx->subs_sidx>=0) )\n\t\t\t\tidx_ext = \"idx\";\n\t\t}\n\t\telse if (ctx->muxtype==DASHER_MUX_MKV) def_ext = \"mkv\";\n\t\telse if (ctx->muxtype==DASHER_MUX_WEBM) def_ext = \"webm\";\n\t\telse if (ctx->muxtype==DASHER_MUX_OGG) def_ext = \"ogg\";\n\t\telse if (ctx->muxtype==DASHER_MUX_RAW) {\n\t\t\tchar *ext = (char *) gf_codecid_file_ext(ds->codec_id);\n\t\t\tif (ds->codec_id==GF_CODECID_RAW) {\n\t\t\t\tconst GF_PropertyValue *p;\n\t\t\t\tif (ds->stream_type==GF_STREAM_VISUAL) {\n\t\t\t\t\tp = gf_filter_pid_get_property(ds->ipid, GF_PROP_PIXFMT);\n\t\t\t\t\tif (p) ext = (char *) gf_pixel_fmt_sname(p->value.uint);\n\t\t\t\t}\n\t\t\t\telse if (ds->stream_type==GF_STREAM_AUDIO) {\n\t\t\t\t\tp = gf_filter_pid_get_property(ds->ipid, GF_PROP_PID_AUDIO_FORMAT);\n\t\t\t\t\tif (p) ext = (char *) gf_audio_fmt_sname(p->value.uint);\n\t\t\t\t}\n\t\t\t}\n\t\t\tstrncpy(szRawExt, ext ? ext : \"raw\", 19);\n\t\t\tszRawExt[19] = 0;\n\t\t\text = strchr(szRawExt, '|');\n\t\t\tif (ext) ext[0] = 0;\n\t\t\tdef_ext = szRawExt;\n\t\t}\n\n\t\tif (!ds->muxed_base && ctx->rawsub && (ds->stream_type==GF_STREAM_TEXT) ) {\n\t\t\tchar *ext_sub = (char *) gf_codecid_file_ext(ds->codec_id);\n\t\t\tif (ext_sub) {\n\t\t\t\tif (!strcmp(ext_sub, \"subx\"))\n\t\t\t\t\text_sub = \"ttml\";\n\t\t\t\tif (!strcmp(ext_sub, \"tx3g\"))\n\t\t\t\t\text_sub = \"srt\";\n\n\t\t\t\tstrncpy(szRawExt, ext_sub, 19);\n\t\t\t\tszRawExt[19] = 0;\n\t\t\t\text_sub = strchr(szRawExt, '|');\n\t\t\t\tif (ext_sub) ext_sub[0] = 0;\n\t\t\t\tdef_ext = szRawExt;\n\t\t\t\tskip_init_type = DASH_INITSEG_NONE;\n\t\t\t\tds->rawmux = GF_TRUE;\n\n\t\t\t\tif (ds->rep->mime_type) gf_free(ds->rep->mime_type);\n\t\t\t\tconst char *mime = gf_codecid_mime(ds->codec_id);\n\t\t\t\tif (!mime) mime = \"text/plain\";\n\t\t\t\tds->rep->mime_type = gf_strdup(mime);\n\n\t\t\t\tif (ds->rep->codecs) {\n\t\t\t\t\tgf_free(ds->rep->codecs);\n\t\t\t\t\tds->rep->codecs = NULL;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (ctx->segext && !stricmp(ctx->segext, \"null\")) {\n\t\t\tseg_ext = NULL;\n\t\t} else {\n\t\t\tseg_ext = ctx->segext;\n\t\t\tif (!seg_ext) seg_ext = def_ext ? def_ext : \"m4s\";\n\t\t}\n\t\tif (ctx->initext && !stricmp(ctx->initext, \"null\")) {\n\t\t\tinit_ext = NULL;\n\t\t} else {\n\t\t\tinit_ext = ctx->initext;\n\t\t\tif (!init_ext) init_ext = def_ext ? def_ext : \"mp4\";\n\t\t}\n\n\t\t//source template is used, do not use any extensions, they are present in the template\n\t\tif (is_source_template) {\n\t\t\tdef_ext = NULL;\n\t\t\tinit_ext = NULL;\n\t\t\tseg_ext = NULL;\n\t\t}\n\n\t\tis_bs_switch = set->bitstream_switching;\n\t\t//only used to force _init in default templates\n\t\tif (ds->tile_base) is_bs_switch = GF_FALSE;\n\n\n\t\t//check we are not reusing an existing template from previous periods, if so append a suffix\n\t\t//we check the final init name\n\t\tif (!ds->skip_tpl_reuse) {\n\t\t\t//1- init will not work in tiling as the base track and the first rep could end up having the same\n\t\t\t//segment template since base uses \"init\" while tile tracks don't for the init template\n\t\t\t//2- because of that, all evaluated templates must be the segment ones, otherwise we may check the audio init template\n\t\t\t//against a tile segment template, which will not match even though they use the same base template...\n\t\t\t//ex: template: seg_ => seg_trackN_init.mp4 for non-tiled vs seg_trackN_$number$.m4s for tiled, resulting in same N\n\t\t\t//being used for 2 track\n\t\t\t//cf issue 1849\n\t\t\t//we however don't want to change templates if they are indeed reused but resolve to something different due to representationID\n\t\t\t//we therefore resolve the segment template with startNumber 0 time 0, use this resolved name as base check.\n\n\t\t\tgf_media_mpd_format_segment_name(GF_DASH_TEMPLATE_SEGMENT, is_bs_switch, szInitSegmentFilename, ds->rep_id, NULL, szDASHTemplate, is_source_template ? NULL : \"mp4\", 0, ds->bitrate, 0, ds->stl, ctx->tpl_force);\n\n\t\t\treused_template_idx = dasher_check_template_reuse(ctx, szInitSegmentFilename);\n\t\t\tif (reused_template_idx) {\n\t\t\t\tchar szExName[20];\n\t\t\t\tsprintf(szExName, \"_r%d_\", reused_template_idx);\n\t\t\t\tstrcat(szDASHTemplate, szExName);\n\t\t\t\t//force template at representation level if more than one rep and templates have been reused\n\t\t\t\tif (gf_list_count(ds->set->representations)>1)\n\t\t\t\t\tsingle_template = GF_FALSE;\n\t\t\t}\n\t\t}\n\n\t\t//get final segment template with path resolution - output file name is NULL, we already have solved this\n\t\tgf_media_mpd_format_segment_name(GF_DASH_TEMPLATE_TEMPLATE_WITH_PATH, is_bs_switch, szSegmentName, ds->rep_id, NULL, szDASHTemplate, seg_ext, 0, 0, 0, ds->stl, ctx->tpl_force);\n\t\tds->seg_template = gf_strdup(szSegmentName);\n\n\t\t//get final segment template - output file name is NULL, we already have solved this\n\t\tgf_media_mpd_format_segment_name(GF_DASH_TEMPLATE_TEMPLATE, is_bs_switch, szSegmentName, ds->rep_id, NULL, szDASHTemplate, seg_ext, 0, 0, 0, ds->stl, ctx->tpl_force);\n\n\n\t\t//get index templates\n\t\tif (idx_ext) {\n\t\t\tgf_media_mpd_format_segment_name(GF_DASH_TEMPLATE_REPINDEX_TEMPLATE_WITH_PATH, is_bs_switch, szIndexSegmentName, ds->rep_id, NULL, szDASHTemplate, idx_ext, 0, 0, 0, ds->stl, ctx->tpl_force);\n\t\t\tds->idx_template = gf_strdup(szIndexSegmentName);\n\n\t\t\tgf_media_mpd_format_segment_name(GF_DASH_TEMPLATE_REPINDEX_TEMPLATE, is_bs_switch, szIndexSegmentName, ds->rep_id, NULL, szDASHTemplate, idx_ext, 0, 0, 0, ds->stl, ctx->tpl_force);\n\t\t}\n\n\t\t//get final init name - output file name is NULL, we already have solved this\n\t\tgf_media_mpd_format_segment_name(GF_DASH_TEMPLATE_INITIALIZATION, is_bs_switch, szInitSegmentFilename, ds->rep_id, NULL, szDASHTemplate, init_ext, 0, ds->bitrate, 0, ds->stl, ctx->tpl_force);\n\n\t\t//get final init template name - output file name is NULL, we already have solved this\n\t\tgf_media_mpd_format_segment_name(init_template_mode, is_bs_switch, szInitSegmentTemplate, ds->rep_id, NULL, szDASHTemplate, init_ext, 0, 0, 0, ds->stl, ctx->tpl_force);\n\n\t\tif (ctx->sigfrag) {\n\t\t\tif (ctx->template || ds->template) {\n\t\t\t\t if (is_source_template) {\n\t\t\t\t\tconst GF_PropertyValue *mpd_url = gf_filter_pid_get_property_str(ds->ipid, \"manifest_url\");\n\t\t\t\t\tstrcpy(szInitSegmentFilename, gf_file_basename(ds->src_url));\n\n\t\t\t\t\tif (ctx->out_path && mpd_url) {\n\t\t\t\t\t\tBool keep_src = GF_FALSE;\n\t\t\t\t\t\tchar *url, *mpd_out, *mpd_src_alloc=NULL;\n\t\t\t\t\t\tmpd_out = gf_file_basename(ctx->out_path);\n\t\t\t\t\t\tu32 len = (u32) (mpd_out - ctx->out_path);\n\t\t\t\t\t\tchar *mpd_src = mpd_url->value.string;\n\t\t\t\t\t\tif (ctx->keep_src) {\n\t\t\t\t\t\t\tkeep_src = GF_TRUE;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (!strncmp(ctx->out_path, mpd_url->value.string, len))\n\t\t\t\t\t\t\tmpd_src += len;\n\t\t\t\t\t\telse if (gf_url_is_relative(ctx->out_path) && gf_url_is_relative(mpd_src)) {\n\t\t\t\t\t\t\tchar *opath=NULL, *ipath=NULL;\n\t\t\t\t\t\t\tif (ctx->out_path[0]!='.') gf_dynstrcat(&opath, \"./\", NULL);\n\t\t\t\t\t\t\tgf_dynstrcat(&opath, ctx->out_path, NULL);\n\t\t\t\t\t\t\tif (mpd_src[0]!='.') gf_dynstrcat(&ipath, \"./\", NULL);\n\t\t\t\t\t\t\tgf_dynstrcat(&ipath, mpd_src, NULL);\n\n\t\t\t\t\t\t\tmpd_src_alloc = gf_url_concatenate_parent(opath, ipath);\n\t\t\t\t\t\t\tmpd_src = mpd_src_alloc;\n\t\t\t\t\t\t\tif (opath) gf_free(opath);\n\t\t\t\t\t\t\tif (ipath) gf_free(ipath);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_DASH, (\"[Dasher] Non-relative URLs used in manifest generation mode, cannot determine output locations. Source URLs will be kept\\n\"));\n\t\t\t\t\t\t\tkeep_src = GF_TRUE;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (mpd_src && !strncmp(mpd_src, \"./\", 2)) mpd_src+=2;\n\n\t\t\t\t\t\tchar *init_url=NULL;\n\t\t\t\t\t\tconst GF_PropertyValue *p = gf_filter_pid_get_property_str(ds->ipid, \"init_url\");\n\t\t\t\t\t\tconst GF_PropertyValue *hls_variant = gf_filter_pid_get_property_str(ds->ipid, \"hls_variant_name\");\n\t\t\t\t\t\tif (p) {\n\t\t\t\t\t\t\tif (hls_variant) {\n\t\t\t\t\t\t\t\tinit_url = gf_url_concatenate(hls_variant->value.string, p->value.string);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tinit_url = gf_strdup(p->value.string);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (keep_src) {\n\t\t\t\t\t\t\tstrcpy(szInitSegmentFilename, init_url);\n\t\t\t\t\t\t\tstrcpy(szInitSegmentTemplate, init_url);\n\t\t\t\t\t\t\tstrcpy(szSegmentName, ds->template);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (init_url) {\n\t\t\t\t\t\t\t\turl = gf_url_concatenate(mpd_src, init_url);\n\t\t\t\t\t\t\t\tstrcpy(szInitSegmentFilename, url);\n\t\t\t\t\t\t\t\tstrcpy(szInitSegmentTemplate, url);\n\t\t\t\t\t\t\t\tgf_free(url);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t//no init segment URL\n\t\t\t\t\t\t\t\tstrcpy(szInitSegmentFilename, \"\");\n\t\t\t\t\t\t\t\tstrcpy(szInitSegmentTemplate, \"\");\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (hls_variant) {\n\t\t\t\t\t\t\t\tchar *tpl_int = gf_url_concatenate(hls_variant->value.string, ds->template);\n\t\t\t\t\t\t\t\turl = gf_url_concatenate(mpd_src, tpl_int);\n\t\t\t\t\t\t\t\tgf_free(tpl_int);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\turl = gf_url_concatenate(mpd_src, ds->template);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tstrcpy(szSegmentName, url);\n\t\t\t\t\t\t\tgf_free(url);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (init_url) gf_free(init_url);\n\t\t\t\t\t\tif (mpd_src_alloc) gf_free(mpd_src_alloc);\n\t\t\t\t\t}\n\t\t\t\t }\n\t\t\t} else {\n\t\t\t\tstrcpy(szInitSegmentFilename, gf_file_basename(ds->src_url));\n\t\t\t\tstrcpy(szSegmentName, gf_file_basename(ds->src_url));\n\t\t\t}\n\t\t}\n\n\t\tif (ctx->store_seg_states) {\n\t\t\tassert(!ds->pending_segment_states);\n\t\t\tds->pending_segment_states = gf_list_new();\n\t\t}\n\t\t/* baseURLs */\n\t\tnb_base = ds->p_base_url ? ds->p_base_url->value.string_list.nb_items : 0;\n\t\tfor (j=0; j<nb_base; j++) {\n\t\t\tGF_MPD_BaseURL *base_url;\n\t\t\tchar *url = ds->p_base_url->value.string_list.vals[j];\n\t\t\tGF_SAFEALLOC(base_url, GF_MPD_BaseURL);\n\t\t\tif (base_url) {\n\t\t\t\tbase_url->URL = gf_strdup(url);\n\t\t\t\tgf_list_add(rep->base_URLs, base_url);\n\t\t\t}\n\t\t}\n\n\t\tforce_init_seg_tpl = NULL;\n#if 0\n\t\tforce_init_seg_sl = NULL;\n#endif\n\t\tif (ds->codec_id==GF_CODECID_HEVC_TILES) {\n\t\t\ttile_base_ds = get_base_ds(ctx, ds);\n\t\t\tskip_init_type = DASH_INITSEG_SKIP;\n\t\t\tif (tile_base_ds->rep->segment_template) force_init_seg_tpl = tile_base_ds->rep->segment_template->initialization;\n\t\t\tif (!force_init_seg_tpl && tile_base_ds->set->segment_template) force_init_seg_tpl = tile_base_ds->set->segment_template->initialization;\n\n#if 0\n\t\t\tif (tile_base_ds->rep->segment_list) force_init_seg_sl = tile_base_ds->rep->segment_list->initialization_segment;\n\t\t\tif (!force_init_seg_sl && tile_base_ds->set->segment_list) force_init_seg_sl = tile_base_ds->set->segment_list->initialization_segment;\n#endif\n\t\t}\n\t\tif (ctx->muxtype==DASHER_MUX_RAW) skip_init_type = DASH_INITSEG_NONE;\n\t\telse if (ctx->muxtype==DASHER_MUX_TS) skip_init_type = DASH_INITSEG_NONE;\n\t\telse if (ctx->muxtype==DASHER_MUX_OGG) skip_init_type = DASH_INITSEG_NONE;\n\n\n\t\t//forward mode, change segment names\n\t\tif (ctx->forward_mode) {\n\t\t\tu32 k, nb_pids = gf_list_count(ctx->pids);\n\t\t\tchar *src = NULL;\n\t\t\tconst GF_PropertyValue *p = gf_filter_pid_get_property(ds->ipid, GF_PROP_PCK_FILENAME);\n\n\t\t\tif (!p || !p->value.string) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_DASH, (\"[Dasher] Couldn't fetch source URL in forward mode, cannot forward\\n\"));\n\t\t\t\tctx->in_error = GF_TRUE;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tsrc = p->value.string;\n\n\t\t\tfor (k=0; k<nb_pids; k++) {\n\t\t\t\tGF_DashStream *a_ds = gf_list_get(ctx->pids, k);\n\t\t\t\tif (ds == a_ds) continue;\n\t\t\t\tif (!a_ds->dst_filter) continue;\n\n\t\t\t\tp = gf_filter_pid_get_property(a_ds->ipid, GF_PROP_PCK_FILENAME);\n\t\t\t\tif (!p || !p->value.string) {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_DASH, (\"[Dasher] Couldn't fetch source URL in forward mode, cannot forward\\n\"));\n\t\t\t\t\tctx->in_error = GF_TRUE;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t//same init segment used (bs switching)\n\t\t\t\tif (!strcmp(p->value.string, src))\n\t\t\t\t\tskip_init_type = DASH_INITSEG_SKIP;\n\t\t\t}\n\t\t\tstrcpy(szInitSegmentFilename, src);\n\t\t\tstrcpy(szInitSegmentTemplate, src);\n\n\t\t\tif (ctx->tpl) {\n\t\t\t\tp = gf_filter_pid_get_property(ds->ipid, GF_PROP_PID_TEMPLATE);\n\t\t\t\tif (!p || !p->value.string) {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_DASH, (\"[Dasher] Couldn't fetch source template in forward mode, cannot forward\\n\"));\n\t\t\t\t\tctx->in_error = GF_TRUE;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tstrcpy(szSegmentName, p->value.string);\n\t\t\t}\n\t\t}\n\n\t\tds->init_seg = gf_strdup(szInitSegmentFilename);\n\n\t\t//we use segment template\n\t\tif (ctx->tpl) {\n\t\t\tBool use_single_init, force_init_template=GF_FALSE;\n\t\t\tGF_MPD_SegmentTemplate *seg_template;\n\t\t\tu32 start_number = ds->startNumber ? ds->startNumber : 1;\n\t\t\tu64 seg_duration = (u64)(ds->dash_dur.num) * ds->mpd_timescale / ds->dash_dur.den;\n\n\t\t\tif (ds->inband_params && (ctx->bs_switch==DASHER_BS_SWITCH_INBAND_PPS)) {\n\t\t\t\tuse_single_init = GF_FALSE;\n\t\t\t\tsingle_template = GF_FALSE;\n\t\t\t} else {\n\t\t\t\tuse_single_init = (set->bitstream_switching || single_template) ? GF_TRUE : GF_FALSE;\n\t\t\t\tif (is_bs_switch && ctx->force_init) {\n\t\t\t\t\tuse_single_init = GF_FALSE;\n\t\t\t\t\tsingle_template = GF_FALSE;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//first rep in set and bs switching or single template, create segment template at set level\n\t\t\tif (!i && use_single_init ) {\n\t\t\t\tinit_template_done = GF_TRUE;\n\t\t\t\tseg_template = NULL;\n\t\t\t\tif (!skip_init_type || force_init_seg_tpl || single_template) {\n\t\t\t\t\tGF_SAFEALLOC(seg_template, GF_MPD_SegmentTemplate);\n\t\t\t\t\tif (seg_template) {\n\t\t\t\t\t\tif (skip_init_type) {\n\t\t\t\t\t\t\tseg_template->initialization = force_init_seg_tpl ? gf_strdup(force_init_seg_tpl) : NULL;\n\t\t\t\t\t\t\tseg_template->hls_init_name = force_init_seg_tpl ? tile_base_ds->init_seg : NULL;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t//bs switching, if we have still template fields init segment template use resolved init file name - cf #2141\n\t\t\t\t\t\t\tif (!force_init_template && is_bs_switch && strchr(szInitSegmentTemplate, '$'))\n\t\t\t\t\t\t\t\tseg_template->initialization = gf_strdup(szInitSegmentFilename);\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tseg_template->initialization = gf_strdup(szInitSegmentTemplate);\n\t\t\t\t\t\t\tseg_template->hls_init_name = ds->init_seg;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tset->segment_template = seg_template;\n\n\t\t\t\tdasher_open_destination(filter, ctx, rep, szInitSegmentFilename, skip_init_type);\n\n\t\t\t\tif (single_template) {\n\t\t\t\t\tseg_template->media = gf_strdup(szSegmentName);\n\t\t\t\t\tif (ds->idx_template)\n\t\t\t\t\t\tseg_template->index = gf_strdup(szIndexSegmentName);\n\n\t\t\t\t\tseg_template->timescale = ds->mpd_timescale;\n\t\t\t\t\tseg_template->start_number = start_number;\n\t\t\t\t\tseg_template->duration = seg_duration;\n\n\t\t\t\t\tif (ctx->asto>0) {\n\t\t\t\t\t\tseg_template->availability_time_offset = ctx->asto;\n\t\t\t\t\t}\n\t\t\t\t} else if (seg_template) {\n\t\t\t\t\tseg_template->start_number = (u32)-1;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//non-first rep in set and single template, only open destination\n\t\t\tif (i && single_template) {\n\t\t\t\tdasher_open_destination(filter, ctx, rep, szInitSegmentFilename,\n\t\t\t\t\t(skip_init_type==DASH_INITSEG_NONE) ? DASH_INITSEG_NONE : (set->bitstream_switching ? DASH_INITSEG_SKIP : DASH_INITSEG_PRESENT));\n\t\t\t}\n\t\t\t//first rep in set and no bs switching or mutliple templates, create segment template at rep level\n\t\t\telse if (i || !single_template) {\n\t\t\t\tGF_SAFEALLOC(seg_template, GF_MPD_SegmentTemplate);\n\t\t\t\tif (seg_template) {\n\t\t\t\t\trep->segment_template = seg_template;\n\t\t\t\t\tif (!init_template_done) {\n\t\t\t\t\t\tif (skip_init_type) {\n\t\t\t\t\t\t\tseg_template->initialization = force_init_seg_tpl ? gf_strdup(force_init_seg_tpl) : NULL;\n\t\t\t\t\t\t\tseg_template->hls_init_name = force_init_seg_tpl ? tile_base_ds->init_seg : NULL;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tseg_template->initialization = gf_strdup(szInitSegmentTemplate);\n\t\t\t\t\t\t\tseg_template->hls_init_name = ds->init_seg;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdasher_open_destination(filter, ctx, rep, szInitSegmentFilename, skip_init_type);\n\t\t\t\t\t} else if (i) {\n\t\t\t\t\t\tdasher_open_destination(filter, ctx, rep, szInitSegmentFilename,\n\t\t\t\t\t\t\t(skip_init_type==DASH_INITSEG_NONE) ? DASH_INITSEG_NONE : (set->bitstream_switching ? DASH_INITSEG_SKIP : DASH_INITSEG_PRESENT) );\n\t\t\t\t\t}\n\t\t\t\t\tseg_template->media = gf_strdup(szSegmentName);\n\t\t\t\t\tif (ds->idx_template)\n\t\t\t\t\t\tseg_template->index = gf_strdup(szIndexSegmentName);\n\t\t\t\t\tseg_template->duration = seg_duration;\n\t\t\t\t\tseg_template->timescale = ds->mpd_timescale;\n\t\t\t\t\tseg_template->start_number = start_number;\n\t\t\t\t\tif (ctx->asto > 0) {\n\t\t\t\t\t\tseg_template->availability_time_offset = ctx->asto;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*we are using a single file or segment, use base url*/\n\t\telse if (ctx->sseg || ctx->sfile) {\n\t\t\tGF_MPD_BaseURL *baseURL;\n\n\t\t\tif (ds->init_seg) gf_free(ds->init_seg);\n\t\t\tds->init_seg = gf_strdup(szInitSegmentFilename);\n\n\t\t\tGF_SAFEALLOC(baseURL, GF_MPD_BaseURL);\n\t\t\tif (!baseURL) continue;\n\n\t\t\tif (!rep->base_URLs) rep->base_URLs = gf_list_new();\n\t\t\tgf_list_add(rep->base_URLs, baseURL);\n\n\t\t\tif (ctx->sseg) {\n\t\t\t\tGF_MPD_SegmentBase *segment_base;\n\t\t\t\tbaseURL->URL = gf_strdup(szInitSegmentFilename);\n\t\t\t\tGF_SAFEALLOC(segment_base, GF_MPD_SegmentBase);\n\t\t\t\tif (!segment_base) continue;\n\t\t\t\trep->segment_base = segment_base;\n\t\t\t\tdasher_open_destination(filter, ctx, rep, szInitSegmentFilename, 0);\n\t\t\t} else {\n\t\t\t\tGF_MPD_SegmentList *seg_list;\n\t\t\t\tGF_SAFEALLOC(seg_list, GF_MPD_SegmentList);\n\t\t\t\tif (!seg_list) continue;\n\t\t\t\tGF_SAFEALLOC(seg_list->initialization_segment, GF_MPD_URL);\n\t\t\t\tif (!seg_list->initialization_segment) continue;\n\t\t\t\tseg_list->start_number = (u32) -1;\n\t\t\t\tbaseURL->URL = gf_strdup(szInitSegmentFilename);\n\t\t\t\tseg_list->dasher_segment_name = gf_strdup(szSegmentName);\n\t\t\t\tseg_list->timescale = ds->mpd_timescale;\n\t\t\t\tseg_list->duration = (u64) (ds->dash_dur.num) * ds->mpd_timescale / ds->dash_dur.den;\n\t\t\t\tseg_list->segment_URLs = gf_list_new();\n\t\t\t\trep->segment_list = seg_list;\n\t\t\t\tds->pending_segment_urls = gf_list_new();\n\n\t\t\t\tdasher_open_destination(filter, ctx, rep, szInitSegmentFilename, skip_init_type);\n\t\t\t}\n\t\t}\n\t\t//no template, no single file, we need a file list\n\t\telse {\n\t\t\tGF_MPD_SegmentList *seg_list;\n\t\t\tGF_SAFEALLOC(seg_list, GF_MPD_SegmentList);\n\t\t\tif (!seg_list) continue;\n\n\t\t\tif (!skip_init_type) {\n\t\t\t\tGF_SAFEALLOC(seg_list->initialization_segment, GF_MPD_URL);\n\t\t\t\tif (!seg_list->initialization_segment) continue;\n\n\t\t\t\tseg_list->initialization_segment->sourceURL = gf_strdup(szInitSegmentFilename);\n\t\t\t}\n\t\t\tseg_list->dasher_segment_name = gf_strdup(szSegmentName);\n\t\t\tseg_list->timescale = ds->mpd_timescale;\n\t\t\tseg_list->segment_URLs = gf_list_new();\n\t\t\tseg_list->start_number = (u32) -1;\n\t\t\tseg_list->duration = (u64) (ds->dash_dur.num) * ds->mpd_timescale / ds->dash_dur.den;\n\t\t\trep->segment_list = seg_list;\n\t\t\tds->pending_segment_urls = gf_list_new();\n\n\t\t\tdasher_open_destination(filter, ctx, rep, szInitSegmentFilename, skip_init_type);\n\t\t}\n\n\t\t//open PID\n\t\tdasher_open_pid(filter, ctx, ds, multi_pids, skip_init_type ? GF_TRUE : GF_FALSE);\n\t}\n}\n\nstatic void dasher_purge_segment_timeline(GF_DashStream *ds, GF_MPD_SegmentTimeline *stl, GF_DASH_SegmentContext *sctx)\n{\n\tGF_MPD_SegmentTimelineEntry *stl_e = gf_list_get(stl->entries, 0);\n\tif (!stl_e) return;\n\n\tif (stl_e->repeat_count) {\n\t\tstl_e->repeat_count--;\n\t\tstl_e->start_time += stl_e->duration;\n\t} else {\n\t\tu64 start_time = stl_e->start_time + stl_e->duration;\n\t\tgf_list_rem(stl->entries, 0);\n\t\tgf_free(stl_e);\n\t\tstl_e = gf_list_get(stl->entries, 0);\n\t\tif (!stl_e) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_DASH, (\"[Dasher] No timeline entry after currently removed segment, cannot update start time\\n\" ));\n\t\t\treturn;\n\t\t}\n\n\t\tif (!stl_e->start_time) stl_e->start_time = start_time;\n\t\telse if (stl_e->start_time != start_time) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_DASH, (\"[Dasher] Mismatch in segment timeline while purging, new start time \"LLU\" but entry indicates \"LLU\", keeping original one\\n\", start_time, stl_e->start_time ));\n\t\t}\n\t}\n}\n\nstatic void dasher_purge_segments(GF_DasherCtx *ctx, u64 *period_dur)\n{\n\tDouble min_valid_mpd_time;\n\tu64 max_rem_dur = 0;\n\tu32 i, count;\n\n\t//non-static mode, purge segments\n\tif (ctx->dmode == GF_MPD_TYPE_STATIC) return;\n\tif (ctx->tsb<0) return;\n\n\n\tmin_valid_mpd_time = (Double) *period_dur;\n\tmin_valid_mpd_time /= 1000;\n\tmin_valid_mpd_time -= ctx->tsb;\n\t//negative asto, we produce segments earlier but we don't want to delete them before the asto\n\tif (ctx->asto<0) {\n\t\tmin_valid_mpd_time += ctx->asto;\n\t}\n\tif (min_valid_mpd_time<=0) return;\n\n\tcount = gf_list_count(ctx->current_period->streams);\n\tfor (i=0; i<count; i++) {\n\t\tGF_DashStream *ds = gf_list_get(ctx->current_period->streams, i);\n\t\tif (ds->muxed_base) continue;\n\t\tif (!ds->rep) continue;\n\t\tif (!ds->rep->state_seg_list) continue;\n\n\t\twhile (1) {\n\t\t\tDouble time, dur;\n\t\t\tBool seg_url_found = GF_FALSE;\n\t\t\tBool has_seg_list = GF_FALSE;\n\t\t\tGF_DASH_SegmentContext *sctx = gf_list_get(ds->rep->state_seg_list, 0);\n\t\t\tif (!sctx) break;\n\t\t\t/*not yet flushed*/\n\t\t\tif (gf_list_find(ds->pending_segment_states, sctx)>=0) break;\n\t\t\ttime = (Double) sctx->time;\n\t\t\ttime /= ds->mpd_timescale;\n\t\t\tdur = (Double) sctx->dur;\n\t\t\tdur/= ds->timescale;\n\t\t\tif (time + dur >= min_valid_mpd_time) break;\n\t\t\tif (sctx->filepath) {\n\t\t\t\tGF_FilterEvent evt;\n\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_DASH, (\"[Dasher] removing segment %s\\n\", sctx->filename ? sctx->filename : sctx->filepath));\n\n\t\t\t\tGF_FEVT_INIT(evt, GF_FEVT_FILE_DELETE, ds->opid);\n\t\t\t\tevt.file_del.url = sctx->filepath;\n\t\t\t\tgf_filter_pid_send_event(ds->opid, &evt);\n\t\t\t\tgf_free(sctx->filepath);\n\t\t\t}\n\n\t\t\tif (ds->rep->segment_list) {\n\t\t\t\tGF_MPD_SegmentURL *surl = gf_list_pop_front(ds->rep->segment_list->segment_URLs);\n\t\t\t\thas_seg_list = GF_TRUE;\n\t\t\t\t//can be NULL if we mutualize everything at AdaptatioSet level\n\t\t\t\tif (surl) {\n\t\t\t\t\tgf_mpd_segment_url_free(surl);\n\t\t\t\t\tseg_url_found = GF_TRUE;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//not an else due to inheritance\n\t\t\tif (ds->owns_set && ds->set->segment_list) {\n\t\t\t\tGF_MPD_SegmentURL *surl = gf_list_pop_front(ds->set->segment_list->segment_URLs);\n\t\t\t\thas_seg_list = GF_TRUE;\n\t\t\t\t//can be NULL if we don't mutualize at AdaptatioSet level\n\t\t\t\tif (surl) {\n\t\t\t\t\tgf_mpd_segment_url_free(surl);\n\t\t\t\t\tseg_url_found = GF_TRUE;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//but we must have at least one segment URL entry\n\t\t\tif (has_seg_list && !seg_url_found) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_DASH, (\"[Dasher] purging segment %s for AS %d rep %s but segment list is empty!\\n\",\n\t\t\t\t\t\tsctx->filename ? sctx->filename : \"\", ds->set->id, ds->rep->id));\n\t\t\t}\n\n\t\t\tif (ds->rep->segment_template) {\n\t\t\t\tif (ds->rep->segment_template->segment_timeline) {\n\t\t\t\t\tdasher_purge_segment_timeline(ds, ds->rep->segment_template->segment_timeline, sctx);\n\t\t\t\t}\n\t\t\t}\n\t\t\t//not an else due to inheritance\n\t\t\tif (ds->owns_set && ds->set->segment_template) {\n\t\t\t\tif (ds->set->segment_template->segment_timeline) {\n\t\t\t\t\tdasher_purge_segment_timeline(ds, ds->set->segment_template->segment_timeline, sctx);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tds->nb_segments_purged ++;\n\t\t\tds->dur_purged += dur;\n\t\t\tassert(gf_list_find(ds->pending_segment_states, sctx)<0);\n\t\t\tif (sctx->filename) gf_free(sctx->filename);\n\t\t\tif (sctx->hls_key_uri) gf_free(sctx->hls_key_uri);\n\t\t\tgf_free(sctx);\n\t\t\tgf_list_rem(ds->rep->state_seg_list, 0);\n\t\t}\n\t\tif (max_rem_dur < ds->dur_purged*1000) max_rem_dur = (u64) (ds->dur_purged * 1000);\n\t\t//final flush to static of live session: update start number\n\t\tif (ctx->dmode!=GF_MPD_TYPE_DYNAMIC) {\n\t\t\tif (ds->owns_set && ds->set && ds->set->segment_template) {\n\t\t\t\tds->set->segment_template->start_number += ds->nb_segments_purged;\n\t\t\t} else if (ds->rep && ds->rep->segment_template) {\n\t\t\t\tds->rep->segment_template->start_number += ds->nb_segments_purged;\n\t\t\t}\n\t\t\tds->nb_segments_purged = 0;\n\t\t}\n\t}\n\t//final flush to static of live session: update period duration\n\tif (ctx->dmode!=GF_MPD_TYPE_DYNAMIC) {\n\t\tif (max_rem_dur > *period_dur) *period_dur = 0;\n\t\telse *period_dur = *period_dur - max_rem_dur;\n\t}\n}\n\nstatic void dasher_update_period_duration(GF_DasherCtx *ctx, Bool is_period_switch)\n{\n\tu32 i, count;\n\tu64 pdur = 0;\n\tu64 min_dur = 0;\n\tu64 p_start=0;\n\tGF_MPD_Period *prev_p = NULL;\n\tcount = gf_list_count(ctx->current_period->streams);\n\tfor (i=0; i<count; i++) {\n\t\tGF_DashStream *ds = gf_list_get(ctx->current_period->streams, i);\n\t\tif (ds->muxed_base) continue;\n\n\t\tif (ds->xlink && (ds->stream_type==GF_STREAM_FILE) ) {\n\t\t\tpdur = (u32) (1000*(s64)ds->period_dur.num / ds->period_dur.den);\n\t\t} else {\n\t\t\tu64 ds_dur = ds->max_period_dur;\n\n\t\t\t//we had to generate one extra segment to unlock looping, but we don't want to advertise it in the manifest duration\n\t\t\t//because other sets may not be ready for this time interval\n\t\t\tif (ds->subdur_forced_use_period_dur)\n\t\t\t\tds_dur = ds->subdur_forced_use_period_dur;\n\n\t\t\tif (ds->clamped_dur.num && !ctx->loop) {\n\t\t\t\tu64 clamp_dur = (u64) (ds->clamped_dur.num * 1000);\n\t\t\t\tif (clamp_dur < ds->clamped_dur.den * ds_dur) ds_dur = clamp_dur / ds->clamped_dur.den;\n\t\t\t}\n\n\t\t\tif (ds->dur_purged && (ctx->mpd->type != GF_MPD_TYPE_DYNAMIC)) {\n\t\t\t\tu64 rem_dur = (u64) (ds->dur_purged * 1000);\n\t\t\t\tif (ds_dur>rem_dur) ds_dur -= rem_dur;\n\t\t\t\telse ds_dur = 0;\n\t\t\t}\n\n\t\t\tif (!min_dur || (min_dur > ds_dur)) min_dur = ds->max_period_dur;\n\t\t\tif (pdur < ds_dur) pdur = ds_dur;\n\t\t}\n\t}\n\n\tif (!count) {\n\t\tif (ctx->current_period->period && ctx->current_period->period->duration)\n\t\t\tpdur = ctx->current_period->period->duration;\n\t}\n\n\tif (!ctx->check_dur) {\n\t\ts32 diff = (s32) ((s64) pdur - (s64) min_dur);\n\t\tif (ABS(diff)>2000) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_DASH, (\"[Dasher] Adaptation sets in period are of unequal duration min %g max %g seconds\\n\", ((Double)min_dur)/1000, ((Double)pdur)/1000));\n\t\t}\n\t}\n\n\tdasher_purge_segments(ctx, &pdur);\n\n\tif (ctx->current_period->period && !ctx->index_media_duration) {\n\t\tctx->current_period->period->duration = pdur;\n\n\t\t//update MPD duration in any case\n\t\tif (ctx->current_period->period->start) {\n\t\t\tctx->mpd->media_presentation_duration = ctx->current_period->period->start + pdur;\n\t\t} else {\n\t\t\tu32 k, pcount = gf_list_count(ctx->mpd->periods);\n\t\t\tctx->mpd->media_presentation_duration = 0;\n\t\t\tfor (k=0; k<pcount; k++) {\n\t\t\t\tGF_MPD_Period *p = gf_list_get(ctx->mpd->periods, k);\n\t\t\t\tif (p->start)\n\t\t\t\t\tctx->mpd->media_presentation_duration = p->start + p->duration;\n\t\t\t\telse\n\t\t\t\t\tctx->mpd->media_presentation_duration += p->duration;\n\t\t\t\tif (p==ctx->current_period->period)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (ctx->refresh<0)\n\t\tctx->mpd->media_presentation_duration = (u32) ( (-ctx->refresh) * 1000 );\n\n\t//static mode, done\n\tif (ctx->dmode != GF_MPD_TYPE_DYNAMIC) {\n\t\treturn;\n\t}\n\tassert(ctx->current_period->period);\n\t//dynamic mode only, reset durations\n\n\tctx->mpd->gpac_mpd_time = ctx->mpd->media_presentation_duration;\n\n\t//not done yet for this period, keep duration to 0\n\tif (ctx->subdur_done) {\n\t\tif (ctx->mpd->media_presentation_duration > ctx->current_period->period->duration)\n\t\t\tctx->mpd->media_presentation_duration -= ctx->current_period->period->duration;\n\t\telse\n\t\t\tctx->mpd->media_presentation_duration = 0;\n\t\tctx->current_period->period->duration = 0;\n\t}\n\n\tctx->mpd->gpac_next_ntp_ms = ctx->mpd->gpac_init_ntp_ms + ctx->mpd->gpac_mpd_time;\n\tif (ctx->asto<0)\n\t\tctx->mpd->gpac_next_ntp_ms -= (u64) (-ctx->asto * 1000);\n\tif (ctx->_p_gentime) (*ctx->_p_gentime) = ctx->mpd->gpac_next_ntp_ms;\n\tif (ctx->_p_mpdtime) (*ctx->_p_mpdtime) = ctx->mpd->gpac_mpd_time;\n\n\tGF_LOG(GF_LOG_INFO, GF_LOG_DASH, (\"[Dasher] updated period %s duration \"LLU\" MPD time \"LLU\"\\n\", ctx->current_period->period->ID, pdur, ctx->mpd->gpac_mpd_time ));\n\n\tcount = gf_list_count(ctx->mpd->periods);\n\tfor (i=0; i<count; i++) {\n\t\tGF_MPD_Period *p = gf_list_get(ctx->mpd->periods, i);\n\t\tif (p->start) {\n\t\t\tp_start = p->start;\n\t\t} else {\n\t\t\tp->start = p_start;\n\t\t}\n\t\tif (prev_p && (prev_p->start + prev_p->duration == p_start)) {\n\t\t\tprev_p->duration = 0;\n\t\t}\n\t\tp_start += p->duration;\n\t\tprev_p = p;\n\t}\n}\n\nstatic void dasher_transfer_file(FILE *f, GF_FilterPid *opid, const char *name, GF_DashStream *ds)\n{\n\tGF_FilterPacket *pck;\n\tu32 size, nb_read;\n\tu8 *output;\n\n\tsize = (u32) gf_fsize(f);\n\n\tpck = gf_filter_pck_new_alloc(opid, size, &output);\n\tif (!pck) return;\n\n\tnb_read = (u32) gf_fread(output, size, f);\n\tif (nb_read != size) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_DASH, (\"[Dasher] Error reading temp MPD file, read %d bytes but file size is %d\\n\", nb_read, size ));\n\t}\n\n\tgf_filter_pck_set_framing(pck, GF_TRUE, GF_TRUE);\n\tgf_filter_pck_set_seek_flag(pck, GF_TRUE);\n\tif (name) {\n\t\tgf_filter_pck_set_property(pck, GF_PROP_PCK_FILENAME, &PROP_STRING(name) );\n\t}\n\tif (ds) {\n\t\tgf_filter_pck_set_property(pck, GF_PROP_PCK_HLS_REF, &PROP_LONGUINT( ds->hls_ref_id ) );\n\t}\n\tgf_filter_pck_send(pck);\n}\n\n\nstatic u64 dasher_get_utc(GF_DasherCtx *ctx)\n{\n\treturn gf_net_get_utc() - ctx->utc_diff;\n}\n\nstatic void dasher_get_set_and_rep(GF_MPD_Period *period, const char *repid, GF_MPD_AdaptationSet **out_set, GF_MPD_Representation **out_rep)\n{\n\tu32 i, nb_sets = gf_list_count(period->adaptation_sets);\n\tfor (i=0; i<nb_sets; i++) {\n\t\tu32 j, nb_reps;\n\t\tGF_MPD_AdaptationSet *set = gf_list_get(period->adaptation_sets, i);\n\t\tnb_reps = gf_list_count(set->representations);\n\t\tfor (j=0; j<nb_reps; j++) {\n\t\t\tGF_MPD_Representation *rep = gf_list_get(set->representations, j);\n\t\t\tif (rep->id && !strcmp(rep->id, repid)) {\n\t\t\t\t*out_set = set;\n\t\t\t\t*out_rep = rep;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic Bool dasher_merge_rep(GF_DashStream *ds, GF_MPD_Representation *rep)\n{\n\tBool transcode_detected = GF_FALSE;\n\tBool recompute_set = GF_FALSE;\n\tGF_MPD_Representation *n_rep = ds->rep;\n\n\t//TODO: copy other properties in case we transcode ?\n\n#define CHECK_VAL(_name, _v) if (rep->_name != n_rep->_name) { rep->_name = n_rep->_name; transcode_detected = GF_TRUE; if (_v) recompute_set = GF_TRUE; }\n\n#define CHECK_STR(_name) if (rep->_name && n_rep->_name && !strcmp(rep->_name, n_rep->_name)) {} \\\n\telse if (!rep->_name && !n_rep->_name) {}\\\n\telse { \\\n\t\tif (rep->_name) gf_free(rep->_name); \\\n\t\trep->_name = n_rep->_name ? gf_strdup(n_rep->_name) : NULL; \\\n\t\ttranscode_detected = GF_TRUE; \\\n\t}\n\n//for frac, if not set on source PID, consider it unchanged\n#define CHECK_FRAC(_name) if (rep->_name && n_rep->_name && (rep->_name->num * n_rep->_name->den == rep->_name->den * n_rep->_name->num)) {} \\\n\telse if (!n_rep->_name) {}\\\n\telse { \\\n\t\tif (rep->_name) gf_free(rep->_name); \\\n\t\tif (n_rep->_name) { rep->_name = gf_malloc(sizeof(GF_MPD_Fractional)); memcpy(rep->_name, n_rep->_name, sizeof(GF_MPD_Fractional)); } \\\n\t\telse rep->_name = NULL; \\\n\t\ttranscode_detected = GF_TRUE; \\\n\t}\n\n\tCHECK_STR(codecs)\n\tCHECK_STR(profiles)\n\tCHECK_STR(mime_type)\n\tCHECK_STR(segmentProfiles)\n\tCHECK_VAL(width, 1)\n\tCHECK_VAL(height, 1)\n\tCHECK_VAL(bandwidth, 0)\n\tCHECK_VAL(samplerate, 0)\n\tCHECK_VAL(scan_type, 0)\n\tCHECK_FRAC(sar)\n\tCHECK_FRAC(framerate)\n\n\tif (transcode_detected && !ds->transcode_detected) {\n\t\tds->transcode_detected = GF_TRUE;\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_DASH, (\"[Dasher] Transcoded detected in forward mode, not fully tested !\\n\"));\n\t}\n#undef CHECK_VAL\n#undef CHECK_STR\n#undef CHECK_FRAC\n\n\treturn recompute_set;\n}\nstatic void dasher_forward_manifest_raw(GF_DasherCtx *ctx, GF_DashStream *ds, const char *manifest, const char *manifest_name)\n{\n\tGF_FilterPacket *pck;\n\tu32 size;\n\tu8 *output;\n\n\tsize = (u32) strlen(manifest);\n\n\tpck = gf_filter_pck_new_alloc(ctx->opid, size+1, &output);\n\tif (!pck) return;\n\n\tmemcpy(output, manifest, size);\n\toutput[size] = 0;\n\tgf_filter_pck_set_framing(pck, GF_TRUE, GF_TRUE);\n\tgf_filter_pck_set_seek_flag(pck, GF_TRUE);\n\tif (manifest_name) {\n\t\tif (ctx->out_path) {\n\t\t\tchar *url = gf_url_concatenate(ctx->out_path, manifest_name);\n\t\t\tgf_filter_pck_set_property(pck, GF_PROP_PCK_FILENAME, &PROP_STRING_NO_COPY(url) );\n\t\t} else {\n\t\t\tgf_filter_pck_set_property(pck, GF_PROP_PCK_FILENAME, &PROP_STRING(manifest_name) );\n\t\t}\n\t\tif (ds)\n\t\t\tgf_filter_pck_set_property(pck, GF_PROP_PCK_HLS_REF, &PROP_LONGUINT( ds->hls_ref_id ) );\n\t}\n\tgf_filter_pck_send(pck);\n}\n\n\nstatic void dasher_forward_mpd(GF_DasherCtx *ctx, const char *manifest)\n{\n\tu32 i, count, nb_periods, nb_streams;\n\tGF_XMLAttribute *cenc_att = NULL;\n\tGF_XMLAttribute *xlink_att = NULL;\n\tGF_XMLAttribute *ck_att = NULL;\n\tFILE *tmp = NULL;\n\tGF_MPD *mpd = gf_mpd_new();\n\tGF_List *recompute_sets = NULL;\n\tGF_DOMParser *dom = gf_xml_dom_new();\n\tGF_Err e = gf_xml_dom_parse_string(dom, (char *)manifest);\n\tif (e) goto err_exit;\n\n\te = gf_mpd_init_from_dom(gf_xml_dom_get_root(dom), mpd, NULL);\n\tif (e) goto err_exit;\n\n\tnb_streams = gf_list_count(ctx->pids);\n\tnb_periods = gf_list_count(mpd->periods);\n\tfor (i=0; i<nb_periods; i++) {\n\t\tu32 j;\n\t\tGF_MPD_AdaptationSet *set = NULL;\n\t\tGF_MPD_Representation *rep = NULL;\n\t\tGF_MPD_Period *period = gf_list_get(mpd->periods, i);\n\t\tfor (j=0; j<nb_streams; j++) {\n\t\t\tBool invalidate_set;\n\t\t\tGF_DashStream *ds = gf_list_get(ctx->pids, j);\n\t\t\tif (ds->muxed_base) continue;\n\t\t\tconst GF_PropertyValue *ps = gf_filter_pid_get_property(ds->ipid, GF_PROP_PID_DASH_PERIOD_START);\n\t\t\tconst GF_PropertyValue *repid = gf_filter_pid_get_property(ds->ipid, GF_PROP_PID_REP_ID);\n\t\t\tif (!ps || !repid) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_DASH, (\"[Dasher] Couldn't fetch period start or rep ID in forward mode, cannot forward\\n\"));\n\t\t\t\tgoto err_exit;\n\t\t\t}\n\t\t\tif (period->start != ps->value.longuint) continue;\n\t\t\tdasher_get_set_and_rep(period, repid->value.string, &set, &rep);\n\t\t\tif (!set || !rep) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_DASH, (\"[Dasher] Couldn't locate adaptation set and period in source manifest in forward mode, cannot forward\\n\"));\n\t\t\t\tgoto err_exit;\n\t\t\t}\n\t\t\t//copy/reset common encryption\n\t\t\tif (set->content_protection) {\n\t\t\t\tgf_mpd_del_list(set->content_protection, gf_mpd_descriptor_free, 1);\n\t\t\t}\n\t\t\tif (rep->content_protection) {\n\t\t\t\tgf_mpd_del_list(rep->content_protection, gf_mpd_descriptor_free, 1);\n\t\t\t}\n\t\t\tif (gf_list_count(ds->rep->content_protection)) {\n\t\t\t\tgf_list_del(rep->content_protection);\n\t\t\t\trep->content_protection = dasher_get_content_protection_desc(ctx, ds, NULL);\n\t\t\t}\n\t\t\tif (gf_list_count(ds->set->content_protection)) {\n\t\t\t\tgf_list_del(set->content_protection);\n\t\t\t\tset->content_protection = dasher_get_content_protection_desc(ctx, ds, ds->set);\n\t\t\t}\n\t\t\tinvalidate_set = dasher_merge_rep(ds, rep);\n\t\t\t//wait until we are all done\n\t\t\tif (invalidate_set) {\n\t\t\t\tif (!recompute_sets) recompute_sets = gf_list_new();\n\t\t\t\tif (gf_list_find(recompute_sets, set)<0)\n\t\t\t\t\tgf_list_add(recompute_sets, set);\n\t\t\t}\n\t\t}\n\t}\n\t//update sets - TODO\n\n\t//insert xmlns if needed\n\tcount = gf_list_count(mpd->x_attributes);\n\tfor (i=0; i<count; i++) {\n\t\tGF_XMLAttribute * att = gf_list_get(mpd->x_attributes, i);\n\t\tif (!strcmp(att->name, \"xmlns:cenc\")) cenc_att = att;\n\t\tif (!strcmp(att->name, \"xmlns:xlink\")) xlink_att = att;\n\t\tif (!strcmp(att->name, \"xmlns:ck\")) ck_att = att;\n\n\t}\n\tif (ctx->use_cenc && !cenc_att) {\n\t\tcenc_att = gf_xml_dom_create_attribute(\"xmlns:cenc\", \"urn:mpeg:cenc:2013\");\n\t\tgf_list_add(mpd->x_attributes, cenc_att);\n\t}\n\tif (ctx->use_xlink && !xlink_att) {\n\t\txlink_att = gf_xml_dom_create_attribute(\"xmlns:xlink\", \"http://www.w3.org/1999/xlink\");\n\t\tgf_list_add(mpd->x_attributes, xlink_att);\n\t}\n\tif (ctx->use_clearkey && !ck_att) {\n\t\tck_att = gf_xml_dom_create_attribute(\"xmlns:ck\", \"http://dashif.org/guidelines/clearKey\");\n\t\tgf_list_add(mpd->x_attributes, ck_att);\n\t}\n\n\n\tdasher_check_chaining(ctx, \"urn:mpeg:dash:mpd-chaining:2016\", ctx->chain);\n\tdasher_check_chaining(ctx, \"urn:mpeg:dash:fallback:2016\", ctx->chain_fbk);\n\n\n\t//and send\n\ttmp = gf_file_temp(NULL);\n\tmpd->xml_namespace = ctx->mpd->xml_namespace;\n\tmpd->publishTime = dasher_get_utc(ctx);\n\te = gf_mpd_write(mpd, tmp, ctx->cmpd);\n\tif (e) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_DASH, (\"[Dasher] Error serializing manifest in forward mode: %s\\n\", gf_error_to_string(e) ));\n\t\te = GF_OK;\n\t\tgoto err_exit;\n\t}\n\tdasher_transfer_file(tmp, ctx->opid, NULL, NULL);\n\nerr_exit:\n\tif (tmp) gf_fclose(tmp);\n\tgf_mpd_del(mpd);\n\tgf_xml_dom_del(dom);\n\tgf_list_del(recompute_sets);\n\tif (e)\n\t\tctx->in_error = GF_TRUE;\n}\n\nstatic GF_Err dasher_write_index(GF_DasherCtx *ctx, GF_FilterPid *opid)\n{\n\tu8 *data;\n\tu32 i, pos, count = gf_list_count(ctx->pids);\n\tu32 nb_rep_pos, nb_reps=0;\n\tGF_BitStream *bs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\n\tgf_bs_write_u32(bs, GF_4CC('G','H','I','D'));\n\tgf_bs_write_u32(bs, 0); //for future ext ?\n\tgf_bs_write_u32 (bs, ctx->mpd->segment_duration);\n\tgf_bs_write_u32 (bs, ctx->mpd->max_segment_duration);\n\tgf_bs_write_u64 (bs, ctx->mpd->media_presentation_duration);\n\tgf_bs_write_u64(bs, ctx->current_period->period->duration);\n\tgf_bs_write_utf8(bs, ctx->mpd->segment_template);\n\n\tnb_rep_pos = (u32) gf_bs_get_position(bs);\n\tgf_bs_write_u32(bs, 0);\n\n\tfor (i=0; i<count; i++) {\n\t\tu8 flags=0;\n\t\tu32 j, nb_segs, rep_start;\n\t\tu32 props_start;\n\t\tGF_MPD_SegmentURL *s;\n\t\tGF_DashStream *ds = gf_list_get(ctx->pids, i);\n\t\tif (!ds || !ds->rep || !ds->rep->res_url || !ds->rep->segment_list) continue;\n\n\t\tnb_reps++;\n\t\trep_start = (u32) gf_bs_get_position(bs);\n\t\tgf_bs_write_u32(bs, 0);\n\n\t\tgf_bs_write_utf8(bs, ds->rep->id);\n\t\tgf_bs_write_utf8(bs, ds->rep->res_url);\n\t\tgf_bs_write_u32(bs, ds->rep->trackID);\n\t\ts = gf_list_get(ds->rep->segment_list->segment_URLs, 0);\n\t\tgf_bs_write_u32(bs, s ? (u32) s->frag_start_offset : 0);\n\t\tgf_bs_write_u32(bs, ds->timescale);\n\t\tgf_bs_write_u32(bs, ds->rep->segment_list->timescale);\n\t\tgf_bs_write_u32(bs, ds->rep->bandwidth);\n\t\tgf_bs_write_u32(bs, (ds->pts_minus_cts<0) ? (u32) (-ds->pts_minus_cts) : 0);\n\t\tgf_bs_write_u32(bs, ds->rep->segment_list->sample_duration);\n\t\tgf_bs_write_u32(bs, ds->rep->segment_list->first_cts_offset);\n\t\tgf_bs_write_u32(bs, gf_list_count(ds->rep->segment_list->segment_URLs) );\n\n\t\tGF_MPD_SegmentURL *surl = gf_list_last(ds->rep->segment_list->segment_URLs);\n\t\tgf_bs_write_u8(bs, ds->set ? ds->set->starts_with_sap : ds->rep->starts_with_sap);\n\t\tif (surl->first_tfdt>0xFFFFFFFFUL) {\n\t\t\tflags |= 1;\n\t\t}\n\t\tif (surl->first_pck_seq>0xFFFFFFFFUL) {\n\t\t\tflags |= 1<<1;\n\t\t}\n\t\tif (ds->frag_start_offset) {\n\t\t\tflags |= 1<<2;\n\t\t\tif (surl->frag_start_offset > 0xFFFFFFFFUL) {\n\t\t\t\tflags |= 1<<3;\n\t\t\t}\n\t\t}\n\t\tif (ds->frag_first_ftdt) {\n\t\t\tflags |= 1<<4;\n\t\t\tif (surl->frag_tfdt > 0xFFFFFFFFUL) {\n\t\t\t\tflags |= 1<<5;\n\t\t\t}\n\t\t}\n\t\tif (ds->rep->segment_list->use_split_dur) {\n\t\t\tflags |= 1<<6;\n\t\t}\n\t\tgf_bs_write_u8(bs, flags);\n\t\tgf_bs_write_u16(bs, 0);\n\t\t//serialize all props\n\t\tprops_start = (u32) gf_bs_get_position(bs);\n\t\tgf_bs_write_u32(bs, 0);\n\n\t\tu32 idx=0;\n\t\twhile (1) {\n\t\t\tu32 k;\n\t\t\tu32 p4cc;\n\t\t\tconst char *pname;\n\t\t\tconst GF_PropertyValue *p = gf_filter_pid_enum_properties(ds->ipid, &idx, &p4cc, &pname);\n\t\t\tif (!p) break;\n\t\t\tswitch (p4cc) {\n\t\t\tcase GF_PROP_PID_ID:\n\t\t\tcase GF_PROP_PID_URL:\n\t\t\tcase GF_PROP_PID_FILEPATH:\n\t\t\tcase GF_PROP_PID_FILE_EXT:\n\t\t\tcase GF_PROP_PID_FILE_CACHED:\n\t\t\tcase GF_PROP_PID_DOWN_SIZE:\n\t\t\tcase GF_PROP_PID_DOWNLOAD_SESSION:\n\t\t\tcase GF_PROP_PID_TRACK_NUM:\n\t\t\tcase GF_PROP_PID_MEDIA_DATA_SIZE:\n\t\t\tcase GF_PROP_PID_MAX_FRAME_SIZE:\n\t\t\tcase GF_PROP_PID_AVG_FRAME_SIZE:\n\t\t\tcase GF_PROP_PID_MAX_TS_DELTA:\n\t\t\tcase GF_PROP_PID_CONSTANT_DURATION:\n\t\t\tcase GF_PROP_PID_PLAYBACK_MODE:\n\t\t\tcase GF_PROP_PID_CHAP_TIMES:\n\t\t\tcase GF_PROP_PID_CHAP_NAMES:\n\t\t\t\tcontinue;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (p->type == GF_PROP_POINTER) continue;\n\n\t\t\tif (p4cc) gf_bs_write_u32(bs, p4cc);\n\t\t\telse {\n\t\t\t\tgf_bs_write_u32(bs, 0);\n\t\t\t\tgf_bs_write_utf8(bs, pname);\n\t\t\t\tgf_bs_write_u32(bs, p->type);\n\t\t\t}\n\n\t\t\tswitch (p->type) {\n\t\t\tcase GF_PROP_SINT:\n\t\t\tcase GF_PROP_UINT:\n\t\t\tcase GF_PROP_4CC:\n\t\t\t\tgf_bs_write_u32(bs, p->value.uint);\n\t\t\t\tbreak;\n\t\t\tcase GF_PROP_LSINT:\n\t\t\tcase GF_PROP_LUINT:\n\t\t\t\tgf_bs_write_u64(bs, p->value.longuint);\n\t\t\t\tbreak;\n\t\t\tcase GF_PROP_BOOL:\n\t\t\t\tgf_bs_write_u8(bs, p->value.boolean ? 1 : 0);\n\t\t\t\tbreak;\n\t\t\tcase GF_PROP_FRACTION:\n\t\t\t\tgf_bs_write_u32(bs, p->value.frac.num);\n\t\t\t\tgf_bs_write_u32(bs, p->value.frac.den);\n\t\t\t\tbreak;\n\t\t\tcase GF_PROP_FRACTION64:\n\t\t\t\tgf_bs_write_u64(bs, p->value.lfrac.num);\n\t\t\t\tgf_bs_write_u64(bs, p->value.lfrac.den);\n\t\t\t\tbreak;\n\t\t\tcase GF_PROP_FLOAT:\n\t\t\t\tgf_bs_write_float(bs, FIX2FLT(p->value.fnumber) );\n\t\t\t\tbreak;\n\t\t\tcase GF_PROP_DOUBLE:\n\t\t\t\tgf_bs_write_double(bs, p->value.number);\n\t\t\t\tbreak;\n\t\t\tcase GF_PROP_VEC2I:\n\t\t\t\tgf_bs_write_u32(bs, p->value.vec2i.x);\n\t\t\t\tgf_bs_write_u32(bs, p->value.vec2i.y);\n\t\t\t\tbreak;\n\t\t\tcase GF_PROP_VEC2:\n\t\t\t\tgf_bs_write_double(bs, p->value.vec2.x);\n\t\t\t\tgf_bs_write_double(bs, p->value.vec2.y);\n\t\t\t\tbreak;\n\t\t\tcase GF_PROP_VEC3I:\n\t\t\t\tgf_bs_write_u32(bs, p->value.vec3i.x);\n\t\t\t\tgf_bs_write_u32(bs, p->value.vec3i.y);\n\t\t\t\tgf_bs_write_u32(bs, p->value.vec3i.z);\n\t\t\t\tbreak;\n\t\t\tcase GF_PROP_VEC4I:\n\t\t\t\tgf_bs_write_u32(bs, p->value.vec4i.x);\n\t\t\t\tgf_bs_write_u32(bs, p->value.vec4i.y);\n\t\t\t\tgf_bs_write_u32(bs, p->value.vec4i.z);\n\t\t\t\tgf_bs_write_u32(bs, p->value.vec4i.w);\n\t\t\t\tbreak;\n\t\t\tcase GF_PROP_STRING:\n\t\t\tcase GF_PROP_STRING_NO_COPY:\n\t\t\tcase GF_PROP_NAME:\n\t\t\t\tif (p4cc == GF_PROP_PID_DECODER_CONFIG_ENHANCEMENT) {\n\t\t\t\t\tu32 len = (u32) strlen(p->value.string)+1;\n\t\t\t\t\tgf_bs_write_u32(bs, len);\n\t\t\t\t\tgf_bs_write_data(bs, p->value.string, len);\n\t\t\t\t} else {\n\t\t\t\t\tgf_bs_write_utf8(bs, p->value.string);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase GF_PROP_DATA:\n\t\t\tcase GF_PROP_DATA_NO_COPY:\n\t\t\tcase GF_PROP_CONST_DATA:\n\t\t\t\tgf_bs_write_u32(bs, p->value.data.size);\n\t\t\t\tgf_bs_write_data(bs, p->value.data.ptr, p->value.data.size);\n\t\t\t\tbreak;\n\n\t\t\t//string list: memory is ALWAYS duplicated\n\t\t\tcase GF_PROP_STRING_LIST:\n\t\t\t\tgf_bs_write_u32(bs, p->value.string_list.nb_items);\n\t\t\t\tfor (k=0; k<p->value.string_list.nb_items; k++) {\n\t\t\t\t\tconst char *str = p->value.string_list.vals[k];\n\t\t\t\t\tgf_bs_write_utf8(bs, str);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase GF_PROP_UINT_LIST:\n\t\t\tcase GF_PROP_SINT_LIST:\n\t\t\tcase GF_PROP_4CC_LIST:\n\t\t\t\tgf_bs_write_u32(bs, p->value.uint_list.nb_items);\n\t\t\t\tfor (k=0; k<p->value.uint_list.nb_items; k++) {\n\t\t\t\t\tgf_bs_write_u32(bs, p->value.uint_list.vals[k]);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase GF_PROP_VEC2I_LIST:\n\t\t\t\tgf_bs_write_u32(bs, p->value.v2i_list.nb_items);\n\t\t\t\tfor (k=0; k<p->value.uint_list.nb_items; k++) {\n\t\t\t\t\tgf_bs_write_u32(bs, p->value.v2i_list.vals[k].x );\n\t\t\t\t\tgf_bs_write_u32(bs, p->value.v2i_list.vals[k].y );\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t//last prop\n\t\tgf_bs_write_u32(bs, 0xFFFFFFFF);\n\n\t\tpos = (u32) gf_bs_get_position(bs);\n\t\tu32 psize = pos - props_start;\n\t\tgf_bs_seek(bs, props_start);\n\t\tgf_bs_write_u32(bs, psize);\n\t\tgf_bs_seek(bs, pos);\n\n\t\t//serialize all segments\n\t\tnb_segs = gf_list_count(ds->rep->segment_list->segment_URLs);\n\t\tfor (j=0; j<nb_segs; j++) {\n\t\t\ts = gf_list_get(ds->rep->segment_list->segment_URLs, j);\n\n\t\t\tif (flags & 1) gf_bs_write_u64(bs, s->first_tfdt);\n\t\t\telse gf_bs_write_u32(bs, (u32) s->first_tfdt);\n\n\t\t\tif (flags & (1<<1)) gf_bs_write_u64(bs, s->first_pck_seq);\n\t\t\telse gf_bs_write_u32(bs, (u32) s->first_pck_seq);\n\n\t\t\tgf_bs_write_u32(bs, (u32) s->duration);\n\n\t\t\tif (flags & (1<<2)) {\n\t\t\t\tif (flags & (1<<3)) gf_bs_write_u64(bs, s->frag_start_offset);\n\t\t\t\telse gf_bs_write_u32(bs, (u32) s->frag_start_offset);\n\t\t\t}\n\t\t\tif (flags & (1<<4)) {\n\t\t\t\tif (flags & (1<<5)) gf_bs_write_u64(bs, s->frag_tfdt);\n\t\t\t\telse gf_bs_write_u32(bs, (u32) s->frag_tfdt);\n\t\t\t}\n\t\t\tif (flags & (1<<6)) {\n\t\t\t\tgf_bs_write_u32(bs, s->split_first_dur);\n\t\t\t\tgf_bs_write_u32(bs, s->split_last_dur);\n\t\t\t}\n\t\t}\n\n\t\tpos = (u32) gf_bs_get_position(bs);\n\t\tpsize = pos - rep_start;\n\t\tgf_bs_seek(bs, rep_start);\n\t\tgf_bs_write_u32(bs, psize);\n\t\tgf_bs_seek(bs, pos);\n\t}\n\n\tpos = (u32) gf_bs_get_position(bs);\n\tgf_bs_seek(bs, nb_rep_pos);\n\tgf_bs_write_u32(bs, nb_reps);\n\tgf_bs_seek(bs, pos);\n\n\tGF_FilterPacket *dst = gf_filter_pck_new_alloc(opid, 1, &data);\n\tgf_free(data);\n\tu32 osize;\n\tgf_bs_get_content(bs, &data, &osize);\n\tgf_filter_pck_check_realloc(dst, data, osize);\n\tgf_filter_pck_set_framing(dst, GF_TRUE, GF_TRUE);\n\tgf_filter_pck_send(dst);\n\tgf_bs_del(bs);\n\tctx->mpd->segment_template = NULL;\n\treturn GF_OK;\n}\n\n\nstatic GF_Err dasher_write_and_send_manifest(GF_DasherCtx *ctx, u64 last_period_dur, Bool do_m3u8, Bool m3u8_second_pass, GF_FilterPid *opid, char *alt_name)\n{\n\tvoid *last_signature;\n\tu8 sig[GF_SHA1_DIGEST_SIZE];\n\tGF_Err e;\n\tFILE *tmp;\n\n\tctx->mpd->segment_template = ctx->template;\n\tif (ctx->do_index==1) {\n\t\treturn dasher_write_index(ctx, opid);\n\t}\n\tif (ctx->from_index)\n\t\tctx->mpd->m3u8_use_repid = GF_TRUE;\n\n\ttmp = gf_file_temp(NULL);\n\tif (do_m3u8) {\n\t\tGF_M3U8WriteMode mode = GF_M3U8_WRITE_ALL;\n\t\tif (ctx->from_index==IDXMODE_MANIFEST) mode = GF_M3U8_WRITE_MASTER;\n\t\telse if (ctx->from_index==IDXMODE_CHILD) mode = GF_M3U8_WRITE_CHILD;\n\n\t\tctx->mpd->m3u8_time = ctx->hlsc;\n\t\tctx->mpd->nb_hls_ext_master = ctx->hlsx.nb_items;\n\t\tctx->mpd->hls_ext_master = (const char **) ctx->hlsx.vals;\n\t\tctx->mpd->llhls_preload = ctx->ll_preload_hint;\n\t\tctx->mpd->llhls_rendition_reports = ctx->ll_rend_rep;\n\t\tctx->mpd->llhls_part_holdback = ctx->ll_part_hb;\n\t\tctx->mpd->hls_abs_url = ctx->hls_absu;\n\n\t\tif (ctx->llhls==3)\n\t\t\tctx->mpd->force_llhls_mode = m3u8_second_pass ? 2 : 1;\n\t\telse\n\t\t\tctx->mpd->force_llhls_mode = 0;\n\n\t\tif (m3u8_second_pass) {\n\t\t\te = gf_mpd_write_m3u8_master_playlist(ctx->mpd, tmp, ctx->out_path, gf_list_last(ctx->mpd->periods), mode);\n\t\t} else {\n\t\t\te = gf_mpd_write_m3u8_master_playlist(ctx->mpd, tmp, ctx->out_path, gf_list_last(ctx->mpd->periods), mode);\n\t\t}\n\t} else {\n\t\te = gf_mpd_write(ctx->mpd, tmp, ctx->cmpd);\n\t}\n\tctx->mpd->segment_template = NULL;\n\n\tif (e) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_DASH, (\"[Dasher] failed to write %s file: %s\\n\", do_m3u8 ? \"M3U8\" : \"MPD\", gf_error_to_string(e) ));\n\t\tgf_fclose(tmp);\n\t\tif (ctx->current_period->period)\n\t\t\tctx->current_period->period->duration = last_period_dur;\n\t\treturn e;\n\t}\n\n\tif (ctx->profile == GF_DASH_PROFILE_HBBTV_1_5_ISOBMF_LIVE) {\n\t\tif (gf_ftell(tmp) > 100 * 1024)\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_DASH, (\"[Dasher] manifest MPD is too big for HbbTV 1.5. Limit is 100kB, current size is \"LLU\"kB\\n\", gf_ftell(tmp) / 1024));\n\t}\n\n\tgf_sha1_file_ptr(tmp, sig);\n\tif (do_m3u8) {\n\t\tlast_signature = (void *) m3u8_second_pass ? ctx->last_hls2_signature : ctx->last_hls_signature;\n\t} else {\n\t\tlast_signature = (void *) ctx->last_mpd_signature;\n\t}\n\n\tif (memcmp(sig, last_signature, GF_SHA1_DIGEST_SIZE)) {\n\t\tmemcpy(last_signature, sig, GF_SHA1_DIGEST_SIZE);\n\n\t\tif (ctx->from_index!=IDXMODE_CHILD)\n\t\t\tdasher_transfer_file(tmp, opid, alt_name, NULL);\n\t}\n\tgf_fclose(tmp);\n\treturn GF_OK;\n}\n\nstatic void dasher_update_dyn_bitrates(GF_DasherCtx *ctx)\n{\n\tu32 i, count = gf_list_count(ctx->current_period->streams);\n\tfor (i=0; i<count; i++) {\n\t\tGF_DashStream *ds = gf_list_get(ctx->current_period->streams, i);\n\t\tif (ds->dyn_bitrate) dasher_update_bitrate(ctx, ds);\n\t}\n}\n\nGF_Err dasher_send_manifest(GF_Filter *filter, GF_DasherCtx *ctx, Bool for_mpd_only)\n{\n\tGF_Err e;\n\tu32 i, max_opid;\n\tFILE *tmp;\n\tu64 store_mpd_dur=0;\n\tu64 max_seg_dur=0;\n\tu64 last_period_dur;\n\n\t//manifest forwarding\n\tif (ctx->forward_mode == DASHER_FWD_ALL)\n\t\treturn GF_OK;\n\n\tif (ctx->from_index>=IDXMODE_INIT)\n\t\treturn GF_OK;\n\n\tif (ctx->dyn_rate)\n\t\tdasher_update_dyn_bitrates(ctx);\n\n\t//UGLY PATCH, to remove - we don't have the same algos in old arch and new arch, which result in slightly different max segment duration\n\t//on audio for our test suite - patch it manually to avoid hash failures :(\n\t//TODO, remove as soon as we switch archs\n\tif (gf_sys_old_arch_compat() && (ctx->mpd->max_segment_duration==1022) && (ctx->mpd->media_presentation_duration==10160) ) {\n\t\tctx->mpd->max_segment_duration = 1080;\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_DASH, (\"[Dasher] patch for old regression tests hit, changing max seg dur from 1022 to 1080\\nPlease notify GPAC devs to remove this, and do not use fot_test modes in dash filter\\n\"));\n\t}\n\n\tctx->mpd->publishTime = dasher_get_utc(ctx);\n\tif (ctx->utc_timing_type==DASHER_UTCREF_INBAND) {\n\t\tGF_MPD_Descriptor *d = gf_list_get(ctx->mpd->utc_timings, 0);\n\t\tif (d) {\n\t\t\ttime_t gtime;\n\t\t\tstruct tm *t;\n\t\t\tu32 sec;\n\t\t\tu32 ms;\n\t\t\tchar szTime[100];\n\t\t\tif (d->value) gf_free(d->value);\n\n\t\t\tgtime = ctx->mpd->publishTime / 1000;\n\t\t\tsec = (u32)(ctx->mpd->publishTime / 1000);\n\t\t\tms = (u32)(ctx->mpd->publishTime - ((u64)sec) * 1000);\n\n\t\t\tt = gf_gmtime(&gtime);\n\t\t\tsec = t->tm_sec;\n\t\t\t//see issue #859, no clue how this happened...\n\t\t\tif (sec > 60)\n\t\t\t\tsec = 60;\n\t\t\tsnprintf(szTime, 100, \"%d-%02d-%02dT%02d:%02d:%02d.%03dZ\", 1900 + t->tm_year, t->tm_mon + 1, t->tm_mday, t->tm_hour, t->tm_min, sec, ms);\n\t\t\td->value = gf_strdup(szTime);\n\t\t}\n\t}\n\n\tdasher_update_mpd(ctx);\n\tctx->mpd->write_context = GF_FALSE;\n\tctx->mpd->was_dynamic = GF_FALSE;\n\tif (ctx->dmode==GF_DASH_DYNAMIC_LAST)\n\t\tctx->mpd->was_dynamic = GF_TRUE;\n\n\tif ((ctx->refresh>=0) && (ctx->dmode==GF_DASH_DYNAMIC)) {\n\t\tstore_mpd_dur= ctx->mpd->media_presentation_duration;\n\t}\n\n\tif (ctx->sseg && ctx->mpd->max_segment_duration) {\n\t\tmax_seg_dur = ctx->mpd->max_subsegment_duration = ctx->mpd->max_segment_duration;\n\t\tctx->mpd->max_segment_duration = 0;\n\t}\n\n\tlast_period_dur = 0;\n\tif (ctx->current_period->period) {\n\t\tlast_period_dur = ctx->current_period->period->duration;\n\t\tif (ctx->dmode==GF_DASH_DYNAMIC) {\n\t\t\tctx->current_period->period->duration = 0;\n\t\t\tctx->mpd->media_presentation_duration = 0;\n\t\t}\n\t}\n\n\tif (ctx->index_max_seg_dur) {\n\t\tctx->mpd->max_segment_duration = ctx->index_max_seg_dur;\n\t\tctx->mpd->allow_empty_reps = 1;\n\t}\n\tif (ctx->index_media_duration)\n\t\tctx->mpd->media_presentation_duration = ctx->index_media_duration;\n\n\tmax_opid = (ctx->dual && ctx->opid_alt) ? 2 : 1;\n\tfor (i=0; i < max_opid; i++) {\n\t\tBool do_m3u8 = GF_FALSE;\n\t\tGF_FilterPid *opid;\n\n\t\tif (i==0) {\n\t\t\tif (max_opid>1) {\n\t\t\t\tdo_m3u8 = ctx->opid_alt_m3u8 ? GF_FALSE : GF_TRUE;\n\t\t\t} else {\n\t\t\t\tdo_m3u8 = ctx->do_m3u8;\n\t\t\t}\n\t\t\topid = ctx->opid;\n\t\t} else {\n\t\t\tdo_m3u8 = ctx->opid_alt_m3u8;\n\t\t\topid = ctx->opid_alt;\n\t\t}\n\t\tif (do_m3u8 && for_mpd_only) {\n\t\t\tcontinue;\n\t\t}\n\t\tif ((ctx->llhls==3) && do_m3u8)\n\t\t\tctx->mpd->force_llhls_mode = 1;\n\t\te = dasher_write_and_send_manifest(ctx, last_period_dur, do_m3u8, GF_FALSE, opid, NULL);\n\t\tif (e) return e;\n\n\t\tctx->mpd->force_llhls_mode = 0;\n\t}\n\n\tif (ctx->current_period->period)\n\t\tctx->current_period->period->duration = last_period_dur;\n\n\tif (store_mpd_dur) {\n\t\tctx->mpd->media_presentation_duration = store_mpd_dur;\n\t}\n\n\tif (max_seg_dur) {\n\t\tctx->mpd->max_segment_duration = (u32) max_seg_dur;\n\t\tctx->mpd->max_subsegment_duration = 0;\n\t}\n\tif (ctx->def_max_seg_dur)\n\t\tctx->mpd->max_segment_duration = (u32) ctx->def_max_seg_dur;\n\n\tif (ctx->do_m3u8) {\n\t\tBool m3u8_second_pass = GF_FALSE;\n\t\tu32 j;\n\t\tGF_MPD_Period *period = gf_list_last(ctx->mpd->periods);\n\t\tGF_MPD_AdaptationSet *as;\n\t\tGF_MPD_Representation *rep;\n\t\tGF_FilterPid *opid;\n\t\tassert(period);\n\t\tif (ctx->opid_alt_m3u8) opid = ctx->opid_alt;\n\t\telse opid = ctx->opid;\n\nresend:\n\t\ti=0;\n\t\twhile ( (as = (GF_MPD_AdaptationSet *) gf_list_enum(period->adaptation_sets, &i))) {\n\t\t\tj=0;\n\t\t\twhile ( (rep = (GF_MPD_Representation *) gf_list_enum(as->representations, &j))) {\n\t\t\t\tif (rep->m3u8_var_file) {\n\t\t\t\t\tGF_DashStream *ds;\n\t\t\t\t\tchar *outfile = rep->m3u8_var_name;\n\t\t\t\t\tBool do_free = GF_FALSE;\n\n\t\t\t\t\tif (rep->m3u8_name) {\n\t\t\t\t\t\toutfile = (char *) rep->m3u8_name;\n\t\t\t\t\t\tif (ctx->out_path && (ctx->from_index<=IDXMODE_ALL)) {\n\t\t\t\t\t\t\toutfile = gf_url_concatenate(ctx->out_path, rep->m3u8_name);\n\t\t\t\t\t\t\tdo_free = GF_TRUE;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (m3u8_second_pass) {\n\t\t\t\t\t\tchar *sep;\n\t\t\t\t\t\tchar *new_name = gf_strdup(outfile);\n\n\t\t\t\t\t\tsep = gf_file_ext_start(new_name);\n\t\t\t\t\t\tif (sep) sep[0] = 0;\n\t\t\t\t\t\tgf_dynstrcat(&new_name, \"_IF\", NULL);\n\t\t\t\t\t\tsep = gf_file_ext_start(outfile);\n\t\t\t\t\t\tif (sep)\n\t\t\t\t\t\t\tgf_dynstrcat(&new_name, sep, NULL);\n\n\t\t\t\t\t\tif (do_free) gf_free(outfile);\n\t\t\t\t\t\toutfile = new_name;\n\t\t\t\t\t\tdo_free = GF_TRUE;\n\t\t\t\t\t}\n\t\t\t\t\tds = rep->playback.udta;\n\t\t\t\t\tdasher_transfer_file(rep->m3u8_var_file, opid, outfile, ds);\n\t\t\t\t\tgf_fclose(rep->m3u8_var_file);\n\t\t\t\t\trep->m3u8_var_file = NULL;\n\t\t\t\t\tif (do_free) gf_free(outfile);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ((ctx->llhls==3) && !m3u8_second_pass && ctx->out_path) {\n\t\t\tchar *sep;\n\t\t\tchar szAltName[GF_MAX_PATH];\n\t\t\tstrcpy(szAltName, ctx->out_path);\n\t\t\tsep = gf_file_ext_start(szAltName);\n\t\t\tif (sep) sep[0] = 0;\n\t\t\tstrcat(szAltName, \"_IF\");\n\t\t\tsep = gf_file_ext_start(ctx->out_path);\n\t\t\tif (sep) strcat(szAltName, sep);\n\n\t\t\tctx->mpd->force_llhls_mode = 2;\n\t\t\te = dasher_write_and_send_manifest(ctx, last_period_dur, GF_TRUE, GF_TRUE, ctx->opid, szAltName);\n\t\t\tif (e) return e;\n\n\t\t\tm3u8_second_pass = GF_TRUE;\n\t\t\tgoto resend;\n\n\t\t}\n\t}\n\n\n\tif (ctx->state) {\n\t\ttmp = gf_fopen(ctx->state, \"w\");\n\t\tif (!tmp) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_DASH, (\"[Dasher] failed to open context MPD %s for write\\n\", ctx->state ));\n\t\t\treturn GF_IO_ERR;\n\t\t}\n\t\tctx->mpd->write_context = GF_TRUE;\n\t\te = gf_mpd_write(ctx->mpd, tmp, ctx->cmpd);\n\t\tgf_fclose(tmp);\n\t\tctx->mpd->write_context = GF_FALSE;\n\t\tif (e) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_DASH, (\"[Dasher] failed to write MPD file: %s\\n\", gf_error_to_string(e) ));\n\t\t}\n\t}\n\n\tif (ctx->def_max_seg_dur)\n\t\tctx->mpd->max_segment_duration = 0;\n\treturn GF_OK;\n}\n\nstatic void dasher_reset_stream(GF_Filter *filter, GF_DashStream *ds, Bool is_destroy)\n{\n\t//we do not remove the destination filter, it will be removed automatically once all remove_pids are called\n\t//removing it explicitly will discard the upper chain and any packets not yet processed\n\n\tds->dst_filter = NULL;\n\tif (ds->seg_template) gf_free(ds->seg_template);\n\tif (ds->idx_template) gf_free(ds->idx_template);\n\tif (ds->init_seg) gf_free(ds->init_seg);\n\tif (ds->multi_pids) gf_list_del(ds->multi_pids);\n\tds->multi_pids = NULL;\n\tif (ds->multi_tracks) gf_list_del(ds->multi_tracks);\n\tds->multi_tracks = NULL;\n\n\tif (ds->pending_segment_urls) gf_list_del(ds->pending_segment_urls);\n\tds->pending_segment_urls = NULL;\n\tif (ds->pending_segment_states) gf_list_del(ds->pending_segment_states);\n\tds->pending_segment_states = NULL;\n\n\tif (is_destroy) {\n\t\tif (ds->cues) gf_free(ds->cues);\n\t\tgf_list_del(ds->complementary_streams);\n\t\tgf_free(ds->rep_id);\n\t\t//string properties are locally copied\n#define RESET_PROP_STR(_prop) \\\n\t\tif (_prop) gf_free(_prop);\n\n\t\tRESET_PROP_STR(ds->src_url)\n\t\tRESET_PROP_STR(ds->template)\n\t\tRESET_PROP_STR(ds->lang)\n\t\tRESET_PROP_STR(ds->hls_vp_name)\n\t\tRESET_PROP_STR(ds->xlink)\n\t\tRESET_PROP_STR(ds->period_id)\n\t\tRESET_PROP_STR(ds->period_continuity_id)\n\n#undef RESET_PROP_STR\n\t\treturn;\n\t}\n\tds->init_seg = ds->seg_template = ds->idx_template = NULL;\n\tds->split_set_names = GF_FALSE;\n\tds->nb_sap_3 = 0;\n\tds->nb_sap_4 = 0;\n\tds->pid_id = 0;\n\tds->force_timescale = 0;\n\tds->set = NULL;\n\tds->owns_set = GF_FALSE;\n\tds->rep = NULL;\n\tds->muxed_base = NULL;\n\tds->nb_comp = ds->nb_comp_done = 0;\n\tgf_list_reset(ds->complementary_streams);\n\tds->inband_params = 0;\n\tds->seg_start_time = 0;\n\tds->seg_number = ds->startNumber;\n\tds->nb_segments_purged = 0;\n\tds->dur_purged = 0;\n\tds->moof_sn_inc = 0;\n\tds->moof_sn = 0;\n\tds->seg_done = 0;\n\tds->subdur_done = 0;\n\tif (ds->packet_queue) {\n\t\twhile (gf_list_count(ds->packet_queue)) {\n\t\t\tGF_FilterPacket *pck = gf_list_pop_front(ds->packet_queue);\n\t\t\tgf_filter_pck_unref(pck);\n\t\t}\n\t\tds->nb_sap_in_queue = 0;\n\t}\n\tds->forced_period_switch = GF_FALSE;\n}\n\nvoid dasher_context_update_period_end(GF_DasherCtx *ctx)\n{\n\tu32 i, count;\n\n\tif (!ctx->mpd) return;\n\n\tcount = gf_list_count(ctx->current_period->streams);\n\tfor (i=0; i<count; i++) {\n\t\tGF_DashStream *ds = gf_list_get(ctx->current_period->streams, i);\n\t\tif (!ds->rep) continue;\n\t\tif (!ds->rep->dasher_ctx) continue;\n\t\tif (ds->done == 1) {\n\t\t\tds->rep->dasher_ctx->done = 1;\n\t\t} else {\n\t\t\t//store all dynamic parameters of the rep\n\t\t\tds->rep->dasher_ctx->last_pck_idx = ds->nb_pck;\n\t\t\tds->seek_to_pck = ds->nb_pck;\n\t\t\tds->rep->dasher_ctx->seg_number = ds->seg_number;\n\t\t\tds->rep->dasher_ctx->next_seg_start = ds->next_seg_start;\n\t\t\tds->rep->dasher_ctx->first_cts = ds->first_cts;\n\t\t\tds->rep->dasher_ctx->first_dts = ds->first_dts;\n\t\t\tds->rep->dasher_ctx->ts_offset = ds->ts_offset;\n\t\t\tds->rep->dasher_ctx->segs_purged = ds->nb_segments_purged;\n\t\t\tds->rep->dasher_ctx->dur_purged = ds->dur_purged;\n\t\t\tds->rep->dasher_ctx->moof_sn = ds->moof_sn;\n\t\t\tds->rep->dasher_ctx->moof_sn_inc = ds->moof_sn_inc;\n\t\t\tds->rep->dasher_ctx->subdur_forced = ds->subdur_forced_use_period_dur ? GF_TRUE : GF_FALSE;\n\t\t}\n\t\tif (ctx->subdur) {\n\t\t\tds->rep->dasher_ctx->cumulated_subdur = ds->cumulated_subdur + ctx->subdur;\n\t\t\tds->rep->dasher_ctx->cumulated_dur = ((Double)ds->cumulated_dur) / ds->timescale;\n\n\t\t}\n\t\tds->rep->dasher_ctx->nb_repeat = ds->nb_repeat;\n\t\tds->rep->dasher_ctx->est_next_dts = ds->est_next_dts;\n\t\tds->rep->dasher_ctx->source_pid = ds->id;\n\t\tds->rep->dasher_ctx->mpd_timescale = ds->mpd_timescale;\n\t\tds->rep->dasher_ctx->last_dyn_period_id = ctx->last_dyn_period_id;\n\n\t\tassert(ds->rep->dasher_ctx->init_seg);\n\t\tassert(ds->rep->dasher_ctx->src_url);\n\t\tassert(ds->rep->dasher_ctx->template_seg);\n\t}\n}\n\nvoid dasher_context_update_period_start(GF_DasherCtx *ctx)\n{\n\tu32 i, j, count;\n\n\tif (!ctx->mpd) return;\n\tcount = gf_list_count(ctx->current_period->streams);\n\tfor (i=0; i<count; i++) {\n\t\tGF_DashStream *ds = gf_list_get(ctx->current_period->streams, i);\n\t\tif (!ds->rep) continue;\n\t\tif (ds->rep->dasher_ctx) continue;\n\n\t\t//store all static parameters of the rep\n\t\tGF_SAFEALLOC(ds->rep->dasher_ctx, GF_DASH_SegmenterContext);\n\t\tif (!ds->rep->dasher_ctx) return;\n\n\t\tds->rep->dasher_ctx->done = 0;\n\n\t\tassert(ds->init_seg);\n\t\tds->rep->dasher_ctx->init_seg = gf_strdup(ds->init_seg);\n\t\tassert(ds->src_url);\n\t\tds->rep->dasher_ctx->src_url = gf_strdup(ds->src_url);\n\t\tassert(ds->seg_template);\n\t\tds->rep->dasher_ctx->template_seg = gf_strdup(ds->seg_template);\n\t\tif (ds->idx_template)\n\t\t\tds->rep->dasher_ctx->template_idx = gf_strdup(ds->idx_template);\n\n\t\tds->rep->dasher_ctx->pid_id = ds->pid_id;\n\t\tds->rep->dasher_ctx->dep_pid_id = ds->dep_pid_id;\n\t\tds->rep->dasher_ctx->period_start = ds->period_start;\n\t\tds->rep->dasher_ctx->period_duration = ds->period_dur;\n\t\tds->rep->dasher_ctx->multi_pids = ds->multi_pids ? GF_TRUE : GF_FALSE;\n\t\tds->rep->dasher_ctx->dash_dur = ds->dash_dur;\n\n\t\tif (strcmp(ds->period_id, DEFAULT_PERIOD_ID))\n\t\t\tds->rep->dasher_ctx->period_id = ds->period_id;\n\n\t\tds->rep->dasher_ctx->owns_set = (ds->set->udta == ds) ? GF_TRUE : GF_FALSE;\n\n\t\tif (ds->rep->dasher_ctx->mux_pids) gf_free(ds->rep->dasher_ctx->mux_pids);\n\t\tds->rep->dasher_ctx->mux_pids = NULL;\n\t\tfor (j=0; j<count; j++) {\n\t\t\tchar szMuxPID[10];\n\t\t\tGF_DashStream *a_ds = gf_list_get(ctx->current_period->streams, j);\n\t\t\tif (a_ds==ds) continue;\n\t\t\tif (a_ds->muxed_base != ds) continue;\n\n\t\t\tif (ds->rep->dasher_ctx->mux_pids)\n\t\t\t\tsprintf(szMuxPID, \" %d\", a_ds->id);\n\t\t\telse\n\t\t\t\tsprintf(szMuxPID, \"%d\", a_ds->id);\n\n\t\t\tgf_dynstrcat(&ds->rep->dasher_ctx->mux_pids, szMuxPID, NULL);\n\t\t}\n\n\t}\n}\n\nstatic GF_DashStream *dasher_get_stream(GF_DasherCtx *ctx, const char *src_url, u32 original_pid, u32 pid_id)\n{\n\tu32 i, count = gf_list_count(ctx->pids);\n\tfor (i=0; i<count; i++) {\n\t\tGF_DashStream *ds = gf_list_get(ctx->pids, i);\n\t\tif (pid_id && (ds->pid_id==pid_id)) return ds;\n\t\tif (src_url && ds->src_url && !strcmp(ds->src_url, src_url) && (ds->id == original_pid) ) return ds;\n\t}\n\treturn NULL;\n}\n\nstatic GF_Err dasher_reload_muxed_comp(GF_DasherCtx *ctx, GF_DashStream *base_ds, char *mux_pids, Bool check_only)\n{\n\tGF_Err e = GF_OK;\n\twhile (mux_pids) {\n\t\tu32 pid_id;\n\t\tGF_DashStream *ds;\n\t\tchar *sep = strchr(mux_pids, ' ');\n\t\tif (sep) sep[0] = 0;\n\n\t\tpid_id = atoi(mux_pids);\n\t\tds = dasher_get_stream(ctx, base_ds->src_url, pid_id, 0);\n\t\tif (ds) {\n\t\t\tif (!check_only) {\n\t\t\t\tif (ds->rep) gf_mpd_representation_free(ds->rep);\n\t\t\t\tds->rep = NULL;\n\t\t\t\tds->set = base_ds->set;\n\t\t\t\tds->muxed_base = base_ds;\n\t\t\t\tbase_ds->nb_comp ++;\n\t\t\t\tds->nb_comp = 1;\n\t\t\t\tds->done = base_ds->done;\n\t\t\t\tds->subdur_done = base_ds->subdur_done;\n\t\t\t\tds->period = ctx->current_period;\n\n\t\t\t\tgf_list_del_item(ctx->next_period->streams, ds);\n\t\t\t\tgf_list_add(ctx->current_period->streams, ds);\n\t\t\t}\n\t\t} else {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_DASH, (\"[Dasher] Couldn't find muxed PID %d in source %s, did you modify the source ?\\n\", pid_id, base_ds->src_url));\n\t\t\te = GF_BAD_PARAM;\n\t\t}\n\n\t\tif (!sep) break;\n\t\tsep[0] = ' ';\n\t\tmux_pids = sep+1;\n\n\t\tif (e) return e;\n\t}\n\treturn GF_OK;\n}\n\nstatic GF_Err dasher_reload_context(GF_Filter *filter, GF_DasherCtx *ctx)\n{\n\tGF_Err e;\n\tBool last_period_active = GF_FALSE;\n\tu32 i, j, k, nb_p, nb_as, nb_rep, count;\n\tGF_DOMParser *mpd_parser;\n\n\tctx->first_context_load = GF_FALSE;\n\n\tif (!gf_file_exists(ctx->state)) return GF_OK;\n\n\t/* parse the MPD */\n\tmpd_parser = gf_xml_dom_new();\n\te = gf_xml_dom_parse(mpd_parser, ctx->state, NULL, NULL);\n\n\tif (e != GF_OK) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_DASH, (\"[Dasher] Cannot parse MPD state %s: %s\\n\", ctx->state, gf_xml_dom_get_error(mpd_parser) ));\n\t\tgf_xml_dom_del(mpd_parser);\n\t\treturn GF_URL_ERROR;\n\t}\n\tif (ctx->mpd) gf_mpd_del(ctx->mpd);\n\tctx->mpd = gf_mpd_new();\n\te = gf_mpd_init_from_dom(gf_xml_dom_get_root(mpd_parser), ctx->mpd, ctx->state);\n\tgf_xml_dom_del(mpd_parser);\n\t//test mode, strip URL path\n\tif (gf_sys_is_test_mode()) {\n\t\tcount = gf_list_count(ctx->mpd->program_infos);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tGF_MPD_ProgramInfo *info = gf_list_get(ctx->mpd->program_infos, i);\n\t\t\tif (info->title && strstr(info->title, \"generated by GPAC\")) {\n\t\t\t\tgf_free(info->title);\n\t\t\t\tchar tmp[256];\n\t\t\t\tchar *name = strrchr(ctx->out_path, '/');\n\t\t\t\tif (!name) name = strrchr(ctx->out_path, '\\\\');\n\t\t\t\tif (!name) name = ctx->out_path;\n\t\t\t\telse name++;\n\t\t\t\tsprintf(tmp, \"%s generated by GPAC\", name);\n\t\t\t\tinfo->title = gf_strdup(tmp);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!ctx->mpd->xml_namespace)\n\t\tctx->mpd->xml_namespace = \"urn:mpeg:dash:schema:mpd:2011\";\n\n\tif (e != GF_OK) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_DASH, (\"[Dasher] Cannot reload MPD state %s: %s\\n\", ctx->state, gf_error_to_string(e) ));\n\t\tgf_mpd_del(ctx->mpd);\n\t\tctx->mpd = NULL;\n\t\treturn GF_URL_ERROR;\n\t}\n\n\t//do a first pass to detect any potential changes in input config, if so consider the period over.\n\tnb_p = gf_list_count(ctx->mpd->periods);\n\tfor (i=0; i<nb_p; i++) {\n\t\tu32 nb_done_in_period = 0;\n\t\tu32 nb_remain_in_period = 0;\n\t\tGF_MPD_Period *p = gf_list_get(ctx->mpd->periods, i);\n\t\tnb_as = gf_list_count(p->adaptation_sets);\n\t\tfor (j=0; j<nb_as; j++) {\n\t\t\tGF_MPD_AdaptationSet *set = gf_list_get(p->adaptation_sets, j);\n\t\t\tnb_rep = gf_list_count(set->representations);\n\t\t\tfor (k=0; k<nb_rep; k++) {\n\t\t\t\tGF_DashStream *ds;\n\t\t\t\tchar *p_id;\n\t\t\t\tGF_MPD_Representation *rep = gf_list_get(set->representations, k);\n\t\t\t\tif (! rep->dasher_ctx) continue;\n\n\t\t\t\t//ensure we have the same settings - if not consider the dash stream has been resetup for a new period\n\t\t\t\tds = dasher_get_stream(ctx, rep->dasher_ctx->src_url, rep->dasher_ctx->source_pid, 0);\n\t\t\t\tif (!ds) {\n\t\t\t\t\trep->dasher_ctx->done = 1;\n\t\t\t\t\tnb_done_in_period++;\n\t\t\t\t\tif (rep->dasher_ctx->last_dyn_period_id >= ctx->last_dyn_period_id)\n\t\t\t\t\t\tctx->last_dyn_period_id = 1 + rep->dasher_ctx->last_dyn_period_id;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (rep->dasher_ctx->done) {\n\t\t\t\t\tnb_done_in_period++;\n\t\t\t\t\tds->nb_repeat = rep->dasher_ctx->nb_repeat + 1;\n\t\t\t\t\tif (rep->dasher_ctx->last_dyn_period_id > ctx->last_dyn_period_id)\n\t\t\t\t\t\tctx->last_dyn_period_id = rep->dasher_ctx->last_dyn_period_id;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tp_id = DEFAULT_PERIOD_ID;\n\t\t\t\tif (rep->dasher_ctx->period_id) p_id = rep->dasher_ctx->period_id;\n\n\t\t\t\tif (ds->period_id && p_id && !strcmp(ds->period_id, p_id)) {\n\t\t\t\t} else if (!ds->period_id && !rep->dasher_ctx->period_id) {\n\t\t\t\t} else {\n\t\t\t\t\trep->dasher_ctx->done = 1;\n\t\t\t\t\tnb_done_in_period++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (ds->period_start.num * rep->dasher_ctx->period_start.den != rep->dasher_ctx->period_start.num * ds->period_start.den) {\n\t\t\t\t\trep->dasher_ctx->done = 1;\n\t\t\t\t\tnb_done_in_period++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (ds->period_dur.num * rep->dasher_ctx->period_duration.den != rep->dasher_ctx->period_duration.num * ds->period_dur.den) {\n\t\t\t\t\trep->dasher_ctx->done = 1;\n\t\t\t\t\tnb_done_in_period++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t//check we can reload muxed components - if not consider this source as removed\n\t\t\t\tif (rep->dasher_ctx->mux_pids) {\n\t\t\t\t\te = dasher_reload_muxed_comp(ctx, ds, rep->dasher_ctx->mux_pids, GF_TRUE);\n\t\t\t\t\tif (e) {\n\t\t\t\t\t\trep->dasher_ctx->done = 1;\n\t\t\t\t\t\tnb_done_in_period++;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tnb_remain_in_period++;\n\t\t\t}\n\t\t}\n\t\tif (nb_remain_in_period) {\n\t\t\tassert(i+1==nb_p);\n\t\t\tlast_period_active = GF_TRUE;\n\t\t}\n\t\telse if (nb_done_in_period && ctx->subdur  ) {\n\t\t\t//we are done but we loop the entire streams\n\t\t\tfor (j=0; j<gf_list_count(ctx->pids); j++) {\n\t\t\t\tGF_DashStream *ds = gf_list_get(ctx->pids, j);\n\t\t\t\tds->done = 0;\n\t\t\t\tds->segment_started = GF_FALSE;\n\t\t\t\tds->seg_done = GF_FALSE;\n\t\t\t\tds->cumulated_dur = 0;\n\t\t\t\tds->cumulated_subdur = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!last_period_active) return GF_OK;\n\tctx->current_period->period = gf_list_last(ctx->mpd->periods);\n\tgf_list_reset(ctx->current_period->streams);\n\tgf_list_del(ctx->next_period->streams);\n\tctx->next_period->streams = gf_list_clone(ctx->pids);\n\n\tif (ctx->current_period->period->duration) {\n\t\t//reset last period duration and cumulated dur of MPD\n\t\tif (ctx->mpd->media_presentation_duration>ctx->current_period->period->duration)\n\t\t\tctx->mpd->media_presentation_duration -= ctx->current_period->period->duration;\n\t\telse\n\t\t\tctx->mpd->media_presentation_duration = 0;\n\t\tctx->current_period->period->duration = 0;\n\t}\n\n\tnb_as = gf_list_count(ctx->current_period->period->adaptation_sets);\n\tfor (j=0; j<nb_as; j++) {\n\t\tGF_DashStream *set_ds = NULL;\n\t\tGF_List *multi_pids = NULL;\n\t\tBool use_multi_pid_init = GF_FALSE;\n\t\tGF_MPD_AdaptationSet *set = gf_list_get(ctx->current_period->period->adaptation_sets, j);\n\t\tnb_rep = gf_list_count(set->representations);\n\t\tfor (k=0; k<nb_rep; k++) {\n\t\t\tGF_DashStream *ds;\n\t\t\tGF_MPD_Representation *rep = gf_list_get(set->representations, k);\n\t\t\tif (! rep->dasher_ctx) continue;\n\n\t\t\tds = dasher_get_stream(ctx, rep->dasher_ctx->src_url, rep->dasher_ctx->source_pid, 0);\n\t\t\tif (!ds) continue;\n\n\t\t\t//restore everything\n\t\t\tds->done = rep->dasher_ctx->done;\n\t\t\tds->seg_number = rep->dasher_ctx->seg_number;\n\n\t\t\tif (ds->init_seg) gf_free(ds->init_seg);\n\t\t\tds->init_seg = gf_strdup(rep->dasher_ctx->init_seg);\n\n\t\t\tif (ds->seg_template) gf_free(ds->seg_template);\n\t\t\tds->seg_template = gf_strdup(rep->dasher_ctx->template_seg);\n\n\t\t\tif (ds->idx_template) gf_free(ds->idx_template);\n\t\t\tds->idx_template = rep->dasher_ctx->template_idx ? gf_strdup(rep->dasher_ctx->template_idx) : NULL;\n\n\t\t\tif (rep->dasher_ctx->period_id) {\n\t\t\t\tif (ds->period_id) gf_free(ds->period_id);\n\t\t\t\tds->period_id = gf_strdup(rep->dasher_ctx->period_id);\n\t\t\t}\n\n\t\t\tds->period_start = rep->dasher_ctx->period_start;\n\t\t\tif (!ds->period_start.den) {\n\t\t\t\tds->period_start.num = 0;\n\t\t\t\tds->period_start.den = 1000;\n\t\t\t}\n\t\t\tds->period_dur = rep->dasher_ctx->period_duration;\n\t\t\tif (!ds->period_dur.den) {\n\t\t\t\tds->period_dur.num = 0;\n\t\t\t\tds->period_dur.den = 1;\n\t\t\t}\n\t\t\tds->pid_id = rep->dasher_ctx->pid_id;\n\t\t\tds->dep_pid_id = rep->dasher_ctx->dep_pid_id;\n\t\t\tds->seek_to_pck = rep->dasher_ctx->last_pck_idx;\n\t\t\tds->dash_dur = rep->dasher_ctx->dash_dur;\n\t\t\tif (!ds->dash_dur.den) {\n\t\t\t\tds->dash_dur.num = 0;\n\t\t\t\tds->dash_dur.den = 1;\n\t\t\t}\n\t\t\tds->next_seg_start = rep->dasher_ctx->next_seg_start;\n\t\t\tds->adjusted_next_seg_start = ds->next_seg_start;\n\t\t\tds->first_cts = rep->dasher_ctx->first_cts;\n\t\t\tds->first_dts = rep->dasher_ctx->first_dts;\n\t\t\tds->ts_offset = rep->dasher_ctx->ts_offset;\n\t\t\tds->est_next_dts = rep->dasher_ctx->est_next_dts;\n\t\t\tds->mpd_timescale = rep->dasher_ctx->mpd_timescale;\n\t\t\tds->cumulated_dur = (u64) (rep->dasher_ctx->cumulated_dur * ds->timescale);\n\t\t\tds->cumulated_subdur = rep->dasher_ctx->cumulated_subdur;\n\t\t\tds->rep_init = GF_TRUE;\n\t\t\tds->subdur_done = rep->dasher_ctx->subdur_forced ? GF_TRUE : GF_FALSE;\n\t\t\tds->subdur_forced_use_period_dur = 0;\n\t\t\tds->nb_pck = 0;\n\t\t\tif (!ctx->subdur) {\n\t\t\t\tds->nb_pck = ds->seek_to_pck;\n\t\t\t\tds->seek_to_pck = 0;\n\t\t\t}\n\t\t\tds->nb_segments_purged = rep->dasher_ctx->segs_purged;\n\t\t\tds->dur_purged = rep->dasher_ctx->dur_purged;\n\t\t\tds->moof_sn = rep->dasher_ctx->moof_sn;\n\t\t\tds->moof_sn_inc = rep->dasher_ctx->moof_sn_inc;\n\t\t\tctx->last_dyn_period_id = rep->dasher_ctx->last_dyn_period_id;\n\n\t\t\tif (ctx->store_seg_states && !ds->pending_segment_states)\n\t\t\t\tds->pending_segment_states = gf_list_new();\n\n\t\t\tif (rep->segment_list && !ds->pending_segment_urls)\n\t\t\t\tds->pending_segment_urls = gf_list_new();\n\n\t\t\tds->owns_set = rep->dasher_ctx->owns_set;\n\t\t\tif (ds->owns_set) set_ds = ds;\n\n\t\t\tif (rep->dasher_ctx->done) {\n\t\t\t\tds->done = 1;\n\t\t\t\tif (ds->rep) gf_mpd_representation_free(ds->rep);\n\t\t\t\tds->rep = NULL;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tds->nb_comp = 1;\n\n\t\t\tif (ds->rep) gf_mpd_representation_free(ds->rep);\n\t\t\tds->rep = rep;\n\t\t\tds->set = set;\n\t\t\trep->playback.udta = ds;\n\t\t\tif (ds->owns_set)\n\t\t\t\tset->udta = ds;\n\t\t\tif (rep->dasher_ctx->multi_pids)\n\t\t\t\tuse_multi_pid_init = GF_TRUE;\n\n\t\t\tds->period = ctx->current_period;\n\t\t\tif ((ds->codec_id==GF_CODECID_MHAS) || (ds->codec_id==GF_CODECID_MPHA)) {\n\t\t\t\tconst GF_PropertyValue *prop = gf_filter_pid_get_property(ds->ipid, GF_PROP_PID_MHA_COMPATIBLE_PROFILES);\n\t\t\t\tif (prop) {\n\t\t\t\t\tds->set->nb_alt_mha_profiles = prop->value.uint_list.nb_items;\n\t\t\t\t\tds->set->alt_mha_profiles = prop->value.uint_list.vals;\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t\tgf_list_del_item(ctx->next_period->streams, ds);\n\n\t\t\t//non-muxed component or main comp of muxed goes first in the list\n\t\t\tif (ds->nb_comp>1) {\n\t\t\t\tgf_list_insert(ctx->current_period->streams, ds, 0);\n\t\t\t} else {\n\t\t\t\tgf_list_add(ctx->current_period->streams, ds);\n\t\t\t}\n\n\t\t\tif (rep->dasher_ctx->mux_pids) {\n\t\t\t\te = dasher_reload_muxed_comp(ctx, ds, rep->dasher_ctx->mux_pids, GF_FALSE);\n\t\t\t\tif (e) return e;\n\t\t\t}\n\t\t}\n\t\tassert(set_ds);\n\t\tset_ds->nb_rep = gf_list_count(set->representations);\n\n\t\t//if multi PID init, gather pids\n\t\tif (use_multi_pid_init) {\n\t\t\tmulti_pids = gf_list_new();\n\t\t\tfor (i=0; i<nb_rep; i++) {\n\t\t\t\tGF_MPD_Representation *rep = gf_list_get(set->representations, i);\n\t\t\t\tGF_DashStream *ds = rep->playback.udta;\n\t\t\t\tif (ds->owns_set) ds->multi_pids = multi_pids;\n\t\t\t\tgf_list_add(multi_pids, ds->ipid);\n\t\t\t}\n\t\t}\n\t\tcount = gf_list_count(ctx->current_period->streams);\n\t\tfor (i=0; i<nb_rep; i++) {\n\t\t\tGF_MPD_Representation *rep = gf_list_get(set->representations, i);\n\t\t\tGF_DashStream *ds = rep->playback.udta;\n\t\t\tif (!ds || ds->done) continue;\n\t\t\t//happens when reloading context without closing the filter\n\t\t\tif (ds->dst_filter || ds->opid) continue;\n\n\t\t\t//open destination, trashing init\n\t\t\tassert(!ds->muxed_base);\n\t\t\tdasher_open_destination(filter, ctx, rep, ds->init_seg, GF_TRUE);\n\n\t\t\tdasher_open_pid(filter, ctx, ds, multi_pids, GF_TRUE);\n\n\t\t\tfor (j=0; j<count; j++) {\n\t\t\t\tGF_DashStream *a_ds = gf_list_get(ctx->current_period->streams, j);\n\t\t\t\tif (a_ds->muxed_base != ds) continue;\n\n\t\t\t\tdasher_open_pid(filter, ctx, a_ds, multi_pids, GF_TRUE);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn GF_OK;\n}\n\nstatic void dasher_udpate_periods_and_manifest(GF_Filter *filter, GF_DasherCtx *ctx)\n{\n\tif (!ctx->subdur_done) {\n\t\tctx->last_dyn_period_id++;\n\t\tctx->next_pid_id_in_period = 0;\n\t}\n\t//update duration\n\tdasher_update_period_duration(ctx, GF_TRUE);\n\n\tif (ctx->state)\n\t\tdasher_context_update_period_end(ctx);\n\n\t//we have a MPD ready, flush it\n\tif (!ctx->gencues && ctx->mpd)\n\t\tdasher_send_manifest(filter, ctx, GF_FALSE);\n}\n\ntypedef struct\n{\n\tGF_Fraction64 period_start;\n\tconst char *period_id;\n} PeriodInfo;\n\nstatic u32 dasher_period_count(GF_List *streams_in /*GF_DashStream*/)\n{\n\tu32 nb_periods, i, j;\n\tPeriodInfo *info;\n\tGF_List *pinfos = gf_list_new();\n\n\tfor (i=0; i < gf_list_count(streams_in); i++) {\n\t\tBool same_period = GF_FALSE;\n\t\tGF_DashStream *ds = gf_list_get(streams_in, i);\n\t\t//check if we already have a period info with same ID or same start time\n\t\tnb_periods = gf_list_count(pinfos);\n\t\tfor (j=0; j < nb_periods; j++) {\n\t\t\tinfo = gf_list_get(pinfos, j);\n\t\t\tif (info->period_start.num * ds->period_start.den == ds->period_start.num * info->period_start.den) {\n\t\t\t\tsame_period = GF_TRUE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (info->period_id && ds->period_id && !strcmp(info->period_id, ds->period_id)) {\n\t\t\t\tsame_period = GF_TRUE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t//nope, register it\n\t\tif (!same_period) {\n\t\t\tGF_SAFEALLOC(info, PeriodInfo);\n\t\t\tif (info) {\n\t\t\t\tinfo->period_start = ds->period_start;\n\t\t\t\tinfo->period_id = ds->period_id;\n\t\t\t\tgf_list_add(pinfos, info);\n\t\t\t}\n\t\t}\n\t}\n\tnb_periods = gf_list_count(pinfos);\n\twhile (1) {\n\t\tinfo = gf_list_pop_back(pinfos);\n\t\tif (!info) break;\n\t\tgf_free(info);\n\t}\n\tgf_list_del(pinfos);\n\n\treturn nb_periods;\n}\n\nstatic void dasher_init_utc(GF_Filter *filter, GF_DasherCtx *ctx)\n{\n\tu8 *data=NULL;\n\tu64 remote_utc;\n#ifdef GPAC_USE_DOWNLOADER\n\tGF_Err e;\n\tconst char *cache_name;\n\tu32 size;\n#endif\n\tGF_DownloadManager *dm;\n\tchar *url;\n\tDasherUTCTimingType def_type = DASHER_UTCREF_NONE;\n\n\tctx->utc_initialized = GF_TRUE;\n\tctx->utc_timing_type = DASHER_UTCREF_NONE;\n\tif (!ctx->utcs) {\n\t\treturn;\n\t}\n\turl = ctx->utcs;\n\tif (!strncmp(url, \"xsd@\", 4)) {\n\t\tdef_type = DASHER_UTCREF_XSDATE;\n\t\turl += 4;\n\t}\n\n\tif (!strcmp(ctx->utcs, \"inband\")) {\n\t\tctx->utc_timing_type = DASHER_UTCREF_INBAND;\n\t\treturn;\n\t}\n#ifndef GPAC_USE_DOWNLOADER\n\tGF_LOG(GF_LOG_WARNING, GF_LOG_DASH, (\"[DASH] No download manager, cannot sync to remote UTC clock\\n\"));\n\tctx->utc_timing_type = DASHER_UTCREF_NONE;\n\treturn;\n#else\n\t//create session\n\tif (!ctx->utc_sess) {\n\t\tdm  = gf_filter_get_download_manager(filter);\n\t\tif (!dm) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_DASH, (\"[DASH] Failed to get download manager, cannot sync to remote UTC clock\\n\"));\n\t\t\treturn;\n\t\t}\n\t\tctx->utc_sess = gf_dm_sess_new(dm, url, GF_NETIO_SESSION_MEMORY_CACHE, NULL, NULL, &e);\n\t\tif (e) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_DASH, (\"[DASH] Failed to create session for remote UTC source %s: %s - local clock will be used instead\\n\", url, gf_error_to_string(e) ));\n\t\t\treturn;\n\t\t}\n\t\te = gf_dm_sess_process(ctx->utc_sess);\n\t\tif (e==GF_IP_NETWORK_EMPTY) {\n\t\t\tctx->utc_initialized = GF_FALSE;\n\t\t\treturn;\n\t\t}\n\t}\n\t//check we are done\n\tGF_NetIOStatus status;\n\te = gf_dm_sess_get_stats(ctx->utc_sess, NULL, NULL, NULL, NULL, NULL, &status);\n\tif (status==GF_NETIO_DATA_TRANSFERED) e = GF_OK;\n\telse if (status==GF_NETIO_DATA_EXCHANGE) e = GF_NOT_READY;\n\telse if (status==GF_NETIO_STATE_ERROR) {}\n\telse if ((status==GF_NETIO_DISCONNECTED) && (e>=GF_OK))\n\t\te = GF_OK;\n\telse\n\t\te = GF_NOT_READY;\n\n\tif (e==GF_NOT_READY) {\n\t\tctx->utc_initialized = GF_FALSE;\n\t\treturn;\n\t}\n\tif (e<0) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_DASH, (\"[DASH] Failed to fetch remote UTC source %s: %s\\n\", url, gf_error_to_string(e) ));\n\t\tgf_dm_sess_del(ctx->utc_sess);\n\t\tctx->utc_sess = NULL;\n\t\treturn;\n\t}\n\tcache_name = gf_dm_sess_get_cache_name(ctx->utc_sess);\n\tgf_blob_get(cache_name, &data, &size, NULL);\n\n\tif (data) {\n\t\t//xsDate or isoDate - we always signal using iso\n\t\tif (strchr(data, 'T')) {\n\t\t\tremote_utc = gf_net_parse_date(data);\n\t\t\tif (remote_utc)\n\t\t\t\tctx->utc_timing_type = def_type ? def_type : DASHER_UTCREF_ISO;\n\t\t}\n\t\t//ntp\n\t\telse if (sscanf(data, LLU, &remote_utc) == 1) {\n\t\t\t//ntp value not counted since 1900, assume format is seconds till 1 jan 1970\n\t\t\tif (remote_utc<=GF_NTP_SEC_1900_TO_1970) {\n\t\t\t\tremote_utc = remote_utc*1000;\n\t\t\t} else {\n\t\t\t\tremote_utc = gf_net_ntp_to_utc(remote_utc);\n\t\t\t}\n\t\t\tif (remote_utc)\n\t\t\t\tctx->utc_timing_type = DASHER_UTCREF_NTP;\n\t\t}\n\t}\n\tgf_blob_release(cache_name);\n\n\t//not match, try http date\n\tif (!ctx->utc_timing_type) {\n\t\tconst char *hdr = gf_dm_sess_get_header(ctx->utc_sess, \"Date\");\n\t\tif (hdr) {\n\t\t\t//http-head\n\t\t\tremote_utc = gf_net_parse_date(hdr);\n\t\t\tif (remote_utc)\n\t\t\t\tctx->utc_timing_type = DASHER_UTCREF_HTTP_HEAD;\n\t\t}\n\t}\n\n\tif (!ctx->utc_timing_type) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_DASH, (\"[DASH] Failed to parse response %s from remote UTC source %s\\n\", data, url ));\n\t} else {\n\t\tctx->utc_diff = (s32) ( (s64) gf_net_get_utc() - (s64) remote_utc );\n\t\tif (ABS(ctx->utc_diff) > 3600000) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_DASH, (\"[Dasher] Diff between local clock and remote %s is %d, way too large! Assuming 0 ms UTC diff\\n\", url, ctx->utc_diff));\n\t\t\tctx->utc_diff = 0;\n\t\t} else {\n\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_DASH, (\"[Dasher] Synchronized clock to remote %s - UTC diff (local - remote) %d ms\\n\", url, ctx->utc_diff));\n\t\t}\n\t}\n\tgf_dm_sess_del(ctx->utc_sess);\n#endif\n}\n\n\nstatic GF_Err dasher_switch_period(GF_Filter *filter, GF_DasherCtx *ctx)\n{\n\tu32 i, count, nb_done;\n\tchar *period_id;\n\tconst char *remote_xlink = NULL;\n\tconst char *period_xlink = NULL;\n\tu64 remote_dur = 0;\n\tGF_DasherPeriod *p;\n\tGF_Fraction64 period_start, next_period_start;\n\tGF_DashStream *first_in_period=NULL;\n\tp = ctx->current_period;\n\n\tif (!ctx->gencues) {\n\t\tif (!ctx->out_path) {\n\t\t\tdasher_check_outpath(ctx);\n\t\t}\n\t\tif (ctx->current_period->period) {\n\t\t\tif (ctx->dyn_rate)\n\t\t\t\tdasher_update_dyn_bitrates(ctx);\n\n\t\t\tdasher_udpate_periods_and_manifest(filter, ctx);\n\t\t}\n\t}\n\n\tif (ctx->subdur_done || (ctx->current_period->period && (ctx->dmode == GF_MPD_TYPE_DYNAMIC_LAST)) )\n\t\treturn GF_EOS;\n\n\tif (ctx->current_period->period) {\n\t\tGF_LOG(GF_LOG_INFO, GF_LOG_DASH, (\"[Dasher] End of Period %s\\n\", ctx->current_period->period->ID ? ctx->current_period->period->ID : \"\"));\n\t}\n\tctx->is_period_restore = GF_FALSE;\n\tctx->is_empty_period = GF_FALSE;\n\n\t//safety check at period switch, probe each first packet in case we have a reconfigure pending\n\tcount = gf_list_count(ctx->pids);\n\tfor (i=0; i<count;i++) {\n\t\tGF_DashStream *ds = gf_list_get(ctx->pids, i);\n\t\tgf_filter_pid_get_packet(ds->ipid);\n\t}\n\n\t//reset - don't destroy, it is in the MPD\n\tctx->current_period->period = NULL;\n\t//switch\n\tctx->current_period = ctx->next_period;\n\tctx->next_period = p;\n\tctx->on_demand_done = GF_FALSE;\n\tctx->min_segment_start_time = ctx->last_min_segment_start_time = 0;\n\n\t//reset input pids and detach output pids\n\tcount = gf_list_count(ctx->current_period->streams);\n\tfor (i=0; i<count;i++) {\n\t\tGF_DashStream *ds = gf_list_get(ctx->current_period->streams, i);\n\t\tif (ds->opid && !ctx->gencues) {\n\t\t\tgf_filter_pid_remove(ds->opid);\n\t\t\tds->opid = NULL;\n\t\t}\n\t\tdasher_reset_stream(filter, ds, GF_FALSE);\n\t\tif (ds->reschedule) {\n\t\t\tds->reschedule = GF_FALSE;\n\t\t\tds->done = 0;\n\t\t}\n\t}\n\n\t//figure out next period\n\tcount = gf_list_count(ctx->current_period->streams);\n\tctx->period_idx = 0;\n\tperiod_start.num = -1;\n\tperiod_start.den = 1;\n\tfor (i=0; i<count; i++) {\n\t\tGF_DashStream *ds = gf_list_get(ctx->current_period->streams, i);\n\n\t\tif (ds->done) continue;\n\t\tif (ds->period_start.num < 0) {\n\t\t\ts32 pstart = (s32) -ds->period_start.num;\n\t\t\tif (!ctx->period_idx || (pstart < ctx->period_idx)) ctx->period_idx = pstart;\n\t\t} else {\n\t\t\tif ((period_start.num<0) || (ds->period_start.num * period_start.den < period_start.num * ds->period_start.den)) {\n\t\t\t\tperiod_start = ds->period_start;\n\t\t\t\tassert(ds->period_start.den);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (period_start.num >= 0)\n\t\tctx->period_idx = 0;\n\n\tif (ctx->first_context_load) {\n\t\tGF_Err e = dasher_reload_context(filter, ctx);\n\t\tif (e) {\n\t\t\tctx->setup_failure = e;\n\t\t\treturn e;\n\t\t}\n\t\tif (ctx->current_period->period) ctx->is_period_restore = GF_TRUE;\n\n\t\tif (ctx->dmode==GF_DASH_DYNAMIC_LAST) {\n\t\t\tdasher_udpate_periods_and_manifest(filter, ctx);\n\t\t\tcount = gf_list_count(ctx->pids);\n\t\t\tfor (i=0; i<count; i++) {\n\t\t\t\tGF_DashStream *ds = gf_list_get(ctx->pids, i);\n\t\t\t\tgf_filter_pid_set_discard(ds->ipid, GF_TRUE);\n\t\t\t}\n\t\t\treturn GF_EOS;\n\t\t}\n\t}\n\n\t//filter out PIDs not for this period\n\tcount = gf_list_count(ctx->current_period->streams);\n\tperiod_id = NULL;\n\tfor (i=0; i<count; i++) {\n\t\tBool in_period=GF_TRUE;\n\t\tGF_DashStream *ds = gf_list_get(ctx->current_period->streams, i);\n\n\t\tif (ds->done) {\n\t\t\tin_period=GF_FALSE;\n\t\t} else if (!period_id) {\n\t\t\tperiod_id = ds->period_id;\n\t\t\tfirst_in_period = ds;\n\t\t} else if (strcmp(period_id, ds->period_id)) {\n\t\t\tin_period = GF_FALSE;\n\t\t}\n\t\tif (in_period) {\n\t\t\tif ((period_start.num>=0) && (ds->period_start.num * period_start.den != period_start.num * ds->period_start.den))\n\t\t\t\tin_period = GF_FALSE;\n\t\t\telse if ((ctx->period_idx>0) && ((s32) -ds->period_start.num != ctx->period_idx))\n\t\t\t\tin_period = GF_FALSE;\n\n\t\t\tif (!in_period && (first_in_period == ds))\n\t\t\t\tperiod_id = NULL;\n\t\t}\n\n\t\t//if not in period, move to next period\n\t\tif (!in_period) {\n\t\t\tgf_list_rem(ctx->current_period->streams, i);\n\t\t\ti--;\n\t\t\tcount--;\n\t\t\tds->period = NULL;\n\t\t\tgf_list_add(ctx->next_period->streams, ds);\n\t\t\tcontinue;\n\t\t}\n\t\tif (ds->stream_type == GF_STREAM_FILE) {\n\t\t\tif (ds->xlink) remote_xlink = ds->xlink;\n\t\t\telse ctx->is_empty_period = GF_TRUE;\n\t\t\tremote_dur = 0;\n\t\t\tif (ds->period_dur.den)\n\t\t\t\tremote_dur = (u64) (ds->period_dur.num * 1000) / ds->period_dur.den;\n\t\t} else if (!ctx->is_period_restore) {\n\t\t\tif (ds->xlink)\n\t\t\t\tperiod_xlink = ds->xlink;\n\n\t\t\tif (ctx->post_play_events) {\n\t\t\t\tGF_FilterEvent evt;\n\n\t\t\t\tGF_FEVT_INIT(evt, GF_FEVT_STOP, ds->ipid);\n\t\t\t\tgf_filter_pid_send_event(ds->ipid, &evt);\n\n\t\t\t\tgf_filter_pid_set_discard(ds->ipid, GF_FALSE);\n\n\t\t\t\tdasher_send_encode_hints(ctx, ds);\n\n\t\t\t\tGF_FEVT_INIT(evt, GF_FEVT_PLAY, ds->ipid);\n\t\t\t\tevt.play.speed = 1.0;\n\t\t\t\tgf_filter_pid_send_event(ds->ipid, &evt);\n\t\t\t}\n\t\t}\n\t}\n\tctx->post_play_events = GF_FALSE;\n\n\tcount = gf_list_count(ctx->current_period->streams);\n\tif (!count) {\n\t\tcount = gf_list_count(ctx->next_period->streams);\n\t\tnb_done = 0;\n\t\tfor (i=0; i<count; i++)\t {\n\t\t\tGF_DashStream *ds = gf_list_get(ctx->next_period->streams, i);\n\t\t\tif (ds->done) nb_done++;\n\t\t}\n\t\tif (nb_done == count) {\n\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_DASH, (\"[Dasher] End of MPD (no more active streams)\\n\"));\n\t\t\tctx->on_demand_done = GF_TRUE;\n\t\t\treturn GF_EOS;\n\t\t}\n\t}\n\n\t//we need a new period unless created during reload, create it\n\tif (!ctx->is_period_restore) {\n\t\tctx->current_period->period = gf_mpd_period_new();\n\t\tif (!ctx->mpd) dasher_setup_mpd(ctx);\n\t\tgf_list_add(ctx->mpd->periods, ctx->current_period->period);\n\t}\n\n\n\tif (remote_xlink) {\n\t\tctx->current_period->period->xlink_href = gf_strdup(remote_xlink);\n\t\tctx->current_period->period->duration = remote_dur;\n\t}\n\telse if (period_xlink) {\n\t\tctx->current_period->period->xlink_href = gf_strdup(period_xlink);\n\t}\n\n\n\tassert(period_id);\n\n\tnext_period_start.num = -1;\n\tnext_period_start.den = 1;\n\tif (period_start.num >= 0) {\n\t\tctx->current_period->period->start = (u64)(period_start.num*1000 / period_start.den);\n\t\t//check next period start\n\t\tcount = gf_list_count(ctx->next_period->streams);\n\t\tfor (i=0; i<count; i++)\t {\n\t\t\tGF_DashStream *ds = gf_list_get(ctx->next_period->streams, i);\n\t\t\tif (ds->done) continue;\n\t\t\tif (ds->period_start.num * period_start.den < period_start.num * ds->period_start.den) continue;\n\t\t\tif ((next_period_start.num<0) || (next_period_start.num * ds->period_start.den > ds->period_start.num * next_period_start.den)) {\n\t\t\t\tnext_period_start = ds->period_start;\n\t\t\t}\n\t\t}\n\t\t//check current period dur\n\t\tcount = gf_list_count(ctx->current_period->streams);\n\t\tfor (i=0; i<count; i++)\t {\n\t\t\tGF_Fraction64 dur;\n\t\t\tGF_DashStream *ds = gf_list_get(ctx->current_period->streams, i);\n\t\t\tif (!ds->period_dur.den) continue;\n\t\t\tdur = period_start;\n\t\t\tif (ds->period_dur.den) {\n\t\t\t\tif (dur.den != ds->period_dur.den)\n\t\t\t\t\tdur.num += ds->period_dur.num * dur.den / ds->period_dur.den;\n\t\t\t\telse\n\t\t\t\t\tdur.num += ds->period_dur.num;\n\t\t\t}\n\t\t\t\n\t\t\tif ((next_period_start.num < 0) || (next_period_start.num * dur.den > dur.num * next_period_start.den))\n\t\t\t\tnext_period_start = dur;\n\t\t}\n\t\tif (next_period_start.num > 0) {\n\t\t\tu64 next = next_period_start.num;\n\t\t\tif (next_period_start.den != period_start.den) {\n\t\t\t\tnext *= period_start.den;\n\t\t\t\tnext /= next_period_start.den;\n\t\t\t}\n\t\t\tctx->current_period->period->duration = (u32) ( (next - period_start.num) * 1000 / period_start.den);\n\t\t}\n\t}\n\n\t//assign period ID if none specified\n\tif (strcmp(period_id, DEFAULT_PERIOD_ID))\n\t\tctx->current_period->period->ID = gf_strdup(period_id);\n\t//assign ID if dynamic - if dash_ctx also assign ID since we could have moved from dynamic to static\n\telse if (!ctx->current_period->period->ID && ((ctx->dmode != GF_MPD_TYPE_STATIC) || ctx->state) ) {\n\t\tchar szPName[50];\n\t\tsprintf(szPName, \"DID%d\", ctx->last_dyn_period_id + 1);\n\t\tctx->current_period->period->ID = gf_strdup(szPName);\n\t}\n\n\t//check all streams are ready\n\tctx->period_not_ready = GF_FALSE;\n\tcount = gf_list_count(ctx->current_period->streams);\n\tfor (i=0; i<count; i++) {\n\t\tGF_DashStream *ds = gf_list_get(ctx->current_period->streams, i);\n\t\t//assign force_rep_end\n\t\tif (next_period_start.num > 0) {\n\t\t\tu64 next = next_period_start.num;\n\t\t\tif (next_period_start.den != period_start.den) {\n\t\t\t\tnext *= period_start.den;\n\t\t\t\tnext /= next_period_start.den;\n\t\t\t}\n\n\t\t\tds->force_rep_end = (u64) ((next - period_start.num) * ds->timescale / period_start.den);\n\t\t}\n\t\tif (ds->dcd_not_ready) {\n\t\t\tctx->period_not_ready = GF_TRUE;\n\t\t}\n\t}\n\t//not all streams are ready, cannot setup period yet\n\tif (ctx->period_not_ready)\n\t\treturn GF_OK;\n\n\treturn dasher_setup_period(filter, ctx, NULL);\n}\n\nstatic GF_Err dasher_setup_period(GF_Filter *filter, GF_DasherCtx *ctx, GF_DashStream *inject_ds)\n{\n\tu32 i, count, j, nb_sets;\n\tBool has_muxed_bases=GF_FALSE;\n\tconst char *remote_xlink = NULL;\n\tBool has_as_id = GF_FALSE;\n\tBool has_deps = GF_FALSE;\n\tconst GF_PropertyValue *prop;\n\tGF_Fraction64 min_dur, min_adur, max_adur;\n\tu32 srd_rep_idx;\n\n\tctx->dyn_rate = GF_FALSE;\n\tctx->use_cues = GF_FALSE;\n\tmin_dur.num = min_adur.num = max_adur.num = 0;\n\tmin_dur.den = min_adur.den = max_adur.den = 1;\n\tsrd_rep_idx = 2; //2 for compat with old arch\n\tctx->min_cts_period.num = 0;\n\tctx->min_cts_period.den = 0;\n\n\tcount = gf_list_count(ctx->current_period->streams);\n\t//setup representations\n\tfor (i=0; i<count; i++) {\n\t\tGF_DashStream *ds = gf_list_get(ctx->current_period->streams, i);\n\t\tif (inject_ds && (ds != inject_ds))\n\t\t\tcontinue;\n\n\t\tif (ds->stream_type == GF_STREAM_FILE) {\n\t\t\tif (ds->xlink) remote_xlink = ds->xlink;\n\t\t} else if (!ctx->is_period_restore) {\n\t\t\t//setup representation - the representation is created independently from the period\n\t\t\tdasher_setup_rep(ctx, ds, &srd_rep_idx);\n\t\t}\n\t}\n\n\t//setup representation dependency / components (muxed)\n\tfor (i=0; i<count; i++) {\n\t\tBool remove = GF_FALSE;\n\t\tGF_DashStream *ds_video=NULL;\n\t\tGF_DashStream *ds = gf_list_get(ctx->current_period->streams, i);\n\t\tif (inject_ds && (ds != inject_ds))\n\t\t\tcontinue;\n\n\t\tds->period = ctx->current_period;\n\t\tds->last_period = ds->period->period;\n\n\t\tif (ds->dyn_bitrate) ctx->dyn_rate = GF_TRUE;\n\t\tif (ds->inband_cues || ds->cues)\n\t\t\tctx->use_cues = GF_TRUE;\n\n\t\tif (ctx->loop) {\n\t\t\tprop = gf_filter_pid_get_property(ds->ipid, GF_PROP_PID_DURATION);\n\t\t\t//only check true media dur\n\t\t\tif (prop && prop->value.lfrac.den && (prop->value.lfrac.num>0)) {\n\t\t\t\tGF_Fraction64 d;\n\t\t\t\td.num = prop->value.lfrac.num;\n\t\t\t\td.den = prop->value.lfrac.den;\n\t\t\t\tif (ds->clamped_dur.num && (ds->clamped_dur.num * d.den < d.num * ds->clamped_dur.den)) {\n\t\t\t\t\td = ds->clamped_dur;\n\t\t\t\t}\n\n\t\t\t\tif (ds->stream_type == GF_STREAM_AUDIO) {\n\t\t\t\t\tif (d.num * max_adur.den > max_adur.num * d.den) max_adur = d;\n\t\t\t\t\tif (!min_adur.num || (d.num * min_adur.den < min_adur.num * d.den)) min_adur = d;\n\t\t\t\t} else {\n\t\t\t\t\tif (!min_dur.num || (d.num * min_dur.den < min_dur.num * d.den)) min_dur = d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (ds->stream_type == GF_STREAM_FILE) {\n\t\t\tremove = GF_TRUE;\n\t\t} else if (remote_xlink) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_DASH, (\"[Dasher] period uses xlink but other media source %s, ignoring source\\n\", ds->src_url));\n\t\t\tremove = GF_TRUE;\n\t\t} else if (ctx->is_empty_period) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_DASH, (\"[Dasher] empty period defined but other media source %s, ignoring source\\n\", ds->src_url));\n\t\t\tremove = GF_TRUE;\n\t\t}\n\n\t\tif (remove) {\n\t\t\tds->done = 1;\n\t\t\tds->period = NULL;\n\t\t\tgf_list_rem(ctx->current_period->streams, i);\n\t\t\tgf_list_add(ctx->next_period->streams, ds);\n\t\t\ti--;\n\t\t\tcount--;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (ctx->gencues)\n\t\t\tds->set_period_switch = GF_TRUE;\n\n\t\tif (ctx->is_period_restore) continue;\n\n\t\t//add period descriptors\n\t\tdasher_add_descriptors(&ctx->current_period->period->x_children, ds->p_period_desc);\n\t\t//add representation descriptors\n\t\tdasher_add_descriptors(&ds->rep->x_children, ds->p_rep_desc);\n\n\t\tif (ds->muxed_base) continue;\n\n\t\tif (ds->stream_type==GF_STREAM_VISUAL)\n\t\t\tds_video = ds;\n\n\t\tds->skip_tpl_reuse = GF_FALSE;\n\t\t// period resume (end of content replacement/splice/...): if using templates, check if period ID is used, if not force startNumber to resume\n\t\tprop = gf_filter_pid_get_property_str(ds->ipid, \"period_resume\");\n\t\tif (prop && prop->value.string && ctx->tpl && ds->mpd_timescale) {\n\t\t\tchar *template = ds->template;\n\t\t\tif (!template) template = ctx->template;\n\t\t\tif (\n\t\t\t\t//undefined period name\n\t\t\t\t!prop->value.string[0]\n\t\t\t\t//template dor not resolve against period name\n\t\t\t\t|| (template && !strstr(template, \"$Period$\"))\n\t\t\t) {\n\t\t\t\tu64 seg_duration = (u64)(ds->dash_dur.num) * ds->mpd_timescale / ds->dash_dur.den;\n\t\t\t\tu64 period_start = ds->mpd_timescale * ctx->mpd->media_presentation_duration / 1000;\n\t\t\t\tu64 num = period_start / seg_duration;\n\t\t\t\tif (num * seg_duration < period_start)\n\t\t\t\t\tnum++;\n\t\t\t\tds->startNumber = (u32) (num+1);\n\t\t\t\tds->skip_tpl_reuse = GF_TRUE;\n\t\t\t}\n\t\t}\n\n\t\tds->nb_comp = 1;\n\n\t\tfor (j=0; j<count; j++) {\n\t\t\tGF_DashStream *a_ds;\n\t\t\tif (i==j) continue;\n\t\t\ta_ds = gf_list_get(ctx->current_period->streams, j);\n\t\t\tif (a_ds->dep_id && (a_ds->src_id==ds->src_id) && (a_ds->dep_id==ds->id) ) {\n\t\t\t\tgf_list_add(ds->complementary_streams, a_ds);\n\t\t\t\thas_deps = GF_TRUE;\n\t\t\t\tif (!a_ds->rep->dependency_id) {\n\t\t\t\t\ta_ds->rep->dependency_id = gf_strdup(ds->rep->id);\n\t\t\t\t}\n\t\t\t}\n\t\t\t//check if this rep should be muxed: same rep ID, not raw format, not CMAF\n\t\t\tif (a_ds->muxed_base) {\n\t\t\t\t//happens when we switch base_ds to use video one\n\t\t\t\tif (a_ds->muxed_base == ds) ds->nb_comp++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (ctx->muxtype==DASHER_MUX_RAW) continue;\n\t\t\tif (ctx->cmaf) continue;\n\t\t\tif (strcmp(a_ds->rep_id, ds->rep_id)) continue;\n\t\t\telse if (ctx->sigfrag) {\n\t\t\t\tif (a_ds->src_url && ds->src_url && strcmp(a_ds->src_url, ds->src_url)) continue;\n\t\t\t}\n\t\t\tif (a_ds->template && ds->template && strcmp(a_ds->template, ds->template)) continue;\n\n\n\t\t\tif (!ds_video && (a_ds->stream_type==GF_STREAM_VISUAL))\n\t\t\t\tds_video = a_ds;\n\n\t\t\ta_ds->muxed_base = ds;\n\t\t\ta_ds->dash_dur = ds->dash_dur;\n\t\t\thas_muxed_bases = GF_TRUE;\n\t\t\tds->nb_comp++;\n\n\t\t\tif (ctx->bs_switch==DASHER_BS_SWITCH_MULTI) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_DASH, (\"[Dasher] Bitstream Swicthing mode \\\"multi\\\" is not supported with multiplexed representations, disabling bitstream switching\\n\"));\n\t\t\t\tctx->bs_switch = DASHER_BS_SWITCH_OFF;\n\t\t\t}\n\t\t\tif (!ds->rep->codecs || !strstr(ds->rep->codecs, a_ds->rep->codecs)) {\n\t\t\t\tgf_dynstrcat(&ds->rep->codecs, a_ds->rep->codecs, \",\");\n\t\t\t}\n\n\t\t\tif (ctx->profile == GF_DASH_PROFILE_AVC264_LIVE) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_DASH, (\"[Dasher] Muxed representations not allowed in DASH-IF AVC264 live profile\\n\\tswitching to regular live profile\\n\"));\n\t\t\t\tctx->profile = GF_DASH_PROFILE_LIVE;\n\t\t\t} else if (ctx->profile == GF_DASH_PROFILE_HBBTV_1_5_ISOBMF_LIVE) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_DASH, (\"[Dasher] Muxed representations not allowed in HbbTV 1.5 ISOBMFF live profile\\n\\tswitching to regular live profile\\n\"));\n\t\t\t\tctx->profile = GF_DASH_PROFILE_LIVE;\n\t\t\t} else if (ctx->profile == GF_DASH_PROFILE_AVC264_ONDEMAND) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_DASH, (\"[Dasher] Muxed representations not allowed in DASH-IF AVC264 onDemand profile\\n\\tswitching to regular onDemand profile\\n\"));\n\t\t\t\tctx->profile = GF_DASH_PROFILE_ONDEMAND;\n\t\t\t} else if (ctx->profile == GF_DASH_PROFILE_DASHIF_LL) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_DASH, (\"[Dasher] Muxed representations not allowed in DASH-IF Low Latency profile\\n\\tswitching to regular live profile\\n\"));\n\t\t\t\tctx->profile = GF_DASH_PROFILE_LIVE;\n\t\t\t}\n\t\t}\n\t\t//use video as main stream for segmentation of muxed sources\n\t\tif (ds_video && (ds_video != ds)) {\n\t\t\tu32 nb_comp = ds->nb_comp;\n\t\t\tfor (j=0; j<count; j++) {\n\t\t\t\tGF_DashStream *a_ds = gf_list_get(ctx->current_period->streams, j);\n\t\t\t\tif ((a_ds->muxed_base==ds) || (a_ds==ds)) {\n\t\t\t\t\tif (a_ds == ds_video) {\n\t\t\t\t\t\ta_ds->muxed_base = NULL;\n\t\t\t\t\t\ta_ds->nb_comp = nb_comp;\n\t\t\t\t\t\tif (a_ds->rep->codecs) gf_free(a_ds->rep->codecs);\n\t\t\t\t\t\ta_ds->rep->codecs = ds->rep->codecs;\n\t\t\t\t\t\tds->rep->codecs = NULL;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ta_ds->muxed_base = ds_video;\n\t\t\t\t\t\ta_ds->nb_comp = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ((u32) ds->dash_dur.num * 1000 > ctx->def_max_seg_dur * ds->dash_dur.den )\n\t\t\tctx->def_max_seg_dur = (u32) ((ds->dash_dur.num * 1000) / ds->dash_dur.den);\n\t}\n\n\tif (ctx->sigfrag) {\n\t\tBool has_rep_conflict = GF_FALSE;\n\t\t//make sure all representation have unique ids\n\t\tfor (i=0; i<count; i++) {\n\t\t\tu32 nb_changed=0;\n\t\t\tGF_DashStream *ds = gf_list_get(ctx->current_period->streams, i);\n\t\t\tif (ds->muxed_base) continue;\n\t\t\tfor (j=0; j<count; j++) {\n\t\t\t\tchar szRep[20];\n\t\t\t\tGF_DashStream *a_ds;\n\t\t\t\tif (j == i) continue;\n\t\t\t\ta_ds = gf_list_get(ctx->current_period->streams, j);\n\t\t\t\tif (a_ds->muxed_base) continue;\n\n\t\t\t\tif (strcmp(ds->rep_id, a_ds->rep_id)) continue;\n\t\t\t\tif (ds->template && strstr(ds->template, \"$RepresentationID$\")) {\n\t\t\t\t\thas_rep_conflict = GF_TRUE;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tnb_changed++;\n\t\t\t\tsprintf(szRep, \"%d\", nb_changed);\n\t\t\t\tgf_free(a_ds->rep_id);\n\t\t\t\ta_ds->rep_id = NULL;\n\t\t\t\tgf_dynstrcat(&a_ds->rep_id, ds->rep_id, NULL);\n\t\t\t\tgf_dynstrcat(&a_ds->rep_id, \"_\", NULL);\n\t\t\t\tgf_dynstrcat(&a_ds->rep_id, szRep, NULL);\n\t\t\t\tgf_free(a_ds->rep->id);\n\t\t\t\ta_ds->rep->id = gf_strdup(a_ds->rep_id);\n\t\t\t}\n\t\t}\n\t\tif (has_rep_conflict && ctx->do_mpd) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_DASH, (\"[Dasher] Several representations with same ID and using $RepresentationID$ template, cannot change IDs. Resulting MPD is not strictly DASH compliant\\n\"));\n\t\t}\n\t}\n\n\tif (ctx->loop && max_adur.num) {\n\t\tif (max_adur.num * min_adur.den != min_adur.num * max_adur.den) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_DASH, (\"[Dasher] Audio streams in the period have different durations (min \"LLU\"/\"LLD\", max \"LLU\"/\"LLD\"), may result in bad synchronization while looping\\n\", min_adur.num, min_adur.den, max_adur.num, max_adur.den));\n\t\t}\n\t\tfor (i=0; i<count; i++) {\n\t\t\tGF_DashStream *ds = gf_list_get(ctx->current_period->streams, i);\n\t\t\tif (ds->duration.num * max_adur.den > max_adur.num * ds->duration.den) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_DASH, (\"[Dasher] Input %s: max audio duration \"LLU\"/\"LLD\" in the period is less than duration \"LLU\"/\"LLD\", clamping will happen\\n\", ds->src_url, max_adur.num, max_adur.den, ds->duration.num, ds->duration.den ));\n\t\t\t}\n\t\t\tds->clamped_dur = max_adur;\n\t\t}\n\t}\n\n\n\tif (ctx->is_period_restore) return GF_OK;\n\n\tif (has_deps) {\n\t\tfor (i=0; i<count; i++) {\n\t\t\tGF_DashStream *ds = gf_list_get(ctx->current_period->streams, i);\n\t\t\t//assign rep bitrates\n\t\t\tif (ds->dep_id)\n\t\t\t\tds->rep->bandwidth = dasher_get_dep_bitrate(ctx, ds);\n\n\t\t\tif (gf_list_count(ds->complementary_streams)) {\n\t\t\t\tu32 nb_str = gf_list_count(ds->complementary_streams);\n\t\t\t\tds->moof_sn_inc = 1+nb_str;\n\t\t\t\tds->moof_sn = 1;\n\t\t\t\tfor (j=0; j<nb_str; j++) {\n\t\t\t\t\tGF_DashStream *a_ds = gf_list_get(ds->complementary_streams, j);\n\t\t\t\t\ta_ds->moof_sn_inc = ds->moof_sn_inc;\n\t\t\t\t\ta_ds->moof_sn = ds->moof_sn + 1 + j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t//moved all mux components after the base one, so that we do the segmentation on the main component\n\tif (has_muxed_bases) {\n\t\t//setup reps in adaptation sets\n\t\tfor (i=0; i<count; i++) {\n\t\t\tGF_DashStream *ds = gf_list_get(ctx->current_period->streams, i);\n\t\t\tif (!ds->muxed_base) continue;\n\t\t\tgf_list_rem(ctx->current_period->streams, i);\n\t\t\tgf_list_add(ctx->current_period->streams, ds);\n\t\t}\n\t}\n\n\t//setup reps in adaptation sets\n\tfor (i=0; i<count; i++) {\n\t\tGF_DashStream *ds = gf_list_get(ctx->current_period->streams, i);\n\t\tif (ds->muxed_base) continue;\n\t\t//already setup\n\t\tif (ds->set) continue;\n\n\t\t//not setup, create new AS\n\t\tds->set = gf_mpd_adaptation_set_new();\n\t\tds->owns_set = GF_TRUE;\n\t\t//only set hls intra for visual stream if we have know for sure\n\t\tif ((ds->stream_type==GF_STREAM_VISUAL) && (ds->sync_points_type==DASHER_SYNC_NONE)) {\n\t\t\tds->set->intra_only = GF_TRUE;\n\t\t}\n\t\tif (ctx->llhls) {\n\t\t\tds->set->use_hls_ll = GF_TRUE;\n\t\t\tif (ctx->cdur.den)\n\t\t\t\tds->set->hls_ll_target_frag_dur = ((Double)ctx->cdur.num) / ctx->cdur.den;\n\t\t}\n\t\tds->set->udta = ds;\n\t\tif (ds->period_continuity_id) {\n\t\t\tGF_FilterPacket *pck = gf_filter_pid_get_packet(ds->ipid);\n\t\t\tif (pck && (gf_filter_pck_get_cts(pck) != ds->period_continuity_next_cts)) {\n\t\t\t\tgf_free(ds->period_continuity_id);\n\t\t\t\tds->period_continuity_id = NULL;\n\t\t\t} else {\n\t\t\t\tGF_MPD_Descriptor *desc = gf_mpd_descriptor_new(NULL, \"urn:mpeg:dash:period-continuity:2015\", ds->period_continuity_id);\n\t\t\t\tgf_list_add(ds->set->supplemental_properties, desc);\n\t\t\t}\n\t\t}\n\t\tds->period_continuity_next_cts = 0;\n\t\tprop = gf_filter_pid_get_property_str(ds->ipid, \"start_with_sap\");\n\t\tif (prop) ds->set->starts_with_sap = prop->value.uint;\n\n\n\t\tif (ctx->mha_compat && ((ds->codec_id==GF_CODECID_MHAS) || (ds->codec_id==GF_CODECID_MPHA))) {\n\t\t\tprop = gf_filter_pid_get_property(ds->ipid, GF_PROP_PID_MHA_COMPATIBLE_PROFILES);\n\t\t\tif (prop) {\n\t\t\t\tds->set->nb_alt_mha_profiles = prop->value.uint_list.nb_items;\n\t\t\t\tds->set->alt_mha_profiles = prop->value.uint_list.vals;\n\t\t\t\tds->set->alt_mha_profiles_only = (ctx->mha_compat==DASHER_MPHA_COMP_ONLY) ? GF_TRUE : GF_FALSE;\n\t\t\t}\n\t\t}\n\n\t\tif (!ds->set->representations)\n\t\t\tds->set->representations = gf_list_new();\n\t\tif (!ds->period->period->adaptation_sets)\n\t\t\tds->period->period->adaptation_sets = gf_list_new();\n\t\tgf_list_add(ds->period->period->adaptation_sets, ds->set);\n\n\t\tgf_list_add(ds->set->representations, ds->rep);\n\t\tds->nb_rep = 1;\n\n\t\t//add non-conditional adaptation set descriptors\n\t\tdasher_add_descriptors(&ds->set->x_children, ds->p_as_any_desc);\n\t\t//new AS, add conditional adaptation set descriptors\n\t\tdasher_add_descriptors(&ds->set->x_children, ds->p_as_desc);\n\n\t\tif (ds->as_id) has_as_id = GF_TRUE;\n\t\t//for each following, check if same AS is possible\n\t\tfor (j=i+1; j<count; j++) {\n\t\t\tGF_DashStream *a_ds;\n\t\t\ta_ds = gf_list_get(ctx->current_period->streams, j);\n\t\t\t//we add to the adaptation set even if shared rep, we will remove it when assigning templates and pids\n\t\t\tif (dasher_same_adaptation_set(ctx, ds, a_ds)) {\n\t\t\t\ta_ds->set = ds->set;\n\n\t\t\t\tgf_list_add(ds->set->representations, a_ds->rep);\n\t\t\t\tds->nb_rep++;\n\t\t\t\t//add non-conditional adaptation set descriptors\n\t\t\t\tdasher_add_descriptors(&ds->set->x_children, a_ds->p_as_any_desc);\n\t\t\t}\n\t\t}\n\t}\n\tif (has_as_id) {\n\t\tfor (i=0; i<count; i++) {\n\t\t\tGF_DashStream *ds = gf_list_get(ctx->current_period->streams, i);\n\t\t\tif (!ds->owns_set) continue;\n\t\t\tfor (j=i+1; j<count; j++) {\n\t\t\t\tGF_DashStream *a_ds = gf_list_get(ctx->current_period->streams, j);\n\t\t\t\t//avoid as id duplicates\n\t\t\t\tif (ds->owns_set && a_ds->owns_set && (a_ds->as_id == ds->as_id)) {\n\t\t\t\t\ta_ds->as_id = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t//we need a pass on adaptation sets to figure out if they share the same source URL\n\t//in case we use file name in templates\n\tnb_sets = gf_list_count(ctx->current_period->period->adaptation_sets);\n\tfor (i=0; i<nb_sets; i++) {\n\t\tGF_DashStream *ds;\n\t\tGF_MPD_Representation *rep;\n\t\tGF_MPD_AdaptationSet *set;\n\n\t\tif (ctx->sigfrag)\n\t\t\tbreak;\n\n\t\tset = gf_list_get(ctx->current_period->period->adaptation_sets, i);\n\t\tassert(set);\n\t\trep = gf_list_get(set->representations, 0);\n\t\tassert(rep);\n\t\tds = rep->playback.udta;\n\n\t\tif (inject_ds && (ds != inject_ds))\n\t\t\tcontinue;\n\n\t\tif (!dasher_template_use_source_url(ds->template ? ds->template : ctx->template))\n\t\t\tcontinue;\n\n\t\tfor (j=i+1; j<nb_sets; j++) {\n\t\t\tBool split_init = GF_FALSE;\n\t\t\tconst GF_PropertyValue *p1, *p2;\n\t\t\tGF_DashStream *a_ds;\n\n\t\t\tset = gf_list_get(ctx->current_period->period->adaptation_sets, j);\n\t\t\trep = gf_list_get(set->representations, 0);\n\t\t\tassert(rep);\n\t\t\ta_ds = rep->playback.udta;\n\n\t\t\tif (!dasher_template_use_source_url(a_ds->template ? a_ds->template : ctx->template))\n\t\t\t\tcontinue;\n\n\t\t\tp1 = gf_filter_pid_get_property(ds->ipid, GF_PROP_PID_URL);\n\t\t\tp2 = gf_filter_pid_get_property(a_ds->ipid, GF_PROP_PID_URL);\n\t\t\tif (p1 && p2) {\n\t\t\t\tif (gf_props_equal(p1, p2)) split_init = GF_TRUE;\n\t\t\t} else {\n\t\t\t\tp1 = gf_filter_pid_get_property(ds->ipid, GF_PROP_PID_FILEPATH);\n\t\t\t\tp2 = gf_filter_pid_get_property(a_ds->ipid, GF_PROP_PID_FILEPATH);\n\t\t\t\tif (p1 && p2 && gf_props_equal(p1, p2)) split_init = GF_TRUE;\n\t\t\t}\n\t\t\t\n\t\t\tif (split_init) {\n\t\t\t\tds->split_set_names = GF_TRUE;\n\t\t\t\ta_ds->split_set_names = GF_TRUE;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*HbbTV 1.5 ISO live specific checks*/\n\tif (ctx->profile == GF_DASH_PROFILE_HBBTV_1_5_ISOBMF_LIVE) {\n\t\tu32 nb_periods = dasher_period_count(ctx->current_period->streams);\n\t\tif (nb_sets > 16) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_DASH, (\"[DASH] Max 16 adaptation sets in HbbTV 1.5 ISO live profile\\n\\tswitching to DASH AVC/264 live profile\\n\"));\n\t\t\tctx->profile = GF_DASH_PROFILE_AVC264_LIVE;\n\t\t}\n\t\tif (nb_periods > 32) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_DASH, (\"[DASH] Max 32 periods in HbbTV 1.5 ISO live profile\\n\\tswitching to regular DASH AVC/264 live profile\\n\"));\n\t\t\tctx->profile = GF_DASH_PROFILE_AVC264_LIVE;\n\t\t}\n\t\tif (ctx->segdur.num < (s32) ctx->segdur.den) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_DASH, (\"[DASH] Min segment duration 1s in HbbTV 1.5 ISO live profile\\n\\tcapping to 1s\\n\"));\n\t\t\tctx->segdur.num = 1;\n\t\t\tctx->segdur.den = 1;\n\t\t}\n\t\tif (ctx->segdur.num > 15 * (s32) ctx->segdur.den) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_DASH, (\"[DASH] Max segment duration 15s in HbbTV 1.5 ISO live profile\\n\\tcapping to 15s\\n\"));\n\t\t\tctx->segdur.num = 15;\n\t\t\tctx->segdur.den = 1;\n\t\t}\n\t}\n\n\t//init UTC reference time for dynamic\n\tif (!ctx->mpd->availabilityStartTime && (ctx->dmode!=GF_MPD_TYPE_STATIC) && !inject_ds) {\n\t\tu64 dash_start_date = ctx->ast ? gf_net_parse_date(ctx->ast) : 0;\n\n\t\tif (ctx->utc_timing_type != DASHER_UTCREF_NONE) {\n\t\t\tif (!gf_list_count(ctx->mpd->utc_timings) ) {\n\t\t\t\tBool dashif_ok = GF_FALSE;\n\t\t\t\tGF_MPD_Descriptor *utc_t;\n\t\t\t\tchar *url = ctx->utcs;\n\t\t\t\tif (!strncmp(url, \"xsd@\", 4)) url += 4;\n\n\t\t\t\tGF_SAFEALLOC(utc_t, GF_MPD_Descriptor);\n\t\t\t\tutc_t->value = gf_strdup(url);\n\t\t\t\tswitch (ctx->utc_timing_type) {\n\t\t\t\tcase DASHER_UTCREF_HTTP_HEAD:\n\t\t\t\t\tutc_t->scheme_id_uri = gf_strdup(\"urn:mpeg:dash:utc:http-head:2014\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase DASHER_UTCREF_XSDATE:\n\t\t\t\t\tutc_t->scheme_id_uri = gf_strdup(\"urn:mpeg:dash:utc:http-xsdate:2014\");\n\t\t\t\t\tdashif_ok = GF_TRUE;\n\t\t\t\t\tbreak;\n\t\t\t\tcase DASHER_UTCREF_ISO:\n\t\t\t\t\tutc_t->scheme_id_uri = gf_strdup(\"urn:mpeg:dash:utc:http-iso:2014\");\n\t\t\t\t\tdashif_ok = GF_TRUE;\n\t\t\t\t\tbreak;\n\t\t\t\tcase DASHER_UTCREF_NTP:\n\t\t\t\t\tutc_t->scheme_id_uri = gf_strdup(\"urn:mpeg:dash:utc:http-ntp:2014\");\n\t\t\t\t\tdashif_ok = GF_TRUE;\n\t\t\t\t\tbreak;\n\t\t\t\tcase DASHER_UTCREF_INBAND:\n\t\t\t\t\tutc_t->scheme_id_uri = gf_strdup(\"urn:mpeg:dash:utc:direct:2014\");\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (!dashif_ok && (ctx->profile==GF_DASH_PROFILE_DASHIF_LL)) {\n\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_DASH, (\"[Dasher] UTC reference %s allowed in DASH-IF Low Latency profile\\n\\tswitching to regular live profile\\n\", utc_t->scheme_id_uri));\n\t\t\t\t\tctx->profile = GF_DASH_PROFILE_LIVE;\n\t\t\t\t}\n\t\t\t\tif (!ctx->mpd->utc_timings)\n\t\t\t\t\tctx->mpd->utc_timings = gf_list_new();\n\t\t\t\tgf_list_add(ctx->mpd->utc_timings, utc_t);\n\t\t\t}\n\t\t}\n\n\t\t//setup service description\n\t\tif (ctx->profile == GF_DASH_PROFILE_DASHIF_LL) {\n\t\t\tctx->mpd->inject_service_desc = GF_TRUE;\n\t\t}\n\n\t\tctx->mpd->gpac_init_ntp_ms = gf_net_get_ntp_ms();\n\t\tctx->mpd->availabilityStartTime = dasher_get_utc(ctx);\n\t\tGF_LOG(GF_LOG_INFO, GF_LOG_DASH, (\"[Dasher] MPD Availability start time initialized to \"LLU\" ms\\n\", ctx->mpd->availabilityStartTime));\n\n\t\tif (dash_start_date && (dash_start_date < ctx->mpd->availabilityStartTime)) {\n\t\t\tu64 start_date_sec_ntp, secs;\n\t\t\tDouble ms;\n\t\t\t//recompute NTP init time matching the required ast\n\t\t\tsecs = dash_start_date/1000;\n\t\t\tstart_date_sec_ntp = (u32) secs;\n\t\t\tstart_date_sec_ntp += GF_NTP_SEC_1900_TO_1970;\n\t\t\tms = (Double) (dash_start_date - secs*1000);\n\t\t\tms /= 1000.0;\n\t\t\tctx->mpd->gpac_init_ntp_ms = (u64) (start_date_sec_ntp * 1000 + ms);\n\t\t\t//compute number of seconds to discard\n\t\t\tctx->nb_secs_to_discard = (Double) (ctx->mpd->availabilityStartTime - dash_start_date);\n\t\t\tctx->nb_secs_to_discard /= 1000;\n\t\t\t//don't discard TSB, this will be done automatically\n\n\t\t\tctx->mpd->availabilityStartTime = dash_start_date;\n\n\t\t} else if (dash_start_date) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_DASH, (\"[Dasher] specified AST %s seems in the future, ignoring it\\n\", ctx->ast));\n\t\t}\n\t}\n\n\t//setup adaptation sets bitstream switching\n\tfor (i=0; i<count; i++) {\n\t\tGF_DashStream *ds = gf_list_get(ctx->current_period->streams, i);\n\t\tif (!ds->owns_set) continue;\n\t\tif (inject_ds && (ds != inject_ds))\n\t\t\tcontinue;\n\t\t//check bitstream switching\n\t\tdasher_check_bitstream_swicthing(ctx, ds->set);\n\t\t//setup AS defaults, roles and co\n\t\tdasher_setup_set_defaults(ctx, ds->set);\n\t\t//setup sources, templates & co\n\t\tdasher_setup_sources(filter, ctx, ds->set);\n\t}\n\n\twhile (gf_list_count(ctx->postponed_pids)) {\n\t\tGF_DashStream *ds = gf_list_get(ctx->postponed_pids, 0);\n\t\tdasher_open_pid(filter, ctx, ds, ds->multi_pids, GF_FALSE);\n\t}\n\n\t//good to go !\n\tfor (i=0; i<count; i++) {\n\t\tGF_DashStream *ds = gf_list_get(ctx->current_period->streams, i);\n\t\tif (inject_ds && (ds != inject_ds))\n\t\t\tcontinue;\n\t\t//setup segmentation\n\t\tds->rep_init = GF_FALSE;\n\t\tds->presentation_time_offset = 0;\n\t\tds->seg_done = GF_FALSE;\n\t\tds->next_seg_start = (u32) ( ((u64) ds->dash_dur.num * ds->timescale) / ds->dash_dur.den);\n\n\t\t//in sbound=0 mode, if stream has sync and non-sync and uses skip samples, allow spliting\n\t\t//slightly before - typically needed for audio with sync points (usac, mpegh) where the segment duration is set\n\t\t//to the intra interval, we need to take into account the skip samples\n\t\tif (!ctx->sbound && !ds->cues && (ds->sync_points_type==DASHER_SYNC_PRESENT)\n\t\t\t&& (ds->pts_minus_cts<0) && (ds->next_seg_start > (u32) -ds->pts_minus_cts)\n\t\t) {\n\t\t\tds->next_seg_start -= (u32) -ds->pts_minus_cts;\n\t\t}\n\n\t\tds->adjusted_next_seg_start = ds->next_seg_start;\n\t\tds->segment_started = GF_FALSE;\n\t\tds->seg_number = ds->startNumber;\n\t\tds->first_cts = ds->first_dts = ds->max_period_dur = 0;\n\n\t\t//simulate N loops of the source\n\t\tif (ctx->nb_secs_to_discard) {\n\t\t\tu64 period_dur, seg_dur;\n\t\t\tu32 nb_skip=0;\n\n\t\t\tperiod_dur = (u64) (ctx->nb_secs_to_discard * ds->timescale);\n\t\t\tseg_dur = (u64) (ds->dash_dur.num) * ds->timescale / ds->dash_dur.den;\n\n\t\t\tnb_skip = (u32) (period_dur / seg_dur);\n\t\t\tds->ts_offset += nb_skip*seg_dur;\n\t\t\tds->seg_number += nb_skip;\n\n\t\t\tds->max_period_dur = ds->cumulated_dur;\n\t\t\tds->adjusted_next_seg_start += ds->ts_offset;\n\t\t\tds->next_seg_start += ds->ts_offset;\n\t\t}\n\t}\n\n\tctx->nb_secs_to_discard = 0;\n\n\tif (ctx->state)\n\t\tdasher_context_update_period_start(ctx);\n\n\treturn GF_OK;\n}\n\nstatic void dasher_insert_timeline_entry(GF_DasherCtx *ctx, GF_DashStream *ds)\n{\n\tGF_MPD_SegmentTimelineEntry *s;\n\tu64 duration, pto, prev_patch_dur=0;\n\tBool is_first = GF_FALSE;\n\tBool seg_align = GF_FALSE;\n\tGF_MPD_SegmentTimeline *tl=NULL;\n\n\t//we only store segment timeline for the main component in the representation\n\tif (ds->muxed_base) return;\n\n\tif (ds->rep && ds->rep->state_seg_list) {\n\t\tGF_DASH_SegmentContext *sctx = gf_list_last(ds->rep->state_seg_list);\n\t\tif (sctx)\n\t\t\tsctx->dur = ds->first_cts_in_next_seg - ds->first_cts_in_seg;\n\t}\n\t//we only use segment timeline with templates\n\tif (!ds->stl && !ctx->do_index) return;\n\n\tif (gf_list_find(ds->set->representations, ds->rep)==0) is_first = GF_TRUE;\n\tassert(ds->first_cts_in_next_seg > ds->first_cts_in_seg);\n\tduration = ds->first_cts_in_next_seg - ds->first_cts_in_seg;\n\n\t\t//handle sap time adjustment (first_cts_in_seg is the SAP cts, we may have lower cts whith sap 2 or 3)\n\tif (ds->min_cts_in_seg_plus_one && (ds->min_cts_in_seg_plus_one-1 < ds->first_cts_in_seg)) {\n\t\tprev_patch_dur = ds->first_cts_in_seg - (ds->min_cts_in_seg_plus_one-1);\n\t\tif (ds->timescale != ds->mpd_timescale)\n\t\t\tprev_patch_dur = gf_timestamp_rescale(prev_patch_dur, ds->timescale, ds->mpd_timescale);\n\t\tds->first_cts_in_seg = ds->min_cts_in_seg_plus_one-1;\n\t\tduration += prev_patch_dur;\n\t\tds->seg_start_time -= prev_patch_dur;\n\t}\n\n\tpto = ds->presentation_time_offset;\n\tif (ds->timescale != ds->mpd_timescale) {\n\t\tduration = gf_timestamp_rescale(duration, ds->timescale, ds->mpd_timescale);\n\n\t\tpto = gf_timestamp_rescale(pto, ds->timescale, ds->mpd_timescale);\n\t}\n\tseg_align = (ds->set->segment_alignment || ds->set->subsegment_alignment) ? GF_TRUE : GF_FALSE;\n\t//not first and segment alignment, ignore\n\tif (!is_first && seg_align) {\n\t\treturn;\n\t}\n\tif (ctx->do_index) {\n\t\tGF_MPD_SegmentURL *surl = gf_list_last(ds->rep->segment_list->segment_URLs);\n\t\tsurl->duration = duration;\n\t}\n\tif (!ds->stl) return;\n\n\t//no segment alignment store in each rep\n\tif (!seg_align) {\n\t\tGF_MPD_SegmentTimeline **p_tl=NULL;\n\t\tif (!ds->rep) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_DASH, (\"[Dasher] failed to store timeline entry, no representation assigned !\\n\"));\n\t\t\treturn;\n\t\t}\n\n\t\tif (ctx->tpl) {\n\t\t\tp_tl = &ds->rep->segment_template->segment_timeline;\n\t\t\tds->rep->segment_template->duration = 0;\n\t\t} else {\n\t\t\tp_tl = &ds->rep->segment_list->segment_timeline;\n\t\t\tds->rep->segment_list->duration = 0;\n\t\t}\n\t\tif (! (*p_tl)) {\n\t\t\t(*p_tl) = gf_mpd_segmentimeline_new();\n\t\t}\n\t\ttl = (*p_tl);\n\t} else {\n\t\tBool new_tl = GF_FALSE;\n\t\tGF_MPD_SegmentTimeline **p_tl=NULL;\n\n\t\tif (!ds->set) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_DASH, (\"[Dasher] failed to store timeline entry, no AdpatationSet assigned !\\n\"));\n\t\t\treturn;\n\t\t}\n\t\tassert(ds->set);\n\t\tif (ctx->tpl) {\n\t\t\t//in case we had no template at set level\n\t\t\tif (!ds->set->segment_template) {\n\t\t\t\tGF_SAFEALLOC(ds->set->segment_template, GF_MPD_SegmentTemplate);\n\t\t\t\tif (ds->set->segment_template) {\n\t\t\t\t\tds->set->segment_template->start_number = (u32) -1;\n\t\t\t\t\tds->set->segment_template->timescale = ds->mpd_timescale;\n\t\t\t\t\tds->set->segment_template->presentation_time_offset = pto;\n\t\t\t\t}\n\t\t\t\tnew_tl = GF_TRUE;\n\t\t\t}\n\t\t\tp_tl = &ds->set->segment_template->segment_timeline;\n\t\t\tds->set->segment_template->duration = 0;\n\t\t} else {\n\t\t\t//in case we had no template at set level\n\t\t\tif (!ds->set->segment_list) {\n\t\t\t\tGF_SAFEALLOC(ds->set->segment_list, GF_MPD_SegmentList);\n\t\t\t\tif (ds->set->segment_list) {\n\t\t\t\t\tds->set->segment_list->start_number = (u32) -1;\n\t\t\t\t\tds->set->segment_list->timescale = ds->mpd_timescale;\n\t\t\t\t\tds->set->segment_list->presentation_time_offset = pto;\n\t\t\t\t}\n\t\t\t\tnew_tl = GF_TRUE;\n\t\t\t}\n\t\t\tp_tl = &ds->set->segment_list->segment_timeline;\n\t\t\tds->set->segment_list->duration = 0;\n\t\t}\n\n\t\tif (! (*p_tl) ) {\n\t\t\t(*p_tl)  = gf_mpd_segmentimeline_new();\n\t\t}\n\t\ttl = (*p_tl);\n\t\tif (new_tl) {\n\t\t\tu32 i, count = gf_list_count(ds->set->representations);\n\t\t\tfor (i=0; i<count; i++) {\n\t\t\t\tGF_MPD_Representation *arep = gf_list_get(ds->set->representations, i);\n\t\t\t\tif (arep && arep->segment_template) arep->segment_template->duration = 0;\n\t\t\t\tif (arep && arep->segment_list) arep->segment_list->duration = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\t//append to previous entry if possible\n\ts = gf_list_last(tl->entries);\n\n\tif (prev_patch_dur) {\n\t\tu32 nb_ent = gf_list_count(tl->entries);\n\t\t//split entry\n\t\tif (s->repeat_count) {\n\t\t\tGF_MPD_SegmentTimelineEntry *next;\n\t\t\ts->repeat_count--;\n\t\t\tGF_SAFEALLOC(next, GF_MPD_SegmentTimelineEntry);\n\t\t\tif (!next) return;\n\t\t\tnext->duration = (u32) (s->duration - prev_patch_dur);\n\t\t\tnext->start_time = s->start_time + (s->repeat_count+1) * s->duration;\n\t\t\tgf_list_add(tl->entries, next);\n\t\t\ts = next;\n\t\t} else {\n\t\t\t//update entry\n\t\t\ts->duration -= (u32) prev_patch_dur;\n\t\t\t//merge with old one if possible\n\t\t\tGF_MPD_SegmentTimelineEntry *prev = (nb_ent>1) ? gf_list_get(tl->entries, nb_ent-2) : NULL;\n\t\t\tif (prev && (prev->duration==s->duration) && (prev->start_time + (prev->repeat_count+1) * prev->duration == s->start_time)) {\n\t\t\t\tprev->repeat_count++;\n\t\t\t\tgf_list_pop_back(tl->entries);\n\t\t\t\tgf_free(s);\n\t\t\t\ts=prev;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (s && (s->duration == duration) && (s->start_time + (s->repeat_count+1) * s->duration == ds->seg_start_time + pto)) {\n\t\ts->repeat_count++;\n\t\treturn;\n\t}\n\n\t//nope, allocate\n\tGF_SAFEALLOC(s, GF_MPD_SegmentTimelineEntry);\n\tif (!s) return;\n\ts->start_time = ds->seg_start_time + pto;\n\ts->duration = (u32) duration;\n\tgf_list_add(tl->entries, s);\n}\n\nstatic void dasher_copy_segment_timelines(GF_DasherCtx *ctx, GF_MPD_AdaptationSet *set)\n{\n\tGF_MPD_SegmentTimeline *src_tl = NULL;\n\tu32 i, j, count, nb_s;\n\t//get as level segment timeline, set it to NULL, reassign it to first rep and clone for other reps\n\tif (ctx->tpl) {\n\t\tassert(set->segment_template->segment_timeline);\n\t\tsrc_tl = set->segment_template->segment_timeline;\n\t\tset->segment_template->segment_timeline = NULL;\n\t} else {\n\t\tassert(set->segment_list->segment_timeline);\n\t\tsrc_tl = set->segment_list->segment_timeline;\n\t\tset->segment_list->segment_timeline = NULL;\n\t}\n\tnb_s = gf_list_count(src_tl->entries);\n\n\tcount = gf_list_count(set->representations);\n\tfor (i=0; i<count; i++) {\n\t\tGF_MPD_SegmentTimeline *tl = NULL;\n\t\tGF_MPD_Representation *rep = gf_list_get(set->representations, i);\n\t\tif (ctx->tpl) {\n\t\t\tif (!rep->segment_template) {\n\t\t\t\tGF_SAFEALLOC(rep->segment_template, GF_MPD_SegmentTemplate);\n\t\t\t\tif (!rep->segment_template) continue;\n\t\t\t}\n\t\t\tif (!i) {\n\t\t\t\trep->segment_template->segment_timeline = src_tl;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!rep->segment_template->segment_timeline) {\n\t\t\t\trep->segment_template->segment_timeline = gf_mpd_segmentimeline_new();\n\t\t\t}\n\t\t\ttl = rep->segment_template->segment_timeline;\n\t\t} else {\n\t\t\tif (!rep->segment_list) {\n\t\t\t\tGF_SAFEALLOC(rep->segment_list, GF_MPD_SegmentList);\n\t\t\t\tif (!rep->segment_list) continue;\n\t\t\t\trep->segment_list->start_number = (u32) -1;\n\t\t\t}\n\t\t\tif (!i) {\n\t\t\t\trep->segment_list->segment_timeline = src_tl;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!rep->segment_list->segment_timeline) {\n\t\t\t\trep->segment_list->segment_timeline = gf_mpd_segmentimeline_new();\n\t\t\t}\n\t\t\ttl = rep->segment_list->segment_timeline;\n\t\t}\n\t\tassert(tl);\n\t\tfor (j=0; j<nb_s; j++) {\n\t\t\tGF_MPD_SegmentTimelineEntry *s;\n\t\t\tGF_MPD_SegmentTimelineEntry *src_s = gf_list_get(src_tl->entries, j);\n\t\t\tGF_SAFEALLOC(s, GF_MPD_SegmentTimelineEntry);\n\t\t\tif (!s) continue;\n\n\t\t\ts->duration = src_s->duration;\n\t\t\ts->repeat_count = src_s->repeat_count;\n\t\t\ts->start_time = src_s->start_time;\n\t\t\tgf_list_add(tl->entries, s);\n\t\t}\n\t}\n}\n\nstatic void dasher_flush_segment(GF_DasherCtx *ctx, GF_DashStream *ds, Bool is_last_in_period)\n{\n\tu32 i, count;\n\tGF_DashStream *ds_done = NULL, *ds_not_done = NULL;\n\tGF_DashStream *set_ds = ds->set->udta;\n\tGF_DashStream *base_ds = ds->muxed_base ? ds->muxed_base : ds;\n\tBool has_ds_done = GF_FALSE;\n\tu32 seg_dur_ms=0;\n\tGF_DashStream *ds_log = NULL;\n\tu64 first_cts_in_cur_seg=0;\n\n\t//these are ignored\n\tif (ds->merged_tile_dep)\n\t\treturn;\n\n\tctx->update_report = -1;\n\n\tif (ds->segment_started) {\n\t\tDouble seg_duration;\n\t\tu64 seg_duration_unscale = base_ds->first_cts_in_next_seg - ds->first_cts_in_seg;\n\t\t//seg_duration /= base_ds->timescale;\n\t\tif (!seg_duration_unscale) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_DASH, (\"[Dasher] Segment %d is empty - pid end of stream %d\\n\", ds->seg_number, gf_filter_pid_is_eos(ds->ipid) ));\n\t\t}\n\t\tseg_dur_ms = (u32) (seg_duration_unscale*1000 / base_ds->timescale);\n\t\tif (seg_dur_ms * base_ds->timescale < seg_duration_unscale* 1000) seg_dur_ms++;\n\n\t\tfirst_cts_in_cur_seg = ds->first_cts_in_seg;\n\t\tif (ctx->mpd->max_segment_duration < seg_dur_ms)\n\t\t\tctx->mpd->max_segment_duration = seg_dur_ms;\n\t\tctx->def_max_seg_dur = 0;\n\n\t\tseg_duration = (Double) base_ds->first_cts_in_next_seg - ds->first_cts_in_seg;\n\t\tseg_duration /= base_ds->timescale;\n\n\t\tif (ctx->sigfrag) {\n\t\t\tif (ds->no_seg_dur) {\n\t\t\t\tds->gm_duration_total += seg_duration;\n\t\t\t\tds->gm_nb_segments++;\n\t\t\t\tif (!ds->gm_duration_min || (ds->gm_duration_min>seg_duration) )\n\t\t\t\t\tds->gm_duration_min = seg_duration;\n\t\t\t\tif (ds->gm_duration_max<seg_duration)\n\t\t\t\t\tds->gm_duration_max = seg_duration;\n\t\t\t\tds->dash_dur.num = (s32) (1000.0 * ds->gm_duration_total / ds->gm_nb_segments);\n\t\t\t\tds->dash_dur.den = 1000;\n\t\t\t\tds->rep->dash_dur = ds->dash_dur;\n\t\t\t}\n\n\t\t\tif (ds->rep->segment_list && (ds->rep->segment_list->duration * ds->dash_dur.den != ds->dash_dur.num) ) {\n\t\t\t\tds->rep->segment_list->duration = (u64) (ds->dash_dur.num) * ds->rep->segment_list->timescale / ds->dash_dur.den;\n\t\t\t}\n\t\t\tif (ds->set->segment_list && (ds->set->segment_list->duration * ds->dash_dur.den != ds->dash_dur.num) ) {\n\t\t\t\tds->set->segment_list->duration = (u64) (ds->dash_dur.num) * ds->set->segment_list->timescale / ds->dash_dur.den;\n\t\t\t}\n\t\t\tif (ds->rep->segment_template && (ds->rep->segment_template->duration * ds->dash_dur.den != ds->dash_dur.num) ) {\n\t\t\t\tds->rep->segment_template->duration = (u64) (ds->dash_dur.num) * ds->rep->segment_template->timescale / ds->dash_dur.den;\n\t\t\t}\n\t\t\tif (ds->set && ds->set->segment_template && (ds->set->segment_template->duration * ds->dash_dur.den != ds->dash_dur.num) ) {\n\t\t\t\tds->set->segment_template->duration = (u64) (ds->dash_dur.num) * ds->set->segment_template->timescale / ds->dash_dur.den;\n\t\t\t}\n\t\t}\n\t\tif (!base_ds->done && !base_ds->stl && ctx->tpl && !ctx->cues && !ctx->forward_mode && !is_last_in_period) {\n\n\t\t\tif (2 * seg_duration * ds->dash_dur.den < ds->dash_dur.num) {\n\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_DASH, (\"[Dasher] Segment %d duration %g less than half DASH duration, consider reencoding or using segment timeline\\n\", ds->seg_number, seg_duration));\n\t\t\t} else if (2 * seg_duration * ds->dash_dur.den > 3 * ds->dash_dur.num) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_DASH, (\"[Dasher] Segment %d duration %g more than 3/2 DASH duration, consider reencoding or using segment timeline\\n\", ds->seg_number, seg_duration));\n\t\t\t}\n\t\t}\n\t\tdasher_insert_timeline_entry(ctx, base_ds);\n\n\t\tif (ctx->do_m3u8) {\n\t\t\tu64 segdur = base_ds->first_cts_in_next_seg - ds->first_cts_in_seg;\n\t\t\tif (gf_timestamp_less(base_ds->rep->hls_max_seg_dur.num, base_ds->rep->hls_max_seg_dur.den, segdur, base_ds->timescale)) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_DASH, (\"[Dasher] Changing HLS target duration from %u to %u, either increase the segment duration or re-encode the content\\n\",\n\t\t\t\t\t\t(u32) gf_ceil( ((Double) base_ds->rep->hls_max_seg_dur.num) / base_ds->rep->hls_max_seg_dur.den),\n\t\t\t\t\t\t(u32) gf_ceil( ((Double) segdur) / base_ds->timescale)\n\t\t\t\t));\n\n\t\t\t\tbase_ds->rep->hls_max_seg_dur.num = (s32) segdur;\n\t\t\t\tbase_ds->rep->hls_max_seg_dur.den = base_ds->timescale;\n\t\t\t}\n\t\t}\n\n\t\tif (ctx->align) {\n\t\t\tif (!set_ds->nb_rep_done || !set_ds->set_seg_duration) {\n\t\t\t\tset_ds->set_seg_duration = seg_duration;\n\t\t\t} else {\n\t\t\t\tDouble diff = set_ds->set_seg_duration - seg_duration;\n\n\t\t\t\tif (ABS(diff) > 0.001) {\n\t\t\t\t\tif (set_ds->set->segment_alignment || set_ds->set->subsegment_alignment) {\n\t\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_DASH, (\"[Dasher] Segments are not aligned across representations: first rep segment duration %g but new segment duration %g for the same segment %d\\n\", set_ds->set_seg_duration, seg_duration, set_ds->seg_number));\n\t\t\t\t\t}\n\t\t\t\t\tif (ctx->profile != GF_DASH_PROFILE_FULL) {\n\t\t\t\t\t\tset_ds->set->segment_alignment = GF_FALSE;\n\t\t\t\t\t\tset_ds->set->subsegment_alignment = GF_FALSE;\n\t\t\t\t\t\tctx->profile = GF_DASH_PROFILE_FULL;\n\t\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_DASH, (\"[Dasher] No segment alignment, switching to full profile\\n\"));\n\n\t\t\t\t\t\tif (set_ds->stl)\n\t\t\t\t\t\t\tdasher_copy_segment_timelines(ctx, set_ds->set);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tset_ds->nb_rep_done++;\n\t\t\tif (set_ds->nb_rep_done < set_ds->nb_rep) {\n\t\t\t\tif (ctx->subdur && (ds->cumulated_dur >= 0.8 * (ds->cumulated_subdur + ctx->subdur) * ds->timescale))\n\t\t\t\t\tds->subdur_done = GF_TRUE;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tset_ds->set_seg_duration = 0;\n\t\t\tset_ds->nb_rep_done = 0;\n\t\t}\n\n\t\tds_log = ds;\n\t} else {\n\t\tif (ctx->align) {\n\t\t\tset_ds->nb_rep_done++;\n\t\t\tif (set_ds->nb_rep_done < set_ds->nb_rep) return;\n\n\t\t\tset_ds->set_seg_duration = 0;\n\t\t\tset_ds->nb_rep_done = 0;\n\t\t}\n\t}\n\n\tif (ctx->subdur && (ds->cumulated_dur >= 0.8 * (ds->cumulated_subdur + ctx->subdur) * ds->timescale))\n\t\tds->subdur_done = GF_TRUE;\n\n\tcount = gf_list_count(ctx->current_period->streams);\n\n\tif (ctx->subdur) {\n\t\tu32 nb_sub_done=0;\n\t\tif (ctx->subdur_done) return;\n\t\tfor (i=0; i<count; i++) {\n\t\t\tGF_DashStream *a_ds = gf_list_get(ctx->current_period->streams, i);\n\t\t\tif (a_ds->muxed_base) {\n\t\t\t\tif (a_ds->muxed_base->subdur_done) a_ds->subdur_done = GF_TRUE;\n\t\t\t}\n\n\t\t\tif (a_ds->subdur_done) {\n\t\t\t\tnb_sub_done++;\n\t\t\t}\n\t\t}\n\t\t// if one of the AS is done and we are at 30% of target subdur, abort\n\t\tif (nb_sub_done && !ds->subdur_done\n\t\t \t&& (ctx->subdur && (ds->cumulated_dur >= (0.7 * (ds->cumulated_subdur + ctx->subdur)) * ds->timescale))\n\t\t) {\n\t\t\tds->subdur_done = GF_TRUE;\n\t\t\tnb_sub_done++;\n\t\t}\n\t\tif (nb_sub_done==count)\n \t\t\tctx->subdur_done = GF_TRUE;\n\t}\n\n\t//reset all streams from our rep or our set\n\tfor (i=0; i<count; i++) {\n\t\tds = gf_list_get(ctx->current_period->streams, i);\n\t\t//reset all in set if segment alignment\n\t\tif (ctx->align) {\n\t\t\tif (ds->set != set_ds->set) continue;\n\t\t} else {\n\t\t\t//otherwise reset only media components for this rep\n\t\t\tif ((ds->muxed_base != base_ds) && (ds != base_ds)) continue;\n\t\t}\n\n\t\tif (!ds->done) {\n\t\t\tds->first_cts_in_next_seg = ds->first_cts_in_seg = ds->est_first_cts_in_next_seg = 0;\n\t\t\tds->min_cts_in_seg_plus_one = 0;\n\t\t}\n\n\t\tif (ds->muxed_base) {\n\t\t\tif (!ds->done) {\n\t\t\t\tds->segment_started = GF_FALSE;\n\t\t\t\tds->seg_done = GF_FALSE;\n\t\t\t} else {\n\t\t\t\thas_ds_done = GF_TRUE;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tbase_ds = ds;\n\n\t\tif (base_ds->done)\n\t\t\tds_done = base_ds;\n\t\telse if (base_ds->nb_comp_done==base_ds->nb_comp) ds_not_done = base_ds;\n\n\t\tif (!base_ds->done && base_ds->seg_done) {\n\t\t\tbase_ds->seg_done = GF_FALSE;\n\t\t\tbase_ds->nb_comp_done = 0;\n\n#ifndef GPAC_DISABLE_LOG\n\t\t\tif (ctx->dmode>=GF_DASH_DYNAMIC) {\n\t\t\t\tu32 asid;\n\t\t\t\ts64 ast_diff;\n\t\t\t\tu64 seg_ast = ctx->mpd->availabilityStartTime;\n\t\t\t\tseg_ast += ctx->current_period->period->start;\n\t\t\t\tseg_ast += gf_timestamp_rescale(base_ds->adjusted_next_seg_start, base_ds->timescale, 1000);\n\n\t\t\t\t//if theoretical AST of the segment is less than the current UTC, we are producing the segment too late.\n\t\t\t\tast_diff = (s64) dasher_get_utc(ctx);\n\t\t\t\tast_diff -= seg_ast;\n\n\t\t\t\tasid = base_ds->set->id;\n\t\t\t\tif (!asid)\n\t\t\t\t\tasid = gf_list_find(ctx->current_period->period->adaptation_sets, base_ds->set) + 1;\n\n\t\t\t\tif (ast_diff>10) {\n\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_DASH, (\"[Dasher] AS%d Rep %s segment %d done TOO LATE by %d ms\\n\", asid, base_ds->rep->id, base_ds->seg_number, (s32) ast_diff));\n\t\t\t\t} else {\n\t\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_DASH, (\"[Dasher] AS%d Rep %s segment %d done %d ms %s UTC due time\\n\", asid, base_ds->rep->id, base_ds->seg_number, ABS(ast_diff), (ast_diff<0) ? \"before\" : \"after\"));\n\t\t\t\t}\n\t\t\t}\n#endif\n\n\t\t\t//it may happen that we get a reconfigure triggered while no segment is active\n\t\t\tif (base_ds->segment_started) {\n\t\t\t\tbase_ds->segment_started = GF_FALSE;\n\n\t\t\t\tbase_ds->next_seg_start += (u64) (base_ds->dash_dur.num) * base_ds->timescale / base_ds->dash_dur.den;\n\t\t\t\twhile (base_ds->next_seg_start <= base_ds->adjusted_next_seg_start) {\n\t\t\t\t\tbase_ds->next_seg_start += (u64) (base_ds->dash_dur.num) * base_ds->timescale / base_ds->dash_dur.den;\n\t\t\t\t\tif (ctx->skip_seg)\n\t\t\t\t\t\tbase_ds->seg_number ++;\n\t\t\t\t}\n\t\t\t\tbase_ds->adjusted_next_seg_start = base_ds->next_seg_start;\n\t\t\t\tbase_ds->seg_number ++;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (ds_log) {\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_DASH, (\"[Dasher] Rep#%s flush seg %d start %g duration %g next seg end time %g\\n\", ds_log->rep->id, ds_log->seg_number-1, ((Double)first_cts_in_cur_seg)/ds_log->timescale, ((Double)seg_dur_ms)/1000, ((Double)ds_log->adjusted_next_seg_start)/ds_log->timescale));\n\t}\n\n\t//muxed representation with unaligned duration, report all done reps to number of components done\n\tif (has_ds_done) {\n\t\tbase_ds->nb_comp_done = 0;\n\t\tfor (i=0; i<count; i++) {\n\t\t\tds = gf_list_get(ctx->current_period->streams, i);\n\t\t\t//otherwise reset only media components for this rep\n\t\t\tif ((ds->muxed_base != base_ds) && (ds != base_ds)) continue;\n\n\t\t\tif (ds->done && (base_ds->nb_comp_done < base_ds->nb_comp)) {\n\t\t\t\tbase_ds->nb_comp_done++;\n\t\t\t}\n\t\t}\n\t}\n\telse if (ds->muxed_base) {\n\t\t//force reset if muxed base and no rep is over\n\t\tbase_ds->nb_comp_done = 0;\n\t}\n\n\t//some reps are done, other not, force a max time on all AS in the period\n\tif (ds_done && ds_not_done) {\n\t\tfor (i=0; i<count; i++) {\n\t\t\tds = gf_list_get(ctx->current_period->streams, i);\n\n\t\t\tif (ds->done) {\n\t\t\t\tif (ds->set->udta == set_ds)\n\t\t\t\t\tset_ds->nb_rep_done++;\n\t\t\t} else if (ctx->check_dur && !ds->force_rep_end) {\n\t\t\t\tds->force_rep_end = gf_timestamp_rescale(ds_done->first_cts_in_next_seg, ds_done->timescale, ds->timescale );\n\t\t\t}\n\t\t}\n\t}\n}\n\n//seg_name is relative to the source manifest (MPD or master HLS) for segments\nstatic char *dasher_strip_base(GF_DasherCtx *ctx, GF_DashStream *ds, char *seg_url, char *seg_name)\n{\n\tif (ctx->keep_src) return gf_strdup(seg_name);\n\n\tconst GF_PropertyValue *mpd_url = gf_filter_pid_get_property_str(ds->ipid, \"manifest_url\");\n\tif (!mpd_url || !ctx->out_path) return gf_strdup(seg_url);\n\n\tBool gf_url_is_relative(const char *pathName);\n\tchar *url, *mpd_out, *mpd_src_alloc=NULL;\n\tmpd_out = gf_file_basename(ctx->out_path);\n\tu32 len = (u32) (mpd_out - ctx->out_path);\n\tchar *mpd_src = mpd_url->value.string;\n\n\tif (!strncmp(ctx->out_path, mpd_url->value.string, len)) {\n\t\tmpd_src += len;\n\t} else if (gf_url_is_relative(ctx->out_path) && gf_url_is_relative(mpd_src)) {\n\t\tchar *opath=NULL, *ipath=NULL;\n\t\tif (ctx->out_path[0]!='.') gf_dynstrcat(&opath, \"./\", NULL);\n\t\tgf_dynstrcat(&opath, ctx->out_path, NULL);\n\t\tif (mpd_src[0]!='.') gf_dynstrcat(&ipath, \"./\", NULL);\n\t\tgf_dynstrcat(&ipath, mpd_src, NULL);\n\n\t\tmpd_src_alloc = gf_url_concatenate_parent(opath, ipath);\n\t\tmpd_src = mpd_src_alloc;\n\t\tif (opath) gf_free(opath);\n\t\tif (ipath) gf_free(ipath);\n\t} else {\n\t\treturn gf_strdup(seg_name);\n\t}\n\n\turl = gf_url_concatenate(mpd_src, seg_name);\n\treturn url;\n}\n\nstatic GFINLINE\nu64 dasher_translate_cts(GF_DashStream *ds, u64 cts)\n{\n\tif (ds->cues) {\n\t\tcts -= ds->first_cts;\n\t} else if (cts < ds->first_dts) {\n\t\tcts = 0;\n\t} else if (ds->pts_minus_cts<0) {\n\t\tif ((s64) (cts - ds->first_dts) >= -ds->pts_minus_cts) {\n\t\t\tcts = cts - ds->first_dts + ds->pts_minus_cts;\n\t\t} else {\n\t\t\tcts = 0;\n\t\t}\n\t} else {\n\t\tcts -= ds->first_cts;\n\t}\n\treturn cts;\n}\n\nstatic void dasher_mark_segment_start(GF_DasherCtx *ctx, GF_DashStream *ds, GF_FilterPacket *pck, GF_FilterPacket *in_pck)\n{\n\tBool no_concat;\n\tGF_DASH_SegmentContext *seg_state=NULL;\n\tchar szSegmentName[GF_MAX_PATH], szSegmentFullPath[GF_MAX_PATH], szIndexName[GF_MAX_PATH];\n\tGF_DashStream *base_ds = ds->muxed_base ? ds->muxed_base : ds;\n\n\tif (ctx->forward_mode) {\n\t\tconst GF_PropertyValue *p_fname, *p_manifest;\n\n\t\tp_fname = gf_filter_pck_get_property(in_pck, GF_PROP_PCK_FILENAME);\n\t\tp_manifest = gf_filter_pck_get_property(in_pck, GF_PROP_PCK_FILENUM);\n\t\tif (!p_fname || !p_fname->value.string || !p_manifest) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_DASH, (\"[Dasher] Couldn't fetch source URL / idx of segment in forward mode, cannot forward\\n\"));\n\t\t\tctx->in_error = GF_TRUE;\n\t\t\treturn;\n\t\t}\n\t\tstrcpy(szSegmentName, p_fname->value.string);\n\t\t//remove filename property\n\t\tif (pck)\n\t\t\tgf_filter_pck_set_property(pck, GF_PROP_PCK_FILENAME, NULL);\n\n\t\t//check for manifest update\n\t\tp_manifest = gf_filter_pck_get_property(in_pck, GF_PROP_PCK_DASH_MANIFEST);\n\t\tif (p_manifest) {\n\t\t\tif (p_manifest->value.string) {\n\t\t\t\tif (strstr(p_manifest->value.string, \"<MPD\")) {\n\t\t\t\t\tif (ctx->do_m3u8) {\n\t\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_DASH, (\"[Dasher] Manifest forward mode got DASH MPD but output is HLS M3U8, cannot operate - change formats or dasher forward mode\\n\"));\n\t\t\t\t\t\tctx->in_error = GF_TRUE;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdasher_forward_mpd(ctx, p_manifest->value.string);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (ctx->do_mpd) {\n\t\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_DASH, (\"[Dasher] Manifest forward mode got M3U8 but output is DASH MPD, cannot operate - change formats or dasher forward mode\\n\"));\n\t\t\t\t\t\tctx->in_error = GF_TRUE;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdasher_forward_manifest_raw(ctx, ds, p_manifest->value.string, NULL);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pck)\n\t\t\t\tgf_filter_pck_set_property(pck, GF_PROP_PCK_DASH_MANIFEST, NULL);\n\t\t}\n\n\t\t//check for HLS child playlist update\n\t\tp_manifest = gf_filter_pck_get_property(in_pck, GF_PROP_PCK_HLS_VARIANT);\n\t\tp_fname = gf_filter_pck_get_property(in_pck, GF_PROP_PCK_HLS_VARIANT_NAME);\n\t\tif (p_manifest && p_fname && (p_fname->value.string_list.nb_items==p_manifest->value.string_list.nb_items)) {\n\t\t\tu32 i, count = p_fname->value.string_list.nb_items;\n\t\t\tfor (i=0; i<count; i++)\n\t\t\t\tdasher_forward_manifest_raw(ctx, ds, p_manifest->value.string_list.vals[i], p_fname->value.string_list.vals[i]);\n\t\t}\n\t\tif (pck) {\n\t\t\tif (p_manifest)\n\t\t\t\tgf_filter_pck_set_property(pck, GF_PROP_PCK_HLS_VARIANT, NULL);\n\t\t\tif (p_fname)\n\t\t\t\tgf_filter_pck_set_property(pck, GF_PROP_PCK_HLS_VARIANT_NAME, NULL);\n\t\t}\n\n\t\t//we need to move from segment name to output name\n\t\tif (ctx->forward_mode==DASHER_FWD_ALL)\n\t\t\tgoto send_packet;\n\t}\n\n\tif (pck) {\n\t\tif (ctx->ntp==DASHER_NTP_YES) {\n\t\t\tu64 ntpts = gf_net_get_ntp_ts();\n\t\t\tgf_filter_pck_set_property(pck, GF_PROP_PCK_SENDER_NTP, &PROP_LONGUINT(ntpts));\n\t\t} else if (ctx->ntp==DASHER_NTP_REM) {\n\t\t\tgf_filter_pck_set_property(pck, GF_PROP_PCK_SENDER_NTP, NULL);\n\t\t}\n\t\tif (!ctx->gencues) {\n\t\t\tgf_filter_pck_set_property(pck, GF_PROP_PCK_FILENUM, NULL );\n\t\t\tgf_filter_pck_set_property(pck, GF_PROP_PCK_IDXFILENAME, NULL );\n\t\t\tgf_filter_pck_set_property(pck, GF_PROP_PCK_FILENAME, NULL );\n\t\t}\n\n\t\tgf_filter_pck_set_property(pck, GF_PROP_PCK_FILENUM, &PROP_UINT(base_ds->seg_number ) );\n\n\t\tif (ctx->gencues) {\n\t\t\tgf_filter_pck_set_property(pck, GF_PROP_PCK_CUE_START, &PROP_BOOL(GF_TRUE));\n\t\t\tif (ds->set_period_switch) {\n\t\t\t\tds->set_period_switch = GF_FALSE;\n\t\t\t\tgf_filter_pck_set_property(pck, GF_PROP_PID_DASH_PERIOD_START, &PROP_LONGUINT(0) );\n\t\t\t}\n\t\t}\n\t}\n\n\t//only signal file name & insert timelines on one stream for muxed representations\n\tif (ds->muxed_base) return;\n\n\tds->seg_start_time = ds->first_cts_in_seg;\n\tif (ds->timescale != ds->mpd_timescale) {\n\t\tds->seg_start_time = gf_timestamp_rescale(ds->seg_start_time, ds->timescale, ds->mpd_timescale);\n\t}\n\tds->last_min_segment_start_time = ds->first_cts_in_seg;\n\tds->last_min_segment_start_time *= 1000;\n\tds->last_min_segment_start_time /= ds->timescale;\n\n\tif (ds->last_min_segment_start_time > ctx->min_segment_start_time)\n\t\tctx->min_segment_start_time = ds->last_min_segment_start_time;\n\n\tif (ctx->store_seg_states) {\n\t\tchar *kms_uri;\n\t\tconst GF_PropertyValue *p;\n\t\tassert(!ctx->gencues);\n\t\tif (!ds->rep->state_seg_list) {\n\t\t\tds->rep->state_seg_list = gf_list_new();\n\t\t}\n\t\tif (!ds->rep->dash_dur.num) {\n\t\t\tds->rep->timescale = ds->timescale;\n\t\t\tds->rep->streamtype = ds->stream_type;\n\t\t\tds->rep->timescale_mpd = ds->mpd_timescale;\n\t\t\tp = gf_filter_pid_get_property(ds->ipid, GF_PROP_PID_HLS_GROUPID);\n\t\t\tif (p)\n\t\t\t\tds->rep->groupID = p->value.string;\n\n\t\t\tds->rep->dash_dur = ds->dash_dur;\n\t\t\tds->rep->hls_max_seg_dur = ds->dash_dur;\n\n\t\t\tif (!ds->rep->hls_single_file_name) {\n\t\t\t\tswitch (ctx->muxtype) {\n\t\t\t\tcase DASHER_MUX_TS:\n\t\t\t\tcase DASHER_MUX_OGG:\n\t\t\t\tcase DASHER_MUX_RAW:\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tif (ds->set->bitstream_switching && ds->set->segment_template)\n\t\t\t\t\t\tds->rep->hls_single_file_name = ds->set->segment_template->hls_init_name;\n\t\t\t\t\telse\n\t\t\t\t\t\tds->rep->hls_single_file_name = ds->init_seg;\n\t\t\t\t}\n\t\t\t}\n\t\t\tds->rep->nb_chan = ds->nb_ch;\n\t\t\tds->rep->m3u8_name = ds->hls_vp_name;\n\t\t\tif (ds->fps.den) {\n\t\t\t\tds->rep->fps = ds->fps.num;\n\t\t\t\tds->rep->fps /= ds->fps.den;\n\t\t\t}\n\t\t}\n\t\tGF_SAFEALLOC(seg_state, GF_DASH_SegmentContext);\n\t\tif (!seg_state) return;\n\t\tseg_state->time = ds->seg_start_time;\n\t\tseg_state->seg_num = ds->seg_number;\n\t\tseg_state->llhls_mode = ctx->llhls;\n\t\tds->current_seg_state = seg_state;\n\t\tseg_state->encrypted = GF_FALSE;\n\n\t\tp = gf_filter_pid_get_property(ds->ipid, GF_PROP_PID_HLS_KMS);\n\t\tkms_uri = (p && p->value.string) ? p->value.string : NULL;\n\t\tif (ds->tci) {\n\t\t\tu32 s;\n\t\t\tds->iv_low++;\n\t\t\tif (ds->iv_low == 0)\n\t\t\t\tds->iv_high++;\n\t\t\tfor (s=0; s<8; s++)\n\t\t\t\tseg_state->hls_iv[s] = (ds->iv_high >> 8*(7-s) ) & 0xFF;\n\t\t\tfor (s=0; s<8; s++)\n\t\t\t\tseg_state->hls_iv[s+8] = (ds->iv_low >> 8*(7-s) ) & 0xFF;\n\n\t\t\tseg_state->encrypted = GF_TRUE;\n\t\t\tgf_cryptfout_push_key(ds->dst_filter, & ds->tci->keys[ds->key_idx].key, &seg_state->hls_iv);\n\n\t\t\tif (ds->tci->keys[ds->key_idx].hls_info)\n\t\t\t\tkms_uri = ds->tci->keys[ds->key_idx].hls_info;\n\n\t\t\tds->nb_crypt_seg++;\n\t\t\tif (ds->tci->keyRoll) {\n\t\t\t\tif (ds->nb_crypt_seg == ds->tci->keyRoll) {\n\t\t\t\t\tds->nb_crypt_seg = 0;\n\t\t\t\t\tds->key_idx = (ds->key_idx+1) % ds->tci->nb_keys;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//we need a hard copy as the pid may reconfigure before we flush the segment\n\t\tif (kms_uri) {\n\t\t\t//insert IV if not mp4\n\t\t\tif (!ds->tci && !strstr(kms_uri, \"IV=\") && (ctx->muxtype!=DASHER_MUX_ISOM)) {\n\t\t\t\tp = gf_filter_pid_get_property(ds->ipid, GF_PROP_PID_CENC_KEY_INFO);\n\t\t\t\tif (p && (p->value.data.size==37)) {\n\t\t\t\t\tchar *kms_iv=NULL;\n\t\t\t\t\tu8 *iv=p->value.data.ptr + 21;\n\t\t\t\t\tchar szIV[40];\n\t\t\t\t\tu32 i;\n\t\t\t\t\tstrcpy(szIV, \"IV=0x\");\n\t\t\t\t\tfor (i=0; i<16; i++) {\n\t\t\t\t\t\tchar szVal[3];\n\t\t\t\t\t\tsprintf(szVal, \"%02X\", iv[i]);\n\t\t\t\t\t\tstrcat(szIV, szVal);\n\t\t\t\t\t}\n\t\t\t\t\tif (!strstr(kms_uri, \"URI=\")) {\n\t\t\t\t\t\tgf_dynstrcat(&kms_iv, \"URI=\\\"\", NULL);\n\t\t\t\t\t\tgf_dynstrcat(&kms_iv, kms_uri, NULL);\n\t\t\t\t\t\tgf_dynstrcat(&kms_iv, \"\\\"\", NULL);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tgf_dynstrcat(&kms_iv, kms_uri, NULL);\n\t\t\t\t\t}\n\t\t\t\t\tgf_dynstrcat(&kms_iv, szIV, \",\");\n\t\t\t\t\tseg_state->hls_key_uri = kms_iv;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!seg_state->hls_key_uri) {\n\t\t\t\tif (!strstr(kms_uri, \"URI=\")) {\n\t\t\t\t\tgf_dynstrcat(&seg_state->hls_key_uri, \"URI=\\\"\", NULL);\n\t\t\t\t\tgf_dynstrcat(&seg_state->hls_key_uri, kms_uri, NULL);\n\t\t\t\t\tgf_dynstrcat(&seg_state->hls_key_uri, \"\\\"\", NULL);\n\t\t\t\t} else {\n\t\t\t\t\tseg_state->hls_key_uri = gf_strdup(kms_uri);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tgf_list_add(ds->rep->state_seg_list, seg_state);\n\t\tif (ctx->sigfrag) {\n\t\t\tconst GF_PropertyValue *frag_range = gf_filter_pck_get_property(in_pck, GF_PROP_PCK_FRAG_RANGE);\n\t\t\tconst GF_PropertyValue *frag_url = gf_filter_pck_get_property(in_pck, GF_PROP_PID_URL);\n\t\t\tconst GF_PropertyValue *frag_name = gf_filter_pck_get_property(in_pck, GF_PROP_PCK_FILENAME);\n\n\t\t\tif (frag_url && frag_name) {\n\t\t\t\tseg_state->filename = dasher_strip_base(ctx, ds, frag_url->value.string, frag_name->value.string);\n\t\t\t} else if (frag_range) {\n\t\t\t\tseg_state->file_offset = frag_range->value.lfrac.num;\n\t\t\t\tseg_state->file_size = (u32) (frag_range->value.lfrac.den - seg_state->file_offset);\n\n\t\t\t\tif (ds->rep->segment_base && !ds->rep->segment_base->initialization_segment) {\n\t\t\t\t\tGF_MPD_URL *url;\n\t\t\t\t\tGF_SAFEALLOC(url, GF_MPD_URL);\n\t\t\t\t\tif (url) {\n\t\t\t\t\t\tGF_SAFEALLOC(url->byte_range, GF_MPD_ByteRange);\n\t\t\t\t\t\tif (url->byte_range) {\n\t\t\t\t\t\t\turl->byte_range->start_range = 0;\n\t\t\t\t\t\t\turl->byte_range->end_range = seg_state->file_offset-1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tds->rep->segment_base->initialization_segment = url;\n\n\t\t\t\t\t//first seg, remove sidx if present\n\t\t\t\t\t//our frag_range includes sidx\n\t\t\t\t\tconst GF_PropertyValue *sidx_range = gf_filter_pck_get_property(in_pck, GF_PROP_PCK_SIDX_RANGE);\n\t\t\t\t\tif (sidx_range) {\n\t\t\t\t\t\tu64 sidx_size = (u64)sidx_range->value.lfrac.den;\n\t\t\t\t\t\tsidx_size -= (u64) sidx_range->value.lfrac.num;\n\t\t\t\t\t\tseg_state->file_offset += sidx_size;\n\t\t\t\t\t\tseg_state->file_size -= (u32) sidx_size;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tgf_list_del_item(ds->rep->state_seg_list, seg_state);\n\t\t\t\tgf_free(seg_state);\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_DASH, (\"[Dasher] Manifest generation only but not fragment information in packet, source demux not properly configured\\n\"));\n\t\t\t\tctx->in_error = GF_TRUE;\n\t\t\t}\n\t\t} else if (!ctx->index_media_duration) {\n\t\t\tgf_list_add(ds->pending_segment_states, seg_state);\n\t\t\tctx->nb_seg_url_pending++;\n\t\t}\n\t}\n\n\tszIndexName[0] = 0;\n\tif (ds->idx_template) {\n\t\t//get final segment template - output file name is NULL, we already have solved this in source_setup\n\t\tgf_media_mpd_format_segment_name(GF_DASH_TEMPLATE_REPINDEX, ds->set->bitstream_switching, szIndexName, base_ds->rep_id, NULL, base_ds->idx_template, NULL, base_ds->seg_start_time, base_ds->rep->bandwidth, base_ds->seg_number, base_ds->stl, ctx->tpl_force);\n\n\t\tstrcpy(szSegmentFullPath, szIndexName);\n\t\tif (ctx->out_path) {\n\t\t\tchar *rel = gf_url_concatenate(ctx->out_path, szIndexName);\n\t\t\tif (rel) {\n\t\t\t\tstrcpy(szSegmentFullPath, rel);\n\t\t\t\tgf_free(rel);\n\t\t\t}\n\t\t}\n\t\tif (pck)\n\t\t\tgf_filter_pck_set_property(pck, GF_PROP_PCK_IDXFILENAME, &PROP_STRING(szSegmentFullPath) );\n\t}\n\n\tif (ctx->sseg) {\n\t\tif (ctx->gencues) return;\n\n\t\tif (ctx->sigfrag) {\n\t\t\tBool has_root_sidx = GF_TRUE;\n\t\t\tconst GF_PropertyValue *p = gf_filter_pid_get_property(ds->ipid, GF_PROP_PCK_SIDX_RANGE);\n\t\t\tif (!p) {\n\t\t\t\tp = gf_filter_pck_get_property(in_pck, GF_PROP_PCK_SIDX_RANGE);\n\t\t\t\thas_root_sidx = GF_FALSE;\n\t\t\t}\n\n\n\t\t\tif (p) {\n\t\t\t\tif (ds->rep->segment_base && !ds->rep->segment_base->index_range) {\n\t\t\t\t\tGF_SAFEALLOC(ds->rep->segment_base->index_range, GF_MPD_ByteRange);\n\t\t\t\t\tif (ds->rep->segment_base->index_range) {\n\t\t\t\t\t\tds->rep->segment_base->index_range->start_range = p->value.lfrac.num;\n\t\t\t\t\t\tds->rep->segment_base->index_range->end_range = p->value.lfrac.den-1;\n\t\t\t\t\t\tds->rep->segment_base->index_range_exact = GF_TRUE;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!ds->rep->segment_base->initialization_segment) {\n\t\t\t\t\t\tGF_SAFEALLOC(ds->rep->segment_base->initialization_segment, GF_MPD_URL);\n\t\t\t\t\t}\n\t\t\t\t\tif (ds->rep->segment_base->initialization_segment && !ds->rep->segment_base->initialization_segment->byte_range) {\n\t\t\t\t\t\tGF_SAFEALLOC(ds->rep->segment_base->initialization_segment->byte_range, GF_MPD_ByteRange);\n\t\t\t\t\t\tif (ds->rep->segment_base->initialization_segment->byte_range) {\n\t\t\t\t\t\t\tds->rep->segment_base->initialization_segment->byte_range->start_range = 0;\n\t\t\t\t\t\t\tds->rep->segment_base->initialization_segment->byte_range->end_range = p->value.lfrac.num-1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if (!has_root_sidx) {\n\t\t\t\t\tctx->in_error = GF_TRUE;\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_DASH, (\"[Dasher] Several SIDX found but trying to regenerate an on-demand MPD, source file is not compatible. Try re-dashing the content or use main or full profiles\\n\"));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\n\tif (ctx->sfile) {\n\t\tGF_MPD_SegmentURL *seg_url;\n\t\tassert(ds->rep->segment_list);\n\n\t\tif (ctx->gencues) return;\n\n\t\tGF_SAFEALLOC(seg_url, GF_MPD_SegmentURL);\n\t\tif (!seg_url) return;\n\n\t\tgf_list_add(ds->rep->segment_list->segment_URLs, seg_url);\n\t\tif (szIndexName[0])\n\t\t\tseg_url->index = gf_strdup(szIndexName);\n\n\t\tif (ctx->sigfrag) {\n\t\t\tconst GF_PropertyValue *frag_range = gf_filter_pck_get_property(in_pck, GF_PROP_PCK_FRAG_RANGE);\n\t\t\tconst GF_PropertyValue *frag_url = gf_filter_pck_get_property(in_pck, GF_PROP_PID_URL);\n\t\t\tconst GF_PropertyValue *frag_name = gf_filter_pck_get_property(in_pck, GF_PROP_PCK_FILENAME);\n\t\t\tif (frag_url && frag_name) {\n\t\t\t\tseg_url->media = dasher_strip_base(ctx, ds, frag_url->value.string, frag_name->value.string);\n\t\t\t\tif (ds->rep->segment_list && ds->rep->segment_list->initialization_segment && !ds->rep->segment_list->initialization_segment->sourceURL) {\n\n\t\t\t\t\tfrag_url = gf_filter_pid_get_property(ds->ipid, GF_PROP_PID_URL);\n\t\t\t\t\tfrag_name = gf_filter_pid_get_property_str(ds->ipid, \"init_url\");\n\t\t\t\t\tif (frag_url && frag_name) {\n\t\t\t\t\t\tu32 j, nb_base;\n\t\t\t\t\t\tds->rep->segment_list->initialization_segment->sourceURL = dasher_strip_base(ctx, ds, frag_url->value.string, frag_name->value.string);\n\n\t\t\t\t\t\tnb_base = gf_list_count(ds->rep->base_URLs);\n\t\t\t\t\t\tfor (j=0; j<nb_base; j++) {\n\t\t\t\t\t\t\tGF_MPD_BaseURL *burl = gf_list_get(ds->rep->base_URLs, j);\n\t\t\t\t\t\t\tif (! strcmp(burl->URL, frag_url->value.string)) {\n\t\t\t\t\t\t\t\tgf_list_rem(ds->rep->base_URLs, j);\n\t\t\t\t\t\t\t\tgf_mpd_base_url_free(burl);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (frag_range) {\n\t\t\t\tGF_SAFEALLOC(seg_url->media_range, GF_MPD_ByteRange);\n\t\t\t\tif (seg_url->media_range) {\n\t\t\t\t\tseg_url->media_range->start_range = frag_range->value.lfrac.num;\n\t\t\t\t\tseg_url->media_range->end_range = frag_range->value.lfrac.den - 1;\n\t\t\t\t}\n\t\t\t\tif (ds->rep->segment_list && ds->rep->segment_list->initialization_segment && !ds->rep->segment_list->initialization_segment->byte_range) {\n\t\t\t\t\tGF_SAFEALLOC(ds->rep->segment_list->initialization_segment->byte_range, GF_MPD_ByteRange);\n\t\t\t\t\tif (ds->rep->segment_list->initialization_segment->byte_range) {\n\t\t\t\t\t\tds->rep->segment_list->initialization_segment->byte_range->start_range = 0;\n\t\t\t\t\t\tds->rep->segment_list->initialization_segment->byte_range->end_range = frag_range->value.lfrac.num-1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tgf_list_add(ds->pending_segment_urls, seg_url);\n\t\t\tctx->nb_seg_url_pending++;\n\t\t}\n\t\treturn;\n\t}\n\n\tif (!ds->stl && !ctx->cues && !ctx->forward_mode && (pck || in_pck) ) {\n\t\tDouble drift, seg_start = (Double) ds->seg_start_time;\n\t\tseg_start /= ds->mpd_timescale;\n\t\tdrift = seg_start - ((Double)(ds->seg_number - ds->startNumber)) * ds->dash_dur.num / ds->dash_dur.den;\n\n\t\tif ((ds->dash_dur.num>0) && (ABS(drift) * 2 * ds->dash_dur.den > ds->dash_dur.num)) {\n\t\t\tu64 cts = 0;\n\t\t\tif (pck) {\n\t\t\t\tcts = dasher_translate_cts(ds, gf_filter_pck_get_cts(pck) );\n\t\t\t} else if (in_pck) {\n\t\t\t\tcts = gf_filter_pck_get_cts(in_pck);\n\t\t\t}\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_DASH, (\"[Dasher] First CTS \"LLU\" in segment %d drifting by %g (more than half a segment duration) from segment time, consider reencoding or using segment timeline\\n\", cts, ds->seg_number,  drift));\n\t\t}\n\t}\n\n\tif (!ctx->forward_mode) {\n\t\t/*get final segment template - output file name is NULL, we already have solved this in source_setup\n\t\tsegment time must be PTO-adjusted !*/\n\t\tu64 pto = ds->presentation_time_offset;\n\t\tif (base_ds->timescale != base_ds->mpd_timescale) {\n\t\t\tpto = gf_timestamp_rescale(pto, base_ds->timescale, base_ds->mpd_timescale);\n\t\t}\n\n\t\tgf_media_mpd_format_segment_name(GF_DASH_TEMPLATE_SEGMENT, ds->set->bitstream_switching, szSegmentName, base_ds->rep_id, NULL, base_ds->seg_template, NULL, base_ds->seg_start_time + pto, base_ds->rep->bandwidth, base_ds->seg_number, ds->stl, ctx->tpl_force);\n\n\t}\n\n\nsend_packet:\n\n\tno_concat=GF_FALSE;\n\tif (ctx->from_index==IDXMODE_SEG) {\n\t\tconst GF_PropertyValue *p = gf_filter_pid_get_property_str(ds->ipid, \"idx_out\");\n\t\tif (p) {\n\t\t\tstrcpy(szSegmentName, p->value.string);\n\t\t\tstrcpy(szSegmentFullPath, p->value.string);\n\t\t\tno_concat = GF_TRUE;\n\t\t}\n\t}\n\tif (!no_concat)\n\t\tstrcpy(szSegmentFullPath, szSegmentName);\n\n\tif (!no_concat && ctx->out_path) {\n\t\tchar *rel = NULL;\n\t\tif (ctx->do_m3u8 && ds->hls_vp_name && !ctx->forward_mode) {\n\t\t\tchar *tmp = gf_url_concatenate(ctx->out_path, ds->hls_vp_name);\n\t\t\tif (tmp) {\n\t\t\t\trel = gf_url_concatenate(tmp, szSegmentName);\n\t\t\t\tgf_free(tmp);\n\t\t\t}\n\t\t}\n\t\tif (!rel)\n\t\t\trel = gf_url_concatenate(ctx->out_path, szSegmentName);\n\n\t\tif (rel) {\n\t\t\tstrcpy(szSegmentFullPath, rel);\n\t\t\tgf_free(rel);\n\t\t}\n\t}\n\n\tif (seg_state && !ctx->sigfrag) {\n\t\tseg_state->filepath = gf_strdup(szSegmentFullPath);\n\t\tseg_state->filename = gf_strdup(szSegmentName);\n\t}\n\n\tif (ds->rep->segment_list && (ctx->forward_mode!=DASHER_FWD_ALL) && !ctx->gencues) {\n\t\tGF_MPD_SegmentURL *seg_url;\n\t\tGF_SAFEALLOC(seg_url, GF_MPD_SegmentURL);\n\t\tif (seg_url) {\n\t\t\tgf_list_add(ds->rep->segment_list->segment_URLs, seg_url);\n\t\t\tif (!ctx->do_index) {\n\t\t\t\tseg_url->media = gf_strdup(szSegmentName);\n\t\t\t\tif (!ctx->index_media_duration) {\n\t\t\t\t\tgf_list_add(ds->pending_segment_urls, seg_url);\n\t\t\t\t\tctx->nb_seg_url_pending++;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tseg_url->first_tfdt = in_pck ? gf_filter_pck_get_dts(in_pck) : 0;\n\t\t\t\tseg_url->first_pck_seq = in_pck ? ds->nb_pck : 0;\n\t\t\t\tseg_url->frag_start_offset = ds->frag_start_offset;\n\t\t\t\tseg_url->frag_tfdt = ds->frag_first_ftdt;\n\t\t\t\t//set constant duration to first packet duration (as used by mp4mx to compute defaults)\n\t\t\t\t//this will avoid generating trex with different default duration if working with or without sample\n\t\t\t\tif (!ds->rep->segment_list->sample_duration) {\n\t\t\t\t\tif (in_pck) {\n\t\t\t\t\t\tds->rep->segment_list->sample_duration = gf_filter_pck_get_duration(in_pck);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconst GF_PropertyValue *p = gf_filter_pid_get_property(ds->ipid, GF_PROP_PID_CONSTANT_DURATION);\n\t\t\t\t\t\tif (p) ds->rep->segment_list->sample_duration = p->value.uint;\n\t\t\t\t\t}\n\n\t\t\t\t\tds->rep->segment_list->index_mode = GF_TRUE;\n\t\t\t\t\tif (ds->pts_minus_cts<0)\n\t\t\t\t\t\tds->rep->segment_list->pid_delay = (u32) (-ds->pts_minus_cts);\n\t\t\t\t\tds->rep->segment_list->src_timescale = ds->timescale;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (szIndexName[0])\n\t\t\t\tseg_url->index = gf_strdup(szIndexName);\n\t\t}\n\t}\n\tif (pck)\n\t\tgf_filter_pck_set_property(pck, GF_PROP_PCK_FILENAME, &PROP_STRING(szSegmentFullPath) );\n}\n\nstatic Bool dasher_check_loop(GF_DasherCtx *ctx, GF_DashStream *ds)\n{\n\tu32 i, count;\n\tu32 pmode = GF_PLAYBACK_MODE_NONE;\n\tu64 ts_offset, max_ts_offset, max_ts_scale;\n\tconst GF_PropertyValue *p;\n\tif (!ds->src_url) return GF_FALSE;\n\n\t//loop requested\n\tif (ds->loop_state==2) return GF_TRUE;\n\n\tcount = gf_list_count(ctx->current_period->streams);\n\tif (!ds->loop_state) {\n\t\tfor (i=0; i<count; i++) {\n\t\t\tGF_DashStream *a_ds = gf_list_get(ctx->current_period->streams, i);\n\n\t\t\tp = gf_filter_pid_get_property(a_ds->ipid, GF_PROP_PID_PLAYBACK_MODE);\n\t\t\tif (p) pmode = p->value.uint;\n\t\t\tif (pmode == GF_PLAYBACK_MODE_NONE) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_DASH, (\"[Dasher] Loop requested in subdur mode, but source cannot seek, defaulting to multi period for all streams\\n\"));\n\t\t\t\tctx->loop = GF_FALSE;\n\t\t\t\treturn GF_FALSE;\n\t\t\t}\n\t\t}\n\t\tds->loop_state = 1;\n\t}\n\n\tmax_ts_offset = 0;\n\tmax_ts_scale = 1;\n\t//check all input media duration\n\tfor (i=0; i<count; i++) {\n\t\tGF_DashStream *a_ds = gf_list_get(ctx->current_period->streams, i);\n\n\t\t//one pid is waiting for loop while another has done its subdur and won't process any new segment until the next subdur call, which\n\t\t//will never happen since the first PID waits for loop. We must force early generation in this case\n\t\tif (a_ds->subdur_done) {\n\t\t\ta_ds->subdur_done = GF_FALSE;\n\t\t\t//remember the max period dur before this forced segment generation\n\t\t\ta_ds->subdur_forced_use_period_dur = a_ds->max_period_dur;\n\t\t}\n\n\t\t//wait for each input to query loop\n\t\tif (!a_ds->loop_state) {\n\t\t\ta_ds->done = 0;\n\t\t\treturn GF_TRUE;\n\t\t}\n\n\t\t//get max duration\n\t\tts_offset = a_ds->est_next_dts;\n\n\t\tif (gf_timestamp_less(max_ts_offset, max_ts_scale, ts_offset, a_ds->timescale)) {\n\t\t\tmax_ts_offset = ts_offset;\n\t\t\tmax_ts_scale = a_ds->timescale;\n\t\t}\n\t}\n\n\t//assign ts offset and send stop/play\n\tfor (i=0; i<count; i++) {\n\t\tGF_DashStream *a_ds = gf_list_get(ctx->current_period->streams, i);\n\n\t\tif (a_ds->subdur_done)\n\t\t\tcontinue;\n\n\t\tts_offset = gf_timestamp_rescale(max_ts_offset, max_ts_scale, a_ds->timescale);\n\n\t\ta_ds->ts_offset = ts_offset;\n\t\tif (a_ds->done) continue;\n\t\tif (a_ds->ts_offset > a_ds->est_next_dts) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_DASH, (\"[Dasher] Looping streams of unequal duration, inserting \"LLU\" us of timestamp delay in pid %s from %s\\n\", ((a_ds->ts_offset - a_ds->est_next_dts) * 1000000) / a_ds->timescale, gf_filter_pid_get_name(a_ds->ipid), a_ds->src_url));\n\t\t}\n\n\t\ta_ds->seek_to_pck = 0;\n\t\ta_ds->nb_pck = 0;\n\t\ta_ds->clamp_done = GF_FALSE;\n\n\t\ta_ds->loop_state = 2;\n\n\t\tif (ctx->subdur) {\n\t\t\tGF_FilterEvent evt;\n\n\t\t\tGF_FEVT_INIT(evt, GF_FEVT_STOP, a_ds->ipid);\n\t\t\tgf_filter_pid_send_event(a_ds->ipid, &evt);\n\n\t\t\tgf_filter_pid_set_discard(a_ds->ipid, GF_FALSE);\n\n\t\t\tdasher_send_encode_hints(ctx, ds);\n\n\t\t\tGF_FEVT_INIT(evt, GF_FEVT_PLAY, a_ds->ipid);\n\t\t\tevt.play.speed = 1.0;\n\t\t\tgf_filter_pid_send_event(a_ds->ipid, &evt);\n\t\t}\n\t}\n\n\treturn GF_TRUE;\n}\n\n//depending on input formats, streams may be declared with or without DCD. For streams requiring the config, wait for it\nstatic Bool dasher_check_period_ready(GF_DasherCtx *ctx, Bool is_session_end)\n{\n\tu32 i=0;\n\tGF_DashStream *ds;\n\tctx->period_not_ready = GF_FALSE;\n\twhile ((ds = gf_list_enum(ctx->current_period->streams, &i))) {\n\n\t\tif (is_session_end)\n\t\t\tgf_filter_pid_set_discard(ds->ipid, GF_TRUE);\n\n\t\tif (ds->dcd_not_ready) {\n\t\t\tGF_FilterPacket *pck;\n\t\t\tu32 prev = ds->dcd_not_ready;\n\t\t\tds->dcd_not_ready = 0;\n\t\t\tpck = gf_filter_pid_get_packet(ds->ipid);\n\t\t\tif (!pck) {\n\t\t\t\tu32 diff = gf_sys_clock() - prev;\n\t\t\t\tif (diff > 10000) {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_DASH, (\"[Dasher] Failed to initialize PID %s, no packets after %d ms, aborting\\n\", gf_filter_pid_get_name(ds->ipid), diff));\n\t\t\t\t\tctx->in_error = GF_TRUE;\n\t\t\t\t\treturn GF_FALSE;\n\t\t\t\t}\n\t\t\t\tds->dcd_not_ready = prev;\n\t\t\t\tctx->period_not_ready = GF_TRUE;\n\t\t\t\treturn GF_FALSE;\n\t\t\t}\n\t\t}\n\t}\n\treturn GF_TRUE;\n}\n\nvoid dasher_format_report(GF_Filter *filter, GF_DasherCtx *ctx)\n{\n\tu32 i, count, nb_pc=0;\n\tDouble max_ts=0;\n\tu32 total_pc = 0;\n\tchar szDS[200];\n\tchar *szStatus = NULL;\n\n\tif (!gf_filter_reporting_enabled(filter))\n\t\treturn;\n\tif (!ctx->update_report)\n\t\treturn;\n\t//don't update at each packet, this would be too much\n\tif ((ctx->update_report>0) && (ctx->update_report < 20))\n\t\treturn;\n\n\tctx->update_report = 0;\n\n\tsprintf(szDS, \"P%s\", ctx->current_period->period->ID ? ctx->current_period->period->ID : \"1\");\n\tgf_dynstrcat(&szStatus, szDS, NULL);\n\n\tcount = gf_list_count(ctx->current_period->streams);\n\tfor (i=0; i<count; i++) {\n\t\ts32 pc=-1;\n\t\tDouble mpdtime;\n\t\tu32 set_idx;\n\t\tu32 rep_idx;\n\t\tu8 stype;\n\t\tGF_DashStream *ds = gf_list_get(ctx->current_period->streams, i);\n\t\tif (ds->muxed_base) continue;\n\n\t\tset_idx = 1 + gf_list_find(ctx->current_period->period->adaptation_sets, ds->set);\n\t\trep_idx = 1 + gf_list_find(ds->set->representations, ds->rep);\n\t\tif (ds->stream_type==GF_STREAM_VISUAL) stype='V';\n\t\telse if (ds->stream_type==GF_STREAM_AUDIO) stype='A';\n\t\telse if (ds->stream_type==GF_STREAM_TEXT) stype='T';\n\t\telse stype='M';\n\n\t\tif (ds->done || ds->subdur_done) {\n\t\t\tsprintf(szDS, \"AS#%d.%d(%c) done (%d segs)\", set_idx, rep_idx, stype, ds->seg_number);\n\t\t\tpc = 10000;\n\t\t} else {\n\t\t\tDouble done;\n\t\t\tif (ctx->cues) {\n\t\t\t\tdone = (Double) (ds->last_dts);\n\t\t\t\tdone /= ds->timescale;\n\t\t\t\tsnprintf(szDS, 200, \"AS#%d.%d(%c) seg #%d %02.2fs\", set_idx, rep_idx, stype, ds->seg_number, done);\n\t\t\t} else {\n\t\t\t\tDouble pcent, ddur;\n\t\t\t\tdone = (Double) ds->adjusted_next_seg_start;\n\t\t\t\tdone -= (Double) ds->last_dts;\n\t\t\t\tif (done<0)\n\t\t\t\t\tdone=0;\n\t\t\t\tdone /= ds->timescale;\n\t\t\t\tddur = ((Double)ds->dash_dur.num) / ds->dash_dur.den;\n\t\t\t\tdone = ddur - done;\n\t\t\t\t//this may happen since we don't print info at segment start\n\t\t\t\tif (done<0)\n\t\t\t\t\tdone=0;\n\t\t\t\tpcent = done / ddur;\n\t\t\t\tpc = (s32) (done * 10000);\n\t\t\t\tsnprintf(szDS, 200, \"AS#%d.%d(%c) seg #%d %02.2fs (%02.2f %%)\", set_idx, rep_idx, stype, ds->seg_number, done, 100*pcent);\n\t\t\t}\n\n\t\t\tmpdtime = (Double) ds->last_dts;\n\t\t\tmpdtime -= (Double) ds->first_dts;\n\t\t\tif (mpdtime<0) mpdtime=0;\n\t\t\tmpdtime /= ds->timescale;\n\n\t\t\tif (ds->duration.den && ds->duration.num) {\n\t\t\t\tdone = mpdtime;\n\n\t\t\t\tdone *= ds->duration.den;\n\t\t\t\tdone /= ds->duration.num;\n\t\t\t\tpc = (u32) (10000*done);\n\t\t\t}\n\t\t\tif (max_ts<mpdtime)\n\t\t\t\tmax_ts = mpdtime;\n\t\t}\n\t\t//don't use max, do an average\n\t\ttotal_pc += pc;\n\t\tnb_pc++;\n\t\tgf_dynstrcat(&szStatus, szDS, \" \");\n\t}\n\tif (nb_pc)\n\t\ttotal_pc /= nb_pc;\n\n\tif (total_pc!=10000) {\n\t\tsprintf(szDS, \" / MPD %.2fs %d %%\", max_ts, total_pc/100);\n\t\tgf_dynstrcat(&szStatus, szDS, NULL);\n\t}\n\tgf_filter_update_status(filter, total_pc, szStatus);\n\tgf_free(szStatus);\n}\n\nstatic void dasher_drop_input(GF_DasherCtx *ctx, GF_DashStream *ds, Bool discard_all)\n{\n\tif (ds->sbound) {\n\t\twhile (gf_list_count(ds->packet_queue)) {\n\t\t\tGF_FilterPacket *pck = gf_list_pop_front(ds->packet_queue);\n\t\t\tif (gf_filter_pck_get_sap(pck)) {\n\t\t\t\tassert(ds->nb_sap_in_queue);\n\t\t\t\tds->nb_sap_in_queue --;\n\t\t\t}\n\t\t\tgf_filter_pck_unref(pck);\n\t\t\tif (!discard_all) break;\n\t\t}\n\t} else {\n\t\tgf_filter_pid_drop_packet(ds->ipid);\n\t}\n\tif (discard_all) {\n\t\tgf_filter_pid_set_discard(ds->ipid, GF_TRUE);\n\t}\n}\n\nstatic void dasher_inject_eods(GF_DasherCtx *ctx, GF_DashStream *ds, Bool forced)\n{\n\t//in dynamic mode, send end of dash segment marker to flush segment right away, otherwise we will\n\t//flush the segment at next segment start which could be after the segment AST => 404\n\t//\n\t//if subdur no need to do so as we will close the muxer right after\n\t//if sigfrag no need to do so since we don't generate media packets\n\tif (!ctx->subdur && ((ctx->dmode>=GF_DASH_DYNAMIC) || forced) && !ctx->sigfrag && !ctx->do_index) {\n\t\tGF_FilterPacket *eods_pck;\n\t\teods_pck = gf_filter_pck_new_alloc(ds->opid, 0, NULL);\n\t\tif (eods_pck) {\n\t\t\tgf_filter_pck_set_property(eods_pck, GF_PROP_PCK_EODS, &PROP_BOOL(GF_TRUE) );\n\t\t\tgf_filter_pck_send(eods_pck);\n\t\t}\n\t}\n}\n\nstatic const char *empty_ttml = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n<tt xmlns=\\\"http://www.w3.org/ns/ttml\\\" xml:lang=\\\"en\\\">\\n<head/>\\n<body/>\\n</tt>\";\n\nstatic void dasher_send_empty_segment(GF_DasherCtx *ctx, GF_DashStream *ds)\n{\n\tGF_FilterPacket *pck=NULL;\n\tu8 *data;\n\n\tif (ds->segment_started) {\n\t\tu64 next_cts = ds->first_cts_in_seg + gf_timestamp_rescale(ds->dash_dur.num, ds->dash_dur.den, ds->timescale);\n\t\tds->first_cts_in_next_seg = next_cts;\n\t\tassert(ds->nb_comp_done < ds->nb_comp);\n\t\tds->nb_comp_done ++;\n\t\tds->split_dur_next = 0;\n\t\tds->seg_done = GF_TRUE;\n\n\t\tdasher_inject_eods(ctx, ds, GF_FALSE);\n\n\t\t//force to be last rep in set to be done\n\t\tds->nb_rep_done = ds->nb_rep-1;\n\t\tdasher_flush_segment(ctx, ds, GF_FALSE);\n\n\t\tds->first_cts_in_seg = next_cts;\n\t\tds->split_dur_next = 0;\n\t}\n\n\tif (ds->opid && (!ctx->from_index || (ctx->from_index==IDXMODE_SEG) )) {\n\n\t\tif (ds->codec_id == GF_CODECID_SUBS_XML) {\n\t\t\t//write empty TTML doc\n\t\t\tu32 len = (u32) strlen(empty_ttml);\n\t\t\tpck = gf_filter_pck_new_alloc(ds->opid, len+1, &data);\n\t\t\tmemcpy(data, empty_ttml, len);\n\t\t\tdata[len] = 0;\n\t\t} else if (ds->codec_id == GF_CODECID_WEBVTT) {\n\t\t\t//write empty cue box, 8 byte size of type vtte\n\t\t\tpck = gf_filter_pck_new_alloc(ds->opid, 8, &data);\n\t\t\tdata[0] = data[1] = data[2] = 0; data[3] = 8;\n\t\t\tdata[4] = 'v'; data[5] = 't'; data[6] = 't'; data[7] = 'e';\n\t\t} else if (ds->codec_id == GF_CODECID_TX3G) {\n\t\t\t//write empty tx3g sample, 2 bytes text len=0\n\t\t\tpck = gf_filter_pck_new_alloc(ds->opid, 2, &data);\n\t\t\tdata[0] = data[1] = 0;\n\t\t} else {\n\t\t\tpck = gf_filter_pck_new_alloc(ds->opid, 0, &data);\n\t\t}\n\n\t\tgf_filter_pck_set_dts(pck, ds->first_cts_in_seg);\n\t\tgf_filter_pck_set_cts(pck, ds->first_cts_in_seg);\n\t\tgf_filter_pck_set_sap(pck, GF_FILTER_SAP_1);\n\t\t//we don't assign a duration\n\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_DASH, (\"[Dasher] Sending empty text packet CTS \"LLU\"/%d\\n\", ds->first_cts_in_seg, ds->timescale));\n\t}\n\n\tdasher_mark_segment_start(ctx, ds, pck, NULL);\n\tds->segment_started = GF_TRUE;\n\tif (pck)\n\t\tgf_filter_pck_send(pck);\n\n\tif (ctx->do_index) {\n\t\tGF_MPD_SegmentURL *s = gf_list_last(ds->rep->segment_list->segment_URLs);\n\t\ts->first_tfdt = ds->first_cts_in_seg;\n\t}\n\n\tds->first_cts_in_next_seg = ds->first_cts_in_seg + gf_timestamp_rescale(ds->dash_dur.num, ds->dash_dur.den, ds->timescale);\n\tds->est_first_cts_in_next_seg = ds->first_cts_in_next_seg;\n}\n\n\n\nstatic GF_Err dasher_process(GF_Filter *filter)\n{\n\tu32 i, count, nb_init, has_init, nb_reg_done;\n\tGF_DasherCtx *ctx = gf_filter_get_udta(filter);\n\tGF_Err e;\n\tBool seg_done = GF_FALSE;\n\tu32 nb_seg_waiting = 0;\n\tu32 nb_seg_active = 0;\n\n\tif (ctx->in_error) {\n\t\tgf_filter_abort(filter);\n\t\treturn GF_SERVICE_ERROR;\n\t}\n\tif (!ctx->utc_initialized) {\n\t\tdasher_init_utc(filter, ctx);\n\t\tif (!ctx->utc_initialized) return GF_OK;\n\t}\n\n\t//session regulation is on and we have a an MPD (setup done) and a next time (first seg processed)\n\t//check if we have reached the next time\n\tif (ctx->sreg && !ctx->state && ctx->mpd && ctx->mpd->gpac_next_ntp_ms) {\n\t\ts64 diff = (s64) ctx->mpd->gpac_next_ntp_ms;\n\t\tdiff -= (s64) gf_net_get_ntp_ms();\n\t\tif (diff>100) {\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_DASH, (\"[Dasher] Next generation scheduled in %d ms, nothing to do\\n\", diff));\n\t\t\tgf_filter_ask_rt_reschedule(filter, (u32) (diff*1000));\n\t\t\treturn GF_OK;\n\t\t}\n\t}\n\n\t//streams in period are not all ready, wait for them\n\tif (ctx->period_not_ready) {\n\t\tBool is_eos;\n\t\t//potpone until no pending connections, otherwise we may add input streams in the wrong period\n\t\tif (gf_filter_connections_pending(filter))\n\t\t\treturn GF_OK;\n\n\t\tis_eos = gf_filter_end_of_session(filter);\n\t\tif (! dasher_check_period_ready(ctx, is_eos)) {\n\t\t\treturn is_eos ? GF_SERVICE_ERROR : GF_OK;\n\t\t}\n\t\te = dasher_setup_period(filter, ctx, NULL);\n\t\tif (e) return e;\n\t}\n\tif (ctx->check_connections) {\n\t\tif (gf_filter_connections_pending(filter))\n\t\t\treturn GF_OK;\n\t\tctx->check_connections = GF_FALSE;\n\t}\n\n\tif (ctx->is_eos)\n\t\treturn GF_EOS;\n\tif (ctx->setup_failure) return ctx->setup_failure;\n\n\tcount = gf_list_count(ctx->current_period->streams);\n\tif (!ctx->min_cts_period.den) {\n\t\tu64 min_ts=0, min_timescale = 0;\n\t\tu32 num_ready=0, num_blocked=0;\n\t\tfor (i=0; i<count; i++) {\n\t\t\tGF_DashStream *ds = gf_list_get(ctx->current_period->streams, i);\n\t\t\tif (ctx->force_period_switch) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tGF_FilterPacket *pck = gf_filter_pid_get_packet(ds->ipid);\n\t\t\tif (!pck) continue;\n\t\t\tu64 ts = gf_filter_pck_get_cts(pck);\n\t\t\t//only adjust if delay is negative (skip), otherwise (delay) keep mints as is.\n\t\t\t//Not doing so will set the rep PTO to the delay, canceling the delay ...\n\t\t\tif (ds->pts_minus_cts<0)\n\t\t\t\tts = ts + ds->pts_minus_cts;\n\t\t\tif (!min_ts || gf_timestamp_less(ts, ds->timescale, min_ts, min_timescale)) {\n\t\t\t\tmin_ts = ts;\n\t\t\t\tmin_timescale = ds->timescale;\n\t\t\t}\n\t\t\tnum_ready++;\n\t\t\tif (gf_filter_pid_would_block(ds->ipid)) num_blocked++;\n\t\t}\n\t\tif (count) {\n\t\t\tif (num_ready < num_blocked) return GF_OK;\n\t\t}\n\t\tctx->min_cts_period.num = min_ts;\n\t\tctx->min_cts_period.den = min_timescale;\n\n\t\tif (ctx->force_period_switch)\n\t\t\tcount = gf_list_count(ctx->current_period->streams);\n\t}\n\n\tnb_init = has_init = nb_reg_done = 0;\n\n\tfor (i=0; i<count; i++) {\n\t\tGF_DashStream *base_ds;\n\t\tGF_DashStream *ds = gf_list_get(ctx->current_period->streams, i);\n\t\tassert(ds);\n\t\tif (ds->done) continue;\n\t\tbase_ds = ds->muxed_base ? ds->muxed_base : ds;\n\t\t//subdur mode abort, don't process\n\t\tif (ds->subdur_done) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (ds->seg_done) continue;\n\n\t\tif (ctx->dmode == GF_MPD_TYPE_DYNAMIC_LAST) {\n\t\t\tif (!ds->done && ds->opid) gf_filter_pid_set_eos(ds->opid);\n\t\t\tds->done = 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\t//flush as much as possible\n\t\twhile (1) {\n\t\t\tu32 sap_type, dur, o_dur, split_dur;\n\t\t\ts32 check_dur;\n\t\t\tu64 cts, orig_cts, dts, split_dur_next, pcont_cts;\n\t\t\tBool seg_over = GF_FALSE;\n\t\t\tBool is_packet_split = GF_FALSE;\n\t\t\tBool is_queue_flush = GF_FALSE;\n\t\t\tGF_FilterPacket *dst;\n\t\t\tGF_FilterPacket *pck = NULL;\n\n\t\t\tif (!ds->request_period_switch) {\n\t\t\t\tassert(ds->period == ctx->current_period);\n\t\t\t\tpck = gf_filter_pid_get_packet(ds->ipid);\n\t\t\t\t//we may change period after a packet fetch (reconfigure of input pid)\n\t\t\t\tif ((ds->period != ctx->current_period) || ds->request_period_switch) {\n\t\t\t\t\t//in closest mode, flush queue\n\t\t\t\t\tif (!ds->sbound || !gf_list_count(ds->packet_queue)) {\n\t\t\t\t\t\tassert(gf_list_find(ctx->current_period->streams, ds)<0);\n\t\t\t\t\t\tcount = gf_list_count(ctx->current_period->streams);\n\t\t\t\t\t\ti--;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tis_queue_flush = GF_TRUE;\n\t\t\t\t}\n\n\t\t\t\t/*text streams, insert an empty segment if we are one segment behind last produced segment on other pids\n\t\t\t\t- we don't generate if behind this last time in case a next packet comes in\n\t\t\t\t- we only insert an empty segment if PID is done (eos) or if we generate for real-time\n\n\t\t\t\tWe cannot apply this in non real-time before end of stream, as we would end up starting a segment while next packet could be in the past (previous seg)\n\n\t\t\t\tTODO: extend this to send empty segments for other streams (audio, video) in case of signal loss ??\n\t\t\t\t*/\n\t\t\t\tif (!pck\n\t\t\t\t\t&& (ds->stream_type==GF_STREAM_TEXT)\n\t\t\t\t\t&& !ds->muxed_base\n\t\t\t\t\t&& (gf_filter_pid_is_eos(ds->ipid) || (ctx->dmode==GF_MPD_TYPE_DYNAMIC))\n\t\t\t\t) {\n\t\t\t\t\tu64 ddur_ms = (1000*ds->dash_dur.num)/ds->dash_dur.den;\n\t\t\t\t\twhile (ds->last_min_segment_start_time + ddur_ms < ctx->last_min_segment_start_time) {\n\t\t\t\t\t\tdasher_send_empty_segment(ctx, ds);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tis_queue_flush = GF_TRUE;\n\t\t\t}\n\t\t\tif (ds->sbound && pck && gf_filter_pck_is_blocking_ref(pck)) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_DASH, (\"[Dasher] Cannot use `sbound` with blocking input packet references, disabling packet buffering for PID %s\\n\", gf_filter_pid_get_name(ds->ipid) ));\n\t\t\t\tds->sbound = DASHER_BOUNDS_OUT;\n\t\t\t}\n\n\t\t\t//skipped merged tile base\n\t\t\tif (ds->merged_tile_dep) {\n\t\t\t\tif (pck) gf_filter_pid_drop_packet(ds->ipid);\n\t\t\t\tpck = NULL;\n\t\t\t}\n\t\t\t//queue mode\n\t\t\telse if (ds->sbound) {\n\t\t\t\tif (!is_queue_flush && pck) {\n\t\t\t\t\tgf_filter_pck_ref(&pck);\n\t\t\t\t\tgf_filter_pid_drop_packet(ds->ipid);\n\t\t\t\t\tgf_list_add(ds->packet_queue, pck);\n\t\t\t\t\tif (gf_filter_pck_get_sap(pck))\n\t\t\t\t\t\tds->nb_sap_in_queue ++;\n\t\t\t\t}\n\t\t\t\tif (\n\t\t\t\t\t//we are flushing due to period switch\n\t\t\t\t\tis_queue_flush\n\t\t\t\t\t//we are flushing due to end of stream\n\t\t\t\t\t|| gf_filter_pid_is_eos(ds->ipid) || ds->clamp_done\n\t\t\t\t) {\n\t\t\t\t\tpck = gf_list_get(ds->packet_queue, 0);\n\t\t\t\t\tis_queue_flush = GF_TRUE;\n\t\t\t\t} else if (\n\t\t\t\t\t//if current segment is not started, always get packet from queue\n\t\t\t\t\t!ds->segment_started\n\t\t\t\t\t//wait until we have more than 2 saps to get packet from queue, to check if next sap will be closer or not\n\t\t\t\t\t|| (ds->nb_sap_in_queue>=2)\n\t\t\t\t) {\n\t\t\t\t\tpck = gf_list_get(ds->packet_queue, 0);\n\t\t\t\t} else {\n\t\t\t\t\tpck = NULL;\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t\tif (!pck) {\n\t\t\t\tBool ds_is_done=GF_FALSE;\n\t\t\t\tif (ds->request_period_switch) {\n\t\t\t\t\te = dasher_stream_period_changed(filter, ctx, ds, (ds->request_period_switch==2) ? GF_TRUE : GF_FALSE);\n\t\t\t\t\tif (e < 0) {\n\t\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_DASH, (\"[Dasher] Period switch request failed.\\n\"));\n\t\t\t\t\t\ti--;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tassert(gf_list_find(ctx->current_period->streams, ds)<0);\n\t\t\t\t\tcount = gf_list_count(ctx->current_period->streams);\n\t\t\t\t\ti--;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (ds->clamp_done) ds_is_done=GF_TRUE;\n\t\t\t\telse if (gf_filter_pid_is_eos(ds->ipid)) {\n\t\t\t\t\tif (gf_filter_pid_is_flush_eos(ds->ipid)) {\n\t\t\t\t\t\tif (ds->segment_started && !ds->seg_done) {\n\t\t\t\t\t\t\tds->seg_done = GF_TRUE;\n\t\t\t\t\t\t\tds->first_cts_in_next_seg = ds->est_first_cts_in_next_seg;\n\t\t\t\t\t\t\tds->est_first_cts_in_next_seg = 0;\n\t\t\t\t\t\t\tassert(base_ds->nb_comp_done < base_ds->nb_comp);\n\t\t\t\t\t\t\tbase_ds->nb_comp_done ++;\n\t\t\t\t\t\t\tif (base_ds->nb_comp_done == base_ds->nb_comp) {\n\t\t\t\t\t\t\t\tdasher_flush_segment(ctx, base_ds, GF_FALSE);\n\t\t\t\t\t\t\t\tdasher_inject_eods(ctx, base_ds, GF_TRUE);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n \t\t\t\t\t} else {\n\t\t\t\t\t\tds_is_done=GF_TRUE;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (ds_is_done) {\n\t\t\t\t\tu32 ds_done = 1;\n\n\t\t\t\t\tif (!ds->clamp_done && !ds->muxed_base && (ds->stream_type==GF_STREAM_TEXT)) {\n\t\t\t\t\t\tu32 s_idx;\n\t\t\t\t\t\tu64 ddur_ms;\n\t\t\t\t\t\tBool over = GF_TRUE;\n\t\t\t\t\t\tfor (s_idx=0; s_idx<count; s_idx++) {\n\t\t\t\t\t\t\tGF_DashStream *a_ds = gf_list_get(ctx->current_period->streams, s_idx);\n\t\t\t\t\t\t\tif (a_ds == ds) continue;\n\t\t\t\t\t\t\tif (a_ds->stream_type==GF_STREAM_TEXT) continue;\n\t\t\t\t\t\t\tif (!a_ds->done) {\n\t\t\t\t\t\t\t\tover = GF_FALSE;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!over)\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t//text streams, insert empty segments if we are one segment behind (and including) last produced segment on other pids\n\t\t\t\t\t\tddur_ms = (1000*ds->dash_dur.num)/ds->dash_dur.den;\n\t\t\t\t\t\twhile (ds->last_min_segment_start_time + ddur_ms <= ctx->min_segment_start_time) {\n\t\t\t\t\t\t\tdasher_send_empty_segment(ctx, ds);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\n\t\t\t\t\tif (ctx->loop && dasher_check_loop(ctx, ds)) {\n\t\t\t\t\t\tif (ctx->subdur)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t//loop on the entire source, consider the stream not done for segment flush\n\t\t\t\t\t\tds_done = 0;\n\t\t\t\t\t}\n\n\t\t\t\t\tds->clamp_done = GF_FALSE;\n\n\t\t\t\t\tctx->update_report = -1;\n\t\t\t\t\t//opid may be NULL for skipped tile rep\n\t\t\t\t\tif (!ctx->sigfrag && ds->opid)\n\t\t\t\t\t\tgf_filter_pid_set_eos(ds->opid);\n\n\t\t\t\t\tif (!ds->done) ds->done = ds_done;\n\t\t\t\t\tds->seg_done = GF_TRUE;\n\t\t\t\t\tseg_done = GF_TRUE;\n\t\t\t\t\tds->first_cts_in_next_seg = ds->est_first_cts_in_next_seg;\n\t\t\t\t\tds->est_first_cts_in_next_seg = 0;\n\t\t\t\t\tassert(base_ds->nb_comp_done < base_ds->nb_comp);\n\t\t\t\t\tbase_ds->nb_comp_done ++;\n\t\t\t\t\tif (base_ds->nb_comp_done == base_ds->nb_comp) {\n\t\t\t\t\t\tdasher_flush_segment(ctx, base_ds, GF_FALSE);\n\t\t\t\t\t}\n\t\t\t\t\t//loop on the entire source, mark as done for subdur and check if all other streams are done\n\t\t\t\t\tif (!ds->done) {\n\t\t\t\t\t\tu32 j;\n\t\t\t\t\t\tds->done = 2;\n\t\t\t\t\t\tds->subdur_done = GF_TRUE;\n\t\t\t\t\t\tu32 nb_sub_done=0;\n\t\t\t\t\t\tfor (j=0; j<count; j++) {\n\t\t\t\t\t\t\tGF_DashStream *a_ds = gf_list_get(ctx->current_period->streams, j);\n\t\t\t\t\t\t\tif (a_ds->muxed_base) a_ds = a_ds->muxed_base;\n\t\t\t\t\t\t\tif (a_ds->subdur_done) {\n\t\t\t\t\t\t\t\tnb_sub_done++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (nb_sub_done==count)\n\t\t\t\t\t\t\tctx->subdur_done = GF_TRUE;\n\t\t\t\t\t} else if (ctx->reschedule && !ctx->loop && (ctx->dmode==GF_MPD_TYPE_DYNAMIC) && !strcmp(ds->period_id, DEFAULT_PERIOD_ID) ) {\n\t\t\t\t\t\tif (gf_list_find(ctx->next_period->streams, ds)<0) {\n\t\t\t\t\t\t\tgf_list_add(ctx->next_period->streams, ds);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tctx->post_play_events = GF_TRUE;\n\t\t\t\t\t\tds->nb_repeat++;\n\t\t\t\t\t\tds->reschedule = GF_TRUE;\n\t\t\t\t\t\tgf_filter_pid_discard_block(ds->opid);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//no packet, muxed rep and base DS done, flush - required if no packet is present for the segment\n\t\t\t\t//typically for subs\n\t\t\t\telse if (ds->muxed_base && base_ds->seg_done && !ds->seg_done && !ds->is_av) {\n\t\t\t\t\tds->seg_done = GF_TRUE;\n\t\t\t\t\tds->first_cts_in_next_seg = ds->est_first_cts_in_next_seg;\n\t\t\t\t\tds->est_first_cts_in_next_seg = 0;\n\t\t\t\t\tassert(base_ds->nb_comp_done < base_ds->nb_comp);\n\t\t\t\t\tbase_ds->nb_comp_done ++;\n\t\t\t\t\tif (base_ds->nb_comp_done == base_ds->nb_comp) {\n\t\t\t\t\t\tdasher_flush_segment(ctx, base_ds, GF_FALSE);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (ds->seek_to_pck) {\n\t\t\t\tu32 sn = gf_filter_pck_get_seq_num(pck);\n\t\t\t\tif (sn) {\n\t\t\t\t\tif (sn <= ds->seek_to_pck) {\n\t\t\t\t\t\tdasher_drop_input(ctx, ds, GF_FALSE);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tds->nb_pck = sn-1;\n\t\t\t\t} else {\n\t\t\t\t\t//no sn signaled, this implies we played from the beginning\n\t\t\t\t\tif (ds->nb_pck < ds->seek_to_pck) {\n\t\t\t\t\t\tds->nb_pck ++;\n\t\t\t\t\t\tdasher_drop_input(ctx, ds, GF_FALSE);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tsap_type = gf_filter_pck_get_sap(pck);\n\t\t\tds->loop_state = 0;\n\n\t\t\tcts = gf_filter_pck_get_cts(pck);\n\t\t\tdts = gf_filter_pck_get_dts(pck);\n\t\t\tif (dts==GF_FILTER_NO_TS) dts = cts;\n\n\t\t\tif (!sap_type && (ds->sync_points_type != DASHER_SYNC_PRESENT)) {\n\t\t\t\tds->sync_points_type = DASHER_SYNC_PRESENT;\n\t\t\t\t//cf setup_period: in sbound=0 mode, if stream has sync and non-sync and uses skip samples, allow spliting\n\t\t\t\t//slightly before - typically needed for audio with sync points (usac, mpegh) where the segment duration is set\n\t\t\t\t//to the intra interval, we need to take into account the skip samples\n\t\t\t\tif (!ctx->sbound && !ds->cues\n\t\t\t\t\t&& (ds->pts_minus_cts<0) && (ds->next_seg_start> (u32) -ds->pts_minus_cts)\n\t\t\t\t) {\n\t\t\t\t\tds->next_seg_start -= (u32) -ds->pts_minus_cts;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ((ctx->strict_sap==DASHER_SAP_INTRA_ONLY) && (sap_type>=4))\n\t\t\t\tsap_type = 0;\n\n\t\t\tpcont_cts = cts;\n\n\t\t\tif (!ds->rep_init) {\n\t\t\t\tu32 set_start_with_sap;\n\t\t\t\t//for video, resync on sap 1 or 2 if not full profile\n\t\t\t\tif ((ds->stream_type==GF_STREAM_VISUAL) && (ctx->profile != GF_DASH_PROFILE_FULL)) {\n\t\t\t\t\tif ((sap_type!=GF_FILTER_SAP_1) && (sap_type!=GF_FILTER_SAP_2))\n\t\t\t\t\t\tsap_type = 0;\n\t\t\t\t}\n\t\t\t\tif (!sap_type) {\n\t\t\t\t\t//remember our timing\n\t\t\t\t\tif (!ds->presentation_time_offset)\n\t\t\t\t\t\tds->presentation_time_offset = cts + 1;\n\n\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_DASH, (\"[Dasher] Representation not initialized, dropping non-SAP1/2 packet CTS \"LLU\"/%d\\n\", cts, ds->timescale));\n\t\t\t\t\tdasher_drop_input(ctx, ds, GF_FALSE);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tset_start_with_sap = ctx->sseg ? base_ds->set->subsegment_starts_with_sap : base_ds->set->starts_with_sap;\n\t\t\t\tif (!ds->muxed_base) {\n\t\t\t\t\tu64 check_ts;\n\t\t\t\t\t//force sap type to 1 for non-visual streams if strict_sap is set to off\n\t\t\t\t\tif ((ds->stream_type!=GF_STREAM_VISUAL) && (ctx->strict_sap==DASHER_SAP_OFF) ) {\n\t\t\t\t\t\tswitch (ds->codec_id) {\n\t\t\t\t\t\t//MPEG-H requires saps\n\t\t\t\t\t\tcase GF_CODECID_MPHA:\n\t\t\t\t\t\tcase GF_CODECID_MHAS:\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tsap_type = 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t//set AS sap type\n\t\t\t\t\tif (!set_start_with_sap) {\n\t\t\t\t\t\t//don't set SAP type if not a base rep - could be further checked\n\t\t\t\t\t\t//if (!gf_list_count(ds->complementary_streams) )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (ctx->sseg) {\n\t\t\t\t\t\t\t\tds->set->subsegment_starts_with_sap = sap_type;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tds->set->starts_with_sap = sap_type;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if (set_start_with_sap != sap_type) {\n\t\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_DASH, (\"[Dasher] Segments do not start with the same SAP types: set initialized with %d but first packet got %d - bitstream will not be compliant\\n\", set_start_with_sap, sap_type));\n\t\t\t\t\t}\n\n\t\t\t\t\tcheck_ts = cts;\n\t\t\t\t\t//in case we droped frames\n\t\t\t\t\tif (ds->presentation_time_offset)\n\t\t\t\t\t\tcheck_ts = ds->presentation_time_offset - 1;\n\t\t\t\t\tds->presentation_time_offset = 0;\n\t\t\t\t\t//The code below assumes that the first frame in the stream has a presentation time of 0\n\t\t\t\t\tif ((s64) check_ts + ds->pts_minus_cts > 0) {\n\t\t\t\t\t\tu64 pto = check_ts + ds->pts_minus_cts;\n\t\t\t\t\t\tu64 pto_adj = pto;\n\t\t\t\t\t\tif (ds->timescale != ds->mpd_timescale) {\n\t\t\t\t\t\t\tpto_adj = gf_timestamp_rescale(pto_adj, ds->timescale, ds->mpd_timescale);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (ctx->min_cts_period.den) {\n\t\t\t\t\t\t\tu64 diff = gf_timestamp_rescale(ctx->min_cts_period.num, ctx->min_cts_period.den, ds->mpd_timescale);\n\t\t\t\t\t\t\tpto_adj = diff;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (ds->rep->segment_list)\n\t\t\t\t\t\t\tds->rep->segment_list->presentation_time_offset = pto_adj;\n\t\t\t\t\t\telse if (ds->rep->segment_template)\n\t\t\t\t\t\t\tds->rep->segment_template->presentation_time_offset = pto_adj;\n\t\t\t\t\t\telse if (ds->set->segment_template)\n\t\t\t\t\t\t\tds->set->segment_template->presentation_time_offset = pto_adj;\n\t\t\t\t\t\telse if (ds->set->segment_list)\n\t\t\t\t\t\t\tds->set->segment_list->presentation_time_offset = pto_adj;\n\t\t\t\t\t\telse if (ds->rep->segment_base) {\n\t\t\t\t\t\t\tds->rep->segment_base->presentation_time_offset = pto_adj;\n\t\t\t\t\t\t\tds->rep->segment_base->timescale = ds->mpd_timescale;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tds->presentation_time_offset = pto;\n\t\t\t\t\t}\n\t\t\t\t\t//period continuity, skip priming in new periods\n\t\t\t\t\tif (ds->period_continuity_id)\n\t\t\t\t\t\tds->pts_minus_cts = 0;\n\t\t\t\t}\n\n\t\t\t\tds->first_cts = cts;\n\t\t\t\tds->first_dts = dts;\n\t\t\t\tif (ctx->do_index) {\n\t\t\t\t\tds->rep->segment_list->first_cts_offset = (s32) ((s64) ds->first_cts - (s64) ds->first_dts);\n\t\t\t\t}\n\t\t\t\tds->rep_init++;\n\t\t\t\thas_init++;\n\t\t\t}\n\n\t\t\tnb_init++;\n\n\t\t\tif (ds->ts_offset) {\n\t\t\t\tcts += ds->ts_offset;\n\t\t\t\tdts += ds->ts_offset;\n\t\t\t}\n\n\t\t\t//ready to write MPD for the first time in dynamic mode with template\n\t\t\tif (has_init && (nb_init==count) && (ctx->dmode==GF_MPD_TYPE_DYNAMIC) && ctx->tpl && ctx->do_mpd && !ctx->dyn_rate) {\n\t\t\t\te = dasher_send_manifest(filter, ctx, GF_TRUE);\n\t\t\t\tif (e) return e;\n\t\t\t}\n\n\t\t\tcts = dasher_translate_cts(ds, cts);\n\t\t\tdts -= ds->first_dts;\n\n\t\t\tif (ctx->sreg && ctx->mpd->gpac_mpd_time && gf_timestamp_greater(dts, ds->timescale, ctx->mpd->gpac_mpd_time, 1000)) {\n\t\t\t\tnb_reg_done++;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tdur = o_dur = gf_filter_pck_get_duration(pck);\n\t\t\tpcont_cts += dur;\n\t\t\tif (ds->period_continuity_next_cts < pcont_cts)\n\t\t\t\tds->period_continuity_next_cts = pcont_cts;\n\n\t\t\tsplit_dur = 0;\n\t\t\tsplit_dur_next = 0;\n\n\t\t\t//patch to align old arch with new\n\t\t\tcheck_dur = 0;\n\t\t\tif (ds->stream_type==GF_STREAM_AUDIO)\n\t\t\t\tcheck_dur = dur;\n\n\t\t\t//perform regulation of inputs to avoid dashing one stream faster than the others\n\t\t\t//this is needed when inputs are not realtime and we have text streams for which we must decide\n\t\t\t//if we insert empty segments\n\t\t\tif (!base_ds->segment_started && ctx->min_segment_start_time) {\n\t\t\t\torig_cts = cts;\n\t\t\t\tif (ds->split_dur_next)\n\t\t\t\t\tcts += ds->split_dur_next;\n\n\t\t\t\tif (gf_timestamp_greater(cts, ds->timescale, ctx->min_segment_start_time, 1000)) {\n\t\t\t\t\tnb_seg_waiting++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcts = orig_cts;\n\t\t\t}\n\t\t\tnb_seg_active++;\n\n\t\t\t//adjust duration and cts\n\t\t\torig_cts = cts;\n\t\t\tif (ds->split_dur_next) {\n\t\t\t\tcts += ds->split_dur_next;\n\t\t\t\tassert(dur > ds->split_dur_next);\n\t\t\t\tdur -= ds->split_dur_next;\n\t\t\t\tsplit_dur_next = ds->split_dur_next;\n\t\t\t\tds->split_dur_next = 0;\n\t\t\t\tis_packet_split = GF_TRUE;\n\t\t\t}\n\n\t\t\tif (ds->splitable && !ds->split_dur_next && !ds->cues && !ds->inband_cues) {\n\t\t\t\tBool do_split = GF_FALSE;\n\t\t\t\t//adding this sample would exceed the segment duration\n\t\t\t\tif (gf_sys_old_arch_compat()) {\n\t\t\t\t\tif (gf_timestamp_greater_or_equal(cts + dur, ds->timescale, base_ds->adjusted_next_seg_start, base_ds->timescale))\n\t\t\t\t\t\tdo_split = GF_TRUE;\n\t\t\t\t} else {\n\t\t\t\t\tif ( gf_timestamp_greater(cts + dur, ds->timescale, base_ds->adjusted_next_seg_start, base_ds->timescale))\n\t\t\t\t\t\tdo_split = GF_TRUE;\n\t\t\t\t}\n\t\t\t\tif (do_split) {\n\t\t\t\t\t//this sample starts in the current segment - split it\n\t\t\t\t\tif (gf_timestamp_less(cts, ds->timescale, base_ds->adjusted_next_seg_start, base_ds->timescale) ) {\n\t\t\t\t\t\tsplit_dur = (u32) (gf_timestamp_rescale(base_ds->adjusted_next_seg_start, base_ds->timescale, ds->timescale) - ds->last_cts);\n\n\t\t\t\t\t\tif (gf_sys_old_arch_compat() && (split_dur==dur))\n\t\t\t\t\t\t\tsplit_dur=0;\n\n\t\t\t\t\t\tif (split_dur>=dur)\n\t\t\t\t\t\t\tsplit_dur=0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//mux rep, wait for a CTS more than our base if base not yet over\n\t\t\tif ((base_ds != ds) && !base_ds->seg_done && gf_timestamp_greater(cts, ds->timescale, base_ds->last_cts, base_ds->timescale) )\n\t\t\t\tbreak;\n\n\t\t\tif (ds->seek_to_pck) {\n\t\t\t\tds->seek_to_pck = 0;\n\t\t\t}\n\t\t\t//base rep has been forced to another period, we switch asap\n\t\t\telse if (base_ds->forced_period_switch) {\n\t\t\t\tds->seg_done = GF_TRUE;\n\t\t\t\tdasher_inject_eods(ctx, ds, GF_FALSE);\n\t\t\t\tseg_done = GF_TRUE;\n\t\t\t\tdasher_stream_period_changed(filter, ctx, ds, GF_FALSE);\n\t\t\t\ti--;\n\t\t\t\tcount--;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t//force flush mode, segment is done upon eos\n\t\t\telse if (ctx->force_flush) {\n\t\t\t}\n\t\t\t//source-driven fragmentation check for segment start\n\t\t\telse if (ctx->sigfrag) {\n\t\t\t\tconst GF_PropertyValue *p = gf_filter_pck_get_property(pck, GF_PROP_PCK_FRAG_START);\n\t\t\t\tif (p && (p->value.uint>=1) && base_ds->segment_started) {\n\t\t\t\t\tseg_over = GF_TRUE;\n\t\t\t\t\tif (ds == base_ds) {\n\t\t\t\t\t\tbase_ds->adjusted_next_seg_start = cts;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t//inband-cue based segmentation\n\t\t\telse if (ds->inband_cues) {\n\t\t\t\tconst GF_PropertyValue *p = gf_filter_pck_get_property(pck, GF_PROP_PCK_CUE_START);\n\t\t\t\tif (p && p->value.boolean) {\n\t\t\t\t\tu32 size;\n\t\t\t\t\tgf_filter_pck_get_data(pck, &size);\n\t\t\t\t\tif (base_ds->segment_started) {\n\t\t\t\t\t\tseg_over = GF_TRUE;\n\t\t\t\t\t\tif (ds == base_ds) {\n\t\t\t\t\t\t\tbase_ds->adjusted_next_seg_start = cts;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t//packet with no size, used by GHI demuxer:\n\t\t\t\t\t//- if seek flag is set, this is a dummy packet sent to generate segment timeline / child HLS\n\t\t\t\t\t//- if seek flag is not set, this is an empty segment for sparse streams\n\t\t\t\t\telse if (!size) {\n\t\t\t\t\t\tif (!gf_filter_pck_get_seek_flag(pck) ) {\n\t\t\t\t\t\t\tds->first_cts_in_seg = gf_filter_pck_get_cts(pck);\n\t\t\t\t\t\t\tdasher_send_empty_segment(ctx, ds);\n\t\t\t\t\t\t\tdasher_drop_input(ctx, ds, GF_TRUE);\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tp = gf_filter_pck_get_property(pck, GF_PROP_PCK_SPLIT_START);\n\t\t\t\t\tif (p) {\n\t\t\t\t\t\tcts += p->value.uint;\n\t\t\t\t\t\tassert(dur > p->value.uint);\n\t\t\t\t\t\tdur -= p->value.uint;\n\t\t\t\t\t\tsplit_dur_next = p->value.uint;\n\t\t\t\t\t\tds->split_dur_next = 0;\n\t\t\t\t\t\tis_packet_split = GF_TRUE;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tp = gf_filter_pck_get_property(pck, GF_PROP_PCK_SPLIT_END);\n\t\t\t\tif (p) {\n\t\t\t\t\tassert(dur > p->value.uint);\n\t\t\t\t\tdur -= p->value.uint;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//cue-list based segmentation\n\t\t\telse if (ds->cues) {\n\t\t\t\tu32 cidx;\n\t\t\t\tGF_DASHCueInfo *cue=NULL;\n\t\t\t\tBool is_cue_split = GF_FALSE;\n\t\t\t\ts32 has_mismatch = -1;\n\n\t\t\t\tfor (cidx=0;cidx<ds->nb_cues; cidx++) {\n\t\t\t\t\tcue = &ds->cues[cidx];\n\t\t\t\t\tif (cue->sample_num) {\n\t\t\t\t\t\tif (cue->sample_num == ds->nb_pck + 1) {\n\t\t\t\t\t\t\tis_cue_split = GF_TRUE;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t} else if (cue->sample_num < ds->nb_pck) {\n\t\t\t\t\t\t\thas_mismatch = cidx;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if (cue->dts) {\n\t\t\t\t\t\tu64 ts = (cue->dts - ds->cues_ts_offset) * ds->timescale;\n\t\t\t\t\t\tu64 ts2 = dts * ds->cues_timescale;\n\t\t\t\t\t\tif (ts == ts2) {\n\t\t\t\t\t\t\tis_cue_split = GF_TRUE;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t} else if (ts < ts2) {\n\t\t\t\t\t\t\thas_mismatch = cidx;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if (cue->cts) {\n\t\t\t\t\t\ts64 ts = (cue->cts - ds->cues_ts_offset) * ds->timescale;\n\t\t\t\t\t\ts64 ts2 = (cts + ds->first_cts) * ds->cues_timescale;\n\n\t\t\t\t\t\t//cues are given in track timeline (presentation time), subtract the media time to pres time offset\n\t\t\t\t\t\tif (ds->cues_use_edits) {\n\t\t\t\t\t\t\tts2 += (s64) (ds->pts_minus_cts) * ds->cues_timescale;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (ts == ts2) {\n\t\t\t\t\t\t\tis_cue_split = GF_TRUE;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t} else if (ts < ts2) {\n\t\t\t\t\t\t\thas_mismatch = cidx;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//start of first segment\n\t\t\t\tif (is_cue_split && !ds->segment_started) {\n\t\t\t\t\tmemmove(ds->cues, &ds->cues[cidx+1], (ds->nb_cues-cidx-1) * sizeof(GF_DASHCueInfo));\n\t\t\t\t\tds->nb_cues -= cidx+1;\n\t\t\t\t\tis_cue_split = 0;\n\t\t\t\t}\n\n\t\t\t\tif (is_cue_split) {\n\t\t\t\t\tif (!sap_type) {\n\t\t\t\t\t\tGF_LOG(ctx->strict_cues ?  GF_LOG_ERROR : GF_LOG_WARNING, GF_LOG_DASH, (\"[DASH] cue found (sn %d - dts \"LLD\" - cts \"LLD\") for PID %s but packet %d is not RAP !\\n\", cue->sample_num, cue->dts, cue->cts, gf_filter_pid_get_name(ds->ipid), ds->nb_pck));\n\t\t\t\t\t\tif (ctx->strict_cues) {\n\t\t\t\t\t\t\tgf_filter_pid_drop_packet(ds->ipid);\n\t\t\t\t\t\t\tgf_filter_pid_set_discard(ds->ipid, GF_TRUE);\n\t\t\t\t\t\t\treturn GF_BAD_PARAM;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tmemmove(ds->cues, &ds->cues[cidx+1], (ds->nb_cues-cidx-1) * sizeof(GF_DASHCueInfo));\n\t\t\t\t\tds->nb_cues -= cidx+1;\n\n\t\t\t\t\tif (sap_type==3)\n\t\t\t\t\t\tds->nb_sap_3 ++;\n\t\t\t\t\telse if (sap_type>3)\n\t\t\t\t\t\tds->nb_sap_4 ++;\n\n\t\t\t\t\t/*check requested profiles can be generated, or adjust them*/\n\t\t\t\t\tif (\n\t\t\t\t\t\t(ds->nb_sap_4 || (ds->nb_sap_3 > 1))\n\t\t\t\t\t\t&& (ctx->profile != GF_DASH_PROFILE_FULL)\n\t\t\t\t\t\t/*TODO: store at DS level whether the usage of sap4 is ok or not (eg roll info for AAC is OK, not for xHEAAC-v2)\n\t\t\t\t\t\tfor now we only complain for video*/\n\t\t\t\t\t\t&& ((ds->stream_type==GF_STREAM_VISUAL) || (ctx->strict_sap==DASHER_SAP_ON) )\n\t\t\t\t\t) {\n\t\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_DASH, (\"[Dasher] WARNING! Max SAP type %d detected - switching to FULL profile\\n\", ds->nb_sap_4 ? 4 : 3));\n\t\t\t\t\t\tctx->profile = GF_DASH_PROFILE_FULL;\n\t\t\t\t\t\tif (ctx->sseg)\n\t\t\t\t\t\t\tds->set->subsegment_starts_with_sap = sap_type;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tds->set->starts_with_sap = sap_type;\n\t\t\t\t\t}\n\n\n\t\t\t\t\tseg_over = GF_TRUE;\n\t\t\t\t\tif (ds == base_ds) {\n\t\t\t\t\t\tbase_ds->adjusted_next_seg_start = cts;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (has_mismatch>=0) {\n\t\t\t\t\tcue = &ds->cues[has_mismatch];\n\t\t\t\t\tGF_LOG(ctx->strict_cues ?  GF_LOG_ERROR : GF_LOG_WARNING, GF_LOG_DASH, (\"[DASH] found cue (sn %d - dts \"LLD\" - cts \"LLD\") in stream %s before current packet (sn %d - dts \"LLD\" - cts \"LLD\") , buggy source cues ?\\n\", cue->sample_num, cue->dts, cue->cts, gf_filter_pid_get_name(ds->ipid), ds->nb_pck+1, dts + ds->first_cts, cts + ds->first_cts));\n\t\t\t\t\tif (ctx->strict_cues) {\n\t\t\t\t\t\tgf_filter_pid_drop_packet(ds->ipid);\n\t\t\t\t\t\tgf_filter_pid_set_discard(ds->ipid, GF_TRUE);\n\t\t\t\t\t\treturn GF_BAD_PARAM;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t//forcing max time\n\t\t\telse if (\n\t\t\t\t(base_ds->force_rep_end && gf_timestamp_greater_or_equal(cts, ds->timescale, base_ds->force_rep_end, base_ds->timescale) )\n\t\t\t\t|| (base_ds->clamped_dur.num && (cts + o_dur > ds->ts_offset + base_ds->clamped_dur.num * ds->timescale / base_ds->clamped_dur.den))\n\t\t\t) {\n\t\t\t\tif (!base_ds->period->period->duration && base_ds->force_rep_end) {\n\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_DASH, (\"[Dasher] Inputs duration do not match, %s truncated to %g duration\\n\", ds->src_url, ((Double)base_ds->force_rep_end)/base_ds->timescale ));\n\t\t\t\t}\n\t\t\t\tdasher_drop_input(ctx, ds, GF_TRUE);\n\t\t\t\tds->clamp_done = GF_TRUE;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t//we have a SAP and we work in closest mode: check the next SAP in the queue, and decide if we\n\t\t\t//split the segment at this SAP or wait for the next one\n\t\t\telse if (ds->segment_started && ds->sbound && sap_type) {\n\t\t\t\tu32 idx, nb_queued, nb_pck = gf_list_count(ds->packet_queue);\n\t\t\t\tnb_queued = nb_pck;\n\t\t\t\tif (is_queue_flush) nb_queued += 1;\n\t\t\t\t\n\t\t\t\tfor (idx=1; idx<nb_queued; idx++) {\n\t\t\t\t\tGF_FilterPacket *next;\n\t\t\t\t\tif (idx==nb_pck) {\n\t\t\t\t\t\tnext = gf_list_last(ds->packet_queue);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnext = gf_list_get(ds->packet_queue, idx);\n\t\t\t\t\t\tu32 sap_next = gf_filter_pck_get_sap(next);\n\t\t\t\t\t\tif (!sap_next) continue;\n\t\t\t\t\t}\n\t\t\t\t\tu32 next_dur = gf_filter_pck_get_duration(next);\n\t\t\t\t\t//compute cts next\n\t\t\t\t\tu64 cts_next = gf_filter_pck_get_cts(next);\n\t\t\t\t\tif (ds->ts_offset) {\n\t\t\t\t\t\tcts_next += ds->ts_offset;\n\t\t\t\t\t}\n\t\t\t\t\tcts_next = dasher_translate_cts(ds, cts_next);\n\n\t\t\t\t\tif ((idx==nb_pck) && ctx->last_seg_merge) {\n\t\t\t\t\t\tu64 next_seg_dur = (cts_next + next_dur - cts);\n\t\t\t\t\t\tif (next_seg_dur * ds->dash_dur.den < (u64) ds->dash_dur.num * ds->timescale / 2)\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\t//same rule as above\n\t\t\t\t\tif (gf_timestamp_greater_or_equal(cts_next + next_dur, ds->timescale, base_ds->adjusted_next_seg_start, base_ds->timescale)) {\n\t\t\t\t\t\tBool force_seg_flush = GF_FALSE;\n\t\t\t\t\t\ts64 diff_next = gf_timestamp_rescale(cts_next, ds->timescale, base_ds->timescale);\n\t\t\t\t\t\tdiff_next -= base_ds->adjusted_next_seg_start;\n\t\t\t\t\t\t//bounds at closest: if this SAP is closer to the target next segment start than the next SAP, split at this packet\n\t\t\t\t\t\tif (ds->sbound==DASHER_BOUNDS_CLOSEST) {\n\t\t\t\t\t\t\ts64 diff = gf_timestamp_rescale(cts, ds->timescale, base_ds->timescale);\n\t\t\t\t\t\t\tdiff -= base_ds->adjusted_next_seg_start;\n\t\t\t\t\t\t\t//this one may be negative, but we always want diff_next positive (next SAP in next segment)\n\t\t\t\t\t\t\tif (diff<0)\n\t\t\t\t\t\t\t\tdiff = -diff;\n\t\t\t\t\t\t\t//old arch was only using closest for tracks with sync points\n\t\t\t\t\t\t\tif (gf_sys_old_arch_compat() && (base_ds->sync_points_type==DASHER_SYNC_NONE) ) {\n\t\t\t\t\t\t\t\tif (diff_next > 0) {\n\t\t\t\t\t\t\t\t\tforce_seg_flush = GF_TRUE;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (diff<diff_next) {\n\t\t\t\t\t\t\t\tforce_seg_flush = GF_TRUE;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//bounds always in: if the next SAP is strictly greater than the target next segment start, split at this packet\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tif (diff_next > 0) {\n\t\t\t\t\t\t\t\tforce_seg_flush = GF_TRUE;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (force_seg_flush) {\n\t\t\t\t\t\t\tseg_over = GF_TRUE;\n\t\t\t\t\t\t\tif (ds == base_ds) {\n\t\t\t\t\t\t\t\tbase_ds->adjusted_next_seg_start = cts;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t//we exceed segment duration - if segment was started, check if we need to stop segment\n\t\t\t//if segment was not started we insert the packet anyway\n\t\t\telse if (!ds->sbound && ds->segment_started && gf_timestamp_greater_or_equal(cts + check_dur, ds->timescale, base_ds->adjusted_next_seg_start, base_ds->timescale) ) {\n\n\n\t\t\t\t//we have a base (muxed rep) and it is not yet done, and we exceed estimated next seg start on base\n\t\t\t\t//wait for the base to be done as the next seg estimate may change if next segment duration is quite\n\t\t\t\t//different from requested duration - cf #2488\n\t\t\t\tif ((ds != base_ds) && !base_ds->seg_done) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t//no sap, segment is over\n\t\t\t\tif (! ctx->sap) {\n\t\t\t\t\tseg_over = GF_TRUE;\n\t\t\t\t}\n\t\t\t\telse if ((ds->stream_type==GF_STREAM_AUDIO)\n\t\t\t\t\t&& gf_timestamp_equal(cts + check_dur, ds->timescale, base_ds->adjusted_next_seg_start, base_ds->timescale)\n\t\t\t\t) {\n\n\t\t\t\t}\n\t\t\t\t// sap, segment is over\n\t\t\t\telse if (sap_type) {\n\n\t\t\t\t\tif (sap_type==3)\n\t\t\t\t\t\tds->nb_sap_3 ++;\n\t\t\t\t\telse if (sap_type>3)\n\t\t\t\t\t\tds->nb_sap_4 ++;\n\n\t\t\t\t\t/*check requested profiles can be generated, or adjust them*/\n\t\t\t\t\tif ((ctx->profile != GF_DASH_PROFILE_FULL)\n\t\t\t\t\t\t&& (ds->nb_sap_4 || (ds->nb_sap_3 > 1))\n\t\t\t\t\t\t/*TODO: store at DS level whether the usage of sap4 is ok or not (eg roll info for AAC is OK, not for xHEAAC-v2)\n\t\t\t\t\t\tfor now we only complain for video*/\n\t\t\t\t\t\t&& ((ds->stream_type==GF_STREAM_VISUAL) || (ctx->strict_sap==DASHER_SAP_ON) )\n\t\t\t\t\t) {\n\t\t\t\t\t\tif ((sap_type == GF_FILTER_SAP_3)\n\t\t\t\t\t\t\t&& (ds->codec_id==GF_CODECID_VVC)\n\t\t\t\t\t\t\t&& (ds->inband_params==2)\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tif (ds->set->starts_with_sap<3) {\n\t\t\t\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_DASH, (\"[Dasher] Using VVC with SAP type 3 and inband PPS, profile not yet defined\\n\", ds->nb_sap_4 ? 4 : 3));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_DASH, (\"[Dasher] WARNING! Max SAP type %d detected - switching to FULL profile\\n\", ds->nb_sap_4 ? 4 : 3));\n\t\t\t\t\t\t\tctx->profile = GF_DASH_PROFILE_FULL;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (ctx->sseg)\n\t\t\t\t\t\t\tds->set->subsegment_starts_with_sap = sap_type;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tds->set->starts_with_sap = sap_type;\n\t\t\t\t\t}\n\n\t\t\t\t\t//if sap2, silently move startWithSAP to 2 if previsouly 0,1 or 2\n\t\t\t\t\tif (sap_type == GF_FILTER_SAP_2) {\n\t\t\t\t\t\tif (ctx->sseg)\n\t\t\t\t\t\t\tds->set->subsegment_starts_with_sap = MAX(ds->set->subsegment_starts_with_sap, sap_type);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tds->set->starts_with_sap = MAX(ds->set->starts_with_sap, sap_type);\n\t\t\t\t\t}\n\n\t\t\t\t\tseg_over = GF_TRUE;\n\t\t\t\t\tif (ds == base_ds) {\n\t\t\t\t\t\tbase_ds->adjusted_next_seg_start = cts;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t\tif (ds->muxed_base && ds->muxed_base->done) {\n\t\t\t\tseg_over = GF_FALSE;\n\t\t\t}\n\t\t\t//if flushing now will result in a one sample fragment afterwards\n\t\t\t//because this is the before-last sample, don't flush unless:\n\t\t\t//- we have an asto set (low latency)\n\t\t\t//- this is not an audio stream or all samples are SAPs\n\t\t\t//- we use cues\n\t\t\t//- we use strict_sap=intra mode\n\t\t\telse if (seg_over && ds->nb_samples_in_source && !ctx->loop\n\t\t\t\t&& (ds->nb_pck+1 == ds->nb_samples_in_source)\n\t\t\t\t&& !ds->inband_cues && !ds->cues\n\t\t\t\t&& !ctx->asto\n\t\t\t\t&& ! ((ds->sync_points_type==DASHER_SYNC_NONE) && (ds->stream_type!=GF_STREAM_AUDIO))\n\t\t\t\t&& (ctx->strict_sap!=DASHER_SAP_INTRA_ONLY)\n\t\t\t) {\n\t\t\t\tseg_over = GF_FALSE;\n\t\t\t}\n\t\t\t//if dur=0 (some text streams), don't flush segment\n\t\t\tif (seg_over && dur) {\n\t\t\t\tassert(!ds->seg_done);\n\n\t\t\t\tif (ds->request_period_switch && !gf_list_count(ds->packet_queue)) {\n\t\t\t\t\te = dasher_stream_period_changed(filter, ctx, ds, (ds->request_period_switch==2) ? GF_TRUE : GF_FALSE);\n\t\t\t\t\tif (e < 0) {\n\t\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_DASH, (\"[Dasher] Period switch request failed.\\n\"));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tassert(gf_list_find(ctx->current_period->streams, ds)<0);\n\t\t\t\t\tcount = gf_list_count(ctx->current_period->streams);\n\t\t\t\t\ti--;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tds->seg_done = GF_TRUE;\n\t\t\t\tif (split_dur_next && ctx->do_index) {\n\t\t\t\t\tGF_MPD_SegmentURL *s = gf_list_last(ds->rep->segment_list->segment_URLs);\n\t\t\t\t\ts->split_last_dur = dur;\n\t\t\t\t\tassert(gf_filter_pck_get_duration(pck) > dur);\n\t\t\t\t\tds->rep->segment_list->use_split_dur = GF_TRUE;\n\t\t\t\t}\n\n\t\t\t\tdasher_inject_eods(ctx, ds, GF_FALSE);\n\n\t\t\t\tds->first_cts_in_next_seg = cts;\n\t\t\t\tassert(base_ds->nb_comp_done < base_ds->nb_comp);\n\t\t\t\tbase_ds->nb_comp_done ++;\n\n\t\t\t\tif (split_dur_next)\n\t\t\t\t\tds->split_dur_next = (u32) split_dur_next;\n\n\t\t\t\tif (base_ds->nb_comp_done == base_ds->nb_comp) {\n\t\t\t\t\tdasher_flush_segment(ctx, base_ds, GF_FALSE);\n\t\t\t\t\tseg_done = GF_TRUE;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (cts==GF_FILTER_NO_TS) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_DASH, (\"[Dasher] WARNING! Source packet has no timestamp !\\n\"));\n\n\t\t\t\tcts = ds->last_cts;\n\t\t\t\tdts = ds->last_dts;\n\t\t\t} else {\n\t\t\t\tu64 ncts = cts + (split_dur ? split_dur : dur);\n\t\t\t\tif (ncts>ds->est_first_cts_in_next_seg)\n\t\t\t\t\tds->est_first_cts_in_next_seg = ncts;\n\n\t\t\t\tncts = gf_timestamp_rescale(ncts, ds->timescale, 1000);\n\t\t\t\tif (ncts>base_ds->max_period_dur)\n\t\t\t\t\tbase_ds->max_period_dur = ncts;\n\n\t\t\t\tds->last_cts = cts + (split_dur ? split_dur : dur);\n\t\t\t\tds->last_dts = dts;\n\t\t\t\tds->est_next_dts = dts + o_dur;\n\t\t\t}\n\n\t\t\tif (!is_packet_split)\n\t\t\t\tds->nb_pck ++;\n\n\t\t\tif (!ds->min_cts_in_seg_plus_one)\n\t\t\t\tds->min_cts_in_seg_plus_one = cts+1;\n\t\t\telse if (ds->min_cts_in_seg_plus_one - 1 > cts)\n\t\t\t\tds->min_cts_in_seg_plus_one = cts+1;\n\n\n\t\t\tif (ctx->sigfrag) {\n\t\t\t\tif (!ds->segment_started) {\n\t\t\t\t\tds->first_cts_in_seg = cts;\n\t\t\t\t\tdasher_mark_segment_start(ctx, ds, NULL, pck);\n\t\t\t\t\tds->segment_started = GF_TRUE;\n\t\t\t\t}\n\n\t\t\t\tds->cumulated_dur += dur;\n\n\t\t\t\t//drop packet if not splitting\n\t\t\t\tif (!ds->split_dur_next)\n\t\t\t\t\tgf_filter_pid_drop_packet(ds->ipid);\n\n\t\t\t\tif (ctx->in_error) {\n\t\t\t\t\tgf_filter_pid_set_discard(ds->ipid, GF_TRUE);\n\t\t\t\t\tgf_filter_pid_set_eos(ctx->opid);\n\t\t\t\t\treturn GF_BAD_PARAM;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (ctx->do_index) {\n\t\t\t\t//frag range may be set for TS and other sources\n\t\t\t\tconst GF_PropertyValue *p = gf_filter_pck_get_property(pck, GF_PROP_PCK_FRAG_RANGE);\n\t\t\t\tif (p) {\n\t\t\t\t\tds->frag_start_offset = p->value.lfrac.num;\n\t\t\t\t\t//frag start only for fmp4\n\t\t\t\t\tp = gf_filter_pck_get_property(pck, GF_PROP_PCK_FRAG_START);\n\t\t\t\t\tif (p && p->value.boolean) {\n\t\t\t\t\t\tp = gf_filter_pck_get_property(pck, GF_PROP_PCK_FRAG_TFDT);\n\t\t\t\t\t\tif (p)\n\t\t\t\t\t\t\tds->frag_first_ftdt = p->value.longuint;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t//create new ref to input\n\t\t\tdst = NULL;\n\t\t\tif (!ctx->do_index && !ctx->index_media_duration) {\n\t\t\t\tdst = gf_filter_pck_new_ref(ds->opid, 0, 0, pck);\n\t\t\t\tif (!dst) return GF_OUT_OF_MEM;\n\n\t\t\t\t//merge all props\n\t\t\t\tgf_filter_pck_merge_properties(pck, dst);\n\t\t\t\t//we have ts offset, use computed cts and dts\n\t\t\t\tif (ds->ts_offset) {\n\t\t\t\t\tgf_filter_pck_set_cts(dst, gf_filter_pck_get_cts(pck) + ds->ts_offset);\n\t\t\t\t\tgf_filter_pck_set_dts(dst, gf_filter_pck_get_dts(pck) + ds->ts_offset);\n\t\t\t\t}\n\n\t\t\t\tif (gf_sys_old_arch_compat() && ds->clamped_dur.num && ctx->loop\n\t\t\t\t\t&& (cts + 2*o_dur >= ds->ts_offset + base_ds->clamped_dur.num * ds->timescale / base_ds->clamped_dur.den)\n\t\t\t\t) {\n\t\t\t\t\tu32 _dur = dur;\n\t\t\t\t\t/* simple round with (int)+.5 to avoid trucating .99999 to 0 */\n\t\t\t\t\tdur = (u32) (ds->clamped_dur.num * ds->timescale / ds->clamped_dur.den - (dts - ds->ts_offset) + 0.5);\n\t\t\t\t\t//it may happen that the sample duration is 0 if the clamp duration is right after the sample DTS and timescale is not big enough to express it - force to 1\n\t\t\t\t\tif (dur==0)\n\t\t\t\t\t\tdur=1;\n\n\t\t\t\t\tgf_filter_pck_set_duration(dst, dur);\n\t\t\t\t\tds->est_next_dts += (s32) dur - (s32) _dur;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!ds->segment_started) {\n\t\t\t\tds->first_cts_in_seg = cts;\n\t\t\t\tif (split_dur_next && (ctx->from_index==IDXMODE_SEG)) {\n\t\t\t\t\tds->first_cts_in_seg -= split_dur_next;\n\t\t\t\t}\n\t\t\t\tdasher_mark_segment_start(ctx, ds, dst, pck);\n\t\t\t\tds->segment_started = GF_TRUE;\n\t\t\t\tif (split_dur_next && ctx->do_index) {\n\t\t\t\t\tGF_MPD_SegmentURL *s = gf_list_last(ds->rep->segment_list->segment_URLs);\n\t\t\t\t\ts->split_first_dur = (u32) split_dur_next;\n\t\t\t\t\tassert(gf_filter_pck_get_duration(pck) > split_dur_next);\n\t\t\t\t\tds->rep->segment_list->use_split_dur = GF_TRUE;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//prev packet was split\n\t\t\tif (is_packet_split) {\n\t\t\t\tu64 diff=0;\n\t\t\t\tu8 dep_flags = gf_filter_pck_get_dependency_flags(pck);\n\t\t\t\tu64 ts = gf_filter_pck_get_cts(pck);\n\t\t\t\tif (ts != GF_FILTER_NO_TS) {\n\t\t\t\t\tcts += ds->first_cts;\n\t\t\t\t\tassert(cts >= ts);\n\t\t\t\t\tdiff = cts - ts;\n\t\t\t\t} else {\n\t\t\t\t\tcts = ds->last_cts;\n\t\t\t\t}\n\t\t\t\tif (dst) {\n\t\t\t\t\tgf_filter_pck_set_cts(dst, cts + ds->ts_offset);\n\n\t\t\t\t\tts = gf_filter_pck_get_dts(pck);\n\t\t\t\t\tif (ts != GF_FILTER_NO_TS)\n\t\t\t\t\t\tgf_filter_pck_set_dts(dst, ts + diff + ds->ts_offset);\n\n\t\t\t\t\t//add sample is redundant flag\n\t\t\t\t\tdep_flags |= 0x1;\n\t\t\t\t\tgf_filter_pck_set_dependency_flags(dst, dep_flags);\n\t\t\t\t\t//this one might be incorrect of this split packet is also split, but we update the duration right below\n\t\t\t\t\tgf_filter_pck_set_duration(dst, dur);\n\t\t\t\t}\n\n\t\t\t\t//undo cts shift, we use it just below to compute cumulated dur using orig_cts (stored before shift)\n\t\t\t\tif (diff)\n\t\t\t\t\tcts -= ds->first_cts;\n\t\t\t}\n\n\t\t\t//if split, adjust duration - this may happen on a split packet, if it covered 3 or more segments\n\t\t\tif (split_dur) {\n\t\t\t\tu32 cumulated_split_dur = split_dur;\n\t\t\t\tif (dst)\n\t\t\t\t\tgf_filter_pck_set_duration(dst, split_dur);\n\t\t\t\t//adjust dur\n\t\t\t\tcumulated_split_dur += (u32) (cts - orig_cts);\n\t\t\t\tassert( dur > split_dur);\n\t\t\t\tassert( cumulated_split_dur <= gf_filter_pck_get_duration(pck) );\n\t\t\t\tds->split_dur_next = cumulated_split_dur;\n\t\t\t\tdur = split_dur;\n\t\t\t}\n\n\t\t\t//remove NTP\n\t\t\tif (dst && (ctx->ntp != DASHER_NTP_KEEP))\n\t\t\t\tgf_filter_pck_set_property(dst, GF_PROP_PCK_SENDER_NTP, NULL);\n\n\t\t\t//change packet times\n\t\t\tif (ds->force_timescale && dst) {\n\t\t\t\tu64 ats;\n\t\t\t\tats = gf_filter_pck_get_dts(dst);\n\t\t\t\tif (ats!=GF_FILTER_NO_TS) {\n\t\t\t\t\tats = gf_timestamp_rescale(ats, ds->timescale, ds->force_timescale);\n\t\t\t\t\tgf_filter_pck_set_dts(dst, ats);\n\t\t\t\t}\n\t\t\t\tats = gf_filter_pck_get_cts(dst);\n\t\t\t\tif (ats!=GF_FILTER_NO_TS) {\n\t\t\t\t\tats = gf_timestamp_rescale(ats, ds->timescale, ds->force_timescale);\n\t\t\t\t\tgf_filter_pck_set_cts(dst, ats);\n\t\t\t\t}\n\t\t\t\tats = (u64) gf_filter_pck_get_duration(dst);\n\t\t\t\tif (ats) {\n\t\t\t\t\tats = gf_timestamp_rescale(ats, ds->timescale, ds->force_timescale);\n\t\t\t\t\tgf_filter_pck_set_duration(dst, (u32) ats);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tds->cumulated_dur += dur;\n\n\t\t\tif (ds->current_seg_state && gf_filter_pck_get_crypt_flags(pck))\n\t\t\t\tds->current_seg_state->encrypted = GF_TRUE;\n\t\t\t//TODO check drift between MPD start time and min CTS in segment (not just first CTS in segment)\n\n\t\t\tif (ctx->gxns && dst && !ds->rep->first_tfdt_plus_one && !ds->muxed_base) {\n\t\t\t\tds->rep->first_tfdt_plus_one = 1 + gf_filter_pck_get_dts(dst);\n\t\t\t\tds->rep->first_tfdt_timescale = ds->timescale;\n\t\t\t}\n\t\t\t//send packet\n\t\t\tif (dst)\n\t\t\t\tgf_filter_pck_send(dst);\n\n\t\t\tif (ctx->update_report>=0)\n\t\t\t\tctx->update_report++;\n\n\t\t\tif (ds->dyn_bitrate) {\n\t\t\t\tu32 dsize;\n\t\t\t\tu64 rdts = gf_filter_pck_get_dts(pck);\n\t\t\t\tgf_filter_pck_get_data(pck, &dsize);\n\t\t\t\tif (!ds->rate_first_dts_plus_one)\n\t\t\t\t\tds->rate_first_dts_plus_one = 1 + rdts;\n\t\t\t\tds->rate_last_dts = rdts;\n\t\t\t\tds->rate_media_size += dsize;\n\t\t\t}\n\n\t\t\t//drop packet if not splitting\n\t\t\tif (!ds->split_dur_next)\n\t\t\t\tdasher_drop_input(ctx, ds, GF_FALSE);\n\n\t\t}\n\t}\n\n\tif (nb_seg_waiting && !nb_seg_active) {\n\t\tctx->last_min_segment_start_time = ctx->min_segment_start_time;\n\t\tctx->min_segment_start_time = 0;\n\t\treturn GF_OK;\n\t}\n\n\tnb_init = 0;\n\tfor (i=0; i<count; i++) {\n\t\tGF_DashStream *ds = gf_list_get(ctx->current_period->streams, i);\n\t\t//if (ds->muxed_base) ds = ds->muxed_base;\n\t\tif (ds->done || ds->subdur_done) nb_init++;\n\t\telse if (ds->seg_done && ctx->force_period_switch) nb_init++;\n\t\telse if (ds->seg_done && ds->muxed_base && ds->muxed_base->done) {\n\t\t\tnb_init++;\n\t\t\tif (!ds->done && ds->opid) gf_filter_pid_set_eos(ds->opid);\n\t\t\tds->done = 1;\n\t\t}\n\t}\n\n\tif (nb_reg_done && (nb_reg_done == count)) {\n\t\tctx->mpd->gpac_mpd_time = 0;\n\t}\n\n\tdasher_format_report(filter, ctx);\n\n\tif (seg_done) {\n\t\tBool update_period = GF_FALSE;\n\t\tBool update_manifest = GF_FALSE;\n\t\tif (ctx->purge_segments) update_period = GF_TRUE;\n\t\tif (ctx->mpd) {\n\t\t\t//segment timeline used, always update manifest\n\t\t\tif (ctx->stl)\n\t\t\t\tupdate_manifest = GF_TRUE;\n\t\t\telse if (ctx->dmode==GF_DASH_DYNAMIC) {\n\t\t\t\t//publish time not set, we never send the manifest, do it\n\t\t\t\tif (!ctx->mpd->publishTime) {\n\t\t\t\t\tupdate_manifest = GF_TRUE;\n\t\t\t\t}\n\t\t\t\t//whenever we have a new seg in HLS, push new manifest\n\t\t\t\telse if (ctx->do_m3u8) {\n\t\t\t\t\tupdate_manifest = GF_TRUE;\n\t\t\t\t}\n\t\t\t\t//we have a minimum ipdate period\n\t\t\t\telse if (ctx->mpd->minimum_update_period) {\n\t\t\t\t\tu64 diff = dasher_get_utc(ctx) - ctx->mpd->publishTime;\n\t\t\t\t\tif (diff >= ctx->mpd->minimum_update_period)\n\t\t\t\t\t\tupdate_manifest = GF_TRUE;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (update_period)\n\t\t\t\tdasher_update_period_duration(ctx, GF_FALSE);\n\n\t\t\tif (update_manifest)\n\t\t\t\tdasher_send_manifest(filter, ctx, GF_FALSE);\n\t\t}\n\t} else if (ctx->force_hls_ll_manifest) {\n\t\tctx->force_hls_ll_manifest = GF_FALSE;\n\t\tdasher_send_manifest(filter, ctx, GF_FALSE);\n\t}\n\n\t//still some running streams in period - do not ask for reschedule, wait for input packets to be available\n\tif (count && (nb_init<count)) {\n\t\treturn GF_OK;\n\t}\n\n\t//in subdur mode once we are done, flush output pids and discard all input packets\n\t//this is done at the end to be able to resume dashing when loop is requested\n\tif (ctx->subdur) {\n\t\tfor (i=0; i<count; i++) {\n\t\t\tGF_FilterPacket *eods_pck;\n\t\t\tGF_DashStream *ds = gf_list_get(ctx->current_period->streams, i);\n\t\t\tif (ds->done) continue;\n\t\t\teods_pck = gf_filter_pck_new_alloc(ds->opid, 0, NULL);\n\t\t\tif (!eods_pck) return GF_OUT_OF_MEM;\n\t\t\tds->done = 2;\n\t\t\tds->subdur_done = GF_TRUE;\n\t\t\tgf_filter_pck_set_property(eods_pck, GF_PROP_PCK_EODS, &PROP_BOOL(GF_TRUE) );\n\t\t\tgf_filter_pck_send(eods_pck);\n\n\t\t\tdasher_drop_input(ctx, ds, GF_TRUE);\n\t\t}\n\t}\n\n\t//we need to wait for full flush of packets before switching periods in order to get the\n\t//proper segment size for segment_list+byte_range mode\n\tif (ctx->nb_seg_url_pending) {\n\t\tu64 diff;\n\t\tif (!ctx->last_evt_check_time) {\n\t\t\tctx->last_evt_check_time = gf_sys_clock_high_res();\n\t\t\tgf_filter_prevent_blocking(filter, GF_TRUE);\n\t\t}\n\n\t\tdiff = gf_sys_clock_high_res() - ctx->last_evt_check_time;\n\t\tif (diff < 10000000) {\n\t\t\tgf_filter_ask_rt_reschedule(filter, 1000);\n\t\t\treturn GF_OK;\n\t\t}\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_DASH, (\"[Dasher] timeout %d segment info still pending but no event from muxer after \"LLU\" us, aborting\\n\", ctx->nb_seg_url_pending, diff));\n\t\tctx->nb_seg_url_pending = 0;\n\t\treturn GF_SERVICE_ERROR;\n\t}\n\tif (ctx->sseg && !ctx->on_demand_done && !ctx->sigfrag && !ctx->do_index && !ctx->index_media_duration) {\n\t\treturn GF_OK;\n\t}\n\tgf_filter_prevent_blocking(filter, GF_FALSE);\n\tctx->force_period_switch = GF_FALSE;\n\t//done with this period, do period switch - this will update the MPD if needed\n\te = dasher_switch_period(filter, ctx);\n\t//no more periods\n\tif (e==GF_EOS) {\n\t\tif (!ctx->is_eos) {\n\t\t\tif (ctx->move_to_static) {\n\t\t\t\tctx->dmode = GF_MPD_TYPE_DYNAMIC_LAST;\n\t\t\t\tif (ctx->mpd) {\n\t\t\t\t\tctx->mpd->type = ctx->dmode;\n\t\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_DASH, (\"[Dasher] EOS, flushing manifest as static\\n\"));\n\t\t\t\t\tdasher_send_manifest(filter, ctx, GF_FALSE);\n\t\t\t\t}\n\t\t\t\tctx->move_to_static = GF_FALSE;\n\t\t\t}\n\t\t\tctx->is_eos = GF_TRUE;\n\t\t\tgf_filter_pid_set_eos(ctx->opid);\n\t\t}\n\t}\n\treturn e;\n}\n\n\n\nstatic void dasher_resume_subdur(GF_Filter *filter, GF_DasherCtx *ctx)\n{\n\tGF_FilterEvent evt;\n\tu32 i, count;\n\tBool is_last = (ctx->dmode == GF_MPD_TYPE_DYNAMIC_LAST) ? GF_TRUE : GF_FALSE;\n\tif (!ctx->state) return;\n\n\tcount = gf_list_count(ctx->pids);\n\tfor (i=0; i<count; i++) {\n\t\tGF_DashStream *ds = gf_list_get(ctx->pids, i);\n\t\tds->rep = NULL;\n\t\tif ((ds->done==1) && !ctx->subdur && ctx->loop) {}\n\t\telse if (ds->reschedule) {\n\t\t\t//we possibly dispatched end of stream on all outputs, we need to force unblockink to get called again\n\t\t\tgf_filter_pid_discard_block(ds->opid);\n\t\t\tcontinue;\n\t\t}\n\t\telse if (ds->done != 2) continue;\n\n\t\tif (is_last) continue;\n\n\t\tgf_filter_pid_set_discard(ds->ipid, GF_FALSE);\n\n\t\t//send stop and play\n\t\tGF_FEVT_INIT(evt, GF_FEVT_STOP, ds->ipid);\n\t\tgf_filter_pid_send_event(ds->ipid, &evt);\n\n\t\tdasher_send_encode_hints(ctx, ds);\n\t\tGF_FEVT_INIT(evt, GF_FEVT_PLAY, ds->ipid);\n\t\tevt.play.speed = 1.0;\n\t\tif (!ctx->subdur || !ctx->loop) {\n\t\t\tds->seek_to_pck = 0;\n\t\t} else {\n\t\t\t//request start after the last packet we processed\n\t\t\tevt.play.from_pck = (u32) ds->seek_to_pck+1;\n\t\t}\n\t\tgf_filter_pid_send_event(ds->ipid, &evt);\n\n\t\t//full stream looping\n\t\tif (ds->subdur_done && !ctx->subdur) {\n\t\t\tds->loop_state = 0;\n\t\t\t//mark as subdur done to force a context reload through period switch\n\t\t\tds->done = 2;\n\t\t\tds->seg_done = GF_FALSE;\n\t\t\tds->subdur_done = GF_FALSE;\n\t\t}\n\t}\n\n\tctx->subdur_done = GF_FALSE;\n\tctx->is_eos = GF_FALSE;\n\tif (!ctx->post_play_events && !is_last) {\n\t\tctx->current_period->period = NULL;\n\t\tctx->first_context_load = GF_TRUE;\n\t\tctx->post_play_events = GF_TRUE;\n\t}\n\tgf_filter_post_process_task(filter);\n}\n\nstatic void dasher_process_hls_ll(GF_DasherCtx *ctx, const GF_FilterEvent *evt)\n{\n\tu32 i, count = gf_list_count(ctx->pids);\n\tGF_DASH_SegmentContext *sctx;\n\tGF_DashStream *ds = NULL;\n\n\tif (ctx->forward_mode)\n\t\treturn;\n\n\tif (!ctx->store_seg_states) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_DASH, (\"[Dasher] Received fragment size info event but no associated segment state\\n\"));\n\t\treturn;\n\t}\n\tfor (i=0; i<count; i++) {\n\t\tds = gf_list_get(ctx->pids, i);\n\t\tif (ds->opid == evt->base.on_pid) break;\n\t\tds = NULL;\n\t}\n\tif (!ds) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_DASH, (\"[Dasher] Received fragment size info event but no associated pid\\n\"));\n\t\treturn;\n\t}\n\tif (ds->muxed_base)\n\t\tds = ds->muxed_base;\n\n\tsctx = gf_list_get(ds->pending_segment_states, 0);\n\tif (!sctx || !ctx->nb_seg_url_pending) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_DASH, (\"[Dasher] Received segment size info event but no pending segments\\n\"));\n\t\treturn;\n\t}\n\tsctx->frags = gf_realloc(sctx->frags, sizeof (GF_DASH_FragmentContext) * (sctx->nb_frags+1));\n\tif (!sctx->frags) {\n\t\tsctx->nb_frags = 0;\n\t\treturn;\n\t}\n\tsctx->frags[sctx->nb_frags].size = evt->frag_size.size;\n\tsctx->frags[sctx->nb_frags].offset = evt->frag_size.offset;\n\tif (evt->frag_size.duration.den) {\n\t\tsctx->frags[sctx->nb_frags].duration = (u32) ((u64) evt->frag_size.duration.num * ds->rep->timescale / evt->frag_size.duration.den);\n\t} else {\n\t\tsctx->frags[sctx->nb_frags].duration = 0;\n\t}\n\n\tsctx->frags[sctx->nb_frags].independent = evt->frag_size.independent;\n\tsctx->nb_frags++;\n\tif (evt->frag_size.is_last) {\n\t\tsctx->llhls_done = GF_TRUE;\n\t} else {\n\t\tctx->force_hls_ll_manifest = GF_TRUE;\n\t}\n}\n\nstatic Bool dasher_process_event(GF_Filter *filter, const GF_FilterEvent *evt)\n{\n\tu32 i, count;\n\tBool flush_mpd = GF_FALSE;\n\tGF_DasherCtx *ctx = gf_filter_get_udta(filter);\n\n\tctx->last_evt_check_time = 0;\n\n\tif (evt->base.type == GF_FEVT_RESUME) {\n\t\t//only process resume event when coming from main output PID, but always cancel it\n\t\t//this is needed in case the output filter where the resume event was initiated consumes both\n\t\t//manifest and segment PIDs, as is the case with httpout\n\t\tif (evt->base.on_pid == ctx->opid)\n\t\t\tdasher_resume_subdur(filter, ctx);\n\t\treturn GF_TRUE;\n\t}\n\tif (evt->base.type == GF_FEVT_CONNECT_FAIL) {\n\t\tctx->in_error = GF_TRUE;\n\t\tgf_filter_pid_set_eos(ctx->opid);\n\t\tif (ctx->opid_alt)\n\t\t\tgf_filter_pid_set_eos(ctx->opid_alt);\n\t\treturn GF_TRUE;\n\t}\n\n\tif (evt->base.type == GF_FEVT_PLAY) {\n\t\tctx->is_playing = GF_TRUE;\n\t\tif (!ctx->sfile && !ctx->stl && !ctx->use_cues) {\n\t\t\tGF_FilterEvent anevt;\n\t\t\tGF_FEVT_INIT(anevt, GF_FEVT_ENCODE_HINTS, NULL)\n\t\t\tcount = gf_list_count(ctx->pids);\n\t\t\tfor (i=0; i<count; i++) {\n\t\t\t\tGF_DashStream *ds = gf_list_get(ctx->pids, i);\n\t\t\t\tanevt.base.on_pid = ds->ipid;\n\t\t\t\tswitch (ctx->from_index) {\n\t\t\t\tcase IDXMODE_NONE:\n\t\t\t\t\tanevt.encode_hints.intra_period = ds->dash_dur;\n\t\t\t\t\tbreak;\n\t\t\t\tcase IDXMODE_SEG:\n\t\t\t\tcase IDXMODE_CHILD:\n\t\t\t\t\tbreak;\n\t\t\t\tcase IDXMODE_ALL:\n\t\t\t\tcase IDXMODE_INIT:\n\t\t\t\tcase IDXMODE_MANIFEST:\n\t\t\t\t\tanevt.encode_hints.gen_dsi_only = GF_TRUE;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tgf_filter_pid_send_event(ds->ipid, &anevt);\n\t\t\t}\n\t\t}\n\t\treturn GF_FALSE;\n\t}\n\tif (evt->base.type == GF_FEVT_STOP) {\n\t\tctx->is_playing = GF_FALSE;\n\t\treturn GF_FALSE;\n\t}\n\n\tif (evt->base.type == GF_FEVT_FRAGMENT_SIZE) {\n\t\tdasher_process_hls_ll(ctx, evt);\n\t\treturn GF_TRUE;\n\t}\n\tif (evt->base.type != GF_FEVT_SEGMENT_SIZE) return GF_FALSE;\n\n\tif (ctx->forward_mode==DASHER_FWD_ALL)\n\t\treturn GF_TRUE;\n\n\tcount = gf_list_count(ctx->pids);\n\tfor (i=0; i<count; i++) {\n\t\tu64 r_start, r_end;\n\t\tGF_DashStream *ds = gf_list_get(ctx->pids, i);\n\t\tif (ds->opid != evt->base.on_pid) continue;\n\n\t\tif (ds->muxed_base)\n\t\t\tds = ds->muxed_base;\n\n\t\tif (ctx->store_seg_states && !evt->seg_size.is_init) {\n\t\t\tGF_DASH_SegmentContext *sctx = gf_list_pop_front(ds->pending_segment_states);\n\t\t\tif (!sctx || !ctx->nb_seg_url_pending) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_DASH, (\"[Dasher] Broken muxer, received segment size info event but no pending segments\\n\"));\n\t\t\t\treturn GF_TRUE;\n\t\t\t}\n\t\t\tassert(sctx);\n\t\t\tassert(ctx->nb_seg_url_pending);\n\t\t\tctx->nb_seg_url_pending--;\n\t\t\tgf_filter_post_process_task(filter);\n\t\t\tsctx->file_size = 1 + (u32) (evt->seg_size.media_range_end - evt->seg_size.media_range_start);\n\t\t\tsctx->file_offset = evt->seg_size.media_range_start;\n\t\t\tsctx->index_size = 1 + (u32) (evt->seg_size.idx_range_end - evt->seg_size.idx_range_start);\n\t\t\tsctx->index_offset = evt->seg_size.idx_range_start;\n\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_DASH, (\"[Dasher] Got segment size event for %s\\n\", sctx->filename));\n\n\t\t\tif (sctx->llhls_mode) {\n\t\t\t\tsctx->llhls_done = GF_TRUE;\n\t\t\t\t//reset frags of past segments\n\t\t\t\ts32 idx, reset_until = gf_list_find(ds->rep->state_seg_list, sctx);\n\t\t\t\tfor (idx=reset_until-4; idx>=0; idx--) {\n\t\t\t\t\tGF_DASH_SegmentContext *prev_sctx = gf_list_get(ds->rep->state_seg_list, idx);\n\t\t\t\t\tif (!prev_sctx->llhls_mode)\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t//send file delete events\n\t\t\t\t\tif (prev_sctx->llhls_mode>1) {\n\t\t\t\t\t\tu32 k;\n\t\t\t\t\t\tfor (k=0; k<prev_sctx->nb_frags; k++) {\n\t\t\t\t\t\t\tGF_FilterEvent anevt;\n\t\t\t\t\t\t\tchar szPath[GF_MAX_PATH];\n\t\t\t\t\t\t\tsprintf(szPath, \"%s.%d\", prev_sctx->filepath, k+1);\n\t\t\t\t\t\t\tGF_FEVT_INIT(anevt, GF_FEVT_FILE_DELETE, ds->opid);\n\t\t\t\t\t\t\tanevt.file_del.url = szPath;\n\t\t\t\t\t\t\tgf_filter_pid_send_event(ds->opid, &anevt);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tprev_sctx->llhls_mode = 0;\n\t\t\t\t}\n\t\t\t\tctx->force_hls_ll_manifest = GF_TRUE;\n\t\t\t}\n\t\t}\n\n\t\t//in state mode we store everything\n\t\t//don't set segment sizes in template mode\n\t\tif (ctx->tpl) continue;\n\t\t//only set size/index size for init segment when doing onDemand/single index\n\t\tif (ctx->sseg && !evt->seg_size.is_init) continue;\n\n\t\tif (evt->seg_size.media_range_end) {\n\t\t\tr_start = evt->seg_size.media_range_start;\n\t\t\tr_end = evt->seg_size.media_range_end;\n\t\t} else {\n\t\t\tr_start = evt->seg_size.idx_range_start;\n\t\t\tr_end = evt->seg_size.idx_range_end;\n\t\t}\n\t\t//init segment or representation index, set it in on demand and main single source\n\t\tif ((ctx->sfile || ctx->sseg) && (evt->seg_size.is_init==1))  {\n\t\t\tGF_MPD_URL *url, **s_url;\n\n\t\t\tif (evt->seg_size.is_shift) {\n\t\t\t\tu32 j, nb_segs = gf_list_count(ds->rep->state_seg_list);\n\t\t\t\t//we assume the shifted index start range is the previous init segment end range\n\t\t\t\t//which is always the case for isobmf muxer (the only one using is_shift)\n\t\t\t\tu64 diff = 1 + (u32) (evt->seg_size.idx_range_end - evt->seg_size.idx_range_start);\n\n\t\t\t\tfor (j=0; j<nb_segs; j++) {\n\t\t\t\t\tGF_DASH_SegmentContext *sctx = gf_list_get(ds->rep->state_seg_list, j);\n\t\t\t\t\tsctx->file_offset += diff;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (ds->rep->segment_list) {\n\t\t\t\tif (!evt->seg_size.media_range_start && !evt->seg_size.media_range_end) {\n\t\t\t\t\tif (ds->rep->segment_list->initialization_segment) {\n\t\t\t\t\t\tgf_mpd_url_free(ds->rep->segment_list->initialization_segment);\n\t\t\t\t\t\tds->rep->segment_list->initialization_segment = NULL;\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (ds->rep->segment_base && !evt->seg_size.media_range_end) {\n\t\t\t\tif (! ds->rep->segment_base->index_range) {\n\t\t\t\t\tGF_SAFEALLOC(ds->rep->segment_base->index_range, GF_MPD_ByteRange);\n\t\t\t\t}\n\t\t\t\tif (ds->rep->segment_base->index_range) {\n\t\t\t\t\tds->rep->segment_base->index_range->start_range = r_start;\n\t\t\t\t\tds->rep->segment_base->index_range->end_range = r_end;\n\t\t\t\t\tds->rep->segment_base->index_range_exact = GF_TRUE;\n\t\t\t\t}\n\t\t\t\tflush_mpd = GF_TRUE;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tGF_SAFEALLOC(url, GF_MPD_URL);\n\t\t\tif (!url) return GF_TRUE;\n\n\t\t\tGF_SAFEALLOC(url->byte_range, GF_MPD_ByteRange);\n\t\t\tif (!url->byte_range) return GF_TRUE;\n\t\t\turl->byte_range->start_range = r_start;\n\t\t\turl->byte_range->end_range = r_end;\n\n\t\t\ts_url = NULL;\n\t\t\tif (ds->rep->segment_base) {\n\t\t\t\tif (evt->seg_size.media_range_end) s_url = &ds->rep->segment_base->initialization_segment;\n\t\t\t} else {\n\t\t\t\tassert(ds->rep->segment_list);\n\t\t\t\tif (evt->seg_size.media_range_end) s_url = &ds->rep->segment_list->initialization_segment;\n\t\t\t\telse s_url = &ds->rep->segment_list->representation_index;\n\t\t\t}\n\t\t\tassert(s_url);\n\t\t\tif (*s_url) gf_mpd_url_free(*s_url);\n\t\t\t*s_url = url;\n\t\t} else if (ds->rep->segment_list && !evt->seg_size.is_init) {\n\t\t\tGF_MPD_SegmentURL *url = gf_list_pop_front(ds->pending_segment_urls);\n\t\t\tif (!url || !ctx->nb_seg_url_pending) {\n\t\t\t\tif (!ds->done) {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_DASH, (\"[Dasher] Broken muxer, received segment size info event but no pending segments\\n\"));\n\t\t\t\t}\n\t\t\t\treturn GF_TRUE;\n\t\t\t}\n\t\t\tctx->nb_seg_url_pending--;\n\n\t\t\tif (!url->media && ctx->sfile) {\n\t\t\t\tGF_SAFEALLOC(url->media_range, GF_MPD_ByteRange);\n\t\t\t\tif (url->media_range) {\n\t\t\t\t\turl->media_range->start_range = evt->seg_size.media_range_start;\n\t\t\t\t\turl->media_range->end_range = evt->seg_size.media_range_end;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//patch in test mode, old arch was not generating the index size for segment lists\n\t\t\tif (evt->seg_size.idx_range_end && (!gf_sys_old_arch_compat() || ctx->sfile) ) {\n\t\t\t\tGF_SAFEALLOC(url->index_range, GF_MPD_ByteRange);\n\t\t\t\tif (url->index_range) {\n\t\t\t\t\turl->index_range->start_range = evt->seg_size.idx_range_start;\n\t\t\t\t\turl->index_range->end_range = evt->seg_size.idx_range_end;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (!ctx->sseg || !flush_mpd) return GF_TRUE;\n\n\tflush_mpd = GF_TRUE;\n\tfor (i=0; i<count; i++) {\n\t\tGF_DashStream *ds = gf_list_get(ctx->pids, i);\n\t\tif (!ds->rep) continue;\n\t\tif (! ds->rep->segment_base) continue;\n\t\tif (ds->rep->segment_base->index_range) continue;\n\t\tflush_mpd = GF_FALSE;\n\t\tbreak;\n\t}\n\tif (flush_mpd) {\n\t\tctx->on_demand_done = GF_TRUE;\n\t\tgf_filter_post_process_task(filter);\n\t}\n\treturn GF_TRUE;\n}\n\nstatic GF_Err dasher_setup_profile(GF_DasherCtx *ctx)\n{\n\tswitch (ctx->profile) {\n\tcase GF_DASH_PROFILE_AVC264_LIVE:\n\tcase GF_DASH_PROFILE_AVC264_ONDEMAND:\n\tcase GF_DASH_PROFILE_DASHIF_LL:\n\t\tif (ctx->cp == GF_DASH_CPMODE_REPRESENTATION) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_DASH, (\"[Dasher] ERROR! The selected DASH profile (DASH-IF IOP) requires the ContentProtection element to be present in the AdaptationSet element, updating.\\n\"));\n\t\t\tctx->cp = GF_DASH_CPMODE_ADAPTATION_SET;\n\t\t}\n\tdefault:\n\t\tbreak;\n\t}\n\tif (ctx->muxtype==DASHER_MUX_TS) {\n\t\tswitch (ctx->profile) {\n\t\tcase GF_DASH_PROFILE_HBBTV_1_5_ISOBMF_LIVE:\n\t\tcase GF_DASH_PROFILE_AVC264_LIVE:\n\t\tcase GF_DASH_PROFILE_DASHIF_LL:\n\t\t\tctx->profile = GF_DASH_PROFILE_LIVE;\n\t\t\tbreak;\n\t\tcase GF_DASH_PROFILE_ONDEMAND:\n\t\tcase GF_DASH_PROFILE_AVC264_ONDEMAND:\n\t\t\tctx->profile = GF_DASH_PROFILE_ONDEMAND;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/*adjust params based on profiles*/\n\tswitch (ctx->profile) {\n\tcase GF_DASH_PROFILE_LIVE:\n\t\tctx->sseg = ctx->sfile = GF_FALSE;\n\t\tctx->tpl = ctx->align = ctx->sap = GF_TRUE;\n\t\tbreak;\n\tcase GF_DASH_PROFILE_HBBTV_1_5_ISOBMF_LIVE:\n\t\tctx->check_main_role = GF_TRUE;\n\t\tctx->bs_switch = DASHER_BS_SWITCH_MULTI;\n\t\t//FALLTHROUGH\n\tcase GF_DASH_PROFILE_AVC264_LIVE:\n\t\tctx->sseg = ctx->sfile = GF_FALSE;\n\t\tctx->no_fragments_defaults = ctx->align = ctx->tpl = ctx->sap = GF_TRUE;\n\t\tbreak;\n\tcase GF_DASH_PROFILE_AVC264_ONDEMAND:\n\t\tctx->tpl = GF_FALSE;\n\t\tctx->no_fragments_defaults = ctx->align = ctx->sseg = ctx->sap = GF_TRUE;\n\t\tbreak;\n\tcase GF_DASH_PROFILE_ONDEMAND:\n\t\tctx->sseg = ctx->align = ctx->sap = ctx->sfile = GF_TRUE;\n\t\tctx->tpl = GF_FALSE;\n\n\t\tif (ctx->muxtype==DASHER_MUX_TS) {\n\t\t\tctx->sseg = GF_FALSE;\n\t\t\tctx->tpl = GF_TRUE;\n\t\t\tctx->profile = GF_DASH_PROFILE_MAIN;\n\t\t} else {\n\t\t\tif ((ctx->bs_switch != DASHER_BS_SWITCH_DEF) && (ctx->bs_switch != DASHER_BS_SWITCH_OFF)) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_DASH, (\"[Dasher] onDemand profile, bitstream switching mode cannot be used, defaulting to off.\\n\"));\n\t\t\t}\n\t\t}\n\t\t/*BS switching is meaningless in onDemand profile*/\n\t\tctx->bs_switch = DASHER_BS_SWITCH_OFF;\n\t\tbreak;\n\tcase GF_DASH_PROFILE_MAIN:\n\t\tctx->align = ctx->sap = GF_TRUE;\n\t\tctx->sseg = ctx->tpl = GF_FALSE;\n\t\tbreak;\n\tcase GF_DASH_PROFILE_DASHIF_LL:\n\t\tctx->sseg = ctx->sfile = GF_FALSE;\n\t\tctx->no_fragments_defaults = ctx->align = ctx->tpl = ctx->sap = GF_TRUE;\n\t\tif (!ctx->utcs) {\n\t\t\tconst char *default_utc_timing_server = \"https://time.akamai.com/?iso&ms\";\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_DASH, (\"[Dasher] DASH-IF LL requires UTCTiming but none specified, using %s \\n\", default_utc_timing_server));\n\t\t\tctx->utcs = gf_strdup(default_utc_timing_server);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif ((ctx->bs_switch == DASHER_BS_SWITCH_MULTI) && (ctx->pswitch == DASHER_PSWITCH_STSD)) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_DASH, (\"[Dasher] Cannot use `stsd` period switch with `multi` bitstream switching, disabling pswitch\\n\"));\n\t\tctx->pswitch = DASHER_PSWITCH_SINGLE;\n\t}\n\n\tif (ctx->sseg)\n\t\tctx->tpl = GF_FALSE;\n\n\tif (ctx->bs_switch == DASHER_BS_SWITCH_DEF) {\n\t\tctx->bs_switch = DASHER_BS_SWITCH_ON;\n\t}\n\n\tif (ctx->cmaf) {\n\t\tctx->align = GF_TRUE;\n\t\tctx->sap = GF_TRUE;\n\t}\n\n\tif (! ctx->align) {\n\t\tif (ctx->profile != GF_DASH_PROFILE_FULL) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_DASH, (\"[Dasher] Segments are not time-aligned in each representation of each period\\n\\tswitching to FULL profile\\n\"));\n\t\t\tctx->profile = GF_DASH_PROFILE_FULL;\n\t\t}\n\t\t//commented out, this does not seem correct since BS switching is orthogonal to segment alignment\n\t\t//one could have inband params working even in non time-aligned setup\n#if 0\n\t\tif (ctx->bs_switch != DASHER_BS_SWITCH_OFF) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_DASH, (\"[Dasher] Segments are not time-aligned in each representation of each period\\n\\tdisabling bitstream switching\\n\"));\n\t\t\tctx->bs_switch = DASHER_BS_SWITCH_OFF;\n\t\t}\n#endif\n\n\t}\n\n\t//check we have a segment template\n\tif (!ctx->template) {\n\t\tif (!ctx->sigfrag) {\n\t\t\tctx->template = gf_strdup( ctx->sfile ? \"$File$$FS$_dash\" : (ctx->stl ? \"$File$_dash$FS$$Time$\" : \"$File$_dash$FS$$Number$\") );\n\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_DASH, (\"[Dasher] No template assigned, using %s\\n\", ctx->template));\n\t\t\tctx->def_template = 1;\n\t\t}\n\n\t\tif (ctx->profile == GF_DASH_PROFILE_FULL) {\n\t\t\tctx->sfile = GF_TRUE;\n\t\t}\n\t}\n\t//backward compatibility with old arch using %s\n\telse {\n\t\tchar *sep = strstr(ctx->template, \"%s\");\n\t\tif (sep) {\n\t\t\tchar *new_template = NULL;\n\t\t\tsep[0] = 0;\n\t\t\tgf_dynstrcat(&new_template, ctx->template, NULL);\n\t\t\tgf_dynstrcat(&new_template, \"$File$\", NULL);\n\t\t\tgf_dynstrcat(&new_template, sep+2, NULL);\n\t\t\tgf_free(ctx->template);\n\t\t\tctx->template = new_template;\n\t\t}\n\n\t}\n\treturn GF_OK;\n}\n\nstatic GF_Err dasher_initialize(GF_Filter *filter)\n{\n\tGF_Err e;\n\tGF_DasherCtx *ctx = gf_filter_get_udta(filter);\n\tgf_filter_set_max_extra_input_pids(filter, -1);\n\n\tctx->pids = gf_list_new();\n\tctx->postponed_pids = gf_list_new();\n\tctx->tpl_records = gf_list_new();\n\tif (!ctx->initext && (ctx->muxtype==DASHER_MUX_AUTO))\n\t\tctx->muxtype = DASHER_MUX_ISOM;\n\n\tif ((ctx->segdur.num <= 0) || !ctx->segdur.den) {\n\t\tctx->segdur.num = 1;\n\t\tctx->segdur.den = 1;\n\t\tctx->no_seg_dur = GF_TRUE;\n\t}\n\tif (ctx->dmode==GF_DASH_DYNAMIC_LAST+1) {\n\t\tctx->dmode = GF_DASH_DYNAMIC;\n\t\tctx->move_to_static = GF_TRUE;\n\t}\n\n\te = dasher_setup_profile(ctx);\n\tif (e) return e;\n\n\tif (ctx->sfile && ctx->tpl)\n\t\tctx->tpl = GF_FALSE;\n\n\tctx->current_period = dasher_new_period();\n\tctx->next_period = dasher_new_period();\n\tctx->on_demand_done = GF_TRUE;\n\n\tif (ctx->state) {\n\t\tctx->first_context_load = GF_TRUE;\n\t}\n\tif (ctx->subdur && !ctx->state) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_DASH, (\"[Dasher] subdur mode specified but no context set, will only dash %g seconds of media\\n\", ctx->subdur));\n\t}\n\t//we build manifest from input frag/seg, always use single frag\n\tif (ctx->sigfrag) {\n\t\tif (ctx->tpl) {\n\t\t\tctx->sseg = GF_FALSE;\n\t\t\tctx->sfile = GF_FALSE;\n\t\t} else {\n\t\t\tif (!ctx->sseg)\n\t\t\t\tctx->sfile = GF_TRUE;\n\t\t}\n\t\tif (ctx->gencues) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_DASH, (\"[Dasher] `sigfrag` and `gencues` options cannot be used together, disabling gencies\\n\"));\n\t\t\tctx->gencues = GF_FALSE;\n\t\t}\n\t}\n\n\tif (!ctx->sap || ctx->sigfrag || ctx->cues)\n\t\tctx->sbound = DASHER_BOUNDS_OUT;\n\n\tif ((ctx->tsb>=0) && (ctx->dmode!=GF_DASH_STATIC))\n\t\tctx->purge_segments = GF_TRUE;\n\n\tif (ctx->state && ctx->sreg) {\n\t\tu32 diff;\n\t\tu64 next_gen_ntp;\n\t\tGF_Err dash_state_check_timing(const char *dash_state, u64 *next_gen_ntp_ms, u32 *next_time_ms);\n\n\t\te = dash_state_check_timing(ctx->state, &next_gen_ntp, &diff);\n\t\tif (e<0) return e;\n\t\tif (e==GF_EOS) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_DASH, (\"[Dasher] generation called too early by %d ms\\n\", (s32) diff));\n\t\t\treturn e;\n\t\t}\n\t}\n\n\n\tdasher_init_utc(filter, ctx);\n\n#ifdef GPAC_CONFIG_EMSCRIPTEN\n\t//we need to read the state file so we must run on main thread\n\tif (ctx->state)\n\t\tgf_filter_force_main_thread(filter, GF_TRUE);\n#endif\n\treturn GF_OK;\n}\n\n\nstatic void dasher_finalize(GF_Filter *filter)\n{\n\tGF_DasherCtx *ctx = gf_filter_get_udta(filter);\n\n\twhile (gf_list_count(ctx->pids)) {\n\t\tGF_DashStream *ds = gf_list_pop_back(ctx->pids);\n\t\tdasher_reset_stream(filter, ds, GF_TRUE);\n\t\tif (ds->packet_queue) gf_list_del(ds->packet_queue);\n#ifndef GPAC_DISABLE_CRYPTO\n\t\tif (ds->cinfo) gf_crypt_info_del(ds->cinfo);\n#endif\n\t\tgf_free(ds);\n\t}\n\tgf_list_del(ctx->pids);\n\tif (ctx->mpd) gf_mpd_del(ctx->mpd);\n\n\twhile (gf_list_count(ctx->tpl_records)) {\n\t\tDashTemplateRecord *tr = gf_list_pop_back(ctx->tpl_records);\n\t\tgf_free(tr->tpl);\n\t\tgf_free(tr);\n\t}\n\tgf_list_del(ctx->tpl_records);\n\n\tif (ctx->next_period->period) gf_mpd_period_free(ctx->next_period->period);\n\tgf_list_del(ctx->current_period->streams);\n\tgf_free(ctx->current_period);\n\tgf_list_del(ctx->next_period->streams);\n\tgf_free(ctx->next_period);\n\tif (ctx->out_path) gf_free(ctx->out_path);\n\tgf_list_del(ctx->postponed_pids);\n#ifndef GPAC_DISABLE_CRYPTO\n\tif (ctx->cinfo) gf_crypt_info_del(ctx->cinfo);\n#endif\n}\n\n#define MPD_EXTS \"mpd|m3u8|3gm|ism|ghix|ghi\"\n#define MPD_MIMES \"application/dash+xml|video/vnd.3gpp.mpd|audio/vnd.3gpp.mpd|video/vnd.mpeg.dash.mpd|audio/vnd.mpeg.dash.mpd|audio/mpegurl|video/mpegurl|application/vnd.ms-sstr+xml|application/x-gpac-ghi|application/x-gpac-ghix\"\n\nstatic const GF_FilterCapability DasherCaps[] =\n{\n\t//we accept files as input, but only for NULL file (no source)\n\tCAP_UINT(GF_CAPS_INPUT,  GF_PROP_PID_STREAM_TYPE, GF_STREAM_FILE),\n\t//only with no source\n\tCAP_STRING(GF_CAPS_INPUT_EXCLUDED, GF_PROP_PID_URL, \"*\"),\n\tCAP_STRING(GF_CAPS_INPUT_EXCLUDED, GF_PROP_PID_FILEPATH, \"*\"),\n\n\tCAP_UINT(GF_CAPS_OUTPUT, GF_PROP_PID_STREAM_TYPE, GF_STREAM_FILE),\n\tCAP_STRING(GF_CAPS_OUTPUT, GF_PROP_PID_FILE_EXT, MPD_EXTS),\n\tCAP_STRING(GF_CAPS_OUTPUT, GF_PROP_PID_MIME, MPD_MIMES),\n\t{0},\n\t//anything AV pid framed result in manifest PID\n\tCAP_UINT(GF_CAPS_INPUT,  GF_PROP_PID_STREAM_TYPE, GF_STREAM_VISUAL),\n\tCAP_UINT(GF_CAPS_INPUT,  GF_PROP_PID_STREAM_TYPE, GF_STREAM_AUDIO),\n\tCAP_UINT(GF_CAPS_INPUT_EXCLUDED, GF_PROP_PID_CODECID, GF_CODECID_NONE),\n\tCAP_BOOL(GF_CAPS_INPUT_EXCLUDED, GF_PROP_PID_UNFRAMED, GF_TRUE),\n\n\tCAP_UINT(GF_CAPS_OUTPUT, GF_PROP_PID_STREAM_TYPE, GF_STREAM_FILE),\n\tCAP_STRING(GF_CAPS_OUTPUT, GF_PROP_PID_FILE_EXT, MPD_EXTS),\n\tCAP_STRING(GF_CAPS_OUTPUT, GF_PROP_PID_MIME, MPD_MIMES),\n\t{0},\n\t//anything else (not file, not AV and framed) in compressed format result in manifest PID\n\t//we cannot handle RAW format for such streams as these are in-memory data (scene graph, decoded text, etc ..)\n\tCAP_UINT(GF_CAPS_INPUT_EXCLUDED,  GF_PROP_PID_STREAM_TYPE, GF_STREAM_FILE),\n\tCAP_UINT(GF_CAPS_INPUT_EXCLUDED,  GF_PROP_PID_STREAM_TYPE, GF_STREAM_VISUAL),\n\tCAP_UINT(GF_CAPS_INPUT_EXCLUDED,  GF_PROP_PID_STREAM_TYPE, GF_STREAM_AUDIO),\n\tCAP_UINT(GF_CAPS_INPUT_EXCLUDED, GF_PROP_PID_CODECID, GF_CODECID_RAW),\n\tCAP_BOOL(GF_CAPS_INPUT_EXCLUDED, GF_PROP_PID_UNFRAMED, GF_TRUE),\n\n\tCAP_UINT(GF_CAPS_OUTPUT, GF_PROP_PID_STREAM_TYPE, GF_STREAM_FILE),\n\tCAP_STRING(GF_CAPS_OUTPUT, GF_PROP_PID_FILE_EXT, MPD_EXTS),\n\tCAP_STRING(GF_CAPS_OUTPUT, GF_PROP_PID_MIME, MPD_MIMES),\n\t{0},\n\t//anything else (not file and framed) result in media pids not file\n\tCAP_UINT(GF_CAPS_INPUT_EXCLUDED | GF_CAPFLAG_LOADED_FILTER,  GF_PROP_PID_STREAM_TYPE, GF_STREAM_FILE),\n\tCAP_UINT(GF_CAPS_INPUT_EXCLUDED | GF_CAPFLAG_LOADED_FILTER, GF_PROP_PID_CODECID, GF_CODECID_NONE),\n\tCAP_BOOL(GF_CAPS_INPUT_EXCLUDED | GF_CAPFLAG_LOADED_FILTER, GF_PROP_PID_UNFRAMED, GF_TRUE),\n\tCAP_UINT(GF_CAPS_OUTPUT_EXCLUDED | GF_CAPFLAG_LOADED_FILTER, GF_PROP_PID_STREAM_TYPE, GF_STREAM_FILE),\n\n};\n\n\n#define OFFS(_n)\t#_n, offsetof(GF_DasherCtx, _n)\nstatic const GF_FilterArgs DasherArgs[] =\n{\n\t{ OFFS(segdur), \"target segment duration in seconds. A value less than or equal to 0 defaults to 1.0 second\", GF_PROP_FRACTION, \"0/0\", NULL, 0},\n\t{ OFFS(tpl), \"use template mode (multiple segment, template URLs)\", GF_PROP_BOOL, \"true\", NULL, 0},\n\t{ OFFS(stl), \"use segment timeline (ignored in on_demand mode)\", GF_PROP_BOOL, \"false\", NULL, 0},\n\t{ OFFS(dmode), \"dash content mode\\n\"\n\t\t\"- static: static content\\n\"\n\t\t\"- dynamic: live generation\\n\"\n\t\t\"- dynlast: last call for live, will turn the MPD into static\\n\"\n\t\t\"- dynauto: live generation and move to static manifest upon end of stream\"\n\t\t\"\", GF_PROP_UINT, \"static\", \"static|dynamic|dynlast|dynauto\", GF_FS_ARG_UPDATE},\n\t{ OFFS(sseg), \"single segment is used\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(sfile), \"use a single file for all segments (default in on_demand)\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(align), \"enable segment time alignment between representations\", GF_PROP_BOOL, \"true\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(sap), \"enable splitting segments at SAP boundaries\", GF_PROP_BOOL, \"true\", NULL, 0},\n\t{ OFFS(mix_codecs), \"enable mixing different codecs in an adaptation set\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_EXPERT},\n\t{ OFFS(ntp), \"insert/override NTP clock at the beginning of each segment\\n\"\n\t\"- rem: removes NTP from all input packets\\n\"\n\t\"- yes: inserts NTP at each segment start\\n\"\n\t\"- keep: leaves input packet NTP untouched\", GF_PROP_UINT, \"rem\", \"rem|yes|keep\", GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(no_sar), \"do not check for identical sample aspect ratio for adaptation sets\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_EXPERT},\n\t{ OFFS(bs_switch), \"bitstream switching mode (single init segment)\\n\"\n\t\"- def: resolves to off for onDemand and inband for live\\n\"\n\t\"- off: disables BS switching\\n\"\n\t\"- on: enables it if same decoder configuration is possible\\n\"\n\t\"- inband: moves decoder config inband if possible\\n\"\n\t\"- both: inband and outband parameter sets\\n\"\n\t\"- pps: moves PPS and APS inband, keep VPS,SPS and DCI out of band (used for VVC RPR)\\n\"\n\t\"- force: enables it even if only one representation\\n\"\n\t\"- multi: uses multiple stsd entries in ISOBMFF\", GF_PROP_UINT, \"def\", \"def|off|on|inband|pps|both|force|multi\", GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(template), \"template string to use to generate segment name\", GF_PROP_STRING, NULL, NULL, 0},\n\t{ OFFS(segext), \"file extension to use for segments\", GF_PROP_STRING, NULL, NULL, 0},\n\t{ OFFS(initext), \"file extension to use for the init segment\", GF_PROP_STRING, NULL, NULL, 0},\n\t{ OFFS(muxtype), \"muxtype to use for the segments\\n\"\n\t\t\"- mp4: uses ISOBMFF format\\n\"\n\t\t\"- ts: uses MPEG-2 TS format\\n\"\n\t\t\"- mkv: uses Matroska format\\n\"\n\t\t\"- webm: uses WebM format\\n\"\n\t\t\"- ogg: uses OGG format\\n\"\n\t\t\"- raw: uses raw media format (disables multiplexed representations)\\n\"\n\t\t\"- auto: guess format based on extension, default to mp4 if no extension\", GF_PROP_UINT, \"auto\", \"mp4|ts|mkv|webm|ogg|raw|auto\", 0},\n\t{ OFFS(rawsub), \"use raw subtitle format instead of encapsulating in container\", GF_PROP_BOOL, \"no\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(asto), \"availabilityStartTimeOffset to use in seconds. A negative value simply increases the AST, a positive value sets the ASToffset to representations\", GF_PROP_DOUBLE, \"0\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(profile), \"target DASH profile. This will set default option values to ensure conformance to the desired profile. For MPEG-2 TS, only main and live are used, others default to main\\n\"\n\t\t\"- auto: turns profile to live for dynamic and full for non-dynamic\\n\"\n\t\t\"- live: DASH live profile, using segment template\\n\"\n\t\t\"- onDemand: MPEG-DASH live profile\\n\"\n\t\t\"- main: MPEG-DASH main profile, using segment list\\n\"\n\t\t\"- full: MPEG-DASH full profile\\n\"\n\t\t\"- hbbtv1.5.live: HBBTV 1.5 DASH profile\\n\"\n\t\t\"- dashavc264.live: DASH-IF live profile\\n\"\n\t\t\"- dashavc264.onDemand: DASH-IF onDemand profile\\n\"\n\t\t\"- dashif.ll: DASH IF low-latency profile (set UTC server to time.akamai.com if none set)\"\n\t\t\"\", GF_PROP_UINT, \"auto\", \"auto|live|onDemand|main|full|hbbtv1.5.live|dashavc264.live|dashavc264.onDemand|dashif.ll\", 0 },\n\t{ OFFS(profX), \"list of profile extensions, as used by DASH-IF and DVB. The string will be colon-concatenated with the profile used. If starting with `+`, the profile string by default is erased and `+` is skipped\", GF_PROP_STRING, NULL, NULL, GF_FS_ARG_HINT_ADVANCED },\n\t{ OFFS(cp), \"content protection element location\\n\"\n\t\"- set: in adaptation set element\\n\"\n\t\"- rep: in representation element\\n\"\n\t\"- both: in both adaptation set and representation elements\"\n\t\"\", GF_PROP_UINT, \"set\", \"set|rep|both\", GF_FS_ARG_HINT_ADVANCED },\n\t{ OFFS(pssh), \"storage mode for PSSH box\\n\"\n\t\"- f: stores in movie fragment only\\n\"\n\t\"- v: stores in movie only, or movie and fragments if key roll is detected\\n\"\n\t\"- m: stores in mpd only\\n\"\n\t\"- mf: stores in mpd and movie fragment\\n\"\n\t\"- mv: stores in mpd and movie\\n\"\n\t\"- n: discard pssh from mpd and segments\", GF_PROP_UINT, \"v\", \"v|f|mv|mf|m|n\", GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(buf), \"min buffer duration in ms. negative value means percent of segment duration (e.g. -150 = 1.5*seg_dur)\", GF_PROP_SINT, \"-100\", NULL, 0},\n\t{ OFFS(spd), \"suggested presentation delay in ms\", GF_PROP_SINT, \"0\", NULL, 0},\n\t{ OFFS(timescale), \"set timescale for timeline and segment list/template. A value of 0 picks up the first timescale of the first stream in an adaptation set. A negative value forces using stream timescales for each timed element (multiplication of segment list/template/timelines). A positive value enforces the MPD timescale\", GF_PROP_SINT, \"0\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(check_dur), \"check duration of sources in period, trying to have roughly equal duration. Enforced whenever period start times are used\", GF_PROP_BOOL, \"true\", NULL, 0},\n\t{ OFFS(skip_seg), \"increment segment number whenever an empty segment would be produced - NOT DASH COMPLIANT\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_EXPERT},\n\t{ OFFS(title), \"MPD title\", GF_PROP_STRING, NULL, NULL, 0},\n\t{ OFFS(source), \"MPD Source\", GF_PROP_STRING, NULL, NULL, 0},\n\t{ OFFS(info), \"MPD info url\", GF_PROP_STRING, NULL, NULL, 0},\n\t{ OFFS(cprt), \"MPD copyright string\", GF_PROP_STRING, NULL, NULL, 0},\n\t{ OFFS(lang), \"language of MPD Info\", GF_PROP_STRING, NULL, NULL, 0},\n\t{ OFFS(location), \"set MPD locations to given URL\", GF_PROP_STRING_LIST, NULL, NULL, 0},\n\t{ OFFS(base), \"set base URLs of MPD\", GF_PROP_STRING_LIST, NULL, NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(refresh), \"refresh rate for dynamic manifests, in seconds (a negative value sets the MPD duration, value 0 uses dash duration)\", GF_PROP_DOUBLE, \"0\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(tsb), \"time-shift buffer depth in seconds (a negative value means infinity)\", GF_PROP_DOUBLE, \"30\", NULL, 0},\n\t{ OFFS(subdur), \"maximum duration of the input file to be segmented. This does not change the segment duration, segmentation stops once segments produced exceeded the duration\", GF_PROP_DOUBLE, \"0\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(ast), \"set start date (as xs:date, e.g. YYYY-MM-DDTHH:MM:SSZ) for live mode. Default is now. !! Do not use with multiple periods, nor when DASH duration is not a multiple of GOP size !!\", GF_PROP_STRING, NULL, NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(state), \"path to file used to store/reload state info when simulating live. This is stored as a valid MPD with GPAC XML extensions\", GF_PROP_STRING, NULL, NULL, GF_FS_ARG_HINT_EXPERT},\n\t{ OFFS(loop), \"loop sources when dashing with subdur and state. If not set, a new period is created once the sources are over\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(split), \"enable cloning samples for text/metadata/scene description streams, marking further clones as redundant\", GF_PROP_BOOL, \"true\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(hlsc), \"insert clock reference in variant playlist in live HLS\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_EXPERT},\n\t{ OFFS(cues), \"set cue file\", GF_PROP_STRING, NULL, NULL, GF_FS_ARG_HINT_EXPERT},\n\t{ OFFS(strict_cues), \"strict mode for cues, complains if splitting is not on SAP type 1/2/3 or if unused cue is found\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_EXPERT},\n\t{ OFFS(strict_sap), \"strict mode for sap\\n\"\n\t\"- off: ignore SAP types for PID other than video, enforcing _startsWithSAP=1_\\n\"\n\t\"- sig: same as [-off]() but keep _startsWithSAP_ to the true SAP value\\n\"\n\t\"- on: warn if any PID uses SAP 3 or 4 and switch to FULL profile\\n\"\n\t\"- intra: ignore SAP types greater than 3 on all media types\"\n\t, GF_PROP_UINT, \"off\", \"off|sig|on|intra\", GF_FS_ARG_HINT_EXPERT},\n\n\t{ OFFS(subs_sidx), \"number of subsegments per sidx. negative value disables sidx. Only used to inherit sidx option of destination\", GF_PROP_SINT, \"-1\", NULL, GF_FS_ARG_HINT_EXPERT},\n\t{ OFFS(cmpd), \"skip line feed and spaces in MPD XML for compactness\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_EXPERT},\n\t{ OFFS(styp), \"indicate the 4CC to use for styp boxes when using ISOBMFF output\", GF_PROP_STRING, NULL, NULL, GF_FS_ARG_HINT_EXPERT},\n\t{ OFFS(dual), \"indicate to produce both MPD and M3U files\", GF_PROP_BOOL, NULL, NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(sigfrag), \"use manifest generation only mode\", GF_PROP_BOOL, NULL, NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(_p_gentime), \"pointer to u64 holding the ntp clock in ms of next DASH generation in live mode\", GF_PROP_POINTER, NULL, NULL, GF_FS_ARG_HINT_HIDE},\n\t{ OFFS(_p_mpdtime), \"pointer to u64 holding the mpd time in ms of the last generated segment\", GF_PROP_POINTER, NULL, NULL, GF_FS_ARG_HINT_HIDE},\n\t{ OFFS(sbound), \"indicate how the theoretical segment start `TSS (= segment_number * duration)` should be handled\\n\"\n\t\t\t\t\"- out: segment split as soon as `TSS` is exceeded (`TSS` <= segment_start)\\n\"\n\t\t\t\t\"- closest: segment split at closest SAP to theoretical bound\\n\"\n\t\t\t\t\"- in: `TSS` is always in segment (`TSS` >= segment_start)\", GF_PROP_UINT, \"out\", \"out|closest|in\", GF_FS_ARG_HINT_EXPERT},\n\t{ OFFS(reschedule), \"reschedule sources with no period ID assigned once done (dynamic mode only)\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_EXPERT},\n\t{ OFFS(sreg), \"regulate the session\\n\"\n\t\"- when using subdur and context, only generate segments from the past up to live edge\\n\"\n\t\"- otherwise in dynamic mode without context, do not generate segments ahead of time\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_EXPERT},\n\t{ OFFS(scope_deps), \"scope PID dependencies to be within source. If disabled, PID dependencies will be checked across all input PIDs regardless of their sources\", GF_PROP_BOOL, \"true\", NULL, GF_FS_ARG_HINT_EXPERT},\n\t{ OFFS(utcs), \"URL to use as time server / UTCTiming source. Special value `inband` enables inband UTC (same as publishTime), special prefix `xsd@` uses xsDateTime schemeURI rather than ISO\", GF_PROP_STRING, NULL, NULL, GF_FS_ARG_HINT_EXPERT},\n\t{ OFFS(force_flush), \"force generating a single segment for each input. This can be useful in batch mode when average source duration is known and used as segment duration but actual duration may sometimes be greater\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_EXPERT},\n\t{ OFFS(last_seg_merge), \"force merging last segment if less than half the target duration\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_EXPERT},\n\t{ OFFS(mha_compat), \"adaptation set generation mode for compatible MPEG-H Audio profile\\n\"\n\t\t\"- no: only generate the adaptation set for the main profile\\n\"\n\t\t\"- comp: only generate the adaptation sets for all compatible profiles\\n\"\n\t\t\"- all: generate the adaptation set for the main profile and all compatible profiles\"\n\t\t, GF_PROP_UINT, \"no\", \"no|comp|all\", GF_FS_ARG_HINT_EXPERT},\n\t{ OFFS(mname), \"output manifest name for ATSC3 multiplexing\", GF_PROP_STRING, NULL, NULL, GF_FS_ARG_HINT_EXPERT},\n\t{ OFFS(llhls), \"HLS low latency type\\n\"\n\t\t\"- off: do not use LL-HLS\\n\"\n\t\t\"- br: use LL-HLS with byte-range for segment parts, pointing to full segment (DASH-LL compatible)\\n\"\n\t\t\"- sf: use separate files for segment parts (post-fixed .1, .2 etc.)\\n\"\n\t\t\"- brsf: generate two sets of manifest, one for byte-range and one for files (`_IF` added before extension of manifest)\", GF_PROP_UINT, \"off\", \"off|br|sf|brsf\", GF_FS_ARG_HINT_EXPERT},\n\t{ OFFS(cdur), \"chunk duration for fragmentation modes\", GF_PROP_FRACTION, \"-1/1\", NULL, GF_FS_ARG_HINT_HIDE},\n\t{ OFFS(hlsdrm), \"cryp file info for HLS full segment encryption\", GF_PROP_STRING, NULL, NULL, GF_FS_ARG_HINT_EXPERT},\n\t{ OFFS(hlsx), \"list of string to append to master HLS header before variants with `['#foo','#bar=val']` added as `#foo \\\\n #bar=val`\", GF_PROP_STRING_LIST, NULL, NULL, GF_FS_ARG_HINT_EXPERT},\n\t{ OFFS(ll_preload_hint), \"inject preload hint for LL-HLS\", GF_PROP_BOOL, \"true\", NULL, GF_FS_ARG_HINT_EXPERT},\n\t{ OFFS(ll_rend_rep), \"inject rendition reports for LL-HLS\", GF_PROP_BOOL, \"true\", NULL, GF_FS_ARG_HINT_EXPERT},\n\t{ OFFS(ll_part_hb), \"user-defined part hold-back for LLHLS, negative value means 3 times max part duration in session\", GF_PROP_DOUBLE, \"-1\", NULL, GF_FS_ARG_HINT_EXPERT},\n\t{ OFFS(ckurl), \"set the ClearKey URL common to all encrypted streams (overriden by `CKUrl` pid property)\", GF_PROP_STRING, NULL, NULL, GF_FS_ARG_HINT_EXPERT},\n\n\t{ OFFS(hls_absu), \"use absolute url in HLS generation using first URL in [base]()\\n\"\n\t\"- no: do not use absolute URL\\n\"\n\t\"- var: use absolute URL only in variant playlists\\n\"\n\t\"- mas: use absolute URL only in master playlist\\n\"\n\t\"- both: use absolute URL everywhere\"\n\t\t, GF_PROP_UINT, \"no\", \"no|var|mas|both\", GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(seg_sync), \"control how waiting on last packet P of fragment/segment to be written impacts segment injection in manifest\\n\"\n\t\"- no: do not wait for P\\n\"\n\t\"- yes: wait for P\\n\"\n\t\"- auto: wait for P if HLS is used\"\n\t, GF_PROP_UINT, \"auto\", \"no|yes|auto\", GF_FS_ARG_HINT_EXPERT},\n\n\t{ OFFS(cmaf), \"use cmaf guidelines\\n\"\n\t\t\"- no: CMAF not enforced\\n\"\n\t\t\"- cmfc: use CMAF `cmfc` guidelines\\n\"\n\t\t\"- cmf2: use CMAF `cmf2` guidelines\"\n\t\t, GF_PROP_UINT, \"no\", \"no|cmfc|cmf2\", GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(pswitch), \"period switch control mode\\n\"\n\t\t\"- single: change period if PID configuration changes\\n\"\n\t\t\"- force: force period switch at each PID reconfiguration instead of absorbing PID reconfiguration (for splicing or add insertion not using periodID)\\n\"\n\t\t\"- stsd: change period if PID configuration changes unless new configuration was advertised in initial config\", GF_PROP_UINT, \"single\", \"single|force|stsd\", GF_FS_ARG_HINT_EXPERT},\n\t{ OFFS(chain), \"URL of next MPD for regular chaining\", GF_PROP_STRING, NULL, NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(chain_fbk), \"URL of fallback MPD\", GF_PROP_STRING, NULL, NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(gencues), \"only insert segment boundaries and do not generate manifests\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(force_init), \"force init segment creation in bitstream switching mode\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_EXPERT},\n\t{ OFFS(keep_src), \"keep source URLs in manifest generation mode\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_EXPERT},\n\t{ OFFS(gxns), \"insert some gpac extensions in manifest (for now, only tfdt of first segment)\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_EXPERT},\n\t{ OFFS(dkid), \"control injection of default KID in MPD\\n\"\n\t\t\"- off: default KID not injected\\n\"\n\t\t\"- on: default KID always injected\\n\"\n\t\t\"- auto: default KID only injected if no key roll is detected (as per DASH-IF guidelines)\"\n\t\t, GF_PROP_UINT, \"auto\", \"off|on|auto\", GF_FS_ARG_HINT_EXPERT},\n\t{ OFFS(tpl_force), \"use template string as is without trying to add extension or solve conflicts in names\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_EXPERT},\n\n\t{0}\n};\n\n\nGF_FilterRegister DasherRegister = {\n\t.name = \"dasher\",\n\tGF_FS_SET_DESCRIPTION(\"DASH and HLS segmenter\")\n\tGF_FS_SET_HELP(\n\"This filter provides segmentation and manifest generation for MPEG-DASH and HLS formats.\\n\"\n\"The segmenter currently supports:\\n\"\n\"- MPD and m3u8 generation (potentially in parallel)\\n\"\n\"- ISOBMFF, MPEG-2 TS, MKV and raw bitstream segment formats\\n\"\n\"- override of profiles and levels in manifest for codecs\\n\"\n\"- most MPEG-DASH profiles\\n\"\n\"- static and dynamic (live) manifest offering\\n\"\n\"- context store and reload for batch processing of live/dynamic sessions\\n\"\n\"\\n\"\n\"The filter does perform per-segment real-time regulation using [-sreg]().\\n\"\n\"If you need per-frame real-time regulation on non-real-time inputs, insert a [reframer](reframer) before to perform real-time regulation.\\n\"\n\"EX gpac -i file.mp4 reframer:rt=on -o live.mpd:dmode=dynamic\\n\"\n\"## Template strings\\n\"\n\"The segmenter uses templates to derive output file names, regardless of the DASH mode (even when templates are not used). \"\n\"The default one is `$File$_dash` for ondemand and single file modes, and `$File$_$Number$` for separate segment files\\n\"\n\"EX template=Great_$File$_$Width$_$Number$\\n\"\n\"If input is `foo.mp4` with `640x360` video resolution, this will resolve in `Great_foo_640_$Number$` for the DASH template.\\n\"\n\"EX template=Great_$File$_$Width$\\n\"\n\"If input is `foo.mp4` with `640x360` video resolution, this will resolve in `Great_foo_640.mp4` for onDemand case.\\n\"\n\"\\n\"\n\"Standard DASH replacement strings: \\n\"\n\"- $Number[%%0Nd]$: replaced by the segment number, possibly prefixed with 0\\n\"\n\"- $RepresentationID$: replaced by representation name\\n\"\n\"- $Time$: replaced by segment start time\\n\"\n\"- $Bandwidth$: replaced by representation bandwidth.\\n\"\n\"Note: these strings are not replaced in the manifest templates elements.\\n\"\n\"\\n\"\n\"Additional replacement strings (not DASH, not generic GPAC replacements but may occur multiple times in template):\\n\"\n\"- $Init=NAME$: replaced by NAME for init segment, ignored otherwise\\n\"\n\"- $XInit=NAME$: complete replace by NAME for init segment, ignored otherwise\\n\"\n\"- $InitExt=EXT$: replaced by EXT for init segment file extensions, ignored otherwise\\n\"\n\"- $Index=NAME$: replaced by NAME for index segments, ignored otherwise\\n\"\n\"- $Path=PATH$: replaced by PATH when creating segments, ignored otherwise\\n\"\n\"- $Segment=NAME$: replaced by NAME for media segments, ignored for init segments\\n\"\n\"- $SegExt=EXT$: replaced by EXT for media segment file extensions, ignored for init segments\\n\"\n\"- $FS$ (FileSuffix): replaced by `_trackN` in case the input is an AV multiplex, or kept empty otherwise\\n\"\n\"Note: these strings are replaced in the manifest templates elements.\\n\"\n\"\\n\"\n\"## PID assignment and configuration\\n\"\n\"To assign PIDs into periods and adaptation sets and configure the session, the segmenter looks for the following properties on each input PID:\\n\"\n\"- `Representation`: assigns representation ID to input PID. If not set, the default behavior is to have each media component in different adaptation sets. Setting the `Representation` allows explicit multiplexing of the source(s)\\n\"\n\"- `Period`: assigns period ID to input PID. If not set, the default behavior is to have all media in the same period with the same start time\\n\"\n\"- `PStart`: assigns period start. If not set, 0 is assumed, and periods appear in the Period ID declaration order. If negative, this gives the period order (-1 first, then -2 ...). If positive, this gives the true start time and will abort DASHing at period end\\n\"\n\"Note: When both positive and negative values are found, the by-order periods (negative) will be inserted AFTER the timed period (positive)\\n\"\n\"- `ASID`: assigns parent adaptation set ID. If not 0, only sources with same AS ID will be in the same adaptation set\\n\"\n\"Note: If multiple streams in source, only the first stream will have an AS ID assigned\\n\"\n\"- `xlink`: for remote periods, only checked for null PID\\n\"\n\"- `Role`, `PDesc`, `ASDesc`, `ASCDesc`, `RDesc`: various descriptors to set for period, AS or representation\\n\"\n\"- `BUrl`: overrides segmenter [-base] with a set of BaseURLs to use for the PID (per representation)\\n\"\n\"- `Template`: overrides segmenter [-template]() for this PID\\n\"\n\"- `DashDur`: overrides segmenter segment duration for this PID\\n\"\n\"- `StartNumber`: sets the start number for the first segment in the PID, default is 1\\n\"\n\"- `IntraOnly`: indicates input PID follows HLS EXT-X-I-FRAMES-ONLY guidelines\\n\"\n\"- `CropOrigin`: indicates x and y coordinates of video for SRD (size is video size)\\n\"\n\"- `SRD`: indicates SRD position and size of video for SRD, ignored if `CropOrigin` is set\\n\"\n\"- `SRDRef`: indicates global width and height of SRD, ignored if `CropOrigin` is set\\n\"\n\"- `HLSMExt`: list of extensions to add to master playlist entries, ['foo','bar=val'] added as `,foo,bar=val`\\n\"\n\"- `HLSVExt`: list of extensions to add to variant playlist, ['#foo','#bar=val'] added as `#foo \\\\n #bar=val`\\n\"\n\"- Non-dash properties: `Bitrate`, `SAR`, `Language`, `Width`, `Height`, `SampleRate`, `NumChannels`, `Language`, `ID`, `DependencyID`, `FPS`, `Interlaced`, `Codec`. These properties are used to setup each representation and can be overridden on input PIDs using the general PID property settings (cf global help).\\n\"\n\"  \\n\"\n\"EX gpac -i test.mp4:#Bitrate=1M -o test.mpd\\n\"\n\"This will force declaring a bitrate of 1M for the representation, regardless of actual input bitrate.\\n\"\n\"EX gpac -i muxav.mp4 -o test.mpd\\n\"\n\"This will create un-multiplexed DASH segments.\\n\"\n\"EX gpac -i muxav.mp4:#Representation=1 -o test.mpd\\n\"\n\"This will create multiplexed DASH segments.\\n\"\n\"EX gpac -i m1.mp4 -i m2.mp4:#Period=Yep -o test.mpd\\n\"\n\"This will put src `m1.mp4` in first period, `m2.mp4` in second period.\\n\"\n\"EX gpac -i m1.mp4:#BUrl=http://foo/bar -o test.mpd\\n\"\n\"This will assign a baseURL to src `m1.mp4`.\\n\"\n\"EX gpac -i m1.mp4:#ASCDesc=<ElemName val=\\\"attval\\\">text</ElemName> -o test.mpd\\n\"\n\"This will assign the specified XML descriptor to the adaptation set.\\n\"\n\"Note:  this can be used to inject most DASH descriptors not natively handled by the segmenter.\\n\"\n\"The segmenter handles the XML descriptor as a string and does not attempt to validate it. Descriptors, as well as some segmenter filter arguments, are string lists (comma-separated by default), so that multiple descriptors can be added:\\n\"\n\"EX gpac -i m1.mp4:#RDesc=<Elem attribute=\\\"1\\\"/>,<Elem2>text</Elem2> -o test.mpd\\n\"\n\"This will insert two descriptors in the representation(s) of `m1.mp4`.\\n\"\n\"EX gpac -i video.mp4:#Template=foo$Number$ -i audio.mp4:#Template=bar$Number$ -o test.mpd\\n\"\n\"This will assign different templates to the audio and video sources.\\n\"\n\"EX gpac -i null:#xlink=http://foo/bar.xml:#PDur=4 -i m.mp4:#PStart=-1 -o test.mpd\\n\"\n\"This will insert an create an MPD with first a remote period then a regular one.\\n\"\n\"EX gpac -i null:#xlink=http://foo/bar.xml:#PStart=6 -i m.mp4 -o test.mpd\\n\"\n\"This will create an MPD with first a regular period, dashing only 6s of content, then a remote one.\\n\"\n\"EX gpac -i v1:#SRD=0x0x1280x360:#SRDRef=1280x720 -i v2:#SRD=0x360x1280x360 -o test.mpd\\n\"\n\"This will layout the `v2` below `v1` using a global SRD size of 1280x720.\\n\"\n\"\\n\"\n\"The segmenter will create multiplexing filter chains for each representation and will reassign PID IDs so that each media component (video, audio, ...) in an adaptation set has the same ID.\\n\"\n\"\\n\"\n\"For HLS, the output PID will deliver the master playlist **and** the variant playlists.\\n\"\n\"The default variant playlist are $NAME_$N.m3u8, where $NAME is the radical of the output file name and $N is the 1-based index of the variant.\\n\"\n\"\\n\"\n\"## Segmentation\\n\"\n\"The default behavior of the segmenter is to estimate the theoretical start time of each segment based on target segment duration, and start a new segment when a packet with SAP type 1,2,3 or 4 with time greater than the theoretical time is found.\\n\"\n\"This behavior can be changed to find the best SAP packet around a segment theoretical boundary using [-sbound]():\\n\"\n\"- `closest` mode: the segment will start at the closest SAP of the theoretical boundary\\n\"\n\"- `in` mode: the segment will start at or before the theoretical boundary\\n\"\n\"Warning: These modes will introduce delay in the segmenter (typically buffering of one GOP) and should not be used for low-latency modes.\\n\"\n\"The segmenter can also be configured to:\\n\"\n\"- completely ignore SAP when segmenting using [-sap]().\\n\"\n\"- ignore SAP on non-video streams when segmenting using [-strict_sap]().\\n\"\n\"\\n\"\n\"When [-seg_sync]() is disabled, the segmenter will by default announce a new segment in the manifest(s) as soon as its size/offset is known or its name is known, but the segment (or part in LL-HLS) may still not be completely written/sent.\\n\"\n\"This may result in temporary mismatches between segment/part size currently received versus size as advertized in manifest.\\n\"\n\"When [-seg_sync]() is enabled, the segmenter will wait for the last byte of the fragment/segment to be pushed before announcing a new segment in the manifest(s). This can however slightly increase the latency in MPEG-DASH low-latency.\\n\"\n\"\\n\"\n\"## Dynamic (real-time live) Mode\\n\"\n\"The dasher does not perform real-time regulation by default.\\n\"\n\"For regular segmentation, you should enable segment regulation [-sreg]() if your sources are not real-time.\\n\"\n\"EX gpac -i source.mp4 -o live.mpd:segdur=2:profile=live:dmode=dynamic:sreg\\n\"\n\"\\n\"\n\"For low latency segmentation with fMP4, you will need to specify the following options:\\n\"\n\"- cdur: set the fMP4 fragment duration\\n\"\n\"- asto: set the availability time offset for DASH. This value should be equal or slightly greater than segment duration minus cdur\\n\"\n\"- llhls: enable low latency for HLS\\n\"\n\"\\n\"\n\"Note: [-llhls]() does not force `cmaf` mode to allow for multiplexed media in segments but it enforces to `tfdt_traf` in the muxer.\\n\"\n\"\\n\"\n\"If your sources are not real-time, insert a reframer filter with real-time regulation\\n\"\n\"EX gpac -i source.mp4 reframer:rt=on -o live.mpd:segdur=2:cdur=0.2:asto=1.8:profile=live:dmode=dynamic\\n\"\n\"This will create DASH segments of 2 seconds made of fragments of 200 ms and indicate to the client that requests can be made 1.8 seconds earlier than segment complete availability on server.\\n\"\n\"EX gpac -i source.mp4 reframer:rt=on -o live.m3u8:segdur=2:cdur=0.2:llhls=br:dmode=dynamic\\n\"\n\"This will create DASH segments of 2 seconds made of fragments of 200 ms and produce HLS low latency parts using byte ranges in the final segment.\\n\"\n\"EX gpac -i source.mp4 reframer:rt=on -o live.m3u8:segdur=2:cdur=0.2:llhls=sf:dmode=dynamic\\n\"\n\"This will create DASH segments of 2 seconds made of fragments of 200 ms and produce HLS low latency parts using dedicated files.\\n\"\n\"\\n\"\n\"You can combine LL-HLS and DASH-LL generation:\\n\"\n\"EX gpac -i source.mp4 reframer:rt=on -o live.mpd:dual:segdur=2:cdur=0.2:asto=1.8:llhls=br:profile=live:dmode=dynamic\\n\"\n\"\\n\"\n\"For DASH, the filter will use the local clock for UTC anchor points in DASH.\\n\"\n\"The filter can fetch and signal clock in other ways using [-utcs]().\\n\"\n\"EX [opts]:utcs=inband\\n\"\n\"This will use the local clock and insert in the MPD a UTCTiming descriptor containing the local clock.\\n\"\n\"EX [opts]::utcs=http://time.akamai.com[::opts]\\n\"\n\"This will fetch time from `http://time.akamai.com`, use it as the UTC reference for segment generation and insert in the MPD a UTCTiming descriptor containing the time server URL.\\n\"\n\"Note: if not set as a global option using `--utcs=`, you must escape the url using double `::` or use other separators.\\n\"\n\"\\n\"\n\"## Cue-driven segmentation\\n\"\n\"The segmenter can take a list of instructions, or Cues, to use for the segmentation process, in which case only these are used to derive segment boundaries. Cues can be set through XML files or injected in input packets.\\n\"\n\"\\n\"\n\"Cue files can be specified for the entire segmenter, or per PID using `DashCue` property.\\n\"\n\"Cues are given in an XML file with a root element called <DASHCues>, with currently no attribute specified. The children are one or more <Stream> elements, with attributes:\\n\"\n\"- id: integer for stream/track/PID ID\\n\"\n\"- timescale: integer giving the units of following timestamps\\n\"\n\"- mode: if present and value is `edit`, the timestamp are in presentation time (edit list applied) otherwise they are in media time\\n\"\n\"- ts_offset: integer giving a value (in timescale) to subtract to the DTS/CTS values listed\\n\"\n\"\\nThe children of <Stream> are one or more <Cue> elements, with attributes:\\n\"\n\"- sample: integer giving the sample/frame number of a sample at which splitting shall happen\\n\"\n\"- dts: long integer giving the decoding time stamp of a sample at which splitting shall happen\\n\"\n\"- cts: long integer giving the composition / presentation time stamp of a sample at which splitting shall happen\\n\"\n\"Warning: Cues shall be listed in decoding order.\\n\"\n\"\\n\"\n\"If the `DashCue` property of a PID equals `inband`, the PID will be segmented according to the `CueStart` property of input packets.\\n\"\n\"This feature is typically combined with a list of files as input:\\n\"\n\"EX gpac -i list.m3u:sigcues -o res/live.mpd\\n\"\n\"This will load the `flist` filter in cue mode, generating continuous timelines from the sources and injecting a `CueStart` property at each new file.\\n\"\n\"\\n\"\n\"If the [-cues]() option equals `none`, the `DashCue` property of input PIDs will be ignored.\\n\"\n\"\\n\"\n\"## Manifest Generation only mode\\n\"\n\"The segmenter can be used to generate manifests from already fragmented ISOBMFF inputs using [-sigfrag]().\\n\"\n\"In this case, segment boundaries are attached to each packet starting a segment and used to drive the segmentation.\\n\"\n\"This can be used with single-track ISOBMFF sources, either single file or multi file.\\n\"\n\"For single file source:\\n\"\n\"- if onDemand [-profile]() is requested, sources have to be formatted as a DASH self-initializing media segment with the proper sidx.\\n\"\n\"- templates are disabled.\\n\"\n\"- [-sseg]() is forced for all profiles except onDemand ones.\\n\"\n\"For multi files source:\\n\"\n\"- input shall be a playlist containing the initial file followed by the ordered list of segments.\\n\"\n\"- if no [-template]() is provided, the full or main [-profile]() will be used\\n\"\n\"- if [-template]() is provided, it shall be correct: the filter will not try to guess one from the input file names and will not validate it either.\\n\"\n\"\\n\"\n\"The manifest generation-only mode supports both MPD and HLS generation.\\n\"\n\"\\n\"\n\"EX gpac -i ondemand_src.mp4 -o dash.mpd:sigfrag:profile=onDemand\\n\"\n\"This will generate a DASH manifest for onDemand Profile based on the input file.\\n\"\n\"EX gpac -i ondemand_src.mp4 -o dash.m3u8:sigfrag\\n\"\n\"This will generate a HLS manifest based on the input file.\\n\"\n\"EX gpac -i seglist.txt -o dash.mpd:sigfrag\\n\"\n\"This will generate a DASH manifest in Main Profile based on the input files.\\n\"\n\"EX gpac -i seglist.txt:Template=$XInit=init$$q1/$Number$ -o dash.mpd:sigfrag:profile=live\\n\"\n\"This will generate a DASH manifest in live Profile based on the input files. The input file will contain `init.mp4`, `q1/1.m4s`, `q1/2.m4s`...\\n\"\n\"\\n\"\n\"## Cue Generation only mode\\n\"\n\"The segmenter can be used to only generate segment boundaries from a set of inputs using [-gencues](), without generating manifests or output files.\\n\"\n\"In this mode, output PIDs are declared directly rather than redirected to media segment files.\\n\"\n\"The segmentation logic is not changed, and packets are forwarded with the same information and timing as in regular mode.\\n\"\n\"\\n\"\n\"Output PIDs are forwarded with `DashCue=inband` property, so that any subsequent dasher follows the same segmentation process (see above).\\n\"\n\"\\n\"\n\"The first packet in a segment has:\\n\"\n\"- property `FileNumber` (and, if multiple files, `FileName`) set as usual\\n\"\n\"- property `CueStart` set\\n\"\n\"- property `DFPStart=0` set if this is the first packet in a period\\n\"\n\"\\n\"\n\"This mode can be used to pre-segment the streams for later processing that must take place before final dashing.\\n\"\n\"EX gpac -i source.mp4 dasher:gencues cecrypt:cfile=roll_seg.xml -o live.mpd\\n\"\n\"This will allow the encrypter to locate dash boundaries and roll keys at segment boundaries.\\n\"\n\"EX gpac -i s1.mp4 -i s2.mp4:#CryptInfo=clear:#Period=3 -i s3.mp4:#Period=3 dasher:gencues cecrypt:cfile=roll_period.xml -o live.mpd\\n\"\n\"If the DRM file uses `keyRoll=period`, this will generate:\\n\"\n\"- first period crypted with one key\\n\"\n\"- second period clear\\n\"\n\"- third period crypted with another key\\n\"\n\"\\n\"\n\"## Forced-Template mode\\n\"\n\"When [-tpl_force]() is set, the [-template]() string is not analyzed nor modified for missing elements.\\n\"\n\"This is typically used to redirect segments to a given destination regardless of the dash profile.\\n\"\n\"EX gpac -i SRC -o null:ext=mpd:tpl_force --template=pipe://mypipe\\n\"\n\"This will trash the manifest and open `mypipe` as destination for the muxer result.\\n\"\n\"Warning: Options for segment destination cannot be set through the [-template](), global options must be used.\\n\"\n\"\\n\"\n\"## Multiplexer development considerations\\n\"\n\"Output multiplexers allowing segmented output must obey the following:\\n\"\n\"- inspect packet properties\\n\"\n\" - FileNumber: if set, indicate the start of a new DASH segment\\n\"\n\" - FileName: if set, indicate the file name. If not present, output shall be a single file. This is only set for packet carrying the `FileNumber` property, and only on one PID (usually the first) for multiplexed outputs\\n\"\n\" - IDXName: gives the optional index name. If not present, index shall be in the same file as dash segment. Only used for MPEG-2 TS for now\\n\"\n\" - EODS: property is set on packets with no payload and no timestamp to signal the end of a DASH segment. This is only used when stopping/resuming the segmentation process, in order to flush segments without dispatching an EOS (see [-subdur]() )\\n\"\n\"- for each segment done, send a downstream event on the first connected PID signaling the size of the segment and the size of its index if any\\n\"\n\"- for multiplexers with init data, send a downstream event signaling the size of the init and the size of the global index if any\\n\"\n\"- the following filter options are passed to multiplexers, which should declare them as arguments:\\n\"\n\" - noinit: disables output of init segment for the multiplexer (used to handle bitstream switching with single init in DASH)\\n\"\n\" - frag: indicates multiplexer shall use fragmented format (used for ISOBMFF mostly)\\n\"\n\" - subs_sidx=0: indicates an SIDX shall be generated - only added if not already specified by user\\n\"\n\" - xps_inband=all|no|both: indicates AVC/HEVC/... parameter sets shall be sent inband, out of band, or both\\n\"\n\" - nofragdef: indicates fragment defaults should be set in each segment rather than in init segment\\n\"\n\"\\n\"\n\"The segmenter adds the following properties to the output PIDs:\\n\"\n\"- DashMode: identifies VoD (single file with global index) or regular DASH mode used by segmenter\\n\"\n\"- DashDur: identifies target DASH segment duration - this can be used to estimate the SIDX size for example\\n\"\n\"- LLHLS: identifies LLHLS is used; the multiplexer must send fragment size events back to the dasher, and set `LLHLSFragNum` on the first packet of each fragment\\n\"\n\"- SegSync: indicates that fragments/segments must be completely flushed before sending back size events\\n\"\n\t\t\t)\n\t.private_size = sizeof(GF_DasherCtx),\n\t.args = DasherArgs,\n\t.initialize = dasher_initialize,\n\t.finalize = dasher_finalize,\n\tSETCAPS(DasherCaps),\n\t.flags = GF_FS_REG_REQUIRES_RESOLVER,\n\t.configure_pid = dasher_configure_pid,\n\t.process = dasher_process,\n\t.process_event = dasher_process_event,\n};\n\n\nconst GF_FilterRegister *dasher_register(GF_FilterSession *session)\n{\n\treturn &DasherRegister;\n}\n#else\nconst GF_FilterRegister *dasher_register(GF_FilterSession *session)\n{\n\treturn NULL;\n}\n#endif // GPAC_DISABLE_DASHER\n", "/*\n *  avilib.c\n *\n *  Copyright (C) Thomas ostreich - June 2001\n *  multiple audio track support Copyright (C) 2002 Thomas ostreich\n *\n *  Original code:\n *  Copyright (C) 1999 Rainer Johanni <Rainer@Johanni.de>\n *\n *  This file is part of transcode, a linux video stream processing tool\n *\n *  transcode is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  transcode is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License aint with this library; see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n#include <gpac/setup.h>\n\n#ifndef GPAC_DISABLE_AVILIB\n\n#include <gpac/internal/avilib.h>\n\n\n#define INFO_LIST\n\n// add a new riff chunk after XX MB\n#define NEW_RIFF_THRES (1900*1024*1024)\n\n// Maximum number of indices per stream\n#define NR_IXNN_CHUNKS 96\n\n\n#define DEBUG_ODML\n#undef DEBUG_ODML\n\n/* The following variable indicates the kind of error */\n\nint AVI_errno = 0;\n\n#define MAX_INFO_STRLEN 64\nstatic char id_str[MAX_INFO_STRLEN];\n\n#define FRAME_RATE_SCALE 1000000\n\n/*******************************************************************\n *                                                                 *\n *    Utilities for writing an AVI File                            *\n *                                                                 *\n *******************************************************************/\n\nstatic u32 avi_read(FILE *fd, char *buf, u32 len)\n{\n\tu32 r = 0;\n\n\twhile (r < len) {\n\t\ts32 n = (s32) gf_fread(buf + r, len - r, fd);\n\t\tif (n == 0) break;\n\t\tif (n < 0) return r;\n\t\tr += n;\n\t}\n\n\treturn r;\n}\n\nstatic u32 avi_write (FILE *fd, char *buf, u32 len)\n{\n\tu32 r = 0;\n\n\twhile (r < len) {\n\t\ts32 n = (u32) gf_fwrite (buf + r, len - r, fd);\n\t\tif (n < 0)\n\t\t\treturn n;\n\n\t\tr += n;\n\t}\n\treturn r;\n}\n\n/* HEADERBYTES: The number of bytes to reserve for the header */\n\n#define HEADERBYTES 2048\n\n/* AVI_MAX_LEN: The maximum length of an AVI file, we stay a bit below\n    the 2GB limit (Remember: 2*10^9 is smaller than 2 GB) */\n\n#define AVI_MAX_LEN (UINT_MAX-(1<<20)*16-HEADERBYTES)\n\n#define PAD_EVEN(x) ( ((x)+1) & ~1 )\n\n\n/* Copy n into dst as a 4 or 2 byte, little endian number.\n   Should also work on big endian machines */\n\nstatic void long2str(unsigned char *dst, s32 n)\n{\n\tdst[0] = (n    )&0xff;\n\tdst[1] = (n>> 8)&0xff;\n\tdst[2] = (n>>16)&0xff;\n\tdst[3] = (n>>24)&0xff;\n}\n\n#ifdef WORDS_BIGENDIAN\nstatic void short2str(unsigned char *dst, s32 n)\n{\n\tdst[0] = (n    )&0xff;\n\tdst[1] = (n>> 8)&0xff;\n}\n#endif\n\n/* Convert a string of 4 or 2 bytes to a number,\n   also working on big endian machines */\n\nstatic u64 str2ullong(unsigned char *str)\n{\n\tu64 r = ((u32)str[0] | ((u32)str[1]<<8) | ((u32)str[2]<<16) | ((u32)str[3]<<24));\n\tu64 s = ((u32)str[4] | ((u32)str[5]<<8) | ((u32)str[6]<<16) | ((u32)str[7]<<24));\n#ifdef __GNUC__\n\treturn ((s<<32)&0xffffffff00000000ULL)|(r&0xffffffff);\n#else\n\treturn ((s<<32)&0xffffffff00000000)|(r&0xffffffff);\n#endif\n}\n\nstatic u32 str2ulong(unsigned char *str)\n{\n\treturn ( (u32)str[0] | ((u32)str[1]<<8) | ((u32)str[2]<<16) | ((u32)str[3]<<24) );\n}\nstatic u32 str2ushort(unsigned char *str)\n{\n\treturn ( (u32)str[0] | ((u32)str[1]<<8) );\n}\n\n// bit 31 denotes a keyframe\nstatic u32 str2ulong_len (unsigned char *str)\n{\n\treturn str2ulong(str) & 0x7fffffff;\n}\n\n\n// if bit 31 is 0, its a keyframe\nstatic u32 str2ulong_key (unsigned char *str)\n{\n\tu32 c = str2ulong(str);\n\tc &= 0x80000000;\n\tif (c == 0) return 0x10;\n\telse return 0;\n}\n\n/* Calculate audio sample size from number of bits and number of channels.\n   This may have to be adjusted for eg. 12 bits and stereo */\n\nstatic int avi_sampsize(avi_t *AVI, int j)\n{\n\tint s;\n\ts = ((AVI->track[j].a_bits+7)/8)*AVI->track[j].a_chans;\n\t//   if(s==0) s=1; /* avoid possible zero divisions */\n\tif(s<4) s=4; /* avoid possible zero divisions */\n\treturn s;\n}\n\n/* Add a chunk (=tag and data) to the AVI file,\n   returns -1 on write error, 0 on success */\n\nstatic int avi_add_chunk(avi_t *AVI, unsigned char *tag, unsigned char *data, u32 length)\n{\n\tunsigned char c[8];\n\tchar p=0;\n\n\t/* Copy tag and length int c, so that we need only 1 write system call\n\t   for these two values */\n\n\tmemcpy(c,tag,4);\n\tlong2str(c+4,length);\n\n\t/* Output tag, length and data, restore previous position\n\t   if the write fails */\n\n\tif( avi_write(AVI->fdes,(char *)c,8) != 8 ||\n\t        avi_write(AVI->fdes,(char *)data,length) != length ||\n\t        avi_write(AVI->fdes,&p,length&1) != (length&1)) // if len is uneven, write a pad byte\n\t{\n\t\tgf_fseek(AVI->fdes,AVI->pos,SEEK_SET);\n\t\tAVI_errno = AVI_ERR_WRITE;\n\t\treturn -1;\n\t}\n\n\t/* Update file position */\n\n\tAVI->pos += 8 + PAD_EVEN(length);\n\n\t//GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] pos=%lu %s\\n\", AVI->pos, tag));\n\n\treturn 0;\n}\n\n#define OUTD(n) long2str((unsigned char*) (ix00+bl),(s32)n); bl+=4\n#define OUTW(n) ix00[bl] = (n)&0xff; ix00[bl+1] = (n>>8)&0xff; bl+=2\n#define OUTC(n) ix00[bl] = (n)&0xff; bl+=1\n#define OUTS(s) memcpy(ix00+bl,s,4); bl+=4\n\n// this does the physical writeout of the ix## structure\nstatic int avi_ixnn_entry(avi_t *AVI, avistdindex_chunk *ch, avisuperindex_entry *en)\n{\n\tint bl;\n\tu32 k;\n\tunsigned int max = ch->nEntriesInUse * sizeof (u32) * ch->wLongsPerEntry + 24; // header\n\tchar *ix00 = (char *)gf_malloc (max);\n\tchar dfcc[5];\n\tmemcpy (dfcc, ch->fcc, 4);\n\tdfcc[4] = 0;\n\n\tbl = 0;\n\n\tif (en) {\n\t\ten->qwOffset = AVI->pos;\n\t\ten->dwSize = max;\n\t\t//en->dwDuration = ch->nEntriesInUse -1; // NUMBER OF stream ticks == frames for video/samples for audio\n\t}\n\n#ifdef DEBUG_ODML\n\t//GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] ODML Write %s: Entries %ld size %d \\n\", dfcc, ch->nEntriesInUse, max));\n#endif\n\n\t//OUTS(ch->fcc);\n\t//OUTD(max);\n\tOUTW(ch->wLongsPerEntry);\n\tOUTC(ch->bIndexSubType);\n\tOUTC(ch->bIndexType);\n\tOUTD(ch->nEntriesInUse);\n\tOUTS(ch->dwChunkId);\n\tOUTD(ch->qwBaseOffset&0xffffffff);\n\tOUTD((ch->qwBaseOffset>>32)&0xffffffff);\n\tOUTD(ch->dwReserved3);\n\n\tfor (k = 0; k < ch->nEntriesInUse; k++) {\n\t\tOUTD(ch->aIndex[k].dwOffset);\n\t\tOUTD(ch->aIndex[k].dwSize);\n\n\t}\n\tavi_add_chunk (AVI, (unsigned char*)ch->fcc, (unsigned char*)ix00, max);\n\n\tgf_free(ix00);\n\n\treturn 0;\n}\n#undef OUTS\n#undef OUTW\n#undef OUTD\n#undef OUTC\n\n// inits a super index structure including its enclosed stdindex\nstatic int avi_init_super_index(avi_t *AVI, unsigned char *idxtag, avisuperindex_chunk **si)\n{\n\tint k;\n\n\tavisuperindex_chunk *sil = NULL;\n\n\tif ((sil = (avisuperindex_chunk *) gf_malloc (sizeof (avisuperindex_chunk))) == NULL) {\n\t\tAVI_errno = AVI_ERR_NO_MEM;\n\t\treturn -1;\n\t}\n\tmemcpy (sil->fcc, \"indx\", 4);\n\tsil->dwSize = 0; // size of this chunk\n\tsil->wLongsPerEntry = 4;\n\tsil->bIndexSubType = 0;\n\tsil->bIndexType = AVI_INDEX_OF_INDEXES;\n\tsil->nEntriesInUse = 0; // none are in use\n\tmemcpy (sil->dwChunkId, idxtag, 4);\n\tmemset (sil->dwReserved, 0, sizeof (sil->dwReserved));\n\n\t// NR_IXNN_CHUNKS == allow 32 indices which means 32 GB files -- arbitrary\n\tsil->aIndex = (avisuperindex_entry *) gf_malloc (sil->wLongsPerEntry * NR_IXNN_CHUNKS * sizeof (void*));\n\tif (!sil->aIndex) {\n\t\tAVI_errno = AVI_ERR_NO_MEM;\n\t\treturn -1;\n\t}\n\tmemset (sil->aIndex, 0, sil->wLongsPerEntry * NR_IXNN_CHUNKS * sizeof (u32));\n\n\tsil->stdindex = (avistdindex_chunk **)gf_malloc (NR_IXNN_CHUNKS * sizeof (avistdindex_chunk *));\n\tif (!sil->stdindex) {\n\t\tAVI_errno = AVI_ERR_NO_MEM;\n\t\treturn -1;\n\t}\n\tfor (k = 0; k < NR_IXNN_CHUNKS; k++) {\n\t\tsil->stdindex[k] = (avistdindex_chunk *) gf_malloc (sizeof (avistdindex_chunk));\n\t\t// gets rewritten later\n\t\tsil->stdindex[k]->qwBaseOffset = (u64)k * AVI->new_riff_threshold;\n\t\tsil->stdindex[k]->aIndex = NULL;\n\t}\n\n\t*si = sil;\n\n\treturn 0;\n}\n\n// fills an alloc'ed stdindex structure and mallocs some entries for the actual chunks\nstatic int avi_add_std_index(avi_t *AVI, unsigned char *idxtag, unsigned char *strtag,\n                             avistdindex_chunk *stdil)\n{\n\n\tmemcpy (stdil->fcc, idxtag, 4);\n\tstdil->dwSize = 4096;\n\tstdil->wLongsPerEntry = 2; //sizeof(avistdindex_entry)/sizeof(u32);\n\tstdil->bIndexSubType = 0;\n\tstdil->bIndexType = AVI_INDEX_OF_CHUNKS;\n\tstdil->nEntriesInUse = 0;\n\n\t// cp 00db ChunkId\n\tmemcpy(stdil->dwChunkId, strtag, 4);\n\n\t//stdil->qwBaseOffset = AVI->video_superindex->aIndex[ cur_std_idx ]->qwOffset;\n\n\tstdil->aIndex = (avistdindex_entry *)gf_malloc(stdil->dwSize * sizeof (u32) * stdil->wLongsPerEntry);\n\n\tif (!stdil->aIndex) {\n\t\tAVI_errno = AVI_ERR_NO_MEM;\n\t\treturn -1;\n\t}\n\n\n\treturn 0;\n}\n\nstatic int avi_add_odml_index_entry_core(avi_t *AVI, int flags, u64 pos, unsigned int len, avistdindex_chunk *si)\n{\n\tu32 cur_chunk_idx;\n\t// put new chunk into index\n\tsi->nEntriesInUse++;\n\tcur_chunk_idx = si->nEntriesInUse-1;\n\n\t// need to fetch more memory\n\tif (cur_chunk_idx >= si->dwSize) {\n\t\tsi->dwSize += 4096;\n\t\tsi->aIndex = (avistdindex_entry *)gf_realloc ( si->aIndex, si->dwSize * sizeof (u32) * si->wLongsPerEntry);\n\t}\n\n\tif(len>AVI->max_len) AVI->max_len=len;\n\n\t// if bit 31 is set, it is NOT a keyframe\n\tif (flags != 0x10) {\n\t\tlen |= 0x80000000;\n\t}\n\n\tsi->aIndex [ cur_chunk_idx ].dwSize = len;\n\tsi->aIndex [ cur_chunk_idx ].dwOffset = (u32) (pos - si->qwBaseOffset + 8);\n\n\t//GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] ODML: POS: 0x%lX\\n\", si->aIndex [ cur_chunk_idx ].dwOffset));\n\n\treturn 0;\n}\n\nstatic int avi_add_odml_index_entry(avi_t *AVI, unsigned char *tag, int flags, u64 pos, unsigned int len)\n{\n\tchar fcc[5];\n\n\tint audio = (strchr ((char*)tag, 'w')?1:0);\n\tint video = !audio;\n\n\tunsigned int cur_std_idx;\n\tu32 audtr;\n\ts64 towrite = 0;\n\n\tif (video) {\n\n\t\tif (!AVI->video_superindex) {\n\t\t\tif (avi_init_super_index(AVI, (unsigned char *)\"ix00\", &AVI->video_superindex) < 0) return -1;\n\t\t\tAVI->video_superindex->nEntriesInUse++;\n\t\t\tcur_std_idx = AVI->video_superindex->nEntriesInUse-1;\n\n\t\t\tif (avi_add_std_index (AVI, (unsigned char *)\"ix00\", (unsigned char *)\"00db\", AVI->video_superindex->stdindex[ cur_std_idx ]) < 0)\n\t\t\t\treturn -1;\n\t\t} // init\n\n\t} // video\n\n\tif (audio) {\n\n\t\tfcc[0] = 'i';\n\t\tfcc[1] = 'x';\n\t\tfcc[2] = tag[0];\n\t\tfcc[3] = tag[1];\n\t\tfcc[4] = '\\0';\n\t\tif (!AVI->track[AVI->aptr].audio_superindex) {\n\n#ifdef DEBUG_ODML\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] ODML: fcc = %s\\n\", fcc));\n#endif\n\t\t\tif (avi_init_super_index(AVI, (unsigned char *)fcc, &AVI->track[AVI->aptr].audio_superindex) < 0) return -1;\n\n\n\t\t\tAVI->track[AVI->aptr].audio_superindex->nEntriesInUse++;\n\n\t\t\tsprintf(fcc, \"ix%02d\", AVI->aptr+1);\n\t\t\tif (avi_add_std_index (AVI, (unsigned char *)fcc, tag, AVI->track[AVI->aptr].audio_superindex->stdindex[\n\t\t\t                           AVI->track[AVI->aptr].audio_superindex->nEntriesInUse - 1 ]) < 0\n\t\t\t   ) return -1;\n\t\t} // init\n\n\t}\n\n\ttowrite = 0;\n\tif (AVI->video_superindex) {\n\n\t\tcur_std_idx = AVI->video_superindex->nEntriesInUse-1;\n\t\ttowrite += AVI->video_superindex->stdindex[cur_std_idx]->nEntriesInUse*8\n\t\t           + 4+4+2+1+1+4+4+8+4;\n\t\tif (cur_std_idx == 0) {\n\t\t\ttowrite += AVI->n_idx*16 + 8;\n\t\t\ttowrite += HEADERBYTES;\n\t\t}\n\t}\n\n\tfor (audtr=0; audtr<AVI->anum; audtr++) {\n\t\tif (AVI->track[audtr].audio_superindex) {\n\t\t\tcur_std_idx = AVI->track[audtr].audio_superindex->nEntriesInUse-1;\n\t\t\ttowrite += AVI->track[audtr].audio_superindex->stdindex[cur_std_idx]->nEntriesInUse*8\n\t\t\t           + 4+4+2+1+1+4+4+8+4;\n\t\t}\n\t}\n\ttowrite += len + (len&1) + 8;\n\n\t//GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] ODML: towrite = 0x%llX = %\"LLD\"\\n\", towrite, towrite));\n\n\tif (AVI->video_superindex &&\n\t        (s64)(AVI->pos+towrite) > (s64)((s64) AVI->new_riff_threshold*AVI->video_superindex->nEntriesInUse)) {\n\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] Adding a new RIFF chunk: %d\\n\", AVI->video_superindex->nEntriesInUse));\n\n\t\t// rotate ALL indices\n\t\tAVI->video_superindex->nEntriesInUse++;\n\t\tcur_std_idx = AVI->video_superindex->nEntriesInUse-1;\n\n\t\tif (AVI->video_superindex->nEntriesInUse > NR_IXNN_CHUNKS) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[avilib] Internal error in avilib - redefine NR_IXNN_CHUNKS\\n\"));\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] cur_std_idx=%d NR_IXNN_CHUNKS=%d\"\n\t\t\t                                        \"POS=%\"LLD\" towrite=%\"LLD\"\\n\",\n\t\t\t                                        cur_std_idx,NR_IXNN_CHUNKS, AVI->pos, towrite));\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (avi_add_std_index (AVI, (unsigned char *)\"ix00\", (unsigned char *)\"00db\", AVI->video_superindex->stdindex[ cur_std_idx ]) < 0)\n\t\t\treturn -1;\n\n\t\tfor (audtr = 0; audtr < AVI->anum; audtr++) {\n\t\t\tchar aud[5];\n\t\t\tif (!AVI->track[audtr].audio_superindex) {\n\t\t\t\t// not initialized -> no index\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tAVI->track[audtr].audio_superindex->nEntriesInUse++;\n\n\t\t\tsprintf(fcc, \"ix%02d\", audtr+1);\n\t\t\tsprintf(aud, \"0%01dwb\", audtr+1);\n\t\t\tif (avi_add_std_index (AVI, (unsigned char *)fcc, (unsigned char *)aud, AVI->track[audtr].audio_superindex->stdindex[\n\t\t\t                           AVI->track[audtr].audio_superindex->nEntriesInUse - 1 ]) < 0\n\t\t\t   ) return -1;\n\t\t}\n\n\t\t// write the new riff;\n\t\tif (cur_std_idx > 0) {\n\n\t\t\t// dump the _previous_ == already finished index\n\t\t\tavi_ixnn_entry (AVI, AVI->video_superindex->stdindex[cur_std_idx - 1],\n\t\t\t                &AVI->video_superindex->aIndex[cur_std_idx - 1]);\n\t\t\tAVI->video_superindex->aIndex[cur_std_idx - 1].dwDuration =\n\t\t\t    AVI->video_superindex->stdindex[cur_std_idx - 1]->nEntriesInUse - 1;\n\n\t\t\tfor (audtr = 0; audtr < AVI->anum; audtr++) {\n\n\t\t\t\tif (!AVI->track[audtr].audio_superindex) {\n\t\t\t\t\t// not initialized -> no index\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tavi_ixnn_entry (AVI, AVI->track[audtr].audio_superindex->stdindex[cur_std_idx - 1],\n\t\t\t\t                &AVI->track[audtr].audio_superindex->aIndex[cur_std_idx - 1]);\n\n\t\t\t\tAVI->track[audtr].audio_superindex->aIndex[cur_std_idx - 1].dwDuration =\n\t\t\t\t    AVI->track[audtr].audio_superindex->stdindex[cur_std_idx - 1]->nEntriesInUse - 1;\n\t\t\t\tif (AVI->track[audtr].a_fmt == 0x1) {\n\t\t\t\t\tAVI->track[audtr].audio_superindex->aIndex[cur_std_idx - 1].dwDuration *=\n\t\t\t\t\t    AVI->track[audtr].a_bits*AVI->track[audtr].a_rate*AVI->track[audtr].a_chans/800;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// XXX: dump idx1 structure\n\t\t\tif (cur_std_idx == 1) {\n\t\t\t\tavi_add_chunk(AVI, (unsigned char *)\"idx1\", (unsigned char *)AVI->idx, AVI->n_idx*16);\n\t\t\t\t// qwBaseOffset will contain the start of the second riff chunk\n\t\t\t}\n\t\t\t// Fix the Offsets later at closing time\n\t\t\tavi_add_chunk(AVI, (unsigned char *)\"RIFF\", (unsigned char *)\"AVIXLIST\\0\\0\\0\\0movi\", 16);\n\n\t\t\tAVI->video_superindex->stdindex[ cur_std_idx ]->qwBaseOffset = AVI->pos -16 -8;\n#ifdef DEBUG_ODML\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] ODML: RIFF No.%02d at Offset 0x%llX\\n\", cur_std_idx, AVI->pos -16 -8));\n#endif\n\n\t\t\tfor (audtr = 0; audtr < AVI->anum; audtr++) {\n\t\t\t\tif (AVI->track[audtr].audio_superindex)\n\t\t\t\t\tAVI->track[audtr].audio_superindex->stdindex[ cur_std_idx ]->qwBaseOffset =\n\t\t\t\t\t    AVI->pos -16 -8;\n\n\t\t\t}\n\n\t\t\t// now we can be sure\n\t\t\tAVI->is_opendml++;\n\t\t}\n\n\t}\n\n\n\tif (video) {\n\t\tavi_add_odml_index_entry_core(AVI, flags, AVI->pos, len,\n\t\t                              AVI->video_superindex->stdindex[ AVI->video_superindex->nEntriesInUse-1 ]);\n\n\t\tAVI->total_frames++;\n\t} // video\n\n\tif (audio) {\n\t\tavi_add_odml_index_entry_core(AVI, flags, AVI->pos, len,\n\t\t                              AVI->track[AVI->aptr].audio_superindex->stdindex[\n\t\t                                  AVI->track[AVI->aptr].audio_superindex->nEntriesInUse-1 ]);\n\t}\n\n\n\treturn 0;\n}\n\n// #undef NR_IXNN_CHUNKS\n\nstatic int avi_add_index_entry(avi_t *AVI, unsigned char *tag, int flags, u64 pos, u64 len)\n{\n\tif(AVI->n_idx>=AVI->max_idx) {\n\t\tvoid *ptr = gf_realloc((void *)AVI->idx,(AVI->max_idx+4096)*16);\n\n\t\tif(ptr == 0) {\n\t\t\tAVI_errno = AVI_ERR_NO_MEM;\n\t\t\treturn -1;\n\t\t}\n\t\tAVI->max_idx += 4096;\n\t\tAVI->idx = (unsigned char((*)[16]) ) ptr;\n\t}\n\n\t/* Add index entry */\n\n\t//   GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] INDEX %s %ld %lu %lu\\n\", tag, flags, pos, len));\n\n\tmemcpy(AVI->idx[AVI->n_idx],tag,4);\n\tlong2str(AVI->idx[AVI->n_idx]+ 4,flags);\n\tlong2str(AVI->idx[AVI->n_idx]+ 8, (s32) pos);\n\tlong2str(AVI->idx[AVI->n_idx]+12, (s32) len);\n\n\t/* Update counter */\n\n\tAVI->n_idx++;\n\n\tif(len>AVI->max_len) AVI->max_len=(u32) len;\n\n\treturn 0;\n}\n\n#if 0\n/* Returns 1 if more audio is in that video junk */\nint AVI_can_read_audio(avi_t *AVI)\n{\n\tif(AVI->mode==AVI_MODE_WRITE) {\n\t\treturn -1;\n\t}\n\tif(!AVI->video_index)         {\n\t\treturn -1;\n\t}\n\tif(!AVI->track[AVI->aptr].audio_index)         {\n\t\treturn -1;\n\t}\n\n\t// is it -1? the last ones got left out --tibit\n\t//if (AVI->track[AVI->aptr].audio_posc>=AVI->track[AVI->aptr].audio_chunks-1) {\n\tif (AVI->track[AVI->aptr].audio_posc>=AVI->track[AVI->aptr].audio_chunks) {\n\t\treturn 0;\n\t}\n\n\tif (AVI->video_pos >= AVI->video_frames) return 1;\n\n\tif (AVI->track[AVI->aptr].audio_index[AVI->track[AVI->aptr].audio_posc].pos < AVI->video_index[AVI->video_pos].pos) return 1;\n\telse return 0;\n}\n#endif\n\n/*\n   AVI_open_output_file: Open an AVI File and write a bunch\n                         of zero bytes as space for the header.\n\n   returns a pointer to avi_t on success, a zero pointer on error\n*/\n\nGF_EXPORT\navi_t* AVI_open_output_file(char * filename, u64 opendml_threshold)\n{\n\tavi_t *AVI;\n\tint i;\n\n\tunsigned char AVI_header[HEADERBYTES];\n\n\t/* Allocate the avi_t struct and zero it */\n\n\tAVI = (avi_t *) gf_malloc(sizeof(avi_t));\n\tif(AVI==0)\n\t{\n\t\tAVI_errno = AVI_ERR_NO_MEM;\n\t\treturn 0;\n\t}\n\tmemset((void *)AVI,0,sizeof(avi_t));\n\n\tAVI->fdes = gf_fopen(filename, \"w+b\");\n\tif (!AVI->fdes )\n\t{\n\t\tAVI_errno = AVI_ERR_OPEN;\n\t\tgf_free(AVI);\n\t\treturn 0;\n\t}\n\n\t/* Write out HEADERBYTES bytes, the header will go here\n\t   when we are finished with writing */\n\n\tfor (i=0; i<HEADERBYTES; i++) AVI_header[i] = 0;\n\ti = avi_write(AVI->fdes,(char *)AVI_header,HEADERBYTES);\n\tif (i != HEADERBYTES)\n\t{\n\t\tgf_fclose(AVI->fdes);\n\t\tAVI_errno = AVI_ERR_WRITE;\n\t\tgf_free(AVI);\n\t\treturn 0;\n\t}\n\n\tAVI->pos  = HEADERBYTES;\n\tAVI->mode = AVI_MODE_WRITE; /* open for writing */\n\tif (opendml_threshold)\n\t\tAVI->new_riff_threshold = opendml_threshold;\n\telse\n\t\tAVI->new_riff_threshold = (1900*1024*1024);\n\n\t//init\n\tAVI->anum = 0;\n\tAVI->aptr = 0;\n\n\treturn AVI;\n}\n\nGF_EXPORT\nvoid AVI_set_video(avi_t *AVI, int width, int height, double fps, char *compressor)\n{\n\t/* may only be called if file is open for writing */\n\n\tif(AVI->mode==AVI_MODE_READ) return;\n\n\tAVI->width  = width;\n\tAVI->height = height;\n\tAVI->fps    = fps;\n\n\tif(strncmp(compressor, \"RGB\", 3)==0) {\n\t\tmemset(AVI->compressor, 0, 4);\n\t} else {\n\t\tmemcpy(AVI->compressor,compressor,4);\n\t}\n\n\tAVI->compressor[4] = 0;\n\n\tavi_update_header(AVI);\n}\n\nGF_EXPORT\nvoid AVI_set_audio(avi_t *AVI, int channels, int rate, int bits, int format, int mp3rate)\n{\n\t/* may only be called if file is open for writing */\n\n\tif(AVI->mode==AVI_MODE_READ) return;\n\n\t//inc audio tracks\n\tAVI->aptr=AVI->anum;\n\t++AVI->anum;\n\n\tif(AVI->anum > AVI_MAX_TRACKS) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[avilib] error - only %d audio tracks supported\\n\", AVI_MAX_TRACKS));\n\t\texit(1);\n\t}\n\n\tAVI->track[AVI->aptr].a_chans = channels;\n\tAVI->track[AVI->aptr].a_rate  = rate;\n\tAVI->track[AVI->aptr].a_bits  = bits;\n\tAVI->track[AVI->aptr].a_fmt   = format;\n\tAVI->track[AVI->aptr].mp3rate = mp3rate;\n\n\tavi_update_header(AVI);\n}\n\n#define OUT4CC(s) \\\n   if(nhb<=HEADERBYTES-4) memcpy(AVI_header+nhb,s,4); \\\n   nhb += 4\n\n#define OUTLONG(n) \\\n   if(nhb<=HEADERBYTES-4) long2str(AVI_header+nhb, (s32)(n)); \\\n   nhb += 4\n\n#define OUTSHRT(n) \\\n   if(nhb<=HEADERBYTES-2) { \\\n      AVI_header[nhb  ] = (u8) ((n   )&0xff); \\\n      AVI_header[nhb+1] = (u8) ((n>>8)&0xff); \\\n   } \\\n   nhb += 2\n\n#define OUTCHR(n) \\\n   if(nhb<=HEADERBYTES-1) { \\\n      AVI_header[nhb  ] = (n   )&0xff; \\\n   } \\\n   nhb += 1\n\n#define OUTMEM(d, s) \\\n   { \\\n     u32 s_ = (u32) (s); \\\n     if(nhb + s_ <= HEADERBYTES) \\\n        memcpy(AVI_header+nhb, (d), s_); \\\n     nhb += s_; \\\n   }\n\n\n//ThOe write preliminary AVI file header: 0 frames, max vid/aud size\nint avi_update_header(avi_t *AVI)\n{\n\tint njunk, ms_per_frame, frate, flag;\n\tint movi_len, hdrl_start, strl_start;\n\tu32 j;\n\tunsigned char AVI_header[HEADERBYTES];\n\tu32 nhb;\n\tunsigned int xd_size, xd_size_align2;\n\n\t//assume max size\n\tmovi_len = AVI_MAX_LEN - HEADERBYTES + 4;\n\n\t//assume index will be written\n//\tint hasIndex=1;\n\n\tif(AVI->fps < 0.001) {\n\t\tfrate=0;\n\t\tms_per_frame=0;\n\t} else {\n\t\tfrate = (int) (FRAME_RATE_SCALE*AVI->fps + 0.5);\n\t\tms_per_frame=(int) (1000000/AVI->fps + 0.5);\n\t}\n\n\t/* Prepare the file header */\n\n\tnhb = 0;\n\n\t/* The RIFF header */\n\n\tOUT4CC (\"RIFF\");\n\tOUTLONG(movi_len);    // assume max size\n\tOUT4CC (\"AVI \");\n\n\t/* Start the header list */\n\n\tOUT4CC (\"LIST\");\n\tOUTLONG(0);        /* Length of list in bytes, don't know yet */\n\thdrl_start = nhb;  /* Store start position */\n\tOUT4CC (\"hdrl\");\n\n\t/* The main AVI header */\n\n\t/* The Flags in AVI File header */\n\n#define AVIF_HASINDEX           0x00000010      /* Index at end of file */\n#define AVIF_MUSTUSEINDEX       0x00000020\n#define AVIF_ISINTERLEAVED      0x00000100\n#define AVIF_TRUSTCKTYPE        0x00000800      /* Use CKType to find key frames */\n#define AVIF_WASCAPTUREFILE     0x00010000\n#define AVIF_COPYRIGHTED        0x00020000\n\n\tOUT4CC (\"avih\");\n\tOUTLONG(56);                 /* # of bytes to follow */\n\tOUTLONG(ms_per_frame);       /* Microseconds per frame */\n\t//ThOe ->0\n\t//   OUTLONG(10000000);           /* MaxBytesPerSec, I hope this will never be used */\n\tOUTLONG(0);\n\tOUTLONG(0);                  /* PaddingGranularity (whatever that might be) */\n\t/* Other sources call it 'reserved' */\n\tflag = AVIF_ISINTERLEAVED;\n\t//if (hasIndex)\n\t\tflag |= AVIF_HASINDEX;\n\tif (/*hasIndex && */AVI->must_use_index)\n\t\tflag |= AVIF_MUSTUSEINDEX;\n\tOUTLONG(flag);               /* Flags */\n\tOUTLONG(0);                  // no frames yet\n\tOUTLONG(0);                  /* InitialFrames */\n\n\tOUTLONG(AVI->anum+1);\n\n\tOUTLONG(0);                  /* SuggestedBufferSize */\n\tOUTLONG(AVI->width);         /* Width */\n\tOUTLONG(AVI->height);        /* Height */\n\t/* MS calls the following 'reserved': */\n\tOUTLONG(0);                  /* TimeScale:  Unit used to measure time */\n\tOUTLONG(0);                  /* DataRate:   Data rate of playback     */\n\tOUTLONG(0);                  /* StartTime:  Starting time of AVI data */\n\tOUTLONG(0);                  /* DataLength: Size of AVI data chunk    */\n\n\n\t/* Start the video stream list ---------------------------------- */\n\n\tOUT4CC (\"LIST\");\n\tOUTLONG(0);        /* Length of list in bytes, don't know yet */\n\tstrl_start = nhb;  /* Store start position */\n\tOUT4CC (\"strl\");\n\n\t/* The video stream header */\n\n\tOUT4CC (\"strh\");\n\tOUTLONG(56);                 /* # of bytes to follow */\n\tOUT4CC (\"vids\");             /* Type */\n\tOUT4CC (AVI->compressor);    /* Handler */\n\tOUTLONG(0);                  /* Flags */\n\tOUTLONG(0);                  /* Reserved, MS says: wPriority, wLanguage */\n\tOUTLONG(0);                  /* InitialFrames */\n\tOUTLONG(FRAME_RATE_SCALE);              /* Scale */\n\tOUTLONG(frate);              /* Rate: Rate/Scale == samples/second */\n\tOUTLONG(0);                  /* Start */\n\tOUTLONG(0);                  // no frames yet\n\tOUTLONG(0);                  /* SuggestedBufferSize */\n\tOUTLONG(-1);                 /* Quality */\n\tOUTLONG(0);                  /* SampleSize */\n\tOUTLONG(0);                  /* Frame */\n\tOUTLONG(0);                  /* Frame */\n\t//   OUTLONG(0);                  /* Frame */\n\t//OUTLONG(0);                  /* Frame */\n\n\t/* The video stream format */\n\n\txd_size        = AVI->extradata_size;\n\txd_size_align2 = (AVI->extradata_size+1) & ~1;\n\n\tOUT4CC (\"strf\");\n\tOUTLONG(40 + xd_size_align2);/* # of bytes to follow */\n\tOUTLONG(40 + xd_size);\t/* Size */\n\tOUTLONG(AVI->width);         /* Width */\n\tOUTLONG(AVI->height);        /* Height */\n\tOUTSHRT(1);\n\tOUTSHRT(24);     /* Planes, Count */\n\tOUT4CC (AVI->compressor);    /* Compression */\n\t// ThOe (*3)\n\tOUTLONG(AVI->width*AVI->height*3);  /* SizeImage (in bytes?) */\n\tOUTLONG(0);                  /* XPelsPerMeter */\n\tOUTLONG(0);                  /* YPelsPerMeter */\n\tOUTLONG(0);                  /* ClrUsed: Number of colors used */\n\tOUTLONG(0);                  /* ClrImportant: Number of colors important */\n\n\t// write extradata\n\tif (xd_size > 0 && AVI->extradata) {\n\t\tOUTMEM(AVI->extradata, xd_size);\n\t\tif (xd_size != xd_size_align2) {\n\t\t\tOUTCHR(0);\n\t\t}\n\t}\n\n\t/* Finish stream list, i.e. put number of bytes in the list to proper pos */\n\n\tlong2str(AVI_header+strl_start-4,nhb-strl_start);\n\n\n\t/* Start the audio stream list ---------------------------------- */\n\n\tfor(j=0; j<AVI->anum; ++j) {\n\t\tint sampsize = avi_sampsize(AVI, j);\n\n\t\tOUT4CC (\"LIST\");\n\t\tOUTLONG(0);        /* Length of list in bytes, don't know yet */\n\t\tstrl_start = nhb;  /* Store start position */\n\t\tOUT4CC (\"strl\");\n\n\t\t/* The audio stream header */\n\n\t\tOUT4CC (\"strh\");\n\t\tOUTLONG(56);            /* # of bytes to follow */\n\t\tOUT4CC (\"auds\");\n\n\t\t// -----------\n\t\t// ThOe\n\t\tOUTLONG(0);             /* Format (Optionally) */\n\t\t// -----------\n\n\t\tOUTLONG(0);             /* Flags */\n\t\tOUTLONG(0);             /* Reserved, MS says: wPriority, wLanguage */\n\t\tOUTLONG(0);             /* InitialFrames */\n\n\t\t// ThOe /4\n\t\tOUTLONG(sampsize/4);      /* Scale */\n\t\tOUTLONG(1000*AVI->track[j].mp3rate/8);\n\t\tOUTLONG(0);             /* Start */\n\t\tOUTLONG(4*AVI->track[j].audio_bytes/sampsize);   /* Length */\n\t\tOUTLONG(0);             /* SuggestedBufferSize */\n\t\tOUTLONG(-1);            /* Quality */\n\n\t\t// ThOe /4\n\t\tOUTLONG(sampsize/4);    /* SampleSize */\n\n\t\tOUTLONG(0);             /* Frame */\n\t\tOUTLONG(0);             /* Frame */\n\t\t//       OUTLONG(0);             /* Frame */\n\t\t//OUTLONG(0);             /* Frame */\n\n\t\t/* The audio stream format */\n\n\t\tOUT4CC (\"strf\");\n\t\tOUTLONG(16);                   /* # of bytes to follow */\n\t\tOUTSHRT(AVI->track[j].a_fmt);           /* Format */\n\t\tOUTSHRT(AVI->track[j].a_chans);         /* Number of channels */\n\t\tOUTLONG(AVI->track[j].a_rate);          /* SamplesPerSec */\n\t\t// ThOe\n\t\tOUTLONG(1000*AVI->track[j].mp3rate/8);\n\t\t//ThOe (/4)\n\n\t\tOUTSHRT(sampsize/4);           /* BlockAlign */\n\n\n\t\tOUTSHRT(AVI->track[j].a_bits);          /* BitsPerSample */\n\n\t\t/* Finish stream list, i.e. put number of bytes in the list to proper pos */\n\n\t\tlong2str(AVI_header+strl_start-4,nhb-strl_start);\n\t}\n\n\t/* Finish header list */\n\n\tlong2str(AVI_header+hdrl_start-4,nhb-hdrl_start);\n\n\n\t/* Calculate the needed amount of junk bytes, output junk */\n\n\tnjunk = HEADERBYTES - nhb - 8 - 12;\n\n\t/* Safety first: if njunk <= 0, somebody has played with\n\t   HEADERBYTES without knowing what (s)he did.\n\t   This is a fatal error */\n\n\tif(njunk<=0)\n\t{\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[avilib] AVI_close_output_file: # of header bytes too small\\n\"));\n\t\texit(1);\n\t}\n\n\tOUT4CC (\"JUNK\");\n\tOUTLONG(njunk);\n\tmemset(AVI_header+nhb,0,njunk);\n\n\tnhb += njunk;\n\n\t/* Start the movi list */\n\n\tOUT4CC (\"LIST\");\n\tOUTLONG(movi_len); /* Length of list in bytes */\n\tOUT4CC (\"movi\");\n\n\t/* Output the header, truncate the file to the number of bytes\n\t   actually written, report an error if someting goes wrong */\n\n\tif ( (gf_fseek(AVI->fdes, 0, SEEK_SET) ==(u64)-1) ||\n\t        avi_write(AVI->fdes,(char *)AVI_header,HEADERBYTES)!=HEADERBYTES ||\n\t        (gf_fseek(AVI->fdes,AVI->pos,SEEK_SET)==(u64)-1)\n\t   ) {\n\t\tAVI_errno = AVI_ERR_CLOSE;\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\n\n//SLM\n#ifndef S_IRUSR\n#define S_IRWXU       00700       /* read, write, execute: owner */\n#define S_IRUSR       00400       /* read permission: owner */\n#define S_IWUSR       00200       /* write permission: owner */\n#define S_IXUSR       00100       /* execute permission: owner */\n#define S_IRWXG       00070       /* read, write, execute: group */\n#define S_IRGRP       00040       /* read permission: group */\n#define S_IWGRP       00020       /* write permission: group */\n#define S_IXGRP       00010       /* execute permission: group */\n#define S_IRWXO       00007       /* read, write, execute: other */\n#define S_IROTH       00004       /* read permission: other */\n#define S_IWOTH       00002       /* write permission: other */\n#define S_IXOTH       00001       /* execute permission: other */\n#endif\n\n/*\n  Write the header of an AVI file and close it.\n  returns 0 on success, -1 on write error.\n*/\n\nstatic int avi_close_output_file(avi_t *AVI)\n{\n\tint njunk, hasIndex, ms_per_frame, frate, idxerror, flag;\n\tu64 movi_len;\n\tint hdrl_start, strl_start;\n\tu32 j;\n\tunsigned char AVI_header[HEADERBYTES];\n\tint nhb;\n\tunsigned int xd_size, xd_size_align2;\n\n#ifdef INFO_LIST\n\tint info_len;\n\tint id_len, real_id_len;\n\tint info_start_pos;\n//   time_t calptr;\n#endif\n\n\t/* Calculate length of movi list */\n\n\t// dump the rest of the index\n\tif (AVI->is_opendml) {\n\t\tint cur_std_idx = AVI->video_superindex->nEntriesInUse-1;\n\t\tu32 audtr;\n\n#ifdef DEBUG_ODML\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] ODML dump the rest indices\\n\"));\n#endif\n\t\tavi_ixnn_entry (AVI, AVI->video_superindex->stdindex[cur_std_idx],\n\t\t                &AVI->video_superindex->aIndex[cur_std_idx]);\n\n\t\tAVI->video_superindex->aIndex[cur_std_idx].dwDuration =\n\t\t    AVI->video_superindex->stdindex[cur_std_idx]->nEntriesInUse - 1;\n\n\t\tfor (audtr = 0; audtr < AVI->anum; audtr++) {\n\t\t\tif (!AVI->track[audtr].audio_superindex) {\n\t\t\t\t// not initialized -> no index\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tavi_ixnn_entry (AVI, AVI->track[audtr].audio_superindex->stdindex[cur_std_idx],\n\t\t\t                &AVI->track[audtr].audio_superindex->aIndex[cur_std_idx]);\n\t\t\tAVI->track[audtr].audio_superindex->aIndex[cur_std_idx].dwDuration =\n\t\t\t    AVI->track[audtr].audio_superindex->stdindex[cur_std_idx]->nEntriesInUse - 1;\n\t\t\tif (AVI->track[audtr].a_fmt == 0x1) {\n\t\t\t\tAVI->track[audtr].audio_superindex->aIndex[cur_std_idx].dwDuration *=\n\t\t\t\t    AVI->track[audtr].a_bits*AVI->track[audtr].a_rate*AVI->track[audtr].a_chans/800;\n\t\t\t}\n\t\t}\n\t\t// The AVI->video_superindex->nEntriesInUse contains the offset\n\t\tAVI->video_superindex->stdindex[ cur_std_idx+1 ]->qwBaseOffset = AVI->pos;\n\n\t\t// Correct!\n\t\tmovi_len = AVI->video_superindex->stdindex[ 1 ]->qwBaseOffset - HEADERBYTES+4 - AVI->n_idx*16 - 8;\n\t} else {\n\t\tmovi_len = AVI->pos - HEADERBYTES + 4;\n\t}\n\n\n\t/* Try to output the index entries. This may fail e.g. if no space\n\t   is left on device. We will report this as an error, but we still\n\t   try to write the header correctly (so that the file still may be\n\t   readable in the most cases */\n\n\tidxerror = 0;\n\thasIndex = 1;\n\tif (!AVI->is_opendml) {\n\t\t//   GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] pos=%lu, index_len=%ld             \\n\", AVI->pos, AVI->n_idx*16));\n\t\tint ret = avi_add_chunk(AVI, (unsigned char *)\"idx1\", (unsigned char *)AVI->idx, AVI->n_idx*16);\n\t\thasIndex = (ret==0);\n\t\t//GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] pos=%lu, index_len=%d\\n\", AVI->pos, hasIndex));\n\n\t\tif(ret) {\n\t\t\tidxerror = 1;\n\t\t\tAVI_errno = AVI_ERR_WRITE_INDEX;\n\t\t}\n\t}\n\n\t/* Calculate Microseconds per frame */\n\n\tif(AVI->fps < 0.001) {\n\t\tfrate=0;\n\t\tms_per_frame=0;\n\t} else {\n\t\tfrate = (int) (FRAME_RATE_SCALE*AVI->fps + 0.5);\n\t\tms_per_frame=(int) (1000000/AVI->fps + 0.5);\n\t}\n\n\t/* Prepare the file header */\n\n\tnhb = 0;\n\n\t/* The RIFF header */\n\n\tOUT4CC (\"RIFF\");\n\tif (AVI->is_opendml) {\n\t\tOUTLONG(AVI->video_superindex->stdindex[ 1 ]->qwBaseOffset - 8);    /* # of bytes to follow */\n\t} else {\n\t\tOUTLONG(AVI->pos - 8);    /* # of bytes to follow */\n\t}\n\n\tOUT4CC (\"AVI \");\n\n\t/* Start the header list */\n\n\tOUT4CC (\"LIST\");\n\tOUTLONG(0);        /* Length of list in bytes, don't know yet */\n\thdrl_start = nhb;  /* Store start position */\n\tOUT4CC (\"hdrl\");\n\n\t/* The main AVI header */\n\n\t/* The Flags in AVI File header */\n\n#define AVIF_HASINDEX           0x00000010      /* Index at end of file */\n#define AVIF_MUSTUSEINDEX       0x00000020\n#define AVIF_ISINTERLEAVED      0x00000100\n#define AVIF_TRUSTCKTYPE        0x00000800      /* Use CKType to find key frames */\n#define AVIF_WASCAPTUREFILE     0x00010000\n#define AVIF_COPYRIGHTED        0x00020000\n\n\tOUT4CC (\"avih\");\n\tOUTLONG(56);                 /* # of bytes to follow */\n\tOUTLONG(ms_per_frame);       /* Microseconds per frame */\n\t//ThOe ->0\n\t//   OUTLONG(10000000);           /* MaxBytesPerSec, I hope this will never be used */\n\tOUTLONG(0);\n\tOUTLONG(0);                  /* PaddingGranularity (whatever that might be) */\n\t/* Other sources call it 'reserved' */\n\tflag = AVIF_ISINTERLEAVED;\n\tif(hasIndex) flag |= AVIF_HASINDEX;\n\tif(hasIndex && AVI->must_use_index) flag |= AVIF_MUSTUSEINDEX;\n\tOUTLONG(flag);               /* Flags */\n\tOUTLONG(AVI->video_frames);  /* TotalFrames */\n\tOUTLONG(0);                  /* InitialFrames */\n\n\tOUTLONG(AVI->anum+1);\n//   if (AVI->track[0].audio_bytes)\n//      { OUTLONG(2); }           /* Streams */\n//   else\n//      { OUTLONG(1); }           /* Streams */\n\n\tOUTLONG(0);                  /* SuggestedBufferSize */\n\tOUTLONG(AVI->width);         /* Width */\n\tOUTLONG(AVI->height);        /* Height */\n\t/* MS calls the following 'reserved': */\n\tOUTLONG(0);                  /* TimeScale:  Unit used to measure time */\n\tOUTLONG(0);                  /* DataRate:   Data rate of playback     */\n\tOUTLONG(0);                  /* StartTime:  Starting time of AVI data */\n\tOUTLONG(0);                  /* DataLength: Size of AVI data chunk    */\n\n\n\t/* Start the video stream list ---------------------------------- */\n\n\tOUT4CC (\"LIST\");\n\tOUTLONG(0);        /* Length of list in bytes, don't know yet */\n\tstrl_start = nhb;  /* Store start position */\n\tOUT4CC (\"strl\");\n\n\t/* The video stream header */\n\n\tOUT4CC (\"strh\");\n\tOUTLONG(56);                 /* # of bytes to follow */\n\tOUT4CC (\"vids\");             /* Type */\n\tOUT4CC (AVI->compressor);    /* Handler */\n\tOUTLONG(0);                  /* Flags */\n\tOUTLONG(0);                  /* Reserved, MS says: wPriority, wLanguage */\n\tOUTLONG(0);                  /* InitialFrames */\n\tOUTLONG(FRAME_RATE_SCALE);   /* Scale */\n\tOUTLONG(frate);              /* Rate: Rate/Scale == samples/second */\n\tOUTLONG(0);                  /* Start */\n\tOUTLONG(AVI->video_frames);  /* Length */\n\tOUTLONG(AVI->max_len);       /* SuggestedBufferSize */\n\tOUTLONG(0);                  /* Quality */\n\tOUTLONG(0);                  /* SampleSize */\n\tOUTLONG(0);                  /* Frame */\n\tOUTLONG(0);                  /* Frame */\n\t//OUTLONG(0);                  /* Frame */\n\t//OUTLONG(0);                  /* Frame */\n\n\t/* The video stream format */\n\n\txd_size        = AVI->extradata_size;\n\txd_size_align2 = (AVI->extradata_size+1) & ~1;\n\n\tOUT4CC (\"strf\");\n\tOUTLONG(40 + xd_size_align2);/* # of bytes to follow */\n\tOUTLONG(40 + xd_size);\t/* Size */\n\tOUTLONG(AVI->width);         /* Width */\n\tOUTLONG(AVI->height);        /* Height */\n\tOUTSHRT(1);\n\tOUTSHRT(24);     /* Planes, Count */\n\tOUT4CC (AVI->compressor);    /* Compression */\n\t// ThOe (*3)\n\tOUTLONG(AVI->width*AVI->height*3);  /* SizeImage (in bytes?) */\n\tOUTLONG(0);                  /* XPelsPerMeter */\n\tOUTLONG(0);                  /* YPelsPerMeter */\n\tOUTLONG(0);                  /* ClrUsed: Number of colors used */\n\tOUTLONG(0);                  /* ClrImportant: Number of colors important */\n\n\t// write extradata if present\n\tif (xd_size > 0 && AVI->extradata) {\n\t\tOUTMEM(AVI->extradata, xd_size);\n\t\tif (xd_size != xd_size_align2) {\n\t\t\tOUTCHR(0);\n\t\t}\n\t}\n\n\t// dump index of indices for audio\n\tif (AVI->is_opendml) {\n\t\tu32 k;\n\n\t\tOUT4CC(AVI->video_superindex->fcc);\n\t\tOUTLONG(2+1+1+4+4+3*4 + AVI->video_superindex->nEntriesInUse * (8+4+4));\n\t\tOUTSHRT(AVI->video_superindex->wLongsPerEntry);\n\t\tOUTCHR(AVI->video_superindex->bIndexSubType);\n\t\tOUTCHR(AVI->video_superindex->bIndexType);\n\t\tOUTLONG(AVI->video_superindex->nEntriesInUse);\n\t\tOUT4CC(AVI->video_superindex->dwChunkId);\n\t\tOUTLONG(0);\n\t\tOUTLONG(0);\n\t\tOUTLONG(0);\n\n\n\t\tfor (k = 0; k < AVI->video_superindex->nEntriesInUse; k++) {\n\t\t\tu32 r = (u32) ((AVI->video_superindex->aIndex[k].qwOffset >> 32) & 0xffffffff);\n\t\t\tu32 s = (u32) ((AVI->video_superindex->aIndex[k].qwOffset) & 0xffffffff);\n\n\t\t\tOUTLONG(s);\n\t\t\tOUTLONG(r);\n\t\t\tOUTLONG(AVI->video_superindex->aIndex[k].dwSize);\n\t\t\tOUTLONG(AVI->video_superindex->aIndex[k].dwDuration);\n\t\t}\n\n\t}\n\n\t/* Finish stream list, i.e. put number of bytes in the list to proper pos */\n\n\tlong2str(AVI_header+strl_start-4,nhb-strl_start);\n\n\t/* Start the audio stream list ---------------------------------- */\n\n\tfor(j=0; j<AVI->anum; ++j) {\n\n\t\t//if (AVI->track[j].a_chans && AVI->track[j].audio_bytes)\n\t\t{\n\t\t\tunsigned int nBlockAlign = 0;\n\t\t\tunsigned int avgbsec = 0;\n\t\t\tunsigned int scalerate = 0;\n\n\t\t\tint sampsize = avi_sampsize(AVI, j);\n\t\t\tsampsize = AVI->track[j].a_fmt==0x1?sampsize*4:sampsize;\n\n\t\t\tnBlockAlign = (AVI->track[j].a_rate<32000)?576:1152;\n\t\t\t/*\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] XXX sampsize (%d) block (%ld) rate (%ld) audio_bytes (%ld) mp3rate(%ld,%ld)\\n\",\n\t\t\t sampsize, nBlockAlign, AVI->track[j].a_rate,\n\t\t\t (int int)AVI->track[j].audio_bytes,\n\t\t\t 1000*AVI->track[j].mp3rate/8, AVI->track[j].mp3rate));\n\t\t\t */\n\n\t\t\tif (AVI->track[j].a_fmt==0x1) {\n\t\t\t\tsampsize = (AVI->track[j].a_chans<2)?sampsize/2:sampsize;\n\t\t\t\tavgbsec = AVI->track[j].a_rate*sampsize/4;\n\t\t\t\tscalerate = AVI->track[j].a_rate*sampsize/4;\n\t\t\t} else  {\n\t\t\t\tavgbsec = 1000*AVI->track[j].mp3rate/8;\n\t\t\t\tscalerate = 1000*AVI->track[j].mp3rate/8;\n\t\t\t}\n\n\t\t\tOUT4CC (\"LIST\");\n\t\t\tOUTLONG(0);        /* Length of list in bytes, don't know yet */\n\t\t\tstrl_start = nhb;  /* Store start position */\n\t\t\tOUT4CC (\"strl\");\n\n\t\t\t/* The audio stream header */\n\n\t\t\tOUT4CC (\"strh\");\n\t\t\tOUTLONG(56);            /* # of bytes to follow */\n\t\t\tOUT4CC (\"auds\");\n\n\t\t\t// -----------\n\t\t\t// ThOe\n\t\t\tOUTLONG(0);             /* Format (Optionally) */\n\t\t\t// -----------\n\n\t\t\tOUTLONG(0);             /* Flags */\n\t\t\tOUTLONG(0);             /* Reserved, MS says: wPriority, wLanguage */\n\t\t\tOUTLONG(0);             /* InitialFrames */\n\n\t\t\t// VBR\n\t\t\tif (AVI->track[j].a_fmt == 0x55 && AVI->track[j].a_vbr) {\n\t\t\t\tOUTLONG(nBlockAlign);                   /* Scale */\n\t\t\t\tOUTLONG(AVI->track[j].a_rate);          /* Rate */\n\t\t\t\tOUTLONG(0);                             /* Start */\n\t\t\t\tOUTLONG(AVI->track[j].audio_chunks);    /* Length */\n\t\t\t\tOUTLONG(0);                      /* SuggestedBufferSize */\n\t\t\t\tOUTLONG(0);                             /* Quality */\n\t\t\t\tOUTLONG(0);                             /* SampleSize */\n\t\t\t\tOUTLONG(0);                             /* Frame */\n\t\t\t\tOUTLONG(0);                             /* Frame */\n\t\t\t} else {\n\t\t\t\tOUTLONG(sampsize/4);                    /* Scale */\n\t\t\t\tOUTLONG(scalerate);  /* Rate */\n\t\t\t\tOUTLONG(0);                             /* Start */\n\t\t\t\tOUTLONG(4*AVI->track[j].audio_bytes/sampsize);   /* Length */\n\t\t\t\tOUTLONG(0);                             /* SuggestedBufferSize */\n\t\t\t\tOUTLONG(0xffffffff);                             /* Quality */\n\t\t\t\tOUTLONG(sampsize/4);                    /* SampleSize */\n\t\t\t\tOUTLONG(0);                             /* Frame */\n\t\t\t\tOUTLONG(0);                             /* Frame */\n\t\t\t}\n\n\t\t\t/* The audio stream format */\n\n\t\t\tOUT4CC (\"strf\");\n\n\t\t\tif (AVI->track[j].a_fmt == 0x55 && AVI->track[j].a_vbr) {\n\n\t\t\t\tOUTLONG(30);                            /* # of bytes to follow */ // mplayer writes 28\n\t\t\t\tOUTSHRT(AVI->track[j].a_fmt);           /* Format */                  // 2\n\t\t\t\tOUTSHRT(AVI->track[j].a_chans);         /* Number of channels */      // 2\n\t\t\t\tOUTLONG(AVI->track[j].a_rate);          /* SamplesPerSec */           // 4\n\t\t\t\t//ThOe/tibit\n\t\t\t\tOUTLONG(1000*AVI->track[j].mp3rate/8);  /* maybe we should write an avg. */ // 4\n\t\t\t\tOUTSHRT(nBlockAlign);                   /* BlockAlign */              // 2\n\t\t\t\tOUTSHRT(AVI->track[j].a_bits);          /* BitsPerSample */           // 2\n\n\t\t\t\tOUTSHRT(12);                           /* cbSize */                   // 2\n\t\t\t\tOUTSHRT(1);                            /* wID */                      // 2\n\t\t\t\tOUTLONG(2);                            /* fdwFlags */                 // 4\n\t\t\t\tOUTSHRT(nBlockAlign);                  /* nBlockSize */               // 2\n\t\t\t\tOUTSHRT(1);                            /* nFramesPerBlock */          // 2\n\t\t\t\tOUTSHRT(0);                            /* nCodecDelay */              // 2\n\n\t\t\t} else if (AVI->track[j].a_fmt == 0x55 && !AVI->track[j].a_vbr) {\n\n\t\t\t\tOUTLONG(30);                            /* # of bytes to follow */\n\t\t\t\tOUTSHRT(AVI->track[j].a_fmt);           /* Format */\n\t\t\t\tOUTSHRT(AVI->track[j].a_chans);         /* Number of channels */\n\t\t\t\tOUTLONG(AVI->track[j].a_rate);          /* SamplesPerSec */\n\t\t\t\t//ThOe/tibit\n\t\t\t\tOUTLONG(1000*AVI->track[j].mp3rate/8);\n\t\t\t\tOUTSHRT(sampsize/4);                    /* BlockAlign */\n\t\t\t\tOUTSHRT(AVI->track[j].a_bits);          /* BitsPerSample */\n\n\t\t\t\tOUTSHRT(12);                           /* cbSize */\n\t\t\t\tOUTSHRT(1);                            /* wID */\n\t\t\t\tOUTLONG(2);                            /* fdwFlags */\n\t\t\t\tOUTSHRT(nBlockAlign);                  /* nBlockSize */\n\t\t\t\tOUTSHRT(1);                            /* nFramesPerBlock */\n\t\t\t\tOUTSHRT(0);                            /* nCodecDelay */\n\n\t\t\t} else {\n\n\t\t\t\tOUTLONG(18);                   /* # of bytes to follow */\n\t\t\t\tOUTSHRT(AVI->track[j].a_fmt);           /* Format */\n\t\t\t\tOUTSHRT(AVI->track[j].a_chans);         /* Number of channels */\n\t\t\t\tOUTLONG(AVI->track[j].a_rate);          /* SamplesPerSec */\n\t\t\t\t//ThOe/tibit\n\t\t\t\tOUTLONG(avgbsec);  /* Avg bytes/sec */\n\t\t\t\tOUTSHRT(sampsize/4);                    /* BlockAlign */\n\t\t\t\tOUTSHRT(AVI->track[j].a_bits);          /* BitsPerSample */\n\t\t\t\tOUTSHRT(0);                           /* cbSize */\n\n\t\t\t}\n\t\t}\n\t\tif (AVI->is_opendml) {\n\t\t\tu32 k;\n\n\t\t\tif (!AVI->track[j].audio_superindex) {\n\t\t\t\t// not initialized -> no index\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tOUT4CC(AVI->track[j].audio_superindex->fcc);    /* \"indx\" */\n\t\t\tOUTLONG(2+1+1+4+4+3*4 + AVI->track[j].audio_superindex->nEntriesInUse * (8+4+4));\n\t\t\tOUTSHRT(AVI->track[j].audio_superindex->wLongsPerEntry);\n\t\t\tOUTCHR(AVI->track[j].audio_superindex->bIndexSubType);\n\t\t\tOUTCHR(AVI->track[j].audio_superindex->bIndexType);\n\t\t\tOUTLONG(AVI->track[j].audio_superindex->nEntriesInUse);\n\t\t\tOUT4CC(AVI->track[j].audio_superindex->dwChunkId);\n\t\t\tOUTLONG(0);\n\t\t\tOUTLONG(0);\n\t\t\tOUTLONG(0);\n\n\t\t\tfor (k = 0; k < AVI->track[j].audio_superindex->nEntriesInUse; k++) {\n\t\t\t\tu32 r = (u32) ((AVI->track[j].audio_superindex->aIndex[k].qwOffset >> 32) & 0xffffffff);\n\t\t\t\tu32 s = (u32) ((AVI->track[j].audio_superindex->aIndex[k].qwOffset) & 0xffffffff);\n\n\t\t\t\t/*\n\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] AUD[%d] NrEntries %d/%ld (%c%c%c%c) |0x%llX|%ld|%ld| \\n\",  j, k,\n\t\t\t\t        AVI->track[j].audio_superindex->nEntriesInUse,\n\t\t\t\t    AVI->track[j].audio_superindex->dwChunkId[0], AVI->track[j].audio_superindex->dwChunkId[1],\n\t\t\t\t    AVI->track[j].audio_superindex->dwChunkId[2], AVI->track[j].audio_superindex->dwChunkId[3],\n\t\t\t\t    AVI->track[j].audio_superindex->aIndex[k].qwOffset,\n\t\t\t\t    AVI->track[j].audio_superindex->aIndex[k].dwSize,\n\t\t\t\t    AVI->track[j].audio_superindex->aIndex[k].dwDuration\n\t\t\t\t  ));\n\t\t\t\t  */\n\n\t\t\t\tOUTLONG(s);\n\t\t\t\tOUTLONG(r);\n\t\t\t\tOUTLONG(AVI->track[j].audio_superindex->aIndex[k].dwSize);\n\t\t\t\tOUTLONG(AVI->track[j].audio_superindex->aIndex[k].dwDuration);\n\t\t\t}\n\t\t}\n\t\t/* Finish stream list, i.e. put number of bytes in the list to proper pos */\n\t\tlong2str(AVI_header+strl_start-4,nhb-strl_start);\n\t}\n\n\tif (AVI->is_opendml) {\n\t\tOUT4CC(\"LIST\");\n\t\tOUTLONG(16);\n\t\tOUT4CC(\"odml\");\n\t\tOUT4CC(\"dmlh\");\n\t\tOUTLONG(4);\n\t\tOUTLONG(AVI->total_frames);\n\t}\n\n\t/* Finish header list */\n\n\tlong2str(AVI_header+hdrl_start-4,nhb-hdrl_start);\n\n\n\t// add INFO list --- (0.6.0pre4)\n\n#ifdef INFO_LIST\n\tOUT4CC (\"LIST\");\n\n\tinfo_start_pos = nhb;\n\tinfo_len = MAX_INFO_STRLEN + 12;\n\tOUTLONG(info_len); // rewritten later\n\tOUT4CC (\"INFO\");\n\n\tOUT4CC (\"ISFT\");\n\t//OUTLONG(MAX_INFO_STRLEN);\n\tmemset(id_str, 0, MAX_INFO_STRLEN);\n\tif (gf_sys_is_test_mode()) {\n\t\tsnprintf(id_str, MAX_INFO_STRLEN, \"GPAC/avilib\");\n\t} else {\n\t\tsnprintf(id_str, MAX_INFO_STRLEN, \"GPAC/avilib-%s\", gf_gpac_version());\n\t}\n\treal_id_len = id_len = (u32) strlen(id_str)+1;\n\tif (id_len&1) id_len++;\n\n\tOUTLONG(real_id_len);\n\n\tmemset(AVI_header+nhb, 0, id_len);\n\tmemcpy(AVI_header+nhb, id_str, id_len);\n\tnhb += id_len;\n\n\tinfo_len = 0;\n\n\t// write correct len\n\tlong2str(AVI_header+info_start_pos, info_len + id_len + 4+4+4);\n\n\tnhb += info_len;\n\n//   OUT4CC (\"ICMT\");\n//   OUTLONG(MAX_INFO_STRLEN);\n\n//   calptr=time(NULL);\n//   sprintf(id_str, \"\\t%s %s\", ctime(&calptr), \"\");\n//   memset(AVI_header+nhb, 0, MAX_INFO_STRLEN);\n//   memcpy(AVI_header+nhb, id_str, 25);\n//   nhb += MAX_INFO_STRLEN;\n#endif\n\n\t// ----------------------------\n\n\t/* Calculate the needed amount of junk bytes, output junk */\n\n\tnjunk = HEADERBYTES - nhb - 8 - 12;\n\n\t/* Safety first: if njunk <= 0, somebody has played with\n\t   HEADERBYTES without knowing what (s)he did.\n\t   This is a fatal error */\n\n\tif(njunk<=0)\n\t{\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[avilib] AVI_close_output_file: # of header bytes too small\\n\"));\n\t\texit(1);\n\t}\n\n\tOUT4CC (\"JUNK\");\n\tOUTLONG(njunk);\n\tmemset(AVI_header+nhb,0,njunk);\n\n\tnhb += njunk;\n\n\t/* Start the movi list */\n\n\tOUT4CC (\"LIST\");\n\tOUTLONG(movi_len); /* Length of list in bytes */\n\tOUT4CC (\"movi\");\n\n\t/* Output the header, truncate the file to the number of bytes\n\t   actually written, report an error if someting goes wrong */\n\n\tif ( (gf_fseek(AVI->fdes,0,SEEK_SET)==(u64)-1) ||\n\t        avi_write(AVI->fdes,(char *)AVI_header,HEADERBYTES)!=HEADERBYTES\n//\t\t|| ftruncate(AVI->fdes,AVI->pos)<0\n\t   )\n\t{\n\t\tAVI_errno = AVI_ERR_CLOSE;\n\t\treturn -1;\n\t}\n\n\n\t// Fix up the empty additional RIFF and LIST chunks\n\tif (AVI->is_opendml) {\n\t\tu32 k;\n\t\tchar f[4];\n\t\tu32 len;\n\n\t\tfor (k=1; k<AVI->video_superindex->nEntriesInUse; k++) {\n\t\t\t// the len of the RIFF Chunk\n\t\t\tgf_fseek(AVI->fdes, AVI->video_superindex->stdindex[k]->qwBaseOffset+4, SEEK_SET);\n\t\t\tlen = (u32) (AVI->video_superindex->stdindex[k+1]->qwBaseOffset - AVI->video_superindex->stdindex[k]->qwBaseOffset - 8);\n\t\t\tlong2str((unsigned char *)f, len);\n\t\t\tavi_write(AVI->fdes, f, 4);\n\n\t\t\t// len of the LIST/movi chunk\n\t\t\tgf_fseek(AVI->fdes, 8, SEEK_CUR);\n\t\t\tlen -= 12;\n\t\t\tlong2str((unsigned char *)f, len);\n\t\t\tavi_write(AVI->fdes, f, 4);\n\t\t}\n\t}\n\n\n\tif(idxerror) return -1;\n\n\treturn 0;\n}\n\n/*\n   AVI_write_data:\n   Add video or audio data to the file;\n\n   Return values:\n    0    No error;\n   -1    Error, AVI_errno is set appropriatly;\n\n*/\n\nstatic int avi_write_data(avi_t *AVI, char *data, unsigned int length, int audio, int keyframe)\n{\n\tint n = 0;\n\n\tunsigned char astr[5];\n\n\t// transcode core itself checks for the size -- unneeded and\n\t// does harm to xvid 2pass encodes where the first pass can get\n\t// _very_ large -- tibit.\n\n#if 0\n\t/* Check for maximum file length */\n\n\tif ( (AVI->pos + 8 + length + 8 + (AVI->n_idx+1)*16) > AVI_MAX_LEN ) {\n\t\tAVI_errno = AVI_ERR_SIZELIM;\n\t\treturn -1;\n\t}\n#endif\n\n\t/* Add index entry */\n\n\t//set tag for current audio track\n\tsprintf((char *)astr, \"0%1dwb\", (int)(AVI->aptr+1));\n\n\tif(audio) {\n\t\tif (!AVI->is_opendml) n = avi_add_index_entry(AVI,astr,0x10,AVI->pos,length);\n\t\tn += avi_add_odml_index_entry(AVI,astr,0x10,AVI->pos,length);\n\t} else {\n\t\tif (!AVI->is_opendml) n = avi_add_index_entry(AVI,(unsigned char *)\"00db\",((keyframe)?0x10:0x0),AVI->pos,length);\n\t\tn += avi_add_odml_index_entry(AVI,(unsigned char *)\"00db\",((keyframe)?0x10:0x0),AVI->pos,length);\n\t}\n\n\tif(n) return -1;\n\n\t/* Output tag and data */\n\n\tif(audio)\n\t\tn = avi_add_chunk(AVI,(unsigned char *)astr, (unsigned char *)data, length);\n\telse\n\t\tn = avi_add_chunk(AVI,(unsigned char *)\"00db\", (unsigned char *)data, length);\n\n\tif (n) return -1;\n\n\treturn 0;\n}\n\nGF_EXPORT\nint AVI_write_frame(avi_t *AVI, u8 *data, int bytes, int keyframe)\n{\n\ts64 pos;\n\n\tif(AVI->mode==AVI_MODE_READ) {\n\t\tAVI_errno = AVI_ERR_NOT_PERM;\n\t\treturn -1;\n\t}\n\n\tpos = AVI->pos;\n\n\tif(avi_write_data(AVI,data,bytes,0,keyframe)) return -1;\n\n\tAVI->last_pos = pos;\n\tAVI->last_len = bytes;\n\tAVI->video_frames++;\n\treturn 0;\n}\n\n#if 0 //unused\nint AVI_dup_frame(avi_t *AVI)\n{\n\tif(AVI->mode==AVI_MODE_READ) {\n\t\tAVI_errno = AVI_ERR_NOT_PERM;\n\t\treturn -1;\n\t}\n\n\tif(AVI->last_pos==0) return 0; /* No previous real frame */\n\tif(avi_add_index_entry(AVI,(unsigned char *)\"00db\",0x10,AVI->last_pos,AVI->last_len)) return -1;\n\tAVI->video_frames++;\n\tAVI->must_use_index = 1;\n\treturn 0;\n}\n#endif\n\nGF_EXPORT\nint AVI_write_audio(avi_t *AVI, u8 *data, int bytes)\n{\n\tif(AVI->mode==AVI_MODE_READ) {\n\t\tAVI_errno = AVI_ERR_NOT_PERM;\n\t\treturn -1;\n\t}\n\n\tif( avi_write_data(AVI,data,bytes,1,0) ) return -1;\n\tAVI->track[AVI->aptr].audio_bytes += bytes;\n\tAVI->track[AVI->aptr].audio_chunks++;\n\treturn 0;\n}\n\n#if 0 //unused\n\nint AVI_append_audio(avi_t *AVI, u8 *data, int bytes)\n{\n\n\t// won't work for >2gb\n\tint i, length, pos;\n\tunsigned char c[4];\n\n\tif(AVI->mode==AVI_MODE_READ) {\n\t\tAVI_errno = AVI_ERR_NOT_PERM;\n\t\treturn -1;\n\t}\n\n\t// update last index entry:\n\n\t--AVI->n_idx;\n\tlength = str2ulong(AVI->idx[AVI->n_idx]+12);\n\tpos    = str2ulong(AVI->idx[AVI->n_idx]+8);\n\n\t//update;\n\tlong2str(AVI->idx[AVI->n_idx]+12,length+bytes);\n\n\t++AVI->n_idx;\n\n\tAVI->track[AVI->aptr].audio_bytes += bytes;\n\n\t//update chunk header\n\tgf_fseek(AVI->fdes, pos+4, SEEK_SET);\n\tlong2str(c, length+bytes);\n\tavi_write(AVI->fdes, (char *)c, 4);\n\n\tgf_fseek(AVI->fdes, pos+8+length, SEEK_SET);\n\n\ti=PAD_EVEN(length + bytes);\n\n\tbytes = i - length;\n\tavi_write(AVI->fdes, data, bytes);\n\tAVI->pos = pos + 8 + i;\n\n\treturn 0;\n}\n\nu64 AVI_bytes_remain(avi_t *AVI)\n{\n\tif(AVI->mode==AVI_MODE_READ) return 0;\n\n\treturn ( AVI_MAX_LEN - (AVI->pos + 8 + 16*AVI->n_idx));\n}\n\nu64 AVI_bytes_written(avi_t *AVI)\n{\n\tif(AVI->mode==AVI_MODE_READ) return 0;\n\n\treturn (AVI->pos + 8 + 16*AVI->n_idx);\n}\n#endif\n\nint AVI_set_audio_track(avi_t *AVI, u32 track)\n{\n\n\tif (track + 1 > AVI->anum) return(-1);\n\n\t//this info is not written to file anyway\n\tAVI->aptr=track;\n\treturn 0;\n}\n\nint AVI_get_audio_track(avi_t *AVI)\n{\n\treturn(AVI->aptr);\n}\n\n#if 0 //unused\nvoid AVI_set_audio_vbr(avi_t *AVI, int is_vbr)\n{\n\tAVI->track[AVI->aptr].a_vbr = is_vbr;\n}\n\nint AVI_get_audio_vbr(avi_t *AVI)\n{\n\treturn(AVI->track[AVI->aptr].a_vbr);\n}\n#endif\n\n\n/*******************************************************************\n *                                                                 *\n *    Utilities for reading video and audio from an AVI File       *\n *                                                                 *\n *******************************************************************/\n\nGF_EXPORT\nint AVI_close(avi_t *AVI)\n{\n\tint ret;\n\tu32 j;\n\n\t/* If the file was open for writing, the header and index still have\n\t   to be written */\n\n\tif(AVI->mode == AVI_MODE_WRITE)\n\t\tret = avi_close_output_file(AVI);\n\telse\n\t\tret = 0;\n\n\t/* Even if there happened an error, we first clean up */\n\n\tgf_fclose(AVI->fdes);\n\tif(AVI->idx) gf_free(AVI->idx);\n\tif(AVI->video_index) gf_free(AVI->video_index);\n\tif(AVI->video_superindex) {\n\t\tif(AVI->video_superindex->aIndex) gf_free(AVI->video_superindex->aIndex);\n\t\tif (AVI->video_superindex->stdindex) {\n\t\t\tfor (j=0; j < NR_IXNN_CHUNKS; j++) {\n\t\t\t\tif (AVI->video_superindex->stdindex[j]->aIndex)\n\t\t\t\t\tgf_free(AVI->video_superindex->stdindex[j]->aIndex);\n\t\t\t\tgf_free(AVI->video_superindex->stdindex[j]);\n\t\t\t}\n\t\t\tgf_free(AVI->video_superindex->stdindex);\n\t\t}\n\t\tgf_free(AVI->video_superindex);\n\t}\n\n\tfor (j=0; j<AVI->anum; j++)\n\t{\n\t\tif(AVI->track[j].audio_index) gf_free(AVI->track[j].audio_index);\n\t\tif(AVI->track[j].audio_superindex) {\n\t\t\tavisuperindex_chunk *asi = AVI->track[j].audio_superindex;\n\t\t\tif (asi->aIndex) gf_free(asi->aIndex);\n\n\t\t\tif (asi->stdindex) {\n\t\t\t\tfor (j=0; j < NR_IXNN_CHUNKS; j++) {\n\t\t\t\t\tif (asi->stdindex[j]->aIndex)\n\t\t\t\t\t\tgf_free(asi->stdindex[j]->aIndex);\n\t\t\t\t\tgf_free(asi->stdindex[j]);\n\t\t\t\t}\n\t\t\t\tgf_free(asi->stdindex);\n\t\t\t}\n\t\t\tgf_free(asi);\n\t\t}\n\t}\n\n\tif (AVI->bitmap_info_header)\n\t\tgf_free(AVI->bitmap_info_header);\n\tfor (j = 0; j < AVI->anum; j++)\n\t\tif (AVI->wave_format_ex[j])\n\t\t\tgf_free(AVI->wave_format_ex[j]);\n\tif (AVI->extradata)\n\t\tgf_free(AVI->extradata);\n\n\tgf_free(AVI);\n\treturn ret;\n}\n\n\n#define ERR_EXIT(x) \\\n{ \\\n   AVI_close(AVI); \\\n   AVI_errno = x; \\\n   return 0; \\\n}\n\n\navi_t *AVI_open_input_file(char *filename, int getIndex)\n{\n\tavi_t *AVI;\n\n\t/* Create avi_t structure */\n\n\tAVI = (avi_t *) gf_malloc(sizeof(avi_t));\n\tif(AVI==NULL)\n\t{\n\t\tAVI_errno = AVI_ERR_NO_MEM;\n\t\treturn 0;\n\t}\n\tmemset((void *)AVI,0,sizeof(avi_t));\n\n\tAVI->mode = AVI_MODE_READ; /* open for reading */\n\n\t/* Open the file */\n\n\tAVI->fdes = gf_fopen(filename,\"rb\");\n\tif(!AVI->fdes )\n\t{\n\t\tAVI_errno = AVI_ERR_OPEN;\n\t\tgf_free(AVI);\n\t\treturn 0;\n\t}\n\n\tAVI_errno = 0;\n\tavi_parse_input_file(AVI, getIndex);\n\n\tif (AVI != NULL && !AVI_errno) {\n\t\tAVI->aptr=0; //reset\n\t}\n\n\tif (AVI_errno) return NULL;\n\n\treturn AVI;\n}\n\n#if 0\navi_t *AVI_open_fd(FILE *fd, int getIndex)\n{\n\tavi_t *AVI=NULL;\n\n\t/* Create avi_t structure */\n\n\tAVI = (avi_t *) gf_malloc(sizeof(avi_t));\n\tif(AVI==NULL)\n\t{\n\t\tAVI_errno = AVI_ERR_NO_MEM;\n\t\treturn 0;\n\t}\n\tmemset((void *)AVI,0,sizeof(avi_t));\n\n\tAVI->mode = AVI_MODE_READ; /* open for reading */\n\n\t// file alread open\n\tAVI->fdes = fd;\n\n\tAVI_errno = 0;\n\tavi_parse_input_file(AVI, getIndex);\n\n\tif (AVI != NULL && !AVI_errno) {\n\t\tAVI->aptr=0; //reset\n\t}\n\n\tif (AVI_errno)\n\t\treturn AVI=NULL;\n\telse\n\t\treturn AVI;\n}\n#endif\n\nint avi_parse_input_file(avi_t *AVI, int getIndex)\n{\n\tint rate, scale, idx_type;\n\ts64 n, i;\n\tunsigned char *hdrl_data;\n\tu64 header_offset=0;\n\tint hdrl_len=0;\n\tint nvi, nai[AVI_MAX_TRACKS], ioff;\n\tu64 tot[AVI_MAX_TRACKS];\n\tu32 j;\n\tint lasttag = 0;\n\tint vids_strh_seen = 0;\n\tint vids_strf_seen = 0;\n\tint auds_strh_seen = 0;\n\t//  int auds_strf_seen = 0;\n\tint num_stream = 0;\n\tchar data[256];\n\ts64 oldpos=-1, newpos=-1;\n\n\tint aud_chunks = 0;\n\tif (!AVI) {\n\t   AVI_errno = AVI_ERR_OPEN;\n\t   return 0;\n\t}\n\n\t/* Read first 12 bytes and check that this is an AVI file */\n\tif (avi_read(AVI->fdes,data,12) != 12 )\n\t\tERR_EXIT(AVI_ERR_READ)\n\n\tif (strnicmp(data  ,\"RIFF\",4) !=0 || strnicmp(data+8,\"AVI \",4) !=0 )\n\t\tERR_EXIT(AVI_ERR_NO_AVI)\n\n\t/* Go through the AVI file and extract the header list,\n\t   the start position of the 'movi' list and an optionally\n\t   present idx1 tag */\n\n\thdrl_data = 0;\n\n\twhile(1)\n\t{\n\t\tif( avi_read(AVI->fdes,data,8) != 8 ) break; /* We assume it's EOF */\n\t\tnewpos = gf_ftell(AVI->fdes);\n\t\tif(oldpos==newpos) {\n\t\t\t/* This is a broken AVI stream... */\n\t\t\treturn -1;\n\t\t}\n\t\toldpos=newpos;\n\n\t\tn = str2ulong((unsigned char *)data+4);\n\t\tn = PAD_EVEN(n);\n\n\t\tif(strnicmp(data,\"LIST\",4) == 0)\n\t\t{\n\t\t\tif( avi_read(AVI->fdes,data,4) != 4 ) ERR_EXIT(AVI_ERR_READ)\n\t\t\t\tn -= 4;\n\t\t\tif(strnicmp(data,\"hdrl\",4) == 0)\n\t\t\t{\n\t\t\t\tif (n>0xFFFFFFFF) ERR_EXIT(AVI_ERR_READ)\n\t\t\t\thdrl_len = (u32) n;\n\t\t\t\thdrl_data = (unsigned char *) gf_malloc((u32)n);\n\t\t\t\tif(hdrl_data==0) ERR_EXIT(AVI_ERR_NO_MEM);\n\n\t\t\t\t// offset of header\n\n\t\t\t\theader_offset = gf_ftell(AVI->fdes);\n\n\t\t\t\tif( avi_read(AVI->fdes,(char *)hdrl_data, (u32) n) != n ) {\n\t\t\t\t\tif (hdrl_data) gf_free(hdrl_data);\n\t\t\t\t\tERR_EXIT(AVI_ERR_READ)\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(strnicmp(data,\"movi\",4) == 0)\n\t\t\t{\n\t\t\t\tAVI->movi_start = gf_ftell(AVI->fdes);\n\t\t\t\tif (gf_fseek(AVI->fdes,n,SEEK_CUR)==(u64)-1) break;\n\t\t\t}\n\t\t\telse if (gf_fseek(AVI->fdes,n,SEEK_CUR)==(u64)-1) break;\n\t\t}\n\t\telse if(strnicmp(data,\"idx1\",4) == 0)\n\t\t{\n\t\t\t/* n must be a multiple of 16, but the reading does not\n\t\t\t   break if this is not the case */\n\n\t\t\tAVI->n_idx = AVI->max_idx = (u32) (n/16);\n\t\t\tAVI->idx = (unsigned  char((*)[16]) ) gf_malloc((u32)n);\n\t\t\tif(AVI->idx==0) {\n\t\t\t\tif (hdrl_data) gf_free(hdrl_data);\n\t\t\t\tERR_EXIT(AVI_ERR_NO_MEM)\n\t\t\t}\n\t\t\tif(avi_read(AVI->fdes, (char *) AVI->idx, (u32) n) != n ) {\n\t\t\t\tgf_free( AVI->idx);\n\t\t\t\tAVI->idx=NULL;\n\t\t\t\tAVI->n_idx = 0;\n\t\t\t\tif (hdrl_data) gf_free(hdrl_data);\n\t\t\t\tERR_EXIT(AVI_ERR_READ)\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\tgf_fseek(AVI->fdes,n,SEEK_CUR);\n\t}\n\n\tif(!hdrl_data) ERR_EXIT(AVI_ERR_NO_HDRL)\n\tif(!AVI->movi_start) ERR_EXIT(AVI_ERR_NO_MOVI)\n\n\t\t\t/* Interpret the header list */\n\n\t\t\tfor(i=0; i<hdrl_len;)\n\t\t\t{\n\t\t\t\t/* List tags are completly ignored */\n\n#ifdef DEBUG_ODML\n\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] TAG %c%c%c%c\\n\", (hdrl_data+i)[0], (hdrl_data+i)[1], (hdrl_data+i)[2], (hdrl_data+i)[3]));\n#endif\n\n\t\t\t\tif(strnicmp((char *)hdrl_data+i,\"LIST\",4)==0) {\n\t\t\t\t\ti+= 12;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tn = str2ulong(hdrl_data+i+4);\n\t\t\t\tn = PAD_EVEN(n);\n\t\t\t\tif (i+n>hdrl_len) ERR_EXIT(AVI_ERR_READ)\n\n\n\t\t\t\t/* Interpret the tag and its args */\n\n\t\t\t\tif(strnicmp((char *)hdrl_data+i,\"strh\",4)==0)\n\t\t\t\t{\n\t\t\t\t\ti += 8;\n#ifdef DEBUG_ODML\n\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] TAG   %c%c%c%c\\n\", (hdrl_data+i)[0], (hdrl_data+i)[1], (hdrl_data+i)[2], (hdrl_data+i)[3]));\n#endif\n\t\t\t\t\tif(strnicmp((char *)hdrl_data+i,\"vids\",4) == 0 && !vids_strh_seen)\n\t\t\t\t\t{\n\t\t\t\t\t\tmemcpy(AVI->compressor,hdrl_data+i+4,4);\n\t\t\t\t\t\tAVI->compressor[4] = 0;\n\n\t\t\t\t\t\t// ThOe\n\t\t\t\t\t\tAVI->v_codech_off = header_offset + i+4;\n\n\t\t\t\t\t\tscale = str2ulong(hdrl_data+i+20);\n\t\t\t\t\t\trate  = str2ulong(hdrl_data+i+24);\n\t\t\t\t\t\tif(scale!=0) AVI->fps = (double)rate/(double)scale;\n\t\t\t\t\t\tAVI->video_frames = str2ulong(hdrl_data+i+32);\n\t\t\t\t\t\tAVI->video_strn = num_stream;\n\t\t\t\t\t\tAVI->max_len = 0;\n\t\t\t\t\t\tvids_strh_seen = 1;\n\t\t\t\t\t\tlasttag = 1; /* vids */\n\t\t\t\t\t\tmemcpy(&AVI->video_stream_header, hdrl_data + i,\n\t\t\t\t\t\t       sizeof(alAVISTREAMHEADER));\n\t\t\t\t\t}\n\t\t\t\t\telse if (strnicmp ((char *)hdrl_data+i,\"auds\",4) ==0 && ! auds_strh_seen)\n\t\t\t\t\t{\n\n\t\t\t\t\t\t//inc audio tracks\n\t\t\t\t\t\tAVI->aptr=AVI->anum;\n\t\t\t\t\t\t++AVI->anum;\n\n\t\t\t\t\t\tif(AVI->anum > AVI_MAX_TRACKS) {\n\t\t\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[avilib] error - only %d audio tracks supported\\n\", AVI_MAX_TRACKS));\n\t\t\t\t\t\t\treturn(-1);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tAVI->track[AVI->aptr].audio_bytes = str2ulong(hdrl_data+i+32)*avi_sampsize(AVI, 0);\n\t\t\t\t\t\tAVI->track[AVI->aptr].audio_strn = num_stream;\n\n\t\t\t\t\t\t// if samplesize==0 -> vbr\n\t\t\t\t\t\tAVI->track[AVI->aptr].a_vbr = !str2ulong(hdrl_data+i+44);\n\n\t\t\t\t\t\tAVI->track[AVI->aptr].padrate = str2ulong(hdrl_data+i+24);\n\t\t\t\t\t\tmemcpy(&AVI->stream_headers[AVI->aptr], hdrl_data + i,\n\t\t\t\t\t\t       sizeof(alAVISTREAMHEADER));\n\n\t\t\t\t\t\t//\t   auds_strh_seen = 1;\n\t\t\t\t\t\tlasttag = 2; /* auds */\n\n\t\t\t\t\t\t// ThOe\n\t\t\t\t\t\tAVI->track[AVI->aptr].a_codech_off = header_offset + i;\n\n\t\t\t\t\t}\n\t\t\t\t\telse if (strnicmp ((char*)hdrl_data+i,\"iavs\",4) ==0 && ! auds_strh_seen) {\n\t\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[avilib] AVILIB: error - DV AVI Type 1 no supported\\n\"));\n\t\t\t\t\t\treturn (-1);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tlasttag = 0;\n\t\t\t\t\tnum_stream++;\n\t\t\t\t}\n\t\t\t\telse if(strnicmp((char*)hdrl_data+i,\"dmlh\",4) == 0) {\n\t\t\t\t\tAVI->total_frames = str2ulong(hdrl_data+i+8);\n#ifdef DEBUG_ODML\n\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] real number of frames %d\\n\", AVI->total_frames));\n#endif\n\t\t\t\t\ti += 8;\n\t\t\t\t}\n\t\t\t\telse if(strnicmp((char *)hdrl_data+i,\"strf\",4)==0)\n\t\t\t\t{\n\t\t\t\t\ti += 8;\n\t\t\t\t\tif(lasttag == 1)\n\t\t\t\t\t{\n\t\t\t\t\t\talBITMAPINFOHEADER bih;\n\n\t\t\t\t\t\tmemcpy(&bih, hdrl_data + i, sizeof(alBITMAPINFOHEADER));\n\t\t\t\t\t\tbih.bi_size = str2ulong((unsigned char *)&bih.bi_size);\n\n\t\t\t\t\t\tif (i + bih.bi_size > hdrl_len) ERR_EXIT(AVI_ERR_READ)\n\n\t\t\t\t\t\tAVI->bitmap_info_header = (alBITMAPINFOHEADER *) gf_malloc(bih.bi_size);\n\t\t\t\t\t\tif (AVI->bitmap_info_header != NULL)\n\t\t\t\t\t\t\tmemcpy(AVI->bitmap_info_header, hdrl_data + i, bih.bi_size);\n\n\t\t\t\t\t\tAVI->width  = str2ulong(hdrl_data+i+4);\n\t\t\t\t\t\tAVI->height = str2ulong(hdrl_data+i+8);\n\t\t\t\t\t\tvids_strf_seen = 1;\n\t\t\t\t\t\t//ThOe\n\t\t\t\t\t\tAVI->v_codecf_off = header_offset + i+16;\n\n\t\t\t\t\t\tmemcpy(AVI->compressor2, hdrl_data+i+16, 4);\n\t\t\t\t\t\tAVI->compressor2[4] = 0;\n\n\t\t\t\t\t\tif (n>40) {\n\t\t\t\t\t\t\tif (n>0xFFFFFFFF) ERR_EXIT(AVI_ERR_READ)\n\t\t\t\t\t\t\tAVI->extradata_size = (u32) (n - 40);\n\t\t\t\t\t\t\tAVI->extradata = gf_malloc(sizeof(u8)* AVI->extradata_size);\n\t\t\t\t\t\t\tif (!AVI->extradata) ERR_EXIT(AVI_ERR_NO_MEM)\n\t\t\t\t\t\t\tmemcpy(AVI->extradata, hdrl_data + i + 40, AVI->extradata_size);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\t\t\t\t\telse if(lasttag == 2)\n\t\t\t\t\t{\n\t\t\t\t\t\talWAVEFORMATEX *wfe;\n\t\t\t\t\t\tchar *nwfe;\n\t\t\t\t\t\tint wfes;\n\n\t\t\t\t\t\tif ((u32) (hdrl_len - i) < sizeof(alWAVEFORMATEX))\n\t\t\t\t\t\t\twfes = (int) (hdrl_len - i);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\twfes = sizeof(alWAVEFORMATEX);\n\t\t\t\t\t\twfe = (alWAVEFORMATEX *)gf_malloc(sizeof(alWAVEFORMATEX));\n\t\t\t\t\t\tif (wfe != NULL) {\n\t\t\t\t\t\t\tmemset(wfe, 0, sizeof(alWAVEFORMATEX));\n\t\t\t\t\t\t\tmemcpy(wfe, hdrl_data + i, wfes);\n\t\t\t\t\t\t\tif (str2ushort((unsigned char *)&wfe->cb_size) != 0) {\n\t\t\t\t\t\t\t\tnwfe = (char *)\n\t\t\t\t\t\t\t\t       gf_realloc(wfe, sizeof(alWAVEFORMATEX) +\n\t\t\t\t\t\t\t\t                  str2ushort((unsigned char *)&wfe->cb_size));\n\t\t\t\t\t\t\t\tif (nwfe != 0) {\n\t\t\t\t\t\t\t\t\ts64 lpos = gf_ftell(AVI->fdes);\n\t\t\t\t\t\t\t\t\tgf_fseek(AVI->fdes, header_offset + i + sizeof(alWAVEFORMATEX),\n\t\t\t\t\t\t\t\t\t         SEEK_SET);\n\t\t\t\t\t\t\t\t\twfe = (alWAVEFORMATEX *)nwfe;\n\t\t\t\t\t\t\t\t\tnwfe = &nwfe[sizeof(alWAVEFORMATEX)];\n\t\t\t\t\t\t\t\t\tavi_read(AVI->fdes, nwfe,\n\t\t\t\t\t\t\t\t\t         str2ushort((unsigned char *)&wfe->cb_size));\n\t\t\t\t\t\t\t\t\tgf_fseek(AVI->fdes, lpos, SEEK_SET);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tAVI->wave_format_ex[AVI->aptr] = wfe;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tAVI->track[AVI->aptr].a_fmt   = str2ushort(hdrl_data+i  );\n\n\t\t\t\t\t\t//ThOe\n\t\t\t\t\t\tAVI->track[AVI->aptr].a_codecf_off = header_offset + i;\n\n\t\t\t\t\t\tAVI->track[AVI->aptr].a_chans = str2ushort(hdrl_data+i+2);\n\t\t\t\t\t\tAVI->track[AVI->aptr].a_rate  = str2ulong (hdrl_data+i+4);\n\t\t\t\t\t\t//ThOe: read mp3bitrate\n\t\t\t\t\t\tAVI->track[AVI->aptr].mp3rate = 8*str2ulong(hdrl_data+i+8)/1000;\n\t\t\t\t\t\t//:ThOe\n\t\t\t\t\t\tAVI->track[AVI->aptr].a_bits  = str2ushort(hdrl_data+i+14);\n\t\t\t\t\t\t//            auds_strf_seen = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(strnicmp((char*)hdrl_data+i,\"indx\",4) == 0) {\n\t\t\t\t\tchar *a;\n\n\t\t\t\t\tif(lasttag == 1) // V I D E O\n\t\t\t\t\t{\n\n\t\t\t\t\t\ta = (char*)hdrl_data+i;\n\t\t\t\t\t\tint avail = hdrl_len-i;\n\t\t\t\t\t\tif (avail<32) ERR_EXIT(AVI_ERR_READ)\n\n\t\t\t\t\t\tAVI->video_superindex = (avisuperindex_chunk *) gf_malloc (sizeof (avisuperindex_chunk));\n\t\t\t\t\t\tmemset(AVI->video_superindex, 0, sizeof (avisuperindex_chunk));\n\t\t\t\t\t\tmemcpy (AVI->video_superindex->fcc, a, 4);\n\t\t\t\t\t\ta += 4;\n\t\t\t\t\t\tAVI->video_superindex->dwSize = str2ulong((unsigned char *)a);\n\t\t\t\t\t\ta += 4;\n\t\t\t\t\t\tAVI->video_superindex->wLongsPerEntry = str2ushort((unsigned char *)a);\n\t\t\t\t\t\ta += 2;\n\t\t\t\t\t\tAVI->video_superindex->bIndexSubType = *a;\n\t\t\t\t\t\ta += 1;\n\t\t\t\t\t\tAVI->video_superindex->bIndexType = *a;\n\t\t\t\t\t\ta += 1;\n\t\t\t\t\t\tAVI->video_superindex->nEntriesInUse = str2ulong((unsigned char *)a);\n\t\t\t\t\t\ta += 4;\n\t\t\t\t\t\tmemcpy (AVI->video_superindex->dwChunkId, a, 4);\n\t\t\t\t\t\ta += 4;\n\n\t\t\t\t\t\t// 3 * reserved\n\t\t\t\t\t\ta += 4;\n\t\t\t\t\t\ta += 4;\n\t\t\t\t\t\ta += 4;\n\n\t\t\t\t\t\tif (AVI->video_superindex->bIndexSubType != 0) {\n\t\t\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[avilib] Invalid Header, bIndexSubType != 0\\n\"));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tavail -= 32;\n\t\t\t\t\t\tif (avail < AVI->video_superindex->nEntriesInUse*16) ERR_EXIT(AVI_ERR_READ)\n\n\t\t\t\t\t\tAVI->video_superindex->aIndex = (avisuperindex_entry*)\n\t\t\t\t\t\t                                gf_malloc (AVI->video_superindex->wLongsPerEntry * AVI->video_superindex->nEntriesInUse * sizeof (u32));\n\n\t\t\t\t\t\t// position of ix## chunks\n\t\t\t\t\t\tfor (j=0; j<AVI->video_superindex->nEntriesInUse; ++j) {\n\t\t\t\t\t\t\tAVI->video_superindex->aIndex[j].qwOffset = str2ullong ((unsigned char*)a);\n\t\t\t\t\t\t\ta += 8;\n\t\t\t\t\t\t\tAVI->video_superindex->aIndex[j].dwSize = str2ulong ((unsigned char*)a);\n\t\t\t\t\t\t\ta += 4;\n\t\t\t\t\t\t\tAVI->video_superindex->aIndex[j].dwDuration = str2ulong ((unsigned char*)a);\n\t\t\t\t\t\t\ta += 4;\n\n#ifdef DEBUG_ODML\n\t\t\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] [%d] 0x%llx 0x%lx %lu\\n\", j,\n\t\t\t\t\t\t\t                                        (unsigned int long)AVI->video_superindex->aIndex[j].qwOffset,\n\t\t\t\t\t\t\t                                        (unsigned long)AVI->video_superindex->aIndex[j].dwSize,\n\t\t\t\t\t\t\t                                        (unsigned long)AVI->video_superindex->aIndex[j].dwDuration));\n#endif\n\t\t\t\t\t\t}\n\n\n#ifdef DEBUG_ODML\n\t\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] FOURCC \\\"%c%c%c%c\\\"\\n\", AVI->video_superindex->fcc[0], AVI->video_superindex->fcc[1],\n\t\t\t\t\t\t                                        AVI->video_superindex->fcc[2], AVI->video_superindex->fcc[3]));\n\t\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] LEN \\\"%ld\\\"\\n\", (long)AVI->video_superindex->dwSize));\n\t\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] wLongsPerEntry \\\"%d\\\"\\n\", AVI->video_superindex->wLongsPerEntry));\n\t\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] bIndexSubType \\\"%d\\\"\\n\", AVI->video_superindex->bIndexSubType));\n\t\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] bIndexType \\\"%d\\\"\\n\", AVI->video_superindex->bIndexType));\n\t\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] nEntriesInUse \\\"%ld\\\"\\n\", (long)AVI->video_superindex->nEntriesInUse));\n\t\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] dwChunkId \\\"%c%c%c%c\\\"\\n\", AVI->video_superindex->dwChunkId[0], AVI->video_superindex->dwChunkId[1],\n\t\t\t\t\t\t                                        AVI->video_superindex->dwChunkId[2], AVI->video_superindex->dwChunkId[3]));\n#endif\n\n\t\t\t\t\t\tAVI->is_opendml = 1;\n\n\t\t\t\t\t}\n\t\t\t\t\telse if(lasttag == 2) // A U D I O\n\t\t\t\t\t{\n\n\t\t\t\t\t\ta = (char*) hdrl_data+i;\n\t\t\t\t\t\tint avail = hdrl_len-i;\n\t\t\t\t\t\tif (avail<32) ERR_EXIT(AVI_ERR_READ)\n\n\t\t\t\t\t\tAVI->track[AVI->aptr].audio_superindex = (avisuperindex_chunk *) gf_malloc (sizeof (avisuperindex_chunk));\n\t\t\t\t\t\tmemcpy (AVI->track[AVI->aptr].audio_superindex->fcc, a, 4);\n\t\t\t\t\t\ta += 4;\n\t\t\t\t\t\tAVI->track[AVI->aptr].audio_superindex->dwSize = str2ulong((unsigned char*)a);\n\t\t\t\t\t\ta += 4;\n\t\t\t\t\t\tAVI->track[AVI->aptr].audio_superindex->wLongsPerEntry = str2ushort((unsigned char*)a);\n\t\t\t\t\t\ta += 2;\n\t\t\t\t\t\tAVI->track[AVI->aptr].audio_superindex->bIndexSubType = *a;\n\t\t\t\t\t\ta += 1;\n\t\t\t\t\t\tAVI->track[AVI->aptr].audio_superindex->bIndexType = *a;\n\t\t\t\t\t\ta += 1;\n\t\t\t\t\t\tAVI->track[AVI->aptr].audio_superindex->nEntriesInUse = str2ulong((unsigned char*)a);\n\t\t\t\t\t\ta += 4;\n\t\t\t\t\t\tmemcpy (AVI->track[AVI->aptr].audio_superindex->dwChunkId, a, 4);\n\t\t\t\t\t\ta += 4;\n\n\t\t\t\t\t\t// 3 * reserved\n\t\t\t\t\t\ta += 4;\n\t\t\t\t\t\ta += 4;\n\t\t\t\t\t\ta += 4;\n\n\t\t\t\t\t\tif (AVI->track[AVI->aptr].audio_superindex->bIndexSubType != 0) {\n\t\t\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[avilib] Invalid Header, bIndexSubType != 0\\n\"));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tavail -= 32;\n\t\t\t\t\t\tif (avail < AVI->track[AVI->aptr].audio_superindex->nEntriesInUse*16) ERR_EXIT(AVI_ERR_READ)\n\n\t\t\t\t\t\tAVI->track[AVI->aptr].audio_superindex->aIndex = (avisuperindex_entry*)\n\t\t\t\t\t\t        gf_malloc (AVI->track[AVI->aptr].audio_superindex->wLongsPerEntry *\n\t\t\t\t\t\t                   AVI->track[AVI->aptr].audio_superindex->nEntriesInUse * sizeof (u32));\n\n\t\t\t\t\t\t// position of ix## chunks\n\t\t\t\t\t\tfor (j=0; j<AVI->track[AVI->aptr].audio_superindex->nEntriesInUse; ++j) {\n\t\t\t\t\t\t\tAVI->track[AVI->aptr].audio_superindex->aIndex[j].qwOffset = str2ullong ((unsigned char*)a);\n\t\t\t\t\t\t\ta += 8;\n\t\t\t\t\t\t\tAVI->track[AVI->aptr].audio_superindex->aIndex[j].dwSize = str2ulong ((unsigned char*)a);\n\t\t\t\t\t\t\ta += 4;\n\t\t\t\t\t\t\tAVI->track[AVI->aptr].audio_superindex->aIndex[j].dwDuration = str2ulong ((unsigned char*)a);\n\t\t\t\t\t\t\ta += 4;\n\n#ifdef DEBUG_ODML\n\t\t\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] [%d] 0x%llx 0x%lx %lu\\n\", j,\n\t\t\t\t\t\t\t                                        (unsigned int long)AVI->track[AVI->aptr].audio_superindex->aIndex[j].qwOffset,\n\t\t\t\t\t\t\t                                        (unsigned long)AVI->track[AVI->aptr].audio_superindex->aIndex[j].dwSize,\n\t\t\t\t\t\t\t                                        (unsigned long)AVI->track[AVI->aptr].audio_superindex->aIndex[j].dwDuration));\n#endif\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tAVI->track[AVI->aptr].audio_superindex->stdindex = NULL;\n\n#ifdef DEBUG_ODML\n\t\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] FOURCC \\\"%.4s\\\"\\n\", AVI->track[AVI->aptr].audio_superindex->fcc));\n\t\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] LEN \\\"%ld\\\"\\n\", (long)AVI->track[AVI->aptr].audio_superindex->dwSize));\n\t\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] wLongsPerEntry \\\"%d\\\"\\n\", AVI->track[AVI->aptr].audio_superindex->wLongsPerEntry));\n\t\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] bIndexSubType \\\"%d\\\"\\n\", AVI->track[AVI->aptr].audio_superindex->bIndexSubType));\n\t\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] bIndexType \\\"%d\\\"\\n\", AVI->track[AVI->aptr].audio_superindex->bIndexType));\n\t\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] nEntriesInUse \\\"%ld\\\"\\n\", (long)AVI->track[AVI->aptr].audio_superindex->nEntriesInUse));\n\t\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] dwChunkId \\\"%.4s\\\"\\n\", AVI->track[AVI->aptr].audio_superindex->dwChunkId[0]));\n#endif\n\n\t\t\t\t\t}\n\t\t\t\t\ti += 8;\n\t\t\t\t}\n\t\t\t\telse if((strnicmp((char*)hdrl_data+i,\"JUNK\",4) == 0) ||\n\t\t\t\t        (strnicmp((char*)hdrl_data+i,\"strn\",4) == 0) ||\n\t\t\t\t        (strnicmp((char*)hdrl_data+i,\"vprp\",4) == 0)) {\n\t\t\t\t\ti += 8;\n\t\t\t\t\t// do not reset lasttag\n\t\t\t\t} else\n\t\t\t\t{\n\t\t\t\t\ti += 8;\n\t\t\t\t\tlasttag = 0;\n\t\t\t\t}\n\t\t\t\t//GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] adding %ld bytes\\n\", (int int)n));\n\n\t\t\t\ti += (u32) n;\n\t\t\t}\n\n\tgf_free(hdrl_data);\n\n\tif(!vids_strh_seen || !vids_strf_seen) ERR_EXIT(AVI_ERR_NO_VIDS)\n\n\t\tAVI->video_tag[0] = AVI->video_strn/10 + '0';\n\tAVI->video_tag[1] = AVI->video_strn%10 + '0';\n\tAVI->video_tag[2] = 'd';\n\tAVI->video_tag[3] = 'b';\n\n\t/* Audio tag is set to \"99wb\" if no audio present */\n\tif(!AVI->track[0].a_chans) AVI->track[0].audio_strn = 99;\n\n\t{\n\t\tint tk=0;\n\t\tfor(j=0; j<AVI->anum+1; ++j) {\n\t\t\tif (j == AVI->video_strn) continue;\n\t\t\tAVI->track[tk].audio_tag[0] = j/10 + '0';\n\t\t\tAVI->track[tk].audio_tag[1] = j%10 + '0';\n\t\t\tAVI->track[tk].audio_tag[2] = 'w';\n\t\t\tAVI->track[tk].audio_tag[3] = 'b';\n\t\t\t++tk;\n\t\t}\n\t}\n\n\tgf_fseek(AVI->fdes,AVI->movi_start,SEEK_SET);\n\n\tif(!getIndex) return(0);\n\n\t/* if the file has an idx1, check if this is relative\n\t   to the start of the file or to the start of the movi list */\n\n\tidx_type = 0;\n\n\tif(AVI->idx)\n\t{\n\t\ts64 pos, len;\n\n\t\t/* Search the first videoframe in the idx1 and look where\n\t\t   it is in the file */\n\n\t\tfor(i=0; i<AVI->n_idx; i++)\n\t\t\tif( strnicmp((char *)AVI->idx[i],(char *)AVI->video_tag,3)==0 ) break;\n\t\tif(i>=AVI->n_idx) ERR_EXIT(AVI_ERR_NO_VIDS)\n\n\t\t\tpos = str2ulong(AVI->idx[i]+ 8);\n\t\tlen = str2ulong(AVI->idx[i]+12);\n\n\t\tgf_fseek(AVI->fdes,pos,SEEK_SET);\n\t\tif(avi_read(AVI->fdes,data,8)!=8) ERR_EXIT(AVI_ERR_READ)\n\t\t\tif( strnicmp(data,(char *)AVI->idx[i],4)==0 && str2ulong((unsigned char *)data+4)==len )\n\t\t\t{\n\t\t\t\tidx_type = 1; /* Index from start of file */\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tgf_fseek(AVI->fdes,pos+AVI->movi_start-4,SEEK_SET);\n\t\t\t\tif(avi_read(AVI->fdes,data,8)!=8) ERR_EXIT(AVI_ERR_READ)\n\t\t\t\t\tif( strnicmp(data,(char *)AVI->idx[i],4)==0 && str2ulong((unsigned char *)data+4)==len )\n\t\t\t\t\t{\n\t\t\t\t\t\tidx_type = 2; /* Index from start of movi list */\n\t\t\t\t\t}\n\t\t\t}\n\t\t/* idx_type remains 0 if neither of the two tests above succeeds */\n\t}\n\n\n\tif(idx_type == 0 && !AVI->is_opendml && !AVI->total_frames)\n\t{\n\t\t/* we must search through the file to get the index */\n\n\t\tgf_fseek(AVI->fdes, AVI->movi_start, SEEK_SET);\n\n\t\tAVI->n_idx = 0;\n\n\t\twhile(1)\n\t\t{\n\t\t\tif( avi_read(AVI->fdes,data,8) != 8 ) break;\n\t\t\tn = str2ulong((unsigned char *)data+4);\n\n\t\t\t/* The movi list may contain sub-lists, ignore them */\n\n\t\t\tif(strnicmp(data,\"LIST\",4)==0)\n\t\t\t{\n\t\t\t\tgf_fseek(AVI->fdes,4,SEEK_CUR);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* Check if we got a tag ##db, ##dc or ##wb */\n\n\t\t\tif( ( (data[2]=='d' || data[2]=='D') &&\n\t\t\t        (data[3]=='b' || data[3]=='B' || data[3]=='c' || data[3]=='C') )\n\t\t\t        || ( (data[2]=='w' || data[2]=='W') &&\n\t\t\t             (data[3]=='b' || data[3]=='B') ) )\n\t\t\t{\n\t\t\t\tu64 __pos = gf_ftell(AVI->fdes) - 8;\n\t\t\t\tavi_add_index_entry(AVI,(unsigned char *)data,0,__pos,n);\n\t\t\t}\n\n\t\t\tgf_fseek(AVI->fdes,PAD_EVEN(n),SEEK_CUR);\n\t\t}\n\t\tidx_type = 1;\n\t}\n\n\t// ************************\n\t// OPENDML\n\t// ************************\n\n\t// read extended index chunks\n\tif (AVI->is_opendml) {\n\t\tu64 offset = 0;\n\t\thdrl_len = 4+4+2+1+1+4+4+8+4;\n\t\tchar *en, *chunk_start;\n\t\tint k = 0;\n\t\tu32 audtr = 0;\n\t\tu32 nrEntries = 0;\n\n\t\tAVI->video_index = NULL;\n\n\t\tnvi = 0;\n\t\tfor(audtr=0; audtr<AVI->anum; ++audtr) {\n\t\t\tnai[audtr] = 0;\n\t\t\ttot[audtr] = 0;\n\t\t}\n\n\t\t// ************************\n\t\t// VIDEO\n\t\t// ************************\n\n\t\tfor (j=0; j<AVI->video_superindex->nEntriesInUse; j++) {\n\n\t\t\t// read from file\n\t\t\tchunk_start = en = (char*) gf_malloc ((u32) (AVI->video_superindex->aIndex[j].dwSize+hdrl_len) );\n\n\t\t\tif (gf_fseek(AVI->fdes, AVI->video_superindex->aIndex[j].qwOffset, SEEK_SET) == (u64)-1) {\n\t\t\t\tgf_free(chunk_start);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (avi_read(AVI->fdes, en, (u32) (AVI->video_superindex->aIndex[j].dwSize+hdrl_len) ) <= 0) {\n\t\t\t\tgf_free(chunk_start);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tnrEntries = str2ulong((unsigned char*)en + 12);\n#ifdef DEBUG_ODML\n\t\t\t//GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] [%d:0] Video nrEntries %ld\\n\", j, nrEntries));\n#endif\n\t\t\toffset = str2ullong((unsigned char*)en + 20);\n\n\t\t\t// skip header\n\t\t\ten += hdrl_len;\n\t\t\tnvi += nrEntries;\n\t\t\tAVI->video_index = (video_index_entry *) gf_realloc (AVI->video_index, nvi * sizeof (video_index_entry));\n\t\t\tif (!AVI->video_index) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[avilib] out of mem (size = %ld)\\n\", nvi * sizeof (video_index_entry)));\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\twhile (k < nvi) {\n\n\t\t\t\tAVI->video_index[k].pos = offset + str2ulong((unsigned char*)en);\n\t\t\t\ten += 4;\n\t\t\t\tAVI->video_index[k].len = str2ulong_len((unsigned char*)en);\n\t\t\t\tAVI->video_index[k].key = str2ulong_key((unsigned char*)en);\n\t\t\t\ten += 4;\n\n\t\t\t\t// completely empty chunk\n\t\t\t\tif (AVI->video_index[k].pos-offset == 0 && AVI->video_index[k].len == 0) {\n\t\t\t\t\tk--;\n\t\t\t\t\tnvi--;\n\t\t\t\t}\n\n#ifdef DEBUG_ODML\n\t\t\t\t/*\n\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] [%d] POS 0x%llX len=%d key=%s offset (%llx) (%ld)\\n\", k,\n\t\t\t\t  AVI->video_index[k].pos,\n\t\t\t\t  (int)AVI->video_index[k].len,\n\t\t\t\t  AVI->video_index[k].key?\"yes\":\"no \", offset,\n\t\t\t\t  AVI->video_superindex->aIndex[j].dwSize));\n\t\t\t\t  */\n#endif\n\n\t\t\t\tk++;\n\t\t\t}\n\n\t\t\tgf_free(chunk_start);\n\t\t}\n\n\t\tAVI->video_frames = nvi;\n\t\t// this should deal with broken 'rec ' odml files.\n\t\tif (AVI->video_frames == 0) {\n\t\t\tAVI->is_opendml=0;\n\t\t\tgoto multiple_riff;\n\t\t}\n\n\t\t// ************************\n\t\t// AUDIO\n\t\t// ************************\n\n\t\tfor(audtr=0; audtr<AVI->anum; ++audtr) {\n\n\t\t\tk = 0;\n\t\t\tif (!AVI->track[audtr].audio_superindex) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[avilib] (%s) cannot read audio index for track %d\\n\", __FILE__, audtr));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor (j=0; j<AVI->track[audtr].audio_superindex->nEntriesInUse; j++) {\n\n\t\t\t\t// read from file\n\t\t\t\tchunk_start = en = (char*)gf_malloc ((u32) (AVI->track[audtr].audio_superindex->aIndex[j].dwSize+hdrl_len));\n\n\t\t\t\tif (gf_fseek(AVI->fdes, AVI->track[audtr].audio_superindex->aIndex[j].qwOffset, SEEK_SET) == (u64)-1) {\n\t\t\t\t\tgf_free(chunk_start);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (avi_read(AVI->fdes, en, (u32) (AVI->track[audtr].audio_superindex->aIndex[j].dwSize+hdrl_len)) <= 0) {\n\t\t\t\t\tgf_free(chunk_start);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tnrEntries = str2ulong((unsigned char*)en + 12);\n\t\t\t\t//if (nrEntries > 50) nrEntries = 2; // XXX\n#ifdef DEBUG_ODML\n\t\t\t\t//GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] [%d:%d] Audio nrEntries %ld\\n\", j, audtr, nrEntries));\n#endif\n\t\t\t\toffset = str2ullong((unsigned char*)en + 20);\n\n\t\t\t\t// skip header\n\t\t\t\ten += hdrl_len;\n\t\t\t\tnai[audtr] += nrEntries;\n\t\t\t\tAVI->track[audtr].audio_index = (audio_index_entry *) gf_realloc (AVI->track[audtr].audio_index, nai[audtr] * sizeof (audio_index_entry));\n\n\t\t\t\twhile (k < nai[audtr]) {\n\n\t\t\t\t\tAVI->track[audtr].audio_index[k].pos = offset + str2ulong((unsigned char*)en);\n\t\t\t\t\ten += 4;\n\t\t\t\t\tAVI->track[audtr].audio_index[k].len = str2ulong_len((unsigned char*)en);\n\t\t\t\t\ten += 4;\n\t\t\t\t\tAVI->track[audtr].audio_index[k].tot = tot[audtr];\n\t\t\t\t\ttot[audtr] += AVI->track[audtr].audio_index[k].len;\n\n#ifdef DEBUG_ODML\n\t\t\t\t\t/*\n\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] [%d:%d] POS 0x%llX len=%d offset (%llx) (%ld)\\n\", k, audtr,\n\t\t\t\t\t  AVI->track[audtr].audio_index[k].pos,\n\t\t\t\t\t  (int)AVI->track[audtr].audio_index[k].len,\n\t\t\t\t\t  offset, AVI->track[audtr].audio_superindex->aIndex[j].dwSize));\n\t\t\t\t\t  */\n#endif\n\n\t\t\t\t\t++k;\n\t\t\t\t}\n\n\t\t\t\tgf_free(chunk_start);\n\t\t\t}\n\n\t\t\tAVI->track[audtr].audio_chunks = nai[audtr];\n\t\t\tAVI->track[audtr].audio_bytes = tot[audtr];\n\t\t}\n\t} // is opendml\n\n\telse if (AVI->total_frames && !AVI->is_opendml && idx_type==0) {\n\n\t\t// *********************\n\t\t// MULTIPLE RIFF CHUNKS (and no index)\n\t\t// *********************\n\nmultiple_riff:\n\n\t\tgf_fseek(AVI->fdes, AVI->movi_start, SEEK_SET);\n\n\t\tAVI->n_idx = 0;\n\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] Reconstructing index...\"));\n\n\t\t// Number of frames; only one audio track supported\n\t\tnvi = AVI->video_frames = AVI->total_frames;\n\t\tnai[0] = AVI->track[0].audio_chunks = AVI->total_frames;\n\t\tfor(j=1; j<AVI->anum; ++j) AVI->track[j].audio_chunks = 0;\n\n\t\tAVI->video_index = (video_index_entry *) gf_malloc(nvi*sizeof(video_index_entry));\n\n\t\tif(AVI->video_index==0) ERR_EXIT(AVI_ERR_NO_MEM);\n\n\t\tfor(j=0; j<AVI->anum; ++j) {\n\t\t\tif(AVI->track[j].audio_chunks) {\n\t\t\t\tAVI->track[j].audio_index = (audio_index_entry *) gf_malloc((nai[j]+1)*sizeof(audio_index_entry));\n\t\t\t\tmemset(AVI->track[j].audio_index, 0, (nai[j]+1)*(sizeof(audio_index_entry)));\n\t\t\t\tif(AVI->track[j].audio_index==0) ERR_EXIT(AVI_ERR_NO_MEM);\n\t\t\t}\n\t\t}\n\n\t\tnvi = 0;\n\t\tfor(j=0; j<AVI->anum; ++j) {\n\t\t\tnai[j] = 0;\n\t\t\ttot[j] = 0;\n\t\t}\n\n\t\taud_chunks = AVI->total_frames;\n\n\t\twhile(1)\n\t\t{\n\t\t\tif (nvi >= AVI->total_frames) break;\n\n\t\t\tif( avi_read(AVI->fdes,data,8) != 8 ) break;\n\t\t\tn = str2ulong((unsigned char *)data+4);\n\n\n\t\t\tj=0;\n\n\t\t\tif (aud_chunks - nai[j] -1 <= 0) {\n\t\t\t\taud_chunks += AVI->total_frames;\n\t\t\t\tAVI->track[j].audio_index = (audio_index_entry *)\n\t\t\t\t                            gf_realloc( AVI->track[j].audio_index, (aud_chunks+1)*sizeof(audio_index_entry));\n\t\t\t\tif (!AVI->track[j].audio_index) {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[avilib] Internal error in avilib -- no mem\\n\"));\n\t\t\t\t\tAVI_errno = AVI_ERR_NO_MEM;\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* Check if we got a tag ##db, ##dc or ##wb */\n\n\t\t\t// VIDEO\n\t\t\tif(\n\t\t\t    (data[0]=='0' || data[1]=='0') &&\n\t\t\t    (data[2]=='d' || data[2]=='D') &&\n\t\t\t    (data[3]=='b' || data[3]=='B' || data[3]=='c' || data[3]=='C') ) {\n\n\t\t\t\tAVI->video_index[nvi].key = 0x0;\n\t\t\t\tAVI->video_index[nvi].pos = gf_ftell(AVI->fdes);\n\t\t\t\tAVI->video_index[nvi].len = (u32) n;\n\n\t\t\t\t/*\n\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] Frame %ld pos %\"LLD\" len %\"LLD\" key %ld\\n\",\n\t\t\t\t    nvi, AVI->video_index[nvi].pos,  AVI->video_index[nvi].len, (long)AVI->video_index[nvi].key));\n\t\t\t\t    */\n\t\t\t\tnvi++;\n\t\t\t\tgf_fseek(AVI->fdes,PAD_EVEN(n),SEEK_CUR);\n\t\t\t}\n\n\t\t\t//AUDIO\n\t\t\telse if(\n\t\t\t    (data[0]=='0' || data[1]=='1') &&\n\t\t\t    (data[2]=='w' || data[2]=='W') &&\n\t\t\t    (data[3]=='b' || data[3]=='B') ) {\n\n\n\t\t\t\tAVI->track[j].audio_index[nai[j]].pos = gf_ftell(AVI->fdes);\n\t\t\t\tAVI->track[j].audio_index[nai[j]].len = (u32) n;\n\t\t\t\tAVI->track[j].audio_index[nai[j]].tot = tot[j];\n\t\t\t\ttot[j] += AVI->track[j].audio_index[nai[j]].len;\n\t\t\t\tnai[j]++;\n\n\t\t\t\tgf_fseek(AVI->fdes,PAD_EVEN(n),SEEK_CUR);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tgf_fseek(AVI->fdes,-4,SEEK_CUR);\n\t\t\t}\n\n\t\t}\n\t\tif (nvi < AVI->total_frames) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[avilib] Uh? Some frames seems missing (%ld/%d)\\n\",\n\t\t\t        nvi,  AVI->total_frames));\n\t\t}\n\n\n\t\tAVI->video_frames = nvi;\n\t\tAVI->track[0].audio_chunks = nai[0];\n\n\t\tfor(j=0; j<AVI->anum; ++j) AVI->track[j].audio_bytes = tot[j];\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] done. nvi=%ld nai=%ld tot=%ld\\n\", nvi, nai[0], tot[0]));\n\n\t} // total_frames but no indx chunk (xawtv does this)\n\n\telse\n\n\t{\n\t\t// ******************\n\t\t// NO OPENDML\n\t\t// ******************\n\n\t\t/* Now generate the video index and audio index arrays */\n\n\t\tnvi = 0;\n\t\tfor(j=0; j<AVI->anum; ++j) nai[j] = 0;\n\n\t\tfor(i=0; i<AVI->n_idx; i++) {\n\n\t\t\tif(strnicmp((char *)AVI->idx[i],AVI->video_tag,3) == 0) nvi++;\n\n\t\t\tfor(j=0; j<AVI->anum; ++j) if(strnicmp((char *)AVI->idx[i], AVI->track[j].audio_tag,4) == 0) nai[j]++;\n\t\t}\n\n\t\tAVI->video_frames = nvi;\n\t\tfor(j=0; j<AVI->anum; ++j) AVI->track[j].audio_chunks = nai[j];\n\n\n\t\tif(AVI->video_frames==0) ERR_EXIT(AVI_ERR_NO_VIDS);\n\t\tAVI->video_index = (video_index_entry *) gf_malloc(nvi*sizeof(video_index_entry));\n\t\tif(AVI->video_index==0) ERR_EXIT(AVI_ERR_NO_MEM);\n\n\t\tfor(j=0; j<AVI->anum; ++j) {\n\t\t\tif(AVI->track[j].audio_chunks) {\n\t\t\t\tAVI->track[j].audio_index = (audio_index_entry *) gf_malloc((nai[j]+1)*sizeof(audio_index_entry));\n\t\t\t\tmemset(AVI->track[j].audio_index, 0, (nai[j]+1)*(sizeof(audio_index_entry)));\n\t\t\t\tif(AVI->track[j].audio_index==0) ERR_EXIT(AVI_ERR_NO_MEM);\n\t\t\t}\n\t\t}\n\n\t\tnvi = 0;\n\t\tfor(j=0; j<AVI->anum; ++j) {\n\t\t\tnai[j] = 0;\n\t\t\ttot[j] = 0;\n\t\t}\n\n\t\tioff = idx_type == 1 ? 8 : (u32)AVI->movi_start+4;\n\n\t\tfor(i=0; i<AVI->n_idx; i++) {\n\n\t\t\t//video\n\t\t\tif(strnicmp((char *)AVI->idx[i],AVI->video_tag,3) == 0) {\n\t\t\t\tAVI->video_index[nvi].key = str2ulong(AVI->idx[i]+ 4);\n\t\t\t\tAVI->video_index[nvi].pos = str2ulong(AVI->idx[i]+ 8)+ioff;\n\t\t\t\tAVI->video_index[nvi].len = str2ulong(AVI->idx[i]+12);\n\t\t\t\tnvi++;\n\t\t\t}\n\n\t\t\t//audio\n\t\t\tfor(j=0; j<AVI->anum; ++j) {\n\n\t\t\t\tif(strnicmp((char *)AVI->idx[i],AVI->track[j].audio_tag,4) == 0) {\n\t\t\t\t\tAVI->track[j].audio_index[nai[j]].pos = str2ulong(AVI->idx[i]+ 8)+ioff;\n\t\t\t\t\tAVI->track[j].audio_index[nai[j]].len = str2ulong(AVI->idx[i]+12);\n\t\t\t\t\tAVI->track[j].audio_index[nai[j]].tot = tot[j];\n\t\t\t\t\ttot[j] += AVI->track[j].audio_index[nai[j]].len;\n\t\t\t\t\tnai[j]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\t\tfor(j=0; j<AVI->anum; ++j) AVI->track[j].audio_bytes = tot[j];\n\n\t} // is no opendml\n\n\t/* Reposition the file */\n\n\tgf_fseek(AVI->fdes,AVI->movi_start,SEEK_SET);\n\tAVI->video_pos = 0;\n\n\treturn(0);\n}\n\nint AVI_video_frames(avi_t *AVI)\n{\n\treturn AVI->video_frames;\n}\nint  AVI_video_width(avi_t *AVI)\n{\n\treturn AVI->width;\n}\nint  AVI_video_height(avi_t *AVI)\n{\n\treturn AVI->height;\n}\ndouble AVI_frame_rate(avi_t *AVI)\n{\n\treturn AVI->fps;\n}\nchar* AVI_video_compressor(avi_t *AVI)\n{\n\treturn AVI->compressor2;\n}\n\n#if 0\nint AVI_max_video_chunk(avi_t *AVI)\n{\n\treturn AVI->max_len;\n}\n#endif\n\nint AVI_audio_tracks(avi_t *AVI)\n{\n\treturn(AVI->anum);\n}\n\nint AVI_audio_channels(avi_t *AVI)\n{\n\treturn AVI->track[AVI->aptr].a_chans;\n}\n\nint AVI_audio_mp3rate(avi_t *AVI)\n{\n\treturn AVI->track[AVI->aptr].mp3rate;\n}\n\n#if 0 //unused\nint AVI_audio_padrate(avi_t *AVI)\n{\n\treturn AVI->track[AVI->aptr].padrate;\n}\n#endif\n\nint AVI_audio_bits(avi_t *AVI)\n{\n\treturn AVI->track[AVI->aptr].a_bits;\n}\n\nint AVI_audio_format(avi_t *AVI)\n{\n\treturn AVI->track[AVI->aptr].a_fmt;\n}\n\nint AVI_audio_rate(avi_t *AVI)\n{\n\treturn AVI->track[AVI->aptr].a_rate;\n}\n\n\nint AVI_frame_size(avi_t *AVI, int frame)\n{\n\tif(AVI->mode==AVI_MODE_WRITE) {\n\t\tAVI_errno = AVI_ERR_NOT_PERM;\n\t\treturn -1;\n\t}\n\tif(!AVI->video_index)         {\n\t\tAVI_errno = AVI_ERR_NO_IDX;\n\t\treturn -1;\n\t}\n\n\tif(frame < 0 || frame >= AVI->video_frames) return 0;\n\treturn (u32) (AVI->video_index[frame].len);\n}\n\nint AVI_audio_size(avi_t *AVI, int frame)\n{\n\tif(AVI->mode==AVI_MODE_WRITE) {\n\t\tAVI_errno = AVI_ERR_NOT_PERM;\n\t\treturn -1;\n\t}\n\tif(!AVI->track[AVI->aptr].audio_index)         {\n\t\tAVI_errno = AVI_ERR_NO_IDX;\n\t\treturn -1;\n\t}\n\n\tif(frame < 0 || frame >= AVI->track[AVI->aptr].audio_chunks) return -1;\n\treturn (u32) (AVI->track[AVI->aptr].audio_index[frame].len);\n}\n\nu64 AVI_get_video_position(avi_t *AVI, int frame)\n{\n\tif(AVI->mode==AVI_MODE_WRITE) {\n\t\tAVI_errno = AVI_ERR_NOT_PERM;\n\t\treturn (u64) -1;\n\t}\n\tif(!AVI->video_index)         {\n\t\tAVI_errno = AVI_ERR_NO_IDX;\n\t\treturn (u64) -1;\n\t}\n\n\tif(frame < 0 || frame >= AVI->video_frames) return 0;\n\treturn(AVI->video_index[frame].pos);\n}\n\n\nint AVI_seek_start(avi_t *AVI)\n{\n\tif(AVI->mode==AVI_MODE_WRITE) {\n\t\tAVI_errno = AVI_ERR_NOT_PERM;\n\t\treturn -1;\n\t}\n\n\tgf_fseek(AVI->fdes,AVI->movi_start,SEEK_SET);\n\tAVI->video_pos = 0;\n\treturn 0;\n}\n\nint AVI_set_video_position(avi_t *AVI, int frame)\n{\n\tif(AVI->mode==AVI_MODE_WRITE) {\n\t\tAVI_errno = AVI_ERR_NOT_PERM;\n\t\treturn -1;\n\t}\n\tif(!AVI->video_index)         {\n\t\tAVI_errno = AVI_ERR_NO_IDX;\n\t\treturn -1;\n\t}\n\n\tif (frame < 0 ) frame = 0;\n\tAVI->video_pos = frame;\n\treturn 0;\n}\n\n#if 0 //unused\nint AVI_set_audio_bitrate(avi_t *AVI, int bitrate)\n{\n\tif(AVI->mode==AVI_MODE_READ) {\n\t\tAVI_errno = AVI_ERR_NOT_PERM;\n\t\treturn -1;\n\t}\n\n\tAVI->track[AVI->aptr].mp3rate = bitrate;\n\treturn 0;\n}\n#endif\n\nint AVI_read_frame(avi_t *AVI, u8 *vidbuf, int *keyframe)\n{\n\tint n;\n\n\tif(AVI->mode==AVI_MODE_WRITE) {\n\t\tAVI_errno = AVI_ERR_NOT_PERM;\n\t\treturn -1;\n\t}\n\tif(!AVI->video_index)         {\n\t\tAVI_errno = AVI_ERR_NO_IDX;\n\t\treturn -1;\n\t}\n\n\tif(AVI->video_pos < 0 || AVI->video_pos >= AVI->video_frames) return -1;\n\tn = (u32) AVI->video_index[AVI->video_pos].len;\n\n\t*keyframe = (AVI->video_index[AVI->video_pos].key==0x10) ? 1:0;\n\n\tif (vidbuf == NULL) {\n\t\tAVI->video_pos++;\n\t\treturn n;\n\t}\n\n\tgf_fseek(AVI->fdes, AVI->video_index[AVI->video_pos].pos, SEEK_SET);\n\tAVI->video_pos++;\n\n\tif (avi_read(AVI->fdes,vidbuf,n) != (u32) n)\n\t{\n\t\tAVI_errno = AVI_ERR_READ;\n\t\treturn -1;\n\t}\n\n\treturn n;\n}\n\n#if 0 //unused\nint AVI_get_audio_position_index(avi_t *AVI)\n{\n\tif(AVI->mode==AVI_MODE_WRITE) {\n\t\tAVI_errno = AVI_ERR_NOT_PERM;\n\t\treturn -1;\n\t}\n\tif(!AVI->track[AVI->aptr].audio_index) {\n\t\tAVI_errno = AVI_ERR_NO_IDX;\n\t\treturn -1;\n\t}\n\n\treturn (AVI->track[AVI->aptr].audio_posc);\n}\n\nint AVI_set_audio_position_index(avi_t *AVI, int indexpos)\n{\n\tif(AVI->mode==AVI_MODE_WRITE) {\n\t\tAVI_errno = AVI_ERR_NOT_PERM;\n\t\treturn -1;\n\t}\n\tif(!AVI->track[AVI->aptr].audio_index)         {\n\t\tAVI_errno = AVI_ERR_NO_IDX;\n\t\treturn -1;\n\t}\n\tif(indexpos > AVI->track[AVI->aptr].audio_chunks)     {\n\t\tAVI_errno = AVI_ERR_NO_IDX;\n\t\treturn -1;\n\t}\n\n\tAVI->track[AVI->aptr].audio_posc = indexpos;\n\tAVI->track[AVI->aptr].audio_posb = 0;\n\n\treturn 0;\n}\n#endif\n\n\nint AVI_set_audio_position(avi_t *AVI, int byte)\n{\n\tint n0, n1;\n\n\tif(AVI->mode==AVI_MODE_WRITE) {\n\t\tAVI_errno = AVI_ERR_NOT_PERM;\n\t\treturn -1;\n\t}\n\tif(!AVI->track[AVI->aptr].audio_index)         {\n\t\tAVI_errno = AVI_ERR_NO_IDX;\n\t\treturn -1;\n\t}\n\n\tif(byte < 0) byte = 0;\n\n\t/* Binary search in the audio chunks */\n\n\tn0 = 0;\n\tn1 = AVI->track[AVI->aptr].audio_chunks;\n\n\twhile(n0<n1-1)\n\t{\n\t\tint n = (n0+n1)/2;\n\t\tif(AVI->track[AVI->aptr].audio_index[n].tot>(u32) byte)\n\t\t\tn1 = n;\n\t\telse\n\t\t\tn0 = n;\n\t}\n\n\tAVI->track[AVI->aptr].audio_posc = n0;\n\tAVI->track[AVI->aptr].audio_posb = (u32) (byte - AVI->track[AVI->aptr].audio_index[n0].tot);\n\n\treturn 0;\n}\n\n\nint AVI_read_audio(avi_t *AVI, u8 *audbuf, int bytes, int *continuous)\n{\n\tint nr, todo;\n\ts64 pos;\n\n\tif(AVI->mode==AVI_MODE_WRITE) {\n\t\tAVI_errno = AVI_ERR_NOT_PERM;\n\t\treturn -1;\n\t}\n\tif(!AVI->track[AVI->aptr].audio_index)         {\n\t\tAVI_errno = AVI_ERR_NO_IDX;\n\t\treturn -1;\n\t}\n\n\tnr = 0; /* total number of bytes read */\n\n\tif (bytes==0) {\n\t\tAVI->track[AVI->aptr].audio_posc++;\n\t\tAVI->track[AVI->aptr].audio_posb = 0;\n\t}\n\n\t*continuous = 1;\n\twhile(bytes>0)\n\t{\n\t\ts64 ret;\n\t\tint left = (int) (AVI->track[AVI->aptr].audio_index[AVI->track[AVI->aptr].audio_posc].len - AVI->track[AVI->aptr].audio_posb);\n\t\tif(left==0)\n\t\t{\n\t\t\tif(AVI->track[AVI->aptr].audio_posc>=AVI->track[AVI->aptr].audio_chunks-1) return nr;\n\t\t\tAVI->track[AVI->aptr].audio_posc++;\n\t\t\tAVI->track[AVI->aptr].audio_posb = 0;\n\t\t\t*continuous = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif(bytes<left)\n\t\t\ttodo = bytes;\n\t\telse\n\t\t\ttodo = left;\n\t\tpos = AVI->track[AVI->aptr].audio_index[AVI->track[AVI->aptr].audio_posc].pos + AVI->track[AVI->aptr].audio_posb;\n\t\tgf_fseek(AVI->fdes, pos, SEEK_SET);\n\t\tAVI->track[AVI->aptr].audio_posb += todo;\n\t\tif ( (ret = avi_read(AVI->fdes,audbuf+nr,todo)) != todo)\n\t\t{\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[avilib] XXX pos = %\"LLD\", ret = %\"LLD\", todo = %ld\\n\", pos, ret, todo));\n\t\t\tAVI_errno = AVI_ERR_READ;\n\t\t\treturn -1;\n\t\t}\n\t\tbytes -= todo;\n\t\tnr    += todo;\n\t}\n\n\treturn nr;\n}\n\n\n#if 0 //unused\n/* AVI_read_data: Special routine for reading the next audio or video chunk\n                  without having an index of the file. */\n\nint AVI_read_data(avi_t *AVI, char *vidbuf, int max_vidbuf,\n                  char *audbuf, int max_audbuf,\n                  int *len)\n{\n\n\t/*\n\t * Return codes:\n\t *\n\t *    1 = video data read\n\t *    2 = audio data read\n\t *    0 = reached EOF\n\t *   -1 = video buffer too small\n\t *   -2 = audio buffer too small\n\t */\n\n\ts64 n;\n\tchar data[8];\n\n\tif(AVI->mode==AVI_MODE_WRITE) return 0;\n\n\twhile(1)\n\t{\n\t\t/* Read tag and length */\n\n\t\tif( avi_read(AVI->fdes,data,8) != 8 ) return 0;\n\n\t\t/* if we got a list tag, ignore it */\n\n\t\tif(strnicmp(data,\"LIST\",4) == 0)\n\t\t{\n\t\t\tgf_fseek(AVI->fdes,4,SEEK_CUR);\n\t\t\tcontinue;\n\t\t}\n\n\t\tn = PAD_EVEN(str2ulong((unsigned char *)data+4));\n\n\t\tif(strnicmp(data,AVI->video_tag,3) == 0)\n\t\t{\n\t\t\t*len = (u32) n;\n\t\t\tAVI->video_pos++;\n\t\t\tif(n>max_vidbuf)\n\t\t\t{\n\t\t\t\tgf_fseek(AVI->fdes,n,SEEK_CUR);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif(avi_read(AVI->fdes,vidbuf, (u32) n) != n ) return 0;\n\t\t\treturn 1;\n\t\t}\n\t\telse if(strnicmp(data,AVI->track[AVI->aptr].audio_tag,4) == 0)\n\t\t{\n\t\t\t*len = (u32) n;\n\t\t\tif(n>max_audbuf)\n\t\t\t{\n\t\t\t\tgf_fseek(AVI->fdes,n,SEEK_CUR);\n\t\t\t\treturn -2;\n\t\t\t}\n\t\t\tif(avi_read(AVI->fdes,audbuf, (u32) n) != n ) return 0;\n\t\t\treturn 2;\n\t\t\tbreak;\n\t\t}\n\t\telse if(gf_fseek(AVI->fdes,n,SEEK_CUR) == (u64) -1)  return 0;\n\t}\n}\n\nu64 AVI_max_size(void)\n{\n\treturn((u64) AVI_MAX_LEN);\n}\n#endif\n\n\n#endif /*GPAC_DISABLE_AVILIB*/\n", "/*\n * The contents of this file are subject to the Mozilla Public\n * License Version 1.1 (the \"License\"); you may not use this file\n * except in compliance with the License. You may obtain a copy of\n * the License at http://www.mozilla.org/MPL/\n *\n * Software distributed under the License is distributed on an \"AS\n * IS\" basis, WITHOUT WARRANTY OF ANY KIND, either express or\n * implied. See the License for the specific language governing\n * rights and limitations under the License.\n *\n * The Original Code is MPEG4IP.\n *\n * The Initial Developer of the Original Code is Cisco Systems Inc.\n * Portions created by Cisco Systems Inc. are\n * Copyright (C) Cisco Systems Inc. 2004.  All Rights Reserved.\n *\n * Contributor(s):\n *\t\tBill May wmay@cisco.com\n */\n\n/*\n * mpeg2ps.c - parse program stream and vob files\n */\n#include \"mpeg2_ps.h\"\n\n#ifndef GPAC_DISABLE_MPEG2PS\n\n\nstatic GFINLINE u16 convert16 (u8 *p)\n{\n#ifdef GPAC_BIG_ENDIAN\n\treturn *(u16 *)p;\n#else\n\tu16 val = p[0];\n\tval <<= 8;\n\treturn (val | p[1]);\n#endif\n}\n\nstatic GFINLINE u32 convert32 (u8 *p)\n{\n#ifdef GPAC_BIG_ENDIAN\n\treturn *(u32 *)p;\n#else\n\tu32 val;\n\tval = p[0];\n\tval <<= 8;\n\tval |= p[1];\n\tval <<= 8;\n\tval |= p[2];\n\tval <<= 8;\n\tval |= p[3];\n\treturn val;\n#endif\n}\n\n#define FDNULL 0\n\n/*\n * structure for passing timestamps around\n */\ntypedef struct mpeg2ps_ts_t\n{\n\tBool have_pts;\n\tBool have_dts;\n\tu64 pts;\n\tu64 dts;\n} mpeg2ps_ts_t;\n\ntypedef struct mpeg2ps_record_pes_t\n{\n\tstruct mpeg2ps_record_pes_t *next_rec;\n\tu64 dts;\n\tu64 location;\n} mpeg2ps_record_pes_t;\n\n/*\n * information about reading a stream\n */\ntypedef struct mpeg2ps_stream_t\n{\n\tmpeg2ps_record_pes_t *record_first, *record_last;\n\tFILE *m_fd;\n\tBool is_video;\n\tu8 m_stream_id;    // program stream id\n\tu8 m_substream_id; // substream, for program stream id == 0xbd\n\n\tmpeg2ps_ts_t next_pes_ts, frame_ts;\n\tu32 frames_since_last_ts;\n\tu64 last_ts;\n\n\tBool have_frame_loaded;\n\t/*\n\t * pes_buffer processing.  this contains the raw elementary stream data\n\t */\n\tu8 *pes_buffer;\n\tu32 pes_buffer_size;\n\tu32 pes_buffer_size_max;\n\tu32 pes_buffer_on;\n\tu32 frame_len;\n\tu32 pict_header_offset; // for mpeg video\n\n\t// timing information and locations.\n\ts64 first_pes_loc;\n\tu64 start_dts;\n\tBool first_pes_has_dts;\n\ts64    end_dts_loc;\n\tu64 end_dts;\n\t// audio stuff\n\tu32 freq;\n\tu32 channels;\n\tu32 bitrate;\n\tu32 samples_per_frame;\n\tu32 layer;\n\t// video stuff\n\tu32 h, w, par;\n\tDouble frame_rate;\n\ts32 have_mpeg2;\n\tDouble bit_rate;\n\tu64 ticks_per_frame;\n\n} mpeg2ps_stream_t;\n\n/*\n * main interface structure - contains stream pointers and other\n * information\n */\nstruct mpeg2ps_ {\n\tmpeg2ps_stream_t *video_streams[16];\n\tmpeg2ps_stream_t *audio_streams[32];\n\tchar *filename;\n\tFILE *fd;\n\tu64 first_dts;\n\tu32 audio_cnt, video_cnt;\n\ts64 end_loc;\n\tu64 max_dts;\n\tu64 max_time;  // time is in msec.\n};\n\n/*************************************************************************\n * File access routines.  Could all be inline\n *************************************************************************/\nstatic FILE *file_open (const char *name)\n{\n\treturn gf_fopen(name, \"rb\");\n}\n\nstatic Bool file_okay (FILE *fd)\n{\n\treturn (fd!=NULL) ? 1 : 0;\n}\n\nstatic void file_close (FILE *fd)\n{\n\tgf_fclose(fd);\n}\n\nstatic Bool file_read_bytes(FILE *fd,\n                            u8 *buffer,\n                            u32 len)\n{\n\tu32 readval = (u32) gf_fread(buffer, len, fd);\n\treturn readval == len;\n}\n\n// note: len could be negative.\nstatic void file_skip_bytes (FILE *fd, s32 len)\n{\n\tgf_fseek(fd, len, SEEK_CUR);\n}\n\n#define file_location(__f) gf_ftell(__f)\n#define file_seek_to(__f, __off) gf_fseek(__f, __off, SEEK_SET)\n\nstatic u64 file_size(FILE *fd)\n{\n\treturn gf_fsize(fd);\n}\n\nstatic mpeg2ps_record_pes_t *create_record (s64 loc, u64 ts)\n{\n\tmpeg2ps_record_pes_t *ret;\n\tGF_SAFEALLOC(ret, mpeg2ps_record_pes_t);\n\tif (!ret) return NULL;\n\tret->next_rec = NULL;\n\tret->dts = ts;\n\tret->location = loc;\n\treturn ret;\n}\n\n#define MPEG2PS_RECORD_TIME ((u64) (5 * 90000))\nvoid mpeg2ps_record_pts (mpeg2ps_stream_t *sptr, s64 location, mpeg2ps_ts_t *pTs)\n{\n\tu64 ts;\n\tmpeg2ps_record_pes_t *p, *q;\n\tif (sptr->is_video) {\n\t\tif (pTs->have_dts == 0) return;\n\t\tts = pTs->dts;\n\t} else {\n\t\tif (pTs->have_pts == 0) return;\n\t\tts = pTs->pts;\n\t}\n\n\tif (sptr->record_first == NULL) {\n\t\tsptr->record_first = sptr->record_last = create_record(location, ts);\n\t\treturn;\n\t}\n\tif (ts > sptr->record_last->dts) {\n\t\tif (ts < MPEG2PS_RECORD_TIME + sptr->record_last->dts) return;\n\t\tsptr->record_last->next_rec = create_record(location, ts);\n\t\tsptr->record_last = sptr->record_last->next_rec;\n\t\treturn;\n\t}\n\tif (ts < sptr->record_first->dts) {\n\t\tif (ts < MPEG2PS_RECORD_TIME + sptr->record_first->dts) return;\n\t\tp = create_record(location, ts);\n\t\tp->next_rec = sptr->record_first;\n\t\tsptr->record_first = p;\n\t\treturn;\n\t}\n\tp = sptr->record_first;\n\tq = p->next_rec;\n\n\twhile (q != NULL && q->dts < ts) {\n\t\tp = q;\n\t\tq = q->next_rec;\n\t}\n\tif (q) {\n\t\tif (p->dts + MPEG2PS_RECORD_TIME <= ts &&\n\t\t\t\tts + MPEG2PS_RECORD_TIME <= q->dts) {\n\t\t\tp->next_rec = create_record(location, ts);\n\t\t\tp->next_rec->next_rec = q;\n\t\t}\n\t}\n}\nstatic Double mpeg12_frame_rate_table[16] =\n{\n\t0.0,   /* Pad */\n\t24000.0/1001.0,       /* Official frame rates */\n\t24.0,\n\t25.0,\n\t30000.0/1001.0,\n\t30.0,\n\t50.0,\n\t((60.0*1000.0)/1001.0),\n\t60.0,\n\n\t1,                    /* Unofficial economy rates */\n\t5,\n\t10,\n\t12,\n\t15,\n\t0,\n\t0,\n};\n\n#define SEQ_ID 1\nint MPEG12_ParseSeqHdr(unsigned char *pbuffer, u32 buflen, s32 *have_mpeg2, u32 *height, u32 *width,\n                       Double *frame_rate, Double *bitrate, u32 *aspect_ratio)\n{\n\tu32 aspect_code;\n\tu32 framerate_code;\n\tu32 bitrate_int;\n\tu32 bitrate_ext;\n\tu32 scode, ix;\n\ts32 found = -1;\n\t*have_mpeg2 = 0;\n\tbuflen -= 6;\n\tbitrate_int = 0;\n\tfor (ix = 0; ix < buflen; ix++, pbuffer++) {\n\t\tscode = ((u32)pbuffer[0] << 24) | (pbuffer[1] << 16) | (pbuffer[2] << 8) |\n\t\t        pbuffer[3];\n\n\t\tif (scode == MPEG12_SEQUENCE_START_CODE) {\n\t\t\tpbuffer += sizeof(u32);\n\t\t\t*width = (pbuffer[0]);\n\t\t\t*width <<= 4;\n\t\t\t*width |= ((pbuffer[1] >> 4) &0xf);\n\t\t\t*height = (pbuffer[1] & 0xf);\n\t\t\t*height <<= 8;\n\t\t\t*height |= pbuffer[2];\n\t\t\taspect_code = (pbuffer[3] >> 4) & 0xf;\n\t\t\tif (aspect_ratio != NULL) {\n\t\t\t\tu32 par = 0;\n\t\t\t\tswitch (aspect_code) {\n\t\t\t\tdefault:\n\t\t\t\t\t*aspect_ratio = 0;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\tpar = 4;\n\t\t\t\t\tpar<<=16;\n\t\t\t\t\tpar |= 3;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 3:\n\t\t\t\t\tpar = 16;\n\t\t\t\t\tpar<<=16;\n\t\t\t\t\tpar |= 9;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 4:\n\t\t\t\t\tpar = 2;\n\t\t\t\t\tpar<<=16;\n\t\t\t\t\tpar |= 21;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t*aspect_ratio = par;\n\t\t\t}\n\n\n\t\t\tframerate_code = pbuffer[3] & 0xf;\n\t\t\t*frame_rate = mpeg12_frame_rate_table[framerate_code];\n\t\t\t// 18 bits\n\t\t\tbitrate_int = (pbuffer[4] << 10) |\n\t\t\t              (pbuffer[5] << 2) |\n\t\t\t              ((pbuffer[6] >> 6) & 0x3);\n\t\t\t*bitrate = bitrate_int;\n\t\t\t*bitrate *= 400.0;\n\t\t\tix += sizeof(u32) + 7;\n\t\t\tpbuffer += 7;\n\t\t\tfound = 0;\n\t\t} else if (found == 0) {\n\t\t\tif (scode == MPEG12_EXT_START_CODE) {\n\t\t\t\tpbuffer += sizeof(u32);\n\t\t\t\tix += sizeof(u32);\n\t\t\t\tswitch ((pbuffer[0] >> 4) & 0xf) {\n\t\t\t\tcase SEQ_ID:\n\t\t\t\t\t*have_mpeg2 = 1;\n\t\t\t\t\t*height = ((pbuffer[1] & 0x1) << 13) |\n\t\t\t\t\t          ((pbuffer[2] & 0x80) << 5) |\n\t\t\t\t\t          (*height & 0x0fff);\n\t\t\t\t\t*width = (((pbuffer[2] >> 5) & 0x3) << 12) | (*width & 0x0fff);\n\t\t\t\t\tbitrate_ext = (pbuffer[2] & 0x1f) << 7;\n\t\t\t\t\tbitrate_ext |= (pbuffer[3] >> 1) & 0x7f;\n\t\t\t\t\tbitrate_int |= (bitrate_ext << 18);\n\t\t\t\t\t*bitrate = bitrate_int;\n\t\t\t\t\t*bitrate *= 400.0;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tpbuffer++;\n\t\t\t\tix++;\n\t\t\t} else if (scode == MPEG12_PICTURE_START_CODE) {\n\t\t\t\treturn found;\n\t\t\t}\n\t\t}\n\t}\n\treturn found;\n}\n\n\ns32 MPEG12_PictHdrType (unsigned char *pbuffer)\n{\n\tpbuffer += sizeof(u32);\n\treturn ((pbuffer[1] >> 3) & 0x7);\n}\n\n#if 0 //unused\nu16 MPEG12_PictHdrTempRef(unsigned char *pbuffer)\n{\n\tpbuffer += sizeof(u32);\n\treturn ((pbuffer[0] << 2) | ((pbuffer[1] >> 6) & 0x3));\n}\n#endif\n\n\nstatic u64 read_pts (u8 *pak)\n{\n\tu64 pts;\n\tu16 temp;\n\n\tpts = ((pak[0] >> 1) & 0x7);\n\tpts <<= 15;\n\ttemp = convert16(&pak[1]) >> 1;\n\tpts |= temp;\n\tpts <<= 15;\n\ttemp = convert16(&pak[3]) >> 1;\n\tpts |= temp;\n\treturn pts;\n}\n\n\nstatic mpeg2ps_stream_t *mpeg2ps_stream_create (u8 stream_id,\n        u8 substream)\n{\n\tmpeg2ps_stream_t *ptr;\n\tGF_SAFEALLOC(ptr, mpeg2ps_stream_t);\n\tif (!ptr) return NULL;\n\tptr->m_stream_id = stream_id;\n\tptr->m_substream_id = substream;\n\tptr->is_video = stream_id >= 0xe0;\n\tptr->pes_buffer = (u8 *)gf_malloc(4*4096);\n\tptr->pes_buffer_size_max = 4 * 4096;\n\treturn ptr;\n}\n\nstatic void mpeg2ps_stream_destroy (mpeg2ps_stream_t *sptr)\n{\n\tmpeg2ps_record_pes_t *p;\n\twhile (sptr->record_first != NULL) {\n\t\tp = sptr->record_first;\n\t\tsptr->record_first = p->next_rec;\n\t\tgf_free(p);\n\t}\n\tif (sptr->m_fd != FDNULL) {\n\t\tfile_close(sptr->m_fd);\n\t\tsptr->m_fd = FDNULL;\n\t}\n\tif (sptr->pes_buffer) gf_free(sptr->pes_buffer);\n\tgf_free(sptr);\n}\n\n\n/*\n * adv_past_pack_hdr - read the pack header, advance past it\n * we don't do anything with the data\n */\nstatic void adv_past_pack_hdr (FILE *fd,\n                               u8 *pak,\n                               u32 read_from_start)\n{\n\tu8 stuffed;\n\tu8 readbyte;\n\tu8 val;\n\tif (read_from_start < 5) {\n\t\tfile_skip_bytes(fd, 5 - read_from_start);\n\t\tfile_read_bytes(fd, &readbyte, 1);\n\t\tval = readbyte;\n\t} else {\n\t\tval = pak[4];\n\t}\n\n\t// we've read 6 bytes\n\tif ((val & 0xc0) != 0x40) {\n\t\t// mpeg1\n\t\tfile_skip_bytes(fd, 12 - read_from_start); // skip 6 more bytes\n\t\treturn;\n\t}\n\tfile_skip_bytes(fd, 13 - read_from_start);\n\tfile_read_bytes(fd, &readbyte, 1);\n\tstuffed = readbyte & 0x7;\n\tfile_skip_bytes(fd, stuffed);\n}\n\n/*\n * find_pack_start\n * look for the pack start code in the file - read 512 bytes at a time,\n * searching for that code.\n * Note: we may also be okay looking for >= 00 00 01 bb\n */\nstatic Bool find_pack_start (FILE *fd,\n                             u8 *saved,\n                             u32 len)\n{\n\tu8 buffer[512];\n\tu32 buffer_on = 0, new_offset, scode;\n\tmemcpy(buffer, saved, len);\n\tif (file_read_bytes(fd, buffer + len, sizeof(buffer) - len) == 0) {\n\t\treturn 0;\n\t}\n\twhile (1) {\n\t\tif (gf_mv12_next_start_code(buffer + buffer_on,\n\t\t                            sizeof(buffer) - buffer_on,\n\t\t                            &new_offset,\n\t\t                            &scode) >= 0) {\n\t\t\tbuffer_on += new_offset;\n\t\t\tif (scode == MPEG2_PS_PACKSTART) {\n\t\t\t\tfile_skip_bytes(fd, buffer_on - 512); // go back to header\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tbuffer_on += 1;\n\t\t} else {\n\t\t\tlen = 0;\n\t\t\tif (buffer[sizeof(buffer) - 3] == 0 &&\n\t\t\t        buffer[sizeof(buffer) - 2] == 0 &&\n\t\t\t        buffer[sizeof(buffer) - 1] == 1) {\n\t\t\t\tbuffer[0] = 0;\n\t\t\t\tbuffer[1] = 0;\n\t\t\t\tbuffer[2] = 1;\n\t\t\t\tlen = 3;\n\t\t\t} else if (*(u16 *)(buffer + sizeof(buffer) - 2) == 0) {\n\t\t\t\tbuffer[0] = 0;\n\t\t\t\tbuffer[1] = 0;\n\t\t\t\tlen = 2;\n\t\t\t} else if (buffer[sizeof(buffer) - 1] == 0) {\n\t\t\t\tbuffer[0] = 0;\n\t\t\t\tlen = 1;\n\t\t\t}\n\t\t\tif (file_read_bytes(fd, buffer + len, sizeof(buffer) - len) == 0) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tbuffer_on = 0;\n\t\t}\n\t}\n\treturn 0;\n}\n\n/*\n * copy_bytes_to_pes_buffer - read pes_len bytes into the buffer,\n * adjusting it if we need it\n */\nstatic void copy_bytes_to_pes_buffer (mpeg2ps_stream_t *sptr,\n                                      u16 pes_len)\n{\n\tu32 to_move;\n\n\tif (sptr->pes_buffer_size + pes_len > sptr->pes_buffer_size_max) {\n\t\t// if no room in the buffer, we'll move it - otherwise, just fill\n\t\t// note - we might want a better strategy about moving the buffer -\n\t\t// right now, we might be moving a number of bytes if we have a large\n\t\t// followed by large frame.\n\t\tto_move = sptr->pes_buffer_size - sptr->pes_buffer_on;\n\t\tmemmove(sptr->pes_buffer,\n\t\t        sptr->pes_buffer + sptr->pes_buffer_on,\n\t\t        to_move);\n\t\tsptr->pes_buffer_size = to_move;\n\t\tsptr->pes_buffer_on = 0;\n\t\tif (to_move + pes_len > sptr->pes_buffer_size_max) {\n\t\t\tsptr->pes_buffer = (u8 *)gf_realloc(sptr->pes_buffer,\n\t\t\t                                    to_move + pes_len + 2048);\n\t\t\tsptr->pes_buffer_size_max = to_move + pes_len + 2048;\n\t\t}\n\t}\n\tfile_read_bytes(sptr->m_fd, sptr->pes_buffer + sptr->pes_buffer_size, pes_len);\n\tsptr->pes_buffer_size += pes_len;\n}\n\n/*\n * read_to_next_pes_header - read the file, look for the next valid\n * pes header.  We will skip over PACK headers, but not over any of the\n * headers listed in 13818-1, table 2-18 - basically, anything with the\n * 00 00 01 and the next byte > 0xbb.\n * We return the pes len to read, and the \"next byte\"\n */\nstatic Bool read_to_next_pes_header (FILE *fd,\n                                     u8 *stream_id,\n                                     u16 *pes_len)\n{\n\tu32 hdr;\n\tu8 local[6];\n\n\twhile (1) {\n\t\t// read the pes header\n\t\tif (file_read_bytes(fd, local, 6) == 0) {\n\t\t\treturn 0;\n\t\t}\n\n\t\thdr = convert32(local);\n\t\t// if we're not a 00 00 01, read until we get the next pack start\n\t\t// we might want to also read until next PES - look into that.\n\t\tif (((hdr & MPEG2_PS_START_MASK) != MPEG2_PS_START) ||\n\t\t        (hdr < MPEG2_PS_END)) {\n\t\t\tif (find_pack_start(fd, local, 6) == 0) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (hdr == MPEG2_PS_PACKSTART) {\n\t\t\t// pack start code - we can skip down\n\t\t\tadv_past_pack_hdr(fd, local, 6);\n\t\t\tcontinue;\n\t\t}\n\t\tif (hdr == MPEG2_PS_END) {\n\t\t\tfile_skip_bytes(fd, -2);\n\t\t\tcontinue;\n\t\t}\n\n\t\t// we should have a valid stream and pes_len here...\n\t\t*stream_id = hdr & 0xff;\n\t\t*pes_len = convert16(local + 4);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n/*\n * read_pes_header_data\n * this should read past the pes header for the audio and video streams\n * it will store the timestamps if it reads them\n */\nstatic Bool read_pes_header_data (FILE *fd,\n                                  u16 orig_pes_len,\n                                  u16 *pes_left,\n                                  Bool *have_ts,\n                                  mpeg2ps_ts_t *ts)\n{\n\tu16 pes_len = orig_pes_len;\n\tu8 local[10];\n\tu32 hdr_len;\n\n\tts->have_pts = 0;\n\tts->have_dts = 0;\n\tif (have_ts) *have_ts = 0;\n\tif (file_read_bytes(fd, local, 1) == 0) {\n\t\treturn 0;\n\t}\n\tpes_len--; // remove this first byte from length\n\twhile (*local == 0xff) {\n\t\tif (file_read_bytes(fd, local, 1) == 0) {\n\t\t\treturn 0;\n\t\t}\n\t\tpes_len--;\n\t\tif (pes_len == 0) {\n\t\t\t*pes_left = 0;\n\t\t\treturn 1;\n\t\t}\n\t}\n\tif ((*local & 0xc0) == 0x40) {\n\t\t// buffer scale & size\n\t\tfile_skip_bytes(fd, 1);\n\t\tif (file_read_bytes(fd, local, 1) == 0) {\n\t\t\treturn 0;\n\t\t}\n\t\tpes_len -= 2;\n\t}\n\n\tif ((*local & 0xf0) == 0x20) {\n\t\t// mpeg-1 with pts\n\t\tif (file_read_bytes(fd, local + 1, 4) == 0) {\n\t\t\treturn 0;\n\t\t}\n\t\tts->have_pts = 1;\n\t\tts->pts = ts->dts = read_pts(local);\n\t\t*have_ts = 1;\n\t\tpes_len -= 4;\n\t} else if ((*local & 0xf0) == 0x30) {\n\t\t// have mpeg 1 pts and dts\n\t\tif (file_read_bytes(fd, local + 1, 9) == 0) {\n\t\t\treturn 0;\n\t\t}\n\t\tts->have_pts = 1;\n\t\tts->have_dts = 1;\n\t\t*have_ts = 1;\n\t\tts->pts = read_pts(local);\n\t\tts->dts = read_pts(local + 5);\n\t\tpes_len -= 9;\n\t} else if ((*local & 0xc0) == 0x80) {\n\t\t// mpeg2 pes header  - we're pointing at the flags field now\n\t\tif (file_read_bytes(fd, local + 1, 2) == 0) {\n\t\t\treturn 0;\n\t\t}\n\t\thdr_len = local[2];\n\t\tpes_len -= hdr_len + 2; // first byte removed already\n\t\tif ((local[1] & 0xc0) == 0x80) {\n\t\t\t// just pts\n\t\t\tts->have_pts = 1;\n\t\t\tfile_read_bytes(fd, local, 5);\n\t\t\tts->pts = ts->dts = read_pts(local);\n\t\t\t*have_ts = 1;\n\t\t\thdr_len -= 5;\n\t\t} else if ((local[1] & 0xc0) == 0xc0) {\n\t\t\t// pts and dts\n\t\t\tts->have_pts = 1;\n\t\t\tts->have_dts = 1;\n\t\t\t*have_ts = 1;\n\t\t\tfile_read_bytes(fd, local, 10);\n\t\t\tts->pts = read_pts(local);\n\t\t\tts->dts = read_pts(local  + 5);\n\t\t\thdr_len -= 10;\n\t\t}\n\t\tfile_skip_bytes(fd, hdr_len);\n\t} else if (*local != 0xf) {\n\t\tfile_skip_bytes(fd, pes_len);\n\t\tpes_len = 0;\n\t}\n\t*pes_left = pes_len;\n\treturn 1;\n}\n\nstatic Bool search_for_next_pes_header (mpeg2ps_stream_t *sptr,\n                                        u16 *pes_len,\n                                        Bool *have_ts,\n                                        s64 *found_loc)\n{\n\tu8 stream_id;\n\tu8 local;\n\ts64 loc;\n\twhile (1) {\n\t\t// this will read until we find the next pes.  We don't know if the\n\t\t// stream matches - this will read over pack headers\n\t\tif (read_to_next_pes_header(sptr->m_fd, &stream_id, pes_len) == 0) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (stream_id != sptr->m_stream_id) {\n\t\t\tfile_skip_bytes(sptr->m_fd, *pes_len);\n\t\t\tcontinue;\n\t\t}\n\t\tloc = file_location(sptr->m_fd) - 6;\n\t\t// advance past header, reading pts\n\t\tif (read_pes_header_data(sptr->m_fd,\n\t\t                         *pes_len,\n\t\t                         pes_len,\n\t\t                         have_ts,\n\t\t                         &sptr->next_pes_ts) == 0) {\n\t\t\treturn 0;\n\t\t}\n\n\t\t// If we're looking at a private stream, make sure that the sub-stream\n\t\t// matches.\n\t\tif (sptr->m_stream_id == 0xbd) {\n\t\t\t// ac3 or pcm\n\t\t\tfile_read_bytes(sptr->m_fd, &local, 1);\n\t\t\t*pes_len -= 1;\n\t\t\tif (local != sptr->m_substream_id) {\n\t\t\t\tfile_skip_bytes(sptr->m_fd, *pes_len);\n\t\t\t\tcontinue; // skip to the next one\n\t\t\t}\n\t\t\t*pes_len -= 3;\n\t\t\tfile_skip_bytes(sptr->m_fd, 3); // 4 bytes - we don't need now...\n\t\t\t// we need more here...\n\t\t}\n\t\tif (have_ts) {\n\t\t\tmpeg2ps_record_pts(sptr, loc, &sptr->next_pes_ts);\n\t\t}\n\t\tif (found_loc != NULL) *found_loc = loc;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n/*\n * mpeg2ps_stream_read_next_pes_buffer - for the given stream,\n * go forward in the file until the next PES for the stream is read.  Read\n * the header (pts, dts), and read the data into the pes_buffer pointer\n */\nstatic Bool mpeg2ps_stream_read_next_pes_buffer (mpeg2ps_stream_t *sptr)\n{\n\tu16 pes_len;\n\tBool have_ts;\n\n\tif (search_for_next_pes_header(sptr, &pes_len, &have_ts, NULL) == 0) {\n\t\treturn 0;\n\t}\n\n\tcopy_bytes_to_pes_buffer(sptr, pes_len);\n\n\treturn 1;\n}\n\n\n/***************************************************************************\n * Frame reading routine.  For each stream, the fd's should be different.\n * we will read from the pes stream, and save it in the stream's pes buffer.\n * This will give us raw data that we can search through for frame headers,\n * and the like.  We shouldn't read more than we need - when we need to read,\n * we'll put the whole next pes buffer in the buffer\n *\n * Audio routines are of the format:\n *   look for header\n *   determine length\n *   make sure length is in buffer\n *\n * Video routines\n *   look for start header (GOP, SEQ, Picture)\n *   look for pict header\n *   look for next start (END, GOP, SEQ, Picture)\n *\n ***************************************************************************/\n#define IS_MPEG_START(a) ((a) == 0xb3 || (a) == 0x00 || (a) == 0xb8)\n\nstatic Bool\nmpeg2ps_stream_find_mpeg_video_frame (mpeg2ps_stream_t *sptr)\n{\n\tu32 offset, scode;\n\tBool have_pict;\n\tBool started_new_pes = 0;\n\tu32 start;\n\t/*\n\t * First thing - determine if we have enough bytes to read the header.\n\t * if we do, we have the correct timestamp.  If not, we read the new\n\t * pes, so we'd want to use the timestamp we read.\n\t */\n\tsptr->frame_ts = sptr->next_pes_ts;\n\tif (sptr->pes_buffer_size <= sptr->pes_buffer_on + 4) {\n\t\tif (sptr->pes_buffer_size != sptr->pes_buffer_on)\n\t\t\tstarted_new_pes = 1;\n\t\tif (mpeg2ps_stream_read_next_pes_buffer(sptr) == 0) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\twhile (gf_mv12_next_start_code(sptr->pes_buffer + sptr->pes_buffer_on,\n\t                               sptr->pes_buffer_size - sptr->pes_buffer_on,\n\t                               &offset,\n\t                               &scode) < 0 ||\n\t        (!IS_MPEG_START(scode & 0xff))) {\n\t\tif (sptr->pes_buffer_size > 3)\n\t\t\tsptr->pes_buffer_on = sptr->pes_buffer_size - 3;\n\t\telse {\n\t\t\tsptr->pes_buffer_on = sptr->pes_buffer_size;\n\t\t\tstarted_new_pes = 1;\n\t\t}\n\t\tif (mpeg2ps_stream_read_next_pes_buffer(sptr) == 0) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\tsptr->pes_buffer_on += offset;\n\tif (offset == 0 && started_new_pes) {\n\t\t// nothing...  we've copied the timestamp already.\n\t} else {\n\t\t// we found the new start, but we pulled in a new pes header before\n\t\t// starting.  So, we want to use the header that we read.\n\t\tsptr->frame_ts = sptr->next_pes_ts; // set timestamp after searching\n\t\t// clear timestamp indication\n\t\tsptr->next_pes_ts.have_pts = sptr->next_pes_ts.have_dts = 0;\n\t}\n\n\tif (scode == MPEG12_PICTURE_START_CODE) {\n\t\tsptr->pict_header_offset = sptr->pes_buffer_on;\n\t\thave_pict = 1;\n\t} else have_pict = 0;\n\n\tstart = 4 + sptr->pes_buffer_on;\n\twhile (1) {\n\n\t\tif (gf_mv12_next_start_code(sptr->pes_buffer + start,\n\t\t                            sptr->pes_buffer_size - start,\n\t\t                            &offset,\n\t\t                            &scode) < 0) {\n\t\t\tstart = sptr->pes_buffer_size - 3;\n\t\t\tstart -= sptr->pes_buffer_on;\n\t\t\tsptr->pict_header_offset -= sptr->pes_buffer_on;\n\t\t\tif (mpeg2ps_stream_read_next_pes_buffer(sptr) == 0) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tstart += sptr->pes_buffer_on;\n\t\t\tsptr->pict_header_offset += sptr->pes_buffer_on;\n\t\t} else {\n\t\t\tstart += offset;\n\t\t\tif (have_pict == 0) {\n\t\t\t\tif (scode == MPEG12_PICTURE_START_CODE) {\n\t\t\t\t\thave_pict = 1;\n\t\t\t\t\tsptr->pict_header_offset = start;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (IS_MPEG_START(scode & 0xff) ||\n\t\t\t\t        scode == MPEG12_SEQUENCE_END_START_CODE) {\n\t\t\t\t\tsptr->frame_len = start - sptr->pes_buffer_on;\n\t\t\t\t\tsptr->have_frame_loaded = 1;\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tstart += 4;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic Bool mpeg2ps_stream_find_ac3_frame (mpeg2ps_stream_t *sptr)\n{\n\tu32 diff;\n\tBool started_new_pes = 0;\n\tGF_AC3Config hdr;\n\tmemset(&hdr, 0, sizeof(GF_AC3Config));\n\tsptr->frame_ts = sptr->next_pes_ts; // set timestamp after searching\n\tif (sptr->pes_buffer_size <= sptr->pes_buffer_on + 6) {\n\t\tif (sptr->pes_buffer_size != sptr->pes_buffer_on)\n\t\t\tstarted_new_pes = 1;\n\t\tif (mpeg2ps_stream_read_next_pes_buffer(sptr) == 0) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\twhile (gf_ac3_parser(sptr->pes_buffer + sptr->pes_buffer_on,\n\t                     sptr->pes_buffer_size - sptr->pes_buffer_on,\n\t                     &diff,\n\t                     &hdr, 0) <= 0) {\n\t\t// don't have frame\n\t\tif (sptr->pes_buffer_size > 6) {\n\t\t\tsptr->pes_buffer_on = sptr->pes_buffer_size - 6;\n\t\t\tstarted_new_pes = 1;\n\t\t} else {\n\t\t\tsptr->pes_buffer_on = sptr->pes_buffer_size;\n\t\t}\n\t\tif (mpeg2ps_stream_read_next_pes_buffer(sptr) == 0) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\tsptr->frame_len = hdr.framesize;\n\tsptr->pes_buffer_on += diff;\n\tif (diff == 0 && started_new_pes) {\n\t\t// we might have a new PTS - but it's not here\n\t} else {\n\t\tsptr->frame_ts = sptr->next_pes_ts;\n\t\tsptr->next_pes_ts.have_dts = sptr->next_pes_ts.have_pts = 0;\n\t}\n\twhile (sptr->pes_buffer_size - sptr->pes_buffer_on < sptr->frame_len) {\n\t\tif (mpeg2ps_stream_read_next_pes_buffer(sptr) == 0) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\tsptr->have_frame_loaded = 1;\n\treturn 1;\n}\n\nstatic Bool mpeg2ps_stream_find_mp3_frame (mpeg2ps_stream_t *sptr)\n{\n\tu32 diff, hdr;\n\tBool started_new_pes = 0;\n\n\tsptr->frame_ts = sptr->next_pes_ts;\n\tif (sptr->pes_buffer_size <= sptr->pes_buffer_on + 4) {\n\t\tif (sptr->pes_buffer_size != sptr->pes_buffer_on)\n\t\t\tstarted_new_pes = 1;\n\t\tif (mpeg2ps_stream_read_next_pes_buffer(sptr) == 0) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\twhile ((hdr=gf_mp3_get_next_header_mem(sptr->pes_buffer + sptr->pes_buffer_on,\n\t                                       sptr->pes_buffer_size - sptr->pes_buffer_on,\n\t                                       &diff) ) == 0) {\n\t\t// don't have frame\n\t\tif (sptr->pes_buffer_size > 3) {\n\t\t\tif (sptr->pes_buffer_on != sptr->pes_buffer_size) {\n\t\t\t\tsptr->pes_buffer_on = sptr->pes_buffer_size - 3;\n\t\t\t}\n\t\t\tstarted_new_pes = 1; // we have left over bytes...\n\t\t} else {\n\t\t\tsptr->pes_buffer_on = sptr->pes_buffer_size;\n\t\t}\n\t\tif (mpeg2ps_stream_read_next_pes_buffer(sptr) == 0) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\t// have frame.\n\tsptr->frame_len = gf_mp3_frame_size(hdr);\n\tsptr->pes_buffer_on += diff;\n\tif (diff == 0 && started_new_pes) {\n\n\t} else {\n\t\tsptr->frame_ts = sptr->next_pes_ts;\n\t\tsptr->next_pes_ts.have_dts = sptr->next_pes_ts.have_pts = 0;\n\t}\n\twhile (sptr->pes_buffer_size - sptr->pes_buffer_on < sptr->frame_len) {\n\t\tif (mpeg2ps_stream_read_next_pes_buffer(sptr) == 0) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\tsptr->have_frame_loaded = 1;\n\treturn 1;\n}\n\n/*\n * mpeg2ps_stream_read_frame.  read the correct frame based on stream type.\n * advance_pointers is 0 when we want to use the data\n */\nstatic Bool mpeg2ps_stream_read_frame (mpeg2ps_stream_t *sptr,\n                                       u8 **buffer,\n                                       u32 *buflen,\n                                       Bool advance_pointers)\n{\n\t//  Bool done = 0;\n\tif (sptr->is_video) {\n\t\tif (mpeg2ps_stream_find_mpeg_video_frame(sptr)) {\n\t\t\t*buffer = sptr->pes_buffer + sptr->pes_buffer_on;\n\t\t\t*buflen = sptr->frame_len;\n\t\t\tif (advance_pointers) {\n\t\t\t\tsptr->pes_buffer_on += sptr->frame_len;\n\t\t\t}\n\t\t\treturn 1;\n\t\t}\n\t\treturn 0;\n\t} else if (sptr->m_stream_id == 0xbd) {\n\t\t// would need to handle LPCM here\n\t\tif (mpeg2ps_stream_find_ac3_frame(sptr)) {\n\t\t\t*buffer = sptr->pes_buffer + sptr->pes_buffer_on;\n\t\t\t*buflen = sptr->frame_len;\n\t\t\tif (advance_pointers)\n\t\t\t\tsptr->pes_buffer_on += sptr->frame_len;\n\t\t\treturn 1;\n\t\t}\n\t\treturn 0;\n\t} else if (mpeg2ps_stream_find_mp3_frame(sptr)) {\n\t\t*buffer = sptr->pes_buffer + sptr->pes_buffer_on;\n\t\t*buflen = sptr->frame_len;\n\t\tif (advance_pointers)\n\t\t\tsptr->pes_buffer_on += sptr->frame_len;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n/*\n * get_info_from_frame - we have a frame, get the info from it.\n */\nstatic void get_info_from_frame (mpeg2ps_stream_t *sptr,\n                                 u8 *buffer,\n                                 u32 buflen)\n{\n\tif (sptr->is_video) {\n\t\tif (MPEG12_ParseSeqHdr(buffer, buflen,\n\t\t                       &sptr->have_mpeg2,\n\t\t                       &sptr->h,\n\t\t                       &sptr->w,\n\t\t                       &sptr->frame_rate,\n\t\t                       &sptr->bit_rate,\n\t\t                       &sptr->par) < 0) {\n\t\t\tsptr->m_stream_id = 0;\n\t\t\tsptr->m_fd = FDNULL;\n\t\t\treturn;\n\t\t}\n\t\tsptr->ticks_per_frame = (u64)(90000.0 / sptr->frame_rate);\n\t\treturn;\n\t}\n\n\tif (sptr->m_stream_id >= 0xc0) {\n\t\t// mpeg audio\n\t\tu32 hdr = GF_4CC((u32)buffer[0],buffer[1],buffer[2],buffer[3]);\n\n\t\tsptr->channels = gf_mp3_num_channels(hdr);\n\t\tsptr->freq = gf_mp3_sampling_rate(hdr);\n\t\tsptr->samples_per_frame = gf_mp3_window_size(hdr);\n\t\tsptr->bitrate = gf_mp3_bit_rate(hdr) * 1000; // give bps, not kbps\n\t\tsptr->layer = gf_mp3_layer(hdr);\n\t} else if (sptr->m_stream_id == 0xbd) {\n\t\tif (sptr->m_substream_id >= 0xa0) {\n\t\t\t// PCM - ???\n\t\t} else if (sptr->m_substream_id >= 0x80) {\n\t\t\tu32 pos;\n\t\t\tGF_AC3Config hdr;\n\t\t\tmemset(&hdr, 0, sizeof(GF_AC3Config));\n\t\t\tgf_ac3_parser(buffer, buflen, &pos, &hdr, 0);\n\t\t\tsptr->bitrate = gf_ac3_get_bitrate(hdr.brcode);\n\t\t\tsptr->freq = hdr.sample_rate;\n\t\t\tsptr->channels = hdr.streams[0].channels;\n\t\t\tsptr->samples_per_frame = 256 * 6;\n\t\t} else {\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\treturn;\n\t}\n}\n\n/*\n * clear_stream_buffer - called when we seek to clear out any data in\n * the buffers\n */\nstatic void clear_stream_buffer (mpeg2ps_stream_t *sptr)\n{\n\tsptr->pes_buffer_on = sptr->pes_buffer_size = 0;\n\tsptr->frame_len = 0;\n\tsptr->have_frame_loaded = 0;\n\tsptr->next_pes_ts.have_dts = sptr->next_pes_ts.have_pts = 0;\n\tsptr->frame_ts.have_dts = sptr->frame_ts.have_pts = 0;\n}\n\n/*\n * convert_to_msec - convert ts (at 90000) to msec, based on base_ts and\n * frames_since_last_ts.\n */\nstatic u64 convert_ts (mpeg2ps_stream_t *sptr,\n                       mpeg2ps_ts_type_t ts_type,\n                       u64 ts,\n                       u64 base_ts,\n                       u32 frames_since_ts)\n{\n\tu64 ret, calc;\n\tret = ts - base_ts;\n\tif (sptr->is_video) {\n\t\t// video\n\t\tret += frames_since_ts * sptr->ticks_per_frame;\n\t} else if (sptr->freq) {\n\t\t// audio\n\t\tcalc = (frames_since_ts * 90000 * sptr->samples_per_frame) / sptr->freq;\n\t\tret += calc;\n\t}\n\tif (ts_type == TS_MSEC)\n\t\tret /= (u64) (90); // * 1000 / 90000\n\n\treturn ret;\n}\n\n/*\n * find_stream_from_id - given the stream, get the sptr.\n * only used in inital set up, really.  APIs use index into\n * video_streams and audio_streams arrays.\n */\nstatic mpeg2ps_stream_t *find_stream_from_id (mpeg2ps_t *ps,\n        u8 stream_id,\n        u8 substream)\n{\n\tu8 ix;\n\tif (stream_id >= 0xe0) {\n\t\tfor (ix = 0; ix < ps->video_cnt; ix++) {\n\t\t\tif (ps->video_streams[ix]->m_stream_id == stream_id) {\n\t\t\t\treturn ps->video_streams[ix];\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfor (ix = 0; ix < ps->audio_cnt; ix++) {\n\t\t\tif (ps->audio_streams[ix]->m_stream_id == stream_id &&\n\t\t\t        (stream_id != 0xbd ||\n\t\t\t         substream == ps->audio_streams[ix]->m_substream_id)) {\n\t\t\t\treturn ps->audio_streams[ix];\n\t\t\t}\n\t\t}\n\t}\n\treturn NULL;\n}\n\n/*\n * add_stream - add a new stream\n */\nstatic Bool add_stream (mpeg2ps_t *ps,\n                        u8 stream_id,\n                        u8 substream,\n                        s64 first_loc,\n                        mpeg2ps_ts_t *ts)\n{\n\tmpeg2ps_stream_t *sptr;\n\n\tsptr = find_stream_from_id(ps, stream_id, substream);\n\tif (sptr != NULL) return 0;\n\n\t// need to add\n\n\tsptr = mpeg2ps_stream_create(stream_id, substream);\n\tsptr->first_pes_loc = first_loc;\n\tif (ts == NULL ||\n\t        (ts->have_dts == 0 && ts->have_pts == 0)) {\n\t\tsptr->first_pes_has_dts = 0;\n\t} else {\n\t\tsptr->start_dts = ts->have_dts ? ts->dts : ts->pts;\n\t\tsptr->first_pes_has_dts = 1;\n\t}\n\tif (sptr->is_video) {\n\t\t// can't be more than 16 - e0 to ef...\n\t\tps->video_streams[ps->video_cnt] = sptr;\n\t\tps->video_cnt++;\n\t} else {\n\t\tif (ps->audio_cnt >= 32) {\n\t\t\tmpeg2ps_stream_destroy(sptr);\n\t\t\treturn 0;\n\t\t}\n\t\tps->audio_streams[ps->audio_cnt] = sptr;\n\t\tps->audio_cnt++;\n\t}\n\treturn 1;\n}\n\nstatic void check_fd_for_stream (mpeg2ps_t *ps,\n                                 mpeg2ps_stream_t *sptr)\n{\n\tif (sptr->m_fd != FDNULL) return;\n\n\tsptr->m_fd = file_open(ps->filename);\n}\n\n/*\n * advance_frame - when we're reading frames, this indicates that we're\n * done.  We will call this when we read a frame, but not when we\n * seek.  It allows us to leave the last frame we're seeking in the\n * buffer\n */\nstatic void advance_frame (mpeg2ps_stream_t *sptr)\n{\n\tsptr->pes_buffer_on += sptr->frame_len;\n\tsptr->have_frame_loaded = 0;\n\tif (sptr->frame_ts.have_dts || sptr->frame_ts.have_pts) {\n\t\tif (sptr->frame_ts.have_dts)\n\t\t\tsptr->last_ts = sptr->frame_ts.dts;\n\t\telse\n\t\t\tsptr->last_ts = sptr->frame_ts.pts;\n\t\tsptr->frames_since_last_ts = 0;\n\t} else {\n\t\tsptr->frames_since_last_ts++;\n\t}\n}\n/*\n * get_info_for_all_streams - loop through found streams - read an\n * figure out the info\n */\nstatic void get_info_for_all_streams (mpeg2ps_t *ps)\n{\n\tu8 stream_ix, max_ix, av;\n\tmpeg2ps_stream_t *sptr;\n\tu8 *buffer;\n\tu32 buflen;\n\n\tfile_seek_to(ps->fd, 0);\n\n\t// av will be 0 for video streams, 1 for audio streams\n\t// av is just so I don't have to dup a lot of code that does the\n\t// same thing.\n\tfor (av = 0; av < 2; av++) {\n\t\tif (av == 0) max_ix = ps->video_cnt;\n\t\telse max_ix = ps->audio_cnt;\n\t\tfor (stream_ix = 0; stream_ix < max_ix; stream_ix++) {\n\t\t\tif (av == 0) sptr = ps->video_streams[stream_ix];\n\t\t\telse sptr = ps->audio_streams[stream_ix];\n\n\t\t\t// we don't open a separate file descriptor yet (only when they\n\t\t\t// start reading or seeking).  Use the one from the ps.\n\t\t\tsptr->m_fd = ps->fd; // for now\n\t\t\tclear_stream_buffer(sptr);\n\t\t\tif (mpeg2ps_stream_read_frame(sptr,\n\t\t\t                              &buffer,\n\t\t\t                              &buflen,\n\t\t\t                              0) == 0) {\n\t\t\t\tsptr->m_stream_id = 0;\n\t\t\t\tsptr->m_fd = FDNULL;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tget_info_from_frame(sptr, buffer, buflen);\n\t\t\t// here - if (sptr->first_pes_has_dts == 0) should be processed\n\t\t\tif ((sptr->first_pes_has_dts == 0) && sptr->m_fd) {\n\t\t\t\tu32 frames_from_beg = 0;\n\t\t\t\tBool have_frame;\n\t\t\t\tdo {\n\t\t\t\t\tadvance_frame(sptr);\n\t\t\t\t\thave_frame =\n\t\t\t\t\t    mpeg2ps_stream_read_frame(sptr, &buffer, &buflen, 0);\n\t\t\t\t\tframes_from_beg++;\n\t\t\t\t} while (have_frame &&\n\t\t\t\t         sptr->frame_ts.have_dts == 0 &&\n\t\t\t\t         sptr->frame_ts.have_pts == 0 &&\n\t\t\t\t         frames_from_beg < 1000);\n\t\t\t\tif (have_frame == 0 ||\n\t\t\t\t        (sptr->frame_ts.have_dts == 0 &&\n\t\t\t\t         sptr->frame_ts.have_pts == 0)) {\n\t\t\t\t} else {\n\t\t\t\t\tsptr->start_dts = sptr->frame_ts.have_dts ? sptr->frame_ts.dts :\n\t\t\t\t\t                  sptr->frame_ts.pts;\n\t\t\t\t\tif (sptr->is_video) {\n\t\t\t\t\t\tsptr->start_dts -= frames_from_beg * sptr->ticks_per_frame;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tu64 conv;\n\t\t\t\t\t\tconv = sptr->samples_per_frame * 90000;\n\t\t\t\t\t\tconv /= (u64)sptr->freq;\n\t\t\t\t\t\tsptr->start_dts -= conv;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tclear_stream_buffer(sptr);\n\t\t\tsptr->m_fd = FDNULL;\n\t\t}\n\t}\n}\n\n/*\n * mpeg2ps_scan_file - read file, grabbing all the information that\n * we can out of it (what streams exist, timing, etc).\n */\nstatic void mpeg2ps_scan_file (mpeg2ps_t *ps)\n{\n\tu8 stream_id, stream_ix, substream, av_ix, max_cnt;\n\tu16 pes_len, pes_left;\n\tmpeg2ps_ts_t ts;\n\ts64 loc, first_video_loc = 0, first_audio_loc = 0;\n\ts64 check, orig_check;\n\tmpeg2ps_stream_t *sptr;\n\tBool valid_stream;\n\tu8 *buffer;\n\tu32 buflen;\n\tBool have_ts;\n\n\tps->end_loc = file_size(ps->fd);\n\torig_check = check = MAX(ps->end_loc / 50, 200 * 1024);\n\n\t/*\n\t * This part reads and finds the streams.  We check up until we\n\t * find audio and video plus a little, with a max of either 200K or\n\t * the file size / 50\n\t */\n\tloc = 0;\n\twhile (read_to_next_pes_header(ps->fd, &stream_id, &pes_len) &&\n\t        loc < check) {\n\t\tpes_left = pes_len;\n\t\tif (stream_id >= 0xbd && stream_id < 0xf0) {\n\t\t\tloc = file_location(ps->fd) - 6;\n\t\t\tif (read_pes_header_data(ps->fd,\n\t\t\t                         pes_len,\n\t\t\t                         &pes_left,\n\t\t\t                         &have_ts,\n\t\t\t                         &ts) == 0) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvalid_stream = 0;\n\t\t\tsubstream = 0;\n\t\t\tif (stream_id == 0xbd) {\n\t\t\t\tif (file_read_bytes(ps->fd, &substream, 1) == 0) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tpes_left--; // remove byte we just read\n\t\t\t\tif ((substream >= 0x80 && substream < 0x90) ||\n\t\t\t\t        (substream >= 0xa0 && substream < 0xb0)) {\n\t\t\t\t\tvalid_stream = 1;\n\t\t\t\t}\n\t\t\t} else if (stream_id >= 0xc0) {\n\t\t\t\t// audio and video\n\t\t\t\tvalid_stream = 1;\n\t\t\t}\n\t\t\tif (valid_stream) {\n\t\t\t\tif (add_stream(ps, stream_id, substream, loc, &ts)) {\n\t\t\t\t\t// added\n\t\t\t\t\tif (stream_id >= 0xe0) {\n\t\t\t\t\t\tif (ps->video_cnt == 1) {\n\t\t\t\t\t\t\tfirst_video_loc = loc;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (ps->audio_cnt == 1) {\n\t\t\t\t\t\tfirst_audio_loc = loc;\n\t\t\t\t\t}\n\t\t\t\t\tif (ps->audio_cnt > 0 && ps->video_cnt > 0) {\n\t\t\t\t\t\ts64 diff;\n\t\t\t\t\t\tif (first_audio_loc > first_video_loc)\n\t\t\t\t\t\t\tdiff = first_audio_loc - first_video_loc;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tdiff = first_video_loc - first_audio_loc;\n\t\t\t\t\t\tdiff *= 2;\n\t\t\t\t\t\tdiff += first_video_loc;\n\t\t\t\t\t\tif (diff < check) {\n\t\t\t\t\t\t\tcheck = diff;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfile_skip_bytes(ps->fd, pes_left);\n\t}\n\tif (ps->video_cnt == 0 && ps->audio_cnt == 0) {\n\t\treturn;\n\t}\n\t/*\n\t * Now, we go to close to the end, and try to find the last\n\t * dts that we can\n\t */\n\tfile_seek_to(ps->fd, ps->end_loc - orig_check);\n\n\twhile (read_to_next_pes_header(ps->fd, &stream_id, &pes_len)) {\n\t\tloc = file_location(ps->fd) - 6;\n\t\tif (stream_id == 0xbd || (stream_id >= 0xc0 && stream_id < 0xf0)) {\n\t\t\tif (read_pes_header_data(ps->fd,\n\t\t\t                         pes_len,\n\t\t\t                         &pes_left,\n\t\t\t                         &have_ts,\n\t\t\t                         &ts) == 0) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (stream_id == 0xbd) {\n\t\t\t\tif (file_read_bytes(ps->fd, &substream, 1) == 0) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tpes_left--; // remove byte we just read\n\t\t\t\tif (!((substream >= 0x80 && substream < 0x90) ||\n\t\t\t\t        (substream >= 0xa0 && substream < 0xb0))) {\n\t\t\t\t\tfile_skip_bytes(ps->fd, pes_left);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tsubstream = 0;\n\t\t\t}\n\t\t\tsptr = find_stream_from_id(ps, stream_id, substream);\n\t\t\tif (sptr == NULL) {\n\t\t\t\tadd_stream(ps, stream_id, substream, 0, NULL);\n\t\t\t\tsptr = find_stream_from_id(ps, stream_id, substream);\n\t\t\t}\n\t\t\tif (sptr != NULL && have_ts) {\n\t\t\t\tsptr->end_dts = ts.have_dts ? ts.dts : ts.pts;\n\t\t\t\tsptr->end_dts_loc = loc;\n\t\t\t}\n\t\t\tfile_skip_bytes(ps->fd, pes_left);\n\t\t}\n\t}\n\n\t/*\n\t * Now, get the info for all streams, so we can use it again\n\t * we could do this before the above, I suppose\n\t */\n\tget_info_for_all_streams(ps);\n\n\tps->first_dts = (u64) -1;\n\n\t/*\n\t * we need to find the earliest start pts - we use that to calc\n\t * the rest of the timing, so we're 0 based.\n\t */\n\tfor (av_ix = 0; av_ix < 2; av_ix++) {\n\t\tif (av_ix == 0) max_cnt = ps->video_cnt;\n\t\telse max_cnt = ps->audio_cnt;\n\n\t\tfor (stream_ix = 0; stream_ix < max_cnt; stream_ix++) {\n\t\t\tsptr = av_ix == 0 ? ps->video_streams[stream_ix] :\n\t\t\t       ps->audio_streams[stream_ix];\n\t\t\tif (sptr != NULL && sptr->start_dts < ps->first_dts) {\n\t\t\t\tps->first_dts = sptr->start_dts;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * Now, for each thread, we'll start at the last pts location, and\n\t * read the number of frames.  This will give us a max time\n\t */\n\tfor (av_ix = 0; av_ix < 2; av_ix++) {\n\t\tif (av_ix == 0) max_cnt = ps->video_cnt;\n\t\telse max_cnt = ps->audio_cnt;\n\t\tfor (stream_ix = 0; stream_ix < max_cnt; stream_ix++) {\n\t\t\tu32 frame_cnt_since_last;\n\t\t\tsptr = av_ix == 0 ? ps->video_streams[stream_ix] :\n\t\t\t       ps->audio_streams[stream_ix];\n\n\t\t\t// pick up here - find the final time...\n\t\t\tif (sptr && (sptr->end_dts_loc != 0)) {\n\t\t\t\tfile_seek_to(ps->fd, sptr->end_dts_loc);\n\t\t\t\tsptr->m_fd = ps->fd;\n\t\t\t\tframe_cnt_since_last = 0;\n\t\t\t\tclear_stream_buffer(sptr);\n\t\t\t\twhile (mpeg2ps_stream_read_frame(sptr,\n\t\t\t\t                                 &buffer,\n\t\t\t\t                                 &buflen,\n\t\t\t\t                                 1)) {\n\t\t\t\t\tframe_cnt_since_last++;\n\t\t\t\t}\n\t\t\t\tsptr->m_fd = FDNULL;\n\t\t\t\tclear_stream_buffer(sptr);\n\t\t\t\tps->max_time = MAX(ps->max_time,\n\t\t\t\t                   convert_ts(sptr,\n\t\t\t\t                              TS_MSEC,\n\t\t\t\t                              sptr->end_dts,\n\t\t\t\t                              ps->first_dts,\n\t\t\t\t                              frame_cnt_since_last));\n\t\t\t}\n\t\t}\n\t}\n\n\tps->max_dts = (ps->max_time * 90) + ps->first_dts;\n\tfile_seek_to(ps->fd, 0);\n}\n\n/*************************************************************************\n * API routines\n *************************************************************************/\nu64 mpeg2ps_get_max_time_msec (mpeg2ps_t *ps)\n{\n\treturn ps->max_time;\n}\n\nu32 mpeg2ps_get_video_stream_count (mpeg2ps_t *ps)\n{\n\treturn ps->video_cnt;\n}\n\n#define NUM_ELEMENTS_IN_ARRAY(name) ((sizeof((name))) / (sizeof(*(name))))\n\n// routine to check stream number passed.\nstatic Bool invalid_video_streamno (mpeg2ps_t *ps, u32 streamno)\n{\n\tif (streamno >= NUM_ELEMENTS_IN_ARRAY(ps->video_streams)) return 1;\n\tif (ps->video_streams[streamno] == NULL) return 1;\n\treturn 0;\n}\n\n#if 0 //unused\nconst char *mpeg2ps_get_video_stream_name (mpeg2ps_t *ps, u32 streamno)\n{\n\tif (invalid_video_streamno(ps, streamno)) {\n\t\treturn 0;\n\t}\n\tif (ps->video_streams[streamno]->have_mpeg2) {\n\t\treturn \"Mpeg-2\";\n\t}\n\treturn \"Mpeg-1\";\n}\n#endif\n\nmpeg2ps_video_type_t mpeg2ps_get_video_stream_type (mpeg2ps_t *ps,\n        u32 streamno)\n{\n\tif (invalid_video_streamno(ps, streamno)) {\n\t\treturn MPEG_VIDEO_UNKNOWN;\n\t}\n\treturn ps->video_streams[streamno]->have_mpeg2 ? MPEG_VIDEO_MPEG2 : MPEG_VIDEO_MPEG1;\n}\n\nu32 mpeg2ps_get_video_stream_width (mpeg2ps_t *ps, u32 streamno)\n{\n\tif (invalid_video_streamno(ps, streamno)) {\n\t\treturn 0;\n\t}\n\treturn ps->video_streams[streamno]->w;\n}\n\nu32 mpeg2ps_get_video_stream_height (mpeg2ps_t *ps, u32 streamno)\n{\n\tif (invalid_video_streamno(ps, streamno)) {\n\t\treturn 0;\n\t}\n\treturn ps->video_streams[streamno]->h;\n}\n\nu32 mpeg2ps_get_video_stream_aspect_ratio (mpeg2ps_t *ps, u32 streamno)\n{\n\tif (invalid_video_streamno(ps, streamno)) {\n\t\treturn 0;\n\t}\n\treturn ps->video_streams[streamno]->par;\n}\n\nDouble mpeg2ps_get_video_stream_bitrate (mpeg2ps_t *ps, u32 streamno)\n{\n\tif (invalid_video_streamno(ps, streamno)) {\n\t\treturn 0;\n\t}\n\treturn ps->video_streams[streamno]->bit_rate;\n}\n\nDouble mpeg2ps_get_video_stream_framerate (mpeg2ps_t *ps, u32 streamno)\n{\n\tif (invalid_video_streamno(ps, streamno)) {\n\t\treturn 0;\n\t}\n\treturn ps->video_streams[streamno]->frame_rate;\n}\n\nu32 mpeg2ps_get_video_stream_id(mpeg2ps_t *ps, u32 streamno)\n{\n\tif (invalid_video_streamno(ps, streamno)) {\n\t\treturn 0;\n\t}\n\treturn ps->video_streams[streamno]->m_stream_id;\n}\n\nstatic Bool invalid_audio_streamno (mpeg2ps_t *ps, u32 streamno)\n{\n\tif (streamno >= NUM_ELEMENTS_IN_ARRAY(ps->audio_streams)) return 1;\n\tif (ps->audio_streams[streamno] == NULL) return 1;\n\treturn 0;\n}\n\nu32 mpeg2ps_get_audio_stream_count (mpeg2ps_t *ps)\n{\n\treturn ps->audio_cnt;\n}\n\n#if 0 //unused\nconst char *mpeg2ps_get_audio_stream_name (mpeg2ps_t *ps,\n        u32 streamno)\n{\n\tif (invalid_audio_streamno(ps, streamno)) {\n\t\treturn \"none\";\n\t}\n\tif (ps->audio_streams[streamno]->m_stream_id >= 0xc0) {\n\t\tswitch (ps->audio_streams[streamno]->layer) {\n\t\tcase 1:\n\t\t\treturn \"MP1\";\n\t\tcase 2:\n\t\t\treturn \"MP2\";\n\t\tcase 3:\n\t\t\treturn \"MP3\";\n\t\t}\n\t\treturn \"unknown mpeg layer\";\n\t}\n\tif (ps->audio_streams[streamno]->m_substream_id >= 0x80 &&\n\t        ps->audio_streams[streamno]->m_substream_id < 0x90)\n\t\treturn \"AC3\";\n\n\treturn \"LPCM\";\n}\n#endif\n\nmpeg2ps_audio_type_t mpeg2ps_get_audio_stream_type (mpeg2ps_t *ps,\n        u32 streamno)\n{\n\tif (invalid_audio_streamno(ps, streamno)) {\n\t\treturn MPEG_AUDIO_UNKNOWN;\n\t}\n\tif (ps->audio_streams[streamno]->m_stream_id >= 0xc0) {\n\t\treturn MPEG_AUDIO_MPEG;\n\t}\n\tif (ps->audio_streams[streamno]->m_substream_id >= 0x80 &&\n\t        ps->audio_streams[streamno]->m_substream_id < 0x90)\n\t\treturn MPEG_AUDIO_AC3;\n\n\treturn MPEG_AUDIO_LPCM;\n}\n\nu32 mpeg2ps_get_audio_stream_sample_freq (mpeg2ps_t *ps, u32 streamno)\n{\n\tif (invalid_audio_streamno(ps, streamno)) {\n\t\treturn 0;\n\t}\n\treturn ps->audio_streams[streamno]->freq;\n}\n\nu32 mpeg2ps_get_audio_stream_channels (mpeg2ps_t *ps, u32 streamno)\n{\n\tif (invalid_audio_streamno(ps, streamno)) {\n\t\treturn 0;\n\t}\n\treturn ps->audio_streams[streamno]->channels;\n}\n\nu32 mpeg2ps_get_audio_stream_bitrate (mpeg2ps_t *ps, u32 streamno)\n{\n\tif (invalid_audio_streamno(ps, streamno)) {\n\t\treturn 0;\n\t}\n\treturn ps->audio_streams[streamno]->bitrate;\n}\n\nu32 mpeg2ps_get_audio_stream_id (mpeg2ps_t *ps, u32 streamno)\n{\n\tif (invalid_audio_streamno(ps, streamno)) {\n\t\treturn 0;\n\t}\n\treturn ps->audio_streams[streamno]->m_stream_id;\n}\n\n\nmpeg2ps_t *mpeg2ps_init (const char *filename)\n{\n\tmpeg2ps_t *ps;\n\tGF_SAFEALLOC(ps, mpeg2ps_t);\n\n\tif (ps == NULL) {\n\t\treturn NULL;\n\t}\n\tmemset(ps, 0, sizeof(*ps));\n\tps->fd = file_open(filename);\n\tif (file_okay(ps->fd) == 0) {\n\t\tgf_free(ps);\n\t\treturn NULL;\n\t}\n\n\tps->filename = gf_strdup(filename);\n\tmpeg2ps_scan_file(ps);\n\tif (ps->video_cnt == 0 && ps->audio_cnt == 0) {\n\t\tmpeg2ps_close(ps);\n\t\treturn NULL;\n\t}\n\treturn ps;\n}\n\nvoid mpeg2ps_close (mpeg2ps_t *ps)\n{\n\tu32 ix;\n\tif (ps == NULL) return;\n\tfor (ix = 0; ix < ps->video_cnt; ix++) {\n\t\tmpeg2ps_stream_destroy(ps->video_streams[ix]);\n\t\tps->video_streams[ix] = NULL;\n\t}\n\tfor (ix = 0; ix < ps->audio_cnt; ix++) {\n\t\tmpeg2ps_stream_destroy(ps->audio_streams[ix]);\n\t\tps->audio_streams[ix] = NULL;\n\t}\n\n\tif (ps->filename) gf_free(ps->filename);\n\tif (ps->fd) file_close(ps->fd);\n\tgf_free(ps);\n}\n\n/*\n * check_fd_for_stream will make sure we have a fd for the stream we're\n * trying to read - we use a different fd for each stream\n */\n\n/*\n * stream_convert_frame_ts_to_msec - given a \"read\" frame, we'll\n * calculate the msec and freq timestamps.  This can be called more\n * than 1 time, if needed, without changing any variables, such as\n * frames_since_last_ts, which gets updated in advance_frame\n */\nstatic u64 stream_convert_frame_ts_to_msec (mpeg2ps_stream_t *sptr,\n        mpeg2ps_ts_type_t ts_type,\n        u64 base_dts,\n        u32 *freq_ts)\n{\n\tu64 calc_ts;\n\tu32 frames_since_last = 0;\n\tu64 freq_conv;\n\n\tcalc_ts = sptr->last_ts;\n\tif (sptr->frame_ts.have_dts) calc_ts = sptr->frame_ts.dts;\n\telse if (sptr->frame_ts.have_pts) calc_ts = sptr->frame_ts.dts;\n\telse frames_since_last = sptr->frames_since_last_ts + 1;\n\n\tif (freq_ts != NULL) {\n\t\tfreq_conv = calc_ts - base_dts;\n\t\tfreq_conv *= sptr->freq;\n\t\tfreq_conv /= 90000;\n\t\tfreq_conv += frames_since_last * sptr->samples_per_frame;\n\t\t*freq_ts = (u32) (freq_conv & 0xffffffff);\n\t}\n\treturn convert_ts(sptr, ts_type, calc_ts, base_dts, frames_since_last);\n}\n\n/*\n * mpeg2ps_get_video_frame - gets the next frame\n */\nBool mpeg2ps_get_video_frame(mpeg2ps_t *ps, u32 streamno,\n                             u8 **buffer,\n                             u32 *buflen,\n                             u8 *frame_type,\n                             mpeg2ps_ts_type_t ts_type,\n                             u64 *decode_timestamp, u64 *compose_timestamp)\n{\n\tu64 dts, cts;\n\tmpeg2ps_stream_t *sptr;\n\tif (invalid_video_streamno(ps, streamno)) return 0;\n\n\tsptr = ps->video_streams[streamno];\n\tcheck_fd_for_stream(ps, sptr);\n\n\tif (sptr->have_frame_loaded == 0) {\n\t\t// if we don't have the frame in the buffer (like after a seek),\n\t\t// read the next frame\n\t\tif (mpeg2ps_stream_find_mpeg_video_frame(sptr) == 0) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\t*buffer = sptr->pes_buffer + sptr->pes_buffer_on;\n\t*buflen = sptr->frame_len;\n\t// determine frame type\n\tif (frame_type != NULL) {\n\t\t*frame_type = MPEG12_PictHdrType(sptr->pes_buffer +\n\t\t                                 sptr->pict_header_offset);\n\t}\n\n\t// set the timestamps\n\tif (sptr->frame_ts.have_pts)\n\t\tcts = sptr->frame_ts.pts;\n\telse\n\t\tcts = sptr->last_ts + (1+sptr->frames_since_last_ts) * sptr->ticks_per_frame;\n\tif (sptr->frame_ts.have_dts)\n\t\tdts = sptr->frame_ts.dts;\n\telse\n\t\tdts = cts;\n\n\tif (decode_timestamp) *decode_timestamp = dts;\n\tif (compose_timestamp) *compose_timestamp = cts;\n\n\t//indicate that we read this frame - get ready for the next one.\n\tadvance_frame(sptr);\n\n\n\treturn 1;\n}\n\n\n// see above comments\nBool mpeg2ps_get_audio_frame(mpeg2ps_t *ps, u32 streamno,\n                             u8 **buffer,\n                             u32 *buflen,\n                             mpeg2ps_ts_type_t ts_type,\n                             u32 *freq_timestamp,\n                             u64 *timestamp)\n{\n\tmpeg2ps_stream_t *sptr;\n\tif (invalid_audio_streamno(ps, streamno)) return 0;\n\n\tsptr = ps->audio_streams[streamno];\n\tcheck_fd_for_stream(ps, sptr);\n\n\tif (sptr->have_frame_loaded == 0) {\n\t\tif (mpeg2ps_stream_read_frame(sptr, buffer, buflen, 0) == 0)\n\t\t\treturn 0;\n\t}\n\n\tif (freq_timestamp) {\n\t\t/*ts = */stream_convert_frame_ts_to_msec(sptr,\n\t\t                                     ts_type,\n\t\t                                     ps->first_dts,\n\t\t                                     freq_timestamp);\n\t}\n\tif (timestamp != NULL) {\n\t\t*timestamp = sptr->frame_ts.have_pts ? sptr->frame_ts.pts : sptr->frame_ts.dts;\n\t}\n\tadvance_frame(sptr);\n\treturn 1;\n}\n\n#if 0 //unused\nu64 mpeg2ps_get_ps_size(mpeg2ps_t *ps)\n{\n\treturn file_size(ps->fd);\n}\ns64 mpeg2ps_get_video_pos(mpeg2ps_t *ps, u32 streamno)\n{\n\tif (invalid_video_streamno(ps, streamno)) return 0;\n\treturn gf_ftell(ps->video_streams[streamno]->m_fd);\n}\ns64 mpeg2ps_get_audio_pos(mpeg2ps_t *ps, u32 streamno)\n{\n\tif (invalid_audio_streamno(ps, streamno)) return 0;\n\treturn gf_ftell(ps->audio_streams[streamno]->m_fd);\n}\n#endif\n\n\n/***************************************************************************\n * seek routines\n ***************************************************************************/\n/*\n * mpeg2ps_binary_seek - look for a pts that's close to the one that\n * we're looking for.  We have a start ts and location, an end ts and\n * location, and what we're looking for\n */\nstatic void mpeg2ps_binary_seek (mpeg2ps_t *ps,\n\t\t\t\t mpeg2ps_stream_t *sptr,\n\t\t\t\t u64 search_dts,\n\t\t\t\t u64 start_dts,\n\t\t\t\t u64 start_loc,\n\t\t\t\t u64 end_dts,\n\t\t\t\tu64 end_loc)\n{\n  u64 dts_perc;\n  u64 loc;\n  u16 pes_len;\n  Bool have_ts = GF_FALSE;\n  u64 found_loc;\n  u64 found_dts;\n\n  while (1) {\n    /*\n     * It's not a binary search as much as using a percentage between\n     * the start and end dts to start.  We subtract off a bit, so we\n     * approach from the beginning of the file - we're more likely to\n     * hit a pts that way\n     */\n    dts_perc = (search_dts - start_dts) * 1000 / (end_dts - start_dts);\n    dts_perc -= dts_perc % 10;\n\n    loc = ((end_loc - start_loc) * dts_perc) / 1000;\n\n    if (loc == start_loc || loc == end_loc) return;\n\n    clear_stream_buffer(sptr);\n    file_seek_to(sptr->m_fd, start_loc + loc);\n\n    // we'll look for the next pes header for this stream that has a ts.\n    do {\n      if (search_for_next_pes_header(sptr,\n\t\t\t\t     &pes_len,\n\t\t\t\t     &have_ts,\n\t\t\t\t     &found_loc) == GF_FALSE) {\n\treturn;\n      }\n      if (have_ts == GF_FALSE) {\n\tfile_skip_bytes(sptr->m_fd, pes_len);\n      }\n    } while (have_ts == GF_FALSE);\n\n    // record that spot...\n    mpeg2ps_record_pts(sptr, found_loc, &sptr->next_pes_ts);\n\n    found_dts = sptr->next_pes_ts.have_dts ?\n      sptr->next_pes_ts.dts : sptr->next_pes_ts.pts;\n    /*\n     * Now, if we're before the search ts, and within 5 seconds,\n     * we'll say we're close enough\n     */\n    if (found_dts + (5 * 90000) > search_dts &&\n\tfound_dts < search_dts) {\n      file_seek_to(sptr->m_fd, found_loc);\n      return; // found it - we can seek from here\n    }\n    /*\n     * otherwise, move the head or the tail (most likely the head).\n     */\n    if (found_dts > search_dts) {\n      if (found_dts >= end_dts) {\n\tfile_seek_to(sptr->m_fd, found_loc);\n\treturn;\n      }\n      end_loc = found_loc;\n      end_dts = found_dts;\n    } else {\n      if (found_dts <= start_dts) {\n\tfile_seek_to(sptr->m_fd, found_loc);\n\treturn;\n      }\n      start_loc = found_loc;\n      start_dts = found_dts;\n    }\n  }\n}\n\n\n\nstatic mpeg2ps_record_pes_t *search_for_ts (mpeg2ps_stream_t *sptr,\n\t\t\t\t     u64 dts)\n{\n  mpeg2ps_record_pes_t *p, *q;\n  u64 p_diff, q_diff;\n  if (sptr->record_last == NULL) return NULL;\n\n  if (dts > sptr->record_last->dts) return sptr->record_last;\n\n  if (dts < sptr->record_first->dts) return NULL;\n  if (dts == sptr->record_first->dts) return sptr->record_first;\n\n  p = sptr->record_first;\n  q = p->next_rec;\n\n  while (q != NULL && q->dts > dts) {\n    p = q;\n    q = q->next_rec;\n  }\n  if (q == NULL) {\n    return sptr->record_last;\n  }\n\n  p_diff = dts - p->dts;\n  q_diff = q->dts - dts;\n\n  if (p_diff < q_diff) return p;\n  if (q_diff > 90000) return p;\n\n  return q;\n}\n\n\n/*\n * mpeg2ps_seek_frame - seek to the next timestamp after the search timestamp\n * First, find a close DTS (usually minus 5 seconds or closer), then\n * read frames until we get the frame after the timestamp.\n */\nstatic Bool mpeg2ps_seek_frame (mpeg2ps_t *ps,\n\t\t\t\tmpeg2ps_stream_t *sptr,\n\t\t\t\tu64 search_msec_timestamp)\n{\n  u64 dts;\n  mpeg2ps_record_pes_t *rec;\n  u64 msec_ts;\n  u8 *buffer;\n  u32 buflen;\n\n  check_fd_for_stream(ps, sptr);\n  clear_stream_buffer(sptr);\n\n  if (search_msec_timestamp <= 1000) { // first second, start from begin...\n    file_seek_to(sptr->m_fd, sptr->first_pes_loc);\n    return GF_TRUE;\n  }\n  dts = search_msec_timestamp * 90; // 1000 timescale to 90000 timescale\n  dts += ps->first_dts;\n\n  /*\n   * see if the recorded data has anything close\n   */\n  rec = search_for_ts(sptr, dts);\n  if (rec != NULL) {\n    // see if it is close\n    // if we're plus or minus a second, seek to that.\n    if (rec->dts + 90000 >= dts && rec->dts <= dts + 90000) {\n      file_seek_to(sptr->m_fd, rec->location);\n      return GF_TRUE;\n    }\n    // at this point, rec is > a distance.  If within 5 or so seconds,\n\n    if (rec->dts + (5 * 90000) < dts) {\n      // more than 5 seconds away - skip and search\n      if (rec->next_rec == NULL) {\n\t\t  mpeg2ps_binary_seek(ps, sptr, dts,\n\t\t\t    rec->dts, rec->location,\n\t\t\t    sptr->end_dts, sptr->end_dts_loc);\n      } else {\n\t\t  mpeg2ps_binary_seek(ps, sptr, dts,\n\t\t\t    rec->dts, rec->location,\n\t\t\t    rec->next_rec->dts, rec->next_rec->location);\n      }\n    }\n    // otherwise, frame by frame search...\n  } else {\n    // we weren't able to find anything from the recording\n    mpeg2ps_binary_seek(ps, sptr, dts,\n\t\t\tsptr->start_dts, sptr->first_pes_loc,\n\t\t\tsptr->end_dts, sptr->end_dts_loc);\n  }\n  /*\n   * Now, the fun part - read frames until we're just past the time\n   */\n  clear_stream_buffer(sptr); // clear out any data, so we can read it\n  do {\n    if (mpeg2ps_stream_read_frame(sptr, &buffer, &buflen, GF_FALSE) == GF_FALSE)\n      return GF_FALSE;\n\n    msec_ts = stream_convert_frame_ts_to_msec(sptr, TS_MSEC,\n\t\t\t\t\t      ps->first_dts, NULL);\n\n    if (msec_ts < search_msec_timestamp) {\n      // only advance the frame if we're not greater than the timestamp\n      advance_frame(sptr);\n    }\n  } while (msec_ts < search_msec_timestamp);\n\n  return GF_TRUE;\n}\n\n\n/*\n * mpeg2ps_seek_video_frame - seek to the location that we're interested\n * in, then scroll up to the next I frame\n */\nBool mpeg2ps_seek_video_frame (mpeg2ps_t *ps, u32 streamno,\n\t\t\t       u64 msec_timestamp)\n{\n  mpeg2ps_stream_t *sptr;\n\n  if (invalid_video_streamno(ps, streamno)) return GF_FALSE;\n\n  sptr = ps->video_streams[streamno];\n  if (mpeg2ps_seek_frame(ps,\n\t\t\t sptr,\n\t\t\t msec_timestamp)\n\t\t\t  == GF_FALSE) return GF_FALSE;\n\n  if (sptr->have_frame_loaded == GF_FALSE) {\n    return GF_FALSE;\n  }\n  return GF_TRUE;\n}\n/*\n * mpeg2ps_seek_audio_frame - go to the closest audio frame after the\n * timestamp\n */\nBool mpeg2ps_seek_audio_frame (mpeg2ps_t *ps,\n\t\t\t       u32 streamno,\n\t\t\t       u64 msec_timestamp)\n{\n  //  off_t closest_pes;\n  mpeg2ps_stream_t *sptr;\n\n  if (invalid_audio_streamno(ps, streamno)) return GF_FALSE;\n\n  sptr = ps->audio_streams[streamno];\n  if (mpeg2ps_seek_frame(ps,\n\t\t\t sptr,\n\t\t\t msec_timestamp) == GF_FALSE) return GF_FALSE;\n\n  return GF_TRUE;\n}\n\nu64 mpeg2ps_get_first_cts(mpeg2ps_t *ps)\n{\n\treturn ps->first_dts;\n}\n\n\n#endif /*GPAC_DISABLE_MPEG2PS*/\n"], "filenames": ["src/filters/dasher.c", "src/media_tools/avilib.c", "src/media_tools/mpeg2_ps.c"], "buggy_code_start_loc": [8389, 1951, 998], "buggy_code_end_loc": [8408, 1980, 1206], "fixing_code_start_loc": [8390, 1951, 999], "fixing_code_end_loc": [8415, 1988, 1207], "type": "CWE-476", "message": "NULL Pointer Dereference in GitHub repository gpac/gpac prior to 2.3-DEV.", "other": {"cve": {"id": "CVE-2023-4681", "sourceIdentifier": "security@huntr.dev", "published": "2023-08-31T16:15:10.520", "lastModified": "2023-09-05T16:22:15.077", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "NULL Pointer Dereference in GitHub repository gpac/gpac prior to 2.3-DEV."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:N/S:U/C:N/I:L/A:L", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 5.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.5, "impactScore": 2.5}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-476"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:gpac:gpac:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.3", "matchCriteriaId": "422EDAFD-56FE-49AE-ADCF-7D33CFA0C56B"}]}]}], "references": [{"url": "https://github.com/gpac/gpac/commit/4bac19ad854159b21ba70d8ab7c4e1cd1db8ea1c", "source": "security@huntr.dev", "tags": ["Patch"]}, {"url": "https://huntr.dev/bounties/d67c5619-ab36-41cc-93b7-04828e25f60e", "source": "security@huntr.dev", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/gpac/gpac/commit/4bac19ad854159b21ba70d8ab7c4e1cd1db8ea1c"}}