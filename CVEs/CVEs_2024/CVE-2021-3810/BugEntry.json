{"buggy_code": ["import { logger } from \"@coder/logger\"\nimport * as argon2 from \"argon2\"\nimport * as cp from \"child_process\"\nimport * as crypto from \"crypto\"\nimport envPaths from \"env-paths\"\nimport { promises as fs } from \"fs\"\nimport * as net from \"net\"\nimport * as os from \"os\"\nimport * as path from \"path\"\nimport safeCompare from \"safe-compare\"\nimport * as util from \"util\"\nimport xdgBasedir from \"xdg-basedir\"\nimport { getFirstString } from \"../common/util\"\n\nexport interface Paths {\n  data: string\n  config: string\n  runtime: string\n}\n\n// From https://github.com/chalk/ansi-regex\nconst pattern = [\n  \"[\\\\u001B\\\\u009B][[\\\\]()#;?]*(?:(?:(?:[a-zA-Z\\\\d]*(?:;[-a-zA-Z\\\\d\\\\/#&.:=?%@~_]*)*)?\\\\u0007)\",\n  \"(?:(?:\\\\d{1,4}(?:;\\\\d{0,4})*)?[\\\\dA-PR-TZcf-ntqry=><~]))\",\n].join(\"|\")\nconst re = new RegExp(pattern, \"g\")\n\n/**\n * Split stdout on newlines and strip ANSI codes.\n */\nexport const onLine = (proc: cp.ChildProcess, callback: (strippedLine: string, originalLine: string) => void): void => {\n  let buffer = \"\"\n  if (!proc.stdout) {\n    throw new Error(\"no stdout\")\n  }\n  proc.stdout.setEncoding(\"utf8\")\n  proc.stdout.on(\"data\", (d) => {\n    const data = buffer + d\n    const split = data.split(\"\\n\")\n    const last = split.length - 1\n\n    for (let i = 0; i < last; ++i) {\n      callback(split[i].replace(re, \"\"), split[i])\n    }\n\n    // The last item will either be an empty string (the data ended with a\n    // newline) or a partial line (did not end with a newline) and we must\n    // wait to parse it until we get a full line.\n    buffer = split[last]\n  })\n}\n\nexport const paths = getEnvPaths()\n\n/**\n * Gets the config and data paths for the current platform/configuration.\n * On MacOS this function gets the standard XDG directories instead of using the native macOS\n * ones. Most CLIs do this as in practice only GUI apps use the standard macOS directories.\n */\nexport function getEnvPaths(): Paths {\n  const paths = envPaths(\"code-server\", { suffix: \"\" })\n  const append = (p: string): string => path.join(p, \"code-server\")\n  switch (process.platform) {\n    case \"darwin\":\n      return {\n        // envPaths uses native directories so force Darwin to use the XDG spec\n        // to align with other CLI tools.\n        data: xdgBasedir.data ? append(xdgBasedir.data) : paths.data,\n        config: xdgBasedir.config ? append(xdgBasedir.config) : paths.config,\n        // Fall back to temp if there is no runtime dir.\n        runtime: xdgBasedir.runtime ? append(xdgBasedir.runtime) : paths.temp,\n      }\n    case \"win32\":\n      return {\n        data: paths.data,\n        config: paths.config,\n        // Windows doesn't have a runtime dir.\n        runtime: paths.temp,\n      }\n    default:\n      return {\n        data: paths.data,\n        config: paths.config,\n        // Fall back to temp if there is no runtime dir.\n        runtime: xdgBasedir.runtime ? append(xdgBasedir.runtime) : paths.temp,\n      }\n  }\n}\n\n/**\n * humanPath replaces the home directory in p with ~.\n * Makes it more readable.\n *\n * @param p\n */\nexport function humanPath(p?: string): string {\n  if (!p) {\n    return \"\"\n  }\n  return p.replace(os.homedir(), \"~\")\n}\n\nexport const generateCertificate = async (hostname: string): Promise<{ cert: string; certKey: string }> => {\n  const certPath = path.join(paths.data, `${hostname.replace(/\\./g, \"_\")}.crt`)\n  const certKeyPath = path.join(paths.data, `${hostname.replace(/\\./g, \"_\")}.key`)\n\n  // Try generating the certificates if we can't access them (which probably\n  // means they don't exist).\n  try {\n    await Promise.all([fs.access(certPath), fs.access(certKeyPath)])\n  } catch (error) {\n    // Require on demand so openssl isn't required if you aren't going to\n    // generate certificates.\n    const pem = require(\"pem\") as typeof import(\"pem\")\n    const certs = await new Promise<import(\"pem\").CertificateCreationResult>((resolve, reject): void => {\n      pem.createCertificate(\n        {\n          selfSigned: true,\n          commonName: hostname,\n          config: `\n[req]\nreq_extensions = v3_req\n\n[ v3_req ]\nbasicConstraints = CA:true\nextendedKeyUsage = serverAuth\nsubjectAltName = @alt_names\n\n[alt_names]\nDNS.1 = ${hostname}\n`,\n        },\n        (error, result) => {\n          return error ? reject(error) : resolve(result)\n        },\n      )\n    })\n    await fs.mkdir(paths.data, { recursive: true })\n    await Promise.all([fs.writeFile(certPath, certs.certificate), fs.writeFile(certKeyPath, certs.serviceKey)])\n  }\n\n  return {\n    cert: certPath,\n    certKey: certKeyPath,\n  }\n}\n\nexport const generatePassword = async (length = 24): Promise<string> => {\n  const buffer = Buffer.alloc(Math.ceil(length / 2))\n  await util.promisify(crypto.randomFill)(buffer)\n  return buffer.toString(\"hex\").substring(0, length)\n}\n\n/**\n * Used to hash the password.\n */\nexport const hash = async (password: string): Promise<string> => {\n  try {\n    return await argon2.hash(password)\n  } catch (error) {\n    logger.error(error)\n    return \"\"\n  }\n}\n\n/**\n * Used to verify if the password matches the hash\n */\nexport const isHashMatch = async (password: string, hash: string) => {\n  if (password === \"\" || hash === \"\" || !hash.startsWith(\"$\")) {\n    return false\n  }\n  try {\n    return await argon2.verify(hash, password)\n  } catch (error) {\n    throw new Error(error)\n  }\n}\n\n/**\n * Used to hash the password using the sha256\n * algorithm. We only use this to for checking\n * the hashed-password set in the config.\n *\n * Kept for legacy reasons.\n */\nexport const hashLegacy = (str: string): string => {\n  return crypto.createHash(\"sha256\").update(str).digest(\"hex\")\n}\n\n/**\n * Used to check if the password matches the hash using\n * the hashLegacy function\n */\nexport const isHashLegacyMatch = (password: string, hashPassword: string) => {\n  const hashedWithLegacy = hashLegacy(password)\n  return safeCompare(hashedWithLegacy, hashPassword)\n}\n\nexport type PasswordMethod = \"SHA256\" | \"ARGON2\" | \"PLAIN_TEXT\"\n\n/**\n * Used to determine the password method.\n *\n * There are three options for the return value:\n * 1. \"SHA256\" -> the legacy hashing algorithm\n * 2. \"ARGON2\" -> the newest hashing algorithm\n * 3. \"PLAIN_TEXT\" -> regular ol' password with no hashing\n *\n * @returns {PasswordMethod} \"SHA256\" | \"ARGON2\" | \"PLAIN_TEXT\"\n */\nexport function getPasswordMethod(hashedPassword: string | undefined): PasswordMethod {\n  if (!hashedPassword) {\n    return \"PLAIN_TEXT\"\n  }\n\n  // This is the new hashing algorithm\n  if (hashedPassword.includes(\"$argon\")) {\n    return \"ARGON2\"\n  }\n\n  // This is the legacy hashing algorithm\n  return \"SHA256\"\n}\n\ntype PasswordValidation = {\n  isPasswordValid: boolean\n  hashedPassword: string\n}\n\ntype HandlePasswordValidationArgs = {\n  /** The PasswordMethod */\n  passwordMethod: PasswordMethod\n  /** The password provided by the user */\n  passwordFromRequestBody: string\n  /** The password set in PASSWORD or config */\n  passwordFromArgs: string | undefined\n  /** The hashed-password set in HASHED_PASSWORD or config */\n  hashedPasswordFromArgs: string | undefined\n}\n\n/**\n * Checks if a password is valid and also returns the hash\n * using the PasswordMethod\n */\nexport async function handlePasswordValidation({\n  passwordMethod,\n  passwordFromArgs,\n  passwordFromRequestBody,\n  hashedPasswordFromArgs,\n}: HandlePasswordValidationArgs): Promise<PasswordValidation> {\n  const passwordValidation = <PasswordValidation>{\n    isPasswordValid: false,\n    hashedPassword: \"\",\n  }\n\n  switch (passwordMethod) {\n    case \"PLAIN_TEXT\": {\n      const isValid = passwordFromArgs ? safeCompare(passwordFromRequestBody, passwordFromArgs) : false\n      passwordValidation.isPasswordValid = isValid\n\n      const hashedPassword = await hash(passwordFromRequestBody)\n      passwordValidation.hashedPassword = hashedPassword\n      break\n    }\n    case \"SHA256\": {\n      const isValid = isHashLegacyMatch(passwordFromRequestBody, hashedPasswordFromArgs || \"\")\n      passwordValidation.isPasswordValid = isValid\n\n      passwordValidation.hashedPassword = hashedPasswordFromArgs || (await hashLegacy(passwordFromRequestBody))\n      break\n    }\n    case \"ARGON2\": {\n      const isValid = await isHashMatch(passwordFromRequestBody, hashedPasswordFromArgs || \"\")\n      passwordValidation.isPasswordValid = isValid\n\n      passwordValidation.hashedPassword = hashedPasswordFromArgs || \"\"\n      break\n    }\n    default:\n      break\n  }\n\n  return passwordValidation\n}\n\nexport type IsCookieValidArgs = {\n  passwordMethod: PasswordMethod\n  cookieKey: string\n  hashedPasswordFromArgs: string | undefined\n  passwordFromArgs: string | undefined\n}\n\n/** Checks if a req.cookies.key is valid using the PasswordMethod */\nexport async function isCookieValid({\n  passwordFromArgs = \"\",\n  cookieKey,\n  hashedPasswordFromArgs = \"\",\n  passwordMethod,\n}: IsCookieValidArgs): Promise<boolean> {\n  let isValid = false\n  switch (passwordMethod) {\n    case \"PLAIN_TEXT\":\n      isValid = await isHashMatch(passwordFromArgs, cookieKey)\n      break\n    case \"ARGON2\":\n    case \"SHA256\":\n      isValid = safeCompare(cookieKey, hashedPasswordFromArgs)\n      break\n    default:\n      break\n  }\n  return isValid\n}\n\n/** Ensures that the input is sanitized by checking\n * - it's a string\n * - greater than 0 characters\n * - trims whitespace\n */\nexport function sanitizeString(str: string): string {\n  // Very basic sanitization of string\n  // Credit: https://stackoverflow.com/a/46719000/3015595\n  return typeof str === \"string\" && str.trim().length > 0 ? str.trim() : \"\"\n}\n\nconst mimeTypes: { [key: string]: string } = {\n  \".aac\": \"audio/x-aac\",\n  \".avi\": \"video/x-msvideo\",\n  \".bmp\": \"image/bmp\",\n  \".css\": \"text/css\",\n  \".flv\": \"video/x-flv\",\n  \".gif\": \"image/gif\",\n  \".html\": \"text/html\",\n  \".ico\": \"image/x-icon\",\n  \".jpe\": \"image/jpg\",\n  \".jpeg\": \"image/jpg\",\n  \".jpg\": \"image/jpg\",\n  \".js\": \"application/javascript\",\n  \".json\": \"application/json\",\n  \".m1v\": \"video/mpeg\",\n  \".m2a\": \"audio/mpeg\",\n  \".m2v\": \"video/mpeg\",\n  \".m3a\": \"audio/mpeg\",\n  \".mid\": \"audio/midi\",\n  \".midi\": \"audio/midi\",\n  \".mk3d\": \"video/x-matroska\",\n  \".mks\": \"video/x-matroska\",\n  \".mkv\": \"video/x-matroska\",\n  \".mov\": \"video/quicktime\",\n  \".movie\": \"video/x-sgi-movie\",\n  \".mp2\": \"audio/mpeg\",\n  \".mp2a\": \"audio/mpeg\",\n  \".mp3\": \"audio/mpeg\",\n  \".mp4\": \"video/mp4\",\n  \".mp4a\": \"audio/mp4\",\n  \".mp4v\": \"video/mp4\",\n  \".mpe\": \"video/mpeg\",\n  \".mpeg\": \"video/mpeg\",\n  \".mpg\": \"video/mpeg\",\n  \".mpg4\": \"video/mp4\",\n  \".mpga\": \"audio/mpeg\",\n  \".oga\": \"audio/ogg\",\n  \".ogg\": \"audio/ogg\",\n  \".ogv\": \"video/ogg\",\n  \".png\": \"image/png\",\n  \".psd\": \"image/vnd.adobe.photoshop\",\n  \".qt\": \"video/quicktime\",\n  \".spx\": \"audio/ogg\",\n  \".svg\": \"image/svg+xml\",\n  \".tga\": \"image/x-tga\",\n  \".tif\": \"image/tiff\",\n  \".tiff\": \"image/tiff\",\n  \".txt\": \"text/plain\",\n  \".wav\": \"audio/x-wav\",\n  \".wasm\": \"application/wasm\",\n  \".webm\": \"video/webm\",\n  \".webp\": \"image/webp\",\n  \".wma\": \"audio/x-ms-wma\",\n  \".wmv\": \"video/x-ms-wmv\",\n  \".woff\": \"application/font-woff\",\n}\n\nexport const getMediaMime = (filePath?: string): string => {\n  return (filePath && mimeTypes[path.extname(filePath)]) || \"text/plain\"\n}\n\nexport const isWsl = async (): Promise<boolean> => {\n  return (\n    (process.platform === \"linux\" && os.release().toLowerCase().indexOf(\"microsoft\") !== -1) ||\n    (await fs.readFile(\"/proc/version\", \"utf8\")).toLowerCase().indexOf(\"microsoft\") !== -1\n  )\n}\n\n/**\n * Try opening a URL using whatever the system has set for opening URLs.\n */\nexport const open = async (url: string): Promise<void> => {\n  const args = [] as string[]\n  const options = {} as cp.SpawnOptions\n  const platform = (await isWsl()) ? \"wsl\" : process.platform\n  let command = platform === \"darwin\" ? \"open\" : \"xdg-open\"\n  if (platform === \"win32\" || platform === \"wsl\") {\n    command = platform === \"wsl\" ? \"cmd.exe\" : \"cmd\"\n    args.push(\"/c\", \"start\", '\"\"', \"/b\")\n    url = url.replace(/&/g, \"^&\")\n  }\n  const proc = cp.spawn(command, [...args, url], options)\n  await new Promise<void>((resolve, reject) => {\n    proc.on(\"error\", reject)\n    proc.on(\"close\", (code) => {\n      return code !== 0 ? reject(new Error(`Failed to open with code ${code}`)) : resolve()\n    })\n  })\n}\n\n/**\n * For iterating over an enum's values.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport const enumToArray = (t: any): string[] => {\n  const values = [] as string[]\n  for (const k in t) {\n    values.push(t[k])\n  }\n  return values\n}\n\n/**\n * For displaying all allowed options in an enum.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport const buildAllowedMessage = (t: any): string => {\n  const values = enumToArray(t)\n  return `Allowed value${values.length === 1 ? \" is\" : \"s are\"} ${values.map((t) => `'${t}'`).join(\", \")}`\n}\n\nexport const isObject = <T extends object>(obj: T): obj is T => {\n  return !Array.isArray(obj) && typeof obj === \"object\" && obj !== null\n}\n\n/**\n * Taken from vs/base/common/charCode.ts. Copied for now instead of importing so\n * we don't have to set up a `vs` alias to be able to import with types (since\n * the alternative is to directly import from `out`).\n */\nenum CharCode {\n  Slash = 47,\n  A = 65,\n  Z = 90,\n  a = 97,\n  z = 122,\n  Colon = 58,\n}\n\n/**\n * Compute `fsPath` for the given uri.\n * Taken from vs/base/common/uri.ts. It's not imported to avoid also importing\n * everything that file imports.\n */\nexport function pathToFsPath(path: string, keepDriveLetterCasing = false): string {\n  const isWindows = process.platform === \"win32\"\n  const uri = { authority: undefined, path: getFirstString(path) || \"\", scheme: \"file\" }\n  let value: string\n\n  if (uri.authority && uri.path.length > 1 && uri.scheme === \"file\") {\n    // unc path: file://shares/c$/far/boo\n    value = `//${uri.authority}${uri.path}`\n  } else if (\n    uri.path.charCodeAt(0) === CharCode.Slash &&\n    ((uri.path.charCodeAt(1) >= CharCode.A && uri.path.charCodeAt(1) <= CharCode.Z) ||\n      (uri.path.charCodeAt(1) >= CharCode.a && uri.path.charCodeAt(1) <= CharCode.z)) &&\n    uri.path.charCodeAt(2) === CharCode.Colon\n  ) {\n    if (!keepDriveLetterCasing) {\n      // windows drive letter: file:///c:/far/boo\n      value = uri.path[1].toLowerCase() + uri.path.substr(2)\n    } else {\n      value = uri.path.substr(1)\n    }\n  } else {\n    // other path\n    value = uri.path\n  }\n  if (isWindows) {\n    value = value.replace(/\\//g, \"\\\\\")\n  }\n  return value\n}\n\n/**\n * Return a promise that resolves with whether the socket path is active.\n */\nexport function canConnect(path: string): Promise<boolean> {\n  return new Promise((resolve) => {\n    const socket = net.connect(path)\n    socket.once(\"error\", () => resolve(false))\n    socket.once(\"connect\", () => {\n      socket.destroy()\n      resolve(true)\n    })\n  })\n}\n\nexport const isFile = async (path: string): Promise<boolean> => {\n  try {\n    const stat = await fs.stat(path)\n    return stat.isFile()\n  } catch (error) {\n    return false\n  }\n}\n\n/**\n * Escapes any HTML string special characters, like &, <, >, \", and '.\n *\n * Source: https://stackoverflow.com/a/6234804/3015595\n **/\nexport function escapeHtml(unsafe: string): string {\n  return unsafe\n    .replace(/&/g, \"&amp;\")\n    .replace(/</g, \"&lt;\")\n    .replace(/>/g, \"&gt;\")\n    .replace(/\"/g, \"&quot;\")\n    .replace(/'/g, \"&apos;\")\n}\n"], "fixing_code": ["import { logger } from \"@coder/logger\"\nimport * as argon2 from \"argon2\"\nimport * as cp from \"child_process\"\nimport * as crypto from \"crypto\"\nimport envPaths from \"env-paths\"\nimport { promises as fs } from \"fs\"\nimport * as net from \"net\"\nimport * as os from \"os\"\nimport * as path from \"path\"\nimport safeCompare from \"safe-compare\"\nimport * as util from \"util\"\nimport xdgBasedir from \"xdg-basedir\"\nimport { getFirstString } from \"../common/util\"\n\nexport interface Paths {\n  data: string\n  config: string\n  runtime: string\n}\n\n// From https://github.com/chalk/ansi-regex\nconst pattern = [\n  \"[\\\\u001B\\\\u009B][[\\\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\\\d\\\\/#&.:=?%@~_]+)*|[a-zA-Z\\\\d]+(?:;[-a-zA-Z\\\\d\\\\/#&.:=?%@~_]*)*)?\\\\u0007)\",\n  \"(?:(?:\\\\d{1,4}(?:;\\\\d{0,4})*)?[\\\\dA-PR-TZcf-ntqry=><~]))\",\n].join(\"|\")\nconst re = new RegExp(pattern, \"g\")\n\n/**\n * Split stdout on newlines and strip ANSI codes.\n */\nexport const onLine = (proc: cp.ChildProcess, callback: (strippedLine: string, originalLine: string) => void): void => {\n  let buffer = \"\"\n  if (!proc.stdout) {\n    throw new Error(\"no stdout\")\n  }\n  proc.stdout.setEncoding(\"utf8\")\n  proc.stdout.on(\"data\", (d) => {\n    const data = buffer + d\n    const split = data.split(\"\\n\")\n    const last = split.length - 1\n\n    for (let i = 0; i < last; ++i) {\n      callback(split[i].replace(re, \"\"), split[i])\n    }\n\n    // The last item will either be an empty string (the data ended with a\n    // newline) or a partial line (did not end with a newline) and we must\n    // wait to parse it until we get a full line.\n    buffer = split[last]\n  })\n}\n\nexport const paths = getEnvPaths()\n\n/**\n * Gets the config and data paths for the current platform/configuration.\n * On MacOS this function gets the standard XDG directories instead of using the native macOS\n * ones. Most CLIs do this as in practice only GUI apps use the standard macOS directories.\n */\nexport function getEnvPaths(): Paths {\n  const paths = envPaths(\"code-server\", { suffix: \"\" })\n  const append = (p: string): string => path.join(p, \"code-server\")\n  switch (process.platform) {\n    case \"darwin\":\n      return {\n        // envPaths uses native directories so force Darwin to use the XDG spec\n        // to align with other CLI tools.\n        data: xdgBasedir.data ? append(xdgBasedir.data) : paths.data,\n        config: xdgBasedir.config ? append(xdgBasedir.config) : paths.config,\n        // Fall back to temp if there is no runtime dir.\n        runtime: xdgBasedir.runtime ? append(xdgBasedir.runtime) : paths.temp,\n      }\n    case \"win32\":\n      return {\n        data: paths.data,\n        config: paths.config,\n        // Windows doesn't have a runtime dir.\n        runtime: paths.temp,\n      }\n    default:\n      return {\n        data: paths.data,\n        config: paths.config,\n        // Fall back to temp if there is no runtime dir.\n        runtime: xdgBasedir.runtime ? append(xdgBasedir.runtime) : paths.temp,\n      }\n  }\n}\n\n/**\n * humanPath replaces the home directory in p with ~.\n * Makes it more readable.\n *\n * @param p\n */\nexport function humanPath(p?: string): string {\n  if (!p) {\n    return \"\"\n  }\n  return p.replace(os.homedir(), \"~\")\n}\n\nexport const generateCertificate = async (hostname: string): Promise<{ cert: string; certKey: string }> => {\n  const certPath = path.join(paths.data, `${hostname.replace(/\\./g, \"_\")}.crt`)\n  const certKeyPath = path.join(paths.data, `${hostname.replace(/\\./g, \"_\")}.key`)\n\n  // Try generating the certificates if we can't access them (which probably\n  // means they don't exist).\n  try {\n    await Promise.all([fs.access(certPath), fs.access(certKeyPath)])\n  } catch (error) {\n    // Require on demand so openssl isn't required if you aren't going to\n    // generate certificates.\n    const pem = require(\"pem\") as typeof import(\"pem\")\n    const certs = await new Promise<import(\"pem\").CertificateCreationResult>((resolve, reject): void => {\n      pem.createCertificate(\n        {\n          selfSigned: true,\n          commonName: hostname,\n          config: `\n[req]\nreq_extensions = v3_req\n\n[ v3_req ]\nbasicConstraints = CA:true\nextendedKeyUsage = serverAuth\nsubjectAltName = @alt_names\n\n[alt_names]\nDNS.1 = ${hostname}\n`,\n        },\n        (error, result) => {\n          return error ? reject(error) : resolve(result)\n        },\n      )\n    })\n    await fs.mkdir(paths.data, { recursive: true })\n    await Promise.all([fs.writeFile(certPath, certs.certificate), fs.writeFile(certKeyPath, certs.serviceKey)])\n  }\n\n  return {\n    cert: certPath,\n    certKey: certKeyPath,\n  }\n}\n\nexport const generatePassword = async (length = 24): Promise<string> => {\n  const buffer = Buffer.alloc(Math.ceil(length / 2))\n  await util.promisify(crypto.randomFill)(buffer)\n  return buffer.toString(\"hex\").substring(0, length)\n}\n\n/**\n * Used to hash the password.\n */\nexport const hash = async (password: string): Promise<string> => {\n  try {\n    return await argon2.hash(password)\n  } catch (error) {\n    logger.error(error)\n    return \"\"\n  }\n}\n\n/**\n * Used to verify if the password matches the hash\n */\nexport const isHashMatch = async (password: string, hash: string) => {\n  if (password === \"\" || hash === \"\" || !hash.startsWith(\"$\")) {\n    return false\n  }\n  try {\n    return await argon2.verify(hash, password)\n  } catch (error) {\n    throw new Error(error)\n  }\n}\n\n/**\n * Used to hash the password using the sha256\n * algorithm. We only use this to for checking\n * the hashed-password set in the config.\n *\n * Kept for legacy reasons.\n */\nexport const hashLegacy = (str: string): string => {\n  return crypto.createHash(\"sha256\").update(str).digest(\"hex\")\n}\n\n/**\n * Used to check if the password matches the hash using\n * the hashLegacy function\n */\nexport const isHashLegacyMatch = (password: string, hashPassword: string) => {\n  const hashedWithLegacy = hashLegacy(password)\n  return safeCompare(hashedWithLegacy, hashPassword)\n}\n\nexport type PasswordMethod = \"SHA256\" | \"ARGON2\" | \"PLAIN_TEXT\"\n\n/**\n * Used to determine the password method.\n *\n * There are three options for the return value:\n * 1. \"SHA256\" -> the legacy hashing algorithm\n * 2. \"ARGON2\" -> the newest hashing algorithm\n * 3. \"PLAIN_TEXT\" -> regular ol' password with no hashing\n *\n * @returns {PasswordMethod} \"SHA256\" | \"ARGON2\" | \"PLAIN_TEXT\"\n */\nexport function getPasswordMethod(hashedPassword: string | undefined): PasswordMethod {\n  if (!hashedPassword) {\n    return \"PLAIN_TEXT\"\n  }\n\n  // This is the new hashing algorithm\n  if (hashedPassword.includes(\"$argon\")) {\n    return \"ARGON2\"\n  }\n\n  // This is the legacy hashing algorithm\n  return \"SHA256\"\n}\n\ntype PasswordValidation = {\n  isPasswordValid: boolean\n  hashedPassword: string\n}\n\ntype HandlePasswordValidationArgs = {\n  /** The PasswordMethod */\n  passwordMethod: PasswordMethod\n  /** The password provided by the user */\n  passwordFromRequestBody: string\n  /** The password set in PASSWORD or config */\n  passwordFromArgs: string | undefined\n  /** The hashed-password set in HASHED_PASSWORD or config */\n  hashedPasswordFromArgs: string | undefined\n}\n\n/**\n * Checks if a password is valid and also returns the hash\n * using the PasswordMethod\n */\nexport async function handlePasswordValidation({\n  passwordMethod,\n  passwordFromArgs,\n  passwordFromRequestBody,\n  hashedPasswordFromArgs,\n}: HandlePasswordValidationArgs): Promise<PasswordValidation> {\n  const passwordValidation = <PasswordValidation>{\n    isPasswordValid: false,\n    hashedPassword: \"\",\n  }\n\n  switch (passwordMethod) {\n    case \"PLAIN_TEXT\": {\n      const isValid = passwordFromArgs ? safeCompare(passwordFromRequestBody, passwordFromArgs) : false\n      passwordValidation.isPasswordValid = isValid\n\n      const hashedPassword = await hash(passwordFromRequestBody)\n      passwordValidation.hashedPassword = hashedPassword\n      break\n    }\n    case \"SHA256\": {\n      const isValid = isHashLegacyMatch(passwordFromRequestBody, hashedPasswordFromArgs || \"\")\n      passwordValidation.isPasswordValid = isValid\n\n      passwordValidation.hashedPassword = hashedPasswordFromArgs || (await hashLegacy(passwordFromRequestBody))\n      break\n    }\n    case \"ARGON2\": {\n      const isValid = await isHashMatch(passwordFromRequestBody, hashedPasswordFromArgs || \"\")\n      passwordValidation.isPasswordValid = isValid\n\n      passwordValidation.hashedPassword = hashedPasswordFromArgs || \"\"\n      break\n    }\n    default:\n      break\n  }\n\n  return passwordValidation\n}\n\nexport type IsCookieValidArgs = {\n  passwordMethod: PasswordMethod\n  cookieKey: string\n  hashedPasswordFromArgs: string | undefined\n  passwordFromArgs: string | undefined\n}\n\n/** Checks if a req.cookies.key is valid using the PasswordMethod */\nexport async function isCookieValid({\n  passwordFromArgs = \"\",\n  cookieKey,\n  hashedPasswordFromArgs = \"\",\n  passwordMethod,\n}: IsCookieValidArgs): Promise<boolean> {\n  let isValid = false\n  switch (passwordMethod) {\n    case \"PLAIN_TEXT\":\n      isValid = await isHashMatch(passwordFromArgs, cookieKey)\n      break\n    case \"ARGON2\":\n    case \"SHA256\":\n      isValid = safeCompare(cookieKey, hashedPasswordFromArgs)\n      break\n    default:\n      break\n  }\n  return isValid\n}\n\n/** Ensures that the input is sanitized by checking\n * - it's a string\n * - greater than 0 characters\n * - trims whitespace\n */\nexport function sanitizeString(str: string): string {\n  // Very basic sanitization of string\n  // Credit: https://stackoverflow.com/a/46719000/3015595\n  return typeof str === \"string\" && str.trim().length > 0 ? str.trim() : \"\"\n}\n\nconst mimeTypes: { [key: string]: string } = {\n  \".aac\": \"audio/x-aac\",\n  \".avi\": \"video/x-msvideo\",\n  \".bmp\": \"image/bmp\",\n  \".css\": \"text/css\",\n  \".flv\": \"video/x-flv\",\n  \".gif\": \"image/gif\",\n  \".html\": \"text/html\",\n  \".ico\": \"image/x-icon\",\n  \".jpe\": \"image/jpg\",\n  \".jpeg\": \"image/jpg\",\n  \".jpg\": \"image/jpg\",\n  \".js\": \"application/javascript\",\n  \".json\": \"application/json\",\n  \".m1v\": \"video/mpeg\",\n  \".m2a\": \"audio/mpeg\",\n  \".m2v\": \"video/mpeg\",\n  \".m3a\": \"audio/mpeg\",\n  \".mid\": \"audio/midi\",\n  \".midi\": \"audio/midi\",\n  \".mk3d\": \"video/x-matroska\",\n  \".mks\": \"video/x-matroska\",\n  \".mkv\": \"video/x-matroska\",\n  \".mov\": \"video/quicktime\",\n  \".movie\": \"video/x-sgi-movie\",\n  \".mp2\": \"audio/mpeg\",\n  \".mp2a\": \"audio/mpeg\",\n  \".mp3\": \"audio/mpeg\",\n  \".mp4\": \"video/mp4\",\n  \".mp4a\": \"audio/mp4\",\n  \".mp4v\": \"video/mp4\",\n  \".mpe\": \"video/mpeg\",\n  \".mpeg\": \"video/mpeg\",\n  \".mpg\": \"video/mpeg\",\n  \".mpg4\": \"video/mp4\",\n  \".mpga\": \"audio/mpeg\",\n  \".oga\": \"audio/ogg\",\n  \".ogg\": \"audio/ogg\",\n  \".ogv\": \"video/ogg\",\n  \".png\": \"image/png\",\n  \".psd\": \"image/vnd.adobe.photoshop\",\n  \".qt\": \"video/quicktime\",\n  \".spx\": \"audio/ogg\",\n  \".svg\": \"image/svg+xml\",\n  \".tga\": \"image/x-tga\",\n  \".tif\": \"image/tiff\",\n  \".tiff\": \"image/tiff\",\n  \".txt\": \"text/plain\",\n  \".wav\": \"audio/x-wav\",\n  \".wasm\": \"application/wasm\",\n  \".webm\": \"video/webm\",\n  \".webp\": \"image/webp\",\n  \".wma\": \"audio/x-ms-wma\",\n  \".wmv\": \"video/x-ms-wmv\",\n  \".woff\": \"application/font-woff\",\n}\n\nexport const getMediaMime = (filePath?: string): string => {\n  return (filePath && mimeTypes[path.extname(filePath)]) || \"text/plain\"\n}\n\nexport const isWsl = async (): Promise<boolean> => {\n  return (\n    (process.platform === \"linux\" && os.release().toLowerCase().indexOf(\"microsoft\") !== -1) ||\n    (await fs.readFile(\"/proc/version\", \"utf8\")).toLowerCase().indexOf(\"microsoft\") !== -1\n  )\n}\n\n/**\n * Try opening a URL using whatever the system has set for opening URLs.\n */\nexport const open = async (url: string): Promise<void> => {\n  const args = [] as string[]\n  const options = {} as cp.SpawnOptions\n  const platform = (await isWsl()) ? \"wsl\" : process.platform\n  let command = platform === \"darwin\" ? \"open\" : \"xdg-open\"\n  if (platform === \"win32\" || platform === \"wsl\") {\n    command = platform === \"wsl\" ? \"cmd.exe\" : \"cmd\"\n    args.push(\"/c\", \"start\", '\"\"', \"/b\")\n    url = url.replace(/&/g, \"^&\")\n  }\n  const proc = cp.spawn(command, [...args, url], options)\n  await new Promise<void>((resolve, reject) => {\n    proc.on(\"error\", reject)\n    proc.on(\"close\", (code) => {\n      return code !== 0 ? reject(new Error(`Failed to open with code ${code}`)) : resolve()\n    })\n  })\n}\n\n/**\n * For iterating over an enum's values.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport const enumToArray = (t: any): string[] => {\n  const values = [] as string[]\n  for (const k in t) {\n    values.push(t[k])\n  }\n  return values\n}\n\n/**\n * For displaying all allowed options in an enum.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport const buildAllowedMessage = (t: any): string => {\n  const values = enumToArray(t)\n  return `Allowed value${values.length === 1 ? \" is\" : \"s are\"} ${values.map((t) => `'${t}'`).join(\", \")}`\n}\n\nexport const isObject = <T extends object>(obj: T): obj is T => {\n  return !Array.isArray(obj) && typeof obj === \"object\" && obj !== null\n}\n\n/**\n * Taken from vs/base/common/charCode.ts. Copied for now instead of importing so\n * we don't have to set up a `vs` alias to be able to import with types (since\n * the alternative is to directly import from `out`).\n */\nenum CharCode {\n  Slash = 47,\n  A = 65,\n  Z = 90,\n  a = 97,\n  z = 122,\n  Colon = 58,\n}\n\n/**\n * Compute `fsPath` for the given uri.\n * Taken from vs/base/common/uri.ts. It's not imported to avoid also importing\n * everything that file imports.\n */\nexport function pathToFsPath(path: string, keepDriveLetterCasing = false): string {\n  const isWindows = process.platform === \"win32\"\n  const uri = { authority: undefined, path: getFirstString(path) || \"\", scheme: \"file\" }\n  let value: string\n\n  if (uri.authority && uri.path.length > 1 && uri.scheme === \"file\") {\n    // unc path: file://shares/c$/far/boo\n    value = `//${uri.authority}${uri.path}`\n  } else if (\n    uri.path.charCodeAt(0) === CharCode.Slash &&\n    ((uri.path.charCodeAt(1) >= CharCode.A && uri.path.charCodeAt(1) <= CharCode.Z) ||\n      (uri.path.charCodeAt(1) >= CharCode.a && uri.path.charCodeAt(1) <= CharCode.z)) &&\n    uri.path.charCodeAt(2) === CharCode.Colon\n  ) {\n    if (!keepDriveLetterCasing) {\n      // windows drive letter: file:///c:/far/boo\n      value = uri.path[1].toLowerCase() + uri.path.substr(2)\n    } else {\n      value = uri.path.substr(1)\n    }\n  } else {\n    // other path\n    value = uri.path\n  }\n  if (isWindows) {\n    value = value.replace(/\\//g, \"\\\\\")\n  }\n  return value\n}\n\n/**\n * Return a promise that resolves with whether the socket path is active.\n */\nexport function canConnect(path: string): Promise<boolean> {\n  return new Promise((resolve) => {\n    const socket = net.connect(path)\n    socket.once(\"error\", () => resolve(false))\n    socket.once(\"connect\", () => {\n      socket.destroy()\n      resolve(true)\n    })\n  })\n}\n\nexport const isFile = async (path: string): Promise<boolean> => {\n  try {\n    const stat = await fs.stat(path)\n    return stat.isFile()\n  } catch (error) {\n    return false\n  }\n}\n\n/**\n * Escapes any HTML string special characters, like &, <, >, \", and '.\n *\n * Source: https://stackoverflow.com/a/6234804/3015595\n **/\nexport function escapeHtml(unsafe: string): string {\n  return unsafe\n    .replace(/&/g, \"&amp;\")\n    .replace(/</g, \"&lt;\")\n    .replace(/>/g, \"&gt;\")\n    .replace(/\"/g, \"&quot;\")\n    .replace(/'/g, \"&apos;\")\n}\n"], "filenames": ["src/node/util.ts"], "buggy_code_start_loc": [23], "buggy_code_end_loc": [24], "fixing_code_start_loc": [23], "fixing_code_end_loc": [24], "type": "NVD-CWE-Other", "message": "code-server is vulnerable to Inefficient Regular Expression Complexity", "other": {"cve": {"id": "CVE-2021-3810", "sourceIdentifier": "security@huntr.dev", "published": "2021-09-17T07:15:09.333", "lastModified": "2022-07-29T16:56:45.370", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "code-server is vulnerable to Inefficient Regular Expression Complexity"}, {"lang": "es", "value": "code-server es vulnerable a una Complejidad de Expresiones Regulares Ineficientes"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:C", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "COMPLETE", "baseScore": 7.8}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-Other"}]}, {"source": "security@huntr.dev", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-1333"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:coder:code-server:*:*:*:*:*:*:*:*", "versionEndExcluding": "3.12.0", "matchCriteriaId": "4A8C250D-8F9A-42EE-9812-CD490E316C28"}]}]}], "references": [{"url": "https://github.com/cdr/code-server/commit/ca617df135e78833f93c8320cb2d2cf8bba809f5", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/38888513-30fc-4d8f-805d-34070d60e223", "source": "security@huntr.dev", "tags": ["Exploit", "Issue Tracking", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/cdr/code-server/commit/ca617df135e78833f93c8320cb2d2cf8bba809f5"}}