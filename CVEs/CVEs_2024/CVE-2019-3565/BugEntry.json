{"buggy_code": ["/*\n * Copyright 2014-present Facebook, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#ifndef THRIFT_PROTOCOL_TPROTOCOL_H_\n#define THRIFT_PROTOCOL_TPROTOCOL_H_ 1\n\n#include <folly/portability/Sockets.h>\n#include <thrift/lib/cpp/protocol/TProtocolException.h>\n#include <thrift/lib/cpp/protocol/TType.h>\n#include <thrift/lib/cpp/transport/TTransport.h>\n#include <thrift/lib/cpp/util/BitwiseCast.h>\n\n#include <memory>\n\n#include <sys/types.h>\n#include <map>\n#include <string>\n#include <vector>\n\n#include <folly/FBString.h>\n\nnamespace apache {\nnamespace thrift {\nnamespace reflection {\nclass Schema;\n}\n} // namespace thrift\n} // namespace apache\n\nnamespace apache {\nnamespace thrift {\nnamespace protocol {\n\nusing apache::thrift::transport::TTransport;\n\n/**\n * Enumerated definition of the message types that the Thrift protocol\n * supports.\n */\nenum TMessageType { T_CALL = 1, T_REPLY = 2, T_EXCEPTION = 3, T_ONEWAY = 4 };\n\n/**\n * Helper template for implementing TProtocol::skip().\n *\n * Templatized to avoid having to make virtual function calls.\n */\ntemplate <class Protocol_>\nuint32_t skip(Protocol_& prot, TType arg_type) {\n  switch (arg_type) {\n    case T_BOOL: {\n      bool boolv;\n      return prot.readBool(boolv);\n    }\n    case T_BYTE: {\n      int8_t bytev = 0;\n      return prot.readByte(bytev);\n    }\n    case T_I16: {\n      int16_t i16;\n      return prot.readI16(i16);\n    }\n    case T_I32: {\n      int32_t i32;\n      return prot.readI32(i32);\n    }\n    case T_I64: {\n      int64_t i64;\n      return prot.readI64(i64);\n    }\n    case T_DOUBLE: {\n      double dub;\n      return prot.readDouble(dub);\n    }\n    case T_FLOAT: {\n      float flt;\n      return prot.readFloat(flt);\n    }\n    case T_STRING: {\n      std::string str;\n      return prot.readBinary(str);\n    }\n    case T_STRUCT: {\n      uint32_t result = 0;\n      std::string name;\n      int16_t fid;\n      TType ftype;\n      result += prot.readStructBegin(name);\n      while (true) {\n        result += prot.readFieldBegin(name, ftype, fid);\n        if (ftype == T_STOP) {\n          break;\n        }\n        result += skip(prot, ftype);\n        result += prot.readFieldEnd();\n      }\n      result += prot.readStructEnd();\n      return result;\n    }\n    case T_MAP: {\n      uint32_t result = 0;\n      TType keyType;\n      TType valType;\n      uint32_t i, size;\n      bool sizeUnknown;\n      result += prot.readMapBegin(keyType, valType, size, sizeUnknown);\n      if (!sizeUnknown) {\n        for (i = 0; i < size; i++) {\n          result += skip(prot, keyType);\n          result += skip(prot, valType);\n        }\n      } else {\n        while (prot.peekMap()) {\n          result += skip(prot, keyType);\n          result += skip(prot, valType);\n        }\n      }\n      result += prot.readMapEnd();\n      return result;\n    }\n    case T_SET: {\n      uint32_t result = 0;\n      TType elemType;\n      uint32_t i, size;\n      bool sizeUnknown;\n      result += prot.readSetBegin(elemType, size, sizeUnknown);\n      if (!sizeUnknown) {\n        for (i = 0; i < size; i++) {\n          result += skip(prot, elemType);\n        }\n      } else {\n        while (prot.peekSet()) {\n          result += skip(prot, elemType);\n        }\n      }\n      result += prot.readSetEnd();\n      return result;\n    }\n    case T_LIST: {\n      uint32_t result = 0;\n      TType elemType;\n      uint32_t i, size;\n      bool sizeUnknown;\n      result += prot.readListBegin(elemType, size, sizeUnknown);\n      if (!sizeUnknown) {\n        for (i = 0; i < size; i++) {\n          result += skip(prot, elemType);\n        }\n      } else {\n        while (prot.peekList()) {\n          result += skip(prot, elemType);\n        }\n      }\n      result += prot.readListEnd();\n      return result;\n    }\n    default:\n      return 0;\n  }\n}\n\n// TODO(denplusplus): remove.\n// DO NOT USE.\ntemplate <typename Protocol_, typename T>\nuint32_t readIntegral(Protocol_& prot, TType arg_type, T& value) {\n  switch (arg_type) {\n    case TType::T_BOOL: {\n      bool boolv;\n      auto res = prot.readBool(boolv);\n      value = static_cast<T>(boolv);\n      return res;\n    }\n    case TType::T_BYTE: {\n      int8_t bytev;\n      auto res = prot.readByte(bytev);\n      value = static_cast<T>(bytev);\n      return res;\n    }\n    case TType::T_I16: {\n      int16_t i16;\n      auto res = prot.readI16(i16);\n      value = static_cast<T>(i16);\n      return res;\n    }\n    case TType::T_I32: {\n      int32_t i32;\n      auto res = prot.readI32(i32);\n      value = static_cast<T>(i32);\n      return res;\n    }\n    case TType::T_I64: {\n      int64_t i64;\n      auto res = prot.readI64(i64);\n      value = static_cast<T>(i64);\n      return res;\n    }\n    default: {\n      throw TProtocolException(\n          std::string(\"Cannot parse integral number of \") +\n          std::to_string(arg_type) + \" type\");\n    }\n  }\n}\n\n// TODO(denplusplus): remove.\n// DO NOT USE.\ntemplate <typename Protocol_, typename T>\nuint32_t readFloatingPoint(Protocol_& prot, TType arg_type, T& value) {\n  switch (arg_type) {\n    case TType::T_DOUBLE: {\n      double dub;\n      auto res = prot.readDouble(dub);\n      value = static_cast<T>(dub);\n      return res;\n    }\n    case TType::T_FLOAT: {\n      float flt;\n      auto res = prot.readFloat(flt);\n      value = static_cast<T>(flt);\n      return res;\n    }\n    default: {\n      throw TProtocolException(\n          std::string(\"Cannot parse floating number of \") +\n          std::to_string(arg_type) + \" type\");\n    }\n  }\n}\n\n/**\n * Abstract class for a thrift protocol driver. These are all the methods that\n * a protocol must implement. Essentially, there must be some way of reading\n * and writing all the base types, plus a mechanism for writing out structs\n * with indexed fields.\n *\n * TProtocol objects should not be shared across multiple encoding contexts,\n * as they may need to maintain internal state in some protocols (i.e. XML).\n * Note that it is acceptable for the TProtocol module to do its own internal\n * buffered reads/writes to the underlying TTransport where appropriate (i.e.\n * when parsing an input XML stream, reading should be batched rather than\n * looking ahead character by character for a close tag).\n *\n */\nclass TProtocol {\n public:\n  virtual ~TProtocol() {}\n\n  virtual void setVersion_virt(const int8_t version) = 0;\n\n  void setVersion(const int8_t version) {\n    T_VIRTUAL_CALL();\n    return setVersion_virt(version);\n  }\n\n  virtual ::apache::thrift::reflection::Schema* getSchema_virt() = 0;\n\n  ::apache::thrift::reflection::Schema* getSchema() {\n    T_VIRTUAL_CALL();\n    return getSchema_virt();\n  }\n\n  /**\n   * Writing functions.\n   */\n\n  virtual uint32_t writeMessageBegin_virt(\n      const std::string& name,\n      const TMessageType messageType,\n      const int32_t seqid) = 0;\n\n  virtual uint32_t writeMessageEnd_virt() = 0;\n\n  virtual uint32_t writeStructBegin_virt(const char* name) = 0;\n\n  virtual uint32_t writeStructEnd_virt() = 0;\n\n  virtual uint32_t writeFieldBegin_virt(\n      const char* name,\n      const TType fieldType,\n      const int16_t fieldId) = 0;\n\n  virtual uint32_t writeFieldEnd_virt() = 0;\n\n  virtual uint32_t writeFieldStop_virt() = 0;\n\n  virtual uint32_t writeMapBegin_virt(\n      const TType keyType,\n      const TType valType,\n      const uint32_t size) = 0;\n\n  virtual uint32_t writeMapEnd_virt() = 0;\n\n  virtual uint32_t writeListBegin_virt(\n      const TType elemType,\n      const uint32_t size) = 0;\n\n  virtual uint32_t writeListEnd_virt() = 0;\n\n  virtual uint32_t writeSetBegin_virt(\n      const TType elemType,\n      const uint32_t size) = 0;\n\n  virtual uint32_t writeSetEnd_virt() = 0;\n\n  virtual uint32_t writeBool_virt(const bool value) = 0;\n\n  virtual uint32_t writeByte_virt(const int8_t byte) = 0;\n\n  virtual uint32_t writeI16_virt(const int16_t i16) = 0;\n\n  virtual uint32_t writeI32_virt(const int32_t i32) = 0;\n\n  virtual uint32_t writeI64_virt(const int64_t i64) = 0;\n\n  virtual uint32_t writeDouble_virt(const double dub) = 0;\n\n  virtual uint32_t writeFloat_virt(const float flt) = 0;\n\n  virtual uint32_t writeString_virt(const std::string& str) = 0;\n\n  virtual uint32_t writeBinary_virt(const std::string& str) = 0;\n\n  uint32_t writeMessageBegin(\n      const std::string& name,\n      const TMessageType messageType,\n      const int32_t seqid) {\n    T_VIRTUAL_CALL();\n    return writeMessageBegin_virt(name, messageType, seqid);\n  }\n\n  uint32_t writeMessageEnd() {\n    T_VIRTUAL_CALL();\n    return writeMessageEnd_virt();\n  }\n\n  uint32_t writeStructBegin(const char* name) {\n    T_VIRTUAL_CALL();\n    return writeStructBegin_virt(name);\n  }\n\n  uint32_t writeStructEnd() {\n    T_VIRTUAL_CALL();\n    return writeStructEnd_virt();\n  }\n\n  uint32_t writeFieldBegin(\n      const char* name,\n      const TType fieldType,\n      const int16_t fieldId) {\n    T_VIRTUAL_CALL();\n    return writeFieldBegin_virt(name, fieldType, fieldId);\n  }\n\n  uint32_t writeFieldEnd() {\n    T_VIRTUAL_CALL();\n    return writeFieldEnd_virt();\n  }\n\n  uint32_t writeFieldStop() {\n    T_VIRTUAL_CALL();\n    return writeFieldStop_virt();\n  }\n\n  uint32_t\n  writeMapBegin(const TType keyType, const TType valType, const uint32_t size) {\n    T_VIRTUAL_CALL();\n    return writeMapBegin_virt(keyType, valType, size);\n  }\n\n  uint32_t writeMapEnd() {\n    T_VIRTUAL_CALL();\n    return writeMapEnd_virt();\n  }\n\n  uint32_t writeListBegin(const TType elemType, const uint32_t size) {\n    T_VIRTUAL_CALL();\n    return writeListBegin_virt(elemType, size);\n  }\n\n  uint32_t writeListEnd() {\n    T_VIRTUAL_CALL();\n    return writeListEnd_virt();\n  }\n\n  uint32_t writeSetBegin(const TType elemType, const uint32_t size) {\n    T_VIRTUAL_CALL();\n    return writeSetBegin_virt(elemType, size);\n  }\n\n  uint32_t writeSetEnd() {\n    T_VIRTUAL_CALL();\n    return writeSetEnd_virt();\n  }\n\n  uint32_t writeBool(const bool value) {\n    T_VIRTUAL_CALL();\n    return writeBool_virt(value);\n  }\n\n  uint32_t writeByte(const int8_t byte) {\n    T_VIRTUAL_CALL();\n    return writeByte_virt(byte);\n  }\n\n  uint32_t writeI16(const int16_t i16) {\n    T_VIRTUAL_CALL();\n    return writeI16_virt(i16);\n  }\n\n  uint32_t writeI32(const int32_t i32) {\n    T_VIRTUAL_CALL();\n    return writeI32_virt(i32);\n  }\n\n  uint32_t writeI64(const int64_t i64) {\n    T_VIRTUAL_CALL();\n    return writeI64_virt(i64);\n  }\n\n  uint32_t writeDouble(const double dub) {\n    T_VIRTUAL_CALL();\n    return writeDouble_virt(dub);\n  }\n\n  uint32_t writeFloat(const float flt) {\n    T_VIRTUAL_CALL();\n    return writeFloat_virt(flt);\n  }\n\n  uint32_t writeString(const std::string& str) {\n    T_VIRTUAL_CALL();\n    return writeString_virt(str);\n  }\n\n  uint32_t writeString(const folly::fbstring& str) {\n    T_VIRTUAL_CALL();\n    return writeString_virt(str.toStdString());\n  }\n\n  uint32_t writeBinary(const std::string& str) {\n    T_VIRTUAL_CALL();\n    return writeBinary_virt(str);\n  }\n\n  uint32_t writeBinary(const folly::fbstring& str) {\n    T_VIRTUAL_CALL();\n    return writeBinary_virt(str.toStdString());\n  }\n\n  /**\n   * Reading functions\n   */\n\n  virtual uint32_t readMessageBegin_virt(\n      std::string& name,\n      TMessageType& messageType,\n      int32_t& seqid) = 0;\n\n  virtual uint32_t readMessageEnd_virt() = 0;\n\n  virtual void setNextStructType_virt(uint64_t reflection_id) = 0;\n\n  virtual uint32_t readStructBegin_virt(std::string& name) = 0;\n\n  virtual uint32_t readStructEnd_virt() = 0;\n\n  virtual uint32_t readFieldBegin_virt(\n      std::string& name,\n      TType& fieldType,\n      int16_t& fieldId) = 0;\n\n  virtual uint32_t readFieldEnd_virt() = 0;\n\n  virtual uint32_t readMapBegin_virt(\n      TType& keyType,\n      TType& valType,\n      uint32_t& size,\n      bool& sizeUnknown) = 0;\n\n  virtual bool peekMap_virt() = 0;\n\n  virtual uint32_t readMapEnd_virt() = 0;\n\n  virtual uint32_t\n  readListBegin_virt(TType& elemType, uint32_t& size, bool& sizeUnknown) = 0;\n\n  virtual bool peekList_virt() = 0;\n\n  virtual uint32_t readListEnd_virt() = 0;\n\n  virtual uint32_t\n  readSetBegin_virt(TType& elemType, uint32_t& size, bool& sizeUnknown) = 0;\n\n  virtual bool peekSet_virt() = 0;\n\n  virtual uint32_t readSetEnd_virt() = 0;\n\n  virtual uint32_t readBool_virt(bool& value) = 0;\n\n  virtual uint32_t readBool_virt(std::vector<bool>::reference value) = 0;\n\n  virtual uint32_t readByte_virt(int8_t& byte) = 0;\n\n  virtual uint32_t readI16_virt(int16_t& i16) = 0;\n\n  virtual uint32_t readI32_virt(int32_t& i32) = 0;\n\n  virtual uint32_t readI64_virt(int64_t& i64) = 0;\n\n  virtual uint32_t readDouble_virt(double& dub) = 0;\n\n  virtual uint32_t readFloat_virt(float& flt) = 0;\n\n  virtual uint32_t readString_virt(std::string& str) = 0;\n\n  virtual uint32_t readBinary_virt(std::string& str) = 0;\n\n  uint32_t readMessageBegin(\n      std::string& name,\n      TMessageType& messageType,\n      int32_t& seqid) {\n    T_VIRTUAL_CALL();\n    return readMessageBegin_virt(name, messageType, seqid);\n  }\n\n  uint32_t readMessageEnd() {\n    T_VIRTUAL_CALL();\n    return readMessageEnd_virt();\n  }\n\n  void setNextStructType(uint64_t reflection_id) {\n    T_VIRTUAL_CALL();\n    return setNextStructType_virt(reflection_id);\n  }\n\n  uint32_t readStructBegin(std::string& name) {\n    T_VIRTUAL_CALL();\n    return readStructBegin_virt(name);\n  }\n\n  uint32_t readStructEnd() {\n    T_VIRTUAL_CALL();\n    return readStructEnd_virt();\n  }\n\n  uint32_t\n  readFieldBegin(std::string& name, TType& fieldType, int16_t& fieldId) {\n    T_VIRTUAL_CALL();\n    return readFieldBegin_virt(name, fieldType, fieldId);\n  }\n\n  uint32_t readFieldEnd() {\n    T_VIRTUAL_CALL();\n    return readFieldEnd_virt();\n  }\n\n  uint32_t readMapBegin(\n      TType& keyType,\n      TType& valType,\n      uint32_t& size,\n      bool& sizeUnknown) {\n    T_VIRTUAL_CALL();\n    return readMapBegin_virt(keyType, valType, size, sizeUnknown);\n  }\n\n  bool peekMap() {\n    T_VIRTUAL_CALL();\n    return peekMap_virt();\n  }\n\n  uint32_t readMapEnd() {\n    T_VIRTUAL_CALL();\n    return readMapEnd_virt();\n  }\n\n  uint32_t readListBegin(TType& elemType, uint32_t& size, bool& sizeUnknown) {\n    T_VIRTUAL_CALL();\n    return readListBegin_virt(elemType, size, sizeUnknown);\n  }\n\n  bool peekList() {\n    T_VIRTUAL_CALL();\n    return peekList_virt();\n  }\n\n  uint32_t readListEnd() {\n    T_VIRTUAL_CALL();\n    return readListEnd_virt();\n  }\n\n  uint32_t readSetBegin(TType& elemType, uint32_t& size, bool& sizeUnknown) {\n    T_VIRTUAL_CALL();\n    return readSetBegin_virt(elemType, size, sizeUnknown);\n  }\n\n  bool peekSet() {\n    T_VIRTUAL_CALL();\n    return peekSet_virt();\n  }\n\n  uint32_t readSetEnd() {\n    T_VIRTUAL_CALL();\n    return readSetEnd_virt();\n  }\n\n  uint32_t readBool(bool& value) {\n    T_VIRTUAL_CALL();\n    return readBool_virt(value);\n  }\n\n  uint32_t readByte(int8_t& byte) {\n    T_VIRTUAL_CALL();\n    return readByte_virt(byte);\n  }\n\n  uint32_t readI16(int16_t& i16) {\n    T_VIRTUAL_CALL();\n    return readI16_virt(i16);\n  }\n\n  uint32_t readI32(int32_t& i32) {\n    T_VIRTUAL_CALL();\n    return readI32_virt(i32);\n  }\n\n  uint32_t readI64(int64_t& i64) {\n    T_VIRTUAL_CALL();\n    return readI64_virt(i64);\n  }\n\n  uint32_t readDouble(double& dub) {\n    T_VIRTUAL_CALL();\n    return readDouble_virt(dub);\n  }\n\n  uint32_t readFloat(float& flt) {\n    T_VIRTUAL_CALL();\n    return readFloat_virt(flt);\n  }\n\n  uint32_t readString(std::string& str) {\n    T_VIRTUAL_CALL();\n    return readString_virt(str);\n  }\n\n  uint32_t readString(folly::fbstring& str) {\n    T_VIRTUAL_CALL();\n    std::string data;\n    uint32_t ret = readString_virt(data);\n    str = data;\n    return ret;\n  }\n\n  uint32_t readBinary(std::string& str) {\n    T_VIRTUAL_CALL();\n    return readBinary_virt(str);\n  }\n\n  uint32_t readBinary(folly::fbstring& str) {\n    T_VIRTUAL_CALL();\n    std::string data;\n    uint32_t ret = readBinary_virt(data);\n    str = data;\n    return ret;\n  }\n\n  int32_t getStringSizeLimit() {\n    return 0; // No limit\n  }\n\n  int32_t getContainerSizeLimit() {\n    return 0; // No limit\n  }\n\n  /*\n   * std::vector is specialized for bool, and its elements are individual bits\n   * rather than bools.   We need to define a different version of readBool()\n   * to work with std::vector<bool>.\n   */\n  uint32_t readBool(std::vector<bool>::reference value) {\n    T_VIRTUAL_CALL();\n    return readBool_virt(value);\n  }\n\n  /**\n   * Method to arbitrarily skip over data.\n   */\n  uint32_t skip(TType type) {\n    T_VIRTUAL_CALL();\n    return skip_virt(type);\n  }\n  virtual uint32_t skip_virt(TType type) {\n    return ::apache::thrift::protocol::skip(*this, type);\n  }\n\n  inline std::shared_ptr<TTransport> getTransport() {\n    return ptrans_;\n  }\n\n  // TODO: remove these two calls, they are for backwards\n  // compatibility\n  inline std::shared_ptr<TTransport> getInputTransport() {\n    return ptrans_;\n  }\n  inline std::shared_ptr<TTransport> getOutputTransport() {\n    return ptrans_;\n  }\n\n protected:\n  explicit TProtocol(std::shared_ptr<TTransport> ptrans) : ptrans_(ptrans) {}\n\n  /**\n   * Construct a TProtocol using a raw TTransport pointer.\n   *\n   * It is the callers responsibility to ensure that the TTransport remains\n   * valid for the lifetime of the TProtocol object.\n   */\n  explicit TProtocol(TTransport* ptrans)\n      : ptrans_(ptrans, [](TTransport*) {}) {}\n\n  std::shared_ptr<TTransport> ptrans_;\n\n private:\n  TProtocol() {}\n};\n\n/**\n * Constructs protocol objects given transports.\n */\nclass TProtocolFactory {\n public:\n  TProtocolFactory() {}\n\n  virtual ~TProtocolFactory() {}\n\n  virtual std::shared_ptr<TProtocol> getProtocol(\n      std::shared_ptr<TTransport> trans) = 0;\n};\n\n/**\n * Constructs both input and output protocol objects with a given pair of\n * input and output transports.\n *\n * TProtocolPair.first = Input Protocol\n * TProtocolPair.second = Output Protocol\n */\ntypedef std::pair<std::shared_ptr<TProtocol>, std::shared_ptr<TProtocol>>\n    TProtocolPair;\n\nclass TDuplexProtocolFactory {\n public:\n  TDuplexProtocolFactory() {}\n\n  virtual ~TDuplexProtocolFactory() {}\n\n  virtual TProtocolPair getProtocol(transport::TTransportPair transports) = 0;\n\n  virtual std::shared_ptr<TProtocolFactory> getInputProtocolFactory() {\n    return std::shared_ptr<TProtocolFactory>();\n  }\n\n  virtual std::shared_ptr<TProtocolFactory> getOutputProtocolFactory() {\n    return std::shared_ptr<TProtocolFactory>();\n  }\n};\n\n/**\n * Adapts a TProtocolFactory to a TDuplexProtocolFactory that returns\n * a new protocol object for both input and output\n */\ntemplate <class Factory_>\nclass TSingleProtocolFactory : public TDuplexProtocolFactory {\n public:\n  TSingleProtocolFactory() {\n    factory_.reset(new Factory_());\n  }\n\n  explicit TSingleProtocolFactory(std::shared_ptr<Factory_> factory)\n      : factory_(factory) {}\n\n  TProtocolPair getProtocol(transport::TTransportPair transports) override {\n    return std::make_pair(\n        factory_->getProtocol(transports.first),\n        factory_->getProtocol(transports.second));\n  }\n\n  std::shared_ptr<TProtocolFactory> getInputProtocolFactory() override {\n    return factory_;\n  }\n\n  std::shared_ptr<TProtocolFactory> getOutputProtocolFactory() override {\n    return factory_;\n  }\n\n private:\n  std::shared_ptr<Factory_> factory_;\n};\n\n/**\n * Use TDualProtocolFactory to construct input and output protocols from\n * different factories.\n */\nclass TDualProtocolFactory : public TDuplexProtocolFactory {\n public:\n  TDualProtocolFactory(\n      std::shared_ptr<TProtocolFactory> inputFactory,\n      std::shared_ptr<TProtocolFactory> outputFactory)\n      : inputFactory_(inputFactory), outputFactory_(outputFactory) {}\n\n  TProtocolPair getProtocol(transport::TTransportPair transports) override {\n    return std::make_pair(\n        inputFactory_->getProtocol(transports.first),\n        outputFactory_->getProtocol(transports.second));\n  }\n\n  std::shared_ptr<TProtocolFactory> getInputProtocolFactory() override {\n    return inputFactory_;\n  }\n\n  std::shared_ptr<TProtocolFactory> getOutputProtocolFactory() override {\n    return outputFactory_;\n  }\n\n private:\n  std::shared_ptr<TProtocolFactory> inputFactory_;\n  std::shared_ptr<TProtocolFactory> outputFactory_;\n};\n\n/**\n * Dummy protocol class.\n *\n * This class does nothing, and should never be instantiated.\n * It is used only by the generator code.\n */\nclass TDummyProtocol : public TProtocol {};\n\n} // namespace protocol\n} // namespace thrift\n} // namespace apache\n\n#endif // #define _THRIFT_PROTOCOL_TPROTOCOL_H_ 1\n"], "fixing_code": ["/*\n * Copyright 2014-present Facebook, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#ifndef THRIFT_PROTOCOL_TPROTOCOL_H_\n#define THRIFT_PROTOCOL_TPROTOCOL_H_ 1\n\n#include <folly/portability/Sockets.h>\n#include <thrift/lib/cpp/protocol/TProtocolException.h>\n#include <thrift/lib/cpp/protocol/TType.h>\n#include <thrift/lib/cpp/transport/TTransport.h>\n#include <thrift/lib/cpp/util/BitwiseCast.h>\n\n#include <memory>\n\n#include <sys/types.h>\n#include <map>\n#include <string>\n#include <vector>\n\n#include <folly/FBString.h>\n\nnamespace apache {\nnamespace thrift {\nnamespace reflection {\nclass Schema;\n}\n} // namespace thrift\n} // namespace apache\n\nnamespace apache {\nnamespace thrift {\nnamespace protocol {\n\nusing apache::thrift::transport::TTransport;\n\n/**\n * Enumerated definition of the message types that the Thrift protocol\n * supports.\n */\nenum TMessageType { T_CALL = 1, T_REPLY = 2, T_EXCEPTION = 3, T_ONEWAY = 4 };\n\n/**\n * Helper template for implementing TProtocol::skip().\n *\n * Templatized to avoid having to make virtual function calls.\n */\ntemplate <class Protocol_>\nuint32_t skip(Protocol_& prot, TType arg_type) {\n  switch (arg_type) {\n    case T_BOOL: {\n      bool boolv;\n      return prot.readBool(boolv);\n    }\n    case T_BYTE: {\n      int8_t bytev = 0;\n      return prot.readByte(bytev);\n    }\n    case T_I16: {\n      int16_t i16;\n      return prot.readI16(i16);\n    }\n    case T_I32: {\n      int32_t i32;\n      return prot.readI32(i32);\n    }\n    case T_I64: {\n      int64_t i64;\n      return prot.readI64(i64);\n    }\n    case T_DOUBLE: {\n      double dub;\n      return prot.readDouble(dub);\n    }\n    case T_FLOAT: {\n      float flt;\n      return prot.readFloat(flt);\n    }\n    case T_STRING: {\n      std::string str;\n      return prot.readBinary(str);\n    }\n    case T_STRUCT: {\n      uint32_t result = 0;\n      std::string name;\n      int16_t fid;\n      TType ftype;\n      result += prot.readStructBegin(name);\n      while (true) {\n        result += prot.readFieldBegin(name, ftype, fid);\n        if (ftype == T_STOP) {\n          break;\n        }\n        result += skip(prot, ftype);\n        result += prot.readFieldEnd();\n      }\n      result += prot.readStructEnd();\n      return result;\n    }\n    case T_MAP: {\n      uint32_t result = 0;\n      TType keyType;\n      TType valType;\n      uint32_t i, size;\n      bool sizeUnknown;\n      result += prot.readMapBegin(keyType, valType, size, sizeUnknown);\n      if (!sizeUnknown) {\n        for (i = 0; i < size; i++) {\n          result += skip(prot, keyType);\n          result += skip(prot, valType);\n        }\n      } else {\n        while (prot.peekMap()) {\n          result += skip(prot, keyType);\n          result += skip(prot, valType);\n        }\n      }\n      result += prot.readMapEnd();\n      return result;\n    }\n    case T_SET: {\n      uint32_t result = 0;\n      TType elemType;\n      uint32_t i, size;\n      bool sizeUnknown;\n      result += prot.readSetBegin(elemType, size, sizeUnknown);\n      if (!sizeUnknown) {\n        for (i = 0; i < size; i++) {\n          result += skip(prot, elemType);\n        }\n      } else {\n        while (prot.peekSet()) {\n          result += skip(prot, elemType);\n        }\n      }\n      result += prot.readSetEnd();\n      return result;\n    }\n    case T_LIST: {\n      uint32_t result = 0;\n      TType elemType;\n      uint32_t i, size;\n      bool sizeUnknown;\n      result += prot.readListBegin(elemType, size, sizeUnknown);\n      if (!sizeUnknown) {\n        for (i = 0; i < size; i++) {\n          result += skip(prot, elemType);\n        }\n      } else {\n        while (prot.peekList()) {\n          result += skip(prot, elemType);\n        }\n      }\n      result += prot.readListEnd();\n      return result;\n    }\n    default: {\n      TProtocolException::throwInvalidSkipType(arg_type);\n    }\n  }\n}\n\n// TODO(denplusplus): remove.\n// DO NOT USE.\ntemplate <typename Protocol_, typename T>\nuint32_t readIntegral(Protocol_& prot, TType arg_type, T& value) {\n  switch (arg_type) {\n    case TType::T_BOOL: {\n      bool boolv;\n      auto res = prot.readBool(boolv);\n      value = static_cast<T>(boolv);\n      return res;\n    }\n    case TType::T_BYTE: {\n      int8_t bytev;\n      auto res = prot.readByte(bytev);\n      value = static_cast<T>(bytev);\n      return res;\n    }\n    case TType::T_I16: {\n      int16_t i16;\n      auto res = prot.readI16(i16);\n      value = static_cast<T>(i16);\n      return res;\n    }\n    case TType::T_I32: {\n      int32_t i32;\n      auto res = prot.readI32(i32);\n      value = static_cast<T>(i32);\n      return res;\n    }\n    case TType::T_I64: {\n      int64_t i64;\n      auto res = prot.readI64(i64);\n      value = static_cast<T>(i64);\n      return res;\n    }\n    default: {\n      throw TProtocolException(\n          std::string(\"Cannot parse integral number of \") +\n          std::to_string(arg_type) + \" type\");\n    }\n  }\n}\n\n// TODO(denplusplus): remove.\n// DO NOT USE.\ntemplate <typename Protocol_, typename T>\nuint32_t readFloatingPoint(Protocol_& prot, TType arg_type, T& value) {\n  switch (arg_type) {\n    case TType::T_DOUBLE: {\n      double dub;\n      auto res = prot.readDouble(dub);\n      value = static_cast<T>(dub);\n      return res;\n    }\n    case TType::T_FLOAT: {\n      float flt;\n      auto res = prot.readFloat(flt);\n      value = static_cast<T>(flt);\n      return res;\n    }\n    default: {\n      throw TProtocolException(\n          std::string(\"Cannot parse floating number of \") +\n          std::to_string(arg_type) + \" type\");\n    }\n  }\n}\n\n/**\n * Abstract class for a thrift protocol driver. These are all the methods that\n * a protocol must implement. Essentially, there must be some way of reading\n * and writing all the base types, plus a mechanism for writing out structs\n * with indexed fields.\n *\n * TProtocol objects should not be shared across multiple encoding contexts,\n * as they may need to maintain internal state in some protocols (i.e. XML).\n * Note that it is acceptable for the TProtocol module to do its own internal\n * buffered reads/writes to the underlying TTransport where appropriate (i.e.\n * when parsing an input XML stream, reading should be batched rather than\n * looking ahead character by character for a close tag).\n *\n */\nclass TProtocol {\n public:\n  virtual ~TProtocol() {}\n\n  virtual void setVersion_virt(const int8_t version) = 0;\n\n  void setVersion(const int8_t version) {\n    T_VIRTUAL_CALL();\n    return setVersion_virt(version);\n  }\n\n  virtual ::apache::thrift::reflection::Schema* getSchema_virt() = 0;\n\n  ::apache::thrift::reflection::Schema* getSchema() {\n    T_VIRTUAL_CALL();\n    return getSchema_virt();\n  }\n\n  /**\n   * Writing functions.\n   */\n\n  virtual uint32_t writeMessageBegin_virt(\n      const std::string& name,\n      const TMessageType messageType,\n      const int32_t seqid) = 0;\n\n  virtual uint32_t writeMessageEnd_virt() = 0;\n\n  virtual uint32_t writeStructBegin_virt(const char* name) = 0;\n\n  virtual uint32_t writeStructEnd_virt() = 0;\n\n  virtual uint32_t writeFieldBegin_virt(\n      const char* name,\n      const TType fieldType,\n      const int16_t fieldId) = 0;\n\n  virtual uint32_t writeFieldEnd_virt() = 0;\n\n  virtual uint32_t writeFieldStop_virt() = 0;\n\n  virtual uint32_t writeMapBegin_virt(\n      const TType keyType,\n      const TType valType,\n      const uint32_t size) = 0;\n\n  virtual uint32_t writeMapEnd_virt() = 0;\n\n  virtual uint32_t writeListBegin_virt(\n      const TType elemType,\n      const uint32_t size) = 0;\n\n  virtual uint32_t writeListEnd_virt() = 0;\n\n  virtual uint32_t writeSetBegin_virt(\n      const TType elemType,\n      const uint32_t size) = 0;\n\n  virtual uint32_t writeSetEnd_virt() = 0;\n\n  virtual uint32_t writeBool_virt(const bool value) = 0;\n\n  virtual uint32_t writeByte_virt(const int8_t byte) = 0;\n\n  virtual uint32_t writeI16_virt(const int16_t i16) = 0;\n\n  virtual uint32_t writeI32_virt(const int32_t i32) = 0;\n\n  virtual uint32_t writeI64_virt(const int64_t i64) = 0;\n\n  virtual uint32_t writeDouble_virt(const double dub) = 0;\n\n  virtual uint32_t writeFloat_virt(const float flt) = 0;\n\n  virtual uint32_t writeString_virt(const std::string& str) = 0;\n\n  virtual uint32_t writeBinary_virt(const std::string& str) = 0;\n\n  uint32_t writeMessageBegin(\n      const std::string& name,\n      const TMessageType messageType,\n      const int32_t seqid) {\n    T_VIRTUAL_CALL();\n    return writeMessageBegin_virt(name, messageType, seqid);\n  }\n\n  uint32_t writeMessageEnd() {\n    T_VIRTUAL_CALL();\n    return writeMessageEnd_virt();\n  }\n\n  uint32_t writeStructBegin(const char* name) {\n    T_VIRTUAL_CALL();\n    return writeStructBegin_virt(name);\n  }\n\n  uint32_t writeStructEnd() {\n    T_VIRTUAL_CALL();\n    return writeStructEnd_virt();\n  }\n\n  uint32_t writeFieldBegin(\n      const char* name,\n      const TType fieldType,\n      const int16_t fieldId) {\n    T_VIRTUAL_CALL();\n    return writeFieldBegin_virt(name, fieldType, fieldId);\n  }\n\n  uint32_t writeFieldEnd() {\n    T_VIRTUAL_CALL();\n    return writeFieldEnd_virt();\n  }\n\n  uint32_t writeFieldStop() {\n    T_VIRTUAL_CALL();\n    return writeFieldStop_virt();\n  }\n\n  uint32_t\n  writeMapBegin(const TType keyType, const TType valType, const uint32_t size) {\n    T_VIRTUAL_CALL();\n    return writeMapBegin_virt(keyType, valType, size);\n  }\n\n  uint32_t writeMapEnd() {\n    T_VIRTUAL_CALL();\n    return writeMapEnd_virt();\n  }\n\n  uint32_t writeListBegin(const TType elemType, const uint32_t size) {\n    T_VIRTUAL_CALL();\n    return writeListBegin_virt(elemType, size);\n  }\n\n  uint32_t writeListEnd() {\n    T_VIRTUAL_CALL();\n    return writeListEnd_virt();\n  }\n\n  uint32_t writeSetBegin(const TType elemType, const uint32_t size) {\n    T_VIRTUAL_CALL();\n    return writeSetBegin_virt(elemType, size);\n  }\n\n  uint32_t writeSetEnd() {\n    T_VIRTUAL_CALL();\n    return writeSetEnd_virt();\n  }\n\n  uint32_t writeBool(const bool value) {\n    T_VIRTUAL_CALL();\n    return writeBool_virt(value);\n  }\n\n  uint32_t writeByte(const int8_t byte) {\n    T_VIRTUAL_CALL();\n    return writeByte_virt(byte);\n  }\n\n  uint32_t writeI16(const int16_t i16) {\n    T_VIRTUAL_CALL();\n    return writeI16_virt(i16);\n  }\n\n  uint32_t writeI32(const int32_t i32) {\n    T_VIRTUAL_CALL();\n    return writeI32_virt(i32);\n  }\n\n  uint32_t writeI64(const int64_t i64) {\n    T_VIRTUAL_CALL();\n    return writeI64_virt(i64);\n  }\n\n  uint32_t writeDouble(const double dub) {\n    T_VIRTUAL_CALL();\n    return writeDouble_virt(dub);\n  }\n\n  uint32_t writeFloat(const float flt) {\n    T_VIRTUAL_CALL();\n    return writeFloat_virt(flt);\n  }\n\n  uint32_t writeString(const std::string& str) {\n    T_VIRTUAL_CALL();\n    return writeString_virt(str);\n  }\n\n  uint32_t writeString(const folly::fbstring& str) {\n    T_VIRTUAL_CALL();\n    return writeString_virt(str.toStdString());\n  }\n\n  uint32_t writeBinary(const std::string& str) {\n    T_VIRTUAL_CALL();\n    return writeBinary_virt(str);\n  }\n\n  uint32_t writeBinary(const folly::fbstring& str) {\n    T_VIRTUAL_CALL();\n    return writeBinary_virt(str.toStdString());\n  }\n\n  /**\n   * Reading functions\n   */\n\n  virtual uint32_t readMessageBegin_virt(\n      std::string& name,\n      TMessageType& messageType,\n      int32_t& seqid) = 0;\n\n  virtual uint32_t readMessageEnd_virt() = 0;\n\n  virtual void setNextStructType_virt(uint64_t reflection_id) = 0;\n\n  virtual uint32_t readStructBegin_virt(std::string& name) = 0;\n\n  virtual uint32_t readStructEnd_virt() = 0;\n\n  virtual uint32_t readFieldBegin_virt(\n      std::string& name,\n      TType& fieldType,\n      int16_t& fieldId) = 0;\n\n  virtual uint32_t readFieldEnd_virt() = 0;\n\n  virtual uint32_t readMapBegin_virt(\n      TType& keyType,\n      TType& valType,\n      uint32_t& size,\n      bool& sizeUnknown) = 0;\n\n  virtual bool peekMap_virt() = 0;\n\n  virtual uint32_t readMapEnd_virt() = 0;\n\n  virtual uint32_t\n  readListBegin_virt(TType& elemType, uint32_t& size, bool& sizeUnknown) = 0;\n\n  virtual bool peekList_virt() = 0;\n\n  virtual uint32_t readListEnd_virt() = 0;\n\n  virtual uint32_t\n  readSetBegin_virt(TType& elemType, uint32_t& size, bool& sizeUnknown) = 0;\n\n  virtual bool peekSet_virt() = 0;\n\n  virtual uint32_t readSetEnd_virt() = 0;\n\n  virtual uint32_t readBool_virt(bool& value) = 0;\n\n  virtual uint32_t readBool_virt(std::vector<bool>::reference value) = 0;\n\n  virtual uint32_t readByte_virt(int8_t& byte) = 0;\n\n  virtual uint32_t readI16_virt(int16_t& i16) = 0;\n\n  virtual uint32_t readI32_virt(int32_t& i32) = 0;\n\n  virtual uint32_t readI64_virt(int64_t& i64) = 0;\n\n  virtual uint32_t readDouble_virt(double& dub) = 0;\n\n  virtual uint32_t readFloat_virt(float& flt) = 0;\n\n  virtual uint32_t readString_virt(std::string& str) = 0;\n\n  virtual uint32_t readBinary_virt(std::string& str) = 0;\n\n  uint32_t readMessageBegin(\n      std::string& name,\n      TMessageType& messageType,\n      int32_t& seqid) {\n    T_VIRTUAL_CALL();\n    return readMessageBegin_virt(name, messageType, seqid);\n  }\n\n  uint32_t readMessageEnd() {\n    T_VIRTUAL_CALL();\n    return readMessageEnd_virt();\n  }\n\n  void setNextStructType(uint64_t reflection_id) {\n    T_VIRTUAL_CALL();\n    return setNextStructType_virt(reflection_id);\n  }\n\n  uint32_t readStructBegin(std::string& name) {\n    T_VIRTUAL_CALL();\n    return readStructBegin_virt(name);\n  }\n\n  uint32_t readStructEnd() {\n    T_VIRTUAL_CALL();\n    return readStructEnd_virt();\n  }\n\n  uint32_t\n  readFieldBegin(std::string& name, TType& fieldType, int16_t& fieldId) {\n    T_VIRTUAL_CALL();\n    return readFieldBegin_virt(name, fieldType, fieldId);\n  }\n\n  uint32_t readFieldEnd() {\n    T_VIRTUAL_CALL();\n    return readFieldEnd_virt();\n  }\n\n  uint32_t readMapBegin(\n      TType& keyType,\n      TType& valType,\n      uint32_t& size,\n      bool& sizeUnknown) {\n    T_VIRTUAL_CALL();\n    return readMapBegin_virt(keyType, valType, size, sizeUnknown);\n  }\n\n  bool peekMap() {\n    T_VIRTUAL_CALL();\n    return peekMap_virt();\n  }\n\n  uint32_t readMapEnd() {\n    T_VIRTUAL_CALL();\n    return readMapEnd_virt();\n  }\n\n  uint32_t readListBegin(TType& elemType, uint32_t& size, bool& sizeUnknown) {\n    T_VIRTUAL_CALL();\n    return readListBegin_virt(elemType, size, sizeUnknown);\n  }\n\n  bool peekList() {\n    T_VIRTUAL_CALL();\n    return peekList_virt();\n  }\n\n  uint32_t readListEnd() {\n    T_VIRTUAL_CALL();\n    return readListEnd_virt();\n  }\n\n  uint32_t readSetBegin(TType& elemType, uint32_t& size, bool& sizeUnknown) {\n    T_VIRTUAL_CALL();\n    return readSetBegin_virt(elemType, size, sizeUnknown);\n  }\n\n  bool peekSet() {\n    T_VIRTUAL_CALL();\n    return peekSet_virt();\n  }\n\n  uint32_t readSetEnd() {\n    T_VIRTUAL_CALL();\n    return readSetEnd_virt();\n  }\n\n  uint32_t readBool(bool& value) {\n    T_VIRTUAL_CALL();\n    return readBool_virt(value);\n  }\n\n  uint32_t readByte(int8_t& byte) {\n    T_VIRTUAL_CALL();\n    return readByte_virt(byte);\n  }\n\n  uint32_t readI16(int16_t& i16) {\n    T_VIRTUAL_CALL();\n    return readI16_virt(i16);\n  }\n\n  uint32_t readI32(int32_t& i32) {\n    T_VIRTUAL_CALL();\n    return readI32_virt(i32);\n  }\n\n  uint32_t readI64(int64_t& i64) {\n    T_VIRTUAL_CALL();\n    return readI64_virt(i64);\n  }\n\n  uint32_t readDouble(double& dub) {\n    T_VIRTUAL_CALL();\n    return readDouble_virt(dub);\n  }\n\n  uint32_t readFloat(float& flt) {\n    T_VIRTUAL_CALL();\n    return readFloat_virt(flt);\n  }\n\n  uint32_t readString(std::string& str) {\n    T_VIRTUAL_CALL();\n    return readString_virt(str);\n  }\n\n  uint32_t readString(folly::fbstring& str) {\n    T_VIRTUAL_CALL();\n    std::string data;\n    uint32_t ret = readString_virt(data);\n    str = data;\n    return ret;\n  }\n\n  uint32_t readBinary(std::string& str) {\n    T_VIRTUAL_CALL();\n    return readBinary_virt(str);\n  }\n\n  uint32_t readBinary(folly::fbstring& str) {\n    T_VIRTUAL_CALL();\n    std::string data;\n    uint32_t ret = readBinary_virt(data);\n    str = data;\n    return ret;\n  }\n\n  int32_t getStringSizeLimit() {\n    return 0; // No limit\n  }\n\n  int32_t getContainerSizeLimit() {\n    return 0; // No limit\n  }\n\n  /*\n   * std::vector is specialized for bool, and its elements are individual bits\n   * rather than bools.   We need to define a different version of readBool()\n   * to work with std::vector<bool>.\n   */\n  uint32_t readBool(std::vector<bool>::reference value) {\n    T_VIRTUAL_CALL();\n    return readBool_virt(value);\n  }\n\n  /**\n   * Method to arbitrarily skip over data.\n   */\n  uint32_t skip(TType type) {\n    T_VIRTUAL_CALL();\n    return skip_virt(type);\n  }\n  virtual uint32_t skip_virt(TType type) {\n    return ::apache::thrift::protocol::skip(*this, type);\n  }\n\n  inline std::shared_ptr<TTransport> getTransport() {\n    return ptrans_;\n  }\n\n  // TODO: remove these two calls, they are for backwards\n  // compatibility\n  inline std::shared_ptr<TTransport> getInputTransport() {\n    return ptrans_;\n  }\n  inline std::shared_ptr<TTransport> getOutputTransport() {\n    return ptrans_;\n  }\n\n protected:\n  explicit TProtocol(std::shared_ptr<TTransport> ptrans) : ptrans_(ptrans) {}\n\n  /**\n   * Construct a TProtocol using a raw TTransport pointer.\n   *\n   * It is the callers responsibility to ensure that the TTransport remains\n   * valid for the lifetime of the TProtocol object.\n   */\n  explicit TProtocol(TTransport* ptrans)\n      : ptrans_(ptrans, [](TTransport*) {}) {}\n\n  std::shared_ptr<TTransport> ptrans_;\n\n private:\n  TProtocol() {}\n};\n\n/**\n * Constructs protocol objects given transports.\n */\nclass TProtocolFactory {\n public:\n  TProtocolFactory() {}\n\n  virtual ~TProtocolFactory() {}\n\n  virtual std::shared_ptr<TProtocol> getProtocol(\n      std::shared_ptr<TTransport> trans) = 0;\n};\n\n/**\n * Constructs both input and output protocol objects with a given pair of\n * input and output transports.\n *\n * TProtocolPair.first = Input Protocol\n * TProtocolPair.second = Output Protocol\n */\ntypedef std::pair<std::shared_ptr<TProtocol>, std::shared_ptr<TProtocol>>\n    TProtocolPair;\n\nclass TDuplexProtocolFactory {\n public:\n  TDuplexProtocolFactory() {}\n\n  virtual ~TDuplexProtocolFactory() {}\n\n  virtual TProtocolPair getProtocol(transport::TTransportPair transports) = 0;\n\n  virtual std::shared_ptr<TProtocolFactory> getInputProtocolFactory() {\n    return std::shared_ptr<TProtocolFactory>();\n  }\n\n  virtual std::shared_ptr<TProtocolFactory> getOutputProtocolFactory() {\n    return std::shared_ptr<TProtocolFactory>();\n  }\n};\n\n/**\n * Adapts a TProtocolFactory to a TDuplexProtocolFactory that returns\n * a new protocol object for both input and output\n */\ntemplate <class Factory_>\nclass TSingleProtocolFactory : public TDuplexProtocolFactory {\n public:\n  TSingleProtocolFactory() {\n    factory_.reset(new Factory_());\n  }\n\n  explicit TSingleProtocolFactory(std::shared_ptr<Factory_> factory)\n      : factory_(factory) {}\n\n  TProtocolPair getProtocol(transport::TTransportPair transports) override {\n    return std::make_pair(\n        factory_->getProtocol(transports.first),\n        factory_->getProtocol(transports.second));\n  }\n\n  std::shared_ptr<TProtocolFactory> getInputProtocolFactory() override {\n    return factory_;\n  }\n\n  std::shared_ptr<TProtocolFactory> getOutputProtocolFactory() override {\n    return factory_;\n  }\n\n private:\n  std::shared_ptr<Factory_> factory_;\n};\n\n/**\n * Use TDualProtocolFactory to construct input and output protocols from\n * different factories.\n */\nclass TDualProtocolFactory : public TDuplexProtocolFactory {\n public:\n  TDualProtocolFactory(\n      std::shared_ptr<TProtocolFactory> inputFactory,\n      std::shared_ptr<TProtocolFactory> outputFactory)\n      : inputFactory_(inputFactory), outputFactory_(outputFactory) {}\n\n  TProtocolPair getProtocol(transport::TTransportPair transports) override {\n    return std::make_pair(\n        inputFactory_->getProtocol(transports.first),\n        outputFactory_->getProtocol(transports.second));\n  }\n\n  std::shared_ptr<TProtocolFactory> getInputProtocolFactory() override {\n    return inputFactory_;\n  }\n\n  std::shared_ptr<TProtocolFactory> getOutputProtocolFactory() override {\n    return outputFactory_;\n  }\n\n private:\n  std::shared_ptr<TProtocolFactory> inputFactory_;\n  std::shared_ptr<TProtocolFactory> outputFactory_;\n};\n\n/**\n * Dummy protocol class.\n *\n * This class does nothing, and should never be instantiated.\n * It is used only by the generator code.\n */\nclass TDummyProtocol : public TProtocol {};\n\n} // namespace protocol\n} // namespace thrift\n} // namespace apache\n\n#endif // #define _THRIFT_PROTOCOL_TPROTOCOL_H_ 1\n"], "filenames": ["thrift/lib/cpp/protocol/TProtocol.h"], "buggy_code_start_loc": [168], "buggy_code_end_loc": [170], "fixing_code_start_loc": [168], "fixing_code_end_loc": [171], "type": "CWE-755", "message": "Legacy C++ Facebook Thrift servers (using cpp instead of cpp2) would not error upon receiving messages with containers of fields of unknown type. As a result, malicious clients could send short messages which would take a long time for the server to parse, potentially leading to denial of service. This issue affects Facebook Thrift prior to v2019.05.06.00.", "other": {"cve": {"id": "CVE-2019-3565", "sourceIdentifier": "cve-assign@fb.com", "published": "2019-05-06T16:29:01.317", "lastModified": "2021-11-02T20:20:03.383", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Legacy C++ Facebook Thrift servers (using cpp instead of cpp2) would not error upon receiving messages with containers of fields of unknown type. As a result, malicious clients could send short messages which would take a long time for the server to parse, potentially leading to denial of service. This issue affects Facebook Thrift prior to v2019.05.06.00."}, {"lang": "es", "value": "Servidores legacy C++ Facebook Thrift (usando cpp en lugar de cpp2) no comet\u00edan errores al recibir mensajes con contenedores de tipo de campo desconocidos. Como resultado, los clientes maliciosos pod\u00edan enviar mensajes cortos los cuales tomar\u00edan un largo periodo de an\u00e1lisis al servidor,esto podr\u00eda llevar a una denegaci\u00f3n de servicio. Este fallo afecta a Facebook Thrift versiones anteriores a v2019.05.06.00."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-755"}]}, {"source": "cve-assign@fb.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-834"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:facebook:thrift:*:*:*:*:*:*:*:*", "versionEndExcluding": "2019.05.06.00", "matchCriteriaId": "51E7D952-EF4F-401A-9A63-C666A7A520DB"}]}]}], "references": [{"url": "http://www.securityfocus.com/bid/108280", "source": "cve-assign@fb.com", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/facebook/fbthrift/commit/01686e15ec77ccb4d49a77d5bce3a01601e54d64", "source": "cve-assign@fb.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/rd0e44e8ef71eeaaa3cf3d1b8b41eb25894372e2995ec908ce7624d26@%3Ccommits.pulsar.apache.org%3E", "source": "cve-assign@fb.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://www.facebook.com/security/advisories/cve-2019-3565", "source": "cve-assign@fb.com", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/facebook/fbthrift/commit/01686e15ec77ccb4d49a77d5bce3a01601e54d64"}}