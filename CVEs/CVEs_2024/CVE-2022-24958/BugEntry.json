{"buggy_code": ["// SPDX-License-Identifier: GPL-2.0+\n/*\n * inode.c -- user mode filesystem api for usb gadget controllers\n *\n * Copyright (C) 2003-2004 David Brownell\n * Copyright (C) 2003 Agilent Technologies\n */\n\n\n/* #define VERBOSE_DEBUG */\n\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/fs_context.h>\n#include <linux/pagemap.h>\n#include <linux/uts.h>\n#include <linux/wait.h>\n#include <linux/compiler.h>\n#include <linux/uaccess.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/kthread.h>\n#include <linux/aio.h>\n#include <linux/uio.h>\n#include <linux/refcount.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n\n#include <linux/usb/gadgetfs.h>\n#include <linux/usb/gadget.h>\n\n\n/*\n * The gadgetfs API maps each endpoint to a file descriptor so that you\n * can use standard synchronous read/write calls for I/O.  There's some\n * O_NONBLOCK and O_ASYNC/FASYNC style i/o support.  Example usermode\n * drivers show how this works in practice.  You can also use AIO to\n * eliminate I/O gaps between requests, to help when streaming data.\n *\n * Key parts that must be USB-specific are protocols defining how the\n * read/write operations relate to the hardware state machines.  There\n * are two types of files.  One type is for the device, implementing ep0.\n * The other type is for each IN or OUT endpoint.  In both cases, the\n * user mode driver must configure the hardware before using it.\n *\n * - First, dev_config() is called when /dev/gadget/$CHIP is configured\n *   (by writing configuration and device descriptors).  Afterwards it\n *   may serve as a source of device events, used to handle all control\n *   requests other than basic enumeration.\n *\n * - Then, after a SET_CONFIGURATION control request, ep_config() is\n *   called when each /dev/gadget/ep* file is configured (by writing\n *   endpoint descriptors).  Afterwards these files are used to write()\n *   IN data or to read() OUT data.  To halt the endpoint, a \"wrong\n *   direction\" request is issued (like reading an IN endpoint).\n *\n * Unlike \"usbfs\" the only ioctl()s are for things that are rare, and maybe\n * not possible on all hardware.  For example, precise fault handling with\n * respect to data left in endpoint fifos after aborted operations; or\n * selective clearing of endpoint halts, to implement SET_INTERFACE.\n */\n\n#define\tDRIVER_DESC\t\"USB Gadget filesystem\"\n#define\tDRIVER_VERSION\t\"24 Aug 2004\"\n\nstatic const char driver_desc [] = DRIVER_DESC;\nstatic const char shortname [] = \"gadgetfs\";\n\nMODULE_DESCRIPTION (DRIVER_DESC);\nMODULE_AUTHOR (\"David Brownell\");\nMODULE_LICENSE (\"GPL\");\n\nstatic int ep_open(struct inode *, struct file *);\n\n\n/*----------------------------------------------------------------------*/\n\n#define GADGETFS_MAGIC\t\t0xaee71ee7\n\n/* /dev/gadget/$CHIP represents ep0 and the whole device */\nenum ep0_state {\n\t/* DISABLED is the initial state. */\n\tSTATE_DEV_DISABLED = 0,\n\n\t/* Only one open() of /dev/gadget/$CHIP; only one file tracks\n\t * ep0/device i/o modes and binding to the controller.  Driver\n\t * must always write descriptors to initialize the device, then\n\t * the device becomes UNCONNECTED until enumeration.\n\t */\n\tSTATE_DEV_OPENED,\n\n\t/* From then on, ep0 fd is in either of two basic modes:\n\t * - (UN)CONNECTED: read usb_gadgetfs_event(s) from it\n\t * - SETUP: read/write will transfer control data and succeed;\n\t *   or if \"wrong direction\", performs protocol stall\n\t */\n\tSTATE_DEV_UNCONNECTED,\n\tSTATE_DEV_CONNECTED,\n\tSTATE_DEV_SETUP,\n\n\t/* UNBOUND means the driver closed ep0, so the device won't be\n\t * accessible again (DEV_DISABLED) until all fds are closed.\n\t */\n\tSTATE_DEV_UNBOUND,\n};\n\n/* enough for the whole queue: most events invalidate others */\n#define\tN_EVENT\t\t\t5\n\n#define RBUF_SIZE\t\t256\n\nstruct dev_data {\n\tspinlock_t\t\t\tlock;\n\trefcount_t\t\t\tcount;\n\tint\t\t\t\tudc_usage;\n\tenum ep0_state\t\t\tstate;\t\t/* P: lock */\n\tstruct usb_gadgetfs_event\tevent [N_EVENT];\n\tunsigned\t\t\tev_next;\n\tstruct fasync_struct\t\t*fasync;\n\tu8\t\t\t\tcurrent_config;\n\n\t/* drivers reading ep0 MUST handle control requests (SETUP)\n\t * reported that way; else the host will time out.\n\t */\n\tunsigned\t\t\tusermode_setup : 1,\n\t\t\t\t\tsetup_in : 1,\n\t\t\t\t\tsetup_can_stall : 1,\n\t\t\t\t\tsetup_out_ready : 1,\n\t\t\t\t\tsetup_out_error : 1,\n\t\t\t\t\tsetup_abort : 1,\n\t\t\t\t\tgadget_registered : 1;\n\tunsigned\t\t\tsetup_wLength;\n\n\t/* the rest is basically write-once */\n\tstruct usb_config_descriptor\t*config, *hs_config;\n\tstruct usb_device_descriptor\t*dev;\n\tstruct usb_request\t\t*req;\n\tstruct usb_gadget\t\t*gadget;\n\tstruct list_head\t\tepfiles;\n\tvoid\t\t\t\t*buf;\n\twait_queue_head_t\t\twait;\n\tstruct super_block\t\t*sb;\n\tstruct dentry\t\t\t*dentry;\n\n\t/* except this scratch i/o buffer for ep0 */\n\tu8\t\t\t\trbuf[RBUF_SIZE];\n};\n\nstatic inline void get_dev (struct dev_data *data)\n{\n\trefcount_inc (&data->count);\n}\n\nstatic void put_dev (struct dev_data *data)\n{\n\tif (likely (!refcount_dec_and_test (&data->count)))\n\t\treturn;\n\t/* needs no more cleanup */\n\tBUG_ON (waitqueue_active (&data->wait));\n\tkfree (data);\n}\n\nstatic struct dev_data *dev_new (void)\n{\n\tstruct dev_data\t\t*dev;\n\n\tdev = kzalloc(sizeof(*dev), GFP_KERNEL);\n\tif (!dev)\n\t\treturn NULL;\n\tdev->state = STATE_DEV_DISABLED;\n\trefcount_set (&dev->count, 1);\n\tspin_lock_init (&dev->lock);\n\tINIT_LIST_HEAD (&dev->epfiles);\n\tinit_waitqueue_head (&dev->wait);\n\treturn dev;\n}\n\n/*----------------------------------------------------------------------*/\n\n/* other /dev/gadget/$ENDPOINT files represent endpoints */\nenum ep_state {\n\tSTATE_EP_DISABLED = 0,\n\tSTATE_EP_READY,\n\tSTATE_EP_ENABLED,\n\tSTATE_EP_UNBOUND,\n};\n\nstruct ep_data {\n\tstruct mutex\t\t\tlock;\n\tenum ep_state\t\t\tstate;\n\trefcount_t\t\t\tcount;\n\tstruct dev_data\t\t\t*dev;\n\t/* must hold dev->lock before accessing ep or req */\n\tstruct usb_ep\t\t\t*ep;\n\tstruct usb_request\t\t*req;\n\tssize_t\t\t\t\tstatus;\n\tchar\t\t\t\tname [16];\n\tstruct usb_endpoint_descriptor\tdesc, hs_desc;\n\tstruct list_head\t\tepfiles;\n\twait_queue_head_t\t\twait;\n\tstruct dentry\t\t\t*dentry;\n};\n\nstatic inline void get_ep (struct ep_data *data)\n{\n\trefcount_inc (&data->count);\n}\n\nstatic void put_ep (struct ep_data *data)\n{\n\tif (likely (!refcount_dec_and_test (&data->count)))\n\t\treturn;\n\tput_dev (data->dev);\n\t/* needs no more cleanup */\n\tBUG_ON (!list_empty (&data->epfiles));\n\tBUG_ON (waitqueue_active (&data->wait));\n\tkfree (data);\n}\n\n/*----------------------------------------------------------------------*/\n\n/* most \"how to use the hardware\" policy choices are in userspace:\n * mapping endpoint roles (which the driver needs) to the capabilities\n * which the usb controller has.  most of those capabilities are exposed\n * implicitly, starting with the driver name and then endpoint names.\n */\n\nstatic const char *CHIP;\n\n/*----------------------------------------------------------------------*/\n\n/* NOTE:  don't use dev_printk calls before binding to the gadget\n * at the end of ep0 configuration, or after unbind.\n */\n\n/* too wordy: dev_printk(level , &(d)->gadget->dev , fmt , ## args) */\n#define xprintk(d,level,fmt,args...) \\\n\tprintk(level \"%s: \" fmt , shortname , ## args)\n\n#ifdef DEBUG\n#define DBG(dev,fmt,args...) \\\n\txprintk(dev , KERN_DEBUG , fmt , ## args)\n#else\n#define DBG(dev,fmt,args...) \\\n\tdo { } while (0)\n#endif /* DEBUG */\n\n#ifdef VERBOSE_DEBUG\n#define VDEBUG\tDBG\n#else\n#define VDEBUG(dev,fmt,args...) \\\n\tdo { } while (0)\n#endif /* DEBUG */\n\n#define ERROR(dev,fmt,args...) \\\n\txprintk(dev , KERN_ERR , fmt , ## args)\n#define INFO(dev,fmt,args...) \\\n\txprintk(dev , KERN_INFO , fmt , ## args)\n\n\n/*----------------------------------------------------------------------*/\n\n/* SYNCHRONOUS ENDPOINT OPERATIONS (bulk/intr/iso)\n *\n * After opening, configure non-control endpoints.  Then use normal\n * stream read() and write() requests; and maybe ioctl() to get more\n * precise FIFO status when recovering from cancellation.\n */\n\nstatic void epio_complete (struct usb_ep *ep, struct usb_request *req)\n{\n\tstruct ep_data\t*epdata = ep->driver_data;\n\n\tif (!req->context)\n\t\treturn;\n\tif (req->status)\n\t\tepdata->status = req->status;\n\telse\n\t\tepdata->status = req->actual;\n\tcomplete ((struct completion *)req->context);\n}\n\n/* tasklock endpoint, returning when it's connected.\n * still need dev->lock to use epdata->ep.\n */\nstatic int\nget_ready_ep (unsigned f_flags, struct ep_data *epdata, bool is_write)\n{\n\tint\tval;\n\n\tif (f_flags & O_NONBLOCK) {\n\t\tif (!mutex_trylock(&epdata->lock))\n\t\t\tgoto nonblock;\n\t\tif (epdata->state != STATE_EP_ENABLED &&\n\t\t    (!is_write || epdata->state != STATE_EP_READY)) {\n\t\t\tmutex_unlock(&epdata->lock);\nnonblock:\n\t\t\tval = -EAGAIN;\n\t\t} else\n\t\t\tval = 0;\n\t\treturn val;\n\t}\n\n\tval = mutex_lock_interruptible(&epdata->lock);\n\tif (val < 0)\n\t\treturn val;\n\n\tswitch (epdata->state) {\n\tcase STATE_EP_ENABLED:\n\t\treturn 0;\n\tcase STATE_EP_READY:\t\t\t/* not configured yet */\n\t\tif (is_write)\n\t\t\treturn 0;\n\t\tfallthrough;\n\tcase STATE_EP_UNBOUND:\t\t\t/* clean disconnect */\n\t\tbreak;\n\t// case STATE_EP_DISABLED:\t\t/* \"can't happen\" */\n\tdefault:\t\t\t\t/* error! */\n\t\tpr_debug (\"%s: ep %p not available, state %d\\n\",\n\t\t\t\tshortname, epdata, epdata->state);\n\t}\n\tmutex_unlock(&epdata->lock);\n\treturn -ENODEV;\n}\n\nstatic ssize_t\nep_io (struct ep_data *epdata, void *buf, unsigned len)\n{\n\tDECLARE_COMPLETION_ONSTACK (done);\n\tint value;\n\n\tspin_lock_irq (&epdata->dev->lock);\n\tif (likely (epdata->ep != NULL)) {\n\t\tstruct usb_request\t*req = epdata->req;\n\n\t\treq->context = &done;\n\t\treq->complete = epio_complete;\n\t\treq->buf = buf;\n\t\treq->length = len;\n\t\tvalue = usb_ep_queue (epdata->ep, req, GFP_ATOMIC);\n\t} else\n\t\tvalue = -ENODEV;\n\tspin_unlock_irq (&epdata->dev->lock);\n\n\tif (likely (value == 0)) {\n\t\tvalue = wait_for_completion_interruptible(&done);\n\t\tif (value != 0) {\n\t\t\tspin_lock_irq (&epdata->dev->lock);\n\t\t\tif (likely (epdata->ep != NULL)) {\n\t\t\t\tDBG (epdata->dev, \"%s i/o interrupted\\n\",\n\t\t\t\t\t\tepdata->name);\n\t\t\t\tusb_ep_dequeue (epdata->ep, epdata->req);\n\t\t\t\tspin_unlock_irq (&epdata->dev->lock);\n\n\t\t\t\twait_for_completion(&done);\n\t\t\t\tif (epdata->status == -ECONNRESET)\n\t\t\t\t\tepdata->status = -EINTR;\n\t\t\t} else {\n\t\t\t\tspin_unlock_irq (&epdata->dev->lock);\n\n\t\t\t\tDBG (epdata->dev, \"endpoint gone\\n\");\n\t\t\t\tepdata->status = -ENODEV;\n\t\t\t}\n\t\t}\n\t\treturn epdata->status;\n\t}\n\treturn value;\n}\n\nstatic int\nep_release (struct inode *inode, struct file *fd)\n{\n\tstruct ep_data\t\t*data = fd->private_data;\n\tint value;\n\n\tvalue = mutex_lock_interruptible(&data->lock);\n\tif (value < 0)\n\t\treturn value;\n\n\t/* clean up if this can be reopened */\n\tif (data->state != STATE_EP_UNBOUND) {\n\t\tdata->state = STATE_EP_DISABLED;\n\t\tdata->desc.bDescriptorType = 0;\n\t\tdata->hs_desc.bDescriptorType = 0;\n\t\tusb_ep_disable(data->ep);\n\t}\n\tmutex_unlock(&data->lock);\n\tput_ep (data);\n\treturn 0;\n}\n\nstatic long ep_ioctl(struct file *fd, unsigned code, unsigned long value)\n{\n\tstruct ep_data\t\t*data = fd->private_data;\n\tint\t\t\tstatus;\n\n\tif ((status = get_ready_ep (fd->f_flags, data, false)) < 0)\n\t\treturn status;\n\n\tspin_lock_irq (&data->dev->lock);\n\tif (likely (data->ep != NULL)) {\n\t\tswitch (code) {\n\t\tcase GADGETFS_FIFO_STATUS:\n\t\t\tstatus = usb_ep_fifo_status (data->ep);\n\t\t\tbreak;\n\t\tcase GADGETFS_FIFO_FLUSH:\n\t\t\tusb_ep_fifo_flush (data->ep);\n\t\t\tbreak;\n\t\tcase GADGETFS_CLEAR_HALT:\n\t\t\tstatus = usb_ep_clear_halt (data->ep);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tstatus = -ENOTTY;\n\t\t}\n\t} else\n\t\tstatus = -ENODEV;\n\tspin_unlock_irq (&data->dev->lock);\n\tmutex_unlock(&data->lock);\n\treturn status;\n}\n\n/*----------------------------------------------------------------------*/\n\n/* ASYNCHRONOUS ENDPOINT I/O OPERATIONS (bulk/intr/iso) */\n\nstruct kiocb_priv {\n\tstruct usb_request\t*req;\n\tstruct ep_data\t\t*epdata;\n\tstruct kiocb\t\t*iocb;\n\tstruct mm_struct\t*mm;\n\tstruct work_struct\twork;\n\tvoid\t\t\t*buf;\n\tstruct iov_iter\t\tto;\n\tconst void\t\t*to_free;\n\tunsigned\t\tactual;\n};\n\nstatic int ep_aio_cancel(struct kiocb *iocb)\n{\n\tstruct kiocb_priv\t*priv = iocb->private;\n\tstruct ep_data\t\t*epdata;\n\tint\t\t\tvalue;\n\n\tlocal_irq_disable();\n\tepdata = priv->epdata;\n\t// spin_lock(&epdata->dev->lock);\n\tif (likely(epdata && epdata->ep && priv->req))\n\t\tvalue = usb_ep_dequeue (epdata->ep, priv->req);\n\telse\n\t\tvalue = -EINVAL;\n\t// spin_unlock(&epdata->dev->lock);\n\tlocal_irq_enable();\n\n\treturn value;\n}\n\nstatic void ep_user_copy_worker(struct work_struct *work)\n{\n\tstruct kiocb_priv *priv = container_of(work, struct kiocb_priv, work);\n\tstruct mm_struct *mm = priv->mm;\n\tstruct kiocb *iocb = priv->iocb;\n\tsize_t ret;\n\n\tkthread_use_mm(mm);\n\tret = copy_to_iter(priv->buf, priv->actual, &priv->to);\n\tkthread_unuse_mm(mm);\n\tif (!ret)\n\t\tret = -EFAULT;\n\n\t/* completing the iocb can drop the ctx and mm, don't touch mm after */\n\tiocb->ki_complete(iocb, ret);\n\n\tkfree(priv->buf);\n\tkfree(priv->to_free);\n\tkfree(priv);\n}\n\nstatic void ep_aio_complete(struct usb_ep *ep, struct usb_request *req)\n{\n\tstruct kiocb\t\t*iocb = req->context;\n\tstruct kiocb_priv\t*priv = iocb->private;\n\tstruct ep_data\t\t*epdata = priv->epdata;\n\n\t/* lock against disconnect (and ideally, cancel) */\n\tspin_lock(&epdata->dev->lock);\n\tpriv->req = NULL;\n\tpriv->epdata = NULL;\n\n\t/* if this was a write or a read returning no data then we\n\t * don't need to copy anything to userspace, so we can\n\t * complete the aio request immediately.\n\t */\n\tif (priv->to_free == NULL || unlikely(req->actual == 0)) {\n\t\tkfree(req->buf);\n\t\tkfree(priv->to_free);\n\t\tkfree(priv);\n\t\tiocb->private = NULL;\n\t\tiocb->ki_complete(iocb,\n\t\t\t\treq->actual ? req->actual : (long)req->status);\n\t} else {\n\t\t/* ep_copy_to_user() won't report both; we hide some faults */\n\t\tif (unlikely(0 != req->status))\n\t\t\tDBG(epdata->dev, \"%s fault %d len %d\\n\",\n\t\t\t\tep->name, req->status, req->actual);\n\n\t\tpriv->buf = req->buf;\n\t\tpriv->actual = req->actual;\n\t\tINIT_WORK(&priv->work, ep_user_copy_worker);\n\t\tschedule_work(&priv->work);\n\t}\n\n\tusb_ep_free_request(ep, req);\n\tspin_unlock(&epdata->dev->lock);\n\tput_ep(epdata);\n}\n\nstatic ssize_t ep_aio(struct kiocb *iocb,\n\t\t      struct kiocb_priv *priv,\n\t\t      struct ep_data *epdata,\n\t\t      char *buf,\n\t\t      size_t len)\n{\n\tstruct usb_request *req;\n\tssize_t value;\n\n\tiocb->private = priv;\n\tpriv->iocb = iocb;\n\n\tkiocb_set_cancel_fn(iocb, ep_aio_cancel);\n\tget_ep(epdata);\n\tpriv->epdata = epdata;\n\tpriv->actual = 0;\n\tpriv->mm = current->mm; /* mm teardown waits for iocbs in exit_aio() */\n\n\t/* each kiocb is coupled to one usb_request, but we can't\n\t * allocate or submit those if the host disconnected.\n\t */\n\tspin_lock_irq(&epdata->dev->lock);\n\tvalue = -ENODEV;\n\tif (unlikely(epdata->ep == NULL))\n\t\tgoto fail;\n\n\treq = usb_ep_alloc_request(epdata->ep, GFP_ATOMIC);\n\tvalue = -ENOMEM;\n\tif (unlikely(!req))\n\t\tgoto fail;\n\n\tpriv->req = req;\n\treq->buf = buf;\n\treq->length = len;\n\treq->complete = ep_aio_complete;\n\treq->context = iocb;\n\tvalue = usb_ep_queue(epdata->ep, req, GFP_ATOMIC);\n\tif (unlikely(0 != value)) {\n\t\tusb_ep_free_request(epdata->ep, req);\n\t\tgoto fail;\n\t}\n\tspin_unlock_irq(&epdata->dev->lock);\n\treturn -EIOCBQUEUED;\n\nfail:\n\tspin_unlock_irq(&epdata->dev->lock);\n\tkfree(priv->to_free);\n\tkfree(priv);\n\tput_ep(epdata);\n\treturn value;\n}\n\nstatic ssize_t\nep_read_iter(struct kiocb *iocb, struct iov_iter *to)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct ep_data *epdata = file->private_data;\n\tsize_t len = iov_iter_count(to);\n\tssize_t value;\n\tchar *buf;\n\n\tif ((value = get_ready_ep(file->f_flags, epdata, false)) < 0)\n\t\treturn value;\n\n\t/* halt any endpoint by doing a \"wrong direction\" i/o call */\n\tif (usb_endpoint_dir_in(&epdata->desc)) {\n\t\tif (usb_endpoint_xfer_isoc(&epdata->desc) ||\n\t\t    !is_sync_kiocb(iocb)) {\n\t\t\tmutex_unlock(&epdata->lock);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tDBG (epdata->dev, \"%s halt\\n\", epdata->name);\n\t\tspin_lock_irq(&epdata->dev->lock);\n\t\tif (likely(epdata->ep != NULL))\n\t\t\tusb_ep_set_halt(epdata->ep);\n\t\tspin_unlock_irq(&epdata->dev->lock);\n\t\tmutex_unlock(&epdata->lock);\n\t\treturn -EBADMSG;\n\t}\n\n\tbuf = kmalloc(len, GFP_KERNEL);\n\tif (unlikely(!buf)) {\n\t\tmutex_unlock(&epdata->lock);\n\t\treturn -ENOMEM;\n\t}\n\tif (is_sync_kiocb(iocb)) {\n\t\tvalue = ep_io(epdata, buf, len);\n\t\tif (value >= 0 && (copy_to_iter(buf, value, to) != value))\n\t\t\tvalue = -EFAULT;\n\t} else {\n\t\tstruct kiocb_priv *priv = kzalloc(sizeof *priv, GFP_KERNEL);\n\t\tvalue = -ENOMEM;\n\t\tif (!priv)\n\t\t\tgoto fail;\n\t\tpriv->to_free = dup_iter(&priv->to, to, GFP_KERNEL);\n\t\tif (!priv->to_free) {\n\t\t\tkfree(priv);\n\t\t\tgoto fail;\n\t\t}\n\t\tvalue = ep_aio(iocb, priv, epdata, buf, len);\n\t\tif (value == -EIOCBQUEUED)\n\t\t\tbuf = NULL;\n\t}\nfail:\n\tkfree(buf);\n\tmutex_unlock(&epdata->lock);\n\treturn value;\n}\n\nstatic ssize_t ep_config(struct ep_data *, const char *, size_t);\n\nstatic ssize_t\nep_write_iter(struct kiocb *iocb, struct iov_iter *from)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct ep_data *epdata = file->private_data;\n\tsize_t len = iov_iter_count(from);\n\tbool configured;\n\tssize_t value;\n\tchar *buf;\n\n\tif ((value = get_ready_ep(file->f_flags, epdata, true)) < 0)\n\t\treturn value;\n\n\tconfigured = epdata->state == STATE_EP_ENABLED;\n\n\t/* halt any endpoint by doing a \"wrong direction\" i/o call */\n\tif (configured && !usb_endpoint_dir_in(&epdata->desc)) {\n\t\tif (usb_endpoint_xfer_isoc(&epdata->desc) ||\n\t\t    !is_sync_kiocb(iocb)) {\n\t\t\tmutex_unlock(&epdata->lock);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tDBG (epdata->dev, \"%s halt\\n\", epdata->name);\n\t\tspin_lock_irq(&epdata->dev->lock);\n\t\tif (likely(epdata->ep != NULL))\n\t\t\tusb_ep_set_halt(epdata->ep);\n\t\tspin_unlock_irq(&epdata->dev->lock);\n\t\tmutex_unlock(&epdata->lock);\n\t\treturn -EBADMSG;\n\t}\n\n\tbuf = kmalloc(len, GFP_KERNEL);\n\tif (unlikely(!buf)) {\n\t\tmutex_unlock(&epdata->lock);\n\t\treturn -ENOMEM;\n\t}\n\n\tif (unlikely(!copy_from_iter_full(buf, len, from))) {\n\t\tvalue = -EFAULT;\n\t\tgoto out;\n\t}\n\n\tif (unlikely(!configured)) {\n\t\tvalue = ep_config(epdata, buf, len);\n\t} else if (is_sync_kiocb(iocb)) {\n\t\tvalue = ep_io(epdata, buf, len);\n\t} else {\n\t\tstruct kiocb_priv *priv = kzalloc(sizeof *priv, GFP_KERNEL);\n\t\tvalue = -ENOMEM;\n\t\tif (priv) {\n\t\t\tvalue = ep_aio(iocb, priv, epdata, buf, len);\n\t\t\tif (value == -EIOCBQUEUED)\n\t\t\t\tbuf = NULL;\n\t\t}\n\t}\nout:\n\tkfree(buf);\n\tmutex_unlock(&epdata->lock);\n\treturn value;\n}\n\n/*----------------------------------------------------------------------*/\n\n/* used after endpoint configuration */\nstatic const struct file_operations ep_io_operations = {\n\t.owner =\tTHIS_MODULE,\n\n\t.open =\t\tep_open,\n\t.release =\tep_release,\n\t.llseek =\tno_llseek,\n\t.unlocked_ioctl = ep_ioctl,\n\t.read_iter =\tep_read_iter,\n\t.write_iter =\tep_write_iter,\n};\n\n/* ENDPOINT INITIALIZATION\n *\n *     fd = open (\"/dev/gadget/$ENDPOINT\", O_RDWR)\n *     status = write (fd, descriptors, sizeof descriptors)\n *\n * That write establishes the endpoint configuration, configuring\n * the controller to process bulk, interrupt, or isochronous transfers\n * at the right maxpacket size, and so on.\n *\n * The descriptors are message type 1, identified by a host order u32\n * at the beginning of what's written.  Descriptor order is: full/low\n * speed descriptor, then optional high speed descriptor.\n */\nstatic ssize_t\nep_config (struct ep_data *data, const char *buf, size_t len)\n{\n\tstruct usb_ep\t\t*ep;\n\tu32\t\t\ttag;\n\tint\t\t\tvalue, length = len;\n\n\tif (data->state != STATE_EP_READY) {\n\t\tvalue = -EL2HLT;\n\t\tgoto fail;\n\t}\n\n\tvalue = len;\n\tif (len < USB_DT_ENDPOINT_SIZE + 4)\n\t\tgoto fail0;\n\n\t/* we might need to change message format someday */\n\tmemcpy(&tag, buf, 4);\n\tif (tag != 1) {\n\t\tDBG(data->dev, \"config %s, bad tag %d\\n\", data->name, tag);\n\t\tgoto fail0;\n\t}\n\tbuf += 4;\n\tlen -= 4;\n\n\t/* NOTE:  audio endpoint extensions not accepted here;\n\t * just don't include the extra bytes.\n\t */\n\n\t/* full/low speed descriptor, then high speed */\n\tmemcpy(&data->desc, buf, USB_DT_ENDPOINT_SIZE);\n\tif (data->desc.bLength != USB_DT_ENDPOINT_SIZE\n\t\t\t|| data->desc.bDescriptorType != USB_DT_ENDPOINT)\n\t\tgoto fail0;\n\tif (len != USB_DT_ENDPOINT_SIZE) {\n\t\tif (len != 2 * USB_DT_ENDPOINT_SIZE)\n\t\t\tgoto fail0;\n\t\tmemcpy(&data->hs_desc, buf + USB_DT_ENDPOINT_SIZE,\n\t\t\tUSB_DT_ENDPOINT_SIZE);\n\t\tif (data->hs_desc.bLength != USB_DT_ENDPOINT_SIZE\n\t\t\t\t|| data->hs_desc.bDescriptorType\n\t\t\t\t\t!= USB_DT_ENDPOINT) {\n\t\t\tDBG(data->dev, \"config %s, bad hs length or type\\n\",\n\t\t\t\t\tdata->name);\n\t\t\tgoto fail0;\n\t\t}\n\t}\n\n\tspin_lock_irq (&data->dev->lock);\n\tif (data->dev->state == STATE_DEV_UNBOUND) {\n\t\tvalue = -ENOENT;\n\t\tgoto gone;\n\t} else {\n\t\tep = data->ep;\n\t\tif (ep == NULL) {\n\t\t\tvalue = -ENODEV;\n\t\t\tgoto gone;\n\t\t}\n\t}\n\tswitch (data->dev->gadget->speed) {\n\tcase USB_SPEED_LOW:\n\tcase USB_SPEED_FULL:\n\t\tep->desc = &data->desc;\n\t\tbreak;\n\tcase USB_SPEED_HIGH:\n\t\t/* fails if caller didn't provide that descriptor... */\n\t\tep->desc = &data->hs_desc;\n\t\tbreak;\n\tdefault:\n\t\tDBG(data->dev, \"unconnected, %s init abandoned\\n\",\n\t\t\t\tdata->name);\n\t\tvalue = -EINVAL;\n\t\tgoto gone;\n\t}\n\tvalue = usb_ep_enable(ep);\n\tif (value == 0) {\n\t\tdata->state = STATE_EP_ENABLED;\n\t\tvalue = length;\n\t}\ngone:\n\tspin_unlock_irq (&data->dev->lock);\n\tif (value < 0) {\nfail:\n\t\tdata->desc.bDescriptorType = 0;\n\t\tdata->hs_desc.bDescriptorType = 0;\n\t}\n\treturn value;\nfail0:\n\tvalue = -EINVAL;\n\tgoto fail;\n}\n\nstatic int\nep_open (struct inode *inode, struct file *fd)\n{\n\tstruct ep_data\t\t*data = inode->i_private;\n\tint\t\t\tvalue = -EBUSY;\n\n\tif (mutex_lock_interruptible(&data->lock) != 0)\n\t\treturn -EINTR;\n\tspin_lock_irq (&data->dev->lock);\n\tif (data->dev->state == STATE_DEV_UNBOUND)\n\t\tvalue = -ENOENT;\n\telse if (data->state == STATE_EP_DISABLED) {\n\t\tvalue = 0;\n\t\tdata->state = STATE_EP_READY;\n\t\tget_ep (data);\n\t\tfd->private_data = data;\n\t\tVDEBUG (data->dev, \"%s ready\\n\", data->name);\n\t} else\n\t\tDBG (data->dev, \"%s state %d\\n\",\n\t\t\tdata->name, data->state);\n\tspin_unlock_irq (&data->dev->lock);\n\tmutex_unlock(&data->lock);\n\treturn value;\n}\n\n/*----------------------------------------------------------------------*/\n\n/* EP0 IMPLEMENTATION can be partly in userspace.\n *\n * Drivers that use this facility receive various events, including\n * control requests the kernel doesn't handle.  Drivers that don't\n * use this facility may be too simple-minded for real applications.\n */\n\nstatic inline void ep0_readable (struct dev_data *dev)\n{\n\twake_up (&dev->wait);\n\tkill_fasync (&dev->fasync, SIGIO, POLL_IN);\n}\n\nstatic void clean_req (struct usb_ep *ep, struct usb_request *req)\n{\n\tstruct dev_data\t\t*dev = ep->driver_data;\n\n\tif (req->buf != dev->rbuf) {\n\t\tkfree(req->buf);\n\t\treq->buf = dev->rbuf;\n\t}\n\treq->complete = epio_complete;\n\tdev->setup_out_ready = 0;\n}\n\nstatic void ep0_complete (struct usb_ep *ep, struct usb_request *req)\n{\n\tstruct dev_data\t\t*dev = ep->driver_data;\n\tunsigned long\t\tflags;\n\tint\t\t\tfree = 1;\n\n\t/* for control OUT, data must still get to userspace */\n\tspin_lock_irqsave(&dev->lock, flags);\n\tif (!dev->setup_in) {\n\t\tdev->setup_out_error = (req->status != 0);\n\t\tif (!dev->setup_out_error)\n\t\t\tfree = 0;\n\t\tdev->setup_out_ready = 1;\n\t\tep0_readable (dev);\n\t}\n\n\t/* clean up as appropriate */\n\tif (free && req->buf != &dev->rbuf)\n\t\tclean_req (ep, req);\n\treq->complete = epio_complete;\n\tspin_unlock_irqrestore(&dev->lock, flags);\n}\n\nstatic int setup_req (struct usb_ep *ep, struct usb_request *req, u16 len)\n{\n\tstruct dev_data\t*dev = ep->driver_data;\n\n\tif (dev->setup_out_ready) {\n\t\tDBG (dev, \"ep0 request busy!\\n\");\n\t\treturn -EBUSY;\n\t}\n\tif (len > sizeof (dev->rbuf))\n\t\treq->buf = kmalloc(len, GFP_ATOMIC);\n\tif (req->buf == NULL) {\n\t\treq->buf = dev->rbuf;\n\t\treturn -ENOMEM;\n\t}\n\treq->complete = ep0_complete;\n\treq->length = len;\n\treq->zero = 0;\n\treturn 0;\n}\n\nstatic ssize_t\nep0_read (struct file *fd, char __user *buf, size_t len, loff_t *ptr)\n{\n\tstruct dev_data\t\t\t*dev = fd->private_data;\n\tssize_t\t\t\t\tretval;\n\tenum ep0_state\t\t\tstate;\n\n\tspin_lock_irq (&dev->lock);\n\tif (dev->state <= STATE_DEV_OPENED) {\n\t\tretval = -EINVAL;\n\t\tgoto done;\n\t}\n\n\t/* report fd mode change before acting on it */\n\tif (dev->setup_abort) {\n\t\tdev->setup_abort = 0;\n\t\tretval = -EIDRM;\n\t\tgoto done;\n\t}\n\n\t/* control DATA stage */\n\tif ((state = dev->state) == STATE_DEV_SETUP) {\n\n\t\tif (dev->setup_in) {\t\t/* stall IN */\n\t\t\tVDEBUG(dev, \"ep0in stall\\n\");\n\t\t\t(void) usb_ep_set_halt (dev->gadget->ep0);\n\t\t\tretval = -EL2HLT;\n\t\t\tdev->state = STATE_DEV_CONNECTED;\n\n\t\t} else if (len == 0) {\t\t/* ack SET_CONFIGURATION etc */\n\t\t\tstruct usb_ep\t\t*ep = dev->gadget->ep0;\n\t\t\tstruct usb_request\t*req = dev->req;\n\n\t\t\tif ((retval = setup_req (ep, req, 0)) == 0) {\n\t\t\t\t++dev->udc_usage;\n\t\t\t\tspin_unlock_irq (&dev->lock);\n\t\t\t\tretval = usb_ep_queue (ep, req, GFP_KERNEL);\n\t\t\t\tspin_lock_irq (&dev->lock);\n\t\t\t\t--dev->udc_usage;\n\t\t\t}\n\t\t\tdev->state = STATE_DEV_CONNECTED;\n\n\t\t\t/* assume that was SET_CONFIGURATION */\n\t\t\tif (dev->current_config) {\n\t\t\t\tunsigned power;\n\n\t\t\t\tif (gadget_is_dualspeed(dev->gadget)\n\t\t\t\t\t\t&& (dev->gadget->speed\n\t\t\t\t\t\t\t== USB_SPEED_HIGH))\n\t\t\t\t\tpower = dev->hs_config->bMaxPower;\n\t\t\t\telse\n\t\t\t\t\tpower = dev->config->bMaxPower;\n\t\t\t\tusb_gadget_vbus_draw(dev->gadget, 2 * power);\n\t\t\t}\n\n\t\t} else {\t\t\t/* collect OUT data */\n\t\t\tif ((fd->f_flags & O_NONBLOCK) != 0\n\t\t\t\t\t&& !dev->setup_out_ready) {\n\t\t\t\tretval = -EAGAIN;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tspin_unlock_irq (&dev->lock);\n\t\t\tretval = wait_event_interruptible (dev->wait,\n\t\t\t\t\tdev->setup_out_ready != 0);\n\n\t\t\t/* FIXME state could change from under us */\n\t\t\tspin_lock_irq (&dev->lock);\n\t\t\tif (retval)\n\t\t\t\tgoto done;\n\n\t\t\tif (dev->state != STATE_DEV_SETUP) {\n\t\t\t\tretval = -ECANCELED;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tdev->state = STATE_DEV_CONNECTED;\n\n\t\t\tif (dev->setup_out_error)\n\t\t\t\tretval = -EIO;\n\t\t\telse {\n\t\t\t\tlen = min (len, (size_t)dev->req->actual);\n\t\t\t\t++dev->udc_usage;\n\t\t\t\tspin_unlock_irq(&dev->lock);\n\t\t\t\tif (copy_to_user (buf, dev->req->buf, len))\n\t\t\t\t\tretval = -EFAULT;\n\t\t\t\telse\n\t\t\t\t\tretval = len;\n\t\t\t\tspin_lock_irq(&dev->lock);\n\t\t\t\t--dev->udc_usage;\n\t\t\t\tclean_req (dev->gadget->ep0, dev->req);\n\t\t\t\t/* NOTE userspace can't yet choose to stall */\n\t\t\t}\n\t\t}\n\t\tgoto done;\n\t}\n\n\t/* else normal: return event data */\n\tif (len < sizeof dev->event [0]) {\n\t\tretval = -EINVAL;\n\t\tgoto done;\n\t}\n\tlen -= len % sizeof (struct usb_gadgetfs_event);\n\tdev->usermode_setup = 1;\n\nscan:\n\t/* return queued events right away */\n\tif (dev->ev_next != 0) {\n\t\tunsigned\t\ti, n;\n\n\t\tn = len / sizeof (struct usb_gadgetfs_event);\n\t\tif (dev->ev_next < n)\n\t\t\tn = dev->ev_next;\n\n\t\t/* ep0 i/o has special semantics during STATE_DEV_SETUP */\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tif (dev->event [i].type == GADGETFS_SETUP) {\n\t\t\t\tdev->state = STATE_DEV_SETUP;\n\t\t\t\tn = i + 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tspin_unlock_irq (&dev->lock);\n\t\tlen = n * sizeof (struct usb_gadgetfs_event);\n\t\tif (copy_to_user (buf, &dev->event, len))\n\t\t\tretval = -EFAULT;\n\t\telse\n\t\t\tretval = len;\n\t\tif (len > 0) {\n\t\t\t/* NOTE this doesn't guard against broken drivers;\n\t\t\t * concurrent ep0 readers may lose events.\n\t\t\t */\n\t\t\tspin_lock_irq (&dev->lock);\n\t\t\tif (dev->ev_next > n) {\n\t\t\t\tmemmove(&dev->event[0], &dev->event[n],\n\t\t\t\t\tsizeof (struct usb_gadgetfs_event)\n\t\t\t\t\t\t* (dev->ev_next - n));\n\t\t\t}\n\t\t\tdev->ev_next -= n;\n\t\t\tspin_unlock_irq (&dev->lock);\n\t\t}\n\t\treturn retval;\n\t}\n\tif (fd->f_flags & O_NONBLOCK) {\n\t\tretval = -EAGAIN;\n\t\tgoto done;\n\t}\n\n\tswitch (state) {\n\tdefault:\n\t\tDBG (dev, \"fail %s, state %d\\n\", __func__, state);\n\t\tretval = -ESRCH;\n\t\tbreak;\n\tcase STATE_DEV_UNCONNECTED:\n\tcase STATE_DEV_CONNECTED:\n\t\tspin_unlock_irq (&dev->lock);\n\t\tDBG (dev, \"%s wait\\n\", __func__);\n\n\t\t/* wait for events */\n\t\tretval = wait_event_interruptible (dev->wait,\n\t\t\t\tdev->ev_next != 0);\n\t\tif (retval < 0)\n\t\t\treturn retval;\n\t\tspin_lock_irq (&dev->lock);\n\t\tgoto scan;\n\t}\n\ndone:\n\tspin_unlock_irq (&dev->lock);\n\treturn retval;\n}\n\nstatic struct usb_gadgetfs_event *\nnext_event (struct dev_data *dev, enum usb_gadgetfs_event_type type)\n{\n\tstruct usb_gadgetfs_event\t*event;\n\tunsigned\t\t\ti;\n\n\tswitch (type) {\n\t/* these events purge the queue */\n\tcase GADGETFS_DISCONNECT:\n\t\tif (dev->state == STATE_DEV_SETUP)\n\t\t\tdev->setup_abort = 1;\n\t\tfallthrough;\n\tcase GADGETFS_CONNECT:\n\t\tdev->ev_next = 0;\n\t\tbreak;\n\tcase GADGETFS_SETUP:\t\t/* previous request timed out */\n\tcase GADGETFS_SUSPEND:\t\t/* same effect */\n\t\t/* these events can't be repeated */\n\t\tfor (i = 0; i != dev->ev_next; i++) {\n\t\t\tif (dev->event [i].type != type)\n\t\t\t\tcontinue;\n\t\t\tDBG(dev, \"discard old event[%d] %d\\n\", i, type);\n\t\t\tdev->ev_next--;\n\t\t\tif (i == dev->ev_next)\n\t\t\t\tbreak;\n\t\t\t/* indices start at zero, for simplicity */\n\t\t\tmemmove (&dev->event [i], &dev->event [i + 1],\n\t\t\t\tsizeof (struct usb_gadgetfs_event)\n\t\t\t\t\t* (dev->ev_next - i));\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tBUG ();\n\t}\n\tVDEBUG(dev, \"event[%d] = %d\\n\", dev->ev_next, type);\n\tevent = &dev->event [dev->ev_next++];\n\tBUG_ON (dev->ev_next > N_EVENT);\n\tmemset (event, 0, sizeof *event);\n\tevent->type = type;\n\treturn event;\n}\n\nstatic ssize_t\nep0_write (struct file *fd, const char __user *buf, size_t len, loff_t *ptr)\n{\n\tstruct dev_data\t\t*dev = fd->private_data;\n\tssize_t\t\t\tretval = -ESRCH;\n\n\t/* report fd mode change before acting on it */\n\tif (dev->setup_abort) {\n\t\tdev->setup_abort = 0;\n\t\tretval = -EIDRM;\n\n\t/* data and/or status stage for control request */\n\t} else if (dev->state == STATE_DEV_SETUP) {\n\n\t\tlen = min_t(size_t, len, dev->setup_wLength);\n\t\tif (dev->setup_in) {\n\t\t\tretval = setup_req (dev->gadget->ep0, dev->req, len);\n\t\t\tif (retval == 0) {\n\t\t\t\tdev->state = STATE_DEV_CONNECTED;\n\t\t\t\t++dev->udc_usage;\n\t\t\t\tspin_unlock_irq (&dev->lock);\n\t\t\t\tif (copy_from_user (dev->req->buf, buf, len))\n\t\t\t\t\tretval = -EFAULT;\n\t\t\t\telse {\n\t\t\t\t\tif (len < dev->setup_wLength)\n\t\t\t\t\t\tdev->req->zero = 1;\n\t\t\t\t\tretval = usb_ep_queue (\n\t\t\t\t\t\tdev->gadget->ep0, dev->req,\n\t\t\t\t\t\tGFP_KERNEL);\n\t\t\t\t}\n\t\t\t\tspin_lock_irq(&dev->lock);\n\t\t\t\t--dev->udc_usage;\n\t\t\t\tif (retval < 0) {\n\t\t\t\t\tclean_req (dev->gadget->ep0, dev->req);\n\t\t\t\t} else\n\t\t\t\t\tretval = len;\n\n\t\t\t\treturn retval;\n\t\t\t}\n\n\t\t/* can stall some OUT transfers */\n\t\t} else if (dev->setup_can_stall) {\n\t\t\tVDEBUG(dev, \"ep0out stall\\n\");\n\t\t\t(void) usb_ep_set_halt (dev->gadget->ep0);\n\t\t\tretval = -EL2HLT;\n\t\t\tdev->state = STATE_DEV_CONNECTED;\n\t\t} else {\n\t\t\tDBG(dev, \"bogus ep0out stall!\\n\");\n\t\t}\n\t} else\n\t\tDBG (dev, \"fail %s, state %d\\n\", __func__, dev->state);\n\n\treturn retval;\n}\n\nstatic int\nep0_fasync (int f, struct file *fd, int on)\n{\n\tstruct dev_data\t\t*dev = fd->private_data;\n\t// caller must F_SETOWN before signal delivery happens\n\tVDEBUG (dev, \"%s %s\\n\", __func__, on ? \"on\" : \"off\");\n\treturn fasync_helper (f, fd, on, &dev->fasync);\n}\n\nstatic struct usb_gadget_driver gadgetfs_driver;\n\nstatic int\ndev_release (struct inode *inode, struct file *fd)\n{\n\tstruct dev_data\t\t*dev = fd->private_data;\n\n\t/* closing ep0 === shutdown all */\n\n\tif (dev->gadget_registered) {\n\t\tusb_gadget_unregister_driver (&gadgetfs_driver);\n\t\tdev->gadget_registered = false;\n\t}\n\n\t/* at this point \"good\" hardware has disconnected the\n\t * device from USB; the host won't see it any more.\n\t * alternatively, all host requests will time out.\n\t */\n\n\tkfree (dev->buf);\n\tdev->buf = NULL;\n\n\t/* other endpoints were all decoupled from this device */\n\tspin_lock_irq(&dev->lock);\n\tdev->state = STATE_DEV_DISABLED;\n\tspin_unlock_irq(&dev->lock);\n\n\tput_dev (dev);\n\treturn 0;\n}\n\nstatic __poll_t\nep0_poll (struct file *fd, poll_table *wait)\n{\n\tstruct dev_data         *dev = fd->private_data;\n\t__poll_t                mask = 0;\n\n\tif (dev->state <= STATE_DEV_OPENED)\n\t\treturn DEFAULT_POLLMASK;\n\n\tpoll_wait(fd, &dev->wait, wait);\n\n\tspin_lock_irq(&dev->lock);\n\n\t/* report fd mode change before acting on it */\n\tif (dev->setup_abort) {\n\t\tdev->setup_abort = 0;\n\t\tmask = EPOLLHUP;\n\t\tgoto out;\n\t}\n\n\tif (dev->state == STATE_DEV_SETUP) {\n\t\tif (dev->setup_in || dev->setup_can_stall)\n\t\t\tmask = EPOLLOUT;\n\t} else {\n\t\tif (dev->ev_next != 0)\n\t\t\tmask = EPOLLIN;\n\t}\nout:\n\tspin_unlock_irq(&dev->lock);\n\treturn mask;\n}\n\nstatic long dev_ioctl (struct file *fd, unsigned code, unsigned long value)\n{\n\tstruct dev_data\t\t*dev = fd->private_data;\n\tstruct usb_gadget\t*gadget = dev->gadget;\n\tlong ret = -ENOTTY;\n\n\tspin_lock_irq(&dev->lock);\n\tif (dev->state == STATE_DEV_OPENED ||\n\t\t\tdev->state == STATE_DEV_UNBOUND) {\n\t\t/* Not bound to a UDC */\n\t} else if (gadget->ops->ioctl) {\n\t\t++dev->udc_usage;\n\t\tspin_unlock_irq(&dev->lock);\n\n\t\tret = gadget->ops->ioctl (gadget, code, value);\n\n\t\tspin_lock_irq(&dev->lock);\n\t\t--dev->udc_usage;\n\t}\n\tspin_unlock_irq(&dev->lock);\n\n\treturn ret;\n}\n\n/*----------------------------------------------------------------------*/\n\n/* The in-kernel gadget driver handles most ep0 issues, in particular\n * enumerating the single configuration (as provided from user space).\n *\n * Unrecognized ep0 requests may be handled in user space.\n */\n\nstatic void make_qualifier (struct dev_data *dev)\n{\n\tstruct usb_qualifier_descriptor\t\tqual;\n\tstruct usb_device_descriptor\t\t*desc;\n\n\tqual.bLength = sizeof qual;\n\tqual.bDescriptorType = USB_DT_DEVICE_QUALIFIER;\n\tqual.bcdUSB = cpu_to_le16 (0x0200);\n\n\tdesc = dev->dev;\n\tqual.bDeviceClass = desc->bDeviceClass;\n\tqual.bDeviceSubClass = desc->bDeviceSubClass;\n\tqual.bDeviceProtocol = desc->bDeviceProtocol;\n\n\t/* assumes ep0 uses the same value for both speeds ... */\n\tqual.bMaxPacketSize0 = dev->gadget->ep0->maxpacket;\n\n\tqual.bNumConfigurations = 1;\n\tqual.bRESERVED = 0;\n\n\tmemcpy (dev->rbuf, &qual, sizeof qual);\n}\n\nstatic int\nconfig_buf (struct dev_data *dev, u8 type, unsigned index)\n{\n\tint\t\tlen;\n\tint\t\ths = 0;\n\n\t/* only one configuration */\n\tif (index > 0)\n\t\treturn -EINVAL;\n\n\tif (gadget_is_dualspeed(dev->gadget)) {\n\t\ths = (dev->gadget->speed == USB_SPEED_HIGH);\n\t\tif (type == USB_DT_OTHER_SPEED_CONFIG)\n\t\t\ths = !hs;\n\t}\n\tif (hs) {\n\t\tdev->req->buf = dev->hs_config;\n\t\tlen = le16_to_cpu(dev->hs_config->wTotalLength);\n\t} else {\n\t\tdev->req->buf = dev->config;\n\t\tlen = le16_to_cpu(dev->config->wTotalLength);\n\t}\n\t((u8 *)dev->req->buf) [1] = type;\n\treturn len;\n}\n\nstatic int\ngadgetfs_setup (struct usb_gadget *gadget, const struct usb_ctrlrequest *ctrl)\n{\n\tstruct dev_data\t\t\t*dev = get_gadget_data (gadget);\n\tstruct usb_request\t\t*req = dev->req;\n\tint\t\t\t\tvalue = -EOPNOTSUPP;\n\tstruct usb_gadgetfs_event\t*event;\n\tu16\t\t\t\tw_value = le16_to_cpu(ctrl->wValue);\n\tu16\t\t\t\tw_length = le16_to_cpu(ctrl->wLength);\n\n\tif (w_length > RBUF_SIZE) {\n\t\tif (ctrl->bRequestType & USB_DIR_IN) {\n\t\t\t/* Cast away the const, we are going to overwrite on purpose. */\n\t\t\t__le16 *temp = (__le16 *)&ctrl->wLength;\n\n\t\t\t*temp = cpu_to_le16(RBUF_SIZE);\n\t\t\tw_length = RBUF_SIZE;\n\t\t} else {\n\t\t\treturn value;\n\t\t}\n\t}\n\n\tspin_lock (&dev->lock);\n\tdev->setup_abort = 0;\n\tif (dev->state == STATE_DEV_UNCONNECTED) {\n\t\tif (gadget_is_dualspeed(gadget)\n\t\t\t\t&& gadget->speed == USB_SPEED_HIGH\n\t\t\t\t&& dev->hs_config == NULL) {\n\t\t\tspin_unlock(&dev->lock);\n\t\t\tERROR (dev, \"no high speed config??\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tdev->state = STATE_DEV_CONNECTED;\n\n\t\tINFO (dev, \"connected\\n\");\n\t\tevent = next_event (dev, GADGETFS_CONNECT);\n\t\tevent->u.speed = gadget->speed;\n\t\tep0_readable (dev);\n\n\t/* host may have given up waiting for response.  we can miss control\n\t * requests handled lower down (device/endpoint status and features);\n\t * then ep0_{read,write} will report the wrong status. controller\n\t * driver will have aborted pending i/o.\n\t */\n\t} else if (dev->state == STATE_DEV_SETUP)\n\t\tdev->setup_abort = 1;\n\n\treq->buf = dev->rbuf;\n\treq->context = NULL;\n\tswitch (ctrl->bRequest) {\n\n\tcase USB_REQ_GET_DESCRIPTOR:\n\t\tif (ctrl->bRequestType != USB_DIR_IN)\n\t\t\tgoto unrecognized;\n\t\tswitch (w_value >> 8) {\n\n\t\tcase USB_DT_DEVICE:\n\t\t\tvalue = min (w_length, (u16) sizeof *dev->dev);\n\t\t\tdev->dev->bMaxPacketSize0 = dev->gadget->ep0->maxpacket;\n\t\t\treq->buf = dev->dev;\n\t\t\tbreak;\n\t\tcase USB_DT_DEVICE_QUALIFIER:\n\t\t\tif (!dev->hs_config)\n\t\t\t\tbreak;\n\t\t\tvalue = min (w_length, (u16)\n\t\t\t\tsizeof (struct usb_qualifier_descriptor));\n\t\t\tmake_qualifier (dev);\n\t\t\tbreak;\n\t\tcase USB_DT_OTHER_SPEED_CONFIG:\n\t\tcase USB_DT_CONFIG:\n\t\t\tvalue = config_buf (dev,\n\t\t\t\t\tw_value >> 8,\n\t\t\t\t\tw_value & 0xff);\n\t\t\tif (value >= 0)\n\t\t\t\tvalue = min (w_length, (u16) value);\n\t\t\tbreak;\n\t\tcase USB_DT_STRING:\n\t\t\tgoto unrecognized;\n\n\t\tdefault:\t\t// all others are errors\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\t/* currently one config, two speeds */\n\tcase USB_REQ_SET_CONFIGURATION:\n\t\tif (ctrl->bRequestType != 0)\n\t\t\tgoto unrecognized;\n\t\tif (0 == (u8) w_value) {\n\t\t\tvalue = 0;\n\t\t\tdev->current_config = 0;\n\t\t\tusb_gadget_vbus_draw(gadget, 8 /* mA */ );\n\t\t\t// user mode expected to disable endpoints\n\t\t} else {\n\t\t\tu8\tconfig, power;\n\n\t\t\tif (gadget_is_dualspeed(gadget)\n\t\t\t\t\t&& gadget->speed == USB_SPEED_HIGH) {\n\t\t\t\tconfig = dev->hs_config->bConfigurationValue;\n\t\t\t\tpower = dev->hs_config->bMaxPower;\n\t\t\t} else {\n\t\t\t\tconfig = dev->config->bConfigurationValue;\n\t\t\t\tpower = dev->config->bMaxPower;\n\t\t\t}\n\n\t\t\tif (config == (u8) w_value) {\n\t\t\t\tvalue = 0;\n\t\t\t\tdev->current_config = config;\n\t\t\t\tusb_gadget_vbus_draw(gadget, 2 * power);\n\t\t\t}\n\t\t}\n\n\t\t/* report SET_CONFIGURATION like any other control request,\n\t\t * except that usermode may not stall this.  the next\n\t\t * request mustn't be allowed start until this finishes:\n\t\t * endpoints and threads set up, etc.\n\t\t *\n\t\t * NOTE:  older PXA hardware (before PXA 255: without UDCCFR)\n\t\t * has bad/racey automagic that prevents synchronizing here.\n\t\t * even kernel mode drivers often miss them.\n\t\t */\n\t\tif (value == 0) {\n\t\t\tINFO (dev, \"configuration #%d\\n\", dev->current_config);\n\t\t\tusb_gadget_set_state(gadget, USB_STATE_CONFIGURED);\n\t\t\tif (dev->usermode_setup) {\n\t\t\t\tdev->setup_can_stall = 0;\n\t\t\t\tgoto delegate;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n#ifndef\tCONFIG_USB_PXA25X\n\t/* PXA automagically handles this request too */\n\tcase USB_REQ_GET_CONFIGURATION:\n\t\tif (ctrl->bRequestType != 0x80)\n\t\t\tgoto unrecognized;\n\t\t*(u8 *)req->buf = dev->current_config;\n\t\tvalue = min (w_length, (u16) 1);\n\t\tbreak;\n#endif\n\n\tdefault:\nunrecognized:\n\t\tVDEBUG (dev, \"%s req%02x.%02x v%04x i%04x l%d\\n\",\n\t\t\tdev->usermode_setup ? \"delegate\" : \"fail\",\n\t\t\tctrl->bRequestType, ctrl->bRequest,\n\t\t\tw_value, le16_to_cpu(ctrl->wIndex), w_length);\n\n\t\t/* if there's an ep0 reader, don't stall */\n\t\tif (dev->usermode_setup) {\n\t\t\tdev->setup_can_stall = 1;\ndelegate:\n\t\t\tdev->setup_in = (ctrl->bRequestType & USB_DIR_IN)\n\t\t\t\t\t\t? 1 : 0;\n\t\t\tdev->setup_wLength = w_length;\n\t\t\tdev->setup_out_ready = 0;\n\t\t\tdev->setup_out_error = 0;\n\n\t\t\t/* read DATA stage for OUT right away */\n\t\t\tif (unlikely (!dev->setup_in && w_length)) {\n\t\t\t\tvalue = setup_req (gadget->ep0, dev->req,\n\t\t\t\t\t\t\tw_length);\n\t\t\t\tif (value < 0)\n\t\t\t\t\tbreak;\n\n\t\t\t\t++dev->udc_usage;\n\t\t\t\tspin_unlock (&dev->lock);\n\t\t\t\tvalue = usb_ep_queue (gadget->ep0, dev->req,\n\t\t\t\t\t\t\tGFP_KERNEL);\n\t\t\t\tspin_lock (&dev->lock);\n\t\t\t\t--dev->udc_usage;\n\t\t\t\tif (value < 0) {\n\t\t\t\t\tclean_req (gadget->ep0, dev->req);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t/* we can't currently stall these */\n\t\t\t\tdev->setup_can_stall = 0;\n\t\t\t}\n\n\t\t\t/* state changes when reader collects event */\n\t\t\tevent = next_event (dev, GADGETFS_SETUP);\n\t\t\tevent->u.setup = *ctrl;\n\t\t\tep0_readable (dev);\n\t\t\tspin_unlock (&dev->lock);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/* proceed with data transfer and status phases? */\n\tif (value >= 0 && dev->state != STATE_DEV_SETUP) {\n\t\treq->length = value;\n\t\treq->zero = value < w_length;\n\n\t\t++dev->udc_usage;\n\t\tspin_unlock (&dev->lock);\n\t\tvalue = usb_ep_queue (gadget->ep0, req, GFP_KERNEL);\n\t\tspin_lock(&dev->lock);\n\t\t--dev->udc_usage;\n\t\tspin_unlock(&dev->lock);\n\t\tif (value < 0) {\n\t\t\tDBG (dev, \"ep_queue --> %d\\n\", value);\n\t\t\treq->status = 0;\n\t\t}\n\t\treturn value;\n\t}\n\n\t/* device stalls when value < 0 */\n\tspin_unlock (&dev->lock);\n\treturn value;\n}\n\nstatic void destroy_ep_files (struct dev_data *dev)\n{\n\tDBG (dev, \"%s %d\\n\", __func__, dev->state);\n\n\t/* dev->state must prevent interference */\n\tspin_lock_irq (&dev->lock);\n\twhile (!list_empty(&dev->epfiles)) {\n\t\tstruct ep_data\t*ep;\n\t\tstruct inode\t*parent;\n\t\tstruct dentry\t*dentry;\n\n\t\t/* break link to FS */\n\t\tep = list_first_entry (&dev->epfiles, struct ep_data, epfiles);\n\t\tlist_del_init (&ep->epfiles);\n\t\tspin_unlock_irq (&dev->lock);\n\n\t\tdentry = ep->dentry;\n\t\tep->dentry = NULL;\n\t\tparent = d_inode(dentry->d_parent);\n\n\t\t/* break link to controller */\n\t\tmutex_lock(&ep->lock);\n\t\tif (ep->state == STATE_EP_ENABLED)\n\t\t\t(void) usb_ep_disable (ep->ep);\n\t\tep->state = STATE_EP_UNBOUND;\n\t\tusb_ep_free_request (ep->ep, ep->req);\n\t\tep->ep = NULL;\n\t\tmutex_unlock(&ep->lock);\n\n\t\twake_up (&ep->wait);\n\t\tput_ep (ep);\n\n\t\t/* break link to dcache */\n\t\tinode_lock(parent);\n\t\td_delete (dentry);\n\t\tdput (dentry);\n\t\tinode_unlock(parent);\n\n\t\tspin_lock_irq (&dev->lock);\n\t}\n\tspin_unlock_irq (&dev->lock);\n}\n\n\nstatic struct dentry *\ngadgetfs_create_file (struct super_block *sb, char const *name,\n\t\tvoid *data, const struct file_operations *fops);\n\nstatic int activate_ep_files (struct dev_data *dev)\n{\n\tstruct usb_ep\t*ep;\n\tstruct ep_data\t*data;\n\n\tgadget_for_each_ep (ep, dev->gadget) {\n\n\t\tdata = kzalloc(sizeof(*data), GFP_KERNEL);\n\t\tif (!data)\n\t\t\tgoto enomem0;\n\t\tdata->state = STATE_EP_DISABLED;\n\t\tmutex_init(&data->lock);\n\t\tinit_waitqueue_head (&data->wait);\n\n\t\tstrncpy (data->name, ep->name, sizeof (data->name) - 1);\n\t\trefcount_set (&data->count, 1);\n\t\tdata->dev = dev;\n\t\tget_dev (dev);\n\n\t\tdata->ep = ep;\n\t\tep->driver_data = data;\n\n\t\tdata->req = usb_ep_alloc_request (ep, GFP_KERNEL);\n\t\tif (!data->req)\n\t\t\tgoto enomem1;\n\n\t\tdata->dentry = gadgetfs_create_file (dev->sb, data->name,\n\t\t\t\tdata, &ep_io_operations);\n\t\tif (!data->dentry)\n\t\t\tgoto enomem2;\n\t\tlist_add_tail (&data->epfiles, &dev->epfiles);\n\t}\n\treturn 0;\n\nenomem2:\n\tusb_ep_free_request (ep, data->req);\nenomem1:\n\tput_dev (dev);\n\tkfree (data);\nenomem0:\n\tDBG (dev, \"%s enomem\\n\", __func__);\n\tdestroy_ep_files (dev);\n\treturn -ENOMEM;\n}\n\nstatic void\ngadgetfs_unbind (struct usb_gadget *gadget)\n{\n\tstruct dev_data\t\t*dev = get_gadget_data (gadget);\n\n\tDBG (dev, \"%s\\n\", __func__);\n\n\tspin_lock_irq (&dev->lock);\n\tdev->state = STATE_DEV_UNBOUND;\n\twhile (dev->udc_usage > 0) {\n\t\tspin_unlock_irq(&dev->lock);\n\t\tusleep_range(1000, 2000);\n\t\tspin_lock_irq(&dev->lock);\n\t}\n\tspin_unlock_irq (&dev->lock);\n\n\tdestroy_ep_files (dev);\n\tgadget->ep0->driver_data = NULL;\n\tset_gadget_data (gadget, NULL);\n\n\t/* we've already been disconnected ... no i/o is active */\n\tif (dev->req)\n\t\tusb_ep_free_request (gadget->ep0, dev->req);\n\tDBG (dev, \"%s done\\n\", __func__);\n\tput_dev (dev);\n}\n\nstatic struct dev_data\t\t*the_device;\n\nstatic int gadgetfs_bind(struct usb_gadget *gadget,\n\t\tstruct usb_gadget_driver *driver)\n{\n\tstruct dev_data\t\t*dev = the_device;\n\n\tif (!dev)\n\t\treturn -ESRCH;\n\tif (0 != strcmp (CHIP, gadget->name)) {\n\t\tpr_err(\"%s expected %s controller not %s\\n\",\n\t\t\tshortname, CHIP, gadget->name);\n\t\treturn -ENODEV;\n\t}\n\n\tset_gadget_data (gadget, dev);\n\tdev->gadget = gadget;\n\tgadget->ep0->driver_data = dev;\n\n\t/* preallocate control response and buffer */\n\tdev->req = usb_ep_alloc_request (gadget->ep0, GFP_KERNEL);\n\tif (!dev->req)\n\t\tgoto enomem;\n\tdev->req->context = NULL;\n\tdev->req->complete = epio_complete;\n\n\tif (activate_ep_files (dev) < 0)\n\t\tgoto enomem;\n\n\tINFO (dev, \"bound to %s driver\\n\", gadget->name);\n\tspin_lock_irq(&dev->lock);\n\tdev->state = STATE_DEV_UNCONNECTED;\n\tspin_unlock_irq(&dev->lock);\n\tget_dev (dev);\n\treturn 0;\n\nenomem:\n\tgadgetfs_unbind (gadget);\n\treturn -ENOMEM;\n}\n\nstatic void\ngadgetfs_disconnect (struct usb_gadget *gadget)\n{\n\tstruct dev_data\t\t*dev = get_gadget_data (gadget);\n\tunsigned long\t\tflags;\n\n\tspin_lock_irqsave (&dev->lock, flags);\n\tif (dev->state == STATE_DEV_UNCONNECTED)\n\t\tgoto exit;\n\tdev->state = STATE_DEV_UNCONNECTED;\n\n\tINFO (dev, \"disconnected\\n\");\n\tnext_event (dev, GADGETFS_DISCONNECT);\n\tep0_readable (dev);\nexit:\n\tspin_unlock_irqrestore (&dev->lock, flags);\n}\n\nstatic void\ngadgetfs_suspend (struct usb_gadget *gadget)\n{\n\tstruct dev_data\t\t*dev = get_gadget_data (gadget);\n\tunsigned long\t\tflags;\n\n\tINFO (dev, \"suspended from state %d\\n\", dev->state);\n\tspin_lock_irqsave(&dev->lock, flags);\n\tswitch (dev->state) {\n\tcase STATE_DEV_SETUP:\t\t// VERY odd... host died??\n\tcase STATE_DEV_CONNECTED:\n\tcase STATE_DEV_UNCONNECTED:\n\t\tnext_event (dev, GADGETFS_SUSPEND);\n\t\tep0_readable (dev);\n\t\tfallthrough;\n\tdefault:\n\t\tbreak;\n\t}\n\tspin_unlock_irqrestore(&dev->lock, flags);\n}\n\nstatic struct usb_gadget_driver gadgetfs_driver = {\n\t.function\t= (char *) driver_desc,\n\t.bind\t\t= gadgetfs_bind,\n\t.unbind\t\t= gadgetfs_unbind,\n\t.setup\t\t= gadgetfs_setup,\n\t.reset\t\t= gadgetfs_disconnect,\n\t.disconnect\t= gadgetfs_disconnect,\n\t.suspend\t= gadgetfs_suspend,\n\n\t.driver\t= {\n\t\t.name\t\t= shortname,\n\t},\n};\n\n/*----------------------------------------------------------------------*/\n/* DEVICE INITIALIZATION\n *\n *     fd = open (\"/dev/gadget/$CHIP\", O_RDWR)\n *     status = write (fd, descriptors, sizeof descriptors)\n *\n * That write establishes the device configuration, so the kernel can\n * bind to the controller ... guaranteeing it can handle enumeration\n * at all necessary speeds.  Descriptor order is:\n *\n * . message tag (u32, host order) ... for now, must be zero; it\n *\twould change to support features like multi-config devices\n * . full/low speed config ... all wTotalLength bytes (with interface,\n *\tclass, altsetting, endpoint, and other descriptors)\n * . high speed config ... all descriptors, for high speed operation;\n *\tthis one's optional except for high-speed hardware\n * . device descriptor\n *\n * Endpoints are not yet enabled. Drivers must wait until device\n * configuration and interface altsetting changes create\n * the need to configure (or unconfigure) them.\n *\n * After initialization, the device stays active for as long as that\n * $CHIP file is open.  Events must then be read from that descriptor,\n * such as configuration notifications.\n */\n\nstatic int is_valid_config(struct usb_config_descriptor *config,\n\t\tunsigned int total)\n{\n\treturn config->bDescriptorType == USB_DT_CONFIG\n\t\t&& config->bLength == USB_DT_CONFIG_SIZE\n\t\t&& total >= USB_DT_CONFIG_SIZE\n\t\t&& config->bConfigurationValue != 0\n\t\t&& (config->bmAttributes & USB_CONFIG_ATT_ONE) != 0\n\t\t&& (config->bmAttributes & USB_CONFIG_ATT_WAKEUP) == 0;\n\t/* FIXME if gadget->is_otg, _must_ include an otg descriptor */\n\t/* FIXME check lengths: walk to end */\n}\n\nstatic ssize_t\ndev_config (struct file *fd, const char __user *buf, size_t len, loff_t *ptr)\n{\n\tstruct dev_data\t\t*dev = fd->private_data;\n\tssize_t\t\t\tvalue, length = len;\n\tunsigned\t\ttotal;\n\tu32\t\t\ttag;\n\tchar\t\t\t*kbuf;\n\n\tspin_lock_irq(&dev->lock);\n\tif (dev->state > STATE_DEV_OPENED) {\n\t\tvalue = ep0_write(fd, buf, len, ptr);\n\t\tspin_unlock_irq(&dev->lock);\n\t\treturn value;\n\t}\n\tspin_unlock_irq(&dev->lock);\n\n\tif ((len < (USB_DT_CONFIG_SIZE + USB_DT_DEVICE_SIZE + 4)) ||\n\t    (len > PAGE_SIZE * 4))\n\t\treturn -EINVAL;\n\n\t/* we might need to change message format someday */\n\tif (copy_from_user (&tag, buf, 4))\n\t\treturn -EFAULT;\n\tif (tag != 0)\n\t\treturn -EINVAL;\n\tbuf += 4;\n\tlength -= 4;\n\n\tkbuf = memdup_user(buf, length);\n\tif (IS_ERR(kbuf))\n\t\treturn PTR_ERR(kbuf);\n\n\tspin_lock_irq (&dev->lock);\n\tvalue = -EINVAL;\n\tif (dev->buf) {\n\t\tspin_unlock_irq(&dev->lock);\n\t\tkfree(kbuf);\n\t\treturn value;\n\t}\n\tdev->buf = kbuf;\n\n\t/* full or low speed config */\n\tdev->config = (void *) kbuf;\n\ttotal = le16_to_cpu(dev->config->wTotalLength);\n\tif (!is_valid_config(dev->config, total) ||\n\t\t\ttotal > length - USB_DT_DEVICE_SIZE)\n\t\tgoto fail;\n\tkbuf += total;\n\tlength -= total;\n\n\t/* optional high speed config */\n\tif (kbuf [1] == USB_DT_CONFIG) {\n\t\tdev->hs_config = (void *) kbuf;\n\t\ttotal = le16_to_cpu(dev->hs_config->wTotalLength);\n\t\tif (!is_valid_config(dev->hs_config, total) ||\n\t\t\t\ttotal > length - USB_DT_DEVICE_SIZE)\n\t\t\tgoto fail;\n\t\tkbuf += total;\n\t\tlength -= total;\n\t} else {\n\t\tdev->hs_config = NULL;\n\t}\n\n\t/* could support multiple configs, using another encoding! */\n\n\t/* device descriptor (tweaked for paranoia) */\n\tif (length != USB_DT_DEVICE_SIZE)\n\t\tgoto fail;\n\tdev->dev = (void *)kbuf;\n\tif (dev->dev->bLength != USB_DT_DEVICE_SIZE\n\t\t\t|| dev->dev->bDescriptorType != USB_DT_DEVICE\n\t\t\t|| dev->dev->bNumConfigurations != 1)\n\t\tgoto fail;\n\tdev->dev->bcdUSB = cpu_to_le16 (0x0200);\n\n\t/* triggers gadgetfs_bind(); then we can enumerate. */\n\tspin_unlock_irq (&dev->lock);\n\tif (dev->hs_config)\n\t\tgadgetfs_driver.max_speed = USB_SPEED_HIGH;\n\telse\n\t\tgadgetfs_driver.max_speed = USB_SPEED_FULL;\n\n\tvalue = usb_gadget_probe_driver(&gadgetfs_driver);\n\tif (value != 0) {\n\t\tkfree (dev->buf);\n\t\tdev->buf = NULL;\n\t} else {\n\t\t/* at this point \"good\" hardware has for the first time\n\t\t * let the USB the host see us.  alternatively, if users\n\t\t * unplug/replug that will clear all the error state.\n\t\t *\n\t\t * note:  everything running before here was guaranteed\n\t\t * to choke driver model style diagnostics.  from here\n\t\t * on, they can work ... except in cleanup paths that\n\t\t * kick in after the ep0 descriptor is closed.\n\t\t */\n\t\tvalue = len;\n\t\tdev->gadget_registered = true;\n\t}\n\treturn value;\n\nfail:\n\tspin_unlock_irq (&dev->lock);\n\tpr_debug (\"%s: %s fail %zd, %p\\n\", shortname, __func__, value, dev);\n\tkfree (dev->buf);\n\tdev->buf = NULL;\n\treturn value;\n}\n\nstatic int\ndev_open (struct inode *inode, struct file *fd)\n{\n\tstruct dev_data\t\t*dev = inode->i_private;\n\tint\t\t\tvalue = -EBUSY;\n\n\tspin_lock_irq(&dev->lock);\n\tif (dev->state == STATE_DEV_DISABLED) {\n\t\tdev->ev_next = 0;\n\t\tdev->state = STATE_DEV_OPENED;\n\t\tfd->private_data = dev;\n\t\tget_dev (dev);\n\t\tvalue = 0;\n\t}\n\tspin_unlock_irq(&dev->lock);\n\treturn value;\n}\n\nstatic const struct file_operations ep0_operations = {\n\t.llseek =\tno_llseek,\n\n\t.open =\t\tdev_open,\n\t.read =\t\tep0_read,\n\t.write =\tdev_config,\n\t.fasync =\tep0_fasync,\n\t.poll =\t\tep0_poll,\n\t.unlocked_ioctl = dev_ioctl,\n\t.release =\tdev_release,\n};\n\n/*----------------------------------------------------------------------*/\n\n/* FILESYSTEM AND SUPERBLOCK OPERATIONS\n *\n * Mounting the filesystem creates a controller file, used first for\n * device configuration then later for event monitoring.\n */\n\n\n/* FIXME PAM etc could set this security policy without mount options\n * if epfiles inherited ownership and permissons from ep0 ...\n */\n\nstatic unsigned default_uid;\nstatic unsigned default_gid;\nstatic unsigned default_perm = S_IRUSR | S_IWUSR;\n\nmodule_param (default_uid, uint, 0644);\nmodule_param (default_gid, uint, 0644);\nmodule_param (default_perm, uint, 0644);\n\n\nstatic struct inode *\ngadgetfs_make_inode (struct super_block *sb,\n\t\tvoid *data, const struct file_operations *fops,\n\t\tint mode)\n{\n\tstruct inode *inode = new_inode (sb);\n\n\tif (inode) {\n\t\tinode->i_ino = get_next_ino();\n\t\tinode->i_mode = mode;\n\t\tinode->i_uid = make_kuid(&init_user_ns, default_uid);\n\t\tinode->i_gid = make_kgid(&init_user_ns, default_gid);\n\t\tinode->i_atime = inode->i_mtime = inode->i_ctime\n\t\t\t\t= current_time(inode);\n\t\tinode->i_private = data;\n\t\tinode->i_fop = fops;\n\t}\n\treturn inode;\n}\n\n/* creates in fs root directory, so non-renamable and non-linkable.\n * so inode and dentry are paired, until device reconfig.\n */\nstatic struct dentry *\ngadgetfs_create_file (struct super_block *sb, char const *name,\n\t\tvoid *data, const struct file_operations *fops)\n{\n\tstruct dentry\t*dentry;\n\tstruct inode\t*inode;\n\n\tdentry = d_alloc_name(sb->s_root, name);\n\tif (!dentry)\n\t\treturn NULL;\n\n\tinode = gadgetfs_make_inode (sb, data, fops,\n\t\t\tS_IFREG | (default_perm & S_IRWXUGO));\n\tif (!inode) {\n\t\tdput(dentry);\n\t\treturn NULL;\n\t}\n\td_add (dentry, inode);\n\treturn dentry;\n}\n\nstatic const struct super_operations gadget_fs_operations = {\n\t.statfs =\tsimple_statfs,\n\t.drop_inode =\tgeneric_delete_inode,\n};\n\nstatic int\ngadgetfs_fill_super (struct super_block *sb, struct fs_context *fc)\n{\n\tstruct inode\t*inode;\n\tstruct dev_data\t*dev;\n\n\tif (the_device)\n\t\treturn -ESRCH;\n\n\tCHIP = usb_get_gadget_udc_name();\n\tif (!CHIP)\n\t\treturn -ENODEV;\n\n\t/* superblock */\n\tsb->s_blocksize = PAGE_SIZE;\n\tsb->s_blocksize_bits = PAGE_SHIFT;\n\tsb->s_magic = GADGETFS_MAGIC;\n\tsb->s_op = &gadget_fs_operations;\n\tsb->s_time_gran = 1;\n\n\t/* root inode */\n\tinode = gadgetfs_make_inode (sb,\n\t\t\tNULL, &simple_dir_operations,\n\t\t\tS_IFDIR | S_IRUGO | S_IXUGO);\n\tif (!inode)\n\t\tgoto Enomem;\n\tinode->i_op = &simple_dir_inode_operations;\n\tif (!(sb->s_root = d_make_root (inode)))\n\t\tgoto Enomem;\n\n\t/* the ep0 file is named after the controller we expect;\n\t * user mode code can use it for sanity checks, like we do.\n\t */\n\tdev = dev_new ();\n\tif (!dev)\n\t\tgoto Enomem;\n\n\tdev->sb = sb;\n\tdev->dentry = gadgetfs_create_file(sb, CHIP, dev, &ep0_operations);\n\tif (!dev->dentry) {\n\t\tput_dev(dev);\n\t\tgoto Enomem;\n\t}\n\n\t/* other endpoint files are available after hardware setup,\n\t * from binding to a controller.\n\t */\n\tthe_device = dev;\n\treturn 0;\n\nEnomem:\n\tkfree(CHIP);\n\tCHIP = NULL;\n\n\treturn -ENOMEM;\n}\n\n/* \"mount -t gadgetfs path /dev/gadget\" ends up here */\nstatic int gadgetfs_get_tree(struct fs_context *fc)\n{\n\treturn get_tree_single(fc, gadgetfs_fill_super);\n}\n\nstatic const struct fs_context_operations gadgetfs_context_ops = {\n\t.get_tree\t= gadgetfs_get_tree,\n};\n\nstatic int gadgetfs_init_fs_context(struct fs_context *fc)\n{\n\tfc->ops = &gadgetfs_context_ops;\n\treturn 0;\n}\n\nstatic void\ngadgetfs_kill_sb (struct super_block *sb)\n{\n\tkill_litter_super (sb);\n\tif (the_device) {\n\t\tput_dev (the_device);\n\t\tthe_device = NULL;\n\t}\n\tkfree(CHIP);\n\tCHIP = NULL;\n}\n\n/*----------------------------------------------------------------------*/\n\nstatic struct file_system_type gadgetfs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= shortname,\n\t.init_fs_context = gadgetfs_init_fs_context,\n\t.kill_sb\t= gadgetfs_kill_sb,\n};\nMODULE_ALIAS_FS(\"gadgetfs\");\n\n/*----------------------------------------------------------------------*/\n\nstatic int __init init (void)\n{\n\tint status;\n\n\tstatus = register_filesystem (&gadgetfs_type);\n\tif (status == 0)\n\t\tpr_info (\"%s: %s, version \" DRIVER_VERSION \"\\n\",\n\t\t\tshortname, driver_desc);\n\treturn status;\n}\nmodule_init (init);\n\nstatic void __exit cleanup (void)\n{\n\tpr_debug (\"unregister %s\\n\", shortname);\n\tunregister_filesystem (&gadgetfs_type);\n}\nmodule_exit (cleanup);\n\n"], "fixing_code": ["// SPDX-License-Identifier: GPL-2.0+\n/*\n * inode.c -- user mode filesystem api for usb gadget controllers\n *\n * Copyright (C) 2003-2004 David Brownell\n * Copyright (C) 2003 Agilent Technologies\n */\n\n\n/* #define VERBOSE_DEBUG */\n\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/fs_context.h>\n#include <linux/pagemap.h>\n#include <linux/uts.h>\n#include <linux/wait.h>\n#include <linux/compiler.h>\n#include <linux/uaccess.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/kthread.h>\n#include <linux/aio.h>\n#include <linux/uio.h>\n#include <linux/refcount.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n\n#include <linux/usb/gadgetfs.h>\n#include <linux/usb/gadget.h>\n\n\n/*\n * The gadgetfs API maps each endpoint to a file descriptor so that you\n * can use standard synchronous read/write calls for I/O.  There's some\n * O_NONBLOCK and O_ASYNC/FASYNC style i/o support.  Example usermode\n * drivers show how this works in practice.  You can also use AIO to\n * eliminate I/O gaps between requests, to help when streaming data.\n *\n * Key parts that must be USB-specific are protocols defining how the\n * read/write operations relate to the hardware state machines.  There\n * are two types of files.  One type is for the device, implementing ep0.\n * The other type is for each IN or OUT endpoint.  In both cases, the\n * user mode driver must configure the hardware before using it.\n *\n * - First, dev_config() is called when /dev/gadget/$CHIP is configured\n *   (by writing configuration and device descriptors).  Afterwards it\n *   may serve as a source of device events, used to handle all control\n *   requests other than basic enumeration.\n *\n * - Then, after a SET_CONFIGURATION control request, ep_config() is\n *   called when each /dev/gadget/ep* file is configured (by writing\n *   endpoint descriptors).  Afterwards these files are used to write()\n *   IN data or to read() OUT data.  To halt the endpoint, a \"wrong\n *   direction\" request is issued (like reading an IN endpoint).\n *\n * Unlike \"usbfs\" the only ioctl()s are for things that are rare, and maybe\n * not possible on all hardware.  For example, precise fault handling with\n * respect to data left in endpoint fifos after aborted operations; or\n * selective clearing of endpoint halts, to implement SET_INTERFACE.\n */\n\n#define\tDRIVER_DESC\t\"USB Gadget filesystem\"\n#define\tDRIVER_VERSION\t\"24 Aug 2004\"\n\nstatic const char driver_desc [] = DRIVER_DESC;\nstatic const char shortname [] = \"gadgetfs\";\n\nMODULE_DESCRIPTION (DRIVER_DESC);\nMODULE_AUTHOR (\"David Brownell\");\nMODULE_LICENSE (\"GPL\");\n\nstatic int ep_open(struct inode *, struct file *);\n\n\n/*----------------------------------------------------------------------*/\n\n#define GADGETFS_MAGIC\t\t0xaee71ee7\n\n/* /dev/gadget/$CHIP represents ep0 and the whole device */\nenum ep0_state {\n\t/* DISABLED is the initial state. */\n\tSTATE_DEV_DISABLED = 0,\n\n\t/* Only one open() of /dev/gadget/$CHIP; only one file tracks\n\t * ep0/device i/o modes and binding to the controller.  Driver\n\t * must always write descriptors to initialize the device, then\n\t * the device becomes UNCONNECTED until enumeration.\n\t */\n\tSTATE_DEV_OPENED,\n\n\t/* From then on, ep0 fd is in either of two basic modes:\n\t * - (UN)CONNECTED: read usb_gadgetfs_event(s) from it\n\t * - SETUP: read/write will transfer control data and succeed;\n\t *   or if \"wrong direction\", performs protocol stall\n\t */\n\tSTATE_DEV_UNCONNECTED,\n\tSTATE_DEV_CONNECTED,\n\tSTATE_DEV_SETUP,\n\n\t/* UNBOUND means the driver closed ep0, so the device won't be\n\t * accessible again (DEV_DISABLED) until all fds are closed.\n\t */\n\tSTATE_DEV_UNBOUND,\n};\n\n/* enough for the whole queue: most events invalidate others */\n#define\tN_EVENT\t\t\t5\n\n#define RBUF_SIZE\t\t256\n\nstruct dev_data {\n\tspinlock_t\t\t\tlock;\n\trefcount_t\t\t\tcount;\n\tint\t\t\t\tudc_usage;\n\tenum ep0_state\t\t\tstate;\t\t/* P: lock */\n\tstruct usb_gadgetfs_event\tevent [N_EVENT];\n\tunsigned\t\t\tev_next;\n\tstruct fasync_struct\t\t*fasync;\n\tu8\t\t\t\tcurrent_config;\n\n\t/* drivers reading ep0 MUST handle control requests (SETUP)\n\t * reported that way; else the host will time out.\n\t */\n\tunsigned\t\t\tusermode_setup : 1,\n\t\t\t\t\tsetup_in : 1,\n\t\t\t\t\tsetup_can_stall : 1,\n\t\t\t\t\tsetup_out_ready : 1,\n\t\t\t\t\tsetup_out_error : 1,\n\t\t\t\t\tsetup_abort : 1,\n\t\t\t\t\tgadget_registered : 1;\n\tunsigned\t\t\tsetup_wLength;\n\n\t/* the rest is basically write-once */\n\tstruct usb_config_descriptor\t*config, *hs_config;\n\tstruct usb_device_descriptor\t*dev;\n\tstruct usb_request\t\t*req;\n\tstruct usb_gadget\t\t*gadget;\n\tstruct list_head\t\tepfiles;\n\tvoid\t\t\t\t*buf;\n\twait_queue_head_t\t\twait;\n\tstruct super_block\t\t*sb;\n\tstruct dentry\t\t\t*dentry;\n\n\t/* except this scratch i/o buffer for ep0 */\n\tu8\t\t\t\trbuf[RBUF_SIZE];\n};\n\nstatic inline void get_dev (struct dev_data *data)\n{\n\trefcount_inc (&data->count);\n}\n\nstatic void put_dev (struct dev_data *data)\n{\n\tif (likely (!refcount_dec_and_test (&data->count)))\n\t\treturn;\n\t/* needs no more cleanup */\n\tBUG_ON (waitqueue_active (&data->wait));\n\tkfree (data);\n}\n\nstatic struct dev_data *dev_new (void)\n{\n\tstruct dev_data\t\t*dev;\n\n\tdev = kzalloc(sizeof(*dev), GFP_KERNEL);\n\tif (!dev)\n\t\treturn NULL;\n\tdev->state = STATE_DEV_DISABLED;\n\trefcount_set (&dev->count, 1);\n\tspin_lock_init (&dev->lock);\n\tINIT_LIST_HEAD (&dev->epfiles);\n\tinit_waitqueue_head (&dev->wait);\n\treturn dev;\n}\n\n/*----------------------------------------------------------------------*/\n\n/* other /dev/gadget/$ENDPOINT files represent endpoints */\nenum ep_state {\n\tSTATE_EP_DISABLED = 0,\n\tSTATE_EP_READY,\n\tSTATE_EP_ENABLED,\n\tSTATE_EP_UNBOUND,\n};\n\nstruct ep_data {\n\tstruct mutex\t\t\tlock;\n\tenum ep_state\t\t\tstate;\n\trefcount_t\t\t\tcount;\n\tstruct dev_data\t\t\t*dev;\n\t/* must hold dev->lock before accessing ep or req */\n\tstruct usb_ep\t\t\t*ep;\n\tstruct usb_request\t\t*req;\n\tssize_t\t\t\t\tstatus;\n\tchar\t\t\t\tname [16];\n\tstruct usb_endpoint_descriptor\tdesc, hs_desc;\n\tstruct list_head\t\tepfiles;\n\twait_queue_head_t\t\twait;\n\tstruct dentry\t\t\t*dentry;\n};\n\nstatic inline void get_ep (struct ep_data *data)\n{\n\trefcount_inc (&data->count);\n}\n\nstatic void put_ep (struct ep_data *data)\n{\n\tif (likely (!refcount_dec_and_test (&data->count)))\n\t\treturn;\n\tput_dev (data->dev);\n\t/* needs no more cleanup */\n\tBUG_ON (!list_empty (&data->epfiles));\n\tBUG_ON (waitqueue_active (&data->wait));\n\tkfree (data);\n}\n\n/*----------------------------------------------------------------------*/\n\n/* most \"how to use the hardware\" policy choices are in userspace:\n * mapping endpoint roles (which the driver needs) to the capabilities\n * which the usb controller has.  most of those capabilities are exposed\n * implicitly, starting with the driver name and then endpoint names.\n */\n\nstatic const char *CHIP;\n\n/*----------------------------------------------------------------------*/\n\n/* NOTE:  don't use dev_printk calls before binding to the gadget\n * at the end of ep0 configuration, or after unbind.\n */\n\n/* too wordy: dev_printk(level , &(d)->gadget->dev , fmt , ## args) */\n#define xprintk(d,level,fmt,args...) \\\n\tprintk(level \"%s: \" fmt , shortname , ## args)\n\n#ifdef DEBUG\n#define DBG(dev,fmt,args...) \\\n\txprintk(dev , KERN_DEBUG , fmt , ## args)\n#else\n#define DBG(dev,fmt,args...) \\\n\tdo { } while (0)\n#endif /* DEBUG */\n\n#ifdef VERBOSE_DEBUG\n#define VDEBUG\tDBG\n#else\n#define VDEBUG(dev,fmt,args...) \\\n\tdo { } while (0)\n#endif /* DEBUG */\n\n#define ERROR(dev,fmt,args...) \\\n\txprintk(dev , KERN_ERR , fmt , ## args)\n#define INFO(dev,fmt,args...) \\\n\txprintk(dev , KERN_INFO , fmt , ## args)\n\n\n/*----------------------------------------------------------------------*/\n\n/* SYNCHRONOUS ENDPOINT OPERATIONS (bulk/intr/iso)\n *\n * After opening, configure non-control endpoints.  Then use normal\n * stream read() and write() requests; and maybe ioctl() to get more\n * precise FIFO status when recovering from cancellation.\n */\n\nstatic void epio_complete (struct usb_ep *ep, struct usb_request *req)\n{\n\tstruct ep_data\t*epdata = ep->driver_data;\n\n\tif (!req->context)\n\t\treturn;\n\tif (req->status)\n\t\tepdata->status = req->status;\n\telse\n\t\tepdata->status = req->actual;\n\tcomplete ((struct completion *)req->context);\n}\n\n/* tasklock endpoint, returning when it's connected.\n * still need dev->lock to use epdata->ep.\n */\nstatic int\nget_ready_ep (unsigned f_flags, struct ep_data *epdata, bool is_write)\n{\n\tint\tval;\n\n\tif (f_flags & O_NONBLOCK) {\n\t\tif (!mutex_trylock(&epdata->lock))\n\t\t\tgoto nonblock;\n\t\tif (epdata->state != STATE_EP_ENABLED &&\n\t\t    (!is_write || epdata->state != STATE_EP_READY)) {\n\t\t\tmutex_unlock(&epdata->lock);\nnonblock:\n\t\t\tval = -EAGAIN;\n\t\t} else\n\t\t\tval = 0;\n\t\treturn val;\n\t}\n\n\tval = mutex_lock_interruptible(&epdata->lock);\n\tif (val < 0)\n\t\treturn val;\n\n\tswitch (epdata->state) {\n\tcase STATE_EP_ENABLED:\n\t\treturn 0;\n\tcase STATE_EP_READY:\t\t\t/* not configured yet */\n\t\tif (is_write)\n\t\t\treturn 0;\n\t\tfallthrough;\n\tcase STATE_EP_UNBOUND:\t\t\t/* clean disconnect */\n\t\tbreak;\n\t// case STATE_EP_DISABLED:\t\t/* \"can't happen\" */\n\tdefault:\t\t\t\t/* error! */\n\t\tpr_debug (\"%s: ep %p not available, state %d\\n\",\n\t\t\t\tshortname, epdata, epdata->state);\n\t}\n\tmutex_unlock(&epdata->lock);\n\treturn -ENODEV;\n}\n\nstatic ssize_t\nep_io (struct ep_data *epdata, void *buf, unsigned len)\n{\n\tDECLARE_COMPLETION_ONSTACK (done);\n\tint value;\n\n\tspin_lock_irq (&epdata->dev->lock);\n\tif (likely (epdata->ep != NULL)) {\n\t\tstruct usb_request\t*req = epdata->req;\n\n\t\treq->context = &done;\n\t\treq->complete = epio_complete;\n\t\treq->buf = buf;\n\t\treq->length = len;\n\t\tvalue = usb_ep_queue (epdata->ep, req, GFP_ATOMIC);\n\t} else\n\t\tvalue = -ENODEV;\n\tspin_unlock_irq (&epdata->dev->lock);\n\n\tif (likely (value == 0)) {\n\t\tvalue = wait_for_completion_interruptible(&done);\n\t\tif (value != 0) {\n\t\t\tspin_lock_irq (&epdata->dev->lock);\n\t\t\tif (likely (epdata->ep != NULL)) {\n\t\t\t\tDBG (epdata->dev, \"%s i/o interrupted\\n\",\n\t\t\t\t\t\tepdata->name);\n\t\t\t\tusb_ep_dequeue (epdata->ep, epdata->req);\n\t\t\t\tspin_unlock_irq (&epdata->dev->lock);\n\n\t\t\t\twait_for_completion(&done);\n\t\t\t\tif (epdata->status == -ECONNRESET)\n\t\t\t\t\tepdata->status = -EINTR;\n\t\t\t} else {\n\t\t\t\tspin_unlock_irq (&epdata->dev->lock);\n\n\t\t\t\tDBG (epdata->dev, \"endpoint gone\\n\");\n\t\t\t\tepdata->status = -ENODEV;\n\t\t\t}\n\t\t}\n\t\treturn epdata->status;\n\t}\n\treturn value;\n}\n\nstatic int\nep_release (struct inode *inode, struct file *fd)\n{\n\tstruct ep_data\t\t*data = fd->private_data;\n\tint value;\n\n\tvalue = mutex_lock_interruptible(&data->lock);\n\tif (value < 0)\n\t\treturn value;\n\n\t/* clean up if this can be reopened */\n\tif (data->state != STATE_EP_UNBOUND) {\n\t\tdata->state = STATE_EP_DISABLED;\n\t\tdata->desc.bDescriptorType = 0;\n\t\tdata->hs_desc.bDescriptorType = 0;\n\t\tusb_ep_disable(data->ep);\n\t}\n\tmutex_unlock(&data->lock);\n\tput_ep (data);\n\treturn 0;\n}\n\nstatic long ep_ioctl(struct file *fd, unsigned code, unsigned long value)\n{\n\tstruct ep_data\t\t*data = fd->private_data;\n\tint\t\t\tstatus;\n\n\tif ((status = get_ready_ep (fd->f_flags, data, false)) < 0)\n\t\treturn status;\n\n\tspin_lock_irq (&data->dev->lock);\n\tif (likely (data->ep != NULL)) {\n\t\tswitch (code) {\n\t\tcase GADGETFS_FIFO_STATUS:\n\t\t\tstatus = usb_ep_fifo_status (data->ep);\n\t\t\tbreak;\n\t\tcase GADGETFS_FIFO_FLUSH:\n\t\t\tusb_ep_fifo_flush (data->ep);\n\t\t\tbreak;\n\t\tcase GADGETFS_CLEAR_HALT:\n\t\t\tstatus = usb_ep_clear_halt (data->ep);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tstatus = -ENOTTY;\n\t\t}\n\t} else\n\t\tstatus = -ENODEV;\n\tspin_unlock_irq (&data->dev->lock);\n\tmutex_unlock(&data->lock);\n\treturn status;\n}\n\n/*----------------------------------------------------------------------*/\n\n/* ASYNCHRONOUS ENDPOINT I/O OPERATIONS (bulk/intr/iso) */\n\nstruct kiocb_priv {\n\tstruct usb_request\t*req;\n\tstruct ep_data\t\t*epdata;\n\tstruct kiocb\t\t*iocb;\n\tstruct mm_struct\t*mm;\n\tstruct work_struct\twork;\n\tvoid\t\t\t*buf;\n\tstruct iov_iter\t\tto;\n\tconst void\t\t*to_free;\n\tunsigned\t\tactual;\n};\n\nstatic int ep_aio_cancel(struct kiocb *iocb)\n{\n\tstruct kiocb_priv\t*priv = iocb->private;\n\tstruct ep_data\t\t*epdata;\n\tint\t\t\tvalue;\n\n\tlocal_irq_disable();\n\tepdata = priv->epdata;\n\t// spin_lock(&epdata->dev->lock);\n\tif (likely(epdata && epdata->ep && priv->req))\n\t\tvalue = usb_ep_dequeue (epdata->ep, priv->req);\n\telse\n\t\tvalue = -EINVAL;\n\t// spin_unlock(&epdata->dev->lock);\n\tlocal_irq_enable();\n\n\treturn value;\n}\n\nstatic void ep_user_copy_worker(struct work_struct *work)\n{\n\tstruct kiocb_priv *priv = container_of(work, struct kiocb_priv, work);\n\tstruct mm_struct *mm = priv->mm;\n\tstruct kiocb *iocb = priv->iocb;\n\tsize_t ret;\n\n\tkthread_use_mm(mm);\n\tret = copy_to_iter(priv->buf, priv->actual, &priv->to);\n\tkthread_unuse_mm(mm);\n\tif (!ret)\n\t\tret = -EFAULT;\n\n\t/* completing the iocb can drop the ctx and mm, don't touch mm after */\n\tiocb->ki_complete(iocb, ret);\n\n\tkfree(priv->buf);\n\tkfree(priv->to_free);\n\tkfree(priv);\n}\n\nstatic void ep_aio_complete(struct usb_ep *ep, struct usb_request *req)\n{\n\tstruct kiocb\t\t*iocb = req->context;\n\tstruct kiocb_priv\t*priv = iocb->private;\n\tstruct ep_data\t\t*epdata = priv->epdata;\n\n\t/* lock against disconnect (and ideally, cancel) */\n\tspin_lock(&epdata->dev->lock);\n\tpriv->req = NULL;\n\tpriv->epdata = NULL;\n\n\t/* if this was a write or a read returning no data then we\n\t * don't need to copy anything to userspace, so we can\n\t * complete the aio request immediately.\n\t */\n\tif (priv->to_free == NULL || unlikely(req->actual == 0)) {\n\t\tkfree(req->buf);\n\t\tkfree(priv->to_free);\n\t\tkfree(priv);\n\t\tiocb->private = NULL;\n\t\tiocb->ki_complete(iocb,\n\t\t\t\treq->actual ? req->actual : (long)req->status);\n\t} else {\n\t\t/* ep_copy_to_user() won't report both; we hide some faults */\n\t\tif (unlikely(0 != req->status))\n\t\t\tDBG(epdata->dev, \"%s fault %d len %d\\n\",\n\t\t\t\tep->name, req->status, req->actual);\n\n\t\tpriv->buf = req->buf;\n\t\tpriv->actual = req->actual;\n\t\tINIT_WORK(&priv->work, ep_user_copy_worker);\n\t\tschedule_work(&priv->work);\n\t}\n\n\tusb_ep_free_request(ep, req);\n\tspin_unlock(&epdata->dev->lock);\n\tput_ep(epdata);\n}\n\nstatic ssize_t ep_aio(struct kiocb *iocb,\n\t\t      struct kiocb_priv *priv,\n\t\t      struct ep_data *epdata,\n\t\t      char *buf,\n\t\t      size_t len)\n{\n\tstruct usb_request *req;\n\tssize_t value;\n\n\tiocb->private = priv;\n\tpriv->iocb = iocb;\n\n\tkiocb_set_cancel_fn(iocb, ep_aio_cancel);\n\tget_ep(epdata);\n\tpriv->epdata = epdata;\n\tpriv->actual = 0;\n\tpriv->mm = current->mm; /* mm teardown waits for iocbs in exit_aio() */\n\n\t/* each kiocb is coupled to one usb_request, but we can't\n\t * allocate or submit those if the host disconnected.\n\t */\n\tspin_lock_irq(&epdata->dev->lock);\n\tvalue = -ENODEV;\n\tif (unlikely(epdata->ep == NULL))\n\t\tgoto fail;\n\n\treq = usb_ep_alloc_request(epdata->ep, GFP_ATOMIC);\n\tvalue = -ENOMEM;\n\tif (unlikely(!req))\n\t\tgoto fail;\n\n\tpriv->req = req;\n\treq->buf = buf;\n\treq->length = len;\n\treq->complete = ep_aio_complete;\n\treq->context = iocb;\n\tvalue = usb_ep_queue(epdata->ep, req, GFP_ATOMIC);\n\tif (unlikely(0 != value)) {\n\t\tusb_ep_free_request(epdata->ep, req);\n\t\tgoto fail;\n\t}\n\tspin_unlock_irq(&epdata->dev->lock);\n\treturn -EIOCBQUEUED;\n\nfail:\n\tspin_unlock_irq(&epdata->dev->lock);\n\tkfree(priv->to_free);\n\tkfree(priv);\n\tput_ep(epdata);\n\treturn value;\n}\n\nstatic ssize_t\nep_read_iter(struct kiocb *iocb, struct iov_iter *to)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct ep_data *epdata = file->private_data;\n\tsize_t len = iov_iter_count(to);\n\tssize_t value;\n\tchar *buf;\n\n\tif ((value = get_ready_ep(file->f_flags, epdata, false)) < 0)\n\t\treturn value;\n\n\t/* halt any endpoint by doing a \"wrong direction\" i/o call */\n\tif (usb_endpoint_dir_in(&epdata->desc)) {\n\t\tif (usb_endpoint_xfer_isoc(&epdata->desc) ||\n\t\t    !is_sync_kiocb(iocb)) {\n\t\t\tmutex_unlock(&epdata->lock);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tDBG (epdata->dev, \"%s halt\\n\", epdata->name);\n\t\tspin_lock_irq(&epdata->dev->lock);\n\t\tif (likely(epdata->ep != NULL))\n\t\t\tusb_ep_set_halt(epdata->ep);\n\t\tspin_unlock_irq(&epdata->dev->lock);\n\t\tmutex_unlock(&epdata->lock);\n\t\treturn -EBADMSG;\n\t}\n\n\tbuf = kmalloc(len, GFP_KERNEL);\n\tif (unlikely(!buf)) {\n\t\tmutex_unlock(&epdata->lock);\n\t\treturn -ENOMEM;\n\t}\n\tif (is_sync_kiocb(iocb)) {\n\t\tvalue = ep_io(epdata, buf, len);\n\t\tif (value >= 0 && (copy_to_iter(buf, value, to) != value))\n\t\t\tvalue = -EFAULT;\n\t} else {\n\t\tstruct kiocb_priv *priv = kzalloc(sizeof *priv, GFP_KERNEL);\n\t\tvalue = -ENOMEM;\n\t\tif (!priv)\n\t\t\tgoto fail;\n\t\tpriv->to_free = dup_iter(&priv->to, to, GFP_KERNEL);\n\t\tif (!priv->to_free) {\n\t\t\tkfree(priv);\n\t\t\tgoto fail;\n\t\t}\n\t\tvalue = ep_aio(iocb, priv, epdata, buf, len);\n\t\tif (value == -EIOCBQUEUED)\n\t\t\tbuf = NULL;\n\t}\nfail:\n\tkfree(buf);\n\tmutex_unlock(&epdata->lock);\n\treturn value;\n}\n\nstatic ssize_t ep_config(struct ep_data *, const char *, size_t);\n\nstatic ssize_t\nep_write_iter(struct kiocb *iocb, struct iov_iter *from)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct ep_data *epdata = file->private_data;\n\tsize_t len = iov_iter_count(from);\n\tbool configured;\n\tssize_t value;\n\tchar *buf;\n\n\tif ((value = get_ready_ep(file->f_flags, epdata, true)) < 0)\n\t\treturn value;\n\n\tconfigured = epdata->state == STATE_EP_ENABLED;\n\n\t/* halt any endpoint by doing a \"wrong direction\" i/o call */\n\tif (configured && !usb_endpoint_dir_in(&epdata->desc)) {\n\t\tif (usb_endpoint_xfer_isoc(&epdata->desc) ||\n\t\t    !is_sync_kiocb(iocb)) {\n\t\t\tmutex_unlock(&epdata->lock);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tDBG (epdata->dev, \"%s halt\\n\", epdata->name);\n\t\tspin_lock_irq(&epdata->dev->lock);\n\t\tif (likely(epdata->ep != NULL))\n\t\t\tusb_ep_set_halt(epdata->ep);\n\t\tspin_unlock_irq(&epdata->dev->lock);\n\t\tmutex_unlock(&epdata->lock);\n\t\treturn -EBADMSG;\n\t}\n\n\tbuf = kmalloc(len, GFP_KERNEL);\n\tif (unlikely(!buf)) {\n\t\tmutex_unlock(&epdata->lock);\n\t\treturn -ENOMEM;\n\t}\n\n\tif (unlikely(!copy_from_iter_full(buf, len, from))) {\n\t\tvalue = -EFAULT;\n\t\tgoto out;\n\t}\n\n\tif (unlikely(!configured)) {\n\t\tvalue = ep_config(epdata, buf, len);\n\t} else if (is_sync_kiocb(iocb)) {\n\t\tvalue = ep_io(epdata, buf, len);\n\t} else {\n\t\tstruct kiocb_priv *priv = kzalloc(sizeof *priv, GFP_KERNEL);\n\t\tvalue = -ENOMEM;\n\t\tif (priv) {\n\t\t\tvalue = ep_aio(iocb, priv, epdata, buf, len);\n\t\t\tif (value == -EIOCBQUEUED)\n\t\t\t\tbuf = NULL;\n\t\t}\n\t}\nout:\n\tkfree(buf);\n\tmutex_unlock(&epdata->lock);\n\treturn value;\n}\n\n/*----------------------------------------------------------------------*/\n\n/* used after endpoint configuration */\nstatic const struct file_operations ep_io_operations = {\n\t.owner =\tTHIS_MODULE,\n\n\t.open =\t\tep_open,\n\t.release =\tep_release,\n\t.llseek =\tno_llseek,\n\t.unlocked_ioctl = ep_ioctl,\n\t.read_iter =\tep_read_iter,\n\t.write_iter =\tep_write_iter,\n};\n\n/* ENDPOINT INITIALIZATION\n *\n *     fd = open (\"/dev/gadget/$ENDPOINT\", O_RDWR)\n *     status = write (fd, descriptors, sizeof descriptors)\n *\n * That write establishes the endpoint configuration, configuring\n * the controller to process bulk, interrupt, or isochronous transfers\n * at the right maxpacket size, and so on.\n *\n * The descriptors are message type 1, identified by a host order u32\n * at the beginning of what's written.  Descriptor order is: full/low\n * speed descriptor, then optional high speed descriptor.\n */\nstatic ssize_t\nep_config (struct ep_data *data, const char *buf, size_t len)\n{\n\tstruct usb_ep\t\t*ep;\n\tu32\t\t\ttag;\n\tint\t\t\tvalue, length = len;\n\n\tif (data->state != STATE_EP_READY) {\n\t\tvalue = -EL2HLT;\n\t\tgoto fail;\n\t}\n\n\tvalue = len;\n\tif (len < USB_DT_ENDPOINT_SIZE + 4)\n\t\tgoto fail0;\n\n\t/* we might need to change message format someday */\n\tmemcpy(&tag, buf, 4);\n\tif (tag != 1) {\n\t\tDBG(data->dev, \"config %s, bad tag %d\\n\", data->name, tag);\n\t\tgoto fail0;\n\t}\n\tbuf += 4;\n\tlen -= 4;\n\n\t/* NOTE:  audio endpoint extensions not accepted here;\n\t * just don't include the extra bytes.\n\t */\n\n\t/* full/low speed descriptor, then high speed */\n\tmemcpy(&data->desc, buf, USB_DT_ENDPOINT_SIZE);\n\tif (data->desc.bLength != USB_DT_ENDPOINT_SIZE\n\t\t\t|| data->desc.bDescriptorType != USB_DT_ENDPOINT)\n\t\tgoto fail0;\n\tif (len != USB_DT_ENDPOINT_SIZE) {\n\t\tif (len != 2 * USB_DT_ENDPOINT_SIZE)\n\t\t\tgoto fail0;\n\t\tmemcpy(&data->hs_desc, buf + USB_DT_ENDPOINT_SIZE,\n\t\t\tUSB_DT_ENDPOINT_SIZE);\n\t\tif (data->hs_desc.bLength != USB_DT_ENDPOINT_SIZE\n\t\t\t\t|| data->hs_desc.bDescriptorType\n\t\t\t\t\t!= USB_DT_ENDPOINT) {\n\t\t\tDBG(data->dev, \"config %s, bad hs length or type\\n\",\n\t\t\t\t\tdata->name);\n\t\t\tgoto fail0;\n\t\t}\n\t}\n\n\tspin_lock_irq (&data->dev->lock);\n\tif (data->dev->state == STATE_DEV_UNBOUND) {\n\t\tvalue = -ENOENT;\n\t\tgoto gone;\n\t} else {\n\t\tep = data->ep;\n\t\tif (ep == NULL) {\n\t\t\tvalue = -ENODEV;\n\t\t\tgoto gone;\n\t\t}\n\t}\n\tswitch (data->dev->gadget->speed) {\n\tcase USB_SPEED_LOW:\n\tcase USB_SPEED_FULL:\n\t\tep->desc = &data->desc;\n\t\tbreak;\n\tcase USB_SPEED_HIGH:\n\t\t/* fails if caller didn't provide that descriptor... */\n\t\tep->desc = &data->hs_desc;\n\t\tbreak;\n\tdefault:\n\t\tDBG(data->dev, \"unconnected, %s init abandoned\\n\",\n\t\t\t\tdata->name);\n\t\tvalue = -EINVAL;\n\t\tgoto gone;\n\t}\n\tvalue = usb_ep_enable(ep);\n\tif (value == 0) {\n\t\tdata->state = STATE_EP_ENABLED;\n\t\tvalue = length;\n\t}\ngone:\n\tspin_unlock_irq (&data->dev->lock);\n\tif (value < 0) {\nfail:\n\t\tdata->desc.bDescriptorType = 0;\n\t\tdata->hs_desc.bDescriptorType = 0;\n\t}\n\treturn value;\nfail0:\n\tvalue = -EINVAL;\n\tgoto fail;\n}\n\nstatic int\nep_open (struct inode *inode, struct file *fd)\n{\n\tstruct ep_data\t\t*data = inode->i_private;\n\tint\t\t\tvalue = -EBUSY;\n\n\tif (mutex_lock_interruptible(&data->lock) != 0)\n\t\treturn -EINTR;\n\tspin_lock_irq (&data->dev->lock);\n\tif (data->dev->state == STATE_DEV_UNBOUND)\n\t\tvalue = -ENOENT;\n\telse if (data->state == STATE_EP_DISABLED) {\n\t\tvalue = 0;\n\t\tdata->state = STATE_EP_READY;\n\t\tget_ep (data);\n\t\tfd->private_data = data;\n\t\tVDEBUG (data->dev, \"%s ready\\n\", data->name);\n\t} else\n\t\tDBG (data->dev, \"%s state %d\\n\",\n\t\t\tdata->name, data->state);\n\tspin_unlock_irq (&data->dev->lock);\n\tmutex_unlock(&data->lock);\n\treturn value;\n}\n\n/*----------------------------------------------------------------------*/\n\n/* EP0 IMPLEMENTATION can be partly in userspace.\n *\n * Drivers that use this facility receive various events, including\n * control requests the kernel doesn't handle.  Drivers that don't\n * use this facility may be too simple-minded for real applications.\n */\n\nstatic inline void ep0_readable (struct dev_data *dev)\n{\n\twake_up (&dev->wait);\n\tkill_fasync (&dev->fasync, SIGIO, POLL_IN);\n}\n\nstatic void clean_req (struct usb_ep *ep, struct usb_request *req)\n{\n\tstruct dev_data\t\t*dev = ep->driver_data;\n\n\tif (req->buf != dev->rbuf) {\n\t\tkfree(req->buf);\n\t\treq->buf = dev->rbuf;\n\t}\n\treq->complete = epio_complete;\n\tdev->setup_out_ready = 0;\n}\n\nstatic void ep0_complete (struct usb_ep *ep, struct usb_request *req)\n{\n\tstruct dev_data\t\t*dev = ep->driver_data;\n\tunsigned long\t\tflags;\n\tint\t\t\tfree = 1;\n\n\t/* for control OUT, data must still get to userspace */\n\tspin_lock_irqsave(&dev->lock, flags);\n\tif (!dev->setup_in) {\n\t\tdev->setup_out_error = (req->status != 0);\n\t\tif (!dev->setup_out_error)\n\t\t\tfree = 0;\n\t\tdev->setup_out_ready = 1;\n\t\tep0_readable (dev);\n\t}\n\n\t/* clean up as appropriate */\n\tif (free && req->buf != &dev->rbuf)\n\t\tclean_req (ep, req);\n\treq->complete = epio_complete;\n\tspin_unlock_irqrestore(&dev->lock, flags);\n}\n\nstatic int setup_req (struct usb_ep *ep, struct usb_request *req, u16 len)\n{\n\tstruct dev_data\t*dev = ep->driver_data;\n\n\tif (dev->setup_out_ready) {\n\t\tDBG (dev, \"ep0 request busy!\\n\");\n\t\treturn -EBUSY;\n\t}\n\tif (len > sizeof (dev->rbuf))\n\t\treq->buf = kmalloc(len, GFP_ATOMIC);\n\tif (req->buf == NULL) {\n\t\treq->buf = dev->rbuf;\n\t\treturn -ENOMEM;\n\t}\n\treq->complete = ep0_complete;\n\treq->length = len;\n\treq->zero = 0;\n\treturn 0;\n}\n\nstatic ssize_t\nep0_read (struct file *fd, char __user *buf, size_t len, loff_t *ptr)\n{\n\tstruct dev_data\t\t\t*dev = fd->private_data;\n\tssize_t\t\t\t\tretval;\n\tenum ep0_state\t\t\tstate;\n\n\tspin_lock_irq (&dev->lock);\n\tif (dev->state <= STATE_DEV_OPENED) {\n\t\tretval = -EINVAL;\n\t\tgoto done;\n\t}\n\n\t/* report fd mode change before acting on it */\n\tif (dev->setup_abort) {\n\t\tdev->setup_abort = 0;\n\t\tretval = -EIDRM;\n\t\tgoto done;\n\t}\n\n\t/* control DATA stage */\n\tif ((state = dev->state) == STATE_DEV_SETUP) {\n\n\t\tif (dev->setup_in) {\t\t/* stall IN */\n\t\t\tVDEBUG(dev, \"ep0in stall\\n\");\n\t\t\t(void) usb_ep_set_halt (dev->gadget->ep0);\n\t\t\tretval = -EL2HLT;\n\t\t\tdev->state = STATE_DEV_CONNECTED;\n\n\t\t} else if (len == 0) {\t\t/* ack SET_CONFIGURATION etc */\n\t\t\tstruct usb_ep\t\t*ep = dev->gadget->ep0;\n\t\t\tstruct usb_request\t*req = dev->req;\n\n\t\t\tif ((retval = setup_req (ep, req, 0)) == 0) {\n\t\t\t\t++dev->udc_usage;\n\t\t\t\tspin_unlock_irq (&dev->lock);\n\t\t\t\tretval = usb_ep_queue (ep, req, GFP_KERNEL);\n\t\t\t\tspin_lock_irq (&dev->lock);\n\t\t\t\t--dev->udc_usage;\n\t\t\t}\n\t\t\tdev->state = STATE_DEV_CONNECTED;\n\n\t\t\t/* assume that was SET_CONFIGURATION */\n\t\t\tif (dev->current_config) {\n\t\t\t\tunsigned power;\n\n\t\t\t\tif (gadget_is_dualspeed(dev->gadget)\n\t\t\t\t\t\t&& (dev->gadget->speed\n\t\t\t\t\t\t\t== USB_SPEED_HIGH))\n\t\t\t\t\tpower = dev->hs_config->bMaxPower;\n\t\t\t\telse\n\t\t\t\t\tpower = dev->config->bMaxPower;\n\t\t\t\tusb_gadget_vbus_draw(dev->gadget, 2 * power);\n\t\t\t}\n\n\t\t} else {\t\t\t/* collect OUT data */\n\t\t\tif ((fd->f_flags & O_NONBLOCK) != 0\n\t\t\t\t\t&& !dev->setup_out_ready) {\n\t\t\t\tretval = -EAGAIN;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tspin_unlock_irq (&dev->lock);\n\t\t\tretval = wait_event_interruptible (dev->wait,\n\t\t\t\t\tdev->setup_out_ready != 0);\n\n\t\t\t/* FIXME state could change from under us */\n\t\t\tspin_lock_irq (&dev->lock);\n\t\t\tif (retval)\n\t\t\t\tgoto done;\n\n\t\t\tif (dev->state != STATE_DEV_SETUP) {\n\t\t\t\tretval = -ECANCELED;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tdev->state = STATE_DEV_CONNECTED;\n\n\t\t\tif (dev->setup_out_error)\n\t\t\t\tretval = -EIO;\n\t\t\telse {\n\t\t\t\tlen = min (len, (size_t)dev->req->actual);\n\t\t\t\t++dev->udc_usage;\n\t\t\t\tspin_unlock_irq(&dev->lock);\n\t\t\t\tif (copy_to_user (buf, dev->req->buf, len))\n\t\t\t\t\tretval = -EFAULT;\n\t\t\t\telse\n\t\t\t\t\tretval = len;\n\t\t\t\tspin_lock_irq(&dev->lock);\n\t\t\t\t--dev->udc_usage;\n\t\t\t\tclean_req (dev->gadget->ep0, dev->req);\n\t\t\t\t/* NOTE userspace can't yet choose to stall */\n\t\t\t}\n\t\t}\n\t\tgoto done;\n\t}\n\n\t/* else normal: return event data */\n\tif (len < sizeof dev->event [0]) {\n\t\tretval = -EINVAL;\n\t\tgoto done;\n\t}\n\tlen -= len % sizeof (struct usb_gadgetfs_event);\n\tdev->usermode_setup = 1;\n\nscan:\n\t/* return queued events right away */\n\tif (dev->ev_next != 0) {\n\t\tunsigned\t\ti, n;\n\n\t\tn = len / sizeof (struct usb_gadgetfs_event);\n\t\tif (dev->ev_next < n)\n\t\t\tn = dev->ev_next;\n\n\t\t/* ep0 i/o has special semantics during STATE_DEV_SETUP */\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tif (dev->event [i].type == GADGETFS_SETUP) {\n\t\t\t\tdev->state = STATE_DEV_SETUP;\n\t\t\t\tn = i + 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tspin_unlock_irq (&dev->lock);\n\t\tlen = n * sizeof (struct usb_gadgetfs_event);\n\t\tif (copy_to_user (buf, &dev->event, len))\n\t\t\tretval = -EFAULT;\n\t\telse\n\t\t\tretval = len;\n\t\tif (len > 0) {\n\t\t\t/* NOTE this doesn't guard against broken drivers;\n\t\t\t * concurrent ep0 readers may lose events.\n\t\t\t */\n\t\t\tspin_lock_irq (&dev->lock);\n\t\t\tif (dev->ev_next > n) {\n\t\t\t\tmemmove(&dev->event[0], &dev->event[n],\n\t\t\t\t\tsizeof (struct usb_gadgetfs_event)\n\t\t\t\t\t\t* (dev->ev_next - n));\n\t\t\t}\n\t\t\tdev->ev_next -= n;\n\t\t\tspin_unlock_irq (&dev->lock);\n\t\t}\n\t\treturn retval;\n\t}\n\tif (fd->f_flags & O_NONBLOCK) {\n\t\tretval = -EAGAIN;\n\t\tgoto done;\n\t}\n\n\tswitch (state) {\n\tdefault:\n\t\tDBG (dev, \"fail %s, state %d\\n\", __func__, state);\n\t\tretval = -ESRCH;\n\t\tbreak;\n\tcase STATE_DEV_UNCONNECTED:\n\tcase STATE_DEV_CONNECTED:\n\t\tspin_unlock_irq (&dev->lock);\n\t\tDBG (dev, \"%s wait\\n\", __func__);\n\n\t\t/* wait for events */\n\t\tretval = wait_event_interruptible (dev->wait,\n\t\t\t\tdev->ev_next != 0);\n\t\tif (retval < 0)\n\t\t\treturn retval;\n\t\tspin_lock_irq (&dev->lock);\n\t\tgoto scan;\n\t}\n\ndone:\n\tspin_unlock_irq (&dev->lock);\n\treturn retval;\n}\n\nstatic struct usb_gadgetfs_event *\nnext_event (struct dev_data *dev, enum usb_gadgetfs_event_type type)\n{\n\tstruct usb_gadgetfs_event\t*event;\n\tunsigned\t\t\ti;\n\n\tswitch (type) {\n\t/* these events purge the queue */\n\tcase GADGETFS_DISCONNECT:\n\t\tif (dev->state == STATE_DEV_SETUP)\n\t\t\tdev->setup_abort = 1;\n\t\tfallthrough;\n\tcase GADGETFS_CONNECT:\n\t\tdev->ev_next = 0;\n\t\tbreak;\n\tcase GADGETFS_SETUP:\t\t/* previous request timed out */\n\tcase GADGETFS_SUSPEND:\t\t/* same effect */\n\t\t/* these events can't be repeated */\n\t\tfor (i = 0; i != dev->ev_next; i++) {\n\t\t\tif (dev->event [i].type != type)\n\t\t\t\tcontinue;\n\t\t\tDBG(dev, \"discard old event[%d] %d\\n\", i, type);\n\t\t\tdev->ev_next--;\n\t\t\tif (i == dev->ev_next)\n\t\t\t\tbreak;\n\t\t\t/* indices start at zero, for simplicity */\n\t\t\tmemmove (&dev->event [i], &dev->event [i + 1],\n\t\t\t\tsizeof (struct usb_gadgetfs_event)\n\t\t\t\t\t* (dev->ev_next - i));\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tBUG ();\n\t}\n\tVDEBUG(dev, \"event[%d] = %d\\n\", dev->ev_next, type);\n\tevent = &dev->event [dev->ev_next++];\n\tBUG_ON (dev->ev_next > N_EVENT);\n\tmemset (event, 0, sizeof *event);\n\tevent->type = type;\n\treturn event;\n}\n\nstatic ssize_t\nep0_write (struct file *fd, const char __user *buf, size_t len, loff_t *ptr)\n{\n\tstruct dev_data\t\t*dev = fd->private_data;\n\tssize_t\t\t\tretval = -ESRCH;\n\n\t/* report fd mode change before acting on it */\n\tif (dev->setup_abort) {\n\t\tdev->setup_abort = 0;\n\t\tretval = -EIDRM;\n\n\t/* data and/or status stage for control request */\n\t} else if (dev->state == STATE_DEV_SETUP) {\n\n\t\tlen = min_t(size_t, len, dev->setup_wLength);\n\t\tif (dev->setup_in) {\n\t\t\tretval = setup_req (dev->gadget->ep0, dev->req, len);\n\t\t\tif (retval == 0) {\n\t\t\t\tdev->state = STATE_DEV_CONNECTED;\n\t\t\t\t++dev->udc_usage;\n\t\t\t\tspin_unlock_irq (&dev->lock);\n\t\t\t\tif (copy_from_user (dev->req->buf, buf, len))\n\t\t\t\t\tretval = -EFAULT;\n\t\t\t\telse {\n\t\t\t\t\tif (len < dev->setup_wLength)\n\t\t\t\t\t\tdev->req->zero = 1;\n\t\t\t\t\tretval = usb_ep_queue (\n\t\t\t\t\t\tdev->gadget->ep0, dev->req,\n\t\t\t\t\t\tGFP_KERNEL);\n\t\t\t\t}\n\t\t\t\tspin_lock_irq(&dev->lock);\n\t\t\t\t--dev->udc_usage;\n\t\t\t\tif (retval < 0) {\n\t\t\t\t\tclean_req (dev->gadget->ep0, dev->req);\n\t\t\t\t} else\n\t\t\t\t\tretval = len;\n\n\t\t\t\treturn retval;\n\t\t\t}\n\n\t\t/* can stall some OUT transfers */\n\t\t} else if (dev->setup_can_stall) {\n\t\t\tVDEBUG(dev, \"ep0out stall\\n\");\n\t\t\t(void) usb_ep_set_halt (dev->gadget->ep0);\n\t\t\tretval = -EL2HLT;\n\t\t\tdev->state = STATE_DEV_CONNECTED;\n\t\t} else {\n\t\t\tDBG(dev, \"bogus ep0out stall!\\n\");\n\t\t}\n\t} else\n\t\tDBG (dev, \"fail %s, state %d\\n\", __func__, dev->state);\n\n\treturn retval;\n}\n\nstatic int\nep0_fasync (int f, struct file *fd, int on)\n{\n\tstruct dev_data\t\t*dev = fd->private_data;\n\t// caller must F_SETOWN before signal delivery happens\n\tVDEBUG (dev, \"%s %s\\n\", __func__, on ? \"on\" : \"off\");\n\treturn fasync_helper (f, fd, on, &dev->fasync);\n}\n\nstatic struct usb_gadget_driver gadgetfs_driver;\n\nstatic int\ndev_release (struct inode *inode, struct file *fd)\n{\n\tstruct dev_data\t\t*dev = fd->private_data;\n\n\t/* closing ep0 === shutdown all */\n\n\tif (dev->gadget_registered) {\n\t\tusb_gadget_unregister_driver (&gadgetfs_driver);\n\t\tdev->gadget_registered = false;\n\t}\n\n\t/* at this point \"good\" hardware has disconnected the\n\t * device from USB; the host won't see it any more.\n\t * alternatively, all host requests will time out.\n\t */\n\n\tkfree (dev->buf);\n\tdev->buf = NULL;\n\n\t/* other endpoints were all decoupled from this device */\n\tspin_lock_irq(&dev->lock);\n\tdev->state = STATE_DEV_DISABLED;\n\tspin_unlock_irq(&dev->lock);\n\n\tput_dev (dev);\n\treturn 0;\n}\n\nstatic __poll_t\nep0_poll (struct file *fd, poll_table *wait)\n{\n\tstruct dev_data         *dev = fd->private_data;\n\t__poll_t                mask = 0;\n\n\tif (dev->state <= STATE_DEV_OPENED)\n\t\treturn DEFAULT_POLLMASK;\n\n\tpoll_wait(fd, &dev->wait, wait);\n\n\tspin_lock_irq(&dev->lock);\n\n\t/* report fd mode change before acting on it */\n\tif (dev->setup_abort) {\n\t\tdev->setup_abort = 0;\n\t\tmask = EPOLLHUP;\n\t\tgoto out;\n\t}\n\n\tif (dev->state == STATE_DEV_SETUP) {\n\t\tif (dev->setup_in || dev->setup_can_stall)\n\t\t\tmask = EPOLLOUT;\n\t} else {\n\t\tif (dev->ev_next != 0)\n\t\t\tmask = EPOLLIN;\n\t}\nout:\n\tspin_unlock_irq(&dev->lock);\n\treturn mask;\n}\n\nstatic long dev_ioctl (struct file *fd, unsigned code, unsigned long value)\n{\n\tstruct dev_data\t\t*dev = fd->private_data;\n\tstruct usb_gadget\t*gadget = dev->gadget;\n\tlong ret = -ENOTTY;\n\n\tspin_lock_irq(&dev->lock);\n\tif (dev->state == STATE_DEV_OPENED ||\n\t\t\tdev->state == STATE_DEV_UNBOUND) {\n\t\t/* Not bound to a UDC */\n\t} else if (gadget->ops->ioctl) {\n\t\t++dev->udc_usage;\n\t\tspin_unlock_irq(&dev->lock);\n\n\t\tret = gadget->ops->ioctl (gadget, code, value);\n\n\t\tspin_lock_irq(&dev->lock);\n\t\t--dev->udc_usage;\n\t}\n\tspin_unlock_irq(&dev->lock);\n\n\treturn ret;\n}\n\n/*----------------------------------------------------------------------*/\n\n/* The in-kernel gadget driver handles most ep0 issues, in particular\n * enumerating the single configuration (as provided from user space).\n *\n * Unrecognized ep0 requests may be handled in user space.\n */\n\nstatic void make_qualifier (struct dev_data *dev)\n{\n\tstruct usb_qualifier_descriptor\t\tqual;\n\tstruct usb_device_descriptor\t\t*desc;\n\n\tqual.bLength = sizeof qual;\n\tqual.bDescriptorType = USB_DT_DEVICE_QUALIFIER;\n\tqual.bcdUSB = cpu_to_le16 (0x0200);\n\n\tdesc = dev->dev;\n\tqual.bDeviceClass = desc->bDeviceClass;\n\tqual.bDeviceSubClass = desc->bDeviceSubClass;\n\tqual.bDeviceProtocol = desc->bDeviceProtocol;\n\n\t/* assumes ep0 uses the same value for both speeds ... */\n\tqual.bMaxPacketSize0 = dev->gadget->ep0->maxpacket;\n\n\tqual.bNumConfigurations = 1;\n\tqual.bRESERVED = 0;\n\n\tmemcpy (dev->rbuf, &qual, sizeof qual);\n}\n\nstatic int\nconfig_buf (struct dev_data *dev, u8 type, unsigned index)\n{\n\tint\t\tlen;\n\tint\t\ths = 0;\n\n\t/* only one configuration */\n\tif (index > 0)\n\t\treturn -EINVAL;\n\n\tif (gadget_is_dualspeed(dev->gadget)) {\n\t\ths = (dev->gadget->speed == USB_SPEED_HIGH);\n\t\tif (type == USB_DT_OTHER_SPEED_CONFIG)\n\t\t\ths = !hs;\n\t}\n\tif (hs) {\n\t\tdev->req->buf = dev->hs_config;\n\t\tlen = le16_to_cpu(dev->hs_config->wTotalLength);\n\t} else {\n\t\tdev->req->buf = dev->config;\n\t\tlen = le16_to_cpu(dev->config->wTotalLength);\n\t}\n\t((u8 *)dev->req->buf) [1] = type;\n\treturn len;\n}\n\nstatic int\ngadgetfs_setup (struct usb_gadget *gadget, const struct usb_ctrlrequest *ctrl)\n{\n\tstruct dev_data\t\t\t*dev = get_gadget_data (gadget);\n\tstruct usb_request\t\t*req = dev->req;\n\tint\t\t\t\tvalue = -EOPNOTSUPP;\n\tstruct usb_gadgetfs_event\t*event;\n\tu16\t\t\t\tw_value = le16_to_cpu(ctrl->wValue);\n\tu16\t\t\t\tw_length = le16_to_cpu(ctrl->wLength);\n\n\tif (w_length > RBUF_SIZE) {\n\t\tif (ctrl->bRequestType & USB_DIR_IN) {\n\t\t\t/* Cast away the const, we are going to overwrite on purpose. */\n\t\t\t__le16 *temp = (__le16 *)&ctrl->wLength;\n\n\t\t\t*temp = cpu_to_le16(RBUF_SIZE);\n\t\t\tw_length = RBUF_SIZE;\n\t\t} else {\n\t\t\treturn value;\n\t\t}\n\t}\n\n\tspin_lock (&dev->lock);\n\tdev->setup_abort = 0;\n\tif (dev->state == STATE_DEV_UNCONNECTED) {\n\t\tif (gadget_is_dualspeed(gadget)\n\t\t\t\t&& gadget->speed == USB_SPEED_HIGH\n\t\t\t\t&& dev->hs_config == NULL) {\n\t\t\tspin_unlock(&dev->lock);\n\t\t\tERROR (dev, \"no high speed config??\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tdev->state = STATE_DEV_CONNECTED;\n\n\t\tINFO (dev, \"connected\\n\");\n\t\tevent = next_event (dev, GADGETFS_CONNECT);\n\t\tevent->u.speed = gadget->speed;\n\t\tep0_readable (dev);\n\n\t/* host may have given up waiting for response.  we can miss control\n\t * requests handled lower down (device/endpoint status and features);\n\t * then ep0_{read,write} will report the wrong status. controller\n\t * driver will have aborted pending i/o.\n\t */\n\t} else if (dev->state == STATE_DEV_SETUP)\n\t\tdev->setup_abort = 1;\n\n\treq->buf = dev->rbuf;\n\treq->context = NULL;\n\tswitch (ctrl->bRequest) {\n\n\tcase USB_REQ_GET_DESCRIPTOR:\n\t\tif (ctrl->bRequestType != USB_DIR_IN)\n\t\t\tgoto unrecognized;\n\t\tswitch (w_value >> 8) {\n\n\t\tcase USB_DT_DEVICE:\n\t\t\tvalue = min (w_length, (u16) sizeof *dev->dev);\n\t\t\tdev->dev->bMaxPacketSize0 = dev->gadget->ep0->maxpacket;\n\t\t\treq->buf = dev->dev;\n\t\t\tbreak;\n\t\tcase USB_DT_DEVICE_QUALIFIER:\n\t\t\tif (!dev->hs_config)\n\t\t\t\tbreak;\n\t\t\tvalue = min (w_length, (u16)\n\t\t\t\tsizeof (struct usb_qualifier_descriptor));\n\t\t\tmake_qualifier (dev);\n\t\t\tbreak;\n\t\tcase USB_DT_OTHER_SPEED_CONFIG:\n\t\tcase USB_DT_CONFIG:\n\t\t\tvalue = config_buf (dev,\n\t\t\t\t\tw_value >> 8,\n\t\t\t\t\tw_value & 0xff);\n\t\t\tif (value >= 0)\n\t\t\t\tvalue = min (w_length, (u16) value);\n\t\t\tbreak;\n\t\tcase USB_DT_STRING:\n\t\t\tgoto unrecognized;\n\n\t\tdefault:\t\t// all others are errors\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\t/* currently one config, two speeds */\n\tcase USB_REQ_SET_CONFIGURATION:\n\t\tif (ctrl->bRequestType != 0)\n\t\t\tgoto unrecognized;\n\t\tif (0 == (u8) w_value) {\n\t\t\tvalue = 0;\n\t\t\tdev->current_config = 0;\n\t\t\tusb_gadget_vbus_draw(gadget, 8 /* mA */ );\n\t\t\t// user mode expected to disable endpoints\n\t\t} else {\n\t\t\tu8\tconfig, power;\n\n\t\t\tif (gadget_is_dualspeed(gadget)\n\t\t\t\t\t&& gadget->speed == USB_SPEED_HIGH) {\n\t\t\t\tconfig = dev->hs_config->bConfigurationValue;\n\t\t\t\tpower = dev->hs_config->bMaxPower;\n\t\t\t} else {\n\t\t\t\tconfig = dev->config->bConfigurationValue;\n\t\t\t\tpower = dev->config->bMaxPower;\n\t\t\t}\n\n\t\t\tif (config == (u8) w_value) {\n\t\t\t\tvalue = 0;\n\t\t\t\tdev->current_config = config;\n\t\t\t\tusb_gadget_vbus_draw(gadget, 2 * power);\n\t\t\t}\n\t\t}\n\n\t\t/* report SET_CONFIGURATION like any other control request,\n\t\t * except that usermode may not stall this.  the next\n\t\t * request mustn't be allowed start until this finishes:\n\t\t * endpoints and threads set up, etc.\n\t\t *\n\t\t * NOTE:  older PXA hardware (before PXA 255: without UDCCFR)\n\t\t * has bad/racey automagic that prevents synchronizing here.\n\t\t * even kernel mode drivers often miss them.\n\t\t */\n\t\tif (value == 0) {\n\t\t\tINFO (dev, \"configuration #%d\\n\", dev->current_config);\n\t\t\tusb_gadget_set_state(gadget, USB_STATE_CONFIGURED);\n\t\t\tif (dev->usermode_setup) {\n\t\t\t\tdev->setup_can_stall = 0;\n\t\t\t\tgoto delegate;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n#ifndef\tCONFIG_USB_PXA25X\n\t/* PXA automagically handles this request too */\n\tcase USB_REQ_GET_CONFIGURATION:\n\t\tif (ctrl->bRequestType != 0x80)\n\t\t\tgoto unrecognized;\n\t\t*(u8 *)req->buf = dev->current_config;\n\t\tvalue = min (w_length, (u16) 1);\n\t\tbreak;\n#endif\n\n\tdefault:\nunrecognized:\n\t\tVDEBUG (dev, \"%s req%02x.%02x v%04x i%04x l%d\\n\",\n\t\t\tdev->usermode_setup ? \"delegate\" : \"fail\",\n\t\t\tctrl->bRequestType, ctrl->bRequest,\n\t\t\tw_value, le16_to_cpu(ctrl->wIndex), w_length);\n\n\t\t/* if there's an ep0 reader, don't stall */\n\t\tif (dev->usermode_setup) {\n\t\t\tdev->setup_can_stall = 1;\ndelegate:\n\t\t\tdev->setup_in = (ctrl->bRequestType & USB_DIR_IN)\n\t\t\t\t\t\t? 1 : 0;\n\t\t\tdev->setup_wLength = w_length;\n\t\t\tdev->setup_out_ready = 0;\n\t\t\tdev->setup_out_error = 0;\n\n\t\t\t/* read DATA stage for OUT right away */\n\t\t\tif (unlikely (!dev->setup_in && w_length)) {\n\t\t\t\tvalue = setup_req (gadget->ep0, dev->req,\n\t\t\t\t\t\t\tw_length);\n\t\t\t\tif (value < 0)\n\t\t\t\t\tbreak;\n\n\t\t\t\t++dev->udc_usage;\n\t\t\t\tspin_unlock (&dev->lock);\n\t\t\t\tvalue = usb_ep_queue (gadget->ep0, dev->req,\n\t\t\t\t\t\t\tGFP_KERNEL);\n\t\t\t\tspin_lock (&dev->lock);\n\t\t\t\t--dev->udc_usage;\n\t\t\t\tif (value < 0) {\n\t\t\t\t\tclean_req (gadget->ep0, dev->req);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t/* we can't currently stall these */\n\t\t\t\tdev->setup_can_stall = 0;\n\t\t\t}\n\n\t\t\t/* state changes when reader collects event */\n\t\t\tevent = next_event (dev, GADGETFS_SETUP);\n\t\t\tevent->u.setup = *ctrl;\n\t\t\tep0_readable (dev);\n\t\t\tspin_unlock (&dev->lock);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/* proceed with data transfer and status phases? */\n\tif (value >= 0 && dev->state != STATE_DEV_SETUP) {\n\t\treq->length = value;\n\t\treq->zero = value < w_length;\n\n\t\t++dev->udc_usage;\n\t\tspin_unlock (&dev->lock);\n\t\tvalue = usb_ep_queue (gadget->ep0, req, GFP_KERNEL);\n\t\tspin_lock(&dev->lock);\n\t\t--dev->udc_usage;\n\t\tspin_unlock(&dev->lock);\n\t\tif (value < 0) {\n\t\t\tDBG (dev, \"ep_queue --> %d\\n\", value);\n\t\t\treq->status = 0;\n\t\t}\n\t\treturn value;\n\t}\n\n\t/* device stalls when value < 0 */\n\tspin_unlock (&dev->lock);\n\treturn value;\n}\n\nstatic void destroy_ep_files (struct dev_data *dev)\n{\n\tDBG (dev, \"%s %d\\n\", __func__, dev->state);\n\n\t/* dev->state must prevent interference */\n\tspin_lock_irq (&dev->lock);\n\twhile (!list_empty(&dev->epfiles)) {\n\t\tstruct ep_data\t*ep;\n\t\tstruct inode\t*parent;\n\t\tstruct dentry\t*dentry;\n\n\t\t/* break link to FS */\n\t\tep = list_first_entry (&dev->epfiles, struct ep_data, epfiles);\n\t\tlist_del_init (&ep->epfiles);\n\t\tspin_unlock_irq (&dev->lock);\n\n\t\tdentry = ep->dentry;\n\t\tep->dentry = NULL;\n\t\tparent = d_inode(dentry->d_parent);\n\n\t\t/* break link to controller */\n\t\tmutex_lock(&ep->lock);\n\t\tif (ep->state == STATE_EP_ENABLED)\n\t\t\t(void) usb_ep_disable (ep->ep);\n\t\tep->state = STATE_EP_UNBOUND;\n\t\tusb_ep_free_request (ep->ep, ep->req);\n\t\tep->ep = NULL;\n\t\tmutex_unlock(&ep->lock);\n\n\t\twake_up (&ep->wait);\n\t\tput_ep (ep);\n\n\t\t/* break link to dcache */\n\t\tinode_lock(parent);\n\t\td_delete (dentry);\n\t\tdput (dentry);\n\t\tinode_unlock(parent);\n\n\t\tspin_lock_irq (&dev->lock);\n\t}\n\tspin_unlock_irq (&dev->lock);\n}\n\n\nstatic struct dentry *\ngadgetfs_create_file (struct super_block *sb, char const *name,\n\t\tvoid *data, const struct file_operations *fops);\n\nstatic int activate_ep_files (struct dev_data *dev)\n{\n\tstruct usb_ep\t*ep;\n\tstruct ep_data\t*data;\n\n\tgadget_for_each_ep (ep, dev->gadget) {\n\n\t\tdata = kzalloc(sizeof(*data), GFP_KERNEL);\n\t\tif (!data)\n\t\t\tgoto enomem0;\n\t\tdata->state = STATE_EP_DISABLED;\n\t\tmutex_init(&data->lock);\n\t\tinit_waitqueue_head (&data->wait);\n\n\t\tstrncpy (data->name, ep->name, sizeof (data->name) - 1);\n\t\trefcount_set (&data->count, 1);\n\t\tdata->dev = dev;\n\t\tget_dev (dev);\n\n\t\tdata->ep = ep;\n\t\tep->driver_data = data;\n\n\t\tdata->req = usb_ep_alloc_request (ep, GFP_KERNEL);\n\t\tif (!data->req)\n\t\t\tgoto enomem1;\n\n\t\tdata->dentry = gadgetfs_create_file (dev->sb, data->name,\n\t\t\t\tdata, &ep_io_operations);\n\t\tif (!data->dentry)\n\t\t\tgoto enomem2;\n\t\tlist_add_tail (&data->epfiles, &dev->epfiles);\n\t}\n\treturn 0;\n\nenomem2:\n\tusb_ep_free_request (ep, data->req);\nenomem1:\n\tput_dev (dev);\n\tkfree (data);\nenomem0:\n\tDBG (dev, \"%s enomem\\n\", __func__);\n\tdestroy_ep_files (dev);\n\treturn -ENOMEM;\n}\n\nstatic void\ngadgetfs_unbind (struct usb_gadget *gadget)\n{\n\tstruct dev_data\t\t*dev = get_gadget_data (gadget);\n\n\tDBG (dev, \"%s\\n\", __func__);\n\n\tspin_lock_irq (&dev->lock);\n\tdev->state = STATE_DEV_UNBOUND;\n\twhile (dev->udc_usage > 0) {\n\t\tspin_unlock_irq(&dev->lock);\n\t\tusleep_range(1000, 2000);\n\t\tspin_lock_irq(&dev->lock);\n\t}\n\tspin_unlock_irq (&dev->lock);\n\n\tdestroy_ep_files (dev);\n\tgadget->ep0->driver_data = NULL;\n\tset_gadget_data (gadget, NULL);\n\n\t/* we've already been disconnected ... no i/o is active */\n\tif (dev->req)\n\t\tusb_ep_free_request (gadget->ep0, dev->req);\n\tDBG (dev, \"%s done\\n\", __func__);\n\tput_dev (dev);\n}\n\nstatic struct dev_data\t\t*the_device;\n\nstatic int gadgetfs_bind(struct usb_gadget *gadget,\n\t\tstruct usb_gadget_driver *driver)\n{\n\tstruct dev_data\t\t*dev = the_device;\n\n\tif (!dev)\n\t\treturn -ESRCH;\n\tif (0 != strcmp (CHIP, gadget->name)) {\n\t\tpr_err(\"%s expected %s controller not %s\\n\",\n\t\t\tshortname, CHIP, gadget->name);\n\t\treturn -ENODEV;\n\t}\n\n\tset_gadget_data (gadget, dev);\n\tdev->gadget = gadget;\n\tgadget->ep0->driver_data = dev;\n\n\t/* preallocate control response and buffer */\n\tdev->req = usb_ep_alloc_request (gadget->ep0, GFP_KERNEL);\n\tif (!dev->req)\n\t\tgoto enomem;\n\tdev->req->context = NULL;\n\tdev->req->complete = epio_complete;\n\n\tif (activate_ep_files (dev) < 0)\n\t\tgoto enomem;\n\n\tINFO (dev, \"bound to %s driver\\n\", gadget->name);\n\tspin_lock_irq(&dev->lock);\n\tdev->state = STATE_DEV_UNCONNECTED;\n\tspin_unlock_irq(&dev->lock);\n\tget_dev (dev);\n\treturn 0;\n\nenomem:\n\tgadgetfs_unbind (gadget);\n\treturn -ENOMEM;\n}\n\nstatic void\ngadgetfs_disconnect (struct usb_gadget *gadget)\n{\n\tstruct dev_data\t\t*dev = get_gadget_data (gadget);\n\tunsigned long\t\tflags;\n\n\tspin_lock_irqsave (&dev->lock, flags);\n\tif (dev->state == STATE_DEV_UNCONNECTED)\n\t\tgoto exit;\n\tdev->state = STATE_DEV_UNCONNECTED;\n\n\tINFO (dev, \"disconnected\\n\");\n\tnext_event (dev, GADGETFS_DISCONNECT);\n\tep0_readable (dev);\nexit:\n\tspin_unlock_irqrestore (&dev->lock, flags);\n}\n\nstatic void\ngadgetfs_suspend (struct usb_gadget *gadget)\n{\n\tstruct dev_data\t\t*dev = get_gadget_data (gadget);\n\tunsigned long\t\tflags;\n\n\tINFO (dev, \"suspended from state %d\\n\", dev->state);\n\tspin_lock_irqsave(&dev->lock, flags);\n\tswitch (dev->state) {\n\tcase STATE_DEV_SETUP:\t\t// VERY odd... host died??\n\tcase STATE_DEV_CONNECTED:\n\tcase STATE_DEV_UNCONNECTED:\n\t\tnext_event (dev, GADGETFS_SUSPEND);\n\t\tep0_readable (dev);\n\t\tfallthrough;\n\tdefault:\n\t\tbreak;\n\t}\n\tspin_unlock_irqrestore(&dev->lock, flags);\n}\n\nstatic struct usb_gadget_driver gadgetfs_driver = {\n\t.function\t= (char *) driver_desc,\n\t.bind\t\t= gadgetfs_bind,\n\t.unbind\t\t= gadgetfs_unbind,\n\t.setup\t\t= gadgetfs_setup,\n\t.reset\t\t= gadgetfs_disconnect,\n\t.disconnect\t= gadgetfs_disconnect,\n\t.suspend\t= gadgetfs_suspend,\n\n\t.driver\t= {\n\t\t.name\t\t= shortname,\n\t},\n};\n\n/*----------------------------------------------------------------------*/\n/* DEVICE INITIALIZATION\n *\n *     fd = open (\"/dev/gadget/$CHIP\", O_RDWR)\n *     status = write (fd, descriptors, sizeof descriptors)\n *\n * That write establishes the device configuration, so the kernel can\n * bind to the controller ... guaranteeing it can handle enumeration\n * at all necessary speeds.  Descriptor order is:\n *\n * . message tag (u32, host order) ... for now, must be zero; it\n *\twould change to support features like multi-config devices\n * . full/low speed config ... all wTotalLength bytes (with interface,\n *\tclass, altsetting, endpoint, and other descriptors)\n * . high speed config ... all descriptors, for high speed operation;\n *\tthis one's optional except for high-speed hardware\n * . device descriptor\n *\n * Endpoints are not yet enabled. Drivers must wait until device\n * configuration and interface altsetting changes create\n * the need to configure (or unconfigure) them.\n *\n * After initialization, the device stays active for as long as that\n * $CHIP file is open.  Events must then be read from that descriptor,\n * such as configuration notifications.\n */\n\nstatic int is_valid_config(struct usb_config_descriptor *config,\n\t\tunsigned int total)\n{\n\treturn config->bDescriptorType == USB_DT_CONFIG\n\t\t&& config->bLength == USB_DT_CONFIG_SIZE\n\t\t&& total >= USB_DT_CONFIG_SIZE\n\t\t&& config->bConfigurationValue != 0\n\t\t&& (config->bmAttributes & USB_CONFIG_ATT_ONE) != 0\n\t\t&& (config->bmAttributes & USB_CONFIG_ATT_WAKEUP) == 0;\n\t/* FIXME if gadget->is_otg, _must_ include an otg descriptor */\n\t/* FIXME check lengths: walk to end */\n}\n\nstatic ssize_t\ndev_config (struct file *fd, const char __user *buf, size_t len, loff_t *ptr)\n{\n\tstruct dev_data\t\t*dev = fd->private_data;\n\tssize_t\t\t\tvalue, length = len;\n\tunsigned\t\ttotal;\n\tu32\t\t\ttag;\n\tchar\t\t\t*kbuf;\n\n\tspin_lock_irq(&dev->lock);\n\tif (dev->state > STATE_DEV_OPENED) {\n\t\tvalue = ep0_write(fd, buf, len, ptr);\n\t\tspin_unlock_irq(&dev->lock);\n\t\treturn value;\n\t}\n\tspin_unlock_irq(&dev->lock);\n\n\tif ((len < (USB_DT_CONFIG_SIZE + USB_DT_DEVICE_SIZE + 4)) ||\n\t    (len > PAGE_SIZE * 4))\n\t\treturn -EINVAL;\n\n\t/* we might need to change message format someday */\n\tif (copy_from_user (&tag, buf, 4))\n\t\treturn -EFAULT;\n\tif (tag != 0)\n\t\treturn -EINVAL;\n\tbuf += 4;\n\tlength -= 4;\n\n\tkbuf = memdup_user(buf, length);\n\tif (IS_ERR(kbuf))\n\t\treturn PTR_ERR(kbuf);\n\n\tspin_lock_irq (&dev->lock);\n\tvalue = -EINVAL;\n\tif (dev->buf) {\n\t\tspin_unlock_irq(&dev->lock);\n\t\tkfree(kbuf);\n\t\treturn value;\n\t}\n\tdev->buf = kbuf;\n\n\t/* full or low speed config */\n\tdev->config = (void *) kbuf;\n\ttotal = le16_to_cpu(dev->config->wTotalLength);\n\tif (!is_valid_config(dev->config, total) ||\n\t\t\ttotal > length - USB_DT_DEVICE_SIZE)\n\t\tgoto fail;\n\tkbuf += total;\n\tlength -= total;\n\n\t/* optional high speed config */\n\tif (kbuf [1] == USB_DT_CONFIG) {\n\t\tdev->hs_config = (void *) kbuf;\n\t\ttotal = le16_to_cpu(dev->hs_config->wTotalLength);\n\t\tif (!is_valid_config(dev->hs_config, total) ||\n\t\t\t\ttotal > length - USB_DT_DEVICE_SIZE)\n\t\t\tgoto fail;\n\t\tkbuf += total;\n\t\tlength -= total;\n\t} else {\n\t\tdev->hs_config = NULL;\n\t}\n\n\t/* could support multiple configs, using another encoding! */\n\n\t/* device descriptor (tweaked for paranoia) */\n\tif (length != USB_DT_DEVICE_SIZE)\n\t\tgoto fail;\n\tdev->dev = (void *)kbuf;\n\tif (dev->dev->bLength != USB_DT_DEVICE_SIZE\n\t\t\t|| dev->dev->bDescriptorType != USB_DT_DEVICE\n\t\t\t|| dev->dev->bNumConfigurations != 1)\n\t\tgoto fail;\n\tdev->dev->bcdUSB = cpu_to_le16 (0x0200);\n\n\t/* triggers gadgetfs_bind(); then we can enumerate. */\n\tspin_unlock_irq (&dev->lock);\n\tif (dev->hs_config)\n\t\tgadgetfs_driver.max_speed = USB_SPEED_HIGH;\n\telse\n\t\tgadgetfs_driver.max_speed = USB_SPEED_FULL;\n\n\tvalue = usb_gadget_probe_driver(&gadgetfs_driver);\n\tif (value != 0) {\n\t\tspin_lock_irq(&dev->lock);\n\t\tgoto fail;\n\t} else {\n\t\t/* at this point \"good\" hardware has for the first time\n\t\t * let the USB the host see us.  alternatively, if users\n\t\t * unplug/replug that will clear all the error state.\n\t\t *\n\t\t * note:  everything running before here was guaranteed\n\t\t * to choke driver model style diagnostics.  from here\n\t\t * on, they can work ... except in cleanup paths that\n\t\t * kick in after the ep0 descriptor is closed.\n\t\t */\n\t\tvalue = len;\n\t\tdev->gadget_registered = true;\n\t}\n\treturn value;\n\nfail:\n\tdev->config = NULL;\n\tdev->hs_config = NULL;\n\tdev->dev = NULL;\n\tspin_unlock_irq (&dev->lock);\n\tpr_debug (\"%s: %s fail %zd, %p\\n\", shortname, __func__, value, dev);\n\tkfree (dev->buf);\n\tdev->buf = NULL;\n\treturn value;\n}\n\nstatic int\ndev_open (struct inode *inode, struct file *fd)\n{\n\tstruct dev_data\t\t*dev = inode->i_private;\n\tint\t\t\tvalue = -EBUSY;\n\n\tspin_lock_irq(&dev->lock);\n\tif (dev->state == STATE_DEV_DISABLED) {\n\t\tdev->ev_next = 0;\n\t\tdev->state = STATE_DEV_OPENED;\n\t\tfd->private_data = dev;\n\t\tget_dev (dev);\n\t\tvalue = 0;\n\t}\n\tspin_unlock_irq(&dev->lock);\n\treturn value;\n}\n\nstatic const struct file_operations ep0_operations = {\n\t.llseek =\tno_llseek,\n\n\t.open =\t\tdev_open,\n\t.read =\t\tep0_read,\n\t.write =\tdev_config,\n\t.fasync =\tep0_fasync,\n\t.poll =\t\tep0_poll,\n\t.unlocked_ioctl = dev_ioctl,\n\t.release =\tdev_release,\n};\n\n/*----------------------------------------------------------------------*/\n\n/* FILESYSTEM AND SUPERBLOCK OPERATIONS\n *\n * Mounting the filesystem creates a controller file, used first for\n * device configuration then later for event monitoring.\n */\n\n\n/* FIXME PAM etc could set this security policy without mount options\n * if epfiles inherited ownership and permissons from ep0 ...\n */\n\nstatic unsigned default_uid;\nstatic unsigned default_gid;\nstatic unsigned default_perm = S_IRUSR | S_IWUSR;\n\nmodule_param (default_uid, uint, 0644);\nmodule_param (default_gid, uint, 0644);\nmodule_param (default_perm, uint, 0644);\n\n\nstatic struct inode *\ngadgetfs_make_inode (struct super_block *sb,\n\t\tvoid *data, const struct file_operations *fops,\n\t\tint mode)\n{\n\tstruct inode *inode = new_inode (sb);\n\n\tif (inode) {\n\t\tinode->i_ino = get_next_ino();\n\t\tinode->i_mode = mode;\n\t\tinode->i_uid = make_kuid(&init_user_ns, default_uid);\n\t\tinode->i_gid = make_kgid(&init_user_ns, default_gid);\n\t\tinode->i_atime = inode->i_mtime = inode->i_ctime\n\t\t\t\t= current_time(inode);\n\t\tinode->i_private = data;\n\t\tinode->i_fop = fops;\n\t}\n\treturn inode;\n}\n\n/* creates in fs root directory, so non-renamable and non-linkable.\n * so inode and dentry are paired, until device reconfig.\n */\nstatic struct dentry *\ngadgetfs_create_file (struct super_block *sb, char const *name,\n\t\tvoid *data, const struct file_operations *fops)\n{\n\tstruct dentry\t*dentry;\n\tstruct inode\t*inode;\n\n\tdentry = d_alloc_name(sb->s_root, name);\n\tif (!dentry)\n\t\treturn NULL;\n\n\tinode = gadgetfs_make_inode (sb, data, fops,\n\t\t\tS_IFREG | (default_perm & S_IRWXUGO));\n\tif (!inode) {\n\t\tdput(dentry);\n\t\treturn NULL;\n\t}\n\td_add (dentry, inode);\n\treturn dentry;\n}\n\nstatic const struct super_operations gadget_fs_operations = {\n\t.statfs =\tsimple_statfs,\n\t.drop_inode =\tgeneric_delete_inode,\n};\n\nstatic int\ngadgetfs_fill_super (struct super_block *sb, struct fs_context *fc)\n{\n\tstruct inode\t*inode;\n\tstruct dev_data\t*dev;\n\n\tif (the_device)\n\t\treturn -ESRCH;\n\n\tCHIP = usb_get_gadget_udc_name();\n\tif (!CHIP)\n\t\treturn -ENODEV;\n\n\t/* superblock */\n\tsb->s_blocksize = PAGE_SIZE;\n\tsb->s_blocksize_bits = PAGE_SHIFT;\n\tsb->s_magic = GADGETFS_MAGIC;\n\tsb->s_op = &gadget_fs_operations;\n\tsb->s_time_gran = 1;\n\n\t/* root inode */\n\tinode = gadgetfs_make_inode (sb,\n\t\t\tNULL, &simple_dir_operations,\n\t\t\tS_IFDIR | S_IRUGO | S_IXUGO);\n\tif (!inode)\n\t\tgoto Enomem;\n\tinode->i_op = &simple_dir_inode_operations;\n\tif (!(sb->s_root = d_make_root (inode)))\n\t\tgoto Enomem;\n\n\t/* the ep0 file is named after the controller we expect;\n\t * user mode code can use it for sanity checks, like we do.\n\t */\n\tdev = dev_new ();\n\tif (!dev)\n\t\tgoto Enomem;\n\n\tdev->sb = sb;\n\tdev->dentry = gadgetfs_create_file(sb, CHIP, dev, &ep0_operations);\n\tif (!dev->dentry) {\n\t\tput_dev(dev);\n\t\tgoto Enomem;\n\t}\n\n\t/* other endpoint files are available after hardware setup,\n\t * from binding to a controller.\n\t */\n\tthe_device = dev;\n\treturn 0;\n\nEnomem:\n\tkfree(CHIP);\n\tCHIP = NULL;\n\n\treturn -ENOMEM;\n}\n\n/* \"mount -t gadgetfs path /dev/gadget\" ends up here */\nstatic int gadgetfs_get_tree(struct fs_context *fc)\n{\n\treturn get_tree_single(fc, gadgetfs_fill_super);\n}\n\nstatic const struct fs_context_operations gadgetfs_context_ops = {\n\t.get_tree\t= gadgetfs_get_tree,\n};\n\nstatic int gadgetfs_init_fs_context(struct fs_context *fc)\n{\n\tfc->ops = &gadgetfs_context_ops;\n\treturn 0;\n}\n\nstatic void\ngadgetfs_kill_sb (struct super_block *sb)\n{\n\tkill_litter_super (sb);\n\tif (the_device) {\n\t\tput_dev (the_device);\n\t\tthe_device = NULL;\n\t}\n\tkfree(CHIP);\n\tCHIP = NULL;\n}\n\n/*----------------------------------------------------------------------*/\n\nstatic struct file_system_type gadgetfs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= shortname,\n\t.init_fs_context = gadgetfs_init_fs_context,\n\t.kill_sb\t= gadgetfs_kill_sb,\n};\nMODULE_ALIAS_FS(\"gadgetfs\");\n\n/*----------------------------------------------------------------------*/\n\nstatic int __init init (void)\n{\n\tint status;\n\n\tstatus = register_filesystem (&gadgetfs_type);\n\tif (status == 0)\n\t\tpr_info (\"%s: %s, version \" DRIVER_VERSION \"\\n\",\n\t\t\tshortname, driver_desc);\n\treturn status;\n}\nmodule_init (init);\n\nstatic void __exit cleanup (void)\n{\n\tpr_debug (\"unregister %s\\n\", shortname);\n\tunregister_filesystem (&gadgetfs_type);\n}\nmodule_exit (cleanup);\n\n"], "filenames": ["drivers/usb/gadget/legacy/inode.c"], "buggy_code_start_loc": [1878], "buggy_code_end_loc": [1895], "fixing_code_start_loc": [1878], "fixing_code_end_loc": [1899], "type": "CWE-763", "message": "drivers/usb/gadget/legacy/inode.c in the Linux kernel through 5.16.8 mishandles dev->buf release.", "other": {"cve": {"id": "CVE-2022-24958", "sourceIdentifier": "cve@mitre.org", "published": "2022-02-11T06:15:06.717", "lastModified": "2023-02-01T15:50:16.677", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "drivers/usb/gadget/legacy/inode.c in the Linux kernel through 5.16.8 mishandles dev->buf release."}, {"lang": "es", "value": "el archivo drivers/usb/gadget/legacy/inode.c en el kernel de Linux versiones hasta 5.16.8 maneja inapropiadamente la liberaci\u00f3n dev-) buf"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 4.6}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.9, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-763"}]}], "configurations": [{"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndExcluding": "5.16.8", "matchCriteriaId": "931908E7-4FBA-4C33-B3CC-727B32E924A4"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:34:*:*:*:*:*:*:*", "matchCriteriaId": "A930E247-0B43-43CB-98FF-6CE7B8189835"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:35:*:*:*:*:*:*:*", "matchCriteriaId": "80E516C0-98A4-4ADE-B69F-66A772E2BAAA"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h300s_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "6770B6C3-732E-4E22-BF1C-2D2FD610061C"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h300s:-:*:*:*:*:*:*:*", "matchCriteriaId": "9F9C8C20-42EB-4AB5-BD97-212DEB070C43"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h500s_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "7FFF7106-ED78-49BA-9EC5-B889E3685D53"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h500s:-:*:*:*:*:*:*:*", "matchCriteriaId": "E63D8B0F-006E-4801-BF9D-1C001BBFB4F9"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h700s_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "56409CEC-5A1E-4450-AA42-641E459CC2AF"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h700s:-:*:*:*:*:*:*:*", "matchCriteriaId": "B06F4839-D16A-4A61-9BB5-55B13F41E47F"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h300e_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "108A2215-50FB-4074-94CF-C130FA14566D"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h300e:-:*:*:*:*:*:*:*", "matchCriteriaId": "7AFC73CE-ABB9-42D3-9A71-3F5BC5381E0E"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h500e_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "32F0B6C0-F930-480D-962B-3F4EFDCC13C7"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h500e:-:*:*:*:*:*:*:*", "matchCriteriaId": "803BC414-B250-4E3A-A478-A3881340D6B8"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h700e_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "0FEB3337-BFDE-462A-908B-176F92053CEC"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h700e:-:*:*:*:*:*:*:*", "matchCriteriaId": "736AEAE9-782B-4F71-9893-DED53367E102"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h410s_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "D0B4AD8A-F172-4558-AEC6-FF424BA2D912"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h410s:-:*:*:*:*:*:*:*", "matchCriteriaId": "8497A4C9-8474-4A62-8331-3FE862ED4098"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h410c_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "234DEFE0-5CE5-4B0A-96B8-5D227CB8ED31"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h410c:-:*:*:*:*:*:*:*", "matchCriteriaId": "CDDF61B7-EC5C-467C-B710-B89F502CD04F"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}], "references": [{"url": "https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit?id=89f3594d0de58e8a57d92d497dea9fee3d4b9cda", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/501e38a5531efbd77d5c73c0ba838a889bfc1d74", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/89f3594d0de58e8a57d92d497dea9fee3d4b9cda", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2022/07/msg00000.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/SUVZA2YVOQJBJTDIDQ5HF5TAU2C6WP6H/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/TCW2KZYJ2H6BKZE3CVLHRIXYDGNYYC5P/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20220225-0008/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/501e38a5531efbd77d5c73c0ba838a889bfc1d74"}}