{"buggy_code": ["/**\n * Jooby https://jooby.io\n * Apache License Version 2.0 https://jooby.io/LICENSE.txt\n * Copyright 2014 Edgar Espina\n */\npackage io.jooby.internal.netty;\n\nimport com.typesafe.config.Config;\nimport io.jooby.Body;\nimport io.jooby.ByteRange;\nimport io.jooby.Context;\nimport io.jooby.Cookie;\nimport io.jooby.DefaultContext;\nimport io.jooby.FileUpload;\nimport io.jooby.Formdata;\nimport io.jooby.MediaType;\nimport io.jooby.Multipart;\nimport io.jooby.QueryString;\nimport io.jooby.Route;\nimport io.jooby.Router;\nimport io.jooby.Sender;\nimport io.jooby.Server;\nimport io.jooby.Session;\nimport io.jooby.SessionStore;\nimport io.jooby.SneakyThrows;\nimport io.jooby.StatusCode;\nimport io.jooby.Value;\nimport io.jooby.ValueNode;\nimport io.jooby.WebSocket;\nimport io.netty.buffer.ByteBuf;\nimport io.netty.buffer.Unpooled;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelFutureListener;\nimport io.netty.channel.ChannelHandlerContext;\nimport io.netty.channel.ChannelPipeline;\nimport io.netty.channel.DefaultFileRegion;\nimport io.netty.handler.codec.http.DefaultFullHttpRequest;\nimport io.netty.handler.codec.http.DefaultFullHttpResponse;\nimport io.netty.handler.codec.http.DefaultHttpHeaders;\nimport io.netty.handler.codec.http.DefaultHttpResponse;\nimport io.netty.handler.codec.http.EmptyHttpHeaders;\nimport io.netty.handler.codec.http.HttpHeaderNames;\nimport io.netty.handler.codec.http.HttpHeaders;\nimport io.netty.handler.codec.http.HttpRequest;\nimport io.netty.handler.codec.http.HttpResponseStatus;\nimport io.netty.handler.codec.http.HttpUtil;\nimport io.netty.handler.codec.http.HttpVersion;\nimport io.netty.handler.codec.http.cookie.ServerCookieDecoder;\nimport io.netty.handler.codec.http.multipart.HttpData;\nimport io.netty.handler.codec.http.multipart.HttpPostRequestDecoder;\nimport io.netty.handler.codec.http.multipart.InterfaceHttpData;\nimport io.netty.handler.codec.http.multipart.InterfaceHttpPostRequestDecoder;\nimport io.netty.handler.codec.http.websocketx.WebSocketDecoderConfig;\nimport io.netty.handler.codec.http.websocketx.WebSocketServerHandshaker;\nimport io.netty.handler.codec.http.websocketx.WebSocketServerHandshakerFactory;\nimport io.netty.handler.stream.ChunkedNioStream;\nimport io.netty.handler.stream.ChunkedStream;\nimport io.netty.handler.stream.ChunkedWriteHandler;\nimport io.netty.handler.timeout.IdleState;\nimport io.netty.handler.timeout.IdleStateHandler;\nimport io.netty.util.ReferenceCounted;\n\nimport javax.annotation.Nonnull;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.net.InetSocketAddress;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.channels.ReadableByteChannel;\nimport java.nio.charset.Charset;\nimport java.time.Duration;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.concurrent.Executor;\nimport java.util.concurrent.TimeUnit;\n\nimport static io.netty.buffer.Unpooled.copiedBuffer;\nimport static io.netty.buffer.Unpooled.wrappedBuffer;\nimport static io.netty.handler.codec.http.HttpHeaderNames.CONTENT_LENGTH;\nimport static io.netty.handler.codec.http.HttpHeaderNames.CONTENT_TYPE;\nimport static io.netty.handler.codec.http.HttpHeaderNames.RANGE;\nimport static io.netty.handler.codec.http.HttpHeaderNames.SET_COOKIE;\nimport static io.netty.handler.codec.http.HttpHeaderNames.TRANSFER_ENCODING;\nimport static io.netty.handler.codec.http.HttpHeaderValues.CHUNKED;\nimport static io.netty.handler.codec.http.HttpUtil.isKeepAlive;\nimport static io.netty.handler.codec.http.HttpVersion.HTTP_1_1;\nimport static io.netty.handler.codec.http.LastHttpContent.EMPTY_LAST_CONTENT;\nimport static java.nio.charset.StandardCharsets.UTF_8;\n\npublic class NettyContext implements DefaultContext, ChannelFutureListener {\n\n  private static final HttpHeaders NO_TRAILING = EmptyHttpHeaders.INSTANCE;\n  final DefaultHttpHeaders setHeaders = new DefaultHttpHeaders(false);\n  private final int bufferSize;\n  InterfaceHttpPostRequestDecoder decoder;\n  private Router router;\n  private Route route;\n  ChannelHandlerContext ctx;\n  private HttpRequest req;\n  private String path;\n  private HttpResponseStatus status = HttpResponseStatus.OK;\n  private boolean responseStarted;\n  private QueryString query;\n  private Formdata form;\n  private Multipart multipart;\n  private List<FileUpload> files;\n  private ValueNode headers;\n  private Map<String, String> pathMap = Collections.EMPTY_MAP;\n  private MediaType responseType;\n  private Map<String, Object> attributes = new HashMap<>();\n  private long contentLength = -1;\n  private boolean needsFlush;\n  private Map<String, String> cookies;\n  private Map<String, String> responseCookies;\n  private Boolean resetHeadersOnError;\n  NettyWebSocket webSocket;\n\n  public NettyContext(ChannelHandlerContext ctx, HttpRequest req, Router router, String path,\n      int bufferSize) {\n    this.path = path;\n    this.ctx = ctx;\n    this.req = req;\n    this.router = router;\n    this.bufferSize = bufferSize;\n  }\n\n  @Nonnull @Override public Router getRouter() {\n    return router;\n  }\n\n  /* **********************************************************************************************\n   * Request methods:\n   * **********************************************************************************************\n   */\n\n  @Nonnull @Override public Map<String, Object> getAttributes() {\n    return attributes;\n  }\n\n  @Nonnull @Override public String getMethod() {\n    return req.method().asciiName().toUpperCase().toString();\n  }\n\n  @Nonnull @Override public Route getRoute() {\n    return route;\n  }\n\n  @Nonnull @Override public Context setRoute(@Nonnull Route route) {\n    this.route = route;\n    return this;\n  }\n\n  @Nonnull @Override public final String pathString() {\n    return path;\n  }\n\n  @Nonnull @Override public Map<String, String> pathMap() {\n    return pathMap;\n  }\n\n  @Nonnull @Override public Context setPathMap(@Nonnull Map<String, String> pathMap) {\n    this.pathMap = pathMap;\n    return this;\n  }\n\n  @Override public final boolean isInIoThread() {\n    return ctx.channel().eventLoop().inEventLoop();\n  }\n\n  @Nonnull @Override public Context dispatch(@Nonnull Runnable action) {\n    return dispatch(router.getWorker(), action);\n  }\n\n  @Override public Context dispatch(Executor executor, Runnable action) {\n    executor.execute(action);\n    return this;\n  }\n\n  @Nonnull @Override public Context detach(@Nonnull Route.Handler next) throws Exception {\n    next.apply(this);\n    return this;\n  }\n\n  @Nonnull @Override public QueryString query() {\n    if (query == null) {\n      String uri = req.uri();\n      int q = uri.indexOf('?');\n      query = QueryString.create(this, q >= 0 ? uri.substring(q + 1) : null);\n    }\n    return query;\n  }\n\n  @Nonnull @Override public Formdata form() {\n    if (form == null) {\n      form = Formdata.create(this);\n      decodeForm(req, form);\n    }\n    return form;\n  }\n\n  @Nonnull @Override public Multipart multipart() {\n    if (multipart == null) {\n      multipart = Multipart.create(this);\n      form = multipart;\n      decodeForm(req, multipart);\n    }\n    return multipart;\n  }\n\n  @Nonnull @Override public Value header(@Nonnull String name) {\n    return Value.create(this, name, req.headers().getAll(name));\n  }\n\n  @Nonnull @Override public String getRemoteAddress() {\n    InetSocketAddress remoteAddress = (InetSocketAddress) ctx.channel().remoteAddress();\n    return remoteAddress.getAddress().getHostAddress();\n  }\n\n  @Nonnull @Override public String getProtocol() {\n    return req.protocolVersion().text();\n  }\n\n  @Nonnull @Override public String getScheme() {\n    // TODO: review if we add websocket or https\n    return \"http\";\n  }\n\n  @Nonnull @Override public ValueNode header() {\n    if (headers == null) {\n      Map<String, Collection<String>> headerMap = new LinkedHashMap<>();\n      HttpHeaders headers = req.headers();\n      Set<String> names = headers.names();\n      for (String name : names) {\n        headerMap.put(name, headers.getAll(name));\n      }\n      this.headers = Value.hash(this, headerMap);\n    }\n    return headers;\n  }\n\n  @Nonnull @Override public Body body() {\n    if (decoder != null && decoder.hasNext()) {\n      return new NettyBody(this, (HttpData) decoder.next(), HttpUtil.getContentLength(req, -1L));\n    }\n    return Body.empty(this);\n  }\n\n  @Override public @Nonnull Map<String, String> cookieMap() {\n    if (this.cookies == null) {\n      this.cookies = Collections.emptyMap();\n      String cookieString = req.headers().get(HttpHeaderNames.COOKIE);\n      if (cookieString != null) {\n        Set<io.netty.handler.codec.http.cookie.Cookie> cookies = ServerCookieDecoder.STRICT\n            .decode(cookieString);\n        if (cookies.size() > 0) {\n          this.cookies = new LinkedHashMap<>(cookies.size());\n          for (io.netty.handler.codec.http.cookie.Cookie it : cookies) {\n            this.cookies.put(it.name(), it.value());\n          }\n        }\n      }\n    }\n    return this.cookies;\n  }\n\n  @Nonnull @Override public Context upgrade(WebSocket.Initializer handler) {\n    try {\n      responseStarted = true;\n      String webSocketURL = getProtocol() + \"://\" + req.headers().get(HttpHeaderNames.HOST) + path;\n      WebSocketDecoderConfig config = WebSocketDecoderConfig.newBuilder()\n          .allowExtensions(true)\n          .allowMaskMismatch(false)\n          .withUTF8Validator(false)\n          .maxFramePayloadLength(WebSocket.MAX_BUFFER_SIZE)\n          .build();\n      webSocket = new NettyWebSocket(this);\n      handler.init(Context.readOnly(this), webSocket);\n      DefaultFullHttpRequest fullHttpRequest = new DefaultFullHttpRequest(req.protocolVersion(),\n          req.method(), req.uri(), Unpooled.EMPTY_BUFFER, req.headers(), EmptyHttpHeaders.INSTANCE);\n      WebSocketServerHandshakerFactory factory = new WebSocketServerHandshakerFactory(webSocketURL,\n          null, config);\n      WebSocketServerHandshaker handshaker = factory.newHandshaker(fullHttpRequest);\n      handshaker.handshake(ctx.channel(), fullHttpRequest, setHeaders, ctx.newPromise())\n          .addListener(future -> {\n            if (future.isSuccess()) {\n              webSocket.fireConnect();\n            }\n          });\n      Config conf = getRouter().getConfig();\n      long timeout = conf.hasPath(\"websocket.idleTimeout\")\n          ? conf.getDuration(\"websocket.idleTimeout\", TimeUnit.MINUTES)\n          : 5;\n      if (timeout > 0) {\n        IdleStateHandler idle = new IdleStateHandler(timeout, 0, 0, TimeUnit.MINUTES);\n        ctx.pipeline().addBefore(\"handler\", \"idle\", idle);\n      }\n    } catch (Throwable x) {\n      sendError(x);\n    }\n    return this;\n  }\n\n  /* **********************************************************************************************\n   * Response methods:\n   * **********************************************************************************************\n   */\n\n  @Nonnull @Override public StatusCode getResponseCode() {\n    return StatusCode.valueOf(this.status.code());\n  }\n\n  @Nonnull @Override public Context setResponseCode(int statusCode) {\n    this.status = HttpResponseStatus.valueOf(statusCode);\n    return this;\n  }\n\n  @Nonnull @Override public Context setResponseHeader(@Nonnull String name, @Nonnull String value) {\n    setHeaders.set(name, value);\n    return this;\n  }\n\n  @Nonnull @Override public Context removeResponseHeader(@Nonnull String name) {\n    setHeaders.remove(name);\n    return this;\n  }\n\n  @Nonnull @Override public Context removeResponseHeaders() {\n    setHeaders.clear();\n    return this;\n  }\n\n  @Nonnull @Override public MediaType getResponseType() {\n    return responseType == null ? MediaType.text : responseType;\n  }\n\n  @Nonnull @Override public Context setDefaultResponseType(@Nonnull MediaType contentType) {\n    if (responseType == null) {\n      setResponseType(contentType, contentType.getCharset());\n    }\n    return this;\n  }\n\n  @Override public final Context setResponseType(MediaType contentType, Charset charset) {\n    this.responseType = contentType;\n    setHeaders.set(CONTENT_TYPE, contentType.toContentTypeHeader(charset));\n    return this;\n  }\n\n  @Nonnull @Override public Context setResponseType(@Nonnull String contentType) {\n    this.responseType = MediaType.valueOf(contentType);\n    setHeaders.set(CONTENT_TYPE, contentType);\n    return this;\n  }\n\n  @Nonnull @Override public Context setResponseLength(long length) {\n    contentLength = length;\n    setHeaders.set(CONTENT_LENGTH, Long.toString(length));\n    return this;\n  }\n\n  @Override public long getResponseLength() {\n    return contentLength;\n  }\n\n  @Nonnull public Context setResponseCookie(@Nonnull Cookie cookie) {\n    if (responseCookies == null) {\n      responseCookies = new HashMap<>();\n    }\n    cookie.setPath(cookie.getPath(getContextPath()));\n    responseCookies.put(cookie.getName(), cookie.toCookieString());\n    setHeaders.remove(SET_COOKIE);\n    for (String cookieString : responseCookies.values()) {\n      setHeaders.add(SET_COOKIE, cookieString);\n    }\n    return this;\n  }\n\n  @Nonnull @Override public PrintWriter responseWriter(MediaType type, Charset charset) {\n    responseStarted = true;\n    setResponseType(type, charset);\n\n    return new PrintWriter(new NettyWriter(newOutputStream(), charset));\n  }\n\n  @Nonnull @Override public Sender responseSender() {\n    responseStarted = true;\n    prepareChunked();\n    ctx.write(new DefaultHttpResponse(req.protocolVersion(), status, setHeaders));\n    return new NettySender(this, ctx);\n  }\n\n  @Nonnull @Override public OutputStream responseStream() {\n    return newOutputStream();\n  }\n\n  @Nonnull @Override public Context send(@Nonnull String data) {\n    return send(copiedBuffer(data, UTF_8));\n  }\n\n  @Override public final Context send(String data, Charset charset) {\n    return send(copiedBuffer(data, charset));\n  }\n\n  @Override public final Context send(byte[] data) {\n    return send(wrappedBuffer(data));\n  }\n\n  @Nonnull @Override public Context send(@Nonnull byte[]... data) {\n    return send(Unpooled.wrappedBuffer(data));\n  }\n\n  @Nonnull @Override public Context send(@Nonnull ByteBuffer[] data) {\n    return send(Unpooled.wrappedBuffer(data));\n  }\n\n  @Override public final Context send(ByteBuffer data) {\n    return send(wrappedBuffer(data));\n  }\n\n  private Context send(@Nonnull ByteBuf data) {\n    responseStarted = true;\n    setHeaders.set(CONTENT_LENGTH, Long.toString(data.readableBytes()));\n    DefaultFullHttpResponse response = new DefaultFullHttpResponse(HTTP_1_1, status,\n        data, setHeaders, NO_TRAILING);\n    if (ctx.channel().eventLoop().inEventLoop()) {\n      needsFlush = true;\n      ctx.write(response).addListener(this);\n    } else {\n      ctx.writeAndFlush(response).addListener(this);\n    }\n    return this;\n  }\n\n  public void flush() {\n    if (needsFlush) {\n      needsFlush = false;\n      ctx.flush();\n    }\n  }\n\n  @Nonnull @Override public Context send(@Nonnull ReadableByteChannel channel) {\n    prepareChunked();\n    DefaultHttpResponse rsp = new DefaultHttpResponse(HttpVersion.HTTP_1_1, status, setHeaders);\n    responseStarted = true;\n    int bufferSize = contentLength > 0 ? (int) contentLength : this.bufferSize;\n    ctx.channel().eventLoop().execute(() -> {\n      // Headers\n      ctx.write(rsp, ctx.voidPromise());\n      // Body\n      ctx.write(new ChunkedNioStream(channel, bufferSize), ctx.voidPromise());\n      // Finish\n      ctx.writeAndFlush(EMPTY_LAST_CONTENT).addListener(this);\n    });\n    return this;\n  }\n\n  @Nonnull @Override public Context send(@Nonnull InputStream in) {\n    if (in instanceof FileInputStream) {\n      // use channel\n      return send(((FileInputStream) in).getChannel());\n    }\n    try {\n      prepareChunked();\n      long len = responseLength();\n      ByteRange range = ByteRange.parse(req.headers().get(RANGE), len)\n          .apply(this);\n      ChunkedStream chunkedStream = new ChunkedStream(range.apply(in), bufferSize);\n\n      DefaultHttpResponse rsp = new DefaultHttpResponse(HttpVersion.HTTP_1_1, status, setHeaders);\n      responseStarted = true;\n      ctx.channel().eventLoop().execute(() -> {\n        // Headers\n        ctx.write(rsp, ctx.voidPromise());\n        // Body\n        ctx.write(chunkedStream, ctx.voidPromise());\n        // Finish\n        ctx.writeAndFlush(EMPTY_LAST_CONTENT).addListener(this);\n      });\n      return this;\n    } catch (Exception x) {\n      throw SneakyThrows.propagate(x);\n    }\n  }\n\n  @Nonnull @Override public Context send(@Nonnull FileChannel file) {\n    try {\n      long len = file.size();\n      setHeaders.set(CONTENT_LENGTH, Long.toString(len));\n\n      ByteRange range = ByteRange.parse(req.headers().get(RANGE), len)\n          .apply(this);\n\n      DefaultHttpResponse rsp = new DefaultHttpResponse(HttpVersion.HTTP_1_1, status, setHeaders);\n      responseStarted = true;\n      ctx.channel().eventLoop().execute(() -> {\n        // Headers\n        ctx.write(rsp, ctx.voidPromise());\n        // Body\n        ctx.write(new DefaultFileRegion(file, range.getStart(), range.getEnd()), ctx.voidPromise());\n        // Finish\n        ctx.writeAndFlush(EMPTY_LAST_CONTENT).addListener(this);\n      });\n    } catch (IOException x) {\n      throw SneakyThrows.propagate(x);\n    }\n    return this;\n  }\n\n  @Override public boolean isResponseStarted() {\n    return responseStarted;\n  }\n\n  @Override public boolean getResetHeadersOnError() {\n    return resetHeadersOnError == null\n        ? getRouter().getRouterOptions().getResetHeadersOnError()\n        : resetHeadersOnError.booleanValue();\n  }\n\n  @Override public Context setResetHeadersOnError(boolean value) {\n    this.resetHeadersOnError = value;\n    return this;\n  }\n\n  @Nonnull @Override public Context send(StatusCode statusCode) {\n    responseStarted = true;\n    if (!setHeaders.contains(CONTENT_LENGTH)) {\n      setHeaders.set(CONTENT_LENGTH, \"0\");\n    }\n    DefaultFullHttpResponse rsp = new DefaultFullHttpResponse(HTTP_1_1,\n        HttpResponseStatus.valueOf(statusCode.value()), Unpooled.EMPTY_BUFFER, setHeaders,\n        NO_TRAILING);\n    ctx.writeAndFlush(rsp).addListener(this);\n    return this;\n  }\n\n  @Override public void operationComplete(ChannelFuture future) {\n    try {\n      ifSaveSession();\n      destroy(future.cause());\n    } finally {\n      if (!isKeepAlive(req)) {\n        future.channel().close();\n      }\n    }\n  }\n\n  private void ifSaveSession() {\n    Session session = (Session) getAttributes().get(Session.NAME);\n    if (session != null && (session.isNew() || session.isModify())) {\n      SessionStore store = router.getSessionStore();\n      store.saveSession(this, session);\n    }\n  }\n\n  private NettyOutputStream newOutputStream() {\n    prepareChunked();\n    return new NettyOutputStream(ctx, bufferSize,\n        new DefaultHttpResponse(req.protocolVersion(), status, setHeaders), this);\n  }\n\n  void destroy(Throwable cause) {\n    if (cause != null) {\n      if (Server.connectionLost(cause)) {\n        router.getLog()\n            .debug(\"exception found while sending response {} {}\", getMethod(), pathString(),\n                cause);\n      } else {\n        router.getLog()\n            .error(\"exception found while sending response {} {}\", getMethod(), pathString(),\n                cause);\n      }\n    }\n    if (files != null) {\n      for (FileUpload file : files) {\n        try {\n          file.destroy();\n        } catch (Exception x) {\n          router.getLog().debug(\"file upload destroy resulted in exception\", x);\n        }\n      }\n      files = null;\n    }\n    if (decoder != null) {\n      try {\n        decoder.destroy();\n      } catch (Exception x) {\n        router.getLog().debug(\"body decoder destroy resulted in exception\", x);\n      }\n      decoder = null;\n    }\n    release(req);\n  }\n\n  private FileUpload register(FileUpload upload) {\n    if (this.files == null) {\n      this.files = new ArrayList<>();\n    }\n    this.files.add(upload);\n    return upload;\n  }\n\n  private void decodeForm(HttpRequest req, Formdata form) {\n    if (decoder == null) {\n      // empty/bad form\n      return;\n    }\n    try {\n      while (decoder.hasNext()) {\n        HttpData next = (HttpData) decoder.next();\n        if (next.getHttpDataType() == InterfaceHttpData.HttpDataType.FileUpload) {\n          ((Multipart) form).put(next.getName(),\n              register(new NettyFileUpload(router.getTmpdir(),\n                  (io.netty.handler.codec.http.multipart.FileUpload) next)));\n        } else {\n          form.put(next.getName(), next.getString(UTF_8));\n        }\n      }\n    } catch (HttpPostRequestDecoder.EndOfDataDecoderException x) {\n      // ignore, silly netty\n    } catch (Exception x) {\n      throw SneakyThrows.propagate(x);\n    } finally {\n      release(req);\n    }\n  }\n\n  private static void release(HttpRequest req) {\n    if (req instanceof ReferenceCounted) {\n      ReferenceCounted ref = (ReferenceCounted) req;\n      if (ref.refCnt() > 0) {\n        ref.release();\n      }\n    }\n  }\n\n  private long responseLength() {\n    String len = setHeaders.get(CONTENT_LENGTH);\n    return len == null ? -1 : Long.parseLong(len);\n  }\n\n  private void prepareChunked() {\n    // remove flusher, doesn't play well with streaming/chunked responses\n    ChannelPipeline pipeline = ctx.pipeline();\n    if (pipeline.get(\"chunker\") == null) {\n      pipeline.addAfter(\"encoder\", \"chunker\", new ChunkedWriteHandler());\n    }\n    if (!setHeaders.contains(CONTENT_LENGTH)) {\n      setHeaders.set(TRANSFER_ENCODING, CHUNKED);\n    }\n  }\n\n  @Override public String toString() {\n    return getMethod() + \" \" + pathString();\n  }\n}\n"], "fixing_code": ["/**\n * Jooby https://jooby.io\n * Apache License Version 2.0 https://jooby.io/LICENSE.txt\n * Copyright 2014 Edgar Espina\n */\npackage io.jooby.internal.netty;\n\nimport com.typesafe.config.Config;\nimport io.jooby.Body;\nimport io.jooby.ByteRange;\nimport io.jooby.Context;\nimport io.jooby.Cookie;\nimport io.jooby.DefaultContext;\nimport io.jooby.FileUpload;\nimport io.jooby.Formdata;\nimport io.jooby.MediaType;\nimport io.jooby.Multipart;\nimport io.jooby.QueryString;\nimport io.jooby.Route;\nimport io.jooby.Router;\nimport io.jooby.Sender;\nimport io.jooby.Server;\nimport io.jooby.Session;\nimport io.jooby.SessionStore;\nimport io.jooby.SneakyThrows;\nimport io.jooby.StatusCode;\nimport io.jooby.Value;\nimport io.jooby.ValueNode;\nimport io.jooby.WebSocket;\nimport io.netty.buffer.ByteBuf;\nimport io.netty.buffer.Unpooled;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelFutureListener;\nimport io.netty.channel.ChannelHandlerContext;\nimport io.netty.channel.ChannelPipeline;\nimport io.netty.channel.DefaultFileRegion;\nimport io.netty.handler.codec.http.DefaultFullHttpRequest;\nimport io.netty.handler.codec.http.DefaultFullHttpResponse;\nimport io.netty.handler.codec.http.DefaultHttpHeaders;\nimport io.netty.handler.codec.http.DefaultHttpResponse;\nimport io.netty.handler.codec.http.EmptyHttpHeaders;\nimport io.netty.handler.codec.http.HttpHeaderNames;\nimport io.netty.handler.codec.http.HttpHeaders;\nimport io.netty.handler.codec.http.HttpRequest;\nimport io.netty.handler.codec.http.HttpResponseStatus;\nimport io.netty.handler.codec.http.HttpUtil;\nimport io.netty.handler.codec.http.HttpVersion;\nimport io.netty.handler.codec.http.cookie.ServerCookieDecoder;\nimport io.netty.handler.codec.http.multipart.HttpData;\nimport io.netty.handler.codec.http.multipart.HttpPostRequestDecoder;\nimport io.netty.handler.codec.http.multipart.InterfaceHttpData;\nimport io.netty.handler.codec.http.multipart.InterfaceHttpPostRequestDecoder;\nimport io.netty.handler.codec.http.websocketx.WebSocketDecoderConfig;\nimport io.netty.handler.codec.http.websocketx.WebSocketServerHandshaker;\nimport io.netty.handler.codec.http.websocketx.WebSocketServerHandshakerFactory;\nimport io.netty.handler.stream.ChunkedNioStream;\nimport io.netty.handler.stream.ChunkedStream;\nimport io.netty.handler.stream.ChunkedWriteHandler;\nimport io.netty.handler.timeout.IdleState;\nimport io.netty.handler.timeout.IdleStateHandler;\nimport io.netty.util.ReferenceCounted;\n\nimport javax.annotation.Nonnull;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.net.InetSocketAddress;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.channels.ReadableByteChannel;\nimport java.nio.charset.Charset;\nimport java.time.Duration;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.concurrent.Executor;\nimport java.util.concurrent.TimeUnit;\n\nimport static io.netty.buffer.Unpooled.copiedBuffer;\nimport static io.netty.buffer.Unpooled.wrappedBuffer;\nimport static io.netty.handler.codec.http.HttpHeaderNames.CONTENT_LENGTH;\nimport static io.netty.handler.codec.http.HttpHeaderNames.CONTENT_TYPE;\nimport static io.netty.handler.codec.http.HttpHeaderNames.RANGE;\nimport static io.netty.handler.codec.http.HttpHeaderNames.SET_COOKIE;\nimport static io.netty.handler.codec.http.HttpHeaderNames.TRANSFER_ENCODING;\nimport static io.netty.handler.codec.http.HttpHeaderValues.CHUNKED;\nimport static io.netty.handler.codec.http.HttpUtil.isKeepAlive;\nimport static io.netty.handler.codec.http.HttpVersion.HTTP_1_1;\nimport static io.netty.handler.codec.http.LastHttpContent.EMPTY_LAST_CONTENT;\nimport static java.nio.charset.StandardCharsets.UTF_8;\n\npublic class NettyContext implements DefaultContext, ChannelFutureListener {\n\n  private static final HttpHeaders NO_TRAILING = EmptyHttpHeaders.INSTANCE;\n  final DefaultHttpHeaders setHeaders = new DefaultHttpHeaders(true);\n  private final int bufferSize;\n  InterfaceHttpPostRequestDecoder decoder;\n  private Router router;\n  private Route route;\n  ChannelHandlerContext ctx;\n  private HttpRequest req;\n  private String path;\n  private HttpResponseStatus status = HttpResponseStatus.OK;\n  private boolean responseStarted;\n  private QueryString query;\n  private Formdata form;\n  private Multipart multipart;\n  private List<FileUpload> files;\n  private ValueNode headers;\n  private Map<String, String> pathMap = Collections.EMPTY_MAP;\n  private MediaType responseType;\n  private Map<String, Object> attributes = new HashMap<>();\n  private long contentLength = -1;\n  private boolean needsFlush;\n  private Map<String, String> cookies;\n  private Map<String, String> responseCookies;\n  private Boolean resetHeadersOnError;\n  NettyWebSocket webSocket;\n\n  public NettyContext(ChannelHandlerContext ctx, HttpRequest req, Router router, String path,\n      int bufferSize) {\n    this.path = path;\n    this.ctx = ctx;\n    this.req = req;\n    this.router = router;\n    this.bufferSize = bufferSize;\n  }\n\n  @Nonnull @Override public Router getRouter() {\n    return router;\n  }\n\n  /* **********************************************************************************************\n   * Request methods:\n   * **********************************************************************************************\n   */\n\n  @Nonnull @Override public Map<String, Object> getAttributes() {\n    return attributes;\n  }\n\n  @Nonnull @Override public String getMethod() {\n    return req.method().asciiName().toUpperCase().toString();\n  }\n\n  @Nonnull @Override public Route getRoute() {\n    return route;\n  }\n\n  @Nonnull @Override public Context setRoute(@Nonnull Route route) {\n    this.route = route;\n    return this;\n  }\n\n  @Nonnull @Override public final String pathString() {\n    return path;\n  }\n\n  @Nonnull @Override public Map<String, String> pathMap() {\n    return pathMap;\n  }\n\n  @Nonnull @Override public Context setPathMap(@Nonnull Map<String, String> pathMap) {\n    this.pathMap = pathMap;\n    return this;\n  }\n\n  @Override public final boolean isInIoThread() {\n    return ctx.channel().eventLoop().inEventLoop();\n  }\n\n  @Nonnull @Override public Context dispatch(@Nonnull Runnable action) {\n    return dispatch(router.getWorker(), action);\n  }\n\n  @Override public Context dispatch(Executor executor, Runnable action) {\n    executor.execute(action);\n    return this;\n  }\n\n  @Nonnull @Override public Context detach(@Nonnull Route.Handler next) throws Exception {\n    next.apply(this);\n    return this;\n  }\n\n  @Nonnull @Override public QueryString query() {\n    if (query == null) {\n      String uri = req.uri();\n      int q = uri.indexOf('?');\n      query = QueryString.create(this, q >= 0 ? uri.substring(q + 1) : null);\n    }\n    return query;\n  }\n\n  @Nonnull @Override public Formdata form() {\n    if (form == null) {\n      form = Formdata.create(this);\n      decodeForm(req, form);\n    }\n    return form;\n  }\n\n  @Nonnull @Override public Multipart multipart() {\n    if (multipart == null) {\n      multipart = Multipart.create(this);\n      form = multipart;\n      decodeForm(req, multipart);\n    }\n    return multipart;\n  }\n\n  @Nonnull @Override public Value header(@Nonnull String name) {\n    return Value.create(this, name, req.headers().getAll(name));\n  }\n\n  @Nonnull @Override public String getRemoteAddress() {\n    InetSocketAddress remoteAddress = (InetSocketAddress) ctx.channel().remoteAddress();\n    return remoteAddress.getAddress().getHostAddress();\n  }\n\n  @Nonnull @Override public String getProtocol() {\n    return req.protocolVersion().text();\n  }\n\n  @Nonnull @Override public String getScheme() {\n    // TODO: review if we add websocket or https\n    return \"http\";\n  }\n\n  @Nonnull @Override public ValueNode header() {\n    if (headers == null) {\n      Map<String, Collection<String>> headerMap = new LinkedHashMap<>();\n      HttpHeaders headers = req.headers();\n      Set<String> names = headers.names();\n      for (String name : names) {\n        headerMap.put(name, headers.getAll(name));\n      }\n      this.headers = Value.hash(this, headerMap);\n    }\n    return headers;\n  }\n\n  @Nonnull @Override public Body body() {\n    if (decoder != null && decoder.hasNext()) {\n      return new NettyBody(this, (HttpData) decoder.next(), HttpUtil.getContentLength(req, -1L));\n    }\n    return Body.empty(this);\n  }\n\n  @Override public @Nonnull Map<String, String> cookieMap() {\n    if (this.cookies == null) {\n      this.cookies = Collections.emptyMap();\n      String cookieString = req.headers().get(HttpHeaderNames.COOKIE);\n      if (cookieString != null) {\n        Set<io.netty.handler.codec.http.cookie.Cookie> cookies = ServerCookieDecoder.STRICT\n            .decode(cookieString);\n        if (cookies.size() > 0) {\n          this.cookies = new LinkedHashMap<>(cookies.size());\n          for (io.netty.handler.codec.http.cookie.Cookie it : cookies) {\n            this.cookies.put(it.name(), it.value());\n          }\n        }\n      }\n    }\n    return this.cookies;\n  }\n\n  @Nonnull @Override public Context upgrade(WebSocket.Initializer handler) {\n    try {\n      responseStarted = true;\n      String webSocketURL = getProtocol() + \"://\" + req.headers().get(HttpHeaderNames.HOST) + path;\n      WebSocketDecoderConfig config = WebSocketDecoderConfig.newBuilder()\n          .allowExtensions(true)\n          .allowMaskMismatch(false)\n          .withUTF8Validator(false)\n          .maxFramePayloadLength(WebSocket.MAX_BUFFER_SIZE)\n          .build();\n      webSocket = new NettyWebSocket(this);\n      handler.init(Context.readOnly(this), webSocket);\n      DefaultFullHttpRequest fullHttpRequest = new DefaultFullHttpRequest(req.protocolVersion(),\n          req.method(), req.uri(), Unpooled.EMPTY_BUFFER, req.headers(), EmptyHttpHeaders.INSTANCE);\n      WebSocketServerHandshakerFactory factory = new WebSocketServerHandshakerFactory(webSocketURL,\n          null, config);\n      WebSocketServerHandshaker handshaker = factory.newHandshaker(fullHttpRequest);\n      handshaker.handshake(ctx.channel(), fullHttpRequest, setHeaders, ctx.newPromise())\n          .addListener(future -> {\n            if (future.isSuccess()) {\n              webSocket.fireConnect();\n            }\n          });\n      Config conf = getRouter().getConfig();\n      long timeout = conf.hasPath(\"websocket.idleTimeout\")\n          ? conf.getDuration(\"websocket.idleTimeout\", TimeUnit.MINUTES)\n          : 5;\n      if (timeout > 0) {\n        IdleStateHandler idle = new IdleStateHandler(timeout, 0, 0, TimeUnit.MINUTES);\n        ctx.pipeline().addBefore(\"handler\", \"idle\", idle);\n      }\n    } catch (Throwable x) {\n      sendError(x);\n    }\n    return this;\n  }\n\n  /* **********************************************************************************************\n   * Response methods:\n   * **********************************************************************************************\n   */\n\n  @Nonnull @Override public StatusCode getResponseCode() {\n    return StatusCode.valueOf(this.status.code());\n  }\n\n  @Nonnull @Override public Context setResponseCode(int statusCode) {\n    this.status = HttpResponseStatus.valueOf(statusCode);\n    return this;\n  }\n\n  @Nonnull @Override public Context setResponseHeader(@Nonnull String name, @Nonnull String value) {\n    setHeaders.set(name, value);\n    return this;\n  }\n\n  @Nonnull @Override public Context removeResponseHeader(@Nonnull String name) {\n    setHeaders.remove(name);\n    return this;\n  }\n\n  @Nonnull @Override public Context removeResponseHeaders() {\n    setHeaders.clear();\n    return this;\n  }\n\n  @Nonnull @Override public MediaType getResponseType() {\n    return responseType == null ? MediaType.text : responseType;\n  }\n\n  @Nonnull @Override public Context setDefaultResponseType(@Nonnull MediaType contentType) {\n    if (responseType == null) {\n      setResponseType(contentType, contentType.getCharset());\n    }\n    return this;\n  }\n\n  @Override public final Context setResponseType(MediaType contentType, Charset charset) {\n    this.responseType = contentType;\n    setHeaders.set(CONTENT_TYPE, contentType.toContentTypeHeader(charset));\n    return this;\n  }\n\n  @Nonnull @Override public Context setResponseType(@Nonnull String contentType) {\n    this.responseType = MediaType.valueOf(contentType);\n    setHeaders.set(CONTENT_TYPE, contentType);\n    return this;\n  }\n\n  @Nonnull @Override public Context setResponseLength(long length) {\n    contentLength = length;\n    setHeaders.set(CONTENT_LENGTH, Long.toString(length));\n    return this;\n  }\n\n  @Override public long getResponseLength() {\n    return contentLength;\n  }\n\n  @Nonnull public Context setResponseCookie(@Nonnull Cookie cookie) {\n    if (responseCookies == null) {\n      responseCookies = new HashMap<>();\n    }\n    cookie.setPath(cookie.getPath(getContextPath()));\n    responseCookies.put(cookie.getName(), cookie.toCookieString());\n    setHeaders.remove(SET_COOKIE);\n    for (String cookieString : responseCookies.values()) {\n      setHeaders.add(SET_COOKIE, cookieString);\n    }\n    return this;\n  }\n\n  @Nonnull @Override public PrintWriter responseWriter(MediaType type, Charset charset) {\n    responseStarted = true;\n    setResponseType(type, charset);\n\n    return new PrintWriter(new NettyWriter(newOutputStream(), charset));\n  }\n\n  @Nonnull @Override public Sender responseSender() {\n    responseStarted = true;\n    prepareChunked();\n    ctx.write(new DefaultHttpResponse(req.protocolVersion(), status, setHeaders));\n    return new NettySender(this, ctx);\n  }\n\n  @Nonnull @Override public OutputStream responseStream() {\n    return newOutputStream();\n  }\n\n  @Nonnull @Override public Context send(@Nonnull String data) {\n    return send(copiedBuffer(data, UTF_8));\n  }\n\n  @Override public final Context send(String data, Charset charset) {\n    return send(copiedBuffer(data, charset));\n  }\n\n  @Override public final Context send(byte[] data) {\n    return send(wrappedBuffer(data));\n  }\n\n  @Nonnull @Override public Context send(@Nonnull byte[]... data) {\n    return send(Unpooled.wrappedBuffer(data));\n  }\n\n  @Nonnull @Override public Context send(@Nonnull ByteBuffer[] data) {\n    return send(Unpooled.wrappedBuffer(data));\n  }\n\n  @Override public final Context send(ByteBuffer data) {\n    return send(wrappedBuffer(data));\n  }\n\n  private Context send(@Nonnull ByteBuf data) {\n    responseStarted = true;\n    setHeaders.set(CONTENT_LENGTH, Long.toString(data.readableBytes()));\n    DefaultFullHttpResponse response = new DefaultFullHttpResponse(HTTP_1_1, status,\n        data, setHeaders, NO_TRAILING);\n    if (ctx.channel().eventLoop().inEventLoop()) {\n      needsFlush = true;\n      ctx.write(response).addListener(this);\n    } else {\n      ctx.writeAndFlush(response).addListener(this);\n    }\n    return this;\n  }\n\n  public void flush() {\n    if (needsFlush) {\n      needsFlush = false;\n      ctx.flush();\n    }\n  }\n\n  @Nonnull @Override public Context send(@Nonnull ReadableByteChannel channel) {\n    prepareChunked();\n    DefaultHttpResponse rsp = new DefaultHttpResponse(HttpVersion.HTTP_1_1, status, setHeaders);\n    responseStarted = true;\n    int bufferSize = contentLength > 0 ? (int) contentLength : this.bufferSize;\n    ctx.channel().eventLoop().execute(() -> {\n      // Headers\n      ctx.write(rsp, ctx.voidPromise());\n      // Body\n      ctx.write(new ChunkedNioStream(channel, bufferSize), ctx.voidPromise());\n      // Finish\n      ctx.writeAndFlush(EMPTY_LAST_CONTENT).addListener(this);\n    });\n    return this;\n  }\n\n  @Nonnull @Override public Context send(@Nonnull InputStream in) {\n    if (in instanceof FileInputStream) {\n      // use channel\n      return send(((FileInputStream) in).getChannel());\n    }\n    try {\n      prepareChunked();\n      long len = responseLength();\n      ByteRange range = ByteRange.parse(req.headers().get(RANGE), len)\n          .apply(this);\n      ChunkedStream chunkedStream = new ChunkedStream(range.apply(in), bufferSize);\n\n      DefaultHttpResponse rsp = new DefaultHttpResponse(HttpVersion.HTTP_1_1, status, setHeaders);\n      responseStarted = true;\n      ctx.channel().eventLoop().execute(() -> {\n        // Headers\n        ctx.write(rsp, ctx.voidPromise());\n        // Body\n        ctx.write(chunkedStream, ctx.voidPromise());\n        // Finish\n        ctx.writeAndFlush(EMPTY_LAST_CONTENT).addListener(this);\n      });\n      return this;\n    } catch (Exception x) {\n      throw SneakyThrows.propagate(x);\n    }\n  }\n\n  @Nonnull @Override public Context send(@Nonnull FileChannel file) {\n    try {\n      long len = file.size();\n      setHeaders.set(CONTENT_LENGTH, Long.toString(len));\n\n      ByteRange range = ByteRange.parse(req.headers().get(RANGE), len)\n          .apply(this);\n\n      DefaultHttpResponse rsp = new DefaultHttpResponse(HttpVersion.HTTP_1_1, status, setHeaders);\n      responseStarted = true;\n      ctx.channel().eventLoop().execute(() -> {\n        // Headers\n        ctx.write(rsp, ctx.voidPromise());\n        // Body\n        ctx.write(new DefaultFileRegion(file, range.getStart(), range.getEnd()), ctx.voidPromise());\n        // Finish\n        ctx.writeAndFlush(EMPTY_LAST_CONTENT).addListener(this);\n      });\n    } catch (IOException x) {\n      throw SneakyThrows.propagate(x);\n    }\n    return this;\n  }\n\n  @Override public boolean isResponseStarted() {\n    return responseStarted;\n  }\n\n  @Override public boolean getResetHeadersOnError() {\n    return resetHeadersOnError == null\n        ? getRouter().getRouterOptions().getResetHeadersOnError()\n        : resetHeadersOnError.booleanValue();\n  }\n\n  @Override public Context setResetHeadersOnError(boolean value) {\n    this.resetHeadersOnError = value;\n    return this;\n  }\n\n  @Nonnull @Override public Context send(StatusCode statusCode) {\n    responseStarted = true;\n    if (!setHeaders.contains(CONTENT_LENGTH)) {\n      setHeaders.set(CONTENT_LENGTH, \"0\");\n    }\n    DefaultFullHttpResponse rsp = new DefaultFullHttpResponse(HTTP_1_1,\n        HttpResponseStatus.valueOf(statusCode.value()), Unpooled.EMPTY_BUFFER, setHeaders,\n        NO_TRAILING);\n    ctx.writeAndFlush(rsp).addListener(this);\n    return this;\n  }\n\n  @Override public void operationComplete(ChannelFuture future) {\n    try {\n      ifSaveSession();\n      destroy(future.cause());\n    } finally {\n      if (!isKeepAlive(req)) {\n        future.channel().close();\n      }\n    }\n  }\n\n  private void ifSaveSession() {\n    Session session = (Session) getAttributes().get(Session.NAME);\n    if (session != null && (session.isNew() || session.isModify())) {\n      SessionStore store = router.getSessionStore();\n      store.saveSession(this, session);\n    }\n  }\n\n  private NettyOutputStream newOutputStream() {\n    prepareChunked();\n    return new NettyOutputStream(ctx, bufferSize,\n        new DefaultHttpResponse(req.protocolVersion(), status, setHeaders), this);\n  }\n\n  void destroy(Throwable cause) {\n    if (cause != null) {\n      if (Server.connectionLost(cause)) {\n        router.getLog()\n            .debug(\"exception found while sending response {} {}\", getMethod(), pathString(),\n                cause);\n      } else {\n        router.getLog()\n            .error(\"exception found while sending response {} {}\", getMethod(), pathString(),\n                cause);\n      }\n    }\n    if (files != null) {\n      for (FileUpload file : files) {\n        try {\n          file.destroy();\n        } catch (Exception x) {\n          router.getLog().debug(\"file upload destroy resulted in exception\", x);\n        }\n      }\n      files = null;\n    }\n    if (decoder != null) {\n      try {\n        decoder.destroy();\n      } catch (Exception x) {\n        router.getLog().debug(\"body decoder destroy resulted in exception\", x);\n      }\n      decoder = null;\n    }\n    release(req);\n  }\n\n  private FileUpload register(FileUpload upload) {\n    if (this.files == null) {\n      this.files = new ArrayList<>();\n    }\n    this.files.add(upload);\n    return upload;\n  }\n\n  private void decodeForm(HttpRequest req, Formdata form) {\n    if (decoder == null) {\n      // empty/bad form\n      return;\n    }\n    try {\n      while (decoder.hasNext()) {\n        HttpData next = (HttpData) decoder.next();\n        if (next.getHttpDataType() == InterfaceHttpData.HttpDataType.FileUpload) {\n          ((Multipart) form).put(next.getName(),\n              register(new NettyFileUpload(router.getTmpdir(),\n                  (io.netty.handler.codec.http.multipart.FileUpload) next)));\n        } else {\n          form.put(next.getName(), next.getString(UTF_8));\n        }\n      }\n    } catch (HttpPostRequestDecoder.EndOfDataDecoderException x) {\n      // ignore, silly netty\n    } catch (Exception x) {\n      throw SneakyThrows.propagate(x);\n    } finally {\n      release(req);\n    }\n  }\n\n  private static void release(HttpRequest req) {\n    if (req instanceof ReferenceCounted) {\n      ReferenceCounted ref = (ReferenceCounted) req;\n      if (ref.refCnt() > 0) {\n        ref.release();\n      }\n    }\n  }\n\n  private long responseLength() {\n    String len = setHeaders.get(CONTENT_LENGTH);\n    return len == null ? -1 : Long.parseLong(len);\n  }\n\n  private void prepareChunked() {\n    // remove flusher, doesn't play well with streaming/chunked responses\n    ChannelPipeline pipeline = ctx.pipeline();\n    if (pipeline.get(\"chunker\") == null) {\n      pipeline.addAfter(\"encoder\", \"chunker\", new ChunkedWriteHandler());\n    }\n    if (!setHeaders.contains(CONTENT_LENGTH)) {\n      setHeaders.set(TRANSFER_ENCODING, CHUNKED);\n    }\n  }\n\n  @Override public String toString() {\n    return getMethod() + \" \" + pathString();\n  }\n}\n"], "filenames": ["modules/jooby-netty/src/main/java/io/jooby/internal/netty/NettyContext.java"], "buggy_code_start_loc": [102], "buggy_code_end_loc": [103], "fixing_code_start_loc": [102], "fixing_code_end_loc": [103], "type": "NVD-CWE-Other", "message": "This affects the package io.jooby:jooby-netty before 1.6.9, from 2.0.0 and before 2.2.1. The DefaultHttpHeaders is set to false which means it does not validates that the header isn't being abused for HTTP Response Splitting.", "other": {"cve": {"id": "CVE-2020-7622", "sourceIdentifier": "report@snyk.io", "published": "2020-04-06T15:15:12.770", "lastModified": "2021-08-03T15:24:12.983", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "This affects the package io.jooby:jooby-netty before 1.6.9, from 2.0.0 and before 2.2.1. The DefaultHttpHeaders is set to false which means it does not validates that the header isn't being abused for HTTP Response Splitting."}, {"lang": "es", "value": "Esto afecta al paquete io.jooby:jooby-netty anterior a la versi\u00f3n 1.6.9, desde la versi\u00f3n 2.0.0 y anterior a la 2.2.1. El DefaultHttpHeaders se establece en false lo que significa que no valida que la cabecera no est\u00e1 siendo abusada para la divisi\u00f3n de la respuesta HTTP."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}, {"source": "report@snyk.io", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 2.5}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-Other"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:jooby:jooby:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.6.9", "matchCriteriaId": "677363FC-9D5B-4A14-ABFA-276A4721FE58"}, {"vulnerable": true, "criteria": "cpe:2.3:a:jooby:jooby:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.0.0", "versionEndExcluding": "2.2.1", "matchCriteriaId": "B3F2665A-CE12-49D1-B93E-9A4D7D701839"}]}]}], "references": [{"url": "https://github.com/jooby-project/jooby/commit/b66e3342cf95205324023cfdf2cb5811e8a6dcf4", "source": "report@snyk.io", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/jooby-project/jooby/security/advisories/GHSA-gv3v-92v6-m48j", "source": "report@snyk.io", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://snyk.io/vuln/SNYK-JAVA-IOJOOBY-564249", "source": "report@snyk.io", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/jooby-project/jooby/commit/b66e3342cf95205324023cfdf2cb5811e8a6dcf4"}}