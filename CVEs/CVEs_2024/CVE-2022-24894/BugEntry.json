{"buggy_code": ["<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * This code is partially based on the Rack-Cache library by Ryan Tomayko,\n * which is released under the MIT license.\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\HttpKernel\\HttpCache;\n\nuse Symfony\\Component\\HttpFoundation\\Request;\nuse Symfony\\Component\\HttpFoundation\\Response;\n\n/**\n * Store implements all the logic for storing cache metadata (Request and Response headers).\n *\n * @author Fabien Potencier <fabien@symfony.com>\n */\nclass Store implements StoreInterface\n{\n    protected $root;\n    private $keyCache;\n    private $locks;\n\n    /**\n     * @throws \\RuntimeException\n     */\n    public function __construct(string $root)\n    {\n        $this->root = $root;\n        if (!file_exists($this->root) && !@mkdir($this->root, 0777, true) && !is_dir($this->root)) {\n            throw new \\RuntimeException(sprintf('Unable to create the store directory (%s).', $this->root));\n        }\n        $this->keyCache = new \\SplObjectStorage();\n        $this->locks = [];\n    }\n\n    /**\n     * Cleanups storage.\n     */\n    public function cleanup()\n    {\n        // unlock everything\n        foreach ($this->locks as $lock) {\n            flock($lock, \\LOCK_UN);\n            fclose($lock);\n        }\n\n        $this->locks = [];\n    }\n\n    /**\n     * Tries to lock the cache for a given Request, without blocking.\n     *\n     * @return bool|string true if the lock is acquired, the path to the current lock otherwise\n     */\n    public function lock(Request $request)\n    {\n        $key = $this->getCacheKey($request);\n\n        if (!isset($this->locks[$key])) {\n            $path = $this->getPath($key);\n            if (!file_exists(\\dirname($path)) && false === @mkdir(\\dirname($path), 0777, true) && !is_dir(\\dirname($path))) {\n                return $path;\n            }\n            $h = fopen($path, 'c');\n            if (!flock($h, \\LOCK_EX | \\LOCK_NB)) {\n                fclose($h);\n\n                return $path;\n            }\n\n            $this->locks[$key] = $h;\n        }\n\n        return true;\n    }\n\n    /**\n     * Releases the lock for the given Request.\n     *\n     * @return bool False if the lock file does not exist or cannot be unlocked, true otherwise\n     */\n    public function unlock(Request $request)\n    {\n        $key = $this->getCacheKey($request);\n\n        if (isset($this->locks[$key])) {\n            flock($this->locks[$key], \\LOCK_UN);\n            fclose($this->locks[$key]);\n            unset($this->locks[$key]);\n\n            return true;\n        }\n\n        return false;\n    }\n\n    public function isLocked(Request $request)\n    {\n        $key = $this->getCacheKey($request);\n\n        if (isset($this->locks[$key])) {\n            return true; // shortcut if lock held by this process\n        }\n\n        if (!file_exists($path = $this->getPath($key))) {\n            return false;\n        }\n\n        $h = fopen($path, 'r');\n        flock($h, \\LOCK_EX | \\LOCK_NB, $wouldBlock);\n        flock($h, \\LOCK_UN); // release the lock we just acquired\n        fclose($h);\n\n        return (bool) $wouldBlock;\n    }\n\n    /**\n     * Locates a cached Response for the Request provided.\n     *\n     * @return Response|null A Response instance, or null if no cache entry was found\n     */\n    public function lookup(Request $request)\n    {\n        $key = $this->getCacheKey($request);\n\n        if (!$entries = $this->getMetadata($key)) {\n            return null;\n        }\n\n        // find a cached entry that matches the request.\n        $match = null;\n        foreach ($entries as $entry) {\n            if ($this->requestsMatch(isset($entry[1]['vary'][0]) ? implode(', ', $entry[1]['vary']) : '', $request->headers->all(), $entry[0])) {\n                $match = $entry;\n\n                break;\n            }\n        }\n\n        if (null === $match) {\n            return null;\n        }\n\n        $headers = $match[1];\n        if (file_exists($path = $this->getPath($headers['x-content-digest'][0]))) {\n            return $this->restoreResponse($headers, $path);\n        }\n\n        // TODO the metaStore referenced an entity that doesn't exist in\n        // the entityStore. We definitely want to return nil but we should\n        // also purge the entry from the meta-store when this is detected.\n        return null;\n    }\n\n    /**\n     * Writes a cache entry to the store for the given Request and Response.\n     *\n     * Existing entries are read and any that match the response are removed. This\n     * method calls write with the new list of cache entries.\n     *\n     * @return string The key under which the response is stored\n     *\n     * @throws \\RuntimeException\n     */\n    public function write(Request $request, Response $response)\n    {\n        $key = $this->getCacheKey($request);\n        $storedEnv = $this->persistRequest($request);\n\n        if ($response->headers->has('X-Body-File')) {\n            // Assume the response came from disk, but at least perform some safeguard checks\n            if (!$response->headers->has('X-Content-Digest')) {\n                throw new \\RuntimeException('A restored response must have the X-Content-Digest header.');\n            }\n\n            $digest = $response->headers->get('X-Content-Digest');\n            if ($this->getPath($digest) !== $response->headers->get('X-Body-File')) {\n                throw new \\RuntimeException('X-Body-File and X-Content-Digest do not match.');\n            }\n            // Everything seems ok, omit writing content to disk\n        } else {\n            $digest = $this->generateContentDigest($response);\n            $response->headers->set('X-Content-Digest', $digest);\n\n            if (!$this->save($digest, $response->getContent(), false)) {\n                throw new \\RuntimeException('Unable to store the entity.');\n            }\n\n            if (!$response->headers->has('Transfer-Encoding')) {\n                $response->headers->set('Content-Length', \\strlen($response->getContent()));\n            }\n        }\n\n        // read existing cache entries, remove non-varying, and add this one to the list\n        $entries = [];\n        $vary = $response->headers->get('vary');\n        foreach ($this->getMetadata($key) as $entry) {\n            if (!isset($entry[1]['vary'][0])) {\n                $entry[1]['vary'] = [''];\n            }\n\n            if ($entry[1]['vary'][0] != $vary || !$this->requestsMatch($vary, $entry[0], $storedEnv)) {\n                $entries[] = $entry;\n            }\n        }\n\n        $headers = $this->persistResponse($response);\n        unset($headers['age']);\n\n        array_unshift($entries, [$storedEnv, $headers]);\n\n        if (!$this->save($key, serialize($entries))) {\n            throw new \\RuntimeException('Unable to store the metadata.');\n        }\n\n        return $key;\n    }\n\n    /**\n     * Returns content digest for $response.\n     *\n     * @return string\n     */\n    protected function generateContentDigest(Response $response)\n    {\n        return 'en'.hash('sha256', $response->getContent());\n    }\n\n    /**\n     * Invalidates all cache entries that match the request.\n     *\n     * @throws \\RuntimeException\n     */\n    public function invalidate(Request $request)\n    {\n        $modified = false;\n        $key = $this->getCacheKey($request);\n\n        $entries = [];\n        foreach ($this->getMetadata($key) as $entry) {\n            $response = $this->restoreResponse($entry[1]);\n            if ($response->isFresh()) {\n                $response->expire();\n                $modified = true;\n                $entries[] = [$entry[0], $this->persistResponse($response)];\n            } else {\n                $entries[] = $entry;\n            }\n        }\n\n        if ($modified && !$this->save($key, serialize($entries))) {\n            throw new \\RuntimeException('Unable to store the metadata.');\n        }\n    }\n\n    /**\n     * Determines whether two Request HTTP header sets are non-varying based on\n     * the vary response header value provided.\n     *\n     * @param string $vary A Response vary header\n     * @param array  $env1 A Request HTTP header array\n     * @param array  $env2 A Request HTTP header array\n     */\n    private function requestsMatch(?string $vary, array $env1, array $env2): bool\n    {\n        if (empty($vary)) {\n            return true;\n        }\n\n        foreach (preg_split('/[\\s,]+/', $vary) as $header) {\n            $key = str_replace('_', '-', strtolower($header));\n            $v1 = $env1[$key] ?? null;\n            $v2 = $env2[$key] ?? null;\n            if ($v1 !== $v2) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    /**\n     * Gets all data associated with the given key.\n     *\n     * Use this method only if you know what you are doing.\n     */\n    private function getMetadata(string $key): array\n    {\n        if (!$entries = $this->load($key)) {\n            return [];\n        }\n\n        return unserialize($entries) ?: [];\n    }\n\n    /**\n     * Purges data for the given URL.\n     *\n     * This method purges both the HTTP and the HTTPS version of the cache entry.\n     *\n     * @param string $url A URL\n     *\n     * @return bool true if the URL exists with either HTTP or HTTPS scheme and has been purged, false otherwise\n     */\n    public function purge($url)\n    {\n        $http = preg_replace('#^https:#', 'http:', $url);\n        $https = preg_replace('#^http:#', 'https:', $url);\n\n        $purgedHttp = $this->doPurge($http);\n        $purgedHttps = $this->doPurge($https);\n\n        return $purgedHttp || $purgedHttps;\n    }\n\n    /**\n     * Purges data for the given URL.\n     */\n    private function doPurge(string $url): bool\n    {\n        $key = $this->getCacheKey(Request::create($url));\n        if (isset($this->locks[$key])) {\n            flock($this->locks[$key], \\LOCK_UN);\n            fclose($this->locks[$key]);\n            unset($this->locks[$key]);\n        }\n\n        if (file_exists($path = $this->getPath($key))) {\n            unlink($path);\n\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * Loads data for the given key.\n     */\n    private function load(string $key): ?string\n    {\n        $path = $this->getPath($key);\n\n        return file_exists($path) && false !== ($contents = @file_get_contents($path)) ? $contents : null;\n    }\n\n    /**\n     * Save data for the given key.\n     */\n    private function save(string $key, string $data, bool $overwrite = true): bool\n    {\n        $path = $this->getPath($key);\n\n        if (!$overwrite && file_exists($path)) {\n            return true;\n        }\n\n        if (isset($this->locks[$key])) {\n            $fp = $this->locks[$key];\n            @ftruncate($fp, 0);\n            @fseek($fp, 0);\n            $len = @fwrite($fp, $data);\n            if (\\strlen($data) !== $len) {\n                @ftruncate($fp, 0);\n\n                return false;\n            }\n        } else {\n            if (!file_exists(\\dirname($path)) && false === @mkdir(\\dirname($path), 0777, true) && !is_dir(\\dirname($path))) {\n                return false;\n            }\n\n            $tmpFile = tempnam(\\dirname($path), basename($path));\n            if (false === $fp = @fopen($tmpFile, 'w')) {\n                @unlink($tmpFile);\n\n                return false;\n            }\n            @fwrite($fp, $data);\n            @fclose($fp);\n\n            if ($data != file_get_contents($tmpFile)) {\n                @unlink($tmpFile);\n\n                return false;\n            }\n\n            if (false === @rename($tmpFile, $path)) {\n                @unlink($tmpFile);\n\n                return false;\n            }\n        }\n\n        @chmod($path, 0666 & ~umask());\n\n        return true;\n    }\n\n    public function getPath($key)\n    {\n        return $this->root.\\DIRECTORY_SEPARATOR.substr($key, 0, 2).\\DIRECTORY_SEPARATOR.substr($key, 2, 2).\\DIRECTORY_SEPARATOR.substr($key, 4, 2).\\DIRECTORY_SEPARATOR.substr($key, 6);\n    }\n\n    /**\n     * Generates a cache key for the given Request.\n     *\n     * This method should return a key that must only depend on a\n     * normalized version of the request URI.\n     *\n     * If the same URI can have more than one representation, based on some\n     * headers, use a Vary header to indicate them, and each representation will\n     * be stored independently under the same cache key.\n     *\n     * @return string A key for the given Request\n     */\n    protected function generateCacheKey(Request $request)\n    {\n        return 'md'.hash('sha256', $request->getUri());\n    }\n\n    /**\n     * Returns a cache key for the given Request.\n     */\n    private function getCacheKey(Request $request): string\n    {\n        if (isset($this->keyCache[$request])) {\n            return $this->keyCache[$request];\n        }\n\n        return $this->keyCache[$request] = $this->generateCacheKey($request);\n    }\n\n    /**\n     * Persists the Request HTTP headers.\n     */\n    private function persistRequest(Request $request): array\n    {\n        return $request->headers->all();\n    }\n\n    /**\n     * Persists the Response HTTP headers.\n     */\n    private function persistResponse(Response $response): array\n    {\n        $headers = $response->headers->all();\n        $headers['X-Status'] = [$response->getStatusCode()];\n\n        return $headers;\n    }\n\n    /**\n     * Restores a Response from the HTTP headers and body.\n     */\n    private function restoreResponse(array $headers, string $path = null): Response\n    {\n        $status = $headers['X-Status'][0];\n        unset($headers['X-Status']);\n\n        if (null !== $path) {\n            $headers['X-Body-File'] = [$path];\n        }\n\n        return new Response($path, $status, $headers);\n    }\n}\n", "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\HttpKernel\\Tests\\HttpCache;\n\nuse PHPUnit\\Framework\\TestCase;\nuse Symfony\\Component\\HttpFoundation\\Request;\nuse Symfony\\Component\\HttpFoundation\\Response;\nuse Symfony\\Component\\HttpKernel\\HttpCache\\Store;\n\nclass StoreTest extends TestCase\n{\n    protected $request;\n    protected $response;\n\n    /**\n     * @var Store\n     */\n    protected $store;\n\n    protected function setUp(): void\n    {\n        $this->request = Request::create('/');\n        $this->response = new Response('hello world', 200, []);\n\n        HttpCacheTestCase::clearDirectory(sys_get_temp_dir().'/http_cache');\n\n        $this->store = new Store(sys_get_temp_dir().'/http_cache');\n    }\n\n    protected function tearDown(): void\n    {\n        $this->store = null;\n        $this->request = null;\n        $this->response = null;\n\n        HttpCacheTestCase::clearDirectory(sys_get_temp_dir().'/http_cache');\n    }\n\n    public function testReadsAnEmptyArrayWithReadWhenNothingCachedAtKey()\n    {\n        $this->assertEmpty($this->getStoreMetadata('/nothing'));\n    }\n\n    public function testUnlockFileThatDoesExist()\n    {\n        $this->storeSimpleEntry();\n        $this->store->lock($this->request);\n\n        $this->assertTrue($this->store->unlock($this->request));\n    }\n\n    public function testUnlockFileThatDoesNotExist()\n    {\n        $this->assertFalse($this->store->unlock($this->request));\n    }\n\n    public function testRemovesEntriesForKeyWithPurge()\n    {\n        $request = Request::create('/foo');\n        $this->store->write($request, new Response('foo'));\n\n        $metadata = $this->getStoreMetadata($request);\n        $this->assertNotEmpty($metadata);\n\n        $this->assertTrue($this->store->purge('/foo'));\n        $this->assertEmpty($this->getStoreMetadata($request));\n\n        // cached content should be kept after purging\n        $path = $this->store->getPath($metadata[0][1]['x-content-digest'][0]);\n        $this->assertTrue(is_file($path));\n\n        $this->assertFalse($this->store->purge('/bar'));\n    }\n\n    public function testStoresACacheEntry()\n    {\n        $cacheKey = $this->storeSimpleEntry();\n\n        $this->assertNotEmpty($this->getStoreMetadata($cacheKey));\n    }\n\n    public function testSetsTheXContentDigestResponseHeaderBeforeStoring()\n    {\n        $cacheKey = $this->storeSimpleEntry();\n        $entries = $this->getStoreMetadata($cacheKey);\n        [, $res] = $entries[0];\n\n        $this->assertEquals('en9f86d081884c7d659a2feaa0c55ad015a3bf4f1b2b0b822cd15d6c15b0f00a08', $res['x-content-digest'][0]);\n    }\n\n    public function testDoesNotTrustXContentDigestFromUpstream()\n    {\n        $response = new Response('test', 200, ['X-Content-Digest' => 'untrusted-from-elsewhere']);\n\n        $cacheKey = $this->store->write($this->request, $response);\n        $entries = $this->getStoreMetadata($cacheKey);\n        [, $res] = $entries[0];\n\n        $this->assertEquals('en9f86d081884c7d659a2feaa0c55ad015a3bf4f1b2b0b822cd15d6c15b0f00a08', $res['x-content-digest'][0]);\n        $this->assertEquals('en9f86d081884c7d659a2feaa0c55ad015a3bf4f1b2b0b822cd15d6c15b0f00a08', $response->headers->get('X-Content-Digest'));\n    }\n\n    public function testWritesResponseEvenIfXContentDigestIsPresent()\n    {\n        // Prime the store\n        $this->store->write($this->request, new Response('test', 200, ['X-Content-Digest' => 'untrusted-from-elsewhere']));\n\n        $response = $this->store->lookup($this->request);\n        $this->assertNotNull($response);\n    }\n\n    public function testWritingARestoredResponseDoesNotCorruptCache()\n    {\n        /*\n         * This covers the regression reported in https://github.com/symfony/symfony/issues/37174.\n         *\n         * A restored response does *not* load the body, but only keep the file path in a special X-Body-File\n         * header. For reasons (?), the file path was also used as the restored response body.\n         * It would be up to others (HttpCache...?) to honor this header and actually load the response content\n         * from there.\n         *\n         * When a restored response was stored again, the Store itself would ignore the header. In the first\n         * step, this would compute a new Content Digest based on the file path in the restored response body;\n         * this is covered by \"Checkpoint 1\" below. But, since the X-Body-File header was left untouched (Checkpoint 2), downstream\n         * code (HttpCache...) would not immediately notice.\n         *\n         * Only upon performing the lookup for a second time, we'd get a Response where the (wrong) Content Digest\n         * is also reflected in the X-Body-File header, this time also producing wrong content when the downstream\n         * evaluates it.\n         */\n        $this->store->write($this->request, $this->response);\n        $digest = $this->response->headers->get('X-Content-Digest');\n        $path = $this->getStorePath($digest);\n\n        $response = $this->store->lookup($this->request);\n        $this->store->write($this->request, $response);\n        $this->assertEquals($digest, $response->headers->get('X-Content-Digest')); // Checkpoint 1\n        $this->assertEquals($path, $response->headers->get('X-Body-File')); // Checkpoint 2\n\n        $response = $this->store->lookup($this->request);\n        $this->assertEquals($digest, $response->headers->get('X-Content-Digest'));\n        $this->assertEquals($path, $response->headers->get('X-Body-File'));\n    }\n\n    public function testFindsAStoredEntryWithLookup()\n    {\n        $this->storeSimpleEntry();\n        $response = $this->store->lookup($this->request);\n\n        $this->assertNotNull($response);\n        $this->assertInstanceOf(Response::class, $response);\n    }\n\n    public function testDoesNotFindAnEntryWithLookupWhenNoneExists()\n    {\n        $request = Request::create('/test', 'get', [], [], [], ['HTTP_FOO' => 'Foo', 'HTTP_BAR' => 'Bar']);\n\n        $this->assertNull($this->store->lookup($request));\n    }\n\n    public function testCanonizesUrlsForCacheKeys()\n    {\n        $this->storeSimpleEntry($path = '/test?x=y&p=q');\n        $hitsReq = Request::create($path);\n        $missReq = Request::create('/test?p=x');\n\n        $this->assertNotNull($this->store->lookup($hitsReq));\n        $this->assertNull($this->store->lookup($missReq));\n    }\n\n    public function testDoesNotFindAnEntryWithLookupWhenTheBodyDoesNotExist()\n    {\n        $this->storeSimpleEntry();\n        $this->assertNotNull($this->response->headers->get('X-Content-Digest'));\n        $path = $this->getStorePath($this->response->headers->get('X-Content-Digest'));\n        @unlink($path);\n        $this->assertNull($this->store->lookup($this->request));\n    }\n\n    public function testRestoresResponseHeadersProperlyWithLookup()\n    {\n        $this->storeSimpleEntry();\n        $response = $this->store->lookup($this->request);\n\n        $this->assertEquals($response->headers->all(), array_merge(['content-length' => 4, 'x-body-file' => [$this->getStorePath($response->headers->get('X-Content-Digest'))]], $this->response->headers->all()));\n    }\n\n    public function testRestoresResponseContentFromEntityStoreWithLookup()\n    {\n        $this->storeSimpleEntry();\n        $response = $this->store->lookup($this->request);\n        $this->assertEquals($this->getStorePath('en'.hash('sha256', 'test')), $response->getContent());\n    }\n\n    public function testInvalidatesMetaAndEntityStoreEntriesWithInvalidate()\n    {\n        $this->storeSimpleEntry();\n        $this->store->invalidate($this->request);\n        $response = $this->store->lookup($this->request);\n        $this->assertInstanceOf(Response::class, $response);\n        $this->assertFalse($response->isFresh());\n    }\n\n    public function testSucceedsQuietlyWhenInvalidateCalledWithNoMatchingEntries()\n    {\n        $req = Request::create('/test');\n        $this->store->invalidate($req);\n        $this->assertNull($this->store->lookup($this->request));\n    }\n\n    public function testDoesNotReturnEntriesThatVaryWithLookup()\n    {\n        $req1 = Request::create('/test', 'get', [], [], [], ['HTTP_FOO' => 'Foo', 'HTTP_BAR' => 'Bar']);\n        $req2 = Request::create('/test', 'get', [], [], [], ['HTTP_FOO' => 'Bling', 'HTTP_BAR' => 'Bam']);\n        $res = new Response('test', 200, ['Vary' => 'Foo Bar']);\n        $this->store->write($req1, $res);\n\n        $this->assertNull($this->store->lookup($req2));\n    }\n\n    public function testDoesNotReturnEntriesThatSlightlyVaryWithLookup()\n    {\n        $req1 = Request::create('/test', 'get', [], [], [], ['HTTP_FOO' => 'Foo', 'HTTP_BAR' => 'Bar']);\n        $req2 = Request::create('/test', 'get', [], [], [], ['HTTP_FOO' => 'Foo', 'HTTP_BAR' => 'Bam']);\n        $res = new Response('test', 200, ['Vary' => ['Foo', 'Bar']]);\n        $this->store->write($req1, $res);\n\n        $this->assertNull($this->store->lookup($req2));\n    }\n\n    public function testStoresMultipleResponsesForEachVaryCombination()\n    {\n        $req1 = Request::create('/test', 'get', [], [], [], ['HTTP_FOO' => 'Foo', 'HTTP_BAR' => 'Bar']);\n        $res1 = new Response('test 1', 200, ['Vary' => 'Foo Bar']);\n        $key = $this->store->write($req1, $res1);\n\n        $req2 = Request::create('/test', 'get', [], [], [], ['HTTP_FOO' => 'Bling', 'HTTP_BAR' => 'Bam']);\n        $res2 = new Response('test 2', 200, ['Vary' => 'Foo Bar']);\n        $this->store->write($req2, $res2);\n\n        $req3 = Request::create('/test', 'get', [], [], [], ['HTTP_FOO' => 'Baz', 'HTTP_BAR' => 'Boom']);\n        $res3 = new Response('test 3', 200, ['Vary' => 'Foo Bar']);\n        $this->store->write($req3, $res3);\n\n        $this->assertEquals($this->getStorePath('en'.hash('sha256', 'test 3')), $this->store->lookup($req3)->getContent());\n        $this->assertEquals($this->getStorePath('en'.hash('sha256', 'test 2')), $this->store->lookup($req2)->getContent());\n        $this->assertEquals($this->getStorePath('en'.hash('sha256', 'test 1')), $this->store->lookup($req1)->getContent());\n\n        $this->assertCount(3, $this->getStoreMetadata($key));\n    }\n\n    public function testOverwritesNonVaryingResponseWithStore()\n    {\n        $req1 = Request::create('/test', 'get', [], [], [], ['HTTP_FOO' => 'Foo', 'HTTP_BAR' => 'Bar']);\n        $res1 = new Response('test 1', 200, ['Vary' => 'Foo Bar']);\n        $this->store->write($req1, $res1);\n        $this->assertEquals($this->getStorePath('en'.hash('sha256', 'test 1')), $this->store->lookup($req1)->getContent());\n\n        $req2 = Request::create('/test', 'get', [], [], [], ['HTTP_FOO' => 'Bling', 'HTTP_BAR' => 'Bam']);\n        $res2 = new Response('test 2', 200, ['Vary' => 'Foo Bar']);\n        $this->store->write($req2, $res2);\n        $this->assertEquals($this->getStorePath('en'.hash('sha256', 'test 2')), $this->store->lookup($req2)->getContent());\n\n        $req3 = Request::create('/test', 'get', [], [], [], ['HTTP_FOO' => 'Foo', 'HTTP_BAR' => 'Bar']);\n        $res3 = new Response('test 3', 200, ['Vary' => 'Foo Bar']);\n        $key = $this->store->write($req3, $res3);\n        $this->assertEquals($this->getStorePath('en'.hash('sha256', 'test 3')), $this->store->lookup($req3)->getContent());\n\n        $this->assertCount(2, $this->getStoreMetadata($key));\n    }\n\n    public function testLocking()\n    {\n        $req = Request::create('/test', 'get', [], [], [], ['HTTP_FOO' => 'Foo', 'HTTP_BAR' => 'Bar']);\n        $this->assertTrue($this->store->lock($req));\n\n        $this->store->lock($req);\n        $this->assertTrue($this->store->isLocked($req));\n\n        $this->store->unlock($req);\n        $this->assertFalse($this->store->isLocked($req));\n    }\n\n    public function testPurgeHttps()\n    {\n        $request = Request::create('https://example.com/foo');\n        $this->store->write($request, new Response('foo'));\n\n        $this->assertNotEmpty($this->getStoreMetadata($request));\n\n        $this->assertTrue($this->store->purge('https://example.com/foo'));\n        $this->assertEmpty($this->getStoreMetadata($request));\n    }\n\n    public function testPurgeHttpAndHttps()\n    {\n        $requestHttp = Request::create('https://example.com/foo');\n        $this->store->write($requestHttp, new Response('foo'));\n\n        $requestHttps = Request::create('http://example.com/foo');\n        $this->store->write($requestHttps, new Response('foo'));\n\n        $this->assertNotEmpty($this->getStoreMetadata($requestHttp));\n        $this->assertNotEmpty($this->getStoreMetadata($requestHttps));\n\n        $this->assertTrue($this->store->purge('http://example.com/foo'));\n        $this->assertEmpty($this->getStoreMetadata($requestHttp));\n        $this->assertEmpty($this->getStoreMetadata($requestHttps));\n    }\n\n    protected function storeSimpleEntry($path = null, $headers = [])\n    {\n        if (null === $path) {\n            $path = '/test';\n        }\n\n        $this->request = Request::create($path, 'get', [], [], [], $headers);\n        $this->response = new Response('test', 200, ['Cache-Control' => 'max-age=420']);\n\n        return $this->store->write($this->request, $this->response);\n    }\n\n    protected function getStoreMetadata($key)\n    {\n        $r = new \\ReflectionObject($this->store);\n        $m = $r->getMethod('getMetadata');\n        $m->setAccessible(true);\n\n        if ($key instanceof Request) {\n            $m1 = $r->getMethod('getCacheKey');\n            $m1->setAccessible(true);\n            $key = $m1->invoke($this->store, $key);\n        }\n\n        return $m->invoke($this->store, $key);\n    }\n\n    protected function getStorePath($key)\n    {\n        $r = new \\ReflectionObject($this->store);\n        $m = $r->getMethod('getPath');\n        $m->setAccessible(true);\n\n        return $m->invoke($this->store, $key);\n    }\n}\n"], "fixing_code": ["<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * This code is partially based on the Rack-Cache library by Ryan Tomayko,\n * which is released under the MIT license.\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\HttpKernel\\HttpCache;\n\nuse Symfony\\Component\\HttpFoundation\\Request;\nuse Symfony\\Component\\HttpFoundation\\Response;\n\n/**\n * Store implements all the logic for storing cache metadata (Request and Response headers).\n *\n * @author Fabien Potencier <fabien@symfony.com>\n */\nclass Store implements StoreInterface\n{\n    protected $root;\n    private $keyCache;\n    private $locks = [];\n    private $options;\n\n    /**\n     * Constructor.\n     *\n     * The available options are:\n     *\n     *   * private_headers  Set of response headers that should not be stored\n     *                      when a response is cached. (default: Set-Cookie)\n     *\n     * @throws \\RuntimeException\n     */\n    public function __construct(string $root, array $options = [])\n    {\n        $this->root = $root;\n        if (!file_exists($this->root) && !@mkdir($this->root, 0777, true) && !is_dir($this->root)) {\n            throw new \\RuntimeException(sprintf('Unable to create the store directory (%s).', $this->root));\n        }\n        $this->keyCache = new \\SplObjectStorage();\n        $this->options = array_merge([\n            'private_headers' => ['Set-Cookie'],\n        ], $options);\n    }\n\n    /**\n     * Cleanups storage.\n     */\n    public function cleanup()\n    {\n        // unlock everything\n        foreach ($this->locks as $lock) {\n            flock($lock, \\LOCK_UN);\n            fclose($lock);\n        }\n\n        $this->locks = [];\n    }\n\n    /**\n     * Tries to lock the cache for a given Request, without blocking.\n     *\n     * @return bool|string true if the lock is acquired, the path to the current lock otherwise\n     */\n    public function lock(Request $request)\n    {\n        $key = $this->getCacheKey($request);\n\n        if (!isset($this->locks[$key])) {\n            $path = $this->getPath($key);\n            if (!file_exists(\\dirname($path)) && false === @mkdir(\\dirname($path), 0777, true) && !is_dir(\\dirname($path))) {\n                return $path;\n            }\n            $h = fopen($path, 'c');\n            if (!flock($h, \\LOCK_EX | \\LOCK_NB)) {\n                fclose($h);\n\n                return $path;\n            }\n\n            $this->locks[$key] = $h;\n        }\n\n        return true;\n    }\n\n    /**\n     * Releases the lock for the given Request.\n     *\n     * @return bool False if the lock file does not exist or cannot be unlocked, true otherwise\n     */\n    public function unlock(Request $request)\n    {\n        $key = $this->getCacheKey($request);\n\n        if (isset($this->locks[$key])) {\n            flock($this->locks[$key], \\LOCK_UN);\n            fclose($this->locks[$key]);\n            unset($this->locks[$key]);\n\n            return true;\n        }\n\n        return false;\n    }\n\n    public function isLocked(Request $request)\n    {\n        $key = $this->getCacheKey($request);\n\n        if (isset($this->locks[$key])) {\n            return true; // shortcut if lock held by this process\n        }\n\n        if (!file_exists($path = $this->getPath($key))) {\n            return false;\n        }\n\n        $h = fopen($path, 'r');\n        flock($h, \\LOCK_EX | \\LOCK_NB, $wouldBlock);\n        flock($h, \\LOCK_UN); // release the lock we just acquired\n        fclose($h);\n\n        return (bool) $wouldBlock;\n    }\n\n    /**\n     * Locates a cached Response for the Request provided.\n     *\n     * @return Response|null A Response instance, or null if no cache entry was found\n     */\n    public function lookup(Request $request)\n    {\n        $key = $this->getCacheKey($request);\n\n        if (!$entries = $this->getMetadata($key)) {\n            return null;\n        }\n\n        // find a cached entry that matches the request.\n        $match = null;\n        foreach ($entries as $entry) {\n            if ($this->requestsMatch(isset($entry[1]['vary'][0]) ? implode(', ', $entry[1]['vary']) : '', $request->headers->all(), $entry[0])) {\n                $match = $entry;\n\n                break;\n            }\n        }\n\n        if (null === $match) {\n            return null;\n        }\n\n        $headers = $match[1];\n        if (file_exists($path = $this->getPath($headers['x-content-digest'][0]))) {\n            return $this->restoreResponse($headers, $path);\n        }\n\n        // TODO the metaStore referenced an entity that doesn't exist in\n        // the entityStore. We definitely want to return nil but we should\n        // also purge the entry from the meta-store when this is detected.\n        return null;\n    }\n\n    /**\n     * Writes a cache entry to the store for the given Request and Response.\n     *\n     * Existing entries are read and any that match the response are removed. This\n     * method calls write with the new list of cache entries.\n     *\n     * @return string The key under which the response is stored\n     *\n     * @throws \\RuntimeException\n     */\n    public function write(Request $request, Response $response)\n    {\n        $key = $this->getCacheKey($request);\n        $storedEnv = $this->persistRequest($request);\n\n        if ($response->headers->has('X-Body-File')) {\n            // Assume the response came from disk, but at least perform some safeguard checks\n            if (!$response->headers->has('X-Content-Digest')) {\n                throw new \\RuntimeException('A restored response must have the X-Content-Digest header.');\n            }\n\n            $digest = $response->headers->get('X-Content-Digest');\n            if ($this->getPath($digest) !== $response->headers->get('X-Body-File')) {\n                throw new \\RuntimeException('X-Body-File and X-Content-Digest do not match.');\n            }\n            // Everything seems ok, omit writing content to disk\n        } else {\n            $digest = $this->generateContentDigest($response);\n            $response->headers->set('X-Content-Digest', $digest);\n\n            if (!$this->save($digest, $response->getContent(), false)) {\n                throw new \\RuntimeException('Unable to store the entity.');\n            }\n\n            if (!$response->headers->has('Transfer-Encoding')) {\n                $response->headers->set('Content-Length', \\strlen($response->getContent()));\n            }\n        }\n\n        // read existing cache entries, remove non-varying, and add this one to the list\n        $entries = [];\n        $vary = $response->headers->get('vary');\n        foreach ($this->getMetadata($key) as $entry) {\n            if (!isset($entry[1]['vary'][0])) {\n                $entry[1]['vary'] = [''];\n            }\n\n            if ($entry[1]['vary'][0] != $vary || !$this->requestsMatch($vary, $entry[0], $storedEnv)) {\n                $entries[] = $entry;\n            }\n        }\n\n        $headers = $this->persistResponse($response);\n        unset($headers['age']);\n\n        foreach ($this->options['private_headers'] as $h) {\n            unset($headers[strtolower($h)]);\n        }\n\n        array_unshift($entries, [$storedEnv, $headers]);\n\n        if (!$this->save($key, serialize($entries))) {\n            throw new \\RuntimeException('Unable to store the metadata.');\n        }\n\n        return $key;\n    }\n\n    /**\n     * Returns content digest for $response.\n     *\n     * @return string\n     */\n    protected function generateContentDigest(Response $response)\n    {\n        return 'en'.hash('sha256', $response->getContent());\n    }\n\n    /**\n     * Invalidates all cache entries that match the request.\n     *\n     * @throws \\RuntimeException\n     */\n    public function invalidate(Request $request)\n    {\n        $modified = false;\n        $key = $this->getCacheKey($request);\n\n        $entries = [];\n        foreach ($this->getMetadata($key) as $entry) {\n            $response = $this->restoreResponse($entry[1]);\n            if ($response->isFresh()) {\n                $response->expire();\n                $modified = true;\n                $entries[] = [$entry[0], $this->persistResponse($response)];\n            } else {\n                $entries[] = $entry;\n            }\n        }\n\n        if ($modified && !$this->save($key, serialize($entries))) {\n            throw new \\RuntimeException('Unable to store the metadata.');\n        }\n    }\n\n    /**\n     * Determines whether two Request HTTP header sets are non-varying based on\n     * the vary response header value provided.\n     *\n     * @param string $vary A Response vary header\n     * @param array  $env1 A Request HTTP header array\n     * @param array  $env2 A Request HTTP header array\n     */\n    private function requestsMatch(?string $vary, array $env1, array $env2): bool\n    {\n        if (empty($vary)) {\n            return true;\n        }\n\n        foreach (preg_split('/[\\s,]+/', $vary) as $header) {\n            $key = str_replace('_', '-', strtolower($header));\n            $v1 = $env1[$key] ?? null;\n            $v2 = $env2[$key] ?? null;\n            if ($v1 !== $v2) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    /**\n     * Gets all data associated with the given key.\n     *\n     * Use this method only if you know what you are doing.\n     */\n    private function getMetadata(string $key): array\n    {\n        if (!$entries = $this->load($key)) {\n            return [];\n        }\n\n        return unserialize($entries) ?: [];\n    }\n\n    /**\n     * Purges data for the given URL.\n     *\n     * This method purges both the HTTP and the HTTPS version of the cache entry.\n     *\n     * @param string $url A URL\n     *\n     * @return bool true if the URL exists with either HTTP or HTTPS scheme and has been purged, false otherwise\n     */\n    public function purge($url)\n    {\n        $http = preg_replace('#^https:#', 'http:', $url);\n        $https = preg_replace('#^http:#', 'https:', $url);\n\n        $purgedHttp = $this->doPurge($http);\n        $purgedHttps = $this->doPurge($https);\n\n        return $purgedHttp || $purgedHttps;\n    }\n\n    /**\n     * Purges data for the given URL.\n     */\n    private function doPurge(string $url): bool\n    {\n        $key = $this->getCacheKey(Request::create($url));\n        if (isset($this->locks[$key])) {\n            flock($this->locks[$key], \\LOCK_UN);\n            fclose($this->locks[$key]);\n            unset($this->locks[$key]);\n        }\n\n        if (file_exists($path = $this->getPath($key))) {\n            unlink($path);\n\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * Loads data for the given key.\n     */\n    private function load(string $key): ?string\n    {\n        $path = $this->getPath($key);\n\n        return file_exists($path) && false !== ($contents = @file_get_contents($path)) ? $contents : null;\n    }\n\n    /**\n     * Save data for the given key.\n     */\n    private function save(string $key, string $data, bool $overwrite = true): bool\n    {\n        $path = $this->getPath($key);\n\n        if (!$overwrite && file_exists($path)) {\n            return true;\n        }\n\n        if (isset($this->locks[$key])) {\n            $fp = $this->locks[$key];\n            @ftruncate($fp, 0);\n            @fseek($fp, 0);\n            $len = @fwrite($fp, $data);\n            if (\\strlen($data) !== $len) {\n                @ftruncate($fp, 0);\n\n                return false;\n            }\n        } else {\n            if (!file_exists(\\dirname($path)) && false === @mkdir(\\dirname($path), 0777, true) && !is_dir(\\dirname($path))) {\n                return false;\n            }\n\n            $tmpFile = tempnam(\\dirname($path), basename($path));\n            if (false === $fp = @fopen($tmpFile, 'w')) {\n                @unlink($tmpFile);\n\n                return false;\n            }\n            @fwrite($fp, $data);\n            @fclose($fp);\n\n            if ($data != file_get_contents($tmpFile)) {\n                @unlink($tmpFile);\n\n                return false;\n            }\n\n            if (false === @rename($tmpFile, $path)) {\n                @unlink($tmpFile);\n\n                return false;\n            }\n        }\n\n        @chmod($path, 0666 & ~umask());\n\n        return true;\n    }\n\n    public function getPath($key)\n    {\n        return $this->root.\\DIRECTORY_SEPARATOR.substr($key, 0, 2).\\DIRECTORY_SEPARATOR.substr($key, 2, 2).\\DIRECTORY_SEPARATOR.substr($key, 4, 2).\\DIRECTORY_SEPARATOR.substr($key, 6);\n    }\n\n    /**\n     * Generates a cache key for the given Request.\n     *\n     * This method should return a key that must only depend on a\n     * normalized version of the request URI.\n     *\n     * If the same URI can have more than one representation, based on some\n     * headers, use a Vary header to indicate them, and each representation will\n     * be stored independently under the same cache key.\n     *\n     * @return string A key for the given Request\n     */\n    protected function generateCacheKey(Request $request)\n    {\n        return 'md'.hash('sha256', $request->getUri());\n    }\n\n    /**\n     * Returns a cache key for the given Request.\n     */\n    private function getCacheKey(Request $request): string\n    {\n        if (isset($this->keyCache[$request])) {\n            return $this->keyCache[$request];\n        }\n\n        return $this->keyCache[$request] = $this->generateCacheKey($request);\n    }\n\n    /**\n     * Persists the Request HTTP headers.\n     */\n    private function persistRequest(Request $request): array\n    {\n        return $request->headers->all();\n    }\n\n    /**\n     * Persists the Response HTTP headers.\n     */\n    private function persistResponse(Response $response): array\n    {\n        $headers = $response->headers->all();\n        $headers['X-Status'] = [$response->getStatusCode()];\n\n        return $headers;\n    }\n\n    /**\n     * Restores a Response from the HTTP headers and body.\n     */\n    private function restoreResponse(array $headers, string $path = null): Response\n    {\n        $status = $headers['X-Status'][0];\n        unset($headers['X-Status']);\n\n        if (null !== $path) {\n            $headers['X-Body-File'] = [$path];\n        }\n\n        return new Response($path, $status, $headers);\n    }\n}\n", "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\HttpKernel\\Tests\\HttpCache;\n\nuse PHPUnit\\Framework\\TestCase;\nuse Symfony\\Component\\HttpFoundation\\Cookie;\nuse Symfony\\Component\\HttpFoundation\\Request;\nuse Symfony\\Component\\HttpFoundation\\Response;\nuse Symfony\\Component\\HttpKernel\\HttpCache\\HttpCache;\nuse Symfony\\Component\\HttpKernel\\HttpCache\\Store;\n\nclass StoreTest extends TestCase\n{\n    protected $request;\n    protected $response;\n\n    /**\n     * @var Store\n     */\n    protected $store;\n\n    protected function setUp(): void\n    {\n        $this->request = Request::create('/');\n        $this->response = new Response('hello world', 200, []);\n\n        HttpCacheTestCase::clearDirectory(sys_get_temp_dir().'/http_cache');\n\n        $this->store = new Store(sys_get_temp_dir().'/http_cache');\n    }\n\n    protected function tearDown(): void\n    {\n        $this->store = null;\n        $this->request = null;\n        $this->response = null;\n\n        HttpCacheTestCase::clearDirectory(sys_get_temp_dir().'/http_cache');\n    }\n\n    public function testReadsAnEmptyArrayWithReadWhenNothingCachedAtKey()\n    {\n        $this->assertEmpty($this->getStoreMetadata('/nothing'));\n    }\n\n    public function testUnlockFileThatDoesExist()\n    {\n        $this->storeSimpleEntry();\n        $this->store->lock($this->request);\n\n        $this->assertTrue($this->store->unlock($this->request));\n    }\n\n    public function testUnlockFileThatDoesNotExist()\n    {\n        $this->assertFalse($this->store->unlock($this->request));\n    }\n\n    public function testRemovesEntriesForKeyWithPurge()\n    {\n        $request = Request::create('/foo');\n        $this->store->write($request, new Response('foo'));\n\n        $metadata = $this->getStoreMetadata($request);\n        $this->assertNotEmpty($metadata);\n\n        $this->assertTrue($this->store->purge('/foo'));\n        $this->assertEmpty($this->getStoreMetadata($request));\n\n        // cached content should be kept after purging\n        $path = $this->store->getPath($metadata[0][1]['x-content-digest'][0]);\n        $this->assertTrue(is_file($path));\n\n        $this->assertFalse($this->store->purge('/bar'));\n    }\n\n    public function testStoresACacheEntry()\n    {\n        $cacheKey = $this->storeSimpleEntry();\n\n        $this->assertNotEmpty($this->getStoreMetadata($cacheKey));\n    }\n\n    public function testSetsTheXContentDigestResponseHeaderBeforeStoring()\n    {\n        $cacheKey = $this->storeSimpleEntry();\n        $entries = $this->getStoreMetadata($cacheKey);\n        [, $res] = $entries[0];\n\n        $this->assertEquals('en9f86d081884c7d659a2feaa0c55ad015a3bf4f1b2b0b822cd15d6c15b0f00a08', $res['x-content-digest'][0]);\n    }\n\n    public function testDoesNotTrustXContentDigestFromUpstream()\n    {\n        $response = new Response('test', 200, ['X-Content-Digest' => 'untrusted-from-elsewhere']);\n\n        $cacheKey = $this->store->write($this->request, $response);\n        $entries = $this->getStoreMetadata($cacheKey);\n        [, $res] = $entries[0];\n\n        $this->assertEquals('en9f86d081884c7d659a2feaa0c55ad015a3bf4f1b2b0b822cd15d6c15b0f00a08', $res['x-content-digest'][0]);\n        $this->assertEquals('en9f86d081884c7d659a2feaa0c55ad015a3bf4f1b2b0b822cd15d6c15b0f00a08', $response->headers->get('X-Content-Digest'));\n    }\n\n    public function testWritesResponseEvenIfXContentDigestIsPresent()\n    {\n        // Prime the store\n        $this->store->write($this->request, new Response('test', 200, ['X-Content-Digest' => 'untrusted-from-elsewhere']));\n\n        $response = $this->store->lookup($this->request);\n        $this->assertNotNull($response);\n    }\n\n    public function testWritingARestoredResponseDoesNotCorruptCache()\n    {\n        /*\n         * This covers the regression reported in https://github.com/symfony/symfony/issues/37174.\n         *\n         * A restored response does *not* load the body, but only keep the file path in a special X-Body-File\n         * header. For reasons (?), the file path was also used as the restored response body.\n         * It would be up to others (HttpCache...?) to honor this header and actually load the response content\n         * from there.\n         *\n         * When a restored response was stored again, the Store itself would ignore the header. In the first\n         * step, this would compute a new Content Digest based on the file path in the restored response body;\n         * this is covered by \"Checkpoint 1\" below. But, since the X-Body-File header was left untouched (Checkpoint 2), downstream\n         * code (HttpCache...) would not immediately notice.\n         *\n         * Only upon performing the lookup for a second time, we'd get a Response where the (wrong) Content Digest\n         * is also reflected in the X-Body-File header, this time also producing wrong content when the downstream\n         * evaluates it.\n         */\n        $this->store->write($this->request, $this->response);\n        $digest = $this->response->headers->get('X-Content-Digest');\n        $path = $this->getStorePath($digest);\n\n        $response = $this->store->lookup($this->request);\n        $this->store->write($this->request, $response);\n        $this->assertEquals($digest, $response->headers->get('X-Content-Digest')); // Checkpoint 1\n        $this->assertEquals($path, $response->headers->get('X-Body-File')); // Checkpoint 2\n\n        $response = $this->store->lookup($this->request);\n        $this->assertEquals($digest, $response->headers->get('X-Content-Digest'));\n        $this->assertEquals($path, $response->headers->get('X-Body-File'));\n    }\n\n    public function testFindsAStoredEntryWithLookup()\n    {\n        $this->storeSimpleEntry();\n        $response = $this->store->lookup($this->request);\n\n        $this->assertNotNull($response);\n        $this->assertInstanceOf(Response::class, $response);\n    }\n\n    public function testDoesNotFindAnEntryWithLookupWhenNoneExists()\n    {\n        $request = Request::create('/test', 'get', [], [], [], ['HTTP_FOO' => 'Foo', 'HTTP_BAR' => 'Bar']);\n\n        $this->assertNull($this->store->lookup($request));\n    }\n\n    public function testCanonizesUrlsForCacheKeys()\n    {\n        $this->storeSimpleEntry($path = '/test?x=y&p=q');\n        $hitsReq = Request::create($path);\n        $missReq = Request::create('/test?p=x');\n\n        $this->assertNotNull($this->store->lookup($hitsReq));\n        $this->assertNull($this->store->lookup($missReq));\n    }\n\n    public function testDoesNotFindAnEntryWithLookupWhenTheBodyDoesNotExist()\n    {\n        $this->storeSimpleEntry();\n        $this->assertNotNull($this->response->headers->get('X-Content-Digest'));\n        $path = $this->getStorePath($this->response->headers->get('X-Content-Digest'));\n        @unlink($path);\n        $this->assertNull($this->store->lookup($this->request));\n    }\n\n    public function testRestoresResponseHeadersProperlyWithLookup()\n    {\n        $this->storeSimpleEntry();\n        $response = $this->store->lookup($this->request);\n\n        $this->assertEquals($response->headers->all(), array_merge(['content-length' => 4, 'x-body-file' => [$this->getStorePath($response->headers->get('X-Content-Digest'))]], $this->response->headers->all()));\n    }\n\n    public function testRestoresResponseContentFromEntityStoreWithLookup()\n    {\n        $this->storeSimpleEntry();\n        $response = $this->store->lookup($this->request);\n        $this->assertEquals($this->getStorePath('en'.hash('sha256', 'test')), $response->getContent());\n    }\n\n    public function testInvalidatesMetaAndEntityStoreEntriesWithInvalidate()\n    {\n        $this->storeSimpleEntry();\n        $this->store->invalidate($this->request);\n        $response = $this->store->lookup($this->request);\n        $this->assertInstanceOf(Response::class, $response);\n        $this->assertFalse($response->isFresh());\n    }\n\n    public function testSucceedsQuietlyWhenInvalidateCalledWithNoMatchingEntries()\n    {\n        $req = Request::create('/test');\n        $this->store->invalidate($req);\n        $this->assertNull($this->store->lookup($this->request));\n    }\n\n    public function testDoesNotReturnEntriesThatVaryWithLookup()\n    {\n        $req1 = Request::create('/test', 'get', [], [], [], ['HTTP_FOO' => 'Foo', 'HTTP_BAR' => 'Bar']);\n        $req2 = Request::create('/test', 'get', [], [], [], ['HTTP_FOO' => 'Bling', 'HTTP_BAR' => 'Bam']);\n        $res = new Response('test', 200, ['Vary' => 'Foo Bar']);\n        $this->store->write($req1, $res);\n\n        $this->assertNull($this->store->lookup($req2));\n    }\n\n    public function testDoesNotReturnEntriesThatSlightlyVaryWithLookup()\n    {\n        $req1 = Request::create('/test', 'get', [], [], [], ['HTTP_FOO' => 'Foo', 'HTTP_BAR' => 'Bar']);\n        $req2 = Request::create('/test', 'get', [], [], [], ['HTTP_FOO' => 'Foo', 'HTTP_BAR' => 'Bam']);\n        $res = new Response('test', 200, ['Vary' => ['Foo', 'Bar']]);\n        $this->store->write($req1, $res);\n\n        $this->assertNull($this->store->lookup($req2));\n    }\n\n    public function testStoresMultipleResponsesForEachVaryCombination()\n    {\n        $req1 = Request::create('/test', 'get', [], [], [], ['HTTP_FOO' => 'Foo', 'HTTP_BAR' => 'Bar']);\n        $res1 = new Response('test 1', 200, ['Vary' => 'Foo Bar']);\n        $key = $this->store->write($req1, $res1);\n\n        $req2 = Request::create('/test', 'get', [], [], [], ['HTTP_FOO' => 'Bling', 'HTTP_BAR' => 'Bam']);\n        $res2 = new Response('test 2', 200, ['Vary' => 'Foo Bar']);\n        $this->store->write($req2, $res2);\n\n        $req3 = Request::create('/test', 'get', [], [], [], ['HTTP_FOO' => 'Baz', 'HTTP_BAR' => 'Boom']);\n        $res3 = new Response('test 3', 200, ['Vary' => 'Foo Bar']);\n        $this->store->write($req3, $res3);\n\n        $this->assertEquals($this->getStorePath('en'.hash('sha256', 'test 3')), $this->store->lookup($req3)->getContent());\n        $this->assertEquals($this->getStorePath('en'.hash('sha256', 'test 2')), $this->store->lookup($req2)->getContent());\n        $this->assertEquals($this->getStorePath('en'.hash('sha256', 'test 1')), $this->store->lookup($req1)->getContent());\n\n        $this->assertCount(3, $this->getStoreMetadata($key));\n    }\n\n    public function testOverwritesNonVaryingResponseWithStore()\n    {\n        $req1 = Request::create('/test', 'get', [], [], [], ['HTTP_FOO' => 'Foo', 'HTTP_BAR' => 'Bar']);\n        $res1 = new Response('test 1', 200, ['Vary' => 'Foo Bar']);\n        $this->store->write($req1, $res1);\n        $this->assertEquals($this->getStorePath('en'.hash('sha256', 'test 1')), $this->store->lookup($req1)->getContent());\n\n        $req2 = Request::create('/test', 'get', [], [], [], ['HTTP_FOO' => 'Bling', 'HTTP_BAR' => 'Bam']);\n        $res2 = new Response('test 2', 200, ['Vary' => 'Foo Bar']);\n        $this->store->write($req2, $res2);\n        $this->assertEquals($this->getStorePath('en'.hash('sha256', 'test 2')), $this->store->lookup($req2)->getContent());\n\n        $req3 = Request::create('/test', 'get', [], [], [], ['HTTP_FOO' => 'Foo', 'HTTP_BAR' => 'Bar']);\n        $res3 = new Response('test 3', 200, ['Vary' => 'Foo Bar']);\n        $key = $this->store->write($req3, $res3);\n        $this->assertEquals($this->getStorePath('en'.hash('sha256', 'test 3')), $this->store->lookup($req3)->getContent());\n\n        $this->assertCount(2, $this->getStoreMetadata($key));\n    }\n\n    public function testLocking()\n    {\n        $req = Request::create('/test', 'get', [], [], [], ['HTTP_FOO' => 'Foo', 'HTTP_BAR' => 'Bar']);\n        $this->assertTrue($this->store->lock($req));\n\n        $this->store->lock($req);\n        $this->assertTrue($this->store->isLocked($req));\n\n        $this->store->unlock($req);\n        $this->assertFalse($this->store->isLocked($req));\n    }\n\n    public function testPurgeHttps()\n    {\n        $request = Request::create('https://example.com/foo');\n        $this->store->write($request, new Response('foo'));\n\n        $this->assertNotEmpty($this->getStoreMetadata($request));\n\n        $this->assertTrue($this->store->purge('https://example.com/foo'));\n        $this->assertEmpty($this->getStoreMetadata($request));\n    }\n\n    public function testPurgeHttpAndHttps()\n    {\n        $requestHttp = Request::create('https://example.com/foo');\n        $this->store->write($requestHttp, new Response('foo'));\n\n        $requestHttps = Request::create('http://example.com/foo');\n        $this->store->write($requestHttps, new Response('foo'));\n\n        $this->assertNotEmpty($this->getStoreMetadata($requestHttp));\n        $this->assertNotEmpty($this->getStoreMetadata($requestHttps));\n\n        $this->assertTrue($this->store->purge('http://example.com/foo'));\n        $this->assertEmpty($this->getStoreMetadata($requestHttp));\n        $this->assertEmpty($this->getStoreMetadata($requestHttps));\n    }\n\n    public function testDoesNotStorePrivateHeaders()\n    {\n        $request = Request::create('https://example.com/foo');\n        $response = new Response('foo');\n        $response->headers->setCookie(Cookie::fromString('foo=bar'));\n\n        $this->store->write($request, $response);\n        $this->assertArrayNotHasKey('set-cookie', $this->getStoreMetadata($request)[0][1]);\n        $this->assertNotEmpty($response->headers->getCookies());\n    }\n\n    protected function storeSimpleEntry($path = null, $headers = [])\n    {\n        if (null === $path) {\n            $path = '/test';\n        }\n\n        $this->request = Request::create($path, 'get', [], [], [], $headers);\n        $this->response = new Response('test', 200, ['Cache-Control' => 'max-age=420']);\n\n        return $this->store->write($this->request, $this->response);\n    }\n\n    protected function getStoreMetadata($key)\n    {\n        $r = new \\ReflectionObject($this->store);\n        $m = $r->getMethod('getMetadata');\n        $m->setAccessible(true);\n\n        if ($key instanceof Request) {\n            $m1 = $r->getMethod('getCacheKey');\n            $m1->setAccessible(true);\n            $key = $m1->invoke($this->store, $key);\n        }\n\n        return $m->invoke($this->store, $key);\n    }\n\n    protected function getStorePath($key)\n    {\n        $r = new \\ReflectionObject($this->store);\n        $m = $r->getMethod('getPath');\n        $m->setAccessible(true);\n\n        return $m->invoke($this->store, $key);\n    }\n}\n"], "filenames": ["src/Symfony/Component/HttpKernel/HttpCache/Store.php", "src/Symfony/Component/HttpKernel/Tests/HttpCache/StoreTest.php"], "buggy_code_start_loc": [29, 14], "buggy_code_end_loc": [216, 319], "fixing_code_start_loc": [29, 15], "fixing_code_end_loc": [231, 333], "type": "CWE-285", "message": "Symfony is a PHP framework for web and console applications and a set of reusable PHP components. The Symfony HTTP cache system, acts as a reverse proxy: It caches entire responses (including headers) and returns them to the clients. In a recent change in the `AbstractSessionListener`, the response might contain a `Set-Cookie` header. If the Symfony HTTP cache system is enabled, this response might bill stored and return to the next clients. An attacker can use this vulnerability to retrieve the victim's session. This issue has been patched and is available for branch 4.4.", "other": {"cve": {"id": "CVE-2022-24894", "sourceIdentifier": "security-advisories@github.com", "published": "2023-02-03T22:15:10.823", "lastModified": "2023-02-14T16:24:34.673", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Symfony is a PHP framework for web and console applications and a set of reusable PHP components. The Symfony HTTP cache system, acts as a reverse proxy: It caches entire responses (including headers) and returns them to the clients. In a recent change in the `AbstractSessionListener`, the response might contain a `Set-Cookie` header. If the Symfony HTTP cache system is enabled, this response might bill stored and return to the next clients. An attacker can use this vulnerability to retrieve the victim's session. This issue has been patched and is available for branch 4.4."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:L/UI:R/S:U/C:H/I:L/A:L", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 5.9, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.2, "impactScore": 4.7}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-285"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:sensiolabs:symfony:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.0.0", "versionEndExcluding": "4.4.50", "matchCriteriaId": "BD26F566-480D-42C8-93BA-011DC77BA73A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:sensiolabs:symfony:*:*:*:*:*:*:*:*", "versionStartIncluding": "5.0.0", "versionEndExcluding": "5.4.2", "matchCriteriaId": "A758FF4D-2E7D-4F45-A672-08994AFCC236"}, {"vulnerable": true, "criteria": "cpe:2.3:a:sensiolabs:symfony:*:*:*:*:*:*:*:*", "versionStartIncluding": "6.0.0", "versionEndExcluding": "6.0.20", "matchCriteriaId": "B7DB6A6C-A7A4-4571-9677-24C9E7AAFD3C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:sensiolabs:symfony:*:*:*:*:*:*:*:*", "versionStartIncluding": "6.1.0", "versionEndExcluding": "6.1.12", "matchCriteriaId": "31265260-5BE3-41B1-A268-ECAE10B18978"}, {"vulnerable": true, "criteria": "cpe:2.3:a:sensiolabs:symfony:*:*:*:*:*:*:*:*", "versionStartIncluding": "6.2.0", "versionEndExcluding": "6.2.6", "matchCriteriaId": "8EE7A2A1-3893-4574-8A59-24BBDDE8DC41"}]}]}], "references": [{"url": "https://github.com/symfony/symfony/commit/d2f6322af9444ac5cd1ef3ac6f280dbef7f9d1fb", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/symfony/symfony/security/advisories/GHSA-h7vf-5wrv-9fhv", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/symfony/symfony/commit/d2f6322af9444ac5cd1ef3ac6f280dbef7f9d1fb"}}