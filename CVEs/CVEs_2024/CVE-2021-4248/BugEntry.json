{"buggy_code": ["using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing DNS.Protocol.Utils;\nusing DNS.Protocol.ResourceRecords;\n\nnamespace DNS.Protocol {\n    public class Request : IRequest {\n        private static readonly Random RANDOM = new Random();\n\n        private IList<Question> questions;\n        private Header header;\n        private IList<IResourceRecord> additional;\n\n        public static Request FromArray(byte[] message) {\n            Header header = Header.FromArray(message);\n            int offset = header.Size;\n\n            if (header.Response || header.QuestionCount == 0 ||\n                    header.AnswerRecordCount + header.AuthorityRecordCount > 0 ||\n                    header.ResponseCode != ResponseCode.NoError) {\n\n                throw new ArgumentException(\"Invalid request message\");\n            }\n\n            return new Request(header,\n                Question.GetAllFromArray(message, offset, header.QuestionCount, out offset),\n                ResourceRecordFactory.GetAllFromArray(message, offset, header.AdditionalRecordCount, out offset));\n        }\n\n        public Request(Header header, IList<Question> questions, IList<IResourceRecord> additional) {\n            this.header = header;\n            this.questions = questions;\n            this.additional = additional;\n        }\n\n        public Request() {\n            this.questions = new List<Question>();\n            this.header = new Header();\n            this.additional = new List<IResourceRecord>();\n\n            this.header.OperationCode = OperationCode.Query;\n            this.header.Response = false;\n            this.header.Id = RANDOM.Next(UInt16.MaxValue);\n        }\n\n        public Request(IRequest request) {\n            this.header = new Header();\n            this.questions = new List<Question>(request.Questions);\n            this.additional = new List<IResourceRecord>(request.AdditionalRecords);\n\n            this.header.Response = false;\n\n            Id = request.Id;\n            OperationCode = request.OperationCode;\n            RecursionDesired = request.RecursionDesired;\n        }\n\n        public IList<Question> Questions {\n            get { return questions; }\n        }\n\n        public IList<IResourceRecord> AdditionalRecords {\n            get { return additional; }\n        }\n\n        public int Size {\n            get {\n                return header.Size +\n                    questions.Sum(q => q.Size) +\n                    additional.Sum(a => a.Size);\n            }\n        }\n\n        public int Id {\n            get { return header.Id; }\n            set { header.Id = value; }\n        }\n\n        public OperationCode OperationCode {\n            get { return header.OperationCode; }\n            set { header.OperationCode = value; }\n        }\n\n        public bool RecursionDesired {\n            get { return header.RecursionDesired; }\n            set { header.RecursionDesired = value; }\n        }\n\n        public byte[] ToArray() {\n            UpdateHeader();\n            ByteStream result = new ByteStream(Size);\n\n            result\n                .Append(header.ToArray())\n                .Append(questions.Select(q => q.ToArray()))\n                .Append(additional.Select(a => a.ToArray()));\n\n            return result.ToArray();\n        }\n\n        public override string ToString() {\n            UpdateHeader();\n\n            return ObjectStringifier.New(this)\n                .Add(\"Header\", header)\n                .Add(\"Questions\", \"AdditionalRecords\")\n                .ToString();\n        }\n\n        private void UpdateHeader() {\n            header.QuestionCount = questions.Count;\n            header.AdditionalRecordCount = additional.Count;\n        }\n    }\n}\n"], "fixing_code": ["using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Security.Cryptography;\nusing DNS.Protocol.Utils;\nusing DNS.Protocol.ResourceRecords;\n\nnamespace DNS.Protocol {\n    public class Request : IRequest {\n        private static readonly RandomNumberGenerator RANDOM = new RNGCryptoServiceProvider();\n\n        private IList<Question> questions;\n        private Header header;\n        private IList<IResourceRecord> additional;\n\n        public static Request FromArray(byte[] message) {\n            Header header = Header.FromArray(message);\n            int offset = header.Size;\n\n            if (header.Response || header.QuestionCount == 0 ||\n                    header.AnswerRecordCount + header.AuthorityRecordCount > 0 ||\n                    header.ResponseCode != ResponseCode.NoError) {\n\n                throw new ArgumentException(\"Invalid request message\");\n            }\n\n            return new Request(header,\n                Question.GetAllFromArray(message, offset, header.QuestionCount, out offset),\n                ResourceRecordFactory.GetAllFromArray(message, offset, header.AdditionalRecordCount, out offset));\n        }\n\n        public Request(Header header, IList<Question> questions, IList<IResourceRecord> additional) {\n            this.header = header;\n            this.questions = questions;\n            this.additional = additional;\n        }\n\n        public Request() {\n            this.questions = new List<Question>();\n            this.header = new Header();\n            this.additional = new List<IResourceRecord>();\n\n            this.header.OperationCode = OperationCode.Query;\n            this.header.Response = false;\n            this.header.Id = NextRandomId();\n        }\n\n        public Request(IRequest request) {\n            this.header = new Header();\n            this.questions = new List<Question>(request.Questions);\n            this.additional = new List<IResourceRecord>(request.AdditionalRecords);\n\n            this.header.Response = false;\n\n            Id = request.Id;\n            OperationCode = request.OperationCode;\n            RecursionDesired = request.RecursionDesired;\n        }\n\n        public IList<Question> Questions {\n            get { return questions; }\n        }\n\n        public IList<IResourceRecord> AdditionalRecords {\n            get { return additional; }\n        }\n\n        public int Size {\n            get {\n                return header.Size +\n                    questions.Sum(q => q.Size) +\n                    additional.Sum(a => a.Size);\n            }\n        }\n\n        public int Id {\n            get { return header.Id; }\n            set { header.Id = value; }\n        }\n\n        public OperationCode OperationCode {\n            get { return header.OperationCode; }\n            set { header.OperationCode = value; }\n        }\n\n        public bool RecursionDesired {\n            get { return header.RecursionDesired; }\n            set { header.RecursionDesired = value; }\n        }\n\n        public byte[] ToArray() {\n            UpdateHeader();\n            ByteStream result = new ByteStream(Size);\n\n            result\n                .Append(header.ToArray())\n                .Append(questions.Select(q => q.ToArray()))\n                .Append(additional.Select(a => a.ToArray()));\n\n            return result.ToArray();\n        }\n\n        public override string ToString() {\n            UpdateHeader();\n\n            return ObjectStringifier.New(this)\n                .Add(\"Header\", header)\n                .Add(\"Questions\", \"AdditionalRecords\")\n                .ToString();\n        }\n\n        private void UpdateHeader() {\n            header.QuestionCount = questions.Count;\n            header.AdditionalRecordCount = additional.Count;\n        }\n\n        private ushort NextRandomId() {\n            byte[] buffer = new byte[sizeof(ushort)];\n            RANDOM.GetBytes(buffer);\n            return BitConverter.ToUInt16(buffer, 0);\n        }\n    }\n}\n"], "filenames": ["DNS/Protocol/Request.cs"], "buggy_code_start_loc": [3], "buggy_code_end_loc": [114], "fixing_code_start_loc": [4], "fixing_code_end_loc": [122], "type": "CWE-330", "message": "A vulnerability was found in kapetan dns up to 6.1.0. It has been rated as problematic. Affected by this issue is some unknown functionality of the file DNS/Protocol/Request.cs. The manipulation leads to insufficient entropy in prng. The attack may be launched remotely. Upgrading to version 7.0.0 is able to address this issue. The name of the patch is cf7105aa2aae90d6656088fe5a8ee1d5730773b6. It is recommended to upgrade the affected component. The identifier of this vulnerability is VDB-216188.", "other": {"cve": {"id": "CVE-2021-4248", "sourceIdentifier": "cna@vuldb.com", "published": "2022-12-18T11:15:09.893", "lastModified": "2022-12-22T16:46:17.510", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A vulnerability was found in kapetan dns up to 6.1.0. It has been rated as problematic. Affected by this issue is some unknown functionality of the file DNS/Protocol/Request.cs. The manipulation leads to insufficient entropy in prng. The attack may be launched remotely. Upgrading to version 7.0.0 is able to address this issue. The name of the patch is cf7105aa2aae90d6656088fe5a8ee1d5730773b6. It is recommended to upgrade the affected component. The identifier of this vulnerability is VDB-216188."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}, {"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:L/I:L/A:L", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 5.6, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.2, "impactScore": 3.4}]}, "weaknesses": [{"source": "cna@vuldb.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-330"}, {"lang": "en", "value": "CWE-331"}, {"lang": "en", "value": "CWE-332"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:kapetan_dns_project:kapetan_dns:*:*:*:*:*:*:*:*", "versionEndExcluding": "7.0.0", "matchCriteriaId": "FCE459F0-CC56-42A9-9483-B10DDB456FE3"}]}]}], "references": [{"url": "https://github.com/kapetan/dns/commit/cf7105aa2aae90d6656088fe5a8ee1d5730773b6", "source": "cna@vuldb.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/kapetan/dns/pull/88", "source": "cna@vuldb.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/kapetan/dns/releases/tag/v7.0.0", "source": "cna@vuldb.com", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://vuldb.com/?id.216188", "source": "cna@vuldb.com", "tags": ["Permissions Required", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/kapetan/dns/commit/cf7105aa2aae90d6656088fe5a8ee1d5730773b6"}}