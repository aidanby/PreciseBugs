{"buggy_code": ["// Copyright (c) Microsoft. All rights reserved.\n// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n\n#include <stdlib.h>\n#include <stdint.h>\n#include <string.h>\n#include <stdbool.h>\n#include \"azure_macro_utils/macro_utils.h\"\n#include \"azure_c_shared_utility/gballoc.h\"\n#include \"azure_c_shared_utility/xlogging.h\"\n#include \"azure_uamqp_c/amqp_types.h\"\n#include \"azure_uamqp_c/amqpvalue.h\"\n#include \"azure_c_shared_utility/refcount.h\"\n\n// max alloc size 100MB\n#define MAX_AMQPVALUE_MALLOC_SIZE_BYTES (100 * 1024 * 1024) \n#define MAX_AMQPVALUE_ITEM_COUNT 65536\n\n/* Requirements satisfied by the current implementation without any code:\nCodes_SRS_AMQPVALUE_01_270: [<encoding code=\"0x56\" category=\"fixed\" width=\"1\" label=\"boolean with the octet 0x00 being false and octet 0x01 being true\"/>]\nCodes_SRS_AMQPVALUE_01_099: [Represents an approximate point in time using the Unix time t [IEEE1003] encoding of UTC, but with a precision of milliseconds.]\n*/\n\ntypedef struct AMQP_LIST_VALUE_TAG\n{\n    AMQP_VALUE* items;\n    uint32_t count;\n} AMQP_LIST_VALUE;\n\ntypedef struct AMQP_ARRAY_VALUE_TAG\n{\n    AMQP_VALUE* items;\n    uint32_t count;\n} AMQP_ARRAY_VALUE;\n\ntypedef struct AMQP_MAP_KEY_VALUE_PAIR_TAG\n{\n    AMQP_VALUE key;\n    AMQP_VALUE value;\n} AMQP_MAP_KEY_VALUE_PAIR;\n\ntypedef struct AMQP_MAP_VALUE_TAG\n{\n    AMQP_MAP_KEY_VALUE_PAIR* pairs;\n    uint32_t pair_count;\n} AMQP_MAP_VALUE;\n\ntypedef struct AMQP_STRING_VALUE_TAG\n{\n    char* chars;\n} AMQP_STRING_VALUE;\n\ntypedef struct AMQP_SYMBOL_VALUE_TAG\n{\n    char* chars;\n} AMQP_SYMBOL_VALUE;\n\ntypedef struct AMQP_BINARY_VALUE_TAG\n{\n    unsigned char* bytes;\n    uint32_t length;\n} AMQP_BINARY_VALUE;\n\ntypedef struct DESCRIBED_VALUE_TAG\n{\n    AMQP_VALUE descriptor;\n    AMQP_VALUE value;\n} DESCRIBED_VALUE;\n\ntypedef union AMQP_VALUE_UNION_TAG\n{\n    DESCRIBED_VALUE described_value;\n    unsigned char ubyte_value;\n    uint16_t ushort_value;\n    uint32_t uint_value;\n    uint64_t ulong_value;\n    char byte_value;\n    int16_t short_value;\n    int32_t int_value;\n    int64_t long_value;\n    bool bool_value;\n    float float_value;\n    double double_value;\n    uint32_t char_value;\n    int64_t timestamp_value;\n    uuid uuid_value;\n    AMQP_STRING_VALUE string_value;\n    amqp_binary binary_value;\n    AMQP_LIST_VALUE list_value;\n    AMQP_MAP_VALUE map_value;\n    AMQP_ARRAY_VALUE array_value;\n    AMQP_SYMBOL_VALUE symbol_value;\n} AMQP_VALUE_UNION;\n\ntypedef enum DECODE_LIST_STEP_TAG\n{\n    DECODE_LIST_STEP_SIZE,\n    DECODE_LIST_STEP_COUNT,\n    DECODE_LIST_STEP_ITEMS\n} DECODE_LIST_STEP;\n\ntypedef enum DECODE_ARRAY_STEP_TAG\n{\n    DECODE_ARRAY_STEP_SIZE,\n    DECODE_ARRAY_STEP_COUNT,\n    DECODE_ARRAY_STEP_ITEMS\n} DECODE_ARRAY_STEP;\n\ntypedef enum DECODE_DESCRIBED_VALUE_STEP_TAG\n{\n    DECODE_DESCRIBED_VALUE_STEP_DESCRIPTOR,\n    DECODE_DESCRIBED_VALUE_STEP_VALUE\n} DECODE_DESCRIBED_VALUE_STEP;\n\ntypedef enum DECODE_MAP_STEP_TAG\n{\n    DECODE_MAP_STEP_SIZE,\n    DECODE_MAP_STEP_COUNT,\n    DECODE_MAP_STEP_PAIRS\n} DECODE_MAP_STEP;\n\ntypedef struct DECODE_LIST_VALUE_STATE_TAG\n{\n    DECODE_LIST_STEP list_value_state;\n    uint32_t item;\n} DECODE_LIST_VALUE_STATE;\n\ntypedef struct DECODE_ARRAY_VALUE_STATE_TAG\n{\n    DECODE_ARRAY_STEP array_value_state;\n    uint32_t item;\n    unsigned char constructor_byte;\n} DECODE_ARRAY_VALUE_STATE;\n\ntypedef struct DECODE_DESCRIBED_VALUE_STATE_TAG\n{\n    DECODE_DESCRIBED_VALUE_STEP described_value_state;\n} DECODE_DESCRIBED_VALUE_STATE;\n\ntypedef struct DECODE_STRING_VALUE_STATE_TAG\n{\n    uint32_t length;\n} DECODE_STRING_VALUE_STATE;\n\ntypedef struct DECODE_SYMBOL_VALUE_STATE_TAG\n{\n    uint32_t length;\n} DECODE_SYMBOL_VALUE_STATE;\n\ntypedef struct DECODE_MAP_VALUE_STATE_TAG\n{\n    DECODE_MAP_STEP map_value_state;\n    uint32_t item;\n} DECODE_MAP_VALUE_STATE;\n\ntypedef union DECODE_VALUE_STATE_UNION_TAG\n{\n    DECODE_LIST_VALUE_STATE list_value_state;\n    DECODE_ARRAY_VALUE_STATE array_value_state;\n    DECODE_DESCRIBED_VALUE_STATE described_value_state;\n    DECODE_STRING_VALUE_STATE string_value_state;\n    DECODE_SYMBOL_VALUE_STATE symbol_value_state;\n    DECODE_MAP_VALUE_STATE map_value_state;\n} DECODE_VALUE_STATE_UNION;\n\ntypedef struct AMQP_VALUE_DATA_TAG\n{\n    AMQP_TYPE type;\n    AMQP_VALUE_UNION value;\n} AMQP_VALUE_DATA;\n\nDEFINE_REFCOUNT_TYPE(AMQP_VALUE_DATA);\n\ntypedef enum DECODER_STATE_TAG\n{\n    DECODER_STATE_CONSTRUCTOR,\n    DECODER_STATE_TYPE_DATA,\n    DECODER_STATE_DONE,\n    DECODER_STATE_ERROR\n} DECODER_STATE;\n\ntypedef struct INTERNAL_DECODER_DATA_TAG* INTERNAL_DECODER_HANDLE;\n\ntypedef struct INTERNAL_DECODER_DATA_TAG\n{\n    ON_VALUE_DECODED on_value_decoded;\n    void* on_value_decoded_context;\n    size_t bytes_decoded;\n    DECODER_STATE decoder_state;\n    uint8_t constructor_byte;\n    AMQP_VALUE_DATA* decode_to_value;\n    INTERNAL_DECODER_HANDLE inner_decoder;\n    DECODE_VALUE_STATE_UNION decode_value_state;\n    bool is_internal;\n} INTERNAL_DECODER_DATA;\n\ntypedef struct AMQPVALUE_DECODER_HANDLE_DATA_TAG\n{\n    INTERNAL_DECODER_DATA* internal_decoder;\n    AMQP_VALUE_DATA* decode_to_value;\n} AMQPVALUE_DECODER_HANDLE_DATA;\n\nstatic int amqpvalue_encode_array_item(AMQP_VALUE item, bool first_element, AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context);\nstatic int amqpvalue_get_encoded_array_item_size(AMQP_VALUE item, size_t* encoded_size);\n\n/* Codes_SRS_AMQPVALUE_01_003: [1.6.1 null Indicates an empty value.] */\nAMQP_VALUE amqpvalue_create_null(void)\n{\n    AMQP_VALUE result = REFCOUNT_TYPE_CREATE(AMQP_VALUE_DATA);\n    if (result == NULL)\n    {\n        /* Codes_SRS_AMQPVALUE_01_002: [If allocating the AMQP_VALUE fails then amqpvalue_create_null shall return NULL.] */\n        LogError(\"Could not allocate memory for AMQP value\");\n    }\n    else\n    {\n        /* Codes_SRS_AMQPVALUE_01_001: [amqpvalue_create_null shall return a handle to an AMQP_VALUE that stores a null value.] */\n        result->type = AMQP_TYPE_NULL;\n    }\n\n    return result;\n}\n\n/* Codes_SRS_AMQPVALUE_01_004: [1.6.2 boolean Represents a true or false value.] */\nAMQP_VALUE amqpvalue_create_boolean(bool value)\n{\n    AMQP_VALUE result = REFCOUNT_TYPE_CREATE(AMQP_VALUE_DATA);\n    if (result == NULL)\n    {\n        /* Codes_SRS_AMQPVALUE_01_007: [If allocating the AMQP_VALUE fails then amqpvalue_create_boolean shall return NULL.] */\n        LogError(\"Could not allocate memory for AMQP value\");\n    }\n    else\n    {\n        /* Codes_SRS_AMQPVALUE_01_006: [amqpvalue_create_boolean shall return a handle to an AMQP_VALUE that stores a boolean value.] */\n        result->type = AMQP_TYPE_BOOL;\n        result->value.bool_value = value;\n    }\n\n    return result;\n}\n\nint amqpvalue_get_boolean(AMQP_VALUE value, bool* bool_value)\n{\n    int result;\n\n    /* Codes_SRS_AMQPVALUE_01_009: [If any of the arguments is NULL then amqpvalue_get_boolean shall return a non-zero value.] */\n    if ((value == NULL) ||\n        (bool_value == NULL))\n    {\n        LogError(\"Bad arguments: value = %p, bool_value = %p\",\n            value, bool_value);\n        result = MU_FAILURE;\n    }\n    else\n    {\n        AMQP_VALUE_DATA* value_data = (AMQP_VALUE_DATA*)value;\n        /* Codes_SRS_AMQPVALUE_01_011: [If the type of the value is not Boolean, then amqpvalue_get_boolean shall return a non-zero value.] */\n        if (value_data->type != AMQP_TYPE_BOOL)\n        {\n            LogError(\"Value is not of type bool\");\n            result = MU_FAILURE;\n        }\n        else\n        {\n            /* Codes_SRS_AMQPVALUE_01_008: [amqpvalue_get_boolean shall fill in the bool_value argument the Boolean value stored by the AMQP value indicated by the value argument.] */\n            *bool_value = value_data->value.bool_value;\n\n            /* Codes_SRS_AMQPVALUE_01_010: [On success amqpvalue_get_boolean shall return 0.] */\n            result = 0;\n        }\n    }\n\n    return result;\n}\n\n/* Codes_SRS_AMQPVALUE_01_005: [1.6.3 ubyte Integer in the range 0 to 28 - 1 inclusive.] */\nAMQP_VALUE amqpvalue_create_ubyte(unsigned char value)\n{\n    AMQP_VALUE result = REFCOUNT_TYPE_CREATE(AMQP_VALUE_DATA);\n    if (result != NULL)\n    {\n        /* Codes_SRS_AMQPVALUE_01_032: [amqpvalue_create_ubyte shall return a handle to an AMQP_VALUE that stores a unsigned char value.] */\n        result->type = AMQP_TYPE_UBYTE;\n        result->value.ubyte_value = value;\n    }\n\n    return result;\n}\n\nint amqpvalue_get_ubyte(AMQP_VALUE value, unsigned char* ubyte_value)\n{\n    int result;\n\n    /* Codes_SRS_AMQPVALUE_01_036: [If any of the arguments is NULL then amqpvalue_get_ubyte shall return a non-zero value.] */\n    if ((value == NULL) ||\n        (ubyte_value == NULL))\n    {\n        LogError(\"Bad arguments: value = %p, ubyte_value = %p\",\n            value, ubyte_value);\n        result = MU_FAILURE;\n    }\n    else\n    {\n        AMQP_VALUE_DATA* value_data = (AMQP_VALUE_DATA*)value;\n        /* Codes_SRS_AMQPVALUE_01_037: [If the type of the value is not ubyte (was not created with amqpvalue_create_ubyte), then amqpvalue_get_ubyte shall return a non-zero value.] */\n        if (value_data->type != AMQP_TYPE_UBYTE)\n        {\n            LogError(\"Value is not of type UBYTE\");\n            result = MU_FAILURE;\n        }\n        else\n        {\n            /* Codes_SRS_AMQPVALUE_01_034: [amqpvalue_get_ubyte shall fill in the ubyte_value argument the unsigned char value stored by the AMQP value indicated by the value argument.] */\n            *ubyte_value = value_data->value.ubyte_value;\n\n            /* Codes_SRS_AMQPVALUE_01_035: [On success amqpvalue_get_ubyte shall return 0.] */\n            result = 0;\n        }\n    }\n\n    return result;\n}\n\n/* Codes_SRS_AMQPVALUE_01_012: [1.6.4 ushort Integer in the range 0 to 216 - 1 inclusive.] */\nAMQP_VALUE amqpvalue_create_ushort(uint16_t value)\n{\n    AMQP_VALUE result = REFCOUNT_TYPE_CREATE(AMQP_VALUE_DATA);\n    if (result == NULL)\n    {\n        /* Codes_SRS_AMQPVALUE_01_039: [If allocating the AMQP_VALUE fails then amqpvalue_create_ushort shall return NULL.] */\n        LogError(\"Could not allocate memory for AMQP value\");\n    }\n    else\n    {\n        /* Codes_SRS_AMQPVALUE_01_038: [amqpvalue_create_ushort shall return a handle to an AMQP_VALUE that stores an uint16_t value.] */\n        result->type = AMQP_TYPE_USHORT;\n        result->value.ushort_value = value;\n    }\n\n    return result;\n}\n\nint amqpvalue_get_ushort(AMQP_VALUE value, uint16_t* ushort_value)\n{\n    int result;\n\n    /* Codes_SRS_AMQPVALUE_01_042: [If any of the arguments is NULL then amqpvalue_get_ushort shall return a non-zero value.] */\n    if ((value == NULL) ||\n        (ushort_value == NULL))\n    {\n        LogError(\"Bad arguments: value = %p, ushort_value = %p\",\n            value, ushort_value);\n        result = MU_FAILURE;\n    }\n    else\n    {\n        AMQP_VALUE_DATA* value_data = (AMQP_VALUE_DATA*)value;\n        /* Codes_SRS_AMQPVALUE_01_043: [If the type of the value is not ushort (was not created with amqpvalue_create_ushort), then amqpvalue_get_ushort shall return a non-zero value.] */\n        if (value_data->type != AMQP_TYPE_USHORT)\n        {\n            LogError(\"Value is not of type USHORT\");\n            result = MU_FAILURE;\n        }\n        else\n        {\n            /* Codes_SRS_AMQPVALUE_01_040: [amqpvalue_get_ushort shall fill in the ushort_value argument the uint16_t value stored by the AMQP value indicated by the value argument.] */\n            *ushort_value = value_data->value.ushort_value;\n\n            /* Codes_SRS_AMQPVALUE_01_041: [On success amqpvalue_get_ushort shall return 0.] */\n            result = 0;\n        }\n    }\n\n    return result;\n}\n\n/* Codes_SRS_AMQPVALUE_01_013: [1.6.5 uint Integer in the range 0 to 232 - 1 inclusive.] */\nAMQP_VALUE amqpvalue_create_uint(uint32_t value)\n{\n    AMQP_VALUE result = REFCOUNT_TYPE_CREATE(AMQP_VALUE_DATA);\n    if (result == NULL)\n    {\n        /* Codes_SRS_AMQPVALUE_01_045: [If allocating the AMQP_VALUE fails then amqpvalue_create_uint shall return NULL.] */\n        LogError(\"Could not allocate memory for AMQP value\");\n    }\n    else\n    {\n        /* Codes_SRS_AMQPVALUE_01_044: [amqpvalue_create_uint shall return a handle to an AMQP_VALUE that stores an uint32_t value.] */\n        result->type = AMQP_TYPE_UINT;\n        result->value.uint_value = value;\n    }\n\n    return result;\n}\n\nint amqpvalue_get_uint(AMQP_VALUE value, uint32_t* uint_value)\n{\n    int result;\n\n    /* Codes_SRS_AMQPVALUE_01_079: [If any of the arguments is NULL then amqpvalue_get_uint shall return a non-zero value.] */\n    if ((value == NULL) ||\n        (uint_value == NULL))\n    {\n        LogError(\"Bad arguments: value = %p, uint_value = %p\",\n            value, uint_value);\n        result = MU_FAILURE;\n    }\n    else\n    {\n        AMQP_VALUE_DATA* value_data = (AMQP_VALUE_DATA*)value;\n        /* Codes_SRS_AMQPVALUE_01_048: [If the type of the value is not uint (was not created with amqpvalue_create_uint), then amqpvalue_get_uint shall return a non-zero value.] */\n        if (value_data->type != AMQP_TYPE_UINT)\n        {\n            LogError(\"Value is not of type UINT\");\n            result = MU_FAILURE;\n        }\n        else\n        {\n            /* Codes_SRS_AMQPVALUE_01_046: [amqpvalue_get_uint shall fill in the uint_value argument the uint32_t value stored by the AMQP value indicated by the value argument.] */\n            *uint_value = value_data->value.uint_value;\n\n            /* Codes_SRS_AMQPVALUE_01_047: [On success amqpvalue_get_uint shall return 0.] */\n            result = 0;\n        }\n    }\n\n    return result;\n}\n\n/* Codes_SRS_AMQPVALUE_01_014: [1.6.6 ulong Integer in the range 0 to 264 - 1 inclusive.] */\nAMQP_VALUE amqpvalue_create_ulong(uint64_t value)\n{\n    AMQP_VALUE result = REFCOUNT_TYPE_CREATE(AMQP_VALUE_DATA);\n    if (result == NULL)\n    {\n        /* Codes_SRS_AMQPVALUE_01_050: [If allocating the AMQP_VALUE fails then amqpvalue_create_ulong shall return NULL.] */\n        LogError(\"Could not allocate memory for AMQP value\");\n    }\n    else\n    {\n        /* Codes_SRS_AMQPVALUE_01_049: [amqpvalue_create_ulong shall return a handle to an AMQP_VALUE that stores an uint64_t value.] */\n        result->type = AMQP_TYPE_ULONG;\n        result->value.ulong_value = value;\n    }\n\n    return result;\n}\n\nint amqpvalue_get_ulong(AMQP_VALUE value, uint64_t* ulong_value)\n{\n    int result;\n\n    /* Codes_SRS_AMQPVALUE_01_053: [If any of the arguments is NULL then amqpvalue_get_ulong shall return a non-zero value.] */\n    if ((value == NULL) ||\n        (ulong_value == NULL))\n    {\n        LogError(\"Bad arguments: value = %p, ulong_value = %p\",\n            value, ulong_value);\n        result = MU_FAILURE;\n    }\n    else\n    {\n        AMQP_VALUE_DATA* value_data = (AMQP_VALUE_DATA*)value;\n        /* Codes_SRS_AMQPVALUE_01_054: [If the type of the value is not ulong (was not created with amqpvalue_create_ulong), then amqpvalue_get_ulong shall return a non-zero value.] */\n        if (value_data->type != AMQP_TYPE_ULONG)\n        {\n            LogError(\"Value is not of type ULONG\");\n            result = MU_FAILURE;\n        }\n        else\n        {\n            /* Codes_SRS_AMQPVALUE_01_051: [amqpvalue_get_ulong shall fill in the ulong_value argument the ulong64_t value stored by the AMQP value indicated by the value argument.] */\n            *ulong_value = value_data->value.ulong_value;\n\n            /* Codes_SRS_AMQPVALUE_01_052: [On success amqpvalue_get_ulong shall return 0.] */\n            result = 0;\n        }\n    }\n\n    return result;\n}\n\n/* Codes_SRS_AMQPVALUE_01_015: [1.6.7 byte Integer in the range -(27) to 27 - 1 inclusive.] */\nAMQP_VALUE amqpvalue_create_byte(char value)\n{\n    AMQP_VALUE result = REFCOUNT_TYPE_CREATE(AMQP_VALUE_DATA);\n    if (result == NULL)\n    {\n        /* Codes_SRS_AMQPVALUE_01_056: [If allocating the AMQP_VALUE fails then amqpvalue_create_byte shall return NULL.] */\n        LogError(\"Could not allocate memory for AMQP value\");\n    }\n    else\n    {\n        /* Codes_SRS_AMQPVALUE_01_055: [amqpvalue_create_byte shall return a handle to an AMQP_VALUE that stores a char value.] */\n        result->type = AMQP_TYPE_BYTE;\n        result->value.byte_value = value;\n    }\n\n    return result;\n}\n\nint amqpvalue_get_byte(AMQP_VALUE value, char* byte_value)\n{\n    int result;\n\n    /* Codes_SRS_AMQPVALUE_01_059: [If any of the arguments is NULL then amqpvalue_get_byte shall return a non-zero value.] */\n    if ((value == NULL) ||\n        (byte_value == NULL))\n    {\n        LogError(\"Bad arguments: value = %p, byte_value = %p\",\n            value, byte_value);\n        result = MU_FAILURE;\n    }\n    else\n    {\n        AMQP_VALUE_DATA* value_data = (AMQP_VALUE_DATA*)value;\n        /* Codes_SRS_AMQPVALUE_01_060: [If the type of the value is not byte (was not created with amqpvalue_create_byte), then amqpvalue_get_byte shall return a non-zero value.] */\n        if (value_data->type != AMQP_TYPE_BYTE)\n        {\n            LogError(\"Value is not of type BYTE\");\n            result = MU_FAILURE;\n        }\n        else\n        {\n            /* Codes_SRS_AMQPVALUE_01_057: [amqpvalue_get_byte shall fill in the byte_value argument the char value stored by the AMQP value indicated by the value argument.] */\n            *byte_value = value_data->value.byte_value;\n\n            /* Codes_SRS_AMQPVALUE_01_058: [On success amqpvalue_get_byte shall return 0.] */\n            result = 0;\n        }\n    }\n\n    return result;\n}\n\n/* Codes_SRS_AMQPVALUE_01_016: [1.6.8 short Integer in the range -(215) to 215 - 1 inclusive.] */\nAMQP_VALUE amqpvalue_create_short(int16_t value)\n{\n    AMQP_VALUE result = REFCOUNT_TYPE_CREATE(AMQP_VALUE_DATA);\n    if (result == NULL)\n    {\n        /* Codes_SRS_AMQPVALUE_01_062: [If allocating the AMQP_VALUE fails then amqpvalue_create_short shall return NULL.] */\n        LogError(\"Could not allocate memory for AMQP value\");\n    }\n    else\n    {\n        /* Codes_SRS_AMQPVALUE_01_061: [amqpvalue_create_short shall return a handle to an AMQP_VALUE that stores an int16_t value.] */\n        result->type = AMQP_TYPE_SHORT;\n        result->value.short_value = value;\n    }\n    return result;\n}\n\nint amqpvalue_get_short(AMQP_VALUE value, int16_t* short_value)\n{\n    int result;\n\n    /* Codes_SRS_AMQPVALUE_01_065: [If any of the arguments is NULL then amqpvalue_get_short shall return a non-zero value.] */\n    if ((value == NULL) ||\n        (short_value == NULL))\n    {\n        LogError(\"Bad arguments: value = %p, short_value = %p\",\n            value, short_value);\n        result = MU_FAILURE;\n    }\n    else\n    {\n        AMQP_VALUE_DATA* value_data = (AMQP_VALUE_DATA*)value;\n        /* Codes_SRS_AMQPVALUE_01_066: [If the type of the value is not short (was not created with amqpvalue_create_short), then amqpvalue_get_short shall return a non-zero value.] */\n        if (value_data->type != AMQP_TYPE_SHORT)\n        {\n            LogError(\"Value is not of type SHORT\");\n            result = MU_FAILURE;\n        }\n        else\n        {\n            /* Codes_SRS_AMQPVALUE_01_063: [amqpvalue_get_short shall fill in the short_value argument the int16_t value stored by the AMQP value indicated by the value argument.] */\n            *short_value = value_data->value.short_value;\n\n            /* Codes_SRS_AMQPVALUE_01_064: [On success amqpvalue_get_short shall return 0.] */\n            result = 0;\n        }\n    }\n\n    return result;\n}\n\n/* Codes_SRS_AMQPVALUE_01_017: [1.6.9 int Integer in the range -(231) to 231 - 1 inclusive.] */\nAMQP_VALUE amqpvalue_create_int(int32_t value)\n{\n    AMQP_VALUE result = REFCOUNT_TYPE_CREATE(AMQP_VALUE_DATA);\n    if (result == NULL)\n    {\n        /* Codes_SRS_AMQPVALUE_01_068: [If allocating the AMQP_VALUE fails then amqpvalue_create_int shall return NULL.] */\n        LogError(\"Could not allocate memory for AMQP value\");\n    }\n    else\n    {\n        /* Codes_SRS_AMQPVALUE_01_067: [amqpvalue_create_int shall return a handle to an AMQP_VALUE that stores an int32_t value.] */\n        result->type = AMQP_TYPE_INT;\n        result->value.int_value = value;\n    }\n\n    return result;\n}\n\nint amqpvalue_get_int(AMQP_VALUE value, int32_t* int_value)\n{\n    int result;\n\n    /* Codes_SRS_AMQPVALUE_01_071: [If any of the arguments is NULL then amqpvalue_get_int shall return a non-zero value.] */\n    if ((value == NULL) ||\n        (int_value == NULL))\n    {\n        LogError(\"Bad arguments: value = %p, int_value = %p\",\n            value, int_value);\n        result = MU_FAILURE;\n    }\n    else\n    {\n        AMQP_VALUE_DATA* value_data = (AMQP_VALUE_DATA*)value;\n        /* Codes_SRS_AMQPVALUE_01_072: [If the type of the value is not int (was not created with amqpvalue_create_int), then amqpvalue_get_int shall return a non-zero value.] */\n        if (value_data->type != AMQP_TYPE_INT)\n        {\n            LogError(\"Value is not of type INT\");\n            result = MU_FAILURE;\n        }\n        else\n        {\n            /* Codes_SRS_AMQPVALUE_01_069: [amqpvalue_get_int shall fill in the int_value argument the int32_t value stored by the AMQP value indicated by the value argument.] */\n            *int_value = value_data->value.int_value;\n\n            /* Codes_SRS_AMQPVALUE_01_070: [On success amqpvalue_get_int shall return 0.] */\n            result = 0;\n        }\n    }\n\n    return result;\n}\n\n/* Codes_SRS_AMQPVALUE_01_018: [1.6.10 long Integer in the range -(263) to 263 - 1 inclusive.] */\nAMQP_VALUE amqpvalue_create_long(int64_t value)\n{\n    AMQP_VALUE result = REFCOUNT_TYPE_CREATE(AMQP_VALUE_DATA);\n    if (result == NULL)\n    {\n        /* Codes_SRS_AMQPVALUE_01_074: [If allocating the AMQP_VALUE fails then amqpvalue_create_long shall return NULL.] */\n        LogError(\"Could not allocate memory for AMQP value\");\n    }\n    else\n    {\n        /* Codes_SRS_AMQPVALUE_01_073: [amqpvalue_create_long shall return a handle to an AMQP_VALUE that stores an int64_t value.] */\n        result->type = AMQP_TYPE_LONG;\n        result->value.long_value = value;\n    }\n\n    return result;\n}\n\nint amqpvalue_get_long(AMQP_VALUE value, int64_t* long_value)\n{\n    int result;\n\n    /* Codes_SRS_AMQPVALUE_01_077: [If any of the arguments is NULL then amqpvalue_get_long shall return a non-zero value.] */\n    if ((value == NULL) ||\n        (long_value == NULL))\n    {\n        LogError(\"Bad arguments: value = %p, long_value = %p\",\n            value, long_value);\n        result = MU_FAILURE;\n    }\n    else\n    {\n        AMQP_VALUE_DATA* value_data = (AMQP_VALUE_DATA*)value;\n        /* Codes_SRS_AMQPVALUE_01_078: [If the type of the value is not long (was not created with amqpvalue_create_long), then amqpvalue_get_long shall return a non-zero value.] */\n        if (value_data->type != AMQP_TYPE_LONG)\n        {\n            LogError(\"Value is not of type LONG\");\n            result = MU_FAILURE;\n        }\n        else\n        {\n            /* Codes_SRS_AMQPVALUE_01_075: [amqpvalue_get_long shall fill in the long_value argument the int64_t value stored by the AMQP value indicated by the value argument.] */\n            *long_value = value_data->value.long_value;\n\n            /* Codes_SRS_AMQPVALUE_01_076: [On success amqpvalue_get_long shall return 0.] */\n            result = 0;\n        }\n    }\n\n    return result;\n}\n\n/* Codes_SRS_AMQPVALUE_01_019: [1.6.11 float 32-bit floating point number (IEEE 754-2008 binary32).]  */\nAMQP_VALUE amqpvalue_create_float(float value)\n{\n    AMQP_VALUE result = REFCOUNT_TYPE_CREATE(AMQP_VALUE_DATA);\n    if (result == NULL)\n    {\n        /* Codes_SRS_AMQPVALUE_01_081: [If allocating the AMQP_VALUE fails then amqpvalue_create_float shall return NULL.] */\n        LogError(\"Could not allocate memory for AMQP value\");\n    }\n    else\n    {\n        /* Codes_SRS_AMQPVALUE_01_080: [amqpvalue_create_float shall return a handle to an AMQP_VALUE that stores a float value.] */\n        result->type = AMQP_TYPE_FLOAT;\n        result->value.float_value = value;\n    }\n\n    return result;\n}\n\nint amqpvalue_get_float(AMQP_VALUE value, float* float_value)\n{\n    int result;\n\n    /* Codes_SRS_AMQPVALUE_01_084: [If any of the arguments is NULL then amqpvalue_get_float shall return a non-zero value.] */\n    if ((value == NULL) ||\n        (float_value == NULL))\n    {\n        LogError(\"Bad arguments: value = %p, float_value = %p\",\n            value, float_value);\n        result = MU_FAILURE;\n    }\n    else\n    {\n        AMQP_VALUE_DATA* value_data = (AMQP_VALUE_DATA*)value;\n        /* Codes_SRS_AMQPVALUE_01_085: [If the type of the value is not float (was not created with amqpvalue_create_float), then amqpvalue_get_float shall return a non-zero value.] */\n        if (value_data->type != AMQP_TYPE_FLOAT)\n        {\n            LogError(\"Value is not of type FLOAT\");\n            result = MU_FAILURE;\n        }\n        else\n        {\n            /* Codes_SRS_AMQPVALUE_01_082: [amqpvalue_get_float shall fill in the float_value argument the float value stored by the AMQP value indicated by the value argument.] */\n            *float_value = value_data->value.float_value;\n\n            /* Codes_SRS_AMQPVALUE_01_083: [On success amqpvalue_get_float shall return 0.] */\n            result = 0;\n        }\n    }\n\n    return result;\n}\n\n/* Codes_SRS_AMQPVALUE_01_020: [1.6.12 double 64-bit floating point number (IEEE 754-2008 binary64).] */\nAMQP_VALUE amqpvalue_create_double(double value)\n{\n    AMQP_VALUE result = REFCOUNT_TYPE_CREATE(AMQP_VALUE_DATA);\n    if (result == NULL)\n    {\n        /* Codes_SRS_AMQPVALUE_01_087: [If allocating the AMQP_VALUE fails then amqpvalue_create_double shall return NULL.] */\n        LogError(\"Could not allocate memory for AMQP value\");\n    }\n    else\n    {\n        /* Codes_SRS_AMQPVALUE_01_086: [amqpvalue_create_double shall return a handle to an AMQP_VALUE that stores a double value.] */\n        result->type = AMQP_TYPE_DOUBLE;\n        result->value.double_value = value;\n    }\n\n    return result;\n}\n\nint amqpvalue_get_double(AMQP_VALUE value, double* double_value)\n{\n    int result;\n\n    /* Codes_SRS_AMQPVALUE_01_090: [If any of the arguments is NULL then amqpvalue_get_double shall return a non-zero value.] */\n    if ((value == NULL) ||\n        (double_value == NULL))\n    {\n        LogError(\"Bad arguments: value = %p, double_value = %p\",\n            value, double_value);\n        result = MU_FAILURE;\n    }\n    else\n    {\n        AMQP_VALUE_DATA* value_data = (AMQP_VALUE_DATA*)value;\n        /* Codes_SRS_AMQPVALUE_01_091: [If the type of the value is not double (was not created with amqpvalue_create_double), then amqpvalue_get_double shall return a non-zero value.] */\n        if (value_data->type != AMQP_TYPE_DOUBLE)\n        {\n            LogError(\"Value is not of type DOUBLE\");\n            result = MU_FAILURE;\n        }\n        else\n        {\n            /* Codes_SRS_AMQPVALUE_01_088: [amqpvalue_get_double shall fill in the double_value argument the double value stored by the AMQP value indicated by the value argument.] */\n            *double_value = value_data->value.double_value;\n\n            /* Codes_SRS_AMQPVALUE_01_089: [On success amqpvalue_get_double shall return 0.] */\n            result = 0;\n        }\n    }\n\n    return result;\n}\n\n/* Codes_SRS_AMQPVALUE_01_024: [1.6.16 char A single Unicode character.] */\nAMQP_VALUE amqpvalue_create_char(uint32_t value)\n{\n    AMQP_VALUE result;\n\n    /* Codes_SRS_AMQPVALUE_01_098: [If the code point value is outside of the allowed range [0, 0x10FFFF] then amqpvalue_create_char shall return NULL.] */\n    if (value > 0x10FFFF)\n    {\n        LogError(\"Invalid value for a Unicode char\");\n        result = NULL;\n    }\n    else\n    {\n        result = REFCOUNT_TYPE_CREATE(AMQP_VALUE_DATA);\n        if (result == NULL)\n        {\n            /* Codes_SRS_AMQPVALUE_01_093: [If allocating the AMQP_VALUE fails then amqpvalue_create_char shall return NULL.] */\n            LogError(\"Could not allocate memory for AMQP value\");\n        }\n        else\n        {\n            /* Codes_SRS_AMQPVALUE_01_092: [amqpvalue_create_char shall return a handle to an AMQP_VALUE that stores a single UTF-32 character value.] */\n            result->type = AMQP_TYPE_CHAR;\n            result->value.char_value = value;\n        }\n    }\n\n    return result;\n}\n\nint amqpvalue_get_char(AMQP_VALUE value, uint32_t* char_value)\n{\n    int result;\n\n    /* Codes_SRS_AMQPVALUE_01_096: [If any of the arguments is NULL then amqpvalue_get_char shall return a non-zero value.] */\n    if ((value == NULL) ||\n        (char_value == NULL))\n    {\n        LogError(\"Bad arguments: value = %p, double_value = %p\",\n            value, char_value);\n        result = MU_FAILURE;\n    }\n    else\n    {\n        AMQP_VALUE_DATA* value_data = (AMQP_VALUE_DATA*)value;\n        /* Codes_SRS_AMQPVALUE_01_097: [If the type of the value is not char (was not created with amqpvalue_create_char), then amqpvalue_get_char shall return a non-zero value.] */\n        if (value_data->type != AMQP_TYPE_CHAR)\n        {\n            LogError(\"Value is not of type CHAR\");\n            result = MU_FAILURE;\n        }\n        else\n        {\n            /* Codes_SRS_AMQPVALUE_01_094: [amqpvalue_get_char shall fill in the char_value argument the UTF32 char value stored by the AMQP value indicated by the value argument.] */\n            *char_value = value_data->value.char_value;\n\n            /* Codes_SRS_AMQPVALUE_01_095: [On success amqpvalue_get_char shall return 0.] */\n            result = 0;\n        }\n    }\n\n    return result;\n}\n\n/* Codes_SRS_AMQPVALUE_01_025: [1.6.17 timestamp An absolute point in time.] */\nAMQP_VALUE amqpvalue_create_timestamp(int64_t value)\n{\n    AMQP_VALUE result = REFCOUNT_TYPE_CREATE(AMQP_VALUE_DATA);\n    if (result == NULL)\n    {\n        /* Codes_SRS_AMQPVALUE_01_108: [If allocating the AMQP_VALUE fails then amqpvalue_create_timestamp shall return NULL.] */\n        LogError(\"Could not allocate memory for AMQP value\");\n    }\n    else\n    {\n        /* Codes_SRS_AMQPVALUE_01_107: [amqpvalue_create_timestamp shall return a handle to an AMQP_VALUE that stores an uint64_t value that represents a millisecond precision Unix time.] */\n        result->type = AMQP_TYPE_TIMESTAMP;\n        result->value.timestamp_value = value;\n    }\n\n    return result;\n}\n\nint amqpvalue_get_timestamp(AMQP_VALUE value, int64_t* timestamp_value)\n{\n    int result;\n\n    /* Codes_SRS_AMQPVALUE_01_111: [If any of the arguments is NULL then amqpvalue_get_timestamp shall return a non-zero value.] */\n    if ((value == NULL) ||\n        (timestamp_value == NULL))\n    {\n        LogError(\"Bad arguments: value = %p, timestamp_value = %p\",\n            value, timestamp_value);\n        result = MU_FAILURE;\n    }\n    else\n    {\n        AMQP_VALUE_DATA* value_data = (AMQP_VALUE_DATA*)value;\n        /* Codes_SRS_AMQPVALUE_01_112: [If the type of the value is not timestamp (was not created with amqpvalue_create_timestamp), then amqpvalue_get_timestamp shall return a non-zero value.] */\n        if (value_data->type != AMQP_TYPE_TIMESTAMP)\n        {\n            LogError(\"Value is not of type TIMESTAMP\");\n            result = MU_FAILURE;\n        }\n        else\n        {\n            /* Codes_SRS_AMQPVALUE_01_109: [amqpvalue_get_timestamp shall fill in the timestamp_value argument the timestamp value stored by the AMQP value indicated by the value argument.] */\n            *timestamp_value = value_data->value.timestamp_value;\n\n            /* Codes_SRS_AMQPVALUE_01_110: [On success amqpvalue_get_timestamp shall return 0.] */\n            result = 0;\n        }\n    }\n\n    return result;\n}\n\n/* Codes_SRS_AMQPVALUE_01_026: [1.6.18 uuid A universally unique identifier as defined by RFC-4122 section 4.1.2 .] */\nAMQP_VALUE amqpvalue_create_uuid(uuid value)\n{\n    AMQP_VALUE result = REFCOUNT_TYPE_CREATE(AMQP_VALUE_DATA);\n    if (result == NULL)\n    {\n        /* Codes_SRS_AMQPVALUE_01_114: [If allocating the AMQP_VALUE fails then amqpvalue_create_uuid shall return NULL.] */\n        LogError(\"Could not allocate memory for AMQP value\");\n    }\n    else\n    {\n        /* Codes_SRS_AMQPVALUE_01_113: [amqpvalue_create_uuid shall return a handle to an AMQP_VALUE that stores an uuid value that represents a unique identifier per RFC-4122 section 4.1.2.] */\n        result->type = AMQP_TYPE_UUID;\n        (void)memcpy(&result->value.uuid_value, value, 16);\n    }\n\n    return result;\n}\n\nint amqpvalue_get_uuid(AMQP_VALUE value, uuid* uuid_value)\n{\n    int result;\n\n    /* Codes_SRS_AMQPVALUE_01_117: [If any of the arguments is NULL then amqpvalue_get_uuid shall return a non-zero value.] */\n    if ((value == NULL) ||\n        (uuid_value == NULL))\n    {\n        LogError(\"Bad arguments: value = %p, uuid_value = %p\",\n            value, uuid_value);\n        result = MU_FAILURE;\n    }\n    else\n    {\n        AMQP_VALUE_DATA* value_data = (AMQP_VALUE_DATA*)value;\n        /* Codes_SRS_AMQPVALUE_01_118: [If the type of the value is not uuid (was not created with amqpvalue_create_uuid), then amqpvalue_get_uuid shall return a non-zero value.] */\n        if (value_data->type != AMQP_TYPE_UUID)\n        {\n            LogError(\"Value is not of type UUID\");\n            result = MU_FAILURE;\n        }\n        else\n        {\n            /* Codes_SRS_AMQPVALUE_01_115: [amqpvalue_get_uuid shall fill in the uuid_value argument the uuid value stored by the AMQP value indicated by the value argument.] */\n            (void)memcpy(*uuid_value, value_data->value.uuid_value, 16);\n\n            /* Codes_SRS_AMQPVALUE_01_116: [On success amqpvalue_get_uuid shall return 0.] */\n            result = 0;\n        }\n    }\n\n    return result;\n}\n\n/* Codes_SRS_AMQPVALUE_01_027: [1.6.19 binary A sequence of octets.] */\nAMQP_VALUE amqpvalue_create_binary(amqp_binary value)\n{\n    AMQP_VALUE result;\n    if ((value.bytes == NULL) &&\n        (value.length > 0))\n    {\n        /* Codes_SRS_AMQPVALUE_01_129: [If value.data is NULL and value.length is positive then amqpvalue_create_binary shall return NULL.] */\n        LogError(\"NULL bytes with non-zero length\");\n        result = NULL;\n    }\n    else\n    {\n        result = REFCOUNT_TYPE_CREATE(AMQP_VALUE_DATA);\n        if (result == NULL)\n        {\n            /* Codes_SRS_AMQPVALUE_01_128: [If allocating the AMQP_VALUE fails then amqpvalue_create_binary shall return NULL.] */\n            LogError(\"Could not allocate memory for AMQP value\");\n        }\n        else\n        {\n            /* Codes_SRS_AMQPVALUE_01_127: [amqpvalue_create_binary shall return a handle to an AMQP_VALUE that stores a sequence of bytes.] */\n            result->type = AMQP_TYPE_BINARY;\n            if (value.length > 0)\n            {\n                result->value.binary_value.bytes = malloc(value.length);\n            }\n            else\n            {\n                result->value.binary_value.bytes = NULL;\n            }\n\n            result->value.binary_value.length = value.length;\n\n            if ((result->value.binary_value.bytes == NULL) && (value.length > 0))\n            {\n                /* Codes_SRS_AMQPVALUE_01_128: [If allocating the AMQP_VALUE fails then amqpvalue_create_binary shall return NULL.] */\n                LogError(\"Could not allocate memory for binary payload of AMQP value\");\n                REFCOUNT_TYPE_DESTROY(AMQP_VALUE_DATA, result);\n                result = NULL;\n            }\n            else\n            {\n                if (value.length > 0)\n                {\n                    (void)memcpy((void*)result->value.binary_value.bytes, value.bytes, value.length);\n                }\n            }\n        }\n    }\n\n    return result;\n}\n\nint amqpvalue_get_binary(AMQP_VALUE value, amqp_binary* binary_value)\n{\n    int result;\n\n    /* Codes_SRS_AMQPVALUE_01_132: [If any of the arguments is NULL then amqpvalue_get_binary shall return NULL.] */\n    if ((value == NULL) ||\n        (binary_value == NULL))\n    {\n        LogError(\"Bad arguments: value = %p, binary_value = %p\",\n            value, binary_value);\n        result = MU_FAILURE;\n    }\n    else\n    {\n        AMQP_VALUE_DATA* value_data = (AMQP_VALUE_DATA*)value;\n        /* Codes_SRS_AMQPVALUE_01_133: [If the type of the value is not binary (was not created with amqpvalue_create_binary), then amqpvalue_get_binary shall return NULL.] */\n        if (value_data->type != AMQP_TYPE_BINARY)\n        {\n            LogError(\"Value is not of type BINARY\");\n            result = MU_FAILURE;\n        }\n        else\n        {\n            /* Codes_SRS_AMQPVALUE_01_131: [amqpvalue_get_binary shall yield a pointer to the sequence of bytes held by the AMQP_VALUE in binary_value.data and fill in the binary_value.length argument the number of bytes held in the binary value.] */\n            binary_value->length = value_data->value.binary_value.length;\n            binary_value->bytes = value_data->value.binary_value.bytes;\n\n            result = 0;\n        }\n    }\n\n    return result;\n}\n\n/* Codes_SRS_AMQPVALUE_01_135: [amqpvalue_create_string shall return a handle to an AMQP_VALUE that stores a sequence of Unicode characters.] */\n/* Codes_SRS_AMQPVALUE_01_028: [1.6.20 string A sequence of Unicode characters.] */\nAMQP_VALUE amqpvalue_create_string(const char* value)\n{\n    AMQP_VALUE result;\n    if (value == NULL)\n    {\n        LogError(\"NULL argument value\");\n        result = NULL;\n    }\n    else\n    {\n        size_t length = strlen(value);\n\n        result = REFCOUNT_TYPE_CREATE(AMQP_VALUE_DATA);\n        if (result == NULL)\n        {\n            /* Codes_SRS_AMQPVALUE_01_136: [If allocating the AMQP_VALUE fails then amqpvalue_create_string shall return NULL.] */\n            LogError(\"Could not allocate memory for AMQP value\");\n        }\n        else\n        {\n            result->type = AMQP_TYPE_STRING;\n            result->value.string_value.chars = (char*)malloc(length + 1);\n            if (result->value.string_value.chars == NULL)\n            {\n                /* Codes_SRS_AMQPVALUE_01_136: [If allocating the AMQP_VALUE fails then amqpvalue_create_string shall return NULL.] */\n                LogError(\"Could not allocate memory for string AMQP value\");\n                REFCOUNT_TYPE_DESTROY(AMQP_VALUE_DATA, result);\n                result = NULL;\n            }\n            else\n            {\n                (void)memcpy(result->value.string_value.chars, value, length + 1);\n            }\n        }\n    }\n\n    return result;\n}\n\nint amqpvalue_get_string(AMQP_VALUE value, const char** string_value)\n{\n    int result;\n\n    /* Codes_SRS_AMQPVALUE_01_139: [If any of the arguments is NULL then amqpvalue_get_string shall return a non-zero value.] */\n    if ((value == NULL) ||\n        (string_value == NULL))\n    {\n        LogError(\"Bad arguments: value = %p, string_value = %p\",\n            value, string_value);\n        result = MU_FAILURE;\n    }\n    else\n    {\n        AMQP_VALUE_DATA* value_data = (AMQP_VALUE_DATA*)value;\n\n        /* Codes_SRS_AMQPVALUE_01_140: [If the type of the value is not string (was not created with amqpvalue_create_string), then amqpvalue_get_string shall return a non-zero value.] */\n        if (value_data->type != AMQP_TYPE_STRING)\n        {\n            LogError(\"Value is not of type STRING\");\n            result = MU_FAILURE;\n        }\n        else\n        {\n            /* Codes_SRS_AMQPVALUE_01_138: [amqpvalue_get_string shall yield a pointer to the sequence of bytes held by the AMQP_VALUE in string_value.] */\n            *string_value = value_data->value.string_value.chars;\n\n            /* Codes_SRS_AMQPVALUE_01_141: [On success, amqpvalue_get_string shall return 0.] */\n            result = 0;\n        }\n    }\n\n    return result;\n}\n\n/* Codes_SRS_AMQPVALUE_01_029: [1.6.21 symbol Symbolic values from a constrained domain.] */\nAMQP_VALUE amqpvalue_create_symbol(const char* value)\n{\n    AMQP_VALUE result;\n    if (value == NULL)\n    {\n        /* Codes_SRS_AMQPVALUE_01_400: [If value is NULL, amqpvalue_create_symbol shall fail and return NULL.] */\n        LogError(\"NULL argument\");\n        result = NULL;\n    }\n    else\n    {\n        size_t length = strlen(value);\n        if (length > UINT32_MAX)\n        {\n            /* Codes_SRS_AMQPVALUE_01_401: [ If the string pointed to by value is longer than 2^32-1 then amqpvalue_create_symbol shall return NULL. ]*/\n            LogError(\"string too long to be represented as a symbol\");\n            result = NULL;\n        }\n        else\n        {\n            /* Codes_SRS_AMQPVALUE_01_143: [If allocating the AMQP_VALUE fails then amqpvalue_create_symbol shall return NULL.] */\n            result = REFCOUNT_TYPE_CREATE(AMQP_VALUE_DATA);\n            if (result == NULL)\n            {\n                LogError(\"Cannot allocate memory for AMQP value\");\n                result = NULL;\n            }\n            else\n            {\n                /* Codes_SRS_AMQPVALUE_01_142: [amqpvalue_create_symbol shall return a handle to an AMQP_VALUE that stores a symbol (ASCII string) value.] */\n                result->type = AMQP_TYPE_SYMBOL;\n                result->value.symbol_value.chars = (char*)malloc(length + 1);\n                if (result->value.symbol_value.chars == NULL)\n                {\n                    LogError(\"Cannot allocate memory for symbol string\");\n                    REFCOUNT_TYPE_DESTROY(AMQP_VALUE_DATA, result);\n                    result = NULL;\n                }\n                else\n                {\n                    (void)memcpy(result->value.symbol_value.chars, value, length + 1);\n                }\n            }\n        }\n    }\n\n    return result;\n}\n\nint amqpvalue_get_symbol(AMQP_VALUE value, const char** symbol_value)\n{\n    int result;\n\n    /* Codes_SRS_AMQPVALUE_01_147: [If any of the arguments is NULL then amqpvalue_get_symbol shall return a non-zero value.] */\n    if ((value == NULL) ||\n        (symbol_value == NULL))\n    {\n        LogError(\"Bad arguments: value = %p, symbol_value = %p\",\n            value, symbol_value);\n        result = MU_FAILURE;\n    }\n    else\n    {\n        AMQP_VALUE_DATA* value_data = (AMQP_VALUE_DATA*)value;\n\n        /* Codes_SRS_AMQPVALUE_01_148: [If the type of the value is not symbol (was not created with amqpvalue_create_symbol), then amqpvalue_get_symbol shall return a non-zero value.] */\n        if (value_data->type != AMQP_TYPE_SYMBOL)\n        {\n            LogError(\"Value is not of type SYMBOL\");\n            result = MU_FAILURE;\n        }\n        else\n        {\n            /* Codes_SRS_AMQPVALUE_01_145: [amqpvalue_get_symbol shall fill in the symbol_value the symbol value string held by the AMQP_VALUE.] */\n            *symbol_value = value_data->value.symbol_value.chars;\n\n            /* Codes_SRS_AMQPVALUE_01_146: [On success, amqpvalue_get_symbol shall return 0.] */\n            result = 0;\n        }\n    }\n\n    return result;\n}\n\n/* Codes_SRS_AMQPVALUE_01_030: [1.6.22 list A sequence of polymorphic values.] */\nAMQP_VALUE amqpvalue_create_list(void)\n{\n    AMQP_VALUE result = REFCOUNT_TYPE_CREATE(AMQP_VALUE_DATA);\n    if (result == NULL)\n    {\n        /* Codes_SRS_AMQPVALUE_01_150: [If allocating the AMQP_VALUE fails then amqpvalue_create_list shall return NULL.] */\n        LogError(\"Could not allocate memory for AMQP value\");\n    }\n    else\n    {\n        /* Codes_SRS_AMQPVALUE_01_149: [amqpvalue_create_list shall return a handle to an AMQP_VALUE that stores a list.] */\n        result->type = AMQP_TYPE_LIST;\n\n        /* Codes_SRS_AMQPVALUE_01_151: [The list shall have an initial size of zero.] */\n        result->value.list_value.count = 0;\n        result->value.list_value.items = NULL;\n    }\n\n    return result;\n}\n\nint amqpvalue_set_list_item_count(AMQP_VALUE value, uint32_t list_size)\n{\n    int result;\n\n    /* Codes_SRS_AMQPVALUE_01_155: [If the value argument is NULL, amqpvalue_set_list_item_count shall return a non-zero value.] */\n    if (value == NULL)\n    {\n        LogError(\"NULL list value\");\n        result = MU_FAILURE;\n    }\n    else\n    {\n        AMQP_VALUE_DATA* value_data = (AMQP_VALUE_DATA*)value;\n        if (value_data->type != AMQP_TYPE_LIST)\n        {\n            /* Codes_SRS_AMQPVALUE_01_156: [If the value is not of type list, then amqpvalue_set_list_item_count shall return a non-zero value.] */\n            LogError(\"Value is not of type LIST\");\n            result = MU_FAILURE;\n        }\n        else\n        {\n            if (value_data->value.list_value.count < list_size)\n            {\n                AMQP_VALUE* new_list;\n\n                /* Codes_SRS_AMQPVALUE_01_152: [amqpvalue_set_list_item_count shall resize an AMQP list.] */\n                new_list = (AMQP_VALUE*)realloc(value_data->value.list_value.items, list_size * sizeof(AMQP_VALUE));\n                if (new_list == NULL)\n                {\n                    /* Codes_SRS_AMQPVALUE_01_154: [If allocating memory for the list according to the new size fails, then amqpvalue_set_list_item_count shall return a non-zero value, while preserving the existing list contents.] */\n                    LogError(\"Could not reallocate list memory\");\n                    result = MU_FAILURE;\n                }\n                else\n                {\n                    uint32_t i;\n                    value_data->value.list_value.items = new_list;\n\n                    /* Codes_SRS_AMQPVALUE_01_162: [When a list is grown a null AMQP_VALUE shall be inserted as new list items to fill the list up to the new size.] */\n                    for (i = value_data->value.list_value.count; i < list_size; i++)\n                    {\n                        new_list[i] = amqpvalue_create_null();\n                        if (new_list[i] == NULL)\n                        {\n                            LogError(\"Could not create NULL AMQP value to be inserted in list\");\n                            break;\n                        }\n                    }\n\n                    if (i < list_size)\n                    {\n                        /* Codes_SRS_AMQPVALUE_01_154: [If allocating memory for the list according to the new size fails, then amqpvalue_set_list_item_count shall return a non-zero value, while preserving the existing list contents.] */\n                        uint32_t j;\n                        for (j = value_data->value.list_value.count; j < i; j++)\n                        {\n                            amqpvalue_destroy(new_list[j]);\n                        }\n\n                        result = MU_FAILURE;\n                    }\n                    else\n                    {\n                        value_data->value.list_value.count = list_size;\n\n                        /* Codes_SRS_AMQPVALUE_01_153: [On success amqpvalue_set_list_item_count shall return 0.] */\n                        result = 0;\n                    }\n                }\n            }\n            else if (value_data->value.list_value.count > list_size)\n            {\n                uint32_t i;\n\n                /* Codes_SRS_AMQPVALUE_01_161: [When the list is shrunk, the extra items shall be freed by using amqp_value_destroy.] */\n                for (i = list_size; i < value_data->value.list_value.count; i++)\n                {\n                    amqpvalue_destroy(value_data->value.list_value.items[i]);\n                }\n\n                value_data->value.list_value.count = list_size;\n\n                /* Codes_SRS_AMQPVALUE_01_153: [On success amqpvalue_set_list_item_count shall return 0.] */\n                result = 0;\n            }\n            else\n            {\n                /* Codes_SRS_AMQPVALUE_01_153: [On success amqpvalue_set_list_item_count shall return 0.] */\n                result = 0;\n            }\n        }\n    }\n\n    return result;\n}\n\nint amqpvalue_get_list_item_count(AMQP_VALUE value, uint32_t* size)\n{\n    int result;\n\n    /* Codes_SRS_AMQPVALUE_01_159: [If any of the arguments are NULL, amqpvalue_get_list_item_count shall return a non-zero value.] */\n    if ((value == NULL) ||\n        (size == NULL))\n    {\n        LogError(\"Bad arguments: value = %p, size = %p\",\n            value, size);\n        result = MU_FAILURE;\n    }\n    else\n    {\n        AMQP_VALUE_DATA* value_data = (AMQP_VALUE_DATA*)value;\n\n        /* Codes_SRS_AMQPVALUE_01_160: [If the AMQP_VALUE is not a list then amqpvalue_get_list_item_count shall return a non-zero value.] */\n        if (value_data->type != AMQP_TYPE_LIST)\n        {\n            LogError(\"Value is not of type LIST\");\n            result = MU_FAILURE;\n        }\n        else\n        {\n            /* Codes_SRS_AMQPVALUE_01_157: [amqpvalue_get_list_item_count shall fill in the size argument the number of items held by the AMQP list.] */\n            *size = value_data->value.list_value.count;\n\n            /* Codes_SRS_AMQPVALUE_01_158: [On success amqpvalue_get_list_item_count shall return 0.] */\n            result = 0;\n        }\n    }\n\n    return result;\n}\n\nint amqpvalue_set_list_item(AMQP_VALUE value, uint32_t index, AMQP_VALUE list_item_value)\n{\n    int result;\n\n    /* Codes_SRS_AMQPVALUE_01_165: [If value or list_item_value is NULL, amqpvalue_set_list_item shall fail and return a non-zero value.] */\n    if (value == NULL)\n    {\n        LogError(\"NULL list value\");\n        result = MU_FAILURE;\n    }\n    else\n    {\n        AMQP_VALUE_DATA* value_data = (AMQP_VALUE_DATA*)value;\n        if (value_data->type != AMQP_TYPE_LIST)\n        {\n            LogError(\"Value is not of type LIST\");\n            result = MU_FAILURE;\n        }\n        else\n        {\n            /* Codes_SRS_AMQPVALUE_01_168: [The item stored at the index-th position in the list shall be a clone of list_item_value.] */\n            AMQP_VALUE cloned_item = amqpvalue_clone(list_item_value);\n            if (cloned_item == NULL)\n            {\n                /* Codes_SRS_AMQPVALUE_01_170: [When amqpvalue_set_list_item fails due to not being able to clone the item or grow the list, the list shall not be altered.] */\n                /* Codes_SRS_AMQPVALUE_01_169: [If cloning the item fails, amqpvalue_set_list_item shall fail and return a non-zero value.] */\n                LogError(\"Could not clone list item\");\n                result = MU_FAILURE;\n            }\n            else\n            {\n                if (index >= value_data->value.list_value.count)\n                {\n                    AMQP_VALUE* new_list = (AMQP_VALUE*)realloc(value_data->value.list_value.items, ((size_t)index + 1) * sizeof(AMQP_VALUE));\n                    if (new_list == NULL)\n                    {\n                        /* Codes_SRS_AMQPVALUE_01_170: [When amqpvalue_set_list_item fails due to not being able to clone the item or grow the list, the list shall not be altered.] */\n                        LogError(\"Could not reallocate list storage\");\n                        amqpvalue_destroy(cloned_item);\n                        result = MU_FAILURE;\n                    }\n                    else\n                    {\n                        uint32_t i;\n\n                        value_data->value.list_value.items = new_list;\n\n                        for (i = value_data->value.list_value.count; i < index; i++)\n                        {\n                            new_list[i] = amqpvalue_create_null();\n                            if (new_list[i] == NULL)\n                            {\n                                LogError(\"Could not allocate NULL value for list entries\");\n                                break;\n                            }\n                        }\n\n                        if (i < index)\n                        {\n                            /* Codes_SRS_AMQPVALUE_01_170: [When amqpvalue_set_list_item fails due to not being able to clone the item or grow the list, the list shall not be altered.] */\n                            uint32_t j;\n\n                            for (j = value_data->value.list_value.count; j < i; j++)\n                            {\n                                amqpvalue_destroy(new_list[j]);\n                            }\n\n                            amqpvalue_destroy(cloned_item);\n\n                            /* Codes_SRS_AMQPVALUE_01_172: [If growing the list fails, then amqpvalue_set_list_item shall fail and return a non-zero value.] */\n                            result = MU_FAILURE;\n                        }\n                        else\n                        {\n                            value_data->value.list_value.count = index + 1;\n                            value_data->value.list_value.items[index] = cloned_item;\n\n                            /* Codes_SRS_AMQPVALUE_01_164: [On success amqpvalue_set_list_item shall return 0.] */\n                            result = 0;\n                        }\n                    }\n                }\n                else\n                {\n                    /* Codes_SRS_AMQPVALUE_01_167: [Any previous value stored at the position index in the list shall be freed by using amqpvalue_destroy.] */\n                    amqpvalue_destroy(value_data->value.list_value.items[index]);\n\n                    /* Codes_SRS_AMQPVALUE_01_163: [amqpvalue_set_list_item shall replace the item at the 0 based index-th position in the list identified by the value argument with the AMQP_VALUE specified by list_item_value.] */\n                    value_data->value.list_value.items[index] = cloned_item;\n\n                    /* Codes_SRS_AMQPVALUE_01_164: [On success amqpvalue_set_list_item shall return 0.] */\n                    result = 0;\n                }\n            }\n        }\n    }\n\n    return result;\n}\n\nAMQP_VALUE amqpvalue_get_list_item(AMQP_VALUE value, size_t index)\n{\n    AMQP_VALUE result;\n\n    if (value == NULL)\n    {\n        /* Codes_SRS_AMQPVALUE_01_174: [If the value argument is NULL, amqpvalue_get_list_item shall fail and return NULL.] */\n        LogError(\"NULL list value\");\n        result = NULL;\n    }\n    else\n    {\n        AMQP_VALUE_DATA* value_data = (AMQP_VALUE_DATA*)value;\n\n        /* Codes_SRS_AMQPVALUE_01_177: [If value is not a list then amqpvalue_get_list_item shall fail and return NULL.] */\n        if (value_data->type != AMQP_TYPE_LIST)\n        {\n            LogError(\"Value is not of type LIST\");\n            result = NULL;\n        }\n        /* Codes_SRS_AMQPVALUE_01_175: [If index is greater or equal to the number of items in the list then amqpvalue_get_list_item shall fail and return NULL.] */\n        else if (value_data->value.list_value.count <= index)\n        {\n            LogError(\"Bad index value %u\", (unsigned int)index);\n            result = NULL;\n        }\n        else\n        {\n            /* Codes_SRS_AMQPVALUE_01_173: [amqpvalue_get_list_item shall return a copy of the AMQP_VALUE stored at the 0 based position index in the list identified by value.] */\n            /* Codes_SRS_AMQPVALUE_01_176: [If cloning the item at position index fails, then amqpvalue_get_list_item shall fail and return NULL.] */\n            result = amqpvalue_clone(value_data->value.list_value.items[index]);\n        }\n    }\n\n    return result;\n}\n\n/* Codes_SRS_AMQPVALUE_01_178: [amqpvalue_create_map shall create an AMQP value that holds a map and return a handle to it.] */\n/* Codes_SRS_AMQPVALUE_01_031: [1.6.23 map A polymorphic mapping from distinct keys to values.] */\nAMQP_VALUE amqpvalue_create_map(void)\n{\n    AMQP_VALUE result = REFCOUNT_TYPE_CREATE(AMQP_VALUE_DATA);\n    if (result == NULL)\n    {\n        /* Codes_SRS_AMQPVALUE_01_179: [If allocating memory for the map fails, then amqpvalue_create_map shall return NULL.] */\n        LogError(\"Could not allocate memory for AMQP value\");\n    }\n    else\n    {\n        result->type = AMQP_TYPE_MAP;\n\n        /* Codes_SRS_AMQPVALUE_01_180: [The number of key/value pairs in the newly created map shall be zero.] */\n        result->value.map_value.pairs = NULL;\n        result->value.map_value.pair_count = 0;\n    }\n\n    return result;\n}\n\nint amqpvalue_set_map_value(AMQP_VALUE map, AMQP_VALUE key, AMQP_VALUE value)\n{\n    int result;\n\n    /* Codes_SRS_AMQPVALUE_01_183: [If any of the arguments are NULL, amqpvalue_set_map_value shall fail and return a non-zero value.] */\n    if ((map == NULL) ||\n        (key == NULL) ||\n        (value == NULL))\n    {\n        LogError(\"Bad arguments: map = %p, key = %p, value = %p\",\n            map, key, value);\n        result = MU_FAILURE;\n    }\n    else\n    {\n        AMQP_VALUE_DATA* value_data = (AMQP_VALUE_DATA*)map;\n\n        /* Codes_SRS_AMQPVALUE_01_196: [If the map argument is not an AMQP value created with the amqpvalue_create_map function than amqpvalue_set_map_value shall fail and return a non-zero value.] */\n        if (value_data->type != AMQP_TYPE_MAP)\n        {\n            LogError(\"Value is not of type MAP\");\n            result = MU_FAILURE;\n        }\n        else\n        {\n            AMQP_VALUE cloned_value;\n\n            /* Codes_SRS_AMQPVALUE_01_185: [When storing the key or value, their contents shall be cloned.] */\n            cloned_value = amqpvalue_clone(value);\n            if (cloned_value == NULL)\n            {\n                /* Codes_SRS_AMQPVALUE_01_188: [If cloning the value fails, amqpvalue_set_map_value shall fail and return a non-zero value.] */\n                LogError(\"Could not clone value to set in the map\");\n                result = MU_FAILURE;\n            }\n            else\n            {\n                uint32_t i;\n                AMQP_VALUE cloned_key;\n\n                for (i = 0; i < value_data->value.map_value.pair_count; i++)\n                {\n                    if (amqpvalue_are_equal(value_data->value.map_value.pairs[i].key, key))\n                    {\n                        LogError(\"Could not allocate NULL value for map entries\");\n                        break;\n                    }\n                }\n\n                if (i < value_data->value.map_value.pair_count)\n                {\n                    /* Codes_SRS_AMQPVALUE_01_184: [If the key already exists in the map, its value shall be replaced with the value provided by the value argument.] */\n                    /* Codes_SRS_AMQPVALUE_01_125: [A map in which there exist two identical key values is invalid.] */\n                    amqpvalue_destroy(value_data->value.map_value.pairs[i].value);\n                    value_data->value.map_value.pairs[i].value = cloned_value;\n\n                    /* Codes_SRS_AMQPVALUE_01_182: [On success amqpvalue_set_map_value shall return 0.] */\n                    result = 0;\n                }\n                else\n                {\n                    /* Codes_SRS_AMQPVALUE_01_185: [When storing the key or value, their contents shall be cloned.] */\n                    cloned_key = amqpvalue_clone(key);\n                    if (cloned_key == NULL)\n                    {\n                        /* Codes_SRS_AMQPVALUE_01_187: [If cloning the key fails, amqpvalue_set_map_value shall fail and return a non-zero value.] */\n                        amqpvalue_destroy(cloned_value);\n                        LogError(\"Could not clone key for map\");\n                        result = MU_FAILURE;\n                    }\n                    else\n                    {\n                        AMQP_MAP_KEY_VALUE_PAIR* new_pairs = (AMQP_MAP_KEY_VALUE_PAIR*)realloc(value_data->value.map_value.pairs, ((size_t)value_data->value.map_value.pair_count + 1) * sizeof(AMQP_MAP_KEY_VALUE_PAIR));\n                        if (new_pairs == NULL)\n                        {\n                            /* Codes_SRS_AMQPVALUE_01_186: [If allocating memory to hold a new key/value pair fails, amqpvalue_set_map_value shall fail and return a non-zero value.] */\n                            amqpvalue_destroy(cloned_key);\n                            amqpvalue_destroy(cloned_value);\n                            LogError(\"Could not reallocate memory for map\");\n                            result = MU_FAILURE;\n                        }\n                        else\n                        {\n                            value_data->value.map_value.pairs = new_pairs;\n\n                            /* Codes_SRS_AMQPVALUE_01_181: [amqpvalue_set_map_value shall set the value in the map identified by the map argument for a key/value pair identified by the key argument.] */\n                            value_data->value.map_value.pairs[value_data->value.map_value.pair_count].key = cloned_key;\n                            value_data->value.map_value.pairs[value_data->value.map_value.pair_count].value = cloned_value;\n                            value_data->value.map_value.pair_count++;\n\n                            /* Codes_SRS_AMQPVALUE_01_182: [On success amqpvalue_set_map_value shall return 0.] */\n                            result = 0;\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    return result;\n}\n\nAMQP_VALUE amqpvalue_get_map_value(AMQP_VALUE map, AMQP_VALUE key)\n{\n    AMQP_VALUE result;\n\n    /* Codes_SRS_AMQPVALUE_01_190: [If any argument is NULL, amqpvalue_get_map_value shall return NULL.] */\n    if ((map == NULL) ||\n        (key == NULL))\n    {\n        LogError(\"Bad arguments: map = %p, key = %p\",\n            map, key);\n        result = NULL;\n    }\n    else\n    {\n        AMQP_VALUE_DATA* value_data = (AMQP_VALUE_DATA*)map;\n\n        /* Codes_SRS_AMQPVALUE_01_197: [If the map argument is not an AMQP value created with the amqpvalue_create_map function than amqpvalue_get_map_value shall return NULL.] */\n        if (value_data->type != AMQP_TYPE_MAP)\n        {\n            LogError(\"Value is not of type MAP\");\n            result = NULL;\n        }\n        else\n        {\n            uint32_t i;\n\n            for (i = 0; i < value_data->value.map_value.pair_count; i++)\n            {\n                if (amqpvalue_are_equal(value_data->value.map_value.pairs[i].key, key))\n                {\n                    break;\n                }\n            }\n\n            if (i == value_data->value.map_value.pair_count)\n            {\n                /* Codes_SRS_AMQPVALUE_01_191: [If the key cannot be found, amqpvalue_get_map_value shall return NULL.] */\n                result = NULL;\n            }\n            else\n            {\n                /* Codes_SRS_AMQPVALUE_01_189: [amqpvalue_get_map_value shall return the value whose key is identified by the key argument.] */\n                /* Codes_SRS_AMQPVALUE_01_192: [The returned value shall be a clone of the actual value stored in the map.] */\n                result = amqpvalue_clone(value_data->value.map_value.pairs[i].value);\n            }\n        }\n    }\n\n    return result;\n}\n\nint amqpvalue_get_map_pair_count(AMQP_VALUE map, uint32_t* pair_count)\n{\n    int result;\n\n    /* Codes_SRS_AMQPVALUE_01_195: [If any of the arguments is NULL, amqpvalue_get_map_pair_count shall fail and return a non-zero value.] */\n    if ((map == NULL) ||\n        (pair_count == NULL))\n    {\n        LogError(\"Bad arguments: map = %p, pair_count = %p\",\n            map, pair_count);\n        result = MU_FAILURE;\n    }\n    else\n    {\n        AMQP_VALUE_DATA* value_data = (AMQP_VALUE_DATA*)map;\n\n        if (value_data->type != AMQP_TYPE_MAP)\n        {\n            /* Codes_SRS_AMQPVALUE_01_198: [If the map argument is not an AMQP value created with the amqpvalue_create_map function then amqpvalue_get_map_pair_count shall fail and return a non-zero value.] */\n            LogError(\"Value is not of type MAP\");\n            result = MU_FAILURE;\n        }\n        else\n        {\n            /* Codes_SRS_AMQPVALUE_01_193: [amqpvalue_get_map_pair_count shall fill in the number of key/value pairs in the map in the pair_count argument.] */\n            *pair_count = value_data->value.map_value.pair_count;\n\n            /* Codes_SRS_AMQPVALUE_01_194: [On success amqpvalue_get_map_pair_count shall return 0.] */\n            result = 0;\n        }\n    }\n\n    return result;\n}\n\nint amqpvalue_get_map_key_value_pair(AMQP_VALUE map, uint32_t index, AMQP_VALUE* key, AMQP_VALUE* value)\n{\n    int result;\n\n    /* Codes_SRS_AMQPVALUE_01_201: [If any of the map, key or value arguments is NULL, amqpvalue_get_map_key_value_pair shall fail and return a non-zero value.] */\n    if ((map == NULL) ||\n        (key == NULL) ||\n        (value == NULL))\n    {\n        LogError(\"Bad arguments: map = %p, key = %p, value = %p\",\n            map, key, value);\n        result = MU_FAILURE;\n    }\n    else\n    {\n        AMQP_VALUE_DATA* value_data = (AMQP_VALUE_DATA*)map;\n\n        if (value_data->type != AMQP_TYPE_MAP)\n        {\n            /* Codes_SRS_AMQPVALUE_01_205: [If the map argument is not an AMQP value created with the amqpvalue_create_map function then amqpvalue_get_map_key_value_pair shall fail and return a non-zero value.] */\n            LogError(\"Value is not of type MAP\");\n            result = MU_FAILURE;\n        }\n        else if (value_data->value.map_value.pair_count <= index)\n        {\n            /* Codes_SRS_AMQPVALUE_01_204: [If the index argument is greater or equal to the number of key/value pairs in the map then amqpvalue_get_map_key_value_pair shall fail and return a non-zero value.] */\n            LogError(\"Index out of range: %u\", (unsigned int)index);\n            result = MU_FAILURE;\n        }\n        else\n        {\n            /* Codes_SRS_AMQPVALUE_01_199: [amqpvalue_get_map_key_value_pair shall fill in the key and value arguments copies of the key/value pair on the 0 based position index in a map.] */\n            *key = amqpvalue_clone(value_data->value.map_value.pairs[index].key);\n            if (*key == NULL)\n            {\n                /* Codes_SRS_AMQPVALUE_01_202: [If cloning the key fails, amqpvalue_get_map_key_value_pair shall fail and return a non-zero value.] */\n                LogError(\"Could not clone index %u key\", (unsigned int)index);\n                result = MU_FAILURE;\n            }\n            else\n            {\n                *value = amqpvalue_clone(value_data->value.map_value.pairs[index].value);\n                if (*value == NULL)\n                {\n                    /* Codes_SRS_AMQPVALUE_01_203: [If cloning the value fails, amqpvalue_get_map_key_value_pair shall fail and return a non-zero value.] */\n                    amqpvalue_destroy(*key);\n                    LogError(\"Could not clone index %u value\", (unsigned int)index);\n                    result = MU_FAILURE;\n                }\n                else\n                {\n                    /* Codes_SRS_AMQPVALUE_01_200: [On success amqpvalue_get_map_key_value_pair shall return 0.] */\n                    result = 0;\n                }\n            }\n        }\n    }\n\n    return result;\n}\n\nint amqpvalue_get_map(AMQP_VALUE value, AMQP_VALUE* map_value)\n{\n    int result;\n\n    if ((value == NULL) ||\n        (map_value == NULL))\n    {\n        LogError(\"Bad arguments: value = %p, map_value = %p\",\n            value, map_value);\n        result = MU_FAILURE;\n    }\n    else\n    {\n        AMQP_VALUE_DATA* value_data = (AMQP_VALUE_DATA*)value;\n        if (value_data->type != AMQP_TYPE_MAP)\n        {\n            LogError(\"Value is not of type MAP\");\n            result = MU_FAILURE;\n        }\n        else\n        {\n            *map_value = value;\n            result = 0;\n        }\n    }\n\n    return result;\n}\n\n/* Codes_SRS_AMQPVALUE_01_397: [1.6.24 array A sequence of values of a single type.] */\nAMQP_VALUE amqpvalue_create_array(void)\n{\n    AMQP_VALUE result = REFCOUNT_TYPE_CREATE(AMQP_VALUE_DATA);\n    if (result == NULL)\n    {\n        /* Codes_SRS_AMQPVALUE_01_405: [ If allocating memory for the array fails, then `amqpvalue_create_array` shall return NULL. ] */\n        LogError(\"Could not allocate memory for AMQP value\");\n    }\n    else\n    {\n        /* Codes_SRS_AMQPVALUE_01_404: [ `amqpvalue_create_array` shall return a handle to an AMQP_VALUE that stores an array. ] */\n        result->type = AMQP_TYPE_ARRAY;\n\n        /* Codes_SRS_AMQPVALUE_01_406: [ The array shall have an initial size of zero. ] */\n        result->value.array_value.items = NULL;\n        result->value.array_value.count = 0;\n    }\n\n    return result;\n}\n\nint amqpvalue_get_array_item_count(AMQP_VALUE value, uint32_t* count)\n{\n    int result;\n\n    /* Tests_SRS_AMQPVALUE_01_421: [ If any of the arguments is NULL, `amqpvalue_get_array_item_count` shall fail and return a non-zero value. ]*/\n    if ((value == NULL) ||\n        (count == NULL))\n    {\n        LogError(\"Bad arguments: value = %p, count = %p\",\n            value, count);\n        result = MU_FAILURE;\n    }\n    else\n    {\n        AMQP_VALUE_DATA* value_data = (AMQP_VALUE_DATA*)value;\n\n        /* Codes_SRS_AMQPVALUE_01_422: [ If the array argument is not an AMQP value created with the `amqpvalue_create_array` function then `amqpvalue_get_array_item_count` shall fail and return a non-zero value. ]*/\n        if (value_data->type != AMQP_TYPE_ARRAY)\n        {\n            LogError(\"Value is not of type ARRAY\");\n            result = MU_FAILURE;\n        }\n        else\n        {\n            /* Codes_SRS_AMQPVALUE_01_419: [ `amqpvalue_get_array_item_count` shall return in `count` the number of items in the array. ]*/\n            *count = value_data->value.array_value.count;\n\n            /* Codes_SRS_AMQPVALUE_01_420: [ On success `amqpvalue_get_array_item_count` shall return 0. ]*/\n            result = 0;\n        }\n    }\n\n    return result;\n}\n\nint amqpvalue_add_array_item(AMQP_VALUE value, AMQP_VALUE array_item_value)\n{\n    int result;\n\n    /* Codes_SRS_AMQPVALUE_01_409: [ If `value` or `array_item_value` is NULL, amqpvalue_add_array_item shall fail and return a non-zero value. ]*/\n    if (value == NULL)\n    {\n        LogError(\"NULL value\");\n        result = MU_FAILURE;\n    }\n    else\n    {\n        /* Codes_SRS_AMQPVALUE_01_413: [ If the `value` argument is not an AMQP array created with the `amqpvalue_create_array` function than `amqpvalue_add_array_item` shall fail and return a non-zero value. ] */\n        AMQP_VALUE_DATA* value_data = (AMQP_VALUE_DATA*)value;\n        if (value_data->type != AMQP_TYPE_ARRAY)\n        {\n            LogError(\"Value is not of type ARRAY\");\n            result = MU_FAILURE;\n        }\n        else\n        {\n            /* Codes_SRS_AMQPVALUE_01_425: [ If the type of `array_item_value` does not match that of items already in the array then `amqpvalue_add_array_item` shall fail and return a non-zero value. ] */\n            AMQP_VALUE_DATA* array_item_value_data = (AMQP_VALUE_DATA*)array_item_value;\n            if ((value_data->value.array_value.count > 0) &&\n                (array_item_value_data->type != value_data->value.array_value.items[0]->type))\n            {\n                LogError(\"Cannot put different types in the same array\");\n                result = MU_FAILURE;\n            }\n            else\n            {\n                /* Codes_SRS_AMQPVALUE_01_410: [ The item stored at the n-th position in the array shall be a clone of `array_item_value`. ] */\n                AMQP_VALUE cloned_item = amqpvalue_clone(array_item_value);\n                if (cloned_item == NULL)\n                {\n                    /* Codes_SRS_AMQPVALUE_01_423: [ When `amqpvalue_add_array_item` fails due to not being able to clone the item or grow the array, the array shall not be altered. ] */\n                    /* Codes_SRS_AMQPVALUE_01_412: [ If cloning the item fails, `amqpvalue_add_array_item` shall fail and return a non-zero value. ]*/\n                    LogError(\"Cannot clone value to put in the array\");\n                    result = MU_FAILURE;\n                }\n                else\n                {\n                    AMQP_VALUE* new_array = (AMQP_VALUE*)realloc(value_data->value.array_value.items, ((size_t)value_data->value.array_value.count + 1) * sizeof(AMQP_VALUE));\n                    if (new_array == NULL)\n                    {\n                        /* Codes_SRS_AMQPVALUE_01_423: [ When `amqpvalue_add_array_item` fails due to not being able to clone the item or grow the array, the array shall not be altered. ] */\n                        /* Codes_SRS_AMQPVALUE_01_424: [ If growing the array fails, then `amqpvalue_add_array_item` shall fail and return a non-zero value. ] */\n                        amqpvalue_destroy(cloned_item);\n                        LogError(\"Cannot resize array\");\n                        result = MU_FAILURE;\n                    }\n                    else\n                    {\n                        value_data->value.array_value.items = new_array;\n\n                        /* Codes_SRS_AMQPVALUE_01_407: [ `amqpvalue_add_array_item` shall add the AMQP_VALUE specified by `array_item_value` at the 0 based n-th position in the array. ]*/\n                        value_data->value.array_value.items[value_data->value.array_value.count] = cloned_item;\n                        value_data->value.array_value.count++;\n\n                        /* Codes_SRS_AMQPVALUE_01_408: [ On success `amqpvalue_add_array_item` shall return 0. ]*/\n                        result = 0;\n                    }\n                }\n            }\n        }\n    }\n\n    return result;\n}\n\nAMQP_VALUE amqpvalue_get_array_item(AMQP_VALUE value, uint32_t index)\n{\n    AMQP_VALUE result;\n\n    if (value == NULL)\n    {\n        /* Codes_SRS_AMQPVALUE_01_416: [ If the `value` argument is NULL, `amqpvalue_get_array_item` shall fail and return NULL. ] */\n        LogError(\"NULL value\");\n        result = NULL;\n    }\n    else\n    {\n        AMQP_VALUE_DATA* value_data = (AMQP_VALUE_DATA*)value;\n\n        /* Codes_SRS_AMQPVALUE_01_418: [ If value is not an array then `amqpvalue_get_array_item` shall fail and return NULL. ] */\n        if (value_data->type != AMQP_TYPE_ARRAY)\n        {\n            LogError(\"Value is not of type ARRAY\");\n            result = NULL;\n        }\n        /* Codes_SRS_AMQPVALUE_01_417: [ If `index` is greater or equal to the number of items in the array then `amqpvalue_get_array_item` shall fail and return NULL. ] */\n        else if (value_data->value.array_value.count <= index)\n        {\n            LogError(\"Index out of range: %u\", (unsigned int)index);\n            result = NULL;\n        }\n        else\n        {\n            /* Codes_SRS_AMQPVALUE_01_414: [ `amqpvalue_get_array_item` shall return a copy of the AMQP_VALUE stored at the 0 based position `index` in the array identified by `value`. ] */\n            /* Codes_SRS_AMQPVALUE_01_426: [ If cloning the item at position `index` fails, then `amqpvalue_get_array_item` shall fail and return NULL. ] */\n            result = amqpvalue_clone(value_data->value.array_value.items[index]);\n        }\n    }\n\n    return result;\n}\n\nint amqpvalue_get_array(AMQP_VALUE value, AMQP_VALUE* array_value)\n{\n    int result;\n\n    if ((value == NULL) ||\n        (array_value == NULL))\n    {\n        LogError(\"Bad arguments: value = %p, array_value = %p\",\n            value, array_value);\n        result = MU_FAILURE;\n    }\n    else\n    {\n        AMQP_VALUE_DATA* value_data = (AMQP_VALUE_DATA*)value;\n        if (value_data->type != AMQP_TYPE_ARRAY)\n        {\n            LogError(\"Value is not of type ARRAY\");\n            result = MU_FAILURE;\n        }\n        else\n        {\n            *array_value = value;\n            result = 0;\n        }\n    }\n\n    return result;\n}\n\n/* Codes_SRS_AMQPVALUE_01_206: [amqpvalue_are_equal shall return true if the contents of value1 and value2 are equal.] */\nbool amqpvalue_are_equal(AMQP_VALUE value1, AMQP_VALUE value2)\n{\n    bool result;\n\n    /* Codes_SRS_AMQPVALUE_01_207: [If value1 and value2 are NULL, amqpvalue_are_equal shall return true.] */\n    if ((value1 == NULL) &&\n        (value2 == NULL))\n    {\n        LogError(\"Bad arguments: value1 = %p, value2 = %p\",\n            value1, value2);\n        result = true;\n    }\n    /* Codes_SRS_AMQPVALUE_01_208: [If one of the arguments is NULL and the other is not, amqpvalue_are_equal shall return false.] */\n    else if ((value1 != value2) && ((value1 == NULL) || (value2 == NULL)))\n    {\n        result = false;\n    }\n    else\n    {\n        AMQP_VALUE_DATA* value1_data = (AMQP_VALUE_DATA*)value1;\n        AMQP_VALUE_DATA* value2_data = (AMQP_VALUE_DATA*)value2;\n\n        /* Codes_SRS_AMQPVALUE_01_209: [If the types for value1 and value2 are different amqpvalue_are_equal shall return false.] */\n#if _MSC_VER\n#pragma warning(suppress: 28182) /* The compiler states that value2_data can be NULL, but it cannot. And there are tests for it. */\n#endif\n        if (value1_data->type != value2_data->type)\n        {\n            result = false;\n        }\n        else\n        {\n            switch (value1_data->type)\n            {\n            default:\n                result = false;\n                break;\n\n            case AMQP_TYPE_NULL:\n                /* Codes_SRS_AMQPVALUE_01_210: [- null: always equal.] */\n                result = true;\n                break;\n\n            case AMQP_TYPE_BOOL:\n                /* Codes_SRS_AMQPVALUE_01_211: [- boolean: compare the bool content.] */\n                result = (value1_data->value.bool_value == value2_data->value.bool_value);\n                break;\n\n            case AMQP_TYPE_UBYTE:\n                /* Codes_SRS_AMQPVALUE_01_212: [- ubyte: compare the unsigned char content.] */\n                result = (value1_data->value.ubyte_value == value2_data->value.ubyte_value);\n                break;\n\n            case AMQP_TYPE_USHORT:\n                /* Codes_SRS_AMQPVALUE_01_213: [- ushort: compare the uint16_t content.] */\n                result = (value1_data->value.ushort_value == value2_data->value.ushort_value);\n                break;\n\n            case AMQP_TYPE_UINT:\n                /* Codes_SRS_AMQPVALUE_01_214: [- uint: compare the uint32_t content.] */\n                result = (value1_data->value.uint_value == value2_data->value.uint_value);\n                break;\n\n            case AMQP_TYPE_ULONG:\n                /* Codes_SRS_AMQPVALUE_01_215: [- ulong: compare the uint64_t content.] */\n                result = (value1_data->value.ulong_value == value2_data->value.ulong_value);\n                break;\n\n            case AMQP_TYPE_BYTE:\n                /* Codes_SRS_AMQPVALUE_01_216: [- byte: compare the char content.] */\n                result = (value1_data->value.byte_value == value2_data->value.byte_value);\n                break;\n\n            case AMQP_TYPE_SHORT:\n                /* Codes_SRS_AMQPVALUE_01_217: [- short: compare the int16_t content.] */\n                result = (value1_data->value.short_value == value2_data->value.short_value);\n                break;\n\n            case AMQP_TYPE_INT:\n                /* Codes_SRS_AMQPVALUE_01_218: [- int: compare the int32_t content.] */\n                result = (value1_data->value.int_value == value2_data->value.int_value);\n                break;\n\n            case AMQP_TYPE_LONG:\n                /* Codes_SRS_AMQPVALUE_01_219: [- long: compare the int64_t content.] */\n                result = (value1_data->value.long_value == value2_data->value.long_value);\n                break;\n\n            case AMQP_TYPE_FLOAT:\n                /* Codes_SRS_AMQPVALUE_01_224: [- float: compare the float content.] */\n                result = (value1_data->value.float_value == value2_data->value.float_value);\n                break;\n\n            case AMQP_TYPE_DOUBLE:\n                /* Codes_SRS_AMQPVALUE_01_225: [- double: compare the double content.] */\n                result = (value1_data->value.double_value == value2_data->value.double_value);\n                break;\n\n            case AMQP_TYPE_CHAR:\n                /* Codes_SRS_AMQPVALUE_01_226: [- char: compare the UNICODE character.] */\n                result = (value1_data->value.char_value == value2_data->value.char_value);\n                break;\n\n            case AMQP_TYPE_TIMESTAMP:\n                /* Codes_SRS_AMQPVALUE_01_227: [- timestamp: compare the underlying 64 bit integer.] */\n                result = (value1_data->value.timestamp_value == value2_data->value.timestamp_value);\n                break;\n\n            case AMQP_TYPE_UUID:\n                /* Codes_SRS_AMQPVALUE_01_228: [- uuid: compare all uuid bytes.] */\n                result = (memcmp(value1_data->value.uuid_value, value2_data->value.uuid_value, sizeof(value1_data->value.uuid_value)) == 0);\n                break;\n\n            case AMQP_TYPE_BINARY:\n                /* Codes_SRS_AMQPVALUE_01_229: [- binary: compare all binary bytes.] */\n                result = (value1_data->value.binary_value.length == value2_data->value.binary_value.length) &&\n                    (memcmp(value1_data->value.binary_value.bytes, value2_data->value.binary_value.bytes, value1_data->value.binary_value.length) == 0);\n                break;\n\n            case AMQP_TYPE_STRING:\n                /* Codes_SRS_AMQPVALUE_01_230: [- string: compare all string characters.] */\n                result = (strcmp(value1_data->value.string_value.chars, value2_data->value.string_value.chars) == 0);\n                break;\n\n            case AMQP_TYPE_SYMBOL:\n                /* Codes_SRS_AMQPVALUE_01_263: [- symbol: compare all symbol characters.] */\n                result = (strcmp(value1_data->value.symbol_value.chars, value2_data->value.symbol_value.chars) == 0);\n                break;\n\n            case AMQP_TYPE_LIST:\n            {\n                /* Codes_SRS_AMQPVALUE_01_231: [- list: compare list item count and each element.] */\n                if (value1_data->value.list_value.count != value2_data->value.list_value.count)\n                {\n                    result = false;\n                }\n                else\n                {\n                    uint32_t i;\n\n                    for (i = 0; i < value1_data->value.list_value.count; i++)\n                    {\n                        /* Codes_SRS_AMQPVALUE_01_232: [Nesting shall be considered in comparison.] */\n                        if (!amqpvalue_are_equal(value1_data->value.list_value.items[i], value2_data->value.list_value.items[i]))\n                        {\n                            break;\n                        }\n                    }\n\n                    result = (i == value1_data->value.list_value.count);\n                }\n\n                break;\n            }\n            case AMQP_TYPE_ARRAY:\n            {\n                /* Codes_SRS_AMQPVALUE_01_427: [- array: compare array item count and each element. ] */\n                if (value1_data->value.array_value.count != value2_data->value.array_value.count)\n                {\n                    result = false;\n                }\n                else\n                {\n                    uint32_t i;\n\n                    for (i = 0; i < value1_data->value.array_value.count; i++)\n                    {\n                        /* Codes_SRS_AMQPVALUE_01_428: [ Nesting shall be considered in comparison. ] */\n                        if (!amqpvalue_are_equal(value1_data->value.array_value.items[i], value2_data->value.array_value.items[i]))\n                        {\n                            break;\n                        }\n                    }\n\n                    result = (i == value1_data->value.array_value.count);\n                }\n\n                break;\n            }\n            case AMQP_TYPE_MAP:\n            {\n                /* Codes_SRS_AMQPVALUE_01_233: [- map: compare map pair count and each key/value pair.] */\n                if (value1_data->value.map_value.pair_count != value2_data->value.map_value.pair_count)\n                {\n                    result = false;\n                }\n                else\n                {\n                    uint32_t i;\n\n                    /* Codes_SRS_AMQPVALUE_01_126: [Unless known to be otherwise, maps MUST be considered to be ordered, that is, the order of the key-value pairs is semantically important and two maps which are different only in the order in which their key-value pairs are encoded are not equal.] */\n                    for (i = 0; i < value1_data->value.map_value.pair_count; i++)\n                    {\n                        /* Codes_SRS_AMQPVALUE_01_234: [Nesting shall be considered in comparison.] */\n                        if ((!amqpvalue_are_equal(value1_data->value.map_value.pairs[i].key, value2_data->value.map_value.pairs[i].key)) ||\n                            (!amqpvalue_are_equal(value1_data->value.map_value.pairs[i].value, value2_data->value.map_value.pairs[i].value)))\n                        {\n                            break;\n                        }\n                    }\n\n                    result = (i == value1_data->value.map_value.pair_count);\n                }\n\n                break;\n            }\n            }\n        }\n    }\n\n    return result;\n}\n\nAMQP_VALUE amqpvalue_clone(AMQP_VALUE value)\n{\n    AMQP_VALUE result;\n\n    if (value == NULL)\n    {\n        /* Codes_SRS_AMQPVALUE_01_402: [ If `value` is NULL, `amqpvalue_clone` shall return NULL. ]*/\n        LogError(\"NULL value\");\n        result = NULL;\n    }\n    else\n    {\n        /* Codes_SRS_AMQPVALUE_01_235: [amqpvalue_clone shall clone the value passed as argument and return a new non-NULL handle to the cloned AMQP value.] */\n        INC_REF(AMQP_VALUE_DATA, value);\n        result = value;\n    }\n\n    return result;\n}\n\nAMQP_TYPE amqpvalue_get_type(AMQP_VALUE value)\n{\n    AMQP_VALUE_DATA* amqpvalue_data = (AMQP_VALUE_DATA*)value;\n    return amqpvalue_data->type;\n}\n\nstatic int output_byte(AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context, unsigned char b)\n{\n    int result;\n\n    if (encoder_output != NULL)\n    {\n        /* Codes_SRS_AMQPVALUE_01_267: [amqpvalue_encode shall pass the encoded bytes to the encoder_output function.] */\n        /* Codes_SRS_AMQPVALUE_01_268: [On each call to the encoder_output function, amqpvalue_encode shall also pass the context argument.] */\n        result = encoder_output(context, &b, 1);\n    }\n    else\n    {\n        result = 0;\n    }\n\n    return result;\n}\n\nstatic int output_bytes(AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context, const void* bytes, size_t length)\n{\n    int result;\n\n    if (encoder_output != NULL)\n    {\n        /* Codes_SRS_AMQPVALUE_01_267: [amqpvalue_encode shall pass the encoded bytes to the encoder_output function.] */\n        /* Codes_SRS_AMQPVALUE_01_268: [On each call to the encoder_output function, amqpvalue_encode shall also pass the context argument.] */\n        result = encoder_output(context, (const unsigned char*)bytes, length);\n    }\n    else\n    {\n        result = 0;\n    }\n\n    return result;\n}\n\nstatic int encode_null_constructor(AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context)\n{\n    int result;\n\n    /* Codes_SRS_AMQPVALUE_01_264: [<encoding code=\"0x40\" category=\"fixed\" width=\"0\" label=\"the null value\"/>] */\n    if (output_byte(encoder_output, context, (unsigned char)0x40) != 0)\n    {\n        /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */\n        LogError(\"Failed encoding NULL constructor\");\n        result = MU_FAILURE;\n    }\n    else\n    {\n        /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */\n        result = 0;\n    }\n\n    return result;\n}\n\nstatic int encode_null_value(AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context)\n{\n    int result = 0;\n    (void)encoder_output;\n    (void)context;\n\n    /* Codes_SRS_AMQPVALUE_01_264: [<encoding code=\"0x40\" category=\"fixed\" width=\"0\" label=\"the null value\"/>] */\n    return result;\n}\n\nstatic int encode_null(AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context)\n{\n    int result;\n\n    if ((encode_null_constructor(encoder_output, context) != 0) ||\n        (encode_null_value(encoder_output, context) != 0))\n    {\n        /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */\n        LogError(\"Failed encoding NULL\");\n        result = MU_FAILURE;\n    }\n    else\n    {\n        /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */\n        result = 0;\n    }\n\n    return result;\n}\n\nstatic int encode_boolean_constructor(AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context)\n{\n    int result;\n\n    /* Codes_SRS_AMQPVALUE_01_270: [<encoding code=\"0x56\" category=\"fixed\" width=\"1\" label=\"boolean with the octet 0x00 being false and octet 0x01 being true\"/>] */\n    if (output_byte(encoder_output, context, 0x56) != 0)\n    {\n        /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */\n        LogError(\"Failed encoding boolean constructor\");\n        result = MU_FAILURE;\n    }\n    else\n    {\n        /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */\n        result = 0;\n    }\n\n    return result;\n}\n\nstatic int encode_boolean_value(AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context, bool value)\n{\n    int result;\n\n    if (value == false)\n    {\n        /* Codes_SRS_AMQPVALUE_01_270: [<encoding code=\"0x56\" category=\"fixed\" width=\"1\" label=\"boolean with the octet 0x00 being false and octet 0x01 being true\"/>] */\n        if (output_byte(encoder_output, context, 0x00) != 0)\n        {\n            /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */\n            LogError(\"Failed encoding boolean value\");\n            result = MU_FAILURE;\n        }\n        else\n        {\n            result = 0;\n        }\n    }\n    else\n    {\n        /* Codes_SRS_AMQPVALUE_01_270: [<encoding code=\"0x56\" category=\"fixed\" width=\"1\" label=\"boolean with the octet 0x00 being false and octet 0x01 being true\"/>] */\n        if (output_byte(encoder_output, context, 0x01) != 0)\n        {\n            /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */\n            LogError(\"Failed encoding boolean value\");\n            result = MU_FAILURE;\n        }\n        else\n        {\n            result = 0;\n        }\n    }\n\n    return result;\n}\n\nstatic int encode_boolean(AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context, bool value)\n{\n    int result;\n\n    if (value == false)\n    {\n        /* Codes_SRS_AMQPVALUE_01_273: [<encoding name=\"false\" code=\"0x42\" category=\"fixed\" width=\"0\" label=\"the boolean value false\"/>] */\n        if (output_byte(encoder_output, context, 0x42) != 0)\n        {\n            /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */\n            LogError(\"Failed encoding boolean\");\n            result = MU_FAILURE;\n        }\n        else\n        {\n            result = 0;\n        }\n    }\n    else\n    {\n        /* Codes_SRS_AMQPVALUE_01_272: [<encoding name=\"true\" code=\"0x41\" category=\"fixed\" width=\"0\" label=\"the boolean value true\"/>] */\n        if (output_byte(encoder_output, context, 0x41) != 0)\n        {\n            /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */\n            LogError(\"Failed encoding boolean\");\n            result = MU_FAILURE;\n        }\n        else\n        {\n            result = 0;\n        }\n    }\n\n    return result;\n}\n\nstatic int encode_ubyte_constructor(AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context)\n{\n    int result;\n\n    /* Codes_SRS_AMQPVALUE_01_275: [<encoding code=\"0x50\" category=\"fixed\" width=\"1\" label=\"8-bit unsigned integer\"/>] */\n    if (output_byte(encoder_output, context, 0x50) != 0)\n    {\n        /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */\n        LogError(\"Failed encoding ubyte constructor\");\n        result = MU_FAILURE;\n    }\n    else\n    {\n        /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */\n        result = 0;\n    }\n\n    return result;\n}\n\nstatic int encode_ubyte_value(AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context, unsigned char value)\n{\n    int result;\n\n    /* Codes_SRS_AMQPVALUE_01_275: [<encoding code=\"0x50\" category=\"fixed\" width=\"1\" label=\"8-bit unsigned integer\"/>] */\n    if (output_byte(encoder_output, context, value) != 0)\n    {\n        /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */\n        LogError(\"Failed encoding ubyte value\");\n        result = MU_FAILURE;\n    }\n    else\n    {\n        /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */\n        result = 0;\n    }\n\n    return result;\n}\n\nstatic int encode_ubyte(AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context, unsigned char value)\n{\n    int result;\n\n    if ((encode_ubyte_constructor(encoder_output, context) != 0) ||\n        (encode_ubyte_value(encoder_output, context, value) != 0))\n    {\n        /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */\n        LogError(\"Failed encoding ubyte\");\n        result = MU_FAILURE;\n    }\n    else\n    {\n        /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */\n        result = 0;\n    }\n\n    return result;\n}\n\nstatic int encode_ushort_constructor(AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context)\n{\n    int result;\n\n    /* Codes_SRS_AMQPVALUE_01_276: [<encoding code=\"0x60\" category=\"fixed\" width=\"2\" label=\"16-bit unsigned integer in network byte order\"/>] */\n    if (output_byte(encoder_output, context, 0x60) != 0)\n    {\n        /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */\n        LogError(\"Failed encoding ushort constructor\");\n        result = MU_FAILURE;\n    }\n    else\n    {\n        /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */\n        result = 0;\n    }\n\n    return result;\n}\n\nstatic int encode_ushort_value(AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context, uint16_t value)\n{\n    int result;\n\n    /* Codes_SRS_AMQPVALUE_01_276: [<encoding code=\"0x60\" category=\"fixed\" width=\"2\" label=\"16-bit unsigned integer in network byte order\"/>] */\n    if ((output_byte(encoder_output, context, (value >> 8) & 0xFF) != 0) ||\n        (output_byte(encoder_output, context, (value & 0xFF)) != 0))\n    {\n        /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */\n        LogError(\"Failed encoding ushort value\");\n        result = MU_FAILURE;\n    }\n    else\n    {\n        /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */\n        result = 0;\n    }\n\n    return result;\n}\n\nstatic int encode_ushort(AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context, uint16_t value)\n{\n    int result;\n\n    if ((encode_ushort_constructor(encoder_output, context) != 0) ||\n        (encode_ushort_value(encoder_output, context, value) != 0))\n    {\n        /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */\n        LogError(\"Failed encoding ushort\");\n        result = MU_FAILURE;\n    }\n    else\n    {\n        /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */\n        result = 0;\n    }\n\n    return result;\n}\n\nstatic int encode_uint_constructor(AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context, bool use_smallest)\n{\n    int result;\n\n    if (use_smallest)\n    {\n        /* smalluint */\n        /* Codes_SRS_AMQPVALUE_01_278: [<encoding name=\"smalluint\" code=\"0x52\" category=\"fixed\" width=\"1\" label=\"unsigned integer value in the range 0 to 255 inclusive\"/>] */\n        if (output_byte(encoder_output, context, 0x52) != 0)\n        {\n            /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */\n            LogError(\"Failed encoding small uint constructor\");\n            result = MU_FAILURE;\n        }\n        else\n        {\n            /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */\n            result = 0;\n        }\n    }\n    else\n    {\n        /* Codes_SRS_AMQPVALUE_01_277: [<encoding code=\"0x70\" category=\"fixed\" width=\"4\" label=\"32-bit unsigned integer in network byte order\"/>] */\n        if (output_byte(encoder_output, context, 0x70) != 0)\n        {\n            /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */\n            LogError(\"Failed encoding uint constructor\");\n            result = MU_FAILURE;\n        }\n        else\n        {\n            /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */\n            result = 0;\n        }\n    }\n\n    return result;\n}\n\nstatic int encode_uint_value(AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context, uint32_t value, bool use_smallest)\n{\n    int result;\n\n    if (use_smallest)\n    {\n        /* smalluint */\n        /* Codes_SRS_AMQPVALUE_01_278: [<encoding name=\"smalluint\" code=\"0x52\" category=\"fixed\" width=\"1\" label=\"unsigned integer value in the range 0 to 255 inclusive\"/>] */\n        if (output_byte(encoder_output, context, value & 0xFF) != 0)\n        {\n            /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */\n            LogError(\"Failed encoding small uint value\");\n            result = MU_FAILURE;\n        }\n        else\n        {\n            /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */\n            result = 0;\n        }\n    }\n    else\n    {\n        /* Codes_SRS_AMQPVALUE_01_277: [<encoding code=\"0x70\" category=\"fixed\" width=\"4\" label=\"32-bit unsigned integer in network byte order\"/>] */\n        if ((output_byte(encoder_output, context, (value >> 24) & 0xFF) != 0) ||\n            (output_byte(encoder_output, context, (value >> 16) & 0xFF) != 0) ||\n            (output_byte(encoder_output, context, (value >> 8) & 0xFF) != 0) ||\n            (output_byte(encoder_output, context, value & 0xFF) != 0))\n        {\n            /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */\n            LogError(\"Failed encoding uint value\");\n            result = MU_FAILURE;\n        }\n        else\n        {\n            /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */\n            result = 0;\n        }\n    }\n\n    return result;\n}\n\nstatic int encode_uint(AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context, uint32_t value)\n{\n    int result;\n\n    if (value == 0)\n    {\n        /* uint0 */\n        /* Codes_SRS_AMQPVALUE_01_279: [<encoding name=\"uint0\" code=\"0x43\" category=\"fixed\" width=\"0\" label=\"the uint value 0\"/>] */\n        if (output_byte(encoder_output, context, 0x43) != 0)\n        {\n            LogError(\"Failed encoding uint\");\n            result = MU_FAILURE;\n        }\n        else\n        {\n            /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */\n            result = 0;\n        }\n    }\n    else\n    {\n        bool use_smallest = (value <= 255);\n\n        if ((encode_uint_constructor(encoder_output, context, use_smallest) != 0) ||\n            (encode_uint_value(encoder_output, context, value, use_smallest) != 0))\n        {\n            /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */\n            LogError(\"Failed encoding uint\");\n            result = MU_FAILURE;\n        }\n        else\n        {\n            /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */\n            result = 0;\n        }\n    }\n\n    return result;\n}\n\nstatic int encode_ulong_constructor(AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context, bool use_smallest)\n{\n    int result;\n\n    if (use_smallest)\n    {\n        /* smallulong */\n        /* Codes_SRS_AMQPVALUE_01_281: [<encoding name=\"smallulong\" code=\"0x53\" category=\"fixed\" width=\"1\" label=\"unsigned long value in the range 0 to 255 inclusive\"/>] */\n        if (output_byte(encoder_output, context, 0x53) != 0)\n        {\n            /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */\n            LogError(\"Failed encoding small ulong constructor\");\n            result = MU_FAILURE;\n        }\n        else\n        {\n            /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */\n            result = 0;\n        }\n    }\n    else\n    {\n        /* Codes_SRS_AMQPVALUE_01_280: [<encoding code=\"0x80\" category=\"fixed\" width=\"8\" label=\"64-bit unsigned integer in network byte order\"/>] */\n        if (output_byte(encoder_output, context, 0x80) != 0)\n        {\n            /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */\n            LogError(\"Failed encoding ulong constructor\");\n            result = MU_FAILURE;\n        }\n        else\n        {\n            /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */\n            result = 0;\n        }\n    }\n\n    return result;\n}\n\nstatic int encode_ulong_value(AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context, uint64_t value, bool use_smallest)\n{\n    int result;\n\n    if (use_smallest)\n    {\n        /* smallulong */\n        /* Codes_SRS_AMQPVALUE_01_281: [<encoding name=\"smallulong\" code=\"0x53\" category=\"fixed\" width=\"1\" label=\"unsigned long value in the range 0 to 255 inclusive\"/>] */\n        if (output_byte(encoder_output, context, value & 0xFF) != 0)\n        {\n            /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */\n            LogError(\"Failed encoding small ulong value\");\n            result = MU_FAILURE;\n        }\n        else\n        {\n            /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */\n            result = 0;\n        }\n    }\n    else\n    {\n        /* Codes_SRS_AMQPVALUE_01_280: [<encoding code=\"0x80\" category=\"fixed\" width=\"8\" label=\"64-bit unsigned integer in network byte order\"/>] */\n        if ((output_byte(encoder_output, context, (value >> 56) & 0xFF) != 0) ||\n            (output_byte(encoder_output, context, (value >> 48) & 0xFF) != 0) ||\n            (output_byte(encoder_output, context, (value >> 40) & 0xFF) != 0) ||\n            (output_byte(encoder_output, context, (value >> 32) & 0xFF) != 0) ||\n            (output_byte(encoder_output, context, (value >> 24) & 0xFF) != 0) ||\n            (output_byte(encoder_output, context, (value >> 16) & 0xFF) != 0) ||\n            (output_byte(encoder_output, context, (value >> 8) & 0xFF) != 0) ||\n            (output_byte(encoder_output, context, value & 0xFF) != 0))\n        {\n            /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */\n            LogError(\"Failed encoding ulong value\");\n            result = MU_FAILURE;\n        }\n        else\n        {\n            /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */\n            result = 0;\n        }\n    }\n\n    return result;\n}\n\nstatic int encode_ulong(AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context, uint64_t value)\n{\n    int result;\n    if (value == 0)\n    {\n        /* ulong0 */\n        /* Codes_SRS_AMQPVALUE_01_282: [<encoding name=\"ulong0\" code=\"0x44\" category=\"fixed\" width=\"0\" label=\"the ulong value 0\"/>] */\n        if (output_byte(encoder_output, context, 0x44) != 0)\n        {\n            /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */\n            LogError(\"Failed encoding ulong\");\n            result = MU_FAILURE;\n        }\n        else\n        {\n            /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */\n            result = 0;\n        }\n    }\n    else\n    {\n        bool use_smallest = (value <= 255);\n\n        if ((encode_ulong_constructor(encoder_output, context, use_smallest) != 0) ||\n            (encode_ulong_value(encoder_output, context, value, use_smallest) != 0))\n        {\n            /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */\n            LogError(\"Failed encoding ulong\");\n            result = MU_FAILURE;\n        }\n        else\n        {\n            /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */\n            result = 0;\n        }\n    }\n\n    return result;\n}\n\nstatic int encode_byte_constructor(AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context)\n{\n    int result;\n\n    /* Codes_SRS_AMQPVALUE_01_283: [<encoding code=\"0x51\" category=\"fixed\" width=\"1\" label=\"8-bit two's-complement integer\"/>] */\n    if (output_byte(encoder_output, context, 0x51) != 0)\n    {\n        /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */\n        LogError(\"Failed encoding byte constructor\");\n        result = MU_FAILURE;\n    }\n    else\n    {\n        /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */\n        result = 0;\n    }\n\n    return result;\n}\n\nstatic int encode_byte_value(AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context, char value)\n{\n    int result;\n\n    /* Codes_SRS_AMQPVALUE_01_283: [<encoding code=\"0x51\" category=\"fixed\" width=\"1\" label=\"8-bit two's-complement integer\"/>] */\n    if (output_byte(encoder_output, context, value) != 0)\n    {\n        /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */\n        LogError(\"Failed encoding byte value\");\n        result = MU_FAILURE;\n    }\n    else\n    {\n        /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */\n        result = 0;\n    }\n\n    return result;\n}\n\nstatic int encode_byte(AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context, char value)\n{\n    int result;\n\n    if ((encode_byte_constructor(encoder_output, context) != 0) ||\n        (encode_byte_value(encoder_output, context, value) != 0))\n    {\n        /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */\n        LogError(\"Failed encoding byte\");\n        result = MU_FAILURE;\n    }\n    else\n    {\n        /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */\n        result = 0;\n    }\n\n    return result;\n}\n\nstatic int encode_short_constructor(AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context)\n{\n    int result;\n\n    /* Codes_SRS_AMQPVALUE_01_284: [<encoding code=\"0x61\" category=\"fixed\" width=\"2\" label=\"16-bit two's-complement integer in network byte order\"/>] */\n    if (output_byte(encoder_output, context, 0x61) != 0)\n    {\n        /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */\n        LogError(\"Failed encoding short constructor\");\n        result = MU_FAILURE;\n    }\n    else\n    {\n        /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */\n        result = 0;\n    }\n\n    return result;\n}\n\nstatic int encode_short_value(AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context, int16_t value)\n{\n    int result;\n\n    /* Codes_SRS_AMQPVALUE_01_284: [<encoding code=\"0x61\" category=\"fixed\" width=\"2\" label=\"16-bit two's-complement integer in network byte order\"/>] */\n    if ((output_byte(encoder_output, context, (value >> 8) & 0xFF) != 0) ||\n        (output_byte(encoder_output, context, (value & 0xFF)) != 0))\n    {\n        /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */\n        LogError(\"Failed encoding short value\");\n        result = MU_FAILURE;\n    }\n    else\n    {\n        /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */\n        result = 0;\n    }\n\n    return result;\n}\n\nstatic int encode_short(AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context, int16_t value)\n{\n    int result;\n\n    if ((encode_short_constructor(encoder_output, context) != 0) ||\n        (encode_short_value(encoder_output, context, value) != 0))\n    {\n        /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */\n        LogError(\"Failed encoding short\");\n        result = MU_FAILURE;\n    }\n    else\n    {\n        /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */\n        result = 0;\n    }\n\n    return result;\n}\n\nstatic int encode_int_constructor(AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context, bool use_smallest)\n{\n    int result;\n\n    if (use_smallest)\n    {\n        /* Codes_SRS_AMQPVALUE_01_286: [<encoding name=\"smallint\" code=\"0x54\" category=\"fixed\" width=\"1\" label=\"8-bit two's-complement integer\"/>] */\n        if (output_byte(encoder_output, context, 0x54) != 0)\n        {\n            /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */\n            LogError(\"Failed encoding small int constructor\");\n            result = MU_FAILURE;\n        }\n        else\n        {\n            /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */\n            result = 0;\n        }\n    }\n    else\n    {\n        /* Codes_SRS_AMQPVALUE_01_285: [<encoding code=\"0x71\" category=\"fixed\" width=\"4\" label=\"32-bit two's-complement integer in network byte order\"/>] */\n        if (output_byte(encoder_output, context, 0x71) != 0)\n        {\n            /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */\n            LogError(\"Failed encoding int constructor\");\n            result = MU_FAILURE;\n        }\n        else\n        {\n            /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */\n            result = 0;\n        }\n    }\n\n    return result;\n}\n\nstatic int encode_int_value(AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context, int32_t value, bool use_smallest)\n{\n    int result;\n\n    if (use_smallest)\n    {\n        /* Codes_SRS_AMQPVALUE_01_286: [<encoding name=\"smallint\" code=\"0x54\" category=\"fixed\" width=\"1\" label=\"8-bit two's-complement integer\"/>] */\n        if (output_byte(encoder_output, context, value & 0xFF) != 0)\n        {\n            /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */\n            LogError(\"Failed encoding small int value\");\n            result = MU_FAILURE;\n        }\n        else\n        {\n            /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */\n            result = 0;\n        }\n    }\n    else\n    {\n        /* Codes_SRS_AMQPVALUE_01_285: [<encoding code=\"0x71\" category=\"fixed\" width=\"4\" label=\"32-bit two's-complement integer in network byte order\"/>] */\n        if ((output_byte(encoder_output, context, (value >> 24) & 0xFF) != 0) ||\n            (output_byte(encoder_output, context, (value >> 16) & 0xFF) != 0) ||\n            (output_byte(encoder_output, context, (value >> 8) & 0xFF) != 0) ||\n            (output_byte(encoder_output, context, value & 0xFF) != 0))\n        {\n            /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */\n            LogError(\"Failed encoding int value\");\n            result = MU_FAILURE;\n        }\n        else\n        {\n            /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */\n            result = 0;\n        }\n    }\n\n    return result;\n}\n\nstatic int encode_int(AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context, int32_t value)\n{\n    int result;\n    bool use_smallest = ((value <= 127) && (value >= -128));\n\n    if ((encode_int_constructor(encoder_output, context, use_smallest) != 0) ||\n        (encode_int_value(encoder_output, context, value, use_smallest) != 0))\n    {\n        /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */\n        LogError(\"Failed encoding int\");\n        result = MU_FAILURE;\n    }\n    else\n    {\n        /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */\n        result = 0;\n    }\n\n    return result;\n}\n\nstatic int encode_long_constructor(AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context, bool use_smallest)\n{\n    int result;\n\n    if (use_smallest)\n    {\n        /* Codes_SRS_AMQPVALUE_01_288: [<encoding name=\"smalllong\" code=\"0x55\" category=\"fixed\" width=\"1\" label=\"8-bit two's-complement integer\"/>] */\n        if (output_byte(encoder_output, context, 0x55) != 0)\n        {\n            /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */\n            LogError(\"Failed encoding small long constructor\");\n            result = MU_FAILURE;\n        }\n        else\n        {\n            /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */\n            result = 0;\n        }\n    }\n    else\n    {\n        /* Codes_SRS_AMQPVALUE_01_287: [<encoding code=\"0x81\" category=\"fixed\" width=\"8\" label=\"64-bit two's-complement integer in network byte order\"/>] */\n        if (output_byte(encoder_output, context, 0x81) != 0)\n        {\n            /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */\n            LogError(\"Failed encoding long constructor\");\n            result = MU_FAILURE;\n        }\n        else\n        {\n            /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */\n            result = 0;\n        }\n    }\n\n    return result;\n}\n\nstatic int encode_long_value(AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context, int64_t value, bool use_smallest)\n{\n    int result;\n\n    if (use_smallest)\n    {\n        /* Codes_SRS_AMQPVALUE_01_288: [<encoding name=\"smalllong\" code=\"0x55\" category=\"fixed\" width=\"1\" label=\"8-bit two's-complement integer\"/>] */\n        if (output_byte(encoder_output, context, value & 0xFF) != 0)\n        {\n            /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */\n            LogError(\"Failed encoding small long value\");\n            result = MU_FAILURE;\n        }\n        else\n        {\n            /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */\n            result = 0;\n        }\n    }\n    else\n    {\n        /* Codes_SRS_AMQPVALUE_01_287: [<encoding code=\"0x81\" category=\"fixed\" width=\"8\" label=\"64-bit two's-complement integer in network byte order\"/>] */\n        if ((output_byte(encoder_output, context, (value >> 56) & 0xFF) != 0) ||\n            (output_byte(encoder_output, context, (value >> 48) & 0xFF) != 0) ||\n            (output_byte(encoder_output, context, (value >> 40) & 0xFF) != 0) ||\n            (output_byte(encoder_output, context, (value >> 32) & 0xFF) != 0) ||\n            (output_byte(encoder_output, context, (value >> 24) & 0xFF) != 0) ||\n            (output_byte(encoder_output, context, (value >> 16) & 0xFF) != 0) ||\n            (output_byte(encoder_output, context, (value >> 8) & 0xFF) != 0) ||\n            (output_byte(encoder_output, context, value & 0xFF) != 0))\n        {\n            /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */\n            LogError(\"Failed encoding long value\");\n            result = MU_FAILURE;\n        }\n        else\n        {\n            /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */\n            result = 0;\n        }\n    }\n\n    return result;\n}\n\nstatic int encode_long(AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context, int64_t value)\n{\n    int result;\n    bool use_smallest = ((value <= 127) && (value >= -128));\n\n    if ((encode_long_constructor(encoder_output, context, use_smallest) != 0) ||\n        (encode_long_value(encoder_output, context, value, use_smallest) != 0))\n    {\n        /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */\n        LogError(\"Failed encoding long\");\n        result = MU_FAILURE;\n    }\n    else\n    {\n        /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */\n        result = 0;\n    }\n\n    return result;\n}\n\nstatic int encode_float_constructor(AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context)\n{\n    int result;\n\n    /* Codes_SRS_AMQPVALUE_01_289: [\\<encoding name=\"ieee-754\" code=\"0x72\" category=\"fixed\" width=\"4\" label=\"IEEE 754-2008 binary32\"/>] */\n    if (output_byte(encoder_output, context, 0x72) != 0)\n    {\n        /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */\n        LogError(\"Failure encoding constructor for float\");\n        result = MU_FAILURE;\n    }\n    else\n    {\n        /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */\n        result = 0;\n    }\n\n    return result;\n}\n\nstatic int encode_float_value(AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context, float value)\n{\n    int result;\n\n    uint32_t value_as_uint32 = *((uint32_t*)(void*)&value);\n    /* Codes_SRS_AMQPVALUE_01_289: [\\<encoding name=\"ieee-754\" code=\"0x72\" category=\"fixed\" width=\"4\" label=\"IEEE 754-2008 binary32\"/>] */\n    if ((output_byte(encoder_output, context, (value_as_uint32 >> 24) & 0xFF) != 0) ||\n        (output_byte(encoder_output, context, (value_as_uint32 >> 16) & 0xFF) != 0) ||\n        (output_byte(encoder_output, context, (value_as_uint32 >> 8) & 0xFF) != 0) ||\n        (output_byte(encoder_output, context, (value_as_uint32) & 0xFF) != 0))\n    {\n        /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */\n        LogError(\"Failure encoding bytes for float\");\n        result = MU_FAILURE;\n    }\n    else\n    {\n        /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */\n        result = 0;\n    }\n\n    return result;\n}\n\nstatic int encode_float(AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context, float value)\n{\n    int result;\n\n    if ((encode_float_constructor(encoder_output, context) != 0) ||\n        (encode_float_value(encoder_output, context, value) != 0))\n    {\n        /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */\n        LogError(\"Failure encoding float value\");\n        result = MU_FAILURE;\n    }\n    else\n    {\n        /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */\n        result = 0;\n    }\n\n    return result;\n}\n\nstatic int encode_double_constructor(AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context)\n{\n    int result;\n\n    /* Codes_SRS_AMQPVALUE_01_290: [\\<encoding name=\"ieee-754\" code=\"0x82\" category=\"fixed\" width=\"8\" label=\"IEEE 754-2008 binary64\"/>] */\n    if (output_byte(encoder_output, context, 0x82) != 0)\n    {\n        /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */\n        LogError(\"Failure encoding constructor for double\");\n        result = MU_FAILURE;\n    }\n    else\n    {\n        /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */\n        result = 0;\n    }\n\n    return result;\n}\n\nstatic int encode_double_value(AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context, double value)\n{\n    int result;\n\n    uint64_t value_as_uint64 = *((uint64_t*)(void*)&value);\n    /* Codes_SRS_AMQPVALUE_01_290: [\\<encoding name=\"ieee-754\" code=\"0x82\" category=\"fixed\" width=\"8\" label=\"IEEE 754-2008 binary64\"/>] */\n    if ((output_byte(encoder_output, context, (value_as_uint64 >> 56) & 0xFF) != 0) ||\n        (output_byte(encoder_output, context, (value_as_uint64 >> 48) & 0xFF) != 0) ||\n        (output_byte(encoder_output, context, (value_as_uint64 >> 40) & 0xFF) != 0) ||\n        (output_byte(encoder_output, context, (value_as_uint64 >> 32) & 0xFF) != 0) ||\n        (output_byte(encoder_output, context, (value_as_uint64 >> 24) & 0xFF) != 0) ||\n        (output_byte(encoder_output, context, (value_as_uint64 >> 16) & 0xFF) != 0) ||\n        (output_byte(encoder_output, context, (value_as_uint64 >> 8) & 0xFF) != 0) ||\n        (output_byte(encoder_output, context, (value_as_uint64) & 0xFF) != 0))\n    {\n        /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */\n        LogError(\"Failure encoding bytes for double\");\n        result = MU_FAILURE;\n    }\n    else\n    {\n        /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */\n        result = 0;\n    }\n\n    return result;\n}\n\nstatic int encode_double(AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context, double value)\n{\n    int result;\n\n    if ((encode_double_constructor(encoder_output, context) != 0) ||\n        (encode_double_value(encoder_output, context, value) != 0))\n    {\n        /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */\n        LogError(\"Failure encoding double value\");\n        result = MU_FAILURE;\n    }\n    else\n    {\n        /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */\n        result = 0;\n    }\n\n    return result;\n}\n\nstatic int encode_timestamp_constructor(AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context)\n{\n    int result;\n\n    /* Codes_SRS_AMQPVALUE_01_295: [<encoding name=\"ms64\" code=\"0x83\" category=\"fixed\" width=\"8\" label=\"64-bit two's-complement integer representing milliseconds since the unix epoch\"/>] */\n    if (output_byte(encoder_output, context, 0x83) != 0)\n    {\n        /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */\n        LogError(\"Failed encoding timestamp constructor\");\n        result = MU_FAILURE;\n    }\n    else\n    {\n        /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */\n        result = 0;\n    }\n\n    return result;\n}\n\nstatic int encode_timestamp_value(AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context, int64_t value)\n{\n    int result;\n\n    /* Codes_SRS_AMQPVALUE_01_295: [<encoding name=\"ms64\" code=\"0x83\" category=\"fixed\" width=\"8\" label=\"64-bit two's-complement integer representing milliseconds since the unix epoch\"/>] */\n    if ((output_byte(encoder_output, context, (value >> 56) & 0xFF) != 0) ||\n        (output_byte(encoder_output, context, (value >> 48) & 0xFF) != 0) ||\n        (output_byte(encoder_output, context, (value >> 40) & 0xFF) != 0) ||\n        (output_byte(encoder_output, context, (value >> 32) & 0xFF) != 0) ||\n        (output_byte(encoder_output, context, (value >> 24) & 0xFF) != 0) ||\n        (output_byte(encoder_output, context, (value >> 16) & 0xFF) != 0) ||\n        (output_byte(encoder_output, context, (value >> 8) & 0xFF) != 0) ||\n        (output_byte(encoder_output, context, value & 0xFF) != 0))\n    {\n        /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */\n        LogError(\"Failed encoding timestamp value\");\n        result = MU_FAILURE;\n    }\n    else\n    {\n        /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */\n        result = 0;\n    }\n\n    return result;\n}\n\nstatic int encode_timestamp(AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context, int64_t value)\n{\n    int result;\n\n    if ((encode_timestamp_constructor(encoder_output, context) != 0) ||\n        (encode_timestamp_value(encoder_output, context, value) != 0))\n    {\n        /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */\n        LogError(\"Failed encoding timestamp\");\n        result = MU_FAILURE;\n    }\n    else\n    {\n        /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */\n        result = 0;\n    }\n\n    return result;\n}\n\nstatic int encode_uuid_constructor(AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context)\n{\n    int result;\n\n    /* Codes_SRS_AMQPVALUE_01_296: [<encoding code=\"0x98\" category=\"fixed\" width=\"16\" label=\"UUID as defined in section 4.1.2 of RFC-4122\"/>] */\n    if (output_byte(encoder_output, context, 0x98) != 0)\n    {\n        /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */\n        LogError(\"Failed encoding uuid constructor\");\n        result = MU_FAILURE;\n    }\n    else\n    {\n        /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */\n        result = 0;\n    }\n\n    return result;\n}\n\nstatic int encode_uuid_value(AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context, uuid uuid)\n{\n    int result;\n\n    /* Codes_SRS_AMQPVALUE_01_296: [<encoding code=\"0x98\" category=\"fixed\" width=\"16\" label=\"UUID as defined in section 4.1.2 of RFC-4122\"/>] */\n    if (output_bytes(encoder_output, context, uuid, 16)  != 0)\n    {\n        /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */\n        LogError(\"Failed encoding uuid value\");\n        result = MU_FAILURE;\n    }\n    else\n    {\n        /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */\n        result = 0;\n    }\n\n    return result;\n}\n\nstatic int encode_uuid(AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context, uuid uuid)\n{\n    int result;\n\n    if ((encode_uuid_constructor(encoder_output, context) != 0) ||\n        (encode_uuid_value(encoder_output, context, uuid) != 0))\n    {\n        /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */\n        LogError(\"Failed encoding uuid\");\n        result = MU_FAILURE;\n    }\n    else\n    {\n        /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */\n        result = 0;\n    }\n\n    return result;\n}\n\nstatic int encode_binary_constructor(AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context, bool use_smallest)\n{\n    int result;\n    if (use_smallest)\n    {\n        /* Codes_SRS_AMQPVALUE_01_297: [<encoding name=\"vbin8\" code=\"0xa0\" category=\"variable\" width=\"1\" label=\"up to 2^8 - 1 octets of binary data\"/>] */\n        if (output_byte(encoder_output, context, 0xA0) != 0)\n        {\n            /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */\n            LogError(\"Failed encoding small binary constructor\");\n            result = MU_FAILURE;\n        }\n        else\n        {\n            /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */\n            result = 0;\n        }\n    }\n    else\n    {\n        /* Codes_SRS_AMQPVALUE_01_298: [<encoding name=\"vbin32\" code=\"0xb0\" category=\"variable\" width=\"4\" label=\"up to 2^32 - 1 octets of binary data\"/>] */\n        if (output_byte(encoder_output, context, 0xB0) != 0)\n        {\n            /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */\n            LogError(\"Failed encoding large binary constructor\");\n            result = MU_FAILURE;\n        }\n        else\n        {\n            /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */\n            result = 0;\n        }\n    }\n\n    return result;\n}\n\nstatic int encode_binary_value(AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context, const unsigned char* value, uint32_t length, bool use_smallest)\n{\n    int result;\n    if (use_smallest)\n    {\n        /* Codes_SRS_AMQPVALUE_01_297: [<encoding name=\"vbin8\" code=\"0xa0\" category=\"variable\" width=\"1\" label=\"up to 2^8 - 1 octets of binary data\"/>] */\n        if ((output_byte(encoder_output, context, (unsigned char)length) != 0) ||\n            ((length > 0) && (output_bytes(encoder_output, context, value, length) != 0)))\n        {\n            /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */\n            LogError(\"Failed encoding small binary value\");\n            result = MU_FAILURE;\n        }\n        else\n        {\n            /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */\n            result = 0;\n        }\n    }\n    else\n    {\n        /* Codes_SRS_AMQPVALUE_01_298: [<encoding name=\"vbin32\" code=\"0xb0\" category=\"variable\" width=\"4\" label=\"up to 2^32 - 1 octets of binary data\"/>] */\n        if ((output_byte(encoder_output, context, (length >> 24) & 0xFF) != 0) ||\n            (output_byte(encoder_output, context, (length >> 16) & 0xFF) != 0) ||\n            (output_byte(encoder_output, context, (length >> 8) & 0xFF) != 0) ||\n            (output_byte(encoder_output, context, length & 0xFF) != 0) ||\n            (output_bytes(encoder_output, context, value, length) != 0))\n        {\n            /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */\n            LogError(\"Failed encoding large binary value\");\n            result = MU_FAILURE;\n        }\n        else\n        {\n            /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */\n            result = 0;\n        }\n    }\n\n    return result;\n}\n\nstatic int encode_binary(AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context, const unsigned char* value, uint32_t length)\n{\n    int result;\n    bool use_smallest = (length <= 255);\n\n    if ((encode_binary_constructor(encoder_output, context, use_smallest) != 0) ||\n        (encode_binary_value(encoder_output, context, value, length, use_smallest) != 0))\n    {\n        /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */\n        LogError(\"Failed encoding binary\");\n        result = MU_FAILURE;\n    }\n    else\n    {\n        /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */\n        result = 0;\n    }\n\n    return result;\n}\n\nstatic int encode_string_constructor(AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context, bool use_smallest)\n{\n    int result;\n\n    if (use_smallest)\n    {\n        /* Codes_SRS_AMQPVALUE_01_299: [<encoding name=\"str8-utf8\" code=\"0xa1\" category=\"variable\" width=\"1\" label=\"up to 2^8 - 1 octets worth of UTF-8 Unicode (with no byte order mark)\"/>] */\n        if (output_byte(encoder_output, context, (unsigned char)0xA1) != 0)\n        {\n            /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */\n            LogError(\"Failed encoding small string constructor\");\n            result = MU_FAILURE;\n        }\n        else\n        {\n            /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */\n            result = 0;\n        }\n    }\n    else\n    {\n        /* Codes_SRS_AMQPVALUE_01_300: [<encoding name=\"str32-utf8\" code=\"0xb1\" category=\"variable\" width=\"4\" label=\"up to 2^32 - 1 octets worth of UTF-8 Unicode (with no byte order mark)\"/>] */\n        if (output_byte(encoder_output, context, 0xB1) != 0)\n        {\n            /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */\n            LogError(\"Failed encoding large string constructor\");\n            result = MU_FAILURE;\n        }\n        else\n        {\n            /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */\n            result = 0;\n        }\n    }\n\n    return result;\n}\n\nstatic int encode_string_value(AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context, const char* value, size_t length, bool use_smallest)\n{\n    int result;\n\n    if (use_smallest)\n    {\n        /* Codes_SRS_AMQPVALUE_01_299: [<encoding name=\"str8-utf8\" code=\"0xa1\" category=\"variable\" width=\"1\" label=\"up to 2^8 - 1 octets worth of UTF-8 Unicode (with no byte order mark)\"/>] */\n        if ((output_byte(encoder_output, context, (unsigned char)length) != 0) ||\n            (output_bytes(encoder_output, context, value, length) != 0))\n        {\n            /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */\n            LogError(\"Failed encoding small string value\");\n            result = MU_FAILURE;\n        }\n        else\n        {\n            /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */\n            result = 0;\n        }\n    }\n    else\n    {\n        /* Codes_SRS_AMQPVALUE_01_300: [<encoding name=\"str32-utf8\" code=\"0xb1\" category=\"variable\" width=\"4\" label=\"up to 2^32 - 1 octets worth of UTF-8 Unicode (with no byte order mark)\"/>] */\n        if ((output_byte(encoder_output, context, (length >> 24) & 0xFF) != 0) ||\n            (output_byte(encoder_output, context, (length >> 16) & 0xFF) != 0) ||\n            (output_byte(encoder_output, context, (length >> 8) & 0xFF) != 0) ||\n            (output_byte(encoder_output, context, length & 0xFF) != 0) ||\n            (output_bytes(encoder_output, context, value, length) != 0))\n        {\n            /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */\n            LogError(\"Failed encoding large string value\");\n            result = MU_FAILURE;\n        }\n        else\n        {\n            /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */\n            result = 0;\n        }\n    }\n\n    return result;\n\n}\n\nstatic int encode_string(AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context, const char* value)\n{\n    int result;\n    size_t length = strlen(value);\n    bool use_smallest = (length <= 255);\n\n    if ((encode_string_constructor(encoder_output, context, use_smallest) != 0) ||\n        (encode_string_value(encoder_output, context, value, length, use_smallest) != 0))\n    {\n        /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */\n        LogError(\"Failed encoding string\");\n        result = MU_FAILURE;\n    }\n    else\n    {\n        /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */\n        result = 0;\n    }\n\n    return result;\n}\n\nstatic int encode_symbol_constructor(AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context, bool use_smallest)\n{\n    int result;\n\n    if (use_smallest)\n    {\n        /* Codes_SRS_AMQPVALUE_01_301: [<encoding name=\"sym8\" code=\"0xa3\" category=\"variable\" width=\"1\" label=\"up to 2^8 - 1 seven bit ASCII characters representing a symbolic value\"/>] */\n        if (output_byte(encoder_output, context, (unsigned char)0xA3) != 0)\n        {\n            /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */\n            LogError(\"Failed encoding small symbol constructor\");\n            result = MU_FAILURE;\n        }\n        else\n        {\n            /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */\n            result = 0;\n        }\n    }\n    else\n    {\n        /* Codes_SRS_AMQPVALUE_01_302: [<encoding name=\"sym32\" code=\"0xb3\" category=\"variable\" width=\"4\" label=\"up to 2^32 - 1 seven bit ASCII characters representing a symbolic value\"/>] */\n        if (output_byte(encoder_output, context, 0xB3) != 0)\n        {\n            /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */\n            LogError(\"Failed encoding large symbol constructor\");\n            result = MU_FAILURE;\n        }\n        else\n        {\n            /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */\n            result = 0;\n        }\n    }\n\n    return result;\n}\n\nstatic int encode_symbol_value(AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context, const char* value, size_t length, bool use_smallest)\n{\n    int result;\n\n    if (use_smallest)\n    {\n        /* Codes_SRS_AMQPVALUE_01_301: [<encoding name=\"sym8\" code=\"0xa3\" category=\"variable\" width=\"1\" label=\"up to 2^8 - 1 seven bit ASCII characters representing a symbolic value\"/>] */\n        if ((output_byte(encoder_output, context, (unsigned char)length) != 0) ||\n            (output_bytes(encoder_output, context, value, length) != 0))\n        {\n            /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */\n            LogError(\"Failed encoding small symbol value\");\n            result = MU_FAILURE;\n        }\n        else\n        {\n            /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */\n            result = 0;\n        }\n    }\n    else\n    {\n        /* Codes_SRS_AMQPVALUE_01_302: [<encoding name=\"sym32\" code=\"0xb3\" category=\"variable\" width=\"4\" label=\"up to 2^32 - 1 seven bit ASCII characters representing a symbolic value\"/>] */\n        if ((output_byte(encoder_output, context, (length >> 24) & 0xFF) != 0) ||\n            (output_byte(encoder_output, context, (length >> 16) & 0xFF) != 0) ||\n            (output_byte(encoder_output, context, (length >> 8) & 0xFF) != 0) ||\n            (output_byte(encoder_output, context, length & 0xFF) != 0) ||\n            /* Codes_SRS_AMQPVALUE_01_122: [Symbols are encoded as ASCII characters [ASCII].] */\n            (output_bytes(encoder_output, context, value, length) != 0))\n        {\n            /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */\n            LogError(\"Failed encoding large symbol value\");\n            result = MU_FAILURE;\n        }\n        else\n        {\n            /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */\n            result = 0;\n        }\n    }\n\n    return result;\n}\n\nstatic int encode_symbol(AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context, const char* value)\n{\n    int result;\n    size_t length = strlen(value);\n    bool use_smallest = (length <= 255);\n\n    if ((encode_symbol_constructor(encoder_output, context, use_smallest) != 0) ||\n        (encode_symbol_value(encoder_output, context, value, length, use_smallest) != 0))\n    {\n        /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */\n        LogError(\"Failed encoding symbol\");\n        result = MU_FAILURE;\n    }\n    else\n    {\n        /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */\n        result = 0;\n    }\n\n    return result;\n}\n\nstatic int encode_list_constructor(AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context, bool use_smallest)\n{\n    int result;\n\n    if (use_smallest)\n    {\n        /* Codes_SRS_AMQPVALUE_01_304: [<encoding name=\"list8\" code=\"0xc0\" category=\"compound\" width=\"1\" label=\"up to 2^8 - 1 list elements with total size less than 2^8 octets\"/>] */\n        if (output_byte(encoder_output, context, 0xC0) != 0)\n        {\n            /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */\n            LogError(\"Failed encoding list constructor\");\n            result = MU_FAILURE;\n        }\n        else\n        {\n            /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */\n            result = 0;\n        }\n    }\n    else\n    {\n        /* Codes_SRS_AMQPVALUE_01_305: [<encoding name=\"list32\" code=\"0xd0\" category=\"compound\" width=\"4\" label=\"up to 2^32 - 1 list elements with total size less than 2^32 octets\"/>] */\n        if (output_byte(encoder_output, context, 0xD0) != 0)\n        {\n            /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */\n            LogError(\"Failed encoding large list constructor\");\n            result = MU_FAILURE;\n        }\n        else\n        {\n            /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */\n            result = 0;\n        }\n    }\n\n    return result;\n}\n\nstatic int amqpvalue_get_encoded_list_size(AMQP_VALUE* items, uint32_t count, uint32_t* encoded_size)\n{\n    int result;\n    size_t i;\n\n    if (encoded_size == NULL)\n    {\n        LogError(\"Bad arguments: encoded_size = %p\", encoded_size);\n        result = MU_FAILURE;\n    }\n    else\n    {\n        *encoded_size = 0;\n\n        /* Get the size of all items in the list */\n        for (i = 0; i < count; i++)\n        {\n            size_t item_size;\n            if (amqpvalue_get_encoded_size(items[i], &item_size) != 0)\n            {\n                LogError(\"Could not get encoded size for element %u of the list\", (unsigned int)i);\n                break;\n            }\n\n            if ((item_size > UINT32_MAX) ||\n                *encoded_size + (uint32_t)item_size < *encoded_size)\n            {\n                LogError(\"Overflow in list size computation\");\n                break;\n            }\n\n            *encoded_size = (uint32_t)(*encoded_size + item_size);\n        }\n\n        if (i < count)\n        {\n            result = MU_FAILURE;\n        }\n        else\n        {\n            result = 0;\n        }\n    }\n    return result;\n}\n\nstatic int encode_list_value(AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context, uint32_t count, uint32_t size, AMQP_VALUE* items, bool use_smallest)\n{\n    int result;\n    size_t i;\n\n    if (use_smallest)\n    {\n        size++;\n\n        /* Codes_SRS_AMQPVALUE_01_304: [<encoding name=\"list8\" code=\"0xc0\" category=\"compound\" width=\"1\" label=\"up to 2^8 - 1 list elements with total size less than 2^8 octets\"/>] */\n        if ((output_byte(encoder_output, context, (size & 0xFF)) != 0) ||\n            (output_byte(encoder_output, context, (count & 0xFF)) != 0))\n        {\n            /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */\n            LogError(\"Failed encoding list value\");\n            result = MU_FAILURE;\n        }\n        else\n        {\n            /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */\n            result = 0;\n        }\n    }\n    else\n    {\n        size += 4;\n\n        /* Codes_SRS_AMQPVALUE_01_305: [<encoding name=\"list32\" code=\"0xd0\" category=\"compound\" width=\"4\" label=\"up to 2^32 - 1 list elements with total size less than 2^32 octets\"/>] */\n        if ((output_byte(encoder_output, context, (size >> 24) & 0xFF) != 0) ||\n            (output_byte(encoder_output, context, (size >> 16) & 0xFF) != 0) ||\n            (output_byte(encoder_output, context, (size >> 8) & 0xFF) != 0) ||\n            (output_byte(encoder_output, context, size & 0xFF) != 0) ||\n            (output_byte(encoder_output, context, (count >> 24) & 0xFF) != 0) ||\n            (output_byte(encoder_output, context, (count >> 16) & 0xFF) != 0) ||\n            (output_byte(encoder_output, context, (count >> 8) & 0xFF) != 0) ||\n            (output_byte(encoder_output, context, count & 0xFF) != 0))\n        {\n            /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */\n            LogError(\"Failed encoding large list value\");\n            result = MU_FAILURE;\n        }\n        else\n        {\n            /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */\n            result = 0;\n        }\n    }\n\n    if (result == 0)\n    {\n        for (i = 0; i < count; i++)\n        {\n            if (amqpvalue_encode(items[i], encoder_output, context) != 0)\n            {\n                break;\n            }\n        }\n\n        if (i < count)\n        {\n            LogError(\"Failed encoding element %u of the list\", (unsigned int)i);\n            result = MU_FAILURE;\n        }\n        else\n        {\n            result = 0;\n        }\n    }\n    return result;\n}\n\nstatic int encode_list(AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context, uint32_t count, AMQP_VALUE* items)\n{\n    int result;\n\n    if (count == 0)\n    {\n        /* Codes_SRS_AMQPVALUE_01_303: [<encoding name=\"list0\" code=\"0x45\" category=\"fixed\" width=\"0\" label=\"the empty list (i.e. the list with no elements)\"/>] */\n        if (output_byte(encoder_output, context, 0x45) != 0)\n        {\n            /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */\n            LogError(\"Could not output list constructor byte\");\n            result = MU_FAILURE;\n        }\n        else\n        {\n            /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */\n            result = 0;\n        }\n    }\n    else\n    {\n        uint32_t size;\n\n        if (amqpvalue_get_encoded_list_size(items, count, &size) != 0)\n        {\n            /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */\n            result = MU_FAILURE;\n        }\n        else\n        {\n            if ((count <= 255) && (size < 255))\n            {\n                /* Codes_SRS_AMQPVALUE_01_304: [<encoding name=\"list8\" code=\"0xc0\" category=\"compound\" width=\"1\" label=\"up to 2^8 - 1 list elements with total size less than 2^8 octets\"/>] */\n                if ((encode_list_constructor(encoder_output, context, true) != 0) ||\n                    (encode_list_value(encoder_output, context, count, size, items, true) != 0))\n                {\n                    /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */\n                    LogError(\"Failed encoding small list\");\n                    result = MU_FAILURE;\n                }\n                else\n                {\n                    /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */\n                    result = 0;\n                }\n            }\n            else\n            {\n                /* Codes_SRS_AMQPVALUE_01_305: [<encoding name=\"list32\" code=\"0xd0\" category=\"compound\" width=\"4\" label=\"up to 2^32 - 1 list elements with total size less than 2^32 octets\"/>] */\n                if ((encode_list_constructor(encoder_output, context, false) != 0) ||\n                    (encode_list_value(encoder_output, context, count, size, items, false) != 0))\n                {\n                    /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */\n                    LogError(\"Failed encoding large list\");\n                    result = MU_FAILURE;\n                }\n                else\n                {\n                    /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */\n                    result = 0;\n                }\n            }\n        }\n    }\n\n    return result;\n}\n\nstatic int encode_map_constructor(AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context, bool use_smallest)\n{\n    int result;\n\n    if (use_smallest)\n    {\n        /* Codes_SRS_AMQPVALUE_01_306: [<encoding name=\"map8\" code=\"0xc1\" category=\"compound\" width=\"1\" label=\"up to 2^8 - 1 octets of encoded map data\"/>] */\n        if (output_byte(encoder_output, context, 0xC1) != 0)\n        {\n            /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */\n            LogError(\"Could not encode small map constructor\");\n            result = MU_FAILURE;\n        }\n        else\n        {\n            /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */\n            result = 0;\n        }\n    }\n    else\n    {\n        /* Codes_SRS_AMQPVALUE_01_307: [<encoding name=\"map32\" code=\"0xd1\" category=\"compound\" width=\"4\" label=\"up to 2^32 - 1 octets of encoded map data\"/>] */\n        if (output_byte(encoder_output, context, 0xD1) != 0)\n        {\n            /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */\n            LogError(\"Could not encode large map constructor\");\n            result = MU_FAILURE;\n        }\n        else\n        {\n            /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */\n            result = 0;\n        }\n    }\n\n    return result;\n}\n\nstatic int amqpvalue_get_encoded_map_size(AMQP_MAP_KEY_VALUE_PAIR* pairs, uint32_t count, uint32_t* encoded_size)\n{\n    size_t i;\n    int result;\n\n    if (encoded_size == NULL)\n    {\n        LogError(\"Bad arguments: encoded_size = %p\", encoded_size);\n        result = MU_FAILURE;\n    }\n    else\n    {\n        *encoded_size = 0;\n\n        /* Get the size of all items in the map */\n        for (i = 0; i < count; i++)\n        {\n            size_t item_size;\n            if (amqpvalue_get_encoded_size(pairs[i].key, &item_size) != 0)\n            {\n                LogError(\"Could not get encoded size for key element %u of the map\", (unsigned int)i);\n                break;\n            }\n\n            if ((item_size > UINT32_MAX) ||\n                *encoded_size + (uint32_t)item_size < *encoded_size)\n            {\n                LogError(\"Encoded data is more than the max size for a map\");\n                break;\n            }\n\n            *encoded_size = (uint32_t)(*encoded_size + item_size);\n\n            if (amqpvalue_get_encoded_size(pairs[i].value, &item_size) != 0)\n            {\n                LogError(\"Could not get encoded size for value element %u of the map\", (unsigned int)i);\n                break;\n            }\n\n            if ((item_size > UINT32_MAX) ||\n                *encoded_size + (uint32_t)item_size < *encoded_size)\n            {\n                LogError(\"Encoded data is more than the max size for a map\");\n                break;\n            }\n\n            *encoded_size = (uint32_t)(*encoded_size + item_size);\n        }\n\n        if (i < count)\n        {\n            result = MU_FAILURE;\n        }\n        else\n        {\n            result = 0;\n        }\n    }\n    return result;\n}\n\nstatic int encode_map_value(AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context, uint32_t count, uint32_t size, AMQP_MAP_KEY_VALUE_PAIR* pairs, bool use_smallest)\n{\n    int result;\n    size_t i;\n\n    /* Codes_SRS_AMQPVALUE_01_124: [Map encodings MUST contain an even number of items (i.e. an equal number of keys and values).] */\n    uint32_t elements = count * 2;\n\n    if (use_smallest)\n    {\n        size++;\n\n        /* Codes_SRS_AMQPVALUE_01_306: [<encoding name=\"map8\" code=\"0xc1\" category=\"compound\" width=\"1\" label=\"up to 2^8 - 1 octets of encoded map data\"/>] */\n        if ((output_byte(encoder_output, context, (size & 0xFF)) != 0) ||\n            (output_byte(encoder_output, context, (elements & 0xFF)) != 0))\n        {\n            /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */\n            LogError(\"Could not encode small map header\");\n            result = MU_FAILURE;\n        }\n        else\n        {\n            /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */\n            result = 0;\n        }\n    }\n    else\n    {\n        size += 4;\n\n        /* Codes_SRS_AMQPVALUE_01_307: [<encoding name=\"map32\" code=\"0xd1\" category=\"compound\" width=\"4\" label=\"up to 2^32 - 1 octets of encoded map data\"/>] */\n        if ((output_byte(encoder_output, context, (size >> 24) & 0xFF) != 0) ||\n            (output_byte(encoder_output, context, (size >> 16) & 0xFF) != 0) ||\n            (output_byte(encoder_output, context, (size >> 8) & 0xFF) != 0) ||\n            (output_byte(encoder_output, context, size & 0xFF) != 0) ||\n            (output_byte(encoder_output, context, (elements >> 24) & 0xFF) != 0) ||\n            (output_byte(encoder_output, context, (elements >> 16) & 0xFF) != 0) ||\n            (output_byte(encoder_output, context, (elements >> 8) & 0xFF) != 0) ||\n            (output_byte(encoder_output, context, elements & 0xFF) != 0))\n        {\n            /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */\n            LogError(\"Could not encode large map header\");\n            result = MU_FAILURE;\n        }\n        else\n        {\n            /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */\n            result = 0;\n        }\n    }\n\n    if (result == 0)\n    {\n        /* Codes_SRS_AMQPVALUE_01_123: [A map is encoded as a compound value where the constituent elements form alternating key value pairs.] */\n        for (i = 0; i < count; i++)\n        {\n            if ((amqpvalue_encode(pairs[i].key, encoder_output, context) != 0) ||\n                (amqpvalue_encode(pairs[i].value, encoder_output, context) != 0))\n            {\n                LogError(\"Failed encoding map element %u\", (unsigned int)i);\n                break;\n            }\n        }\n\n        if (i < count)\n        {\n            LogError(\"Could not encode map\");\n            result = MU_FAILURE;\n        }\n        else\n        {\n            result = 0;\n        }\n    }\n    return result;\n}\n\nstatic int encode_map(AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context, uint32_t count, AMQP_MAP_KEY_VALUE_PAIR* pairs)\n{\n    int result;\n    uint32_t size;\n\n    /* Codes_SRS_AMQPVALUE_01_124: [Map encodings MUST contain an even number of items (i.e. an equal number of keys and values).] */\n    uint32_t elements = count * 2;\n\n    if (amqpvalue_get_encoded_map_size(pairs, count, &size) != 0)\n    {\n        /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */\n        result = MU_FAILURE;\n    }\n    else\n    {\n        if ((elements <= 255) && (size < 255))\n        {\n            /* Codes_SRS_AMQPVALUE_01_306: [<encoding name=\"map8\" code=\"0xc1\" category=\"compound\" width=\"1\" label=\"up to 2^8 - 1 octets of encoded map data\"/>] */\n            if ((encode_map_constructor(encoder_output, context, true) != 0) ||\n                (encode_map_value(encoder_output, context, count, size, pairs, true) != 0))\n            {\n                /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */\n                LogError(\"Could not encode small map\");\n                result = MU_FAILURE;\n            }\n            else\n            {\n                /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */\n                result = 0;\n            }\n        }\n        else\n        {\n            /* Codes_SRS_AMQPVALUE_01_307: [<encoding name=\"map32\" code=\"0xd1\" category=\"compound\" width=\"4\" label=\"up to 2^32 - 1 octets of encoded map data\"/>] */\n            if ((encode_map_constructor(encoder_output, context, false) != 0) ||\n                (encode_map_value(encoder_output, context, count, size, pairs, false) != 0))\n            {\n                /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */\n                LogError(\"Could not encode large map\");\n                result = MU_FAILURE;\n            }\n            else\n            {\n                /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */\n                result = 0;\n            }\n        }\n    }\n\n    return result;\n}\n\nstatic int encode_array_constructor(AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context, bool use_smallest)\n{\n    int result;\n\n    if (use_smallest)\n    {\n        /* Codes_SRS_AMQPVALUE_01_306: [<encoding name=\"map8\" code=\"0xE0\" category=\"compound\" width=\"1\" label=\"up to 2^8 - 1 octets of encoded map data\"/>] */\n        if (output_byte(encoder_output, context, 0xE0) != 0)\n        {\n            /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */\n            LogError(\"Could not encode small array constructor\");\n            result = MU_FAILURE;\n        }\n        else\n        {\n            /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */\n            result = 0;\n        }\n    }\n    else\n    {\n        /* Codes_SRS_AMQPVALUE_01_307: [<encoding name=\"map32\" code=\"0xF0\" category=\"compound\" width=\"4\" label=\"up to 2^32 - 1 octets of encoded map data\"/>] */\n        if (output_byte(encoder_output, context, 0xF0) != 0)\n        {\n            /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */\n            LogError(\"Could not encode large array constructor\");\n            result = MU_FAILURE;\n        }\n        else\n        {\n            /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */\n            result = 0;\n        }\n    }\n\n    return result;\n}\n\nstatic int amqpvalue_get_encoded_array_size(AMQP_VALUE* items, uint32_t count, uint32_t* encoded_size)\n{\n    size_t i;\n    int result;\n\n    if (encoded_size == NULL)\n    {\n        LogError(\"Bad arguments: encoded_size = %p\", encoded_size);\n        result = MU_FAILURE;\n    }\n    else\n    {\n        *encoded_size = 0;\n\n        /* Get the size of all items in the array */\n        for (i = 0; i < count; i++)\n        {\n            size_t item_size;\n            if (amqpvalue_get_encoded_array_item_size(items[i], &item_size) != 0)\n            {\n                LogError(\"Could not get encoded size for element %u of the array\", (unsigned int)i);\n                break;\n            }\n\n            if ((item_size > UINT32_MAX) ||\n                *encoded_size + (uint32_t)item_size < *encoded_size)\n            {\n                LogError(\"Overflow in array size computation\");\n                break;\n            }\n\n            *encoded_size = (uint32_t)(*encoded_size + item_size);\n        }\n\n        if (i < count)\n        {\n            result = MU_FAILURE;\n        }\n        else\n        {\n            if (*encoded_size > count)\n            {\n                /* Include a single constructor byte in the size calculation where array items require a constructor. */\n                (*encoded_size)++;\n            }\n            result = 0;\n        }\n    }\n    return result;\n}\n\nstatic int encode_array_value(AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context, uint32_t count, uint32_t size, AMQP_VALUE* items, bool use_smallest)\n{\n    int result;\n    size_t i;\n\n    if (use_smallest)\n    {\n        size++;\n\n        /* Codes_SRS_AMQPVALUE_01_306: [<encoding name=\"map8\" code=\"0xE0\" category=\"compound\" width=\"1\" label=\"up to 2^8 - 1 octets of encoded map data\"/>] */\n        if ((output_byte(encoder_output, context, (size & 0xFF)) != 0) ||\n            (output_byte(encoder_output, context, (count & 0xFF)) != 0))\n        {\n            /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */\n            LogError(\"Could not encode small array header\");\n            result = MU_FAILURE;\n        }\n        else\n        {\n            /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */\n            result = 0;\n        }\n    }\n    else\n    {\n        size += 4;\n\n        /* Codes_SRS_AMQPVALUE_01_307: [<encoding name=\"map32\" code=\"0xF0\" category=\"compound\" width=\"4\" label=\"up to 2^32 - 1 octets of encoded map data\"/>] */\n        if ((output_byte(encoder_output, context, (size >> 24) & 0xFF) != 0) ||\n            (output_byte(encoder_output, context, (size >> 16) & 0xFF) != 0) ||\n            (output_byte(encoder_output, context, (size >> 8) & 0xFF) != 0) ||\n            (output_byte(encoder_output, context, size & 0xFF) != 0) ||\n            (output_byte(encoder_output, context, (count >> 24) & 0xFF) != 0) ||\n            (output_byte(encoder_output, context, (count >> 16) & 0xFF) != 0) ||\n            (output_byte(encoder_output, context, (count >> 8) & 0xFF) != 0) ||\n            (output_byte(encoder_output, context, count & 0xFF) != 0))\n        {\n            /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */\n            LogError(\"Could not encode large array header\");\n            result = MU_FAILURE;\n        }\n        else\n        {\n            /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */\n            result = 0;\n        }\n    }\n\n    if (result == 0)\n    {\n        bool first_element = true;\n\n        for (i = 0; i < count; i++)\n        {\n            if (amqpvalue_encode_array_item(items[i], first_element, encoder_output, context) != 0)\n            {\n                LogError(\"Failed encoding element %u of the array\", (unsigned int)i);\n                break;\n            }\n            first_element = false;\n        }\n\n        if (i < count)\n        {\n            LogError(\"Could not encode array\");\n            result = MU_FAILURE;\n        }\n        else\n        {\n            result = 0;\n        }\n    }\n    return result;\n}\n\nstatic int encode_array(AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context, uint32_t count, AMQP_VALUE* items)\n{\n    int result;\n    uint32_t size;\n\n    if (amqpvalue_get_encoded_array_size(items, count, &size) != 0)\n    {\n        /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */\n        result = MU_FAILURE;\n    }\n    else\n    {\n        if ((count <= 255) && (size < 255))\n        {\n            /* Codes_SRS_AMQPVALUE_01_306: [<encoding name=\"map8\" code=\"0xE0\" category=\"compound\" width=\"1\" label=\"up to 2^8 - 1 octets of encoded map data\"/>] */\n            if ((encode_array_constructor(encoder_output, context, true) != 0) ||\n                (encode_array_value(encoder_output,context, count, size, items, true) != 0))\n            {\n                /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */\n                LogError(\"Could not encode small array\");\n                result = MU_FAILURE;\n            }\n            else\n            {\n                /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */\n                result = 0;\n            }\n        }\n        else\n        {\n            /* Codes_SRS_AMQPVALUE_01_307: [<encoding name=\"map32\" code=\"0xF0\" category=\"compound\" width=\"4\" label=\"up to 2^32 - 1 octets of encoded map data\"/>] */\n            if ((encode_array_constructor(encoder_output, context, false) != 0) ||\n                (encode_array_value(encoder_output, context, count, size, items, false) != 0))\n            {\n                /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */\n                LogError(\"Could not encode large array\");\n                result = MU_FAILURE;\n            }\n            else\n            {\n                /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */\n                result = 0;\n            }\n        }\n    }\n\n    return result;\n}\n\nstatic int encode_descriptor_header(AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context)\n{\n    int result;\n\n    if (output_byte(encoder_output, context, 0x00) != 0)\n    {\n        LogError(\"Failed encoding descriptor header\");\n        result = MU_FAILURE;\n    }\n    else\n    {\n        result = 0;\n    }\n\n    return result;\n}\n\n/* Codes_SRS_AMQPVALUE_01_265: [amqpvalue_encode shall encode the value per the ISO.] */\nint amqpvalue_encode(AMQP_VALUE value, AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context)\n{\n    int result;\n\n    /* Codes_SRS_AMQPVALUE_01_269: [If value or encoder_output are NULL, amqpvalue_encode shall fail and return a non-zero value.] */\n    if ((value == NULL) ||\n        (encoder_output == NULL))\n    {\n        LogError(\"Bad arguments: value = %p, encoder_output = %p\",\n            value, encoder_output);\n        result = MU_FAILURE;\n    }\n    else\n    {\n        AMQP_VALUE_DATA* value_data = (AMQP_VALUE_DATA*)value;\n\n        switch (value_data->type)\n        {\n        default:\n            /* Codes_SRS_AMQPVALUE_01_271: [If encoding fails due to any error not specifically mentioned here, it shall return a non-zero value.] */\n            LogError(\"Invalid type: %d\", (int)value_data->type);\n            result = MU_FAILURE;\n            break;\n\n        case AMQP_TYPE_NULL:\n            /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */\n            result = encode_null(encoder_output, context);\n            break;\n\n        case AMQP_TYPE_BOOL:\n            result = encode_boolean(encoder_output, context, value_data->value.bool_value);\n            break;\n\n        case AMQP_TYPE_UBYTE:\n            result = encode_ubyte(encoder_output, context, value_data->value.ubyte_value);\n            break;\n\n        case AMQP_TYPE_USHORT:\n            result = encode_ushort(encoder_output, context, value_data->value.ushort_value);\n            break;\n\n        case AMQP_TYPE_UINT:\n            result = encode_uint(encoder_output, context, value_data->value.uint_value);\n            break;\n\n        case AMQP_TYPE_ULONG:\n            result = encode_ulong(encoder_output, context, value_data->value.ulong_value);\n            break;\n\n        case AMQP_TYPE_BYTE:\n            result = encode_byte(encoder_output, context, value_data->value.byte_value);\n            break;\n\n        case AMQP_TYPE_SHORT:\n            result = encode_short(encoder_output, context, value_data->value.short_value);\n            break;\n\n        case AMQP_TYPE_INT:\n            result = encode_int(encoder_output, context, value_data->value.int_value);\n            break;\n\n        case AMQP_TYPE_LONG:\n            result = encode_long(encoder_output, context, value_data->value.long_value);\n            break;\n\n        case AMQP_TYPE_FLOAT:\n            result = encode_float(encoder_output, context, value_data->value.float_value);\n            break;\n\n        case AMQP_TYPE_DOUBLE:\n            result = encode_double(encoder_output, context, value_data->value.double_value);\n            break;\n\n        case AMQP_TYPE_TIMESTAMP:\n            result = encode_timestamp(encoder_output, context, value_data->value.timestamp_value);\n            break;\n\n        case AMQP_TYPE_UUID:\n            result = encode_uuid(encoder_output, context, value_data->value.uuid_value);\n            break;\n\n        case AMQP_TYPE_BINARY:\n            result = encode_binary(encoder_output, context, (const unsigned char*)value_data->value.binary_value.bytes, value_data->value.binary_value.length);\n            break;\n\n        case AMQP_TYPE_STRING:\n            result = encode_string(encoder_output, context, value_data->value.string_value.chars);\n            break;\n\n        case AMQP_TYPE_SYMBOL:\n            result = encode_symbol(encoder_output, context, value_data->value.symbol_value.chars);\n            break;\n\n        case AMQP_TYPE_LIST:\n            result = encode_list(encoder_output, context, value_data->value.list_value.count, value_data->value.list_value.items);\n            break;\n\n        case AMQP_TYPE_ARRAY:\n            result = encode_array(encoder_output, context, value_data->value.array_value.count, value_data->value.array_value.items);\n            break;\n\n        case AMQP_TYPE_MAP:\n            result = encode_map(encoder_output, context, value_data->value.map_value.pair_count, value_data->value.map_value.pairs);\n            break;\n\n        case AMQP_TYPE_COMPOSITE:\n        case AMQP_TYPE_DESCRIBED:\n        {\n            if ((encode_descriptor_header(encoder_output, context) != 0) ||\n                (amqpvalue_encode(value_data->value.described_value.descriptor, encoder_output, context) != 0) ||\n                (amqpvalue_encode(value_data->value.described_value.value, encoder_output, context) != 0))\n            {\n                LogError(\"Failed encoding described or composite type\");\n                result = MU_FAILURE;\n            }\n            else\n            {\n                result = 0;\n            }\n\n            break;\n        }\n        }\n    }\n\n    return result;\n}\n\nstatic int amqpvalue_encode_array_item(AMQP_VALUE item, bool first_element, AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context)\n{\n    int result;\n\n    if ((item == NULL) ||\n        (encoder_output == NULL))\n    {\n        LogError(\"Bad arguments: item = %p, encoder_output = %p\", item, encoder_output);\n        result = MU_FAILURE;\n    }\n    else\n    {\n        AMQP_VALUE_DATA* value_data = (AMQP_VALUE_DATA*)item;\n\n        switch (value_data->type)\n        {\n            default:\n                LogError(\"Unsupported array type: %d\", (int)value_data->type);\n                result = MU_FAILURE;\n                break;\n\n            case AMQP_TYPE_NULL:\n                if ((first_element) && (encode_null_constructor(encoder_output, context) != 0))\n                {\n                    result = MU_FAILURE;\n                    break;\n                }\n                result = encode_null_value(encoder_output, context);\n                break;\n\n            case AMQP_TYPE_BOOL:\n                if ((first_element) && (encode_boolean_constructor(encoder_output, context) != 0))\n                {\n                    result = MU_FAILURE;\n                    break;\n                }\n                result = encode_boolean_value(encoder_output, context, value_data->value.bool_value);\n                break;\n\n            case AMQP_TYPE_UBYTE:\n                if ((first_element) && (encode_ubyte_constructor(encoder_output, context) != 0))\n                {\n                    result = MU_FAILURE;\n                    break;\n                }\n                result = encode_ubyte_value(encoder_output, context, value_data->value.ubyte_value);\n                break;\n\n            case AMQP_TYPE_USHORT:\n                if ((first_element) && (encode_ushort_constructor(encoder_output, context) != 0))\n                {\n                    result = MU_FAILURE;\n                    break;\n                }\n                result = encode_ushort_value(encoder_output, context, value_data->value.ushort_value);\n                break;\n\n            case AMQP_TYPE_UINT:\n                if ((first_element) && (encode_uint_constructor(encoder_output, context, false) != 0))\n                {\n                    result = MU_FAILURE;\n                    break;\n                }\n                result = encode_uint_value(encoder_output, context, value_data->value.uint_value, false);\n                break;\n\n            case AMQP_TYPE_ULONG:\n                if ((first_element) && (encode_ulong_constructor(encoder_output, context, false) != 0))\n                {\n                    result = MU_FAILURE;\n                    break;\n                }\n                result = encode_ulong_value(encoder_output, context, value_data->value.ulong_value, false);\n                break;\n\n            case AMQP_TYPE_BYTE:\n                if ((first_element) && (encode_byte_constructor(encoder_output, context) != 0))\n                {\n                    result = MU_FAILURE;\n                    break;\n                }\n                result = encode_byte_value(encoder_output, context, value_data->value.byte_value);\n                break;\n\n            case AMQP_TYPE_SHORT:\n                if ((first_element) && (encode_short_constructor(encoder_output, context) != 0))\n                {\n                    result = MU_FAILURE;\n                    break;\n                }\n                result = encode_short_value(encoder_output, context, value_data->value.short_value);\n                break;\n\n            case AMQP_TYPE_INT:\n                if ((first_element) && (encode_int_constructor(encoder_output, context, false) != 0))\n                {\n                    result = MU_FAILURE;\n                    break;\n                }\n                result = encode_int_value(encoder_output, context, value_data->value.int_value, false);\n                break;\n\n            case AMQP_TYPE_LONG:\n                if ((first_element) && (encode_long_constructor(encoder_output, context, false) != 0))\n                {\n                    result = MU_FAILURE;\n                    break;\n                }\n                result = encode_long_value(encoder_output, context, value_data->value.long_value, false);\n                break;\n\n            case AMQP_TYPE_FLOAT:\n                if ((first_element) && (encode_float_constructor(encoder_output, context) != 0))\n                {\n                    result = MU_FAILURE;\n                    break;\n                }\n                result = encode_float_value(encoder_output, context, value_data->value.float_value);\n                break;\n\n            case AMQP_TYPE_DOUBLE:\n                if ((first_element) && (encode_double_constructor(encoder_output, context) != 0))\n                {\n                    result = MU_FAILURE;\n                    break;\n                }\n                result = encode_double_value(encoder_output, context, value_data->value.double_value);\n                break;\n\n            case AMQP_TYPE_TIMESTAMP:\n                if ((first_element) && (encode_timestamp_constructor(encoder_output, context) != 0))\n                {\n                    result = MU_FAILURE;\n                    break;\n                }\n                result = encode_timestamp_value(encoder_output, context, value_data->value.timestamp_value);\n                break;\n\n            case AMQP_TYPE_UUID:\n                if ((first_element) && (encode_uuid_constructor(encoder_output, context) != 0))\n                {\n                    result = MU_FAILURE;\n                    break;\n                }\n                result = encode_uuid_value(encoder_output, context, value_data->value.uuid_value);\n                break;\n\n            case AMQP_TYPE_BINARY:\n                if ((first_element) && (encode_binary_constructor(encoder_output, context, false) != 0))\n                {\n                    result = MU_FAILURE;\n                    break;\n                }\n                result = encode_binary_value(encoder_output, context, (const unsigned char*)value_data->value.binary_value.bytes, value_data->value.binary_value.length, false);\n                break;\n\n            case AMQP_TYPE_STRING:\n                if ((first_element) && (encode_string_constructor(encoder_output, context, false) != 0))\n                {\n                    result = MU_FAILURE;\n                    break;\n                }\n                result = encode_string_value(encoder_output, context, value_data->value.string_value.chars, strlen(value_data->value.string_value.chars), false);\n                break;\n\n            case AMQP_TYPE_SYMBOL:\n                if ((first_element) && (encode_symbol_constructor(encoder_output, context, false) != 0))\n                {\n                    result = MU_FAILURE;\n                    break;\n                }\n                result = encode_symbol_value(encoder_output, context, value_data->value.symbol_value.chars, strlen(value_data->value.symbol_value.chars), false);\n                break;\n\n            case AMQP_TYPE_LIST:\n            {\n                uint32_t list_size;\n\n                if ((first_element) && (encode_list_constructor(encoder_output, context, false) != 0))\n                {\n                    result = MU_FAILURE;\n                }\n                else if (amqpvalue_get_encoded_list_size(value_data->value.list_value.items, value_data->value.list_value.count, &list_size) != 0)\n                {\n                    result = MU_FAILURE;\n                }\n                else\n                {\n                    result = encode_list_value(encoder_output, context, value_data->value.list_value.count, list_size, value_data->value.list_value.items, false);\n                }\n                break;\n            }\n\n            case AMQP_TYPE_MAP:\n            {\n                uint32_t map_size;\n\n                if ((first_element) && (encode_map_constructor(encoder_output, context, false) != 0))\n                {\n                    result = MU_FAILURE;\n                }\n                else if (amqpvalue_get_encoded_map_size(value_data->value.map_value.pairs, value_data->value.map_value.pair_count, &map_size) != 0)\n                {\n                    result = MU_FAILURE;\n                }\n                else\n                {\n                    result = encode_map_value(encoder_output, context, value_data->value.map_value.pair_count, map_size, value_data->value.map_value.pairs, false);\n                }\n                break;\n            }\n\n            case AMQP_TYPE_ARRAY:\n            {\n                uint32_t array_size;\n\n                if ((first_element) && (encode_array_constructor(encoder_output, context, false) != 0))\n                {\n                    result = MU_FAILURE;\n                }\n                else if (amqpvalue_get_encoded_array_size(value_data->value.array_value.items, value_data->value.array_value.count, &array_size) != 0)\n                {\n                    result = MU_FAILURE;\n                }\n                else\n                {\n                    result = encode_array_value(encoder_output, context, value_data->value.array_value.count, array_size, value_data->value.array_value.items, false);\n                }\n                break;\n            }\n        }\n    }\n    return result;\n}\n\nstatic int count_bytes(void* context, const unsigned char* bytes, size_t length)\n{\n    size_t* byte_count;\n    (void)bytes;\n\n    byte_count = (size_t*)context;\n    *byte_count += length;\n\n    return 0;\n}\n\n/* Codes_SRS_AMQPVALUE_01_308: [amqpvalue_get_encoded_size shall fill in the encoded_size argument the number of bytes required to encode the given AMQP value.] */\nint amqpvalue_get_encoded_size(AMQP_VALUE value, size_t* encoded_size)\n{\n    int result;\n\n    /* Codes_SRS_AMQPVALUE_01_309: [If any argument is NULL, amqpvalue_get_encoded_size shall return a non-zero value.] */\n    if ((value == NULL) ||\n        (encoded_size == NULL))\n    {\n        LogError(\"Bad arguments: value = %p, encoded_size = %p\",\n            value, encoded_size);\n        result = MU_FAILURE;\n    }\n    else\n    {\n        *encoded_size = 0;\n        result = amqpvalue_encode(value, count_bytes, encoded_size);\n    }\n\n    return result;\n}\n\nstatic int amqpvalue_get_encoded_array_item_size(AMQP_VALUE item, size_t* encoded_size)\n{\n    int result;\n\n    if ((item == NULL) ||\n        (encoded_size == NULL))\n    {\n        LogError(\"Bad arguments: item = %p, encoded_size = %p\", item, encoded_size);\n        result = MU_FAILURE;\n    }\n    else\n    {\n        *encoded_size = 0;\n        result = amqpvalue_encode_array_item(item, false, count_bytes, encoded_size);\n    }\n\n    return result;\n}\n\nstatic void amqpvalue_clear(AMQP_VALUE_DATA* value_data)\n{\n    switch (value_data->type)\n    {\n    default:\n        break;\n\n    case AMQP_TYPE_BINARY:\n        if (value_data->value.binary_value.bytes != NULL)\n        {\n            free((void*)value_data->value.binary_value.bytes);\n        }\n        break;\n    case AMQP_TYPE_STRING:\n        if (value_data->value.string_value.chars != NULL)\n        {\n            free(value_data->value.string_value.chars);\n        }\n        break;\n    case AMQP_TYPE_SYMBOL:\n        if (value_data->value.symbol_value.chars != NULL)\n        {\n            free(value_data->value.symbol_value.chars);\n        }\n        break;\n    case AMQP_TYPE_LIST:\n    {\n        if (value_data->value.list_value.items != NULL)\n        {\n            size_t i;\n            for (i = 0; i < value_data->value.list_value.count; i++)\n            {\n                amqpvalue_destroy(value_data->value.list_value.items[i]);\n            }\n\n            free(value_data->value.list_value.items);\n            value_data->value.list_value.items = NULL;\n        }\n        break;\n    }\n    case AMQP_TYPE_MAP:\n    {\n        if (value_data->value.map_value.pairs != NULL)\n        {\n            size_t i;\n            for (i = 0; i < value_data->value.map_value.pair_count; i++)\n            {\n                amqpvalue_destroy(value_data->value.map_value.pairs[i].key);\n                amqpvalue_destroy(value_data->value.map_value.pairs[i].value);\n            }\n\n            free(value_data->value.map_value.pairs);\n            value_data->value.map_value.pairs = NULL;\n        }\n        break;\n    }\n    case AMQP_TYPE_ARRAY:\n    {\n        if (value_data->value.array_value.items != NULL)\n        {\n            size_t i;\n            for (i = 0; i < value_data->value.array_value.count; i++)\n            {\n                amqpvalue_destroy(value_data->value.array_value.items[i]);\n            }\n\n            free(value_data->value.array_value.items);\n            value_data->value.array_value.items = NULL;\n        }\n        break;\n    }\n    case AMQP_TYPE_COMPOSITE:\n    case AMQP_TYPE_DESCRIBED:\n        amqpvalue_destroy(value_data->value.described_value.descriptor);\n        amqpvalue_destroy(value_data->value.described_value.value);\n        break;\n    }\n\n    value_data->type = AMQP_TYPE_UNKNOWN;\n}\n\nvoid amqpvalue_destroy(AMQP_VALUE value)\n{\n    /* Codes_SRS_AMQPVALUE_01_315: [If the value argument is NULL, amqpvalue_destroy shall do nothing.] */\n    if (value != NULL)\n    {\n        if (DEC_REF(AMQP_VALUE_DATA, value) == DEC_RETURN_ZERO)\n        {\n            /* Codes_SRS_AMQPVALUE_01_314: [amqpvalue_destroy shall free all resources allocated by any of the amqpvalue_create_xxx functions or amqpvalue_clone.] */\n            AMQP_VALUE_DATA* value_data = (AMQP_VALUE_DATA*)value;\n            amqpvalue_clear(value_data);\n            REFCOUNT_TYPE_DESTROY(AMQP_VALUE_DATA, value);\n        }\n    }\n}\n\nstatic INTERNAL_DECODER_DATA* internal_decoder_create(ON_VALUE_DECODED on_value_decoded, void* callback_context, AMQP_VALUE_DATA* value_data, bool is_internal)\n{\n    INTERNAL_DECODER_DATA* internal_decoder_data = (INTERNAL_DECODER_DATA*)calloc(1, sizeof(INTERNAL_DECODER_DATA));\n    if (internal_decoder_data == NULL)\n    {\n        LogError(\"Cannot allocate memory for internal decoder structure\");\n    }\n    else\n    {\n        internal_decoder_data->is_internal = is_internal;\n        internal_decoder_data->on_value_decoded = on_value_decoded;\n        internal_decoder_data->on_value_decoded_context = callback_context;\n        internal_decoder_data->decoder_state = DECODER_STATE_CONSTRUCTOR;\n        internal_decoder_data->inner_decoder = NULL;\n        internal_decoder_data->decode_to_value = value_data;\n    }\n\n    return internal_decoder_data;\n}\n\nstatic void internal_decoder_destroy(INTERNAL_DECODER_DATA* internal_decoder)\n{\n    if (internal_decoder != NULL)\n    {\n        internal_decoder_destroy(internal_decoder->inner_decoder);\n        free(internal_decoder);\n    }\n}\n\nstatic void inner_decoder_callback(void* context, AMQP_VALUE decoded_value)\n{\n    /* API issue: the decoded_value should be removed completely:\n    TODO: uAMQP: inner_decoder_callback in amqpvalue.c could probably do without the decoded_value ... */\n    INTERNAL_DECODER_DATA* internal_decoder_data = (INTERNAL_DECODER_DATA*)context;\n    INTERNAL_DECODER_DATA* inner_decoder = (INTERNAL_DECODER_DATA*)internal_decoder_data->inner_decoder;\n    (void)decoded_value;\n    inner_decoder->decoder_state = DECODER_STATE_DONE;\n}\n\nstatic int internal_decoder_decode_bytes(INTERNAL_DECODER_DATA* internal_decoder_data, const unsigned char* buffer, size_t size, size_t* used_bytes)\n{\n    int result;\n    size_t initial_size = size;\n\n    if (internal_decoder_data == NULL)\n    {\n        /* TODO: investigate if this check is even needed */\n        LogError(\"NULL internal_decoder_data\");\n        result = MU_FAILURE;\n    }\n    else\n    {\n        result = 0;\n        /* Codes_SRS_AMQPVALUE_01_322: [amqpvalue_decode_bytes shall process the bytes byte by byte, as a stream.] */\n        while ((size > 0) && (internal_decoder_data->decoder_state != DECODER_STATE_DONE))\n        {\n            switch (internal_decoder_data->decoder_state)\n            {\n            default:\n                LogError(\"Invalid decoder state: %d\", (int)internal_decoder_data->decoder_state);\n                result = MU_FAILURE;\n                break;\n\n            case DECODER_STATE_CONSTRUCTOR:\n            {\n                if ((internal_decoder_data->decode_to_value != NULL) && (!internal_decoder_data->is_internal))\n                {\n                    amqpvalue_destroy(internal_decoder_data->decode_to_value);\n                    internal_decoder_data->decode_to_value = NULL;\n                }\n\n                if (internal_decoder_data->decode_to_value == NULL)\n                {\n                    internal_decoder_data->decode_to_value = (AMQP_VALUE_DATA*)REFCOUNT_TYPE_CREATE(AMQP_VALUE_DATA);\n                }\n\n                if (internal_decoder_data->decode_to_value == NULL)\n                {\n                    LogError(\"Cannot allocate decode value\");\n                    result = MU_FAILURE;\n                    break;\n                }\n\n                memset(internal_decoder_data->decode_to_value, 0, sizeof(AMQP_VALUE_DATA));\n                internal_decoder_data->constructor_byte = buffer[0];\n                buffer++;\n                size--;\n\n                switch (internal_decoder_data->constructor_byte)\n                {\n                default:\n                    internal_decoder_data->decoder_state = DECODER_STATE_ERROR;\n                    LogError(\"Invalid constructor byte: 0x%02x\", internal_decoder_data->constructor_byte);\n                    result = MU_FAILURE;\n                    break;\n\n                case 0x00: /* descriptor */\n                {\n                    AMQP_VALUE_DATA* descriptor;\n                    internal_decoder_data->decode_to_value->type = AMQP_TYPE_DESCRIBED;\n                    internal_decoder_data->decode_to_value->value.described_value.value = NULL;\n                    descriptor = REFCOUNT_TYPE_CREATE(AMQP_VALUE_DATA);\n                    if (descriptor == NULL)\n                    {\n                        internal_decoder_data->decoder_state = DECODER_STATE_ERROR;\n                        LogError(\"Could not allocate memory for descriptor\");\n                        result = MU_FAILURE;\n                    }\n                    else\n                    {\n                        descriptor->type = AMQP_TYPE_UNKNOWN;\n                        internal_decoder_data->decode_to_value->value.described_value.descriptor = descriptor;\n                        internal_decoder_data->inner_decoder = internal_decoder_create(inner_decoder_callback, internal_decoder_data, descriptor, true);\n                        if (internal_decoder_data->inner_decoder == NULL)\n                        {\n                            internal_decoder_data->decoder_state = DECODER_STATE_ERROR;\n                            LogError(\"Could not create inner decoder for descriptor\");\n                            result = MU_FAILURE;\n                        }\n                        else\n                        {\n                            internal_decoder_data->decoder_state = DECODER_STATE_TYPE_DATA;\n                            internal_decoder_data->decode_value_state.described_value_state.described_value_state = DECODE_DESCRIBED_VALUE_STEP_DESCRIPTOR;\n                            result = 0;\n                        }\n                    }\n\n                    break;\n                }\n\n                /* Codes_SRS_AMQPVALUE_01_329: [<encoding code=\"0x40\" category=\"fixed\" width=\"0\" label=\"the null value\"/>] */\n                case 0x40:\n                {\n                    /* Codes_SRS_AMQPVALUE_01_328: [1.6.1 null Indicates an empty value.] */\n                    internal_decoder_data->decode_to_value->type = AMQP_TYPE_NULL;\n                    internal_decoder_data->decoder_state = DECODER_STATE_CONSTRUCTOR;\n\n                    /* Codes_SRS_AMQPVALUE_01_323: [When enough bytes have been processed for a valid amqp value, the on_value_decoded passed in amqpvalue_decoder_create shall be called.] */\n                    /* Codes_SRS_AMQPVALUE_01_324: [The decoded amqp value shall be passed to on_value_decoded.] */\n                    /* Codes_SRS_AMQPVALUE_01_325: [Also the context stored in amqpvalue_decoder_create shall be passed to the on_value_decoded callback.] */\n                    internal_decoder_data->on_value_decoded(internal_decoder_data->on_value_decoded_context, internal_decoder_data->decode_to_value);\n                    result = 0;\n\n                    break;\n                }\n\n                /* Codes_SRS_AMQPVALUE_01_331: [<encoding code=\"0x56\" category=\"fixed\" width=\"1\" label=\"boolean with the octet 0x00 being false and octet 0x01 being true\"/>] */\n                case 0x56:\n                {\n                    /* Codes_SRS_AMQPVALUE_01_330: [1.6.2 boolean Represents a true or false value.] */\n                    internal_decoder_data->decode_to_value->type = AMQP_TYPE_BOOL;\n                    internal_decoder_data->decoder_state = DECODER_STATE_TYPE_DATA;\n                    internal_decoder_data->bytes_decoded = 0;\n\n                    /* Codes_SRS_AMQPVALUE_01_327: [If not enough bytes have accumulated to decode a value, the on_value_decoded shall not be called.] */\n                    result = 0;\n                    break;\n                }\n                /* Codes_SRS_AMQPVALUE_01_332: [<encoding name=\"true\" code=\"0x41\" category=\"fixed\" width=\"0\" label=\"the boolean value true\"/>] */\n                case 0x41:\n                {\n                    /* Codes_SRS_AMQPVALUE_01_330: [1.6.2 boolean Represents a true or false value.] */\n                    internal_decoder_data->decode_to_value->type = AMQP_TYPE_BOOL;\n                    internal_decoder_data->decode_to_value->value.bool_value = true;\n                    internal_decoder_data->decoder_state = DECODER_STATE_CONSTRUCTOR;\n\n                    /* Codes_SRS_AMQPVALUE_01_323: [When enough bytes have been processed for a valid amqp value, the on_value_decoded passed in amqpvalue_decoder_create shall be called.] */\n                    /* Codes_SRS_AMQPVALUE_01_324: [The decoded amqp value shall be passed to on_value_decoded.] */\n                    /* Codes_SRS_AMQPVALUE_01_325: [Also the context stored in amqpvalue_decoder_create shall be passed to the on_value_decoded callback.] */\n                    internal_decoder_data->on_value_decoded(internal_decoder_data->on_value_decoded_context, internal_decoder_data->decode_to_value);\n                    result = 0;\n                    break;\n                }\n                /* Codes_SRS_AMQPVALUE_01_333: [<encoding name=\"false\" code=\"0x42\" category=\"fixed\" width=\"0\" label=\"the boolean value false\"/>] */\n                case 0x42:\n                {\n                    /* Codes_SRS_AMQPVALUE_01_330: [1.6.2 boolean Represents a true or false value.] */\n                    internal_decoder_data->decode_to_value->type = AMQP_TYPE_BOOL;\n                    internal_decoder_data->decode_to_value->value.bool_value = false;\n                    internal_decoder_data->decoder_state = DECODER_STATE_CONSTRUCTOR;\n\n                    /* Codes_SRS_AMQPVALUE_01_323: [When enough bytes have been processed for a valid amqp value, the on_value_decoded passed in amqpvalue_decoder_create shall be called.] */\n                    /* Codes_SRS_AMQPVALUE_01_324: [The decoded amqp value shall be passed to on_value_decoded.] */\n                    /* Codes_SRS_AMQPVALUE_01_325: [Also the context stored in amqpvalue_decoder_create shall be passed to the on_value_decoded callback.] */\n                    internal_decoder_data->on_value_decoded(internal_decoder_data->on_value_decoded_context, internal_decoder_data->decode_to_value);\n                    result = 0;\n                    break;\n                }\n                /* Codes_SRS_AMQPVALUE_01_335: [<encoding code=\"0x50\" category=\"fixed\" width=\"1\" label=\"8-bit unsigned integer\"/>] */\n                case 0x50:\n                {\n                    /* Codes_SRS_AMQPVALUE_01_334: [1.6.3 ubyte Integer in the range 0 to 28 - 1 inclusive.] */\n                    internal_decoder_data->decode_to_value->type = AMQP_TYPE_UBYTE;\n                    internal_decoder_data->decoder_state = DECODER_STATE_TYPE_DATA;\n                    internal_decoder_data->decode_to_value->value.ubyte_value = 0;\n\n                    /* Codes_SRS_AMQPVALUE_01_327: [If not enough bytes have accumulated to decode a value, the on_value_decoded shall not be called.] */\n                    result = 0;\n                    break;\n                }\n                /* Codes_SRS_AMQPVALUE_01_337: [<encoding code=\"0x60\" category=\"fixed\" width=\"2\" label=\"16-bit unsigned integer in network byte order\"/>] */\n                case 0x60:\n                {\n                    /* Codes_SRS_AMQPVALUE_01_336: [1.6.4 ushort Integer in the range 0 to 216 - 1 inclusive.] */\n                    internal_decoder_data->decode_to_value->type = AMQP_TYPE_USHORT;\n                    internal_decoder_data->decoder_state = DECODER_STATE_TYPE_DATA;\n                    internal_decoder_data->decode_to_value->value.ushort_value = 0;\n                    internal_decoder_data->bytes_decoded = 0;\n\n                    /* Codes_SRS_AMQPVALUE_01_327: [If not enough bytes have accumulated to decode a value, the on_value_decoded shall not be called.] */\n                    result = 0;\n                    break;\n                }\n                /* Codes_SRS_AMQPVALUE_01_339: [<encoding code=\"0x70\" category=\"fixed\" width=\"4\" label=\"32-bit unsigned integer in network byte order\"/>] */\n                case 0x70:\n                /* Codes_SRS_AMQPVALUE_01_340: [<encoding name=\"smalluint\" code=\"0x52\" category=\"fixed\" width=\"1\" label=\"unsigned integer value in the range 0 to 255 inclusive\"/>] */\n                case 0x52:\n                {\n                    internal_decoder_data->decode_to_value->type = AMQP_TYPE_UINT;\n                    internal_decoder_data->decoder_state = DECODER_STATE_TYPE_DATA;\n                    internal_decoder_data->decode_to_value->value.uint_value = 0;\n                    internal_decoder_data->bytes_decoded = 0;\n\n                    /* Codes_SRS_AMQPVALUE_01_327: [If not enough bytes have accumulated to decode a value, the on_value_decoded shall not be called.] */\n                    result = 0;\n                    break;\n                }\n                /* Codes_SRS_AMQPVALUE_01_341: [<encoding name=\"uint0\" code=\"0x43\" category=\"fixed\" width=\"0\" label=\"the uint value 0\"/>] */\n                case 0x43:\n                {\n                    /* Codes_SRS_AMQPVALUE_01_338: [1.6.5 uint Integer in the range 0 to 232 - 1 inclusive.] */\n                    internal_decoder_data->decode_to_value->type = AMQP_TYPE_UINT;\n                    internal_decoder_data->decode_to_value->value.uint_value = 0;\n                    internal_decoder_data->decoder_state = DECODER_STATE_CONSTRUCTOR;\n\n                    /* Codes_SRS_AMQPVALUE_01_323: [When enough bytes have been processed for a valid amqp value, the on_value_decoded passed in amqpvalue_decoder_create shall be called.] */\n                    /* Codes_SRS_AMQPVALUE_01_324: [The decoded amqp value shall be passed to on_value_decoded.] */\n                    /* Codes_SRS_AMQPVALUE_01_325: [Also the context stored in amqpvalue_decoder_create shall be passed to the on_value_decoded callback.] */\n                    internal_decoder_data->on_value_decoded(internal_decoder_data->on_value_decoded_context, internal_decoder_data->decode_to_value);\n                    result = 0;\n                    break;\n                }\n                /* Codes_SRS_AMQPVALUE_01_343: [<encoding code=\"0x80\" category=\"fixed\" width=\"8\" label=\"64-bit unsigned integer in network byte order\"/>] */\n                case 0x80:\n                {\n                    /* Codes_SRS_AMQPVALUE_01_342: [1.6.6 ulong Integer in the range 0 to 264 - 1 inclusive.] */\n                    internal_decoder_data->decode_to_value->type = AMQP_TYPE_ULONG;\n                    internal_decoder_data->decoder_state = DECODER_STATE_TYPE_DATA;\n                    internal_decoder_data->decode_to_value->value.ulong_value = 0;\n\n                    /* Codes_SRS_AMQPVALUE_01_327: [If not enough bytes have accumulated to decode a value, the on_value_decoded shall not be called.] */\n                    internal_decoder_data->bytes_decoded = 0;\n                    result = 0;\n                    break;\n                }\n                /* Codes_SRS_AMQPVALUE_01_344: [<encoding name=\"smallulong\" code=\"0x53\" category=\"fixed\" width=\"1\" label=\"unsigned long value in the range 0 to 255 inclusive\"/>] */\n                case 0x53:\n                {\n                    internal_decoder_data->decode_to_value->type = AMQP_TYPE_ULONG;\n                    internal_decoder_data->decoder_state = DECODER_STATE_TYPE_DATA;\n                    internal_decoder_data->decode_to_value->value.ulong_value = 0;\n\n                    /* Codes_SRS_AMQPVALUE_01_327: [If not enough bytes have accumulated to decode a value, the on_value_decoded shall not be called.] */\n                    internal_decoder_data->bytes_decoded = 0;\n                    result = 0;\n                    break;\n                }\n                /* Codes_SRS_AMQPVALUE_01_345: [<encoding name=\"ulong0\" code=\"0x44\" category=\"fixed\" width=\"0\" label=\"the ulong value 0\"/>] */\n                case 0x44:\n                {\n                    /* Codes_SRS_AMQPVALUE_01_342: [1.6.6 ulong Integer in the range 0 to 264 - 1 inclusive.] */\n                    internal_decoder_data->decode_to_value->type = AMQP_TYPE_ULONG;\n                    internal_decoder_data->decode_to_value->value.ulong_value = 0;\n                    internal_decoder_data->decoder_state = DECODER_STATE_CONSTRUCTOR;\n\n                    /* Codes_SRS_AMQPVALUE_01_323: [When enough bytes have been processed for a valid amqp value, the on_value_decoded passed in amqpvalue_decoder_create shall be called.] */\n                    /* Codes_SRS_AMQPVALUE_01_324: [The decoded amqp value shall be passed to on_value_decoded.] */\n                    /* Codes_SRS_AMQPVALUE_01_325: [Also the context stored in amqpvalue_decoder_create shall be passed to the on_value_decoded callback.] */\n                    internal_decoder_data->on_value_decoded(internal_decoder_data->on_value_decoded_context, internal_decoder_data->decode_to_value);\n                    result = 0;\n                    break;\n                }\n                /* Codes_SRS_AMQPVALUE_01_347: [<encoding code=\"0x51\" category=\"fixed\" width=\"1\" label=\"8-bit two's-complement integer\"/>] */\n                case 0x51:\n                {\n                    /* Codes_SRS_AMQPVALUE_01_346: [1.6.7 byte Integer in the range -(27) to 27 - 1 inclusive.] */\n                    internal_decoder_data->decode_to_value->type = AMQP_TYPE_BYTE;\n                    internal_decoder_data->decoder_state = DECODER_STATE_TYPE_DATA;\n                    internal_decoder_data->decode_to_value->value.byte_value = 0;\n                    internal_decoder_data->bytes_decoded = 0;\n\n                    /* Codes_SRS_AMQPVALUE_01_327: [If not enough bytes have accumulated to decode a value, the on_value_decoded shall not be called.] */\n                    result = 0;\n                    break;\n                }\n                /* Codes_SRS_AMQPVALUE_01_349: [<encoding code=\"0x61\" category=\"fixed\" width=\"2\" label=\"16-bit two's-complement integer in network byte order\"/>] */\n                case 0x61:\n                {\n                    /* Codes_SRS_AMQPVALUE_01_348: [1.6.8 short Integer in the range -(215) to 215 - 1 inclusive.] */\n                    internal_decoder_data->decode_to_value->type = AMQP_TYPE_SHORT;\n                    internal_decoder_data->decoder_state = DECODER_STATE_TYPE_DATA;\n                    internal_decoder_data->decode_to_value->value.short_value = 0;\n                    internal_decoder_data->bytes_decoded = 0;\n\n                    /* Codes_SRS_AMQPVALUE_01_327: [If not enough bytes have accumulated to decode a value, the on_value_decoded shall not be called.] */\n                    result = 0;\n                    break;\n                }\n                /* Codes_SRS_AMQPVALUE_01_351: [<encoding code=\"0x71\" category=\"fixed\" width=\"4\" label=\"32-bit two's-complement integer in network byte order\"/>] */\n                case 0x71:\n                {\n                    /* Codes_SRS_AMQPVALUE_01_350: [1.6.9 int Integer in the range -(231) to 231 - 1 inclusive.] */\n                    internal_decoder_data->decode_to_value->type = AMQP_TYPE_INT;\n                    internal_decoder_data->decoder_state = DECODER_STATE_TYPE_DATA;\n                    internal_decoder_data->decode_to_value->value.int_value = 0;\n                    internal_decoder_data->bytes_decoded = 0;\n\n                    /* Codes_SRS_AMQPVALUE_01_327: [If not enough bytes have accumulated to decode a value, the on_value_decoded shall not be called.] */\n                    result = 0;\n                    break;\n                }\n                /* Codes_SRS_AMQPVALUE_01_352: [<encoding name=\"smallint\" code=\"0x54\" category=\"fixed\" width=\"1\" label=\"8-bit two's-complement integer\"/>] */\n                case 0x54:\n                {\n                    /* Codes_SRS_AMQPVALUE_01_350: [1.6.9 int Integer in the range -(231) to 231 - 1 inclusive.] */\n                    internal_decoder_data->decode_to_value->type = AMQP_TYPE_INT;\n                    internal_decoder_data->decoder_state = DECODER_STATE_TYPE_DATA;\n                    internal_decoder_data->decode_to_value->value.int_value = 0;\n\n                    /* Codes_SRS_AMQPVALUE_01_327: [If not enough bytes have accumulated to decode a value, the on_value_decoded shall not be called.] */\n                    result = 0;\n                    break;\n                }\n                /* Codes_SRS_AMQPVALUE_01_354: [<encoding code=\"0x81\" category=\"fixed\" width=\"8\" label=\"64-bit two's-complement integer in network byte order\"/>] */\n                case 0x81:\n                {\n                    /* Codes_SRS_AMQPVALUE_01_353: [1.6.10 long Integer in the range -(263) to 263 - 1 inclusive.] */\n                    internal_decoder_data->decode_to_value->type = AMQP_TYPE_LONG;\n                    internal_decoder_data->decoder_state = DECODER_STATE_TYPE_DATA;\n                    internal_decoder_data->decode_to_value->value.long_value = 0;\n                    internal_decoder_data->bytes_decoded = 0;\n\n                    /* Codes_SRS_AMQPVALUE_01_327: [If not enough bytes have accumulated to decode a value, the on_value_decoded shall not be called.] */\n                    result = 0;\n                    break;\n                }\n                /* Codes_SRS_AMQPVALUE_01_355: [<encoding name=\"smalllong\" code=\"0x55\" category=\"fixed\" width=\"1\" label=\"8-bit two's-complement integer\"/>] */\n                case 0x55:\n                {\n                    /* Codes_SRS_AMQPVALUE_01_353: [1.6.10 long Integer in the range -(263) to 263 - 1 inclusive.] */\n                    internal_decoder_data->decode_to_value->type = AMQP_TYPE_LONG;\n                    internal_decoder_data->decoder_state = DECODER_STATE_TYPE_DATA;\n                    internal_decoder_data->decode_to_value->value.long_value = 0;\n\n                    /* Codes_SRS_AMQPVALUE_01_327: [If not enough bytes have accumulated to decode a value, the on_value_decoded shall not be called.] */\n                    result = 0;\n                    break;\n                }\n                /* Codes_SRS_AMQPVALUE_01_289: [\\<encoding name=\"ieee-754\" code=\"0x72\" category=\"fixed\" width=\"4\" label=\"IEEE 754-2008 binary32\"/>] */\n                case 0x72:\n                {\n                    /* Codes_SRS_AMQPVALUE_01_019: [1.6.11 float 32-bit floating point number (IEEE 754-2008 binary32).] */\n                    internal_decoder_data->decode_to_value->type = AMQP_TYPE_FLOAT;\n                    internal_decoder_data->decoder_state = DECODER_STATE_TYPE_DATA;\n                    internal_decoder_data->bytes_decoded = 0;\n                    *((uint32_t*)&internal_decoder_data->decode_to_value->value.float_value) = 0;\n\n                    /* Codes_SRS_AMQPVALUE_01_327: [If not enough bytes have accumulated to decode a value, the on_value_decoded shall not be called.] */\n                    result = 0;\n                    break;\n                }\n                /* Codes_SRS_AMQPVALUE_01_290: [\\<encoding name=\"ieee-754\" code=\"0x82\" category=\"fixed\" width=\"8\" label=\"IEEE 754-2008 binary64\"/>] */\n                case 0x82:\n                {\n                    /* Codes_SRS_AMQPVALUE_01_020: [1.6.12 double 64-bit floating point number (IEEE 754-2008 binary64).] */\n                    internal_decoder_data->decode_to_value->type = AMQP_TYPE_DOUBLE;\n                    internal_decoder_data->decoder_state = DECODER_STATE_TYPE_DATA;\n                    internal_decoder_data->bytes_decoded = 0;\n                    *((uint64_t*)&internal_decoder_data->decode_to_value->value.double_value) = 0;\n\n                    /* Codes_SRS_AMQPVALUE_01_327: [If not enough bytes have accumulated to decode a value, the on_value_decoded shall not be called.] */\n                    result = 0;\n                    break;\n                }\n                /* Codes_SRS_AMQPVALUE_01_369: [<encoding name=\"ms64\" code=\"0x83\" category=\"fixed\" width=\"8\" label=\"64-bit two's-complement integer representing milliseconds since the unix epoch\"/>] */\n                case 0x83:\n                {\n                    /* Codes_SRS_AMQPVALUE_01_368: [1.6.17 timestamp An absolute point in time.] */\n                    internal_decoder_data->decode_to_value->type = AMQP_TYPE_TIMESTAMP;\n                    internal_decoder_data->decoder_state = DECODER_STATE_TYPE_DATA;\n                    internal_decoder_data->decode_to_value->value.timestamp_value = 0;\n                    internal_decoder_data->bytes_decoded = 0;\n\n                    /* Codes_SRS_AMQPVALUE_01_327: [If not enough bytes have accumulated to decode a value, the on_value_decoded shall not be called.] */\n                    result = 0;\n                    break;\n                }\n                /* Codes_SRS_AMQPVALUE_01_371: [<encoding code=\"0x98\" category=\"fixed\" width=\"16\" label=\"UUID as defined in section 4.1.2 of RFC-4122\"/>] */\n                case 0x98:\n                {\n                    /* Codes_SRS_AMQPVALUE_01_370: [1.6.18 uuid A universally unique identifier as defined by RFC-4122 section 4.1.2 .] */\n                    internal_decoder_data->decode_to_value->type = AMQP_TYPE_UUID;\n                    internal_decoder_data->decoder_state = DECODER_STATE_TYPE_DATA;\n                    internal_decoder_data->decode_to_value->value.timestamp_value = 0;\n                    internal_decoder_data->bytes_decoded = 0;\n\n                    /* Codes_SRS_AMQPVALUE_01_327: [If not enough bytes have accumulated to decode a value, the on_value_decoded shall not be called.] */\n                    result = 0;\n                    break;\n                }\n                /* Codes_SRS_AMQPVALUE_01_373: [<encoding name=\"vbin8\" code=\"0xa0\" category=\"variable\" width=\"1\" label=\"up to 2^8 - 1 octets of binary data\"/>] */\n                case 0xA0:\n                /* Codes_SRS_AMQPVALUE_01_374: [<encoding name=\"vbin32\" code=\"0xb0\" category=\"variable\" width=\"4\" label=\"up to 2^32 - 1 octets of binary data\"/>] */\n                case 0xB0:\n                {\n                    /* Codes_SRS_AMQPVALUE_01_372: [1.6.19 binary A sequence of octets.] */\n                    internal_decoder_data->decode_to_value->type = AMQP_TYPE_BINARY;\n                    internal_decoder_data->decoder_state = DECODER_STATE_TYPE_DATA;\n                    internal_decoder_data->decode_to_value->value.binary_value.length = 0;\n                    internal_decoder_data->decode_to_value->value.binary_value.bytes = NULL;\n                    internal_decoder_data->bytes_decoded = 0;\n\n                    /* Codes_SRS_AMQPVALUE_01_327: [If not enough bytes have accumulated to decode a value, the on_value_decoded shall not be called.] */\n                    result = 0;\n                    break;\n                }\n                /* Codes_SRS_AMQPVALUE_01_376: [<encoding name=\"str8-utf8\" code=\"0xa1\" category=\"variable\" width=\"1\" label=\"up to 2^8 - 1 octets worth of UTF-8 Unicode (with no byte order mark)\"/>] */\n                case 0xA1:\n                /* Codes_SRS_AMQPVALUE_01_377: [<encoding name=\"str32-utf8\" code=\"0xb1\" category=\"variable\" width=\"4\" label=\"up to 2^32 - 1 octets worth of UTF-8 Unicode (with no byte order mark)\"/>] */\n                case 0xB1:\n                {\n                    /* Codes_SRS_AMQPVALUE_01_375: [1.6.20 string A sequence of Unicode characters.] */\n                    internal_decoder_data->decode_to_value->type = AMQP_TYPE_STRING;\n                    internal_decoder_data->decoder_state = DECODER_STATE_TYPE_DATA;\n                    internal_decoder_data->decode_to_value->value.string_value.chars = NULL;\n                    internal_decoder_data->decode_value_state.string_value_state.length = 0;\n                    internal_decoder_data->bytes_decoded = 0;\n\n                    /* Codes_SRS_AMQPVALUE_01_327: [If not enough bytes have accumulated to decode a value, the on_value_decoded shall not be called.] */\n                    result = 0;\n                    break;\n                }\n                /* Codes_SRS_AMQPVALUE_01_379: [<encoding name=\"sym8\" code=\"0xa3\" category=\"variable\" width=\"1\" label=\"up to 2^8 - 1 seven bit ASCII characters representing a symbolic value\"/>] */\n                case 0xA3:\n                /* Codes_SRS_AMQPVALUE_01_380: [<encoding name=\"sym32\" code=\"0xb3\" category=\"variable\" width=\"4\" label=\"up to 2^32 - 1 seven bit ASCII characters representing a symbolic value\"/>] */\n                case 0xB3:\n                {\n                    /* Codes_SRS_AMQPVALUE_01_378: [1.6.21 symbol Symbolic values from a constrained domain.] */\n                    internal_decoder_data->decode_to_value->type = AMQP_TYPE_SYMBOL;\n                    internal_decoder_data->decoder_state = DECODER_STATE_TYPE_DATA;\n                    internal_decoder_data->decode_to_value->value.symbol_value.chars = NULL;\n                    internal_decoder_data->decode_value_state.symbol_value_state.length = 0;\n                    internal_decoder_data->bytes_decoded = 0;\n\n                    /* Codes_SRS_AMQPVALUE_01_327: [If not enough bytes have accumulated to decode a value, the on_value_decoded shall not be called.] */\n                    result = 0;\n                    break;\n                }\n                /* Codes_SRS_AMQPVALUE_01_384: [<encoding name=\"list0\" code=\"0x45\" category=\"fixed\" width=\"0\" label=\"the empty list (i.e. the list with no elements)\"/>] */\n                case 0x45:\n                    /* Codes_SRS_AMQPVALUE_01_383: [1.6.22 list A sequence of polymorphic values.] */\n                    internal_decoder_data->decode_to_value->type = AMQP_TYPE_LIST;\n                    internal_decoder_data->decoder_state = DECODER_STATE_CONSTRUCTOR;\n                    internal_decoder_data->decode_to_value->value.list_value.count = 0;\n                    internal_decoder_data->decode_to_value->value.list_value.items = NULL;\n\n                    /* Codes_SRS_AMQPVALUE_01_323: [When enough bytes have been processed for a valid amqp value, the on_value_decoded passed in amqpvalue_decoder_create shall be called.] */\n                    /* Codes_SRS_AMQPVALUE_01_324: [The decoded amqp value shall be passed to on_value_decoded.] */\n                    /* Codes_SRS_AMQPVALUE_01_325: [Also the context stored in amqpvalue_decoder_create shall be passed to the on_value_decoded callback.] */\n                    internal_decoder_data->on_value_decoded(internal_decoder_data->on_value_decoded_context, internal_decoder_data->decode_to_value);\n                    result = 0;\n                    break;\n\n                /* Codes_SRS_AMQPVALUE_01_385: [<encoding name=\"list8\" code=\"0xc0\" category=\"compound\" width=\"1\" label=\"up to 2^8 - 1 list elements with total size less than 2^8 octets\"/>] */\n                case 0xC0:\n                case 0xD0:\n                    internal_decoder_data->decode_to_value->type = AMQP_TYPE_LIST;\n                    internal_decoder_data->decoder_state = DECODER_STATE_TYPE_DATA;\n                    internal_decoder_data->decode_to_value->value.list_value.count = 0;\n                    internal_decoder_data->decode_to_value->value.list_value.items = NULL;\n                    internal_decoder_data->bytes_decoded = 0;\n                    internal_decoder_data->decode_value_state.list_value_state.list_value_state = DECODE_LIST_STEP_SIZE;\n\n                    /* Codes_SRS_AMQPVALUE_01_327: [If not enough bytes have accumulated to decode a value, the on_value_decoded shall not be called.] */\n                    result = 0;\n                    break;\n\n                case 0xC1:\n                case 0xD1:\n                    internal_decoder_data->decode_to_value->type = AMQP_TYPE_MAP;\n                    internal_decoder_data->decoder_state = DECODER_STATE_TYPE_DATA;\n                    internal_decoder_data->decode_to_value->value.map_value.pair_count = 0;\n                    internal_decoder_data->decode_to_value->value.map_value.pairs = NULL;\n                    internal_decoder_data->bytes_decoded = 0;\n                    internal_decoder_data->decode_value_state.map_value_state.map_value_state = DECODE_MAP_STEP_SIZE;\n\n                    result = 0;\n                    break;\n\n                case 0xE0:\n                case 0xF0:\n                    internal_decoder_data->decode_to_value->type = AMQP_TYPE_ARRAY;\n                    internal_decoder_data->decoder_state = DECODER_STATE_TYPE_DATA;\n                    internal_decoder_data->decode_to_value->value.array_value.count = 0;\n                    internal_decoder_data->decode_to_value->value.array_value.items = NULL;\n                    internal_decoder_data->bytes_decoded = 0;\n                    internal_decoder_data->decode_value_state.array_value_state.array_value_state = DECODE_ARRAY_STEP_SIZE;\n\n                    result = 0;\n                    break;\n                }\n                break;\n            }\n\n            case DECODER_STATE_TYPE_DATA:\n            {\n                switch (internal_decoder_data->constructor_byte)\n                {\n                default:\n                    LogError(\"Invalid constructor byte: 0x%02x\", internal_decoder_data->constructor_byte);\n                    result = MU_FAILURE;\n                    break;\n\n                case 0x00: /* descriptor */\n                {\n                    DECODE_DESCRIBED_VALUE_STEP step = internal_decoder_data->decode_value_state.described_value_state.described_value_state;\n                    switch (step)\n                    {\n                    default:\n                        LogError(\"Invalid described value decode step: %d\", step);\n                        result = MU_FAILURE;\n                        break;\n\n                    case DECODE_DESCRIBED_VALUE_STEP_DESCRIPTOR:\n                    {\n                        size_t inner_used_bytes;\n                        if (internal_decoder_decode_bytes(internal_decoder_data->inner_decoder, buffer, size, &inner_used_bytes) != 0)\n                        {\n                            LogError(\"Decoding bytes for described value failed\");\n                            internal_decoder_data->decode_to_value->type = AMQP_TYPE_UNKNOWN;\n                            result = MU_FAILURE;\n                        }\n                        else\n                        {\n                            INTERNAL_DECODER_DATA* inner_decoder = (INTERNAL_DECODER_DATA*)internal_decoder_data->inner_decoder;\n                            buffer += inner_used_bytes;\n                            size -= inner_used_bytes;\n\n                            if (inner_decoder->decoder_state == DECODER_STATE_DONE)\n                            {\n                                AMQP_VALUE described_value;\n                                internal_decoder_destroy(inner_decoder);\n\n                                described_value = REFCOUNT_TYPE_CREATE(AMQP_VALUE_DATA);\n                                if (described_value == NULL)\n                                {\n                                    internal_decoder_data->decoder_state = DECODER_STATE_ERROR;\n                                    LogError(\"Could not allocate memory for AMQP value\");\n                                    result = MU_FAILURE;\n                                }\n                                else\n                                {\n                                    described_value->type = AMQP_TYPE_UNKNOWN;\n                                    internal_decoder_data->decode_to_value->value.described_value.value = (AMQP_VALUE)described_value;\n                                    internal_decoder_data->inner_decoder = internal_decoder_create(inner_decoder_callback, internal_decoder_data, described_value, true);\n                                    if (internal_decoder_data->inner_decoder == NULL)\n                                    {\n                                        internal_decoder_data->decoder_state = DECODER_STATE_ERROR;\n                                        LogError(\"Could not create inner decoder\");\n                                        result = MU_FAILURE;\n                                    }\n                                    else\n                                    {\n                                        internal_decoder_data->decode_value_state.described_value_state.described_value_state = DECODE_DESCRIBED_VALUE_STEP_VALUE;\n                                        result = 0;\n                                    }\n                                }\n                            }\n                            else\n                            {\n                                result = 0;\n                            }\n                        }\n                        break;\n                    }\n                    case DECODE_DESCRIBED_VALUE_STEP_VALUE:\n                    {\n                        size_t inner_used_bytes;\n                        if (internal_decoder_decode_bytes(internal_decoder_data->inner_decoder, buffer, size, &inner_used_bytes) != 0)\n                        {\n                            LogError(\"Decoding bytes for described value failed\");\n                            result = MU_FAILURE;\n                        }\n                        else\n                        {\n                            INTERNAL_DECODER_DATA* inner_decoder = (INTERNAL_DECODER_DATA*)internal_decoder_data->inner_decoder;\n                            buffer += inner_used_bytes;\n                            size -= inner_used_bytes;\n\n                            if (inner_decoder->decoder_state == DECODER_STATE_DONE)\n                            {\n                                internal_decoder_destroy(inner_decoder);\n                                internal_decoder_data->inner_decoder = NULL;\n\n                                internal_decoder_data->decoder_state = DECODER_STATE_CONSTRUCTOR;\n                                internal_decoder_data->on_value_decoded(internal_decoder_data->on_value_decoded_context, internal_decoder_data->decode_to_value);\n                            }\n\n                            result = 0;\n                        }\n                        break;\n                    }\n                    }\n                    break;\n                }\n                case 0x56:\n                {\n                    /* Codes_SRS_AMQPVALUE_01_331: [<encoding code=\"0x56\" category=\"fixed\" width=\"1\" label=\"boolean with the octet 0x00 being false and octet 0x01 being true\"/>] */\n                    if (buffer[0] >= 2)\n                    {\n                        LogError(\"Bad boolean value: %02X\", buffer[0]);\n                        result = MU_FAILURE;\n                    }\n                    else\n                    {\n                        internal_decoder_data->decode_to_value->value.bool_value = (buffer[0] == 0) ? false : true;\n\n                        buffer++;\n                        size--;\n                        internal_decoder_data->decoder_state = DECODER_STATE_CONSTRUCTOR;\n\n                        /* Codes_SRS_AMQPVALUE_01_323: [When enough bytes have been processed for a valid amqp value, the on_value_decoded passed in amqpvalue_decoder_create shall be called.] */\n                        /* Codes_SRS_AMQPVALUE_01_324: [The decoded amqp value shall be passed to on_value_decoded.] */\n                        /* Codes_SRS_AMQPVALUE_01_325: [Also the context stored in amqpvalue_decoder_create shall be passed to the on_value_decoded callback.] */\n                        internal_decoder_data->on_value_decoded(internal_decoder_data->on_value_decoded_context, internal_decoder_data->decode_to_value);\n                        result = 0;\n                    }\n\n                    break;\n                }\n                /* Codes_SRS_AMQPVALUE_01_335: [<encoding code=\"0x50\" category=\"fixed\" width=\"1\" label=\"8-bit unsigned integer\"/>] */\n                case 0x50:\n                {\n                    internal_decoder_data->decode_to_value->value.ubyte_value = buffer[0];\n                    buffer++;\n                    size--;\n                    internal_decoder_data->decoder_state = DECODER_STATE_CONSTRUCTOR;\n\n                    /* Codes_SRS_AMQPVALUE_01_323: [When enough bytes have been processed for a valid amqp value, the on_value_decoded passed in amqpvalue_decoder_create shall be called.] */\n                    /* Codes_SRS_AMQPVALUE_01_324: [The decoded amqp value shall be passed to on_value_decoded.] */\n                    /* Codes_SRS_AMQPVALUE_01_325: [Also the context stored in amqpvalue_decoder_create shall be passed to the on_value_decoded callback.] */\n                    internal_decoder_data->on_value_decoded(internal_decoder_data->on_value_decoded_context, internal_decoder_data->decode_to_value);\n                    result = 0;\n                    break;\n                }\n                /* Codes_SRS_AMQPVALUE_01_337: [<encoding code=\"0x60\" category=\"fixed\" width=\"2\" label=\"16-bit unsigned integer in network byte order\"/>] */\n                case 0x60:\n                {\n                    internal_decoder_data->decode_to_value->value.ushort_value += ((uint16_t)buffer[0]) << ((1 - internal_decoder_data->bytes_decoded) * 8);\n                    internal_decoder_data->bytes_decoded++;\n                    buffer++;\n                    size--;\n                    if (internal_decoder_data->bytes_decoded == 2)\n                    {\n                        internal_decoder_data->decoder_state = DECODER_STATE_CONSTRUCTOR;\n\n                        /* Codes_SRS_AMQPVALUE_01_323: [When enough bytes have been processed for a valid amqp value, the on_value_decoded passed in amqpvalue_decoder_create shall be called.] */\n                        /* Codes_SRS_AMQPVALUE_01_324: [The decoded amqp value shall be passed to on_value_decoded.] */\n                        /* Codes_SRS_AMQPVALUE_01_325: [Also the context stored in amqpvalue_decoder_create shall be passed to the on_value_decoded callback.] */\n                        internal_decoder_data->on_value_decoded(internal_decoder_data->on_value_decoded_context, internal_decoder_data->decode_to_value);\n                    }\n\n                    result = 0;\n                    break;\n                }\n                /* Codes_SRS_AMQPVALUE_01_339: [<encoding code=\"0x70\" category=\"fixed\" width=\"4\" label=\"32-bit unsigned integer in network byte order\"/>] */\n                case 0x70:\n                {\n                    internal_decoder_data->decode_to_value->value.uint_value += ((uint32_t)buffer[0]) << ((3 - internal_decoder_data->bytes_decoded) * 8);\n                    internal_decoder_data->bytes_decoded++;\n                    buffer++;\n                    size--;\n\n                    /* Codes_SRS_AMQPVALUE_01_327: [If not enough bytes have accumulated to decode a value, the on_value_decoded shall not be called.] */\n                    if (internal_decoder_data->bytes_decoded == 4)\n                    {\n                        internal_decoder_data->decoder_state = DECODER_STATE_CONSTRUCTOR;\n\n                        /* Codes_SRS_AMQPVALUE_01_323: [When enough bytes have been processed for a valid amqp value, the on_value_decoded passed in amqpvalue_decoder_create shall be called.] */\n                        /* Codes_SRS_AMQPVALUE_01_324: [The decoded amqp value shall be passed to on_value_decoded.] */\n                        /* Codes_SRS_AMQPVALUE_01_325: [Also the context stored in amqpvalue_decoder_create shall be passed to the on_value_decoded callback.] */\n                        internal_decoder_data->on_value_decoded(internal_decoder_data->on_value_decoded_context, internal_decoder_data->decode_to_value);\n                    }\n\n                    result = 0;\n                    break;\n                }\n                /* Codes_SRS_AMQPVALUE_01_340: [<encoding name=\"smalluint\" code=\"0x52\" category=\"fixed\" width=\"1\" label=\"unsigned integer value in the range 0 to 255 inclusive\"/>] */\n                case 0x52:\n                {\n                    internal_decoder_data->decode_to_value->value.uint_value = buffer[0];\n                    buffer++;\n                    size--;\n                    internal_decoder_data->decoder_state = DECODER_STATE_CONSTRUCTOR;\n\n                    /* Codes_SRS_AMQPVALUE_01_323: [When enough bytes have been processed for a valid amqp value, the on_value_decoded passed in amqpvalue_decoder_create shall be called.] */\n                    /* Codes_SRS_AMQPVALUE_01_324: [The decoded amqp value shall be passed to on_value_decoded.] */\n                    /* Codes_SRS_AMQPVALUE_01_325: [Also the context stored in amqpvalue_decoder_create shall be passed to the on_value_decoded callback.] */\n                    internal_decoder_data->on_value_decoded(internal_decoder_data->on_value_decoded_context, internal_decoder_data->decode_to_value);\n                    result = 0;\n                    break;\n                }\n                /* Codes_SRS_AMQPVALUE_01_343: [<encoding code=\"0x80\" category=\"fixed\" width=\"8\" label=\"64-bit unsigned integer in network byte order\"/>] */\n                case 0x80:\n                {\n                    internal_decoder_data->decode_to_value->value.ulong_value += ((uint64_t)buffer[0]) << ((7 - internal_decoder_data->bytes_decoded) * 8);\n                    internal_decoder_data->bytes_decoded++;\n                    buffer++;\n                    size--;\n\n                    /* Codes_SRS_AMQPVALUE_01_327: [If not enough bytes have accumulated to decode a value, the on_value_decoded shall not be called.] */\n                    if (internal_decoder_data->bytes_decoded == 8)\n                    {\n                        internal_decoder_data->decoder_state = DECODER_STATE_CONSTRUCTOR;\n\n                        /* Codes_SRS_AMQPVALUE_01_323: [When enough bytes have been processed for a valid amqp value, the on_value_decoded passed in amqpvalue_decoder_create shall be called.] */\n                        /* Codes_SRS_AMQPVALUE_01_324: [The decoded amqp value shall be passed to on_value_decoded.] */\n                        /* Codes_SRS_AMQPVALUE_01_325: [Also the context stored in amqpvalue_decoder_create shall be passed to the on_value_decoded callback.] */\n                        internal_decoder_data->on_value_decoded(internal_decoder_data->on_value_decoded_context, internal_decoder_data->decode_to_value);\n                    }\n\n                    result = 0;\n                    break;\n                }\n                /* Codes_SRS_AMQPVALUE_01_344: [<encoding name=\"smallulong\" code=\"0x53\" category=\"fixed\" width=\"1\" label=\"unsigned long value in the range 0 to 255 inclusive\"/>] */\n                case 0x53:\n                {\n                    internal_decoder_data->decode_to_value->value.ulong_value = buffer[0];\n                    buffer++;\n                    size--;\n                    internal_decoder_data->decoder_state = DECODER_STATE_CONSTRUCTOR;\n\n                    /* Codes_SRS_AMQPVALUE_01_323: [When enough bytes have been processed for a valid amqp value, the on_value_decoded passed in amqpvalue_decoder_create shall be called.] */\n                    /* Codes_SRS_AMQPVALUE_01_324: [The decoded amqp value shall be passed to on_value_decoded.] */\n                    /* Codes_SRS_AMQPVALUE_01_325: [Also the context stored in amqpvalue_decoder_create shall be passed to the on_value_decoded callback.] */\n                    internal_decoder_data->on_value_decoded(internal_decoder_data->on_value_decoded_context, internal_decoder_data->decode_to_value);\n                    result = 0;\n                    break;\n                }\n                /* Codes_SRS_AMQPVALUE_01_347: [<encoding code=\"0x51\" category=\"fixed\" width=\"1\" label=\"8-bit two's-complement integer\"/>] */\n                case 0x51:\n                {\n                    internal_decoder_data->decode_to_value->value.byte_value = buffer[0];\n                    buffer++;\n                    size--;\n                    internal_decoder_data->decoder_state = DECODER_STATE_CONSTRUCTOR;\n\n                    /* Codes_SRS_AMQPVALUE_01_323: [When enough bytes have been processed for a valid amqp value, the on_value_decoded passed in amqpvalue_decoder_create shall be called.] */\n                    /* Codes_SRS_AMQPVALUE_01_324: [The decoded amqp value shall be passed to on_value_decoded.] */\n                    /* Codes_SRS_AMQPVALUE_01_325: [Also the context stored in amqpvalue_decoder_create shall be passed to the on_value_decoded callback.] */\n                    internal_decoder_data->on_value_decoded(internal_decoder_data->on_value_decoded_context, internal_decoder_data->decode_to_value);\n                    result = 0;\n                    break;\n                }\n                /* Codes_SRS_AMQPVALUE_01_349: [<encoding code=\"0x61\" category=\"fixed\" width=\"2\" label=\"16-bit two's-complement integer in network byte order\"/>] */\n                case 0x61:\n                {\n                    internal_decoder_data->decode_to_value->value.short_value = (int16_t)((uint16_t)internal_decoder_data->decode_to_value->value.short_value + (((uint16_t)buffer[0]) << ((1 - internal_decoder_data->bytes_decoded) * 8)));\n                    internal_decoder_data->bytes_decoded++;\n                    buffer++;\n                    size--;\n\n                    /* Codes_SRS_AMQPVALUE_01_327: [If not enough bytes have accumulated to decode a value, the on_value_decoded shall not be called.] */\n                    if (internal_decoder_data->bytes_decoded == 2)\n                    {\n                        internal_decoder_data->decoder_state = DECODER_STATE_CONSTRUCTOR;\n\n                        /* Codes_SRS_AMQPVALUE_01_323: [When enough bytes have been processed for a valid amqp value, the on_value_decoded passed in amqpvalue_decoder_create shall be called.] */\n                        /* Codes_SRS_AMQPVALUE_01_324: [The decoded amqp value shall be passed to on_value_decoded.] */\n                        /* Codes_SRS_AMQPVALUE_01_325: [Also the context stored in amqpvalue_decoder_create shall be passed to the on_value_decoded callback.] */\n                        internal_decoder_data->on_value_decoded(internal_decoder_data->on_value_decoded_context, internal_decoder_data->decode_to_value);\n                    }\n\n                    result = 0;\n                    break;\n                }\n                /* Codes_SRS_AMQPVALUE_01_351: [<encoding code=\"0x71\" category=\"fixed\" width=\"4\" label=\"32-bit two's-complement integer in network byte order\"/>] */\n                case 0x71:\n                {\n                    internal_decoder_data->decode_to_value->value.int_value = (int32_t)((uint32_t)internal_decoder_data->decode_to_value->value.int_value + (((uint32_t)buffer[0]) << ((3 - internal_decoder_data->bytes_decoded) * 8)));\n                    internal_decoder_data->bytes_decoded++;\n                    buffer++;\n                    size--;\n\n                    /* Codes_SRS_AMQPVALUE_01_327: [If not enough bytes have accumulated to decode a value, the on_value_decoded shall not be called.] */\n                    if (internal_decoder_data->bytes_decoded == 4)\n                    {\n                        internal_decoder_data->decoder_state = DECODER_STATE_CONSTRUCTOR;\n\n                        /* Codes_SRS_AMQPVALUE_01_323: [When enough bytes have been processed for a valid amqp value, the on_value_decoded passed in amqpvalue_decoder_create shall be called.] */\n                        /* Codes_SRS_AMQPVALUE_01_324: [The decoded amqp value shall be passed to on_value_decoded.] */\n                        /* Codes_SRS_AMQPVALUE_01_325: [Also the context stored in amqpvalue_decoder_create shall be passed to the on_value_decoded callback.] */\n                        internal_decoder_data->on_value_decoded(internal_decoder_data->on_value_decoded_context, internal_decoder_data->decode_to_value);\n                    }\n\n                    result = 0;\n                    break;\n                }\n                /* Codes_SRS_AMQPVALUE_01_351: [<encoding code=\"0x71\" category=\"fixed\" width=\"4\" label=\"32-bit two's-complement integer in network byte order\"/>] */\n                case 0x54:\n                {\n                    internal_decoder_data->decode_to_value->value.int_value = (int32_t)((int8_t)(buffer[0]));\n                    buffer++;\n                    size--;\n                    internal_decoder_data->decoder_state = DECODER_STATE_CONSTRUCTOR;\n\n                    /* Codes_SRS_AMQPVALUE_01_323: [When enough bytes have been processed for a valid amqp value, the on_value_decoded passed in amqpvalue_decoder_create shall be called.] */\n                    /* Codes_SRS_AMQPVALUE_01_324: [The decoded amqp value shall be passed to on_value_decoded.] */\n                    /* Codes_SRS_AMQPVALUE_01_325: [Also the context stored in amqpvalue_decoder_create shall be passed to the on_value_decoded callback.] */\n                    internal_decoder_data->on_value_decoded(internal_decoder_data->on_value_decoded_context, internal_decoder_data->decode_to_value);\n                    result = 0;\n                    break;\n                }\n                /* Codes_SRS_AMQPVALUE_01_354: [<encoding code=\"0x81\" category=\"fixed\" width=\"8\" label=\"64-bit two's-complement integer in network byte order\"/>] */\n                case 0x81:\n                {\n                    internal_decoder_data->decode_to_value->value.long_value = (int64_t)((uint64_t)internal_decoder_data->decode_to_value->value.long_value + (((uint64_t)buffer[0]) << ((7 - internal_decoder_data->bytes_decoded) * 8)));\n                    internal_decoder_data->bytes_decoded++;\n                    buffer++;\n                    size--;\n\n                    /* Codes_SRS_AMQPVALUE_01_327: [If not enough bytes have accumulated to decode a value, the on_value_decoded shall not be called.] */\n                    if (internal_decoder_data->bytes_decoded == 8)\n                    {\n                        internal_decoder_data->decoder_state = DECODER_STATE_CONSTRUCTOR;\n\n                        /* Codes_SRS_AMQPVALUE_01_323: [When enough bytes have been processed for a valid amqp value, the on_value_decoded passed in amqpvalue_decoder_create shall be called.] */\n                        /* Codes_SRS_AMQPVALUE_01_324: [The decoded amqp value shall be passed to on_value_decoded.] */\n                        /* Codes_SRS_AMQPVALUE_01_325: [Also the context stored in amqpvalue_decoder_create shall be passed to the on_value_decoded callback.] */\n                        internal_decoder_data->on_value_decoded(internal_decoder_data->on_value_decoded_context, internal_decoder_data->decode_to_value);\n                    }\n\n                    result = 0;\n                    break;\n                }\n                /* Codes_SRS_AMQPVALUE_01_355: [<encoding name=\"smalllong\" code=\"0x55\" category=\"fixed\" width=\"1\" label=\"8-bit two's-complement integer\"/>] */\n                case 0x55:\n                {\n                    internal_decoder_data->decode_to_value->value.long_value = (int64_t)((int8_t)buffer[0]);\n                    buffer++;\n                    size--;\n                    internal_decoder_data->decoder_state = DECODER_STATE_CONSTRUCTOR;\n\n                    /* Codes_SRS_AMQPVALUE_01_323: [When enough bytes have been processed for a valid amqp value, the on_value_decoded passed in amqpvalue_decoder_create shall be called.] */\n                    /* Codes_SRS_AMQPVALUE_01_324: [The decoded amqp value shall be passed to on_value_decoded.] */\n                    /* Codes_SRS_AMQPVALUE_01_325: [Also the context stored in amqpvalue_decoder_create shall be passed to the on_value_decoded callback.] */\n                    internal_decoder_data->on_value_decoded(internal_decoder_data->on_value_decoded_context, internal_decoder_data->decode_to_value);\n                    result = 0;\n                    break;\n                }\n                /* Codes_SRS_AMQPVALUE_01_289: [\\<encoding name=\"ieee-754\" code=\"0x72\" category=\"fixed\" width=\"4\" label=\"IEEE 754-2008 binary32\"/>] */\n                case 0x72:\n                {\n                    *((uint32_t*)&internal_decoder_data->decode_to_value->value.float_value) += ((uint32_t)buffer[0]) << ((3 - internal_decoder_data->bytes_decoded) * 8);\n                    internal_decoder_data->bytes_decoded++;\n                    buffer++;\n                    size--;\n\n                    /* Codes_SRS_AMQPVALUE_01_327: [If not enough bytes have accumulated to decode a value, the on_value_decoded shall not be called.] */\n                    if (internal_decoder_data->bytes_decoded == 4)\n                    {\n                        internal_decoder_data->decoder_state = DECODER_STATE_CONSTRUCTOR;\n\n                        /* Codes_SRS_AMQPVALUE_01_323: [When enough bytes have been processed for a valid amqp value, the on_value_decoded passed in amqpvalue_decoder_create shall be called.] */\n                        /* Codes_SRS_AMQPVALUE_01_324: [The decoded amqp value shall be passed to on_value_decoded.] */\n                        /* Codes_SRS_AMQPVALUE_01_325: [Also the context stored in amqpvalue_decoder_create shall be passed to the on_value_decoded callback.] */\n                        internal_decoder_data->on_value_decoded(internal_decoder_data->on_value_decoded_context, internal_decoder_data->decode_to_value);\n                    }\n\n                    result = 0;\n                    break;\n                }\n                /* Codes_SRS_AMQPVALUE_01_290: [\\<encoding name=\"ieee-754\" code=\"0x82\" category=\"fixed\" width=\"8\" label=\"IEEE 754-2008 binary64\"/>]*/\n                case 0x82:\n                {\n                    *((uint64_t*)&internal_decoder_data->decode_to_value->value.double_value) += ((uint64_t)buffer[0]) << ((7 - internal_decoder_data->bytes_decoded) * 8);\n                    internal_decoder_data->bytes_decoded++;\n                    buffer++;\n                    size--;\n\n                    /* Codes_SRS_AMQPVALUE_01_327: [If not enough bytes have accumulated to decode a value, the on_value_decoded shall not be called.] */\n                    if (internal_decoder_data->bytes_decoded == 8)\n                    {\n                        internal_decoder_data->decoder_state = DECODER_STATE_CONSTRUCTOR;\n\n                        /* Codes_SRS_AMQPVALUE_01_323: [When enough bytes have been processed for a valid amqp value, the on_value_decoded passed in amqpvalue_decoder_create shall be called.] */\n                        /* Codes_SRS_AMQPVALUE_01_324: [The decoded amqp value shall be passed to on_value_decoded.] */\n                        /* Codes_SRS_AMQPVALUE_01_325: [Also the context stored in amqpvalue_decoder_create shall be passed to the on_value_decoded callback.] */\n                        internal_decoder_data->on_value_decoded(internal_decoder_data->on_value_decoded_context, internal_decoder_data->decode_to_value);\n                    }\n\n                    result = 0;\n                    break;\n                }\n                /* Codes_SRS_AMQPVALUE_01_369: [<encoding name=\"ms64\" code=\"0x83\" category=\"fixed\" width=\"8\" label=\"64-bit two's-complement integer representing milliseconds since the unix epoch\"/>] */\n                case 0x83:\n                {\n                    internal_decoder_data->decode_to_value->value.timestamp_value = (int64_t)((uint64_t)internal_decoder_data->decode_to_value->value.timestamp_value + (((uint64_t)buffer[0]) << ((7 - internal_decoder_data->bytes_decoded) * 8)));\n                    internal_decoder_data->bytes_decoded++;\n                    buffer++;\n                    size--;\n\n                    /* Codes_SRS_AMQPVALUE_01_327: [If not enough bytes have accumulated to decode a value, the on_value_decoded shall not be called.] */\n                    if (internal_decoder_data->bytes_decoded == 8)\n                    {\n                        internal_decoder_data->decoder_state = DECODER_STATE_CONSTRUCTOR;\n\n                        /* Codes_SRS_AMQPVALUE_01_323: [When enough bytes have been processed for a valid amqp value, the on_value_decoded passed in amqpvalue_decoder_create shall be called.] */\n                        /* Codes_SRS_AMQPVALUE_01_324: [The decoded amqp value shall be passed to on_value_decoded.] */\n                        /* Codes_SRS_AMQPVALUE_01_325: [Also the context stored in amqpvalue_decoder_create shall be passed to the on_value_decoded callback.] */\n                        internal_decoder_data->on_value_decoded(internal_decoder_data->on_value_decoded_context, internal_decoder_data->decode_to_value);\n                    }\n\n                    result = 0;\n                    break;\n                }\n                /* Codes_SRS_AMQPVALUE_01_369: [<encoding name=\"ms64\" code=\"0x83\" category=\"fixed\" width=\"8\" label=\"64-bit two's-complement integer representing milliseconds since the unix epoch\"/>] */\n                case 0x98:\n                {\n                    size_t to_copy = 16 - internal_decoder_data->bytes_decoded;\n                    if (to_copy > size)\n                    {\n                        to_copy = size;\n                    }\n\n                    (void)memcpy(&internal_decoder_data->decode_to_value->value.uuid_value[internal_decoder_data->bytes_decoded], buffer, to_copy);\n                    internal_decoder_data->bytes_decoded += to_copy;\n                    buffer += to_copy;\n                    size -= to_copy;\n\n                    /* Codes_SRS_AMQPVALUE_01_327: [If not enough bytes have accumulated to decode a value, the on_value_decoded shall not be called.] */\n                    if (internal_decoder_data->bytes_decoded == 16)\n                    {\n                        internal_decoder_data->decoder_state = DECODER_STATE_CONSTRUCTOR;\n\n                        /* Codes_SRS_AMQPVALUE_01_323: [When enough bytes have been processed for a valid amqp value, the on_value_decoded passed in amqpvalue_decoder_create shall be called.] */\n                        /* Codes_SRS_AMQPVALUE_01_324: [The decoded amqp value shall be passed to on_value_decoded.] */\n                        /* Codes_SRS_AMQPVALUE_01_325: [Also the context stored in amqpvalue_decoder_create shall be passed to the on_value_decoded callback.] */\n                        internal_decoder_data->on_value_decoded(internal_decoder_data->on_value_decoded_context, internal_decoder_data->decode_to_value);\n                    }\n\n                    result = 0;\n                    break;\n                }\n                /* Codes_SRS_AMQPVALUE_01_373: [<encoding name=\"vbin8\" code=\"0xa0\" category=\"variable\" width=\"1\" label=\"up to 2^8 - 1 octets of binary data\"/>] */\n                case 0xA0:\n                {\n                    if (internal_decoder_data->bytes_decoded == 0)\n                    {\n                        internal_decoder_data->decode_to_value->value.binary_value.length = buffer[0];\n                        internal_decoder_data->bytes_decoded++;\n                        buffer++;\n                        size--;\n\n                        if (internal_decoder_data->decode_to_value->value.binary_value.length == 0)\n                        {\n                            internal_decoder_data->decode_to_value->value.binary_value.bytes = NULL;\n\n                            /* Codes_SRS_AMQPVALUE_01_323: [When enough bytes have been processed for a valid amqp value, the on_value_decoded passed in amqpvalue_decoder_create shall be called.] */\n                            /* Codes_SRS_AMQPVALUE_01_324: [The decoded amqp value shall be passed to on_value_decoded.] */\n                            /* Codes_SRS_AMQPVALUE_01_325: [Also the context stored in amqpvalue_decoder_create shall be passed to the on_value_decoded callback.] */\n                            internal_decoder_data->on_value_decoded(internal_decoder_data->on_value_decoded_context, internal_decoder_data->decode_to_value);\n                            result = 0;\n                        }\n                        else\n                        {\n                            internal_decoder_data->decode_to_value->value.binary_value.bytes = (unsigned char*)malloc(internal_decoder_data->decode_to_value->value.binary_value.length);\n                            if (internal_decoder_data->decode_to_value->value.binary_value.bytes == NULL)\n                            {\n                                /* Codes_SRS_AMQPVALUE_01_326: [If any allocation failure occurs during decoding, amqpvalue_decode_bytes shall fail and return a non-zero value.] */\n                                LogError(\"Cannot allocate memory for decoded binary value\");\n                                internal_decoder_data->decoder_state = DECODER_STATE_ERROR;\n                                result = MU_FAILURE;\n                            }\n                            else\n                            {\n                                result = 0;\n                            }\n                        }\n                    }\n                    else\n                    {\n                        size_t to_copy = internal_decoder_data->decode_to_value->value.binary_value.length - (internal_decoder_data->bytes_decoded - 1);\n                        if (to_copy > size)\n                        {\n                            to_copy = size;\n                        }\n\n                        (void)memcpy((unsigned char*)(internal_decoder_data->decode_to_value->value.binary_value.bytes) + (internal_decoder_data->bytes_decoded - 1), buffer, to_copy);\n\n                        buffer += to_copy;\n                        size -= to_copy;\n                        internal_decoder_data->bytes_decoded += to_copy;\n\n                        if (internal_decoder_data->bytes_decoded == (size_t)internal_decoder_data->decode_to_value->value.binary_value.length + 1)\n                        {\n                            internal_decoder_data->decoder_state = DECODER_STATE_CONSTRUCTOR;\n\n                            /* Codes_SRS_AMQPVALUE_01_323: [When enough bytes have been processed for a valid amqp value, the on_value_decoded passed in amqpvalue_decoder_create shall be called.] */\n                            /* Codes_SRS_AMQPVALUE_01_324: [The decoded amqp value shall be passed to on_value_decoded.] */\n                            /* Codes_SRS_AMQPVALUE_01_325: [Also the context stored in amqpvalue_decoder_create shall be passed to the on_value_decoded callback.] */\n                            internal_decoder_data->on_value_decoded(internal_decoder_data->on_value_decoded_context, internal_decoder_data->decode_to_value);\n                        }\n\n                        result = 0;\n                    }\n\n                    break;\n                }\n                /* Codes_SRS_AMQPVALUE_01_374: [<encoding name=\"vbin32\" code=\"0xb0\" category=\"variable\" width=\"4\" label=\"up to 2^32 - 1 octets of binary data\"/>] */\n                case 0xB0:\n                {\n                    if (internal_decoder_data->bytes_decoded < 4)\n                    {\n                        internal_decoder_data->decode_to_value->value.binary_value.length += buffer[0] << ((3 - internal_decoder_data->bytes_decoded) * 8);\n                        internal_decoder_data->bytes_decoded++;\n                        buffer++;\n                        size--;\n\n                        if (internal_decoder_data->bytes_decoded == 4)\n                        {\n                            if (internal_decoder_data->decode_to_value->value.binary_value.length == 0)\n                            {\n                                internal_decoder_data->decode_to_value->value.binary_value.bytes = NULL;\n\n                                /* Codes_SRS_AMQPVALUE_01_323: [When enough bytes have been processed for a valid amqp value, the on_value_decoded passed in amqpvalue_decoder_create shall be called.] */\n                                /* Codes_SRS_AMQPVALUE_01_324: [The decoded amqp value shall be passed to on_value_decoded.] */\n                                /* Codes_SRS_AMQPVALUE_01_325: [Also the context stored in amqpvalue_decoder_create shall be passed to the on_value_decoded callback.] */\n                                internal_decoder_data->on_value_decoded(internal_decoder_data->on_value_decoded_context, internal_decoder_data->decode_to_value);\n                                result = 0;\n                            }\n                            else\n                            {\n                                internal_decoder_data->decode_to_value->value.binary_value.bytes = (unsigned char*)malloc((size_t)internal_decoder_data->decode_to_value->value.binary_value.length + 1);\n                                if (internal_decoder_data->decode_to_value->value.binary_value.bytes == NULL)\n                                {\n                                    /* Codes_SRS_AMQPVALUE_01_326: [If any allocation failure occurs during decoding, amqpvalue_decode_bytes shall fail and return a non-zero value.] */\n                                    internal_decoder_data->decoder_state = DECODER_STATE_ERROR;\n                                    LogError(\"Cannot allocate memory for decoded binary value\");\n                                    result = MU_FAILURE;\n                                }\n                                else\n                                {\n                                    result = 0;\n                                }\n                            }\n                        }\n                        else\n                        {\n                            result = 0;\n                        }\n                    }\n                    else\n                    {\n                        size_t to_copy = internal_decoder_data->decode_to_value->value.binary_value.length - (internal_decoder_data->bytes_decoded - 4);\n                        if (to_copy > size)\n                        {\n                            to_copy = size;\n                        }\n\n                        (void)memcpy((unsigned char*)(internal_decoder_data->decode_to_value->value.binary_value.bytes) + (internal_decoder_data->bytes_decoded - 4), buffer, to_copy);\n                        buffer += to_copy;\n                        size -= to_copy;\n                        internal_decoder_data->bytes_decoded += to_copy;\n\n                        if (internal_decoder_data->bytes_decoded == (size_t)internal_decoder_data->decode_to_value->value.binary_value.length + 4)\n                        {\n                            internal_decoder_data->decoder_state = DECODER_STATE_CONSTRUCTOR;\n                            internal_decoder_data->on_value_decoded(internal_decoder_data->on_value_decoded_context, internal_decoder_data->decode_to_value);\n                        }\n\n                        result = 0;\n                    }\n\n                    break;\n                }\n                /* Codes_SRS_AMQPVALUE_01_376: [<encoding name=\"str8-utf8\" code=\"0xa1\" category=\"variable\" width=\"1\" label=\"up to 2^8 - 1 octets worth of UTF-8 Unicode (with no byte order mark)\"/>] */\n                case 0xA1:\n                {\n                    if (internal_decoder_data->bytes_decoded == 0)\n                    {\n                        internal_decoder_data->decode_value_state.string_value_state.length = buffer[0];\n                        internal_decoder_data->bytes_decoded++;\n                        buffer++;\n                        size--;\n\n                        internal_decoder_data->decode_to_value->value.string_value.chars = (char*)malloc((size_t)internal_decoder_data->decode_value_state.string_value_state.length + 1);\n                        if (internal_decoder_data->decode_to_value->value.string_value.chars == NULL)\n                        {\n                            /* Codes_SRS_AMQPVALUE_01_326: [If any allocation failure occurs during decoding, amqpvalue_decode_bytes shall fail and return a non-zero value.] */\n                            internal_decoder_data->decoder_state = DECODER_STATE_ERROR;\n                            LogError(\"Could not allocate memory for decoded string value\");\n                            result = MU_FAILURE;\n                        }\n                        else\n                        {\n                            if (internal_decoder_data->decode_value_state.string_value_state.length == 0)\n                            {\n                                internal_decoder_data->decode_to_value->value.string_value.chars[0] = '\\0';\n\n                                /* Codes_SRS_AMQPVALUE_01_323: [When enough bytes have been processed for a valid amqp value, the on_value_decoded passed in amqpvalue_decoder_create shall be called.] */\n                                /* Codes_SRS_AMQPVALUE_01_324: [The decoded amqp value shall be passed to on_value_decoded.] */\n                                /* Codes_SRS_AMQPVALUE_01_325: [Also the context stored in amqpvalue_decoder_create shall be passed to the on_value_decoded callback.] */\n                                internal_decoder_data->on_value_decoded(internal_decoder_data->on_value_decoded_context, internal_decoder_data->decode_to_value);\n                            }\n\n                            result = 0;\n                        }\n                    }\n                    else\n                    {\n                        size_t to_copy = internal_decoder_data->decode_value_state.string_value_state.length - (internal_decoder_data->bytes_decoded - 1);\n                        if (to_copy > size)\n                        {\n                            to_copy = size;\n                        }\n\n                        (void)memcpy(internal_decoder_data->decode_to_value->value.string_value.chars + (internal_decoder_data->bytes_decoded - 1), buffer, to_copy);\n                        buffer += to_copy;\n                        size -= to_copy;\n                        internal_decoder_data->bytes_decoded += to_copy;\n\n                        if (internal_decoder_data->bytes_decoded == (size_t)internal_decoder_data->decode_value_state.string_value_state.length + 1)\n                        {\n                            internal_decoder_data->decode_to_value->value.string_value.chars[internal_decoder_data->decode_value_state.string_value_state.length] = 0;\n                            internal_decoder_data->decoder_state = DECODER_STATE_CONSTRUCTOR;\n\n                            /* Codes_SRS_AMQPVALUE_01_323: [When enough bytes have been processed for a valid amqp value, the on_value_decoded passed in amqpvalue_decoder_create shall be called.] */\n                            /* Codes_SRS_AMQPVALUE_01_324: [The decoded amqp value shall be passed to on_value_decoded.] */\n                            /* Codes_SRS_AMQPVALUE_01_325: [Also the context stored in amqpvalue_decoder_create shall be passed to the on_value_decoded callback.] */\n                            internal_decoder_data->on_value_decoded(internal_decoder_data->on_value_decoded_context, internal_decoder_data->decode_to_value);\n                        }\n\n                        result = 0;\n                    }\n                    break;\n                }\n                /* Codes_SRS_AMQPVALUE_01_377: [<encoding name=\"str32-utf8\" code=\"0xb1\" category=\"variable\" width=\"4\" label=\"up to 2^32 - 1 octets worth of UTF-8 Unicode (with no byte order mark)\"/>] */\n                case 0xB1:\n                {\n                    if (internal_decoder_data->bytes_decoded < 4)\n                    {\n                        internal_decoder_data->decode_value_state.string_value_state.length += buffer[0] << ((3 - internal_decoder_data->bytes_decoded) * 8);\n                        internal_decoder_data->bytes_decoded++;\n                        buffer++;\n                        size--;\n\n                        if (internal_decoder_data->bytes_decoded == 4)\n                        {\n                            internal_decoder_data->decode_to_value->value.string_value.chars = (char*)malloc((size_t)internal_decoder_data->decode_value_state.string_value_state.length + 1);\n                            if (internal_decoder_data->decode_to_value->value.string_value.chars == NULL)\n                            {\n                                /* Codes_SRS_AMQPVALUE_01_326: [If any allocation failure occurs during decoding, amqpvalue_decode_bytes shall fail and return a non-zero value.] */\n                                internal_decoder_data->decoder_state = DECODER_STATE_ERROR;\n                                LogError(\"Could not allocate memory for decoded string value\");\n                                result = MU_FAILURE;\n                            }\n                            else\n                            {\n                                if (internal_decoder_data->decode_value_state.string_value_state.length == 0)\n                                {\n                                    internal_decoder_data->decode_to_value->value.string_value.chars[0] = '\\0';\n\n                                    /* Codes_SRS_AMQPVALUE_01_323: [When enough bytes have been processed for a valid amqp value, the on_value_decoded passed in amqpvalue_decoder_create shall be called.] */\n                                    /* Codes_SRS_AMQPVALUE_01_324: [The decoded amqp value shall be passed to on_value_decoded.] */\n                                    /* Codes_SRS_AMQPVALUE_01_325: [Also the context stored in amqpvalue_decoder_create shall be passed to the on_value_decoded callback.] */\n                                    internal_decoder_data->on_value_decoded(internal_decoder_data->on_value_decoded_context, internal_decoder_data->decode_to_value);\n                                }\n\n                                result = 0;\n                            }\n                        }\n                        else\n                        {\n                            result = 0;\n                        }\n                    }\n                    else\n                    {\n                        size_t to_copy = internal_decoder_data->decode_value_state.string_value_state.length - (internal_decoder_data->bytes_decoded - 4);\n                        if (to_copy > size)\n                        {\n                            to_copy = size;\n                        }\n\n                        (void)memcpy(internal_decoder_data->decode_to_value->value.string_value.chars + (internal_decoder_data->bytes_decoded - 4), buffer, to_copy);\n                        buffer += to_copy;\n                        size -= to_copy;\n                        internal_decoder_data->bytes_decoded += to_copy;\n\n                        if (internal_decoder_data->bytes_decoded == (size_t)internal_decoder_data->decode_value_state.string_value_state.length + 4)\n                        {\n                            internal_decoder_data->decode_to_value->value.string_value.chars[internal_decoder_data->decode_value_state.string_value_state.length] = '\\0';\n                            internal_decoder_data->decoder_state = DECODER_STATE_CONSTRUCTOR;\n\n                            /* Codes_SRS_AMQPVALUE_01_323: [When enough bytes have been processed for a valid amqp value, the on_value_decoded passed in amqpvalue_decoder_create shall be called.] */\n                            /* Codes_SRS_AMQPVALUE_01_324: [The decoded amqp value shall be passed to on_value_decoded.] */\n                            /* Codes_SRS_AMQPVALUE_01_325: [Also the context stored in amqpvalue_decoder_create shall be passed to the on_value_decoded callback.] */\n                            internal_decoder_data->on_value_decoded(internal_decoder_data->on_value_decoded_context, internal_decoder_data->decode_to_value);\n                        }\n\n                        result = 0;\n                    }\n                    break;\n                }\n                /* Codes_SRS_AMQPVALUE_01_379: [<encoding name=\"sym8\" code=\"0xa3\" category=\"variable\" width=\"1\" label=\"up to 2^8 - 1 seven bit ASCII characters representing a symbolic value\"/>] */\n                case 0xA3:\n                {\n                    if (internal_decoder_data->bytes_decoded == 0)\n                    {\n                        internal_decoder_data->decode_value_state.symbol_value_state.length = buffer[0];\n                        internal_decoder_data->bytes_decoded++;\n                        buffer++;\n                        size--;\n\n                        internal_decoder_data->decode_to_value->value.symbol_value.chars = (char*)malloc((size_t)internal_decoder_data->decode_value_state.symbol_value_state.length + 1);\n                        if (internal_decoder_data->decode_to_value->value.symbol_value.chars == NULL)\n                        {\n                            /* Codes_SRS_AMQPVALUE_01_326: [If any allocation failure occurs during decoding, amqpvalue_decode_bytes shall fail and return a non-zero value.] */\n                            internal_decoder_data->decoder_state = DECODER_STATE_ERROR;\n                            LogError(\"Could not allocate memory for decoded symbol value\");\n                            result = MU_FAILURE;\n                        }\n                        else\n                        {\n                            if (internal_decoder_data->decode_value_state.symbol_value_state.length == 0)\n                            {\n                                internal_decoder_data->decode_to_value->value.symbol_value.chars[0] = '\\0';\n\n                                /* Codes_SRS_AMQPVALUE_01_323: [When enough bytes have been processed for a valid amqp value, the on_value_decoded passed in amqpvalue_decoder_create shall be called.] */\n                                /* Codes_SRS_AMQPVALUE_01_324: [The decoded amqp value shall be passed to on_value_decoded.] */\n                                /* Codes_SRS_AMQPVALUE_01_325: [Also the context stored in amqpvalue_decoder_create shall be passed to the on_value_decoded callback.] */\n                                internal_decoder_data->on_value_decoded(internal_decoder_data->on_value_decoded_context, internal_decoder_data->decode_to_value);\n                            }\n\n                            result = 0;\n                        }\n                    }\n                    else\n                    {\n                        size_t to_copy = internal_decoder_data->decode_value_state.symbol_value_state.length - (internal_decoder_data->bytes_decoded - 1);\n                        if (to_copy > size)\n                        {\n                            to_copy = size;\n                        }\n\n                        (void)memcpy(internal_decoder_data->decode_to_value->value.symbol_value.chars + (internal_decoder_data->bytes_decoded - 1), buffer, to_copy);\n                        buffer += to_copy;\n                        size -= to_copy;\n                        internal_decoder_data->bytes_decoded += to_copy;\n\n                        if (internal_decoder_data->bytes_decoded == (size_t)internal_decoder_data->decode_value_state.symbol_value_state.length + 1)\n                        {\n                            internal_decoder_data->decode_to_value->value.symbol_value.chars[internal_decoder_data->decode_value_state.symbol_value_state.length] = 0;\n                            internal_decoder_data->decoder_state = DECODER_STATE_CONSTRUCTOR;\n\n                            /* Codes_SRS_AMQPVALUE_01_323: [When enough bytes have been processed for a valid amqp value, the on_value_decoded passed in amqpvalue_decoder_create shall be called.] */\n                            /* Codes_SRS_AMQPVALUE_01_324: [The decoded amqp value shall be passed to on_value_decoded.] */\n                            /* Codes_SRS_AMQPVALUE_01_325: [Also the context stored in amqpvalue_decoder_create shall be passed to the on_value_decoded callback.] */\n                            internal_decoder_data->on_value_decoded(internal_decoder_data->on_value_decoded_context, internal_decoder_data->decode_to_value);\n                        }\n\n                        result = 0;\n                    }\n                    break;\n                }\n                /* Codes_SRS_AMQPVALUE_01_380: [<encoding name=\"sym32\" code=\"0xb3\" category=\"variable\" width=\"4\" label=\"up to 2^32 - 1 seven bit ASCII characters representing a symbolic value\"/>] */\n                case 0xB3:\n                {\n                    if (internal_decoder_data->bytes_decoded < 4)\n                    {\n                        internal_decoder_data->decode_value_state.symbol_value_state.length += buffer[0] << ((3 - internal_decoder_data->bytes_decoded) * 8);\n                        internal_decoder_data->bytes_decoded++;\n                        buffer++;\n                        size--;\n\n                        if (internal_decoder_data->bytes_decoded == 4)\n                        {\n                            internal_decoder_data->decode_to_value->value.symbol_value.chars = (char*)malloc((size_t)internal_decoder_data->decode_value_state.symbol_value_state.length + 1);\n                            if (internal_decoder_data->decode_to_value->value.symbol_value.chars == NULL)\n                            {\n                                /* Codes_SRS_AMQPVALUE_01_326: [If any allocation failure occurs during decoding, amqpvalue_decode_bytes shall fail and return a non-zero value.] */\n                                internal_decoder_data->decoder_state = DECODER_STATE_ERROR;\n                                LogError(\"Could not allocate memory for decoded symbol value\");\n                                result = MU_FAILURE;\n                            }\n                            else\n                            {\n                                if (internal_decoder_data->decode_value_state.symbol_value_state.length == 0)\n                                {\n                                    internal_decoder_data->decode_to_value->value.symbol_value.chars[0] = '\\0';\n\n                                    /* Codes_SRS_AMQPVALUE_01_323: [When enough bytes have been processed for a valid amqp value, the on_value_decoded passed in amqpvalue_decoder_create shall be called.] */\n                                    /* Codes_SRS_AMQPVALUE_01_324: [The decoded amqp value shall be passed to on_value_decoded.] */\n                                    /* Codes_SRS_AMQPVALUE_01_325: [Also the context stored in amqpvalue_decoder_create shall be passed to the on_value_decoded callback.] */\n                                    internal_decoder_data->on_value_decoded(internal_decoder_data->on_value_decoded_context, internal_decoder_data->decode_to_value);\n                                }\n\n                                result = 0;\n                            }\n                        }\n                        else\n                        {\n                            result = 0;\n                        }\n                    }\n                    else\n                    {\n                        size_t to_copy = internal_decoder_data->decode_value_state.symbol_value_state.length - (internal_decoder_data->bytes_decoded - 4);\n                        if (to_copy > size)\n                        {\n                            to_copy = size;\n                        }\n\n                        (void)memcpy(internal_decoder_data->decode_to_value->value.symbol_value.chars + (internal_decoder_data->bytes_decoded - 4), buffer, to_copy);\n                        buffer += to_copy;\n                        size -= to_copy;\n                        internal_decoder_data->bytes_decoded += to_copy;\n\n                        if (internal_decoder_data->bytes_decoded == (size_t)internal_decoder_data->decode_value_state.symbol_value_state.length + 4)\n                        {\n                            internal_decoder_data->decode_to_value->value.symbol_value.chars[internal_decoder_data->decode_value_state.symbol_value_state.length] = '\\0';\n                            internal_decoder_data->decoder_state = DECODER_STATE_CONSTRUCTOR;\n\n                            /* Codes_SRS_AMQPVALUE_01_323: [When enough bytes have been processed for a valid amqp value, the on_value_decoded passed in amqpvalue_decoder_create shall be called.] */\n                            /* Codes_SRS_AMQPVALUE_01_324: [The decoded amqp value shall be passed to on_value_decoded.] */\n                            /* Codes_SRS_AMQPVALUE_01_325: [Also the context stored in amqpvalue_decoder_create shall be passed to the on_value_decoded callback.] */\n                            internal_decoder_data->on_value_decoded(internal_decoder_data->on_value_decoded_context, internal_decoder_data->decode_to_value);\n                        }\n\n                        result = 0;\n                    }\n                    break;\n                }\n                /* Codes_SRS_AMQPVALUE_01_385: [<encoding name=\"list8\" code=\"0xc0\" category=\"compound\" width=\"1\" label=\"up to 2^8 - 1 list elements with total size less than 2^8 octets\"/>] */\n                case 0xC0:\n                /* Codes_SRS_AMQPVALUE_01_386: [<encoding name=\"list32\" code=\"0xd0\" category=\"compound\" width=\"4\" label=\"up to 2^32 - 1 list elements with total size less than 2^32 octets\"/>] */\n                case 0xD0:\n                {\n                    DECODE_LIST_STEP step = internal_decoder_data->decode_value_state.list_value_state.list_value_state;\n\n                    switch (step)\n                    {\n                    default:\n                        LogError(\"Invalid step in decoding list value: %d\", step);\n                        result = MU_FAILURE;\n                        break;\n\n                    case DECODE_LIST_STEP_SIZE:\n                        internal_decoder_data->bytes_decoded++;\n                        buffer++;\n                        size--;\n\n                        if (internal_decoder_data->constructor_byte == 0xC0)\n                        {\n                            internal_decoder_data->decode_value_state.list_value_state.list_value_state = DECODE_LIST_STEP_COUNT;\n                            internal_decoder_data->bytes_decoded = 0;\n                            internal_decoder_data->decode_to_value->value.list_value.count = 0;\n                            result = 0;\n                        }\n                        else\n                        {\n                            if (internal_decoder_data->bytes_decoded == 4)\n                            {\n                                internal_decoder_data->decode_value_state.list_value_state.list_value_state = DECODE_LIST_STEP_COUNT;\n                                internal_decoder_data->bytes_decoded = 0;\n                                internal_decoder_data->decode_to_value->value.list_value.count = 0;\n                            }\n\n                            result = 0;\n                        }\n\n                        break;\n\n                    case DECODE_LIST_STEP_COUNT:\n                        if (internal_decoder_data->constructor_byte == 0xC0)\n                        {\n                            internal_decoder_data->decode_to_value->value.list_value.count = buffer[0];\n                        }\n                        else\n                        {\n                            internal_decoder_data->decode_to_value->value.list_value.count += buffer[0] << ((3 - internal_decoder_data->bytes_decoded) * 8);\n                        }\n\n                        internal_decoder_data->bytes_decoded++;\n                        buffer++;\n                        size--;\n                        if (internal_decoder_data->decode_to_value->value.list_value.count > MAX_AMQPVALUE_ITEM_COUNT)\n                        {\n                            LogError(\"AMQP list item count exceeded MAX_AMQPVALUE_ITEM_COUNT\");\n                            result = MU_FAILURE;\n                            size = 0;\n                            break;\n                        }\n\n                        if (internal_decoder_data->constructor_byte == 0xC0)\n                        {\n                            if (internal_decoder_data->decode_to_value->value.list_value.count == 0)\n                            {\n                                internal_decoder_data->decoder_state = DECODER_STATE_CONSTRUCTOR;\n\n                                /* Codes_SRS_AMQPVALUE_01_323: [When enough bytes have been processed for a valid amqp value, the on_value_decoded passed in amqpvalue_decoder_create shall be called.] */\n                                /* Codes_SRS_AMQPVALUE_01_324: [The decoded amqp value shall be passed to on_value_decoded.] */\n                                /* Codes_SRS_AMQPVALUE_01_325: [Also the context stored in amqpvalue_decoder_create shall be passed to the on_value_decoded callback.] */\n                                internal_decoder_data->on_value_decoded(internal_decoder_data->on_value_decoded_context, internal_decoder_data->decode_to_value);\n                                result = 0;\n                            }\n                            else\n                            {\n                                uint32_t i;\n                                internal_decoder_data->decode_to_value->value.list_value.items = (AMQP_VALUE*)calloc(1, (sizeof(AMQP_VALUE) * internal_decoder_data->decode_to_value->value.list_value.count));\n                                if (internal_decoder_data->decode_to_value->value.list_value.items == NULL)\n                                {\n                                    LogError(\"Could not allocate memory for decoded list value\");\n                                    result = MU_FAILURE;\n                                }\n                                else\n                                {\n                                    for (i = 0; i < internal_decoder_data->decode_to_value->value.list_value.count; i++)\n                                    {\n                                        internal_decoder_data->decode_to_value->value.list_value.items[i] = NULL;\n                                    }\n\n                                    internal_decoder_data->decode_value_state.list_value_state.list_value_state = DECODE_LIST_STEP_ITEMS;\n                                    internal_decoder_data->bytes_decoded = 0;\n                                    internal_decoder_data->inner_decoder = NULL;\n                                    internal_decoder_data->decode_value_state.list_value_state.item = 0;\n                                    result = 0;\n                                }\n                            }\n                        }\n                        else\n                        {\n                            if (internal_decoder_data->bytes_decoded == 4)\n                            {\n                                if (internal_decoder_data->decode_to_value->value.list_value.count == 0)\n                                {\n                                    internal_decoder_data->decoder_state = DECODER_STATE_CONSTRUCTOR;\n\n                                    /* Codes_SRS_AMQPVALUE_01_323: [When enough bytes have been processed for a valid amqp value, the on_value_decoded passed in amqpvalue_decoder_create shall be called.] */\n                                    /* Codes_SRS_AMQPVALUE_01_324: [The decoded amqp value shall be passed to on_value_decoded.] */\n                                    /* Codes_SRS_AMQPVALUE_01_325: [Also the context stored in amqpvalue_decoder_create shall be passed to the on_value_decoded callback.] */\n                                    internal_decoder_data->on_value_decoded(internal_decoder_data->on_value_decoded_context, internal_decoder_data->decode_to_value);\n                                    result = 0;\n                                }\n                                else\n                                {\n                                    uint32_t i;\n                                    size_t calloc_size = (sizeof(AMQP_VALUE) * internal_decoder_data->decode_to_value->value.list_value.count);\n                                    // bug 8819364: [FuzzAMQP] AddressSanitizer: allocator is out of memory trying to allocate 0x7fff80070 bytes\n                                    if (calloc_size < MAX_AMQPVALUE_MALLOC_SIZE_BYTES)\n                                    {\n                                        internal_decoder_data->decode_to_value->value.list_value.items = (AMQP_VALUE*)calloc(1, calloc_size);\n                                    }\n                                    else\n                                    {\n                                        LogError(\"Large memory allocation exceeded MAX_AMQPVALUE_MALLOC_SIZE_BYTES\");\n                                        internal_decoder_data->decode_to_value->value.list_value.items = NULL;\n                                    }\n\n                                    if (internal_decoder_data->decode_to_value->value.list_value.items == NULL)\n                                    {\n                                        LogError(\"Could not allocate memory for decoded list value\");\n                                        result = MU_FAILURE;\n                                    }\n                                    else\n                                    {\n                                        for (i = 0; i < internal_decoder_data->decode_to_value->value.list_value.count; i++)\n                                        {\n                                            internal_decoder_data->decode_to_value->value.list_value.items[i] = NULL;\n                                        }\n\n                                        internal_decoder_data->decode_value_state.list_value_state.list_value_state = DECODE_LIST_STEP_ITEMS;\n                                        internal_decoder_data->bytes_decoded = 0;\n                                        internal_decoder_data->inner_decoder = NULL;\n                                        internal_decoder_data->decode_value_state.list_value_state.item = 0;\n                                        result = 0;\n                                    }\n                                }\n                            }\n                            else\n                            {\n                                result = 0;\n                            }\n                        }\n                        break;\n\n                    case DECODE_LIST_STEP_ITEMS:\n                    {\n                        size_t inner_used_bytes;\n\n                        if (internal_decoder_data->bytes_decoded == 0)\n                        {\n                            AMQP_VALUE_DATA* list_item = (AMQP_VALUE_DATA*)REFCOUNT_TYPE_CREATE(AMQP_VALUE_DATA);\n                            if (list_item == NULL)\n                            {\n                                internal_decoder_data->decoder_state = DECODER_STATE_ERROR;\n                                result = MU_FAILURE;\n                                break;\n                            }\n                            else\n                            {\n                                list_item->type = AMQP_TYPE_UNKNOWN;\n                                internal_decoder_data->decode_to_value->value.list_value.items[internal_decoder_data->decode_value_state.list_value_state.item] = list_item;\n                                internal_decoder_data->inner_decoder = internal_decoder_create(inner_decoder_callback, internal_decoder_data, list_item, true);\n                                if (internal_decoder_data->inner_decoder == NULL)\n                                {\n                                    LogError(\"Could not create inner decoder for list items\");\n                                    internal_decoder_data->decoder_state = DECODER_STATE_ERROR;\n                                }\n                            }\n                        }\n\n                        if (internal_decoder_data->inner_decoder == NULL)\n                        {\n                            LogError(\"NULL inner decoder. This should not happen under normal circumstances\");\n                            result = MU_FAILURE;\n                        }\n                        else if (internal_decoder_decode_bytes(internal_decoder_data->inner_decoder, buffer, size, &inner_used_bytes) != 0)\n                        {\n                            LogError(\"Decoding list items failed\");\n                            result = MU_FAILURE;\n                        }\n                        else\n                        {\n                            INTERNAL_DECODER_DATA* inner_decoder = (INTERNAL_DECODER_DATA*)internal_decoder_data->inner_decoder;\n                            internal_decoder_data->bytes_decoded += inner_used_bytes;\n                            buffer += inner_used_bytes;\n                            size -= inner_used_bytes;\n\n                            if (inner_decoder->decoder_state == DECODER_STATE_DONE)\n                            {\n                                internal_decoder_destroy(inner_decoder);\n                                internal_decoder_data->inner_decoder = NULL;\n                                internal_decoder_data->bytes_decoded = 0;\n\n                                internal_decoder_data->decode_value_state.list_value_state.item++;\n                                if (internal_decoder_data->decode_value_state.list_value_state.item == internal_decoder_data->decode_to_value->value.list_value.count)\n                                {\n                                    internal_decoder_data->decoder_state = DECODER_STATE_CONSTRUCTOR;\n\n                                    /* Codes_SRS_AMQPVALUE_01_323: [When enough bytes have been processed for a valid amqp value, the on_value_decoded passed in amqpvalue_decoder_create shall be called.] */\n                                    /* Codes_SRS_AMQPVALUE_01_324: [The decoded amqp value shall be passed to on_value_decoded.] */\n                                    /* Codes_SRS_AMQPVALUE_01_325: [Also the context stored in amqpvalue_decoder_create shall be passed to the on_value_decoded callback.] */\n                                    internal_decoder_data->on_value_decoded(internal_decoder_data->on_value_decoded_context, internal_decoder_data->decode_to_value);\n                                }\n\n                            }\n\n                            result = 0;\n                        }\n\n                        break;\n                    }\n                    }\n\n                    break;\n                }\n                case 0xC1:\n                case 0xD1:\n                {\n                    DECODE_MAP_STEP step = internal_decoder_data->decode_value_state.map_value_state.map_value_state;\n\n                    switch (step)\n                    {\n                    default:\n                        LogError(\"Invalid step in decoding map value: %d\", step);\n                        result = MU_FAILURE;\n                        break;\n\n                    case DECODE_MAP_STEP_SIZE:\n                        internal_decoder_data->bytes_decoded++;\n                        buffer++;\n                        size--;\n\n                        if (internal_decoder_data->constructor_byte == 0xC1)\n                        {\n                            internal_decoder_data->decode_value_state.map_value_state.map_value_state = DECODE_MAP_STEP_COUNT;\n                            internal_decoder_data->bytes_decoded = 0;\n                            internal_decoder_data->decode_to_value->value.map_value.pair_count = 0;\n                            result = 0;\n                        }\n                        else\n                        {\n                            if (internal_decoder_data->bytes_decoded == 4)\n                            {\n                                internal_decoder_data->decode_value_state.map_value_state.map_value_state = DECODE_MAP_STEP_COUNT;\n                                internal_decoder_data->bytes_decoded = 0;\n                                internal_decoder_data->decode_to_value->value.map_value.pair_count = 0;\n                            }\n                            result = 0;\n                        }\n\n                        break;\n\n                    case DECODE_MAP_STEP_COUNT:\n                        if (internal_decoder_data->constructor_byte == 0xC1)\n                        {\n                            internal_decoder_data->decode_to_value->value.map_value.pair_count = buffer[0];\n                        }\n                        else\n                        {\n                            internal_decoder_data->decode_to_value->value.map_value.pair_count += buffer[0] << ((3 - internal_decoder_data->bytes_decoded) * 8);\n                        }\n                        internal_decoder_data->bytes_decoded++;\n                        buffer++;\n                        size--;\n\n                        if (internal_decoder_data->constructor_byte == 0xC1)\n                        {\n                            if (internal_decoder_data->decode_to_value->value.map_value.pair_count == 0)\n                            {\n                                internal_decoder_data->decoder_state = DECODER_STATE_CONSTRUCTOR;\n\n                                internal_decoder_data->on_value_decoded(internal_decoder_data->on_value_decoded_context, internal_decoder_data->decode_to_value);\n                                result = 0;\n                            }\n                            else\n                            {\n                                uint32_t i;\n\n                                internal_decoder_data->decode_to_value->value.map_value.pair_count /= 2;\n\n                                internal_decoder_data->decode_to_value->value.map_value.pairs = (AMQP_MAP_KEY_VALUE_PAIR*)malloc(sizeof(AMQP_MAP_KEY_VALUE_PAIR) * ((size_t)internal_decoder_data->decode_to_value->value.map_value.pair_count * 2));\n                                if (internal_decoder_data->decode_to_value->value.map_value.pairs == NULL)\n                                {\n                                    LogError(\"Could not allocate memory for map value items\");\n                                    result = MU_FAILURE;\n                                }\n                                else\n                                {\n                                    for (i = 0; i < internal_decoder_data->decode_to_value->value.map_value.pair_count; i++)\n                                    {\n                                        internal_decoder_data->decode_to_value->value.map_value.pairs[i].key = NULL;\n                                        internal_decoder_data->decode_to_value->value.map_value.pairs[i].value = NULL;\n                                    }\n\n                                    internal_decoder_data->decode_value_state.map_value_state.map_value_state = DECODE_MAP_STEP_PAIRS;\n                                    internal_decoder_data->bytes_decoded = 0;\n                                    internal_decoder_data->inner_decoder = NULL;\n                                    internal_decoder_data->decode_value_state.map_value_state.item = 0;\n                                    result = 0;\n                                }\n                            }\n                        }\n                        else\n                        {\n                            if (internal_decoder_data->bytes_decoded == 4)\n                            {\n                                if (internal_decoder_data->decode_to_value->value.map_value.pair_count == 0)\n                                {\n                                    internal_decoder_data->decoder_state = DECODER_STATE_CONSTRUCTOR;\n\n                                    internal_decoder_data->on_value_decoded(internal_decoder_data->on_value_decoded_context, internal_decoder_data->decode_to_value);\n                                    result = 0;\n                                }\n                                else\n                                {\n                                    uint32_t i;\n\n                                    internal_decoder_data->decode_to_value->value.map_value.pair_count /= 2;\n                                    if (internal_decoder_data->decode_to_value->value.map_value.pair_count > MAX_AMQPVALUE_ITEM_COUNT)\n                                    {\n                                        LogError(\"AMQP list map count exceeded MAX_AMQPVALUE_ITEM_COUNT\");\n                                        result = MU_FAILURE;\n                                    }\n                                    else if ((internal_decoder_data->decode_to_value->value.map_value.pairs = \n                                        (AMQP_MAP_KEY_VALUE_PAIR*)malloc(sizeof(AMQP_MAP_KEY_VALUE_PAIR) * ((size_t)internal_decoder_data->decode_to_value->value.map_value.pair_count * 2)))\n                                        == NULL)\n                                    {\n                                        LogError(\"Could not allocate memory for map value items\");\n                                        result = MU_FAILURE;\n                                    }\n                                    else\n                                    {\n                                        for (i = 0; i < internal_decoder_data->decode_to_value->value.map_value.pair_count; i++)\n                                        {\n                                            internal_decoder_data->decode_to_value->value.map_value.pairs[i].key = NULL;\n                                            internal_decoder_data->decode_to_value->value.map_value.pairs[i].value = NULL;\n                                        }\n\n                                        internal_decoder_data->decode_value_state.map_value_state.map_value_state = DECODE_MAP_STEP_PAIRS;\n                                        internal_decoder_data->bytes_decoded = 0;\n                                        internal_decoder_data->inner_decoder = NULL;\n                                        internal_decoder_data->decode_value_state.map_value_state.item = 0;\n                                        result = 0;\n                                    }\n                                }\n                            }\n                            else\n                            {\n                                result = 0;\n                            }\n                        }\n                        break;\n\n                    case DECODE_MAP_STEP_PAIRS:\n                    {\n                        size_t inner_used_bytes;\n\n                        if (internal_decoder_data->bytes_decoded == 0)\n                        {\n                            if (internal_decoder_data->decode_value_state.map_value_state.item >= internal_decoder_data->decode_to_value->value.map_value.pair_count)\n                            {\n                                LogError(\"Map item index is out of range\");\n                                internal_decoder_data->decoder_state = DECODER_STATE_ERROR;\n                                result = MU_FAILURE;\n                                break;\n                            }\n\n                            AMQP_VALUE_DATA* map_item = (AMQP_VALUE_DATA*)REFCOUNT_TYPE_CREATE(AMQP_VALUE_DATA);\n                            if (map_item == NULL)\n                            {\n                                LogError(\"Could not allocate memory for map item\");\n                                internal_decoder_data->decoder_state = DECODER_STATE_ERROR;\n                                result = MU_FAILURE;\n                                break;\n                            }\n                            else\n                            {\n                                map_item->type = AMQP_TYPE_UNKNOWN;\n                                \n                                if (internal_decoder_data->decode_to_value->value.map_value.pairs[internal_decoder_data->decode_value_state.map_value_state.item].key == NULL)\n                                {\n                                    internal_decoder_data->decode_to_value->value.map_value.pairs[internal_decoder_data->decode_value_state.map_value_state.item].key = map_item;\n                                }\n                                else\n                                {\n                                    internal_decoder_data->decode_to_value->value.map_value.pairs[internal_decoder_data->decode_value_state.map_value_state.item].value = map_item;\n                                }\n                                internal_decoder_data->inner_decoder = internal_decoder_create(inner_decoder_callback, internal_decoder_data, map_item, true);\n                                if (internal_decoder_data->inner_decoder == NULL)\n                                {\n                                    LogError(\"Could not create inner decoder for map item\");\n                                    internal_decoder_data->decoder_state = DECODER_STATE_ERROR;\n                                }\n                                else\n                                {\n                                    result = 0;\n                                }\n                            }\n                        }\n\n                        if (internal_decoder_data->inner_decoder == NULL)\n                        {\n                            LogError(\"NULL inner decoder. This should not happen under normal circumstances\");\n                            result = MU_FAILURE;\n                        }\n                        else if (internal_decoder_decode_bytes(internal_decoder_data->inner_decoder, buffer, size, &inner_used_bytes) != 0)\n                        {\n                            LogError(\"Could not decode map item\");\n                            result = MU_FAILURE;\n                        }\n                        else\n                        {\n                            INTERNAL_DECODER_DATA* inner_decoder = (INTERNAL_DECODER_DATA*)internal_decoder_data->inner_decoder;\n                            internal_decoder_data->bytes_decoded += inner_used_bytes;\n                            buffer += inner_used_bytes;\n                            size -= inner_used_bytes;\n\n                            if (inner_decoder->decoder_state == DECODER_STATE_DONE)\n                            {\n                                internal_decoder_destroy(inner_decoder);\n                                internal_decoder_data->inner_decoder = NULL;\n                                internal_decoder_data->bytes_decoded = 0;\n\n                                if (internal_decoder_data->decode_to_value->value.map_value.pairs[internal_decoder_data->decode_value_state.map_value_state.item].value != NULL)\n                                {\n                                    internal_decoder_data->decode_value_state.map_value_state.item++;\n                                    if (internal_decoder_data->decode_value_state.map_value_state.item == internal_decoder_data->decode_to_value->value.map_value.pair_count)\n                                    {\n                                        internal_decoder_data->decoder_state = DECODER_STATE_CONSTRUCTOR;\n\n                                        internal_decoder_data->on_value_decoded(internal_decoder_data->on_value_decoded_context, internal_decoder_data->decode_to_value);\n                                    }\n                                }\n                            }\n\n                            result = 0;\n                        }\n\n                        break;\n                    }\n                    }\n\n                    break;\n                }\n                case 0xE0:\n                case 0xF0:\n                {\n                    DECODE_ARRAY_STEP step = internal_decoder_data->decode_value_state.array_value_state.array_value_state;\n\n                    switch (step)\n                    {\n                    default:\n                        LogError(\"Invalid step in decoding array value: %d\", step);\n                        result = MU_FAILURE;\n                        break;\n\n                    case DECODE_ARRAY_STEP_SIZE:\n                        internal_decoder_data->bytes_decoded++;\n                        buffer++;\n                        size--;\n\n                        if (internal_decoder_data->constructor_byte == 0xE0)\n                        {\n                            internal_decoder_data->decode_value_state.array_value_state.array_value_state = DECODE_ARRAY_STEP_COUNT;\n                            internal_decoder_data->bytes_decoded = 0;\n                            internal_decoder_data->decode_to_value->value.array_value.count = 0;\n                            result = 0;\n                        }\n                        else\n                        {\n                            if (internal_decoder_data->bytes_decoded == 4)\n                            {\n                                internal_decoder_data->decode_value_state.array_value_state.array_value_state = DECODE_ARRAY_STEP_COUNT;\n                                internal_decoder_data->bytes_decoded = 0;\n                                internal_decoder_data->decode_to_value->value.array_value.count = 0;\n                            }\n                            result = 0;\n                        }\n\n                        break;\n\n                    case DECODE_ARRAY_STEP_COUNT:\n                        if (internal_decoder_data->constructor_byte == 0xE0)\n                        {\n                            internal_decoder_data->decode_to_value->value.array_value.count = buffer[0];\n                        }\n                        else\n                        {\n                            internal_decoder_data->decode_to_value->value.array_value.count += buffer[0] << ((3 - internal_decoder_data->bytes_decoded) * 8);\n                        }\n\n                        internal_decoder_data->bytes_decoded++;\n                        buffer++;\n                        size--;\n                        if (internal_decoder_data->decode_to_value->value.array_value.count > MAX_AMQPVALUE_ITEM_COUNT)\n                        {\n                            LogError(\"AMQP array item count exceeded MAX_AMQPVALUE_ITEM_COUNT\");\n                            result = MU_FAILURE;\n                            size = 0;\n                            break;\n                        }\n\n                        if (internal_decoder_data->constructor_byte == 0xE0)\n                        {\n                            if (internal_decoder_data->decode_to_value->value.array_value.count == 0)\n                            {\n                                internal_decoder_data->decoder_state = DECODER_STATE_CONSTRUCTOR;\n\n                                internal_decoder_data->on_value_decoded(internal_decoder_data->on_value_decoded_context, internal_decoder_data->decode_to_value);\n                                result = 0;\n                            }\n                            else\n                            {\n                                uint32_t i;\n                                internal_decoder_data->decode_to_value->value.array_value.items = (AMQP_VALUE*)calloc(1, (sizeof(AMQP_VALUE) * internal_decoder_data->decode_to_value->value.array_value.count));\n                                if (internal_decoder_data->decode_to_value->value.array_value.items == NULL)\n                                {\n                                    LogError(\"Could not allocate memory for array items\");\n                                    result = MU_FAILURE;\n                                }\n                                else\n                                {\n                                    for (i = 0; i < internal_decoder_data->decode_to_value->value.array_value.count; i++)\n                                    {\n                                        internal_decoder_data->decode_to_value->value.array_value.items[i] = NULL;\n                                    }\n\n                                    internal_decoder_data->decode_value_state.array_value_state.array_value_state = DECODE_ARRAY_STEP_ITEMS;\n                                    internal_decoder_data->bytes_decoded = 0;\n                                    internal_decoder_data->inner_decoder = NULL;\n                                    internal_decoder_data->decode_value_state.array_value_state.item = 0;\n                                    result = 0;\n                                }\n                            }\n                        }\n                        else\n                        {\n                            if (internal_decoder_data->bytes_decoded == 4)\n                            {\n                                if (internal_decoder_data->decode_to_value->value.array_value.count == 0)\n                                {\n                                    internal_decoder_data->decoder_state = DECODER_STATE_CONSTRUCTOR;\n                                    internal_decoder_data->on_value_decoded(internal_decoder_data->on_value_decoded_context, internal_decoder_data->decode_to_value);\n                                    result = 0;\n                                }\n                                else\n                                {\n                                    uint32_t i;\n                                    internal_decoder_data->decode_to_value->value.array_value.items = (AMQP_VALUE*)calloc(1, (sizeof(AMQP_VALUE) * internal_decoder_data->decode_to_value->value.array_value.count));\n                                    if (internal_decoder_data->decode_to_value->value.array_value.items == NULL)\n                                    {\n                                        LogError(\"Could not allocate memory for array items\");\n                                        result = MU_FAILURE;\n                                    }\n                                    else\n                                    {\n                                        for (i = 0; i < internal_decoder_data->decode_to_value->value.array_value.count; i++)\n                                        {\n                                            internal_decoder_data->decode_to_value->value.array_value.items[i] = NULL;\n                                        }\n                                        internal_decoder_data->decode_value_state.array_value_state.array_value_state = DECODE_ARRAY_STEP_ITEMS;\n                                        internal_decoder_data->bytes_decoded = 0;\n                                        internal_decoder_data->inner_decoder = NULL;\n                                        internal_decoder_data->decode_value_state.array_value_state.item = 0;\n                                        result = 0;\n                                    }\n                                }\n                            }\n                            else\n                            {\n                                result = 0;\n                            }\n                        }\n                        break;\n\n                    case DECODE_ARRAY_STEP_ITEMS:\n                    {\n                        size_t inner_used_bytes;\n\n                        if (internal_decoder_data->bytes_decoded == 0)\n                        {\n                            AMQP_VALUE_DATA* array_item;\n                            internal_decoder_data->decode_value_state.array_value_state.constructor_byte = buffer[0];\n\n                            array_item = (AMQP_VALUE_DATA*)REFCOUNT_TYPE_CREATE(AMQP_VALUE_DATA);\n                            if (array_item == NULL)\n                            {\n                                LogError(\"Could not allocate memory for array item to be decoded\");\n                                internal_decoder_data->decoder_state = DECODER_STATE_ERROR;\n                                result = MU_FAILURE;\n                                break;\n                            }\n                            else\n                            {\n                                array_item->type = AMQP_TYPE_UNKNOWN;\n                                internal_decoder_data->decode_to_value->value.array_value.items[internal_decoder_data->decode_value_state.array_value_state.item] = array_item;\n                                internal_decoder_data->inner_decoder = internal_decoder_create(inner_decoder_callback, internal_decoder_data, array_item, true);\n                                if (internal_decoder_data->inner_decoder == NULL)\n                                {\n                                    internal_decoder_data->decoder_state = DECODER_STATE_ERROR;\n                                    LogError(\"Could not create inner decoder for array items\");\n                                }\n                            }\n                        }\n\n                        if (internal_decoder_data->inner_decoder == NULL)\n                        {\n                            LogError(\"NULL inner decoder. This should not happen under normal circumstances\");\n                            result = MU_FAILURE;\n                        }\n                        else if (internal_decoder_decode_bytes(internal_decoder_data->inner_decoder, buffer, size, &inner_used_bytes) != 0)\n                        {\n                            LogError(\"Could not decode array item\");\n                            result = MU_FAILURE;\n                        }\n                        else\n                        {\n                            INTERNAL_DECODER_DATA* inner_decoder = (INTERNAL_DECODER_DATA*)internal_decoder_data->inner_decoder;\n                            internal_decoder_data->bytes_decoded += inner_used_bytes;\n                            size -= inner_used_bytes;\n\n                            if (inner_decoder->decoder_state == DECODER_STATE_DONE)\n                            {\n                                internal_decoder_destroy(inner_decoder);\n                                internal_decoder_data->inner_decoder = NULL;\n\n                                internal_decoder_data->decode_value_state.array_value_state.item++;\n                                if (internal_decoder_data->decode_value_state.array_value_state.item == internal_decoder_data->decode_to_value->value.array_value.count)\n                                {\n                                    buffer += inner_used_bytes;\n                                    internal_decoder_data->decoder_state = DECODER_STATE_CONSTRUCTOR;\n                                    internal_decoder_data->on_value_decoded(internal_decoder_data->on_value_decoded_context, internal_decoder_data->decode_to_value);\n\n                                    result = 0;\n                                }\n                                else\n                                {\n                                    AMQP_VALUE_DATA* array_item;\n\n                                    if ((internal_decoder_data->decode_value_state.array_value_state.constructor_byte == 0x40) ||\n                                        (internal_decoder_data->decode_value_state.array_value_state.constructor_byte == 0x41) ||\n                                        (internal_decoder_data->decode_value_state.array_value_state.constructor_byte == 0x42) ||\n                                        (internal_decoder_data->decode_value_state.array_value_state.constructor_byte == 0x43) ||\n                                        (internal_decoder_data->decode_value_state.array_value_state.constructor_byte == 0x44) ||\n                                        (internal_decoder_data->decode_value_state.array_value_state.constructor_byte == 0x45))\n                                    {\n                                        /* Array items are constructor-only, e.g. NULL Don't increment buffer to account for implied data. */\n                                        size += inner_used_bytes;\n                                        internal_decoder_data->decoder_state = DECODER_STATE_TYPE_DATA;\n                                    }\n                                    else\n                                    {\n                                        buffer += inner_used_bytes;\n                                    }\n\n                                    array_item = (AMQP_VALUE_DATA*)REFCOUNT_TYPE_CREATE(AMQP_VALUE_DATA);\n                                    if (array_item == NULL)\n                                    {\n                                        LogError(\"Could not allocate memory for array item\");\n                                        internal_decoder_data->decoder_state = DECODER_STATE_ERROR;\n                                        result = MU_FAILURE;\n                                    }\n                                    else\n                                    {\n                                        array_item->type = AMQP_TYPE_UNKNOWN;\n                                        internal_decoder_data->decode_to_value->value.array_value.items[internal_decoder_data->decode_value_state.array_value_state.item] = array_item;\n                                        internal_decoder_data->inner_decoder = internal_decoder_create(inner_decoder_callback, internal_decoder_data, array_item, true);\n                                        if (internal_decoder_data->inner_decoder == NULL)\n                                        {\n                                            LogError(\"Could not create inner decoder for array item\");\n                                            internal_decoder_data->decoder_state = DECODER_STATE_ERROR;\n                                            result = MU_FAILURE;\n                                        }\n                                        else\n                                        {\n                                            if (internal_decoder_decode_bytes(internal_decoder_data->inner_decoder, &internal_decoder_data->decode_value_state.array_value_state.constructor_byte, 1, NULL) != 0)\n                                            {\n                                                LogError(\"Could not decode array item data\");\n                                                result = MU_FAILURE;\n                                            }\n                                            else\n                                            {\n                                                result = 0;\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                            else\n                            {\n                                buffer += inner_used_bytes;\n                                result = 0;\n                            }\n                        }\n\n                        break;\n                    }\n                    }\n\n                    break;\n                }\n                }\n                break;\n            }\n            }\n\n            if (result != 0)\n            {\n                break;\n            }\n        }\n    }\n\n    if (used_bytes != NULL)\n    {\n        *used_bytes = initial_size - size;\n    }\n\n    return result;\n}\n\nAMQPVALUE_DECODER_HANDLE amqpvalue_decoder_create(ON_VALUE_DECODED on_value_decoded, void* callback_context)\n{\n    AMQPVALUE_DECODER_HANDLE_DATA* decoder_instance;\n\n    /* Codes_SRS_AMQPVALUE_01_312: [If the on_value_decoded argument is NULL, amqpvalue_decoder_create shall return NULL.] */\n    if (on_value_decoded == NULL)\n    {\n        LogError(\"NULL on_value_decoded\");\n        decoder_instance = NULL;\n    }\n    else\n    {\n        decoder_instance = (AMQPVALUE_DECODER_HANDLE_DATA*)malloc(sizeof(AMQPVALUE_DECODER_HANDLE_DATA));\n        /* Codes_SRS_AMQPVALUE_01_313: [If creating the decoder fails, amqpvalue_decoder_create shall return NULL.] */\n        if (decoder_instance == NULL)\n        {\n            LogError(\"Could not allocate memory for AMQP value decoder\");\n        }\n        else\n        {\n            decoder_instance->decode_to_value = REFCOUNT_TYPE_CREATE(AMQP_VALUE_DATA);\n            if (decoder_instance->decode_to_value == NULL)\n            {\n                /* Codes_SRS_AMQPVALUE_01_313: [If creating the decoder fails, amqpvalue_decoder_create shall return NULL.] */\n                LogError(\"Could not allocate memory for decoded AMQP value\");\n                free(decoder_instance);\n                decoder_instance = NULL;\n            }\n            else\n            {\n                decoder_instance->decode_to_value->type = AMQP_TYPE_UNKNOWN;\n                decoder_instance->internal_decoder = internal_decoder_create(on_value_decoded, callback_context, decoder_instance->decode_to_value, false);\n                if (decoder_instance->internal_decoder == NULL)\n                {\n                    /* Codes_SRS_AMQPVALUE_01_313: [If creating the decoder fails, amqpvalue_decoder_create shall return NULL.] */\n                    LogError(\"Could not create the internal decoder\");\n                    REFCOUNT_TYPE_DESTROY(AMQP_VALUE_DATA, decoder_instance->decode_to_value);\n                    free(decoder_instance);\n                    decoder_instance = NULL;\n                }\n            }\n        }\n    }\n\n    /* Codes_SRS_AMQPVALUE_01_311: [amqpvalue_decoder_create shall create a new amqp value decoder and return a non-NULL handle to it.] */\n    return decoder_instance;\n}\n\nvoid amqpvalue_decoder_destroy(AMQPVALUE_DECODER_HANDLE handle)\n{\n    if (handle == NULL)\n    {\n        /* Codes_SRS_AMQPVALUE_01_317: [If handle is NULL, amqpvalue_decoder_destroy shall do nothing.] */\n        LogError(\"NULL handle\");\n    }\n    else\n    {\n        AMQPVALUE_DECODER_HANDLE_DATA* decoder_instance = (AMQPVALUE_DECODER_HANDLE_DATA*)handle;\n        /* Codes_SRS_AMQPVALUE_01_316: [amqpvalue_decoder_destroy shall free all resources associated with the amqpvalue_decoder.] */\n        amqpvalue_destroy(decoder_instance->internal_decoder->decode_to_value);\n        internal_decoder_destroy(decoder_instance->internal_decoder);\n        free(handle);\n    }\n}\n\n/* Codes_SRS_AMQPVALUE_01_318: [amqpvalue_decode_bytes shall decode size bytes that are passed in the buffer argument.] */\nint amqpvalue_decode_bytes(AMQPVALUE_DECODER_HANDLE handle, const unsigned char* buffer, size_t size)\n{\n    int result;\n\n    AMQPVALUE_DECODER_HANDLE_DATA* decoder_instance = (AMQPVALUE_DECODER_HANDLE_DATA*)handle;\n    /* Codes_SRS_AMQPVALUE_01_320: [If handle or buffer are NULL, amqpvalue_decode_bytes shall return a non-zero value.] */\n    if ((decoder_instance == NULL) ||\n        (buffer == NULL) ||\n        /* Codes_SRS_AMQPVALUE_01_321: [If size is 0, amqpvalue_decode_bytes shall return a non-zero value.] */\n        (size == 0))\n    {\n        LogError(\"Bad arguments: decoder_instance = %p, buffer = %p, size = %lu\",\n            decoder_instance, buffer, (unsigned long)size);\n        result = MU_FAILURE;\n    }\n    else\n    {\n        size_t used_bytes;\n\n        /* Codes_SRS_AMQPVALUE_01_318: [amqpvalue_decode_bytes shall decode size bytes that are passed in the buffer argument.] */\n        if (internal_decoder_decode_bytes(decoder_instance->internal_decoder, buffer, size, &used_bytes) != 0)\n        {\n            LogError(\"Failed decoding bytes\");\n            result = MU_FAILURE;\n        }\n        else\n        {\n            /* Codes_SRS_AMQPVALUE_01_319: [On success, amqpvalue_decode_bytes shall return 0.] */\n            result = 0;\n        }\n    }\n\n    return result;\n}\n\nAMQP_VALUE amqpvalue_get_inplace_descriptor(AMQP_VALUE value)\n{\n    AMQP_VALUE result;\n\n    if (value == NULL)\n    {\n        LogError(\"NULL value\");\n        result = NULL;\n    }\n    else\n    {\n        AMQP_VALUE_DATA* value_data = (AMQP_VALUE_DATA*)value;\n        if ((value_data->type != AMQP_TYPE_DESCRIBED) &&\n            (value_data->type != AMQP_TYPE_COMPOSITE))\n        {\n            LogError(\"Type is not described or composite\");\n            result = NULL;\n        }\n        else\n        {\n            result = value_data->value.described_value.descriptor;\n        }\n    }\n\n    return result;\n}\n\nAMQP_VALUE amqpvalue_get_inplace_described_value(AMQP_VALUE value)\n{\n    AMQP_VALUE result;\n\n    if (value == NULL)\n    {\n        LogError(\"NULL value\");\n        result = NULL;\n    }\n    else\n    {\n        AMQP_VALUE_DATA* value_data = (AMQP_VALUE_DATA*)value;\n        if ((value_data->type != AMQP_TYPE_DESCRIBED) &&\n            (value_data->type != AMQP_TYPE_COMPOSITE))\n        {\n            LogError(\"Type is not described or composite\");\n            result = NULL;\n        }\n        else\n        {\n            result = value_data->value.described_value.value;\n        }\n    }\n\n    return result;\n}\n\nAMQP_VALUE amqpvalue_create_described(AMQP_VALUE descriptor, AMQP_VALUE value)\n{\n    AMQP_VALUE_DATA* result = (AMQP_VALUE_DATA*)REFCOUNT_TYPE_CREATE(AMQP_VALUE_DATA);\n    if (result == NULL)\n    {\n        LogError(\"Cannot allocate memory for described type\");\n    }\n    else\n    {\n        result->type = AMQP_TYPE_DESCRIBED;\n        result->value.described_value.descriptor = descriptor;\n        result->value.described_value.value = value;\n    }\n\n    return result;\n}\n\nAMQP_VALUE amqpvalue_create_composite(AMQP_VALUE descriptor, uint32_t list_size)\n{\n    AMQP_VALUE_DATA* result = (AMQP_VALUE_DATA*)REFCOUNT_TYPE_CREATE(AMQP_VALUE_DATA);\n    if (result == NULL)\n    {\n        LogError(\"Cannot allocate memory for composite type\");\n    }\n    else\n    {\n        result->type = AMQP_TYPE_COMPOSITE;\n        result->value.described_value.descriptor = amqpvalue_clone(descriptor);\n        if (result->value.described_value.descriptor == NULL)\n        {\n            LogError(\"Cannot clone descriptor for composite type\");\n            REFCOUNT_TYPE_DESTROY(AMQP_VALUE_DATA, result);\n            result = NULL;\n        }\n        else\n        {\n            result->value.described_value.value = amqpvalue_create_list();\n            if (result->value.described_value.value == NULL)\n            {\n                LogError(\"Cannot create list for composite type\");\n                amqpvalue_destroy(result->value.described_value.descriptor);\n                REFCOUNT_TYPE_DESTROY(AMQP_VALUE_DATA, result);\n                result = NULL;\n            }\n            else\n            {\n                if (amqpvalue_set_list_item_count(result->value.described_value.value, list_size) != 0)\n                {\n                    LogError(\"Cannot set list item count for composite type\");\n                    amqpvalue_destroy(result->value.described_value.descriptor);\n                    amqpvalue_destroy(result->value.described_value.value);\n                    REFCOUNT_TYPE_DESTROY(AMQP_VALUE_DATA, result);\n                    result = NULL;\n                }\n            }\n        }\n    }\n\n    return result;\n}\n\nAMQP_VALUE amqpvalue_create_composite_with_ulong_descriptor(uint64_t descriptor)\n{\n    AMQP_VALUE_DATA* result = (AMQP_VALUE_DATA*)REFCOUNT_TYPE_CREATE(AMQP_VALUE_DATA);\n    if (result == NULL)\n    {\n        LogError(\"Cannot allocate memory for composite type\");\n    }\n    else\n    {\n        AMQP_VALUE descriptor_ulong_value = amqpvalue_create_ulong(descriptor);\n        if (descriptor_ulong_value == NULL)\n        {\n            LogError(\"Cannot create ulong descriptor for composite type\");\n            REFCOUNT_TYPE_DESTROY(AMQP_VALUE_DATA, result);\n            result = NULL;\n        }\n        else\n        {\n            result->type = AMQP_TYPE_COMPOSITE;\n            result->value.described_value.descriptor = descriptor_ulong_value;\n            result->value.described_value.value = amqpvalue_create_list();\n            if (result->value.described_value.value == NULL)\n            {\n                LogError(\"Cannot create list for composite type\");\n                amqpvalue_destroy(descriptor_ulong_value);\n                REFCOUNT_TYPE_DESTROY(AMQP_VALUE_DATA, result);\n                result = NULL;\n            }\n        }\n    }\n\n    return result;\n}\n\nint amqpvalue_set_composite_item(AMQP_VALUE value, uint32_t index, AMQP_VALUE item_value)\n{\n    int result;\n\n    if (value == NULL)\n    {\n        LogError(\"NULL value\");\n        result = MU_FAILURE;\n    }\n    else\n    {\n        AMQP_VALUE_DATA* value_data = (AMQP_VALUE_DATA*)value;\n        if ((value_data->type != AMQP_TYPE_COMPOSITE) &&\n            (value_data->type != AMQP_TYPE_DESCRIBED))\n        {\n            LogError(\"Attempt to set composite item on a non-composite type\");\n            result = MU_FAILURE;\n        }\n        else\n        {\n            if (amqpvalue_set_list_item(value_data->value.described_value.value, index, item_value) != 0)\n            {\n                LogError(\"amqpvalue_set_list_item failed for composite item\");\n                result = MU_FAILURE;\n            }\n            else\n            {\n                result = 0;\n            }\n        }\n    }\n\n    return result;\n}\n\nAMQP_VALUE amqpvalue_get_composite_item(AMQP_VALUE value, size_t index)\n{\n    AMQP_VALUE result;\n\n    if (value == NULL)\n    {\n        LogError(\"NULL value\");\n        result = NULL;\n    }\n    else\n    {\n        AMQP_VALUE_DATA* value_data = (AMQP_VALUE_DATA*)value;\n        if ((value_data->type != AMQP_TYPE_COMPOSITE) &&\n            (value_data->type != AMQP_TYPE_DESCRIBED))\n        {\n            LogError(\"Attempt to get composite item on a non-composite type\");\n            result = NULL;\n        }\n        else\n        {\n            result = amqpvalue_get_list_item(value_data->value.described_value.value, index);\n            if (result == NULL)\n            {\n                LogError(\"amqpvalue_get_list_item failed for composite item\");\n            }\n        }\n    }\n\n    return result;\n}\n\nAMQP_VALUE amqpvalue_get_composite_item_in_place(AMQP_VALUE value, size_t index)\n{\n    AMQP_VALUE result;\n\n    if (value == NULL)\n    {\n        LogError(\"NULL value\");\n        result = NULL;\n    }\n    else\n    {\n        AMQP_VALUE_DATA* value_data = (AMQP_VALUE_DATA*)value;\n        if ((value_data->type != AMQP_TYPE_COMPOSITE) &&\n            (value_data->type != AMQP_TYPE_DESCRIBED))\n        {\n            LogError(\"Attempt to get composite item in place on a non-composite type\");\n            result = NULL;\n        }\n        else\n        {\n            result = amqpvalue_get_list_item_in_place(value_data->value.described_value.value, index);\n            if (result == NULL)\n            {\n                LogError(\"amqpvalue_get_list_item_in_place failed for composite item\");\n            }\n        }\n    }\n\n    return result;\n}\n\nint amqpvalue_get_composite_item_count(AMQP_VALUE value, uint32_t* item_count)\n{\n    int result;\n\n    if (value == NULL)\n    {\n        LogError(\"NULL value\");\n        result = MU_FAILURE;\n    }\n    else\n    {\n        AMQP_VALUE_DATA* value_data = (AMQP_VALUE_DATA*)value;\n        if ((value_data->type != AMQP_TYPE_COMPOSITE) &&\n            (value_data->type != AMQP_TYPE_DESCRIBED))\n        {\n            LogError(\"Attempt to get composite item in place on a non-composite type\");\n            result = MU_FAILURE;\n        }\n        else\n        {\n            if (amqpvalue_get_list_item_count(value_data->value.described_value.value, item_count) != 0)\n            {\n                LogError(\"amqpvalue_get_list_item_in_place failed for composite item\");\n                result = MU_FAILURE;\n            }\n            else\n            {\n                result = 0;\n            }\n        }\n    }\n\n    return result;\n}\n\nAMQP_VALUE amqpvalue_get_list_item_in_place(AMQP_VALUE value, size_t index)\n{\n    AMQP_VALUE result;\n\n    if (value == NULL)\n    {\n        LogError(\"NULL value\");\n        result = NULL;\n    }\n    else\n    {\n        AMQP_VALUE_DATA* value_data = (AMQP_VALUE_DATA*)value;\n\n        if ((value_data->type != AMQP_TYPE_LIST) ||\n            (value_data->value.list_value.count <= index))\n        {\n            LogError(\"Attempt to get list item in place on a non-list type\");\n            result = NULL;\n        }\n        else\n        {\n            result = value_data->value.list_value.items[index];\n        }\n    }\n\n    return result;\n}\n"], "fixing_code": ["// Copyright (c) Microsoft. All rights reserved.\n// Licensed under the MIT license. See LICENSE file in the project root for full license information.\n\n#include <stdlib.h>\n#include <stdint.h>\n#include <string.h>\n#include <stdbool.h>\n#include \"azure_macro_utils/macro_utils.h\"\n#include \"azure_c_shared_utility/gballoc.h\"\n#include \"azure_c_shared_utility/xlogging.h\"\n#include \"azure_uamqp_c/amqp_types.h\"\n#include \"azure_uamqp_c/amqpvalue.h\"\n#include \"azure_c_shared_utility/refcount.h\"\n\n// max alloc size 100MB\n#define MAX_AMQPVALUE_MALLOC_SIZE_BYTES (100 * 1024 * 1024) \n#define MAX_AMQPVALUE_ITEM_COUNT 65536\n\n/* Requirements satisfied by the current implementation without any code:\nCodes_SRS_AMQPVALUE_01_270: [<encoding code=\"0x56\" category=\"fixed\" width=\"1\" label=\"boolean with the octet 0x00 being false and octet 0x01 being true\"/>]\nCodes_SRS_AMQPVALUE_01_099: [Represents an approximate point in time using the Unix time t [IEEE1003] encoding of UTC, but with a precision of milliseconds.]\n*/\n\ntypedef struct AMQP_LIST_VALUE_TAG\n{\n    AMQP_VALUE* items;\n    uint32_t count;\n} AMQP_LIST_VALUE;\n\ntypedef struct AMQP_ARRAY_VALUE_TAG\n{\n    AMQP_VALUE* items;\n    uint32_t count;\n} AMQP_ARRAY_VALUE;\n\ntypedef struct AMQP_MAP_KEY_VALUE_PAIR_TAG\n{\n    AMQP_VALUE key;\n    AMQP_VALUE value;\n} AMQP_MAP_KEY_VALUE_PAIR;\n\ntypedef struct AMQP_MAP_VALUE_TAG\n{\n    AMQP_MAP_KEY_VALUE_PAIR* pairs;\n    uint32_t pair_count;\n} AMQP_MAP_VALUE;\n\ntypedef struct AMQP_STRING_VALUE_TAG\n{\n    char* chars;\n} AMQP_STRING_VALUE;\n\ntypedef struct AMQP_SYMBOL_VALUE_TAG\n{\n    char* chars;\n} AMQP_SYMBOL_VALUE;\n\ntypedef struct AMQP_BINARY_VALUE_TAG\n{\n    unsigned char* bytes;\n    uint32_t length;\n} AMQP_BINARY_VALUE;\n\ntypedef struct DESCRIBED_VALUE_TAG\n{\n    AMQP_VALUE descriptor;\n    AMQP_VALUE value;\n} DESCRIBED_VALUE;\n\ntypedef union AMQP_VALUE_UNION_TAG\n{\n    DESCRIBED_VALUE described_value;\n    unsigned char ubyte_value;\n    uint16_t ushort_value;\n    uint32_t uint_value;\n    uint64_t ulong_value;\n    char byte_value;\n    int16_t short_value;\n    int32_t int_value;\n    int64_t long_value;\n    bool bool_value;\n    float float_value;\n    double double_value;\n    uint32_t char_value;\n    int64_t timestamp_value;\n    uuid uuid_value;\n    AMQP_STRING_VALUE string_value;\n    amqp_binary binary_value;\n    AMQP_LIST_VALUE list_value;\n    AMQP_MAP_VALUE map_value;\n    AMQP_ARRAY_VALUE array_value;\n    AMQP_SYMBOL_VALUE symbol_value;\n} AMQP_VALUE_UNION;\n\ntypedef enum DECODE_LIST_STEP_TAG\n{\n    DECODE_LIST_STEP_SIZE,\n    DECODE_LIST_STEP_COUNT,\n    DECODE_LIST_STEP_ITEMS\n} DECODE_LIST_STEP;\n\ntypedef enum DECODE_ARRAY_STEP_TAG\n{\n    DECODE_ARRAY_STEP_SIZE,\n    DECODE_ARRAY_STEP_COUNT,\n    DECODE_ARRAY_STEP_ITEMS\n} DECODE_ARRAY_STEP;\n\ntypedef enum DECODE_DESCRIBED_VALUE_STEP_TAG\n{\n    DECODE_DESCRIBED_VALUE_STEP_DESCRIPTOR,\n    DECODE_DESCRIBED_VALUE_STEP_VALUE\n} DECODE_DESCRIBED_VALUE_STEP;\n\ntypedef enum DECODE_MAP_STEP_TAG\n{\n    DECODE_MAP_STEP_SIZE,\n    DECODE_MAP_STEP_COUNT,\n    DECODE_MAP_STEP_PAIRS\n} DECODE_MAP_STEP;\n\ntypedef struct DECODE_LIST_VALUE_STATE_TAG\n{\n    DECODE_LIST_STEP list_value_state;\n    uint32_t item;\n} DECODE_LIST_VALUE_STATE;\n\ntypedef struct DECODE_ARRAY_VALUE_STATE_TAG\n{\n    DECODE_ARRAY_STEP array_value_state;\n    uint32_t item;\n    unsigned char constructor_byte;\n} DECODE_ARRAY_VALUE_STATE;\n\ntypedef struct DECODE_DESCRIBED_VALUE_STATE_TAG\n{\n    DECODE_DESCRIBED_VALUE_STEP described_value_state;\n} DECODE_DESCRIBED_VALUE_STATE;\n\ntypedef struct DECODE_STRING_VALUE_STATE_TAG\n{\n    uint32_t length;\n} DECODE_STRING_VALUE_STATE;\n\ntypedef struct DECODE_SYMBOL_VALUE_STATE_TAG\n{\n    uint32_t length;\n} DECODE_SYMBOL_VALUE_STATE;\n\ntypedef struct DECODE_MAP_VALUE_STATE_TAG\n{\n    DECODE_MAP_STEP map_value_state;\n    uint32_t item;\n} DECODE_MAP_VALUE_STATE;\n\ntypedef union DECODE_VALUE_STATE_UNION_TAG\n{\n    DECODE_LIST_VALUE_STATE list_value_state;\n    DECODE_ARRAY_VALUE_STATE array_value_state;\n    DECODE_DESCRIBED_VALUE_STATE described_value_state;\n    DECODE_STRING_VALUE_STATE string_value_state;\n    DECODE_SYMBOL_VALUE_STATE symbol_value_state;\n    DECODE_MAP_VALUE_STATE map_value_state;\n} DECODE_VALUE_STATE_UNION;\n\ntypedef struct AMQP_VALUE_DATA_TAG\n{\n    AMQP_TYPE type;\n    AMQP_VALUE_UNION value;\n} AMQP_VALUE_DATA;\n\nDEFINE_REFCOUNT_TYPE(AMQP_VALUE_DATA);\n\ntypedef enum DECODER_STATE_TAG\n{\n    DECODER_STATE_CONSTRUCTOR,\n    DECODER_STATE_TYPE_DATA,\n    DECODER_STATE_DONE,\n    DECODER_STATE_ERROR\n} DECODER_STATE;\n\ntypedef struct INTERNAL_DECODER_DATA_TAG* INTERNAL_DECODER_HANDLE;\n\ntypedef struct INTERNAL_DECODER_DATA_TAG\n{\n    ON_VALUE_DECODED on_value_decoded;\n    void* on_value_decoded_context;\n    size_t bytes_decoded;\n    DECODER_STATE decoder_state;\n    uint8_t constructor_byte;\n    AMQP_VALUE_DATA* decode_to_value;\n    INTERNAL_DECODER_HANDLE inner_decoder;\n    DECODE_VALUE_STATE_UNION decode_value_state;\n    bool is_internal;\n} INTERNAL_DECODER_DATA;\n\ntypedef struct AMQPVALUE_DECODER_HANDLE_DATA_TAG\n{\n    INTERNAL_DECODER_DATA* internal_decoder;\n    AMQP_VALUE_DATA* decode_to_value;\n} AMQPVALUE_DECODER_HANDLE_DATA;\n\nstatic int amqpvalue_encode_array_item(AMQP_VALUE item, bool first_element, AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context);\nstatic int amqpvalue_get_encoded_array_item_size(AMQP_VALUE item, size_t* encoded_size);\n\n/* Codes_SRS_AMQPVALUE_01_003: [1.6.1 null Indicates an empty value.] */\nAMQP_VALUE amqpvalue_create_null(void)\n{\n    AMQP_VALUE result = REFCOUNT_TYPE_CREATE(AMQP_VALUE_DATA);\n    if (result == NULL)\n    {\n        /* Codes_SRS_AMQPVALUE_01_002: [If allocating the AMQP_VALUE fails then amqpvalue_create_null shall return NULL.] */\n        LogError(\"Could not allocate memory for AMQP value\");\n    }\n    else\n    {\n        /* Codes_SRS_AMQPVALUE_01_001: [amqpvalue_create_null shall return a handle to an AMQP_VALUE that stores a null value.] */\n        result->type = AMQP_TYPE_NULL;\n    }\n\n    return result;\n}\n\n/* Codes_SRS_AMQPVALUE_01_004: [1.6.2 boolean Represents a true or false value.] */\nAMQP_VALUE amqpvalue_create_boolean(bool value)\n{\n    AMQP_VALUE result = REFCOUNT_TYPE_CREATE(AMQP_VALUE_DATA);\n    if (result == NULL)\n    {\n        /* Codes_SRS_AMQPVALUE_01_007: [If allocating the AMQP_VALUE fails then amqpvalue_create_boolean shall return NULL.] */\n        LogError(\"Could not allocate memory for AMQP value\");\n    }\n    else\n    {\n        /* Codes_SRS_AMQPVALUE_01_006: [amqpvalue_create_boolean shall return a handle to an AMQP_VALUE that stores a boolean value.] */\n        result->type = AMQP_TYPE_BOOL;\n        result->value.bool_value = value;\n    }\n\n    return result;\n}\n\nint amqpvalue_get_boolean(AMQP_VALUE value, bool* bool_value)\n{\n    int result;\n\n    /* Codes_SRS_AMQPVALUE_01_009: [If any of the arguments is NULL then amqpvalue_get_boolean shall return a non-zero value.] */\n    if ((value == NULL) ||\n        (bool_value == NULL))\n    {\n        LogError(\"Bad arguments: value = %p, bool_value = %p\",\n            value, bool_value);\n        result = MU_FAILURE;\n    }\n    else\n    {\n        AMQP_VALUE_DATA* value_data = (AMQP_VALUE_DATA*)value;\n        /* Codes_SRS_AMQPVALUE_01_011: [If the type of the value is not Boolean, then amqpvalue_get_boolean shall return a non-zero value.] */\n        if (value_data->type != AMQP_TYPE_BOOL)\n        {\n            LogError(\"Value is not of type bool\");\n            result = MU_FAILURE;\n        }\n        else\n        {\n            /* Codes_SRS_AMQPVALUE_01_008: [amqpvalue_get_boolean shall fill in the bool_value argument the Boolean value stored by the AMQP value indicated by the value argument.] */\n            *bool_value = value_data->value.bool_value;\n\n            /* Codes_SRS_AMQPVALUE_01_010: [On success amqpvalue_get_boolean shall return 0.] */\n            result = 0;\n        }\n    }\n\n    return result;\n}\n\n/* Codes_SRS_AMQPVALUE_01_005: [1.6.3 ubyte Integer in the range 0 to 28 - 1 inclusive.] */\nAMQP_VALUE amqpvalue_create_ubyte(unsigned char value)\n{\n    AMQP_VALUE result = REFCOUNT_TYPE_CREATE(AMQP_VALUE_DATA);\n    if (result != NULL)\n    {\n        /* Codes_SRS_AMQPVALUE_01_032: [amqpvalue_create_ubyte shall return a handle to an AMQP_VALUE that stores a unsigned char value.] */\n        result->type = AMQP_TYPE_UBYTE;\n        result->value.ubyte_value = value;\n    }\n\n    return result;\n}\n\nint amqpvalue_get_ubyte(AMQP_VALUE value, unsigned char* ubyte_value)\n{\n    int result;\n\n    /* Codes_SRS_AMQPVALUE_01_036: [If any of the arguments is NULL then amqpvalue_get_ubyte shall return a non-zero value.] */\n    if ((value == NULL) ||\n        (ubyte_value == NULL))\n    {\n        LogError(\"Bad arguments: value = %p, ubyte_value = %p\",\n            value, ubyte_value);\n        result = MU_FAILURE;\n    }\n    else\n    {\n        AMQP_VALUE_DATA* value_data = (AMQP_VALUE_DATA*)value;\n        /* Codes_SRS_AMQPVALUE_01_037: [If the type of the value is not ubyte (was not created with amqpvalue_create_ubyte), then amqpvalue_get_ubyte shall return a non-zero value.] */\n        if (value_data->type != AMQP_TYPE_UBYTE)\n        {\n            LogError(\"Value is not of type UBYTE\");\n            result = MU_FAILURE;\n        }\n        else\n        {\n            /* Codes_SRS_AMQPVALUE_01_034: [amqpvalue_get_ubyte shall fill in the ubyte_value argument the unsigned char value stored by the AMQP value indicated by the value argument.] */\n            *ubyte_value = value_data->value.ubyte_value;\n\n            /* Codes_SRS_AMQPVALUE_01_035: [On success amqpvalue_get_ubyte shall return 0.] */\n            result = 0;\n        }\n    }\n\n    return result;\n}\n\n/* Codes_SRS_AMQPVALUE_01_012: [1.6.4 ushort Integer in the range 0 to 216 - 1 inclusive.] */\nAMQP_VALUE amqpvalue_create_ushort(uint16_t value)\n{\n    AMQP_VALUE result = REFCOUNT_TYPE_CREATE(AMQP_VALUE_DATA);\n    if (result == NULL)\n    {\n        /* Codes_SRS_AMQPVALUE_01_039: [If allocating the AMQP_VALUE fails then amqpvalue_create_ushort shall return NULL.] */\n        LogError(\"Could not allocate memory for AMQP value\");\n    }\n    else\n    {\n        /* Codes_SRS_AMQPVALUE_01_038: [amqpvalue_create_ushort shall return a handle to an AMQP_VALUE that stores an uint16_t value.] */\n        result->type = AMQP_TYPE_USHORT;\n        result->value.ushort_value = value;\n    }\n\n    return result;\n}\n\nint amqpvalue_get_ushort(AMQP_VALUE value, uint16_t* ushort_value)\n{\n    int result;\n\n    /* Codes_SRS_AMQPVALUE_01_042: [If any of the arguments is NULL then amqpvalue_get_ushort shall return a non-zero value.] */\n    if ((value == NULL) ||\n        (ushort_value == NULL))\n    {\n        LogError(\"Bad arguments: value = %p, ushort_value = %p\",\n            value, ushort_value);\n        result = MU_FAILURE;\n    }\n    else\n    {\n        AMQP_VALUE_DATA* value_data = (AMQP_VALUE_DATA*)value;\n        /* Codes_SRS_AMQPVALUE_01_043: [If the type of the value is not ushort (was not created with amqpvalue_create_ushort), then amqpvalue_get_ushort shall return a non-zero value.] */\n        if (value_data->type != AMQP_TYPE_USHORT)\n        {\n            LogError(\"Value is not of type USHORT\");\n            result = MU_FAILURE;\n        }\n        else\n        {\n            /* Codes_SRS_AMQPVALUE_01_040: [amqpvalue_get_ushort shall fill in the ushort_value argument the uint16_t value stored by the AMQP value indicated by the value argument.] */\n            *ushort_value = value_data->value.ushort_value;\n\n            /* Codes_SRS_AMQPVALUE_01_041: [On success amqpvalue_get_ushort shall return 0.] */\n            result = 0;\n        }\n    }\n\n    return result;\n}\n\n/* Codes_SRS_AMQPVALUE_01_013: [1.6.5 uint Integer in the range 0 to 232 - 1 inclusive.] */\nAMQP_VALUE amqpvalue_create_uint(uint32_t value)\n{\n    AMQP_VALUE result = REFCOUNT_TYPE_CREATE(AMQP_VALUE_DATA);\n    if (result == NULL)\n    {\n        /* Codes_SRS_AMQPVALUE_01_045: [If allocating the AMQP_VALUE fails then amqpvalue_create_uint shall return NULL.] */\n        LogError(\"Could not allocate memory for AMQP value\");\n    }\n    else\n    {\n        /* Codes_SRS_AMQPVALUE_01_044: [amqpvalue_create_uint shall return a handle to an AMQP_VALUE that stores an uint32_t value.] */\n        result->type = AMQP_TYPE_UINT;\n        result->value.uint_value = value;\n    }\n\n    return result;\n}\n\nint amqpvalue_get_uint(AMQP_VALUE value, uint32_t* uint_value)\n{\n    int result;\n\n    /* Codes_SRS_AMQPVALUE_01_079: [If any of the arguments is NULL then amqpvalue_get_uint shall return a non-zero value.] */\n    if ((value == NULL) ||\n        (uint_value == NULL))\n    {\n        LogError(\"Bad arguments: value = %p, uint_value = %p\",\n            value, uint_value);\n        result = MU_FAILURE;\n    }\n    else\n    {\n        AMQP_VALUE_DATA* value_data = (AMQP_VALUE_DATA*)value;\n        /* Codes_SRS_AMQPVALUE_01_048: [If the type of the value is not uint (was not created with amqpvalue_create_uint), then amqpvalue_get_uint shall return a non-zero value.] */\n        if (value_data->type != AMQP_TYPE_UINT)\n        {\n            LogError(\"Value is not of type UINT\");\n            result = MU_FAILURE;\n        }\n        else\n        {\n            /* Codes_SRS_AMQPVALUE_01_046: [amqpvalue_get_uint shall fill in the uint_value argument the uint32_t value stored by the AMQP value indicated by the value argument.] */\n            *uint_value = value_data->value.uint_value;\n\n            /* Codes_SRS_AMQPVALUE_01_047: [On success amqpvalue_get_uint shall return 0.] */\n            result = 0;\n        }\n    }\n\n    return result;\n}\n\n/* Codes_SRS_AMQPVALUE_01_014: [1.6.6 ulong Integer in the range 0 to 264 - 1 inclusive.] */\nAMQP_VALUE amqpvalue_create_ulong(uint64_t value)\n{\n    AMQP_VALUE result = REFCOUNT_TYPE_CREATE(AMQP_VALUE_DATA);\n    if (result == NULL)\n    {\n        /* Codes_SRS_AMQPVALUE_01_050: [If allocating the AMQP_VALUE fails then amqpvalue_create_ulong shall return NULL.] */\n        LogError(\"Could not allocate memory for AMQP value\");\n    }\n    else\n    {\n        /* Codes_SRS_AMQPVALUE_01_049: [amqpvalue_create_ulong shall return a handle to an AMQP_VALUE that stores an uint64_t value.] */\n        result->type = AMQP_TYPE_ULONG;\n        result->value.ulong_value = value;\n    }\n\n    return result;\n}\n\nint amqpvalue_get_ulong(AMQP_VALUE value, uint64_t* ulong_value)\n{\n    int result;\n\n    /* Codes_SRS_AMQPVALUE_01_053: [If any of the arguments is NULL then amqpvalue_get_ulong shall return a non-zero value.] */\n    if ((value == NULL) ||\n        (ulong_value == NULL))\n    {\n        LogError(\"Bad arguments: value = %p, ulong_value = %p\",\n            value, ulong_value);\n        result = MU_FAILURE;\n    }\n    else\n    {\n        AMQP_VALUE_DATA* value_data = (AMQP_VALUE_DATA*)value;\n        /* Codes_SRS_AMQPVALUE_01_054: [If the type of the value is not ulong (was not created with amqpvalue_create_ulong), then amqpvalue_get_ulong shall return a non-zero value.] */\n        if (value_data->type != AMQP_TYPE_ULONG)\n        {\n            LogError(\"Value is not of type ULONG\");\n            result = MU_FAILURE;\n        }\n        else\n        {\n            /* Codes_SRS_AMQPVALUE_01_051: [amqpvalue_get_ulong shall fill in the ulong_value argument the ulong64_t value stored by the AMQP value indicated by the value argument.] */\n            *ulong_value = value_data->value.ulong_value;\n\n            /* Codes_SRS_AMQPVALUE_01_052: [On success amqpvalue_get_ulong shall return 0.] */\n            result = 0;\n        }\n    }\n\n    return result;\n}\n\n/* Codes_SRS_AMQPVALUE_01_015: [1.6.7 byte Integer in the range -(27) to 27 - 1 inclusive.] */\nAMQP_VALUE amqpvalue_create_byte(char value)\n{\n    AMQP_VALUE result = REFCOUNT_TYPE_CREATE(AMQP_VALUE_DATA);\n    if (result == NULL)\n    {\n        /* Codes_SRS_AMQPVALUE_01_056: [If allocating the AMQP_VALUE fails then amqpvalue_create_byte shall return NULL.] */\n        LogError(\"Could not allocate memory for AMQP value\");\n    }\n    else\n    {\n        /* Codes_SRS_AMQPVALUE_01_055: [amqpvalue_create_byte shall return a handle to an AMQP_VALUE that stores a char value.] */\n        result->type = AMQP_TYPE_BYTE;\n        result->value.byte_value = value;\n    }\n\n    return result;\n}\n\nint amqpvalue_get_byte(AMQP_VALUE value, char* byte_value)\n{\n    int result;\n\n    /* Codes_SRS_AMQPVALUE_01_059: [If any of the arguments is NULL then amqpvalue_get_byte shall return a non-zero value.] */\n    if ((value == NULL) ||\n        (byte_value == NULL))\n    {\n        LogError(\"Bad arguments: value = %p, byte_value = %p\",\n            value, byte_value);\n        result = MU_FAILURE;\n    }\n    else\n    {\n        AMQP_VALUE_DATA* value_data = (AMQP_VALUE_DATA*)value;\n        /* Codes_SRS_AMQPVALUE_01_060: [If the type of the value is not byte (was not created with amqpvalue_create_byte), then amqpvalue_get_byte shall return a non-zero value.] */\n        if (value_data->type != AMQP_TYPE_BYTE)\n        {\n            LogError(\"Value is not of type BYTE\");\n            result = MU_FAILURE;\n        }\n        else\n        {\n            /* Codes_SRS_AMQPVALUE_01_057: [amqpvalue_get_byte shall fill in the byte_value argument the char value stored by the AMQP value indicated by the value argument.] */\n            *byte_value = value_data->value.byte_value;\n\n            /* Codes_SRS_AMQPVALUE_01_058: [On success amqpvalue_get_byte shall return 0.] */\n            result = 0;\n        }\n    }\n\n    return result;\n}\n\n/* Codes_SRS_AMQPVALUE_01_016: [1.6.8 short Integer in the range -(215) to 215 - 1 inclusive.] */\nAMQP_VALUE amqpvalue_create_short(int16_t value)\n{\n    AMQP_VALUE result = REFCOUNT_TYPE_CREATE(AMQP_VALUE_DATA);\n    if (result == NULL)\n    {\n        /* Codes_SRS_AMQPVALUE_01_062: [If allocating the AMQP_VALUE fails then amqpvalue_create_short shall return NULL.] */\n        LogError(\"Could not allocate memory for AMQP value\");\n    }\n    else\n    {\n        /* Codes_SRS_AMQPVALUE_01_061: [amqpvalue_create_short shall return a handle to an AMQP_VALUE that stores an int16_t value.] */\n        result->type = AMQP_TYPE_SHORT;\n        result->value.short_value = value;\n    }\n    return result;\n}\n\nint amqpvalue_get_short(AMQP_VALUE value, int16_t* short_value)\n{\n    int result;\n\n    /* Codes_SRS_AMQPVALUE_01_065: [If any of the arguments is NULL then amqpvalue_get_short shall return a non-zero value.] */\n    if ((value == NULL) ||\n        (short_value == NULL))\n    {\n        LogError(\"Bad arguments: value = %p, short_value = %p\",\n            value, short_value);\n        result = MU_FAILURE;\n    }\n    else\n    {\n        AMQP_VALUE_DATA* value_data = (AMQP_VALUE_DATA*)value;\n        /* Codes_SRS_AMQPVALUE_01_066: [If the type of the value is not short (was not created with amqpvalue_create_short), then amqpvalue_get_short shall return a non-zero value.] */\n        if (value_data->type != AMQP_TYPE_SHORT)\n        {\n            LogError(\"Value is not of type SHORT\");\n            result = MU_FAILURE;\n        }\n        else\n        {\n            /* Codes_SRS_AMQPVALUE_01_063: [amqpvalue_get_short shall fill in the short_value argument the int16_t value stored by the AMQP value indicated by the value argument.] */\n            *short_value = value_data->value.short_value;\n\n            /* Codes_SRS_AMQPVALUE_01_064: [On success amqpvalue_get_short shall return 0.] */\n            result = 0;\n        }\n    }\n\n    return result;\n}\n\n/* Codes_SRS_AMQPVALUE_01_017: [1.6.9 int Integer in the range -(231) to 231 - 1 inclusive.] */\nAMQP_VALUE amqpvalue_create_int(int32_t value)\n{\n    AMQP_VALUE result = REFCOUNT_TYPE_CREATE(AMQP_VALUE_DATA);\n    if (result == NULL)\n    {\n        /* Codes_SRS_AMQPVALUE_01_068: [If allocating the AMQP_VALUE fails then amqpvalue_create_int shall return NULL.] */\n        LogError(\"Could not allocate memory for AMQP value\");\n    }\n    else\n    {\n        /* Codes_SRS_AMQPVALUE_01_067: [amqpvalue_create_int shall return a handle to an AMQP_VALUE that stores an int32_t value.] */\n        result->type = AMQP_TYPE_INT;\n        result->value.int_value = value;\n    }\n\n    return result;\n}\n\nint amqpvalue_get_int(AMQP_VALUE value, int32_t* int_value)\n{\n    int result;\n\n    /* Codes_SRS_AMQPVALUE_01_071: [If any of the arguments is NULL then amqpvalue_get_int shall return a non-zero value.] */\n    if ((value == NULL) ||\n        (int_value == NULL))\n    {\n        LogError(\"Bad arguments: value = %p, int_value = %p\",\n            value, int_value);\n        result = MU_FAILURE;\n    }\n    else\n    {\n        AMQP_VALUE_DATA* value_data = (AMQP_VALUE_DATA*)value;\n        /* Codes_SRS_AMQPVALUE_01_072: [If the type of the value is not int (was not created with amqpvalue_create_int), then amqpvalue_get_int shall return a non-zero value.] */\n        if (value_data->type != AMQP_TYPE_INT)\n        {\n            LogError(\"Value is not of type INT\");\n            result = MU_FAILURE;\n        }\n        else\n        {\n            /* Codes_SRS_AMQPVALUE_01_069: [amqpvalue_get_int shall fill in the int_value argument the int32_t value stored by the AMQP value indicated by the value argument.] */\n            *int_value = value_data->value.int_value;\n\n            /* Codes_SRS_AMQPVALUE_01_070: [On success amqpvalue_get_int shall return 0.] */\n            result = 0;\n        }\n    }\n\n    return result;\n}\n\n/* Codes_SRS_AMQPVALUE_01_018: [1.6.10 long Integer in the range -(263) to 263 - 1 inclusive.] */\nAMQP_VALUE amqpvalue_create_long(int64_t value)\n{\n    AMQP_VALUE result = REFCOUNT_TYPE_CREATE(AMQP_VALUE_DATA);\n    if (result == NULL)\n    {\n        /* Codes_SRS_AMQPVALUE_01_074: [If allocating the AMQP_VALUE fails then amqpvalue_create_long shall return NULL.] */\n        LogError(\"Could not allocate memory for AMQP value\");\n    }\n    else\n    {\n        /* Codes_SRS_AMQPVALUE_01_073: [amqpvalue_create_long shall return a handle to an AMQP_VALUE that stores an int64_t value.] */\n        result->type = AMQP_TYPE_LONG;\n        result->value.long_value = value;\n    }\n\n    return result;\n}\n\nint amqpvalue_get_long(AMQP_VALUE value, int64_t* long_value)\n{\n    int result;\n\n    /* Codes_SRS_AMQPVALUE_01_077: [If any of the arguments is NULL then amqpvalue_get_long shall return a non-zero value.] */\n    if ((value == NULL) ||\n        (long_value == NULL))\n    {\n        LogError(\"Bad arguments: value = %p, long_value = %p\",\n            value, long_value);\n        result = MU_FAILURE;\n    }\n    else\n    {\n        AMQP_VALUE_DATA* value_data = (AMQP_VALUE_DATA*)value;\n        /* Codes_SRS_AMQPVALUE_01_078: [If the type of the value is not long (was not created with amqpvalue_create_long), then amqpvalue_get_long shall return a non-zero value.] */\n        if (value_data->type != AMQP_TYPE_LONG)\n        {\n            LogError(\"Value is not of type LONG\");\n            result = MU_FAILURE;\n        }\n        else\n        {\n            /* Codes_SRS_AMQPVALUE_01_075: [amqpvalue_get_long shall fill in the long_value argument the int64_t value stored by the AMQP value indicated by the value argument.] */\n            *long_value = value_data->value.long_value;\n\n            /* Codes_SRS_AMQPVALUE_01_076: [On success amqpvalue_get_long shall return 0.] */\n            result = 0;\n        }\n    }\n\n    return result;\n}\n\n/* Codes_SRS_AMQPVALUE_01_019: [1.6.11 float 32-bit floating point number (IEEE 754-2008 binary32).]  */\nAMQP_VALUE amqpvalue_create_float(float value)\n{\n    AMQP_VALUE result = REFCOUNT_TYPE_CREATE(AMQP_VALUE_DATA);\n    if (result == NULL)\n    {\n        /* Codes_SRS_AMQPVALUE_01_081: [If allocating the AMQP_VALUE fails then amqpvalue_create_float shall return NULL.] */\n        LogError(\"Could not allocate memory for AMQP value\");\n    }\n    else\n    {\n        /* Codes_SRS_AMQPVALUE_01_080: [amqpvalue_create_float shall return a handle to an AMQP_VALUE that stores a float value.] */\n        result->type = AMQP_TYPE_FLOAT;\n        result->value.float_value = value;\n    }\n\n    return result;\n}\n\nint amqpvalue_get_float(AMQP_VALUE value, float* float_value)\n{\n    int result;\n\n    /* Codes_SRS_AMQPVALUE_01_084: [If any of the arguments is NULL then amqpvalue_get_float shall return a non-zero value.] */\n    if ((value == NULL) ||\n        (float_value == NULL))\n    {\n        LogError(\"Bad arguments: value = %p, float_value = %p\",\n            value, float_value);\n        result = MU_FAILURE;\n    }\n    else\n    {\n        AMQP_VALUE_DATA* value_data = (AMQP_VALUE_DATA*)value;\n        /* Codes_SRS_AMQPVALUE_01_085: [If the type of the value is not float (was not created with amqpvalue_create_float), then amqpvalue_get_float shall return a non-zero value.] */\n        if (value_data->type != AMQP_TYPE_FLOAT)\n        {\n            LogError(\"Value is not of type FLOAT\");\n            result = MU_FAILURE;\n        }\n        else\n        {\n            /* Codes_SRS_AMQPVALUE_01_082: [amqpvalue_get_float shall fill in the float_value argument the float value stored by the AMQP value indicated by the value argument.] */\n            *float_value = value_data->value.float_value;\n\n            /* Codes_SRS_AMQPVALUE_01_083: [On success amqpvalue_get_float shall return 0.] */\n            result = 0;\n        }\n    }\n\n    return result;\n}\n\n/* Codes_SRS_AMQPVALUE_01_020: [1.6.12 double 64-bit floating point number (IEEE 754-2008 binary64).] */\nAMQP_VALUE amqpvalue_create_double(double value)\n{\n    AMQP_VALUE result = REFCOUNT_TYPE_CREATE(AMQP_VALUE_DATA);\n    if (result == NULL)\n    {\n        /* Codes_SRS_AMQPVALUE_01_087: [If allocating the AMQP_VALUE fails then amqpvalue_create_double shall return NULL.] */\n        LogError(\"Could not allocate memory for AMQP value\");\n    }\n    else\n    {\n        /* Codes_SRS_AMQPVALUE_01_086: [amqpvalue_create_double shall return a handle to an AMQP_VALUE that stores a double value.] */\n        result->type = AMQP_TYPE_DOUBLE;\n        result->value.double_value = value;\n    }\n\n    return result;\n}\n\nint amqpvalue_get_double(AMQP_VALUE value, double* double_value)\n{\n    int result;\n\n    /* Codes_SRS_AMQPVALUE_01_090: [If any of the arguments is NULL then amqpvalue_get_double shall return a non-zero value.] */\n    if ((value == NULL) ||\n        (double_value == NULL))\n    {\n        LogError(\"Bad arguments: value = %p, double_value = %p\",\n            value, double_value);\n        result = MU_FAILURE;\n    }\n    else\n    {\n        AMQP_VALUE_DATA* value_data = (AMQP_VALUE_DATA*)value;\n        /* Codes_SRS_AMQPVALUE_01_091: [If the type of the value is not double (was not created with amqpvalue_create_double), then amqpvalue_get_double shall return a non-zero value.] */\n        if (value_data->type != AMQP_TYPE_DOUBLE)\n        {\n            LogError(\"Value is not of type DOUBLE\");\n            result = MU_FAILURE;\n        }\n        else\n        {\n            /* Codes_SRS_AMQPVALUE_01_088: [amqpvalue_get_double shall fill in the double_value argument the double value stored by the AMQP value indicated by the value argument.] */\n            *double_value = value_data->value.double_value;\n\n            /* Codes_SRS_AMQPVALUE_01_089: [On success amqpvalue_get_double shall return 0.] */\n            result = 0;\n        }\n    }\n\n    return result;\n}\n\n/* Codes_SRS_AMQPVALUE_01_024: [1.6.16 char A single Unicode character.] */\nAMQP_VALUE amqpvalue_create_char(uint32_t value)\n{\n    AMQP_VALUE result;\n\n    /* Codes_SRS_AMQPVALUE_01_098: [If the code point value is outside of the allowed range [0, 0x10FFFF] then amqpvalue_create_char shall return NULL.] */\n    if (value > 0x10FFFF)\n    {\n        LogError(\"Invalid value for a Unicode char\");\n        result = NULL;\n    }\n    else\n    {\n        result = REFCOUNT_TYPE_CREATE(AMQP_VALUE_DATA);\n        if (result == NULL)\n        {\n            /* Codes_SRS_AMQPVALUE_01_093: [If allocating the AMQP_VALUE fails then amqpvalue_create_char shall return NULL.] */\n            LogError(\"Could not allocate memory for AMQP value\");\n        }\n        else\n        {\n            /* Codes_SRS_AMQPVALUE_01_092: [amqpvalue_create_char shall return a handle to an AMQP_VALUE that stores a single UTF-32 character value.] */\n            result->type = AMQP_TYPE_CHAR;\n            result->value.char_value = value;\n        }\n    }\n\n    return result;\n}\n\nint amqpvalue_get_char(AMQP_VALUE value, uint32_t* char_value)\n{\n    int result;\n\n    /* Codes_SRS_AMQPVALUE_01_096: [If any of the arguments is NULL then amqpvalue_get_char shall return a non-zero value.] */\n    if ((value == NULL) ||\n        (char_value == NULL))\n    {\n        LogError(\"Bad arguments: value = %p, double_value = %p\",\n            value, char_value);\n        result = MU_FAILURE;\n    }\n    else\n    {\n        AMQP_VALUE_DATA* value_data = (AMQP_VALUE_DATA*)value;\n        /* Codes_SRS_AMQPVALUE_01_097: [If the type of the value is not char (was not created with amqpvalue_create_char), then amqpvalue_get_char shall return a non-zero value.] */\n        if (value_data->type != AMQP_TYPE_CHAR)\n        {\n            LogError(\"Value is not of type CHAR\");\n            result = MU_FAILURE;\n        }\n        else\n        {\n            /* Codes_SRS_AMQPVALUE_01_094: [amqpvalue_get_char shall fill in the char_value argument the UTF32 char value stored by the AMQP value indicated by the value argument.] */\n            *char_value = value_data->value.char_value;\n\n            /* Codes_SRS_AMQPVALUE_01_095: [On success amqpvalue_get_char shall return 0.] */\n            result = 0;\n        }\n    }\n\n    return result;\n}\n\n/* Codes_SRS_AMQPVALUE_01_025: [1.6.17 timestamp An absolute point in time.] */\nAMQP_VALUE amqpvalue_create_timestamp(int64_t value)\n{\n    AMQP_VALUE result = REFCOUNT_TYPE_CREATE(AMQP_VALUE_DATA);\n    if (result == NULL)\n    {\n        /* Codes_SRS_AMQPVALUE_01_108: [If allocating the AMQP_VALUE fails then amqpvalue_create_timestamp shall return NULL.] */\n        LogError(\"Could not allocate memory for AMQP value\");\n    }\n    else\n    {\n        /* Codes_SRS_AMQPVALUE_01_107: [amqpvalue_create_timestamp shall return a handle to an AMQP_VALUE that stores an uint64_t value that represents a millisecond precision Unix time.] */\n        result->type = AMQP_TYPE_TIMESTAMP;\n        result->value.timestamp_value = value;\n    }\n\n    return result;\n}\n\nint amqpvalue_get_timestamp(AMQP_VALUE value, int64_t* timestamp_value)\n{\n    int result;\n\n    /* Codes_SRS_AMQPVALUE_01_111: [If any of the arguments is NULL then amqpvalue_get_timestamp shall return a non-zero value.] */\n    if ((value == NULL) ||\n        (timestamp_value == NULL))\n    {\n        LogError(\"Bad arguments: value = %p, timestamp_value = %p\",\n            value, timestamp_value);\n        result = MU_FAILURE;\n    }\n    else\n    {\n        AMQP_VALUE_DATA* value_data = (AMQP_VALUE_DATA*)value;\n        /* Codes_SRS_AMQPVALUE_01_112: [If the type of the value is not timestamp (was not created with amqpvalue_create_timestamp), then amqpvalue_get_timestamp shall return a non-zero value.] */\n        if (value_data->type != AMQP_TYPE_TIMESTAMP)\n        {\n            LogError(\"Value is not of type TIMESTAMP\");\n            result = MU_FAILURE;\n        }\n        else\n        {\n            /* Codes_SRS_AMQPVALUE_01_109: [amqpvalue_get_timestamp shall fill in the timestamp_value argument the timestamp value stored by the AMQP value indicated by the value argument.] */\n            *timestamp_value = value_data->value.timestamp_value;\n\n            /* Codes_SRS_AMQPVALUE_01_110: [On success amqpvalue_get_timestamp shall return 0.] */\n            result = 0;\n        }\n    }\n\n    return result;\n}\n\n/* Codes_SRS_AMQPVALUE_01_026: [1.6.18 uuid A universally unique identifier as defined by RFC-4122 section 4.1.2 .] */\nAMQP_VALUE amqpvalue_create_uuid(uuid value)\n{\n    AMQP_VALUE result = REFCOUNT_TYPE_CREATE(AMQP_VALUE_DATA);\n    if (result == NULL)\n    {\n        /* Codes_SRS_AMQPVALUE_01_114: [If allocating the AMQP_VALUE fails then amqpvalue_create_uuid shall return NULL.] */\n        LogError(\"Could not allocate memory for AMQP value\");\n    }\n    else\n    {\n        /* Codes_SRS_AMQPVALUE_01_113: [amqpvalue_create_uuid shall return a handle to an AMQP_VALUE that stores an uuid value that represents a unique identifier per RFC-4122 section 4.1.2.] */\n        result->type = AMQP_TYPE_UUID;\n        (void)memcpy(&result->value.uuid_value, value, 16);\n    }\n\n    return result;\n}\n\nint amqpvalue_get_uuid(AMQP_VALUE value, uuid* uuid_value)\n{\n    int result;\n\n    /* Codes_SRS_AMQPVALUE_01_117: [If any of the arguments is NULL then amqpvalue_get_uuid shall return a non-zero value.] */\n    if ((value == NULL) ||\n        (uuid_value == NULL))\n    {\n        LogError(\"Bad arguments: value = %p, uuid_value = %p\",\n            value, uuid_value);\n        result = MU_FAILURE;\n    }\n    else\n    {\n        AMQP_VALUE_DATA* value_data = (AMQP_VALUE_DATA*)value;\n        /* Codes_SRS_AMQPVALUE_01_118: [If the type of the value is not uuid (was not created with amqpvalue_create_uuid), then amqpvalue_get_uuid shall return a non-zero value.] */\n        if (value_data->type != AMQP_TYPE_UUID)\n        {\n            LogError(\"Value is not of type UUID\");\n            result = MU_FAILURE;\n        }\n        else\n        {\n            /* Codes_SRS_AMQPVALUE_01_115: [amqpvalue_get_uuid shall fill in the uuid_value argument the uuid value stored by the AMQP value indicated by the value argument.] */\n            (void)memcpy(*uuid_value, value_data->value.uuid_value, 16);\n\n            /* Codes_SRS_AMQPVALUE_01_116: [On success amqpvalue_get_uuid shall return 0.] */\n            result = 0;\n        }\n    }\n\n    return result;\n}\n\n/* Codes_SRS_AMQPVALUE_01_027: [1.6.19 binary A sequence of octets.] */\nAMQP_VALUE amqpvalue_create_binary(amqp_binary value)\n{\n    AMQP_VALUE result;\n    if ((value.bytes == NULL) &&\n        (value.length > 0))\n    {\n        /* Codes_SRS_AMQPVALUE_01_129: [If value.data is NULL and value.length is positive then amqpvalue_create_binary shall return NULL.] */\n        LogError(\"NULL bytes with non-zero length\");\n        result = NULL;\n    }\n    else\n    {\n        result = REFCOUNT_TYPE_CREATE(AMQP_VALUE_DATA);\n        if (result == NULL)\n        {\n            /* Codes_SRS_AMQPVALUE_01_128: [If allocating the AMQP_VALUE fails then amqpvalue_create_binary shall return NULL.] */\n            LogError(\"Could not allocate memory for AMQP value\");\n        }\n        else\n        {\n            /* Codes_SRS_AMQPVALUE_01_127: [amqpvalue_create_binary shall return a handle to an AMQP_VALUE that stores a sequence of bytes.] */\n            result->type = AMQP_TYPE_BINARY;\n            if (value.length > 0)\n            {\n                result->value.binary_value.bytes = malloc(value.length);\n            }\n            else\n            {\n                result->value.binary_value.bytes = NULL;\n            }\n\n            result->value.binary_value.length = value.length;\n\n            if ((result->value.binary_value.bytes == NULL) && (value.length > 0))\n            {\n                /* Codes_SRS_AMQPVALUE_01_128: [If allocating the AMQP_VALUE fails then amqpvalue_create_binary shall return NULL.] */\n                LogError(\"Could not allocate memory for binary payload of AMQP value\");\n                REFCOUNT_TYPE_DESTROY(AMQP_VALUE_DATA, result);\n                result = NULL;\n            }\n            else\n            {\n                if (value.length > 0)\n                {\n                    (void)memcpy((void*)result->value.binary_value.bytes, value.bytes, value.length);\n                }\n            }\n        }\n    }\n\n    return result;\n}\n\nint amqpvalue_get_binary(AMQP_VALUE value, amqp_binary* binary_value)\n{\n    int result;\n\n    /* Codes_SRS_AMQPVALUE_01_132: [If any of the arguments is NULL then amqpvalue_get_binary shall return NULL.] */\n    if ((value == NULL) ||\n        (binary_value == NULL))\n    {\n        LogError(\"Bad arguments: value = %p, binary_value = %p\",\n            value, binary_value);\n        result = MU_FAILURE;\n    }\n    else\n    {\n        AMQP_VALUE_DATA* value_data = (AMQP_VALUE_DATA*)value;\n        /* Codes_SRS_AMQPVALUE_01_133: [If the type of the value is not binary (was not created with amqpvalue_create_binary), then amqpvalue_get_binary shall return NULL.] */\n        if (value_data->type != AMQP_TYPE_BINARY)\n        {\n            LogError(\"Value is not of type BINARY\");\n            result = MU_FAILURE;\n        }\n        else\n        {\n            /* Codes_SRS_AMQPVALUE_01_131: [amqpvalue_get_binary shall yield a pointer to the sequence of bytes held by the AMQP_VALUE in binary_value.data and fill in the binary_value.length argument the number of bytes held in the binary value.] */\n            binary_value->length = value_data->value.binary_value.length;\n            binary_value->bytes = value_data->value.binary_value.bytes;\n\n            result = 0;\n        }\n    }\n\n    return result;\n}\n\n/* Codes_SRS_AMQPVALUE_01_135: [amqpvalue_create_string shall return a handle to an AMQP_VALUE that stores a sequence of Unicode characters.] */\n/* Codes_SRS_AMQPVALUE_01_028: [1.6.20 string A sequence of Unicode characters.] */\nAMQP_VALUE amqpvalue_create_string(const char* value)\n{\n    AMQP_VALUE result;\n    if (value == NULL)\n    {\n        LogError(\"NULL argument value\");\n        result = NULL;\n    }\n    else\n    {\n        size_t length = strlen(value);\n\n        result = REFCOUNT_TYPE_CREATE(AMQP_VALUE_DATA);\n        if (result == NULL)\n        {\n            /* Codes_SRS_AMQPVALUE_01_136: [If allocating the AMQP_VALUE fails then amqpvalue_create_string shall return NULL.] */\n            LogError(\"Could not allocate memory for AMQP value\");\n        }\n        else\n        {\n            result->type = AMQP_TYPE_STRING;\n            result->value.string_value.chars = (char*)malloc(length + 1);\n            if (result->value.string_value.chars == NULL)\n            {\n                /* Codes_SRS_AMQPVALUE_01_136: [If allocating the AMQP_VALUE fails then amqpvalue_create_string shall return NULL.] */\n                LogError(\"Could not allocate memory for string AMQP value\");\n                REFCOUNT_TYPE_DESTROY(AMQP_VALUE_DATA, result);\n                result = NULL;\n            }\n            else\n            {\n                (void)memcpy(result->value.string_value.chars, value, length + 1);\n            }\n        }\n    }\n\n    return result;\n}\n\nint amqpvalue_get_string(AMQP_VALUE value, const char** string_value)\n{\n    int result;\n\n    /* Codes_SRS_AMQPVALUE_01_139: [If any of the arguments is NULL then amqpvalue_get_string shall return a non-zero value.] */\n    if ((value == NULL) ||\n        (string_value == NULL))\n    {\n        LogError(\"Bad arguments: value = %p, string_value = %p\",\n            value, string_value);\n        result = MU_FAILURE;\n    }\n    else\n    {\n        AMQP_VALUE_DATA* value_data = (AMQP_VALUE_DATA*)value;\n\n        /* Codes_SRS_AMQPVALUE_01_140: [If the type of the value is not string (was not created with amqpvalue_create_string), then amqpvalue_get_string shall return a non-zero value.] */\n        if (value_data->type != AMQP_TYPE_STRING)\n        {\n            LogError(\"Value is not of type STRING\");\n            result = MU_FAILURE;\n        }\n        else\n        {\n            /* Codes_SRS_AMQPVALUE_01_138: [amqpvalue_get_string shall yield a pointer to the sequence of bytes held by the AMQP_VALUE in string_value.] */\n            *string_value = value_data->value.string_value.chars;\n\n            /* Codes_SRS_AMQPVALUE_01_141: [On success, amqpvalue_get_string shall return 0.] */\n            result = 0;\n        }\n    }\n\n    return result;\n}\n\n/* Codes_SRS_AMQPVALUE_01_029: [1.6.21 symbol Symbolic values from a constrained domain.] */\nAMQP_VALUE amqpvalue_create_symbol(const char* value)\n{\n    AMQP_VALUE result;\n    if (value == NULL)\n    {\n        /* Codes_SRS_AMQPVALUE_01_400: [If value is NULL, amqpvalue_create_symbol shall fail and return NULL.] */\n        LogError(\"NULL argument\");\n        result = NULL;\n    }\n    else\n    {\n        size_t length = strlen(value);\n        if (length > UINT32_MAX)\n        {\n            /* Codes_SRS_AMQPVALUE_01_401: [ If the string pointed to by value is longer than 2^32-1 then amqpvalue_create_symbol shall return NULL. ]*/\n            LogError(\"string too long to be represented as a symbol\");\n            result = NULL;\n        }\n        else\n        {\n            /* Codes_SRS_AMQPVALUE_01_143: [If allocating the AMQP_VALUE fails then amqpvalue_create_symbol shall return NULL.] */\n            result = REFCOUNT_TYPE_CREATE(AMQP_VALUE_DATA);\n            if (result == NULL)\n            {\n                LogError(\"Cannot allocate memory for AMQP value\");\n                result = NULL;\n            }\n            else\n            {\n                /* Codes_SRS_AMQPVALUE_01_142: [amqpvalue_create_symbol shall return a handle to an AMQP_VALUE that stores a symbol (ASCII string) value.] */\n                result->type = AMQP_TYPE_SYMBOL;\n                result->value.symbol_value.chars = (char*)malloc(length + 1);\n                if (result->value.symbol_value.chars == NULL)\n                {\n                    LogError(\"Cannot allocate memory for symbol string\");\n                    REFCOUNT_TYPE_DESTROY(AMQP_VALUE_DATA, result);\n                    result = NULL;\n                }\n                else\n                {\n                    (void)memcpy(result->value.symbol_value.chars, value, length + 1);\n                }\n            }\n        }\n    }\n\n    return result;\n}\n\nint amqpvalue_get_symbol(AMQP_VALUE value, const char** symbol_value)\n{\n    int result;\n\n    /* Codes_SRS_AMQPVALUE_01_147: [If any of the arguments is NULL then amqpvalue_get_symbol shall return a non-zero value.] */\n    if ((value == NULL) ||\n        (symbol_value == NULL))\n    {\n        LogError(\"Bad arguments: value = %p, symbol_value = %p\",\n            value, symbol_value);\n        result = MU_FAILURE;\n    }\n    else\n    {\n        AMQP_VALUE_DATA* value_data = (AMQP_VALUE_DATA*)value;\n\n        /* Codes_SRS_AMQPVALUE_01_148: [If the type of the value is not symbol (was not created with amqpvalue_create_symbol), then amqpvalue_get_symbol shall return a non-zero value.] */\n        if (value_data->type != AMQP_TYPE_SYMBOL)\n        {\n            LogError(\"Value is not of type SYMBOL\");\n            result = MU_FAILURE;\n        }\n        else\n        {\n            /* Codes_SRS_AMQPVALUE_01_145: [amqpvalue_get_symbol shall fill in the symbol_value the symbol value string held by the AMQP_VALUE.] */\n            *symbol_value = value_data->value.symbol_value.chars;\n\n            /* Codes_SRS_AMQPVALUE_01_146: [On success, amqpvalue_get_symbol shall return 0.] */\n            result = 0;\n        }\n    }\n\n    return result;\n}\n\n/* Codes_SRS_AMQPVALUE_01_030: [1.6.22 list A sequence of polymorphic values.] */\nAMQP_VALUE amqpvalue_create_list(void)\n{\n    AMQP_VALUE result = REFCOUNT_TYPE_CREATE(AMQP_VALUE_DATA);\n    if (result == NULL)\n    {\n        /* Codes_SRS_AMQPVALUE_01_150: [If allocating the AMQP_VALUE fails then amqpvalue_create_list shall return NULL.] */\n        LogError(\"Could not allocate memory for AMQP value\");\n    }\n    else\n    {\n        /* Codes_SRS_AMQPVALUE_01_149: [amqpvalue_create_list shall return a handle to an AMQP_VALUE that stores a list.] */\n        result->type = AMQP_TYPE_LIST;\n\n        /* Codes_SRS_AMQPVALUE_01_151: [The list shall have an initial size of zero.] */\n        result->value.list_value.count = 0;\n        result->value.list_value.items = NULL;\n    }\n\n    return result;\n}\n\nint amqpvalue_set_list_item_count(AMQP_VALUE value, uint32_t list_size)\n{\n    int result;\n\n    /* Codes_SRS_AMQPVALUE_01_155: [If the value argument is NULL, amqpvalue_set_list_item_count shall return a non-zero value.] */\n    if (value == NULL)\n    {\n        LogError(\"NULL list value\");\n        result = MU_FAILURE;\n    }\n    else\n    {\n        AMQP_VALUE_DATA* value_data = (AMQP_VALUE_DATA*)value;\n        if (value_data->type != AMQP_TYPE_LIST)\n        {\n            /* Codes_SRS_AMQPVALUE_01_156: [If the value is not of type list, then amqpvalue_set_list_item_count shall return a non-zero value.] */\n            LogError(\"Value is not of type LIST\");\n            result = MU_FAILURE;\n        }\n        else\n        {\n            if (value_data->value.list_value.count < list_size)\n            {\n                AMQP_VALUE* new_list;\n\n                /* Codes_SRS_AMQPVALUE_01_152: [amqpvalue_set_list_item_count shall resize an AMQP list.] */\n                new_list = (AMQP_VALUE*)realloc(value_data->value.list_value.items, list_size * sizeof(AMQP_VALUE));\n                if (new_list == NULL)\n                {\n                    /* Codes_SRS_AMQPVALUE_01_154: [If allocating memory for the list according to the new size fails, then amqpvalue_set_list_item_count shall return a non-zero value, while preserving the existing list contents.] */\n                    LogError(\"Could not reallocate list memory\");\n                    result = MU_FAILURE;\n                }\n                else\n                {\n                    uint32_t i;\n                    value_data->value.list_value.items = new_list;\n\n                    /* Codes_SRS_AMQPVALUE_01_162: [When a list is grown a null AMQP_VALUE shall be inserted as new list items to fill the list up to the new size.] */\n                    for (i = value_data->value.list_value.count; i < list_size; i++)\n                    {\n                        new_list[i] = amqpvalue_create_null();\n                        if (new_list[i] == NULL)\n                        {\n                            LogError(\"Could not create NULL AMQP value to be inserted in list\");\n                            break;\n                        }\n                    }\n\n                    if (i < list_size)\n                    {\n                        /* Codes_SRS_AMQPVALUE_01_154: [If allocating memory for the list according to the new size fails, then amqpvalue_set_list_item_count shall return a non-zero value, while preserving the existing list contents.] */\n                        uint32_t j;\n                        for (j = value_data->value.list_value.count; j < i; j++)\n                        {\n                            amqpvalue_destroy(new_list[j]);\n                        }\n\n                        result = MU_FAILURE;\n                    }\n                    else\n                    {\n                        value_data->value.list_value.count = list_size;\n\n                        /* Codes_SRS_AMQPVALUE_01_153: [On success amqpvalue_set_list_item_count shall return 0.] */\n                        result = 0;\n                    }\n                }\n            }\n            else if (value_data->value.list_value.count > list_size)\n            {\n                uint32_t i;\n\n                /* Codes_SRS_AMQPVALUE_01_161: [When the list is shrunk, the extra items shall be freed by using amqp_value_destroy.] */\n                for (i = list_size; i < value_data->value.list_value.count; i++)\n                {\n                    amqpvalue_destroy(value_data->value.list_value.items[i]);\n                }\n\n                value_data->value.list_value.count = list_size;\n\n                /* Codes_SRS_AMQPVALUE_01_153: [On success amqpvalue_set_list_item_count shall return 0.] */\n                result = 0;\n            }\n            else\n            {\n                /* Codes_SRS_AMQPVALUE_01_153: [On success amqpvalue_set_list_item_count shall return 0.] */\n                result = 0;\n            }\n        }\n    }\n\n    return result;\n}\n\nint amqpvalue_get_list_item_count(AMQP_VALUE value, uint32_t* size)\n{\n    int result;\n\n    /* Codes_SRS_AMQPVALUE_01_159: [If any of the arguments are NULL, amqpvalue_get_list_item_count shall return a non-zero value.] */\n    if ((value == NULL) ||\n        (size == NULL))\n    {\n        LogError(\"Bad arguments: value = %p, size = %p\",\n            value, size);\n        result = MU_FAILURE;\n    }\n    else\n    {\n        AMQP_VALUE_DATA* value_data = (AMQP_VALUE_DATA*)value;\n\n        /* Codes_SRS_AMQPVALUE_01_160: [If the AMQP_VALUE is not a list then amqpvalue_get_list_item_count shall return a non-zero value.] */\n        if (value_data->type != AMQP_TYPE_LIST)\n        {\n            LogError(\"Value is not of type LIST\");\n            result = MU_FAILURE;\n        }\n        else\n        {\n            /* Codes_SRS_AMQPVALUE_01_157: [amqpvalue_get_list_item_count shall fill in the size argument the number of items held by the AMQP list.] */\n            *size = value_data->value.list_value.count;\n\n            /* Codes_SRS_AMQPVALUE_01_158: [On success amqpvalue_get_list_item_count shall return 0.] */\n            result = 0;\n        }\n    }\n\n    return result;\n}\n\nint amqpvalue_set_list_item(AMQP_VALUE value, uint32_t index, AMQP_VALUE list_item_value)\n{\n    int result;\n\n    /* Codes_SRS_AMQPVALUE_01_165: [If value or list_item_value is NULL, amqpvalue_set_list_item shall fail and return a non-zero value.] */\n    if (value == NULL)\n    {\n        LogError(\"NULL list value\");\n        result = MU_FAILURE;\n    }\n    else\n    {\n        AMQP_VALUE_DATA* value_data = (AMQP_VALUE_DATA*)value;\n        if (value_data->type != AMQP_TYPE_LIST)\n        {\n            LogError(\"Value is not of type LIST\");\n            result = MU_FAILURE;\n        }\n        else\n        {\n            /* Codes_SRS_AMQPVALUE_01_168: [The item stored at the index-th position in the list shall be a clone of list_item_value.] */\n            AMQP_VALUE cloned_item = amqpvalue_clone(list_item_value);\n            if (cloned_item == NULL)\n            {\n                /* Codes_SRS_AMQPVALUE_01_170: [When amqpvalue_set_list_item fails due to not being able to clone the item or grow the list, the list shall not be altered.] */\n                /* Codes_SRS_AMQPVALUE_01_169: [If cloning the item fails, amqpvalue_set_list_item shall fail and return a non-zero value.] */\n                LogError(\"Could not clone list item\");\n                result = MU_FAILURE;\n            }\n            else\n            {\n                if (index >= value_data->value.list_value.count)\n                {\n                    AMQP_VALUE* new_list = (AMQP_VALUE*)realloc(value_data->value.list_value.items, ((size_t)index + 1) * sizeof(AMQP_VALUE));\n                    if (new_list == NULL)\n                    {\n                        /* Codes_SRS_AMQPVALUE_01_170: [When amqpvalue_set_list_item fails due to not being able to clone the item or grow the list, the list shall not be altered.] */\n                        LogError(\"Could not reallocate list storage\");\n                        amqpvalue_destroy(cloned_item);\n                        result = MU_FAILURE;\n                    }\n                    else\n                    {\n                        uint32_t i;\n\n                        value_data->value.list_value.items = new_list;\n\n                        for (i = value_data->value.list_value.count; i < index; i++)\n                        {\n                            new_list[i] = amqpvalue_create_null();\n                            if (new_list[i] == NULL)\n                            {\n                                LogError(\"Could not allocate NULL value for list entries\");\n                                break;\n                            }\n                        }\n\n                        if (i < index)\n                        {\n                            /* Codes_SRS_AMQPVALUE_01_170: [When amqpvalue_set_list_item fails due to not being able to clone the item or grow the list, the list shall not be altered.] */\n                            uint32_t j;\n\n                            for (j = value_data->value.list_value.count; j < i; j++)\n                            {\n                                amqpvalue_destroy(new_list[j]);\n                            }\n\n                            amqpvalue_destroy(cloned_item);\n\n                            /* Codes_SRS_AMQPVALUE_01_172: [If growing the list fails, then amqpvalue_set_list_item shall fail and return a non-zero value.] */\n                            result = MU_FAILURE;\n                        }\n                        else\n                        {\n                            value_data->value.list_value.count = index + 1;\n                            value_data->value.list_value.items[index] = cloned_item;\n\n                            /* Codes_SRS_AMQPVALUE_01_164: [On success amqpvalue_set_list_item shall return 0.] */\n                            result = 0;\n                        }\n                    }\n                }\n                else\n                {\n                    /* Codes_SRS_AMQPVALUE_01_167: [Any previous value stored at the position index in the list shall be freed by using amqpvalue_destroy.] */\n                    amqpvalue_destroy(value_data->value.list_value.items[index]);\n\n                    /* Codes_SRS_AMQPVALUE_01_163: [amqpvalue_set_list_item shall replace the item at the 0 based index-th position in the list identified by the value argument with the AMQP_VALUE specified by list_item_value.] */\n                    value_data->value.list_value.items[index] = cloned_item;\n\n                    /* Codes_SRS_AMQPVALUE_01_164: [On success amqpvalue_set_list_item shall return 0.] */\n                    result = 0;\n                }\n            }\n        }\n    }\n\n    return result;\n}\n\nAMQP_VALUE amqpvalue_get_list_item(AMQP_VALUE value, size_t index)\n{\n    AMQP_VALUE result;\n\n    if (value == NULL)\n    {\n        /* Codes_SRS_AMQPVALUE_01_174: [If the value argument is NULL, amqpvalue_get_list_item shall fail and return NULL.] */\n        LogError(\"NULL list value\");\n        result = NULL;\n    }\n    else\n    {\n        AMQP_VALUE_DATA* value_data = (AMQP_VALUE_DATA*)value;\n\n        /* Codes_SRS_AMQPVALUE_01_177: [If value is not a list then amqpvalue_get_list_item shall fail and return NULL.] */\n        if (value_data->type != AMQP_TYPE_LIST)\n        {\n            LogError(\"Value is not of type LIST\");\n            result = NULL;\n        }\n        /* Codes_SRS_AMQPVALUE_01_175: [If index is greater or equal to the number of items in the list then amqpvalue_get_list_item shall fail and return NULL.] */\n        else if (value_data->value.list_value.count <= index)\n        {\n            LogError(\"Bad index value %u\", (unsigned int)index);\n            result = NULL;\n        }\n        else\n        {\n            /* Codes_SRS_AMQPVALUE_01_173: [amqpvalue_get_list_item shall return a copy of the AMQP_VALUE stored at the 0 based position index in the list identified by value.] */\n            /* Codes_SRS_AMQPVALUE_01_176: [If cloning the item at position index fails, then amqpvalue_get_list_item shall fail and return NULL.] */\n            result = amqpvalue_clone(value_data->value.list_value.items[index]);\n        }\n    }\n\n    return result;\n}\n\n/* Codes_SRS_AMQPVALUE_01_178: [amqpvalue_create_map shall create an AMQP value that holds a map and return a handle to it.] */\n/* Codes_SRS_AMQPVALUE_01_031: [1.6.23 map A polymorphic mapping from distinct keys to values.] */\nAMQP_VALUE amqpvalue_create_map(void)\n{\n    AMQP_VALUE result = REFCOUNT_TYPE_CREATE(AMQP_VALUE_DATA);\n    if (result == NULL)\n    {\n        /* Codes_SRS_AMQPVALUE_01_179: [If allocating memory for the map fails, then amqpvalue_create_map shall return NULL.] */\n        LogError(\"Could not allocate memory for AMQP value\");\n    }\n    else\n    {\n        result->type = AMQP_TYPE_MAP;\n\n        /* Codes_SRS_AMQPVALUE_01_180: [The number of key/value pairs in the newly created map shall be zero.] */\n        result->value.map_value.pairs = NULL;\n        result->value.map_value.pair_count = 0;\n    }\n\n    return result;\n}\n\nint amqpvalue_set_map_value(AMQP_VALUE map, AMQP_VALUE key, AMQP_VALUE value)\n{\n    int result;\n\n    /* Codes_SRS_AMQPVALUE_01_183: [If any of the arguments are NULL, amqpvalue_set_map_value shall fail and return a non-zero value.] */\n    if ((map == NULL) ||\n        (key == NULL) ||\n        (value == NULL))\n    {\n        LogError(\"Bad arguments: map = %p, key = %p, value = %p\",\n            map, key, value);\n        result = MU_FAILURE;\n    }\n    else\n    {\n        AMQP_VALUE_DATA* value_data = (AMQP_VALUE_DATA*)map;\n\n        /* Codes_SRS_AMQPVALUE_01_196: [If the map argument is not an AMQP value created with the amqpvalue_create_map function than amqpvalue_set_map_value shall fail and return a non-zero value.] */\n        if (value_data->type != AMQP_TYPE_MAP)\n        {\n            LogError(\"Value is not of type MAP\");\n            result = MU_FAILURE;\n        }\n        else\n        {\n            AMQP_VALUE cloned_value;\n\n            /* Codes_SRS_AMQPVALUE_01_185: [When storing the key or value, their contents shall be cloned.] */\n            cloned_value = amqpvalue_clone(value);\n            if (cloned_value == NULL)\n            {\n                /* Codes_SRS_AMQPVALUE_01_188: [If cloning the value fails, amqpvalue_set_map_value shall fail and return a non-zero value.] */\n                LogError(\"Could not clone value to set in the map\");\n                result = MU_FAILURE;\n            }\n            else\n            {\n                uint32_t i;\n                AMQP_VALUE cloned_key;\n\n                for (i = 0; i < value_data->value.map_value.pair_count; i++)\n                {\n                    if (amqpvalue_are_equal(value_data->value.map_value.pairs[i].key, key))\n                    {\n                        LogError(\"Could not allocate NULL value for map entries\");\n                        break;\n                    }\n                }\n\n                if (i < value_data->value.map_value.pair_count)\n                {\n                    /* Codes_SRS_AMQPVALUE_01_184: [If the key already exists in the map, its value shall be replaced with the value provided by the value argument.] */\n                    /* Codes_SRS_AMQPVALUE_01_125: [A map in which there exist two identical key values is invalid.] */\n                    amqpvalue_destroy(value_data->value.map_value.pairs[i].value);\n                    value_data->value.map_value.pairs[i].value = cloned_value;\n\n                    /* Codes_SRS_AMQPVALUE_01_182: [On success amqpvalue_set_map_value shall return 0.] */\n                    result = 0;\n                }\n                else\n                {\n                    /* Codes_SRS_AMQPVALUE_01_185: [When storing the key or value, their contents shall be cloned.] */\n                    cloned_key = amqpvalue_clone(key);\n                    if (cloned_key == NULL)\n                    {\n                        /* Codes_SRS_AMQPVALUE_01_187: [If cloning the key fails, amqpvalue_set_map_value shall fail and return a non-zero value.] */\n                        amqpvalue_destroy(cloned_value);\n                        LogError(\"Could not clone key for map\");\n                        result = MU_FAILURE;\n                    }\n                    else\n                    {\n                        AMQP_MAP_KEY_VALUE_PAIR* new_pairs = (AMQP_MAP_KEY_VALUE_PAIR*)realloc(value_data->value.map_value.pairs, ((size_t)value_data->value.map_value.pair_count + 1) * sizeof(AMQP_MAP_KEY_VALUE_PAIR));\n                        if (new_pairs == NULL)\n                        {\n                            /* Codes_SRS_AMQPVALUE_01_186: [If allocating memory to hold a new key/value pair fails, amqpvalue_set_map_value shall fail and return a non-zero value.] */\n                            amqpvalue_destroy(cloned_key);\n                            amqpvalue_destroy(cloned_value);\n                            LogError(\"Could not reallocate memory for map\");\n                            result = MU_FAILURE;\n                        }\n                        else\n                        {\n                            value_data->value.map_value.pairs = new_pairs;\n\n                            /* Codes_SRS_AMQPVALUE_01_181: [amqpvalue_set_map_value shall set the value in the map identified by the map argument for a key/value pair identified by the key argument.] */\n                            value_data->value.map_value.pairs[value_data->value.map_value.pair_count].key = cloned_key;\n                            value_data->value.map_value.pairs[value_data->value.map_value.pair_count].value = cloned_value;\n                            value_data->value.map_value.pair_count++;\n\n                            /* Codes_SRS_AMQPVALUE_01_182: [On success amqpvalue_set_map_value shall return 0.] */\n                            result = 0;\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    return result;\n}\n\nAMQP_VALUE amqpvalue_get_map_value(AMQP_VALUE map, AMQP_VALUE key)\n{\n    AMQP_VALUE result;\n\n    /* Codes_SRS_AMQPVALUE_01_190: [If any argument is NULL, amqpvalue_get_map_value shall return NULL.] */\n    if ((map == NULL) ||\n        (key == NULL))\n    {\n        LogError(\"Bad arguments: map = %p, key = %p\",\n            map, key);\n        result = NULL;\n    }\n    else\n    {\n        AMQP_VALUE_DATA* value_data = (AMQP_VALUE_DATA*)map;\n\n        /* Codes_SRS_AMQPVALUE_01_197: [If the map argument is not an AMQP value created with the amqpvalue_create_map function than amqpvalue_get_map_value shall return NULL.] */\n        if (value_data->type != AMQP_TYPE_MAP)\n        {\n            LogError(\"Value is not of type MAP\");\n            result = NULL;\n        }\n        else\n        {\n            uint32_t i;\n\n            for (i = 0; i < value_data->value.map_value.pair_count; i++)\n            {\n                if (amqpvalue_are_equal(value_data->value.map_value.pairs[i].key, key))\n                {\n                    break;\n                }\n            }\n\n            if (i == value_data->value.map_value.pair_count)\n            {\n                /* Codes_SRS_AMQPVALUE_01_191: [If the key cannot be found, amqpvalue_get_map_value shall return NULL.] */\n                result = NULL;\n            }\n            else\n            {\n                /* Codes_SRS_AMQPVALUE_01_189: [amqpvalue_get_map_value shall return the value whose key is identified by the key argument.] */\n                /* Codes_SRS_AMQPVALUE_01_192: [The returned value shall be a clone of the actual value stored in the map.] */\n                result = amqpvalue_clone(value_data->value.map_value.pairs[i].value);\n            }\n        }\n    }\n\n    return result;\n}\n\nint amqpvalue_get_map_pair_count(AMQP_VALUE map, uint32_t* pair_count)\n{\n    int result;\n\n    /* Codes_SRS_AMQPVALUE_01_195: [If any of the arguments is NULL, amqpvalue_get_map_pair_count shall fail and return a non-zero value.] */\n    if ((map == NULL) ||\n        (pair_count == NULL))\n    {\n        LogError(\"Bad arguments: map = %p, pair_count = %p\",\n            map, pair_count);\n        result = MU_FAILURE;\n    }\n    else\n    {\n        AMQP_VALUE_DATA* value_data = (AMQP_VALUE_DATA*)map;\n\n        if (value_data->type != AMQP_TYPE_MAP)\n        {\n            /* Codes_SRS_AMQPVALUE_01_198: [If the map argument is not an AMQP value created with the amqpvalue_create_map function then amqpvalue_get_map_pair_count shall fail and return a non-zero value.] */\n            LogError(\"Value is not of type MAP\");\n            result = MU_FAILURE;\n        }\n        else\n        {\n            /* Codes_SRS_AMQPVALUE_01_193: [amqpvalue_get_map_pair_count shall fill in the number of key/value pairs in the map in the pair_count argument.] */\n            *pair_count = value_data->value.map_value.pair_count;\n\n            /* Codes_SRS_AMQPVALUE_01_194: [On success amqpvalue_get_map_pair_count shall return 0.] */\n            result = 0;\n        }\n    }\n\n    return result;\n}\n\nint amqpvalue_get_map_key_value_pair(AMQP_VALUE map, uint32_t index, AMQP_VALUE* key, AMQP_VALUE* value)\n{\n    int result;\n\n    /* Codes_SRS_AMQPVALUE_01_201: [If any of the map, key or value arguments is NULL, amqpvalue_get_map_key_value_pair shall fail and return a non-zero value.] */\n    if ((map == NULL) ||\n        (key == NULL) ||\n        (value == NULL))\n    {\n        LogError(\"Bad arguments: map = %p, key = %p, value = %p\",\n            map, key, value);\n        result = MU_FAILURE;\n    }\n    else\n    {\n        AMQP_VALUE_DATA* value_data = (AMQP_VALUE_DATA*)map;\n\n        if (value_data->type != AMQP_TYPE_MAP)\n        {\n            /* Codes_SRS_AMQPVALUE_01_205: [If the map argument is not an AMQP value created with the amqpvalue_create_map function then amqpvalue_get_map_key_value_pair shall fail and return a non-zero value.] */\n            LogError(\"Value is not of type MAP\");\n            result = MU_FAILURE;\n        }\n        else if (value_data->value.map_value.pair_count <= index)\n        {\n            /* Codes_SRS_AMQPVALUE_01_204: [If the index argument is greater or equal to the number of key/value pairs in the map then amqpvalue_get_map_key_value_pair shall fail and return a non-zero value.] */\n            LogError(\"Index out of range: %u\", (unsigned int)index);\n            result = MU_FAILURE;\n        }\n        else\n        {\n            /* Codes_SRS_AMQPVALUE_01_199: [amqpvalue_get_map_key_value_pair shall fill in the key and value arguments copies of the key/value pair on the 0 based position index in a map.] */\n            *key = amqpvalue_clone(value_data->value.map_value.pairs[index].key);\n            if (*key == NULL)\n            {\n                /* Codes_SRS_AMQPVALUE_01_202: [If cloning the key fails, amqpvalue_get_map_key_value_pair shall fail and return a non-zero value.] */\n                LogError(\"Could not clone index %u key\", (unsigned int)index);\n                result = MU_FAILURE;\n            }\n            else\n            {\n                *value = amqpvalue_clone(value_data->value.map_value.pairs[index].value);\n                if (*value == NULL)\n                {\n                    /* Codes_SRS_AMQPVALUE_01_203: [If cloning the value fails, amqpvalue_get_map_key_value_pair shall fail and return a non-zero value.] */\n                    amqpvalue_destroy(*key);\n                    LogError(\"Could not clone index %u value\", (unsigned int)index);\n                    result = MU_FAILURE;\n                }\n                else\n                {\n                    /* Codes_SRS_AMQPVALUE_01_200: [On success amqpvalue_get_map_key_value_pair shall return 0.] */\n                    result = 0;\n                }\n            }\n        }\n    }\n\n    return result;\n}\n\nint amqpvalue_get_map(AMQP_VALUE value, AMQP_VALUE* map_value)\n{\n    int result;\n\n    if ((value == NULL) ||\n        (map_value == NULL))\n    {\n        LogError(\"Bad arguments: value = %p, map_value = %p\",\n            value, map_value);\n        result = MU_FAILURE;\n    }\n    else\n    {\n        AMQP_VALUE_DATA* value_data = (AMQP_VALUE_DATA*)value;\n        if (value_data->type != AMQP_TYPE_MAP)\n        {\n            LogError(\"Value is not of type MAP\");\n            result = MU_FAILURE;\n        }\n        else\n        {\n            *map_value = value;\n            result = 0;\n        }\n    }\n\n    return result;\n}\n\n/* Codes_SRS_AMQPVALUE_01_397: [1.6.24 array A sequence of values of a single type.] */\nAMQP_VALUE amqpvalue_create_array(void)\n{\n    AMQP_VALUE result = REFCOUNT_TYPE_CREATE(AMQP_VALUE_DATA);\n    if (result == NULL)\n    {\n        /* Codes_SRS_AMQPVALUE_01_405: [ If allocating memory for the array fails, then `amqpvalue_create_array` shall return NULL. ] */\n        LogError(\"Could not allocate memory for AMQP value\");\n    }\n    else\n    {\n        /* Codes_SRS_AMQPVALUE_01_404: [ `amqpvalue_create_array` shall return a handle to an AMQP_VALUE that stores an array. ] */\n        result->type = AMQP_TYPE_ARRAY;\n\n        /* Codes_SRS_AMQPVALUE_01_406: [ The array shall have an initial size of zero. ] */\n        result->value.array_value.items = NULL;\n        result->value.array_value.count = 0;\n    }\n\n    return result;\n}\n\nint amqpvalue_get_array_item_count(AMQP_VALUE value, uint32_t* count)\n{\n    int result;\n\n    /* Tests_SRS_AMQPVALUE_01_421: [ If any of the arguments is NULL, `amqpvalue_get_array_item_count` shall fail and return a non-zero value. ]*/\n    if ((value == NULL) ||\n        (count == NULL))\n    {\n        LogError(\"Bad arguments: value = %p, count = %p\",\n            value, count);\n        result = MU_FAILURE;\n    }\n    else\n    {\n        AMQP_VALUE_DATA* value_data = (AMQP_VALUE_DATA*)value;\n\n        /* Codes_SRS_AMQPVALUE_01_422: [ If the array argument is not an AMQP value created with the `amqpvalue_create_array` function then `amqpvalue_get_array_item_count` shall fail and return a non-zero value. ]*/\n        if (value_data->type != AMQP_TYPE_ARRAY)\n        {\n            LogError(\"Value is not of type ARRAY\");\n            result = MU_FAILURE;\n        }\n        else\n        {\n            /* Codes_SRS_AMQPVALUE_01_419: [ `amqpvalue_get_array_item_count` shall return in `count` the number of items in the array. ]*/\n            *count = value_data->value.array_value.count;\n\n            /* Codes_SRS_AMQPVALUE_01_420: [ On success `amqpvalue_get_array_item_count` shall return 0. ]*/\n            result = 0;\n        }\n    }\n\n    return result;\n}\n\nint amqpvalue_add_array_item(AMQP_VALUE value, AMQP_VALUE array_item_value)\n{\n    int result;\n\n    /* Codes_SRS_AMQPVALUE_01_409: [ If `value` or `array_item_value` is NULL, amqpvalue_add_array_item shall fail and return a non-zero value. ]*/\n    if (value == NULL)\n    {\n        LogError(\"NULL value\");\n        result = MU_FAILURE;\n    }\n    else\n    {\n        /* Codes_SRS_AMQPVALUE_01_413: [ If the `value` argument is not an AMQP array created with the `amqpvalue_create_array` function than `amqpvalue_add_array_item` shall fail and return a non-zero value. ] */\n        AMQP_VALUE_DATA* value_data = (AMQP_VALUE_DATA*)value;\n        if (value_data->type != AMQP_TYPE_ARRAY)\n        {\n            LogError(\"Value is not of type ARRAY\");\n            result = MU_FAILURE;\n        }\n        else\n        {\n            /* Codes_SRS_AMQPVALUE_01_425: [ If the type of `array_item_value` does not match that of items already in the array then `amqpvalue_add_array_item` shall fail and return a non-zero value. ] */\n            AMQP_VALUE_DATA* array_item_value_data = (AMQP_VALUE_DATA*)array_item_value;\n            if ((value_data->value.array_value.count > 0) &&\n                (array_item_value_data->type != value_data->value.array_value.items[0]->type))\n            {\n                LogError(\"Cannot put different types in the same array\");\n                result = MU_FAILURE;\n            }\n            else\n            {\n                /* Codes_SRS_AMQPVALUE_01_410: [ The item stored at the n-th position in the array shall be a clone of `array_item_value`. ] */\n                AMQP_VALUE cloned_item = amqpvalue_clone(array_item_value);\n                if (cloned_item == NULL)\n                {\n                    /* Codes_SRS_AMQPVALUE_01_423: [ When `amqpvalue_add_array_item` fails due to not being able to clone the item or grow the array, the array shall not be altered. ] */\n                    /* Codes_SRS_AMQPVALUE_01_412: [ If cloning the item fails, `amqpvalue_add_array_item` shall fail and return a non-zero value. ]*/\n                    LogError(\"Cannot clone value to put in the array\");\n                    result = MU_FAILURE;\n                }\n                else\n                {\n                    AMQP_VALUE* new_array = (AMQP_VALUE*)realloc(value_data->value.array_value.items, ((size_t)value_data->value.array_value.count + 1) * sizeof(AMQP_VALUE));\n                    if (new_array == NULL)\n                    {\n                        /* Codes_SRS_AMQPVALUE_01_423: [ When `amqpvalue_add_array_item` fails due to not being able to clone the item or grow the array, the array shall not be altered. ] */\n                        /* Codes_SRS_AMQPVALUE_01_424: [ If growing the array fails, then `amqpvalue_add_array_item` shall fail and return a non-zero value. ] */\n                        amqpvalue_destroy(cloned_item);\n                        LogError(\"Cannot resize array\");\n                        result = MU_FAILURE;\n                    }\n                    else\n                    {\n                        value_data->value.array_value.items = new_array;\n\n                        /* Codes_SRS_AMQPVALUE_01_407: [ `amqpvalue_add_array_item` shall add the AMQP_VALUE specified by `array_item_value` at the 0 based n-th position in the array. ]*/\n                        value_data->value.array_value.items[value_data->value.array_value.count] = cloned_item;\n                        value_data->value.array_value.count++;\n\n                        /* Codes_SRS_AMQPVALUE_01_408: [ On success `amqpvalue_add_array_item` shall return 0. ]*/\n                        result = 0;\n                    }\n                }\n            }\n        }\n    }\n\n    return result;\n}\n\nAMQP_VALUE amqpvalue_get_array_item(AMQP_VALUE value, uint32_t index)\n{\n    AMQP_VALUE result;\n\n    if (value == NULL)\n    {\n        /* Codes_SRS_AMQPVALUE_01_416: [ If the `value` argument is NULL, `amqpvalue_get_array_item` shall fail and return NULL. ] */\n        LogError(\"NULL value\");\n        result = NULL;\n    }\n    else\n    {\n        AMQP_VALUE_DATA* value_data = (AMQP_VALUE_DATA*)value;\n\n        /* Codes_SRS_AMQPVALUE_01_418: [ If value is not an array then `amqpvalue_get_array_item` shall fail and return NULL. ] */\n        if (value_data->type != AMQP_TYPE_ARRAY)\n        {\n            LogError(\"Value is not of type ARRAY\");\n            result = NULL;\n        }\n        /* Codes_SRS_AMQPVALUE_01_417: [ If `index` is greater or equal to the number of items in the array then `amqpvalue_get_array_item` shall fail and return NULL. ] */\n        else if (value_data->value.array_value.count <= index)\n        {\n            LogError(\"Index out of range: %u\", (unsigned int)index);\n            result = NULL;\n        }\n        else\n        {\n            /* Codes_SRS_AMQPVALUE_01_414: [ `amqpvalue_get_array_item` shall return a copy of the AMQP_VALUE stored at the 0 based position `index` in the array identified by `value`. ] */\n            /* Codes_SRS_AMQPVALUE_01_426: [ If cloning the item at position `index` fails, then `amqpvalue_get_array_item` shall fail and return NULL. ] */\n            result = amqpvalue_clone(value_data->value.array_value.items[index]);\n        }\n    }\n\n    return result;\n}\n\nint amqpvalue_get_array(AMQP_VALUE value, AMQP_VALUE* array_value)\n{\n    int result;\n\n    if ((value == NULL) ||\n        (array_value == NULL))\n    {\n        LogError(\"Bad arguments: value = %p, array_value = %p\",\n            value, array_value);\n        result = MU_FAILURE;\n    }\n    else\n    {\n        AMQP_VALUE_DATA* value_data = (AMQP_VALUE_DATA*)value;\n        if (value_data->type != AMQP_TYPE_ARRAY)\n        {\n            LogError(\"Value is not of type ARRAY\");\n            result = MU_FAILURE;\n        }\n        else\n        {\n            *array_value = value;\n            result = 0;\n        }\n    }\n\n    return result;\n}\n\n/* Codes_SRS_AMQPVALUE_01_206: [amqpvalue_are_equal shall return true if the contents of value1 and value2 are equal.] */\nbool amqpvalue_are_equal(AMQP_VALUE value1, AMQP_VALUE value2)\n{\n    bool result;\n\n    /* Codes_SRS_AMQPVALUE_01_207: [If value1 and value2 are NULL, amqpvalue_are_equal shall return true.] */\n    if ((value1 == NULL) &&\n        (value2 == NULL))\n    {\n        LogError(\"Bad arguments: value1 = %p, value2 = %p\",\n            value1, value2);\n        result = true;\n    }\n    /* Codes_SRS_AMQPVALUE_01_208: [If one of the arguments is NULL and the other is not, amqpvalue_are_equal shall return false.] */\n    else if ((value1 != value2) && ((value1 == NULL) || (value2 == NULL)))\n    {\n        result = false;\n    }\n    else\n    {\n        AMQP_VALUE_DATA* value1_data = (AMQP_VALUE_DATA*)value1;\n        AMQP_VALUE_DATA* value2_data = (AMQP_VALUE_DATA*)value2;\n\n        /* Codes_SRS_AMQPVALUE_01_209: [If the types for value1 and value2 are different amqpvalue_are_equal shall return false.] */\n#if _MSC_VER\n#pragma warning(suppress: 28182) /* The compiler states that value2_data can be NULL, but it cannot. And there are tests for it. */\n#endif\n        if (value1_data->type != value2_data->type)\n        {\n            result = false;\n        }\n        else\n        {\n            switch (value1_data->type)\n            {\n            default:\n                result = false;\n                break;\n\n            case AMQP_TYPE_NULL:\n                /* Codes_SRS_AMQPVALUE_01_210: [- null: always equal.] */\n                result = true;\n                break;\n\n            case AMQP_TYPE_BOOL:\n                /* Codes_SRS_AMQPVALUE_01_211: [- boolean: compare the bool content.] */\n                result = (value1_data->value.bool_value == value2_data->value.bool_value);\n                break;\n\n            case AMQP_TYPE_UBYTE:\n                /* Codes_SRS_AMQPVALUE_01_212: [- ubyte: compare the unsigned char content.] */\n                result = (value1_data->value.ubyte_value == value2_data->value.ubyte_value);\n                break;\n\n            case AMQP_TYPE_USHORT:\n                /* Codes_SRS_AMQPVALUE_01_213: [- ushort: compare the uint16_t content.] */\n                result = (value1_data->value.ushort_value == value2_data->value.ushort_value);\n                break;\n\n            case AMQP_TYPE_UINT:\n                /* Codes_SRS_AMQPVALUE_01_214: [- uint: compare the uint32_t content.] */\n                result = (value1_data->value.uint_value == value2_data->value.uint_value);\n                break;\n\n            case AMQP_TYPE_ULONG:\n                /* Codes_SRS_AMQPVALUE_01_215: [- ulong: compare the uint64_t content.] */\n                result = (value1_data->value.ulong_value == value2_data->value.ulong_value);\n                break;\n\n            case AMQP_TYPE_BYTE:\n                /* Codes_SRS_AMQPVALUE_01_216: [- byte: compare the char content.] */\n                result = (value1_data->value.byte_value == value2_data->value.byte_value);\n                break;\n\n            case AMQP_TYPE_SHORT:\n                /* Codes_SRS_AMQPVALUE_01_217: [- short: compare the int16_t content.] */\n                result = (value1_data->value.short_value == value2_data->value.short_value);\n                break;\n\n            case AMQP_TYPE_INT:\n                /* Codes_SRS_AMQPVALUE_01_218: [- int: compare the int32_t content.] */\n                result = (value1_data->value.int_value == value2_data->value.int_value);\n                break;\n\n            case AMQP_TYPE_LONG:\n                /* Codes_SRS_AMQPVALUE_01_219: [- long: compare the int64_t content.] */\n                result = (value1_data->value.long_value == value2_data->value.long_value);\n                break;\n\n            case AMQP_TYPE_FLOAT:\n                /* Codes_SRS_AMQPVALUE_01_224: [- float: compare the float content.] */\n                result = (value1_data->value.float_value == value2_data->value.float_value);\n                break;\n\n            case AMQP_TYPE_DOUBLE:\n                /* Codes_SRS_AMQPVALUE_01_225: [- double: compare the double content.] */\n                result = (value1_data->value.double_value == value2_data->value.double_value);\n                break;\n\n            case AMQP_TYPE_CHAR:\n                /* Codes_SRS_AMQPVALUE_01_226: [- char: compare the UNICODE character.] */\n                result = (value1_data->value.char_value == value2_data->value.char_value);\n                break;\n\n            case AMQP_TYPE_TIMESTAMP:\n                /* Codes_SRS_AMQPVALUE_01_227: [- timestamp: compare the underlying 64 bit integer.] */\n                result = (value1_data->value.timestamp_value == value2_data->value.timestamp_value);\n                break;\n\n            case AMQP_TYPE_UUID:\n                /* Codes_SRS_AMQPVALUE_01_228: [- uuid: compare all uuid bytes.] */\n                result = (memcmp(value1_data->value.uuid_value, value2_data->value.uuid_value, sizeof(value1_data->value.uuid_value)) == 0);\n                break;\n\n            case AMQP_TYPE_BINARY:\n                /* Codes_SRS_AMQPVALUE_01_229: [- binary: compare all binary bytes.] */\n                result = (value1_data->value.binary_value.length == value2_data->value.binary_value.length) &&\n                    (memcmp(value1_data->value.binary_value.bytes, value2_data->value.binary_value.bytes, value1_data->value.binary_value.length) == 0);\n                break;\n\n            case AMQP_TYPE_STRING:\n                /* Codes_SRS_AMQPVALUE_01_230: [- string: compare all string characters.] */\n                result = (strcmp(value1_data->value.string_value.chars, value2_data->value.string_value.chars) == 0);\n                break;\n\n            case AMQP_TYPE_SYMBOL:\n                /* Codes_SRS_AMQPVALUE_01_263: [- symbol: compare all symbol characters.] */\n                result = (strcmp(value1_data->value.symbol_value.chars, value2_data->value.symbol_value.chars) == 0);\n                break;\n\n            case AMQP_TYPE_LIST:\n            {\n                /* Codes_SRS_AMQPVALUE_01_231: [- list: compare list item count and each element.] */\n                if (value1_data->value.list_value.count != value2_data->value.list_value.count)\n                {\n                    result = false;\n                }\n                else\n                {\n                    uint32_t i;\n\n                    for (i = 0; i < value1_data->value.list_value.count; i++)\n                    {\n                        /* Codes_SRS_AMQPVALUE_01_232: [Nesting shall be considered in comparison.] */\n                        if (!amqpvalue_are_equal(value1_data->value.list_value.items[i], value2_data->value.list_value.items[i]))\n                        {\n                            break;\n                        }\n                    }\n\n                    result = (i == value1_data->value.list_value.count);\n                }\n\n                break;\n            }\n            case AMQP_TYPE_ARRAY:\n            {\n                /* Codes_SRS_AMQPVALUE_01_427: [- array: compare array item count and each element. ] */\n                if (value1_data->value.array_value.count != value2_data->value.array_value.count)\n                {\n                    result = false;\n                }\n                else\n                {\n                    uint32_t i;\n\n                    for (i = 0; i < value1_data->value.array_value.count; i++)\n                    {\n                        /* Codes_SRS_AMQPVALUE_01_428: [ Nesting shall be considered in comparison. ] */\n                        if (!amqpvalue_are_equal(value1_data->value.array_value.items[i], value2_data->value.array_value.items[i]))\n                        {\n                            break;\n                        }\n                    }\n\n                    result = (i == value1_data->value.array_value.count);\n                }\n\n                break;\n            }\n            case AMQP_TYPE_MAP:\n            {\n                /* Codes_SRS_AMQPVALUE_01_233: [- map: compare map pair count and each key/value pair.] */\n                if (value1_data->value.map_value.pair_count != value2_data->value.map_value.pair_count)\n                {\n                    result = false;\n                }\n                else\n                {\n                    uint32_t i;\n\n                    /* Codes_SRS_AMQPVALUE_01_126: [Unless known to be otherwise, maps MUST be considered to be ordered, that is, the order of the key-value pairs is semantically important and two maps which are different only in the order in which their key-value pairs are encoded are not equal.] */\n                    for (i = 0; i < value1_data->value.map_value.pair_count; i++)\n                    {\n                        /* Codes_SRS_AMQPVALUE_01_234: [Nesting shall be considered in comparison.] */\n                        if ((!amqpvalue_are_equal(value1_data->value.map_value.pairs[i].key, value2_data->value.map_value.pairs[i].key)) ||\n                            (!amqpvalue_are_equal(value1_data->value.map_value.pairs[i].value, value2_data->value.map_value.pairs[i].value)))\n                        {\n                            break;\n                        }\n                    }\n\n                    result = (i == value1_data->value.map_value.pair_count);\n                }\n\n                break;\n            }\n            }\n        }\n    }\n\n    return result;\n}\n\nAMQP_VALUE amqpvalue_clone(AMQP_VALUE value)\n{\n    AMQP_VALUE result;\n\n    if (value == NULL)\n    {\n        /* Codes_SRS_AMQPVALUE_01_402: [ If `value` is NULL, `amqpvalue_clone` shall return NULL. ]*/\n        LogError(\"NULL value\");\n        result = NULL;\n    }\n    else\n    {\n        /* Codes_SRS_AMQPVALUE_01_235: [amqpvalue_clone shall clone the value passed as argument and return a new non-NULL handle to the cloned AMQP value.] */\n        INC_REF(AMQP_VALUE_DATA, value);\n        result = value;\n    }\n\n    return result;\n}\n\nAMQP_TYPE amqpvalue_get_type(AMQP_VALUE value)\n{\n    AMQP_VALUE_DATA* amqpvalue_data = (AMQP_VALUE_DATA*)value;\n    return amqpvalue_data->type;\n}\n\nstatic int output_byte(AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context, unsigned char b)\n{\n    int result;\n\n    if (encoder_output != NULL)\n    {\n        /* Codes_SRS_AMQPVALUE_01_267: [amqpvalue_encode shall pass the encoded bytes to the encoder_output function.] */\n        /* Codes_SRS_AMQPVALUE_01_268: [On each call to the encoder_output function, amqpvalue_encode shall also pass the context argument.] */\n        result = encoder_output(context, &b, 1);\n    }\n    else\n    {\n        result = 0;\n    }\n\n    return result;\n}\n\nstatic int output_bytes(AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context, const void* bytes, size_t length)\n{\n    int result;\n\n    if (encoder_output != NULL)\n    {\n        /* Codes_SRS_AMQPVALUE_01_267: [amqpvalue_encode shall pass the encoded bytes to the encoder_output function.] */\n        /* Codes_SRS_AMQPVALUE_01_268: [On each call to the encoder_output function, amqpvalue_encode shall also pass the context argument.] */\n        result = encoder_output(context, (const unsigned char*)bytes, length);\n    }\n    else\n    {\n        result = 0;\n    }\n\n    return result;\n}\n\nstatic int encode_null_constructor(AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context)\n{\n    int result;\n\n    /* Codes_SRS_AMQPVALUE_01_264: [<encoding code=\"0x40\" category=\"fixed\" width=\"0\" label=\"the null value\"/>] */\n    if (output_byte(encoder_output, context, (unsigned char)0x40) != 0)\n    {\n        /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */\n        LogError(\"Failed encoding NULL constructor\");\n        result = MU_FAILURE;\n    }\n    else\n    {\n        /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */\n        result = 0;\n    }\n\n    return result;\n}\n\nstatic int encode_null_value(AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context)\n{\n    int result = 0;\n    (void)encoder_output;\n    (void)context;\n\n    /* Codes_SRS_AMQPVALUE_01_264: [<encoding code=\"0x40\" category=\"fixed\" width=\"0\" label=\"the null value\"/>] */\n    return result;\n}\n\nstatic int encode_null(AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context)\n{\n    int result;\n\n    if ((encode_null_constructor(encoder_output, context) != 0) ||\n        (encode_null_value(encoder_output, context) != 0))\n    {\n        /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */\n        LogError(\"Failed encoding NULL\");\n        result = MU_FAILURE;\n    }\n    else\n    {\n        /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */\n        result = 0;\n    }\n\n    return result;\n}\n\nstatic int encode_boolean_constructor(AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context)\n{\n    int result;\n\n    /* Codes_SRS_AMQPVALUE_01_270: [<encoding code=\"0x56\" category=\"fixed\" width=\"1\" label=\"boolean with the octet 0x00 being false and octet 0x01 being true\"/>] */\n    if (output_byte(encoder_output, context, 0x56) != 0)\n    {\n        /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */\n        LogError(\"Failed encoding boolean constructor\");\n        result = MU_FAILURE;\n    }\n    else\n    {\n        /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */\n        result = 0;\n    }\n\n    return result;\n}\n\nstatic int encode_boolean_value(AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context, bool value)\n{\n    int result;\n\n    if (value == false)\n    {\n        /* Codes_SRS_AMQPVALUE_01_270: [<encoding code=\"0x56\" category=\"fixed\" width=\"1\" label=\"boolean with the octet 0x00 being false and octet 0x01 being true\"/>] */\n        if (output_byte(encoder_output, context, 0x00) != 0)\n        {\n            /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */\n            LogError(\"Failed encoding boolean value\");\n            result = MU_FAILURE;\n        }\n        else\n        {\n            result = 0;\n        }\n    }\n    else\n    {\n        /* Codes_SRS_AMQPVALUE_01_270: [<encoding code=\"0x56\" category=\"fixed\" width=\"1\" label=\"boolean with the octet 0x00 being false and octet 0x01 being true\"/>] */\n        if (output_byte(encoder_output, context, 0x01) != 0)\n        {\n            /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */\n            LogError(\"Failed encoding boolean value\");\n            result = MU_FAILURE;\n        }\n        else\n        {\n            result = 0;\n        }\n    }\n\n    return result;\n}\n\nstatic int encode_boolean(AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context, bool value)\n{\n    int result;\n\n    if (value == false)\n    {\n        /* Codes_SRS_AMQPVALUE_01_273: [<encoding name=\"false\" code=\"0x42\" category=\"fixed\" width=\"0\" label=\"the boolean value false\"/>] */\n        if (output_byte(encoder_output, context, 0x42) != 0)\n        {\n            /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */\n            LogError(\"Failed encoding boolean\");\n            result = MU_FAILURE;\n        }\n        else\n        {\n            result = 0;\n        }\n    }\n    else\n    {\n        /* Codes_SRS_AMQPVALUE_01_272: [<encoding name=\"true\" code=\"0x41\" category=\"fixed\" width=\"0\" label=\"the boolean value true\"/>] */\n        if (output_byte(encoder_output, context, 0x41) != 0)\n        {\n            /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */\n            LogError(\"Failed encoding boolean\");\n            result = MU_FAILURE;\n        }\n        else\n        {\n            result = 0;\n        }\n    }\n\n    return result;\n}\n\nstatic int encode_ubyte_constructor(AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context)\n{\n    int result;\n\n    /* Codes_SRS_AMQPVALUE_01_275: [<encoding code=\"0x50\" category=\"fixed\" width=\"1\" label=\"8-bit unsigned integer\"/>] */\n    if (output_byte(encoder_output, context, 0x50) != 0)\n    {\n        /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */\n        LogError(\"Failed encoding ubyte constructor\");\n        result = MU_FAILURE;\n    }\n    else\n    {\n        /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */\n        result = 0;\n    }\n\n    return result;\n}\n\nstatic int encode_ubyte_value(AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context, unsigned char value)\n{\n    int result;\n\n    /* Codes_SRS_AMQPVALUE_01_275: [<encoding code=\"0x50\" category=\"fixed\" width=\"1\" label=\"8-bit unsigned integer\"/>] */\n    if (output_byte(encoder_output, context, value) != 0)\n    {\n        /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */\n        LogError(\"Failed encoding ubyte value\");\n        result = MU_FAILURE;\n    }\n    else\n    {\n        /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */\n        result = 0;\n    }\n\n    return result;\n}\n\nstatic int encode_ubyte(AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context, unsigned char value)\n{\n    int result;\n\n    if ((encode_ubyte_constructor(encoder_output, context) != 0) ||\n        (encode_ubyte_value(encoder_output, context, value) != 0))\n    {\n        /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */\n        LogError(\"Failed encoding ubyte\");\n        result = MU_FAILURE;\n    }\n    else\n    {\n        /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */\n        result = 0;\n    }\n\n    return result;\n}\n\nstatic int encode_ushort_constructor(AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context)\n{\n    int result;\n\n    /* Codes_SRS_AMQPVALUE_01_276: [<encoding code=\"0x60\" category=\"fixed\" width=\"2\" label=\"16-bit unsigned integer in network byte order\"/>] */\n    if (output_byte(encoder_output, context, 0x60) != 0)\n    {\n        /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */\n        LogError(\"Failed encoding ushort constructor\");\n        result = MU_FAILURE;\n    }\n    else\n    {\n        /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */\n        result = 0;\n    }\n\n    return result;\n}\n\nstatic int encode_ushort_value(AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context, uint16_t value)\n{\n    int result;\n\n    /* Codes_SRS_AMQPVALUE_01_276: [<encoding code=\"0x60\" category=\"fixed\" width=\"2\" label=\"16-bit unsigned integer in network byte order\"/>] */\n    if ((output_byte(encoder_output, context, (value >> 8) & 0xFF) != 0) ||\n        (output_byte(encoder_output, context, (value & 0xFF)) != 0))\n    {\n        /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */\n        LogError(\"Failed encoding ushort value\");\n        result = MU_FAILURE;\n    }\n    else\n    {\n        /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */\n        result = 0;\n    }\n\n    return result;\n}\n\nstatic int encode_ushort(AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context, uint16_t value)\n{\n    int result;\n\n    if ((encode_ushort_constructor(encoder_output, context) != 0) ||\n        (encode_ushort_value(encoder_output, context, value) != 0))\n    {\n        /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */\n        LogError(\"Failed encoding ushort\");\n        result = MU_FAILURE;\n    }\n    else\n    {\n        /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */\n        result = 0;\n    }\n\n    return result;\n}\n\nstatic int encode_uint_constructor(AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context, bool use_smallest)\n{\n    int result;\n\n    if (use_smallest)\n    {\n        /* smalluint */\n        /* Codes_SRS_AMQPVALUE_01_278: [<encoding name=\"smalluint\" code=\"0x52\" category=\"fixed\" width=\"1\" label=\"unsigned integer value in the range 0 to 255 inclusive\"/>] */\n        if (output_byte(encoder_output, context, 0x52) != 0)\n        {\n            /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */\n            LogError(\"Failed encoding small uint constructor\");\n            result = MU_FAILURE;\n        }\n        else\n        {\n            /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */\n            result = 0;\n        }\n    }\n    else\n    {\n        /* Codes_SRS_AMQPVALUE_01_277: [<encoding code=\"0x70\" category=\"fixed\" width=\"4\" label=\"32-bit unsigned integer in network byte order\"/>] */\n        if (output_byte(encoder_output, context, 0x70) != 0)\n        {\n            /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */\n            LogError(\"Failed encoding uint constructor\");\n            result = MU_FAILURE;\n        }\n        else\n        {\n            /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */\n            result = 0;\n        }\n    }\n\n    return result;\n}\n\nstatic int encode_uint_value(AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context, uint32_t value, bool use_smallest)\n{\n    int result;\n\n    if (use_smallest)\n    {\n        /* smalluint */\n        /* Codes_SRS_AMQPVALUE_01_278: [<encoding name=\"smalluint\" code=\"0x52\" category=\"fixed\" width=\"1\" label=\"unsigned integer value in the range 0 to 255 inclusive\"/>] */\n        if (output_byte(encoder_output, context, value & 0xFF) != 0)\n        {\n            /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */\n            LogError(\"Failed encoding small uint value\");\n            result = MU_FAILURE;\n        }\n        else\n        {\n            /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */\n            result = 0;\n        }\n    }\n    else\n    {\n        /* Codes_SRS_AMQPVALUE_01_277: [<encoding code=\"0x70\" category=\"fixed\" width=\"4\" label=\"32-bit unsigned integer in network byte order\"/>] */\n        if ((output_byte(encoder_output, context, (value >> 24) & 0xFF) != 0) ||\n            (output_byte(encoder_output, context, (value >> 16) & 0xFF) != 0) ||\n            (output_byte(encoder_output, context, (value >> 8) & 0xFF) != 0) ||\n            (output_byte(encoder_output, context, value & 0xFF) != 0))\n        {\n            /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */\n            LogError(\"Failed encoding uint value\");\n            result = MU_FAILURE;\n        }\n        else\n        {\n            /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */\n            result = 0;\n        }\n    }\n\n    return result;\n}\n\nstatic int encode_uint(AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context, uint32_t value)\n{\n    int result;\n\n    if (value == 0)\n    {\n        /* uint0 */\n        /* Codes_SRS_AMQPVALUE_01_279: [<encoding name=\"uint0\" code=\"0x43\" category=\"fixed\" width=\"0\" label=\"the uint value 0\"/>] */\n        if (output_byte(encoder_output, context, 0x43) != 0)\n        {\n            LogError(\"Failed encoding uint\");\n            result = MU_FAILURE;\n        }\n        else\n        {\n            /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */\n            result = 0;\n        }\n    }\n    else\n    {\n        bool use_smallest = (value <= 255);\n\n        if ((encode_uint_constructor(encoder_output, context, use_smallest) != 0) ||\n            (encode_uint_value(encoder_output, context, value, use_smallest) != 0))\n        {\n            /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */\n            LogError(\"Failed encoding uint\");\n            result = MU_FAILURE;\n        }\n        else\n        {\n            /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */\n            result = 0;\n        }\n    }\n\n    return result;\n}\n\nstatic int encode_ulong_constructor(AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context, bool use_smallest)\n{\n    int result;\n\n    if (use_smallest)\n    {\n        /* smallulong */\n        /* Codes_SRS_AMQPVALUE_01_281: [<encoding name=\"smallulong\" code=\"0x53\" category=\"fixed\" width=\"1\" label=\"unsigned long value in the range 0 to 255 inclusive\"/>] */\n        if (output_byte(encoder_output, context, 0x53) != 0)\n        {\n            /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */\n            LogError(\"Failed encoding small ulong constructor\");\n            result = MU_FAILURE;\n        }\n        else\n        {\n            /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */\n            result = 0;\n        }\n    }\n    else\n    {\n        /* Codes_SRS_AMQPVALUE_01_280: [<encoding code=\"0x80\" category=\"fixed\" width=\"8\" label=\"64-bit unsigned integer in network byte order\"/>] */\n        if (output_byte(encoder_output, context, 0x80) != 0)\n        {\n            /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */\n            LogError(\"Failed encoding ulong constructor\");\n            result = MU_FAILURE;\n        }\n        else\n        {\n            /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */\n            result = 0;\n        }\n    }\n\n    return result;\n}\n\nstatic int encode_ulong_value(AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context, uint64_t value, bool use_smallest)\n{\n    int result;\n\n    if (use_smallest)\n    {\n        /* smallulong */\n        /* Codes_SRS_AMQPVALUE_01_281: [<encoding name=\"smallulong\" code=\"0x53\" category=\"fixed\" width=\"1\" label=\"unsigned long value in the range 0 to 255 inclusive\"/>] */\n        if (output_byte(encoder_output, context, value & 0xFF) != 0)\n        {\n            /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */\n            LogError(\"Failed encoding small ulong value\");\n            result = MU_FAILURE;\n        }\n        else\n        {\n            /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */\n            result = 0;\n        }\n    }\n    else\n    {\n        /* Codes_SRS_AMQPVALUE_01_280: [<encoding code=\"0x80\" category=\"fixed\" width=\"8\" label=\"64-bit unsigned integer in network byte order\"/>] */\n        if ((output_byte(encoder_output, context, (value >> 56) & 0xFF) != 0) ||\n            (output_byte(encoder_output, context, (value >> 48) & 0xFF) != 0) ||\n            (output_byte(encoder_output, context, (value >> 40) & 0xFF) != 0) ||\n            (output_byte(encoder_output, context, (value >> 32) & 0xFF) != 0) ||\n            (output_byte(encoder_output, context, (value >> 24) & 0xFF) != 0) ||\n            (output_byte(encoder_output, context, (value >> 16) & 0xFF) != 0) ||\n            (output_byte(encoder_output, context, (value >> 8) & 0xFF) != 0) ||\n            (output_byte(encoder_output, context, value & 0xFF) != 0))\n        {\n            /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */\n            LogError(\"Failed encoding ulong value\");\n            result = MU_FAILURE;\n        }\n        else\n        {\n            /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */\n            result = 0;\n        }\n    }\n\n    return result;\n}\n\nstatic int encode_ulong(AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context, uint64_t value)\n{\n    int result;\n    if (value == 0)\n    {\n        /* ulong0 */\n        /* Codes_SRS_AMQPVALUE_01_282: [<encoding name=\"ulong0\" code=\"0x44\" category=\"fixed\" width=\"0\" label=\"the ulong value 0\"/>] */\n        if (output_byte(encoder_output, context, 0x44) != 0)\n        {\n            /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */\n            LogError(\"Failed encoding ulong\");\n            result = MU_FAILURE;\n        }\n        else\n        {\n            /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */\n            result = 0;\n        }\n    }\n    else\n    {\n        bool use_smallest = (value <= 255);\n\n        if ((encode_ulong_constructor(encoder_output, context, use_smallest) != 0) ||\n            (encode_ulong_value(encoder_output, context, value, use_smallest) != 0))\n        {\n            /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */\n            LogError(\"Failed encoding ulong\");\n            result = MU_FAILURE;\n        }\n        else\n        {\n            /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */\n            result = 0;\n        }\n    }\n\n    return result;\n}\n\nstatic int encode_byte_constructor(AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context)\n{\n    int result;\n\n    /* Codes_SRS_AMQPVALUE_01_283: [<encoding code=\"0x51\" category=\"fixed\" width=\"1\" label=\"8-bit two's-complement integer\"/>] */\n    if (output_byte(encoder_output, context, 0x51) != 0)\n    {\n        /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */\n        LogError(\"Failed encoding byte constructor\");\n        result = MU_FAILURE;\n    }\n    else\n    {\n        /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */\n        result = 0;\n    }\n\n    return result;\n}\n\nstatic int encode_byte_value(AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context, char value)\n{\n    int result;\n\n    /* Codes_SRS_AMQPVALUE_01_283: [<encoding code=\"0x51\" category=\"fixed\" width=\"1\" label=\"8-bit two's-complement integer\"/>] */\n    if (output_byte(encoder_output, context, value) != 0)\n    {\n        /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */\n        LogError(\"Failed encoding byte value\");\n        result = MU_FAILURE;\n    }\n    else\n    {\n        /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */\n        result = 0;\n    }\n\n    return result;\n}\n\nstatic int encode_byte(AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context, char value)\n{\n    int result;\n\n    if ((encode_byte_constructor(encoder_output, context) != 0) ||\n        (encode_byte_value(encoder_output, context, value) != 0))\n    {\n        /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */\n        LogError(\"Failed encoding byte\");\n        result = MU_FAILURE;\n    }\n    else\n    {\n        /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */\n        result = 0;\n    }\n\n    return result;\n}\n\nstatic int encode_short_constructor(AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context)\n{\n    int result;\n\n    /* Codes_SRS_AMQPVALUE_01_284: [<encoding code=\"0x61\" category=\"fixed\" width=\"2\" label=\"16-bit two's-complement integer in network byte order\"/>] */\n    if (output_byte(encoder_output, context, 0x61) != 0)\n    {\n        /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */\n        LogError(\"Failed encoding short constructor\");\n        result = MU_FAILURE;\n    }\n    else\n    {\n        /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */\n        result = 0;\n    }\n\n    return result;\n}\n\nstatic int encode_short_value(AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context, int16_t value)\n{\n    int result;\n\n    /* Codes_SRS_AMQPVALUE_01_284: [<encoding code=\"0x61\" category=\"fixed\" width=\"2\" label=\"16-bit two's-complement integer in network byte order\"/>] */\n    if ((output_byte(encoder_output, context, (value >> 8) & 0xFF) != 0) ||\n        (output_byte(encoder_output, context, (value & 0xFF)) != 0))\n    {\n        /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */\n        LogError(\"Failed encoding short value\");\n        result = MU_FAILURE;\n    }\n    else\n    {\n        /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */\n        result = 0;\n    }\n\n    return result;\n}\n\nstatic int encode_short(AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context, int16_t value)\n{\n    int result;\n\n    if ((encode_short_constructor(encoder_output, context) != 0) ||\n        (encode_short_value(encoder_output, context, value) != 0))\n    {\n        /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */\n        LogError(\"Failed encoding short\");\n        result = MU_FAILURE;\n    }\n    else\n    {\n        /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */\n        result = 0;\n    }\n\n    return result;\n}\n\nstatic int encode_int_constructor(AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context, bool use_smallest)\n{\n    int result;\n\n    if (use_smallest)\n    {\n        /* Codes_SRS_AMQPVALUE_01_286: [<encoding name=\"smallint\" code=\"0x54\" category=\"fixed\" width=\"1\" label=\"8-bit two's-complement integer\"/>] */\n        if (output_byte(encoder_output, context, 0x54) != 0)\n        {\n            /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */\n            LogError(\"Failed encoding small int constructor\");\n            result = MU_FAILURE;\n        }\n        else\n        {\n            /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */\n            result = 0;\n        }\n    }\n    else\n    {\n        /* Codes_SRS_AMQPVALUE_01_285: [<encoding code=\"0x71\" category=\"fixed\" width=\"4\" label=\"32-bit two's-complement integer in network byte order\"/>] */\n        if (output_byte(encoder_output, context, 0x71) != 0)\n        {\n            /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */\n            LogError(\"Failed encoding int constructor\");\n            result = MU_FAILURE;\n        }\n        else\n        {\n            /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */\n            result = 0;\n        }\n    }\n\n    return result;\n}\n\nstatic int encode_int_value(AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context, int32_t value, bool use_smallest)\n{\n    int result;\n\n    if (use_smallest)\n    {\n        /* Codes_SRS_AMQPVALUE_01_286: [<encoding name=\"smallint\" code=\"0x54\" category=\"fixed\" width=\"1\" label=\"8-bit two's-complement integer\"/>] */\n        if (output_byte(encoder_output, context, value & 0xFF) != 0)\n        {\n            /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */\n            LogError(\"Failed encoding small int value\");\n            result = MU_FAILURE;\n        }\n        else\n        {\n            /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */\n            result = 0;\n        }\n    }\n    else\n    {\n        /* Codes_SRS_AMQPVALUE_01_285: [<encoding code=\"0x71\" category=\"fixed\" width=\"4\" label=\"32-bit two's-complement integer in network byte order\"/>] */\n        if ((output_byte(encoder_output, context, (value >> 24) & 0xFF) != 0) ||\n            (output_byte(encoder_output, context, (value >> 16) & 0xFF) != 0) ||\n            (output_byte(encoder_output, context, (value >> 8) & 0xFF) != 0) ||\n            (output_byte(encoder_output, context, value & 0xFF) != 0))\n        {\n            /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */\n            LogError(\"Failed encoding int value\");\n            result = MU_FAILURE;\n        }\n        else\n        {\n            /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */\n            result = 0;\n        }\n    }\n\n    return result;\n}\n\nstatic int encode_int(AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context, int32_t value)\n{\n    int result;\n    bool use_smallest = ((value <= 127) && (value >= -128));\n\n    if ((encode_int_constructor(encoder_output, context, use_smallest) != 0) ||\n        (encode_int_value(encoder_output, context, value, use_smallest) != 0))\n    {\n        /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */\n        LogError(\"Failed encoding int\");\n        result = MU_FAILURE;\n    }\n    else\n    {\n        /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */\n        result = 0;\n    }\n\n    return result;\n}\n\nstatic int encode_long_constructor(AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context, bool use_smallest)\n{\n    int result;\n\n    if (use_smallest)\n    {\n        /* Codes_SRS_AMQPVALUE_01_288: [<encoding name=\"smalllong\" code=\"0x55\" category=\"fixed\" width=\"1\" label=\"8-bit two's-complement integer\"/>] */\n        if (output_byte(encoder_output, context, 0x55) != 0)\n        {\n            /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */\n            LogError(\"Failed encoding small long constructor\");\n            result = MU_FAILURE;\n        }\n        else\n        {\n            /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */\n            result = 0;\n        }\n    }\n    else\n    {\n        /* Codes_SRS_AMQPVALUE_01_287: [<encoding code=\"0x81\" category=\"fixed\" width=\"8\" label=\"64-bit two's-complement integer in network byte order\"/>] */\n        if (output_byte(encoder_output, context, 0x81) != 0)\n        {\n            /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */\n            LogError(\"Failed encoding long constructor\");\n            result = MU_FAILURE;\n        }\n        else\n        {\n            /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */\n            result = 0;\n        }\n    }\n\n    return result;\n}\n\nstatic int encode_long_value(AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context, int64_t value, bool use_smallest)\n{\n    int result;\n\n    if (use_smallest)\n    {\n        /* Codes_SRS_AMQPVALUE_01_288: [<encoding name=\"smalllong\" code=\"0x55\" category=\"fixed\" width=\"1\" label=\"8-bit two's-complement integer\"/>] */\n        if (output_byte(encoder_output, context, value & 0xFF) != 0)\n        {\n            /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */\n            LogError(\"Failed encoding small long value\");\n            result = MU_FAILURE;\n        }\n        else\n        {\n            /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */\n            result = 0;\n        }\n    }\n    else\n    {\n        /* Codes_SRS_AMQPVALUE_01_287: [<encoding code=\"0x81\" category=\"fixed\" width=\"8\" label=\"64-bit two's-complement integer in network byte order\"/>] */\n        if ((output_byte(encoder_output, context, (value >> 56) & 0xFF) != 0) ||\n            (output_byte(encoder_output, context, (value >> 48) & 0xFF) != 0) ||\n            (output_byte(encoder_output, context, (value >> 40) & 0xFF) != 0) ||\n            (output_byte(encoder_output, context, (value >> 32) & 0xFF) != 0) ||\n            (output_byte(encoder_output, context, (value >> 24) & 0xFF) != 0) ||\n            (output_byte(encoder_output, context, (value >> 16) & 0xFF) != 0) ||\n            (output_byte(encoder_output, context, (value >> 8) & 0xFF) != 0) ||\n            (output_byte(encoder_output, context, value & 0xFF) != 0))\n        {\n            /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */\n            LogError(\"Failed encoding long value\");\n            result = MU_FAILURE;\n        }\n        else\n        {\n            /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */\n            result = 0;\n        }\n    }\n\n    return result;\n}\n\nstatic int encode_long(AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context, int64_t value)\n{\n    int result;\n    bool use_smallest = ((value <= 127) && (value >= -128));\n\n    if ((encode_long_constructor(encoder_output, context, use_smallest) != 0) ||\n        (encode_long_value(encoder_output, context, value, use_smallest) != 0))\n    {\n        /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */\n        LogError(\"Failed encoding long\");\n        result = MU_FAILURE;\n    }\n    else\n    {\n        /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */\n        result = 0;\n    }\n\n    return result;\n}\n\nstatic int encode_float_constructor(AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context)\n{\n    int result;\n\n    /* Codes_SRS_AMQPVALUE_01_289: [\\<encoding name=\"ieee-754\" code=\"0x72\" category=\"fixed\" width=\"4\" label=\"IEEE 754-2008 binary32\"/>] */\n    if (output_byte(encoder_output, context, 0x72) != 0)\n    {\n        /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */\n        LogError(\"Failure encoding constructor for float\");\n        result = MU_FAILURE;\n    }\n    else\n    {\n        /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */\n        result = 0;\n    }\n\n    return result;\n}\n\nstatic int encode_float_value(AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context, float value)\n{\n    int result;\n\n    uint32_t value_as_uint32 = *((uint32_t*)(void*)&value);\n    /* Codes_SRS_AMQPVALUE_01_289: [\\<encoding name=\"ieee-754\" code=\"0x72\" category=\"fixed\" width=\"4\" label=\"IEEE 754-2008 binary32\"/>] */\n    if ((output_byte(encoder_output, context, (value_as_uint32 >> 24) & 0xFF) != 0) ||\n        (output_byte(encoder_output, context, (value_as_uint32 >> 16) & 0xFF) != 0) ||\n        (output_byte(encoder_output, context, (value_as_uint32 >> 8) & 0xFF) != 0) ||\n        (output_byte(encoder_output, context, (value_as_uint32) & 0xFF) != 0))\n    {\n        /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */\n        LogError(\"Failure encoding bytes for float\");\n        result = MU_FAILURE;\n    }\n    else\n    {\n        /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */\n        result = 0;\n    }\n\n    return result;\n}\n\nstatic int encode_float(AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context, float value)\n{\n    int result;\n\n    if ((encode_float_constructor(encoder_output, context) != 0) ||\n        (encode_float_value(encoder_output, context, value) != 0))\n    {\n        /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */\n        LogError(\"Failure encoding float value\");\n        result = MU_FAILURE;\n    }\n    else\n    {\n        /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */\n        result = 0;\n    }\n\n    return result;\n}\n\nstatic int encode_double_constructor(AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context)\n{\n    int result;\n\n    /* Codes_SRS_AMQPVALUE_01_290: [\\<encoding name=\"ieee-754\" code=\"0x82\" category=\"fixed\" width=\"8\" label=\"IEEE 754-2008 binary64\"/>] */\n    if (output_byte(encoder_output, context, 0x82) != 0)\n    {\n        /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */\n        LogError(\"Failure encoding constructor for double\");\n        result = MU_FAILURE;\n    }\n    else\n    {\n        /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */\n        result = 0;\n    }\n\n    return result;\n}\n\nstatic int encode_double_value(AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context, double value)\n{\n    int result;\n\n    uint64_t value_as_uint64 = *((uint64_t*)(void*)&value);\n    /* Codes_SRS_AMQPVALUE_01_290: [\\<encoding name=\"ieee-754\" code=\"0x82\" category=\"fixed\" width=\"8\" label=\"IEEE 754-2008 binary64\"/>] */\n    if ((output_byte(encoder_output, context, (value_as_uint64 >> 56) & 0xFF) != 0) ||\n        (output_byte(encoder_output, context, (value_as_uint64 >> 48) & 0xFF) != 0) ||\n        (output_byte(encoder_output, context, (value_as_uint64 >> 40) & 0xFF) != 0) ||\n        (output_byte(encoder_output, context, (value_as_uint64 >> 32) & 0xFF) != 0) ||\n        (output_byte(encoder_output, context, (value_as_uint64 >> 24) & 0xFF) != 0) ||\n        (output_byte(encoder_output, context, (value_as_uint64 >> 16) & 0xFF) != 0) ||\n        (output_byte(encoder_output, context, (value_as_uint64 >> 8) & 0xFF) != 0) ||\n        (output_byte(encoder_output, context, (value_as_uint64) & 0xFF) != 0))\n    {\n        /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */\n        LogError(\"Failure encoding bytes for double\");\n        result = MU_FAILURE;\n    }\n    else\n    {\n        /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */\n        result = 0;\n    }\n\n    return result;\n}\n\nstatic int encode_double(AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context, double value)\n{\n    int result;\n\n    if ((encode_double_constructor(encoder_output, context) != 0) ||\n        (encode_double_value(encoder_output, context, value) != 0))\n    {\n        /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */\n        LogError(\"Failure encoding double value\");\n        result = MU_FAILURE;\n    }\n    else\n    {\n        /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */\n        result = 0;\n    }\n\n    return result;\n}\n\nstatic int encode_timestamp_constructor(AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context)\n{\n    int result;\n\n    /* Codes_SRS_AMQPVALUE_01_295: [<encoding name=\"ms64\" code=\"0x83\" category=\"fixed\" width=\"8\" label=\"64-bit two's-complement integer representing milliseconds since the unix epoch\"/>] */\n    if (output_byte(encoder_output, context, 0x83) != 0)\n    {\n        /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */\n        LogError(\"Failed encoding timestamp constructor\");\n        result = MU_FAILURE;\n    }\n    else\n    {\n        /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */\n        result = 0;\n    }\n\n    return result;\n}\n\nstatic int encode_timestamp_value(AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context, int64_t value)\n{\n    int result;\n\n    /* Codes_SRS_AMQPVALUE_01_295: [<encoding name=\"ms64\" code=\"0x83\" category=\"fixed\" width=\"8\" label=\"64-bit two's-complement integer representing milliseconds since the unix epoch\"/>] */\n    if ((output_byte(encoder_output, context, (value >> 56) & 0xFF) != 0) ||\n        (output_byte(encoder_output, context, (value >> 48) & 0xFF) != 0) ||\n        (output_byte(encoder_output, context, (value >> 40) & 0xFF) != 0) ||\n        (output_byte(encoder_output, context, (value >> 32) & 0xFF) != 0) ||\n        (output_byte(encoder_output, context, (value >> 24) & 0xFF) != 0) ||\n        (output_byte(encoder_output, context, (value >> 16) & 0xFF) != 0) ||\n        (output_byte(encoder_output, context, (value >> 8) & 0xFF) != 0) ||\n        (output_byte(encoder_output, context, value & 0xFF) != 0))\n    {\n        /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */\n        LogError(\"Failed encoding timestamp value\");\n        result = MU_FAILURE;\n    }\n    else\n    {\n        /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */\n        result = 0;\n    }\n\n    return result;\n}\n\nstatic int encode_timestamp(AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context, int64_t value)\n{\n    int result;\n\n    if ((encode_timestamp_constructor(encoder_output, context) != 0) ||\n        (encode_timestamp_value(encoder_output, context, value) != 0))\n    {\n        /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */\n        LogError(\"Failed encoding timestamp\");\n        result = MU_FAILURE;\n    }\n    else\n    {\n        /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */\n        result = 0;\n    }\n\n    return result;\n}\n\nstatic int encode_uuid_constructor(AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context)\n{\n    int result;\n\n    /* Codes_SRS_AMQPVALUE_01_296: [<encoding code=\"0x98\" category=\"fixed\" width=\"16\" label=\"UUID as defined in section 4.1.2 of RFC-4122\"/>] */\n    if (output_byte(encoder_output, context, 0x98) != 0)\n    {\n        /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */\n        LogError(\"Failed encoding uuid constructor\");\n        result = MU_FAILURE;\n    }\n    else\n    {\n        /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */\n        result = 0;\n    }\n\n    return result;\n}\n\nstatic int encode_uuid_value(AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context, uuid uuid)\n{\n    int result;\n\n    /* Codes_SRS_AMQPVALUE_01_296: [<encoding code=\"0x98\" category=\"fixed\" width=\"16\" label=\"UUID as defined in section 4.1.2 of RFC-4122\"/>] */\n    if (output_bytes(encoder_output, context, uuid, 16)  != 0)\n    {\n        /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */\n        LogError(\"Failed encoding uuid value\");\n        result = MU_FAILURE;\n    }\n    else\n    {\n        /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */\n        result = 0;\n    }\n\n    return result;\n}\n\nstatic int encode_uuid(AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context, uuid uuid)\n{\n    int result;\n\n    if ((encode_uuid_constructor(encoder_output, context) != 0) ||\n        (encode_uuid_value(encoder_output, context, uuid) != 0))\n    {\n        /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */\n        LogError(\"Failed encoding uuid\");\n        result = MU_FAILURE;\n    }\n    else\n    {\n        /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */\n        result = 0;\n    }\n\n    return result;\n}\n\nstatic int encode_binary_constructor(AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context, bool use_smallest)\n{\n    int result;\n    if (use_smallest)\n    {\n        /* Codes_SRS_AMQPVALUE_01_297: [<encoding name=\"vbin8\" code=\"0xa0\" category=\"variable\" width=\"1\" label=\"up to 2^8 - 1 octets of binary data\"/>] */\n        if (output_byte(encoder_output, context, 0xA0) != 0)\n        {\n            /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */\n            LogError(\"Failed encoding small binary constructor\");\n            result = MU_FAILURE;\n        }\n        else\n        {\n            /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */\n            result = 0;\n        }\n    }\n    else\n    {\n        /* Codes_SRS_AMQPVALUE_01_298: [<encoding name=\"vbin32\" code=\"0xb0\" category=\"variable\" width=\"4\" label=\"up to 2^32 - 1 octets of binary data\"/>] */\n        if (output_byte(encoder_output, context, 0xB0) != 0)\n        {\n            /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */\n            LogError(\"Failed encoding large binary constructor\");\n            result = MU_FAILURE;\n        }\n        else\n        {\n            /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */\n            result = 0;\n        }\n    }\n\n    return result;\n}\n\nstatic int encode_binary_value(AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context, const unsigned char* value, uint32_t length, bool use_smallest)\n{\n    int result;\n    if (use_smallest)\n    {\n        /* Codes_SRS_AMQPVALUE_01_297: [<encoding name=\"vbin8\" code=\"0xa0\" category=\"variable\" width=\"1\" label=\"up to 2^8 - 1 octets of binary data\"/>] */\n        if ((output_byte(encoder_output, context, (unsigned char)length) != 0) ||\n            ((length > 0) && (output_bytes(encoder_output, context, value, length) != 0)))\n        {\n            /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */\n            LogError(\"Failed encoding small binary value\");\n            result = MU_FAILURE;\n        }\n        else\n        {\n            /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */\n            result = 0;\n        }\n    }\n    else\n    {\n        /* Codes_SRS_AMQPVALUE_01_298: [<encoding name=\"vbin32\" code=\"0xb0\" category=\"variable\" width=\"4\" label=\"up to 2^32 - 1 octets of binary data\"/>] */\n        if ((output_byte(encoder_output, context, (length >> 24) & 0xFF) != 0) ||\n            (output_byte(encoder_output, context, (length >> 16) & 0xFF) != 0) ||\n            (output_byte(encoder_output, context, (length >> 8) & 0xFF) != 0) ||\n            (output_byte(encoder_output, context, length & 0xFF) != 0) ||\n            (output_bytes(encoder_output, context, value, length) != 0))\n        {\n            /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */\n            LogError(\"Failed encoding large binary value\");\n            result = MU_FAILURE;\n        }\n        else\n        {\n            /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */\n            result = 0;\n        }\n    }\n\n    return result;\n}\n\nstatic int encode_binary(AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context, const unsigned char* value, uint32_t length)\n{\n    int result;\n    bool use_smallest = (length <= 255);\n\n    if ((encode_binary_constructor(encoder_output, context, use_smallest) != 0) ||\n        (encode_binary_value(encoder_output, context, value, length, use_smallest) != 0))\n    {\n        /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */\n        LogError(\"Failed encoding binary\");\n        result = MU_FAILURE;\n    }\n    else\n    {\n        /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */\n        result = 0;\n    }\n\n    return result;\n}\n\nstatic int encode_string_constructor(AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context, bool use_smallest)\n{\n    int result;\n\n    if (use_smallest)\n    {\n        /* Codes_SRS_AMQPVALUE_01_299: [<encoding name=\"str8-utf8\" code=\"0xa1\" category=\"variable\" width=\"1\" label=\"up to 2^8 - 1 octets worth of UTF-8 Unicode (with no byte order mark)\"/>] */\n        if (output_byte(encoder_output, context, (unsigned char)0xA1) != 0)\n        {\n            /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */\n            LogError(\"Failed encoding small string constructor\");\n            result = MU_FAILURE;\n        }\n        else\n        {\n            /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */\n            result = 0;\n        }\n    }\n    else\n    {\n        /* Codes_SRS_AMQPVALUE_01_300: [<encoding name=\"str32-utf8\" code=\"0xb1\" category=\"variable\" width=\"4\" label=\"up to 2^32 - 1 octets worth of UTF-8 Unicode (with no byte order mark)\"/>] */\n        if (output_byte(encoder_output, context, 0xB1) != 0)\n        {\n            /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */\n            LogError(\"Failed encoding large string constructor\");\n            result = MU_FAILURE;\n        }\n        else\n        {\n            /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */\n            result = 0;\n        }\n    }\n\n    return result;\n}\n\nstatic int encode_string_value(AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context, const char* value, size_t length, bool use_smallest)\n{\n    int result;\n\n    if (use_smallest)\n    {\n        /* Codes_SRS_AMQPVALUE_01_299: [<encoding name=\"str8-utf8\" code=\"0xa1\" category=\"variable\" width=\"1\" label=\"up to 2^8 - 1 octets worth of UTF-8 Unicode (with no byte order mark)\"/>] */\n        if ((output_byte(encoder_output, context, (unsigned char)length) != 0) ||\n            (output_bytes(encoder_output, context, value, length) != 0))\n        {\n            /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */\n            LogError(\"Failed encoding small string value\");\n            result = MU_FAILURE;\n        }\n        else\n        {\n            /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */\n            result = 0;\n        }\n    }\n    else\n    {\n        /* Codes_SRS_AMQPVALUE_01_300: [<encoding name=\"str32-utf8\" code=\"0xb1\" category=\"variable\" width=\"4\" label=\"up to 2^32 - 1 octets worth of UTF-8 Unicode (with no byte order mark)\"/>] */\n        if ((output_byte(encoder_output, context, (length >> 24) & 0xFF) != 0) ||\n            (output_byte(encoder_output, context, (length >> 16) & 0xFF) != 0) ||\n            (output_byte(encoder_output, context, (length >> 8) & 0xFF) != 0) ||\n            (output_byte(encoder_output, context, length & 0xFF) != 0) ||\n            (output_bytes(encoder_output, context, value, length) != 0))\n        {\n            /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */\n            LogError(\"Failed encoding large string value\");\n            result = MU_FAILURE;\n        }\n        else\n        {\n            /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */\n            result = 0;\n        }\n    }\n\n    return result;\n\n}\n\nstatic int encode_string(AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context, const char* value)\n{\n    int result;\n    size_t length = strlen(value);\n    bool use_smallest = (length <= 255);\n\n    if ((encode_string_constructor(encoder_output, context, use_smallest) != 0) ||\n        (encode_string_value(encoder_output, context, value, length, use_smallest) != 0))\n    {\n        /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */\n        LogError(\"Failed encoding string\");\n        result = MU_FAILURE;\n    }\n    else\n    {\n        /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */\n        result = 0;\n    }\n\n    return result;\n}\n\nstatic int encode_symbol_constructor(AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context, bool use_smallest)\n{\n    int result;\n\n    if (use_smallest)\n    {\n        /* Codes_SRS_AMQPVALUE_01_301: [<encoding name=\"sym8\" code=\"0xa3\" category=\"variable\" width=\"1\" label=\"up to 2^8 - 1 seven bit ASCII characters representing a symbolic value\"/>] */\n        if (output_byte(encoder_output, context, (unsigned char)0xA3) != 0)\n        {\n            /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */\n            LogError(\"Failed encoding small symbol constructor\");\n            result = MU_FAILURE;\n        }\n        else\n        {\n            /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */\n            result = 0;\n        }\n    }\n    else\n    {\n        /* Codes_SRS_AMQPVALUE_01_302: [<encoding name=\"sym32\" code=\"0xb3\" category=\"variable\" width=\"4\" label=\"up to 2^32 - 1 seven bit ASCII characters representing a symbolic value\"/>] */\n        if (output_byte(encoder_output, context, 0xB3) != 0)\n        {\n            /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */\n            LogError(\"Failed encoding large symbol constructor\");\n            result = MU_FAILURE;\n        }\n        else\n        {\n            /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */\n            result = 0;\n        }\n    }\n\n    return result;\n}\n\nstatic int encode_symbol_value(AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context, const char* value, size_t length, bool use_smallest)\n{\n    int result;\n\n    if (use_smallest)\n    {\n        /* Codes_SRS_AMQPVALUE_01_301: [<encoding name=\"sym8\" code=\"0xa3\" category=\"variable\" width=\"1\" label=\"up to 2^8 - 1 seven bit ASCII characters representing a symbolic value\"/>] */\n        if ((output_byte(encoder_output, context, (unsigned char)length) != 0) ||\n            (output_bytes(encoder_output, context, value, length) != 0))\n        {\n            /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */\n            LogError(\"Failed encoding small symbol value\");\n            result = MU_FAILURE;\n        }\n        else\n        {\n            /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */\n            result = 0;\n        }\n    }\n    else\n    {\n        /* Codes_SRS_AMQPVALUE_01_302: [<encoding name=\"sym32\" code=\"0xb3\" category=\"variable\" width=\"4\" label=\"up to 2^32 - 1 seven bit ASCII characters representing a symbolic value\"/>] */\n        if ((output_byte(encoder_output, context, (length >> 24) & 0xFF) != 0) ||\n            (output_byte(encoder_output, context, (length >> 16) & 0xFF) != 0) ||\n            (output_byte(encoder_output, context, (length >> 8) & 0xFF) != 0) ||\n            (output_byte(encoder_output, context, length & 0xFF) != 0) ||\n            /* Codes_SRS_AMQPVALUE_01_122: [Symbols are encoded as ASCII characters [ASCII].] */\n            (output_bytes(encoder_output, context, value, length) != 0))\n        {\n            /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */\n            LogError(\"Failed encoding large symbol value\");\n            result = MU_FAILURE;\n        }\n        else\n        {\n            /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */\n            result = 0;\n        }\n    }\n\n    return result;\n}\n\nstatic int encode_symbol(AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context, const char* value)\n{\n    int result;\n    size_t length = strlen(value);\n    bool use_smallest = (length <= 255);\n\n    if ((encode_symbol_constructor(encoder_output, context, use_smallest) != 0) ||\n        (encode_symbol_value(encoder_output, context, value, length, use_smallest) != 0))\n    {\n        /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */\n        LogError(\"Failed encoding symbol\");\n        result = MU_FAILURE;\n    }\n    else\n    {\n        /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */\n        result = 0;\n    }\n\n    return result;\n}\n\nstatic int encode_list_constructor(AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context, bool use_smallest)\n{\n    int result;\n\n    if (use_smallest)\n    {\n        /* Codes_SRS_AMQPVALUE_01_304: [<encoding name=\"list8\" code=\"0xc0\" category=\"compound\" width=\"1\" label=\"up to 2^8 - 1 list elements with total size less than 2^8 octets\"/>] */\n        if (output_byte(encoder_output, context, 0xC0) != 0)\n        {\n            /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */\n            LogError(\"Failed encoding list constructor\");\n            result = MU_FAILURE;\n        }\n        else\n        {\n            /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */\n            result = 0;\n        }\n    }\n    else\n    {\n        /* Codes_SRS_AMQPVALUE_01_305: [<encoding name=\"list32\" code=\"0xd0\" category=\"compound\" width=\"4\" label=\"up to 2^32 - 1 list elements with total size less than 2^32 octets\"/>] */\n        if (output_byte(encoder_output, context, 0xD0) != 0)\n        {\n            /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */\n            LogError(\"Failed encoding large list constructor\");\n            result = MU_FAILURE;\n        }\n        else\n        {\n            /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */\n            result = 0;\n        }\n    }\n\n    return result;\n}\n\nstatic int amqpvalue_get_encoded_list_size(AMQP_VALUE* items, uint32_t count, uint32_t* encoded_size)\n{\n    int result;\n    size_t i;\n\n    if (encoded_size == NULL)\n    {\n        LogError(\"Bad arguments: encoded_size = %p\", encoded_size);\n        result = MU_FAILURE;\n    }\n    else\n    {\n        *encoded_size = 0;\n\n        /* Get the size of all items in the list */\n        for (i = 0; i < count; i++)\n        {\n            size_t item_size;\n            if (amqpvalue_get_encoded_size(items[i], &item_size) != 0)\n            {\n                LogError(\"Could not get encoded size for element %u of the list\", (unsigned int)i);\n                break;\n            }\n\n            if ((item_size > UINT32_MAX) ||\n                *encoded_size + (uint32_t)item_size < *encoded_size)\n            {\n                LogError(\"Overflow in list size computation\");\n                break;\n            }\n\n            *encoded_size = (uint32_t)(*encoded_size + item_size);\n        }\n\n        if (i < count)\n        {\n            result = MU_FAILURE;\n        }\n        else\n        {\n            result = 0;\n        }\n    }\n    return result;\n}\n\nstatic int encode_list_value(AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context, uint32_t count, uint32_t size, AMQP_VALUE* items, bool use_smallest)\n{\n    int result;\n    size_t i;\n\n    if (use_smallest)\n    {\n        size++;\n\n        /* Codes_SRS_AMQPVALUE_01_304: [<encoding name=\"list8\" code=\"0xc0\" category=\"compound\" width=\"1\" label=\"up to 2^8 - 1 list elements with total size less than 2^8 octets\"/>] */\n        if ((output_byte(encoder_output, context, (size & 0xFF)) != 0) ||\n            (output_byte(encoder_output, context, (count & 0xFF)) != 0))\n        {\n            /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */\n            LogError(\"Failed encoding list value\");\n            result = MU_FAILURE;\n        }\n        else\n        {\n            /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */\n            result = 0;\n        }\n    }\n    else\n    {\n        size += 4;\n\n        /* Codes_SRS_AMQPVALUE_01_305: [<encoding name=\"list32\" code=\"0xd0\" category=\"compound\" width=\"4\" label=\"up to 2^32 - 1 list elements with total size less than 2^32 octets\"/>] */\n        if ((output_byte(encoder_output, context, (size >> 24) & 0xFF) != 0) ||\n            (output_byte(encoder_output, context, (size >> 16) & 0xFF) != 0) ||\n            (output_byte(encoder_output, context, (size >> 8) & 0xFF) != 0) ||\n            (output_byte(encoder_output, context, size & 0xFF) != 0) ||\n            (output_byte(encoder_output, context, (count >> 24) & 0xFF) != 0) ||\n            (output_byte(encoder_output, context, (count >> 16) & 0xFF) != 0) ||\n            (output_byte(encoder_output, context, (count >> 8) & 0xFF) != 0) ||\n            (output_byte(encoder_output, context, count & 0xFF) != 0))\n        {\n            /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */\n            LogError(\"Failed encoding large list value\");\n            result = MU_FAILURE;\n        }\n        else\n        {\n            /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */\n            result = 0;\n        }\n    }\n\n    if (result == 0)\n    {\n        for (i = 0; i < count; i++)\n        {\n            if (amqpvalue_encode(items[i], encoder_output, context) != 0)\n            {\n                break;\n            }\n        }\n\n        if (i < count)\n        {\n            LogError(\"Failed encoding element %u of the list\", (unsigned int)i);\n            result = MU_FAILURE;\n        }\n        else\n        {\n            result = 0;\n        }\n    }\n    return result;\n}\n\nstatic int encode_list(AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context, uint32_t count, AMQP_VALUE* items)\n{\n    int result;\n\n    if (count == 0)\n    {\n        /* Codes_SRS_AMQPVALUE_01_303: [<encoding name=\"list0\" code=\"0x45\" category=\"fixed\" width=\"0\" label=\"the empty list (i.e. the list with no elements)\"/>] */\n        if (output_byte(encoder_output, context, 0x45) != 0)\n        {\n            /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */\n            LogError(\"Could not output list constructor byte\");\n            result = MU_FAILURE;\n        }\n        else\n        {\n            /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */\n            result = 0;\n        }\n    }\n    else\n    {\n        uint32_t size;\n\n        if (amqpvalue_get_encoded_list_size(items, count, &size) != 0)\n        {\n            /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */\n            result = MU_FAILURE;\n        }\n        else\n        {\n            if ((count <= 255) && (size < 255))\n            {\n                /* Codes_SRS_AMQPVALUE_01_304: [<encoding name=\"list8\" code=\"0xc0\" category=\"compound\" width=\"1\" label=\"up to 2^8 - 1 list elements with total size less than 2^8 octets\"/>] */\n                if ((encode_list_constructor(encoder_output, context, true) != 0) ||\n                    (encode_list_value(encoder_output, context, count, size, items, true) != 0))\n                {\n                    /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */\n                    LogError(\"Failed encoding small list\");\n                    result = MU_FAILURE;\n                }\n                else\n                {\n                    /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */\n                    result = 0;\n                }\n            }\n            else\n            {\n                /* Codes_SRS_AMQPVALUE_01_305: [<encoding name=\"list32\" code=\"0xd0\" category=\"compound\" width=\"4\" label=\"up to 2^32 - 1 list elements with total size less than 2^32 octets\"/>] */\n                if ((encode_list_constructor(encoder_output, context, false) != 0) ||\n                    (encode_list_value(encoder_output, context, count, size, items, false) != 0))\n                {\n                    /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */\n                    LogError(\"Failed encoding large list\");\n                    result = MU_FAILURE;\n                }\n                else\n                {\n                    /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */\n                    result = 0;\n                }\n            }\n        }\n    }\n\n    return result;\n}\n\nstatic int encode_map_constructor(AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context, bool use_smallest)\n{\n    int result;\n\n    if (use_smallest)\n    {\n        /* Codes_SRS_AMQPVALUE_01_306: [<encoding name=\"map8\" code=\"0xc1\" category=\"compound\" width=\"1\" label=\"up to 2^8 - 1 octets of encoded map data\"/>] */\n        if (output_byte(encoder_output, context, 0xC1) != 0)\n        {\n            /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */\n            LogError(\"Could not encode small map constructor\");\n            result = MU_FAILURE;\n        }\n        else\n        {\n            /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */\n            result = 0;\n        }\n    }\n    else\n    {\n        /* Codes_SRS_AMQPVALUE_01_307: [<encoding name=\"map32\" code=\"0xd1\" category=\"compound\" width=\"4\" label=\"up to 2^32 - 1 octets of encoded map data\"/>] */\n        if (output_byte(encoder_output, context, 0xD1) != 0)\n        {\n            /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */\n            LogError(\"Could not encode large map constructor\");\n            result = MU_FAILURE;\n        }\n        else\n        {\n            /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */\n            result = 0;\n        }\n    }\n\n    return result;\n}\n\nstatic int amqpvalue_get_encoded_map_size(AMQP_MAP_KEY_VALUE_PAIR* pairs, uint32_t count, uint32_t* encoded_size)\n{\n    size_t i;\n    int result;\n\n    if (encoded_size == NULL)\n    {\n        LogError(\"Bad arguments: encoded_size = %p\", encoded_size);\n        result = MU_FAILURE;\n    }\n    else\n    {\n        *encoded_size = 0;\n\n        /* Get the size of all items in the map */\n        for (i = 0; i < count; i++)\n        {\n            size_t item_size;\n            if (amqpvalue_get_encoded_size(pairs[i].key, &item_size) != 0)\n            {\n                LogError(\"Could not get encoded size for key element %u of the map\", (unsigned int)i);\n                break;\n            }\n\n            if ((item_size > UINT32_MAX) ||\n                *encoded_size + (uint32_t)item_size < *encoded_size)\n            {\n                LogError(\"Encoded data is more than the max size for a map\");\n                break;\n            }\n\n            *encoded_size = (uint32_t)(*encoded_size + item_size);\n\n            if (amqpvalue_get_encoded_size(pairs[i].value, &item_size) != 0)\n            {\n                LogError(\"Could not get encoded size for value element %u of the map\", (unsigned int)i);\n                break;\n            }\n\n            if ((item_size > UINT32_MAX) ||\n                *encoded_size + (uint32_t)item_size < *encoded_size)\n            {\n                LogError(\"Encoded data is more than the max size for a map\");\n                break;\n            }\n\n            *encoded_size = (uint32_t)(*encoded_size + item_size);\n        }\n\n        if (i < count)\n        {\n            result = MU_FAILURE;\n        }\n        else\n        {\n            result = 0;\n        }\n    }\n    return result;\n}\n\nstatic int encode_map_value(AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context, uint32_t count, uint32_t size, AMQP_MAP_KEY_VALUE_PAIR* pairs, bool use_smallest)\n{\n    int result;\n    size_t i;\n\n    /* Codes_SRS_AMQPVALUE_01_124: [Map encodings MUST contain an even number of items (i.e. an equal number of keys and values).] */\n    uint32_t elements = count * 2;\n\n    if (use_smallest)\n    {\n        size++;\n\n        /* Codes_SRS_AMQPVALUE_01_306: [<encoding name=\"map8\" code=\"0xc1\" category=\"compound\" width=\"1\" label=\"up to 2^8 - 1 octets of encoded map data\"/>] */\n        if ((output_byte(encoder_output, context, (size & 0xFF)) != 0) ||\n            (output_byte(encoder_output, context, (elements & 0xFF)) != 0))\n        {\n            /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */\n            LogError(\"Could not encode small map header\");\n            result = MU_FAILURE;\n        }\n        else\n        {\n            /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */\n            result = 0;\n        }\n    }\n    else\n    {\n        size += 4;\n\n        /* Codes_SRS_AMQPVALUE_01_307: [<encoding name=\"map32\" code=\"0xd1\" category=\"compound\" width=\"4\" label=\"up to 2^32 - 1 octets of encoded map data\"/>] */\n        if ((output_byte(encoder_output, context, (size >> 24) & 0xFF) != 0) ||\n            (output_byte(encoder_output, context, (size >> 16) & 0xFF) != 0) ||\n            (output_byte(encoder_output, context, (size >> 8) & 0xFF) != 0) ||\n            (output_byte(encoder_output, context, size & 0xFF) != 0) ||\n            (output_byte(encoder_output, context, (elements >> 24) & 0xFF) != 0) ||\n            (output_byte(encoder_output, context, (elements >> 16) & 0xFF) != 0) ||\n            (output_byte(encoder_output, context, (elements >> 8) & 0xFF) != 0) ||\n            (output_byte(encoder_output, context, elements & 0xFF) != 0))\n        {\n            /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */\n            LogError(\"Could not encode large map header\");\n            result = MU_FAILURE;\n        }\n        else\n        {\n            /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */\n            result = 0;\n        }\n    }\n\n    if (result == 0)\n    {\n        /* Codes_SRS_AMQPVALUE_01_123: [A map is encoded as a compound value where the constituent elements form alternating key value pairs.] */\n        for (i = 0; i < count; i++)\n        {\n            if ((amqpvalue_encode(pairs[i].key, encoder_output, context) != 0) ||\n                (amqpvalue_encode(pairs[i].value, encoder_output, context) != 0))\n            {\n                LogError(\"Failed encoding map element %u\", (unsigned int)i);\n                break;\n            }\n        }\n\n        if (i < count)\n        {\n            LogError(\"Could not encode map\");\n            result = MU_FAILURE;\n        }\n        else\n        {\n            result = 0;\n        }\n    }\n    return result;\n}\n\nstatic int encode_map(AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context, uint32_t count, AMQP_MAP_KEY_VALUE_PAIR* pairs)\n{\n    int result;\n    uint32_t size;\n\n    /* Codes_SRS_AMQPVALUE_01_124: [Map encodings MUST contain an even number of items (i.e. an equal number of keys and values).] */\n    uint32_t elements = count * 2;\n\n    if (amqpvalue_get_encoded_map_size(pairs, count, &size) != 0)\n    {\n        /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */\n        result = MU_FAILURE;\n    }\n    else\n    {\n        if ((elements <= 255) && (size < 255))\n        {\n            /* Codes_SRS_AMQPVALUE_01_306: [<encoding name=\"map8\" code=\"0xc1\" category=\"compound\" width=\"1\" label=\"up to 2^8 - 1 octets of encoded map data\"/>] */\n            if ((encode_map_constructor(encoder_output, context, true) != 0) ||\n                (encode_map_value(encoder_output, context, count, size, pairs, true) != 0))\n            {\n                /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */\n                LogError(\"Could not encode small map\");\n                result = MU_FAILURE;\n            }\n            else\n            {\n                /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */\n                result = 0;\n            }\n        }\n        else\n        {\n            /* Codes_SRS_AMQPVALUE_01_307: [<encoding name=\"map32\" code=\"0xd1\" category=\"compound\" width=\"4\" label=\"up to 2^32 - 1 octets of encoded map data\"/>] */\n            if ((encode_map_constructor(encoder_output, context, false) != 0) ||\n                (encode_map_value(encoder_output, context, count, size, pairs, false) != 0))\n            {\n                /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */\n                LogError(\"Could not encode large map\");\n                result = MU_FAILURE;\n            }\n            else\n            {\n                /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */\n                result = 0;\n            }\n        }\n    }\n\n    return result;\n}\n\nstatic int encode_array_constructor(AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context, bool use_smallest)\n{\n    int result;\n\n    if (use_smallest)\n    {\n        /* Codes_SRS_AMQPVALUE_01_306: [<encoding name=\"map8\" code=\"0xE0\" category=\"compound\" width=\"1\" label=\"up to 2^8 - 1 octets of encoded map data\"/>] */\n        if (output_byte(encoder_output, context, 0xE0) != 0)\n        {\n            /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */\n            LogError(\"Could not encode small array constructor\");\n            result = MU_FAILURE;\n        }\n        else\n        {\n            /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */\n            result = 0;\n        }\n    }\n    else\n    {\n        /* Codes_SRS_AMQPVALUE_01_307: [<encoding name=\"map32\" code=\"0xF0\" category=\"compound\" width=\"4\" label=\"up to 2^32 - 1 octets of encoded map data\"/>] */\n        if (output_byte(encoder_output, context, 0xF0) != 0)\n        {\n            /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */\n            LogError(\"Could not encode large array constructor\");\n            result = MU_FAILURE;\n        }\n        else\n        {\n            /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */\n            result = 0;\n        }\n    }\n\n    return result;\n}\n\nstatic int amqpvalue_get_encoded_array_size(AMQP_VALUE* items, uint32_t count, uint32_t* encoded_size)\n{\n    size_t i;\n    int result;\n\n    if (encoded_size == NULL)\n    {\n        LogError(\"Bad arguments: encoded_size = %p\", encoded_size);\n        result = MU_FAILURE;\n    }\n    else\n    {\n        *encoded_size = 0;\n\n        /* Get the size of all items in the array */\n        for (i = 0; i < count; i++)\n        {\n            size_t item_size;\n            if (amqpvalue_get_encoded_array_item_size(items[i], &item_size) != 0)\n            {\n                LogError(\"Could not get encoded size for element %u of the array\", (unsigned int)i);\n                break;\n            }\n\n            if ((item_size > UINT32_MAX) ||\n                *encoded_size + (uint32_t)item_size < *encoded_size)\n            {\n                LogError(\"Overflow in array size computation\");\n                break;\n            }\n\n            *encoded_size = (uint32_t)(*encoded_size + item_size);\n        }\n\n        if (i < count)\n        {\n            result = MU_FAILURE;\n        }\n        else\n        {\n            if (*encoded_size > count)\n            {\n                /* Include a single constructor byte in the size calculation where array items require a constructor. */\n                (*encoded_size)++;\n            }\n            result = 0;\n        }\n    }\n    return result;\n}\n\nstatic int encode_array_value(AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context, uint32_t count, uint32_t size, AMQP_VALUE* items, bool use_smallest)\n{\n    int result;\n    size_t i;\n\n    if (use_smallest)\n    {\n        size++;\n\n        /* Codes_SRS_AMQPVALUE_01_306: [<encoding name=\"map8\" code=\"0xE0\" category=\"compound\" width=\"1\" label=\"up to 2^8 - 1 octets of encoded map data\"/>] */\n        if ((output_byte(encoder_output, context, (size & 0xFF)) != 0) ||\n            (output_byte(encoder_output, context, (count & 0xFF)) != 0))\n        {\n            /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */\n            LogError(\"Could not encode small array header\");\n            result = MU_FAILURE;\n        }\n        else\n        {\n            /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */\n            result = 0;\n        }\n    }\n    else\n    {\n        size += 4;\n\n        /* Codes_SRS_AMQPVALUE_01_307: [<encoding name=\"map32\" code=\"0xF0\" category=\"compound\" width=\"4\" label=\"up to 2^32 - 1 octets of encoded map data\"/>] */\n        if ((output_byte(encoder_output, context, (size >> 24) & 0xFF) != 0) ||\n            (output_byte(encoder_output, context, (size >> 16) & 0xFF) != 0) ||\n            (output_byte(encoder_output, context, (size >> 8) & 0xFF) != 0) ||\n            (output_byte(encoder_output, context, size & 0xFF) != 0) ||\n            (output_byte(encoder_output, context, (count >> 24) & 0xFF) != 0) ||\n            (output_byte(encoder_output, context, (count >> 16) & 0xFF) != 0) ||\n            (output_byte(encoder_output, context, (count >> 8) & 0xFF) != 0) ||\n            (output_byte(encoder_output, context, count & 0xFF) != 0))\n        {\n            /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */\n            LogError(\"Could not encode large array header\");\n            result = MU_FAILURE;\n        }\n        else\n        {\n            /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */\n            result = 0;\n        }\n    }\n\n    if (result == 0)\n    {\n        bool first_element = true;\n\n        for (i = 0; i < count; i++)\n        {\n            if (amqpvalue_encode_array_item(items[i], first_element, encoder_output, context) != 0)\n            {\n                LogError(\"Failed encoding element %u of the array\", (unsigned int)i);\n                break;\n            }\n            first_element = false;\n        }\n\n        if (i < count)\n        {\n            LogError(\"Could not encode array\");\n            result = MU_FAILURE;\n        }\n        else\n        {\n            result = 0;\n        }\n    }\n    return result;\n}\n\nstatic int encode_array(AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context, uint32_t count, AMQP_VALUE* items)\n{\n    int result;\n    uint32_t size;\n\n    if (amqpvalue_get_encoded_array_size(items, count, &size) != 0)\n    {\n        /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */\n        result = MU_FAILURE;\n    }\n    else\n    {\n        if ((count <= 255) && (size < 255))\n        {\n            /* Codes_SRS_AMQPVALUE_01_306: [<encoding name=\"map8\" code=\"0xE0\" category=\"compound\" width=\"1\" label=\"up to 2^8 - 1 octets of encoded map data\"/>] */\n            if ((encode_array_constructor(encoder_output, context, true) != 0) ||\n                (encode_array_value(encoder_output,context, count, size, items, true) != 0))\n            {\n                /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */\n                LogError(\"Could not encode small array\");\n                result = MU_FAILURE;\n            }\n            else\n            {\n                /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */\n                result = 0;\n            }\n        }\n        else\n        {\n            /* Codes_SRS_AMQPVALUE_01_307: [<encoding name=\"map32\" code=\"0xF0\" category=\"compound\" width=\"4\" label=\"up to 2^32 - 1 octets of encoded map data\"/>] */\n            if ((encode_array_constructor(encoder_output, context, false) != 0) ||\n                (encode_array_value(encoder_output, context, count, size, items, false) != 0))\n            {\n                /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */\n                LogError(\"Could not encode large array\");\n                result = MU_FAILURE;\n            }\n            else\n            {\n                /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */\n                result = 0;\n            }\n        }\n    }\n\n    return result;\n}\n\nstatic int encode_descriptor_header(AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context)\n{\n    int result;\n\n    if (output_byte(encoder_output, context, 0x00) != 0)\n    {\n        LogError(\"Failed encoding descriptor header\");\n        result = MU_FAILURE;\n    }\n    else\n    {\n        result = 0;\n    }\n\n    return result;\n}\n\n/* Codes_SRS_AMQPVALUE_01_265: [amqpvalue_encode shall encode the value per the ISO.] */\nint amqpvalue_encode(AMQP_VALUE value, AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context)\n{\n    int result;\n\n    /* Codes_SRS_AMQPVALUE_01_269: [If value or encoder_output are NULL, amqpvalue_encode shall fail and return a non-zero value.] */\n    if ((value == NULL) ||\n        (encoder_output == NULL))\n    {\n        LogError(\"Bad arguments: value = %p, encoder_output = %p\",\n            value, encoder_output);\n        result = MU_FAILURE;\n    }\n    else\n    {\n        AMQP_VALUE_DATA* value_data = (AMQP_VALUE_DATA*)value;\n\n        switch (value_data->type)\n        {\n        default:\n            /* Codes_SRS_AMQPVALUE_01_271: [If encoding fails due to any error not specifically mentioned here, it shall return a non-zero value.] */\n            LogError(\"Invalid type: %d\", (int)value_data->type);\n            result = MU_FAILURE;\n            break;\n\n        case AMQP_TYPE_NULL:\n            /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */\n            result = encode_null(encoder_output, context);\n            break;\n\n        case AMQP_TYPE_BOOL:\n            result = encode_boolean(encoder_output, context, value_data->value.bool_value);\n            break;\n\n        case AMQP_TYPE_UBYTE:\n            result = encode_ubyte(encoder_output, context, value_data->value.ubyte_value);\n            break;\n\n        case AMQP_TYPE_USHORT:\n            result = encode_ushort(encoder_output, context, value_data->value.ushort_value);\n            break;\n\n        case AMQP_TYPE_UINT:\n            result = encode_uint(encoder_output, context, value_data->value.uint_value);\n            break;\n\n        case AMQP_TYPE_ULONG:\n            result = encode_ulong(encoder_output, context, value_data->value.ulong_value);\n            break;\n\n        case AMQP_TYPE_BYTE:\n            result = encode_byte(encoder_output, context, value_data->value.byte_value);\n            break;\n\n        case AMQP_TYPE_SHORT:\n            result = encode_short(encoder_output, context, value_data->value.short_value);\n            break;\n\n        case AMQP_TYPE_INT:\n            result = encode_int(encoder_output, context, value_data->value.int_value);\n            break;\n\n        case AMQP_TYPE_LONG:\n            result = encode_long(encoder_output, context, value_data->value.long_value);\n            break;\n\n        case AMQP_TYPE_FLOAT:\n            result = encode_float(encoder_output, context, value_data->value.float_value);\n            break;\n\n        case AMQP_TYPE_DOUBLE:\n            result = encode_double(encoder_output, context, value_data->value.double_value);\n            break;\n\n        case AMQP_TYPE_TIMESTAMP:\n            result = encode_timestamp(encoder_output, context, value_data->value.timestamp_value);\n            break;\n\n        case AMQP_TYPE_UUID:\n            result = encode_uuid(encoder_output, context, value_data->value.uuid_value);\n            break;\n\n        case AMQP_TYPE_BINARY:\n            result = encode_binary(encoder_output, context, (const unsigned char*)value_data->value.binary_value.bytes, value_data->value.binary_value.length);\n            break;\n\n        case AMQP_TYPE_STRING:\n            result = encode_string(encoder_output, context, value_data->value.string_value.chars);\n            break;\n\n        case AMQP_TYPE_SYMBOL:\n            result = encode_symbol(encoder_output, context, value_data->value.symbol_value.chars);\n            break;\n\n        case AMQP_TYPE_LIST:\n            result = encode_list(encoder_output, context, value_data->value.list_value.count, value_data->value.list_value.items);\n            break;\n\n        case AMQP_TYPE_ARRAY:\n            result = encode_array(encoder_output, context, value_data->value.array_value.count, value_data->value.array_value.items);\n            break;\n\n        case AMQP_TYPE_MAP:\n            result = encode_map(encoder_output, context, value_data->value.map_value.pair_count, value_data->value.map_value.pairs);\n            break;\n\n        case AMQP_TYPE_COMPOSITE:\n        case AMQP_TYPE_DESCRIBED:\n        {\n            if ((encode_descriptor_header(encoder_output, context) != 0) ||\n                (amqpvalue_encode(value_data->value.described_value.descriptor, encoder_output, context) != 0) ||\n                (amqpvalue_encode(value_data->value.described_value.value, encoder_output, context) != 0))\n            {\n                LogError(\"Failed encoding described or composite type\");\n                result = MU_FAILURE;\n            }\n            else\n            {\n                result = 0;\n            }\n\n            break;\n        }\n        }\n    }\n\n    return result;\n}\n\nstatic int amqpvalue_encode_array_item(AMQP_VALUE item, bool first_element, AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context)\n{\n    int result;\n\n    if ((item == NULL) ||\n        (encoder_output == NULL))\n    {\n        LogError(\"Bad arguments: item = %p, encoder_output = %p\", item, encoder_output);\n        result = MU_FAILURE;\n    }\n    else\n    {\n        AMQP_VALUE_DATA* value_data = (AMQP_VALUE_DATA*)item;\n\n        switch (value_data->type)\n        {\n            default:\n                LogError(\"Unsupported array type: %d\", (int)value_data->type);\n                result = MU_FAILURE;\n                break;\n\n            case AMQP_TYPE_NULL:\n                if ((first_element) && (encode_null_constructor(encoder_output, context) != 0))\n                {\n                    result = MU_FAILURE;\n                    break;\n                }\n                result = encode_null_value(encoder_output, context);\n                break;\n\n            case AMQP_TYPE_BOOL:\n                if ((first_element) && (encode_boolean_constructor(encoder_output, context) != 0))\n                {\n                    result = MU_FAILURE;\n                    break;\n                }\n                result = encode_boolean_value(encoder_output, context, value_data->value.bool_value);\n                break;\n\n            case AMQP_TYPE_UBYTE:\n                if ((first_element) && (encode_ubyte_constructor(encoder_output, context) != 0))\n                {\n                    result = MU_FAILURE;\n                    break;\n                }\n                result = encode_ubyte_value(encoder_output, context, value_data->value.ubyte_value);\n                break;\n\n            case AMQP_TYPE_USHORT:\n                if ((first_element) && (encode_ushort_constructor(encoder_output, context) != 0))\n                {\n                    result = MU_FAILURE;\n                    break;\n                }\n                result = encode_ushort_value(encoder_output, context, value_data->value.ushort_value);\n                break;\n\n            case AMQP_TYPE_UINT:\n                if ((first_element) && (encode_uint_constructor(encoder_output, context, false) != 0))\n                {\n                    result = MU_FAILURE;\n                    break;\n                }\n                result = encode_uint_value(encoder_output, context, value_data->value.uint_value, false);\n                break;\n\n            case AMQP_TYPE_ULONG:\n                if ((first_element) && (encode_ulong_constructor(encoder_output, context, false) != 0))\n                {\n                    result = MU_FAILURE;\n                    break;\n                }\n                result = encode_ulong_value(encoder_output, context, value_data->value.ulong_value, false);\n                break;\n\n            case AMQP_TYPE_BYTE:\n                if ((first_element) && (encode_byte_constructor(encoder_output, context) != 0))\n                {\n                    result = MU_FAILURE;\n                    break;\n                }\n                result = encode_byte_value(encoder_output, context, value_data->value.byte_value);\n                break;\n\n            case AMQP_TYPE_SHORT:\n                if ((first_element) && (encode_short_constructor(encoder_output, context) != 0))\n                {\n                    result = MU_FAILURE;\n                    break;\n                }\n                result = encode_short_value(encoder_output, context, value_data->value.short_value);\n                break;\n\n            case AMQP_TYPE_INT:\n                if ((first_element) && (encode_int_constructor(encoder_output, context, false) != 0))\n                {\n                    result = MU_FAILURE;\n                    break;\n                }\n                result = encode_int_value(encoder_output, context, value_data->value.int_value, false);\n                break;\n\n            case AMQP_TYPE_LONG:\n                if ((first_element) && (encode_long_constructor(encoder_output, context, false) != 0))\n                {\n                    result = MU_FAILURE;\n                    break;\n                }\n                result = encode_long_value(encoder_output, context, value_data->value.long_value, false);\n                break;\n\n            case AMQP_TYPE_FLOAT:\n                if ((first_element) && (encode_float_constructor(encoder_output, context) != 0))\n                {\n                    result = MU_FAILURE;\n                    break;\n                }\n                result = encode_float_value(encoder_output, context, value_data->value.float_value);\n                break;\n\n            case AMQP_TYPE_DOUBLE:\n                if ((first_element) && (encode_double_constructor(encoder_output, context) != 0))\n                {\n                    result = MU_FAILURE;\n                    break;\n                }\n                result = encode_double_value(encoder_output, context, value_data->value.double_value);\n                break;\n\n            case AMQP_TYPE_TIMESTAMP:\n                if ((first_element) && (encode_timestamp_constructor(encoder_output, context) != 0))\n                {\n                    result = MU_FAILURE;\n                    break;\n                }\n                result = encode_timestamp_value(encoder_output, context, value_data->value.timestamp_value);\n                break;\n\n            case AMQP_TYPE_UUID:\n                if ((first_element) && (encode_uuid_constructor(encoder_output, context) != 0))\n                {\n                    result = MU_FAILURE;\n                    break;\n                }\n                result = encode_uuid_value(encoder_output, context, value_data->value.uuid_value);\n                break;\n\n            case AMQP_TYPE_BINARY:\n                if ((first_element) && (encode_binary_constructor(encoder_output, context, false) != 0))\n                {\n                    result = MU_FAILURE;\n                    break;\n                }\n                result = encode_binary_value(encoder_output, context, (const unsigned char*)value_data->value.binary_value.bytes, value_data->value.binary_value.length, false);\n                break;\n\n            case AMQP_TYPE_STRING:\n                if ((first_element) && (encode_string_constructor(encoder_output, context, false) != 0))\n                {\n                    result = MU_FAILURE;\n                    break;\n                }\n                result = encode_string_value(encoder_output, context, value_data->value.string_value.chars, strlen(value_data->value.string_value.chars), false);\n                break;\n\n            case AMQP_TYPE_SYMBOL:\n                if ((first_element) && (encode_symbol_constructor(encoder_output, context, false) != 0))\n                {\n                    result = MU_FAILURE;\n                    break;\n                }\n                result = encode_symbol_value(encoder_output, context, value_data->value.symbol_value.chars, strlen(value_data->value.symbol_value.chars), false);\n                break;\n\n            case AMQP_TYPE_LIST:\n            {\n                uint32_t list_size;\n\n                if ((first_element) && (encode_list_constructor(encoder_output, context, false) != 0))\n                {\n                    result = MU_FAILURE;\n                }\n                else if (amqpvalue_get_encoded_list_size(value_data->value.list_value.items, value_data->value.list_value.count, &list_size) != 0)\n                {\n                    result = MU_FAILURE;\n                }\n                else\n                {\n                    result = encode_list_value(encoder_output, context, value_data->value.list_value.count, list_size, value_data->value.list_value.items, false);\n                }\n                break;\n            }\n\n            case AMQP_TYPE_MAP:\n            {\n                uint32_t map_size;\n\n                if ((first_element) && (encode_map_constructor(encoder_output, context, false) != 0))\n                {\n                    result = MU_FAILURE;\n                }\n                else if (amqpvalue_get_encoded_map_size(value_data->value.map_value.pairs, value_data->value.map_value.pair_count, &map_size) != 0)\n                {\n                    result = MU_FAILURE;\n                }\n                else\n                {\n                    result = encode_map_value(encoder_output, context, value_data->value.map_value.pair_count, map_size, value_data->value.map_value.pairs, false);\n                }\n                break;\n            }\n\n            case AMQP_TYPE_ARRAY:\n            {\n                uint32_t array_size;\n\n                if ((first_element) && (encode_array_constructor(encoder_output, context, false) != 0))\n                {\n                    result = MU_FAILURE;\n                }\n                else if (amqpvalue_get_encoded_array_size(value_data->value.array_value.items, value_data->value.array_value.count, &array_size) != 0)\n                {\n                    result = MU_FAILURE;\n                }\n                else\n                {\n                    result = encode_array_value(encoder_output, context, value_data->value.array_value.count, array_size, value_data->value.array_value.items, false);\n                }\n                break;\n            }\n        }\n    }\n    return result;\n}\n\nstatic int count_bytes(void* context, const unsigned char* bytes, size_t length)\n{\n    size_t* byte_count;\n    (void)bytes;\n\n    byte_count = (size_t*)context;\n    *byte_count += length;\n\n    return 0;\n}\n\n/* Codes_SRS_AMQPVALUE_01_308: [amqpvalue_get_encoded_size shall fill in the encoded_size argument the number of bytes required to encode the given AMQP value.] */\nint amqpvalue_get_encoded_size(AMQP_VALUE value, size_t* encoded_size)\n{\n    int result;\n\n    /* Codes_SRS_AMQPVALUE_01_309: [If any argument is NULL, amqpvalue_get_encoded_size shall return a non-zero value.] */\n    if ((value == NULL) ||\n        (encoded_size == NULL))\n    {\n        LogError(\"Bad arguments: value = %p, encoded_size = %p\",\n            value, encoded_size);\n        result = MU_FAILURE;\n    }\n    else\n    {\n        *encoded_size = 0;\n        result = amqpvalue_encode(value, count_bytes, encoded_size);\n    }\n\n    return result;\n}\n\nstatic int amqpvalue_get_encoded_array_item_size(AMQP_VALUE item, size_t* encoded_size)\n{\n    int result;\n\n    if ((item == NULL) ||\n        (encoded_size == NULL))\n    {\n        LogError(\"Bad arguments: item = %p, encoded_size = %p\", item, encoded_size);\n        result = MU_FAILURE;\n    }\n    else\n    {\n        *encoded_size = 0;\n        result = amqpvalue_encode_array_item(item, false, count_bytes, encoded_size);\n    }\n\n    return result;\n}\n\nstatic void amqpvalue_clear(AMQP_VALUE_DATA* value_data)\n{\n    switch (value_data->type)\n    {\n    default:\n        break;\n\n    case AMQP_TYPE_BINARY:\n        if (value_data->value.binary_value.bytes != NULL)\n        {\n            free((void*)value_data->value.binary_value.bytes);\n        }\n        break;\n    case AMQP_TYPE_STRING:\n        if (value_data->value.string_value.chars != NULL)\n        {\n            free(value_data->value.string_value.chars);\n        }\n        break;\n    case AMQP_TYPE_SYMBOL:\n        if (value_data->value.symbol_value.chars != NULL)\n        {\n            free(value_data->value.symbol_value.chars);\n        }\n        break;\n    case AMQP_TYPE_LIST:\n    {\n        if (value_data->value.list_value.items != NULL)\n        {\n            size_t i;\n            for (i = 0; i < value_data->value.list_value.count; i++)\n            {\n                amqpvalue_destroy(value_data->value.list_value.items[i]);\n            }\n\n            free(value_data->value.list_value.items);\n            value_data->value.list_value.items = NULL;\n        }\n        break;\n    }\n    case AMQP_TYPE_MAP:\n    {\n        if (value_data->value.map_value.pairs != NULL)\n        {\n            size_t i;\n            for (i = 0; i < value_data->value.map_value.pair_count; i++)\n            {\n                amqpvalue_destroy(value_data->value.map_value.pairs[i].key);\n                amqpvalue_destroy(value_data->value.map_value.pairs[i].value);\n            }\n\n            free(value_data->value.map_value.pairs);\n            value_data->value.map_value.pairs = NULL;\n        }\n        break;\n    }\n    case AMQP_TYPE_ARRAY:\n    {\n        if (value_data->value.array_value.items != NULL)\n        {\n            size_t i;\n            for (i = 0; i < value_data->value.array_value.count; i++)\n            {\n                amqpvalue_destroy(value_data->value.array_value.items[i]);\n            }\n\n            free(value_data->value.array_value.items);\n            value_data->value.array_value.items = NULL;\n        }\n        break;\n    }\n    case AMQP_TYPE_COMPOSITE:\n    case AMQP_TYPE_DESCRIBED:\n        amqpvalue_destroy(value_data->value.described_value.descriptor);\n        amqpvalue_destroy(value_data->value.described_value.value);\n        break;\n    }\n\n    value_data->type = AMQP_TYPE_UNKNOWN;\n}\n\nvoid amqpvalue_destroy(AMQP_VALUE value)\n{\n    /* Codes_SRS_AMQPVALUE_01_315: [If the value argument is NULL, amqpvalue_destroy shall do nothing.] */\n    if (value != NULL)\n    {\n        if (DEC_REF(AMQP_VALUE_DATA, value) == DEC_RETURN_ZERO)\n        {\n            /* Codes_SRS_AMQPVALUE_01_314: [amqpvalue_destroy shall free all resources allocated by any of the amqpvalue_create_xxx functions or amqpvalue_clone.] */\n            AMQP_VALUE_DATA* value_data = (AMQP_VALUE_DATA*)value;\n            amqpvalue_clear(value_data);\n            REFCOUNT_TYPE_DESTROY(AMQP_VALUE_DATA, value);\n        }\n    }\n}\n\nstatic INTERNAL_DECODER_DATA* internal_decoder_create(ON_VALUE_DECODED on_value_decoded, void* callback_context, AMQP_VALUE_DATA* value_data, bool is_internal)\n{\n    INTERNAL_DECODER_DATA* internal_decoder_data = (INTERNAL_DECODER_DATA*)calloc(1, sizeof(INTERNAL_DECODER_DATA));\n    if (internal_decoder_data == NULL)\n    {\n        LogError(\"Cannot allocate memory for internal decoder structure\");\n    }\n    else\n    {\n        internal_decoder_data->is_internal = is_internal;\n        internal_decoder_data->on_value_decoded = on_value_decoded;\n        internal_decoder_data->on_value_decoded_context = callback_context;\n        internal_decoder_data->decoder_state = DECODER_STATE_CONSTRUCTOR;\n        internal_decoder_data->inner_decoder = NULL;\n        internal_decoder_data->decode_to_value = value_data;\n    }\n\n    return internal_decoder_data;\n}\n\nstatic void internal_decoder_destroy(INTERNAL_DECODER_DATA* internal_decoder)\n{\n    if (internal_decoder != NULL)\n    {\n        internal_decoder_destroy(internal_decoder->inner_decoder);\n        free(internal_decoder);\n    }\n}\n\nstatic void inner_decoder_callback(void* context, AMQP_VALUE decoded_value)\n{\n    /* API issue: the decoded_value should be removed completely:\n    TODO: uAMQP: inner_decoder_callback in amqpvalue.c could probably do without the decoded_value ... */\n    INTERNAL_DECODER_DATA* internal_decoder_data = (INTERNAL_DECODER_DATA*)context;\n    INTERNAL_DECODER_DATA* inner_decoder = (INTERNAL_DECODER_DATA*)internal_decoder_data->inner_decoder;\n    (void)decoded_value;\n    inner_decoder->decoder_state = DECODER_STATE_DONE;\n}\n\nstatic int internal_decoder_decode_bytes(INTERNAL_DECODER_DATA* internal_decoder_data, const unsigned char* buffer, size_t size, size_t* used_bytes)\n{\n    int result;\n    size_t initial_size = size;\n\n    if (internal_decoder_data == NULL)\n    {\n        /* TODO: investigate if this check is even needed */\n        LogError(\"NULL internal_decoder_data\");\n        result = MU_FAILURE;\n    }\n    else\n    {\n        result = 0;\n        /* Codes_SRS_AMQPVALUE_01_322: [amqpvalue_decode_bytes shall process the bytes byte by byte, as a stream.] */\n        while ((size > 0) && (internal_decoder_data->decoder_state != DECODER_STATE_DONE))\n        {\n            switch (internal_decoder_data->decoder_state)\n            {\n            default:\n                LogError(\"Invalid decoder state: %d\", (int)internal_decoder_data->decoder_state);\n                result = MU_FAILURE;\n                break;\n\n            case DECODER_STATE_CONSTRUCTOR:\n            {\n                if ((internal_decoder_data->decode_to_value != NULL) && (!internal_decoder_data->is_internal))\n                {\n                    amqpvalue_destroy(internal_decoder_data->decode_to_value);\n                    internal_decoder_data->decode_to_value = NULL;\n                }\n\n                if (internal_decoder_data->decode_to_value == NULL)\n                {\n                    internal_decoder_data->decode_to_value = (AMQP_VALUE_DATA*)REFCOUNT_TYPE_CREATE(AMQP_VALUE_DATA);\n                }\n\n                if (internal_decoder_data->decode_to_value == NULL)\n                {\n                    LogError(\"Cannot allocate decode value\");\n                    result = MU_FAILURE;\n                    break;\n                }\n\n                memset(internal_decoder_data->decode_to_value, 0, sizeof(AMQP_VALUE_DATA));\n                internal_decoder_data->constructor_byte = buffer[0];\n                buffer++;\n                size--;\n\n                switch (internal_decoder_data->constructor_byte)\n                {\n                default:\n                    internal_decoder_data->decoder_state = DECODER_STATE_ERROR;\n                    LogError(\"Invalid constructor byte: 0x%02x\", internal_decoder_data->constructor_byte);\n                    result = MU_FAILURE;\n                    break;\n\n                case 0x00: /* descriptor */\n                {\n                    AMQP_VALUE_DATA* descriptor;\n                    internal_decoder_data->decode_to_value->type = AMQP_TYPE_DESCRIBED;\n                    internal_decoder_data->decode_to_value->value.described_value.value = NULL;\n                    descriptor = REFCOUNT_TYPE_CREATE(AMQP_VALUE_DATA);\n                    if (descriptor == NULL)\n                    {\n                        internal_decoder_data->decoder_state = DECODER_STATE_ERROR;\n                        LogError(\"Could not allocate memory for descriptor\");\n                        result = MU_FAILURE;\n                    }\n                    else\n                    {\n                        descriptor->type = AMQP_TYPE_UNKNOWN;\n                        internal_decoder_data->decode_to_value->value.described_value.descriptor = descriptor;\n                        internal_decoder_data->inner_decoder = internal_decoder_create(inner_decoder_callback, internal_decoder_data, descriptor, true);\n                        if (internal_decoder_data->inner_decoder == NULL)\n                        {\n                            internal_decoder_data->decoder_state = DECODER_STATE_ERROR;\n                            LogError(\"Could not create inner decoder for descriptor\");\n                            result = MU_FAILURE;\n                        }\n                        else\n                        {\n                            internal_decoder_data->decoder_state = DECODER_STATE_TYPE_DATA;\n                            internal_decoder_data->decode_value_state.described_value_state.described_value_state = DECODE_DESCRIBED_VALUE_STEP_DESCRIPTOR;\n                            result = 0;\n                        }\n                    }\n\n                    break;\n                }\n\n                /* Codes_SRS_AMQPVALUE_01_329: [<encoding code=\"0x40\" category=\"fixed\" width=\"0\" label=\"the null value\"/>] */\n                case 0x40:\n                {\n                    /* Codes_SRS_AMQPVALUE_01_328: [1.6.1 null Indicates an empty value.] */\n                    internal_decoder_data->decode_to_value->type = AMQP_TYPE_NULL;\n                    internal_decoder_data->decoder_state = DECODER_STATE_CONSTRUCTOR;\n\n                    /* Codes_SRS_AMQPVALUE_01_323: [When enough bytes have been processed for a valid amqp value, the on_value_decoded passed in amqpvalue_decoder_create shall be called.] */\n                    /* Codes_SRS_AMQPVALUE_01_324: [The decoded amqp value shall be passed to on_value_decoded.] */\n                    /* Codes_SRS_AMQPVALUE_01_325: [Also the context stored in amqpvalue_decoder_create shall be passed to the on_value_decoded callback.] */\n                    internal_decoder_data->on_value_decoded(internal_decoder_data->on_value_decoded_context, internal_decoder_data->decode_to_value);\n                    result = 0;\n\n                    break;\n                }\n\n                /* Codes_SRS_AMQPVALUE_01_331: [<encoding code=\"0x56\" category=\"fixed\" width=\"1\" label=\"boolean with the octet 0x00 being false and octet 0x01 being true\"/>] */\n                case 0x56:\n                {\n                    /* Codes_SRS_AMQPVALUE_01_330: [1.6.2 boolean Represents a true or false value.] */\n                    internal_decoder_data->decode_to_value->type = AMQP_TYPE_BOOL;\n                    internal_decoder_data->decoder_state = DECODER_STATE_TYPE_DATA;\n                    internal_decoder_data->bytes_decoded = 0;\n\n                    /* Codes_SRS_AMQPVALUE_01_327: [If not enough bytes have accumulated to decode a value, the on_value_decoded shall not be called.] */\n                    result = 0;\n                    break;\n                }\n                /* Codes_SRS_AMQPVALUE_01_332: [<encoding name=\"true\" code=\"0x41\" category=\"fixed\" width=\"0\" label=\"the boolean value true\"/>] */\n                case 0x41:\n                {\n                    /* Codes_SRS_AMQPVALUE_01_330: [1.6.2 boolean Represents a true or false value.] */\n                    internal_decoder_data->decode_to_value->type = AMQP_TYPE_BOOL;\n                    internal_decoder_data->decode_to_value->value.bool_value = true;\n                    internal_decoder_data->decoder_state = DECODER_STATE_CONSTRUCTOR;\n\n                    /* Codes_SRS_AMQPVALUE_01_323: [When enough bytes have been processed for a valid amqp value, the on_value_decoded passed in amqpvalue_decoder_create shall be called.] */\n                    /* Codes_SRS_AMQPVALUE_01_324: [The decoded amqp value shall be passed to on_value_decoded.] */\n                    /* Codes_SRS_AMQPVALUE_01_325: [Also the context stored in amqpvalue_decoder_create shall be passed to the on_value_decoded callback.] */\n                    internal_decoder_data->on_value_decoded(internal_decoder_data->on_value_decoded_context, internal_decoder_data->decode_to_value);\n                    result = 0;\n                    break;\n                }\n                /* Codes_SRS_AMQPVALUE_01_333: [<encoding name=\"false\" code=\"0x42\" category=\"fixed\" width=\"0\" label=\"the boolean value false\"/>] */\n                case 0x42:\n                {\n                    /* Codes_SRS_AMQPVALUE_01_330: [1.6.2 boolean Represents a true or false value.] */\n                    internal_decoder_data->decode_to_value->type = AMQP_TYPE_BOOL;\n                    internal_decoder_data->decode_to_value->value.bool_value = false;\n                    internal_decoder_data->decoder_state = DECODER_STATE_CONSTRUCTOR;\n\n                    /* Codes_SRS_AMQPVALUE_01_323: [When enough bytes have been processed for a valid amqp value, the on_value_decoded passed in amqpvalue_decoder_create shall be called.] */\n                    /* Codes_SRS_AMQPVALUE_01_324: [The decoded amqp value shall be passed to on_value_decoded.] */\n                    /* Codes_SRS_AMQPVALUE_01_325: [Also the context stored in amqpvalue_decoder_create shall be passed to the on_value_decoded callback.] */\n                    internal_decoder_data->on_value_decoded(internal_decoder_data->on_value_decoded_context, internal_decoder_data->decode_to_value);\n                    result = 0;\n                    break;\n                }\n                /* Codes_SRS_AMQPVALUE_01_335: [<encoding code=\"0x50\" category=\"fixed\" width=\"1\" label=\"8-bit unsigned integer\"/>] */\n                case 0x50:\n                {\n                    /* Codes_SRS_AMQPVALUE_01_334: [1.6.3 ubyte Integer in the range 0 to 28 - 1 inclusive.] */\n                    internal_decoder_data->decode_to_value->type = AMQP_TYPE_UBYTE;\n                    internal_decoder_data->decoder_state = DECODER_STATE_TYPE_DATA;\n                    internal_decoder_data->decode_to_value->value.ubyte_value = 0;\n\n                    /* Codes_SRS_AMQPVALUE_01_327: [If not enough bytes have accumulated to decode a value, the on_value_decoded shall not be called.] */\n                    result = 0;\n                    break;\n                }\n                /* Codes_SRS_AMQPVALUE_01_337: [<encoding code=\"0x60\" category=\"fixed\" width=\"2\" label=\"16-bit unsigned integer in network byte order\"/>] */\n                case 0x60:\n                {\n                    /* Codes_SRS_AMQPVALUE_01_336: [1.6.4 ushort Integer in the range 0 to 216 - 1 inclusive.] */\n                    internal_decoder_data->decode_to_value->type = AMQP_TYPE_USHORT;\n                    internal_decoder_data->decoder_state = DECODER_STATE_TYPE_DATA;\n                    internal_decoder_data->decode_to_value->value.ushort_value = 0;\n                    internal_decoder_data->bytes_decoded = 0;\n\n                    /* Codes_SRS_AMQPVALUE_01_327: [If not enough bytes have accumulated to decode a value, the on_value_decoded shall not be called.] */\n                    result = 0;\n                    break;\n                }\n                /* Codes_SRS_AMQPVALUE_01_339: [<encoding code=\"0x70\" category=\"fixed\" width=\"4\" label=\"32-bit unsigned integer in network byte order\"/>] */\n                case 0x70:\n                /* Codes_SRS_AMQPVALUE_01_340: [<encoding name=\"smalluint\" code=\"0x52\" category=\"fixed\" width=\"1\" label=\"unsigned integer value in the range 0 to 255 inclusive\"/>] */\n                case 0x52:\n                {\n                    internal_decoder_data->decode_to_value->type = AMQP_TYPE_UINT;\n                    internal_decoder_data->decoder_state = DECODER_STATE_TYPE_DATA;\n                    internal_decoder_data->decode_to_value->value.uint_value = 0;\n                    internal_decoder_data->bytes_decoded = 0;\n\n                    /* Codes_SRS_AMQPVALUE_01_327: [If not enough bytes have accumulated to decode a value, the on_value_decoded shall not be called.] */\n                    result = 0;\n                    break;\n                }\n                /* Codes_SRS_AMQPVALUE_01_341: [<encoding name=\"uint0\" code=\"0x43\" category=\"fixed\" width=\"0\" label=\"the uint value 0\"/>] */\n                case 0x43:\n                {\n                    /* Codes_SRS_AMQPVALUE_01_338: [1.6.5 uint Integer in the range 0 to 232 - 1 inclusive.] */\n                    internal_decoder_data->decode_to_value->type = AMQP_TYPE_UINT;\n                    internal_decoder_data->decode_to_value->value.uint_value = 0;\n                    internal_decoder_data->decoder_state = DECODER_STATE_CONSTRUCTOR;\n\n                    /* Codes_SRS_AMQPVALUE_01_323: [When enough bytes have been processed for a valid amqp value, the on_value_decoded passed in amqpvalue_decoder_create shall be called.] */\n                    /* Codes_SRS_AMQPVALUE_01_324: [The decoded amqp value shall be passed to on_value_decoded.] */\n                    /* Codes_SRS_AMQPVALUE_01_325: [Also the context stored in amqpvalue_decoder_create shall be passed to the on_value_decoded callback.] */\n                    internal_decoder_data->on_value_decoded(internal_decoder_data->on_value_decoded_context, internal_decoder_data->decode_to_value);\n                    result = 0;\n                    break;\n                }\n                /* Codes_SRS_AMQPVALUE_01_343: [<encoding code=\"0x80\" category=\"fixed\" width=\"8\" label=\"64-bit unsigned integer in network byte order\"/>] */\n                case 0x80:\n                {\n                    /* Codes_SRS_AMQPVALUE_01_342: [1.6.6 ulong Integer in the range 0 to 264 - 1 inclusive.] */\n                    internal_decoder_data->decode_to_value->type = AMQP_TYPE_ULONG;\n                    internal_decoder_data->decoder_state = DECODER_STATE_TYPE_DATA;\n                    internal_decoder_data->decode_to_value->value.ulong_value = 0;\n\n                    /* Codes_SRS_AMQPVALUE_01_327: [If not enough bytes have accumulated to decode a value, the on_value_decoded shall not be called.] */\n                    internal_decoder_data->bytes_decoded = 0;\n                    result = 0;\n                    break;\n                }\n                /* Codes_SRS_AMQPVALUE_01_344: [<encoding name=\"smallulong\" code=\"0x53\" category=\"fixed\" width=\"1\" label=\"unsigned long value in the range 0 to 255 inclusive\"/>] */\n                case 0x53:\n                {\n                    internal_decoder_data->decode_to_value->type = AMQP_TYPE_ULONG;\n                    internal_decoder_data->decoder_state = DECODER_STATE_TYPE_DATA;\n                    internal_decoder_data->decode_to_value->value.ulong_value = 0;\n\n                    /* Codes_SRS_AMQPVALUE_01_327: [If not enough bytes have accumulated to decode a value, the on_value_decoded shall not be called.] */\n                    internal_decoder_data->bytes_decoded = 0;\n                    result = 0;\n                    break;\n                }\n                /* Codes_SRS_AMQPVALUE_01_345: [<encoding name=\"ulong0\" code=\"0x44\" category=\"fixed\" width=\"0\" label=\"the ulong value 0\"/>] */\n                case 0x44:\n                {\n                    /* Codes_SRS_AMQPVALUE_01_342: [1.6.6 ulong Integer in the range 0 to 264 - 1 inclusive.] */\n                    internal_decoder_data->decode_to_value->type = AMQP_TYPE_ULONG;\n                    internal_decoder_data->decode_to_value->value.ulong_value = 0;\n                    internal_decoder_data->decoder_state = DECODER_STATE_CONSTRUCTOR;\n\n                    /* Codes_SRS_AMQPVALUE_01_323: [When enough bytes have been processed for a valid amqp value, the on_value_decoded passed in amqpvalue_decoder_create shall be called.] */\n                    /* Codes_SRS_AMQPVALUE_01_324: [The decoded amqp value shall be passed to on_value_decoded.] */\n                    /* Codes_SRS_AMQPVALUE_01_325: [Also the context stored in amqpvalue_decoder_create shall be passed to the on_value_decoded callback.] */\n                    internal_decoder_data->on_value_decoded(internal_decoder_data->on_value_decoded_context, internal_decoder_data->decode_to_value);\n                    result = 0;\n                    break;\n                }\n                /* Codes_SRS_AMQPVALUE_01_347: [<encoding code=\"0x51\" category=\"fixed\" width=\"1\" label=\"8-bit two's-complement integer\"/>] */\n                case 0x51:\n                {\n                    /* Codes_SRS_AMQPVALUE_01_346: [1.6.7 byte Integer in the range -(27) to 27 - 1 inclusive.] */\n                    internal_decoder_data->decode_to_value->type = AMQP_TYPE_BYTE;\n                    internal_decoder_data->decoder_state = DECODER_STATE_TYPE_DATA;\n                    internal_decoder_data->decode_to_value->value.byte_value = 0;\n                    internal_decoder_data->bytes_decoded = 0;\n\n                    /* Codes_SRS_AMQPVALUE_01_327: [If not enough bytes have accumulated to decode a value, the on_value_decoded shall not be called.] */\n                    result = 0;\n                    break;\n                }\n                /* Codes_SRS_AMQPVALUE_01_349: [<encoding code=\"0x61\" category=\"fixed\" width=\"2\" label=\"16-bit two's-complement integer in network byte order\"/>] */\n                case 0x61:\n                {\n                    /* Codes_SRS_AMQPVALUE_01_348: [1.6.8 short Integer in the range -(215) to 215 - 1 inclusive.] */\n                    internal_decoder_data->decode_to_value->type = AMQP_TYPE_SHORT;\n                    internal_decoder_data->decoder_state = DECODER_STATE_TYPE_DATA;\n                    internal_decoder_data->decode_to_value->value.short_value = 0;\n                    internal_decoder_data->bytes_decoded = 0;\n\n                    /* Codes_SRS_AMQPVALUE_01_327: [If not enough bytes have accumulated to decode a value, the on_value_decoded shall not be called.] */\n                    result = 0;\n                    break;\n                }\n                /* Codes_SRS_AMQPVALUE_01_351: [<encoding code=\"0x71\" category=\"fixed\" width=\"4\" label=\"32-bit two's-complement integer in network byte order\"/>] */\n                case 0x71:\n                {\n                    /* Codes_SRS_AMQPVALUE_01_350: [1.6.9 int Integer in the range -(231) to 231 - 1 inclusive.] */\n                    internal_decoder_data->decode_to_value->type = AMQP_TYPE_INT;\n                    internal_decoder_data->decoder_state = DECODER_STATE_TYPE_DATA;\n                    internal_decoder_data->decode_to_value->value.int_value = 0;\n                    internal_decoder_data->bytes_decoded = 0;\n\n                    /* Codes_SRS_AMQPVALUE_01_327: [If not enough bytes have accumulated to decode a value, the on_value_decoded shall not be called.] */\n                    result = 0;\n                    break;\n                }\n                /* Codes_SRS_AMQPVALUE_01_352: [<encoding name=\"smallint\" code=\"0x54\" category=\"fixed\" width=\"1\" label=\"8-bit two's-complement integer\"/>] */\n                case 0x54:\n                {\n                    /* Codes_SRS_AMQPVALUE_01_350: [1.6.9 int Integer in the range -(231) to 231 - 1 inclusive.] */\n                    internal_decoder_data->decode_to_value->type = AMQP_TYPE_INT;\n                    internal_decoder_data->decoder_state = DECODER_STATE_TYPE_DATA;\n                    internal_decoder_data->decode_to_value->value.int_value = 0;\n\n                    /* Codes_SRS_AMQPVALUE_01_327: [If not enough bytes have accumulated to decode a value, the on_value_decoded shall not be called.] */\n                    result = 0;\n                    break;\n                }\n                /* Codes_SRS_AMQPVALUE_01_354: [<encoding code=\"0x81\" category=\"fixed\" width=\"8\" label=\"64-bit two's-complement integer in network byte order\"/>] */\n                case 0x81:\n                {\n                    /* Codes_SRS_AMQPVALUE_01_353: [1.6.10 long Integer in the range -(263) to 263 - 1 inclusive.] */\n                    internal_decoder_data->decode_to_value->type = AMQP_TYPE_LONG;\n                    internal_decoder_data->decoder_state = DECODER_STATE_TYPE_DATA;\n                    internal_decoder_data->decode_to_value->value.long_value = 0;\n                    internal_decoder_data->bytes_decoded = 0;\n\n                    /* Codes_SRS_AMQPVALUE_01_327: [If not enough bytes have accumulated to decode a value, the on_value_decoded shall not be called.] */\n                    result = 0;\n                    break;\n                }\n                /* Codes_SRS_AMQPVALUE_01_355: [<encoding name=\"smalllong\" code=\"0x55\" category=\"fixed\" width=\"1\" label=\"8-bit two's-complement integer\"/>] */\n                case 0x55:\n                {\n                    /* Codes_SRS_AMQPVALUE_01_353: [1.6.10 long Integer in the range -(263) to 263 - 1 inclusive.] */\n                    internal_decoder_data->decode_to_value->type = AMQP_TYPE_LONG;\n                    internal_decoder_data->decoder_state = DECODER_STATE_TYPE_DATA;\n                    internal_decoder_data->decode_to_value->value.long_value = 0;\n\n                    /* Codes_SRS_AMQPVALUE_01_327: [If not enough bytes have accumulated to decode a value, the on_value_decoded shall not be called.] */\n                    result = 0;\n                    break;\n                }\n                /* Codes_SRS_AMQPVALUE_01_289: [\\<encoding name=\"ieee-754\" code=\"0x72\" category=\"fixed\" width=\"4\" label=\"IEEE 754-2008 binary32\"/>] */\n                case 0x72:\n                {\n                    /* Codes_SRS_AMQPVALUE_01_019: [1.6.11 float 32-bit floating point number (IEEE 754-2008 binary32).] */\n                    internal_decoder_data->decode_to_value->type = AMQP_TYPE_FLOAT;\n                    internal_decoder_data->decoder_state = DECODER_STATE_TYPE_DATA;\n                    internal_decoder_data->bytes_decoded = 0;\n                    *((uint32_t*)&internal_decoder_data->decode_to_value->value.float_value) = 0;\n\n                    /* Codes_SRS_AMQPVALUE_01_327: [If not enough bytes have accumulated to decode a value, the on_value_decoded shall not be called.] */\n                    result = 0;\n                    break;\n                }\n                /* Codes_SRS_AMQPVALUE_01_290: [\\<encoding name=\"ieee-754\" code=\"0x82\" category=\"fixed\" width=\"8\" label=\"IEEE 754-2008 binary64\"/>] */\n                case 0x82:\n                {\n                    /* Codes_SRS_AMQPVALUE_01_020: [1.6.12 double 64-bit floating point number (IEEE 754-2008 binary64).] */\n                    internal_decoder_data->decode_to_value->type = AMQP_TYPE_DOUBLE;\n                    internal_decoder_data->decoder_state = DECODER_STATE_TYPE_DATA;\n                    internal_decoder_data->bytes_decoded = 0;\n                    *((uint64_t*)&internal_decoder_data->decode_to_value->value.double_value) = 0;\n\n                    /* Codes_SRS_AMQPVALUE_01_327: [If not enough bytes have accumulated to decode a value, the on_value_decoded shall not be called.] */\n                    result = 0;\n                    break;\n                }\n                /* Codes_SRS_AMQPVALUE_01_369: [<encoding name=\"ms64\" code=\"0x83\" category=\"fixed\" width=\"8\" label=\"64-bit two's-complement integer representing milliseconds since the unix epoch\"/>] */\n                case 0x83:\n                {\n                    /* Codes_SRS_AMQPVALUE_01_368: [1.6.17 timestamp An absolute point in time.] */\n                    internal_decoder_data->decode_to_value->type = AMQP_TYPE_TIMESTAMP;\n                    internal_decoder_data->decoder_state = DECODER_STATE_TYPE_DATA;\n                    internal_decoder_data->decode_to_value->value.timestamp_value = 0;\n                    internal_decoder_data->bytes_decoded = 0;\n\n                    /* Codes_SRS_AMQPVALUE_01_327: [If not enough bytes have accumulated to decode a value, the on_value_decoded shall not be called.] */\n                    result = 0;\n                    break;\n                }\n                /* Codes_SRS_AMQPVALUE_01_371: [<encoding code=\"0x98\" category=\"fixed\" width=\"16\" label=\"UUID as defined in section 4.1.2 of RFC-4122\"/>] */\n                case 0x98:\n                {\n                    /* Codes_SRS_AMQPVALUE_01_370: [1.6.18 uuid A universally unique identifier as defined by RFC-4122 section 4.1.2 .] */\n                    internal_decoder_data->decode_to_value->type = AMQP_TYPE_UUID;\n                    internal_decoder_data->decoder_state = DECODER_STATE_TYPE_DATA;\n                    internal_decoder_data->decode_to_value->value.timestamp_value = 0;\n                    internal_decoder_data->bytes_decoded = 0;\n\n                    /* Codes_SRS_AMQPVALUE_01_327: [If not enough bytes have accumulated to decode a value, the on_value_decoded shall not be called.] */\n                    result = 0;\n                    break;\n                }\n                /* Codes_SRS_AMQPVALUE_01_373: [<encoding name=\"vbin8\" code=\"0xa0\" category=\"variable\" width=\"1\" label=\"up to 2^8 - 1 octets of binary data\"/>] */\n                case 0xA0:\n                /* Codes_SRS_AMQPVALUE_01_374: [<encoding name=\"vbin32\" code=\"0xb0\" category=\"variable\" width=\"4\" label=\"up to 2^32 - 1 octets of binary data\"/>] */\n                case 0xB0:\n                {\n                    /* Codes_SRS_AMQPVALUE_01_372: [1.6.19 binary A sequence of octets.] */\n                    internal_decoder_data->decode_to_value->type = AMQP_TYPE_BINARY;\n                    internal_decoder_data->decoder_state = DECODER_STATE_TYPE_DATA;\n                    internal_decoder_data->decode_to_value->value.binary_value.length = 0;\n                    internal_decoder_data->decode_to_value->value.binary_value.bytes = NULL;\n                    internal_decoder_data->bytes_decoded = 0;\n\n                    /* Codes_SRS_AMQPVALUE_01_327: [If not enough bytes have accumulated to decode a value, the on_value_decoded shall not be called.] */\n                    result = 0;\n                    break;\n                }\n                /* Codes_SRS_AMQPVALUE_01_376: [<encoding name=\"str8-utf8\" code=\"0xa1\" category=\"variable\" width=\"1\" label=\"up to 2^8 - 1 octets worth of UTF-8 Unicode (with no byte order mark)\"/>] */\n                case 0xA1:\n                /* Codes_SRS_AMQPVALUE_01_377: [<encoding name=\"str32-utf8\" code=\"0xb1\" category=\"variable\" width=\"4\" label=\"up to 2^32 - 1 octets worth of UTF-8 Unicode (with no byte order mark)\"/>] */\n                case 0xB1:\n                {\n                    /* Codes_SRS_AMQPVALUE_01_375: [1.6.20 string A sequence of Unicode characters.] */\n                    internal_decoder_data->decode_to_value->type = AMQP_TYPE_STRING;\n                    internal_decoder_data->decoder_state = DECODER_STATE_TYPE_DATA;\n                    internal_decoder_data->decode_to_value->value.string_value.chars = NULL;\n                    internal_decoder_data->decode_value_state.string_value_state.length = 0;\n                    internal_decoder_data->bytes_decoded = 0;\n\n                    /* Codes_SRS_AMQPVALUE_01_327: [If not enough bytes have accumulated to decode a value, the on_value_decoded shall not be called.] */\n                    result = 0;\n                    break;\n                }\n                /* Codes_SRS_AMQPVALUE_01_379: [<encoding name=\"sym8\" code=\"0xa3\" category=\"variable\" width=\"1\" label=\"up to 2^8 - 1 seven bit ASCII characters representing a symbolic value\"/>] */\n                case 0xA3:\n                /* Codes_SRS_AMQPVALUE_01_380: [<encoding name=\"sym32\" code=\"0xb3\" category=\"variable\" width=\"4\" label=\"up to 2^32 - 1 seven bit ASCII characters representing a symbolic value\"/>] */\n                case 0xB3:\n                {\n                    /* Codes_SRS_AMQPVALUE_01_378: [1.6.21 symbol Symbolic values from a constrained domain.] */\n                    internal_decoder_data->decode_to_value->type = AMQP_TYPE_SYMBOL;\n                    internal_decoder_data->decoder_state = DECODER_STATE_TYPE_DATA;\n                    internal_decoder_data->decode_to_value->value.symbol_value.chars = NULL;\n                    internal_decoder_data->decode_value_state.symbol_value_state.length = 0;\n                    internal_decoder_data->bytes_decoded = 0;\n\n                    /* Codes_SRS_AMQPVALUE_01_327: [If not enough bytes have accumulated to decode a value, the on_value_decoded shall not be called.] */\n                    result = 0;\n                    break;\n                }\n                /* Codes_SRS_AMQPVALUE_01_384: [<encoding name=\"list0\" code=\"0x45\" category=\"fixed\" width=\"0\" label=\"the empty list (i.e. the list with no elements)\"/>] */\n                case 0x45:\n                    /* Codes_SRS_AMQPVALUE_01_383: [1.6.22 list A sequence of polymorphic values.] */\n                    internal_decoder_data->decode_to_value->type = AMQP_TYPE_LIST;\n                    internal_decoder_data->decoder_state = DECODER_STATE_CONSTRUCTOR;\n                    internal_decoder_data->decode_to_value->value.list_value.count = 0;\n                    internal_decoder_data->decode_to_value->value.list_value.items = NULL;\n\n                    /* Codes_SRS_AMQPVALUE_01_323: [When enough bytes have been processed for a valid amqp value, the on_value_decoded passed in amqpvalue_decoder_create shall be called.] */\n                    /* Codes_SRS_AMQPVALUE_01_324: [The decoded amqp value shall be passed to on_value_decoded.] */\n                    /* Codes_SRS_AMQPVALUE_01_325: [Also the context stored in amqpvalue_decoder_create shall be passed to the on_value_decoded callback.] */\n                    internal_decoder_data->on_value_decoded(internal_decoder_data->on_value_decoded_context, internal_decoder_data->decode_to_value);\n                    result = 0;\n                    break;\n\n                /* Codes_SRS_AMQPVALUE_01_385: [<encoding name=\"list8\" code=\"0xc0\" category=\"compound\" width=\"1\" label=\"up to 2^8 - 1 list elements with total size less than 2^8 octets\"/>] */\n                case 0xC0:\n                case 0xD0:\n                    internal_decoder_data->decode_to_value->type = AMQP_TYPE_LIST;\n                    internal_decoder_data->decoder_state = DECODER_STATE_TYPE_DATA;\n                    internal_decoder_data->decode_to_value->value.list_value.count = 0;\n                    internal_decoder_data->decode_to_value->value.list_value.items = NULL;\n                    internal_decoder_data->bytes_decoded = 0;\n                    internal_decoder_data->decode_value_state.list_value_state.list_value_state = DECODE_LIST_STEP_SIZE;\n\n                    /* Codes_SRS_AMQPVALUE_01_327: [If not enough bytes have accumulated to decode a value, the on_value_decoded shall not be called.] */\n                    result = 0;\n                    break;\n\n                case 0xC1:\n                case 0xD1:\n                    internal_decoder_data->decode_to_value->type = AMQP_TYPE_MAP;\n                    internal_decoder_data->decoder_state = DECODER_STATE_TYPE_DATA;\n                    internal_decoder_data->decode_to_value->value.map_value.pair_count = 0;\n                    internal_decoder_data->decode_to_value->value.map_value.pairs = NULL;\n                    internal_decoder_data->bytes_decoded = 0;\n                    internal_decoder_data->decode_value_state.map_value_state.map_value_state = DECODE_MAP_STEP_SIZE;\n\n                    result = 0;\n                    break;\n\n                case 0xE0:\n                case 0xF0:\n                    internal_decoder_data->decode_to_value->type = AMQP_TYPE_ARRAY;\n                    internal_decoder_data->decoder_state = DECODER_STATE_TYPE_DATA;\n                    internal_decoder_data->decode_to_value->value.array_value.count = 0;\n                    internal_decoder_data->decode_to_value->value.array_value.items = NULL;\n                    internal_decoder_data->bytes_decoded = 0;\n                    internal_decoder_data->decode_value_state.array_value_state.array_value_state = DECODE_ARRAY_STEP_SIZE;\n\n                    result = 0;\n                    break;\n                }\n                break;\n            }\n\n            case DECODER_STATE_TYPE_DATA:\n            {\n                switch (internal_decoder_data->constructor_byte)\n                {\n                default:\n                    LogError(\"Invalid constructor byte: 0x%02x\", internal_decoder_data->constructor_byte);\n                    result = MU_FAILURE;\n                    break;\n\n                case 0x00: /* descriptor */\n                {\n                    DECODE_DESCRIBED_VALUE_STEP step = internal_decoder_data->decode_value_state.described_value_state.described_value_state;\n                    switch (step)\n                    {\n                    default:\n                        LogError(\"Invalid described value decode step: %d\", step);\n                        result = MU_FAILURE;\n                        break;\n\n                    case DECODE_DESCRIBED_VALUE_STEP_DESCRIPTOR:\n                    {\n                        size_t inner_used_bytes;\n                        if (internal_decoder_decode_bytes(internal_decoder_data->inner_decoder, buffer, size, &inner_used_bytes) != 0)\n                        {\n                            LogError(\"Decoding bytes for described value failed\");\n                            internal_decoder_data->decode_to_value->type = AMQP_TYPE_UNKNOWN;\n                            result = MU_FAILURE;\n                        }\n                        else\n                        {\n                            INTERNAL_DECODER_DATA* inner_decoder = (INTERNAL_DECODER_DATA*)internal_decoder_data->inner_decoder;\n                            buffer += inner_used_bytes;\n                            size -= inner_used_bytes;\n\n                            if (inner_decoder->decoder_state == DECODER_STATE_DONE)\n                            {\n                                AMQP_VALUE described_value;\n                                internal_decoder_destroy(inner_decoder);\n\n                                described_value = REFCOUNT_TYPE_CREATE(AMQP_VALUE_DATA);\n                                if (described_value == NULL)\n                                {\n                                    internal_decoder_data->decoder_state = DECODER_STATE_ERROR;\n                                    LogError(\"Could not allocate memory for AMQP value\");\n                                    result = MU_FAILURE;\n                                }\n                                else\n                                {\n                                    described_value->type = AMQP_TYPE_UNKNOWN;\n                                    internal_decoder_data->decode_to_value->value.described_value.value = (AMQP_VALUE)described_value;\n                                    internal_decoder_data->inner_decoder = internal_decoder_create(inner_decoder_callback, internal_decoder_data, described_value, true);\n                                    if (internal_decoder_data->inner_decoder == NULL)\n                                    {\n                                        internal_decoder_data->decoder_state = DECODER_STATE_ERROR;\n                                        LogError(\"Could not create inner decoder\");\n                                        result = MU_FAILURE;\n                                    }\n                                    else\n                                    {\n                                        internal_decoder_data->decode_value_state.described_value_state.described_value_state = DECODE_DESCRIBED_VALUE_STEP_VALUE;\n                                        result = 0;\n                                    }\n                                }\n                            }\n                            else\n                            {\n                                result = 0;\n                            }\n                        }\n                        break;\n                    }\n                    case DECODE_DESCRIBED_VALUE_STEP_VALUE:\n                    {\n                        size_t inner_used_bytes;\n                        if (internal_decoder_decode_bytes(internal_decoder_data->inner_decoder, buffer, size, &inner_used_bytes) != 0)\n                        {\n                            LogError(\"Decoding bytes for described value failed\");\n                            result = MU_FAILURE;\n                        }\n                        else\n                        {\n                            INTERNAL_DECODER_DATA* inner_decoder = (INTERNAL_DECODER_DATA*)internal_decoder_data->inner_decoder;\n                            buffer += inner_used_bytes;\n                            size -= inner_used_bytes;\n\n                            if (inner_decoder->decoder_state == DECODER_STATE_DONE)\n                            {\n                                internal_decoder_destroy(inner_decoder);\n                                internal_decoder_data->inner_decoder = NULL;\n\n                                internal_decoder_data->decoder_state = DECODER_STATE_CONSTRUCTOR;\n                                internal_decoder_data->on_value_decoded(internal_decoder_data->on_value_decoded_context, internal_decoder_data->decode_to_value);\n                            }\n\n                            result = 0;\n                        }\n                        break;\n                    }\n                    }\n                    break;\n                }\n                case 0x56:\n                {\n                    /* Codes_SRS_AMQPVALUE_01_331: [<encoding code=\"0x56\" category=\"fixed\" width=\"1\" label=\"boolean with the octet 0x00 being false and octet 0x01 being true\"/>] */\n                    if (buffer[0] >= 2)\n                    {\n                        LogError(\"Bad boolean value: %02X\", buffer[0]);\n                        result = MU_FAILURE;\n                    }\n                    else\n                    {\n                        internal_decoder_data->decode_to_value->value.bool_value = (buffer[0] == 0) ? false : true;\n\n                        buffer++;\n                        size--;\n                        internal_decoder_data->decoder_state = DECODER_STATE_CONSTRUCTOR;\n\n                        /* Codes_SRS_AMQPVALUE_01_323: [When enough bytes have been processed for a valid amqp value, the on_value_decoded passed in amqpvalue_decoder_create shall be called.] */\n                        /* Codes_SRS_AMQPVALUE_01_324: [The decoded amqp value shall be passed to on_value_decoded.] */\n                        /* Codes_SRS_AMQPVALUE_01_325: [Also the context stored in amqpvalue_decoder_create shall be passed to the on_value_decoded callback.] */\n                        internal_decoder_data->on_value_decoded(internal_decoder_data->on_value_decoded_context, internal_decoder_data->decode_to_value);\n                        result = 0;\n                    }\n\n                    break;\n                }\n                /* Codes_SRS_AMQPVALUE_01_335: [<encoding code=\"0x50\" category=\"fixed\" width=\"1\" label=\"8-bit unsigned integer\"/>] */\n                case 0x50:\n                {\n                    internal_decoder_data->decode_to_value->value.ubyte_value = buffer[0];\n                    buffer++;\n                    size--;\n                    internal_decoder_data->decoder_state = DECODER_STATE_CONSTRUCTOR;\n\n                    /* Codes_SRS_AMQPVALUE_01_323: [When enough bytes have been processed for a valid amqp value, the on_value_decoded passed in amqpvalue_decoder_create shall be called.] */\n                    /* Codes_SRS_AMQPVALUE_01_324: [The decoded amqp value shall be passed to on_value_decoded.] */\n                    /* Codes_SRS_AMQPVALUE_01_325: [Also the context stored in amqpvalue_decoder_create shall be passed to the on_value_decoded callback.] */\n                    internal_decoder_data->on_value_decoded(internal_decoder_data->on_value_decoded_context, internal_decoder_data->decode_to_value);\n                    result = 0;\n                    break;\n                }\n                /* Codes_SRS_AMQPVALUE_01_337: [<encoding code=\"0x60\" category=\"fixed\" width=\"2\" label=\"16-bit unsigned integer in network byte order\"/>] */\n                case 0x60:\n                {\n                    internal_decoder_data->decode_to_value->value.ushort_value += ((uint16_t)buffer[0]) << ((1 - internal_decoder_data->bytes_decoded) * 8);\n                    internal_decoder_data->bytes_decoded++;\n                    buffer++;\n                    size--;\n                    if (internal_decoder_data->bytes_decoded == 2)\n                    {\n                        internal_decoder_data->decoder_state = DECODER_STATE_CONSTRUCTOR;\n\n                        /* Codes_SRS_AMQPVALUE_01_323: [When enough bytes have been processed for a valid amqp value, the on_value_decoded passed in amqpvalue_decoder_create shall be called.] */\n                        /* Codes_SRS_AMQPVALUE_01_324: [The decoded amqp value shall be passed to on_value_decoded.] */\n                        /* Codes_SRS_AMQPVALUE_01_325: [Also the context stored in amqpvalue_decoder_create shall be passed to the on_value_decoded callback.] */\n                        internal_decoder_data->on_value_decoded(internal_decoder_data->on_value_decoded_context, internal_decoder_data->decode_to_value);\n                    }\n\n                    result = 0;\n                    break;\n                }\n                /* Codes_SRS_AMQPVALUE_01_339: [<encoding code=\"0x70\" category=\"fixed\" width=\"4\" label=\"32-bit unsigned integer in network byte order\"/>] */\n                case 0x70:\n                {\n                    internal_decoder_data->decode_to_value->value.uint_value += ((uint32_t)buffer[0]) << ((3 - internal_decoder_data->bytes_decoded) * 8);\n                    internal_decoder_data->bytes_decoded++;\n                    buffer++;\n                    size--;\n\n                    /* Codes_SRS_AMQPVALUE_01_327: [If not enough bytes have accumulated to decode a value, the on_value_decoded shall not be called.] */\n                    if (internal_decoder_data->bytes_decoded == 4)\n                    {\n                        internal_decoder_data->decoder_state = DECODER_STATE_CONSTRUCTOR;\n\n                        /* Codes_SRS_AMQPVALUE_01_323: [When enough bytes have been processed for a valid amqp value, the on_value_decoded passed in amqpvalue_decoder_create shall be called.] */\n                        /* Codes_SRS_AMQPVALUE_01_324: [The decoded amqp value shall be passed to on_value_decoded.] */\n                        /* Codes_SRS_AMQPVALUE_01_325: [Also the context stored in amqpvalue_decoder_create shall be passed to the on_value_decoded callback.] */\n                        internal_decoder_data->on_value_decoded(internal_decoder_data->on_value_decoded_context, internal_decoder_data->decode_to_value);\n                    }\n\n                    result = 0;\n                    break;\n                }\n                /* Codes_SRS_AMQPVALUE_01_340: [<encoding name=\"smalluint\" code=\"0x52\" category=\"fixed\" width=\"1\" label=\"unsigned integer value in the range 0 to 255 inclusive\"/>] */\n                case 0x52:\n                {\n                    internal_decoder_data->decode_to_value->value.uint_value = buffer[0];\n                    buffer++;\n                    size--;\n                    internal_decoder_data->decoder_state = DECODER_STATE_CONSTRUCTOR;\n\n                    /* Codes_SRS_AMQPVALUE_01_323: [When enough bytes have been processed for a valid amqp value, the on_value_decoded passed in amqpvalue_decoder_create shall be called.] */\n                    /* Codes_SRS_AMQPVALUE_01_324: [The decoded amqp value shall be passed to on_value_decoded.] */\n                    /* Codes_SRS_AMQPVALUE_01_325: [Also the context stored in amqpvalue_decoder_create shall be passed to the on_value_decoded callback.] */\n                    internal_decoder_data->on_value_decoded(internal_decoder_data->on_value_decoded_context, internal_decoder_data->decode_to_value);\n                    result = 0;\n                    break;\n                }\n                /* Codes_SRS_AMQPVALUE_01_343: [<encoding code=\"0x80\" category=\"fixed\" width=\"8\" label=\"64-bit unsigned integer in network byte order\"/>] */\n                case 0x80:\n                {\n                    internal_decoder_data->decode_to_value->value.ulong_value += ((uint64_t)buffer[0]) << ((7 - internal_decoder_data->bytes_decoded) * 8);\n                    internal_decoder_data->bytes_decoded++;\n                    buffer++;\n                    size--;\n\n                    /* Codes_SRS_AMQPVALUE_01_327: [If not enough bytes have accumulated to decode a value, the on_value_decoded shall not be called.] */\n                    if (internal_decoder_data->bytes_decoded == 8)\n                    {\n                        internal_decoder_data->decoder_state = DECODER_STATE_CONSTRUCTOR;\n\n                        /* Codes_SRS_AMQPVALUE_01_323: [When enough bytes have been processed for a valid amqp value, the on_value_decoded passed in amqpvalue_decoder_create shall be called.] */\n                        /* Codes_SRS_AMQPVALUE_01_324: [The decoded amqp value shall be passed to on_value_decoded.] */\n                        /* Codes_SRS_AMQPVALUE_01_325: [Also the context stored in amqpvalue_decoder_create shall be passed to the on_value_decoded callback.] */\n                        internal_decoder_data->on_value_decoded(internal_decoder_data->on_value_decoded_context, internal_decoder_data->decode_to_value);\n                    }\n\n                    result = 0;\n                    break;\n                }\n                /* Codes_SRS_AMQPVALUE_01_344: [<encoding name=\"smallulong\" code=\"0x53\" category=\"fixed\" width=\"1\" label=\"unsigned long value in the range 0 to 255 inclusive\"/>] */\n                case 0x53:\n                {\n                    internal_decoder_data->decode_to_value->value.ulong_value = buffer[0];\n                    buffer++;\n                    size--;\n                    internal_decoder_data->decoder_state = DECODER_STATE_CONSTRUCTOR;\n\n                    /* Codes_SRS_AMQPVALUE_01_323: [When enough bytes have been processed for a valid amqp value, the on_value_decoded passed in amqpvalue_decoder_create shall be called.] */\n                    /* Codes_SRS_AMQPVALUE_01_324: [The decoded amqp value shall be passed to on_value_decoded.] */\n                    /* Codes_SRS_AMQPVALUE_01_325: [Also the context stored in amqpvalue_decoder_create shall be passed to the on_value_decoded callback.] */\n                    internal_decoder_data->on_value_decoded(internal_decoder_data->on_value_decoded_context, internal_decoder_data->decode_to_value);\n                    result = 0;\n                    break;\n                }\n                /* Codes_SRS_AMQPVALUE_01_347: [<encoding code=\"0x51\" category=\"fixed\" width=\"1\" label=\"8-bit two's-complement integer\"/>] */\n                case 0x51:\n                {\n                    internal_decoder_data->decode_to_value->value.byte_value = buffer[0];\n                    buffer++;\n                    size--;\n                    internal_decoder_data->decoder_state = DECODER_STATE_CONSTRUCTOR;\n\n                    /* Codes_SRS_AMQPVALUE_01_323: [When enough bytes have been processed for a valid amqp value, the on_value_decoded passed in amqpvalue_decoder_create shall be called.] */\n                    /* Codes_SRS_AMQPVALUE_01_324: [The decoded amqp value shall be passed to on_value_decoded.] */\n                    /* Codes_SRS_AMQPVALUE_01_325: [Also the context stored in amqpvalue_decoder_create shall be passed to the on_value_decoded callback.] */\n                    internal_decoder_data->on_value_decoded(internal_decoder_data->on_value_decoded_context, internal_decoder_data->decode_to_value);\n                    result = 0;\n                    break;\n                }\n                /* Codes_SRS_AMQPVALUE_01_349: [<encoding code=\"0x61\" category=\"fixed\" width=\"2\" label=\"16-bit two's-complement integer in network byte order\"/>] */\n                case 0x61:\n                {\n                    internal_decoder_data->decode_to_value->value.short_value = (int16_t)((uint16_t)internal_decoder_data->decode_to_value->value.short_value + (((uint16_t)buffer[0]) << ((1 - internal_decoder_data->bytes_decoded) * 8)));\n                    internal_decoder_data->bytes_decoded++;\n                    buffer++;\n                    size--;\n\n                    /* Codes_SRS_AMQPVALUE_01_327: [If not enough bytes have accumulated to decode a value, the on_value_decoded shall not be called.] */\n                    if (internal_decoder_data->bytes_decoded == 2)\n                    {\n                        internal_decoder_data->decoder_state = DECODER_STATE_CONSTRUCTOR;\n\n                        /* Codes_SRS_AMQPVALUE_01_323: [When enough bytes have been processed for a valid amqp value, the on_value_decoded passed in amqpvalue_decoder_create shall be called.] */\n                        /* Codes_SRS_AMQPVALUE_01_324: [The decoded amqp value shall be passed to on_value_decoded.] */\n                        /* Codes_SRS_AMQPVALUE_01_325: [Also the context stored in amqpvalue_decoder_create shall be passed to the on_value_decoded callback.] */\n                        internal_decoder_data->on_value_decoded(internal_decoder_data->on_value_decoded_context, internal_decoder_data->decode_to_value);\n                    }\n\n                    result = 0;\n                    break;\n                }\n                /* Codes_SRS_AMQPVALUE_01_351: [<encoding code=\"0x71\" category=\"fixed\" width=\"4\" label=\"32-bit two's-complement integer in network byte order\"/>] */\n                case 0x71:\n                {\n                    internal_decoder_data->decode_to_value->value.int_value = (int32_t)((uint32_t)internal_decoder_data->decode_to_value->value.int_value + (((uint32_t)buffer[0]) << ((3 - internal_decoder_data->bytes_decoded) * 8)));\n                    internal_decoder_data->bytes_decoded++;\n                    buffer++;\n                    size--;\n\n                    /* Codes_SRS_AMQPVALUE_01_327: [If not enough bytes have accumulated to decode a value, the on_value_decoded shall not be called.] */\n                    if (internal_decoder_data->bytes_decoded == 4)\n                    {\n                        internal_decoder_data->decoder_state = DECODER_STATE_CONSTRUCTOR;\n\n                        /* Codes_SRS_AMQPVALUE_01_323: [When enough bytes have been processed for a valid amqp value, the on_value_decoded passed in amqpvalue_decoder_create shall be called.] */\n                        /* Codes_SRS_AMQPVALUE_01_324: [The decoded amqp value shall be passed to on_value_decoded.] */\n                        /* Codes_SRS_AMQPVALUE_01_325: [Also the context stored in amqpvalue_decoder_create shall be passed to the on_value_decoded callback.] */\n                        internal_decoder_data->on_value_decoded(internal_decoder_data->on_value_decoded_context, internal_decoder_data->decode_to_value);\n                    }\n\n                    result = 0;\n                    break;\n                }\n                /* Codes_SRS_AMQPVALUE_01_351: [<encoding code=\"0x71\" category=\"fixed\" width=\"4\" label=\"32-bit two's-complement integer in network byte order\"/>] */\n                case 0x54:\n                {\n                    internal_decoder_data->decode_to_value->value.int_value = (int32_t)((int8_t)(buffer[0]));\n                    buffer++;\n                    size--;\n                    internal_decoder_data->decoder_state = DECODER_STATE_CONSTRUCTOR;\n\n                    /* Codes_SRS_AMQPVALUE_01_323: [When enough bytes have been processed for a valid amqp value, the on_value_decoded passed in amqpvalue_decoder_create shall be called.] */\n                    /* Codes_SRS_AMQPVALUE_01_324: [The decoded amqp value shall be passed to on_value_decoded.] */\n                    /* Codes_SRS_AMQPVALUE_01_325: [Also the context stored in amqpvalue_decoder_create shall be passed to the on_value_decoded callback.] */\n                    internal_decoder_data->on_value_decoded(internal_decoder_data->on_value_decoded_context, internal_decoder_data->decode_to_value);\n                    result = 0;\n                    break;\n                }\n                /* Codes_SRS_AMQPVALUE_01_354: [<encoding code=\"0x81\" category=\"fixed\" width=\"8\" label=\"64-bit two's-complement integer in network byte order\"/>] */\n                case 0x81:\n                {\n                    internal_decoder_data->decode_to_value->value.long_value = (int64_t)((uint64_t)internal_decoder_data->decode_to_value->value.long_value + (((uint64_t)buffer[0]) << ((7 - internal_decoder_data->bytes_decoded) * 8)));\n                    internal_decoder_data->bytes_decoded++;\n                    buffer++;\n                    size--;\n\n                    /* Codes_SRS_AMQPVALUE_01_327: [If not enough bytes have accumulated to decode a value, the on_value_decoded shall not be called.] */\n                    if (internal_decoder_data->bytes_decoded == 8)\n                    {\n                        internal_decoder_data->decoder_state = DECODER_STATE_CONSTRUCTOR;\n\n                        /* Codes_SRS_AMQPVALUE_01_323: [When enough bytes have been processed for a valid amqp value, the on_value_decoded passed in amqpvalue_decoder_create shall be called.] */\n                        /* Codes_SRS_AMQPVALUE_01_324: [The decoded amqp value shall be passed to on_value_decoded.] */\n                        /* Codes_SRS_AMQPVALUE_01_325: [Also the context stored in amqpvalue_decoder_create shall be passed to the on_value_decoded callback.] */\n                        internal_decoder_data->on_value_decoded(internal_decoder_data->on_value_decoded_context, internal_decoder_data->decode_to_value);\n                    }\n\n                    result = 0;\n                    break;\n                }\n                /* Codes_SRS_AMQPVALUE_01_355: [<encoding name=\"smalllong\" code=\"0x55\" category=\"fixed\" width=\"1\" label=\"8-bit two's-complement integer\"/>] */\n                case 0x55:\n                {\n                    internal_decoder_data->decode_to_value->value.long_value = (int64_t)((int8_t)buffer[0]);\n                    buffer++;\n                    size--;\n                    internal_decoder_data->decoder_state = DECODER_STATE_CONSTRUCTOR;\n\n                    /* Codes_SRS_AMQPVALUE_01_323: [When enough bytes have been processed for a valid amqp value, the on_value_decoded passed in amqpvalue_decoder_create shall be called.] */\n                    /* Codes_SRS_AMQPVALUE_01_324: [The decoded amqp value shall be passed to on_value_decoded.] */\n                    /* Codes_SRS_AMQPVALUE_01_325: [Also the context stored in amqpvalue_decoder_create shall be passed to the on_value_decoded callback.] */\n                    internal_decoder_data->on_value_decoded(internal_decoder_data->on_value_decoded_context, internal_decoder_data->decode_to_value);\n                    result = 0;\n                    break;\n                }\n                /* Codes_SRS_AMQPVALUE_01_289: [\\<encoding name=\"ieee-754\" code=\"0x72\" category=\"fixed\" width=\"4\" label=\"IEEE 754-2008 binary32\"/>] */\n                case 0x72:\n                {\n                    *((uint32_t*)&internal_decoder_data->decode_to_value->value.float_value) += ((uint32_t)buffer[0]) << ((3 - internal_decoder_data->bytes_decoded) * 8);\n                    internal_decoder_data->bytes_decoded++;\n                    buffer++;\n                    size--;\n\n                    /* Codes_SRS_AMQPVALUE_01_327: [If not enough bytes have accumulated to decode a value, the on_value_decoded shall not be called.] */\n                    if (internal_decoder_data->bytes_decoded == 4)\n                    {\n                        internal_decoder_data->decoder_state = DECODER_STATE_CONSTRUCTOR;\n\n                        /* Codes_SRS_AMQPVALUE_01_323: [When enough bytes have been processed for a valid amqp value, the on_value_decoded passed in amqpvalue_decoder_create shall be called.] */\n                        /* Codes_SRS_AMQPVALUE_01_324: [The decoded amqp value shall be passed to on_value_decoded.] */\n                        /* Codes_SRS_AMQPVALUE_01_325: [Also the context stored in amqpvalue_decoder_create shall be passed to the on_value_decoded callback.] */\n                        internal_decoder_data->on_value_decoded(internal_decoder_data->on_value_decoded_context, internal_decoder_data->decode_to_value);\n                    }\n\n                    result = 0;\n                    break;\n                }\n                /* Codes_SRS_AMQPVALUE_01_290: [\\<encoding name=\"ieee-754\" code=\"0x82\" category=\"fixed\" width=\"8\" label=\"IEEE 754-2008 binary64\"/>]*/\n                case 0x82:\n                {\n                    *((uint64_t*)&internal_decoder_data->decode_to_value->value.double_value) += ((uint64_t)buffer[0]) << ((7 - internal_decoder_data->bytes_decoded) * 8);\n                    internal_decoder_data->bytes_decoded++;\n                    buffer++;\n                    size--;\n\n                    /* Codes_SRS_AMQPVALUE_01_327: [If not enough bytes have accumulated to decode a value, the on_value_decoded shall not be called.] */\n                    if (internal_decoder_data->bytes_decoded == 8)\n                    {\n                        internal_decoder_data->decoder_state = DECODER_STATE_CONSTRUCTOR;\n\n                        /* Codes_SRS_AMQPVALUE_01_323: [When enough bytes have been processed for a valid amqp value, the on_value_decoded passed in amqpvalue_decoder_create shall be called.] */\n                        /* Codes_SRS_AMQPVALUE_01_324: [The decoded amqp value shall be passed to on_value_decoded.] */\n                        /* Codes_SRS_AMQPVALUE_01_325: [Also the context stored in amqpvalue_decoder_create shall be passed to the on_value_decoded callback.] */\n                        internal_decoder_data->on_value_decoded(internal_decoder_data->on_value_decoded_context, internal_decoder_data->decode_to_value);\n                    }\n\n                    result = 0;\n                    break;\n                }\n                /* Codes_SRS_AMQPVALUE_01_369: [<encoding name=\"ms64\" code=\"0x83\" category=\"fixed\" width=\"8\" label=\"64-bit two's-complement integer representing milliseconds since the unix epoch\"/>] */\n                case 0x83:\n                {\n                    internal_decoder_data->decode_to_value->value.timestamp_value = (int64_t)((uint64_t)internal_decoder_data->decode_to_value->value.timestamp_value + (((uint64_t)buffer[0]) << ((7 - internal_decoder_data->bytes_decoded) * 8)));\n                    internal_decoder_data->bytes_decoded++;\n                    buffer++;\n                    size--;\n\n                    /* Codes_SRS_AMQPVALUE_01_327: [If not enough bytes have accumulated to decode a value, the on_value_decoded shall not be called.] */\n                    if (internal_decoder_data->bytes_decoded == 8)\n                    {\n                        internal_decoder_data->decoder_state = DECODER_STATE_CONSTRUCTOR;\n\n                        /* Codes_SRS_AMQPVALUE_01_323: [When enough bytes have been processed for a valid amqp value, the on_value_decoded passed in amqpvalue_decoder_create shall be called.] */\n                        /* Codes_SRS_AMQPVALUE_01_324: [The decoded amqp value shall be passed to on_value_decoded.] */\n                        /* Codes_SRS_AMQPVALUE_01_325: [Also the context stored in amqpvalue_decoder_create shall be passed to the on_value_decoded callback.] */\n                        internal_decoder_data->on_value_decoded(internal_decoder_data->on_value_decoded_context, internal_decoder_data->decode_to_value);\n                    }\n\n                    result = 0;\n                    break;\n                }\n                /* Codes_SRS_AMQPVALUE_01_369: [<encoding name=\"ms64\" code=\"0x83\" category=\"fixed\" width=\"8\" label=\"64-bit two's-complement integer representing milliseconds since the unix epoch\"/>] */\n                case 0x98:\n                {\n                    size_t to_copy = 16 - internal_decoder_data->bytes_decoded;\n                    if (to_copy > size)\n                    {\n                        to_copy = size;\n                    }\n\n                    (void)memcpy(&internal_decoder_data->decode_to_value->value.uuid_value[internal_decoder_data->bytes_decoded], buffer, to_copy);\n                    internal_decoder_data->bytes_decoded += to_copy;\n                    buffer += to_copy;\n                    size -= to_copy;\n\n                    /* Codes_SRS_AMQPVALUE_01_327: [If not enough bytes have accumulated to decode a value, the on_value_decoded shall not be called.] */\n                    if (internal_decoder_data->bytes_decoded == 16)\n                    {\n                        internal_decoder_data->decoder_state = DECODER_STATE_CONSTRUCTOR;\n\n                        /* Codes_SRS_AMQPVALUE_01_323: [When enough bytes have been processed for a valid amqp value, the on_value_decoded passed in amqpvalue_decoder_create shall be called.] */\n                        /* Codes_SRS_AMQPVALUE_01_324: [The decoded amqp value shall be passed to on_value_decoded.] */\n                        /* Codes_SRS_AMQPVALUE_01_325: [Also the context stored in amqpvalue_decoder_create shall be passed to the on_value_decoded callback.] */\n                        internal_decoder_data->on_value_decoded(internal_decoder_data->on_value_decoded_context, internal_decoder_data->decode_to_value);\n                    }\n\n                    result = 0;\n                    break;\n                }\n                /* Codes_SRS_AMQPVALUE_01_373: [<encoding name=\"vbin8\" code=\"0xa0\" category=\"variable\" width=\"1\" label=\"up to 2^8 - 1 octets of binary data\"/>] */\n                case 0xA0:\n                {\n                    if (internal_decoder_data->bytes_decoded == 0)\n                    {\n                        internal_decoder_data->decode_to_value->value.binary_value.length = buffer[0];\n                        internal_decoder_data->bytes_decoded++;\n                        buffer++;\n                        size--;\n\n                        if (internal_decoder_data->decode_to_value->value.binary_value.length == 0)\n                        {\n                            internal_decoder_data->decode_to_value->value.binary_value.bytes = NULL;\n\n                            /* Codes_SRS_AMQPVALUE_01_323: [When enough bytes have been processed for a valid amqp value, the on_value_decoded passed in amqpvalue_decoder_create shall be called.] */\n                            /* Codes_SRS_AMQPVALUE_01_324: [The decoded amqp value shall be passed to on_value_decoded.] */\n                            /* Codes_SRS_AMQPVALUE_01_325: [Also the context stored in amqpvalue_decoder_create shall be passed to the on_value_decoded callback.] */\n                            internal_decoder_data->on_value_decoded(internal_decoder_data->on_value_decoded_context, internal_decoder_data->decode_to_value);\n                            result = 0;\n                        }\n                        else\n                        {\n                            internal_decoder_data->decode_to_value->value.binary_value.bytes = (unsigned char*)malloc(internal_decoder_data->decode_to_value->value.binary_value.length);\n                            if (internal_decoder_data->decode_to_value->value.binary_value.bytes == NULL)\n                            {\n                                /* Codes_SRS_AMQPVALUE_01_326: [If any allocation failure occurs during decoding, amqpvalue_decode_bytes shall fail and return a non-zero value.] */\n                                LogError(\"Cannot allocate memory for decoded binary value\");\n                                internal_decoder_data->decoder_state = DECODER_STATE_ERROR;\n                                result = MU_FAILURE;\n                            }\n                            else\n                            {\n                                result = 0;\n                            }\n                        }\n                    }\n                    else\n                    {\n                        size_t to_copy = internal_decoder_data->decode_to_value->value.binary_value.length - (internal_decoder_data->bytes_decoded - 1);\n                        if (to_copy > size)\n                        {\n                            to_copy = size;\n                        }\n\n                        (void)memcpy((unsigned char*)(internal_decoder_data->decode_to_value->value.binary_value.bytes) + (internal_decoder_data->bytes_decoded - 1), buffer, to_copy);\n\n                        buffer += to_copy;\n                        size -= to_copy;\n                        internal_decoder_data->bytes_decoded += to_copy;\n\n                        if (internal_decoder_data->bytes_decoded == (size_t)internal_decoder_data->decode_to_value->value.binary_value.length + 1)\n                        {\n                            internal_decoder_data->decoder_state = DECODER_STATE_CONSTRUCTOR;\n\n                            /* Codes_SRS_AMQPVALUE_01_323: [When enough bytes have been processed for a valid amqp value, the on_value_decoded passed in amqpvalue_decoder_create shall be called.] */\n                            /* Codes_SRS_AMQPVALUE_01_324: [The decoded amqp value shall be passed to on_value_decoded.] */\n                            /* Codes_SRS_AMQPVALUE_01_325: [Also the context stored in amqpvalue_decoder_create shall be passed to the on_value_decoded callback.] */\n                            internal_decoder_data->on_value_decoded(internal_decoder_data->on_value_decoded_context, internal_decoder_data->decode_to_value);\n                        }\n\n                        result = 0;\n                    }\n\n                    break;\n                }\n                /* Codes_SRS_AMQPVALUE_01_374: [<encoding name=\"vbin32\" code=\"0xb0\" category=\"variable\" width=\"4\" label=\"up to 2^32 - 1 octets of binary data\"/>] */\n                case 0xB0:\n                {\n                    if (internal_decoder_data->bytes_decoded < 4)\n                    {\n                        internal_decoder_data->decode_to_value->value.binary_value.length += buffer[0] << ((3 - internal_decoder_data->bytes_decoded) * 8);\n                        internal_decoder_data->bytes_decoded++;\n                        buffer++;\n                        size--;\n\n                        if (internal_decoder_data->bytes_decoded == 4)\n                        {\n                            if (internal_decoder_data->decode_to_value->value.binary_value.length == 0)\n                            {\n                                internal_decoder_data->decode_to_value->value.binary_value.bytes = NULL;\n\n                                /* Codes_SRS_AMQPVALUE_01_323: [When enough bytes have been processed for a valid amqp value, the on_value_decoded passed in amqpvalue_decoder_create shall be called.] */\n                                /* Codes_SRS_AMQPVALUE_01_324: [The decoded amqp value shall be passed to on_value_decoded.] */\n                                /* Codes_SRS_AMQPVALUE_01_325: [Also the context stored in amqpvalue_decoder_create shall be passed to the on_value_decoded callback.] */\n                                internal_decoder_data->on_value_decoded(internal_decoder_data->on_value_decoded_context, internal_decoder_data->decode_to_value);\n                                result = 0;\n                            }\n                            else\n                            {\n                                size_t malloc_size = (size_t)internal_decoder_data->decode_to_value->value.binary_value.length + 1;\n                                if (malloc_size == 0)\n                                {\n                                    internal_decoder_data->decode_to_value->value.binary_value.bytes = NULL;\n                                    LogError(\"Invalid binary_value size exceeded max allocation\");\n                                }\n                                else\n                                {\n                                    internal_decoder_data->decode_to_value->value.binary_value.bytes = (unsigned char*)malloc(malloc_size);\n                                }\n\n                                if (internal_decoder_data->decode_to_value->value.binary_value.bytes == NULL)\n                                {\n                                    /* Codes_SRS_AMQPVALUE_01_326: [If any allocation failure occurs during decoding, amqpvalue_decode_bytes shall fail and return a non-zero value.] */\n                                    internal_decoder_data->decoder_state = DECODER_STATE_ERROR;\n                                    LogError(\"Cannot allocate memory for decoded binary value\");\n                                    result = MU_FAILURE;\n                                }\n                                else\n                                {\n                                    result = 0;\n                                }\n                            }\n                        }\n                        else\n                        {\n                            result = 0;\n                        }\n                    }\n                    else\n                    {\n                        size_t to_copy = internal_decoder_data->decode_to_value->value.binary_value.length - (internal_decoder_data->bytes_decoded - 4);\n                        if (to_copy > size)\n                        {\n                            to_copy = size;\n                        }\n\n                        (void)memcpy((unsigned char*)(internal_decoder_data->decode_to_value->value.binary_value.bytes) + (internal_decoder_data->bytes_decoded - 4), buffer, to_copy);\n                        buffer += to_copy;\n                        size -= to_copy;\n                        internal_decoder_data->bytes_decoded += to_copy;\n\n                        if (internal_decoder_data->bytes_decoded == (size_t)internal_decoder_data->decode_to_value->value.binary_value.length + 4)\n                        {\n                            internal_decoder_data->decoder_state = DECODER_STATE_CONSTRUCTOR;\n                            internal_decoder_data->on_value_decoded(internal_decoder_data->on_value_decoded_context, internal_decoder_data->decode_to_value);\n                        }\n\n                        result = 0;\n                    }\n\n                    break;\n                }\n                /* Codes_SRS_AMQPVALUE_01_376: [<encoding name=\"str8-utf8\" code=\"0xa1\" category=\"variable\" width=\"1\" label=\"up to 2^8 - 1 octets worth of UTF-8 Unicode (with no byte order mark)\"/>] */\n                case 0xA1:\n                {\n                    if (internal_decoder_data->bytes_decoded == 0)\n                    {\n                        internal_decoder_data->decode_value_state.string_value_state.length = buffer[0];\n                        internal_decoder_data->bytes_decoded++;\n                        buffer++;\n                        size--;\n\n                        internal_decoder_data->decode_to_value->value.string_value.chars = (char*)malloc((size_t)internal_decoder_data->decode_value_state.string_value_state.length + 1);\n                        if (internal_decoder_data->decode_to_value->value.string_value.chars == NULL)\n                        {\n                            /* Codes_SRS_AMQPVALUE_01_326: [If any allocation failure occurs during decoding, amqpvalue_decode_bytes shall fail and return a non-zero value.] */\n                            internal_decoder_data->decoder_state = DECODER_STATE_ERROR;\n                            LogError(\"Could not allocate memory for decoded string value\");\n                            result = MU_FAILURE;\n                        }\n                        else\n                        {\n                            if (internal_decoder_data->decode_value_state.string_value_state.length == 0)\n                            {\n                                internal_decoder_data->decode_to_value->value.string_value.chars[0] = '\\0';\n\n                                /* Codes_SRS_AMQPVALUE_01_323: [When enough bytes have been processed for a valid amqp value, the on_value_decoded passed in amqpvalue_decoder_create shall be called.] */\n                                /* Codes_SRS_AMQPVALUE_01_324: [The decoded amqp value shall be passed to on_value_decoded.] */\n                                /* Codes_SRS_AMQPVALUE_01_325: [Also the context stored in amqpvalue_decoder_create shall be passed to the on_value_decoded callback.] */\n                                internal_decoder_data->on_value_decoded(internal_decoder_data->on_value_decoded_context, internal_decoder_data->decode_to_value);\n                            }\n\n                            result = 0;\n                        }\n                    }\n                    else\n                    {\n                        size_t to_copy = internal_decoder_data->decode_value_state.string_value_state.length - (internal_decoder_data->bytes_decoded - 1);\n                        if (to_copy > size)\n                        {\n                            to_copy = size;\n                        }\n\n                        (void)memcpy(internal_decoder_data->decode_to_value->value.string_value.chars + (internal_decoder_data->bytes_decoded - 1), buffer, to_copy);\n                        buffer += to_copy;\n                        size -= to_copy;\n                        internal_decoder_data->bytes_decoded += to_copy;\n\n                        if (internal_decoder_data->bytes_decoded == (size_t)internal_decoder_data->decode_value_state.string_value_state.length + 1)\n                        {\n                            internal_decoder_data->decode_to_value->value.string_value.chars[internal_decoder_data->decode_value_state.string_value_state.length] = 0;\n                            internal_decoder_data->decoder_state = DECODER_STATE_CONSTRUCTOR;\n\n                            /* Codes_SRS_AMQPVALUE_01_323: [When enough bytes have been processed for a valid amqp value, the on_value_decoded passed in amqpvalue_decoder_create shall be called.] */\n                            /* Codes_SRS_AMQPVALUE_01_324: [The decoded amqp value shall be passed to on_value_decoded.] */\n                            /* Codes_SRS_AMQPVALUE_01_325: [Also the context stored in amqpvalue_decoder_create shall be passed to the on_value_decoded callback.] */\n                            internal_decoder_data->on_value_decoded(internal_decoder_data->on_value_decoded_context, internal_decoder_data->decode_to_value);\n                        }\n\n                        result = 0;\n                    }\n                    break;\n                }\n                /* Codes_SRS_AMQPVALUE_01_377: [<encoding name=\"str32-utf8\" code=\"0xb1\" category=\"variable\" width=\"4\" label=\"up to 2^32 - 1 octets worth of UTF-8 Unicode (with no byte order mark)\"/>] */\n                case 0xB1:\n                {\n                    if (internal_decoder_data->bytes_decoded < 4)\n                    {\n                        internal_decoder_data->decode_value_state.string_value_state.length += buffer[0] << ((3 - internal_decoder_data->bytes_decoded) * 8);\n                        internal_decoder_data->bytes_decoded++;\n                        buffer++;\n                        size--;\n\n                        if (internal_decoder_data->bytes_decoded == 4)\n                        {\n                            internal_decoder_data->decode_to_value->value.string_value.chars = (char*)malloc((size_t)internal_decoder_data->decode_value_state.string_value_state.length + 1);\n                            if (internal_decoder_data->decode_to_value->value.string_value.chars == NULL)\n                            {\n                                /* Codes_SRS_AMQPVALUE_01_326: [If any allocation failure occurs during decoding, amqpvalue_decode_bytes shall fail and return a non-zero value.] */\n                                internal_decoder_data->decoder_state = DECODER_STATE_ERROR;\n                                LogError(\"Could not allocate memory for decoded string value\");\n                                result = MU_FAILURE;\n                            }\n                            else\n                            {\n                                if (internal_decoder_data->decode_value_state.string_value_state.length == 0)\n                                {\n                                    internal_decoder_data->decode_to_value->value.string_value.chars[0] = '\\0';\n\n                                    /* Codes_SRS_AMQPVALUE_01_323: [When enough bytes have been processed for a valid amqp value, the on_value_decoded passed in amqpvalue_decoder_create shall be called.] */\n                                    /* Codes_SRS_AMQPVALUE_01_324: [The decoded amqp value shall be passed to on_value_decoded.] */\n                                    /* Codes_SRS_AMQPVALUE_01_325: [Also the context stored in amqpvalue_decoder_create shall be passed to the on_value_decoded callback.] */\n                                    internal_decoder_data->on_value_decoded(internal_decoder_data->on_value_decoded_context, internal_decoder_data->decode_to_value);\n                                }\n\n                                result = 0;\n                            }\n                        }\n                        else\n                        {\n                            result = 0;\n                        }\n                    }\n                    else\n                    {\n                        size_t to_copy = internal_decoder_data->decode_value_state.string_value_state.length - (internal_decoder_data->bytes_decoded - 4);\n                        if (to_copy > size)\n                        {\n                            to_copy = size;\n                        }\n\n                        (void)memcpy(internal_decoder_data->decode_to_value->value.string_value.chars + (internal_decoder_data->bytes_decoded - 4), buffer, to_copy);\n                        buffer += to_copy;\n                        size -= to_copy;\n                        internal_decoder_data->bytes_decoded += to_copy;\n\n                        if (internal_decoder_data->bytes_decoded == (size_t)internal_decoder_data->decode_value_state.string_value_state.length + 4)\n                        {\n                            internal_decoder_data->decode_to_value->value.string_value.chars[internal_decoder_data->decode_value_state.string_value_state.length] = '\\0';\n                            internal_decoder_data->decoder_state = DECODER_STATE_CONSTRUCTOR;\n\n                            /* Codes_SRS_AMQPVALUE_01_323: [When enough bytes have been processed for a valid amqp value, the on_value_decoded passed in amqpvalue_decoder_create shall be called.] */\n                            /* Codes_SRS_AMQPVALUE_01_324: [The decoded amqp value shall be passed to on_value_decoded.] */\n                            /* Codes_SRS_AMQPVALUE_01_325: [Also the context stored in amqpvalue_decoder_create shall be passed to the on_value_decoded callback.] */\n                            internal_decoder_data->on_value_decoded(internal_decoder_data->on_value_decoded_context, internal_decoder_data->decode_to_value);\n                        }\n\n                        result = 0;\n                    }\n                    break;\n                }\n                /* Codes_SRS_AMQPVALUE_01_379: [<encoding name=\"sym8\" code=\"0xa3\" category=\"variable\" width=\"1\" label=\"up to 2^8 - 1 seven bit ASCII characters representing a symbolic value\"/>] */\n                case 0xA3:\n                {\n                    if (internal_decoder_data->bytes_decoded == 0)\n                    {\n                        internal_decoder_data->decode_value_state.symbol_value_state.length = buffer[0];\n                        internal_decoder_data->bytes_decoded++;\n                        buffer++;\n                        size--;\n\n                        internal_decoder_data->decode_to_value->value.symbol_value.chars = (char*)malloc((size_t)internal_decoder_data->decode_value_state.symbol_value_state.length + 1);\n                        if (internal_decoder_data->decode_to_value->value.symbol_value.chars == NULL)\n                        {\n                            /* Codes_SRS_AMQPVALUE_01_326: [If any allocation failure occurs during decoding, amqpvalue_decode_bytes shall fail and return a non-zero value.] */\n                            internal_decoder_data->decoder_state = DECODER_STATE_ERROR;\n                            LogError(\"Could not allocate memory for decoded symbol value\");\n                            result = MU_FAILURE;\n                        }\n                        else\n                        {\n                            if (internal_decoder_data->decode_value_state.symbol_value_state.length == 0)\n                            {\n                                internal_decoder_data->decode_to_value->value.symbol_value.chars[0] = '\\0';\n\n                                /* Codes_SRS_AMQPVALUE_01_323: [When enough bytes have been processed for a valid amqp value, the on_value_decoded passed in amqpvalue_decoder_create shall be called.] */\n                                /* Codes_SRS_AMQPVALUE_01_324: [The decoded amqp value shall be passed to on_value_decoded.] */\n                                /* Codes_SRS_AMQPVALUE_01_325: [Also the context stored in amqpvalue_decoder_create shall be passed to the on_value_decoded callback.] */\n                                internal_decoder_data->on_value_decoded(internal_decoder_data->on_value_decoded_context, internal_decoder_data->decode_to_value);\n                            }\n\n                            result = 0;\n                        }\n                    }\n                    else\n                    {\n                        size_t to_copy = internal_decoder_data->decode_value_state.symbol_value_state.length - (internal_decoder_data->bytes_decoded - 1);\n                        if (to_copy > size)\n                        {\n                            to_copy = size;\n                        }\n\n                        (void)memcpy(internal_decoder_data->decode_to_value->value.symbol_value.chars + (internal_decoder_data->bytes_decoded - 1), buffer, to_copy);\n                        buffer += to_copy;\n                        size -= to_copy;\n                        internal_decoder_data->bytes_decoded += to_copy;\n\n                        if (internal_decoder_data->bytes_decoded == (size_t)internal_decoder_data->decode_value_state.symbol_value_state.length + 1)\n                        {\n                            internal_decoder_data->decode_to_value->value.symbol_value.chars[internal_decoder_data->decode_value_state.symbol_value_state.length] = 0;\n                            internal_decoder_data->decoder_state = DECODER_STATE_CONSTRUCTOR;\n\n                            /* Codes_SRS_AMQPVALUE_01_323: [When enough bytes have been processed for a valid amqp value, the on_value_decoded passed in amqpvalue_decoder_create shall be called.] */\n                            /* Codes_SRS_AMQPVALUE_01_324: [The decoded amqp value shall be passed to on_value_decoded.] */\n                            /* Codes_SRS_AMQPVALUE_01_325: [Also the context stored in amqpvalue_decoder_create shall be passed to the on_value_decoded callback.] */\n                            internal_decoder_data->on_value_decoded(internal_decoder_data->on_value_decoded_context, internal_decoder_data->decode_to_value);\n                        }\n\n                        result = 0;\n                    }\n                    break;\n                }\n                /* Codes_SRS_AMQPVALUE_01_380: [<encoding name=\"sym32\" code=\"0xb3\" category=\"variable\" width=\"4\" label=\"up to 2^32 - 1 seven bit ASCII characters representing a symbolic value\"/>] */\n                case 0xB3:\n                {\n                    if (internal_decoder_data->bytes_decoded < 4)\n                    {\n                        internal_decoder_data->decode_value_state.symbol_value_state.length += buffer[0] << ((3 - internal_decoder_data->bytes_decoded) * 8);\n                        internal_decoder_data->bytes_decoded++;\n                        buffer++;\n                        size--;\n\n                        if (internal_decoder_data->bytes_decoded == 4)\n                        {\n                            internal_decoder_data->decode_to_value->value.symbol_value.chars = (char*)malloc((size_t)internal_decoder_data->decode_value_state.symbol_value_state.length + 1);\n                            if (internal_decoder_data->decode_to_value->value.symbol_value.chars == NULL)\n                            {\n                                /* Codes_SRS_AMQPVALUE_01_326: [If any allocation failure occurs during decoding, amqpvalue_decode_bytes shall fail and return a non-zero value.] */\n                                internal_decoder_data->decoder_state = DECODER_STATE_ERROR;\n                                LogError(\"Could not allocate memory for decoded symbol value\");\n                                result = MU_FAILURE;\n                            }\n                            else\n                            {\n                                if (internal_decoder_data->decode_value_state.symbol_value_state.length == 0)\n                                {\n                                    internal_decoder_data->decode_to_value->value.symbol_value.chars[0] = '\\0';\n\n                                    /* Codes_SRS_AMQPVALUE_01_323: [When enough bytes have been processed for a valid amqp value, the on_value_decoded passed in amqpvalue_decoder_create shall be called.] */\n                                    /* Codes_SRS_AMQPVALUE_01_324: [The decoded amqp value shall be passed to on_value_decoded.] */\n                                    /* Codes_SRS_AMQPVALUE_01_325: [Also the context stored in amqpvalue_decoder_create shall be passed to the on_value_decoded callback.] */\n                                    internal_decoder_data->on_value_decoded(internal_decoder_data->on_value_decoded_context, internal_decoder_data->decode_to_value);\n                                }\n\n                                result = 0;\n                            }\n                        }\n                        else\n                        {\n                            result = 0;\n                        }\n                    }\n                    else\n                    {\n                        size_t to_copy = internal_decoder_data->decode_value_state.symbol_value_state.length - (internal_decoder_data->bytes_decoded - 4);\n                        if (to_copy > size)\n                        {\n                            to_copy = size;\n                        }\n\n                        (void)memcpy(internal_decoder_data->decode_to_value->value.symbol_value.chars + (internal_decoder_data->bytes_decoded - 4), buffer, to_copy);\n                        buffer += to_copy;\n                        size -= to_copy;\n                        internal_decoder_data->bytes_decoded += to_copy;\n\n                        if (internal_decoder_data->bytes_decoded == (size_t)internal_decoder_data->decode_value_state.symbol_value_state.length + 4)\n                        {\n                            internal_decoder_data->decode_to_value->value.symbol_value.chars[internal_decoder_data->decode_value_state.symbol_value_state.length] = '\\0';\n                            internal_decoder_data->decoder_state = DECODER_STATE_CONSTRUCTOR;\n\n                            /* Codes_SRS_AMQPVALUE_01_323: [When enough bytes have been processed for a valid amqp value, the on_value_decoded passed in amqpvalue_decoder_create shall be called.] */\n                            /* Codes_SRS_AMQPVALUE_01_324: [The decoded amqp value shall be passed to on_value_decoded.] */\n                            /* Codes_SRS_AMQPVALUE_01_325: [Also the context stored in amqpvalue_decoder_create shall be passed to the on_value_decoded callback.] */\n                            internal_decoder_data->on_value_decoded(internal_decoder_data->on_value_decoded_context, internal_decoder_data->decode_to_value);\n                        }\n\n                        result = 0;\n                    }\n                    break;\n                }\n                /* Codes_SRS_AMQPVALUE_01_385: [<encoding name=\"list8\" code=\"0xc0\" category=\"compound\" width=\"1\" label=\"up to 2^8 - 1 list elements with total size less than 2^8 octets\"/>] */\n                case 0xC0:\n                /* Codes_SRS_AMQPVALUE_01_386: [<encoding name=\"list32\" code=\"0xd0\" category=\"compound\" width=\"4\" label=\"up to 2^32 - 1 list elements with total size less than 2^32 octets\"/>] */\n                case 0xD0:\n                {\n                    DECODE_LIST_STEP step = internal_decoder_data->decode_value_state.list_value_state.list_value_state;\n\n                    switch (step)\n                    {\n                    default:\n                        LogError(\"Invalid step in decoding list value: %d\", step);\n                        result = MU_FAILURE;\n                        break;\n\n                    case DECODE_LIST_STEP_SIZE:\n                        internal_decoder_data->bytes_decoded++;\n                        buffer++;\n                        size--;\n\n                        if (internal_decoder_data->constructor_byte == 0xC0)\n                        {\n                            internal_decoder_data->decode_value_state.list_value_state.list_value_state = DECODE_LIST_STEP_COUNT;\n                            internal_decoder_data->bytes_decoded = 0;\n                            internal_decoder_data->decode_to_value->value.list_value.count = 0;\n                            result = 0;\n                        }\n                        else\n                        {\n                            if (internal_decoder_data->bytes_decoded == 4)\n                            {\n                                internal_decoder_data->decode_value_state.list_value_state.list_value_state = DECODE_LIST_STEP_COUNT;\n                                internal_decoder_data->bytes_decoded = 0;\n                                internal_decoder_data->decode_to_value->value.list_value.count = 0;\n                            }\n\n                            result = 0;\n                        }\n\n                        break;\n\n                    case DECODE_LIST_STEP_COUNT:\n                        if (internal_decoder_data->constructor_byte == 0xC0)\n                        {\n                            internal_decoder_data->decode_to_value->value.list_value.count = buffer[0];\n                        }\n                        else\n                        {\n                            internal_decoder_data->decode_to_value->value.list_value.count += buffer[0] << ((3 - internal_decoder_data->bytes_decoded) * 8);\n                        }\n\n                        internal_decoder_data->bytes_decoded++;\n                        buffer++;\n                        size--;\n                        if (internal_decoder_data->decode_to_value->value.list_value.count > MAX_AMQPVALUE_ITEM_COUNT)\n                        {\n                            LogError(\"AMQP list item count exceeded MAX_AMQPVALUE_ITEM_COUNT\");\n                            result = MU_FAILURE;\n                            size = 0;\n                            break;\n                        }\n\n                        if (internal_decoder_data->constructor_byte == 0xC0)\n                        {\n                            if (internal_decoder_data->decode_to_value->value.list_value.count == 0)\n                            {\n                                internal_decoder_data->decoder_state = DECODER_STATE_CONSTRUCTOR;\n\n                                /* Codes_SRS_AMQPVALUE_01_323: [When enough bytes have been processed for a valid amqp value, the on_value_decoded passed in amqpvalue_decoder_create shall be called.] */\n                                /* Codes_SRS_AMQPVALUE_01_324: [The decoded amqp value shall be passed to on_value_decoded.] */\n                                /* Codes_SRS_AMQPVALUE_01_325: [Also the context stored in amqpvalue_decoder_create shall be passed to the on_value_decoded callback.] */\n                                internal_decoder_data->on_value_decoded(internal_decoder_data->on_value_decoded_context, internal_decoder_data->decode_to_value);\n                                result = 0;\n                            }\n                            else\n                            {\n                                uint32_t i;\n                                internal_decoder_data->decode_to_value->value.list_value.items = (AMQP_VALUE*)calloc(1, (sizeof(AMQP_VALUE) * internal_decoder_data->decode_to_value->value.list_value.count));\n                                if (internal_decoder_data->decode_to_value->value.list_value.items == NULL)\n                                {\n                                    LogError(\"Could not allocate memory for decoded list value\");\n                                    result = MU_FAILURE;\n                                }\n                                else\n                                {\n                                    for (i = 0; i < internal_decoder_data->decode_to_value->value.list_value.count; i++)\n                                    {\n                                        internal_decoder_data->decode_to_value->value.list_value.items[i] = NULL;\n                                    }\n\n                                    internal_decoder_data->decode_value_state.list_value_state.list_value_state = DECODE_LIST_STEP_ITEMS;\n                                    internal_decoder_data->bytes_decoded = 0;\n                                    internal_decoder_data->inner_decoder = NULL;\n                                    internal_decoder_data->decode_value_state.list_value_state.item = 0;\n                                    result = 0;\n                                }\n                            }\n                        }\n                        else\n                        {\n                            if (internal_decoder_data->bytes_decoded == 4)\n                            {\n                                if (internal_decoder_data->decode_to_value->value.list_value.count == 0)\n                                {\n                                    internal_decoder_data->decoder_state = DECODER_STATE_CONSTRUCTOR;\n\n                                    /* Codes_SRS_AMQPVALUE_01_323: [When enough bytes have been processed for a valid amqp value, the on_value_decoded passed in amqpvalue_decoder_create shall be called.] */\n                                    /* Codes_SRS_AMQPVALUE_01_324: [The decoded amqp value shall be passed to on_value_decoded.] */\n                                    /* Codes_SRS_AMQPVALUE_01_325: [Also the context stored in amqpvalue_decoder_create shall be passed to the on_value_decoded callback.] */\n                                    internal_decoder_data->on_value_decoded(internal_decoder_data->on_value_decoded_context, internal_decoder_data->decode_to_value);\n                                    result = 0;\n                                }\n                                else\n                                {\n                                    uint32_t i;\n                                    size_t calloc_size = (sizeof(AMQP_VALUE) * internal_decoder_data->decode_to_value->value.list_value.count);\n                                    // bug 8819364: [FuzzAMQP] AddressSanitizer: allocator is out of memory trying to allocate 0x7fff80070 bytes\n                                    if (calloc_size < MAX_AMQPVALUE_MALLOC_SIZE_BYTES)\n                                    {\n                                        internal_decoder_data->decode_to_value->value.list_value.items = (AMQP_VALUE*)calloc(1, calloc_size);\n                                    }\n                                    else\n                                    {\n                                        LogError(\"Large memory allocation exceeded MAX_AMQPVALUE_MALLOC_SIZE_BYTES\");\n                                        internal_decoder_data->decode_to_value->value.list_value.items = NULL;\n                                    }\n\n                                    if (internal_decoder_data->decode_to_value->value.list_value.items == NULL)\n                                    {\n                                        LogError(\"Could not allocate memory for decoded list value\");\n                                        result = MU_FAILURE;\n                                    }\n                                    else\n                                    {\n                                        for (i = 0; i < internal_decoder_data->decode_to_value->value.list_value.count; i++)\n                                        {\n                                            internal_decoder_data->decode_to_value->value.list_value.items[i] = NULL;\n                                        }\n\n                                        internal_decoder_data->decode_value_state.list_value_state.list_value_state = DECODE_LIST_STEP_ITEMS;\n                                        internal_decoder_data->bytes_decoded = 0;\n                                        internal_decoder_data->inner_decoder = NULL;\n                                        internal_decoder_data->decode_value_state.list_value_state.item = 0;\n                                        result = 0;\n                                    }\n                                }\n                            }\n                            else\n                            {\n                                result = 0;\n                            }\n                        }\n                        break;\n\n                    case DECODE_LIST_STEP_ITEMS:\n                    {\n                        size_t inner_used_bytes;\n\n                        if (internal_decoder_data->bytes_decoded == 0)\n                        {\n                            AMQP_VALUE_DATA* list_item = (AMQP_VALUE_DATA*)REFCOUNT_TYPE_CREATE(AMQP_VALUE_DATA);\n                            if (list_item == NULL)\n                            {\n                                internal_decoder_data->decoder_state = DECODER_STATE_ERROR;\n                                result = MU_FAILURE;\n                                break;\n                            }\n                            else\n                            {\n                                list_item->type = AMQP_TYPE_UNKNOWN;\n                                internal_decoder_data->decode_to_value->value.list_value.items[internal_decoder_data->decode_value_state.list_value_state.item] = list_item;\n                                internal_decoder_data->inner_decoder = internal_decoder_create(inner_decoder_callback, internal_decoder_data, list_item, true);\n                                if (internal_decoder_data->inner_decoder == NULL)\n                                {\n                                    LogError(\"Could not create inner decoder for list items\");\n                                    internal_decoder_data->decoder_state = DECODER_STATE_ERROR;\n                                }\n                            }\n                        }\n\n                        if (internal_decoder_data->inner_decoder == NULL)\n                        {\n                            LogError(\"NULL inner decoder. This should not happen under normal circumstances\");\n                            result = MU_FAILURE;\n                        }\n                        else if (internal_decoder_decode_bytes(internal_decoder_data->inner_decoder, buffer, size, &inner_used_bytes) != 0)\n                        {\n                            LogError(\"Decoding list items failed\");\n                            result = MU_FAILURE;\n                        }\n                        else\n                        {\n                            INTERNAL_DECODER_DATA* inner_decoder = (INTERNAL_DECODER_DATA*)internal_decoder_data->inner_decoder;\n                            internal_decoder_data->bytes_decoded += inner_used_bytes;\n                            buffer += inner_used_bytes;\n                            size -= inner_used_bytes;\n\n                            if (inner_decoder->decoder_state == DECODER_STATE_DONE)\n                            {\n                                internal_decoder_destroy(inner_decoder);\n                                internal_decoder_data->inner_decoder = NULL;\n                                internal_decoder_data->bytes_decoded = 0;\n\n                                internal_decoder_data->decode_value_state.list_value_state.item++;\n                                if (internal_decoder_data->decode_value_state.list_value_state.item == internal_decoder_data->decode_to_value->value.list_value.count)\n                                {\n                                    internal_decoder_data->decoder_state = DECODER_STATE_CONSTRUCTOR;\n\n                                    /* Codes_SRS_AMQPVALUE_01_323: [When enough bytes have been processed for a valid amqp value, the on_value_decoded passed in amqpvalue_decoder_create shall be called.] */\n                                    /* Codes_SRS_AMQPVALUE_01_324: [The decoded amqp value shall be passed to on_value_decoded.] */\n                                    /* Codes_SRS_AMQPVALUE_01_325: [Also the context stored in amqpvalue_decoder_create shall be passed to the on_value_decoded callback.] */\n                                    internal_decoder_data->on_value_decoded(internal_decoder_data->on_value_decoded_context, internal_decoder_data->decode_to_value);\n                                }\n\n                            }\n\n                            result = 0;\n                        }\n\n                        break;\n                    }\n                    }\n\n                    break;\n                }\n                case 0xC1:\n                case 0xD1:\n                {\n                    DECODE_MAP_STEP step = internal_decoder_data->decode_value_state.map_value_state.map_value_state;\n\n                    switch (step)\n                    {\n                    default:\n                        LogError(\"Invalid step in decoding map value: %d\", step);\n                        result = MU_FAILURE;\n                        break;\n\n                    case DECODE_MAP_STEP_SIZE:\n                        internal_decoder_data->bytes_decoded++;\n                        buffer++;\n                        size--;\n\n                        if (internal_decoder_data->constructor_byte == 0xC1)\n                        {\n                            internal_decoder_data->decode_value_state.map_value_state.map_value_state = DECODE_MAP_STEP_COUNT;\n                            internal_decoder_data->bytes_decoded = 0;\n                            internal_decoder_data->decode_to_value->value.map_value.pair_count = 0;\n                            result = 0;\n                        }\n                        else\n                        {\n                            if (internal_decoder_data->bytes_decoded == 4)\n                            {\n                                internal_decoder_data->decode_value_state.map_value_state.map_value_state = DECODE_MAP_STEP_COUNT;\n                                internal_decoder_data->bytes_decoded = 0;\n                                internal_decoder_data->decode_to_value->value.map_value.pair_count = 0;\n                            }\n                            result = 0;\n                        }\n\n                        break;\n\n                    case DECODE_MAP_STEP_COUNT:\n                        if (internal_decoder_data->constructor_byte == 0xC1)\n                        {\n                            internal_decoder_data->decode_to_value->value.map_value.pair_count = buffer[0];\n                        }\n                        else\n                        {\n                            internal_decoder_data->decode_to_value->value.map_value.pair_count += buffer[0] << ((3 - internal_decoder_data->bytes_decoded) * 8);\n                        }\n                        internal_decoder_data->bytes_decoded++;\n                        buffer++;\n                        size--;\n\n                        if (internal_decoder_data->constructor_byte == 0xC1)\n                        {\n                            if (internal_decoder_data->decode_to_value->value.map_value.pair_count == 0)\n                            {\n                                internal_decoder_data->decoder_state = DECODER_STATE_CONSTRUCTOR;\n\n                                internal_decoder_data->on_value_decoded(internal_decoder_data->on_value_decoded_context, internal_decoder_data->decode_to_value);\n                                result = 0;\n                            }\n                            else\n                            {\n                                uint32_t i;\n\n                                internal_decoder_data->decode_to_value->value.map_value.pair_count /= 2;\n\n                                internal_decoder_data->decode_to_value->value.map_value.pairs = (AMQP_MAP_KEY_VALUE_PAIR*)malloc(sizeof(AMQP_MAP_KEY_VALUE_PAIR) * ((size_t)internal_decoder_data->decode_to_value->value.map_value.pair_count * 2));\n                                if (internal_decoder_data->decode_to_value->value.map_value.pairs == NULL)\n                                {\n                                    LogError(\"Could not allocate memory for map value items\");\n                                    result = MU_FAILURE;\n                                }\n                                else\n                                {\n                                    for (i = 0; i < internal_decoder_data->decode_to_value->value.map_value.pair_count; i++)\n                                    {\n                                        internal_decoder_data->decode_to_value->value.map_value.pairs[i].key = NULL;\n                                        internal_decoder_data->decode_to_value->value.map_value.pairs[i].value = NULL;\n                                    }\n\n                                    internal_decoder_data->decode_value_state.map_value_state.map_value_state = DECODE_MAP_STEP_PAIRS;\n                                    internal_decoder_data->bytes_decoded = 0;\n                                    internal_decoder_data->inner_decoder = NULL;\n                                    internal_decoder_data->decode_value_state.map_value_state.item = 0;\n                                    result = 0;\n                                }\n                            }\n                        }\n                        else\n                        {\n                            if (internal_decoder_data->bytes_decoded == 4)\n                            {\n                                if (internal_decoder_data->decode_to_value->value.map_value.pair_count == 0)\n                                {\n                                    internal_decoder_data->decoder_state = DECODER_STATE_CONSTRUCTOR;\n\n                                    internal_decoder_data->on_value_decoded(internal_decoder_data->on_value_decoded_context, internal_decoder_data->decode_to_value);\n                                    result = 0;\n                                }\n                                else\n                                {\n                                    uint32_t i;\n\n                                    internal_decoder_data->decode_to_value->value.map_value.pair_count /= 2;\n                                    if (internal_decoder_data->decode_to_value->value.map_value.pair_count > MAX_AMQPVALUE_ITEM_COUNT)\n                                    {\n                                        LogError(\"AMQP list map count exceeded MAX_AMQPVALUE_ITEM_COUNT\");\n                                        result = MU_FAILURE;\n                                    }\n                                    else if ((internal_decoder_data->decode_to_value->value.map_value.pairs = \n                                        (AMQP_MAP_KEY_VALUE_PAIR*)malloc(sizeof(AMQP_MAP_KEY_VALUE_PAIR) * ((size_t)internal_decoder_data->decode_to_value->value.map_value.pair_count * 2)))\n                                        == NULL)\n                                    {\n                                        LogError(\"Could not allocate memory for map value items\");\n                                        result = MU_FAILURE;\n                                    }\n                                    else\n                                    {\n                                        for (i = 0; i < internal_decoder_data->decode_to_value->value.map_value.pair_count; i++)\n                                        {\n                                            internal_decoder_data->decode_to_value->value.map_value.pairs[i].key = NULL;\n                                            internal_decoder_data->decode_to_value->value.map_value.pairs[i].value = NULL;\n                                        }\n\n                                        internal_decoder_data->decode_value_state.map_value_state.map_value_state = DECODE_MAP_STEP_PAIRS;\n                                        internal_decoder_data->bytes_decoded = 0;\n                                        internal_decoder_data->inner_decoder = NULL;\n                                        internal_decoder_data->decode_value_state.map_value_state.item = 0;\n                                        result = 0;\n                                    }\n                                }\n                            }\n                            else\n                            {\n                                result = 0;\n                            }\n                        }\n                        break;\n\n                    case DECODE_MAP_STEP_PAIRS:\n                    {\n                        size_t inner_used_bytes;\n\n                        if (internal_decoder_data->bytes_decoded == 0)\n                        {\n                            if (internal_decoder_data->decode_value_state.map_value_state.item >= internal_decoder_data->decode_to_value->value.map_value.pair_count)\n                            {\n                                LogError(\"Map item index is out of range\");\n                                internal_decoder_data->decoder_state = DECODER_STATE_ERROR;\n                                result = MU_FAILURE;\n                                break;\n                            }\n\n                            AMQP_VALUE_DATA* map_item = (AMQP_VALUE_DATA*)REFCOUNT_TYPE_CREATE(AMQP_VALUE_DATA);\n                            if (map_item == NULL)\n                            {\n                                LogError(\"Could not allocate memory for map item\");\n                                internal_decoder_data->decoder_state = DECODER_STATE_ERROR;\n                                result = MU_FAILURE;\n                                break;\n                            }\n                            else\n                            {\n                                map_item->type = AMQP_TYPE_UNKNOWN;\n                                \n                                if (internal_decoder_data->decode_to_value->value.map_value.pairs[internal_decoder_data->decode_value_state.map_value_state.item].key == NULL)\n                                {\n                                    internal_decoder_data->decode_to_value->value.map_value.pairs[internal_decoder_data->decode_value_state.map_value_state.item].key = map_item;\n                                }\n                                else\n                                {\n                                    internal_decoder_data->decode_to_value->value.map_value.pairs[internal_decoder_data->decode_value_state.map_value_state.item].value = map_item;\n                                }\n                                internal_decoder_data->inner_decoder = internal_decoder_create(inner_decoder_callback, internal_decoder_data, map_item, true);\n                                if (internal_decoder_data->inner_decoder == NULL)\n                                {\n                                    LogError(\"Could not create inner decoder for map item\");\n                                    internal_decoder_data->decoder_state = DECODER_STATE_ERROR;\n                                }\n                                else\n                                {\n                                    result = 0;\n                                }\n                            }\n                        }\n\n                        if (internal_decoder_data->inner_decoder == NULL)\n                        {\n                            LogError(\"NULL inner decoder. This should not happen under normal circumstances\");\n                            result = MU_FAILURE;\n                        }\n                        else if (internal_decoder_decode_bytes(internal_decoder_data->inner_decoder, buffer, size, &inner_used_bytes) != 0)\n                        {\n                            LogError(\"Could not decode map item\");\n                            result = MU_FAILURE;\n                        }\n                        else\n                        {\n                            INTERNAL_DECODER_DATA* inner_decoder = (INTERNAL_DECODER_DATA*)internal_decoder_data->inner_decoder;\n                            internal_decoder_data->bytes_decoded += inner_used_bytes;\n                            buffer += inner_used_bytes;\n                            size -= inner_used_bytes;\n\n                            if (inner_decoder->decoder_state == DECODER_STATE_DONE)\n                            {\n                                internal_decoder_destroy(inner_decoder);\n                                internal_decoder_data->inner_decoder = NULL;\n                                internal_decoder_data->bytes_decoded = 0;\n\n                                if (internal_decoder_data->decode_to_value->value.map_value.pairs[internal_decoder_data->decode_value_state.map_value_state.item].value != NULL)\n                                {\n                                    internal_decoder_data->decode_value_state.map_value_state.item++;\n                                    if (internal_decoder_data->decode_value_state.map_value_state.item == internal_decoder_data->decode_to_value->value.map_value.pair_count)\n                                    {\n                                        internal_decoder_data->decoder_state = DECODER_STATE_CONSTRUCTOR;\n\n                                        internal_decoder_data->on_value_decoded(internal_decoder_data->on_value_decoded_context, internal_decoder_data->decode_to_value);\n                                    }\n                                }\n                            }\n\n                            result = 0;\n                        }\n\n                        break;\n                    }\n                    }\n\n                    break;\n                }\n                case 0xE0:\n                case 0xF0:\n                {\n                    DECODE_ARRAY_STEP step = internal_decoder_data->decode_value_state.array_value_state.array_value_state;\n\n                    switch (step)\n                    {\n                    default:\n                        LogError(\"Invalid step in decoding array value: %d\", step);\n                        result = MU_FAILURE;\n                        break;\n\n                    case DECODE_ARRAY_STEP_SIZE:\n                        internal_decoder_data->bytes_decoded++;\n                        buffer++;\n                        size--;\n\n                        if (internal_decoder_data->constructor_byte == 0xE0)\n                        {\n                            internal_decoder_data->decode_value_state.array_value_state.array_value_state = DECODE_ARRAY_STEP_COUNT;\n                            internal_decoder_data->bytes_decoded = 0;\n                            internal_decoder_data->decode_to_value->value.array_value.count = 0;\n                            result = 0;\n                        }\n                        else\n                        {\n                            if (internal_decoder_data->bytes_decoded == 4)\n                            {\n                                internal_decoder_data->decode_value_state.array_value_state.array_value_state = DECODE_ARRAY_STEP_COUNT;\n                                internal_decoder_data->bytes_decoded = 0;\n                                internal_decoder_data->decode_to_value->value.array_value.count = 0;\n                            }\n                            result = 0;\n                        }\n\n                        break;\n\n                    case DECODE_ARRAY_STEP_COUNT:\n                        if (internal_decoder_data->constructor_byte == 0xE0)\n                        {\n                            internal_decoder_data->decode_to_value->value.array_value.count = buffer[0];\n                        }\n                        else\n                        {\n                            internal_decoder_data->decode_to_value->value.array_value.count += buffer[0] << ((3 - internal_decoder_data->bytes_decoded) * 8);\n                        }\n\n                        internal_decoder_data->bytes_decoded++;\n                        buffer++;\n                        size--;\n                        if (internal_decoder_data->decode_to_value->value.array_value.count > MAX_AMQPVALUE_ITEM_COUNT)\n                        {\n                            LogError(\"AMQP array item count exceeded MAX_AMQPVALUE_ITEM_COUNT\");\n                            result = MU_FAILURE;\n                            size = 0;\n                            break;\n                        }\n\n                        if (internal_decoder_data->constructor_byte == 0xE0)\n                        {\n                            if (internal_decoder_data->decode_to_value->value.array_value.count == 0)\n                            {\n                                internal_decoder_data->decoder_state = DECODER_STATE_CONSTRUCTOR;\n\n                                internal_decoder_data->on_value_decoded(internal_decoder_data->on_value_decoded_context, internal_decoder_data->decode_to_value);\n                                result = 0;\n                            }\n                            else\n                            {\n                                uint32_t i;\n                                internal_decoder_data->decode_to_value->value.array_value.items = (AMQP_VALUE*)calloc(1, (sizeof(AMQP_VALUE) * internal_decoder_data->decode_to_value->value.array_value.count));\n                                if (internal_decoder_data->decode_to_value->value.array_value.items == NULL)\n                                {\n                                    LogError(\"Could not allocate memory for array items\");\n                                    result = MU_FAILURE;\n                                }\n                                else\n                                {\n                                    for (i = 0; i < internal_decoder_data->decode_to_value->value.array_value.count; i++)\n                                    {\n                                        internal_decoder_data->decode_to_value->value.array_value.items[i] = NULL;\n                                    }\n\n                                    internal_decoder_data->decode_value_state.array_value_state.array_value_state = DECODE_ARRAY_STEP_ITEMS;\n                                    internal_decoder_data->bytes_decoded = 0;\n                                    internal_decoder_data->inner_decoder = NULL;\n                                    internal_decoder_data->decode_value_state.array_value_state.item = 0;\n                                    result = 0;\n                                }\n                            }\n                        }\n                        else\n                        {\n                            if (internal_decoder_data->bytes_decoded == 4)\n                            {\n                                if (internal_decoder_data->decode_to_value->value.array_value.count == 0)\n                                {\n                                    internal_decoder_data->decoder_state = DECODER_STATE_CONSTRUCTOR;\n                                    internal_decoder_data->on_value_decoded(internal_decoder_data->on_value_decoded_context, internal_decoder_data->decode_to_value);\n                                    result = 0;\n                                }\n                                else\n                                {\n                                    uint32_t i;\n                                    internal_decoder_data->decode_to_value->value.array_value.items = (AMQP_VALUE*)calloc(1, (sizeof(AMQP_VALUE) * internal_decoder_data->decode_to_value->value.array_value.count));\n                                    if (internal_decoder_data->decode_to_value->value.array_value.items == NULL)\n                                    {\n                                        LogError(\"Could not allocate memory for array items\");\n                                        result = MU_FAILURE;\n                                    }\n                                    else\n                                    {\n                                        for (i = 0; i < internal_decoder_data->decode_to_value->value.array_value.count; i++)\n                                        {\n                                            internal_decoder_data->decode_to_value->value.array_value.items[i] = NULL;\n                                        }\n                                        internal_decoder_data->decode_value_state.array_value_state.array_value_state = DECODE_ARRAY_STEP_ITEMS;\n                                        internal_decoder_data->bytes_decoded = 0;\n                                        internal_decoder_data->inner_decoder = NULL;\n                                        internal_decoder_data->decode_value_state.array_value_state.item = 0;\n                                        result = 0;\n                                    }\n                                }\n                            }\n                            else\n                            {\n                                result = 0;\n                            }\n                        }\n                        break;\n\n                    case DECODE_ARRAY_STEP_ITEMS:\n                    {\n                        size_t inner_used_bytes;\n\n                        if (internal_decoder_data->bytes_decoded == 0)\n                        {\n                            AMQP_VALUE_DATA* array_item;\n                            internal_decoder_data->decode_value_state.array_value_state.constructor_byte = buffer[0];\n\n                            array_item = (AMQP_VALUE_DATA*)REFCOUNT_TYPE_CREATE(AMQP_VALUE_DATA);\n                            if (array_item == NULL)\n                            {\n                                LogError(\"Could not allocate memory for array item to be decoded\");\n                                internal_decoder_data->decoder_state = DECODER_STATE_ERROR;\n                                result = MU_FAILURE;\n                                break;\n                            }\n                            else\n                            {\n                                array_item->type = AMQP_TYPE_UNKNOWN;\n                                internal_decoder_data->decode_to_value->value.array_value.items[internal_decoder_data->decode_value_state.array_value_state.item] = array_item;\n                                internal_decoder_data->inner_decoder = internal_decoder_create(inner_decoder_callback, internal_decoder_data, array_item, true);\n                                if (internal_decoder_data->inner_decoder == NULL)\n                                {\n                                    internal_decoder_data->decoder_state = DECODER_STATE_ERROR;\n                                    LogError(\"Could not create inner decoder for array items\");\n                                }\n                            }\n                        }\n\n                        if (internal_decoder_data->inner_decoder == NULL)\n                        {\n                            LogError(\"NULL inner decoder. This should not happen under normal circumstances\");\n                            result = MU_FAILURE;\n                        }\n                        else if (internal_decoder_decode_bytes(internal_decoder_data->inner_decoder, buffer, size, &inner_used_bytes) != 0)\n                        {\n                            LogError(\"Could not decode array item\");\n                            result = MU_FAILURE;\n                        }\n                        else\n                        {\n                            INTERNAL_DECODER_DATA* inner_decoder = (INTERNAL_DECODER_DATA*)internal_decoder_data->inner_decoder;\n                            internal_decoder_data->bytes_decoded += inner_used_bytes;\n                            size -= inner_used_bytes;\n\n                            if (inner_decoder->decoder_state == DECODER_STATE_DONE)\n                            {\n                                internal_decoder_destroy(inner_decoder);\n                                internal_decoder_data->inner_decoder = NULL;\n\n                                internal_decoder_data->decode_value_state.array_value_state.item++;\n                                if (internal_decoder_data->decode_value_state.array_value_state.item == internal_decoder_data->decode_to_value->value.array_value.count)\n                                {\n                                    buffer += inner_used_bytes;\n                                    internal_decoder_data->decoder_state = DECODER_STATE_CONSTRUCTOR;\n                                    internal_decoder_data->on_value_decoded(internal_decoder_data->on_value_decoded_context, internal_decoder_data->decode_to_value);\n\n                                    result = 0;\n                                }\n                                else\n                                {\n                                    AMQP_VALUE_DATA* array_item;\n\n                                    if ((internal_decoder_data->decode_value_state.array_value_state.constructor_byte == 0x40) ||\n                                        (internal_decoder_data->decode_value_state.array_value_state.constructor_byte == 0x41) ||\n                                        (internal_decoder_data->decode_value_state.array_value_state.constructor_byte == 0x42) ||\n                                        (internal_decoder_data->decode_value_state.array_value_state.constructor_byte == 0x43) ||\n                                        (internal_decoder_data->decode_value_state.array_value_state.constructor_byte == 0x44) ||\n                                        (internal_decoder_data->decode_value_state.array_value_state.constructor_byte == 0x45))\n                                    {\n                                        /* Array items are constructor-only, e.g. NULL Don't increment buffer to account for implied data. */\n                                        size += inner_used_bytes;\n                                        internal_decoder_data->decoder_state = DECODER_STATE_TYPE_DATA;\n                                    }\n                                    else\n                                    {\n                                        buffer += inner_used_bytes;\n                                    }\n\n                                    array_item = (AMQP_VALUE_DATA*)REFCOUNT_TYPE_CREATE(AMQP_VALUE_DATA);\n                                    if (array_item == NULL)\n                                    {\n                                        LogError(\"Could not allocate memory for array item\");\n                                        internal_decoder_data->decoder_state = DECODER_STATE_ERROR;\n                                        result = MU_FAILURE;\n                                    }\n                                    else\n                                    {\n                                        array_item->type = AMQP_TYPE_UNKNOWN;\n                                        internal_decoder_data->decode_to_value->value.array_value.items[internal_decoder_data->decode_value_state.array_value_state.item] = array_item;\n                                        internal_decoder_data->inner_decoder = internal_decoder_create(inner_decoder_callback, internal_decoder_data, array_item, true);\n                                        if (internal_decoder_data->inner_decoder == NULL)\n                                        {\n                                            LogError(\"Could not create inner decoder for array item\");\n                                            internal_decoder_data->decoder_state = DECODER_STATE_ERROR;\n                                            result = MU_FAILURE;\n                                        }\n                                        else\n                                        {\n                                            if (internal_decoder_decode_bytes(internal_decoder_data->inner_decoder, &internal_decoder_data->decode_value_state.array_value_state.constructor_byte, 1, NULL) != 0)\n                                            {\n                                                LogError(\"Could not decode array item data\");\n                                                result = MU_FAILURE;\n                                            }\n                                            else\n                                            {\n                                                result = 0;\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                            else\n                            {\n                                buffer += inner_used_bytes;\n                                result = 0;\n                            }\n                        }\n\n                        break;\n                    }\n                    }\n\n                    break;\n                }\n                }\n                break;\n            }\n            }\n\n            if (result != 0)\n            {\n                break;\n            }\n        }\n    }\n\n    if (used_bytes != NULL)\n    {\n        *used_bytes = initial_size - size;\n    }\n\n    return result;\n}\n\nAMQPVALUE_DECODER_HANDLE amqpvalue_decoder_create(ON_VALUE_DECODED on_value_decoded, void* callback_context)\n{\n    AMQPVALUE_DECODER_HANDLE_DATA* decoder_instance;\n\n    /* Codes_SRS_AMQPVALUE_01_312: [If the on_value_decoded argument is NULL, amqpvalue_decoder_create shall return NULL.] */\n    if (on_value_decoded == NULL)\n    {\n        LogError(\"NULL on_value_decoded\");\n        decoder_instance = NULL;\n    }\n    else\n    {\n        decoder_instance = (AMQPVALUE_DECODER_HANDLE_DATA*)malloc(sizeof(AMQPVALUE_DECODER_HANDLE_DATA));\n        /* Codes_SRS_AMQPVALUE_01_313: [If creating the decoder fails, amqpvalue_decoder_create shall return NULL.] */\n        if (decoder_instance == NULL)\n        {\n            LogError(\"Could not allocate memory for AMQP value decoder\");\n        }\n        else\n        {\n            decoder_instance->decode_to_value = REFCOUNT_TYPE_CREATE(AMQP_VALUE_DATA);\n            if (decoder_instance->decode_to_value == NULL)\n            {\n                /* Codes_SRS_AMQPVALUE_01_313: [If creating the decoder fails, amqpvalue_decoder_create shall return NULL.] */\n                LogError(\"Could not allocate memory for decoded AMQP value\");\n                free(decoder_instance);\n                decoder_instance = NULL;\n            }\n            else\n            {\n                decoder_instance->decode_to_value->type = AMQP_TYPE_UNKNOWN;\n                decoder_instance->internal_decoder = internal_decoder_create(on_value_decoded, callback_context, decoder_instance->decode_to_value, false);\n                if (decoder_instance->internal_decoder == NULL)\n                {\n                    /* Codes_SRS_AMQPVALUE_01_313: [If creating the decoder fails, amqpvalue_decoder_create shall return NULL.] */\n                    LogError(\"Could not create the internal decoder\");\n                    REFCOUNT_TYPE_DESTROY(AMQP_VALUE_DATA, decoder_instance->decode_to_value);\n                    free(decoder_instance);\n                    decoder_instance = NULL;\n                }\n            }\n        }\n    }\n\n    /* Codes_SRS_AMQPVALUE_01_311: [amqpvalue_decoder_create shall create a new amqp value decoder and return a non-NULL handle to it.] */\n    return decoder_instance;\n}\n\nvoid amqpvalue_decoder_destroy(AMQPVALUE_DECODER_HANDLE handle)\n{\n    if (handle == NULL)\n    {\n        /* Codes_SRS_AMQPVALUE_01_317: [If handle is NULL, amqpvalue_decoder_destroy shall do nothing.] */\n        LogError(\"NULL handle\");\n    }\n    else\n    {\n        AMQPVALUE_DECODER_HANDLE_DATA* decoder_instance = (AMQPVALUE_DECODER_HANDLE_DATA*)handle;\n        /* Codes_SRS_AMQPVALUE_01_316: [amqpvalue_decoder_destroy shall free all resources associated with the amqpvalue_decoder.] */\n        amqpvalue_destroy(decoder_instance->internal_decoder->decode_to_value);\n        internal_decoder_destroy(decoder_instance->internal_decoder);\n        free(handle);\n    }\n}\n\n/* Codes_SRS_AMQPVALUE_01_318: [amqpvalue_decode_bytes shall decode size bytes that are passed in the buffer argument.] */\nint amqpvalue_decode_bytes(AMQPVALUE_DECODER_HANDLE handle, const unsigned char* buffer, size_t size)\n{\n    int result;\n\n    AMQPVALUE_DECODER_HANDLE_DATA* decoder_instance = (AMQPVALUE_DECODER_HANDLE_DATA*)handle;\n    /* Codes_SRS_AMQPVALUE_01_320: [If handle or buffer are NULL, amqpvalue_decode_bytes shall return a non-zero value.] */\n    if ((decoder_instance == NULL) ||\n        (buffer == NULL) ||\n        /* Codes_SRS_AMQPVALUE_01_321: [If size is 0, amqpvalue_decode_bytes shall return a non-zero value.] */\n        (size == 0))\n    {\n        LogError(\"Bad arguments: decoder_instance = %p, buffer = %p, size = %lu\",\n            decoder_instance, buffer, (unsigned long)size);\n        result = MU_FAILURE;\n    }\n    else\n    {\n        size_t used_bytes;\n\n        /* Codes_SRS_AMQPVALUE_01_318: [amqpvalue_decode_bytes shall decode size bytes that are passed in the buffer argument.] */\n        if (internal_decoder_decode_bytes(decoder_instance->internal_decoder, buffer, size, &used_bytes) != 0)\n        {\n            LogError(\"Failed decoding bytes\");\n            result = MU_FAILURE;\n        }\n        else\n        {\n            /* Codes_SRS_AMQPVALUE_01_319: [On success, amqpvalue_decode_bytes shall return 0.] */\n            result = 0;\n        }\n    }\n\n    return result;\n}\n\nAMQP_VALUE amqpvalue_get_inplace_descriptor(AMQP_VALUE value)\n{\n    AMQP_VALUE result;\n\n    if (value == NULL)\n    {\n        LogError(\"NULL value\");\n        result = NULL;\n    }\n    else\n    {\n        AMQP_VALUE_DATA* value_data = (AMQP_VALUE_DATA*)value;\n        if ((value_data->type != AMQP_TYPE_DESCRIBED) &&\n            (value_data->type != AMQP_TYPE_COMPOSITE))\n        {\n            LogError(\"Type is not described or composite\");\n            result = NULL;\n        }\n        else\n        {\n            result = value_data->value.described_value.descriptor;\n        }\n    }\n\n    return result;\n}\n\nAMQP_VALUE amqpvalue_get_inplace_described_value(AMQP_VALUE value)\n{\n    AMQP_VALUE result;\n\n    if (value == NULL)\n    {\n        LogError(\"NULL value\");\n        result = NULL;\n    }\n    else\n    {\n        AMQP_VALUE_DATA* value_data = (AMQP_VALUE_DATA*)value;\n        if ((value_data->type != AMQP_TYPE_DESCRIBED) &&\n            (value_data->type != AMQP_TYPE_COMPOSITE))\n        {\n            LogError(\"Type is not described or composite\");\n            result = NULL;\n        }\n        else\n        {\n            result = value_data->value.described_value.value;\n        }\n    }\n\n    return result;\n}\n\nAMQP_VALUE amqpvalue_create_described(AMQP_VALUE descriptor, AMQP_VALUE value)\n{\n    AMQP_VALUE_DATA* result = (AMQP_VALUE_DATA*)REFCOUNT_TYPE_CREATE(AMQP_VALUE_DATA);\n    if (result == NULL)\n    {\n        LogError(\"Cannot allocate memory for described type\");\n    }\n    else\n    {\n        result->type = AMQP_TYPE_DESCRIBED;\n        result->value.described_value.descriptor = descriptor;\n        result->value.described_value.value = value;\n    }\n\n    return result;\n}\n\nAMQP_VALUE amqpvalue_create_composite(AMQP_VALUE descriptor, uint32_t list_size)\n{\n    AMQP_VALUE_DATA* result = (AMQP_VALUE_DATA*)REFCOUNT_TYPE_CREATE(AMQP_VALUE_DATA);\n    if (result == NULL)\n    {\n        LogError(\"Cannot allocate memory for composite type\");\n    }\n    else\n    {\n        result->type = AMQP_TYPE_COMPOSITE;\n        result->value.described_value.descriptor = amqpvalue_clone(descriptor);\n        if (result->value.described_value.descriptor == NULL)\n        {\n            LogError(\"Cannot clone descriptor for composite type\");\n            REFCOUNT_TYPE_DESTROY(AMQP_VALUE_DATA, result);\n            result = NULL;\n        }\n        else\n        {\n            result->value.described_value.value = amqpvalue_create_list();\n            if (result->value.described_value.value == NULL)\n            {\n                LogError(\"Cannot create list for composite type\");\n                amqpvalue_destroy(result->value.described_value.descriptor);\n                REFCOUNT_TYPE_DESTROY(AMQP_VALUE_DATA, result);\n                result = NULL;\n            }\n            else\n            {\n                if (amqpvalue_set_list_item_count(result->value.described_value.value, list_size) != 0)\n                {\n                    LogError(\"Cannot set list item count for composite type\");\n                    amqpvalue_destroy(result->value.described_value.descriptor);\n                    amqpvalue_destroy(result->value.described_value.value);\n                    REFCOUNT_TYPE_DESTROY(AMQP_VALUE_DATA, result);\n                    result = NULL;\n                }\n            }\n        }\n    }\n\n    return result;\n}\n\nAMQP_VALUE amqpvalue_create_composite_with_ulong_descriptor(uint64_t descriptor)\n{\n    AMQP_VALUE_DATA* result = (AMQP_VALUE_DATA*)REFCOUNT_TYPE_CREATE(AMQP_VALUE_DATA);\n    if (result == NULL)\n    {\n        LogError(\"Cannot allocate memory for composite type\");\n    }\n    else\n    {\n        AMQP_VALUE descriptor_ulong_value = amqpvalue_create_ulong(descriptor);\n        if (descriptor_ulong_value == NULL)\n        {\n            LogError(\"Cannot create ulong descriptor for composite type\");\n            REFCOUNT_TYPE_DESTROY(AMQP_VALUE_DATA, result);\n            result = NULL;\n        }\n        else\n        {\n            result->type = AMQP_TYPE_COMPOSITE;\n            result->value.described_value.descriptor = descriptor_ulong_value;\n            result->value.described_value.value = amqpvalue_create_list();\n            if (result->value.described_value.value == NULL)\n            {\n                LogError(\"Cannot create list for composite type\");\n                amqpvalue_destroy(descriptor_ulong_value);\n                REFCOUNT_TYPE_DESTROY(AMQP_VALUE_DATA, result);\n                result = NULL;\n            }\n        }\n    }\n\n    return result;\n}\n\nint amqpvalue_set_composite_item(AMQP_VALUE value, uint32_t index, AMQP_VALUE item_value)\n{\n    int result;\n\n    if (value == NULL)\n    {\n        LogError(\"NULL value\");\n        result = MU_FAILURE;\n    }\n    else\n    {\n        AMQP_VALUE_DATA* value_data = (AMQP_VALUE_DATA*)value;\n        if ((value_data->type != AMQP_TYPE_COMPOSITE) &&\n            (value_data->type != AMQP_TYPE_DESCRIBED))\n        {\n            LogError(\"Attempt to set composite item on a non-composite type\");\n            result = MU_FAILURE;\n        }\n        else\n        {\n            if (amqpvalue_set_list_item(value_data->value.described_value.value, index, item_value) != 0)\n            {\n                LogError(\"amqpvalue_set_list_item failed for composite item\");\n                result = MU_FAILURE;\n            }\n            else\n            {\n                result = 0;\n            }\n        }\n    }\n\n    return result;\n}\n\nAMQP_VALUE amqpvalue_get_composite_item(AMQP_VALUE value, size_t index)\n{\n    AMQP_VALUE result;\n\n    if (value == NULL)\n    {\n        LogError(\"NULL value\");\n        result = NULL;\n    }\n    else\n    {\n        AMQP_VALUE_DATA* value_data = (AMQP_VALUE_DATA*)value;\n        if ((value_data->type != AMQP_TYPE_COMPOSITE) &&\n            (value_data->type != AMQP_TYPE_DESCRIBED))\n        {\n            LogError(\"Attempt to get composite item on a non-composite type\");\n            result = NULL;\n        }\n        else\n        {\n            result = amqpvalue_get_list_item(value_data->value.described_value.value, index);\n            if (result == NULL)\n            {\n                LogError(\"amqpvalue_get_list_item failed for composite item\");\n            }\n        }\n    }\n\n    return result;\n}\n\nAMQP_VALUE amqpvalue_get_composite_item_in_place(AMQP_VALUE value, size_t index)\n{\n    AMQP_VALUE result;\n\n    if (value == NULL)\n    {\n        LogError(\"NULL value\");\n        result = NULL;\n    }\n    else\n    {\n        AMQP_VALUE_DATA* value_data = (AMQP_VALUE_DATA*)value;\n        if ((value_data->type != AMQP_TYPE_COMPOSITE) &&\n            (value_data->type != AMQP_TYPE_DESCRIBED))\n        {\n            LogError(\"Attempt to get composite item in place on a non-composite type\");\n            result = NULL;\n        }\n        else\n        {\n            result = amqpvalue_get_list_item_in_place(value_data->value.described_value.value, index);\n            if (result == NULL)\n            {\n                LogError(\"amqpvalue_get_list_item_in_place failed for composite item\");\n            }\n        }\n    }\n\n    return result;\n}\n\nint amqpvalue_get_composite_item_count(AMQP_VALUE value, uint32_t* item_count)\n{\n    int result;\n\n    if (value == NULL)\n    {\n        LogError(\"NULL value\");\n        result = MU_FAILURE;\n    }\n    else\n    {\n        AMQP_VALUE_DATA* value_data = (AMQP_VALUE_DATA*)value;\n        if ((value_data->type != AMQP_TYPE_COMPOSITE) &&\n            (value_data->type != AMQP_TYPE_DESCRIBED))\n        {\n            LogError(\"Attempt to get composite item in place on a non-composite type\");\n            result = MU_FAILURE;\n        }\n        else\n        {\n            if (amqpvalue_get_list_item_count(value_data->value.described_value.value, item_count) != 0)\n            {\n                LogError(\"amqpvalue_get_list_item_in_place failed for composite item\");\n                result = MU_FAILURE;\n            }\n            else\n            {\n                result = 0;\n            }\n        }\n    }\n\n    return result;\n}\n\nAMQP_VALUE amqpvalue_get_list_item_in_place(AMQP_VALUE value, size_t index)\n{\n    AMQP_VALUE result;\n\n    if (value == NULL)\n    {\n        LogError(\"NULL value\");\n        result = NULL;\n    }\n    else\n    {\n        AMQP_VALUE_DATA* value_data = (AMQP_VALUE_DATA*)value;\n\n        if ((value_data->type != AMQP_TYPE_LIST) ||\n            (value_data->value.list_value.count <= index))\n        {\n            LogError(\"Attempt to get list item in place on a non-list type\");\n            result = NULL;\n        }\n        else\n        {\n            result = value_data->value.list_value.items[index];\n        }\n    }\n\n    return result;\n}\n"], "filenames": ["src/amqpvalue.c"], "buggy_code_start_loc": [5915], "buggy_code_end_loc": [5916], "fixing_code_start_loc": [5915], "fixing_code_end_loc": [5926], "type": "CWE-190", "message": "Azure uAMQP is a general purpose C library for AMQP 1.0. The UAMQP library is used by several clients to implement AMQP protocol communication.  When clients using this library receive a crafted binary type data, an integer overflow or wraparound or memory safety issue can occur and may cause remote code execution.  This vulnerability has been patched in release 2024-01-01.", "other": {"cve": {"id": "CVE-2024-21646", "sourceIdentifier": "security-advisories@github.com", "published": "2024-01-09T01:15:38.937", "lastModified": "2024-01-12T16:39:24.037", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Azure uAMQP is a general purpose C library for AMQP 1.0. The UAMQP library is used by several clients to implement AMQP protocol communication.  When clients using this library receive a crafted binary type data, an integer overflow or wraparound or memory safety issue can occur and may cause remote code execution.  This vulnerability has been patched in release 2024-01-01."}, {"lang": "es", "value": "Azure uAMQP es una librer\u00eda C de uso general para AMQP 1.0. Varios clientes utilizan la librer\u00eda UAMQP para implementar la comunicaci\u00f3n del protocolo AMQP. Cuando los clientes que utilizan esta librer\u00eda reciben datos de tipo binario manipulados, puede producirse un desbordamiento de enteros o un problema de seguridad de la memoria que puede provocar la ejecuci\u00f3n remota de c\u00f3digo. Esta vulnerabilidad se solucion\u00f3 en la versi\u00f3n 2024-01-01."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-190"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-94"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:microsoft:azure_uamqp:*:*:*:*:*:*:*:*", "versionEndExcluding": "2024-01-01", "matchCriteriaId": "A7BC0B9B-7E26-4F62-88D1-D076EB37050C"}]}]}], "references": [{"url": "https://github.com/Azure/azure-uamqp-c/commit/12ddb3a31a5a97f55b06fa5d74c59a1d84ad78fe", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/Azure/azure-uamqp-c/security/advisories/GHSA-j29m-p99g-7hpv", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/Azure/azure-uamqp-c/commit/12ddb3a31a5a97f55b06fa5d74c59a1d84ad78fe"}}