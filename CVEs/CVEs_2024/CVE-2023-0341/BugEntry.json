{"buggy_code": ["/*\n * Copyright (c) 2014-2019 Hong Xu <hong AT topbug DOT net>\n * Copyright (c) 2018 Sven Strickroth <email AT cs-ware DOT de>\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n*/\n\n#include \"global.h\"\n\n#include <ctype.h>\n#include <string.h>\n#include <pcre2.h>\n\n#define utarray_oom() { return -2; }\n#include \"utarray.h\"\n#include \"misc.h\"\n#include \"util.h\"\n\n#include \"ec_glob.h\"\n\n/* Special characters */\nconst char ec_special_chars[] = \"?[]\\\\*-{},\";\n\ntypedef struct int_pair\n{\n    int     num1;\n    int     num2;\n} int_pair;\nstatic const UT_icd ut_int_pair_icd = {sizeof(int_pair),NULL,NULL,NULL};\n\n/* concatenate the string then move the pointer to the end */\n#define STRING_CAT(p, string, end)  do {    \\\n    size_t string_len = strlen(string); \\\n    if (p + string_len >= end) \\\n        return -1; \\\n    strcat(p, string); \\\n    p += string_len; \\\n} while(0)\n\n#define PATTERN_MAX  4097\n/*\n * Whether the string matches the given glob pattern. Return 0 if successful, return -1 if a PCRE\n * error or other regex error occurs, and return -2 if an OOM outside PCRE occurs.\n */\nEDITORCONFIG_LOCAL\nint ec_glob(const char *pattern, const char *string)\n{\n    size_t                    i;\n    int_pair *                p;\n    char *                    c;\n    char                      pcre_str[2 * PATTERN_MAX] = \"^\";\n    char *                    p_pcre;\n    char *                    pcre_str_end;\n    int                       brace_level = 0;\n    _Bool                     is_in_bracket = 0;\n    int                       error_code;\n    size_t                    erroffset;\n    pcre2_code *              re;\n    int                       rc;\n    size_t *                  pcre_result;\n    pcre2_match_data *        pcre_match_data;\n    char                      l_pattern[2 * PATTERN_MAX];\n    _Bool                     are_braces_paired = 1;\n    UT_array *                nums;     /* number ranges */\n    int                       ret = 0;\n\n    strcpy(l_pattern, pattern);\n    p_pcre = pcre_str + 1;\n    pcre_str_end = pcre_str + 2 * PATTERN_MAX;\n\n    /* Determine whether curly braces are paired */\n    {\n        int     left_count = 0;\n        int     right_count = 0;\n        for (c = l_pattern; *c; ++ c)\n        {\n            if (*c == '\\\\' && *(c+1) != '\\0')\n            {\n                ++ c;\n                continue;\n            }\n\n            if (*c == '}')\n                ++ right_count;\n            else if (*c == '{')\n                ++ left_count;\n\n            if (right_count > left_count)\n            {\n                are_braces_paired = 0;\n                break;\n            }\n        }\n\n        if (right_count != left_count)\n            are_braces_paired = 0;\n    }\n\n    /* used to search for {num1..num2} case */\n    re = pcre2_compile(\"^\\\\{[\\\\+\\\\-]?\\\\d+\\\\.\\\\.[\\\\+\\\\-]?\\\\d+\\\\}$\", PCRE2_ZERO_TERMINATED, 0,\n            &error_code, &erroffset, NULL);\n    if (!re)        /* failed to compile */\n        return -1;\n\n    utarray_new(nums, &ut_int_pair_icd);\n\n    for (c = l_pattern; *c; ++ c)\n    {\n        switch (*c)\n        {\n        case '\\\\':      /* also skip the next one */\n            if (*(c+1) != '\\0')\n            {\n                *(p_pcre ++) = *(c++);\n                *(p_pcre ++) = *c;\n            }\n            else\n                STRING_CAT(p_pcre, \"\\\\\\\\\", pcre_str_end);\n\n            break;\n        case '?':\n            STRING_CAT(p_pcre, \"[^/]\", pcre_str_end);\n            break;\n        case '*':\n            if (*(c+1) == '*')      /* case of ** */\n            {\n                STRING_CAT(p_pcre, \".*\", pcre_str_end);\n                ++ c;\n            }\n            else                    /* case of * */\n                STRING_CAT(p_pcre, \"[^\\\\/]*\", pcre_str_end);\n\n            break;\n        case '[':\n            if (is_in_bracket)     /* inside brackets, we really mean bracket */\n            {\n                STRING_CAT(p_pcre, \"\\\\[\", pcre_str_end);\n                break;\n            }\n\n            {\n                /* check whether we have slash within the bracket */\n                _Bool           has_slash = 0;\n                char *          cc;\n                for (cc = c; *cc && *cc != ']'; ++ cc)\n                {\n                    if (*cc == '\\\\' && *(cc+1) != '\\0')\n                    {\n                        ++ cc;\n                        continue;\n                    }\n\n                    if (*cc == '/')\n                    {\n                        has_slash = 1;\n                        break;\n                    }\n                }\n\n                /* if we have slash in the brackets, just do it literally */\n                if (has_slash)\n                {\n                    char *           right_bracket = strchr(c, ']');\n\n                    if (!right_bracket)  /* The right bracket may not exist */\n                        right_bracket = c + strlen(c);\n\n                    strcat(p_pcre, \"\\\\\");\n                    strncat(p_pcre, c, right_bracket - c);\n                    if (*right_bracket)  /* right_bracket is a bracket */\n                        strcat(p_pcre, \"\\\\]\");\n                    p_pcre += strlen(p_pcre);\n                    c = right_bracket;\n                    if (!*c)\n                        /* end of string, meaning that right_bracket is not a\n                         * bracket. Then we go back one character to make the\n                         * parsing end normally for the counter in the \"for\"\n                         * loop. */\n                        c -= 1;\n                    break;\n                }\n            }\n\n            is_in_bracket = 1;\n            if (*(c+1) == '!')     /* case of [!...] */\n            {\n                STRING_CAT(p_pcre, \"[^\", pcre_str_end);\n                ++ c;\n            }\n            else\n                *(p_pcre ++) = '[';\n\n            break;\n\n        case ']':\n            is_in_bracket = 0;\n            *(p_pcre ++) = *c;\n            break;\n\n        case '-':\n            if (is_in_bracket)      /* in brackets, - indicates range */\n                *(p_pcre ++) = *c;\n            else\n                STRING_CAT(p_pcre, \"\\\\-\", pcre_str_end);\n\n            break;\n        case '{':\n            if (!are_braces_paired)\n            {\n                STRING_CAT(p_pcre, \"\\\\{\", pcre_str_end);\n                break;\n            }\n\n            /* Check the case of {single}, where single can be empty */\n            {\n                char *                   cc;\n                _Bool                    is_single = 1;\n\n                for (cc = c + 1; *cc != '\\0' && *cc != '}'; ++ cc)\n                {\n                    if (*cc == '\\\\' && *(cc+1) != '\\0')\n                    {\n                        ++ cc;\n                        continue;\n                    }\n\n                    if (*cc == ',')\n                    {\n                        is_single = 0;\n                        break;\n                    }\n                }\n\n                if (*cc == '\\0')\n                    is_single = 0;\n\n                if (is_single)      /* escape the { and the corresponding } */\n                {\n                    const char *        double_dots;\n                    int_pair            pair;\n\n                    pcre2_match_data *  match_data = pcre2_match_data_create_from_pattern(re, NULL);\n\n                    /* Check the case of {num1..num2} */\n                    rc = pcre2_match(re, c, cc - c + 1, 0, 0, match_data, NULL);\n\n                    pcre2_match_data_free(match_data);\n\n                    if (rc < 0)    /* not {num1..num2} case */\n                    {\n                        STRING_CAT(p_pcre, \"\\\\{\", pcre_str_end);\n\n                        memmove(cc+1, cc, strlen(cc) + 1);\n                        *cc = '\\\\';\n\n                        break;\n                    }\n\n                    /* Get the range */\n                    double_dots = strstr(c, \"..\");\n                    pair.num1 = ec_atoi(c + 1);\n                    pair.num2 = ec_atoi(double_dots + 2);\n\n                    utarray_push_back(nums, &pair);\n\n                    STRING_CAT(p_pcre, \"([\\\\+\\\\-]?\\\\d+)\", pcre_str_end);\n                    c = cc;\n\n                    break;\n                }\n            }\n\n            ++ brace_level;\n            STRING_CAT(p_pcre, \"(?:\", pcre_str_end);\n            break;\n\n        case '}':\n            if (!are_braces_paired)\n            {\n                STRING_CAT(p_pcre, \"\\\\}\", pcre_str_end);\n                break;\n            }\n\n            -- brace_level;\n            *(p_pcre ++) = ')';\n            break;\n\n        case ',':\n            if (brace_level > 0)  /* , inside {...} */\n                *(p_pcre ++) = '|';\n            else\n                STRING_CAT(p_pcre, \"\\\\,\", pcre_str_end);\n            break;\n\n        case '/':\n            // /**/ case, match both single / and /anything/\n            if (!strncmp(c, \"/**/\", 4))\n            {\n                STRING_CAT(p_pcre, \"(\\\\/|\\\\/.*\\\\/)\", pcre_str_end);\n                c += 3;\n            }\n            else\n                STRING_CAT(p_pcre, \"\\\\/\", pcre_str_end);\n\n            break;\n\n        default:\n            if (!isalnum(*c))\n                *(p_pcre ++) = '\\\\';\n\n            *(p_pcre ++) = *c;\n        }\n    }\n\n    *(p_pcre ++) = '$';\n\n    pcre2_code_free(re); /* ^\\\\d+\\\\.\\\\.\\\\d+$ */\n\n    re = pcre2_compile(pcre_str, PCRE2_ZERO_TERMINATED, 0, &error_code, &erroffset, NULL);\n\n    if (!re)        /* failed to compile */\n    {\n        utarray_free(nums);\n        return -1;\n    }\n\n    pcre_match_data = pcre2_match_data_create_from_pattern(re, NULL);\n    rc = pcre2_match(re, string, strlen(string), 0, 0, pcre_match_data, NULL);\n\n    if (rc < 0)     /* failed to match */\n    {\n        if (rc == PCRE2_ERROR_NOMATCH)\n            ret = EC_GLOB_NOMATCH;\n        else\n            ret = rc;\n\n        goto cleanup;\n    }\n\n    /* Whether the numbers are in the desired range? */\n    pcre_result = pcre2_get_ovector_pointer(pcre_match_data);\n    for(p = (int_pair *) utarray_front(nums), i = 1; p;\n            ++ i, p = (int_pair *) utarray_next(nums, p))\n    {\n        const char * substring_start = string + pcre_result[2 * i];\n        size_t  substring_length = pcre_result[2 * i + 1] - pcre_result[2 * i];\n        char *       num_string;\n        int          num;\n\n        /* we don't consider 0digits such as 010 as matched */\n        if (*substring_start == '0')\n            break;\n\n        num_string = strndup(substring_start, substring_length);\n        if (num_string == NULL) {\n          ret = -2;\n          goto cleanup;\n        }\n        num = ec_atoi(num_string);\n        free(num_string);\n\n        if (num < p->num1 || num > p->num2) /* not matched */\n            break;\n    }\n\n    if (p != NULL)      /* numbers not matched */\n        ret = EC_GLOB_NOMATCH;\n\n cleanup:\n\n    pcre2_code_free(re);\n    pcre2_match_data_free(pcre_match_data);\n    utarray_free(nums);\n\n    return ret;\n}\n"], "fixing_code": ["/*\n * Copyright (c) 2014-2019 Hong Xu <hong AT topbug DOT net>\n * Copyright (c) 2018 Sven Strickroth <email AT cs-ware DOT de>\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n*/\n\n#include \"global.h\"\n\n#include <ctype.h>\n#include <string.h>\n#include <pcre2.h>\n\n#define utarray_oom() { return -2; }\n#include \"utarray.h\"\n#include \"misc.h\"\n#include \"util.h\"\n\n#include \"ec_glob.h\"\n\n/* Special characters */\nconst char ec_special_chars[] = \"?[]\\\\*-{},\";\n\ntypedef struct int_pair\n{\n    int     num1;\n    int     num2;\n} int_pair;\nstatic const UT_icd ut_int_pair_icd = {sizeof(int_pair),NULL,NULL,NULL};\n\n/* concatenate the string then move the pointer to the end */\n#define STRING_CAT(p, string, end)  do {    \\\n    size_t string_len = strlen(string); \\\n    if (p + string_len >= end) \\\n        return -1; \\\n    strcat(p, string); \\\n    p += string_len; \\\n} while(0)\n\n/* safely add a char to a string then move the pointer to the end */\n#define ADD_CHAR(string, new_chr, end)  do {    \\\n    if (string + 1 >= end) \\\n        return -1; \\\n    *(string ++) = new_chr; \\\n} while(0)\n\n#define PATTERN_MAX  4097\n/*\n * Whether the string matches the given glob pattern. Return 0 if successful, return -1 if a PCRE\n * error or other regex error occurs, and return -2 if an OOM outside PCRE occurs.\n */\nEDITORCONFIG_LOCAL\nint ec_glob(const char *pattern, const char *string)\n{\n    size_t                    i;\n    int_pair *                p;\n    char *                    c;\n    char                      pcre_str[2 * PATTERN_MAX] = \"^\";\n    char *                    p_pcre;\n    char *                    pcre_str_end;\n    int                       brace_level = 0;\n    _Bool                     is_in_bracket = 0;\n    int                       error_code;\n    size_t                    erroffset;\n    pcre2_code *              re;\n    int                       rc;\n    size_t *                  pcre_result;\n    pcre2_match_data *        pcre_match_data;\n    char                      l_pattern[2 * PATTERN_MAX];\n    _Bool                     are_braces_paired = 1;\n    UT_array *                nums;     /* number ranges */\n    int                       ret = 0;\n\n    strcpy(l_pattern, pattern);\n    p_pcre = pcre_str + 1;\n    pcre_str_end = pcre_str + 2 * PATTERN_MAX;\n\n    /* Determine whether curly braces are paired */\n    {\n        int     left_count = 0;\n        int     right_count = 0;\n        for (c = l_pattern; *c; ++ c)\n        {\n            if (*c == '\\\\' && *(c+1) != '\\0')\n            {\n                ++ c;\n                continue;\n            }\n\n            if (*c == '}')\n                ++ right_count;\n            else if (*c == '{')\n                ++ left_count;\n\n            if (right_count > left_count)\n            {\n                are_braces_paired = 0;\n                break;\n            }\n        }\n\n        if (right_count != left_count)\n            are_braces_paired = 0;\n    }\n\n    /* used to search for {num1..num2} case */\n    re = pcre2_compile(\"^\\\\{[\\\\+\\\\-]?\\\\d+\\\\.\\\\.[\\\\+\\\\-]?\\\\d+\\\\}$\", PCRE2_ZERO_TERMINATED, 0,\n            &error_code, &erroffset, NULL);\n    if (!re)        /* failed to compile */\n        return -1;\n\n    utarray_new(nums, &ut_int_pair_icd);\n\n    for (c = l_pattern; *c; ++ c)\n    {\n        switch (*c)\n        {\n        case '\\\\':      /* also skip the next one */\n            if (*(c+1) != '\\0')\n            {\n                ADD_CHAR(p_pcre, *(c++), pcre_str_end);\n                ADD_CHAR(p_pcre, *c, pcre_str_end);\n            }\n            else\n                STRING_CAT(p_pcre, \"\\\\\\\\\", pcre_str_end);\n\n            break;\n        case '?':\n            STRING_CAT(p_pcre, \"[^/]\", pcre_str_end);\n            break;\n        case '*':\n            if (*(c+1) == '*')      /* case of ** */\n            {\n                STRING_CAT(p_pcre, \".*\", pcre_str_end);\n                ++ c;\n            }\n            else                    /* case of * */\n                STRING_CAT(p_pcre, \"[^\\\\/]*\", pcre_str_end);\n\n            break;\n        case '[':\n            if (is_in_bracket)     /* inside brackets, we really mean bracket */\n            {\n                STRING_CAT(p_pcre, \"\\\\[\", pcre_str_end);\n                break;\n            }\n\n            {\n                /* check whether we have slash within the bracket */\n                _Bool           has_slash = 0;\n                char *          cc;\n                for (cc = c; *cc && *cc != ']'; ++ cc)\n                {\n                    if (*cc == '\\\\' && *(cc+1) != '\\0')\n                    {\n                        ++ cc;\n                        continue;\n                    }\n\n                    if (*cc == '/')\n                    {\n                        has_slash = 1;\n                        break;\n                    }\n                }\n\n                /* if we have slash in the brackets, just do it literally */\n                if (has_slash)\n                {\n                    char *           right_bracket = strchr(c, ']');\n\n                    if (!right_bracket)  /* The right bracket may not exist */\n                        right_bracket = c + strlen(c);\n\n                    strcat(p_pcre, \"\\\\\");\n                    strncat(p_pcre, c, right_bracket - c);\n                    if (*right_bracket)  /* right_bracket is a bracket */\n                        strcat(p_pcre, \"\\\\]\");\n                    p_pcre += strlen(p_pcre);\n                    c = right_bracket;\n                    if (!*c)\n                        /* end of string, meaning that right_bracket is not a\n                         * bracket. Then we go back one character to make the\n                         * parsing end normally for the counter in the \"for\"\n                         * loop. */\n                        c -= 1;\n                    break;\n                }\n            }\n\n            is_in_bracket = 1;\n            if (*(c+1) == '!')     /* case of [!...] */\n            {\n                STRING_CAT(p_pcre, \"[^\", pcre_str_end);\n                ++ c;\n            }\n            else\n                STRING_CAT(p_pcre, \"[\", pcre_str_end);\n\n            break;\n\n        case ']':\n            is_in_bracket = 0;\n            ADD_CHAR(p_pcre, *c, pcre_str_end);\n            break;\n\n        case '-':\n            if (is_in_bracket)      /* in brackets, - indicates range */\n                ADD_CHAR(p_pcre, *c, pcre_str_end);\n            else\n                STRING_CAT(p_pcre, \"\\\\-\", pcre_str_end);\n\n            break;\n        case '{':\n            if (!are_braces_paired)\n            {\n                STRING_CAT(p_pcre, \"\\\\{\", pcre_str_end);\n                break;\n            }\n\n            /* Check the case of {single}, where single can be empty */\n            {\n                char *                   cc;\n                _Bool                    is_single = 1;\n\n                for (cc = c + 1; *cc != '\\0' && *cc != '}'; ++ cc)\n                {\n                    if (*cc == '\\\\' && *(cc+1) != '\\0')\n                    {\n                        ++ cc;\n                        continue;\n                    }\n\n                    if (*cc == ',')\n                    {\n                        is_single = 0;\n                        break;\n                    }\n                }\n\n                if (*cc == '\\0')\n                    is_single = 0;\n\n                if (is_single)      /* escape the { and the corresponding } */\n                {\n                    const char *        double_dots;\n                    int_pair            pair;\n\n                    pcre2_match_data *  match_data = pcre2_match_data_create_from_pattern(re, NULL);\n\n                    /* Check the case of {num1..num2} */\n                    rc = pcre2_match(re, c, cc - c + 1, 0, 0, match_data, NULL);\n\n                    pcre2_match_data_free(match_data);\n\n                    if (rc < 0)    /* not {num1..num2} case */\n                    {\n                        STRING_CAT(p_pcre, \"\\\\{\", pcre_str_end);\n\n                        memmove(cc+1, cc, strlen(cc) + 1);\n                        *cc = '\\\\';\n\n                        break;\n                    }\n\n                    /* Get the range */\n                    double_dots = strstr(c, \"..\");\n                    pair.num1 = ec_atoi(c + 1);\n                    pair.num2 = ec_atoi(double_dots + 2);\n\n                    utarray_push_back(nums, &pair);\n\n                    STRING_CAT(p_pcre, \"([\\\\+\\\\-]?\\\\d+)\", pcre_str_end);\n                    c = cc;\n\n                    break;\n                }\n            }\n\n            ++ brace_level;\n            STRING_CAT(p_pcre, \"(?:\", pcre_str_end);\n            break;\n\n        case '}':\n            if (!are_braces_paired)\n            {\n                STRING_CAT(p_pcre, \"\\\\}\", pcre_str_end);\n                break;\n            }\n\n            -- brace_level;\n            STRING_CAT(p_pcre, \")\", pcre_str_end);\n            break;\n\n        case ',':\n            if (brace_level > 0)  /* , inside {...} */\n                STRING_CAT(p_pcre, \"|\", pcre_str_end);\n            else\n                STRING_CAT(p_pcre, \"\\\\,\", pcre_str_end);\n            break;\n\n        case '/':\n            // /**/ case, match both single / and /anything/\n            if (!strncmp(c, \"/**/\", 4))\n            {\n                STRING_CAT(p_pcre, \"(\\\\/|\\\\/.*\\\\/)\", pcre_str_end);\n                c += 3;\n            }\n            else\n                STRING_CAT(p_pcre, \"\\\\/\", pcre_str_end);\n\n            break;\n\n        default:\n            if (!isalnum(*c))\n                STRING_CAT(p_pcre, \"\\\\\", pcre_str_end);\n\n            ADD_CHAR(p_pcre, *c, pcre_str_end);\n        }\n    }\n\n    *(p_pcre ++) = '$';\n\n    pcre2_code_free(re); /* ^\\\\d+\\\\.\\\\.\\\\d+$ */\n\n    re = pcre2_compile(pcre_str, PCRE2_ZERO_TERMINATED, 0, &error_code, &erroffset, NULL);\n\n    if (!re)        /* failed to compile */\n    {\n        utarray_free(nums);\n        return -1;\n    }\n\n    pcre_match_data = pcre2_match_data_create_from_pattern(re, NULL);\n    rc = pcre2_match(re, string, strlen(string), 0, 0, pcre_match_data, NULL);\n\n    if (rc < 0)     /* failed to match */\n    {\n        if (rc == PCRE2_ERROR_NOMATCH)\n            ret = EC_GLOB_NOMATCH;\n        else\n            ret = rc;\n\n        goto cleanup;\n    }\n\n    /* Whether the numbers are in the desired range? */\n    pcre_result = pcre2_get_ovector_pointer(pcre_match_data);\n    for(p = (int_pair *) utarray_front(nums), i = 1; p;\n            ++ i, p = (int_pair *) utarray_next(nums, p))\n    {\n        const char * substring_start = string + pcre_result[2 * i];\n        size_t  substring_length = pcre_result[2 * i + 1] - pcre_result[2 * i];\n        char *       num_string;\n        int          num;\n\n        /* we don't consider 0digits such as 010 as matched */\n        if (*substring_start == '0')\n            break;\n\n        num_string = strndup(substring_start, substring_length);\n        if (num_string == NULL) {\n          ret = -2;\n          goto cleanup;\n        }\n        num = ec_atoi(num_string);\n        free(num_string);\n\n        if (num < p->num1 || num > p->num2) /* not matched */\n            break;\n    }\n\n    if (p != NULL)      /* numbers not matched */\n        ret = EC_GLOB_NOMATCH;\n\n cleanup:\n\n    pcre2_code_free(re);\n    pcre2_match_data_free(pcre_match_data);\n    utarray_free(nums);\n\n    return ret;\n}\n"], "filenames": ["src/lib/ec_glob.c"], "buggy_code_start_loc": [59], "buggy_code_end_loc": [332], "fixing_code_start_loc": [60], "fixing_code_end_loc": [339], "type": "CWE-787", "message": "A stack buffer overflow exists in the ec_glob function of editorconfig-core-c before v0.12.6 which allowed an attacker to arbitrarily write to the stack and possibly allows remote code execution. editorconfig-core-c v0.12.6 resolved this vulnerability by bound checking all write operations over the p_pcre buffer.", "other": {"cve": {"id": "CVE-2023-0341", "sourceIdentifier": "security@ubuntu.com", "published": "2023-02-01T00:15:10.343", "lastModified": "2023-06-03T05:15:08.917", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "A stack buffer overflow exists in the ec_glob function of editorconfig-core-c before v0.12.6 which allowed an attacker to arbitrarily write to the stack and possibly allows remote code execution. editorconfig-core-c v0.12.6 resolved this vulnerability by bound checking all write operations over the p_pcre buffer."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}, {"source": "security@ubuntu.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}, {"source": "security@ubuntu.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-121"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:editorconfig:editorconfig:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.12.6", "matchCriteriaId": "063ADAC0-7C09-4775-87F0-A2FE98E99FC7"}]}]}], "references": [{"url": "https://github.com/editorconfig/editorconfig-core-c/commit/41281ea82fbf24b060a9f69b9c5369350fb0529e", "source": "security@ubuntu.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/ZCFE7DXWAAKDJPRKMXHCACKGKNV37IYZ/", "source": "security@ubuntu.com"}, {"url": "https://litios.github.io/2023/01/14/CVE-2023-0341.html", "source": "security@ubuntu.com", "tags": ["Exploit", "Patch", "Third Party Advisory"]}, {"url": "https://ubuntu.com/security/notices/USN-5842-1", "source": "security@ubuntu.com"}]}, "github_commit_url": "https://github.com/editorconfig/editorconfig-core-c/commit/41281ea82fbf24b060a9f69b9c5369350fb0529e"}}