{"buggy_code": ["// SPDX-License-Identifier: GPL-2.0+\n/*\n * composite.c - infrastructure for Composite USB Gadgets\n *\n * Copyright (C) 2006-2008 David Brownell\n */\n\n/* #define VERBOSE_DEBUG */\n\n#include <linux/kallsyms.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/device.h>\n#include <linux/utsname.h>\n#include <linux/bitfield.h>\n\n#include <linux/usb/composite.h>\n#include <linux/usb/otg.h>\n#include <asm/unaligned.h>\n\n#include \"u_os_desc.h\"\n\n/**\n * struct usb_os_string - represents OS String to be reported by a gadget\n * @bLength: total length of the entire descritor, always 0x12\n * @bDescriptorType: USB_DT_STRING\n * @qwSignature: the OS String proper\n * @bMS_VendorCode: code used by the host for subsequent requests\n * @bPad: not used, must be zero\n */\nstruct usb_os_string {\n\t__u8\tbLength;\n\t__u8\tbDescriptorType;\n\t__u8\tqwSignature[OS_STRING_QW_SIGN_LEN];\n\t__u8\tbMS_VendorCode;\n\t__u8\tbPad;\n} __packed;\n\n/*\n * The code in this file is utility code, used to build a gadget driver\n * from one or more \"function\" drivers, one or more \"configuration\"\n * objects, and a \"usb_composite_driver\" by gluing them together along\n * with the relevant device-wide data.\n */\n\nstatic struct usb_gadget_strings **get_containers_gs(\n\t\tstruct usb_gadget_string_container *uc)\n{\n\treturn (struct usb_gadget_strings **)uc->stash;\n}\n\n/**\n * function_descriptors() - get function descriptors for speed\n * @f: the function\n * @speed: the speed\n *\n * Returns the descriptors or NULL if not set.\n */\nstatic struct usb_descriptor_header **\nfunction_descriptors(struct usb_function *f,\n\t\t     enum usb_device_speed speed)\n{\n\tstruct usb_descriptor_header **descriptors;\n\n\t/*\n\t * NOTE: we try to help gadget drivers which might not be setting\n\t * max_speed appropriately.\n\t */\n\n\tswitch (speed) {\n\tcase USB_SPEED_SUPER_PLUS:\n\t\tdescriptors = f->ssp_descriptors;\n\t\tif (descriptors)\n\t\t\tbreak;\n\t\tfallthrough;\n\tcase USB_SPEED_SUPER:\n\t\tdescriptors = f->ss_descriptors;\n\t\tif (descriptors)\n\t\t\tbreak;\n\t\tfallthrough;\n\tcase USB_SPEED_HIGH:\n\t\tdescriptors = f->hs_descriptors;\n\t\tif (descriptors)\n\t\t\tbreak;\n\t\tfallthrough;\n\tdefault:\n\t\tdescriptors = f->fs_descriptors;\n\t}\n\n\t/*\n\t * if we can't find any descriptors at all, then this gadget deserves to\n\t * Oops with a NULL pointer dereference\n\t */\n\n\treturn descriptors;\n}\n\n/**\n * next_desc() - advance to the next desc_type descriptor\n * @t: currect pointer within descriptor array\n * @desc_type: descriptor type\n *\n * Return: next desc_type descriptor or NULL\n *\n * Iterate over @t until either desc_type descriptor found or\n * NULL (that indicates end of list) encountered\n */\nstatic struct usb_descriptor_header**\nnext_desc(struct usb_descriptor_header **t, u8 desc_type)\n{\n\tfor (; *t; t++) {\n\t\tif ((*t)->bDescriptorType == desc_type)\n\t\t\treturn t;\n\t}\n\treturn NULL;\n}\n\n/*\n * for_each_desc() - iterate over desc_type descriptors in the\n * descriptors list\n * @start: pointer within descriptor array.\n * @iter_desc: desc_type descriptor to use as the loop cursor\n * @desc_type: wanted descriptr type\n */\n#define for_each_desc(start, iter_desc, desc_type) \\\n\tfor (iter_desc = next_desc(start, desc_type); \\\n\t     iter_desc; iter_desc = next_desc(iter_desc + 1, desc_type))\n\n/**\n * config_ep_by_speed_and_alt() - configures the given endpoint\n * according to gadget speed.\n * @g: pointer to the gadget\n * @f: usb function\n * @_ep: the endpoint to configure\n * @alt: alternate setting number\n *\n * Return: error code, 0 on success\n *\n * This function chooses the right descriptors for a given\n * endpoint according to gadget speed and saves it in the\n * endpoint desc field. If the endpoint already has a descriptor\n * assigned to it - overwrites it with currently corresponding\n * descriptor. The endpoint maxpacket field is updated according\n * to the chosen descriptor.\n * Note: the supplied function should hold all the descriptors\n * for supported speeds\n */\nint config_ep_by_speed_and_alt(struct usb_gadget *g,\n\t\t\t\tstruct usb_function *f,\n\t\t\t\tstruct usb_ep *_ep,\n\t\t\t\tu8 alt)\n{\n\tstruct usb_endpoint_descriptor *chosen_desc = NULL;\n\tstruct usb_interface_descriptor *int_desc = NULL;\n\tstruct usb_descriptor_header **speed_desc = NULL;\n\n\tstruct usb_ss_ep_comp_descriptor *comp_desc = NULL;\n\tint want_comp_desc = 0;\n\n\tstruct usb_descriptor_header **d_spd; /* cursor for speed desc */\n\tstruct usb_composite_dev *cdev;\n\tbool incomplete_desc = false;\n\n\tif (!g || !f || !_ep)\n\t\treturn -EIO;\n\n\t/* select desired speed */\n\tswitch (g->speed) {\n\tcase USB_SPEED_SUPER_PLUS:\n\t\tif (gadget_is_superspeed_plus(g)) {\n\t\t\tif (f->ssp_descriptors) {\n\t\t\t\tspeed_desc = f->ssp_descriptors;\n\t\t\t\twant_comp_desc = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tincomplete_desc = true;\n\t\t}\n\t\tfallthrough;\n\tcase USB_SPEED_SUPER:\n\t\tif (gadget_is_superspeed(g)) {\n\t\t\tif (f->ss_descriptors) {\n\t\t\t\tspeed_desc = f->ss_descriptors;\n\t\t\t\twant_comp_desc = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tincomplete_desc = true;\n\t\t}\n\t\tfallthrough;\n\tcase USB_SPEED_HIGH:\n\t\tif (gadget_is_dualspeed(g)) {\n\t\t\tif (f->hs_descriptors) {\n\t\t\t\tspeed_desc = f->hs_descriptors;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tincomplete_desc = true;\n\t\t}\n\t\tfallthrough;\n\tdefault:\n\t\tspeed_desc = f->fs_descriptors;\n\t}\n\n\tcdev = get_gadget_data(g);\n\tif (incomplete_desc)\n\t\tWARNING(cdev,\n\t\t\t\"%s doesn't hold the descriptors for current speed\\n\",\n\t\t\tf->name);\n\n\t/* find correct alternate setting descriptor */\n\tfor_each_desc(speed_desc, d_spd, USB_DT_INTERFACE) {\n\t\tint_desc = (struct usb_interface_descriptor *)*d_spd;\n\n\t\tif (int_desc->bAlternateSetting == alt) {\n\t\t\tspeed_desc = d_spd;\n\t\t\tgoto intf_found;\n\t\t}\n\t}\n\treturn -EIO;\n\nintf_found:\n\t/* find descriptors */\n\tfor_each_desc(speed_desc, d_spd, USB_DT_ENDPOINT) {\n\t\tchosen_desc = (struct usb_endpoint_descriptor *)*d_spd;\n\t\tif (chosen_desc->bEndpointAddress == _ep->address)\n\t\t\tgoto ep_found;\n\t}\n\treturn -EIO;\n\nep_found:\n\t/* commit results */\n\t_ep->maxpacket = usb_endpoint_maxp(chosen_desc);\n\t_ep->desc = chosen_desc;\n\t_ep->comp_desc = NULL;\n\t_ep->maxburst = 0;\n\t_ep->mult = 1;\n\n\tif (g->speed == USB_SPEED_HIGH && (usb_endpoint_xfer_isoc(_ep->desc) ||\n\t\t\t\tusb_endpoint_xfer_int(_ep->desc)))\n\t\t_ep->mult = usb_endpoint_maxp_mult(_ep->desc);\n\n\tif (!want_comp_desc)\n\t\treturn 0;\n\n\t/*\n\t * Companion descriptor should follow EP descriptor\n\t * USB 3.0 spec, #9.6.7\n\t */\n\tcomp_desc = (struct usb_ss_ep_comp_descriptor *)*(++d_spd);\n\tif (!comp_desc ||\n\t    (comp_desc->bDescriptorType != USB_DT_SS_ENDPOINT_COMP))\n\t\treturn -EIO;\n\t_ep->comp_desc = comp_desc;\n\tif (g->speed >= USB_SPEED_SUPER) {\n\t\tswitch (usb_endpoint_type(_ep->desc)) {\n\t\tcase USB_ENDPOINT_XFER_ISOC:\n\t\t\t/* mult: bits 1:0 of bmAttributes */\n\t\t\t_ep->mult = (comp_desc->bmAttributes & 0x3) + 1;\n\t\t\tfallthrough;\n\t\tcase USB_ENDPOINT_XFER_BULK:\n\t\tcase USB_ENDPOINT_XFER_INT:\n\t\t\t_ep->maxburst = comp_desc->bMaxBurst + 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (comp_desc->bMaxBurst != 0)\n\t\t\t\tERROR(cdev, \"ep0 bMaxBurst must be 0\\n\");\n\t\t\t_ep->maxburst = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(config_ep_by_speed_and_alt);\n\n/**\n * config_ep_by_speed() - configures the given endpoint\n * according to gadget speed.\n * @g: pointer to the gadget\n * @f: usb function\n * @_ep: the endpoint to configure\n *\n * Return: error code, 0 on success\n *\n * This function chooses the right descriptors for a given\n * endpoint according to gadget speed and saves it in the\n * endpoint desc field. If the endpoint already has a descriptor\n * assigned to it - overwrites it with currently corresponding\n * descriptor. The endpoint maxpacket field is updated according\n * to the chosen descriptor.\n * Note: the supplied function should hold all the descriptors\n * for supported speeds\n */\nint config_ep_by_speed(struct usb_gadget *g,\n\t\t\tstruct usb_function *f,\n\t\t\tstruct usb_ep *_ep)\n{\n\treturn config_ep_by_speed_and_alt(g, f, _ep, 0);\n}\nEXPORT_SYMBOL_GPL(config_ep_by_speed);\n\n/**\n * usb_add_function() - add a function to a configuration\n * @config: the configuration\n * @function: the function being added\n * Context: single threaded during gadget setup\n *\n * After initialization, each configuration must have one or more\n * functions added to it.  Adding a function involves calling its @bind()\n * method to allocate resources such as interface and string identifiers\n * and endpoints.\n *\n * This function returns the value of the function's bind(), which is\n * zero for success else a negative errno value.\n */\nint usb_add_function(struct usb_configuration *config,\n\t\tstruct usb_function *function)\n{\n\tint\tvalue = -EINVAL;\n\n\tDBG(config->cdev, \"adding '%s'/%p to config '%s'/%p\\n\",\n\t\t\tfunction->name, function,\n\t\t\tconfig->label, config);\n\n\tif (!function->set_alt || !function->disable)\n\t\tgoto done;\n\n\tfunction->config = config;\n\tlist_add_tail(&function->list, &config->functions);\n\n\tif (function->bind_deactivated) {\n\t\tvalue = usb_function_deactivate(function);\n\t\tif (value)\n\t\t\tgoto done;\n\t}\n\n\t/* REVISIT *require* function->bind? */\n\tif (function->bind) {\n\t\tvalue = function->bind(config, function);\n\t\tif (value < 0) {\n\t\t\tlist_del(&function->list);\n\t\t\tfunction->config = NULL;\n\t\t}\n\t} else\n\t\tvalue = 0;\n\n\t/* We allow configurations that don't work at both speeds.\n\t * If we run into a lowspeed Linux system, treat it the same\n\t * as full speed ... it's the function drivers that will need\n\t * to avoid bulk and ISO transfers.\n\t */\n\tif (!config->fullspeed && function->fs_descriptors)\n\t\tconfig->fullspeed = true;\n\tif (!config->highspeed && function->hs_descriptors)\n\t\tconfig->highspeed = true;\n\tif (!config->superspeed && function->ss_descriptors)\n\t\tconfig->superspeed = true;\n\tif (!config->superspeed_plus && function->ssp_descriptors)\n\t\tconfig->superspeed_plus = true;\n\ndone:\n\tif (value)\n\t\tDBG(config->cdev, \"adding '%s'/%p --> %d\\n\",\n\t\t\t\tfunction->name, function, value);\n\treturn value;\n}\nEXPORT_SYMBOL_GPL(usb_add_function);\n\nvoid usb_remove_function(struct usb_configuration *c, struct usb_function *f)\n{\n\tif (f->disable)\n\t\tf->disable(f);\n\n\tbitmap_zero(f->endpoints, 32);\n\tlist_del(&f->list);\n\tif (f->unbind)\n\t\tf->unbind(c, f);\n\n\tif (f->bind_deactivated)\n\t\tusb_function_activate(f);\n}\nEXPORT_SYMBOL_GPL(usb_remove_function);\n\n/**\n * usb_function_deactivate - prevent function and gadget enumeration\n * @function: the function that isn't yet ready to respond\n *\n * Blocks response of the gadget driver to host enumeration by\n * preventing the data line pullup from being activated.  This is\n * normally called during @bind() processing to change from the\n * initial \"ready to respond\" state, or when a required resource\n * becomes available.\n *\n * For example, drivers that serve as a passthrough to a userspace\n * daemon can block enumeration unless that daemon (such as an OBEX,\n * MTP, or print server) is ready to handle host requests.\n *\n * Not all systems support software control of their USB peripheral\n * data pullups.\n *\n * Returns zero on success, else negative errno.\n */\nint usb_function_deactivate(struct usb_function *function)\n{\n\tstruct usb_composite_dev\t*cdev = function->config->cdev;\n\tunsigned long\t\t\tflags;\n\tint\t\t\t\tstatus = 0;\n\n\tspin_lock_irqsave(&cdev->lock, flags);\n\n\tif (cdev->deactivations == 0) {\n\t\tspin_unlock_irqrestore(&cdev->lock, flags);\n\t\tstatus = usb_gadget_deactivate(cdev->gadget);\n\t\tspin_lock_irqsave(&cdev->lock, flags);\n\t}\n\tif (status == 0)\n\t\tcdev->deactivations++;\n\n\tspin_unlock_irqrestore(&cdev->lock, flags);\n\treturn status;\n}\nEXPORT_SYMBOL_GPL(usb_function_deactivate);\n\n/**\n * usb_function_activate - allow function and gadget enumeration\n * @function: function on which usb_function_activate() was called\n *\n * Reverses effect of usb_function_deactivate().  If no more functions\n * are delaying their activation, the gadget driver will respond to\n * host enumeration procedures.\n *\n * Returns zero on success, else negative errno.\n */\nint usb_function_activate(struct usb_function *function)\n{\n\tstruct usb_composite_dev\t*cdev = function->config->cdev;\n\tunsigned long\t\t\tflags;\n\tint\t\t\t\tstatus = 0;\n\n\tspin_lock_irqsave(&cdev->lock, flags);\n\n\tif (WARN_ON(cdev->deactivations == 0))\n\t\tstatus = -EINVAL;\n\telse {\n\t\tcdev->deactivations--;\n\t\tif (cdev->deactivations == 0) {\n\t\t\tspin_unlock_irqrestore(&cdev->lock, flags);\n\t\t\tstatus = usb_gadget_activate(cdev->gadget);\n\t\t\tspin_lock_irqsave(&cdev->lock, flags);\n\t\t}\n\t}\n\n\tspin_unlock_irqrestore(&cdev->lock, flags);\n\treturn status;\n}\nEXPORT_SYMBOL_GPL(usb_function_activate);\n\n/**\n * usb_interface_id() - allocate an unused interface ID\n * @config: configuration associated with the interface\n * @function: function handling the interface\n * Context: single threaded during gadget setup\n *\n * usb_interface_id() is called from usb_function.bind() callbacks to\n * allocate new interface IDs.  The function driver will then store that\n * ID in interface, association, CDC union, and other descriptors.  It\n * will also handle any control requests targeted at that interface,\n * particularly changing its altsetting via set_alt().  There may\n * also be class-specific or vendor-specific requests to handle.\n *\n * All interface identifier should be allocated using this routine, to\n * ensure that for example different functions don't wrongly assign\n * different meanings to the same identifier.  Note that since interface\n * identifiers are configuration-specific, functions used in more than\n * one configuration (or more than once in a given configuration) need\n * multiple versions of the relevant descriptors.\n *\n * Returns the interface ID which was allocated; or -ENODEV if no\n * more interface IDs can be allocated.\n */\nint usb_interface_id(struct usb_configuration *config,\n\t\tstruct usb_function *function)\n{\n\tunsigned id = config->next_interface_id;\n\n\tif (id < MAX_CONFIG_INTERFACES) {\n\t\tconfig->interface[id] = function;\n\t\tconfig->next_interface_id = id + 1;\n\t\treturn id;\n\t}\n\treturn -ENODEV;\n}\nEXPORT_SYMBOL_GPL(usb_interface_id);\n\nstatic u8 encode_bMaxPower(enum usb_device_speed speed,\n\t\tstruct usb_configuration *c)\n{\n\tunsigned val;\n\n\tif (c->MaxPower || (c->bmAttributes & USB_CONFIG_ATT_SELFPOWER))\n\t\tval = c->MaxPower;\n\telse\n\t\tval = CONFIG_USB_GADGET_VBUS_DRAW;\n\tif (!val)\n\t\treturn 0;\n\tif (speed < USB_SPEED_SUPER)\n\t\treturn min(val, 500U) / 2;\n\telse\n\t\t/*\n\t\t * USB 3.x supports up to 900mA, but since 900 isn't divisible\n\t\t * by 8 the integral division will effectively cap to 896mA.\n\t\t */\n\t\treturn min(val, 900U) / 8;\n}\n\nstatic int config_buf(struct usb_configuration *config,\n\t\tenum usb_device_speed speed, void *buf, u8 type)\n{\n\tstruct usb_config_descriptor\t*c = buf;\n\tvoid\t\t\t\t*next = buf + USB_DT_CONFIG_SIZE;\n\tint\t\t\t\tlen;\n\tstruct usb_function\t\t*f;\n\tint\t\t\t\tstatus;\n\n\tlen = USB_COMP_EP0_BUFSIZ - USB_DT_CONFIG_SIZE;\n\t/* write the config descriptor */\n\tc = buf;\n\tc->bLength = USB_DT_CONFIG_SIZE;\n\tc->bDescriptorType = type;\n\t/* wTotalLength is written later */\n\tc->bNumInterfaces = config->next_interface_id;\n\tc->bConfigurationValue = config->bConfigurationValue;\n\tc->iConfiguration = config->iConfiguration;\n\tc->bmAttributes = USB_CONFIG_ATT_ONE | config->bmAttributes;\n\tc->bMaxPower = encode_bMaxPower(speed, config);\n\n\t/* There may be e.g. OTG descriptors */\n\tif (config->descriptors) {\n\t\tstatus = usb_descriptor_fillbuf(next, len,\n\t\t\t\tconfig->descriptors);\n\t\tif (status < 0)\n\t\t\treturn status;\n\t\tlen -= status;\n\t\tnext += status;\n\t}\n\n\t/* add each function's descriptors */\n\tlist_for_each_entry(f, &config->functions, list) {\n\t\tstruct usb_descriptor_header **descriptors;\n\n\t\tdescriptors = function_descriptors(f, speed);\n\t\tif (!descriptors)\n\t\t\tcontinue;\n\t\tstatus = usb_descriptor_fillbuf(next, len,\n\t\t\t(const struct usb_descriptor_header **) descriptors);\n\t\tif (status < 0)\n\t\t\treturn status;\n\t\tlen -= status;\n\t\tnext += status;\n\t}\n\n\tlen = next - buf;\n\tc->wTotalLength = cpu_to_le16(len);\n\treturn len;\n}\n\nstatic int config_desc(struct usb_composite_dev *cdev, unsigned w_value)\n{\n\tstruct usb_gadget\t\t*gadget = cdev->gadget;\n\tstruct usb_configuration\t*c;\n\tstruct list_head\t\t*pos;\n\tu8\t\t\t\ttype = w_value >> 8;\n\tenum usb_device_speed\t\tspeed = USB_SPEED_UNKNOWN;\n\n\tif (gadget->speed >= USB_SPEED_SUPER)\n\t\tspeed = gadget->speed;\n\telse if (gadget_is_dualspeed(gadget)) {\n\t\tint\ths = 0;\n\t\tif (gadget->speed == USB_SPEED_HIGH)\n\t\t\ths = 1;\n\t\tif (type == USB_DT_OTHER_SPEED_CONFIG)\n\t\t\ths = !hs;\n\t\tif (hs)\n\t\t\tspeed = USB_SPEED_HIGH;\n\n\t}\n\n\t/* This is a lookup by config *INDEX* */\n\tw_value &= 0xff;\n\n\tpos = &cdev->configs;\n\tc = cdev->os_desc_config;\n\tif (c)\n\t\tgoto check_config;\n\n\twhile ((pos = pos->next) !=  &cdev->configs) {\n\t\tc = list_entry(pos, typeof(*c), list);\n\n\t\t/* skip OS Descriptors config which is handled separately */\n\t\tif (c == cdev->os_desc_config)\n\t\t\tcontinue;\n\ncheck_config:\n\t\t/* ignore configs that won't work at this speed */\n\t\tswitch (speed) {\n\t\tcase USB_SPEED_SUPER_PLUS:\n\t\t\tif (!c->superspeed_plus)\n\t\t\t\tcontinue;\n\t\t\tbreak;\n\t\tcase USB_SPEED_SUPER:\n\t\t\tif (!c->superspeed)\n\t\t\t\tcontinue;\n\t\t\tbreak;\n\t\tcase USB_SPEED_HIGH:\n\t\t\tif (!c->highspeed)\n\t\t\t\tcontinue;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (!c->fullspeed)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tif (w_value == 0)\n\t\t\treturn config_buf(c, speed, cdev->req->buf, type);\n\t\tw_value--;\n\t}\n\treturn -EINVAL;\n}\n\nstatic int count_configs(struct usb_composite_dev *cdev, unsigned type)\n{\n\tstruct usb_gadget\t\t*gadget = cdev->gadget;\n\tstruct usb_configuration\t*c;\n\tunsigned\t\t\tcount = 0;\n\tint\t\t\t\ths = 0;\n\tint\t\t\t\tss = 0;\n\tint\t\t\t\tssp = 0;\n\n\tif (gadget_is_dualspeed(gadget)) {\n\t\tif (gadget->speed == USB_SPEED_HIGH)\n\t\t\ths = 1;\n\t\tif (gadget->speed == USB_SPEED_SUPER)\n\t\t\tss = 1;\n\t\tif (gadget->speed == USB_SPEED_SUPER_PLUS)\n\t\t\tssp = 1;\n\t\tif (type == USB_DT_DEVICE_QUALIFIER)\n\t\t\ths = !hs;\n\t}\n\tlist_for_each_entry(c, &cdev->configs, list) {\n\t\t/* ignore configs that won't work at this speed */\n\t\tif (ssp) {\n\t\t\tif (!c->superspeed_plus)\n\t\t\t\tcontinue;\n\t\t} else if (ss) {\n\t\t\tif (!c->superspeed)\n\t\t\t\tcontinue;\n\t\t} else if (hs) {\n\t\t\tif (!c->highspeed)\n\t\t\t\tcontinue;\n\t\t} else {\n\t\t\tif (!c->fullspeed)\n\t\t\t\tcontinue;\n\t\t}\n\t\tcount++;\n\t}\n\treturn count;\n}\n\n/**\n * bos_desc() - prepares the BOS descriptor.\n * @cdev: pointer to usb_composite device to generate the bos\n *\tdescriptor for\n *\n * This function generates the BOS (Binary Device Object)\n * descriptor and its device capabilities descriptors. The BOS\n * descriptor should be supported by a SuperSpeed device.\n */\nstatic int bos_desc(struct usb_composite_dev *cdev)\n{\n\tstruct usb_ext_cap_descriptor\t*usb_ext;\n\tstruct usb_dcd_config_params\tdcd_config_params;\n\tstruct usb_bos_descriptor\t*bos = cdev->req->buf;\n\tunsigned int\t\t\tbesl = 0;\n\n\tbos->bLength = USB_DT_BOS_SIZE;\n\tbos->bDescriptorType = USB_DT_BOS;\n\n\tbos->wTotalLength = cpu_to_le16(USB_DT_BOS_SIZE);\n\tbos->bNumDeviceCaps = 0;\n\n\t/* Get Controller configuration */\n\tif (cdev->gadget->ops->get_config_params) {\n\t\tcdev->gadget->ops->get_config_params(cdev->gadget,\n\t\t\t\t\t\t     &dcd_config_params);\n\t} else {\n\t\tdcd_config_params.besl_baseline =\n\t\t\tUSB_DEFAULT_BESL_UNSPECIFIED;\n\t\tdcd_config_params.besl_deep =\n\t\t\tUSB_DEFAULT_BESL_UNSPECIFIED;\n\t\tdcd_config_params.bU1devExitLat =\n\t\t\tUSB_DEFAULT_U1_DEV_EXIT_LAT;\n\t\tdcd_config_params.bU2DevExitLat =\n\t\t\tcpu_to_le16(USB_DEFAULT_U2_DEV_EXIT_LAT);\n\t}\n\n\tif (dcd_config_params.besl_baseline != USB_DEFAULT_BESL_UNSPECIFIED)\n\t\tbesl = USB_BESL_BASELINE_VALID |\n\t\t\tUSB_SET_BESL_BASELINE(dcd_config_params.besl_baseline);\n\n\tif (dcd_config_params.besl_deep != USB_DEFAULT_BESL_UNSPECIFIED)\n\t\tbesl |= USB_BESL_DEEP_VALID |\n\t\t\tUSB_SET_BESL_DEEP(dcd_config_params.besl_deep);\n\n\t/*\n\t * A SuperSpeed device shall include the USB2.0 extension descriptor\n\t * and shall support LPM when operating in USB2.0 HS mode.\n\t */\n\tusb_ext = cdev->req->buf + le16_to_cpu(bos->wTotalLength);\n\tbos->bNumDeviceCaps++;\n\tle16_add_cpu(&bos->wTotalLength, USB_DT_USB_EXT_CAP_SIZE);\n\tusb_ext->bLength = USB_DT_USB_EXT_CAP_SIZE;\n\tusb_ext->bDescriptorType = USB_DT_DEVICE_CAPABILITY;\n\tusb_ext->bDevCapabilityType = USB_CAP_TYPE_EXT;\n\tusb_ext->bmAttributes = cpu_to_le32(USB_LPM_SUPPORT |\n\t\t\t\t\t    USB_BESL_SUPPORT | besl);\n\n\t/*\n\t * The Superspeed USB Capability descriptor shall be implemented by all\n\t * SuperSpeed devices.\n\t */\n\tif (gadget_is_superspeed(cdev->gadget)) {\n\t\tstruct usb_ss_cap_descriptor *ss_cap;\n\n\t\tss_cap = cdev->req->buf + le16_to_cpu(bos->wTotalLength);\n\t\tbos->bNumDeviceCaps++;\n\t\tle16_add_cpu(&bos->wTotalLength, USB_DT_USB_SS_CAP_SIZE);\n\t\tss_cap->bLength = USB_DT_USB_SS_CAP_SIZE;\n\t\tss_cap->bDescriptorType = USB_DT_DEVICE_CAPABILITY;\n\t\tss_cap->bDevCapabilityType = USB_SS_CAP_TYPE;\n\t\tss_cap->bmAttributes = 0; /* LTM is not supported yet */\n\t\tss_cap->wSpeedSupported = cpu_to_le16(USB_LOW_SPEED_OPERATION |\n\t\t\t\t\t\t      USB_FULL_SPEED_OPERATION |\n\t\t\t\t\t\t      USB_HIGH_SPEED_OPERATION |\n\t\t\t\t\t\t      USB_5GBPS_OPERATION);\n\t\tss_cap->bFunctionalitySupport = USB_LOW_SPEED_OPERATION;\n\t\tss_cap->bU1devExitLat = dcd_config_params.bU1devExitLat;\n\t\tss_cap->bU2DevExitLat = dcd_config_params.bU2DevExitLat;\n\t}\n\n\t/* The SuperSpeedPlus USB Device Capability descriptor */\n\tif (gadget_is_superspeed_plus(cdev->gadget)) {\n\t\tstruct usb_ssp_cap_descriptor *ssp_cap;\n\t\tu8 ssac = 1;\n\t\tu8 ssic;\n\t\tint i;\n\n\t\tif (cdev->gadget->max_ssp_rate == USB_SSP_GEN_2x2)\n\t\t\tssac = 3;\n\n\t\t/*\n\t\t * Paired RX and TX sublink speed attributes share\n\t\t * the same SSID.\n\t\t */\n\t\tssic = (ssac + 1) / 2 - 1;\n\n\t\tssp_cap = cdev->req->buf + le16_to_cpu(bos->wTotalLength);\n\t\tbos->bNumDeviceCaps++;\n\n\t\tle16_add_cpu(&bos->wTotalLength, USB_DT_USB_SSP_CAP_SIZE(ssac));\n\t\tssp_cap->bLength = USB_DT_USB_SSP_CAP_SIZE(ssac);\n\t\tssp_cap->bDescriptorType = USB_DT_DEVICE_CAPABILITY;\n\t\tssp_cap->bDevCapabilityType = USB_SSP_CAP_TYPE;\n\t\tssp_cap->bReserved = 0;\n\t\tssp_cap->wReserved = 0;\n\n\t\tssp_cap->bmAttributes =\n\t\t\tcpu_to_le32(FIELD_PREP(USB_SSP_SUBLINK_SPEED_ATTRIBS, ssac) |\n\t\t\t\t    FIELD_PREP(USB_SSP_SUBLINK_SPEED_IDS, ssic));\n\n\t\tssp_cap->wFunctionalitySupport =\n\t\t\tcpu_to_le16(FIELD_PREP(USB_SSP_MIN_SUBLINK_SPEED_ATTRIBUTE_ID, 0) |\n\t\t\t\t    FIELD_PREP(USB_SSP_MIN_RX_LANE_COUNT, 1) |\n\t\t\t\t    FIELD_PREP(USB_SSP_MIN_TX_LANE_COUNT, 1));\n\n\t\t/*\n\t\t * Use 1 SSID if the gadget supports up to gen2x1 or not\n\t\t * specified:\n\t\t * - SSID 0 for symmetric RX/TX sublink speed of 10 Gbps.\n\t\t *\n\t\t * Use 1 SSID if the gadget supports up to gen1x2:\n\t\t * - SSID 0 for symmetric RX/TX sublink speed of 5 Gbps.\n\t\t *\n\t\t * Use 2 SSIDs if the gadget supports up to gen2x2:\n\t\t * - SSID 0 for symmetric RX/TX sublink speed of 5 Gbps.\n\t\t * - SSID 1 for symmetric RX/TX sublink speed of 10 Gbps.\n\t\t */\n\t\tfor (i = 0; i < ssac + 1; i++) {\n\t\t\tu8 ssid;\n\t\t\tu8 mantissa;\n\t\t\tu8 type;\n\n\t\t\tssid = i >> 1;\n\n\t\t\tif (cdev->gadget->max_ssp_rate == USB_SSP_GEN_2x1 ||\n\t\t\t    cdev->gadget->max_ssp_rate == USB_SSP_GEN_UNKNOWN)\n\t\t\t\tmantissa = 10;\n\t\t\telse\n\t\t\t\tmantissa = 5 << ssid;\n\n\t\t\tif (i % 2)\n\t\t\t\ttype = USB_SSP_SUBLINK_SPEED_ST_SYM_TX;\n\t\t\telse\n\t\t\t\ttype = USB_SSP_SUBLINK_SPEED_ST_SYM_RX;\n\n\t\t\tssp_cap->bmSublinkSpeedAttr[i] =\n\t\t\t\tcpu_to_le32(FIELD_PREP(USB_SSP_SUBLINK_SPEED_SSID, ssid) |\n\t\t\t\t\t    FIELD_PREP(USB_SSP_SUBLINK_SPEED_LSE,\n\t\t\t\t\t\t       USB_SSP_SUBLINK_SPEED_LSE_GBPS) |\n\t\t\t\t\t    FIELD_PREP(USB_SSP_SUBLINK_SPEED_ST, type) |\n\t\t\t\t\t    FIELD_PREP(USB_SSP_SUBLINK_SPEED_LP,\n\t\t\t\t\t\t       USB_SSP_SUBLINK_SPEED_LP_SSP) |\n\t\t\t\t\t    FIELD_PREP(USB_SSP_SUBLINK_SPEED_LSM, mantissa));\n\t\t}\n\t}\n\n\treturn le16_to_cpu(bos->wTotalLength);\n}\n\nstatic void device_qual(struct usb_composite_dev *cdev)\n{\n\tstruct usb_qualifier_descriptor\t*qual = cdev->req->buf;\n\n\tqual->bLength = sizeof(*qual);\n\tqual->bDescriptorType = USB_DT_DEVICE_QUALIFIER;\n\t/* POLICY: same bcdUSB and device type info at both speeds */\n\tqual->bcdUSB = cdev->desc.bcdUSB;\n\tqual->bDeviceClass = cdev->desc.bDeviceClass;\n\tqual->bDeviceSubClass = cdev->desc.bDeviceSubClass;\n\tqual->bDeviceProtocol = cdev->desc.bDeviceProtocol;\n\t/* ASSUME same EP0 fifo size at both speeds */\n\tqual->bMaxPacketSize0 = cdev->gadget->ep0->maxpacket;\n\tqual->bNumConfigurations = count_configs(cdev, USB_DT_DEVICE_QUALIFIER);\n\tqual->bRESERVED = 0;\n}\n\n/*-------------------------------------------------------------------------*/\n\nstatic void reset_config(struct usb_composite_dev *cdev)\n{\n\tstruct usb_function\t\t*f;\n\n\tDBG(cdev, \"reset config\\n\");\n\n\tlist_for_each_entry(f, &cdev->config->functions, list) {\n\t\tif (f->disable)\n\t\t\tf->disable(f);\n\n\t\tbitmap_zero(f->endpoints, 32);\n\t}\n\tcdev->config = NULL;\n\tcdev->delayed_status = 0;\n}\n\nstatic int set_config(struct usb_composite_dev *cdev,\n\t\tconst struct usb_ctrlrequest *ctrl, unsigned number)\n{\n\tstruct usb_gadget\t*gadget = cdev->gadget;\n\tstruct usb_configuration *c = NULL;\n\tint\t\t\tresult = -EINVAL;\n\tunsigned\t\tpower = gadget_is_otg(gadget) ? 8 : 100;\n\tint\t\t\ttmp;\n\n\tif (number) {\n\t\tlist_for_each_entry(c, &cdev->configs, list) {\n\t\t\tif (c->bConfigurationValue == number) {\n\t\t\t\t/*\n\t\t\t\t * We disable the FDs of the previous\n\t\t\t\t * configuration only if the new configuration\n\t\t\t\t * is a valid one\n\t\t\t\t */\n\t\t\t\tif (cdev->config)\n\t\t\t\t\treset_config(cdev);\n\t\t\t\tresult = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (result < 0)\n\t\t\tgoto done;\n\t} else { /* Zero configuration value - need to reset the config */\n\t\tif (cdev->config)\n\t\t\treset_config(cdev);\n\t\tresult = 0;\n\t}\n\n\tDBG(cdev, \"%s config #%d: %s\\n\",\n\t    usb_speed_string(gadget->speed),\n\t    number, c ? c->label : \"unconfigured\");\n\n\tif (!c)\n\t\tgoto done;\n\n\tusb_gadget_set_state(gadget, USB_STATE_CONFIGURED);\n\tcdev->config = c;\n\n\t/* Initialize all interfaces by setting them to altsetting zero. */\n\tfor (tmp = 0; tmp < MAX_CONFIG_INTERFACES; tmp++) {\n\t\tstruct usb_function\t*f = c->interface[tmp];\n\t\tstruct usb_descriptor_header **descriptors;\n\n\t\tif (!f)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Record which endpoints are used by the function. This is used\n\t\t * to dispatch control requests targeted at that endpoint to the\n\t\t * function's setup callback instead of the current\n\t\t * configuration's setup callback.\n\t\t */\n\t\tdescriptors = function_descriptors(f, gadget->speed);\n\n\t\tfor (; *descriptors; ++descriptors) {\n\t\t\tstruct usb_endpoint_descriptor *ep;\n\t\t\tint addr;\n\n\t\t\tif ((*descriptors)->bDescriptorType != USB_DT_ENDPOINT)\n\t\t\t\tcontinue;\n\n\t\t\tep = (struct usb_endpoint_descriptor *)*descriptors;\n\t\t\taddr = ((ep->bEndpointAddress & 0x80) >> 3)\n\t\t\t     |  (ep->bEndpointAddress & 0x0f);\n\t\t\tset_bit(addr, f->endpoints);\n\t\t}\n\n\t\tresult = f->set_alt(f, tmp, 0);\n\t\tif (result < 0) {\n\t\t\tDBG(cdev, \"interface %d (%s/%p) alt 0 --> %d\\n\",\n\t\t\t\t\ttmp, f->name, f, result);\n\n\t\t\treset_config(cdev);\n\t\t\tgoto done;\n\t\t}\n\n\t\tif (result == USB_GADGET_DELAYED_STATUS) {\n\t\t\tDBG(cdev,\n\t\t\t \"%s: interface %d (%s) requested delayed status\\n\",\n\t\t\t\t\t__func__, tmp, f->name);\n\t\t\tcdev->delayed_status++;\n\t\t\tDBG(cdev, \"delayed_status count %d\\n\",\n\t\t\t\t\tcdev->delayed_status);\n\t\t}\n\t}\n\n\t/* when we return, be sure our power usage is valid */\n\tif (c->MaxPower || (c->bmAttributes & USB_CONFIG_ATT_SELFPOWER))\n\t\tpower = c->MaxPower;\n\telse\n\t\tpower = CONFIG_USB_GADGET_VBUS_DRAW;\n\n\tif (gadget->speed < USB_SPEED_SUPER)\n\t\tpower = min(power, 500U);\n\telse\n\t\tpower = min(power, 900U);\ndone:\n\tif (power <= USB_SELF_POWER_VBUS_MAX_DRAW)\n\t\tusb_gadget_set_selfpowered(gadget);\n\telse\n\t\tusb_gadget_clear_selfpowered(gadget);\n\n\tusb_gadget_vbus_draw(gadget, power);\n\tif (result >= 0 && cdev->delayed_status)\n\t\tresult = USB_GADGET_DELAYED_STATUS;\n\treturn result;\n}\n\nint usb_add_config_only(struct usb_composite_dev *cdev,\n\t\tstruct usb_configuration *config)\n{\n\tstruct usb_configuration *c;\n\n\tif (!config->bConfigurationValue)\n\t\treturn -EINVAL;\n\n\t/* Prevent duplicate configuration identifiers */\n\tlist_for_each_entry(c, &cdev->configs, list) {\n\t\tif (c->bConfigurationValue == config->bConfigurationValue)\n\t\t\treturn -EBUSY;\n\t}\n\n\tconfig->cdev = cdev;\n\tlist_add_tail(&config->list, &cdev->configs);\n\n\tINIT_LIST_HEAD(&config->functions);\n\tconfig->next_interface_id = 0;\n\tmemset(config->interface, 0, sizeof(config->interface));\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(usb_add_config_only);\n\n/**\n * usb_add_config() - add a configuration to a device.\n * @cdev: wraps the USB gadget\n * @config: the configuration, with bConfigurationValue assigned\n * @bind: the configuration's bind function\n * Context: single threaded during gadget setup\n *\n * One of the main tasks of a composite @bind() routine is to\n * add each of the configurations it supports, using this routine.\n *\n * This function returns the value of the configuration's @bind(), which\n * is zero for success else a negative errno value.  Binding configurations\n * assigns global resources including string IDs, and per-configuration\n * resources such as interface IDs and endpoints.\n */\nint usb_add_config(struct usb_composite_dev *cdev,\n\t\tstruct usb_configuration *config,\n\t\tint (*bind)(struct usb_configuration *))\n{\n\tint\t\t\t\tstatus = -EINVAL;\n\n\tif (!bind)\n\t\tgoto done;\n\n\tDBG(cdev, \"adding config #%u '%s'/%p\\n\",\n\t\t\tconfig->bConfigurationValue,\n\t\t\tconfig->label, config);\n\n\tstatus = usb_add_config_only(cdev, config);\n\tif (status)\n\t\tgoto done;\n\n\tstatus = bind(config);\n\tif (status < 0) {\n\t\twhile (!list_empty(&config->functions)) {\n\t\t\tstruct usb_function\t\t*f;\n\n\t\t\tf = list_first_entry(&config->functions,\n\t\t\t\t\tstruct usb_function, list);\n\t\t\tlist_del(&f->list);\n\t\t\tif (f->unbind) {\n\t\t\t\tDBG(cdev, \"unbind function '%s'/%p\\n\",\n\t\t\t\t\tf->name, f);\n\t\t\t\tf->unbind(config, f);\n\t\t\t\t/* may free memory for \"f\" */\n\t\t\t}\n\t\t}\n\t\tlist_del(&config->list);\n\t\tconfig->cdev = NULL;\n\t} else {\n\t\tunsigned\ti;\n\n\t\tDBG(cdev, \"cfg %d/%p speeds:%s%s%s%s\\n\",\n\t\t\tconfig->bConfigurationValue, config,\n\t\t\tconfig->superspeed_plus ? \" superplus\" : \"\",\n\t\t\tconfig->superspeed ? \" super\" : \"\",\n\t\t\tconfig->highspeed ? \" high\" : \"\",\n\t\t\tconfig->fullspeed\n\t\t\t\t? (gadget_is_dualspeed(cdev->gadget)\n\t\t\t\t\t? \" full\"\n\t\t\t\t\t: \" full/low\")\n\t\t\t\t: \"\");\n\n\t\tfor (i = 0; i < MAX_CONFIG_INTERFACES; i++) {\n\t\t\tstruct usb_function\t*f = config->interface[i];\n\n\t\t\tif (!f)\n\t\t\t\tcontinue;\n\t\t\tDBG(cdev, \"  interface %d = %s/%p\\n\",\n\t\t\t\ti, f->name, f);\n\t\t}\n\t}\n\n\t/* set_alt(), or next bind(), sets up ep->claimed as needed */\n\tusb_ep_autoconfig_reset(cdev->gadget);\n\ndone:\n\tif (status)\n\t\tDBG(cdev, \"added config '%s'/%u --> %d\\n\", config->label,\n\t\t\t\tconfig->bConfigurationValue, status);\n\treturn status;\n}\nEXPORT_SYMBOL_GPL(usb_add_config);\n\nstatic void remove_config(struct usb_composite_dev *cdev,\n\t\t\t      struct usb_configuration *config)\n{\n\twhile (!list_empty(&config->functions)) {\n\t\tstruct usb_function\t\t*f;\n\n\t\tf = list_first_entry(&config->functions,\n\t\t\t\tstruct usb_function, list);\n\n\t\tusb_remove_function(config, f);\n\t}\n\tlist_del(&config->list);\n\tif (config->unbind) {\n\t\tDBG(cdev, \"unbind config '%s'/%p\\n\", config->label, config);\n\t\tconfig->unbind(config);\n\t\t\t/* may free memory for \"c\" */\n\t}\n}\n\n/**\n * usb_remove_config() - remove a configuration from a device.\n * @cdev: wraps the USB gadget\n * @config: the configuration\n *\n * Drivers must call usb_gadget_disconnect before calling this function\n * to disconnect the device from the host and make sure the host will not\n * try to enumerate the device while we are changing the config list.\n */\nvoid usb_remove_config(struct usb_composite_dev *cdev,\n\t\t      struct usb_configuration *config)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&cdev->lock, flags);\n\n\tif (cdev->config == config)\n\t\treset_config(cdev);\n\n\tspin_unlock_irqrestore(&cdev->lock, flags);\n\n\tremove_config(cdev, config);\n}\n\n/*-------------------------------------------------------------------------*/\n\n/* We support strings in multiple languages ... string descriptor zero\n * says which languages are supported.  The typical case will be that\n * only one language (probably English) is used, with i18n handled on\n * the host side.\n */\n\nstatic void collect_langs(struct usb_gadget_strings **sp, __le16 *buf)\n{\n\tconst struct usb_gadget_strings\t*s;\n\t__le16\t\t\t\tlanguage;\n\t__le16\t\t\t\t*tmp;\n\n\twhile (*sp) {\n\t\ts = *sp;\n\t\tlanguage = cpu_to_le16(s->language);\n\t\tfor (tmp = buf; *tmp && tmp < &buf[USB_MAX_STRING_LEN]; tmp++) {\n\t\t\tif (*tmp == language)\n\t\t\t\tgoto repeat;\n\t\t}\n\t\t*tmp++ = language;\nrepeat:\n\t\tsp++;\n\t}\n}\n\nstatic int lookup_string(\n\tstruct usb_gadget_strings\t**sp,\n\tvoid\t\t\t\t*buf,\n\tu16\t\t\t\tlanguage,\n\tint\t\t\t\tid\n)\n{\n\tstruct usb_gadget_strings\t*s;\n\tint\t\t\t\tvalue;\n\n\twhile (*sp) {\n\t\ts = *sp++;\n\t\tif (s->language != language)\n\t\t\tcontinue;\n\t\tvalue = usb_gadget_get_string(s, id, buf);\n\t\tif (value > 0)\n\t\t\treturn value;\n\t}\n\treturn -EINVAL;\n}\n\nstatic int get_string(struct usb_composite_dev *cdev,\n\t\tvoid *buf, u16 language, int id)\n{\n\tstruct usb_composite_driver\t*composite = cdev->driver;\n\tstruct usb_gadget_string_container *uc;\n\tstruct usb_configuration\t*c;\n\tstruct usb_function\t\t*f;\n\tint\t\t\t\tlen;\n\n\t/* Yes, not only is USB's i18n support probably more than most\n\t * folk will ever care about ... also, it's all supported here.\n\t * (Except for UTF8 support for Unicode's \"Astral Planes\".)\n\t */\n\n\t/* 0 == report all available language codes */\n\tif (id == 0) {\n\t\tstruct usb_string_descriptor\t*s = buf;\n\t\tstruct usb_gadget_strings\t**sp;\n\n\t\tmemset(s, 0, 256);\n\t\ts->bDescriptorType = USB_DT_STRING;\n\n\t\tsp = composite->strings;\n\t\tif (sp)\n\t\t\tcollect_langs(sp, s->wData);\n\n\t\tlist_for_each_entry(c, &cdev->configs, list) {\n\t\t\tsp = c->strings;\n\t\t\tif (sp)\n\t\t\t\tcollect_langs(sp, s->wData);\n\n\t\t\tlist_for_each_entry(f, &c->functions, list) {\n\t\t\t\tsp = f->strings;\n\t\t\t\tif (sp)\n\t\t\t\t\tcollect_langs(sp, s->wData);\n\t\t\t}\n\t\t}\n\t\tlist_for_each_entry(uc, &cdev->gstrings, list) {\n\t\t\tstruct usb_gadget_strings **sp;\n\n\t\t\tsp = get_containers_gs(uc);\n\t\t\tcollect_langs(sp, s->wData);\n\t\t}\n\n\t\tfor (len = 0; len <= USB_MAX_STRING_LEN && s->wData[len]; len++)\n\t\t\tcontinue;\n\t\tif (!len)\n\t\t\treturn -EINVAL;\n\n\t\ts->bLength = 2 * (len + 1);\n\t\treturn s->bLength;\n\t}\n\n\tif (cdev->use_os_string && language == 0 && id == OS_STRING_IDX) {\n\t\tstruct usb_os_string *b = buf;\n\t\tb->bLength = sizeof(*b);\n\t\tb->bDescriptorType = USB_DT_STRING;\n\t\tcompiletime_assert(\n\t\t\tsizeof(b->qwSignature) == sizeof(cdev->qw_sign),\n\t\t\t\"qwSignature size must be equal to qw_sign\");\n\t\tmemcpy(&b->qwSignature, cdev->qw_sign, sizeof(b->qwSignature));\n\t\tb->bMS_VendorCode = cdev->b_vendor_code;\n\t\tb->bPad = 0;\n\t\treturn sizeof(*b);\n\t}\n\n\tlist_for_each_entry(uc, &cdev->gstrings, list) {\n\t\tstruct usb_gadget_strings **sp;\n\n\t\tsp = get_containers_gs(uc);\n\t\tlen = lookup_string(sp, buf, language, id);\n\t\tif (len > 0)\n\t\t\treturn len;\n\t}\n\n\t/* String IDs are device-scoped, so we look up each string\n\t * table we're told about.  These lookups are infrequent;\n\t * simpler-is-better here.\n\t */\n\tif (composite->strings) {\n\t\tlen = lookup_string(composite->strings, buf, language, id);\n\t\tif (len > 0)\n\t\t\treturn len;\n\t}\n\tlist_for_each_entry(c, &cdev->configs, list) {\n\t\tif (c->strings) {\n\t\t\tlen = lookup_string(c->strings, buf, language, id);\n\t\t\tif (len > 0)\n\t\t\t\treturn len;\n\t\t}\n\t\tlist_for_each_entry(f, &c->functions, list) {\n\t\t\tif (!f->strings)\n\t\t\t\tcontinue;\n\t\t\tlen = lookup_string(f->strings, buf, language, id);\n\t\t\tif (len > 0)\n\t\t\t\treturn len;\n\t\t}\n\t}\n\treturn -EINVAL;\n}\n\n/**\n * usb_string_id() - allocate an unused string ID\n * @cdev: the device whose string descriptor IDs are being allocated\n * Context: single threaded during gadget setup\n *\n * @usb_string_id() is called from bind() callbacks to allocate\n * string IDs.  Drivers for functions, configurations, or gadgets will\n * then store that ID in the appropriate descriptors and string table.\n *\n * All string identifier should be allocated using this,\n * @usb_string_ids_tab() or @usb_string_ids_n() routine, to ensure\n * that for example different functions don't wrongly assign different\n * meanings to the same identifier.\n */\nint usb_string_id(struct usb_composite_dev *cdev)\n{\n\tif (cdev->next_string_id < 254) {\n\t\t/* string id 0 is reserved by USB spec for list of\n\t\t * supported languages */\n\t\t/* 255 reserved as well? -- mina86 */\n\t\tcdev->next_string_id++;\n\t\treturn cdev->next_string_id;\n\t}\n\treturn -ENODEV;\n}\nEXPORT_SYMBOL_GPL(usb_string_id);\n\n/**\n * usb_string_ids_tab() - allocate unused string IDs in batch\n * @cdev: the device whose string descriptor IDs are being allocated\n * @str: an array of usb_string objects to assign numbers to\n * Context: single threaded during gadget setup\n *\n * @usb_string_ids() is called from bind() callbacks to allocate\n * string IDs.  Drivers for functions, configurations, or gadgets will\n * then copy IDs from the string table to the appropriate descriptors\n * and string table for other languages.\n *\n * All string identifier should be allocated using this,\n * @usb_string_id() or @usb_string_ids_n() routine, to ensure that for\n * example different functions don't wrongly assign different meanings\n * to the same identifier.\n */\nint usb_string_ids_tab(struct usb_composite_dev *cdev, struct usb_string *str)\n{\n\tint next = cdev->next_string_id;\n\n\tfor (; str->s; ++str) {\n\t\tif (unlikely(next >= 254))\n\t\t\treturn -ENODEV;\n\t\tstr->id = ++next;\n\t}\n\n\tcdev->next_string_id = next;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(usb_string_ids_tab);\n\nstatic struct usb_gadget_string_container *copy_gadget_strings(\n\t\tstruct usb_gadget_strings **sp, unsigned n_gstrings,\n\t\tunsigned n_strings)\n{\n\tstruct usb_gadget_string_container *uc;\n\tstruct usb_gadget_strings **gs_array;\n\tstruct usb_gadget_strings *gs;\n\tstruct usb_string *s;\n\tunsigned mem;\n\tunsigned n_gs;\n\tunsigned n_s;\n\tvoid *stash;\n\n\tmem = sizeof(*uc);\n\tmem += sizeof(void *) * (n_gstrings + 1);\n\tmem += sizeof(struct usb_gadget_strings) * n_gstrings;\n\tmem += sizeof(struct usb_string) * (n_strings + 1) * (n_gstrings);\n\tuc = kmalloc(mem, GFP_KERNEL);\n\tif (!uc)\n\t\treturn ERR_PTR(-ENOMEM);\n\tgs_array = get_containers_gs(uc);\n\tstash = uc->stash;\n\tstash += sizeof(void *) * (n_gstrings + 1);\n\tfor (n_gs = 0; n_gs < n_gstrings; n_gs++) {\n\t\tstruct usb_string *org_s;\n\n\t\tgs_array[n_gs] = stash;\n\t\tgs = gs_array[n_gs];\n\t\tstash += sizeof(struct usb_gadget_strings);\n\t\tgs->language = sp[n_gs]->language;\n\t\tgs->strings = stash;\n\t\torg_s = sp[n_gs]->strings;\n\n\t\tfor (n_s = 0; n_s < n_strings; n_s++) {\n\t\t\ts = stash;\n\t\t\tstash += sizeof(struct usb_string);\n\t\t\tif (org_s->s)\n\t\t\t\ts->s = org_s->s;\n\t\t\telse\n\t\t\t\ts->s = \"\";\n\t\t\torg_s++;\n\t\t}\n\t\ts = stash;\n\t\ts->s = NULL;\n\t\tstash += sizeof(struct usb_string);\n\n\t}\n\tgs_array[n_gs] = NULL;\n\treturn uc;\n}\n\n/**\n * usb_gstrings_attach() - attach gadget strings to a cdev and assign ids\n * @cdev: the device whose string descriptor IDs are being allocated\n * and attached.\n * @sp: an array of usb_gadget_strings to attach.\n * @n_strings: number of entries in each usb_strings array (sp[]->strings)\n *\n * This function will create a deep copy of usb_gadget_strings and usb_string\n * and attach it to the cdev. The actual string (usb_string.s) will not be\n * copied but only a referenced will be made. The struct usb_gadget_strings\n * array may contain multiple languages and should be NULL terminated.\n * The ->language pointer of each struct usb_gadget_strings has to contain the\n * same amount of entries.\n * For instance: sp[0] is en-US, sp[1] is es-ES. It is expected that the first\n * usb_string entry of es-ES contains the translation of the first usb_string\n * entry of en-US. Therefore both entries become the same id assign.\n */\nstruct usb_string *usb_gstrings_attach(struct usb_composite_dev *cdev,\n\t\tstruct usb_gadget_strings **sp, unsigned n_strings)\n{\n\tstruct usb_gadget_string_container *uc;\n\tstruct usb_gadget_strings **n_gs;\n\tunsigned n_gstrings = 0;\n\tunsigned i;\n\tint ret;\n\n\tfor (i = 0; sp[i]; i++)\n\t\tn_gstrings++;\n\n\tif (!n_gstrings)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tuc = copy_gadget_strings(sp, n_gstrings, n_strings);\n\tif (IS_ERR(uc))\n\t\treturn ERR_CAST(uc);\n\n\tn_gs = get_containers_gs(uc);\n\tret = usb_string_ids_tab(cdev, n_gs[0]->strings);\n\tif (ret)\n\t\tgoto err;\n\n\tfor (i = 1; i < n_gstrings; i++) {\n\t\tstruct usb_string *m_s;\n\t\tstruct usb_string *s;\n\t\tunsigned n;\n\n\t\tm_s = n_gs[0]->strings;\n\t\ts = n_gs[i]->strings;\n\t\tfor (n = 0; n < n_strings; n++) {\n\t\t\ts->id = m_s->id;\n\t\t\ts++;\n\t\t\tm_s++;\n\t\t}\n\t}\n\tlist_add_tail(&uc->list, &cdev->gstrings);\n\treturn n_gs[0]->strings;\nerr:\n\tkfree(uc);\n\treturn ERR_PTR(ret);\n}\nEXPORT_SYMBOL_GPL(usb_gstrings_attach);\n\n/**\n * usb_string_ids_n() - allocate unused string IDs in batch\n * @c: the device whose string descriptor IDs are being allocated\n * @n: number of string IDs to allocate\n * Context: single threaded during gadget setup\n *\n * Returns the first requested ID.  This ID and next @n-1 IDs are now\n * valid IDs.  At least provided that @n is non-zero because if it\n * is, returns last requested ID which is now very useful information.\n *\n * @usb_string_ids_n() is called from bind() callbacks to allocate\n * string IDs.  Drivers for functions, configurations, or gadgets will\n * then store that ID in the appropriate descriptors and string table.\n *\n * All string identifier should be allocated using this,\n * @usb_string_id() or @usb_string_ids_n() routine, to ensure that for\n * example different functions don't wrongly assign different meanings\n * to the same identifier.\n */\nint usb_string_ids_n(struct usb_composite_dev *c, unsigned n)\n{\n\tunsigned next = c->next_string_id;\n\tif (unlikely(n > 254 || (unsigned)next + n > 254))\n\t\treturn -ENODEV;\n\tc->next_string_id += n;\n\treturn next + 1;\n}\nEXPORT_SYMBOL_GPL(usb_string_ids_n);\n\n/*-------------------------------------------------------------------------*/\n\nstatic void composite_setup_complete(struct usb_ep *ep, struct usb_request *req)\n{\n\tstruct usb_composite_dev *cdev;\n\n\tif (req->status || req->actual != req->length)\n\t\tDBG((struct usb_composite_dev *) ep->driver_data,\n\t\t\t\t\"setup complete --> %d, %d/%d\\n\",\n\t\t\t\treq->status, req->actual, req->length);\n\n\t/*\n\t * REVIST The same ep0 requests are shared with function drivers\n\t * so they don't have to maintain the same ->complete() stubs.\n\t *\n\t * Because of that, we need to check for the validity of ->context\n\t * here, even though we know we've set it to something useful.\n\t */\n\tif (!req->context)\n\t\treturn;\n\n\tcdev = req->context;\n\n\tif (cdev->req == req)\n\t\tcdev->setup_pending = false;\n\telse if (cdev->os_desc_req == req)\n\t\tcdev->os_desc_pending = false;\n\telse\n\t\tWARN(1, \"unknown request %p\\n\", req);\n}\n\nstatic int composite_ep0_queue(struct usb_composite_dev *cdev,\n\t\tstruct usb_request *req, gfp_t gfp_flags)\n{\n\tint ret;\n\n\tret = usb_ep_queue(cdev->gadget->ep0, req, gfp_flags);\n\tif (ret == 0) {\n\t\tif (cdev->req == req)\n\t\t\tcdev->setup_pending = true;\n\t\telse if (cdev->os_desc_req == req)\n\t\t\tcdev->os_desc_pending = true;\n\t\telse\n\t\t\tWARN(1, \"unknown request %p\\n\", req);\n\t}\n\n\treturn ret;\n}\n\nstatic int count_ext_compat(struct usb_configuration *c)\n{\n\tint i, res;\n\n\tres = 0;\n\tfor (i = 0; i < c->next_interface_id; ++i) {\n\t\tstruct usb_function *f;\n\t\tint j;\n\n\t\tf = c->interface[i];\n\t\tfor (j = 0; j < f->os_desc_n; ++j) {\n\t\t\tstruct usb_os_desc *d;\n\n\t\t\tif (i != f->os_desc_table[j].if_id)\n\t\t\t\tcontinue;\n\t\t\td = f->os_desc_table[j].os_desc;\n\t\t\tif (d && d->ext_compat_id)\n\t\t\t\t++res;\n\t\t}\n\t}\n\tBUG_ON(res > 255);\n\treturn res;\n}\n\nstatic int fill_ext_compat(struct usb_configuration *c, u8 *buf)\n{\n\tint i, count;\n\n\tcount = 16;\n\tbuf += 16;\n\tfor (i = 0; i < c->next_interface_id; ++i) {\n\t\tstruct usb_function *f;\n\t\tint j;\n\n\t\tf = c->interface[i];\n\t\tfor (j = 0; j < f->os_desc_n; ++j) {\n\t\t\tstruct usb_os_desc *d;\n\n\t\t\tif (i != f->os_desc_table[j].if_id)\n\t\t\t\tcontinue;\n\t\t\td = f->os_desc_table[j].os_desc;\n\t\t\tif (d && d->ext_compat_id) {\n\t\t\t\t*buf++ = i;\n\t\t\t\t*buf++ = 0x01;\n\t\t\t\tmemcpy(buf, d->ext_compat_id, 16);\n\t\t\t\tbuf += 22;\n\t\t\t} else {\n\t\t\t\t++buf;\n\t\t\t\t*buf = 0x01;\n\t\t\t\tbuf += 23;\n\t\t\t}\n\t\t\tcount += 24;\n\t\t\tif (count + 24 >= USB_COMP_EP0_OS_DESC_BUFSIZ)\n\t\t\t\treturn count;\n\t\t}\n\t}\n\n\treturn count;\n}\n\nstatic int count_ext_prop(struct usb_configuration *c, int interface)\n{\n\tstruct usb_function *f;\n\tint j;\n\n\tf = c->interface[interface];\n\tfor (j = 0; j < f->os_desc_n; ++j) {\n\t\tstruct usb_os_desc *d;\n\n\t\tif (interface != f->os_desc_table[j].if_id)\n\t\t\tcontinue;\n\t\td = f->os_desc_table[j].os_desc;\n\t\tif (d && d->ext_compat_id)\n\t\t\treturn d->ext_prop_count;\n\t}\n\treturn 0;\n}\n\nstatic int len_ext_prop(struct usb_configuration *c, int interface)\n{\n\tstruct usb_function *f;\n\tstruct usb_os_desc *d;\n\tint j, res;\n\n\tres = 10; /* header length */\n\tf = c->interface[interface];\n\tfor (j = 0; j < f->os_desc_n; ++j) {\n\t\tif (interface != f->os_desc_table[j].if_id)\n\t\t\tcontinue;\n\t\td = f->os_desc_table[j].os_desc;\n\t\tif (d)\n\t\t\treturn min(res + d->ext_prop_len, 4096);\n\t}\n\treturn res;\n}\n\nstatic int fill_ext_prop(struct usb_configuration *c, int interface, u8 *buf)\n{\n\tstruct usb_function *f;\n\tstruct usb_os_desc *d;\n\tstruct usb_os_desc_ext_prop *ext_prop;\n\tint j, count, n, ret;\n\n\tf = c->interface[interface];\n\tcount = 10; /* header length */\n\tbuf += 10;\n\tfor (j = 0; j < f->os_desc_n; ++j) {\n\t\tif (interface != f->os_desc_table[j].if_id)\n\t\t\tcontinue;\n\t\td = f->os_desc_table[j].os_desc;\n\t\tif (d)\n\t\t\tlist_for_each_entry(ext_prop, &d->ext_prop, entry) {\n\t\t\t\tn = ext_prop->data_len +\n\t\t\t\t\text_prop->name_len + 14;\n\t\t\t\tif (count + n >= USB_COMP_EP0_OS_DESC_BUFSIZ)\n\t\t\t\t\treturn count;\n\t\t\t\tusb_ext_prop_put_size(buf, n);\n\t\t\t\tusb_ext_prop_put_type(buf, ext_prop->type);\n\t\t\t\tret = usb_ext_prop_put_name(buf, ext_prop->name,\n\t\t\t\t\t\t\t    ext_prop->name_len);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\treturn ret;\n\t\t\t\tswitch (ext_prop->type) {\n\t\t\t\tcase USB_EXT_PROP_UNICODE:\n\t\t\t\tcase USB_EXT_PROP_UNICODE_ENV:\n\t\t\t\tcase USB_EXT_PROP_UNICODE_LINK:\n\t\t\t\t\tusb_ext_prop_put_unicode(buf, ret,\n\t\t\t\t\t\t\t ext_prop->data,\n\t\t\t\t\t\t\t ext_prop->data_len);\n\t\t\t\t\tbreak;\n\t\t\t\tcase USB_EXT_PROP_BINARY:\n\t\t\t\t\tusb_ext_prop_put_binary(buf, ret,\n\t\t\t\t\t\t\text_prop->data,\n\t\t\t\t\t\t\text_prop->data_len);\n\t\t\t\t\tbreak;\n\t\t\t\tcase USB_EXT_PROP_LE32:\n\t\t\t\t\t/* not implemented */\n\t\t\t\tcase USB_EXT_PROP_BE32:\n\t\t\t\t\t/* not implemented */\n\t\t\t\tdefault:\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\t\t\t\tbuf += n;\n\t\t\t\tcount += n;\n\t\t\t}\n\t}\n\n\treturn count;\n}\n\n/*\n * The setup() callback implements all the ep0 functionality that's\n * not handled lower down, in hardware or the hardware driver(like\n * device and endpoint feature flags, and their status).  It's all\n * housekeeping for the gadget function we're implementing.  Most of\n * the work is in config and function specific setup.\n */\nint\ncomposite_setup(struct usb_gadget *gadget, const struct usb_ctrlrequest *ctrl)\n{\n\tstruct usb_composite_dev\t*cdev = get_gadget_data(gadget);\n\tstruct usb_request\t\t*req = cdev->req;\n\tint\t\t\t\tvalue = -EOPNOTSUPP;\n\tint\t\t\t\tstatus = 0;\n\tu16\t\t\t\tw_index = le16_to_cpu(ctrl->wIndex);\n\tu8\t\t\t\tintf = w_index & 0xFF;\n\tu16\t\t\t\tw_value = le16_to_cpu(ctrl->wValue);\n\tu16\t\t\t\tw_length = le16_to_cpu(ctrl->wLength);\n\tstruct usb_function\t\t*f = NULL;\n\tu8\t\t\t\tendp;\n\n\tif (w_length > USB_COMP_EP0_BUFSIZ) {\n\t\tif (ctrl->bRequestType & USB_DIR_IN) {\n\t\t\t/* Cast away the const, we are going to overwrite on purpose. */\n\t\t\t__le16 *temp = (__le16 *)&ctrl->wLength;\n\n\t\t\t*temp = cpu_to_le16(USB_COMP_EP0_BUFSIZ);\n\t\t\tw_length = USB_COMP_EP0_BUFSIZ;\n\t\t} else {\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\t/* partial re-init of the response message; the function or the\n\t * gadget might need to intercept e.g. a control-OUT completion\n\t * when we delegate to it.\n\t */\n\treq->zero = 0;\n\treq->context = cdev;\n\treq->complete = composite_setup_complete;\n\treq->length = 0;\n\tgadget->ep0->driver_data = cdev;\n\n\t/*\n\t * Don't let non-standard requests match any of the cases below\n\t * by accident.\n\t */\n\tif ((ctrl->bRequestType & USB_TYPE_MASK) != USB_TYPE_STANDARD)\n\t\tgoto unknown;\n\n\tswitch (ctrl->bRequest) {\n\n\t/* we handle all standard USB descriptors */\n\tcase USB_REQ_GET_DESCRIPTOR:\n\t\tif (ctrl->bRequestType != USB_DIR_IN)\n\t\t\tgoto unknown;\n\t\tswitch (w_value >> 8) {\n\n\t\tcase USB_DT_DEVICE:\n\t\t\tcdev->desc.bNumConfigurations =\n\t\t\t\tcount_configs(cdev, USB_DT_DEVICE);\n\t\t\tcdev->desc.bMaxPacketSize0 =\n\t\t\t\tcdev->gadget->ep0->maxpacket;\n\t\t\tif (gadget_is_superspeed(gadget)) {\n\t\t\t\tif (gadget->speed >= USB_SPEED_SUPER) {\n\t\t\t\t\tcdev->desc.bcdUSB = cpu_to_le16(0x0320);\n\t\t\t\t\tcdev->desc.bMaxPacketSize0 = 9;\n\t\t\t\t} else {\n\t\t\t\t\tcdev->desc.bcdUSB = cpu_to_le16(0x0210);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (gadget->lpm_capable)\n\t\t\t\t\tcdev->desc.bcdUSB = cpu_to_le16(0x0201);\n\t\t\t\telse\n\t\t\t\t\tcdev->desc.bcdUSB = cpu_to_le16(0x0200);\n\t\t\t}\n\n\t\t\tvalue = min(w_length, (u16) sizeof cdev->desc);\n\t\t\tmemcpy(req->buf, &cdev->desc, value);\n\t\t\tbreak;\n\t\tcase USB_DT_DEVICE_QUALIFIER:\n\t\t\tif (!gadget_is_dualspeed(gadget) ||\n\t\t\t    gadget->speed >= USB_SPEED_SUPER)\n\t\t\t\tbreak;\n\t\t\tdevice_qual(cdev);\n\t\t\tvalue = min_t(int, w_length,\n\t\t\t\tsizeof(struct usb_qualifier_descriptor));\n\t\t\tbreak;\n\t\tcase USB_DT_OTHER_SPEED_CONFIG:\n\t\t\tif (!gadget_is_dualspeed(gadget) ||\n\t\t\t    gadget->speed >= USB_SPEED_SUPER)\n\t\t\t\tbreak;\n\t\t\tfallthrough;\n\t\tcase USB_DT_CONFIG:\n\t\t\tvalue = config_desc(cdev, w_value);\n\t\t\tif (value >= 0)\n\t\t\t\tvalue = min(w_length, (u16) value);\n\t\t\tbreak;\n\t\tcase USB_DT_STRING:\n\t\t\tvalue = get_string(cdev, req->buf,\n\t\t\t\t\tw_index, w_value & 0xff);\n\t\t\tif (value >= 0)\n\t\t\t\tvalue = min(w_length, (u16) value);\n\t\t\tbreak;\n\t\tcase USB_DT_BOS:\n\t\t\tif (gadget_is_superspeed(gadget) ||\n\t\t\t    gadget->lpm_capable) {\n\t\t\t\tvalue = bos_desc(cdev);\n\t\t\t\tvalue = min(w_length, (u16) value);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase USB_DT_OTG:\n\t\t\tif (gadget_is_otg(gadget)) {\n\t\t\t\tstruct usb_configuration *config;\n\t\t\t\tint otg_desc_len = 0;\n\n\t\t\t\tif (cdev->config)\n\t\t\t\t\tconfig = cdev->config;\n\t\t\t\telse\n\t\t\t\t\tconfig = list_first_entry(\n\t\t\t\t\t\t\t&cdev->configs,\n\t\t\t\t\t\tstruct usb_configuration, list);\n\t\t\t\tif (!config)\n\t\t\t\t\tgoto done;\n\n\t\t\t\tif (gadget->otg_caps &&\n\t\t\t\t\t(gadget->otg_caps->otg_rev >= 0x0200))\n\t\t\t\t\totg_desc_len += sizeof(\n\t\t\t\t\t\tstruct usb_otg20_descriptor);\n\t\t\t\telse\n\t\t\t\t\totg_desc_len += sizeof(\n\t\t\t\t\t\tstruct usb_otg_descriptor);\n\n\t\t\t\tvalue = min_t(int, w_length, otg_desc_len);\n\t\t\t\tmemcpy(req->buf, config->descriptors[0], value);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\t/* any number of configs can work */\n\tcase USB_REQ_SET_CONFIGURATION:\n\t\tif (ctrl->bRequestType != 0)\n\t\t\tgoto unknown;\n\t\tif (gadget_is_otg(gadget)) {\n\t\t\tif (gadget->a_hnp_support)\n\t\t\t\tDBG(cdev, \"HNP available\\n\");\n\t\t\telse if (gadget->a_alt_hnp_support)\n\t\t\t\tDBG(cdev, \"HNP on another port\\n\");\n\t\t\telse\n\t\t\t\tVDBG(cdev, \"HNP inactive\\n\");\n\t\t}\n\t\tspin_lock(&cdev->lock);\n\t\tvalue = set_config(cdev, ctrl, w_value);\n\t\tspin_unlock(&cdev->lock);\n\t\tbreak;\n\tcase USB_REQ_GET_CONFIGURATION:\n\t\tif (ctrl->bRequestType != USB_DIR_IN)\n\t\t\tgoto unknown;\n\t\tif (cdev->config)\n\t\t\t*(u8 *)req->buf = cdev->config->bConfigurationValue;\n\t\telse\n\t\t\t*(u8 *)req->buf = 0;\n\t\tvalue = min(w_length, (u16) 1);\n\t\tbreak;\n\n\t/* function drivers must handle get/set altsetting */\n\tcase USB_REQ_SET_INTERFACE:\n\t\tif (ctrl->bRequestType != USB_RECIP_INTERFACE)\n\t\t\tgoto unknown;\n\t\tif (!cdev->config || intf >= MAX_CONFIG_INTERFACES)\n\t\t\tbreak;\n\t\tf = cdev->config->interface[intf];\n\t\tif (!f)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * If there's no get_alt() method, we know only altsetting zero\n\t\t * works. There is no need to check if set_alt() is not NULL\n\t\t * as we check this in usb_add_function().\n\t\t */\n\t\tif (w_value && !f->get_alt)\n\t\t\tbreak;\n\n\t\tspin_lock(&cdev->lock);\n\t\tvalue = f->set_alt(f, w_index, w_value);\n\t\tif (value == USB_GADGET_DELAYED_STATUS) {\n\t\t\tDBG(cdev,\n\t\t\t \"%s: interface %d (%s) requested delayed status\\n\",\n\t\t\t\t\t__func__, intf, f->name);\n\t\t\tcdev->delayed_status++;\n\t\t\tDBG(cdev, \"delayed_status count %d\\n\",\n\t\t\t\t\tcdev->delayed_status);\n\t\t}\n\t\tspin_unlock(&cdev->lock);\n\t\tbreak;\n\tcase USB_REQ_GET_INTERFACE:\n\t\tif (ctrl->bRequestType != (USB_DIR_IN|USB_RECIP_INTERFACE))\n\t\t\tgoto unknown;\n\t\tif (!cdev->config || intf >= MAX_CONFIG_INTERFACES)\n\t\t\tbreak;\n\t\tf = cdev->config->interface[intf];\n\t\tif (!f)\n\t\t\tbreak;\n\t\t/* lots of interfaces only need altsetting zero... */\n\t\tvalue = f->get_alt ? f->get_alt(f, w_index) : 0;\n\t\tif (value < 0)\n\t\t\tbreak;\n\t\t*((u8 *)req->buf) = value;\n\t\tvalue = min(w_length, (u16) 1);\n\t\tbreak;\n\tcase USB_REQ_GET_STATUS:\n\t\tif (gadget_is_otg(gadget) && gadget->hnp_polling_support &&\n\t\t\t\t\t\t(w_index == OTG_STS_SELECTOR)) {\n\t\t\tif (ctrl->bRequestType != (USB_DIR_IN |\n\t\t\t\t\t\t\tUSB_RECIP_DEVICE))\n\t\t\t\tgoto unknown;\n\t\t\t*((u8 *)req->buf) = gadget->host_request_flag;\n\t\t\tvalue = 1;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * USB 3.0 additions:\n\t\t * Function driver should handle get_status request. If such cb\n\t\t * wasn't supplied we respond with default value = 0\n\t\t * Note: function driver should supply such cb only for the\n\t\t * first interface of the function\n\t\t */\n\t\tif (!gadget_is_superspeed(gadget))\n\t\t\tgoto unknown;\n\t\tif (ctrl->bRequestType != (USB_DIR_IN | USB_RECIP_INTERFACE))\n\t\t\tgoto unknown;\n\t\tvalue = 2;\t/* This is the length of the get_status reply */\n\t\tput_unaligned_le16(0, req->buf);\n\t\tif (!cdev->config || intf >= MAX_CONFIG_INTERFACES)\n\t\t\tbreak;\n\t\tf = cdev->config->interface[intf];\n\t\tif (!f)\n\t\t\tbreak;\n\t\tstatus = f->get_status ? f->get_status(f) : 0;\n\t\tif (status < 0)\n\t\t\tbreak;\n\t\tput_unaligned_le16(status & 0x0000ffff, req->buf);\n\t\tbreak;\n\t/*\n\t * Function drivers should handle SetFeature/ClearFeature\n\t * (FUNCTION_SUSPEND) request. function_suspend cb should be supplied\n\t * only for the first interface of the function\n\t */\n\tcase USB_REQ_CLEAR_FEATURE:\n\tcase USB_REQ_SET_FEATURE:\n\t\tif (!gadget_is_superspeed(gadget))\n\t\t\tgoto unknown;\n\t\tif (ctrl->bRequestType != (USB_DIR_OUT | USB_RECIP_INTERFACE))\n\t\t\tgoto unknown;\n\t\tswitch (w_value) {\n\t\tcase USB_INTRF_FUNC_SUSPEND:\n\t\t\tif (!cdev->config || intf >= MAX_CONFIG_INTERFACES)\n\t\t\t\tbreak;\n\t\t\tf = cdev->config->interface[intf];\n\t\t\tif (!f)\n\t\t\t\tbreak;\n\t\t\tvalue = 0;\n\t\t\tif (f->func_suspend)\n\t\t\t\tvalue = f->func_suspend(f, w_index >> 8);\n\t\t\tif (value < 0) {\n\t\t\t\tERROR(cdev,\n\t\t\t\t      \"func_suspend() returned error %d\\n\",\n\t\t\t\t      value);\n\t\t\t\tvalue = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tdefault:\nunknown:\n\t\t/*\n\t\t * OS descriptors handling\n\t\t */\n\t\tif (cdev->use_os_string && cdev->os_desc_config &&\n\t\t    (ctrl->bRequestType & USB_TYPE_VENDOR) &&\n\t\t    ctrl->bRequest == cdev->b_vendor_code) {\n\t\t\tstruct usb_configuration\t*os_desc_cfg;\n\t\t\tu8\t\t\t\t*buf;\n\t\t\tint\t\t\t\tinterface;\n\t\t\tint\t\t\t\tcount = 0;\n\n\t\t\treq = cdev->os_desc_req;\n\t\t\treq->context = cdev;\n\t\t\treq->complete = composite_setup_complete;\n\t\t\tbuf = req->buf;\n\t\t\tos_desc_cfg = cdev->os_desc_config;\n\t\t\tw_length = min_t(u16, w_length, USB_COMP_EP0_OS_DESC_BUFSIZ);\n\t\t\tmemset(buf, 0, w_length);\n\t\t\tbuf[5] = 0x01;\n\t\t\tswitch (ctrl->bRequestType & USB_RECIP_MASK) {\n\t\t\tcase USB_RECIP_DEVICE:\n\t\t\t\tif (w_index != 0x4 || (w_value >> 8))\n\t\t\t\t\tbreak;\n\t\t\t\tbuf[6] = w_index;\n\t\t\t\t/* Number of ext compat interfaces */\n\t\t\t\tcount = count_ext_compat(os_desc_cfg);\n\t\t\t\tbuf[8] = count;\n\t\t\t\tcount *= 24; /* 24 B/ext compat desc */\n\t\t\t\tcount += 16; /* header */\n\t\t\t\tput_unaligned_le32(count, buf);\n\t\t\t\tvalue = w_length;\n\t\t\t\tif (w_length > 0x10) {\n\t\t\t\t\tvalue = fill_ext_compat(os_desc_cfg, buf);\n\t\t\t\t\tvalue = min_t(u16, w_length, value);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase USB_RECIP_INTERFACE:\n\t\t\t\tif (w_index != 0x5 || (w_value >> 8))\n\t\t\t\t\tbreak;\n\t\t\t\tinterface = w_value & 0xFF;\n\t\t\t\tbuf[6] = w_index;\n\t\t\t\tcount = count_ext_prop(os_desc_cfg,\n\t\t\t\t\tinterface);\n\t\t\t\tput_unaligned_le16(count, buf + 8);\n\t\t\t\tcount = len_ext_prop(os_desc_cfg,\n\t\t\t\t\tinterface);\n\t\t\t\tput_unaligned_le32(count, buf);\n\t\t\t\tvalue = w_length;\n\t\t\t\tif (w_length > 0x0A) {\n\t\t\t\t\tvalue = fill_ext_prop(os_desc_cfg,\n\t\t\t\t\t\t\t      interface, buf);\n\t\t\t\t\tif (value >= 0)\n\t\t\t\t\t\tvalue = min_t(u16, w_length, value);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tgoto check_value;\n\t\t}\n\n\t\tVDBG(cdev,\n\t\t\t\"non-core control req%02x.%02x v%04x i%04x l%d\\n\",\n\t\t\tctrl->bRequestType, ctrl->bRequest,\n\t\t\tw_value, w_index, w_length);\n\n\t\t/* functions always handle their interfaces and endpoints...\n\t\t * punt other recipients (other, WUSB, ...) to the current\n\t\t * configuration code.\n\t\t */\n\t\tif (cdev->config) {\n\t\t\tlist_for_each_entry(f, &cdev->config->functions, list)\n\t\t\t\tif (f->req_match &&\n\t\t\t\t    f->req_match(f, ctrl, false))\n\t\t\t\t\tgoto try_fun_setup;\n\t\t} else {\n\t\t\tstruct usb_configuration *c;\n\t\t\tlist_for_each_entry(c, &cdev->configs, list)\n\t\t\t\tlist_for_each_entry(f, &c->functions, list)\n\t\t\t\t\tif (f->req_match &&\n\t\t\t\t\t    f->req_match(f, ctrl, true))\n\t\t\t\t\t\tgoto try_fun_setup;\n\t\t}\n\t\tf = NULL;\n\n\t\tswitch (ctrl->bRequestType & USB_RECIP_MASK) {\n\t\tcase USB_RECIP_INTERFACE:\n\t\t\tif (!cdev->config || intf >= MAX_CONFIG_INTERFACES)\n\t\t\t\tbreak;\n\t\t\tf = cdev->config->interface[intf];\n\t\t\tbreak;\n\n\t\tcase USB_RECIP_ENDPOINT:\n\t\t\tif (!cdev->config)\n\t\t\t\tbreak;\n\t\t\tendp = ((w_index & 0x80) >> 3) | (w_index & 0x0f);\n\t\t\tlist_for_each_entry(f, &cdev->config->functions, list) {\n\t\t\t\tif (test_bit(endp, f->endpoints))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (&f->list == &cdev->config->functions)\n\t\t\t\tf = NULL;\n\t\t\tbreak;\n\t\t}\ntry_fun_setup:\n\t\tif (f && f->setup)\n\t\t\tvalue = f->setup(f, ctrl);\n\t\telse {\n\t\t\tstruct usb_configuration\t*c;\n\n\t\t\tc = cdev->config;\n\t\t\tif (!c)\n\t\t\t\tgoto done;\n\n\t\t\t/* try current config's setup */\n\t\t\tif (c->setup) {\n\t\t\t\tvalue = c->setup(c, ctrl);\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\t/* try the only function in the current config */\n\t\t\tif (!list_is_singular(&c->functions))\n\t\t\t\tgoto done;\n\t\t\tf = list_first_entry(&c->functions, struct usb_function,\n\t\t\t\t\t     list);\n\t\t\tif (f->setup)\n\t\t\t\tvalue = f->setup(f, ctrl);\n\t\t}\n\n\t\tgoto done;\n\t}\n\ncheck_value:\n\t/* respond with data transfer before status phase? */\n\tif (value >= 0 && value != USB_GADGET_DELAYED_STATUS) {\n\t\treq->length = value;\n\t\treq->context = cdev;\n\t\treq->zero = value < w_length;\n\t\tvalue = composite_ep0_queue(cdev, req, GFP_ATOMIC);\n\t\tif (value < 0) {\n\t\t\tDBG(cdev, \"ep_queue --> %d\\n\", value);\n\t\t\treq->status = 0;\n\t\t\tcomposite_setup_complete(gadget->ep0, req);\n\t\t}\n\t} else if (value == USB_GADGET_DELAYED_STATUS && w_length != 0) {\n\t\tWARN(cdev,\n\t\t\t\"%s: Delayed status not supported for w_length != 0\",\n\t\t\t__func__);\n\t}\n\ndone:\n\t/* device either stalls (value < 0) or reports success */\n\treturn value;\n}\n\nstatic void __composite_disconnect(struct usb_gadget *gadget)\n{\n\tstruct usb_composite_dev\t*cdev = get_gadget_data(gadget);\n\tunsigned long\t\t\tflags;\n\n\t/* REVISIT:  should we have config and device level\n\t * disconnect callbacks?\n\t */\n\tspin_lock_irqsave(&cdev->lock, flags);\n\tcdev->suspended = 0;\n\tif (cdev->config)\n\t\treset_config(cdev);\n\tif (cdev->driver->disconnect)\n\t\tcdev->driver->disconnect(cdev);\n\tspin_unlock_irqrestore(&cdev->lock, flags);\n}\n\nvoid composite_disconnect(struct usb_gadget *gadget)\n{\n\tusb_gadget_vbus_draw(gadget, 0);\n\t__composite_disconnect(gadget);\n}\n\nvoid composite_reset(struct usb_gadget *gadget)\n{\n\t/*\n\t * Section 1.4.13 Standard Downstream Port of the USB battery charging\n\t * specification v1.2 states that a device connected on a SDP shall only\n\t * draw at max 100mA while in a connected, but unconfigured state.\n\t */\n\tusb_gadget_vbus_draw(gadget, 100);\n\t__composite_disconnect(gadget);\n}\n\n/*-------------------------------------------------------------------------*/\n\nstatic ssize_t suspended_show(struct device *dev, struct device_attribute *attr,\n\t\t\t      char *buf)\n{\n\tstruct usb_gadget *gadget = dev_to_usb_gadget(dev);\n\tstruct usb_composite_dev *cdev = get_gadget_data(gadget);\n\n\treturn sprintf(buf, \"%d\\n\", cdev->suspended);\n}\nstatic DEVICE_ATTR_RO(suspended);\n\nstatic void __composite_unbind(struct usb_gadget *gadget, bool unbind_driver)\n{\n\tstruct usb_composite_dev\t*cdev = get_gadget_data(gadget);\n\tstruct usb_gadget_strings\t*gstr = cdev->driver->strings[0];\n\tstruct usb_string\t\t*dev_str = gstr->strings;\n\n\t/* composite_disconnect() must already have been called\n\t * by the underlying peripheral controller driver!\n\t * so there's no i/o concurrency that could affect the\n\t * state protected by cdev->lock.\n\t */\n\tWARN_ON(cdev->config);\n\n\twhile (!list_empty(&cdev->configs)) {\n\t\tstruct usb_configuration\t*c;\n\t\tc = list_first_entry(&cdev->configs,\n\t\t\t\tstruct usb_configuration, list);\n\t\tremove_config(cdev, c);\n\t}\n\tif (cdev->driver->unbind && unbind_driver)\n\t\tcdev->driver->unbind(cdev);\n\n\tcomposite_dev_cleanup(cdev);\n\n\tif (dev_str[USB_GADGET_MANUFACTURER_IDX].s == cdev->def_manufacturer)\n\t\tdev_str[USB_GADGET_MANUFACTURER_IDX].s = \"\";\n\n\tkfree(cdev->def_manufacturer);\n\tkfree(cdev);\n\tset_gadget_data(gadget, NULL);\n}\n\nstatic void composite_unbind(struct usb_gadget *gadget)\n{\n\t__composite_unbind(gadget, true);\n}\n\nstatic void update_unchanged_dev_desc(struct usb_device_descriptor *new,\n\t\tconst struct usb_device_descriptor *old)\n{\n\t__le16 idVendor;\n\t__le16 idProduct;\n\t__le16 bcdDevice;\n\tu8 iSerialNumber;\n\tu8 iManufacturer;\n\tu8 iProduct;\n\n\t/*\n\t * these variables may have been set in\n\t * usb_composite_overwrite_options()\n\t */\n\tidVendor = new->idVendor;\n\tidProduct = new->idProduct;\n\tbcdDevice = new->bcdDevice;\n\tiSerialNumber = new->iSerialNumber;\n\tiManufacturer = new->iManufacturer;\n\tiProduct = new->iProduct;\n\n\t*new = *old;\n\tif (idVendor)\n\t\tnew->idVendor = idVendor;\n\tif (idProduct)\n\t\tnew->idProduct = idProduct;\n\tif (bcdDevice)\n\t\tnew->bcdDevice = bcdDevice;\n\telse\n\t\tnew->bcdDevice = cpu_to_le16(get_default_bcdDevice());\n\tif (iSerialNumber)\n\t\tnew->iSerialNumber = iSerialNumber;\n\tif (iManufacturer)\n\t\tnew->iManufacturer = iManufacturer;\n\tif (iProduct)\n\t\tnew->iProduct = iProduct;\n}\n\nint composite_dev_prepare(struct usb_composite_driver *composite,\n\t\tstruct usb_composite_dev *cdev)\n{\n\tstruct usb_gadget *gadget = cdev->gadget;\n\tint ret = -ENOMEM;\n\n\t/* preallocate control response and buffer */\n\tcdev->req = usb_ep_alloc_request(gadget->ep0, GFP_KERNEL);\n\tif (!cdev->req)\n\t\treturn -ENOMEM;\n\n\tcdev->req->buf = kzalloc(USB_COMP_EP0_BUFSIZ, GFP_KERNEL);\n\tif (!cdev->req->buf)\n\t\tgoto fail;\n\n\tret = device_create_file(&gadget->dev, &dev_attr_suspended);\n\tif (ret)\n\t\tgoto fail_dev;\n\n\tcdev->req->complete = composite_setup_complete;\n\tcdev->req->context = cdev;\n\tgadget->ep0->driver_data = cdev;\n\n\tcdev->driver = composite;\n\n\t/*\n\t * As per USB compliance update, a device that is actively drawing\n\t * more than 100mA from USB must report itself as bus-powered in\n\t * the GetStatus(DEVICE) call.\n\t */\n\tif (CONFIG_USB_GADGET_VBUS_DRAW <= USB_SELF_POWER_VBUS_MAX_DRAW)\n\t\tusb_gadget_set_selfpowered(gadget);\n\n\t/* interface and string IDs start at zero via kzalloc.\n\t * we force endpoints to start unassigned; few controller\n\t * drivers will zero ep->driver_data.\n\t */\n\tusb_ep_autoconfig_reset(gadget);\n\treturn 0;\nfail_dev:\n\tkfree(cdev->req->buf);\nfail:\n\tusb_ep_free_request(gadget->ep0, cdev->req);\n\tcdev->req = NULL;\n\treturn ret;\n}\n\nint composite_os_desc_req_prepare(struct usb_composite_dev *cdev,\n\t\t\t\t  struct usb_ep *ep0)\n{\n\tint ret = 0;\n\n\tcdev->os_desc_req = usb_ep_alloc_request(ep0, GFP_KERNEL);\n\tif (!cdev->os_desc_req) {\n\t\tret = -ENOMEM;\n\t\tgoto end;\n\t}\n\n\tcdev->os_desc_req->buf = kmalloc(USB_COMP_EP0_OS_DESC_BUFSIZ,\n\t\t\t\t\t GFP_KERNEL);\n\tif (!cdev->os_desc_req->buf) {\n\t\tret = -ENOMEM;\n\t\tusb_ep_free_request(ep0, cdev->os_desc_req);\n\t\tgoto end;\n\t}\n\tcdev->os_desc_req->context = cdev;\n\tcdev->os_desc_req->complete = composite_setup_complete;\nend:\n\treturn ret;\n}\n\nvoid composite_dev_cleanup(struct usb_composite_dev *cdev)\n{\n\tstruct usb_gadget_string_container *uc, *tmp;\n\tstruct usb_ep\t\t\t   *ep, *tmp_ep;\n\n\tlist_for_each_entry_safe(uc, tmp, &cdev->gstrings, list) {\n\t\tlist_del(&uc->list);\n\t\tkfree(uc);\n\t}\n\tif (cdev->os_desc_req) {\n\t\tif (cdev->os_desc_pending)\n\t\t\tusb_ep_dequeue(cdev->gadget->ep0, cdev->os_desc_req);\n\n\t\tkfree(cdev->os_desc_req->buf);\n\t\tcdev->os_desc_req->buf = NULL;\n\t\tusb_ep_free_request(cdev->gadget->ep0, cdev->os_desc_req);\n\t\tcdev->os_desc_req = NULL;\n\t}\n\tif (cdev->req) {\n\t\tif (cdev->setup_pending)\n\t\t\tusb_ep_dequeue(cdev->gadget->ep0, cdev->req);\n\n\t\tkfree(cdev->req->buf);\n\t\tcdev->req->buf = NULL;\n\t\tusb_ep_free_request(cdev->gadget->ep0, cdev->req);\n\t\tcdev->req = NULL;\n\t}\n\tcdev->next_string_id = 0;\n\tdevice_remove_file(&cdev->gadget->dev, &dev_attr_suspended);\n\n\t/*\n\t * Some UDC backends have a dynamic EP allocation scheme.\n\t *\n\t * In that case, the dispose() callback is used to notify the\n\t * backend that the EPs are no longer in use.\n\t *\n\t * Note: The UDC backend can remove the EP from the ep_list as\n\t *\t a result, so we need to use the _safe list iterator.\n\t */\n\tlist_for_each_entry_safe(ep, tmp_ep,\n\t\t\t\t &cdev->gadget->ep_list, ep_list) {\n\t\tif (ep->ops->dispose)\n\t\t\tep->ops->dispose(ep);\n\t}\n}\n\nstatic int composite_bind(struct usb_gadget *gadget,\n\t\tstruct usb_gadget_driver *gdriver)\n{\n\tstruct usb_composite_dev\t*cdev;\n\tstruct usb_composite_driver\t*composite = to_cdriver(gdriver);\n\tint\t\t\t\tstatus = -ENOMEM;\n\n\tcdev = kzalloc(sizeof *cdev, GFP_KERNEL);\n\tif (!cdev)\n\t\treturn status;\n\n\tspin_lock_init(&cdev->lock);\n\tcdev->gadget = gadget;\n\tset_gadget_data(gadget, cdev);\n\tINIT_LIST_HEAD(&cdev->configs);\n\tINIT_LIST_HEAD(&cdev->gstrings);\n\n\tstatus = composite_dev_prepare(composite, cdev);\n\tif (status)\n\t\tgoto fail;\n\n\t/* composite gadget needs to assign strings for whole device (like\n\t * serial number), register function drivers, potentially update\n\t * power state and consumption, etc\n\t */\n\tstatus = composite->bind(cdev);\n\tif (status < 0)\n\t\tgoto fail;\n\n\tif (cdev->use_os_string) {\n\t\tstatus = composite_os_desc_req_prepare(cdev, gadget->ep0);\n\t\tif (status)\n\t\t\tgoto fail;\n\t}\n\n\tupdate_unchanged_dev_desc(&cdev->desc, composite->dev);\n\n\t/* has userspace failed to provide a serial number? */\n\tif (composite->needs_serial && !cdev->desc.iSerialNumber)\n\t\tWARNING(cdev, \"userspace failed to provide iSerialNumber\\n\");\n\n\tINFO(cdev, \"%s ready\\n\", composite->name);\n\treturn 0;\n\nfail:\n\t__composite_unbind(gadget, false);\n\treturn status;\n}\n\n/*-------------------------------------------------------------------------*/\n\nvoid composite_suspend(struct usb_gadget *gadget)\n{\n\tstruct usb_composite_dev\t*cdev = get_gadget_data(gadget);\n\tstruct usb_function\t\t*f;\n\n\t/* REVISIT:  should we have config level\n\t * suspend/resume callbacks?\n\t */\n\tDBG(cdev, \"suspend\\n\");\n\tif (cdev->config) {\n\t\tlist_for_each_entry(f, &cdev->config->functions, list) {\n\t\t\tif (f->suspend)\n\t\t\t\tf->suspend(f);\n\t\t}\n\t}\n\tif (cdev->driver->suspend)\n\t\tcdev->driver->suspend(cdev);\n\n\tcdev->suspended = 1;\n\n\tusb_gadget_set_selfpowered(gadget);\n\tusb_gadget_vbus_draw(gadget, 2);\n}\n\nvoid composite_resume(struct usb_gadget *gadget)\n{\n\tstruct usb_composite_dev\t*cdev = get_gadget_data(gadget);\n\tstruct usb_function\t\t*f;\n\tunsigned\t\t\tmaxpower;\n\n\t/* REVISIT:  should we have config level\n\t * suspend/resume callbacks?\n\t */\n\tDBG(cdev, \"resume\\n\");\n\tif (cdev->driver->resume)\n\t\tcdev->driver->resume(cdev);\n\tif (cdev->config) {\n\t\tlist_for_each_entry(f, &cdev->config->functions, list) {\n\t\t\tif (f->resume)\n\t\t\t\tf->resume(f);\n\t\t}\n\n\t\tmaxpower = cdev->config->MaxPower ?\n\t\t\tcdev->config->MaxPower : CONFIG_USB_GADGET_VBUS_DRAW;\n\t\tif (gadget->speed < USB_SPEED_SUPER)\n\t\t\tmaxpower = min(maxpower, 500U);\n\t\telse\n\t\t\tmaxpower = min(maxpower, 900U);\n\n\t\tif (maxpower > USB_SELF_POWER_VBUS_MAX_DRAW)\n\t\t\tusb_gadget_clear_selfpowered(gadget);\n\n\t\tusb_gadget_vbus_draw(gadget, maxpower);\n\t}\n\n\tcdev->suspended = 0;\n}\n\n/*-------------------------------------------------------------------------*/\n\nstatic const struct usb_gadget_driver composite_driver_template = {\n\t.bind\t\t= composite_bind,\n\t.unbind\t\t= composite_unbind,\n\n\t.setup\t\t= composite_setup,\n\t.reset\t\t= composite_reset,\n\t.disconnect\t= composite_disconnect,\n\n\t.suspend\t= composite_suspend,\n\t.resume\t\t= composite_resume,\n\n\t.driver\t= {\n\t\t.owner\t\t= THIS_MODULE,\n\t},\n};\n\n/**\n * usb_composite_probe() - register a composite driver\n * @driver: the driver to register\n *\n * Context: single threaded during gadget setup\n *\n * This function is used to register drivers using the composite driver\n * framework.  The return value is zero, or a negative errno value.\n * Those values normally come from the driver's @bind method, which does\n * all the work of setting up the driver to match the hardware.\n *\n * On successful return, the gadget is ready to respond to requests from\n * the host, unless one of its components invokes usb_gadget_disconnect()\n * while it was binding.  That would usually be done in order to wait for\n * some userspace participation.\n */\nint usb_composite_probe(struct usb_composite_driver *driver)\n{\n\tstruct usb_gadget_driver *gadget_driver;\n\n\tif (!driver || !driver->dev || !driver->bind)\n\t\treturn -EINVAL;\n\n\tif (!driver->name)\n\t\tdriver->name = \"composite\";\n\n\tdriver->gadget_driver = composite_driver_template;\n\tgadget_driver = &driver->gadget_driver;\n\n\tgadget_driver->function =  (char *) driver->name;\n\tgadget_driver->driver.name = driver->name;\n\tgadget_driver->max_speed = driver->max_speed;\n\n\treturn usb_gadget_probe_driver(gadget_driver);\n}\nEXPORT_SYMBOL_GPL(usb_composite_probe);\n\n/**\n * usb_composite_unregister() - unregister a composite driver\n * @driver: the driver to unregister\n *\n * This function is used to unregister drivers using the composite\n * driver framework.\n */\nvoid usb_composite_unregister(struct usb_composite_driver *driver)\n{\n\tusb_gadget_unregister_driver(&driver->gadget_driver);\n}\nEXPORT_SYMBOL_GPL(usb_composite_unregister);\n\n/**\n * usb_composite_setup_continue() - Continue with the control transfer\n * @cdev: the composite device who's control transfer was kept waiting\n *\n * This function must be called by the USB function driver to continue\n * with the control transfer's data/status stage in case it had requested to\n * delay the data/status stages. A USB function's setup handler (e.g. set_alt())\n * can request the composite framework to delay the setup request's data/status\n * stages by returning USB_GADGET_DELAYED_STATUS.\n */\nvoid usb_composite_setup_continue(struct usb_composite_dev *cdev)\n{\n\tint\t\t\tvalue;\n\tstruct usb_request\t*req = cdev->req;\n\tunsigned long\t\tflags;\n\n\tDBG(cdev, \"%s\\n\", __func__);\n\tspin_lock_irqsave(&cdev->lock, flags);\n\n\tif (cdev->delayed_status == 0) {\n\t\tWARN(cdev, \"%s: Unexpected call\\n\", __func__);\n\n\t} else if (--cdev->delayed_status == 0) {\n\t\tDBG(cdev, \"%s: Completing delayed status\\n\", __func__);\n\t\treq->length = 0;\n\t\treq->context = cdev;\n\t\tvalue = composite_ep0_queue(cdev, req, GFP_ATOMIC);\n\t\tif (value < 0) {\n\t\t\tDBG(cdev, \"ep_queue --> %d\\n\", value);\n\t\t\treq->status = 0;\n\t\t\tcomposite_setup_complete(cdev->gadget->ep0, req);\n\t\t}\n\t}\n\n\tspin_unlock_irqrestore(&cdev->lock, flags);\n}\nEXPORT_SYMBOL_GPL(usb_composite_setup_continue);\n\nstatic char *composite_default_mfr(struct usb_gadget *gadget)\n{\n\treturn kasprintf(GFP_KERNEL, \"%s %s with %s\", init_utsname()->sysname,\n\t\t\t init_utsname()->release, gadget->name);\n}\n\nvoid usb_composite_overwrite_options(struct usb_composite_dev *cdev,\n\t\tstruct usb_composite_overwrite *covr)\n{\n\tstruct usb_device_descriptor\t*desc = &cdev->desc;\n\tstruct usb_gadget_strings\t*gstr = cdev->driver->strings[0];\n\tstruct usb_string\t\t*dev_str = gstr->strings;\n\n\tif (covr->idVendor)\n\t\tdesc->idVendor = cpu_to_le16(covr->idVendor);\n\n\tif (covr->idProduct)\n\t\tdesc->idProduct = cpu_to_le16(covr->idProduct);\n\n\tif (covr->bcdDevice)\n\t\tdesc->bcdDevice = cpu_to_le16(covr->bcdDevice);\n\n\tif (covr->serial_number) {\n\t\tdesc->iSerialNumber = dev_str[USB_GADGET_SERIAL_IDX].id;\n\t\tdev_str[USB_GADGET_SERIAL_IDX].s = covr->serial_number;\n\t}\n\tif (covr->manufacturer) {\n\t\tdesc->iManufacturer = dev_str[USB_GADGET_MANUFACTURER_IDX].id;\n\t\tdev_str[USB_GADGET_MANUFACTURER_IDX].s = covr->manufacturer;\n\n\t} else if (!strlen(dev_str[USB_GADGET_MANUFACTURER_IDX].s)) {\n\t\tdesc->iManufacturer = dev_str[USB_GADGET_MANUFACTURER_IDX].id;\n\t\tcdev->def_manufacturer = composite_default_mfr(cdev->gadget);\n\t\tdev_str[USB_GADGET_MANUFACTURER_IDX].s = cdev->def_manufacturer;\n\t}\n\n\tif (covr->product) {\n\t\tdesc->iProduct = dev_str[USB_GADGET_PRODUCT_IDX].id;\n\t\tdev_str[USB_GADGET_PRODUCT_IDX].s = covr->product;\n\t}\n}\nEXPORT_SYMBOL_GPL(usb_composite_overwrite_options);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"David Brownell\");\n"], "fixing_code": ["// SPDX-License-Identifier: GPL-2.0+\n/*\n * composite.c - infrastructure for Composite USB Gadgets\n *\n * Copyright (C) 2006-2008 David Brownell\n */\n\n/* #define VERBOSE_DEBUG */\n\n#include <linux/kallsyms.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/device.h>\n#include <linux/utsname.h>\n#include <linux/bitfield.h>\n\n#include <linux/usb/composite.h>\n#include <linux/usb/otg.h>\n#include <asm/unaligned.h>\n\n#include \"u_os_desc.h\"\n\n/**\n * struct usb_os_string - represents OS String to be reported by a gadget\n * @bLength: total length of the entire descritor, always 0x12\n * @bDescriptorType: USB_DT_STRING\n * @qwSignature: the OS String proper\n * @bMS_VendorCode: code used by the host for subsequent requests\n * @bPad: not used, must be zero\n */\nstruct usb_os_string {\n\t__u8\tbLength;\n\t__u8\tbDescriptorType;\n\t__u8\tqwSignature[OS_STRING_QW_SIGN_LEN];\n\t__u8\tbMS_VendorCode;\n\t__u8\tbPad;\n} __packed;\n\n/*\n * The code in this file is utility code, used to build a gadget driver\n * from one or more \"function\" drivers, one or more \"configuration\"\n * objects, and a \"usb_composite_driver\" by gluing them together along\n * with the relevant device-wide data.\n */\n\nstatic struct usb_gadget_strings **get_containers_gs(\n\t\tstruct usb_gadget_string_container *uc)\n{\n\treturn (struct usb_gadget_strings **)uc->stash;\n}\n\n/**\n * function_descriptors() - get function descriptors for speed\n * @f: the function\n * @speed: the speed\n *\n * Returns the descriptors or NULL if not set.\n */\nstatic struct usb_descriptor_header **\nfunction_descriptors(struct usb_function *f,\n\t\t     enum usb_device_speed speed)\n{\n\tstruct usb_descriptor_header **descriptors;\n\n\t/*\n\t * NOTE: we try to help gadget drivers which might not be setting\n\t * max_speed appropriately.\n\t */\n\n\tswitch (speed) {\n\tcase USB_SPEED_SUPER_PLUS:\n\t\tdescriptors = f->ssp_descriptors;\n\t\tif (descriptors)\n\t\t\tbreak;\n\t\tfallthrough;\n\tcase USB_SPEED_SUPER:\n\t\tdescriptors = f->ss_descriptors;\n\t\tif (descriptors)\n\t\t\tbreak;\n\t\tfallthrough;\n\tcase USB_SPEED_HIGH:\n\t\tdescriptors = f->hs_descriptors;\n\t\tif (descriptors)\n\t\t\tbreak;\n\t\tfallthrough;\n\tdefault:\n\t\tdescriptors = f->fs_descriptors;\n\t}\n\n\t/*\n\t * if we can't find any descriptors at all, then this gadget deserves to\n\t * Oops with a NULL pointer dereference\n\t */\n\n\treturn descriptors;\n}\n\n/**\n * next_desc() - advance to the next desc_type descriptor\n * @t: currect pointer within descriptor array\n * @desc_type: descriptor type\n *\n * Return: next desc_type descriptor or NULL\n *\n * Iterate over @t until either desc_type descriptor found or\n * NULL (that indicates end of list) encountered\n */\nstatic struct usb_descriptor_header**\nnext_desc(struct usb_descriptor_header **t, u8 desc_type)\n{\n\tfor (; *t; t++) {\n\t\tif ((*t)->bDescriptorType == desc_type)\n\t\t\treturn t;\n\t}\n\treturn NULL;\n}\n\n/*\n * for_each_desc() - iterate over desc_type descriptors in the\n * descriptors list\n * @start: pointer within descriptor array.\n * @iter_desc: desc_type descriptor to use as the loop cursor\n * @desc_type: wanted descriptr type\n */\n#define for_each_desc(start, iter_desc, desc_type) \\\n\tfor (iter_desc = next_desc(start, desc_type); \\\n\t     iter_desc; iter_desc = next_desc(iter_desc + 1, desc_type))\n\n/**\n * config_ep_by_speed_and_alt() - configures the given endpoint\n * according to gadget speed.\n * @g: pointer to the gadget\n * @f: usb function\n * @_ep: the endpoint to configure\n * @alt: alternate setting number\n *\n * Return: error code, 0 on success\n *\n * This function chooses the right descriptors for a given\n * endpoint according to gadget speed and saves it in the\n * endpoint desc field. If the endpoint already has a descriptor\n * assigned to it - overwrites it with currently corresponding\n * descriptor. The endpoint maxpacket field is updated according\n * to the chosen descriptor.\n * Note: the supplied function should hold all the descriptors\n * for supported speeds\n */\nint config_ep_by_speed_and_alt(struct usb_gadget *g,\n\t\t\t\tstruct usb_function *f,\n\t\t\t\tstruct usb_ep *_ep,\n\t\t\t\tu8 alt)\n{\n\tstruct usb_endpoint_descriptor *chosen_desc = NULL;\n\tstruct usb_interface_descriptor *int_desc = NULL;\n\tstruct usb_descriptor_header **speed_desc = NULL;\n\n\tstruct usb_ss_ep_comp_descriptor *comp_desc = NULL;\n\tint want_comp_desc = 0;\n\n\tstruct usb_descriptor_header **d_spd; /* cursor for speed desc */\n\tstruct usb_composite_dev *cdev;\n\tbool incomplete_desc = false;\n\n\tif (!g || !f || !_ep)\n\t\treturn -EIO;\n\n\t/* select desired speed */\n\tswitch (g->speed) {\n\tcase USB_SPEED_SUPER_PLUS:\n\t\tif (gadget_is_superspeed_plus(g)) {\n\t\t\tif (f->ssp_descriptors) {\n\t\t\t\tspeed_desc = f->ssp_descriptors;\n\t\t\t\twant_comp_desc = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tincomplete_desc = true;\n\t\t}\n\t\tfallthrough;\n\tcase USB_SPEED_SUPER:\n\t\tif (gadget_is_superspeed(g)) {\n\t\t\tif (f->ss_descriptors) {\n\t\t\t\tspeed_desc = f->ss_descriptors;\n\t\t\t\twant_comp_desc = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tincomplete_desc = true;\n\t\t}\n\t\tfallthrough;\n\tcase USB_SPEED_HIGH:\n\t\tif (gadget_is_dualspeed(g)) {\n\t\t\tif (f->hs_descriptors) {\n\t\t\t\tspeed_desc = f->hs_descriptors;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tincomplete_desc = true;\n\t\t}\n\t\tfallthrough;\n\tdefault:\n\t\tspeed_desc = f->fs_descriptors;\n\t}\n\n\tcdev = get_gadget_data(g);\n\tif (incomplete_desc)\n\t\tWARNING(cdev,\n\t\t\t\"%s doesn't hold the descriptors for current speed\\n\",\n\t\t\tf->name);\n\n\t/* find correct alternate setting descriptor */\n\tfor_each_desc(speed_desc, d_spd, USB_DT_INTERFACE) {\n\t\tint_desc = (struct usb_interface_descriptor *)*d_spd;\n\n\t\tif (int_desc->bAlternateSetting == alt) {\n\t\t\tspeed_desc = d_spd;\n\t\t\tgoto intf_found;\n\t\t}\n\t}\n\treturn -EIO;\n\nintf_found:\n\t/* find descriptors */\n\tfor_each_desc(speed_desc, d_spd, USB_DT_ENDPOINT) {\n\t\tchosen_desc = (struct usb_endpoint_descriptor *)*d_spd;\n\t\tif (chosen_desc->bEndpointAddress == _ep->address)\n\t\t\tgoto ep_found;\n\t}\n\treturn -EIO;\n\nep_found:\n\t/* commit results */\n\t_ep->maxpacket = usb_endpoint_maxp(chosen_desc);\n\t_ep->desc = chosen_desc;\n\t_ep->comp_desc = NULL;\n\t_ep->maxburst = 0;\n\t_ep->mult = 1;\n\n\tif (g->speed == USB_SPEED_HIGH && (usb_endpoint_xfer_isoc(_ep->desc) ||\n\t\t\t\tusb_endpoint_xfer_int(_ep->desc)))\n\t\t_ep->mult = usb_endpoint_maxp_mult(_ep->desc);\n\n\tif (!want_comp_desc)\n\t\treturn 0;\n\n\t/*\n\t * Companion descriptor should follow EP descriptor\n\t * USB 3.0 spec, #9.6.7\n\t */\n\tcomp_desc = (struct usb_ss_ep_comp_descriptor *)*(++d_spd);\n\tif (!comp_desc ||\n\t    (comp_desc->bDescriptorType != USB_DT_SS_ENDPOINT_COMP))\n\t\treturn -EIO;\n\t_ep->comp_desc = comp_desc;\n\tif (g->speed >= USB_SPEED_SUPER) {\n\t\tswitch (usb_endpoint_type(_ep->desc)) {\n\t\tcase USB_ENDPOINT_XFER_ISOC:\n\t\t\t/* mult: bits 1:0 of bmAttributes */\n\t\t\t_ep->mult = (comp_desc->bmAttributes & 0x3) + 1;\n\t\t\tfallthrough;\n\t\tcase USB_ENDPOINT_XFER_BULK:\n\t\tcase USB_ENDPOINT_XFER_INT:\n\t\t\t_ep->maxburst = comp_desc->bMaxBurst + 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (comp_desc->bMaxBurst != 0)\n\t\t\t\tERROR(cdev, \"ep0 bMaxBurst must be 0\\n\");\n\t\t\t_ep->maxburst = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(config_ep_by_speed_and_alt);\n\n/**\n * config_ep_by_speed() - configures the given endpoint\n * according to gadget speed.\n * @g: pointer to the gadget\n * @f: usb function\n * @_ep: the endpoint to configure\n *\n * Return: error code, 0 on success\n *\n * This function chooses the right descriptors for a given\n * endpoint according to gadget speed and saves it in the\n * endpoint desc field. If the endpoint already has a descriptor\n * assigned to it - overwrites it with currently corresponding\n * descriptor. The endpoint maxpacket field is updated according\n * to the chosen descriptor.\n * Note: the supplied function should hold all the descriptors\n * for supported speeds\n */\nint config_ep_by_speed(struct usb_gadget *g,\n\t\t\tstruct usb_function *f,\n\t\t\tstruct usb_ep *_ep)\n{\n\treturn config_ep_by_speed_and_alt(g, f, _ep, 0);\n}\nEXPORT_SYMBOL_GPL(config_ep_by_speed);\n\n/**\n * usb_add_function() - add a function to a configuration\n * @config: the configuration\n * @function: the function being added\n * Context: single threaded during gadget setup\n *\n * After initialization, each configuration must have one or more\n * functions added to it.  Adding a function involves calling its @bind()\n * method to allocate resources such as interface and string identifiers\n * and endpoints.\n *\n * This function returns the value of the function's bind(), which is\n * zero for success else a negative errno value.\n */\nint usb_add_function(struct usb_configuration *config,\n\t\tstruct usb_function *function)\n{\n\tint\tvalue = -EINVAL;\n\n\tDBG(config->cdev, \"adding '%s'/%p to config '%s'/%p\\n\",\n\t\t\tfunction->name, function,\n\t\t\tconfig->label, config);\n\n\tif (!function->set_alt || !function->disable)\n\t\tgoto done;\n\n\tfunction->config = config;\n\tlist_add_tail(&function->list, &config->functions);\n\n\tif (function->bind_deactivated) {\n\t\tvalue = usb_function_deactivate(function);\n\t\tif (value)\n\t\t\tgoto done;\n\t}\n\n\t/* REVISIT *require* function->bind? */\n\tif (function->bind) {\n\t\tvalue = function->bind(config, function);\n\t\tif (value < 0) {\n\t\t\tlist_del(&function->list);\n\t\t\tfunction->config = NULL;\n\t\t}\n\t} else\n\t\tvalue = 0;\n\n\t/* We allow configurations that don't work at both speeds.\n\t * If we run into a lowspeed Linux system, treat it the same\n\t * as full speed ... it's the function drivers that will need\n\t * to avoid bulk and ISO transfers.\n\t */\n\tif (!config->fullspeed && function->fs_descriptors)\n\t\tconfig->fullspeed = true;\n\tif (!config->highspeed && function->hs_descriptors)\n\t\tconfig->highspeed = true;\n\tif (!config->superspeed && function->ss_descriptors)\n\t\tconfig->superspeed = true;\n\tif (!config->superspeed_plus && function->ssp_descriptors)\n\t\tconfig->superspeed_plus = true;\n\ndone:\n\tif (value)\n\t\tDBG(config->cdev, \"adding '%s'/%p --> %d\\n\",\n\t\t\t\tfunction->name, function, value);\n\treturn value;\n}\nEXPORT_SYMBOL_GPL(usb_add_function);\n\nvoid usb_remove_function(struct usb_configuration *c, struct usb_function *f)\n{\n\tif (f->disable)\n\t\tf->disable(f);\n\n\tbitmap_zero(f->endpoints, 32);\n\tlist_del(&f->list);\n\tif (f->unbind)\n\t\tf->unbind(c, f);\n\n\tif (f->bind_deactivated)\n\t\tusb_function_activate(f);\n}\nEXPORT_SYMBOL_GPL(usb_remove_function);\n\n/**\n * usb_function_deactivate - prevent function and gadget enumeration\n * @function: the function that isn't yet ready to respond\n *\n * Blocks response of the gadget driver to host enumeration by\n * preventing the data line pullup from being activated.  This is\n * normally called during @bind() processing to change from the\n * initial \"ready to respond\" state, or when a required resource\n * becomes available.\n *\n * For example, drivers that serve as a passthrough to a userspace\n * daemon can block enumeration unless that daemon (such as an OBEX,\n * MTP, or print server) is ready to handle host requests.\n *\n * Not all systems support software control of their USB peripheral\n * data pullups.\n *\n * Returns zero on success, else negative errno.\n */\nint usb_function_deactivate(struct usb_function *function)\n{\n\tstruct usb_composite_dev\t*cdev = function->config->cdev;\n\tunsigned long\t\t\tflags;\n\tint\t\t\t\tstatus = 0;\n\n\tspin_lock_irqsave(&cdev->lock, flags);\n\n\tif (cdev->deactivations == 0) {\n\t\tspin_unlock_irqrestore(&cdev->lock, flags);\n\t\tstatus = usb_gadget_deactivate(cdev->gadget);\n\t\tspin_lock_irqsave(&cdev->lock, flags);\n\t}\n\tif (status == 0)\n\t\tcdev->deactivations++;\n\n\tspin_unlock_irqrestore(&cdev->lock, flags);\n\treturn status;\n}\nEXPORT_SYMBOL_GPL(usb_function_deactivate);\n\n/**\n * usb_function_activate - allow function and gadget enumeration\n * @function: function on which usb_function_activate() was called\n *\n * Reverses effect of usb_function_deactivate().  If no more functions\n * are delaying their activation, the gadget driver will respond to\n * host enumeration procedures.\n *\n * Returns zero on success, else negative errno.\n */\nint usb_function_activate(struct usb_function *function)\n{\n\tstruct usb_composite_dev\t*cdev = function->config->cdev;\n\tunsigned long\t\t\tflags;\n\tint\t\t\t\tstatus = 0;\n\n\tspin_lock_irqsave(&cdev->lock, flags);\n\n\tif (WARN_ON(cdev->deactivations == 0))\n\t\tstatus = -EINVAL;\n\telse {\n\t\tcdev->deactivations--;\n\t\tif (cdev->deactivations == 0) {\n\t\t\tspin_unlock_irqrestore(&cdev->lock, flags);\n\t\t\tstatus = usb_gadget_activate(cdev->gadget);\n\t\t\tspin_lock_irqsave(&cdev->lock, flags);\n\t\t}\n\t}\n\n\tspin_unlock_irqrestore(&cdev->lock, flags);\n\treturn status;\n}\nEXPORT_SYMBOL_GPL(usb_function_activate);\n\n/**\n * usb_interface_id() - allocate an unused interface ID\n * @config: configuration associated with the interface\n * @function: function handling the interface\n * Context: single threaded during gadget setup\n *\n * usb_interface_id() is called from usb_function.bind() callbacks to\n * allocate new interface IDs.  The function driver will then store that\n * ID in interface, association, CDC union, and other descriptors.  It\n * will also handle any control requests targeted at that interface,\n * particularly changing its altsetting via set_alt().  There may\n * also be class-specific or vendor-specific requests to handle.\n *\n * All interface identifier should be allocated using this routine, to\n * ensure that for example different functions don't wrongly assign\n * different meanings to the same identifier.  Note that since interface\n * identifiers are configuration-specific, functions used in more than\n * one configuration (or more than once in a given configuration) need\n * multiple versions of the relevant descriptors.\n *\n * Returns the interface ID which was allocated; or -ENODEV if no\n * more interface IDs can be allocated.\n */\nint usb_interface_id(struct usb_configuration *config,\n\t\tstruct usb_function *function)\n{\n\tunsigned id = config->next_interface_id;\n\n\tif (id < MAX_CONFIG_INTERFACES) {\n\t\tconfig->interface[id] = function;\n\t\tconfig->next_interface_id = id + 1;\n\t\treturn id;\n\t}\n\treturn -ENODEV;\n}\nEXPORT_SYMBOL_GPL(usb_interface_id);\n\nstatic u8 encode_bMaxPower(enum usb_device_speed speed,\n\t\tstruct usb_configuration *c)\n{\n\tunsigned val;\n\n\tif (c->MaxPower || (c->bmAttributes & USB_CONFIG_ATT_SELFPOWER))\n\t\tval = c->MaxPower;\n\telse\n\t\tval = CONFIG_USB_GADGET_VBUS_DRAW;\n\tif (!val)\n\t\treturn 0;\n\tif (speed < USB_SPEED_SUPER)\n\t\treturn min(val, 500U) / 2;\n\telse\n\t\t/*\n\t\t * USB 3.x supports up to 900mA, but since 900 isn't divisible\n\t\t * by 8 the integral division will effectively cap to 896mA.\n\t\t */\n\t\treturn min(val, 900U) / 8;\n}\n\nstatic int config_buf(struct usb_configuration *config,\n\t\tenum usb_device_speed speed, void *buf, u8 type)\n{\n\tstruct usb_config_descriptor\t*c = buf;\n\tvoid\t\t\t\t*next = buf + USB_DT_CONFIG_SIZE;\n\tint\t\t\t\tlen;\n\tstruct usb_function\t\t*f;\n\tint\t\t\t\tstatus;\n\n\tlen = USB_COMP_EP0_BUFSIZ - USB_DT_CONFIG_SIZE;\n\t/* write the config descriptor */\n\tc = buf;\n\tc->bLength = USB_DT_CONFIG_SIZE;\n\tc->bDescriptorType = type;\n\t/* wTotalLength is written later */\n\tc->bNumInterfaces = config->next_interface_id;\n\tc->bConfigurationValue = config->bConfigurationValue;\n\tc->iConfiguration = config->iConfiguration;\n\tc->bmAttributes = USB_CONFIG_ATT_ONE | config->bmAttributes;\n\tc->bMaxPower = encode_bMaxPower(speed, config);\n\n\t/* There may be e.g. OTG descriptors */\n\tif (config->descriptors) {\n\t\tstatus = usb_descriptor_fillbuf(next, len,\n\t\t\t\tconfig->descriptors);\n\t\tif (status < 0)\n\t\t\treturn status;\n\t\tlen -= status;\n\t\tnext += status;\n\t}\n\n\t/* add each function's descriptors */\n\tlist_for_each_entry(f, &config->functions, list) {\n\t\tstruct usb_descriptor_header **descriptors;\n\n\t\tdescriptors = function_descriptors(f, speed);\n\t\tif (!descriptors)\n\t\t\tcontinue;\n\t\tstatus = usb_descriptor_fillbuf(next, len,\n\t\t\t(const struct usb_descriptor_header **) descriptors);\n\t\tif (status < 0)\n\t\t\treturn status;\n\t\tlen -= status;\n\t\tnext += status;\n\t}\n\n\tlen = next - buf;\n\tc->wTotalLength = cpu_to_le16(len);\n\treturn len;\n}\n\nstatic int config_desc(struct usb_composite_dev *cdev, unsigned w_value)\n{\n\tstruct usb_gadget\t\t*gadget = cdev->gadget;\n\tstruct usb_configuration\t*c;\n\tstruct list_head\t\t*pos;\n\tu8\t\t\t\ttype = w_value >> 8;\n\tenum usb_device_speed\t\tspeed = USB_SPEED_UNKNOWN;\n\n\tif (gadget->speed >= USB_SPEED_SUPER)\n\t\tspeed = gadget->speed;\n\telse if (gadget_is_dualspeed(gadget)) {\n\t\tint\ths = 0;\n\t\tif (gadget->speed == USB_SPEED_HIGH)\n\t\t\ths = 1;\n\t\tif (type == USB_DT_OTHER_SPEED_CONFIG)\n\t\t\ths = !hs;\n\t\tif (hs)\n\t\t\tspeed = USB_SPEED_HIGH;\n\n\t}\n\n\t/* This is a lookup by config *INDEX* */\n\tw_value &= 0xff;\n\n\tpos = &cdev->configs;\n\tc = cdev->os_desc_config;\n\tif (c)\n\t\tgoto check_config;\n\n\twhile ((pos = pos->next) !=  &cdev->configs) {\n\t\tc = list_entry(pos, typeof(*c), list);\n\n\t\t/* skip OS Descriptors config which is handled separately */\n\t\tif (c == cdev->os_desc_config)\n\t\t\tcontinue;\n\ncheck_config:\n\t\t/* ignore configs that won't work at this speed */\n\t\tswitch (speed) {\n\t\tcase USB_SPEED_SUPER_PLUS:\n\t\t\tif (!c->superspeed_plus)\n\t\t\t\tcontinue;\n\t\t\tbreak;\n\t\tcase USB_SPEED_SUPER:\n\t\t\tif (!c->superspeed)\n\t\t\t\tcontinue;\n\t\t\tbreak;\n\t\tcase USB_SPEED_HIGH:\n\t\t\tif (!c->highspeed)\n\t\t\t\tcontinue;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (!c->fullspeed)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tif (w_value == 0)\n\t\t\treturn config_buf(c, speed, cdev->req->buf, type);\n\t\tw_value--;\n\t}\n\treturn -EINVAL;\n}\n\nstatic int count_configs(struct usb_composite_dev *cdev, unsigned type)\n{\n\tstruct usb_gadget\t\t*gadget = cdev->gadget;\n\tstruct usb_configuration\t*c;\n\tunsigned\t\t\tcount = 0;\n\tint\t\t\t\ths = 0;\n\tint\t\t\t\tss = 0;\n\tint\t\t\t\tssp = 0;\n\n\tif (gadget_is_dualspeed(gadget)) {\n\t\tif (gadget->speed == USB_SPEED_HIGH)\n\t\t\ths = 1;\n\t\tif (gadget->speed == USB_SPEED_SUPER)\n\t\t\tss = 1;\n\t\tif (gadget->speed == USB_SPEED_SUPER_PLUS)\n\t\t\tssp = 1;\n\t\tif (type == USB_DT_DEVICE_QUALIFIER)\n\t\t\ths = !hs;\n\t}\n\tlist_for_each_entry(c, &cdev->configs, list) {\n\t\t/* ignore configs that won't work at this speed */\n\t\tif (ssp) {\n\t\t\tif (!c->superspeed_plus)\n\t\t\t\tcontinue;\n\t\t} else if (ss) {\n\t\t\tif (!c->superspeed)\n\t\t\t\tcontinue;\n\t\t} else if (hs) {\n\t\t\tif (!c->highspeed)\n\t\t\t\tcontinue;\n\t\t} else {\n\t\t\tif (!c->fullspeed)\n\t\t\t\tcontinue;\n\t\t}\n\t\tcount++;\n\t}\n\treturn count;\n}\n\n/**\n * bos_desc() - prepares the BOS descriptor.\n * @cdev: pointer to usb_composite device to generate the bos\n *\tdescriptor for\n *\n * This function generates the BOS (Binary Device Object)\n * descriptor and its device capabilities descriptors. The BOS\n * descriptor should be supported by a SuperSpeed device.\n */\nstatic int bos_desc(struct usb_composite_dev *cdev)\n{\n\tstruct usb_ext_cap_descriptor\t*usb_ext;\n\tstruct usb_dcd_config_params\tdcd_config_params;\n\tstruct usb_bos_descriptor\t*bos = cdev->req->buf;\n\tunsigned int\t\t\tbesl = 0;\n\n\tbos->bLength = USB_DT_BOS_SIZE;\n\tbos->bDescriptorType = USB_DT_BOS;\n\n\tbos->wTotalLength = cpu_to_le16(USB_DT_BOS_SIZE);\n\tbos->bNumDeviceCaps = 0;\n\n\t/* Get Controller configuration */\n\tif (cdev->gadget->ops->get_config_params) {\n\t\tcdev->gadget->ops->get_config_params(cdev->gadget,\n\t\t\t\t\t\t     &dcd_config_params);\n\t} else {\n\t\tdcd_config_params.besl_baseline =\n\t\t\tUSB_DEFAULT_BESL_UNSPECIFIED;\n\t\tdcd_config_params.besl_deep =\n\t\t\tUSB_DEFAULT_BESL_UNSPECIFIED;\n\t\tdcd_config_params.bU1devExitLat =\n\t\t\tUSB_DEFAULT_U1_DEV_EXIT_LAT;\n\t\tdcd_config_params.bU2DevExitLat =\n\t\t\tcpu_to_le16(USB_DEFAULT_U2_DEV_EXIT_LAT);\n\t}\n\n\tif (dcd_config_params.besl_baseline != USB_DEFAULT_BESL_UNSPECIFIED)\n\t\tbesl = USB_BESL_BASELINE_VALID |\n\t\t\tUSB_SET_BESL_BASELINE(dcd_config_params.besl_baseline);\n\n\tif (dcd_config_params.besl_deep != USB_DEFAULT_BESL_UNSPECIFIED)\n\t\tbesl |= USB_BESL_DEEP_VALID |\n\t\t\tUSB_SET_BESL_DEEP(dcd_config_params.besl_deep);\n\n\t/*\n\t * A SuperSpeed device shall include the USB2.0 extension descriptor\n\t * and shall support LPM when operating in USB2.0 HS mode.\n\t */\n\tusb_ext = cdev->req->buf + le16_to_cpu(bos->wTotalLength);\n\tbos->bNumDeviceCaps++;\n\tle16_add_cpu(&bos->wTotalLength, USB_DT_USB_EXT_CAP_SIZE);\n\tusb_ext->bLength = USB_DT_USB_EXT_CAP_SIZE;\n\tusb_ext->bDescriptorType = USB_DT_DEVICE_CAPABILITY;\n\tusb_ext->bDevCapabilityType = USB_CAP_TYPE_EXT;\n\tusb_ext->bmAttributes = cpu_to_le32(USB_LPM_SUPPORT |\n\t\t\t\t\t    USB_BESL_SUPPORT | besl);\n\n\t/*\n\t * The Superspeed USB Capability descriptor shall be implemented by all\n\t * SuperSpeed devices.\n\t */\n\tif (gadget_is_superspeed(cdev->gadget)) {\n\t\tstruct usb_ss_cap_descriptor *ss_cap;\n\n\t\tss_cap = cdev->req->buf + le16_to_cpu(bos->wTotalLength);\n\t\tbos->bNumDeviceCaps++;\n\t\tle16_add_cpu(&bos->wTotalLength, USB_DT_USB_SS_CAP_SIZE);\n\t\tss_cap->bLength = USB_DT_USB_SS_CAP_SIZE;\n\t\tss_cap->bDescriptorType = USB_DT_DEVICE_CAPABILITY;\n\t\tss_cap->bDevCapabilityType = USB_SS_CAP_TYPE;\n\t\tss_cap->bmAttributes = 0; /* LTM is not supported yet */\n\t\tss_cap->wSpeedSupported = cpu_to_le16(USB_LOW_SPEED_OPERATION |\n\t\t\t\t\t\t      USB_FULL_SPEED_OPERATION |\n\t\t\t\t\t\t      USB_HIGH_SPEED_OPERATION |\n\t\t\t\t\t\t      USB_5GBPS_OPERATION);\n\t\tss_cap->bFunctionalitySupport = USB_LOW_SPEED_OPERATION;\n\t\tss_cap->bU1devExitLat = dcd_config_params.bU1devExitLat;\n\t\tss_cap->bU2DevExitLat = dcd_config_params.bU2DevExitLat;\n\t}\n\n\t/* The SuperSpeedPlus USB Device Capability descriptor */\n\tif (gadget_is_superspeed_plus(cdev->gadget)) {\n\t\tstruct usb_ssp_cap_descriptor *ssp_cap;\n\t\tu8 ssac = 1;\n\t\tu8 ssic;\n\t\tint i;\n\n\t\tif (cdev->gadget->max_ssp_rate == USB_SSP_GEN_2x2)\n\t\t\tssac = 3;\n\n\t\t/*\n\t\t * Paired RX and TX sublink speed attributes share\n\t\t * the same SSID.\n\t\t */\n\t\tssic = (ssac + 1) / 2 - 1;\n\n\t\tssp_cap = cdev->req->buf + le16_to_cpu(bos->wTotalLength);\n\t\tbos->bNumDeviceCaps++;\n\n\t\tle16_add_cpu(&bos->wTotalLength, USB_DT_USB_SSP_CAP_SIZE(ssac));\n\t\tssp_cap->bLength = USB_DT_USB_SSP_CAP_SIZE(ssac);\n\t\tssp_cap->bDescriptorType = USB_DT_DEVICE_CAPABILITY;\n\t\tssp_cap->bDevCapabilityType = USB_SSP_CAP_TYPE;\n\t\tssp_cap->bReserved = 0;\n\t\tssp_cap->wReserved = 0;\n\n\t\tssp_cap->bmAttributes =\n\t\t\tcpu_to_le32(FIELD_PREP(USB_SSP_SUBLINK_SPEED_ATTRIBS, ssac) |\n\t\t\t\t    FIELD_PREP(USB_SSP_SUBLINK_SPEED_IDS, ssic));\n\n\t\tssp_cap->wFunctionalitySupport =\n\t\t\tcpu_to_le16(FIELD_PREP(USB_SSP_MIN_SUBLINK_SPEED_ATTRIBUTE_ID, 0) |\n\t\t\t\t    FIELD_PREP(USB_SSP_MIN_RX_LANE_COUNT, 1) |\n\t\t\t\t    FIELD_PREP(USB_SSP_MIN_TX_LANE_COUNT, 1));\n\n\t\t/*\n\t\t * Use 1 SSID if the gadget supports up to gen2x1 or not\n\t\t * specified:\n\t\t * - SSID 0 for symmetric RX/TX sublink speed of 10 Gbps.\n\t\t *\n\t\t * Use 1 SSID if the gadget supports up to gen1x2:\n\t\t * - SSID 0 for symmetric RX/TX sublink speed of 5 Gbps.\n\t\t *\n\t\t * Use 2 SSIDs if the gadget supports up to gen2x2:\n\t\t * - SSID 0 for symmetric RX/TX sublink speed of 5 Gbps.\n\t\t * - SSID 1 for symmetric RX/TX sublink speed of 10 Gbps.\n\t\t */\n\t\tfor (i = 0; i < ssac + 1; i++) {\n\t\t\tu8 ssid;\n\t\t\tu8 mantissa;\n\t\t\tu8 type;\n\n\t\t\tssid = i >> 1;\n\n\t\t\tif (cdev->gadget->max_ssp_rate == USB_SSP_GEN_2x1 ||\n\t\t\t    cdev->gadget->max_ssp_rate == USB_SSP_GEN_UNKNOWN)\n\t\t\t\tmantissa = 10;\n\t\t\telse\n\t\t\t\tmantissa = 5 << ssid;\n\n\t\t\tif (i % 2)\n\t\t\t\ttype = USB_SSP_SUBLINK_SPEED_ST_SYM_TX;\n\t\t\telse\n\t\t\t\ttype = USB_SSP_SUBLINK_SPEED_ST_SYM_RX;\n\n\t\t\tssp_cap->bmSublinkSpeedAttr[i] =\n\t\t\t\tcpu_to_le32(FIELD_PREP(USB_SSP_SUBLINK_SPEED_SSID, ssid) |\n\t\t\t\t\t    FIELD_PREP(USB_SSP_SUBLINK_SPEED_LSE,\n\t\t\t\t\t\t       USB_SSP_SUBLINK_SPEED_LSE_GBPS) |\n\t\t\t\t\t    FIELD_PREP(USB_SSP_SUBLINK_SPEED_ST, type) |\n\t\t\t\t\t    FIELD_PREP(USB_SSP_SUBLINK_SPEED_LP,\n\t\t\t\t\t\t       USB_SSP_SUBLINK_SPEED_LP_SSP) |\n\t\t\t\t\t    FIELD_PREP(USB_SSP_SUBLINK_SPEED_LSM, mantissa));\n\t\t}\n\t}\n\n\treturn le16_to_cpu(bos->wTotalLength);\n}\n\nstatic void device_qual(struct usb_composite_dev *cdev)\n{\n\tstruct usb_qualifier_descriptor\t*qual = cdev->req->buf;\n\n\tqual->bLength = sizeof(*qual);\n\tqual->bDescriptorType = USB_DT_DEVICE_QUALIFIER;\n\t/* POLICY: same bcdUSB and device type info at both speeds */\n\tqual->bcdUSB = cdev->desc.bcdUSB;\n\tqual->bDeviceClass = cdev->desc.bDeviceClass;\n\tqual->bDeviceSubClass = cdev->desc.bDeviceSubClass;\n\tqual->bDeviceProtocol = cdev->desc.bDeviceProtocol;\n\t/* ASSUME same EP0 fifo size at both speeds */\n\tqual->bMaxPacketSize0 = cdev->gadget->ep0->maxpacket;\n\tqual->bNumConfigurations = count_configs(cdev, USB_DT_DEVICE_QUALIFIER);\n\tqual->bRESERVED = 0;\n}\n\n/*-------------------------------------------------------------------------*/\n\nstatic void reset_config(struct usb_composite_dev *cdev)\n{\n\tstruct usb_function\t\t*f;\n\n\tDBG(cdev, \"reset config\\n\");\n\n\tlist_for_each_entry(f, &cdev->config->functions, list) {\n\t\tif (f->disable)\n\t\t\tf->disable(f);\n\n\t\tbitmap_zero(f->endpoints, 32);\n\t}\n\tcdev->config = NULL;\n\tcdev->delayed_status = 0;\n}\n\nstatic int set_config(struct usb_composite_dev *cdev,\n\t\tconst struct usb_ctrlrequest *ctrl, unsigned number)\n{\n\tstruct usb_gadget\t*gadget = cdev->gadget;\n\tstruct usb_configuration *c = NULL;\n\tint\t\t\tresult = -EINVAL;\n\tunsigned\t\tpower = gadget_is_otg(gadget) ? 8 : 100;\n\tint\t\t\ttmp;\n\n\tif (number) {\n\t\tlist_for_each_entry(c, &cdev->configs, list) {\n\t\t\tif (c->bConfigurationValue == number) {\n\t\t\t\t/*\n\t\t\t\t * We disable the FDs of the previous\n\t\t\t\t * configuration only if the new configuration\n\t\t\t\t * is a valid one\n\t\t\t\t */\n\t\t\t\tif (cdev->config)\n\t\t\t\t\treset_config(cdev);\n\t\t\t\tresult = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (result < 0)\n\t\t\tgoto done;\n\t} else { /* Zero configuration value - need to reset the config */\n\t\tif (cdev->config)\n\t\t\treset_config(cdev);\n\t\tresult = 0;\n\t}\n\n\tDBG(cdev, \"%s config #%d: %s\\n\",\n\t    usb_speed_string(gadget->speed),\n\t    number, c ? c->label : \"unconfigured\");\n\n\tif (!c)\n\t\tgoto done;\n\n\tusb_gadget_set_state(gadget, USB_STATE_CONFIGURED);\n\tcdev->config = c;\n\n\t/* Initialize all interfaces by setting them to altsetting zero. */\n\tfor (tmp = 0; tmp < MAX_CONFIG_INTERFACES; tmp++) {\n\t\tstruct usb_function\t*f = c->interface[tmp];\n\t\tstruct usb_descriptor_header **descriptors;\n\n\t\tif (!f)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Record which endpoints are used by the function. This is used\n\t\t * to dispatch control requests targeted at that endpoint to the\n\t\t * function's setup callback instead of the current\n\t\t * configuration's setup callback.\n\t\t */\n\t\tdescriptors = function_descriptors(f, gadget->speed);\n\n\t\tfor (; *descriptors; ++descriptors) {\n\t\t\tstruct usb_endpoint_descriptor *ep;\n\t\t\tint addr;\n\n\t\t\tif ((*descriptors)->bDescriptorType != USB_DT_ENDPOINT)\n\t\t\t\tcontinue;\n\n\t\t\tep = (struct usb_endpoint_descriptor *)*descriptors;\n\t\t\taddr = ((ep->bEndpointAddress & 0x80) >> 3)\n\t\t\t     |  (ep->bEndpointAddress & 0x0f);\n\t\t\tset_bit(addr, f->endpoints);\n\t\t}\n\n\t\tresult = f->set_alt(f, tmp, 0);\n\t\tif (result < 0) {\n\t\t\tDBG(cdev, \"interface %d (%s/%p) alt 0 --> %d\\n\",\n\t\t\t\t\ttmp, f->name, f, result);\n\n\t\t\treset_config(cdev);\n\t\t\tgoto done;\n\t\t}\n\n\t\tif (result == USB_GADGET_DELAYED_STATUS) {\n\t\t\tDBG(cdev,\n\t\t\t \"%s: interface %d (%s) requested delayed status\\n\",\n\t\t\t\t\t__func__, tmp, f->name);\n\t\t\tcdev->delayed_status++;\n\t\t\tDBG(cdev, \"delayed_status count %d\\n\",\n\t\t\t\t\tcdev->delayed_status);\n\t\t}\n\t}\n\n\t/* when we return, be sure our power usage is valid */\n\tif (c->MaxPower || (c->bmAttributes & USB_CONFIG_ATT_SELFPOWER))\n\t\tpower = c->MaxPower;\n\telse\n\t\tpower = CONFIG_USB_GADGET_VBUS_DRAW;\n\n\tif (gadget->speed < USB_SPEED_SUPER)\n\t\tpower = min(power, 500U);\n\telse\n\t\tpower = min(power, 900U);\ndone:\n\tif (power <= USB_SELF_POWER_VBUS_MAX_DRAW)\n\t\tusb_gadget_set_selfpowered(gadget);\n\telse\n\t\tusb_gadget_clear_selfpowered(gadget);\n\n\tusb_gadget_vbus_draw(gadget, power);\n\tif (result >= 0 && cdev->delayed_status)\n\t\tresult = USB_GADGET_DELAYED_STATUS;\n\treturn result;\n}\n\nint usb_add_config_only(struct usb_composite_dev *cdev,\n\t\tstruct usb_configuration *config)\n{\n\tstruct usb_configuration *c;\n\n\tif (!config->bConfigurationValue)\n\t\treturn -EINVAL;\n\n\t/* Prevent duplicate configuration identifiers */\n\tlist_for_each_entry(c, &cdev->configs, list) {\n\t\tif (c->bConfigurationValue == config->bConfigurationValue)\n\t\t\treturn -EBUSY;\n\t}\n\n\tconfig->cdev = cdev;\n\tlist_add_tail(&config->list, &cdev->configs);\n\n\tINIT_LIST_HEAD(&config->functions);\n\tconfig->next_interface_id = 0;\n\tmemset(config->interface, 0, sizeof(config->interface));\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(usb_add_config_only);\n\n/**\n * usb_add_config() - add a configuration to a device.\n * @cdev: wraps the USB gadget\n * @config: the configuration, with bConfigurationValue assigned\n * @bind: the configuration's bind function\n * Context: single threaded during gadget setup\n *\n * One of the main tasks of a composite @bind() routine is to\n * add each of the configurations it supports, using this routine.\n *\n * This function returns the value of the configuration's @bind(), which\n * is zero for success else a negative errno value.  Binding configurations\n * assigns global resources including string IDs, and per-configuration\n * resources such as interface IDs and endpoints.\n */\nint usb_add_config(struct usb_composite_dev *cdev,\n\t\tstruct usb_configuration *config,\n\t\tint (*bind)(struct usb_configuration *))\n{\n\tint\t\t\t\tstatus = -EINVAL;\n\n\tif (!bind)\n\t\tgoto done;\n\n\tDBG(cdev, \"adding config #%u '%s'/%p\\n\",\n\t\t\tconfig->bConfigurationValue,\n\t\t\tconfig->label, config);\n\n\tstatus = usb_add_config_only(cdev, config);\n\tif (status)\n\t\tgoto done;\n\n\tstatus = bind(config);\n\tif (status < 0) {\n\t\twhile (!list_empty(&config->functions)) {\n\t\t\tstruct usb_function\t\t*f;\n\n\t\t\tf = list_first_entry(&config->functions,\n\t\t\t\t\tstruct usb_function, list);\n\t\t\tlist_del(&f->list);\n\t\t\tif (f->unbind) {\n\t\t\t\tDBG(cdev, \"unbind function '%s'/%p\\n\",\n\t\t\t\t\tf->name, f);\n\t\t\t\tf->unbind(config, f);\n\t\t\t\t/* may free memory for \"f\" */\n\t\t\t}\n\t\t}\n\t\tlist_del(&config->list);\n\t\tconfig->cdev = NULL;\n\t} else {\n\t\tunsigned\ti;\n\n\t\tDBG(cdev, \"cfg %d/%p speeds:%s%s%s%s\\n\",\n\t\t\tconfig->bConfigurationValue, config,\n\t\t\tconfig->superspeed_plus ? \" superplus\" : \"\",\n\t\t\tconfig->superspeed ? \" super\" : \"\",\n\t\t\tconfig->highspeed ? \" high\" : \"\",\n\t\t\tconfig->fullspeed\n\t\t\t\t? (gadget_is_dualspeed(cdev->gadget)\n\t\t\t\t\t? \" full\"\n\t\t\t\t\t: \" full/low\")\n\t\t\t\t: \"\");\n\n\t\tfor (i = 0; i < MAX_CONFIG_INTERFACES; i++) {\n\t\t\tstruct usb_function\t*f = config->interface[i];\n\n\t\t\tif (!f)\n\t\t\t\tcontinue;\n\t\t\tDBG(cdev, \"  interface %d = %s/%p\\n\",\n\t\t\t\ti, f->name, f);\n\t\t}\n\t}\n\n\t/* set_alt(), or next bind(), sets up ep->claimed as needed */\n\tusb_ep_autoconfig_reset(cdev->gadget);\n\ndone:\n\tif (status)\n\t\tDBG(cdev, \"added config '%s'/%u --> %d\\n\", config->label,\n\t\t\t\tconfig->bConfigurationValue, status);\n\treturn status;\n}\nEXPORT_SYMBOL_GPL(usb_add_config);\n\nstatic void remove_config(struct usb_composite_dev *cdev,\n\t\t\t      struct usb_configuration *config)\n{\n\twhile (!list_empty(&config->functions)) {\n\t\tstruct usb_function\t\t*f;\n\n\t\tf = list_first_entry(&config->functions,\n\t\t\t\tstruct usb_function, list);\n\n\t\tusb_remove_function(config, f);\n\t}\n\tlist_del(&config->list);\n\tif (config->unbind) {\n\t\tDBG(cdev, \"unbind config '%s'/%p\\n\", config->label, config);\n\t\tconfig->unbind(config);\n\t\t\t/* may free memory for \"c\" */\n\t}\n}\n\n/**\n * usb_remove_config() - remove a configuration from a device.\n * @cdev: wraps the USB gadget\n * @config: the configuration\n *\n * Drivers must call usb_gadget_disconnect before calling this function\n * to disconnect the device from the host and make sure the host will not\n * try to enumerate the device while we are changing the config list.\n */\nvoid usb_remove_config(struct usb_composite_dev *cdev,\n\t\t      struct usb_configuration *config)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&cdev->lock, flags);\n\n\tif (cdev->config == config)\n\t\treset_config(cdev);\n\n\tspin_unlock_irqrestore(&cdev->lock, flags);\n\n\tremove_config(cdev, config);\n}\n\n/*-------------------------------------------------------------------------*/\n\n/* We support strings in multiple languages ... string descriptor zero\n * says which languages are supported.  The typical case will be that\n * only one language (probably English) is used, with i18n handled on\n * the host side.\n */\n\nstatic void collect_langs(struct usb_gadget_strings **sp, __le16 *buf)\n{\n\tconst struct usb_gadget_strings\t*s;\n\t__le16\t\t\t\tlanguage;\n\t__le16\t\t\t\t*tmp;\n\n\twhile (*sp) {\n\t\ts = *sp;\n\t\tlanguage = cpu_to_le16(s->language);\n\t\tfor (tmp = buf; *tmp && tmp < &buf[USB_MAX_STRING_LEN]; tmp++) {\n\t\t\tif (*tmp == language)\n\t\t\t\tgoto repeat;\n\t\t}\n\t\t*tmp++ = language;\nrepeat:\n\t\tsp++;\n\t}\n}\n\nstatic int lookup_string(\n\tstruct usb_gadget_strings\t**sp,\n\tvoid\t\t\t\t*buf,\n\tu16\t\t\t\tlanguage,\n\tint\t\t\t\tid\n)\n{\n\tstruct usb_gadget_strings\t*s;\n\tint\t\t\t\tvalue;\n\n\twhile (*sp) {\n\t\ts = *sp++;\n\t\tif (s->language != language)\n\t\t\tcontinue;\n\t\tvalue = usb_gadget_get_string(s, id, buf);\n\t\tif (value > 0)\n\t\t\treturn value;\n\t}\n\treturn -EINVAL;\n}\n\nstatic int get_string(struct usb_composite_dev *cdev,\n\t\tvoid *buf, u16 language, int id)\n{\n\tstruct usb_composite_driver\t*composite = cdev->driver;\n\tstruct usb_gadget_string_container *uc;\n\tstruct usb_configuration\t*c;\n\tstruct usb_function\t\t*f;\n\tint\t\t\t\tlen;\n\n\t/* Yes, not only is USB's i18n support probably more than most\n\t * folk will ever care about ... also, it's all supported here.\n\t * (Except for UTF8 support for Unicode's \"Astral Planes\".)\n\t */\n\n\t/* 0 == report all available language codes */\n\tif (id == 0) {\n\t\tstruct usb_string_descriptor\t*s = buf;\n\t\tstruct usb_gadget_strings\t**sp;\n\n\t\tmemset(s, 0, 256);\n\t\ts->bDescriptorType = USB_DT_STRING;\n\n\t\tsp = composite->strings;\n\t\tif (sp)\n\t\t\tcollect_langs(sp, s->wData);\n\n\t\tlist_for_each_entry(c, &cdev->configs, list) {\n\t\t\tsp = c->strings;\n\t\t\tif (sp)\n\t\t\t\tcollect_langs(sp, s->wData);\n\n\t\t\tlist_for_each_entry(f, &c->functions, list) {\n\t\t\t\tsp = f->strings;\n\t\t\t\tif (sp)\n\t\t\t\t\tcollect_langs(sp, s->wData);\n\t\t\t}\n\t\t}\n\t\tlist_for_each_entry(uc, &cdev->gstrings, list) {\n\t\t\tstruct usb_gadget_strings **sp;\n\n\t\t\tsp = get_containers_gs(uc);\n\t\t\tcollect_langs(sp, s->wData);\n\t\t}\n\n\t\tfor (len = 0; len <= USB_MAX_STRING_LEN && s->wData[len]; len++)\n\t\t\tcontinue;\n\t\tif (!len)\n\t\t\treturn -EINVAL;\n\n\t\ts->bLength = 2 * (len + 1);\n\t\treturn s->bLength;\n\t}\n\n\tif (cdev->use_os_string && language == 0 && id == OS_STRING_IDX) {\n\t\tstruct usb_os_string *b = buf;\n\t\tb->bLength = sizeof(*b);\n\t\tb->bDescriptorType = USB_DT_STRING;\n\t\tcompiletime_assert(\n\t\t\tsizeof(b->qwSignature) == sizeof(cdev->qw_sign),\n\t\t\t\"qwSignature size must be equal to qw_sign\");\n\t\tmemcpy(&b->qwSignature, cdev->qw_sign, sizeof(b->qwSignature));\n\t\tb->bMS_VendorCode = cdev->b_vendor_code;\n\t\tb->bPad = 0;\n\t\treturn sizeof(*b);\n\t}\n\n\tlist_for_each_entry(uc, &cdev->gstrings, list) {\n\t\tstruct usb_gadget_strings **sp;\n\n\t\tsp = get_containers_gs(uc);\n\t\tlen = lookup_string(sp, buf, language, id);\n\t\tif (len > 0)\n\t\t\treturn len;\n\t}\n\n\t/* String IDs are device-scoped, so we look up each string\n\t * table we're told about.  These lookups are infrequent;\n\t * simpler-is-better here.\n\t */\n\tif (composite->strings) {\n\t\tlen = lookup_string(composite->strings, buf, language, id);\n\t\tif (len > 0)\n\t\t\treturn len;\n\t}\n\tlist_for_each_entry(c, &cdev->configs, list) {\n\t\tif (c->strings) {\n\t\t\tlen = lookup_string(c->strings, buf, language, id);\n\t\t\tif (len > 0)\n\t\t\t\treturn len;\n\t\t}\n\t\tlist_for_each_entry(f, &c->functions, list) {\n\t\t\tif (!f->strings)\n\t\t\t\tcontinue;\n\t\t\tlen = lookup_string(f->strings, buf, language, id);\n\t\t\tif (len > 0)\n\t\t\t\treturn len;\n\t\t}\n\t}\n\treturn -EINVAL;\n}\n\n/**\n * usb_string_id() - allocate an unused string ID\n * @cdev: the device whose string descriptor IDs are being allocated\n * Context: single threaded during gadget setup\n *\n * @usb_string_id() is called from bind() callbacks to allocate\n * string IDs.  Drivers for functions, configurations, or gadgets will\n * then store that ID in the appropriate descriptors and string table.\n *\n * All string identifier should be allocated using this,\n * @usb_string_ids_tab() or @usb_string_ids_n() routine, to ensure\n * that for example different functions don't wrongly assign different\n * meanings to the same identifier.\n */\nint usb_string_id(struct usb_composite_dev *cdev)\n{\n\tif (cdev->next_string_id < 254) {\n\t\t/* string id 0 is reserved by USB spec for list of\n\t\t * supported languages */\n\t\t/* 255 reserved as well? -- mina86 */\n\t\tcdev->next_string_id++;\n\t\treturn cdev->next_string_id;\n\t}\n\treturn -ENODEV;\n}\nEXPORT_SYMBOL_GPL(usb_string_id);\n\n/**\n * usb_string_ids_tab() - allocate unused string IDs in batch\n * @cdev: the device whose string descriptor IDs are being allocated\n * @str: an array of usb_string objects to assign numbers to\n * Context: single threaded during gadget setup\n *\n * @usb_string_ids() is called from bind() callbacks to allocate\n * string IDs.  Drivers for functions, configurations, or gadgets will\n * then copy IDs from the string table to the appropriate descriptors\n * and string table for other languages.\n *\n * All string identifier should be allocated using this,\n * @usb_string_id() or @usb_string_ids_n() routine, to ensure that for\n * example different functions don't wrongly assign different meanings\n * to the same identifier.\n */\nint usb_string_ids_tab(struct usb_composite_dev *cdev, struct usb_string *str)\n{\n\tint next = cdev->next_string_id;\n\n\tfor (; str->s; ++str) {\n\t\tif (unlikely(next >= 254))\n\t\t\treturn -ENODEV;\n\t\tstr->id = ++next;\n\t}\n\n\tcdev->next_string_id = next;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(usb_string_ids_tab);\n\nstatic struct usb_gadget_string_container *copy_gadget_strings(\n\t\tstruct usb_gadget_strings **sp, unsigned n_gstrings,\n\t\tunsigned n_strings)\n{\n\tstruct usb_gadget_string_container *uc;\n\tstruct usb_gadget_strings **gs_array;\n\tstruct usb_gadget_strings *gs;\n\tstruct usb_string *s;\n\tunsigned mem;\n\tunsigned n_gs;\n\tunsigned n_s;\n\tvoid *stash;\n\n\tmem = sizeof(*uc);\n\tmem += sizeof(void *) * (n_gstrings + 1);\n\tmem += sizeof(struct usb_gadget_strings) * n_gstrings;\n\tmem += sizeof(struct usb_string) * (n_strings + 1) * (n_gstrings);\n\tuc = kmalloc(mem, GFP_KERNEL);\n\tif (!uc)\n\t\treturn ERR_PTR(-ENOMEM);\n\tgs_array = get_containers_gs(uc);\n\tstash = uc->stash;\n\tstash += sizeof(void *) * (n_gstrings + 1);\n\tfor (n_gs = 0; n_gs < n_gstrings; n_gs++) {\n\t\tstruct usb_string *org_s;\n\n\t\tgs_array[n_gs] = stash;\n\t\tgs = gs_array[n_gs];\n\t\tstash += sizeof(struct usb_gadget_strings);\n\t\tgs->language = sp[n_gs]->language;\n\t\tgs->strings = stash;\n\t\torg_s = sp[n_gs]->strings;\n\n\t\tfor (n_s = 0; n_s < n_strings; n_s++) {\n\t\t\ts = stash;\n\t\t\tstash += sizeof(struct usb_string);\n\t\t\tif (org_s->s)\n\t\t\t\ts->s = org_s->s;\n\t\t\telse\n\t\t\t\ts->s = \"\";\n\t\t\torg_s++;\n\t\t}\n\t\ts = stash;\n\t\ts->s = NULL;\n\t\tstash += sizeof(struct usb_string);\n\n\t}\n\tgs_array[n_gs] = NULL;\n\treturn uc;\n}\n\n/**\n * usb_gstrings_attach() - attach gadget strings to a cdev and assign ids\n * @cdev: the device whose string descriptor IDs are being allocated\n * and attached.\n * @sp: an array of usb_gadget_strings to attach.\n * @n_strings: number of entries in each usb_strings array (sp[]->strings)\n *\n * This function will create a deep copy of usb_gadget_strings and usb_string\n * and attach it to the cdev. The actual string (usb_string.s) will not be\n * copied but only a referenced will be made. The struct usb_gadget_strings\n * array may contain multiple languages and should be NULL terminated.\n * The ->language pointer of each struct usb_gadget_strings has to contain the\n * same amount of entries.\n * For instance: sp[0] is en-US, sp[1] is es-ES. It is expected that the first\n * usb_string entry of es-ES contains the translation of the first usb_string\n * entry of en-US. Therefore both entries become the same id assign.\n */\nstruct usb_string *usb_gstrings_attach(struct usb_composite_dev *cdev,\n\t\tstruct usb_gadget_strings **sp, unsigned n_strings)\n{\n\tstruct usb_gadget_string_container *uc;\n\tstruct usb_gadget_strings **n_gs;\n\tunsigned n_gstrings = 0;\n\tunsigned i;\n\tint ret;\n\n\tfor (i = 0; sp[i]; i++)\n\t\tn_gstrings++;\n\n\tif (!n_gstrings)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tuc = copy_gadget_strings(sp, n_gstrings, n_strings);\n\tif (IS_ERR(uc))\n\t\treturn ERR_CAST(uc);\n\n\tn_gs = get_containers_gs(uc);\n\tret = usb_string_ids_tab(cdev, n_gs[0]->strings);\n\tif (ret)\n\t\tgoto err;\n\n\tfor (i = 1; i < n_gstrings; i++) {\n\t\tstruct usb_string *m_s;\n\t\tstruct usb_string *s;\n\t\tunsigned n;\n\n\t\tm_s = n_gs[0]->strings;\n\t\ts = n_gs[i]->strings;\n\t\tfor (n = 0; n < n_strings; n++) {\n\t\t\ts->id = m_s->id;\n\t\t\ts++;\n\t\t\tm_s++;\n\t\t}\n\t}\n\tlist_add_tail(&uc->list, &cdev->gstrings);\n\treturn n_gs[0]->strings;\nerr:\n\tkfree(uc);\n\treturn ERR_PTR(ret);\n}\nEXPORT_SYMBOL_GPL(usb_gstrings_attach);\n\n/**\n * usb_string_ids_n() - allocate unused string IDs in batch\n * @c: the device whose string descriptor IDs are being allocated\n * @n: number of string IDs to allocate\n * Context: single threaded during gadget setup\n *\n * Returns the first requested ID.  This ID and next @n-1 IDs are now\n * valid IDs.  At least provided that @n is non-zero because if it\n * is, returns last requested ID which is now very useful information.\n *\n * @usb_string_ids_n() is called from bind() callbacks to allocate\n * string IDs.  Drivers for functions, configurations, or gadgets will\n * then store that ID in the appropriate descriptors and string table.\n *\n * All string identifier should be allocated using this,\n * @usb_string_id() or @usb_string_ids_n() routine, to ensure that for\n * example different functions don't wrongly assign different meanings\n * to the same identifier.\n */\nint usb_string_ids_n(struct usb_composite_dev *c, unsigned n)\n{\n\tunsigned next = c->next_string_id;\n\tif (unlikely(n > 254 || (unsigned)next + n > 254))\n\t\treturn -ENODEV;\n\tc->next_string_id += n;\n\treturn next + 1;\n}\nEXPORT_SYMBOL_GPL(usb_string_ids_n);\n\n/*-------------------------------------------------------------------------*/\n\nstatic void composite_setup_complete(struct usb_ep *ep, struct usb_request *req)\n{\n\tstruct usb_composite_dev *cdev;\n\n\tif (req->status || req->actual != req->length)\n\t\tDBG((struct usb_composite_dev *) ep->driver_data,\n\t\t\t\t\"setup complete --> %d, %d/%d\\n\",\n\t\t\t\treq->status, req->actual, req->length);\n\n\t/*\n\t * REVIST The same ep0 requests are shared with function drivers\n\t * so they don't have to maintain the same ->complete() stubs.\n\t *\n\t * Because of that, we need to check for the validity of ->context\n\t * here, even though we know we've set it to something useful.\n\t */\n\tif (!req->context)\n\t\treturn;\n\n\tcdev = req->context;\n\n\tif (cdev->req == req)\n\t\tcdev->setup_pending = false;\n\telse if (cdev->os_desc_req == req)\n\t\tcdev->os_desc_pending = false;\n\telse\n\t\tWARN(1, \"unknown request %p\\n\", req);\n}\n\nstatic int composite_ep0_queue(struct usb_composite_dev *cdev,\n\t\tstruct usb_request *req, gfp_t gfp_flags)\n{\n\tint ret;\n\n\tret = usb_ep_queue(cdev->gadget->ep0, req, gfp_flags);\n\tif (ret == 0) {\n\t\tif (cdev->req == req)\n\t\t\tcdev->setup_pending = true;\n\t\telse if (cdev->os_desc_req == req)\n\t\t\tcdev->os_desc_pending = true;\n\t\telse\n\t\t\tWARN(1, \"unknown request %p\\n\", req);\n\t}\n\n\treturn ret;\n}\n\nstatic int count_ext_compat(struct usb_configuration *c)\n{\n\tint i, res;\n\n\tres = 0;\n\tfor (i = 0; i < c->next_interface_id; ++i) {\n\t\tstruct usb_function *f;\n\t\tint j;\n\n\t\tf = c->interface[i];\n\t\tfor (j = 0; j < f->os_desc_n; ++j) {\n\t\t\tstruct usb_os_desc *d;\n\n\t\t\tif (i != f->os_desc_table[j].if_id)\n\t\t\t\tcontinue;\n\t\t\td = f->os_desc_table[j].os_desc;\n\t\t\tif (d && d->ext_compat_id)\n\t\t\t\t++res;\n\t\t}\n\t}\n\tBUG_ON(res > 255);\n\treturn res;\n}\n\nstatic int fill_ext_compat(struct usb_configuration *c, u8 *buf)\n{\n\tint i, count;\n\n\tcount = 16;\n\tbuf += 16;\n\tfor (i = 0; i < c->next_interface_id; ++i) {\n\t\tstruct usb_function *f;\n\t\tint j;\n\n\t\tf = c->interface[i];\n\t\tfor (j = 0; j < f->os_desc_n; ++j) {\n\t\t\tstruct usb_os_desc *d;\n\n\t\t\tif (i != f->os_desc_table[j].if_id)\n\t\t\t\tcontinue;\n\t\t\td = f->os_desc_table[j].os_desc;\n\t\t\tif (d && d->ext_compat_id) {\n\t\t\t\t*buf++ = i;\n\t\t\t\t*buf++ = 0x01;\n\t\t\t\tmemcpy(buf, d->ext_compat_id, 16);\n\t\t\t\tbuf += 22;\n\t\t\t} else {\n\t\t\t\t++buf;\n\t\t\t\t*buf = 0x01;\n\t\t\t\tbuf += 23;\n\t\t\t}\n\t\t\tcount += 24;\n\t\t\tif (count + 24 >= USB_COMP_EP0_OS_DESC_BUFSIZ)\n\t\t\t\treturn count;\n\t\t}\n\t}\n\n\treturn count;\n}\n\nstatic int count_ext_prop(struct usb_configuration *c, int interface)\n{\n\tstruct usb_function *f;\n\tint j;\n\n\tf = c->interface[interface];\n\tfor (j = 0; j < f->os_desc_n; ++j) {\n\t\tstruct usb_os_desc *d;\n\n\t\tif (interface != f->os_desc_table[j].if_id)\n\t\t\tcontinue;\n\t\td = f->os_desc_table[j].os_desc;\n\t\tif (d && d->ext_compat_id)\n\t\t\treturn d->ext_prop_count;\n\t}\n\treturn 0;\n}\n\nstatic int len_ext_prop(struct usb_configuration *c, int interface)\n{\n\tstruct usb_function *f;\n\tstruct usb_os_desc *d;\n\tint j, res;\n\n\tres = 10; /* header length */\n\tf = c->interface[interface];\n\tfor (j = 0; j < f->os_desc_n; ++j) {\n\t\tif (interface != f->os_desc_table[j].if_id)\n\t\t\tcontinue;\n\t\td = f->os_desc_table[j].os_desc;\n\t\tif (d)\n\t\t\treturn min(res + d->ext_prop_len, 4096);\n\t}\n\treturn res;\n}\n\nstatic int fill_ext_prop(struct usb_configuration *c, int interface, u8 *buf)\n{\n\tstruct usb_function *f;\n\tstruct usb_os_desc *d;\n\tstruct usb_os_desc_ext_prop *ext_prop;\n\tint j, count, n, ret;\n\n\tf = c->interface[interface];\n\tcount = 10; /* header length */\n\tbuf += 10;\n\tfor (j = 0; j < f->os_desc_n; ++j) {\n\t\tif (interface != f->os_desc_table[j].if_id)\n\t\t\tcontinue;\n\t\td = f->os_desc_table[j].os_desc;\n\t\tif (d)\n\t\t\tlist_for_each_entry(ext_prop, &d->ext_prop, entry) {\n\t\t\t\tn = ext_prop->data_len +\n\t\t\t\t\text_prop->name_len + 14;\n\t\t\t\tif (count + n >= USB_COMP_EP0_OS_DESC_BUFSIZ)\n\t\t\t\t\treturn count;\n\t\t\t\tusb_ext_prop_put_size(buf, n);\n\t\t\t\tusb_ext_prop_put_type(buf, ext_prop->type);\n\t\t\t\tret = usb_ext_prop_put_name(buf, ext_prop->name,\n\t\t\t\t\t\t\t    ext_prop->name_len);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\treturn ret;\n\t\t\t\tswitch (ext_prop->type) {\n\t\t\t\tcase USB_EXT_PROP_UNICODE:\n\t\t\t\tcase USB_EXT_PROP_UNICODE_ENV:\n\t\t\t\tcase USB_EXT_PROP_UNICODE_LINK:\n\t\t\t\t\tusb_ext_prop_put_unicode(buf, ret,\n\t\t\t\t\t\t\t ext_prop->data,\n\t\t\t\t\t\t\t ext_prop->data_len);\n\t\t\t\t\tbreak;\n\t\t\t\tcase USB_EXT_PROP_BINARY:\n\t\t\t\t\tusb_ext_prop_put_binary(buf, ret,\n\t\t\t\t\t\t\text_prop->data,\n\t\t\t\t\t\t\text_prop->data_len);\n\t\t\t\t\tbreak;\n\t\t\t\tcase USB_EXT_PROP_LE32:\n\t\t\t\t\t/* not implemented */\n\t\t\t\tcase USB_EXT_PROP_BE32:\n\t\t\t\t\t/* not implemented */\n\t\t\t\tdefault:\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\t\t\t\tbuf += n;\n\t\t\t\tcount += n;\n\t\t\t}\n\t}\n\n\treturn count;\n}\n\n/*\n * The setup() callback implements all the ep0 functionality that's\n * not handled lower down, in hardware or the hardware driver(like\n * device and endpoint feature flags, and their status).  It's all\n * housekeeping for the gadget function we're implementing.  Most of\n * the work is in config and function specific setup.\n */\nint\ncomposite_setup(struct usb_gadget *gadget, const struct usb_ctrlrequest *ctrl)\n{\n\tstruct usb_composite_dev\t*cdev = get_gadget_data(gadget);\n\tstruct usb_request\t\t*req = cdev->req;\n\tint\t\t\t\tvalue = -EOPNOTSUPP;\n\tint\t\t\t\tstatus = 0;\n\tu16\t\t\t\tw_index = le16_to_cpu(ctrl->wIndex);\n\tu8\t\t\t\tintf = w_index & 0xFF;\n\tu16\t\t\t\tw_value = le16_to_cpu(ctrl->wValue);\n\tu16\t\t\t\tw_length = le16_to_cpu(ctrl->wLength);\n\tstruct usb_function\t\t*f = NULL;\n\tu8\t\t\t\tendp;\n\n\tif (w_length > USB_COMP_EP0_BUFSIZ) {\n\t\tif (ctrl->bRequestType & USB_DIR_IN) {\n\t\t\t/* Cast away the const, we are going to overwrite on purpose. */\n\t\t\t__le16 *temp = (__le16 *)&ctrl->wLength;\n\n\t\t\t*temp = cpu_to_le16(USB_COMP_EP0_BUFSIZ);\n\t\t\tw_length = USB_COMP_EP0_BUFSIZ;\n\t\t} else {\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\t/* partial re-init of the response message; the function or the\n\t * gadget might need to intercept e.g. a control-OUT completion\n\t * when we delegate to it.\n\t */\n\treq->zero = 0;\n\treq->context = cdev;\n\treq->complete = composite_setup_complete;\n\treq->length = 0;\n\tgadget->ep0->driver_data = cdev;\n\n\t/*\n\t * Don't let non-standard requests match any of the cases below\n\t * by accident.\n\t */\n\tif ((ctrl->bRequestType & USB_TYPE_MASK) != USB_TYPE_STANDARD)\n\t\tgoto unknown;\n\n\tswitch (ctrl->bRequest) {\n\n\t/* we handle all standard USB descriptors */\n\tcase USB_REQ_GET_DESCRIPTOR:\n\t\tif (ctrl->bRequestType != USB_DIR_IN)\n\t\t\tgoto unknown;\n\t\tswitch (w_value >> 8) {\n\n\t\tcase USB_DT_DEVICE:\n\t\t\tcdev->desc.bNumConfigurations =\n\t\t\t\tcount_configs(cdev, USB_DT_DEVICE);\n\t\t\tcdev->desc.bMaxPacketSize0 =\n\t\t\t\tcdev->gadget->ep0->maxpacket;\n\t\t\tif (gadget_is_superspeed(gadget)) {\n\t\t\t\tif (gadget->speed >= USB_SPEED_SUPER) {\n\t\t\t\t\tcdev->desc.bcdUSB = cpu_to_le16(0x0320);\n\t\t\t\t\tcdev->desc.bMaxPacketSize0 = 9;\n\t\t\t\t} else {\n\t\t\t\t\tcdev->desc.bcdUSB = cpu_to_le16(0x0210);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (gadget->lpm_capable)\n\t\t\t\t\tcdev->desc.bcdUSB = cpu_to_le16(0x0201);\n\t\t\t\telse\n\t\t\t\t\tcdev->desc.bcdUSB = cpu_to_le16(0x0200);\n\t\t\t}\n\n\t\t\tvalue = min(w_length, (u16) sizeof cdev->desc);\n\t\t\tmemcpy(req->buf, &cdev->desc, value);\n\t\t\tbreak;\n\t\tcase USB_DT_DEVICE_QUALIFIER:\n\t\t\tif (!gadget_is_dualspeed(gadget) ||\n\t\t\t    gadget->speed >= USB_SPEED_SUPER)\n\t\t\t\tbreak;\n\t\t\tdevice_qual(cdev);\n\t\t\tvalue = min_t(int, w_length,\n\t\t\t\tsizeof(struct usb_qualifier_descriptor));\n\t\t\tbreak;\n\t\tcase USB_DT_OTHER_SPEED_CONFIG:\n\t\t\tif (!gadget_is_dualspeed(gadget) ||\n\t\t\t    gadget->speed >= USB_SPEED_SUPER)\n\t\t\t\tbreak;\n\t\t\tfallthrough;\n\t\tcase USB_DT_CONFIG:\n\t\t\tvalue = config_desc(cdev, w_value);\n\t\t\tif (value >= 0)\n\t\t\t\tvalue = min(w_length, (u16) value);\n\t\t\tbreak;\n\t\tcase USB_DT_STRING:\n\t\t\tvalue = get_string(cdev, req->buf,\n\t\t\t\t\tw_index, w_value & 0xff);\n\t\t\tif (value >= 0)\n\t\t\t\tvalue = min(w_length, (u16) value);\n\t\t\tbreak;\n\t\tcase USB_DT_BOS:\n\t\t\tif (gadget_is_superspeed(gadget) ||\n\t\t\t    gadget->lpm_capable) {\n\t\t\t\tvalue = bos_desc(cdev);\n\t\t\t\tvalue = min(w_length, (u16) value);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase USB_DT_OTG:\n\t\t\tif (gadget_is_otg(gadget)) {\n\t\t\t\tstruct usb_configuration *config;\n\t\t\t\tint otg_desc_len = 0;\n\n\t\t\t\tif (cdev->config)\n\t\t\t\t\tconfig = cdev->config;\n\t\t\t\telse\n\t\t\t\t\tconfig = list_first_entry(\n\t\t\t\t\t\t\t&cdev->configs,\n\t\t\t\t\t\tstruct usb_configuration, list);\n\t\t\t\tif (!config)\n\t\t\t\t\tgoto done;\n\n\t\t\t\tif (gadget->otg_caps &&\n\t\t\t\t\t(gadget->otg_caps->otg_rev >= 0x0200))\n\t\t\t\t\totg_desc_len += sizeof(\n\t\t\t\t\t\tstruct usb_otg20_descriptor);\n\t\t\t\telse\n\t\t\t\t\totg_desc_len += sizeof(\n\t\t\t\t\t\tstruct usb_otg_descriptor);\n\n\t\t\t\tvalue = min_t(int, w_length, otg_desc_len);\n\t\t\t\tmemcpy(req->buf, config->descriptors[0], value);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\t/* any number of configs can work */\n\tcase USB_REQ_SET_CONFIGURATION:\n\t\tif (ctrl->bRequestType != 0)\n\t\t\tgoto unknown;\n\t\tif (gadget_is_otg(gadget)) {\n\t\t\tif (gadget->a_hnp_support)\n\t\t\t\tDBG(cdev, \"HNP available\\n\");\n\t\t\telse if (gadget->a_alt_hnp_support)\n\t\t\t\tDBG(cdev, \"HNP on another port\\n\");\n\t\t\telse\n\t\t\t\tVDBG(cdev, \"HNP inactive\\n\");\n\t\t}\n\t\tspin_lock(&cdev->lock);\n\t\tvalue = set_config(cdev, ctrl, w_value);\n\t\tspin_unlock(&cdev->lock);\n\t\tbreak;\n\tcase USB_REQ_GET_CONFIGURATION:\n\t\tif (ctrl->bRequestType != USB_DIR_IN)\n\t\t\tgoto unknown;\n\t\tif (cdev->config)\n\t\t\t*(u8 *)req->buf = cdev->config->bConfigurationValue;\n\t\telse\n\t\t\t*(u8 *)req->buf = 0;\n\t\tvalue = min(w_length, (u16) 1);\n\t\tbreak;\n\n\t/* function drivers must handle get/set altsetting */\n\tcase USB_REQ_SET_INTERFACE:\n\t\tif (ctrl->bRequestType != USB_RECIP_INTERFACE)\n\t\t\tgoto unknown;\n\t\tif (!cdev->config || intf >= MAX_CONFIG_INTERFACES)\n\t\t\tbreak;\n\t\tf = cdev->config->interface[intf];\n\t\tif (!f)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * If there's no get_alt() method, we know only altsetting zero\n\t\t * works. There is no need to check if set_alt() is not NULL\n\t\t * as we check this in usb_add_function().\n\t\t */\n\t\tif (w_value && !f->get_alt)\n\t\t\tbreak;\n\n\t\tspin_lock(&cdev->lock);\n\t\tvalue = f->set_alt(f, w_index, w_value);\n\t\tif (value == USB_GADGET_DELAYED_STATUS) {\n\t\t\tDBG(cdev,\n\t\t\t \"%s: interface %d (%s) requested delayed status\\n\",\n\t\t\t\t\t__func__, intf, f->name);\n\t\t\tcdev->delayed_status++;\n\t\t\tDBG(cdev, \"delayed_status count %d\\n\",\n\t\t\t\t\tcdev->delayed_status);\n\t\t}\n\t\tspin_unlock(&cdev->lock);\n\t\tbreak;\n\tcase USB_REQ_GET_INTERFACE:\n\t\tif (ctrl->bRequestType != (USB_DIR_IN|USB_RECIP_INTERFACE))\n\t\t\tgoto unknown;\n\t\tif (!cdev->config || intf >= MAX_CONFIG_INTERFACES)\n\t\t\tbreak;\n\t\tf = cdev->config->interface[intf];\n\t\tif (!f)\n\t\t\tbreak;\n\t\t/* lots of interfaces only need altsetting zero... */\n\t\tvalue = f->get_alt ? f->get_alt(f, w_index) : 0;\n\t\tif (value < 0)\n\t\t\tbreak;\n\t\t*((u8 *)req->buf) = value;\n\t\tvalue = min(w_length, (u16) 1);\n\t\tbreak;\n\tcase USB_REQ_GET_STATUS:\n\t\tif (gadget_is_otg(gadget) && gadget->hnp_polling_support &&\n\t\t\t\t\t\t(w_index == OTG_STS_SELECTOR)) {\n\t\t\tif (ctrl->bRequestType != (USB_DIR_IN |\n\t\t\t\t\t\t\tUSB_RECIP_DEVICE))\n\t\t\t\tgoto unknown;\n\t\t\t*((u8 *)req->buf) = gadget->host_request_flag;\n\t\t\tvalue = 1;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * USB 3.0 additions:\n\t\t * Function driver should handle get_status request. If such cb\n\t\t * wasn't supplied we respond with default value = 0\n\t\t * Note: function driver should supply such cb only for the\n\t\t * first interface of the function\n\t\t */\n\t\tif (!gadget_is_superspeed(gadget))\n\t\t\tgoto unknown;\n\t\tif (ctrl->bRequestType != (USB_DIR_IN | USB_RECIP_INTERFACE))\n\t\t\tgoto unknown;\n\t\tvalue = 2;\t/* This is the length of the get_status reply */\n\t\tput_unaligned_le16(0, req->buf);\n\t\tif (!cdev->config || intf >= MAX_CONFIG_INTERFACES)\n\t\t\tbreak;\n\t\tf = cdev->config->interface[intf];\n\t\tif (!f)\n\t\t\tbreak;\n\t\tstatus = f->get_status ? f->get_status(f) : 0;\n\t\tif (status < 0)\n\t\t\tbreak;\n\t\tput_unaligned_le16(status & 0x0000ffff, req->buf);\n\t\tbreak;\n\t/*\n\t * Function drivers should handle SetFeature/ClearFeature\n\t * (FUNCTION_SUSPEND) request. function_suspend cb should be supplied\n\t * only for the first interface of the function\n\t */\n\tcase USB_REQ_CLEAR_FEATURE:\n\tcase USB_REQ_SET_FEATURE:\n\t\tif (!gadget_is_superspeed(gadget))\n\t\t\tgoto unknown;\n\t\tif (ctrl->bRequestType != (USB_DIR_OUT | USB_RECIP_INTERFACE))\n\t\t\tgoto unknown;\n\t\tswitch (w_value) {\n\t\tcase USB_INTRF_FUNC_SUSPEND:\n\t\t\tif (!cdev->config || intf >= MAX_CONFIG_INTERFACES)\n\t\t\t\tbreak;\n\t\t\tf = cdev->config->interface[intf];\n\t\t\tif (!f)\n\t\t\t\tbreak;\n\t\t\tvalue = 0;\n\t\t\tif (f->func_suspend)\n\t\t\t\tvalue = f->func_suspend(f, w_index >> 8);\n\t\t\tif (value < 0) {\n\t\t\t\tERROR(cdev,\n\t\t\t\t      \"func_suspend() returned error %d\\n\",\n\t\t\t\t      value);\n\t\t\t\tvalue = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tdefault:\nunknown:\n\t\t/*\n\t\t * OS descriptors handling\n\t\t */\n\t\tif (cdev->use_os_string && cdev->os_desc_config &&\n\t\t    (ctrl->bRequestType & USB_TYPE_VENDOR) &&\n\t\t    ctrl->bRequest == cdev->b_vendor_code) {\n\t\t\tstruct usb_configuration\t*os_desc_cfg;\n\t\t\tu8\t\t\t\t*buf;\n\t\t\tint\t\t\t\tinterface;\n\t\t\tint\t\t\t\tcount = 0;\n\n\t\t\treq = cdev->os_desc_req;\n\t\t\treq->context = cdev;\n\t\t\treq->complete = composite_setup_complete;\n\t\t\tbuf = req->buf;\n\t\t\tos_desc_cfg = cdev->os_desc_config;\n\t\t\tw_length = min_t(u16, w_length, USB_COMP_EP0_OS_DESC_BUFSIZ);\n\t\t\tmemset(buf, 0, w_length);\n\t\t\tbuf[5] = 0x01;\n\t\t\tswitch (ctrl->bRequestType & USB_RECIP_MASK) {\n\t\t\tcase USB_RECIP_DEVICE:\n\t\t\t\tif (w_index != 0x4 || (w_value >> 8))\n\t\t\t\t\tbreak;\n\t\t\t\tbuf[6] = w_index;\n\t\t\t\t/* Number of ext compat interfaces */\n\t\t\t\tcount = count_ext_compat(os_desc_cfg);\n\t\t\t\tbuf[8] = count;\n\t\t\t\tcount *= 24; /* 24 B/ext compat desc */\n\t\t\t\tcount += 16; /* header */\n\t\t\t\tput_unaligned_le32(count, buf);\n\t\t\t\tvalue = w_length;\n\t\t\t\tif (w_length > 0x10) {\n\t\t\t\t\tvalue = fill_ext_compat(os_desc_cfg, buf);\n\t\t\t\t\tvalue = min_t(u16, w_length, value);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase USB_RECIP_INTERFACE:\n\t\t\t\tif (w_index != 0x5 || (w_value >> 8))\n\t\t\t\t\tbreak;\n\t\t\t\tinterface = w_value & 0xFF;\n\t\t\t\tif (interface >= MAX_CONFIG_INTERFACES ||\n\t\t\t\t    !os_desc_cfg->interface[interface])\n\t\t\t\t\tbreak;\n\t\t\t\tbuf[6] = w_index;\n\t\t\t\tcount = count_ext_prop(os_desc_cfg,\n\t\t\t\t\tinterface);\n\t\t\t\tput_unaligned_le16(count, buf + 8);\n\t\t\t\tcount = len_ext_prop(os_desc_cfg,\n\t\t\t\t\tinterface);\n\t\t\t\tput_unaligned_le32(count, buf);\n\t\t\t\tvalue = w_length;\n\t\t\t\tif (w_length > 0x0A) {\n\t\t\t\t\tvalue = fill_ext_prop(os_desc_cfg,\n\t\t\t\t\t\t\t      interface, buf);\n\t\t\t\t\tif (value >= 0)\n\t\t\t\t\t\tvalue = min_t(u16, w_length, value);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tgoto check_value;\n\t\t}\n\n\t\tVDBG(cdev,\n\t\t\t\"non-core control req%02x.%02x v%04x i%04x l%d\\n\",\n\t\t\tctrl->bRequestType, ctrl->bRequest,\n\t\t\tw_value, w_index, w_length);\n\n\t\t/* functions always handle their interfaces and endpoints...\n\t\t * punt other recipients (other, WUSB, ...) to the current\n\t\t * configuration code.\n\t\t */\n\t\tif (cdev->config) {\n\t\t\tlist_for_each_entry(f, &cdev->config->functions, list)\n\t\t\t\tif (f->req_match &&\n\t\t\t\t    f->req_match(f, ctrl, false))\n\t\t\t\t\tgoto try_fun_setup;\n\t\t} else {\n\t\t\tstruct usb_configuration *c;\n\t\t\tlist_for_each_entry(c, &cdev->configs, list)\n\t\t\t\tlist_for_each_entry(f, &c->functions, list)\n\t\t\t\t\tif (f->req_match &&\n\t\t\t\t\t    f->req_match(f, ctrl, true))\n\t\t\t\t\t\tgoto try_fun_setup;\n\t\t}\n\t\tf = NULL;\n\n\t\tswitch (ctrl->bRequestType & USB_RECIP_MASK) {\n\t\tcase USB_RECIP_INTERFACE:\n\t\t\tif (!cdev->config || intf >= MAX_CONFIG_INTERFACES)\n\t\t\t\tbreak;\n\t\t\tf = cdev->config->interface[intf];\n\t\t\tbreak;\n\n\t\tcase USB_RECIP_ENDPOINT:\n\t\t\tif (!cdev->config)\n\t\t\t\tbreak;\n\t\t\tendp = ((w_index & 0x80) >> 3) | (w_index & 0x0f);\n\t\t\tlist_for_each_entry(f, &cdev->config->functions, list) {\n\t\t\t\tif (test_bit(endp, f->endpoints))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (&f->list == &cdev->config->functions)\n\t\t\t\tf = NULL;\n\t\t\tbreak;\n\t\t}\ntry_fun_setup:\n\t\tif (f && f->setup)\n\t\t\tvalue = f->setup(f, ctrl);\n\t\telse {\n\t\t\tstruct usb_configuration\t*c;\n\n\t\t\tc = cdev->config;\n\t\t\tif (!c)\n\t\t\t\tgoto done;\n\n\t\t\t/* try current config's setup */\n\t\t\tif (c->setup) {\n\t\t\t\tvalue = c->setup(c, ctrl);\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\t/* try the only function in the current config */\n\t\t\tif (!list_is_singular(&c->functions))\n\t\t\t\tgoto done;\n\t\t\tf = list_first_entry(&c->functions, struct usb_function,\n\t\t\t\t\t     list);\n\t\t\tif (f->setup)\n\t\t\t\tvalue = f->setup(f, ctrl);\n\t\t}\n\n\t\tgoto done;\n\t}\n\ncheck_value:\n\t/* respond with data transfer before status phase? */\n\tif (value >= 0 && value != USB_GADGET_DELAYED_STATUS) {\n\t\treq->length = value;\n\t\treq->context = cdev;\n\t\treq->zero = value < w_length;\n\t\tvalue = composite_ep0_queue(cdev, req, GFP_ATOMIC);\n\t\tif (value < 0) {\n\t\t\tDBG(cdev, \"ep_queue --> %d\\n\", value);\n\t\t\treq->status = 0;\n\t\t\tcomposite_setup_complete(gadget->ep0, req);\n\t\t}\n\t} else if (value == USB_GADGET_DELAYED_STATUS && w_length != 0) {\n\t\tWARN(cdev,\n\t\t\t\"%s: Delayed status not supported for w_length != 0\",\n\t\t\t__func__);\n\t}\n\ndone:\n\t/* device either stalls (value < 0) or reports success */\n\treturn value;\n}\n\nstatic void __composite_disconnect(struct usb_gadget *gadget)\n{\n\tstruct usb_composite_dev\t*cdev = get_gadget_data(gadget);\n\tunsigned long\t\t\tflags;\n\n\t/* REVISIT:  should we have config and device level\n\t * disconnect callbacks?\n\t */\n\tspin_lock_irqsave(&cdev->lock, flags);\n\tcdev->suspended = 0;\n\tif (cdev->config)\n\t\treset_config(cdev);\n\tif (cdev->driver->disconnect)\n\t\tcdev->driver->disconnect(cdev);\n\tspin_unlock_irqrestore(&cdev->lock, flags);\n}\n\nvoid composite_disconnect(struct usb_gadget *gadget)\n{\n\tusb_gadget_vbus_draw(gadget, 0);\n\t__composite_disconnect(gadget);\n}\n\nvoid composite_reset(struct usb_gadget *gadget)\n{\n\t/*\n\t * Section 1.4.13 Standard Downstream Port of the USB battery charging\n\t * specification v1.2 states that a device connected on a SDP shall only\n\t * draw at max 100mA while in a connected, but unconfigured state.\n\t */\n\tusb_gadget_vbus_draw(gadget, 100);\n\t__composite_disconnect(gadget);\n}\n\n/*-------------------------------------------------------------------------*/\n\nstatic ssize_t suspended_show(struct device *dev, struct device_attribute *attr,\n\t\t\t      char *buf)\n{\n\tstruct usb_gadget *gadget = dev_to_usb_gadget(dev);\n\tstruct usb_composite_dev *cdev = get_gadget_data(gadget);\n\n\treturn sprintf(buf, \"%d\\n\", cdev->suspended);\n}\nstatic DEVICE_ATTR_RO(suspended);\n\nstatic void __composite_unbind(struct usb_gadget *gadget, bool unbind_driver)\n{\n\tstruct usb_composite_dev\t*cdev = get_gadget_data(gadget);\n\tstruct usb_gadget_strings\t*gstr = cdev->driver->strings[0];\n\tstruct usb_string\t\t*dev_str = gstr->strings;\n\n\t/* composite_disconnect() must already have been called\n\t * by the underlying peripheral controller driver!\n\t * so there's no i/o concurrency that could affect the\n\t * state protected by cdev->lock.\n\t */\n\tWARN_ON(cdev->config);\n\n\twhile (!list_empty(&cdev->configs)) {\n\t\tstruct usb_configuration\t*c;\n\t\tc = list_first_entry(&cdev->configs,\n\t\t\t\tstruct usb_configuration, list);\n\t\tremove_config(cdev, c);\n\t}\n\tif (cdev->driver->unbind && unbind_driver)\n\t\tcdev->driver->unbind(cdev);\n\n\tcomposite_dev_cleanup(cdev);\n\n\tif (dev_str[USB_GADGET_MANUFACTURER_IDX].s == cdev->def_manufacturer)\n\t\tdev_str[USB_GADGET_MANUFACTURER_IDX].s = \"\";\n\n\tkfree(cdev->def_manufacturer);\n\tkfree(cdev);\n\tset_gadget_data(gadget, NULL);\n}\n\nstatic void composite_unbind(struct usb_gadget *gadget)\n{\n\t__composite_unbind(gadget, true);\n}\n\nstatic void update_unchanged_dev_desc(struct usb_device_descriptor *new,\n\t\tconst struct usb_device_descriptor *old)\n{\n\t__le16 idVendor;\n\t__le16 idProduct;\n\t__le16 bcdDevice;\n\tu8 iSerialNumber;\n\tu8 iManufacturer;\n\tu8 iProduct;\n\n\t/*\n\t * these variables may have been set in\n\t * usb_composite_overwrite_options()\n\t */\n\tidVendor = new->idVendor;\n\tidProduct = new->idProduct;\n\tbcdDevice = new->bcdDevice;\n\tiSerialNumber = new->iSerialNumber;\n\tiManufacturer = new->iManufacturer;\n\tiProduct = new->iProduct;\n\n\t*new = *old;\n\tif (idVendor)\n\t\tnew->idVendor = idVendor;\n\tif (idProduct)\n\t\tnew->idProduct = idProduct;\n\tif (bcdDevice)\n\t\tnew->bcdDevice = bcdDevice;\n\telse\n\t\tnew->bcdDevice = cpu_to_le16(get_default_bcdDevice());\n\tif (iSerialNumber)\n\t\tnew->iSerialNumber = iSerialNumber;\n\tif (iManufacturer)\n\t\tnew->iManufacturer = iManufacturer;\n\tif (iProduct)\n\t\tnew->iProduct = iProduct;\n}\n\nint composite_dev_prepare(struct usb_composite_driver *composite,\n\t\tstruct usb_composite_dev *cdev)\n{\n\tstruct usb_gadget *gadget = cdev->gadget;\n\tint ret = -ENOMEM;\n\n\t/* preallocate control response and buffer */\n\tcdev->req = usb_ep_alloc_request(gadget->ep0, GFP_KERNEL);\n\tif (!cdev->req)\n\t\treturn -ENOMEM;\n\n\tcdev->req->buf = kzalloc(USB_COMP_EP0_BUFSIZ, GFP_KERNEL);\n\tif (!cdev->req->buf)\n\t\tgoto fail;\n\n\tret = device_create_file(&gadget->dev, &dev_attr_suspended);\n\tif (ret)\n\t\tgoto fail_dev;\n\n\tcdev->req->complete = composite_setup_complete;\n\tcdev->req->context = cdev;\n\tgadget->ep0->driver_data = cdev;\n\n\tcdev->driver = composite;\n\n\t/*\n\t * As per USB compliance update, a device that is actively drawing\n\t * more than 100mA from USB must report itself as bus-powered in\n\t * the GetStatus(DEVICE) call.\n\t */\n\tif (CONFIG_USB_GADGET_VBUS_DRAW <= USB_SELF_POWER_VBUS_MAX_DRAW)\n\t\tusb_gadget_set_selfpowered(gadget);\n\n\t/* interface and string IDs start at zero via kzalloc.\n\t * we force endpoints to start unassigned; few controller\n\t * drivers will zero ep->driver_data.\n\t */\n\tusb_ep_autoconfig_reset(gadget);\n\treturn 0;\nfail_dev:\n\tkfree(cdev->req->buf);\nfail:\n\tusb_ep_free_request(gadget->ep0, cdev->req);\n\tcdev->req = NULL;\n\treturn ret;\n}\n\nint composite_os_desc_req_prepare(struct usb_composite_dev *cdev,\n\t\t\t\t  struct usb_ep *ep0)\n{\n\tint ret = 0;\n\n\tcdev->os_desc_req = usb_ep_alloc_request(ep0, GFP_KERNEL);\n\tif (!cdev->os_desc_req) {\n\t\tret = -ENOMEM;\n\t\tgoto end;\n\t}\n\n\tcdev->os_desc_req->buf = kmalloc(USB_COMP_EP0_OS_DESC_BUFSIZ,\n\t\t\t\t\t GFP_KERNEL);\n\tif (!cdev->os_desc_req->buf) {\n\t\tret = -ENOMEM;\n\t\tusb_ep_free_request(ep0, cdev->os_desc_req);\n\t\tgoto end;\n\t}\n\tcdev->os_desc_req->context = cdev;\n\tcdev->os_desc_req->complete = composite_setup_complete;\nend:\n\treturn ret;\n}\n\nvoid composite_dev_cleanup(struct usb_composite_dev *cdev)\n{\n\tstruct usb_gadget_string_container *uc, *tmp;\n\tstruct usb_ep\t\t\t   *ep, *tmp_ep;\n\n\tlist_for_each_entry_safe(uc, tmp, &cdev->gstrings, list) {\n\t\tlist_del(&uc->list);\n\t\tkfree(uc);\n\t}\n\tif (cdev->os_desc_req) {\n\t\tif (cdev->os_desc_pending)\n\t\t\tusb_ep_dequeue(cdev->gadget->ep0, cdev->os_desc_req);\n\n\t\tkfree(cdev->os_desc_req->buf);\n\t\tcdev->os_desc_req->buf = NULL;\n\t\tusb_ep_free_request(cdev->gadget->ep0, cdev->os_desc_req);\n\t\tcdev->os_desc_req = NULL;\n\t}\n\tif (cdev->req) {\n\t\tif (cdev->setup_pending)\n\t\t\tusb_ep_dequeue(cdev->gadget->ep0, cdev->req);\n\n\t\tkfree(cdev->req->buf);\n\t\tcdev->req->buf = NULL;\n\t\tusb_ep_free_request(cdev->gadget->ep0, cdev->req);\n\t\tcdev->req = NULL;\n\t}\n\tcdev->next_string_id = 0;\n\tdevice_remove_file(&cdev->gadget->dev, &dev_attr_suspended);\n\n\t/*\n\t * Some UDC backends have a dynamic EP allocation scheme.\n\t *\n\t * In that case, the dispose() callback is used to notify the\n\t * backend that the EPs are no longer in use.\n\t *\n\t * Note: The UDC backend can remove the EP from the ep_list as\n\t *\t a result, so we need to use the _safe list iterator.\n\t */\n\tlist_for_each_entry_safe(ep, tmp_ep,\n\t\t\t\t &cdev->gadget->ep_list, ep_list) {\n\t\tif (ep->ops->dispose)\n\t\t\tep->ops->dispose(ep);\n\t}\n}\n\nstatic int composite_bind(struct usb_gadget *gadget,\n\t\tstruct usb_gadget_driver *gdriver)\n{\n\tstruct usb_composite_dev\t*cdev;\n\tstruct usb_composite_driver\t*composite = to_cdriver(gdriver);\n\tint\t\t\t\tstatus = -ENOMEM;\n\n\tcdev = kzalloc(sizeof *cdev, GFP_KERNEL);\n\tif (!cdev)\n\t\treturn status;\n\n\tspin_lock_init(&cdev->lock);\n\tcdev->gadget = gadget;\n\tset_gadget_data(gadget, cdev);\n\tINIT_LIST_HEAD(&cdev->configs);\n\tINIT_LIST_HEAD(&cdev->gstrings);\n\n\tstatus = composite_dev_prepare(composite, cdev);\n\tif (status)\n\t\tgoto fail;\n\n\t/* composite gadget needs to assign strings for whole device (like\n\t * serial number), register function drivers, potentially update\n\t * power state and consumption, etc\n\t */\n\tstatus = composite->bind(cdev);\n\tif (status < 0)\n\t\tgoto fail;\n\n\tif (cdev->use_os_string) {\n\t\tstatus = composite_os_desc_req_prepare(cdev, gadget->ep0);\n\t\tif (status)\n\t\t\tgoto fail;\n\t}\n\n\tupdate_unchanged_dev_desc(&cdev->desc, composite->dev);\n\n\t/* has userspace failed to provide a serial number? */\n\tif (composite->needs_serial && !cdev->desc.iSerialNumber)\n\t\tWARNING(cdev, \"userspace failed to provide iSerialNumber\\n\");\n\n\tINFO(cdev, \"%s ready\\n\", composite->name);\n\treturn 0;\n\nfail:\n\t__composite_unbind(gadget, false);\n\treturn status;\n}\n\n/*-------------------------------------------------------------------------*/\n\nvoid composite_suspend(struct usb_gadget *gadget)\n{\n\tstruct usb_composite_dev\t*cdev = get_gadget_data(gadget);\n\tstruct usb_function\t\t*f;\n\n\t/* REVISIT:  should we have config level\n\t * suspend/resume callbacks?\n\t */\n\tDBG(cdev, \"suspend\\n\");\n\tif (cdev->config) {\n\t\tlist_for_each_entry(f, &cdev->config->functions, list) {\n\t\t\tif (f->suspend)\n\t\t\t\tf->suspend(f);\n\t\t}\n\t}\n\tif (cdev->driver->suspend)\n\t\tcdev->driver->suspend(cdev);\n\n\tcdev->suspended = 1;\n\n\tusb_gadget_set_selfpowered(gadget);\n\tusb_gadget_vbus_draw(gadget, 2);\n}\n\nvoid composite_resume(struct usb_gadget *gadget)\n{\n\tstruct usb_composite_dev\t*cdev = get_gadget_data(gadget);\n\tstruct usb_function\t\t*f;\n\tunsigned\t\t\tmaxpower;\n\n\t/* REVISIT:  should we have config level\n\t * suspend/resume callbacks?\n\t */\n\tDBG(cdev, \"resume\\n\");\n\tif (cdev->driver->resume)\n\t\tcdev->driver->resume(cdev);\n\tif (cdev->config) {\n\t\tlist_for_each_entry(f, &cdev->config->functions, list) {\n\t\t\tif (f->resume)\n\t\t\t\tf->resume(f);\n\t\t}\n\n\t\tmaxpower = cdev->config->MaxPower ?\n\t\t\tcdev->config->MaxPower : CONFIG_USB_GADGET_VBUS_DRAW;\n\t\tif (gadget->speed < USB_SPEED_SUPER)\n\t\t\tmaxpower = min(maxpower, 500U);\n\t\telse\n\t\t\tmaxpower = min(maxpower, 900U);\n\n\t\tif (maxpower > USB_SELF_POWER_VBUS_MAX_DRAW)\n\t\t\tusb_gadget_clear_selfpowered(gadget);\n\n\t\tusb_gadget_vbus_draw(gadget, maxpower);\n\t}\n\n\tcdev->suspended = 0;\n}\n\n/*-------------------------------------------------------------------------*/\n\nstatic const struct usb_gadget_driver composite_driver_template = {\n\t.bind\t\t= composite_bind,\n\t.unbind\t\t= composite_unbind,\n\n\t.setup\t\t= composite_setup,\n\t.reset\t\t= composite_reset,\n\t.disconnect\t= composite_disconnect,\n\n\t.suspend\t= composite_suspend,\n\t.resume\t\t= composite_resume,\n\n\t.driver\t= {\n\t\t.owner\t\t= THIS_MODULE,\n\t},\n};\n\n/**\n * usb_composite_probe() - register a composite driver\n * @driver: the driver to register\n *\n * Context: single threaded during gadget setup\n *\n * This function is used to register drivers using the composite driver\n * framework.  The return value is zero, or a negative errno value.\n * Those values normally come from the driver's @bind method, which does\n * all the work of setting up the driver to match the hardware.\n *\n * On successful return, the gadget is ready to respond to requests from\n * the host, unless one of its components invokes usb_gadget_disconnect()\n * while it was binding.  That would usually be done in order to wait for\n * some userspace participation.\n */\nint usb_composite_probe(struct usb_composite_driver *driver)\n{\n\tstruct usb_gadget_driver *gadget_driver;\n\n\tif (!driver || !driver->dev || !driver->bind)\n\t\treturn -EINVAL;\n\n\tif (!driver->name)\n\t\tdriver->name = \"composite\";\n\n\tdriver->gadget_driver = composite_driver_template;\n\tgadget_driver = &driver->gadget_driver;\n\n\tgadget_driver->function =  (char *) driver->name;\n\tgadget_driver->driver.name = driver->name;\n\tgadget_driver->max_speed = driver->max_speed;\n\n\treturn usb_gadget_probe_driver(gadget_driver);\n}\nEXPORT_SYMBOL_GPL(usb_composite_probe);\n\n/**\n * usb_composite_unregister() - unregister a composite driver\n * @driver: the driver to unregister\n *\n * This function is used to unregister drivers using the composite\n * driver framework.\n */\nvoid usb_composite_unregister(struct usb_composite_driver *driver)\n{\n\tusb_gadget_unregister_driver(&driver->gadget_driver);\n}\nEXPORT_SYMBOL_GPL(usb_composite_unregister);\n\n/**\n * usb_composite_setup_continue() - Continue with the control transfer\n * @cdev: the composite device who's control transfer was kept waiting\n *\n * This function must be called by the USB function driver to continue\n * with the control transfer's data/status stage in case it had requested to\n * delay the data/status stages. A USB function's setup handler (e.g. set_alt())\n * can request the composite framework to delay the setup request's data/status\n * stages by returning USB_GADGET_DELAYED_STATUS.\n */\nvoid usb_composite_setup_continue(struct usb_composite_dev *cdev)\n{\n\tint\t\t\tvalue;\n\tstruct usb_request\t*req = cdev->req;\n\tunsigned long\t\tflags;\n\n\tDBG(cdev, \"%s\\n\", __func__);\n\tspin_lock_irqsave(&cdev->lock, flags);\n\n\tif (cdev->delayed_status == 0) {\n\t\tWARN(cdev, \"%s: Unexpected call\\n\", __func__);\n\n\t} else if (--cdev->delayed_status == 0) {\n\t\tDBG(cdev, \"%s: Completing delayed status\\n\", __func__);\n\t\treq->length = 0;\n\t\treq->context = cdev;\n\t\tvalue = composite_ep0_queue(cdev, req, GFP_ATOMIC);\n\t\tif (value < 0) {\n\t\t\tDBG(cdev, \"ep_queue --> %d\\n\", value);\n\t\t\treq->status = 0;\n\t\t\tcomposite_setup_complete(cdev->gadget->ep0, req);\n\t\t}\n\t}\n\n\tspin_unlock_irqrestore(&cdev->lock, flags);\n}\nEXPORT_SYMBOL_GPL(usb_composite_setup_continue);\n\nstatic char *composite_default_mfr(struct usb_gadget *gadget)\n{\n\treturn kasprintf(GFP_KERNEL, \"%s %s with %s\", init_utsname()->sysname,\n\t\t\t init_utsname()->release, gadget->name);\n}\n\nvoid usb_composite_overwrite_options(struct usb_composite_dev *cdev,\n\t\tstruct usb_composite_overwrite *covr)\n{\n\tstruct usb_device_descriptor\t*desc = &cdev->desc;\n\tstruct usb_gadget_strings\t*gstr = cdev->driver->strings[0];\n\tstruct usb_string\t\t*dev_str = gstr->strings;\n\n\tif (covr->idVendor)\n\t\tdesc->idVendor = cpu_to_le16(covr->idVendor);\n\n\tif (covr->idProduct)\n\t\tdesc->idProduct = cpu_to_le16(covr->idProduct);\n\n\tif (covr->bcdDevice)\n\t\tdesc->bcdDevice = cpu_to_le16(covr->bcdDevice);\n\n\tif (covr->serial_number) {\n\t\tdesc->iSerialNumber = dev_str[USB_GADGET_SERIAL_IDX].id;\n\t\tdev_str[USB_GADGET_SERIAL_IDX].s = covr->serial_number;\n\t}\n\tif (covr->manufacturer) {\n\t\tdesc->iManufacturer = dev_str[USB_GADGET_MANUFACTURER_IDX].id;\n\t\tdev_str[USB_GADGET_MANUFACTURER_IDX].s = covr->manufacturer;\n\n\t} else if (!strlen(dev_str[USB_GADGET_MANUFACTURER_IDX].s)) {\n\t\tdesc->iManufacturer = dev_str[USB_GADGET_MANUFACTURER_IDX].id;\n\t\tcdev->def_manufacturer = composite_default_mfr(cdev->gadget);\n\t\tdev_str[USB_GADGET_MANUFACTURER_IDX].s = cdev->def_manufacturer;\n\t}\n\n\tif (covr->product) {\n\t\tdesc->iProduct = dev_str[USB_GADGET_PRODUCT_IDX].id;\n\t\tdev_str[USB_GADGET_PRODUCT_IDX].s = covr->product;\n\t}\n}\nEXPORT_SYMBOL_GPL(usb_composite_overwrite_options);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"David Brownell\");\n"], "filenames": ["drivers/usb/gadget/composite.c"], "buggy_code_start_loc": [1990], "buggy_code_end_loc": [1990], "fixing_code_start_loc": [1991], "fixing_code_end_loc": [1994], "type": "CWE-476", "message": "An issue was discovered in drivers/usb/gadget/composite.c in the Linux kernel before 5.16.10. The USB Gadget subsystem lacks certain validation of interface OS descriptor requests (ones with a large array index and ones associated with NULL function pointer retrieval). Memory corruption might occur.", "other": {"cve": {"id": "CVE-2022-25258", "sourceIdentifier": "cve@mitre.org", "published": "2022-02-16T20:15:07.517", "lastModified": "2022-12-07T02:12:38.987", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An issue was discovered in drivers/usb/gadget/composite.c in the Linux kernel before 5.16.10. The USB Gadget subsystem lacks certain validation of interface OS descriptor requests (ones with a large array index and ones associated with NULL function pointer retrieval). Memory corruption might occur."}, {"lang": "es", "value": "Se ha descubierto un problema en drivers/usb/gadget/composite.c en el kernel de Linux anterior a la versi\u00f3n 5.16.10. El subsistema USB Gadget carece de cierta validaci\u00f3n de las solicitudes de descriptor del SO de la interfaz (las que tienen un \u00edndice de matriz grande y las asociadas a la recuperaci\u00f3n de punteros de funci\u00f3n NULL). Podr\u00eda producirse una corrupci\u00f3n de memoria"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:P/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "PHYSICAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 4.6, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 0.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:N/I:N/A:C", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "COMPLETE", "baseScore": 4.9}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.9, "impactScore": 6.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-476"}]}], "configurations": [{"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndExcluding": "5.16.10", "matchCriteriaId": "6FADC79F-20B6-4353-B8FF-03CDC52EFBE4"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:35:*:*:*:*:*:*:*", "matchCriteriaId": "80E516C0-98A4-4ADE-B69F-66A772E2BAAA"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:11.0:*:*:*:*:*:*:*", "matchCriteriaId": "FA6FEEC2-9F11-4643-8827-749718254FED"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:netapp:active_iq_unified_manager:-:*:*:*:*:vmware_vsphere:*:*", "matchCriteriaId": "3A756737-1CC4-42C2-A4DF-E1C893B4E2D5"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h300s_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "6770B6C3-732E-4E22-BF1C-2D2FD610061C"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h300s:-:*:*:*:*:*:*:*", "matchCriteriaId": "9F9C8C20-42EB-4AB5-BD97-212DEB070C43"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h500s_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "7FFF7106-ED78-49BA-9EC5-B889E3685D53"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h500s:-:*:*:*:*:*:*:*", "matchCriteriaId": "E63D8B0F-006E-4801-BF9D-1C001BBFB4F9"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h700s_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "56409CEC-5A1E-4450-AA42-641E459CC2AF"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h700s:-:*:*:*:*:*:*:*", "matchCriteriaId": "B06F4839-D16A-4A61-9BB5-55B13F41E47F"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h410s_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "D0B4AD8A-F172-4558-AEC6-FF424BA2D912"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h410s:-:*:*:*:*:*:*:*", "matchCriteriaId": "8497A4C9-8474-4A62-8331-3FE862ED4098"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h410c_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "234DEFE0-5CE5-4B0A-96B8-5D227CB8ED31"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h410c:-:*:*:*:*:*:*:*", "matchCriteriaId": "CDDF61B7-EC5C-467C-B710-B89F502CD04F"}]}]}], "references": [{"url": "https://cdn.kernel.org/pub/linux/kernel/v5.x/ChangeLog-5.16.10", "source": "cve@mitre.org", "tags": ["Release Notes", "Vendor Advisory"]}, {"url": "https://github.com/szymonh/d-os-descriptor", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/75e5b4849b81e19e9efe1654b30d7f3151c33c2c", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2022/03/msg00011.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2022/03/msg00012.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/TCW2KZYJ2H6BKZE3CVLHRIXYDGNYYC5P/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20221028-0007/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.debian.org/security/2022/dsa-5092", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.debian.org/security/2022/dsa-5096", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/75e5b4849b81e19e9efe1654b30d7f3151c33c2c"}}