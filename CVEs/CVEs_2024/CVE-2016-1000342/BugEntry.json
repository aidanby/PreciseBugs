{"buggy_code": ["package org.bouncycastle.asn1;\n\nimport java.io.IOException;\nimport java.math.BigInteger;\n\nimport org.bouncycastle.util.Arrays;\n\n/**\n * Class representing the ASN.1 ENUMERATED type.\n */\npublic class ASN1Enumerated\n    extends ASN1Primitive\n{\n    private final byte[] bytes;\n\n    /**\n     * return an enumerated from the passed in object\n     *\n     * @param obj an ASN1Enumerated or an object that can be converted into one.\n     * @exception IllegalArgumentException if the object cannot be converted.\n     * @return an ASN1Enumerated instance, or null.\n     */\n    public static ASN1Enumerated getInstance(\n        Object  obj)\n    {\n        if (obj == null || obj instanceof ASN1Enumerated)\n        {\n            return (ASN1Enumerated)obj;\n        }\n\n        if (obj instanceof byte[])\n        {\n            try\n            {\n                return (ASN1Enumerated)fromByteArray((byte[])obj);\n            }\n            catch (Exception e)\n            {\n                throw new IllegalArgumentException(\"encoding error in getInstance: \" + e.toString());\n            }\n        }\n\n        throw new IllegalArgumentException(\"illegal object in getInstance: \" + obj.getClass().getName());\n    }\n\n    /**\n     * return an Enumerated from a tagged object.\n     *\n     * @param obj the tagged object holding the object we want\n     * @param explicit true if the object is meant to be explicitly\n     *              tagged false otherwise.\n     * @exception IllegalArgumentException if the tagged object cannot\n     *               be converted.\n     * @return an ASN1Enumerated instance, or null.\n     */\n    public static ASN1Enumerated getInstance(\n        ASN1TaggedObject obj,\n        boolean          explicit)\n    {\n        ASN1Primitive o = obj.getObject();\n\n        if (explicit || o instanceof ASN1Enumerated)\n        {\n            return getInstance(o);\n        }\n        else\n        {\n            return fromOctetString(((ASN1OctetString)o).getOctets());\n        }\n    }\n\n    /**\n     * Constructor from int.\n     *\n     * @param value the value of this enumerated.\n     */\n    public ASN1Enumerated(\n        int         value)\n    {\n        bytes = BigInteger.valueOf(value).toByteArray();\n    }\n\n    /**\n     * Constructor from BigInteger\n     *\n     * @param value the value of this enumerated.\n     */\n    public ASN1Enumerated(\n        BigInteger   value)\n    {\n        bytes = value.toByteArray();\n    }\n\n    /**\n     * Constructor from encoded BigInteger.\n     *\n     * @param bytes the value of this enumerated as an encoded BigInteger (signed).\n     */\n    public ASN1Enumerated(\n        byte[]   bytes)\n    {\n        this.bytes = Arrays.clone(bytes);\n    }\n\n    public BigInteger getValue()\n    {\n        return new BigInteger(bytes);\n    }\n\n    boolean isConstructed()\n    {\n        return false;\n    }\n\n    int encodedLength()\n    {\n        return 1 + StreamUtil.calculateBodyLength(bytes.length) + bytes.length;\n    }\n\n    void encode(\n        ASN1OutputStream out)\n        throws IOException\n    {\n        out.writeEncoded(BERTags.ENUMERATED, bytes);\n    }\n    \n    boolean asn1Equals(\n        ASN1Primitive  o)\n    {\n        if (!(o instanceof ASN1Enumerated))\n        {\n            return false;\n        }\n\n        ASN1Enumerated other = (ASN1Enumerated)o;\n\n        return Arrays.areEqual(this.bytes, other.bytes);\n    }\n\n    public int hashCode()\n    {\n        return Arrays.hashCode(bytes);\n    }\n\n    private static ASN1Enumerated[] cache = new ASN1Enumerated[12];\n\n    static ASN1Enumerated fromOctetString(byte[] enc)\n    {\n        if (enc.length > 1)\n        {\n            return new ASN1Enumerated(enc);\n        }\n\n        if (enc.length == 0)\n        {\n            throw new IllegalArgumentException(\"ENUMERATED has zero length\");\n        }\n        int value = enc[0] & 0xff;\n\n        if (value >= cache.length)\n        {\n            return new ASN1Enumerated(Arrays.clone(enc));\n        }\n\n        ASN1Enumerated possibleMatch = cache[value];\n\n        if (possibleMatch == null)\n        {\n            possibleMatch = cache[value] = new ASN1Enumerated(Arrays.clone(enc));\n        }\n\n        return possibleMatch;\n    }\n}\n", "package org.bouncycastle.asn1;\n\nimport java.io.IOException;\nimport java.math.BigInteger;\n\nimport org.bouncycastle.util.Arrays;\n\n/**\n * Class representing the ASN.1 INTEGER type.\n */\npublic class ASN1Integer\n    extends ASN1Primitive\n{\n    private final byte[] bytes;\n\n    /**\n     * return an integer from the passed in object\n     *\n     * @param obj an ASN1Integer or an object that can be converted into one.\n     * @throws IllegalArgumentException if the object cannot be converted.\n     * @return an ASN1Integer instance.\n     */\n    public static ASN1Integer getInstance(\n        Object obj)\n    {\n        if (obj == null || obj instanceof ASN1Integer)\n        {\n            return (ASN1Integer)obj;\n        }\n\n        if (obj instanceof byte[])\n        {\n            try\n            {\n                return (ASN1Integer)fromByteArray((byte[])obj);\n            }\n            catch (Exception e)\n            {\n                throw new IllegalArgumentException(\"encoding error in getInstance: \" + e.toString());\n            }\n        }\n\n        throw new IllegalArgumentException(\"illegal object in getInstance: \" + obj.getClass().getName());\n    }\n\n    /**\n     * return an Integer from a tagged object.\n     *\n     * @param obj      the tagged object holding the object we want\n     * @param explicit true if the object is meant to be explicitly\n     *                 tagged false otherwise.\n     * @throws IllegalArgumentException if the tagged object cannot\n     * be converted.\n     * @return an ASN1Integer instance.\n     */\n    public static ASN1Integer getInstance(\n        ASN1TaggedObject obj,\n        boolean explicit)\n    {\n        ASN1Primitive o = obj.getObject();\n\n        if (explicit || o instanceof ASN1Integer)\n        {\n            return getInstance(o);\n        }\n        else\n        {\n            return new ASN1Integer(ASN1OctetString.getInstance(obj.getObject()).getOctets());\n        }\n    }\n\n    public ASN1Integer(\n        long value)\n    {\n        bytes = BigInteger.valueOf(value).toByteArray();\n    }\n\n    public ASN1Integer(\n        BigInteger value)\n    {\n        bytes = value.toByteArray();\n    }\n\n    public ASN1Integer(\n        byte[] bytes)\n    {\n        this(bytes, true);\n    }\n\n    ASN1Integer(byte[] bytes, boolean clone)\n    {\n        this.bytes = (clone) ? Arrays.clone(bytes) : bytes;\n    }\n\n    public BigInteger getValue()\n    {\n        return new BigInteger(bytes);\n    }\n\n    /**\n     * in some cases positive values get crammed into a space,\n     * that's not quite big enough...\n     * @return the BigInteger that results from treating this ASN.1 INTEGER as unsigned.\n     */\n    public BigInteger getPositiveValue()\n    {\n        return new BigInteger(1, bytes);\n    }\n\n    boolean isConstructed()\n    {\n        return false;\n    }\n\n    int encodedLength()\n    {\n        return 1 + StreamUtil.calculateBodyLength(bytes.length) + bytes.length;\n    }\n\n    void encode(\n        ASN1OutputStream out)\n        throws IOException\n    {\n        out.writeEncoded(BERTags.INTEGER, bytes);\n    }\n\n    public int hashCode()\n    {\n        int value = 0;\n\n        for (int i = 0; i != bytes.length; i++)\n        {\n            value ^= (bytes[i] & 0xff) << (i % 4);\n        }\n\n        return value;\n    }\n\n    boolean asn1Equals(\n        ASN1Primitive o)\n    {\n        if (!(o instanceof ASN1Integer))\n        {\n            return false;\n        }\n\n        ASN1Integer other = (ASN1Integer)o;\n\n        return Arrays.areEqual(bytes, other.bytes);\n    }\n\n    public String toString()\n    {\n        return getValue().toString();\n    }\n\n}\n", "package org.bouncycastle.asn1.test;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\n\nimport org.bouncycastle.asn1.ASN1Encodable;\nimport org.bouncycastle.asn1.ASN1InputStream;\nimport org.bouncycastle.asn1.ASN1OutputStream;\nimport org.bouncycastle.asn1.ASN1Primitive;\nimport org.bouncycastle.asn1.BERSequence;\nimport org.bouncycastle.asn1.DERBitString;\nimport org.bouncycastle.asn1.DERIA5String;\nimport org.bouncycastle.asn1.misc.CAST5CBCParameters;\nimport org.bouncycastle.asn1.misc.IDEACBCPar;\nimport org.bouncycastle.asn1.misc.NetscapeCertType;\nimport org.bouncycastle.asn1.misc.NetscapeRevocationURL;\nimport org.bouncycastle.asn1.misc.VerisignCzagExtension;\nimport org.bouncycastle.util.Arrays;\nimport org.bouncycastle.util.encoders.Base64;\nimport org.bouncycastle.util.test.SimpleTest;\n\npublic class MiscTest\n    extends SimpleTest\n{\n    private boolean isSameAs(\n        byte[]  a,\n        byte[]  b)\n    {\n        if (a.length != b.length)\n        {\n            return false;\n        }\n        \n        for (int i = 0; i != a.length; i++)\n        {\n            if (a[i] != b[i])\n            {\n                return false;\n            }\n        }\n        \n        return true;\n    }\n\n    public void shouldFailOnExtraData()\n        throws Exception\n    {\n        // basic construction\n        DERBitString s1 = new DERBitString(new byte[0], 0);\n\n        ASN1Primitive.fromByteArray(s1.getEncoded());\n\n        ASN1Primitive.fromByteArray(new BERSequence(s1).getEncoded());\n\n        try\n        {\n            ASN1Primitive obj = ASN1Primitive.fromByteArray(Arrays.concatenate(s1.getEncoded(), new byte[1]));\n            fail(\"no exception\");\n        }\n        catch (IOException e)\n        {\n            if (!\"Extra data detected in stream\".equals(e.getMessage()))\n            {\n                fail(\"wrong exception\");\n            }\n        }\n    }\n\n    public void performTest()\n        throws Exception\n    {\n        byte[]  testIv = { 1, 2, 3, 4, 5, 6, 7, 8 };\n        \n        ASN1Encodable[]     values = {\n            new CAST5CBCParameters(testIv, 128), \n            new NetscapeCertType(NetscapeCertType.smime),    \n            new VerisignCzagExtension(new DERIA5String(\"hello\")),\n            new IDEACBCPar(testIv),        \n            new NetscapeRevocationURL(new DERIA5String(\"http://test\"))\n        };\n        \n        byte[] data = Base64.decode(\"MA4ECAECAwQFBgcIAgIAgAMCBSAWBWhlbGxvMAoECAECAwQFBgcIFgtodHRwOi8vdGVzdA==\");\n\n        ByteArrayOutputStream bOut = new ByteArrayOutputStream();\n        ASN1OutputStream aOut = new ASN1OutputStream(bOut);\n\n        for (int i = 0; i != values.length; i++)\n        {\n            aOut.writeObject(values[i]);\n        }\n\n        ASN1Primitive[] readValues = new ASN1Primitive[values.length];\n\n        if (!isSameAs(bOut.toByteArray(), data))\n        {\n            fail(\"Failed data check\");\n        }\n\n        ByteArrayInputStream bIn = new ByteArrayInputStream(bOut.toByteArray());\n        ASN1InputStream aIn = new ASN1InputStream(bIn);\n\n        for (int i = 0; i != values.length; i++)\n        {\n            ASN1Primitive o = aIn.readObject();\n            if (!values[i].equals(o))\n            {\n                fail(\"Failed equality test for \" + o);\n            }\n\n            if (o.hashCode() != values[i].hashCode())\n            {\n                fail(\"Failed hashCode test for \" + o);\n            }\n        }\n\n        shouldFailOnExtraData();\n    }\n\n    public String getName()\n    {\n        return \"Misc\";\n    }\n\n    public static void main(\n        String[] args)\n    {\n        runTest(new MiscTest());\n    }\n}\n", "package org.bouncycastle.jcajce.provider.asymmetric.dsa;\n\nimport java.io.IOException;\nimport java.math.BigInteger;\nimport java.security.InvalidKeyException;\nimport java.security.PrivateKey;\nimport java.security.PublicKey;\nimport java.security.SecureRandom;\nimport java.security.SignatureException;\nimport java.security.SignatureSpi;\nimport java.security.spec.AlgorithmParameterSpec;\n\nimport org.bouncycastle.asn1.ASN1Encoding;\nimport org.bouncycastle.asn1.ASN1Integer;\nimport org.bouncycastle.asn1.ASN1Primitive;\nimport org.bouncycastle.asn1.ASN1Sequence;\nimport org.bouncycastle.asn1.DERSequence;\nimport org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers;\nimport org.bouncycastle.asn1.x509.X509ObjectIdentifiers;\nimport org.bouncycastle.crypto.CipherParameters;\nimport org.bouncycastle.crypto.DSA;\nimport org.bouncycastle.crypto.Digest;\nimport org.bouncycastle.crypto.digests.NullDigest;\nimport org.bouncycastle.crypto.digests.SHA1Digest;\nimport org.bouncycastle.crypto.digests.SHA224Digest;\nimport org.bouncycastle.crypto.digests.SHA256Digest;\nimport org.bouncycastle.crypto.digests.SHA384Digest;\nimport org.bouncycastle.crypto.digests.SHA3Digest;\nimport org.bouncycastle.crypto.digests.SHA512Digest;\nimport org.bouncycastle.crypto.params.ParametersWithRandom;\nimport org.bouncycastle.crypto.signers.HMacDSAKCalculator;\n\npublic class DSASigner\n    extends SignatureSpi\n    implements PKCSObjectIdentifiers, X509ObjectIdentifiers\n{\n    private Digest                  digest;\n    private DSA                     signer;\n    private SecureRandom            random;\n\n    protected DSASigner(\n        Digest digest,\n        DSA signer)\n    {\n        this.digest = digest;\n        this.signer = signer;\n    }\n\n    protected void engineInitVerify(\n        PublicKey   publicKey)\n        throws InvalidKeyException\n    {\n        CipherParameters    param = DSAUtil.generatePublicKeyParameter(publicKey);\n\n        digest.reset();\n        signer.init(false, param);\n    }\n\n    protected void engineInitSign(\n        PrivateKey      privateKey,\n        SecureRandom    random)\n        throws InvalidKeyException\n    {\n        this.random = random;\n        engineInitSign(privateKey);\n    }\n\n    protected void engineInitSign(\n        PrivateKey  privateKey)\n        throws InvalidKeyException\n    {\n        CipherParameters    param = DSAUtil.generatePrivateKeyParameter(privateKey);\n\n        if (random != null)\n        {\n            param = new ParametersWithRandom(param, random);\n        }\n\n        digest.reset();\n        signer.init(true, param);\n    }\n\n    protected void engineUpdate(\n        byte    b)\n        throws SignatureException\n    {\n        digest.update(b);\n    }\n\n    protected void engineUpdate(\n        byte[]  b,\n        int     off,\n        int     len) \n        throws SignatureException\n    {\n        digest.update(b, off, len);\n    }\n\n    protected byte[] engineSign()\n        throws SignatureException\n    {\n        byte[]  hash = new byte[digest.getDigestSize()];\n\n        digest.doFinal(hash, 0);\n\n        try\n        {\n            BigInteger[]    sig = signer.generateSignature(hash);\n\n            return derEncode(sig[0], sig[1]);\n        }\n        catch (Exception e)\n        {\n            throw new SignatureException(e.toString());\n        }\n    }\n\n    protected boolean engineVerify(\n        byte[]  sigBytes) \n        throws SignatureException\n    {\n        byte[]  hash = new byte[digest.getDigestSize()];\n\n        digest.doFinal(hash, 0);\n\n        BigInteger[]    sig;\n\n        try\n        {\n            sig = derDecode(sigBytes);\n        }\n        catch (Exception e)\n        {\n            throw new SignatureException(\"error decoding signature bytes.\");\n        }\n\n        return signer.verifySignature(hash, sig[0], sig[1]);\n    }\n\n    protected void engineSetParameter(\n        AlgorithmParameterSpec params)\n    {\n        throw new UnsupportedOperationException(\"engineSetParameter unsupported\");\n    }\n\n    /**\n     * @deprecated replaced with <a href = \"#engineSetParameter(java.security.spec.AlgorithmParameterSpec)\">\n     */\n    protected void engineSetParameter(\n        String  param,\n        Object  value)\n    {\n        throw new UnsupportedOperationException(\"engineSetParameter unsupported\");\n    }\n\n    /**\n     * @deprecated\n     */\n    protected Object engineGetParameter(\n        String      param)\n    {\n        throw new UnsupportedOperationException(\"engineSetParameter unsupported\");\n    }\n\n    private byte[] derEncode(\n        BigInteger  r,\n        BigInteger  s)\n        throws IOException\n    {\n        ASN1Integer[] rs = new ASN1Integer[]{ new ASN1Integer(r), new ASN1Integer(s) };\n        return new DERSequence(rs).getEncoded(ASN1Encoding.DER);\n    }\n\n    private BigInteger[] derDecode(\n        byte[]  encoding)\n        throws IOException\n    {\n        ASN1Sequence s = (ASN1Sequence)ASN1Primitive.fromByteArray(encoding);\n        if (s.size() != 2)\n        {\n            throw new IOException(\"malformed signature\");\n        }\n\n        return new BigInteger[]{\n            ((ASN1Integer)s.getObjectAt(0)).getValue(),\n            ((ASN1Integer)s.getObjectAt(1)).getValue()\n        };\n    }\n\n    static public class stdDSA\n        extends DSASigner\n    {\n        public stdDSA()\n        {\n            super(new SHA1Digest(), new org.bouncycastle.crypto.signers.DSASigner());\n        }\n    }\n\n    static public class detDSA\n        extends DSASigner\n    {\n        public detDSA()\n        {\n            super(new SHA1Digest(), new org.bouncycastle.crypto.signers.DSASigner(new HMacDSAKCalculator(new SHA1Digest())));\n        }\n    }\n\n    static public class dsa224\n        extends DSASigner\n    {\n        public dsa224()\n        {\n            super(new SHA224Digest(), new org.bouncycastle.crypto.signers.DSASigner());\n        }\n    }\n\n    static public class detDSA224\n        extends DSASigner\n    {\n        public detDSA224()\n        {\n            super(new SHA224Digest(), new org.bouncycastle.crypto.signers.DSASigner(new HMacDSAKCalculator(new SHA224Digest())));\n        }\n    }\n\n    static public class dsa256\n        extends DSASigner\n    {\n        public dsa256()\n        {\n            super(new SHA256Digest(), new org.bouncycastle.crypto.signers.DSASigner());\n        }\n    }\n\n    static public class detDSA256\n        extends DSASigner\n    {\n        public detDSA256()\n        {\n            super(new SHA256Digest(), new org.bouncycastle.crypto.signers.DSASigner(new HMacDSAKCalculator(new SHA256Digest())));\n        }\n    }\n\n    static public class dsa384\n        extends DSASigner\n    {\n        public dsa384()\n        {\n            super(new SHA384Digest(), new org.bouncycastle.crypto.signers.DSASigner());\n        }\n    }\n\n    static public class detDSA384\n        extends DSASigner\n    {\n        public detDSA384()\n        {\n            super(new SHA384Digest(), new org.bouncycastle.crypto.signers.DSASigner(new HMacDSAKCalculator(new SHA384Digest())));\n        }\n    }\n\n    static public class dsa512\n        extends DSASigner\n    {\n        public dsa512()\n        {\n            super(new SHA512Digest(), new org.bouncycastle.crypto.signers.DSASigner());\n        }\n    }\n\n    static public class detDSA512\n        extends DSASigner\n    {\n        public detDSA512()\n        {\n            super(new SHA512Digest(), new org.bouncycastle.crypto.signers.DSASigner(new HMacDSAKCalculator(new SHA512Digest())));\n        }\n    }\n\n    static public class dsaSha3_224\n        extends DSASigner\n    {\n        public dsaSha3_224()\n        {\n            super(new SHA3Digest(224), new org.bouncycastle.crypto.signers.DSASigner());\n        }\n    }\n\n    static public class detDSASha3_224\n        extends DSASigner\n    {\n        public detDSASha3_224()\n        {\n            super(new SHA3Digest(224), new org.bouncycastle.crypto.signers.DSASigner(new HMacDSAKCalculator(new SHA3Digest(224))));\n        }\n    }\n\n    static public class dsaSha3_256\n        extends DSASigner\n    {\n        public dsaSha3_256()\n        {\n            super(new SHA3Digest(256), new org.bouncycastle.crypto.signers.DSASigner());\n        }\n    }\n\n    static public class detDSASha3_256\n        extends DSASigner\n    {\n        public detDSASha3_256()\n        {\n            super(new SHA3Digest(256), new org.bouncycastle.crypto.signers.DSASigner(new HMacDSAKCalculator(new SHA3Digest(256))));\n        }\n    }\n\n    static public class dsaSha3_384\n        extends DSASigner\n    {\n        public dsaSha3_384()\n        {\n            super(new SHA3Digest(384), new org.bouncycastle.crypto.signers.DSASigner());\n        }\n    }\n\n    static public class detDSASha3_384\n        extends DSASigner\n    {\n        public detDSASha3_384()\n        {\n            super(new SHA3Digest(384), new org.bouncycastle.crypto.signers.DSASigner(new HMacDSAKCalculator(new SHA3Digest(384))));\n        }\n    }\n\n    static public class dsaSha3_512\n        extends DSASigner\n    {\n        public dsaSha3_512()\n        {\n            super(new SHA3Digest(512), new org.bouncycastle.crypto.signers.DSASigner());\n        }\n    }\n\n    static public class detDSASha3_512\n        extends DSASigner\n    {\n        public detDSASha3_512()\n        {\n            super(new SHA3Digest(512), new org.bouncycastle.crypto.signers.DSASigner(new HMacDSAKCalculator(new SHA3Digest(512))));\n        }\n    }\n\n    static public class noneDSA\n        extends DSASigner\n    {\n        public noneDSA()\n        {\n            super(new NullDigest(), new org.bouncycastle.crypto.signers.DSASigner());\n        }\n    }\n}\n", "package org.bouncycastle.jcajce.provider.asymmetric.ec;\n\nimport java.io.IOException;\nimport java.math.BigInteger;\nimport java.security.InvalidKeyException;\nimport java.security.PrivateKey;\nimport java.security.PublicKey;\n\nimport org.bouncycastle.asn1.ASN1EncodableVector;\nimport org.bouncycastle.asn1.ASN1Encoding;\nimport org.bouncycastle.asn1.ASN1Integer;\nimport org.bouncycastle.asn1.ASN1Primitive;\nimport org.bouncycastle.asn1.ASN1Sequence;\nimport org.bouncycastle.asn1.DERSequence;\nimport org.bouncycastle.crypto.CipherParameters;\nimport org.bouncycastle.crypto.DSA;\nimport org.bouncycastle.crypto.Digest;\nimport org.bouncycastle.crypto.digests.NullDigest;\nimport org.bouncycastle.crypto.digests.RIPEMD160Digest;\nimport org.bouncycastle.crypto.digests.SHA1Digest;\nimport org.bouncycastle.crypto.digests.SHA224Digest;\nimport org.bouncycastle.crypto.digests.SHA256Digest;\nimport org.bouncycastle.crypto.digests.SHA384Digest;\nimport org.bouncycastle.crypto.digests.SHA3Digest;\nimport org.bouncycastle.crypto.digests.SHA512Digest;\nimport org.bouncycastle.crypto.params.ECPublicKeyParameters;\nimport org.bouncycastle.crypto.params.ParametersWithRandom;\nimport org.bouncycastle.crypto.signers.ECDSASigner;\nimport org.bouncycastle.crypto.signers.ECNRSigner;\nimport org.bouncycastle.crypto.signers.HMacDSAKCalculator;\nimport org.bouncycastle.jcajce.provider.asymmetric.util.DSABase;\nimport org.bouncycastle.jcajce.provider.asymmetric.util.DSAEncoder;\nimport org.bouncycastle.jcajce.provider.asymmetric.util.ECUtil;\n\npublic class SignatureSpi\n    extends DSABase\n{\n    SignatureSpi(Digest digest, DSA signer, DSAEncoder encoder)\n    {\n        super(digest, signer, encoder);\n    }\n\n    protected void engineInitVerify(PublicKey publicKey)\n        throws InvalidKeyException\n    {\n        CipherParameters param = ECUtils.generatePublicKeyParameter(publicKey);\n\n        digest.reset();\n        signer.init(false, param);\n    }\n\n    protected void engineInitSign(\n        PrivateKey privateKey)\n        throws InvalidKeyException\n    {\n        CipherParameters param = ECUtil.generatePrivateKeyParameter(privateKey);\n\n        digest.reset();\n\n        if (appRandom != null)\n        {\n            signer.init(true, new ParametersWithRandom(param, appRandom));\n        }\n        else\n        {\n            signer.init(true, param);\n        }\n    }\n\n    static public class ecDSA\n        extends SignatureSpi\n    {\n        public ecDSA()\n        {\n            super(new SHA1Digest(), new ECDSASigner(), new StdDSAEncoder());\n        }\n    }\n\n    static public class ecDetDSA\n        extends SignatureSpi\n    {\n        public ecDetDSA()\n        {\n            super(new SHA1Digest(), new ECDSASigner(new HMacDSAKCalculator(new SHA1Digest())), new StdDSAEncoder());\n        }\n    }\n\n    static public class ecDSAnone\n        extends SignatureSpi\n    {\n        public ecDSAnone()\n        {\n            super(new NullDigest(), new ECDSASigner(), new StdDSAEncoder());\n        }\n    }\n\n    static public class ecDSA224\n        extends SignatureSpi\n    {\n        public ecDSA224()\n        {\n            super(new SHA224Digest(), new ECDSASigner(), new StdDSAEncoder());\n        }\n    }\n\n    static public class ecDetDSA224\n        extends SignatureSpi\n    {\n        public ecDetDSA224()\n        {\n            super(new SHA224Digest(), new ECDSASigner(new HMacDSAKCalculator(new SHA224Digest())), new StdDSAEncoder());\n        }\n    }\n\n    static public class ecDSA256\n        extends SignatureSpi\n    {\n        public ecDSA256()\n        {\n            super(new SHA256Digest(), new ECDSASigner(), new StdDSAEncoder());\n        }\n    }\n\n    static public class ecDetDSA256\n        extends SignatureSpi\n    {\n        public ecDetDSA256()\n        {\n            super(new SHA256Digest(), new ECDSASigner(new HMacDSAKCalculator(new SHA256Digest())), new StdDSAEncoder());\n        }\n    }\n\n    static public class ecDSA384\n        extends SignatureSpi\n    {\n        public ecDSA384()\n        {\n            super(new SHA384Digest(), new ECDSASigner(), new StdDSAEncoder());\n        }\n    }\n\n    static public class ecDetDSA384\n        extends SignatureSpi\n    {\n        public ecDetDSA384()\n        {\n            super(new SHA384Digest(), new ECDSASigner(new HMacDSAKCalculator(new SHA384Digest())), new StdDSAEncoder());\n        }\n    }\n\n    static public class ecDSA512\n        extends SignatureSpi\n    {\n        public ecDSA512()\n        {\n            super(new SHA512Digest(), new ECDSASigner(), new StdDSAEncoder());\n        }\n    }\n\n    static public class ecDetDSA512\n        extends SignatureSpi\n    {\n        public ecDetDSA512()\n        {\n            super(new SHA512Digest(), new ECDSASigner(new HMacDSAKCalculator(new SHA512Digest())), new StdDSAEncoder());\n        }\n    }\n\n    static public class ecDSASha3_224\n        extends SignatureSpi\n    {\n        public ecDSASha3_224()\n        {\n            super(new SHA3Digest(224), new ECDSASigner(), new StdDSAEncoder());\n        }\n    }\n\n    static public class ecDetDSASha3_224\n        extends SignatureSpi\n    {\n        public ecDetDSASha3_224()\n        {\n            super(new SHA3Digest(224), new ECDSASigner(new HMacDSAKCalculator(new SHA3Digest(224))), new StdDSAEncoder());\n        }\n    }\n\n    static public class ecDSASha3_256\n        extends SignatureSpi\n    {\n        public ecDSASha3_256()\n        {\n            super(new SHA3Digest(256), new ECDSASigner(), new StdDSAEncoder());\n        }\n    }\n\n    static public class ecDetDSASha3_256\n        extends SignatureSpi\n    {\n        public ecDetDSASha3_256()\n        {\n            super(new SHA3Digest(256), new ECDSASigner(new HMacDSAKCalculator(new SHA3Digest(256))), new StdDSAEncoder());\n        }\n    }\n\n    static public class ecDSASha3_384\n        extends SignatureSpi\n    {\n        public ecDSASha3_384()\n        {\n            super(new SHA3Digest(384), new ECDSASigner(), new StdDSAEncoder());\n        }\n    }\n\n    static public class ecDetDSASha3_384\n        extends SignatureSpi\n    {\n        public ecDetDSASha3_384()\n        {\n            super(new SHA3Digest(384), new ECDSASigner(new HMacDSAKCalculator(new SHA3Digest(384))), new StdDSAEncoder());\n        }\n    }\n\n    static public class ecDSASha3_512\n        extends SignatureSpi\n    {\n        public ecDSASha3_512()\n        {\n            super(new SHA3Digest(512), new ECDSASigner(), new StdDSAEncoder());\n        }\n    }\n\n    static public class ecDetDSASha3_512\n        extends SignatureSpi\n    {\n        public ecDetDSASha3_512()\n        {\n            super(new SHA3Digest(512), new ECDSASigner(new HMacDSAKCalculator(new SHA3Digest(512))), new StdDSAEncoder());\n        }\n    }\n\n    static public class ecDSARipeMD160\n        extends SignatureSpi\n    {\n        public ecDSARipeMD160()\n        {\n            super(new RIPEMD160Digest(), new ECDSASigner(), new StdDSAEncoder());\n        }\n    }\n\n    static public class ecNR\n        extends SignatureSpi\n    {\n        public ecNR()\n        {\n            super(new SHA1Digest(), new ECNRSigner(), new StdDSAEncoder());\n        }\n    }\n\n    static public class ecNR224\n        extends SignatureSpi\n    {\n        public ecNR224()\n        {\n            super(new SHA224Digest(), new ECNRSigner(), new StdDSAEncoder());\n        }\n    }\n\n    static public class ecNR256\n        extends SignatureSpi\n    {\n        public ecNR256()\n        {\n            super(new SHA256Digest(), new ECNRSigner(), new StdDSAEncoder());\n        }\n    }\n\n    static public class ecNR384\n        extends SignatureSpi\n    {\n        public ecNR384()\n        {\n            super(new SHA384Digest(), new ECNRSigner(), new StdDSAEncoder());\n        }\n    }\n\n    static public class ecNR512\n        extends SignatureSpi\n    {\n        public ecNR512()\n        {\n            super(new SHA512Digest(), new ECNRSigner(), new StdDSAEncoder());\n        }\n    }\n\n    static public class ecCVCDSA\n        extends SignatureSpi\n    {\n        public ecCVCDSA()\n        {\n            super(new SHA1Digest(), new ECDSASigner(), new PlainDSAEncoder());\n        }\n    }\n\n    static public class ecCVCDSA224\n        extends SignatureSpi\n    {\n        public ecCVCDSA224()\n        {\n            super(new SHA224Digest(), new ECDSASigner(), new PlainDSAEncoder());\n        }\n    }\n\n    static public class ecCVCDSA256\n        extends SignatureSpi\n    {\n        public ecCVCDSA256()\n        {\n            super(new SHA256Digest(), new ECDSASigner(), new PlainDSAEncoder());\n        }\n    }\n\n    static public class ecCVCDSA384\n        extends SignatureSpi\n    {\n        public ecCVCDSA384()\n        {\n            super(new SHA384Digest(), new ECDSASigner(), new PlainDSAEncoder());\n        }\n    }\n\n    static public class ecCVCDSA512\n        extends SignatureSpi\n    {\n        public ecCVCDSA512()\n        {\n            super(new SHA512Digest(), new ECDSASigner(), new PlainDSAEncoder());\n        }\n    }\n\n    static public class ecPlainDSARP160\n        extends SignatureSpi\n    {\n        public ecPlainDSARP160()\n        {\n            super(new RIPEMD160Digest(), new ECDSASigner(), new PlainDSAEncoder());\n        }\n    }\n\n    private static class StdDSAEncoder\n        implements DSAEncoder\n    {\n        public byte[] encode(\n            BigInteger r,\n            BigInteger s)\n            throws IOException\n        {\n            ASN1EncodableVector v = new ASN1EncodableVector();\n\n            v.add(new ASN1Integer(r));\n            v.add(new ASN1Integer(s));\n\n            return new DERSequence(v).getEncoded(ASN1Encoding.DER);\n        }\n\n        public BigInteger[] decode(\n            byte[] encoding)\n            throws IOException\n        {\n            ASN1Sequence s = (ASN1Sequence)ASN1Primitive.fromByteArray(encoding);\n            BigInteger[] sig = new BigInteger[2];\n\n            sig[0] = ASN1Integer.getInstance(s.getObjectAt(0)).getValue();\n            sig[1] = ASN1Integer.getInstance(s.getObjectAt(1)).getValue();\n\n            return sig;\n        }\n    }\n\n    private static class PlainDSAEncoder\n        implements DSAEncoder\n    {\n        public byte[] encode(\n            BigInteger r,\n            BigInteger s)\n            throws IOException\n        {\n            byte[] first = makeUnsigned(r);\n            byte[] second = makeUnsigned(s);\n            byte[] res;\n\n            if (first.length > second.length)\n            {\n                res = new byte[first.length * 2];\n            }\n            else\n            {\n                res = new byte[second.length * 2];\n            }\n\n            System.arraycopy(first, 0, res, res.length / 2 - first.length, first.length);\n            System.arraycopy(second, 0, res, res.length - second.length, second.length);\n\n            return res;\n        }\n\n\n        private byte[] makeUnsigned(BigInteger val)\n        {\n            byte[] res = val.toByteArray();\n\n            if (res[0] == 0)\n            {\n                byte[] tmp = new byte[res.length - 1];\n\n                System.arraycopy(res, 1, tmp, 0, tmp.length);\n\n                return tmp;\n            }\n\n            return res;\n        }\n\n        public BigInteger[] decode(\n            byte[] encoding)\n            throws IOException\n        {\n            BigInteger[] sig = new BigInteger[2];\n\n            byte[] first = new byte[encoding.length / 2];\n            byte[] second = new byte[encoding.length / 2];\n\n            System.arraycopy(encoding, 0, first, 0, first.length);\n            System.arraycopy(encoding, first.length, second, 0, second.length);\n\n            sig[0] = new BigInteger(1, first);\n            sig[1] = new BigInteger(1, second);\n\n            return sig;\n        }\n    }\n}", "package org.bouncycastle.jce.provider.test;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.math.BigInteger;\nimport java.security.AlgorithmParameterGenerator;\nimport java.security.AlgorithmParameters;\nimport java.security.InvalidKeyException;\nimport java.security.KeyFactory;\nimport java.security.KeyPair;\nimport java.security.KeyPairGenerator;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.NoSuchProviderException;\nimport java.security.PrivateKey;\nimport java.security.PublicKey;\nimport java.security.SecureRandom;\nimport java.security.Security;\nimport java.security.Signature;\nimport java.security.SignatureException;\nimport java.security.interfaces.DSAPrivateKey;\nimport java.security.interfaces.DSAPublicKey;\nimport java.security.spec.DSAParameterSpec;\nimport java.security.spec.DSAPrivateKeySpec;\nimport java.security.spec.DSAPublicKeySpec;\nimport java.security.spec.InvalidKeySpecException;\nimport java.security.spec.PKCS8EncodedKeySpec;\nimport java.security.spec.X509EncodedKeySpec;\n\nimport org.bouncycastle.asn1.ASN1InputStream;\nimport org.bouncycastle.asn1.ASN1Integer;\nimport org.bouncycastle.asn1.ASN1ObjectIdentifier;\nimport org.bouncycastle.asn1.ASN1Primitive;\nimport org.bouncycastle.asn1.ASN1Sequence;\nimport org.bouncycastle.asn1.eac.EACObjectIdentifiers;\nimport org.bouncycastle.asn1.nist.NISTNamedCurves;\nimport org.bouncycastle.asn1.nist.NISTObjectIdentifiers;\nimport org.bouncycastle.asn1.teletrust.TeleTrusTObjectIdentifiers;\nimport org.bouncycastle.asn1.x509.AlgorithmIdentifier;\nimport org.bouncycastle.asn1.x509.SubjectPublicKeyInfo;\nimport org.bouncycastle.asn1.x9.X9ECParameters;\nimport org.bouncycastle.asn1.x9.X9ObjectIdentifiers;\nimport org.bouncycastle.crypto.params.DSAParameters;\nimport org.bouncycastle.crypto.params.DSAPublicKeyParameters;\nimport org.bouncycastle.crypto.params.ECDomainParameters;\nimport org.bouncycastle.crypto.signers.DSASigner;\nimport org.bouncycastle.jce.interfaces.PKCS12BagAttributeCarrier;\nimport org.bouncycastle.jce.provider.BouncyCastleProvider;\nimport org.bouncycastle.jce.spec.ECNamedCurveGenParameterSpec;\nimport org.bouncycastle.jce.spec.ECParameterSpec;\nimport org.bouncycastle.jce.spec.ECPrivateKeySpec;\nimport org.bouncycastle.jce.spec.ECPublicKeySpec;\nimport org.bouncycastle.math.ec.ECCurve;\nimport org.bouncycastle.util.Arrays;\nimport org.bouncycastle.util.BigIntegers;\nimport org.bouncycastle.util.Strings;\nimport org.bouncycastle.util.encoders.Hex;\nimport org.bouncycastle.util.test.FixedSecureRandom;\nimport org.bouncycastle.util.test.SimpleTest;\nimport org.bouncycastle.util.test.TestRandomBigInteger;\nimport org.bouncycastle.util.test.TestRandomData;\n\npublic class DSATest\n    extends SimpleTest\n{\n    byte[] k1 = Hex.decode(\"d5014e4b60ef2ba8b6211b4062ba3224e0427dd3\");\n    byte[] k2 = Hex.decode(\"345e8d05c075c3a508df729a1685690e68fcfb8c8117847e89063bca1f85d968fd281540b6e13bd1af989a1fbf17e06462bf511f9d0b140fb48ac1b1baa5bded\");\n\n    SecureRandom    random = new FixedSecureRandom(new byte[][] { k1, k2 });\n\n    // DSA modified signatures, courtesy of the Google security team\n    static final DSAPrivateKeySpec PRIVATE_KEY = new DSAPrivateKeySpec(\n        // x\n        new BigInteger(\n            \"15382583218386677486843706921635237927801862255437148328980464126979\"),\n        // p\n        new BigInteger(\n            \"181118486631420055711787706248812146965913392568235070235446058914\"\n            + \"1170708161715231951918020125044061516370042605439640379530343556\"\n            + \"4101919053459832890139496933938670005799610981765220283775567361\"\n            + \"4836626483403394052203488713085936276470766894079318754834062443\"\n            + \"1033792580942743268186462355159813630244169054658542719322425431\"\n            + \"4088256212718983105131138772434658820375111735710449331518776858\"\n            + \"7867938758654181244292694091187568128410190746310049564097068770\"\n            + \"8161261634790060655580211122402292101772553741704724263582994973\"\n            + \"9109274666495826205002104010355456981211025738812433088757102520\"\n            + \"562459649777989718122219159982614304359\"),\n        // q\n        new BigInteger(\n            \"19689526866605154788513693571065914024068069442724893395618704484701\"),\n        // g\n        new BigInteger(\n            \"2859278237642201956931085611015389087970918161297522023542900348\"\n            + \"0877180630984239764282523693409675060100542360520959501692726128\"\n            + \"3149190229583566074777557293475747419473934711587072321756053067\"\n            + \"2532404847508798651915566434553729839971841903983916294692452760\"\n            + \"2490198571084091890169933809199002313226100830607842692992570749\"\n            + \"0504363602970812128803790973955960534785317485341020833424202774\"\n            + \"0275688698461842637641566056165699733710043802697192696426360843\"\n            + \"1736206792141319514001488556117408586108219135730880594044593648\"\n            + \"9237302749293603778933701187571075920849848690861126195402696457\"\n            + \"4111219599568903257472567764789616958430\"));\n\n    static final DSAPublicKeySpec PUBLIC_KEY = new DSAPublicKeySpec(\n        new BigInteger(\n            \"3846308446317351758462473207111709291533523711306097971550086650\"\n            + \"2577333637930103311673872185522385807498738696446063139653693222\"\n            + \"3528823234976869516765207838304932337200968476150071617737755913\"\n            + \"3181601169463467065599372409821150709457431511200322947508290005\"\n            + \"1780020974429072640276810306302799924668893998032630777409440831\"\n            + \"4314588994475223696460940116068336991199969153649625334724122468\"\n            + \"7497038281983541563359385775312520539189474547346202842754393945\"\n            + \"8755803223951078082197762886933401284142487322057236814878262166\"\n            + \"5072306622943221607031324846468109901964841479558565694763440972\"\n            + \"5447389416166053148132419345627682740529\"),\n         PRIVATE_KEY.getP(),\n         PRIVATE_KEY.getQ(),\n         PRIVATE_KEY.getG());\n\n    // The following test vectors check for signature malleability and bugs. That means the test\n    // vectors are derived from a valid signature by modifying the ASN encoding. A correct\n    // implementation of DSA should only accept correct DER encoding and properly handle the others.\n    // Allowing alternative BER encodings is in many cases benign. An example where this kind of\n    // signature malleability was a problem: https://en.bitcoin.it/wiki/Transaction_Malleability\n    static final String[] MODIFIED_SIGNATURES  = {\n        \"303e02811c1e41b479ad576905b960fe14eadb91b0ccf34843dab916173bb8c9cd021d00ade65988d237d30f9e\"\n        + \"f41dd424a4e1c8f16967cf3365813fe8786236\",\n        \"303f0282001c1e41b479ad576905b960fe14eadb91b0ccf34843dab916173bb8c9cd021d00ade65988d237d30f\"\n        + \"9ef41dd424a4e1c8f16967cf3365813fe8786236\",\n        \"303e021d001e41b479ad576905b960fe14eadb91b0ccf34843dab916173bb8c9cd021d00ade65988d237d30f9e\"\n        + \"f41dd424a4e1c8f16967cf3365813fe8786236\",\n        \"303e021c1e41b479ad576905b960fe14eadb91b0ccf34843dab916173bb8c9cd02811d00ade65988d237d30f9e\"\n        + \"f41dd424a4e1c8f16967cf3365813fe8786236\",\n        \"303f021c1e41b479ad576905b960fe14eadb91b0ccf34843dab916173bb8c9cd0282001d00ade65988d237d30f\"\n        + \"9ef41dd424a4e1c8f16967cf3365813fe8786236\",\n        \"303e021c1e41b479ad576905b960fe14eadb91b0ccf34843dab916173bb8c9cd021e0000ade65988d237d30f9e\"\n        + \"f41dd424a4e1c8f16967cf3365813fe8786236\",\n        \"30813d021c1e41b479ad576905b960fe14eadb91b0ccf34843dab916173bb8c9cd021d00ade65988d237d30f9e\"\n        + \"f41dd424a4e1c8f16967cf3365813fe8786236\",\n        \"3082003d021c1e41b479ad576905b960fe14eadb91b0ccf34843dab916173bb8c9cd021d00ade65988d237d30f\"\n        + \"9ef41dd424a4e1c8f16967cf3365813fe8786236\",\n        \"303d021c1e41b479ad576905b960fe14eadb91b0ccf34843dab916173bb8c9cd021d00ade65988d237d30f9ef4\"\n        + \"1dd424a4e1c8f16967cf3365813fe87862360000\",\n        \"3040021c57b10411b54ab248af03d8f2456676ebc6d3db5f1081492ac87e9ca8021d00942b117051d7d9d107fc42cac9c5a36a1fd7f0f8916ccca86cec4ed3040100\"\n    };\n\n    private void testModified()\n        throws Exception\n    {\n        KeyFactory kFact = KeyFactory.getInstance(\"DSA\", \"BC\");\n        PublicKey pubKey = kFact.generatePublic(PUBLIC_KEY);\n        Signature sig = Signature.getInstance(\"DSA\", \"BC\");\n\n        for (int i = 0; i != MODIFIED_SIGNATURES.length; i++)\n        {\n            sig.initVerify(pubKey);\n\n            sig.update(Strings.toByteArray(\"Hello\"));\n\n            boolean failed;\n\n            try\n            {\n                failed = !sig.verify(Hex.decode(MODIFIED_SIGNATURES[i]));\n            }\n            catch (SignatureException e)\n            {\n                failed = true;\n            }\n\n            isTrue(\"sig verified when shouldn't\", failed);\n        }\n    }\n\n    private void testCompat()\n        throws Exception\n    {\n        if (Security.getProvider(\"SUN\") == null)\n        {\n            return;\n        }\n\n        Signature           s = Signature.getInstance(\"DSA\", \"SUN\");\n        KeyPairGenerator    g = KeyPairGenerator.getInstance(\"DSA\", \"SUN\");\n        byte[]              data = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 0 };\n        \n        g.initialize(512, new SecureRandom());\n        \n        KeyPair p = g.generateKeyPair();\n        \n        PrivateKey  sKey = p.getPrivate();\n        PublicKey   vKey = p.getPublic();\n        \n        //\n        // sign SUN - verify with BC \n        //\n        s.initSign(sKey);\n        \n        s.update(data);\n        \n        byte[]  sigBytes = s.sign();\n        \n        s = Signature.getInstance(\"DSA\", \"BC\");\n        \n        s.initVerify(vKey);\n        \n        s.update(data);\n        \n        if (!s.verify(sigBytes))\n        {\n            fail(\"SUN -> BC verification failed\");\n        }\n        \n        //\n        // sign BC - verify with SUN\n        //\n        \n        s.initSign(sKey);\n        \n        s.update(data);\n        \n        sigBytes = s.sign();\n        \n        s = Signature.getInstance(\"DSA\", \"SUN\");\n        \n        s.initVerify(vKey);\n        \n        s.update(data);\n        \n        if (!s.verify(sigBytes))\n        {\n            fail(\"BC -> SUN verification failed\");\n        }\n\n        //\n        // key encoding test - BC decoding Sun keys\n        //\n        KeyFactory          f = KeyFactory.getInstance(\"DSA\", \"BC\");\n        X509EncodedKeySpec  x509s = new X509EncodedKeySpec(vKey.getEncoded());\n\n        DSAPublicKey        k1 = (DSAPublicKey)f.generatePublic(x509s);\n\n        checkPublic(k1, vKey);\n        \n        PKCS8EncodedKeySpec  pkcs8 = new PKCS8EncodedKeySpec(sKey.getEncoded());\n\n        DSAPrivateKey        k2 = (DSAPrivateKey)f.generatePrivate(pkcs8);\n\n        checkPrivateKey(k2, sKey);\n        \n        //\n        // key decoding test - SUN decoding BC keys\n        // \n        f = KeyFactory.getInstance(\"DSA\", \"SUN\");\n        x509s = new X509EncodedKeySpec(k1.getEncoded());\n        \n        vKey = (DSAPublicKey)f.generatePublic(x509s);\n\n        checkPublic(k1, vKey);\n        \n        pkcs8 = new PKCS8EncodedKeySpec(k2.getEncoded());\n        sKey = f.generatePrivate(pkcs8);\n\n        checkPrivateKey(k2, sKey);\n    }\n\n    private void testNullParameters()\n        throws Exception\n    {\n        KeyFactory f = KeyFactory.getInstance(\"DSA\", \"BC\");\n        X509EncodedKeySpec x509s = new X509EncodedKeySpec(new SubjectPublicKeyInfo(new AlgorithmIdentifier(X9ObjectIdentifiers.id_dsa), new ASN1Integer(10001)).getEncoded());\n\n        DSAPublicKey key1 = (DSAPublicKey)f.generatePublic(x509s);\n        DSAPublicKey key2 = (DSAPublicKey)f.generatePublic(x509s);\n\n        isTrue(\"parameters not absent\", key1.getParams() == null && key2.getParams() == null);\n        isTrue(\"hashCode mismatch\", key1.hashCode() == key2.hashCode());\n        isTrue(\"not equal\", key1.equals(key2));\n        isTrue(\"encoding mismatch\", Arrays.areEqual(x509s.getEncoded(), key1.getEncoded()));\n    }\n\n    private void testValidate()\n        throws Exception\n    {\n        DSAParameterSpec dsaParams = new DSAParameterSpec(\n            new BigInteger(\n                        \"F56C2A7D366E3EBDEAA1891FD2A0D099\" +\n                        \"436438A673FED4D75F594959CFFEBCA7BE0FC72E4FE67D91\" +\n                        \"D801CBA0693AC4ED9E411B41D19E2FD1699C4390AD27D94C\" +\n                        \"69C0B143F1DC88932CFE2310C886412047BD9B1C7A67F8A2\" +\n                        \"5909132627F51A0C866877E672E555342BDF9355347DBD43\" +\n                        \"B47156B2C20BAD9D2B071BC2FDCF9757F75C168C5D9FC431\" +\n                        \"31BE162A0756D1BDEC2CA0EB0E3B018A8B38D3EF2487782A\" +\n                        \"EB9FBF99D8B30499C55E4F61E5C7DCEE2A2BB55BD7F75FCD\" +\n                        \"F00E48F2E8356BDB59D86114028F67B8E07B127744778AFF\" +\n                        \"1CF1399A4D679D92FDE7D941C5C85C5D7BFF91BA69F9489D\" +\n                        \"531D1EBFA727CFDA651390F8021719FA9F7216CEB177BD75\", 16),\n            new BigInteger(\"C24ED361870B61E0D367F008F99F8A1F75525889C89DB1B673C45AF5867CB467\", 16),\n            new BigInteger(\n                        \"8DC6CC814CAE4A1C05A3E186A6FE27EA\" +\n                        \"BA8CDB133FDCE14A963A92E809790CBA096EAA26140550C1\" +\n                        \"29FA2B98C16E84236AA33BF919CD6F587E048C52666576DB\" +\n                        \"6E925C6CBE9B9EC5C16020F9A44C9F1C8F7A8E611C1F6EC2\" +\n                        \"513EA6AA0B8D0F72FED73CA37DF240DB57BBB27431D61869\" +\n                        \"7B9E771B0B301D5DF05955425061A30DC6D33BB6D2A32BD0\" +\n                        \"A75A0A71D2184F506372ABF84A56AEEEA8EB693BF29A6403\" +\n                        \"45FA1298A16E85421B2208D00068A5A42915F82CF0B858C8\" +\n                        \"FA39D43D704B6927E0B2F916304E86FB6A1B487F07D8139E\" +\n                        \"428BB096C6D67A76EC0B8D4EF274B8A2CF556D279AD267CC\" +\n                        \"EF5AF477AFED029F485B5597739F5D0240F67C2D948A6279\", 16)\n        );\n\n        KeyFactory f = KeyFactory.getInstance(\"DSA\", \"BC\");\n\n        try\n        {\n            f.generatePublic(new DSAPublicKeySpec(BigInteger.valueOf(1), dsaParams.getP(), dsaParams.getG(), dsaParams.getQ()));\n\n            fail(\"no exception\");\n        }\n        catch (Exception e)\n        {\n            isTrue(\"mismatch\", \"invalid KeySpec: y value does not appear to be in correct group\".equals(e.getMessage()));\n        }\n    }\n\n    private void testNONEwithDSA()\n        throws Exception\n    {\n        byte[] dummySha1 = Hex.decode(\"01020304050607080910111213141516\");\n\n        KeyPairGenerator kpGen = KeyPairGenerator.getInstance(\"DSA\", \"BC\");\n\n        kpGen.initialize(512);\n\n        KeyPair          kp = kpGen.generateKeyPair();\n\n        Signature        sig = Signature.getInstance(\"NONEwithDSA\", \"BC\");\n\n        sig.initSign(kp.getPrivate());\n\n        sig.update(dummySha1);\n\n        byte[] sigBytes = sig.sign();\n\n        sig.initVerify(kp.getPublic());\n\n        sig.update(dummySha1);\n\n        sig.verify(sigBytes);\n\n        // reset test\n\n        sig.update(dummySha1);\n\n        if (!sig.verify(sigBytes))\n        {\n            fail(\"NONEwithDSA failed to reset\");\n        }\n\n        // lightweight test\n        DSAPublicKey  key = (DSAPublicKey)kp.getPublic();\n        DSAParameters params = new DSAParameters(key.getParams().getP(), key.getParams().getQ(), key.getParams().getG());\n        DSAPublicKeyParameters keyParams = new DSAPublicKeyParameters(key.getY(), params);\n        DSASigner signer = new DSASigner();\n        ASN1Sequence derSig = ASN1Sequence.getInstance(ASN1Primitive.fromByteArray(sigBytes));\n\n        signer.init(false, keyParams);\n\n        if (!signer.verifySignature(dummySha1, ASN1Integer.getInstance(derSig.getObjectAt(0)).getValue(), ASN1Integer.getInstance(derSig.getObjectAt(1)).getValue()))\n        {\n            fail(\"NONEwithDSA not really NONE!\");\n        }\n    }\n\n    private void checkPublic(DSAPublicKey k1, PublicKey vKey)\n    {\n        if (!k1.getY().equals(((DSAPublicKey)vKey).getY()))\n        {\n            fail(\"public number not decoded properly\");\n        }\n\n        if (!k1.getParams().getG().equals(((DSAPublicKey)vKey).getParams().getG()))\n        {\n            fail(\"public generator not decoded properly\");\n        }\n\n        if (!k1.getParams().getP().equals(((DSAPublicKey)vKey).getParams().getP()))\n        {\n            fail(\"public p value not decoded properly\");\n        }\n\n        if (!k1.getParams().getQ().equals(((DSAPublicKey)vKey).getParams().getQ()))\n        {\n            fail(\"public q value not decoded properly\");\n        }\n    }\n\n    private void checkPrivateKey(DSAPrivateKey k2, PrivateKey sKey)\n    {\n        if (!k2.getX().equals(((DSAPrivateKey)sKey).getX()))\n        {\n            fail(\"private number not decoded properly\");\n        }\n\n        if (!k2.getParams().getG().equals(((DSAPrivateKey)sKey).getParams().getG()))\n        {\n            fail(\"private generator not decoded properly\");\n        }\n\n        if (!k2.getParams().getP().equals(((DSAPrivateKey)sKey).getParams().getP()))\n        {\n            fail(\"private p value not decoded properly\");\n        }\n\n        if (!k2.getParams().getQ().equals(((DSAPrivateKey)sKey).getParams().getQ()))\n        {\n            fail(\"private q value not decoded properly\");\n        }\n    }\n\n    private Object serializeDeserialize(Object o)\n        throws Exception\n    {\n        ByteArrayOutputStream bOut = new ByteArrayOutputStream();\n        ObjectOutputStream oOut = new ObjectOutputStream(bOut);\n\n        oOut.writeObject(o);\n        oOut.close();\n\n        ObjectInputStream oIn = new ObjectInputStream(new ByteArrayInputStream(bOut.toByteArray()));\n\n        return oIn.readObject();\n    }\n\n    /**\n     * X9.62 - 1998,<br>\n     * J.3.2, Page 155, ECDSA over the field Fp<br>\n     * an example with 239 bit prime\n     */\n    private void testECDSA239bitPrime()\n        throws Exception\n    {\n        BigInteger r = new BigInteger(\"308636143175167811492622547300668018854959378758531778147462058306432176\");\n        BigInteger s = new BigInteger(\"323813553209797357708078776831250505931891051755007842781978505179448783\");\n\n        byte[] kData = BigIntegers.asUnsignedByteArray(new BigInteger(\"700000017569056646655505781757157107570501575775705779575555657156756655\"));\n\n        SecureRandom    k = new TestRandomBigInteger(kData);\n\n        ECCurve curve = new ECCurve.Fp(\n                new BigInteger(\"883423532389192164791648750360308885314476597252960362792450860609699839\"), // q\n                new BigInteger(\"7fffffffffffffffffffffff7fffffffffff8000000000007ffffffffffc\", 16), // a\n                new BigInteger(\"6b016c3bdcf18941d0d654921475ca71a9db2fb27d1d37796185c2942c0a\", 16)); // b\n        \n        ECParameterSpec spec = new ECParameterSpec(\n                curve,\n                curve.decodePoint(Hex.decode(\"020ffa963cdca8816ccc33b8642bedf905c3d358573d3f27fbbd3b3cb9aaaf\")), // G\n                new BigInteger(\"883423532389192164791648750360308884807550341691627752275345424702807307\")); // n\n        \n        \n        ECPrivateKeySpec priKey = new ECPrivateKeySpec(\n                new BigInteger(\"876300101507107567501066130761671078357010671067781776716671676178726717\"), // d\n                spec);\n        \n        ECPublicKeySpec pubKey = new ECPublicKeySpec(\n                curve.decodePoint(Hex.decode(\"025b6dc53bc61a2548ffb0f671472de6c9521a9d2d2534e65abfcbd5fe0c70\")), // Q\n                spec);\n        \n        Signature           sgr = Signature.getInstance(\"ECDSA\", \"BC\");\n        KeyFactory          f = KeyFactory.getInstance(\"ECDSA\", \"BC\");\n        PrivateKey          sKey = f.generatePrivate(priKey);\n        PublicKey           vKey = f.generatePublic(pubKey);\n        \n        sgr.initSign(sKey, k);\n        \n        byte[] message = new byte[] { (byte)'a', (byte)'b', (byte)'c' };\n        \n        sgr.update(message);\n        \n        byte[]  sigBytes = sgr.sign();\n        \n        sgr.initVerify(vKey);\n        \n        sgr.update(message);\n        \n        if (!sgr.verify(sigBytes))\n        {\n            fail(\"239 Bit EC verification failed\");\n        }\n        \n        BigInteger[]  sig = derDecode(sigBytes);\n        \n        if (!r.equals(sig[0]))\n        {\n            fail(\"r component wrong.\" + Strings.lineSeparator()\n                    + \" expecting: \" + r + Strings.lineSeparator()\n                    + \" got      : \" + sig[0]);\n        }\n        \n        if (!s.equals(sig[1]))\n        {\n            fail(\"s component wrong.\" + Strings.lineSeparator()\n                    + \" expecting: \" + s + Strings.lineSeparator()\n                    + \" got      : \" + sig[1]);\n        }\n    }\n\n    private void testNONEwithECDSA239bitPrime()\n        throws Exception\n    {\n        ECCurve curve = new ECCurve.Fp(\n                new BigInteger(\"883423532389192164791648750360308885314476597252960362792450860609699839\"), // q\n                new BigInteger(\"7fffffffffffffffffffffff7fffffffffff8000000000007ffffffffffc\", 16), // a\n                new BigInteger(\"6b016c3bdcf18941d0d654921475ca71a9db2fb27d1d37796185c2942c0a\", 16)); // b\n\n        ECParameterSpec spec = new ECParameterSpec(\n                curve,\n                curve.decodePoint(Hex.decode(\"020ffa963cdca8816ccc33b8642bedf905c3d358573d3f27fbbd3b3cb9aaaf\")), // G\n                new BigInteger(\"883423532389192164791648750360308884807550341691627752275345424702807307\")); // n\n\n\n        ECPrivateKeySpec priKey = new ECPrivateKeySpec(\n                new BigInteger(\"876300101507107567501066130761671078357010671067781776716671676178726717\"), // d\n                spec);\n\n        ECPublicKeySpec pubKey = new ECPublicKeySpec(\n                curve.decodePoint(Hex.decode(\"025b6dc53bc61a2548ffb0f671472de6c9521a9d2d2534e65abfcbd5fe0c70\")), // Q\n                spec);\n\n        Signature           sgr = Signature.getInstance(\"NONEwithECDSA\", \"BC\");\n        KeyFactory          f = KeyFactory.getInstance(\"ECDSA\", \"BC\");\n        PrivateKey          sKey = f.generatePrivate(priKey);\n        PublicKey           vKey = f.generatePublic(pubKey);\n\n        byte[] message = \"abc\".getBytes();\n        byte[] sig = Hex.decode(\"3040021e2cb7f36803ebb9c427c58d8265f11fc5084747133078fc279de874fbecb0021e64cb19604be06c57e761b3de5518f71de0f6e0cd2df677cec8a6ffcb690d\");\n\n        checkMessage(sgr, sKey, vKey, message, sig);\n\n        message = \"abcdefghijklmnopqrstuvwxyz\".getBytes();\n        sig = Hex.decode(\"3040021e2cb7f36803ebb9c427c58d8265f11fc5084747133078fc279de874fbecb0021e43fd65b3363d76aabef8630572257dbb67c82818ad9fad31256539b1b02c\");\n\n        checkMessage(sgr, sKey, vKey, message, sig);\n\n        message = \"a very very long message gauranteed to cause an overflow\".getBytes();\n        sig = Hex.decode(\"3040021e2cb7f36803ebb9c427c58d8265f11fc5084747133078fc279de874fbecb0021e7d5be84b22937a1691859a3c6fe45ed30b108574431d01b34025825ec17a\");\n\n        checkMessage(sgr, sKey, vKey, message, sig);\n    }\n\n    private void testECDSAP256sha3(ASN1ObjectIdentifier sigOid, int size, BigInteger s)\n        throws Exception\n    {\n        X9ECParameters p = NISTNamedCurves.getByName(\"P-256\");\n        KeyFactory ecKeyFact = KeyFactory.getInstance(\"EC\", \"BC\");\n\n        ECDomainParameters params = new ECDomainParameters(p.getCurve(), p.getG(), p.getN(), p.getH());\n\n        ECCurve curve = p.getCurve();\n\n        ECParameterSpec spec = new ECParameterSpec(\n                curve,\n                p.getG(), // G\n                p.getN()); // n\n\n        ECPrivateKeySpec priKey = new ECPrivateKeySpec(\n                new BigInteger(\"20186677036482506117540275567393538695075300175221296989956723148347484984008\"), // d\n                spec);\n\n        ECPublicKeySpec pubKey = new ECPublicKeySpec(\n            params.getCurve().decodePoint(Hex.decode(\"03596375E6CE57E0F20294FC46BDFCFD19A39F8161B58695B3EC5B3D16427C274D\")), // Q\n            spec);\n\n        doEcDsaTest(\"SHA3-\" + size + \"withECDSA\", s, ecKeyFact, pubKey, priKey);\n        doEcDsaTest(sigOid.getId(), s, ecKeyFact, pubKey, priKey);\n    }\n\n    private void doEcDsaTest(String sigName, BigInteger s, KeyFactory ecKeyFact, ECPublicKeySpec pubKey, ECPrivateKeySpec priKey)\n        throws NoSuchAlgorithmException, NoSuchProviderException, InvalidKeyException, InvalidKeySpecException, SignatureException\n    {\n        SecureRandom k = new TestRandomBigInteger(BigIntegers.asUnsignedByteArray(new BigInteger(\"72546832179840998877302529996971396893172522460793442785601695562409154906335\")));\n\n        byte[] M = Hex.decode(\"1BD4ED430B0F384B4E8D458EFF1A8A553286D7AC21CB2F6806172EF5F94A06AD\");\n\n        Signature dsa = Signature.getInstance(sigName, \"BC\");\n\n        dsa.initSign(ecKeyFact.generatePrivate(priKey), k);\n\n        dsa.update(M, 0, M.length);\n\n        byte[] encSig = dsa.sign();\n\n        ASN1Sequence sig = ASN1Sequence.getInstance(encSig);\n\n        BigInteger r = new BigInteger(\"97354732615802252173078420023658453040116611318111190383344590814578738210384\");\n\n        BigInteger sigR = ASN1Integer.getInstance(sig.getObjectAt(0)).getValue();\n        if (!r.equals(sigR))\n        {\n            fail(\"r component wrong.\" + Strings.lineSeparator()\n                + \" expecting: \" + r.toString(16) + Strings.lineSeparator()\n                + \" got      : \" + sigR.toString(16));\n        }\n\n        BigInteger sigS = ASN1Integer.getInstance(sig.getObjectAt(1)).getValue();\n        if (!s.equals(sigS))\n        {\n            fail(\"s component wrong.\" + Strings.lineSeparator()\n                + \" expecting: \" + s.toString(16) + Strings.lineSeparator()\n                + \" got      : \" + sigS.toString(16));\n        }\n\n        // Verify the signature\n        dsa.initVerify(ecKeyFact.generatePublic(pubKey));\n\n        dsa.update(M, 0, M.length);\n\n        if (!dsa.verify(encSig))\n        {\n            fail(\"signature fails\");\n        }\n    }\n\n    private void testDSAsha3(ASN1ObjectIdentifier sigOid, int size, BigInteger s)\n        throws Exception\n    {\n        DSAParameterSpec dsaParams = new DSAParameterSpec(\n            new BigInteger(\n                        \"F56C2A7D366E3EBDEAA1891FD2A0D099\" +\n                        \"436438A673FED4D75F594959CFFEBCA7BE0FC72E4FE67D91\" +\n                        \"D801CBA0693AC4ED9E411B41D19E2FD1699C4390AD27D94C\" +\n                        \"69C0B143F1DC88932CFE2310C886412047BD9B1C7A67F8A2\" +\n                        \"5909132627F51A0C866877E672E555342BDF9355347DBD43\" +\n                        \"B47156B2C20BAD9D2B071BC2FDCF9757F75C168C5D9FC431\" +\n                        \"31BE162A0756D1BDEC2CA0EB0E3B018A8B38D3EF2487782A\" +\n                        \"EB9FBF99D8B30499C55E4F61E5C7DCEE2A2BB55BD7F75FCD\" +\n                        \"F00E48F2E8356BDB59D86114028F67B8E07B127744778AFF\" +\n                        \"1CF1399A4D679D92FDE7D941C5C85C5D7BFF91BA69F9489D\" +\n                        \"531D1EBFA727CFDA651390F8021719FA9F7216CEB177BD75\", 16),\n            new BigInteger(\"C24ED361870B61E0D367F008F99F8A1F75525889C89DB1B673C45AF5867CB467\", 16),\n            new BigInteger(\n                        \"8DC6CC814CAE4A1C05A3E186A6FE27EA\" +\n                        \"BA8CDB133FDCE14A963A92E809790CBA096EAA26140550C1\" +\n                        \"29FA2B98C16E84236AA33BF919CD6F587E048C52666576DB\" +\n                        \"6E925C6CBE9B9EC5C16020F9A44C9F1C8F7A8E611C1F6EC2\" +\n                        \"513EA6AA0B8D0F72FED73CA37DF240DB57BBB27431D61869\" +\n                        \"7B9E771B0B301D5DF05955425061A30DC6D33BB6D2A32BD0\" +\n                        \"A75A0A71D2184F506372ABF84A56AEEEA8EB693BF29A6403\" +\n                        \"45FA1298A16E85421B2208D00068A5A42915F82CF0B858C8\" +\n                        \"FA39D43D704B6927E0B2F916304E86FB6A1B487F07D8139E\" +\n                        \"428BB096C6D67A76EC0B8D4EF274B8A2CF556D279AD267CC\" +\n                        \"EF5AF477AFED029F485B5597739F5D0240F67C2D948A6279\", 16)\n        );\n\n        BigInteger x = new BigInteger(\"0CAF2EF547EC49C4F3A6FE6DF4223A174D01F2C115D49A6F73437C29A2A8458C\", 16);\n\n        BigInteger y = new BigInteger(\n                    \"2828003D7C747199143C370FDD07A286\" +\n                    \"1524514ACC57F63F80C38C2087C6B795B62DE1C224BF8D1D\" +\n                    \"1424E60CE3F5AE3F76C754A2464AF292286D873A7A30B7EA\" +\n                    \"CBBC75AAFDE7191D9157598CDB0B60E0C5AA3F6EBE425500\" +\n                    \"C611957DBF5ED35490714A42811FDCDEB19AF2AB30BEADFF\" +\n                    \"2907931CEE7F3B55532CFFAEB371F84F01347630EB227A41\" +\n                    \"9B1F3F558BC8A509D64A765D8987D493B007C4412C297CAF\" +\n                    \"41566E26FAEE475137EC781A0DC088A26C8804A98C23140E\" +\n                    \"7C936281864B99571EE95C416AA38CEEBB41FDBFF1EB1D1D\" +\n                    \"C97B63CE1355257627C8B0FD840DDB20ED35BE92F08C49AE\" +\n                    \"A5613957D7E5C7A6D5A5834B4CB069E0831753ECF65BA02B\", 16);\n\n        DSAPrivateKeySpec priKey = new DSAPrivateKeySpec(\n                x, dsaParams.getP(), dsaParams.getQ(), dsaParams.getG());\n\n        DSAPublicKeySpec pubKey = new DSAPublicKeySpec(\n            y, dsaParams.getP(), dsaParams.getQ(), dsaParams.getG());\n\n        KeyFactory dsaKeyFact = KeyFactory.getInstance(\"DSA\", \"BC\");\n\n        doDsaTest(\"SHA3-\" + size + \"withDSA\", s, dsaKeyFact, pubKey, priKey);\n        doDsaTest(sigOid.getId(), s, dsaKeyFact, pubKey, priKey);\n    }\n\n    private void doDsaTest(String sigName, BigInteger s, KeyFactory ecKeyFact, DSAPublicKeySpec pubKey, DSAPrivateKeySpec priKey)\n        throws NoSuchAlgorithmException, NoSuchProviderException, InvalidKeyException, InvalidKeySpecException, SignatureException\n    {\n        SecureRandom k = new TestRandomBigInteger(BigIntegers.asUnsignedByteArray(new BigInteger(\"72546832179840998877302529996971396893172522460793442785601695562409154906335\")));\n\n        byte[] M = Hex.decode(\"1BD4ED430B0F384B4E8D458EFF1A8A553286D7AC21CB2F6806172EF5F94A06AD\");\n\n        Signature dsa = Signature.getInstance(sigName, \"BC\");\n\n        dsa.initSign(ecKeyFact.generatePrivate(priKey), k);\n\n        dsa.update(M, 0, M.length);\n\n        byte[] encSig = dsa.sign();\n\n        ASN1Sequence sig = ASN1Sequence.getInstance(encSig);\n\n        BigInteger r = new BigInteger(\"4864074fe30e6601268ee663440e4d9b703f62673419864e91e9edb0338ce510\", 16);\n\n        BigInteger sigR = ASN1Integer.getInstance(sig.getObjectAt(0)).getValue();\n        if (!r.equals(sigR))\n        {\n            fail(\"r component wrong.\" + Strings.lineSeparator()\n                + \" expecting: \" + r.toString(16) + Strings.lineSeparator()\n                + \" got      : \" + sigR.toString(16));\n        }\n\n        BigInteger sigS = ASN1Integer.getInstance(sig.getObjectAt(1)).getValue();\n        if (!s.equals(sigS))\n        {\n            fail(\"s component wrong.\" + Strings.lineSeparator()\n                + \" expecting: \" + s.toString(16) + Strings.lineSeparator()\n                + \" got      : \" + sigS.toString(16));\n        }\n\n        // Verify the signature\n        dsa.initVerify(ecKeyFact.generatePublic(pubKey));\n\n        dsa.update(M, 0, M.length);\n\n        if (!dsa.verify(encSig))\n        {\n            fail(\"signature fails\");\n        }\n    }\n\n    private void checkMessage(Signature sgr, PrivateKey sKey, PublicKey vKey, byte[] message, byte[] sig)\n        throws InvalidKeyException, SignatureException\n    {\n        byte[] kData = BigIntegers.asUnsignedByteArray(new BigInteger(\"700000017569056646655505781757157107570501575775705779575555657156756655\"));\n\n        SecureRandom    k = new TestRandomBigInteger(kData);\n\n        sgr.initSign(sKey, k);\n\n        sgr.update(message);\n\n        byte[]  sigBytes = sgr.sign();\n\n        if (!Arrays.areEqual(sigBytes, sig))\n        {\n            fail(new String(message) + \" signature incorrect\");\n        }\n\n        sgr.initVerify(vKey);\n\n        sgr.update(message);\n\n        if (!sgr.verify(sigBytes))\n        {\n            fail(new String(message) + \" verification failed\");\n        }\n    }\n\n    /**\n     * X9.62 - 1998,<br>\n     * J.2.1, Page 100, ECDSA over the field F2m<br>\n     * an example with 191 bit binary field\n     */\n    private void testECDSA239bitBinary()\n        throws Exception\n    {\n        BigInteger r = new BigInteger(\"21596333210419611985018340039034612628818151486841789642455876922391552\");\n        BigInteger s = new BigInteger(\"197030374000731686738334997654997227052849804072198819102649413465737174\");\n    \n        byte[] kData = BigIntegers.asUnsignedByteArray(new BigInteger(\"171278725565216523967285789236956265265265235675811949404040041670216363\"));\n\n        SecureRandom    k = new TestRandomBigInteger(kData);\n\n        ECCurve curve = new ECCurve.F2m(\n            239, // m\n            36, // k\n            new BigInteger(\"32010857077C5431123A46B808906756F543423E8D27877578125778AC76\", 16), // a\n            new BigInteger(\"790408F2EEDAF392B012EDEFB3392F30F4327C0CA3F31FC383C422AA8C16\", 16)); // b\n    \n        ECParameterSpec params = new ECParameterSpec(\n            curve,\n            curve.decodePoint(Hex.decode(\"0457927098FA932E7C0A96D3FD5B706EF7E5F5C156E16B7E7C86038552E91D61D8EE5077C33FECF6F1A16B268DE469C3C7744EA9A971649FC7A9616305\")), // G\n            new BigInteger(\"220855883097298041197912187592864814557886993776713230936715041207411783\"), // n\n            BigInteger.valueOf(4)); // h\n    \n        ECPrivateKeySpec priKeySpec = new ECPrivateKeySpec(\n            new BigInteger(\"145642755521911534651321230007534120304391871461646461466464667494947990\"), // d\n            params);\n        \n        ECPublicKeySpec pubKeySpec = new ECPublicKeySpec(\n            curve.decodePoint(Hex.decode(\"045894609CCECF9A92533F630DE713A958E96C97CCB8F5ABB5A688A238DEED6DC2D9D0C94EBFB7D526BA6A61764175B99CB6011E2047F9F067293F57F5\")), // Q\n            params);\n    \n        Signature   sgr = Signature.getInstance(\"ECDSA\", \"BC\");\n        KeyFactory  f = KeyFactory.getInstance(\"ECDSA\", \"BC\");\n        PrivateKey  sKey = f.generatePrivate(priKeySpec);\n        PublicKey   vKey = f.generatePublic(pubKeySpec);\n        byte[]      message = new byte[] { (byte)'a', (byte)'b', (byte)'c' };\n       \n        sgr.initSign(sKey, k);\n\n        sgr.update(message);\n        \n        byte[]  sigBytes = sgr.sign();\n\n        sgr.initVerify(vKey);\n\n        sgr.update(message);\n\n        if (!sgr.verify(sigBytes))\n        {\n            fail(\"239 Bit EC verification failed\");\n        }\n\n        BigInteger[]  sig = derDecode(sigBytes);\n\n        if (!r.equals(sig[0]))\n        {\n            fail(\"r component wrong.\" + Strings.lineSeparator()\n                + \" expecting: \" + r + Strings.lineSeparator()\n                + \" got      : \" + sig[0]);\n        }\n\n        if (!s.equals(sig[1]))\n        {\n            fail(\"s component wrong.\" + Strings.lineSeparator()\n                + \" expecting: \" + s + Strings.lineSeparator()\n                + \" got      : \" + sig[1]);\n        }\n    }\n\n    private void testECDSA239bitBinary(String algorithm, ASN1ObjectIdentifier oid)\n        throws Exception\n    {\n        byte[] kData = BigIntegers.asUnsignedByteArray(new BigInteger(\"171278725565216523967285789236956265265265235675811949404040041670216363\"));\n\n        SecureRandom    k = new TestRandomBigInteger(kData);\n\n        ECCurve curve = new ECCurve.F2m(\n            239, // m\n            36, // k\n            new BigInteger(\"32010857077C5431123A46B808906756F543423E8D27877578125778AC76\", 16), // a\n            new BigInteger(\"790408F2EEDAF392B012EDEFB3392F30F4327C0CA3F31FC383C422AA8C16\", 16)); // b\n\n        ECParameterSpec params = new ECParameterSpec(\n            curve,\n            curve.decodePoint(Hex.decode(\"0457927098FA932E7C0A96D3FD5B706EF7E5F5C156E16B7E7C86038552E91D61D8EE5077C33FECF6F1A16B268DE469C3C7744EA9A971649FC7A9616305\")), // G\n            new BigInteger(\"220855883097298041197912187592864814557886993776713230936715041207411783\"), // n\n            BigInteger.valueOf(4)); // h\n\n        ECPrivateKeySpec priKeySpec = new ECPrivateKeySpec(\n            new BigInteger(\"145642755521911534651321230007534120304391871461646461466464667494947990\"), // d\n            params);\n\n        ECPublicKeySpec pubKeySpec = new ECPublicKeySpec(\n            curve.decodePoint(Hex.decode(\"045894609CCECF9A92533F630DE713A958E96C97CCB8F5ABB5A688A238DEED6DC2D9D0C94EBFB7D526BA6A61764175B99CB6011E2047F9F067293F57F5\")), // Q\n            params);\n\n        Signature   sgr = Signature.getInstance(algorithm, \"BC\");\n        KeyFactory  f = KeyFactory.getInstance(\"ECDSA\", \"BC\");\n        PrivateKey  sKey = f.generatePrivate(priKeySpec);\n        PublicKey   vKey = f.generatePublic(pubKeySpec);\n        byte[]      message = new byte[] { (byte)'a', (byte)'b', (byte)'c' };\n\n        sgr.initSign(sKey, k);\n\n        sgr.update(message);\n\n        byte[]  sigBytes = sgr.sign();\n\n        sgr = Signature.getInstance(oid.getId(), \"BC\");\n\n        sgr.initVerify(vKey);\n\n        sgr.update(message);\n\n        if (!sgr.verify(sigBytes))\n        {\n            fail(\"239 Bit EC RIPEMD160 verification failed\");\n        }\n    }\n\n    private void testGeneration()\n        throws Exception\n    {\n        Signature           s = Signature.getInstance(\"DSA\", \"BC\");\n        KeyPairGenerator    g = KeyPairGenerator.getInstance(\"DSA\", \"BC\");\n        byte[]              data = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 0 };\n\n\n        // test exception\n        //\n        try\n        {\n            g.initialize(513, new SecureRandom());\n\n            fail(\"illegal parameter 513 check failed.\");\n        }\n        catch (IllegalArgumentException e)\n        {\n            // expected\n        }\n\n        try\n        {\n            g.initialize(510, new SecureRandom());\n\n            fail(\"illegal parameter 510 check failed.\");\n        }\n        catch (IllegalArgumentException e)\n        {\n            // expected\n        }\n\n        try\n        {\n            g.initialize(1025, new SecureRandom());\n\n            fail(\"illegal parameter 1025 check failed.\");\n        }\n        catch (IllegalArgumentException e)\n        {\n            // expected\n        }\n\n        g.initialize(512, new SecureRandom());\n\n        KeyPair p = g.generateKeyPair();\n\n        PrivateKey  sKey = p.getPrivate();\n        PublicKey   vKey = p.getPublic();\n\n        s.initSign(sKey);\n\n        s.update(data);\n\n        byte[]  sigBytes = s.sign();\n\n        s = Signature.getInstance(\"DSA\", \"BC\");\n\n        s.initVerify(vKey);\n\n        s.update(data);\n\n        if (!s.verify(sigBytes))\n        {\n            fail(\"DSA verification failed\");\n        }\n\n        //\n        // key decoding test - serialisation test\n        //\n\n        DSAPublicKey k1 = (DSAPublicKey)serializeDeserialize(vKey);\n\n        checkPublic(k1, vKey);\n\n        checkEquals(k1, vKey);\n\n        DSAPrivateKey k2 = (DSAPrivateKey)serializeDeserialize(sKey);\n\n        checkPrivateKey(k2, sKey);\n\n        checkEquals(k2, sKey);\n\n        if (!(k2 instanceof PKCS12BagAttributeCarrier))\n        {\n            fail(\"private key not implementing PKCS12 attribute carrier\");\n        }\n\n        //\n        // ECDSA Fp generation test\n        //\n        s = Signature.getInstance(\"ECDSA\", \"BC\");\n        g = KeyPairGenerator.getInstance(\"ECDSA\", \"BC\");\n\n        ECCurve curve = new ECCurve.Fp(\n            new BigInteger(\"883423532389192164791648750360308885314476597252960362792450860609699839\"), // q\n            new BigInteger(\"7fffffffffffffffffffffff7fffffffffff8000000000007ffffffffffc\", 16), // a\n            new BigInteger(\"6b016c3bdcf18941d0d654921475ca71a9db2fb27d1d37796185c2942c0a\", 16)); // b\n\n        ECParameterSpec ecSpec = new ECParameterSpec(\n            curve,\n            curve.decodePoint(Hex.decode(\"020ffa963cdca8816ccc33b8642bedf905c3d358573d3f27fbbd3b3cb9aaaf\")), // G\n            new BigInteger(\"883423532389192164791648750360308884807550341691627752275345424702807307\")); // n\n\n        g.initialize(ecSpec, new SecureRandom());\n\n        p = g.generateKeyPair();\n\n        sKey = p.getPrivate();\n        vKey = p.getPublic();\n\n        s.initSign(sKey);\n\n        s.update(data);\n\n        sigBytes = s.sign();\n\n        s = Signature.getInstance(\"ECDSA\", \"BC\");\n\n        s.initVerify(vKey);\n\n        s.update(data);\n\n        if (!s.verify(sigBytes))\n        {\n            fail(\"ECDSA verification failed\");\n        }\n\n        //\n        // key decoding test - serialisation test\n        //\n\n        PublicKey eck1 = (PublicKey)serializeDeserialize(vKey);\n\n        checkEquals(eck1, vKey);\n\n        PrivateKey eck2 = (PrivateKey)serializeDeserialize(sKey);\n\n        checkEquals(eck2, sKey);\n\n        // Named curve parameter\n        g.initialize(new ECNamedCurveGenParameterSpec(\"P-256\"), new SecureRandom());\n\n        p = g.generateKeyPair();\n\n        sKey = p.getPrivate();\n        vKey = p.getPublic();\n\n        s.initSign(sKey);\n\n        s.update(data);\n\n        sigBytes = s.sign();\n\n        s = Signature.getInstance(\"ECDSA\", \"BC\");\n\n        s.initVerify(vKey);\n\n        s.update(data);\n\n        if (!s.verify(sigBytes))\n        {\n            fail(\"ECDSA verification failed\");\n        }\n\n        //\n        // key decoding test - serialisation test\n        //\n\n        eck1 = (PublicKey)serializeDeserialize(vKey);\n\n        checkEquals(eck1, vKey);\n\n        eck2 = (PrivateKey)serializeDeserialize(sKey);\n\n        checkEquals(eck2, sKey);\n\n        //\n        // ECDSA F2m generation test\n        //\n        s = Signature.getInstance(\"ECDSA\", \"BC\");\n        g = KeyPairGenerator.getInstance(\"ECDSA\", \"BC\");\n\n        curve = new ECCurve.F2m(\n                239, // m\n                36, // k\n                new BigInteger(\"32010857077C5431123A46B808906756F543423E8D27877578125778AC76\", 16), // a\n                new BigInteger(\"790408F2EEDAF392B012EDEFB3392F30F4327C0CA3F31FC383C422AA8C16\", 16)); // b\n        \n        ecSpec = new ECParameterSpec(\n            curve,\n            curve.decodePoint(Hex.decode(\"0457927098FA932E7C0A96D3FD5B706EF7E5F5C156E16B7E7C86038552E91D61D8EE5077C33FECF6F1A16B268DE469C3C7744EA9A971649FC7A9616305\")), // G\n            new BigInteger(\"220855883097298041197912187592864814557886993776713230936715041207411783\"), // n\n            BigInteger.valueOf(4)); // h\n        \n        g.initialize(ecSpec, new SecureRandom());\n\n        p = g.generateKeyPair();\n\n        sKey = p.getPrivate();\n        vKey = p.getPublic();\n\n        s.initSign(sKey);\n\n        s.update(data);\n\n        sigBytes = s.sign();\n\n        s = Signature.getInstance(\"ECDSA\", \"BC\");\n\n        s.initVerify(vKey);\n\n        s.update(data);\n\n        if (!s.verify(sigBytes))\n        {\n            fail(\"ECDSA verification failed\");\n        }\n\n        //\n        // key decoding test - serialisation test\n        //\n\n        eck1 = (PublicKey)serializeDeserialize(vKey);\n\n        checkEquals(eck1, vKey);\n\n        eck2 = (PrivateKey)serializeDeserialize(sKey);\n\n        checkEquals(eck2, sKey);\n\n        if (!(eck2 instanceof PKCS12BagAttributeCarrier))\n        {\n            fail(\"private key not implementing PKCS12 attribute carrier\");\n        }\n    }\n\n    private void checkEquals(Object o1, Object o2)\n    {\n        if (!o1.equals(o2))\n        {\n            fail(\"comparison test failed\");\n        }\n\n        if (o1.hashCode() != o2.hashCode())\n        {\n            fail(\"hashCode test failed\");\n        }\n    }\n    \n    private void testParameters()\n        throws Exception\n    {\n        AlgorithmParameterGenerator a = AlgorithmParameterGenerator.getInstance(\"DSA\", \"BC\");\n        a.init(512, random);\n        AlgorithmParameters params = a.generateParameters();\n        \n        byte[] encodeParams = params.getEncoded();\n        \n        AlgorithmParameters a2 = AlgorithmParameters.getInstance(\"DSA\", \"BC\");\n        a2.init(encodeParams);\n        \n        // a and a2 should be equivalent!\n        byte[] encodeParams_2 = a2.getEncoded();\n        \n        if (!areEqual(encodeParams, encodeParams_2))\n        {\n            fail(\"encode/decode parameters failed\");\n        }\n        \n        DSAParameterSpec dsaP = (DSAParameterSpec)params.getParameterSpec(DSAParameterSpec.class);\n        \n        KeyPairGenerator    g = KeyPairGenerator.getInstance(\"DSA\", \"BC\");\n        g.initialize(dsaP, new SecureRandom());\n        KeyPair p = g.generateKeyPair();\n        \n        PrivateKey  sKey = p.getPrivate();\n        PublicKey   vKey = p.getPublic();\n        \n        Signature           s = Signature.getInstance(\"DSA\", \"BC\");\n        byte[]              data = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 0 };\n        \n        s.initSign(sKey);\n        \n        s.update(data);\n        \n        byte[]  sigBytes = s.sign();\n        \n        s = Signature.getInstance(\"DSA\", \"BC\");\n        \n        s.initVerify(vKey);\n        \n        s.update(data);\n        \n        if (!s.verify(sigBytes))\n        {\n            fail(\"DSA verification failed\");\n        }\n    }\n\n    private void testDSA2Parameters()\n        throws Exception\n    {\n        byte[] seed = Hex.decode(\"4783081972865EA95D43318AB2EAF9C61A2FC7BBF1B772A09017BDF5A58F4FF0\");\n\n        AlgorithmParameterGenerator a = AlgorithmParameterGenerator.getInstance(\"DSA\", \"BC\");\n        a.init(2048, new DSATestSecureRandom(seed));\n        AlgorithmParameters params = a.generateParameters();\n\n        DSAParameterSpec dsaP = (DSAParameterSpec)params.getParameterSpec(DSAParameterSpec.class);\n\n        if (!dsaP.getQ().equals(new BigInteger(\"C24ED361870B61E0D367F008F99F8A1F75525889C89DB1B673C45AF5867CB467\", 16)))\n        {\n            fail(\"Q incorrect\");\n        }\n\n        if (!dsaP.getP().equals(new BigInteger(\n            \"F56C2A7D366E3EBDEAA1891FD2A0D099\" +\n            \"436438A673FED4D75F594959CFFEBCA7BE0FC72E4FE67D91\" +\n            \"D801CBA0693AC4ED9E411B41D19E2FD1699C4390AD27D94C\" +\n            \"69C0B143F1DC88932CFE2310C886412047BD9B1C7A67F8A2\" +\n            \"5909132627F51A0C866877E672E555342BDF9355347DBD43\" +\n            \"B47156B2C20BAD9D2B071BC2FDCF9757F75C168C5D9FC431\" +\n            \"31BE162A0756D1BDEC2CA0EB0E3B018A8B38D3EF2487782A\" +\n            \"EB9FBF99D8B30499C55E4F61E5C7DCEE2A2BB55BD7F75FCD\" +\n            \"F00E48F2E8356BDB59D86114028F67B8E07B127744778AFF\" +\n            \"1CF1399A4D679D92FDE7D941C5C85C5D7BFF91BA69F9489D\" +\n            \"531D1EBFA727CFDA651390F8021719FA9F7216CEB177BD75\", 16)))\n        {\n            fail(\"P incorrect\");\n        }\n\n        if (!dsaP.getG().equals(new BigInteger(\n            \"8DC6CC814CAE4A1C05A3E186A6FE27EA\" +\n            \"BA8CDB133FDCE14A963A92E809790CBA096EAA26140550C1\" +\n            \"29FA2B98C16E84236AA33BF919CD6F587E048C52666576DB\" +\n            \"6E925C6CBE9B9EC5C16020F9A44C9F1C8F7A8E611C1F6EC2\" +\n            \"513EA6AA0B8D0F72FED73CA37DF240DB57BBB27431D61869\" +\n            \"7B9E771B0B301D5DF05955425061A30DC6D33BB6D2A32BD0\" +\n            \"A75A0A71D2184F506372ABF84A56AEEEA8EB693BF29A6403\" +\n            \"45FA1298A16E85421B2208D00068A5A42915F82CF0B858C8\" +\n            \"FA39D43D704B6927E0B2F916304E86FB6A1B487F07D8139E\" +\n            \"428BB096C6D67A76EC0B8D4EF274B8A2CF556D279AD267CC\" +\n            \"EF5AF477AFED029F485B5597739F5D0240F67C2D948A6279\", 16)))\n        {\n            fail(\"G incorrect\");\n        }\n\n        KeyPairGenerator    g = KeyPairGenerator.getInstance(\"DSA\", \"BC\");\n        g.initialize(dsaP, new TestRandomBigInteger(Hex.decode(\"0CAF2EF547EC49C4F3A6FE6DF4223A174D01F2C115D49A6F73437C29A2A8458C\")));\n        KeyPair p = g.generateKeyPair();\n\n        DSAPrivateKey  sKey = (DSAPrivateKey)p.getPrivate();\n        DSAPublicKey   vKey = (DSAPublicKey)p.getPublic();\n\n        if (!vKey.getY().equals(new BigInteger(\n            \"2828003D7C747199143C370FDD07A286\" +\n            \"1524514ACC57F63F80C38C2087C6B795B62DE1C224BF8D1D\" +\n            \"1424E60CE3F5AE3F76C754A2464AF292286D873A7A30B7EA\" +\n            \"CBBC75AAFDE7191D9157598CDB0B60E0C5AA3F6EBE425500\" +\n            \"C611957DBF5ED35490714A42811FDCDEB19AF2AB30BEADFF\" +\n            \"2907931CEE7F3B55532CFFAEB371F84F01347630EB227A41\" +\n            \"9B1F3F558BC8A509D64A765D8987D493B007C4412C297CAF\" +\n            \"41566E26FAEE475137EC781A0DC088A26C8804A98C23140E\" +\n            \"7C936281864B99571EE95C416AA38CEEBB41FDBFF1EB1D1D\" +\n            \"C97B63CE1355257627C8B0FD840DDB20ED35BE92F08C49AE\" +\n            \"A5613957D7E5C7A6D5A5834B4CB069E0831753ECF65BA02B\", 16)))\n        {\n            fail(\"Y value incorrect\");\n        }\n\n        if (!sKey.getX().equals(\n            new BigInteger(\"0CAF2EF547EC49C4F3A6FE6DF4223A174D01F2C115D49A6F73437C29A2A8458C\", 16)))\n        {\n            fail(\"X value incorrect\");\n        }\n\n        byte[] encodeParams = params.getEncoded();\n\n        AlgorithmParameters a2 = AlgorithmParameters.getInstance(\"DSA\", \"BC\");\n        a2.init(encodeParams);\n\n        // a and a2 should be equivalent!\n        byte[] encodeParams_2 = a2.getEncoded();\n\n        if (!areEqual(encodeParams, encodeParams_2))\n        {\n            fail(\"encode/decode parameters failed\");\n        }\n\n        Signature           s = Signature.getInstance(\"DSA\", \"BC\");\n        byte[]              data = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 0 };\n\n        s.initSign(sKey);\n\n        s.update(data);\n\n        byte[]  sigBytes = s.sign();\n\n        s = Signature.getInstance(\"DSA\", \"BC\");\n\n        s.initVerify(vKey);\n\n        s.update(data);\n\n        if (!s.verify(sigBytes))\n        {\n            fail(\"DSA verification failed\");\n        }\n    }\n\n    public void performTest()\n        throws Exception\n    {\n        testCompat();\n        testNONEwithDSA();\n\n        testDSAsha3(NISTObjectIdentifiers.id_dsa_with_sha3_224, 224, new BigInteger(\"613202af2a7f77e02b11b5c3a5311cf6b412192bc0032aac3ec127faebfc6bd0\", 16));\n        testDSAsha3(NISTObjectIdentifiers.id_dsa_with_sha3_256, 256, new BigInteger(\"2450755c5e15a691b121bc833b97864e34a61ee025ecec89289c949c1858091e\", 16));\n        testDSAsha3(NISTObjectIdentifiers.id_dsa_with_sha3_384, 384, new BigInteger(\"7aad97c0b71bb1e1a6483b6948a03bbe952e4780b0cee699a11731f90d84ddd1\", 16));\n        testDSAsha3(NISTObjectIdentifiers.id_dsa_with_sha3_512, 512, new BigInteger(\"725ad64d923c668e64e7c3898b5efde484cab49ce7f98c2885d2a13a9e355ad4\", 16));\n\n        testECDSA239bitPrime();\n        testNONEwithECDSA239bitPrime();\n        testECDSA239bitBinary();\n        testECDSA239bitBinary(\"RIPEMD160withECDSA\", TeleTrusTObjectIdentifiers.ecSignWithRipemd160);\n        testECDSA239bitBinary(\"SHA1withECDSA\", TeleTrusTObjectIdentifiers.ecSignWithSha1);\n        testECDSA239bitBinary(\"SHA224withECDSA\", X9ObjectIdentifiers.ecdsa_with_SHA224);\n        testECDSA239bitBinary(\"SHA256withECDSA\", X9ObjectIdentifiers.ecdsa_with_SHA256);\n        testECDSA239bitBinary(\"SHA384withECDSA\", X9ObjectIdentifiers.ecdsa_with_SHA384);\n        testECDSA239bitBinary(\"SHA512withECDSA\", X9ObjectIdentifiers.ecdsa_with_SHA512);\n        testECDSA239bitBinary(\"SHA1withCVC-ECDSA\", EACObjectIdentifiers.id_TA_ECDSA_SHA_1);\n        testECDSA239bitBinary(\"SHA224withCVC-ECDSA\", EACObjectIdentifiers.id_TA_ECDSA_SHA_224);\n        testECDSA239bitBinary(\"SHA256withCVC-ECDSA\", EACObjectIdentifiers.id_TA_ECDSA_SHA_256);\n        testECDSA239bitBinary(\"SHA384withCVC-ECDSA\", EACObjectIdentifiers.id_TA_ECDSA_SHA_384);\n        testECDSA239bitBinary(\"SHA512withCVC-ECDSA\", EACObjectIdentifiers.id_TA_ECDSA_SHA_512);\n\n        testECDSAP256sha3(NISTObjectIdentifiers.id_ecdsa_with_sha3_224, 224, new BigInteger(\"84d7d8e68e405064109cd9fc3e3026d74d278aada14ce6b7a9dd0380c154dc94\", 16));\n        testECDSAP256sha3(NISTObjectIdentifiers.id_ecdsa_with_sha3_256, 256, new BigInteger(\"99a43bdab4af989aaf2899079375642f2bae2dce05bcd8b72ec8c4a8d9a143f\", 16));\n        testECDSAP256sha3(NISTObjectIdentifiers.id_ecdsa_with_sha3_384, 384, new BigInteger(\"aa27726509c37aaf601de6f7e01e11c19add99530c9848381c23365dc505b11a\", 16));\n        testECDSAP256sha3(NISTObjectIdentifiers.id_ecdsa_with_sha3_512, 512, new BigInteger(\"f8306b57a1f5068bf12e53aabaae39e2658db39bc56747eaefb479995130ad16\", 16));\n\n        testGeneration();\n        testParameters();\n        testDSA2Parameters();\n        testNullParameters();\n        testValidate();\n        testModified();\n    }\n\n    protected BigInteger[] derDecode(\n        byte[]  encoding)\n        throws IOException\n    {\n        ByteArrayInputStream    bIn = new ByteArrayInputStream(encoding);\n        ASN1InputStream         aIn = new ASN1InputStream(bIn);\n        ASN1Sequence            s = (ASN1Sequence)aIn.readObject();\n\n        BigInteger[]            sig = new BigInteger[2];\n\n        sig[0] = ((ASN1Integer)s.getObjectAt(0)).getValue();\n        sig[1] = ((ASN1Integer)s.getObjectAt(1)).getValue();\n\n        return sig;\n    }\n\n    public String getName()\n    {\n        return \"DSA/ECDSA\";\n    }\n\n    public static void main(\n        String[]    args)\n    {\n        Security.addProvider(new BouncyCastleProvider());\n\n        runTest(new DSATest());\n    }\n\n    private class DSATestSecureRandom\n        extends TestRandomData\n    {\n        private boolean first = true;\n\n        public DSATestSecureRandom(byte[] value)\n        {\n            super(value);\n        }\n\n       public void nextBytes(byte[] bytes)\n       {\n           if (first)\n           {\n               super.nextBytes(bytes);\n               first = false;\n           }\n           else\n           {\n               bytes[bytes.length - 1] = 2;\n           }\n       }\n    }\n}\n", "package org.bouncycastle.jce.provider.test;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.math.BigInteger;\nimport java.security.AlgorithmParameters;\nimport java.security.InvalidAlgorithmParameterException;\nimport java.security.InvalidKeyException;\nimport java.security.KeyFactory;\nimport java.security.KeyPair;\nimport java.security.KeyPairGenerator;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.NoSuchProviderException;\nimport java.security.PrivateKey;\nimport java.security.PublicKey;\nimport java.security.SecureRandom;\nimport java.security.Security;\nimport java.security.Signature;\nimport java.security.SignatureException;\nimport java.security.interfaces.ECPrivateKey;\nimport java.security.interfaces.ECPublicKey;\nimport java.security.spec.AlgorithmParameterSpec;\nimport java.security.spec.ECFieldF2m;\nimport java.security.spec.ECFieldFp;\nimport java.security.spec.ECGenParameterSpec;\nimport java.security.spec.ECParameterSpec;\nimport java.security.spec.ECPoint;\nimport java.security.spec.ECPrivateKeySpec;\nimport java.security.spec.ECPublicKeySpec;\nimport java.security.spec.EllipticCurve;\nimport java.security.spec.PKCS8EncodedKeySpec;\nimport java.security.spec.X509EncodedKeySpec;\n\nimport javax.crypto.KeyAgreement;\n\nimport org.bouncycastle.asn1.ASN1InputStream;\nimport org.bouncycastle.asn1.ASN1Integer;\nimport org.bouncycastle.asn1.ASN1ObjectIdentifier;\nimport org.bouncycastle.asn1.ASN1Primitive;\nimport org.bouncycastle.asn1.ASN1Sequence;\nimport org.bouncycastle.asn1.bsi.BSIObjectIdentifiers;\nimport org.bouncycastle.asn1.eac.EACObjectIdentifiers;\nimport org.bouncycastle.asn1.nist.NISTNamedCurves;\nimport org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers;\nimport org.bouncycastle.asn1.pkcs.PrivateKeyInfo;\nimport org.bouncycastle.asn1.sec.SECObjectIdentifiers;\nimport org.bouncycastle.asn1.teletrust.TeleTrusTObjectIdentifiers;\nimport org.bouncycastle.asn1.x509.SubjectPublicKeyInfo;\nimport org.bouncycastle.asn1.x9.X962Parameters;\nimport org.bouncycastle.asn1.x9.X9ECParameters;\nimport org.bouncycastle.asn1.x9.X9ObjectIdentifiers;\nimport org.bouncycastle.jcajce.provider.asymmetric.util.ECUtil;\nimport org.bouncycastle.jcajce.spec.MQVParameterSpec;\nimport org.bouncycastle.jce.ECKeyUtil;\nimport org.bouncycastle.jce.ECNamedCurveTable;\nimport org.bouncycastle.jce.ECPointUtil;\nimport org.bouncycastle.jce.provider.BouncyCastleProvider;\nimport org.bouncycastle.math.ec.ECCurve;\nimport org.bouncycastle.util.Arrays;\nimport org.bouncycastle.util.BigIntegers;\nimport org.bouncycastle.util.Strings;\nimport org.bouncycastle.util.encoders.Hex;\nimport org.bouncycastle.util.test.FixedSecureRandom;\nimport org.bouncycastle.util.test.SimpleTest;\nimport org.bouncycastle.util.test.TestRandomBigInteger;\n\npublic class ECDSA5Test\n    extends SimpleTest\n{\n    byte[] k1 = Hex.decode(\"d5014e4b60ef2ba8b6211b4062ba3224e0427dd3\");\n    byte[] k2 = Hex.decode(\"345e8d05c075c3a508df729a1685690e68fcfb8c8117847e89063bca1f85d968fd281540b6e13bd1af989a1fbf17e06462bf511f9d0b140fb48ac1b1baa5bded\");\n\n    SecureRandom    random = new FixedSecureRandom(\n        new FixedSecureRandom.Source[] { new FixedSecureRandom.Data(k1), new FixedSecureRandom.Data(k2) });\n    \n    private void decodeTest()\n    {\n        EllipticCurve curve = new EllipticCurve(\n                new ECFieldFp(new BigInteger(\"6277101735386680763835789423207666416083908700390324961279\")), // q\n                new BigInteger(\"fffffffffffffffffffffffffffffffefffffffffffffffc\", 16), // a\n                new BigInteger(\"64210519e59c80e70fa7e9ab72243049feb8deecc146b9b1\", 16)); // b\n\n        ECPoint p = ECPointUtil.decodePoint(curve, Hex.decode(\"03188da80eb03090f67cbf20eb43a18800f4ff0afd82ff1012\"));\n\n        if (!p.getAffineX().equals(new BigInteger(\"188da80eb03090f67cbf20eb43a18800f4ff0afd82ff1012\", 16)))\n        {\n            fail(\"x uncompressed incorrectly\");\n        }\n\n        if (!p.getAffineY().equals(new BigInteger(\"7192b95ffc8da78631011ed6b24cdd573f977a11e794811\", 16)))\n        {\n            fail(\"y uncompressed incorrectly\");\n        }\n    }\n\n    /**\n     * X9.62 - 1998,<br>\n     * J.3.2, Page 155, ECDSA over the field Fp<br>\n     * an example with 239 bit prime\n     */\n    private void testECDSA239bitPrime()\n        throws Exception\n    {\n        BigInteger r = new BigInteger(\"308636143175167811492622547300668018854959378758531778147462058306432176\");\n        BigInteger s = new BigInteger(\"323813553209797357708078776831250505931891051755007842781978505179448783\");\n\n        byte[] kData = BigIntegers.asUnsignedByteArray(new BigInteger(\"700000017569056646655505781757157107570501575775705779575555657156756655\"));\n\n        SecureRandom    k = new TestRandomBigInteger(kData);\n\n        EllipticCurve curve = new EllipticCurve(\n            new ECFieldFp(new BigInteger(\"883423532389192164791648750360308885314476597252960362792450860609699839\")), // q\n            new BigInteger(\"7fffffffffffffffffffffff7fffffffffff8000000000007ffffffffffc\", 16), // a\n            new BigInteger(\"6b016c3bdcf18941d0d654921475ca71a9db2fb27d1d37796185c2942c0a\", 16)); // b\n\n        ECParameterSpec spec = new ECParameterSpec(\n            curve,\n            ECPointUtil.decodePoint(curve, Hex.decode(\"020ffa963cdca8816ccc33b8642bedf905c3d358573d3f27fbbd3b3cb9aaaf\")), // G\n            new BigInteger(\"883423532389192164791648750360308884807550341691627752275345424702807307\"), // n\n            1); // h\n        \n\n        ECPrivateKeySpec priKey = new ECPrivateKeySpec(\n            new BigInteger(\"876300101507107567501066130761671078357010671067781776716671676178726717\"), // d\n            spec);\n\n        ECPublicKeySpec pubKey = new ECPublicKeySpec(\n            ECPointUtil.decodePoint(curve, Hex.decode(\"025b6dc53bc61a2548ffb0f671472de6c9521a9d2d2534e65abfcbd5fe0c70\")), // Q\n            spec);\n\n        Signature           sgr = Signature.getInstance(\"ECDSA\", \"BC\");\n        KeyFactory          f = KeyFactory.getInstance(\"ECDSA\", \"BC\");\n        PrivateKey          sKey = f.generatePrivate(priKey);\n        PublicKey           vKey = f.generatePublic(pubKey);\n\n        sgr.initSign(sKey, k);\n\n        byte[] message = new byte[] { (byte)'a', (byte)'b', (byte)'c' };\n\n        sgr.update(message);\n\n        byte[]  sigBytes = sgr.sign();\n\n        sgr.initVerify(vKey);\n\n        sgr.update(message);\n\n        if (!sgr.verify(sigBytes))\n        {\n            fail(\"239 Bit EC verification failed\");\n        }\n\n        BigInteger[]  sig = derDecode(sigBytes);\n\n        if (!r.equals(sig[0]))\n        {\n            fail(\"r component wrong.\" + Strings.lineSeparator()\n                + \" expecting: \" + r + Strings.lineSeparator()\n                + \" got      : \" + sig[0]);\n        }\n\n        if (!s.equals(sig[1]))\n        {\n            fail(\"s component wrong.\" + Strings.lineSeparator()\n                + \" expecting: \" + s + Strings.lineSeparator()\n                + \" got      : \" + sig[1]);\n        }\n    }\n\n    // test BSI algorithm support.\n    private void testBSI()\n        throws Exception\n    {\n        KeyPairGenerator kpGen = KeyPairGenerator.getInstance(\"ECDSA\", \"BC\");\n\n        kpGen.initialize(new ECGenParameterSpec(TeleTrusTObjectIdentifiers.brainpoolP512r1.getId()));\n\n        KeyPair kp = kpGen.generateKeyPair();\n\n        byte[] data = \"Hello World!!!\".getBytes();\n        String[] cvcAlgs = { \"SHA1WITHCVC-ECDSA\", \"SHA224WITHCVC-ECDSA\",\n                             \"SHA256WITHCVC-ECDSA\", \"SHA384WITHCVC-ECDSA\",\n                             \"SHA512WITHCVC-ECDSA\" };\n        String[] cvcOids = { EACObjectIdentifiers.id_TA_ECDSA_SHA_1.getId(), EACObjectIdentifiers.id_TA_ECDSA_SHA_224.getId(),\n                             EACObjectIdentifiers.id_TA_ECDSA_SHA_256.getId(), EACObjectIdentifiers.id_TA_ECDSA_SHA_384.getId(),\n                             EACObjectIdentifiers.id_TA_ECDSA_SHA_512.getId() };\n\n        testBsiAlgorithms(kp, data, cvcAlgs, cvcOids);\n\n        String[] plainAlgs = { \"SHA1WITHPLAIN-ECDSA\", \"SHA224WITHPLAIN-ECDSA\",\n                             \"SHA256WITHPLAIN-ECDSA\", \"SHA384WITHPLAIN-ECDSA\",\n                             \"SHA512WITHPLAIN-ECDSA\", \"RIPEMD160WITHPLAIN-ECDSA\" };\n        String[] plainOids = { BSIObjectIdentifiers.ecdsa_plain_SHA1.getId(), BSIObjectIdentifiers.ecdsa_plain_SHA224.getId(),\n                                BSIObjectIdentifiers.ecdsa_plain_SHA256.getId(), BSIObjectIdentifiers.ecdsa_plain_SHA384.getId(),\n                                BSIObjectIdentifiers.ecdsa_plain_SHA512.getId(), BSIObjectIdentifiers.ecdsa_plain_RIPEMD160.getId() };\n\n        testBsiAlgorithms(kp, data, plainAlgs, plainOids);\n    }\n\n    private void testBsiAlgorithms(KeyPair kp, byte[] data, String[] algs, String[] oids)\n        throws NoSuchAlgorithmException, NoSuchProviderException, InvalidKeyException, SignatureException\n    {\n        for (int i = 0; i != algs.length; i++)\n        {\n            Signature sig1 = Signature.getInstance(algs[i], \"BC\");\n            Signature sig2 = Signature.getInstance(oids[i], \"BC\");\n\n            sig1.initSign(kp.getPrivate());\n\n            sig1.update(data);\n\n            byte[] sig = sig1.sign();\n\n            sig2.initVerify(kp.getPublic());\n\n            sig2.update(data);\n\n            if (!sig2.verify(sig))\n            {\n                fail(\"BSI CVC signature failed: \" + algs[i]);\n            }\n        }\n    }\n\n    /**\n     * X9.62 - 1998,<br>\n     * J.2.1, Page 100, ECDSA over the field F2m<br>\n     * an example with 191 bit binary field\n     */\n    private void testECDSA239bitBinary()\n        throws Exception\n    {\n        BigInteger r = new BigInteger(\"21596333210419611985018340039034612628818151486841789642455876922391552\");\n        BigInteger s = new BigInteger(\"197030374000731686738334997654997227052849804072198819102649413465737174\");\n    \n        byte[] kData = BigIntegers.asUnsignedByteArray(new BigInteger(\"171278725565216523967285789236956265265265235675811949404040041670216363\"));\n\n        SecureRandom    k = new TestRandomBigInteger(kData);\n\n        EllipticCurve curve = new EllipticCurve(\n            new ECFieldF2m(239, // m\n                           new int[] { 36 }), // k\n            new BigInteger(\"32010857077C5431123A46B808906756F543423E8D27877578125778AC76\", 16), // a\n            new BigInteger(\"790408F2EEDAF392B012EDEFB3392F30F4327C0CA3F31FC383C422AA8C16\", 16)); // b\n    \n        ECParameterSpec params = new ECParameterSpec(\n            curve,\n            ECPointUtil.decodePoint(curve, Hex.decode(\"0457927098FA932E7C0A96D3FD5B706EF7E5F5C156E16B7E7C86038552E91D61D8EE5077C33FECF6F1A16B268DE469C3C7744EA9A971649FC7A9616305\")), // G\n            new BigInteger(\"220855883097298041197912187592864814557886993776713230936715041207411783\"), // n\n            4); // h\n    \n        ECPrivateKeySpec priKeySpec = new ECPrivateKeySpec(\n            new BigInteger(\"145642755521911534651321230007534120304391871461646461466464667494947990\"), // d\n            params);\n        \n        ECPublicKeySpec pubKeySpec = new ECPublicKeySpec(\n            ECPointUtil.decodePoint(curve, Hex.decode(\"045894609CCECF9A92533F630DE713A958E96C97CCB8F5ABB5A688A238DEED6DC2D9D0C94EBFB7D526BA6A61764175B99CB6011E2047F9F067293F57F5\")), // Q\n            params);\n    \n        Signature   sgr = Signature.getInstance(\"ECDSA\", \"BC\");\n        KeyFactory  f = KeyFactory.getInstance(\"ECDSA\", \"BC\");\n        PrivateKey  sKey = f.generatePrivate(priKeySpec);\n        PublicKey   vKey = f.generatePublic(pubKeySpec);\n        byte[]      message = new byte[] { (byte)'a', (byte)'b', (byte)'c' };\n       \n        sgr.initSign(sKey, k);\n\n        sgr.update(message);\n        \n        byte[]  sigBytes = sgr.sign();\n\n        sgr.initVerify(vKey);\n\n        sgr.update(message);\n\n        if (!sgr.verify(sigBytes))\n        {\n            fail(\"239 Bit EC verification failed\");\n        }\n\n        BigInteger[]  sig = derDecode(sigBytes);\n\n        if (!r.equals(sig[0]))\n        {\n            fail(\"r component wrong.\" + Strings.lineSeparator()\n                + \" expecting: \" + r + Strings.lineSeparator()\n                + \" got      : \" + sig[0]);\n        }\n\n        if (!s.equals(sig[1]))\n        {\n            fail(\"s component wrong.\" + Strings.lineSeparator()\n                + \" expecting: \" + s + Strings.lineSeparator()\n                + \" got      : \" + sig[1]);\n        }\n    }\n    \n    private void testGeneration()\n        throws Exception\n    {\n        //\n        // ECDSA generation test\n        //\n        byte[]              data = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 0 };\n        Signature s = Signature.getInstance(\"ECDSA\", \"BC\");\n        KeyPairGenerator g = KeyPairGenerator.getInstance(\"ECDSA\", \"BC\");\n\n        EllipticCurve curve = new EllipticCurve(\n            new ECFieldFp(new BigInteger(\"883423532389192164791648750360308885314476597252960362792450860609699839\")), // q\n            new BigInteger(\"7fffffffffffffffffffffff7fffffffffff8000000000007ffffffffffc\", 16), // a\n            new BigInteger(\"6b016c3bdcf18941d0d654921475ca71a9db2fb27d1d37796185c2942c0a\", 16)); // b\n\n        ECParameterSpec ecSpec = new ECParameterSpec(\n            curve,\n            ECPointUtil.decodePoint(curve, Hex.decode(\"020ffa963cdca8816ccc33b8642bedf905c3d358573d3f27fbbd3b3cb9aaaf\")), // G\n            new BigInteger(\"883423532389192164791648750360308884807550341691627752275345424702807307\"), // n\n            1); // h\n\n        g.initialize(ecSpec, new SecureRandom());\n\n        KeyPair p = g.generateKeyPair();\n\n        PrivateKey sKey = p.getPrivate();\n        PublicKey  vKey = p.getPublic();\n\n        s.initSign(sKey);\n\n        s.update(data);\n\n        byte[] sigBytes = s.sign();\n\n        s = Signature.getInstance(\"ECDSA\", \"BC\");\n\n        s.initVerify(vKey);\n\n        s.update(data);\n\n        if (!s.verify(sigBytes))\n        {\n            fail(\"ECDSA verification failed\");\n        }\n\n        testKeyFactory((ECPublicKey)vKey, (ECPrivateKey)sKey);\n        testSerialise((ECPublicKey)vKey, (ECPrivateKey)sKey);\n    }\n\n    private void testSerialise(ECPublicKey ecPublicKey, ECPrivateKey ecPrivateKey)\n        throws Exception\n    {\n        ByteArrayOutputStream bOut = new ByteArrayOutputStream();\n        ObjectOutputStream oOut = new ObjectOutputStream(bOut);\n\n        oOut.writeObject(ecPublicKey);\n        oOut.writeObject(ecPrivateKey);\n        oOut.close();\n\n        ObjectInputStream oIn = new ObjectInputStream(new ByteArrayInputStream(bOut.toByteArray()));\n\n        PublicKey pubKey = (PublicKey)oIn.readObject();\n        PrivateKey privKey = (PrivateKey)oIn.readObject();\n\n        if (!ecPublicKey.equals(pubKey))\n        {\n            fail(\"public key serialisation check failed\");\n        }\n\n        if (!ecPrivateKey.equals(privKey))\n        {\n            fail(\"private key serialisation check failed\");\n        }\n    }\n\n    private void testKeyFactory(ECPublicKey pub, ECPrivateKey priv)\n        throws Exception\n    {\n        KeyFactory ecFact = KeyFactory.getInstance(\"ECDSA\");\n\n        ECPublicKeySpec  pubSpec = (ECPublicKeySpec)ecFact.getKeySpec(pub, ECPublicKeySpec.class);\n        ECPrivateKeySpec  privSpec = (ECPrivateKeySpec)ecFact.getKeySpec(priv, ECPrivateKeySpec.class);\n\n        if (!pubSpec.getW().equals(pub.getW()) || !pubSpec.getParams().getCurve().equals(pub.getParams().getCurve()))\n        {\n            fail(\"pubSpec not correct\");\n        }\n\n        if (!privSpec.getS().equals(priv.getS()) || !privSpec.getParams().getCurve().equals(priv.getParams().getCurve()))\n        {\n            fail(\"privSpec not correct\");\n        }\n\n        ECPublicKey  pubKey = (ECPublicKey)ecFact.translateKey(pub);\n        ECPrivateKey  privKey = (ECPrivateKey)ecFact.translateKey(priv);\n\n        if (!pubKey.getW().equals(pub.getW()) || !pubKey.getParams().getCurve().equals(pub.getParams().getCurve()))\n        {\n            fail(\"pubKey not correct\");\n        }\n\n        if (!privKey.getS().equals(priv.getS()) || !privKey.getParams().getCurve().equals(priv.getParams().getCurve()))\n        {\n            fail(\"privKey not correct\");\n        }\n    }\n\n    private void testKeyConversion()\n        throws Exception\n    {\n        KeyPairGenerator kpGen = KeyPairGenerator.getInstance(\"ECDSA\", \"BC\");\n\n        kpGen.initialize(new ECGenParameterSpec(\"prime192v1\"));\n\n        KeyPair pair = kpGen.generateKeyPair();\n\n        PublicKey pubKey = ECKeyUtil.publicToExplicitParameters(pair.getPublic(), \"BC\");\n\n        SubjectPublicKeyInfo info = SubjectPublicKeyInfo.getInstance(ASN1Primitive.fromByteArray(pubKey.getEncoded()));\n        X962Parameters params = X962Parameters.getInstance(info.getAlgorithmId().getParameters());\n\n        if (params.isNamedCurve() || params.isImplicitlyCA())\n        {\n            fail(\"public key conversion to explicit failed\");\n        }\n\n        if (!((ECPublicKey)pair.getPublic()).getW().equals(((ECPublicKey)pubKey).getW()))\n        {\n            fail(\"public key conversion check failed\");\n        }\n\n        PrivateKey privKey = ECKeyUtil.privateToExplicitParameters(pair.getPrivate(), \"BC\");\n        PrivateKeyInfo privInfo = PrivateKeyInfo.getInstance(ASN1Primitive.fromByteArray(privKey.getEncoded()));\n        params = X962Parameters.getInstance(privInfo.getAlgorithmId().getParameters());\n\n        if (params.isNamedCurve() || params.isImplicitlyCA())\n        {\n            fail(\"private key conversion to explicit failed\");\n        }\n\n        if (!((ECPrivateKey)pair.getPrivate()).getS().equals(((ECPrivateKey)privKey).getS()))\n        {\n            fail(\"private key conversion check failed\");\n        }\n    }\n\n    private void testAdaptiveKeyConversion()\n        throws Exception\n    {\n        KeyPairGenerator kpGen = KeyPairGenerator.getInstance(\"ECDSA\", \"BC\");\n\n        kpGen.initialize(new ECGenParameterSpec(\"prime192v1\"));\n\n        KeyPair pair = kpGen.generateKeyPair();\n\n        final PrivateKey privKey = pair.getPrivate();\n        final PublicKey  pubKey = pair.getPublic();\n\n        Signature s = Signature.getInstance(\"ECDSA\", \"BC\");\n\n        // raw interface tests\n        s.initSign(new PrivateKey()\n        {\n            public String getAlgorithm()\n            {\n                return privKey.getAlgorithm();\n            }\n\n            public String getFormat()\n            {\n                return privKey.getFormat();\n            }\n\n            public byte[] getEncoded()\n            {\n                return privKey.getEncoded();\n            }\n        });\n\n        s.initVerify(new PublicKey()\n        {\n            public String getAlgorithm()\n            {\n                return pubKey.getAlgorithm();\n            }\n\n            public String getFormat()\n            {\n                return pubKey.getFormat();\n            }\n\n            public byte[] getEncoded()\n            {\n                return pubKey.getEncoded();\n            }\n        });\n\n\n        s.initSign(new ECPrivateKey()\n        {\n            public String getAlgorithm()\n            {\n                return privKey.getAlgorithm();\n            }\n\n            public String getFormat()\n            {\n                return privKey.getFormat();\n            }\n\n            public byte[] getEncoded()\n            {\n                return privKey.getEncoded();\n            }\n\n            public BigInteger getS()\n            {\n                return ((ECPrivateKey)privKey).getS();\n            }\n\n            public ECParameterSpec getParams()\n            {\n                return ((ECPrivateKey)privKey).getParams();\n            }\n        });\n\n        s.initVerify(new ECPublicKey()\n        {\n            public String getAlgorithm()\n            {\n                return pubKey.getAlgorithm();\n            }\n\n            public String getFormat()\n            {\n                return pubKey.getFormat();\n            }\n\n            public byte[] getEncoded()\n            {\n                return pubKey.getEncoded();\n            }\n\n            public ECPoint getW()\n            {\n                return ((ECPublicKey)pubKey).getW();\n            }\n\n            public ECParameterSpec getParams()\n            {\n                return ((ECPublicKey)pubKey).getParams();\n            }\n        });\n\n        try\n        {\n            s.initSign(new PrivateKey()\n            {\n                public String getAlgorithm()\n                {\n                    return privKey.getAlgorithm();\n                }\n\n                public String getFormat()\n                {\n                    return privKey.getFormat();\n                }\n\n                public byte[] getEncoded()\n                {\n                    return null;\n                }\n            });\n\n            fail(\"no exception thrown!!!\");\n        }\n        catch (InvalidKeyException e)\n        {\n            // ignore\n        }\n\n        try\n        {\n            s.initVerify(new PublicKey()\n            {\n                public String getAlgorithm()\n                {\n                    return pubKey.getAlgorithm();\n                }\n\n                public String getFormat()\n                {\n                    return pubKey.getFormat();\n                }\n\n                public byte[] getEncoded()\n                {\n                    return null;\n                }\n            });\n\n            fail(\"no exception thrown!!!\");\n        }\n        catch (InvalidKeyException e)\n        {\n            // ignore\n        }\n\n        // try bogus encoding\n        try\n        {\n            s.initSign(new PrivateKey()\n            {\n                public String getAlgorithm()\n                {\n                    return privKey.getAlgorithm();\n                }\n\n                public String getFormat()\n                {\n                    return privKey.getFormat();\n                }\n\n                public byte[] getEncoded()\n                {\n                    return new byte[20];\n                }\n            });\n\n            fail(\"no exception thrown!!!\");\n        }\n        catch (InvalidKeyException e)\n        {\n            // ignore\n        }\n\n        try\n        {\n            s.initVerify(new PublicKey()\n            {\n                public String getAlgorithm()\n                {\n                    return pubKey.getAlgorithm();\n                }\n\n                public String getFormat()\n                {\n                    return pubKey.getFormat();\n                }\n\n                public byte[] getEncoded()\n                {\n                    return new byte[20];\n                }\n            });\n\n            fail(\"no exception thrown!!!\");\n        }\n        catch (InvalidKeyException e)\n        {\n            // ignore\n        }\n\n        // try encoding of wrong key\n        kpGen = KeyPairGenerator.getInstance(\"RSA\", \"BC\");\n\n        kpGen.initialize(512);\n\n        pair = kpGen.generateKeyPair();\n\n        final PrivateKey privRsa = pair.getPrivate();\n        final PublicKey  pubRsa = pair.getPublic();\n\n        try\n        {\n            s.initSign(new PrivateKey()\n            {\n                public String getAlgorithm()\n                {\n                    return privRsa.getAlgorithm();\n                }\n\n                public String getFormat()\n                {\n                    return privRsa.getFormat();\n                }\n\n                public byte[] getEncoded()\n                {\n                    return privRsa.getEncoded();\n                }\n            });\n\n            fail(\"no exception thrown!!!\");\n\n        }\n        catch (InvalidKeyException e)\n        {\n            // ignore\n        }\n\n        try\n        {\n            s.initVerify(new PublicKey()\n            {\n                public String getAlgorithm()\n                {\n                    return pubRsa.getAlgorithm();\n                }\n\n                public String getFormat()\n                {\n                    return pubRsa.getFormat();\n                }\n\n                public byte[] getEncoded()\n                {\n                    return pubRsa.getEncoded();\n                }\n            });\n\n            fail(\"no exception thrown!!!\");\n        }\n        catch (InvalidKeyException e)\n        {\n            // ignore\n        }\n    }\n\n    private void testAlgorithmParameters()\n        throws Exception\n    {\n        AlgorithmParameters algParam = AlgorithmParameters.getInstance(\"EC\", \"BC\");\n\n        algParam.init(new ECGenParameterSpec(\"P-256\"));\n\n        byte[] encoded = algParam.getEncoded();\n\n        algParam = AlgorithmParameters.getInstance(\"EC\", \"BC\");\n\n        algParam.init(encoded);\n\n        ECGenParameterSpec genSpec = algParam.getParameterSpec(ECGenParameterSpec.class);\n\n        if (!genSpec.getName().equals(X9ObjectIdentifiers.prime256v1.getId()))\n        {\n            fail(\"curve name not recovered\");\n        }\n\n        ECParameterSpec ecSpec = algParam.getParameterSpec(ECParameterSpec.class);\n\n        if (!ecSpec.getOrder().equals(NISTNamedCurves.getByName(\"P-256\").getN()))\n        {\n            fail(\"incorrect spec recovered\");\n        }\n    }\n\n    private void testKeyPairGenerationWithOIDs()\n        throws Exception\n    {\n        KeyPairGenerator kpGen = KeyPairGenerator.getInstance(\"ECDSA\", \"BC\");\n\n        kpGen.initialize(new ECGenParameterSpec(X9ObjectIdentifiers.prime192v1.getId()));\n        kpGen.initialize(new ECGenParameterSpec(TeleTrusTObjectIdentifiers.brainpoolP160r1.getId()));\n        kpGen.initialize(new ECGenParameterSpec(SECObjectIdentifiers.secp128r1.getId()));\n\n        try\n        {\n            kpGen.initialize(new ECGenParameterSpec(\"1.1\"));\n\n            fail(\"non-existant curve OID failed\");\n        }\n        catch (InvalidAlgorithmParameterException e)\n        {\n            if (!\"unknown curve OID: 1.1\".equals(e.getMessage()))\n            {\n                fail(\"OID message check failed\");\n            }\n        }\n\n        try\n        {\n            kpGen.initialize(new ECGenParameterSpec(\"flibble\"));\n\n            fail(\"non-existant curve name failed\");\n        }\n        catch (InvalidAlgorithmParameterException e)\n        {\n            if (!\"unknown curve name: flibble\".equals(e.getMessage()))\n            {\n                fail(\"name message check failed\");\n            }\n        }\n    }\n\n    private static class ECRandom\n        extends SecureRandom\n    {\n        public void nextBytes(byte[] bytes)\n        {\n            byte[] src = new BigInteger(\"e2eb6663f551331bda00b90f1272c09d980260c1a70cab1ec481f6c937f34b62\", 16).toByteArray();\n\n            if (src.length <= bytes.length)\n            {\n                System.arraycopy(src, 0, bytes, bytes.length - src.length, src.length);\n            }\n            else\n            {\n                System.arraycopy(src, 0, bytes, 0, bytes.length);\n            }\n        }\n    }\n\n    private void testNamedCurveParameterPreservation()\n        throws Exception\n    {\n        AlgorithmParameterSpec ecSpec = ECNamedCurveTable.getParameterSpec(\"secp256r1\");\n        KeyPairGenerator keygen = KeyPairGenerator.getInstance(\"EC\", \"BC\");\n        keygen.initialize(ecSpec, new ECRandom());\n\n        KeyPair keys = keygen.generateKeyPair();\n\n        PrivateKeyInfo priv1 = PrivateKeyInfo.getInstance(keys.getPrivate().getEncoded());\n        SubjectPublicKeyInfo pub1 = SubjectPublicKeyInfo.getInstance(keys.getPublic().getEncoded());\n\n        keygen = KeyPairGenerator.getInstance(\"EC\", \"BC\");\n        keygen.initialize(new ECGenParameterSpec(\"secp256r1\"), new ECRandom());\n\n        PrivateKeyInfo priv2 = PrivateKeyInfo.getInstance(keys.getPrivate().getEncoded());\n        SubjectPublicKeyInfo pub2 = SubjectPublicKeyInfo.getInstance(keys.getPublic().getEncoded());\n\n        if (!priv1.equals(priv2) || !pub1.equals(pub2))\n        {\n            fail(\"mismatch between alg param spec and ECGenParameterSpec\");\n        }\n\n        if (!(priv2.getPrivateKeyAlgorithm().getParameters() instanceof ASN1ObjectIdentifier))\n        {\n            fail(\"OID not preserved in private key\");\n        }\n\n        if (!(pub1.getAlgorithm().getParameters() instanceof ASN1ObjectIdentifier))\n        {\n            fail(\"OID not preserved in public key\");\n        }\n    }\n\n    private void testNamedCurveSigning()\n        throws Exception\n    {\n        testCustomNamedCurveSigning(\"secp256r1\");\n\n        try\n        {\n            testCustomNamedCurveSigning(\"secp256k1\");\n        }\n        catch (IllegalArgumentException e)\n        {\n            if (!e.getMessage().equals(\"first coefficient is negative\"))     // bogus jdk 1.5 exception...\n            {\n                throw e;\n            }\n        }\n    }\n\n    private void testCustomNamedCurveSigning(String name)\n        throws Exception\n    {\n        X9ECParameters x9Params = ECUtil.getNamedCurveByOid(ECUtil.getNamedCurveOid(name));\n\n        // TODO: one day this may have to change\n        if (x9Params.getCurve() instanceof ECCurve.Fp)\n        {\n            fail(\"curve not custom curve!!\");\n        }\n\n        AlgorithmParameterSpec ecSpec = ECNamedCurveTable.getParameterSpec(name);\n        KeyPairGenerator keygen = KeyPairGenerator.getInstance(\"EC\", \"BC\");\n        keygen.initialize(ecSpec, new ECRandom());\n\n        KeyPair keys = keygen.generateKeyPair();\n\n        PrivateKeyInfo priv1 = PrivateKeyInfo.getInstance(keys.getPrivate().getEncoded());\n        SubjectPublicKeyInfo pub1 = SubjectPublicKeyInfo.getInstance(keys.getPublic().getEncoded());\n\n        keygen = KeyPairGenerator.getInstance(\"EC\", \"BC\");\n        keygen.initialize(new ECGenParameterSpec(\"secp256r1\"), new ECRandom());\n\n        Signature ecdsaSigner = Signature.getInstance(\"ECDSA\", \"BC\");\n\n        ecdsaSigner.initSign(keys.getPrivate());\n\n        ecdsaSigner.update(new byte[100]);\n\n        byte[] sig = ecdsaSigner.sign();\n\n        ecdsaSigner.initVerify(keys.getPublic());\n\n        ecdsaSigner.update(new byte[100]);\n\n        if (!ecdsaSigner.verify(sig))\n        {\n            fail(\"signature failed to verify\");\n        }\n\n        KeyFactory kFact = KeyFactory.getInstance(\"EC\", \"BC\");\n\n        PublicKey pub = kFact.generatePublic(new X509EncodedKeySpec(pub1.getEncoded()));\n        PrivateKey pri = kFact.generatePrivate(new PKCS8EncodedKeySpec(priv1.getEncoded()));\n\n        ecdsaSigner = Signature.getInstance(\"ECDSA\", \"BC\");\n\n        ecdsaSigner.initSign(pri);\n\n        ecdsaSigner.update(new byte[100]);\n\n        sig = ecdsaSigner.sign();\n\n        ecdsaSigner.initVerify(pub);\n\n        ecdsaSigner.update(new byte[100]);\n\n        if (!ecdsaSigner.verify(sig))\n        {\n            fail(\"signature failed to verify\");\n        }\n    }\n\n    /**\n    COUNT = 1\n    dsCAVS = 00000179557decd75b797bea9db656ce99c03a6e0ab13804b5b589644f7db41ceba05c3940c300361061074ca72a828428d9198267fa0b75e1e3e785a0ff20e839414be0\n    QsCAVSx = 000001ce7da31681d5f176f3618f205969b9142520363dd26a596866c89988c932e3ce01904d12d1e9b105462e56163dbe7658ba3c472bf1f3c8165813295393ae346764\n    QsCAVSy = 000000e70d6e55b76ebd362ff071ab819315593cec650276209a9fdc2c1c48e03c35945f04e74d958cabd3f5e4d1f096a991e807a8f9d217de306a6b561038ca15aea4b9\n    NonceEphemCAVS = 4214a1a0a1d11679ae22f98d7ae483c1a74008a9cd7f7cf71b1f373a4226f5c58eb621ec56e2537797c01750dcbff07f613b9c58774f9af32aebeadd2226140dc7d56b1aa95c93ab1ec4412e2d0e42cdaac7bf9da3ddbf19fbb1edd0556d9c5a339808905fe8defd8b57ff8f34788192cc0cf7df17d1f351d69ac979a3a495931c287fb8\n    dsIUT = 000000c14895dfcc5a6b24994828cfd0a0cc0a881a70173a3eb05c57b098046c8e60a868f6176284aa346eff1fd1b8b879052c5a6d5fd0ae146b35ed7ecee32e294103cd\n    QsIUTx = 00000174a658695049db59f6bbe2ad23e1753bf58384a56fc9b3dec13eb873b33e1f4dbd24b6b4ca05a9a11ad531f6d99e9430a774980e8a8d9fd2d1e2a0d76fe3dd36c7\n    QsIUTy = 00000030639849e1df341973db44e7bbba5bb597884a439f9ce54620c3ca73a9804cc26fcda3aaf73ae5a11d5b325cae0e95cfafe1985c6c2fdb892722e7dd2c5d744cf3\n    deIUT = 00000138f54e986c7b44f49da389fa9f61bb7265f0cebdeddf09d47c72e55186e2520965fc2c31bb9c0a557e3c28e02a751f097e413c4252c7b0d22452d89f9ac314bc6e\n    QeIUTx = 000001b9fbce9c9ebb31070a4a4ac7af54ec9189c1f98948cd24ca0a5029217e4784d3c8692da08a6a512d1c9875d20d8e03664c148fa5d34bbac6d42e499ee5dbf01120\n    QeIUTy = 000000994a714b6d09afa896dbba9b4f436ab3cdb0d11dcd2aad28b7ba35d6fa6be537b6ffb0f9bf5fe1d594b8f8b8829687c9395c3d938c873f26c7100888c3aca2d59a\n    OI = a1b2c3d4e54341565369646dbb63a273c81e0aad02f92699bf7baa28fd4509145b0096746894e98e209a85ecb415b8\n    CAVSTag = 4ade5dc983cc1cf61c90fdbf726fa6a88e9bf411bbaf0015db06ff4348560e4d\n    Z = 019a19a0a99f60221ee23323b3317292e8c10d57ba04e0b33f6241979ec3895945eed0bdcbc59ab576e7047061f0d63d1aaf78b1d442028605aa1c0f963a3bc9d61a\n    MacData = 4b435f315f55a1b2c3d4e543415653696401b9fbce9c9ebb31070a4a4ac7af54ec9189c1f98948cd24ca0a5029217e4784d3c8692da08a6a512d1c9875d20d8e03664c148fa5d34bbac6d42e499ee5dbf0112000994a714b6d09afa896dbba9b4f436ab3cdb0d11dcd2aad28b7ba35d6fa6be537b6ffb0f9bf5fe1d594b8f8b8829687c9395c3d938c873f26c7100888c3aca2d59a4214a1a0a1d11679ae22f98d7ae483c1a74008a9cd7f7cf71b1f373a4226f5c58eb621ec56e2537797c01750dcbff07f613b9c58774f9af32aebeadd2226140dc7d56b1aa95c93ab1ec4412e2d0e42cdaac7bf9da3ddbf19fbb1edd0556d9c5a339808905fe8defd8b57ff8f34788192cc0cf7df17d1f351d69ac979a3a495931c287fb8\n    DKM = 0744e1774149a8b8f88d3a1e20ac1517efd2f54ba4b5f178de99f33b68eea426\n    Result = P (14 - DKM value should have leading 0 nibble )\n    */\n    public void testMQVwithHMACOnePass()\n        throws Exception\n    {\n        AlgorithmParameters algorithmParameters = AlgorithmParameters.getInstance(\"EC\", \"BC\");\n\n        algorithmParameters.init(new ECGenParameterSpec(\"P-521\"));\n\n        ECParameterSpec ecSpec = algorithmParameters.getParameterSpec(ECParameterSpec.class);\n        KeyFactory keyFact = KeyFactory.getInstance(\"EC\", \"BC\");\n\n        ECPrivateKey dsCAVS = (ECPrivateKey)keyFact.generatePrivate(new ECPrivateKeySpec(new BigInteger(\"00000179557decd75b797bea9db656ce99c03a6e0ab13804b5b589644f7db41ceba05c3940c300361061074ca72a828428d9198267fa0b75e1e3e785a0ff20e839414be0\", 16), ecSpec));\n        ECPublicKey  qsCAVS = (ECPublicKey)keyFact.generatePublic(new ECPublicKeySpec(new ECPoint(\n                            new BigInteger(\"000001ce7da31681d5f176f3618f205969b9142520363dd26a596866c89988c932e3ce01904d12d1e9b105462e56163dbe7658ba3c472bf1f3c8165813295393ae346764\", 16),\n                            new BigInteger(\"000000e70d6e55b76ebd362ff071ab819315593cec650276209a9fdc2c1c48e03c35945f04e74d958cabd3f5e4d1f096a991e807a8f9d217de306a6b561038ca15aea4b9\", 16)), ecSpec));\n\n        ECPrivateKey dsIUT = (ECPrivateKey)keyFact.generatePrivate(new ECPrivateKeySpec(new BigInteger(\"000000c14895dfcc5a6b24994828cfd0a0cc0a881a70173a3eb05c57b098046c8e60a868f6176284aa346eff1fd1b8b879052c5a6d5fd0ae146b35ed7ecee32e294103cd\", 16), ecSpec));\n        ECPublicKey  qsIUT = (ECPublicKey)keyFact.generatePublic(new ECPublicKeySpec(new ECPoint(\n                            new BigInteger(\"00000174a658695049db59f6bbe2ad23e1753bf58384a56fc9b3dec13eb873b33e1f4dbd24b6b4ca05a9a11ad531f6d99e9430a774980e8a8d9fd2d1e2a0d76fe3dd36c7\", 16),\n                            new BigInteger(\"00000030639849e1df341973db44e7bbba5bb597884a439f9ce54620c3ca73a9804cc26fcda3aaf73ae5a11d5b325cae0e95cfafe1985c6c2fdb892722e7dd2c5d744cf3\", 16)), ecSpec));\n\n        ECPrivateKey deIUT = (ECPrivateKey)keyFact.generatePrivate(new ECPrivateKeySpec(new BigInteger(\"00000138f54e986c7b44f49da389fa9f61bb7265f0cebdeddf09d47c72e55186e2520965fc2c31bb9c0a557e3c28e02a751f097e413c4252c7b0d22452d89f9ac314bc6e\", 16), ecSpec));\n        ECPublicKey  qeIUT = (ECPublicKey)keyFact.generatePublic(new ECPublicKeySpec(new ECPoint(\n            new BigInteger(\"000001b9fbce9c9ebb31070a4a4ac7af54ec9189c1f98948cd24ca0a5029217e4784d3c8692da08a6a512d1c9875d20d8e03664c148fa5d34bbac6d42e499ee5dbf01120\", 16),\n            new BigInteger(\"000000994a714b6d09afa896dbba9b4f436ab3cdb0d11dcd2aad28b7ba35d6fa6be537b6ffb0f9bf5fe1d594b8f8b8829687c9395c3d938c873f26c7100888c3aca2d59a\", 16)), ecSpec));\n\n        KeyAgreement uAgree = KeyAgreement.getInstance(\"ECMQVwithSHA512CKDF\", \"BC\");\n\n        uAgree.init(dsCAVS, new MQVParameterSpec(dsCAVS, qeIUT, Hex.decode(\"a1b2c3d4e54341565369646dbb63a273c81e0aad02f92699bf7baa28fd4509145b0096746894e98e209a85ecb415b8\")));\n\n\n        KeyAgreement vAgree = KeyAgreement.getInstance(\"ECMQVwithSHA512CKDF\", \"BC\");\n        vAgree.init(dsIUT, new MQVParameterSpec(deIUT, qsCAVS, Hex.decode(\"a1b2c3d4e54341565369646dbb63a273c81e0aad02f92699bf7baa28fd4509145b0096746894e98e209a85ecb415b8\")));\n\n        //\n        // agreement\n        //\n        uAgree.doPhase(qsIUT, true);\n        vAgree.doPhase(qsCAVS, true);\n\n        byte[] ux = uAgree.generateSecret(PKCSObjectIdentifiers.id_hmacWithSHA512.getId()).getEncoded();\n        byte[] vx = vAgree.generateSecret(PKCSObjectIdentifiers.id_hmacWithSHA512.getId()).getEncoded();\n\n        if (!Arrays.areEqual(ux, vx))\n        {\n            fail(\"agreement values don't match\");\n        }\n\n        if (!Arrays.areEqual(Hex.decode(\"0744e1774149a8b8f88d3a1e20ac1517efd2f54ba4b5f178de99f33b68eea426\"), Arrays.copyOfRange(ux, 0, 32)))\n        {\n            fail(\"agreement values not correct\");\n        }\n    }\n\n    protected BigInteger[] derDecode(\n        byte[]  encoding)\n        throws IOException\n    {\n        ByteArrayInputStream    bIn = new ByteArrayInputStream(encoding);\n        ASN1InputStream         aIn = new ASN1InputStream(bIn);\n        ASN1Sequence            s = (ASN1Sequence)aIn.readObject();\n\n        BigInteger[]            sig = new BigInteger[2];\n\n        sig[0] = ((ASN1Integer)s.getObjectAt(0)).getValue();\n        sig[1] = ((ASN1Integer)s.getObjectAt(1)).getValue();\n\n        return sig;\n    }\n\n    public String getName()\n    {\n        return \"ECDSA5\";\n    }\n\n    public void performTest()\n        throws Exception\n    {\n        testKeyConversion();\n        testAdaptiveKeyConversion();\n        decodeTest();\n        testECDSA239bitPrime();\n        testECDSA239bitBinary();\n        testGeneration();\n        testKeyPairGenerationWithOIDs();\n        testNamedCurveParameterPreservation();\n        testNamedCurveSigning();\n        testBSI();\n        testMQVwithHMACOnePass();\n        testAlgorithmParameters();\n    }\n\n    public static void main(\n        String[]    args)\n    {\n        Security.addProvider(new BouncyCastleProvider());\n\n        runTest(new ECDSA5Test());\n    }\n}\n"], "fixing_code": ["package org.bouncycastle.asn1;\n\nimport java.io.IOException;\nimport java.math.BigInteger;\n\nimport org.bouncycastle.util.Arrays;\n\n/**\n * Class representing the ASN.1 ENUMERATED type.\n */\npublic class ASN1Enumerated\n    extends ASN1Primitive\n{\n    private final byte[] bytes;\n\n    /**\n     * return an enumerated from the passed in object\n     *\n     * @param obj an ASN1Enumerated or an object that can be converted into one.\n     * @exception IllegalArgumentException if the object cannot be converted.\n     * @return an ASN1Enumerated instance, or null.\n     */\n    public static ASN1Enumerated getInstance(\n        Object  obj)\n    {\n        if (obj == null || obj instanceof ASN1Enumerated)\n        {\n            return (ASN1Enumerated)obj;\n        }\n\n        if (obj instanceof byte[])\n        {\n            try\n            {\n                return (ASN1Enumerated)fromByteArray((byte[])obj);\n            }\n            catch (Exception e)\n            {\n                throw new IllegalArgumentException(\"encoding error in getInstance: \" + e.toString());\n            }\n        }\n\n        throw new IllegalArgumentException(\"illegal object in getInstance: \" + obj.getClass().getName());\n    }\n\n    /**\n     * return an Enumerated from a tagged object.\n     *\n     * @param obj the tagged object holding the object we want\n     * @param explicit true if the object is meant to be explicitly\n     *              tagged false otherwise.\n     * @exception IllegalArgumentException if the tagged object cannot\n     *               be converted.\n     * @return an ASN1Enumerated instance, or null.\n     */\n    public static ASN1Enumerated getInstance(\n        ASN1TaggedObject obj,\n        boolean          explicit)\n    {\n        ASN1Primitive o = obj.getObject();\n\n        if (explicit || o instanceof ASN1Enumerated)\n        {\n            return getInstance(o);\n        }\n        else\n        {\n            return fromOctetString(((ASN1OctetString)o).getOctets());\n        }\n    }\n\n    /**\n     * Constructor from int.\n     *\n     * @param value the value of this enumerated.\n     */\n    public ASN1Enumerated(\n        int         value)\n    {\n        bytes = BigInteger.valueOf(value).toByteArray();\n    }\n\n    /**\n     * Constructor from BigInteger\n     *\n     * @param value the value of this enumerated.\n     */\n    public ASN1Enumerated(\n        BigInteger   value)\n    {\n        bytes = value.toByteArray();\n    }\n\n    /**\n     * Constructor from encoded BigInteger.\n     *\n     * @param bytes the value of this enumerated as an encoded BigInteger (signed).\n     */\n    public ASN1Enumerated(\n        byte[]   bytes)\n    {\n        if (bytes.length > 1)\n        {\n            if (bytes[0] == 0 && (bytes[1] & 0x80) == 0)\n            {\n                throw new IllegalArgumentException(\"malformed enumerated\");\n            }\n            if (bytes[0] == (byte)0xff && (bytes[1] & 0x80) != 0)\n            {\n                throw new IllegalArgumentException(\"malformed enumerated\");\n            }\n        }\n        this.bytes = Arrays.clone(bytes);\n    }\n\n    public BigInteger getValue()\n    {\n        return new BigInteger(bytes);\n    }\n\n    boolean isConstructed()\n    {\n        return false;\n    }\n\n    int encodedLength()\n    {\n        return 1 + StreamUtil.calculateBodyLength(bytes.length) + bytes.length;\n    }\n\n    void encode(\n        ASN1OutputStream out)\n        throws IOException\n    {\n        out.writeEncoded(BERTags.ENUMERATED, bytes);\n    }\n    \n    boolean asn1Equals(\n        ASN1Primitive  o)\n    {\n        if (!(o instanceof ASN1Enumerated))\n        {\n            return false;\n        }\n\n        ASN1Enumerated other = (ASN1Enumerated)o;\n\n        return Arrays.areEqual(this.bytes, other.bytes);\n    }\n\n    public int hashCode()\n    {\n        return Arrays.hashCode(bytes);\n    }\n\n    private static ASN1Enumerated[] cache = new ASN1Enumerated[12];\n\n    static ASN1Enumerated fromOctetString(byte[] enc)\n    {\n        if (enc.length > 1)\n        {\n            return new ASN1Enumerated(enc);\n        }\n\n        if (enc.length == 0)\n        {\n            throw new IllegalArgumentException(\"ENUMERATED has zero length\");\n        }\n        int value = enc[0] & 0xff;\n\n        if (value >= cache.length)\n        {\n            return new ASN1Enumerated(Arrays.clone(enc));\n        }\n\n        ASN1Enumerated possibleMatch = cache[value];\n\n        if (possibleMatch == null)\n        {\n            possibleMatch = cache[value] = new ASN1Enumerated(Arrays.clone(enc));\n        }\n\n        return possibleMatch;\n    }\n}\n", "package org.bouncycastle.asn1;\n\nimport java.io.IOException;\nimport java.math.BigInteger;\n\nimport org.bouncycastle.util.Arrays;\n\n/**\n * Class representing the ASN.1 INTEGER type.\n */\npublic class ASN1Integer\n    extends ASN1Primitive\n{\n    private final byte[] bytes;\n\n    /**\n     * return an integer from the passed in object\n     *\n     * @param obj an ASN1Integer or an object that can be converted into one.\n     * @throws IllegalArgumentException if the object cannot be converted.\n     * @return an ASN1Integer instance.\n     */\n    public static ASN1Integer getInstance(\n        Object obj)\n    {\n        if (obj == null || obj instanceof ASN1Integer)\n        {\n            return (ASN1Integer)obj;\n        }\n\n        if (obj instanceof byte[])\n        {\n            try\n            {\n                return (ASN1Integer)fromByteArray((byte[])obj);\n            }\n            catch (Exception e)\n            {\n                throw new IllegalArgumentException(\"encoding error in getInstance: \" + e.toString());\n            }\n        }\n\n        throw new IllegalArgumentException(\"illegal object in getInstance: \" + obj.getClass().getName());\n    }\n\n    /**\n     * return an Integer from a tagged object.\n     *\n     * @param obj      the tagged object holding the object we want\n     * @param explicit true if the object is meant to be explicitly\n     *                 tagged false otherwise.\n     * @throws IllegalArgumentException if the tagged object cannot\n     * be converted.\n     * @return an ASN1Integer instance.\n     */\n    public static ASN1Integer getInstance(\n        ASN1TaggedObject obj,\n        boolean explicit)\n    {\n        ASN1Primitive o = obj.getObject();\n\n        if (explicit || o instanceof ASN1Integer)\n        {\n            return getInstance(o);\n        }\n        else\n        {\n            return new ASN1Integer(ASN1OctetString.getInstance(obj.getObject()).getOctets());\n        }\n    }\n\n    public ASN1Integer(\n        long value)\n    {\n        bytes = BigInteger.valueOf(value).toByteArray();\n    }\n\n    public ASN1Integer(\n        BigInteger value)\n    {\n        bytes = value.toByteArray();\n    }\n\n    public ASN1Integer(\n        byte[] bytes)\n    {\n        this(bytes, true);\n    }\n\n    ASN1Integer(byte[] bytes, boolean clone)\n    {\n        if (bytes.length > 1)\n        {\n            if (bytes[0] == 0 && (bytes[1] & 0x80) == 0)\n            {\n                throw new IllegalArgumentException(\"malformed integer\");\n            }\n            if (bytes[0] == (byte)0xff && (bytes[1] & 0x80) != 0)\n            {\n                throw new IllegalArgumentException(\"malformed integer\");\n            }\n        }\n        this.bytes = (clone) ? Arrays.clone(bytes) : bytes;\n    }\n\n    public BigInteger getValue()\n    {\n        return new BigInteger(bytes);\n    }\n\n    /**\n     * in some cases positive values get crammed into a space,\n     * that's not quite big enough...\n     * @return the BigInteger that results from treating this ASN.1 INTEGER as unsigned.\n     */\n    public BigInteger getPositiveValue()\n    {\n        return new BigInteger(1, bytes);\n    }\n\n    boolean isConstructed()\n    {\n        return false;\n    }\n\n    int encodedLength()\n    {\n        return 1 + StreamUtil.calculateBodyLength(bytes.length) + bytes.length;\n    }\n\n    void encode(\n        ASN1OutputStream out)\n        throws IOException\n    {\n        out.writeEncoded(BERTags.INTEGER, bytes);\n    }\n\n    public int hashCode()\n    {\n        int value = 0;\n\n        for (int i = 0; i != bytes.length; i++)\n        {\n            value ^= (bytes[i] & 0xff) << (i % 4);\n        }\n\n        return value;\n    }\n\n    boolean asn1Equals(\n        ASN1Primitive o)\n    {\n        if (!(o instanceof ASN1Integer))\n        {\n            return false;\n        }\n\n        ASN1Integer other = (ASN1Integer)o;\n\n        return Arrays.areEqual(bytes, other.bytes);\n    }\n\n    public String toString()\n    {\n        return getValue().toString();\n    }\n\n}\n", "package org.bouncycastle.asn1.test;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\n\nimport org.bouncycastle.asn1.ASN1Encodable;\nimport org.bouncycastle.asn1.ASN1Enumerated;\nimport org.bouncycastle.asn1.ASN1InputStream;\nimport org.bouncycastle.asn1.ASN1Integer;\nimport org.bouncycastle.asn1.ASN1OutputStream;\nimport org.bouncycastle.asn1.ASN1Primitive;\nimport org.bouncycastle.asn1.BERSequence;\nimport org.bouncycastle.asn1.DERBitString;\nimport org.bouncycastle.asn1.DERIA5String;\nimport org.bouncycastle.asn1.misc.CAST5CBCParameters;\nimport org.bouncycastle.asn1.misc.IDEACBCPar;\nimport org.bouncycastle.asn1.misc.NetscapeCertType;\nimport org.bouncycastle.asn1.misc.NetscapeRevocationURL;\nimport org.bouncycastle.asn1.misc.VerisignCzagExtension;\nimport org.bouncycastle.util.Arrays;\nimport org.bouncycastle.util.encoders.Base64;\nimport org.bouncycastle.util.test.SimpleTest;\n\npublic class MiscTest\n    extends SimpleTest\n{\n    private boolean isSameAs(\n        byte[]  a,\n        byte[]  b)\n    {\n        if (a.length != b.length)\n        {\n            return false;\n        }\n        \n        for (int i = 0; i != a.length; i++)\n        {\n            if (a[i] != b[i])\n            {\n                return false;\n            }\n        }\n        \n        return true;\n    }\n\n    public void shouldFailOnExtraData()\n        throws Exception\n    {\n        // basic construction\n        DERBitString s1 = new DERBitString(new byte[0], 0);\n\n        ASN1Primitive.fromByteArray(s1.getEncoded());\n\n        ASN1Primitive.fromByteArray(new BERSequence(s1).getEncoded());\n\n        try\n        {\n            ASN1Primitive obj = ASN1Primitive.fromByteArray(Arrays.concatenate(s1.getEncoded(), new byte[1]));\n            fail(\"no exception\");\n        }\n        catch (IOException e)\n        {\n            if (!\"Extra data detected in stream\".equals(e.getMessage()))\n            {\n                fail(\"wrong exception\");\n            }\n        }\n    }\n\n    public void derIntegerTest()\n        throws Exception\n    {\n        try\n        {\n            new ASN1Integer(new byte[] { 0, 0, 0, 1});\n        }\n        catch (IllegalArgumentException e)\n        {\n            isTrue(\"wrong exc\", \"malformed integer\".equals(e.getMessage()));\n        }\n\n        try\n        {\n            new ASN1Integer(new byte[] {(byte)0xff, (byte)0x80, 0, 1});\n        }\n        catch (IllegalArgumentException e)\n        {\n            isTrue(\"wrong exc\", \"malformed integer\".equals(e.getMessage()));\n        }\n\n        try\n        {\n            new ASN1Enumerated(new byte[] { 0, 0, 0, 1});\n        }\n        catch (IllegalArgumentException e)\n        {\n            isTrue(\"wrong exc\", \"malformed enumerated\".equals(e.getMessage()));\n        }\n\n        try\n        {\n            new ASN1Enumerated(new byte[] {(byte)0xff, (byte)0x80, 0, 1});\n        }\n        catch (IllegalArgumentException e)\n        {\n            isTrue(\"wrong exc\", \"malformed enumerated\".equals(e.getMessage()));\n        }\n    }\n\n    public void performTest()\n        throws Exception\n    {\n        byte[]  testIv = { 1, 2, 3, 4, 5, 6, 7, 8 };\n        \n        ASN1Encodable[]     values = {\n            new CAST5CBCParameters(testIv, 128), \n            new NetscapeCertType(NetscapeCertType.smime),    \n            new VerisignCzagExtension(new DERIA5String(\"hello\")),\n            new IDEACBCPar(testIv),        \n            new NetscapeRevocationURL(new DERIA5String(\"http://test\"))\n        };\n        \n        byte[] data = Base64.decode(\"MA4ECAECAwQFBgcIAgIAgAMCBSAWBWhlbGxvMAoECAECAwQFBgcIFgtodHRwOi8vdGVzdA==\");\n\n        ByteArrayOutputStream bOut = new ByteArrayOutputStream();\n        ASN1OutputStream aOut = new ASN1OutputStream(bOut);\n\n        for (int i = 0; i != values.length; i++)\n        {\n            aOut.writeObject(values[i]);\n        }\n\n        ASN1Primitive[] readValues = new ASN1Primitive[values.length];\n\n        if (!isSameAs(bOut.toByteArray(), data))\n        {\n            fail(\"Failed data check\");\n        }\n\n        ByteArrayInputStream bIn = new ByteArrayInputStream(bOut.toByteArray());\n        ASN1InputStream aIn = new ASN1InputStream(bIn);\n\n        for (int i = 0; i != values.length; i++)\n        {\n            ASN1Primitive o = aIn.readObject();\n            if (!values[i].equals(o))\n            {\n                fail(\"Failed equality test for \" + o);\n            }\n\n            if (o.hashCode() != values[i].hashCode())\n            {\n                fail(\"Failed hashCode test for \" + o);\n            }\n        }\n\n        shouldFailOnExtraData();\n        derIntegerTest();\n    }\n\n    public String getName()\n    {\n        return \"Misc\";\n    }\n\n    public static void main(\n        String[] args)\n    {\n        runTest(new MiscTest());\n    }\n}\n", "package org.bouncycastle.jcajce.provider.asymmetric.dsa;\n\nimport java.io.IOException;\nimport java.math.BigInteger;\nimport java.security.InvalidKeyException;\nimport java.security.PrivateKey;\nimport java.security.PublicKey;\nimport java.security.SecureRandom;\nimport java.security.SignatureException;\nimport java.security.SignatureSpi;\nimport java.security.spec.AlgorithmParameterSpec;\n\nimport org.bouncycastle.asn1.ASN1Encoding;\nimport org.bouncycastle.asn1.ASN1Integer;\nimport org.bouncycastle.asn1.ASN1Primitive;\nimport org.bouncycastle.asn1.ASN1Sequence;\nimport org.bouncycastle.asn1.DERSequence;\nimport org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers;\nimport org.bouncycastle.asn1.x509.X509ObjectIdentifiers;\nimport org.bouncycastle.crypto.CipherParameters;\nimport org.bouncycastle.crypto.DSA;\nimport org.bouncycastle.crypto.Digest;\nimport org.bouncycastle.crypto.digests.NullDigest;\nimport org.bouncycastle.crypto.digests.SHA1Digest;\nimport org.bouncycastle.crypto.digests.SHA224Digest;\nimport org.bouncycastle.crypto.digests.SHA256Digest;\nimport org.bouncycastle.crypto.digests.SHA384Digest;\nimport org.bouncycastle.crypto.digests.SHA3Digest;\nimport org.bouncycastle.crypto.digests.SHA512Digest;\nimport org.bouncycastle.crypto.params.ParametersWithRandom;\nimport org.bouncycastle.crypto.signers.HMacDSAKCalculator;\nimport org.bouncycastle.util.Arrays;\n\npublic class DSASigner\n    extends SignatureSpi\n    implements PKCSObjectIdentifiers, X509ObjectIdentifiers\n{\n    private Digest                  digest;\n    private DSA                     signer;\n    private SecureRandom            random;\n\n    protected DSASigner(\n        Digest digest,\n        DSA signer)\n    {\n        this.digest = digest;\n        this.signer = signer;\n    }\n\n    protected void engineInitVerify(\n        PublicKey   publicKey)\n        throws InvalidKeyException\n    {\n        CipherParameters    param = DSAUtil.generatePublicKeyParameter(publicKey);\n\n        digest.reset();\n        signer.init(false, param);\n    }\n\n    protected void engineInitSign(\n        PrivateKey      privateKey,\n        SecureRandom    random)\n        throws InvalidKeyException\n    {\n        this.random = random;\n        engineInitSign(privateKey);\n    }\n\n    protected void engineInitSign(\n        PrivateKey  privateKey)\n        throws InvalidKeyException\n    {\n        CipherParameters    param = DSAUtil.generatePrivateKeyParameter(privateKey);\n\n        if (random != null)\n        {\n            param = new ParametersWithRandom(param, random);\n        }\n\n        digest.reset();\n        signer.init(true, param);\n    }\n\n    protected void engineUpdate(\n        byte    b)\n        throws SignatureException\n    {\n        digest.update(b);\n    }\n\n    protected void engineUpdate(\n        byte[]  b,\n        int     off,\n        int     len) \n        throws SignatureException\n    {\n        digest.update(b, off, len);\n    }\n\n    protected byte[] engineSign()\n        throws SignatureException\n    {\n        byte[]  hash = new byte[digest.getDigestSize()];\n\n        digest.doFinal(hash, 0);\n\n        try\n        {\n            BigInteger[]    sig = signer.generateSignature(hash);\n\n            return derEncode(sig[0], sig[1]);\n        }\n        catch (Exception e)\n        {\n            throw new SignatureException(e.toString());\n        }\n    }\n\n    protected boolean engineVerify(\n        byte[]  sigBytes) \n        throws SignatureException\n    {\n        byte[]  hash = new byte[digest.getDigestSize()];\n\n        digest.doFinal(hash, 0);\n\n        BigInteger[]    sig;\n\n        try\n        {\n            sig = derDecode(sigBytes);\n        }\n        catch (Exception e)\n        {\n            throw new SignatureException(\"error decoding signature bytes.\");\n        }\n\n        return signer.verifySignature(hash, sig[0], sig[1]);\n    }\n\n    protected void engineSetParameter(\n        AlgorithmParameterSpec params)\n    {\n        throw new UnsupportedOperationException(\"engineSetParameter unsupported\");\n    }\n\n    /**\n     * @deprecated replaced with <a href = \"#engineSetParameter(java.security.spec.AlgorithmParameterSpec)\">\n     */\n    protected void engineSetParameter(\n        String  param,\n        Object  value)\n    {\n        throw new UnsupportedOperationException(\"engineSetParameter unsupported\");\n    }\n\n    /**\n     * @deprecated\n     */\n    protected Object engineGetParameter(\n        String      param)\n    {\n        throw new UnsupportedOperationException(\"engineSetParameter unsupported\");\n    }\n\n    private byte[] derEncode(\n        BigInteger  r,\n        BigInteger  s)\n        throws IOException\n    {\n        ASN1Integer[] rs = new ASN1Integer[]{ new ASN1Integer(r), new ASN1Integer(s) };\n        return new DERSequence(rs).getEncoded(ASN1Encoding.DER);\n    }\n\n    private BigInteger[] derDecode(\n        byte[]  encoding)\n        throws IOException\n    {\n        ASN1Sequence s = (ASN1Sequence)ASN1Primitive.fromByteArray(encoding);\n        if (s.size() != 2)\n        {\n            throw new IOException(\"malformed signature\");\n        }\n        if (!Arrays.areEqual(encoding, s.getEncoded(ASN1Encoding.DER)))\n        {\n            throw new IOException(\"malformed signature\");\n        }\n\n        return new BigInteger[]{\n            ((ASN1Integer)s.getObjectAt(0)).getValue(),\n            ((ASN1Integer)s.getObjectAt(1)).getValue()\n        };\n    }\n\n    static public class stdDSA\n        extends DSASigner\n    {\n        public stdDSA()\n        {\n            super(new SHA1Digest(), new org.bouncycastle.crypto.signers.DSASigner());\n        }\n    }\n\n    static public class detDSA\n        extends DSASigner\n    {\n        public detDSA()\n        {\n            super(new SHA1Digest(), new org.bouncycastle.crypto.signers.DSASigner(new HMacDSAKCalculator(new SHA1Digest())));\n        }\n    }\n\n    static public class dsa224\n        extends DSASigner\n    {\n        public dsa224()\n        {\n            super(new SHA224Digest(), new org.bouncycastle.crypto.signers.DSASigner());\n        }\n    }\n\n    static public class detDSA224\n        extends DSASigner\n    {\n        public detDSA224()\n        {\n            super(new SHA224Digest(), new org.bouncycastle.crypto.signers.DSASigner(new HMacDSAKCalculator(new SHA224Digest())));\n        }\n    }\n\n    static public class dsa256\n        extends DSASigner\n    {\n        public dsa256()\n        {\n            super(new SHA256Digest(), new org.bouncycastle.crypto.signers.DSASigner());\n        }\n    }\n\n    static public class detDSA256\n        extends DSASigner\n    {\n        public detDSA256()\n        {\n            super(new SHA256Digest(), new org.bouncycastle.crypto.signers.DSASigner(new HMacDSAKCalculator(new SHA256Digest())));\n        }\n    }\n\n    static public class dsa384\n        extends DSASigner\n    {\n        public dsa384()\n        {\n            super(new SHA384Digest(), new org.bouncycastle.crypto.signers.DSASigner());\n        }\n    }\n\n    static public class detDSA384\n        extends DSASigner\n    {\n        public detDSA384()\n        {\n            super(new SHA384Digest(), new org.bouncycastle.crypto.signers.DSASigner(new HMacDSAKCalculator(new SHA384Digest())));\n        }\n    }\n\n    static public class dsa512\n        extends DSASigner\n    {\n        public dsa512()\n        {\n            super(new SHA512Digest(), new org.bouncycastle.crypto.signers.DSASigner());\n        }\n    }\n\n    static public class detDSA512\n        extends DSASigner\n    {\n        public detDSA512()\n        {\n            super(new SHA512Digest(), new org.bouncycastle.crypto.signers.DSASigner(new HMacDSAKCalculator(new SHA512Digest())));\n        }\n    }\n\n    static public class dsaSha3_224\n        extends DSASigner\n    {\n        public dsaSha3_224()\n        {\n            super(new SHA3Digest(224), new org.bouncycastle.crypto.signers.DSASigner());\n        }\n    }\n\n    static public class detDSASha3_224\n        extends DSASigner\n    {\n        public detDSASha3_224()\n        {\n            super(new SHA3Digest(224), new org.bouncycastle.crypto.signers.DSASigner(new HMacDSAKCalculator(new SHA3Digest(224))));\n        }\n    }\n\n    static public class dsaSha3_256\n        extends DSASigner\n    {\n        public dsaSha3_256()\n        {\n            super(new SHA3Digest(256), new org.bouncycastle.crypto.signers.DSASigner());\n        }\n    }\n\n    static public class detDSASha3_256\n        extends DSASigner\n    {\n        public detDSASha3_256()\n        {\n            super(new SHA3Digest(256), new org.bouncycastle.crypto.signers.DSASigner(new HMacDSAKCalculator(new SHA3Digest(256))));\n        }\n    }\n\n    static public class dsaSha3_384\n        extends DSASigner\n    {\n        public dsaSha3_384()\n        {\n            super(new SHA3Digest(384), new org.bouncycastle.crypto.signers.DSASigner());\n        }\n    }\n\n    static public class detDSASha3_384\n        extends DSASigner\n    {\n        public detDSASha3_384()\n        {\n            super(new SHA3Digest(384), new org.bouncycastle.crypto.signers.DSASigner(new HMacDSAKCalculator(new SHA3Digest(384))));\n        }\n    }\n\n    static public class dsaSha3_512\n        extends DSASigner\n    {\n        public dsaSha3_512()\n        {\n            super(new SHA3Digest(512), new org.bouncycastle.crypto.signers.DSASigner());\n        }\n    }\n\n    static public class detDSASha3_512\n        extends DSASigner\n    {\n        public detDSASha3_512()\n        {\n            super(new SHA3Digest(512), new org.bouncycastle.crypto.signers.DSASigner(new HMacDSAKCalculator(new SHA3Digest(512))));\n        }\n    }\n\n    static public class noneDSA\n        extends DSASigner\n    {\n        public noneDSA()\n        {\n            super(new NullDigest(), new org.bouncycastle.crypto.signers.DSASigner());\n        }\n    }\n}\n", "package org.bouncycastle.jcajce.provider.asymmetric.ec;\n\nimport java.io.IOException;\nimport java.math.BigInteger;\nimport java.security.InvalidKeyException;\nimport java.security.PrivateKey;\nimport java.security.PublicKey;\n\nimport org.bouncycastle.asn1.ASN1EncodableVector;\nimport org.bouncycastle.asn1.ASN1Encoding;\nimport org.bouncycastle.asn1.ASN1Integer;\nimport org.bouncycastle.asn1.ASN1Primitive;\nimport org.bouncycastle.asn1.ASN1Sequence;\nimport org.bouncycastle.asn1.DERSequence;\nimport org.bouncycastle.crypto.CipherParameters;\nimport org.bouncycastle.crypto.DSA;\nimport org.bouncycastle.crypto.Digest;\nimport org.bouncycastle.crypto.digests.NullDigest;\nimport org.bouncycastle.crypto.digests.RIPEMD160Digest;\nimport org.bouncycastle.crypto.digests.SHA1Digest;\nimport org.bouncycastle.crypto.digests.SHA224Digest;\nimport org.bouncycastle.crypto.digests.SHA256Digest;\nimport org.bouncycastle.crypto.digests.SHA384Digest;\nimport org.bouncycastle.crypto.digests.SHA3Digest;\nimport org.bouncycastle.crypto.digests.SHA512Digest;\nimport org.bouncycastle.crypto.params.ParametersWithRandom;\nimport org.bouncycastle.crypto.signers.ECDSASigner;\nimport org.bouncycastle.crypto.signers.ECNRSigner;\nimport org.bouncycastle.crypto.signers.HMacDSAKCalculator;\nimport org.bouncycastle.jcajce.provider.asymmetric.util.DSABase;\nimport org.bouncycastle.jcajce.provider.asymmetric.util.DSAEncoder;\nimport org.bouncycastle.jcajce.provider.asymmetric.util.ECUtil;\nimport org.bouncycastle.util.Arrays;\n\npublic class SignatureSpi\n    extends DSABase\n{\n    SignatureSpi(Digest digest, DSA signer, DSAEncoder encoder)\n    {\n        super(digest, signer, encoder);\n    }\n\n    protected void engineInitVerify(PublicKey publicKey)\n        throws InvalidKeyException\n    {\n        CipherParameters param = ECUtils.generatePublicKeyParameter(publicKey);\n\n        digest.reset();\n        signer.init(false, param);\n    }\n\n    protected void engineInitSign(\n        PrivateKey privateKey)\n        throws InvalidKeyException\n    {\n        CipherParameters param = ECUtil.generatePrivateKeyParameter(privateKey);\n\n        digest.reset();\n\n        if (appRandom != null)\n        {\n            signer.init(true, new ParametersWithRandom(param, appRandom));\n        }\n        else\n        {\n            signer.init(true, param);\n        }\n    }\n\n    static public class ecDSA\n        extends SignatureSpi\n    {\n        public ecDSA()\n        {\n            super(new SHA1Digest(), new ECDSASigner(), new StdDSAEncoder());\n        }\n    }\n\n    static public class ecDetDSA\n        extends SignatureSpi\n    {\n        public ecDetDSA()\n        {\n            super(new SHA1Digest(), new ECDSASigner(new HMacDSAKCalculator(new SHA1Digest())), new StdDSAEncoder());\n        }\n    }\n\n    static public class ecDSAnone\n        extends SignatureSpi\n    {\n        public ecDSAnone()\n        {\n            super(new NullDigest(), new ECDSASigner(), new StdDSAEncoder());\n        }\n    }\n\n    static public class ecDSA224\n        extends SignatureSpi\n    {\n        public ecDSA224()\n        {\n            super(new SHA224Digest(), new ECDSASigner(), new StdDSAEncoder());\n        }\n    }\n\n    static public class ecDetDSA224\n        extends SignatureSpi\n    {\n        public ecDetDSA224()\n        {\n            super(new SHA224Digest(), new ECDSASigner(new HMacDSAKCalculator(new SHA224Digest())), new StdDSAEncoder());\n        }\n    }\n\n    static public class ecDSA256\n        extends SignatureSpi\n    {\n        public ecDSA256()\n        {\n            super(new SHA256Digest(), new ECDSASigner(), new StdDSAEncoder());\n        }\n    }\n\n    static public class ecDetDSA256\n        extends SignatureSpi\n    {\n        public ecDetDSA256()\n        {\n            super(new SHA256Digest(), new ECDSASigner(new HMacDSAKCalculator(new SHA256Digest())), new StdDSAEncoder());\n        }\n    }\n\n    static public class ecDSA384\n        extends SignatureSpi\n    {\n        public ecDSA384()\n        {\n            super(new SHA384Digest(), new ECDSASigner(), new StdDSAEncoder());\n        }\n    }\n\n    static public class ecDetDSA384\n        extends SignatureSpi\n    {\n        public ecDetDSA384()\n        {\n            super(new SHA384Digest(), new ECDSASigner(new HMacDSAKCalculator(new SHA384Digest())), new StdDSAEncoder());\n        }\n    }\n\n    static public class ecDSA512\n        extends SignatureSpi\n    {\n        public ecDSA512()\n        {\n            super(new SHA512Digest(), new ECDSASigner(), new StdDSAEncoder());\n        }\n    }\n\n    static public class ecDetDSA512\n        extends SignatureSpi\n    {\n        public ecDetDSA512()\n        {\n            super(new SHA512Digest(), new ECDSASigner(new HMacDSAKCalculator(new SHA512Digest())), new StdDSAEncoder());\n        }\n    }\n\n    static public class ecDSASha3_224\n        extends SignatureSpi\n    {\n        public ecDSASha3_224()\n        {\n            super(new SHA3Digest(224), new ECDSASigner(), new StdDSAEncoder());\n        }\n    }\n\n    static public class ecDetDSASha3_224\n        extends SignatureSpi\n    {\n        public ecDetDSASha3_224()\n        {\n            super(new SHA3Digest(224), new ECDSASigner(new HMacDSAKCalculator(new SHA3Digest(224))), new StdDSAEncoder());\n        }\n    }\n\n    static public class ecDSASha3_256\n        extends SignatureSpi\n    {\n        public ecDSASha3_256()\n        {\n            super(new SHA3Digest(256), new ECDSASigner(), new StdDSAEncoder());\n        }\n    }\n\n    static public class ecDetDSASha3_256\n        extends SignatureSpi\n    {\n        public ecDetDSASha3_256()\n        {\n            super(new SHA3Digest(256), new ECDSASigner(new HMacDSAKCalculator(new SHA3Digest(256))), new StdDSAEncoder());\n        }\n    }\n\n    static public class ecDSASha3_384\n        extends SignatureSpi\n    {\n        public ecDSASha3_384()\n        {\n            super(new SHA3Digest(384), new ECDSASigner(), new StdDSAEncoder());\n        }\n    }\n\n    static public class ecDetDSASha3_384\n        extends SignatureSpi\n    {\n        public ecDetDSASha3_384()\n        {\n            super(new SHA3Digest(384), new ECDSASigner(new HMacDSAKCalculator(new SHA3Digest(384))), new StdDSAEncoder());\n        }\n    }\n\n    static public class ecDSASha3_512\n        extends SignatureSpi\n    {\n        public ecDSASha3_512()\n        {\n            super(new SHA3Digest(512), new ECDSASigner(), new StdDSAEncoder());\n        }\n    }\n\n    static public class ecDetDSASha3_512\n        extends SignatureSpi\n    {\n        public ecDetDSASha3_512()\n        {\n            super(new SHA3Digest(512), new ECDSASigner(new HMacDSAKCalculator(new SHA3Digest(512))), new StdDSAEncoder());\n        }\n    }\n\n    static public class ecDSARipeMD160\n        extends SignatureSpi\n    {\n        public ecDSARipeMD160()\n        {\n            super(new RIPEMD160Digest(), new ECDSASigner(), new StdDSAEncoder());\n        }\n    }\n\n    static public class ecNR\n        extends SignatureSpi\n    {\n        public ecNR()\n        {\n            super(new SHA1Digest(), new ECNRSigner(), new StdDSAEncoder());\n        }\n    }\n\n    static public class ecNR224\n        extends SignatureSpi\n    {\n        public ecNR224()\n        {\n            super(new SHA224Digest(), new ECNRSigner(), new StdDSAEncoder());\n        }\n    }\n\n    static public class ecNR256\n        extends SignatureSpi\n    {\n        public ecNR256()\n        {\n            super(new SHA256Digest(), new ECNRSigner(), new StdDSAEncoder());\n        }\n    }\n\n    static public class ecNR384\n        extends SignatureSpi\n    {\n        public ecNR384()\n        {\n            super(new SHA384Digest(), new ECNRSigner(), new StdDSAEncoder());\n        }\n    }\n\n    static public class ecNR512\n        extends SignatureSpi\n    {\n        public ecNR512()\n        {\n            super(new SHA512Digest(), new ECNRSigner(), new StdDSAEncoder());\n        }\n    }\n\n    static public class ecCVCDSA\n        extends SignatureSpi\n    {\n        public ecCVCDSA()\n        {\n            super(new SHA1Digest(), new ECDSASigner(), new PlainDSAEncoder());\n        }\n    }\n\n    static public class ecCVCDSA224\n        extends SignatureSpi\n    {\n        public ecCVCDSA224()\n        {\n            super(new SHA224Digest(), new ECDSASigner(), new PlainDSAEncoder());\n        }\n    }\n\n    static public class ecCVCDSA256\n        extends SignatureSpi\n    {\n        public ecCVCDSA256()\n        {\n            super(new SHA256Digest(), new ECDSASigner(), new PlainDSAEncoder());\n        }\n    }\n\n    static public class ecCVCDSA384\n        extends SignatureSpi\n    {\n        public ecCVCDSA384()\n        {\n            super(new SHA384Digest(), new ECDSASigner(), new PlainDSAEncoder());\n        }\n    }\n\n    static public class ecCVCDSA512\n        extends SignatureSpi\n    {\n        public ecCVCDSA512()\n        {\n            super(new SHA512Digest(), new ECDSASigner(), new PlainDSAEncoder());\n        }\n    }\n\n    static public class ecPlainDSARP160\n        extends SignatureSpi\n    {\n        public ecPlainDSARP160()\n        {\n            super(new RIPEMD160Digest(), new ECDSASigner(), new PlainDSAEncoder());\n        }\n    }\n\n    private static class StdDSAEncoder\n        implements DSAEncoder\n    {\n        public byte[] encode(\n            BigInteger r,\n            BigInteger s)\n            throws IOException\n        {\n            ASN1EncodableVector v = new ASN1EncodableVector();\n\n            v.add(new ASN1Integer(r));\n            v.add(new ASN1Integer(s));\n\n            return new DERSequence(v).getEncoded(ASN1Encoding.DER);\n        }\n\n        public BigInteger[] decode(\n            byte[] encoding)\n            throws IOException\n        {\n            ASN1Sequence s = (ASN1Sequence)ASN1Primitive.fromByteArray(encoding);\n            if (s.size() != 2)\n            {\n                throw new IOException(\"malformed signature\");\n            }\n            if (!Arrays.areEqual(encoding, s.getEncoded(ASN1Encoding.DER)))\n            {\n                throw new IOException(\"malformed signature\");\n            }\n\n            BigInteger[] sig = new BigInteger[2];\n\n            sig[0] = ASN1Integer.getInstance(s.getObjectAt(0)).getValue();\n            sig[1] = ASN1Integer.getInstance(s.getObjectAt(1)).getValue();\n\n            return sig;\n        }\n    }\n\n    private static class PlainDSAEncoder\n        implements DSAEncoder\n    {\n        public byte[] encode(\n            BigInteger r,\n            BigInteger s)\n            throws IOException\n        {\n            byte[] first = makeUnsigned(r);\n            byte[] second = makeUnsigned(s);\n            byte[] res;\n\n            if (first.length > second.length)\n            {\n                res = new byte[first.length * 2];\n            }\n            else\n            {\n                res = new byte[second.length * 2];\n            }\n\n            System.arraycopy(first, 0, res, res.length / 2 - first.length, first.length);\n            System.arraycopy(second, 0, res, res.length - second.length, second.length);\n\n            return res;\n        }\n\n\n        private byte[] makeUnsigned(BigInteger val)\n        {\n            byte[] res = val.toByteArray();\n\n            if (res[0] == 0)\n            {\n                byte[] tmp = new byte[res.length - 1];\n\n                System.arraycopy(res, 1, tmp, 0, tmp.length);\n\n                return tmp;\n            }\n\n            return res;\n        }\n\n        public BigInteger[] decode(\n            byte[] encoding)\n            throws IOException\n        {\n            BigInteger[] sig = new BigInteger[2];\n\n            byte[] first = new byte[encoding.length / 2];\n            byte[] second = new byte[encoding.length / 2];\n\n            System.arraycopy(encoding, 0, first, 0, first.length);\n            System.arraycopy(encoding, first.length, second, 0, second.length);\n\n            sig[0] = new BigInteger(1, first);\n            sig[1] = new BigInteger(1, second);\n\n            return sig;\n        }\n    }\n}", "package org.bouncycastle.jce.provider.test;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.math.BigInteger;\nimport java.security.AlgorithmParameterGenerator;\nimport java.security.AlgorithmParameters;\nimport java.security.InvalidKeyException;\nimport java.security.KeyFactory;\nimport java.security.KeyPair;\nimport java.security.KeyPairGenerator;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.NoSuchProviderException;\nimport java.security.PrivateKey;\nimport java.security.PublicKey;\nimport java.security.SecureRandom;\nimport java.security.Security;\nimport java.security.Signature;\nimport java.security.SignatureException;\nimport java.security.interfaces.DSAPrivateKey;\nimport java.security.interfaces.DSAPublicKey;\nimport java.security.spec.DSAParameterSpec;\nimport java.security.spec.DSAPrivateKeySpec;\nimport java.security.spec.DSAPublicKeySpec;\nimport java.security.spec.InvalidKeySpecException;\nimport java.security.spec.PKCS8EncodedKeySpec;\nimport java.security.spec.X509EncodedKeySpec;\n\nimport org.bouncycastle.asn1.ASN1InputStream;\nimport org.bouncycastle.asn1.ASN1Integer;\nimport org.bouncycastle.asn1.ASN1ObjectIdentifier;\nimport org.bouncycastle.asn1.ASN1Primitive;\nimport org.bouncycastle.asn1.ASN1Sequence;\nimport org.bouncycastle.asn1.eac.EACObjectIdentifiers;\nimport org.bouncycastle.asn1.nist.NISTNamedCurves;\nimport org.bouncycastle.asn1.nist.NISTObjectIdentifiers;\nimport org.bouncycastle.asn1.teletrust.TeleTrusTObjectIdentifiers;\nimport org.bouncycastle.asn1.x509.AlgorithmIdentifier;\nimport org.bouncycastle.asn1.x509.SubjectPublicKeyInfo;\nimport org.bouncycastle.asn1.x9.X9ECParameters;\nimport org.bouncycastle.asn1.x9.X9ObjectIdentifiers;\nimport org.bouncycastle.crypto.params.DSAParameters;\nimport org.bouncycastle.crypto.params.DSAPublicKeyParameters;\nimport org.bouncycastle.crypto.params.ECDomainParameters;\nimport org.bouncycastle.crypto.signers.DSASigner;\nimport org.bouncycastle.jce.interfaces.PKCS12BagAttributeCarrier;\nimport org.bouncycastle.jce.provider.BouncyCastleProvider;\nimport org.bouncycastle.jce.spec.ECNamedCurveGenParameterSpec;\nimport org.bouncycastle.jce.spec.ECParameterSpec;\nimport org.bouncycastle.jce.spec.ECPrivateKeySpec;\nimport org.bouncycastle.jce.spec.ECPublicKeySpec;\nimport org.bouncycastle.math.ec.ECCurve;\nimport org.bouncycastle.util.Arrays;\nimport org.bouncycastle.util.BigIntegers;\nimport org.bouncycastle.util.Strings;\nimport org.bouncycastle.util.encoders.Hex;\nimport org.bouncycastle.util.test.FixedSecureRandom;\nimport org.bouncycastle.util.test.SimpleTest;\nimport org.bouncycastle.util.test.TestRandomBigInteger;\nimport org.bouncycastle.util.test.TestRandomData;\n\npublic class DSATest\n    extends SimpleTest\n{\n    byte[] k1 = Hex.decode(\"d5014e4b60ef2ba8b6211b4062ba3224e0427dd3\");\n    byte[] k2 = Hex.decode(\"345e8d05c075c3a508df729a1685690e68fcfb8c8117847e89063bca1f85d968fd281540b6e13bd1af989a1fbf17e06462bf511f9d0b140fb48ac1b1baa5bded\");\n\n    SecureRandom    random = new FixedSecureRandom(new byte[][] { k1, k2 });\n\n    // DSA modified signatures, courtesy of the Google security team\n    static final DSAPrivateKeySpec PRIVATE_KEY = new DSAPrivateKeySpec(\n        // x\n        new BigInteger(\n            \"15382583218386677486843706921635237927801862255437148328980464126979\"),\n        // p\n        new BigInteger(\n            \"181118486631420055711787706248812146965913392568235070235446058914\"\n            + \"1170708161715231951918020125044061516370042605439640379530343556\"\n            + \"4101919053459832890139496933938670005799610981765220283775567361\"\n            + \"4836626483403394052203488713085936276470766894079318754834062443\"\n            + \"1033792580942743268186462355159813630244169054658542719322425431\"\n            + \"4088256212718983105131138772434658820375111735710449331518776858\"\n            + \"7867938758654181244292694091187568128410190746310049564097068770\"\n            + \"8161261634790060655580211122402292101772553741704724263582994973\"\n            + \"9109274666495826205002104010355456981211025738812433088757102520\"\n            + \"562459649777989718122219159982614304359\"),\n        // q\n        new BigInteger(\n            \"19689526866605154788513693571065914024068069442724893395618704484701\"),\n        // g\n        new BigInteger(\n            \"2859278237642201956931085611015389087970918161297522023542900348\"\n            + \"0877180630984239764282523693409675060100542360520959501692726128\"\n            + \"3149190229583566074777557293475747419473934711587072321756053067\"\n            + \"2532404847508798651915566434553729839971841903983916294692452760\"\n            + \"2490198571084091890169933809199002313226100830607842692992570749\"\n            + \"0504363602970812128803790973955960534785317485341020833424202774\"\n            + \"0275688698461842637641566056165699733710043802697192696426360843\"\n            + \"1736206792141319514001488556117408586108219135730880594044593648\"\n            + \"9237302749293603778933701187571075920849848690861126195402696457\"\n            + \"4111219599568903257472567764789616958430\"));\n\n    static final DSAPublicKeySpec PUBLIC_KEY = new DSAPublicKeySpec(\n        new BigInteger(\n            \"3846308446317351758462473207111709291533523711306097971550086650\"\n            + \"2577333637930103311673872185522385807498738696446063139653693222\"\n            + \"3528823234976869516765207838304932337200968476150071617737755913\"\n            + \"3181601169463467065599372409821150709457431511200322947508290005\"\n            + \"1780020974429072640276810306302799924668893998032630777409440831\"\n            + \"4314588994475223696460940116068336991199969153649625334724122468\"\n            + \"7497038281983541563359385775312520539189474547346202842754393945\"\n            + \"8755803223951078082197762886933401284142487322057236814878262166\"\n            + \"5072306622943221607031324846468109901964841479558565694763440972\"\n            + \"5447389416166053148132419345627682740529\"),\n         PRIVATE_KEY.getP(),\n         PRIVATE_KEY.getQ(),\n         PRIVATE_KEY.getG());\n\n    // The following test vectors check for signature malleability and bugs. That means the test\n    // vectors are derived from a valid signature by modifying the ASN encoding. A correct\n    // implementation of DSA should only accept correct DER encoding and properly handle the others.\n    // Allowing alternative BER encodings is in many cases benign. An example where this kind of\n    // signature malleability was a problem: https://en.bitcoin.it/wiki/Transaction_Malleability\n    static final String[] MODIFIED_SIGNATURES  = {\n        \"303e02811c1e41b479ad576905b960fe14eadb91b0ccf34843dab916173bb8c9cd021d00ade65988d237d30f9e\"\n        + \"f41dd424a4e1c8f16967cf3365813fe8786236\",\n        \"303f0282001c1e41b479ad576905b960fe14eadb91b0ccf34843dab916173bb8c9cd021d00ade65988d237d30f\"\n        + \"9ef41dd424a4e1c8f16967cf3365813fe8786236\",\n        \"303e021d001e41b479ad576905b960fe14eadb91b0ccf34843dab916173bb8c9cd021d00ade65988d237d30f9e\"\n        + \"f41dd424a4e1c8f16967cf3365813fe8786236\",\n        \"303e021c1e41b479ad576905b960fe14eadb91b0ccf34843dab916173bb8c9cd02811d00ade65988d237d30f9e\"\n        + \"f41dd424a4e1c8f16967cf3365813fe8786236\",\n        \"303f021c1e41b479ad576905b960fe14eadb91b0ccf34843dab916173bb8c9cd0282001d00ade65988d237d30f\"\n        + \"9ef41dd424a4e1c8f16967cf3365813fe8786236\",\n        \"303e021c1e41b479ad576905b960fe14eadb91b0ccf34843dab916173bb8c9cd021e0000ade65988d237d30f9e\"\n        + \"f41dd424a4e1c8f16967cf3365813fe8786236\",\n        \"30813d021c1e41b479ad576905b960fe14eadb91b0ccf34843dab916173bb8c9cd021d00ade65988d237d30f9e\"\n        + \"f41dd424a4e1c8f16967cf3365813fe8786236\",\n        \"3082003d021c1e41b479ad576905b960fe14eadb91b0ccf34843dab916173bb8c9cd021d00ade65988d237d30f\"\n        + \"9ef41dd424a4e1c8f16967cf3365813fe8786236\",\n        \"303d021c1e41b479ad576905b960fe14eadb91b0ccf34843dab916173bb8c9cd021d00ade65988d237d30f9ef4\"\n        + \"1dd424a4e1c8f16967cf3365813fe87862360000\",\n        \"3040021c57b10411b54ab248af03d8f2456676ebc6d3db5f1081492ac87e9ca8021d00942b117051d7d9d107fc42cac9c5a36a1fd7f0f8916ccca86cec4ed3040100\",\n        \"303e021c57b10411b54ab248af03d8f2456676ebc6d3db5f1081492ac87e9ca802811d00942b117051d7d9d107fc42cac9c5a36a1fd7f0f8916ccca86cec4ed3\"\n    };\n\n    private void testModified()\n        throws Exception\n    {\n        KeyFactory kFact = KeyFactory.getInstance(\"DSA\", \"BC\");\n        PublicKey pubKey = kFact.generatePublic(PUBLIC_KEY);\n        Signature sig = Signature.getInstance(\"DSA\", \"BC\");\n\n        for (int i = 0; i != MODIFIED_SIGNATURES.length; i++)\n        {\n            sig.initVerify(pubKey);\n\n            sig.update(Strings.toByteArray(\"Hello\"));\n\n            boolean failed;\n\n            try\n            {\n                failed = !sig.verify(Hex.decode(MODIFIED_SIGNATURES[i]));\n            }\n            catch (SignatureException e)\n            {\n                failed = true;\n            }\n\n            isTrue(\"sig verified when shouldn't\", failed);\n        }\n    }\n\n    private void testCompat()\n        throws Exception\n    {\n        if (Security.getProvider(\"SUN\") == null)\n        {\n            return;\n        }\n\n        Signature           s = Signature.getInstance(\"DSA\", \"SUN\");\n        KeyPairGenerator    g = KeyPairGenerator.getInstance(\"DSA\", \"SUN\");\n        byte[]              data = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 0 };\n        \n        g.initialize(512, new SecureRandom());\n        \n        KeyPair p = g.generateKeyPair();\n        \n        PrivateKey  sKey = p.getPrivate();\n        PublicKey   vKey = p.getPublic();\n        \n        //\n        // sign SUN - verify with BC \n        //\n        s.initSign(sKey);\n        \n        s.update(data);\n        \n        byte[]  sigBytes = s.sign();\n        \n        s = Signature.getInstance(\"DSA\", \"BC\");\n        \n        s.initVerify(vKey);\n        \n        s.update(data);\n        \n        if (!s.verify(sigBytes))\n        {\n            fail(\"SUN -> BC verification failed\");\n        }\n        \n        //\n        // sign BC - verify with SUN\n        //\n        \n        s.initSign(sKey);\n        \n        s.update(data);\n        \n        sigBytes = s.sign();\n        \n        s = Signature.getInstance(\"DSA\", \"SUN\");\n        \n        s.initVerify(vKey);\n        \n        s.update(data);\n        \n        if (!s.verify(sigBytes))\n        {\n            fail(\"BC -> SUN verification failed\");\n        }\n\n        //\n        // key encoding test - BC decoding Sun keys\n        //\n        KeyFactory          f = KeyFactory.getInstance(\"DSA\", \"BC\");\n        X509EncodedKeySpec  x509s = new X509EncodedKeySpec(vKey.getEncoded());\n\n        DSAPublicKey        k1 = (DSAPublicKey)f.generatePublic(x509s);\n\n        checkPublic(k1, vKey);\n        \n        PKCS8EncodedKeySpec  pkcs8 = new PKCS8EncodedKeySpec(sKey.getEncoded());\n\n        DSAPrivateKey        k2 = (DSAPrivateKey)f.generatePrivate(pkcs8);\n\n        checkPrivateKey(k2, sKey);\n        \n        //\n        // key decoding test - SUN decoding BC keys\n        // \n        f = KeyFactory.getInstance(\"DSA\", \"SUN\");\n        x509s = new X509EncodedKeySpec(k1.getEncoded());\n        \n        vKey = (DSAPublicKey)f.generatePublic(x509s);\n\n        checkPublic(k1, vKey);\n        \n        pkcs8 = new PKCS8EncodedKeySpec(k2.getEncoded());\n        sKey = f.generatePrivate(pkcs8);\n\n        checkPrivateKey(k2, sKey);\n    }\n\n    private void testNullParameters()\n        throws Exception\n    {\n        KeyFactory f = KeyFactory.getInstance(\"DSA\", \"BC\");\n        X509EncodedKeySpec x509s = new X509EncodedKeySpec(new SubjectPublicKeyInfo(new AlgorithmIdentifier(X9ObjectIdentifiers.id_dsa), new ASN1Integer(10001)).getEncoded());\n\n        DSAPublicKey key1 = (DSAPublicKey)f.generatePublic(x509s);\n        DSAPublicKey key2 = (DSAPublicKey)f.generatePublic(x509s);\n\n        isTrue(\"parameters not absent\", key1.getParams() == null && key2.getParams() == null);\n        isTrue(\"hashCode mismatch\", key1.hashCode() == key2.hashCode());\n        isTrue(\"not equal\", key1.equals(key2));\n        isTrue(\"encoding mismatch\", Arrays.areEqual(x509s.getEncoded(), key1.getEncoded()));\n    }\n\n    private void testValidate()\n        throws Exception\n    {\n        DSAParameterSpec dsaParams = new DSAParameterSpec(\n            new BigInteger(\n                        \"F56C2A7D366E3EBDEAA1891FD2A0D099\" +\n                        \"436438A673FED4D75F594959CFFEBCA7BE0FC72E4FE67D91\" +\n                        \"D801CBA0693AC4ED9E411B41D19E2FD1699C4390AD27D94C\" +\n                        \"69C0B143F1DC88932CFE2310C886412047BD9B1C7A67F8A2\" +\n                        \"5909132627F51A0C866877E672E555342BDF9355347DBD43\" +\n                        \"B47156B2C20BAD9D2B071BC2FDCF9757F75C168C5D9FC431\" +\n                        \"31BE162A0756D1BDEC2CA0EB0E3B018A8B38D3EF2487782A\" +\n                        \"EB9FBF99D8B30499C55E4F61E5C7DCEE2A2BB55BD7F75FCD\" +\n                        \"F00E48F2E8356BDB59D86114028F67B8E07B127744778AFF\" +\n                        \"1CF1399A4D679D92FDE7D941C5C85C5D7BFF91BA69F9489D\" +\n                        \"531D1EBFA727CFDA651390F8021719FA9F7216CEB177BD75\", 16),\n            new BigInteger(\"C24ED361870B61E0D367F008F99F8A1F75525889C89DB1B673C45AF5867CB467\", 16),\n            new BigInteger(\n                        \"8DC6CC814CAE4A1C05A3E186A6FE27EA\" +\n                        \"BA8CDB133FDCE14A963A92E809790CBA096EAA26140550C1\" +\n                        \"29FA2B98C16E84236AA33BF919CD6F587E048C52666576DB\" +\n                        \"6E925C6CBE9B9EC5C16020F9A44C9F1C8F7A8E611C1F6EC2\" +\n                        \"513EA6AA0B8D0F72FED73CA37DF240DB57BBB27431D61869\" +\n                        \"7B9E771B0B301D5DF05955425061A30DC6D33BB6D2A32BD0\" +\n                        \"A75A0A71D2184F506372ABF84A56AEEEA8EB693BF29A6403\" +\n                        \"45FA1298A16E85421B2208D00068A5A42915F82CF0B858C8\" +\n                        \"FA39D43D704B6927E0B2F916304E86FB6A1B487F07D8139E\" +\n                        \"428BB096C6D67A76EC0B8D4EF274B8A2CF556D279AD267CC\" +\n                        \"EF5AF477AFED029F485B5597739F5D0240F67C2D948A6279\", 16)\n        );\n\n        KeyFactory f = KeyFactory.getInstance(\"DSA\", \"BC\");\n\n        try\n        {\n            f.generatePublic(new DSAPublicKeySpec(BigInteger.valueOf(1), dsaParams.getP(), dsaParams.getG(), dsaParams.getQ()));\n\n            fail(\"no exception\");\n        }\n        catch (Exception e)\n        {\n            isTrue(\"mismatch\", \"invalid KeySpec: y value does not appear to be in correct group\".equals(e.getMessage()));\n        }\n    }\n\n    private void testNONEwithDSA()\n        throws Exception\n    {\n        byte[] dummySha1 = Hex.decode(\"01020304050607080910111213141516\");\n\n        KeyPairGenerator kpGen = KeyPairGenerator.getInstance(\"DSA\", \"BC\");\n\n        kpGen.initialize(512);\n\n        KeyPair          kp = kpGen.generateKeyPair();\n\n        Signature        sig = Signature.getInstance(\"NONEwithDSA\", \"BC\");\n\n        sig.initSign(kp.getPrivate());\n\n        sig.update(dummySha1);\n\n        byte[] sigBytes = sig.sign();\n\n        sig.initVerify(kp.getPublic());\n\n        sig.update(dummySha1);\n\n        sig.verify(sigBytes);\n\n        // reset test\n\n        sig.update(dummySha1);\n\n        if (!sig.verify(sigBytes))\n        {\n            fail(\"NONEwithDSA failed to reset\");\n        }\n\n        // lightweight test\n        DSAPublicKey  key = (DSAPublicKey)kp.getPublic();\n        DSAParameters params = new DSAParameters(key.getParams().getP(), key.getParams().getQ(), key.getParams().getG());\n        DSAPublicKeyParameters keyParams = new DSAPublicKeyParameters(key.getY(), params);\n        DSASigner signer = new DSASigner();\n        ASN1Sequence derSig = ASN1Sequence.getInstance(ASN1Primitive.fromByteArray(sigBytes));\n\n        signer.init(false, keyParams);\n\n        if (!signer.verifySignature(dummySha1, ASN1Integer.getInstance(derSig.getObjectAt(0)).getValue(), ASN1Integer.getInstance(derSig.getObjectAt(1)).getValue()))\n        {\n            fail(\"NONEwithDSA not really NONE!\");\n        }\n    }\n\n    private void checkPublic(DSAPublicKey k1, PublicKey vKey)\n    {\n        if (!k1.getY().equals(((DSAPublicKey)vKey).getY()))\n        {\n            fail(\"public number not decoded properly\");\n        }\n\n        if (!k1.getParams().getG().equals(((DSAPublicKey)vKey).getParams().getG()))\n        {\n            fail(\"public generator not decoded properly\");\n        }\n\n        if (!k1.getParams().getP().equals(((DSAPublicKey)vKey).getParams().getP()))\n        {\n            fail(\"public p value not decoded properly\");\n        }\n\n        if (!k1.getParams().getQ().equals(((DSAPublicKey)vKey).getParams().getQ()))\n        {\n            fail(\"public q value not decoded properly\");\n        }\n    }\n\n    private void checkPrivateKey(DSAPrivateKey k2, PrivateKey sKey)\n    {\n        if (!k2.getX().equals(((DSAPrivateKey)sKey).getX()))\n        {\n            fail(\"private number not decoded properly\");\n        }\n\n        if (!k2.getParams().getG().equals(((DSAPrivateKey)sKey).getParams().getG()))\n        {\n            fail(\"private generator not decoded properly\");\n        }\n\n        if (!k2.getParams().getP().equals(((DSAPrivateKey)sKey).getParams().getP()))\n        {\n            fail(\"private p value not decoded properly\");\n        }\n\n        if (!k2.getParams().getQ().equals(((DSAPrivateKey)sKey).getParams().getQ()))\n        {\n            fail(\"private q value not decoded properly\");\n        }\n    }\n\n    private Object serializeDeserialize(Object o)\n        throws Exception\n    {\n        ByteArrayOutputStream bOut = new ByteArrayOutputStream();\n        ObjectOutputStream oOut = new ObjectOutputStream(bOut);\n\n        oOut.writeObject(o);\n        oOut.close();\n\n        ObjectInputStream oIn = new ObjectInputStream(new ByteArrayInputStream(bOut.toByteArray()));\n\n        return oIn.readObject();\n    }\n\n    /**\n     * X9.62 - 1998,<br>\n     * J.3.2, Page 155, ECDSA over the field Fp<br>\n     * an example with 239 bit prime\n     */\n    private void testECDSA239bitPrime()\n        throws Exception\n    {\n        BigInteger r = new BigInteger(\"308636143175167811492622547300668018854959378758531778147462058306432176\");\n        BigInteger s = new BigInteger(\"323813553209797357708078776831250505931891051755007842781978505179448783\");\n\n        byte[] kData = BigIntegers.asUnsignedByteArray(new BigInteger(\"700000017569056646655505781757157107570501575775705779575555657156756655\"));\n\n        SecureRandom    k = new TestRandomBigInteger(kData);\n\n        ECCurve curve = new ECCurve.Fp(\n                new BigInteger(\"883423532389192164791648750360308885314476597252960362792450860609699839\"), // q\n                new BigInteger(\"7fffffffffffffffffffffff7fffffffffff8000000000007ffffffffffc\", 16), // a\n                new BigInteger(\"6b016c3bdcf18941d0d654921475ca71a9db2fb27d1d37796185c2942c0a\", 16)); // b\n        \n        ECParameterSpec spec = new ECParameterSpec(\n                curve,\n                curve.decodePoint(Hex.decode(\"020ffa963cdca8816ccc33b8642bedf905c3d358573d3f27fbbd3b3cb9aaaf\")), // G\n                new BigInteger(\"883423532389192164791648750360308884807550341691627752275345424702807307\")); // n\n        \n        \n        ECPrivateKeySpec priKey = new ECPrivateKeySpec(\n                new BigInteger(\"876300101507107567501066130761671078357010671067781776716671676178726717\"), // d\n                spec);\n        \n        ECPublicKeySpec pubKey = new ECPublicKeySpec(\n                curve.decodePoint(Hex.decode(\"025b6dc53bc61a2548ffb0f671472de6c9521a9d2d2534e65abfcbd5fe0c70\")), // Q\n                spec);\n        \n        Signature           sgr = Signature.getInstance(\"ECDSA\", \"BC\");\n        KeyFactory          f = KeyFactory.getInstance(\"ECDSA\", \"BC\");\n        PrivateKey          sKey = f.generatePrivate(priKey);\n        PublicKey           vKey = f.generatePublic(pubKey);\n        \n        sgr.initSign(sKey, k);\n        \n        byte[] message = new byte[] { (byte)'a', (byte)'b', (byte)'c' };\n        \n        sgr.update(message);\n        \n        byte[]  sigBytes = sgr.sign();\n        \n        sgr.initVerify(vKey);\n        \n        sgr.update(message);\n        \n        if (!sgr.verify(sigBytes))\n        {\n            fail(\"239 Bit EC verification failed\");\n        }\n        \n        BigInteger[]  sig = derDecode(sigBytes);\n        \n        if (!r.equals(sig[0]))\n        {\n            fail(\"r component wrong.\" + Strings.lineSeparator()\n                    + \" expecting: \" + r + Strings.lineSeparator()\n                    + \" got      : \" + sig[0]);\n        }\n        \n        if (!s.equals(sig[1]))\n        {\n            fail(\"s component wrong.\" + Strings.lineSeparator()\n                    + \" expecting: \" + s + Strings.lineSeparator()\n                    + \" got      : \" + sig[1]);\n        }\n    }\n\n    private void testNONEwithECDSA239bitPrime()\n        throws Exception\n    {\n        ECCurve curve = new ECCurve.Fp(\n                new BigInteger(\"883423532389192164791648750360308885314476597252960362792450860609699839\"), // q\n                new BigInteger(\"7fffffffffffffffffffffff7fffffffffff8000000000007ffffffffffc\", 16), // a\n                new BigInteger(\"6b016c3bdcf18941d0d654921475ca71a9db2fb27d1d37796185c2942c0a\", 16)); // b\n\n        ECParameterSpec spec = new ECParameterSpec(\n                curve,\n                curve.decodePoint(Hex.decode(\"020ffa963cdca8816ccc33b8642bedf905c3d358573d3f27fbbd3b3cb9aaaf\")), // G\n                new BigInteger(\"883423532389192164791648750360308884807550341691627752275345424702807307\")); // n\n\n\n        ECPrivateKeySpec priKey = new ECPrivateKeySpec(\n                new BigInteger(\"876300101507107567501066130761671078357010671067781776716671676178726717\"), // d\n                spec);\n\n        ECPublicKeySpec pubKey = new ECPublicKeySpec(\n                curve.decodePoint(Hex.decode(\"025b6dc53bc61a2548ffb0f671472de6c9521a9d2d2534e65abfcbd5fe0c70\")), // Q\n                spec);\n\n        Signature           sgr = Signature.getInstance(\"NONEwithECDSA\", \"BC\");\n        KeyFactory          f = KeyFactory.getInstance(\"ECDSA\", \"BC\");\n        PrivateKey          sKey = f.generatePrivate(priKey);\n        PublicKey           vKey = f.generatePublic(pubKey);\n\n        byte[] message = \"abc\".getBytes();\n        byte[] sig = Hex.decode(\"3040021e2cb7f36803ebb9c427c58d8265f11fc5084747133078fc279de874fbecb0021e64cb19604be06c57e761b3de5518f71de0f6e0cd2df677cec8a6ffcb690d\");\n\n        checkMessage(sgr, sKey, vKey, message, sig);\n\n        message = \"abcdefghijklmnopqrstuvwxyz\".getBytes();\n        sig = Hex.decode(\"3040021e2cb7f36803ebb9c427c58d8265f11fc5084747133078fc279de874fbecb0021e43fd65b3363d76aabef8630572257dbb67c82818ad9fad31256539b1b02c\");\n\n        checkMessage(sgr, sKey, vKey, message, sig);\n\n        message = \"a very very long message gauranteed to cause an overflow\".getBytes();\n        sig = Hex.decode(\"3040021e2cb7f36803ebb9c427c58d8265f11fc5084747133078fc279de874fbecb0021e7d5be84b22937a1691859a3c6fe45ed30b108574431d01b34025825ec17a\");\n\n        checkMessage(sgr, sKey, vKey, message, sig);\n    }\n\n    private void testECDSAP256sha3(ASN1ObjectIdentifier sigOid, int size, BigInteger s)\n        throws Exception\n    {\n        X9ECParameters p = NISTNamedCurves.getByName(\"P-256\");\n        KeyFactory ecKeyFact = KeyFactory.getInstance(\"EC\", \"BC\");\n\n        ECDomainParameters params = new ECDomainParameters(p.getCurve(), p.getG(), p.getN(), p.getH());\n\n        ECCurve curve = p.getCurve();\n\n        ECParameterSpec spec = new ECParameterSpec(\n                curve,\n                p.getG(), // G\n                p.getN()); // n\n\n        ECPrivateKeySpec priKey = new ECPrivateKeySpec(\n                new BigInteger(\"20186677036482506117540275567393538695075300175221296989956723148347484984008\"), // d\n                spec);\n\n        ECPublicKeySpec pubKey = new ECPublicKeySpec(\n            params.getCurve().decodePoint(Hex.decode(\"03596375E6CE57E0F20294FC46BDFCFD19A39F8161B58695B3EC5B3D16427C274D\")), // Q\n            spec);\n\n        doEcDsaTest(\"SHA3-\" + size + \"withECDSA\", s, ecKeyFact, pubKey, priKey);\n        doEcDsaTest(sigOid.getId(), s, ecKeyFact, pubKey, priKey);\n    }\n\n    private void doEcDsaTest(String sigName, BigInteger s, KeyFactory ecKeyFact, ECPublicKeySpec pubKey, ECPrivateKeySpec priKey)\n        throws NoSuchAlgorithmException, NoSuchProviderException, InvalidKeyException, InvalidKeySpecException, SignatureException\n    {\n        SecureRandom k = new TestRandomBigInteger(BigIntegers.asUnsignedByteArray(new BigInteger(\"72546832179840998877302529996971396893172522460793442785601695562409154906335\")));\n\n        byte[] M = Hex.decode(\"1BD4ED430B0F384B4E8D458EFF1A8A553286D7AC21CB2F6806172EF5F94A06AD\");\n\n        Signature dsa = Signature.getInstance(sigName, \"BC\");\n\n        dsa.initSign(ecKeyFact.generatePrivate(priKey), k);\n\n        dsa.update(M, 0, M.length);\n\n        byte[] encSig = dsa.sign();\n\n        ASN1Sequence sig = ASN1Sequence.getInstance(encSig);\n\n        BigInteger r = new BigInteger(\"97354732615802252173078420023658453040116611318111190383344590814578738210384\");\n\n        BigInteger sigR = ASN1Integer.getInstance(sig.getObjectAt(0)).getValue();\n        if (!r.equals(sigR))\n        {\n            fail(\"r component wrong.\" + Strings.lineSeparator()\n                + \" expecting: \" + r.toString(16) + Strings.lineSeparator()\n                + \" got      : \" + sigR.toString(16));\n        }\n\n        BigInteger sigS = ASN1Integer.getInstance(sig.getObjectAt(1)).getValue();\n        if (!s.equals(sigS))\n        {\n            fail(\"s component wrong.\" + Strings.lineSeparator()\n                + \" expecting: \" + s.toString(16) + Strings.lineSeparator()\n                + \" got      : \" + sigS.toString(16));\n        }\n\n        // Verify the signature\n        dsa.initVerify(ecKeyFact.generatePublic(pubKey));\n\n        dsa.update(M, 0, M.length);\n\n        if (!dsa.verify(encSig))\n        {\n            fail(\"signature fails\");\n        }\n    }\n\n    private void testDSAsha3(ASN1ObjectIdentifier sigOid, int size, BigInteger s)\n        throws Exception\n    {\n        DSAParameterSpec dsaParams = new DSAParameterSpec(\n            new BigInteger(\n                        \"F56C2A7D366E3EBDEAA1891FD2A0D099\" +\n                        \"436438A673FED4D75F594959CFFEBCA7BE0FC72E4FE67D91\" +\n                        \"D801CBA0693AC4ED9E411B41D19E2FD1699C4390AD27D94C\" +\n                        \"69C0B143F1DC88932CFE2310C886412047BD9B1C7A67F8A2\" +\n                        \"5909132627F51A0C866877E672E555342BDF9355347DBD43\" +\n                        \"B47156B2C20BAD9D2B071BC2FDCF9757F75C168C5D9FC431\" +\n                        \"31BE162A0756D1BDEC2CA0EB0E3B018A8B38D3EF2487782A\" +\n                        \"EB9FBF99D8B30499C55E4F61E5C7DCEE2A2BB55BD7F75FCD\" +\n                        \"F00E48F2E8356BDB59D86114028F67B8E07B127744778AFF\" +\n                        \"1CF1399A4D679D92FDE7D941C5C85C5D7BFF91BA69F9489D\" +\n                        \"531D1EBFA727CFDA651390F8021719FA9F7216CEB177BD75\", 16),\n            new BigInteger(\"C24ED361870B61E0D367F008F99F8A1F75525889C89DB1B673C45AF5867CB467\", 16),\n            new BigInteger(\n                        \"8DC6CC814CAE4A1C05A3E186A6FE27EA\" +\n                        \"BA8CDB133FDCE14A963A92E809790CBA096EAA26140550C1\" +\n                        \"29FA2B98C16E84236AA33BF919CD6F587E048C52666576DB\" +\n                        \"6E925C6CBE9B9EC5C16020F9A44C9F1C8F7A8E611C1F6EC2\" +\n                        \"513EA6AA0B8D0F72FED73CA37DF240DB57BBB27431D61869\" +\n                        \"7B9E771B0B301D5DF05955425061A30DC6D33BB6D2A32BD0\" +\n                        \"A75A0A71D2184F506372ABF84A56AEEEA8EB693BF29A6403\" +\n                        \"45FA1298A16E85421B2208D00068A5A42915F82CF0B858C8\" +\n                        \"FA39D43D704B6927E0B2F916304E86FB6A1B487F07D8139E\" +\n                        \"428BB096C6D67A76EC0B8D4EF274B8A2CF556D279AD267CC\" +\n                        \"EF5AF477AFED029F485B5597739F5D0240F67C2D948A6279\", 16)\n        );\n\n        BigInteger x = new BigInteger(\"0CAF2EF547EC49C4F3A6FE6DF4223A174D01F2C115D49A6F73437C29A2A8458C\", 16);\n\n        BigInteger y = new BigInteger(\n                    \"2828003D7C747199143C370FDD07A286\" +\n                    \"1524514ACC57F63F80C38C2087C6B795B62DE1C224BF8D1D\" +\n                    \"1424E60CE3F5AE3F76C754A2464AF292286D873A7A30B7EA\" +\n                    \"CBBC75AAFDE7191D9157598CDB0B60E0C5AA3F6EBE425500\" +\n                    \"C611957DBF5ED35490714A42811FDCDEB19AF2AB30BEADFF\" +\n                    \"2907931CEE7F3B55532CFFAEB371F84F01347630EB227A41\" +\n                    \"9B1F3F558BC8A509D64A765D8987D493B007C4412C297CAF\" +\n                    \"41566E26FAEE475137EC781A0DC088A26C8804A98C23140E\" +\n                    \"7C936281864B99571EE95C416AA38CEEBB41FDBFF1EB1D1D\" +\n                    \"C97B63CE1355257627C8B0FD840DDB20ED35BE92F08C49AE\" +\n                    \"A5613957D7E5C7A6D5A5834B4CB069E0831753ECF65BA02B\", 16);\n\n        DSAPrivateKeySpec priKey = new DSAPrivateKeySpec(\n                x, dsaParams.getP(), dsaParams.getQ(), dsaParams.getG());\n\n        DSAPublicKeySpec pubKey = new DSAPublicKeySpec(\n            y, dsaParams.getP(), dsaParams.getQ(), dsaParams.getG());\n\n        KeyFactory dsaKeyFact = KeyFactory.getInstance(\"DSA\", \"BC\");\n\n        doDsaTest(\"SHA3-\" + size + \"withDSA\", s, dsaKeyFact, pubKey, priKey);\n        doDsaTest(sigOid.getId(), s, dsaKeyFact, pubKey, priKey);\n    }\n\n    private void doDsaTest(String sigName, BigInteger s, KeyFactory ecKeyFact, DSAPublicKeySpec pubKey, DSAPrivateKeySpec priKey)\n        throws NoSuchAlgorithmException, NoSuchProviderException, InvalidKeyException, InvalidKeySpecException, SignatureException\n    {\n        SecureRandom k = new TestRandomBigInteger(BigIntegers.asUnsignedByteArray(new BigInteger(\"72546832179840998877302529996971396893172522460793442785601695562409154906335\")));\n\n        byte[] M = Hex.decode(\"1BD4ED430B0F384B4E8D458EFF1A8A553286D7AC21CB2F6806172EF5F94A06AD\");\n\n        Signature dsa = Signature.getInstance(sigName, \"BC\");\n\n        dsa.initSign(ecKeyFact.generatePrivate(priKey), k);\n\n        dsa.update(M, 0, M.length);\n\n        byte[] encSig = dsa.sign();\n\n        ASN1Sequence sig = ASN1Sequence.getInstance(encSig);\n\n        BigInteger r = new BigInteger(\"4864074fe30e6601268ee663440e4d9b703f62673419864e91e9edb0338ce510\", 16);\n\n        BigInteger sigR = ASN1Integer.getInstance(sig.getObjectAt(0)).getValue();\n        if (!r.equals(sigR))\n        {\n            fail(\"r component wrong.\" + Strings.lineSeparator()\n                + \" expecting: \" + r.toString(16) + Strings.lineSeparator()\n                + \" got      : \" + sigR.toString(16));\n        }\n\n        BigInteger sigS = ASN1Integer.getInstance(sig.getObjectAt(1)).getValue();\n        if (!s.equals(sigS))\n        {\n            fail(\"s component wrong.\" + Strings.lineSeparator()\n                + \" expecting: \" + s.toString(16) + Strings.lineSeparator()\n                + \" got      : \" + sigS.toString(16));\n        }\n\n        // Verify the signature\n        dsa.initVerify(ecKeyFact.generatePublic(pubKey));\n\n        dsa.update(M, 0, M.length);\n\n        if (!dsa.verify(encSig))\n        {\n            fail(\"signature fails\");\n        }\n    }\n\n    private void checkMessage(Signature sgr, PrivateKey sKey, PublicKey vKey, byte[] message, byte[] sig)\n        throws InvalidKeyException, SignatureException\n    {\n        byte[] kData = BigIntegers.asUnsignedByteArray(new BigInteger(\"700000017569056646655505781757157107570501575775705779575555657156756655\"));\n\n        SecureRandom    k = new TestRandomBigInteger(kData);\n\n        sgr.initSign(sKey, k);\n\n        sgr.update(message);\n\n        byte[]  sigBytes = sgr.sign();\n\n        if (!Arrays.areEqual(sigBytes, sig))\n        {\n            fail(new String(message) + \" signature incorrect\");\n        }\n\n        sgr.initVerify(vKey);\n\n        sgr.update(message);\n\n        if (!sgr.verify(sigBytes))\n        {\n            fail(new String(message) + \" verification failed\");\n        }\n    }\n\n    /**\n     * X9.62 - 1998,<br>\n     * J.2.1, Page 100, ECDSA over the field F2m<br>\n     * an example with 191 bit binary field\n     */\n    private void testECDSA239bitBinary()\n        throws Exception\n    {\n        BigInteger r = new BigInteger(\"21596333210419611985018340039034612628818151486841789642455876922391552\");\n        BigInteger s = new BigInteger(\"197030374000731686738334997654997227052849804072198819102649413465737174\");\n    \n        byte[] kData = BigIntegers.asUnsignedByteArray(new BigInteger(\"171278725565216523967285789236956265265265235675811949404040041670216363\"));\n\n        SecureRandom    k = new TestRandomBigInteger(kData);\n\n        ECCurve curve = new ECCurve.F2m(\n            239, // m\n            36, // k\n            new BigInteger(\"32010857077C5431123A46B808906756F543423E8D27877578125778AC76\", 16), // a\n            new BigInteger(\"790408F2EEDAF392B012EDEFB3392F30F4327C0CA3F31FC383C422AA8C16\", 16)); // b\n    \n        ECParameterSpec params = new ECParameterSpec(\n            curve,\n            curve.decodePoint(Hex.decode(\"0457927098FA932E7C0A96D3FD5B706EF7E5F5C156E16B7E7C86038552E91D61D8EE5077C33FECF6F1A16B268DE469C3C7744EA9A971649FC7A9616305\")), // G\n            new BigInteger(\"220855883097298041197912187592864814557886993776713230936715041207411783\"), // n\n            BigInteger.valueOf(4)); // h\n    \n        ECPrivateKeySpec priKeySpec = new ECPrivateKeySpec(\n            new BigInteger(\"145642755521911534651321230007534120304391871461646461466464667494947990\"), // d\n            params);\n        \n        ECPublicKeySpec pubKeySpec = new ECPublicKeySpec(\n            curve.decodePoint(Hex.decode(\"045894609CCECF9A92533F630DE713A958E96C97CCB8F5ABB5A688A238DEED6DC2D9D0C94EBFB7D526BA6A61764175B99CB6011E2047F9F067293F57F5\")), // Q\n            params);\n    \n        Signature   sgr = Signature.getInstance(\"ECDSA\", \"BC\");\n        KeyFactory  f = KeyFactory.getInstance(\"ECDSA\", \"BC\");\n        PrivateKey  sKey = f.generatePrivate(priKeySpec);\n        PublicKey   vKey = f.generatePublic(pubKeySpec);\n        byte[]      message = new byte[] { (byte)'a', (byte)'b', (byte)'c' };\n       \n        sgr.initSign(sKey, k);\n\n        sgr.update(message);\n        \n        byte[]  sigBytes = sgr.sign();\n\n        sgr.initVerify(vKey);\n\n        sgr.update(message);\n\n        if (!sgr.verify(sigBytes))\n        {\n            fail(\"239 Bit EC verification failed\");\n        }\n\n        BigInteger[]  sig = derDecode(sigBytes);\n\n        if (!r.equals(sig[0]))\n        {\n            fail(\"r component wrong.\" + Strings.lineSeparator()\n                + \" expecting: \" + r + Strings.lineSeparator()\n                + \" got      : \" + sig[0]);\n        }\n\n        if (!s.equals(sig[1]))\n        {\n            fail(\"s component wrong.\" + Strings.lineSeparator()\n                + \" expecting: \" + s + Strings.lineSeparator()\n                + \" got      : \" + sig[1]);\n        }\n    }\n\n    private void testECDSA239bitBinary(String algorithm, ASN1ObjectIdentifier oid)\n        throws Exception\n    {\n        byte[] kData = BigIntegers.asUnsignedByteArray(new BigInteger(\"171278725565216523967285789236956265265265235675811949404040041670216363\"));\n\n        SecureRandom    k = new TestRandomBigInteger(kData);\n\n        ECCurve curve = new ECCurve.F2m(\n            239, // m\n            36, // k\n            new BigInteger(\"32010857077C5431123A46B808906756F543423E8D27877578125778AC76\", 16), // a\n            new BigInteger(\"790408F2EEDAF392B012EDEFB3392F30F4327C0CA3F31FC383C422AA8C16\", 16)); // b\n\n        ECParameterSpec params = new ECParameterSpec(\n            curve,\n            curve.decodePoint(Hex.decode(\"0457927098FA932E7C0A96D3FD5B706EF7E5F5C156E16B7E7C86038552E91D61D8EE5077C33FECF6F1A16B268DE469C3C7744EA9A971649FC7A9616305\")), // G\n            new BigInteger(\"220855883097298041197912187592864814557886993776713230936715041207411783\"), // n\n            BigInteger.valueOf(4)); // h\n\n        ECPrivateKeySpec priKeySpec = new ECPrivateKeySpec(\n            new BigInteger(\"145642755521911534651321230007534120304391871461646461466464667494947990\"), // d\n            params);\n\n        ECPublicKeySpec pubKeySpec = new ECPublicKeySpec(\n            curve.decodePoint(Hex.decode(\"045894609CCECF9A92533F630DE713A958E96C97CCB8F5ABB5A688A238DEED6DC2D9D0C94EBFB7D526BA6A61764175B99CB6011E2047F9F067293F57F5\")), // Q\n            params);\n\n        Signature   sgr = Signature.getInstance(algorithm, \"BC\");\n        KeyFactory  f = KeyFactory.getInstance(\"ECDSA\", \"BC\");\n        PrivateKey  sKey = f.generatePrivate(priKeySpec);\n        PublicKey   vKey = f.generatePublic(pubKeySpec);\n        byte[]      message = new byte[] { (byte)'a', (byte)'b', (byte)'c' };\n\n        sgr.initSign(sKey, k);\n\n        sgr.update(message);\n\n        byte[]  sigBytes = sgr.sign();\n\n        sgr = Signature.getInstance(oid.getId(), \"BC\");\n\n        sgr.initVerify(vKey);\n\n        sgr.update(message);\n\n        if (!sgr.verify(sigBytes))\n        {\n            fail(\"239 Bit EC RIPEMD160 verification failed\");\n        }\n    }\n\n    private void testGeneration()\n        throws Exception\n    {\n        Signature           s = Signature.getInstance(\"DSA\", \"BC\");\n        KeyPairGenerator    g = KeyPairGenerator.getInstance(\"DSA\", \"BC\");\n        byte[]              data = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 0 };\n\n\n        // test exception\n        //\n        try\n        {\n            g.initialize(513, new SecureRandom());\n\n            fail(\"illegal parameter 513 check failed.\");\n        }\n        catch (IllegalArgumentException e)\n        {\n            // expected\n        }\n\n        try\n        {\n            g.initialize(510, new SecureRandom());\n\n            fail(\"illegal parameter 510 check failed.\");\n        }\n        catch (IllegalArgumentException e)\n        {\n            // expected\n        }\n\n        try\n        {\n            g.initialize(1025, new SecureRandom());\n\n            fail(\"illegal parameter 1025 check failed.\");\n        }\n        catch (IllegalArgumentException e)\n        {\n            // expected\n        }\n\n        g.initialize(512, new SecureRandom());\n\n        KeyPair p = g.generateKeyPair();\n\n        PrivateKey  sKey = p.getPrivate();\n        PublicKey   vKey = p.getPublic();\n\n        s.initSign(sKey);\n\n        s.update(data);\n\n        byte[]  sigBytes = s.sign();\n\n        s = Signature.getInstance(\"DSA\", \"BC\");\n\n        s.initVerify(vKey);\n\n        s.update(data);\n\n        if (!s.verify(sigBytes))\n        {\n            fail(\"DSA verification failed\");\n        }\n\n        //\n        // key decoding test - serialisation test\n        //\n\n        DSAPublicKey k1 = (DSAPublicKey)serializeDeserialize(vKey);\n\n        checkPublic(k1, vKey);\n\n        checkEquals(k1, vKey);\n\n        DSAPrivateKey k2 = (DSAPrivateKey)serializeDeserialize(sKey);\n\n        checkPrivateKey(k2, sKey);\n\n        checkEquals(k2, sKey);\n\n        if (!(k2 instanceof PKCS12BagAttributeCarrier))\n        {\n            fail(\"private key not implementing PKCS12 attribute carrier\");\n        }\n\n        //\n        // ECDSA Fp generation test\n        //\n        s = Signature.getInstance(\"ECDSA\", \"BC\");\n        g = KeyPairGenerator.getInstance(\"ECDSA\", \"BC\");\n\n        ECCurve curve = new ECCurve.Fp(\n            new BigInteger(\"883423532389192164791648750360308885314476597252960362792450860609699839\"), // q\n            new BigInteger(\"7fffffffffffffffffffffff7fffffffffff8000000000007ffffffffffc\", 16), // a\n            new BigInteger(\"6b016c3bdcf18941d0d654921475ca71a9db2fb27d1d37796185c2942c0a\", 16)); // b\n\n        ECParameterSpec ecSpec = new ECParameterSpec(\n            curve,\n            curve.decodePoint(Hex.decode(\"020ffa963cdca8816ccc33b8642bedf905c3d358573d3f27fbbd3b3cb9aaaf\")), // G\n            new BigInteger(\"883423532389192164791648750360308884807550341691627752275345424702807307\")); // n\n\n        g.initialize(ecSpec, new SecureRandom());\n\n        p = g.generateKeyPair();\n\n        sKey = p.getPrivate();\n        vKey = p.getPublic();\n\n        s.initSign(sKey);\n\n        s.update(data);\n\n        sigBytes = s.sign();\n\n        s = Signature.getInstance(\"ECDSA\", \"BC\");\n\n        s.initVerify(vKey);\n\n        s.update(data);\n\n        if (!s.verify(sigBytes))\n        {\n            fail(\"ECDSA verification failed\");\n        }\n\n        //\n        // key decoding test - serialisation test\n        //\n\n        PublicKey eck1 = (PublicKey)serializeDeserialize(vKey);\n\n        checkEquals(eck1, vKey);\n\n        PrivateKey eck2 = (PrivateKey)serializeDeserialize(sKey);\n\n        checkEquals(eck2, sKey);\n\n        // Named curve parameter\n        g.initialize(new ECNamedCurveGenParameterSpec(\"P-256\"), new SecureRandom());\n\n        p = g.generateKeyPair();\n\n        sKey = p.getPrivate();\n        vKey = p.getPublic();\n\n        s.initSign(sKey);\n\n        s.update(data);\n\n        sigBytes = s.sign();\n\n        s = Signature.getInstance(\"ECDSA\", \"BC\");\n\n        s.initVerify(vKey);\n\n        s.update(data);\n\n        if (!s.verify(sigBytes))\n        {\n            fail(\"ECDSA verification failed\");\n        }\n\n        //\n        // key decoding test - serialisation test\n        //\n\n        eck1 = (PublicKey)serializeDeserialize(vKey);\n\n        checkEquals(eck1, vKey);\n\n        eck2 = (PrivateKey)serializeDeserialize(sKey);\n\n        checkEquals(eck2, sKey);\n\n        //\n        // ECDSA F2m generation test\n        //\n        s = Signature.getInstance(\"ECDSA\", \"BC\");\n        g = KeyPairGenerator.getInstance(\"ECDSA\", \"BC\");\n\n        curve = new ECCurve.F2m(\n                239, // m\n                36, // k\n                new BigInteger(\"32010857077C5431123A46B808906756F543423E8D27877578125778AC76\", 16), // a\n                new BigInteger(\"790408F2EEDAF392B012EDEFB3392F30F4327C0CA3F31FC383C422AA8C16\", 16)); // b\n        \n        ecSpec = new ECParameterSpec(\n            curve,\n            curve.decodePoint(Hex.decode(\"0457927098FA932E7C0A96D3FD5B706EF7E5F5C156E16B7E7C86038552E91D61D8EE5077C33FECF6F1A16B268DE469C3C7744EA9A971649FC7A9616305\")), // G\n            new BigInteger(\"220855883097298041197912187592864814557886993776713230936715041207411783\"), // n\n            BigInteger.valueOf(4)); // h\n        \n        g.initialize(ecSpec, new SecureRandom());\n\n        p = g.generateKeyPair();\n\n        sKey = p.getPrivate();\n        vKey = p.getPublic();\n\n        s.initSign(sKey);\n\n        s.update(data);\n\n        sigBytes = s.sign();\n\n        s = Signature.getInstance(\"ECDSA\", \"BC\");\n\n        s.initVerify(vKey);\n\n        s.update(data);\n\n        if (!s.verify(sigBytes))\n        {\n            fail(\"ECDSA verification failed\");\n        }\n\n        //\n        // key decoding test - serialisation test\n        //\n\n        eck1 = (PublicKey)serializeDeserialize(vKey);\n\n        checkEquals(eck1, vKey);\n\n        eck2 = (PrivateKey)serializeDeserialize(sKey);\n\n        checkEquals(eck2, sKey);\n\n        if (!(eck2 instanceof PKCS12BagAttributeCarrier))\n        {\n            fail(\"private key not implementing PKCS12 attribute carrier\");\n        }\n    }\n\n    private void checkEquals(Object o1, Object o2)\n    {\n        if (!o1.equals(o2))\n        {\n            fail(\"comparison test failed\");\n        }\n\n        if (o1.hashCode() != o2.hashCode())\n        {\n            fail(\"hashCode test failed\");\n        }\n    }\n    \n    private void testParameters()\n        throws Exception\n    {\n        AlgorithmParameterGenerator a = AlgorithmParameterGenerator.getInstance(\"DSA\", \"BC\");\n        a.init(512, random);\n        AlgorithmParameters params = a.generateParameters();\n        \n        byte[] encodeParams = params.getEncoded();\n        \n        AlgorithmParameters a2 = AlgorithmParameters.getInstance(\"DSA\", \"BC\");\n        a2.init(encodeParams);\n        \n        // a and a2 should be equivalent!\n        byte[] encodeParams_2 = a2.getEncoded();\n        \n        if (!areEqual(encodeParams, encodeParams_2))\n        {\n            fail(\"encode/decode parameters failed\");\n        }\n        \n        DSAParameterSpec dsaP = (DSAParameterSpec)params.getParameterSpec(DSAParameterSpec.class);\n        \n        KeyPairGenerator    g = KeyPairGenerator.getInstance(\"DSA\", \"BC\");\n        g.initialize(dsaP, new SecureRandom());\n        KeyPair p = g.generateKeyPair();\n        \n        PrivateKey  sKey = p.getPrivate();\n        PublicKey   vKey = p.getPublic();\n        \n        Signature           s = Signature.getInstance(\"DSA\", \"BC\");\n        byte[]              data = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 0 };\n        \n        s.initSign(sKey);\n        \n        s.update(data);\n        \n        byte[]  sigBytes = s.sign();\n        \n        s = Signature.getInstance(\"DSA\", \"BC\");\n        \n        s.initVerify(vKey);\n        \n        s.update(data);\n        \n        if (!s.verify(sigBytes))\n        {\n            fail(\"DSA verification failed\");\n        }\n    }\n\n    private void testDSA2Parameters()\n        throws Exception\n    {\n        byte[] seed = Hex.decode(\"4783081972865EA95D43318AB2EAF9C61A2FC7BBF1B772A09017BDF5A58F4FF0\");\n\n        AlgorithmParameterGenerator a = AlgorithmParameterGenerator.getInstance(\"DSA\", \"BC\");\n        a.init(2048, new DSATestSecureRandom(seed));\n        AlgorithmParameters params = a.generateParameters();\n\n        DSAParameterSpec dsaP = (DSAParameterSpec)params.getParameterSpec(DSAParameterSpec.class);\n\n        if (!dsaP.getQ().equals(new BigInteger(\"C24ED361870B61E0D367F008F99F8A1F75525889C89DB1B673C45AF5867CB467\", 16)))\n        {\n            fail(\"Q incorrect\");\n        }\n\n        if (!dsaP.getP().equals(new BigInteger(\n            \"F56C2A7D366E3EBDEAA1891FD2A0D099\" +\n            \"436438A673FED4D75F594959CFFEBCA7BE0FC72E4FE67D91\" +\n            \"D801CBA0693AC4ED9E411B41D19E2FD1699C4390AD27D94C\" +\n            \"69C0B143F1DC88932CFE2310C886412047BD9B1C7A67F8A2\" +\n            \"5909132627F51A0C866877E672E555342BDF9355347DBD43\" +\n            \"B47156B2C20BAD9D2B071BC2FDCF9757F75C168C5D9FC431\" +\n            \"31BE162A0756D1BDEC2CA0EB0E3B018A8B38D3EF2487782A\" +\n            \"EB9FBF99D8B30499C55E4F61E5C7DCEE2A2BB55BD7F75FCD\" +\n            \"F00E48F2E8356BDB59D86114028F67B8E07B127744778AFF\" +\n            \"1CF1399A4D679D92FDE7D941C5C85C5D7BFF91BA69F9489D\" +\n            \"531D1EBFA727CFDA651390F8021719FA9F7216CEB177BD75\", 16)))\n        {\n            fail(\"P incorrect\");\n        }\n\n        if (!dsaP.getG().equals(new BigInteger(\n            \"8DC6CC814CAE4A1C05A3E186A6FE27EA\" +\n            \"BA8CDB133FDCE14A963A92E809790CBA096EAA26140550C1\" +\n            \"29FA2B98C16E84236AA33BF919CD6F587E048C52666576DB\" +\n            \"6E925C6CBE9B9EC5C16020F9A44C9F1C8F7A8E611C1F6EC2\" +\n            \"513EA6AA0B8D0F72FED73CA37DF240DB57BBB27431D61869\" +\n            \"7B9E771B0B301D5DF05955425061A30DC6D33BB6D2A32BD0\" +\n            \"A75A0A71D2184F506372ABF84A56AEEEA8EB693BF29A6403\" +\n            \"45FA1298A16E85421B2208D00068A5A42915F82CF0B858C8\" +\n            \"FA39D43D704B6927E0B2F916304E86FB6A1B487F07D8139E\" +\n            \"428BB096C6D67A76EC0B8D4EF274B8A2CF556D279AD267CC\" +\n            \"EF5AF477AFED029F485B5597739F5D0240F67C2D948A6279\", 16)))\n        {\n            fail(\"G incorrect\");\n        }\n\n        KeyPairGenerator    g = KeyPairGenerator.getInstance(\"DSA\", \"BC\");\n        g.initialize(dsaP, new TestRandomBigInteger(Hex.decode(\"0CAF2EF547EC49C4F3A6FE6DF4223A174D01F2C115D49A6F73437C29A2A8458C\")));\n        KeyPair p = g.generateKeyPair();\n\n        DSAPrivateKey  sKey = (DSAPrivateKey)p.getPrivate();\n        DSAPublicKey   vKey = (DSAPublicKey)p.getPublic();\n\n        if (!vKey.getY().equals(new BigInteger(\n            \"2828003D7C747199143C370FDD07A286\" +\n            \"1524514ACC57F63F80C38C2087C6B795B62DE1C224BF8D1D\" +\n            \"1424E60CE3F5AE3F76C754A2464AF292286D873A7A30B7EA\" +\n            \"CBBC75AAFDE7191D9157598CDB0B60E0C5AA3F6EBE425500\" +\n            \"C611957DBF5ED35490714A42811FDCDEB19AF2AB30BEADFF\" +\n            \"2907931CEE7F3B55532CFFAEB371F84F01347630EB227A41\" +\n            \"9B1F3F558BC8A509D64A765D8987D493B007C4412C297CAF\" +\n            \"41566E26FAEE475137EC781A0DC088A26C8804A98C23140E\" +\n            \"7C936281864B99571EE95C416AA38CEEBB41FDBFF1EB1D1D\" +\n            \"C97B63CE1355257627C8B0FD840DDB20ED35BE92F08C49AE\" +\n            \"A5613957D7E5C7A6D5A5834B4CB069E0831753ECF65BA02B\", 16)))\n        {\n            fail(\"Y value incorrect\");\n        }\n\n        if (!sKey.getX().equals(\n            new BigInteger(\"0CAF2EF547EC49C4F3A6FE6DF4223A174D01F2C115D49A6F73437C29A2A8458C\", 16)))\n        {\n            fail(\"X value incorrect\");\n        }\n\n        byte[] encodeParams = params.getEncoded();\n\n        AlgorithmParameters a2 = AlgorithmParameters.getInstance(\"DSA\", \"BC\");\n        a2.init(encodeParams);\n\n        // a and a2 should be equivalent!\n        byte[] encodeParams_2 = a2.getEncoded();\n\n        if (!areEqual(encodeParams, encodeParams_2))\n        {\n            fail(\"encode/decode parameters failed\");\n        }\n\n        Signature           s = Signature.getInstance(\"DSA\", \"BC\");\n        byte[]              data = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 0 };\n\n        s.initSign(sKey);\n\n        s.update(data);\n\n        byte[]  sigBytes = s.sign();\n\n        s = Signature.getInstance(\"DSA\", \"BC\");\n\n        s.initVerify(vKey);\n\n        s.update(data);\n\n        if (!s.verify(sigBytes))\n        {\n            fail(\"DSA verification failed\");\n        }\n    }\n\n    public void performTest()\n        throws Exception\n    {\n        testCompat();\n        testNONEwithDSA();\n\n        testDSAsha3(NISTObjectIdentifiers.id_dsa_with_sha3_224, 224, new BigInteger(\"613202af2a7f77e02b11b5c3a5311cf6b412192bc0032aac3ec127faebfc6bd0\", 16));\n        testDSAsha3(NISTObjectIdentifiers.id_dsa_with_sha3_256, 256, new BigInteger(\"2450755c5e15a691b121bc833b97864e34a61ee025ecec89289c949c1858091e\", 16));\n        testDSAsha3(NISTObjectIdentifiers.id_dsa_with_sha3_384, 384, new BigInteger(\"7aad97c0b71bb1e1a6483b6948a03bbe952e4780b0cee699a11731f90d84ddd1\", 16));\n        testDSAsha3(NISTObjectIdentifiers.id_dsa_with_sha3_512, 512, new BigInteger(\"725ad64d923c668e64e7c3898b5efde484cab49ce7f98c2885d2a13a9e355ad4\", 16));\n\n        testECDSA239bitPrime();\n        testNONEwithECDSA239bitPrime();\n        testECDSA239bitBinary();\n        testECDSA239bitBinary(\"RIPEMD160withECDSA\", TeleTrusTObjectIdentifiers.ecSignWithRipemd160);\n        testECDSA239bitBinary(\"SHA1withECDSA\", TeleTrusTObjectIdentifiers.ecSignWithSha1);\n        testECDSA239bitBinary(\"SHA224withECDSA\", X9ObjectIdentifiers.ecdsa_with_SHA224);\n        testECDSA239bitBinary(\"SHA256withECDSA\", X9ObjectIdentifiers.ecdsa_with_SHA256);\n        testECDSA239bitBinary(\"SHA384withECDSA\", X9ObjectIdentifiers.ecdsa_with_SHA384);\n        testECDSA239bitBinary(\"SHA512withECDSA\", X9ObjectIdentifiers.ecdsa_with_SHA512);\n        testECDSA239bitBinary(\"SHA1withCVC-ECDSA\", EACObjectIdentifiers.id_TA_ECDSA_SHA_1);\n        testECDSA239bitBinary(\"SHA224withCVC-ECDSA\", EACObjectIdentifiers.id_TA_ECDSA_SHA_224);\n        testECDSA239bitBinary(\"SHA256withCVC-ECDSA\", EACObjectIdentifiers.id_TA_ECDSA_SHA_256);\n        testECDSA239bitBinary(\"SHA384withCVC-ECDSA\", EACObjectIdentifiers.id_TA_ECDSA_SHA_384);\n        testECDSA239bitBinary(\"SHA512withCVC-ECDSA\", EACObjectIdentifiers.id_TA_ECDSA_SHA_512);\n\n        testECDSAP256sha3(NISTObjectIdentifiers.id_ecdsa_with_sha3_224, 224, new BigInteger(\"84d7d8e68e405064109cd9fc3e3026d74d278aada14ce6b7a9dd0380c154dc94\", 16));\n        testECDSAP256sha3(NISTObjectIdentifiers.id_ecdsa_with_sha3_256, 256, new BigInteger(\"99a43bdab4af989aaf2899079375642f2bae2dce05bcd8b72ec8c4a8d9a143f\", 16));\n        testECDSAP256sha3(NISTObjectIdentifiers.id_ecdsa_with_sha3_384, 384, new BigInteger(\"aa27726509c37aaf601de6f7e01e11c19add99530c9848381c23365dc505b11a\", 16));\n        testECDSAP256sha3(NISTObjectIdentifiers.id_ecdsa_with_sha3_512, 512, new BigInteger(\"f8306b57a1f5068bf12e53aabaae39e2658db39bc56747eaefb479995130ad16\", 16));\n\n        testGeneration();\n        testParameters();\n        testDSA2Parameters();\n        testNullParameters();\n        testValidate();\n        testModified();\n    }\n\n    protected BigInteger[] derDecode(\n        byte[]  encoding)\n        throws IOException\n    {\n        ByteArrayInputStream    bIn = new ByteArrayInputStream(encoding);\n        ASN1InputStream         aIn = new ASN1InputStream(bIn);\n        ASN1Sequence            s = (ASN1Sequence)aIn.readObject();\n\n        BigInteger[]            sig = new BigInteger[2];\n\n        sig[0] = ((ASN1Integer)s.getObjectAt(0)).getValue();\n        sig[1] = ((ASN1Integer)s.getObjectAt(1)).getValue();\n\n        return sig;\n    }\n\n    public String getName()\n    {\n        return \"DSA/ECDSA\";\n    }\n\n    public static void main(\n        String[]    args)\n    {\n        Security.addProvider(new BouncyCastleProvider());\n\n        runTest(new DSATest());\n    }\n\n    private class DSATestSecureRandom\n        extends TestRandomData\n    {\n        private boolean first = true;\n\n        public DSATestSecureRandom(byte[] value)\n        {\n            super(value);\n        }\n\n       public void nextBytes(byte[] bytes)\n       {\n           if (first)\n           {\n               super.nextBytes(bytes);\n               first = false;\n           }\n           else\n           {\n               bytes[bytes.length - 1] = 2;\n           }\n       }\n    }\n}\n", "package org.bouncycastle.jce.provider.test;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.math.BigInteger;\nimport java.security.AlgorithmParameters;\nimport java.security.InvalidAlgorithmParameterException;\nimport java.security.InvalidKeyException;\nimport java.security.KeyFactory;\nimport java.security.KeyPair;\nimport java.security.KeyPairGenerator;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.NoSuchProviderException;\nimport java.security.PrivateKey;\nimport java.security.PublicKey;\nimport java.security.SecureRandom;\nimport java.security.Security;\nimport java.security.Signature;\nimport java.security.SignatureException;\nimport java.security.interfaces.ECPrivateKey;\nimport java.security.interfaces.ECPublicKey;\nimport java.security.spec.AlgorithmParameterSpec;\nimport java.security.spec.ECFieldF2m;\nimport java.security.spec.ECFieldFp;\nimport java.security.spec.ECGenParameterSpec;\nimport java.security.spec.ECParameterSpec;\nimport java.security.spec.ECPoint;\nimport java.security.spec.ECPrivateKeySpec;\nimport java.security.spec.ECPublicKeySpec;\nimport java.security.spec.EllipticCurve;\nimport java.security.spec.PKCS8EncodedKeySpec;\nimport java.security.spec.X509EncodedKeySpec;\n\nimport javax.crypto.KeyAgreement;\n\nimport org.bouncycastle.asn1.ASN1InputStream;\nimport org.bouncycastle.asn1.ASN1Integer;\nimport org.bouncycastle.asn1.ASN1ObjectIdentifier;\nimport org.bouncycastle.asn1.ASN1Primitive;\nimport org.bouncycastle.asn1.ASN1Sequence;\nimport org.bouncycastle.asn1.bsi.BSIObjectIdentifiers;\nimport org.bouncycastle.asn1.eac.EACObjectIdentifiers;\nimport org.bouncycastle.asn1.nist.NISTNamedCurves;\nimport org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers;\nimport org.bouncycastle.asn1.pkcs.PrivateKeyInfo;\nimport org.bouncycastle.asn1.sec.SECObjectIdentifiers;\nimport org.bouncycastle.asn1.teletrust.TeleTrusTObjectIdentifiers;\nimport org.bouncycastle.asn1.util.ASN1Dump;\nimport org.bouncycastle.asn1.x509.SubjectPublicKeyInfo;\nimport org.bouncycastle.asn1.x9.X962Parameters;\nimport org.bouncycastle.asn1.x9.X9ECParameters;\nimport org.bouncycastle.asn1.x9.X9ObjectIdentifiers;\nimport org.bouncycastle.jcajce.provider.asymmetric.util.ECUtil;\nimport org.bouncycastle.jcajce.spec.MQVParameterSpec;\nimport org.bouncycastle.jce.ECKeyUtil;\nimport org.bouncycastle.jce.ECNamedCurveTable;\nimport org.bouncycastle.jce.ECPointUtil;\nimport org.bouncycastle.jce.provider.BouncyCastleProvider;\nimport org.bouncycastle.jce.spec.ECNamedCurveParameterSpec;\nimport org.bouncycastle.math.ec.ECCurve;\nimport org.bouncycastle.util.Arrays;\nimport org.bouncycastle.util.BigIntegers;\nimport org.bouncycastle.util.Strings;\nimport org.bouncycastle.util.encoders.Hex;\nimport org.bouncycastle.util.test.FixedSecureRandom;\nimport org.bouncycastle.util.test.SimpleTest;\nimport org.bouncycastle.util.test.TestRandomBigInteger;\n\npublic class ECDSA5Test\n    extends SimpleTest\n{\n    byte[] k1 = Hex.decode(\"d5014e4b60ef2ba8b6211b4062ba3224e0427dd3\");\n    byte[] k2 = Hex.decode(\"345e8d05c075c3a508df729a1685690e68fcfb8c8117847e89063bca1f85d968fd281540b6e13bd1af989a1fbf17e06462bf511f9d0b140fb48ac1b1baa5bded\");\n\n    SecureRandom random = new FixedSecureRandom(\n        new FixedSecureRandom.Source[]{new FixedSecureRandom.Data(k1), new FixedSecureRandom.Data(k2)});\n    static final BigInteger PubX =\n        new BigInteger(\"3390396496586153202365024500890309020181905168626402195853036609\"\n            + \"0984128098564\");\n    static final BigInteger PubY =\n        new BigInteger(\"1135421298983937257390683162600855221890652900790509030911087400\"\n            + \"65052129055287\");\n    static final String[] VALID_SIGNATURES = {\n        \"3045022100b7babae9332b54b8a3a05b7004579821a887a1b21465f7db8a3d49\"\n            + \"1b39fd2c3f0220747291dd2f3f44af7ace68ea33431d6f94e418c106a6e76285\"\n            + \"cd59f43260ecce\",\n    };\n\n    // The following test vectors check for signature malleability and bugs. That means the test\n    // vectors are derived from a valid signature by modifying the ASN encoding. A correct\n    // implementation of ECDSA should only accept correct DER encoding and properly handle the\n    // others (e.g. integer overflow, infinity, redundant parameters, etc). Allowing alternative BER\n    // encodings is in many cases benign. An example where this kind of signature malleability was a\n    // problem: https://en.bitcoin.it/wiki/Transaction_Malleability\n    static final String[] MODIFIED_SIGNATURES = {\n        \"304602812100b7babae9332b54b8a3a05b7004579821a887a1b21465f7db8a3d491b39fd2c3f0220747291dd2f\"\n            + \"3f44af7ace68ea33431d6f94e418c106a6e76285cd59f43260ecce\",\n        \"30470282002100b7babae9332b54b8a3a05b7004579821a887a1b21465f7db8a3d491b39fd2c3f0220747291dd\"\n            + \"2f3f44af7ace68ea33431d6f94e418c106a6e76285cd59f43260ecce\",\n        \"304602220000b7babae9332b54b8a3a05b7004579821a887a1b21465f7db8a3d491b39fd2c3f0220747291dd2f\"\n            + \"3f44af7ace68ea33431d6f94e418c106a6e76285cd59f43260ecce\",\n        \"3046022100b7babae9332b54b8a3a05b7004579821a887a1b21465f7db8a3d491b39fd2c3f028120747291dd2f\"\n            + \"3f44af7ace68ea33431d6f94e418c106a6e76285cd59f43260ecce\",\n        \"3047022100b7babae9332b54b8a3a05b7004579821a887a1b21465f7db8a3d491b39fd2c3f02820020747291dd\"\n            + \"2f3f44af7ace68ea33431d6f94e418c106a6e76285cd59f43260ecce\",\n        \"3046022100b7babae9332b54b8a3a05b7004579821a887a1b21465f7db8a3d491b39fd2c3f022100747291dd2f\"\n            + \"3f44af7ace68ea33431d6f94e418c106a6e76285cd59f43260ecce\",\n        \"308145022100b7babae9332b54b8a3a05b7004579821a887a1b21465f7db8a3d491b39fd2c3f0220747291dd2f\"\n            + \"3f44af7ace68ea33431d6f94e418c106a6e76285cd59f43260ecce\",\n        \"30820045022100b7babae9332b54b8a3a05b7004579821a887a1b21465f7db8a3d491b39fd2c3f0220747291dd\"\n            + \"2f3f44af7ace68ea33431d6f94e418c106a6e76285cd59f43260ecce\",\n        \"3047022100b7babae9332b54b8a3a05b7004579821a887a1b21465f7db8a3d491b39fd2c3f0220747291dd2f3f\"\n            + \"44af7ace68ea33431d6f94e418c106a6e76285cd59f43260ecce3000\",\n        \"3047022100b7babae9332b54b8a3a05b7004579821a887a1b21465f7db8a3d491b39fd2c3f0220747291dd2f3f\"\n            + \"44af7ace68ea33431d6f94e418c106a6e76285cd59f43260ecce1000\",\n        \"3047022100b7babae9332b54b8a3a05b7004579821a887a1b21465f7db8a3d491b39fd2c3f0220747291dd2f3f\"\n            + \"44af7ace68ea33431d6f94e418c106a6e76285cd59f43260ecce0000\",\n        \"3045022100b7babae9332b54b8a3a05b7004579821a887a1b21465f7db8a3d491b39fd2c3f0220747291dd2f3f\"\n            + \"44af7ace68ea33431d6f94e418c106a6e76285cd59f43260ecce0000\",\n        \"3048022100b7babae9332b54b8a3a05b7004579821a887a1b21465f7db8a3d491b39fd2c3f0220747291dd2f3f\"\n            + \"44af7ace68ea33431d6f94e418c106a6e76285cd59f43260ecce058100\",\n        \"3049022100b7babae9332b54b8a3a05b7004579821a887a1b21465f7db8a3d491b39fd2c3f0220747291dd2f3f\"\n            + \"44af7ace68ea33431d6f94e418c106a6e76285cd59f43260ecce05820000\",\n        \"3047022100b7babae9332b54b8a3a05b7004579821a887a1b21465f7db8a3d491b39fd2c3f0220747291dd2f3f\"\n            + \"44af7ace68ea33431d6f94e418c106a6e76285cd59f43260ecce1100\",\n        \"3047022100b7babae9332b54b8a3a05b7004579821a887a1b21465f7db8a3d491b39fd2c3f0220747291dd2f3f\"\n            + \"44af7ace68ea33431d6f94e418c106a6e76285cd59f43260ecce0500\",\n        \"3047022100b7babae9332b54b8a3a05b7004579821a887a1b21465f7db8a3d491b39fd2c3f0220747291dd2f3f\"\n            + \"44af7ace68ea33431d6f94e418c106a6e76285cd59f43260ecce2500\",\n        \"3067022100b7babae9332b54b8a3a05b7004579821a887a1b21465f7db8a3d491b39fd2c3f0220747291dd2f3f\"\n            + \"44af7ace68ea33431d6f94e418c106a6e76285cd59f43260ecce0220747291dd2f3f44af7ace68ea33431d6f\"\n            + \"94e418c106a6e76285cd59f43260ecce\"\n    };\n\n    private void testModified()\n        throws Exception\n    {\n        ECNamedCurveParameterSpec namedCurve = ECNamedCurveTable.getParameterSpec(\"P-256\");\n        org.bouncycastle.jce.spec.ECPublicKeySpec pubSpec = new org.bouncycastle.jce.spec.ECPublicKeySpec(namedCurve.getCurve().createPoint(PubX, PubY), namedCurve);\n        KeyFactory kFact = KeyFactory.getInstance(\"EC\", \"BC\");\n        PublicKey pubKey = kFact.generatePublic(pubSpec);\n        Signature sig = Signature.getInstance(\"SHA256WithECDSA\", \"BC\");\n\n        for (int i = 0; i != MODIFIED_SIGNATURES.length; i++)\n        {\n            sig.initVerify(pubKey);\n\n            sig.update(Strings.toByteArray(\"Hello\"));\n\n            boolean failed;\n\n            try\n            {\n                failed = !sig.verify(Hex.decode(MODIFIED_SIGNATURES[i]));\n                System.err.println(ASN1Dump.dumpAsString(ASN1Primitive.fromByteArray(Hex.decode(MODIFIED_SIGNATURES[i]))));\n            }\n            catch (SignatureException e)\n            {\n                failed = true;\n            }\n\n            isTrue(\"sig verified when shouldn't: \" + i, failed);\n        }\n    }\n\n    private void decodeTest()\n    {\n        EllipticCurve curve = new EllipticCurve(\n            new ECFieldFp(new BigInteger(\"6277101735386680763835789423207666416083908700390324961279\")), // q\n            new BigInteger(\"fffffffffffffffffffffffffffffffefffffffffffffffc\", 16), // a\n            new BigInteger(\"64210519e59c80e70fa7e9ab72243049feb8deecc146b9b1\", 16)); // b\n\n        ECPoint p = ECPointUtil.decodePoint(curve, Hex.decode(\"03188da80eb03090f67cbf20eb43a18800f4ff0afd82ff1012\"));\n\n        if (!p.getAffineX().equals(new BigInteger(\"188da80eb03090f67cbf20eb43a18800f4ff0afd82ff1012\", 16)))\n        {\n            fail(\"x uncompressed incorrectly\");\n        }\n\n        if (!p.getAffineY().equals(new BigInteger(\"7192b95ffc8da78631011ed6b24cdd573f977a11e794811\", 16)))\n        {\n            fail(\"y uncompressed incorrectly\");\n        }\n    }\n\n    /**\n     * X9.62 - 1998,<br>\n     * J.3.2, Page 155, ECDSA over the field Fp<br>\n     * an example with 239 bit prime\n     */\n    private void testECDSA239bitPrime()\n        throws Exception\n    {\n        BigInteger r = new BigInteger(\"308636143175167811492622547300668018854959378758531778147462058306432176\");\n        BigInteger s = new BigInteger(\"323813553209797357708078776831250505931891051755007842781978505179448783\");\n\n        byte[] kData = BigIntegers.asUnsignedByteArray(new BigInteger(\"700000017569056646655505781757157107570501575775705779575555657156756655\"));\n\n        SecureRandom k = new TestRandomBigInteger(kData);\n\n        EllipticCurve curve = new EllipticCurve(\n            new ECFieldFp(new BigInteger(\"883423532389192164791648750360308885314476597252960362792450860609699839\")), // q\n            new BigInteger(\"7fffffffffffffffffffffff7fffffffffff8000000000007ffffffffffc\", 16), // a\n            new BigInteger(\"6b016c3bdcf18941d0d654921475ca71a9db2fb27d1d37796185c2942c0a\", 16)); // b\n\n        ECParameterSpec spec = new ECParameterSpec(\n            curve,\n            ECPointUtil.decodePoint(curve, Hex.decode(\"020ffa963cdca8816ccc33b8642bedf905c3d358573d3f27fbbd3b3cb9aaaf\")), // G\n            new BigInteger(\"883423532389192164791648750360308884807550341691627752275345424702807307\"), // n\n            1); // h\n\n\n        ECPrivateKeySpec priKey = new ECPrivateKeySpec(\n            new BigInteger(\"876300101507107567501066130761671078357010671067781776716671676178726717\"), // d\n            spec);\n\n        ECPublicKeySpec pubKey = new ECPublicKeySpec(\n            ECPointUtil.decodePoint(curve, Hex.decode(\"025b6dc53bc61a2548ffb0f671472de6c9521a9d2d2534e65abfcbd5fe0c70\")), // Q\n            spec);\n\n        Signature sgr = Signature.getInstance(\"ECDSA\", \"BC\");\n        KeyFactory f = KeyFactory.getInstance(\"ECDSA\", \"BC\");\n        PrivateKey sKey = f.generatePrivate(priKey);\n        PublicKey vKey = f.generatePublic(pubKey);\n\n        sgr.initSign(sKey, k);\n\n        byte[] message = new byte[]{(byte)'a', (byte)'b', (byte)'c'};\n\n        sgr.update(message);\n\n        byte[] sigBytes = sgr.sign();\n\n        sgr.initVerify(vKey);\n\n        sgr.update(message);\n\n        if (!sgr.verify(sigBytes))\n        {\n            fail(\"239 Bit EC verification failed\");\n        }\n\n        BigInteger[] sig = derDecode(sigBytes);\n\n        if (!r.equals(sig[0]))\n        {\n            fail(\"r component wrong.\" + Strings.lineSeparator()\n                + \" expecting: \" + r + Strings.lineSeparator()\n                + \" got      : \" + sig[0]);\n        }\n\n        if (!s.equals(sig[1]))\n        {\n            fail(\"s component wrong.\" + Strings.lineSeparator()\n                + \" expecting: \" + s + Strings.lineSeparator()\n                + \" got      : \" + sig[1]);\n        }\n    }\n\n    // test BSI algorithm support.\n    private void testBSI()\n        throws Exception\n    {\n        KeyPairGenerator kpGen = KeyPairGenerator.getInstance(\"ECDSA\", \"BC\");\n\n        kpGen.initialize(new ECGenParameterSpec(TeleTrusTObjectIdentifiers.brainpoolP512r1.getId()));\n\n        KeyPair kp = kpGen.generateKeyPair();\n\n        byte[] data = \"Hello World!!!\".getBytes();\n        String[] cvcAlgs = {\"SHA1WITHCVC-ECDSA\", \"SHA224WITHCVC-ECDSA\",\n            \"SHA256WITHCVC-ECDSA\", \"SHA384WITHCVC-ECDSA\",\n            \"SHA512WITHCVC-ECDSA\"};\n        String[] cvcOids = {EACObjectIdentifiers.id_TA_ECDSA_SHA_1.getId(), EACObjectIdentifiers.id_TA_ECDSA_SHA_224.getId(),\n            EACObjectIdentifiers.id_TA_ECDSA_SHA_256.getId(), EACObjectIdentifiers.id_TA_ECDSA_SHA_384.getId(),\n            EACObjectIdentifiers.id_TA_ECDSA_SHA_512.getId()};\n\n        testBsiAlgorithms(kp, data, cvcAlgs, cvcOids);\n\n        String[] plainAlgs = {\"SHA1WITHPLAIN-ECDSA\", \"SHA224WITHPLAIN-ECDSA\",\n            \"SHA256WITHPLAIN-ECDSA\", \"SHA384WITHPLAIN-ECDSA\",\n            \"SHA512WITHPLAIN-ECDSA\", \"RIPEMD160WITHPLAIN-ECDSA\"};\n        String[] plainOids = {BSIObjectIdentifiers.ecdsa_plain_SHA1.getId(), BSIObjectIdentifiers.ecdsa_plain_SHA224.getId(),\n            BSIObjectIdentifiers.ecdsa_plain_SHA256.getId(), BSIObjectIdentifiers.ecdsa_plain_SHA384.getId(),\n            BSIObjectIdentifiers.ecdsa_plain_SHA512.getId(), BSIObjectIdentifiers.ecdsa_plain_RIPEMD160.getId()};\n\n        testBsiAlgorithms(kp, data, plainAlgs, plainOids);\n    }\n\n    private void testBsiAlgorithms(KeyPair kp, byte[] data, String[] algs, String[] oids)\n        throws NoSuchAlgorithmException, NoSuchProviderException, InvalidKeyException, SignatureException\n    {\n        for (int i = 0; i != algs.length; i++)\n        {\n            Signature sig1 = Signature.getInstance(algs[i], \"BC\");\n            Signature sig2 = Signature.getInstance(oids[i], \"BC\");\n\n            sig1.initSign(kp.getPrivate());\n\n            sig1.update(data);\n\n            byte[] sig = sig1.sign();\n\n            sig2.initVerify(kp.getPublic());\n\n            sig2.update(data);\n\n            if (!sig2.verify(sig))\n            {\n                fail(\"BSI CVC signature failed: \" + algs[i]);\n            }\n        }\n    }\n\n    /**\n     * X9.62 - 1998,<br>\n     * J.2.1, Page 100, ECDSA over the field F2m<br>\n     * an example with 191 bit binary field\n     */\n    private void testECDSA239bitBinary()\n        throws Exception\n    {\n        BigInteger r = new BigInteger(\"21596333210419611985018340039034612628818151486841789642455876922391552\");\n        BigInteger s = new BigInteger(\"197030374000731686738334997654997227052849804072198819102649413465737174\");\n\n        byte[] kData = BigIntegers.asUnsignedByteArray(new BigInteger(\"171278725565216523967285789236956265265265235675811949404040041670216363\"));\n\n        SecureRandom k = new TestRandomBigInteger(kData);\n\n        EllipticCurve curve = new EllipticCurve(\n            new ECFieldF2m(239, // m\n                new int[]{36}), // k\n            new BigInteger(\"32010857077C5431123A46B808906756F543423E8D27877578125778AC76\", 16), // a\n            new BigInteger(\"790408F2EEDAF392B012EDEFB3392F30F4327C0CA3F31FC383C422AA8C16\", 16)); // b\n\n        ECParameterSpec params = new ECParameterSpec(\n            curve,\n            ECPointUtil.decodePoint(curve, Hex.decode(\"0457927098FA932E7C0A96D3FD5B706EF7E5F5C156E16B7E7C86038552E91D61D8EE5077C33FECF6F1A16B268DE469C3C7744EA9A971649FC7A9616305\")), // G\n            new BigInteger(\"220855883097298041197912187592864814557886993776713230936715041207411783\"), // n\n            4); // h\n\n        ECPrivateKeySpec priKeySpec = new ECPrivateKeySpec(\n            new BigInteger(\"145642755521911534651321230007534120304391871461646461466464667494947990\"), // d\n            params);\n\n        ECPublicKeySpec pubKeySpec = new ECPublicKeySpec(\n            ECPointUtil.decodePoint(curve, Hex.decode(\"045894609CCECF9A92533F630DE713A958E96C97CCB8F5ABB5A688A238DEED6DC2D9D0C94EBFB7D526BA6A61764175B99CB6011E2047F9F067293F57F5\")), // Q\n            params);\n\n        Signature sgr = Signature.getInstance(\"ECDSA\", \"BC\");\n        KeyFactory f = KeyFactory.getInstance(\"ECDSA\", \"BC\");\n        PrivateKey sKey = f.generatePrivate(priKeySpec);\n        PublicKey vKey = f.generatePublic(pubKeySpec);\n        byte[] message = new byte[]{(byte)'a', (byte)'b', (byte)'c'};\n\n        sgr.initSign(sKey, k);\n\n        sgr.update(message);\n\n        byte[] sigBytes = sgr.sign();\n\n        sgr.initVerify(vKey);\n\n        sgr.update(message);\n\n        if (!sgr.verify(sigBytes))\n        {\n            fail(\"239 Bit EC verification failed\");\n        }\n\n        BigInteger[] sig = derDecode(sigBytes);\n\n        if (!r.equals(sig[0]))\n        {\n            fail(\"r component wrong.\" + Strings.lineSeparator()\n                + \" expecting: \" + r + Strings.lineSeparator()\n                + \" got      : \" + sig[0]);\n        }\n\n        if (!s.equals(sig[1]))\n        {\n            fail(\"s component wrong.\" + Strings.lineSeparator()\n                + \" expecting: \" + s + Strings.lineSeparator()\n                + \" got      : \" + sig[1]);\n        }\n    }\n\n    private void testGeneration()\n        throws Exception\n    {\n        //\n        // ECDSA generation test\n        //\n        byte[] data = {1, 2, 3, 4, 5, 6, 7, 8, 9, 0};\n        Signature s = Signature.getInstance(\"ECDSA\", \"BC\");\n        KeyPairGenerator g = KeyPairGenerator.getInstance(\"ECDSA\", \"BC\");\n\n        EllipticCurve curve = new EllipticCurve(\n            new ECFieldFp(new BigInteger(\"883423532389192164791648750360308885314476597252960362792450860609699839\")), // q\n            new BigInteger(\"7fffffffffffffffffffffff7fffffffffff8000000000007ffffffffffc\", 16), // a\n            new BigInteger(\"6b016c3bdcf18941d0d654921475ca71a9db2fb27d1d37796185c2942c0a\", 16)); // b\n\n        ECParameterSpec ecSpec = new ECParameterSpec(\n            curve,\n            ECPointUtil.decodePoint(curve, Hex.decode(\"020ffa963cdca8816ccc33b8642bedf905c3d358573d3f27fbbd3b3cb9aaaf\")), // G\n            new BigInteger(\"883423532389192164791648750360308884807550341691627752275345424702807307\"), // n\n            1); // h\n\n        g.initialize(ecSpec, new SecureRandom());\n\n        KeyPair p = g.generateKeyPair();\n\n        PrivateKey sKey = p.getPrivate();\n        PublicKey vKey = p.getPublic();\n\n        s.initSign(sKey);\n\n        s.update(data);\n\n        byte[] sigBytes = s.sign();\n\n        s = Signature.getInstance(\"ECDSA\", \"BC\");\n\n        s.initVerify(vKey);\n\n        s.update(data);\n\n        if (!s.verify(sigBytes))\n        {\n            fail(\"ECDSA verification failed\");\n        }\n\n        testKeyFactory((ECPublicKey)vKey, (ECPrivateKey)sKey);\n        testSerialise((ECPublicKey)vKey, (ECPrivateKey)sKey);\n    }\n\n    private void testSerialise(ECPublicKey ecPublicKey, ECPrivateKey ecPrivateKey)\n        throws Exception\n    {\n        ByteArrayOutputStream bOut = new ByteArrayOutputStream();\n        ObjectOutputStream oOut = new ObjectOutputStream(bOut);\n\n        oOut.writeObject(ecPublicKey);\n        oOut.writeObject(ecPrivateKey);\n        oOut.close();\n\n        ObjectInputStream oIn = new ObjectInputStream(new ByteArrayInputStream(bOut.toByteArray()));\n\n        PublicKey pubKey = (PublicKey)oIn.readObject();\n        PrivateKey privKey = (PrivateKey)oIn.readObject();\n\n        if (!ecPublicKey.equals(pubKey))\n        {\n            fail(\"public key serialisation check failed\");\n        }\n\n        if (!ecPrivateKey.equals(privKey))\n        {\n            fail(\"private key serialisation check failed\");\n        }\n    }\n\n    private void testKeyFactory(ECPublicKey pub, ECPrivateKey priv)\n        throws Exception\n    {\n        KeyFactory ecFact = KeyFactory.getInstance(\"ECDSA\");\n\n        ECPublicKeySpec pubSpec = (ECPublicKeySpec)ecFact.getKeySpec(pub, ECPublicKeySpec.class);\n        ECPrivateKeySpec privSpec = (ECPrivateKeySpec)ecFact.getKeySpec(priv, ECPrivateKeySpec.class);\n\n        if (!pubSpec.getW().equals(pub.getW()) || !pubSpec.getParams().getCurve().equals(pub.getParams().getCurve()))\n        {\n            fail(\"pubSpec not correct\");\n        }\n\n        if (!privSpec.getS().equals(priv.getS()) || !privSpec.getParams().getCurve().equals(priv.getParams().getCurve()))\n        {\n            fail(\"privSpec not correct\");\n        }\n\n        ECPublicKey pubKey = (ECPublicKey)ecFact.translateKey(pub);\n        ECPrivateKey privKey = (ECPrivateKey)ecFact.translateKey(priv);\n\n        if (!pubKey.getW().equals(pub.getW()) || !pubKey.getParams().getCurve().equals(pub.getParams().getCurve()))\n        {\n            fail(\"pubKey not correct\");\n        }\n\n        if (!privKey.getS().equals(priv.getS()) || !privKey.getParams().getCurve().equals(priv.getParams().getCurve()))\n        {\n            fail(\"privKey not correct\");\n        }\n    }\n\n    private void testKeyConversion()\n        throws Exception\n    {\n        KeyPairGenerator kpGen = KeyPairGenerator.getInstance(\"ECDSA\", \"BC\");\n\n        kpGen.initialize(new ECGenParameterSpec(\"prime192v1\"));\n\n        KeyPair pair = kpGen.generateKeyPair();\n\n        PublicKey pubKey = ECKeyUtil.publicToExplicitParameters(pair.getPublic(), \"BC\");\n\n        SubjectPublicKeyInfo info = SubjectPublicKeyInfo.getInstance(ASN1Primitive.fromByteArray(pubKey.getEncoded()));\n        X962Parameters params = X962Parameters.getInstance(info.getAlgorithmId().getParameters());\n\n        if (params.isNamedCurve() || params.isImplicitlyCA())\n        {\n            fail(\"public key conversion to explicit failed\");\n        }\n\n        if (!((ECPublicKey)pair.getPublic()).getW().equals(((ECPublicKey)pubKey).getW()))\n        {\n            fail(\"public key conversion check failed\");\n        }\n\n        PrivateKey privKey = ECKeyUtil.privateToExplicitParameters(pair.getPrivate(), \"BC\");\n        PrivateKeyInfo privInfo = PrivateKeyInfo.getInstance(ASN1Primitive.fromByteArray(privKey.getEncoded()));\n        params = X962Parameters.getInstance(privInfo.getAlgorithmId().getParameters());\n\n        if (params.isNamedCurve() || params.isImplicitlyCA())\n        {\n            fail(\"private key conversion to explicit failed\");\n        }\n\n        if (!((ECPrivateKey)pair.getPrivate()).getS().equals(((ECPrivateKey)privKey).getS()))\n        {\n            fail(\"private key conversion check failed\");\n        }\n    }\n\n    private void testAdaptiveKeyConversion()\n        throws Exception\n    {\n        KeyPairGenerator kpGen = KeyPairGenerator.getInstance(\"ECDSA\", \"BC\");\n\n        kpGen.initialize(new ECGenParameterSpec(\"prime192v1\"));\n\n        KeyPair pair = kpGen.generateKeyPair();\n\n        final PrivateKey privKey = pair.getPrivate();\n        final PublicKey pubKey = pair.getPublic();\n\n        Signature s = Signature.getInstance(\"ECDSA\", \"BC\");\n\n        // raw interface tests\n        s.initSign(new PrivateKey()\n        {\n            public String getAlgorithm()\n            {\n                return privKey.getAlgorithm();\n            }\n\n            public String getFormat()\n            {\n                return privKey.getFormat();\n            }\n\n            public byte[] getEncoded()\n            {\n                return privKey.getEncoded();\n            }\n        });\n\n        s.initVerify(new PublicKey()\n        {\n            public String getAlgorithm()\n            {\n                return pubKey.getAlgorithm();\n            }\n\n            public String getFormat()\n            {\n                return pubKey.getFormat();\n            }\n\n            public byte[] getEncoded()\n            {\n                return pubKey.getEncoded();\n            }\n        });\n\n\n        s.initSign(new ECPrivateKey()\n        {\n            public String getAlgorithm()\n            {\n                return privKey.getAlgorithm();\n            }\n\n            public String getFormat()\n            {\n                return privKey.getFormat();\n            }\n\n            public byte[] getEncoded()\n            {\n                return privKey.getEncoded();\n            }\n\n            public BigInteger getS()\n            {\n                return ((ECPrivateKey)privKey).getS();\n            }\n\n            public ECParameterSpec getParams()\n            {\n                return ((ECPrivateKey)privKey).getParams();\n            }\n        });\n\n        s.initVerify(new ECPublicKey()\n        {\n            public String getAlgorithm()\n            {\n                return pubKey.getAlgorithm();\n            }\n\n            public String getFormat()\n            {\n                return pubKey.getFormat();\n            }\n\n            public byte[] getEncoded()\n            {\n                return pubKey.getEncoded();\n            }\n\n            public ECPoint getW()\n            {\n                return ((ECPublicKey)pubKey).getW();\n            }\n\n            public ECParameterSpec getParams()\n            {\n                return ((ECPublicKey)pubKey).getParams();\n            }\n        });\n\n        try\n        {\n            s.initSign(new PrivateKey()\n            {\n                public String getAlgorithm()\n                {\n                    return privKey.getAlgorithm();\n                }\n\n                public String getFormat()\n                {\n                    return privKey.getFormat();\n                }\n\n                public byte[] getEncoded()\n                {\n                    return null;\n                }\n            });\n\n            fail(\"no exception thrown!!!\");\n        }\n        catch (InvalidKeyException e)\n        {\n            // ignore\n        }\n\n        try\n        {\n            s.initVerify(new PublicKey()\n            {\n                public String getAlgorithm()\n                {\n                    return pubKey.getAlgorithm();\n                }\n\n                public String getFormat()\n                {\n                    return pubKey.getFormat();\n                }\n\n                public byte[] getEncoded()\n                {\n                    return null;\n                }\n            });\n\n            fail(\"no exception thrown!!!\");\n        }\n        catch (InvalidKeyException e)\n        {\n            // ignore\n        }\n\n        // try bogus encoding\n        try\n        {\n            s.initSign(new PrivateKey()\n            {\n                public String getAlgorithm()\n                {\n                    return privKey.getAlgorithm();\n                }\n\n                public String getFormat()\n                {\n                    return privKey.getFormat();\n                }\n\n                public byte[] getEncoded()\n                {\n                    return new byte[20];\n                }\n            });\n\n            fail(\"no exception thrown!!!\");\n        }\n        catch (InvalidKeyException e)\n        {\n            // ignore\n        }\n\n        try\n        {\n            s.initVerify(new PublicKey()\n            {\n                public String getAlgorithm()\n                {\n                    return pubKey.getAlgorithm();\n                }\n\n                public String getFormat()\n                {\n                    return pubKey.getFormat();\n                }\n\n                public byte[] getEncoded()\n                {\n                    return new byte[20];\n                }\n            });\n\n            fail(\"no exception thrown!!!\");\n        }\n        catch (InvalidKeyException e)\n        {\n            // ignore\n        }\n\n        // try encoding of wrong key\n        kpGen = KeyPairGenerator.getInstance(\"RSA\", \"BC\");\n\n        kpGen.initialize(512);\n\n        pair = kpGen.generateKeyPair();\n\n        final PrivateKey privRsa = pair.getPrivate();\n        final PublicKey pubRsa = pair.getPublic();\n\n        try\n        {\n            s.initSign(new PrivateKey()\n            {\n                public String getAlgorithm()\n                {\n                    return privRsa.getAlgorithm();\n                }\n\n                public String getFormat()\n                {\n                    return privRsa.getFormat();\n                }\n\n                public byte[] getEncoded()\n                {\n                    return privRsa.getEncoded();\n                }\n            });\n\n            fail(\"no exception thrown!!!\");\n\n        }\n        catch (InvalidKeyException e)\n        {\n            // ignore\n        }\n\n        try\n        {\n            s.initVerify(new PublicKey()\n            {\n                public String getAlgorithm()\n                {\n                    return pubRsa.getAlgorithm();\n                }\n\n                public String getFormat()\n                {\n                    return pubRsa.getFormat();\n                }\n\n                public byte[] getEncoded()\n                {\n                    return pubRsa.getEncoded();\n                }\n            });\n\n            fail(\"no exception thrown!!!\");\n        }\n        catch (InvalidKeyException e)\n        {\n            // ignore\n        }\n    }\n\n    private void testAlgorithmParameters()\n        throws Exception\n    {\n        AlgorithmParameters algParam = AlgorithmParameters.getInstance(\"EC\", \"BC\");\n\n        algParam.init(new ECGenParameterSpec(\"P-256\"));\n\n        byte[] encoded = algParam.getEncoded();\n\n        algParam = AlgorithmParameters.getInstance(\"EC\", \"BC\");\n\n        algParam.init(encoded);\n\n        ECGenParameterSpec genSpec = algParam.getParameterSpec(ECGenParameterSpec.class);\n\n        if (!genSpec.getName().equals(X9ObjectIdentifiers.prime256v1.getId()))\n        {\n            fail(\"curve name not recovered\");\n        }\n\n        ECParameterSpec ecSpec = algParam.getParameterSpec(ECParameterSpec.class);\n\n        if (!ecSpec.getOrder().equals(NISTNamedCurves.getByName(\"P-256\").getN()))\n        {\n            fail(\"incorrect spec recovered\");\n        }\n    }\n\n    private void testKeyPairGenerationWithOIDs()\n        throws Exception\n    {\n        KeyPairGenerator kpGen = KeyPairGenerator.getInstance(\"ECDSA\", \"BC\");\n\n        kpGen.initialize(new ECGenParameterSpec(X9ObjectIdentifiers.prime192v1.getId()));\n        kpGen.initialize(new ECGenParameterSpec(TeleTrusTObjectIdentifiers.brainpoolP160r1.getId()));\n        kpGen.initialize(new ECGenParameterSpec(SECObjectIdentifiers.secp128r1.getId()));\n\n        try\n        {\n            kpGen.initialize(new ECGenParameterSpec(\"1.1\"));\n\n            fail(\"non-existant curve OID failed\");\n        }\n        catch (InvalidAlgorithmParameterException e)\n        {\n            if (!\"unknown curve OID: 1.1\".equals(e.getMessage()))\n            {\n                fail(\"OID message check failed\");\n            }\n        }\n\n        try\n        {\n            kpGen.initialize(new ECGenParameterSpec(\"flibble\"));\n\n            fail(\"non-existant curve name failed\");\n        }\n        catch (InvalidAlgorithmParameterException e)\n        {\n            if (!\"unknown curve name: flibble\".equals(e.getMessage()))\n            {\n                fail(\"name message check failed\");\n            }\n        }\n    }\n\n    private static class ECRandom\n        extends SecureRandom\n    {\n        public void nextBytes(byte[] bytes)\n        {\n            byte[] src = new BigInteger(\"e2eb6663f551331bda00b90f1272c09d980260c1a70cab1ec481f6c937f34b62\", 16).toByteArray();\n\n            if (src.length <= bytes.length)\n            {\n                System.arraycopy(src, 0, bytes, bytes.length - src.length, src.length);\n            }\n            else\n            {\n                System.arraycopy(src, 0, bytes, 0, bytes.length);\n            }\n        }\n    }\n\n    private void testNamedCurveParameterPreservation()\n        throws Exception\n    {\n        AlgorithmParameterSpec ecSpec = ECNamedCurveTable.getParameterSpec(\"secp256r1\");\n        KeyPairGenerator keygen = KeyPairGenerator.getInstance(\"EC\", \"BC\");\n        keygen.initialize(ecSpec, new ECRandom());\n\n        KeyPair keys = keygen.generateKeyPair();\n\n        PrivateKeyInfo priv1 = PrivateKeyInfo.getInstance(keys.getPrivate().getEncoded());\n        SubjectPublicKeyInfo pub1 = SubjectPublicKeyInfo.getInstance(keys.getPublic().getEncoded());\n\n        keygen = KeyPairGenerator.getInstance(\"EC\", \"BC\");\n        keygen.initialize(new ECGenParameterSpec(\"secp256r1\"), new ECRandom());\n\n        PrivateKeyInfo priv2 = PrivateKeyInfo.getInstance(keys.getPrivate().getEncoded());\n        SubjectPublicKeyInfo pub2 = SubjectPublicKeyInfo.getInstance(keys.getPublic().getEncoded());\n\n        if (!priv1.equals(priv2) || !pub1.equals(pub2))\n        {\n            fail(\"mismatch between alg param spec and ECGenParameterSpec\");\n        }\n\n        if (!(priv2.getPrivateKeyAlgorithm().getParameters() instanceof ASN1ObjectIdentifier))\n        {\n            fail(\"OID not preserved in private key\");\n        }\n\n        if (!(pub1.getAlgorithm().getParameters() instanceof ASN1ObjectIdentifier))\n        {\n            fail(\"OID not preserved in public key\");\n        }\n    }\n\n    private void testNamedCurveSigning()\n        throws Exception\n    {\n        testCustomNamedCurveSigning(\"secp256r1\");\n\n        try\n        {\n            testCustomNamedCurveSigning(\"secp256k1\");\n        }\n        catch (IllegalArgumentException e)\n        {\n            if (!e.getMessage().equals(\"first coefficient is negative\"))     // bogus jdk 1.5 exception...\n            {\n                throw e;\n            }\n        }\n    }\n\n    private void testCustomNamedCurveSigning(String name)\n        throws Exception\n    {\n        X9ECParameters x9Params = ECUtil.getNamedCurveByOid(ECUtil.getNamedCurveOid(name));\n\n        // TODO: one day this may have to change\n        if (x9Params.getCurve() instanceof ECCurve.Fp)\n        {\n            fail(\"curve not custom curve!!\");\n        }\n\n        AlgorithmParameterSpec ecSpec = ECNamedCurveTable.getParameterSpec(name);\n        KeyPairGenerator keygen = KeyPairGenerator.getInstance(\"EC\", \"BC\");\n        keygen.initialize(ecSpec, new ECRandom());\n\n        KeyPair keys = keygen.generateKeyPair();\n\n        PrivateKeyInfo priv1 = PrivateKeyInfo.getInstance(keys.getPrivate().getEncoded());\n        SubjectPublicKeyInfo pub1 = SubjectPublicKeyInfo.getInstance(keys.getPublic().getEncoded());\n\n        keygen = KeyPairGenerator.getInstance(\"EC\", \"BC\");\n        keygen.initialize(new ECGenParameterSpec(\"secp256r1\"), new ECRandom());\n\n        Signature ecdsaSigner = Signature.getInstance(\"ECDSA\", \"BC\");\n\n        ecdsaSigner.initSign(keys.getPrivate());\n\n        ecdsaSigner.update(new byte[100]);\n\n        byte[] sig = ecdsaSigner.sign();\n\n        ecdsaSigner.initVerify(keys.getPublic());\n\n        ecdsaSigner.update(new byte[100]);\n\n        if (!ecdsaSigner.verify(sig))\n        {\n            fail(\"signature failed to verify\");\n        }\n\n        KeyFactory kFact = KeyFactory.getInstance(\"EC\", \"BC\");\n\n        PublicKey pub = kFact.generatePublic(new X509EncodedKeySpec(pub1.getEncoded()));\n        PrivateKey pri = kFact.generatePrivate(new PKCS8EncodedKeySpec(priv1.getEncoded()));\n\n        ecdsaSigner = Signature.getInstance(\"ECDSA\", \"BC\");\n\n        ecdsaSigner.initSign(pri);\n\n        ecdsaSigner.update(new byte[100]);\n\n        sig = ecdsaSigner.sign();\n\n        ecdsaSigner.initVerify(pub);\n\n        ecdsaSigner.update(new byte[100]);\n\n        if (!ecdsaSigner.verify(sig))\n        {\n            fail(\"signature failed to verify\");\n        }\n    }\n\n    /**\n     * COUNT = 1\n     * dsCAVS = 00000179557decd75b797bea9db656ce99c03a6e0ab13804b5b589644f7db41ceba05c3940c300361061074ca72a828428d9198267fa0b75e1e3e785a0ff20e839414be0\n     * QsCAVSx = 000001ce7da31681d5f176f3618f205969b9142520363dd26a596866c89988c932e3ce01904d12d1e9b105462e56163dbe7658ba3c472bf1f3c8165813295393ae346764\n     * QsCAVSy = 000000e70d6e55b76ebd362ff071ab819315593cec650276209a9fdc2c1c48e03c35945f04e74d958cabd3f5e4d1f096a991e807a8f9d217de306a6b561038ca15aea4b9\n     * NonceEphemCAVS = 4214a1a0a1d11679ae22f98d7ae483c1a74008a9cd7f7cf71b1f373a4226f5c58eb621ec56e2537797c01750dcbff07f613b9c58774f9af32aebeadd2226140dc7d56b1aa95c93ab1ec4412e2d0e42cdaac7bf9da3ddbf19fbb1edd0556d9c5a339808905fe8defd8b57ff8f34788192cc0cf7df17d1f351d69ac979a3a495931c287fb8\n     * dsIUT = 000000c14895dfcc5a6b24994828cfd0a0cc0a881a70173a3eb05c57b098046c8e60a868f6176284aa346eff1fd1b8b879052c5a6d5fd0ae146b35ed7ecee32e294103cd\n     * QsIUTx = 00000174a658695049db59f6bbe2ad23e1753bf58384a56fc9b3dec13eb873b33e1f4dbd24b6b4ca05a9a11ad531f6d99e9430a774980e8a8d9fd2d1e2a0d76fe3dd36c7\n     * QsIUTy = 00000030639849e1df341973db44e7bbba5bb597884a439f9ce54620c3ca73a9804cc26fcda3aaf73ae5a11d5b325cae0e95cfafe1985c6c2fdb892722e7dd2c5d744cf3\n     * deIUT = 00000138f54e986c7b44f49da389fa9f61bb7265f0cebdeddf09d47c72e55186e2520965fc2c31bb9c0a557e3c28e02a751f097e413c4252c7b0d22452d89f9ac314bc6e\n     * QeIUTx = 000001b9fbce9c9ebb31070a4a4ac7af54ec9189c1f98948cd24ca0a5029217e4784d3c8692da08a6a512d1c9875d20d8e03664c148fa5d34bbac6d42e499ee5dbf01120\n     * QeIUTy = 000000994a714b6d09afa896dbba9b4f436ab3cdb0d11dcd2aad28b7ba35d6fa6be537b6ffb0f9bf5fe1d594b8f8b8829687c9395c3d938c873f26c7100888c3aca2d59a\n     * OI = a1b2c3d4e54341565369646dbb63a273c81e0aad02f92699bf7baa28fd4509145b0096746894e98e209a85ecb415b8\n     * CAVSTag = 4ade5dc983cc1cf61c90fdbf726fa6a88e9bf411bbaf0015db06ff4348560e4d\n     * Z = 019a19a0a99f60221ee23323b3317292e8c10d57ba04e0b33f6241979ec3895945eed0bdcbc59ab576e7047061f0d63d1aaf78b1d442028605aa1c0f963a3bc9d61a\n     * MacData = 4b435f315f55a1b2c3d4e543415653696401b9fbce9c9ebb31070a4a4ac7af54ec9189c1f98948cd24ca0a5029217e4784d3c8692da08a6a512d1c9875d20d8e03664c148fa5d34bbac6d42e499ee5dbf0112000994a714b6d09afa896dbba9b4f436ab3cdb0d11dcd2aad28b7ba35d6fa6be537b6ffb0f9bf5fe1d594b8f8b8829687c9395c3d938c873f26c7100888c3aca2d59a4214a1a0a1d11679ae22f98d7ae483c1a74008a9cd7f7cf71b1f373a4226f5c58eb621ec56e2537797c01750dcbff07f613b9c58774f9af32aebeadd2226140dc7d56b1aa95c93ab1ec4412e2d0e42cdaac7bf9da3ddbf19fbb1edd0556d9c5a339808905fe8defd8b57ff8f34788192cc0cf7df17d1f351d69ac979a3a495931c287fb8\n     * DKM = 0744e1774149a8b8f88d3a1e20ac1517efd2f54ba4b5f178de99f33b68eea426\n     * Result = P (14 - DKM value should have leading 0 nibble )\n     */\n    public void testMQVwithHMACOnePass()\n        throws Exception\n    {\n        AlgorithmParameters algorithmParameters = AlgorithmParameters.getInstance(\"EC\", \"BC\");\n\n        algorithmParameters.init(new ECGenParameterSpec(\"P-521\"));\n\n        ECParameterSpec ecSpec = algorithmParameters.getParameterSpec(ECParameterSpec.class);\n        KeyFactory keyFact = KeyFactory.getInstance(\"EC\", \"BC\");\n\n        ECPrivateKey dsCAVS = (ECPrivateKey)keyFact.generatePrivate(new ECPrivateKeySpec(new BigInteger(\"00000179557decd75b797bea9db656ce99c03a6e0ab13804b5b589644f7db41ceba05c3940c300361061074ca72a828428d9198267fa0b75e1e3e785a0ff20e839414be0\", 16), ecSpec));\n        ECPublicKey qsCAVS = (ECPublicKey)keyFact.generatePublic(new ECPublicKeySpec(new ECPoint(\n            new BigInteger(\"000001ce7da31681d5f176f3618f205969b9142520363dd26a596866c89988c932e3ce01904d12d1e9b105462e56163dbe7658ba3c472bf1f3c8165813295393ae346764\", 16),\n            new BigInteger(\"000000e70d6e55b76ebd362ff071ab819315593cec650276209a9fdc2c1c48e03c35945f04e74d958cabd3f5e4d1f096a991e807a8f9d217de306a6b561038ca15aea4b9\", 16)), ecSpec));\n\n        ECPrivateKey dsIUT = (ECPrivateKey)keyFact.generatePrivate(new ECPrivateKeySpec(new BigInteger(\"000000c14895dfcc5a6b24994828cfd0a0cc0a881a70173a3eb05c57b098046c8e60a868f6176284aa346eff1fd1b8b879052c5a6d5fd0ae146b35ed7ecee32e294103cd\", 16), ecSpec));\n        ECPublicKey qsIUT = (ECPublicKey)keyFact.generatePublic(new ECPublicKeySpec(new ECPoint(\n            new BigInteger(\"00000174a658695049db59f6bbe2ad23e1753bf58384a56fc9b3dec13eb873b33e1f4dbd24b6b4ca05a9a11ad531f6d99e9430a774980e8a8d9fd2d1e2a0d76fe3dd36c7\", 16),\n            new BigInteger(\"00000030639849e1df341973db44e7bbba5bb597884a439f9ce54620c3ca73a9804cc26fcda3aaf73ae5a11d5b325cae0e95cfafe1985c6c2fdb892722e7dd2c5d744cf3\", 16)), ecSpec));\n\n        ECPrivateKey deIUT = (ECPrivateKey)keyFact.generatePrivate(new ECPrivateKeySpec(new BigInteger(\"00000138f54e986c7b44f49da389fa9f61bb7265f0cebdeddf09d47c72e55186e2520965fc2c31bb9c0a557e3c28e02a751f097e413c4252c7b0d22452d89f9ac314bc6e\", 16), ecSpec));\n        ECPublicKey qeIUT = (ECPublicKey)keyFact.generatePublic(new ECPublicKeySpec(new ECPoint(\n            new BigInteger(\"000001b9fbce9c9ebb31070a4a4ac7af54ec9189c1f98948cd24ca0a5029217e4784d3c8692da08a6a512d1c9875d20d8e03664c148fa5d34bbac6d42e499ee5dbf01120\", 16),\n            new BigInteger(\"000000994a714b6d09afa896dbba9b4f436ab3cdb0d11dcd2aad28b7ba35d6fa6be537b6ffb0f9bf5fe1d594b8f8b8829687c9395c3d938c873f26c7100888c3aca2d59a\", 16)), ecSpec));\n\n        KeyAgreement uAgree = KeyAgreement.getInstance(\"ECMQVwithSHA512CKDF\", \"BC\");\n\n        uAgree.init(dsCAVS, new MQVParameterSpec(dsCAVS, qeIUT, Hex.decode(\"a1b2c3d4e54341565369646dbb63a273c81e0aad02f92699bf7baa28fd4509145b0096746894e98e209a85ecb415b8\")));\n\n\n        KeyAgreement vAgree = KeyAgreement.getInstance(\"ECMQVwithSHA512CKDF\", \"BC\");\n        vAgree.init(dsIUT, new MQVParameterSpec(deIUT, qsCAVS, Hex.decode(\"a1b2c3d4e54341565369646dbb63a273c81e0aad02f92699bf7baa28fd4509145b0096746894e98e209a85ecb415b8\")));\n\n        //\n        // agreement\n        //\n        uAgree.doPhase(qsIUT, true);\n        vAgree.doPhase(qsCAVS, true);\n\n        byte[] ux = uAgree.generateSecret(PKCSObjectIdentifiers.id_hmacWithSHA512.getId()).getEncoded();\n        byte[] vx = vAgree.generateSecret(PKCSObjectIdentifiers.id_hmacWithSHA512.getId()).getEncoded();\n\n        if (!Arrays.areEqual(ux, vx))\n        {\n            fail(\"agreement values don't match\");\n        }\n\n        if (!Arrays.areEqual(Hex.decode(\"0744e1774149a8b8f88d3a1e20ac1517efd2f54ba4b5f178de99f33b68eea426\"), Arrays.copyOfRange(ux, 0, 32)))\n        {\n            fail(\"agreement values not correct\");\n        }\n    }\n\n    protected BigInteger[] derDecode(\n        byte[] encoding)\n        throws IOException\n    {\n        ByteArrayInputStream bIn = new ByteArrayInputStream(encoding);\n        ASN1InputStream aIn = new ASN1InputStream(bIn);\n        ASN1Sequence s = (ASN1Sequence)aIn.readObject();\n\n        BigInteger[] sig = new BigInteger[2];\n\n        sig[0] = ((ASN1Integer)s.getObjectAt(0)).getValue();\n        sig[1] = ((ASN1Integer)s.getObjectAt(1)).getValue();\n\n        return sig;\n    }\n\n    public String getName()\n    {\n        return \"ECDSA5\";\n    }\n\n    public void performTest()\n        throws Exception\n    {\n//        testKeyConversion();\n//        testAdaptiveKeyConversion();\n//        decodeTest();\n//        testECDSA239bitPrime();\n//        testECDSA239bitBinary();\n//        testGeneration();\n//        testKeyPairGenerationWithOIDs();\n//        testNamedCurveParameterPreservation();\n//        testNamedCurveSigning();\n//        testBSI();\n//        testMQVwithHMACOnePass();\n//        testAlgorithmParameters();\n        testModified();\n    }\n\n    public static void main(\n        String[] args)\n    {\n        Security.addProvider(new BouncyCastleProvider());\n\n        runTest(new ECDSA5Test());\n    }\n}\n"], "filenames": ["core/src/main/java/org/bouncycastle/asn1/ASN1Enumerated.java", "core/src/main/java/org/bouncycastle/asn1/ASN1Integer.java", "core/src/test/java/org/bouncycastle/asn1/test/MiscTest.java", "prov/src/main/java/org/bouncycastle/jcajce/provider/asymmetric/dsa/DSASigner.java", "prov/src/main/java/org/bouncycastle/jcajce/provider/asymmetric/ec/SignatureSpi.java", "prov/src/test/java/org/bouncycastle/jce/provider/test/DSATest.java", "prov/src/test/java/org/bouncycastle/jce/provider/test/ECDSA5Test.java"], "buggy_code_start_loc": [101, 91, 7, 31, 26, 146, 50], "buggy_code_end_loc": [101, 91, 117, 182, 369, 147, 1041], "fixing_code_start_loc": [102, 92, 8, 32, 25, 146, 51], "fixing_code_end_loc": [113, 103, 161, 188, 379, 148, 1132], "type": "CWE-347", "message": "In the Bouncy Castle JCE Provider version 1.55 and earlier ECDSA does not fully validate ASN.1 encoding of signature on verification. It is possible to inject extra elements in the sequence making up the signature and still have it validate, which in some cases may allow the introduction of 'invisible' data into a signed structure.", "other": {"cve": {"id": "CVE-2016-1000342", "sourceIdentifier": "cve@mitre.org", "published": "2018-06-04T13:29:00.387", "lastModified": "2020-10-20T22:15:17.357", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "In the Bouncy Castle JCE Provider version 1.55 and earlier ECDSA does not fully validate ASN.1 encoding of signature on verification. It is possible to inject extra elements in the sequence making up the signature and still have it validate, which in some cases may allow the introduction of 'invisible' data into a signed structure."}, {"lang": "es", "value": "En Bouncy Castle JCE Provider en versiones 1.55 y anteriores, el ECDSA no valida completamente el cifrado ASN.1 de la firma en verificaci\u00f3n. Es posible inyectar elementos extra en la secuencia que forma la firma y, a\u00fan as\u00ed, validarla. En algunos casos, esto podr\u00eda permitir la introducci\u00f3n de datos \"invisibles\" en una estructura firmada."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-347"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:bouncycastle:legion-of-the-bouncy-castle-java-crytography-api:*:*:*:*:*:*:*:*", "versionEndIncluding": "1.55", "matchCriteriaId": "946393A6-EEE2-4502-9309-81514DB5755B"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}]}]}], "references": [{"url": "https://access.redhat.com/errata/RHSA-2018:2669", "source": "cve@mitre.org"}, {"url": "https://access.redhat.com/errata/RHSA-2018:2927", "source": "cve@mitre.org"}, {"url": "https://github.com/bcgit/bc-java/commit/843c2e60f67d71faf81d236f448ebbe56c62c647#diff-25c3c78db788365f36839b3f2d3016b9", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2018/07/msg00009.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20181127-0004/", "source": "cve@mitre.org"}, {"url": "https://usn.ubuntu.com/3727-1/", "source": "cve@mitre.org"}, {"url": "https://www.oracle.com/security-alerts/cpuoct2020.html", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/bcgit/bc-java/commit/843c2e60f67d71faf81d236f448ebbe56c62c647#diff-25c3c78db788365f36839b3f2d3016b9"}}