{"buggy_code": ["// Code generated by Wire. DO NOT EDIT.\n\n//go:generate go run github.com/google/wire/cmd/wire\n//go:build !wireinject\n// +build !wireinject\n\npackage answercmd\n\nimport (\n\t\"github.com/answerdev/answer/internal/base/conf\"\n\t\"github.com/answerdev/answer/internal/base/cron\"\n\t\"github.com/answerdev/answer/internal/base/data\"\n\t\"github.com/answerdev/answer/internal/base/middleware\"\n\t\"github.com/answerdev/answer/internal/base/server\"\n\t\"github.com/answerdev/answer/internal/base/translator\"\n\t\"github.com/answerdev/answer/internal/controller\"\n\t\"github.com/answerdev/answer/internal/controller/template_render\"\n\t\"github.com/answerdev/answer/internal/controller_admin\"\n\t\"github.com/answerdev/answer/internal/repo/activity\"\n\t\"github.com/answerdev/answer/internal/repo/activity_common\"\n\t\"github.com/answerdev/answer/internal/repo/answer\"\n\t\"github.com/answerdev/answer/internal/repo/auth\"\n\t\"github.com/answerdev/answer/internal/repo/captcha\"\n\t\"github.com/answerdev/answer/internal/repo/collection\"\n\t\"github.com/answerdev/answer/internal/repo/comment\"\n\t\"github.com/answerdev/answer/internal/repo/config\"\n\t\"github.com/answerdev/answer/internal/repo/export\"\n\t\"github.com/answerdev/answer/internal/repo/meta\"\n\t\"github.com/answerdev/answer/internal/repo/notification\"\n\t\"github.com/answerdev/answer/internal/repo/plugin_config\"\n\t\"github.com/answerdev/answer/internal/repo/question\"\n\t\"github.com/answerdev/answer/internal/repo/rank\"\n\t\"github.com/answerdev/answer/internal/repo/reason\"\n\t\"github.com/answerdev/answer/internal/repo/report\"\n\t\"github.com/answerdev/answer/internal/repo/revision\"\n\t\"github.com/answerdev/answer/internal/repo/role\"\n\t\"github.com/answerdev/answer/internal/repo/search_common\"\n\t\"github.com/answerdev/answer/internal/repo/site_info\"\n\t\"github.com/answerdev/answer/internal/repo/tag\"\n\t\"github.com/answerdev/answer/internal/repo/tag_common\"\n\t\"github.com/answerdev/answer/internal/repo/unique\"\n\t\"github.com/answerdev/answer/internal/repo/user\"\n\t\"github.com/answerdev/answer/internal/repo/user_external_login\"\n\t\"github.com/answerdev/answer/internal/router\"\n\t\"github.com/answerdev/answer/internal/service\"\n\t\"github.com/answerdev/answer/internal/service/action\"\n\tactivity2 \"github.com/answerdev/answer/internal/service/activity\"\n\tactivity_common2 \"github.com/answerdev/answer/internal/service/activity_common\"\n\t\"github.com/answerdev/answer/internal/service/activity_queue\"\n\t\"github.com/answerdev/answer/internal/service/answer_common\"\n\tauth2 \"github.com/answerdev/answer/internal/service/auth\"\n\t\"github.com/answerdev/answer/internal/service/collection_common\"\n\tcomment2 \"github.com/answerdev/answer/internal/service/comment\"\n\t\"github.com/answerdev/answer/internal/service/comment_common\"\n\tconfig2 \"github.com/answerdev/answer/internal/service/config\"\n\t\"github.com/answerdev/answer/internal/service/dashboard\"\n\texport2 \"github.com/answerdev/answer/internal/service/export\"\n\t\"github.com/answerdev/answer/internal/service/follow\"\n\tmeta2 \"github.com/answerdev/answer/internal/service/meta\"\n\t\"github.com/answerdev/answer/internal/service/notice_queue\"\n\tnotification2 \"github.com/answerdev/answer/internal/service/notification\"\n\t\"github.com/answerdev/answer/internal/service/notification_common\"\n\t\"github.com/answerdev/answer/internal/service/object_info\"\n\t\"github.com/answerdev/answer/internal/service/plugin_common\"\n\t\"github.com/answerdev/answer/internal/service/question_common\"\n\trank2 \"github.com/answerdev/answer/internal/service/rank\"\n\treason2 \"github.com/answerdev/answer/internal/service/reason\"\n\treport2 \"github.com/answerdev/answer/internal/service/report\"\n\t\"github.com/answerdev/answer/internal/service/report_admin\"\n\t\"github.com/answerdev/answer/internal/service/report_handle_admin\"\n\t\"github.com/answerdev/answer/internal/service/revision_common\"\n\trole2 \"github.com/answerdev/answer/internal/service/role\"\n\t\"github.com/answerdev/answer/internal/service/search_parser\"\n\t\"github.com/answerdev/answer/internal/service/service_config\"\n\t\"github.com/answerdev/answer/internal/service/siteinfo\"\n\t\"github.com/answerdev/answer/internal/service/siteinfo_common\"\n\ttag2 \"github.com/answerdev/answer/internal/service/tag\"\n\ttag_common2 \"github.com/answerdev/answer/internal/service/tag_common\"\n\t\"github.com/answerdev/answer/internal/service/uploader\"\n\t\"github.com/answerdev/answer/internal/service/user_admin\"\n\t\"github.com/answerdev/answer/internal/service/user_common\"\n\tuser_external_login2 \"github.com/answerdev/answer/internal/service/user_external_login\"\n\t\"github.com/segmentfault/pacman\"\n\t\"github.com/segmentfault/pacman/log\"\n)\n\n// Injectors from wire.go:\n\n// initApplication init application.\nfunc initApplication(debug bool, serverConf *conf.Server, dbConf *data.Database, cacheConf *data.CacheConf, i18nConf *translator.I18n, swaggerConf *router.SwaggerConfig, serviceConf *service_config.ServiceConfig, logConf log.Logger) (*pacman.Application, func(), error) {\n\tstaticRouter := router.NewStaticRouter(serviceConf)\n\ti18nTranslator, err := translator.NewTranslator(i18nConf)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tengine, err := data.NewDB(debug, dbConf)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tcache, cleanup, err := data.NewCache(cacheConf)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tdataData, cleanup2, err := data.NewData(engine, cache)\n\tif err != nil {\n\t\tcleanup()\n\t\treturn nil, nil, err\n\t}\n\tsiteInfoRepo := site_info.NewSiteInfo(dataData)\n\tsiteInfoCommonService := siteinfo_common.NewSiteInfoCommonService(siteInfoRepo)\n\tlangController := controller.NewLangController(i18nTranslator, siteInfoCommonService)\n\tauthRepo := auth.NewAuthRepo(dataData)\n\tauthService := auth2.NewAuthService(authRepo)\n\tuserRepo := user.NewUserRepo(dataData)\n\tuniqueIDRepo := unique.NewUniqueIDRepo(dataData)\n\tconfigRepo := config.NewConfigRepo(dataData)\n\tconfigService := config2.NewConfigService(configRepo)\n\tactivityRepo := activity_common.NewActivityRepo(dataData, uniqueIDRepo, configService)\n\tuserRankRepo := rank.NewUserRankRepo(dataData, configService)\n\tuserActiveActivityRepo := activity.NewUserActiveActivityRepo(dataData, activityRepo, userRankRepo, configService)\n\temailRepo := export.NewEmailRepo(dataData)\n\temailService := export2.NewEmailService(configService, emailRepo, siteInfoRepo)\n\tuserRoleRelRepo := role.NewUserRoleRelRepo(dataData)\n\troleRepo := role.NewRoleRepo(dataData)\n\troleService := role2.NewRoleService(roleRepo)\n\tuserRoleRelService := role2.NewUserRoleRelService(userRoleRelRepo, roleService)\n\tuserCommon := usercommon.NewUserCommon(userRepo, userRoleRelService, authService, siteInfoCommonService)\n\tuserExternalLoginRepo := user_external_login.NewUserExternalLoginRepo(dataData)\n\tuserExternalLoginService := user_external_login2.NewUserExternalLoginService(userRepo, userCommon, userExternalLoginRepo, emailService, siteInfoCommonService, userActiveActivityRepo)\n\tuserService := service.NewUserService(userRepo, userActiveActivityRepo, activityRepo, emailService, authService, siteInfoCommonService, userRoleRelService, userCommon, userExternalLoginService)\n\tcaptchaRepo := captcha.NewCaptchaRepo(dataData)\n\tcaptchaService := action.NewCaptchaService(captchaRepo)\n\tuserController := controller.NewUserController(authService, userService, captchaService, emailService, siteInfoCommonService)\n\tcommentRepo := comment.NewCommentRepo(dataData, uniqueIDRepo)\n\tcommentCommonRepo := comment.NewCommentCommonRepo(dataData, uniqueIDRepo)\n\tanswerRepo := answer.NewAnswerRepo(dataData, uniqueIDRepo, userRankRepo, activityRepo)\n\tquestionRepo := question.NewQuestionRepo(dataData, uniqueIDRepo)\n\ttagCommonRepo := tag_common.NewTagCommonRepo(dataData, uniqueIDRepo)\n\ttagRelRepo := tag.NewTagRelRepo(dataData, uniqueIDRepo)\n\ttagRepo := tag.NewTagRepo(dataData, uniqueIDRepo)\n\trevisionRepo := revision.NewRevisionRepo(dataData, uniqueIDRepo)\n\trevisionService := revision_common.NewRevisionService(revisionRepo, userRepo)\n\tactivityQueueService := activity_queue.NewActivityQueueService()\n\ttagCommonService := tag_common2.NewTagCommonService(tagCommonRepo, tagRelRepo, tagRepo, revisionService, siteInfoCommonService, activityQueueService)\n\tobjService := object_info.NewObjService(answerRepo, questionRepo, commentCommonRepo, tagCommonRepo, tagCommonService)\n\tvoteRepo := activity_common.NewVoteRepo(dataData, activityRepo)\n\tnotificationQueueService := notice_queue.NewNotificationQueueService()\n\tcommentService := comment2.NewCommentService(commentRepo, commentCommonRepo, userCommon, objService, voteRepo, emailService, userRepo, notificationQueueService, activityQueueService)\n\trolePowerRelRepo := role.NewRolePowerRelRepo(dataData)\n\trolePowerRelService := role2.NewRolePowerRelService(rolePowerRelRepo, userRoleRelService)\n\trankService := rank2.NewRankService(userCommon, userRankRepo, objService, userRoleRelService, rolePowerRelService, configService)\n\tcommentController := controller.NewCommentController(commentService, rankService)\n\treportRepo := report.NewReportRepo(dataData, uniqueIDRepo)\n\treportService := report2.NewReportService(reportRepo, objService)\n\treportController := controller.NewReportController(reportService, rankService)\n\tserviceVoteRepo := activity.NewVoteRepo(dataData, uniqueIDRepo, configService, activityRepo, userRankRepo, voteRepo, notificationQueueService)\n\tvoteService := service.NewVoteService(serviceVoteRepo, uniqueIDRepo, configService, questionRepo, answerRepo, commentCommonRepo, objService)\n\tvoteController := controller.NewVoteController(voteService, rankService)\n\tfollowRepo := activity_common.NewFollowRepo(dataData, uniqueIDRepo, activityRepo)\n\ttagService := tag2.NewTagService(tagRepo, tagCommonService, revisionService, followRepo, siteInfoCommonService, activityQueueService)\n\ttagController := controller.NewTagController(tagService, tagCommonService, rankService)\n\tfollowFollowRepo := activity.NewFollowRepo(dataData, uniqueIDRepo, activityRepo)\n\tfollowService := follow.NewFollowService(followFollowRepo, followRepo, tagCommonRepo)\n\tfollowController := controller.NewFollowController(followService)\n\tcollectionRepo := collection.NewCollectionRepo(dataData, uniqueIDRepo)\n\tcollectionGroupRepo := collection.NewCollectionGroupRepo(dataData)\n\tcollectionCommon := collectioncommon.NewCollectionCommon(collectionRepo)\n\tanswerCommon := answercommon.NewAnswerCommon(answerRepo)\n\tmetaRepo := meta.NewMetaRepo(dataData)\n\tmetaService := meta2.NewMetaService(metaRepo)\n\tquestionCommon := questioncommon.NewQuestionCommon(questionRepo, answerRepo, voteRepo, followRepo, tagCommonService, userCommon, collectionCommon, answerCommon, metaService, configService, activityQueueService, dataData)\n\tcollectionService := service.NewCollectionService(collectionRepo, collectionGroupRepo, questionCommon)\n\tcollectionController := controller.NewCollectionController(collectionService)\n\tanswerActivityRepo := activity.NewAnswerActivityRepo(dataData, activityRepo, userRankRepo, notificationQueueService)\n\tquestionActivityRepo := activity.NewQuestionActivityRepo(dataData, activityRepo, userRankRepo)\n\tanswerActivityService := activity2.NewAnswerActivityService(answerActivityRepo, questionActivityRepo)\n\tquestionService := service.NewQuestionService(questionRepo, tagCommonService, questionCommon, userCommon, userRepo, revisionService, metaService, collectionCommon, answerActivityService, emailService, notificationQueueService, activityQueueService, siteInfoCommonService)\n\tanswerService := service.NewAnswerService(answerRepo, questionRepo, questionCommon, userCommon, collectionCommon, userRepo, revisionService, answerActivityService, answerCommon, voteRepo, emailService, userRoleRelService, notificationQueueService, activityQueueService)\n\tquestionController := controller.NewQuestionController(questionService, answerService, rankService, siteInfoCommonService)\n\tanswerController := controller.NewAnswerController(answerService, rankService)\n\tsearchParser := search_parser.NewSearchParser(tagCommonService, userCommon)\n\tsearchRepo := search_common.NewSearchRepo(dataData, uniqueIDRepo, userCommon)\n\tsearchService := service.NewSearchService(searchParser, searchRepo)\n\tsearchController := controller.NewSearchController(searchService)\n\tserviceRevisionService := service.NewRevisionService(revisionRepo, userCommon, questionCommon, answerService, objService, questionRepo, answerRepo, tagRepo, tagCommonService, notificationQueueService, activityQueueService)\n\trevisionController := controller.NewRevisionController(serviceRevisionService, rankService)\n\trankController := controller.NewRankController(rankService)\n\treportHandle := report_handle_admin.NewReportHandle(questionCommon, commentRepo, configService, notificationQueueService)\n\treportAdminService := report_admin.NewReportAdminService(reportRepo, userCommon, answerRepo, questionRepo, commentCommonRepo, reportHandle, configService, objService)\n\tcontroller_adminReportController := controller_admin.NewReportController(reportAdminService)\n\tuserAdminRepo := user.NewUserAdminRepo(dataData, authRepo)\n\tuserAdminService := user_admin.NewUserAdminService(userAdminRepo, userRoleRelService, authService, userCommon, userActiveActivityRepo, siteInfoCommonService)\n\tuserAdminController := controller_admin.NewUserAdminController(userAdminService)\n\treasonRepo := reason.NewReasonRepo(configService)\n\treasonService := reason2.NewReasonService(reasonRepo)\n\treasonController := controller.NewReasonController(reasonService)\n\tthemeController := controller_admin.NewThemeController()\n\tsiteInfoService := siteinfo.NewSiteInfoService(siteInfoRepo, siteInfoCommonService, emailService, tagCommonService, configService, questionCommon)\n\tsiteInfoController := controller_admin.NewSiteInfoController(siteInfoService)\n\tcontrollerSiteInfoController := controller.NewSiteInfoController(siteInfoCommonService)\n\tnotificationRepo := notification.NewNotificationRepo(dataData)\n\tnotificationCommon := notificationcommon.NewNotificationCommon(dataData, notificationRepo, userCommon, activityRepo, followRepo, objService, notificationQueueService)\n\tnotificationService := notification2.NewNotificationService(dataData, notificationRepo, notificationCommon, revisionService)\n\tnotificationController := controller.NewNotificationController(notificationService, rankService)\n\tdashboardService := dashboard.NewDashboardService(questionRepo, answerRepo, commentCommonRepo, voteRepo, userRepo, reportRepo, configService, siteInfoCommonService, serviceConf, dataData)\n\tdashboardController := controller.NewDashboardController(dashboardService)\n\tuploaderService := uploader.NewUploaderService(serviceConf, siteInfoCommonService)\n\tuploadController := controller.NewUploadController(uploaderService)\n\tactivityCommon := activity_common2.NewActivityCommon(activityRepo, activityQueueService)\n\tactivityActivityRepo := activity.NewActivityRepo(dataData, configService)\n\tcommentCommonService := comment_common.NewCommentCommonService(commentCommonRepo)\n\tactivityService := activity2.NewActivityService(activityActivityRepo, userCommon, activityCommon, tagCommonService, objService, commentCommonService, revisionService, metaService, configService)\n\tactivityController := controller.NewActivityController(activityCommon, activityService)\n\troleController := controller_admin.NewRoleController(roleService)\n\tpluginConfigRepo := plugin_config.NewPluginConfigRepo(dataData)\n\tpluginCommonService := plugin_common.NewPluginCommonService(pluginConfigRepo, configService)\n\tpluginController := controller_admin.NewPluginController(pluginCommonService)\n\tpermissionController := controller.NewPermissionController(rankService)\n\tanswerAPIRouter := router.NewAnswerAPIRouter(langController, userController, commentController, reportController, voteController, tagController, followController, collectionController, questionController, answerController, searchController, revisionController, rankController, controller_adminReportController, userAdminController, reasonController, themeController, siteInfoController, controllerSiteInfoController, notificationController, dashboardController, uploadController, activityController, roleController, pluginController, permissionController)\n\tswaggerRouter := router.NewSwaggerRouter(swaggerConf)\n\tuiRouter := router.NewUIRouter(controllerSiteInfoController, siteInfoCommonService)\n\tauthUserMiddleware := middleware.NewAuthUserMiddleware(authService, siteInfoCommonService)\n\tavatarMiddleware := middleware.NewAvatarMiddleware(serviceConf, uploaderService)\n\tshortIDMiddleware := middleware.NewShortIDMiddleware(siteInfoCommonService)\n\ttemplateRenderController := templaterender.NewTemplateRenderController(questionService, userService, tagService, answerService, commentService, siteInfoCommonService, questionRepo)\n\ttemplateController := controller.NewTemplateController(templateRenderController, siteInfoCommonService)\n\ttemplateRouter := router.NewTemplateRouter(templateController, templateRenderController, siteInfoController)\n\tconnectorController := controller.NewConnectorController(siteInfoCommonService, emailService, userExternalLoginService)\n\tuserCenterLoginService := user_external_login2.NewUserCenterLoginService(userRepo, userCommon, userExternalLoginRepo, userActiveActivityRepo, siteInfoCommonService)\n\tuserCenterController := controller.NewUserCenterController(userCenterLoginService, siteInfoCommonService)\n\tpluginAPIRouter := router.NewPluginAPIRouter(connectorController, userCenterController)\n\tginEngine := server.NewHTTPServer(debug, staticRouter, answerAPIRouter, swaggerRouter, uiRouter, authUserMiddleware, avatarMiddleware, shortIDMiddleware, templateRouter, pluginAPIRouter)\n\tscheduledTaskManager := cron.NewScheduledTaskManager(siteInfoCommonService, questionService)\n\tapplication := newApplication(serverConf, ginEngine, scheduledTaskManager)\n\treturn application, func() {\n\t\tcleanup2()\n\t\tcleanup()\n\t}, nil\n}\n", "package controller\n\nimport (\n\t\"github.com/answerdev/answer/internal/base/handler\"\n\t\"github.com/answerdev/answer/internal/base/middleware\"\n\t\"github.com/answerdev/answer/internal/base/reason\"\n\t\"github.com/answerdev/answer/internal/base/translator\"\n\t\"github.com/answerdev/answer/internal/schema\"\n\t\"github.com/answerdev/answer/internal/service\"\n\t\"github.com/answerdev/answer/internal/service/rank\"\n\t\"github.com/answerdev/answer/pkg/uid\"\n\t\"github.com/gin-gonic/gin\"\n\t\"github.com/jinzhu/copier\"\n\t\"github.com/segmentfault/pacman/errors\"\n)\n\n// VoteController activity controller\ntype VoteController struct {\n\tVoteService *service.VoteService\n\trankService *rank.RankService\n}\n\n// NewVoteController new controller\nfunc NewVoteController(voteService *service.VoteService, rankService *rank.RankService) *VoteController {\n\treturn &VoteController{VoteService: voteService, rankService: rankService}\n}\n\n// VoteUp godoc\n// @Summary vote up\n// @Description add vote\n// @Tags Activity\n// @Accept json\n// @Produce json\n// @Security ApiKeyAuth\n// @Param data body schema.VoteReq true \"vote\"\n// @Success 200 {object} handler.RespBody{data=schema.VoteResp}\n// @Router /answer/api/v1/vote/up [post]\nfunc (vc *VoteController) VoteUp(ctx *gin.Context) {\n\treq := &schema.VoteReq{}\n\tif handler.BindAndCheck(ctx, req) {\n\t\treturn\n\t}\n\treq.ObjectID = uid.DeShortID(req.ObjectID)\n\treq.UserID = middleware.GetLoginUserIDFromContext(ctx)\n\tcan, needRank, err := vc.rankService.CheckVotePermission(ctx, req.UserID, req.ObjectID, true)\n\tif err != nil {\n\t\thandler.HandleResponse(ctx, err, nil)\n\t\treturn\n\t}\n\tif !can {\n\t\tlang := handler.GetLang(ctx)\n\t\tmsg := translator.TrWithData(lang, reason.NoEnoughRankToOperate, &schema.PermissionTrTplData{Rank: needRank})\n\t\thandler.HandleResponse(ctx, errors.Forbidden(reason.NoEnoughRankToOperate).WithMsg(msg), nil)\n\t\treturn\n\t}\n\n\tdto := &schema.VoteDTO{}\n\t_ = copier.Copy(dto, req)\n\tresp, err := vc.VoteService.VoteUp(ctx, dto)\n\tif err != nil {\n\t\thandler.HandleResponse(ctx, err, schema.ErrTypeToast)\n\t} else {\n\t\thandler.HandleResponse(ctx, err, resp)\n\t}\n}\n\n// VoteDown godoc\n// @Summary vote down\n// @Description add vote\n// @Tags Activity\n// @Accept json\n// @Produce json\n// @Security ApiKeyAuth\n// @Param data body schema.VoteReq true \"vote\"\n// @Success 200 {object} handler.RespBody{data=schema.VoteResp}\n// @Router /answer/api/v1/vote/down [post]\nfunc (vc *VoteController) VoteDown(ctx *gin.Context) {\n\treq := &schema.VoteReq{}\n\tif handler.BindAndCheck(ctx, req) {\n\t\treturn\n\t}\n\treq.ObjectID = uid.DeShortID(req.ObjectID)\n\treq.UserID = middleware.GetLoginUserIDFromContext(ctx)\n\tcan, needRank, err := vc.rankService.CheckVotePermission(ctx, req.UserID, req.ObjectID, false)\n\tif err != nil {\n\t\thandler.HandleResponse(ctx, err, nil)\n\t\treturn\n\t}\n\tif !can {\n\t\tlang := handler.GetLang(ctx)\n\t\tmsg := translator.TrWithData(lang, reason.NoEnoughRankToOperate, &schema.PermissionTrTplData{Rank: needRank})\n\t\thandler.HandleResponse(ctx, errors.Forbidden(reason.NoEnoughRankToOperate).WithMsg(msg), nil)\n\t\treturn\n\t}\n\n\tdto := &schema.VoteDTO{}\n\t_ = copier.Copy(dto, req)\n\tresp, err := vc.VoteService.VoteDown(ctx, dto)\n\tif err != nil {\n\t\thandler.HandleResponse(ctx, err, schema.ErrTypeToast)\n\t} else {\n\t\thandler.HandleResponse(ctx, err, resp)\n\t}\n}\n\n// UserVotes user votes\n// @Summary get user personal votes\n// @Description get user personal votes\n// @Tags Activity\n// @Accept json\n// @Produce json\n// @Security ApiKeyAuth\n// @Param page query int false \"page size\"\n// @Param page_size query int false \"page size\"\n// @Success 200 {object} handler.RespBody{data=pager.PageModel{list=[]schema.GetVoteWithPageResp}}\n// @Router /answer/api/v1/personal/vote/page [get]\nfunc (vc *VoteController) UserVotes(ctx *gin.Context) {\n\treq := schema.GetVoteWithPageReq{}\n\tif handler.BindAndCheck(ctx, &req) {\n\t\treturn\n\t}\n\n\treq.UserID = middleware.GetLoginUserIDFromContext(ctx)\n\n\tresp, err := vc.VoteService.ListUserVotes(ctx, req)\n\thandler.HandleResponse(ctx, err, resp)\n}\n", "package activity\n\nimport (\n\t\"context\"\n\t\"time\"\n\n\t\"github.com/answerdev/answer/internal/base/constant\"\n\t\"github.com/answerdev/answer/internal/base/data\"\n\t\"github.com/answerdev/answer/internal/base/reason\"\n\t\"github.com/answerdev/answer/internal/entity\"\n\t\"github.com/answerdev/answer/internal/schema\"\n\t\"github.com/answerdev/answer/internal/service/activity\"\n\t\"github.com/answerdev/answer/internal/service/activity_common\"\n\t\"github.com/answerdev/answer/internal/service/notice_queue\"\n\t\"github.com/answerdev/answer/internal/service/rank\"\n\t\"github.com/answerdev/answer/pkg/converter\"\n\t\"github.com/segmentfault/pacman/errors\"\n\t\"github.com/segmentfault/pacman/log\"\n\t\"xorm.io/xorm\"\n)\n\nvar (\n\tacceptActionList = []string{constant.ActAccept, constant.ActAccepted}\n)\n\n// AnswerActivityRepo answer accepted\ntype AnswerActivityRepo struct {\n\tdata                     *data.Data\n\tactivityRepo             activity_common.ActivityRepo\n\tuserRankRepo             rank.UserRankRepo\n\tnotificationQueueService notice_queue.NotificationQueueService\n}\n\n// NewAnswerActivityRepo new repository\nfunc NewAnswerActivityRepo(\n\tdata *data.Data,\n\tactivityRepo activity_common.ActivityRepo,\n\tuserRankRepo rank.UserRankRepo,\n\tnotificationQueueService notice_queue.NotificationQueueService,\n) activity.AnswerActivityRepo {\n\treturn &AnswerActivityRepo{\n\t\tdata:                     data,\n\t\tactivityRepo:             activityRepo,\n\t\tuserRankRepo:             userRankRepo,\n\t\tnotificationQueueService: notificationQueueService,\n\t}\n}\n\n// NewQuestionActivityRepo new repository\nfunc NewQuestionActivityRepo(\n\tdata *data.Data,\n\tactivityRepo activity_common.ActivityRepo,\n\tuserRankRepo rank.UserRankRepo,\n) activity.QuestionActivityRepo {\n\treturn &AnswerActivityRepo{\n\t\tdata:         data,\n\t\tactivityRepo: activityRepo,\n\t\tuserRankRepo: userRankRepo,\n\t}\n}\n\nfunc (ar *AnswerActivityRepo) DeleteQuestion(ctx context.Context, questionID string) (err error) {\n\tquestionInfo := &entity.Question{}\n\texist, err := ar.data.DB.Context(ctx).Where(\"id = ?\", questionID).Get(questionInfo)\n\tif err != nil {\n\t\treturn errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()\n\t}\n\tif !exist {\n\t\treturn nil\n\t}\n\n\t// get all this object activity\n\tactivityList := make([]*entity.Activity, 0)\n\tsession := ar.data.DB.Context(ctx).Where(\"has_rank = 1\")\n\tsession.Where(\"cancelled = ?\", entity.ActivityAvailable)\n\terr = session.Find(&activityList, &entity.Activity{ObjectID: questionID})\n\tif err != nil {\n\t\treturn errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()\n\t}\n\tif len(activityList) == 0 {\n\t\treturn nil\n\t}\n\n\tlog.Infof(\"questionInfo %s deleted will rollback activity %d\", questionID, len(activityList))\n\n\t_, err = ar.data.DB.Transaction(func(session *xorm.Session) (result any, err error) {\n\t\tsession = session.Context(ctx)\n\t\tfor _, act := range activityList {\n\t\t\tlog.Infof(\"user %s rollback rank %d\", act.UserID, -act.Rank)\n\t\t\t_, e := ar.userRankRepo.TriggerUserRank(\n\t\t\t\tctx, session, act.UserID, -act.Rank, act.ActivityType)\n\t\t\tif e != nil {\n\t\t\t\treturn nil, errors.InternalServer(reason.DatabaseError).WithError(e).WithStack()\n\t\t\t}\n\n\t\t\tif _, e := session.Where(\"id = ?\", act.ID).Cols(\"cancelled\", \"cancelled_at\").\n\t\t\t\tUpdate(&entity.Activity{Cancelled: entity.ActivityCancelled, CancelledAt: time.Now()}); e != nil {\n\t\t\t\treturn nil, errors.InternalServer(reason.DatabaseError).WithError(e).WithStack()\n\t\t\t}\n\t\t}\n\t\treturn nil, nil\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// get all answers\n\tanswerList := make([]*entity.Answer, 0)\n\terr = ar.data.DB.Context(ctx).Find(&answerList, &entity.Answer{QuestionID: questionID})\n\tif err != nil {\n\t\treturn errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()\n\t}\n\tfor _, answerInfo := range answerList {\n\t\terr = ar.DeleteAnswer(ctx, answerInfo.ID)\n\t\tif err != nil {\n\t\t\tlog.Error(err)\n\t\t}\n\t}\n\treturn\n}\n\n// AcceptAnswer accept other answer\nfunc (ar *AnswerActivityRepo) AcceptAnswer(ctx context.Context,\n\tanswerObjID, questionObjID, questionUserID, answerUserID string, isSelf bool,\n) (err error) {\n\taddActivityList := make([]*entity.Activity, 0)\n\tfor _, action := range acceptActionList {\n\t\t// get accept answer need add rank amount\n\t\tactivityType, deltaRank, hasRank, e := ar.activityRepo.GetActivityTypeByObjID(ctx, answerObjID, action)\n\t\tif e != nil {\n\t\t\treturn errors.InternalServer(reason.DatabaseError).WithError(e).WithStack()\n\t\t}\n\t\taddActivity := &entity.Activity{\n\t\t\tObjectID:         answerObjID,\n\t\t\tOriginalObjectID: questionObjID,\n\t\t\tActivityType:     activityType,\n\t\t\tRank:             deltaRank,\n\t\t\tHasRank:          hasRank,\n\t\t}\n\t\tif action == constant.ActAccept {\n\t\t\taddActivity.UserID = questionUserID\n\t\t\taddActivity.TriggerUserID = converter.StringToInt64(answerUserID)\n\t\t\taddActivity.OriginalObjectID = questionObjID // if activity is 'accept' means this question is accept the answer.\n\t\t} else {\n\t\t\taddActivity.UserID = answerUserID\n\t\t\taddActivity.TriggerUserID = converter.StringToInt64(answerUserID)\n\t\t\taddActivity.OriginalObjectID = answerObjID // if activity is 'accepted' means this answer was accepted.\n\t\t}\n\t\tif isSelf {\n\t\t\taddActivity.Rank = 0\n\t\t\taddActivity.HasRank = 0\n\t\t}\n\t\taddActivityList = append(addActivityList, addActivity)\n\t}\n\n\t_, err = ar.data.DB.Transaction(func(session *xorm.Session) (result any, err error) {\n\t\tsession = session.Context(ctx)\n\t\tfor _, addActivity := range addActivityList {\n\t\t\texistsActivity, exists, e := ar.activityRepo.GetActivity(\n\t\t\t\tctx, session, answerObjID, addActivity.UserID, addActivity.ActivityType)\n\t\t\tif e != nil {\n\t\t\t\treturn nil, errors.InternalServer(reason.DatabaseError).WithError(e).WithStack()\n\t\t\t}\n\t\t\tif exists && existsActivity.Cancelled == entity.ActivityAvailable {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\t// trigger user rank and send notification\n\t\t\tif addActivity.Rank != 0 {\n\t\t\t\treachStandard, e := ar.userRankRepo.TriggerUserRank(\n\t\t\t\t\tctx, session, addActivity.UserID, addActivity.Rank, addActivity.ActivityType)\n\t\t\t\tif e != nil {\n\t\t\t\t\treturn nil, errors.InternalServer(reason.DatabaseError).WithError(e).WithStack()\n\t\t\t\t}\n\t\t\t\tif reachStandard {\n\t\t\t\t\taddActivity.Rank = 0\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif exists {\n\t\t\t\tif _, e = session.Where(\"id = ?\", existsActivity.ID).Cols(\"`cancelled`\").\n\t\t\t\t\tUpdate(&entity.Activity{Cancelled: entity.ActivityAvailable}); e != nil {\n\t\t\t\t\treturn nil, errors.InternalServer(reason.DatabaseError).WithError(e).WithStack()\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif _, e = session.Insert(addActivity); e != nil {\n\t\t\t\t\treturn nil, errors.InternalServer(reason.DatabaseError).WithError(e).WithStack()\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn nil, nil\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\tfor _, act := range addActivityList {\n\t\tmsg := &schema.NotificationMsg{\n\t\t\tType:           schema.NotificationTypeAchievement,\n\t\t\tObjectID:       act.ObjectID,\n\t\t\tReceiverUserID: act.UserID,\n\t\t}\n\t\tif act.UserID == questionUserID {\n\t\t\tmsg.TriggerUserID = answerUserID\n\t\t\tmsg.ObjectType = constant.AnswerObjectType\n\t\t} else {\n\t\t\tmsg.TriggerUserID = questionUserID\n\t\t\tmsg.ObjectType = constant.AnswerObjectType\n\t\t}\n\t\tif msg.TriggerUserID != msg.ReceiverUserID {\n\t\t\tar.notificationQueueService.Send(ctx, msg)\n\t\t}\n\t}\n\n\tfor _, act := range addActivityList {\n\t\tmsg := &schema.NotificationMsg{\n\t\t\tReceiverUserID: act.UserID,\n\t\t\tType:           schema.NotificationTypeInbox,\n\t\t\tObjectID:       act.ObjectID,\n\t\t}\n\t\tif act.UserID != questionUserID {\n\t\t\tmsg.TriggerUserID = questionUserID\n\t\t\tmsg.ObjectType = constant.AnswerObjectType\n\t\t\tmsg.NotificationAction = constant.NotificationAcceptAnswer\n\t\t\tar.notificationQueueService.Send(ctx, msg)\n\t\t}\n\t}\n\treturn err\n}\n\n// CancelAcceptAnswer accept other answer\nfunc (ar *AnswerActivityRepo) CancelAcceptAnswer(ctx context.Context,\n\tanswerObjID, questionObjID, questionUserID, answerUserID string,\n) (err error) {\n\taddActivityList := make([]*entity.Activity, 0)\n\tfor _, action := range acceptActionList {\n\t\t// get accept answer need add rank amount\n\t\tactivityType, deltaRank, hasRank, e := ar.activityRepo.GetActivityTypeByObjID(ctx, answerObjID, action)\n\t\tif e != nil {\n\t\t\treturn errors.InternalServer(reason.DatabaseError).WithError(e).WithStack()\n\t\t}\n\t\taddActivity := &entity.Activity{\n\t\t\tObjectID:     answerObjID,\n\t\t\tActivityType: activityType,\n\t\t\tRank:         -deltaRank,\n\t\t\tHasRank:      hasRank,\n\t\t}\n\t\tif action == constant.ActAccept {\n\t\t\taddActivity.UserID = questionUserID\n\t\t\taddActivity.OriginalObjectID = questionObjID\n\t\t} else {\n\t\t\taddActivity.UserID = answerUserID\n\t\t\taddActivity.OriginalObjectID = answerObjID\n\t\t}\n\t\taddActivityList = append(addActivityList, addActivity)\n\t}\n\n\t_, err = ar.data.DB.Transaction(func(session *xorm.Session) (result any, err error) {\n\t\tsession = session.Context(ctx)\n\t\tfor _, addActivity := range addActivityList {\n\t\t\texistsActivity, exists, e := ar.activityRepo.GetActivity(\n\t\t\t\tctx, session, answerObjID, addActivity.UserID, addActivity.ActivityType)\n\t\t\tif e != nil {\n\t\t\t\treturn nil, errors.InternalServer(reason.DatabaseError).WithError(e).WithStack()\n\t\t\t}\n\t\t\tif exists && existsActivity.Cancelled == entity.ActivityCancelled {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif !exists {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tif existsActivity.Rank != 0 {\n\t\t\t\t_, e = ar.userRankRepo.TriggerUserRank(\n\t\t\t\t\tctx, session, addActivity.UserID, addActivity.Rank, addActivity.ActivityType)\n\t\t\t\tif e != nil {\n\t\t\t\t\treturn nil, errors.InternalServer(reason.DatabaseError).WithError(e).WithStack()\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif _, e := session.Where(\"id = ?\", existsActivity.ID).Cols(\"cancelled\", \"cancelled_at\").\n\t\t\t\tUpdate(&entity.Activity{Cancelled: entity.ActivityCancelled, CancelledAt: time.Now()}); e != nil {\n\t\t\t\treturn nil, errors.InternalServer(reason.DatabaseError).WithError(e).WithStack()\n\t\t\t}\n\t\t}\n\t\treturn nil, nil\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\tfor _, act := range addActivityList {\n\t\tmsg := &schema.NotificationMsg{\n\t\t\tReceiverUserID: act.UserID,\n\t\t\tType:           schema.NotificationTypeAchievement,\n\t\t\tObjectID:       act.ObjectID,\n\t\t}\n\t\tif act.UserID == questionUserID {\n\t\t\tmsg.TriggerUserID = answerUserID\n\t\t\tmsg.ObjectType = constant.QuestionObjectType\n\t\t} else {\n\t\t\tmsg.TriggerUserID = questionUserID\n\t\t\tmsg.ObjectType = constant.AnswerObjectType\n\t\t}\n\t\tif msg.TriggerUserID != msg.ReceiverUserID {\n\t\t\tar.notificationQueueService.Send(ctx, msg)\n\t\t}\n\t}\n\treturn err\n}\n\nfunc (ar *AnswerActivityRepo) DeleteAnswer(ctx context.Context, answerID string) (err error) {\n\tanswerInfo := &entity.Answer{}\n\texist, err := ar.data.DB.Context(ctx).Where(\"id = ?\", answerID).Get(answerInfo)\n\tif err != nil {\n\t\treturn errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()\n\t}\n\tif !exist {\n\t\treturn nil\n\t}\n\n\t// get all this object activity\n\tactivityList := make([]*entity.Activity, 0)\n\tsession := ar.data.DB.Context(ctx).Where(\"has_rank = 1\")\n\tsession.Where(\"cancelled = ?\", entity.ActivityAvailable)\n\terr = session.Find(&activityList, &entity.Activity{ObjectID: answerID})\n\tif err != nil {\n\t\treturn errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()\n\t}\n\tif len(activityList) == 0 {\n\t\treturn nil\n\t}\n\n\tlog.Infof(\"answerInfo %s deleted will rollback activity %d\", answerID, len(activityList))\n\n\t_, err = ar.data.DB.Transaction(func(session *xorm.Session) (result any, err error) {\n\t\tsession = session.Context(ctx)\n\t\tfor _, act := range activityList {\n\t\t\tlog.Infof(\"user %s rollback rank %d\", act.UserID, -act.Rank)\n\t\t\t_, e := ar.userRankRepo.TriggerUserRank(\n\t\t\t\tctx, session, act.UserID, -act.Rank, act.ActivityType)\n\t\t\tif e != nil {\n\t\t\t\treturn nil, errors.InternalServer(reason.DatabaseError).WithError(e).WithStack()\n\t\t\t}\n\n\t\t\tif _, e := session.Where(\"id = ?\", act.ID).Cols(\"cancelled\", \"cancelled_at\").\n\t\t\t\tUpdate(&entity.Activity{Cancelled: entity.ActivityCancelled, CancelledAt: time.Now()}); e != nil {\n\t\t\t\treturn nil, errors.InternalServer(reason.DatabaseError).WithError(e).WithStack()\n\t\t\t}\n\t\t}\n\t\treturn nil, nil\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn\n}\n", "package activity\n\nimport (\n\t\"context\"\n\t\"time\"\n\n\t\"github.com/answerdev/answer/internal/service/activity_common\"\n\t\"github.com/answerdev/answer/internal/service/follow\"\n\t\"github.com/answerdev/answer/pkg/obj\"\n\t\"github.com/segmentfault/pacman/log\"\n\t\"xorm.io/builder\"\n\n\t\"github.com/answerdev/answer/internal/base/data\"\n\t\"github.com/answerdev/answer/internal/base/reason\"\n\t\"github.com/answerdev/answer/internal/entity\"\n\t\"github.com/answerdev/answer/internal/service/unique\"\n\t\"github.com/segmentfault/pacman/errors\"\n\t\"xorm.io/xorm\"\n)\n\n// FollowRepo activity repository\ntype FollowRepo struct {\n\tdata         *data.Data\n\tuniqueIDRepo unique.UniqueIDRepo\n\tactivityRepo activity_common.ActivityRepo\n}\n\n// NewFollowRepo new repository\nfunc NewFollowRepo(\n\tdata *data.Data,\n\tuniqueIDRepo unique.UniqueIDRepo,\n\tactivityRepo activity_common.ActivityRepo,\n) follow.FollowRepo {\n\treturn &FollowRepo{\n\t\tdata:         data,\n\t\tuniqueIDRepo: uniqueIDRepo,\n\t\tactivityRepo: activityRepo,\n\t}\n}\n\nfunc (ar *FollowRepo) Follow(ctx context.Context, objectID, userID string) error {\n\tobjectTypeStr, err := obj.GetObjectTypeStrByObjectID(objectID)\n\tif err != nil {\n\t\treturn errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()\n\t}\n\tactivityType, err := ar.activityRepo.GetActivityTypeByObjKey(ctx, objectTypeStr, \"follow\")\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t_, err = ar.data.DB.Transaction(func(session *xorm.Session) (result any, err error) {\n\t\tsession = session.Context(ctx)\n\t\tvar (\n\t\t\texistsActivity entity.Activity\n\t\t\thas            bool\n\t\t)\n\t\tresult = nil\n\n\t\thas, err = session.Where(builder.Eq{\"activity_type\": activityType}).\n\t\t\tAnd(builder.Eq{\"user_id\": userID}).\n\t\t\tAnd(builder.Eq{\"object_id\": objectID}).\n\t\t\tGet(&existsActivity)\n\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\n\t\tif has && existsActivity.Cancelled == entity.ActivityAvailable {\n\t\t\treturn\n\t\t}\n\n\t\tif has {\n\t\t\t_, err = session.Where(builder.Eq{\"id\": existsActivity.ID}).\n\t\t\t\tCols(`cancelled`).\n\t\t\t\tUpdate(&entity.Activity{\n\t\t\t\t\tCancelled: entity.ActivityAvailable,\n\t\t\t\t})\n\t\t} else {\n\t\t\t// update existing activity with new user id and u object id\n\t\t\t_, err = session.Insert(&entity.Activity{\n\t\t\t\tUserID:           userID,\n\t\t\t\tObjectID:         objectID,\n\t\t\t\tOriginalObjectID: objectID,\n\t\t\t\tActivityType:     activityType,\n\t\t\t\tCancelled:        entity.ActivityAvailable,\n\t\t\t\tRank:             0,\n\t\t\t\tHasRank:          0,\n\t\t\t})\n\t\t}\n\n\t\tif err != nil {\n\t\t\tlog.Error(err)\n\t\t\treturn\n\t\t}\n\n\t\t// start update followers when everything is fine\n\t\terr = ar.updateFollows(ctx, session, objectID, 1)\n\t\tif err != nil {\n\t\t\tlog.Error(err)\n\t\t}\n\n\t\treturn\n\t})\n\n\treturn err\n}\n\nfunc (ar *FollowRepo) FollowCancel(ctx context.Context, objectID, userID string) error {\n\tobjectTypeStr, err := obj.GetObjectTypeStrByObjectID(objectID)\n\tif err != nil {\n\t\treturn errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()\n\t}\n\tactivityType, err := ar.activityRepo.GetActivityTypeByObjKey(ctx, objectTypeStr, \"follow\")\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t_, err = ar.data.DB.Transaction(func(session *xorm.Session) (result any, err error) {\n\t\tsession = session.Context(ctx)\n\t\tvar (\n\t\t\texistsActivity entity.Activity\n\t\t\thas            bool\n\t\t)\n\t\tresult = nil\n\n\t\thas, err = session.Where(builder.Eq{\"activity_type\": activityType}).\n\t\t\tAnd(builder.Eq{\"user_id\": userID}).\n\t\t\tAnd(builder.Eq{\"object_id\": objectID}).\n\t\t\tGet(&existsActivity)\n\n\t\tif err != nil || !has {\n\t\t\treturn\n\t\t}\n\n\t\tif has && existsActivity.Cancelled == entity.ActivityCancelled {\n\t\t\treturn\n\t\t}\n\t\tif _, err = session.Where(\"id = ?\", existsActivity.ID).\n\t\t\tCols(\"cancelled\").\n\t\t\tUpdate(&entity.Activity{\n\t\t\t\tCancelled:   entity.ActivityCancelled,\n\t\t\t\tCancelledAt: time.Now(),\n\t\t\t}); err != nil {\n\t\t\treturn\n\t\t}\n\t\terr = ar.updateFollows(ctx, session, objectID, -1)\n\t\treturn\n\t})\n\treturn err\n}\n\nfunc (ar *FollowRepo) updateFollows(ctx context.Context, session *xorm.Session, objectID string, follows int) error {\n\tobjectType, err := obj.GetObjectTypeStrByObjectID(objectID)\n\tif err != nil {\n\t\treturn err\n\t}\n\tswitch objectType {\n\tcase \"question\":\n\t\t_, err = session.Where(\"id = ?\", objectID).Incr(\"follow_count\", follows).Update(&entity.Question{})\n\tcase \"user\":\n\t\t_, err = session.Where(\"id = ?\", objectID).Incr(\"follow_count\", follows).Update(&entity.User{})\n\tcase \"tag\":\n\t\t_, err = session.Where(\"id = ?\", objectID).Incr(\"follow_count\", follows).Update(&entity.Tag{})\n\tdefault:\n\t\terr = errors.InternalServer(reason.DisallowFollow).WithMsg(\"this object can't be followed\")\n\t}\n\treturn err\n}\n", "package activity\n\nimport (\n\t\"context\"\n\n\t\"github.com/answerdev/answer/internal/base/data\"\n\t\"github.com/answerdev/answer/internal/base/reason\"\n\t\"github.com/answerdev/answer/internal/entity\"\n\t\"github.com/answerdev/answer/internal/service/activity\"\n\t\"github.com/answerdev/answer/internal/service/activity_common\"\n\t\"github.com/answerdev/answer/internal/service/config\"\n\t\"github.com/answerdev/answer/internal/service/rank\"\n\t\"github.com/segmentfault/pacman/errors\"\n\t\"xorm.io/xorm\"\n)\n\n// UserActiveActivityRepo answer accepted\ntype UserActiveActivityRepo struct {\n\tdata          *data.Data\n\tactivityRepo  activity_common.ActivityRepo\n\tuserRankRepo  rank.UserRankRepo\n\tconfigService *config.ConfigService\n}\n\nconst (\n\tUserActivated = \"user.activated\"\n)\n\n// NewUserActiveActivityRepo new repository\nfunc NewUserActiveActivityRepo(\n\tdata *data.Data,\n\tactivityRepo activity_common.ActivityRepo,\n\tuserRankRepo rank.UserRankRepo,\n\tconfigService *config.ConfigService,\n) activity.UserActiveActivityRepo {\n\treturn &UserActiveActivityRepo{\n\t\tdata:          data,\n\t\tactivityRepo:  activityRepo,\n\t\tuserRankRepo:  userRankRepo,\n\t\tconfigService: configService,\n\t}\n}\n\n// UserActive accept other answer\nfunc (ar *UserActiveActivityRepo) UserActive(ctx context.Context, userID string) (err error) {\n\tcfg, err := ar.configService.GetConfigByKey(ctx, UserActivated)\n\tif err != nil {\n\t\treturn err\n\t}\n\tactivityType := cfg.ID\n\tdeltaRank := cfg.GetIntValue()\n\taddActivity := &entity.Activity{\n\t\tUserID:           userID,\n\t\tObjectID:         \"0\",\n\t\tOriginalObjectID: \"0\",\n\t\tActivityType:     activityType,\n\t\tRank:             deltaRank,\n\t\tHasRank:          1,\n\t}\n\n\t_, err = ar.data.DB.Transaction(func(session *xorm.Session) (result any, err error) {\n\t\tsession = session.Context(ctx)\n\n\t\t_, exists, err := ar.activityRepo.GetActivity(ctx, session, \"0\", addActivity.UserID, activityType)\n\t\tif err != nil {\n\t\t\treturn nil, errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()\n\t\t}\n\t\tif exists {\n\t\t\treturn nil, nil\n\t\t}\n\n\t\t_, err = ar.userRankRepo.TriggerUserRank(ctx, session, addActivity.UserID, addActivity.Rank, activityType)\n\t\tif err != nil {\n\t\t\treturn nil, errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()\n\t\t}\n\t\t_, err = session.Insert(addActivity)\n\t\tif err != nil {\n\t\t\treturn nil, errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()\n\t\t}\n\t\treturn nil, nil\n\t})\n\treturn err\n}\n", "package activity\n\nimport (\n\t\"context\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/answerdev/answer/internal/base/constant\"\n\t\"github.com/answerdev/answer/internal/service/notice_queue\"\n\t\"github.com/answerdev/answer/pkg/converter\"\n\n\t\"github.com/answerdev/answer/internal/base/pager\"\n\t\"github.com/answerdev/answer/internal/service/config\"\n\t\"github.com/answerdev/answer/internal/service/rank\"\n\t\"github.com/answerdev/answer/pkg/obj\"\n\n\t\"xorm.io/builder\"\n\n\t\"github.com/answerdev/answer/internal/service/activity_common\"\n\t\"github.com/answerdev/answer/internal/service/unique\"\n\n\t\"github.com/answerdev/answer/internal/base/data\"\n\t\"github.com/answerdev/answer/internal/base/reason\"\n\t\"github.com/answerdev/answer/internal/entity\"\n\t\"github.com/answerdev/answer/internal/schema\"\n\t\"github.com/answerdev/answer/internal/service\"\n\t\"github.com/segmentfault/pacman/errors\"\n\t\"xorm.io/xorm\"\n)\n\n// VoteRepo activity repository\ntype VoteRepo struct {\n\tdata                     *data.Data\n\tuniqueIDRepo             unique.UniqueIDRepo\n\tconfigService            *config.ConfigService\n\tactivityRepo             activity_common.ActivityRepo\n\tuserRankRepo             rank.UserRankRepo\n\tvoteCommon               activity_common.VoteRepo\n\tnotificationQueueService notice_queue.NotificationQueueService\n}\n\n// NewVoteRepo new repository\nfunc NewVoteRepo(\n\tdata *data.Data,\n\tuniqueIDRepo unique.UniqueIDRepo,\n\tconfigService *config.ConfigService,\n\tactivityRepo activity_common.ActivityRepo,\n\tuserRankRepo rank.UserRankRepo,\n\tvoteCommon activity_common.VoteRepo,\n\tnotificationQueueService notice_queue.NotificationQueueService,\n) service.VoteRepo {\n\treturn &VoteRepo{\n\t\tdata:                     data,\n\t\tuniqueIDRepo:             uniqueIDRepo,\n\t\tconfigService:            configService,\n\t\tactivityRepo:             activityRepo,\n\t\tuserRankRepo:             userRankRepo,\n\t\tvoteCommon:               voteCommon,\n\t\tnotificationQueueService: notificationQueueService,\n\t}\n}\n\nvar LimitUpActions = map[string][]string{\n\t\"question\": {\"vote_up\", \"voted_up\"},\n\t\"answer\":   {\"vote_up\", \"voted_up\"},\n\t\"comment\":  {\"vote_up\"},\n}\n\nvar LimitDownActions = map[string][]string{\n\t\"question\": {\"vote_down\", \"voted_down\"},\n\t\"answer\":   {\"vote_down\", \"voted_down\"},\n\t\"comment\":  {\"vote_down\"},\n}\n\nfunc (vr *VoteRepo) vote(ctx context.Context, objectID string, userID, objectUserID string, actions []string) (resp *schema.VoteResp, err error) {\n\tresp = &schema.VoteResp{}\n\tachievementNotificationUserIDs := make([]string, 0)\n\tsendInboxNotification := false\n\tupVote := false\n\t_, err = vr.data.DB.Transaction(func(session *xorm.Session) (result any, err error) {\n\t\tsession = session.Context(ctx)\n\t\tresult = nil\n\t\tfor _, action := range actions {\n\t\t\tvar (\n\t\t\t\texistsActivity entity.Activity\n\t\t\t\tinsertActivity entity.Activity\n\t\t\t\thas            bool\n\t\t\t\ttriggerUserID,\n\t\t\t\tactivityUserID string\n\t\t\t\tactivityType, deltaRank, hasRank int\n\t\t\t)\n\n\t\t\tactivityUserID, activityType, deltaRank, hasRank, err = vr.CheckRank(ctx, objectID, objectUserID, userID, action)\n\t\t\tif err != nil {\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\ttriggerUserID = userID\n\t\t\tif userID == activityUserID {\n\t\t\t\ttriggerUserID = \"0\"\n\t\t\t}\n\n\t\t\t// check is voted up\n\t\t\thas, _ = session.\n\t\t\t\tWhere(builder.Eq{\"object_id\": objectID}).\n\t\t\t\tAnd(builder.Eq{\"user_id\": activityUserID}).\n\t\t\t\tAnd(builder.Eq{\"trigger_user_id\": triggerUserID}).\n\t\t\t\tAnd(builder.Eq{\"activity_type\": activityType}).\n\t\t\t\tGet(&existsActivity)\n\n\t\t\t// is is voted,return\n\t\t\tif has && existsActivity.Cancelled == entity.ActivityAvailable {\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tinsertActivity = entity.Activity{\n\t\t\t\tObjectID:         objectID,\n\t\t\t\tOriginalObjectID: objectID,\n\t\t\t\tUserID:           activityUserID,\n\t\t\t\tTriggerUserID:    converter.StringToInt64(triggerUserID),\n\t\t\t\tActivityType:     activityType,\n\t\t\t\tRank:             deltaRank,\n\t\t\t\tHasRank:          hasRank,\n\t\t\t\tCancelled:        entity.ActivityAvailable,\n\t\t\t}\n\n\t\t\t// trigger user rank and send notification\n\t\t\tif hasRank != 0 {\n\t\t\t\tvar isReachStandard bool\n\t\t\t\tisReachStandard, err = vr.userRankRepo.TriggerUserRank(ctx, session, activityUserID, deltaRank, activityType)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\t\t\t\tif isReachStandard {\n\t\t\t\t\tinsertActivity.Rank = 0\n\t\t\t\t}\n\t\t\t\tachievementNotificationUserIDs = append(achievementNotificationUserIDs, activityUserID)\n\t\t\t}\n\n\t\t\tif has {\n\t\t\t\tif _, err = session.Where(\"id = ?\", existsActivity.ID).Cols(\"`cancelled`\").\n\t\t\t\t\tUpdate(&entity.Activity{\n\t\t\t\t\t\tCancelled: entity.ActivityAvailable,\n\t\t\t\t\t}); err != nil {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t_, err = session.Insert(&insertActivity)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\t\t\t\tsendInboxNotification = true\n\t\t\t}\n\n\t\t\t// update votes\n\t\t\tif action == constant.ActVoteDown || action == constant.ActVoteUp {\n\t\t\t\tvotes := 1\n\t\t\t\tif action == constant.ActVoteDown {\n\t\t\t\t\tupVote = false\n\t\t\t\t\tvotes = -1\n\t\t\t\t} else {\n\t\t\t\t\tupVote = true\n\t\t\t\t}\n\t\t\t\terr = vr.updateVotes(ctx, session, objectID, votes)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn\n\t})\n\tif err != nil {\n\t\treturn\n\t}\n\n\tresp, err = vr.GetVoteResultByObjectId(ctx, objectID)\n\tresp.VoteStatus = vr.voteCommon.GetVoteStatus(ctx, objectID, userID)\n\n\tfor _, activityUserID := range achievementNotificationUserIDs {\n\t\tvr.sendNotification(ctx, activityUserID, objectUserID, objectID)\n\t}\n\tif sendInboxNotification {\n\t\tvr.sendVoteInboxNotification(ctx, userID, objectUserID, objectID, upVote)\n\t}\n\treturn\n}\n\nfunc (vr *VoteRepo) voteCancel(ctx context.Context, objectID string, userID, objectUserID string, actions []string) (resp *schema.VoteResp, err error) {\n\tresp = &schema.VoteResp{}\n\tnotificationUserIDs := make([]string, 0)\n\t_, err = vr.data.DB.Transaction(func(session *xorm.Session) (result any, err error) {\n\t\tsession = session.Context(ctx)\n\t\tfor _, action := range actions {\n\t\t\tvar (\n\t\t\t\texistsActivity entity.Activity\n\t\t\t\thas            bool\n\t\t\t\ttriggerUserID,\n\t\t\t\tactivityUserID string\n\t\t\t\tactivityType,\n\t\t\t\tdeltaRank, hasRank int\n\t\t\t)\n\t\t\tresult = nil\n\n\t\t\tactivityUserID, activityType, deltaRank, hasRank, err = vr.CheckRank(ctx, objectID, objectUserID, userID, action)\n\t\t\tif err != nil {\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\ttriggerUserID = userID\n\t\t\tif userID == activityUserID {\n\t\t\t\ttriggerUserID = \"0\"\n\t\t\t}\n\n\t\t\thas, err = session.\n\t\t\t\tWhere(builder.Eq{\"user_id\": activityUserID}).\n\t\t\t\tAnd(builder.Eq{\"trigger_user_id\": triggerUserID}).\n\t\t\t\tAnd(builder.Eq{\"activity_type\": activityType}).\n\t\t\t\tAnd(builder.Eq{\"object_id\": objectID}).\n\t\t\t\tGet(&existsActivity)\n\n\t\t\tif !has {\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif existsActivity.Cancelled == entity.ActivityCancelled {\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif _, err = session.Where(\"id = ?\", existsActivity.ID).Cols(\"cancelled\", \"cancelled_at\").\n\t\t\t\tUpdate(&entity.Activity{\n\t\t\t\t\tCancelled:   entity.ActivityCancelled,\n\t\t\t\t\tCancelledAt: time.Now(),\n\t\t\t\t}); err != nil {\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\t// trigger user rank and send notification\n\t\t\tif hasRank != 0 && existsActivity.Rank != 0 {\n\t\t\t\t_, err = vr.userRankRepo.TriggerUserRank(ctx, session, activityUserID, -deltaRank, activityType)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tnotificationUserIDs = append(notificationUserIDs, activityUserID)\n\t\t\t}\n\n\t\t\t// update votes\n\t\t\tif action == \"vote_down\" || action == \"vote_up\" {\n\t\t\t\tvotes := -1\n\t\t\t\tif action == \"vote_down\" {\n\t\t\t\t\tvotes = 1\n\t\t\t\t}\n\t\t\t\terr = vr.updateVotes(ctx, session, objectID, votes)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn\n\t})\n\tif err != nil {\n\t\treturn\n\t}\n\tresp, err = vr.GetVoteResultByObjectId(ctx, objectID)\n\tresp.VoteStatus = vr.voteCommon.GetVoteStatus(ctx, objectID, userID)\n\n\tfor _, activityUserID := range notificationUserIDs {\n\t\tvr.sendNotification(ctx, activityUserID, objectUserID, objectID)\n\t}\n\treturn\n}\n\nfunc (vr *VoteRepo) VoteUp(ctx context.Context, objectID string, userID, objectUserID string) (resp *schema.VoteResp, err error) {\n\tresp = &schema.VoteResp{}\n\tobjectType, err := obj.GetObjectTypeStrByObjectID(objectID)\n\tif err != nil {\n\t\terr = errors.BadRequest(reason.ObjectNotFound)\n\t\treturn\n\t}\n\n\tactions, ok := LimitUpActions[objectType]\n\tif !ok {\n\t\terr = errors.BadRequest(reason.DisallowVote)\n\t\treturn\n\t}\n\n\t_, _ = vr.VoteDownCancel(ctx, objectID, userID, objectUserID)\n\treturn vr.vote(ctx, objectID, userID, objectUserID, actions)\n}\n\nfunc (vr *VoteRepo) VoteDown(ctx context.Context, objectID string, userID, objectUserID string) (resp *schema.VoteResp, err error) {\n\tresp = &schema.VoteResp{}\n\tobjectType, err := obj.GetObjectTypeStrByObjectID(objectID)\n\tif err != nil {\n\t\terr = errors.BadRequest(reason.ObjectNotFound)\n\t\treturn\n\t}\n\tactions, ok := LimitDownActions[objectType]\n\tif !ok {\n\t\terr = errors.BadRequest(reason.DisallowVote)\n\t\treturn\n\t}\n\n\t_, _ = vr.VoteUpCancel(ctx, objectID, userID, objectUserID)\n\treturn vr.vote(ctx, objectID, userID, objectUserID, actions)\n}\n\nfunc (vr *VoteRepo) VoteUpCancel(ctx context.Context, objectID string, userID, objectUserID string) (resp *schema.VoteResp, err error) {\n\tvar objectType string\n\tresp = &schema.VoteResp{}\n\n\tobjectType, err = obj.GetObjectTypeStrByObjectID(objectID)\n\tif err != nil {\n\t\terr = errors.BadRequest(reason.ObjectNotFound)\n\t\treturn\n\t}\n\tactions, ok := LimitUpActions[objectType]\n\tif !ok {\n\t\terr = errors.BadRequest(reason.DisallowVote)\n\t\treturn\n\t}\n\n\treturn vr.voteCancel(ctx, objectID, userID, objectUserID, actions)\n}\n\nfunc (vr *VoteRepo) VoteDownCancel(ctx context.Context, objectID string, userID, objectUserID string) (resp *schema.VoteResp, err error) {\n\tvar objectType string\n\tresp = &schema.VoteResp{}\n\n\tobjectType, err = obj.GetObjectTypeStrByObjectID(objectID)\n\tif err != nil {\n\t\terr = errors.BadRequest(reason.ObjectNotFound)\n\t\treturn\n\t}\n\tactions, ok := LimitDownActions[objectType]\n\tif !ok {\n\t\terr = errors.BadRequest(reason.DisallowVote)\n\t\treturn\n\t}\n\n\treturn vr.voteCancel(ctx, objectID, userID, objectUserID, actions)\n}\n\nfunc (vr *VoteRepo) CheckRank(ctx context.Context, objectID, objectUserID, userID string, action string) (activityUserID string, activityType, rank, hasRank int, err error) {\n\tactivityType, rank, hasRank, err = vr.activityRepo.GetActivityTypeByObjID(ctx, objectID, action)\n\n\tif err != nil {\n\t\treturn\n\t}\n\n\tactivityUserID = userID\n\tif strings.Contains(action, \"voted\") {\n\t\tactivityUserID = objectUserID\n\t}\n\n\treturn activityUserID, activityType, rank, hasRank, nil\n}\n\nfunc (vr *VoteRepo) GetVoteResultByObjectId(ctx context.Context, objectID string) (resp *schema.VoteResp, err error) {\n\tresp = &schema.VoteResp{}\n\tfor _, action := range []string{\"vote_up\", \"vote_down\"} {\n\t\tvar (\n\t\t\tactivity     entity.Activity\n\t\t\tvotes        int64\n\t\t\tactivityType int\n\t\t)\n\n\t\tactivityType, _, _, _ = vr.activityRepo.GetActivityTypeByObjID(ctx, objectID, action)\n\n\t\tvotes, err = vr.data.DB.Context(ctx).Where(builder.Eq{\"object_id\": objectID}).\n\t\t\tAnd(builder.Eq{\"activity_type\": activityType}).\n\t\t\tAnd(builder.Eq{\"cancelled\": 0}).\n\t\t\tCount(&activity)\n\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\n\t\tif action == \"vote_up\" {\n\t\t\tresp.UpVotes = int(votes)\n\t\t} else {\n\t\t\tresp.DownVotes = int(votes)\n\t\t}\n\t}\n\n\tresp.Votes = resp.UpVotes - resp.DownVotes\n\n\treturn resp, nil\n}\n\nfunc (vr *VoteRepo) ListUserVotes(ctx context.Context, userID string,\n\tpage int, pageSize int, activityTypes []int) (voteList []entity.Activity, total int64, err error) {\n\tsession := vr.data.DB.Context(ctx)\n\tcond := builder.\n\t\tAnd(\n\t\t\tbuilder.Eq{\"user_id\": userID},\n\t\t\tbuilder.Eq{\"cancelled\": 0},\n\t\t\tbuilder.In(\"activity_type\", activityTypes),\n\t\t)\n\n\tsession.Where(cond).Desc(\"updated_at\")\n\n\ttotal, err = pager.Help(page, pageSize, &voteList, &entity.Activity{}, session)\n\tif err != nil {\n\t\terr = errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()\n\t}\n\treturn\n}\n\n// updateVotes\n// if votes < 0 Decr object vote_count,otherwise Incr object vote_count\nfunc (vr *VoteRepo) updateVotes(ctx context.Context, session *xorm.Session, objectID string, votes int) (err error) {\n\tvar (\n\t\tobjectType string\n\t\te          error\n\t)\n\n\tobjectType, err = obj.GetObjectTypeStrByObjectID(objectID)\n\tswitch objectType {\n\tcase \"question\":\n\t\t_, err = session.Where(\"id = ?\", objectID).Incr(\"vote_count\", votes).Update(&entity.Question{})\n\tcase \"answer\":\n\t\t_, err = session.Where(\"id = ?\", objectID).Incr(\"vote_count\", votes).Update(&entity.Answer{})\n\tcase \"comment\":\n\t\t_, err = session.Where(\"id = ?\", objectID).Incr(\"vote_count\", votes).Update(&entity.Comment{})\n\tdefault:\n\t\te = errors.BadRequest(reason.DisallowVote)\n\t}\n\n\tif e != nil {\n\t\terr = e\n\t} else if err != nil {\n\t\terr = errors.BadRequest(reason.DatabaseError).WithError(err).WithStack()\n\t}\n\n\treturn\n}\n\n// sendNotification send rank triggered notification\nfunc (vr *VoteRepo) sendNotification(ctx context.Context, activityUserID, objectUserID, objectID string) {\n\tobjectType, err := obj.GetObjectTypeStrByObjectID(objectID)\n\tif err != nil {\n\t\treturn\n\t}\n\n\tmsg := &schema.NotificationMsg{\n\t\tReceiverUserID: activityUserID,\n\t\tTriggerUserID:  objectUserID,\n\t\tType:           schema.NotificationTypeAchievement,\n\t\tObjectID:       objectID,\n\t\tObjectType:     objectType,\n\t}\n\tvr.notificationQueueService.Send(ctx, msg)\n}\n\nfunc (vr *VoteRepo) sendVoteInboxNotification(ctx context.Context, triggerUserID, receiverUserID, objectID string, upvote bool) {\n\tif triggerUserID == receiverUserID {\n\t\treturn\n\t}\n\tobjectType, _ := obj.GetObjectTypeStrByObjectID(objectID)\n\n\tmsg := &schema.NotificationMsg{\n\t\tTriggerUserID:  triggerUserID,\n\t\tReceiverUserID: receiverUserID,\n\t\tType:           schema.NotificationTypeInbox,\n\t\tObjectID:       objectID,\n\t\tObjectType:     objectType,\n\t}\n\tif objectType == constant.QuestionObjectType {\n\t\tif upvote {\n\t\t\tmsg.NotificationAction = constant.NotificationUpVotedTheQuestion\n\t\t} else {\n\t\t\tmsg.NotificationAction = constant.NotificationDownVotedTheQuestion\n\t\t}\n\t}\n\tif objectType == constant.AnswerObjectType {\n\t\tif upvote {\n\t\t\tmsg.NotificationAction = constant.NotificationUpVotedTheAnswer\n\t\t} else {\n\t\t\tmsg.NotificationAction = constant.NotificationDownVotedTheAnswer\n\t\t}\n\t}\n\tif objectType == constant.CommentObjectType {\n\t\tif upvote {\n\t\t\tmsg.NotificationAction = constant.NotificationUpVotedTheComment\n\t\t}\n\t}\n\tif len(msg.NotificationAction) > 0 {\n\t\tvr.notificationQueueService.Send(ctx, msg)\n\t}\n}\n", "package activity_common\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/answerdev/answer/internal/entity\"\n\t\"github.com/answerdev/answer/internal/service/activity_common\"\n\t\"github.com/answerdev/answer/internal/service/activity_type\"\n\t\"github.com/answerdev/answer/pkg/obj\"\n\t\"xorm.io/builder\"\n\t\"xorm.io/xorm\"\n\n\t\"github.com/answerdev/answer/internal/base/data\"\n\t\"github.com/answerdev/answer/internal/base/reason\"\n\t\"github.com/answerdev/answer/internal/service/config\"\n\t\"github.com/answerdev/answer/internal/service/unique\"\n\t\"github.com/segmentfault/pacman/errors\"\n)\n\n// ActivityRepo activity repository\ntype ActivityRepo struct {\n\tdata          *data.Data\n\tuniqueIDRepo  unique.UniqueIDRepo\n\tconfigService *config.ConfigService\n}\n\n// NewActivityRepo new repository\nfunc NewActivityRepo(\n\tdata *data.Data,\n\tuniqueIDRepo unique.UniqueIDRepo,\n\tconfigService *config.ConfigService,\n) activity_common.ActivityRepo {\n\treturn &ActivityRepo{\n\t\tdata:          data,\n\t\tuniqueIDRepo:  uniqueIDRepo,\n\t\tconfigService: configService,\n\t}\n}\n\nfunc (ar *ActivityRepo) GetActivityTypeByObjID(ctx context.Context, objectID string, action string) (\n\tactivityType, rank, hasRank int, err error) {\n\tobjectKey, err := obj.GetObjectTypeStrByObjectID(objectID)\n\tif err != nil {\n\t\treturn\n\t}\n\n\tconfKey := fmt.Sprintf(\"%s.%s\", objectKey, action)\n\tcfg, err := ar.configService.GetConfigByKey(ctx, confKey)\n\tif err != nil {\n\t\treturn\n\t}\n\tactivityType, rank = cfg.ID, cfg.GetIntValue()\n\thasRank = 0\n\tif rank != 0 {\n\t\thasRank = 1\n\t}\n\treturn\n}\n\nfunc (ar *ActivityRepo) GetActivityTypeByObjKey(ctx context.Context, objectKey, action string) (activityType int, err error) {\n\tconfigKey := fmt.Sprintf(\"%s.%s\", objectKey, action)\n\tcfg, err := ar.configService.GetConfigByKey(ctx, configKey)\n\tif err != nil {\n\t\treturn 0, errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()\n\t}\n\treturn cfg.ID, nil\n}\n\nfunc (ar *ActivityRepo) GetActivityTypeByConfigKey(ctx context.Context, configKey string) (activityType int, err error) {\n\tcfg, err := ar.configService.GetConfigByKey(ctx, configKey)\n\tif err != nil {\n\t\treturn 0, errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()\n\t}\n\treturn cfg.ID, nil\n}\n\nfunc (ar *ActivityRepo) GetActivity(ctx context.Context, session *xorm.Session,\n\tobjectID, userID string, activityType int,\n) (existsActivity *entity.Activity, exist bool, err error) {\n\texistsActivity = &entity.Activity{}\n\texist, err = session.\n\t\tWhere(builder.Eq{\"object_id\": objectID}).\n\t\tAnd(builder.Eq{\"user_id\": userID}).\n\t\tAnd(builder.Eq{\"activity_type\": activityType}).\n\t\tGet(existsActivity)\n\treturn\n}\n\nfunc (ar *ActivityRepo) GetUserIDObjectIDActivitySum(ctx context.Context, userID, objectID string) (int, error) {\n\tsum := &entity.ActivityRankSum{}\n\t_, err := ar.data.DB.Context(ctx).Table(entity.Activity{}.TableName()).\n\t\tSelect(\"sum(`rank`) as `rank`\").\n\t\tWhere(\"user_id =?\", userID).\n\t\tAnd(\"object_id = ?\", objectID).\n\t\tAnd(\"cancelled =0\").\n\t\tGet(sum)\n\tif err != nil {\n\t\terr = errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()\n\t\treturn 0, err\n\t}\n\treturn sum.Rank, nil\n}\n\n// AddActivity add activity\nfunc (ar *ActivityRepo) AddActivity(ctx context.Context, activity *entity.Activity) (err error) {\n\t_, err = ar.data.DB.Context(ctx).Insert(activity)\n\tif err != nil {\n\t\terr = errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()\n\t}\n\treturn\n}\n\n// GetUsersWhoHasGainedTheMostReputation get users who has gained the most reputation over a period of time\nfunc (ar *ActivityRepo) GetUsersWhoHasGainedTheMostReputation(\n\tctx context.Context, startTime, endTime time.Time, limit int) (rankStat []*entity.ActivityUserRankStat, err error) {\n\trankStat = make([]*entity.ActivityUserRankStat, 0)\n\tsession := ar.data.DB.Context(ctx).Select(\"user_id, SUM(`rank`) AS rank_amount\").Table(\"activity\")\n\tsession.Where(\"has_rank = 1 AND cancelled = 0\")\n\tsession.Where(\"created_at >= ?\", startTime)\n\tsession.Where(\"created_at <= ?\", endTime)\n\tsession.GroupBy(\"user_id\")\n\tsession.Desc(\"rank_amount\")\n\tsession.Limit(limit)\n\terr = session.Find(&rankStat)\n\tif err != nil {\n\t\terr = errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()\n\t}\n\treturn\n}\n\n// GetUsersWhoHasVoteMost get users who has vote most\nfunc (ar *ActivityRepo) GetUsersWhoHasVoteMost(\n\tctx context.Context, startTime, endTime time.Time, limit int) (voteStat []*entity.ActivityUserVoteStat, err error) {\n\tvoteStat = make([]*entity.ActivityUserVoteStat, 0)\n\n\tactIDs := make([]int, 0)\n\tfor _, act := range activity_type.ActivityTypeList {\n\t\tcfg, err := ar.configService.GetConfigByKey(ctx, act)\n\t\tif err == nil {\n\t\t\tactIDs = append(actIDs, cfg.ID)\n\t\t}\n\t}\n\n\tsession := ar.data.DB.Context(ctx).Select(\"user_id, COUNT(*) AS vote_count\").Table(\"activity\")\n\tsession.Where(\"cancelled = 0\")\n\tsession.In(\"activity_type\", actIDs)\n\tsession.Where(\"created_at >= ?\", startTime)\n\tsession.Where(\"created_at <= ?\", endTime)\n\tsession.GroupBy(\"user_id\")\n\tsession.Desc(\"vote_count\")\n\tsession.Limit(limit)\n\terr = session.Find(&voteStat)\n\tif err != nil {\n\t\terr = errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()\n\t}\n\treturn\n}\n", "package activity_common\n\nimport (\n\t\"context\"\n\n\t\"github.com/answerdev/answer/internal/base/data\"\n\t\"github.com/answerdev/answer/internal/base/reason\"\n\t\"github.com/answerdev/answer/internal/entity\"\n\t\"github.com/answerdev/answer/internal/service/activity_common\"\n\t\"github.com/answerdev/answer/internal/service/unique\"\n\t\"github.com/answerdev/answer/pkg/obj\"\n\t\"github.com/segmentfault/pacman/errors\"\n\t\"github.com/segmentfault/pacman/log\"\n)\n\n// FollowRepo follow repository\ntype FollowRepo struct {\n\tdata         *data.Data\n\tuniqueIDRepo unique.UniqueIDRepo\n\tactivityRepo activity_common.ActivityRepo\n}\n\n// NewFollowRepo new repository\nfunc NewFollowRepo(\n\tdata *data.Data,\n\tuniqueIDRepo unique.UniqueIDRepo,\n\tactivityRepo activity_common.ActivityRepo,\n) activity_common.FollowRepo {\n\treturn &FollowRepo{\n\t\tdata:         data,\n\t\tuniqueIDRepo: uniqueIDRepo,\n\t\tactivityRepo: activityRepo,\n\t}\n}\n\n// GetFollowAmount get object id's follows\nfunc (ar *FollowRepo) GetFollowAmount(ctx context.Context, objectID string) (follows int, err error) {\n\tobjectType, err := obj.GetObjectTypeStrByObjectID(objectID)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\tswitch objectType {\n\tcase \"question\":\n\t\tmodel := &entity.Question{}\n\t\t_, err = ar.data.DB.Context(ctx).Where(\"id = ?\", objectID).Cols(\"`follow_count`\").Get(model)\n\t\tif err == nil {\n\t\t\tfollows = int(model.FollowCount)\n\t\t}\n\tcase \"user\":\n\t\tmodel := &entity.User{}\n\t\t_, err = ar.data.DB.Context(ctx).Where(\"id = ?\", objectID).Cols(\"`follow_count`\").Get(model)\n\t\tif err == nil {\n\t\t\tfollows = int(model.FollowCount)\n\t\t}\n\tcase \"tag\":\n\t\tmodel := &entity.Tag{}\n\t\t_, err = ar.data.DB.Context(ctx).Where(\"id = ?\", objectID).Cols(\"`follow_count`\").Get(model)\n\t\tif err == nil {\n\t\t\tfollows = int(model.FollowCount)\n\t\t}\n\tdefault:\n\t\terr = errors.InternalServer(reason.DisallowFollow).WithMsg(\"this object can't be followed\")\n\t}\n\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\treturn follows, nil\n}\n\n// GetFollowUserIDs get follow userID by objectID\nfunc (ar *FollowRepo) GetFollowUserIDs(ctx context.Context, objectID string) (userIDs []string, err error) {\n\tobjectTypeStr, err := obj.GetObjectTypeStrByObjectID(objectID)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tactivityType, err := ar.activityRepo.GetActivityTypeByObjKey(ctx, objectTypeStr, \"follow\")\n\tif err != nil {\n\t\tlog.Errorf(\"can't get activity type by object key: %s\", objectTypeStr)\n\t\treturn nil, err\n\t}\n\n\tuserIDs = make([]string, 0)\n\tsession := ar.data.DB.Context(ctx).Select(\"user_id\")\n\tsession.Table(entity.Activity{}.TableName())\n\tsession.Where(\"object_id = ?\", objectID)\n\tsession.Where(\"activity_type = ?\", activityType)\n\tsession.Where(\"cancelled = 0\")\n\terr = session.Find(&userIDs)\n\tif err != nil {\n\t\treturn nil, errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()\n\t}\n\treturn userIDs, nil\n}\n\n// GetFollowIDs get all follow id list\nfunc (ar *FollowRepo) GetFollowIDs(ctx context.Context, userID, objectKey string) (followIDs []string, err error) {\n\tfollowIDs = make([]string, 0)\n\tactivityType, err := ar.activityRepo.GetActivityTypeByObjKey(ctx, objectKey, \"follow\")\n\tif err != nil {\n\t\treturn nil, errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()\n\t}\n\tsession := ar.data.DB.Context(ctx).Select(\"object_id\")\n\tsession.Table(entity.Activity{}.TableName())\n\tsession.Where(\"user_id = ? AND activity_type = ?\", userID, activityType)\n\tsession.Where(\"cancelled = 0\")\n\terr = session.Find(&followIDs)\n\tif err != nil {\n\t\treturn nil, errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()\n\t}\n\treturn followIDs, nil\n}\n\n// IsFollowed check user if follow object or not\nfunc (ar *FollowRepo) IsFollowed(ctx context.Context, userID, objectID string) (followed bool, err error) {\n\tobjectKey, err := obj.GetObjectTypeStrByObjectID(objectID)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\n\tactivityType, err := ar.activityRepo.GetActivityTypeByObjKey(ctx, objectKey, \"follow\")\n\tif err != nil {\n\t\treturn false, err\n\t}\n\n\tat := &entity.Activity{}\n\thas, err := ar.data.DB.Context(ctx).Where(\"user_id = ? AND object_id = ? AND activity_type = ?\", userID, objectID, activityType).Get(at)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\tif !has {\n\t\treturn false, nil\n\t}\n\tif at.Cancelled == entity.ActivityCancelled {\n\t\treturn false, nil\n\t} else {\n\t\treturn true, nil\n\t}\n}\n", "package repo\n\nimport (\n\t\"github.com/answerdev/answer/internal/base/data\"\n\t\"github.com/answerdev/answer/internal/repo/activity\"\n\t\"github.com/answerdev/answer/internal/repo/activity_common\"\n\t\"github.com/answerdev/answer/internal/repo/answer\"\n\t\"github.com/answerdev/answer/internal/repo/auth\"\n\t\"github.com/answerdev/answer/internal/repo/captcha\"\n\t\"github.com/answerdev/answer/internal/repo/collection\"\n\t\"github.com/answerdev/answer/internal/repo/comment\"\n\t\"github.com/answerdev/answer/internal/repo/config\"\n\t\"github.com/answerdev/answer/internal/repo/export\"\n\t\"github.com/answerdev/answer/internal/repo/meta\"\n\t\"github.com/answerdev/answer/internal/repo/notification\"\n\t\"github.com/answerdev/answer/internal/repo/plugin_config\"\n\t\"github.com/answerdev/answer/internal/repo/question\"\n\t\"github.com/answerdev/answer/internal/repo/rank\"\n\t\"github.com/answerdev/answer/internal/repo/reason\"\n\t\"github.com/answerdev/answer/internal/repo/report\"\n\t\"github.com/answerdev/answer/internal/repo/revision\"\n\t\"github.com/answerdev/answer/internal/repo/role\"\n\t\"github.com/answerdev/answer/internal/repo/search_common\"\n\t\"github.com/answerdev/answer/internal/repo/site_info\"\n\t\"github.com/answerdev/answer/internal/repo/tag\"\n\t\"github.com/answerdev/answer/internal/repo/tag_common\"\n\t\"github.com/answerdev/answer/internal/repo/unique\"\n\t\"github.com/answerdev/answer/internal/repo/user\"\n\t\"github.com/answerdev/answer/internal/repo/user_external_login\"\n\t\"github.com/google/wire\"\n)\n\n// ProviderSetRepo is data providers.\nvar ProviderSetRepo = wire.NewSet(\n\tdata.NewData,\n\tdata.NewDB,\n\tdata.NewCache,\n\tcomment.NewCommentRepo,\n\tcomment.NewCommentCommonRepo,\n\tcaptcha.NewCaptchaRepo,\n\tunique.NewUniqueIDRepo,\n\treport.NewReportRepo,\n\tactivity_common.NewFollowRepo,\n\tactivity_common.NewVoteRepo,\n\tconfig.NewConfigRepo,\n\tuser.NewUserRepo,\n\tuser.NewUserAdminRepo,\n\trank.NewUserRankRepo,\n\tquestion.NewQuestionRepo,\n\tanswer.NewAnswerRepo,\n\tactivity_common.NewActivityRepo,\n\tactivity.NewVoteRepo,\n\tactivity.NewFollowRepo,\n\tactivity.NewAnswerActivityRepo,\n\tactivity.NewQuestionActivityRepo,\n\tactivity.NewUserActiveActivityRepo,\n\tactivity.NewActivityRepo,\n\ttag.NewTagRepo,\n\ttag_common.NewTagCommonRepo,\n\ttag.NewTagRelRepo,\n\tcollection.NewCollectionRepo,\n\tcollection.NewCollectionGroupRepo,\n\tauth.NewAuthRepo,\n\trevision.NewRevisionRepo,\n\tsearch_common.NewSearchRepo,\n\tmeta.NewMetaRepo,\n\texport.NewEmailRepo,\n\treason.NewReasonRepo,\n\tsite_info.NewSiteInfo,\n\tnotification.NewNotificationRepo,\n\trole.NewRoleRepo,\n\trole.NewUserRoleRelRepo,\n\trole.NewRolePowerRelRepo,\n\trole.NewPowerRepo,\n\tuser_external_login.NewUserExternalLoginRepo,\n\tplugin_config.NewPluginConfigRepo,\n)\n", "package rank\n\nimport (\n\t\"context\"\n\n\t\"github.com/answerdev/answer/internal/base/data\"\n\t\"github.com/answerdev/answer/internal/base/pager\"\n\t\"github.com/answerdev/answer/internal/base/reason\"\n\t\"github.com/answerdev/answer/internal/entity\"\n\t\"github.com/answerdev/answer/internal/service/config\"\n\t\"github.com/answerdev/answer/internal/service/rank\"\n\t\"github.com/answerdev/answer/plugin\"\n\t\"github.com/jinzhu/now\"\n\t\"github.com/segmentfault/pacman/errors\"\n\t\"github.com/segmentfault/pacman/log\"\n\t\"xorm.io/builder\"\n\t\"xorm.io/xorm\"\n)\n\n// UserRankRepo user rank repository\ntype UserRankRepo struct {\n\tdata          *data.Data\n\tconfigService *config.ConfigService\n}\n\n// NewUserRankRepo new repository\nfunc NewUserRankRepo(data *data.Data, configService *config.ConfigService) rank.UserRankRepo {\n\treturn &UserRankRepo{\n\t\tdata:          data,\n\t\tconfigService: configService,\n\t}\n}\n\n// TriggerUserRank trigger user rank change\n// session is need provider, it means this action must be success or failure\n// if outer action is failed then this action is need rollback\nfunc (ur *UserRankRepo) TriggerUserRank(ctx context.Context,\n\tsession *xorm.Session, userID string, deltaRank int, activityType int,\n) (isReachStandard bool, err error) {\n\t// IMPORTANT: If user center enabled the rank agent, then we should not change user rank.\n\tif plugin.RankAgentEnabled() {\n\t\treturn false, nil\n\t}\n\tif deltaRank == 0 {\n\t\treturn false, nil\n\t}\n\n\tif deltaRank < 0 {\n\t\t// if user rank is lower than 1 after this action, then user rank will be set to 1 only.\n\t\tvar isReachMin bool\n\t\tisReachMin, err = ur.checkUserMinRank(ctx, session, userID, deltaRank)\n\t\tif err != nil {\n\t\t\treturn false, errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()\n\t\t}\n\t\tif isReachMin {\n\t\t\t_, err = session.Where(builder.Eq{\"id\": userID}).Update(&entity.User{Rank: 1})\n\t\t\tif err != nil {\n\t\t\t\treturn false, errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()\n\t\t\t}\n\t\t\treturn true, nil\n\t\t}\n\t} else {\n\t\tisReachStandard, err = ur.checkUserTodayRank(ctx, session, userID, activityType)\n\t\tif err != nil {\n\t\t\treturn false, errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()\n\t\t}\n\t\tif isReachStandard {\n\t\t\treturn isReachStandard, nil\n\t\t}\n\t}\n\t_, err = session.Where(builder.Eq{\"id\": userID}).Incr(\"`rank`\", deltaRank).Update(&entity.User{})\n\tif err != nil {\n\t\treturn false, errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()\n\t}\n\treturn false, nil\n}\n\nfunc (ur *UserRankRepo) checkUserMinRank(ctx context.Context, session *xorm.Session, userID string, deltaRank int) (\n\tisReachStandard bool, err error,\n) {\n\tbean := &entity.User{ID: userID}\n\t_, err = session.Select(\"`rank`\").Get(bean)\n\tif err != nil {\n\t\treturn false, errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()\n\t}\n\tif bean.Rank+deltaRank < 1 {\n\t\tlog.Infof(\"user %s is rank %d out of range before rank operation\", userID, deltaRank)\n\t\treturn true, nil\n\t}\n\treturn\n}\n\nfunc (ur *UserRankRepo) checkUserTodayRank(ctx context.Context,\n\tsession *xorm.Session, userID string, activityType int,\n) (isReachStandard bool, err error) {\n\t// exclude daily rank\n\texclude, _ := ur.configService.GetArrayStringValue(ctx, \"daily_rank_limit.exclude\")\n\tfor _, item := range exclude {\n\t\tcfg, err := ur.configService.GetConfigByKey(ctx, item)\n\t\tif err != nil {\n\t\t\treturn false, err\n\t\t}\n\t\tif activityType == cfg.ID {\n\t\t\treturn false, nil\n\t\t}\n\t}\n\n\t// get user\n\tstart, end := now.BeginningOfDay(), now.EndOfDay()\n\tsession.Where(builder.Eq{\"user_id\": userID})\n\tsession.Where(builder.Eq{\"cancelled\": 0})\n\tsession.Where(builder.Between{\n\t\tCol:     \"updated_at\",\n\t\tLessVal: start,\n\t\tMoreVal: end,\n\t})\n\tearned, err := session.Sum(&entity.Activity{}, \"`rank`\")\n\tif err != nil {\n\t\treturn false, err\n\t}\n\n\t// max rank\n\tmaxDailyRank, err := ur.configService.GetIntValue(ctx, \"daily_rank_limit\")\n\tif err != nil {\n\t\treturn false, err\n\t}\n\n\tif int(earned) < maxDailyRank {\n\t\treturn false, nil\n\t}\n\tlog.Infof(\"user %s today has rank %d is reach stand %d\", userID, earned, maxDailyRank)\n\treturn true, nil\n}\n\nfunc (ur *UserRankRepo) UserRankPage(ctx context.Context, userID string, page, pageSize int) (\n\trankPage []*entity.Activity, total int64, err error,\n) {\n\trankPage = make([]*entity.Activity, 0)\n\n\tsession := ur.data.DB.Context(ctx).Where(builder.Eq{\"has_rank\": 1}.And(builder.Eq{\"cancelled\": 0})).And(builder.Gt{\"`rank`\": 0})\n\tsession.Desc(\"created_at\")\n\n\tcond := &entity.Activity{UserID: userID}\n\ttotal, err = pager.Help(page, pageSize, &rankPage, cond, session)\n\tif err != nil {\n\t\terr = errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()\n\t}\n\treturn\n}\n", "package user\n\nimport (\n\t\"context\"\n\t\"time\"\n\n\t\"github.com/answerdev/answer/internal/base/data\"\n\t\"github.com/answerdev/answer/internal/base/reason\"\n\t\"github.com/answerdev/answer/internal/entity\"\n\t\"github.com/answerdev/answer/internal/schema\"\n\tusercommon \"github.com/answerdev/answer/internal/service/user_common\"\n\t\"github.com/answerdev/answer/pkg/converter\"\n\t\"github.com/answerdev/answer/plugin\"\n\t\"github.com/segmentfault/pacman/errors\"\n\t\"github.com/segmentfault/pacman/log\"\n\t\"xorm.io/xorm\"\n)\n\n// userRepo user repository\ntype userRepo struct {\n\tdata *data.Data\n}\n\n// NewUserRepo new repository\nfunc NewUserRepo(data *data.Data) usercommon.UserRepo {\n\treturn &userRepo{\n\t\tdata: data,\n\t}\n}\n\n// AddUser add user\nfunc (ur *userRepo) AddUser(ctx context.Context, user *entity.User) (err error) {\n\t_, err = ur.data.DB.Transaction(func(session *xorm.Session) (interface{}, error) {\n\t\tsession = session.Context(ctx)\n\t\tuserInfo := &entity.User{}\n\t\texist, err := session.Where(\"username = ?\", user.Username).Get(userInfo)\n\t\tif err != nil {\n\t\t\treturn nil, errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()\n\t\t}\n\t\tif exist {\n\t\t\treturn nil, errors.InternalServer(reason.UsernameDuplicate)\n\t\t}\n\t\t_, err = session.Insert(user)\n\t\tif err != nil {\n\t\t\treturn nil, errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()\n\t\t}\n\t\treturn nil, nil\n\t})\n\treturn\n}\n\n// IncreaseAnswerCount increase answer count\nfunc (ur *userRepo) IncreaseAnswerCount(ctx context.Context, userID string, amount int) (err error) {\n\tuser := &entity.User{}\n\t_, err = ur.data.DB.Context(ctx).Where(\"id = ?\", userID).Incr(\"answer_count\", amount).Update(user)\n\tif err != nil {\n\t\treturn errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()\n\t}\n\treturn nil\n}\n\n// IncreaseQuestionCount increase question count\nfunc (ur *userRepo) IncreaseQuestionCount(ctx context.Context, userID string, amount int) (err error) {\n\tuser := &entity.User{}\n\t_, err = ur.data.DB.Context(ctx).Where(\"id = ?\", userID).Incr(\"question_count\", amount).Update(user)\n\tif err != nil {\n\t\treturn errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()\n\t}\n\treturn nil\n}\n\nfunc (ur *userRepo) UpdateQuestionCount(ctx context.Context, userID string, count int64) (err error) {\n\tuser := &entity.User{}\n\tuser.QuestionCount = int(count)\n\t_, err = ur.data.DB.Context(ctx).Where(\"id = ?\", userID).Cols(\"question_count\").Update(user)\n\tif err != nil {\n\t\treturn errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()\n\t}\n\treturn nil\n}\n\nfunc (ur *userRepo) UpdateAnswerCount(ctx context.Context, userID string, count int) (err error) {\n\tuser := &entity.User{}\n\tuser.AnswerCount = count\n\t_, err = ur.data.DB.Context(ctx).Where(\"id = ?\", userID).Cols(\"answer_count\").Update(user)\n\tif err != nil {\n\t\treturn errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()\n\t}\n\treturn nil\n}\n\n// UpdateLastLoginDate update last login date\nfunc (ur *userRepo) UpdateLastLoginDate(ctx context.Context, userID string) (err error) {\n\tuser := &entity.User{LastLoginDate: time.Now()}\n\t_, err = ur.data.DB.Context(ctx).Where(\"id = ?\", userID).Cols(\"last_login_date\").Update(user)\n\tif err != nil {\n\t\treturn errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()\n\t}\n\treturn nil\n}\n\n// UpdateEmailStatus update email status\nfunc (ur *userRepo) UpdateEmailStatus(ctx context.Context, userID string, emailStatus int) error {\n\tcond := &entity.User{MailStatus: emailStatus}\n\t_, err := ur.data.DB.Context(ctx).Where(\"id = ?\", userID).Cols(\"mail_status\").Update(cond)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\n// UpdateNoticeStatus update notice status\nfunc (ur *userRepo) UpdateNoticeStatus(ctx context.Context, userID string, noticeStatus int) error {\n\tcond := &entity.User{NoticeStatus: noticeStatus}\n\t_, err := ur.data.DB.Context(ctx).Where(\"id = ?\", userID).Cols(\"notice_status\").Update(cond)\n\tif err != nil {\n\t\treturn errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()\n\t}\n\treturn nil\n}\n\nfunc (ur *userRepo) UpdatePass(ctx context.Context, userID, pass string) error {\n\t_, err := ur.data.DB.Context(ctx).Where(\"id = ?\", userID).Cols(\"pass\").Update(&entity.User{Pass: pass})\n\tif err != nil {\n\t\treturn errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()\n\t}\n\treturn nil\n}\n\nfunc (ur *userRepo) UpdateEmail(ctx context.Context, userID, email string) (err error) {\n\t_, err = ur.data.DB.Context(ctx).Where(\"id = ?\", userID).Update(&entity.User{EMail: email})\n\tif err != nil {\n\t\terr = errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()\n\t}\n\treturn\n}\n\nfunc (ur *userRepo) UpdateLanguage(ctx context.Context, userID, language string) (err error) {\n\t_, err = ur.data.DB.Context(ctx).Where(\"id = ?\", userID).Update(&entity.User{Language: language})\n\tif err != nil {\n\t\terr = errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()\n\t}\n\treturn\n}\n\n// UpdateInfo update user info\nfunc (ur *userRepo) UpdateInfo(ctx context.Context, userInfo *entity.User) (err error) {\n\t_, err = ur.data.DB.Context(ctx).Where(\"id = ?\", userInfo.ID).\n\t\tCols(\"username\", \"display_name\", \"avatar\", \"bio\", \"bio_html\", \"website\", \"location\").Update(userInfo)\n\tif err != nil {\n\t\terr = errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()\n\t}\n\treturn\n}\n\n// GetByUserID get user info by user id\nfunc (ur *userRepo) GetByUserID(ctx context.Context, userID string) (userInfo *entity.User, exist bool, err error) {\n\tuserInfo = &entity.User{}\n\texist, err = ur.data.DB.Context(ctx).Where(\"id = ?\", userID).Get(userInfo)\n\tif err != nil {\n\t\terr = errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()\n\t\treturn\n\t}\n\terr = tryToDecorateUserInfoFromUserCenter(ctx, ur.data, userInfo)\n\tif err != nil {\n\t\treturn nil, false, err\n\t}\n\treturn\n}\n\nfunc (ur *userRepo) BatchGetByID(ctx context.Context, ids []string) ([]*entity.User, error) {\n\tlist := make([]*entity.User, 0)\n\terr := ur.data.DB.Context(ctx).In(\"id\", ids).Find(&list)\n\tif err != nil {\n\t\treturn nil, errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()\n\t}\n\ttryToDecorateUserListFromUserCenter(ctx, ur.data, list)\n\treturn list, nil\n}\n\n// GetByUsername get user by username\nfunc (ur *userRepo) GetByUsername(ctx context.Context, username string) (userInfo *entity.User, exist bool, err error) {\n\tuserInfo = &entity.User{}\n\texist, err = ur.data.DB.Context(ctx).Where(\"username = ?\", username).Get(userInfo)\n\tif err != nil {\n\t\terr = errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()\n\t\treturn\n\t}\n\terr = tryToDecorateUserInfoFromUserCenter(ctx, ur.data, userInfo)\n\tif err != nil {\n\t\treturn nil, false, err\n\t}\n\treturn\n}\n\nfunc (ur *userRepo) GetByUsernames(ctx context.Context, usernames []string) ([]*entity.User, error) {\n\tlist := make([]*entity.User, 0)\n\terr := ur.data.DB.Where(\"status =?\", entity.UserStatusAvailable).In(\"username\", usernames).Find(&list)\n\tif err != nil {\n\t\terr = errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()\n\t\treturn list, err\n\t}\n\ttryToDecorateUserListFromUserCenter(ctx, ur.data, list)\n\treturn list, nil\n}\n\n// GetByEmail get user by email\nfunc (ur *userRepo) GetByEmail(ctx context.Context, email string) (userInfo *entity.User, exist bool, err error) {\n\tuserInfo = &entity.User{}\n\texist, err = ur.data.DB.Context(ctx).Where(\"e_mail = ?\", email).\n\t\tWhere(\"status != ?\", entity.UserStatusDeleted).Get(userInfo)\n\tif err != nil {\n\t\terr = errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()\n\t}\n\treturn\n}\n\nfunc (ur *userRepo) GetUserCount(ctx context.Context) (count int64, err error) {\n\tlist := make([]*entity.User, 0)\n\tcount, err = ur.data.DB.Context(ctx).Where(\"mail_status =?\", entity.EmailStatusAvailable).And(\"status =?\", entity.UserStatusAvailable).FindAndCount(&list)\n\tif err != nil {\n\t\treturn count, errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()\n\t}\n\treturn\n}\n\nfunc (ur *userRepo) SearchUserListByName(ctx context.Context, name string) (userList []*entity.User, err error) {\n\tuserList = make([]*entity.User, 0)\n\tif name == \"\" {\n\t\treturn userList, nil\n\t}\n\tsession := ur.data.DB.Where(\"\")\n\tsession.Where(\"username LIKE LOWER(?) or display_name LIKE ?\", name+\"%\", name+\"%\").And(\"status =?\", entity.UserStatusAvailable)\n\tsession.Asc(\"username\")\n\tsession = session.Limit(5, 0)\n\terr = session.OrderBy(\"id desc\").Find(&userList)\n\tif err != nil {\n\t\terr = errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()\n\t}\n\ttryToDecorateUserListFromUserCenter(ctx, ur.data, userList)\n\treturn\n}\n\nfunc tryToDecorateUserInfoFromUserCenter(ctx context.Context, data *data.Data, original *entity.User) (err error) {\n\tif original == nil {\n\t\treturn nil\n\t}\n\tuc, ok := plugin.GetUserCenter()\n\tif !ok {\n\t\treturn nil\n\t}\n\n\tuserInfo := &entity.UserExternalLogin{}\n\tsession := data.DB.Context(ctx).Where(\"user_id = ?\", original.ID)\n\tsession.Where(\"provider = ?\", uc.Info().SlugName)\n\texist, err := session.Get(userInfo)\n\tif err != nil {\n\t\treturn errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()\n\t}\n\tif !exist {\n\t\treturn nil\n\t}\n\n\tuserCenterBasicUserInfo, err := uc.UserInfo(userInfo.ExternalID)\n\tif err != nil {\n\t\tlog.Error(err)\n\t\treturn errors.BadRequest(reason.UserNotFound).WithError(err).WithStack()\n\t}\n\n\t// In general, usernames should be guaranteed unique by the User Center plugin, so there are no inconsistencies.\n\tif original.Username != userCenterBasicUserInfo.Username {\n\t\tlog.Warnf(\"user %s username is inconsistent with user center\", original.ID)\n\t}\n\tdecorateByUserCenterUser(original, userCenterBasicUserInfo)\n\treturn nil\n}\n\nfunc tryToDecorateUserListFromUserCenter(ctx context.Context, data *data.Data, original []*entity.User) {\n\tuc, ok := plugin.GetUserCenter()\n\tif !ok {\n\t\treturn\n\t}\n\n\tids := make([]string, 0)\n\toriginalUserIDMapping := make(map[string]*entity.User, 0)\n\tfor _, user := range original {\n\t\toriginalUserIDMapping[user.ID] = user\n\t\tids = append(ids, user.ID)\n\t}\n\n\tuserExternalLoginList := make([]*entity.UserExternalLogin, 0)\n\tsession := data.DB.Context(ctx).Where(\"provider = ?\", uc.Info().SlugName)\n\tsession.In(\"user_id\", ids)\n\terr := session.Find(&userExternalLoginList)\n\tif err != nil {\n\t\tlog.Error(err)\n\t\treturn\n\t}\n\n\tuserExternalIDs := make([]string, 0)\n\toriginalExternalIDMapping := make(map[string]*entity.User, 0)\n\tfor _, u := range userExternalLoginList {\n\t\toriginalExternalIDMapping[u.ExternalID] = originalUserIDMapping[u.UserID]\n\t\tuserExternalIDs = append(userExternalIDs, u.ExternalID)\n\t}\n\tif len(userExternalIDs) == 0 {\n\t\treturn\n\t}\n\n\tucUsers, err := uc.UserList(userExternalIDs)\n\tif err != nil {\n\t\tlog.Errorf(\"get user list from user center failed: %v, %v\", err, userExternalIDs)\n\t\treturn\n\t}\n\n\tfor _, ucUser := range ucUsers {\n\t\tdecorateByUserCenterUser(originalExternalIDMapping[ucUser.ExternalID], ucUser)\n\t}\n}\n\nfunc decorateByUserCenterUser(original *entity.User, ucUser *plugin.UserCenterBasicUserInfo) {\n\tif original == nil || ucUser == nil {\n\t\treturn\n\t}\n\t// In general, usernames should be guaranteed unique by the User Center plugin, so there are no inconsistencies.\n\tif original.Username != ucUser.Username {\n\t\tlog.Warnf(\"user %s username is inconsistent with user center\", original.ID)\n\t}\n\tif len(ucUser.DisplayName) > 0 {\n\t\toriginal.DisplayName = ucUser.DisplayName\n\t}\n\tif len(ucUser.Email) > 0 {\n\t\toriginal.EMail = ucUser.Email\n\t}\n\tif len(ucUser.Avatar) > 0 {\n\t\toriginal.Avatar = schema.CustomAvatar(ucUser.Avatar).ToJsonString()\n\t}\n\tif len(ucUser.Mobile) > 0 {\n\t\toriginal.Mobile = ucUser.Mobile\n\t}\n\tif len(ucUser.Bio) > 0 {\n\t\toriginal.BioHTML = converter.Markdown2HTML(ucUser.Bio) + original.BioHTML\n\t}\n\n\t// If plugin enable rank agent, use rank from user center.\n\tif plugin.RankAgentEnabled() {\n\t\toriginal.Rank = ucUser.Rank\n\t}\n\tif ucUser.Status != plugin.UserStatusAvailable {\n\t\toriginal.Status = int(ucUser.Status)\n\t}\n}\n", "package schema\n\ntype VoteReq struct {\n\tObjectID string `validate:\"required\" form:\"object_id\" json:\"object_id\"`  //\t id\n\tIsCancel bool   `validate:\"omitempty\" form:\"is_cancel\" json:\"is_cancel\"` // is cancel\n\tUserID   string `json:\"-\"`\n}\n\ntype VoteDTO struct {\n\t// object TagID\n\tObjectID string\n\t// is cancel\n\tIsCancel bool\n\t// user TagID\n\tUserID string\n}\n\ntype VoteResp struct {\n\tUpVotes    int    `json:\"up_votes\"`\n\tDownVotes  int    `json:\"down_votes\"`\n\tVotes      int    `json:\"votes\"`\n\tVoteStatus string `json:\"vote_status\"`\n}\n\ntype GetVoteWithPageReq struct {\n\t// page\n\tPage int `validate:\"omitempty,min=1\" form:\"page\"`\n\t// page size\n\tPageSize int `validate:\"omitempty,min=1\" form:\"page_size\"`\n\t// user id\n\tUserID string `json:\"-\"`\n}\n\ntype VoteQuestion struct {\n\t// object ID\n\tID string `json:\"id\"`\n\t// title\n\tTitle string `json:\"title\"`\n}\n\ntype VoteAnswer struct {\n\t// object ID\n\tID string `json:\"id\"`\n\t// question ID\n\tQuestionID string `json:\"question_id\"`\n\t// title\n\tTitle string `json:\"title\"`\n}\n\ntype GetVoteWithPageResp struct {\n\t// create time\n\tCreatedAt int64 `json:\"created_at\"`\n\t// object id\n\tObjectID string `json:\"object_id\"`\n\t// question id\n\tQuestionID string `json:\"question_id\"`\n\t// answer id\n\tAnswerID string `json:\"answer_id\"`\n\t// object type\n\tObjectType string `json:\"object_type\" enums:\"question,answer,tag,comment\"`\n\t// title\n\tTitle string `json:\"title\"`\n\t// url title\n\tUrlTitle string `json:\"url_title\"`\n\t// content\n\tContent string `json:\"content\"`\n\t// vote type\n\tVoteType string `json:\"vote_type\"`\n}\n", "package activity\n\nimport (\n\t\"context\"\n\t\"time\"\n\n\t\"github.com/segmentfault/pacman/log\"\n)\n\n// AnswerActivityRepo answer activity\ntype AnswerActivityRepo interface {\n\tAcceptAnswer(ctx context.Context,\n\t\tanswerObjID, questionObjID, questionUserID, answerUserID string, isSelf bool) (err error)\n\tCancelAcceptAnswer(ctx context.Context,\n\t\tanswerObjID, questionObjID, questionUserID, answerUserID string) (err error)\n\tDeleteAnswer(ctx context.Context, answerID string) (err error)\n}\n\n// QuestionActivityRepo answer activity\ntype QuestionActivityRepo interface {\n\tDeleteQuestion(ctx context.Context, questionID string) (err error)\n}\n\n// AnswerActivityService user service\ntype AnswerActivityService struct {\n\tanswerActivityRepo   AnswerActivityRepo\n\tquestionActivityRepo QuestionActivityRepo\n}\n\n// NewAnswerActivityService new comment service\nfunc NewAnswerActivityService(\n\tanswerActivityRepo AnswerActivityRepo, questionActivityRepo QuestionActivityRepo) *AnswerActivityService {\n\treturn &AnswerActivityService{\n\t\tanswerActivityRepo:   answerActivityRepo,\n\t\tquestionActivityRepo: questionActivityRepo,\n\t}\n}\n\n// AcceptAnswer accept answer change activity\nfunc (as *AnswerActivityService) AcceptAnswer(ctx context.Context,\n\tanswerObjID, questionObjID, questionUserID, answerUserID string, isSelf bool) (err error) {\n\treturn as.answerActivityRepo.AcceptAnswer(ctx, answerObjID, questionObjID, questionUserID, answerUserID, isSelf)\n}\n\n// CancelAcceptAnswer cancel accept answer change activity\nfunc (as *AnswerActivityService) CancelAcceptAnswer(ctx context.Context,\n\tanswerObjID, questionObjID, questionUserID, answerUserID string) (err error) {\n\treturn as.answerActivityRepo.CancelAcceptAnswer(ctx, answerObjID, questionObjID, questionUserID, answerUserID)\n}\n\n// DeleteAnswer delete answer change activity\nfunc (as *AnswerActivityService) DeleteAnswer(ctx context.Context, answerID string, createdAt time.Time,\n\tvoteCount int) (err error) {\n\tif voteCount >= 3 {\n\t\tlog.Infof(\"There is no need to roll back the reputation by answering likes above the target value. %s %d\", answerID, voteCount)\n\t\treturn nil\n\t}\n\tif createdAt.Before(time.Now().AddDate(0, 0, -60)) {\n\t\tlog.Infof(\"There is no need to roll back the reputation by answer's existence time meets the target. %s %s\", answerID, createdAt.String())\n\t\treturn nil\n\t}\n\treturn as.answerActivityRepo.DeleteAnswer(ctx, answerID)\n}\n\n// DeleteQuestion delete question change activity\nfunc (as *AnswerActivityService) DeleteQuestion(ctx context.Context, questionID string, createdAt time.Time,\n\tvoteCount int) (err error) {\n\tif voteCount >= 3 {\n\t\tlog.Infof(\"There is no need to roll back the reputation by answering likes above the target value. %s %d\", questionID, voteCount)\n\t\treturn nil\n\t}\n\tif createdAt.Before(time.Now().AddDate(0, 0, -60)) {\n\t\tlog.Infof(\"There is no need to roll back the reputation by answer's existence time meets the target. %s %s\", questionID, createdAt.String())\n\t\treturn nil\n\t}\n\treturn as.questionActivityRepo.DeleteQuestion(ctx, questionID)\n}\n", "package activity_common\n\nimport (\n\t\"context\"\n\t\"time\"\n\n\t\"github.com/answerdev/answer/internal/entity\"\n\t\"github.com/answerdev/answer/internal/schema\"\n\t\"github.com/answerdev/answer/internal/service/activity_queue\"\n\t\"github.com/answerdev/answer/pkg/converter\"\n\t\"github.com/answerdev/answer/pkg/uid\"\n\t\"github.com/segmentfault/pacman/log\"\n\t\"xorm.io/xorm\"\n)\n\ntype ActivityRepo interface {\n\tGetActivityTypeByObjID(ctx context.Context, objectId string, action string) (activityType, rank int, hasRank int, err error)\n\tGetActivityTypeByObjKey(ctx context.Context, objectKey, action string) (activityType int, err error)\n\tGetActivity(ctx context.Context, session *xorm.Session, objectID, userID string, activityType int) (\n\t\texistsActivity *entity.Activity, exist bool, err error)\n\tGetUserIDObjectIDActivitySum(ctx context.Context, userID, objectID string) (int, error)\n\tGetActivityTypeByConfigKey(ctx context.Context, configKey string) (activityType int, err error)\n\tAddActivity(ctx context.Context, activity *entity.Activity) (err error)\n\tGetUsersWhoHasGainedTheMostReputation(\n\t\tctx context.Context, startTime, endTime time.Time, limit int) (rankStat []*entity.ActivityUserRankStat, err error)\n\tGetUsersWhoHasVoteMost(\n\t\tctx context.Context, startTime, endTime time.Time, limit int) (voteStat []*entity.ActivityUserVoteStat, err error)\n}\n\ntype ActivityCommon struct {\n\tactivityRepo         ActivityRepo\n\tactivityQueueService activity_queue.ActivityQueueService\n}\n\n// NewActivityCommon new activity common\nfunc NewActivityCommon(\n\tactivityRepo ActivityRepo,\n\tactivityQueueService activity_queue.ActivityQueueService,\n) *ActivityCommon {\n\tactivity := &ActivityCommon{\n\t\tactivityRepo:         activityRepo,\n\t\tactivityQueueService: activityQueueService,\n\t}\n\tactivity.activityQueueService.RegisterHandler(activity.HandleActivity)\n\treturn activity\n}\n\n// HandleActivity handle activity message\nfunc (ac *ActivityCommon) HandleActivity(ctx context.Context, msg *schema.ActivityMsg) error {\n\tactivityType, err := ac.activityRepo.GetActivityTypeByConfigKey(ctx, string(msg.ActivityTypeKey))\n\tif err != nil {\n\t\tlog.Errorf(\"error getting activity type %s, activity type is %d\", err, activityType)\n\t\treturn err\n\t}\n\n\tact := &entity.Activity{\n\t\tUserID:           msg.UserID,\n\t\tTriggerUserID:    msg.TriggerUserID,\n\t\tObjectID:         uid.DeShortID(msg.ObjectID),\n\t\tOriginalObjectID: uid.DeShortID(msg.OriginalObjectID),\n\t\tActivityType:     activityType,\n\t\tCancelled:        entity.ActivityAvailable,\n\t}\n\tif len(msg.RevisionID) > 0 {\n\t\tact.RevisionID = converter.StringToInt64(msg.RevisionID)\n\t}\n\tif err := ac.activityRepo.AddActivity(ctx, act); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n", "package rank\n\nimport (\n\t\"context\"\n\n\t\"github.com/answerdev/answer/internal/base/constant\"\n\t\"github.com/answerdev/answer/internal/base/handler\"\n\t\"github.com/answerdev/answer/internal/base/pager\"\n\t\"github.com/answerdev/answer/internal/base/reason\"\n\t\"github.com/answerdev/answer/internal/base/translator\"\n\t\"github.com/answerdev/answer/internal/entity\"\n\t\"github.com/answerdev/answer/internal/schema\"\n\t\"github.com/answerdev/answer/internal/service/activity_type\"\n\t\"github.com/answerdev/answer/internal/service/config\"\n\t\"github.com/answerdev/answer/internal/service/object_info\"\n\t\"github.com/answerdev/answer/internal/service/permission\"\n\t\"github.com/answerdev/answer/internal/service/role\"\n\tusercommon \"github.com/answerdev/answer/internal/service/user_common\"\n\t\"github.com/answerdev/answer/pkg/htmltext\"\n\t\"github.com/answerdev/answer/pkg/uid\"\n\t\"github.com/answerdev/answer/plugin\"\n\t\"github.com/segmentfault/pacman/errors\"\n\t\"github.com/segmentfault/pacman/log\"\n\t\"xorm.io/xorm\"\n)\n\nconst (\n\tPermissionPrefix = \"rank.\"\n)\n\ntype UserRankRepo interface {\n\tTriggerUserRank(ctx context.Context, session *xorm.Session, userId string, rank int, activityType int) (isReachStandard bool, err error)\n\tUserRankPage(ctx context.Context, userId string, page, pageSize int) (rankPage []*entity.Activity, total int64, err error)\n}\n\n// RankService rank service\ntype RankService struct {\n\tuserCommon        *usercommon.UserCommon\n\tconfigService     *config.ConfigService\n\tuserRankRepo      UserRankRepo\n\tobjectInfoService *object_info.ObjService\n\troleService       *role.UserRoleRelService\n\trolePowerService  *role.RolePowerRelService\n}\n\n// NewRankService new rank service\nfunc NewRankService(\n\tuserCommon *usercommon.UserCommon,\n\tuserRankRepo UserRankRepo,\n\tobjectInfoService *object_info.ObjService,\n\troleService *role.UserRoleRelService,\n\trolePowerService *role.RolePowerRelService,\n\tconfigService *config.ConfigService) *RankService {\n\treturn &RankService{\n\t\tuserCommon:        userCommon,\n\t\tconfigService:     configService,\n\t\tuserRankRepo:      userRankRepo,\n\t\tobjectInfoService: objectInfoService,\n\t\troleService:       roleService,\n\t\trolePowerService:  rolePowerService,\n\t}\n}\n\n// CheckOperationPermission verify that the user has permission\nfunc (rs *RankService) CheckOperationPermission(ctx context.Context, userID string, action string, objectID string) (\n\tcan bool, err error) {\n\tif len(userID) == 0 {\n\t\treturn false, nil\n\t}\n\n\t// get the rank of the current user\n\tuserInfo, exist, err := rs.userCommon.GetUserBasicInfoByID(ctx, userID)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\tif !exist {\n\t\treturn false, nil\n\t}\n\tpowerMapping := rs.getUserPowerMapping(ctx, userID)\n\tif powerMapping[action] {\n\t\treturn true, nil\n\t}\n\n\tif len(objectID) > 0 {\n\t\tobjectInfo, err := rs.objectInfoService.GetInfo(ctx, objectID)\n\t\tif err != nil {\n\t\t\treturn can, err\n\t\t}\n\t\t// if the user is this object creator, the user can operate this object.\n\t\tif objectInfo != nil &&\n\t\t\tobjectInfo.ObjectCreatorUserID == userID {\n\t\t\treturn true, nil\n\t\t}\n\t}\n\n\tcan, _ = rs.checkUserRank(ctx, userInfo.ID, userInfo.Rank, PermissionPrefix+action)\n\treturn can, nil\n}\n\n// CheckOperationPermissionsForRanks verify that the user has permission\nfunc (rs *RankService) CheckOperationPermissionsForRanks(ctx context.Context, userID string, actions []string) (\n\tcan []bool, requireRanks []int, err error) {\n\tcan = make([]bool, len(actions))\n\trequireRanks = make([]int, len(actions))\n\tif len(userID) == 0 {\n\t\treturn can, requireRanks, nil\n\t}\n\n\t// get the rank of the current user\n\tuserInfo, exist, err := rs.userCommon.GetUserBasicInfoByID(ctx, userID)\n\tif err != nil {\n\t\treturn can, requireRanks, err\n\t}\n\tif !exist {\n\t\treturn can, requireRanks, nil\n\t}\n\n\tpowerMapping := rs.getUserPowerMapping(ctx, userID)\n\tfor idx, action := range actions {\n\t\tif powerMapping[action] {\n\t\t\tcan[idx] = true\n\t\t\tcontinue\n\t\t}\n\t\tmeetRank, requireRank := rs.checkUserRank(ctx, userInfo.ID, userInfo.Rank, PermissionPrefix+action)\n\t\tcan[idx] = meetRank\n\t\trequireRanks[idx] = requireRank\n\t}\n\treturn can, requireRanks, nil\n}\n\n// CheckOperationPermissions verify that the user has permission\nfunc (rs *RankService) CheckOperationPermissions(ctx context.Context, userID string, actions []string) (\n\tcan []bool, err error) {\n\tcan, _, err = rs.CheckOperationPermissionsForRanks(ctx, userID, actions)\n\treturn can, err\n}\n\n// CheckOperationObjectOwner check operation object owner\nfunc (rs *RankService) CheckOperationObjectOwner(ctx context.Context, userID, objectID string) bool {\n\tobjectID = uid.DeShortID(objectID)\n\tobjectInfo, err := rs.objectInfoService.GetInfo(ctx, objectID)\n\tif err != nil {\n\t\tlog.Error(err)\n\t\treturn false\n\t}\n\t// if the user is this object creator, the user can operate this object.\n\tif objectInfo != nil &&\n\t\tobjectInfo.ObjectCreatorUserID == userID {\n\t\treturn true\n\t}\n\treturn false\n}\n\n// CheckVotePermission verify that the user has vote permission\nfunc (rs *RankService) CheckVotePermission(ctx context.Context, userID, objectID string, voteUp bool) (\n\tcan bool, needRank int, err error) {\n\tif len(userID) == 0 || len(objectID) == 0 {\n\t\treturn false, 0, nil\n\t}\n\n\t// get the rank of the current user\n\tuserInfo, exist, err := rs.userCommon.GetUserBasicInfoByID(ctx, userID)\n\tif err != nil {\n\t\treturn can, 0, err\n\t}\n\tif !exist {\n\t\treturn can, 0, nil\n\t}\n\tobjectInfo, err := rs.objectInfoService.GetInfo(ctx, objectID)\n\tif err != nil {\n\t\treturn can, 0, err\n\t}\n\taction := \"\"\n\tswitch objectInfo.ObjectType {\n\tcase constant.QuestionObjectType:\n\t\tif voteUp {\n\t\t\taction = permission.QuestionVoteUp\n\t\t} else {\n\t\t\taction = permission.QuestionVoteDown\n\t\t}\n\tcase constant.AnswerObjectType:\n\t\tif voteUp {\n\t\t\taction = permission.AnswerVoteUp\n\t\t} else {\n\t\t\taction = permission.AnswerVoteDown\n\t\t}\n\tcase constant.CommentObjectType:\n\t\tif voteUp {\n\t\t\taction = permission.CommentVoteUp\n\t\t} else {\n\t\t\taction = permission.CommentVoteDown\n\t\t}\n\t}\n\tpowerMapping := rs.getUserPowerMapping(ctx, userID)\n\tif powerMapping[action] {\n\t\treturn true, 0, nil\n\t}\n\tcan, needRank = rs.checkUserRank(ctx, userInfo.ID, userInfo.Rank, PermissionPrefix+action)\n\treturn can, needRank, nil\n}\n\n// getUserPowerMapping get user power mapping\nfunc (rs *RankService) getUserPowerMapping(ctx context.Context, userID string) (powerMapping map[string]bool) {\n\tpowerMapping = make(map[string]bool, 0)\n\tuserRole, err := rs.roleService.GetUserRole(ctx, userID)\n\tif err != nil {\n\t\tlog.Error(err)\n\t\treturn powerMapping\n\t}\n\tpowers, err := rs.rolePowerService.GetRolePowerList(ctx, userRole)\n\tif err != nil {\n\t\tlog.Error(err)\n\t\treturn powerMapping\n\t}\n\n\tfor _, power := range powers {\n\t\tpowerMapping[power] = true\n\t}\n\treturn powerMapping\n}\n\n// CheckRankPermission verify that the user meets the prestige criteria\nfunc (rs *RankService) checkUserRank(ctx context.Context, userID string, userRank int, action string) (\n\tcan bool, rank int) {\n\t// get the amount of rank required for the current operation\n\trequireRank, err := rs.configService.GetIntValue(ctx, action)\n\tif err != nil {\n\t\tlog.Error(err)\n\t\treturn false, requireRank\n\t}\n\tif userRank < requireRank || requireRank < 0 {\n\t\tlog.Debugf(\"user %s want to do action %s, but rank %d < %d\",\n\t\t\tuserID, action, userRank, requireRank)\n\t\treturn false, requireRank\n\t}\n\treturn true, requireRank\n}\n\n// GetRankPersonalPage get personal comment list page\nfunc (rs *RankService) GetRankPersonalPage(ctx context.Context, req *schema.GetRankPersonalWithPageReq) (\n\tpageModel *pager.PageModel, err error) {\n\tif plugin.RankAgentEnabled() {\n\t\treturn pager.NewPageModel(0, []string{}), nil\n\t}\n\tif len(req.Username) > 0 {\n\t\tuserInfo, exist, err := rs.userCommon.GetUserBasicInfoByUserName(ctx, req.Username)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tif !exist {\n\t\t\treturn nil, errors.BadRequest(reason.UserNotFound)\n\t\t}\n\t\treq.UserID = userInfo.ID\n\t}\n\tif len(req.UserID) == 0 {\n\t\treturn nil, errors.BadRequest(reason.UserNotFound)\n\t}\n\n\tuserRankPage, total, err := rs.userRankRepo.UserRankPage(ctx, req.UserID, req.Page, req.PageSize)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tresp := rs.decorateRankPersonalPageResp(ctx, userRankPage)\n\treturn pager.NewPageModel(total, resp), nil\n}\n\nfunc (rs *RankService) decorateRankPersonalPageResp(\n\tctx context.Context, userRankPage []*entity.Activity) []*schema.GetRankPersonalPageResp {\n\tresp := make([]*schema.GetRankPersonalPageResp, 0)\n\tlang := handler.GetLangByCtx(ctx)\n\n\tfor _, userRankInfo := range userRankPage {\n\t\tif len(userRankInfo.ObjectID) == 0 || userRankInfo.ObjectID == \"0\" {\n\t\t\tcontinue\n\t\t}\n\t\tobjInfo, err := rs.objectInfoService.GetInfo(ctx, userRankInfo.ObjectID)\n\t\tif err != nil {\n\t\t\tlog.Error(err)\n\t\t\tcontinue\n\t\t}\n\n\t\tcommentResp := &schema.GetRankPersonalPageResp{\n\t\t\tCreatedAt:  userRankInfo.CreatedAt.Unix(),\n\t\t\tObjectID:   userRankInfo.ObjectID,\n\t\t\tReputation: userRankInfo.Rank,\n\t\t}\n\t\tcfg, err := rs.configService.GetConfigByID(ctx, userRankInfo.ActivityType)\n\t\tif err != nil {\n\t\t\tlog.Error(err)\n\t\t\tcontinue\n\t\t}\n\t\tcommentResp.RankType = translator.Tr(lang, activity_type.ActivityTypeFlagMapping[cfg.Key])\n\t\tcommentResp.ObjectType = objInfo.ObjectType\n\t\tcommentResp.Title = objInfo.Title\n\t\tcommentResp.UrlTitle = htmltext.UrlTitle(objInfo.Title)\n\t\tcommentResp.Content = objInfo.Content\n\t\tif objInfo.QuestionStatus == entity.QuestionStatusDeleted {\n\t\t\tcommentResp.Title = translator.Tr(lang, constant.DeletedQuestionTitleTrKey)\n\t\t}\n\t\tcommentResp.QuestionID = objInfo.QuestionID\n\t\tcommentResp.AnswerID = objInfo.AnswerID\n\t\tresp = append(resp, commentResp)\n\t}\n\treturn resp\n}\n", "package service\n\nimport (\n\t\"context\"\n\n\t\"github.com/answerdev/answer/internal/base/constant\"\n\t\"github.com/answerdev/answer/internal/base/handler\"\n\t\"github.com/answerdev/answer/internal/base/pager\"\n\t\"github.com/answerdev/answer/internal/base/translator\"\n\t\"github.com/answerdev/answer/internal/entity\"\n\t\"github.com/answerdev/answer/internal/service/activity_type\"\n\t\"github.com/answerdev/answer/internal/service/comment_common\"\n\t\"github.com/answerdev/answer/internal/service/config\"\n\t\"github.com/answerdev/answer/internal/service/object_info\"\n\t\"github.com/answerdev/answer/pkg/htmltext\"\n\t\"github.com/answerdev/answer/pkg/obj\"\n\t\"github.com/segmentfault/pacman/log\"\n\n\t\"github.com/answerdev/answer/internal/base/reason\"\n\t\"github.com/answerdev/answer/internal/schema\"\n\tanswercommon \"github.com/answerdev/answer/internal/service/answer_common\"\n\tquestioncommon \"github.com/answerdev/answer/internal/service/question_common\"\n\t\"github.com/answerdev/answer/internal/service/unique\"\n\t\"github.com/segmentfault/pacman/errors\"\n)\n\n// VoteRepo activity repository\ntype VoteRepo interface {\n\tVoteUp(ctx context.Context, objectID string, userID, objectUserID string) (resp *schema.VoteResp, err error)\n\tVoteDown(ctx context.Context, objectID string, userID, objectUserID string) (resp *schema.VoteResp, err error)\n\tVoteUpCancel(ctx context.Context, objectID string, userID, objectUserID string) (resp *schema.VoteResp, err error)\n\tVoteDownCancel(ctx context.Context, objectID string, userID, objectUserID string) (resp *schema.VoteResp, err error)\n\tGetVoteResultByObjectId(ctx context.Context, objectID string) (resp *schema.VoteResp, err error)\n\tListUserVotes(ctx context.Context, userID string, page int, pageSize int, activityTypes []int) (\n\t\tvoteList []entity.Activity, total int64, err error)\n}\n\n// VoteService user service\ntype VoteService struct {\n\tvoteRepo          VoteRepo\n\tUniqueIDRepo      unique.UniqueIDRepo\n\tconfigService     *config.ConfigService\n\tquestionRepo      questioncommon.QuestionRepo\n\tanswerRepo        answercommon.AnswerRepo\n\tcommentCommonRepo comment_common.CommentCommonRepo\n\tobjectService     *object_info.ObjService\n}\n\nfunc NewVoteService(\n\tVoteRepo VoteRepo,\n\tuniqueIDRepo unique.UniqueIDRepo,\n\tconfigService *config.ConfigService,\n\tquestionRepo questioncommon.QuestionRepo,\n\tanswerRepo answercommon.AnswerRepo,\n\tcommentCommonRepo comment_common.CommentCommonRepo,\n\tobjectService *object_info.ObjService,\n) *VoteService {\n\treturn &VoteService{\n\t\tvoteRepo:          VoteRepo,\n\t\tUniqueIDRepo:      uniqueIDRepo,\n\t\tconfigService:     configService,\n\t\tquestionRepo:      questionRepo,\n\t\tanswerRepo:        answerRepo,\n\t\tcommentCommonRepo: commentCommonRepo,\n\t\tobjectService:     objectService,\n\t}\n}\n\n// VoteUp vote up\nfunc (vs *VoteService) VoteUp(ctx context.Context, dto *schema.VoteDTO) (voteResp *schema.VoteResp, err error) {\n\tvoteResp = &schema.VoteResp{}\n\n\tvar objectUserID string\n\n\tobjectUserID, err = vs.GetObjectUserID(ctx, dto.ObjectID)\n\tif err != nil {\n\t\treturn\n\t}\n\n\t// check user is voting self or not\n\tif objectUserID == dto.UserID {\n\t\terr = errors.BadRequest(reason.DisallowVoteYourSelf)\n\t\treturn\n\t}\n\n\tif dto.IsCancel {\n\t\treturn vs.voteRepo.VoteUpCancel(ctx, dto.ObjectID, dto.UserID, objectUserID)\n\t} else {\n\t\treturn vs.voteRepo.VoteUp(ctx, dto.ObjectID, dto.UserID, objectUserID)\n\t}\n}\n\n// VoteDown vote down\nfunc (vs *VoteService) VoteDown(ctx context.Context, dto *schema.VoteDTO) (voteResp *schema.VoteResp, err error) {\n\tvoteResp = &schema.VoteResp{}\n\n\tvar objectUserID string\n\n\tobjectUserID, err = vs.GetObjectUserID(ctx, dto.ObjectID)\n\tif err != nil {\n\t\treturn\n\t}\n\n\t// check user is voting self or not\n\tif objectUserID == dto.UserID {\n\t\terr = errors.BadRequest(reason.DisallowVoteYourSelf)\n\t\treturn\n\t}\n\n\tif dto.IsCancel {\n\t\treturn vs.voteRepo.VoteDownCancel(ctx, dto.ObjectID, dto.UserID, objectUserID)\n\t} else {\n\t\treturn vs.voteRepo.VoteDown(ctx, dto.ObjectID, dto.UserID, objectUserID)\n\t}\n}\n\nfunc (vs *VoteService) GetObjectUserID(ctx context.Context, objectID string) (userID string, err error) {\n\tvar objectKey string\n\tobjectKey, err = obj.GetObjectTypeStrByObjectID(objectID)\n\n\tif err != nil {\n\t\terr = nil\n\t\treturn\n\t}\n\n\tswitch objectKey {\n\tcase \"question\":\n\t\tobject, has, e := vs.questionRepo.GetQuestion(ctx, objectID)\n\t\tif e != nil || !has {\n\t\t\terr = errors.BadRequest(reason.QuestionNotFound).WithError(e).WithStack()\n\t\t\treturn\n\t\t}\n\t\tuserID = object.UserID\n\tcase \"answer\":\n\t\tobject, has, e := vs.answerRepo.GetAnswer(ctx, objectID)\n\t\tif e != nil || !has {\n\t\t\terr = errors.BadRequest(reason.AnswerNotFound).WithError(e).WithStack()\n\t\t\treturn\n\t\t}\n\t\tuserID = object.UserID\n\tcase \"comment\":\n\t\tobject, has, e := vs.commentCommonRepo.GetComment(ctx, objectID)\n\t\tif e != nil || !has {\n\t\t\terr = errors.BadRequest(reason.CommentNotFound).WithError(e).WithStack()\n\t\t\treturn\n\t\t}\n\t\tuserID = object.UserID\n\tdefault:\n\t\terr = errors.BadRequest(reason.DisallowVote).WithError(err).WithStack()\n\t\treturn\n\t}\n\n\treturn\n}\n\n// ListUserVotes list user's votes\nfunc (vs *VoteService) ListUserVotes(ctx context.Context, req schema.GetVoteWithPageReq) (resp *pager.PageModel, err error) {\n\ttypeKeys := []string{\n\t\tactivity_type.QuestionVoteUp,\n\t\tactivity_type.QuestionVoteDown,\n\t\tactivity_type.AnswerVoteUp,\n\t\tactivity_type.AnswerVoteDown,\n\t}\n\tactivityTypes := make([]int, 0)\n\tactivityTypeMapping := make(map[int]string, 0)\n\n\tfor _, typeKey := range typeKeys {\n\t\tcfg, err := vs.configService.GetConfigByKey(ctx, typeKey)\n\t\tif err != nil {\n\t\t\tcontinue\n\t\t}\n\t\tactivityTypes = append(activityTypes, cfg.ID)\n\t\tactivityTypeMapping[cfg.ID] = typeKey\n\t}\n\n\tvoteList, total, err := vs.voteRepo.ListUserVotes(ctx, req.UserID, req.Page, req.PageSize, activityTypes)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tlang := handler.GetLangByCtx(ctx)\n\n\tvotes := make([]*schema.GetVoteWithPageResp, 0)\n\tfor _, voteInfo := range voteList {\n\t\tobjInfo, err := vs.objectService.GetInfo(ctx, voteInfo.ObjectID)\n\t\tif err != nil {\n\t\t\tlog.Error(err)\n\t\t\tcontinue\n\t\t}\n\n\t\titem := &schema.GetVoteWithPageResp{\n\t\t\tCreatedAt:  voteInfo.CreatedAt.Unix(),\n\t\t\tObjectID:   objInfo.ObjectID,\n\t\t\tQuestionID: objInfo.QuestionID,\n\t\t\tAnswerID:   objInfo.AnswerID,\n\t\t\tObjectType: objInfo.ObjectType,\n\t\t\tTitle:      objInfo.Title,\n\t\t\tUrlTitle:   htmltext.UrlTitle(objInfo.Title),\n\t\t\tContent:    objInfo.Content,\n\t\t}\n\t\titem.VoteType = translator.Tr(lang,\n\t\t\tactivity_type.ActivityTypeFlagMapping[activityTypeMapping[voteInfo.ActivityType]])\n\t\tif objInfo.QuestionStatus == entity.QuestionStatusDeleted {\n\t\t\titem.Title = translator.Tr(lang, constant.DeletedQuestionTitleTrKey)\n\t\t}\n\t\tvotes = append(votes, item)\n\t}\n\treturn pager.NewPageModel(total, votes), err\n}\n"], "fixing_code": ["// Code generated by Wire. DO NOT EDIT.\n\n//go:generate go run github.com/google/wire/cmd/wire\n//go:build !wireinject\n// +build !wireinject\n\npackage answercmd\n\nimport (\n\t\"github.com/answerdev/answer/internal/base/conf\"\n\t\"github.com/answerdev/answer/internal/base/cron\"\n\t\"github.com/answerdev/answer/internal/base/data\"\n\t\"github.com/answerdev/answer/internal/base/middleware\"\n\t\"github.com/answerdev/answer/internal/base/server\"\n\t\"github.com/answerdev/answer/internal/base/translator\"\n\t\"github.com/answerdev/answer/internal/controller\"\n\t\"github.com/answerdev/answer/internal/controller/template_render\"\n\t\"github.com/answerdev/answer/internal/controller_admin\"\n\t\"github.com/answerdev/answer/internal/repo/activity\"\n\t\"github.com/answerdev/answer/internal/repo/activity_common\"\n\t\"github.com/answerdev/answer/internal/repo/answer\"\n\t\"github.com/answerdev/answer/internal/repo/auth\"\n\t\"github.com/answerdev/answer/internal/repo/captcha\"\n\t\"github.com/answerdev/answer/internal/repo/collection\"\n\t\"github.com/answerdev/answer/internal/repo/comment\"\n\t\"github.com/answerdev/answer/internal/repo/config\"\n\t\"github.com/answerdev/answer/internal/repo/export\"\n\t\"github.com/answerdev/answer/internal/repo/meta\"\n\t\"github.com/answerdev/answer/internal/repo/notification\"\n\t\"github.com/answerdev/answer/internal/repo/plugin_config\"\n\t\"github.com/answerdev/answer/internal/repo/question\"\n\t\"github.com/answerdev/answer/internal/repo/rank\"\n\t\"github.com/answerdev/answer/internal/repo/reason\"\n\t\"github.com/answerdev/answer/internal/repo/report\"\n\t\"github.com/answerdev/answer/internal/repo/revision\"\n\t\"github.com/answerdev/answer/internal/repo/role\"\n\t\"github.com/answerdev/answer/internal/repo/search_common\"\n\t\"github.com/answerdev/answer/internal/repo/site_info\"\n\t\"github.com/answerdev/answer/internal/repo/tag\"\n\t\"github.com/answerdev/answer/internal/repo/tag_common\"\n\t\"github.com/answerdev/answer/internal/repo/unique\"\n\t\"github.com/answerdev/answer/internal/repo/user\"\n\t\"github.com/answerdev/answer/internal/repo/user_external_login\"\n\t\"github.com/answerdev/answer/internal/router\"\n\t\"github.com/answerdev/answer/internal/service\"\n\t\"github.com/answerdev/answer/internal/service/action\"\n\tactivity2 \"github.com/answerdev/answer/internal/service/activity\"\n\tactivity_common2 \"github.com/answerdev/answer/internal/service/activity_common\"\n\t\"github.com/answerdev/answer/internal/service/activity_queue\"\n\t\"github.com/answerdev/answer/internal/service/answer_common\"\n\tauth2 \"github.com/answerdev/answer/internal/service/auth\"\n\t\"github.com/answerdev/answer/internal/service/collection_common\"\n\tcomment2 \"github.com/answerdev/answer/internal/service/comment\"\n\t\"github.com/answerdev/answer/internal/service/comment_common\"\n\tconfig2 \"github.com/answerdev/answer/internal/service/config\"\n\t\"github.com/answerdev/answer/internal/service/dashboard\"\n\texport2 \"github.com/answerdev/answer/internal/service/export\"\n\t\"github.com/answerdev/answer/internal/service/follow\"\n\tmeta2 \"github.com/answerdev/answer/internal/service/meta\"\n\t\"github.com/answerdev/answer/internal/service/notice_queue\"\n\tnotification2 \"github.com/answerdev/answer/internal/service/notification\"\n\t\"github.com/answerdev/answer/internal/service/notification_common\"\n\t\"github.com/answerdev/answer/internal/service/object_info\"\n\t\"github.com/answerdev/answer/internal/service/plugin_common\"\n\t\"github.com/answerdev/answer/internal/service/question_common\"\n\trank2 \"github.com/answerdev/answer/internal/service/rank\"\n\treason2 \"github.com/answerdev/answer/internal/service/reason\"\n\treport2 \"github.com/answerdev/answer/internal/service/report\"\n\t\"github.com/answerdev/answer/internal/service/report_admin\"\n\t\"github.com/answerdev/answer/internal/service/report_handle_admin\"\n\t\"github.com/answerdev/answer/internal/service/revision_common\"\n\trole2 \"github.com/answerdev/answer/internal/service/role\"\n\t\"github.com/answerdev/answer/internal/service/search_parser\"\n\t\"github.com/answerdev/answer/internal/service/service_config\"\n\t\"github.com/answerdev/answer/internal/service/siteinfo\"\n\t\"github.com/answerdev/answer/internal/service/siteinfo_common\"\n\ttag2 \"github.com/answerdev/answer/internal/service/tag\"\n\ttag_common2 \"github.com/answerdev/answer/internal/service/tag_common\"\n\t\"github.com/answerdev/answer/internal/service/uploader\"\n\t\"github.com/answerdev/answer/internal/service/user_admin\"\n\t\"github.com/answerdev/answer/internal/service/user_common\"\n\tuser_external_login2 \"github.com/answerdev/answer/internal/service/user_external_login\"\n\t\"github.com/segmentfault/pacman\"\n\t\"github.com/segmentfault/pacman/log\"\n)\n\n// Injectors from wire.go:\n\n// initApplication init application.\nfunc initApplication(debug bool, serverConf *conf.Server, dbConf *data.Database, cacheConf *data.CacheConf, i18nConf *translator.I18n, swaggerConf *router.SwaggerConfig, serviceConf *service_config.ServiceConfig, logConf log.Logger) (*pacman.Application, func(), error) {\n\tstaticRouter := router.NewStaticRouter(serviceConf)\n\ti18nTranslator, err := translator.NewTranslator(i18nConf)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tengine, err := data.NewDB(debug, dbConf)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tcache, cleanup, err := data.NewCache(cacheConf)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tdataData, cleanup2, err := data.NewData(engine, cache)\n\tif err != nil {\n\t\tcleanup()\n\t\treturn nil, nil, err\n\t}\n\tsiteInfoRepo := site_info.NewSiteInfo(dataData)\n\tsiteInfoCommonService := siteinfo_common.NewSiteInfoCommonService(siteInfoRepo)\n\tlangController := controller.NewLangController(i18nTranslator, siteInfoCommonService)\n\tauthRepo := auth.NewAuthRepo(dataData)\n\tauthService := auth2.NewAuthService(authRepo)\n\tuserRepo := user.NewUserRepo(dataData)\n\tuniqueIDRepo := unique.NewUniqueIDRepo(dataData)\n\tconfigRepo := config.NewConfigRepo(dataData)\n\tconfigService := config2.NewConfigService(configRepo)\n\tactivityRepo := activity_common.NewActivityRepo(dataData, uniqueIDRepo, configService)\n\tuserRankRepo := rank.NewUserRankRepo(dataData, configService)\n\tuserActiveActivityRepo := activity.NewUserActiveActivityRepo(dataData, activityRepo, userRankRepo, configService)\n\temailRepo := export.NewEmailRepo(dataData)\n\temailService := export2.NewEmailService(configService, emailRepo, siteInfoRepo)\n\tuserRoleRelRepo := role.NewUserRoleRelRepo(dataData)\n\troleRepo := role.NewRoleRepo(dataData)\n\troleService := role2.NewRoleService(roleRepo)\n\tuserRoleRelService := role2.NewUserRoleRelService(userRoleRelRepo, roleService)\n\tuserCommon := usercommon.NewUserCommon(userRepo, userRoleRelService, authService, siteInfoCommonService)\n\tuserExternalLoginRepo := user_external_login.NewUserExternalLoginRepo(dataData)\n\tuserExternalLoginService := user_external_login2.NewUserExternalLoginService(userRepo, userCommon, userExternalLoginRepo, emailService, siteInfoCommonService, userActiveActivityRepo)\n\tuserService := service.NewUserService(userRepo, userActiveActivityRepo, activityRepo, emailService, authService, siteInfoCommonService, userRoleRelService, userCommon, userExternalLoginService)\n\tcaptchaRepo := captcha.NewCaptchaRepo(dataData)\n\tcaptchaService := action.NewCaptchaService(captchaRepo)\n\tuserController := controller.NewUserController(authService, userService, captchaService, emailService, siteInfoCommonService)\n\tcommentRepo := comment.NewCommentRepo(dataData, uniqueIDRepo)\n\tcommentCommonRepo := comment.NewCommentCommonRepo(dataData, uniqueIDRepo)\n\tanswerRepo := answer.NewAnswerRepo(dataData, uniqueIDRepo, userRankRepo, activityRepo)\n\tquestionRepo := question.NewQuestionRepo(dataData, uniqueIDRepo)\n\ttagCommonRepo := tag_common.NewTagCommonRepo(dataData, uniqueIDRepo)\n\ttagRelRepo := tag.NewTagRelRepo(dataData, uniqueIDRepo)\n\ttagRepo := tag.NewTagRepo(dataData, uniqueIDRepo)\n\trevisionRepo := revision.NewRevisionRepo(dataData, uniqueIDRepo)\n\trevisionService := revision_common.NewRevisionService(revisionRepo, userRepo)\n\tactivityQueueService := activity_queue.NewActivityQueueService()\n\ttagCommonService := tag_common2.NewTagCommonService(tagCommonRepo, tagRelRepo, tagRepo, revisionService, siteInfoCommonService, activityQueueService)\n\tobjService := object_info.NewObjService(answerRepo, questionRepo, commentCommonRepo, tagCommonRepo, tagCommonService)\n\tvoteRepo := activity_common.NewVoteRepo(dataData, activityRepo)\n\tnotificationQueueService := notice_queue.NewNotificationQueueService()\n\tcommentService := comment2.NewCommentService(commentRepo, commentCommonRepo, userCommon, objService, voteRepo, emailService, userRepo, notificationQueueService, activityQueueService)\n\trolePowerRelRepo := role.NewRolePowerRelRepo(dataData)\n\trolePowerRelService := role2.NewRolePowerRelService(rolePowerRelRepo, userRoleRelService)\n\trankService := rank2.NewRankService(userCommon, userRankRepo, objService, userRoleRelService, rolePowerRelService, configService)\n\tcommentController := controller.NewCommentController(commentService, rankService)\n\treportRepo := report.NewReportRepo(dataData, uniqueIDRepo)\n\treportService := report2.NewReportService(reportRepo, objService)\n\treportController := controller.NewReportController(reportService, rankService)\n\tserviceVoteRepo := activity.NewVoteRepo(dataData, activityRepo, userRankRepo, notificationQueueService)\n\tvoteService := service.NewVoteService(serviceVoteRepo, configService, questionRepo, answerRepo, commentCommonRepo, objService)\n\tvoteController := controller.NewVoteController(voteService, rankService)\n\tfollowRepo := activity_common.NewFollowRepo(dataData, uniqueIDRepo, activityRepo)\n\ttagService := tag2.NewTagService(tagRepo, tagCommonService, revisionService, followRepo, siteInfoCommonService, activityQueueService)\n\ttagController := controller.NewTagController(tagService, tagCommonService, rankService)\n\tfollowFollowRepo := activity.NewFollowRepo(dataData, uniqueIDRepo, activityRepo)\n\tfollowService := follow.NewFollowService(followFollowRepo, followRepo, tagCommonRepo)\n\tfollowController := controller.NewFollowController(followService)\n\tcollectionRepo := collection.NewCollectionRepo(dataData, uniqueIDRepo)\n\tcollectionGroupRepo := collection.NewCollectionGroupRepo(dataData)\n\tcollectionCommon := collectioncommon.NewCollectionCommon(collectionRepo)\n\tanswerCommon := answercommon.NewAnswerCommon(answerRepo)\n\tmetaRepo := meta.NewMetaRepo(dataData)\n\tmetaService := meta2.NewMetaService(metaRepo)\n\tquestionCommon := questioncommon.NewQuestionCommon(questionRepo, answerRepo, voteRepo, followRepo, tagCommonService, userCommon, collectionCommon, answerCommon, metaService, configService, activityQueueService, dataData)\n\tcollectionService := service.NewCollectionService(collectionRepo, collectionGroupRepo, questionCommon)\n\tcollectionController := controller.NewCollectionController(collectionService)\n\tanswerActivityRepo := activity.NewAnswerActivityRepo(dataData, activityRepo, userRankRepo, notificationQueueService)\n\tanswerActivityService := activity2.NewAnswerActivityService(answerActivityRepo)\n\tquestionService := service.NewQuestionService(questionRepo, tagCommonService, questionCommon, userCommon, userRepo, revisionService, metaService, collectionCommon, answerActivityService, emailService, notificationQueueService, activityQueueService, siteInfoCommonService)\n\tanswerService := service.NewAnswerService(answerRepo, questionRepo, questionCommon, userCommon, collectionCommon, userRepo, revisionService, answerActivityService, answerCommon, voteRepo, emailService, userRoleRelService, notificationQueueService, activityQueueService)\n\tquestionController := controller.NewQuestionController(questionService, answerService, rankService, siteInfoCommonService)\n\tanswerController := controller.NewAnswerController(answerService, rankService)\n\tsearchParser := search_parser.NewSearchParser(tagCommonService, userCommon)\n\tsearchRepo := search_common.NewSearchRepo(dataData, uniqueIDRepo, userCommon)\n\tsearchService := service.NewSearchService(searchParser, searchRepo)\n\tsearchController := controller.NewSearchController(searchService)\n\tserviceRevisionService := service.NewRevisionService(revisionRepo, userCommon, questionCommon, answerService, objService, questionRepo, answerRepo, tagRepo, tagCommonService, notificationQueueService, activityQueueService)\n\trevisionController := controller.NewRevisionController(serviceRevisionService, rankService)\n\trankController := controller.NewRankController(rankService)\n\treportHandle := report_handle_admin.NewReportHandle(questionCommon, commentRepo, configService, notificationQueueService)\n\treportAdminService := report_admin.NewReportAdminService(reportRepo, userCommon, answerRepo, questionRepo, commentCommonRepo, reportHandle, configService, objService)\n\tcontroller_adminReportController := controller_admin.NewReportController(reportAdminService)\n\tuserAdminRepo := user.NewUserAdminRepo(dataData, authRepo)\n\tuserAdminService := user_admin.NewUserAdminService(userAdminRepo, userRoleRelService, authService, userCommon, userActiveActivityRepo, siteInfoCommonService)\n\tuserAdminController := controller_admin.NewUserAdminController(userAdminService)\n\treasonRepo := reason.NewReasonRepo(configService)\n\treasonService := reason2.NewReasonService(reasonRepo)\n\treasonController := controller.NewReasonController(reasonService)\n\tthemeController := controller_admin.NewThemeController()\n\tsiteInfoService := siteinfo.NewSiteInfoService(siteInfoRepo, siteInfoCommonService, emailService, tagCommonService, configService, questionCommon)\n\tsiteInfoController := controller_admin.NewSiteInfoController(siteInfoService)\n\tcontrollerSiteInfoController := controller.NewSiteInfoController(siteInfoCommonService)\n\tnotificationRepo := notification.NewNotificationRepo(dataData)\n\tnotificationCommon := notificationcommon.NewNotificationCommon(dataData, notificationRepo, userCommon, activityRepo, followRepo, objService, notificationQueueService)\n\tnotificationService := notification2.NewNotificationService(dataData, notificationRepo, notificationCommon, revisionService)\n\tnotificationController := controller.NewNotificationController(notificationService, rankService)\n\tdashboardService := dashboard.NewDashboardService(questionRepo, answerRepo, commentCommonRepo, voteRepo, userRepo, reportRepo, configService, siteInfoCommonService, serviceConf, dataData)\n\tdashboardController := controller.NewDashboardController(dashboardService)\n\tuploaderService := uploader.NewUploaderService(serviceConf, siteInfoCommonService)\n\tuploadController := controller.NewUploadController(uploaderService)\n\tactivityCommon := activity_common2.NewActivityCommon(activityRepo, activityQueueService)\n\tactivityActivityRepo := activity.NewActivityRepo(dataData, configService)\n\tcommentCommonService := comment_common.NewCommentCommonService(commentCommonRepo)\n\tactivityService := activity2.NewActivityService(activityActivityRepo, userCommon, activityCommon, tagCommonService, objService, commentCommonService, revisionService, metaService, configService)\n\tactivityController := controller.NewActivityController(activityCommon, activityService)\n\troleController := controller_admin.NewRoleController(roleService)\n\tpluginConfigRepo := plugin_config.NewPluginConfigRepo(dataData)\n\tpluginCommonService := plugin_common.NewPluginCommonService(pluginConfigRepo, configService)\n\tpluginController := controller_admin.NewPluginController(pluginCommonService)\n\tpermissionController := controller.NewPermissionController(rankService)\n\tanswerAPIRouter := router.NewAnswerAPIRouter(langController, userController, commentController, reportController, voteController, tagController, followController, collectionController, questionController, answerController, searchController, revisionController, rankController, controller_adminReportController, userAdminController, reasonController, themeController, siteInfoController, controllerSiteInfoController, notificationController, dashboardController, uploadController, activityController, roleController, pluginController, permissionController)\n\tswaggerRouter := router.NewSwaggerRouter(swaggerConf)\n\tuiRouter := router.NewUIRouter(controllerSiteInfoController, siteInfoCommonService)\n\tauthUserMiddleware := middleware.NewAuthUserMiddleware(authService, siteInfoCommonService)\n\tavatarMiddleware := middleware.NewAvatarMiddleware(serviceConf, uploaderService)\n\tshortIDMiddleware := middleware.NewShortIDMiddleware(siteInfoCommonService)\n\ttemplateRenderController := templaterender.NewTemplateRenderController(questionService, userService, tagService, answerService, commentService, siteInfoCommonService, questionRepo)\n\ttemplateController := controller.NewTemplateController(templateRenderController, siteInfoCommonService)\n\ttemplateRouter := router.NewTemplateRouter(templateController, templateRenderController, siteInfoController)\n\tconnectorController := controller.NewConnectorController(siteInfoCommonService, emailService, userExternalLoginService)\n\tuserCenterLoginService := user_external_login2.NewUserCenterLoginService(userRepo, userCommon, userExternalLoginRepo, userActiveActivityRepo, siteInfoCommonService)\n\tuserCenterController := controller.NewUserCenterController(userCenterLoginService, siteInfoCommonService)\n\tpluginAPIRouter := router.NewPluginAPIRouter(connectorController, userCenterController)\n\tginEngine := server.NewHTTPServer(debug, staticRouter, answerAPIRouter, swaggerRouter, uiRouter, authUserMiddleware, avatarMiddleware, shortIDMiddleware, templateRouter, pluginAPIRouter)\n\tscheduledTaskManager := cron.NewScheduledTaskManager(siteInfoCommonService, questionService)\n\tapplication := newApplication(serverConf, ginEngine, scheduledTaskManager)\n\treturn application, func() {\n\t\tcleanup2()\n\t\tcleanup()\n\t}, nil\n}\n", "package controller\n\nimport (\n\t\"github.com/answerdev/answer/internal/base/handler\"\n\t\"github.com/answerdev/answer/internal/base/middleware\"\n\t\"github.com/answerdev/answer/internal/base/reason\"\n\t\"github.com/answerdev/answer/internal/base/translator\"\n\t\"github.com/answerdev/answer/internal/schema\"\n\t\"github.com/answerdev/answer/internal/service\"\n\t\"github.com/answerdev/answer/internal/service/rank\"\n\t\"github.com/answerdev/answer/pkg/uid\"\n\t\"github.com/gin-gonic/gin\"\n\t\"github.com/segmentfault/pacman/errors\"\n)\n\n// VoteController activity controller\ntype VoteController struct {\n\tVoteService *service.VoteService\n\trankService *rank.RankService\n}\n\n// NewVoteController new controller\nfunc NewVoteController(voteService *service.VoteService, rankService *rank.RankService) *VoteController {\n\treturn &VoteController{VoteService: voteService, rankService: rankService}\n}\n\n// VoteUp godoc\n// @Summary vote up\n// @Description add vote\n// @Tags Activity\n// @Accept json\n// @Produce json\n// @Security ApiKeyAuth\n// @Param data body schema.VoteReq true \"vote\"\n// @Success 200 {object} handler.RespBody{data=schema.VoteResp}\n// @Router /answer/api/v1/vote/up [post]\nfunc (vc *VoteController) VoteUp(ctx *gin.Context) {\n\treq := &schema.VoteReq{}\n\tif handler.BindAndCheck(ctx, req) {\n\t\treturn\n\t}\n\treq.ObjectID = uid.DeShortID(req.ObjectID)\n\treq.UserID = middleware.GetLoginUserIDFromContext(ctx)\n\tcan, needRank, err := vc.rankService.CheckVotePermission(ctx, req.UserID, req.ObjectID, true)\n\tif err != nil {\n\t\thandler.HandleResponse(ctx, err, nil)\n\t\treturn\n\t}\n\tif !can {\n\t\tlang := handler.GetLang(ctx)\n\t\tmsg := translator.TrWithData(lang, reason.NoEnoughRankToOperate, &schema.PermissionTrTplData{Rank: needRank})\n\t\thandler.HandleResponse(ctx, errors.Forbidden(reason.NoEnoughRankToOperate).WithMsg(msg), nil)\n\t\treturn\n\t}\n\n\tresp, err := vc.VoteService.VoteUp(ctx, req)\n\tif err != nil {\n\t\thandler.HandleResponse(ctx, err, schema.ErrTypeToast)\n\t} else {\n\t\thandler.HandleResponse(ctx, err, resp)\n\t}\n}\n\n// VoteDown godoc\n// @Summary vote down\n// @Description add vote\n// @Tags Activity\n// @Accept json\n// @Produce json\n// @Security ApiKeyAuth\n// @Param data body schema.VoteReq true \"vote\"\n// @Success 200 {object} handler.RespBody{data=schema.VoteResp}\n// @Router /answer/api/v1/vote/down [post]\nfunc (vc *VoteController) VoteDown(ctx *gin.Context) {\n\treq := &schema.VoteReq{}\n\tif handler.BindAndCheck(ctx, req) {\n\t\treturn\n\t}\n\treq.ObjectID = uid.DeShortID(req.ObjectID)\n\treq.UserID = middleware.GetLoginUserIDFromContext(ctx)\n\tcan, needRank, err := vc.rankService.CheckVotePermission(ctx, req.UserID, req.ObjectID, false)\n\tif err != nil {\n\t\thandler.HandleResponse(ctx, err, nil)\n\t\treturn\n\t}\n\tif !can {\n\t\tlang := handler.GetLang(ctx)\n\t\tmsg := translator.TrWithData(lang, reason.NoEnoughRankToOperate, &schema.PermissionTrTplData{Rank: needRank})\n\t\thandler.HandleResponse(ctx, errors.Forbidden(reason.NoEnoughRankToOperate).WithMsg(msg), nil)\n\t\treturn\n\t}\n\n\tresp, err := vc.VoteService.VoteDown(ctx, req)\n\tif err != nil {\n\t\thandler.HandleResponse(ctx, err, schema.ErrTypeToast)\n\t} else {\n\t\thandler.HandleResponse(ctx, err, resp)\n\t}\n}\n\n// UserVotes user votes\n// @Summary get user personal votes\n// @Description get user personal votes\n// @Tags Activity\n// @Accept json\n// @Produce json\n// @Security ApiKeyAuth\n// @Param page query int false \"page size\"\n// @Param page_size query int false \"page size\"\n// @Success 200 {object} handler.RespBody{data=pager.PageModel{list=[]schema.GetVoteWithPageResp}}\n// @Router /answer/api/v1/personal/vote/page [get]\nfunc (vc *VoteController) UserVotes(ctx *gin.Context) {\n\treq := schema.GetVoteWithPageReq{}\n\tif handler.BindAndCheck(ctx, &req) {\n\t\treturn\n\t}\n\n\treq.UserID = middleware.GetLoginUserIDFromContext(ctx)\n\n\tresp, err := vc.VoteService.ListUserVotes(ctx, req)\n\thandler.HandleResponse(ctx, err, resp)\n}\n", "package activity\n\nimport (\n\t\"context\"\n\t\"time\"\n\n\t\"github.com/answerdev/answer/internal/base/constant\"\n\t\"github.com/answerdev/answer/internal/base/data\"\n\t\"github.com/answerdev/answer/internal/base/reason\"\n\t\"github.com/answerdev/answer/internal/entity\"\n\t\"github.com/answerdev/answer/internal/schema\"\n\t\"github.com/answerdev/answer/internal/service/activity\"\n\t\"github.com/answerdev/answer/internal/service/activity_common\"\n\t\"github.com/answerdev/answer/internal/service/notice_queue\"\n\t\"github.com/answerdev/answer/internal/service/rank\"\n\t\"github.com/answerdev/answer/pkg/converter\"\n\t\"github.com/segmentfault/pacman/errors\"\n\t\"xorm.io/xorm\"\n)\n\nvar (\n\tacceptActionList = []string{constant.ActAccept, constant.ActAccepted}\n)\n\n// AnswerActivityRepo answer accepted\ntype AnswerActivityRepo struct {\n\tdata                     *data.Data\n\tactivityRepo             activity_common.ActivityRepo\n\tuserRankRepo             rank.UserRankRepo\n\tnotificationQueueService notice_queue.NotificationQueueService\n}\n\n// NewAnswerActivityRepo new repository\nfunc NewAnswerActivityRepo(\n\tdata *data.Data,\n\tactivityRepo activity_common.ActivityRepo,\n\tuserRankRepo rank.UserRankRepo,\n\tnotificationQueueService notice_queue.NotificationQueueService,\n) activity.AnswerActivityRepo {\n\treturn &AnswerActivityRepo{\n\t\tdata:                     data,\n\t\tactivityRepo:             activityRepo,\n\t\tuserRankRepo:             userRankRepo,\n\t\tnotificationQueueService: notificationQueueService,\n\t}\n}\n\n// AcceptAnswer accept other answer\nfunc (ar *AnswerActivityRepo) AcceptAnswer(ctx context.Context,\n\tanswerObjID, questionObjID, questionUserID, answerUserID string, isSelf bool,\n) (err error) {\n\taddActivityList := make([]*entity.Activity, 0)\n\tfor _, action := range acceptActionList {\n\t\t// get accept answer need add rank amount\n\t\tactivityType, deltaRank, hasRank, e := ar.activityRepo.GetActivityTypeByObjID(ctx, answerObjID, action)\n\t\tif e != nil {\n\t\t\treturn errors.InternalServer(reason.DatabaseError).WithError(e).WithStack()\n\t\t}\n\t\taddActivity := &entity.Activity{\n\t\t\tObjectID:         answerObjID,\n\t\t\tOriginalObjectID: questionObjID,\n\t\t\tActivityType:     activityType,\n\t\t\tRank:             deltaRank,\n\t\t\tHasRank:          hasRank,\n\t\t}\n\t\tif action == constant.ActAccept {\n\t\t\taddActivity.UserID = questionUserID\n\t\t\taddActivity.TriggerUserID = converter.StringToInt64(answerUserID)\n\t\t\taddActivity.OriginalObjectID = questionObjID // if activity is 'accept' means this question is accept the answer.\n\t\t} else {\n\t\t\taddActivity.UserID = answerUserID\n\t\t\taddActivity.TriggerUserID = converter.StringToInt64(answerUserID)\n\t\t\taddActivity.OriginalObjectID = answerObjID // if activity is 'accepted' means this answer was accepted.\n\t\t}\n\t\tif isSelf {\n\t\t\taddActivity.Rank = 0\n\t\t\taddActivity.HasRank = 0\n\t\t}\n\t\taddActivityList = append(addActivityList, addActivity)\n\t}\n\n\t_, err = ar.data.DB.Transaction(func(session *xorm.Session) (result any, err error) {\n\t\tsession = session.Context(ctx)\n\t\tfor _, addActivity := range addActivityList {\n\t\t\texistsActivity, exists, e := ar.activityRepo.GetActivity(\n\t\t\t\tctx, session, answerObjID, addActivity.UserID, addActivity.ActivityType)\n\t\t\tif e != nil {\n\t\t\t\treturn nil, errors.InternalServer(reason.DatabaseError).WithError(e).WithStack()\n\t\t\t}\n\t\t\tif exists && existsActivity.Cancelled == entity.ActivityAvailable {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\t// trigger user rank and send notification\n\t\t\tif addActivity.Rank != 0 {\n\t\t\t\treachStandard, e := ar.userRankRepo.TriggerUserRank(\n\t\t\t\t\tctx, session, addActivity.UserID, addActivity.Rank, addActivity.ActivityType)\n\t\t\t\tif e != nil {\n\t\t\t\t\treturn nil, errors.InternalServer(reason.DatabaseError).WithError(e).WithStack()\n\t\t\t\t}\n\t\t\t\tif reachStandard {\n\t\t\t\t\taddActivity.Rank = 0\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif exists {\n\t\t\t\tif _, e = session.Where(\"id = ?\", existsActivity.ID).Cols(\"`cancelled`\").\n\t\t\t\t\tUpdate(&entity.Activity{Cancelled: entity.ActivityAvailable}); e != nil {\n\t\t\t\t\treturn nil, errors.InternalServer(reason.DatabaseError).WithError(e).WithStack()\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif _, e = session.Insert(addActivity); e != nil {\n\t\t\t\t\treturn nil, errors.InternalServer(reason.DatabaseError).WithError(e).WithStack()\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn nil, nil\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\tfor _, act := range addActivityList {\n\t\tmsg := &schema.NotificationMsg{\n\t\t\tType:           schema.NotificationTypeAchievement,\n\t\t\tObjectID:       act.ObjectID,\n\t\t\tReceiverUserID: act.UserID,\n\t\t}\n\t\tif act.UserID == questionUserID {\n\t\t\tmsg.TriggerUserID = answerUserID\n\t\t\tmsg.ObjectType = constant.AnswerObjectType\n\t\t} else {\n\t\t\tmsg.TriggerUserID = questionUserID\n\t\t\tmsg.ObjectType = constant.AnswerObjectType\n\t\t}\n\t\tif msg.TriggerUserID != msg.ReceiverUserID {\n\t\t\tar.notificationQueueService.Send(ctx, msg)\n\t\t}\n\t}\n\n\tfor _, act := range addActivityList {\n\t\tmsg := &schema.NotificationMsg{\n\t\t\tReceiverUserID: act.UserID,\n\t\t\tType:           schema.NotificationTypeInbox,\n\t\t\tObjectID:       act.ObjectID,\n\t\t}\n\t\tif act.UserID != questionUserID {\n\t\t\tmsg.TriggerUserID = questionUserID\n\t\t\tmsg.ObjectType = constant.AnswerObjectType\n\t\t\tmsg.NotificationAction = constant.NotificationAcceptAnswer\n\t\t\tar.notificationQueueService.Send(ctx, msg)\n\t\t}\n\t}\n\treturn err\n}\n\n// CancelAcceptAnswer accept other answer\nfunc (ar *AnswerActivityRepo) CancelAcceptAnswer(ctx context.Context,\n\tanswerObjID, questionObjID, questionUserID, answerUserID string,\n) (err error) {\n\taddActivityList := make([]*entity.Activity, 0)\n\tfor _, action := range acceptActionList {\n\t\t// get accept answer need add rank amount\n\t\tactivityType, deltaRank, hasRank, e := ar.activityRepo.GetActivityTypeByObjID(ctx, answerObjID, action)\n\t\tif e != nil {\n\t\t\treturn errors.InternalServer(reason.DatabaseError).WithError(e).WithStack()\n\t\t}\n\t\taddActivity := &entity.Activity{\n\t\t\tObjectID:     answerObjID,\n\t\t\tActivityType: activityType,\n\t\t\tRank:         -deltaRank,\n\t\t\tHasRank:      hasRank,\n\t\t}\n\t\tif action == constant.ActAccept {\n\t\t\taddActivity.UserID = questionUserID\n\t\t\taddActivity.OriginalObjectID = questionObjID\n\t\t} else {\n\t\t\taddActivity.UserID = answerUserID\n\t\t\taddActivity.OriginalObjectID = answerObjID\n\t\t}\n\t\taddActivityList = append(addActivityList, addActivity)\n\t}\n\n\t_, err = ar.data.DB.Transaction(func(session *xorm.Session) (result any, err error) {\n\t\tsession = session.Context(ctx)\n\t\tfor _, addActivity := range addActivityList {\n\t\t\texistsActivity, exists, e := ar.activityRepo.GetActivity(\n\t\t\t\tctx, session, answerObjID, addActivity.UserID, addActivity.ActivityType)\n\t\t\tif e != nil {\n\t\t\t\treturn nil, errors.InternalServer(reason.DatabaseError).WithError(e).WithStack()\n\t\t\t}\n\t\t\tif exists && existsActivity.Cancelled == entity.ActivityCancelled {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif !exists {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tif existsActivity.Rank != 0 {\n\t\t\t\t_, e = ar.userRankRepo.TriggerUserRank(\n\t\t\t\t\tctx, session, addActivity.UserID, addActivity.Rank, addActivity.ActivityType)\n\t\t\t\tif e != nil {\n\t\t\t\t\treturn nil, errors.InternalServer(reason.DatabaseError).WithError(e).WithStack()\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif _, e := session.Where(\"id = ?\", existsActivity.ID).Cols(\"cancelled\", \"cancelled_at\").\n\t\t\t\tUpdate(&entity.Activity{Cancelled: entity.ActivityCancelled, CancelledAt: time.Now()}); e != nil {\n\t\t\t\treturn nil, errors.InternalServer(reason.DatabaseError).WithError(e).WithStack()\n\t\t\t}\n\t\t}\n\t\treturn nil, nil\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\tfor _, act := range addActivityList {\n\t\tmsg := &schema.NotificationMsg{\n\t\t\tReceiverUserID: act.UserID,\n\t\t\tType:           schema.NotificationTypeAchievement,\n\t\t\tObjectID:       act.ObjectID,\n\t\t}\n\t\tif act.UserID == questionUserID {\n\t\t\tmsg.TriggerUserID = answerUserID\n\t\t\tmsg.ObjectType = constant.QuestionObjectType\n\t\t} else {\n\t\t\tmsg.TriggerUserID = questionUserID\n\t\t\tmsg.ObjectType = constant.AnswerObjectType\n\t\t}\n\t\tif msg.TriggerUserID != msg.ReceiverUserID {\n\t\t\tar.notificationQueueService.Send(ctx, msg)\n\t\t}\n\t}\n\treturn err\n}\n", "package activity\n\nimport (\n\t\"context\"\n\t\"time\"\n\n\t\"github.com/answerdev/answer/internal/service/activity_common\"\n\t\"github.com/answerdev/answer/internal/service/follow\"\n\t\"github.com/answerdev/answer/pkg/obj\"\n\t\"github.com/segmentfault/pacman/log\"\n\t\"xorm.io/builder\"\n\n\t\"github.com/answerdev/answer/internal/base/data\"\n\t\"github.com/answerdev/answer/internal/base/reason\"\n\t\"github.com/answerdev/answer/internal/entity\"\n\t\"github.com/answerdev/answer/internal/service/unique\"\n\t\"github.com/segmentfault/pacman/errors\"\n\t\"xorm.io/xorm\"\n)\n\n// FollowRepo activity repository\ntype FollowRepo struct {\n\tdata         *data.Data\n\tuniqueIDRepo unique.UniqueIDRepo\n\tactivityRepo activity_common.ActivityRepo\n}\n\n// NewFollowRepo new repository\nfunc NewFollowRepo(\n\tdata *data.Data,\n\tuniqueIDRepo unique.UniqueIDRepo,\n\tactivityRepo activity_common.ActivityRepo,\n) follow.FollowRepo {\n\treturn &FollowRepo{\n\t\tdata:         data,\n\t\tuniqueIDRepo: uniqueIDRepo,\n\t\tactivityRepo: activityRepo,\n\t}\n}\n\nfunc (ar *FollowRepo) Follow(ctx context.Context, objectID, userID string) error {\n\tobjectTypeStr, err := obj.GetObjectTypeStrByObjectID(objectID)\n\tif err != nil {\n\t\treturn errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()\n\t}\n\tactivityType, err := ar.activityRepo.GetActivityTypeByObjectType(ctx, objectTypeStr, \"follow\")\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t_, err = ar.data.DB.Transaction(func(session *xorm.Session) (result any, err error) {\n\t\tsession = session.Context(ctx)\n\t\tvar (\n\t\t\texistsActivity entity.Activity\n\t\t\thas            bool\n\t\t)\n\t\tresult = nil\n\n\t\thas, err = session.Where(builder.Eq{\"activity_type\": activityType}).\n\t\t\tAnd(builder.Eq{\"user_id\": userID}).\n\t\t\tAnd(builder.Eq{\"object_id\": objectID}).\n\t\t\tGet(&existsActivity)\n\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\n\t\tif has && existsActivity.Cancelled == entity.ActivityAvailable {\n\t\t\treturn\n\t\t}\n\n\t\tif has {\n\t\t\t_, err = session.Where(builder.Eq{\"id\": existsActivity.ID}).\n\t\t\t\tCols(`cancelled`).\n\t\t\t\tUpdate(&entity.Activity{\n\t\t\t\t\tCancelled: entity.ActivityAvailable,\n\t\t\t\t})\n\t\t} else {\n\t\t\t// update existing activity with new user id and u object id\n\t\t\t_, err = session.Insert(&entity.Activity{\n\t\t\t\tUserID:           userID,\n\t\t\t\tObjectID:         objectID,\n\t\t\t\tOriginalObjectID: objectID,\n\t\t\t\tActivityType:     activityType,\n\t\t\t\tCancelled:        entity.ActivityAvailable,\n\t\t\t\tRank:             0,\n\t\t\t\tHasRank:          0,\n\t\t\t})\n\t\t}\n\n\t\tif err != nil {\n\t\t\tlog.Error(err)\n\t\t\treturn\n\t\t}\n\n\t\t// start update followers when everything is fine\n\t\terr = ar.updateFollows(ctx, session, objectID, 1)\n\t\tif err != nil {\n\t\t\tlog.Error(err)\n\t\t}\n\n\t\treturn\n\t})\n\n\treturn err\n}\n\nfunc (ar *FollowRepo) FollowCancel(ctx context.Context, objectID, userID string) error {\n\tobjectTypeStr, err := obj.GetObjectTypeStrByObjectID(objectID)\n\tif err != nil {\n\t\treturn errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()\n\t}\n\tactivityType, err := ar.activityRepo.GetActivityTypeByObjectType(ctx, objectTypeStr, \"follow\")\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t_, err = ar.data.DB.Transaction(func(session *xorm.Session) (result any, err error) {\n\t\tsession = session.Context(ctx)\n\t\tvar (\n\t\t\texistsActivity entity.Activity\n\t\t\thas            bool\n\t\t)\n\t\tresult = nil\n\n\t\thas, err = session.Where(builder.Eq{\"activity_type\": activityType}).\n\t\t\tAnd(builder.Eq{\"user_id\": userID}).\n\t\t\tAnd(builder.Eq{\"object_id\": objectID}).\n\t\t\tGet(&existsActivity)\n\n\t\tif err != nil || !has {\n\t\t\treturn\n\t\t}\n\n\t\tif has && existsActivity.Cancelled == entity.ActivityCancelled {\n\t\t\treturn\n\t\t}\n\t\tif _, err = session.Where(\"id = ?\", existsActivity.ID).\n\t\t\tCols(\"cancelled\").\n\t\t\tUpdate(&entity.Activity{\n\t\t\t\tCancelled:   entity.ActivityCancelled,\n\t\t\t\tCancelledAt: time.Now(),\n\t\t\t}); err != nil {\n\t\t\treturn\n\t\t}\n\t\terr = ar.updateFollows(ctx, session, objectID, -1)\n\t\treturn\n\t})\n\treturn err\n}\n\nfunc (ar *FollowRepo) updateFollows(ctx context.Context, session *xorm.Session, objectID string, follows int) error {\n\tobjectType, err := obj.GetObjectTypeStrByObjectID(objectID)\n\tif err != nil {\n\t\treturn err\n\t}\n\tswitch objectType {\n\tcase \"question\":\n\t\t_, err = session.Where(\"id = ?\", objectID).Incr(\"follow_count\", follows).Update(&entity.Question{})\n\tcase \"user\":\n\t\t_, err = session.Where(\"id = ?\", objectID).Incr(\"follow_count\", follows).Update(&entity.User{})\n\tcase \"tag\":\n\t\t_, err = session.Where(\"id = ?\", objectID).Incr(\"follow_count\", follows).Update(&entity.Tag{})\n\tdefault:\n\t\terr = errors.InternalServer(reason.DisallowFollow).WithMsg(\"this object can't be followed\")\n\t}\n\treturn err\n}\n", "package activity\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"xorm.io/builder\"\n\n\t\"github.com/answerdev/answer/internal/base/data\"\n\t\"github.com/answerdev/answer/internal/base/reason\"\n\t\"github.com/answerdev/answer/internal/entity\"\n\t\"github.com/answerdev/answer/internal/service/activity\"\n\t\"github.com/answerdev/answer/internal/service/activity_common\"\n\t\"github.com/answerdev/answer/internal/service/config\"\n\t\"github.com/answerdev/answer/internal/service/rank\"\n\t\"github.com/segmentfault/pacman/errors\"\n\t\"xorm.io/xorm\"\n)\n\n// UserActiveActivityRepo answer accepted\ntype UserActiveActivityRepo struct {\n\tdata          *data.Data\n\tactivityRepo  activity_common.ActivityRepo\n\tuserRankRepo  rank.UserRankRepo\n\tconfigService *config.ConfigService\n}\n\nconst (\n\tUserActivated = \"user.activated\"\n)\n\n// NewUserActiveActivityRepo new repository\nfunc NewUserActiveActivityRepo(\n\tdata *data.Data,\n\tactivityRepo activity_common.ActivityRepo,\n\tuserRankRepo rank.UserRankRepo,\n\tconfigService *config.ConfigService,\n) activity.UserActiveActivityRepo {\n\treturn &UserActiveActivityRepo{\n\t\tdata:          data,\n\t\tactivityRepo:  activityRepo,\n\t\tuserRankRepo:  userRankRepo,\n\t\tconfigService: configService,\n\t}\n}\n\n// UserActive user active\nfunc (ar *UserActiveActivityRepo) UserActive(ctx context.Context, userID string) (err error) {\n\tcfg, err := ar.configService.GetConfigByKey(ctx, UserActivated)\n\tif err != nil {\n\t\treturn err\n\t}\n\taddActivity := &entity.Activity{\n\t\tUserID:           userID,\n\t\tObjectID:         \"0\",\n\t\tOriginalObjectID: \"0\",\n\t\tActivityType:     cfg.ID,\n\t\tRank:             cfg.GetIntValue(),\n\t\tHasRank:          1,\n\t}\n\n\t_, err = ar.data.DB.Transaction(func(session *xorm.Session) (result any, err error) {\n\t\tsession = session.Context(ctx)\n\n\t\tuser := &entity.User{}\n\t\texist, err := session.ID(userID).ForUpdate().Get(user)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tif !exist {\n\t\t\treturn nil, fmt.Errorf(\"user not exist\")\n\t\t}\n\n\t\texistsActivity := &entity.Activity{}\n\t\texist, err = session.\n\t\t\tAnd(builder.Eq{\"user_id\": addActivity.UserID}).\n\t\t\tAnd(builder.Eq{\"activity_type\": addActivity.ActivityType}).\n\t\t\tGet(existsActivity)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tif exist {\n\t\t\treturn nil, nil\n\t\t}\n\n\t\terr = ar.userRankRepo.ChangeUserRank(ctx, session, addActivity.UserID, user.Rank, addActivity.Rank)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\t_, err = session.Insert(addActivity)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\treturn nil, nil\n\t})\n\tif err != nil {\n\t\treturn errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()\n\t}\n\treturn nil\n}\n", "package activity\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"github.com/segmentfault/pacman/log\"\n\t\"time\"\n\n\t\"github.com/answerdev/answer/internal/base/constant\"\n\t\"github.com/answerdev/answer/internal/service/notice_queue\"\n\t\"github.com/answerdev/answer/pkg/converter\"\n\n\t\"github.com/answerdev/answer/internal/base/pager\"\n\t\"github.com/answerdev/answer/internal/service/rank\"\n\t\"github.com/answerdev/answer/pkg/obj\"\n\n\t\"xorm.io/builder\"\n\n\t\"github.com/answerdev/answer/internal/base/data\"\n\t\"github.com/answerdev/answer/internal/base/reason\"\n\t\"github.com/answerdev/answer/internal/entity\"\n\t\"github.com/answerdev/answer/internal/schema\"\n\t\"github.com/answerdev/answer/internal/service\"\n\t\"github.com/answerdev/answer/internal/service/activity_common\"\n\t\"github.com/segmentfault/pacman/errors\"\n\t\"xorm.io/xorm\"\n)\n\n// VoteRepo activity repository\ntype VoteRepo struct {\n\tdata                     *data.Data\n\tactivityRepo             activity_common.ActivityRepo\n\tuserRankRepo             rank.UserRankRepo\n\tnotificationQueueService notice_queue.NotificationQueueService\n}\n\n// NewVoteRepo new repository\nfunc NewVoteRepo(\n\tdata *data.Data,\n\tactivityRepo activity_common.ActivityRepo,\n\tuserRankRepo rank.UserRankRepo,\n\tnotificationQueueService notice_queue.NotificationQueueService,\n) service.VoteRepo {\n\treturn &VoteRepo{\n\t\tdata:                     data,\n\t\tactivityRepo:             activityRepo,\n\t\tuserRankRepo:             userRankRepo,\n\t\tnotificationQueueService: notificationQueueService,\n\t}\n}\n\nfunc (vr *VoteRepo) Vote(ctx context.Context, op *schema.VoteOperationInfo) (err error) {\n\tnoNeedToVote, err := vr.votePreCheck(ctx, op)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif noNeedToVote {\n\t\treturn nil\n\t}\n\n\tsendInboxNotification := false\n\tmaxDailyRank, err := vr.userRankRepo.GetMaxDailyRank(ctx)\n\tif err != nil {\n\t\treturn err\n\t}\n\tvar userIDs []string\n\tfor _, activity := range op.Activities {\n\t\tuserIDs = append(userIDs, activity.ActivityUserID)\n\t}\n\n\t_, err = vr.data.DB.Transaction(func(session *xorm.Session) (result any, err error) {\n\t\tsession = session.Context(ctx)\n\n\t\tuserInfoMapping, err := vr.acquireUserInfo(session, userIDs)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\terr = vr.setActivityRankToZeroIfUserReachLimit(ctx, session, op, maxDailyRank)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tsendInboxNotification, err = vr.saveActivitiesAvailable(session, op)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\terr = vr.changeUserRank(ctx, session, op, userInfoMapping)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\treturn nil, nil\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tfor _, activity := range op.Activities {\n\t\tif activity.Rank == 0 {\n\t\t\tcontinue\n\t\t}\n\t\tvr.sendAchievementNotification(ctx, activity.ActivityUserID, op.ObjectCreatorUserID, op.ObjectID)\n\t}\n\tif sendInboxNotification {\n\t\tvr.sendVoteInboxNotification(ctx, op.OperatingUserID, op.ObjectCreatorUserID, op.ObjectID, op.VoteUp)\n\t}\n\treturn nil\n}\n\nfunc (vr *VoteRepo) CancelVote(ctx context.Context, op *schema.VoteOperationInfo) (err error) {\n\t// Pre-Check\n\t// 1. check if the activity exist\n\t// 2. check if the activity is not cancelled\n\t// 3. if all activities are cancelled, return directly\n\tactivities, err := vr.getExistActivity(ctx, op)\n\tif err != nil {\n\t\treturn err\n\t}\n\tvar userIDs []string\n\tfor _, activity := range activities {\n\t\tif activity.Cancelled == entity.ActivityCancelled {\n\t\t\tcontinue\n\t\t}\n\t\tuserIDs = append(userIDs, activity.UserID)\n\t}\n\tif len(userIDs) == 0 {\n\t\treturn nil\n\t}\n\n\t_, err = vr.data.DB.Transaction(func(session *xorm.Session) (result any, err error) {\n\t\tsession = session.Context(ctx)\n\n\t\tuserInfoMapping, err := vr.acquireUserInfo(session, userIDs)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\terr = vr.cancelActivities(session, activities)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\terr = vr.rollbackUserRank(ctx, session, activities, userInfoMapping)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\treturn nil, nil\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tfor _, activity := range activities {\n\t\tif activity.Rank == 0 {\n\t\t\tcontinue\n\t\t}\n\t\tvr.sendAchievementNotification(ctx, activity.UserID, op.ObjectCreatorUserID, op.ObjectID)\n\t}\n\treturn nil\n}\n\nfunc (vr *VoteRepo) GetAndSaveVoteResult(ctx context.Context, objectID, objectType string) (\n\tup, down int64, err error) {\n\tup = vr.countVoteUp(ctx, objectID, objectType)\n\tdown = vr.countVoteDown(ctx, objectID, objectType)\n\terr = vr.updateVotes(ctx, objectID, objectType, int(up-down))\n\treturn\n}\n\nfunc (vr *VoteRepo) ListUserVotes(ctx context.Context, userID string,\n\tpage int, pageSize int, activityTypes []int) (voteList []*entity.Activity, total int64, err error) {\n\tsession := vr.data.DB.Context(ctx)\n\tcond := builder.\n\t\tAnd(\n\t\t\tbuilder.Eq{\"user_id\": userID},\n\t\t\tbuilder.Eq{\"cancelled\": 0},\n\t\t\tbuilder.In(\"activity_type\", activityTypes),\n\t\t)\n\n\tsession.Where(cond).Desc(\"updated_at\")\n\n\ttotal, err = pager.Help(page, pageSize, &voteList, &entity.Activity{}, session)\n\tif err != nil {\n\t\terr = errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()\n\t}\n\treturn\n}\n\nfunc (vr *VoteRepo) votePreCheck(ctx context.Context, op *schema.VoteOperationInfo) (noNeedToVote bool, err error) {\n\tactivities, err := vr.getExistActivity(ctx, op)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\tdone := 0\n\tfor _, activity := range activities {\n\t\tif activity.Cancelled == entity.ActivityAvailable {\n\t\t\tdone++\n\t\t}\n\t}\n\treturn done == len(op.Activities), nil\n}\n\nfunc (vr *VoteRepo) acquireUserInfo(session *xorm.Session, userIDs []string) (map[string]*entity.User, error) {\n\tus := make([]*entity.User, 0)\n\terr := session.In(\"id\", userIDs).ForUpdate().Find(&us)\n\tif err != nil {\n\t\tlog.Error(err)\n\t\treturn nil, err\n\t}\n\n\tusers := make(map[string]*entity.User, 0)\n\tfor _, u := range us {\n\t\tusers[u.ID] = u\n\t}\n\treturn users, nil\n}\n\nfunc (vr *VoteRepo) setActivityRankToZeroIfUserReachLimit(ctx context.Context, session *xorm.Session,\n\top *schema.VoteOperationInfo, maxDailyRank int) (err error) {\n\t// check if user reach daily rank limit\n\tfor _, activity := range op.Activities {\n\t\treach, err := vr.userRankRepo.CheckReachLimit(ctx, session, activity.ActivityUserID, maxDailyRank)\n\t\tif err != nil {\n\t\t\tlog.Error(err)\n\t\t\treturn err\n\t\t}\n\t\tif reach {\n\t\t\tactivity.Rank = 0\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (vr *VoteRepo) changeUserRank(ctx context.Context, session *xorm.Session,\n\top *schema.VoteOperationInfo,\n\tuserInfoMapping map[string]*entity.User) (err error) {\n\tfor _, activity := range op.Activities {\n\t\tif activity.Rank == 0 {\n\t\t\tcontinue\n\t\t}\n\t\tuser := userInfoMapping[activity.ActivityUserID]\n\t\tif user == nil {\n\t\t\tcontinue\n\t\t}\n\t\tif err = vr.userRankRepo.ChangeUserRank(ctx, session,\n\t\t\tactivity.ActivityUserID, user.Rank, activity.Rank); err != nil {\n\t\t\tlog.Error(err)\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (vr *VoteRepo) rollbackUserRank(ctx context.Context, session *xorm.Session,\n\tactivities []*entity.Activity,\n\tuserInfoMapping map[string]*entity.User) (err error) {\n\tfor _, activity := range activities {\n\t\tif activity.Rank == 0 {\n\t\t\tcontinue\n\t\t}\n\t\tuser := userInfoMapping[activity.UserID]\n\t\tif user == nil {\n\t\t\tcontinue\n\t\t}\n\t\tif err = vr.userRankRepo.ChangeUserRank(ctx, session,\n\t\t\tactivity.UserID, user.Rank, -activity.Rank); err != nil {\n\t\t\tlog.Error(err)\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\n// saveActivitiesAvailable save activities\n// If activity not exist it will be created or else will be updated\n// If this activity is already exist, set activity rank to 0\n// So after this function, the activity rank will be correct for update user rank\nfunc (vr *VoteRepo) saveActivitiesAvailable(session *xorm.Session, op *schema.VoteOperationInfo) (newAct bool, err error) {\n\tfor _, activity := range op.Activities {\n\t\texistsActivity := &entity.Activity{}\n\t\texist, err := session.\n\t\t\tWhere(builder.Eq{\"object_id\": op.ObjectID}).\n\t\t\tAnd(builder.Eq{\"user_id\": activity.ActivityUserID}).\n\t\t\tAnd(builder.Eq{\"trigger_user_id\": activity.TriggerUserID}).\n\t\t\tAnd(builder.Eq{\"activity_type\": activity.ActivityType}).\n\t\t\tGet(existsActivity)\n\t\tif err != nil {\n\t\t\treturn false, err\n\t\t}\n\t\tif exist && existsActivity.Cancelled == entity.ActivityAvailable {\n\t\t\tactivity.Rank = 0\n\t\t\tcontinue\n\t\t}\n\t\tif exist {\n\t\t\tif _, err = session.Where(\"id = ?\", existsActivity.ID).Cols(\"`cancelled`\").\n\t\t\t\tUpdate(&entity.Activity{Cancelled: entity.ActivityAvailable}); err != nil {\n\t\t\t\treturn false, err\n\t\t\t}\n\t\t} else {\n\t\t\tinsertActivity := entity.Activity{\n\t\t\t\tObjectID:         op.ObjectID,\n\t\t\t\tOriginalObjectID: op.ObjectID,\n\t\t\t\tUserID:           activity.ActivityUserID,\n\t\t\t\tTriggerUserID:    converter.StringToInt64(activity.TriggerUserID),\n\t\t\t\tActivityType:     activity.ActivityType,\n\t\t\t\tRank:             activity.Rank,\n\t\t\t\tHasRank:          activity.HasRank(),\n\t\t\t\tCancelled:        entity.ActivityAvailable,\n\t\t\t}\n\t\t\t_, err = session.Insert(&insertActivity)\n\t\t\tif err != nil {\n\t\t\t\treturn false, err\n\t\t\t}\n\t\t\tnewAct = true\n\t\t}\n\t}\n\treturn newAct, nil\n}\n\n// cancelActivities cancel activities\n// If this activity is already cancelled, set activity rank to 0\n// So after this function, the activity rank will be correct for update user rank\nfunc (vr *VoteRepo) cancelActivities(session *xorm.Session, activities []*entity.Activity) (err error) {\n\tfor _, activity := range activities {\n\t\tt := &entity.Activity{}\n\t\texist, err := session.ID(activity.ID).Get(t)\n\t\tif err != nil {\n\t\t\tlog.Error(err)\n\t\t\treturn err\n\t\t}\n\t\tif !exist {\n\t\t\tlog.Error(fmt.Errorf(\"%s activity not exist\", activity.ID))\n\t\t\treturn fmt.Errorf(\"%s activity not exist\", activity.ID)\n\t\t}\n\t\t//  If this activity is already cancelled, set activity rank to 0\n\t\tif t.Cancelled == entity.ActivityCancelled {\n\t\t\tactivity.Rank = 0\n\t\t}\n\t\tif _, err = session.ID(activity.ID).Cols(\"cancelled\", \"cancelled_at\").\n\t\t\tUpdate(&entity.Activity{\n\t\t\t\tCancelled:   entity.ActivityCancelled,\n\t\t\t\tCancelledAt: time.Now(),\n\t\t\t}); err != nil {\n\t\t\tlog.Error(err)\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (vr *VoteRepo) getExistActivity(ctx context.Context, op *schema.VoteOperationInfo) ([]*entity.Activity, error) {\n\tvar activities []*entity.Activity\n\tfor _, action := range op.Activities {\n\t\tt := &entity.Activity{}\n\t\texist, err := vr.data.DB.Context(ctx).\n\t\t\tWhere(builder.Eq{\"user_id\": action.ActivityUserID}).\n\t\t\tAnd(builder.Eq{\"trigger_user_id\": action.TriggerUserID}).\n\t\t\tAnd(builder.Eq{\"activity_type\": action.ActivityType}).\n\t\t\tAnd(builder.Eq{\"object_id\": op.ObjectID}).\n\t\t\tGet(t)\n\t\tif err != nil {\n\t\t\treturn nil, errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()\n\t\t}\n\t\tif exist {\n\t\t\tactivities = append(activities, t)\n\t\t}\n\t}\n\treturn activities, nil\n}\n\nfunc (vr *VoteRepo) countVoteUp(ctx context.Context, objectID, objectType string) (count int64) {\n\tcount, err := vr.countVote(ctx, objectID, objectType, constant.ActVoteUp)\n\tif err != nil {\n\t\tlog.Errorf(\"get vote up count error: %v\", err)\n\t}\n\treturn count\n}\n\nfunc (vr *VoteRepo) countVoteDown(ctx context.Context, objectID, objectType string) (count int64) {\n\tcount, err := vr.countVote(ctx, objectID, objectType, constant.ActVoteDown)\n\tif err != nil {\n\t\tlog.Errorf(\"get vote down count error: %v\", err)\n\t}\n\treturn count\n}\n\nfunc (vr *VoteRepo) countVote(ctx context.Context, objectID, objectType, action string) (count int64, err error) {\n\tactivity := &entity.Activity{}\n\tactivityType, _ := vr.activityRepo.GetActivityTypeByObjectType(ctx, objectType, action)\n\tcount, err = vr.data.DB.Context(ctx).Where(builder.Eq{\"object_id\": objectID}).\n\t\tAnd(builder.Eq{\"activity_type\": activityType}).\n\t\tAnd(builder.Eq{\"cancelled\": 0}).\n\t\tCount(activity)\n\tif err != nil {\n\t\terr = errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()\n\t}\n\treturn count, err\n}\n\nfunc (vr *VoteRepo) updateVotes(ctx context.Context, objectID, objectType string, voteCount int) (err error) {\n\tsession := vr.data.DB.Context(ctx)\n\tswitch objectType {\n\tcase constant.QuestionObjectType:\n\t\t_, err = session.ID(objectID).Cols(\"vote_count\").Update(&entity.Question{VoteCount: voteCount})\n\tcase constant.AnswerObjectType:\n\t\t_, err = session.ID(objectID).Cols(\"vote_count\").Update(&entity.Answer{VoteCount: voteCount})\n\tcase constant.CommentObjectType:\n\t\t_, err = session.ID(objectID).Cols(\"vote_count\").Update(&entity.Comment{VoteCount: voteCount})\n\t}\n\tif err != nil {\n\t\tlog.Error(err)\n\t}\n\treturn\n}\n\nfunc (vr *VoteRepo) sendAchievementNotification(ctx context.Context, activityUserID, objectUserID, objectID string) {\n\tobjectType, err := obj.GetObjectTypeStrByObjectID(objectID)\n\tif err != nil {\n\t\treturn\n\t}\n\n\tmsg := &schema.NotificationMsg{\n\t\tReceiverUserID: activityUserID,\n\t\tTriggerUserID:  objectUserID,\n\t\tType:           schema.NotificationTypeAchievement,\n\t\tObjectID:       objectID,\n\t\tObjectType:     objectType,\n\t}\n\tvr.notificationQueueService.Send(ctx, msg)\n}\n\nfunc (vr *VoteRepo) sendVoteInboxNotification(ctx context.Context, triggerUserID, receiverUserID, objectID string, upvote bool) {\n\tif triggerUserID == receiverUserID {\n\t\treturn\n\t}\n\tobjectType, _ := obj.GetObjectTypeStrByObjectID(objectID)\n\n\tmsg := &schema.NotificationMsg{\n\t\tTriggerUserID:  triggerUserID,\n\t\tReceiverUserID: receiverUserID,\n\t\tType:           schema.NotificationTypeInbox,\n\t\tObjectID:       objectID,\n\t\tObjectType:     objectType,\n\t}\n\tif objectType == constant.QuestionObjectType {\n\t\tif upvote {\n\t\t\tmsg.NotificationAction = constant.NotificationUpVotedTheQuestion\n\t\t} else {\n\t\t\tmsg.NotificationAction = constant.NotificationDownVotedTheQuestion\n\t\t}\n\t}\n\tif objectType == constant.AnswerObjectType {\n\t\tif upvote {\n\t\t\tmsg.NotificationAction = constant.NotificationUpVotedTheAnswer\n\t\t} else {\n\t\t\tmsg.NotificationAction = constant.NotificationDownVotedTheAnswer\n\t\t}\n\t}\n\tif objectType == constant.CommentObjectType {\n\t\tif upvote {\n\t\t\tmsg.NotificationAction = constant.NotificationUpVotedTheComment\n\t\t}\n\t}\n\tif len(msg.NotificationAction) > 0 {\n\t\tvr.notificationQueueService.Send(ctx, msg)\n\t}\n}\n", "package activity_common\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/answerdev/answer/internal/entity\"\n\t\"github.com/answerdev/answer/internal/service/activity_common\"\n\t\"github.com/answerdev/answer/internal/service/activity_type\"\n\t\"github.com/answerdev/answer/pkg/obj\"\n\t\"xorm.io/builder\"\n\t\"xorm.io/xorm\"\n\n\t\"github.com/answerdev/answer/internal/base/data\"\n\t\"github.com/answerdev/answer/internal/base/reason\"\n\t\"github.com/answerdev/answer/internal/service/config\"\n\t\"github.com/answerdev/answer/internal/service/unique\"\n\t\"github.com/segmentfault/pacman/errors\"\n)\n\n// ActivityRepo activity repository\ntype ActivityRepo struct {\n\tdata          *data.Data\n\tuniqueIDRepo  unique.UniqueIDRepo\n\tconfigService *config.ConfigService\n}\n\n// NewActivityRepo new repository\nfunc NewActivityRepo(\n\tdata *data.Data,\n\tuniqueIDRepo unique.UniqueIDRepo,\n\tconfigService *config.ConfigService,\n) activity_common.ActivityRepo {\n\treturn &ActivityRepo{\n\t\tdata:          data,\n\t\tuniqueIDRepo:  uniqueIDRepo,\n\t\tconfigService: configService,\n\t}\n}\n\nfunc (ar *ActivityRepo) GetActivityTypeByObjID(ctx context.Context, objectID string, action string) (\n\tactivityType, rank, hasRank int, err error) {\n\tobjectType, err := obj.GetObjectTypeStrByObjectID(objectID)\n\tif err != nil {\n\t\treturn\n\t}\n\n\tconfKey := fmt.Sprintf(\"%s.%s\", objectType, action)\n\tcfg, err := ar.configService.GetConfigByKey(ctx, confKey)\n\tif err != nil {\n\t\treturn\n\t}\n\tactivityType, rank = cfg.ID, cfg.GetIntValue()\n\thasRank = 0\n\tif rank != 0 {\n\t\thasRank = 1\n\t}\n\treturn\n}\n\nfunc (ar *ActivityRepo) GetActivityTypeByObjectType(ctx context.Context, objectType, action string) (activityType int, err error) {\n\tconfigKey := fmt.Sprintf(\"%s.%s\", objectType, action)\n\tcfg, err := ar.configService.GetConfigByKey(ctx, configKey)\n\tif err != nil {\n\t\treturn 0, errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()\n\t}\n\treturn cfg.ID, nil\n}\n\nfunc (ar *ActivityRepo) GetActivityTypeByConfigKey(ctx context.Context, configKey string) (activityType int, err error) {\n\tcfg, err := ar.configService.GetConfigByKey(ctx, configKey)\n\tif err != nil {\n\t\treturn 0, errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()\n\t}\n\treturn cfg.ID, nil\n}\n\nfunc (ar *ActivityRepo) GetActivity(ctx context.Context, session *xorm.Session,\n\tobjectID, userID string, activityType int,\n) (existsActivity *entity.Activity, exist bool, err error) {\n\texistsActivity = &entity.Activity{}\n\texist, err = session.\n\t\tWhere(builder.Eq{\"object_id\": objectID}).\n\t\tAnd(builder.Eq{\"user_id\": userID}).\n\t\tAnd(builder.Eq{\"activity_type\": activityType}).\n\t\tGet(existsActivity)\n\treturn\n}\n\nfunc (ar *ActivityRepo) GetUserIDObjectIDActivitySum(ctx context.Context, userID, objectID string) (int, error) {\n\tsum := &entity.ActivityRankSum{}\n\t_, err := ar.data.DB.Context(ctx).Table(entity.Activity{}.TableName()).\n\t\tSelect(\"sum(`rank`) as `rank`\").\n\t\tWhere(\"user_id =?\", userID).\n\t\tAnd(\"object_id = ?\", objectID).\n\t\tAnd(\"cancelled =0\").\n\t\tGet(sum)\n\tif err != nil {\n\t\terr = errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()\n\t\treturn 0, err\n\t}\n\treturn sum.Rank, nil\n}\n\n// AddActivity add activity\nfunc (ar *ActivityRepo) AddActivity(ctx context.Context, activity *entity.Activity) (err error) {\n\t_, err = ar.data.DB.Context(ctx).Insert(activity)\n\tif err != nil {\n\t\terr = errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()\n\t}\n\treturn\n}\n\n// GetUsersWhoHasGainedTheMostReputation get users who has gained the most reputation over a period of time\nfunc (ar *ActivityRepo) GetUsersWhoHasGainedTheMostReputation(\n\tctx context.Context, startTime, endTime time.Time, limit int) (rankStat []*entity.ActivityUserRankStat, err error) {\n\trankStat = make([]*entity.ActivityUserRankStat, 0)\n\tsession := ar.data.DB.Context(ctx).Select(\"user_id, SUM(`rank`) AS rank_amount\").Table(\"activity\")\n\tsession.Where(\"has_rank = 1 AND cancelled = 0\")\n\tsession.Where(\"created_at >= ?\", startTime)\n\tsession.Where(\"created_at <= ?\", endTime)\n\tsession.GroupBy(\"user_id\")\n\tsession.Desc(\"rank_amount\")\n\tsession.Limit(limit)\n\terr = session.Find(&rankStat)\n\tif err != nil {\n\t\terr = errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()\n\t}\n\treturn\n}\n\n// GetUsersWhoHasVoteMost get users who has vote most\nfunc (ar *ActivityRepo) GetUsersWhoHasVoteMost(\n\tctx context.Context, startTime, endTime time.Time, limit int) (voteStat []*entity.ActivityUserVoteStat, err error) {\n\tvoteStat = make([]*entity.ActivityUserVoteStat, 0)\n\n\tactIDs := make([]int, 0)\n\tfor _, act := range activity_type.ActivityTypeList {\n\t\tcfg, err := ar.configService.GetConfigByKey(ctx, act)\n\t\tif err == nil {\n\t\t\tactIDs = append(actIDs, cfg.ID)\n\t\t}\n\t}\n\n\tsession := ar.data.DB.Context(ctx).Select(\"user_id, COUNT(*) AS vote_count\").Table(\"activity\")\n\tsession.Where(\"cancelled = 0\")\n\tsession.In(\"activity_type\", actIDs)\n\tsession.Where(\"created_at >= ?\", startTime)\n\tsession.Where(\"created_at <= ?\", endTime)\n\tsession.GroupBy(\"user_id\")\n\tsession.Desc(\"vote_count\")\n\tsession.Limit(limit)\n\terr = session.Find(&voteStat)\n\tif err != nil {\n\t\terr = errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()\n\t}\n\treturn\n}\n", "package activity_common\n\nimport (\n\t\"context\"\n\n\t\"github.com/answerdev/answer/internal/base/data\"\n\t\"github.com/answerdev/answer/internal/base/reason\"\n\t\"github.com/answerdev/answer/internal/entity\"\n\t\"github.com/answerdev/answer/internal/service/activity_common\"\n\t\"github.com/answerdev/answer/internal/service/unique\"\n\t\"github.com/answerdev/answer/pkg/obj\"\n\t\"github.com/segmentfault/pacman/errors\"\n\t\"github.com/segmentfault/pacman/log\"\n)\n\n// FollowRepo follow repository\ntype FollowRepo struct {\n\tdata         *data.Data\n\tuniqueIDRepo unique.UniqueIDRepo\n\tactivityRepo activity_common.ActivityRepo\n}\n\n// NewFollowRepo new repository\nfunc NewFollowRepo(\n\tdata *data.Data,\n\tuniqueIDRepo unique.UniqueIDRepo,\n\tactivityRepo activity_common.ActivityRepo,\n) activity_common.FollowRepo {\n\treturn &FollowRepo{\n\t\tdata:         data,\n\t\tuniqueIDRepo: uniqueIDRepo,\n\t\tactivityRepo: activityRepo,\n\t}\n}\n\n// GetFollowAmount get object id's follows\nfunc (ar *FollowRepo) GetFollowAmount(ctx context.Context, objectID string) (follows int, err error) {\n\tobjectType, err := obj.GetObjectTypeStrByObjectID(objectID)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\tswitch objectType {\n\tcase \"question\":\n\t\tmodel := &entity.Question{}\n\t\t_, err = ar.data.DB.Context(ctx).Where(\"id = ?\", objectID).Cols(\"`follow_count`\").Get(model)\n\t\tif err == nil {\n\t\t\tfollows = int(model.FollowCount)\n\t\t}\n\tcase \"user\":\n\t\tmodel := &entity.User{}\n\t\t_, err = ar.data.DB.Context(ctx).Where(\"id = ?\", objectID).Cols(\"`follow_count`\").Get(model)\n\t\tif err == nil {\n\t\t\tfollows = int(model.FollowCount)\n\t\t}\n\tcase \"tag\":\n\t\tmodel := &entity.Tag{}\n\t\t_, err = ar.data.DB.Context(ctx).Where(\"id = ?\", objectID).Cols(\"`follow_count`\").Get(model)\n\t\tif err == nil {\n\t\t\tfollows = int(model.FollowCount)\n\t\t}\n\tdefault:\n\t\terr = errors.InternalServer(reason.DisallowFollow).WithMsg(\"this object can't be followed\")\n\t}\n\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\treturn follows, nil\n}\n\n// GetFollowUserIDs get follow userID by objectID\nfunc (ar *FollowRepo) GetFollowUserIDs(ctx context.Context, objectID string) (userIDs []string, err error) {\n\tobjectTypeStr, err := obj.GetObjectTypeStrByObjectID(objectID)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tactivityType, err := ar.activityRepo.GetActivityTypeByObjectType(ctx, objectTypeStr, \"follow\")\n\tif err != nil {\n\t\tlog.Errorf(\"can't get activity type by object key: %s\", objectTypeStr)\n\t\treturn nil, err\n\t}\n\n\tuserIDs = make([]string, 0)\n\tsession := ar.data.DB.Context(ctx).Select(\"user_id\")\n\tsession.Table(entity.Activity{}.TableName())\n\tsession.Where(\"object_id = ?\", objectID)\n\tsession.Where(\"activity_type = ?\", activityType)\n\tsession.Where(\"cancelled = 0\")\n\terr = session.Find(&userIDs)\n\tif err != nil {\n\t\treturn nil, errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()\n\t}\n\treturn userIDs, nil\n}\n\n// GetFollowIDs get all follow id list\nfunc (ar *FollowRepo) GetFollowIDs(ctx context.Context, userID, objectKey string) (followIDs []string, err error) {\n\tfollowIDs = make([]string, 0)\n\tactivityType, err := ar.activityRepo.GetActivityTypeByObjectType(ctx, objectKey, \"follow\")\n\tif err != nil {\n\t\treturn nil, errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()\n\t}\n\tsession := ar.data.DB.Context(ctx).Select(\"object_id\")\n\tsession.Table(entity.Activity{}.TableName())\n\tsession.Where(\"user_id = ? AND activity_type = ?\", userID, activityType)\n\tsession.Where(\"cancelled = 0\")\n\terr = session.Find(&followIDs)\n\tif err != nil {\n\t\treturn nil, errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()\n\t}\n\treturn followIDs, nil\n}\n\n// IsFollowed check user if follow object or not\nfunc (ar *FollowRepo) IsFollowed(ctx context.Context, userID, objectID string) (followed bool, err error) {\n\tobjectKey, err := obj.GetObjectTypeStrByObjectID(objectID)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\n\tactivityType, err := ar.activityRepo.GetActivityTypeByObjectType(ctx, objectKey, \"follow\")\n\tif err != nil {\n\t\treturn false, err\n\t}\n\n\tat := &entity.Activity{}\n\thas, err := ar.data.DB.Context(ctx).Where(\"user_id = ? AND object_id = ? AND activity_type = ?\", userID, objectID, activityType).Get(at)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\tif !has {\n\t\treturn false, nil\n\t}\n\tif at.Cancelled == entity.ActivityCancelled {\n\t\treturn false, nil\n\t} else {\n\t\treturn true, nil\n\t}\n}\n", "package repo\n\nimport (\n\t\"github.com/answerdev/answer/internal/base/data\"\n\t\"github.com/answerdev/answer/internal/repo/activity\"\n\t\"github.com/answerdev/answer/internal/repo/activity_common\"\n\t\"github.com/answerdev/answer/internal/repo/answer\"\n\t\"github.com/answerdev/answer/internal/repo/auth\"\n\t\"github.com/answerdev/answer/internal/repo/captcha\"\n\t\"github.com/answerdev/answer/internal/repo/collection\"\n\t\"github.com/answerdev/answer/internal/repo/comment\"\n\t\"github.com/answerdev/answer/internal/repo/config\"\n\t\"github.com/answerdev/answer/internal/repo/export\"\n\t\"github.com/answerdev/answer/internal/repo/meta\"\n\t\"github.com/answerdev/answer/internal/repo/notification\"\n\t\"github.com/answerdev/answer/internal/repo/plugin_config\"\n\t\"github.com/answerdev/answer/internal/repo/question\"\n\t\"github.com/answerdev/answer/internal/repo/rank\"\n\t\"github.com/answerdev/answer/internal/repo/reason\"\n\t\"github.com/answerdev/answer/internal/repo/report\"\n\t\"github.com/answerdev/answer/internal/repo/revision\"\n\t\"github.com/answerdev/answer/internal/repo/role\"\n\t\"github.com/answerdev/answer/internal/repo/search_common\"\n\t\"github.com/answerdev/answer/internal/repo/site_info\"\n\t\"github.com/answerdev/answer/internal/repo/tag\"\n\t\"github.com/answerdev/answer/internal/repo/tag_common\"\n\t\"github.com/answerdev/answer/internal/repo/unique\"\n\t\"github.com/answerdev/answer/internal/repo/user\"\n\t\"github.com/answerdev/answer/internal/repo/user_external_login\"\n\t\"github.com/google/wire\"\n)\n\n// ProviderSetRepo is data providers.\nvar ProviderSetRepo = wire.NewSet(\n\tdata.NewData,\n\tdata.NewDB,\n\tdata.NewCache,\n\tcomment.NewCommentRepo,\n\tcomment.NewCommentCommonRepo,\n\tcaptcha.NewCaptchaRepo,\n\tunique.NewUniqueIDRepo,\n\treport.NewReportRepo,\n\tactivity_common.NewFollowRepo,\n\tactivity_common.NewVoteRepo,\n\tconfig.NewConfigRepo,\n\tuser.NewUserRepo,\n\tuser.NewUserAdminRepo,\n\trank.NewUserRankRepo,\n\tquestion.NewQuestionRepo,\n\tanswer.NewAnswerRepo,\n\tactivity_common.NewActivityRepo,\n\tactivity.NewVoteRepo,\n\tactivity.NewFollowRepo,\n\tactivity.NewAnswerActivityRepo,\n\tactivity.NewUserActiveActivityRepo,\n\tactivity.NewActivityRepo,\n\ttag.NewTagRepo,\n\ttag_common.NewTagCommonRepo,\n\ttag.NewTagRelRepo,\n\tcollection.NewCollectionRepo,\n\tcollection.NewCollectionGroupRepo,\n\tauth.NewAuthRepo,\n\trevision.NewRevisionRepo,\n\tsearch_common.NewSearchRepo,\n\tmeta.NewMetaRepo,\n\texport.NewEmailRepo,\n\treason.NewReasonRepo,\n\tsite_info.NewSiteInfo,\n\tnotification.NewNotificationRepo,\n\trole.NewRoleRepo,\n\trole.NewUserRoleRelRepo,\n\trole.NewRolePowerRelRepo,\n\trole.NewPowerRepo,\n\tuser_external_login.NewUserExternalLoginRepo,\n\tplugin_config.NewPluginConfigRepo,\n)\n", "package rank\n\nimport (\n\t\"context\"\n\n\t\"github.com/answerdev/answer/internal/base/data\"\n\t\"github.com/answerdev/answer/internal/base/pager\"\n\t\"github.com/answerdev/answer/internal/base/reason\"\n\t\"github.com/answerdev/answer/internal/entity\"\n\t\"github.com/answerdev/answer/internal/service/config\"\n\t\"github.com/answerdev/answer/internal/service/rank\"\n\t\"github.com/answerdev/answer/plugin\"\n\t\"github.com/jinzhu/now\"\n\t\"github.com/segmentfault/pacman/errors\"\n\t\"github.com/segmentfault/pacman/log\"\n\t\"xorm.io/builder\"\n\t\"xorm.io/xorm\"\n)\n\n// UserRankRepo user rank repository\ntype UserRankRepo struct {\n\tdata          *data.Data\n\tconfigService *config.ConfigService\n}\n\n// NewUserRankRepo new repository\nfunc NewUserRankRepo(data *data.Data, configService *config.ConfigService) rank.UserRankRepo {\n\treturn &UserRankRepo{\n\t\tdata:          data,\n\t\tconfigService: configService,\n\t}\n}\n\nfunc (ur *UserRankRepo) GetMaxDailyRank(ctx context.Context) (maxDailyRank int, err error) {\n\tmaxDailyRank, err = ur.configService.GetIntValue(ctx, \"daily_rank_limit\")\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\treturn maxDailyRank, nil\n}\n\nfunc (ur *UserRankRepo) CheckReachLimit(ctx context.Context, session *xorm.Session,\n\tuserID string, maxDailyRank int) (\n\treach bool, err error) {\n\tsession.Where(builder.Eq{\"user_id\": userID})\n\tsession.Where(builder.Eq{\"cancelled\": 0})\n\tsession.Where(builder.Between{\n\t\tCol:     \"updated_at\",\n\t\tLessVal: now.BeginningOfDay(),\n\t\tMoreVal: now.EndOfDay(),\n\t})\n\n\tearned, err := session.Sum(&entity.Activity{}, \"`rank`\")\n\tif err != nil {\n\t\treturn false, err\n\t}\n\tif int(earned) <= maxDailyRank {\n\t\treturn false, nil\n\t}\n\tlog.Infof(\"user %s today has rank %d is reach stand %d\", userID, earned, maxDailyRank)\n\treturn true, nil\n}\n\n// ChangeUserRank change user rank\nfunc (ur *UserRankRepo) ChangeUserRank(\n\tctx context.Context, session *xorm.Session, userID string, userCurrentScore, deltaRank int) (err error) {\n\t// IMPORTANT: If user center enabled the rank agent, then we should not change user rank.\n\tif plugin.RankAgentEnabled() || deltaRank == 0 {\n\t\treturn nil\n\t}\n\n\t// If user rank is lower than 1 after this action, then user rank will be set to 1 only.\n\tif deltaRank < 0 && userCurrentScore+deltaRank < 1 {\n\t\tdeltaRank = 1 - userCurrentScore\n\t}\n\n\t_, err = session.ID(userID).Incr(\"`rank`\", deltaRank).Update(&entity.User{})\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\n// TriggerUserRank trigger user rank change\n// session is need provider, it means this action must be success or failure\n// if outer action is failed then this action is need rollback\nfunc (ur *UserRankRepo) TriggerUserRank(ctx context.Context,\n\tsession *xorm.Session, userID string, deltaRank int, activityType int,\n) (isReachStandard bool, err error) {\n\t// IMPORTANT: If user center enabled the rank agent, then we should not change user rank.\n\tif plugin.RankAgentEnabled() || deltaRank == 0 {\n\t\treturn false, nil\n\t}\n\n\tif deltaRank < 0 {\n\t\t// if user rank is lower than 1 after this action, then user rank will be set to 1 only.\n\t\tvar isReachMin bool\n\t\tisReachMin, err = ur.checkUserMinRank(ctx, session, userID, deltaRank)\n\t\tif err != nil {\n\t\t\treturn false, errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()\n\t\t}\n\t\tif isReachMin {\n\t\t\t_, err = session.Where(builder.Eq{\"id\": userID}).Update(&entity.User{Rank: 1})\n\t\t\tif err != nil {\n\t\t\t\treturn false, errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()\n\t\t\t}\n\t\t\treturn true, nil\n\t\t}\n\t} else {\n\t\tisReachStandard, err = ur.checkUserTodayRank(ctx, session, userID, activityType)\n\t\tif err != nil {\n\t\t\treturn false, errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()\n\t\t}\n\t\tif isReachStandard {\n\t\t\treturn isReachStandard, nil\n\t\t}\n\t}\n\t_, err = session.Where(builder.Eq{\"id\": userID}).Incr(\"`rank`\", deltaRank).Update(&entity.User{})\n\tif err != nil {\n\t\treturn false, errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()\n\t}\n\treturn false, nil\n}\n\nfunc (ur *UserRankRepo) checkUserMinRank(ctx context.Context, session *xorm.Session, userID string, deltaRank int) (\n\tisReachStandard bool, err error,\n) {\n\tbean := &entity.User{ID: userID}\n\t_, err = session.Select(\"`rank`\").Get(bean)\n\tif err != nil {\n\t\treturn false, errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()\n\t}\n\tif bean.Rank+deltaRank < 1 {\n\t\tlog.Infof(\"user %s is rank %d out of range before rank operation\", userID, deltaRank)\n\t\treturn true, nil\n\t}\n\treturn\n}\n\nfunc (ur *UserRankRepo) checkUserTodayRank(ctx context.Context,\n\tsession *xorm.Session, userID string, activityType int,\n) (isReachStandard bool, err error) {\n\t// exclude daily rank\n\texclude, _ := ur.configService.GetArrayStringValue(ctx, \"daily_rank_limit.exclude\")\n\tfor _, item := range exclude {\n\t\tcfg, err := ur.configService.GetConfigByKey(ctx, item)\n\t\tif err != nil {\n\t\t\treturn false, err\n\t\t}\n\t\tif activityType == cfg.ID {\n\t\t\treturn false, nil\n\t\t}\n\t}\n\n\t// get user\n\tstart, end := now.BeginningOfDay(), now.EndOfDay()\n\tsession.Where(builder.Eq{\"user_id\": userID})\n\tsession.Where(builder.Eq{\"cancelled\": 0})\n\tsession.Where(builder.Between{\n\t\tCol:     \"updated_at\",\n\t\tLessVal: start,\n\t\tMoreVal: end,\n\t})\n\tearned, err := session.Sum(&entity.Activity{}, \"`rank`\")\n\tif err != nil {\n\t\treturn false, err\n\t}\n\n\t// max rank\n\tmaxDailyRank, err := ur.configService.GetIntValue(ctx, \"daily_rank_limit\")\n\tif err != nil {\n\t\treturn false, err\n\t}\n\n\tif int(earned) < maxDailyRank {\n\t\treturn false, nil\n\t}\n\tlog.Infof(\"user %s today has rank %d is reach stand %d\", userID, earned, maxDailyRank)\n\treturn true, nil\n}\n\nfunc (ur *UserRankRepo) UserRankPage(ctx context.Context, userID string, page, pageSize int) (\n\trankPage []*entity.Activity, total int64, err error,\n) {\n\trankPage = make([]*entity.Activity, 0)\n\n\tsession := ur.data.DB.Context(ctx).Where(builder.Eq{\"has_rank\": 1}.And(builder.Eq{\"cancelled\": 0})).And(builder.Gt{\"`rank`\": 0})\n\tsession.Desc(\"created_at\")\n\n\tcond := &entity.Activity{UserID: userID}\n\ttotal, err = pager.Help(page, pageSize, &rankPage, cond, session)\n\tif err != nil {\n\t\terr = errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()\n\t}\n\treturn\n}\n", "package user\n\nimport (\n\t\"context\"\n\t\"time\"\n\n\t\"github.com/answerdev/answer/internal/base/data\"\n\t\"github.com/answerdev/answer/internal/base/reason\"\n\t\"github.com/answerdev/answer/internal/entity\"\n\t\"github.com/answerdev/answer/internal/schema\"\n\tusercommon \"github.com/answerdev/answer/internal/service/user_common\"\n\t\"github.com/answerdev/answer/pkg/converter\"\n\t\"github.com/answerdev/answer/plugin\"\n\t\"github.com/segmentfault/pacman/errors\"\n\t\"github.com/segmentfault/pacman/log\"\n\t\"xorm.io/xorm\"\n)\n\n// userRepo user repository\ntype userRepo struct {\n\tdata *data.Data\n}\n\n// NewUserRepo new repository\nfunc NewUserRepo(data *data.Data) usercommon.UserRepo {\n\treturn &userRepo{\n\t\tdata: data,\n\t}\n}\n\n// AddUser add user\nfunc (ur *userRepo) AddUser(ctx context.Context, user *entity.User) (err error) {\n\t_, err = ur.data.DB.Transaction(func(session *xorm.Session) (interface{}, error) {\n\t\tsession = session.Context(ctx)\n\t\tuserInfo := &entity.User{}\n\t\texist, err := session.Where(\"username = ?\", user.Username).Get(userInfo)\n\t\tif err != nil {\n\t\t\treturn nil, errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()\n\t\t}\n\t\tif exist {\n\t\t\treturn nil, errors.InternalServer(reason.UsernameDuplicate)\n\t\t}\n\t\t_, err = session.Insert(user)\n\t\tif err != nil {\n\t\t\treturn nil, errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()\n\t\t}\n\t\treturn nil, nil\n\t})\n\treturn\n}\n\n// IncreaseAnswerCount increase answer count\nfunc (ur *userRepo) IncreaseAnswerCount(ctx context.Context, userID string, amount int) (err error) {\n\tuser := &entity.User{}\n\t_, err = ur.data.DB.Context(ctx).Where(\"id = ?\", userID).Incr(\"answer_count\", amount).Update(user)\n\tif err != nil {\n\t\treturn errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()\n\t}\n\treturn nil\n}\n\n// IncreaseQuestionCount increase question count\nfunc (ur *userRepo) IncreaseQuestionCount(ctx context.Context, userID string, amount int) (err error) {\n\tuser := &entity.User{}\n\t_, err = ur.data.DB.Context(ctx).Where(\"id = ?\", userID).Incr(\"question_count\", amount).Update(user)\n\tif err != nil {\n\t\treturn errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()\n\t}\n\treturn nil\n}\n\nfunc (ur *userRepo) UpdateQuestionCount(ctx context.Context, userID string, count int64) (err error) {\n\tuser := &entity.User{}\n\tuser.QuestionCount = int(count)\n\t_, err = ur.data.DB.Context(ctx).Where(\"id = ?\", userID).Cols(\"question_count\").Update(user)\n\tif err != nil {\n\t\treturn errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()\n\t}\n\treturn nil\n}\n\nfunc (ur *userRepo) UpdateAnswerCount(ctx context.Context, userID string, count int) (err error) {\n\tuser := &entity.User{}\n\tuser.AnswerCount = count\n\t_, err = ur.data.DB.Context(ctx).Where(\"id = ?\", userID).Cols(\"answer_count\").Update(user)\n\tif err != nil {\n\t\treturn errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()\n\t}\n\treturn nil\n}\n\n// UpdateLastLoginDate update last login date\nfunc (ur *userRepo) UpdateLastLoginDate(ctx context.Context, userID string) (err error) {\n\tuser := &entity.User{LastLoginDate: time.Now()}\n\t_, err = ur.data.DB.Context(ctx).Where(\"id = ?\", userID).Cols(\"last_login_date\").Update(user)\n\tif err != nil {\n\t\treturn errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()\n\t}\n\treturn nil\n}\n\n// UpdateEmailStatus update email status\nfunc (ur *userRepo) UpdateEmailStatus(ctx context.Context, userID string, emailStatus int) error {\n\tcond := &entity.User{MailStatus: emailStatus}\n\t_, err := ur.data.DB.Context(ctx).Where(\"id = ?\", userID).Cols(\"mail_status\").Update(cond)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\n// UpdateNoticeStatus update notice status\nfunc (ur *userRepo) UpdateNoticeStatus(ctx context.Context, userID string, noticeStatus int) error {\n\tcond := &entity.User{NoticeStatus: noticeStatus}\n\t_, err := ur.data.DB.Context(ctx).Where(\"id = ?\", userID).Cols(\"notice_status\").Update(cond)\n\tif err != nil {\n\t\treturn errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()\n\t}\n\treturn nil\n}\n\nfunc (ur *userRepo) UpdatePass(ctx context.Context, userID, pass string) error {\n\t_, err := ur.data.DB.Context(ctx).Where(\"id = ?\", userID).Cols(\"pass\").Update(&entity.User{Pass: pass})\n\tif err != nil {\n\t\treturn errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()\n\t}\n\treturn nil\n}\n\nfunc (ur *userRepo) UpdateEmail(ctx context.Context, userID, email string) (err error) {\n\t_, err = ur.data.DB.Context(ctx).Where(\"id = ?\", userID).Update(&entity.User{EMail: email})\n\tif err != nil {\n\t\terr = errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()\n\t}\n\treturn\n}\n\nfunc (ur *userRepo) UpdateLanguage(ctx context.Context, userID, language string) (err error) {\n\t_, err = ur.data.DB.Context(ctx).Where(\"id = ?\", userID).Update(&entity.User{Language: language})\n\tif err != nil {\n\t\terr = errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()\n\t}\n\treturn\n}\n\n// UpdateInfo update user info\nfunc (ur *userRepo) UpdateInfo(ctx context.Context, userInfo *entity.User) (err error) {\n\t_, err = ur.data.DB.Context(ctx).Where(\"id = ?\", userInfo.ID).\n\t\tCols(\"username\", \"display_name\", \"avatar\", \"bio\", \"bio_html\", \"website\", \"location\").Update(userInfo)\n\tif err != nil {\n\t\terr = errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()\n\t}\n\treturn\n}\n\n// GetByUserID get user info by user id\nfunc (ur *userRepo) GetByUserID(ctx context.Context, userID string) (userInfo *entity.User, exist bool, err error) {\n\tuserInfo = &entity.User{}\n\texist, err = ur.data.DB.Context(ctx).Where(\"id = ?\", userID).Get(userInfo)\n\tif err != nil {\n\t\terr = errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()\n\t\treturn\n\t}\n\terr = tryToDecorateUserInfoFromUserCenter(ctx, ur.data, userInfo)\n\tif err != nil {\n\t\treturn nil, false, err\n\t}\n\treturn\n}\n\nfunc (ur *userRepo) BatchGetByID(ctx context.Context, ids []string) ([]*entity.User, error) {\n\tlist := make([]*entity.User, 0)\n\terr := ur.data.DB.Context(ctx).In(\"id\", ids).Find(&list)\n\tif err != nil {\n\t\treturn nil, errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()\n\t}\n\ttryToDecorateUserListFromUserCenter(ctx, ur.data, list)\n\treturn list, nil\n}\n\n// GetByUsername get user by username\nfunc (ur *userRepo) GetByUsername(ctx context.Context, username string) (userInfo *entity.User, exist bool, err error) {\n\tuserInfo = &entity.User{}\n\texist, err = ur.data.DB.Context(ctx).Where(\"username = ?\", username).Get(userInfo)\n\tif err != nil {\n\t\terr = errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()\n\t\treturn\n\t}\n\terr = tryToDecorateUserInfoFromUserCenter(ctx, ur.data, userInfo)\n\tif err != nil {\n\t\treturn nil, false, err\n\t}\n\treturn\n}\n\nfunc (ur *userRepo) GetByUsernames(ctx context.Context, usernames []string) ([]*entity.User, error) {\n\tlist := make([]*entity.User, 0)\n\terr := ur.data.DB.Context(ctx).Where(\"status =?\", entity.UserStatusAvailable).In(\"username\", usernames).Find(&list)\n\tif err != nil {\n\t\terr = errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()\n\t\treturn list, err\n\t}\n\ttryToDecorateUserListFromUserCenter(ctx, ur.data, list)\n\treturn list, nil\n}\n\n// GetByEmail get user by email\nfunc (ur *userRepo) GetByEmail(ctx context.Context, email string) (userInfo *entity.User, exist bool, err error) {\n\tuserInfo = &entity.User{}\n\texist, err = ur.data.DB.Context(ctx).Where(\"e_mail = ?\", email).\n\t\tWhere(\"status != ?\", entity.UserStatusDeleted).Get(userInfo)\n\tif err != nil {\n\t\terr = errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()\n\t}\n\treturn\n}\n\nfunc (ur *userRepo) GetUserCount(ctx context.Context) (count int64, err error) {\n\tlist := make([]*entity.User, 0)\n\tcount, err = ur.data.DB.Context(ctx).Where(\"mail_status =?\", entity.EmailStatusAvailable).And(\"status =?\", entity.UserStatusAvailable).FindAndCount(&list)\n\tif err != nil {\n\t\treturn count, errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()\n\t}\n\treturn\n}\n\nfunc (ur *userRepo) SearchUserListByName(ctx context.Context, name string) (userList []*entity.User, err error) {\n\tuserList = make([]*entity.User, 0)\n\tif name == \"\" {\n\t\treturn userList, nil\n\t}\n\tsession := ur.data.DB.Where(\"\")\n\tsession.Where(\"username LIKE LOWER(?) or display_name LIKE ?\", name+\"%\", name+\"%\").And(\"status =?\", entity.UserStatusAvailable)\n\tsession.Asc(\"username\")\n\tsession = session.Limit(5, 0)\n\terr = session.OrderBy(\"id desc\").Find(&userList)\n\tif err != nil {\n\t\terr = errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()\n\t}\n\ttryToDecorateUserListFromUserCenter(ctx, ur.data, userList)\n\treturn\n}\n\nfunc tryToDecorateUserInfoFromUserCenter(ctx context.Context, data *data.Data, original *entity.User) (err error) {\n\tif original == nil {\n\t\treturn nil\n\t}\n\tuc, ok := plugin.GetUserCenter()\n\tif !ok {\n\t\treturn nil\n\t}\n\n\tuserInfo := &entity.UserExternalLogin{}\n\tsession := data.DB.Context(ctx).Where(\"user_id = ?\", original.ID)\n\tsession.Where(\"provider = ?\", uc.Info().SlugName)\n\texist, err := session.Get(userInfo)\n\tif err != nil {\n\t\treturn errors.InternalServer(reason.DatabaseError).WithError(err).WithStack()\n\t}\n\tif !exist {\n\t\treturn nil\n\t}\n\n\tuserCenterBasicUserInfo, err := uc.UserInfo(userInfo.ExternalID)\n\tif err != nil {\n\t\tlog.Error(err)\n\t\treturn errors.BadRequest(reason.UserNotFound).WithError(err).WithStack()\n\t}\n\n\t// In general, usernames should be guaranteed unique by the User Center plugin, so there are no inconsistencies.\n\tif original.Username != userCenterBasicUserInfo.Username {\n\t\tlog.Warnf(\"user %s username is inconsistent with user center\", original.ID)\n\t}\n\tdecorateByUserCenterUser(original, userCenterBasicUserInfo)\n\treturn nil\n}\n\nfunc tryToDecorateUserListFromUserCenter(ctx context.Context, data *data.Data, original []*entity.User) {\n\tuc, ok := plugin.GetUserCenter()\n\tif !ok {\n\t\treturn\n\t}\n\n\tids := make([]string, 0)\n\toriginalUserIDMapping := make(map[string]*entity.User, 0)\n\tfor _, user := range original {\n\t\toriginalUserIDMapping[user.ID] = user\n\t\tids = append(ids, user.ID)\n\t}\n\n\tuserExternalLoginList := make([]*entity.UserExternalLogin, 0)\n\tsession := data.DB.Context(ctx).Where(\"provider = ?\", uc.Info().SlugName)\n\tsession.In(\"user_id\", ids)\n\terr := session.Find(&userExternalLoginList)\n\tif err != nil {\n\t\tlog.Error(err)\n\t\treturn\n\t}\n\n\tuserExternalIDs := make([]string, 0)\n\toriginalExternalIDMapping := make(map[string]*entity.User, 0)\n\tfor _, u := range userExternalLoginList {\n\t\toriginalExternalIDMapping[u.ExternalID] = originalUserIDMapping[u.UserID]\n\t\tuserExternalIDs = append(userExternalIDs, u.ExternalID)\n\t}\n\tif len(userExternalIDs) == 0 {\n\t\treturn\n\t}\n\n\tucUsers, err := uc.UserList(userExternalIDs)\n\tif err != nil {\n\t\tlog.Errorf(\"get user list from user center failed: %v, %v\", err, userExternalIDs)\n\t\treturn\n\t}\n\n\tfor _, ucUser := range ucUsers {\n\t\tdecorateByUserCenterUser(originalExternalIDMapping[ucUser.ExternalID], ucUser)\n\t}\n}\n\nfunc decorateByUserCenterUser(original *entity.User, ucUser *plugin.UserCenterBasicUserInfo) {\n\tif original == nil || ucUser == nil {\n\t\treturn\n\t}\n\t// In general, usernames should be guaranteed unique by the User Center plugin, so there are no inconsistencies.\n\tif original.Username != ucUser.Username {\n\t\tlog.Warnf(\"user %s username is inconsistent with user center\", original.ID)\n\t}\n\tif len(ucUser.DisplayName) > 0 {\n\t\toriginal.DisplayName = ucUser.DisplayName\n\t}\n\tif len(ucUser.Email) > 0 {\n\t\toriginal.EMail = ucUser.Email\n\t}\n\tif len(ucUser.Avatar) > 0 {\n\t\toriginal.Avatar = schema.CustomAvatar(ucUser.Avatar).ToJsonString()\n\t}\n\tif len(ucUser.Mobile) > 0 {\n\t\toriginal.Mobile = ucUser.Mobile\n\t}\n\tif len(ucUser.Bio) > 0 {\n\t\toriginal.BioHTML = converter.Markdown2HTML(ucUser.Bio) + original.BioHTML\n\t}\n\n\t// If plugin enable rank agent, use rank from user center.\n\tif plugin.RankAgentEnabled() {\n\t\toriginal.Rank = ucUser.Rank\n\t}\n\tif ucUser.Status != plugin.UserStatusAvailable {\n\t\toriginal.Status = int(ucUser.Status)\n\t}\n}\n", "package schema\n\ntype VoteReq struct {\n\tObjectID string `validate:\"required\" form:\"object_id\" json:\"object_id\"`  //\t id\n\tIsCancel bool   `validate:\"omitempty\" form:\"is_cancel\" json:\"is_cancel\"` // is cancel\n\tUserID   string `json:\"-\"`\n}\n\ntype VoteResp struct {\n\tUpVotes    int64  `json:\"up_votes\"`\n\tDownVotes  int64  `json:\"down_votes\"`\n\tVotes      int64  `json:\"votes\"`\n\tVoteStatus string `json:\"vote_status\"`\n}\n\n// VoteOperationInfo vote operation info\ntype VoteOperationInfo struct {\n\t// operation object id\n\tObjectID string\n\t// question answer comment\n\tObjectType string\n\t// object owner user id\n\tObjectCreatorUserID string\n\t// operation user id\n\tOperatingUserID string\n\t// vote up\n\tVoteUp bool\n\t// vote down\n\tVoteDown bool\n\t// vote activity info\n\tActivities []*VoteActivity\n}\n\n// VoteActivity vote activity\ntype VoteActivity struct {\n\tActivityType   int\n\tActivityUserID string\n\tTriggerUserID  string\n\tRank           int\n}\n\nfunc (v *VoteActivity) HasRank() int {\n\tif v.Rank != 0 {\n\t\treturn 1\n\t}\n\treturn 0\n}\n\ntype GetVoteWithPageReq struct {\n\t// page\n\tPage int `validate:\"omitempty,min=1\" form:\"page\"`\n\t// page size\n\tPageSize int `validate:\"omitempty,min=1\" form:\"page_size\"`\n\t// user id\n\tUserID string `json:\"-\"`\n}\n\ntype GetVoteWithPageResp struct {\n\t// create time\n\tCreatedAt int64 `json:\"created_at\"`\n\t// object id\n\tObjectID string `json:\"object_id\"`\n\t// question id\n\tQuestionID string `json:\"question_id\"`\n\t// answer id\n\tAnswerID string `json:\"answer_id\"`\n\t// object type\n\tObjectType string `json:\"object_type\" enums:\"question,answer,tag,comment\"`\n\t// title\n\tTitle string `json:\"title\"`\n\t// url title\n\tUrlTitle string `json:\"url_title\"`\n\t// content\n\tContent string `json:\"content\"`\n\t// vote type\n\tVoteType string `json:\"vote_type\"`\n}\n", "package activity\n\nimport (\n\t\"context\"\n)\n\n// AnswerActivityRepo answer activity\ntype AnswerActivityRepo interface {\n\tAcceptAnswer(ctx context.Context,\n\t\tanswerObjID, questionObjID, questionUserID, answerUserID string, isSelf bool) (err error)\n\tCancelAcceptAnswer(ctx context.Context,\n\t\tanswerObjID, questionObjID, questionUserID, answerUserID string) (err error)\n}\n\n// AnswerActivityService user service\ntype AnswerActivityService struct {\n\tanswerActivityRepo AnswerActivityRepo\n}\n\n// NewAnswerActivityService new comment service\nfunc NewAnswerActivityService(\n\tanswerActivityRepo AnswerActivityRepo) *AnswerActivityService {\n\treturn &AnswerActivityService{\n\t\tanswerActivityRepo: answerActivityRepo,\n\t}\n}\n\n// AcceptAnswer accept answer change activity\nfunc (as *AnswerActivityService) AcceptAnswer(ctx context.Context,\n\tanswerObjID, questionObjID, questionUserID, answerUserID string, isSelf bool) (err error) {\n\treturn as.answerActivityRepo.AcceptAnswer(ctx, answerObjID, questionObjID, questionUserID, answerUserID, isSelf)\n}\n\n// CancelAcceptAnswer cancel accept answer change activity\nfunc (as *AnswerActivityService) CancelAcceptAnswer(ctx context.Context,\n\tanswerObjID, questionObjID, questionUserID, answerUserID string) (err error) {\n\treturn as.answerActivityRepo.CancelAcceptAnswer(ctx, answerObjID, questionObjID, questionUserID, answerUserID)\n}\n", "package activity_common\n\nimport (\n\t\"context\"\n\t\"time\"\n\n\t\"github.com/answerdev/answer/internal/entity\"\n\t\"github.com/answerdev/answer/internal/schema\"\n\t\"github.com/answerdev/answer/internal/service/activity_queue\"\n\t\"github.com/answerdev/answer/pkg/converter\"\n\t\"github.com/answerdev/answer/pkg/uid\"\n\t\"github.com/segmentfault/pacman/log\"\n\t\"xorm.io/xorm\"\n)\n\ntype ActivityRepo interface {\n\tGetActivityTypeByObjID(ctx context.Context, objectId string, action string) (activityType, rank int, hasRank int, err error)\n\tGetActivityTypeByObjectType(ctx context.Context, objectKey, action string) (activityType int, err error)\n\tGetActivity(ctx context.Context, session *xorm.Session, objectID, userID string, activityType int) (\n\t\texistsActivity *entity.Activity, exist bool, err error)\n\tGetUserIDObjectIDActivitySum(ctx context.Context, userID, objectID string) (int, error)\n\tGetActivityTypeByConfigKey(ctx context.Context, configKey string) (activityType int, err error)\n\tAddActivity(ctx context.Context, activity *entity.Activity) (err error)\n\tGetUsersWhoHasGainedTheMostReputation(\n\t\tctx context.Context, startTime, endTime time.Time, limit int) (rankStat []*entity.ActivityUserRankStat, err error)\n\tGetUsersWhoHasVoteMost(\n\t\tctx context.Context, startTime, endTime time.Time, limit int) (voteStat []*entity.ActivityUserVoteStat, err error)\n}\n\ntype ActivityCommon struct {\n\tactivityRepo         ActivityRepo\n\tactivityQueueService activity_queue.ActivityQueueService\n}\n\n// NewActivityCommon new activity common\nfunc NewActivityCommon(\n\tactivityRepo ActivityRepo,\n\tactivityQueueService activity_queue.ActivityQueueService,\n) *ActivityCommon {\n\tactivity := &ActivityCommon{\n\t\tactivityRepo:         activityRepo,\n\t\tactivityQueueService: activityQueueService,\n\t}\n\tactivity.activityQueueService.RegisterHandler(activity.HandleActivity)\n\treturn activity\n}\n\n// HandleActivity handle activity message\nfunc (ac *ActivityCommon) HandleActivity(ctx context.Context, msg *schema.ActivityMsg) error {\n\tactivityType, err := ac.activityRepo.GetActivityTypeByConfigKey(ctx, string(msg.ActivityTypeKey))\n\tif err != nil {\n\t\tlog.Errorf(\"error getting activity type %s, activity type is %d\", err, activityType)\n\t\treturn err\n\t}\n\n\tact := &entity.Activity{\n\t\tUserID:           msg.UserID,\n\t\tTriggerUserID:    msg.TriggerUserID,\n\t\tObjectID:         uid.DeShortID(msg.ObjectID),\n\t\tOriginalObjectID: uid.DeShortID(msg.OriginalObjectID),\n\t\tActivityType:     activityType,\n\t\tCancelled:        entity.ActivityAvailable,\n\t}\n\tif len(msg.RevisionID) > 0 {\n\t\tact.RevisionID = converter.StringToInt64(msg.RevisionID)\n\t}\n\tif err := ac.activityRepo.AddActivity(ctx, act); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n", "package rank\n\nimport (\n\t\"context\"\n\n\t\"github.com/answerdev/answer/internal/base/constant\"\n\t\"github.com/answerdev/answer/internal/base/handler\"\n\t\"github.com/answerdev/answer/internal/base/pager\"\n\t\"github.com/answerdev/answer/internal/base/reason\"\n\t\"github.com/answerdev/answer/internal/base/translator\"\n\t\"github.com/answerdev/answer/internal/entity\"\n\t\"github.com/answerdev/answer/internal/schema\"\n\t\"github.com/answerdev/answer/internal/service/activity_type\"\n\t\"github.com/answerdev/answer/internal/service/config\"\n\t\"github.com/answerdev/answer/internal/service/object_info\"\n\t\"github.com/answerdev/answer/internal/service/permission\"\n\t\"github.com/answerdev/answer/internal/service/role\"\n\tusercommon \"github.com/answerdev/answer/internal/service/user_common\"\n\t\"github.com/answerdev/answer/pkg/htmltext\"\n\t\"github.com/answerdev/answer/pkg/uid\"\n\t\"github.com/answerdev/answer/plugin\"\n\t\"github.com/segmentfault/pacman/errors\"\n\t\"github.com/segmentfault/pacman/log\"\n\t\"xorm.io/xorm\"\n)\n\nconst (\n\tPermissionPrefix = \"rank.\"\n)\n\ntype UserRankRepo interface {\n\tGetMaxDailyRank(ctx context.Context) (maxDailyRank int, err error)\n\tCheckReachLimit(ctx context.Context, session *xorm.Session, userID string, maxDailyRank int) (reach bool, err error)\n\tChangeUserRank(ctx context.Context, session *xorm.Session,\n\t\tuserID string, userCurrentScore, deltaRank int) (err error)\n\tTriggerUserRank(ctx context.Context, session *xorm.Session, userId string, rank int, activityType int) (isReachStandard bool, err error)\n\tUserRankPage(ctx context.Context, userId string, page, pageSize int) (rankPage []*entity.Activity, total int64, err error)\n}\n\n// RankService rank service\ntype RankService struct {\n\tuserCommon        *usercommon.UserCommon\n\tconfigService     *config.ConfigService\n\tuserRankRepo      UserRankRepo\n\tobjectInfoService *object_info.ObjService\n\troleService       *role.UserRoleRelService\n\trolePowerService  *role.RolePowerRelService\n}\n\n// NewRankService new rank service\nfunc NewRankService(\n\tuserCommon *usercommon.UserCommon,\n\tuserRankRepo UserRankRepo,\n\tobjectInfoService *object_info.ObjService,\n\troleService *role.UserRoleRelService,\n\trolePowerService *role.RolePowerRelService,\n\tconfigService *config.ConfigService) *RankService {\n\treturn &RankService{\n\t\tuserCommon:        userCommon,\n\t\tconfigService:     configService,\n\t\tuserRankRepo:      userRankRepo,\n\t\tobjectInfoService: objectInfoService,\n\t\troleService:       roleService,\n\t\trolePowerService:  rolePowerService,\n\t}\n}\n\n// CheckOperationPermission verify that the user has permission\nfunc (rs *RankService) CheckOperationPermission(ctx context.Context, userID string, action string, objectID string) (\n\tcan bool, err error) {\n\tif len(userID) == 0 {\n\t\treturn false, nil\n\t}\n\n\t// get the rank of the current user\n\tuserInfo, exist, err := rs.userCommon.GetUserBasicInfoByID(ctx, userID)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\tif !exist {\n\t\treturn false, nil\n\t}\n\tpowerMapping := rs.getUserPowerMapping(ctx, userID)\n\tif powerMapping[action] {\n\t\treturn true, nil\n\t}\n\n\tif len(objectID) > 0 {\n\t\tobjectInfo, err := rs.objectInfoService.GetInfo(ctx, objectID)\n\t\tif err != nil {\n\t\t\treturn can, err\n\t\t}\n\t\t// if the user is this object creator, the user can operate this object.\n\t\tif objectInfo != nil &&\n\t\t\tobjectInfo.ObjectCreatorUserID == userID {\n\t\t\treturn true, nil\n\t\t}\n\t}\n\n\tcan, _ = rs.checkUserRank(ctx, userInfo.ID, userInfo.Rank, PermissionPrefix+action)\n\treturn can, nil\n}\n\n// CheckOperationPermissionsForRanks verify that the user has permission\nfunc (rs *RankService) CheckOperationPermissionsForRanks(ctx context.Context, userID string, actions []string) (\n\tcan []bool, requireRanks []int, err error) {\n\tcan = make([]bool, len(actions))\n\trequireRanks = make([]int, len(actions))\n\tif len(userID) == 0 {\n\t\treturn can, requireRanks, nil\n\t}\n\n\t// get the rank of the current user\n\tuserInfo, exist, err := rs.userCommon.GetUserBasicInfoByID(ctx, userID)\n\tif err != nil {\n\t\treturn can, requireRanks, err\n\t}\n\tif !exist {\n\t\treturn can, requireRanks, nil\n\t}\n\n\tpowerMapping := rs.getUserPowerMapping(ctx, userID)\n\tfor idx, action := range actions {\n\t\tif powerMapping[action] {\n\t\t\tcan[idx] = true\n\t\t\tcontinue\n\t\t}\n\t\tmeetRank, requireRank := rs.checkUserRank(ctx, userInfo.ID, userInfo.Rank, PermissionPrefix+action)\n\t\tcan[idx] = meetRank\n\t\trequireRanks[idx] = requireRank\n\t}\n\treturn can, requireRanks, nil\n}\n\n// CheckOperationPermissions verify that the user has permission\nfunc (rs *RankService) CheckOperationPermissions(ctx context.Context, userID string, actions []string) (\n\tcan []bool, err error) {\n\tcan, _, err = rs.CheckOperationPermissionsForRanks(ctx, userID, actions)\n\treturn can, err\n}\n\n// CheckOperationObjectOwner check operation object owner\nfunc (rs *RankService) CheckOperationObjectOwner(ctx context.Context, userID, objectID string) bool {\n\tobjectID = uid.DeShortID(objectID)\n\tobjectInfo, err := rs.objectInfoService.GetInfo(ctx, objectID)\n\tif err != nil {\n\t\tlog.Error(err)\n\t\treturn false\n\t}\n\t// if the user is this object creator, the user can operate this object.\n\tif objectInfo != nil &&\n\t\tobjectInfo.ObjectCreatorUserID == userID {\n\t\treturn true\n\t}\n\treturn false\n}\n\n// CheckVotePermission verify that the user has vote permission\nfunc (rs *RankService) CheckVotePermission(ctx context.Context, userID, objectID string, voteUp bool) (\n\tcan bool, needRank int, err error) {\n\tif len(userID) == 0 || len(objectID) == 0 {\n\t\treturn false, 0, nil\n\t}\n\n\t// get the rank of the current user\n\tuserInfo, exist, err := rs.userCommon.GetUserBasicInfoByID(ctx, userID)\n\tif err != nil {\n\t\treturn can, 0, err\n\t}\n\tif !exist {\n\t\treturn can, 0, nil\n\t}\n\tobjectInfo, err := rs.objectInfoService.GetInfo(ctx, objectID)\n\tif err != nil {\n\t\treturn can, 0, err\n\t}\n\taction := \"\"\n\tswitch objectInfo.ObjectType {\n\tcase constant.QuestionObjectType:\n\t\tif voteUp {\n\t\t\taction = permission.QuestionVoteUp\n\t\t} else {\n\t\t\taction = permission.QuestionVoteDown\n\t\t}\n\tcase constant.AnswerObjectType:\n\t\tif voteUp {\n\t\t\taction = permission.AnswerVoteUp\n\t\t} else {\n\t\t\taction = permission.AnswerVoteDown\n\t\t}\n\tcase constant.CommentObjectType:\n\t\tif voteUp {\n\t\t\taction = permission.CommentVoteUp\n\t\t} else {\n\t\t\taction = permission.CommentVoteDown\n\t\t}\n\t}\n\tpowerMapping := rs.getUserPowerMapping(ctx, userID)\n\tif powerMapping[action] {\n\t\treturn true, 0, nil\n\t}\n\tcan, needRank = rs.checkUserRank(ctx, userInfo.ID, userInfo.Rank, PermissionPrefix+action)\n\treturn can, needRank, nil\n}\n\n// getUserPowerMapping get user power mapping\nfunc (rs *RankService) getUserPowerMapping(ctx context.Context, userID string) (powerMapping map[string]bool) {\n\tpowerMapping = make(map[string]bool, 0)\n\tuserRole, err := rs.roleService.GetUserRole(ctx, userID)\n\tif err != nil {\n\t\tlog.Error(err)\n\t\treturn powerMapping\n\t}\n\tpowers, err := rs.rolePowerService.GetRolePowerList(ctx, userRole)\n\tif err != nil {\n\t\tlog.Error(err)\n\t\treturn powerMapping\n\t}\n\n\tfor _, power := range powers {\n\t\tpowerMapping[power] = true\n\t}\n\treturn powerMapping\n}\n\n// CheckRankPermission verify that the user meets the prestige criteria\nfunc (rs *RankService) checkUserRank(ctx context.Context, userID string, userRank int, action string) (\n\tcan bool, rank int) {\n\t// get the amount of rank required for the current operation\n\trequireRank, err := rs.configService.GetIntValue(ctx, action)\n\tif err != nil {\n\t\tlog.Error(err)\n\t\treturn false, requireRank\n\t}\n\tif userRank < requireRank || requireRank < 0 {\n\t\tlog.Debugf(\"user %s want to do action %s, but rank %d < %d\",\n\t\t\tuserID, action, userRank, requireRank)\n\t\treturn false, requireRank\n\t}\n\treturn true, requireRank\n}\n\n// GetRankPersonalPage get personal comment list page\nfunc (rs *RankService) GetRankPersonalPage(ctx context.Context, req *schema.GetRankPersonalWithPageReq) (\n\tpageModel *pager.PageModel, err error) {\n\tif plugin.RankAgentEnabled() {\n\t\treturn pager.NewPageModel(0, []string{}), nil\n\t}\n\tif len(req.Username) > 0 {\n\t\tuserInfo, exist, err := rs.userCommon.GetUserBasicInfoByUserName(ctx, req.Username)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tif !exist {\n\t\t\treturn nil, errors.BadRequest(reason.UserNotFound)\n\t\t}\n\t\treq.UserID = userInfo.ID\n\t}\n\tif len(req.UserID) == 0 {\n\t\treturn nil, errors.BadRequest(reason.UserNotFound)\n\t}\n\n\tuserRankPage, total, err := rs.userRankRepo.UserRankPage(ctx, req.UserID, req.Page, req.PageSize)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tresp := rs.decorateRankPersonalPageResp(ctx, userRankPage)\n\treturn pager.NewPageModel(total, resp), nil\n}\n\nfunc (rs *RankService) decorateRankPersonalPageResp(\n\tctx context.Context, userRankPage []*entity.Activity) []*schema.GetRankPersonalPageResp {\n\tresp := make([]*schema.GetRankPersonalPageResp, 0)\n\tlang := handler.GetLangByCtx(ctx)\n\n\tfor _, userRankInfo := range userRankPage {\n\t\tif len(userRankInfo.ObjectID) == 0 || userRankInfo.ObjectID == \"0\" {\n\t\t\tcontinue\n\t\t}\n\t\tobjInfo, err := rs.objectInfoService.GetInfo(ctx, userRankInfo.ObjectID)\n\t\tif err != nil {\n\t\t\tlog.Error(err)\n\t\t\tcontinue\n\t\t}\n\n\t\tcommentResp := &schema.GetRankPersonalPageResp{\n\t\t\tCreatedAt:  userRankInfo.CreatedAt.Unix(),\n\t\t\tObjectID:   userRankInfo.ObjectID,\n\t\t\tReputation: userRankInfo.Rank,\n\t\t}\n\t\tcfg, err := rs.configService.GetConfigByID(ctx, userRankInfo.ActivityType)\n\t\tif err != nil {\n\t\t\tlog.Error(err)\n\t\t\tcontinue\n\t\t}\n\t\tcommentResp.RankType = translator.Tr(lang, activity_type.ActivityTypeFlagMapping[cfg.Key])\n\t\tcommentResp.ObjectType = objInfo.ObjectType\n\t\tcommentResp.Title = objInfo.Title\n\t\tcommentResp.UrlTitle = htmltext.UrlTitle(objInfo.Title)\n\t\tcommentResp.Content = objInfo.Content\n\t\tif objInfo.QuestionStatus == entity.QuestionStatusDeleted {\n\t\t\tcommentResp.Title = translator.Tr(lang, constant.DeletedQuestionTitleTrKey)\n\t\t}\n\t\tcommentResp.QuestionID = objInfo.QuestionID\n\t\tcommentResp.AnswerID = objInfo.AnswerID\n\t\tresp = append(resp, commentResp)\n\t}\n\treturn resp\n}\n", "package service\n\nimport (\n\t\"context\"\n\t\"github.com/answerdev/answer/internal/service/activity_common\"\n\t\"strings\"\n\n\t\"github.com/answerdev/answer/internal/base/constant\"\n\t\"github.com/answerdev/answer/internal/base/handler\"\n\t\"github.com/answerdev/answer/internal/base/pager\"\n\t\"github.com/answerdev/answer/internal/base/translator\"\n\t\"github.com/answerdev/answer/internal/entity\"\n\t\"github.com/answerdev/answer/internal/service/activity_type\"\n\t\"github.com/answerdev/answer/internal/service/comment_common\"\n\t\"github.com/answerdev/answer/internal/service/config\"\n\t\"github.com/answerdev/answer/internal/service/object_info\"\n\t\"github.com/answerdev/answer/pkg/htmltext\"\n\t\"github.com/segmentfault/pacman/log\"\n\n\t\"github.com/answerdev/answer/internal/base/reason\"\n\t\"github.com/answerdev/answer/internal/schema\"\n\tanswercommon \"github.com/answerdev/answer/internal/service/answer_common\"\n\tquestioncommon \"github.com/answerdev/answer/internal/service/question_common\"\n\t\"github.com/segmentfault/pacman/errors\"\n)\n\n// VoteRepo activity repository\ntype VoteRepo interface {\n\tVote(ctx context.Context, op *schema.VoteOperationInfo) (err error)\n\tCancelVote(ctx context.Context, op *schema.VoteOperationInfo) (err error)\n\tGetAndSaveVoteResult(ctx context.Context, objectID, objectType string) (up, down int64, err error)\n\tListUserVotes(ctx context.Context, userID string, page int, pageSize int, activityTypes []int) (\n\t\tvoteList []*entity.Activity, total int64, err error)\n}\n\n// VoteService user service\ntype VoteService struct {\n\tvoteRepo          VoteRepo\n\tconfigService     *config.ConfigService\n\tquestionRepo      questioncommon.QuestionRepo\n\tanswerRepo        answercommon.AnswerRepo\n\tcommentCommonRepo comment_common.CommentCommonRepo\n\tobjectService     *object_info.ObjService\n\tactivityRepo      activity_common.ActivityRepo\n}\n\nfunc NewVoteService(\n\tvoteRepo VoteRepo,\n\tconfigService *config.ConfigService,\n\tquestionRepo questioncommon.QuestionRepo,\n\tanswerRepo answercommon.AnswerRepo,\n\tcommentCommonRepo comment_common.CommentCommonRepo,\n\tobjectService *object_info.ObjService,\n) *VoteService {\n\treturn &VoteService{\n\t\tvoteRepo:          voteRepo,\n\t\tconfigService:     configService,\n\t\tquestionRepo:      questionRepo,\n\t\tanswerRepo:        answerRepo,\n\t\tcommentCommonRepo: commentCommonRepo,\n\t\tobjectService:     objectService,\n\t}\n}\n\n// VoteUp vote up\nfunc (vs *VoteService) VoteUp(ctx context.Context, req *schema.VoteReq) (resp *schema.VoteResp, err error) {\n\tobjectInfo, err := vs.objectService.GetInfo(ctx, req.ObjectID)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\t// make object id must be decoded\n\tobjectInfo.ObjectID = req.ObjectID\n\n\t// check user is voting self or not\n\tif objectInfo.ObjectCreatorUserID == req.UserID {\n\t\treturn nil, errors.BadRequest(reason.DisallowVoteYourSelf)\n\t}\n\n\tvoteUpOperationInfo := vs.createVoteOperationInfo(ctx, req.UserID, true, objectInfo)\n\n\t// vote operation\n\tif req.IsCancel {\n\t\terr = vs.voteRepo.CancelVote(ctx, voteUpOperationInfo)\n\t} else {\n\t\t// cancel vote down if exist\n\t\tvoteOperationInfo := vs.createVoteOperationInfo(ctx, req.UserID, false, objectInfo)\n\t\terr = vs.voteRepo.CancelVote(ctx, voteOperationInfo)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\terr = vs.voteRepo.Vote(ctx, voteUpOperationInfo)\n\t}\n\n\tresp = &schema.VoteResp{}\n\tresp.UpVotes, resp.DownVotes, err = vs.voteRepo.GetAndSaveVoteResult(ctx, req.ObjectID, objectInfo.ObjectType)\n\tif err != nil {\n\t\tlog.Error(err)\n\t}\n\tresp.Votes = resp.UpVotes - resp.DownVotes\n\tif !req.IsCancel {\n\t\tresp.VoteStatus = constant.ActVoteUp\n\t}\n\treturn resp, nil\n}\n\n// VoteDown vote down\nfunc (vs *VoteService) VoteDown(ctx context.Context, req *schema.VoteReq) (resp *schema.VoteResp, err error) {\n\tobjectInfo, err := vs.objectService.GetInfo(ctx, req.ObjectID)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\t// make object id must be decoded\n\tobjectInfo.ObjectID = req.ObjectID\n\n\t// check user is voting self or not\n\tif objectInfo.ObjectCreatorUserID == req.UserID {\n\t\treturn nil, errors.BadRequest(reason.DisallowVoteYourSelf)\n\t}\n\n\t// vote operation\n\tvoteDownOperationInfo := vs.createVoteOperationInfo(ctx, req.UserID, false, objectInfo)\n\tif req.IsCancel {\n\t\terr = vs.voteRepo.CancelVote(ctx, voteDownOperationInfo)\n\t} else {\n\t\t// cancel vote up if exist\n\t\terr = vs.voteRepo.CancelVote(ctx, vs.createVoteOperationInfo(ctx, req.UserID, true, objectInfo))\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\terr = vs.voteRepo.Vote(ctx, voteDownOperationInfo)\n\t}\n\n\tresp = &schema.VoteResp{}\n\tresp.UpVotes, resp.DownVotes, err = vs.voteRepo.GetAndSaveVoteResult(ctx, req.ObjectID, objectInfo.ObjectType)\n\tif err != nil {\n\t\tlog.Error(err)\n\t}\n\tresp.Votes = resp.UpVotes - resp.DownVotes\n\tif !req.IsCancel {\n\t\tresp.VoteStatus = constant.ActVoteDown\n\t}\n\treturn resp, nil\n}\n\n// ListUserVotes list user's votes\nfunc (vs *VoteService) ListUserVotes(ctx context.Context, req schema.GetVoteWithPageReq) (resp *pager.PageModel, err error) {\n\ttypeKeys := []string{\n\t\tactivity_type.QuestionVoteUp,\n\t\tactivity_type.QuestionVoteDown,\n\t\tactivity_type.AnswerVoteUp,\n\t\tactivity_type.AnswerVoteDown,\n\t}\n\tactivityTypes := make([]int, 0)\n\tactivityTypeMapping := make(map[int]string, 0)\n\n\tfor _, typeKey := range typeKeys {\n\t\tcfg, err := vs.configService.GetConfigByKey(ctx, typeKey)\n\t\tif err != nil {\n\t\t\tcontinue\n\t\t}\n\t\tactivityTypes = append(activityTypes, cfg.ID)\n\t\tactivityTypeMapping[cfg.ID] = typeKey\n\t}\n\n\tvoteList, total, err := vs.voteRepo.ListUserVotes(ctx, req.UserID, req.Page, req.PageSize, activityTypes)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tlang := handler.GetLangByCtx(ctx)\n\n\tvotes := make([]*schema.GetVoteWithPageResp, 0)\n\tfor _, voteInfo := range voteList {\n\t\tobjInfo, err := vs.objectService.GetInfo(ctx, voteInfo.ObjectID)\n\t\tif err != nil {\n\t\t\tlog.Error(err)\n\t\t\tcontinue\n\t\t}\n\n\t\titem := &schema.GetVoteWithPageResp{\n\t\t\tCreatedAt:  voteInfo.CreatedAt.Unix(),\n\t\t\tObjectID:   objInfo.ObjectID,\n\t\t\tQuestionID: objInfo.QuestionID,\n\t\t\tAnswerID:   objInfo.AnswerID,\n\t\t\tObjectType: objInfo.ObjectType,\n\t\t\tTitle:      objInfo.Title,\n\t\t\tUrlTitle:   htmltext.UrlTitle(objInfo.Title),\n\t\t\tContent:    objInfo.Content,\n\t\t}\n\t\titem.VoteType = translator.Tr(lang,\n\t\t\tactivity_type.ActivityTypeFlagMapping[activityTypeMapping[voteInfo.ActivityType]])\n\t\tif objInfo.QuestionStatus == entity.QuestionStatusDeleted {\n\t\t\titem.Title = translator.Tr(lang, constant.DeletedQuestionTitleTrKey)\n\t\t}\n\t\tvotes = append(votes, item)\n\t}\n\treturn pager.NewPageModel(total, votes), err\n}\n\nfunc (vs *VoteService) createVoteOperationInfo(ctx context.Context,\n\tuserID string, voteUp bool, objectInfo *schema.SimpleObjectInfo) *schema.VoteOperationInfo {\n\t// warp vote operation\n\tvoteOperationInfo := &schema.VoteOperationInfo{\n\t\tObjectID:            objectInfo.ObjectID,\n\t\tObjectType:          objectInfo.ObjectType,\n\t\tObjectCreatorUserID: objectInfo.ObjectCreatorUserID,\n\t\tOperatingUserID:     userID,\n\t\tVoteUp:              voteUp,\n\t\tVoteDown:            !voteUp,\n\t}\n\tvoteOperationInfo.Activities = vs.getActivities(ctx, voteOperationInfo)\n\treturn voteOperationInfo\n}\n\nfunc (vs *VoteService) getActivities(ctx context.Context, op *schema.VoteOperationInfo) (\n\tactivities []*schema.VoteActivity) {\n\tactivities = make([]*schema.VoteActivity, 0)\n\n\tvar actions []string\n\tswitch op.ObjectType {\n\tcase constant.QuestionObjectType:\n\t\tif op.VoteUp {\n\t\t\tactions = []string{activity_type.QuestionVoteUp, activity_type.QuestionVotedUp}\n\t\t} else {\n\t\t\tactions = []string{activity_type.QuestionVoteDown, activity_type.QuestionVotedDown}\n\t\t}\n\tcase constant.AnswerObjectType:\n\t\tif op.VoteUp {\n\t\t\tactions = []string{activity_type.AnswerVoteUp, activity_type.AnswerVotedUp}\n\t\t} else {\n\t\t\tactions = []string{activity_type.AnswerVoteDown, activity_type.AnswerVotedDown}\n\t\t}\n\tcase constant.CommentObjectType:\n\t\tactions = []string{activity_type.CommentVoteUp}\n\t}\n\n\tfor _, action := range actions {\n\t\tt := &schema.VoteActivity{}\n\t\tcfg, err := vs.configService.GetConfigByKey(ctx, action)\n\t\tif err != nil {\n\t\t\tlog.Warnf(\"get config by key error: %v\", err)\n\t\t\tcontinue\n\t\t}\n\t\tt.ActivityType, t.Rank = cfg.ID, cfg.GetIntValue()\n\n\t\tif strings.Contains(action, \"voted\") {\n\t\t\tt.ActivityUserID = op.ObjectCreatorUserID\n\t\t\tt.TriggerUserID = op.OperatingUserID\n\t\t} else {\n\t\t\tt.ActivityUserID = op.OperatingUserID\n\t\t\tt.TriggerUserID = \"0\"\n\t\t}\n\t\tactivities = append(activities, t)\n\t}\n\treturn activities\n}\n"], "filenames": ["cmd/wire_gen.go", "internal/controller/vote_controller.go", "internal/repo/activity/answer_repo.go", "internal/repo/activity/follow_repo.go", "internal/repo/activity/user_active_repo.go", "internal/repo/activity/vote_repo.go", "internal/repo/activity_common/activity_repo.go", "internal/repo/activity_common/follow.go", "internal/repo/provider.go", "internal/repo/rank/user_rank_repo.go", "internal/repo/user/user_repo.go", "internal/schema/vote_schema.go", "internal/service/activity/answer_activity.go", "internal/service/activity_common/activity.go", "internal/service/rank/rank_service.go", "internal/service/vote_service.go"], "buggy_code_start_loc": [156, 13, 18, 46, 4, 5, 44, 77, 55, 33, 198, 9, 5, 18, 31, 4], "buggy_code_end_loc": [177, 99, 356, 114, 83, 441, 64, 122, 56, 45, 199, 48, 78, 19, 31, 209], "fixing_code_start_loc": [156, 12, 17, 46, 5, 5, 44, 77, 54, 34, 198, 9, 4, 18, 32, 5], "fixing_code_end_loc": [176, 94, 234, 114, 100, 418, 64, 122, 54, 92, 199, 55, 38, 19, 36, 257], "type": "CWE-366", "message": "Race Condition within a Thread in GitHub repository answerdev/answer prior to v1.1.1.", "other": {"cve": {"id": "CVE-2023-4127", "sourceIdentifier": "security@huntr.dev", "published": "2023-08-03T04:15:11.753", "lastModified": "2023-08-08T17:01:00.177", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Race Condition within a Thread in GitHub repository answerdev/answer prior to v1.1.1."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 5.9, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.2, "impactScore": 3.6}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-366"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:answer:answer:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.1.1", "matchCriteriaId": "0025E76C-4BCF-464D-BF24-51B8D2FFE76F"}]}]}], "references": [{"url": "https://github.com/answerdev/answer/commit/47661dc8a356ce6aa7793f1bd950399292180182", "source": "security@huntr.dev", "tags": ["Patch"]}, {"url": "https://huntr.dev/bounties/cf7d19e3-1318-4c77-8366-d8d04a0b41ba", "source": "security@huntr.dev", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/answerdev/answer/commit/47661dc8a356ce6aa7793f1bd950399292180182"}}