{"buggy_code": ["/* -*- Mode: C; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 8; c-indent-level: 8 -*- */\n/*\n * Copyright (C) 2009-2010 Juanjo Mar\u00edn <juanj.marin@juntadeandalucia.es>\n * Copyright (C) 2005, Teemu Tervo <teemu.tervo@gmx.net>\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2, or (at your option)\n * any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n */\n\n#include <config.h>\n\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <errno.h>\n\n#include <glib.h>\n#include <glib/gi18n-lib.h>\n#include <glib/gstdio.h>\n#include <gio/gio.h>\n\n#ifdef G_OS_WIN32\n# define WIFEXITED(x) ((x) != 3)\n# define WEXITSTATUS(x) (x)\n#else\n# include <sys/wait.h>\n#endif\n\n#include \"comics-document.h\"\n#include \"ev-document-misc.h\"\n#include \"ev-file-helpers.h\"\n\n#ifdef G_OS_WIN32\n/* On windows g_spawn_command_line_sync reads stdout in O_BINARY mode, not in O_TEXT mode.\n * As a consequence, newlines are in a platform dependent representation (\\r\\n). This\n * might be considered a bug in glib.\n */\n#define EV_EOL \"\\r\\n\"\n#else\n#define EV_EOL \"\\n\"\n#endif\n\ntypedef enum\n{\n\tRARLABS,\n\tGNAUNRAR,\n\tUNZIP,\n\tP7ZIP,\n\tTAR\n} ComicBookDecompressType;\n\ntypedef struct _ComicsDocumentClass ComicsDocumentClass;\n\nstruct _ComicsDocumentClass\n{\n\tEvDocumentClass parent_class;\n};\n\nstruct _ComicsDocument\n{\n\tEvDocument parent_instance;\n\n\tgchar    *archive, *dir;\n\tGPtrArray *page_names;\n\tgchar    *selected_command, *alternative_command;\n\tgchar    *extract_command, *list_command, *decompress_tmp;\n\tgboolean regex_arg;\n\tgint     offset;\n\tComicBookDecompressType command_usage;\n};\n\n#define OFFSET_7Z 53\n#define OFFSET_ZIP 2\n#define NO_OFFSET 0\n\n/* For perfomance reasons of 7z* we've choosen to decompress on the temporary \n * directory instead of decompressing on the stdout */\n\n/**\n * @extract: command line arguments to pass to extract a file from the archive\n *   to stdout.\n * @list: command line arguments to list the archive contents\n * @decompress_tmp: command line arguments to pass to extract the archive\n *   into a directory.\n * @regex_arg: whether the command can accept regex expressions\n * @offset: the position offset of the filename on each line in the output of\n *   running the @list command\n */\ntypedef struct {\n        char *extract;\n        char *list;\n        char *decompress_tmp;\n        gboolean regex_arg;\n        gint offset;\n} ComicBookDecompressCommand;\n\nstatic const ComicBookDecompressCommand command_usage_def[] = {\n        /* RARLABS unrar */\n\t{\"%s p -c- -ierr --\", \"%s vb -c- -- %s\", NULL             , FALSE, NO_OFFSET},\n\n        /* GNA! unrar */\n\t{NULL               , \"%s t %s\"        , \"%s -xf %s %s\"   , FALSE, NO_OFFSET},\n\n        /* unzip */\n\t{\"%s -p -C --\"      , \"%s %s\"          , NULL             , TRUE , OFFSET_ZIP},\n\n        /* 7zip */\n\t{NULL               , \"%s l -- %s\"     , \"%s x -y %s -o%s\", FALSE, OFFSET_7Z},\n\n        /* tar */\n\t{\"%s -xOf\"          , \"%s -tf %s\"      , NULL             , FALSE, NO_OFFSET}\n};\n\nstatic GSList*    get_supported_image_extensions (void);\nstatic void       get_page_size_area_prepared_cb (GdkPixbufLoader *loader,\n\t\t\t\t\t\t  gpointer data);\nstatic void       render_pixbuf_size_prepared_cb (GdkPixbufLoader *loader,\n\t\t\t\t\t\t  gint width,\n\t\t\t\t\t\t  gint height,\n\t\t\t\t\t\t  EvRenderContext *rc);\nstatic char**     extract_argv                   (EvDocument *document,\n\t\t\t\t\t\t  gint page);\n\n\nEV_BACKEND_REGISTER (ComicsDocument, comics_document)\n\n/**\n * comics_regex_quote:\n * @unquoted_string: a literal string\n *\n * Quotes a string so unzip will not interpret the regex expressions of\n * @unquoted_string. Basically, this functions uses [] to disable regex \n * expressions. The return value must be freed with * g_free()\n *\n * Return value: quoted and disabled-regex string\n **/\nstatic gchar *\ncomics_regex_quote (const gchar *unquoted_string)\n{\n\tconst gchar *p;\n\tGString *dest;\n\n\tdest = g_string_new (\"'\");\n\n\tp = unquoted_string;\n\n\twhile (*p) {\n\t\tswitch (*p) {\n\t\t\t/* * matches a sequence of 0 or more characters */\n\t\t\tcase ('*'):\n\t\t\t/* ? matches exactly 1 charactere */\n\t\t\tcase ('?'):\n\t\t\t/* [...]  matches any single character found inside\n\t\t\t * the brackets. Disabling the first bracket is enough.\n\t\t\t */\n\t\t\tcase ('['):\n\t\t\t\tg_string_append (dest, \"[\");\n\t\t\t\tg_string_append_c (dest, *p);\n\t\t\t\tg_string_append (dest, \"]\");\n\t\t\t\tbreak;\n\t\t\t/* Because \\ escapes regex expressions that we are\n\t\t\t * disabling for unzip, we need to disable \\ too */\n\t\t\tcase ('\\\\'):\n\t\t\t\tg_string_append (dest, \"[\\\\\\\\]\");\n\t\t\t\tbreak;\n\t\t\t/* Escape single quote inside the string */\n\t\t\tcase ('\\''):\n\t\t\t\tg_string_append (dest, \"'\\\\''\");\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tg_string_append_c (dest, *p);\n\t\t\t\tbreak;\n\t\t}\n\t\t++p;\n\t}\n\tg_string_append_c (dest, '\\'');\n\treturn g_string_free (dest, FALSE);\n}\n\n\n/* This function manages the command for decompressing a comic book */\nstatic gboolean \ncomics_decompress_temp_dir (const gchar *command_decompress_tmp,\n\t\t\t    const gchar *command, \n\t\t\t    GError      **error)\n{\n\tgboolean success;\n\tgchar *std_out, *basename;\n\tGError *err = NULL;\n\tgint retval;\n\t\n\tsuccess = g_spawn_command_line_sync (command_decompress_tmp, &std_out, \n\t\t\t\t\t     NULL, &retval, &err);\n\tbasename = g_path_get_basename (command);\n\tif (!success) {\n\t\tg_set_error (error,\n\t\t\t     EV_DOCUMENT_ERROR, \n\t\t\t     EV_DOCUMENT_ERROR_INVALID,\n\t\t\t     _(\"Error launching the command \u201c%s\u201d in order to \"\n\t\t\t     \"decompress the comic book: %s\"),\n\t\t\t     basename,\n\t\t\t     err->message);\n\t\tg_error_free (err);\n\t} else if (WIFEXITED (retval)) {\n\t\tif (WEXITSTATUS (retval) == EXIT_SUCCESS) {\n\t\t\tg_free (std_out);\n\t\t\tg_free (basename);\n\t\t\treturn TRUE;\n\t\t} else {\n\t\t\tg_set_error (error,\n\t\t\t\t     EV_DOCUMENT_ERROR,\n\t\t\t\t     EV_DOCUMENT_ERROR_INVALID,\n\t\t\t\t     _(\"The command \u201c%s\u201d failed at \"\n\t\t\t\t     \"decompressing the comic book.\"),\n\t\t\t\t     basename);\n\t\t\tg_free (std_out);\n\t\t}\n\t} else {\n\t\tg_set_error (error,\n\t\t\t     EV_DOCUMENT_ERROR,\n\t\t\t     EV_DOCUMENT_ERROR_INVALID,\n\t\t\t     _(\"The command \u201c%s\u201d did not end normally.\"),\n\t\t\t     basename);\n\t\tg_free (std_out);\n\t}\n\tg_free (basename);\n\treturn FALSE;\n}\n\n/* This function shows how to use the chosen command for decompressing a\n * comic book file. It modifies fields of the ComicsDocument struct with \n * this information */\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wformat-nonliteral\"\nstatic gboolean \ncomics_generate_command_lines (ComicsDocument *comics_document, \n\t\t\t       GError         **error)\n{\n\tgchar *quoted_file, *quoted_file_aux;\n\tgchar *quoted_command;\n\tComicBookDecompressType type;\n\t\n\ttype = comics_document->command_usage;\n\tcomics_document->regex_arg = command_usage_def[type].regex_arg;\n\tquoted_command = g_shell_quote (comics_document->selected_command);\n\tif (comics_document->regex_arg) {\n\t\tquoted_file = comics_regex_quote (comics_document->archive);\n\t\tquoted_file_aux = g_shell_quote (comics_document->archive);\n\t\tcomics_document->list_command =\n\t\t\t   g_strdup_printf (command_usage_def[type].list,\n\t\t\t                    comics_document->alternative_command,\n\t\t\t                    quoted_file_aux);\n\t\tg_free (quoted_file_aux);\n\t} else {\n\t\tquoted_file = g_shell_quote (comics_document->archive);\n\t\tcomics_document->list_command =\n\t\t\t\tg_strdup_printf (command_usage_def[type].list,\n\t\t\t\t                 quoted_command, quoted_file);\n\t}\n\tcomics_document->extract_command =\n\t\t\t    g_strdup_printf (command_usage_def[type].extract,\n\t\t\t\t             quoted_command);\n\tcomics_document->offset = command_usage_def[type].offset;\n\tif (command_usage_def[type].decompress_tmp) {\n\t\tcomics_document->dir = ev_mkdtemp (\"evince-comics-XXXXXX\", error);\n                if (comics_document->dir == NULL)\n                        return FALSE;\n\n\t\t/* unrar-free can't create directories, but ev_mkdtemp already created the dir */\n\n\t\tcomics_document->decompress_tmp =\n\t\t\tg_strdup_printf (command_usage_def[type].decompress_tmp, \n\t\t\t\t\t quoted_command, quoted_file,\n\t\t\t\t\t comics_document->dir);\n\t\tg_free (quoted_file);\n\t\tg_free (quoted_command);\n\n\t\tif (!comics_decompress_temp_dir (comics_document->decompress_tmp,\n\t\t    comics_document->selected_command, error))\n\t\t\treturn FALSE;\n\t\telse\n\t\t\treturn TRUE;\n\t} else {\n\t\tg_free (quoted_file);\n\t\tg_free (quoted_command);\n\t\treturn TRUE;\n\t}\n\n}\n#pragma GCC diagnostic pop\n\n/* This function chooses an external command for decompressing a comic \n * book based on its mime tipe. */\nstatic gboolean \ncomics_check_decompress_command\t(gchar          *mime_type, \n\t\t\t\t ComicsDocument *comics_document,\n\t\t\t\t GError         **error)\n{\n\tgboolean success;\n\tgchar *std_out, *std_err;\n\tgint retval;\n\tGError *err = NULL;\n\t\n\t/* FIXME, use proper cbr/cbz mime types once they're\n\t * included in shared-mime-info */\n\t\n\tif (g_content_type_is_a (mime_type, \"application/x-cbr\") ||\n\t    g_content_type_is_a (mime_type, \"application/x-rar\")) {\n\t        /* The RARLAB provides a no-charge proprietary (freeware) \n\t        * decompress-only client for Linux called unrar. Another \n\t\t* option is a GPLv2-licensed command-line tool developed by \n\t\t* the Gna! project. Confusingly enough, the free software RAR \n\t\t* decoder is also named unrar. For this reason we need to add \n\t\t* some lines for disambiguation. Sorry for the added the \n\t\t* complexity but it's life :)\n\t\t* Finally, some distributions, like Debian, rename this free \n\t\t* option as unrar-free. \n\t\t* */\n\t\tcomics_document->selected_command = \n\t\t\t\t\tg_find_program_in_path (\"unrar\");\n\t\tif (comics_document->selected_command) {\n\t\t\t/* We only use std_err to avoid printing useless error \n\t\t\t * messages on the terminal */\n\t\t\tsuccess = \n\t\t\t\tg_spawn_command_line_sync (\n\t\t\t\t              comics_document->selected_command, \n\t\t\t\t\t\t\t   &std_out, &std_err,\n\t\t\t\t\t\t\t   &retval, &err);\n\t\t\tif (!success) {\n\t\t\t\tg_propagate_error (error, err);\n\t\t\t\tg_error_free (err);\n\t\t\t\treturn FALSE;\n\t\t\t/* I don't check retval status because RARLAB unrar \n\t\t\t * doesn't have a way to return 0 without involving an \n\t\t\t * operation with a file*/\n\t\t\t} else if (WIFEXITED (retval)) {\n\t\t\t\tif (g_strrstr (std_out,\"freeware\") != NULL)\n\t\t\t\t\t/* The RARLAB freeware client */\n\t\t\t\t\tcomics_document->command_usage = RARLABS;\n\t\t\t\telse\n\t\t\t\t\t/* The Gna! free software client */\n\t\t\t\t\tcomics_document->command_usage = GNAUNRAR;\n\n\t\t\t\tg_free (std_out);\n\t\t\t\tg_free (std_err);\n\t\t\t\treturn TRUE;\n\t\t\t}\n\t\t}\n\t\t/* The Gna! free software client with Debian naming convention */\n\t\tcomics_document->selected_command = \n\t\t\t\tg_find_program_in_path (\"unrar-free\");\n\t\tif (comics_document->selected_command) {\n\t\t\tcomics_document->command_usage = GNAUNRAR;\n\t\t\treturn TRUE;\n\t\t}\n\t\tcomics_document->selected_command =\n\t\t\t\tg_find_program_in_path (\"bsdtar\");\n\t\tif (comics_document->selected_command) {\n\t\t\tcomics_document->command_usage = TAR;\n\t\t\treturn TRUE;\n\t\t}\n\n\t} else if (g_content_type_is_a (mime_type, \"application/x-cbz\") ||\n\t\t   g_content_type_is_a (mime_type, \"application/zip\")) {\n\t\t/* InfoZIP's unzip program */\n\t\tcomics_document->selected_command = \n\t\t\t\tg_find_program_in_path (\"unzip\");\n\t\tcomics_document->alternative_command =\n\t\t\t\tg_find_program_in_path (\"zipnote\");\n\t\tif (comics_document->selected_command &&\n\t\t    comics_document->alternative_command) {\n\t\t\tcomics_document->command_usage = UNZIP;\n\t\t\treturn TRUE;\n\t\t}\n\t\t/* fallback mode using 7za and 7z from p7zip project  */\n\t\tcomics_document->selected_command =\n\t\t\t\tg_find_program_in_path (\"7za\");\n\t\tif (comics_document->selected_command) {\n\t\t\tcomics_document->command_usage = P7ZIP;\n\t\t\treturn TRUE;\n\t\t}\n\t\tcomics_document->selected_command =\n\t\t\t\tg_find_program_in_path (\"7z\");\n\t\tif (comics_document->selected_command) {\n\t\t\tcomics_document->command_usage = P7ZIP;\n\t\t\treturn TRUE;\n\t\t}\n\t\tcomics_document->selected_command =\n\t\t\t\tg_find_program_in_path (\"bsdtar\");\n\t\tif (comics_document->selected_command) {\n\t\t\tcomics_document->command_usage = TAR;\n\t\t\treturn TRUE;\n\t\t}\n\n\t} else if (g_content_type_is_a (mime_type, \"application/x-cb7\") ||\n\t\t   g_content_type_is_a (mime_type, \"application/x-7z-compressed\")) {\n\t\t/* 7zr, 7za and 7z are the commands from the p7zip project able \n\t\t * to decompress .7z files */ \n\t\tcomics_document->selected_command =\n\t\t\t\tg_find_program_in_path (\"7zr\");\n\t\tif (comics_document->selected_command) {\n\t\t\tcomics_document->command_usage = P7ZIP;\n\t\t\treturn TRUE;\n\t\t}\n\t\tcomics_document->selected_command =\n\t\t\t\tg_find_program_in_path (\"7za\");\n\t\tif (comics_document->selected_command) {\n\t\t\tcomics_document->command_usage = P7ZIP;\n\t\t\treturn TRUE;\n\t\t}\n\t\tcomics_document->selected_command =\n\t\t\t\tg_find_program_in_path (\"7z\");\n\t\tif (comics_document->selected_command) {\n\t\t\tcomics_document->command_usage = P7ZIP;\n\t\t\treturn TRUE;\n\t\t}\n\t\tcomics_document->selected_command =\n\t\t\t\tg_find_program_in_path (\"bsdtar\");\n\t\tif (comics_document->selected_command) {\n\t\t\tcomics_document->command_usage = TAR;\n\t\t\treturn TRUE;\n\t\t}\n\t} else if (g_content_type_is_a (mime_type, \"application/x-cbt\") ||\n\t\t   g_content_type_is_a (mime_type, \"application/x-tar\")) {\n\t\t/* tar utility (Tape ARchive) */\n\t\tcomics_document->selected_command =\n\t\t\t\tg_find_program_in_path (\"tar\");\n\t\tif (comics_document->selected_command) {\n\t\t\tcomics_document->command_usage = TAR;\n\t\t\treturn TRUE;\n\t\t}\n\t\tcomics_document->selected_command =\n\t\t\t\tg_find_program_in_path (\"bsdtar\");\n\t\tif (comics_document->selected_command) {\n\t\t\tcomics_document->command_usage = TAR;\n\t\t\treturn TRUE;\n\t\t}\n\t} else {\n\t\tg_set_error (error,\n\t\t\t     EV_DOCUMENT_ERROR,\n\t\t\t     EV_DOCUMENT_ERROR_INVALID,\n\t\t\t     _(\"Not a comic book MIME type: %s\"),\n\t\t\t     mime_type);\n\t\t\t     return FALSE;\n\t}\n\tg_set_error_literal (error,\n\t\t\t     EV_DOCUMENT_ERROR,\n\t\t\t     EV_DOCUMENT_ERROR_INVALID,\n\t\t\t     _(\"Can\u2019t find an appropriate command to \"\n\t\t\t     \"decompress this type of comic book\"));\n\treturn FALSE;\n}\n\nstatic int\nsort_page_names (gconstpointer a,\n                 gconstpointer b)\n{\n  gchar *temp1, *temp2;\n  gint ret;\n\n  temp1 = g_utf8_collate_key_for_filename (* (const char **) a, -1);\n  temp2 = g_utf8_collate_key_for_filename (* (const char **) b, -1);\n\n  ret = strcmp (temp1, temp2);\n\n  g_free (temp1);\n  g_free (temp2);\n\n  return ret;\n}\n\nstatic gboolean\ncomics_document_load (EvDocument *document,\n\t\t      const char *uri,\n\t\t      GError    **error)\n{\n\tComicsDocument *comics_document = COMICS_DOCUMENT (document);\n\tGSList *supported_extensions;\n\tgchar *std_out;\n\tgchar *mime_type;\n\tgchar **cb_files, *cb_file;\n\tgboolean success;\n\tint i, retval;\n\tGError *err = NULL;\n\n\tcomics_document->archive = g_filename_from_uri (uri, NULL, error);\n\tif (!comics_document->archive)\n\t\treturn FALSE;\n\n\tmime_type = ev_file_get_mime_type (uri, FALSE, &err);\n\tif (mime_type == NULL)\n\t\treturn FALSE;\n\t\n\tif (!comics_check_decompress_command (mime_type, comics_document, \n\terror)) {\t\n\t\tg_free (mime_type);\n\t\treturn FALSE;\n\t} else if (!comics_generate_command_lines (comics_document, error)) {\n\t\t   g_free (mime_type);\n\t\treturn FALSE;\n\t}\n\n\tg_free (mime_type);\n\n\t/* Get list of files in archive */\n\tsuccess = g_spawn_command_line_sync (comics_document->list_command,\n\t\t\t\t\t     &std_out, NULL, &retval, error);\n\n\tif (!success) {\n\t\treturn FALSE;\n\t} else if (!WIFEXITED(retval) || WEXITSTATUS(retval) != EXIT_SUCCESS) {\n\t\tg_set_error_literal (error,\n                                     EV_DOCUMENT_ERROR,\n                                     EV_DOCUMENT_ERROR_INVALID,\n                                     _(\"File corrupted\"));\n\t\treturn FALSE;\n\t}\n\n\t/* FIXME: is this safe against filenames containing \\n in the archive ? */\n\tcb_files = g_strsplit (std_out, EV_EOL, 0);\n\n\tg_free (std_out);\n\n\tif (!cb_files) {\n\t\tg_set_error_literal (error,\n\t\t\t\t     EV_DOCUMENT_ERROR,\n\t\t\t\t     EV_DOCUMENT_ERROR_INVALID,\n\t\t\t\t     _(\"No files in archive\"));\n\t\treturn FALSE;\n\t}\n\n        comics_document->page_names = g_ptr_array_sized_new (64);\n\n\tsupported_extensions = get_supported_image_extensions ();\n\tfor (i = 0; cb_files[i] != NULL; i++) {\n\t\tif (comics_document->offset != NO_OFFSET) {\n\t\t\tif (g_utf8_strlen (cb_files[i],-1) > \n\t\t\t    comics_document->offset) {\n\t\t\t\tcb_file = \n\t\t\t\t\tg_utf8_offset_to_pointer (cb_files[i], \n\t\t\t\t\t\t       comics_document->offset);\n\t\t\t} else {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else {\n\t\t\tcb_file = cb_files[i];\n\t\t}\n\t\tgchar *suffix = g_strrstr (cb_file, \".\");\n\t\tif (!suffix)\n\t\t\tcontinue;\n\t\tsuffix = g_ascii_strdown (suffix + 1, -1);\n\t\tif (g_slist_find_custom (supported_extensions, suffix,\n\t\t\t\t\t (GCompareFunc) strcmp) != NULL) {\n                        g_ptr_array_add (comics_document->page_names,\n                                         g_strstrip (g_strdup (cb_file)));\n\t\t}\n\t\tg_free (suffix);\n\t}\n\tg_strfreev (cb_files);\n\tg_slist_foreach (supported_extensions, (GFunc) g_free, NULL);\n\tg_slist_free (supported_extensions);\n\n\tif (comics_document->page_names->len == 0) {\n\t\tg_set_error (error,\n\t\t\t     EV_DOCUMENT_ERROR,\n\t\t\t     EV_DOCUMENT_ERROR_INVALID,\n\t\t\t     _(\"No images found in archive %s\"),\n\t\t\t     uri);\n\t\treturn FALSE;\n\t}\n\n        /* Now sort the pages */\n        g_ptr_array_sort (comics_document->page_names, sort_page_names);\n\n\treturn TRUE;\n}\n\n\nstatic gboolean\ncomics_document_save (EvDocument *document,\n\t\t      const char *uri,\n\t\t      GError    **error)\n{\n\tComicsDocument *comics_document = COMICS_DOCUMENT (document);\n\n\treturn ev_xfer_uri_simple (comics_document->archive, uri, error);\n}\n\nstatic int\ncomics_document_get_n_pages (EvDocument *document)\n{\n\tComicsDocument *comics_document = COMICS_DOCUMENT (document);\n\n        if (comics_document->page_names == NULL)\n                return 0;\n\n\treturn comics_document->page_names->len;\n}\n\nstatic void\ncomics_document_get_page_size (EvDocument *document,\n\t\t\t       EvPage     *page,\n\t\t\t       double     *width,\n\t\t\t       double     *height)\n{\n\tGdkPixbufLoader *loader;\n\tchar **argv;\n\tguchar buf[1024];\n\tgboolean success, got_size = FALSE;\n\tgint outpipe = -1;\n\tGPid child_pid;\n\tgssize bytes;\n\tGdkPixbuf *pixbuf;\n\tgchar *filename;\n\tComicsDocument *comics_document = COMICS_DOCUMENT (document);\n\t\n\tif (!comics_document->decompress_tmp) {\n\t\targv = extract_argv (document, page->index);\n\t\tsuccess = g_spawn_async_with_pipes (NULL, argv, NULL,\n\t\t\t\t\t\t    G_SPAWN_SEARCH_PATH | \n\t\t\t\t\t\t    G_SPAWN_STDERR_TO_DEV_NULL,\n\t\t\t\t\t\t    NULL, NULL,\n\t\t\t\t\t\t    &child_pid,\n\t\t\t\t\t\t    NULL, &outpipe, NULL, NULL);\n\t\tg_strfreev (argv);\n\t\tg_return_if_fail (success == TRUE);\n\n\t\tloader = gdk_pixbuf_loader_new ();\n\t\tg_signal_connect (loader, \"area-prepared\",\n\t\t\t\t  G_CALLBACK (get_page_size_area_prepared_cb),\n\t\t\t\t  &got_size);\n\n\t\twhile (outpipe >= 0) {\n\t\t\tbytes = read (outpipe, buf, 1024);\n\t\t\n\t\t\tif (bytes > 0)\n\t\t\tgdk_pixbuf_loader_write (loader, buf, bytes, NULL);\n\t\t\tif (bytes <= 0 || got_size) {\n\t\t\t\tclose (outpipe);\n\t\t\t\toutpipe = -1;\n\t\t\t\tgdk_pixbuf_loader_close (loader, NULL);\n\t\t\t}\n\t\t}\n\t\tpixbuf = gdk_pixbuf_loader_get_pixbuf (loader);\n\t\tif (pixbuf) {\n\t\t\tif (width)\n\t\t\t\t*width = gdk_pixbuf_get_width (pixbuf);\n\t\t\tif (height)\n\t\t\t\t*height = gdk_pixbuf_get_height (pixbuf);\n\t\t}\n\t\tg_spawn_close_pid (child_pid);\n\t\tg_object_unref (loader);\n\t} else {\n\t\tfilename = g_build_filename (comics_document->dir,\n                                             (char *) comics_document->page_names->pdata[page->index],\n\t\t\t\t\t     NULL);\n\t\tpixbuf = gdk_pixbuf_new_from_file (filename, NULL);\n\t\tif (pixbuf) {\n\t\t\tif (width)\n\t\t\t\t*width = gdk_pixbuf_get_width (pixbuf);\n\t\t\tif (height)\n\t\t\t\t*height = gdk_pixbuf_get_height (pixbuf);\n\t\t\tg_object_unref (pixbuf);\n\t\t}\n\t\tg_free (filename);\n\t}\n}\n\nstatic void\nget_page_size_area_prepared_cb (GdkPixbufLoader *loader,\n\t\t\t\tgpointer         data)\n{\n\tgboolean *got_size = data;\n\t*got_size = TRUE;\n}\n\nstatic GdkPixbuf *\ncomics_document_render_pixbuf (EvDocument      *document,\n\t\t\t       EvRenderContext *rc)\n{\n\tGdkPixbufLoader *loader;\n\tGdkPixbuf *rotated_pixbuf, *tmp_pixbuf;\n\tchar **argv;\n\tguchar buf[4096];\n\tgboolean success;\n\tgint outpipe = -1;\n\tGPid child_pid;\n\tgssize bytes;\n\tgint width, height;\n\tgchar *filename;\n\tComicsDocument *comics_document = COMICS_DOCUMENT (document);\n\t\n\tif (!comics_document->decompress_tmp) {\n\t\targv = extract_argv (document, rc->page->index);\n\t\tsuccess = g_spawn_async_with_pipes (NULL, argv, NULL,\n\t\t\t\t\t\t    G_SPAWN_SEARCH_PATH | \n\t\t\t\t\t\t    G_SPAWN_STDERR_TO_DEV_NULL,\n\t\t\t\t\t\t    NULL, NULL,\n\t\t\t\t\t\t    &child_pid,\n\t\t\t\t\t\t    NULL, &outpipe, NULL, NULL);\n\t\tg_strfreev (argv);\n\t\tg_return_val_if_fail (success == TRUE, NULL);\n\n\t\tloader = gdk_pixbuf_loader_new ();\n\t\tg_signal_connect (loader, \"size-prepared\",\n\t\t\t\t  G_CALLBACK (render_pixbuf_size_prepared_cb), \n\t\t\t\t  rc);\n\n\t\twhile (outpipe >= 0) {\n\t\t\tbytes = read (outpipe, buf, 4096);\n\n\t\t\tif (bytes > 0) {\n\t\t\t\tgdk_pixbuf_loader_write (loader, buf, bytes, \n\t\t\t\tNULL);\n\t\t\t} else if (bytes <= 0) {\n\t\t\t\tclose (outpipe);\n\t\t\t\tgdk_pixbuf_loader_close (loader, NULL);\n\t\t\t\toutpipe = -1;\n\t\t\t}\n\t\t}\n\t\ttmp_pixbuf = gdk_pixbuf_loader_get_pixbuf (loader);\n\t\trotated_pixbuf =\n\t\t\tgdk_pixbuf_rotate_simple (tmp_pixbuf,\n\t\t\t\t\t\t  360 - rc->rotation);\n\t\tg_spawn_close_pid (child_pid);\n\t\tg_object_unref (loader);\n\t} else {\n\t\tint scaled_width, scaled_height;\n\n\t\tfilename = \n\t\t\tg_build_filename (comics_document->dir,\n                                          (char *) comics_document->page_names->pdata[rc->page->index],\n\t\t\t\t\t  NULL);\n\t   \n\t\tgdk_pixbuf_get_file_info (filename, &width, &height);\n\n\t\tev_render_context_compute_scaled_size (rc, width, height,\n\t\t\t\t\t\t       &scaled_width, &scaled_height);\n\t\t\n\t\ttmp_pixbuf =\n\t\t\tgdk_pixbuf_new_from_file_at_size (\n\t\t\t\t    filename, scaled_width, scaled_height, NULL);\n\t\trotated_pixbuf =\n\t\t\tgdk_pixbuf_rotate_simple (tmp_pixbuf,\n\t\t\t\t\t\t  360 - rc->rotation);\n\t\tg_free (filename);\n\t\tg_object_unref (tmp_pixbuf);\n\t}\n\treturn rotated_pixbuf;\n}\n\nstatic cairo_surface_t *\ncomics_document_render (EvDocument      *document,\n\t\t\tEvRenderContext *rc)\n{\n\tGdkPixbuf       *pixbuf;\n\tcairo_surface_t *surface;\n\n\tpixbuf = comics_document_render_pixbuf (document, rc);\n\tsurface = ev_document_misc_surface_from_pixbuf (pixbuf);\n\tg_object_unref (pixbuf);\n\t\n\treturn surface;\n}\n\nstatic void\nrender_pixbuf_size_prepared_cb (GdkPixbufLoader *loader,\n\t\t\t\tgint             width,\n\t\t\t\tgint             height,\n\t\t\t\tEvRenderContext *rc)\n{\n\tint scaled_width, scaled_height;\n\n\tev_render_context_compute_scaled_size (rc, width, height, &scaled_width, &scaled_height);\n\tgdk_pixbuf_loader_set_size (loader, scaled_width, scaled_height);\n}\n\n/**\n * comics_remove_dir: Removes a directory recursively. \n * Returns:\n *   \t0 if it was successfully deleted,\n * \t-1 if an error occurred \t\t\n */\nstatic int \ncomics_remove_dir (gchar *path_name) \n{\n\tGDir  *content_dir;\n\tconst gchar *filename;\n\tgchar *filename_with_path;\n\t\n\tif (g_file_test (path_name, G_FILE_TEST_IS_DIR)) {\n\t\tcontent_dir = g_dir_open  (path_name, 0, NULL);\n\t\tfilename  = g_dir_read_name (content_dir);\n\t\twhile (filename) {\n\t\t\tfilename_with_path = \n\t\t\t\tg_build_filename (path_name, \n\t\t\t\t\t\t  filename, NULL);\n\t\t\tcomics_remove_dir (filename_with_path);\n\t\t\tg_free (filename_with_path);\n\t\t\tfilename = g_dir_read_name (content_dir);\n\t\t}\n\t\tg_dir_close (content_dir);\n\t}\n\t/* Note from g_remove() documentation: on Windows, it is in general not \n\t * possible to remove a file that is open to some process, or mapped \n\t * into memory.*/\n\treturn (g_remove (path_name));\n}\n\nstatic void\ncomics_document_finalize (GObject *object)\n{\n\tComicsDocument *comics_document = COMICS_DOCUMENT (object);\n\t\n\tif (comics_document->decompress_tmp) {\n\t\tif (comics_remove_dir (comics_document->dir) == -1)\n\t\t\tg_warning (_(\"There was an error deleting \u201c%s\u201d.\"),\n\t\t\t\t   comics_document->dir);\n\t\tg_free (comics_document->dir);\n\t}\n\t\n\tif (comics_document->page_names) {\n                g_ptr_array_foreach (comics_document->page_names, (GFunc) g_free, NULL);\n                g_ptr_array_free (comics_document->page_names, TRUE);\n\t}\n\n\tg_free (comics_document->archive);\n\tg_free (comics_document->selected_command);\n\tg_free (comics_document->alternative_command);\n\tg_free (comics_document->extract_command);\n\tg_free (comics_document->list_command);\n\n\tG_OBJECT_CLASS (comics_document_parent_class)->finalize (object);\n}\n\nstatic void\ncomics_document_class_init (ComicsDocumentClass *klass)\n{\n\tGObjectClass    *gobject_class = G_OBJECT_CLASS (klass);\n\tEvDocumentClass *ev_document_class = EV_DOCUMENT_CLASS (klass);\n\n\tgobject_class->finalize = comics_document_finalize;\n\n\tev_document_class->load = comics_document_load;\n\tev_document_class->save = comics_document_save;\n\tev_document_class->get_n_pages = comics_document_get_n_pages;\n\tev_document_class->get_page_size = comics_document_get_page_size;\n\tev_document_class->render = comics_document_render;\n}\n\nstatic void\ncomics_document_init (ComicsDocument *comics_document)\n{\n\tcomics_document->archive = NULL;\n\tcomics_document->page_names = NULL;\n\tcomics_document->extract_command = NULL;\n}\n\n/* Returns a list of file extensions supported by gdk-pixbuf */\nstatic GSList*\nget_supported_image_extensions(void)\n{\n\tGSList *extensions = NULL;\n\tGSList *formats = gdk_pixbuf_get_formats ();\n\tGSList *l;\n\n\tfor (l = formats; l != NULL; l = l->next) {\n\t\tint i;\n\t\tgchar **ext = gdk_pixbuf_format_get_extensions (l->data);\n\n\t\tfor (i = 0; ext[i] != NULL; i++) {\n\t\t\textensions = g_slist_append (extensions,\n\t\t\t\t\t\t     g_strdup (ext[i]));\n\t\t}\n\n\t\tg_strfreev (ext);\n\t}\n\n\tg_slist_free (formats);\n\treturn extensions;\n}\n\nstatic char**\nextract_argv (EvDocument *document, gint page)\n{\n\tComicsDocument *comics_document = COMICS_DOCUMENT (document);\n\tchar **argv;\n\tchar *command_line, *quoted_archive, *quoted_filename;\n\tGError *err = NULL;\n\n        if (page >= comics_document->page_names->len)\n                return NULL;\n\n\tif (comics_document->regex_arg) {\n\t\tquoted_archive = g_shell_quote (comics_document->archive);\n\t\tquoted_filename =\n\t\t\tcomics_regex_quote (comics_document->page_names->pdata[page]);\n\t} else {\n\t\tquoted_archive = g_shell_quote (comics_document->archive);\n\t\tquoted_filename = g_shell_quote (comics_document->page_names->pdata[page]);\n\t}\n\n\tcommand_line = g_strdup_printf (\"%s %s %s\",\n\t\t\t\t\tcomics_document->extract_command,\n\t\t\t\t\tquoted_archive,\n\t\t\t\t\tquoted_filename);\n\tg_shell_parse_argv (command_line, NULL, &argv, &err);\n\n\tif (err) {\n\t\tg_warning (_(\"Error %s\"), err->message);\n\t\tg_error_free (err);\n\t\treturn NULL;\n\t}\n\n\tg_free (command_line);\n\tg_free (quoted_archive);\n\tg_free (quoted_filename);\n\treturn argv;\n}\n", "# *****************************************************************************\n# Versioning\n# *****************************************************************************\n\nm4_define([ev_major_version],[3])\nm4_define([ev_minor_version],[24])\nm4_define([ev_micro_version],[0])\nm4_define([ev_extra_version],[])\nm4_define([ev_version],[ev_major_version.ev_minor_version.ev_micro_version()ev_extra_version])\n\n# The evince API version\nm4_define([ev_api_version], [3.0])\n\n# Libtool versioning. The backend and view libraries have separate versions.\n# Before making a release, the libtool version should be modified.\n# The string is of the form C:R:A.\n# - If interfaces have been changed or added, but binary compatibility has\n#   been preserved, change to C+1:0:A+1\n# - If binary compatibility has been broken (eg removed or changed interfaces)\n#   change to C+1:0:0\n# - If the interface is the same as the previous version, change to C:R+1:A\n\n# Libtool version of the backend library\nm4_define([ev_document_lt_current],[4])\nm4_define([ev_document_lt_revision],[0])\nm4_define([ev_document_lt_age],[0])\nm4_define([ev_document_lt_version_info],[ev_document_lt_current:ev_document_lt_revision:ev_document_lt_age])\nm4_define([ev_document_lt_current_minus_age],[m4_eval(ev_document_lt_current - ev_document_lt_age)])\n\n# Libtool version of the view library\nm4_define([ev_view_lt_current],[3])\nm4_define([ev_view_lt_revision],[0])\nm4_define([ev_view_lt_age],[0])\nm4_define([ev_view_lt_version_info],[ev_view_lt_current:ev_view_lt_revision:ev_view_lt_age])\nm4_define([ev_view_lt_current_minus_age],[m4_eval(ev_view_lt_current - ev_view_lt_age)])\n\n# Binary version for the document backends\nm4_define([ev_binary_version],[ev_document_lt_current])\n\n# *****************************************************************************\n\nAC_PREREQ([2.57])\nAC_INIT([Evince],[ev_version],[http://bugzilla.gnome.org/enter_bug.cgi?product=evince],[evince])\nAM_INIT_AUTOMAKE([1.10 foreign dist-xz no-dist-gzip tar-ustar])\n\nAC_CONFIG_HEADERS([config.h])\nAC_CONFIG_MACRO_DIR([m4])\n\nif test -z \"$enable_maintainer_mode\"; then\n  enable_maintainer_mode=yes\nfi\nAM_MAINTAINER_MODE([enable])\n\nm4_ifdef([AM_SILENT_RULES],[AM_SILENT_RULES([yes])])\n\nAC_PROG_CC\nAM_PROG_CC_C_O\nAC_PROG_CXX\n\nAC_PROG_SED\n\n# Initialize libtool\nLT_PREREQ([2.2])\nLT_INIT\nLT_LIB_M\n\nGNOME_CXX_WARNINGS\n\nIT_PROG_INTLTOOL([0.35.0])\n\nGETTEXT_PACKAGE=evince\nAC_SUBST(GETTEXT_PACKAGE)\nAC_DEFINE_UNQUOTED([GETTEXT_PACKAGE],[\"$GETTEXT_PACKAGE\"],[Gettext package])\nAM_GLIB_GNU_GETTEXT\n\nm4_pattern_allow([AM_V_GEN])dnl Make autoconf not complain about the rule below\nEV_INTLTOOL_EVINCE_BACKEND_RULE='%.evince-backend:   %.evince-backend.in   $(INTLTOOL_MERGE) $(wildcard $(top_srcdir)/po/*.po) ; $(AM_V_GEN) LC_ALL=C $(INTLTOOL_MERGE) -d -u -c $(top_builddir)/po/.intltool-merge-cache $(top_srcdir)/po $< [$]@'\nAC_SUBST([EV_INTLTOOL_EVINCE_BACKEND_RULE])\n\nGLIB_GSETTINGS\n\n# Check which platform to use\n\nAC_MSG_CHECKING([for which platform to build])\nAC_ARG_WITH([platform],\n  [AS_HELP_STRING([--with-platform=gnome|win32],\n                  [Setting platform (default: gnome)])],\n  [case \"$withval\" in\n    gnome|win32) ;;\n    *) AC_MSG_ERROR([invalid argument \"$withval\" for --with-platform]) ;;\n   esac],\n  [case \"$host\" in\n     *-*-mingw*|*-*-cygwin*) with_platform=\"win32\" ;;\n     *) with_platform=gnome ;;\n   esac])\n\nAC_MSG_RESULT([$with_platform])\n\nif test \"$with_platform\" = \"win32\"; then\n  AC_CHECK_TOOL([WINDRES],[windres])\n  AC_MSG_CHECKING([for native Win32])\n  case \"$host\" in\n    *-*-mingw*)\n      os_win32=yes\n      ;;\n    *)\n      os_win32=no\n      ;;\n  esac\n  AC_MSG_RESULT([$os_win32])\n\n  AM_CFLAGS=\"$AM_CFLAGS -D_WIN32_WINNT=0x0500\"\nfi\n\nAM_CONDITIONAL([PLATFORM_WIN32],[test \"$with_platform\" = \"win32\"])\n\ndnl Specify required versions of dependencies\nCAIRO_REQUIRED=1.10.0\nGLIB_REQUIRED=2.36.0\nLIBSECRET_REQUIRED=0.5\nGTK_REQUIRED=3.16.0\nNAUTILUS_REQUIRED=2.91.4\n\nAC_SUBST([GLIB_REQUIRED])\nAC_SUBST([GTK_REQUIRED])\n\nAC_DEFINE([GDK_VERSION_MIN_REQUIRED], [GDK_VERSION_3_8], [Minimum GTK/GDK version required])\n\nADWAITA_ICON_THEME_REQUIRED=2.17.1\nLIBXML_REQUIRED=2.5.0\n\ndnl Check dependencies\n\n# LIB_CFLAGS       for helpers and generic widgets. (libdocument, cut-and-paste)\n# BACKEND_CFLAGS   for backend implementations.\n# FRONTEND_CFLAGS  for frontend implementations. (properties, thumbnailer)\n# FRONTEND_LIBS\n# SHELL_CFLAGS     for shell implementation.\n# SHELL_LIBS\n\nhave_zlib=yes\nAC_CHECK_HEADERS([zlib.h],\n\t[AC_CHECK_LIB([z], [inflate],\n\t\t[AC_CHECK_LIB([z], [crc32], [have_zlib=yes], [have_zlib=no])],\n\t\t[have_zlib=no])],\n\t[have_zlib=no])\n\nif test x$have_zlib = xno; then\n\tAC_MSG_ERROR([No sufficient zlib library found on your system.])\nfi\n\nZLIB_LIBS=-lz\nAC_SUBST(ZLIB_LIBS)\n\nPKG_CHECK_MODULES(LIBDOCUMENT, gtk+-3.0 >= $GTK_REQUIRED gio-2.0 >= $GLIB_REQUIRED gmodule-no-export-2.0 >= $GLIB_REQUIRED gmodule-2.0)\nPKG_CHECK_MODULES(LIBVIEW, gtk+-3.0 >= $GTK_REQUIRED gthread-2.0 gio-2.0 >= $GLIB_REQUIRED)\nPKG_CHECK_MODULES(BACKEND, cairo >= $CAIRO_REQUIRED gtk+-3.0 >= $GTK_REQUIRED)\nPKG_CHECK_MODULES(FRONTEND_CORE, gtk+-3.0 >= $GTK_REQUIRED gthread-2.0 gio-2.0 >= $GLIB_REQUIRED gmodule-no-export-2.0 >= $GLIB_REQUIRED)\n\n# Although GTK+ 3.10 includes hi-dpi functionality, it does not require a cairo with\n# cairo_surface_set_device_scale(), which we also need if we're to support hi-dpi,\n# so we need check for that explicity.\n\nevince_save_LIBS=$LIBS\nLIBS=\"$LIBS $LIBVIEW_LIBS\"\nAC_CHECK_FUNCS(cairo_surface_set_device_scale)\nLIBS=$evince_save_LIBS\n\nAC_MSG_CHECKING([for hi-dpi support])\nif test \"$ac_cv_func_cairo_surface_set_device_scale\" = yes ; then\n   AC_DEFINE([HAVE_HIDPI_SUPPORT], [1], [Define if cairo and GTK+ have necessary functions for hi-dpi])\n   AC_MSG_RESULT([yes])\nelse\n   AC_MSG_RESULT([no])\nfi\n\n\n# Check if GTK+ version is older than 3.20 to use different CSS.\nAM_CONDITIONAL([HAVE_GTK_320],[$($PKG_CONFIG --atleast-version=3.20.0 gtk+-3.0)])\n\nSHELL_PLATFORM_PKGS=\ncase \"$with_platform\" in\n  gnome)\n        # Evince has a rather soft run-time dependency on hicolor-icon-theme.\n        # If the hicolor theme is not available, Evince fails to display some\n        # icons. Because we cannot check for it at run-time, we instead\n        # would like to require the icon theme at compile-time. But, because\n        # the hicolor-icon-theme does not have a pkgconfig file, on gnome we\n        # require the gnome icon theme instead.\n        SHELL_PLATFORM_PKGS=\"adwaita-icon-theme >= $ADWAITA_ICON_THEME_REQUIRED\"\n        ;;\n  *)\n        # On all other platforms we issue a warning about the runtime\n        # dependency.\n        AC_MSG_WARN([Evince has a soft run-time dependency on hicolor-icon-theme. You are advised to have this theme installed when running Evince.]);\n        SHELL_PLATFORM_PKGS=\"\"\n        ;;\nesac\n\nPKG_CHECK_MODULES([SHELL_CORE],[libxml-2.0 >= $LIBXML_REQUIRED gtk+-3.0 >= $GTK_REQUIRED gio-2.0 >= $GLIB_REQUIRED gmodule-no-export-2.0 >= $GLIB_REQUIRED gthread-2.0 $SHELL_PLATFORM_PKGS])\n\n# ***************\n# Build utilities\n# ***************\n\nAC_ARG_VAR([GLIB_GENMARSHAL],[the glib-genmarschal programme])\nAC_PATH_PROG([GLIB_GENMARSHAL],[glib-genmarshal],[])\nif test -z \"$GLIB_GENMARSHAL\"; then\n  AC_MSG_ERROR([glib-genmarshal not found])\nfi\n\nAC_ARG_VAR([GLIB_MKENUMS],[the glib-mkenums programme])\nAC_PATH_PROG([GLIB_MKENUMS],[glib-mkenums],[])\nif test -z \"$GLIB_MKENUMS\"; then\n  AC_MSG_ERROR([glib-mkenums not found])\nfi\n\nAC_ARG_VAR([GLIB_COMPILE_RESOURCES],[the glib-compile-resources programme])\nAC_PATH_PROG([GLIB_COMPILE_RESOURCES],[glib-compile-resources],[])\nif test -z \"$GLIB_COMPILE_RESOURCES\"; then\n  AC_MSG_ERROR([glib-compile-resources not found])\nfi\n\nAC_ARG_VAR([XMLLINT],[the xmllint programme])\nAC_PATH_PROG([XMLLINT],[xmllint],[])\nif test -z \"$XMLLINT\"; then\n  AC_MSG_ERROR([xmllint not found])\nfi\n\nAC_ARG_VAR([GDBUS_CODEGEN],[the gdbus-codegen programme])\nAC_PATH_PROG([GDBUS_CODEGEN],[gdbus-codegen],[])\nif test -z \"$GDBUS_CODEGEN\"; then\n  AC_MSG_ERROR([gdbus-codegen not found])\nfi\n\n# ***\n\nBACKEND_LIBTOOL_FLAGS=\"-module -avoid-version -no-undefined -export-symbols \\$(top_srcdir)/backend/backend.symbols\"\nAC_SUBST(BACKEND_LIBTOOL_FLAGS)\n\ndnl ===== Check special functions\nevince_save_LIBS=$LIBS\nLIBS=\"$LIBS $BACKEND_LIBS\"\nAC_CHECK_FUNCS(cairo_format_stride_for_width)\nLIBS=$evince_save_LIBS\n\n# ******************\n# GKT+ Unix Printing\n# ******************\n\nAC_MSG_CHECKING([whether gtk+-unix-print support is requested])\nAC_ARG_WITH([gtk-unix-print],\n  [AS_HELP_STRING([--without-gtk-unix-print],\n\t\t  [Disable the use of gtk-unix-print])],\n  [],[case \"$os_win32\" in\n        yes) with_gtk_unix_print=no ;;\n        *) with_gtk_unix_print=yes ;;\n      esac])\n      \nAC_MSG_RESULT([$with_gtk_unix_print])\n\nif test \"$with_gtk_unix_print\" = \"yes\"; then\n   PKG_CHECK_MODULES(GTKUNIXPRINT, [gtk+-unix-print-3.0 >= $GTK_REQUIRED])\n   AC_DEFINE([GTKUNIXPRINT_ENABLED], [1], [Define if gtk+-unix-print is enabled.])\nfi\n\n# *********************\n# GNOME Keyring support\n# *********************\n\nAC_ARG_WITH(keyring,\n        [AS_HELP_STRING([--without-keyring],\n\t\t\t[Disable the use of gnome-keyring])],\n        [],\n        [case \"$with_platform\" in\n           gnome) with_keyring=yes ;;\n           win32) with_keyring=no ;;\n         esac])\n\nAM_CONDITIONAL([WITH_KEYRING],[test \"$with_keyring\" = \"yes\"])\n\nif test \"$with_keyring\" = \"yes\"; then\n        PKG_CHECK_MODULES(LIBSECRET, libsecret-1 >= $LIBSECRET_REQUIRED)\n        AC_DEFINE([WITH_KEYRING],[1],[Define if KEYRING support is enabled])\nfi\n\n# ****\n# DBUS\n# ****\n\nAC_ARG_ENABLE([dbus],\n  [AS_HELP_STRING([--disable-dbus], [Disable support for dbus])],\n  [],\n  [case \"$with_platform\" in\n      gnome) enable_dbus=yes ;;\n    esac])\n\nif test \"$enable_dbus\" = \"yes\"; then\n  AC_DEFINE([ENABLE_DBUS],[1],[Define if DBUS support is enabled])\n\n   PKG_CHECK_MODULES([EV_DAEMON], [gio-2.0 >= $GLIB_REQUIRED gio-unix-2.0])\nfi\n\nAM_CONDITIONAL([ENABLE_DBUS], [test \"$enable_dbus\" = \"yes\"])\n\n# It is correct for this to be in ${prefix}/lib, even on systems where that\n# does not match ${libdir}. This is what systemd uses on such platforms.\nAC_ARG_WITH([systemduserunitdir],\n\tAS_HELP_STRING([--with-systemduserunitdir=PATH],\n\t[Set directory for systemd user units, or 'no' to disable]\n\t[[default=${prefix}/lib/systemd/user]]),\n\t[systemd_userdir=\"$withval\"],\n\t[systemd_userdir='${prefix}/lib/systemd/user'])\nAC_SUBST([systemd_userdir])\nAM_CONDITIONAL([WITH_SYSTEMD_USER_UNITS], [test \"x$systemd_userdir\" != \"xno\"])\n\n# *******************************\n# GNOME Desktop (Thumbnail cache)\n# *******************************\n\nAC_ARG_ENABLE([libgnome-desktop],\n        [AS_HELP_STRING([--disable-libgnome-desktop], [Disable GNOME Desktop (Thumbnail cache)])],\n        [enable_gnome_desktop=$enableval],\n        [enable_gnome_desktop=auto])\n\nif test \"$enable_gnome_desktop\" != \"no\"; then\n   if test \"$enable_gnome_desktop\" = \"auto\"; then\n      PKG_CHECK_MODULES([LIBGNOME_DESKTOP], [gnome-desktop-3.0], has_libgnome_desktop=yes, has_libgnome_desktop=no)\n   else\n      PKG_CHECK_MODULES([LIBGNOME_DESKTOP], [gnome-desktop-3.0])\n      has_libgnome_desktop=yes\n   fi\n\n   if test x$has_libgnome_desktop = xyes; then\n      AC_DEFINE([HAVE_LIBGNOME_DESKTOP], [1], [Whether GNOME Desktop (Thumbnail cache) is available])\n      enable_gnome_desktop=yes\n   else\n      enable_gnome_desktop=no\n   fi\nfi\n\n# **********************\n# GStreamer (Multimedia)\n# **********************\n\nAC_ARG_ENABLE([multimedia],\n        [AS_HELP_STRING([--disable-multimedia], [Disable Multimedia support])],\n        [enable_multimedia=$enableval],\n        [enable_multimedia=auto])\n\nif test \"$enable_multimedia\" != \"no\"; then\n   if test \"$enable_multimedia\" = \"auto\"; then\n      PKG_CHECK_MODULES([GSTREAMER], [gstreamer-1.0 gstreamer-base-1.0 gstreamer-video-1.0], has_gstreamer=yes, has_gstreamer=no)\n   else\n      PKG_CHECK_MODULES([GSTREAMER], [gstreamer-1.0 gstreamer-base-1.0 gstreamer-video-1.0])\n      has_gstreamer=yes\n   fi\n\n   if test x$has_gstreamer = xyes; then\n      AC_DEFINE([ENABLE_MULTIMEDIA], [1], [Whether multimedia support is enabled])\n      enable_multimedia=yes\n   else\n      enable_multimedia=no\n   fi\nfi\n\nAM_CONDITIONAL([ENABLE_MULTIMEDIA], [test \"$enable_multimedia\" = \"yes\"])\n\ndnl ========= Check for Desktop Schemas\nPKG_CHECK_MODULES([DESKTOP_SCHEMAS], [gsettings-desktop-schemas],\n                  has_desktop_schemas=yes, has_desktop_schemas=no)\nif test x$has_desktop_schemas = xyes; then\n   AC_DEFINE([HAVE_DESKTOP_SCHEMAS], [1], [Whether GSettings Desktop Schemas are available])\nfi\n\ndnl Debug mode\n\nAC_ARG_ENABLE([debug],\n\tAS_HELP_STRING([--enable-debug],\n\t\t       [Turn on evince debug mode]),\n\t[enable_debug=$enableval],\n\t[enable_debug=no])\n\nif test \"x$enable_debug\" = \"xyes\"; then\n   DEBUG_FLAGS=\"-DEV_ENABLE_DEBUG\"\nfi\n\nLIBDOCUMENT_CFLAGS=\"$LIBDOCUMENT_CFLAGS $DEBUG_FLAGS\"\nLIBDOCUMENT_LIBS=\"$LIBDOCUMENT_LIBS\"\nAC_SUBST(LIBDOCUMENT_CFLAGS)\nAC_SUBST(LIBDOCUMENT_LIBS)\n\nLIBVIEW_CFLAGS=\"$LIBVIEW_CFLAGS $GTKUNIXPRINT_CFLAGS $GSTREAMER_CFLAGS $DEBUG_FLAGS\"\nLIBVIEW_LIBS=\"$LIBVIEW_LIBS $GTKUNIXPRINT_LIBS $GSTREAMER_LIBS -lm\"\nAC_SUBST(LIBVIEW_CFLAGS)\nAC_SUBST(LIBVIEW_LIBS)\n\nBACKEND_CFLAGS=\"$BACKEND_CFLAGS -DGDK_MULTIHEAD_SAFE -DGTK_MULTIHEAD_SAFE $DEBUG_FLAGS\"\nBACKEND_LIBS=\"$BACKEND_LIBS -lm\"\nAC_SUBST(BACKEND_CFLAGS)\nAC_SUBST(BACKEND_LIBS)\n\nSHELL_CFLAGS=\"$SHELL_CORE_CFLAGS $LIBSECRET_CFLAGS -DGDK_MULTIHEAD_SAFE -DGTK_MULTIHEAD_SAFE $DEBUG_FLAGS $LIBGNOME_DESKTOP_CFLAGS\"\nSHELL_LIBS=\"$SHELL_CORE_LIBS $LIBSECRET_LIBS $LIBGNOME_DESKTOP_LIBS -lz -lm\"\nAC_SUBST(SHELL_CFLAGS)\nAC_SUBST(SHELL_LIBS)\n\nFRONTEND_CFLAGS=\"$FRONTEND_CORE_CFLAGS $DEBUG_FLAGS\"\nFRONTEND_LIBS=\"$FRONTEND_CORE_LIBS -lz\"\nAC_SUBST(FRONTEND_CFLAGS)\nAC_SUBST(FRONTEND_LIBS)\n\nEV_DAEMON_CFLAGS=\"$EV_DAEMON_CFLAGS $DEBUG_FLAGS\"\nAC_SUBST([EV_DAEMON_CFLAGS])\nAC_SUBST([EV_DAEMON_LIBS])\n\n# Check for Nautilus property page build\nAC_ARG_ENABLE([nautilus],\n  [AS_HELP_STRING([--disable-nautilus],\n\t\t  [Disable build of nautilus extensions])],\n  [],\n  [case \"$with_platform\" in\n     gnome) enable_nautilus=yes ;;\n     *) enable_nautilus=no ;;\n    esac])\n\nif test \"$enable_nautilus\" = \"yes\" ; then\n  PKG_CHECK_MODULES([NAUTILUS],[gtk+-3.0 $MM gthread-2.0 libnautilus-extension >= $NAUTILUS_REQUIRED],\n                    [],[AC_MSG_ERROR([libnautilus-extension not found; use --disable-nautilus to disable the nautilus extensions])])\n  NAUTILUS_EXTENSION_DIR=`$PKG_CONFIG --variable=extensiondir libnautilus-extension`\n  NAUTILUS_EXTENSION_DIR=${NAUTILUS_EXTENSION_DIR#`$PKG_CONFIG --variable=libdir libnautilus-extension`}\n  NAUTILUS_EXTENSION_DIR=${NAUTILUS_EXTENSION_DIR#/}\n  AC_SUBST(NAUTILUS_EXTENSION_DIR)\n  AC_SUBST(NAUTILUS_CFLAGS)\n  AC_SUBST(NAUTILUS_LIBS)\n\n  AC_DEFINE([HAVE_NAUTILUS],[1], [defined if you build the nautilus plugin])\nfi\n\nAM_CONDITIONAL([ENABLE_NAUTILUS],[test \"$enable_nautilus\" = \"yes\"])\n\n# ***************\n# Document Viewer\n# ***************\n\nAC_ARG_ENABLE(\n  [viewer],\n  [AS_HELP_STRING([--disable-viewer], [Disable GNOME Document viewer])],\n  [],\n  [enable_viewer=yes]\n)\nAM_CONDITIONAL([ENABLE_VIEWER],[test \"$enable_viewer\" = \"yes\"])\n\n# ***************\n# Thumbnailer\n# ***************\n\nAC_ARG_ENABLE([thumbnailer],\n  [AS_HELP_STRING([--disable-thumbnailer],\n\t\t  [Disable GNOME thumbnailer])],\n  [],\n  [enable_thumbnailer=yes])\n\nAM_CONDITIONAL([ENABLE_THUMBNAILER],[test \"$enable_thumbnailer\" = \"yes\"])\n\n# ***************\n# Print Previewer\n# ***************\n\nAC_ARG_ENABLE([previewer],\n  [AS_HELP_STRING([--disable-previewer],\n\t\t  [Disable the GNOME Document Previewer])],\n  [],\n  [enable_previewer=yes])\n\nif test x$enable_previewer = \"xyes\" ; then\n  PKG_CHECK_MODULES([PREVIEWER],[gtk+-3.0 >= $GTK_REQUIRED gthread-2.0 gio-2.0 >= $GLIB_REQUIRED gmodule-no-export-2.0 >= $GLIB_REQUIRED])\nfi\n\nAM_CONDITIONAL([ENABLE_PREVIEWER],[test \"$enable_previewer\" = \"yes\"])\nPREVIEWER_CFLAGS=\"$PREVIEWER_CFLAGS $GTKUNIXPRINT_CFLAGS $DEBUG_FLAGS\"\nPREVIEWER_LIBS=\"$PREVIEWER_LIBS $GTKUNIXPRINT_LIBS -lz\"\nAC_SUBST(PREVIEWER_CFLAGS)\nAC_SUBST(PREVIEWER_LIBS)\n\n\n# **************\n# Browser Plugin\n# **************\n\nAC_ARG_ENABLE([browser-plugin],\n  [AS_HELP_STRING([--disable-browser-plugin],\n                  [Disable the Browser Plugin])],\n  [],\n  [enable_browser_plugin=yes])\n\nif test x$enable_browser_plugin = \"xyes\" ; then\n  PKG_CHECK_MODULES([BROWSER_PLUGIN],[gtk+-3.0 >= $GTK_REQUIRED gthread-2.0 gio-2.0 >= $GLIB_REQUIRED])\n\n  if test -z \"${BROWSER_PLUGIN_DIR}\"; then\n    BROWSER_PLUGIN_DIR=\"\\${libdir}/mozilla/plugins\"\n  fi\n  AC_ARG_VAR([BROWSER_PLUGIN_DIR],[Where to install the plugin to])\nfi\n\nAM_CONDITIONAL([ENABLE_BROWSER_PLUGIN],[test \"$enable_browser_plugin\" = \"yes\"])\nBROWSER_PLUGIN_CFLAGS=\"$BROWSER_PLUGIN_CFLAGS $DEBUG_FLAGS\"\nAC_SUBST(BROWSER_PLUGIN_CFLAGS)\nAC_SUBST(BROWSER_PLUGIN_LIBS)\n\n# ***\n# GIR\n# ***\n\n# No automagic please!\nif test -z \"$enable_introspection\"; then\n  enable_introspection=no\nfi\n\nGOBJECT_INTROSPECTION_CHECK([1.0])\n\ndnl ================== portability checks ===========================================\n\ndnl for backtrace()\nAC_CHECK_HEADERS([execinfo.h])\n\nAC_CHECK_DECL([_NL_MEASUREMENT_MEASUREMENT],[\n  AC_DEFINE([HAVE__NL_MEASUREMENT_MEASUREMENT],[1],[Define if _NL_MEASUREMENT_MEASUREMENT is available])\n  ],[],[#include <langinfo.h>])\n\ndnl ================== pdf checks ===================================================\nAC_ARG_ENABLE([pdf],\n  [AS_HELP_STRING([--disable-pdf],\n\t\t  [Disable the PDF support])],\n  [enable_pdf=$enableval],\n  [enable_pdf=yes])\n\nif test \"x$enable_pdf\" = \"xyes\"; then\n    POPPLER_REQUIRED=0.33.0\n    PKG_CHECK_MODULES(POPPLER, poppler-glib >= $POPPLER_REQUIRED libxml-2.0 >= $LIBXML_REQUIRED,enable_pdf=yes,enable_pdf=no)\n\n    if test \"x$enable_pdf\" = \"xyes\"; then\n\t    PKG_CHECK_MODULES(CAIRO_PDF, cairo-pdf, enable_cairo_pdf=yes, enable_cairo_pdf=no)\n\t    if test x$enable_cairo_pdf = xyes; then\n\t            AC_DEFINE([HAVE_CAIRO_PDF], [1], [defined if cairo-pdf is available])\n            fi\n\n\t    PKG_CHECK_MODULES(CAIRO_PS, cairo-ps, enable_cairo_ps=yes, enable_cairo_ps=no)\n\t    if test x$enable_cairo_ps = xyes; then\n\t            AC_DEFINE([HAVE_CAIRO_PS], [1], [defined if cairo-ps is available])\n            fi\n    else\n\t    AC_MSG_ERROR(\"PDF support is disabled since poppler-glib library version $POPPLER_REQUIRED or newer not found\")\n    fi \nfi\n\nAM_CONDITIONAL(ENABLE_PDF, test x$enable_pdf = xyes)\ndnl ================== end of pdf checks ============================================\n\ndnl libspectre (used by ps and dvi backends)\nSPECTRE_REQUIRED=0.2.0 \nPKG_CHECK_MODULES(SPECTRE, libspectre >= $SPECTRE_REQUIRED,have_spectre=yes,have_spectre=no)\nAM_CONDITIONAL(HAVE_SPECTRE, test x$have_spectre = xyes)\nif test \"x$have_spectre\" = \"xyes\"; then\n   AC_DEFINE([HAVE_SPECTRE], [1], [Have libspectre])\nfi\n\ndnl ================== ps checks ====================================================\nAC_ARG_ENABLE(ps,\n  \t[AS_HELP_STRING([--disable-ps],\n\t\t\t[Disable the PostScript backend])],\n\t[enable_ps=$enableval],\n\t[enable_ps=yes])\n\nif test \"x$enable_ps\" = \"xyes\"; then\n   if test \"x$have_spectre\" = \"xyes\"; then\n      AC_DEFINE([ENABLE_PS], [1], [Enable support for PostScript files.])\n   else\n      enable_ps=\"no\"\n      AC_MSG_WARN([PS support is disabled since libspectre (version >= $SPECTRE_REQUIRED) is needed])\n   fi\nfi\nAM_CONDITIONAL(ENABLE_PS, test x$enable_ps = xyes)\ndnl ======================== End of ps checks ===================================\n\ndnl ================== tiff checks ===================================================\nAC_ARG_ENABLE(tiff,\n            [AS_HELP_STRING([--disable-tiff],\n\t\t\t    [Disable the support of multipage tiff])],\n\t    [enable_tiff=$enableval],\n\t    [enable_tiff=yes])\n\nif test \"x$enable_tiff\" = \"xyes\"; then\n    AC_CHECK_HEADERS([tiff.h],enable_tiff=yes,enable_tiff=no,)\n    if test \"x$enable_tiff\" = \"xyes\"; then\n\tAC_CHECK_LIB([tiff],TIFFOpen,enable_tiff=yes,enable_tiff=no,\"-lz\")\n        AC_CHECK_LIB([tiff],TIFFReadRGBAImageOriented,enable_tiff=yes,enable_tiff=no,\"-lz\")\n    fi\n    if test \"x$enable_tiff\" = \"xyes\"; then\n\t    AC_DEFINE([ENABLE_TIFF], [1], [Enable multipage tiff support.])\n    else\n\t    AC_MSG_WARN(\"Tiff support is disabled since tiff library version 3.6 or newer not found\")\n    fi \nfi\n\nAM_CONDITIONAL(ENABLE_TIFF, test x$enable_tiff = xyes)\ndnl ================== end of tiff checks ============================================\n\ndnl ================== djvu checks ===================================================\n\nAC_ARG_ENABLE(djvu,\n            [AS_HELP_STRING([--disable-djvu],\n\t\t\t    [Disable the support of djvu viewer])],\n\t    [enable_djvu=$enableval],\n\t    [enable_djvu=yes])\n\nif test \"x$enable_djvu\" = \"xyes\"; then\n    DJVULIBRE_REQUIRED=3.5.22\n    PKG_CHECK_MODULES(DJVU, ddjvuapi >= $DJVULIBRE_REQUIRED, enable_djvu=yes, enable_djvu=no)\n\n    if test \"x$enable_djvu\" = \"xyes\"; then\n        AC_DEFINE([ENABLE_DJVU], [1], [Enable djvu viewer support.])\n    else\n\tAC_MSG_WARN([\t\n** Djvu support is disabled since a recent version of the djvulibre \n** library was not found. You need at least djvulibre-3.5.22 which\n** can be found on http://djvulibre.djvuzone.org \n])\n    fi \nfi\n\nAM_CONDITIONAL(ENABLE_DJVU, test x$enable_djvu = xyes)\n\ndnl ================== End of djvu checks ===================================================\n\ndnl ================== dvi checks ===================================================\n\nAC_ARG_ENABLE(dvi,\n            [AS_HELP_STRING([--disable-dvi],\n\t    [Disable the support of dvi viewer])],\n\t    [enable_dvi=$enableval],\n\t    [enable_dvi=yes])\n\nAC_ARG_ENABLE(t1lib,\n            [AS_HELP_STRING([--enable-t1lib],\n\t                    [Compile with support of t1lib for type1 fonts in dvi])],\n\t    [enable_type1_fonts=$enableval],\n\t    [enable_type1_fonts=no])\n\nif test \"x$enable_dvi\" = \"xyes\"; then\n    AC_C_CONST\n    AC_C_INLINE\n    AC_TYPE_SIZE_T\n    AC_CHECK_SIZEOF(long, 4)\n    AC_CHECK_SIZEOF(int, 4)\n    AC_CHECK_SIZEOF(short, 2)\n    AC_CHECK_SIZEOF(long long, 4)\n    AC_CHECK_SIZEOF(void *, 4)\n    AC_CHECK_LIB([kpathsea],[kpse_init_prog],[enable_dvi=yes],[enable_dvi=no])\n\n    if test \"x$enable_dvi\" = \"xyes\"; then\n\tAC_DEFINE([ENABLE_DVI], [1], [Enable dvi viewer support.])\n    else\n        AC_MSG_WARN(\"Dvi support is disabled since kpathsea library is not found. Check your TeX installation.\")\n    fi\nfi\nAM_CONDITIONAL(ENABLE_DVI, test x$enable_dvi = xyes)\n\nif test \"x$enable_dvi\" = \"xyes\"; then\n    if test \"x$enable_type1_fonts\" = \"xyes\"; then\n\tAC_CHECK_LIB([t1],T1_InitLib,enable_type1_fonts=yes,enable_type1_fonts=no,[-lm])\n    fi\n\n    if test \"x$enable_type1_fonts\" = xyes; then\n        AC_DEFINE([WITH_TYPE1_FONTS], [1], [Enable t1lib support in dvi.])\n    fi\nelse \n    enable_type1_fonts=no\nfi\nAM_CONDITIONAL(WITH_TYPE1_FONTS, test x$enable_type1_fonts = xyes)\n\ndnl ================== End of dvi checks ===================================================\n\ndnl ================== comic book checks ===================================================\n \nAC_ARG_ENABLE(comics,\n \t[AS_HELP_STRING([--enable-comics],\n\t                [Compile with support for comic book archives])],\n\t[enable_comics=$enableval],\n\t[enable_comics=yes])\n\t\nif test \"x$enable_comics\" = \"xyes\"; then\n\tAC_DEFINE([ENABLE_COMICS], [1], [Enable support for comics.])\nfi\nAM_CONDITIONAL(ENABLE_COMICS, test x$enable_comics = xyes)\n\ndnl ================== End of comic book checks ============================================\n\ndnl ================== XPS checks ===================================================\n\nAC_ARG_ENABLE(xps,\n\t[AS_HELP_STRING([--enable-xps],\n\t\t\t[Compile with support for XPS documents.])],\n\t[enable_xps=$enableval],\n\t[enable_xps=yes])\n\nif test \"x$enable_xps\" = \"xyes\"; then\n   GXPS_REQUIRED=0.2.1\n   PKG_CHECK_MODULES(GXPS, libgxps >= $GXPS_REQUIRED,enable_xps=yes,enable_xps=no)\n\n   if test \"x$enable_xps\" = \"xyes\"; then\n      AC_DEFINE([ENABLE_XPS], [1], [Enable support for XPS documents.])\n   else\n      enable_xps=\"no\"\n      AC_MSG_WARN([XPS support is disabled since libgxps (version >= $GXPS_REQUIRED) is needed])\n   fi\nfi\n\nAM_CONDITIONAL(ENABLE_XPS, test x$enable_xps = xyes)\n\ndnl ================== End of XPS checks ===================================================\n\ndnl =================== Compile warnings ===================================================\n\nGNOME_COMPILE_WARNINGS\n\nCC_CHECK_FLAGS_APPEND([AM_CFLAGS],[CFLAGS],[ \\\n])\n\nAM_CFLAGS=\"$AM_CFLAGS $WARN_CFLAGS\"\nAM_CXXFLAGS=\"$AM_CXXFLAGS $WARN_CXXFLAGS\"\n\ndnl =================== End of compile warnings=============================================\n\ndnl =================== Mime types list ====================================================\n\nif test \"x$enable_pdf\" = \"xyes\" ; then\n        PDF_MIME_TYPES=\"application/pdf;application/x-bzpdf;application/x-gzpdf;application/x-xzpdf;application/x-ext-pdf\"\n        APPDATA_PDF_MIME_TYPES=$(echo \"<mimetype>$PDF_MIME_TYPES</mimetype>\" | sed -e 's/;/<\\/mimetype>\\n    <mimetype>/g')\n        if test -z \"$EVINCE_MIME_TYPES\"; then\n           EVINCE_MIME_TYPES=\"${PDF_MIME_TYPES}\"\n        else\n           EVINCE_MIME_TYPES=\"${EVINCE_MIME_TYPES};${PDF_MIME_TYPES}\"\n        fi\nfi\nAC_SUBST(PDF_MIME_TYPES)\nAC_SUBST(APPDATA_PDF_MIME_TYPES)\nAM_SUBST_NOTMAKE(APPDATA_PDF_MIME_TYPES)\nif test \"x$enable_ps\" = \"xyes\" ; then\n        PS_MIME_TYPES=\"application/postscript;application/x-bzpostscript;application/x-gzpostscript;image/x-eps;image/x-bzeps;image/x-gzeps;application/x-ext-ps;application/x-ext-eps\"\n        APPDATA_PS_MIME_TYPES=$(echo \"<mimetype>$PS_MIME_TYPES</mimetype>\" | sed -e 's/;/<\\/mimetype>\\n    <mimetype>/g')\n        if test -z \"$EVINCE_MIME_TYPES\"; then\n           EVINCE_MIME_TYPES=\"${PS_MIME_TYPES}\"\n        else\n           EVINCE_MIME_TYPES=\"${EVINCE_MIME_TYPES};${PS_MIME_TYPES}\"\n        fi\nfi\nAC_SUBST(PS_MIME_TYPES)\nAC_SUBST(APPDATA_PS_MIME_TYPES)\nAM_SUBST_NOTMAKE(APPDATA_PS_MIME_TYPES)\nif test \"x$enable_dvi\" = \"xyes\"; then\n        DVI_MIME_TYPES=\"application/x-dvi;application/x-bzdvi;application/x-gzdvi;application/x-ext-dvi\"\n        APPDATA_DVI_MIME_TYPES=$(echo \"<mimetype>$DVI_MIME_TYPES</mimetype>\" | sed -e 's/;/<\\/mimetype>\\n    <mimetype>/g')\n        if test -z \"$EVINCE_MIME_TYPES\"; then\n           EVINCE_MIME_TYPES=\"${DVI_MIME_TYPES}\"\n        else\n           EVINCE_MIME_TYPES=\"${EVINCE_MIME_TYPES};${DVI_MIME_TYPES}\"\n        fi\nfi\nAC_SUBST(DVI_MIME_TYPES)\nAC_SUBST(APPDATA_DVI_MIME_TYPES)\nAM_SUBST_NOTMAKE(APPDATA_DVI_MIME_TYPES)\nif test \"x$enable_djvu\" = \"xyes\"; then\n        DJVU_MIME_TYPES=\"image/vnd.djvu;image/vnd.djvu+multipage;application/x-ext-djv;application/x-ext-djvu\"\n        APPDATA_DJVU_MIME_TYPES=$(echo \"<mimetype>$DJVU_MIME_TYPES</mimetype>\" | sed -e 's/;/<\\/mimetype>\\n    <mimetype>/g')\n        if test -z \"$EVINCE_MIME_TYPES\"; then\n           EVINCE_MIME_TYPES=\"${DJVU_MIME_TYPES}\"\n        else\n           EVINCE_MIME_TYPES=\"${EVINCE_MIME_TYPES};${DJVU_MIME_TYPES}\"\n        fi\nfi\nAC_SUBST(DJVU_MIME_TYPES)\nAC_SUBST(APPDATA_DJVU_MIME_TYPES)\nAM_SUBST_NOTMAKE(APPDATA_DJVU_MIME_TYPES)\nif test \"x$enable_tiff\" = \"xyes\"; then\n        TIFF_MIME_TYPES=\"image/tiff\"\n        APPDATA_TIFF_MIME_TYPES=$(echo \"<mimetype>$TIFF_MIME_TYPES</mimetype>\" | sed -e 's/;/<\\/mimetype>\\n    <mimetype>/g')\n        if test -z \"$EVINCE_MIME_TYPES\"; then\n           EVINCE_MIME_TYPES=\"${TIFF_MIME_TYPES}\"\n        else\n           EVINCE_MIME_TYPES=\"${EVINCE_MIME_TYPES};${TIFF_MIME_TYPES}\"\n        fi\nfi\nAC_SUBST(TIFF_MIME_TYPES)\nAC_SUBST(APPDATA_TIFF_MIME_TYPES)\nAM_SUBST_NOTMAKE(APPDATA_TIFF_MIME_TYPES)\nif test \"x$enable_comics\" = \"xyes\"; then\n        COMICS_MIME_TYPES=\"application/x-cbr;application/x-cbz;application/x-cb7;application/x-cbt;application/x-ext-cbr;application/x-ext-cbz;application/vnd.comicbook+zip;application/x-ext-cb7;application/x-ext-cbt\"\n        APPDATA_COMICS_MIME_TYPES=$(echo \"<mimetype>$COMICS_MIME_TYPES</mimetype>\" | sed -e 's/;/<\\/mimetype>\\n    <mimetype>/g')\n        if test -z \"$EVINCE_MIME_TYPES\"; then\n           EVINCE_MIME_TYPES=\"${COMICS_MIME_TYPES}\"\n        else\n           EVINCE_MIME_TYPES=\"${EVINCE_MIME_TYPES};${COMICS_MIME_TYPES}\"\n        fi\nfi\nAC_SUBST(COMICS_MIME_TYPES)\nAC_SUBST(APPDATA_COMICS_MIME_TYPES)\nAM_SUBST_NOTMAKE(APPDATA_COMICS_MIME_TYPES)\nif test \"x$enable_xps\" = \"xyes\"; then\n        XPS_MIME_TYPES=\"application/oxps;application/vnd.ms-xpsdocument\"\n        APPDATA_XPS_MIME_TYPES=$(echo \"<mimetype>$XPS_MIME_TYPES</mimetype>\" | sed -e 's/;/<\\/mimetype>\\n    <mimetype>/g')\n        if test -z \"$EVINCE_MIME_TYPES\"; then\n           EVINCE_MIME_TYPES=\"${XPS_MIME_TYPES}\"\n        else\n           EVINCE_MIME_TYPES=\"${EVINCE_MIME_TYPES};${XPS_MIME_TYPES}\"\n        fi\nfi\nAC_SUBST(XPS_MIME_TYPES)\nAC_SUBST(APPDATA_XPS_MIME_TYPES)\nAM_SUBST_NOTMAKE(APPDATA_XPS_MIME_TYPES)\n\nAC_SUBST(EVINCE_MIME_TYPES)\n\nAC_CHECK_FUNC(localtime_r, AC_DEFINE(HAVE_LOCALTIME_R, 1, [Defines if localtime_r is available on your system]))\n\n# *****************\n# Help files\n# *****************\n\nYELP_HELP_INIT\n\n# *****************\n# API documentation\n# *****************\n\nGTK_DOC_CHECK([1.13],[--flavour no-tmpl])\n\nAC_SUBST([GLIB_PREFIX],[$($PKG_CONFIG --variable=prefix glib-2.0)])\nAC_SUBST([GTK_PREFIX],[$($PKG_CONFIG --variable=prefix gtk+-3.0)])\n\n# ******************\n# Backends directory\n# ******************\n\nAC_SUBST([backenddir],\"\\$(libdir)/evince/ev_binary_version/backends\")\nAC_SUBST([backend_binary_version],\"ev_binary_version\")\n\n# **********\n# Versioning\n# **********\n\nAC_SUBST([EV_MAJOR_VERSION],[ev_major_version])\nAC_SUBST([EV_MINOR_VERSION],[ev_minor_version])\nAC_SUBST([EV_MICRO_VERSION],[ev_micro_version])\n\nAC_SUBST([EV_API_VERSION],[ev_api_version])\nAC_SUBST([EV_API_VERSION_U],[AS_TR_SH([ev_api_version])])\nAC_SUBST([EV_BINARY_VERSION],[ev_binary_version])\n\nAC_SUBST([EV_DOCUMENT_LT_VERSION_INFO],[ev_document_lt_version_info])\nAC_SUBST([EV_DOCUMENT_LT_CURRENT_MINUS_AGE],[ev_document_lt_current_minus_age])\nAC_SUBST([EV_VIEW_LT_VERSION_INFO],[ev_view_lt_version_info])\nAC_SUBST([EV_VIEW_LT_CURRENT_MINUS_AGE],[ev_view_lt_current_minus_age])\n\nAC_SUBST([AM_CPPFLAGS])\nAC_SUBST([AM_CFLAGS])\nAC_SUBST([AM_CXXFLAGS])\nAC_SUBST([AM_LDFLAGS])\n\n# *****************************************************************************\n# *****************************************************************************\n\nAC_CONFIG_FILES([\nbackend/Makefile\nbackend/comics/comicsdocument.evince-backend.in\nbackend/comics/evince-comicsdocument.metainfo.xml.in\nbackend/comics/Makefile\nbackend/djvu/djvudocument.evince-backend.in\nbackend/djvu/evince-djvudocument.metainfo.xml.in\nbackend/djvu/Makefile\nbackend/dvi/dvidocument.evince-backend.in\nbackend/dvi/evince-dvidocument.metainfo.xml.in\nbackend/dvi/Makefile\nbackend/dvi/mdvi-lib/Makefile\nbackend/pdf/evince-pdfdocument.metainfo.xml.in\nbackend/pdf/pdfdocument.evince-backend.in\nbackend/pdf/Makefile\nbackend/ps/evince-psdocument.metainfo.xml.in\nbackend/ps/psdocument.evince-backend.in\nbackend/ps/Makefile\nbackend/tiff/evince-tiffdocument.metainfo.xml.in\nbackend/tiff/tiffdocument.evince-backend.in\nbackend/tiff/Makefile\nbackend/xps/evince-xpsdocument.metainfo.xml.in\nbackend/xps/xpsdocument.evince-backend.in\nbackend/xps/Makefile\nbrowser-plugin/Makefile\ncut-n-paste/Makefile\ncut-n-paste/gimpcellrenderertoggle/Makefile\ncut-n-paste/synctex/Makefile\ncut-n-paste/libgd/Makefile\ndata/evince.desktop.in\ndata/evince-previewer.desktop.in\ndata/Makefile\ndata/icons/Makefile\ndata/icons/16x16/Makefile\ndata/icons/16x16/apps/Makefile\ndata/icons/16x16/actions/Makefile\ndata/icons/16x16/mimetypes/Makefile\ndata/icons/22x22/Makefile\ndata/icons/22x22/apps/Makefile\ndata/icons/22x22/actions/Makefile\ndata/icons/22x22/mimetypes/Makefile\ndata/icons/24x24/Makefile\ndata/icons/24x24/apps/Makefile\ndata/icons/24x24/actions/Makefile\ndata/icons/24x24/mimetypes/Makefile\ndata/icons/32x32/Makefile\ndata/icons/32x32/actions/Makefile\ndata/icons/32x32/mimetypes/Makefile\ndata/icons/48x48/Makefile\ndata/icons/48x48/apps/Makefile\ndata/icons/48x48/actions/Makefile\ndata/icons/256x256/Makefile\ndata/icons/256x256/apps/Makefile\ndata/icons/scalable/Makefile\ndata/icons/scalable/actions/Makefile\ndata/icons/scalable/mimetypes/Makefile\ndata/icons/symbolic/Makefile\ndata/icons/symbolic/apps/Makefile\nhelp/Makefile\nhelp/reference/Makefile\nhelp/reference/libdocument/Makefile\nhelp/reference/libdocument/version.xml\nhelp/reference/libview/Makefile\nhelp/reference/libview/version.xml\nhelp/reference/shell/Makefile\nhelp/reference/shell/version.xml\nlibdocument/Makefile\nlibdocument/ev-version.h\nlibmisc/Makefile\nlibview/Makefile\nMakefile\npo/Makefile.in\npreviewer/Makefile\nproperties/Makefile\nshell/Makefile\nthumbnailer/Makefile\n])\n\nAC_CONFIG_FILES(evince-document-[]ev_api_version[].pc:evince-document.pc.in)\nAC_CONFIG_FILES(evince-view-[]ev_api_version[].pc:evince-view.pc.in)\n\nAC_OUTPUT\n\nAC_MSG_NOTICE([\n\nEvince configure summary\n========================\n\nPlatform .................:  $with_platform\nDebug mode ...............:  $enable_debug\n\n\nFRONTENDS\n\nViewer ...................:  $enable_viewer\nPreviewer ................:  $enable_previewer\nThumbnailer ..............:  $enable_thumbnailer\nNautilus Extensions.......:  $enable_nautilus\nBrowser Plugin............:  $enable_browser_plugin\n\n\nBACKENDS\n\nPDF ......................:  $enable_pdf\nPostScript ...............:  $enable_ps\nTIFF .....................:  $enable_tiff\nDJVU .....................:  $enable_djvu\nDVI ......................:  $enable_dvi\nComics ...................:  $enable_comics\nXPS ......................:  $enable_xps\n\n\nFEATURES\n\nGTK Doc reference ........:  $enable_gtk_doc\nGObject Introspection ....:  $enable_introspection\nDBUS communication .......:  $enable_dbus\nKeyring integration ......:  $with_keyring\nGTK+ Unix Print ..........:  $with_gtk_unix_print\nThumbnail cache ..........:  $enable_gnome_desktop\nMultimedia ...............:  $enable_multimedia\n\n])\n"], "fixing_code": ["/* -*- Mode: C; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 8; c-indent-level: 8 -*- */\n/*\n * Copyright (C) 2009-2010 Juanjo Mar\u00edn <juanj.marin@juntadeandalucia.es>\n * Copyright (C) 2005, Teemu Tervo <teemu.tervo@gmx.net>\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2, or (at your option)\n * any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n */\n\n#include <config.h>\n\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <errno.h>\n\n#include <glib.h>\n#include <glib/gi18n-lib.h>\n#include <glib/gstdio.h>\n#include <gio/gio.h>\n\n#ifdef G_OS_WIN32\n# define WIFEXITED(x) ((x) != 3)\n# define WEXITSTATUS(x) (x)\n#else\n# include <sys/wait.h>\n#endif\n\n#include \"comics-document.h\"\n#include \"ev-document-misc.h\"\n#include \"ev-file-helpers.h\"\n\n#ifdef G_OS_WIN32\n/* On windows g_spawn_command_line_sync reads stdout in O_BINARY mode, not in O_TEXT mode.\n * As a consequence, newlines are in a platform dependent representation (\\r\\n). This\n * might be considered a bug in glib.\n */\n#define EV_EOL \"\\r\\n\"\n#else\n#define EV_EOL \"\\n\"\n#endif\n\ntypedef enum\n{\n\tRARLABS,\n\tGNAUNRAR,\n\tUNZIP,\n\tP7ZIP\n} ComicBookDecompressType;\n\ntypedef struct _ComicsDocumentClass ComicsDocumentClass;\n\nstruct _ComicsDocumentClass\n{\n\tEvDocumentClass parent_class;\n};\n\nstruct _ComicsDocument\n{\n\tEvDocument parent_instance;\n\n\tgchar    *archive, *dir;\n\tGPtrArray *page_names;\n\tgchar    *selected_command, *alternative_command;\n\tgchar    *extract_command, *list_command, *decompress_tmp;\n\tgboolean regex_arg;\n\tgint     offset;\n\tComicBookDecompressType command_usage;\n};\n\n#define OFFSET_7Z 53\n#define OFFSET_ZIP 2\n#define NO_OFFSET 0\n\n/* For perfomance reasons of 7z* we've choosen to decompress on the temporary \n * directory instead of decompressing on the stdout */\n\n/**\n * @extract: command line arguments to pass to extract a file from the archive\n *   to stdout.\n * @list: command line arguments to list the archive contents\n * @decompress_tmp: command line arguments to pass to extract the archive\n *   into a directory.\n * @regex_arg: whether the command can accept regex expressions\n * @offset: the position offset of the filename on each line in the output of\n *   running the @list command\n */\ntypedef struct {\n        char *extract;\n        char *list;\n        char *decompress_tmp;\n        gboolean regex_arg;\n        gint offset;\n} ComicBookDecompressCommand;\n\nstatic const ComicBookDecompressCommand command_usage_def[] = {\n        /* RARLABS unrar */\n\t{\"%s p -c- -ierr --\", \"%s vb -c- -- %s\", NULL             , FALSE, NO_OFFSET},\n\n        /* GNA! unrar */\n\t{NULL               , \"%s t %s\"        , \"%s -xf %s %s\"   , FALSE, NO_OFFSET},\n\n        /* unzip */\n\t{\"%s -p -C --\"      , \"%s %s\"          , NULL             , TRUE , OFFSET_ZIP},\n\n        /* 7zip */\n\t{NULL               , \"%s l -- %s\"     , \"%s x -y %s -o%s\", FALSE, OFFSET_7Z},\n};\n\nstatic GSList*    get_supported_image_extensions (void);\nstatic void       get_page_size_area_prepared_cb (GdkPixbufLoader *loader,\n\t\t\t\t\t\t  gpointer data);\nstatic void       render_pixbuf_size_prepared_cb (GdkPixbufLoader *loader,\n\t\t\t\t\t\t  gint width,\n\t\t\t\t\t\t  gint height,\n\t\t\t\t\t\t  EvRenderContext *rc);\nstatic char**     extract_argv                   (EvDocument *document,\n\t\t\t\t\t\t  gint page);\n\n\nEV_BACKEND_REGISTER (ComicsDocument, comics_document)\n\n/**\n * comics_regex_quote:\n * @unquoted_string: a literal string\n *\n * Quotes a string so unzip will not interpret the regex expressions of\n * @unquoted_string. Basically, this functions uses [] to disable regex \n * expressions. The return value must be freed with * g_free()\n *\n * Return value: quoted and disabled-regex string\n **/\nstatic gchar *\ncomics_regex_quote (const gchar *unquoted_string)\n{\n\tconst gchar *p;\n\tGString *dest;\n\n\tdest = g_string_new (\"'\");\n\n\tp = unquoted_string;\n\n\twhile (*p) {\n\t\tswitch (*p) {\n\t\t\t/* * matches a sequence of 0 or more characters */\n\t\t\tcase ('*'):\n\t\t\t/* ? matches exactly 1 charactere */\n\t\t\tcase ('?'):\n\t\t\t/* [...]  matches any single character found inside\n\t\t\t * the brackets. Disabling the first bracket is enough.\n\t\t\t */\n\t\t\tcase ('['):\n\t\t\t\tg_string_append (dest, \"[\");\n\t\t\t\tg_string_append_c (dest, *p);\n\t\t\t\tg_string_append (dest, \"]\");\n\t\t\t\tbreak;\n\t\t\t/* Because \\ escapes regex expressions that we are\n\t\t\t * disabling for unzip, we need to disable \\ too */\n\t\t\tcase ('\\\\'):\n\t\t\t\tg_string_append (dest, \"[\\\\\\\\]\");\n\t\t\t\tbreak;\n\t\t\t/* Escape single quote inside the string */\n\t\t\tcase ('\\''):\n\t\t\t\tg_string_append (dest, \"'\\\\''\");\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tg_string_append_c (dest, *p);\n\t\t\t\tbreak;\n\t\t}\n\t\t++p;\n\t}\n\tg_string_append_c (dest, '\\'');\n\treturn g_string_free (dest, FALSE);\n}\n\n\n/* This function manages the command for decompressing a comic book */\nstatic gboolean \ncomics_decompress_temp_dir (const gchar *command_decompress_tmp,\n\t\t\t    const gchar *command, \n\t\t\t    GError      **error)\n{\n\tgboolean success;\n\tgchar *std_out, *basename;\n\tGError *err = NULL;\n\tgint retval;\n\t\n\tsuccess = g_spawn_command_line_sync (command_decompress_tmp, &std_out, \n\t\t\t\t\t     NULL, &retval, &err);\n\tbasename = g_path_get_basename (command);\n\tif (!success) {\n\t\tg_set_error (error,\n\t\t\t     EV_DOCUMENT_ERROR, \n\t\t\t     EV_DOCUMENT_ERROR_INVALID,\n\t\t\t     _(\"Error launching the command \u201c%s\u201d in order to \"\n\t\t\t     \"decompress the comic book: %s\"),\n\t\t\t     basename,\n\t\t\t     err->message);\n\t\tg_error_free (err);\n\t} else if (WIFEXITED (retval)) {\n\t\tif (WEXITSTATUS (retval) == EXIT_SUCCESS) {\n\t\t\tg_free (std_out);\n\t\t\tg_free (basename);\n\t\t\treturn TRUE;\n\t\t} else {\n\t\t\tg_set_error (error,\n\t\t\t\t     EV_DOCUMENT_ERROR,\n\t\t\t\t     EV_DOCUMENT_ERROR_INVALID,\n\t\t\t\t     _(\"The command \u201c%s\u201d failed at \"\n\t\t\t\t     \"decompressing the comic book.\"),\n\t\t\t\t     basename);\n\t\t\tg_free (std_out);\n\t\t}\n\t} else {\n\t\tg_set_error (error,\n\t\t\t     EV_DOCUMENT_ERROR,\n\t\t\t     EV_DOCUMENT_ERROR_INVALID,\n\t\t\t     _(\"The command \u201c%s\u201d did not end normally.\"),\n\t\t\t     basename);\n\t\tg_free (std_out);\n\t}\n\tg_free (basename);\n\treturn FALSE;\n}\n\n/* This function shows how to use the chosen command for decompressing a\n * comic book file. It modifies fields of the ComicsDocument struct with \n * this information */\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wformat-nonliteral\"\nstatic gboolean \ncomics_generate_command_lines (ComicsDocument *comics_document, \n\t\t\t       GError         **error)\n{\n\tgchar *quoted_file, *quoted_file_aux;\n\tgchar *quoted_command;\n\tComicBookDecompressType type;\n\t\n\ttype = comics_document->command_usage;\n\tcomics_document->regex_arg = command_usage_def[type].regex_arg;\n\tquoted_command = g_shell_quote (comics_document->selected_command);\n\tif (comics_document->regex_arg) {\n\t\tquoted_file = comics_regex_quote (comics_document->archive);\n\t\tquoted_file_aux = g_shell_quote (comics_document->archive);\n\t\tcomics_document->list_command =\n\t\t\t   g_strdup_printf (command_usage_def[type].list,\n\t\t\t                    comics_document->alternative_command,\n\t\t\t                    quoted_file_aux);\n\t\tg_free (quoted_file_aux);\n\t} else {\n\t\tquoted_file = g_shell_quote (comics_document->archive);\n\t\tcomics_document->list_command =\n\t\t\t\tg_strdup_printf (command_usage_def[type].list,\n\t\t\t\t                 quoted_command, quoted_file);\n\t}\n\tcomics_document->extract_command =\n\t\t\t    g_strdup_printf (command_usage_def[type].extract,\n\t\t\t\t             quoted_command);\n\tcomics_document->offset = command_usage_def[type].offset;\n\tif (command_usage_def[type].decompress_tmp) {\n\t\tcomics_document->dir = ev_mkdtemp (\"evince-comics-XXXXXX\", error);\n                if (comics_document->dir == NULL)\n                        return FALSE;\n\n\t\t/* unrar-free can't create directories, but ev_mkdtemp already created the dir */\n\n\t\tcomics_document->decompress_tmp =\n\t\t\tg_strdup_printf (command_usage_def[type].decompress_tmp, \n\t\t\t\t\t quoted_command, quoted_file,\n\t\t\t\t\t comics_document->dir);\n\t\tg_free (quoted_file);\n\t\tg_free (quoted_command);\n\n\t\tif (!comics_decompress_temp_dir (comics_document->decompress_tmp,\n\t\t    comics_document->selected_command, error))\n\t\t\treturn FALSE;\n\t\telse\n\t\t\treturn TRUE;\n\t} else {\n\t\tg_free (quoted_file);\n\t\tg_free (quoted_command);\n\t\treturn TRUE;\n\t}\n\n}\n#pragma GCC diagnostic pop\n\n/* This function chooses an external command for decompressing a comic \n * book based on its mime tipe. */\nstatic gboolean \ncomics_check_decompress_command\t(gchar          *mime_type, \n\t\t\t\t ComicsDocument *comics_document,\n\t\t\t\t GError         **error)\n{\n\tgboolean success;\n\tgchar *std_out, *std_err;\n\tgint retval;\n\tGError *err = NULL;\n\t\n\t/* FIXME, use proper cbr/cbz mime types once they're\n\t * included in shared-mime-info */\n\t\n\tif (g_content_type_is_a (mime_type, \"application/x-cbr\") ||\n\t    g_content_type_is_a (mime_type, \"application/x-rar\")) {\n\t        /* The RARLAB provides a no-charge proprietary (freeware) \n\t        * decompress-only client for Linux called unrar. Another \n\t\t* option is a GPLv2-licensed command-line tool developed by \n\t\t* the Gna! project. Confusingly enough, the free software RAR \n\t\t* decoder is also named unrar. For this reason we need to add \n\t\t* some lines for disambiguation. Sorry for the added the \n\t\t* complexity but it's life :)\n\t\t* Finally, some distributions, like Debian, rename this free \n\t\t* option as unrar-free. \n\t\t* */\n\t\tcomics_document->selected_command = \n\t\t\t\t\tg_find_program_in_path (\"unrar\");\n\t\tif (comics_document->selected_command) {\n\t\t\t/* We only use std_err to avoid printing useless error \n\t\t\t * messages on the terminal */\n\t\t\tsuccess = \n\t\t\t\tg_spawn_command_line_sync (\n\t\t\t\t              comics_document->selected_command, \n\t\t\t\t\t\t\t   &std_out, &std_err,\n\t\t\t\t\t\t\t   &retval, &err);\n\t\t\tif (!success) {\n\t\t\t\tg_propagate_error (error, err);\n\t\t\t\tg_error_free (err);\n\t\t\t\treturn FALSE;\n\t\t\t/* I don't check retval status because RARLAB unrar \n\t\t\t * doesn't have a way to return 0 without involving an \n\t\t\t * operation with a file*/\n\t\t\t} else if (WIFEXITED (retval)) {\n\t\t\t\tif (g_strrstr (std_out,\"freeware\") != NULL)\n\t\t\t\t\t/* The RARLAB freeware client */\n\t\t\t\t\tcomics_document->command_usage = RARLABS;\n\t\t\t\telse\n\t\t\t\t\t/* The Gna! free software client */\n\t\t\t\t\tcomics_document->command_usage = GNAUNRAR;\n\n\t\t\t\tg_free (std_out);\n\t\t\t\tg_free (std_err);\n\t\t\t\treturn TRUE;\n\t\t\t}\n\t\t}\n\t\t/* The Gna! free software client with Debian naming convention */\n\t\tcomics_document->selected_command = \n\t\t\t\tg_find_program_in_path (\"unrar-free\");\n\t\tif (comics_document->selected_command) {\n\t\t\tcomics_document->command_usage = GNAUNRAR;\n\t\t\treturn TRUE;\n\t\t}\n\t} else if (g_content_type_is_a (mime_type, \"application/x-cbz\") ||\n\t\t   g_content_type_is_a (mime_type, \"application/zip\")) {\n\t\t/* InfoZIP's unzip program */\n\t\tcomics_document->selected_command = \n\t\t\t\tg_find_program_in_path (\"unzip\");\n\t\tcomics_document->alternative_command =\n\t\t\t\tg_find_program_in_path (\"zipnote\");\n\t\tif (comics_document->selected_command &&\n\t\t    comics_document->alternative_command) {\n\t\t\tcomics_document->command_usage = UNZIP;\n\t\t\treturn TRUE;\n\t\t}\n\t\t/* fallback mode using 7za and 7z from p7zip project  */\n\t\tcomics_document->selected_command =\n\t\t\t\tg_find_program_in_path (\"7za\");\n\t\tif (comics_document->selected_command) {\n\t\t\tcomics_document->command_usage = P7ZIP;\n\t\t\treturn TRUE;\n\t\t}\n\t\tcomics_document->selected_command =\n\t\t\t\tg_find_program_in_path (\"7z\");\n\t\tif (comics_document->selected_command) {\n\t\t\tcomics_document->command_usage = P7ZIP;\n\t\t\treturn TRUE;\n\t\t}\n\n\t} else if (g_content_type_is_a (mime_type, \"application/x-cb7\") ||\n\t\t   g_content_type_is_a (mime_type, \"application/x-7z-compressed\")) {\n\t\t/* 7zr, 7za and 7z are the commands from the p7zip project able \n\t\t * to decompress .7z files */ \n\t\tcomics_document->selected_command =\n\t\t\t\tg_find_program_in_path (\"7zr\");\n\t\tif (comics_document->selected_command) {\n\t\t\tcomics_document->command_usage = P7ZIP;\n\t\t\treturn TRUE;\n\t\t}\n\t\tcomics_document->selected_command =\n\t\t\t\tg_find_program_in_path (\"7za\");\n\t\tif (comics_document->selected_command) {\n\t\t\tcomics_document->command_usage = P7ZIP;\n\t\t\treturn TRUE;\n\t\t}\n\t\tcomics_document->selected_command =\n\t\t\t\tg_find_program_in_path (\"7z\");\n\t\tif (comics_document->selected_command) {\n\t\t\tcomics_document->command_usage = P7ZIP;\n\t\t\treturn TRUE;\n\t\t}\n\t} else {\n\t\tg_set_error (error,\n\t\t\t     EV_DOCUMENT_ERROR,\n\t\t\t     EV_DOCUMENT_ERROR_INVALID,\n\t\t\t     _(\"Not a comic book MIME type: %s\"),\n\t\t\t     mime_type);\n\t\t\t     return FALSE;\n\t}\n\tg_set_error_literal (error,\n\t\t\t     EV_DOCUMENT_ERROR,\n\t\t\t     EV_DOCUMENT_ERROR_INVALID,\n\t\t\t     _(\"Can\u2019t find an appropriate command to \"\n\t\t\t     \"decompress this type of comic book\"));\n\treturn FALSE;\n}\n\nstatic int\nsort_page_names (gconstpointer a,\n                 gconstpointer b)\n{\n  gchar *temp1, *temp2;\n  gint ret;\n\n  temp1 = g_utf8_collate_key_for_filename (* (const char **) a, -1);\n  temp2 = g_utf8_collate_key_for_filename (* (const char **) b, -1);\n\n  ret = strcmp (temp1, temp2);\n\n  g_free (temp1);\n  g_free (temp2);\n\n  return ret;\n}\n\nstatic gboolean\ncomics_document_load (EvDocument *document,\n\t\t      const char *uri,\n\t\t      GError    **error)\n{\n\tComicsDocument *comics_document = COMICS_DOCUMENT (document);\n\tGSList *supported_extensions;\n\tgchar *std_out;\n\tgchar *mime_type;\n\tgchar **cb_files, *cb_file;\n\tgboolean success;\n\tint i, retval;\n\tGError *err = NULL;\n\n\tcomics_document->archive = g_filename_from_uri (uri, NULL, error);\n\tif (!comics_document->archive)\n\t\treturn FALSE;\n\n\tmime_type = ev_file_get_mime_type (uri, FALSE, &err);\n\tif (mime_type == NULL)\n\t\treturn FALSE;\n\t\n\tif (!comics_check_decompress_command (mime_type, comics_document, \n\terror)) {\t\n\t\tg_free (mime_type);\n\t\treturn FALSE;\n\t} else if (!comics_generate_command_lines (comics_document, error)) {\n\t\t   g_free (mime_type);\n\t\treturn FALSE;\n\t}\n\n\tg_free (mime_type);\n\n\t/* Get list of files in archive */\n\tsuccess = g_spawn_command_line_sync (comics_document->list_command,\n\t\t\t\t\t     &std_out, NULL, &retval, error);\n\n\tif (!success) {\n\t\treturn FALSE;\n\t} else if (!WIFEXITED(retval) || WEXITSTATUS(retval) != EXIT_SUCCESS) {\n\t\tg_set_error_literal (error,\n                                     EV_DOCUMENT_ERROR,\n                                     EV_DOCUMENT_ERROR_INVALID,\n                                     _(\"File corrupted\"));\n\t\treturn FALSE;\n\t}\n\n\t/* FIXME: is this safe against filenames containing \\n in the archive ? */\n\tcb_files = g_strsplit (std_out, EV_EOL, 0);\n\n\tg_free (std_out);\n\n\tif (!cb_files) {\n\t\tg_set_error_literal (error,\n\t\t\t\t     EV_DOCUMENT_ERROR,\n\t\t\t\t     EV_DOCUMENT_ERROR_INVALID,\n\t\t\t\t     _(\"No files in archive\"));\n\t\treturn FALSE;\n\t}\n\n        comics_document->page_names = g_ptr_array_sized_new (64);\n\n\tsupported_extensions = get_supported_image_extensions ();\n\tfor (i = 0; cb_files[i] != NULL; i++) {\n\t\tif (comics_document->offset != NO_OFFSET) {\n\t\t\tif (g_utf8_strlen (cb_files[i],-1) > \n\t\t\t    comics_document->offset) {\n\t\t\t\tcb_file = \n\t\t\t\t\tg_utf8_offset_to_pointer (cb_files[i], \n\t\t\t\t\t\t       comics_document->offset);\n\t\t\t} else {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else {\n\t\t\tcb_file = cb_files[i];\n\t\t}\n\t\tgchar *suffix = g_strrstr (cb_file, \".\");\n\t\tif (!suffix)\n\t\t\tcontinue;\n\t\tsuffix = g_ascii_strdown (suffix + 1, -1);\n\t\tif (g_slist_find_custom (supported_extensions, suffix,\n\t\t\t\t\t (GCompareFunc) strcmp) != NULL) {\n                        g_ptr_array_add (comics_document->page_names,\n                                         g_strstrip (g_strdup (cb_file)));\n\t\t}\n\t\tg_free (suffix);\n\t}\n\tg_strfreev (cb_files);\n\tg_slist_foreach (supported_extensions, (GFunc) g_free, NULL);\n\tg_slist_free (supported_extensions);\n\n\tif (comics_document->page_names->len == 0) {\n\t\tg_set_error (error,\n\t\t\t     EV_DOCUMENT_ERROR,\n\t\t\t     EV_DOCUMENT_ERROR_INVALID,\n\t\t\t     _(\"No images found in archive %s\"),\n\t\t\t     uri);\n\t\treturn FALSE;\n\t}\n\n        /* Now sort the pages */\n        g_ptr_array_sort (comics_document->page_names, sort_page_names);\n\n\treturn TRUE;\n}\n\n\nstatic gboolean\ncomics_document_save (EvDocument *document,\n\t\t      const char *uri,\n\t\t      GError    **error)\n{\n\tComicsDocument *comics_document = COMICS_DOCUMENT (document);\n\n\treturn ev_xfer_uri_simple (comics_document->archive, uri, error);\n}\n\nstatic int\ncomics_document_get_n_pages (EvDocument *document)\n{\n\tComicsDocument *comics_document = COMICS_DOCUMENT (document);\n\n        if (comics_document->page_names == NULL)\n                return 0;\n\n\treturn comics_document->page_names->len;\n}\n\nstatic void\ncomics_document_get_page_size (EvDocument *document,\n\t\t\t       EvPage     *page,\n\t\t\t       double     *width,\n\t\t\t       double     *height)\n{\n\tGdkPixbufLoader *loader;\n\tchar **argv;\n\tguchar buf[1024];\n\tgboolean success, got_size = FALSE;\n\tgint outpipe = -1;\n\tGPid child_pid;\n\tgssize bytes;\n\tGdkPixbuf *pixbuf;\n\tgchar *filename;\n\tComicsDocument *comics_document = COMICS_DOCUMENT (document);\n\t\n\tif (!comics_document->decompress_tmp) {\n\t\targv = extract_argv (document, page->index);\n\t\tsuccess = g_spawn_async_with_pipes (NULL, argv, NULL,\n\t\t\t\t\t\t    G_SPAWN_SEARCH_PATH | \n\t\t\t\t\t\t    G_SPAWN_STDERR_TO_DEV_NULL,\n\t\t\t\t\t\t    NULL, NULL,\n\t\t\t\t\t\t    &child_pid,\n\t\t\t\t\t\t    NULL, &outpipe, NULL, NULL);\n\t\tg_strfreev (argv);\n\t\tg_return_if_fail (success == TRUE);\n\n\t\tloader = gdk_pixbuf_loader_new ();\n\t\tg_signal_connect (loader, \"area-prepared\",\n\t\t\t\t  G_CALLBACK (get_page_size_area_prepared_cb),\n\t\t\t\t  &got_size);\n\n\t\twhile (outpipe >= 0) {\n\t\t\tbytes = read (outpipe, buf, 1024);\n\t\t\n\t\t\tif (bytes > 0)\n\t\t\tgdk_pixbuf_loader_write (loader, buf, bytes, NULL);\n\t\t\tif (bytes <= 0 || got_size) {\n\t\t\t\tclose (outpipe);\n\t\t\t\toutpipe = -1;\n\t\t\t\tgdk_pixbuf_loader_close (loader, NULL);\n\t\t\t}\n\t\t}\n\t\tpixbuf = gdk_pixbuf_loader_get_pixbuf (loader);\n\t\tif (pixbuf) {\n\t\t\tif (width)\n\t\t\t\t*width = gdk_pixbuf_get_width (pixbuf);\n\t\t\tif (height)\n\t\t\t\t*height = gdk_pixbuf_get_height (pixbuf);\n\t\t}\n\t\tg_spawn_close_pid (child_pid);\n\t\tg_object_unref (loader);\n\t} else {\n\t\tfilename = g_build_filename (comics_document->dir,\n                                             (char *) comics_document->page_names->pdata[page->index],\n\t\t\t\t\t     NULL);\n\t\tpixbuf = gdk_pixbuf_new_from_file (filename, NULL);\n\t\tif (pixbuf) {\n\t\t\tif (width)\n\t\t\t\t*width = gdk_pixbuf_get_width (pixbuf);\n\t\t\tif (height)\n\t\t\t\t*height = gdk_pixbuf_get_height (pixbuf);\n\t\t\tg_object_unref (pixbuf);\n\t\t}\n\t\tg_free (filename);\n\t}\n}\n\nstatic void\nget_page_size_area_prepared_cb (GdkPixbufLoader *loader,\n\t\t\t\tgpointer         data)\n{\n\tgboolean *got_size = data;\n\t*got_size = TRUE;\n}\n\nstatic GdkPixbuf *\ncomics_document_render_pixbuf (EvDocument      *document,\n\t\t\t       EvRenderContext *rc)\n{\n\tGdkPixbufLoader *loader;\n\tGdkPixbuf *rotated_pixbuf, *tmp_pixbuf;\n\tchar **argv;\n\tguchar buf[4096];\n\tgboolean success;\n\tgint outpipe = -1;\n\tGPid child_pid;\n\tgssize bytes;\n\tgint width, height;\n\tgchar *filename;\n\tComicsDocument *comics_document = COMICS_DOCUMENT (document);\n\t\n\tif (!comics_document->decompress_tmp) {\n\t\targv = extract_argv (document, rc->page->index);\n\t\tsuccess = g_spawn_async_with_pipes (NULL, argv, NULL,\n\t\t\t\t\t\t    G_SPAWN_SEARCH_PATH | \n\t\t\t\t\t\t    G_SPAWN_STDERR_TO_DEV_NULL,\n\t\t\t\t\t\t    NULL, NULL,\n\t\t\t\t\t\t    &child_pid,\n\t\t\t\t\t\t    NULL, &outpipe, NULL, NULL);\n\t\tg_strfreev (argv);\n\t\tg_return_val_if_fail (success == TRUE, NULL);\n\n\t\tloader = gdk_pixbuf_loader_new ();\n\t\tg_signal_connect (loader, \"size-prepared\",\n\t\t\t\t  G_CALLBACK (render_pixbuf_size_prepared_cb), \n\t\t\t\t  rc);\n\n\t\twhile (outpipe >= 0) {\n\t\t\tbytes = read (outpipe, buf, 4096);\n\n\t\t\tif (bytes > 0) {\n\t\t\t\tgdk_pixbuf_loader_write (loader, buf, bytes, \n\t\t\t\tNULL);\n\t\t\t} else if (bytes <= 0) {\n\t\t\t\tclose (outpipe);\n\t\t\t\tgdk_pixbuf_loader_close (loader, NULL);\n\t\t\t\toutpipe = -1;\n\t\t\t}\n\t\t}\n\t\ttmp_pixbuf = gdk_pixbuf_loader_get_pixbuf (loader);\n\t\trotated_pixbuf =\n\t\t\tgdk_pixbuf_rotate_simple (tmp_pixbuf,\n\t\t\t\t\t\t  360 - rc->rotation);\n\t\tg_spawn_close_pid (child_pid);\n\t\tg_object_unref (loader);\n\t} else {\n\t\tint scaled_width, scaled_height;\n\n\t\tfilename = \n\t\t\tg_build_filename (comics_document->dir,\n                                          (char *) comics_document->page_names->pdata[rc->page->index],\n\t\t\t\t\t  NULL);\n\t   \n\t\tgdk_pixbuf_get_file_info (filename, &width, &height);\n\n\t\tev_render_context_compute_scaled_size (rc, width, height,\n\t\t\t\t\t\t       &scaled_width, &scaled_height);\n\t\t\n\t\ttmp_pixbuf =\n\t\t\tgdk_pixbuf_new_from_file_at_size (\n\t\t\t\t    filename, scaled_width, scaled_height, NULL);\n\t\trotated_pixbuf =\n\t\t\tgdk_pixbuf_rotate_simple (tmp_pixbuf,\n\t\t\t\t\t\t  360 - rc->rotation);\n\t\tg_free (filename);\n\t\tg_object_unref (tmp_pixbuf);\n\t}\n\treturn rotated_pixbuf;\n}\n\nstatic cairo_surface_t *\ncomics_document_render (EvDocument      *document,\n\t\t\tEvRenderContext *rc)\n{\n\tGdkPixbuf       *pixbuf;\n\tcairo_surface_t *surface;\n\n\tpixbuf = comics_document_render_pixbuf (document, rc);\n\tsurface = ev_document_misc_surface_from_pixbuf (pixbuf);\n\tg_object_unref (pixbuf);\n\t\n\treturn surface;\n}\n\nstatic void\nrender_pixbuf_size_prepared_cb (GdkPixbufLoader *loader,\n\t\t\t\tgint             width,\n\t\t\t\tgint             height,\n\t\t\t\tEvRenderContext *rc)\n{\n\tint scaled_width, scaled_height;\n\n\tev_render_context_compute_scaled_size (rc, width, height, &scaled_width, &scaled_height);\n\tgdk_pixbuf_loader_set_size (loader, scaled_width, scaled_height);\n}\n\n/**\n * comics_remove_dir: Removes a directory recursively. \n * Returns:\n *   \t0 if it was successfully deleted,\n * \t-1 if an error occurred \t\t\n */\nstatic int \ncomics_remove_dir (gchar *path_name) \n{\n\tGDir  *content_dir;\n\tconst gchar *filename;\n\tgchar *filename_with_path;\n\t\n\tif (g_file_test (path_name, G_FILE_TEST_IS_DIR)) {\n\t\tcontent_dir = g_dir_open  (path_name, 0, NULL);\n\t\tfilename  = g_dir_read_name (content_dir);\n\t\twhile (filename) {\n\t\t\tfilename_with_path = \n\t\t\t\tg_build_filename (path_name, \n\t\t\t\t\t\t  filename, NULL);\n\t\t\tcomics_remove_dir (filename_with_path);\n\t\t\tg_free (filename_with_path);\n\t\t\tfilename = g_dir_read_name (content_dir);\n\t\t}\n\t\tg_dir_close (content_dir);\n\t}\n\t/* Note from g_remove() documentation: on Windows, it is in general not \n\t * possible to remove a file that is open to some process, or mapped \n\t * into memory.*/\n\treturn (g_remove (path_name));\n}\n\nstatic void\ncomics_document_finalize (GObject *object)\n{\n\tComicsDocument *comics_document = COMICS_DOCUMENT (object);\n\t\n\tif (comics_document->decompress_tmp) {\n\t\tif (comics_remove_dir (comics_document->dir) == -1)\n\t\t\tg_warning (_(\"There was an error deleting \u201c%s\u201d.\"),\n\t\t\t\t   comics_document->dir);\n\t\tg_free (comics_document->dir);\n\t}\n\t\n\tif (comics_document->page_names) {\n                g_ptr_array_foreach (comics_document->page_names, (GFunc) g_free, NULL);\n                g_ptr_array_free (comics_document->page_names, TRUE);\n\t}\n\n\tg_free (comics_document->archive);\n\tg_free (comics_document->selected_command);\n\tg_free (comics_document->alternative_command);\n\tg_free (comics_document->extract_command);\n\tg_free (comics_document->list_command);\n\n\tG_OBJECT_CLASS (comics_document_parent_class)->finalize (object);\n}\n\nstatic void\ncomics_document_class_init (ComicsDocumentClass *klass)\n{\n\tGObjectClass    *gobject_class = G_OBJECT_CLASS (klass);\n\tEvDocumentClass *ev_document_class = EV_DOCUMENT_CLASS (klass);\n\n\tgobject_class->finalize = comics_document_finalize;\n\n\tev_document_class->load = comics_document_load;\n\tev_document_class->save = comics_document_save;\n\tev_document_class->get_n_pages = comics_document_get_n_pages;\n\tev_document_class->get_page_size = comics_document_get_page_size;\n\tev_document_class->render = comics_document_render;\n}\n\nstatic void\ncomics_document_init (ComicsDocument *comics_document)\n{\n\tcomics_document->archive = NULL;\n\tcomics_document->page_names = NULL;\n\tcomics_document->extract_command = NULL;\n}\n\n/* Returns a list of file extensions supported by gdk-pixbuf */\nstatic GSList*\nget_supported_image_extensions(void)\n{\n\tGSList *extensions = NULL;\n\tGSList *formats = gdk_pixbuf_get_formats ();\n\tGSList *l;\n\n\tfor (l = formats; l != NULL; l = l->next) {\n\t\tint i;\n\t\tgchar **ext = gdk_pixbuf_format_get_extensions (l->data);\n\n\t\tfor (i = 0; ext[i] != NULL; i++) {\n\t\t\textensions = g_slist_append (extensions,\n\t\t\t\t\t\t     g_strdup (ext[i]));\n\t\t}\n\n\t\tg_strfreev (ext);\n\t}\n\n\tg_slist_free (formats);\n\treturn extensions;\n}\n\nstatic char**\nextract_argv (EvDocument *document, gint page)\n{\n\tComicsDocument *comics_document = COMICS_DOCUMENT (document);\n\tchar **argv;\n\tchar *command_line, *quoted_archive, *quoted_filename;\n\tGError *err = NULL;\n\n        if (page >= comics_document->page_names->len)\n                return NULL;\n\n\tif (comics_document->regex_arg) {\n\t\tquoted_archive = g_shell_quote (comics_document->archive);\n\t\tquoted_filename =\n\t\t\tcomics_regex_quote (comics_document->page_names->pdata[page]);\n\t} else {\n\t\tquoted_archive = g_shell_quote (comics_document->archive);\n\t\tquoted_filename = g_shell_quote (comics_document->page_names->pdata[page]);\n\t}\n\n\tcommand_line = g_strdup_printf (\"%s %s %s\",\n\t\t\t\t\tcomics_document->extract_command,\n\t\t\t\t\tquoted_archive,\n\t\t\t\t\tquoted_filename);\n\tg_shell_parse_argv (command_line, NULL, &argv, &err);\n\n\tif (err) {\n\t\tg_warning (_(\"Error %s\"), err->message);\n\t\tg_error_free (err);\n\t\treturn NULL;\n\t}\n\n\tg_free (command_line);\n\tg_free (quoted_archive);\n\tg_free (quoted_filename);\n\treturn argv;\n}\n", "# *****************************************************************************\n# Versioning\n# *****************************************************************************\n\nm4_define([ev_major_version],[3])\nm4_define([ev_minor_version],[24])\nm4_define([ev_micro_version],[0])\nm4_define([ev_extra_version],[])\nm4_define([ev_version],[ev_major_version.ev_minor_version.ev_micro_version()ev_extra_version])\n\n# The evince API version\nm4_define([ev_api_version], [3.0])\n\n# Libtool versioning. The backend and view libraries have separate versions.\n# Before making a release, the libtool version should be modified.\n# The string is of the form C:R:A.\n# - If interfaces have been changed or added, but binary compatibility has\n#   been preserved, change to C+1:0:A+1\n# - If binary compatibility has been broken (eg removed or changed interfaces)\n#   change to C+1:0:0\n# - If the interface is the same as the previous version, change to C:R+1:A\n\n# Libtool version of the backend library\nm4_define([ev_document_lt_current],[4])\nm4_define([ev_document_lt_revision],[0])\nm4_define([ev_document_lt_age],[0])\nm4_define([ev_document_lt_version_info],[ev_document_lt_current:ev_document_lt_revision:ev_document_lt_age])\nm4_define([ev_document_lt_current_minus_age],[m4_eval(ev_document_lt_current - ev_document_lt_age)])\n\n# Libtool version of the view library\nm4_define([ev_view_lt_current],[3])\nm4_define([ev_view_lt_revision],[0])\nm4_define([ev_view_lt_age],[0])\nm4_define([ev_view_lt_version_info],[ev_view_lt_current:ev_view_lt_revision:ev_view_lt_age])\nm4_define([ev_view_lt_current_minus_age],[m4_eval(ev_view_lt_current - ev_view_lt_age)])\n\n# Binary version for the document backends\nm4_define([ev_binary_version],[ev_document_lt_current])\n\n# *****************************************************************************\n\nAC_PREREQ([2.57])\nAC_INIT([Evince],[ev_version],[http://bugzilla.gnome.org/enter_bug.cgi?product=evince],[evince])\nAM_INIT_AUTOMAKE([1.10 foreign dist-xz no-dist-gzip tar-ustar])\n\nAC_CONFIG_HEADERS([config.h])\nAC_CONFIG_MACRO_DIR([m4])\n\nif test -z \"$enable_maintainer_mode\"; then\n  enable_maintainer_mode=yes\nfi\nAM_MAINTAINER_MODE([enable])\n\nm4_ifdef([AM_SILENT_RULES],[AM_SILENT_RULES([yes])])\n\nAC_PROG_CC\nAM_PROG_CC_C_O\nAC_PROG_CXX\n\nAC_PROG_SED\n\n# Initialize libtool\nLT_PREREQ([2.2])\nLT_INIT\nLT_LIB_M\n\nGNOME_CXX_WARNINGS\n\nIT_PROG_INTLTOOL([0.35.0])\n\nGETTEXT_PACKAGE=evince\nAC_SUBST(GETTEXT_PACKAGE)\nAC_DEFINE_UNQUOTED([GETTEXT_PACKAGE],[\"$GETTEXT_PACKAGE\"],[Gettext package])\nAM_GLIB_GNU_GETTEXT\n\nm4_pattern_allow([AM_V_GEN])dnl Make autoconf not complain about the rule below\nEV_INTLTOOL_EVINCE_BACKEND_RULE='%.evince-backend:   %.evince-backend.in   $(INTLTOOL_MERGE) $(wildcard $(top_srcdir)/po/*.po) ; $(AM_V_GEN) LC_ALL=C $(INTLTOOL_MERGE) -d -u -c $(top_builddir)/po/.intltool-merge-cache $(top_srcdir)/po $< [$]@'\nAC_SUBST([EV_INTLTOOL_EVINCE_BACKEND_RULE])\n\nGLIB_GSETTINGS\n\n# Check which platform to use\n\nAC_MSG_CHECKING([for which platform to build])\nAC_ARG_WITH([platform],\n  [AS_HELP_STRING([--with-platform=gnome|win32],\n                  [Setting platform (default: gnome)])],\n  [case \"$withval\" in\n    gnome|win32) ;;\n    *) AC_MSG_ERROR([invalid argument \"$withval\" for --with-platform]) ;;\n   esac],\n  [case \"$host\" in\n     *-*-mingw*|*-*-cygwin*) with_platform=\"win32\" ;;\n     *) with_platform=gnome ;;\n   esac])\n\nAC_MSG_RESULT([$with_platform])\n\nif test \"$with_platform\" = \"win32\"; then\n  AC_CHECK_TOOL([WINDRES],[windres])\n  AC_MSG_CHECKING([for native Win32])\n  case \"$host\" in\n    *-*-mingw*)\n      os_win32=yes\n      ;;\n    *)\n      os_win32=no\n      ;;\n  esac\n  AC_MSG_RESULT([$os_win32])\n\n  AM_CFLAGS=\"$AM_CFLAGS -D_WIN32_WINNT=0x0500\"\nfi\n\nAM_CONDITIONAL([PLATFORM_WIN32],[test \"$with_platform\" = \"win32\"])\n\ndnl Specify required versions of dependencies\nCAIRO_REQUIRED=1.10.0\nGLIB_REQUIRED=2.36.0\nLIBSECRET_REQUIRED=0.5\nGTK_REQUIRED=3.16.0\nNAUTILUS_REQUIRED=2.91.4\n\nAC_SUBST([GLIB_REQUIRED])\nAC_SUBST([GTK_REQUIRED])\n\nAC_DEFINE([GDK_VERSION_MIN_REQUIRED], [GDK_VERSION_3_8], [Minimum GTK/GDK version required])\n\nADWAITA_ICON_THEME_REQUIRED=2.17.1\nLIBXML_REQUIRED=2.5.0\n\ndnl Check dependencies\n\n# LIB_CFLAGS       for helpers and generic widgets. (libdocument, cut-and-paste)\n# BACKEND_CFLAGS   for backend implementations.\n# FRONTEND_CFLAGS  for frontend implementations. (properties, thumbnailer)\n# FRONTEND_LIBS\n# SHELL_CFLAGS     for shell implementation.\n# SHELL_LIBS\n\nhave_zlib=yes\nAC_CHECK_HEADERS([zlib.h],\n\t[AC_CHECK_LIB([z], [inflate],\n\t\t[AC_CHECK_LIB([z], [crc32], [have_zlib=yes], [have_zlib=no])],\n\t\t[have_zlib=no])],\n\t[have_zlib=no])\n\nif test x$have_zlib = xno; then\n\tAC_MSG_ERROR([No sufficient zlib library found on your system.])\nfi\n\nZLIB_LIBS=-lz\nAC_SUBST(ZLIB_LIBS)\n\nPKG_CHECK_MODULES(LIBDOCUMENT, gtk+-3.0 >= $GTK_REQUIRED gio-2.0 >= $GLIB_REQUIRED gmodule-no-export-2.0 >= $GLIB_REQUIRED gmodule-2.0)\nPKG_CHECK_MODULES(LIBVIEW, gtk+-3.0 >= $GTK_REQUIRED gthread-2.0 gio-2.0 >= $GLIB_REQUIRED)\nPKG_CHECK_MODULES(BACKEND, cairo >= $CAIRO_REQUIRED gtk+-3.0 >= $GTK_REQUIRED)\nPKG_CHECK_MODULES(FRONTEND_CORE, gtk+-3.0 >= $GTK_REQUIRED gthread-2.0 gio-2.0 >= $GLIB_REQUIRED gmodule-no-export-2.0 >= $GLIB_REQUIRED)\n\n# Although GTK+ 3.10 includes hi-dpi functionality, it does not require a cairo with\n# cairo_surface_set_device_scale(), which we also need if we're to support hi-dpi,\n# so we need check for that explicity.\n\nevince_save_LIBS=$LIBS\nLIBS=\"$LIBS $LIBVIEW_LIBS\"\nAC_CHECK_FUNCS(cairo_surface_set_device_scale)\nLIBS=$evince_save_LIBS\n\nAC_MSG_CHECKING([for hi-dpi support])\nif test \"$ac_cv_func_cairo_surface_set_device_scale\" = yes ; then\n   AC_DEFINE([HAVE_HIDPI_SUPPORT], [1], [Define if cairo and GTK+ have necessary functions for hi-dpi])\n   AC_MSG_RESULT([yes])\nelse\n   AC_MSG_RESULT([no])\nfi\n\n\n# Check if GTK+ version is older than 3.20 to use different CSS.\nAM_CONDITIONAL([HAVE_GTK_320],[$($PKG_CONFIG --atleast-version=3.20.0 gtk+-3.0)])\n\nSHELL_PLATFORM_PKGS=\ncase \"$with_platform\" in\n  gnome)\n        # Evince has a rather soft run-time dependency on hicolor-icon-theme.\n        # If the hicolor theme is not available, Evince fails to display some\n        # icons. Because we cannot check for it at run-time, we instead\n        # would like to require the icon theme at compile-time. But, because\n        # the hicolor-icon-theme does not have a pkgconfig file, on gnome we\n        # require the gnome icon theme instead.\n        SHELL_PLATFORM_PKGS=\"adwaita-icon-theme >= $ADWAITA_ICON_THEME_REQUIRED\"\n        ;;\n  *)\n        # On all other platforms we issue a warning about the runtime\n        # dependency.\n        AC_MSG_WARN([Evince has a soft run-time dependency on hicolor-icon-theme. You are advised to have this theme installed when running Evince.]);\n        SHELL_PLATFORM_PKGS=\"\"\n        ;;\nesac\n\nPKG_CHECK_MODULES([SHELL_CORE],[libxml-2.0 >= $LIBXML_REQUIRED gtk+-3.0 >= $GTK_REQUIRED gio-2.0 >= $GLIB_REQUIRED gmodule-no-export-2.0 >= $GLIB_REQUIRED gthread-2.0 $SHELL_PLATFORM_PKGS])\n\n# ***************\n# Build utilities\n# ***************\n\nAC_ARG_VAR([GLIB_GENMARSHAL],[the glib-genmarschal programme])\nAC_PATH_PROG([GLIB_GENMARSHAL],[glib-genmarshal],[])\nif test -z \"$GLIB_GENMARSHAL\"; then\n  AC_MSG_ERROR([glib-genmarshal not found])\nfi\n\nAC_ARG_VAR([GLIB_MKENUMS],[the glib-mkenums programme])\nAC_PATH_PROG([GLIB_MKENUMS],[glib-mkenums],[])\nif test -z \"$GLIB_MKENUMS\"; then\n  AC_MSG_ERROR([glib-mkenums not found])\nfi\n\nAC_ARG_VAR([GLIB_COMPILE_RESOURCES],[the glib-compile-resources programme])\nAC_PATH_PROG([GLIB_COMPILE_RESOURCES],[glib-compile-resources],[])\nif test -z \"$GLIB_COMPILE_RESOURCES\"; then\n  AC_MSG_ERROR([glib-compile-resources not found])\nfi\n\nAC_ARG_VAR([XMLLINT],[the xmllint programme])\nAC_PATH_PROG([XMLLINT],[xmllint],[])\nif test -z \"$XMLLINT\"; then\n  AC_MSG_ERROR([xmllint not found])\nfi\n\nAC_ARG_VAR([GDBUS_CODEGEN],[the gdbus-codegen programme])\nAC_PATH_PROG([GDBUS_CODEGEN],[gdbus-codegen],[])\nif test -z \"$GDBUS_CODEGEN\"; then\n  AC_MSG_ERROR([gdbus-codegen not found])\nfi\n\n# ***\n\nBACKEND_LIBTOOL_FLAGS=\"-module -avoid-version -no-undefined -export-symbols \\$(top_srcdir)/backend/backend.symbols\"\nAC_SUBST(BACKEND_LIBTOOL_FLAGS)\n\ndnl ===== Check special functions\nevince_save_LIBS=$LIBS\nLIBS=\"$LIBS $BACKEND_LIBS\"\nAC_CHECK_FUNCS(cairo_format_stride_for_width)\nLIBS=$evince_save_LIBS\n\n# ******************\n# GKT+ Unix Printing\n# ******************\n\nAC_MSG_CHECKING([whether gtk+-unix-print support is requested])\nAC_ARG_WITH([gtk-unix-print],\n  [AS_HELP_STRING([--without-gtk-unix-print],\n\t\t  [Disable the use of gtk-unix-print])],\n  [],[case \"$os_win32\" in\n        yes) with_gtk_unix_print=no ;;\n        *) with_gtk_unix_print=yes ;;\n      esac])\n      \nAC_MSG_RESULT([$with_gtk_unix_print])\n\nif test \"$with_gtk_unix_print\" = \"yes\"; then\n   PKG_CHECK_MODULES(GTKUNIXPRINT, [gtk+-unix-print-3.0 >= $GTK_REQUIRED])\n   AC_DEFINE([GTKUNIXPRINT_ENABLED], [1], [Define if gtk+-unix-print is enabled.])\nfi\n\n# *********************\n# GNOME Keyring support\n# *********************\n\nAC_ARG_WITH(keyring,\n        [AS_HELP_STRING([--without-keyring],\n\t\t\t[Disable the use of gnome-keyring])],\n        [],\n        [case \"$with_platform\" in\n           gnome) with_keyring=yes ;;\n           win32) with_keyring=no ;;\n         esac])\n\nAM_CONDITIONAL([WITH_KEYRING],[test \"$with_keyring\" = \"yes\"])\n\nif test \"$with_keyring\" = \"yes\"; then\n        PKG_CHECK_MODULES(LIBSECRET, libsecret-1 >= $LIBSECRET_REQUIRED)\n        AC_DEFINE([WITH_KEYRING],[1],[Define if KEYRING support is enabled])\nfi\n\n# ****\n# DBUS\n# ****\n\nAC_ARG_ENABLE([dbus],\n  [AS_HELP_STRING([--disable-dbus], [Disable support for dbus])],\n  [],\n  [case \"$with_platform\" in\n      gnome) enable_dbus=yes ;;\n    esac])\n\nif test \"$enable_dbus\" = \"yes\"; then\n  AC_DEFINE([ENABLE_DBUS],[1],[Define if DBUS support is enabled])\n\n   PKG_CHECK_MODULES([EV_DAEMON], [gio-2.0 >= $GLIB_REQUIRED gio-unix-2.0])\nfi\n\nAM_CONDITIONAL([ENABLE_DBUS], [test \"$enable_dbus\" = \"yes\"])\n\n# It is correct for this to be in ${prefix}/lib, even on systems where that\n# does not match ${libdir}. This is what systemd uses on such platforms.\nAC_ARG_WITH([systemduserunitdir],\n\tAS_HELP_STRING([--with-systemduserunitdir=PATH],\n\t[Set directory for systemd user units, or 'no' to disable]\n\t[[default=${prefix}/lib/systemd/user]]),\n\t[systemd_userdir=\"$withval\"],\n\t[systemd_userdir='${prefix}/lib/systemd/user'])\nAC_SUBST([systemd_userdir])\nAM_CONDITIONAL([WITH_SYSTEMD_USER_UNITS], [test \"x$systemd_userdir\" != \"xno\"])\n\n# *******************************\n# GNOME Desktop (Thumbnail cache)\n# *******************************\n\nAC_ARG_ENABLE([libgnome-desktop],\n        [AS_HELP_STRING([--disable-libgnome-desktop], [Disable GNOME Desktop (Thumbnail cache)])],\n        [enable_gnome_desktop=$enableval],\n        [enable_gnome_desktop=auto])\n\nif test \"$enable_gnome_desktop\" != \"no\"; then\n   if test \"$enable_gnome_desktop\" = \"auto\"; then\n      PKG_CHECK_MODULES([LIBGNOME_DESKTOP], [gnome-desktop-3.0], has_libgnome_desktop=yes, has_libgnome_desktop=no)\n   else\n      PKG_CHECK_MODULES([LIBGNOME_DESKTOP], [gnome-desktop-3.0])\n      has_libgnome_desktop=yes\n   fi\n\n   if test x$has_libgnome_desktop = xyes; then\n      AC_DEFINE([HAVE_LIBGNOME_DESKTOP], [1], [Whether GNOME Desktop (Thumbnail cache) is available])\n      enable_gnome_desktop=yes\n   else\n      enable_gnome_desktop=no\n   fi\nfi\n\n# **********************\n# GStreamer (Multimedia)\n# **********************\n\nAC_ARG_ENABLE([multimedia],\n        [AS_HELP_STRING([--disable-multimedia], [Disable Multimedia support])],\n        [enable_multimedia=$enableval],\n        [enable_multimedia=auto])\n\nif test \"$enable_multimedia\" != \"no\"; then\n   if test \"$enable_multimedia\" = \"auto\"; then\n      PKG_CHECK_MODULES([GSTREAMER], [gstreamer-1.0 gstreamer-base-1.0 gstreamer-video-1.0], has_gstreamer=yes, has_gstreamer=no)\n   else\n      PKG_CHECK_MODULES([GSTREAMER], [gstreamer-1.0 gstreamer-base-1.0 gstreamer-video-1.0])\n      has_gstreamer=yes\n   fi\n\n   if test x$has_gstreamer = xyes; then\n      AC_DEFINE([ENABLE_MULTIMEDIA], [1], [Whether multimedia support is enabled])\n      enable_multimedia=yes\n   else\n      enable_multimedia=no\n   fi\nfi\n\nAM_CONDITIONAL([ENABLE_MULTIMEDIA], [test \"$enable_multimedia\" = \"yes\"])\n\ndnl ========= Check for Desktop Schemas\nPKG_CHECK_MODULES([DESKTOP_SCHEMAS], [gsettings-desktop-schemas],\n                  has_desktop_schemas=yes, has_desktop_schemas=no)\nif test x$has_desktop_schemas = xyes; then\n   AC_DEFINE([HAVE_DESKTOP_SCHEMAS], [1], [Whether GSettings Desktop Schemas are available])\nfi\n\ndnl Debug mode\n\nAC_ARG_ENABLE([debug],\n\tAS_HELP_STRING([--enable-debug],\n\t\t       [Turn on evince debug mode]),\n\t[enable_debug=$enableval],\n\t[enable_debug=no])\n\nif test \"x$enable_debug\" = \"xyes\"; then\n   DEBUG_FLAGS=\"-DEV_ENABLE_DEBUG\"\nfi\n\nLIBDOCUMENT_CFLAGS=\"$LIBDOCUMENT_CFLAGS $DEBUG_FLAGS\"\nLIBDOCUMENT_LIBS=\"$LIBDOCUMENT_LIBS\"\nAC_SUBST(LIBDOCUMENT_CFLAGS)\nAC_SUBST(LIBDOCUMENT_LIBS)\n\nLIBVIEW_CFLAGS=\"$LIBVIEW_CFLAGS $GTKUNIXPRINT_CFLAGS $GSTREAMER_CFLAGS $DEBUG_FLAGS\"\nLIBVIEW_LIBS=\"$LIBVIEW_LIBS $GTKUNIXPRINT_LIBS $GSTREAMER_LIBS -lm\"\nAC_SUBST(LIBVIEW_CFLAGS)\nAC_SUBST(LIBVIEW_LIBS)\n\nBACKEND_CFLAGS=\"$BACKEND_CFLAGS -DGDK_MULTIHEAD_SAFE -DGTK_MULTIHEAD_SAFE $DEBUG_FLAGS\"\nBACKEND_LIBS=\"$BACKEND_LIBS -lm\"\nAC_SUBST(BACKEND_CFLAGS)\nAC_SUBST(BACKEND_LIBS)\n\nSHELL_CFLAGS=\"$SHELL_CORE_CFLAGS $LIBSECRET_CFLAGS -DGDK_MULTIHEAD_SAFE -DGTK_MULTIHEAD_SAFE $DEBUG_FLAGS $LIBGNOME_DESKTOP_CFLAGS\"\nSHELL_LIBS=\"$SHELL_CORE_LIBS $LIBSECRET_LIBS $LIBGNOME_DESKTOP_LIBS -lz -lm\"\nAC_SUBST(SHELL_CFLAGS)\nAC_SUBST(SHELL_LIBS)\n\nFRONTEND_CFLAGS=\"$FRONTEND_CORE_CFLAGS $DEBUG_FLAGS\"\nFRONTEND_LIBS=\"$FRONTEND_CORE_LIBS -lz\"\nAC_SUBST(FRONTEND_CFLAGS)\nAC_SUBST(FRONTEND_LIBS)\n\nEV_DAEMON_CFLAGS=\"$EV_DAEMON_CFLAGS $DEBUG_FLAGS\"\nAC_SUBST([EV_DAEMON_CFLAGS])\nAC_SUBST([EV_DAEMON_LIBS])\n\n# Check for Nautilus property page build\nAC_ARG_ENABLE([nautilus],\n  [AS_HELP_STRING([--disable-nautilus],\n\t\t  [Disable build of nautilus extensions])],\n  [],\n  [case \"$with_platform\" in\n     gnome) enable_nautilus=yes ;;\n     *) enable_nautilus=no ;;\n    esac])\n\nif test \"$enable_nautilus\" = \"yes\" ; then\n  PKG_CHECK_MODULES([NAUTILUS],[gtk+-3.0 $MM gthread-2.0 libnautilus-extension >= $NAUTILUS_REQUIRED],\n                    [],[AC_MSG_ERROR([libnautilus-extension not found; use --disable-nautilus to disable the nautilus extensions])])\n  NAUTILUS_EXTENSION_DIR=`$PKG_CONFIG --variable=extensiondir libnautilus-extension`\n  NAUTILUS_EXTENSION_DIR=${NAUTILUS_EXTENSION_DIR#`$PKG_CONFIG --variable=libdir libnautilus-extension`}\n  NAUTILUS_EXTENSION_DIR=${NAUTILUS_EXTENSION_DIR#/}\n  AC_SUBST(NAUTILUS_EXTENSION_DIR)\n  AC_SUBST(NAUTILUS_CFLAGS)\n  AC_SUBST(NAUTILUS_LIBS)\n\n  AC_DEFINE([HAVE_NAUTILUS],[1], [defined if you build the nautilus plugin])\nfi\n\nAM_CONDITIONAL([ENABLE_NAUTILUS],[test \"$enable_nautilus\" = \"yes\"])\n\n# ***************\n# Document Viewer\n# ***************\n\nAC_ARG_ENABLE(\n  [viewer],\n  [AS_HELP_STRING([--disable-viewer], [Disable GNOME Document viewer])],\n  [],\n  [enable_viewer=yes]\n)\nAM_CONDITIONAL([ENABLE_VIEWER],[test \"$enable_viewer\" = \"yes\"])\n\n# ***************\n# Thumbnailer\n# ***************\n\nAC_ARG_ENABLE([thumbnailer],\n  [AS_HELP_STRING([--disable-thumbnailer],\n\t\t  [Disable GNOME thumbnailer])],\n  [],\n  [enable_thumbnailer=yes])\n\nAM_CONDITIONAL([ENABLE_THUMBNAILER],[test \"$enable_thumbnailer\" = \"yes\"])\n\n# ***************\n# Print Previewer\n# ***************\n\nAC_ARG_ENABLE([previewer],\n  [AS_HELP_STRING([--disable-previewer],\n\t\t  [Disable the GNOME Document Previewer])],\n  [],\n  [enable_previewer=yes])\n\nif test x$enable_previewer = \"xyes\" ; then\n  PKG_CHECK_MODULES([PREVIEWER],[gtk+-3.0 >= $GTK_REQUIRED gthread-2.0 gio-2.0 >= $GLIB_REQUIRED gmodule-no-export-2.0 >= $GLIB_REQUIRED])\nfi\n\nAM_CONDITIONAL([ENABLE_PREVIEWER],[test \"$enable_previewer\" = \"yes\"])\nPREVIEWER_CFLAGS=\"$PREVIEWER_CFLAGS $GTKUNIXPRINT_CFLAGS $DEBUG_FLAGS\"\nPREVIEWER_LIBS=\"$PREVIEWER_LIBS $GTKUNIXPRINT_LIBS -lz\"\nAC_SUBST(PREVIEWER_CFLAGS)\nAC_SUBST(PREVIEWER_LIBS)\n\n\n# **************\n# Browser Plugin\n# **************\n\nAC_ARG_ENABLE([browser-plugin],\n  [AS_HELP_STRING([--disable-browser-plugin],\n                  [Disable the Browser Plugin])],\n  [],\n  [enable_browser_plugin=yes])\n\nif test x$enable_browser_plugin = \"xyes\" ; then\n  PKG_CHECK_MODULES([BROWSER_PLUGIN],[gtk+-3.0 >= $GTK_REQUIRED gthread-2.0 gio-2.0 >= $GLIB_REQUIRED])\n\n  if test -z \"${BROWSER_PLUGIN_DIR}\"; then\n    BROWSER_PLUGIN_DIR=\"\\${libdir}/mozilla/plugins\"\n  fi\n  AC_ARG_VAR([BROWSER_PLUGIN_DIR],[Where to install the plugin to])\nfi\n\nAM_CONDITIONAL([ENABLE_BROWSER_PLUGIN],[test \"$enable_browser_plugin\" = \"yes\"])\nBROWSER_PLUGIN_CFLAGS=\"$BROWSER_PLUGIN_CFLAGS $DEBUG_FLAGS\"\nAC_SUBST(BROWSER_PLUGIN_CFLAGS)\nAC_SUBST(BROWSER_PLUGIN_LIBS)\n\n# ***\n# GIR\n# ***\n\n# No automagic please!\nif test -z \"$enable_introspection\"; then\n  enable_introspection=no\nfi\n\nGOBJECT_INTROSPECTION_CHECK([1.0])\n\ndnl ================== portability checks ===========================================\n\ndnl for backtrace()\nAC_CHECK_HEADERS([execinfo.h])\n\nAC_CHECK_DECL([_NL_MEASUREMENT_MEASUREMENT],[\n  AC_DEFINE([HAVE__NL_MEASUREMENT_MEASUREMENT],[1],[Define if _NL_MEASUREMENT_MEASUREMENT is available])\n  ],[],[#include <langinfo.h>])\n\ndnl ================== pdf checks ===================================================\nAC_ARG_ENABLE([pdf],\n  [AS_HELP_STRING([--disable-pdf],\n\t\t  [Disable the PDF support])],\n  [enable_pdf=$enableval],\n  [enable_pdf=yes])\n\nif test \"x$enable_pdf\" = \"xyes\"; then\n    POPPLER_REQUIRED=0.33.0\n    PKG_CHECK_MODULES(POPPLER, poppler-glib >= $POPPLER_REQUIRED libxml-2.0 >= $LIBXML_REQUIRED,enable_pdf=yes,enable_pdf=no)\n\n    if test \"x$enable_pdf\" = \"xyes\"; then\n\t    PKG_CHECK_MODULES(CAIRO_PDF, cairo-pdf, enable_cairo_pdf=yes, enable_cairo_pdf=no)\n\t    if test x$enable_cairo_pdf = xyes; then\n\t            AC_DEFINE([HAVE_CAIRO_PDF], [1], [defined if cairo-pdf is available])\n            fi\n\n\t    PKG_CHECK_MODULES(CAIRO_PS, cairo-ps, enable_cairo_ps=yes, enable_cairo_ps=no)\n\t    if test x$enable_cairo_ps = xyes; then\n\t            AC_DEFINE([HAVE_CAIRO_PS], [1], [defined if cairo-ps is available])\n            fi\n    else\n\t    AC_MSG_ERROR(\"PDF support is disabled since poppler-glib library version $POPPLER_REQUIRED or newer not found\")\n    fi \nfi\n\nAM_CONDITIONAL(ENABLE_PDF, test x$enable_pdf = xyes)\ndnl ================== end of pdf checks ============================================\n\ndnl libspectre (used by ps and dvi backends)\nSPECTRE_REQUIRED=0.2.0 \nPKG_CHECK_MODULES(SPECTRE, libspectre >= $SPECTRE_REQUIRED,have_spectre=yes,have_spectre=no)\nAM_CONDITIONAL(HAVE_SPECTRE, test x$have_spectre = xyes)\nif test \"x$have_spectre\" = \"xyes\"; then\n   AC_DEFINE([HAVE_SPECTRE], [1], [Have libspectre])\nfi\n\ndnl ================== ps checks ====================================================\nAC_ARG_ENABLE(ps,\n  \t[AS_HELP_STRING([--disable-ps],\n\t\t\t[Disable the PostScript backend])],\n\t[enable_ps=$enableval],\n\t[enable_ps=yes])\n\nif test \"x$enable_ps\" = \"xyes\"; then\n   if test \"x$have_spectre\" = \"xyes\"; then\n      AC_DEFINE([ENABLE_PS], [1], [Enable support for PostScript files.])\n   else\n      enable_ps=\"no\"\n      AC_MSG_WARN([PS support is disabled since libspectre (version >= $SPECTRE_REQUIRED) is needed])\n   fi\nfi\nAM_CONDITIONAL(ENABLE_PS, test x$enable_ps = xyes)\ndnl ======================== End of ps checks ===================================\n\ndnl ================== tiff checks ===================================================\nAC_ARG_ENABLE(tiff,\n            [AS_HELP_STRING([--disable-tiff],\n\t\t\t    [Disable the support of multipage tiff])],\n\t    [enable_tiff=$enableval],\n\t    [enable_tiff=yes])\n\nif test \"x$enable_tiff\" = \"xyes\"; then\n    AC_CHECK_HEADERS([tiff.h],enable_tiff=yes,enable_tiff=no,)\n    if test \"x$enable_tiff\" = \"xyes\"; then\n\tAC_CHECK_LIB([tiff],TIFFOpen,enable_tiff=yes,enable_tiff=no,\"-lz\")\n        AC_CHECK_LIB([tiff],TIFFReadRGBAImageOriented,enable_tiff=yes,enable_tiff=no,\"-lz\")\n    fi\n    if test \"x$enable_tiff\" = \"xyes\"; then\n\t    AC_DEFINE([ENABLE_TIFF], [1], [Enable multipage tiff support.])\n    else\n\t    AC_MSG_WARN(\"Tiff support is disabled since tiff library version 3.6 or newer not found\")\n    fi \nfi\n\nAM_CONDITIONAL(ENABLE_TIFF, test x$enable_tiff = xyes)\ndnl ================== end of tiff checks ============================================\n\ndnl ================== djvu checks ===================================================\n\nAC_ARG_ENABLE(djvu,\n            [AS_HELP_STRING([--disable-djvu],\n\t\t\t    [Disable the support of djvu viewer])],\n\t    [enable_djvu=$enableval],\n\t    [enable_djvu=yes])\n\nif test \"x$enable_djvu\" = \"xyes\"; then\n    DJVULIBRE_REQUIRED=3.5.22\n    PKG_CHECK_MODULES(DJVU, ddjvuapi >= $DJVULIBRE_REQUIRED, enable_djvu=yes, enable_djvu=no)\n\n    if test \"x$enable_djvu\" = \"xyes\"; then\n        AC_DEFINE([ENABLE_DJVU], [1], [Enable djvu viewer support.])\n    else\n\tAC_MSG_WARN([\t\n** Djvu support is disabled since a recent version of the djvulibre \n** library was not found. You need at least djvulibre-3.5.22 which\n** can be found on http://djvulibre.djvuzone.org \n])\n    fi \nfi\n\nAM_CONDITIONAL(ENABLE_DJVU, test x$enable_djvu = xyes)\n\ndnl ================== End of djvu checks ===================================================\n\ndnl ================== dvi checks ===================================================\n\nAC_ARG_ENABLE(dvi,\n            [AS_HELP_STRING([--disable-dvi],\n\t    [Disable the support of dvi viewer])],\n\t    [enable_dvi=$enableval],\n\t    [enable_dvi=yes])\n\nAC_ARG_ENABLE(t1lib,\n            [AS_HELP_STRING([--enable-t1lib],\n\t                    [Compile with support of t1lib for type1 fonts in dvi])],\n\t    [enable_type1_fonts=$enableval],\n\t    [enable_type1_fonts=no])\n\nif test \"x$enable_dvi\" = \"xyes\"; then\n    AC_C_CONST\n    AC_C_INLINE\n    AC_TYPE_SIZE_T\n    AC_CHECK_SIZEOF(long, 4)\n    AC_CHECK_SIZEOF(int, 4)\n    AC_CHECK_SIZEOF(short, 2)\n    AC_CHECK_SIZEOF(long long, 4)\n    AC_CHECK_SIZEOF(void *, 4)\n    AC_CHECK_LIB([kpathsea],[kpse_init_prog],[enable_dvi=yes],[enable_dvi=no])\n\n    if test \"x$enable_dvi\" = \"xyes\"; then\n\tAC_DEFINE([ENABLE_DVI], [1], [Enable dvi viewer support.])\n    else\n        AC_MSG_WARN(\"Dvi support is disabled since kpathsea library is not found. Check your TeX installation.\")\n    fi\nfi\nAM_CONDITIONAL(ENABLE_DVI, test x$enable_dvi = xyes)\n\nif test \"x$enable_dvi\" = \"xyes\"; then\n    if test \"x$enable_type1_fonts\" = \"xyes\"; then\n\tAC_CHECK_LIB([t1],T1_InitLib,enable_type1_fonts=yes,enable_type1_fonts=no,[-lm])\n    fi\n\n    if test \"x$enable_type1_fonts\" = xyes; then\n        AC_DEFINE([WITH_TYPE1_FONTS], [1], [Enable t1lib support in dvi.])\n    fi\nelse \n    enable_type1_fonts=no\nfi\nAM_CONDITIONAL(WITH_TYPE1_FONTS, test x$enable_type1_fonts = xyes)\n\ndnl ================== End of dvi checks ===================================================\n\ndnl ================== comic book checks ===================================================\n \nAC_ARG_ENABLE(comics,\n \t[AS_HELP_STRING([--enable-comics],\n\t                [Compile with support for comic book archives])],\n\t[enable_comics=$enableval],\n\t[enable_comics=yes])\n\t\nif test \"x$enable_comics\" = \"xyes\"; then\n\tAC_DEFINE([ENABLE_COMICS], [1], [Enable support for comics.])\nfi\nAM_CONDITIONAL(ENABLE_COMICS, test x$enable_comics = xyes)\n\ndnl ================== End of comic book checks ============================================\n\ndnl ================== XPS checks ===================================================\n\nAC_ARG_ENABLE(xps,\n\t[AS_HELP_STRING([--enable-xps],\n\t\t\t[Compile with support for XPS documents.])],\n\t[enable_xps=$enableval],\n\t[enable_xps=yes])\n\nif test \"x$enable_xps\" = \"xyes\"; then\n   GXPS_REQUIRED=0.2.1\n   PKG_CHECK_MODULES(GXPS, libgxps >= $GXPS_REQUIRED,enable_xps=yes,enable_xps=no)\n\n   if test \"x$enable_xps\" = \"xyes\"; then\n      AC_DEFINE([ENABLE_XPS], [1], [Enable support for XPS documents.])\n   else\n      enable_xps=\"no\"\n      AC_MSG_WARN([XPS support is disabled since libgxps (version >= $GXPS_REQUIRED) is needed])\n   fi\nfi\n\nAM_CONDITIONAL(ENABLE_XPS, test x$enable_xps = xyes)\n\ndnl ================== End of XPS checks ===================================================\n\ndnl =================== Compile warnings ===================================================\n\nGNOME_COMPILE_WARNINGS\n\nCC_CHECK_FLAGS_APPEND([AM_CFLAGS],[CFLAGS],[ \\\n])\n\nAM_CFLAGS=\"$AM_CFLAGS $WARN_CFLAGS\"\nAM_CXXFLAGS=\"$AM_CXXFLAGS $WARN_CXXFLAGS\"\n\ndnl =================== End of compile warnings=============================================\n\ndnl =================== Mime types list ====================================================\n\nif test \"x$enable_pdf\" = \"xyes\" ; then\n        PDF_MIME_TYPES=\"application/pdf;application/x-bzpdf;application/x-gzpdf;application/x-xzpdf;application/x-ext-pdf\"\n        APPDATA_PDF_MIME_TYPES=$(echo \"<mimetype>$PDF_MIME_TYPES</mimetype>\" | sed -e 's/;/<\\/mimetype>\\n    <mimetype>/g')\n        if test -z \"$EVINCE_MIME_TYPES\"; then\n           EVINCE_MIME_TYPES=\"${PDF_MIME_TYPES}\"\n        else\n           EVINCE_MIME_TYPES=\"${EVINCE_MIME_TYPES};${PDF_MIME_TYPES}\"\n        fi\nfi\nAC_SUBST(PDF_MIME_TYPES)\nAC_SUBST(APPDATA_PDF_MIME_TYPES)\nAM_SUBST_NOTMAKE(APPDATA_PDF_MIME_TYPES)\nif test \"x$enable_ps\" = \"xyes\" ; then\n        PS_MIME_TYPES=\"application/postscript;application/x-bzpostscript;application/x-gzpostscript;image/x-eps;image/x-bzeps;image/x-gzeps;application/x-ext-ps;application/x-ext-eps\"\n        APPDATA_PS_MIME_TYPES=$(echo \"<mimetype>$PS_MIME_TYPES</mimetype>\" | sed -e 's/;/<\\/mimetype>\\n    <mimetype>/g')\n        if test -z \"$EVINCE_MIME_TYPES\"; then\n           EVINCE_MIME_TYPES=\"${PS_MIME_TYPES}\"\n        else\n           EVINCE_MIME_TYPES=\"${EVINCE_MIME_TYPES};${PS_MIME_TYPES}\"\n        fi\nfi\nAC_SUBST(PS_MIME_TYPES)\nAC_SUBST(APPDATA_PS_MIME_TYPES)\nAM_SUBST_NOTMAKE(APPDATA_PS_MIME_TYPES)\nif test \"x$enable_dvi\" = \"xyes\"; then\n        DVI_MIME_TYPES=\"application/x-dvi;application/x-bzdvi;application/x-gzdvi;application/x-ext-dvi\"\n        APPDATA_DVI_MIME_TYPES=$(echo \"<mimetype>$DVI_MIME_TYPES</mimetype>\" | sed -e 's/;/<\\/mimetype>\\n    <mimetype>/g')\n        if test -z \"$EVINCE_MIME_TYPES\"; then\n           EVINCE_MIME_TYPES=\"${DVI_MIME_TYPES}\"\n        else\n           EVINCE_MIME_TYPES=\"${EVINCE_MIME_TYPES};${DVI_MIME_TYPES}\"\n        fi\nfi\nAC_SUBST(DVI_MIME_TYPES)\nAC_SUBST(APPDATA_DVI_MIME_TYPES)\nAM_SUBST_NOTMAKE(APPDATA_DVI_MIME_TYPES)\nif test \"x$enable_djvu\" = \"xyes\"; then\n        DJVU_MIME_TYPES=\"image/vnd.djvu;image/vnd.djvu+multipage;application/x-ext-djv;application/x-ext-djvu\"\n        APPDATA_DJVU_MIME_TYPES=$(echo \"<mimetype>$DJVU_MIME_TYPES</mimetype>\" | sed -e 's/;/<\\/mimetype>\\n    <mimetype>/g')\n        if test -z \"$EVINCE_MIME_TYPES\"; then\n           EVINCE_MIME_TYPES=\"${DJVU_MIME_TYPES}\"\n        else\n           EVINCE_MIME_TYPES=\"${EVINCE_MIME_TYPES};${DJVU_MIME_TYPES}\"\n        fi\nfi\nAC_SUBST(DJVU_MIME_TYPES)\nAC_SUBST(APPDATA_DJVU_MIME_TYPES)\nAM_SUBST_NOTMAKE(APPDATA_DJVU_MIME_TYPES)\nif test \"x$enable_tiff\" = \"xyes\"; then\n        TIFF_MIME_TYPES=\"image/tiff\"\n        APPDATA_TIFF_MIME_TYPES=$(echo \"<mimetype>$TIFF_MIME_TYPES</mimetype>\" | sed -e 's/;/<\\/mimetype>\\n    <mimetype>/g')\n        if test -z \"$EVINCE_MIME_TYPES\"; then\n           EVINCE_MIME_TYPES=\"${TIFF_MIME_TYPES}\"\n        else\n           EVINCE_MIME_TYPES=\"${EVINCE_MIME_TYPES};${TIFF_MIME_TYPES}\"\n        fi\nfi\nAC_SUBST(TIFF_MIME_TYPES)\nAC_SUBST(APPDATA_TIFF_MIME_TYPES)\nAM_SUBST_NOTMAKE(APPDATA_TIFF_MIME_TYPES)\nif test \"x$enable_comics\" = \"xyes\"; then\n        COMICS_MIME_TYPES=\"application/x-cbr;application/x-cbz;application/x-cb7;application/x-ext-cbr;application/x-ext-cbz;application/vnd.comicbook+zip;application/x-ext-cb7;\"\n        APPDATA_COMICS_MIME_TYPES=$(echo \"<mimetype>$COMICS_MIME_TYPES</mimetype>\" | sed -e 's/;/<\\/mimetype>\\n    <mimetype>/g')\n        if test -z \"$EVINCE_MIME_TYPES\"; then\n           EVINCE_MIME_TYPES=\"${COMICS_MIME_TYPES}\"\n        else\n           EVINCE_MIME_TYPES=\"${EVINCE_MIME_TYPES};${COMICS_MIME_TYPES}\"\n        fi\nfi\nAC_SUBST(COMICS_MIME_TYPES)\nAC_SUBST(APPDATA_COMICS_MIME_TYPES)\nAM_SUBST_NOTMAKE(APPDATA_COMICS_MIME_TYPES)\nif test \"x$enable_xps\" = \"xyes\"; then\n        XPS_MIME_TYPES=\"application/oxps;application/vnd.ms-xpsdocument\"\n        APPDATA_XPS_MIME_TYPES=$(echo \"<mimetype>$XPS_MIME_TYPES</mimetype>\" | sed -e 's/;/<\\/mimetype>\\n    <mimetype>/g')\n        if test -z \"$EVINCE_MIME_TYPES\"; then\n           EVINCE_MIME_TYPES=\"${XPS_MIME_TYPES}\"\n        else\n           EVINCE_MIME_TYPES=\"${EVINCE_MIME_TYPES};${XPS_MIME_TYPES}\"\n        fi\nfi\nAC_SUBST(XPS_MIME_TYPES)\nAC_SUBST(APPDATA_XPS_MIME_TYPES)\nAM_SUBST_NOTMAKE(APPDATA_XPS_MIME_TYPES)\n\nAC_SUBST(EVINCE_MIME_TYPES)\n\nAC_CHECK_FUNC(localtime_r, AC_DEFINE(HAVE_LOCALTIME_R, 1, [Defines if localtime_r is available on your system]))\n\n# *****************\n# Help files\n# *****************\n\nYELP_HELP_INIT\n\n# *****************\n# API documentation\n# *****************\n\nGTK_DOC_CHECK([1.13],[--flavour no-tmpl])\n\nAC_SUBST([GLIB_PREFIX],[$($PKG_CONFIG --variable=prefix glib-2.0)])\nAC_SUBST([GTK_PREFIX],[$($PKG_CONFIG --variable=prefix gtk+-3.0)])\n\n# ******************\n# Backends directory\n# ******************\n\nAC_SUBST([backenddir],\"\\$(libdir)/evince/ev_binary_version/backends\")\nAC_SUBST([backend_binary_version],\"ev_binary_version\")\n\n# **********\n# Versioning\n# **********\n\nAC_SUBST([EV_MAJOR_VERSION],[ev_major_version])\nAC_SUBST([EV_MINOR_VERSION],[ev_minor_version])\nAC_SUBST([EV_MICRO_VERSION],[ev_micro_version])\n\nAC_SUBST([EV_API_VERSION],[ev_api_version])\nAC_SUBST([EV_API_VERSION_U],[AS_TR_SH([ev_api_version])])\nAC_SUBST([EV_BINARY_VERSION],[ev_binary_version])\n\nAC_SUBST([EV_DOCUMENT_LT_VERSION_INFO],[ev_document_lt_version_info])\nAC_SUBST([EV_DOCUMENT_LT_CURRENT_MINUS_AGE],[ev_document_lt_current_minus_age])\nAC_SUBST([EV_VIEW_LT_VERSION_INFO],[ev_view_lt_version_info])\nAC_SUBST([EV_VIEW_LT_CURRENT_MINUS_AGE],[ev_view_lt_current_minus_age])\n\nAC_SUBST([AM_CPPFLAGS])\nAC_SUBST([AM_CFLAGS])\nAC_SUBST([AM_CXXFLAGS])\nAC_SUBST([AM_LDFLAGS])\n\n# *****************************************************************************\n# *****************************************************************************\n\nAC_CONFIG_FILES([\nbackend/Makefile\nbackend/comics/comicsdocument.evince-backend.in\nbackend/comics/evince-comicsdocument.metainfo.xml.in\nbackend/comics/Makefile\nbackend/djvu/djvudocument.evince-backend.in\nbackend/djvu/evince-djvudocument.metainfo.xml.in\nbackend/djvu/Makefile\nbackend/dvi/dvidocument.evince-backend.in\nbackend/dvi/evince-dvidocument.metainfo.xml.in\nbackend/dvi/Makefile\nbackend/dvi/mdvi-lib/Makefile\nbackend/pdf/evince-pdfdocument.metainfo.xml.in\nbackend/pdf/pdfdocument.evince-backend.in\nbackend/pdf/Makefile\nbackend/ps/evince-psdocument.metainfo.xml.in\nbackend/ps/psdocument.evince-backend.in\nbackend/ps/Makefile\nbackend/tiff/evince-tiffdocument.metainfo.xml.in\nbackend/tiff/tiffdocument.evince-backend.in\nbackend/tiff/Makefile\nbackend/xps/evince-xpsdocument.metainfo.xml.in\nbackend/xps/xpsdocument.evince-backend.in\nbackend/xps/Makefile\nbrowser-plugin/Makefile\ncut-n-paste/Makefile\ncut-n-paste/gimpcellrenderertoggle/Makefile\ncut-n-paste/synctex/Makefile\ncut-n-paste/libgd/Makefile\ndata/evince.desktop.in\ndata/evince-previewer.desktop.in\ndata/Makefile\ndata/icons/Makefile\ndata/icons/16x16/Makefile\ndata/icons/16x16/apps/Makefile\ndata/icons/16x16/actions/Makefile\ndata/icons/16x16/mimetypes/Makefile\ndata/icons/22x22/Makefile\ndata/icons/22x22/apps/Makefile\ndata/icons/22x22/actions/Makefile\ndata/icons/22x22/mimetypes/Makefile\ndata/icons/24x24/Makefile\ndata/icons/24x24/apps/Makefile\ndata/icons/24x24/actions/Makefile\ndata/icons/24x24/mimetypes/Makefile\ndata/icons/32x32/Makefile\ndata/icons/32x32/actions/Makefile\ndata/icons/32x32/mimetypes/Makefile\ndata/icons/48x48/Makefile\ndata/icons/48x48/apps/Makefile\ndata/icons/48x48/actions/Makefile\ndata/icons/256x256/Makefile\ndata/icons/256x256/apps/Makefile\ndata/icons/scalable/Makefile\ndata/icons/scalable/actions/Makefile\ndata/icons/scalable/mimetypes/Makefile\ndata/icons/symbolic/Makefile\ndata/icons/symbolic/apps/Makefile\nhelp/Makefile\nhelp/reference/Makefile\nhelp/reference/libdocument/Makefile\nhelp/reference/libdocument/version.xml\nhelp/reference/libview/Makefile\nhelp/reference/libview/version.xml\nhelp/reference/shell/Makefile\nhelp/reference/shell/version.xml\nlibdocument/Makefile\nlibdocument/ev-version.h\nlibmisc/Makefile\nlibview/Makefile\nMakefile\npo/Makefile.in\npreviewer/Makefile\nproperties/Makefile\nshell/Makefile\nthumbnailer/Makefile\n])\n\nAC_CONFIG_FILES(evince-document-[]ev_api_version[].pc:evince-document.pc.in)\nAC_CONFIG_FILES(evince-view-[]ev_api_version[].pc:evince-view.pc.in)\n\nAC_OUTPUT\n\nAC_MSG_NOTICE([\n\nEvince configure summary\n========================\n\nPlatform .................:  $with_platform\nDebug mode ...............:  $enable_debug\n\n\nFRONTENDS\n\nViewer ...................:  $enable_viewer\nPreviewer ................:  $enable_previewer\nThumbnailer ..............:  $enable_thumbnailer\nNautilus Extensions.......:  $enable_nautilus\nBrowser Plugin............:  $enable_browser_plugin\n\n\nBACKENDS\n\nPDF ......................:  $enable_pdf\nPostScript ...............:  $enable_ps\nTIFF .....................:  $enable_tiff\nDJVU .....................:  $enable_djvu\nDVI ......................:  $enable_dvi\nComics ...................:  $enable_comics\nXPS ......................:  $enable_xps\n\n\nFEATURES\n\nGTK Doc reference ........:  $enable_gtk_doc\nGObject Introspection ....:  $enable_introspection\nDBUS communication .......:  $enable_dbus\nKeyring integration ......:  $with_keyring\nGTK+ Unix Print ..........:  $with_gtk_unix_print\nThumbnail cache ..........:  $enable_gnome_desktop\nMultimedia ...............:  $enable_multimedia\n\n])\n"], "filenames": ["backend/comics/comics-document.c", "configure.ac"], "buggy_code_start_loc": [59, 798], "buggy_code_end_loc": [447, 799], "fixing_code_start_loc": [59, 798], "fixing_code_end_loc": [408, 799], "type": "NVD-CWE-noinfo", "message": "backend/comics/comics-document.c (aka the comic book backend) in GNOME Evince before 3.24.1 allows remote attackers to execute arbitrary commands via a .cbt file that is a TAR archive containing a filename beginning with a \"--\" command-line option substring, as demonstrated by a --checkpoint-action=exec=bash at the beginning of the filename.", "other": {"cve": {"id": "CVE-2017-1000083", "sourceIdentifier": "cve@mitre.org", "published": "2017-09-05T06:29:00.180", "lastModified": "2019-10-03T00:03:26.223", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "backend/comics/comics-document.c (aka the comic book backend) in GNOME Evince before 3.24.1 allows remote attackers to execute arbitrary commands via a .cbt file that is a TAR archive containing a filename beginning with a \"--\" command-line option substring, as demonstrated by a --checkpoint-action=exec=bash at the beginning of the filename."}, {"lang": "es", "value": "El archivo backend/comics/comics-document.c (tambi\u00e9n conocido como comic book backend) en versiones anteriores a la v3.24.1 de GNOME Evince permite que atacantes remotos ejecuten comandos arbitrarios utilizando un archivo .cbt, que es un archivo TAR que contiene un nombre de archivo que comienza con un substring de opci\u00f3n de l\u00ednea de comandos \"--\". Esto ha sido demostrado con --checkpoint-action=exec=bash al principio del nombre de archivo."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:gnome:evince:*:*:*:*:*:*:*:*", "versionEndIncluding": "3.24.0", "matchCriteriaId": "9131D549-DC0E-48F3-96E9-5609E294B9C8"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_desktop:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "33C068A4-3780-4EAB-A937-6082DF847564"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "51EF4996-72F4-4FA4-814F-F5991E7A8318"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server:7.4:*:*:*:*:*:*:*", "matchCriteriaId": "DA4AB18C-40FC-4E48-830D-481A97B34256"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server:7.5:*:*:*:*:*:*:*", "matchCriteriaId": "24D3235A-DB42-4868-90D9-712C3B3693AE"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server:7.6:*:*:*:*:*:*:*", "matchCriteriaId": "5E92F9B3-3841-4C05-88F0-CEB0735EA4BB"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_aus:7.4:*:*:*:*:*:*:*", "matchCriteriaId": "D99A687E-EAE6-417E-A88E-D0082BC194CD"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_aus:7.6:*:*:*:*:*:*:*", "matchCriteriaId": "B353CE99-D57C-465B-AAB0-73EF581127D1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_eus:7.4:*:*:*:*:*:*:*", "matchCriteriaId": "9EC0D196-F7B8-4BDD-9050-779F7A7FBEE4"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_eus:7.5:*:*:*:*:*:*:*", "matchCriteriaId": "A4E9DD8A-A68B-4A69-8B01-BFF92A2020A8"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_eus:7.6:*:*:*:*:*:*:*", "matchCriteriaId": "BF77CDCF-B9C9-427D-B2BF-36650FB2148C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_tus:7.4:*:*:*:*:*:*:*", "matchCriteriaId": "D5F7E11E-FB34-4467-8919-2B6BEAABF665"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_tus:7.6:*:*:*:*:*:*:*", "matchCriteriaId": "B76AA310-FEC7-497F-AF04-C3EC1E76C4CC"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_workstation:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "825ECE2D-E232-46E0-A047-074B34DB1E97"}]}]}], "references": [{"url": "http://seclists.org/oss-sec/2017/q3/128", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://www.debian.org/security/2017/dsa-3911", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/99597", "source": "cve@mitre.org", "tags": ["VDB Entry", "Third Party Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2017:2388", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://bugzilla.gnome.org/show_bug.cgi?id=784630", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://github.com/GNOME/evince/commit/717df38fd8509bf883b70d680c9b1b3cf36732ee", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://www.exploit-db.com/exploits/45824/", "source": "cve@mitre.org", "tags": ["Exploit", "VDB Entry", "Third Party Advisory"]}, {"url": "https://www.exploit-db.com/exploits/46341/", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory", "VDB Entry"]}]}, "github_commit_url": "https://github.com/GNOME/evince/commit/717df38fd8509bf883b70d680c9b1b3cf36732ee"}}