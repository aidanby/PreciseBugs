{"buggy_code": ["/*\n * Copyright 2012 The Netty Project\n *\n * The Netty Project licenses this file to you under the Apache License,\n * version 2.0 (the \"License\"); you may not use this file except in compliance\n * with the License. You may obtain a copy of the License at:\n *\n *   https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations\n * under the License.\n */\npackage io.netty.handler.codec.http;\n\nimport static io.netty.util.internal.ObjectUtil.checkPositive;\nimport static io.netty.util.internal.StringUtil.COMMA;\n\nimport io.netty.buffer.ByteBuf;\nimport io.netty.buffer.Unpooled;\nimport io.netty.channel.ChannelHandlerContext;\nimport io.netty.channel.ChannelPipeline;\nimport io.netty.handler.codec.ByteToMessageDecoder;\nimport io.netty.handler.codec.DecoderResult;\nimport io.netty.handler.codec.PrematureChannelClosureException;\nimport io.netty.handler.codec.TooLongFrameException;\nimport io.netty.util.ByteProcessor;\nimport io.netty.util.internal.AppendableCharSequence;\n\nimport java.util.List;\nimport java.util.regex.Pattern;\n\n/**\n * Decodes {@link ByteBuf}s into {@link HttpMessage}s and\n * {@link HttpContent}s.\n *\n * <h3>Parameters that prevents excessive memory consumption</h3>\n * <table border=\"1\">\n * <tr>\n * <th>Name</th><th>Default value</th><th>Meaning</th>\n * </tr>\n * <tr>\n * <td>{@code maxInitialLineLength}</td>\n * <td>{@value #DEFAULT_MAX_INITIAL_LINE_LENGTH}</td>\n * <td>The maximum length of the initial line\n *     (e.g. {@code \"GET / HTTP/1.0\"} or {@code \"HTTP/1.0 200 OK\"})\n *     If the length of the initial line exceeds this value, a\n *     {@link TooLongFrameException} will be raised.</td>\n * </tr>\n * <tr>\n * <td>{@code maxHeaderSize}</td>\n * <td>{@value #DEFAULT_MAX_HEADER_SIZE}</td>\n * <td>The maximum length of all headers.  If the sum of the length of each\n *     header exceeds this value, a {@link TooLongFrameException} will be raised.</td>\n * </tr>\n * <tr>\n * <td>{@code maxChunkSize}</td>\n * <td>{@value #DEFAULT_MAX_CHUNK_SIZE}</td>\n * <td>The maximum length of the content or each chunk.  If the content length\n *     (or the length of each chunk) exceeds this value, the content or chunk\n *     will be split into multiple {@link HttpContent}s whose length is\n *     {@code maxChunkSize} at maximum.</td>\n * </tr>\n * </table>\n *\n * <h3>Parameters that control parsing behavior</h3>\n * <table border=\"1\">\n * <tr>\n * <th>Name</th><th>Default value</th><th>Meaning</th>\n * </tr>\n * <tr>\n * <td>{@code allowDuplicateContentLengths}</td>\n * <td>{@value #DEFAULT_ALLOW_DUPLICATE_CONTENT_LENGTHS}</td>\n * <td>When set to {@code false}, will reject any messages that contain multiple Content-Length header fields.\n *     When set to {@code true}, will allow multiple Content-Length headers only if they are all the same decimal value.\n *     The duplicated field-values will be replaced with a single valid Content-Length field.\n *     See <a href=\"https://tools.ietf.org/html/rfc7230#section-3.3.2\">RFC 7230, Section 3.3.2</a>.</td>\n * </tr>\n * </table>\n *\n * <h3>Chunked Content</h3>\n *\n * If the content of an HTTP message is greater than {@code maxChunkSize} or\n * the transfer encoding of the HTTP message is 'chunked', this decoder\n * generates one {@link HttpMessage} instance and its following\n * {@link HttpContent}s per single HTTP message to avoid excessive memory\n * consumption. For example, the following HTTP message:\n * <pre>\n * GET / HTTP/1.1\n * Transfer-Encoding: chunked\n *\n * 1a\n * abcdefghijklmnopqrstuvwxyz\n * 10\n * 1234567890abcdef\n * 0\n * Content-MD5: ...\n * <i>[blank line]</i>\n * </pre>\n * triggers {@link HttpRequestDecoder} to generate 3 objects:\n * <ol>\n * <li>An {@link HttpRequest},</li>\n * <li>The first {@link HttpContent} whose content is {@code 'abcdefghijklmnopqrstuvwxyz'},</li>\n * <li>The second {@link LastHttpContent} whose content is {@code '1234567890abcdef'}, which marks\n * the end of the content.</li>\n * </ol>\n *\n * If you prefer not to handle {@link HttpContent}s by yourself for your\n * convenience, insert {@link HttpObjectAggregator} after this decoder in the\n * {@link ChannelPipeline}.  However, please note that your server might not\n * be as memory efficient as without the aggregator.\n *\n * <h3>Extensibility</h3>\n *\n * Please note that this decoder is designed to be extended to implement\n * a protocol derived from HTTP, such as\n * <a href=\"https://en.wikipedia.org/wiki/Real_Time_Streaming_Protocol\">RTSP</a> and\n * <a href=\"https://en.wikipedia.org/wiki/Internet_Content_Adaptation_Protocol\">ICAP</a>.\n * To implement the decoder of such a derived protocol, extend this class and\n * implement all abstract methods properly.\n */\npublic abstract class HttpObjectDecoder extends ByteToMessageDecoder {\n    public static final int DEFAULT_MAX_INITIAL_LINE_LENGTH = 4096;\n    public static final int DEFAULT_MAX_HEADER_SIZE = 8192;\n    public static final boolean DEFAULT_CHUNKED_SUPPORTED = true;\n    public static final int DEFAULT_MAX_CHUNK_SIZE = 8192;\n    public static final boolean DEFAULT_VALIDATE_HEADERS = true;\n    public static final int DEFAULT_INITIAL_BUFFER_SIZE = 128;\n    public static final boolean DEFAULT_ALLOW_DUPLICATE_CONTENT_LENGTHS = false;\n\n    private static final String EMPTY_VALUE = \"\";\n    private static final Pattern COMMA_PATTERN = Pattern.compile(\",\");\n\n    private final int maxChunkSize;\n    private final boolean chunkedSupported;\n    protected final boolean validateHeaders;\n    private final boolean allowDuplicateContentLengths;\n    private final HeaderParser headerParser;\n    private final LineParser lineParser;\n\n    private HttpMessage message;\n    private long chunkSize;\n    private long contentLength = Long.MIN_VALUE;\n    private volatile boolean resetRequested;\n\n    // These will be updated by splitHeader(...)\n    private CharSequence name;\n    private CharSequence value;\n\n    private LastHttpContent trailer;\n\n    /**\n     * The internal state of {@link HttpObjectDecoder}.\n     * <em>Internal use only</em>.\n     */\n    private enum State {\n        SKIP_CONTROL_CHARS,\n        READ_INITIAL,\n        READ_HEADER,\n        READ_VARIABLE_LENGTH_CONTENT,\n        READ_FIXED_LENGTH_CONTENT,\n        READ_CHUNK_SIZE,\n        READ_CHUNKED_CONTENT,\n        READ_CHUNK_DELIMITER,\n        READ_CHUNK_FOOTER,\n        BAD_MESSAGE,\n        UPGRADED\n    }\n\n    private State currentState = State.SKIP_CONTROL_CHARS;\n\n    /**\n     * Creates a new instance with the default\n     * {@code maxInitialLineLength (4096}}, {@code maxHeaderSize (8192)}, and\n     * {@code maxChunkSize (8192)}.\n     */\n    protected HttpObjectDecoder() {\n        this(DEFAULT_MAX_INITIAL_LINE_LENGTH, DEFAULT_MAX_HEADER_SIZE, DEFAULT_MAX_CHUNK_SIZE,\n             DEFAULT_CHUNKED_SUPPORTED);\n    }\n\n    /**\n     * Creates a new instance with the specified parameters.\n     */\n    protected HttpObjectDecoder(\n            int maxInitialLineLength, int maxHeaderSize, int maxChunkSize, boolean chunkedSupported) {\n        this(maxInitialLineLength, maxHeaderSize, maxChunkSize, chunkedSupported, DEFAULT_VALIDATE_HEADERS);\n    }\n\n    /**\n     * Creates a new instance with the specified parameters.\n     */\n    protected HttpObjectDecoder(\n            int maxInitialLineLength, int maxHeaderSize, int maxChunkSize,\n            boolean chunkedSupported, boolean validateHeaders) {\n        this(maxInitialLineLength, maxHeaderSize, maxChunkSize, chunkedSupported, validateHeaders,\n             DEFAULT_INITIAL_BUFFER_SIZE);\n    }\n\n    /**\n     * Creates a new instance with the specified parameters.\n     */\n    protected HttpObjectDecoder(\n            int maxInitialLineLength, int maxHeaderSize, int maxChunkSize,\n            boolean chunkedSupported, boolean validateHeaders, int initialBufferSize) {\n        this(maxInitialLineLength, maxHeaderSize, maxChunkSize, chunkedSupported, validateHeaders, initialBufferSize,\n             DEFAULT_ALLOW_DUPLICATE_CONTENT_LENGTHS);\n    }\n\n    protected HttpObjectDecoder(\n            int maxInitialLineLength, int maxHeaderSize, int maxChunkSize,\n            boolean chunkedSupported, boolean validateHeaders, int initialBufferSize,\n            boolean allowDuplicateContentLengths) {\n        checkPositive(maxInitialLineLength, \"maxInitialLineLength\");\n        checkPositive(maxHeaderSize, \"maxHeaderSize\");\n        checkPositive(maxChunkSize, \"maxChunkSize\");\n\n        AppendableCharSequence seq = new AppendableCharSequence(initialBufferSize);\n        lineParser = new LineParser(seq, maxInitialLineLength);\n        headerParser = new HeaderParser(seq, maxHeaderSize);\n        this.maxChunkSize = maxChunkSize;\n        this.chunkedSupported = chunkedSupported;\n        this.validateHeaders = validateHeaders;\n        this.allowDuplicateContentLengths = allowDuplicateContentLengths;\n    }\n\n    @Override\n    protected void decode(ChannelHandlerContext ctx, ByteBuf buffer, List<Object> out) throws Exception {\n        if (resetRequested) {\n            resetNow();\n        }\n\n        switch (currentState) {\n        case SKIP_CONTROL_CHARS:\n            // Fall-through\n        case READ_INITIAL: try {\n            AppendableCharSequence line = lineParser.parse(buffer);\n            if (line == null) {\n                return;\n            }\n            String[] initialLine = splitInitialLine(line);\n            if (initialLine.length < 3) {\n                // Invalid initial line - ignore.\n                currentState = State.SKIP_CONTROL_CHARS;\n                return;\n            }\n\n            message = createMessage(initialLine);\n            currentState = State.READ_HEADER;\n            // fall-through\n        } catch (Exception e) {\n            out.add(invalidMessage(buffer, e));\n            return;\n        }\n        case READ_HEADER: try {\n            State nextState = readHeaders(buffer);\n            if (nextState == null) {\n                return;\n            }\n            currentState = nextState;\n            switch (nextState) {\n            case SKIP_CONTROL_CHARS:\n                // fast-path\n                // No content is expected.\n                out.add(message);\n                out.add(LastHttpContent.EMPTY_LAST_CONTENT);\n                resetNow();\n                return;\n            case READ_CHUNK_SIZE:\n                if (!chunkedSupported) {\n                    throw new IllegalArgumentException(\"Chunked messages not supported\");\n                }\n                // Chunked encoding - generate HttpMessage first.  HttpChunks will follow.\n                out.add(message);\n                return;\n            default:\n                /**\n                 * <a href=\"https://tools.ietf.org/html/rfc7230#section-3.3.3\">RFC 7230, 3.3.3</a> states that if a\n                 * request does not have either a transfer-encoding or a content-length header then the message body\n                 * length is 0. However for a response the body length is the number of octets received prior to the\n                 * server closing the connection. So we treat this as variable length chunked encoding.\n                 */\n                long contentLength = contentLength();\n                if (contentLength == 0 || contentLength == -1 && isDecodingRequest()) {\n                    out.add(message);\n                    out.add(LastHttpContent.EMPTY_LAST_CONTENT);\n                    resetNow();\n                    return;\n                }\n\n                assert nextState == State.READ_FIXED_LENGTH_CONTENT ||\n                        nextState == State.READ_VARIABLE_LENGTH_CONTENT;\n\n                out.add(message);\n\n                if (nextState == State.READ_FIXED_LENGTH_CONTENT) {\n                    // chunkSize will be decreased as the READ_FIXED_LENGTH_CONTENT state reads data chunk by chunk.\n                    chunkSize = contentLength;\n                }\n\n                // We return here, this forces decode to be called again where we will decode the content\n                return;\n            }\n        } catch (Exception e) {\n            out.add(invalidMessage(buffer, e));\n            return;\n        }\n        case READ_VARIABLE_LENGTH_CONTENT: {\n            // Keep reading data as a chunk until the end of connection is reached.\n            int toRead = Math.min(buffer.readableBytes(), maxChunkSize);\n            if (toRead > 0) {\n                ByteBuf content = buffer.readRetainedSlice(toRead);\n                out.add(new DefaultHttpContent(content));\n            }\n            return;\n        }\n        case READ_FIXED_LENGTH_CONTENT: {\n            int readLimit = buffer.readableBytes();\n\n            // Check if the buffer is readable first as we use the readable byte count\n            // to create the HttpChunk. This is needed as otherwise we may end up with\n            // create an HttpChunk instance that contains an empty buffer and so is\n            // handled like it is the last HttpChunk.\n            //\n            // See https://github.com/netty/netty/issues/433\n            if (readLimit == 0) {\n                return;\n            }\n\n            int toRead = Math.min(readLimit, maxChunkSize);\n            if (toRead > chunkSize) {\n                toRead = (int) chunkSize;\n            }\n            ByteBuf content = buffer.readRetainedSlice(toRead);\n            chunkSize -= toRead;\n\n            if (chunkSize == 0) {\n                // Read all content.\n                out.add(new DefaultLastHttpContent(content, validateHeaders));\n                resetNow();\n            } else {\n                out.add(new DefaultHttpContent(content));\n            }\n            return;\n        }\n        /**\n         * everything else after this point takes care of reading chunked content. basically, read chunk size,\n         * read chunk, read and ignore the CRLF and repeat until 0\n         */\n        case READ_CHUNK_SIZE: try {\n            AppendableCharSequence line = lineParser.parse(buffer);\n            if (line == null) {\n                return;\n            }\n            int chunkSize = getChunkSize(line.toString());\n            this.chunkSize = chunkSize;\n            if (chunkSize == 0) {\n                currentState = State.READ_CHUNK_FOOTER;\n                return;\n            }\n            currentState = State.READ_CHUNKED_CONTENT;\n            // fall-through\n        } catch (Exception e) {\n            out.add(invalidChunk(buffer, e));\n            return;\n        }\n        case READ_CHUNKED_CONTENT: {\n            assert chunkSize <= Integer.MAX_VALUE;\n            int toRead = Math.min((int) chunkSize, maxChunkSize);\n            toRead = Math.min(toRead, buffer.readableBytes());\n            if (toRead == 0) {\n                return;\n            }\n            HttpContent chunk = new DefaultHttpContent(buffer.readRetainedSlice(toRead));\n            chunkSize -= toRead;\n\n            out.add(chunk);\n\n            if (chunkSize != 0) {\n                return;\n            }\n            currentState = State.READ_CHUNK_DELIMITER;\n            // fall-through\n        }\n        case READ_CHUNK_DELIMITER: {\n            final int wIdx = buffer.writerIndex();\n            int rIdx = buffer.readerIndex();\n            while (wIdx > rIdx) {\n                byte next = buffer.getByte(rIdx++);\n                if (next == HttpConstants.LF) {\n                    currentState = State.READ_CHUNK_SIZE;\n                    break;\n                }\n            }\n            buffer.readerIndex(rIdx);\n            return;\n        }\n        case READ_CHUNK_FOOTER: try {\n            LastHttpContent trailer = readTrailingHeaders(buffer);\n            if (trailer == null) {\n                return;\n            }\n            out.add(trailer);\n            resetNow();\n            return;\n        } catch (Exception e) {\n            out.add(invalidChunk(buffer, e));\n            return;\n        }\n        case BAD_MESSAGE: {\n            // Keep discarding until disconnection.\n            buffer.skipBytes(buffer.readableBytes());\n            break;\n        }\n        case UPGRADED: {\n            int readableBytes = buffer.readableBytes();\n            if (readableBytes > 0) {\n                // Keep on consuming as otherwise we may trigger an DecoderException,\n                // other handler will replace this codec with the upgraded protocol codec to\n                // take the traffic over at some point then.\n                // See https://github.com/netty/netty/issues/2173\n                out.add(buffer.readBytes(readableBytes));\n            }\n            break;\n        }\n        }\n    }\n\n    @Override\n    protected void decodeLast(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) throws Exception {\n        super.decodeLast(ctx, in, out);\n\n        if (resetRequested) {\n            // If a reset was requested by decodeLast() we need to do it now otherwise we may produce a\n            // LastHttpContent while there was already one.\n            resetNow();\n        }\n        // Handle the last unfinished message.\n        if (message != null) {\n            boolean chunked = HttpUtil.isTransferEncodingChunked(message);\n            if (currentState == State.READ_VARIABLE_LENGTH_CONTENT && !in.isReadable() && !chunked) {\n                // End of connection.\n                out.add(LastHttpContent.EMPTY_LAST_CONTENT);\n                resetNow();\n                return;\n            }\n\n            if (currentState == State.READ_HEADER) {\n                // If we are still in the state of reading headers we need to create a new invalid message that\n                // signals that the connection was closed before we received the headers.\n                out.add(invalidMessage(Unpooled.EMPTY_BUFFER,\n                        new PrematureChannelClosureException(\"Connection closed before received headers\")));\n                resetNow();\n                return;\n            }\n\n            // Check if the closure of the connection signifies the end of the content.\n            boolean prematureClosure;\n            if (isDecodingRequest() || chunked) {\n                // The last request did not wait for a response.\n                prematureClosure = true;\n            } else {\n                // Compare the length of the received content and the 'Content-Length' header.\n                // If the 'Content-Length' header is absent, the length of the content is determined by the end of the\n                // connection, so it is perfectly fine.\n                prematureClosure = contentLength() > 0;\n            }\n\n            if (!prematureClosure) {\n                out.add(LastHttpContent.EMPTY_LAST_CONTENT);\n            }\n            resetNow();\n        }\n    }\n\n    @Override\n    public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception {\n        if (evt instanceof HttpExpectationFailedEvent) {\n            switch (currentState) {\n            case READ_FIXED_LENGTH_CONTENT:\n            case READ_VARIABLE_LENGTH_CONTENT:\n            case READ_CHUNK_SIZE:\n                reset();\n                break;\n            default:\n                break;\n            }\n        }\n        super.userEventTriggered(ctx, evt);\n    }\n\n    protected boolean isContentAlwaysEmpty(HttpMessage msg) {\n        if (msg instanceof HttpResponse) {\n            HttpResponse res = (HttpResponse) msg;\n            int code = res.status().code();\n\n            // Correctly handle return codes of 1xx.\n            //\n            // See:\n            //     - https://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html Section 4.4\n            //     - https://github.com/netty/netty/issues/222\n            if (code >= 100 && code < 200) {\n                // One exception: Hixie 76 websocket handshake response\n                return !(code == 101 && !res.headers().contains(HttpHeaderNames.SEC_WEBSOCKET_ACCEPT)\n                         && res.headers().contains(HttpHeaderNames.UPGRADE, HttpHeaderValues.WEBSOCKET, true));\n            }\n\n            switch (code) {\n            case 204: case 304:\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Returns true if the server switched to a different protocol than HTTP/1.0 or HTTP/1.1, e.g. HTTP/2 or Websocket.\n     * Returns false if the upgrade happened in a different layer, e.g. upgrade from HTTP/1.1 to HTTP/1.1 over TLS.\n     */\n    protected boolean isSwitchingToNonHttp1Protocol(HttpResponse msg) {\n        if (msg.status().code() != HttpResponseStatus.SWITCHING_PROTOCOLS.code()) {\n            return false;\n        }\n        String newProtocol = msg.headers().get(HttpHeaderNames.UPGRADE);\n        return newProtocol == null ||\n                !newProtocol.contains(HttpVersion.HTTP_1_0.text()) &&\n                !newProtocol.contains(HttpVersion.HTTP_1_1.text());\n    }\n\n    /**\n     * Resets the state of the decoder so that it is ready to decode a new message.\n     * This method is useful for handling a rejected request with {@code Expect: 100-continue} header.\n     */\n    public void reset() {\n        resetRequested = true;\n    }\n\n    private void resetNow() {\n        HttpMessage message = this.message;\n        this.message = null;\n        name = null;\n        value = null;\n        contentLength = Long.MIN_VALUE;\n        lineParser.reset();\n        headerParser.reset();\n        trailer = null;\n        if (!isDecodingRequest()) {\n            HttpResponse res = (HttpResponse) message;\n            if (res != null && isSwitchingToNonHttp1Protocol(res)) {\n                currentState = State.UPGRADED;\n                return;\n            }\n        }\n\n        resetRequested = false;\n        currentState = State.SKIP_CONTROL_CHARS;\n    }\n\n    private HttpMessage invalidMessage(ByteBuf in, Exception cause) {\n        currentState = State.BAD_MESSAGE;\n\n        // Advance the readerIndex so that ByteToMessageDecoder does not complain\n        // when we produced an invalid message without consuming anything.\n        in.skipBytes(in.readableBytes());\n\n        if (message == null) {\n            message = createInvalidMessage();\n        }\n        message.setDecoderResult(DecoderResult.failure(cause));\n\n        HttpMessage ret = message;\n        message = null;\n        return ret;\n    }\n\n    private HttpContent invalidChunk(ByteBuf in, Exception cause) {\n        currentState = State.BAD_MESSAGE;\n\n        // Advance the readerIndex so that ByteToMessageDecoder does not complain\n        // when we produced an invalid message without consuming anything.\n        in.skipBytes(in.readableBytes());\n\n        HttpContent chunk = new DefaultLastHttpContent(Unpooled.EMPTY_BUFFER);\n        chunk.setDecoderResult(DecoderResult.failure(cause));\n        message = null;\n        trailer = null;\n        return chunk;\n    }\n\n    private State readHeaders(ByteBuf buffer) {\n        final HttpMessage message = this.message;\n        final HttpHeaders headers = message.headers();\n\n        AppendableCharSequence line = headerParser.parse(buffer);\n        if (line == null) {\n            return null;\n        }\n        if (line.length() > 0) {\n            do {\n                char firstChar = line.charAtUnsafe(0);\n                if (name != null && (firstChar == ' ' || firstChar == '\\t')) {\n                    //please do not make one line from below code\n                    //as it breaks +XX:OptimizeStringConcat optimization\n                    String trimmedLine = line.toString().trim();\n                    String valueStr = String.valueOf(value);\n                    value = valueStr + ' ' + trimmedLine;\n                } else {\n                    if (name != null) {\n                        headers.add(name, value);\n                    }\n                    splitHeader(line);\n                }\n\n                line = headerParser.parse(buffer);\n                if (line == null) {\n                    return null;\n                }\n            } while (line.length() > 0);\n        }\n\n        // Add the last header.\n        if (name != null) {\n            headers.add(name, value);\n        }\n\n        // reset name and value fields\n        name = null;\n        value = null;\n\n        List<String> contentLengthFields = headers.getAll(HttpHeaderNames.CONTENT_LENGTH);\n\n        if (!contentLengthFields.isEmpty()) {\n            // Guard against multiple Content-Length headers as stated in\n            // https://tools.ietf.org/html/rfc7230#section-3.3.2:\n            //\n            // If a message is received that has multiple Content-Length header\n            //   fields with field-values consisting of the same decimal value, or a\n            //   single Content-Length header field with a field value containing a\n            //   list of identical decimal values (e.g., \"Content-Length: 42, 42\"),\n            //   indicating that duplicate Content-Length header fields have been\n            //   generated or combined by an upstream message processor, then the\n            //   recipient MUST either reject the message as invalid or replace the\n            //   duplicated field-values with a single valid Content-Length field\n            //   containing that decimal value prior to determining the message body\n            //   length or forwarding the message.\n            boolean multipleContentLengths =\n                    contentLengthFields.size() > 1 || contentLengthFields.get(0).indexOf(COMMA) >= 0;\n            if (multipleContentLengths && message.protocolVersion() == HttpVersion.HTTP_1_1) {\n                if (allowDuplicateContentLengths) {\n                    // Find and enforce that all Content-Length values are the same\n                    String firstValue = null;\n                    for (String field : contentLengthFields) {\n                        String[] tokens = COMMA_PATTERN.split(field, -1);\n                        for (String token : tokens) {\n                            String trimmed = token.trim();\n                            if (firstValue == null) {\n                                firstValue = trimmed;\n                            } else if (!trimmed.equals(firstValue)) {\n                                throw new IllegalArgumentException(\n                                        \"Multiple Content-Length values found: \" + contentLengthFields);\n                            }\n                        }\n                    }\n                    // Replace the duplicated field-values with a single valid Content-Length field\n                    headers.set(HttpHeaderNames.CONTENT_LENGTH, firstValue);\n                    contentLength = Long.parseLong(firstValue);\n                } else {\n                    // Reject the message as invalid\n                    throw new IllegalArgumentException(\n                            \"Multiple Content-Length values found: \" + contentLengthFields);\n                }\n            } else {\n                contentLength = Long.parseLong(contentLengthFields.get(0));\n            }\n        }\n\n        if (isContentAlwaysEmpty(message)) {\n            HttpUtil.setTransferEncodingChunked(message, false);\n            return State.SKIP_CONTROL_CHARS;\n        } else if (HttpUtil.isTransferEncodingChunked(message)) {\n            if (!contentLengthFields.isEmpty() && message.protocolVersion() == HttpVersion.HTTP_1_1) {\n                handleTransferEncodingChunkedWithContentLength(message);\n            }\n            return State.READ_CHUNK_SIZE;\n        } else if (contentLength() >= 0) {\n            return State.READ_FIXED_LENGTH_CONTENT;\n        } else {\n            return State.READ_VARIABLE_LENGTH_CONTENT;\n        }\n    }\n\n    /**\n     * Invoked when a message with both a \"Transfer-Encoding: chunked\" and a \"Content-Length\" header field is detected.\n     * The default behavior is to <i>remove</i> the Content-Length field, but this method could be overridden\n     * to change the behavior (to, e.g., throw an exception and produce an invalid message).\n     * <p>\n     * See: https://tools.ietf.org/html/rfc7230#section-3.3.3\n     * <pre>\n     *     If a message is received with both a Transfer-Encoding and a\n     *     Content-Length header field, the Transfer-Encoding overrides the\n     *     Content-Length.  Such a message might indicate an attempt to\n     *     perform request smuggling (Section 9.5) or response splitting\n     *     (Section 9.4) and ought to be handled as an error.  A sender MUST\n     *     remove the received Content-Length field prior to forwarding such\n     *     a message downstream.\n     * </pre>\n     * Also see:\n     * https://github.com/apache/tomcat/blob/b693d7c1981fa7f51e58bc8c8e72e3fe80b7b773/\n     * java/org/apache/coyote/http11/Http11Processor.java#L747-L755\n     * https://github.com/nginx/nginx/blob/0ad4393e30c119d250415cb769e3d8bc8dce5186/\n     * src/http/ngx_http_request.c#L1946-L1953\n     */\n    protected void handleTransferEncodingChunkedWithContentLength(HttpMessage message) {\n        message.headers().remove(HttpHeaderNames.CONTENT_LENGTH);\n        contentLength = Long.MIN_VALUE;\n    }\n\n    private long contentLength() {\n        if (contentLength == Long.MIN_VALUE) {\n            contentLength = HttpUtil.getContentLength(message, -1L);\n        }\n        return contentLength;\n    }\n\n    private LastHttpContent readTrailingHeaders(ByteBuf buffer) {\n        AppendableCharSequence line = headerParser.parse(buffer);\n        if (line == null) {\n            return null;\n        }\n        LastHttpContent trailer = this.trailer;\n        if (line.length() == 0 && trailer == null) {\n            // We have received the empty line which signals the trailer is complete and did not parse any trailers\n            // before. Just return an empty last content to reduce allocations.\n            return LastHttpContent.EMPTY_LAST_CONTENT;\n        }\n\n        CharSequence lastHeader = null;\n        if (trailer == null) {\n            trailer = this.trailer = new DefaultLastHttpContent(Unpooled.EMPTY_BUFFER, validateHeaders);\n        }\n        while (line.length() > 0) {\n            char firstChar = line.charAtUnsafe(0);\n            if (lastHeader != null && (firstChar == ' ' || firstChar == '\\t')) {\n                List<String> current = trailer.trailingHeaders().getAll(lastHeader);\n                if (!current.isEmpty()) {\n                    int lastPos = current.size() - 1;\n                    //please do not make one line from below code\n                    //as it breaks +XX:OptimizeStringConcat optimization\n                    String lineTrimmed = line.toString().trim();\n                    String currentLastPos = current.get(lastPos);\n                    current.set(lastPos, currentLastPos + lineTrimmed);\n                }\n            } else {\n                splitHeader(line);\n                CharSequence headerName = name;\n                if (!HttpHeaderNames.CONTENT_LENGTH.contentEqualsIgnoreCase(headerName) &&\n                        !HttpHeaderNames.TRANSFER_ENCODING.contentEqualsIgnoreCase(headerName) &&\n                        !HttpHeaderNames.TRAILER.contentEqualsIgnoreCase(headerName)) {\n                    trailer.trailingHeaders().add(headerName, value);\n                }\n                lastHeader = name;\n                // reset name and value fields\n                name = null;\n                value = null;\n            }\n            line = headerParser.parse(buffer);\n            if (line == null) {\n                return null;\n            }\n        }\n\n        this.trailer = null;\n        return trailer;\n    }\n\n    protected abstract boolean isDecodingRequest();\n    protected abstract HttpMessage createMessage(String[] initialLine) throws Exception;\n    protected abstract HttpMessage createInvalidMessage();\n\n    private static int getChunkSize(String hex) {\n        hex = hex.trim();\n        for (int i = 0; i < hex.length(); i ++) {\n            char c = hex.charAt(i);\n            if (c == ';' || Character.isWhitespace(c) || Character.isISOControl(c)) {\n                hex = hex.substring(0, i);\n                break;\n            }\n        }\n\n        return Integer.parseInt(hex, 16);\n    }\n\n    private static String[] splitInitialLine(AppendableCharSequence sb) {\n        int aStart;\n        int aEnd;\n        int bStart;\n        int bEnd;\n        int cStart;\n        int cEnd;\n\n        aStart = findNonSPLenient(sb, 0);\n        aEnd = findSPLenient(sb, aStart);\n\n        bStart = findNonSPLenient(sb, aEnd);\n        bEnd = findSPLenient(sb, bStart);\n\n        cStart = findNonSPLenient(sb, bEnd);\n        cEnd = findEndOfString(sb);\n\n        return new String[] {\n                sb.subStringUnsafe(aStart, aEnd),\n                sb.subStringUnsafe(bStart, bEnd),\n                cStart < cEnd? sb.subStringUnsafe(cStart, cEnd) : \"\" };\n    }\n\n    private void splitHeader(AppendableCharSequence sb) {\n        final int length = sb.length();\n        int nameStart;\n        int nameEnd;\n        int colonEnd;\n        int valueStart;\n        int valueEnd;\n\n        nameStart = findNonWhitespace(sb, 0, false);\n        for (nameEnd = nameStart; nameEnd < length; nameEnd ++) {\n            char ch = sb.charAtUnsafe(nameEnd);\n            // https://tools.ietf.org/html/rfc7230#section-3.2.4\n            //\n            // No whitespace is allowed between the header field-name and colon. In\n            // the past, differences in the handling of such whitespace have led to\n            // security vulnerabilities in request routing and response handling. A\n            // server MUST reject any received request message that contains\n            // whitespace between a header field-name and colon with a response code\n            // of 400 (Bad Request). A proxy MUST remove any such whitespace from a\n            // response message before forwarding the message downstream.\n            if (ch == ':' ||\n                    // In case of decoding a request we will just continue processing and header validation\n                    // is done in the DefaultHttpHeaders implementation.\n                    //\n                    // In the case of decoding a response we will \"skip\" the whitespace.\n                    (!isDecodingRequest() && isOWS(ch))) {\n                break;\n            }\n        }\n\n        if (nameEnd == length) {\n            // There was no colon present at all.\n            throw new IllegalArgumentException(\"No colon found\");\n        }\n\n        for (colonEnd = nameEnd; colonEnd < length; colonEnd ++) {\n            if (sb.charAtUnsafe(colonEnd) == ':') {\n                colonEnd ++;\n                break;\n            }\n        }\n\n        name = sb.subStringUnsafe(nameStart, nameEnd);\n        valueStart = findNonWhitespace(sb, colonEnd, true);\n        if (valueStart == length) {\n            value = EMPTY_VALUE;\n        } else {\n            valueEnd = findEndOfString(sb);\n            value = sb.subStringUnsafe(valueStart, valueEnd);\n        }\n    }\n\n    private static int findNonSPLenient(AppendableCharSequence sb, int offset) {\n        for (int result = offset; result < sb.length(); ++result) {\n            char c = sb.charAtUnsafe(result);\n            // See https://tools.ietf.org/html/rfc7230#section-3.5\n            if (isSPLenient(c)) {\n                continue;\n            }\n            if (Character.isWhitespace(c)) {\n                // Any other whitespace delimiter is invalid\n                throw new IllegalArgumentException(\"Invalid separator\");\n            }\n            return result;\n        }\n        return sb.length();\n    }\n\n    private static int findSPLenient(AppendableCharSequence sb, int offset) {\n        for (int result = offset; result < sb.length(); ++result) {\n            if (isSPLenient(sb.charAtUnsafe(result))) {\n                return result;\n            }\n        }\n        return sb.length();\n    }\n\n    private static boolean isSPLenient(char c) {\n        // See https://tools.ietf.org/html/rfc7230#section-3.5\n        return c == ' ' || c == (char) 0x09 || c == (char) 0x0B || c == (char) 0x0C || c == (char) 0x0D;\n    }\n\n    private static int findNonWhitespace(AppendableCharSequence sb, int offset, boolean validateOWS) {\n        for (int result = offset; result < sb.length(); ++result) {\n            char c = sb.charAtUnsafe(result);\n            if (!Character.isWhitespace(c)) {\n                return result;\n            } else if (validateOWS && !isOWS(c)) {\n                // Only OWS is supported for whitespace\n                throw new IllegalArgumentException(\"Invalid separator, only a single space or horizontal tab allowed,\" +\n                        \" but received a '\" + c + \"' (0x\" + Integer.toHexString(c) + \")\");\n            }\n        }\n        return sb.length();\n    }\n\n    private static int findEndOfString(AppendableCharSequence sb) {\n        for (int result = sb.length() - 1; result > 0; --result) {\n            if (!Character.isWhitespace(sb.charAtUnsafe(result))) {\n                return result + 1;\n            }\n        }\n        return 0;\n    }\n\n    private static boolean isOWS(char ch) {\n        return ch == ' ' || ch == (char) 0x09;\n    }\n\n    private static class HeaderParser implements ByteProcessor {\n        private final AppendableCharSequence seq;\n        private final int maxLength;\n        private int size;\n\n        HeaderParser(AppendableCharSequence seq, int maxLength) {\n            this.seq = seq;\n            this.maxLength = maxLength;\n        }\n\n        public AppendableCharSequence parse(ByteBuf buffer) {\n            final int oldSize = size;\n            seq.reset();\n            int i = buffer.forEachByte(this);\n            if (i == -1) {\n                size = oldSize;\n                return null;\n            }\n            buffer.readerIndex(i + 1);\n            return seq;\n        }\n\n        public void reset() {\n            size = 0;\n        }\n\n        @Override\n        public boolean process(byte value) throws Exception {\n            char nextByte = (char) (value & 0xFF);\n            if (nextByte == HttpConstants.LF) {\n                int len = seq.length();\n                // Drop CR if we had a CRLF pair\n                if (len >= 1 && seq.charAtUnsafe(len - 1) == HttpConstants.CR) {\n                    -- size;\n                    seq.setLength(len - 1);\n                }\n                return false;\n            }\n\n            increaseCount();\n\n            seq.append(nextByte);\n            return true;\n        }\n\n        protected final void increaseCount() {\n            if (++ size > maxLength) {\n                // TODO: Respond with Bad Request and discard the traffic\n                //    or close the connection.\n                //       No need to notify the upstream handlers - just log.\n                //       If decoding a response, just throw an exception.\n                throw newException(maxLength);\n            }\n        }\n\n        protected TooLongFrameException newException(int maxLength) {\n            return new TooLongFrameException(\"HTTP header is larger than \" + maxLength + \" bytes.\");\n        }\n    }\n\n    private final class LineParser extends HeaderParser {\n\n        LineParser(AppendableCharSequence seq, int maxLength) {\n            super(seq, maxLength);\n        }\n\n        @Override\n        public AppendableCharSequence parse(ByteBuf buffer) {\n            // Suppress a warning because HeaderParser.reset() is supposed to be called\n            reset();    // lgtm[java/subtle-inherited-call]\n            return super.parse(buffer);\n        }\n\n        @Override\n        public boolean process(byte value) throws Exception {\n            if (currentState == State.SKIP_CONTROL_CHARS) {\n                char c = (char) (value & 0xFF);\n                if (Character.isISOControl(c) || Character.isWhitespace(c)) {\n                    increaseCount();\n                    return true;\n                }\n                currentState = State.READ_INITIAL;\n            }\n            return super.process(value);\n        }\n\n        @Override\n        protected TooLongFrameException newException(int maxLength) {\n            return new TooLongFrameException(\"An HTTP line is larger than \" + maxLength + \" bytes.\");\n        }\n    }\n}\n", "/*\n * Copyright 2015 The Netty Project\n *\n * The Netty Project licenses this file to you under the Apache License,\n * version 2.0 (the \"License\"); you may not use this file except in compliance\n * with the License. You may obtain a copy of the License at:\n *\n *   https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations\n * under the License.\n */\npackage io.netty.handler.codec.http;\n\nimport java.net.InetSocketAddress;\nimport java.net.URI;\nimport java.nio.charset.Charset;\nimport java.nio.charset.IllegalCharsetNameException;\nimport java.nio.charset.UnsupportedCharsetException;\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\n\nimport io.netty.util.AsciiString;\nimport io.netty.util.CharsetUtil;\nimport io.netty.util.NetUtil;\nimport io.netty.util.internal.ObjectUtil;\n\n/**\n * Utility methods useful in the HTTP context.\n */\npublic final class HttpUtil {\n\n    private static final AsciiString CHARSET_EQUALS = AsciiString.of(HttpHeaderValues.CHARSET + \"=\");\n    private static final AsciiString SEMICOLON = AsciiString.cached(\";\");\n\n    private HttpUtil() { }\n\n    /**\n     * Determine if a uri is in origin-form according to\n     * <a href=\"https://tools.ietf.org/html/rfc7230#section-5.3\">rfc7230, 5.3</a>.\n     */\n    public static boolean isOriginForm(URI uri) {\n        return uri.getScheme() == null && uri.getSchemeSpecificPart() == null &&\n               uri.getHost() == null && uri.getAuthority() == null;\n    }\n\n    /**\n     * Determine if a uri is in asterisk-form according to\n     * <a href=\"https://tools.ietf.org/html/rfc7230#section-5.3\">rfc7230, 5.3</a>.\n     */\n    public static boolean isAsteriskForm(URI uri) {\n        return \"*\".equals(uri.getPath()) &&\n                uri.getScheme() == null && uri.getSchemeSpecificPart() == null &&\n                uri.getHost() == null && uri.getAuthority() == null && uri.getQuery() == null &&\n                uri.getFragment() == null;\n    }\n\n    /**\n     * Returns {@code true} if and only if the connection can remain open and\n     * thus 'kept alive'.  This methods respects the value of the.\n     *\n     * {@code \"Connection\"} header first and then the return value of\n     * {@link HttpVersion#isKeepAliveDefault()}.\n     */\n    public static boolean isKeepAlive(HttpMessage message) {\n        return !message.headers().containsValue(HttpHeaderNames.CONNECTION, HttpHeaderValues.CLOSE, true) &&\n               (message.protocolVersion().isKeepAliveDefault() ||\n                message.headers().containsValue(HttpHeaderNames.CONNECTION, HttpHeaderValues.KEEP_ALIVE, true));\n    }\n\n    /**\n     * Sets the value of the {@code \"Connection\"} header depending on the\n     * protocol version of the specified message. This getMethod sets or removes\n     * the {@code \"Connection\"} header depending on what the default keep alive\n     * mode of the message's protocol version is, as specified by\n     * {@link HttpVersion#isKeepAliveDefault()}.\n     * <ul>\n     * <li>If the connection is kept alive by default:\n     *     <ul>\n     *     <li>set to {@code \"close\"} if {@code keepAlive} is {@code false}.</li>\n     *     <li>remove otherwise.</li>\n     *     </ul></li>\n     * <li>If the connection is closed by default:\n     *     <ul>\n     *     <li>set to {@code \"keep-alive\"} if {@code keepAlive} is {@code true}.</li>\n     *     <li>remove otherwise.</li>\n     *     </ul></li>\n     * </ul>\n     * @see #setKeepAlive(HttpHeaders, HttpVersion, boolean)\n     */\n    public static void setKeepAlive(HttpMessage message, boolean keepAlive) {\n        setKeepAlive(message.headers(), message.protocolVersion(), keepAlive);\n    }\n\n    /**\n     * Sets the value of the {@code \"Connection\"} header depending on the\n     * protocol version of the specified message. This getMethod sets or removes\n     * the {@code \"Connection\"} header depending on what the default keep alive\n     * mode of the message's protocol version is, as specified by\n     * {@link HttpVersion#isKeepAliveDefault()}.\n     * <ul>\n     * <li>If the connection is kept alive by default:\n     *     <ul>\n     *     <li>set to {@code \"close\"} if {@code keepAlive} is {@code false}.</li>\n     *     <li>remove otherwise.</li>\n     *     </ul></li>\n     * <li>If the connection is closed by default:\n     *     <ul>\n     *     <li>set to {@code \"keep-alive\"} if {@code keepAlive} is {@code true}.</li>\n     *     <li>remove otherwise.</li>\n     *     </ul></li>\n     * </ul>\n     */\n    public static void setKeepAlive(HttpHeaders h, HttpVersion httpVersion, boolean keepAlive) {\n        if (httpVersion.isKeepAliveDefault()) {\n            if (keepAlive) {\n                h.remove(HttpHeaderNames.CONNECTION);\n            } else {\n                h.set(HttpHeaderNames.CONNECTION, HttpHeaderValues.CLOSE);\n            }\n        } else {\n            if (keepAlive) {\n                h.set(HttpHeaderNames.CONNECTION, HttpHeaderValues.KEEP_ALIVE);\n            } else {\n                h.remove(HttpHeaderNames.CONNECTION);\n            }\n        }\n    }\n\n    /**\n     * Returns the length of the content. Please note that this value is\n     * not retrieved from {@link HttpContent#content()} but from the\n     * {@code \"Content-Length\"} header, and thus they are independent from each\n     * other.\n     *\n     * @return the content length\n     *\n     * @throws NumberFormatException\n     *         if the message does not have the {@code \"Content-Length\"} header\n     *         or its value is not a number\n     */\n    public static long getContentLength(HttpMessage message) {\n        String value = message.headers().get(HttpHeaderNames.CONTENT_LENGTH);\n        if (value != null) {\n            return Long.parseLong(value);\n        }\n\n        // We know the content length if it's a Web Socket message even if\n        // Content-Length header is missing.\n        long webSocketContentLength = getWebSocketContentLength(message);\n        if (webSocketContentLength >= 0) {\n            return webSocketContentLength;\n        }\n\n        // Otherwise we don't.\n        throw new NumberFormatException(\"header not found: \" + HttpHeaderNames.CONTENT_LENGTH);\n    }\n\n    /**\n     * Returns the length of the content or the specified default value if the message does not have the {@code\n     * \"Content-Length\" header}. Please note that this value is not retrieved from {@link HttpContent#content()} but\n     * from the {@code \"Content-Length\"} header, and thus they are independent from each other.\n     *\n     * @param message      the message\n     * @param defaultValue the default value\n     * @return the content length or the specified default value\n     * @throws NumberFormatException if the {@code \"Content-Length\"} header does not parse as a long\n     */\n    public static long getContentLength(HttpMessage message, long defaultValue) {\n        String value = message.headers().get(HttpHeaderNames.CONTENT_LENGTH);\n        if (value != null) {\n            return Long.parseLong(value);\n        }\n\n        // We know the content length if it's a Web Socket message even if\n        // Content-Length header is missing.\n        long webSocketContentLength = getWebSocketContentLength(message);\n        if (webSocketContentLength >= 0) {\n            return webSocketContentLength;\n        }\n\n        // Otherwise we don't.\n        return defaultValue;\n    }\n\n    /**\n     * Get an {@code int} representation of {@link #getContentLength(HttpMessage, long)}.\n     *\n     * @return the content length or {@code defaultValue} if this message does\n     *         not have the {@code \"Content-Length\"} header or its value is not\n     *         a number. Not to exceed the boundaries of integer.\n     */\n    public static int getContentLength(HttpMessage message, int defaultValue) {\n        return (int) Math.min(Integer.MAX_VALUE, getContentLength(message, (long) defaultValue));\n    }\n\n    /**\n     * Returns the content length of the specified web socket message. If the\n     * specified message is not a web socket message, {@code -1} is returned.\n     */\n    private static int getWebSocketContentLength(HttpMessage message) {\n        // WebSocket messages have constant content-lengths.\n        HttpHeaders h = message.headers();\n        if (message instanceof HttpRequest) {\n            HttpRequest req = (HttpRequest) message;\n            if (HttpMethod.GET.equals(req.method()) &&\n                    h.contains(HttpHeaderNames.SEC_WEBSOCKET_KEY1) &&\n                    h.contains(HttpHeaderNames.SEC_WEBSOCKET_KEY2)) {\n                return 8;\n            }\n        } else if (message instanceof HttpResponse) {\n            HttpResponse res = (HttpResponse) message;\n            if (res.status().code() == 101 &&\n                    h.contains(HttpHeaderNames.SEC_WEBSOCKET_ORIGIN) &&\n                    h.contains(HttpHeaderNames.SEC_WEBSOCKET_LOCATION)) {\n                return 16;\n            }\n        }\n\n        // Not a web socket message\n        return -1;\n    }\n\n    /**\n     * Sets the {@code \"Content-Length\"} header.\n     */\n    public static void setContentLength(HttpMessage message, long length) {\n        message.headers().set(HttpHeaderNames.CONTENT_LENGTH, length);\n    }\n\n    public static boolean isContentLengthSet(HttpMessage m) {\n        return m.headers().contains(HttpHeaderNames.CONTENT_LENGTH);\n    }\n\n    /**\n     * Returns {@code true} if and only if the specified message contains an expect header and the only expectation\n     * present is the 100-continue expectation. Note that this method returns {@code false} if the expect header is\n     * not valid for the message (e.g., the message is a response, or the version on the message is HTTP/1.0).\n     *\n     * @param message the message\n     * @return {@code true} if and only if the expectation 100-continue is present and it is the only expectation\n     * present\n     */\n    public static boolean is100ContinueExpected(HttpMessage message) {\n        return isExpectHeaderValid(message)\n          // unquoted tokens in the expect header are case-insensitive, thus 100-continue is case insensitive\n          && message.headers().contains(HttpHeaderNames.EXPECT, HttpHeaderValues.CONTINUE, true);\n    }\n\n    /**\n     * Returns {@code true} if the specified message contains an expect header specifying an expectation that is not\n     * supported. Note that this method returns {@code false} if the expect header is not valid for the message\n     * (e.g., the message is a response, or the version on the message is HTTP/1.0).\n     *\n     * @param message the message\n     * @return {@code true} if and only if an expectation is present that is not supported\n     */\n    static boolean isUnsupportedExpectation(HttpMessage message) {\n        if (!isExpectHeaderValid(message)) {\n            return false;\n        }\n\n        final String expectValue = message.headers().get(HttpHeaderNames.EXPECT);\n        return expectValue != null && !HttpHeaderValues.CONTINUE.toString().equalsIgnoreCase(expectValue);\n    }\n\n    private static boolean isExpectHeaderValid(final HttpMessage message) {\n        /*\n         * Expect: 100-continue is for requests only and it works only on HTTP/1.1 or later. Note further that RFC 7231\n         * section 5.1.1 says \"A server that receives a 100-continue expectation in an HTTP/1.0 request MUST ignore\n         * that expectation.\"\n         */\n        return message instanceof HttpRequest &&\n                message.protocolVersion().compareTo(HttpVersion.HTTP_1_1) >= 0;\n    }\n\n    /**\n     * Sets or removes the {@code \"Expect: 100-continue\"} header to / from the\n     * specified message. If {@code expected} is {@code true},\n     * the {@code \"Expect: 100-continue\"} header is set and all other previous\n     * {@code \"Expect\"} headers are removed.  Otherwise, all {@code \"Expect\"}\n     * headers are removed completely.\n     */\n    public static void set100ContinueExpected(HttpMessage message, boolean expected) {\n        if (expected) {\n            message.headers().set(HttpHeaderNames.EXPECT, HttpHeaderValues.CONTINUE);\n        } else {\n            message.headers().remove(HttpHeaderNames.EXPECT);\n        }\n    }\n\n    /**\n     * Checks to see if the transfer encoding in a specified {@link HttpMessage} is chunked\n     *\n     * @param message The message to check\n     * @return True if transfer encoding is chunked, otherwise false\n     */\n    public static boolean isTransferEncodingChunked(HttpMessage message) {\n        return message.headers().containsValue(HttpHeaderNames.TRANSFER_ENCODING, HttpHeaderValues.CHUNKED, true);\n    }\n\n    /**\n     * Set the {@link HttpHeaderNames#TRANSFER_ENCODING} to either include {@link HttpHeaderValues#CHUNKED} if\n     * {@code chunked} is {@code true}, or remove {@link HttpHeaderValues#CHUNKED} if {@code chunked} is {@code false}.\n     *\n     * @param m The message which contains the headers to modify.\n     * @param chunked if {@code true} then include {@link HttpHeaderValues#CHUNKED} in the headers. otherwise remove\n     * {@link HttpHeaderValues#CHUNKED} from the headers.\n     */\n    public static void setTransferEncodingChunked(HttpMessage m, boolean chunked) {\n        if (chunked) {\n            m.headers().set(HttpHeaderNames.TRANSFER_ENCODING, HttpHeaderValues.CHUNKED);\n            m.headers().remove(HttpHeaderNames.CONTENT_LENGTH);\n        } else {\n            List<String> encodings = m.headers().getAll(HttpHeaderNames.TRANSFER_ENCODING);\n            if (encodings.isEmpty()) {\n                return;\n            }\n            List<CharSequence> values = new ArrayList<CharSequence>(encodings);\n            Iterator<CharSequence> valuesIt = values.iterator();\n            while (valuesIt.hasNext()) {\n                CharSequence value = valuesIt.next();\n                if (HttpHeaderValues.CHUNKED.contentEqualsIgnoreCase(value)) {\n                    valuesIt.remove();\n                }\n            }\n            if (values.isEmpty()) {\n                m.headers().remove(HttpHeaderNames.TRANSFER_ENCODING);\n            } else {\n                m.headers().set(HttpHeaderNames.TRANSFER_ENCODING, values);\n            }\n        }\n    }\n\n    /**\n     * Fetch charset from message's Content-Type header.\n     *\n     * @param message entity to fetch Content-Type header from\n     * @return the charset from message's Content-Type header or {@link CharsetUtil#ISO_8859_1}\n     * if charset is not presented or unparsable\n     */\n    public static Charset getCharset(HttpMessage message) {\n        return getCharset(message, CharsetUtil.ISO_8859_1);\n    }\n\n    /**\n     * Fetch charset from Content-Type header value.\n     *\n     * @param contentTypeValue Content-Type header value to parse\n     * @return the charset from message's Content-Type header or {@link CharsetUtil#ISO_8859_1}\n     * if charset is not presented or unparsable\n     */\n    public static Charset getCharset(CharSequence contentTypeValue) {\n        if (contentTypeValue != null) {\n            return getCharset(contentTypeValue, CharsetUtil.ISO_8859_1);\n        } else {\n            return CharsetUtil.ISO_8859_1;\n        }\n    }\n\n    /**\n     * Fetch charset from message's Content-Type header.\n     *\n     * @param message        entity to fetch Content-Type header from\n     * @param defaultCharset result to use in case of empty, incorrect or doesn't contain required part header value\n     * @return the charset from message's Content-Type header or {@code defaultCharset}\n     * if charset is not presented or unparsable\n     */\n    public static Charset getCharset(HttpMessage message, Charset defaultCharset) {\n        CharSequence contentTypeValue = message.headers().get(HttpHeaderNames.CONTENT_TYPE);\n        if (contentTypeValue != null) {\n            return getCharset(contentTypeValue, defaultCharset);\n        } else {\n            return defaultCharset;\n        }\n    }\n\n    /**\n     * Fetch charset from Content-Type header value.\n     *\n     * @param contentTypeValue Content-Type header value to parse\n     * @param defaultCharset   result to use in case of empty, incorrect or doesn't contain required part header value\n     * @return the charset from message's Content-Type header or {@code defaultCharset}\n     * if charset is not presented or unparsable\n     */\n    public static Charset getCharset(CharSequence contentTypeValue, Charset defaultCharset) {\n        if (contentTypeValue != null) {\n            CharSequence charsetCharSequence = getCharsetAsSequence(contentTypeValue);\n            if (charsetCharSequence != null) {\n                try {\n                    return Charset.forName(charsetCharSequence.toString());\n                } catch (IllegalCharsetNameException ignored) {\n                    // just return the default charset\n                } catch (UnsupportedCharsetException ignored) {\n                    // just return the default charset\n                }\n            }\n        }\n        return defaultCharset;\n    }\n\n    /**\n     * Fetch charset from message's Content-Type header as a char sequence.\n     *\n     * A lot of sites/possibly clients have charset=\"CHARSET\", for example charset=\"utf-8\". Or \"utf8\" instead of \"utf-8\"\n     * This is not according to standard, but this method provide an ability to catch desired mistakes manually in code\n     *\n     * @param message entity to fetch Content-Type header from\n     * @return the {@code CharSequence} with charset from message's Content-Type header\n     * or {@code null} if charset is not presented\n     * @deprecated use {@link #getCharsetAsSequence(HttpMessage)}\n     */\n    @Deprecated\n    public static CharSequence getCharsetAsString(HttpMessage message) {\n        return getCharsetAsSequence(message);\n    }\n\n    /**\n     * Fetch charset from message's Content-Type header as a char sequence.\n     *\n     * A lot of sites/possibly clients have charset=\"CHARSET\", for example charset=\"utf-8\". Or \"utf8\" instead of \"utf-8\"\n     * This is not according to standard, but this method provide an ability to catch desired mistakes manually in code\n     *\n     * @return the {@code CharSequence} with charset from message's Content-Type header\n     * or {@code null} if charset is not presented\n     */\n    public static CharSequence getCharsetAsSequence(HttpMessage message) {\n        CharSequence contentTypeValue = message.headers().get(HttpHeaderNames.CONTENT_TYPE);\n        if (contentTypeValue != null) {\n            return getCharsetAsSequence(contentTypeValue);\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * Fetch charset from Content-Type header value as a char sequence.\n     *\n     * A lot of sites/possibly clients have charset=\"CHARSET\", for example charset=\"utf-8\". Or \"utf8\" instead of \"utf-8\"\n     * This is not according to standard, but this method provide an ability to catch desired mistakes manually in code\n     *\n     * @param contentTypeValue Content-Type header value to parse\n     * @return the {@code CharSequence} with charset from message's Content-Type header\n     * or {@code null} if charset is not presented\n     * @throws NullPointerException in case if {@code contentTypeValue == null}\n     */\n    public static CharSequence getCharsetAsSequence(CharSequence contentTypeValue) {\n        ObjectUtil.checkNotNull(contentTypeValue, \"contentTypeValue\");\n\n        int indexOfCharset = AsciiString.indexOfIgnoreCaseAscii(contentTypeValue, CHARSET_EQUALS, 0);\n        if (indexOfCharset == AsciiString.INDEX_NOT_FOUND) {\n            return null;\n        }\n\n        int indexOfEncoding = indexOfCharset + CHARSET_EQUALS.length();\n        if (indexOfEncoding < contentTypeValue.length()) {\n            CharSequence charsetCandidate = contentTypeValue.subSequence(indexOfEncoding, contentTypeValue.length());\n            int indexOfSemicolon = AsciiString.indexOfIgnoreCaseAscii(charsetCandidate, SEMICOLON, 0);\n            if (indexOfSemicolon == AsciiString.INDEX_NOT_FOUND) {\n                return charsetCandidate;\n            }\n\n            return charsetCandidate.subSequence(0, indexOfSemicolon);\n        }\n\n        return null;\n    }\n\n    /**\n     * Fetch MIME type part from message's Content-Type header as a char sequence.\n     *\n     * @param message entity to fetch Content-Type header from\n     * @return the MIME type as a {@code CharSequence} from message's Content-Type header\n     * or {@code null} if content-type header or MIME type part of this header are not presented\n     * <p/>\n     * \"content-type: text/html; charset=utf-8\" - \"text/html\" will be returned <br/>\n     * \"content-type: text/html\" - \"text/html\" will be returned <br/>\n     * \"content-type: \" or no header - {@code null} we be returned\n     */\n    public static CharSequence getMimeType(HttpMessage message) {\n        CharSequence contentTypeValue = message.headers().get(HttpHeaderNames.CONTENT_TYPE);\n        if (contentTypeValue != null) {\n            return getMimeType(contentTypeValue);\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * Fetch MIME type part from Content-Type header value as a char sequence.\n     *\n     * @param contentTypeValue Content-Type header value to parse\n     * @return the MIME type as a {@code CharSequence} from message's Content-Type header\n     * or {@code null} if content-type header or MIME type part of this header are not presented\n     * <p/>\n     * \"content-type: text/html; charset=utf-8\" - \"text/html\" will be returned <br/>\n     * \"content-type: text/html\" - \"text/html\" will be returned <br/>\n     * \"content-type: empty header - {@code null} we be returned\n     * @throws NullPointerException in case if {@code contentTypeValue == null}\n     */\n    public static CharSequence getMimeType(CharSequence contentTypeValue) {\n        ObjectUtil.checkNotNull(contentTypeValue, \"contentTypeValue\");\n\n        int indexOfSemicolon = AsciiString.indexOfIgnoreCaseAscii(contentTypeValue, SEMICOLON, 0);\n        if (indexOfSemicolon != AsciiString.INDEX_NOT_FOUND) {\n            return contentTypeValue.subSequence(0, indexOfSemicolon);\n        } else {\n            return contentTypeValue.length() > 0 ? contentTypeValue : null;\n        }\n    }\n\n    /**\n     * Formats the host string of an address so it can be used for computing an HTTP component\n     * such as a URL or a Host header\n     *\n     * @param addr the address\n     * @return the formatted String\n     */\n    public static String formatHostnameForHttp(InetSocketAddress addr) {\n        String hostString = NetUtil.getHostname(addr);\n        if (NetUtil.isValidIpV6Address(hostString)) {\n            if (!addr.isUnresolved()) {\n                hostString = NetUtil.toAddressString(addr.getAddress());\n            }\n            return '[' + hostString + ']';\n        }\n        return hostString;\n    }\n}\n", "/*\n * Copyright 2014 The Netty Project\n *\n * The Netty Project licenses this file to you under the Apache License, version 2.0 (the\n * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n * copy of the License at:\n *\n * https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under the License\n * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n * or implied. See the License for the specific language governing permissions and limitations under\n * the License.\n */\npackage io.netty.handler.codec.http2;\n\nimport io.netty.buffer.ByteBuf;\nimport io.netty.channel.ChannelHandlerContext;\nimport io.netty.handler.codec.http.HttpStatusClass;\nimport io.netty.handler.codec.http2.Http2Connection.Endpoint;\nimport io.netty.util.internal.UnstableApi;\nimport io.netty.util.internal.logging.InternalLogger;\nimport io.netty.util.internal.logging.InternalLoggerFactory;\n\nimport java.util.List;\n\nimport static io.netty.handler.codec.http.HttpStatusClass.INFORMATIONAL;\nimport static io.netty.handler.codec.http2.Http2CodecUtil.DEFAULT_PRIORITY_WEIGHT;\nimport static io.netty.handler.codec.http2.Http2Error.INTERNAL_ERROR;\nimport static io.netty.handler.codec.http2.Http2Error.PROTOCOL_ERROR;\nimport static io.netty.handler.codec.http2.Http2Error.STREAM_CLOSED;\nimport static io.netty.handler.codec.http2.Http2Exception.connectionError;\nimport static io.netty.handler.codec.http2.Http2Exception.streamError;\nimport static io.netty.handler.codec.http2.Http2PromisedRequestVerifier.ALWAYS_VERIFY;\nimport static io.netty.handler.codec.http2.Http2Stream.State.CLOSED;\nimport static io.netty.handler.codec.http2.Http2Stream.State.HALF_CLOSED_REMOTE;\nimport static io.netty.util.internal.ObjectUtil.checkNotNull;\nimport static java.lang.Integer.MAX_VALUE;\nimport static java.lang.Math.min;\n\n/**\n * Provides the default implementation for processing inbound frame events and delegates to a\n * {@link Http2FrameListener}\n * <p>\n * This class will read HTTP/2 frames and delegate the events to a {@link Http2FrameListener}\n * <p>\n * This interface enforces inbound flow control functionality through\n * {@link Http2LocalFlowController}\n */\n@UnstableApi\npublic class DefaultHttp2ConnectionDecoder implements Http2ConnectionDecoder {\n    private static final InternalLogger logger = InternalLoggerFactory.getInstance(DefaultHttp2ConnectionDecoder.class);\n    private Http2FrameListener internalFrameListener = new PrefaceFrameListener();\n    private final Http2Connection connection;\n    private Http2LifecycleManager lifecycleManager;\n    private final Http2ConnectionEncoder encoder;\n    private final Http2FrameReader frameReader;\n    private Http2FrameListener listener;\n    private final Http2PromisedRequestVerifier requestVerifier;\n    private final Http2SettingsReceivedConsumer settingsReceivedConsumer;\n    private final boolean autoAckPing;\n\n    public DefaultHttp2ConnectionDecoder(Http2Connection connection,\n                                         Http2ConnectionEncoder encoder,\n                                         Http2FrameReader frameReader) {\n        this(connection, encoder, frameReader, ALWAYS_VERIFY);\n    }\n\n    public DefaultHttp2ConnectionDecoder(Http2Connection connection,\n                                         Http2ConnectionEncoder encoder,\n                                         Http2FrameReader frameReader,\n                                         Http2PromisedRequestVerifier requestVerifier) {\n        this(connection, encoder, frameReader, requestVerifier, true);\n    }\n\n    /**\n     * Create a new instance.\n     * @param connection The {@link Http2Connection} associated with this decoder.\n     * @param encoder The {@link Http2ConnectionEncoder} associated with this decoder.\n     * @param frameReader Responsible for reading/parsing the raw frames. As opposed to this object which applies\n     *                    h2 semantics on top of the frames.\n     * @param requestVerifier Determines if push promised streams are valid.\n     * @param autoAckSettings {@code false} to disable automatically applying and sending settings acknowledge frame.\n     *  The {@code Http2ConnectionEncoder} is expected to be an instance of {@link Http2SettingsReceivedConsumer} and\n     *  will apply the earliest received but not yet ACKed SETTINGS when writing the SETTINGS ACKs.\n     * {@code true} to enable automatically applying and sending settings acknowledge frame.\n     */\n    public DefaultHttp2ConnectionDecoder(Http2Connection connection,\n                                         Http2ConnectionEncoder encoder,\n                                         Http2FrameReader frameReader,\n                                         Http2PromisedRequestVerifier requestVerifier,\n                                         boolean autoAckSettings) {\n        this(connection, encoder, frameReader, requestVerifier, autoAckSettings, true);\n    }\n\n    /**\n     * Create a new instance.\n     * @param connection The {@link Http2Connection} associated with this decoder.\n     * @param encoder The {@link Http2ConnectionEncoder} associated with this decoder.\n     * @param frameReader Responsible for reading/parsing the raw frames. As opposed to this object which applies\n     *                    h2 semantics on top of the frames.\n     * @param requestVerifier Determines if push promised streams are valid.\n     * @param autoAckSettings {@code false} to disable automatically applying and sending settings acknowledge frame.\n     *                        The {@code Http2ConnectionEncoder} is expected to be an instance of\n     *                        {@link Http2SettingsReceivedConsumer} and will apply the earliest received but not yet\n     *                        ACKed SETTINGS when writing the SETTINGS ACKs. {@code true} to enable automatically\n     *                        applying and sending settings acknowledge frame.\n     * @param autoAckPing {@code false} to disable automatically sending ping acknowledge frame. {@code true} to enable\n     *                    automatically sending ping ack frame.\n     */\n    public DefaultHttp2ConnectionDecoder(Http2Connection connection,\n                                         Http2ConnectionEncoder encoder,\n                                         Http2FrameReader frameReader,\n                                         Http2PromisedRequestVerifier requestVerifier,\n                                         boolean autoAckSettings,\n                                         boolean autoAckPing) {\n        this.autoAckPing = autoAckPing;\n        if (autoAckSettings) {\n            settingsReceivedConsumer = null;\n        } else {\n            if (!(encoder instanceof Http2SettingsReceivedConsumer)) {\n                throw new IllegalArgumentException(\"disabling autoAckSettings requires the encoder to be a \" +\n                        Http2SettingsReceivedConsumer.class);\n            }\n            settingsReceivedConsumer = (Http2SettingsReceivedConsumer) encoder;\n        }\n        this.connection = checkNotNull(connection, \"connection\");\n        this.frameReader = checkNotNull(frameReader, \"frameReader\");\n        this.encoder = checkNotNull(encoder, \"encoder\");\n        this.requestVerifier = checkNotNull(requestVerifier, \"requestVerifier\");\n        if (connection.local().flowController() == null) {\n            connection.local().flowController(new DefaultHttp2LocalFlowController(connection));\n        }\n        connection.local().flowController().frameWriter(encoder.frameWriter());\n    }\n\n    @Override\n    public void lifecycleManager(Http2LifecycleManager lifecycleManager) {\n        this.lifecycleManager = checkNotNull(lifecycleManager, \"lifecycleManager\");\n    }\n\n    @Override\n    public Http2Connection connection() {\n        return connection;\n    }\n\n    @Override\n    public final Http2LocalFlowController flowController() {\n        return connection.local().flowController();\n    }\n\n    @Override\n    public void frameListener(Http2FrameListener listener) {\n        this.listener = checkNotNull(listener, \"listener\");\n    }\n\n    @Override\n    public Http2FrameListener frameListener() {\n        return listener;\n    }\n\n    // Visible for testing\n    Http2FrameListener internalFrameListener() {\n        return internalFrameListener;\n    }\n\n    @Override\n    public boolean prefaceReceived() {\n        return FrameReadListener.class == internalFrameListener.getClass();\n    }\n\n    @Override\n    public void decodeFrame(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) throws Http2Exception {\n        frameReader.readFrame(ctx, in, internalFrameListener);\n    }\n\n    @Override\n    public Http2Settings localSettings() {\n        Http2Settings settings = new Http2Settings();\n        Http2FrameReader.Configuration config = frameReader.configuration();\n        Http2HeadersDecoder.Configuration headersConfig = config.headersConfiguration();\n        Http2FrameSizePolicy frameSizePolicy = config.frameSizePolicy();\n        settings.initialWindowSize(flowController().initialWindowSize());\n        settings.maxConcurrentStreams(connection.remote().maxActiveStreams());\n        settings.headerTableSize(headersConfig.maxHeaderTableSize());\n        settings.maxFrameSize(frameSizePolicy.maxFrameSize());\n        settings.maxHeaderListSize(headersConfig.maxHeaderListSize());\n        if (!connection.isServer()) {\n            // Only set the pushEnabled flag if this is a client endpoint.\n            settings.pushEnabled(connection.local().allowPushTo());\n        }\n        return settings;\n    }\n\n    @Override\n    public void close() {\n        frameReader.close();\n    }\n\n    /**\n     * Calculate the threshold in bytes which should trigger a {@code GO_AWAY} if a set of headers exceeds this amount.\n     * @param maxHeaderListSize\n     *      <a href=\"https://tools.ietf.org/html/rfc7540#section-6.5.2\">SETTINGS_MAX_HEADER_LIST_SIZE</a> for the local\n     *      endpoint.\n     * @return the threshold in bytes which should trigger a {@code GO_AWAY} if a set of headers exceeds this amount.\n     */\n    protected long calculateMaxHeaderListSizeGoAway(long maxHeaderListSize) {\n        return Http2CodecUtil.calculateMaxHeaderListSizeGoAway(maxHeaderListSize);\n    }\n\n    private int unconsumedBytes(Http2Stream stream) {\n        return flowController().unconsumedBytes(stream);\n    }\n\n    void onGoAwayRead0(ChannelHandlerContext ctx, int lastStreamId, long errorCode, ByteBuf debugData)\n            throws Http2Exception {\n        listener.onGoAwayRead(ctx, lastStreamId, errorCode, debugData);\n        connection.goAwayReceived(lastStreamId, errorCode, debugData);\n    }\n\n    void onUnknownFrame0(ChannelHandlerContext ctx, byte frameType, int streamId, Http2Flags flags,\n            ByteBuf payload) throws Http2Exception {\n        listener.onUnknownFrame(ctx, frameType, streamId, flags, payload);\n    }\n\n    /**\n     * Handles all inbound frames from the network.\n     */\n    private final class FrameReadListener implements Http2FrameListener {\n        @Override\n        public int onDataRead(final ChannelHandlerContext ctx, int streamId, ByteBuf data, int padding,\n                              boolean endOfStream) throws Http2Exception {\n            Http2Stream stream = connection.stream(streamId);\n            Http2LocalFlowController flowController = flowController();\n            int bytesToReturn = data.readableBytes() + padding;\n\n            final boolean shouldIgnore;\n            try {\n                shouldIgnore = shouldIgnoreHeadersOrDataFrame(ctx, streamId, stream, \"DATA\");\n            } catch (Http2Exception e) {\n                // Ignoring this frame. We still need to count the frame towards the connection flow control\n                // window, but we immediately mark all bytes as consumed.\n                flowController.receiveFlowControlledFrame(stream, data, padding, endOfStream);\n                flowController.consumeBytes(stream, bytesToReturn);\n                throw e;\n            } catch (Throwable t) {\n                throw connectionError(INTERNAL_ERROR, t, \"Unhandled error on data stream id %d\", streamId);\n            }\n\n            if (shouldIgnore) {\n                // Ignoring this frame. We still need to count the frame towards the connection flow control\n                // window, but we immediately mark all bytes as consumed.\n                flowController.receiveFlowControlledFrame(stream, data, padding, endOfStream);\n                flowController.consumeBytes(stream, bytesToReturn);\n\n                // Verify that the stream may have existed after we apply flow control.\n                verifyStreamMayHaveExisted(streamId);\n\n                // All bytes have been consumed.\n                return bytesToReturn;\n            }\n\n            Http2Exception error = null;\n            switch (stream.state()) {\n                case OPEN:\n                case HALF_CLOSED_LOCAL:\n                    break;\n                case HALF_CLOSED_REMOTE:\n                case CLOSED:\n                    error = streamError(stream.id(), STREAM_CLOSED, \"Stream %d in unexpected state: %s\",\n                        stream.id(), stream.state());\n                    break;\n                default:\n                    error = streamError(stream.id(), PROTOCOL_ERROR,\n                        \"Stream %d in unexpected state: %s\", stream.id(), stream.state());\n                    break;\n            }\n\n            int unconsumedBytes = unconsumedBytes(stream);\n            try {\n                flowController.receiveFlowControlledFrame(stream, data, padding, endOfStream);\n                // Update the unconsumed bytes after flow control is applied.\n                unconsumedBytes = unconsumedBytes(stream);\n\n                // If the stream is in an invalid state to receive the frame, throw the error.\n                if (error != null) {\n                    throw error;\n                }\n\n                // Call back the application and retrieve the number of bytes that have been\n                // immediately processed.\n                bytesToReturn = listener.onDataRead(ctx, streamId, data, padding, endOfStream);\n                return bytesToReturn;\n            } catch (Http2Exception e) {\n                // If an exception happened during delivery, the listener may have returned part\n                // of the bytes before the error occurred. If that's the case, subtract that from\n                // the total processed bytes so that we don't return too many bytes.\n                int delta = unconsumedBytes - unconsumedBytes(stream);\n                bytesToReturn -= delta;\n                throw e;\n            } catch (RuntimeException e) {\n                // If an exception happened during delivery, the listener may have returned part\n                // of the bytes before the error occurred. If that's the case, subtract that from\n                // the total processed bytes so that we don't return too many bytes.\n                int delta = unconsumedBytes - unconsumedBytes(stream);\n                bytesToReturn -= delta;\n                throw e;\n            } finally {\n                // If appropriate, return the processed bytes to the flow controller.\n                flowController.consumeBytes(stream, bytesToReturn);\n\n                if (endOfStream) {\n                    lifecycleManager.closeStreamRemote(stream, ctx.newSucceededFuture());\n                }\n            }\n        }\n\n        @Override\n        public void onHeadersRead(ChannelHandlerContext ctx, int streamId, Http2Headers headers, int padding,\n                boolean endOfStream) throws Http2Exception {\n            onHeadersRead(ctx, streamId, headers, 0, DEFAULT_PRIORITY_WEIGHT, false, padding, endOfStream);\n        }\n\n        @Override\n        public void onHeadersRead(ChannelHandlerContext ctx, int streamId, Http2Headers headers, int streamDependency,\n                short weight, boolean exclusive, int padding, boolean endOfStream) throws Http2Exception {\n            Http2Stream stream = connection.stream(streamId);\n            boolean allowHalfClosedRemote = false;\n            if (stream == null && !connection.streamMayHaveExisted(streamId)) {\n                stream = connection.remote().createStream(streamId, endOfStream);\n                // Allow the state to be HALF_CLOSE_REMOTE if we're creating it in that state.\n                allowHalfClosedRemote = stream.state() == HALF_CLOSED_REMOTE;\n            }\n\n            if (shouldIgnoreHeadersOrDataFrame(ctx, streamId, stream, \"HEADERS\")) {\n                return;\n            }\n\n            boolean isInformational = !connection.isServer() &&\n                    HttpStatusClass.valueOf(headers.status()) == INFORMATIONAL;\n            if ((isInformational || !endOfStream) && stream.isHeadersReceived() || stream.isTrailersReceived()) {\n                throw streamError(streamId, PROTOCOL_ERROR,\n                                  \"Stream %d received too many headers EOS: %s state: %s\",\n                                  streamId, endOfStream, stream.state());\n            }\n\n            switch (stream.state()) {\n                case RESERVED_REMOTE:\n                    stream.open(endOfStream);\n                    break;\n                case OPEN:\n                case HALF_CLOSED_LOCAL:\n                    // Allowed to receive headers in these states.\n                    break;\n                case HALF_CLOSED_REMOTE:\n                    if (!allowHalfClosedRemote) {\n                        throw streamError(stream.id(), STREAM_CLOSED, \"Stream %d in unexpected state: %s\",\n                                stream.id(), stream.state());\n                    }\n                    break;\n                case CLOSED:\n                    throw streamError(stream.id(), STREAM_CLOSED, \"Stream %d in unexpected state: %s\",\n                            stream.id(), stream.state());\n                default:\n                    // Connection error.\n                    throw connectionError(PROTOCOL_ERROR, \"Stream %d in unexpected state: %s\", stream.id(),\n                            stream.state());\n            }\n\n            stream.headersReceived(isInformational);\n            encoder.flowController().updateDependencyTree(streamId, streamDependency, weight, exclusive);\n\n            listener.onHeadersRead(ctx, streamId, headers, streamDependency, weight, exclusive, padding, endOfStream);\n\n            // If the headers completes this stream, close it.\n            if (endOfStream) {\n                lifecycleManager.closeStreamRemote(stream, ctx.newSucceededFuture());\n            }\n        }\n\n        @Override\n        public void onPriorityRead(ChannelHandlerContext ctx, int streamId, int streamDependency, short weight,\n                boolean exclusive) throws Http2Exception {\n            encoder.flowController().updateDependencyTree(streamId, streamDependency, weight, exclusive);\n\n            listener.onPriorityRead(ctx, streamId, streamDependency, weight, exclusive);\n        }\n\n        @Override\n        public void onRstStreamRead(ChannelHandlerContext ctx, int streamId, long errorCode) throws Http2Exception {\n            Http2Stream stream = connection.stream(streamId);\n            if (stream == null) {\n                verifyStreamMayHaveExisted(streamId);\n                return;\n            }\n\n            switch(stream.state()) {\n            case IDLE:\n                throw connectionError(PROTOCOL_ERROR, \"RST_STREAM received for IDLE stream %d\", streamId);\n            case CLOSED:\n                return; // RST_STREAM frames must be ignored for closed streams.\n            default:\n                break;\n            }\n\n            listener.onRstStreamRead(ctx, streamId, errorCode);\n\n            lifecycleManager.closeStream(stream, ctx.newSucceededFuture());\n        }\n\n        @Override\n        public void onSettingsAckRead(ChannelHandlerContext ctx) throws Http2Exception {\n            // Apply oldest outstanding local settings here. This is a synchronization point between endpoints.\n            Http2Settings settings = encoder.pollSentSettings();\n\n            if (settings != null) {\n                applyLocalSettings(settings);\n            }\n\n            listener.onSettingsAckRead(ctx);\n        }\n\n        /**\n         * Applies settings sent from the local endpoint.\n         * <p>\n         * This method is only called after the local settings have been acknowledged from the remote endpoint.\n         */\n        private void applyLocalSettings(Http2Settings settings) throws Http2Exception {\n            Boolean pushEnabled = settings.pushEnabled();\n            final Http2FrameReader.Configuration config = frameReader.configuration();\n            final Http2HeadersDecoder.Configuration headerConfig = config.headersConfiguration();\n            final Http2FrameSizePolicy frameSizePolicy = config.frameSizePolicy();\n            if (pushEnabled != null) {\n                if (connection.isServer()) {\n                    throw connectionError(PROTOCOL_ERROR, \"Server sending SETTINGS frame with ENABLE_PUSH specified\");\n                }\n                connection.local().allowPushTo(pushEnabled);\n            }\n\n            Long maxConcurrentStreams = settings.maxConcurrentStreams();\n            if (maxConcurrentStreams != null) {\n                connection.remote().maxActiveStreams((int) min(maxConcurrentStreams, MAX_VALUE));\n            }\n\n            Long headerTableSize = settings.headerTableSize();\n            if (headerTableSize != null) {\n                headerConfig.maxHeaderTableSize(headerTableSize);\n            }\n\n            Long maxHeaderListSize = settings.maxHeaderListSize();\n            if (maxHeaderListSize != null) {\n                headerConfig.maxHeaderListSize(maxHeaderListSize, calculateMaxHeaderListSizeGoAway(maxHeaderListSize));\n            }\n\n            Integer maxFrameSize = settings.maxFrameSize();\n            if (maxFrameSize != null) {\n                frameSizePolicy.maxFrameSize(maxFrameSize);\n            }\n\n            Integer initialWindowSize = settings.initialWindowSize();\n            if (initialWindowSize != null) {\n                flowController().initialWindowSize(initialWindowSize);\n            }\n        }\n\n        @Override\n        public void onSettingsRead(final ChannelHandlerContext ctx, Http2Settings settings) throws Http2Exception {\n            if (settingsReceivedConsumer == null) {\n                // Acknowledge receipt of the settings. We should do this before we process the settings to ensure our\n                // remote peer applies these settings before any subsequent frames that we may send which depend upon\n                // these new settings. See https://github.com/netty/netty/issues/6520.\n                encoder.writeSettingsAck(ctx, ctx.newPromise());\n\n                encoder.remoteSettings(settings);\n            } else {\n                settingsReceivedConsumer.consumeReceivedSettings(settings);\n            }\n\n            listener.onSettingsRead(ctx, settings);\n        }\n\n        @Override\n        public void onPingRead(ChannelHandlerContext ctx, long data) throws Http2Exception {\n            if (autoAckPing) {\n                // Send an ack back to the remote client.\n                encoder.writePing(ctx, true, data, ctx.newPromise());\n            }\n            listener.onPingRead(ctx, data);\n        }\n\n        @Override\n        public void onPingAckRead(ChannelHandlerContext ctx, long data) throws Http2Exception {\n            listener.onPingAckRead(ctx, data);\n        }\n\n        @Override\n        public void onPushPromiseRead(ChannelHandlerContext ctx, int streamId, int promisedStreamId,\n                Http2Headers headers, int padding) throws Http2Exception {\n            // A client cannot push.\n            if (connection().isServer()) {\n                throw connectionError(PROTOCOL_ERROR, \"A client cannot push.\");\n            }\n\n            Http2Stream parentStream = connection.stream(streamId);\n\n            if (shouldIgnoreHeadersOrDataFrame(ctx, streamId, parentStream, \"PUSH_PROMISE\")) {\n                return;\n            }\n\n            switch (parentStream.state()) {\n              case OPEN:\n              case HALF_CLOSED_LOCAL:\n                  // Allowed to receive push promise in these states.\n                  break;\n              default:\n                  // Connection error.\n                  throw connectionError(PROTOCOL_ERROR,\n                      \"Stream %d in unexpected state for receiving push promise: %s\",\n                      parentStream.id(), parentStream.state());\n            }\n\n            if (!requestVerifier.isAuthoritative(ctx, headers)) {\n                throw streamError(promisedStreamId, PROTOCOL_ERROR,\n                        \"Promised request on stream %d for promised stream %d is not authoritative\",\n                        streamId, promisedStreamId);\n            }\n            if (!requestVerifier.isCacheable(headers)) {\n                throw streamError(promisedStreamId, PROTOCOL_ERROR,\n                        \"Promised request on stream %d for promised stream %d is not known to be cacheable\",\n                        streamId, promisedStreamId);\n            }\n            if (!requestVerifier.isSafe(headers)) {\n                throw streamError(promisedStreamId, PROTOCOL_ERROR,\n                        \"Promised request on stream %d for promised stream %d is not known to be safe\",\n                        streamId, promisedStreamId);\n            }\n\n            // Reserve the push stream based with a priority based on the current stream's priority.\n            connection.remote().reservePushStream(promisedStreamId, parentStream);\n\n            listener.onPushPromiseRead(ctx, streamId, promisedStreamId, headers, padding);\n        }\n\n        @Override\n        public void onGoAwayRead(ChannelHandlerContext ctx, int lastStreamId, long errorCode, ByteBuf debugData)\n                throws Http2Exception {\n            onGoAwayRead0(ctx, lastStreamId, errorCode, debugData);\n        }\n\n        @Override\n        public void onWindowUpdateRead(ChannelHandlerContext ctx, int streamId, int windowSizeIncrement)\n                throws Http2Exception {\n            Http2Stream stream = connection.stream(streamId);\n            if (stream == null || stream.state() == CLOSED || streamCreatedAfterGoAwaySent(streamId)) {\n                // Ignore this frame.\n                verifyStreamMayHaveExisted(streamId);\n                return;\n            }\n\n            // Update the outbound flow control window.\n            encoder.flowController().incrementWindowSize(stream, windowSizeIncrement);\n\n            listener.onWindowUpdateRead(ctx, streamId, windowSizeIncrement);\n        }\n\n        @Override\n        public void onUnknownFrame(ChannelHandlerContext ctx, byte frameType, int streamId, Http2Flags flags,\n                ByteBuf payload) throws Http2Exception {\n            onUnknownFrame0(ctx, frameType, streamId, flags, payload);\n        }\n\n        /**\n         * Helper method to determine if a frame that has the semantics of headers or data should be ignored for the\n         * {@code stream} (which may be {@code null}) associated with {@code streamId}.\n         */\n        private boolean shouldIgnoreHeadersOrDataFrame(ChannelHandlerContext ctx, int streamId, Http2Stream stream,\n                String frameName) throws Http2Exception {\n            if (stream == null) {\n                if (streamCreatedAfterGoAwaySent(streamId)) {\n                    logger.info(\"{} ignoring {} frame for stream {}. Stream sent after GOAWAY sent\",\n                            ctx.channel(), frameName, streamId);\n                    return true;\n                }\n\n                // Make sure it's not an out-of-order frame, like a rogue DATA frame, for a stream that could\n                // never have existed.\n                verifyStreamMayHaveExisted(streamId);\n\n                // Its possible that this frame would result in stream ID out of order creation (PROTOCOL ERROR) and its\n                // also possible that this frame is received on a CLOSED stream (STREAM_CLOSED after a RST_STREAM is\n                // sent). We don't have enough information to know for sure, so we choose the lesser of the two errors.\n                throw streamError(streamId, STREAM_CLOSED, \"Received %s frame for an unknown stream %d\",\n                                  frameName, streamId);\n            } else if (stream.isResetSent() || streamCreatedAfterGoAwaySent(streamId)) {\n                // If we have sent a reset stream it is assumed the stream will be closed after the write completes.\n                // If we have not sent a reset, but the stream was created after a GoAway this is not supported by\n                // DefaultHttp2Connection and if a custom Http2Connection is used it is assumed the lifetime is managed\n                // elsewhere so we don't close the stream or otherwise modify the stream's state.\n\n                if (logger.isInfoEnabled()) {\n                    logger.info(\"{} ignoring {} frame for stream {}\", ctx.channel(), frameName,\n                            stream.isResetSent() ? \"RST_STREAM sent.\" :\n                                (\"Stream created after GOAWAY sent. Last known stream by peer \" +\n                                 connection.remote().lastStreamKnownByPeer()));\n                }\n\n                return true;\n            }\n            return false;\n        }\n\n        /**\n         * Helper method for determining whether or not to ignore inbound frames. A stream is considered to be created\n         * after a {@code GOAWAY} is sent if the following conditions hold:\n         * <p/>\n         * <ul>\n         *     <li>A {@code GOAWAY} must have been sent by the local endpoint</li>\n         *     <li>The {@code streamId} must identify a legitimate stream id for the remote endpoint to be creating</li>\n         *     <li>{@code streamId} is greater than the Last Known Stream ID which was sent by the local endpoint\n         *     in the last {@code GOAWAY} frame</li>\n         * </ul>\n         * <p/>\n         */\n        private boolean streamCreatedAfterGoAwaySent(int streamId) {\n            Endpoint<?> remote = connection.remote();\n            return connection.goAwaySent() && remote.isValidStreamId(streamId) &&\n                    streamId > remote.lastStreamKnownByPeer();\n        }\n\n        private void verifyStreamMayHaveExisted(int streamId) throws Http2Exception {\n            if (!connection.streamMayHaveExisted(streamId)) {\n                throw connectionError(PROTOCOL_ERROR, \"Stream %d does not exist\", streamId);\n            }\n        }\n    }\n\n    private final class PrefaceFrameListener implements Http2FrameListener {\n        /**\n         * Verifies that the HTTP/2 connection preface has been received from the remote endpoint.\n         * It is possible that the current call to\n         * {@link Http2FrameReader#readFrame(ChannelHandlerContext, ByteBuf, Http2FrameListener)} will have multiple\n         * frames to dispatch. So it may be OK for this class to get legitimate frames for the first readFrame.\n         */\n        private void verifyPrefaceReceived() throws Http2Exception {\n            if (!prefaceReceived()) {\n                throw connectionError(PROTOCOL_ERROR, \"Received non-SETTINGS as first frame.\");\n            }\n        }\n\n        @Override\n        public int onDataRead(ChannelHandlerContext ctx, int streamId, ByteBuf data, int padding, boolean endOfStream)\n                throws Http2Exception {\n            verifyPrefaceReceived();\n            return internalFrameListener.onDataRead(ctx, streamId, data, padding, endOfStream);\n        }\n\n        @Override\n        public void onHeadersRead(ChannelHandlerContext ctx, int streamId, Http2Headers headers, int padding,\n                boolean endOfStream) throws Http2Exception {\n            verifyPrefaceReceived();\n            internalFrameListener.onHeadersRead(ctx, streamId, headers, padding, endOfStream);\n        }\n\n        @Override\n        public void onHeadersRead(ChannelHandlerContext ctx, int streamId, Http2Headers headers, int streamDependency,\n                short weight, boolean exclusive, int padding, boolean endOfStream) throws Http2Exception {\n            verifyPrefaceReceived();\n            internalFrameListener.onHeadersRead(ctx, streamId, headers, streamDependency, weight,\n                    exclusive, padding, endOfStream);\n        }\n\n        @Override\n        public void onPriorityRead(ChannelHandlerContext ctx, int streamId, int streamDependency, short weight,\n                boolean exclusive) throws Http2Exception {\n            verifyPrefaceReceived();\n            internalFrameListener.onPriorityRead(ctx, streamId, streamDependency, weight, exclusive);\n        }\n\n        @Override\n        public void onRstStreamRead(ChannelHandlerContext ctx, int streamId, long errorCode) throws Http2Exception {\n            verifyPrefaceReceived();\n            internalFrameListener.onRstStreamRead(ctx, streamId, errorCode);\n        }\n\n        @Override\n        public void onSettingsAckRead(ChannelHandlerContext ctx) throws Http2Exception {\n            verifyPrefaceReceived();\n            internalFrameListener.onSettingsAckRead(ctx);\n        }\n\n        @Override\n        public void onSettingsRead(ChannelHandlerContext ctx, Http2Settings settings) throws Http2Exception {\n            // The first settings should change the internalFrameListener to the \"real\" listener\n            // that expects the preface to be verified.\n            if (!prefaceReceived()) {\n                internalFrameListener = new FrameReadListener();\n            }\n            internalFrameListener.onSettingsRead(ctx, settings);\n        }\n\n        @Override\n        public void onPingRead(ChannelHandlerContext ctx, long data) throws Http2Exception {\n            verifyPrefaceReceived();\n            internalFrameListener.onPingRead(ctx, data);\n        }\n\n        @Override\n        public void onPingAckRead(ChannelHandlerContext ctx, long data) throws Http2Exception {\n            verifyPrefaceReceived();\n            internalFrameListener.onPingAckRead(ctx, data);\n        }\n\n        @Override\n        public void onPushPromiseRead(ChannelHandlerContext ctx, int streamId, int promisedStreamId,\n                Http2Headers headers, int padding) throws Http2Exception {\n            verifyPrefaceReceived();\n            internalFrameListener.onPushPromiseRead(ctx, streamId, promisedStreamId, headers, padding);\n        }\n\n        @Override\n        public void onGoAwayRead(ChannelHandlerContext ctx, int lastStreamId, long errorCode, ByteBuf debugData)\n                throws Http2Exception {\n            onGoAwayRead0(ctx, lastStreamId, errorCode, debugData);\n        }\n\n        @Override\n        public void onWindowUpdateRead(ChannelHandlerContext ctx, int streamId, int windowSizeIncrement)\n                throws Http2Exception {\n            verifyPrefaceReceived();\n            internalFrameListener.onWindowUpdateRead(ctx, streamId, windowSizeIncrement);\n        }\n\n        @Override\n        public void onUnknownFrame(ChannelHandlerContext ctx, byte frameType, int streamId, Http2Flags flags,\n                ByteBuf payload) throws Http2Exception {\n            onUnknownFrame0(ctx, frameType, streamId, flags, payload);\n        }\n    }\n}\n", "/*\n * Copyright 2014 The Netty Project\n *\n * The Netty Project licenses this file to you under the Apache License, version 2.0 (the\n * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n * copy of the License at:\n *\n * https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under the License\n * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n * or implied. See the License for the specific language governing permissions and limitations under\n * the License.\n */\npackage io.netty.handler.codec.http2;\n\nimport io.netty.buffer.ByteBuf;\nimport io.netty.buffer.UnpooledByteBufAllocator;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelHandlerContext;\nimport io.netty.channel.ChannelPromise;\nimport io.netty.channel.DefaultChannelPromise;\nimport io.netty.handler.codec.http.HttpResponseStatus;\nimport junit.framework.AssertionFailedError;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.mockito.ArgumentCaptor;\nimport org.mockito.Mock;\nimport org.mockito.MockitoAnnotations;\nimport org.mockito.invocation.InvocationOnMock;\nimport org.mockito.stubbing.Answer;\n\nimport java.util.Collections;\nimport java.util.concurrent.atomic.AtomicInteger;\n\nimport static io.netty.buffer.Unpooled.EMPTY_BUFFER;\nimport static io.netty.buffer.Unpooled.wrappedBuffer;\nimport static io.netty.handler.codec.http2.Http2CodecUtil.DEFAULT_PRIORITY_WEIGHT;\nimport static io.netty.handler.codec.http2.Http2Error.PROTOCOL_ERROR;\nimport static io.netty.handler.codec.http2.Http2Stream.State.IDLE;\nimport static io.netty.handler.codec.http2.Http2Stream.State.OPEN;\nimport static io.netty.handler.codec.http2.Http2Stream.State.RESERVED_REMOTE;\nimport static io.netty.util.CharsetUtil.UTF_8;\n\nimport static org.hamcrest.MatcherAssert.assertThat;\nimport static org.hamcrest.Matchers.instanceOf;\nimport static org.hamcrest.Matchers.not;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertTrue;\nimport static org.junit.Assert.fail;\nimport static org.mockito.Mockito.any;\nimport static org.mockito.Mockito.anyBoolean;\nimport static org.mockito.Mockito.anyInt;\nimport static org.mockito.Mockito.anyLong;\nimport static org.mockito.Mockito.anyShort;\nimport static org.mockito.Mockito.doAnswer;\nimport static org.mockito.Mockito.doNothing;\nimport static org.mockito.Mockito.eq;\nimport static org.mockito.Mockito.isNull;\nimport static org.mockito.Mockito.never;\nimport static org.mockito.Mockito.times;\nimport static org.mockito.Mockito.verify;\nimport static org.mockito.Mockito.verifyNoMoreInteractions;\nimport static org.mockito.Mockito.when;\n\n/**\n * Tests for {@link DefaultHttp2ConnectionDecoder}.\n */\npublic class DefaultHttp2ConnectionDecoderTest {\n    private static final int STREAM_ID = 3;\n    private static final int PUSH_STREAM_ID = 2;\n    private static final int STREAM_DEPENDENCY_ID = 5;\n    private static final int STATE_RECV_HEADERS = 1;\n    private static final int STATE_RECV_TRAILERS = 1 << 1;\n\n    private Http2ConnectionDecoder decoder;\n    private ChannelPromise promise;\n\n    @Mock\n    private Http2Connection connection;\n\n    @Mock\n    private Http2Connection.Endpoint<Http2RemoteFlowController> remote;\n\n    @Mock\n    private Http2Connection.Endpoint<Http2LocalFlowController> local;\n\n    @Mock\n    private Http2LocalFlowController localFlow;\n\n    @Mock\n    private Http2RemoteFlowController remoteFlow;\n\n    @Mock\n    private ChannelHandlerContext ctx;\n\n    @Mock\n    private Channel channel;\n\n    @Mock\n    private ChannelFuture future;\n\n    @Mock\n    private Http2Stream stream;\n\n    @Mock\n    private Http2Stream pushStream;\n\n    @Mock\n    private Http2FrameListener listener;\n\n    @Mock\n    private Http2FrameReader reader;\n\n    @Mock\n    private Http2FrameWriter writer;\n\n    @Mock\n    private Http2ConnectionEncoder encoder;\n\n    @Mock\n    private Http2LifecycleManager lifecycleManager;\n\n    @Before\n    public void setup() throws Exception {\n        MockitoAnnotations.initMocks(this);\n\n        promise = new DefaultChannelPromise(channel);\n\n        final AtomicInteger headersReceivedState = new AtomicInteger();\n        when(channel.isActive()).thenReturn(true);\n        when(stream.id()).thenReturn(STREAM_ID);\n        when(stream.state()).thenReturn(OPEN);\n        when(stream.open(anyBoolean())).thenReturn(stream);\n        when(pushStream.id()).thenReturn(PUSH_STREAM_ID);\n        doAnswer(new Answer<Boolean>() {\n            @Override\n            public Boolean answer(InvocationOnMock in) throws Throwable {\n                return (headersReceivedState.get() & STATE_RECV_HEADERS) != 0;\n            }\n        }).when(stream).isHeadersReceived();\n        doAnswer(new Answer<Boolean>() {\n            @Override\n            public Boolean answer(InvocationOnMock in) throws Throwable {\n                return (headersReceivedState.get() & STATE_RECV_TRAILERS) != 0;\n            }\n        }).when(stream).isTrailersReceived();\n        doAnswer(new Answer<Http2Stream>() {\n            @Override\n            public Http2Stream answer(InvocationOnMock in) throws Throwable {\n                boolean isInformational = in.getArgument(0);\n                if (isInformational) {\n                    return stream;\n                }\n                for (;;) {\n                    int current = headersReceivedState.get();\n                    int next = current;\n                    if ((current & STATE_RECV_HEADERS) != 0) {\n                        if ((current & STATE_RECV_TRAILERS) != 0) {\n                            throw new IllegalStateException(\"already sent headers!\");\n                        }\n                        next |= STATE_RECV_TRAILERS;\n                    } else {\n                        next |= STATE_RECV_HEADERS;\n                    }\n                    if (headersReceivedState.compareAndSet(current, next)) {\n                        break;\n                    }\n                }\n                return stream;\n            }\n        }).when(stream).headersReceived(anyBoolean());\n        doAnswer(new Answer<Http2Stream>() {\n            @Override\n            public Http2Stream answer(InvocationOnMock in) throws Throwable {\n                Http2StreamVisitor visitor = in.getArgument(0);\n                if (!visitor.visit(stream)) {\n                    return stream;\n                }\n                return null;\n            }\n        }).when(connection).forEachActiveStream(any(Http2StreamVisitor.class));\n        when(connection.stream(STREAM_ID)).thenReturn(stream);\n        when(connection.streamMayHaveExisted(STREAM_ID)).thenReturn(true);\n        when(connection.local()).thenReturn(local);\n        when(local.flowController()).thenReturn(localFlow);\n        when(encoder.flowController()).thenReturn(remoteFlow);\n        when(encoder.frameWriter()).thenReturn(writer);\n        when(connection.remote()).thenReturn(remote);\n        when(local.reservePushStream(eq(PUSH_STREAM_ID), eq(stream))).thenReturn(pushStream);\n        when(remote.reservePushStream(eq(PUSH_STREAM_ID), eq(stream))).thenReturn(pushStream);\n        when(ctx.alloc()).thenReturn(UnpooledByteBufAllocator.DEFAULT);\n        when(ctx.channel()).thenReturn(channel);\n        when(ctx.newSucceededFuture()).thenReturn(future);\n        when(ctx.newPromise()).thenReturn(promise);\n        when(ctx.write(any())).thenReturn(future);\n\n        decoder = new DefaultHttp2ConnectionDecoder(connection, encoder, reader);\n        decoder.lifecycleManager(lifecycleManager);\n        decoder.frameListener(listener);\n\n        // Simulate receiving the initial settings from the remote endpoint.\n        decode().onSettingsRead(ctx, new Http2Settings());\n        verify(listener).onSettingsRead(eq(ctx), eq(new Http2Settings()));\n        assertTrue(decoder.prefaceReceived());\n        verify(encoder).writeSettingsAck(eq(ctx), eq(promise));\n\n        // Simulate receiving the SETTINGS ACK for the initial settings.\n        decode().onSettingsAckRead(ctx);\n\n        // Disallow any further flushes now that settings ACK has been sent\n        when(ctx.flush()).thenThrow(new AssertionFailedError(\"forbidden\"));\n    }\n\n    @Test\n    public void dataReadAfterGoAwaySentShouldApplyFlowControl() throws Exception {\n        mockGoAwaySent();\n\n        final ByteBuf data = dummyData();\n        int padding = 10;\n        int processedBytes = data.readableBytes() + padding;\n        mockFlowControl(processedBytes);\n        try {\n            decode().onDataRead(ctx, STREAM_ID, data, padding, true);\n            verify(localFlow).receiveFlowControlledFrame(eq(stream), eq(data), eq(padding), eq(true));\n            verify(localFlow).consumeBytes(eq(stream), eq(processedBytes));\n\n            // Verify that the event was absorbed and not propagated to the observer.\n            verify(listener, never()).onDataRead(eq(ctx), anyInt(), any(ByteBuf.class), anyInt(), anyBoolean());\n        } finally {\n            data.release();\n        }\n    }\n\n    @Test\n    public void dataReadAfterGoAwaySentShouldAllowFramesForStreamCreatedByLocalEndpoint() throws Exception {\n        mockGoAwaySentShouldAllowFramesForStreamCreatedByLocalEndpoint();\n\n        final ByteBuf data = dummyData();\n        int padding = 10;\n        int processedBytes = data.readableBytes() + padding;\n        mockFlowControl(processedBytes);\n        try {\n            decode().onDataRead(ctx, STREAM_ID, data, padding, true);\n            verify(localFlow).receiveFlowControlledFrame(eq(stream), eq(data), eq(padding), eq(true));\n            verify(localFlow).consumeBytes(eq(stream), eq(processedBytes));\n\n            // Verify that the event was absorbed and not propagated to the observer.\n            verify(listener).onDataRead(eq(ctx), anyInt(), any(ByteBuf.class), anyInt(), anyBoolean());\n        } finally {\n            data.release();\n        }\n    }\n\n    @Test(expected = Http2Exception.StreamException.class)\n    public void dataReadForUnknownStreamShouldApplyFlowControlAndFail() throws Exception {\n        when(connection.streamMayHaveExisted(STREAM_ID)).thenReturn(true);\n        when(connection.stream(STREAM_ID)).thenReturn(null);\n        final ByteBuf data = dummyData();\n        int padding = 10;\n        int processedBytes = data.readableBytes() + padding;\n        try {\n            decode().onDataRead(ctx, STREAM_ID, data, padding, true);\n        } finally {\n            try {\n                verify(localFlow)\n                        .receiveFlowControlledFrame(eq((Http2Stream) null), eq(data), eq(padding), eq(true));\n                verify(localFlow).consumeBytes(eq((Http2Stream) null), eq(processedBytes));\n                verify(localFlow).frameWriter(any(Http2FrameWriter.class));\n                verifyNoMoreInteractions(localFlow);\n                verify(listener, never()).onDataRead(eq(ctx), anyInt(), any(ByteBuf.class), anyInt(), anyBoolean());\n            } finally {\n                data.release();\n            }\n        }\n    }\n\n    @Test(expected = Http2Exception.class)\n    public void dataReadForUnknownStreamThatCouldntExistFail() throws Exception {\n        when(connection.streamMayHaveExisted(STREAM_ID)).thenReturn(false);\n        when(connection.stream(STREAM_ID)).thenReturn(null);\n        final ByteBuf data = dummyData();\n        int padding = 10;\n        int processedBytes = data.readableBytes() + padding;\n        try {\n            decode().onDataRead(ctx, STREAM_ID, data, padding, true);\n        } catch (Http2Exception ex) {\n            assertThat(ex, not(instanceOf(Http2Exception.StreamException.class)));\n            throw ex;\n        } finally {\n            try {\n                verify(localFlow)\n                    .receiveFlowControlledFrame(eq((Http2Stream) null), eq(data), eq(padding), eq(true));\n                verify(localFlow).consumeBytes(eq((Http2Stream) null), eq(processedBytes));\n                verify(localFlow).frameWriter(any(Http2FrameWriter.class));\n                verifyNoMoreInteractions(localFlow);\n                verify(listener, never()).onDataRead(eq(ctx), anyInt(), any(ByteBuf.class), anyInt(), anyBoolean());\n            } finally {\n                data.release();\n            }\n        }\n    }\n\n    @Test\n    public void dataReadForUnknownStreamShouldApplyFlowControl() throws Exception {\n        when(connection.stream(STREAM_ID)).thenReturn(null);\n        final ByteBuf data = dummyData();\n        int padding = 10;\n        int processedBytes = data.readableBytes() + padding;\n        try {\n            try {\n                decode().onDataRead(ctx, STREAM_ID, data, padding, true);\n                fail();\n            } catch (Http2Exception e) {\n                verify(localFlow)\n                        .receiveFlowControlledFrame(eq((Http2Stream) null), eq(data), eq(padding), eq(true));\n                verify(localFlow).consumeBytes(eq((Http2Stream) null), eq(processedBytes));\n                verify(localFlow).frameWriter(any(Http2FrameWriter.class));\n                verifyNoMoreInteractions(localFlow);\n\n                // Verify that the event was absorbed and not propagated to the observer.\n                verify(listener, never()).onDataRead(eq(ctx), anyInt(), any(ByteBuf.class), anyInt(), anyBoolean());\n            }\n        } finally {\n            data.release();\n        }\n    }\n\n    @Test\n    public void emptyDataFrameShouldApplyFlowControl() throws Exception {\n        final ByteBuf data = EMPTY_BUFFER;\n        int padding = 0;\n        mockFlowControl(0);\n        try {\n            decode().onDataRead(ctx, STREAM_ID, data, padding, true);\n            verify(localFlow).receiveFlowControlledFrame(eq(stream), eq(data), eq(padding), eq(true));\n\n            // Now we ignore the empty bytes inside consumeBytes method, so it will be called once.\n            verify(localFlow).consumeBytes(eq(stream), eq(0));\n\n            // Verify that the empty data event was propagated to the observer.\n            verify(listener).onDataRead(eq(ctx), eq(STREAM_ID), eq(data), eq(padding), eq(true));\n        } finally {\n            data.release();\n        }\n    }\n\n    @Test(expected = Http2Exception.class)\n    public void dataReadForStreamInInvalidStateShouldThrow() throws Exception {\n        // Throw an exception when checking stream state.\n        when(stream.state()).thenReturn(Http2Stream.State.CLOSED);\n        final ByteBuf data = dummyData();\n        try {\n            decode().onDataRead(ctx, STREAM_ID, data, 10, true);\n        } finally {\n            data.release();\n        }\n    }\n\n    @Test\n    public void dataReadAfterGoAwaySentForStreamInInvalidStateShouldIgnore() throws Exception {\n        // Throw an exception when checking stream state.\n        when(stream.state()).thenReturn(Http2Stream.State.CLOSED);\n        mockGoAwaySent();\n        final ByteBuf data = dummyData();\n        try {\n            decode().onDataRead(ctx, STREAM_ID, data, 10, true);\n            verify(localFlow).receiveFlowControlledFrame(eq(stream), eq(data), eq(10), eq(true));\n            verify(listener, never()).onDataRead(eq(ctx), anyInt(), any(ByteBuf.class), anyInt(), anyBoolean());\n        } finally {\n            data.release();\n        }\n    }\n\n    @Test\n    public void dataReadAfterGoAwaySentOnUnknownStreamShouldIgnore() throws Exception {\n        // Throw an exception when checking stream state.\n        when(connection.stream(STREAM_ID)).thenReturn(null);\n        mockGoAwaySent();\n        final ByteBuf data = dummyData();\n        try {\n            decode().onDataRead(ctx, STREAM_ID, data, 10, true);\n            verify(localFlow).receiveFlowControlledFrame((Http2Stream) isNull(), eq(data), eq(10), eq(true));\n            verify(listener, never()).onDataRead(eq(ctx), anyInt(), any(ByteBuf.class), anyInt(), anyBoolean());\n        } finally {\n            data.release();\n        }\n    }\n\n    @Test\n    public void dataReadAfterRstStreamForStreamInInvalidStateShouldIgnore() throws Exception {\n        // Throw an exception when checking stream state.\n        when(stream.state()).thenReturn(Http2Stream.State.CLOSED);\n        when(stream.isResetSent()).thenReturn(true);\n        final ByteBuf data = dummyData();\n        try {\n            decode().onDataRead(ctx, STREAM_ID, data, 10, true);\n            verify(localFlow).receiveFlowControlledFrame(eq(stream), eq(data), eq(10), eq(true));\n            verify(listener, never()).onDataRead(eq(ctx), anyInt(), any(ByteBuf.class), anyInt(), anyBoolean());\n        } finally {\n            data.release();\n        }\n    }\n\n    @Test\n    public void dataReadWithEndOfStreamShouldcloseStreamRemote() throws Exception {\n        final ByteBuf data = dummyData();\n        try {\n            decode().onDataRead(ctx, STREAM_ID, data, 10, true);\n            verify(localFlow).receiveFlowControlledFrame(eq(stream), eq(data), eq(10), eq(true));\n            verify(lifecycleManager).closeStreamRemote(eq(stream), eq(future));\n            verify(listener).onDataRead(eq(ctx), eq(STREAM_ID), eq(data), eq(10), eq(true));\n        } finally {\n            data.release();\n        }\n    }\n\n    @Test\n    public void errorDuringDeliveryShouldReturnCorrectNumberOfBytes() throws Exception {\n        final ByteBuf data = dummyData();\n        final int padding = 10;\n        final AtomicInteger unprocessed = new AtomicInteger(data.readableBytes() + padding);\n        doAnswer(new Answer<Integer>() {\n            @Override\n            public Integer answer(InvocationOnMock in) throws Throwable {\n                return unprocessed.get();\n            }\n        }).when(localFlow).unconsumedBytes(eq(stream));\n        doAnswer(new Answer<Void>() {\n            @Override\n            public Void answer(InvocationOnMock in) throws Throwable {\n                int delta = (Integer) in.getArguments()[1];\n                int newValue = unprocessed.addAndGet(-delta);\n                if (newValue < 0) {\n                    throw new RuntimeException(\"Returned too many bytes\");\n                }\n                return null;\n            }\n        }).when(localFlow).consumeBytes(eq(stream), anyInt());\n        // When the listener callback is called, process a few bytes and then throw.\n        doAnswer(new Answer<Integer>() {\n            @Override\n            public Integer answer(InvocationOnMock in) throws Throwable {\n                localFlow.consumeBytes(stream, 4);\n                throw new RuntimeException(\"Fake Exception\");\n            }\n        }).when(listener).onDataRead(eq(ctx), eq(STREAM_ID), any(ByteBuf.class), eq(10), eq(true));\n        try {\n            decode().onDataRead(ctx, STREAM_ID, data, padding, true);\n            fail(\"Expected exception\");\n        } catch (RuntimeException cause) {\n            verify(localFlow)\n                    .receiveFlowControlledFrame(eq(stream), eq(data), eq(padding), eq(true));\n            verify(lifecycleManager).closeStreamRemote(eq(stream), eq(future));\n            verify(listener).onDataRead(eq(ctx), eq(STREAM_ID), eq(data), eq(padding), eq(true));\n            assertEquals(0, localFlow.unconsumedBytes(stream));\n        } finally {\n            data.release();\n        }\n    }\n\n    @Test(expected = Http2Exception.class)\n    public void headersReadForUnknownStreamShouldThrow() throws Exception {\n        when(connection.stream(STREAM_ID)).thenReturn(null);\n        decode().onHeadersRead(ctx, STREAM_ID, EmptyHttp2Headers.INSTANCE, 0, false);\n    }\n\n    @Test\n    public void headersReadForStreamThatAlreadySentResetShouldBeIgnored() throws Exception {\n        when(stream.isResetSent()).thenReturn(true);\n        decode().onHeadersRead(ctx, STREAM_ID, EmptyHttp2Headers.INSTANCE, 0, false);\n        verify(remote, never()).createStream(anyInt(), anyBoolean());\n        verify(stream, never()).open(anyBoolean());\n\n        // Verify that the event was absorbed and not propagated to the observer.\n        verify(listener, never()).onHeadersRead(eq(ctx), anyInt(), any(Http2Headers.class), anyInt(), anyBoolean());\n        verify(remote, never()).createStream(anyInt(), anyBoolean());\n        verify(stream, never()).open(anyBoolean());\n    }\n\n    @Test\n    public void headersReadForUnknownStreamAfterGoAwayShouldBeIgnored() throws Exception {\n        mockGoAwaySent();\n        when(connection.stream(STREAM_ID)).thenReturn(null);\n        decode().onHeadersRead(ctx, STREAM_ID, EmptyHttp2Headers.INSTANCE, 0, false);\n        verify(remote, never()).createStream(anyInt(), anyBoolean());\n        verify(stream, never()).open(anyBoolean());\n\n        // Verify that the event was absorbed and not propagated to the observer.\n        verify(listener, never()).onHeadersRead(eq(ctx), anyInt(), any(Http2Headers.class), anyInt(), anyBoolean());\n        verify(remote, never()).createStream(anyInt(), anyBoolean());\n        verify(stream, never()).open(anyBoolean());\n    }\n\n    @Test\n    public void headersReadForUnknownStreamShouldCreateStream() throws Exception {\n        final int streamId = 5;\n        when(remote.createStream(eq(streamId), anyBoolean())).thenReturn(stream);\n        decode().onHeadersRead(ctx, streamId, EmptyHttp2Headers.INSTANCE, 0, false);\n        verify(remote).createStream(eq(streamId), eq(false));\n        verify(listener).onHeadersRead(eq(ctx), eq(streamId), eq(EmptyHttp2Headers.INSTANCE), eq(0),\n                eq(DEFAULT_PRIORITY_WEIGHT), eq(false), eq(0), eq(false));\n    }\n\n    @Test\n    public void headersReadForUnknownStreamShouldCreateHalfClosedStream() throws Exception {\n        final int streamId = 5;\n        when(remote.createStream(eq(streamId), anyBoolean())).thenReturn(stream);\n        decode().onHeadersRead(ctx, streamId, EmptyHttp2Headers.INSTANCE, 0, true);\n        verify(remote).createStream(eq(streamId), eq(true));\n        verify(listener).onHeadersRead(eq(ctx), eq(streamId), eq(EmptyHttp2Headers.INSTANCE), eq(0),\n                eq(DEFAULT_PRIORITY_WEIGHT), eq(false), eq(0), eq(true));\n    }\n\n    @Test\n    public void headersReadForPromisedStreamShouldHalfOpenStream() throws Exception {\n        when(stream.state()).thenReturn(RESERVED_REMOTE);\n        decode().onHeadersRead(ctx, STREAM_ID, EmptyHttp2Headers.INSTANCE, 0, false);\n        verify(stream).open(false);\n        verify(listener).onHeadersRead(eq(ctx), eq(STREAM_ID), eq(EmptyHttp2Headers.INSTANCE), eq(0),\n                eq(DEFAULT_PRIORITY_WEIGHT), eq(false), eq(0), eq(false));\n    }\n\n    @Test(expected = Http2Exception.class)\n    public void trailersDoNotEndStreamThrows() throws Exception {\n        decode().onHeadersRead(ctx, STREAM_ID, EmptyHttp2Headers.INSTANCE, 0, false);\n        // Trailers must end the stream!\n        decode().onHeadersRead(ctx, STREAM_ID, EmptyHttp2Headers.INSTANCE, 0, false);\n    }\n\n    @Test(expected = Http2Exception.class)\n    public void tooManyHeadersEOSThrows() throws Exception {\n        tooManyHeaderThrows(true);\n    }\n\n    @Test(expected = Http2Exception.class)\n    public void tooManyHeadersNoEOSThrows() throws Exception {\n        tooManyHeaderThrows(false);\n    }\n\n    private void tooManyHeaderThrows(boolean eos) throws Exception {\n        decode().onHeadersRead(ctx, STREAM_ID, EmptyHttp2Headers.INSTANCE, 0, false);\n        decode().onHeadersRead(ctx, STREAM_ID, EmptyHttp2Headers.INSTANCE, 0, true);\n        // We already received the trailers!\n        decode().onHeadersRead(ctx, STREAM_ID, EmptyHttp2Headers.INSTANCE, 0, eos);\n    }\n\n    private static Http2Headers informationalHeaders() {\n        Http2Headers headers = new DefaultHttp2Headers();\n        headers.status(HttpResponseStatus.CONTINUE.codeAsText());\n        return headers;\n    }\n\n    @Test\n    public void infoHeadersAndTrailersAllowed() throws Exception {\n        infoHeadersAndTrailersAllowed(true, 1);\n    }\n\n    @Test\n    public void multipleInfoHeadersAndTrailersAllowed() throws Exception {\n        infoHeadersAndTrailersAllowed(true, 10);\n    }\n\n    @Test(expected = Http2Exception.class)\n    public void infoHeadersAndTrailersNoEOSThrows() throws Exception {\n        infoHeadersAndTrailersAllowed(false, 1);\n    }\n\n    @Test(expected = Http2Exception.class)\n    public void multipleInfoHeadersAndTrailersNoEOSThrows() throws Exception {\n        infoHeadersAndTrailersAllowed(false, 10);\n    }\n\n    private void infoHeadersAndTrailersAllowed(boolean eos, int infoHeaderCount) throws Exception {\n        for (int i = 0; i < infoHeaderCount; ++i) {\n            decode().onHeadersRead(ctx, STREAM_ID, informationalHeaders(), 0, false);\n        }\n        decode().onHeadersRead(ctx, STREAM_ID, EmptyHttp2Headers.INSTANCE, 0, false);\n        decode().onHeadersRead(ctx, STREAM_ID, EmptyHttp2Headers.INSTANCE, 0, eos);\n    }\n\n    @Test()\n    public void headersReadForPromisedStreamShouldCloseStream() throws Exception {\n        when(stream.state()).thenReturn(RESERVED_REMOTE);\n        decode().onHeadersRead(ctx, STREAM_ID, EmptyHttp2Headers.INSTANCE, 0, true);\n        verify(stream).open(true);\n        verify(lifecycleManager).closeStreamRemote(eq(stream), eq(future));\n        verify(listener).onHeadersRead(eq(ctx), eq(STREAM_ID), eq(EmptyHttp2Headers.INSTANCE), eq(0),\n                eq(DEFAULT_PRIORITY_WEIGHT), eq(false), eq(0), eq(true));\n    }\n\n    @Test\n    public void headersDependencyNotCreatedShouldCreateAndSucceed() throws Exception {\n        final short weight = 1;\n        decode().onHeadersRead(ctx, STREAM_ID, EmptyHttp2Headers.INSTANCE, STREAM_DEPENDENCY_ID,\n                weight, true, 0, true);\n        verify(listener).onHeadersRead(eq(ctx), eq(STREAM_ID), eq(EmptyHttp2Headers.INSTANCE), eq(STREAM_DEPENDENCY_ID),\n                eq(weight), eq(true), eq(0), eq(true));\n        verify(remoteFlow).updateDependencyTree(eq(STREAM_ID), eq(STREAM_DEPENDENCY_ID), eq(weight), eq(true));\n        verify(lifecycleManager).closeStreamRemote(eq(stream), any(ChannelFuture.class));\n    }\n\n    @Test\n    public void pushPromiseReadAfterGoAwaySentShouldBeIgnored() throws Exception {\n        mockGoAwaySent();\n        decode().onPushPromiseRead(ctx, STREAM_ID, PUSH_STREAM_ID, EmptyHttp2Headers.INSTANCE, 0);\n        verify(remote, never()).reservePushStream(anyInt(), any(Http2Stream.class));\n        verify(listener, never()).onPushPromiseRead(eq(ctx), anyInt(), anyInt(), any(Http2Headers.class), anyInt());\n    }\n\n    @Test\n    public void pushPromiseReadAfterGoAwayShouldAllowFramesForStreamCreatedByLocalEndpoint() throws Exception {\n        mockGoAwaySentShouldAllowFramesForStreamCreatedByLocalEndpoint();\n        decode().onPushPromiseRead(ctx, STREAM_ID, PUSH_STREAM_ID, EmptyHttp2Headers.INSTANCE, 0);\n        verify(remote).reservePushStream(anyInt(), any(Http2Stream.class));\n        verify(listener).onPushPromiseRead(eq(ctx), anyInt(), anyInt(), any(Http2Headers.class), anyInt());\n    }\n\n    @Test(expected = Http2Exception.class)\n    public void pushPromiseReadForUnknownStreamShouldThrow() throws Exception {\n        when(connection.stream(STREAM_ID)).thenReturn(null);\n        decode().onPushPromiseRead(ctx, STREAM_ID, PUSH_STREAM_ID, EmptyHttp2Headers.INSTANCE, 0);\n    }\n\n    @Test\n    public void pushPromiseReadShouldSucceed() throws Exception {\n        decode().onPushPromiseRead(ctx, STREAM_ID, PUSH_STREAM_ID, EmptyHttp2Headers.INSTANCE, 0);\n        verify(remote).reservePushStream(eq(PUSH_STREAM_ID), eq(stream));\n        verify(listener).onPushPromiseRead(eq(ctx), eq(STREAM_ID), eq(PUSH_STREAM_ID),\n                eq(EmptyHttp2Headers.INSTANCE), eq(0));\n    }\n\n    @Test\n    public void priorityReadAfterGoAwaySentShouldAllowFramesForStreamCreatedByLocalEndpoint() throws Exception {\n        mockGoAwaySentShouldAllowFramesForStreamCreatedByLocalEndpoint();\n        decode().onPriorityRead(ctx, STREAM_ID, 0, (short) 255, true);\n        verify(remoteFlow).updateDependencyTree(eq(STREAM_ID), eq(0), eq((short) 255), eq(true));\n        verify(listener).onPriorityRead(eq(ctx), anyInt(), anyInt(), anyShort(), anyBoolean());\n    }\n\n    @Test\n    public void priorityReadForUnknownStreamShouldNotBeIgnored() throws Exception {\n        when(connection.stream(STREAM_ID)).thenReturn(null);\n        decode().onPriorityRead(ctx, STREAM_ID, 0, (short) 255, true);\n        verify(remoteFlow).updateDependencyTree(eq(STREAM_ID), eq(0), eq((short) 255), eq(true));\n        verify(listener).onPriorityRead(eq(ctx), eq(STREAM_ID), eq(0), eq((short) 255), eq(true));\n    }\n\n    @Test\n    public void priorityReadShouldNotCreateNewStream() throws Exception {\n        when(connection.streamMayHaveExisted(STREAM_ID)).thenReturn(false);\n        when(connection.stream(STREAM_ID)).thenReturn(null);\n        decode().onPriorityRead(ctx, STREAM_ID, STREAM_DEPENDENCY_ID, (short) 255, true);\n        verify(remoteFlow).updateDependencyTree(eq(STREAM_ID), eq(STREAM_DEPENDENCY_ID), eq((short) 255), eq(true));\n        verify(listener).onPriorityRead(eq(ctx), eq(STREAM_ID), eq(STREAM_DEPENDENCY_ID), eq((short) 255), eq(true));\n        verify(remote, never()).createStream(eq(STREAM_ID), anyBoolean());\n        verify(stream, never()).open(anyBoolean());\n    }\n\n    @Test\n    public void windowUpdateReadAfterGoAwaySentShouldBeIgnored() throws Exception {\n        mockGoAwaySent();\n        decode().onWindowUpdateRead(ctx, STREAM_ID, 10);\n        verify(remoteFlow, never()).incrementWindowSize(any(Http2Stream.class), anyInt());\n        verify(listener, never()).onWindowUpdateRead(eq(ctx), anyInt(), anyInt());\n    }\n\n    @Test\n    public void windowUpdateReadAfterGoAwaySentShouldAllowFramesForStreamCreatedByLocalEndpoint() throws Exception {\n        mockGoAwaySentShouldAllowFramesForStreamCreatedByLocalEndpoint();\n        decode().onWindowUpdateRead(ctx, STREAM_ID, 10);\n        verify(remoteFlow).incrementWindowSize(any(Http2Stream.class), anyInt());\n        verify(listener).onWindowUpdateRead(eq(ctx), anyInt(), anyInt());\n    }\n\n    @Test(expected = Http2Exception.class)\n    public void windowUpdateReadForUnknownStreamShouldThrow() throws Exception {\n        when(connection.streamMayHaveExisted(STREAM_ID)).thenReturn(false);\n        when(connection.stream(STREAM_ID)).thenReturn(null);\n        decode().onWindowUpdateRead(ctx, STREAM_ID, 10);\n    }\n\n    @Test\n    public void windowUpdateReadForUnknownStreamShouldBeIgnored() throws Exception {\n        when(connection.stream(STREAM_ID)).thenReturn(null);\n        decode().onWindowUpdateRead(ctx, STREAM_ID, 10);\n        verify(remoteFlow, never()).incrementWindowSize(any(Http2Stream.class), anyInt());\n        verify(listener, never()).onWindowUpdateRead(eq(ctx), anyInt(), anyInt());\n    }\n\n    @Test\n    public void windowUpdateReadShouldSucceed() throws Exception {\n        decode().onWindowUpdateRead(ctx, STREAM_ID, 10);\n        verify(remoteFlow).incrementWindowSize(eq(stream), eq(10));\n        verify(listener).onWindowUpdateRead(eq(ctx), eq(STREAM_ID), eq(10));\n    }\n\n    @Test\n    public void rstStreamReadAfterGoAwayShouldSucceed() throws Exception {\n        when(connection.goAwaySent()).thenReturn(true);\n        decode().onRstStreamRead(ctx, STREAM_ID, PROTOCOL_ERROR.code());\n        verify(lifecycleManager).closeStream(eq(stream), eq(future));\n        verify(listener).onRstStreamRead(eq(ctx), anyInt(), anyLong());\n    }\n\n    @Test(expected = Http2Exception.class)\n    public void rstStreamReadForUnknownStreamShouldThrow() throws Exception {\n        when(connection.streamMayHaveExisted(STREAM_ID)).thenReturn(false);\n        when(connection.stream(STREAM_ID)).thenReturn(null);\n        decode().onRstStreamRead(ctx, STREAM_ID, PROTOCOL_ERROR.code());\n    }\n\n    @Test\n    public void rstStreamReadForUnknownStreamShouldBeIgnored() throws Exception {\n        when(connection.stream(STREAM_ID)).thenReturn(null);\n        decode().onRstStreamRead(ctx, STREAM_ID, PROTOCOL_ERROR.code());\n        verify(lifecycleManager, never()).closeStream(eq(stream), eq(future));\n        verify(listener, never()).onRstStreamRead(eq(ctx), anyInt(), anyLong());\n    }\n\n    @Test\n    public void rstStreamReadShouldCloseStream() throws Exception {\n        decode().onRstStreamRead(ctx, STREAM_ID, PROTOCOL_ERROR.code());\n        verify(lifecycleManager).closeStream(eq(stream), eq(future));\n        verify(listener).onRstStreamRead(eq(ctx), eq(STREAM_ID), eq(PROTOCOL_ERROR.code()));\n    }\n\n    @Test(expected = Http2Exception.class)\n    public void rstStreamOnIdleStreamShouldThrow() throws Exception {\n        when(stream.state()).thenReturn(IDLE);\n        decode().onRstStreamRead(ctx, STREAM_ID, PROTOCOL_ERROR.code());\n        verify(lifecycleManager).closeStream(eq(stream), eq(future));\n        verify(listener, never()).onRstStreamRead(any(ChannelHandlerContext.class), anyInt(), anyLong());\n    }\n\n    @Test\n    public void pingReadWithAckShouldNotifyListener() throws Exception {\n        decode().onPingAckRead(ctx, 0L);\n        verify(listener).onPingAckRead(eq(ctx), eq(0L));\n    }\n\n    @Test\n    public void pingReadShouldReplyWithAck() throws Exception {\n        decode().onPingRead(ctx, 0L);\n        verify(encoder).writePing(eq(ctx), eq(true), eq(0L), eq(promise));\n        verify(listener, never()).onPingAckRead(eq(ctx), any(long.class));\n    }\n\n    @Test\n    public void settingsReadWithAckShouldNotifyListener() throws Exception {\n        decode().onSettingsAckRead(ctx);\n        // Take into account the time this was called during setup().\n        verify(listener, times(2)).onSettingsAckRead(eq(ctx));\n    }\n\n    @Test\n    public void settingsReadShouldSetValues() throws Exception {\n        Http2Settings settings = new Http2Settings();\n        settings.pushEnabled(true);\n        settings.initialWindowSize(123);\n        settings.maxConcurrentStreams(456);\n        settings.headerTableSize(789);\n        decode().onSettingsRead(ctx, settings);\n        verify(encoder).remoteSettings(settings);\n        verify(listener).onSettingsRead(eq(ctx), eq(settings));\n    }\n\n    @Test\n    public void goAwayShouldReadShouldUpdateConnectionState() throws Exception {\n        decode().onGoAwayRead(ctx, 1, 2L, EMPTY_BUFFER);\n        verify(connection).goAwayReceived(eq(1), eq(2L), eq(EMPTY_BUFFER));\n        verify(listener).onGoAwayRead(eq(ctx), eq(1), eq(2L), eq(EMPTY_BUFFER));\n    }\n\n    private static ByteBuf dummyData() {\n        // The buffer is purposely 8 bytes so it will even work for a ping frame.\n        return wrappedBuffer(\"abcdefgh\".getBytes(UTF_8));\n    }\n\n    /**\n     * Calls the decode method on the handler and gets back the captured internal listener\n     */\n    private Http2FrameListener decode() throws Exception {\n        ArgumentCaptor<Http2FrameListener> internalListener = ArgumentCaptor.forClass(Http2FrameListener.class);\n        doNothing().when(reader).readFrame(eq(ctx), any(ByteBuf.class), internalListener.capture());\n        decoder.decodeFrame(ctx, EMPTY_BUFFER, Collections.emptyList());\n        return internalListener.getValue();\n    }\n\n    private void mockFlowControl(final int processedBytes) throws Http2Exception {\n        doAnswer(new Answer<Integer>() {\n            @Override\n            public Integer answer(InvocationOnMock invocation) throws Throwable {\n                return processedBytes;\n            }\n        }).when(listener).onDataRead(any(ChannelHandlerContext.class), anyInt(),\n                any(ByteBuf.class), anyInt(), anyBoolean());\n    }\n\n    private void mockGoAwaySent() {\n        when(connection.goAwaySent()).thenReturn(true);\n        when(remote.isValidStreamId(STREAM_ID)).thenReturn(true);\n        when(remote.lastStreamKnownByPeer()).thenReturn(0);\n    }\n\n    private void mockGoAwaySentShouldAllowFramesForStreamCreatedByLocalEndpoint() {\n        when(connection.goAwaySent()).thenReturn(true);\n        when(remote.isValidStreamId(STREAM_ID)).thenReturn(false);\n        when(remote.lastStreamKnownByPeer()).thenReturn(0);\n    }\n}\n"], "fixing_code": ["/*\n * Copyright 2012 The Netty Project\n *\n * The Netty Project licenses this file to you under the Apache License,\n * version 2.0 (the \"License\"); you may not use this file except in compliance\n * with the License. You may obtain a copy of the License at:\n *\n *   https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations\n * under the License.\n */\npackage io.netty.handler.codec.http;\n\nimport static io.netty.util.internal.ObjectUtil.checkPositive;\n\nimport io.netty.buffer.ByteBuf;\nimport io.netty.buffer.Unpooled;\nimport io.netty.channel.ChannelHandlerContext;\nimport io.netty.channel.ChannelPipeline;\nimport io.netty.handler.codec.ByteToMessageDecoder;\nimport io.netty.handler.codec.DecoderResult;\nimport io.netty.handler.codec.PrematureChannelClosureException;\nimport io.netty.handler.codec.TooLongFrameException;\nimport io.netty.util.ByteProcessor;\nimport io.netty.util.internal.AppendableCharSequence;\n\nimport java.util.List;\nimport java.util.regex.Pattern;\n\n/**\n * Decodes {@link ByteBuf}s into {@link HttpMessage}s and\n * {@link HttpContent}s.\n *\n * <h3>Parameters that prevents excessive memory consumption</h3>\n * <table border=\"1\">\n * <tr>\n * <th>Name</th><th>Default value</th><th>Meaning</th>\n * </tr>\n * <tr>\n * <td>{@code maxInitialLineLength}</td>\n * <td>{@value #DEFAULT_MAX_INITIAL_LINE_LENGTH}</td>\n * <td>The maximum length of the initial line\n *     (e.g. {@code \"GET / HTTP/1.0\"} or {@code \"HTTP/1.0 200 OK\"})\n *     If the length of the initial line exceeds this value, a\n *     {@link TooLongFrameException} will be raised.</td>\n * </tr>\n * <tr>\n * <td>{@code maxHeaderSize}</td>\n * <td>{@value #DEFAULT_MAX_HEADER_SIZE}</td>\n * <td>The maximum length of all headers.  If the sum of the length of each\n *     header exceeds this value, a {@link TooLongFrameException} will be raised.</td>\n * </tr>\n * <tr>\n * <td>{@code maxChunkSize}</td>\n * <td>{@value #DEFAULT_MAX_CHUNK_SIZE}</td>\n * <td>The maximum length of the content or each chunk.  If the content length\n *     (or the length of each chunk) exceeds this value, the content or chunk\n *     will be split into multiple {@link HttpContent}s whose length is\n *     {@code maxChunkSize} at maximum.</td>\n * </tr>\n * </table>\n *\n * <h3>Parameters that control parsing behavior</h3>\n * <table border=\"1\">\n * <tr>\n * <th>Name</th><th>Default value</th><th>Meaning</th>\n * </tr>\n * <tr>\n * <td>{@code allowDuplicateContentLengths}</td>\n * <td>{@value #DEFAULT_ALLOW_DUPLICATE_CONTENT_LENGTHS}</td>\n * <td>When set to {@code false}, will reject any messages that contain multiple Content-Length header fields.\n *     When set to {@code true}, will allow multiple Content-Length headers only if they are all the same decimal value.\n *     The duplicated field-values will be replaced with a single valid Content-Length field.\n *     See <a href=\"https://tools.ietf.org/html/rfc7230#section-3.3.2\">RFC 7230, Section 3.3.2</a>.</td>\n * </tr>\n * </table>\n *\n * <h3>Chunked Content</h3>\n *\n * If the content of an HTTP message is greater than {@code maxChunkSize} or\n * the transfer encoding of the HTTP message is 'chunked', this decoder\n * generates one {@link HttpMessage} instance and its following\n * {@link HttpContent}s per single HTTP message to avoid excessive memory\n * consumption. For example, the following HTTP message:\n * <pre>\n * GET / HTTP/1.1\n * Transfer-Encoding: chunked\n *\n * 1a\n * abcdefghijklmnopqrstuvwxyz\n * 10\n * 1234567890abcdef\n * 0\n * Content-MD5: ...\n * <i>[blank line]</i>\n * </pre>\n * triggers {@link HttpRequestDecoder} to generate 3 objects:\n * <ol>\n * <li>An {@link HttpRequest},</li>\n * <li>The first {@link HttpContent} whose content is {@code 'abcdefghijklmnopqrstuvwxyz'},</li>\n * <li>The second {@link LastHttpContent} whose content is {@code '1234567890abcdef'}, which marks\n * the end of the content.</li>\n * </ol>\n *\n * If you prefer not to handle {@link HttpContent}s by yourself for your\n * convenience, insert {@link HttpObjectAggregator} after this decoder in the\n * {@link ChannelPipeline}.  However, please note that your server might not\n * be as memory efficient as without the aggregator.\n *\n * <h3>Extensibility</h3>\n *\n * Please note that this decoder is designed to be extended to implement\n * a protocol derived from HTTP, such as\n * <a href=\"https://en.wikipedia.org/wiki/Real_Time_Streaming_Protocol\">RTSP</a> and\n * <a href=\"https://en.wikipedia.org/wiki/Internet_Content_Adaptation_Protocol\">ICAP</a>.\n * To implement the decoder of such a derived protocol, extend this class and\n * implement all abstract methods properly.\n */\npublic abstract class HttpObjectDecoder extends ByteToMessageDecoder {\n    public static final int DEFAULT_MAX_INITIAL_LINE_LENGTH = 4096;\n    public static final int DEFAULT_MAX_HEADER_SIZE = 8192;\n    public static final boolean DEFAULT_CHUNKED_SUPPORTED = true;\n    public static final int DEFAULT_MAX_CHUNK_SIZE = 8192;\n    public static final boolean DEFAULT_VALIDATE_HEADERS = true;\n    public static final int DEFAULT_INITIAL_BUFFER_SIZE = 128;\n    public static final boolean DEFAULT_ALLOW_DUPLICATE_CONTENT_LENGTHS = false;\n\n    private static final String EMPTY_VALUE = \"\";\n    private static final Pattern COMMA_PATTERN = Pattern.compile(\",\");\n\n    private final int maxChunkSize;\n    private final boolean chunkedSupported;\n    protected final boolean validateHeaders;\n    private final boolean allowDuplicateContentLengths;\n    private final HeaderParser headerParser;\n    private final LineParser lineParser;\n\n    private HttpMessage message;\n    private long chunkSize;\n    private long contentLength = Long.MIN_VALUE;\n    private volatile boolean resetRequested;\n\n    // These will be updated by splitHeader(...)\n    private CharSequence name;\n    private CharSequence value;\n\n    private LastHttpContent trailer;\n\n    /**\n     * The internal state of {@link HttpObjectDecoder}.\n     * <em>Internal use only</em>.\n     */\n    private enum State {\n        SKIP_CONTROL_CHARS,\n        READ_INITIAL,\n        READ_HEADER,\n        READ_VARIABLE_LENGTH_CONTENT,\n        READ_FIXED_LENGTH_CONTENT,\n        READ_CHUNK_SIZE,\n        READ_CHUNKED_CONTENT,\n        READ_CHUNK_DELIMITER,\n        READ_CHUNK_FOOTER,\n        BAD_MESSAGE,\n        UPGRADED\n    }\n\n    private State currentState = State.SKIP_CONTROL_CHARS;\n\n    /**\n     * Creates a new instance with the default\n     * {@code maxInitialLineLength (4096}}, {@code maxHeaderSize (8192)}, and\n     * {@code maxChunkSize (8192)}.\n     */\n    protected HttpObjectDecoder() {\n        this(DEFAULT_MAX_INITIAL_LINE_LENGTH, DEFAULT_MAX_HEADER_SIZE, DEFAULT_MAX_CHUNK_SIZE,\n             DEFAULT_CHUNKED_SUPPORTED);\n    }\n\n    /**\n     * Creates a new instance with the specified parameters.\n     */\n    protected HttpObjectDecoder(\n            int maxInitialLineLength, int maxHeaderSize, int maxChunkSize, boolean chunkedSupported) {\n        this(maxInitialLineLength, maxHeaderSize, maxChunkSize, chunkedSupported, DEFAULT_VALIDATE_HEADERS);\n    }\n\n    /**\n     * Creates a new instance with the specified parameters.\n     */\n    protected HttpObjectDecoder(\n            int maxInitialLineLength, int maxHeaderSize, int maxChunkSize,\n            boolean chunkedSupported, boolean validateHeaders) {\n        this(maxInitialLineLength, maxHeaderSize, maxChunkSize, chunkedSupported, validateHeaders,\n             DEFAULT_INITIAL_BUFFER_SIZE);\n    }\n\n    /**\n     * Creates a new instance with the specified parameters.\n     */\n    protected HttpObjectDecoder(\n            int maxInitialLineLength, int maxHeaderSize, int maxChunkSize,\n            boolean chunkedSupported, boolean validateHeaders, int initialBufferSize) {\n        this(maxInitialLineLength, maxHeaderSize, maxChunkSize, chunkedSupported, validateHeaders, initialBufferSize,\n             DEFAULT_ALLOW_DUPLICATE_CONTENT_LENGTHS);\n    }\n\n    protected HttpObjectDecoder(\n            int maxInitialLineLength, int maxHeaderSize, int maxChunkSize,\n            boolean chunkedSupported, boolean validateHeaders, int initialBufferSize,\n            boolean allowDuplicateContentLengths) {\n        checkPositive(maxInitialLineLength, \"maxInitialLineLength\");\n        checkPositive(maxHeaderSize, \"maxHeaderSize\");\n        checkPositive(maxChunkSize, \"maxChunkSize\");\n\n        AppendableCharSequence seq = new AppendableCharSequence(initialBufferSize);\n        lineParser = new LineParser(seq, maxInitialLineLength);\n        headerParser = new HeaderParser(seq, maxHeaderSize);\n        this.maxChunkSize = maxChunkSize;\n        this.chunkedSupported = chunkedSupported;\n        this.validateHeaders = validateHeaders;\n        this.allowDuplicateContentLengths = allowDuplicateContentLengths;\n    }\n\n    @Override\n    protected void decode(ChannelHandlerContext ctx, ByteBuf buffer, List<Object> out) throws Exception {\n        if (resetRequested) {\n            resetNow();\n        }\n\n        switch (currentState) {\n        case SKIP_CONTROL_CHARS:\n            // Fall-through\n        case READ_INITIAL: try {\n            AppendableCharSequence line = lineParser.parse(buffer);\n            if (line == null) {\n                return;\n            }\n            String[] initialLine = splitInitialLine(line);\n            if (initialLine.length < 3) {\n                // Invalid initial line - ignore.\n                currentState = State.SKIP_CONTROL_CHARS;\n                return;\n            }\n\n            message = createMessage(initialLine);\n            currentState = State.READ_HEADER;\n            // fall-through\n        } catch (Exception e) {\n            out.add(invalidMessage(buffer, e));\n            return;\n        }\n        case READ_HEADER: try {\n            State nextState = readHeaders(buffer);\n            if (nextState == null) {\n                return;\n            }\n            currentState = nextState;\n            switch (nextState) {\n            case SKIP_CONTROL_CHARS:\n                // fast-path\n                // No content is expected.\n                out.add(message);\n                out.add(LastHttpContent.EMPTY_LAST_CONTENT);\n                resetNow();\n                return;\n            case READ_CHUNK_SIZE:\n                if (!chunkedSupported) {\n                    throw new IllegalArgumentException(\"Chunked messages not supported\");\n                }\n                // Chunked encoding - generate HttpMessage first.  HttpChunks will follow.\n                out.add(message);\n                return;\n            default:\n                /**\n                 * <a href=\"https://tools.ietf.org/html/rfc7230#section-3.3.3\">RFC 7230, 3.3.3</a> states that if a\n                 * request does not have either a transfer-encoding or a content-length header then the message body\n                 * length is 0. However for a response the body length is the number of octets received prior to the\n                 * server closing the connection. So we treat this as variable length chunked encoding.\n                 */\n                long contentLength = contentLength();\n                if (contentLength == 0 || contentLength == -1 && isDecodingRequest()) {\n                    out.add(message);\n                    out.add(LastHttpContent.EMPTY_LAST_CONTENT);\n                    resetNow();\n                    return;\n                }\n\n                assert nextState == State.READ_FIXED_LENGTH_CONTENT ||\n                        nextState == State.READ_VARIABLE_LENGTH_CONTENT;\n\n                out.add(message);\n\n                if (nextState == State.READ_FIXED_LENGTH_CONTENT) {\n                    // chunkSize will be decreased as the READ_FIXED_LENGTH_CONTENT state reads data chunk by chunk.\n                    chunkSize = contentLength;\n                }\n\n                // We return here, this forces decode to be called again where we will decode the content\n                return;\n            }\n        } catch (Exception e) {\n            out.add(invalidMessage(buffer, e));\n            return;\n        }\n        case READ_VARIABLE_LENGTH_CONTENT: {\n            // Keep reading data as a chunk until the end of connection is reached.\n            int toRead = Math.min(buffer.readableBytes(), maxChunkSize);\n            if (toRead > 0) {\n                ByteBuf content = buffer.readRetainedSlice(toRead);\n                out.add(new DefaultHttpContent(content));\n            }\n            return;\n        }\n        case READ_FIXED_LENGTH_CONTENT: {\n            int readLimit = buffer.readableBytes();\n\n            // Check if the buffer is readable first as we use the readable byte count\n            // to create the HttpChunk. This is needed as otherwise we may end up with\n            // create an HttpChunk instance that contains an empty buffer and so is\n            // handled like it is the last HttpChunk.\n            //\n            // See https://github.com/netty/netty/issues/433\n            if (readLimit == 0) {\n                return;\n            }\n\n            int toRead = Math.min(readLimit, maxChunkSize);\n            if (toRead > chunkSize) {\n                toRead = (int) chunkSize;\n            }\n            ByteBuf content = buffer.readRetainedSlice(toRead);\n            chunkSize -= toRead;\n\n            if (chunkSize == 0) {\n                // Read all content.\n                out.add(new DefaultLastHttpContent(content, validateHeaders));\n                resetNow();\n            } else {\n                out.add(new DefaultHttpContent(content));\n            }\n            return;\n        }\n        /**\n         * everything else after this point takes care of reading chunked content. basically, read chunk size,\n         * read chunk, read and ignore the CRLF and repeat until 0\n         */\n        case READ_CHUNK_SIZE: try {\n            AppendableCharSequence line = lineParser.parse(buffer);\n            if (line == null) {\n                return;\n            }\n            int chunkSize = getChunkSize(line.toString());\n            this.chunkSize = chunkSize;\n            if (chunkSize == 0) {\n                currentState = State.READ_CHUNK_FOOTER;\n                return;\n            }\n            currentState = State.READ_CHUNKED_CONTENT;\n            // fall-through\n        } catch (Exception e) {\n            out.add(invalidChunk(buffer, e));\n            return;\n        }\n        case READ_CHUNKED_CONTENT: {\n            assert chunkSize <= Integer.MAX_VALUE;\n            int toRead = Math.min((int) chunkSize, maxChunkSize);\n            toRead = Math.min(toRead, buffer.readableBytes());\n            if (toRead == 0) {\n                return;\n            }\n            HttpContent chunk = new DefaultHttpContent(buffer.readRetainedSlice(toRead));\n            chunkSize -= toRead;\n\n            out.add(chunk);\n\n            if (chunkSize != 0) {\n                return;\n            }\n            currentState = State.READ_CHUNK_DELIMITER;\n            // fall-through\n        }\n        case READ_CHUNK_DELIMITER: {\n            final int wIdx = buffer.writerIndex();\n            int rIdx = buffer.readerIndex();\n            while (wIdx > rIdx) {\n                byte next = buffer.getByte(rIdx++);\n                if (next == HttpConstants.LF) {\n                    currentState = State.READ_CHUNK_SIZE;\n                    break;\n                }\n            }\n            buffer.readerIndex(rIdx);\n            return;\n        }\n        case READ_CHUNK_FOOTER: try {\n            LastHttpContent trailer = readTrailingHeaders(buffer);\n            if (trailer == null) {\n                return;\n            }\n            out.add(trailer);\n            resetNow();\n            return;\n        } catch (Exception e) {\n            out.add(invalidChunk(buffer, e));\n            return;\n        }\n        case BAD_MESSAGE: {\n            // Keep discarding until disconnection.\n            buffer.skipBytes(buffer.readableBytes());\n            break;\n        }\n        case UPGRADED: {\n            int readableBytes = buffer.readableBytes();\n            if (readableBytes > 0) {\n                // Keep on consuming as otherwise we may trigger an DecoderException,\n                // other handler will replace this codec with the upgraded protocol codec to\n                // take the traffic over at some point then.\n                // See https://github.com/netty/netty/issues/2173\n                out.add(buffer.readBytes(readableBytes));\n            }\n            break;\n        }\n        }\n    }\n\n    @Override\n    protected void decodeLast(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) throws Exception {\n        super.decodeLast(ctx, in, out);\n\n        if (resetRequested) {\n            // If a reset was requested by decodeLast() we need to do it now otherwise we may produce a\n            // LastHttpContent while there was already one.\n            resetNow();\n        }\n        // Handle the last unfinished message.\n        if (message != null) {\n            boolean chunked = HttpUtil.isTransferEncodingChunked(message);\n            if (currentState == State.READ_VARIABLE_LENGTH_CONTENT && !in.isReadable() && !chunked) {\n                // End of connection.\n                out.add(LastHttpContent.EMPTY_LAST_CONTENT);\n                resetNow();\n                return;\n            }\n\n            if (currentState == State.READ_HEADER) {\n                // If we are still in the state of reading headers we need to create a new invalid message that\n                // signals that the connection was closed before we received the headers.\n                out.add(invalidMessage(Unpooled.EMPTY_BUFFER,\n                        new PrematureChannelClosureException(\"Connection closed before received headers\")));\n                resetNow();\n                return;\n            }\n\n            // Check if the closure of the connection signifies the end of the content.\n            boolean prematureClosure;\n            if (isDecodingRequest() || chunked) {\n                // The last request did not wait for a response.\n                prematureClosure = true;\n            } else {\n                // Compare the length of the received content and the 'Content-Length' header.\n                // If the 'Content-Length' header is absent, the length of the content is determined by the end of the\n                // connection, so it is perfectly fine.\n                prematureClosure = contentLength() > 0;\n            }\n\n            if (!prematureClosure) {\n                out.add(LastHttpContent.EMPTY_LAST_CONTENT);\n            }\n            resetNow();\n        }\n    }\n\n    @Override\n    public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception {\n        if (evt instanceof HttpExpectationFailedEvent) {\n            switch (currentState) {\n            case READ_FIXED_LENGTH_CONTENT:\n            case READ_VARIABLE_LENGTH_CONTENT:\n            case READ_CHUNK_SIZE:\n                reset();\n                break;\n            default:\n                break;\n            }\n        }\n        super.userEventTriggered(ctx, evt);\n    }\n\n    protected boolean isContentAlwaysEmpty(HttpMessage msg) {\n        if (msg instanceof HttpResponse) {\n            HttpResponse res = (HttpResponse) msg;\n            int code = res.status().code();\n\n            // Correctly handle return codes of 1xx.\n            //\n            // See:\n            //     - https://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html Section 4.4\n            //     - https://github.com/netty/netty/issues/222\n            if (code >= 100 && code < 200) {\n                // One exception: Hixie 76 websocket handshake response\n                return !(code == 101 && !res.headers().contains(HttpHeaderNames.SEC_WEBSOCKET_ACCEPT)\n                         && res.headers().contains(HttpHeaderNames.UPGRADE, HttpHeaderValues.WEBSOCKET, true));\n            }\n\n            switch (code) {\n            case 204: case 304:\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Returns true if the server switched to a different protocol than HTTP/1.0 or HTTP/1.1, e.g. HTTP/2 or Websocket.\n     * Returns false if the upgrade happened in a different layer, e.g. upgrade from HTTP/1.1 to HTTP/1.1 over TLS.\n     */\n    protected boolean isSwitchingToNonHttp1Protocol(HttpResponse msg) {\n        if (msg.status().code() != HttpResponseStatus.SWITCHING_PROTOCOLS.code()) {\n            return false;\n        }\n        String newProtocol = msg.headers().get(HttpHeaderNames.UPGRADE);\n        return newProtocol == null ||\n                !newProtocol.contains(HttpVersion.HTTP_1_0.text()) &&\n                !newProtocol.contains(HttpVersion.HTTP_1_1.text());\n    }\n\n    /**\n     * Resets the state of the decoder so that it is ready to decode a new message.\n     * This method is useful for handling a rejected request with {@code Expect: 100-continue} header.\n     */\n    public void reset() {\n        resetRequested = true;\n    }\n\n    private void resetNow() {\n        HttpMessage message = this.message;\n        this.message = null;\n        name = null;\n        value = null;\n        contentLength = Long.MIN_VALUE;\n        lineParser.reset();\n        headerParser.reset();\n        trailer = null;\n        if (!isDecodingRequest()) {\n            HttpResponse res = (HttpResponse) message;\n            if (res != null && isSwitchingToNonHttp1Protocol(res)) {\n                currentState = State.UPGRADED;\n                return;\n            }\n        }\n\n        resetRequested = false;\n        currentState = State.SKIP_CONTROL_CHARS;\n    }\n\n    private HttpMessage invalidMessage(ByteBuf in, Exception cause) {\n        currentState = State.BAD_MESSAGE;\n\n        // Advance the readerIndex so that ByteToMessageDecoder does not complain\n        // when we produced an invalid message without consuming anything.\n        in.skipBytes(in.readableBytes());\n\n        if (message == null) {\n            message = createInvalidMessage();\n        }\n        message.setDecoderResult(DecoderResult.failure(cause));\n\n        HttpMessage ret = message;\n        message = null;\n        return ret;\n    }\n\n    private HttpContent invalidChunk(ByteBuf in, Exception cause) {\n        currentState = State.BAD_MESSAGE;\n\n        // Advance the readerIndex so that ByteToMessageDecoder does not complain\n        // when we produced an invalid message without consuming anything.\n        in.skipBytes(in.readableBytes());\n\n        HttpContent chunk = new DefaultLastHttpContent(Unpooled.EMPTY_BUFFER);\n        chunk.setDecoderResult(DecoderResult.failure(cause));\n        message = null;\n        trailer = null;\n        return chunk;\n    }\n\n    private State readHeaders(ByteBuf buffer) {\n        final HttpMessage message = this.message;\n        final HttpHeaders headers = message.headers();\n\n        AppendableCharSequence line = headerParser.parse(buffer);\n        if (line == null) {\n            return null;\n        }\n        if (line.length() > 0) {\n            do {\n                char firstChar = line.charAtUnsafe(0);\n                if (name != null && (firstChar == ' ' || firstChar == '\\t')) {\n                    //please do not make one line from below code\n                    //as it breaks +XX:OptimizeStringConcat optimization\n                    String trimmedLine = line.toString().trim();\n                    String valueStr = String.valueOf(value);\n                    value = valueStr + ' ' + trimmedLine;\n                } else {\n                    if (name != null) {\n                        headers.add(name, value);\n                    }\n                    splitHeader(line);\n                }\n\n                line = headerParser.parse(buffer);\n                if (line == null) {\n                    return null;\n                }\n            } while (line.length() > 0);\n        }\n\n        // Add the last header.\n        if (name != null) {\n            headers.add(name, value);\n        }\n\n        // reset name and value fields\n        name = null;\n        value = null;\n\n        List<String> contentLengthFields = headers.getAll(HttpHeaderNames.CONTENT_LENGTH);\n        if (!contentLengthFields.isEmpty()) {\n            HttpVersion version = message.protocolVersion();\n            boolean isHttp10OrEarlier = version.majorVersion() < 1 || (version.majorVersion() == 1\n                    && version.minorVersion() == 0);\n            // Guard against multiple Content-Length headers as stated in\n            // https://tools.ietf.org/html/rfc7230#section-3.3.2:\n            contentLength = HttpUtil.normalizeAndGetContentLength(contentLengthFields,\n                    isHttp10OrEarlier, allowDuplicateContentLengths);\n            if (contentLength != -1) {\n                headers.set(HttpHeaderNames.CONTENT_LENGTH, contentLength);\n            }\n        }\n\n        if (isContentAlwaysEmpty(message)) {\n            HttpUtil.setTransferEncodingChunked(message, false);\n            return State.SKIP_CONTROL_CHARS;\n        } else if (HttpUtil.isTransferEncodingChunked(message)) {\n            if (!contentLengthFields.isEmpty() && message.protocolVersion() == HttpVersion.HTTP_1_1) {\n                handleTransferEncodingChunkedWithContentLength(message);\n            }\n            return State.READ_CHUNK_SIZE;\n        } else if (contentLength() >= 0) {\n            return State.READ_FIXED_LENGTH_CONTENT;\n        } else {\n            return State.READ_VARIABLE_LENGTH_CONTENT;\n        }\n    }\n\n    /**\n     * Invoked when a message with both a \"Transfer-Encoding: chunked\" and a \"Content-Length\" header field is detected.\n     * The default behavior is to <i>remove</i> the Content-Length field, but this method could be overridden\n     * to change the behavior (to, e.g., throw an exception and produce an invalid message).\n     * <p>\n     * See: https://tools.ietf.org/html/rfc7230#section-3.3.3\n     * <pre>\n     *     If a message is received with both a Transfer-Encoding and a\n     *     Content-Length header field, the Transfer-Encoding overrides the\n     *     Content-Length.  Such a message might indicate an attempt to\n     *     perform request smuggling (Section 9.5) or response splitting\n     *     (Section 9.4) and ought to be handled as an error.  A sender MUST\n     *     remove the received Content-Length field prior to forwarding such\n     *     a message downstream.\n     * </pre>\n     * Also see:\n     * https://github.com/apache/tomcat/blob/b693d7c1981fa7f51e58bc8c8e72e3fe80b7b773/\n     * java/org/apache/coyote/http11/Http11Processor.java#L747-L755\n     * https://github.com/nginx/nginx/blob/0ad4393e30c119d250415cb769e3d8bc8dce5186/\n     * src/http/ngx_http_request.c#L1946-L1953\n     */\n    protected void handleTransferEncodingChunkedWithContentLength(HttpMessage message) {\n        message.headers().remove(HttpHeaderNames.CONTENT_LENGTH);\n        contentLength = Long.MIN_VALUE;\n    }\n\n    private long contentLength() {\n        if (contentLength == Long.MIN_VALUE) {\n            contentLength = HttpUtil.getContentLength(message, -1L);\n        }\n        return contentLength;\n    }\n\n    private LastHttpContent readTrailingHeaders(ByteBuf buffer) {\n        AppendableCharSequence line = headerParser.parse(buffer);\n        if (line == null) {\n            return null;\n        }\n        LastHttpContent trailer = this.trailer;\n        if (line.length() == 0 && trailer == null) {\n            // We have received the empty line which signals the trailer is complete and did not parse any trailers\n            // before. Just return an empty last content to reduce allocations.\n            return LastHttpContent.EMPTY_LAST_CONTENT;\n        }\n\n        CharSequence lastHeader = null;\n        if (trailer == null) {\n            trailer = this.trailer = new DefaultLastHttpContent(Unpooled.EMPTY_BUFFER, validateHeaders);\n        }\n        while (line.length() > 0) {\n            char firstChar = line.charAtUnsafe(0);\n            if (lastHeader != null && (firstChar == ' ' || firstChar == '\\t')) {\n                List<String> current = trailer.trailingHeaders().getAll(lastHeader);\n                if (!current.isEmpty()) {\n                    int lastPos = current.size() - 1;\n                    //please do not make one line from below code\n                    //as it breaks +XX:OptimizeStringConcat optimization\n                    String lineTrimmed = line.toString().trim();\n                    String currentLastPos = current.get(lastPos);\n                    current.set(lastPos, currentLastPos + lineTrimmed);\n                }\n            } else {\n                splitHeader(line);\n                CharSequence headerName = name;\n                if (!HttpHeaderNames.CONTENT_LENGTH.contentEqualsIgnoreCase(headerName) &&\n                        !HttpHeaderNames.TRANSFER_ENCODING.contentEqualsIgnoreCase(headerName) &&\n                        !HttpHeaderNames.TRAILER.contentEqualsIgnoreCase(headerName)) {\n                    trailer.trailingHeaders().add(headerName, value);\n                }\n                lastHeader = name;\n                // reset name and value fields\n                name = null;\n                value = null;\n            }\n            line = headerParser.parse(buffer);\n            if (line == null) {\n                return null;\n            }\n        }\n\n        this.trailer = null;\n        return trailer;\n    }\n\n    protected abstract boolean isDecodingRequest();\n    protected abstract HttpMessage createMessage(String[] initialLine) throws Exception;\n    protected abstract HttpMessage createInvalidMessage();\n\n    private static int getChunkSize(String hex) {\n        hex = hex.trim();\n        for (int i = 0; i < hex.length(); i ++) {\n            char c = hex.charAt(i);\n            if (c == ';' || Character.isWhitespace(c) || Character.isISOControl(c)) {\n                hex = hex.substring(0, i);\n                break;\n            }\n        }\n\n        return Integer.parseInt(hex, 16);\n    }\n\n    private static String[] splitInitialLine(AppendableCharSequence sb) {\n        int aStart;\n        int aEnd;\n        int bStart;\n        int bEnd;\n        int cStart;\n        int cEnd;\n\n        aStart = findNonSPLenient(sb, 0);\n        aEnd = findSPLenient(sb, aStart);\n\n        bStart = findNonSPLenient(sb, aEnd);\n        bEnd = findSPLenient(sb, bStart);\n\n        cStart = findNonSPLenient(sb, bEnd);\n        cEnd = findEndOfString(sb);\n\n        return new String[] {\n                sb.subStringUnsafe(aStart, aEnd),\n                sb.subStringUnsafe(bStart, bEnd),\n                cStart < cEnd? sb.subStringUnsafe(cStart, cEnd) : \"\" };\n    }\n\n    private void splitHeader(AppendableCharSequence sb) {\n        final int length = sb.length();\n        int nameStart;\n        int nameEnd;\n        int colonEnd;\n        int valueStart;\n        int valueEnd;\n\n        nameStart = findNonWhitespace(sb, 0, false);\n        for (nameEnd = nameStart; nameEnd < length; nameEnd ++) {\n            char ch = sb.charAtUnsafe(nameEnd);\n            // https://tools.ietf.org/html/rfc7230#section-3.2.4\n            //\n            // No whitespace is allowed between the header field-name and colon. In\n            // the past, differences in the handling of such whitespace have led to\n            // security vulnerabilities in request routing and response handling. A\n            // server MUST reject any received request message that contains\n            // whitespace between a header field-name and colon with a response code\n            // of 400 (Bad Request). A proxy MUST remove any such whitespace from a\n            // response message before forwarding the message downstream.\n            if (ch == ':' ||\n                    // In case of decoding a request we will just continue processing and header validation\n                    // is done in the DefaultHttpHeaders implementation.\n                    //\n                    // In the case of decoding a response we will \"skip\" the whitespace.\n                    (!isDecodingRequest() && isOWS(ch))) {\n                break;\n            }\n        }\n\n        if (nameEnd == length) {\n            // There was no colon present at all.\n            throw new IllegalArgumentException(\"No colon found\");\n        }\n\n        for (colonEnd = nameEnd; colonEnd < length; colonEnd ++) {\n            if (sb.charAtUnsafe(colonEnd) == ':') {\n                colonEnd ++;\n                break;\n            }\n        }\n\n        name = sb.subStringUnsafe(nameStart, nameEnd);\n        valueStart = findNonWhitespace(sb, colonEnd, true);\n        if (valueStart == length) {\n            value = EMPTY_VALUE;\n        } else {\n            valueEnd = findEndOfString(sb);\n            value = sb.subStringUnsafe(valueStart, valueEnd);\n        }\n    }\n\n    private static int findNonSPLenient(AppendableCharSequence sb, int offset) {\n        for (int result = offset; result < sb.length(); ++result) {\n            char c = sb.charAtUnsafe(result);\n            // See https://tools.ietf.org/html/rfc7230#section-3.5\n            if (isSPLenient(c)) {\n                continue;\n            }\n            if (Character.isWhitespace(c)) {\n                // Any other whitespace delimiter is invalid\n                throw new IllegalArgumentException(\"Invalid separator\");\n            }\n            return result;\n        }\n        return sb.length();\n    }\n\n    private static int findSPLenient(AppendableCharSequence sb, int offset) {\n        for (int result = offset; result < sb.length(); ++result) {\n            if (isSPLenient(sb.charAtUnsafe(result))) {\n                return result;\n            }\n        }\n        return sb.length();\n    }\n\n    private static boolean isSPLenient(char c) {\n        // See https://tools.ietf.org/html/rfc7230#section-3.5\n        return c == ' ' || c == (char) 0x09 || c == (char) 0x0B || c == (char) 0x0C || c == (char) 0x0D;\n    }\n\n    private static int findNonWhitespace(AppendableCharSequence sb, int offset, boolean validateOWS) {\n        for (int result = offset; result < sb.length(); ++result) {\n            char c = sb.charAtUnsafe(result);\n            if (!Character.isWhitespace(c)) {\n                return result;\n            } else if (validateOWS && !isOWS(c)) {\n                // Only OWS is supported for whitespace\n                throw new IllegalArgumentException(\"Invalid separator, only a single space or horizontal tab allowed,\" +\n                        \" but received a '\" + c + \"' (0x\" + Integer.toHexString(c) + \")\");\n            }\n        }\n        return sb.length();\n    }\n\n    private static int findEndOfString(AppendableCharSequence sb) {\n        for (int result = sb.length() - 1; result > 0; --result) {\n            if (!Character.isWhitespace(sb.charAtUnsafe(result))) {\n                return result + 1;\n            }\n        }\n        return 0;\n    }\n\n    private static boolean isOWS(char ch) {\n        return ch == ' ' || ch == (char) 0x09;\n    }\n\n    private static class HeaderParser implements ByteProcessor {\n        private final AppendableCharSequence seq;\n        private final int maxLength;\n        private int size;\n\n        HeaderParser(AppendableCharSequence seq, int maxLength) {\n            this.seq = seq;\n            this.maxLength = maxLength;\n        }\n\n        public AppendableCharSequence parse(ByteBuf buffer) {\n            final int oldSize = size;\n            seq.reset();\n            int i = buffer.forEachByte(this);\n            if (i == -1) {\n                size = oldSize;\n                return null;\n            }\n            buffer.readerIndex(i + 1);\n            return seq;\n        }\n\n        public void reset() {\n            size = 0;\n        }\n\n        @Override\n        public boolean process(byte value) throws Exception {\n            char nextByte = (char) (value & 0xFF);\n            if (nextByte == HttpConstants.LF) {\n                int len = seq.length();\n                // Drop CR if we had a CRLF pair\n                if (len >= 1 && seq.charAtUnsafe(len - 1) == HttpConstants.CR) {\n                    -- size;\n                    seq.setLength(len - 1);\n                }\n                return false;\n            }\n\n            increaseCount();\n\n            seq.append(nextByte);\n            return true;\n        }\n\n        protected final void increaseCount() {\n            if (++ size > maxLength) {\n                // TODO: Respond with Bad Request and discard the traffic\n                //    or close the connection.\n                //       No need to notify the upstream handlers - just log.\n                //       If decoding a response, just throw an exception.\n                throw newException(maxLength);\n            }\n        }\n\n        protected TooLongFrameException newException(int maxLength) {\n            return new TooLongFrameException(\"HTTP header is larger than \" + maxLength + \" bytes.\");\n        }\n    }\n\n    private final class LineParser extends HeaderParser {\n\n        LineParser(AppendableCharSequence seq, int maxLength) {\n            super(seq, maxLength);\n        }\n\n        @Override\n        public AppendableCharSequence parse(ByteBuf buffer) {\n            // Suppress a warning because HeaderParser.reset() is supposed to be called\n            reset();    // lgtm[java/subtle-inherited-call]\n            return super.parse(buffer);\n        }\n\n        @Override\n        public boolean process(byte value) throws Exception {\n            if (currentState == State.SKIP_CONTROL_CHARS) {\n                char c = (char) (value & 0xFF);\n                if (Character.isISOControl(c) || Character.isWhitespace(c)) {\n                    increaseCount();\n                    return true;\n                }\n                currentState = State.READ_INITIAL;\n            }\n            return super.process(value);\n        }\n\n        @Override\n        protected TooLongFrameException newException(int maxLength) {\n            return new TooLongFrameException(\"An HTTP line is larger than \" + maxLength + \" bytes.\");\n        }\n    }\n}\n", "/*\n * Copyright 2015 The Netty Project\n *\n * The Netty Project licenses this file to you under the Apache License,\n * version 2.0 (the \"License\"); you may not use this file except in compliance\n * with the License. You may obtain a copy of the License at:\n *\n *   https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations\n * under the License.\n */\npackage io.netty.handler.codec.http;\n\nimport java.net.InetSocketAddress;\nimport java.net.URI;\nimport java.nio.charset.Charset;\nimport java.nio.charset.IllegalCharsetNameException;\nimport java.nio.charset.UnsupportedCharsetException;\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\n\nimport io.netty.handler.codec.Headers;\nimport io.netty.util.AsciiString;\nimport io.netty.util.CharsetUtil;\nimport io.netty.util.NetUtil;\nimport io.netty.util.internal.ObjectUtil;\nimport io.netty.util.internal.UnstableApi;\n\nimport static io.netty.util.internal.StringUtil.COMMA;\n\n/**\n * Utility methods useful in the HTTP context.\n */\npublic final class HttpUtil {\n\n    private static final AsciiString CHARSET_EQUALS = AsciiString.of(HttpHeaderValues.CHARSET + \"=\");\n    private static final AsciiString SEMICOLON = AsciiString.cached(\";\");\n    private static final String COMMA_STRING = String.valueOf(COMMA);\n\n    private HttpUtil() { }\n\n    /**\n     * Determine if a uri is in origin-form according to\n     * <a href=\"https://tools.ietf.org/html/rfc7230#section-5.3\">rfc7230, 5.3</a>.\n     */\n    public static boolean isOriginForm(URI uri) {\n        return uri.getScheme() == null && uri.getSchemeSpecificPart() == null &&\n               uri.getHost() == null && uri.getAuthority() == null;\n    }\n\n    /**\n     * Determine if a uri is in asterisk-form according to\n     * <a href=\"https://tools.ietf.org/html/rfc7230#section-5.3\">rfc7230, 5.3</a>.\n     */\n    public static boolean isAsteriskForm(URI uri) {\n        return \"*\".equals(uri.getPath()) &&\n                uri.getScheme() == null && uri.getSchemeSpecificPart() == null &&\n                uri.getHost() == null && uri.getAuthority() == null && uri.getQuery() == null &&\n                uri.getFragment() == null;\n    }\n\n    /**\n     * Returns {@code true} if and only if the connection can remain open and\n     * thus 'kept alive'.  This methods respects the value of the.\n     *\n     * {@code \"Connection\"} header first and then the return value of\n     * {@link HttpVersion#isKeepAliveDefault()}.\n     */\n    public static boolean isKeepAlive(HttpMessage message) {\n        return !message.headers().containsValue(HttpHeaderNames.CONNECTION, HttpHeaderValues.CLOSE, true) &&\n               (message.protocolVersion().isKeepAliveDefault() ||\n                message.headers().containsValue(HttpHeaderNames.CONNECTION, HttpHeaderValues.KEEP_ALIVE, true));\n    }\n\n    /**\n     * Sets the value of the {@code \"Connection\"} header depending on the\n     * protocol version of the specified message. This getMethod sets or removes\n     * the {@code \"Connection\"} header depending on what the default keep alive\n     * mode of the message's protocol version is, as specified by\n     * {@link HttpVersion#isKeepAliveDefault()}.\n     * <ul>\n     * <li>If the connection is kept alive by default:\n     *     <ul>\n     *     <li>set to {@code \"close\"} if {@code keepAlive} is {@code false}.</li>\n     *     <li>remove otherwise.</li>\n     *     </ul></li>\n     * <li>If the connection is closed by default:\n     *     <ul>\n     *     <li>set to {@code \"keep-alive\"} if {@code keepAlive} is {@code true}.</li>\n     *     <li>remove otherwise.</li>\n     *     </ul></li>\n     * </ul>\n     * @see #setKeepAlive(HttpHeaders, HttpVersion, boolean)\n     */\n    public static void setKeepAlive(HttpMessage message, boolean keepAlive) {\n        setKeepAlive(message.headers(), message.protocolVersion(), keepAlive);\n    }\n\n    /**\n     * Sets the value of the {@code \"Connection\"} header depending on the\n     * protocol version of the specified message. This getMethod sets or removes\n     * the {@code \"Connection\"} header depending on what the default keep alive\n     * mode of the message's protocol version is, as specified by\n     * {@link HttpVersion#isKeepAliveDefault()}.\n     * <ul>\n     * <li>If the connection is kept alive by default:\n     *     <ul>\n     *     <li>set to {@code \"close\"} if {@code keepAlive} is {@code false}.</li>\n     *     <li>remove otherwise.</li>\n     *     </ul></li>\n     * <li>If the connection is closed by default:\n     *     <ul>\n     *     <li>set to {@code \"keep-alive\"} if {@code keepAlive} is {@code true}.</li>\n     *     <li>remove otherwise.</li>\n     *     </ul></li>\n     * </ul>\n     */\n    public static void setKeepAlive(HttpHeaders h, HttpVersion httpVersion, boolean keepAlive) {\n        if (httpVersion.isKeepAliveDefault()) {\n            if (keepAlive) {\n                h.remove(HttpHeaderNames.CONNECTION);\n            } else {\n                h.set(HttpHeaderNames.CONNECTION, HttpHeaderValues.CLOSE);\n            }\n        } else {\n            if (keepAlive) {\n                h.set(HttpHeaderNames.CONNECTION, HttpHeaderValues.KEEP_ALIVE);\n            } else {\n                h.remove(HttpHeaderNames.CONNECTION);\n            }\n        }\n    }\n\n    /**\n     * Returns the length of the content. Please note that this value is\n     * not retrieved from {@link HttpContent#content()} but from the\n     * {@code \"Content-Length\"} header, and thus they are independent from each\n     * other.\n     *\n     * @return the content length\n     *\n     * @throws NumberFormatException\n     *         if the message does not have the {@code \"Content-Length\"} header\n     *         or its value is not a number\n     */\n    public static long getContentLength(HttpMessage message) {\n        String value = message.headers().get(HttpHeaderNames.CONTENT_LENGTH);\n        if (value != null) {\n            return Long.parseLong(value);\n        }\n\n        // We know the content length if it's a Web Socket message even if\n        // Content-Length header is missing.\n        long webSocketContentLength = getWebSocketContentLength(message);\n        if (webSocketContentLength >= 0) {\n            return webSocketContentLength;\n        }\n\n        // Otherwise we don't.\n        throw new NumberFormatException(\"header not found: \" + HttpHeaderNames.CONTENT_LENGTH);\n    }\n\n    /**\n     * Returns the length of the content or the specified default value if the message does not have the {@code\n     * \"Content-Length\" header}. Please note that this value is not retrieved from {@link HttpContent#content()} but\n     * from the {@code \"Content-Length\"} header, and thus they are independent from each other.\n     *\n     * @param message      the message\n     * @param defaultValue the default value\n     * @return the content length or the specified default value\n     * @throws NumberFormatException if the {@code \"Content-Length\"} header does not parse as a long\n     */\n    public static long getContentLength(HttpMessage message, long defaultValue) {\n        String value = message.headers().get(HttpHeaderNames.CONTENT_LENGTH);\n        if (value != null) {\n            return Long.parseLong(value);\n        }\n\n        // We know the content length if it's a Web Socket message even if\n        // Content-Length header is missing.\n        long webSocketContentLength = getWebSocketContentLength(message);\n        if (webSocketContentLength >= 0) {\n            return webSocketContentLength;\n        }\n\n        // Otherwise we don't.\n        return defaultValue;\n    }\n\n    /**\n     * Get an {@code int} representation of {@link #getContentLength(HttpMessage, long)}.\n     *\n     * @return the content length or {@code defaultValue} if this message does\n     *         not have the {@code \"Content-Length\"} header or its value is not\n     *         a number. Not to exceed the boundaries of integer.\n     */\n    public static int getContentLength(HttpMessage message, int defaultValue) {\n        return (int) Math.min(Integer.MAX_VALUE, getContentLength(message, (long) defaultValue));\n    }\n\n    /**\n     * Returns the content length of the specified web socket message. If the\n     * specified message is not a web socket message, {@code -1} is returned.\n     */\n    private static int getWebSocketContentLength(HttpMessage message) {\n        // WebSocket messages have constant content-lengths.\n        HttpHeaders h = message.headers();\n        if (message instanceof HttpRequest) {\n            HttpRequest req = (HttpRequest) message;\n            if (HttpMethod.GET.equals(req.method()) &&\n                    h.contains(HttpHeaderNames.SEC_WEBSOCKET_KEY1) &&\n                    h.contains(HttpHeaderNames.SEC_WEBSOCKET_KEY2)) {\n                return 8;\n            }\n        } else if (message instanceof HttpResponse) {\n            HttpResponse res = (HttpResponse) message;\n            if (res.status().code() == 101 &&\n                    h.contains(HttpHeaderNames.SEC_WEBSOCKET_ORIGIN) &&\n                    h.contains(HttpHeaderNames.SEC_WEBSOCKET_LOCATION)) {\n                return 16;\n            }\n        }\n\n        // Not a web socket message\n        return -1;\n    }\n\n    /**\n     * Sets the {@code \"Content-Length\"} header.\n     */\n    public static void setContentLength(HttpMessage message, long length) {\n        message.headers().set(HttpHeaderNames.CONTENT_LENGTH, length);\n    }\n\n    public static boolean isContentLengthSet(HttpMessage m) {\n        return m.headers().contains(HttpHeaderNames.CONTENT_LENGTH);\n    }\n\n    /**\n     * Returns {@code true} if and only if the specified message contains an expect header and the only expectation\n     * present is the 100-continue expectation. Note that this method returns {@code false} if the expect header is\n     * not valid for the message (e.g., the message is a response, or the version on the message is HTTP/1.0).\n     *\n     * @param message the message\n     * @return {@code true} if and only if the expectation 100-continue is present and it is the only expectation\n     * present\n     */\n    public static boolean is100ContinueExpected(HttpMessage message) {\n        return isExpectHeaderValid(message)\n          // unquoted tokens in the expect header are case-insensitive, thus 100-continue is case insensitive\n          && message.headers().contains(HttpHeaderNames.EXPECT, HttpHeaderValues.CONTINUE, true);\n    }\n\n    /**\n     * Returns {@code true} if the specified message contains an expect header specifying an expectation that is not\n     * supported. Note that this method returns {@code false} if the expect header is not valid for the message\n     * (e.g., the message is a response, or the version on the message is HTTP/1.0).\n     *\n     * @param message the message\n     * @return {@code true} if and only if an expectation is present that is not supported\n     */\n    static boolean isUnsupportedExpectation(HttpMessage message) {\n        if (!isExpectHeaderValid(message)) {\n            return false;\n        }\n\n        final String expectValue = message.headers().get(HttpHeaderNames.EXPECT);\n        return expectValue != null && !HttpHeaderValues.CONTINUE.toString().equalsIgnoreCase(expectValue);\n    }\n\n    private static boolean isExpectHeaderValid(final HttpMessage message) {\n        /*\n         * Expect: 100-continue is for requests only and it works only on HTTP/1.1 or later. Note further that RFC 7231\n         * section 5.1.1 says \"A server that receives a 100-continue expectation in an HTTP/1.0 request MUST ignore\n         * that expectation.\"\n         */\n        return message instanceof HttpRequest &&\n                message.protocolVersion().compareTo(HttpVersion.HTTP_1_1) >= 0;\n    }\n\n    /**\n     * Sets or removes the {@code \"Expect: 100-continue\"} header to / from the\n     * specified message. If {@code expected} is {@code true},\n     * the {@code \"Expect: 100-continue\"} header is set and all other previous\n     * {@code \"Expect\"} headers are removed.  Otherwise, all {@code \"Expect\"}\n     * headers are removed completely.\n     */\n    public static void set100ContinueExpected(HttpMessage message, boolean expected) {\n        if (expected) {\n            message.headers().set(HttpHeaderNames.EXPECT, HttpHeaderValues.CONTINUE);\n        } else {\n            message.headers().remove(HttpHeaderNames.EXPECT);\n        }\n    }\n\n    /**\n     * Checks to see if the transfer encoding in a specified {@link HttpMessage} is chunked\n     *\n     * @param message The message to check\n     * @return True if transfer encoding is chunked, otherwise false\n     */\n    public static boolean isTransferEncodingChunked(HttpMessage message) {\n        return message.headers().containsValue(HttpHeaderNames.TRANSFER_ENCODING, HttpHeaderValues.CHUNKED, true);\n    }\n\n    /**\n     * Set the {@link HttpHeaderNames#TRANSFER_ENCODING} to either include {@link HttpHeaderValues#CHUNKED} if\n     * {@code chunked} is {@code true}, or remove {@link HttpHeaderValues#CHUNKED} if {@code chunked} is {@code false}.\n     *\n     * @param m The message which contains the headers to modify.\n     * @param chunked if {@code true} then include {@link HttpHeaderValues#CHUNKED} in the headers. otherwise remove\n     * {@link HttpHeaderValues#CHUNKED} from the headers.\n     */\n    public static void setTransferEncodingChunked(HttpMessage m, boolean chunked) {\n        if (chunked) {\n            m.headers().set(HttpHeaderNames.TRANSFER_ENCODING, HttpHeaderValues.CHUNKED);\n            m.headers().remove(HttpHeaderNames.CONTENT_LENGTH);\n        } else {\n            List<String> encodings = m.headers().getAll(HttpHeaderNames.TRANSFER_ENCODING);\n            if (encodings.isEmpty()) {\n                return;\n            }\n            List<CharSequence> values = new ArrayList<CharSequence>(encodings);\n            Iterator<CharSequence> valuesIt = values.iterator();\n            while (valuesIt.hasNext()) {\n                CharSequence value = valuesIt.next();\n                if (HttpHeaderValues.CHUNKED.contentEqualsIgnoreCase(value)) {\n                    valuesIt.remove();\n                }\n            }\n            if (values.isEmpty()) {\n                m.headers().remove(HttpHeaderNames.TRANSFER_ENCODING);\n            } else {\n                m.headers().set(HttpHeaderNames.TRANSFER_ENCODING, values);\n            }\n        }\n    }\n\n    /**\n     * Fetch charset from message's Content-Type header.\n     *\n     * @param message entity to fetch Content-Type header from\n     * @return the charset from message's Content-Type header or {@link CharsetUtil#ISO_8859_1}\n     * if charset is not presented or unparsable\n     */\n    public static Charset getCharset(HttpMessage message) {\n        return getCharset(message, CharsetUtil.ISO_8859_1);\n    }\n\n    /**\n     * Fetch charset from Content-Type header value.\n     *\n     * @param contentTypeValue Content-Type header value to parse\n     * @return the charset from message's Content-Type header or {@link CharsetUtil#ISO_8859_1}\n     * if charset is not presented or unparsable\n     */\n    public static Charset getCharset(CharSequence contentTypeValue) {\n        if (contentTypeValue != null) {\n            return getCharset(contentTypeValue, CharsetUtil.ISO_8859_1);\n        } else {\n            return CharsetUtil.ISO_8859_1;\n        }\n    }\n\n    /**\n     * Fetch charset from message's Content-Type header.\n     *\n     * @param message        entity to fetch Content-Type header from\n     * @param defaultCharset result to use in case of empty, incorrect or doesn't contain required part header value\n     * @return the charset from message's Content-Type header or {@code defaultCharset}\n     * if charset is not presented or unparsable\n     */\n    public static Charset getCharset(HttpMessage message, Charset defaultCharset) {\n        CharSequence contentTypeValue = message.headers().get(HttpHeaderNames.CONTENT_TYPE);\n        if (contentTypeValue != null) {\n            return getCharset(contentTypeValue, defaultCharset);\n        } else {\n            return defaultCharset;\n        }\n    }\n\n    /**\n     * Fetch charset from Content-Type header value.\n     *\n     * @param contentTypeValue Content-Type header value to parse\n     * @param defaultCharset   result to use in case of empty, incorrect or doesn't contain required part header value\n     * @return the charset from message's Content-Type header or {@code defaultCharset}\n     * if charset is not presented or unparsable\n     */\n    public static Charset getCharset(CharSequence contentTypeValue, Charset defaultCharset) {\n        if (contentTypeValue != null) {\n            CharSequence charsetCharSequence = getCharsetAsSequence(contentTypeValue);\n            if (charsetCharSequence != null) {\n                try {\n                    return Charset.forName(charsetCharSequence.toString());\n                } catch (IllegalCharsetNameException ignored) {\n                    // just return the default charset\n                } catch (UnsupportedCharsetException ignored) {\n                    // just return the default charset\n                }\n            }\n        }\n        return defaultCharset;\n    }\n\n    /**\n     * Fetch charset from message's Content-Type header as a char sequence.\n     *\n     * A lot of sites/possibly clients have charset=\"CHARSET\", for example charset=\"utf-8\". Or \"utf8\" instead of \"utf-8\"\n     * This is not according to standard, but this method provide an ability to catch desired mistakes manually in code\n     *\n     * @param message entity to fetch Content-Type header from\n     * @return the {@code CharSequence} with charset from message's Content-Type header\n     * or {@code null} if charset is not presented\n     * @deprecated use {@link #getCharsetAsSequence(HttpMessage)}\n     */\n    @Deprecated\n    public static CharSequence getCharsetAsString(HttpMessage message) {\n        return getCharsetAsSequence(message);\n    }\n\n    /**\n     * Fetch charset from message's Content-Type header as a char sequence.\n     *\n     * A lot of sites/possibly clients have charset=\"CHARSET\", for example charset=\"utf-8\". Or \"utf8\" instead of \"utf-8\"\n     * This is not according to standard, but this method provide an ability to catch desired mistakes manually in code\n     *\n     * @return the {@code CharSequence} with charset from message's Content-Type header\n     * or {@code null} if charset is not presented\n     */\n    public static CharSequence getCharsetAsSequence(HttpMessage message) {\n        CharSequence contentTypeValue = message.headers().get(HttpHeaderNames.CONTENT_TYPE);\n        if (contentTypeValue != null) {\n            return getCharsetAsSequence(contentTypeValue);\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * Fetch charset from Content-Type header value as a char sequence.\n     *\n     * A lot of sites/possibly clients have charset=\"CHARSET\", for example charset=\"utf-8\". Or \"utf8\" instead of \"utf-8\"\n     * This is not according to standard, but this method provide an ability to catch desired mistakes manually in code\n     *\n     * @param contentTypeValue Content-Type header value to parse\n     * @return the {@code CharSequence} with charset from message's Content-Type header\n     * or {@code null} if charset is not presented\n     * @throws NullPointerException in case if {@code contentTypeValue == null}\n     */\n    public static CharSequence getCharsetAsSequence(CharSequence contentTypeValue) {\n        ObjectUtil.checkNotNull(contentTypeValue, \"contentTypeValue\");\n\n        int indexOfCharset = AsciiString.indexOfIgnoreCaseAscii(contentTypeValue, CHARSET_EQUALS, 0);\n        if (indexOfCharset == AsciiString.INDEX_NOT_FOUND) {\n            return null;\n        }\n\n        int indexOfEncoding = indexOfCharset + CHARSET_EQUALS.length();\n        if (indexOfEncoding < contentTypeValue.length()) {\n            CharSequence charsetCandidate = contentTypeValue.subSequence(indexOfEncoding, contentTypeValue.length());\n            int indexOfSemicolon = AsciiString.indexOfIgnoreCaseAscii(charsetCandidate, SEMICOLON, 0);\n            if (indexOfSemicolon == AsciiString.INDEX_NOT_FOUND) {\n                return charsetCandidate;\n            }\n\n            return charsetCandidate.subSequence(0, indexOfSemicolon);\n        }\n\n        return null;\n    }\n\n    /**\n     * Fetch MIME type part from message's Content-Type header as a char sequence.\n     *\n     * @param message entity to fetch Content-Type header from\n     * @return the MIME type as a {@code CharSequence} from message's Content-Type header\n     * or {@code null} if content-type header or MIME type part of this header are not presented\n     * <p/>\n     * \"content-type: text/html; charset=utf-8\" - \"text/html\" will be returned <br/>\n     * \"content-type: text/html\" - \"text/html\" will be returned <br/>\n     * \"content-type: \" or no header - {@code null} we be returned\n     */\n    public static CharSequence getMimeType(HttpMessage message) {\n        CharSequence contentTypeValue = message.headers().get(HttpHeaderNames.CONTENT_TYPE);\n        if (contentTypeValue != null) {\n            return getMimeType(contentTypeValue);\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * Fetch MIME type part from Content-Type header value as a char sequence.\n     *\n     * @param contentTypeValue Content-Type header value to parse\n     * @return the MIME type as a {@code CharSequence} from message's Content-Type header\n     * or {@code null} if content-type header or MIME type part of this header are not presented\n     * <p/>\n     * \"content-type: text/html; charset=utf-8\" - \"text/html\" will be returned <br/>\n     * \"content-type: text/html\" - \"text/html\" will be returned <br/>\n     * \"content-type: empty header - {@code null} we be returned\n     * @throws NullPointerException in case if {@code contentTypeValue == null}\n     */\n    public static CharSequence getMimeType(CharSequence contentTypeValue) {\n        ObjectUtil.checkNotNull(contentTypeValue, \"contentTypeValue\");\n\n        int indexOfSemicolon = AsciiString.indexOfIgnoreCaseAscii(contentTypeValue, SEMICOLON, 0);\n        if (indexOfSemicolon != AsciiString.INDEX_NOT_FOUND) {\n            return contentTypeValue.subSequence(0, indexOfSemicolon);\n        } else {\n            return contentTypeValue.length() > 0 ? contentTypeValue : null;\n        }\n    }\n\n    /**\n     * Formats the host string of an address so it can be used for computing an HTTP component\n     * such as a URL or a Host header\n     *\n     * @param addr the address\n     * @return the formatted String\n     */\n    public static String formatHostnameForHttp(InetSocketAddress addr) {\n        String hostString = NetUtil.getHostname(addr);\n        if (NetUtil.isValidIpV6Address(hostString)) {\n            if (!addr.isUnresolved()) {\n                hostString = NetUtil.toAddressString(addr.getAddress());\n            }\n            return '[' + hostString + ']';\n        }\n        return hostString;\n    }\n\n    /**\n     * Validates, and optionally extracts the content length from headers. This method is not intended for\n     * general use, but is here to be shared between HTTP/1 and HTTP/2 parsing.\n     *\n     * @param contentLengthFields the content-length header fields.\n     * @param isHttp10OrEarlier {@code true} if we are handling HTTP/1.0 or earlier\n     * @param allowDuplicateContentLengths {@code true}  if multiple, identical-value content lengths should be allowed.\n     * @return the normalized content length from the headers or {@code -1} if the fields were empty.\n     * @throws IllegalArgumentException if the content-length fields are not valid\n     */\n    @UnstableApi\n    public static long normalizeAndGetContentLength(\n            List<? extends CharSequence> contentLengthFields, boolean isHttp10OrEarlier,\n            boolean allowDuplicateContentLengths) {\n        if (contentLengthFields.isEmpty()) {\n            return -1;\n        }\n\n        // Guard against multiple Content-Length headers as stated in\n        // https://tools.ietf.org/html/rfc7230#section-3.3.2:\n        //\n        // If a message is received that has multiple Content-Length header\n        //   fields with field-values consisting of the same decimal value, or a\n        //   single Content-Length header field with a field value containing a\n        //   list of identical decimal values (e.g., \"Content-Length: 42, 42\"),\n        //   indicating that duplicate Content-Length header fields have been\n        //   generated or combined by an upstream message processor, then the\n        //   recipient MUST either reject the message as invalid or replace the\n        //   duplicated field-values with a single valid Content-Length field\n        //   containing that decimal value prior to determining the message body\n        //   length or forwarding the message.\n        String firstField = contentLengthFields.get(0).toString();\n        boolean multipleContentLengths =\n                contentLengthFields.size() > 1 || firstField.indexOf(COMMA) >= 0;\n\n        if (multipleContentLengths && !isHttp10OrEarlier) {\n            if (allowDuplicateContentLengths) {\n                // Find and enforce that all Content-Length values are the same\n                String firstValue = null;\n                for (CharSequence field : contentLengthFields) {\n                    String[] tokens = field.toString().split(COMMA_STRING, -1);\n                    for (String token : tokens) {\n                        String trimmed = token.trim();\n                        if (firstValue == null) {\n                            firstValue = trimmed;\n                        } else if (!trimmed.equals(firstValue)) {\n                            throw new IllegalArgumentException(\n                                    \"Multiple Content-Length values found: \" + contentLengthFields);\n                        }\n                    }\n                }\n                // Replace the duplicated field-values with a single valid Content-Length field\n                firstField = firstValue;\n            } else {\n                // Reject the message as invalid\n                throw new IllegalArgumentException(\n                        \"Multiple Content-Length values found: \" + contentLengthFields);\n            }\n        }\n        // Ensure we not allow sign as part of the content-length:\n        // See https://github.com/squid-cache/squid/security/advisories/GHSA-qf3v-rc95-96j5\n        if (!Character.isDigit(firstField.charAt(0))) {\n            // Reject the message as invalid\n            throw new IllegalArgumentException(\n                    \"Content-Length value is not a number: \" + firstField);\n        }\n        try {\n            final long value = Long.parseLong(firstField);\n            if (value < 0) {\n                // Reject the message as invalid\n                throw new IllegalArgumentException(\n                        \"Content-Length value must be >=0: \" + value);\n            }\n            return value;\n        } catch (NumberFormatException e) {\n            // Reject the message as invalid\n            throw new IllegalArgumentException(\n                    \"Content-Length value is not a number: \" + firstField, e);\n        }\n    }\n}\n", "/*\n * Copyright 2014 The Netty Project\n *\n * The Netty Project licenses this file to you under the Apache License, version 2.0 (the\n * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n * copy of the License at:\n *\n * https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under the License\n * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n * or implied. See the License for the specific language governing permissions and limitations under\n * the License.\n */\npackage io.netty.handler.codec.http2;\n\nimport io.netty.buffer.ByteBuf;\nimport io.netty.channel.ChannelHandlerContext;\nimport io.netty.handler.codec.http.HttpHeaderNames;\nimport io.netty.handler.codec.http.HttpStatusClass;\nimport io.netty.handler.codec.http.HttpUtil;\nimport io.netty.handler.codec.http2.Http2Connection.Endpoint;\nimport io.netty.util.internal.SystemPropertyUtil;\nimport io.netty.util.internal.UnstableApi;\nimport io.netty.util.internal.logging.InternalLogger;\nimport io.netty.util.internal.logging.InternalLoggerFactory;\n\nimport java.util.List;\n\nimport static io.netty.handler.codec.http.HttpStatusClass.INFORMATIONAL;\nimport static io.netty.handler.codec.http2.Http2CodecUtil.DEFAULT_PRIORITY_WEIGHT;\nimport static io.netty.handler.codec.http2.Http2Error.INTERNAL_ERROR;\nimport static io.netty.handler.codec.http2.Http2Error.PROTOCOL_ERROR;\nimport static io.netty.handler.codec.http2.Http2Error.STREAM_CLOSED;\nimport static io.netty.handler.codec.http2.Http2Exception.connectionError;\nimport static io.netty.handler.codec.http2.Http2Exception.streamError;\nimport static io.netty.handler.codec.http2.Http2PromisedRequestVerifier.ALWAYS_VERIFY;\nimport static io.netty.handler.codec.http2.Http2Stream.State.CLOSED;\nimport static io.netty.handler.codec.http2.Http2Stream.State.HALF_CLOSED_REMOTE;\nimport static io.netty.util.internal.ObjectUtil.checkNotNull;\nimport static java.lang.Integer.MAX_VALUE;\nimport static java.lang.Math.min;\n\n/**\n * Provides the default implementation for processing inbound frame events and delegates to a\n * {@link Http2FrameListener}\n * <p>\n * This class will read HTTP/2 frames and delegate the events to a {@link Http2FrameListener}\n * <p>\n * This interface enforces inbound flow control functionality through\n * {@link Http2LocalFlowController}\n */\n@UnstableApi\npublic class DefaultHttp2ConnectionDecoder implements Http2ConnectionDecoder {\n    private static final boolean VALIDATE_CONTENT_LENGTH =\n            SystemPropertyUtil.getBoolean(\"io.netty.http2.validateContentLength\", true);\n    private static final InternalLogger logger = InternalLoggerFactory.getInstance(DefaultHttp2ConnectionDecoder.class);\n    private Http2FrameListener internalFrameListener = new PrefaceFrameListener();\n    private final Http2Connection connection;\n    private Http2LifecycleManager lifecycleManager;\n    private final Http2ConnectionEncoder encoder;\n    private final Http2FrameReader frameReader;\n    private Http2FrameListener listener;\n    private final Http2PromisedRequestVerifier requestVerifier;\n    private final Http2SettingsReceivedConsumer settingsReceivedConsumer;\n    private final boolean autoAckPing;\n    private final Http2Connection.PropertyKey contentLengthKey;\n\n    public DefaultHttp2ConnectionDecoder(Http2Connection connection,\n                                         Http2ConnectionEncoder encoder,\n                                         Http2FrameReader frameReader) {\n        this(connection, encoder, frameReader, ALWAYS_VERIFY);\n    }\n\n    public DefaultHttp2ConnectionDecoder(Http2Connection connection,\n                                         Http2ConnectionEncoder encoder,\n                                         Http2FrameReader frameReader,\n                                         Http2PromisedRequestVerifier requestVerifier) {\n        this(connection, encoder, frameReader, requestVerifier, true);\n    }\n\n    /**\n     * Create a new instance.\n     * @param connection The {@link Http2Connection} associated with this decoder.\n     * @param encoder The {@link Http2ConnectionEncoder} associated with this decoder.\n     * @param frameReader Responsible for reading/parsing the raw frames. As opposed to this object which applies\n     *                    h2 semantics on top of the frames.\n     * @param requestVerifier Determines if push promised streams are valid.\n     * @param autoAckSettings {@code false} to disable automatically applying and sending settings acknowledge frame.\n     *  The {@code Http2ConnectionEncoder} is expected to be an instance of {@link Http2SettingsReceivedConsumer} and\n     *  will apply the earliest received but not yet ACKed SETTINGS when writing the SETTINGS ACKs.\n     * {@code true} to enable automatically applying and sending settings acknowledge frame.\n     */\n    public DefaultHttp2ConnectionDecoder(Http2Connection connection,\n                                         Http2ConnectionEncoder encoder,\n                                         Http2FrameReader frameReader,\n                                         Http2PromisedRequestVerifier requestVerifier,\n                                         boolean autoAckSettings) {\n        this(connection, encoder, frameReader, requestVerifier, autoAckSettings, true);\n    }\n\n    /**\n     * Create a new instance.\n     * @param connection The {@link Http2Connection} associated with this decoder.\n     * @param encoder The {@link Http2ConnectionEncoder} associated with this decoder.\n     * @param frameReader Responsible for reading/parsing the raw frames. As opposed to this object which applies\n     *                    h2 semantics on top of the frames.\n     * @param requestVerifier Determines if push promised streams are valid.\n     * @param autoAckSettings {@code false} to disable automatically applying and sending settings acknowledge frame.\n     *                        The {@code Http2ConnectionEncoder} is expected to be an instance of\n     *                        {@link Http2SettingsReceivedConsumer} and will apply the earliest received but not yet\n     *                        ACKed SETTINGS when writing the SETTINGS ACKs. {@code true} to enable automatically\n     *                        applying and sending settings acknowledge frame.\n     * @param autoAckPing {@code false} to disable automatically sending ping acknowledge frame. {@code true} to enable\n     *                    automatically sending ping ack frame.\n     */\n    public DefaultHttp2ConnectionDecoder(Http2Connection connection,\n                                         Http2ConnectionEncoder encoder,\n                                         Http2FrameReader frameReader,\n                                         Http2PromisedRequestVerifier requestVerifier,\n                                         boolean autoAckSettings,\n                                         boolean autoAckPing) {\n        this.autoAckPing = autoAckPing;\n        if (autoAckSettings) {\n            settingsReceivedConsumer = null;\n        } else {\n            if (!(encoder instanceof Http2SettingsReceivedConsumer)) {\n                throw new IllegalArgumentException(\"disabling autoAckSettings requires the encoder to be a \" +\n                        Http2SettingsReceivedConsumer.class);\n            }\n            settingsReceivedConsumer = (Http2SettingsReceivedConsumer) encoder;\n        }\n        this.connection = checkNotNull(connection, \"connection\");\n        contentLengthKey = this.connection.newKey();\n        this.frameReader = checkNotNull(frameReader, \"frameReader\");\n        this.encoder = checkNotNull(encoder, \"encoder\");\n        this.requestVerifier = checkNotNull(requestVerifier, \"requestVerifier\");\n        if (connection.local().flowController() == null) {\n            connection.local().flowController(new DefaultHttp2LocalFlowController(connection));\n        }\n        connection.local().flowController().frameWriter(encoder.frameWriter());\n    }\n\n    @Override\n    public void lifecycleManager(Http2LifecycleManager lifecycleManager) {\n        this.lifecycleManager = checkNotNull(lifecycleManager, \"lifecycleManager\");\n    }\n\n    @Override\n    public Http2Connection connection() {\n        return connection;\n    }\n\n    @Override\n    public final Http2LocalFlowController flowController() {\n        return connection.local().flowController();\n    }\n\n    @Override\n    public void frameListener(Http2FrameListener listener) {\n        this.listener = checkNotNull(listener, \"listener\");\n    }\n\n    @Override\n    public Http2FrameListener frameListener() {\n        return listener;\n    }\n\n    // Visible for testing\n    Http2FrameListener internalFrameListener() {\n        return internalFrameListener;\n    }\n\n    @Override\n    public boolean prefaceReceived() {\n        return FrameReadListener.class == internalFrameListener.getClass();\n    }\n\n    @Override\n    public void decodeFrame(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) throws Http2Exception {\n        frameReader.readFrame(ctx, in, internalFrameListener);\n    }\n\n    @Override\n    public Http2Settings localSettings() {\n        Http2Settings settings = new Http2Settings();\n        Http2FrameReader.Configuration config = frameReader.configuration();\n        Http2HeadersDecoder.Configuration headersConfig = config.headersConfiguration();\n        Http2FrameSizePolicy frameSizePolicy = config.frameSizePolicy();\n        settings.initialWindowSize(flowController().initialWindowSize());\n        settings.maxConcurrentStreams(connection.remote().maxActiveStreams());\n        settings.headerTableSize(headersConfig.maxHeaderTableSize());\n        settings.maxFrameSize(frameSizePolicy.maxFrameSize());\n        settings.maxHeaderListSize(headersConfig.maxHeaderListSize());\n        if (!connection.isServer()) {\n            // Only set the pushEnabled flag if this is a client endpoint.\n            settings.pushEnabled(connection.local().allowPushTo());\n        }\n        return settings;\n    }\n\n    @Override\n    public void close() {\n        frameReader.close();\n    }\n\n    /**\n     * Calculate the threshold in bytes which should trigger a {@code GO_AWAY} if a set of headers exceeds this amount.\n     * @param maxHeaderListSize\n     *      <a href=\"https://tools.ietf.org/html/rfc7540#section-6.5.2\">SETTINGS_MAX_HEADER_LIST_SIZE</a> for the local\n     *      endpoint.\n     * @return the threshold in bytes which should trigger a {@code GO_AWAY} if a set of headers exceeds this amount.\n     */\n    protected long calculateMaxHeaderListSizeGoAway(long maxHeaderListSize) {\n        return Http2CodecUtil.calculateMaxHeaderListSizeGoAway(maxHeaderListSize);\n    }\n\n    private int unconsumedBytes(Http2Stream stream) {\n        return flowController().unconsumedBytes(stream);\n    }\n\n    void onGoAwayRead0(ChannelHandlerContext ctx, int lastStreamId, long errorCode, ByteBuf debugData)\n            throws Http2Exception {\n        listener.onGoAwayRead(ctx, lastStreamId, errorCode, debugData);\n        connection.goAwayReceived(lastStreamId, errorCode, debugData);\n    }\n\n    void onUnknownFrame0(ChannelHandlerContext ctx, byte frameType, int streamId, Http2Flags flags,\n            ByteBuf payload) throws Http2Exception {\n        listener.onUnknownFrame(ctx, frameType, streamId, flags, payload);\n    }\n\n    // See https://tools.ietf.org/html/rfc7540#section-8.1.2.6\n    private void verifyContentLength(Http2Stream stream, int data, boolean isEnd) throws Http2Exception {\n        if (!VALIDATE_CONTENT_LENGTH) {\n            return;\n        }\n        ContentLength contentLength = stream.getProperty(contentLengthKey);\n        if (contentLength != null) {\n            try {\n                contentLength.increaseReceivedBytes(connection.isServer(), stream.id(), data, isEnd);\n            } finally {\n                if (isEnd) {\n                    stream.removeProperty(contentLengthKey);\n                }\n            }\n        }\n    }\n\n    /**\n     * Handles all inbound frames from the network.\n     */\n    private final class FrameReadListener implements Http2FrameListener {\n        @Override\n        public int onDataRead(final ChannelHandlerContext ctx, int streamId, ByteBuf data, int padding,\n                              boolean endOfStream) throws Http2Exception {\n            Http2Stream stream = connection.stream(streamId);\n            Http2LocalFlowController flowController = flowController();\n            int readable = data.readableBytes();\n            int bytesToReturn = readable + padding;\n\n            final boolean shouldIgnore;\n            try {\n                shouldIgnore = shouldIgnoreHeadersOrDataFrame(ctx, streamId, stream, \"DATA\");\n            } catch (Http2Exception e) {\n                // Ignoring this frame. We still need to count the frame towards the connection flow control\n                // window, but we immediately mark all bytes as consumed.\n                flowController.receiveFlowControlledFrame(stream, data, padding, endOfStream);\n                flowController.consumeBytes(stream, bytesToReturn);\n                throw e;\n            } catch (Throwable t) {\n                throw connectionError(INTERNAL_ERROR, t, \"Unhandled error on data stream id %d\", streamId);\n            }\n\n            if (shouldIgnore) {\n                // Ignoring this frame. We still need to count the frame towards the connection flow control\n                // window, but we immediately mark all bytes as consumed.\n                flowController.receiveFlowControlledFrame(stream, data, padding, endOfStream);\n                flowController.consumeBytes(stream, bytesToReturn);\n\n                // Verify that the stream may have existed after we apply flow control.\n                verifyStreamMayHaveExisted(streamId);\n\n                // All bytes have been consumed.\n                return bytesToReturn;\n            }\n            Http2Exception error = null;\n            switch (stream.state()) {\n                case OPEN:\n                case HALF_CLOSED_LOCAL:\n                    break;\n                case HALF_CLOSED_REMOTE:\n                case CLOSED:\n                    error = streamError(stream.id(), STREAM_CLOSED, \"Stream %d in unexpected state: %s\",\n                        stream.id(), stream.state());\n                    break;\n                default:\n                    error = streamError(stream.id(), PROTOCOL_ERROR,\n                        \"Stream %d in unexpected state: %s\", stream.id(), stream.state());\n                    break;\n            }\n\n            int unconsumedBytes = unconsumedBytes(stream);\n            try {\n                flowController.receiveFlowControlledFrame(stream, data, padding, endOfStream);\n                // Update the unconsumed bytes after flow control is applied.\n                unconsumedBytes = unconsumedBytes(stream);\n\n                // If the stream is in an invalid state to receive the frame, throw the error.\n                if (error != null) {\n                    throw error;\n                }\n\n                verifyContentLength(stream, readable, endOfStream);\n\n                // Call back the application and retrieve the number of bytes that have been\n                // immediately processed.\n                bytesToReturn = listener.onDataRead(ctx, streamId, data, padding, endOfStream);\n                return bytesToReturn;\n            } catch (Http2Exception e) {\n                // If an exception happened during delivery, the listener may have returned part\n                // of the bytes before the error occurred. If that's the case, subtract that from\n                // the total processed bytes so that we don't return too many bytes.\n                int delta = unconsumedBytes - unconsumedBytes(stream);\n                bytesToReturn -= delta;\n                throw e;\n            } catch (RuntimeException e) {\n                // If an exception happened during delivery, the listener may have returned part\n                // of the bytes before the error occurred. If that's the case, subtract that from\n                // the total processed bytes so that we don't return too many bytes.\n                int delta = unconsumedBytes - unconsumedBytes(stream);\n                bytesToReturn -= delta;\n                throw e;\n            } finally {\n                // If appropriate, return the processed bytes to the flow controller.\n                flowController.consumeBytes(stream, bytesToReturn);\n\n                if (endOfStream) {\n                    lifecycleManager.closeStreamRemote(stream, ctx.newSucceededFuture());\n                }\n            }\n        }\n\n        @Override\n        public void onHeadersRead(ChannelHandlerContext ctx, int streamId, Http2Headers headers, int padding,\n                boolean endOfStream) throws Http2Exception {\n            onHeadersRead(ctx, streamId, headers, 0, DEFAULT_PRIORITY_WEIGHT, false, padding, endOfStream);\n        }\n\n        @Override\n        public void onHeadersRead(ChannelHandlerContext ctx, int streamId, Http2Headers headers, int streamDependency,\n                short weight, boolean exclusive, int padding, boolean endOfStream) throws Http2Exception {\n            Http2Stream stream = connection.stream(streamId);\n            boolean allowHalfClosedRemote = false;\n            if (stream == null && !connection.streamMayHaveExisted(streamId)) {\n                stream = connection.remote().createStream(streamId, endOfStream);\n                // Allow the state to be HALF_CLOSE_REMOTE if we're creating it in that state.\n                allowHalfClosedRemote = stream.state() == HALF_CLOSED_REMOTE;\n            }\n\n            if (shouldIgnoreHeadersOrDataFrame(ctx, streamId, stream, \"HEADERS\")) {\n                return;\n            }\n\n            boolean isInformational = !connection.isServer() &&\n                    HttpStatusClass.valueOf(headers.status()) == INFORMATIONAL;\n            if ((isInformational || !endOfStream) && stream.isHeadersReceived() || stream.isTrailersReceived()) {\n                throw streamError(streamId, PROTOCOL_ERROR,\n                                  \"Stream %d received too many headers EOS: %s state: %s\",\n                                  streamId, endOfStream, stream.state());\n            }\n\n            switch (stream.state()) {\n                case RESERVED_REMOTE:\n                    stream.open(endOfStream);\n                    break;\n                case OPEN:\n                case HALF_CLOSED_LOCAL:\n                    // Allowed to receive headers in these states.\n                    break;\n                case HALF_CLOSED_REMOTE:\n                    if (!allowHalfClosedRemote) {\n                        throw streamError(stream.id(), STREAM_CLOSED, \"Stream %d in unexpected state: %s\",\n                                stream.id(), stream.state());\n                    }\n                    break;\n                case CLOSED:\n                    throw streamError(stream.id(), STREAM_CLOSED, \"Stream %d in unexpected state: %s\",\n                            stream.id(), stream.state());\n                default:\n                    // Connection error.\n                    throw connectionError(PROTOCOL_ERROR, \"Stream %d in unexpected state: %s\", stream.id(),\n                            stream.state());\n            }\n\n            if (!stream.isHeadersReceived()) {\n                // extract the content-length header\n                List<? extends CharSequence> contentLength = headers.getAll(HttpHeaderNames.CONTENT_LENGTH);\n                if (contentLength != null && !contentLength.isEmpty()) {\n                    try {\n                        long cLength = HttpUtil.normalizeAndGetContentLength(contentLength, false, true);\n                        if (cLength != -1) {\n                            headers.setLong(HttpHeaderNames.CONTENT_LENGTH, cLength);\n                            stream.setProperty(contentLengthKey, new ContentLength(cLength));\n                        }\n                    } catch (IllegalArgumentException e) {\n                        throw streamError(stream.id(), PROTOCOL_ERROR,\n                                \"Multiple content-length headers received\", e);\n                    }\n                }\n            }\n\n            stream.headersReceived(isInformational);\n            try {\n                verifyContentLength(stream, 0, endOfStream);\n                encoder.flowController().updateDependencyTree(streamId, streamDependency, weight, exclusive);\n                listener.onHeadersRead(ctx, streamId, headers, streamDependency,\n                        weight, exclusive, padding, endOfStream);\n            } finally {\n                // If the headers completes this stream, close it.\n                if (endOfStream) {\n                    lifecycleManager.closeStreamRemote(stream, ctx.newSucceededFuture());\n                }\n            }\n        }\n\n        @Override\n        public void onPriorityRead(ChannelHandlerContext ctx, int streamId, int streamDependency, short weight,\n                boolean exclusive) throws Http2Exception {\n            encoder.flowController().updateDependencyTree(streamId, streamDependency, weight, exclusive);\n\n            listener.onPriorityRead(ctx, streamId, streamDependency, weight, exclusive);\n        }\n\n        @Override\n        public void onRstStreamRead(ChannelHandlerContext ctx, int streamId, long errorCode) throws Http2Exception {\n            Http2Stream stream = connection.stream(streamId);\n            if (stream == null) {\n                verifyStreamMayHaveExisted(streamId);\n                return;\n            }\n\n            switch(stream.state()) {\n            case IDLE:\n                throw connectionError(PROTOCOL_ERROR, \"RST_STREAM received for IDLE stream %d\", streamId);\n            case CLOSED:\n                return; // RST_STREAM frames must be ignored for closed streams.\n            default:\n                break;\n            }\n\n            listener.onRstStreamRead(ctx, streamId, errorCode);\n\n            lifecycleManager.closeStream(stream, ctx.newSucceededFuture());\n        }\n\n        @Override\n        public void onSettingsAckRead(ChannelHandlerContext ctx) throws Http2Exception {\n            // Apply oldest outstanding local settings here. This is a synchronization point between endpoints.\n            Http2Settings settings = encoder.pollSentSettings();\n\n            if (settings != null) {\n                applyLocalSettings(settings);\n            }\n\n            listener.onSettingsAckRead(ctx);\n        }\n\n        /**\n         * Applies settings sent from the local endpoint.\n         * <p>\n         * This method is only called after the local settings have been acknowledged from the remote endpoint.\n         */\n        private void applyLocalSettings(Http2Settings settings) throws Http2Exception {\n            Boolean pushEnabled = settings.pushEnabled();\n            final Http2FrameReader.Configuration config = frameReader.configuration();\n            final Http2HeadersDecoder.Configuration headerConfig = config.headersConfiguration();\n            final Http2FrameSizePolicy frameSizePolicy = config.frameSizePolicy();\n            if (pushEnabled != null) {\n                if (connection.isServer()) {\n                    throw connectionError(PROTOCOL_ERROR, \"Server sending SETTINGS frame with ENABLE_PUSH specified\");\n                }\n                connection.local().allowPushTo(pushEnabled);\n            }\n\n            Long maxConcurrentStreams = settings.maxConcurrentStreams();\n            if (maxConcurrentStreams != null) {\n                connection.remote().maxActiveStreams((int) min(maxConcurrentStreams, MAX_VALUE));\n            }\n\n            Long headerTableSize = settings.headerTableSize();\n            if (headerTableSize != null) {\n                headerConfig.maxHeaderTableSize(headerTableSize);\n            }\n\n            Long maxHeaderListSize = settings.maxHeaderListSize();\n            if (maxHeaderListSize != null) {\n                headerConfig.maxHeaderListSize(maxHeaderListSize, calculateMaxHeaderListSizeGoAway(maxHeaderListSize));\n            }\n\n            Integer maxFrameSize = settings.maxFrameSize();\n            if (maxFrameSize != null) {\n                frameSizePolicy.maxFrameSize(maxFrameSize);\n            }\n\n            Integer initialWindowSize = settings.initialWindowSize();\n            if (initialWindowSize != null) {\n                flowController().initialWindowSize(initialWindowSize);\n            }\n        }\n\n        @Override\n        public void onSettingsRead(final ChannelHandlerContext ctx, Http2Settings settings) throws Http2Exception {\n            if (settingsReceivedConsumer == null) {\n                // Acknowledge receipt of the settings. We should do this before we process the settings to ensure our\n                // remote peer applies these settings before any subsequent frames that we may send which depend upon\n                // these new settings. See https://github.com/netty/netty/issues/6520.\n                encoder.writeSettingsAck(ctx, ctx.newPromise());\n\n                encoder.remoteSettings(settings);\n            } else {\n                settingsReceivedConsumer.consumeReceivedSettings(settings);\n            }\n\n            listener.onSettingsRead(ctx, settings);\n        }\n\n        @Override\n        public void onPingRead(ChannelHandlerContext ctx, long data) throws Http2Exception {\n            if (autoAckPing) {\n                // Send an ack back to the remote client.\n                encoder.writePing(ctx, true, data, ctx.newPromise());\n            }\n            listener.onPingRead(ctx, data);\n        }\n\n        @Override\n        public void onPingAckRead(ChannelHandlerContext ctx, long data) throws Http2Exception {\n            listener.onPingAckRead(ctx, data);\n        }\n\n        @Override\n        public void onPushPromiseRead(ChannelHandlerContext ctx, int streamId, int promisedStreamId,\n                Http2Headers headers, int padding) throws Http2Exception {\n            // A client cannot push.\n            if (connection().isServer()) {\n                throw connectionError(PROTOCOL_ERROR, \"A client cannot push.\");\n            }\n\n            Http2Stream parentStream = connection.stream(streamId);\n\n            if (shouldIgnoreHeadersOrDataFrame(ctx, streamId, parentStream, \"PUSH_PROMISE\")) {\n                return;\n            }\n\n            switch (parentStream.state()) {\n              case OPEN:\n              case HALF_CLOSED_LOCAL:\n                  // Allowed to receive push promise in these states.\n                  break;\n              default:\n                  // Connection error.\n                  throw connectionError(PROTOCOL_ERROR,\n                      \"Stream %d in unexpected state for receiving push promise: %s\",\n                      parentStream.id(), parentStream.state());\n            }\n\n            if (!requestVerifier.isAuthoritative(ctx, headers)) {\n                throw streamError(promisedStreamId, PROTOCOL_ERROR,\n                        \"Promised request on stream %d for promised stream %d is not authoritative\",\n                        streamId, promisedStreamId);\n            }\n            if (!requestVerifier.isCacheable(headers)) {\n                throw streamError(promisedStreamId, PROTOCOL_ERROR,\n                        \"Promised request on stream %d for promised stream %d is not known to be cacheable\",\n                        streamId, promisedStreamId);\n            }\n            if (!requestVerifier.isSafe(headers)) {\n                throw streamError(promisedStreamId, PROTOCOL_ERROR,\n                        \"Promised request on stream %d for promised stream %d is not known to be safe\",\n                        streamId, promisedStreamId);\n            }\n\n            // Reserve the push stream based with a priority based on the current stream's priority.\n            connection.remote().reservePushStream(promisedStreamId, parentStream);\n\n            listener.onPushPromiseRead(ctx, streamId, promisedStreamId, headers, padding);\n        }\n\n        @Override\n        public void onGoAwayRead(ChannelHandlerContext ctx, int lastStreamId, long errorCode, ByteBuf debugData)\n                throws Http2Exception {\n            onGoAwayRead0(ctx, lastStreamId, errorCode, debugData);\n        }\n\n        @Override\n        public void onWindowUpdateRead(ChannelHandlerContext ctx, int streamId, int windowSizeIncrement)\n                throws Http2Exception {\n            Http2Stream stream = connection.stream(streamId);\n            if (stream == null || stream.state() == CLOSED || streamCreatedAfterGoAwaySent(streamId)) {\n                // Ignore this frame.\n                verifyStreamMayHaveExisted(streamId);\n                return;\n            }\n\n            // Update the outbound flow control window.\n            encoder.flowController().incrementWindowSize(stream, windowSizeIncrement);\n\n            listener.onWindowUpdateRead(ctx, streamId, windowSizeIncrement);\n        }\n\n        @Override\n        public void onUnknownFrame(ChannelHandlerContext ctx, byte frameType, int streamId, Http2Flags flags,\n                ByteBuf payload) throws Http2Exception {\n            onUnknownFrame0(ctx, frameType, streamId, flags, payload);\n        }\n\n        /**\n         * Helper method to determine if a frame that has the semantics of headers or data should be ignored for the\n         * {@code stream} (which may be {@code null}) associated with {@code streamId}.\n         */\n        private boolean shouldIgnoreHeadersOrDataFrame(ChannelHandlerContext ctx, int streamId, Http2Stream stream,\n                String frameName) throws Http2Exception {\n            if (stream == null) {\n                if (streamCreatedAfterGoAwaySent(streamId)) {\n                    logger.info(\"{} ignoring {} frame for stream {}. Stream sent after GOAWAY sent\",\n                            ctx.channel(), frameName, streamId);\n                    return true;\n                }\n\n                // Make sure it's not an out-of-order frame, like a rogue DATA frame, for a stream that could\n                // never have existed.\n                verifyStreamMayHaveExisted(streamId);\n\n                // Its possible that this frame would result in stream ID out of order creation (PROTOCOL ERROR) and its\n                // also possible that this frame is received on a CLOSED stream (STREAM_CLOSED after a RST_STREAM is\n                // sent). We don't have enough information to know for sure, so we choose the lesser of the two errors.\n                throw streamError(streamId, STREAM_CLOSED, \"Received %s frame for an unknown stream %d\",\n                                  frameName, streamId);\n            } else if (stream.isResetSent() || streamCreatedAfterGoAwaySent(streamId)) {\n                // If we have sent a reset stream it is assumed the stream will be closed after the write completes.\n                // If we have not sent a reset, but the stream was created after a GoAway this is not supported by\n                // DefaultHttp2Connection and if a custom Http2Connection is used it is assumed the lifetime is managed\n                // elsewhere so we don't close the stream or otherwise modify the stream's state.\n\n                if (logger.isInfoEnabled()) {\n                    logger.info(\"{} ignoring {} frame for stream {}\", ctx.channel(), frameName,\n                            stream.isResetSent() ? \"RST_STREAM sent.\" :\n                                (\"Stream created after GOAWAY sent. Last known stream by peer \" +\n                                 connection.remote().lastStreamKnownByPeer()));\n                }\n\n                return true;\n            }\n            return false;\n        }\n\n        /**\n         * Helper method for determining whether or not to ignore inbound frames. A stream is considered to be created\n         * after a {@code GOAWAY} is sent if the following conditions hold:\n         * <p/>\n         * <ul>\n         *     <li>A {@code GOAWAY} must have been sent by the local endpoint</li>\n         *     <li>The {@code streamId} must identify a legitimate stream id for the remote endpoint to be creating</li>\n         *     <li>{@code streamId} is greater than the Last Known Stream ID which was sent by the local endpoint\n         *     in the last {@code GOAWAY} frame</li>\n         * </ul>\n         * <p/>\n         */\n        private boolean streamCreatedAfterGoAwaySent(int streamId) {\n            Endpoint<?> remote = connection.remote();\n            return connection.goAwaySent() && remote.isValidStreamId(streamId) &&\n                    streamId > remote.lastStreamKnownByPeer();\n        }\n\n        private void verifyStreamMayHaveExisted(int streamId) throws Http2Exception {\n            if (!connection.streamMayHaveExisted(streamId)) {\n                throw connectionError(PROTOCOL_ERROR, \"Stream %d does not exist\", streamId);\n            }\n        }\n    }\n\n    private final class PrefaceFrameListener implements Http2FrameListener {\n        /**\n         * Verifies that the HTTP/2 connection preface has been received from the remote endpoint.\n         * It is possible that the current call to\n         * {@link Http2FrameReader#readFrame(ChannelHandlerContext, ByteBuf, Http2FrameListener)} will have multiple\n         * frames to dispatch. So it may be OK for this class to get legitimate frames for the first readFrame.\n         */\n        private void verifyPrefaceReceived() throws Http2Exception {\n            if (!prefaceReceived()) {\n                throw connectionError(PROTOCOL_ERROR, \"Received non-SETTINGS as first frame.\");\n            }\n        }\n\n        @Override\n        public int onDataRead(ChannelHandlerContext ctx, int streamId, ByteBuf data, int padding, boolean endOfStream)\n                throws Http2Exception {\n            verifyPrefaceReceived();\n            return internalFrameListener.onDataRead(ctx, streamId, data, padding, endOfStream);\n        }\n\n        @Override\n        public void onHeadersRead(ChannelHandlerContext ctx, int streamId, Http2Headers headers, int padding,\n                boolean endOfStream) throws Http2Exception {\n            verifyPrefaceReceived();\n            internalFrameListener.onHeadersRead(ctx, streamId, headers, padding, endOfStream);\n        }\n\n        @Override\n        public void onHeadersRead(ChannelHandlerContext ctx, int streamId, Http2Headers headers, int streamDependency,\n                short weight, boolean exclusive, int padding, boolean endOfStream) throws Http2Exception {\n            verifyPrefaceReceived();\n            internalFrameListener.onHeadersRead(ctx, streamId, headers, streamDependency, weight,\n                    exclusive, padding, endOfStream);\n        }\n\n        @Override\n        public void onPriorityRead(ChannelHandlerContext ctx, int streamId, int streamDependency, short weight,\n                boolean exclusive) throws Http2Exception {\n            verifyPrefaceReceived();\n            internalFrameListener.onPriorityRead(ctx, streamId, streamDependency, weight, exclusive);\n        }\n\n        @Override\n        public void onRstStreamRead(ChannelHandlerContext ctx, int streamId, long errorCode) throws Http2Exception {\n            verifyPrefaceReceived();\n            internalFrameListener.onRstStreamRead(ctx, streamId, errorCode);\n        }\n\n        @Override\n        public void onSettingsAckRead(ChannelHandlerContext ctx) throws Http2Exception {\n            verifyPrefaceReceived();\n            internalFrameListener.onSettingsAckRead(ctx);\n        }\n\n        @Override\n        public void onSettingsRead(ChannelHandlerContext ctx, Http2Settings settings) throws Http2Exception {\n            // The first settings should change the internalFrameListener to the \"real\" listener\n            // that expects the preface to be verified.\n            if (!prefaceReceived()) {\n                internalFrameListener = new FrameReadListener();\n            }\n            internalFrameListener.onSettingsRead(ctx, settings);\n        }\n\n        @Override\n        public void onPingRead(ChannelHandlerContext ctx, long data) throws Http2Exception {\n            verifyPrefaceReceived();\n            internalFrameListener.onPingRead(ctx, data);\n        }\n\n        @Override\n        public void onPingAckRead(ChannelHandlerContext ctx, long data) throws Http2Exception {\n            verifyPrefaceReceived();\n            internalFrameListener.onPingAckRead(ctx, data);\n        }\n\n        @Override\n        public void onPushPromiseRead(ChannelHandlerContext ctx, int streamId, int promisedStreamId,\n                Http2Headers headers, int padding) throws Http2Exception {\n            verifyPrefaceReceived();\n            internalFrameListener.onPushPromiseRead(ctx, streamId, promisedStreamId, headers, padding);\n        }\n\n        @Override\n        public void onGoAwayRead(ChannelHandlerContext ctx, int lastStreamId, long errorCode, ByteBuf debugData)\n                throws Http2Exception {\n            onGoAwayRead0(ctx, lastStreamId, errorCode, debugData);\n        }\n\n        @Override\n        public void onWindowUpdateRead(ChannelHandlerContext ctx, int streamId, int windowSizeIncrement)\n                throws Http2Exception {\n            verifyPrefaceReceived();\n            internalFrameListener.onWindowUpdateRead(ctx, streamId, windowSizeIncrement);\n        }\n\n        @Override\n        public void onUnknownFrame(ChannelHandlerContext ctx, byte frameType, int streamId, Http2Flags flags,\n                ByteBuf payload) throws Http2Exception {\n            onUnknownFrame0(ctx, frameType, streamId, flags, payload);\n        }\n    }\n\n    private static final class ContentLength {\n        private final long expected;\n        private long seen;\n\n        ContentLength(long expected) {\n            this.expected = expected;\n        }\n\n        void increaseReceivedBytes(boolean server, int streamId, int bytes, boolean isEnd) throws Http2Exception {\n            seen += bytes;\n            // Check for overflow\n            if (seen < 0) {\n                throw streamError(streamId, PROTOCOL_ERROR,\n                        \"Received amount of data did overflow and so not match content-length header %d\", expected);\n            }\n            // Check if we received more data then what was advertised via the content-length header.\n            if (seen > expected) {\n                throw streamError(streamId, PROTOCOL_ERROR,\n                        \"Received amount of data %d does not match content-length header %d\", seen, expected);\n            }\n\n            if (isEnd) {\n                if (seen == 0 && !server) {\n                    // This may be a response to a HEAD request, let's just allow it.\n                    return;\n                }\n\n                // Check that we really saw what was told via the content-length header.\n                if (expected > seen) {\n                    throw streamError(streamId, PROTOCOL_ERROR,\n                            \"Received amount of data %d does not match content-length header %d\", seen, expected);\n                }\n            }\n        }\n    }\n}\n", "/*\n * Copyright 2014 The Netty Project\n *\n * The Netty Project licenses this file to you under the Apache License, version 2.0 (the\n * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n * copy of the License at:\n *\n * https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under the License\n * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n * or implied. See the License for the specific language governing permissions and limitations under\n * the License.\n */\npackage io.netty.handler.codec.http2;\n\nimport io.netty.buffer.ByteBuf;\nimport io.netty.buffer.UnpooledByteBufAllocator;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelHandlerContext;\nimport io.netty.channel.ChannelPromise;\nimport io.netty.channel.DefaultChannelPromise;\nimport io.netty.handler.codec.http.HttpHeaderNames;\nimport io.netty.handler.codec.http.HttpResponseStatus;\nimport junit.framework.AssertionFailedError;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.mockito.ArgumentCaptor;\nimport org.mockito.ArgumentMatchers;\nimport org.mockito.Mock;\nimport org.mockito.MockitoAnnotations;\nimport org.mockito.invocation.InvocationOnMock;\nimport org.mockito.stubbing.Answer;\n\nimport java.util.Collections;\nimport java.util.IdentityHashMap;\nimport java.util.Map;\nimport java.util.concurrent.atomic.AtomicInteger;\n\nimport static io.netty.buffer.Unpooled.EMPTY_BUFFER;\nimport static io.netty.buffer.Unpooled.wrappedBuffer;\nimport static io.netty.handler.codec.http2.Http2CodecUtil.DEFAULT_PRIORITY_WEIGHT;\nimport static io.netty.handler.codec.http2.Http2Error.PROTOCOL_ERROR;\nimport static io.netty.handler.codec.http2.Http2Stream.State.IDLE;\nimport static io.netty.handler.codec.http2.Http2Stream.State.OPEN;\nimport static io.netty.handler.codec.http2.Http2Stream.State.RESERVED_REMOTE;\nimport static io.netty.util.CharsetUtil.UTF_8;\n\nimport static org.hamcrest.MatcherAssert.assertThat;\nimport static org.hamcrest.Matchers.instanceOf;\nimport static org.hamcrest.Matchers.not;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertTrue;\nimport static org.junit.Assert.fail;\nimport static org.mockito.Mockito.any;\nimport static org.mockito.Mockito.anyBoolean;\nimport static org.mockito.Mockito.anyInt;\nimport static org.mockito.Mockito.anyLong;\nimport static org.mockito.Mockito.anyShort;\nimport static org.mockito.Mockito.doAnswer;\nimport static org.mockito.Mockito.doNothing;\nimport static org.mockito.Mockito.eq;\nimport static org.mockito.Mockito.isNull;\nimport static org.mockito.Mockito.never;\nimport static org.mockito.Mockito.times;\nimport static org.mockito.Mockito.verify;\nimport static org.mockito.Mockito.verifyNoMoreInteractions;\nimport static org.mockito.Mockito.when;\n\n/**\n * Tests for {@link DefaultHttp2ConnectionDecoder}.\n */\npublic class DefaultHttp2ConnectionDecoderTest {\n    private static final int STREAM_ID = 3;\n    private static final int PUSH_STREAM_ID = 2;\n    private static final int STREAM_DEPENDENCY_ID = 5;\n    private static final int STATE_RECV_HEADERS = 1;\n    private static final int STATE_RECV_TRAILERS = 1 << 1;\n\n    private Http2ConnectionDecoder decoder;\n    private ChannelPromise promise;\n\n    @Mock\n    private Http2Connection connection;\n\n    @Mock\n    private Http2Connection.Endpoint<Http2RemoteFlowController> remote;\n\n    @Mock\n    private Http2Connection.Endpoint<Http2LocalFlowController> local;\n\n    @Mock\n    private Http2LocalFlowController localFlow;\n\n    @Mock\n    private Http2RemoteFlowController remoteFlow;\n\n    @Mock\n    private ChannelHandlerContext ctx;\n\n    @Mock\n    private Channel channel;\n\n    @Mock\n    private ChannelFuture future;\n\n    @Mock\n    private Http2Stream stream;\n\n    @Mock\n    private Http2Stream pushStream;\n\n    @Mock\n    private Http2FrameListener listener;\n\n    @Mock\n    private Http2FrameReader reader;\n\n    @Mock\n    private Http2FrameWriter writer;\n\n    @Mock\n    private Http2ConnectionEncoder encoder;\n\n    @Mock\n    private Http2LifecycleManager lifecycleManager;\n\n    @Before\n    public void setup() throws Exception {\n        MockitoAnnotations.initMocks(this);\n\n        promise = new DefaultChannelPromise(channel);\n\n        final AtomicInteger headersReceivedState = new AtomicInteger();\n        when(channel.isActive()).thenReturn(true);\n        when(stream.id()).thenReturn(STREAM_ID);\n        when(stream.state()).thenReturn(OPEN);\n        when(stream.open(anyBoolean())).thenReturn(stream);\n\n        final Map<Object, Object> properties = new IdentityHashMap<Object, Object>();\n        when(stream.getProperty(ArgumentMatchers.<Http2Connection.PropertyKey>any())).thenAnswer(new Answer<Object>() {\n            @Override\n            public Object answer(InvocationOnMock invocationOnMock) {\n                return properties.get(invocationOnMock.getArgument(0));\n            }\n        });\n        when(stream.setProperty(ArgumentMatchers.<Http2Connection.PropertyKey>any(), any())).then(new Answer<Object>() {\n            @Override\n            public Object answer(InvocationOnMock invocationOnMock) {\n                return properties.put(invocationOnMock.getArgument(0), invocationOnMock.getArgument(1));\n            }\n        });\n\n        when(pushStream.id()).thenReturn(PUSH_STREAM_ID);\n        doAnswer(new Answer<Boolean>() {\n            @Override\n            public Boolean answer(InvocationOnMock in) throws Throwable {\n                return (headersReceivedState.get() & STATE_RECV_HEADERS) != 0;\n            }\n        }).when(stream).isHeadersReceived();\n        doAnswer(new Answer<Boolean>() {\n            @Override\n            public Boolean answer(InvocationOnMock in) throws Throwable {\n                return (headersReceivedState.get() & STATE_RECV_TRAILERS) != 0;\n            }\n        }).when(stream).isTrailersReceived();\n        doAnswer(new Answer<Http2Stream>() {\n            @Override\n            public Http2Stream answer(InvocationOnMock in) throws Throwable {\n                boolean isInformational = in.getArgument(0);\n                if (isInformational) {\n                    return stream;\n                }\n                for (;;) {\n                    int current = headersReceivedState.get();\n                    int next = current;\n                    if ((current & STATE_RECV_HEADERS) != 0) {\n                        if ((current & STATE_RECV_TRAILERS) != 0) {\n                            throw new IllegalStateException(\"already sent headers!\");\n                        }\n                        next |= STATE_RECV_TRAILERS;\n                    } else {\n                        next |= STATE_RECV_HEADERS;\n                    }\n                    if (headersReceivedState.compareAndSet(current, next)) {\n                        break;\n                    }\n                }\n                return stream;\n            }\n        }).when(stream).headersReceived(anyBoolean());\n        doAnswer(new Answer<Http2Stream>() {\n            @Override\n            public Http2Stream answer(InvocationOnMock in) throws Throwable {\n                Http2StreamVisitor visitor = in.getArgument(0);\n                if (!visitor.visit(stream)) {\n                    return stream;\n                }\n                return null;\n            }\n        }).when(connection).forEachActiveStream(any(Http2StreamVisitor.class));\n        when(connection.stream(STREAM_ID)).thenReturn(stream);\n        when(connection.streamMayHaveExisted(STREAM_ID)).thenReturn(true);\n        when(connection.local()).thenReturn(local);\n        when(local.flowController()).thenReturn(localFlow);\n        when(encoder.flowController()).thenReturn(remoteFlow);\n        when(encoder.frameWriter()).thenReturn(writer);\n        when(connection.remote()).thenReturn(remote);\n        when(local.reservePushStream(eq(PUSH_STREAM_ID), eq(stream))).thenReturn(pushStream);\n        when(remote.reservePushStream(eq(PUSH_STREAM_ID), eq(stream))).thenReturn(pushStream);\n        when(ctx.alloc()).thenReturn(UnpooledByteBufAllocator.DEFAULT);\n        when(ctx.channel()).thenReturn(channel);\n        when(ctx.newSucceededFuture()).thenReturn(future);\n        when(ctx.newPromise()).thenReturn(promise);\n        when(ctx.write(any())).thenReturn(future);\n\n        decoder = new DefaultHttp2ConnectionDecoder(connection, encoder, reader);\n        decoder.lifecycleManager(lifecycleManager);\n        decoder.frameListener(listener);\n\n        // Simulate receiving the initial settings from the remote endpoint.\n        decode().onSettingsRead(ctx, new Http2Settings());\n        verify(listener).onSettingsRead(eq(ctx), eq(new Http2Settings()));\n        assertTrue(decoder.prefaceReceived());\n        verify(encoder).writeSettingsAck(eq(ctx), eq(promise));\n\n        // Simulate receiving the SETTINGS ACK for the initial settings.\n        decode().onSettingsAckRead(ctx);\n\n        // Disallow any further flushes now that settings ACK has been sent\n        when(ctx.flush()).thenThrow(new AssertionFailedError(\"forbidden\"));\n    }\n\n    @Test\n    public void dataReadAfterGoAwaySentShouldApplyFlowControl() throws Exception {\n        mockGoAwaySent();\n\n        final ByteBuf data = dummyData();\n        int padding = 10;\n        int processedBytes = data.readableBytes() + padding;\n        mockFlowControl(processedBytes);\n        try {\n            decode().onDataRead(ctx, STREAM_ID, data, padding, true);\n            verify(localFlow).receiveFlowControlledFrame(eq(stream), eq(data), eq(padding), eq(true));\n            verify(localFlow).consumeBytes(eq(stream), eq(processedBytes));\n\n            // Verify that the event was absorbed and not propagated to the observer.\n            verify(listener, never()).onDataRead(eq(ctx), anyInt(), any(ByteBuf.class), anyInt(), anyBoolean());\n        } finally {\n            data.release();\n        }\n    }\n\n    @Test\n    public void dataReadAfterGoAwaySentShouldAllowFramesForStreamCreatedByLocalEndpoint() throws Exception {\n        mockGoAwaySentShouldAllowFramesForStreamCreatedByLocalEndpoint();\n\n        final ByteBuf data = dummyData();\n        int padding = 10;\n        int processedBytes = data.readableBytes() + padding;\n        mockFlowControl(processedBytes);\n        try {\n            decode().onDataRead(ctx, STREAM_ID, data, padding, true);\n            verify(localFlow).receiveFlowControlledFrame(eq(stream), eq(data), eq(padding), eq(true));\n            verify(localFlow).consumeBytes(eq(stream), eq(processedBytes));\n\n            // Verify that the event was absorbed and not propagated to the observer.\n            verify(listener).onDataRead(eq(ctx), anyInt(), any(ByteBuf.class), anyInt(), anyBoolean());\n        } finally {\n            data.release();\n        }\n    }\n\n    @Test(expected = Http2Exception.StreamException.class)\n    public void dataReadForUnknownStreamShouldApplyFlowControlAndFail() throws Exception {\n        when(connection.streamMayHaveExisted(STREAM_ID)).thenReturn(true);\n        when(connection.stream(STREAM_ID)).thenReturn(null);\n        final ByteBuf data = dummyData();\n        int padding = 10;\n        int processedBytes = data.readableBytes() + padding;\n        try {\n            decode().onDataRead(ctx, STREAM_ID, data, padding, true);\n        } finally {\n            try {\n                verify(localFlow)\n                        .receiveFlowControlledFrame(eq((Http2Stream) null), eq(data), eq(padding), eq(true));\n                verify(localFlow).consumeBytes(eq((Http2Stream) null), eq(processedBytes));\n                verify(localFlow).frameWriter(any(Http2FrameWriter.class));\n                verifyNoMoreInteractions(localFlow);\n                verify(listener, never()).onDataRead(eq(ctx), anyInt(), any(ByteBuf.class), anyInt(), anyBoolean());\n            } finally {\n                data.release();\n            }\n        }\n    }\n\n    @Test(expected = Http2Exception.class)\n    public void dataReadForUnknownStreamThatCouldntExistFail() throws Exception {\n        when(connection.streamMayHaveExisted(STREAM_ID)).thenReturn(false);\n        when(connection.stream(STREAM_ID)).thenReturn(null);\n        final ByteBuf data = dummyData();\n        int padding = 10;\n        int processedBytes = data.readableBytes() + padding;\n        try {\n            decode().onDataRead(ctx, STREAM_ID, data, padding, true);\n        } catch (Http2Exception ex) {\n            assertThat(ex, not(instanceOf(Http2Exception.StreamException.class)));\n            throw ex;\n        } finally {\n            try {\n                verify(localFlow)\n                    .receiveFlowControlledFrame(eq((Http2Stream) null), eq(data), eq(padding), eq(true));\n                verify(localFlow).consumeBytes(eq((Http2Stream) null), eq(processedBytes));\n                verify(localFlow).frameWriter(any(Http2FrameWriter.class));\n                verifyNoMoreInteractions(localFlow);\n                verify(listener, never()).onDataRead(eq(ctx), anyInt(), any(ByteBuf.class), anyInt(), anyBoolean());\n            } finally {\n                data.release();\n            }\n        }\n    }\n\n    @Test\n    public void dataReadForUnknownStreamShouldApplyFlowControl() throws Exception {\n        when(connection.stream(STREAM_ID)).thenReturn(null);\n        final ByteBuf data = dummyData();\n        int padding = 10;\n        int processedBytes = data.readableBytes() + padding;\n        try {\n            try {\n                decode().onDataRead(ctx, STREAM_ID, data, padding, true);\n                fail();\n            } catch (Http2Exception e) {\n                verify(localFlow)\n                        .receiveFlowControlledFrame(eq((Http2Stream) null), eq(data), eq(padding), eq(true));\n                verify(localFlow).consumeBytes(eq((Http2Stream) null), eq(processedBytes));\n                verify(localFlow).frameWriter(any(Http2FrameWriter.class));\n                verifyNoMoreInteractions(localFlow);\n\n                // Verify that the event was absorbed and not propagated to the observer.\n                verify(listener, never()).onDataRead(eq(ctx), anyInt(), any(ByteBuf.class), anyInt(), anyBoolean());\n            }\n        } finally {\n            data.release();\n        }\n    }\n\n    @Test\n    public void emptyDataFrameShouldApplyFlowControl() throws Exception {\n        final ByteBuf data = EMPTY_BUFFER;\n        int padding = 0;\n        mockFlowControl(0);\n        try {\n            decode().onDataRead(ctx, STREAM_ID, data, padding, true);\n            verify(localFlow).receiveFlowControlledFrame(eq(stream), eq(data), eq(padding), eq(true));\n\n            // Now we ignore the empty bytes inside consumeBytes method, so it will be called once.\n            verify(localFlow).consumeBytes(eq(stream), eq(0));\n\n            // Verify that the empty data event was propagated to the observer.\n            verify(listener).onDataRead(eq(ctx), eq(STREAM_ID), eq(data), eq(padding), eq(true));\n        } finally {\n            data.release();\n        }\n    }\n\n    @Test(expected = Http2Exception.class)\n    public void dataReadForStreamInInvalidStateShouldThrow() throws Exception {\n        // Throw an exception when checking stream state.\n        when(stream.state()).thenReturn(Http2Stream.State.CLOSED);\n        final ByteBuf data = dummyData();\n        try {\n            decode().onDataRead(ctx, STREAM_ID, data, 10, true);\n        } finally {\n            data.release();\n        }\n    }\n\n    @Test\n    public void dataReadAfterGoAwaySentForStreamInInvalidStateShouldIgnore() throws Exception {\n        // Throw an exception when checking stream state.\n        when(stream.state()).thenReturn(Http2Stream.State.CLOSED);\n        mockGoAwaySent();\n        final ByteBuf data = dummyData();\n        try {\n            decode().onDataRead(ctx, STREAM_ID, data, 10, true);\n            verify(localFlow).receiveFlowControlledFrame(eq(stream), eq(data), eq(10), eq(true));\n            verify(listener, never()).onDataRead(eq(ctx), anyInt(), any(ByteBuf.class), anyInt(), anyBoolean());\n        } finally {\n            data.release();\n        }\n    }\n\n    @Test\n    public void dataReadAfterGoAwaySentOnUnknownStreamShouldIgnore() throws Exception {\n        // Throw an exception when checking stream state.\n        when(connection.stream(STREAM_ID)).thenReturn(null);\n        mockGoAwaySent();\n        final ByteBuf data = dummyData();\n        try {\n            decode().onDataRead(ctx, STREAM_ID, data, 10, true);\n            verify(localFlow).receiveFlowControlledFrame((Http2Stream) isNull(), eq(data), eq(10), eq(true));\n            verify(listener, never()).onDataRead(eq(ctx), anyInt(), any(ByteBuf.class), anyInt(), anyBoolean());\n        } finally {\n            data.release();\n        }\n    }\n\n    @Test\n    public void dataReadAfterRstStreamForStreamInInvalidStateShouldIgnore() throws Exception {\n        // Throw an exception when checking stream state.\n        when(stream.state()).thenReturn(Http2Stream.State.CLOSED);\n        when(stream.isResetSent()).thenReturn(true);\n        final ByteBuf data = dummyData();\n        try {\n            decode().onDataRead(ctx, STREAM_ID, data, 10, true);\n            verify(localFlow).receiveFlowControlledFrame(eq(stream), eq(data), eq(10), eq(true));\n            verify(listener, never()).onDataRead(eq(ctx), anyInt(), any(ByteBuf.class), anyInt(), anyBoolean());\n        } finally {\n            data.release();\n        }\n    }\n\n    @Test\n    public void dataReadWithEndOfStreamShouldcloseStreamRemote() throws Exception {\n        final ByteBuf data = dummyData();\n        try {\n            decode().onDataRead(ctx, STREAM_ID, data, 10, true);\n            verify(localFlow).receiveFlowControlledFrame(eq(stream), eq(data), eq(10), eq(true));\n            verify(lifecycleManager).closeStreamRemote(eq(stream), eq(future));\n            verify(listener).onDataRead(eq(ctx), eq(STREAM_ID), eq(data), eq(10), eq(true));\n        } finally {\n            data.release();\n        }\n    }\n\n    @Test\n    public void errorDuringDeliveryShouldReturnCorrectNumberOfBytes() throws Exception {\n        final ByteBuf data = dummyData();\n        final int padding = 10;\n        final AtomicInteger unprocessed = new AtomicInteger(data.readableBytes() + padding);\n        doAnswer(new Answer<Integer>() {\n            @Override\n            public Integer answer(InvocationOnMock in) throws Throwable {\n                return unprocessed.get();\n            }\n        }).when(localFlow).unconsumedBytes(eq(stream));\n        doAnswer(new Answer<Void>() {\n            @Override\n            public Void answer(InvocationOnMock in) throws Throwable {\n                int delta = (Integer) in.getArguments()[1];\n                int newValue = unprocessed.addAndGet(-delta);\n                if (newValue < 0) {\n                    throw new RuntimeException(\"Returned too many bytes\");\n                }\n                return null;\n            }\n        }).when(localFlow).consumeBytes(eq(stream), anyInt());\n        // When the listener callback is called, process a few bytes and then throw.\n        doAnswer(new Answer<Integer>() {\n            @Override\n            public Integer answer(InvocationOnMock in) throws Throwable {\n                localFlow.consumeBytes(stream, 4);\n                throw new RuntimeException(\"Fake Exception\");\n            }\n        }).when(listener).onDataRead(eq(ctx), eq(STREAM_ID), any(ByteBuf.class), eq(10), eq(true));\n        try {\n            decode().onDataRead(ctx, STREAM_ID, data, padding, true);\n            fail(\"Expected exception\");\n        } catch (RuntimeException cause) {\n            verify(localFlow)\n                    .receiveFlowControlledFrame(eq(stream), eq(data), eq(padding), eq(true));\n            verify(lifecycleManager).closeStreamRemote(eq(stream), eq(future));\n            verify(listener).onDataRead(eq(ctx), eq(STREAM_ID), eq(data), eq(padding), eq(true));\n            assertEquals(0, localFlow.unconsumedBytes(stream));\n        } finally {\n            data.release();\n        }\n    }\n\n    @Test(expected = Http2Exception.class)\n    public void headersReadForUnknownStreamShouldThrow() throws Exception {\n        when(connection.stream(STREAM_ID)).thenReturn(null);\n        decode().onHeadersRead(ctx, STREAM_ID, EmptyHttp2Headers.INSTANCE, 0, false);\n    }\n\n    @Test\n    public void headersReadForStreamThatAlreadySentResetShouldBeIgnored() throws Exception {\n        when(stream.isResetSent()).thenReturn(true);\n        decode().onHeadersRead(ctx, STREAM_ID, EmptyHttp2Headers.INSTANCE, 0, false);\n        verify(remote, never()).createStream(anyInt(), anyBoolean());\n        verify(stream, never()).open(anyBoolean());\n\n        // Verify that the event was absorbed and not propagated to the observer.\n        verify(listener, never()).onHeadersRead(eq(ctx), anyInt(), any(Http2Headers.class), anyInt(), anyBoolean());\n        verify(remote, never()).createStream(anyInt(), anyBoolean());\n        verify(stream, never()).open(anyBoolean());\n    }\n\n    @Test\n    public void headersReadForUnknownStreamAfterGoAwayShouldBeIgnored() throws Exception {\n        mockGoAwaySent();\n        when(connection.stream(STREAM_ID)).thenReturn(null);\n        decode().onHeadersRead(ctx, STREAM_ID, EmptyHttp2Headers.INSTANCE, 0, false);\n        verify(remote, never()).createStream(anyInt(), anyBoolean());\n        verify(stream, never()).open(anyBoolean());\n\n        // Verify that the event was absorbed and not propagated to the observer.\n        verify(listener, never()).onHeadersRead(eq(ctx), anyInt(), any(Http2Headers.class), anyInt(), anyBoolean());\n        verify(remote, never()).createStream(anyInt(), anyBoolean());\n        verify(stream, never()).open(anyBoolean());\n    }\n\n    @Test\n    public void headersReadForUnknownStreamShouldCreateStream() throws Exception {\n        final int streamId = 5;\n        when(remote.createStream(eq(streamId), anyBoolean())).thenReturn(stream);\n        decode().onHeadersRead(ctx, streamId, EmptyHttp2Headers.INSTANCE, 0, false);\n        verify(remote).createStream(eq(streamId), eq(false));\n        verify(listener).onHeadersRead(eq(ctx), eq(streamId), eq(EmptyHttp2Headers.INSTANCE), eq(0),\n                eq(DEFAULT_PRIORITY_WEIGHT), eq(false), eq(0), eq(false));\n    }\n\n    @Test\n    public void headersReadForUnknownStreamShouldCreateHalfClosedStream() throws Exception {\n        final int streamId = 5;\n        when(remote.createStream(eq(streamId), anyBoolean())).thenReturn(stream);\n        decode().onHeadersRead(ctx, streamId, EmptyHttp2Headers.INSTANCE, 0, true);\n        verify(remote).createStream(eq(streamId), eq(true));\n        verify(listener).onHeadersRead(eq(ctx), eq(streamId), eq(EmptyHttp2Headers.INSTANCE), eq(0),\n                eq(DEFAULT_PRIORITY_WEIGHT), eq(false), eq(0), eq(true));\n    }\n\n    @Test\n    public void headersReadForPromisedStreamShouldHalfOpenStream() throws Exception {\n        when(stream.state()).thenReturn(RESERVED_REMOTE);\n        decode().onHeadersRead(ctx, STREAM_ID, EmptyHttp2Headers.INSTANCE, 0, false);\n        verify(stream).open(false);\n        verify(listener).onHeadersRead(eq(ctx), eq(STREAM_ID), eq(EmptyHttp2Headers.INSTANCE), eq(0),\n                eq(DEFAULT_PRIORITY_WEIGHT), eq(false), eq(0), eq(false));\n    }\n\n    @Test(expected = Http2Exception.class)\n    public void trailersDoNotEndStreamThrows() throws Exception {\n        decode().onHeadersRead(ctx, STREAM_ID, EmptyHttp2Headers.INSTANCE, 0, false);\n        // Trailers must end the stream!\n        decode().onHeadersRead(ctx, STREAM_ID, EmptyHttp2Headers.INSTANCE, 0, false);\n    }\n\n    @Test(expected = Http2Exception.class)\n    public void tooManyHeadersEOSThrows() throws Exception {\n        tooManyHeaderThrows(true);\n    }\n\n    @Test(expected = Http2Exception.class)\n    public void tooManyHeadersNoEOSThrows() throws Exception {\n        tooManyHeaderThrows(false);\n    }\n\n    private void tooManyHeaderThrows(boolean eos) throws Exception {\n        decode().onHeadersRead(ctx, STREAM_ID, EmptyHttp2Headers.INSTANCE, 0, false);\n        decode().onHeadersRead(ctx, STREAM_ID, EmptyHttp2Headers.INSTANCE, 0, true);\n        // We already received the trailers!\n        decode().onHeadersRead(ctx, STREAM_ID, EmptyHttp2Headers.INSTANCE, 0, eos);\n    }\n\n    private static Http2Headers informationalHeaders() {\n        Http2Headers headers = new DefaultHttp2Headers();\n        headers.status(HttpResponseStatus.CONTINUE.codeAsText());\n        return headers;\n    }\n\n    @Test\n    public void infoHeadersAndTrailersAllowed() throws Exception {\n        infoHeadersAndTrailersAllowed(true, 1);\n    }\n\n    @Test\n    public void multipleInfoHeadersAndTrailersAllowed() throws Exception {\n        infoHeadersAndTrailersAllowed(true, 10);\n    }\n\n    @Test(expected = Http2Exception.class)\n    public void infoHeadersAndTrailersNoEOSThrows() throws Exception {\n        infoHeadersAndTrailersAllowed(false, 1);\n    }\n\n    @Test(expected = Http2Exception.class)\n    public void multipleInfoHeadersAndTrailersNoEOSThrows() throws Exception {\n        infoHeadersAndTrailersAllowed(false, 10);\n    }\n\n    private void infoHeadersAndTrailersAllowed(boolean eos, int infoHeaderCount) throws Exception {\n        for (int i = 0; i < infoHeaderCount; ++i) {\n            decode().onHeadersRead(ctx, STREAM_ID, informationalHeaders(), 0, false);\n        }\n        decode().onHeadersRead(ctx, STREAM_ID, EmptyHttp2Headers.INSTANCE, 0, false);\n        decode().onHeadersRead(ctx, STREAM_ID, EmptyHttp2Headers.INSTANCE, 0, eos);\n    }\n\n    @Test()\n    public void headersReadForPromisedStreamShouldCloseStream() throws Exception {\n        when(stream.state()).thenReturn(RESERVED_REMOTE);\n        decode().onHeadersRead(ctx, STREAM_ID, EmptyHttp2Headers.INSTANCE, 0, true);\n        verify(stream).open(true);\n        verify(lifecycleManager).closeStreamRemote(eq(stream), eq(future));\n        verify(listener).onHeadersRead(eq(ctx), eq(STREAM_ID), eq(EmptyHttp2Headers.INSTANCE), eq(0),\n                eq(DEFAULT_PRIORITY_WEIGHT), eq(false), eq(0), eq(true));\n    }\n\n    @Test\n    public void headersDependencyNotCreatedShouldCreateAndSucceed() throws Exception {\n        final short weight = 1;\n        decode().onHeadersRead(ctx, STREAM_ID, EmptyHttp2Headers.INSTANCE, STREAM_DEPENDENCY_ID,\n                weight, true, 0, true);\n        verify(listener).onHeadersRead(eq(ctx), eq(STREAM_ID), eq(EmptyHttp2Headers.INSTANCE), eq(STREAM_DEPENDENCY_ID),\n                eq(weight), eq(true), eq(0), eq(true));\n        verify(remoteFlow).updateDependencyTree(eq(STREAM_ID), eq(STREAM_DEPENDENCY_ID), eq(weight), eq(true));\n        verify(lifecycleManager).closeStreamRemote(eq(stream), any(ChannelFuture.class));\n    }\n\n    @Test\n    public void pushPromiseReadAfterGoAwaySentShouldBeIgnored() throws Exception {\n        mockGoAwaySent();\n        decode().onPushPromiseRead(ctx, STREAM_ID, PUSH_STREAM_ID, EmptyHttp2Headers.INSTANCE, 0);\n        verify(remote, never()).reservePushStream(anyInt(), any(Http2Stream.class));\n        verify(listener, never()).onPushPromiseRead(eq(ctx), anyInt(), anyInt(), any(Http2Headers.class), anyInt());\n    }\n\n    @Test\n    public void pushPromiseReadAfterGoAwayShouldAllowFramesForStreamCreatedByLocalEndpoint() throws Exception {\n        mockGoAwaySentShouldAllowFramesForStreamCreatedByLocalEndpoint();\n        decode().onPushPromiseRead(ctx, STREAM_ID, PUSH_STREAM_ID, EmptyHttp2Headers.INSTANCE, 0);\n        verify(remote).reservePushStream(anyInt(), any(Http2Stream.class));\n        verify(listener).onPushPromiseRead(eq(ctx), anyInt(), anyInt(), any(Http2Headers.class), anyInt());\n    }\n\n    @Test(expected = Http2Exception.class)\n    public void pushPromiseReadForUnknownStreamShouldThrow() throws Exception {\n        when(connection.stream(STREAM_ID)).thenReturn(null);\n        decode().onPushPromiseRead(ctx, STREAM_ID, PUSH_STREAM_ID, EmptyHttp2Headers.INSTANCE, 0);\n    }\n\n    @Test\n    public void pushPromiseReadShouldSucceed() throws Exception {\n        decode().onPushPromiseRead(ctx, STREAM_ID, PUSH_STREAM_ID, EmptyHttp2Headers.INSTANCE, 0);\n        verify(remote).reservePushStream(eq(PUSH_STREAM_ID), eq(stream));\n        verify(listener).onPushPromiseRead(eq(ctx), eq(STREAM_ID), eq(PUSH_STREAM_ID),\n                eq(EmptyHttp2Headers.INSTANCE), eq(0));\n    }\n\n    @Test\n    public void priorityReadAfterGoAwaySentShouldAllowFramesForStreamCreatedByLocalEndpoint() throws Exception {\n        mockGoAwaySentShouldAllowFramesForStreamCreatedByLocalEndpoint();\n        decode().onPriorityRead(ctx, STREAM_ID, 0, (short) 255, true);\n        verify(remoteFlow).updateDependencyTree(eq(STREAM_ID), eq(0), eq((short) 255), eq(true));\n        verify(listener).onPriorityRead(eq(ctx), anyInt(), anyInt(), anyShort(), anyBoolean());\n    }\n\n    @Test\n    public void priorityReadForUnknownStreamShouldNotBeIgnored() throws Exception {\n        when(connection.stream(STREAM_ID)).thenReturn(null);\n        decode().onPriorityRead(ctx, STREAM_ID, 0, (short) 255, true);\n        verify(remoteFlow).updateDependencyTree(eq(STREAM_ID), eq(0), eq((short) 255), eq(true));\n        verify(listener).onPriorityRead(eq(ctx), eq(STREAM_ID), eq(0), eq((short) 255), eq(true));\n    }\n\n    @Test\n    public void priorityReadShouldNotCreateNewStream() throws Exception {\n        when(connection.streamMayHaveExisted(STREAM_ID)).thenReturn(false);\n        when(connection.stream(STREAM_ID)).thenReturn(null);\n        decode().onPriorityRead(ctx, STREAM_ID, STREAM_DEPENDENCY_ID, (short) 255, true);\n        verify(remoteFlow).updateDependencyTree(eq(STREAM_ID), eq(STREAM_DEPENDENCY_ID), eq((short) 255), eq(true));\n        verify(listener).onPriorityRead(eq(ctx), eq(STREAM_ID), eq(STREAM_DEPENDENCY_ID), eq((short) 255), eq(true));\n        verify(remote, never()).createStream(eq(STREAM_ID), anyBoolean());\n        verify(stream, never()).open(anyBoolean());\n    }\n\n    @Test\n    public void windowUpdateReadAfterGoAwaySentShouldBeIgnored() throws Exception {\n        mockGoAwaySent();\n        decode().onWindowUpdateRead(ctx, STREAM_ID, 10);\n        verify(remoteFlow, never()).incrementWindowSize(any(Http2Stream.class), anyInt());\n        verify(listener, never()).onWindowUpdateRead(eq(ctx), anyInt(), anyInt());\n    }\n\n    @Test\n    public void windowUpdateReadAfterGoAwaySentShouldAllowFramesForStreamCreatedByLocalEndpoint() throws Exception {\n        mockGoAwaySentShouldAllowFramesForStreamCreatedByLocalEndpoint();\n        decode().onWindowUpdateRead(ctx, STREAM_ID, 10);\n        verify(remoteFlow).incrementWindowSize(any(Http2Stream.class), anyInt());\n        verify(listener).onWindowUpdateRead(eq(ctx), anyInt(), anyInt());\n    }\n\n    @Test(expected = Http2Exception.class)\n    public void windowUpdateReadForUnknownStreamShouldThrow() throws Exception {\n        when(connection.streamMayHaveExisted(STREAM_ID)).thenReturn(false);\n        when(connection.stream(STREAM_ID)).thenReturn(null);\n        decode().onWindowUpdateRead(ctx, STREAM_ID, 10);\n    }\n\n    @Test\n    public void windowUpdateReadForUnknownStreamShouldBeIgnored() throws Exception {\n        when(connection.stream(STREAM_ID)).thenReturn(null);\n        decode().onWindowUpdateRead(ctx, STREAM_ID, 10);\n        verify(remoteFlow, never()).incrementWindowSize(any(Http2Stream.class), anyInt());\n        verify(listener, never()).onWindowUpdateRead(eq(ctx), anyInt(), anyInt());\n    }\n\n    @Test\n    public void windowUpdateReadShouldSucceed() throws Exception {\n        decode().onWindowUpdateRead(ctx, STREAM_ID, 10);\n        verify(remoteFlow).incrementWindowSize(eq(stream), eq(10));\n        verify(listener).onWindowUpdateRead(eq(ctx), eq(STREAM_ID), eq(10));\n    }\n\n    @Test\n    public void rstStreamReadAfterGoAwayShouldSucceed() throws Exception {\n        when(connection.goAwaySent()).thenReturn(true);\n        decode().onRstStreamRead(ctx, STREAM_ID, PROTOCOL_ERROR.code());\n        verify(lifecycleManager).closeStream(eq(stream), eq(future));\n        verify(listener).onRstStreamRead(eq(ctx), anyInt(), anyLong());\n    }\n\n    @Test(expected = Http2Exception.class)\n    public void rstStreamReadForUnknownStreamShouldThrow() throws Exception {\n        when(connection.streamMayHaveExisted(STREAM_ID)).thenReturn(false);\n        when(connection.stream(STREAM_ID)).thenReturn(null);\n        decode().onRstStreamRead(ctx, STREAM_ID, PROTOCOL_ERROR.code());\n    }\n\n    @Test\n    public void rstStreamReadForUnknownStreamShouldBeIgnored() throws Exception {\n        when(connection.stream(STREAM_ID)).thenReturn(null);\n        decode().onRstStreamRead(ctx, STREAM_ID, PROTOCOL_ERROR.code());\n        verify(lifecycleManager, never()).closeStream(eq(stream), eq(future));\n        verify(listener, never()).onRstStreamRead(eq(ctx), anyInt(), anyLong());\n    }\n\n    @Test\n    public void rstStreamReadShouldCloseStream() throws Exception {\n        decode().onRstStreamRead(ctx, STREAM_ID, PROTOCOL_ERROR.code());\n        verify(lifecycleManager).closeStream(eq(stream), eq(future));\n        verify(listener).onRstStreamRead(eq(ctx), eq(STREAM_ID), eq(PROTOCOL_ERROR.code()));\n    }\n\n    @Test(expected = Http2Exception.class)\n    public void rstStreamOnIdleStreamShouldThrow() throws Exception {\n        when(stream.state()).thenReturn(IDLE);\n        decode().onRstStreamRead(ctx, STREAM_ID, PROTOCOL_ERROR.code());\n        verify(lifecycleManager).closeStream(eq(stream), eq(future));\n        verify(listener, never()).onRstStreamRead(any(ChannelHandlerContext.class), anyInt(), anyLong());\n    }\n\n    @Test\n    public void pingReadWithAckShouldNotifyListener() throws Exception {\n        decode().onPingAckRead(ctx, 0L);\n        verify(listener).onPingAckRead(eq(ctx), eq(0L));\n    }\n\n    @Test\n    public void pingReadShouldReplyWithAck() throws Exception {\n        decode().onPingRead(ctx, 0L);\n        verify(encoder).writePing(eq(ctx), eq(true), eq(0L), eq(promise));\n        verify(listener, never()).onPingAckRead(eq(ctx), any(long.class));\n    }\n\n    @Test\n    public void settingsReadWithAckShouldNotifyListener() throws Exception {\n        decode().onSettingsAckRead(ctx);\n        // Take into account the time this was called during setup().\n        verify(listener, times(2)).onSettingsAckRead(eq(ctx));\n    }\n\n    @Test\n    public void settingsReadShouldSetValues() throws Exception {\n        Http2Settings settings = new Http2Settings();\n        settings.pushEnabled(true);\n        settings.initialWindowSize(123);\n        settings.maxConcurrentStreams(456);\n        settings.headerTableSize(789);\n        decode().onSettingsRead(ctx, settings);\n        verify(encoder).remoteSettings(settings);\n        verify(listener).onSettingsRead(eq(ctx), eq(settings));\n    }\n\n    @Test\n    public void goAwayShouldReadShouldUpdateConnectionState() throws Exception {\n        decode().onGoAwayRead(ctx, 1, 2L, EMPTY_BUFFER);\n        verify(connection).goAwayReceived(eq(1), eq(2L), eq(EMPTY_BUFFER));\n        verify(listener).onGoAwayRead(eq(ctx), eq(1), eq(2L), eq(EMPTY_BUFFER));\n    }\n\n    @Test(expected = Http2Exception.StreamException.class)\n    public void dataContentLengthMissmatch() throws Exception {\n        dataContentLengthInvalid(false);\n    }\n\n    @Test(expected = Http2Exception.StreamException.class)\n    public void dataContentLengthInvalid() throws Exception {\n        dataContentLengthInvalid(true);\n    }\n\n    private void dataContentLengthInvalid(boolean negative) throws Exception {\n        final ByteBuf data = dummyData();\n        int padding = 10;\n        int processedBytes = data.readableBytes() + padding;\n        mockFlowControl(processedBytes);\n        try {\n            decode().onHeadersRead(ctx, STREAM_ID, new DefaultHttp2Headers()\n                    .setLong(HttpHeaderNames.CONTENT_LENGTH, negative ? -1L : 1L), padding, false);\n            decode().onDataRead(ctx, STREAM_ID, data, padding, true);\n            verify(localFlow).receiveFlowControlledFrame(eq(stream), eq(data), eq(padding), eq(true));\n            verify(localFlow).consumeBytes(eq(stream), eq(processedBytes));\n\n            verify(listener, times(1)).onHeadersRead(eq(ctx), anyInt(),\n                    any(Http2Headers.class), eq(0), eq(DEFAULT_PRIORITY_WEIGHT), eq(false),\n                    eq(padding), eq(false));\n            // Verify that the event was absorbed and not propagated to the observer.\n            verify(listener, never()).onDataRead(eq(ctx), anyInt(), any(ByteBuf.class), anyInt(), anyBoolean());\n        } finally {\n            data.release();\n        }\n    }\n\n    @Test(expected = Http2Exception.StreamException.class)\n    public void headersContentLengthPositiveSign() throws Exception {\n        headersContentLengthSign(\"+1\");\n    }\n\n    @Test(expected = Http2Exception.StreamException.class)\n    public void headersContentLengthNegativeSign() throws Exception {\n        headersContentLengthSign(\"-1\");\n    }\n\n    private void headersContentLengthSign(String length) throws Exception {\n        int padding = 10;\n        when(connection.isServer()).thenReturn(true);\n        decode().onHeadersRead(ctx, STREAM_ID, new DefaultHttp2Headers()\n                .set(HttpHeaderNames.CONTENT_LENGTH, length), padding, false);\n\n        // Verify that the event was absorbed and not propagated to the observer.\n        verify(listener, never()).onHeadersRead(eq(ctx), anyInt(),\n                any(Http2Headers.class), anyInt(), anyShort(), anyBoolean(), anyInt(), anyBoolean());\n    }\n\n    @Test(expected = Http2Exception.StreamException.class)\n    public void headersContentLengthMissmatch() throws Exception {\n        headersContentLength(false);\n    }\n\n    @Test(expected = Http2Exception.StreamException.class)\n    public void headersContentLengthInvalid() throws Exception {\n        headersContentLength(true);\n    }\n\n    private void headersContentLength(boolean negative) throws Exception {\n        int padding = 10;\n        when(connection.isServer()).thenReturn(true);\n        decode().onHeadersRead(ctx, STREAM_ID, new DefaultHttp2Headers()\n                .setLong(HttpHeaderNames.CONTENT_LENGTH, negative ? -1L : 1L), padding, true);\n\n        // Verify that the event was absorbed and not propagated to the observer.\n        verify(listener, never()).onHeadersRead(eq(ctx), anyInt(),\n                any(Http2Headers.class), anyInt(), anyShort(), anyBoolean(), anyInt(), anyBoolean());\n    }\n\n    @Test\n    public void multipleHeadersContentLengthSame() throws Exception {\n        multipleHeadersContentLength(true);\n    }\n\n    @Test(expected = Http2Exception.StreamException.class)\n    public void multipleHeadersContentLengthDifferent() throws Exception {\n        multipleHeadersContentLength(false);\n    }\n\n    private void multipleHeadersContentLength(boolean same) throws Exception {\n        int padding = 10;\n        when(connection.isServer()).thenReturn(true);\n        Http2Headers headers = new DefaultHttp2Headers();\n        if (same) {\n            headers.addLong(HttpHeaderNames.CONTENT_LENGTH, 0);\n            headers.addLong(HttpHeaderNames.CONTENT_LENGTH, 0);\n        } else {\n            headers.addLong(HttpHeaderNames.CONTENT_LENGTH, 0);\n            headers.addLong(HttpHeaderNames.CONTENT_LENGTH, 1);\n        }\n\n        decode().onHeadersRead(ctx, STREAM_ID, headers, padding, true);\n\n        if (same) {\n            verify(listener, times(1)).onHeadersRead(eq(ctx), anyInt(),\n                    any(Http2Headers.class), anyInt(), anyShort(), anyBoolean(), anyInt(), anyBoolean());\n            assertEquals(1, headers.getAll(HttpHeaderNames.CONTENT_LENGTH).size());\n        } else {\n            // Verify that the event was absorbed and not propagated to the observer.\n            verify(listener, never()).onHeadersRead(eq(ctx), anyInt(),\n                    any(Http2Headers.class), anyInt(), anyShort(), anyBoolean(), anyInt(), anyBoolean());\n        }\n    }\n\n    private static ByteBuf dummyData() {\n        // The buffer is purposely 8 bytes so it will even work for a ping frame.\n        return wrappedBuffer(\"abcdefgh\".getBytes(UTF_8));\n    }\n\n    /**\n     * Calls the decode method on the handler and gets back the captured internal listener\n     */\n    private Http2FrameListener decode() throws Exception {\n        ArgumentCaptor<Http2FrameListener> internalListener = ArgumentCaptor.forClass(Http2FrameListener.class);\n        doNothing().when(reader).readFrame(eq(ctx), any(ByteBuf.class), internalListener.capture());\n        decoder.decodeFrame(ctx, EMPTY_BUFFER, Collections.emptyList());\n        return internalListener.getValue();\n    }\n\n    private void mockFlowControl(final int processedBytes) throws Http2Exception {\n        doAnswer(new Answer<Integer>() {\n            @Override\n            public Integer answer(InvocationOnMock invocation) throws Throwable {\n                return processedBytes;\n            }\n        }).when(listener).onDataRead(any(ChannelHandlerContext.class), anyInt(),\n                any(ByteBuf.class), anyInt(), anyBoolean());\n    }\n\n    private void mockGoAwaySent() {\n        when(connection.goAwaySent()).thenReturn(true);\n        when(remote.isValidStreamId(STREAM_ID)).thenReturn(true);\n        when(remote.lastStreamKnownByPeer()).thenReturn(0);\n    }\n\n    private void mockGoAwaySentShouldAllowFramesForStreamCreatedByLocalEndpoint() {\n        when(connection.goAwaySent()).thenReturn(true);\n        when(remote.isValidStreamId(STREAM_ID)).thenReturn(false);\n        when(remote.lastStreamKnownByPeer()).thenReturn(0);\n    }\n}\n"], "filenames": ["codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectDecoder.java", "codec-http/src/main/java/io/netty/handler/codec/http/HttpUtil.java", "codec-http2/src/main/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionDecoder.java", "codec-http2/src/test/java/io/netty/handler/codec/http2/DefaultHttp2ConnectionDecoderTest.java"], "buggy_code_start_loc": [19, 26, 18, 23], "buggy_code_end_loc": [676, 532, 738, 776], "fixing_code_start_loc": [18, 27, 19, 24], "fixing_code_end_loc": [642, 619, 821, 905], "type": "CWE-444", "message": "Netty is an open-source, asynchronous event-driven network application framework for rapid development of maintainable high performance protocol servers & clients. In Netty (io.netty:netty-codec-http2) before version 4.1.60.Final there is a vulnerability that enables request smuggling. If a Content-Length header is present in the original HTTP/2 request, the field is not validated by `Http2MultiplexHandler` as it is propagated up. This is fine as long as the request is not proxied through as HTTP/1.1. If the request comes in as an HTTP/2 stream, gets converted into the HTTP/1.1 domain objects (`HttpRequest`, `HttpContent`, etc.) via `Http2StreamFrameToHttpObjectCodec `and then sent up to the child channel's pipeline and proxied through a remote peer as HTTP/1.1 this may result in request smuggling. In a proxy case, users may assume the content-length is validated somehow, which is not the case. If the request is forwarded to a backend channel that is a HTTP/1.1 connection, the Content-Length now has meaning and needs to be checked. An attacker can smuggle requests inside the body as it gets downgraded from HTTP/2 to HTTP/1.1. For an example attack refer to the linked GitHub Advisory. Users are only affected if all of this is true: `HTTP2MultiplexCodec` or `Http2FrameCodec` is used, `Http2StreamFrameToHttpObjectCodec` is used to convert to HTTP/1.1 objects, and these HTTP/1.1 objects are forwarded to another remote peer. This has been patched in 4.1.60.Final As a workaround, the user can do the validation by themselves by implementing a custom `ChannelInboundHandler` that is put in the `ChannelPipeline` behind `Http2StreamFrameToHttpObjectCodec`.", "other": {"cve": {"id": "CVE-2021-21295", "sourceIdentifier": "security-advisories@github.com", "published": "2021-03-09T19:15:12.657", "lastModified": "2022-05-12T14:34:45.053", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Netty is an open-source, asynchronous event-driven network application framework for rapid development of maintainable high performance protocol servers & clients. In Netty (io.netty:netty-codec-http2) before version 4.1.60.Final there is a vulnerability that enables request smuggling. If a Content-Length header is present in the original HTTP/2 request, the field is not validated by `Http2MultiplexHandler` as it is propagated up. This is fine as long as the request is not proxied through as HTTP/1.1. If the request comes in as an HTTP/2 stream, gets converted into the HTTP/1.1 domain objects (`HttpRequest`, `HttpContent`, etc.) via `Http2StreamFrameToHttpObjectCodec `and then sent up to the child channel's pipeline and proxied through a remote peer as HTTP/1.1 this may result in request smuggling. In a proxy case, users may assume the content-length is validated somehow, which is not the case. If the request is forwarded to a backend channel that is a HTTP/1.1 connection, the Content-Length now has meaning and needs to be checked. An attacker can smuggle requests inside the body as it gets downgraded from HTTP/2 to HTTP/1.1. For an example attack refer to the linked GitHub Advisory. Users are only affected if all of this is true: `HTTP2MultiplexCodec` or `Http2FrameCodec` is used, `Http2StreamFrameToHttpObjectCodec` is used to convert to HTTP/1.1 objects, and these HTTP/1.1 objects are forwarded to another remote peer. This has been patched in 4.1.60.Final As a workaround, the user can do the validation by themselves by implementing a custom `ChannelInboundHandler` that is put in the `ChannelPipeline` behind `Http2StreamFrameToHttpObjectCodec`."}, {"lang": "es", "value": "Netty es un framework de aplicaci\u00f3n de red de c\u00f3digo abierto y controlado por eventos as\u00edncronos para el desarrollo r\u00e1pido de servidores y clientes de protocolo de alto rendimiento mantenibles.&#xa0;En Netty (io.netty: netty-codec-http2) versiones anteriores a la versi\u00f3n 4.1.60.Final, se presenta una vulnerabilidad que permite el tr\u00e1fico de peticiones.&#xa0;Si existe un encabezado Content-Length en la petici\u00f3n HTTP/2 original, el campo no es comprobado por \"Http2MultiplexHandler\" a medida que se propaga.&#xa0;Esto est\u00e1 bien siempre que la petici\u00f3n no se transmita como HTTP/1.1.&#xa0;Si la petici\u00f3n llega como una secuencia HTTP/2, se convierte en los objetos de dominio HTTP/1.1 (\"HttpRequest\", \"HttpContent\", etc.) por medio de \"Http2StreamFrameToHttpObjectCodec\" y luego se env\u00eda al pipeline del canal secundario y al proxy mediante un peer remoto como HTTP/1.1, esto puede resultar en el tr\u00e1fico de peticiones.&#xa0;En un caso de proxy,&#xa0;los usuarios pueden asumir que la longitud del contenido est\u00e1 comprobada de alguna forma, lo que no es el caso.&#xa0;Si la petici\u00f3n se reenv\u00eda a un canal de backend que es una conexi\u00f3n HTTP/1.1, la longitud del contenido ahora tiene significado y debe verificarse.&#xa0;Un atacante puede traficar peticiones dentro del cuerpo a medida que se degrada de HTTP/2 a HTTP/1.1.&#xa0;Para visualizar un ejemplo de ataque, consulte el Aviso de GitHub vinculado.&#xa0;Los usuarios solo est\u00e1n afectados si todo esto es cierto: se usa \"HTTP2MultiplexCodec\" o \"Http2FrameCodec\", se usa \"Http2StreamFrameToHttpObjectCodec\" para convertir a objetos HTTP/1.1, y estos objetos HTTP/1.1 se reenv\u00edan a otro par remoto.&#xa0;Esto ha sido parcheado en la versi\u00f3n 4.1.60.Final. Como soluci\u00f3n, el usuario puede hacer la comprobaci\u00f3n por s\u00ed mismo implementando un \"ChannelInboundHandler\" personalizado que se coloca en el \"ChannelPipeline\" detr\u00e1s de \"Http2StreamFrameToHttpObjectCodec\""}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 5.9, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.2, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 5.9, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.2, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:H/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "HIGH", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 2.6}, "baseSeverity": "LOW", "exploitabilityScore": 4.9, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-444"}]}, {"source": "nvd@nist.gov", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-444"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:netty:netty:*:*:*:*:*:*:*:*", "versionEndExcluding": "4.1.60", "matchCriteriaId": "635A35A3-F02B-44CC-BB81-48C97F1612B1"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:netapp:oncommand_api_services:-:*:*:*:*:*:*:*", "matchCriteriaId": "5EC98B22-FFAA-4B59-8E63-EBAA4336AD13"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:oncommand_workflow_automation:-:*:*:*:*:*:*:*", "matchCriteriaId": "5735E553-9731-4AAC-BCFF-989377F817B3"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:quarkus:quarkus:*:*:*:*:*:*:*:*", "versionEndIncluding": "1.13.7", "matchCriteriaId": "64839EBF-078E-492A-897C-9AFFB7678ED8"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:apache:kudu:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.16.0", "matchCriteriaId": "A868228B-8AA3-4A4D-B3B4-9344854B94F2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:apache:zookeeper:3.5.9:*:*:*:*:*:*:*", "matchCriteriaId": "C6D906AE-B5F6-4CD6-8018-F6FFF7A49913"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:oracle:communications_cloud_native_core_policy:1.14.0:*:*:*:*:*:*:*", "matchCriteriaId": "4479F76A-4B67-41CC-98C7-C76B81050F8E"}]}]}], "references": [{"url": "https://github.com/Netflix/zuul/pull/980", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/netty/netty/commit/89c241e3b1795ff257af4ad6eadc616cb2fb3dc4", "source": "security-advisories@github.com", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://github.com/netty/netty/security/advisories/GHSA-wm47-8v5p-wjpj", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/r02e467123d45006a1dda20a38349e9c74c3a4b53e2e07be0939ecb3f@%3Cdev.ranger.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/r040a5e4d9cca2f98354b58a70b27099672276f66995c4e2e39545d0b@%3Cissues.hbase.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/r04a3e0d9f53421fb946c60cc54762b7151dc692eb4e39970a7579052@%3Ccommits.servicecomb.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/r0b09f3e31e004fe583f677f7afa46bd30110904576c13c5ac818ac2c@%3Cissues.flink.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/r15f66ada9a5faf4bac69d9e7c4521cedfefa62df9509881603791969@%3Cjira.kafka.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/r16c4b55ac82be72f28adad4f8061477e5f978199d5725691dcc82c24@%3Ccommits.servicecomb.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/r1908a34b9cc7120e5c19968a116ddbcffea5e9deb76c2be4fa461904@%3Cdev.zookeeper.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/r1bca0b81193b74a451fc6d687ab58ef3a1f5ec40f6c61561d8dd9509@%3Cissues.zookeeper.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/r22adb45fe902aeafcd0a1c4db13984224a667676c323c66db3af38a1@%3Ccommits.zookeeper.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/r22b2f34447d71c9a0ad9079b7860323d5584fb9b40eb42668c21eaf1@%3Cissues.hbase.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/r268850f26639ebe249356ed6d8edb54ee8943be6f200f770784fb190@%3Cissues.hbase.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/r27b7e5a588ec826b15f38c40be500c50073400019ce7b8adfd07fece@%3Cissues.hbase.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/r2936730ef0a06e724b96539bc7eacfcd3628987c16b1b99c790e7b87@%3Cissues.zookeeper.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/r2e93ce23e04c3f0a61e987d1111d0695cb668ac4ec4edbf237bd3e80@%3Ccommits.servicecomb.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/r312ce5bd3c6bf08c138349b507b6f1c25fe9cf40b6f2b0014c9d12b1@%3Cnotifications.zookeeper.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/r32b0b640ad2be3b858f0af51c68a7d5c5a66a462c8bbb93699825cd3@%3Cissues.zookeeper.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/r33eb06b05afbc7df28d31055cae0cb3fd36cab808c884bf6d680bea5@%3Cdev.zookeeper.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/r393a339ab0b63ef9e6502253eeab26e7643b3e69738d5948b2b1d064@%3Cissues.hbase.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/r3c293431c781696681abbfe1c573c2d9dcdae6fd3ff330ea22f0433f@%3Cjira.kafka.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/r3c4596b9b37f5ae91628ccf169d33cd5a0da4b16b6c39d5bad8e03f3@%3Cdev.jackrabbit.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/r3ff9e735ca33612d900607dc139ebd38a64cadc6bce292e53eb86d7f@%3Cissues.zookeeper.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/r490ca5611c150d193b320a2608209180713b7c68e501b67b0cffb925@%3Ccommits.servicecomb.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/r4ea2f1a9d79d4fc1896e085f31fb60a21b1770d0a26a5250f849372d@%3Cissues.kudu.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/r5232e33a1f3b310a3e083423f736f3925ebdb150844d60ac582809f8@%3Cnotifications.zookeeper.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/r5470456cf1409a99893ae9dd57439799f6dc1a60fda90e11570f66fe@%3Cnotifications.zookeeper.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/r57245853c7245baab09eae08728c52b58fd77666538092389cc3e882@%3Ccommits.servicecomb.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/r584cf871f188c406d8bd447ff4e2fd9817fca862436c064d0951a071@%3Ccommits.pulsar.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/r59bac5c09f7a4179b9e2460e8f41c278aaf3b9a21cc23678eb893e41@%3Cjira.kafka.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/r5baac01f9e06c40ff7aab209d5751b3b58802c63734e33324b70a06a@%3Cissues.flink.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/r5e66e286afb5506cdfe9bbf68a323e8d09614f6d1ddc806ed0224700@%3Cjira.kafka.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/r5fc5786cdd640b1b0a3c643237ce0011f0a08a296b11c0e2c669022c@%3Cdev.kafka.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/r602e98daacc98934f097f07f2eed6eb07c18bfc1949c8489dc7bfcf5@%3Cissues.flink.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/r67c4f90658fde875521c949448c54c98517beecdc7f618f902c620ec@%3Cissues.zookeeper.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/r67e6a636cbc1958383a1cd72b7fd0cd7493360b1dd0e6c12f5761798@%3Cnotifications.zookeeper.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/r6a122c25e352eb134d01e7f4fc4d345a491c5ee9453fef6fc754d15b@%3Ccommits.zookeeper.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/r6a29316d758db628a1df49ca219d64caf493999b52cc77847bfba675@%3Cnotifications.zookeeper.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/r6aee7e3566cb3e51eeed2fd8786704d91f80a7581e00a787ba9f37f6@%3Cissues.hbase.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/r6d32fc3cd547f7c9a288a57c7f525f5d00a00d5d163613e0d10a23ef@%3Ccommits.servicecomb.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/r70cebada51bc6d49138272437d8a28fe971d0197334ef906b575044c@%3Ccommits.zookeeper.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/r790c2926efcd062067eb18fde2486527596d7275381cfaff2f7b3890@%3Cissues.bookkeeper.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/r7bb3cdc192e9a6f863d3ea05422f09fa1ae2b88d4663e63696ee7ef5@%3Cdev.ranger.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/r837bbcbf12e335e83ab448b1bd2c1ad7e86efdc14034b23811422e6a@%3Ccommits.zookeeper.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/r855b4b6814ac829ce2d48dd9d8138d07f33387e710de798ee92c011e@%3Cissues.flink.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/r86cd38a825ab2344f3e6cad570528852f29a4ffdf56ab67d75c36edf@%3Cissues.hbase.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/r8bcaf7821247b1836b10f6a1a3a3212b06272fd4cde4a859de1b78cf@%3Ccommits.servicecomb.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/r8db1d7b3b9acc9e8d2776395e280eb9615dd7790e1da8c57039963de@%3Cnotifications.zookeeper.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/r9051e4f484a970b5566dc1870ecd9c1eb435214e2652cf3ea4d0c0cc@%3Cjira.kafka.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/r905b92099998291956eebf4f1c5d95f5a0cbcece2946cc46d32274fd@%3Cdev.hbase.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/r96ce18044880c33634c4b3fcecc57b8b90673c9364d63eba00385523@%3Cjira.kafka.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/r9924ef9357537722b28d04c98a189750b80694a19754e5057c34ca48@%3Ccommits.pulsar.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/ra64d56a8a331ffd7bdcd24a9aaaeeedeacd5d639f5a683389123f898@%3Cdev.flink.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/ra655e5cec74d1ddf62adacb71d398abd96f3ea2c588f6bbf048348eb@%3Cissues.kudu.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/ra83096bcbfe6e1f4d54449f8a013117a0536404e9d307ab4a0d34f81@%3Cissues.hbase.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/ra96c74c37ed7252f78392e1ad16442bd16ae72a4d6c8db50dd55c88b@%3Ccommits.servicecomb.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/racc191a1f70a4f13155e8002c61bddef2870b26441971c697436ad5d@%3Ccommits.servicecomb.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/rae198f44c3f7ac5264045e6ba976be1703cff38dcf1609916e50210d@%3Ccommits.servicecomb.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/rb06c1e766aa45ee422e8261a8249b561784186483e8f742ea627bda4@%3Cdev.kafka.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/rb51d6202ff1a773f96eaa694b7da4ad3f44922c40b3d4e1a19c2f325@%3Ccommits.pulsar.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/rb523bb6c60196c5f58514b86a8585c2069a4852039b45de3818b29d2@%3Ccommits.servicecomb.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/rb592033a2462548d061a83ac9449c5ff66098751748fcd1e2d008233@%3Cissues.zookeeper.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/rb95d42ce220ed4a4683aa17833b5006d657bc4254bc5cb03cd5e6bfb@%3Cissues.hbase.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/rbadcbcb50195f00bbd196403865ced521ca70787999583c07be38d0e@%3Cnotifications.zookeeper.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/rbed09768f496244a2e138dbbe6d2847ddf796c9c8ef9e50f2e3e30d9@%3Cnotifications.zookeeper.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/rc0087125cb15b4b78e44000f841cd37fefedfda942fd7ddf3ad1b528@%3Cissues.zookeeper.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/rc165e36ca7cb5417aec3f21bbc4ec00fb38ecebdd96a82cfab9bd56f@%3Cjira.kafka.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/rc73b8dd01b1be276d06bdf07883ecd93fe1a01f139a99ef30ba4308c@%3Ccommits.servicecomb.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/rca0978b634a0c3ebee4126ec29c7f570b165fae3f8f3658754c1cbd3@%3Cissues.kudu.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/rcd163e421273e8dca1c71ea298dce3dd11b41d51c3a812e0394e6a5d@%3Ccommits.pulsar.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/rcf3752209a8b04996373bf57fdc808b3bfaa2be8702698a0323641f8@%3Ccommits.hbase.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/rcfc154eb2de23d2dc08a56100341161e1a40a8ea86c693735437e8f2@%3Ccommits.servicecomb.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/rcfc535afd413d9934d6ee509dce234dac41fa3747a7555befb17447e@%3Cissues.zookeeper.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/rd25c88aad0e76240dd09f0eb34bdab924933946429e068a167adcb73@%3Ccommits.servicecomb.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/rd4a6b7dec38ea6cd28b6f94bd4b312629a52b80be3786d5fb0e474bc@%3Cissues.kudu.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/rd8f72411fb75b98d366400ae789966373b5c3eb3f511e717caf3e49e@%3Cissues.flink.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/rdb4db3f5a9c478ca52a7b164680b88877a5a9c174e7047676c006b2c@%3Ccommits.servicecomb.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/rdc096e13ac4501ea2e2b03a197682a313b85d3d3ec89d5ae5551b384@%3Cissues.zookeeper.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/rddbb4f8d5db23265bb63d14ef4b3723b438abc1589f877db11d35450@%3Cissues.zookeeper.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/re4f70b62843e92163fab03b65e2aa8078693293a0c36f1cc260079ed@%3Ccommits.servicecomb.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/re6207ebe2ca4d44f2a6deee695ad6f27fd29d78980f1d46ed1574f91@%3Cissues.zookeeper.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/re7c69756a102bebce8b8681882844a53e2f23975a189363e68ad0324@%3Cissues.flink.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/reafc834062486adfc7be5bb8f7b7793be0d33f483678a094c3f9d468@%3Ccommits.servicecomb.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/rf36f1114e84a3379b20587063686148e2d5a39abc0b8a66ff2a9087a@%3Cissues.zookeeper.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/rf87b870a22aa5c77c27900967b518a71a7d954c2952860fce3794b60@%3Ccommits.servicecomb.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/rf934292a4a1c189827f625d567838d2c1001e4739b158638d844105b@%3Cissues.kudu.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/rfff6ff8ffb31e8a32619c79774def44b6ffbb037c128c5ad3eab7171@%3Cissues.zookeeper.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20210604-0003/", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://www.debian.org/security/2021/dsa-4885", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://www.oracle.com/security-alerts/cpuapr2022.html", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/netty/netty/commit/89c241e3b1795ff257af4ad6eadc616cb2fb3dc4"}}