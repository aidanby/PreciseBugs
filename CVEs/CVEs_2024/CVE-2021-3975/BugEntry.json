{"buggy_code": ["/*\n * qemu_process.c: QEMU process management\n *\n * Copyright (C) 2006-2016 Red Hat, Inc.\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library.  If not, see\n * <http://www.gnu.org/licenses/>.\n *\n */\n\n#include <config.h>\n\n#include <fcntl.h>\n#include <unistd.h>\n#include <signal.h>\n#include <sys/stat.h>\n#if defined(__linux__)\n# include <linux/capability.h>\n#elif defined(__FreeBSD__)\n# include <sys/param.h>\n# include <sys/cpuset.h>\n#endif\n\n#include <sys/utsname.h>\n\n#if WITH_CAPNG\n# include <cap-ng.h>\n#endif\n\n#include \"qemu_process.h\"\n#define LIBVIRT_QEMU_PROCESSPRIV_H_ALLOW\n#include \"qemu_processpriv.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_block.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_domain_address.h\"\n#include \"qemu_namespace.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_command.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_interface.h\"\n#include \"qemu_security.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_dbus.h\"\n#include \"qemu_snapshot.h\"\n\n#include \"cpu/cpu.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virhook.h\"\n#include \"virfile.h\"\n#include \"virpidfile.h\"\n#include \"virhostcpu.h\"\n#include \"domain_audit.h\"\n#include \"domain_nwfilter.h\"\n#include \"domain_validate.h\"\n#include \"locking/domain_lock.h\"\n#include \"viruuid.h\"\n#include \"virprocess.h\"\n#include \"virtime.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevmidonet.h\"\n#include \"virbitmap.h\"\n#include \"virnuma.h\"\n#include \"virstring.h\"\n#include \"virhostdev.h\"\n#include \"virsecret.h\"\n#include \"configmake.h\"\n#include \"nwfilter_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"virresctrl.h\"\n#include \"virvsock.h\"\n#include \"viridentity.h\"\n#include \"virthreadjob.h\"\n#include \"virutil.h\"\n#include \"storage_source.h\"\n\n#define VIR_FROM_THIS VIR_FROM_QEMU\n\nVIR_LOG_INIT(\"qemu.qemu_process\");\n\n/**\n * qemuProcessRemoveDomainStatus\n *\n * remove all state files of a domain from statedir\n */\nstatic void\nqemuProcessRemoveDomainStatus(virQEMUDriverPtr driver,\n                              virDomainObjPtr vm)\n{\n    g_autofree char *file = NULL;\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    g_autoptr(virQEMUDriverConfig) cfg = virQEMUDriverGetConfig(driver);\n\n    file = g_strdup_printf(\"%s/%s.xml\", cfg->stateDir, vm->def->name);\n\n    if (unlink(file) < 0 && errno != ENOENT && errno != ENOTDIR)\n        VIR_WARN(\"Failed to remove domain XML for %s: %s\",\n                 vm->def->name, g_strerror(errno));\n\n    if (priv->pidfile &&\n        unlink(priv->pidfile) < 0 &&\n        errno != ENOENT)\n        VIR_WARN(\"Failed to remove PID file for %s: %s\",\n                 vm->def->name, g_strerror(errno));\n}\n\n\n/*\n * This is a callback registered with a qemuAgentPtr instance,\n * and to be invoked when the agent console hits an end of file\n * condition, or error, thus indicating VM shutdown should be\n * performed\n */\nstatic void\nqemuProcessHandleAgentEOF(qemuAgentPtr agent,\n                          virDomainObjPtr vm)\n{\n    qemuDomainObjPrivatePtr priv;\n\n    VIR_DEBUG(\"Received EOF from agent on %p '%s'\", vm, vm->def->name);\n\n    virObjectLock(vm);\n\n    priv = vm->privateData;\n\n    if (!priv->agent) {\n        VIR_DEBUG(\"Agent freed already\");\n        goto unlock;\n    }\n\n    if (priv->beingDestroyed) {\n        VIR_DEBUG(\"Domain is being destroyed, agent EOF is expected\");\n        goto unlock;\n    }\n\n    qemuAgentClose(agent);\n    priv->agent = NULL;\n    priv->agentError = false;\n\n    virObjectUnlock(vm);\n    return;\n\n unlock:\n    virObjectUnlock(vm);\n    return;\n}\n\n\n/*\n * This is invoked when there is some kind of error\n * parsing data to/from the agent. The VM can continue\n * to run, but no further agent commands will be\n * allowed\n */\nstatic void\nqemuProcessHandleAgentError(qemuAgentPtr agent G_GNUC_UNUSED,\n                            virDomainObjPtr vm)\n{\n    qemuDomainObjPrivatePtr priv;\n\n    VIR_DEBUG(\"Received error from agent on %p '%s'\", vm, vm->def->name);\n\n    virObjectLock(vm);\n\n    priv = vm->privateData;\n\n    priv->agentError = true;\n\n    virObjectUnlock(vm);\n}\n\nstatic void qemuProcessHandleAgentDestroy(qemuAgentPtr agent,\n                                          virDomainObjPtr vm)\n{\n    VIR_DEBUG(\"Received destroy agent=%p vm=%p\", agent, vm);\n\n    virObjectUnref(vm);\n}\n\n\nstatic qemuAgentCallbacks agentCallbacks = {\n    .destroy = qemuProcessHandleAgentDestroy,\n    .eofNotify = qemuProcessHandleAgentEOF,\n    .errorNotify = qemuProcessHandleAgentError,\n};\n\n\nint\nqemuConnectAgent(virQEMUDriverPtr driver, virDomainObjPtr vm)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    qemuAgentPtr agent = NULL;\n    virDomainChrDefPtr config = qemuFindAgentConfig(vm->def);\n\n    if (!config)\n        return 0;\n\n    if (priv->agent)\n        return 0;\n\n    if (virQEMUCapsGet(priv->qemuCaps, QEMU_CAPS_VSERPORT_CHANGE) &&\n        config->state != VIR_DOMAIN_CHR_DEVICE_STATE_CONNECTED) {\n        VIR_DEBUG(\"Deferring connecting to guest agent\");\n        return 0;\n    }\n\n    if (qemuSecuritySetDaemonSocketLabel(driver->securityManager, vm->def) < 0) {\n        VIR_ERROR(_(\"Failed to set security context for agent for %s\"),\n                  vm->def->name);\n        goto cleanup;\n    }\n\n    /* Hold an extra reference because we can't allow 'vm' to be\n     * deleted while the agent is active */\n    virObjectRef(vm);\n\n    virObjectUnlock(vm);\n\n    agent = qemuAgentOpen(vm,\n                          config->source,\n                          virEventThreadGetContext(priv->eventThread),\n                          &agentCallbacks,\n                          virQEMUCapsGet(priv->qemuCaps, QEMU_CAPS_VSERPORT_CHANGE));\n\n    virObjectLock(vm);\n\n    if (agent == NULL)\n        virObjectUnref(vm);\n\n    if (!virDomainObjIsActive(vm)) {\n        qemuAgentClose(agent);\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"guest crashed while connecting to the guest agent\"));\n        return -1;\n    }\n\n    if (qemuSecurityClearSocketLabel(driver->securityManager, vm->def) < 0) {\n        VIR_ERROR(_(\"Failed to clear security context for agent for %s\"),\n                  vm->def->name);\n        qemuAgentClose(agent);\n        goto cleanup;\n    }\n\n    priv->agent = agent;\n    if (!priv->agent)\n        VIR_INFO(\"Failed to connect agent for %s\", vm->def->name);\n\n cleanup:\n    if (!priv->agent) {\n        VIR_WARN(\"Cannot connect to QEMU guest agent for %s\", vm->def->name);\n        priv->agentError = true;\n        virResetLastError();\n    }\n\n    return 0;\n}\n\n\n/*\n * This is a callback registered with a qemuMonitorPtr instance,\n * and to be invoked when the monitor console hits an end of file\n * condition, or error, thus indicating VM shutdown should be\n * performed\n */\nstatic void\nqemuProcessHandleMonitorEOF(qemuMonitorPtr mon,\n                            virDomainObjPtr vm,\n                            void *opaque)\n{\n    virQEMUDriverPtr driver = opaque;\n    qemuDomainObjPrivatePtr priv;\n    struct qemuProcessEvent *processEvent;\n\n    virObjectLock(vm);\n\n    VIR_DEBUG(\"Received EOF on %p '%s'\", vm, vm->def->name);\n\n    priv = vm->privateData;\n    if (priv->beingDestroyed) {\n        VIR_DEBUG(\"Domain is being destroyed, EOF is expected\");\n        goto cleanup;\n    }\n\n    processEvent = g_new0(struct qemuProcessEvent, 1);\n\n    processEvent->eventType = QEMU_PROCESS_EVENT_MONITOR_EOF;\n    processEvent->vm = virObjectRef(vm);\n\n    if (virThreadPoolSendJob(driver->workerPool, 0, processEvent) < 0) {\n        virObjectUnref(vm);\n        qemuProcessEventFree(processEvent);\n        goto cleanup;\n    }\n\n    /* We don't want this EOF handler to be called over and over while the\n     * thread is waiting for a job.\n     */\n    qemuMonitorUnregister(mon);\n\n    /* We don't want any cleanup from EOF handler (or any other\n     * thread) to enter qemu namespace. */\n    qemuDomainDestroyNamespace(driver, vm);\n\n cleanup:\n    virObjectUnlock(vm);\n}\n\n\n/*\n * This is invoked when there is some kind of error\n * parsing data to/from the monitor. The VM can continue\n * to run, but no further monitor commands will be\n * allowed\n */\nstatic void\nqemuProcessHandleMonitorError(qemuMonitorPtr mon G_GNUC_UNUSED,\n                              virDomainObjPtr vm,\n                              void *opaque)\n{\n    virQEMUDriverPtr driver = opaque;\n    virObjectEventPtr event = NULL;\n\n    VIR_DEBUG(\"Received error on %p '%s'\", vm, vm->def->name);\n\n    virObjectLock(vm);\n\n    ((qemuDomainObjPrivatePtr) vm->privateData)->monError = true;\n    event = virDomainEventControlErrorNewFromObj(vm);\n    virObjectEventStateQueue(driver->domainEventState, event);\n\n    virObjectUnlock(vm);\n}\n\n\n/**\n * qemuProcessFindDomainDiskByAliasOrQOM:\n * @vm: domain object to search for the disk\n * @alias: -drive or -device alias of the disk\n * @qomid: QOM tree device name\n *\n * Looks up a disk in the domain definition of @vm which either matches the\n * -drive or -device alias used for the backend and frontend respectively or the\n * QOM name. If @alias is empty it's treated as NULL as it's a mandatory field\n * in some cases.\n *\n * Returns a disk from @vm or NULL if it could not be found.\n */\nvirDomainDiskDefPtr\nqemuProcessFindDomainDiskByAliasOrQOM(virDomainObjPtr vm,\n                                      const char *alias,\n                                      const char *qomid)\n{\n    size_t i;\n\n    if (alias && *alias == '\\0')\n        alias = NULL;\n\n    if (alias)\n        alias = qemuAliasDiskDriveSkipPrefix(alias);\n\n    for (i = 0; i < vm->def->ndisks; i++) {\n        virDomainDiskDefPtr disk = vm->def->disks[i];\n        qemuDomainDiskPrivatePtr diskPriv = QEMU_DOMAIN_DISK_PRIVATE(disk);\n\n        if ((disk->info.alias && STREQ_NULLABLE(disk->info.alias, alias)) ||\n            (diskPriv->qomName && STREQ_NULLABLE(diskPriv->qomName, qomid)))\n            return disk;\n    }\n\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   _(\"no disk found with alias '%s' or id '%s'\"),\n                   NULLSTR(alias), NULLSTR(qomid));\n    return NULL;\n}\n\n\nstatic int\nqemuProcessHandleReset(qemuMonitorPtr mon G_GNUC_UNUSED,\n                       virDomainObjPtr vm,\n                       void *opaque)\n{\n    virQEMUDriverPtr driver = opaque;\n    virObjectEventPtr event;\n    qemuDomainObjPrivatePtr priv;\n    g_autoptr(virQEMUDriverConfig) cfg = virQEMUDriverGetConfig(driver);\n    int ret = -1;\n\n    virObjectLock(vm);\n\n    event = virDomainEventRebootNewFromObj(vm);\n    priv = vm->privateData;\n    if (priv->agent)\n        qemuAgentNotifyEvent(priv->agent, QEMU_AGENT_EVENT_RESET);\n\n    if (virDomainObjSave(vm, driver->xmlopt, cfg->stateDir) < 0)\n        VIR_WARN(\"Failed to save status on vm %s\", vm->def->name);\n\n    if (vm->def->onReboot == VIR_DOMAIN_LIFECYCLE_ACTION_DESTROY ||\n        vm->def->onReboot == VIR_DOMAIN_LIFECYCLE_ACTION_PRESERVE) {\n\n        if (qemuDomainObjBeginJob(driver, vm, QEMU_JOB_MODIFY) < 0)\n            goto cleanup;\n\n        if (!virDomainObjIsActive(vm)) {\n            VIR_DEBUG(\"Ignoring RESET event from inactive domain %s\",\n                      vm->def->name);\n            goto endjob;\n        }\n\n        qemuProcessStop(driver, vm, VIR_DOMAIN_SHUTOFF_DESTROYED,\n                        QEMU_ASYNC_JOB_NONE, 0);\n        virDomainAuditStop(vm, \"destroyed\");\n        qemuDomainRemoveInactive(driver, vm);\n     endjob:\n        qemuDomainObjEndJob(driver, vm);\n    }\n\n    ret = 0;\n cleanup:\n    virObjectUnlock(vm);\n    virObjectEventStateQueue(driver->domainEventState, event);\n    return ret;\n}\n\n\n/*\n * Since we have the '-no-shutdown' flag set, the\n * QEMU process will currently have guest OS shutdown\n * and the CPUS stopped. To fake the reboot, we thus\n * want todo a reset of the virtual hardware, followed\n * by restart of the CPUs. This should result in the\n * guest OS booting up again\n */\nstatic void\nqemuProcessFakeReboot(void *opaque)\n{\n    virDomainObjPtr vm = opaque;\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    virQEMUDriverPtr driver = priv->driver;\n    g_autoptr(virQEMUDriverConfig) cfg = virQEMUDriverGetConfig(driver);\n    virDomainRunningReason reason = VIR_DOMAIN_RUNNING_BOOTED;\n    int ret = -1, rc;\n\n    VIR_DEBUG(\"vm=%p\", vm);\n    virObjectLock(vm);\n    if (qemuDomainObjBeginJob(driver, vm, QEMU_JOB_MODIFY) < 0)\n        goto cleanup;\n\n    if (!virDomainObjIsActive(vm)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"guest unexpectedly quit\"));\n        goto endjob;\n    }\n\n    qemuDomainObjEnterMonitor(driver, vm);\n    rc = qemuMonitorSystemReset(priv->mon);\n\n    if (qemuDomainObjExitMonitor(driver, vm) < 0)\n        goto endjob;\n\n    if (rc < 0)\n        goto endjob;\n\n    if (virDomainObjGetState(vm, NULL) == VIR_DOMAIN_CRASHED)\n        reason = VIR_DOMAIN_RUNNING_CRASHED;\n\n    if (qemuProcessStartCPUs(driver, vm,\n                             reason,\n                             QEMU_ASYNC_JOB_NONE) < 0) {\n        if (virGetLastErrorCode() == VIR_ERR_OK)\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           \"%s\", _(\"resume operation failed\"));\n        goto endjob;\n    }\n\n    if (virDomainObjSave(vm, driver->xmlopt, cfg->stateDir) < 0) {\n        VIR_WARN(\"Unable to save status on vm %s after state change\",\n                 vm->def->name);\n    }\n\n    ret = 0;\n\n endjob:\n    qemuDomainObjEndJob(driver, vm);\n\n cleanup:\n    priv->pausedShutdown = false;\n    if (ret == -1)\n        ignore_value(qemuProcessKill(vm, VIR_QEMU_PROCESS_KILL_FORCE));\n    virDomainObjEndAPI(&vm);\n}\n\n\nvoid\nqemuProcessShutdownOrReboot(virQEMUDriverPtr driver,\n                            virDomainObjPtr vm)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n\n    if (priv->fakeReboot) {\n        g_autofree char *name = g_strdup_printf(\"reboot-%s\", vm->def->name);\n        virThread th;\n\n        qemuDomainSetFakeReboot(driver, vm, false);\n        virObjectRef(vm);\n        if (virThreadCreateFull(&th,\n                                false,\n                                qemuProcessFakeReboot,\n                                name,\n                                false,\n                                vm) < 0) {\n            VIR_ERROR(_(\"Failed to create reboot thread, killing domain\"));\n            ignore_value(qemuProcessKill(vm, VIR_QEMU_PROCESS_KILL_NOWAIT));\n            priv->pausedShutdown = false;\n            virObjectUnref(vm);\n        }\n    } else {\n        ignore_value(qemuProcessKill(vm, VIR_QEMU_PROCESS_KILL_NOWAIT));\n    }\n}\n\n\nstatic int\nqemuProcessHandleEvent(qemuMonitorPtr mon G_GNUC_UNUSED,\n                       virDomainObjPtr vm,\n                       const char *eventName,\n                       long long seconds,\n                       unsigned int micros,\n                       const char *details,\n                       void *opaque)\n{\n    virQEMUDriverPtr driver = opaque;\n    virObjectEventPtr event = NULL;\n\n    VIR_DEBUG(\"vm=%p\", vm);\n\n    virObjectLock(vm);\n    event = virDomainQemuMonitorEventNew(vm->def->id, vm->def->name,\n                                         vm->def->uuid, eventName,\n                                         seconds, micros, details);\n\n    virObjectUnlock(vm);\n    virObjectEventStateQueue(driver->domainEventState, event);\n\n    return 0;\n}\n\n\nstatic int\nqemuProcessHandleShutdown(qemuMonitorPtr mon G_GNUC_UNUSED,\n                          virDomainObjPtr vm,\n                          virTristateBool guest_initiated,\n                          void *opaque)\n{\n    virQEMUDriverPtr driver = opaque;\n    qemuDomainObjPrivatePtr priv;\n    virObjectEventPtr event = NULL;\n    g_autoptr(virQEMUDriverConfig) cfg = virQEMUDriverGetConfig(driver);\n    int detail = 0;\n\n    VIR_DEBUG(\"vm=%p\", vm);\n\n    virObjectLock(vm);\n\n    priv = vm->privateData;\n    if (virDomainObjGetState(vm, NULL) == VIR_DOMAIN_SHUTDOWN) {\n        VIR_DEBUG(\"Ignoring repeated SHUTDOWN event from domain %s\",\n                  vm->def->name);\n        goto unlock;\n    } else if (!virDomainObjIsActive(vm)) {\n        VIR_DEBUG(\"Ignoring SHUTDOWN event from inactive domain %s\",\n                  vm->def->name);\n        goto unlock;\n    }\n\n    /* In case of fake reboot qemu shutdown state is transient so don't\n     * change domain state nor send events. */\n    if (!priv->fakeReboot) {\n        VIR_DEBUG(\"Transitioned guest %s to shutdown state\",\n                  vm->def->name);\n        virDomainObjSetState(vm,\n                             VIR_DOMAIN_SHUTDOWN,\n                             VIR_DOMAIN_SHUTDOWN_UNKNOWN);\n\n        switch (guest_initiated) {\n        case VIR_TRISTATE_BOOL_YES:\n            detail = VIR_DOMAIN_EVENT_SHUTDOWN_GUEST;\n            break;\n\n        case VIR_TRISTATE_BOOL_NO:\n            detail = VIR_DOMAIN_EVENT_SHUTDOWN_HOST;\n            break;\n\n        case VIR_TRISTATE_BOOL_ABSENT:\n        case VIR_TRISTATE_BOOL_LAST:\n        default:\n            detail = VIR_DOMAIN_EVENT_SHUTDOWN_FINISHED;\n            break;\n        }\n\n        event = virDomainEventLifecycleNewFromObj(vm,\n                                                  VIR_DOMAIN_EVENT_SHUTDOWN,\n                                                  detail);\n\n        if (virDomainObjSave(vm, driver->xmlopt, cfg->stateDir) < 0) {\n            VIR_WARN(\"Unable to save status on vm %s after state change\",\n                     vm->def->name);\n        }\n    } else {\n        priv->pausedShutdown = true;\n    }\n\n    if (priv->agent)\n        qemuAgentNotifyEvent(priv->agent, QEMU_AGENT_EVENT_SHUTDOWN);\n\n    qemuProcessShutdownOrReboot(driver, vm);\n\n unlock:\n    virObjectUnlock(vm);\n    virObjectEventStateQueue(driver->domainEventState, event);\n\n    return 0;\n}\n\n\nstatic int\nqemuProcessHandleStop(qemuMonitorPtr mon G_GNUC_UNUSED,\n                      virDomainObjPtr vm,\n                      void *opaque)\n{\n    virQEMUDriverPtr driver = opaque;\n    virObjectEventPtr event = NULL;\n    virDomainPausedReason reason;\n    virDomainEventSuspendedDetailType detail;\n    g_autoptr(virQEMUDriverConfig) cfg = virQEMUDriverGetConfig(driver);\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n\n    virObjectLock(vm);\n\n    reason = priv->pausedReason;\n    priv->pausedReason = VIR_DOMAIN_PAUSED_UNKNOWN;\n\n    /* In case of fake reboot qemu paused state is transient so don't\n     * reveal it in domain state nor sent events */\n    if (virDomainObjGetState(vm, NULL) == VIR_DOMAIN_RUNNING &&\n        !priv->pausedShutdown) {\n        if (priv->job.asyncJob == QEMU_ASYNC_JOB_MIGRATION_OUT) {\n            if (priv->job.current->status == QEMU_DOMAIN_JOB_STATUS_POSTCOPY)\n                reason = VIR_DOMAIN_PAUSED_POSTCOPY;\n            else\n                reason = VIR_DOMAIN_PAUSED_MIGRATION;\n        }\n\n        detail = qemuDomainPausedReasonToSuspendedEvent(reason);\n        VIR_DEBUG(\"Transitioned guest %s to paused state, \"\n                  \"reason %s, event detail %d\",\n                  vm->def->name, virDomainPausedReasonTypeToString(reason),\n                  detail);\n\n        if (priv->job.current)\n            ignore_value(virTimeMillisNow(&priv->job.current->stopped));\n\n        if (priv->signalStop)\n            virDomainObjBroadcast(vm);\n\n        virDomainObjSetState(vm, VIR_DOMAIN_PAUSED, reason);\n        event = virDomainEventLifecycleNewFromObj(vm,\n                                                  VIR_DOMAIN_EVENT_SUSPENDED,\n                                                  detail);\n\n        VIR_FREE(priv->lockState);\n        if (virDomainLockProcessPause(driver->lockManager, vm, &priv->lockState) < 0)\n            VIR_WARN(\"Unable to release lease on %s\", vm->def->name);\n        VIR_DEBUG(\"Preserving lock state '%s'\", NULLSTR(priv->lockState));\n\n        if (virDomainObjSave(vm, driver->xmlopt, cfg->stateDir) < 0) {\n            VIR_WARN(\"Unable to save status on vm %s after state change\",\n                     vm->def->name);\n        }\n    }\n\n    virObjectUnlock(vm);\n    virObjectEventStateQueue(driver->domainEventState, event);\n\n    return 0;\n}\n\n\nstatic int\nqemuProcessHandleResume(qemuMonitorPtr mon G_GNUC_UNUSED,\n                        virDomainObjPtr vm,\n                        void *opaque)\n{\n    virQEMUDriverPtr driver = opaque;\n    virObjectEventPtr event = NULL;\n    g_autoptr(virQEMUDriverConfig) cfg = virQEMUDriverGetConfig(driver);\n    qemuDomainObjPrivatePtr priv;\n    virDomainRunningReason reason = VIR_DOMAIN_RUNNING_UNPAUSED;\n    virDomainEventResumedDetailType eventDetail;\n\n    virObjectLock(vm);\n\n    priv = vm->privateData;\n    if (priv->runningReason != VIR_DOMAIN_RUNNING_UNKNOWN) {\n        reason = priv->runningReason;\n        priv->runningReason = VIR_DOMAIN_RUNNING_UNKNOWN;\n    }\n\n    if (virDomainObjGetState(vm, NULL) != VIR_DOMAIN_RUNNING) {\n        eventDetail = qemuDomainRunningReasonToResumeEvent(reason);\n        VIR_DEBUG(\"Transitioned guest %s into running state, reason '%s', \"\n                  \"event detail %d\",\n                  vm->def->name, virDomainRunningReasonTypeToString(reason),\n                  eventDetail);\n\n        virDomainObjSetState(vm, VIR_DOMAIN_RUNNING, reason);\n        event = virDomainEventLifecycleNewFromObj(vm,\n                                                  VIR_DOMAIN_EVENT_RESUMED,\n                                                  eventDetail);\n\n        if (virDomainObjSave(vm, driver->xmlopt, cfg->stateDir) < 0) {\n            VIR_WARN(\"Unable to save status on vm %s after state change\",\n                     vm->def->name);\n        }\n    }\n\n    virObjectUnlock(vm);\n    virObjectEventStateQueue(driver->domainEventState, event);\n    return 0;\n}\n\nstatic int\nqemuProcessHandleRTCChange(qemuMonitorPtr mon G_GNUC_UNUSED,\n                           virDomainObjPtr vm,\n                           long long offset,\n                           void *opaque)\n{\n    virQEMUDriverPtr driver = opaque;\n    virObjectEventPtr event = NULL;\n    g_autoptr(virQEMUDriverConfig) cfg = virQEMUDriverGetConfig(driver);\n\n    virObjectLock(vm);\n\n    if (vm->def->clock.offset == VIR_DOMAIN_CLOCK_OFFSET_VARIABLE) {\n        /* when a basedate is manually given on the qemu commandline\n         * rather than simply \"-rtc base=utc\", the offset sent by qemu\n         * in this event is *not* the new offset from UTC, but is\n         * instead the new offset from the *original basedate* +\n         * uptime. For example, if the original offset was 3600 and\n         * the guest clock has been advanced by 10 seconds, qemu will\n         * send \"10\" in the event - this means that the new offset\n         * from UTC is 3610, *not* 10. If the guest clock is advanced\n         * by another 10 seconds, qemu will now send \"20\" - i.e. each\n         * event is the sum of the most recent change and all previous\n         * changes since the domain was started. Fortunately, we have\n         * saved the initial offset in \"adjustment0\", so to arrive at\n         * the proper new \"adjustment\", we just add the most recent\n         * offset to adjustment0.\n         */\n        offset += vm->def->clock.data.variable.adjustment0;\n        vm->def->clock.data.variable.adjustment = offset;\n\n        if (virDomainObjSave(vm, driver->xmlopt, cfg->stateDir) < 0)\n           VIR_WARN(\"unable to save domain status with RTC change\");\n    }\n\n    event = virDomainEventRTCChangeNewFromObj(vm, offset);\n\n    virObjectUnlock(vm);\n\n    virObjectEventStateQueue(driver->domainEventState, event);\n    return 0;\n}\n\n\nstatic int\nqemuProcessHandleWatchdog(qemuMonitorPtr mon G_GNUC_UNUSED,\n                          virDomainObjPtr vm,\n                          int action,\n                          void *opaque)\n{\n    virQEMUDriverPtr driver = opaque;\n    virObjectEventPtr watchdogEvent = NULL;\n    virObjectEventPtr lifecycleEvent = NULL;\n    g_autoptr(virQEMUDriverConfig) cfg = virQEMUDriverGetConfig(driver);\n\n    virObjectLock(vm);\n    watchdogEvent = virDomainEventWatchdogNewFromObj(vm, action);\n\n    if (action == VIR_DOMAIN_EVENT_WATCHDOG_PAUSE &&\n        virDomainObjGetState(vm, NULL) == VIR_DOMAIN_RUNNING) {\n        qemuDomainObjPrivatePtr priv = vm->privateData;\n        VIR_DEBUG(\"Transitioned guest %s to paused state due to watchdog\", vm->def->name);\n\n        virDomainObjSetState(vm, VIR_DOMAIN_PAUSED, VIR_DOMAIN_PAUSED_WATCHDOG);\n        lifecycleEvent = virDomainEventLifecycleNewFromObj(vm,\n                                                  VIR_DOMAIN_EVENT_SUSPENDED,\n                                                  VIR_DOMAIN_EVENT_SUSPENDED_WATCHDOG);\n\n        VIR_FREE(priv->lockState);\n        if (virDomainLockProcessPause(driver->lockManager, vm, &priv->lockState) < 0)\n            VIR_WARN(\"Unable to release lease on %s\", vm->def->name);\n        VIR_DEBUG(\"Preserving lock state '%s'\", NULLSTR(priv->lockState));\n\n        if (virDomainObjSave(vm, driver->xmlopt, cfg->stateDir) < 0) {\n            VIR_WARN(\"Unable to save status on vm %s after watchdog event\",\n                     vm->def->name);\n        }\n    }\n\n    if (vm->def->watchdog->action == VIR_DOMAIN_WATCHDOG_ACTION_DUMP) {\n        struct qemuProcessEvent *processEvent;\n        processEvent = g_new0(struct qemuProcessEvent, 1);\n\n        processEvent->eventType = QEMU_PROCESS_EVENT_WATCHDOG;\n        processEvent->action = VIR_DOMAIN_WATCHDOG_ACTION_DUMP;\n        /* Hold an extra reference because we can't allow 'vm' to be\n         * deleted before handling watchdog event is finished.\n         */\n        processEvent->vm = virObjectRef(vm);\n        if (virThreadPoolSendJob(driver->workerPool, 0, processEvent) < 0) {\n            virObjectUnref(vm);\n            qemuProcessEventFree(processEvent);\n        }\n    }\n\n    virObjectUnlock(vm);\n    virObjectEventStateQueue(driver->domainEventState, watchdogEvent);\n    virObjectEventStateQueue(driver->domainEventState, lifecycleEvent);\n\n    return 0;\n}\n\n\nstatic int\nqemuProcessHandleIOError(qemuMonitorPtr mon G_GNUC_UNUSED,\n                         virDomainObjPtr vm,\n                         const char *diskAlias,\n                         const char *nodename,\n                         int action,\n                         const char *reason,\n                         void *opaque)\n{\n    virQEMUDriverPtr driver = opaque;\n    virObjectEventPtr ioErrorEvent = NULL;\n    virObjectEventPtr ioErrorEvent2 = NULL;\n    virObjectEventPtr lifecycleEvent = NULL;\n    const char *srcPath;\n    const char *devAlias;\n    virDomainDiskDefPtr disk;\n    g_autoptr(virQEMUDriverConfig) cfg = virQEMUDriverGetConfig(driver);\n\n    virObjectLock(vm);\n\n    if (*diskAlias == '\\0')\n        diskAlias = NULL;\n\n    if (diskAlias)\n        disk = qemuProcessFindDomainDiskByAliasOrQOM(vm, diskAlias, NULL);\n    else if (nodename)\n        disk = qemuDomainDiskLookupByNodename(vm->def, NULL, nodename, NULL);\n    else\n        disk = NULL;\n\n    if (disk) {\n        srcPath = virDomainDiskGetSource(disk);\n        devAlias = disk->info.alias;\n    } else {\n        srcPath = \"\";\n        devAlias = \"\";\n    }\n\n    ioErrorEvent = virDomainEventIOErrorNewFromObj(vm, srcPath, devAlias, action);\n    ioErrorEvent2 = virDomainEventIOErrorReasonNewFromObj(vm, srcPath, devAlias, action, reason);\n\n    if (action == VIR_DOMAIN_EVENT_IO_ERROR_PAUSE &&\n        virDomainObjGetState(vm, NULL) == VIR_DOMAIN_RUNNING) {\n        qemuDomainObjPrivatePtr priv = vm->privateData;\n        VIR_DEBUG(\"Transitioned guest %s to paused state due to IO error\", vm->def->name);\n\n        if (priv->signalIOError)\n            virDomainObjBroadcast(vm);\n\n        virDomainObjSetState(vm, VIR_DOMAIN_PAUSED, VIR_DOMAIN_PAUSED_IOERROR);\n        lifecycleEvent = virDomainEventLifecycleNewFromObj(vm,\n                                                  VIR_DOMAIN_EVENT_SUSPENDED,\n                                                  VIR_DOMAIN_EVENT_SUSPENDED_IOERROR);\n\n        VIR_FREE(priv->lockState);\n        if (virDomainLockProcessPause(driver->lockManager, vm, &priv->lockState) < 0)\n            VIR_WARN(\"Unable to release lease on %s\", vm->def->name);\n        VIR_DEBUG(\"Preserving lock state '%s'\", NULLSTR(priv->lockState));\n\n        if (virDomainObjSave(vm, driver->xmlopt, cfg->stateDir) < 0)\n            VIR_WARN(\"Unable to save status on vm %s after IO error\", vm->def->name);\n    }\n    virObjectUnlock(vm);\n\n    virObjectEventStateQueue(driver->domainEventState, ioErrorEvent);\n    virObjectEventStateQueue(driver->domainEventState, ioErrorEvent2);\n    virObjectEventStateQueue(driver->domainEventState, lifecycleEvent);\n    return 0;\n}\n\nstatic int\nqemuProcessHandleBlockJob(qemuMonitorPtr mon G_GNUC_UNUSED,\n                          virDomainObjPtr vm,\n                          const char *diskAlias,\n                          int type,\n                          int status,\n                          const char *error,\n                          void *opaque)\n{\n    qemuDomainObjPrivatePtr priv;\n    virQEMUDriverPtr driver = opaque;\n    struct qemuProcessEvent *processEvent = NULL;\n    virDomainDiskDefPtr disk;\n    g_autoptr(qemuBlockJobData) job = NULL;\n    char *data = NULL;\n\n    virObjectLock(vm);\n\n    priv = vm->privateData;\n\n    /* with QEMU_CAPS_BLOCKDEV we handle block job events via JOB_STATUS_CHANGE */\n    if (virQEMUCapsGet(priv->qemuCaps, QEMU_CAPS_BLOCKDEV))\n        goto cleanup;\n\n    VIR_DEBUG(\"Block job for device %s (domain: %p,%s) type %d status %d\",\n              diskAlias, vm, vm->def->name, type, status);\n\n    if (!(disk = qemuProcessFindDomainDiskByAliasOrQOM(vm, diskAlias, NULL)))\n        goto cleanup;\n\n    job = qemuBlockJobDiskGetJob(disk);\n\n    if (job && job->synchronous) {\n        /* We have a SYNC API waiting for this event, dispatch it back */\n        job->newstate = status;\n        VIR_FREE(job->errmsg);\n        job->errmsg = g_strdup(error);\n        virDomainObjBroadcast(vm);\n    } else {\n        /* there is no waiting SYNC API, dispatch the update to a thread */\n        processEvent = g_new0(struct qemuProcessEvent, 1);\n\n        processEvent->eventType = QEMU_PROCESS_EVENT_BLOCK_JOB;\n        data = g_strdup(diskAlias);\n        processEvent->data = data;\n        processEvent->vm = virObjectRef(vm);\n        processEvent->action = type;\n        processEvent->status = status;\n\n        if (virThreadPoolSendJob(driver->workerPool, 0, processEvent) < 0) {\n            virObjectUnref(vm);\n            goto cleanup;\n        }\n\n        processEvent = NULL;\n    }\n\n cleanup:\n    qemuProcessEventFree(processEvent);\n    virObjectUnlock(vm);\n    return 0;\n}\n\n\nstatic int\nqemuProcessHandleJobStatusChange(qemuMonitorPtr mon G_GNUC_UNUSED,\n                                 virDomainObjPtr vm,\n                                 const char *jobname,\n                                 int status,\n                                 void *opaque)\n{\n    virQEMUDriverPtr driver = opaque;\n    qemuDomainObjPrivatePtr priv;\n    struct qemuProcessEvent *processEvent = NULL;\n    qemuBlockJobDataPtr job = NULL;\n    int jobnewstate;\n\n    virObjectLock(vm);\n    priv = vm->privateData;\n\n    VIR_DEBUG(\"job '%s'(domain: %p,%s) state changed to '%s'(%d)\",\n              jobname, vm, vm->def->name,\n              qemuMonitorJobStatusTypeToString(status), status);\n\n    if (!virQEMUCapsGet(priv->qemuCaps, QEMU_CAPS_BLOCKDEV)) {\n        VIR_DEBUG(\"job '%s' handled by old blockjob handler\", jobname);\n        goto cleanup;\n    }\n\n    if ((jobnewstate = qemuBlockjobConvertMonitorStatus(status)) == QEMU_BLOCKJOB_STATE_LAST)\n        goto cleanup;\n\n    if (!(job = virHashLookup(priv->blockjobs, jobname))) {\n        VIR_DEBUG(\"job '%s' not registered\", jobname);\n        goto cleanup;\n    }\n\n    job->newstate = jobnewstate;\n\n    if (job->synchronous) {\n        VIR_DEBUG(\"job '%s' handled synchronously\", jobname);\n        virDomainObjBroadcast(vm);\n    } else {\n        VIR_DEBUG(\"job '%s' handled by event thread\", jobname);\n        processEvent = g_new0(struct qemuProcessEvent, 1);\n\n        processEvent->eventType = QEMU_PROCESS_EVENT_JOB_STATUS_CHANGE;\n        processEvent->vm = virObjectRef(vm);\n        processEvent->data = virObjectRef(job);\n\n        if (virThreadPoolSendJob(driver->workerPool, 0, processEvent) < 0) {\n            virObjectUnref(vm);\n            goto cleanup;\n        }\n\n        processEvent = NULL;\n    }\n\n cleanup:\n    qemuProcessEventFree(processEvent);\n    virObjectUnlock(vm);\n    return 0;\n}\n\n\nstatic int\nqemuProcessHandleGraphics(qemuMonitorPtr mon G_GNUC_UNUSED,\n                          virDomainObjPtr vm,\n                          int phase,\n                          int localFamily,\n                          const char *localNode,\n                          const char *localService,\n                          int remoteFamily,\n                          const char *remoteNode,\n                          const char *remoteService,\n                          const char *authScheme,\n                          const char *x509dname,\n                          const char *saslUsername,\n                          void *opaque)\n{\n    virQEMUDriverPtr driver = opaque;\n    virObjectEventPtr event;\n    virDomainEventGraphicsAddressPtr localAddr = NULL;\n    virDomainEventGraphicsAddressPtr remoteAddr = NULL;\n    virDomainEventGraphicsSubjectPtr subject = NULL;\n    size_t i;\n\n    localAddr = g_new0(virDomainEventGraphicsAddress, 1);\n    localAddr->family = localFamily;\n    localAddr->service = g_strdup(localService);\n    localAddr->node = g_strdup(localNode);\n\n    remoteAddr = g_new0(virDomainEventGraphicsAddress, 1);\n    remoteAddr->family = remoteFamily;\n    remoteAddr->service = g_strdup(remoteService);\n    remoteAddr->node = g_strdup(remoteNode);\n\n    subject = g_new0(virDomainEventGraphicsSubject, 1);\n    if (x509dname) {\n        if (VIR_REALLOC_N(subject->identities, subject->nidentity+1) < 0)\n            goto error;\n        subject->nidentity++;\n        subject->identities[subject->nidentity - 1].type = g_strdup(\"x509dname\");\n        subject->identities[subject->nidentity - 1].name = g_strdup(x509dname);\n    }\n    if (saslUsername) {\n        if (VIR_REALLOC_N(subject->identities, subject->nidentity+1) < 0)\n            goto error;\n        subject->nidentity++;\n        subject->identities[subject->nidentity - 1].type = g_strdup(\"saslUsername\");\n        subject->identities[subject->nidentity - 1].name = g_strdup(saslUsername);\n    }\n\n    virObjectLock(vm);\n    event = virDomainEventGraphicsNewFromObj(vm, phase, localAddr, remoteAddr, authScheme, subject);\n    virObjectUnlock(vm);\n\n    virObjectEventStateQueue(driver->domainEventState, event);\n\n    return 0;\n\n error:\n    VIR_FREE(localAddr->service);\n    VIR_FREE(localAddr->node);\n    VIR_FREE(localAddr);\n\n    VIR_FREE(remoteAddr->service);\n    VIR_FREE(remoteAddr->node);\n    VIR_FREE(remoteAddr);\n\n    for (i = 0; i < subject->nidentity; i++) {\n        VIR_FREE(subject->identities[i].type);\n        VIR_FREE(subject->identities[i].name);\n    }\n    VIR_FREE(subject->identities);\n    VIR_FREE(subject);\n\n    return -1;\n}\n\nstatic int\nqemuProcessHandleTrayChange(qemuMonitorPtr mon G_GNUC_UNUSED,\n                            virDomainObjPtr vm,\n                            const char *devAlias,\n                            const char *devid,\n                            int reason,\n                            void *opaque)\n{\n    virQEMUDriverPtr driver = opaque;\n    virObjectEventPtr event = NULL;\n    virDomainDiskDefPtr disk;\n    g_autoptr(virQEMUDriverConfig) cfg = virQEMUDriverGetConfig(driver);\n\n    virObjectLock(vm);\n    disk = qemuProcessFindDomainDiskByAliasOrQOM(vm, devAlias, devid);\n\n    if (disk) {\n        event = virDomainEventTrayChangeNewFromObj(vm, disk->info.alias, reason);\n        /* Update disk tray status */\n        if (reason == VIR_DOMAIN_EVENT_TRAY_CHANGE_OPEN)\n            disk->tray_status = VIR_DOMAIN_DISK_TRAY_OPEN;\n        else if (reason == VIR_DOMAIN_EVENT_TRAY_CHANGE_CLOSE)\n            disk->tray_status = VIR_DOMAIN_DISK_TRAY_CLOSED;\n\n        if (virDomainObjSave(vm, driver->xmlopt, cfg->stateDir) < 0) {\n            VIR_WARN(\"Unable to save status on vm %s after tray moved event\",\n                     vm->def->name);\n        }\n\n        virDomainObjBroadcast(vm);\n    }\n\n    virObjectUnlock(vm);\n    virObjectEventStateQueue(driver->domainEventState, event);\n    return 0;\n}\n\nstatic int\nqemuProcessHandlePMWakeup(qemuMonitorPtr mon G_GNUC_UNUSED,\n                          virDomainObjPtr vm,\n                          void *opaque)\n{\n    virQEMUDriverPtr driver = opaque;\n    virObjectEventPtr event = NULL;\n    virObjectEventPtr lifecycleEvent = NULL;\n    g_autoptr(virQEMUDriverConfig) cfg = virQEMUDriverGetConfig(driver);\n\n    virObjectLock(vm);\n    event = virDomainEventPMWakeupNewFromObj(vm);\n\n    /* Don't set domain status back to running if it wasn't paused\n     * from guest side, otherwise it can just cause confusion.\n     */\n    if (virDomainObjGetState(vm, NULL) == VIR_DOMAIN_PMSUSPENDED) {\n        VIR_DEBUG(\"Transitioned guest %s from pmsuspended to running \"\n                  \"state due to QMP wakeup event\", vm->def->name);\n\n        virDomainObjSetState(vm, VIR_DOMAIN_RUNNING,\n                             VIR_DOMAIN_RUNNING_WAKEUP);\n        lifecycleEvent = virDomainEventLifecycleNewFromObj(vm,\n                                                  VIR_DOMAIN_EVENT_STARTED,\n                                                  VIR_DOMAIN_EVENT_STARTED_WAKEUP);\n\n        if (virDomainObjSave(vm, driver->xmlopt, cfg->stateDir) < 0) {\n            VIR_WARN(\"Unable to save status on vm %s after wakeup event\",\n                     vm->def->name);\n        }\n    }\n\n    virObjectUnlock(vm);\n    virObjectEventStateQueue(driver->domainEventState, event);\n    virObjectEventStateQueue(driver->domainEventState, lifecycleEvent);\n    return 0;\n}\n\nstatic int\nqemuProcessHandlePMSuspend(qemuMonitorPtr mon G_GNUC_UNUSED,\n                           virDomainObjPtr vm,\n                           void *opaque)\n{\n    virQEMUDriverPtr driver = opaque;\n    virObjectEventPtr event = NULL;\n    virObjectEventPtr lifecycleEvent = NULL;\n    g_autoptr(virQEMUDriverConfig) cfg = virQEMUDriverGetConfig(driver);\n\n    virObjectLock(vm);\n    event = virDomainEventPMSuspendNewFromObj(vm);\n\n    if (virDomainObjGetState(vm, NULL) == VIR_DOMAIN_RUNNING) {\n        qemuDomainObjPrivatePtr priv = vm->privateData;\n        VIR_DEBUG(\"Transitioned guest %s to pmsuspended state due to \"\n                  \"QMP suspend event\", vm->def->name);\n\n        virDomainObjSetState(vm, VIR_DOMAIN_PMSUSPENDED,\n                             VIR_DOMAIN_PMSUSPENDED_UNKNOWN);\n        lifecycleEvent =\n            virDomainEventLifecycleNewFromObj(vm,\n                                     VIR_DOMAIN_EVENT_PMSUSPENDED,\n                                     VIR_DOMAIN_EVENT_PMSUSPENDED_MEMORY);\n\n        if (virDomainObjSave(vm, driver->xmlopt, cfg->stateDir) < 0) {\n            VIR_WARN(\"Unable to save status on vm %s after suspend event\",\n                     vm->def->name);\n        }\n\n        if (priv->agent)\n            qemuAgentNotifyEvent(priv->agent, QEMU_AGENT_EVENT_SUSPEND);\n    }\n\n    virObjectUnlock(vm);\n\n    virObjectEventStateQueue(driver->domainEventState, event);\n    virObjectEventStateQueue(driver->domainEventState, lifecycleEvent);\n    return 0;\n}\n\nstatic int\nqemuProcessHandleBalloonChange(qemuMonitorPtr mon G_GNUC_UNUSED,\n                               virDomainObjPtr vm,\n                               unsigned long long actual,\n                               void *opaque)\n{\n    virQEMUDriverPtr driver = opaque;\n    virObjectEventPtr event = NULL;\n    g_autoptr(virQEMUDriverConfig) cfg = virQEMUDriverGetConfig(driver);\n\n    virObjectLock(vm);\n    event = virDomainEventBalloonChangeNewFromObj(vm, actual);\n\n    VIR_DEBUG(\"Updating balloon from %lld to %lld kb\",\n              vm->def->mem.cur_balloon, actual);\n    vm->def->mem.cur_balloon = actual;\n\n    if (virDomainObjSave(vm, driver->xmlopt, cfg->stateDir) < 0)\n        VIR_WARN(\"unable to save domain status with balloon change\");\n\n    virObjectUnlock(vm);\n\n    virObjectEventStateQueue(driver->domainEventState, event);\n    return 0;\n}\n\nstatic int\nqemuProcessHandlePMSuspendDisk(qemuMonitorPtr mon G_GNUC_UNUSED,\n                               virDomainObjPtr vm,\n                               void *opaque)\n{\n    virQEMUDriverPtr driver = opaque;\n    virObjectEventPtr event = NULL;\n    virObjectEventPtr lifecycleEvent = NULL;\n    g_autoptr(virQEMUDriverConfig) cfg = virQEMUDriverGetConfig(driver);\n\n    virObjectLock(vm);\n    event = virDomainEventPMSuspendDiskNewFromObj(vm);\n\n    if (virDomainObjGetState(vm, NULL) == VIR_DOMAIN_RUNNING) {\n        qemuDomainObjPrivatePtr priv = vm->privateData;\n        VIR_DEBUG(\"Transitioned guest %s to pmsuspended state due to \"\n                  \"QMP suspend_disk event\", vm->def->name);\n\n        virDomainObjSetState(vm, VIR_DOMAIN_PMSUSPENDED,\n                             VIR_DOMAIN_PMSUSPENDED_UNKNOWN);\n        lifecycleEvent =\n            virDomainEventLifecycleNewFromObj(vm,\n                                     VIR_DOMAIN_EVENT_PMSUSPENDED,\n                                     VIR_DOMAIN_EVENT_PMSUSPENDED_DISK);\n\n        if (virDomainObjSave(vm, driver->xmlopt, cfg->stateDir) < 0) {\n            VIR_WARN(\"Unable to save status on vm %s after suspend event\",\n                     vm->def->name);\n        }\n\n        if (priv->agent)\n            qemuAgentNotifyEvent(priv->agent, QEMU_AGENT_EVENT_SUSPEND);\n    }\n\n    virObjectUnlock(vm);\n\n    virObjectEventStateQueue(driver->domainEventState, event);\n    virObjectEventStateQueue(driver->domainEventState, lifecycleEvent);\n\n    return 0;\n}\n\n\nstatic int\nqemuProcessHandleGuestPanic(qemuMonitorPtr mon G_GNUC_UNUSED,\n                            virDomainObjPtr vm,\n                            qemuMonitorEventPanicInfoPtr info,\n                            void *opaque)\n{\n    virQEMUDriverPtr driver = opaque;\n    struct qemuProcessEvent *processEvent;\n\n    virObjectLock(vm);\n    processEvent = g_new0(struct qemuProcessEvent, 1);\n\n    processEvent->eventType = QEMU_PROCESS_EVENT_GUESTPANIC;\n    processEvent->action = vm->def->onCrash;\n    processEvent->data = info;\n    /* Hold an extra reference because we can't allow 'vm' to be\n     * deleted before handling guest panic event is finished.\n     */\n    processEvent->vm = virObjectRef(vm);\n\n    if (virThreadPoolSendJob(driver->workerPool, 0, processEvent) < 0) {\n        virObjectUnref(vm);\n        qemuProcessEventFree(processEvent);\n    }\n\n    virObjectUnlock(vm);\n\n    return 0;\n}\n\n\nint\nqemuProcessHandleDeviceDeleted(qemuMonitorPtr mon G_GNUC_UNUSED,\n                               virDomainObjPtr vm,\n                               const char *devAlias,\n                               void *opaque)\n{\n    virQEMUDriverPtr driver = opaque;\n    struct qemuProcessEvent *processEvent = NULL;\n    char *data;\n\n    virObjectLock(vm);\n\n    VIR_DEBUG(\"Device %s removed from domain %p %s\",\n              devAlias, vm, vm->def->name);\n\n    if (qemuDomainSignalDeviceRemoval(vm, devAlias,\n                                      QEMU_DOMAIN_UNPLUGGING_DEVICE_STATUS_OK))\n        goto cleanup;\n\n    processEvent = g_new0(struct qemuProcessEvent, 1);\n\n    processEvent->eventType = QEMU_PROCESS_EVENT_DEVICE_DELETED;\n    data = g_strdup(devAlias);\n    processEvent->data = data;\n    processEvent->vm = virObjectRef(vm);\n\n    if (virThreadPoolSendJob(driver->workerPool, 0, processEvent) < 0) {\n        virObjectUnref(vm);\n        goto error;\n    }\n\n cleanup:\n    virObjectUnlock(vm);\n    return 0;\n error:\n    qemuProcessEventFree(processEvent);\n    goto cleanup;\n}\n\n\n/**\n *\n * Meaning of fields reported by the event according to the ACPI standard:\n * @source:\n *  0x00 - 0xff: Notification values, as passed at the request time\n *  0x100: Operating System Shutdown Processing\n *  0x103: Ejection processing\n *  0x200: Insertion processing\n *  other values are reserved\n *\n * @status:\n *   general values\n *     0x00: success\n *     0x01: non-specific failure\n *     0x02: unrecognized notify code\n *     0x03 - 0x7f: reserved\n *     other values are specific to the notification type (see below)\n *\n *   for the 0x100 source the following additional codes are standardized:\n *     0x80: OS Shutdown request denied\n *     0x81: OS Shutdown in progress\n *     0x82: OS Shutdown completed\n *     0x83: OS Graceful shutdown not supported\n *     other higher values are reserved\n *\n *  for the 0x003 (Ejection request) and 0x103 (Ejection processing) source\n *  the following additional codes are standardized:\n *     0x80: Device ejection not supported by OSPM\n *     0x81: Device in use by application\n *     0x82: Device Busy\n *     0x83: Ejection dependency is busy or not supported for ejection by OSPM\n *     0x84: Ejection is in progress (pending)\n *     other higher values are reserved\n *\n *  for the 0x200 source the following additional codes are standardized:\n *     0x80: Device insertion in progress (pending)\n *     0x81: Device driver load failure\n *     0x82: Device insertion not supported by OSPM\n *     0x83-0x8F: Reserved\n *     0x90-0x9F: Insertion failure - Resources Unavailable as described by the\n *                                    following bit encodings:\n *                                    Bit [3]: Bus or Segment Numbers\n *                                    Bit [2]: Interrupts\n *                                    Bit [1]: I/O\n *                                    Bit [0]: Memory\n *     other higher values are reserved\n *\n * Other fields and semantics are specific to the qemu handling of the event.\n *  - @alias may be NULL for successful unplug operations\n *  - @slotType describes the device type a bit more closely, currently the\n *    only known value is 'DIMM'\n *  - @slot describes the specific device\n *\n *  Note that qemu does not emit the event for all the documented sources or\n *  devices.\n */\nstatic int\nqemuProcessHandleAcpiOstInfo(qemuMonitorPtr mon G_GNUC_UNUSED,\n                             virDomainObjPtr vm,\n                             const char *alias,\n                             const char *slotType,\n                             const char *slot,\n                             unsigned int source,\n                             unsigned int status,\n                             void *opaque)\n{\n    virQEMUDriverPtr driver = opaque;\n    virObjectEventPtr event = NULL;\n\n    virObjectLock(vm);\n\n    VIR_DEBUG(\"ACPI OST info for device %s domain %p %s. \"\n              \"slotType='%s' slot='%s' source=%u status=%u\",\n              NULLSTR(alias), vm, vm->def->name, slotType, slot, source, status);\n\n    if (!alias)\n        goto cleanup;\n\n    if (STREQ(slotType, \"DIMM\")) {\n        if ((source == 0x003 || source == 0x103) &&\n            (status == 0x01 || (status >= 0x80 && status <= 0x83))) {\n            qemuDomainSignalDeviceRemoval(vm, alias,\n                                          QEMU_DOMAIN_UNPLUGGING_DEVICE_STATUS_GUEST_REJECTED);\n\n            event = virDomainEventDeviceRemovalFailedNewFromObj(vm, alias);\n        }\n    }\n\n cleanup:\n    virObjectUnlock(vm);\n    virObjectEventStateQueue(driver->domainEventState, event);\n\n    return 0;\n}\n\n\nstatic int\nqemuProcessHandleBlockThreshold(qemuMonitorPtr mon G_GNUC_UNUSED,\n                                virDomainObjPtr vm,\n                                const char *nodename,\n                                unsigned long long threshold,\n                                unsigned long long excess,\n                                void *opaque)\n{\n    qemuDomainObjPrivatePtr priv;\n    virQEMUDriverPtr driver = opaque;\n    virObjectEventPtr eventSource = NULL;\n    virObjectEventPtr eventDevice = NULL;\n    virDomainDiskDefPtr disk;\n    virStorageSourcePtr src;\n    const char *path = NULL;\n\n    virObjectLock(vm);\n\n    priv  = vm->privateData;\n\n    VIR_DEBUG(\"BLOCK_WRITE_THRESHOLD event for block node '%s' in domain %p %s:\"\n              \"threshold '%llu' exceeded by '%llu'\",\n              nodename, vm, vm->def->name, threshold, excess);\n\n    if ((disk = qemuDomainDiskLookupByNodename(vm->def, priv->backup, nodename, &src))) {\n        if (virStorageSourceIsLocalStorage(src))\n            path = src->path;\n\n        if (src == disk->src) {\n            g_autofree char *dev = qemuDomainDiskBackingStoreGetName(disk, 0);\n\n            eventDevice = virDomainEventBlockThresholdNewFromObj(vm, dev, path,\n                                                                 threshold, excess);\n        }\n\n        if (src->id != 0) {\n            g_autofree char *dev = qemuDomainDiskBackingStoreGetName(disk, src->id);\n\n            eventSource = virDomainEventBlockThresholdNewFromObj(vm, dev, path,\n                                                                 threshold, excess);\n        }\n    }\n\n    virObjectUnlock(vm);\n    virObjectEventStateQueue(driver->domainEventState, eventDevice);\n    virObjectEventStateQueue(driver->domainEventState, eventSource);\n\n    return 0;\n}\n\n\nstatic int\nqemuProcessHandleNicRxFilterChanged(qemuMonitorPtr mon G_GNUC_UNUSED,\n                                    virDomainObjPtr vm,\n                                    const char *devAlias,\n                                    void *opaque)\n{\n    virQEMUDriverPtr driver = opaque;\n    struct qemuProcessEvent *processEvent = NULL;\n    char *data;\n\n    virObjectLock(vm);\n\n    VIR_DEBUG(\"Device %s RX Filter changed in domain %p %s\",\n              devAlias, vm, vm->def->name);\n\n    processEvent = g_new0(struct qemuProcessEvent, 1);\n\n    processEvent->eventType = QEMU_PROCESS_EVENT_NIC_RX_FILTER_CHANGED;\n    data = g_strdup(devAlias);\n    processEvent->data = data;\n    processEvent->vm = virObjectRef(vm);\n\n    if (virThreadPoolSendJob(driver->workerPool, 0, processEvent) < 0) {\n        virObjectUnref(vm);\n        goto error;\n    }\n\n cleanup:\n    virObjectUnlock(vm);\n    return 0;\n error:\n    qemuProcessEventFree(processEvent);\n    goto cleanup;\n}\n\n\nstatic int\nqemuProcessHandleSerialChanged(qemuMonitorPtr mon G_GNUC_UNUSED,\n                               virDomainObjPtr vm,\n                               const char *devAlias,\n                               bool connected,\n                               void *opaque)\n{\n    virQEMUDriverPtr driver = opaque;\n    struct qemuProcessEvent *processEvent = NULL;\n    char *data;\n\n    virObjectLock(vm);\n\n    VIR_DEBUG(\"Serial port %s state changed to '%d' in domain %p %s\",\n              devAlias, connected, vm, vm->def->name);\n\n    processEvent = g_new0(struct qemuProcessEvent, 1);\n\n    processEvent->eventType = QEMU_PROCESS_EVENT_SERIAL_CHANGED;\n    data = g_strdup(devAlias);\n    processEvent->data = data;\n    processEvent->action = connected;\n    processEvent->vm = virObjectRef(vm);\n\n    if (virThreadPoolSendJob(driver->workerPool, 0, processEvent) < 0) {\n        virObjectUnref(vm);\n        goto error;\n    }\n\n cleanup:\n    virObjectUnlock(vm);\n    return 0;\n error:\n    qemuProcessEventFree(processEvent);\n    goto cleanup;\n}\n\n\nstatic int\nqemuProcessHandleSpiceMigrated(qemuMonitorPtr mon G_GNUC_UNUSED,\n                               virDomainObjPtr vm,\n                               void *opaque G_GNUC_UNUSED)\n{\n    qemuDomainObjPrivatePtr priv;\n    qemuDomainJobPrivatePtr jobPriv;\n\n    virObjectLock(vm);\n\n    VIR_DEBUG(\"Spice migration completed for domain %p %s\",\n              vm, vm->def->name);\n\n    priv = vm->privateData;\n    jobPriv = priv->job.privateData;\n    if (priv->job.asyncJob != QEMU_ASYNC_JOB_MIGRATION_OUT) {\n        VIR_DEBUG(\"got SPICE_MIGRATE_COMPLETED event without a migration job\");\n        goto cleanup;\n    }\n\n    jobPriv->spiceMigrated = true;\n    virDomainObjBroadcast(vm);\n\n cleanup:\n    virObjectUnlock(vm);\n    return 0;\n}\n\n\nstatic int\nqemuProcessHandleMigrationStatus(qemuMonitorPtr mon G_GNUC_UNUSED,\n                                 virDomainObjPtr vm,\n                                 int status,\n                                 void *opaque)\n{\n    qemuDomainObjPrivatePtr priv;\n    virQEMUDriverPtr driver = opaque;\n    virObjectEventPtr event = NULL;\n    g_autoptr(virQEMUDriverConfig) cfg = virQEMUDriverGetConfig(driver);\n    int reason;\n\n    virObjectLock(vm);\n\n    VIR_DEBUG(\"Migration of domain %p %s changed state to %s\",\n              vm, vm->def->name,\n              qemuMonitorMigrationStatusTypeToString(status));\n\n    priv = vm->privateData;\n    if (priv->job.asyncJob == QEMU_ASYNC_JOB_NONE) {\n        VIR_DEBUG(\"got MIGRATION event without a migration job\");\n        goto cleanup;\n    }\n\n    priv->job.current->stats.mig.status = status;\n    virDomainObjBroadcast(vm);\n\n    if (status == QEMU_MONITOR_MIGRATION_STATUS_POSTCOPY &&\n        priv->job.asyncJob == QEMU_ASYNC_JOB_MIGRATION_OUT &&\n        virDomainObjGetState(vm, &reason) == VIR_DOMAIN_PAUSED &&\n        reason == VIR_DOMAIN_PAUSED_MIGRATION) {\n        VIR_DEBUG(\"Correcting paused state reason for domain %s to %s\",\n                  vm->def->name,\n                  virDomainPausedReasonTypeToString(VIR_DOMAIN_PAUSED_POSTCOPY));\n\n        virDomainObjSetState(vm, VIR_DOMAIN_PAUSED, VIR_DOMAIN_PAUSED_POSTCOPY);\n        event = virDomainEventLifecycleNewFromObj(vm,\n                                                  VIR_DOMAIN_EVENT_SUSPENDED,\n                                                  VIR_DOMAIN_EVENT_SUSPENDED_POSTCOPY);\n\n        if (virDomainObjSave(vm, driver->xmlopt, cfg->stateDir) < 0) {\n            VIR_WARN(\"Unable to save status on vm %s after state change\",\n                     vm->def->name);\n        }\n    }\n\n cleanup:\n    virObjectUnlock(vm);\n    virObjectEventStateQueue(driver->domainEventState, event);\n    return 0;\n}\n\n\nstatic int\nqemuProcessHandleMigrationPass(qemuMonitorPtr mon G_GNUC_UNUSED,\n                               virDomainObjPtr vm,\n                               int pass,\n                               void *opaque)\n{\n    virQEMUDriverPtr driver = opaque;\n    qemuDomainObjPrivatePtr priv;\n\n    virObjectLock(vm);\n\n    VIR_DEBUG(\"Migrating domain %p %s, iteration %d\",\n              vm, vm->def->name, pass);\n\n    priv = vm->privateData;\n    if (priv->job.asyncJob == QEMU_ASYNC_JOB_NONE) {\n        VIR_DEBUG(\"got MIGRATION_PASS event without a migration job\");\n        goto cleanup;\n    }\n\n    virObjectEventStateQueue(driver->domainEventState,\n                         virDomainEventMigrationIterationNewFromObj(vm, pass));\n\n cleanup:\n    virObjectUnlock(vm);\n    return 0;\n}\n\n\nstatic int\nqemuProcessHandleDumpCompleted(qemuMonitorPtr mon G_GNUC_UNUSED,\n                               virDomainObjPtr vm,\n                               int status,\n                               qemuMonitorDumpStatsPtr stats,\n                               const char *error,\n                               void *opaque G_GNUC_UNUSED)\n{\n    qemuDomainObjPrivatePtr priv;\n    qemuDomainJobPrivatePtr jobPriv;\n\n    virObjectLock(vm);\n\n    VIR_DEBUG(\"Dump completed for domain %p %s with stats=%p error='%s'\",\n              vm, vm->def->name, stats, NULLSTR(error));\n\n    priv = vm->privateData;\n    jobPriv = priv->job.privateData;\n    if (priv->job.asyncJob == QEMU_ASYNC_JOB_NONE) {\n        VIR_DEBUG(\"got DUMP_COMPLETED event without a dump_completed job\");\n        goto cleanup;\n    }\n    jobPriv->dumpCompleted = true;\n    priv->job.current->stats.dump = *stats;\n    priv->job.error = g_strdup(error);\n\n    /* Force error if extracting the DUMP_COMPLETED status failed */\n    if (!error && status < 0) {\n        priv->job.error = g_strdup(virGetLastErrorMessage());\n        priv->job.current->stats.dump.status = QEMU_MONITOR_DUMP_STATUS_FAILED;\n    }\n\n    virDomainObjBroadcast(vm);\n\n cleanup:\n    virResetLastError();\n    virObjectUnlock(vm);\n    return 0;\n}\n\n\nstatic int\nqemuProcessHandlePRManagerStatusChanged(qemuMonitorPtr mon G_GNUC_UNUSED,\n                                        virDomainObjPtr vm,\n                                        const char *prManager,\n                                        bool connected,\n                                        void *opaque)\n{\n    virQEMUDriverPtr driver = opaque;\n    qemuDomainObjPrivatePtr priv;\n    struct qemuProcessEvent *processEvent = NULL;\n    const char *managedAlias = qemuDomainGetManagedPRAlias();\n    int ret = -1;\n\n    virObjectLock(vm);\n\n    VIR_DEBUG(\"pr-manager %s status changed for domain %p %s connected=%d\",\n              prManager, vm, vm->def->name, connected);\n\n    if (connected) {\n        /* Connect events are boring. */\n        ret = 0;\n        goto cleanup;\n    }\n    /* Disconnect events are more interesting. */\n\n    if (STRNEQ(prManager, managedAlias)) {\n        VIR_DEBUG(\"pr-manager %s not managed, ignoring event\",\n                  prManager);\n        ret = 0;\n        goto cleanup;\n    }\n\n    priv = vm->privateData;\n    priv->prDaemonRunning = false;\n\n    processEvent = g_new0(struct qemuProcessEvent, 1);\n\n    processEvent->eventType = QEMU_PROCESS_EVENT_PR_DISCONNECT;\n    processEvent->vm = virObjectRef(vm);\n\n    if (virThreadPoolSendJob(driver->workerPool, 0, processEvent) < 0) {\n        qemuProcessEventFree(processEvent);\n        virObjectUnref(vm);\n        goto cleanup;\n    }\n\n    ret = 0;\n cleanup:\n    virObjectUnlock(vm);\n    return ret;\n}\n\n\nstatic int\nqemuProcessHandleRdmaGidStatusChanged(qemuMonitorPtr mon G_GNUC_UNUSED,\n                                      virDomainObjPtr vm,\n                                      const char *netdev,\n                                      bool gid_status,\n                                      unsigned long long subnet_prefix,\n                                      unsigned long long interface_id,\n                                      void *opaque)\n{\n    virQEMUDriverPtr driver = opaque;\n    struct qemuProcessEvent *processEvent = NULL;\n    qemuMonitorRdmaGidStatusPtr info = NULL;\n    int ret = -1;\n\n    virObjectLock(vm);\n\n    VIR_DEBUG(\"netdev=%s,gid_status=%d,subnet_prefix=0x%llx,interface_id=0x%llx\",\n              netdev, gid_status, subnet_prefix, interface_id);\n\n    info = g_new0(qemuMonitorRdmaGidStatus, 1);\n\n    info->netdev = g_strdup(netdev);\n\n    info->gid_status = gid_status;\n    info->subnet_prefix = subnet_prefix;\n    info->interface_id = interface_id;\n\n    processEvent = g_new0(struct qemuProcessEvent, 1);\n\n    processEvent->eventType = QEMU_PROCESS_EVENT_RDMA_GID_STATUS_CHANGED;\n    processEvent->vm = virObjectRef(vm);\n    processEvent->data = g_steal_pointer(&info);\n\n    if (virThreadPoolSendJob(driver->workerPool, 0, processEvent) < 0) {\n        qemuProcessEventFree(processEvent);\n        virObjectUnref(vm);\n        goto cleanup;\n    }\n\n    ret = 0;\n cleanup:\n    qemuMonitorEventRdmaGidStatusFree(info);\n    virObjectUnlock(vm);\n    return ret;\n}\n\n\nstatic int\nqemuProcessHandleGuestCrashloaded(qemuMonitorPtr mon G_GNUC_UNUSED,\n                                  virDomainObjPtr vm,\n                                  void *opaque)\n{\n    virQEMUDriverPtr driver = opaque;\n    struct qemuProcessEvent *processEvent;\n\n    virObjectLock(vm);\n    processEvent = g_new0(struct qemuProcessEvent, 1);\n\n    processEvent->eventType = QEMU_PROCESS_EVENT_GUEST_CRASHLOADED;\n    processEvent->vm = virObjectRef(vm);\n\n    if (virThreadPoolSendJob(driver->workerPool, 0, processEvent) < 0) {\n        virObjectUnref(vm);\n        qemuProcessEventFree(processEvent);\n    }\n\n    virObjectUnlock(vm);\n\n    return 0;\n}\n\n\nstatic int\nqemuProcessHandleMemoryFailure(qemuMonitorPtr mon G_GNUC_UNUSED,\n                               virDomainObjPtr vm,\n                               qemuMonitorEventMemoryFailurePtr mfp,\n                               void *opaque)\n{\n    virQEMUDriverPtr driver = opaque;\n    virObjectEventPtr event = NULL;\n    virDomainMemoryFailureRecipientType recipient;\n    virDomainMemoryFailureActionType action;\n    unsigned int flags = 0;\n\n    switch (mfp->recipient) {\n    case QEMU_MONITOR_MEMORY_FAILURE_RECIPIENT_HYPERVISOR:\n        recipient = VIR_DOMAIN_EVENT_MEMORY_FAILURE_RECIPIENT_HYPERVISOR;\n        break;\n    case QEMU_MONITOR_MEMORY_FAILURE_RECIPIENT_GUEST:\n        recipient = VIR_DOMAIN_EVENT_MEMORY_FAILURE_RECIPIENT_GUEST;\n        break;\n    case QEMU_MONITOR_MEMORY_FAILURE_RECIPIENT_LAST:\n    default:\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"requested unknown memory failure recipient\"));\n        return -1;\n    }\n\n    switch (mfp->action) {\n    case QEMU_MONITOR_MEMORY_FAILURE_ACTION_IGNORE:\n        action = VIR_DOMAIN_EVENT_MEMORY_FAILURE_ACTION_IGNORE;\n        break;\n    case QEMU_MONITOR_MEMORY_FAILURE_ACTION_INJECT:\n        action = VIR_DOMAIN_EVENT_MEMORY_FAILURE_ACTION_INJECT;\n        break;\n    case QEMU_MONITOR_MEMORY_FAILURE_ACTION_FATAL:\n        action = VIR_DOMAIN_EVENT_MEMORY_FAILURE_ACTION_FATAL;\n        break;\n    case QEMU_MONITOR_MEMORY_FAILURE_ACTION_RESET:\n        action = VIR_DOMAIN_EVENT_MEMORY_FAILURE_ACTION_RESET;\n        break;\n    case QEMU_MONITOR_MEMORY_FAILURE_ACTION_LAST:\n    default:\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"requested unknown memory failure action\"));\n        return -1;\n    }\n\n    if (mfp->action_required)\n        flags |= VIR_DOMAIN_MEMORY_FAILURE_ACTION_REQUIRED;\n    if (mfp->recursive)\n        flags |= VIR_DOMAIN_MEMORY_FAILURE_RECURSIVE;\n\n    event = virDomainEventMemoryFailureNewFromObj(vm, recipient, action, flags);\n    virObjectEventStateQueue(driver->domainEventState, event);\n\n    return 0;\n}\n\n\nstatic qemuMonitorCallbacks monitorCallbacks = {\n    .eofNotify = qemuProcessHandleMonitorEOF,\n    .errorNotify = qemuProcessHandleMonitorError,\n    .domainEvent = qemuProcessHandleEvent,\n    .domainShutdown = qemuProcessHandleShutdown,\n    .domainStop = qemuProcessHandleStop,\n    .domainResume = qemuProcessHandleResume,\n    .domainReset = qemuProcessHandleReset,\n    .domainRTCChange = qemuProcessHandleRTCChange,\n    .domainWatchdog = qemuProcessHandleWatchdog,\n    .domainIOError = qemuProcessHandleIOError,\n    .domainGraphics = qemuProcessHandleGraphics,\n    .domainBlockJob = qemuProcessHandleBlockJob,\n    .jobStatusChange = qemuProcessHandleJobStatusChange,\n    .domainTrayChange = qemuProcessHandleTrayChange,\n    .domainPMWakeup = qemuProcessHandlePMWakeup,\n    .domainPMSuspend = qemuProcessHandlePMSuspend,\n    .domainBalloonChange = qemuProcessHandleBalloonChange,\n    .domainPMSuspendDisk = qemuProcessHandlePMSuspendDisk,\n    .domainGuestPanic = qemuProcessHandleGuestPanic,\n    .domainDeviceDeleted = qemuProcessHandleDeviceDeleted,\n    .domainNicRxFilterChanged = qemuProcessHandleNicRxFilterChanged,\n    .domainSerialChange = qemuProcessHandleSerialChanged,\n    .domainSpiceMigrated = qemuProcessHandleSpiceMigrated,\n    .domainMigrationStatus = qemuProcessHandleMigrationStatus,\n    .domainMigrationPass = qemuProcessHandleMigrationPass,\n    .domainAcpiOstInfo = qemuProcessHandleAcpiOstInfo,\n    .domainBlockThreshold = qemuProcessHandleBlockThreshold,\n    .domainDumpCompleted = qemuProcessHandleDumpCompleted,\n    .domainPRManagerStatusChanged = qemuProcessHandlePRManagerStatusChanged,\n    .domainRdmaGidStatusChanged = qemuProcessHandleRdmaGidStatusChanged,\n    .domainGuestCrashloaded = qemuProcessHandleGuestCrashloaded,\n    .domainMemoryFailure = qemuProcessHandleMemoryFailure,\n};\n\nstatic void\nqemuProcessMonitorReportLogError(qemuMonitorPtr mon,\n                                 const char *msg,\n                                 void *opaque);\n\n\nstatic void\nqemuProcessMonitorLogFree(void *opaque)\n{\n    qemuDomainLogContextPtr logCtxt = opaque;\n    g_clear_object(&logCtxt);\n}\n\n\nstatic int\nqemuProcessInitMonitor(virQEMUDriverPtr driver,\n                       virDomainObjPtr vm,\n                       qemuDomainAsyncJob asyncJob)\n{\n    int ret;\n\n    if (qemuDomainObjEnterMonitorAsync(driver, vm, asyncJob) < 0)\n        return -1;\n\n    ret = qemuMonitorSetCapabilities(QEMU_DOMAIN_PRIVATE(vm)->mon);\n\n    if (qemuDomainObjExitMonitor(driver, vm) < 0)\n        ret = -1;\n\n    return ret;\n}\n\n\nstatic int\nqemuConnectMonitor(virQEMUDriverPtr driver, virDomainObjPtr vm, int asyncJob,\n                   bool retry, qemuDomainLogContextPtr logCtxt)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    qemuMonitorPtr mon = NULL;\n    unsigned long long timeout = 0;\n\n    if (qemuSecuritySetDaemonSocketLabel(driver->securityManager, vm->def) < 0) {\n        VIR_ERROR(_(\"Failed to set security context for monitor for %s\"),\n                  vm->def->name);\n        return -1;\n    }\n\n    /* When using hugepages, kernel zeroes them out before\n     * handing them over to qemu. This can be very time\n     * consuming. Therefore, add a second to timeout for each\n     * 1GiB of guest RAM. */\n    timeout = vm->def->mem.total_memory / (1024 * 1024);\n\n    ignore_value(virTimeMillisNow(&priv->monStart));\n\n    mon = qemuMonitorOpen(vm,\n                          priv->monConfig,\n                          retry,\n                          timeout,\n                          virEventThreadGetContext(priv->eventThread),\n                          &monitorCallbacks,\n                          driver);\n\n    if (mon && logCtxt) {\n        g_object_ref(logCtxt);\n        qemuMonitorSetDomainLog(mon,\n                                qemuProcessMonitorReportLogError,\n                                logCtxt,\n                                qemuProcessMonitorLogFree);\n    }\n\n    priv->monStart = 0;\n    priv->mon = mon;\n\n    if (qemuSecurityClearSocketLabel(driver->securityManager, vm->def) < 0) {\n        VIR_ERROR(_(\"Failed to clear security context for monitor for %s\"),\n                  vm->def->name);\n        return -1;\n    }\n\n    if (priv->mon == NULL) {\n        VIR_INFO(\"Failed to connect monitor for %s\", vm->def->name);\n        return -1;\n    }\n\n    if (qemuProcessInitMonitor(driver, vm, asyncJob) < 0)\n        return -1;\n\n    if (qemuMigrationCapsCheck(driver, vm, asyncJob) < 0)\n        return -1;\n\n    return 0;\n}\n\n\n/**\n * qemuProcessReadLog: Read log file of a qemu VM\n * @logCtxt: the domain log context\n * @msg: pointer to buffer to store the read messages in\n * @max: maximum length of the message returned in @msg\n *\n * Reads log of a qemu VM. Skips messages not produced by qemu or irrelevant\n * messages. If @max is not zero, @msg will contain at most @max characters\n * from the end of the log and @msg will start after a new line if possible.\n *\n * Returns 0 on success or -1 on error\n */\nstatic int\nqemuProcessReadLog(qemuDomainLogContextPtr logCtxt,\n                   char **msg,\n                   size_t max)\n{\n    char *buf;\n    ssize_t got;\n    char *eol;\n    char *filter_next;\n    size_t skip;\n\n    if ((got = qemuDomainLogContextRead(logCtxt, &buf)) < 0)\n        return -1;\n\n    /* Filter out debug messages from intermediate libvirt process */\n    filter_next = buf;\n    while ((eol = strchr(filter_next, '\\n'))) {\n        *eol = '\\0';\n        if (virLogProbablyLogMessage(filter_next) ||\n            strstr(filter_next, \"char device redirected to\")) {\n            skip = (eol + 1) - filter_next;\n            memmove(filter_next, eol + 1, buf + got - eol);\n            got -= skip;\n        } else {\n            filter_next = eol + 1;\n            *eol = '\\n';\n        }\n    }\n    filter_next = NULL; /* silence false coverity warning */\n\n    if (got > 0 &&\n        buf[got - 1] == '\\n') {\n        buf[got - 1] = '\\0';\n        got--;\n    }\n\n    if (max > 0 && got > max) {\n        skip = got - max;\n\n        if (buf[skip - 1] != '\\n' &&\n            (eol = strchr(buf + skip, '\\n')) &&\n            !virStringIsEmpty(eol + 1))\n            skip = eol + 1 - buf;\n\n        memmove(buf, buf + skip, got - skip + 1);\n        got -= skip;\n    }\n\n    buf = g_renew(char, buf, got + 1);\n    *msg = buf;\n    return 0;\n}\n\n\nstatic int\nqemuProcessReportLogError(qemuDomainLogContextPtr logCtxt,\n                          const char *msgprefix)\n{\n    g_autofree char *logmsg = NULL;\n    size_t max;\n\n    max = VIR_ERROR_MAX_LENGTH - 1;\n    max -= strlen(msgprefix);\n    /* The length of the formatting string minus two '%s' */\n    max -= strlen(_(\"%s: %s\")) - 4;\n\n    if (qemuProcessReadLog(logCtxt, &logmsg, max) < 0)\n        return -1;\n\n    virResetLastError();\n    if (virStringIsEmpty(logmsg))\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", msgprefix);\n    else\n        virReportError(VIR_ERR_INTERNAL_ERROR, _(\"%s: %s\"), msgprefix, logmsg);\n\n    return 0;\n}\n\n\nstatic void\nqemuProcessMonitorReportLogError(qemuMonitorPtr mon G_GNUC_UNUSED,\n                                 const char *msg,\n                                 void *opaque)\n{\n    qemuDomainLogContextPtr logCtxt = opaque;\n    qemuProcessReportLogError(logCtxt, msg);\n}\n\n\nstatic int\nqemuProcessLookupPTYs(virDomainChrDefPtr *devices,\n                      int count,\n                      GHashTable *info)\n{\n    size_t i;\n\n    for (i = 0; i < count; i++) {\n        g_autofree char *id = NULL;\n        virDomainChrDefPtr chr = devices[i];\n        if (chr->source->type == VIR_DOMAIN_CHR_TYPE_PTY) {\n            qemuMonitorChardevInfoPtr entry;\n\n            id = g_strdup_printf(\"char%s\", chr->info.alias);\n\n            entry = virHashLookup(info, id);\n            if (!entry || !entry->ptyPath) {\n                if (chr->source->data.file.path == NULL) {\n                    /* neither the log output nor 'info chardev' had a\n                     * pty path for this chardev, report an error\n                     */\n                    virReportError(VIR_ERR_INTERNAL_ERROR,\n                                   _(\"no assigned pty for device %s\"), id);\n                    return -1;\n                } else {\n                    /* 'info chardev' had no pty path for this chardev,\n                     * but the log output had, so we're fine\n                     */\n                    continue;\n                }\n            }\n\n            g_free(chr->source->data.file.path);\n            chr->source->data.file.path = g_strdup(entry->ptyPath);\n        }\n    }\n\n    return 0;\n}\n\nstatic int\nqemuProcessFindCharDevicePTYsMonitor(virDomainObjPtr vm,\n                                     GHashTable *info)\n{\n    size_t i = 0;\n\n    if (qemuProcessLookupPTYs(vm->def->serials, vm->def->nserials, info) < 0)\n        return -1;\n\n    if (qemuProcessLookupPTYs(vm->def->parallels, vm->def->nparallels,\n                              info) < 0)\n        return -1;\n\n    if (qemuProcessLookupPTYs(vm->def->channels, vm->def->nchannels, info) < 0)\n        return -1;\n    /* For historical reasons, console[0] can be just an alias\n     * for serial[0]. That's why we need to update it as well. */\n    if (vm->def->nconsoles) {\n        virDomainChrDefPtr chr = vm->def->consoles[0];\n\n        if (vm->def->nserials &&\n            chr->deviceType == VIR_DOMAIN_CHR_DEVICE_TYPE_CONSOLE &&\n            chr->targetType == VIR_DOMAIN_CHR_CONSOLE_TARGET_TYPE_SERIAL) {\n            /* yes, the first console is just an alias for serials[0] */\n            i = 1;\n            if (virDomainChrSourceDefCopy(chr->source,\n                                          ((vm->def->serials[0])->source)) < 0)\n                return -1;\n        }\n    }\n\n    if (qemuProcessLookupPTYs(vm->def->consoles + i, vm->def->nconsoles - i,\n                              info) < 0)\n        return -1;\n\n    return 0;\n}\n\n\nstatic void\nqemuProcessRefreshChannelVirtioState(virQEMUDriverPtr driver,\n                                     virDomainObjPtr vm,\n                                     GHashTable *info,\n                                     int booted)\n{\n    size_t i;\n    int agentReason = VIR_CONNECT_DOMAIN_EVENT_AGENT_LIFECYCLE_REASON_CHANNEL;\n    qemuMonitorChardevInfoPtr entry;\n    virObjectEventPtr event = NULL;\n    g_autofree char *id = NULL;\n\n    if (booted)\n        agentReason = VIR_CONNECT_DOMAIN_EVENT_AGENT_LIFECYCLE_REASON_DOMAIN_STARTED;\n\n    for (i = 0; i < vm->def->nchannels; i++) {\n        virDomainChrDefPtr chr = vm->def->channels[i];\n        if (chr->targetType == VIR_DOMAIN_CHR_CHANNEL_TARGET_TYPE_VIRTIO) {\n\n            VIR_FREE(id);\n            id = g_strdup_printf(\"char%s\", chr->info.alias);\n\n            /* port state not reported */\n            if (!(entry = virHashLookup(info, id)) ||\n                !entry->state)\n                continue;\n\n            if (entry->state != VIR_DOMAIN_CHR_DEVICE_STATE_DEFAULT &&\n                STREQ_NULLABLE(chr->target.name, \"org.qemu.guest_agent.0\") &&\n                (event = virDomainEventAgentLifecycleNewFromObj(vm, entry->state,\n                                                                agentReason)))\n                virObjectEventStateQueue(driver->domainEventState, event);\n\n            chr->state = entry->state;\n        }\n    }\n}\n\n\nint\nqemuRefreshVirtioChannelState(virQEMUDriverPtr driver,\n                              virDomainObjPtr vm,\n                              qemuDomainAsyncJob asyncJob)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    GHashTable *info = NULL;\n    int ret = -1;\n\n    if (qemuDomainObjEnterMonitorAsync(driver, vm, asyncJob) < 0)\n        goto cleanup;\n\n    ret = qemuMonitorGetChardevInfo(priv->mon, &info);\n    if (qemuDomainObjExitMonitor(driver, vm) < 0)\n        ret = -1;\n\n    if (ret < 0)\n        goto cleanup;\n\n    qemuProcessRefreshChannelVirtioState(driver, vm, info, false);\n    ret = 0;\n\n cleanup:\n    virHashFree(info);\n    return ret;\n}\n\n\nstatic int\nqemuProcessRefreshPRManagerState(virDomainObjPtr vm,\n                                 GHashTable *info)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    qemuMonitorPRManagerInfoPtr prManagerInfo;\n    const char *managedAlias = qemuDomainGetManagedPRAlias();\n\n    if (!(prManagerInfo = virHashLookup(info, managedAlias))) {\n        virReportError(VIR_ERR_OPERATION_FAILED,\n                       _(\"missing info on pr-manager %s\"),\n                       managedAlias);\n        return -1;\n    }\n\n    priv->prDaemonRunning = prManagerInfo->connected;\n\n    if (!priv->prDaemonRunning &&\n        qemuProcessStartManagedPRDaemon(vm) < 0)\n        return -1;\n\n    return 0;\n}\n\n\nstatic int\nqemuRefreshPRManagerState(virQEMUDriverPtr driver,\n                          virDomainObjPtr vm)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    GHashTable *info = NULL;\n    int ret = -1;\n\n    if (!virQEMUCapsGet(priv->qemuCaps, QEMU_CAPS_PR_MANAGER_HELPER) ||\n        !qemuDomainDefHasManagedPR(vm))\n        return 0;\n\n    qemuDomainObjEnterMonitor(driver, vm);\n    ret = qemuMonitorGetPRManagerInfo(priv->mon, &info);\n    if (qemuDomainObjExitMonitor(driver, vm) < 0)\n        ret = -1;\n\n    if (ret < 0)\n        goto cleanup;\n\n    ret = qemuProcessRefreshPRManagerState(vm, info);\n\n cleanup:\n    virHashFree(info);\n    return ret;\n}\n\n\nstatic void\nqemuRefreshRTC(virQEMUDriverPtr driver,\n               virDomainObjPtr vm)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    time_t now, then;\n    struct tm thenbits;\n    long localOffset;\n    int rv;\n\n    if (vm->def->clock.offset != VIR_DOMAIN_CLOCK_OFFSET_VARIABLE)\n        return;\n\n    memset(&thenbits, 0, sizeof(thenbits));\n    qemuDomainObjEnterMonitor(driver, vm);\n    now = time(NULL);\n    rv = qemuMonitorGetRTCTime(priv->mon, &thenbits);\n    if (qemuDomainObjExitMonitor(driver, vm) < 0)\n        rv = -1;\n\n    if (rv < 0)\n        return;\n\n    thenbits.tm_isdst = -1;\n    if ((then = mktime(&thenbits)) == (time_t)-1) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Unable to convert time\"));\n        return;\n    }\n\n    /* Thing is, @now is in local TZ but @then in UTC. */\n    if (virTimeLocalOffsetFromUTC(&localOffset) < 0)\n        return;\n\n    vm->def->clock.data.variable.adjustment = then - now + localOffset;\n}\n\nint\nqemuProcessRefreshBalloonState(virQEMUDriverPtr driver,\n                               virDomainObjPtr vm,\n                               int asyncJob)\n{\n    unsigned long long balloon;\n    int rc;\n\n    /* if no ballooning is available, the current size equals to the current\n     * full memory size */\n    if (!virDomainDefHasMemballoon(vm->def)) {\n        vm->def->mem.cur_balloon = virDomainDefGetMemoryTotal(vm->def);\n        return 0;\n    }\n\n    if (qemuDomainObjEnterMonitorAsync(driver, vm, asyncJob) < 0)\n        return -1;\n\n    rc = qemuMonitorGetBalloonInfo(qemuDomainGetMonitor(vm), &balloon);\n    if (qemuDomainObjExitMonitor(driver, vm) < 0 || rc < 0)\n        return -1;\n\n    vm->def->mem.cur_balloon = balloon;\n\n    return 0;\n}\n\n\nstatic int\nqemuProcessWaitForMonitor(virQEMUDriverPtr driver,\n                          virDomainObjPtr vm,\n                          int asyncJob,\n                          qemuDomainLogContextPtr logCtxt)\n{\n    int ret = -1;\n    GHashTable *info = NULL;\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    bool retry = true;\n\n    if (priv->qemuCaps &&\n        virQEMUCapsGet(priv->qemuCaps, QEMU_CAPS_CHARDEV_FD_PASS))\n        retry = false;\n\n    VIR_DEBUG(\"Connect monitor to vm=%p name='%s' retry=%d\",\n              vm, vm->def->name, retry);\n\n    if (qemuConnectMonitor(driver, vm, asyncJob, retry, logCtxt) < 0)\n        goto cleanup;\n\n    /* Try to get the pty path mappings again via the monitor. This is much more\n     * reliable if it's available.\n     * Note that the monitor itself can be on a pty, so we still need to try the\n     * log output method. */\n    if (qemuDomainObjEnterMonitorAsync(driver, vm, asyncJob) < 0)\n        goto cleanup;\n    ret = qemuMonitorGetChardevInfo(priv->mon, &info);\n    VIR_DEBUG(\"qemuMonitorGetChardevInfo returned %i\", ret);\n    if (qemuDomainObjExitMonitor(driver, vm) < 0)\n        ret = -1;\n\n    if (ret == 0) {\n        if ((ret = qemuProcessFindCharDevicePTYsMonitor(vm, info)) < 0)\n            goto cleanup;\n\n         qemuProcessRefreshChannelVirtioState(driver, vm, info, true);\n    }\n\n cleanup:\n    virHashFree(info);\n\n    if (logCtxt && kill(vm->pid, 0) == -1 && errno == ESRCH) {\n        qemuProcessReportLogError(logCtxt,\n                                  _(\"process exited while connecting to monitor\"));\n        ret = -1;\n    }\n\n    return ret;\n}\n\n\nstatic int\nqemuProcessDetectIOThreadPIDs(virQEMUDriverPtr driver,\n                              virDomainObjPtr vm,\n                              int asyncJob)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    qemuMonitorIOThreadInfoPtr *iothreads = NULL;\n    int niothreads = 0;\n    int ret = -1;\n    size_t i;\n\n    if (!virQEMUCapsGet(priv->qemuCaps, QEMU_CAPS_OBJECT_IOTHREAD)) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    /* Get the list of IOThreads from qemu */\n    if (qemuDomainObjEnterMonitorAsync(driver, vm, asyncJob) < 0)\n        goto cleanup;\n    ret = qemuMonitorGetIOThreads(priv->mon, &iothreads, &niothreads);\n    if (qemuDomainObjExitMonitor(driver, vm) < 0)\n        goto cleanup;\n    if (ret < 0)\n        goto cleanup;\n\n    if (niothreads != vm->def->niothreadids) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"got wrong number of IOThread pids from QEMU monitor. \"\n                         \"got %d, wanted %zu\"),\n                       niothreads, vm->def->niothreadids);\n        goto cleanup;\n    }\n\n    /* Nothing to do */\n    if (niothreads == 0) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    for (i = 0; i < niothreads; i++) {\n        virDomainIOThreadIDDefPtr iothrid;\n\n        if (!(iothrid = virDomainIOThreadIDFind(vm->def,\n                                                iothreads[i]->iothread_id))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"iothread %d not found\"),\n                           iothreads[i]->iothread_id);\n            goto cleanup;\n        }\n        iothrid->thread_id = iothreads[i]->thread_id;\n    }\n\n    ret = 0;\n\n cleanup:\n    if (iothreads) {\n        for (i = 0; i < niothreads; i++)\n            VIR_FREE(iothreads[i]);\n        VIR_FREE(iothreads);\n    }\n    return ret;\n}\n\n\nstatic int\nqemuProcessGetAllCpuAffinity(virBitmapPtr *cpumapRet)\n{\n    *cpumapRet = NULL;\n\n    if (!virHostCPUHasBitmap())\n        return 0;\n\n    if (!(*cpumapRet = virHostCPUGetOnlineBitmap()))\n        return -1;\n\n    return 0;\n}\n\n\n/*\n * To be run between fork/exec of QEMU only\n */\n#if defined(WITH_SCHED_GETAFFINITY) || defined(WITH_BSD_CPU_AFFINITY)\nstatic int\nqemuProcessInitCpuAffinity(virDomainObjPtr vm)\n{\n    bool settingAll = false;\n    g_autoptr(virBitmap) cpumapToSet = NULL;\n    virDomainNumatuneMemMode mem_mode;\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n\n    if (!vm->pid) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Cannot setup CPU affinity until process is started\"));\n        return -1;\n    }\n\n    /* Here is the deal, we can't set cpuset.mems before qemu is\n     * started as it clashes with KVM allocation. Therefore, we\n     * used to let qemu allocate its memory anywhere as we would\n     * then move the memory to desired NUMA node via CGroups.\n     * However, that might not be always possible because qemu\n     * might lock some parts of its memory (e.g. due to VFIO).\n     * Even if it possible, memory has to be copied between NUMA\n     * nodes which is suboptimal.\n     * Solution is to set affinity that matches the best what we\n     * would have set in CGroups and then fix it later, once qemu\n     * is already running. */\n    if (virDomainNumaGetNodeCount(vm->def->numa) <= 1 &&\n        virDomainNumatuneGetMode(vm->def->numa, -1, &mem_mode) == 0 &&\n        mem_mode == VIR_DOMAIN_NUMATUNE_MEM_STRICT) {\n        virBitmapPtr nodeset = NULL;\n\n        if (virDomainNumatuneMaybeGetNodeset(vm->def->numa,\n                                             priv->autoNodeset,\n                                             &nodeset,\n                                             -1) < 0)\n            return -1;\n\n        if (virNumaNodesetToCPUset(nodeset, &cpumapToSet) < 0)\n            return -1;\n    } else if (vm->def->cputune.emulatorpin) {\n        cpumapToSet = virBitmapNewCopy(vm->def->cputune.emulatorpin);\n    } else {\n        settingAll = true;\n        if (qemuProcessGetAllCpuAffinity(&cpumapToSet) < 0)\n            return -1;\n    }\n\n    /*\n     * We only want to error out if we failed to set the affinity to\n     * user-requested mapping.  If we are just trying to reset the affinity\n     * to all CPUs and this fails it can only be an issue if:\n     *  1) libvirtd does not have CAP_SYS_NICE\n     *  2) libvirtd does not run on all CPUs\n     *\n     * This scenario can easily occur when libvirtd is run inside a\n     * container with restrictive permissions and CPU pinning.\n     *\n     * See also: https://bugzilla.redhat.com/1819801#c2\n     */\n    if (cpumapToSet &&\n        virProcessSetAffinity(vm->pid, cpumapToSet, settingAll) < 0) {\n        return -1;\n    }\n\n    return 0;\n}\n#else /* !defined(WITH_SCHED_GETAFFINITY) && !defined(WITH_BSD_CPU_AFFINITY) */\nstatic int\nqemuProcessInitCpuAffinity(virDomainObjPtr vm G_GNUC_UNUSED)\n{\n    return 0;\n}\n#endif /* !defined(WITH_SCHED_GETAFFINITY) && !defined(WITH_BSD_CPU_AFFINITY) */\n\n/* set link states to down on interfaces at qemu start */\nstatic int\nqemuProcessSetLinkStates(virQEMUDriverPtr driver,\n                         virDomainObjPtr vm,\n                         qemuDomainAsyncJob asyncJob)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    virDomainDefPtr def = vm->def;\n    size_t i;\n    int ret = -1;\n    int rv;\n\n    if (qemuDomainObjEnterMonitorAsync(driver, vm, asyncJob) < 0)\n        return -1;\n\n    for (i = 0; i < def->nnets; i++) {\n        if (def->nets[i]->linkstate == VIR_DOMAIN_NET_INTERFACE_LINK_STATE_DOWN) {\n            if (!def->nets[i]->info.alias) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"missing alias for network device\"));\n                goto cleanup;\n            }\n\n            VIR_DEBUG(\"Setting link state: %s\", def->nets[i]->info.alias);\n\n            rv = qemuMonitorSetLink(priv->mon,\n                                    def->nets[i]->info.alias,\n                                    VIR_DOMAIN_NET_INTERFACE_LINK_STATE_DOWN);\n            if (rv < 0) {\n                virReportError(VIR_ERR_OPERATION_FAILED,\n                               _(\"Couldn't set link state on interface: %s\"),\n                               def->nets[i]->info.alias);\n                goto cleanup;\n            }\n        }\n    }\n\n    ret = 0;\n\n cleanup:\n    if (qemuDomainObjExitMonitor(driver, vm) < 0)\n        ret = -1;\n    return ret;\n}\n\n\n/**\n * qemuProcessSetupPid:\n *\n * This function sets resource properties (affinity, cgroups,\n * scheduler) for any PID associated with a domain.  It should be used\n * to set up emulator PIDs as well as vCPU and I/O thread pids to\n * ensure they are all handled the same way.\n *\n * Returns 0 on success, -1 on error.\n */\nstatic int\nqemuProcessSetupPid(virDomainObjPtr vm,\n                    pid_t pid,\n                    virCgroupThreadName nameval,\n                    int id,\n                    virBitmapPtr cpumask,\n                    unsigned long long period,\n                    long long quota,\n                    virDomainThreadSchedParamPtr sched)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    virDomainNumatuneMemMode mem_mode;\n    virCgroupPtr cgroup = NULL;\n    virBitmapPtr use_cpumask = NULL;\n    virBitmapPtr affinity_cpumask = NULL;\n    g_autoptr(virBitmap) hostcpumap = NULL;\n    g_autofree char *mem_mask = NULL;\n    int ret = -1;\n\n    if ((period || quota) &&\n        !virCgroupHasController(priv->cgroup, VIR_CGROUP_CONTROLLER_CPU)) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"cgroup cpu is required for scheduler tuning\"));\n        goto cleanup;\n    }\n\n    /* Infer which cpumask shall be used. */\n    if (cpumask) {\n        use_cpumask = cpumask;\n    } else if (vm->def->placement_mode == VIR_DOMAIN_CPU_PLACEMENT_MODE_AUTO) {\n        use_cpumask = priv->autoCpuset;\n    } else if (vm->def->cpumask) {\n        use_cpumask = vm->def->cpumask;\n    } else {\n        /* You may think this is redundant, but we can't assume libvirtd\n         * itself is running on all pCPUs, so we need to explicitly set\n         * the spawned QEMU instance to all pCPUs if no map is given in\n         * its config file */\n        if (qemuProcessGetAllCpuAffinity(&hostcpumap) < 0)\n            goto cleanup;\n        affinity_cpumask = hostcpumap;\n    }\n\n    /*\n     * If CPU cgroup controller is not initialized here, then we need\n     * neither period nor quota settings.  And if CPUSET controller is\n     * not initialized either, then there's nothing to do anyway.\n     */\n    if (virCgroupHasController(priv->cgroup, VIR_CGROUP_CONTROLLER_CPU) ||\n        virCgroupHasController(priv->cgroup, VIR_CGROUP_CONTROLLER_CPUSET)) {\n\n        if (virDomainNumatuneGetMode(vm->def->numa, -1, &mem_mode) == 0 &&\n            mem_mode == VIR_DOMAIN_NUMATUNE_MEM_STRICT &&\n            virDomainNumatuneMaybeFormatNodeset(vm->def->numa,\n                                                priv->autoNodeset,\n                                                &mem_mask, -1) < 0)\n            goto cleanup;\n\n        if (virCgroupNewThread(priv->cgroup, nameval, id, true, &cgroup) < 0)\n            goto cleanup;\n\n        if (virCgroupHasController(priv->cgroup, VIR_CGROUP_CONTROLLER_CPUSET)) {\n            if (use_cpumask &&\n                qemuSetupCgroupCpusetCpus(cgroup, use_cpumask) < 0)\n                goto cleanup;\n\n            if (mem_mask && virCgroupSetCpusetMems(cgroup, mem_mask) < 0)\n                goto cleanup;\n\n        }\n\n        if ((period || quota) &&\n            qemuSetupCgroupVcpuBW(cgroup, period, quota) < 0)\n            goto cleanup;\n\n        /* Move the thread to the sub dir */\n        if (virCgroupAddThread(cgroup, pid) < 0)\n            goto cleanup;\n\n    }\n\n    if (!affinity_cpumask)\n        affinity_cpumask = use_cpumask;\n\n    /* Setup legacy affinity.\n     *\n     * We only want to error out if we failed to set the affinity to\n     * user-requested mapping.  If we are just trying to reset the affinity\n     * to all CPUs and this fails it can only be an issue if:\n     *  1) libvirtd does not have CAP_SYS_NICE\n     *  2) libvirtd does not run on all CPUs\n     *\n     * This scenario can easily occur when libvirtd is run inside a\n     * container with restrictive permissions and CPU pinning.\n     *\n     * See also: https://bugzilla.redhat.com/1819801#c2\n     */\n    if (affinity_cpumask &&\n        virProcessSetAffinity(pid, affinity_cpumask,\n                              affinity_cpumask == hostcpumap) < 0) {\n        goto cleanup;\n    }\n\n    /* Set scheduler type and priority, but not for the main thread. */\n    if (sched &&\n        nameval != VIR_CGROUP_THREAD_EMULATOR &&\n        virProcessSetScheduler(pid, sched->policy, sched->priority) < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    if (cgroup) {\n        if (ret < 0)\n            virCgroupRemove(cgroup);\n        virCgroupFree(cgroup);\n    }\n\n    return ret;\n}\n\n\nstatic int\nqemuProcessSetupEmulator(virDomainObjPtr vm)\n{\n    return qemuProcessSetupPid(vm, vm->pid, VIR_CGROUP_THREAD_EMULATOR,\n                               0, vm->def->cputune.emulatorpin,\n                               vm->def->cputune.emulator_period,\n                               vm->def->cputune.emulator_quota,\n                               vm->def->cputune.emulatorsched);\n}\n\n\nstatic int\nqemuProcessResctrlCreate(virQEMUDriverPtr driver,\n                         virDomainObjPtr vm)\n{\n    size_t i = 0;\n    g_autoptr(virCaps) caps = NULL;\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n\n    if (!vm->def->nresctrls)\n        return 0;\n\n    /* Force capability refresh since resctrl info can change\n     * XXX: move cache info into virresctrl so caps are not needed */\n    caps = virQEMUDriverGetCapabilities(driver, true);\n    if (!caps)\n        return -1;\n\n    for (i = 0; i < vm->def->nresctrls; i++) {\n        size_t j = 0;\n        if (virResctrlAllocCreate(caps->host.resctrl,\n                                  vm->def->resctrls[i]->alloc,\n                                  priv->machineName) < 0)\n            return -1;\n\n        for (j = 0; j < vm->def->resctrls[i]->nmonitors; j++) {\n            virDomainResctrlMonDefPtr mon = NULL;\n\n            mon = vm->def->resctrls[i]->monitors[j];\n            if (virResctrlMonitorCreate(mon->instance,\n                                        priv->machineName) < 0)\n                return -1;\n        }\n    }\n\n    return 0;\n}\n\n\nstatic char *\nqemuProcessBuildPRHelperPidfilePath(virDomainObjPtr vm)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    const char *prdAlias = qemuDomainGetManagedPRAlias();\n\n    return virPidFileBuildPath(priv->libDir, prdAlias);\n}\n\n\nvoid\nqemuProcessKillManagedPRDaemon(virDomainObjPtr vm)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    virErrorPtr orig_err;\n    g_autofree char *pidfile = NULL;\n\n    if (!(pidfile = qemuProcessBuildPRHelperPidfilePath(vm))) {\n        VIR_WARN(\"Unable to construct pr-helper pidfile path\");\n        return;\n    }\n\n    virErrorPreserveLast(&orig_err);\n    if (virPidFileForceCleanupPath(pidfile) < 0) {\n        VIR_WARN(\"Unable to kill pr-helper process\");\n    } else {\n        priv->prDaemonRunning = false;\n    }\n    virErrorRestore(&orig_err);\n}\n\n\nstatic int\nqemuProcessStartPRDaemonHook(void *opaque)\n{\n    virDomainObjPtr vm = opaque;\n    size_t i, nfds = 0;\n    g_autofree int *fds = NULL;\n    int ret = -1;\n\n    if (qemuDomainNamespaceEnabled(vm, QEMU_DOMAIN_NS_MOUNT)) {\n        if (virProcessGetNamespaces(vm->pid, &nfds, &fds) < 0)\n            return ret;\n\n        if (nfds > 0 &&\n            virProcessSetNamespaces(nfds, fds) < 0)\n            goto cleanup;\n    }\n\n    ret = 0;\n cleanup:\n    for (i = 0; i < nfds; i++)\n        VIR_FORCE_CLOSE(fds[i]);\n    return ret;\n}\n\n\nint\nqemuProcessStartManagedPRDaemon(virDomainObjPtr vm)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    virQEMUDriverPtr driver = priv->driver;\n    g_autoptr(virQEMUDriverConfig) cfg = NULL;\n    int errfd = -1;\n    g_autofree char *pidfile = NULL;\n    g_autofree char *socketPath = NULL;\n    pid_t cpid = -1;\n    g_autoptr(virCommand) cmd = NULL;\n    virTimeBackOffVar timebackoff;\n    const unsigned long long timeout = 500000; /* ms */\n    int ret = -1;\n\n    cfg = virQEMUDriverGetConfig(driver);\n\n    if (!virFileIsExecutable(cfg->prHelperName)) {\n        virReportSystemError(errno, _(\"'%s' is not a suitable pr helper\"),\n                             cfg->prHelperName);\n        goto cleanup;\n    }\n\n    if (!(pidfile = qemuProcessBuildPRHelperPidfilePath(vm)))\n        goto cleanup;\n\n    if (!(socketPath = qemuDomainGetManagedPRSocketPath(priv)))\n        goto cleanup;\n\n    /* Remove stale socket */\n    if (unlink(socketPath) < 0 &&\n        errno != ENOENT) {\n        virReportSystemError(errno,\n                             _(\"Unable to remove stale socket path: %s\"),\n                             socketPath);\n        goto cleanup;\n    }\n\n    if (!(cmd = virCommandNewArgList(cfg->prHelperName,\n                                     \"-k\", socketPath,\n                                     NULL)))\n        goto cleanup;\n\n    virCommandDaemonize(cmd);\n    virCommandSetPidFile(cmd, pidfile);\n    virCommandSetErrorFD(cmd, &errfd);\n\n    /* Place the process into the same namespace and cgroup as\n     * qemu (so that it shares the same view of the system). */\n    virCommandSetPreExecHook(cmd, qemuProcessStartPRDaemonHook, vm);\n\n    if (virCommandRun(cmd, NULL) < 0)\n        goto cleanup;\n\n    if (virPidFileReadPath(pidfile, &cpid) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"pr helper %s didn't show up\"),\n                       cfg->prHelperName);\n        goto cleanup;\n    }\n\n    if (virTimeBackOffStart(&timebackoff, 1, timeout) < 0)\n        goto cleanup;\n    while (virTimeBackOffWait(&timebackoff)) {\n        char errbuf[1024] = { 0 };\n\n        if (virFileExists(socketPath))\n            break;\n\n        if (virProcessKill(cpid, 0) == 0)\n            continue;\n\n        if (saferead(errfd, errbuf, sizeof(errbuf) - 1) < 0) {\n            virReportSystemError(errno,\n                                 _(\"pr helper %s died unexpectedly\"),\n                                 cfg->prHelperName);\n        } else {\n            virReportError(VIR_ERR_OPERATION_FAILED,\n                           _(\"pr helper died and reported: %s\"), errbuf);\n        }\n        goto cleanup;\n    }\n\n    if (!virFileExists(socketPath)) {\n        virReportError(VIR_ERR_OPERATION_TIMEOUT, \"%s\",\n                       _(\"pr helper socked did not show up\"));\n        goto cleanup;\n    }\n\n    if (priv->cgroup &&\n        virCgroupAddMachineProcess(priv->cgroup, cpid) < 0)\n        goto cleanup;\n\n    if (qemuSecurityDomainSetPathLabel(driver, vm, socketPath, true) < 0)\n        goto cleanup;\n\n    priv->prDaemonRunning = true;\n    ret = 0;\n cleanup:\n    if (ret < 0) {\n        virCommandAbort(cmd);\n        if (cpid >= 0)\n            virProcessKillPainfully(cpid, true);\n        if (pidfile)\n            unlink(pidfile);\n    }\n    VIR_FORCE_CLOSE(errfd);\n    return ret;\n}\n\n\nstatic int\nqemuProcessInitPasswords(virQEMUDriverPtr driver,\n                         virDomainObjPtr vm,\n                         int asyncJob)\n{\n    int ret = 0;\n    g_autoptr(virQEMUDriverConfig) cfg = virQEMUDriverGetConfig(driver);\n    size_t i;\n\n    for (i = 0; i < vm->def->ngraphics; ++i) {\n        virDomainGraphicsDefPtr graphics = vm->def->graphics[i];\n        if (graphics->type == VIR_DOMAIN_GRAPHICS_TYPE_VNC) {\n            ret = qemuDomainChangeGraphicsPasswords(driver, vm,\n                                                    VIR_DOMAIN_GRAPHICS_TYPE_VNC,\n                                                    &graphics->data.vnc.auth,\n                                                    cfg->vncPassword,\n                                                    asyncJob);\n        } else if (graphics->type == VIR_DOMAIN_GRAPHICS_TYPE_SPICE) {\n            ret = qemuDomainChangeGraphicsPasswords(driver, vm,\n                                                    VIR_DOMAIN_GRAPHICS_TYPE_SPICE,\n                                                    &graphics->data.spice.auth,\n                                                    cfg->spicePassword,\n                                                    asyncJob);\n        }\n\n        if (ret < 0)\n            return ret;\n    }\n\n    return ret;\n}\n\n\nstatic int\nqemuProcessPrepareChardevDevice(virDomainDefPtr def G_GNUC_UNUSED,\n                                virDomainChrDefPtr dev,\n                                void *opaque G_GNUC_UNUSED)\n{\n    int fd;\n    if (dev->source->type != VIR_DOMAIN_CHR_TYPE_FILE)\n        return 0;\n\n    if ((fd = open(dev->source->data.file.path,\n                   O_CREAT | O_APPEND, S_IRUSR|S_IWUSR)) < 0) {\n        virReportSystemError(errno,\n                             _(\"Unable to pre-create chardev file '%s'\"),\n                             dev->source->data.file.path);\n        return -1;\n    }\n\n    VIR_FORCE_CLOSE(fd);\n\n    return 0;\n}\n\n\nstatic int\nqemuProcessCleanupChardevDevice(virDomainDefPtr def G_GNUC_UNUSED,\n                                virDomainChrDefPtr dev,\n                                void *opaque G_GNUC_UNUSED)\n{\n    if (dev->source->type == VIR_DOMAIN_CHR_TYPE_UNIX &&\n        dev->source->data.nix.listen &&\n        dev->source->data.nix.path)\n        unlink(dev->source->data.nix.path);\n\n    return 0;\n}\n\n\n/**\n * Loads and update video memory size for video devices according to QEMU\n * process as the QEMU will silently update the values that we pass to QEMU\n * through command line.  We need to load these updated values and store them\n * into the status XML.\n *\n * We will fail if for some reason the values cannot be loaded from QEMU because\n * its mandatory to get the correct video memory size to status XML to not break\n * migration.\n */\nstatic int\nqemuProcessUpdateVideoRamSize(virQEMUDriverPtr driver,\n                              virDomainObjPtr vm,\n                              int asyncJob)\n{\n    int ret = -1;\n    ssize_t i;\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    virDomainVideoDefPtr video = NULL;\n    g_autoptr(virQEMUDriverConfig) cfg = NULL;\n\n    if (qemuDomainObjEnterMonitorAsync(driver, vm, asyncJob) < 0)\n        return -1;\n\n    for (i = 0; i < vm->def->nvideos; i++) {\n        video = vm->def->videos[i];\n\n        switch (video->type) {\n        case VIR_DOMAIN_VIDEO_TYPE_VGA:\n            if (virQEMUCapsGet(priv->qemuCaps, QEMU_CAPS_VGA_VGAMEM)) {\n                if (qemuMonitorUpdateVideoMemorySize(priv->mon, video, \"VGA\") < 0)\n                    goto error;\n            }\n            break;\n        case VIR_DOMAIN_VIDEO_TYPE_QXL:\n            if (i == 0) {\n                if (virQEMUCapsGet(priv->qemuCaps, QEMU_CAPS_QXL_VGAMEM) &&\n                    qemuMonitorUpdateVideoMemorySize(priv->mon, video,\n                                                     \"qxl-vga\") < 0)\n                        goto error;\n\n                if (virQEMUCapsGet(priv->qemuCaps, QEMU_CAPS_QXL_VRAM64) &&\n                    qemuMonitorUpdateVideoVram64Size(priv->mon, video,\n                                                     \"qxl-vga\") < 0)\n                    goto error;\n            } else {\n                if (virQEMUCapsGet(priv->qemuCaps, QEMU_CAPS_QXL_VGAMEM) &&\n                    qemuMonitorUpdateVideoMemorySize(priv->mon, video,\n                                                     \"qxl\") < 0)\n                        goto error;\n\n                if (virQEMUCapsGet(priv->qemuCaps, QEMU_CAPS_QXL_VRAM64) &&\n                    qemuMonitorUpdateVideoVram64Size(priv->mon, video,\n                                                     \"qxl\") < 0)\n                        goto error;\n            }\n            break;\n        case VIR_DOMAIN_VIDEO_TYPE_VMVGA:\n            if (virQEMUCapsGet(priv->qemuCaps, QEMU_CAPS_VMWARE_SVGA_VGAMEM)) {\n                if (qemuMonitorUpdateVideoMemorySize(priv->mon, video,\n                                                     \"vmware-svga\") < 0)\n                    goto error;\n            }\n            break;\n        case VIR_DOMAIN_VIDEO_TYPE_CIRRUS:\n        case VIR_DOMAIN_VIDEO_TYPE_XEN:\n        case VIR_DOMAIN_VIDEO_TYPE_VBOX:\n        case VIR_DOMAIN_VIDEO_TYPE_LAST:\n            break;\n        }\n\n    }\n\n    if (qemuDomainObjExitMonitor(driver, vm) < 0)\n        return -1;\n\n    cfg = virQEMUDriverGetConfig(driver);\n    ret = virDomainObjSave(vm, driver->xmlopt, cfg->stateDir);\n\n    return ret;\n\n error:\n    ignore_value(qemuDomainObjExitMonitor(driver, vm));\n    return -1;\n}\n\n\nstruct qemuProcessHookData {\n    virDomainObjPtr vm;\n    virQEMUDriverPtr driver;\n    virQEMUDriverConfigPtr cfg;\n};\n\nstatic int qemuProcessHook(void *data)\n{\n    struct qemuProcessHookData *h = data;\n    qemuDomainObjPrivatePtr priv = h->vm->privateData;\n    int ret = -1;\n    int fd;\n    virBitmapPtr nodeset = NULL;\n    virDomainNumatuneMemMode mode;\n\n    /* This method cannot use any mutexes, which are not\n     * protected across fork()\n     */\n\n    qemuSecurityPostFork(h->driver->securityManager);\n\n    /* Some later calls want pid present */\n    h->vm->pid = getpid();\n\n    VIR_DEBUG(\"Obtaining domain lock\");\n    /*\n     * Since we're going to leak the returned FD to QEMU,\n     * we need to make sure it gets a sensible label.\n     * This mildly sucks, because there could be other\n     * sockets the lock driver opens that we don't want\n     * labelled. So far we're ok though.\n     */\n    if (qemuSecuritySetSocketLabel(h->driver->securityManager, h->vm->def) < 0)\n        goto cleanup;\n    if (virDomainLockProcessStart(h->driver->lockManager,\n                                  h->cfg->uri,\n                                  h->vm,\n                                  /* QEMU is always paused initially */\n                                  true,\n                                  &fd) < 0)\n        goto cleanup;\n    if (qemuSecurityClearSocketLabel(h->driver->securityManager, h->vm->def) < 0)\n        goto cleanup;\n\n    if (qemuDomainUnshareNamespace(h->cfg, h->driver->securityManager, h->vm) < 0)\n        goto cleanup;\n\n    if (virDomainNumatuneGetMode(h->vm->def->numa, -1, &mode) == 0) {\n        if (mode == VIR_DOMAIN_NUMATUNE_MEM_STRICT &&\n            h->cfg->cgroupControllers & (1 << VIR_CGROUP_CONTROLLER_CPUSET) &&\n            virCgroupControllerAvailable(VIR_CGROUP_CONTROLLER_CPUSET)) {\n            /* Use virNuma* API iff necessary. Once set and child is exec()-ed,\n             * there's no way for us to change it. Rely on cgroups (if available\n             * and enabled in the config) rather than virNuma*. */\n            VIR_DEBUG(\"Relying on CGroups for memory binding\");\n        } else {\n            nodeset = virDomainNumatuneGetNodeset(h->vm->def->numa,\n                                                  priv->autoNodeset, -1);\n\n            if (virNumaSetupMemoryPolicy(mode, nodeset) < 0)\n                goto cleanup;\n        }\n    }\n\n    ret = 0;\n\n cleanup:\n    virObjectUnref(h->cfg);\n    VIR_DEBUG(\"Hook complete ret=%d\", ret);\n    return ret;\n}\n\nint\nqemuProcessPrepareMonitorChr(virDomainChrSourceDefPtr monConfig,\n                             const char *domainDir)\n{\n    monConfig->type = VIR_DOMAIN_CHR_TYPE_UNIX;\n    monConfig->data.nix.listen = true;\n\n    monConfig->data.nix.path = g_strdup_printf(\"%s/monitor.sock\", domainDir);\n    return 0;\n}\n\n\n/*\n * Precondition: vm must be locked, and a job must be active.\n * This method will call {Enter,Exit}Monitor\n */\nint\nqemuProcessStartCPUs(virQEMUDriverPtr driver, virDomainObjPtr vm,\n                     virDomainRunningReason reason,\n                     qemuDomainAsyncJob asyncJob)\n{\n    int ret = -1;\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    g_autoptr(virQEMUDriverConfig) cfg = virQEMUDriverGetConfig(driver);\n\n    /* Bring up netdevs before starting CPUs */\n    if (qemuInterfaceStartDevices(vm->def) < 0)\n       return -1;\n\n    VIR_DEBUG(\"Using lock state '%s'\", NULLSTR(priv->lockState));\n    if (virDomainLockProcessResume(driver->lockManager, cfg->uri,\n                                   vm, priv->lockState) < 0) {\n        /* Don't free priv->lockState on error, because we need\n         * to make sure we have state still present if the user\n         * tries to resume again\n         */\n        return -1;\n    }\n    VIR_FREE(priv->lockState);\n\n    priv->runningReason = reason;\n\n    if (qemuDomainObjEnterMonitorAsync(driver, vm, asyncJob) < 0)\n        goto release;\n\n    ret = qemuMonitorStartCPUs(priv->mon);\n    if (qemuDomainObjExitMonitor(driver, vm) < 0)\n        ret = -1;\n\n    if (ret < 0)\n        goto release;\n\n    /* The RESUME event handler will change the domain state with the reason\n     * saved in priv->runningReason and it will also emit corresponding domain\n     * lifecycle event.\n     */\n\n    return ret;\n\n release:\n    priv->runningReason = VIR_DOMAIN_RUNNING_UNKNOWN;\n    if (virDomainLockProcessPause(driver->lockManager, vm, &priv->lockState) < 0)\n        VIR_WARN(\"Unable to release lease on %s\", vm->def->name);\n    VIR_DEBUG(\"Preserving lock state '%s'\", NULLSTR(priv->lockState));\n    return ret;\n}\n\n\nint qemuProcessStopCPUs(virQEMUDriverPtr driver,\n                        virDomainObjPtr vm,\n                        virDomainPausedReason reason,\n                        qemuDomainAsyncJob asyncJob)\n{\n    int ret = -1;\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n\n    VIR_FREE(priv->lockState);\n\n    priv->pausedReason = reason;\n\n    if (qemuDomainObjEnterMonitorAsync(driver, vm, asyncJob) < 0)\n        goto cleanup;\n\n    ret = qemuMonitorStopCPUs(priv->mon);\n    if (qemuDomainObjExitMonitor(driver, vm) < 0)\n        ret = -1;\n\n    if (ret < 0)\n        goto cleanup;\n\n    /* de-activate netdevs after stopping CPUs */\n    ignore_value(qemuInterfaceStopDevices(vm->def));\n\n    if (priv->job.current)\n        ignore_value(virTimeMillisNow(&priv->job.current->stopped));\n\n    /* The STOP event handler will change the domain state with the reason\n     * saved in priv->pausedReason and it will also emit corresponding domain\n     * lifecycle event.\n     */\n\n    if (virDomainLockProcessPause(driver->lockManager, vm, &priv->lockState) < 0)\n        VIR_WARN(\"Unable to release lease on %s\", vm->def->name);\n    VIR_DEBUG(\"Preserving lock state '%s'\", NULLSTR(priv->lockState));\n\n cleanup:\n    if (ret < 0)\n        priv->pausedReason = VIR_DOMAIN_PAUSED_UNKNOWN;\n\n    return ret;\n}\n\n\n\nstatic void\nqemuProcessNotifyNets(virDomainDefPtr def)\n{\n    size_t i;\n    g_autoptr(virConnect) conn = NULL;\n\n    for (i = 0; i < def->nnets; i++) {\n        virDomainNetDefPtr net = def->nets[i];\n        /* keep others from trying to use the macvtap device name, but\n         * don't return error if this happens, since that causes the\n         * domain to be unceremoniously killed, which would be *very*\n         * impolite.\n         */\n        switch (virDomainNetGetActualType(net)) {\n        case VIR_DOMAIN_NET_TYPE_DIRECT:\n            virNetDevReserveName(net->ifname);\n            break;\n        case VIR_DOMAIN_NET_TYPE_BRIDGE:\n        case VIR_DOMAIN_NET_TYPE_NETWORK:\n        case VIR_DOMAIN_NET_TYPE_ETHERNET:\n            virNetDevReserveName(net->ifname);\n            break;\n        case VIR_DOMAIN_NET_TYPE_USER:\n        case VIR_DOMAIN_NET_TYPE_VHOSTUSER:\n        case VIR_DOMAIN_NET_TYPE_SERVER:\n        case VIR_DOMAIN_NET_TYPE_CLIENT:\n        case VIR_DOMAIN_NET_TYPE_MCAST:\n        case VIR_DOMAIN_NET_TYPE_INTERNAL:\n        case VIR_DOMAIN_NET_TYPE_HOSTDEV:\n        case VIR_DOMAIN_NET_TYPE_UDP:\n        case VIR_DOMAIN_NET_TYPE_VDPA:\n        case VIR_DOMAIN_NET_TYPE_LAST:\n            break;\n        }\n\n        if (net->type == VIR_DOMAIN_NET_TYPE_NETWORK && !conn)\n            conn = virGetConnectNetwork();\n\n        virDomainNetNotifyActualDevice(conn, def, net);\n    }\n}\n\n/* Attempt to instantiate the filters. Ignore failures because it's\n * possible that someone deleted a filter binding and the associated\n * filter while the guest was running and we don't want that action\n * to cause failure to keep the guest running during the reconnection\n * processing. Nor do we necessarily want other failures to do the\n * same. We'll just log the error conditions other than of course\n * ignoreExists possibility (e.g. the true flag) */\nstatic void\nqemuProcessFiltersInstantiate(virDomainDefPtr def)\n{\n    size_t i;\n\n    for (i = 0; i < def->nnets; i++) {\n        virDomainNetDefPtr net = def->nets[i];\n        if ((net->filter) && (net->ifname)) {\n            if (virDomainConfNWFilterInstantiate(def->name, def->uuid, net,\n                                                 true) < 0) {\n                VIR_WARN(\"filter '%s' instantiation for '%s' failed '%s'\",\n                         net->filter, net->ifname, virGetLastErrorMessage());\n                virResetLastError();\n            }\n        }\n    }\n}\n\nstatic int\nqemuProcessUpdateState(virQEMUDriverPtr driver, virDomainObjPtr vm)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    virDomainState state;\n    virDomainPausedReason reason;\n    virDomainState newState = VIR_DOMAIN_NOSTATE;\n    int oldReason;\n    int newReason;\n    bool running;\n    g_autofree char *msg = NULL;\n    int ret;\n\n    qemuDomainObjEnterMonitor(driver, vm);\n    ret = qemuMonitorGetStatus(priv->mon, &running, &reason);\n    if (qemuDomainObjExitMonitor(driver, vm) < 0)\n        return -1;\n\n    if (ret < 0)\n        return -1;\n\n    state = virDomainObjGetState(vm, &oldReason);\n\n    if (running &&\n        (state == VIR_DOMAIN_SHUTOFF ||\n         (state == VIR_DOMAIN_PAUSED &&\n          oldReason == VIR_DOMAIN_PAUSED_STARTING_UP))) {\n        newState = VIR_DOMAIN_RUNNING;\n        newReason = VIR_DOMAIN_RUNNING_BOOTED;\n        msg = g_strdup(\"finished booting\");\n    } else if (state == VIR_DOMAIN_PAUSED && running) {\n        newState = VIR_DOMAIN_RUNNING;\n        newReason = VIR_DOMAIN_RUNNING_UNPAUSED;\n        msg = g_strdup(\"was unpaused\");\n    } else if (state == VIR_DOMAIN_RUNNING && !running) {\n        if (reason == VIR_DOMAIN_PAUSED_SHUTTING_DOWN) {\n            newState = VIR_DOMAIN_SHUTDOWN;\n            newReason = VIR_DOMAIN_SHUTDOWN_UNKNOWN;\n            msg = g_strdup(\"shutdown\");\n        } else if (reason == VIR_DOMAIN_PAUSED_CRASHED) {\n            newState = VIR_DOMAIN_CRASHED;\n            newReason = VIR_DOMAIN_CRASHED_PANICKED;\n            msg = g_strdup(\"crashed\");\n        } else {\n            newState = VIR_DOMAIN_PAUSED;\n            newReason = reason;\n            msg = g_strdup_printf(\"was paused (%s)\",\n                                  virDomainPausedReasonTypeToString(reason));\n        }\n    }\n\n    if (newState != VIR_DOMAIN_NOSTATE) {\n        VIR_DEBUG(\"Domain %s %s while its monitor was disconnected;\"\n                  \" changing state to %s (%s)\",\n                  vm->def->name,\n                  NULLSTR(msg),\n                  virDomainStateTypeToString(newState),\n                  virDomainStateReasonToString(newState, newReason));\n        virDomainObjSetState(vm, newState, newReason);\n    }\n\n    return 0;\n}\n\nstatic int\nqemuProcessRecoverMigrationIn(virQEMUDriverPtr driver,\n                              virDomainObjPtr vm,\n                              const qemuDomainJobObj *job,\n                              virDomainState state,\n                              int reason)\n{\n\n    qemuDomainJobPrivatePtr jobPriv = job->privateData;\n    bool postcopy = (state == VIR_DOMAIN_PAUSED &&\n                     reason == VIR_DOMAIN_PAUSED_POSTCOPY_FAILED) ||\n                    (state == VIR_DOMAIN_RUNNING &&\n                     reason == VIR_DOMAIN_RUNNING_POSTCOPY);\n\n    switch ((qemuMigrationJobPhase) job->phase) {\n    case QEMU_MIGRATION_PHASE_NONE:\n    case QEMU_MIGRATION_PHASE_PERFORM2:\n    case QEMU_MIGRATION_PHASE_BEGIN3:\n    case QEMU_MIGRATION_PHASE_PERFORM3:\n    case QEMU_MIGRATION_PHASE_PERFORM3_DONE:\n    case QEMU_MIGRATION_PHASE_CONFIRM3_CANCELLED:\n    case QEMU_MIGRATION_PHASE_CONFIRM3:\n    case QEMU_MIGRATION_PHASE_LAST:\n        /* N/A for incoming migration */\n        break;\n\n    case QEMU_MIGRATION_PHASE_PREPARE:\n        VIR_DEBUG(\"Killing unfinished incoming migration for domain %s\",\n                  vm->def->name);\n        return -1;\n\n    case QEMU_MIGRATION_PHASE_FINISH2:\n        /* source domain is already killed so let's just resume the domain\n         * and hope we are all set */\n        VIR_DEBUG(\"Incoming migration finished, resuming domain %s\",\n                  vm->def->name);\n        if (qemuProcessStartCPUs(driver, vm,\n                                 VIR_DOMAIN_RUNNING_MIGRATED,\n                                 QEMU_ASYNC_JOB_NONE) < 0) {\n            VIR_WARN(\"Could not resume domain %s\", vm->def->name);\n        }\n        break;\n\n    case QEMU_MIGRATION_PHASE_FINISH3:\n        /* migration finished, we started resuming the domain but didn't\n         * confirm success or failure yet; killing it seems safest unless\n         * we already started guest CPUs or we were in post-copy mode */\n        if (postcopy) {\n            qemuMigrationAnyPostcopyFailed(driver, vm);\n        } else if (state != VIR_DOMAIN_RUNNING) {\n            VIR_DEBUG(\"Killing migrated domain %s\", vm->def->name);\n            return -1;\n        }\n        break;\n    }\n\n    qemuMigrationParamsReset(driver, vm, QEMU_ASYNC_JOB_NONE,\n                             jobPriv->migParams, job->apiFlags);\n    return 0;\n}\n\nstatic int\nqemuProcessRecoverMigrationOut(virQEMUDriverPtr driver,\n                               virDomainObjPtr vm,\n                               const qemuDomainJobObj *job,\n                               virDomainState state,\n                               int reason,\n                               unsigned int *stopFlags)\n{\n    qemuDomainJobPrivatePtr jobPriv = job->privateData;\n    bool postcopy = state == VIR_DOMAIN_PAUSED &&\n                    (reason == VIR_DOMAIN_PAUSED_POSTCOPY ||\n                     reason == VIR_DOMAIN_PAUSED_POSTCOPY_FAILED);\n    bool resume = false;\n\n    switch ((qemuMigrationJobPhase) job->phase) {\n    case QEMU_MIGRATION_PHASE_NONE:\n    case QEMU_MIGRATION_PHASE_PREPARE:\n    case QEMU_MIGRATION_PHASE_FINISH2:\n    case QEMU_MIGRATION_PHASE_FINISH3:\n    case QEMU_MIGRATION_PHASE_LAST:\n        /* N/A for outgoing migration */\n        break;\n\n    case QEMU_MIGRATION_PHASE_BEGIN3:\n        /* nothing happened so far, just forget we were about to migrate the\n         * domain */\n        break;\n\n    case QEMU_MIGRATION_PHASE_PERFORM2:\n    case QEMU_MIGRATION_PHASE_PERFORM3:\n        /* migration is still in progress, let's cancel it and resume the\n         * domain; however we can only do that before migration enters\n         * post-copy mode\n         */\n        if (postcopy) {\n            qemuMigrationAnyPostcopyFailed(driver, vm);\n        } else {\n            VIR_DEBUG(\"Cancelling unfinished migration of domain %s\",\n                      vm->def->name);\n            if (qemuMigrationSrcCancel(driver, vm) < 0) {\n                VIR_WARN(\"Could not cancel ongoing migration of domain %s\",\n                         vm->def->name);\n            }\n            resume = true;\n        }\n        break;\n\n    case QEMU_MIGRATION_PHASE_PERFORM3_DONE:\n        /* migration finished but we didn't have a chance to get the result\n         * of Finish3 step; third party needs to check what to do next; in\n         * post-copy mode we can use PAUSED_POSTCOPY_FAILED state for this\n         */\n        if (postcopy)\n            qemuMigrationAnyPostcopyFailed(driver, vm);\n        break;\n\n    case QEMU_MIGRATION_PHASE_CONFIRM3_CANCELLED:\n        /* Finish3 failed, we need to resume the domain, but once we enter\n         * post-copy mode there's no way back, so let's just mark the domain\n         * as broken in that case\n         */\n        if (postcopy) {\n            qemuMigrationAnyPostcopyFailed(driver, vm);\n        } else {\n            VIR_DEBUG(\"Resuming domain %s after failed migration\",\n                      vm->def->name);\n            resume = true;\n        }\n        break;\n\n    case QEMU_MIGRATION_PHASE_CONFIRM3:\n        /* migration completed, we need to kill the domain here */\n        *stopFlags |= VIR_QEMU_PROCESS_STOP_MIGRATED;\n        return -1;\n    }\n\n    if (resume) {\n        /* resume the domain but only if it was paused as a result of\n         * migration\n         */\n        if (state == VIR_DOMAIN_PAUSED &&\n            (reason == VIR_DOMAIN_PAUSED_MIGRATION ||\n             reason == VIR_DOMAIN_PAUSED_UNKNOWN)) {\n            if (qemuProcessStartCPUs(driver, vm,\n                                     VIR_DOMAIN_RUNNING_MIGRATION_CANCELED,\n                                     QEMU_ASYNC_JOB_NONE) < 0) {\n                VIR_WARN(\"Could not resume domain %s\", vm->def->name);\n            }\n        }\n    }\n\n    qemuMigrationParamsReset(driver, vm, QEMU_ASYNC_JOB_NONE,\n                             jobPriv->migParams, job->apiFlags);\n    return 0;\n}\n\nstatic int\nqemuProcessRecoverJob(virQEMUDriverPtr driver,\n                      virDomainObjPtr vm,\n                      const qemuDomainJobObj *job,\n                      unsigned int *stopFlags)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    virDomainState state;\n    int reason;\n    unsigned long long now;\n\n    state = virDomainObjGetState(vm, &reason);\n\n    switch (job->asyncJob) {\n    case QEMU_ASYNC_JOB_MIGRATION_OUT:\n        if (qemuProcessRecoverMigrationOut(driver, vm, job,\n                                           state, reason, stopFlags) < 0)\n            return -1;\n        break;\n\n    case QEMU_ASYNC_JOB_MIGRATION_IN:\n        if (qemuProcessRecoverMigrationIn(driver, vm, job,\n                                          state, reason) < 0)\n            return -1;\n        break;\n\n    case QEMU_ASYNC_JOB_SAVE:\n    case QEMU_ASYNC_JOB_DUMP:\n    case QEMU_ASYNC_JOB_SNAPSHOT:\n        qemuDomainObjEnterMonitor(driver, vm);\n        ignore_value(qemuMonitorMigrateCancel(priv->mon));\n        if (qemuDomainObjExitMonitor(driver, vm) < 0)\n            return -1;\n        /* resume the domain but only if it was paused as a result of\n         * running a migration-to-file operation.  Although we are\n         * recovering an async job, this function is run at startup\n         * and must resume things using sync monitor connections.  */\n         if (state == VIR_DOMAIN_PAUSED &&\n             ((job->asyncJob == QEMU_ASYNC_JOB_DUMP &&\n               reason == VIR_DOMAIN_PAUSED_DUMP) ||\n              (job->asyncJob == QEMU_ASYNC_JOB_SAVE &&\n               reason == VIR_DOMAIN_PAUSED_SAVE) ||\n              (job->asyncJob == QEMU_ASYNC_JOB_SNAPSHOT &&\n               (reason == VIR_DOMAIN_PAUSED_SNAPSHOT ||\n                reason == VIR_DOMAIN_PAUSED_MIGRATION)) ||\n              reason == VIR_DOMAIN_PAUSED_UNKNOWN)) {\n             if (qemuProcessStartCPUs(driver, vm,\n                                      VIR_DOMAIN_RUNNING_SAVE_CANCELED,\n                                      QEMU_ASYNC_JOB_NONE) < 0) {\n                 VIR_WARN(\"Could not resume domain '%s' after migration to file\",\n                          vm->def->name);\n            }\n        }\n        break;\n\n    case QEMU_ASYNC_JOB_START:\n        /* Already handled in VIR_DOMAIN_PAUSED_STARTING_UP check. */\n        break;\n\n    case QEMU_ASYNC_JOB_BACKUP:\n        ignore_value(virTimeMillisNow(&now));\n\n        /* Restore the config of the async job which is not persisted */\n        priv->jobs_queued++;\n        priv->job.asyncJob = QEMU_ASYNC_JOB_BACKUP;\n        priv->job.asyncOwnerAPI = virThreadJobGet();\n        priv->job.asyncStarted = now;\n\n        qemuDomainObjSetAsyncJobMask(vm, (QEMU_JOB_DEFAULT_MASK |\n                                          JOB_MASK(QEMU_JOB_SUSPEND) |\n                                          JOB_MASK(QEMU_JOB_MODIFY)));\n\n        /* We reset the job parameters for backup so that the job will look\n         * active. This is possible because we are able to recover the state\n         * of blockjobs and also the backup job allows all sub-job types */\n        priv->job.current = g_new0(qemuDomainJobInfo, 1);\n        priv->job.current->operation = VIR_DOMAIN_JOB_OPERATION_BACKUP;\n        priv->job.current->statsType = QEMU_DOMAIN_JOB_STATS_TYPE_BACKUP;\n        priv->job.current->status = QEMU_DOMAIN_JOB_STATUS_ACTIVE;\n        priv->job.current->started = now;\n        break;\n\n    case QEMU_ASYNC_JOB_NONE:\n    case QEMU_ASYNC_JOB_LAST:\n        break;\n    }\n\n    if (!virDomainObjIsActive(vm))\n        return -1;\n\n    /* In case any special handling is added for job type that has been ignored\n     * before, QEMU_DOMAIN_TRACK_JOBS (from qemu_domain.h) needs to be updated\n     * for the job to be properly tracked in domain state XML.\n     */\n    switch (job->active) {\n    case QEMU_JOB_QUERY:\n        /* harmless */\n        break;\n\n    case QEMU_JOB_DESTROY:\n        VIR_DEBUG(\"Domain %s should have already been destroyed\",\n                  vm->def->name);\n        return -1;\n\n    case QEMU_JOB_SUSPEND:\n        /* mostly harmless */\n        break;\n\n    case QEMU_JOB_MODIFY:\n        /* XXX depending on the command we may be in an inconsistent state and\n         * we should probably fall back to \"monitor error\" state and refuse to\n         */\n        break;\n\n    case QEMU_JOB_MIGRATION_OP:\n    case QEMU_JOB_ABORT:\n    case QEMU_JOB_ASYNC:\n    case QEMU_JOB_ASYNC_NESTED:\n        /* async job was already handled above */\n    case QEMU_JOB_NONE:\n    case QEMU_JOB_LAST:\n        break;\n    }\n\n    return 0;\n}\n\nstatic int\nqemuProcessUpdateDevices(virQEMUDriverPtr driver,\n                         virDomainObjPtr vm)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    virDomainDeviceDef dev;\n    g_auto(GStrv) old = g_steal_pointer(&priv->qemuDevices);\n    GStrv tmp;\n\n    if (qemuDomainUpdateDeviceList(driver, vm, QEMU_ASYNC_JOB_NONE) < 0)\n        return -1;\n\n    if (!old)\n        return 0;\n\n    for (tmp = old; *tmp; tmp++) {\n        if (!g_strv_contains((const char **) priv->qemuDevices, *tmp) &&\n            virDomainDefFindDevice(vm->def, *tmp, &dev, false) == 0 &&\n            qemuDomainRemoveDevice(driver, vm, &dev))\n            return -1;\n    }\n\n    return 0;\n}\n\nstatic int\nqemuDomainPerfRestart(virDomainObjPtr vm)\n{\n    size_t i;\n    virDomainDefPtr def = vm->def;\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n\n    if (!(priv->perf = virPerfNew()))\n        return -1;\n\n    for (i = 0; i < VIR_PERF_EVENT_LAST; i++) {\n        if (def->perf.events[i] &&\n            def->perf.events[i] == VIR_TRISTATE_BOOL_YES) {\n\n            /* Failure to re-enable the perf event should not be fatal */\n            if (virPerfEventEnable(priv->perf, i, vm->pid) < 0)\n                def->perf.events[i] = VIR_TRISTATE_BOOL_NO;\n        }\n    }\n\n    return 0;\n}\n\n\nstatic void\nqemuProcessReconnectCheckMemAliasOrderMismatch(virDomainObjPtr vm)\n{\n    size_t i;\n    int aliasidx;\n    virDomainDefPtr def = vm->def;\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n\n    if (!virDomainDefHasMemoryHotplug(def) || def->nmems == 0)\n        return;\n\n    for (i = 0; i < def->nmems; i++) {\n        aliasidx = qemuDomainDeviceAliasIndex(&def->mems[i]->info, \"dimm\");\n\n        if (def->mems[i]->info.addr.dimm.slot != aliasidx) {\n            priv->memAliasOrderMismatch = true;\n            break;\n        }\n    }\n}\n\n\nstatic bool\nqemuProcessNeedHugepagesPath(virDomainDefPtr def,\n                             virDomainMemoryDefPtr mem)\n{\n    const long system_pagesize = virGetSystemPageSizeKB();\n    size_t i;\n\n    if (def->mem.source == VIR_DOMAIN_MEMORY_SOURCE_FILE)\n        return true;\n\n    for (i = 0; i < def->mem.nhugepages; i++) {\n        if (def->mem.hugepages[i].size != system_pagesize)\n            return true;\n    }\n\n    for (i = 0; i < def->nmems; i++) {\n        if (def->mems[i]->model == VIR_DOMAIN_MEMORY_MODEL_DIMM &&\n            def->mems[i]->pagesize &&\n            def->mems[i]->pagesize != system_pagesize)\n            return true;\n    }\n\n    if (mem &&\n        mem->model == VIR_DOMAIN_MEMORY_MODEL_DIMM &&\n        mem->pagesize &&\n        mem->pagesize != system_pagesize)\n        return true;\n\n    return false;\n}\n\n\nstatic bool\nqemuProcessNeedMemoryBackingPath(virDomainDefPtr def,\n                                 virDomainMemoryDefPtr mem)\n{\n    size_t i;\n    size_t numaNodes;\n\n    if (def->mem.source == VIR_DOMAIN_MEMORY_SOURCE_FILE ||\n        def->mem.access != VIR_DOMAIN_MEMORY_ACCESS_DEFAULT)\n        return true;\n\n    numaNodes = virDomainNumaGetNodeCount(def->numa);\n    for (i = 0; i < numaNodes; i++) {\n        if (virDomainNumaGetNodeMemoryAccessMode(def->numa, i)\n            != VIR_DOMAIN_MEMORY_ACCESS_DEFAULT)\n            return true;\n    }\n\n    if (mem &&\n        mem->model == VIR_DOMAIN_MEMORY_MODEL_DIMM &&\n        (mem->access != VIR_DOMAIN_MEMORY_ACCESS_DEFAULT ||\n         (mem->targetNode >= 0 &&\n          virDomainNumaGetNodeMemoryAccessMode(def->numa, mem->targetNode)\n          != VIR_DOMAIN_MEMORY_ACCESS_DEFAULT)))\n        return true;\n\n    return false;\n}\n\n\nstatic int\nqemuProcessBuildDestroyMemoryPathsImpl(virQEMUDriverPtr driver,\n                                       virDomainObjPtr vm,\n                                       const char *path,\n                                       bool build)\n{\n    if (build) {\n        if (virFileExists(path))\n            return 0;\n\n        if (virFileMakePathWithMode(path, 0700) < 0) {\n            virReportSystemError(errno,\n                                 _(\"Unable to create %s\"),\n                                 path);\n            return -1;\n        }\n\n        if (qemuSecurityDomainSetPathLabel(driver, vm, path, true) < 0)\n            return -1;\n    } else {\n        if (virFileDeleteTree(path) < 0)\n            return -1;\n    }\n\n    return 0;\n}\n\n\nint\nqemuProcessBuildDestroyMemoryPaths(virQEMUDriverPtr driver,\n                                   virDomainObjPtr vm,\n                                   virDomainMemoryDefPtr mem,\n                                   bool build)\n{\n\n    g_autoptr(virQEMUDriverConfig) cfg = virQEMUDriverGetConfig(driver);\n    size_t i;\n    bool shouldBuildHP = false;\n    bool shouldBuildMB = false;\n\n    if (build) {\n        shouldBuildHP = qemuProcessNeedHugepagesPath(vm->def, mem);\n        shouldBuildMB = qemuProcessNeedMemoryBackingPath(vm->def, mem);\n    }\n\n    if (!build || shouldBuildHP) {\n        for (i = 0; i < cfg->nhugetlbfs; i++) {\n            g_autofree char *path = NULL;\n            path = qemuGetDomainHugepagePath(driver, vm->def, &cfg->hugetlbfs[i]);\n\n            if (!path)\n                return -1;\n\n            if (qemuProcessBuildDestroyMemoryPathsImpl(driver, vm,\n                                                       path, build) < 0)\n                return -1;\n        }\n    }\n\n    if (!build || shouldBuildMB) {\n        g_autofree char *path = NULL;\n        if (qemuGetMemoryBackingDomainPath(driver, vm->def, &path) < 0)\n            return -1;\n\n        if (qemuProcessBuildDestroyMemoryPathsImpl(driver, vm,\n                                                   path, build) < 0)\n            return -1;\n    }\n\n    return 0;\n}\n\n\nint\nqemuProcessDestroyMemoryBackingPath(virQEMUDriverPtr driver,\n                                    virDomainObjPtr vm,\n                                    virDomainMemoryDefPtr mem)\n{\n    g_autofree char *path = NULL;\n\n    if (qemuGetMemoryBackingPath(driver, vm->def, mem->info.alias, &path) < 0)\n        return -1;\n\n    if (unlink(path) < 0 &&\n        errno != ENOENT) {\n        virReportSystemError(errno, _(\"Unable to remove %s\"), path);\n        return -1;\n    }\n\n    return 0;\n}\n\n\nstatic int\nqemuProcessVNCAllocatePorts(virQEMUDriverPtr driver,\n                            virDomainGraphicsDefPtr graphics,\n                            bool allocate)\n{\n    unsigned short port;\n\n    if (!allocate) {\n        if (graphics->data.vnc.autoport)\n            graphics->data.vnc.port = 5900;\n\n        return 0;\n    }\n\n    if (graphics->data.vnc.autoport) {\n        if (virPortAllocatorAcquire(driver->remotePorts, &port) < 0)\n            return -1;\n        graphics->data.vnc.port = port;\n    }\n\n    if (graphics->data.vnc.websocket == -1) {\n        if (virPortAllocatorAcquire(driver->webSocketPorts, &port) < 0)\n            return -1;\n        graphics->data.vnc.websocket = port;\n        graphics->data.vnc.websocketGenerated = true;\n    }\n\n    return 0;\n}\n\nstatic int\nqemuProcessSPICEAllocatePorts(virQEMUDriverPtr driver,\n                              virDomainGraphicsDefPtr graphics,\n                              bool allocate)\n{\n    g_autoptr(virQEMUDriverConfig) cfg = virQEMUDriverGetConfig(driver);\n    unsigned short port = 0;\n    unsigned short tlsPort;\n    size_t i;\n    int defaultMode = graphics->data.spice.defaultMode;\n\n    bool needTLSPort = false;\n    bool needPort = false;\n\n    if (graphics->data.spice.autoport) {\n        /* check if tlsPort or port need allocation */\n        for (i = 0; i < VIR_DOMAIN_GRAPHICS_SPICE_CHANNEL_LAST; i++) {\n            switch (graphics->data.spice.channels[i]) {\n            case VIR_DOMAIN_GRAPHICS_SPICE_CHANNEL_MODE_SECURE:\n                needTLSPort = true;\n                break;\n\n            case VIR_DOMAIN_GRAPHICS_SPICE_CHANNEL_MODE_INSECURE:\n                needPort = true;\n                break;\n\n            case VIR_DOMAIN_GRAPHICS_SPICE_CHANNEL_MODE_ANY:\n                /* default mode will be used */\n                break;\n            }\n        }\n        switch (defaultMode) {\n        case VIR_DOMAIN_GRAPHICS_SPICE_CHANNEL_MODE_SECURE:\n            needTLSPort = true;\n            break;\n\n        case VIR_DOMAIN_GRAPHICS_SPICE_CHANNEL_MODE_INSECURE:\n            needPort = true;\n            break;\n\n        case VIR_DOMAIN_GRAPHICS_SPICE_CHANNEL_MODE_ANY:\n            if (cfg->spiceTLS)\n                needTLSPort = true;\n            needPort = true;\n            break;\n        }\n    }\n\n    if (!allocate) {\n        if (needPort || graphics->data.spice.port == -1)\n            graphics->data.spice.port = 5901;\n\n        if (needTLSPort || graphics->data.spice.tlsPort == -1)\n            graphics->data.spice.tlsPort = 5902;\n\n        return 0;\n    }\n\n    if (needPort || graphics->data.spice.port == -1) {\n        if (virPortAllocatorAcquire(driver->remotePorts, &port) < 0)\n            return -1;\n\n        graphics->data.spice.port = port;\n\n        if (!graphics->data.spice.autoport)\n            graphics->data.spice.portReserved = true;\n    }\n\n    if (needTLSPort || graphics->data.spice.tlsPort == -1) {\n        if (!cfg->spiceTLS) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"Auto allocation of spice TLS port requested \"\n                             \"but spice TLS is disabled in qemu.conf\"));\n            return -1;\n        }\n\n        if (virPortAllocatorAcquire(driver->remotePorts, &tlsPort) < 0)\n            return -1;\n\n        graphics->data.spice.tlsPort = tlsPort;\n\n        if (!graphics->data.spice.autoport)\n            graphics->data.spice.tlsPortReserved = true;\n    }\n\n    return 0;\n}\n\n\nstatic int\nqemuProcessVerifyHypervFeatures(virDomainDefPtr def,\n                                virCPUDataPtr cpu)\n{\n    size_t i;\n    int rc;\n\n    for (i = 0; i < VIR_DOMAIN_HYPERV_LAST; i++) {\n        g_autofree char *cpuFeature = NULL;\n\n        /* always supported string property */\n        if (i == VIR_DOMAIN_HYPERV_VENDOR_ID ||\n            i == VIR_DOMAIN_HYPERV_SPINLOCKS)\n            continue;\n\n        if (def->hyperv_features[i] != VIR_TRISTATE_SWITCH_ON)\n            continue;\n\n        cpuFeature = g_strdup_printf(\"hv-%s\", virDomainHypervTypeToString(i));\n\n        rc = virCPUDataCheckFeature(cpu, cpuFeature);\n\n        if (rc < 0) {\n            return -1;\n        } else if (rc == 1) {\n            if (i == VIR_DOMAIN_HYPERV_STIMER) {\n                if (def->hyperv_stimer_direct != VIR_TRISTATE_SWITCH_ON)\n                    continue;\n\n                rc = virCPUDataCheckFeature(cpu, VIR_CPU_x86_HV_STIMER_DIRECT);\n                if (rc < 0)\n                    return -1;\n                else if (rc == 1)\n                    continue;\n\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                               _(\"host doesn't support hyperv stimer '%s' feature\"),\n                               \"direct\");\n                return -1;\n            }\n            continue;\n        }\n\n        switch ((virDomainHyperv) i) {\n        case VIR_DOMAIN_HYPERV_RELAXED:\n        case VIR_DOMAIN_HYPERV_VAPIC:\n            VIR_WARN(\"host doesn't support hyperv '%s' feature\",\n                     virDomainHypervTypeToString(i));\n            break;\n\n        case VIR_DOMAIN_HYPERV_VPINDEX:\n        case VIR_DOMAIN_HYPERV_RUNTIME:\n        case VIR_DOMAIN_HYPERV_SYNIC:\n        case VIR_DOMAIN_HYPERV_STIMER:\n        case VIR_DOMAIN_HYPERV_RESET:\n        case VIR_DOMAIN_HYPERV_FREQUENCIES:\n        case VIR_DOMAIN_HYPERV_REENLIGHTENMENT:\n        case VIR_DOMAIN_HYPERV_TLBFLUSH:\n        case VIR_DOMAIN_HYPERV_IPI:\n        case VIR_DOMAIN_HYPERV_EVMCS:\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"host doesn't support hyperv '%s' feature\"),\n                           virDomainHypervTypeToString(i));\n            return -1;\n\n        /* coverity[dead_error_begin] */\n        case VIR_DOMAIN_HYPERV_SPINLOCKS:\n        case VIR_DOMAIN_HYPERV_VENDOR_ID:\n        case VIR_DOMAIN_HYPERV_LAST:\n            break;\n        }\n    }\n\n    return 0;\n}\n\n\nstatic int\nqemuProcessVerifyKVMFeatures(virDomainDefPtr def,\n                             virCPUDataPtr cpu)\n{\n    int rc = 0;\n\n    if (def->features[VIR_DOMAIN_FEATURE_PVSPINLOCK] != VIR_TRISTATE_SWITCH_ON)\n        return 0;\n\n    rc = virCPUDataCheckFeature(cpu, VIR_CPU_x86_KVM_PV_UNHALT);\n\n    if (rc <= 0) {\n        if (rc == 0)\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"host doesn't support paravirtual spinlocks\"));\n        return -1;\n    }\n\n    return 0;\n}\n\n\nstatic int\nqemuProcessVerifyCPUFeatures(virDomainDefPtr def,\n                             virCPUDataPtr cpu)\n{\n    int rc;\n\n    rc = virCPUCheckFeature(def->os.arch, def->cpu, \"invtsc\");\n\n    if (rc < 0) {\n        return -1;\n    } else if (rc == 1) {\n        rc = virCPUDataCheckFeature(cpu, \"invtsc\");\n        if (rc <= 0) {\n            if (rc == 0) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                               _(\"host doesn't support invariant TSC\"));\n            }\n            return -1;\n        }\n    }\n\n    return 0;\n}\n\n\nstatic const char *\nqemuProcessTranslateCPUFeatures(const char *name,\n                                void *opaque)\n{\n    virQEMUCapsPtr qemuCaps = opaque;\n\n    return virQEMUCapsCPUFeatureFromQEMU(qemuCaps, name);\n}\n\n\nstatic int\nqemuProcessFetchGuestCPU(virQEMUDriverPtr driver,\n                         virDomainObjPtr vm,\n                         qemuDomainAsyncJob asyncJob,\n                         virCPUDataPtr *enabled,\n                         virCPUDataPtr *disabled)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    g_autoptr(virCPUData) dataEnabled = NULL;\n    g_autoptr(virCPUData) dataDisabled = NULL;\n    bool generic;\n    int rc;\n\n    *enabled = NULL;\n    *disabled = NULL;\n\n    generic = virQEMUCapsGet(priv->qemuCaps, QEMU_CAPS_CPU_UNAVAILABLE_FEATURES);\n\n    if (!generic && !ARCH_IS_X86(vm->def->os.arch))\n        return 0;\n\n    if (qemuDomainObjEnterMonitorAsync(driver, vm, asyncJob) < 0)\n        return -1;\n\n    if (generic) {\n        rc = qemuMonitorGetGuestCPU(priv->mon,\n                                    vm->def->os.arch,\n                                    qemuProcessTranslateCPUFeatures, priv->qemuCaps,\n                                    &dataEnabled, &dataDisabled);\n    } else {\n        rc = qemuMonitorGetGuestCPUx86(priv->mon, &dataEnabled, &dataDisabled);\n    }\n\n    if (qemuDomainObjExitMonitor(driver, vm) < 0)\n        return -1;\n\n    if (rc == -1)\n        return -1;\n\n    *enabled = g_steal_pointer(&dataEnabled);\n    *disabled = g_steal_pointer(&dataDisabled);\n    return 0;\n}\n\n\nstatic int\nqemuProcessVerifyCPU(virDomainObjPtr vm,\n                     virCPUDataPtr cpu)\n{\n    virDomainDefPtr def = vm->def;\n\n    if (!cpu)\n        return 0;\n\n    if (qemuProcessVerifyKVMFeatures(def, cpu) < 0 ||\n        qemuProcessVerifyHypervFeatures(def, cpu) < 0)\n        return -1;\n\n    if (!def->cpu ||\n        (def->cpu->mode == VIR_CPU_MODE_CUSTOM &&\n         !def->cpu->model))\n        return 0;\n\n    if (qemuProcessVerifyCPUFeatures(def, cpu) < 0)\n        return -1;\n\n    return 0;\n}\n\n\nstatic int\nqemuProcessUpdateLiveGuestCPU(virDomainObjPtr vm,\n                              virCPUDataPtr enabled,\n                              virCPUDataPtr disabled)\n{\n    virDomainDefPtr def = vm->def;\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    g_autoptr(virCPUDef) orig = NULL;\n    int rc;\n\n    if (!enabled)\n        return 0;\n\n    if (!def->cpu ||\n        (def->cpu->mode == VIR_CPU_MODE_CUSTOM &&\n         !def->cpu->model))\n        return 0;\n\n    if (!(orig = virCPUDefCopy(def->cpu)))\n        return -1;\n\n    if ((rc = virCPUUpdateLive(def->os.arch, def->cpu, enabled, disabled)) < 0) {\n        return -1;\n    } else if (rc == 0) {\n        /* Store the original CPU in priv if QEMU changed it and we didn't\n         * get the original CPU via migration, restore, or snapshot revert.\n         */\n        if (!priv->origCPU && !virCPUDefIsEqual(def->cpu, orig, false))\n            priv->origCPU = g_steal_pointer(&orig);\n\n        def->cpu->check = VIR_CPU_CHECK_FULL;\n    }\n\n    return 0;\n}\n\n\nstatic int\nqemuProcessUpdateAndVerifyCPU(virQEMUDriverPtr driver,\n                              virDomainObjPtr vm,\n                              qemuDomainAsyncJob asyncJob)\n{\n    virCPUDataPtr cpu = NULL;\n    virCPUDataPtr disabled = NULL;\n    int ret = -1;\n\n    if (qemuProcessFetchGuestCPU(driver, vm, asyncJob, &cpu, &disabled) < 0)\n        goto cleanup;\n\n    if (qemuProcessVerifyCPU(vm, cpu) < 0)\n        goto cleanup;\n\n    if (qemuProcessUpdateLiveGuestCPU(vm, cpu, disabled) < 0)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    virCPUDataFree(cpu);\n    virCPUDataFree(disabled);\n    return ret;\n}\n\n\nstatic int\nqemuProcessFetchCPUDefinitions(virQEMUDriverPtr driver,\n                               virDomainObjPtr vm,\n                               qemuDomainAsyncJob asyncJob,\n                               virDomainCapsCPUModelsPtr *cpuModels)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    g_autoptr(virDomainCapsCPUModels) models = NULL;\n    int rc;\n\n    if (qemuDomainObjEnterMonitorAsync(driver, vm, asyncJob) < 0)\n        return -1;\n\n    rc = virQEMUCapsFetchCPUModels(priv->mon, vm->def->os.arch, &models);\n\n    if (qemuDomainObjExitMonitor(driver, vm) < 0 || rc < 0)\n        return -1;\n\n    *cpuModels = g_steal_pointer(&models);\n    return 0;\n}\n\n\nstatic int\nqemuProcessUpdateCPU(virQEMUDriverPtr driver,\n                     virDomainObjPtr vm,\n                     qemuDomainAsyncJob asyncJob)\n{\n    g_autoptr(virCPUData) cpu = NULL;\n    g_autoptr(virCPUData) disabled = NULL;\n    g_autoptr(virDomainCapsCPUModels) models = NULL;\n\n    /* The host CPU model comes from host caps rather than QEMU caps so\n     * fallback must be allowed no matter what the user specified in the XML.\n     */\n    vm->def->cpu->fallback = VIR_CPU_FALLBACK_ALLOW;\n\n    if (qemuProcessFetchGuestCPU(driver, vm, asyncJob, &cpu, &disabled) < 0)\n        return -1;\n\n    if (qemuProcessUpdateLiveGuestCPU(vm, cpu, disabled) < 0)\n        return -1;\n\n    if (qemuProcessFetchCPUDefinitions(driver, vm, asyncJob, &models) < 0 ||\n        virCPUTranslate(vm->def->os.arch, vm->def->cpu, models) < 0)\n        return -1;\n\n    return 0;\n}\n\n\nstatic int\nqemuPrepareNVRAM(virQEMUDriverConfigPtr cfg,\n                 virDomainObjPtr vm)\n{\n    int ret = -1;\n    int srcFD = -1;\n    int dstFD = -1;\n    virDomainLoaderDefPtr loader = vm->def->os.loader;\n    bool created = false;\n    const char *master_nvram_path;\n    ssize_t r;\n\n    if (!loader || !loader->nvram || virFileExists(loader->nvram))\n        return 0;\n\n    master_nvram_path = loader->templt;\n    if (!loader->templt) {\n        size_t i;\n        for (i = 0; i < cfg->nfirmwares; i++) {\n            if (STREQ(cfg->firmwares[i]->name, loader->path)) {\n                master_nvram_path = cfg->firmwares[i]->nvram;\n                break;\n            }\n        }\n    }\n\n    if (!master_nvram_path) {\n        virReportError(VIR_ERR_OPERATION_FAILED,\n                       _(\"unable to find any master var store for \"\n                         \"loader: %s\"), loader->path);\n        goto cleanup;\n    }\n\n    if ((srcFD = virFileOpenAs(master_nvram_path, O_RDONLY,\n                               0, -1, -1, 0)) < 0) {\n        virReportSystemError(-srcFD,\n                             _(\"Failed to open file '%s'\"),\n                             master_nvram_path);\n        goto cleanup;\n    }\n    if ((dstFD = virFileOpenAs(loader->nvram,\n                               O_WRONLY | O_CREAT | O_EXCL,\n                               S_IRUSR | S_IWUSR,\n                               cfg->user, cfg->group, 0)) < 0) {\n        virReportSystemError(-dstFD,\n                             _(\"Failed to create file '%s'\"),\n                             loader->nvram);\n        goto cleanup;\n    }\n    created = true;\n\n    do {\n        char buf[1024];\n\n        if ((r = saferead(srcFD, buf, sizeof(buf))) < 0) {\n            virReportSystemError(errno,\n                                 _(\"Unable to read from file '%s'\"),\n                                 master_nvram_path);\n            goto cleanup;\n        }\n\n        if (safewrite(dstFD, buf, r) < 0) {\n            virReportSystemError(errno,\n                                 _(\"Unable to write to file '%s'\"),\n                                 loader->nvram);\n            goto cleanup;\n        }\n    } while (r);\n\n    if (VIR_CLOSE(srcFD) < 0) {\n        virReportSystemError(errno,\n                             _(\"Unable to close file '%s'\"),\n                             master_nvram_path);\n        goto cleanup;\n    }\n    if (VIR_CLOSE(dstFD) < 0) {\n        virReportSystemError(errno,\n                             _(\"Unable to close file '%s'\"),\n                             loader->nvram);\n        goto cleanup;\n    }\n\n    ret = 0;\n cleanup:\n    /* We successfully generated the nvram path, but failed to\n     * copy the file content. Roll back. */\n    if (ret < 0) {\n        if (created)\n            unlink(loader->nvram);\n    }\n\n    VIR_FORCE_CLOSE(srcFD);\n    VIR_FORCE_CLOSE(dstFD);\n    return ret;\n}\n\n\nstatic void\nqemuLogOperation(virDomainObjPtr vm,\n                 const char *msg,\n                 virCommandPtr cmd,\n                 qemuDomainLogContextPtr logCtxt)\n{\n    g_autofree char *timestamp = NULL;\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    int qemuVersion = virQEMUCapsGetVersion(priv->qemuCaps);\n    const char *package = virQEMUCapsGetPackage(priv->qemuCaps);\n    g_autofree char *hostname = virGetHostname();\n    struct utsname uts;\n\n    uname(&uts);\n\n    if ((timestamp = virTimeStringNow()) == NULL)\n        return;\n\n    if (qemuDomainLogContextWrite(logCtxt,\n                                  \"%s: %s %s, qemu version: %d.%d.%d%s, kernel: %s, hostname: %s\\n\",\n                                  timestamp, msg, VIR_LOG_VERSION_STRING,\n                                  (qemuVersion / 1000000) % 1000,\n                                  (qemuVersion / 1000) % 1000,\n                                  qemuVersion % 1000,\n                                  NULLSTR_EMPTY(package),\n                                  uts.release,\n                                  NULLSTR_EMPTY(hostname)) < 0)\n        return;\n\n    if (cmd) {\n        g_autofree char *args = virCommandToString(cmd, true);\n        qemuDomainLogContextWrite(logCtxt, \"%s\\n\", args);\n    }\n}\n\n\nvoid\nqemuProcessIncomingDefFree(qemuProcessIncomingDefPtr inc)\n{\n    if (!inc)\n        return;\n\n    g_free(inc->address);\n    g_free(inc->launchURI);\n    g_free(inc->deferredURI);\n    g_free(inc);\n}\n\n\n/*\n * This function does not copy @path, the caller is responsible for keeping\n * the @path pointer valid during the lifetime of the allocated\n * qemuProcessIncomingDef structure.\n *\n * The caller is responsible for closing @fd, calling\n * qemuProcessIncomingDefFree will NOT close it.\n */\nqemuProcessIncomingDefPtr\nqemuProcessIncomingDefNew(virQEMUCapsPtr qemuCaps,\n                          const char *listenAddress,\n                          const char *migrateFrom,\n                          int fd,\n                          const char *path)\n{\n    qemuProcessIncomingDefPtr inc = NULL;\n\n    if (qemuMigrationDstCheckProtocol(qemuCaps, migrateFrom) < 0)\n        return NULL;\n\n    inc = g_new0(qemuProcessIncomingDef, 1);\n\n    inc->address = g_strdup(listenAddress);\n\n    inc->launchURI = qemuMigrationDstGetURI(migrateFrom, fd);\n    if (!inc->launchURI)\n        goto error;\n\n    if (virQEMUCapsGet(qemuCaps, QEMU_CAPS_INCOMING_DEFER)) {\n        inc->deferredURI = inc->launchURI;\n        inc->launchURI = g_strdup(\"defer\");\n    }\n\n    inc->fd = fd;\n    inc->path = path;\n\n    return inc;\n\n error:\n    qemuProcessIncomingDefFree(inc);\n    return NULL;\n}\n\n\n/*\n * This function starts a new QEMU_ASYNC_JOB_START async job. The user is\n * responsible for calling qemuProcessEndJob to stop this job and for passing\n * QEMU_ASYNC_JOB_START as @asyncJob argument to any function requiring this\n * parameter between qemuProcessBeginJob and qemuProcessEndJob.\n */\nint\nqemuProcessBeginJob(virQEMUDriverPtr driver,\n                    virDomainObjPtr vm,\n                    virDomainJobOperation operation,\n                    unsigned long apiFlags)\n{\n    if (qemuDomainObjBeginAsyncJob(driver, vm, QEMU_ASYNC_JOB_START,\n                                   operation, apiFlags) < 0)\n        return -1;\n\n    qemuDomainObjSetAsyncJobMask(vm, QEMU_JOB_NONE);\n    return 0;\n}\n\n\nvoid\nqemuProcessEndJob(virQEMUDriverPtr driver,\n                  virDomainObjPtr vm)\n{\n    qemuDomainObjEndAsyncJob(driver, vm);\n}\n\n\nstatic int\nqemuProcessStartHook(virQEMUDriverPtr driver,\n                     virDomainObjPtr vm,\n                     virHookQemuOpType op,\n                     virHookSubopType subop)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    g_autofree char *xml = NULL;\n    int ret;\n\n    if (!virHookPresent(VIR_HOOK_DRIVER_QEMU))\n        return 0;\n\n    if (!(xml = qemuDomainDefFormatXML(driver, priv->qemuCaps, vm->def, 0)))\n        return -1;\n\n    ret = virHookCall(VIR_HOOK_DRIVER_QEMU, vm->def->name, op, subop,\n                      NULL, xml, NULL);\n\n    return ret;\n}\n\n\nstatic int\nqemuProcessGraphicsReservePorts(virDomainGraphicsDefPtr graphics,\n                                bool reconnect)\n{\n    virDomainGraphicsListenDefPtr glisten;\n\n    if (graphics->nListens <= 0)\n        return 0;\n\n    glisten = &graphics->listens[0];\n\n    if (glisten->type != VIR_DOMAIN_GRAPHICS_LISTEN_TYPE_ADDRESS &&\n        glisten->type != VIR_DOMAIN_GRAPHICS_LISTEN_TYPE_NETWORK)\n        return 0;\n\n    switch (graphics->type) {\n    case VIR_DOMAIN_GRAPHICS_TYPE_VNC:\n        if (!graphics->data.vnc.autoport ||\n            reconnect) {\n            if (virPortAllocatorSetUsed(graphics->data.vnc.port) < 0)\n                return -1;\n            graphics->data.vnc.portReserved = true;\n        }\n        if (graphics->data.vnc.websocket > 0 &&\n            virPortAllocatorSetUsed(graphics->data.vnc.websocket) < 0)\n            return -1;\n        break;\n\n    case VIR_DOMAIN_GRAPHICS_TYPE_SPICE:\n        if (graphics->data.spice.autoport && !reconnect)\n            return 0;\n\n        if (graphics->data.spice.port > 0) {\n            if (virPortAllocatorSetUsed(graphics->data.spice.port) < 0)\n                return -1;\n            graphics->data.spice.portReserved = true;\n        }\n\n        if (graphics->data.spice.tlsPort > 0) {\n            if (virPortAllocatorSetUsed(graphics->data.spice.tlsPort) < 0)\n                return -1;\n            graphics->data.spice.tlsPortReserved = true;\n        }\n        break;\n\n    case VIR_DOMAIN_GRAPHICS_TYPE_SDL:\n    case VIR_DOMAIN_GRAPHICS_TYPE_RDP:\n    case VIR_DOMAIN_GRAPHICS_TYPE_DESKTOP:\n    case VIR_DOMAIN_GRAPHICS_TYPE_EGL_HEADLESS:\n    case VIR_DOMAIN_GRAPHICS_TYPE_LAST:\n        break;\n    }\n\n    return 0;\n}\n\n\nstatic int\nqemuProcessGraphicsAllocatePorts(virQEMUDriverPtr driver,\n                                 virDomainGraphicsDefPtr graphics,\n                                 bool allocate)\n{\n    virDomainGraphicsListenDefPtr glisten;\n\n    if (graphics->nListens <= 0)\n        return 0;\n\n    glisten = &graphics->listens[0];\n\n    if (glisten->type != VIR_DOMAIN_GRAPHICS_LISTEN_TYPE_ADDRESS &&\n        glisten->type != VIR_DOMAIN_GRAPHICS_LISTEN_TYPE_NETWORK)\n        return 0;\n\n    switch (graphics->type) {\n    case VIR_DOMAIN_GRAPHICS_TYPE_VNC:\n        if (qemuProcessVNCAllocatePorts(driver, graphics, allocate) < 0)\n            return -1;\n        break;\n\n    case VIR_DOMAIN_GRAPHICS_TYPE_SPICE:\n        if (qemuProcessSPICEAllocatePorts(driver, graphics, allocate) < 0)\n            return -1;\n        break;\n\n    case VIR_DOMAIN_GRAPHICS_TYPE_SDL:\n    case VIR_DOMAIN_GRAPHICS_TYPE_RDP:\n    case VIR_DOMAIN_GRAPHICS_TYPE_DESKTOP:\n    case VIR_DOMAIN_GRAPHICS_TYPE_EGL_HEADLESS:\n    case VIR_DOMAIN_GRAPHICS_TYPE_LAST:\n        break;\n    }\n\n    return 0;\n}\n\nstatic int\nqemuProcessGetNetworkAddress(const char *netname,\n                             char **netaddr)\n{\n    g_autoptr(virConnect) conn = NULL;\n    int ret = -1;\n    g_autoptr(virNetwork) net = NULL;\n    virNetworkDefPtr netdef = NULL;\n    virNetworkIPDefPtr ipdef;\n    virSocketAddr addr;\n    virSocketAddrPtr addrptr = NULL;\n    char *dev_name = NULL;\n    g_autofree char *xml = NULL;\n\n    *netaddr = NULL;\n\n    if (!(conn = virGetConnectNetwork()))\n        return -1;\n\n    net = virNetworkLookupByName(conn, netname);\n    if (!net)\n        goto cleanup;\n\n    xml = virNetworkGetXMLDesc(net, 0);\n    if (!xml)\n        goto cleanup;\n\n    netdef = virNetworkDefParseString(xml, NULL);\n    if (!netdef)\n        goto cleanup;\n\n    switch ((virNetworkForwardType) netdef->forward.type) {\n    case VIR_NETWORK_FORWARD_NONE:\n    case VIR_NETWORK_FORWARD_NAT:\n    case VIR_NETWORK_FORWARD_ROUTE:\n    case VIR_NETWORK_FORWARD_OPEN:\n        ipdef = virNetworkDefGetIPByIndex(netdef, AF_UNSPEC, 0);\n        if (!ipdef) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"network '%s' doesn't have an IP address\"),\n                           netdef->name);\n            goto cleanup;\n        }\n        addrptr = &ipdef->address;\n        break;\n\n    case VIR_NETWORK_FORWARD_BRIDGE:\n        if ((dev_name = netdef->bridge))\n            break;\n        /*\n         * fall through if netdef->bridge wasn't set, since that is\n         * macvtap bridge mode network.\n         */\n        G_GNUC_FALLTHROUGH;\n\n    case VIR_NETWORK_FORWARD_PRIVATE:\n    case VIR_NETWORK_FORWARD_VEPA:\n    case VIR_NETWORK_FORWARD_PASSTHROUGH:\n        if ((netdef->forward.nifs > 0) && netdef->forward.ifs)\n            dev_name = netdef->forward.ifs[0].device.dev;\n\n        if (!dev_name) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"network '%s' has no associated interface or bridge\"),\n                           netdef->name);\n            goto cleanup;\n        }\n        break;\n\n    case VIR_NETWORK_FORWARD_HOSTDEV:\n        break;\n\n    case VIR_NETWORK_FORWARD_LAST:\n    default:\n        virReportEnumRangeError(virNetworkForwardType, netdef->forward.type);\n        goto cleanup;\n    }\n\n    if (dev_name) {\n        if (virNetDevIPAddrGet(dev_name, &addr) < 0)\n            goto cleanup;\n        addrptr = &addr;\n    }\n\n    if (!(addrptr &&\n          (*netaddr = virSocketAddrFormat(addrptr)))) {\n        goto cleanup;\n    }\n\n    ret = 0;\n cleanup:\n    virNetworkDefFree(netdef);\n    return ret;\n}\n\n\nstatic int\nqemuProcessGraphicsSetupNetworkAddress(virDomainGraphicsListenDefPtr glisten,\n                                       const char *listenAddr)\n{\n    int rc;\n\n    /* TODO: reject configuration without network specified for network listen */\n    if (!glisten->network) {\n        glisten->address = g_strdup(listenAddr);\n        return 0;\n    }\n\n    rc = qemuProcessGetNetworkAddress(glisten->network, &glisten->address);\n    if (rc <= -2) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"network-based listen isn't possible, \"\n                         \"network driver isn't present\"));\n        return -1;\n    }\n    if (rc < 0)\n        return -1;\n\n    return 0;\n}\n\n\nstatic int\nqemuProcessGraphicsSetupListen(virQEMUDriverPtr driver,\n                               virDomainGraphicsDefPtr graphics,\n                               virDomainObjPtr vm)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    g_autoptr(virQEMUDriverConfig) cfg = virQEMUDriverGetConfig(driver);\n    const char *type = virDomainGraphicsTypeToString(graphics->type);\n    char *listenAddr = NULL;\n    bool useSocket = false;\n    size_t i;\n\n    switch (graphics->type) {\n    case VIR_DOMAIN_GRAPHICS_TYPE_VNC:\n        useSocket = cfg->vncAutoUnixSocket;\n        listenAddr = cfg->vncListen;\n        break;\n\n    case VIR_DOMAIN_GRAPHICS_TYPE_SPICE:\n        useSocket = cfg->spiceAutoUnixSocket;\n        listenAddr = cfg->spiceListen;\n        break;\n\n    case VIR_DOMAIN_GRAPHICS_TYPE_SDL:\n    case VIR_DOMAIN_GRAPHICS_TYPE_RDP:\n    case VIR_DOMAIN_GRAPHICS_TYPE_DESKTOP:\n    case VIR_DOMAIN_GRAPHICS_TYPE_EGL_HEADLESS:\n    case VIR_DOMAIN_GRAPHICS_TYPE_LAST:\n        break;\n    }\n\n    for (i = 0; i < graphics->nListens; i++) {\n        virDomainGraphicsListenDefPtr glisten = &graphics->listens[i];\n\n        switch (glisten->type) {\n        case VIR_DOMAIN_GRAPHICS_LISTEN_TYPE_ADDRESS:\n            if (!glisten->address) {\n                /* If there is no address specified and qemu.conf has\n                 * *_auto_unix_socket set we should use unix socket as\n                 * default instead of tcp listen. */\n                if (useSocket) {\n                    memset(glisten, 0, sizeof(virDomainGraphicsListenDef));\n                    glisten->socket = g_strdup_printf(\"%s/%s.sock\", priv->libDir,\n                                                      type);\n                    glisten->fromConfig = true;\n                    glisten->type = VIR_DOMAIN_GRAPHICS_LISTEN_TYPE_SOCKET;\n                } else if (listenAddr) {\n                    glisten->address = g_strdup(listenAddr);\n                    glisten->fromConfig = true;\n                }\n            }\n            break;\n\n        case VIR_DOMAIN_GRAPHICS_LISTEN_TYPE_NETWORK:\n            if (glisten->address || !listenAddr)\n                continue;\n\n            if (qemuProcessGraphicsSetupNetworkAddress(glisten,\n                                                       listenAddr) < 0)\n                return -1;\n            break;\n\n        case VIR_DOMAIN_GRAPHICS_LISTEN_TYPE_SOCKET:\n            if (!glisten->socket) {\n                glisten->socket = g_strdup_printf(\"%s/%s.sock\", priv->libDir,\n                                                  type);\n                glisten->autoGenerated = true;\n            }\n            break;\n\n        case VIR_DOMAIN_GRAPHICS_LISTEN_TYPE_NONE:\n        case VIR_DOMAIN_GRAPHICS_LISTEN_TYPE_LAST:\n            break;\n        }\n    }\n\n    return 0;\n}\n\n\nstatic int\nqemuProcessGraphicsSetupRenderNode(virDomainGraphicsDefPtr graphics,\n                                   virQEMUCapsPtr qemuCaps)\n{\n    char **rendernode = NULL;\n\n    if (!virDomainGraphicsNeedsAutoRenderNode(graphics))\n        return 0;\n\n    /* Don't bother picking a DRM node if QEMU doesn't support it. */\n    if (graphics->type == VIR_DOMAIN_GRAPHICS_TYPE_SPICE) {\n        if (!virQEMUCapsGet(qemuCaps, QEMU_CAPS_SPICE_RENDERNODE))\n            return 0;\n\n        rendernode = &graphics->data.spice.rendernode;\n    } else {\n        if (!virQEMUCapsGet(qemuCaps, QEMU_CAPS_EGL_HEADLESS_RENDERNODE))\n            return 0;\n\n        rendernode = &graphics->data.egl_headless.rendernode;\n    }\n\n    if (!(*rendernode = virHostGetDRMRenderNode()))\n        return -1;\n\n    return 0;\n}\n\n\nstatic int\nqemuProcessSetupGraphics(virQEMUDriverPtr driver,\n                         virDomainObjPtr vm,\n                         virQEMUCapsPtr qemuCaps,\n                         unsigned int flags)\n{\n    virDomainGraphicsDefPtr graphics;\n    bool allocate = !(flags & VIR_QEMU_PROCESS_START_PRETEND);\n    size_t i;\n\n    for (i = 0; i < vm->def->ngraphics; i++) {\n        graphics = vm->def->graphics[i];\n\n        if (qemuProcessGraphicsSetupRenderNode(graphics, qemuCaps) < 0)\n            return -1;\n\n        if (qemuProcessGraphicsSetupListen(driver, graphics, vm) < 0)\n            return -1;\n    }\n\n    if (allocate) {\n        for (i = 0; i < vm->def->ngraphics; i++) {\n            graphics = vm->def->graphics[i];\n\n            if (qemuProcessGraphicsReservePorts(graphics, false) < 0)\n                return -1;\n        }\n    }\n\n    for (i = 0; i < vm->def->ngraphics; ++i) {\n        graphics = vm->def->graphics[i];\n\n        if (qemuProcessGraphicsAllocatePorts(driver, graphics, allocate) < 0)\n            return -1;\n    }\n\n    return 0;\n}\n\n\nstatic int\nqemuProcessSetupRawIO(virQEMUDriverPtr driver,\n                      virDomainObjPtr vm,\n                      virCommandPtr cmd G_GNUC_UNUSED)\n{\n    bool rawio = false;\n    size_t i;\n    int ret = -1;\n\n    /* in case a certain disk is desirous of CAP_SYS_RAWIO, add this */\n    for (i = 0; i < vm->def->ndisks; i++) {\n        virDomainDeviceDef dev;\n        virDomainDiskDefPtr disk = vm->def->disks[i];\n\n        if (disk->rawio == VIR_TRISTATE_BOOL_YES) {\n            rawio = true;\n#ifndef CAP_SYS_RAWIO\n            break;\n#endif\n        }\n\n        dev.type = VIR_DOMAIN_DEVICE_DISK;\n        dev.data.disk = disk;\n        if (qemuAddSharedDevice(driver, &dev, vm->def->name) < 0)\n            goto cleanup;\n\n        if (qemuSetUnprivSGIO(&dev) < 0)\n            goto cleanup;\n    }\n\n    /* If rawio not already set, check hostdevs as well */\n    if (!rawio) {\n        for (i = 0; i < vm->def->nhostdevs; i++) {\n            virDomainHostdevSubsysSCSIPtr scsisrc;\n\n            if (!virHostdevIsSCSIDevice(vm->def->hostdevs[i]))\n                continue;\n\n            scsisrc = &vm->def->hostdevs[i]->source.subsys.u.scsi;\n            if (scsisrc->rawio == VIR_TRISTATE_BOOL_YES) {\n                rawio = true;\n                break;\n            }\n        }\n    }\n\n    ret = 0;\n\n cleanup:\n    if (rawio) {\n#ifdef CAP_SYS_RAWIO\n        if (ret == 0)\n            virCommandAllowCap(cmd, CAP_SYS_RAWIO);\n#else\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Raw I/O is not supported on this platform\"));\n        ret = -1;\n#endif\n    }\n    return ret;\n}\n\n\nstatic int\nqemuProcessSetupBalloon(virQEMUDriverPtr driver,\n                        virDomainObjPtr vm,\n                        qemuDomainAsyncJob asyncJob)\n{\n    unsigned long long balloon = vm->def->mem.cur_balloon;\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    int ret = -1;\n\n    if (!virDomainDefHasMemballoon(vm->def))\n        return 0;\n\n    if (qemuDomainObjEnterMonitorAsync(driver, vm, asyncJob) < 0)\n        return -1;\n\n    if (vm->def->memballoon->period)\n        qemuMonitorSetMemoryStatsPeriod(priv->mon, vm->def->memballoon,\n                                        vm->def->memballoon->period);\n    if (qemuMonitorSetBalloon(priv->mon, balloon) < 0)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    if (qemuDomainObjExitMonitor(driver, vm) < 0)\n        ret = -1;\n    return ret;\n}\n\n\nstatic int\nqemuProcessMakeDir(virQEMUDriverPtr driver,\n                   virDomainObjPtr vm,\n                   const char *path)\n{\n    if (virFileMakePathWithMode(path, 0750) < 0) {\n        virReportSystemError(errno, _(\"Cannot create directory '%s'\"), path);\n        return -1;\n    }\n\n    if (qemuSecurityDomainSetPathLabel(driver, vm, path, true) < 0)\n        return -1;\n\n    return 0;\n}\n\n\nstatic void\nqemuProcessStartWarnShmem(virDomainObjPtr vm)\n{\n    size_t i;\n    bool check_shmem = false;\n    bool shmem = vm->def->nshmems;\n\n    /*\n     * For vhost-user to work, the domain has to have some type of\n     * shared memory configured.  We're not the proper ones to judge\n     * whether shared hugepages or shm are enough and will be in the\n     * future, so we'll just warn in case neither is configured.\n     * Moreover failing would give the false illusion that libvirt is\n     * really checking that everything works before running the domain\n     * and not only we are unable to do that, but it's also not our\n     * aim to do so.\n     */\n    for (i = 0; i < vm->def->nnets; i++) {\n        if (virDomainNetGetActualType(vm->def->nets[i]) ==\n                                      VIR_DOMAIN_NET_TYPE_VHOSTUSER) {\n            check_shmem = true;\n            break;\n        }\n    }\n\n    if (!check_shmem)\n        return;\n\n    /*\n     * This check is by no means complete.  We merely check\n     * whether there are *some* hugepages enabled and *some* NUMA\n     * nodes with shared memory access.\n     */\n    if (!shmem && vm->def->mem.nhugepages) {\n        for (i = 0; i < virDomainNumaGetNodeCount(vm->def->numa); i++) {\n            if (virDomainNumaGetNodeMemoryAccessMode(vm->def->numa, i) ==\n                VIR_DOMAIN_MEMORY_ACCESS_SHARED) {\n                shmem = true;\n                break;\n            }\n        }\n    }\n\n    if (!shmem) {\n        VIR_WARN(\"Detected vhost-user interface without any shared memory, \"\n                 \"the interface might not be operational\");\n    }\n}\n\n\nstatic int\nqemuProcessStartValidateGraphics(virDomainObjPtr vm)\n{\n    size_t i;\n\n    for (i = 0; i < vm->def->ngraphics; i++) {\n        virDomainGraphicsDefPtr graphics = vm->def->graphics[i];\n\n        switch (graphics->type) {\n        case VIR_DOMAIN_GRAPHICS_TYPE_VNC:\n        case VIR_DOMAIN_GRAPHICS_TYPE_SPICE:\n            if (graphics->nListens > 1) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                               _(\"QEMU does not support multiple listens for \"\n                                 \"one graphics device.\"));\n                return -1;\n            }\n            break;\n\n        case VIR_DOMAIN_GRAPHICS_TYPE_SDL:\n        case VIR_DOMAIN_GRAPHICS_TYPE_RDP:\n        case VIR_DOMAIN_GRAPHICS_TYPE_DESKTOP:\n        case VIR_DOMAIN_GRAPHICS_TYPE_EGL_HEADLESS:\n        case VIR_DOMAIN_GRAPHICS_TYPE_LAST:\n            break;\n        }\n    }\n\n    return 0;\n}\n\n\nstatic int\nqemuProcessStartValidateIOThreads(virDomainObjPtr vm,\n                                  virQEMUCapsPtr qemuCaps)\n{\n    size_t i;\n\n    if (vm->def->niothreadids > 0 &&\n        !virQEMUCapsGet(qemuCaps, QEMU_CAPS_OBJECT_IOTHREAD)) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"IOThreads not supported for this QEMU\"));\n        return -1;\n    }\n\n    for (i = 0; i < vm->def->ncontrollers; i++) {\n        virDomainControllerDefPtr cont = vm->def->controllers[i];\n\n        if (cont->type == VIR_DOMAIN_CONTROLLER_TYPE_SCSI &&\n            cont->model == VIR_DOMAIN_CONTROLLER_MODEL_SCSI_VIRTIO_SCSI &&\n            cont->iothread > 0 &&\n            !virQEMUCapsGet(qemuCaps, QEMU_CAPS_VIRTIO_SCSI_IOTHREAD)) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"IOThreads for virtio-scsi not supported for \"\n                             \"this QEMU\"));\n            return -1;\n        }\n    }\n\n    return 0;\n}\n\n\nstatic int\nqemuProcessStartValidateShmem(virDomainObjPtr vm)\n{\n    size_t i;\n\n    for (i = 0; i < vm->def->nshmems; i++) {\n        virDomainShmemDefPtr shmem = vm->def->shmems[i];\n\n        if (strchr(shmem->name, '/')) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"shmem name '%s' must not contain '/'\"),\n                           shmem->name);\n            return -1;\n        }\n    }\n\n    return 0;\n}\n\n\nstatic int\nqemuProcessStartValidateDisks(virDomainObjPtr vm,\n                              virQEMUCapsPtr qemuCaps)\n{\n    size_t i;\n\n    for (i = 0; i < vm->def->ndisks; i++) {\n        virDomainDiskDefPtr disk = vm->def->disks[i];\n        virStorageSourcePtr src = disk->src;\n\n        /* This is a best effort check as we can only check if the command\n         * option exists, but we cannot determine whether the running QEMU\n         * was build with '--enable-vxhs'. */\n        if (src->type == VIR_STORAGE_TYPE_NETWORK &&\n            src->protocol == VIR_STORAGE_NET_PROTOCOL_VXHS &&\n            !virQEMUCapsGet(qemuCaps, QEMU_CAPS_VXHS)) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"VxHS protocol is not supported with this \"\n                             \"QEMU binary\"));\n            return -1;\n        }\n\n        /* PowerPC pseries based VMs do not support floppy device */\n        if (disk->device == VIR_DOMAIN_DISK_DEVICE_FLOPPY &&\n            qemuDomainIsPSeries(vm->def)) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"PowerPC pseries machines do not support floppy device\"));\n            return -1;\n        }\n\n        if (src->type == VIR_STORAGE_TYPE_NVME &&\n            !virQEMUCapsGet(qemuCaps, QEMU_CAPS_DRIVE_NVME)) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"NVMe disks are not supported with this QEMU binary\"));\n            return -1;\n        }\n    }\n\n    return 0;\n}\n\n\n/* 250 parts per million (ppm) is a half of NTP threshold */\n#define TSC_TOLERANCE 250\n\nstatic int\nqemuProcessStartValidateTSC(virQEMUDriverPtr driver,\n                            virDomainObjPtr vm)\n{\n    size_t i;\n    unsigned long long freq = 0;\n    unsigned long long tolerance;\n    unsigned long long minFreq;\n    unsigned long long maxFreq;\n    virHostCPUTscInfoPtr tsc;\n    g_autoptr(virCPUDef) cpu = NULL;\n\n    for (i = 0; i < vm->def->clock.ntimers; i++) {\n        virDomainTimerDefPtr timer = vm->def->clock.timers[i];\n\n        if (timer->name == VIR_DOMAIN_TIMER_NAME_TSC &&\n            timer->frequency > 0) {\n            freq = timer->frequency;\n            break;\n        }\n    }\n\n    if (freq == 0)\n        return 0;\n\n    VIR_DEBUG(\"Requested TSC frequency %llu Hz\", freq);\n\n    cpu = virQEMUDriverGetHostCPU(driver);\n    if (!cpu || !cpu->tsc) {\n        VIR_DEBUG(\"Host TSC frequency could not be probed\");\n        return 0;\n    }\n\n    tsc = cpu->tsc;\n    tolerance = tsc->frequency * TSC_TOLERANCE / 1000000;\n    minFreq = tsc->frequency - tolerance;\n    maxFreq = tsc->frequency + tolerance;\n\n    VIR_DEBUG(\"Host TSC frequency %llu Hz, scaling %s, tolerance +/- %llu Hz\",\n              tsc->frequency, virTristateBoolTypeToString(tsc->scaling),\n              tolerance);\n\n    if (freq >= minFreq && freq <= maxFreq) {\n        VIR_DEBUG(\"Requested TSC frequency is within tolerance interval\");\n        return 0;\n    }\n\n    if (tsc->scaling == VIR_TRISTATE_BOOL_YES)\n        return 0;\n\n    if (tsc->scaling == VIR_TRISTATE_BOOL_ABSENT) {\n        VIR_DEBUG(\"Requested TSC frequency falls outside tolerance range and \"\n                  \"scaling support is unknown, QEMU will try and possibly \"\n                  \"fail later\");\n        return 0;\n    }\n\n    virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                   _(\"Requested TSC frequency %llu Hz is outside tolerance \"\n                     \"range ([%llu, %llu] Hz) around host frequency %llu Hz \"\n                     \"and TSC scaling is not supported by the host CPU\"),\n                   freq, minFreq, maxFreq, tsc->frequency);\n    return -1;\n}\n\n\n/**\n * qemuProcessStartValidate:\n * @vm: domain object\n * @qemuCaps: emulator capabilities\n * @migration: restoration of existing state\n *\n * This function aggregates checks done prior to start of a VM.\n *\n * Flag VIR_QEMU_PROCESS_START_PRETEND tells, that we don't want to actually\n * start the domain but create a valid qemu command.  If some code shouldn't be\n * executed in this case, make sure to check this flag.\n */\nstatic int\nqemuProcessStartValidate(virQEMUDriverPtr driver,\n                         virDomainObjPtr vm,\n                         virQEMUCapsPtr qemuCaps,\n                         unsigned int flags)\n{\n    if (!(flags & VIR_QEMU_PROCESS_START_PRETEND)) {\n        if (vm->def->virtType == VIR_DOMAIN_VIRT_KVM) {\n            VIR_DEBUG(\"Checking for KVM availability\");\n            if (!virFileExists(\"/dev/kvm\")) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                               _(\"Domain requires KVM, but it is not available. \"\n                                 \"Check that virtualization is enabled in the \"\n                                 \"host BIOS, and host configuration is setup to \"\n                                 \"load the kvm modules.\"));\n                return -1;\n            }\n        }\n\n        VIR_DEBUG(\"Checking domain and device security labels\");\n        if (qemuSecurityCheckAllLabel(driver->securityManager, vm->def) < 0)\n            return -1;\n\n    }\n\n    /* Checks below should not be executed when starting a qemu process for a\n     * VM that was running before (migration, snapshots, save). It's more\n     * important to start such VM than keep the configuration clean */\n    if ((flags & VIR_QEMU_PROCESS_START_NEW) &&\n        virDomainDefValidate(vm->def, 0, driver->xmlopt, qemuCaps) < 0)\n        return -1;\n\n    if (qemuProcessStartValidateGraphics(vm) < 0)\n        return -1;\n\n    if (qemuProcessStartValidateIOThreads(vm, qemuCaps) < 0)\n        return -1;\n\n    if (qemuProcessStartValidateShmem(vm) < 0)\n        return -1;\n\n    if (vm->def->cpu) {\n        if (virCPUValidateFeatures(vm->def->os.arch, vm->def->cpu) < 0)\n            return -1;\n\n        if (ARCH_IS_X86(vm->def->os.arch) &&\n            !virQEMUCapsGet(qemuCaps, QEMU_CAPS_CPU_UNAVAILABLE_FEATURES)) {\n            g_auto(GStrv) features = NULL;\n            int n;\n\n            if ((n = virCPUDefCheckFeatures(vm->def->cpu,\n                                            virCPUx86FeatureFilterSelectMSR,\n                                            NULL,\n                                            &features)) < 0)\n                return -1;\n\n            if (n > 0) {\n                g_autofree char *str = NULL;\n\n                str = g_strjoinv(\", \", features);\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                               _(\"Some features cannot be reliably used \"\n                                 \"with this QEMU: %s\"), str);\n                return -1;\n            }\n        }\n    }\n\n    if (qemuProcessStartValidateDisks(vm, qemuCaps) < 0)\n        return -1;\n\n    if (qemuProcessStartValidateTSC(driver, vm) < 0)\n        return -1;\n\n    VIR_DEBUG(\"Checking for any possible (non-fatal) issues\");\n\n    qemuProcessStartWarnShmem(vm);\n\n    return 0;\n}\n\n\nstatic int\nqemuProcessStartUpdateCustomCaps(virDomainObjPtr vm)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    g_autoptr(virQEMUDriverConfig) cfg = virQEMUDriverGetConfig(priv->driver);\n    qemuDomainXmlNsDefPtr nsdef = vm->def->namespaceData;\n    char **next;\n    int tmp;\n    size_t i;\n\n    if (cfg->capabilityfilters) {\n        for (next = cfg->capabilityfilters; *next; next++) {\n            if ((tmp = virQEMUCapsTypeFromString(*next)) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"invalid capability_filters capability '%s'\"),\n                               *next);\n                return -1;\n            }\n\n            virQEMUCapsClear(priv->qemuCaps, tmp);\n        }\n    }\n\n    if (nsdef) {\n        for (i = 0; i < nsdef->ncapsadd; i++) {\n            if ((tmp = virQEMUCapsTypeFromString(nsdef->capsadd[i])) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"invalid qemu namespace capability '%s'\"),\n                               nsdef->capsadd[i]);\n                return -1;\n            }\n\n            virQEMUCapsSet(priv->qemuCaps, tmp);\n        }\n\n        for (i = 0; i < nsdef->ncapsdel; i++) {\n            if ((tmp = virQEMUCapsTypeFromString(nsdef->capsdel[i])) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"invalid qemu namespace capability '%s'\"),\n                               nsdef->capsdel[i]);\n                return -1;\n            }\n\n            virQEMUCapsClear(priv->qemuCaps, tmp);\n        }\n    }\n\n    return 0;\n}\n\n\n/**\n * qemuProcessPrepareQEMUCaps:\n * @vm: domain object\n * @qemuCapsCache: cache of QEMU capabilities\n * @processStartFlags: flags based on the VIR_QEMU_PROCESS_START_* enum\n *\n * Prepare the capabilities of a QEMU process for startup. This includes\n * copying the caps to a static cache and potential post-processing depending\n * on the configuration of the VM and startup process.\n *\n * Returns 0 on success, -1 on error.\n */\nstatic int\nqemuProcessPrepareQEMUCaps(virDomainObjPtr vm,\n                           virFileCachePtr qemuCapsCache,\n                           unsigned int processStartFlags)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n\n    virObjectUnref(priv->qemuCaps);\n    if (!(priv->qemuCaps = virQEMUCapsCacheLookupCopy(qemuCapsCache,\n                                                      vm->def->virtType,\n                                                      vm->def->emulator,\n                                                      vm->def->os.machine)))\n        return -1;\n\n    if (processStartFlags & VIR_QEMU_PROCESS_START_STANDALONE)\n        virQEMUCapsClear(priv->qemuCaps, QEMU_CAPS_CHARDEV_FD_PASS);\n\n    /* Update qemu capabilities according to lists passed in via namespace */\n    if (qemuProcessStartUpdateCustomCaps(vm) < 0)\n        return -1;\n\n    /* re-process capability lockouts since we might have removed capabilities */\n    virQEMUCapsInitProcessCapsInterlock(priv->qemuCaps);\n\n    return 0;\n}\n\n\n/**\n * qemuProcessInit:\n *\n * Prepares the domain up to the point when priv->qemuCaps is initialized. The\n * function calls qemuProcessStop when needed.\n *\n * Flag VIR_QEMU_PROCESS_START_PRETEND tells, that we don't want to actually\n * start the domain but create a valid qemu command.  If some code shouldn't be\n * executed in this case, make sure to check this flag.\n *\n * Returns 0 on success, -1 on error.\n */\nint\nqemuProcessInit(virQEMUDriverPtr driver,\n                virDomainObjPtr vm,\n                virCPUDefPtr updatedCPU,\n                qemuDomainAsyncJob asyncJob,\n                bool migration,\n                unsigned int flags)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    int stopFlags;\n    virCPUDefPtr origCPU = NULL;\n    int ret = -1;\n\n    VIR_DEBUG(\"vm=%p name=%s id=%d migration=%d\",\n              vm, vm->def->name, vm->def->id, migration);\n\n    VIR_DEBUG(\"Beginning VM startup process\");\n\n    if (virDomainObjIsActive(vm)) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"VM is already active\"));\n        goto cleanup;\n    }\n\n    /* in case when the post parse callback failed we need to re-run it on the\n     * old config prior we start the VM */\n    if (vm->def->postParseFailed) {\n        VIR_DEBUG(\"re-running the post parse callback\");\n\n        /* we don't have the private copy of qemuCaps at this point */\n        if (virDomainDefPostParse(vm->def, 0, driver->xmlopt, NULL) < 0)\n            goto cleanup;\n    }\n\n    VIR_DEBUG(\"Determining emulator version\");\n    if (qemuProcessPrepareQEMUCaps(vm, driver->qemuCapsCache, flags) < 0)\n        goto cleanup;\n\n    if (qemuDomainUpdateCPU(vm, updatedCPU, &origCPU) < 0)\n        goto cleanup;\n\n    if (qemuProcessStartValidate(driver, vm, priv->qemuCaps, flags) < 0)\n        goto cleanup;\n\n    /* Do this upfront, so any part of the startup process can add\n     * runtime state to vm->def that won't be persisted. This let's us\n     * report implicit runtime defaults in the XML, like vnc listen/socket\n     */\n    VIR_DEBUG(\"Setting current domain def as transient\");\n    if (virDomainObjSetDefTransient(driver->xmlopt, vm, priv->qemuCaps) < 0)\n        goto cleanup;\n\n    /* don't clean up files for <transient> disks until we set them up */\n    priv->inhibitDiskTransientDelete = true;\n\n    if (flags & VIR_QEMU_PROCESS_START_PRETEND) {\n        if (qemuDomainSetPrivatePaths(driver, vm) < 0) {\n            virDomainObjRemoveTransientDef(vm);\n            goto cleanup;\n        }\n    } else {\n        vm->def->id = qemuDriverAllocateID(driver);\n        qemuDomainSetFakeReboot(driver, vm, false);\n        virDomainObjSetState(vm, VIR_DOMAIN_PAUSED, VIR_DOMAIN_PAUSED_STARTING_UP);\n\n        if (g_atomic_int_add(&driver->nactive, 1) == 0 && driver->inhibitCallback)\n            driver->inhibitCallback(true, driver->inhibitOpaque);\n\n        /* Run an early hook to set-up missing devices */\n        if (qemuProcessStartHook(driver, vm,\n                                 VIR_HOOK_QEMU_OP_PREPARE,\n                                 VIR_HOOK_SUBOP_BEGIN) < 0)\n            goto stop;\n\n        if (qemuDomainSetPrivatePaths(driver, vm) < 0)\n            goto stop;\n\n        priv->origCPU = g_steal_pointer(&origCPU);\n    }\n\n    ret = 0;\n\n cleanup:\n    virCPUDefFree(origCPU);\n    return ret;\n\n stop:\n    stopFlags = VIR_QEMU_PROCESS_STOP_NO_RELABEL;\n    if (migration)\n        stopFlags |= VIR_QEMU_PROCESS_STOP_MIGRATED;\n    qemuProcessStop(driver, vm, VIR_DOMAIN_SHUTOFF_FAILED, asyncJob, stopFlags);\n    goto cleanup;\n}\n\n\n/**\n * qemuProcessNetworkPrepareDevices\n */\nstatic int\nqemuProcessNetworkPrepareDevices(virQEMUDriverPtr driver,\n                                 virDomainObjPtr vm)\n{\n    virDomainDefPtr def = vm->def;\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    size_t i;\n    g_autoptr(virConnect) conn = NULL;\n\n    for (i = 0; i < def->nnets; i++) {\n        virDomainNetDefPtr net = def->nets[i];\n        virDomainNetType actualType;\n\n        /* If appropriate, grab a physical device from the configured\n         * network's pool of devices, or resolve bridge device name\n         * to the one defined in the network definition.\n         */\n        if (net->type == VIR_DOMAIN_NET_TYPE_NETWORK) {\n            if (!conn && !(conn = virGetConnectNetwork()))\n                return -1;\n            if (virDomainNetAllocateActualDevice(conn, def, net) < 0)\n                return -1;\n        }\n\n        actualType = virDomainNetGetActualType(net);\n        if (actualType == VIR_DOMAIN_NET_TYPE_HOSTDEV &&\n            net->type == VIR_DOMAIN_NET_TYPE_NETWORK) {\n            /* Each type='hostdev' network device must also have a\n             * corresponding entry in the hostdevs array. For netdevs\n             * that are hardcoded as type='hostdev', this is already\n             * done by the parser, but for those allocated from a\n             * network / determined at runtime, we need to do it\n             * separately.\n             */\n            virDomainHostdevDefPtr hostdev = virDomainNetGetActualHostdev(net);\n            virDomainHostdevSubsysPCIPtr pcisrc = &hostdev->source.subsys.u.pci;\n\n            if (virDomainHostdevFind(def, hostdev, NULL) >= 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"PCI device %04x:%02x:%02x.%x \"\n                                 \"allocated from network %s is already \"\n                                 \"in use by domain %s\"),\n                               pcisrc->addr.domain, pcisrc->addr.bus,\n                               pcisrc->addr.slot, pcisrc->addr.function,\n                               net->data.network.name, def->name);\n                return -1;\n            }\n            if (virDomainHostdevInsert(def, hostdev) < 0)\n                return -1;\n        } else if (actualType == VIR_DOMAIN_NET_TYPE_USER &&\n                   !priv->disableSlirp &&\n                   virQEMUCapsGet(priv->qemuCaps, QEMU_CAPS_DBUS_VMSTATE)) {\n            qemuSlirpPtr slirp = NULL;\n            int rv = qemuInterfacePrepareSlirp(driver, net, &slirp);\n\n            if (rv == -1)\n                return -1;\n            if (rv == 1)\n                QEMU_DOMAIN_NETWORK_PRIVATE(net)->slirp = slirp;\n         }\n\n    }\n    return 0;\n}\n\n\n/**\n * qemuProcessSetupVcpu:\n * @vm: domain object\n * @vcpuid: id of VCPU to set defaults\n *\n * This function sets resource properties (cgroups, affinity, scheduler) for a\n * vCPU. This function expects that the vCPU is online and the vCPU pids were\n * correctly detected at the point when it's called.\n *\n * Returns 0 on success, -1 on error.\n */\nint\nqemuProcessSetupVcpu(virDomainObjPtr vm,\n                     unsigned int vcpuid)\n{\n    pid_t vcpupid = qemuDomainGetVcpuPid(vm, vcpuid);\n    virDomainVcpuDefPtr vcpu = virDomainDefGetVcpu(vm->def, vcpuid);\n    virDomainResctrlMonDefPtr mon = NULL;\n    size_t i = 0;\n\n    if (qemuProcessSetupPid(vm, vcpupid, VIR_CGROUP_THREAD_VCPU,\n                            vcpuid, vcpu->cpumask,\n                            vm->def->cputune.period,\n                            vm->def->cputune.quota,\n                            &vcpu->sched) < 0)\n        return -1;\n\n    for (i = 0; i < vm->def->nresctrls; i++) {\n        size_t j = 0;\n        virDomainResctrlDefPtr ct = vm->def->resctrls[i];\n\n        if (virBitmapIsBitSet(ct->vcpus, vcpuid)) {\n            if (virResctrlAllocAddPID(ct->alloc, vcpupid) < 0)\n                return -1;\n\n            for (j = 0; j < ct->nmonitors; j++) {\n                mon = ct->monitors[j];\n\n                if (virBitmapEqual(ct->vcpus, mon->vcpus) &&\n                    !virResctrlAllocIsEmpty(ct->alloc))\n                    continue;\n\n                if (virBitmapIsBitSet(mon->vcpus, vcpuid)) {\n                    if (virResctrlMonitorAddPID(mon->instance, vcpupid) < 0)\n                        return -1;\n                    break;\n                }\n            }\n\n            break;\n        }\n    }\n\n    return 0;\n}\n\n\nstatic int\nqemuProcessSetupVcpus(virDomainObjPtr vm)\n{\n    virDomainVcpuDefPtr vcpu;\n    unsigned int maxvcpus = virDomainDefGetVcpusMax(vm->def);\n    size_t i;\n\n    if ((vm->def->cputune.period || vm->def->cputune.quota) &&\n        !virCgroupHasController(((qemuDomainObjPrivatePtr) vm->privateData)->cgroup,\n                                VIR_CGROUP_CONTROLLER_CPU)) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"cgroup cpu is required for scheduler tuning\"));\n        return -1;\n    }\n\n    if (!qemuDomainHasVcpuPids(vm)) {\n        /* If any CPU has custom affinity that differs from the\n         * VM default affinity, we must reject it */\n        for (i = 0; i < maxvcpus; i++) {\n            vcpu = virDomainDefGetVcpu(vm->def, i);\n\n            if (!vcpu->online)\n                continue;\n\n            if (vcpu->cpumask &&\n                !virBitmapEqual(vm->def->cpumask, vcpu->cpumask)) {\n                virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                                _(\"cpu affinity is not supported\"));\n                return -1;\n            }\n        }\n\n        return 0;\n    }\n\n    for (i = 0; i < maxvcpus; i++) {\n        vcpu = virDomainDefGetVcpu(vm->def, i);\n\n        if (!vcpu->online)\n            continue;\n\n        if (qemuProcessSetupVcpu(vm, i) < 0)\n            return -1;\n    }\n\n    return 0;\n}\n\n\nint\nqemuProcessSetupIOThread(virDomainObjPtr vm,\n                         virDomainIOThreadIDDefPtr iothread)\n{\n    return qemuProcessSetupPid(vm, iothread->thread_id,\n                               VIR_CGROUP_THREAD_IOTHREAD,\n                               iothread->iothread_id,\n                               iothread->cpumask,\n                               vm->def->cputune.iothread_period,\n                               vm->def->cputune.iothread_quota,\n                               &iothread->sched);\n}\n\n\nstatic int\nqemuProcessSetupIOThreads(virDomainObjPtr vm)\n{\n    size_t i;\n\n    for (i = 0; i < vm->def->niothreadids; i++) {\n        virDomainIOThreadIDDefPtr info = vm->def->iothreadids[i];\n\n        if (qemuProcessSetupIOThread(vm, info) < 0)\n            return -1;\n    }\n\n    return 0;\n}\n\n\nstatic int\nqemuProcessValidateHotpluggableVcpus(virDomainDefPtr def)\n{\n    virDomainVcpuDefPtr vcpu;\n    virDomainVcpuDefPtr subvcpu;\n    qemuDomainVcpuPrivatePtr vcpupriv;\n    unsigned int maxvcpus = virDomainDefGetVcpusMax(def);\n    size_t i = 0;\n    size_t j;\n    virBitmapPtr ordermap = virBitmapNew(maxvcpus + 1);\n    int ret = -1;\n\n    /* validate:\n     * - all hotpluggable entities to be hotplugged have the correct data\n     * - vcpus belonging to a hotpluggable entity share configuration\n     * - order of the hotpluggable entities is unique\n     */\n    for (i = 0; i < maxvcpus; i++) {\n        vcpu = virDomainDefGetVcpu(def, i);\n        vcpupriv = QEMU_DOMAIN_VCPU_PRIVATE(vcpu);\n\n        /* skip over hotpluggable entities  */\n        if (vcpupriv->vcpus == 0)\n            continue;\n\n        if (vcpu->order != 0) {\n            if (virBitmapIsBitSet(ordermap, vcpu->order)) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                               _(\"duplicate vcpu order '%u'\"), vcpu->order);\n                goto cleanup;\n            }\n\n            if (virBitmapSetBit(ordermap, vcpu->order)) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                               _(\"vcpu order '%u' exceeds vcpu count\"),\n                               vcpu->order);\n                goto cleanup;\n            }\n        }\n\n        for (j = i + 1; j < (i + vcpupriv->vcpus); j++) {\n            subvcpu = virDomainDefGetVcpu(def, j);\n            if (subvcpu->hotpluggable != vcpu->hotpluggable ||\n                subvcpu->online != vcpu->online ||\n                subvcpu->order != vcpu->order) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                               _(\"vcpus '%zu' and '%zu' are in the same hotplug \"\n                                 \"group but differ in configuration\"), i, j);\n                goto cleanup;\n            }\n        }\n\n        if (vcpu->online && vcpu->hotpluggable == VIR_TRISTATE_BOOL_YES) {\n            if ((vcpupriv->socket_id == -1 && vcpupriv->core_id == -1 &&\n                 vcpupriv->thread_id == -1 && vcpupriv->node_id == -1) ||\n                !vcpupriv->type) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                               _(\"vcpu '%zu' is missing hotplug data\"), i);\n                goto cleanup;\n            }\n        }\n    }\n\n    ret = 0;\n cleanup:\n    virBitmapFree(ordermap);\n    return ret;\n}\n\n\nstatic int\nqemuDomainHasHotpluggableStartupVcpus(virDomainDefPtr def)\n{\n    size_t maxvcpus = virDomainDefGetVcpusMax(def);\n    virDomainVcpuDefPtr vcpu;\n    size_t i;\n\n    for (i = 0; i < maxvcpus; i++) {\n        vcpu = virDomainDefGetVcpu(def, i);\n\n        if (vcpu->online && vcpu->hotpluggable == VIR_TRISTATE_BOOL_YES)\n            return true;\n    }\n\n    return false;\n}\n\n\nstatic int\nqemuProcessVcpusSortOrder(const void *a,\n                          const void *b)\n{\n    virDomainVcpuDefPtr vcpua = *((virDomainVcpuDefPtr *)a);\n    virDomainVcpuDefPtr vcpub = *((virDomainVcpuDefPtr *)b);\n\n    return vcpua->order - vcpub->order;\n}\n\n\nstatic int\nqemuProcessSetupHotpluggableVcpus(virQEMUDriverPtr driver,\n                                  virDomainObjPtr vm,\n                                  qemuDomainAsyncJob asyncJob)\n{\n    unsigned int maxvcpus = virDomainDefGetVcpusMax(vm->def);\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    qemuCgroupEmulatorAllNodesDataPtr emulatorCgroup = NULL;\n    virDomainVcpuDefPtr vcpu;\n    qemuDomainVcpuPrivatePtr vcpupriv;\n    virJSONValuePtr vcpuprops = NULL;\n    size_t i;\n    int ret = -1;\n    int rc;\n\n    virDomainVcpuDefPtr *bootHotplug = NULL;\n    size_t nbootHotplug = 0;\n\n    for (i = 0; i < maxvcpus; i++) {\n        vcpu = virDomainDefGetVcpu(vm->def, i);\n        vcpupriv = QEMU_DOMAIN_VCPU_PRIVATE(vcpu);\n\n        if (vcpu->hotpluggable == VIR_TRISTATE_BOOL_YES && vcpu->online &&\n            vcpupriv->vcpus != 0) {\n            vcpupriv->alias = g_strdup_printf(\"vcpu%zu\", i);\n\n            if (VIR_APPEND_ELEMENT(bootHotplug, nbootHotplug, vcpu) < 0)\n                goto cleanup;\n        }\n    }\n\n    if (nbootHotplug == 0) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    qsort(bootHotplug, nbootHotplug, sizeof(*bootHotplug),\n          qemuProcessVcpusSortOrder);\n\n    if (qemuCgroupEmulatorAllNodesAllow(priv->cgroup, &emulatorCgroup) < 0)\n        goto cleanup;\n\n    for (i = 0; i < nbootHotplug; i++) {\n        vcpu = bootHotplug[i];\n\n        if (!(vcpuprops = qemuBuildHotpluggableCPUProps(vcpu)))\n            goto cleanup;\n\n        if (qemuDomainObjEnterMonitorAsync(driver, vm, asyncJob) < 0)\n            goto cleanup;\n\n        rc = qemuMonitorAddDeviceArgs(qemuDomainGetMonitor(vm), vcpuprops);\n        vcpuprops = NULL;\n\n        if (qemuDomainObjExitMonitor(driver, vm) < 0)\n            goto cleanup;\n\n        if (rc < 0)\n            goto cleanup;\n\n        virJSONValueFree(vcpuprops);\n    }\n\n    ret = 0;\n\n cleanup:\n    qemuCgroupEmulatorAllNodesRestore(emulatorCgroup);\n    VIR_FREE(bootHotplug);\n    virJSONValueFree(vcpuprops);\n    return ret;\n}\n\n\nstatic bool\nqemuProcessDropUnknownCPUFeatures(const char *name,\n                                  virCPUFeaturePolicy policy,\n                                  void *opaque)\n{\n    const char **features = opaque;\n\n    if (policy != VIR_CPU_FEATURE_DISABLE &&\n        policy != VIR_CPU_FEATURE_FORBID)\n        return true;\n\n    if (g_strv_contains(features, name))\n        return true;\n\n    /* Features unknown to QEMU are implicitly disabled, we can just drop them\n     * from the definition. */\n    return false;\n}\n\n\nstatic int\nqemuProcessUpdateGuestCPU(virDomainDefPtr def,\n                          virQEMUCapsPtr qemuCaps,\n                          virArch hostarch,\n                          unsigned int flags)\n{\n    if (!def->cpu)\n        return 0;\n\n    /* nothing to do if only topology part of CPU def is used */\n    if (def->cpu->mode == VIR_CPU_MODE_CUSTOM && !def->cpu->model)\n        return 0;\n\n    /* Old libvirt added host CPU model to host-model CPUs for migrations,\n     * while new libvirt just turns host-model into custom mode. We need\n     * to fix the mode to maintain backward compatibility and to avoid\n     * the CPU model to be replaced in virCPUUpdate.\n     */\n    if (!(flags & VIR_QEMU_PROCESS_START_NEW) &&\n        ARCH_IS_X86(def->os.arch) &&\n        def->cpu->mode == VIR_CPU_MODE_HOST_MODEL &&\n        def->cpu->model) {\n        def->cpu->mode = VIR_CPU_MODE_CUSTOM;\n    }\n\n    if (!virQEMUCapsIsCPUModeSupported(qemuCaps, hostarch, def->virtType,\n                                       def->cpu->mode, def->os.machine)) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"CPU mode '%s' for %s %s domain on %s host is not \"\n                         \"supported by hypervisor\"),\n                       virCPUModeTypeToString(def->cpu->mode),\n                       virArchToString(def->os.arch),\n                       virDomainVirtTypeToString(def->virtType),\n                       virArchToString(hostarch));\n        return -1;\n    }\n\n    if (virCPUConvertLegacy(hostarch, def->cpu) < 0)\n        return -1;\n\n    /* nothing to update for host-passthrough / maximum */\n    if (def->cpu->mode != VIR_CPU_MODE_HOST_PASSTHROUGH &&\n        def->cpu->mode != VIR_CPU_MODE_MAXIMUM) {\n        g_autoptr(virDomainCapsCPUModels) cpuModels = NULL;\n\n        if (def->cpu->check == VIR_CPU_CHECK_PARTIAL &&\n            virCPUCompare(hostarch,\n                          virQEMUCapsGetHostModel(qemuCaps, def->virtType,\n                                                  VIR_QEMU_CAPS_HOST_CPU_FULL),\n                          def->cpu, true) < 0)\n            return -1;\n\n        if (virCPUUpdate(def->os.arch, def->cpu,\n                         virQEMUCapsGetHostModel(qemuCaps, def->virtType,\n                                                 VIR_QEMU_CAPS_HOST_CPU_MIGRATABLE)) < 0)\n            return -1;\n\n        cpuModels = virQEMUCapsGetCPUModels(qemuCaps, def->virtType, NULL, NULL);\n\n        if (virCPUTranslate(def->os.arch, def->cpu, cpuModels) < 0)\n            return -1;\n\n        def->cpu->fallback = VIR_CPU_FALLBACK_FORBID;\n    }\n\n    if (virCPUDefFilterFeatures(def->cpu, virQEMUCapsCPUFilterFeatures,\n                                &def->os.arch) < 0)\n        return -1;\n\n    if (ARCH_IS_X86(def->os.arch)) {\n        g_auto(GStrv) features = NULL;\n\n        if (virQEMUCapsGetCPUFeatures(qemuCaps, def->virtType, false, &features) < 0)\n            return -1;\n\n        if (features &&\n            virCPUDefFilterFeatures(def->cpu, qemuProcessDropUnknownCPUFeatures,\n                                    features) < 0)\n            return -1;\n    }\n\n    return 0;\n}\n\n\nstatic int\nqemuProcessPrepareDomainNUMAPlacement(virDomainObjPtr vm)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    g_autofree char *nodeset = NULL;\n    g_autoptr(virBitmap) numadNodeset = NULL;\n    g_autoptr(virBitmap) hostMemoryNodeset = NULL;\n    g_autoptr(virCapsHostNUMA) caps = NULL;\n\n    /* Get the advisory nodeset from numad if 'placement' of\n     * either <vcpu> or <numatune> is 'auto'.\n     */\n    if (!virDomainDefNeedsPlacementAdvice(vm->def))\n        return 0;\n\n    nodeset = virNumaGetAutoPlacementAdvice(virDomainDefGetVcpus(vm->def),\n                                            virDomainDefGetMemoryTotal(vm->def));\n\n    if (!nodeset)\n        return -1;\n\n    if (!(hostMemoryNodeset = virNumaGetHostMemoryNodeset()))\n        return -1;\n\n    VIR_DEBUG(\"Nodeset returned from numad: %s\", nodeset);\n\n    if (virBitmapParse(nodeset, &numadNodeset, VIR_DOMAIN_CPUMASK_LEN) < 0)\n        return -1;\n\n    if (!(caps = virCapabilitiesHostNUMANewHost()))\n        return -1;\n\n    /* numad may return a nodeset that only contains cpus but cgroups don't play\n     * well with that. Set the autoCpuset from all cpus from that nodeset, but\n     * assign autoNodeset only with nodes containing memory. */\n    if (!(priv->autoCpuset = virCapabilitiesHostNUMAGetCpus(caps, numadNodeset)))\n        return -1;\n\n    virBitmapIntersect(numadNodeset, hostMemoryNodeset);\n\n    priv->autoNodeset = g_steal_pointer(&numadNodeset);\n\n    return 0;\n}\n\n\nstatic int\nqemuProcessPrepareDomainStorage(virQEMUDriverPtr driver,\n                                virDomainObjPtr vm,\n                                qemuDomainObjPrivatePtr priv,\n                                virQEMUDriverConfigPtr cfg,\n                                unsigned int flags)\n{\n    size_t i;\n    bool cold_boot = flags & VIR_QEMU_PROCESS_START_COLD;\n\n    for (i = vm->def->ndisks; i > 0; i--) {\n        size_t idx = i - 1;\n        virDomainDiskDefPtr disk = vm->def->disks[idx];\n\n        if (virDomainDiskTranslateSourcePool(disk) < 0) {\n            if (qemuDomainCheckDiskStartupPolicy(driver, vm, idx, cold_boot) < 0)\n                return -1;\n\n            /* disk source was dropped */\n            continue;\n        }\n\n        if (qemuDomainPrepareDiskSource(disk, priv, cfg) < 0)\n            return -1;\n    }\n\n    return 0;\n}\n\n\nstatic int\nqemuProcessPrepareDomainHostdevs(virDomainObjPtr vm,\n                                 qemuDomainObjPrivatePtr priv)\n{\n    size_t i;\n\n    for (i = 0; i < vm->def->nhostdevs; i++) {\n        virDomainHostdevDefPtr hostdev = vm->def->hostdevs[i];\n\n        if (qemuDomainPrepareHostdev(hostdev, priv) < 0)\n            return -1;\n    }\n\n    return 0;\n}\n\n\nint\nqemuProcessPrepareHostHostdev(virDomainHostdevDefPtr hostdev)\n{\n    if (virHostdevIsSCSIDevice(hostdev)) {\n        virDomainHostdevSubsysSCSIPtr scsisrc = &hostdev->source.subsys.u.scsi;\n\n        switch ((virDomainHostdevSCSIProtocolType) scsisrc->protocol) {\n        case VIR_DOMAIN_HOSTDEV_SCSI_PROTOCOL_TYPE_NONE: {\n            virDomainHostdevSubsysSCSIHostPtr scsihostsrc = &scsisrc->u.host;\n            virStorageSourcePtr src = scsisrc->u.host.src;\n            g_autofree char *devstr = NULL;\n\n            if (!(devstr = virSCSIDeviceGetSgName(NULL,\n                                                  scsihostsrc->adapter,\n                                                  scsihostsrc->bus,\n                                                  scsihostsrc->target,\n                                                  scsihostsrc->unit)))\n                return -1;\n\n            src->path = g_strdup_printf(\"/dev/%s\", devstr);\n            break;\n        }\n\n        case VIR_DOMAIN_HOSTDEV_SCSI_PROTOCOL_TYPE_ISCSI:\n            break;\n\n        case VIR_DOMAIN_HOSTDEV_SCSI_PROTOCOL_TYPE_LAST:\n        default:\n            virReportEnumRangeError(virDomainHostdevSCSIProtocolType, scsisrc->protocol);\n            return -1;\n        }\n    }\n\n    return 0;\n}\n\n\nstatic int\nqemuProcessPrepareHostHostdevs(virDomainObjPtr vm)\n{\n    size_t i;\n\n    for (i = 0; i < vm->def->nhostdevs; i++) {\n        virDomainHostdevDefPtr hostdev = vm->def->hostdevs[i];\n\n        if (qemuProcessPrepareHostHostdev(hostdev) < 0)\n            return -1;\n    }\n\n    return 0;\n}\n\n\nstatic void\nqemuProcessPrepareAllowReboot(virDomainObjPtr vm)\n{\n    virDomainDefPtr def = vm->def;\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n\n    if (priv->allowReboot != VIR_TRISTATE_BOOL_ABSENT)\n        return;\n\n    if (def->onReboot == VIR_DOMAIN_LIFECYCLE_ACTION_DESTROY &&\n        def->onPoweroff == VIR_DOMAIN_LIFECYCLE_ACTION_DESTROY &&\n        (def->onCrash == VIR_DOMAIN_LIFECYCLE_ACTION_DESTROY ||\n         def->onCrash == VIR_DOMAIN_LIFECYCLE_ACTION_COREDUMP_DESTROY)) {\n        priv->allowReboot = VIR_TRISTATE_BOOL_NO;\n    } else {\n        priv->allowReboot = VIR_TRISTATE_BOOL_YES;\n    }\n}\n\n\nstatic int\nqemuProcessUpdateSEVInfo(virDomainObjPtr vm)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    virQEMUCapsPtr qemuCaps = priv->qemuCaps;\n    virDomainSEVDefPtr sev = vm->def->sev;\n    virSEVCapabilityPtr sevCaps = NULL;\n\n    /* if platform specific info like 'cbitpos' and 'reducedPhysBits' have\n     * not been supplied, we need to autofill them from caps now as both are\n     * mandatory on QEMU cmdline\n     */\n    sevCaps = virQEMUCapsGetSEVCapabilities(qemuCaps);\n    if (!sev->haveCbitpos) {\n        sev->cbitpos = sevCaps->cbitpos;\n        sev->haveCbitpos = true;\n    }\n\n    if (!sev->haveReducedPhysBits) {\n        sev->reduced_phys_bits = sevCaps->reduced_phys_bits;\n        sev->haveReducedPhysBits = true;\n    }\n\n    return 0;\n}\n\n\n/**\n * qemuProcessPrepareDomain:\n * @driver: qemu driver\n * @vm: domain object\n * @flags: qemuProcessStartFlags\n *\n * This function groups all code that modifies only live XML of a domain which\n * is about to start and it's the only place to do those modifications.\n *\n * Flag VIR_QEMU_PROCESS_START_PRETEND tells, that we don't want to actually\n * start the domain but create a valid qemu command.  If some code shouldn't be\n * executed in this case, make sure to check this flag.\n *\n * TODO: move all XML modification from qemuBuildCommandLine into this function\n */\nint\nqemuProcessPrepareDomain(virQEMUDriverPtr driver,\n                         virDomainObjPtr vm,\n                         unsigned int flags)\n{\n    size_t i;\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    g_autoptr(virQEMUDriverConfig) cfg = virQEMUDriverGetConfig(driver);\n\n    priv->machineName = qemuDomainGetMachineName(vm);\n    if (!priv->machineName)\n        return -1;\n\n    if (!(flags & VIR_QEMU_PROCESS_START_PRETEND)) {\n        /* If you are using a SecurityDriver with dynamic labelling,\n           then generate a security label for isolation */\n        VIR_DEBUG(\"Generating domain security label (if required)\");\n        if (qemuSecurityGenLabel(driver->securityManager, vm->def) < 0) {\n            virDomainAuditSecurityLabel(vm, false);\n            return -1;\n        }\n        virDomainAuditSecurityLabel(vm, true);\n\n        if (qemuProcessPrepareDomainNUMAPlacement(vm) < 0)\n            return -1;\n    }\n\n    /* Whether we should use virtlogd as stdio handler for character\n     * devices source backend. */\n    if (cfg->stdioLogD &&\n        virQEMUCapsGet(priv->qemuCaps, QEMU_CAPS_CHARDEV_FILE_APPEND)) {\n        priv->chardevStdioLogd = true;\n    }\n\n    /* Track if this domain remembers original owner */\n    priv->rememberOwner = cfg->rememberOwner;\n\n    qemuProcessPrepareAllowReboot(vm);\n\n    /*\n     * Normally PCI addresses are assigned in the virDomainCreate\n     * or virDomainDefine methods. We might still need to assign\n     * some here to cope with the question of upgrades. Regardless\n     * we also need to populate the PCI address set cache for later\n     * use in hotplug\n     */\n    VIR_DEBUG(\"Assigning domain PCI addresses\");\n    if ((qemuDomainAssignAddresses(vm->def, priv->qemuCaps, driver, vm,\n                                   !!(flags & VIR_QEMU_PROCESS_START_NEW))) < 0) {\n        return -1;\n    }\n\n    if (qemuAssignDeviceAliases(vm->def, priv->qemuCaps) < 0)\n        return -1;\n\n    VIR_DEBUG(\"Setting graphics devices\");\n    if (qemuProcessSetupGraphics(driver, vm, priv->qemuCaps, flags) < 0)\n        return -1;\n\n    VIR_DEBUG(\"Create domain masterKey\");\n    if (qemuDomainMasterKeyCreate(vm) < 0)\n        return -1;\n\n    VIR_DEBUG(\"Setting up storage\");\n    if (qemuProcessPrepareDomainStorage(driver, vm, priv, cfg, flags) < 0)\n        return -1;\n\n    VIR_DEBUG(\"Setting up host devices\");\n    if (qemuProcessPrepareDomainHostdevs(vm, priv) < 0)\n        return -1;\n\n    VIR_DEBUG(\"Prepare chardev source backends for TLS\");\n    qemuDomainPrepareChardevSource(vm->def, cfg);\n\n    VIR_DEBUG(\"Prepare device secrets\");\n    if (qemuDomainSecretPrepare(driver, vm) < 0)\n        return -1;\n\n    VIR_DEBUG(\"Prepare bios/uefi paths\");\n    if (qemuFirmwareFillDomain(driver, vm->def, flags) < 0)\n        return -1;\n    if (qemuDomainInitializePflashStorageSource(vm) < 0)\n        return -1;\n\n    VIR_DEBUG(\"Preparing external devices\");\n    if (qemuExtDevicesPrepareDomain(driver, vm) < 0)\n        return -1;\n\n    if (flags & VIR_QEMU_PROCESS_START_NEW) {\n        VIR_DEBUG(\"Aligning guest memory\");\n        if (qemuDomainAlignMemorySizes(vm->def) < 0)\n            return -1;\n    }\n\n    for (i = 0; i < vm->def->nchannels; i++) {\n        if (qemuDomainPrepareChannel(vm->def->channels[i],\n                                     priv->channelTargetDir) < 0)\n            return -1;\n    }\n\n    if (!(priv->monConfig = virDomainChrSourceDefNew(driver->xmlopt)))\n        return -1;\n\n    VIR_DEBUG(\"Preparing monitor state\");\n    if (qemuProcessPrepareMonitorChr(priv->monConfig, priv->libDir) < 0)\n        return -1;\n\n    priv->monError = false;\n    priv->monStart = 0;\n    priv->runningReason = VIR_DOMAIN_RUNNING_UNKNOWN;\n    priv->pausedReason = VIR_DOMAIN_PAUSED_UNKNOWN;\n\n    VIR_DEBUG(\"Updating guest CPU definition\");\n    if (qemuProcessUpdateGuestCPU(vm->def, priv->qemuCaps, driver->hostarch, flags) < 0)\n        return -1;\n\n    for (i = 0; i < vm->def->nshmems; i++)\n        qemuDomainPrepareShmemChardev(vm->def->shmems[i]);\n\n    if (vm->def->sev) {\n        VIR_DEBUG(\"Updating SEV platform info\");\n        if (qemuProcessUpdateSEVInfo(vm) < 0)\n            return -1;\n    }\n\n    return 0;\n}\n\n\nstatic int\nqemuProcessSEVCreateFile(virDomainObjPtr vm,\n                         const char *name,\n                         const char *data)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    virQEMUDriverPtr driver = priv->driver;\n    g_autofree char *configFile = NULL;\n\n    if (!(configFile = virFileBuildPath(priv->libDir, name, \".base64\")))\n        return -1;\n\n    if (virFileRewriteStr(configFile, S_IRUSR | S_IWUSR, data) < 0) {\n        virReportSystemError(errno, _(\"failed to write data to config '%s'\"),\n                             configFile);\n        return -1;\n    }\n\n    if (qemuSecurityDomainSetPathLabel(driver, vm, configFile, true) < 0)\n        return -1;\n\n    return 0;\n}\n\n\nstatic int\nqemuProcessPrepareSEVGuestInput(virDomainObjPtr vm)\n{\n    virDomainSEVDefPtr sev = vm->def->sev;\n\n    if (!sev)\n        return 0;\n\n    VIR_DEBUG(\"Preparing SEV guest\");\n\n    if (sev->dh_cert) {\n        if (qemuProcessSEVCreateFile(vm, \"dh_cert\", sev->dh_cert) < 0)\n            return -1;\n    }\n\n    if (sev->session) {\n        if (qemuProcessSEVCreateFile(vm, \"session\", sev->session) < 0)\n            return -1;\n    }\n\n    return 0;\n}\n\n\nstatic int\nqemuProcessPrepareHostStorage(virQEMUDriverPtr driver,\n                              virDomainObjPtr vm,\n                              unsigned int flags)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    size_t i;\n    bool cold_boot = flags & VIR_QEMU_PROCESS_START_COLD;\n    bool blockdev = virQEMUCapsGet(priv->qemuCaps, QEMU_CAPS_BLOCKDEV);\n\n    for (i = vm->def->ndisks; i > 0; i--) {\n        size_t idx = i - 1;\n        virDomainDiskDefPtr disk = vm->def->disks[idx];\n\n        if (virStorageSourceIsEmpty(disk->src))\n            continue;\n\n        /* backing chain needs to be redetected if we aren't using blockdev */\n        if (!blockdev || qemuDiskBusIsSD(disk->bus))\n            virStorageSourceBackingStoreClear(disk->src);\n\n        /*\n         * Go to applying startup policy for optional disk with nonexistent\n         * source file immediately as determining chain will surely fail\n         * and we don't want noisy error notice in logs for this case.\n         */\n        if (qemuDomainDiskIsMissingLocalOptional(disk) && cold_boot)\n            VIR_INFO(\"optional disk '%s' source file is missing, \"\n                     \"skip checking disk chain\", disk->dst);\n        else if (qemuDomainDetermineDiskChain(driver, vm, disk, NULL, true) >= 0)\n            continue;\n\n        if (qemuDomainCheckDiskStartupPolicy(driver, vm, idx, cold_boot) >= 0)\n            continue;\n\n        return -1;\n    }\n\n    return 0;\n}\n\n\nint\nqemuProcessOpenVhostVsock(virDomainVsockDefPtr vsock)\n{\n    qemuDomainVsockPrivatePtr priv = (qemuDomainVsockPrivatePtr)vsock->privateData;\n    const char *vsock_path = \"/dev/vhost-vsock\";\n    int fd;\n\n    if ((fd = open(vsock_path, O_RDWR)) < 0) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       \"%s\", _(\"unable to open vhost-vsock device\"));\n        return -1;\n    }\n\n    if (vsock->auto_cid == VIR_TRISTATE_BOOL_YES) {\n        if (virVsockAcquireGuestCid(fd, &vsock->guest_cid) < 0)\n            goto error;\n    } else {\n        if (virVsockSetGuestCid(fd, vsock->guest_cid) < 0)\n            goto error;\n    }\n\n    priv->vhostfd = fd;\n    return 0;\n\n error:\n    VIR_FORCE_CLOSE(fd);\n    return -1;\n}\n\n\n/**\n * qemuProcessPrepareHost:\n * @driver: qemu driver\n * @vm: domain object\n * @flags: qemuProcessStartFlags\n *\n * This function groups all code that modifies host system (which also may\n * update live XML) to prepare environment for a domain which is about to start\n * and it's the only place to do those modifications.\n *\n * TODO: move all host modification from qemuBuildCommandLine into this function\n */\nint\nqemuProcessPrepareHost(virQEMUDriverPtr driver,\n                       virDomainObjPtr vm,\n                       unsigned int flags)\n{\n    unsigned int hostdev_flags = 0;\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    g_autoptr(virQEMUDriverConfig) cfg = virQEMUDriverGetConfig(driver);\n\n    if (qemuPrepareNVRAM(cfg, vm) < 0)\n        return -1;\n\n    if (vm->def->vsock) {\n        if (qemuProcessOpenVhostVsock(vm->def->vsock) < 0)\n            return -1;\n    }\n    /* network devices must be \"prepared\" before hostdevs, because\n     * setting up a network device might create a new hostdev that\n     * will need to be setup.\n     */\n    VIR_DEBUG(\"Preparing network devices\");\n    if (qemuProcessNetworkPrepareDevices(driver, vm) < 0)\n        return -1;\n\n    /* Must be run before security labelling */\n    VIR_DEBUG(\"Preparing host devices\");\n    if (!cfg->relaxedACS)\n        hostdev_flags |= VIR_HOSTDEV_STRICT_ACS_CHECK;\n    if (flags & VIR_QEMU_PROCESS_START_NEW)\n        hostdev_flags |= VIR_HOSTDEV_COLD_BOOT;\n    if (qemuHostdevPrepareDomainDevices(driver, vm->def, priv->qemuCaps,\n                                        hostdev_flags) < 0)\n        return -1;\n\n    VIR_DEBUG(\"Preparing chr devices\");\n    if (virDomainChrDefForeach(vm->def,\n                               true,\n                               qemuProcessPrepareChardevDevice,\n                               NULL) < 0)\n        return -1;\n\n    if (qemuProcessBuildDestroyMemoryPaths(driver, vm, NULL, true) < 0)\n        return -1;\n\n    /* Ensure no historical cgroup for this VM is lying around bogus\n     * settings */\n    VIR_DEBUG(\"Ensuring no historical cgroup is lying around\");\n    qemuRemoveCgroup(vm);\n\n    if (virFileMakePath(cfg->logDir) < 0) {\n        virReportSystemError(errno,\n                             _(\"cannot create log directory %s\"),\n                             cfg->logDir);\n        return -1;\n    }\n\n    VIR_FREE(priv->pidfile);\n    if (!(priv->pidfile = virPidFileBuildPath(cfg->stateDir, vm->def->name))) {\n        virReportSystemError(errno,\n                             \"%s\", _(\"Failed to build pidfile path.\"));\n        return -1;\n    }\n\n    if (unlink(priv->pidfile) < 0 &&\n        errno != ENOENT) {\n        virReportSystemError(errno,\n                             _(\"Cannot remove stale PID file %s\"),\n                             priv->pidfile);\n        return -1;\n    }\n\n    /*\n     * Create all per-domain directories in order to make sure domain\n     * with any possible seclabels can access it.\n     */\n    if (qemuProcessMakeDir(driver, vm, priv->libDir) < 0 ||\n        qemuProcessMakeDir(driver, vm, priv->channelTargetDir) < 0)\n        return -1;\n\n    VIR_DEBUG(\"Write domain masterKey\");\n    if (qemuDomainWriteMasterKeyFile(driver, vm) < 0)\n        return -1;\n\n    VIR_DEBUG(\"Preparing disks (host)\");\n    if (qemuProcessPrepareHostStorage(driver, vm, flags) < 0)\n        return -1;\n\n    VIR_DEBUG(\"Preparing hostdevs (host-side)\");\n    if (qemuProcessPrepareHostHostdevs(vm) < 0)\n        return -1;\n\n    VIR_DEBUG(\"Preparing external devices\");\n    if (qemuExtDevicesPrepareHost(driver, vm) < 0)\n        return -1;\n\n    if (qemuProcessPrepareSEVGuestInput(vm) < 0)\n        return -1;\n\n    return 0;\n}\n\n\n/**\n * qemuProcessGenID:\n * @vm: Pointer to domain object\n * @flags: qemuProcessStartFlags\n *\n * If this domain is requesting to use genid, then update the GUID\n * value if the VIR_QEMU_PROCESS_START_GEN_VMID flag is set. This\n * flag is set on specific paths during domain start processing when\n * there is the possibility that the VM is potentially re-executing\n * something that has already been executed before.\n */\nstatic int\nqemuProcessGenID(virDomainObjPtr vm,\n                 unsigned int flags)\n{\n    if (!vm->def->genidRequested)\n        return 0;\n\n    /* If we are coming from a path where we must provide a new gen id\n     * value regardless of whether it was previously generated or provided,\n     * then generate a new GUID value before we build the command line. */\n    if (flags & VIR_QEMU_PROCESS_START_GEN_VMID) {\n        if (virUUIDGenerate(vm->def->genid) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"failed to regenerate genid\"));\n            return -1;\n        }\n    }\n\n    return 0;\n}\n\n\n/**\n * qemuProcessSetupDiskThrottlingBlockdev:\n *\n * Sets up disk trottling for -blockdev via block_set_io_throttle monitor\n * command. This hack should be replaced by proper use of the 'throttle'\n * blockdev driver in qemu once it will support changing of the throttle group.\n * Same hack is done in qemuDomainAttachDiskGeneric.\n */\nstatic int\nqemuProcessSetupDiskThrottlingBlockdev(virQEMUDriverPtr driver,\n                                       virDomainObjPtr vm,\n                                       qemuDomainAsyncJob asyncJob)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    size_t i;\n    int ret = -1;\n\n    if (!virQEMUCapsGet(priv->qemuCaps, QEMU_CAPS_BLOCKDEV))\n        return 0;\n\n    VIR_DEBUG(\"Setting up disk throttling for -blockdev via block_set_io_throttle\");\n\n    if (qemuDomainObjEnterMonitorAsync(driver, vm, asyncJob) < 0)\n        return -1;\n\n    for (i = 0; i < vm->def->ndisks; i++) {\n        virDomainDiskDefPtr disk = vm->def->disks[i];\n        qemuDomainDiskPrivatePtr diskPriv = QEMU_DOMAIN_DISK_PRIVATE(disk);\n\n        /* sd-cards are instantiated via -drive */\n        if (qemuDiskBusIsSD(disk->bus))\n            continue;\n\n        /* Setting throttling for empty drives fails */\n        if (virStorageSourceIsEmpty(disk->src))\n            continue;\n\n        if (!qemuDiskConfigBlkdeviotuneEnabled(disk))\n            continue;\n\n        if (qemuMonitorSetBlockIoThrottle(qemuDomainGetMonitor(vm), NULL,\n                                          diskPriv->qomName, &disk->blkdeviotune,\n                                          true, true, true) < 0)\n            goto cleanup;\n    }\n\n    ret = 0;\n\n cleanup:\n    if (qemuDomainObjExitMonitor(driver, vm) < 0)\n        ret = -1;\n    return ret;\n}\n\n\nstatic int\nqemuProcessEnableDomainNamespaces(virQEMUDriverPtr driver,\n                                  virDomainObjPtr vm)\n{\n    g_autoptr(virQEMUDriverConfig) cfg = virQEMUDriverGetConfig(driver);\n\n    if (virBitmapIsBitSet(cfg->namespaces, QEMU_DOMAIN_NS_MOUNT) &&\n        qemuDomainEnableNamespace(vm, QEMU_DOMAIN_NS_MOUNT) < 0)\n        return -1;\n\n    return 0;\n}\n\n\nstatic int\nqemuProcessEnablePerf(virDomainObjPtr vm)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    size_t i;\n\n    if (!(priv->perf = virPerfNew()))\n        return -1;\n\n    for (i = 0; i < VIR_PERF_EVENT_LAST; i++) {\n        if (vm->def->perf.events[i] == VIR_TRISTATE_BOOL_YES &&\n            virPerfEventEnable(priv->perf, i, vm->pid) < 0)\n            return -1;\n    }\n\n    return 0;\n}\n\n\n/**\n * qemuProcessLaunch:\n *\n * Launch a new QEMU process with stopped virtual CPUs.\n *\n * The caller is supposed to call qemuProcessStop with appropriate\n * flags in case of failure.\n *\n * Returns 0 on success,\n *        -1 on error which happened before devices were labeled and thus\n *           there is no need to restore them,\n *        -2 on error requesting security labels to be restored.\n */\nint\nqemuProcessLaunch(virConnectPtr conn,\n                  virQEMUDriverPtr driver,\n                  virDomainObjPtr vm,\n                  qemuDomainAsyncJob asyncJob,\n                  qemuProcessIncomingDefPtr incoming,\n                  virDomainMomentObjPtr snapshot,\n                  virNetDevVPortProfileOp vmop,\n                  unsigned int flags)\n{\n    int ret = -1;\n    int rv;\n    int logfile = -1;\n    g_autoptr(qemuDomainLogContext) logCtxt = NULL;\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    g_autoptr(virCommand) cmd = NULL;\n    struct qemuProcessHookData hookData;\n    g_autoptr(virQEMUDriverConfig) cfg = NULL;\n    size_t nnicindexes = 0;\n    g_autofree int *nicindexes = NULL;\n\n    VIR_DEBUG(\"conn=%p driver=%p vm=%p name=%s if=%d asyncJob=%d \"\n              \"incoming.launchURI=%s incoming.deferredURI=%s \"\n              \"incoming.fd=%d incoming.path=%s \"\n              \"snapshot=%p vmop=%d flags=0x%x\",\n              conn, driver, vm, vm->def->name, vm->def->id, asyncJob,\n              NULLSTR(incoming ? incoming->launchURI : NULL),\n              NULLSTR(incoming ? incoming->deferredURI : NULL),\n              incoming ? incoming->fd : -1,\n              NULLSTR(incoming ? incoming->path : NULL),\n              snapshot, vmop, flags);\n\n    /* Okay, these are just internal flags,\n     * but doesn't hurt to check */\n    virCheckFlags(VIR_QEMU_PROCESS_START_COLD |\n                  VIR_QEMU_PROCESS_START_PAUSED |\n                  VIR_QEMU_PROCESS_START_AUTODESTROY |\n                  VIR_QEMU_PROCESS_START_NEW |\n                  VIR_QEMU_PROCESS_START_GEN_VMID, -1);\n\n    cfg = virQEMUDriverGetConfig(driver);\n\n    if (flags & VIR_QEMU_PROCESS_START_AUTODESTROY) {\n        if (!conn) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Domain autodestroy requires a connection handle\"));\n            return -1;\n        }\n        if (driver->embeddedRoot) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Domain autodestroy not supported for embedded drivers yet\"));\n            return -1;\n        }\n    }\n\n    hookData.vm = vm;\n    hookData.driver = driver;\n    /* We don't increase cfg's reference counter here. */\n    hookData.cfg = cfg;\n\n    VIR_DEBUG(\"Creating domain log file\");\n    if (!(logCtxt = qemuDomainLogContextNew(driver, vm,\n                                            QEMU_DOMAIN_LOG_CONTEXT_MODE_START))) {\n        virLastErrorPrefixMessage(\"%s\", _(\"can't connect to virtlogd\"));\n        goto cleanup;\n    }\n    logfile = qemuDomainLogContextGetWriteFD(logCtxt);\n\n    if (qemuProcessGenID(vm, flags) < 0)\n        goto cleanup;\n\n    if (qemuExtDevicesStart(driver, vm,\n                            qemuDomainLogContextGetManager(logCtxt),\n                            incoming != NULL) < 0)\n        goto cleanup;\n\n    VIR_DEBUG(\"Building emulator command line\");\n    if (!(cmd = qemuBuildCommandLine(driver,\n                                     qemuDomainLogContextGetManager(logCtxt),\n                                     driver->securityManager,\n                                     vm,\n                                     incoming ? incoming->launchURI : NULL,\n                                     snapshot, vmop,\n                                     false,\n                                     qemuCheckFips(vm),\n                                     &nnicindexes, &nicindexes, 0)))\n        goto cleanup;\n\n    if (incoming && incoming->fd != -1)\n        virCommandPassFD(cmd, incoming->fd, 0);\n\n    /* now that we know it is about to start call the hook if present */\n    if (qemuProcessStartHook(driver, vm,\n                             VIR_HOOK_QEMU_OP_START,\n                             VIR_HOOK_SUBOP_BEGIN) < 0)\n        goto cleanup;\n\n    qemuLogOperation(vm, \"starting up\", cmd, logCtxt);\n\n    qemuDomainObjCheckTaint(driver, vm, logCtxt, incoming != NULL);\n\n    qemuDomainLogContextMarkPosition(logCtxt);\n\n    VIR_DEBUG(\"Building mount namespace\");\n\n    if (qemuProcessEnableDomainNamespaces(driver, vm) < 0)\n        goto cleanup;\n\n    VIR_DEBUG(\"Setting up raw IO\");\n    if (qemuProcessSetupRawIO(driver, vm, cmd) < 0)\n        goto cleanup;\n\n    virCommandSetPreExecHook(cmd, qemuProcessHook, &hookData);\n    virCommandSetMaxProcesses(cmd, cfg->maxProcesses);\n    virCommandSetMaxFiles(cmd, cfg->maxFiles);\n    virCommandSetMaxCoreSize(cmd, cfg->maxCore);\n    virCommandSetUmask(cmd, 0x002);\n\n    VIR_DEBUG(\"Setting up security labelling\");\n    if (qemuSecuritySetChildProcessLabel(driver->securityManager,\n                                         vm->def, cmd) < 0)\n        goto cleanup;\n\n    virCommandSetOutputFD(cmd, &logfile);\n    virCommandSetErrorFD(cmd, &logfile);\n    virCommandNonblockingFDs(cmd);\n    virCommandSetPidFile(cmd, priv->pidfile);\n    virCommandDaemonize(cmd);\n    virCommandRequireHandshake(cmd);\n\n    if (qemuSecurityPreFork(driver->securityManager) < 0)\n        goto cleanup;\n    rv = virCommandRun(cmd, NULL);\n    qemuSecurityPostFork(driver->securityManager);\n\n    /* wait for qemu process to show up */\n    if (rv == 0) {\n        if ((rv = virPidFileReadPath(priv->pidfile, &vm->pid)) < 0) {\n            virReportSystemError(-rv,\n                                 _(\"Domain %s didn't show up\"),\n                                 vm->def->name);\n            goto cleanup;\n        }\n        VIR_DEBUG(\"QEMU vm=%p name=%s running with pid=%lld\",\n                  vm, vm->def->name, (long long)vm->pid);\n    } else {\n        VIR_DEBUG(\"QEMU vm=%p name=%s failed to spawn\",\n                  vm, vm->def->name);\n        goto cleanup;\n    }\n\n    VIR_DEBUG(\"Writing early domain status to disk\");\n    if (virDomainObjSave(vm, driver->xmlopt, cfg->stateDir) < 0)\n        goto cleanup;\n\n    VIR_DEBUG(\"Waiting for handshake from child\");\n    if (virCommandHandshakeWait(cmd) < 0) {\n        /* Read errors from child that occurred between fork and exec. */\n        qemuProcessReportLogError(logCtxt,\n                                  _(\"Process exited prior to exec\"));\n        goto cleanup;\n    }\n\n    VIR_DEBUG(\"Building domain mount namespace (if required)\");\n    if (qemuDomainBuildNamespace(cfg, vm) < 0)\n        goto cleanup;\n\n    VIR_DEBUG(\"Setting up domain cgroup (if required)\");\n    if (qemuSetupCgroup(vm, nnicindexes, nicindexes) < 0)\n        goto cleanup;\n\n    VIR_DEBUG(\"Setting up domain perf (if required)\");\n    if (qemuProcessEnablePerf(vm) < 0)\n        goto cleanup;\n\n    /* This must be done after cgroup placement to avoid resetting CPU\n     * affinity */\n    if (qemuProcessInitCpuAffinity(vm) < 0)\n        goto cleanup;\n\n    VIR_DEBUG(\"Setting emulator tuning/settings\");\n    if (qemuProcessSetupEmulator(vm) < 0)\n        goto cleanup;\n\n    VIR_DEBUG(\"Setting cgroup for external devices (if required)\");\n    if (qemuSetupCgroupForExtDevices(vm, driver) < 0)\n        goto cleanup;\n\n    VIR_DEBUG(\"Setting up resctrl\");\n    if (qemuProcessResctrlCreate(driver, vm) < 0)\n        goto cleanup;\n\n    VIR_DEBUG(\"Setting up managed PR daemon\");\n    if (virDomainDefHasManagedPR(vm->def) &&\n        qemuProcessStartManagedPRDaemon(vm) < 0)\n        goto cleanup;\n\n    VIR_DEBUG(\"Setting domain security labels\");\n    if (qemuSecuritySetAllLabel(driver,\n                                vm,\n                                incoming ? incoming->path : NULL,\n                                incoming != NULL) < 0)\n        goto cleanup;\n\n    /* Security manager labeled all devices, therefore\n     * if any operation from now on fails, we need to ask the caller to\n     * restore labels.\n     */\n    ret = -2;\n\n    if (incoming && incoming->fd != -1) {\n        /* if there's an fd to migrate from, and it's a pipe, put the\n         * proper security label on it\n         */\n        struct stat stdin_sb;\n\n        VIR_DEBUG(\"setting security label on pipe used for migration\");\n\n        if (fstat(incoming->fd, &stdin_sb) < 0) {\n            virReportSystemError(errno,\n                                 _(\"cannot stat fd %d\"), incoming->fd);\n            goto cleanup;\n        }\n        if (S_ISFIFO(stdin_sb.st_mode) &&\n            qemuSecuritySetImageFDLabel(driver->securityManager,\n                                        vm->def, incoming->fd) < 0)\n            goto cleanup;\n    }\n\n    VIR_DEBUG(\"Labelling done, completing handshake to child\");\n    if (virCommandHandshakeNotify(cmd) < 0)\n        goto cleanup;\n    VIR_DEBUG(\"Handshake complete, child running\");\n\n    if (qemuDomainObjStartWorker(vm) < 0)\n        goto cleanup;\n\n    VIR_DEBUG(\"Waiting for monitor to show up\");\n    if (qemuProcessWaitForMonitor(driver, vm, asyncJob, logCtxt) < 0)\n        goto cleanup;\n\n    if (qemuConnectAgent(driver, vm) < 0)\n        goto cleanup;\n\n    VIR_DEBUG(\"Verifying and updating provided guest CPU\");\n    if (qemuProcessUpdateAndVerifyCPU(driver, vm, asyncJob) < 0)\n        goto cleanup;\n\n    VIR_DEBUG(\"setting up hotpluggable cpus\");\n    if (qemuDomainHasHotpluggableStartupVcpus(vm->def)) {\n        if (qemuDomainRefreshVcpuInfo(driver, vm, asyncJob, false) < 0)\n            goto cleanup;\n\n        if (qemuProcessValidateHotpluggableVcpus(vm->def) < 0)\n            goto cleanup;\n\n        if (qemuProcessSetupHotpluggableVcpus(driver, vm, asyncJob) < 0)\n            goto cleanup;\n    }\n\n    VIR_DEBUG(\"Refreshing VCPU info\");\n    if (qemuDomainRefreshVcpuInfo(driver, vm, asyncJob, false) < 0)\n        goto cleanup;\n\n    if (qemuDomainValidateVcpuInfo(vm) < 0)\n        goto cleanup;\n\n    qemuDomainVcpuPersistOrder(vm->def);\n\n    VIR_DEBUG(\"Detecting IOThread PIDs\");\n    if (qemuProcessDetectIOThreadPIDs(driver, vm, asyncJob) < 0)\n        goto cleanup;\n\n    VIR_DEBUG(\"Setting global CPU cgroup (if required)\");\n    if (qemuSetupGlobalCpuCgroup(vm) < 0)\n        goto cleanup;\n\n    VIR_DEBUG(\"Setting vCPU tuning/settings\");\n    if (qemuProcessSetupVcpus(vm) < 0)\n        goto cleanup;\n\n    VIR_DEBUG(\"Setting IOThread tuning/settings\");\n    if (qemuProcessSetupIOThreads(vm) < 0)\n        goto cleanup;\n\n    VIR_DEBUG(\"Setting emulator scheduler\");\n    if (vm->def->cputune.emulatorsched &&\n        virProcessSetScheduler(vm->pid,\n                               vm->def->cputune.emulatorsched->policy,\n                               vm->def->cputune.emulatorsched->priority) < 0)\n        goto cleanup;\n\n    VIR_DEBUG(\"Setting any required VM passwords\");\n    if (qemuProcessInitPasswords(driver, vm, asyncJob) < 0)\n        goto cleanup;\n\n    /* set default link states */\n    /* qemu doesn't support setting this on the command line, so\n     * enter the monitor */\n    VIR_DEBUG(\"Setting network link states\");\n    if (qemuProcessSetLinkStates(driver, vm, asyncJob) < 0)\n        goto cleanup;\n\n    VIR_DEBUG(\"Setting initial memory amount\");\n    if (qemuProcessSetupBalloon(driver, vm, asyncJob) < 0)\n        goto cleanup;\n\n    if (qemuProcessSetupDiskThrottlingBlockdev(driver, vm, asyncJob) < 0)\n        goto cleanup;\n\n    /* Since CPUs were not started yet, the balloon could not return the memory\n     * to the host and thus cur_balloon needs to be updated so that GetXMLdesc\n     * and friends return the correct size in case they can't grab the job */\n    if (!incoming && !snapshot &&\n        qemuProcessRefreshBalloonState(driver, vm, asyncJob) < 0)\n        goto cleanup;\n\n    if (flags & VIR_QEMU_PROCESS_START_AUTODESTROY &&\n        qemuProcessAutoDestroyAdd(driver, vm, conn) < 0)\n        goto cleanup;\n\n    VIR_DEBUG(\"Setting up transient disk\");\n    if (qemuSnapshotCreateDisksTransient(vm, asyncJob) < 0)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    qemuDomainSecretDestroy(vm);\n    return ret;\n}\n\n\n/**\n * qemuProcessRefreshState:\n * @driver: qemu driver data\n * @vm: domain to refresh\n * @asyncJob: async job type\n *\n * This function gathers calls to refresh qemu state after startup. This\n * function is called after a deferred migration finishes so that we can update\n * state influenced by the migration stream.\n */\nint\nqemuProcessRefreshState(virQEMUDriverPtr driver,\n                        virDomainObjPtr vm,\n                        qemuDomainAsyncJob asyncJob)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n\n    VIR_DEBUG(\"Fetching list of active devices\");\n    if (qemuDomainUpdateDeviceList(driver, vm, asyncJob) < 0)\n        return -1;\n\n    VIR_DEBUG(\"Updating info of memory devices\");\n    if (qemuDomainUpdateMemoryDeviceInfo(driver, vm, asyncJob) < 0)\n        return -1;\n\n    VIR_DEBUG(\"Detecting actual memory size for video device\");\n    if (qemuProcessUpdateVideoRamSize(driver, vm, asyncJob) < 0)\n        return -1;\n\n    VIR_DEBUG(\"Updating disk data\");\n    if (qemuProcessRefreshDisks(driver, vm, asyncJob) < 0)\n        return -1;\n    if (!virQEMUCapsGet(priv->qemuCaps, QEMU_CAPS_BLOCKDEV) &&\n        qemuBlockNodeNamesDetect(driver, vm, asyncJob) < 0)\n        return -1;\n\n    return 0;\n}\n\n\n/**\n * qemuProcessFinishStartup:\n *\n * Finish starting a new domain.\n */\nint\nqemuProcessFinishStartup(virQEMUDriverPtr driver,\n                         virDomainObjPtr vm,\n                         qemuDomainAsyncJob asyncJob,\n                         bool startCPUs,\n                         virDomainPausedReason pausedReason)\n{\n    g_autoptr(virQEMUDriverConfig) cfg = virQEMUDriverGetConfig(driver);\n\n    if (startCPUs) {\n        VIR_DEBUG(\"Starting domain CPUs\");\n        if (qemuProcessStartCPUs(driver, vm,\n                                 VIR_DOMAIN_RUNNING_BOOTED,\n                                 asyncJob) < 0) {\n            if (virGetLastErrorCode() == VIR_ERR_OK)\n                virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                               _(\"resume operation failed\"));\n            return -1;\n        }\n    } else {\n        virDomainObjSetState(vm, VIR_DOMAIN_PAUSED, pausedReason);\n    }\n\n    VIR_DEBUG(\"Writing domain status to disk\");\n    if (virDomainObjSave(vm, driver->xmlopt, cfg->stateDir) < 0)\n        return -1;\n\n    if (qemuProcessStartHook(driver, vm,\n                             VIR_HOOK_QEMU_OP_STARTED,\n                             VIR_HOOK_SUBOP_BEGIN) < 0)\n        return -1;\n\n    return 0;\n}\n\n\nint\nqemuProcessStart(virConnectPtr conn,\n                 virQEMUDriverPtr driver,\n                 virDomainObjPtr vm,\n                 virCPUDefPtr updatedCPU,\n                 qemuDomainAsyncJob asyncJob,\n                 const char *migrateFrom,\n                 int migrateFd,\n                 const char *migratePath,\n                 virDomainMomentObjPtr snapshot,\n                 virNetDevVPortProfileOp vmop,\n                 unsigned int flags)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    qemuProcessIncomingDefPtr incoming = NULL;\n    unsigned int stopFlags;\n    bool relabel = false;\n    bool relabelSavedState = false;\n    int ret = -1;\n    int rv;\n\n    VIR_DEBUG(\"conn=%p driver=%p vm=%p name=%s id=%d asyncJob=%s \"\n              \"migrateFrom=%s migrateFd=%d migratePath=%s \"\n              \"snapshot=%p vmop=%d flags=0x%x\",\n              conn, driver, vm, vm->def->name, vm->def->id,\n              qemuDomainAsyncJobTypeToString(asyncJob),\n              NULLSTR(migrateFrom), migrateFd, NULLSTR(migratePath),\n              snapshot, vmop, flags);\n\n    virCheckFlagsGoto(VIR_QEMU_PROCESS_START_COLD |\n                      VIR_QEMU_PROCESS_START_PAUSED |\n                      VIR_QEMU_PROCESS_START_AUTODESTROY |\n                      VIR_QEMU_PROCESS_START_GEN_VMID, cleanup);\n\n    if (!migrateFrom && !snapshot)\n        flags |= VIR_QEMU_PROCESS_START_NEW;\n\n    if (qemuProcessInit(driver, vm, updatedCPU,\n                        asyncJob, !!migrateFrom, flags) < 0)\n        goto cleanup;\n\n    if (migrateFrom) {\n        incoming = qemuProcessIncomingDefNew(priv->qemuCaps, NULL, migrateFrom,\n                                             migrateFd, migratePath);\n        if (!incoming)\n            goto stop;\n    }\n\n    if (qemuProcessPrepareDomain(driver, vm, flags) < 0)\n        goto stop;\n\n    if (qemuProcessPrepareHost(driver, vm, flags) < 0)\n        goto stop;\n\n    if (migratePath) {\n        if (qemuSecuritySetSavedStateLabel(driver->securityManager,\n                                           vm->def, migratePath) < 0)\n            goto cleanup;\n        relabelSavedState = true;\n    }\n\n    if ((rv = qemuProcessLaunch(conn, driver, vm, asyncJob, incoming,\n                                snapshot, vmop, flags)) < 0) {\n        if (rv == -2)\n            relabel = true;\n        goto stop;\n    }\n    relabel = true;\n\n    if (incoming) {\n        if (incoming->deferredURI &&\n            qemuMigrationDstRun(driver, vm, incoming->deferredURI, asyncJob) < 0)\n            goto stop;\n    } else {\n        /* Refresh state of devices from QEMU. During migration this happens\n         * in qemuMigrationDstFinish to ensure that state information is fully\n         * transferred. */\n        if (qemuProcessRefreshState(driver, vm, asyncJob) < 0)\n            goto stop;\n    }\n\n    if (qemuProcessFinishStartup(driver, vm, asyncJob,\n                                 !(flags & VIR_QEMU_PROCESS_START_PAUSED),\n                                 incoming ?\n                                 VIR_DOMAIN_PAUSED_MIGRATION :\n                                 VIR_DOMAIN_PAUSED_USER) < 0)\n        goto stop;\n\n    if (!incoming) {\n        /* Keep watching qemu log for errors during incoming migration, otherwise\n         * unset reporting errors from qemu log. */\n        qemuMonitorSetDomainLog(priv->mon, NULL, NULL, NULL);\n    }\n\n    ret = 0;\n\n cleanup:\n    if (relabelSavedState &&\n        qemuSecurityRestoreSavedStateLabel(driver->securityManager,\n                                           vm->def, migratePath) < 0)\n        VIR_WARN(\"failed to restore save state label on %s\", migratePath);\n    qemuProcessIncomingDefFree(incoming);\n    return ret;\n\n stop:\n    stopFlags = 0;\n    if (!relabel)\n        stopFlags |= VIR_QEMU_PROCESS_STOP_NO_RELABEL;\n    if (migrateFrom)\n        stopFlags |= VIR_QEMU_PROCESS_STOP_MIGRATED;\n    if (priv->mon)\n        qemuMonitorSetDomainLog(priv->mon, NULL, NULL, NULL);\n    qemuProcessStop(driver, vm, VIR_DOMAIN_SHUTOFF_FAILED, asyncJob, stopFlags);\n    goto cleanup;\n}\n\n\nint\nqemuProcessCreatePretendCmdPrepare(virQEMUDriverPtr driver,\n                                   virDomainObjPtr vm,\n                                   const char *migrateURI,\n                                   bool standalone,\n                                   unsigned int flags)\n{\n    virCheckFlags(VIR_QEMU_PROCESS_START_COLD |\n                  VIR_QEMU_PROCESS_START_PAUSED |\n                  VIR_QEMU_PROCESS_START_AUTODESTROY, -1);\n\n    flags |= VIR_QEMU_PROCESS_START_PRETEND;\n\n    if (!migrateURI)\n        flags |= VIR_QEMU_PROCESS_START_NEW;\n\n    if (standalone)\n        flags |= VIR_QEMU_PROCESS_START_STANDALONE;\n\n    if (qemuProcessInit(driver, vm, NULL, QEMU_ASYNC_JOB_NONE,\n                        !!migrateURI, flags) < 0)\n        return -1;\n\n    if (qemuProcessPrepareDomain(driver, vm, flags) < 0)\n        return -1;\n\n    return 0;\n}\n\n\nvirCommandPtr\nqemuProcessCreatePretendCmdBuild(virQEMUDriverPtr driver,\n                                 virDomainObjPtr vm,\n                                 const char *migrateURI,\n                                 bool enableFips,\n                                 bool standalone,\n                                 bool jsonPropsValidation)\n{\n    unsigned int buildflags = 0;\n\n    if (jsonPropsValidation)\n        buildflags = QEMU_BUILD_COMMANDLINE_VALIDATE_KEEP_JSON;\n\n    VIR_DEBUG(\"Building emulator command line\");\n    return qemuBuildCommandLine(driver,\n                                NULL,\n                                driver->securityManager,\n                                vm,\n                                migrateURI,\n                                NULL,\n                                VIR_NETDEV_VPORT_PROFILE_OP_NO_OP,\n                                standalone,\n                                enableFips,\n                                NULL,\n                                NULL,\n                                buildflags);\n}\n\n\nint\nqemuProcessKill(virDomainObjPtr vm, unsigned int flags)\n{\n    VIR_DEBUG(\"vm=%p name=%s pid=%lld flags=0x%x\",\n              vm, vm->def->name,\n              (long long)vm->pid, flags);\n\n    if (!(flags & VIR_QEMU_PROCESS_KILL_NOCHECK)) {\n        if (!virDomainObjIsActive(vm)) {\n            VIR_DEBUG(\"VM '%s' not active\", vm->def->name);\n            return 0;\n        }\n    }\n\n    if (flags & VIR_QEMU_PROCESS_KILL_NOWAIT) {\n        virProcessKill(vm->pid,\n                       (flags & VIR_QEMU_PROCESS_KILL_FORCE) ?\n                       SIGKILL : SIGTERM);\n        return 0;\n    }\n\n    /* Request an extra delay of two seconds per current nhostdevs\n     * to be safe against stalls by the kernel freeing up the resources */\n    return virProcessKillPainfullyDelay(vm->pid,\n                                        !!(flags & VIR_QEMU_PROCESS_KILL_FORCE),\n                                        vm->def->nhostdevs * 2);\n}\n\n\n/**\n * qemuProcessBeginStopJob:\n *\n * Stop all current jobs by killing the domain and start a new one for\n * qemuProcessStop.\n */\nint\nqemuProcessBeginStopJob(virQEMUDriverPtr driver,\n                        virDomainObjPtr vm,\n                        qemuDomainJob job,\n                        bool forceKill)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    unsigned int killFlags = forceKill ? VIR_QEMU_PROCESS_KILL_FORCE : 0;\n    int ret = -1;\n\n    /* We need to prevent monitor EOF callback from doing our work (and\n     * sending misleading events) while the vm is unlocked inside\n     * BeginJob/ProcessKill API\n     */\n    priv->beingDestroyed = true;\n\n    if (qemuProcessKill(vm, killFlags) < 0)\n        goto cleanup;\n\n    /* Wake up anything waiting on domain condition */\n    virDomainObjBroadcast(vm);\n\n    if (qemuDomainObjBeginJob(driver, vm, job) < 0)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    priv->beingDestroyed = false;\n    return ret;\n}\n\n\nvoid qemuProcessStop(virQEMUDriverPtr driver,\n                     virDomainObjPtr vm,\n                     virDomainShutoffReason reason,\n                     qemuDomainAsyncJob asyncJob,\n                     unsigned int flags)\n{\n    int ret;\n    int retries = 0;\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    virErrorPtr orig_err;\n    virDomainDefPtr def = vm->def;\n    const virNetDevVPortProfile *vport = NULL;\n    size_t i;\n    g_autofree char *timestamp = NULL;\n    g_autoptr(virQEMUDriverConfig) cfg = virQEMUDriverGetConfig(driver);\n    g_autoptr(virConnect) conn = NULL;\n\n    VIR_DEBUG(\"Shutting down vm=%p name=%s id=%d pid=%lld, \"\n              \"reason=%s, asyncJob=%s, flags=0x%x\",\n              vm, vm->def->name, vm->def->id,\n              (long long)vm->pid,\n              virDomainShutoffReasonTypeToString(reason),\n              qemuDomainAsyncJobTypeToString(asyncJob),\n              flags);\n\n    /* This method is routinely used in clean up paths. Disable error\n     * reporting so we don't squash a legit error. */\n    virErrorPreserveLast(&orig_err);\n\n    if (asyncJob != QEMU_ASYNC_JOB_NONE) {\n        if (qemuDomainObjBeginNestedJob(driver, vm, asyncJob) < 0)\n            goto cleanup;\n    } else if (priv->job.asyncJob != QEMU_ASYNC_JOB_NONE &&\n               priv->job.asyncOwner == virThreadSelfID() &&\n               priv->job.active != QEMU_JOB_ASYNC_NESTED) {\n        VIR_WARN(\"qemuProcessStop called without a nested job (async=%s)\",\n                 qemuDomainAsyncJobTypeToString(asyncJob));\n    }\n\n    if (!virDomainObjIsActive(vm)) {\n        VIR_DEBUG(\"VM '%s' not active\", vm->def->name);\n        goto endjob;\n    }\n\n    qemuProcessBuildDestroyMemoryPaths(driver, vm, NULL, false);\n\n    if (!!g_atomic_int_dec_and_test(&driver->nactive) && driver->inhibitCallback)\n        driver->inhibitCallback(false, driver->inhibitOpaque);\n\n    /* Wake up anything waiting on domain condition */\n    virDomainObjBroadcast(vm);\n\n    if ((timestamp = virTimeStringNow()) != NULL) {\n        qemuDomainLogAppendMessage(driver, vm, \"%s: shutting down, reason=%s\\n\",\n                                   timestamp,\n                                   virDomainShutoffReasonTypeToString(reason));\n    }\n\n    /* Clear network bandwidth */\n    virDomainClearNetBandwidth(vm->def);\n\n    virDomainConfVMNWFilterTeardown(vm);\n\n    if (cfg->macFilter) {\n        for (i = 0; i < def->nnets; i++) {\n            virDomainNetDefPtr net = def->nets[i];\n            if (net->ifname == NULL)\n                continue;\n            ignore_value(ebtablesRemoveForwardAllowIn(driver->ebtables,\n                                                      net->ifname,\n                                                      &net->mac));\n        }\n    }\n\n    virPortAllocatorRelease(priv->nbdPort);\n    priv->nbdPort = 0;\n\n    if (priv->agent) {\n        qemuAgentClose(priv->agent);\n        priv->agent = NULL;\n    }\n    priv->agentError = false;\n\n    if (priv->mon) {\n        qemuMonitorClose(priv->mon);\n        priv->mon = NULL;\n    }\n\n    if (priv->monConfig) {\n        if (priv->monConfig->type == VIR_DOMAIN_CHR_TYPE_UNIX)\n            unlink(priv->monConfig->data.nix.path);\n        virObjectUnref(priv->monConfig);\n        priv->monConfig = NULL;\n    }\n\n    qemuDomainObjStopWorker(vm);\n\n    /* Remove the master key */\n    qemuDomainMasterKeyRemove(priv);\n\n    /* Do this before we delete the tree and remove pidfile. */\n    qemuProcessKillManagedPRDaemon(vm);\n\n    ignore_value(virDomainChrDefForeach(vm->def,\n                                        false,\n                                        qemuProcessCleanupChardevDevice,\n                                        NULL));\n\n\n    /* shut it off for sure */\n    ignore_value(qemuProcessKill(vm,\n                                 VIR_QEMU_PROCESS_KILL_FORCE|\n                                 VIR_QEMU_PROCESS_KILL_NOCHECK));\n\n    qemuDomainCleanupRun(driver, vm);\n\n    qemuExtDevicesStop(driver, vm);\n\n    qemuDBusStop(driver, vm);\n\n    vm->def->id = -1;\n\n    virFileDeleteTree(priv->libDir);\n    virFileDeleteTree(priv->channelTargetDir);\n\n    /* Stop autodestroy in case guest is restarted */\n    qemuProcessAutoDestroyRemove(driver, vm);\n\n    /* now that we know it's stopped call the hook if present */\n    if (virHookPresent(VIR_HOOK_DRIVER_QEMU)) {\n        g_autofree char *xml = qemuDomainDefFormatXML(driver, NULL, vm->def, 0);\n\n        /* we can't stop the operation even if the script raised an error */\n        ignore_value(virHookCall(VIR_HOOK_DRIVER_QEMU, vm->def->name,\n                                 VIR_HOOK_QEMU_OP_STOPPED, VIR_HOOK_SUBOP_END,\n                                 NULL, xml, NULL));\n    }\n\n    /* Reset Security Labels unless caller don't want us to */\n    if (!(flags & VIR_QEMU_PROCESS_STOP_NO_RELABEL))\n        qemuSecurityRestoreAllLabel(driver, vm,\n                                    !!(flags & VIR_QEMU_PROCESS_STOP_MIGRATED));\n\n    for (i = 0; i < vm->def->ndisks; i++) {\n        virDomainDeviceDef dev;\n        virDomainDiskDefPtr disk = vm->def->disks[i];\n\n        dev.type = VIR_DOMAIN_DEVICE_DISK;\n        dev.data.disk = disk;\n        ignore_value(qemuRemoveSharedDevice(driver, &dev, vm->def->name));\n    }\n\n    /* Clear out dynamically assigned labels */\n    for (i = 0; i < vm->def->nseclabels; i++) {\n        if (vm->def->seclabels[i]->type == VIR_DOMAIN_SECLABEL_DYNAMIC)\n            VIR_FREE(vm->def->seclabels[i]->label);\n        VIR_FREE(vm->def->seclabels[i]->imagelabel);\n    }\n\n    qemuHostdevReAttachDomainDevices(driver, vm->def);\n\n    for (i = 0; i < def->nnets; i++) {\n        virDomainNetDefPtr net = def->nets[i];\n        vport = virDomainNetGetActualVirtPortProfile(net);\n\n        switch (virDomainNetGetActualType(net)) {\n        case VIR_DOMAIN_NET_TYPE_DIRECT:\n            ignore_value(virNetDevMacVLanDeleteWithVPortProfile(\n                             net->ifname, &net->mac,\n                             virDomainNetGetActualDirectDev(net),\n                             virDomainNetGetActualDirectMode(net),\n                             virDomainNetGetActualVirtPortProfile(net),\n                             cfg->stateDir));\n            break;\n        case VIR_DOMAIN_NET_TYPE_ETHERNET:\n            if (net->managed_tap != VIR_TRISTATE_BOOL_NO && net->ifname) {\n                ignore_value(virNetDevTapDelete(net->ifname, net->backend.tap));\n                VIR_FREE(net->ifname);\n            }\n            break;\n        case VIR_DOMAIN_NET_TYPE_BRIDGE:\n        case VIR_DOMAIN_NET_TYPE_NETWORK:\n#ifdef VIR_NETDEV_TAP_REQUIRE_MANUAL_CLEANUP\n            if (!(vport && vport->virtPortType == VIR_NETDEV_VPORT_PROFILE_OPENVSWITCH))\n                ignore_value(virNetDevTapDelete(net->ifname, net->backend.tap));\n#endif\n            break;\n        case VIR_DOMAIN_NET_TYPE_USER:\n        case VIR_DOMAIN_NET_TYPE_VHOSTUSER:\n        case VIR_DOMAIN_NET_TYPE_SERVER:\n        case VIR_DOMAIN_NET_TYPE_CLIENT:\n        case VIR_DOMAIN_NET_TYPE_MCAST:\n        case VIR_DOMAIN_NET_TYPE_INTERNAL:\n        case VIR_DOMAIN_NET_TYPE_HOSTDEV:\n        case VIR_DOMAIN_NET_TYPE_UDP:\n        case VIR_DOMAIN_NET_TYPE_VDPA:\n        case VIR_DOMAIN_NET_TYPE_LAST:\n            /* No special cleanup procedure for these types. */\n            break;\n        }\n        /* release the physical device (or any other resources used by\n         * this interface in the network driver\n         */\n        if (vport) {\n            if (vport->virtPortType == VIR_NETDEV_VPORT_PROFILE_MIDONET) {\n                ignore_value(virNetDevMidonetUnbindPort(vport));\n            } else if (vport->virtPortType == VIR_NETDEV_VPORT_PROFILE_OPENVSWITCH) {\n                ignore_value(virNetDevOpenvswitchRemovePort(\n                                 virDomainNetGetActualBridgeName(net),\n                                 net->ifname));\n            }\n        }\n\n        /* kick the device out of the hostdev list too */\n        virDomainNetRemoveHostdev(def, net);\n        if (net->type == VIR_DOMAIN_NET_TYPE_NETWORK) {\n            if (conn || (conn = virGetConnectNetwork()))\n                virDomainNetReleaseActualDevice(conn, vm->def, net);\n            else\n                VIR_WARN(\"Unable to release network device '%s'\", NULLSTR(net->ifname));\n        }\n    }\n\n retry:\n    if ((ret = qemuRemoveCgroup(vm)) < 0) {\n        if (ret == -EBUSY && (retries++ < 5)) {\n            g_usleep(200*1000);\n            goto retry;\n        }\n        VIR_WARN(\"Failed to remove cgroup for %s\",\n                 vm->def->name);\n    }\n\n    /* Remove resctrl allocation after cgroups are cleaned up which makes it\n     * kind of safer (although removing the allocation should work even with\n     * pids in tasks file */\n    for (i = 0; i < vm->def->nresctrls; i++) {\n        size_t j = 0;\n\n        for (j = 0; j < vm->def->resctrls[i]->nmonitors; j++) {\n            virDomainResctrlMonDefPtr mon = NULL;\n\n            mon = vm->def->resctrls[i]->monitors[j];\n            virResctrlMonitorRemove(mon->instance);\n        }\n\n        virResctrlAllocRemove(vm->def->resctrls[i]->alloc);\n    }\n\n    /* clean up a possible backup job */\n    if (priv->backup)\n        qemuBackupJobTerminate(vm, QEMU_DOMAIN_JOB_STATUS_CANCELED);\n\n    qemuProcessRemoveDomainStatus(driver, vm);\n\n    /* Remove VNC and Spice ports from port reservation bitmap, but only if\n       they were reserved by the driver (autoport=yes)\n    */\n    for (i = 0; i < vm->def->ngraphics; ++i) {\n        virDomainGraphicsDefPtr graphics = vm->def->graphics[i];\n        if (graphics->type == VIR_DOMAIN_GRAPHICS_TYPE_VNC) {\n            if (graphics->data.vnc.autoport) {\n                virPortAllocatorRelease(graphics->data.vnc.port);\n            } else if (graphics->data.vnc.portReserved) {\n                virPortAllocatorRelease(graphics->data.vnc.port);\n                graphics->data.vnc.portReserved = false;\n            }\n            if (graphics->data.vnc.websocketGenerated) {\n                virPortAllocatorRelease(graphics->data.vnc.websocket);\n                graphics->data.vnc.websocketGenerated = false;\n                graphics->data.vnc.websocket = -1;\n            } else if (graphics->data.vnc.websocket) {\n                virPortAllocatorRelease(graphics->data.vnc.websocket);\n            }\n        }\n        if (graphics->type == VIR_DOMAIN_GRAPHICS_TYPE_SPICE) {\n            if (graphics->data.spice.autoport) {\n                virPortAllocatorRelease(graphics->data.spice.port);\n                virPortAllocatorRelease(graphics->data.spice.tlsPort);\n            } else {\n                if (graphics->data.spice.portReserved) {\n                    virPortAllocatorRelease(graphics->data.spice.port);\n                    graphics->data.spice.portReserved = false;\n                }\n\n                if (graphics->data.spice.tlsPortReserved) {\n                    virPortAllocatorRelease(graphics->data.spice.tlsPort);\n                    graphics->data.spice.tlsPortReserved = false;\n                }\n            }\n        }\n    }\n\n    for (i = 0; i < vm->ndeprecations; i++)\n        g_free(vm->deprecations[i]);\n    g_free(vm->deprecations);\n    vm->ndeprecations = 0;\n    vm->deprecations = NULL;\n    vm->taint = 0;\n    vm->pid = -1;\n    virDomainObjSetState(vm, VIR_DOMAIN_SHUTOFF, reason);\n    for (i = 0; i < vm->def->niothreadids; i++)\n        vm->def->iothreadids[i]->thread_id = 0;\n\n    /* Do this explicitly after vm->pid is reset so that security drivers don't\n     * try to enter the domain's namespace which is non-existent by now as qemu\n     * is no longer running. */\n    if (!(flags & VIR_QEMU_PROCESS_STOP_NO_RELABEL)) {\n        for (i = 0; i < def->ndisks; i++) {\n            virDomainDiskDefPtr disk = def->disks[i];\n\n            if (disk->mirror) {\n                if (qemuSecurityRestoreImageLabel(driver, vm, disk->mirror, false) < 0)\n                    VIR_WARN(\"Unable to restore security label on %s\", disk->dst);\n\n                if (virStorageSourceChainHasNVMe(disk->mirror))\n                    qemuHostdevReAttachOneNVMeDisk(driver, vm->def->name, disk->mirror);\n            }\n\n            qemuBlockRemoveImageMetadata(driver, vm, disk->dst, disk->src);\n\n            /* for now transient disks are forbidden with migration so they\n             * can be handled here */\n            if (disk->transient &&\n                !priv->inhibitDiskTransientDelete) {\n                VIR_DEBUG(\"Removing transient overlay '%s' of disk '%s'\",\n                          disk->src->path, disk->dst);\n                if (qemuDomainStorageFileInit(driver, vm, disk->src, NULL) >= 0) {\n                    virStorageSourceUnlink(disk->src);\n                    virStorageSourceDeinit(disk->src);\n                }\n            }\n        }\n    }\n\n    qemuSecurityReleaseLabel(driver->securityManager, vm->def);\n\n    /* clear all private data entries which are no longer needed */\n    qemuDomainObjPrivateDataClear(priv);\n\n    /* The \"release\" hook cleans up additional resources */\n    if (virHookPresent(VIR_HOOK_DRIVER_QEMU)) {\n        g_autofree char *xml = qemuDomainDefFormatXML(driver, NULL, vm->def, 0);\n\n        /* we can't stop the operation even if the script raised an error */\n        virHookCall(VIR_HOOK_DRIVER_QEMU, vm->def->name,\n                    VIR_HOOK_QEMU_OP_RELEASE, VIR_HOOK_SUBOP_END,\n                    NULL, xml, NULL);\n    }\n\n    virDomainObjRemoveTransientDef(vm);\n\n endjob:\n    if (asyncJob != QEMU_ASYNC_JOB_NONE)\n        qemuDomainObjEndJob(driver, vm);\n\n cleanup:\n    virErrorRestore(&orig_err);\n}\n\n\nstatic void\nqemuProcessAutoDestroy(virDomainObjPtr dom,\n                       virConnectPtr conn,\n                       void *opaque)\n{\n    virQEMUDriverPtr driver = opaque;\n    qemuDomainObjPrivatePtr priv = dom->privateData;\n    virObjectEventPtr event = NULL;\n    unsigned int stopFlags = 0;\n\n    VIR_DEBUG(\"vm=%s, conn=%p\", dom->def->name, conn);\n\n    if (priv->job.asyncJob == QEMU_ASYNC_JOB_MIGRATION_IN)\n        stopFlags |= VIR_QEMU_PROCESS_STOP_MIGRATED;\n\n    if (priv->job.asyncJob) {\n        VIR_DEBUG(\"vm=%s has long-term job active, cancelling\",\n                  dom->def->name);\n        qemuDomainObjDiscardAsyncJob(driver, dom);\n    }\n\n    VIR_DEBUG(\"Killing domain\");\n\n    if (qemuProcessBeginStopJob(driver, dom, QEMU_JOB_DESTROY, true) < 0)\n        return;\n\n    qemuProcessStop(driver, dom, VIR_DOMAIN_SHUTOFF_DESTROYED,\n                    QEMU_ASYNC_JOB_NONE, stopFlags);\n\n    virDomainAuditStop(dom, \"destroyed\");\n    event = virDomainEventLifecycleNewFromObj(dom,\n                                     VIR_DOMAIN_EVENT_STOPPED,\n                                     VIR_DOMAIN_EVENT_STOPPED_DESTROYED);\n\n    qemuDomainRemoveInactive(driver, dom);\n\n    qemuDomainObjEndJob(driver, dom);\n\n    virObjectEventStateQueue(driver->domainEventState, event);\n}\n\nint qemuProcessAutoDestroyAdd(virQEMUDriverPtr driver,\n                              virDomainObjPtr vm,\n                              virConnectPtr conn)\n{\n    VIR_DEBUG(\"vm=%s, conn=%p\", vm->def->name, conn);\n    return virCloseCallbacksSet(driver->closeCallbacks, vm, conn,\n                                qemuProcessAutoDestroy);\n}\n\nint qemuProcessAutoDestroyRemove(virQEMUDriverPtr driver,\n                                 virDomainObjPtr vm)\n{\n    VIR_DEBUG(\"vm=%s\", vm->def->name);\n    return virCloseCallbacksUnset(driver->closeCallbacks, vm,\n                                  qemuProcessAutoDestroy);\n}\n\nbool qemuProcessAutoDestroyActive(virQEMUDriverPtr driver,\n                                  virDomainObjPtr vm)\n{\n    virCloseCallback cb;\n    VIR_DEBUG(\"vm=%s\", vm->def->name);\n    cb = virCloseCallbacksGet(driver->closeCallbacks, vm, NULL);\n    return cb == qemuProcessAutoDestroy;\n}\n\n\nint\nqemuProcessRefreshDisks(virQEMUDriverPtr driver,\n                        virDomainObjPtr vm,\n                        qemuDomainAsyncJob asyncJob)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    bool blockdev = virQEMUCapsGet(priv->qemuCaps, QEMU_CAPS_BLOCKDEV);\n    GHashTable *table = NULL;\n    int ret = -1;\n    size_t i;\n\n    if (qemuDomainObjEnterMonitorAsync(driver, vm, asyncJob) == 0) {\n        table = qemuMonitorGetBlockInfo(priv->mon);\n        if (qemuDomainObjExitMonitor(driver, vm) < 0)\n            goto cleanup;\n    }\n\n    if (!table)\n        goto cleanup;\n\n    for (i = 0; i < vm->def->ndisks; i++) {\n        virDomainDiskDefPtr disk = vm->def->disks[i];\n        qemuDomainDiskPrivatePtr diskpriv = QEMU_DOMAIN_DISK_PRIVATE(disk);\n        struct qemuDomainDiskInfo *info;\n        const char *entryname = disk->info.alias;\n\n        if (blockdev && diskpriv->qomName)\n            entryname = diskpriv->qomName;\n\n        if (!(info = virHashLookup(table, entryname)))\n            continue;\n\n        if (info->removable) {\n            if (info->empty)\n                virDomainDiskEmptySource(disk);\n\n            if (info->tray) {\n                if (info->tray_open)\n                    disk->tray_status = VIR_DOMAIN_DISK_TRAY_OPEN;\n                else\n                    disk->tray_status = VIR_DOMAIN_DISK_TRAY_CLOSED;\n            }\n        }\n\n        /* fill in additional data */\n        diskpriv->removable = info->removable;\n        diskpriv->tray = info->tray;\n    }\n\n    ret = 0;\n\n cleanup:\n    virHashFree(table);\n    return ret;\n}\n\n\nstatic int\nqemuProcessRefreshCPUMigratability(virQEMUDriverPtr driver,\n                                   virDomainObjPtr vm,\n                                   qemuDomainAsyncJob asyncJob)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    virDomainDefPtr def = vm->def;\n    bool migratable;\n    int rc;\n\n    if (def->cpu->mode != VIR_CPU_MODE_HOST_PASSTHROUGH &&\n        def->cpu->mode != VIR_CPU_MODE_MAXIMUM)\n        return 0;\n\n    /* If the cpu.migratable capability is present, the migratable attribute\n     * is set correctly. */\n    if (virQEMUCapsGet(priv->qemuCaps, QEMU_CAPS_CPU_MIGRATABLE))\n        return 0;\n\n    if (!ARCH_IS_X86(def->os.arch))\n        return 0;\n\n    if (qemuDomainObjEnterMonitorAsync(driver, vm, asyncJob) < 0)\n        return -1;\n\n    rc = qemuMonitorGetCPUMigratable(priv->mon, &migratable);\n\n    if (qemuDomainObjExitMonitor(driver, vm) < 0 || rc < 0)\n        return -1;\n\n    if (rc == 1)\n        migratable = false;\n\n    /* Libvirt 6.5.0 would set migratable='off' for running domains even though\n     * the actual default used by QEMU was 'on'. */\n    if (def->cpu->migratable == VIR_TRISTATE_SWITCH_OFF && migratable) {\n        VIR_DEBUG(\"Fixing CPU migratable attribute\");\n        def->cpu->migratable = VIR_TRISTATE_SWITCH_ON;\n    }\n\n    if (def->cpu->migratable == VIR_TRISTATE_SWITCH_ABSENT)\n        def->cpu->migratable = virTristateSwitchFromBool(migratable);\n\n    return 0;\n}\n\n\nstatic int\nqemuProcessRefreshCPU(virQEMUDriverPtr driver,\n                      virDomainObjPtr vm)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    g_autoptr(virCPUDef) host = NULL;\n    g_autoptr(virCPUDef) hostmig = NULL;\n    g_autoptr(virCPUDef) cpu = NULL;\n\n    if (!virQEMUCapsGuestIsNative(driver->hostarch, vm->def->os.arch))\n        return 0;\n\n    if (!vm->def->cpu)\n        return 0;\n\n    if (qemuProcessRefreshCPUMigratability(driver, vm, QEMU_ASYNC_JOB_NONE) < 0)\n        return -1;\n\n    if (!(host = virQEMUDriverGetHostCPU(driver))) {\n        virResetLastError();\n        return 0;\n    }\n\n    /* If the domain with a host-model CPU was started by an old libvirt\n     * (< 2.3) which didn't replace the CPU with a custom one, let's do it now\n     * since the rest of our code does not really expect a host-model CPU in a\n     * running domain.\n     */\n    if (vm->def->cpu->mode == VIR_CPU_MODE_HOST_MODEL) {\n        /*\n         * PSeries domains are able to run with host-model CPU by design,\n         * even on Libvirt newer than 2.3, never replacing host-model with\n         * custom in the virCPUUpdate() call. It is not needed to call\n         * virCPUUpdate() and qemuProcessUpdateCPU() in this case.\n         */\n        if (qemuDomainIsPSeries(vm->def))\n            return 0;\n\n        if (!(hostmig = virCPUCopyMigratable(host->arch, host)))\n            return -1;\n\n        if (!(cpu = virCPUDefCopyWithoutModel(hostmig)) ||\n            virCPUDefCopyModelFilter(cpu, hostmig, false,\n                                     virQEMUCapsCPUFilterFeatures,\n                                     &host->arch) < 0)\n            return -1;\n\n        if (virCPUUpdate(vm->def->os.arch, vm->def->cpu, cpu) < 0)\n            return -1;\n\n        if (qemuProcessUpdateCPU(driver, vm, QEMU_ASYNC_JOB_NONE) < 0)\n            return -1;\n    } else if (!virQEMUCapsGet(priv->qemuCaps, QEMU_CAPS_QUERY_CPU_MODEL_EXPANSION)) {\n        /* We only try to fix CPUs when the libvirt/QEMU combo used to start\n         * the domain did not know about query-cpu-model-expansion in which\n         * case the host-model is known to not contain features which QEMU\n         * doesn't know about.\n         */\n        if (qemuDomainFixupCPUs(vm, &priv->origCPU) < 0)\n            return -1;\n    }\n\n    return 0;\n}\n\n\nstatic int\nqemuProcessRefreshLegacyBlockjob(void *payload,\n                                 const char *name,\n                                 void *opaque)\n{\n    const char *jobname = name;\n    virDomainObjPtr vm = opaque;\n    qemuMonitorBlockJobInfoPtr info = payload;\n    virDomainDiskDefPtr disk;\n    qemuBlockJobDataPtr job;\n    qemuBlockJobType jobtype = info->type;\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n\n    if (!(disk = qemuProcessFindDomainDiskByAliasOrQOM(vm, jobname, jobname))) {\n        VIR_DEBUG(\"could not find disk for block job '%s'\", jobname);\n        return 0;\n    }\n\n    if (jobtype == QEMU_BLOCKJOB_TYPE_COMMIT &&\n        disk->mirrorJob == VIR_DOMAIN_BLOCK_JOB_TYPE_ACTIVE_COMMIT)\n        jobtype = disk->mirrorJob;\n\n    if (!(job = qemuBlockJobDiskNew(vm, disk, jobtype, jobname)))\n        return -1;\n\n    if (disk->mirror) {\n        if ((!info->ready_present && info->end == info->cur) ||\n            info->ready) {\n            disk->mirrorState = VIR_DOMAIN_DISK_MIRROR_STATE_READY;\n            job->state = VIR_DOMAIN_BLOCK_JOB_READY;\n        }\n\n        /* Pre-blockdev block copy labelled the chain of the mirrored device\n         * just before pivoting. At that point it was no longer known whether\n         * it's even necessary (e.g. disk is being reused). This code fixes\n         * the labelling in case the job was started in a libvirt version\n         * which did not label the chain when the block copy is being started.\n         * Note that we can't do much on failure. */\n        if (disk->mirrorJob == VIR_DOMAIN_BLOCK_JOB_TYPE_COPY) {\n            if (qemuDomainDetermineDiskChain(priv->driver, vm, disk,\n                                             disk->mirror, true) < 0)\n                goto cleanup;\n\n            if (disk->mirror->format &&\n                disk->mirror->format != VIR_STORAGE_FILE_RAW &&\n                (qemuDomainNamespaceSetupDisk(vm, disk->mirror) < 0 ||\n                 qemuSetupImageChainCgroup(vm, disk->mirror) < 0 ||\n                 qemuSecuritySetImageLabel(priv->driver, vm, disk->mirror,\n                                           true, true) < 0))\n                goto cleanup;\n        }\n    }\n\n    qemuBlockJobStarted(job, vm);\n\n cleanup:\n    qemuBlockJobStartupFinalize(vm, job);\n\n    return 0;\n}\n\n\nstatic int\nqemuProcessRefreshLegacyBlockjobs(virQEMUDriverPtr driver,\n                                  virDomainObjPtr vm)\n{\n    GHashTable *blockJobs = NULL;\n    int ret = -1;\n\n    qemuDomainObjEnterMonitor(driver, vm);\n    blockJobs = qemuMonitorGetAllBlockJobInfo(qemuDomainGetMonitor(vm), true);\n    if (qemuDomainObjExitMonitor(driver, vm) < 0 || !blockJobs)\n        goto cleanup;\n\n    if (virHashForEach(blockJobs, qemuProcessRefreshLegacyBlockjob, vm) < 0)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    virHashFree(blockJobs);\n    return ret;\n}\n\n\nstatic int\nqemuProcessRefreshBlockjobs(virQEMUDriverPtr driver,\n                            virDomainObjPtr vm)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n\n    if (virQEMUCapsGet(priv->qemuCaps, QEMU_CAPS_BLOCKDEV))\n        return qemuBlockJobRefreshJobs(driver, vm);\n    else\n        return qemuProcessRefreshLegacyBlockjobs(driver, vm);\n}\n\n\nstruct qemuProcessReconnectData {\n    virQEMUDriverPtr driver;\n    virDomainObjPtr obj;\n    virIdentityPtr identity;\n};\n/*\n * Open an existing VM's monitor, re-detect VCPU threads\n * and re-reserve the security labels in use\n *\n * This function also inherits a locked and ref'd domain object.\n *\n * This function needs to:\n * 1. Enter job\n * 1. just before monitor reconnect do lightweight MonitorEnter\n *    (increase VM refcount and unlock VM)\n * 2. reconnect to monitor\n * 3. do lightweight MonitorExit (lock VM)\n * 4. continue reconnect process\n * 5. EndJob\n *\n * We can't do normal MonitorEnter & MonitorExit because these two lock the\n * monitor lock, which does not exists in this early phase.\n */\nstatic void\nqemuProcessReconnect(void *opaque)\n{\n    struct qemuProcessReconnectData *data = opaque;\n    virQEMUDriverPtr driver = data->driver;\n    virDomainObjPtr obj = data->obj;\n    qemuDomainObjPrivatePtr priv;\n    g_auto(qemuDomainJobObj) oldjob = {\n      .cb = NULL,\n    };\n    int state;\n    int reason;\n    g_autoptr(virQEMUDriverConfig) cfg = NULL;\n    size_t i;\n    unsigned int stopFlags = 0;\n    bool jobStarted = false;\n    bool retry = true;\n    bool tryMonReconn = false;\n\n    virIdentitySetCurrent(data->identity);\n    g_clear_object(&data->identity);\n    VIR_FREE(data);\n\n    qemuDomainObjRestoreJob(obj, &oldjob);\n    if (oldjob.asyncJob == QEMU_ASYNC_JOB_MIGRATION_IN)\n        stopFlags |= VIR_QEMU_PROCESS_STOP_MIGRATED;\n\n    cfg = virQEMUDriverGetConfig(driver);\n    priv = obj->privateData;\n\n    /* expect that libvirt might have crashed during VM start, so prevent\n     * cleanup of transient disks */\n    priv->inhibitDiskTransientDelete = true;\n\n    if (qemuDomainObjBeginJob(driver, obj, QEMU_JOB_MODIFY) < 0)\n        goto error;\n    jobStarted = true;\n\n    /* XXX If we ever gonna change pid file pattern, come up with\n     * some intelligence here to deal with old paths. */\n    if (!(priv->pidfile = virPidFileBuildPath(cfg->stateDir, obj->def->name)))\n        goto error;\n\n    /* Restore the masterKey */\n    if (qemuDomainMasterKeyReadFile(priv) < 0)\n        goto error;\n\n    /* If we are connecting to a guest started by old libvirt there is no\n     * allowReboot in status XML and we need to initialize it. */\n    qemuProcessPrepareAllowReboot(obj);\n\n    if (qemuHostdevUpdateActiveDomainDevices(driver, obj->def) < 0)\n        goto error;\n\n    if (priv->qemuCaps &&\n        virQEMUCapsGet(priv->qemuCaps, QEMU_CAPS_CHARDEV_FD_PASS))\n        retry = false;\n\n    if (qemuDomainObjStartWorker(obj) < 0)\n        goto error;\n\n    VIR_DEBUG(\"Reconnect monitor to def=%p name='%s' retry=%d\",\n              obj, obj->def->name, retry);\n\n    tryMonReconn = true;\n\n    /* XXX check PID liveliness & EXE path */\n    if (qemuConnectMonitor(driver, obj, QEMU_ASYNC_JOB_NONE, retry, NULL) < 0)\n        goto error;\n\n    priv->machineName = qemuDomainGetMachineName(obj);\n    if (!priv->machineName)\n        goto error;\n\n    if (qemuConnectCgroup(obj) < 0)\n        goto error;\n\n    if (qemuDomainPerfRestart(obj) < 0)\n        goto error;\n\n    /* recreate the pflash storage sources */\n    if (qemuDomainInitializePflashStorageSource(obj) < 0)\n        goto error;\n\n    /* XXX: Need to change as long as lock is introduced for\n     * qemu_driver->sharedDevices.\n     */\n    for (i = 0; i < obj->def->ndisks; i++) {\n        virDomainDiskDefPtr disk = obj->def->disks[i];\n        virDomainDeviceDef dev;\n\n        if (virDomainDiskTranslateSourcePool(disk) < 0)\n            goto error;\n\n        /* backing chains need to be refreshed only if they could change */\n        if (priv->reconnectBlockjobs != VIR_TRISTATE_BOOL_NO &&\n            !virQEMUCapsGet(priv->qemuCaps, QEMU_CAPS_BLOCKDEV)) {\n            /* This should be the only place that calls\n             * qemuDomainDetermineDiskChain with @report_broken == false\n             * to guarantee best-effort domain reconnect */\n            virStorageSourceBackingStoreClear(disk->src);\n            if (qemuDomainDetermineDiskChain(driver, obj, disk, NULL, false) < 0)\n                goto error;\n        } else {\n            VIR_DEBUG(\"skipping backing chain detection for '%s'\", disk->dst);\n        }\n\n        dev.type = VIR_DOMAIN_DEVICE_DISK;\n        dev.data.disk = disk;\n        if (qemuAddSharedDevice(driver, &dev, obj->def->name) < 0)\n            goto error;\n    }\n\n    for (i = 0; i < obj->def->ngraphics; i++) {\n        if (qemuProcessGraphicsReservePorts(obj->def->graphics[i], true) < 0)\n            goto error;\n    }\n\n    if (qemuProcessUpdateState(driver, obj) < 0)\n        goto error;\n\n    state = virDomainObjGetState(obj, &reason);\n    if (state == VIR_DOMAIN_SHUTOFF ||\n        (state == VIR_DOMAIN_PAUSED &&\n         reason == VIR_DOMAIN_PAUSED_STARTING_UP)) {\n        VIR_DEBUG(\"Domain '%s' wasn't fully started yet, killing it\",\n                  obj->def->name);\n        goto error;\n    }\n\n    if (!priv->qemuCaps) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"domain '%s' has no capabilities recorded\"),\n                       obj->def->name);\n        goto error;\n    }\n\n    /* vm startup complete, we can remove transient disks if required */\n    priv->inhibitDiskTransientDelete = false;\n\n    /* In case the domain shutdown while we were not running,\n     * we need to finish the shutdown process. And we need to do it after\n     * we have virQEMUCaps filled in.\n     */\n    if (state == VIR_DOMAIN_SHUTDOWN ||\n        (state == VIR_DOMAIN_PAUSED &&\n         reason == VIR_DOMAIN_PAUSED_SHUTTING_DOWN)) {\n        VIR_DEBUG(\"Finishing shutdown sequence for domain %s\",\n                  obj->def->name);\n        qemuProcessShutdownOrReboot(driver, obj);\n        goto cleanup;\n    }\n\n    if (qemuProcessBuildDestroyMemoryPaths(driver, obj, NULL, true) < 0)\n        goto error;\n\n    if ((qemuDomainAssignAddresses(obj->def, priv->qemuCaps,\n                                   driver, obj, false)) < 0) {\n        goto error;\n    }\n\n    /* if domain requests security driver we haven't loaded, report error, but\n     * do not kill the domain\n     */\n    ignore_value(qemuSecurityCheckAllLabel(driver->securityManager,\n                                           obj->def));\n\n    if (qemuProcessRefreshCPU(driver, obj) < 0)\n        goto error;\n\n    if (qemuDomainRefreshVcpuInfo(driver, obj, QEMU_ASYNC_JOB_NONE, true) < 0)\n        goto error;\n\n    qemuDomainVcpuPersistOrder(obj->def);\n\n    if (qemuProcessDetectIOThreadPIDs(driver, obj, QEMU_ASYNC_JOB_NONE) < 0)\n        goto error;\n\n    if (qemuSecurityReserveLabel(driver->securityManager, obj->def, obj->pid) < 0)\n        goto error;\n\n    qemuProcessNotifyNets(obj->def);\n\n    qemuProcessFiltersInstantiate(obj->def);\n\n    if (qemuProcessRefreshDisks(driver, obj, QEMU_ASYNC_JOB_NONE) < 0)\n        goto error;\n\n    if (!virQEMUCapsGet(priv->qemuCaps, QEMU_CAPS_BLOCKDEV) &&\n        qemuBlockNodeNamesDetect(driver, obj, QEMU_ASYNC_JOB_NONE) < 0)\n        goto error;\n\n    if (qemuRefreshVirtioChannelState(driver, obj, QEMU_ASYNC_JOB_NONE) < 0)\n        goto error;\n\n    /* If querying of guest's RTC failed, report error, but do not kill the domain. */\n    qemuRefreshRTC(driver, obj);\n\n    if (qemuProcessRefreshBalloonState(driver, obj, QEMU_ASYNC_JOB_NONE) < 0)\n        goto error;\n\n    if (qemuProcessRecoverJob(driver, obj, &oldjob, &stopFlags) < 0)\n        goto error;\n\n    if (qemuProcessRefreshBlockjobs(driver, obj) < 0)\n        goto error;\n\n    if (qemuProcessUpdateDevices(driver, obj) < 0)\n        goto error;\n\n    if (qemuRefreshPRManagerState(driver, obj) < 0)\n        goto error;\n\n    qemuProcessReconnectCheckMemAliasOrderMismatch(obj);\n\n    if (qemuConnectAgent(driver, obj) < 0)\n        goto error;\n\n    for (i = 0; i < obj->def->nresctrls; i++) {\n        size_t j = 0;\n\n        if (virResctrlAllocDeterminePath(obj->def->resctrls[i]->alloc,\n                                         priv->machineName) < 0)\n            goto error;\n\n        for (j = 0; j < obj->def->resctrls[i]->nmonitors; j++) {\n            virDomainResctrlMonDefPtr mon = NULL;\n\n            mon = obj->def->resctrls[i]->monitors[j];\n            if (virResctrlMonitorDeterminePath(mon->instance,\n                                               priv->machineName) < 0)\n                goto error;\n        }\n    }\n\n    /* update domain state XML with possibly updated state in virDomainObj */\n    if (virDomainObjSave(obj, driver->xmlopt, cfg->stateDir) < 0)\n        goto error;\n\n    /* Run an hook to allow admins to do some magic */\n    if (virHookPresent(VIR_HOOK_DRIVER_QEMU)) {\n        g_autofree char *xml = qemuDomainDefFormatXML(driver,\n                                                          priv->qemuCaps,\n                                                          obj->def, 0);\n        int hookret;\n\n        hookret = virHookCall(VIR_HOOK_DRIVER_QEMU, obj->def->name,\n                              VIR_HOOK_QEMU_OP_RECONNECT, VIR_HOOK_SUBOP_BEGIN,\n                              NULL, xml, NULL);\n\n        /*\n         * If the script raised an error abort the launch\n         */\n        if (hookret < 0)\n            goto error;\n    }\n\n    if (g_atomic_int_add(&driver->nactive, 1) == 0 && driver->inhibitCallback)\n        driver->inhibitCallback(true, driver->inhibitOpaque);\n\n cleanup:\n    if (jobStarted) {\n        if (!virDomainObjIsActive(obj))\n            qemuDomainRemoveInactive(driver, obj);\n        qemuDomainObjEndJob(driver, obj);\n    } else {\n        if (!virDomainObjIsActive(obj))\n            qemuDomainRemoveInactiveJob(driver, obj);\n    }\n    virDomainObjEndAPI(&obj);\n    virNWFilterUnlockFilterUpdates();\n    virIdentitySetCurrent(NULL);\n    return;\n\n error:\n    if (virDomainObjIsActive(obj)) {\n        /* We can't get the monitor back, so must kill the VM\n         * to remove danger of it ending up running twice if\n         * user tries to start it again later.\n         *\n         * If we cannot get to the monitor when the QEMU command\n         * line used -no-shutdown, then we can safely say that the\n         * domain crashed; otherwise, if the monitor was started,\n         * then we can blame ourselves, else we failed before the\n         * monitor started so we don't really know. */\n        if (!priv->mon && tryMonReconn &&\n            qemuDomainIsUsingNoShutdown(priv))\n            state = VIR_DOMAIN_SHUTOFF_CRASHED;\n        else if (priv->mon)\n            state = VIR_DOMAIN_SHUTOFF_DAEMON;\n        else\n            state = VIR_DOMAIN_SHUTOFF_UNKNOWN;\n\n        /* If BeginJob failed, we jumped here without a job, let's hope another\n         * thread didn't have a chance to start playing with the domain yet\n         * (it's all we can do anyway).\n         */\n        qemuProcessStop(driver, obj, state, QEMU_ASYNC_JOB_NONE, stopFlags);\n    }\n    goto cleanup;\n}\n\nstatic int\nqemuProcessReconnectHelper(virDomainObjPtr obj,\n                           void *opaque)\n{\n    virThread thread;\n    struct qemuProcessReconnectData *src = opaque;\n    struct qemuProcessReconnectData *data;\n    g_autofree char *name = NULL;\n\n    /* If the VM was inactive, we don't need to reconnect */\n    if (!obj->pid)\n        return 0;\n\n    data = g_new0(struct qemuProcessReconnectData, 1);\n\n    memcpy(data, src, sizeof(*data));\n    data->obj = obj;\n    data->identity = virIdentityGetCurrent();\n\n    virNWFilterReadLockFilterUpdates();\n\n    /* this lock and reference will be eventually transferred to the thread\n     * that handles the reconnect */\n    virObjectLock(obj);\n    virObjectRef(obj);\n\n    name = g_strdup_printf(\"init-%s\", obj->def->name);\n\n    if (virThreadCreateFull(&thread, false, qemuProcessReconnect,\n                            name, false, data) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Could not create thread. QEMU initialization \"\n                         \"might be incomplete\"));\n        /* We can't spawn a thread and thus connect to monitor. Kill qemu.\n         * It's safe to call qemuProcessStop without a job here since there\n         * is no thread that could be doing anything else with the same domain\n         * object.\n         */\n        qemuProcessStop(src->driver, obj, VIR_DOMAIN_SHUTOFF_FAILED,\n                        QEMU_ASYNC_JOB_NONE, 0);\n        qemuDomainRemoveInactiveJobLocked(src->driver, obj);\n\n        virDomainObjEndAPI(&obj);\n        virNWFilterUnlockFilterUpdates();\n        g_clear_object(&data->identity);\n        VIR_FREE(data);\n        return -1;\n    }\n\n    return 0;\n}\n\n/**\n * qemuProcessReconnectAll\n *\n * Try to re-open the resources for live VMs that we care\n * about.\n */\nvoid\nqemuProcessReconnectAll(virQEMUDriverPtr driver)\n{\n    struct qemuProcessReconnectData data = {.driver = driver};\n    virDomainObjListForEach(driver->domains, true,\n                            qemuProcessReconnectHelper, &data);\n}\n\n\nstatic void virQEMUCapsMonitorNotify(qemuMonitorPtr mon G_GNUC_UNUSED,\n                                     virDomainObjPtr vm G_GNUC_UNUSED,\n                                     void *opaque G_GNUC_UNUSED)\n{\n}\n\nstatic qemuMonitorCallbacks callbacks = {\n    .eofNotify = virQEMUCapsMonitorNotify,\n    .errorNotify = virQEMUCapsMonitorNotify,\n};\n\n\nstatic void\nqemuProcessQMPStop(qemuProcessQMPPtr proc)\n{\n    if (proc->mon) {\n        virObjectUnlock(proc->mon);\n        qemuMonitorClose(proc->mon);\n        proc->mon = NULL;\n    }\n\n    if (proc->cmd) {\n        virCommandAbort(proc->cmd);\n        virCommandFree(proc->cmd);\n        proc->cmd = NULL;\n    }\n\n    if (proc->monpath)\n        unlink(proc->monpath);\n\n    virDomainObjEndAPI(&proc->vm);\n\n    if (proc->pid != 0) {\n        VIR_DEBUG(\"Killing QMP caps process %lld\", (long long)proc->pid);\n        if (virProcessKill(proc->pid, SIGKILL) < 0 && errno != ESRCH)\n            VIR_ERROR(_(\"Failed to kill process %lld: %s\"),\n                      (long long)proc->pid,\n                      g_strerror(errno));\n\n        proc->pid = 0;\n    }\n\n    if (proc->pidfile)\n        unlink(proc->pidfile);\n\n    if (proc->uniqDir)\n        rmdir(proc->uniqDir);\n}\n\n\n/**\n * qemuProcessQMPFree:\n * @proc: Stores process and connection state\n *\n * Kill QEMU process and free process data structure.\n */\nvoid\nqemuProcessQMPFree(qemuProcessQMPPtr proc)\n{\n    if (!proc)\n        return;\n\n    qemuProcessQMPStop(proc);\n\n    g_object_unref(proc->eventThread);\n\n    g_free(proc->binary);\n    g_free(proc->libDir);\n    g_free(proc->uniqDir);\n    g_free(proc->monpath);\n    g_free(proc->monarg);\n    g_free(proc->pidfile);\n    g_free(proc->stdErr);\n    g_free(proc);\n}\n\n\n/**\n * qemuProcessQMPNew:\n * @binary: QEMU binary\n * @libDir: Directory for process and connection artifacts\n * @runUid: UserId for QEMU process\n * @runGid: GroupId for QEMU process\n * @forceTCG: Force TCG mode if true\n *\n * Allocate and initialize domain structure encapsulating QEMU process state\n * and monitor connection for completing QMP queries.\n */\nqemuProcessQMPPtr\nqemuProcessQMPNew(const char *binary,\n                  const char *libDir,\n                  uid_t runUid,\n                  gid_t runGid,\n                  bool forceTCG)\n{\n    g_autoptr(qemuProcessQMP) proc = NULL;\n    const char *threadSuffix;\n    g_autofree char *threadName = NULL;\n\n    VIR_DEBUG(\"exec=%s, libDir=%s, runUid=%u, runGid=%u, forceTCG=%d\",\n              binary, libDir, runUid, runGid, forceTCG);\n\n    proc = g_new0(qemuProcessQMP, 1);\n\n    proc->binary = g_strdup(binary);\n    proc->libDir = g_strdup(libDir);\n\n    proc->runUid = runUid;\n    proc->runGid = runGid;\n    proc->forceTCG = forceTCG;\n\n    threadSuffix = strrchr(binary, '-');\n    if (threadSuffix)\n        threadSuffix++;\n    else\n        threadSuffix = binary;\n    threadName = g_strdup_printf(\"qmp-%s\", threadSuffix);\n\n    if (!(proc->eventThread = virEventThreadNew(threadName)))\n        return NULL;\n\n    return g_steal_pointer(&proc);\n}\n\n\nstatic int\nqemuProcessQEMULabelUniqPath(qemuProcessQMPPtr proc)\n{\n    /* We cannot use the security driver here, but we should not need to. */\n    if (chown(proc->uniqDir, proc->runUid, -1) < 0) {\n        virReportSystemError(errno,\n                             _(\"Cannot chown uniq path: %s\"),\n                             proc->uniqDir);\n        return -1;\n    }\n\n    return 0;\n}\n\n\nstatic int\nqemuProcessQMPInit(qemuProcessQMPPtr proc)\n{\n    g_autofree char *template = NULL;\n\n    VIR_DEBUG(\"proc=%p, emulator=%s\", proc, proc->binary);\n\n    template = g_strdup_printf(\"%s/qmp-XXXXXX\", proc->libDir);\n\n    if (!(proc->uniqDir = g_mkdtemp(template))) {\n        virReportSystemError(errno,\n                             _(\"Failed to create unique directory with \"\n                               \"template '%s' for probing QEMU\"),\n                             template);\n        return -1;\n    }\n    /* if g_mkdtemp succeeds, proc->uniqDir is now the owner of\n     * the string. Set template to NULL to avoid freeing\n     * the memory in this case */\n    template = NULL;\n\n    if (qemuProcessQEMULabelUniqPath(proc) < 0)\n        return -1;\n\n    proc->monpath = g_strdup_printf(\"%s/%s\", proc->uniqDir, \"qmp.monitor\");\n\n    proc->monarg = g_strdup_printf(\"unix:%s,server,nowait\", proc->monpath);\n\n    /*\n     * Normally we'd use runDir for pid files, but because we're using\n     * -daemonize we need QEMU to be allowed to create them, rather\n     * than libvirtd. So we're using libDir which QEMU can write to\n     */\n    proc->pidfile = g_strdup_printf(\"%s/%s\", proc->uniqDir, \"qmp.pid\");\n\n    return 0;\n}\n\n\nstatic int\nqemuProcessQMPLaunch(qemuProcessQMPPtr proc)\n{\n    const char *machine;\n    int status = 0;\n    int rc;\n\n    if (proc->forceTCG)\n        machine = \"none,accel=tcg\";\n    else\n        machine = \"none,accel=kvm:tcg\";\n\n    VIR_DEBUG(\"Try to probe capabilities of '%s' via QMP, machine %s\",\n              proc->binary, machine);\n\n    /*\n     * We explicitly need to use -daemonize here, rather than\n     * virCommandDaemonize, because we need to synchronize\n     * with QEMU creating its monitor socket API. Using\n     * daemonize guarantees control won't return to libvirt\n     * until the socket is present.\n     */\n    proc->cmd = virCommandNewArgList(proc->binary,\n                                     \"-S\",\n                                     \"-no-user-config\",\n                                     \"-nodefaults\",\n                                     \"-nographic\",\n                                     \"-machine\", machine,\n                                     \"-qmp\", proc->monarg,\n                                     \"-pidfile\", proc->pidfile,\n                                     \"-daemonize\",\n                                    NULL);\n    virCommandAddEnvPassCommon(proc->cmd);\n    virCommandClearCaps(proc->cmd);\n\n#if WITH_CAPNG\n    /* QEMU might run into permission issues, e.g. /dev/sev (0600), override\n     * them just for the purpose of probing */\n    if (geteuid() == 0)\n        virCommandAllowCap(proc->cmd, CAP_DAC_OVERRIDE);\n#endif\n\n    virCommandSetGID(proc->cmd, proc->runGid);\n    virCommandSetUID(proc->cmd, proc->runUid);\n\n    virCommandSetErrorBuffer(proc->cmd, &(proc->stdErr));\n\n    if (virCommandRun(proc->cmd, &status) < 0)\n        return -1;\n\n    if (status != 0) {\n        VIR_DEBUG(\"QEMU %s exited with status %d\", proc->binary, status);\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to start QEMU binary %s for probing: %s\"),\n                       proc->binary,\n                       proc->stdErr ? proc->stdErr : _(\"unknown error\"));\n        return -1;\n    }\n\n    if ((rc = virPidFileReadPath(proc->pidfile, &proc->pid)) < 0) {\n        virReportSystemError(-rc, _(\"Failed to read pidfile %s\"), proc->pidfile);\n        return -1;\n    }\n\n    return 0;\n}\n\n\nint\nqemuProcessQMPInitMonitor(qemuMonitorPtr mon)\n{\n    if (qemuMonitorSetCapabilities(mon) < 0) {\n        VIR_DEBUG(\"Failed to set monitor capabilities %s\",\n                  virGetLastErrorMessage());\n        return -1;\n    }\n\n    return 0;\n}\n\n\nstatic int\nqemuProcessQMPConnectMonitor(qemuProcessQMPPtr proc)\n{\n    virDomainXMLOptionPtr xmlopt = NULL;\n    virDomainChrSourceDef monConfig;\n    int ret = -1;\n\n    VIR_DEBUG(\"proc=%p, emulator=%s, proc->pid=%lld\",\n              proc, proc->binary, (long long)proc->pid);\n\n    monConfig.type = VIR_DOMAIN_CHR_TYPE_UNIX;\n    monConfig.data.nix.path = proc->monpath;\n    monConfig.data.nix.listen = false;\n\n    if (!(xmlopt = virDomainXMLOptionNew(NULL, NULL, NULL, NULL, NULL)) ||\n        !(proc->vm = virDomainObjNew(xmlopt)) ||\n        !(proc->vm->def = virDomainDefNew()))\n        goto cleanup;\n\n    proc->vm->pid = proc->pid;\n\n    if (!(proc->mon = qemuMonitorOpen(proc->vm, &monConfig, true, 0,\n                                      virEventThreadGetContext(proc->eventThread),\n                                      &callbacks, NULL)))\n        goto cleanup;\n\n    virObjectLock(proc->mon);\n\n    if (qemuProcessQMPInitMonitor(proc->mon) < 0)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    virObjectUnref(xmlopt);\n    return ret;\n}\n\n\n/**\n * qemuProcessQMPStart:\n * @proc: QEMU process and connection state created by qemuProcessQMPNew()\n *\n * Start and connect to QEMU binary so QMP queries can be made.\n *\n * Usage:\n *   proc = qemuProcessQMPNew(binary, libDir, runUid, runGid, forceTCG);\n *   qemuProcessQMPStart(proc);\n *   ** Send QMP Queries to QEMU using monitor (proc->mon) **\n *   qemuProcessQMPFree(proc);\n *\n * Process error output (proc->stdErr) remains available in qemuProcessQMP\n * struct until qemuProcessQMPFree is called.\n */\nint\nqemuProcessQMPStart(qemuProcessQMPPtr proc)\n{\n    VIR_DEBUG(\"proc=%p, emulator=%s\", proc, proc->binary);\n\n    if (qemuProcessQMPInit(proc) < 0)\n        return -1;\n\n    if (qemuProcessQMPLaunch(proc) < 0)\n        return -1;\n\n    if (qemuProcessQMPConnectMonitor(proc) < 0)\n        return -1;\n\n    return 0;\n}\n"], "fixing_code": ["/*\n * qemu_process.c: QEMU process management\n *\n * Copyright (C) 2006-2016 Red Hat, Inc.\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library.  If not, see\n * <http://www.gnu.org/licenses/>.\n *\n */\n\n#include <config.h>\n\n#include <fcntl.h>\n#include <unistd.h>\n#include <signal.h>\n#include <sys/stat.h>\n#if defined(__linux__)\n# include <linux/capability.h>\n#elif defined(__FreeBSD__)\n# include <sys/param.h>\n# include <sys/cpuset.h>\n#endif\n\n#include <sys/utsname.h>\n\n#if WITH_CAPNG\n# include <cap-ng.h>\n#endif\n\n#include \"qemu_process.h\"\n#define LIBVIRT_QEMU_PROCESSPRIV_H_ALLOW\n#include \"qemu_processpriv.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_block.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_domain_address.h\"\n#include \"qemu_namespace.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_command.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_interface.h\"\n#include \"qemu_security.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_dbus.h\"\n#include \"qemu_snapshot.h\"\n\n#include \"cpu/cpu.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virhook.h\"\n#include \"virfile.h\"\n#include \"virpidfile.h\"\n#include \"virhostcpu.h\"\n#include \"domain_audit.h\"\n#include \"domain_nwfilter.h\"\n#include \"domain_validate.h\"\n#include \"locking/domain_lock.h\"\n#include \"viruuid.h\"\n#include \"virprocess.h\"\n#include \"virtime.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevmidonet.h\"\n#include \"virbitmap.h\"\n#include \"virnuma.h\"\n#include \"virstring.h\"\n#include \"virhostdev.h\"\n#include \"virsecret.h\"\n#include \"configmake.h\"\n#include \"nwfilter_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"virresctrl.h\"\n#include \"virvsock.h\"\n#include \"viridentity.h\"\n#include \"virthreadjob.h\"\n#include \"virutil.h\"\n#include \"storage_source.h\"\n\n#define VIR_FROM_THIS VIR_FROM_QEMU\n\nVIR_LOG_INIT(\"qemu.qemu_process\");\n\n/**\n * qemuProcessRemoveDomainStatus\n *\n * remove all state files of a domain from statedir\n */\nstatic void\nqemuProcessRemoveDomainStatus(virQEMUDriverPtr driver,\n                              virDomainObjPtr vm)\n{\n    g_autofree char *file = NULL;\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    g_autoptr(virQEMUDriverConfig) cfg = virQEMUDriverGetConfig(driver);\n\n    file = g_strdup_printf(\"%s/%s.xml\", cfg->stateDir, vm->def->name);\n\n    if (unlink(file) < 0 && errno != ENOENT && errno != ENOTDIR)\n        VIR_WARN(\"Failed to remove domain XML for %s: %s\",\n                 vm->def->name, g_strerror(errno));\n\n    if (priv->pidfile &&\n        unlink(priv->pidfile) < 0 &&\n        errno != ENOENT)\n        VIR_WARN(\"Failed to remove PID file for %s: %s\",\n                 vm->def->name, g_strerror(errno));\n}\n\n\n/*\n * This is a callback registered with a qemuAgentPtr instance,\n * and to be invoked when the agent console hits an end of file\n * condition, or error, thus indicating VM shutdown should be\n * performed\n */\nstatic void\nqemuProcessHandleAgentEOF(qemuAgentPtr agent,\n                          virDomainObjPtr vm)\n{\n    qemuDomainObjPrivatePtr priv;\n\n    VIR_DEBUG(\"Received EOF from agent on %p '%s'\", vm, vm->def->name);\n\n    virObjectLock(vm);\n\n    priv = vm->privateData;\n\n    if (!priv->agent) {\n        VIR_DEBUG(\"Agent freed already\");\n        goto unlock;\n    }\n\n    if (priv->beingDestroyed) {\n        VIR_DEBUG(\"Domain is being destroyed, agent EOF is expected\");\n        goto unlock;\n    }\n\n    qemuAgentClose(agent);\n    priv->agent = NULL;\n    priv->agentError = false;\n\n    virObjectUnlock(vm);\n    return;\n\n unlock:\n    virObjectUnlock(vm);\n    return;\n}\n\n\n/*\n * This is invoked when there is some kind of error\n * parsing data to/from the agent. The VM can continue\n * to run, but no further agent commands will be\n * allowed\n */\nstatic void\nqemuProcessHandleAgentError(qemuAgentPtr agent G_GNUC_UNUSED,\n                            virDomainObjPtr vm)\n{\n    qemuDomainObjPrivatePtr priv;\n\n    VIR_DEBUG(\"Received error from agent on %p '%s'\", vm, vm->def->name);\n\n    virObjectLock(vm);\n\n    priv = vm->privateData;\n\n    priv->agentError = true;\n\n    virObjectUnlock(vm);\n}\n\nstatic void qemuProcessHandleAgentDestroy(qemuAgentPtr agent,\n                                          virDomainObjPtr vm)\n{\n    VIR_DEBUG(\"Received destroy agent=%p vm=%p\", agent, vm);\n\n    virObjectUnref(vm);\n}\n\n\nstatic qemuAgentCallbacks agentCallbacks = {\n    .destroy = qemuProcessHandleAgentDestroy,\n    .eofNotify = qemuProcessHandleAgentEOF,\n    .errorNotify = qemuProcessHandleAgentError,\n};\n\n\nint\nqemuConnectAgent(virQEMUDriverPtr driver, virDomainObjPtr vm)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    qemuAgentPtr agent = NULL;\n    virDomainChrDefPtr config = qemuFindAgentConfig(vm->def);\n\n    if (!config)\n        return 0;\n\n    if (priv->agent)\n        return 0;\n\n    if (virQEMUCapsGet(priv->qemuCaps, QEMU_CAPS_VSERPORT_CHANGE) &&\n        config->state != VIR_DOMAIN_CHR_DEVICE_STATE_CONNECTED) {\n        VIR_DEBUG(\"Deferring connecting to guest agent\");\n        return 0;\n    }\n\n    if (qemuSecuritySetDaemonSocketLabel(driver->securityManager, vm->def) < 0) {\n        VIR_ERROR(_(\"Failed to set security context for agent for %s\"),\n                  vm->def->name);\n        goto cleanup;\n    }\n\n    /* Hold an extra reference because we can't allow 'vm' to be\n     * deleted while the agent is active */\n    virObjectRef(vm);\n\n    virObjectUnlock(vm);\n\n    agent = qemuAgentOpen(vm,\n                          config->source,\n                          virEventThreadGetContext(priv->eventThread),\n                          &agentCallbacks,\n                          virQEMUCapsGet(priv->qemuCaps, QEMU_CAPS_VSERPORT_CHANGE));\n\n    virObjectLock(vm);\n\n    if (agent == NULL)\n        virObjectUnref(vm);\n\n    if (!virDomainObjIsActive(vm)) {\n        qemuAgentClose(agent);\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"guest crashed while connecting to the guest agent\"));\n        return -1;\n    }\n\n    if (qemuSecurityClearSocketLabel(driver->securityManager, vm->def) < 0) {\n        VIR_ERROR(_(\"Failed to clear security context for agent for %s\"),\n                  vm->def->name);\n        qemuAgentClose(agent);\n        goto cleanup;\n    }\n\n    priv->agent = agent;\n    if (!priv->agent)\n        VIR_INFO(\"Failed to connect agent for %s\", vm->def->name);\n\n cleanup:\n    if (!priv->agent) {\n        VIR_WARN(\"Cannot connect to QEMU guest agent for %s\", vm->def->name);\n        priv->agentError = true;\n        virResetLastError();\n    }\n\n    return 0;\n}\n\n\n/*\n * This is a callback registered with a qemuMonitorPtr instance,\n * and to be invoked when the monitor console hits an end of file\n * condition, or error, thus indicating VM shutdown should be\n * performed\n */\nstatic void\nqemuProcessHandleMonitorEOF(qemuMonitorPtr mon,\n                            virDomainObjPtr vm,\n                            void *opaque)\n{\n    virQEMUDriverPtr driver = opaque;\n    qemuDomainObjPrivatePtr priv;\n    struct qemuProcessEvent *processEvent;\n\n    virObjectLock(vm);\n\n    VIR_DEBUG(\"Received EOF on %p '%s'\", vm, vm->def->name);\n\n    priv = vm->privateData;\n    if (priv->beingDestroyed) {\n        VIR_DEBUG(\"Domain is being destroyed, EOF is expected\");\n        goto cleanup;\n    }\n\n    processEvent = g_new0(struct qemuProcessEvent, 1);\n\n    processEvent->eventType = QEMU_PROCESS_EVENT_MONITOR_EOF;\n    processEvent->vm = virObjectRef(vm);\n\n    if (virThreadPoolSendJob(driver->workerPool, 0, processEvent) < 0) {\n        virObjectUnref(vm);\n        qemuProcessEventFree(processEvent);\n        goto cleanup;\n    }\n\n    /* We don't want this EOF handler to be called over and over while the\n     * thread is waiting for a job.\n     */\n    virObjectLock(mon);\n    qemuMonitorUnregister(mon);\n    virObjectUnlock(mon);\n\n    /* We don't want any cleanup from EOF handler (or any other\n     * thread) to enter qemu namespace. */\n    qemuDomainDestroyNamespace(driver, vm);\n\n cleanup:\n    virObjectUnlock(vm);\n}\n\n\n/*\n * This is invoked when there is some kind of error\n * parsing data to/from the monitor. The VM can continue\n * to run, but no further monitor commands will be\n * allowed\n */\nstatic void\nqemuProcessHandleMonitorError(qemuMonitorPtr mon G_GNUC_UNUSED,\n                              virDomainObjPtr vm,\n                              void *opaque)\n{\n    virQEMUDriverPtr driver = opaque;\n    virObjectEventPtr event = NULL;\n\n    VIR_DEBUG(\"Received error on %p '%s'\", vm, vm->def->name);\n\n    virObjectLock(vm);\n\n    ((qemuDomainObjPrivatePtr) vm->privateData)->monError = true;\n    event = virDomainEventControlErrorNewFromObj(vm);\n    virObjectEventStateQueue(driver->domainEventState, event);\n\n    virObjectUnlock(vm);\n}\n\n\n/**\n * qemuProcessFindDomainDiskByAliasOrQOM:\n * @vm: domain object to search for the disk\n * @alias: -drive or -device alias of the disk\n * @qomid: QOM tree device name\n *\n * Looks up a disk in the domain definition of @vm which either matches the\n * -drive or -device alias used for the backend and frontend respectively or the\n * QOM name. If @alias is empty it's treated as NULL as it's a mandatory field\n * in some cases.\n *\n * Returns a disk from @vm or NULL if it could not be found.\n */\nvirDomainDiskDefPtr\nqemuProcessFindDomainDiskByAliasOrQOM(virDomainObjPtr vm,\n                                      const char *alias,\n                                      const char *qomid)\n{\n    size_t i;\n\n    if (alias && *alias == '\\0')\n        alias = NULL;\n\n    if (alias)\n        alias = qemuAliasDiskDriveSkipPrefix(alias);\n\n    for (i = 0; i < vm->def->ndisks; i++) {\n        virDomainDiskDefPtr disk = vm->def->disks[i];\n        qemuDomainDiskPrivatePtr diskPriv = QEMU_DOMAIN_DISK_PRIVATE(disk);\n\n        if ((disk->info.alias && STREQ_NULLABLE(disk->info.alias, alias)) ||\n            (diskPriv->qomName && STREQ_NULLABLE(diskPriv->qomName, qomid)))\n            return disk;\n    }\n\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   _(\"no disk found with alias '%s' or id '%s'\"),\n                   NULLSTR(alias), NULLSTR(qomid));\n    return NULL;\n}\n\n\nstatic int\nqemuProcessHandleReset(qemuMonitorPtr mon G_GNUC_UNUSED,\n                       virDomainObjPtr vm,\n                       void *opaque)\n{\n    virQEMUDriverPtr driver = opaque;\n    virObjectEventPtr event;\n    qemuDomainObjPrivatePtr priv;\n    g_autoptr(virQEMUDriverConfig) cfg = virQEMUDriverGetConfig(driver);\n    int ret = -1;\n\n    virObjectLock(vm);\n\n    event = virDomainEventRebootNewFromObj(vm);\n    priv = vm->privateData;\n    if (priv->agent)\n        qemuAgentNotifyEvent(priv->agent, QEMU_AGENT_EVENT_RESET);\n\n    if (virDomainObjSave(vm, driver->xmlopt, cfg->stateDir) < 0)\n        VIR_WARN(\"Failed to save status on vm %s\", vm->def->name);\n\n    if (vm->def->onReboot == VIR_DOMAIN_LIFECYCLE_ACTION_DESTROY ||\n        vm->def->onReboot == VIR_DOMAIN_LIFECYCLE_ACTION_PRESERVE) {\n\n        if (qemuDomainObjBeginJob(driver, vm, QEMU_JOB_MODIFY) < 0)\n            goto cleanup;\n\n        if (!virDomainObjIsActive(vm)) {\n            VIR_DEBUG(\"Ignoring RESET event from inactive domain %s\",\n                      vm->def->name);\n            goto endjob;\n        }\n\n        qemuProcessStop(driver, vm, VIR_DOMAIN_SHUTOFF_DESTROYED,\n                        QEMU_ASYNC_JOB_NONE, 0);\n        virDomainAuditStop(vm, \"destroyed\");\n        qemuDomainRemoveInactive(driver, vm);\n     endjob:\n        qemuDomainObjEndJob(driver, vm);\n    }\n\n    ret = 0;\n cleanup:\n    virObjectUnlock(vm);\n    virObjectEventStateQueue(driver->domainEventState, event);\n    return ret;\n}\n\n\n/*\n * Since we have the '-no-shutdown' flag set, the\n * QEMU process will currently have guest OS shutdown\n * and the CPUS stopped. To fake the reboot, we thus\n * want todo a reset of the virtual hardware, followed\n * by restart of the CPUs. This should result in the\n * guest OS booting up again\n */\nstatic void\nqemuProcessFakeReboot(void *opaque)\n{\n    virDomainObjPtr vm = opaque;\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    virQEMUDriverPtr driver = priv->driver;\n    g_autoptr(virQEMUDriverConfig) cfg = virQEMUDriverGetConfig(driver);\n    virDomainRunningReason reason = VIR_DOMAIN_RUNNING_BOOTED;\n    int ret = -1, rc;\n\n    VIR_DEBUG(\"vm=%p\", vm);\n    virObjectLock(vm);\n    if (qemuDomainObjBeginJob(driver, vm, QEMU_JOB_MODIFY) < 0)\n        goto cleanup;\n\n    if (!virDomainObjIsActive(vm)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"guest unexpectedly quit\"));\n        goto endjob;\n    }\n\n    qemuDomainObjEnterMonitor(driver, vm);\n    rc = qemuMonitorSystemReset(priv->mon);\n\n    if (qemuDomainObjExitMonitor(driver, vm) < 0)\n        goto endjob;\n\n    if (rc < 0)\n        goto endjob;\n\n    if (virDomainObjGetState(vm, NULL) == VIR_DOMAIN_CRASHED)\n        reason = VIR_DOMAIN_RUNNING_CRASHED;\n\n    if (qemuProcessStartCPUs(driver, vm,\n                             reason,\n                             QEMU_ASYNC_JOB_NONE) < 0) {\n        if (virGetLastErrorCode() == VIR_ERR_OK)\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           \"%s\", _(\"resume operation failed\"));\n        goto endjob;\n    }\n\n    if (virDomainObjSave(vm, driver->xmlopt, cfg->stateDir) < 0) {\n        VIR_WARN(\"Unable to save status on vm %s after state change\",\n                 vm->def->name);\n    }\n\n    ret = 0;\n\n endjob:\n    qemuDomainObjEndJob(driver, vm);\n\n cleanup:\n    priv->pausedShutdown = false;\n    if (ret == -1)\n        ignore_value(qemuProcessKill(vm, VIR_QEMU_PROCESS_KILL_FORCE));\n    virDomainObjEndAPI(&vm);\n}\n\n\nvoid\nqemuProcessShutdownOrReboot(virQEMUDriverPtr driver,\n                            virDomainObjPtr vm)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n\n    if (priv->fakeReboot) {\n        g_autofree char *name = g_strdup_printf(\"reboot-%s\", vm->def->name);\n        virThread th;\n\n        qemuDomainSetFakeReboot(driver, vm, false);\n        virObjectRef(vm);\n        if (virThreadCreateFull(&th,\n                                false,\n                                qemuProcessFakeReboot,\n                                name,\n                                false,\n                                vm) < 0) {\n            VIR_ERROR(_(\"Failed to create reboot thread, killing domain\"));\n            ignore_value(qemuProcessKill(vm, VIR_QEMU_PROCESS_KILL_NOWAIT));\n            priv->pausedShutdown = false;\n            virObjectUnref(vm);\n        }\n    } else {\n        ignore_value(qemuProcessKill(vm, VIR_QEMU_PROCESS_KILL_NOWAIT));\n    }\n}\n\n\nstatic int\nqemuProcessHandleEvent(qemuMonitorPtr mon G_GNUC_UNUSED,\n                       virDomainObjPtr vm,\n                       const char *eventName,\n                       long long seconds,\n                       unsigned int micros,\n                       const char *details,\n                       void *opaque)\n{\n    virQEMUDriverPtr driver = opaque;\n    virObjectEventPtr event = NULL;\n\n    VIR_DEBUG(\"vm=%p\", vm);\n\n    virObjectLock(vm);\n    event = virDomainQemuMonitorEventNew(vm->def->id, vm->def->name,\n                                         vm->def->uuid, eventName,\n                                         seconds, micros, details);\n\n    virObjectUnlock(vm);\n    virObjectEventStateQueue(driver->domainEventState, event);\n\n    return 0;\n}\n\n\nstatic int\nqemuProcessHandleShutdown(qemuMonitorPtr mon G_GNUC_UNUSED,\n                          virDomainObjPtr vm,\n                          virTristateBool guest_initiated,\n                          void *opaque)\n{\n    virQEMUDriverPtr driver = opaque;\n    qemuDomainObjPrivatePtr priv;\n    virObjectEventPtr event = NULL;\n    g_autoptr(virQEMUDriverConfig) cfg = virQEMUDriverGetConfig(driver);\n    int detail = 0;\n\n    VIR_DEBUG(\"vm=%p\", vm);\n\n    virObjectLock(vm);\n\n    priv = vm->privateData;\n    if (virDomainObjGetState(vm, NULL) == VIR_DOMAIN_SHUTDOWN) {\n        VIR_DEBUG(\"Ignoring repeated SHUTDOWN event from domain %s\",\n                  vm->def->name);\n        goto unlock;\n    } else if (!virDomainObjIsActive(vm)) {\n        VIR_DEBUG(\"Ignoring SHUTDOWN event from inactive domain %s\",\n                  vm->def->name);\n        goto unlock;\n    }\n\n    /* In case of fake reboot qemu shutdown state is transient so don't\n     * change domain state nor send events. */\n    if (!priv->fakeReboot) {\n        VIR_DEBUG(\"Transitioned guest %s to shutdown state\",\n                  vm->def->name);\n        virDomainObjSetState(vm,\n                             VIR_DOMAIN_SHUTDOWN,\n                             VIR_DOMAIN_SHUTDOWN_UNKNOWN);\n\n        switch (guest_initiated) {\n        case VIR_TRISTATE_BOOL_YES:\n            detail = VIR_DOMAIN_EVENT_SHUTDOWN_GUEST;\n            break;\n\n        case VIR_TRISTATE_BOOL_NO:\n            detail = VIR_DOMAIN_EVENT_SHUTDOWN_HOST;\n            break;\n\n        case VIR_TRISTATE_BOOL_ABSENT:\n        case VIR_TRISTATE_BOOL_LAST:\n        default:\n            detail = VIR_DOMAIN_EVENT_SHUTDOWN_FINISHED;\n            break;\n        }\n\n        event = virDomainEventLifecycleNewFromObj(vm,\n                                                  VIR_DOMAIN_EVENT_SHUTDOWN,\n                                                  detail);\n\n        if (virDomainObjSave(vm, driver->xmlopt, cfg->stateDir) < 0) {\n            VIR_WARN(\"Unable to save status on vm %s after state change\",\n                     vm->def->name);\n        }\n    } else {\n        priv->pausedShutdown = true;\n    }\n\n    if (priv->agent)\n        qemuAgentNotifyEvent(priv->agent, QEMU_AGENT_EVENT_SHUTDOWN);\n\n    qemuProcessShutdownOrReboot(driver, vm);\n\n unlock:\n    virObjectUnlock(vm);\n    virObjectEventStateQueue(driver->domainEventState, event);\n\n    return 0;\n}\n\n\nstatic int\nqemuProcessHandleStop(qemuMonitorPtr mon G_GNUC_UNUSED,\n                      virDomainObjPtr vm,\n                      void *opaque)\n{\n    virQEMUDriverPtr driver = opaque;\n    virObjectEventPtr event = NULL;\n    virDomainPausedReason reason;\n    virDomainEventSuspendedDetailType detail;\n    g_autoptr(virQEMUDriverConfig) cfg = virQEMUDriverGetConfig(driver);\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n\n    virObjectLock(vm);\n\n    reason = priv->pausedReason;\n    priv->pausedReason = VIR_DOMAIN_PAUSED_UNKNOWN;\n\n    /* In case of fake reboot qemu paused state is transient so don't\n     * reveal it in domain state nor sent events */\n    if (virDomainObjGetState(vm, NULL) == VIR_DOMAIN_RUNNING &&\n        !priv->pausedShutdown) {\n        if (priv->job.asyncJob == QEMU_ASYNC_JOB_MIGRATION_OUT) {\n            if (priv->job.current->status == QEMU_DOMAIN_JOB_STATUS_POSTCOPY)\n                reason = VIR_DOMAIN_PAUSED_POSTCOPY;\n            else\n                reason = VIR_DOMAIN_PAUSED_MIGRATION;\n        }\n\n        detail = qemuDomainPausedReasonToSuspendedEvent(reason);\n        VIR_DEBUG(\"Transitioned guest %s to paused state, \"\n                  \"reason %s, event detail %d\",\n                  vm->def->name, virDomainPausedReasonTypeToString(reason),\n                  detail);\n\n        if (priv->job.current)\n            ignore_value(virTimeMillisNow(&priv->job.current->stopped));\n\n        if (priv->signalStop)\n            virDomainObjBroadcast(vm);\n\n        virDomainObjSetState(vm, VIR_DOMAIN_PAUSED, reason);\n        event = virDomainEventLifecycleNewFromObj(vm,\n                                                  VIR_DOMAIN_EVENT_SUSPENDED,\n                                                  detail);\n\n        VIR_FREE(priv->lockState);\n        if (virDomainLockProcessPause(driver->lockManager, vm, &priv->lockState) < 0)\n            VIR_WARN(\"Unable to release lease on %s\", vm->def->name);\n        VIR_DEBUG(\"Preserving lock state '%s'\", NULLSTR(priv->lockState));\n\n        if (virDomainObjSave(vm, driver->xmlopt, cfg->stateDir) < 0) {\n            VIR_WARN(\"Unable to save status on vm %s after state change\",\n                     vm->def->name);\n        }\n    }\n\n    virObjectUnlock(vm);\n    virObjectEventStateQueue(driver->domainEventState, event);\n\n    return 0;\n}\n\n\nstatic int\nqemuProcessHandleResume(qemuMonitorPtr mon G_GNUC_UNUSED,\n                        virDomainObjPtr vm,\n                        void *opaque)\n{\n    virQEMUDriverPtr driver = opaque;\n    virObjectEventPtr event = NULL;\n    g_autoptr(virQEMUDriverConfig) cfg = virQEMUDriverGetConfig(driver);\n    qemuDomainObjPrivatePtr priv;\n    virDomainRunningReason reason = VIR_DOMAIN_RUNNING_UNPAUSED;\n    virDomainEventResumedDetailType eventDetail;\n\n    virObjectLock(vm);\n\n    priv = vm->privateData;\n    if (priv->runningReason != VIR_DOMAIN_RUNNING_UNKNOWN) {\n        reason = priv->runningReason;\n        priv->runningReason = VIR_DOMAIN_RUNNING_UNKNOWN;\n    }\n\n    if (virDomainObjGetState(vm, NULL) != VIR_DOMAIN_RUNNING) {\n        eventDetail = qemuDomainRunningReasonToResumeEvent(reason);\n        VIR_DEBUG(\"Transitioned guest %s into running state, reason '%s', \"\n                  \"event detail %d\",\n                  vm->def->name, virDomainRunningReasonTypeToString(reason),\n                  eventDetail);\n\n        virDomainObjSetState(vm, VIR_DOMAIN_RUNNING, reason);\n        event = virDomainEventLifecycleNewFromObj(vm,\n                                                  VIR_DOMAIN_EVENT_RESUMED,\n                                                  eventDetail);\n\n        if (virDomainObjSave(vm, driver->xmlopt, cfg->stateDir) < 0) {\n            VIR_WARN(\"Unable to save status on vm %s after state change\",\n                     vm->def->name);\n        }\n    }\n\n    virObjectUnlock(vm);\n    virObjectEventStateQueue(driver->domainEventState, event);\n    return 0;\n}\n\nstatic int\nqemuProcessHandleRTCChange(qemuMonitorPtr mon G_GNUC_UNUSED,\n                           virDomainObjPtr vm,\n                           long long offset,\n                           void *opaque)\n{\n    virQEMUDriverPtr driver = opaque;\n    virObjectEventPtr event = NULL;\n    g_autoptr(virQEMUDriverConfig) cfg = virQEMUDriverGetConfig(driver);\n\n    virObjectLock(vm);\n\n    if (vm->def->clock.offset == VIR_DOMAIN_CLOCK_OFFSET_VARIABLE) {\n        /* when a basedate is manually given on the qemu commandline\n         * rather than simply \"-rtc base=utc\", the offset sent by qemu\n         * in this event is *not* the new offset from UTC, but is\n         * instead the new offset from the *original basedate* +\n         * uptime. For example, if the original offset was 3600 and\n         * the guest clock has been advanced by 10 seconds, qemu will\n         * send \"10\" in the event - this means that the new offset\n         * from UTC is 3610, *not* 10. If the guest clock is advanced\n         * by another 10 seconds, qemu will now send \"20\" - i.e. each\n         * event is the sum of the most recent change and all previous\n         * changes since the domain was started. Fortunately, we have\n         * saved the initial offset in \"adjustment0\", so to arrive at\n         * the proper new \"adjustment\", we just add the most recent\n         * offset to adjustment0.\n         */\n        offset += vm->def->clock.data.variable.adjustment0;\n        vm->def->clock.data.variable.adjustment = offset;\n\n        if (virDomainObjSave(vm, driver->xmlopt, cfg->stateDir) < 0)\n           VIR_WARN(\"unable to save domain status with RTC change\");\n    }\n\n    event = virDomainEventRTCChangeNewFromObj(vm, offset);\n\n    virObjectUnlock(vm);\n\n    virObjectEventStateQueue(driver->domainEventState, event);\n    return 0;\n}\n\n\nstatic int\nqemuProcessHandleWatchdog(qemuMonitorPtr mon G_GNUC_UNUSED,\n                          virDomainObjPtr vm,\n                          int action,\n                          void *opaque)\n{\n    virQEMUDriverPtr driver = opaque;\n    virObjectEventPtr watchdogEvent = NULL;\n    virObjectEventPtr lifecycleEvent = NULL;\n    g_autoptr(virQEMUDriverConfig) cfg = virQEMUDriverGetConfig(driver);\n\n    virObjectLock(vm);\n    watchdogEvent = virDomainEventWatchdogNewFromObj(vm, action);\n\n    if (action == VIR_DOMAIN_EVENT_WATCHDOG_PAUSE &&\n        virDomainObjGetState(vm, NULL) == VIR_DOMAIN_RUNNING) {\n        qemuDomainObjPrivatePtr priv = vm->privateData;\n        VIR_DEBUG(\"Transitioned guest %s to paused state due to watchdog\", vm->def->name);\n\n        virDomainObjSetState(vm, VIR_DOMAIN_PAUSED, VIR_DOMAIN_PAUSED_WATCHDOG);\n        lifecycleEvent = virDomainEventLifecycleNewFromObj(vm,\n                                                  VIR_DOMAIN_EVENT_SUSPENDED,\n                                                  VIR_DOMAIN_EVENT_SUSPENDED_WATCHDOG);\n\n        VIR_FREE(priv->lockState);\n        if (virDomainLockProcessPause(driver->lockManager, vm, &priv->lockState) < 0)\n            VIR_WARN(\"Unable to release lease on %s\", vm->def->name);\n        VIR_DEBUG(\"Preserving lock state '%s'\", NULLSTR(priv->lockState));\n\n        if (virDomainObjSave(vm, driver->xmlopt, cfg->stateDir) < 0) {\n            VIR_WARN(\"Unable to save status on vm %s after watchdog event\",\n                     vm->def->name);\n        }\n    }\n\n    if (vm->def->watchdog->action == VIR_DOMAIN_WATCHDOG_ACTION_DUMP) {\n        struct qemuProcessEvent *processEvent;\n        processEvent = g_new0(struct qemuProcessEvent, 1);\n\n        processEvent->eventType = QEMU_PROCESS_EVENT_WATCHDOG;\n        processEvent->action = VIR_DOMAIN_WATCHDOG_ACTION_DUMP;\n        /* Hold an extra reference because we can't allow 'vm' to be\n         * deleted before handling watchdog event is finished.\n         */\n        processEvent->vm = virObjectRef(vm);\n        if (virThreadPoolSendJob(driver->workerPool, 0, processEvent) < 0) {\n            virObjectUnref(vm);\n            qemuProcessEventFree(processEvent);\n        }\n    }\n\n    virObjectUnlock(vm);\n    virObjectEventStateQueue(driver->domainEventState, watchdogEvent);\n    virObjectEventStateQueue(driver->domainEventState, lifecycleEvent);\n\n    return 0;\n}\n\n\nstatic int\nqemuProcessHandleIOError(qemuMonitorPtr mon G_GNUC_UNUSED,\n                         virDomainObjPtr vm,\n                         const char *diskAlias,\n                         const char *nodename,\n                         int action,\n                         const char *reason,\n                         void *opaque)\n{\n    virQEMUDriverPtr driver = opaque;\n    virObjectEventPtr ioErrorEvent = NULL;\n    virObjectEventPtr ioErrorEvent2 = NULL;\n    virObjectEventPtr lifecycleEvent = NULL;\n    const char *srcPath;\n    const char *devAlias;\n    virDomainDiskDefPtr disk;\n    g_autoptr(virQEMUDriverConfig) cfg = virQEMUDriverGetConfig(driver);\n\n    virObjectLock(vm);\n\n    if (*diskAlias == '\\0')\n        diskAlias = NULL;\n\n    if (diskAlias)\n        disk = qemuProcessFindDomainDiskByAliasOrQOM(vm, diskAlias, NULL);\n    else if (nodename)\n        disk = qemuDomainDiskLookupByNodename(vm->def, NULL, nodename, NULL);\n    else\n        disk = NULL;\n\n    if (disk) {\n        srcPath = virDomainDiskGetSource(disk);\n        devAlias = disk->info.alias;\n    } else {\n        srcPath = \"\";\n        devAlias = \"\";\n    }\n\n    ioErrorEvent = virDomainEventIOErrorNewFromObj(vm, srcPath, devAlias, action);\n    ioErrorEvent2 = virDomainEventIOErrorReasonNewFromObj(vm, srcPath, devAlias, action, reason);\n\n    if (action == VIR_DOMAIN_EVENT_IO_ERROR_PAUSE &&\n        virDomainObjGetState(vm, NULL) == VIR_DOMAIN_RUNNING) {\n        qemuDomainObjPrivatePtr priv = vm->privateData;\n        VIR_DEBUG(\"Transitioned guest %s to paused state due to IO error\", vm->def->name);\n\n        if (priv->signalIOError)\n            virDomainObjBroadcast(vm);\n\n        virDomainObjSetState(vm, VIR_DOMAIN_PAUSED, VIR_DOMAIN_PAUSED_IOERROR);\n        lifecycleEvent = virDomainEventLifecycleNewFromObj(vm,\n                                                  VIR_DOMAIN_EVENT_SUSPENDED,\n                                                  VIR_DOMAIN_EVENT_SUSPENDED_IOERROR);\n\n        VIR_FREE(priv->lockState);\n        if (virDomainLockProcessPause(driver->lockManager, vm, &priv->lockState) < 0)\n            VIR_WARN(\"Unable to release lease on %s\", vm->def->name);\n        VIR_DEBUG(\"Preserving lock state '%s'\", NULLSTR(priv->lockState));\n\n        if (virDomainObjSave(vm, driver->xmlopt, cfg->stateDir) < 0)\n            VIR_WARN(\"Unable to save status on vm %s after IO error\", vm->def->name);\n    }\n    virObjectUnlock(vm);\n\n    virObjectEventStateQueue(driver->domainEventState, ioErrorEvent);\n    virObjectEventStateQueue(driver->domainEventState, ioErrorEvent2);\n    virObjectEventStateQueue(driver->domainEventState, lifecycleEvent);\n    return 0;\n}\n\nstatic int\nqemuProcessHandleBlockJob(qemuMonitorPtr mon G_GNUC_UNUSED,\n                          virDomainObjPtr vm,\n                          const char *diskAlias,\n                          int type,\n                          int status,\n                          const char *error,\n                          void *opaque)\n{\n    qemuDomainObjPrivatePtr priv;\n    virQEMUDriverPtr driver = opaque;\n    struct qemuProcessEvent *processEvent = NULL;\n    virDomainDiskDefPtr disk;\n    g_autoptr(qemuBlockJobData) job = NULL;\n    char *data = NULL;\n\n    virObjectLock(vm);\n\n    priv = vm->privateData;\n\n    /* with QEMU_CAPS_BLOCKDEV we handle block job events via JOB_STATUS_CHANGE */\n    if (virQEMUCapsGet(priv->qemuCaps, QEMU_CAPS_BLOCKDEV))\n        goto cleanup;\n\n    VIR_DEBUG(\"Block job for device %s (domain: %p,%s) type %d status %d\",\n              diskAlias, vm, vm->def->name, type, status);\n\n    if (!(disk = qemuProcessFindDomainDiskByAliasOrQOM(vm, diskAlias, NULL)))\n        goto cleanup;\n\n    job = qemuBlockJobDiskGetJob(disk);\n\n    if (job && job->synchronous) {\n        /* We have a SYNC API waiting for this event, dispatch it back */\n        job->newstate = status;\n        VIR_FREE(job->errmsg);\n        job->errmsg = g_strdup(error);\n        virDomainObjBroadcast(vm);\n    } else {\n        /* there is no waiting SYNC API, dispatch the update to a thread */\n        processEvent = g_new0(struct qemuProcessEvent, 1);\n\n        processEvent->eventType = QEMU_PROCESS_EVENT_BLOCK_JOB;\n        data = g_strdup(diskAlias);\n        processEvent->data = data;\n        processEvent->vm = virObjectRef(vm);\n        processEvent->action = type;\n        processEvent->status = status;\n\n        if (virThreadPoolSendJob(driver->workerPool, 0, processEvent) < 0) {\n            virObjectUnref(vm);\n            goto cleanup;\n        }\n\n        processEvent = NULL;\n    }\n\n cleanup:\n    qemuProcessEventFree(processEvent);\n    virObjectUnlock(vm);\n    return 0;\n}\n\n\nstatic int\nqemuProcessHandleJobStatusChange(qemuMonitorPtr mon G_GNUC_UNUSED,\n                                 virDomainObjPtr vm,\n                                 const char *jobname,\n                                 int status,\n                                 void *opaque)\n{\n    virQEMUDriverPtr driver = opaque;\n    qemuDomainObjPrivatePtr priv;\n    struct qemuProcessEvent *processEvent = NULL;\n    qemuBlockJobDataPtr job = NULL;\n    int jobnewstate;\n\n    virObjectLock(vm);\n    priv = vm->privateData;\n\n    VIR_DEBUG(\"job '%s'(domain: %p,%s) state changed to '%s'(%d)\",\n              jobname, vm, vm->def->name,\n              qemuMonitorJobStatusTypeToString(status), status);\n\n    if (!virQEMUCapsGet(priv->qemuCaps, QEMU_CAPS_BLOCKDEV)) {\n        VIR_DEBUG(\"job '%s' handled by old blockjob handler\", jobname);\n        goto cleanup;\n    }\n\n    if ((jobnewstate = qemuBlockjobConvertMonitorStatus(status)) == QEMU_BLOCKJOB_STATE_LAST)\n        goto cleanup;\n\n    if (!(job = virHashLookup(priv->blockjobs, jobname))) {\n        VIR_DEBUG(\"job '%s' not registered\", jobname);\n        goto cleanup;\n    }\n\n    job->newstate = jobnewstate;\n\n    if (job->synchronous) {\n        VIR_DEBUG(\"job '%s' handled synchronously\", jobname);\n        virDomainObjBroadcast(vm);\n    } else {\n        VIR_DEBUG(\"job '%s' handled by event thread\", jobname);\n        processEvent = g_new0(struct qemuProcessEvent, 1);\n\n        processEvent->eventType = QEMU_PROCESS_EVENT_JOB_STATUS_CHANGE;\n        processEvent->vm = virObjectRef(vm);\n        processEvent->data = virObjectRef(job);\n\n        if (virThreadPoolSendJob(driver->workerPool, 0, processEvent) < 0) {\n            virObjectUnref(vm);\n            goto cleanup;\n        }\n\n        processEvent = NULL;\n    }\n\n cleanup:\n    qemuProcessEventFree(processEvent);\n    virObjectUnlock(vm);\n    return 0;\n}\n\n\nstatic int\nqemuProcessHandleGraphics(qemuMonitorPtr mon G_GNUC_UNUSED,\n                          virDomainObjPtr vm,\n                          int phase,\n                          int localFamily,\n                          const char *localNode,\n                          const char *localService,\n                          int remoteFamily,\n                          const char *remoteNode,\n                          const char *remoteService,\n                          const char *authScheme,\n                          const char *x509dname,\n                          const char *saslUsername,\n                          void *opaque)\n{\n    virQEMUDriverPtr driver = opaque;\n    virObjectEventPtr event;\n    virDomainEventGraphicsAddressPtr localAddr = NULL;\n    virDomainEventGraphicsAddressPtr remoteAddr = NULL;\n    virDomainEventGraphicsSubjectPtr subject = NULL;\n    size_t i;\n\n    localAddr = g_new0(virDomainEventGraphicsAddress, 1);\n    localAddr->family = localFamily;\n    localAddr->service = g_strdup(localService);\n    localAddr->node = g_strdup(localNode);\n\n    remoteAddr = g_new0(virDomainEventGraphicsAddress, 1);\n    remoteAddr->family = remoteFamily;\n    remoteAddr->service = g_strdup(remoteService);\n    remoteAddr->node = g_strdup(remoteNode);\n\n    subject = g_new0(virDomainEventGraphicsSubject, 1);\n    if (x509dname) {\n        if (VIR_REALLOC_N(subject->identities, subject->nidentity+1) < 0)\n            goto error;\n        subject->nidentity++;\n        subject->identities[subject->nidentity - 1].type = g_strdup(\"x509dname\");\n        subject->identities[subject->nidentity - 1].name = g_strdup(x509dname);\n    }\n    if (saslUsername) {\n        if (VIR_REALLOC_N(subject->identities, subject->nidentity+1) < 0)\n            goto error;\n        subject->nidentity++;\n        subject->identities[subject->nidentity - 1].type = g_strdup(\"saslUsername\");\n        subject->identities[subject->nidentity - 1].name = g_strdup(saslUsername);\n    }\n\n    virObjectLock(vm);\n    event = virDomainEventGraphicsNewFromObj(vm, phase, localAddr, remoteAddr, authScheme, subject);\n    virObjectUnlock(vm);\n\n    virObjectEventStateQueue(driver->domainEventState, event);\n\n    return 0;\n\n error:\n    VIR_FREE(localAddr->service);\n    VIR_FREE(localAddr->node);\n    VIR_FREE(localAddr);\n\n    VIR_FREE(remoteAddr->service);\n    VIR_FREE(remoteAddr->node);\n    VIR_FREE(remoteAddr);\n\n    for (i = 0; i < subject->nidentity; i++) {\n        VIR_FREE(subject->identities[i].type);\n        VIR_FREE(subject->identities[i].name);\n    }\n    VIR_FREE(subject->identities);\n    VIR_FREE(subject);\n\n    return -1;\n}\n\nstatic int\nqemuProcessHandleTrayChange(qemuMonitorPtr mon G_GNUC_UNUSED,\n                            virDomainObjPtr vm,\n                            const char *devAlias,\n                            const char *devid,\n                            int reason,\n                            void *opaque)\n{\n    virQEMUDriverPtr driver = opaque;\n    virObjectEventPtr event = NULL;\n    virDomainDiskDefPtr disk;\n    g_autoptr(virQEMUDriverConfig) cfg = virQEMUDriverGetConfig(driver);\n\n    virObjectLock(vm);\n    disk = qemuProcessFindDomainDiskByAliasOrQOM(vm, devAlias, devid);\n\n    if (disk) {\n        event = virDomainEventTrayChangeNewFromObj(vm, disk->info.alias, reason);\n        /* Update disk tray status */\n        if (reason == VIR_DOMAIN_EVENT_TRAY_CHANGE_OPEN)\n            disk->tray_status = VIR_DOMAIN_DISK_TRAY_OPEN;\n        else if (reason == VIR_DOMAIN_EVENT_TRAY_CHANGE_CLOSE)\n            disk->tray_status = VIR_DOMAIN_DISK_TRAY_CLOSED;\n\n        if (virDomainObjSave(vm, driver->xmlopt, cfg->stateDir) < 0) {\n            VIR_WARN(\"Unable to save status on vm %s after tray moved event\",\n                     vm->def->name);\n        }\n\n        virDomainObjBroadcast(vm);\n    }\n\n    virObjectUnlock(vm);\n    virObjectEventStateQueue(driver->domainEventState, event);\n    return 0;\n}\n\nstatic int\nqemuProcessHandlePMWakeup(qemuMonitorPtr mon G_GNUC_UNUSED,\n                          virDomainObjPtr vm,\n                          void *opaque)\n{\n    virQEMUDriverPtr driver = opaque;\n    virObjectEventPtr event = NULL;\n    virObjectEventPtr lifecycleEvent = NULL;\n    g_autoptr(virQEMUDriverConfig) cfg = virQEMUDriverGetConfig(driver);\n\n    virObjectLock(vm);\n    event = virDomainEventPMWakeupNewFromObj(vm);\n\n    /* Don't set domain status back to running if it wasn't paused\n     * from guest side, otherwise it can just cause confusion.\n     */\n    if (virDomainObjGetState(vm, NULL) == VIR_DOMAIN_PMSUSPENDED) {\n        VIR_DEBUG(\"Transitioned guest %s from pmsuspended to running \"\n                  \"state due to QMP wakeup event\", vm->def->name);\n\n        virDomainObjSetState(vm, VIR_DOMAIN_RUNNING,\n                             VIR_DOMAIN_RUNNING_WAKEUP);\n        lifecycleEvent = virDomainEventLifecycleNewFromObj(vm,\n                                                  VIR_DOMAIN_EVENT_STARTED,\n                                                  VIR_DOMAIN_EVENT_STARTED_WAKEUP);\n\n        if (virDomainObjSave(vm, driver->xmlopt, cfg->stateDir) < 0) {\n            VIR_WARN(\"Unable to save status on vm %s after wakeup event\",\n                     vm->def->name);\n        }\n    }\n\n    virObjectUnlock(vm);\n    virObjectEventStateQueue(driver->domainEventState, event);\n    virObjectEventStateQueue(driver->domainEventState, lifecycleEvent);\n    return 0;\n}\n\nstatic int\nqemuProcessHandlePMSuspend(qemuMonitorPtr mon G_GNUC_UNUSED,\n                           virDomainObjPtr vm,\n                           void *opaque)\n{\n    virQEMUDriverPtr driver = opaque;\n    virObjectEventPtr event = NULL;\n    virObjectEventPtr lifecycleEvent = NULL;\n    g_autoptr(virQEMUDriverConfig) cfg = virQEMUDriverGetConfig(driver);\n\n    virObjectLock(vm);\n    event = virDomainEventPMSuspendNewFromObj(vm);\n\n    if (virDomainObjGetState(vm, NULL) == VIR_DOMAIN_RUNNING) {\n        qemuDomainObjPrivatePtr priv = vm->privateData;\n        VIR_DEBUG(\"Transitioned guest %s to pmsuspended state due to \"\n                  \"QMP suspend event\", vm->def->name);\n\n        virDomainObjSetState(vm, VIR_DOMAIN_PMSUSPENDED,\n                             VIR_DOMAIN_PMSUSPENDED_UNKNOWN);\n        lifecycleEvent =\n            virDomainEventLifecycleNewFromObj(vm,\n                                     VIR_DOMAIN_EVENT_PMSUSPENDED,\n                                     VIR_DOMAIN_EVENT_PMSUSPENDED_MEMORY);\n\n        if (virDomainObjSave(vm, driver->xmlopt, cfg->stateDir) < 0) {\n            VIR_WARN(\"Unable to save status on vm %s after suspend event\",\n                     vm->def->name);\n        }\n\n        if (priv->agent)\n            qemuAgentNotifyEvent(priv->agent, QEMU_AGENT_EVENT_SUSPEND);\n    }\n\n    virObjectUnlock(vm);\n\n    virObjectEventStateQueue(driver->domainEventState, event);\n    virObjectEventStateQueue(driver->domainEventState, lifecycleEvent);\n    return 0;\n}\n\nstatic int\nqemuProcessHandleBalloonChange(qemuMonitorPtr mon G_GNUC_UNUSED,\n                               virDomainObjPtr vm,\n                               unsigned long long actual,\n                               void *opaque)\n{\n    virQEMUDriverPtr driver = opaque;\n    virObjectEventPtr event = NULL;\n    g_autoptr(virQEMUDriverConfig) cfg = virQEMUDriverGetConfig(driver);\n\n    virObjectLock(vm);\n    event = virDomainEventBalloonChangeNewFromObj(vm, actual);\n\n    VIR_DEBUG(\"Updating balloon from %lld to %lld kb\",\n              vm->def->mem.cur_balloon, actual);\n    vm->def->mem.cur_balloon = actual;\n\n    if (virDomainObjSave(vm, driver->xmlopt, cfg->stateDir) < 0)\n        VIR_WARN(\"unable to save domain status with balloon change\");\n\n    virObjectUnlock(vm);\n\n    virObjectEventStateQueue(driver->domainEventState, event);\n    return 0;\n}\n\nstatic int\nqemuProcessHandlePMSuspendDisk(qemuMonitorPtr mon G_GNUC_UNUSED,\n                               virDomainObjPtr vm,\n                               void *opaque)\n{\n    virQEMUDriverPtr driver = opaque;\n    virObjectEventPtr event = NULL;\n    virObjectEventPtr lifecycleEvent = NULL;\n    g_autoptr(virQEMUDriverConfig) cfg = virQEMUDriverGetConfig(driver);\n\n    virObjectLock(vm);\n    event = virDomainEventPMSuspendDiskNewFromObj(vm);\n\n    if (virDomainObjGetState(vm, NULL) == VIR_DOMAIN_RUNNING) {\n        qemuDomainObjPrivatePtr priv = vm->privateData;\n        VIR_DEBUG(\"Transitioned guest %s to pmsuspended state due to \"\n                  \"QMP suspend_disk event\", vm->def->name);\n\n        virDomainObjSetState(vm, VIR_DOMAIN_PMSUSPENDED,\n                             VIR_DOMAIN_PMSUSPENDED_UNKNOWN);\n        lifecycleEvent =\n            virDomainEventLifecycleNewFromObj(vm,\n                                     VIR_DOMAIN_EVENT_PMSUSPENDED,\n                                     VIR_DOMAIN_EVENT_PMSUSPENDED_DISK);\n\n        if (virDomainObjSave(vm, driver->xmlopt, cfg->stateDir) < 0) {\n            VIR_WARN(\"Unable to save status on vm %s after suspend event\",\n                     vm->def->name);\n        }\n\n        if (priv->agent)\n            qemuAgentNotifyEvent(priv->agent, QEMU_AGENT_EVENT_SUSPEND);\n    }\n\n    virObjectUnlock(vm);\n\n    virObjectEventStateQueue(driver->domainEventState, event);\n    virObjectEventStateQueue(driver->domainEventState, lifecycleEvent);\n\n    return 0;\n}\n\n\nstatic int\nqemuProcessHandleGuestPanic(qemuMonitorPtr mon G_GNUC_UNUSED,\n                            virDomainObjPtr vm,\n                            qemuMonitorEventPanicInfoPtr info,\n                            void *opaque)\n{\n    virQEMUDriverPtr driver = opaque;\n    struct qemuProcessEvent *processEvent;\n\n    virObjectLock(vm);\n    processEvent = g_new0(struct qemuProcessEvent, 1);\n\n    processEvent->eventType = QEMU_PROCESS_EVENT_GUESTPANIC;\n    processEvent->action = vm->def->onCrash;\n    processEvent->data = info;\n    /* Hold an extra reference because we can't allow 'vm' to be\n     * deleted before handling guest panic event is finished.\n     */\n    processEvent->vm = virObjectRef(vm);\n\n    if (virThreadPoolSendJob(driver->workerPool, 0, processEvent) < 0) {\n        virObjectUnref(vm);\n        qemuProcessEventFree(processEvent);\n    }\n\n    virObjectUnlock(vm);\n\n    return 0;\n}\n\n\nint\nqemuProcessHandleDeviceDeleted(qemuMonitorPtr mon G_GNUC_UNUSED,\n                               virDomainObjPtr vm,\n                               const char *devAlias,\n                               void *opaque)\n{\n    virQEMUDriverPtr driver = opaque;\n    struct qemuProcessEvent *processEvent = NULL;\n    char *data;\n\n    virObjectLock(vm);\n\n    VIR_DEBUG(\"Device %s removed from domain %p %s\",\n              devAlias, vm, vm->def->name);\n\n    if (qemuDomainSignalDeviceRemoval(vm, devAlias,\n                                      QEMU_DOMAIN_UNPLUGGING_DEVICE_STATUS_OK))\n        goto cleanup;\n\n    processEvent = g_new0(struct qemuProcessEvent, 1);\n\n    processEvent->eventType = QEMU_PROCESS_EVENT_DEVICE_DELETED;\n    data = g_strdup(devAlias);\n    processEvent->data = data;\n    processEvent->vm = virObjectRef(vm);\n\n    if (virThreadPoolSendJob(driver->workerPool, 0, processEvent) < 0) {\n        virObjectUnref(vm);\n        goto error;\n    }\n\n cleanup:\n    virObjectUnlock(vm);\n    return 0;\n error:\n    qemuProcessEventFree(processEvent);\n    goto cleanup;\n}\n\n\n/**\n *\n * Meaning of fields reported by the event according to the ACPI standard:\n * @source:\n *  0x00 - 0xff: Notification values, as passed at the request time\n *  0x100: Operating System Shutdown Processing\n *  0x103: Ejection processing\n *  0x200: Insertion processing\n *  other values are reserved\n *\n * @status:\n *   general values\n *     0x00: success\n *     0x01: non-specific failure\n *     0x02: unrecognized notify code\n *     0x03 - 0x7f: reserved\n *     other values are specific to the notification type (see below)\n *\n *   for the 0x100 source the following additional codes are standardized:\n *     0x80: OS Shutdown request denied\n *     0x81: OS Shutdown in progress\n *     0x82: OS Shutdown completed\n *     0x83: OS Graceful shutdown not supported\n *     other higher values are reserved\n *\n *  for the 0x003 (Ejection request) and 0x103 (Ejection processing) source\n *  the following additional codes are standardized:\n *     0x80: Device ejection not supported by OSPM\n *     0x81: Device in use by application\n *     0x82: Device Busy\n *     0x83: Ejection dependency is busy or not supported for ejection by OSPM\n *     0x84: Ejection is in progress (pending)\n *     other higher values are reserved\n *\n *  for the 0x200 source the following additional codes are standardized:\n *     0x80: Device insertion in progress (pending)\n *     0x81: Device driver load failure\n *     0x82: Device insertion not supported by OSPM\n *     0x83-0x8F: Reserved\n *     0x90-0x9F: Insertion failure - Resources Unavailable as described by the\n *                                    following bit encodings:\n *                                    Bit [3]: Bus or Segment Numbers\n *                                    Bit [2]: Interrupts\n *                                    Bit [1]: I/O\n *                                    Bit [0]: Memory\n *     other higher values are reserved\n *\n * Other fields and semantics are specific to the qemu handling of the event.\n *  - @alias may be NULL for successful unplug operations\n *  - @slotType describes the device type a bit more closely, currently the\n *    only known value is 'DIMM'\n *  - @slot describes the specific device\n *\n *  Note that qemu does not emit the event for all the documented sources or\n *  devices.\n */\nstatic int\nqemuProcessHandleAcpiOstInfo(qemuMonitorPtr mon G_GNUC_UNUSED,\n                             virDomainObjPtr vm,\n                             const char *alias,\n                             const char *slotType,\n                             const char *slot,\n                             unsigned int source,\n                             unsigned int status,\n                             void *opaque)\n{\n    virQEMUDriverPtr driver = opaque;\n    virObjectEventPtr event = NULL;\n\n    virObjectLock(vm);\n\n    VIR_DEBUG(\"ACPI OST info for device %s domain %p %s. \"\n              \"slotType='%s' slot='%s' source=%u status=%u\",\n              NULLSTR(alias), vm, vm->def->name, slotType, slot, source, status);\n\n    if (!alias)\n        goto cleanup;\n\n    if (STREQ(slotType, \"DIMM\")) {\n        if ((source == 0x003 || source == 0x103) &&\n            (status == 0x01 || (status >= 0x80 && status <= 0x83))) {\n            qemuDomainSignalDeviceRemoval(vm, alias,\n                                          QEMU_DOMAIN_UNPLUGGING_DEVICE_STATUS_GUEST_REJECTED);\n\n            event = virDomainEventDeviceRemovalFailedNewFromObj(vm, alias);\n        }\n    }\n\n cleanup:\n    virObjectUnlock(vm);\n    virObjectEventStateQueue(driver->domainEventState, event);\n\n    return 0;\n}\n\n\nstatic int\nqemuProcessHandleBlockThreshold(qemuMonitorPtr mon G_GNUC_UNUSED,\n                                virDomainObjPtr vm,\n                                const char *nodename,\n                                unsigned long long threshold,\n                                unsigned long long excess,\n                                void *opaque)\n{\n    qemuDomainObjPrivatePtr priv;\n    virQEMUDriverPtr driver = opaque;\n    virObjectEventPtr eventSource = NULL;\n    virObjectEventPtr eventDevice = NULL;\n    virDomainDiskDefPtr disk;\n    virStorageSourcePtr src;\n    const char *path = NULL;\n\n    virObjectLock(vm);\n\n    priv  = vm->privateData;\n\n    VIR_DEBUG(\"BLOCK_WRITE_THRESHOLD event for block node '%s' in domain %p %s:\"\n              \"threshold '%llu' exceeded by '%llu'\",\n              nodename, vm, vm->def->name, threshold, excess);\n\n    if ((disk = qemuDomainDiskLookupByNodename(vm->def, priv->backup, nodename, &src))) {\n        if (virStorageSourceIsLocalStorage(src))\n            path = src->path;\n\n        if (src == disk->src) {\n            g_autofree char *dev = qemuDomainDiskBackingStoreGetName(disk, 0);\n\n            eventDevice = virDomainEventBlockThresholdNewFromObj(vm, dev, path,\n                                                                 threshold, excess);\n        }\n\n        if (src->id != 0) {\n            g_autofree char *dev = qemuDomainDiskBackingStoreGetName(disk, src->id);\n\n            eventSource = virDomainEventBlockThresholdNewFromObj(vm, dev, path,\n                                                                 threshold, excess);\n        }\n    }\n\n    virObjectUnlock(vm);\n    virObjectEventStateQueue(driver->domainEventState, eventDevice);\n    virObjectEventStateQueue(driver->domainEventState, eventSource);\n\n    return 0;\n}\n\n\nstatic int\nqemuProcessHandleNicRxFilterChanged(qemuMonitorPtr mon G_GNUC_UNUSED,\n                                    virDomainObjPtr vm,\n                                    const char *devAlias,\n                                    void *opaque)\n{\n    virQEMUDriverPtr driver = opaque;\n    struct qemuProcessEvent *processEvent = NULL;\n    char *data;\n\n    virObjectLock(vm);\n\n    VIR_DEBUG(\"Device %s RX Filter changed in domain %p %s\",\n              devAlias, vm, vm->def->name);\n\n    processEvent = g_new0(struct qemuProcessEvent, 1);\n\n    processEvent->eventType = QEMU_PROCESS_EVENT_NIC_RX_FILTER_CHANGED;\n    data = g_strdup(devAlias);\n    processEvent->data = data;\n    processEvent->vm = virObjectRef(vm);\n\n    if (virThreadPoolSendJob(driver->workerPool, 0, processEvent) < 0) {\n        virObjectUnref(vm);\n        goto error;\n    }\n\n cleanup:\n    virObjectUnlock(vm);\n    return 0;\n error:\n    qemuProcessEventFree(processEvent);\n    goto cleanup;\n}\n\n\nstatic int\nqemuProcessHandleSerialChanged(qemuMonitorPtr mon G_GNUC_UNUSED,\n                               virDomainObjPtr vm,\n                               const char *devAlias,\n                               bool connected,\n                               void *opaque)\n{\n    virQEMUDriverPtr driver = opaque;\n    struct qemuProcessEvent *processEvent = NULL;\n    char *data;\n\n    virObjectLock(vm);\n\n    VIR_DEBUG(\"Serial port %s state changed to '%d' in domain %p %s\",\n              devAlias, connected, vm, vm->def->name);\n\n    processEvent = g_new0(struct qemuProcessEvent, 1);\n\n    processEvent->eventType = QEMU_PROCESS_EVENT_SERIAL_CHANGED;\n    data = g_strdup(devAlias);\n    processEvent->data = data;\n    processEvent->action = connected;\n    processEvent->vm = virObjectRef(vm);\n\n    if (virThreadPoolSendJob(driver->workerPool, 0, processEvent) < 0) {\n        virObjectUnref(vm);\n        goto error;\n    }\n\n cleanup:\n    virObjectUnlock(vm);\n    return 0;\n error:\n    qemuProcessEventFree(processEvent);\n    goto cleanup;\n}\n\n\nstatic int\nqemuProcessHandleSpiceMigrated(qemuMonitorPtr mon G_GNUC_UNUSED,\n                               virDomainObjPtr vm,\n                               void *opaque G_GNUC_UNUSED)\n{\n    qemuDomainObjPrivatePtr priv;\n    qemuDomainJobPrivatePtr jobPriv;\n\n    virObjectLock(vm);\n\n    VIR_DEBUG(\"Spice migration completed for domain %p %s\",\n              vm, vm->def->name);\n\n    priv = vm->privateData;\n    jobPriv = priv->job.privateData;\n    if (priv->job.asyncJob != QEMU_ASYNC_JOB_MIGRATION_OUT) {\n        VIR_DEBUG(\"got SPICE_MIGRATE_COMPLETED event without a migration job\");\n        goto cleanup;\n    }\n\n    jobPriv->spiceMigrated = true;\n    virDomainObjBroadcast(vm);\n\n cleanup:\n    virObjectUnlock(vm);\n    return 0;\n}\n\n\nstatic int\nqemuProcessHandleMigrationStatus(qemuMonitorPtr mon G_GNUC_UNUSED,\n                                 virDomainObjPtr vm,\n                                 int status,\n                                 void *opaque)\n{\n    qemuDomainObjPrivatePtr priv;\n    virQEMUDriverPtr driver = opaque;\n    virObjectEventPtr event = NULL;\n    g_autoptr(virQEMUDriverConfig) cfg = virQEMUDriverGetConfig(driver);\n    int reason;\n\n    virObjectLock(vm);\n\n    VIR_DEBUG(\"Migration of domain %p %s changed state to %s\",\n              vm, vm->def->name,\n              qemuMonitorMigrationStatusTypeToString(status));\n\n    priv = vm->privateData;\n    if (priv->job.asyncJob == QEMU_ASYNC_JOB_NONE) {\n        VIR_DEBUG(\"got MIGRATION event without a migration job\");\n        goto cleanup;\n    }\n\n    priv->job.current->stats.mig.status = status;\n    virDomainObjBroadcast(vm);\n\n    if (status == QEMU_MONITOR_MIGRATION_STATUS_POSTCOPY &&\n        priv->job.asyncJob == QEMU_ASYNC_JOB_MIGRATION_OUT &&\n        virDomainObjGetState(vm, &reason) == VIR_DOMAIN_PAUSED &&\n        reason == VIR_DOMAIN_PAUSED_MIGRATION) {\n        VIR_DEBUG(\"Correcting paused state reason for domain %s to %s\",\n                  vm->def->name,\n                  virDomainPausedReasonTypeToString(VIR_DOMAIN_PAUSED_POSTCOPY));\n\n        virDomainObjSetState(vm, VIR_DOMAIN_PAUSED, VIR_DOMAIN_PAUSED_POSTCOPY);\n        event = virDomainEventLifecycleNewFromObj(vm,\n                                                  VIR_DOMAIN_EVENT_SUSPENDED,\n                                                  VIR_DOMAIN_EVENT_SUSPENDED_POSTCOPY);\n\n        if (virDomainObjSave(vm, driver->xmlopt, cfg->stateDir) < 0) {\n            VIR_WARN(\"Unable to save status on vm %s after state change\",\n                     vm->def->name);\n        }\n    }\n\n cleanup:\n    virObjectUnlock(vm);\n    virObjectEventStateQueue(driver->domainEventState, event);\n    return 0;\n}\n\n\nstatic int\nqemuProcessHandleMigrationPass(qemuMonitorPtr mon G_GNUC_UNUSED,\n                               virDomainObjPtr vm,\n                               int pass,\n                               void *opaque)\n{\n    virQEMUDriverPtr driver = opaque;\n    qemuDomainObjPrivatePtr priv;\n\n    virObjectLock(vm);\n\n    VIR_DEBUG(\"Migrating domain %p %s, iteration %d\",\n              vm, vm->def->name, pass);\n\n    priv = vm->privateData;\n    if (priv->job.asyncJob == QEMU_ASYNC_JOB_NONE) {\n        VIR_DEBUG(\"got MIGRATION_PASS event without a migration job\");\n        goto cleanup;\n    }\n\n    virObjectEventStateQueue(driver->domainEventState,\n                         virDomainEventMigrationIterationNewFromObj(vm, pass));\n\n cleanup:\n    virObjectUnlock(vm);\n    return 0;\n}\n\n\nstatic int\nqemuProcessHandleDumpCompleted(qemuMonitorPtr mon G_GNUC_UNUSED,\n                               virDomainObjPtr vm,\n                               int status,\n                               qemuMonitorDumpStatsPtr stats,\n                               const char *error,\n                               void *opaque G_GNUC_UNUSED)\n{\n    qemuDomainObjPrivatePtr priv;\n    qemuDomainJobPrivatePtr jobPriv;\n\n    virObjectLock(vm);\n\n    VIR_DEBUG(\"Dump completed for domain %p %s with stats=%p error='%s'\",\n              vm, vm->def->name, stats, NULLSTR(error));\n\n    priv = vm->privateData;\n    jobPriv = priv->job.privateData;\n    if (priv->job.asyncJob == QEMU_ASYNC_JOB_NONE) {\n        VIR_DEBUG(\"got DUMP_COMPLETED event without a dump_completed job\");\n        goto cleanup;\n    }\n    jobPriv->dumpCompleted = true;\n    priv->job.current->stats.dump = *stats;\n    priv->job.error = g_strdup(error);\n\n    /* Force error if extracting the DUMP_COMPLETED status failed */\n    if (!error && status < 0) {\n        priv->job.error = g_strdup(virGetLastErrorMessage());\n        priv->job.current->stats.dump.status = QEMU_MONITOR_DUMP_STATUS_FAILED;\n    }\n\n    virDomainObjBroadcast(vm);\n\n cleanup:\n    virResetLastError();\n    virObjectUnlock(vm);\n    return 0;\n}\n\n\nstatic int\nqemuProcessHandlePRManagerStatusChanged(qemuMonitorPtr mon G_GNUC_UNUSED,\n                                        virDomainObjPtr vm,\n                                        const char *prManager,\n                                        bool connected,\n                                        void *opaque)\n{\n    virQEMUDriverPtr driver = opaque;\n    qemuDomainObjPrivatePtr priv;\n    struct qemuProcessEvent *processEvent = NULL;\n    const char *managedAlias = qemuDomainGetManagedPRAlias();\n    int ret = -1;\n\n    virObjectLock(vm);\n\n    VIR_DEBUG(\"pr-manager %s status changed for domain %p %s connected=%d\",\n              prManager, vm, vm->def->name, connected);\n\n    if (connected) {\n        /* Connect events are boring. */\n        ret = 0;\n        goto cleanup;\n    }\n    /* Disconnect events are more interesting. */\n\n    if (STRNEQ(prManager, managedAlias)) {\n        VIR_DEBUG(\"pr-manager %s not managed, ignoring event\",\n                  prManager);\n        ret = 0;\n        goto cleanup;\n    }\n\n    priv = vm->privateData;\n    priv->prDaemonRunning = false;\n\n    processEvent = g_new0(struct qemuProcessEvent, 1);\n\n    processEvent->eventType = QEMU_PROCESS_EVENT_PR_DISCONNECT;\n    processEvent->vm = virObjectRef(vm);\n\n    if (virThreadPoolSendJob(driver->workerPool, 0, processEvent) < 0) {\n        qemuProcessEventFree(processEvent);\n        virObjectUnref(vm);\n        goto cleanup;\n    }\n\n    ret = 0;\n cleanup:\n    virObjectUnlock(vm);\n    return ret;\n}\n\n\nstatic int\nqemuProcessHandleRdmaGidStatusChanged(qemuMonitorPtr mon G_GNUC_UNUSED,\n                                      virDomainObjPtr vm,\n                                      const char *netdev,\n                                      bool gid_status,\n                                      unsigned long long subnet_prefix,\n                                      unsigned long long interface_id,\n                                      void *opaque)\n{\n    virQEMUDriverPtr driver = opaque;\n    struct qemuProcessEvent *processEvent = NULL;\n    qemuMonitorRdmaGidStatusPtr info = NULL;\n    int ret = -1;\n\n    virObjectLock(vm);\n\n    VIR_DEBUG(\"netdev=%s,gid_status=%d,subnet_prefix=0x%llx,interface_id=0x%llx\",\n              netdev, gid_status, subnet_prefix, interface_id);\n\n    info = g_new0(qemuMonitorRdmaGidStatus, 1);\n\n    info->netdev = g_strdup(netdev);\n\n    info->gid_status = gid_status;\n    info->subnet_prefix = subnet_prefix;\n    info->interface_id = interface_id;\n\n    processEvent = g_new0(struct qemuProcessEvent, 1);\n\n    processEvent->eventType = QEMU_PROCESS_EVENT_RDMA_GID_STATUS_CHANGED;\n    processEvent->vm = virObjectRef(vm);\n    processEvent->data = g_steal_pointer(&info);\n\n    if (virThreadPoolSendJob(driver->workerPool, 0, processEvent) < 0) {\n        qemuProcessEventFree(processEvent);\n        virObjectUnref(vm);\n        goto cleanup;\n    }\n\n    ret = 0;\n cleanup:\n    qemuMonitorEventRdmaGidStatusFree(info);\n    virObjectUnlock(vm);\n    return ret;\n}\n\n\nstatic int\nqemuProcessHandleGuestCrashloaded(qemuMonitorPtr mon G_GNUC_UNUSED,\n                                  virDomainObjPtr vm,\n                                  void *opaque)\n{\n    virQEMUDriverPtr driver = opaque;\n    struct qemuProcessEvent *processEvent;\n\n    virObjectLock(vm);\n    processEvent = g_new0(struct qemuProcessEvent, 1);\n\n    processEvent->eventType = QEMU_PROCESS_EVENT_GUEST_CRASHLOADED;\n    processEvent->vm = virObjectRef(vm);\n\n    if (virThreadPoolSendJob(driver->workerPool, 0, processEvent) < 0) {\n        virObjectUnref(vm);\n        qemuProcessEventFree(processEvent);\n    }\n\n    virObjectUnlock(vm);\n\n    return 0;\n}\n\n\nstatic int\nqemuProcessHandleMemoryFailure(qemuMonitorPtr mon G_GNUC_UNUSED,\n                               virDomainObjPtr vm,\n                               qemuMonitorEventMemoryFailurePtr mfp,\n                               void *opaque)\n{\n    virQEMUDriverPtr driver = opaque;\n    virObjectEventPtr event = NULL;\n    virDomainMemoryFailureRecipientType recipient;\n    virDomainMemoryFailureActionType action;\n    unsigned int flags = 0;\n\n    switch (mfp->recipient) {\n    case QEMU_MONITOR_MEMORY_FAILURE_RECIPIENT_HYPERVISOR:\n        recipient = VIR_DOMAIN_EVENT_MEMORY_FAILURE_RECIPIENT_HYPERVISOR;\n        break;\n    case QEMU_MONITOR_MEMORY_FAILURE_RECIPIENT_GUEST:\n        recipient = VIR_DOMAIN_EVENT_MEMORY_FAILURE_RECIPIENT_GUEST;\n        break;\n    case QEMU_MONITOR_MEMORY_FAILURE_RECIPIENT_LAST:\n    default:\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"requested unknown memory failure recipient\"));\n        return -1;\n    }\n\n    switch (mfp->action) {\n    case QEMU_MONITOR_MEMORY_FAILURE_ACTION_IGNORE:\n        action = VIR_DOMAIN_EVENT_MEMORY_FAILURE_ACTION_IGNORE;\n        break;\n    case QEMU_MONITOR_MEMORY_FAILURE_ACTION_INJECT:\n        action = VIR_DOMAIN_EVENT_MEMORY_FAILURE_ACTION_INJECT;\n        break;\n    case QEMU_MONITOR_MEMORY_FAILURE_ACTION_FATAL:\n        action = VIR_DOMAIN_EVENT_MEMORY_FAILURE_ACTION_FATAL;\n        break;\n    case QEMU_MONITOR_MEMORY_FAILURE_ACTION_RESET:\n        action = VIR_DOMAIN_EVENT_MEMORY_FAILURE_ACTION_RESET;\n        break;\n    case QEMU_MONITOR_MEMORY_FAILURE_ACTION_LAST:\n    default:\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"requested unknown memory failure action\"));\n        return -1;\n    }\n\n    if (mfp->action_required)\n        flags |= VIR_DOMAIN_MEMORY_FAILURE_ACTION_REQUIRED;\n    if (mfp->recursive)\n        flags |= VIR_DOMAIN_MEMORY_FAILURE_RECURSIVE;\n\n    event = virDomainEventMemoryFailureNewFromObj(vm, recipient, action, flags);\n    virObjectEventStateQueue(driver->domainEventState, event);\n\n    return 0;\n}\n\n\nstatic qemuMonitorCallbacks monitorCallbacks = {\n    .eofNotify = qemuProcessHandleMonitorEOF,\n    .errorNotify = qemuProcessHandleMonitorError,\n    .domainEvent = qemuProcessHandleEvent,\n    .domainShutdown = qemuProcessHandleShutdown,\n    .domainStop = qemuProcessHandleStop,\n    .domainResume = qemuProcessHandleResume,\n    .domainReset = qemuProcessHandleReset,\n    .domainRTCChange = qemuProcessHandleRTCChange,\n    .domainWatchdog = qemuProcessHandleWatchdog,\n    .domainIOError = qemuProcessHandleIOError,\n    .domainGraphics = qemuProcessHandleGraphics,\n    .domainBlockJob = qemuProcessHandleBlockJob,\n    .jobStatusChange = qemuProcessHandleJobStatusChange,\n    .domainTrayChange = qemuProcessHandleTrayChange,\n    .domainPMWakeup = qemuProcessHandlePMWakeup,\n    .domainPMSuspend = qemuProcessHandlePMSuspend,\n    .domainBalloonChange = qemuProcessHandleBalloonChange,\n    .domainPMSuspendDisk = qemuProcessHandlePMSuspendDisk,\n    .domainGuestPanic = qemuProcessHandleGuestPanic,\n    .domainDeviceDeleted = qemuProcessHandleDeviceDeleted,\n    .domainNicRxFilterChanged = qemuProcessHandleNicRxFilterChanged,\n    .domainSerialChange = qemuProcessHandleSerialChanged,\n    .domainSpiceMigrated = qemuProcessHandleSpiceMigrated,\n    .domainMigrationStatus = qemuProcessHandleMigrationStatus,\n    .domainMigrationPass = qemuProcessHandleMigrationPass,\n    .domainAcpiOstInfo = qemuProcessHandleAcpiOstInfo,\n    .domainBlockThreshold = qemuProcessHandleBlockThreshold,\n    .domainDumpCompleted = qemuProcessHandleDumpCompleted,\n    .domainPRManagerStatusChanged = qemuProcessHandlePRManagerStatusChanged,\n    .domainRdmaGidStatusChanged = qemuProcessHandleRdmaGidStatusChanged,\n    .domainGuestCrashloaded = qemuProcessHandleGuestCrashloaded,\n    .domainMemoryFailure = qemuProcessHandleMemoryFailure,\n};\n\nstatic void\nqemuProcessMonitorReportLogError(qemuMonitorPtr mon,\n                                 const char *msg,\n                                 void *opaque);\n\n\nstatic void\nqemuProcessMonitorLogFree(void *opaque)\n{\n    qemuDomainLogContextPtr logCtxt = opaque;\n    g_clear_object(&logCtxt);\n}\n\n\nstatic int\nqemuProcessInitMonitor(virQEMUDriverPtr driver,\n                       virDomainObjPtr vm,\n                       qemuDomainAsyncJob asyncJob)\n{\n    int ret;\n\n    if (qemuDomainObjEnterMonitorAsync(driver, vm, asyncJob) < 0)\n        return -1;\n\n    ret = qemuMonitorSetCapabilities(QEMU_DOMAIN_PRIVATE(vm)->mon);\n\n    if (qemuDomainObjExitMonitor(driver, vm) < 0)\n        ret = -1;\n\n    return ret;\n}\n\n\nstatic int\nqemuConnectMonitor(virQEMUDriverPtr driver, virDomainObjPtr vm, int asyncJob,\n                   bool retry, qemuDomainLogContextPtr logCtxt)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    qemuMonitorPtr mon = NULL;\n    unsigned long long timeout = 0;\n\n    if (qemuSecuritySetDaemonSocketLabel(driver->securityManager, vm->def) < 0) {\n        VIR_ERROR(_(\"Failed to set security context for monitor for %s\"),\n                  vm->def->name);\n        return -1;\n    }\n\n    /* When using hugepages, kernel zeroes them out before\n     * handing them over to qemu. This can be very time\n     * consuming. Therefore, add a second to timeout for each\n     * 1GiB of guest RAM. */\n    timeout = vm->def->mem.total_memory / (1024 * 1024);\n\n    ignore_value(virTimeMillisNow(&priv->monStart));\n\n    mon = qemuMonitorOpen(vm,\n                          priv->monConfig,\n                          retry,\n                          timeout,\n                          virEventThreadGetContext(priv->eventThread),\n                          &monitorCallbacks,\n                          driver);\n\n    if (mon && logCtxt) {\n        g_object_ref(logCtxt);\n        qemuMonitorSetDomainLog(mon,\n                                qemuProcessMonitorReportLogError,\n                                logCtxt,\n                                qemuProcessMonitorLogFree);\n    }\n\n    priv->monStart = 0;\n    priv->mon = mon;\n\n    if (qemuSecurityClearSocketLabel(driver->securityManager, vm->def) < 0) {\n        VIR_ERROR(_(\"Failed to clear security context for monitor for %s\"),\n                  vm->def->name);\n        return -1;\n    }\n\n    if (priv->mon == NULL) {\n        VIR_INFO(\"Failed to connect monitor for %s\", vm->def->name);\n        return -1;\n    }\n\n    if (qemuProcessInitMonitor(driver, vm, asyncJob) < 0)\n        return -1;\n\n    if (qemuMigrationCapsCheck(driver, vm, asyncJob) < 0)\n        return -1;\n\n    return 0;\n}\n\n\n/**\n * qemuProcessReadLog: Read log file of a qemu VM\n * @logCtxt: the domain log context\n * @msg: pointer to buffer to store the read messages in\n * @max: maximum length of the message returned in @msg\n *\n * Reads log of a qemu VM. Skips messages not produced by qemu or irrelevant\n * messages. If @max is not zero, @msg will contain at most @max characters\n * from the end of the log and @msg will start after a new line if possible.\n *\n * Returns 0 on success or -1 on error\n */\nstatic int\nqemuProcessReadLog(qemuDomainLogContextPtr logCtxt,\n                   char **msg,\n                   size_t max)\n{\n    char *buf;\n    ssize_t got;\n    char *eol;\n    char *filter_next;\n    size_t skip;\n\n    if ((got = qemuDomainLogContextRead(logCtxt, &buf)) < 0)\n        return -1;\n\n    /* Filter out debug messages from intermediate libvirt process */\n    filter_next = buf;\n    while ((eol = strchr(filter_next, '\\n'))) {\n        *eol = '\\0';\n        if (virLogProbablyLogMessage(filter_next) ||\n            strstr(filter_next, \"char device redirected to\")) {\n            skip = (eol + 1) - filter_next;\n            memmove(filter_next, eol + 1, buf + got - eol);\n            got -= skip;\n        } else {\n            filter_next = eol + 1;\n            *eol = '\\n';\n        }\n    }\n    filter_next = NULL; /* silence false coverity warning */\n\n    if (got > 0 &&\n        buf[got - 1] == '\\n') {\n        buf[got - 1] = '\\0';\n        got--;\n    }\n\n    if (max > 0 && got > max) {\n        skip = got - max;\n\n        if (buf[skip - 1] != '\\n' &&\n            (eol = strchr(buf + skip, '\\n')) &&\n            !virStringIsEmpty(eol + 1))\n            skip = eol + 1 - buf;\n\n        memmove(buf, buf + skip, got - skip + 1);\n        got -= skip;\n    }\n\n    buf = g_renew(char, buf, got + 1);\n    *msg = buf;\n    return 0;\n}\n\n\nstatic int\nqemuProcessReportLogError(qemuDomainLogContextPtr logCtxt,\n                          const char *msgprefix)\n{\n    g_autofree char *logmsg = NULL;\n    size_t max;\n\n    max = VIR_ERROR_MAX_LENGTH - 1;\n    max -= strlen(msgprefix);\n    /* The length of the formatting string minus two '%s' */\n    max -= strlen(_(\"%s: %s\")) - 4;\n\n    if (qemuProcessReadLog(logCtxt, &logmsg, max) < 0)\n        return -1;\n\n    virResetLastError();\n    if (virStringIsEmpty(logmsg))\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", msgprefix);\n    else\n        virReportError(VIR_ERR_INTERNAL_ERROR, _(\"%s: %s\"), msgprefix, logmsg);\n\n    return 0;\n}\n\n\nstatic void\nqemuProcessMonitorReportLogError(qemuMonitorPtr mon G_GNUC_UNUSED,\n                                 const char *msg,\n                                 void *opaque)\n{\n    qemuDomainLogContextPtr logCtxt = opaque;\n    qemuProcessReportLogError(logCtxt, msg);\n}\n\n\nstatic int\nqemuProcessLookupPTYs(virDomainChrDefPtr *devices,\n                      int count,\n                      GHashTable *info)\n{\n    size_t i;\n\n    for (i = 0; i < count; i++) {\n        g_autofree char *id = NULL;\n        virDomainChrDefPtr chr = devices[i];\n        if (chr->source->type == VIR_DOMAIN_CHR_TYPE_PTY) {\n            qemuMonitorChardevInfoPtr entry;\n\n            id = g_strdup_printf(\"char%s\", chr->info.alias);\n\n            entry = virHashLookup(info, id);\n            if (!entry || !entry->ptyPath) {\n                if (chr->source->data.file.path == NULL) {\n                    /* neither the log output nor 'info chardev' had a\n                     * pty path for this chardev, report an error\n                     */\n                    virReportError(VIR_ERR_INTERNAL_ERROR,\n                                   _(\"no assigned pty for device %s\"), id);\n                    return -1;\n                } else {\n                    /* 'info chardev' had no pty path for this chardev,\n                     * but the log output had, so we're fine\n                     */\n                    continue;\n                }\n            }\n\n            g_free(chr->source->data.file.path);\n            chr->source->data.file.path = g_strdup(entry->ptyPath);\n        }\n    }\n\n    return 0;\n}\n\nstatic int\nqemuProcessFindCharDevicePTYsMonitor(virDomainObjPtr vm,\n                                     GHashTable *info)\n{\n    size_t i = 0;\n\n    if (qemuProcessLookupPTYs(vm->def->serials, vm->def->nserials, info) < 0)\n        return -1;\n\n    if (qemuProcessLookupPTYs(vm->def->parallels, vm->def->nparallels,\n                              info) < 0)\n        return -1;\n\n    if (qemuProcessLookupPTYs(vm->def->channels, vm->def->nchannels, info) < 0)\n        return -1;\n    /* For historical reasons, console[0] can be just an alias\n     * for serial[0]. That's why we need to update it as well. */\n    if (vm->def->nconsoles) {\n        virDomainChrDefPtr chr = vm->def->consoles[0];\n\n        if (vm->def->nserials &&\n            chr->deviceType == VIR_DOMAIN_CHR_DEVICE_TYPE_CONSOLE &&\n            chr->targetType == VIR_DOMAIN_CHR_CONSOLE_TARGET_TYPE_SERIAL) {\n            /* yes, the first console is just an alias for serials[0] */\n            i = 1;\n            if (virDomainChrSourceDefCopy(chr->source,\n                                          ((vm->def->serials[0])->source)) < 0)\n                return -1;\n        }\n    }\n\n    if (qemuProcessLookupPTYs(vm->def->consoles + i, vm->def->nconsoles - i,\n                              info) < 0)\n        return -1;\n\n    return 0;\n}\n\n\nstatic void\nqemuProcessRefreshChannelVirtioState(virQEMUDriverPtr driver,\n                                     virDomainObjPtr vm,\n                                     GHashTable *info,\n                                     int booted)\n{\n    size_t i;\n    int agentReason = VIR_CONNECT_DOMAIN_EVENT_AGENT_LIFECYCLE_REASON_CHANNEL;\n    qemuMonitorChardevInfoPtr entry;\n    virObjectEventPtr event = NULL;\n    g_autofree char *id = NULL;\n\n    if (booted)\n        agentReason = VIR_CONNECT_DOMAIN_EVENT_AGENT_LIFECYCLE_REASON_DOMAIN_STARTED;\n\n    for (i = 0; i < vm->def->nchannels; i++) {\n        virDomainChrDefPtr chr = vm->def->channels[i];\n        if (chr->targetType == VIR_DOMAIN_CHR_CHANNEL_TARGET_TYPE_VIRTIO) {\n\n            VIR_FREE(id);\n            id = g_strdup_printf(\"char%s\", chr->info.alias);\n\n            /* port state not reported */\n            if (!(entry = virHashLookup(info, id)) ||\n                !entry->state)\n                continue;\n\n            if (entry->state != VIR_DOMAIN_CHR_DEVICE_STATE_DEFAULT &&\n                STREQ_NULLABLE(chr->target.name, \"org.qemu.guest_agent.0\") &&\n                (event = virDomainEventAgentLifecycleNewFromObj(vm, entry->state,\n                                                                agentReason)))\n                virObjectEventStateQueue(driver->domainEventState, event);\n\n            chr->state = entry->state;\n        }\n    }\n}\n\n\nint\nqemuRefreshVirtioChannelState(virQEMUDriverPtr driver,\n                              virDomainObjPtr vm,\n                              qemuDomainAsyncJob asyncJob)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    GHashTable *info = NULL;\n    int ret = -1;\n\n    if (qemuDomainObjEnterMonitorAsync(driver, vm, asyncJob) < 0)\n        goto cleanup;\n\n    ret = qemuMonitorGetChardevInfo(priv->mon, &info);\n    if (qemuDomainObjExitMonitor(driver, vm) < 0)\n        ret = -1;\n\n    if (ret < 0)\n        goto cleanup;\n\n    qemuProcessRefreshChannelVirtioState(driver, vm, info, false);\n    ret = 0;\n\n cleanup:\n    virHashFree(info);\n    return ret;\n}\n\n\nstatic int\nqemuProcessRefreshPRManagerState(virDomainObjPtr vm,\n                                 GHashTable *info)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    qemuMonitorPRManagerInfoPtr prManagerInfo;\n    const char *managedAlias = qemuDomainGetManagedPRAlias();\n\n    if (!(prManagerInfo = virHashLookup(info, managedAlias))) {\n        virReportError(VIR_ERR_OPERATION_FAILED,\n                       _(\"missing info on pr-manager %s\"),\n                       managedAlias);\n        return -1;\n    }\n\n    priv->prDaemonRunning = prManagerInfo->connected;\n\n    if (!priv->prDaemonRunning &&\n        qemuProcessStartManagedPRDaemon(vm) < 0)\n        return -1;\n\n    return 0;\n}\n\n\nstatic int\nqemuRefreshPRManagerState(virQEMUDriverPtr driver,\n                          virDomainObjPtr vm)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    GHashTable *info = NULL;\n    int ret = -1;\n\n    if (!virQEMUCapsGet(priv->qemuCaps, QEMU_CAPS_PR_MANAGER_HELPER) ||\n        !qemuDomainDefHasManagedPR(vm))\n        return 0;\n\n    qemuDomainObjEnterMonitor(driver, vm);\n    ret = qemuMonitorGetPRManagerInfo(priv->mon, &info);\n    if (qemuDomainObjExitMonitor(driver, vm) < 0)\n        ret = -1;\n\n    if (ret < 0)\n        goto cleanup;\n\n    ret = qemuProcessRefreshPRManagerState(vm, info);\n\n cleanup:\n    virHashFree(info);\n    return ret;\n}\n\n\nstatic void\nqemuRefreshRTC(virQEMUDriverPtr driver,\n               virDomainObjPtr vm)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    time_t now, then;\n    struct tm thenbits;\n    long localOffset;\n    int rv;\n\n    if (vm->def->clock.offset != VIR_DOMAIN_CLOCK_OFFSET_VARIABLE)\n        return;\n\n    memset(&thenbits, 0, sizeof(thenbits));\n    qemuDomainObjEnterMonitor(driver, vm);\n    now = time(NULL);\n    rv = qemuMonitorGetRTCTime(priv->mon, &thenbits);\n    if (qemuDomainObjExitMonitor(driver, vm) < 0)\n        rv = -1;\n\n    if (rv < 0)\n        return;\n\n    thenbits.tm_isdst = -1;\n    if ((then = mktime(&thenbits)) == (time_t)-1) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Unable to convert time\"));\n        return;\n    }\n\n    /* Thing is, @now is in local TZ but @then in UTC. */\n    if (virTimeLocalOffsetFromUTC(&localOffset) < 0)\n        return;\n\n    vm->def->clock.data.variable.adjustment = then - now + localOffset;\n}\n\nint\nqemuProcessRefreshBalloonState(virQEMUDriverPtr driver,\n                               virDomainObjPtr vm,\n                               int asyncJob)\n{\n    unsigned long long balloon;\n    int rc;\n\n    /* if no ballooning is available, the current size equals to the current\n     * full memory size */\n    if (!virDomainDefHasMemballoon(vm->def)) {\n        vm->def->mem.cur_balloon = virDomainDefGetMemoryTotal(vm->def);\n        return 0;\n    }\n\n    if (qemuDomainObjEnterMonitorAsync(driver, vm, asyncJob) < 0)\n        return -1;\n\n    rc = qemuMonitorGetBalloonInfo(qemuDomainGetMonitor(vm), &balloon);\n    if (qemuDomainObjExitMonitor(driver, vm) < 0 || rc < 0)\n        return -1;\n\n    vm->def->mem.cur_balloon = balloon;\n\n    return 0;\n}\n\n\nstatic int\nqemuProcessWaitForMonitor(virQEMUDriverPtr driver,\n                          virDomainObjPtr vm,\n                          int asyncJob,\n                          qemuDomainLogContextPtr logCtxt)\n{\n    int ret = -1;\n    GHashTable *info = NULL;\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    bool retry = true;\n\n    if (priv->qemuCaps &&\n        virQEMUCapsGet(priv->qemuCaps, QEMU_CAPS_CHARDEV_FD_PASS))\n        retry = false;\n\n    VIR_DEBUG(\"Connect monitor to vm=%p name='%s' retry=%d\",\n              vm, vm->def->name, retry);\n\n    if (qemuConnectMonitor(driver, vm, asyncJob, retry, logCtxt) < 0)\n        goto cleanup;\n\n    /* Try to get the pty path mappings again via the monitor. This is much more\n     * reliable if it's available.\n     * Note that the monitor itself can be on a pty, so we still need to try the\n     * log output method. */\n    if (qemuDomainObjEnterMonitorAsync(driver, vm, asyncJob) < 0)\n        goto cleanup;\n    ret = qemuMonitorGetChardevInfo(priv->mon, &info);\n    VIR_DEBUG(\"qemuMonitorGetChardevInfo returned %i\", ret);\n    if (qemuDomainObjExitMonitor(driver, vm) < 0)\n        ret = -1;\n\n    if (ret == 0) {\n        if ((ret = qemuProcessFindCharDevicePTYsMonitor(vm, info)) < 0)\n            goto cleanup;\n\n         qemuProcessRefreshChannelVirtioState(driver, vm, info, true);\n    }\n\n cleanup:\n    virHashFree(info);\n\n    if (logCtxt && kill(vm->pid, 0) == -1 && errno == ESRCH) {\n        qemuProcessReportLogError(logCtxt,\n                                  _(\"process exited while connecting to monitor\"));\n        ret = -1;\n    }\n\n    return ret;\n}\n\n\nstatic int\nqemuProcessDetectIOThreadPIDs(virQEMUDriverPtr driver,\n                              virDomainObjPtr vm,\n                              int asyncJob)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    qemuMonitorIOThreadInfoPtr *iothreads = NULL;\n    int niothreads = 0;\n    int ret = -1;\n    size_t i;\n\n    if (!virQEMUCapsGet(priv->qemuCaps, QEMU_CAPS_OBJECT_IOTHREAD)) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    /* Get the list of IOThreads from qemu */\n    if (qemuDomainObjEnterMonitorAsync(driver, vm, asyncJob) < 0)\n        goto cleanup;\n    ret = qemuMonitorGetIOThreads(priv->mon, &iothreads, &niothreads);\n    if (qemuDomainObjExitMonitor(driver, vm) < 0)\n        goto cleanup;\n    if (ret < 0)\n        goto cleanup;\n\n    if (niothreads != vm->def->niothreadids) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"got wrong number of IOThread pids from QEMU monitor. \"\n                         \"got %d, wanted %zu\"),\n                       niothreads, vm->def->niothreadids);\n        goto cleanup;\n    }\n\n    /* Nothing to do */\n    if (niothreads == 0) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    for (i = 0; i < niothreads; i++) {\n        virDomainIOThreadIDDefPtr iothrid;\n\n        if (!(iothrid = virDomainIOThreadIDFind(vm->def,\n                                                iothreads[i]->iothread_id))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"iothread %d not found\"),\n                           iothreads[i]->iothread_id);\n            goto cleanup;\n        }\n        iothrid->thread_id = iothreads[i]->thread_id;\n    }\n\n    ret = 0;\n\n cleanup:\n    if (iothreads) {\n        for (i = 0; i < niothreads; i++)\n            VIR_FREE(iothreads[i]);\n        VIR_FREE(iothreads);\n    }\n    return ret;\n}\n\n\nstatic int\nqemuProcessGetAllCpuAffinity(virBitmapPtr *cpumapRet)\n{\n    *cpumapRet = NULL;\n\n    if (!virHostCPUHasBitmap())\n        return 0;\n\n    if (!(*cpumapRet = virHostCPUGetOnlineBitmap()))\n        return -1;\n\n    return 0;\n}\n\n\n/*\n * To be run between fork/exec of QEMU only\n */\n#if defined(WITH_SCHED_GETAFFINITY) || defined(WITH_BSD_CPU_AFFINITY)\nstatic int\nqemuProcessInitCpuAffinity(virDomainObjPtr vm)\n{\n    bool settingAll = false;\n    g_autoptr(virBitmap) cpumapToSet = NULL;\n    virDomainNumatuneMemMode mem_mode;\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n\n    if (!vm->pid) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Cannot setup CPU affinity until process is started\"));\n        return -1;\n    }\n\n    /* Here is the deal, we can't set cpuset.mems before qemu is\n     * started as it clashes with KVM allocation. Therefore, we\n     * used to let qemu allocate its memory anywhere as we would\n     * then move the memory to desired NUMA node via CGroups.\n     * However, that might not be always possible because qemu\n     * might lock some parts of its memory (e.g. due to VFIO).\n     * Even if it possible, memory has to be copied between NUMA\n     * nodes which is suboptimal.\n     * Solution is to set affinity that matches the best what we\n     * would have set in CGroups and then fix it later, once qemu\n     * is already running. */\n    if (virDomainNumaGetNodeCount(vm->def->numa) <= 1 &&\n        virDomainNumatuneGetMode(vm->def->numa, -1, &mem_mode) == 0 &&\n        mem_mode == VIR_DOMAIN_NUMATUNE_MEM_STRICT) {\n        virBitmapPtr nodeset = NULL;\n\n        if (virDomainNumatuneMaybeGetNodeset(vm->def->numa,\n                                             priv->autoNodeset,\n                                             &nodeset,\n                                             -1) < 0)\n            return -1;\n\n        if (virNumaNodesetToCPUset(nodeset, &cpumapToSet) < 0)\n            return -1;\n    } else if (vm->def->cputune.emulatorpin) {\n        cpumapToSet = virBitmapNewCopy(vm->def->cputune.emulatorpin);\n    } else {\n        settingAll = true;\n        if (qemuProcessGetAllCpuAffinity(&cpumapToSet) < 0)\n            return -1;\n    }\n\n    /*\n     * We only want to error out if we failed to set the affinity to\n     * user-requested mapping.  If we are just trying to reset the affinity\n     * to all CPUs and this fails it can only be an issue if:\n     *  1) libvirtd does not have CAP_SYS_NICE\n     *  2) libvirtd does not run on all CPUs\n     *\n     * This scenario can easily occur when libvirtd is run inside a\n     * container with restrictive permissions and CPU pinning.\n     *\n     * See also: https://bugzilla.redhat.com/1819801#c2\n     */\n    if (cpumapToSet &&\n        virProcessSetAffinity(vm->pid, cpumapToSet, settingAll) < 0) {\n        return -1;\n    }\n\n    return 0;\n}\n#else /* !defined(WITH_SCHED_GETAFFINITY) && !defined(WITH_BSD_CPU_AFFINITY) */\nstatic int\nqemuProcessInitCpuAffinity(virDomainObjPtr vm G_GNUC_UNUSED)\n{\n    return 0;\n}\n#endif /* !defined(WITH_SCHED_GETAFFINITY) && !defined(WITH_BSD_CPU_AFFINITY) */\n\n/* set link states to down on interfaces at qemu start */\nstatic int\nqemuProcessSetLinkStates(virQEMUDriverPtr driver,\n                         virDomainObjPtr vm,\n                         qemuDomainAsyncJob asyncJob)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    virDomainDefPtr def = vm->def;\n    size_t i;\n    int ret = -1;\n    int rv;\n\n    if (qemuDomainObjEnterMonitorAsync(driver, vm, asyncJob) < 0)\n        return -1;\n\n    for (i = 0; i < def->nnets; i++) {\n        if (def->nets[i]->linkstate == VIR_DOMAIN_NET_INTERFACE_LINK_STATE_DOWN) {\n            if (!def->nets[i]->info.alias) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"missing alias for network device\"));\n                goto cleanup;\n            }\n\n            VIR_DEBUG(\"Setting link state: %s\", def->nets[i]->info.alias);\n\n            rv = qemuMonitorSetLink(priv->mon,\n                                    def->nets[i]->info.alias,\n                                    VIR_DOMAIN_NET_INTERFACE_LINK_STATE_DOWN);\n            if (rv < 0) {\n                virReportError(VIR_ERR_OPERATION_FAILED,\n                               _(\"Couldn't set link state on interface: %s\"),\n                               def->nets[i]->info.alias);\n                goto cleanup;\n            }\n        }\n    }\n\n    ret = 0;\n\n cleanup:\n    if (qemuDomainObjExitMonitor(driver, vm) < 0)\n        ret = -1;\n    return ret;\n}\n\n\n/**\n * qemuProcessSetupPid:\n *\n * This function sets resource properties (affinity, cgroups,\n * scheduler) for any PID associated with a domain.  It should be used\n * to set up emulator PIDs as well as vCPU and I/O thread pids to\n * ensure they are all handled the same way.\n *\n * Returns 0 on success, -1 on error.\n */\nstatic int\nqemuProcessSetupPid(virDomainObjPtr vm,\n                    pid_t pid,\n                    virCgroupThreadName nameval,\n                    int id,\n                    virBitmapPtr cpumask,\n                    unsigned long long period,\n                    long long quota,\n                    virDomainThreadSchedParamPtr sched)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    virDomainNumatuneMemMode mem_mode;\n    virCgroupPtr cgroup = NULL;\n    virBitmapPtr use_cpumask = NULL;\n    virBitmapPtr affinity_cpumask = NULL;\n    g_autoptr(virBitmap) hostcpumap = NULL;\n    g_autofree char *mem_mask = NULL;\n    int ret = -1;\n\n    if ((period || quota) &&\n        !virCgroupHasController(priv->cgroup, VIR_CGROUP_CONTROLLER_CPU)) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"cgroup cpu is required for scheduler tuning\"));\n        goto cleanup;\n    }\n\n    /* Infer which cpumask shall be used. */\n    if (cpumask) {\n        use_cpumask = cpumask;\n    } else if (vm->def->placement_mode == VIR_DOMAIN_CPU_PLACEMENT_MODE_AUTO) {\n        use_cpumask = priv->autoCpuset;\n    } else if (vm->def->cpumask) {\n        use_cpumask = vm->def->cpumask;\n    } else {\n        /* You may think this is redundant, but we can't assume libvirtd\n         * itself is running on all pCPUs, so we need to explicitly set\n         * the spawned QEMU instance to all pCPUs if no map is given in\n         * its config file */\n        if (qemuProcessGetAllCpuAffinity(&hostcpumap) < 0)\n            goto cleanup;\n        affinity_cpumask = hostcpumap;\n    }\n\n    /*\n     * If CPU cgroup controller is not initialized here, then we need\n     * neither period nor quota settings.  And if CPUSET controller is\n     * not initialized either, then there's nothing to do anyway.\n     */\n    if (virCgroupHasController(priv->cgroup, VIR_CGROUP_CONTROLLER_CPU) ||\n        virCgroupHasController(priv->cgroup, VIR_CGROUP_CONTROLLER_CPUSET)) {\n\n        if (virDomainNumatuneGetMode(vm->def->numa, -1, &mem_mode) == 0 &&\n            mem_mode == VIR_DOMAIN_NUMATUNE_MEM_STRICT &&\n            virDomainNumatuneMaybeFormatNodeset(vm->def->numa,\n                                                priv->autoNodeset,\n                                                &mem_mask, -1) < 0)\n            goto cleanup;\n\n        if (virCgroupNewThread(priv->cgroup, nameval, id, true, &cgroup) < 0)\n            goto cleanup;\n\n        if (virCgroupHasController(priv->cgroup, VIR_CGROUP_CONTROLLER_CPUSET)) {\n            if (use_cpumask &&\n                qemuSetupCgroupCpusetCpus(cgroup, use_cpumask) < 0)\n                goto cleanup;\n\n            if (mem_mask && virCgroupSetCpusetMems(cgroup, mem_mask) < 0)\n                goto cleanup;\n\n        }\n\n        if ((period || quota) &&\n            qemuSetupCgroupVcpuBW(cgroup, period, quota) < 0)\n            goto cleanup;\n\n        /* Move the thread to the sub dir */\n        if (virCgroupAddThread(cgroup, pid) < 0)\n            goto cleanup;\n\n    }\n\n    if (!affinity_cpumask)\n        affinity_cpumask = use_cpumask;\n\n    /* Setup legacy affinity.\n     *\n     * We only want to error out if we failed to set the affinity to\n     * user-requested mapping.  If we are just trying to reset the affinity\n     * to all CPUs and this fails it can only be an issue if:\n     *  1) libvirtd does not have CAP_SYS_NICE\n     *  2) libvirtd does not run on all CPUs\n     *\n     * This scenario can easily occur when libvirtd is run inside a\n     * container with restrictive permissions and CPU pinning.\n     *\n     * See also: https://bugzilla.redhat.com/1819801#c2\n     */\n    if (affinity_cpumask &&\n        virProcessSetAffinity(pid, affinity_cpumask,\n                              affinity_cpumask == hostcpumap) < 0) {\n        goto cleanup;\n    }\n\n    /* Set scheduler type and priority, but not for the main thread. */\n    if (sched &&\n        nameval != VIR_CGROUP_THREAD_EMULATOR &&\n        virProcessSetScheduler(pid, sched->policy, sched->priority) < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    if (cgroup) {\n        if (ret < 0)\n            virCgroupRemove(cgroup);\n        virCgroupFree(cgroup);\n    }\n\n    return ret;\n}\n\n\nstatic int\nqemuProcessSetupEmulator(virDomainObjPtr vm)\n{\n    return qemuProcessSetupPid(vm, vm->pid, VIR_CGROUP_THREAD_EMULATOR,\n                               0, vm->def->cputune.emulatorpin,\n                               vm->def->cputune.emulator_period,\n                               vm->def->cputune.emulator_quota,\n                               vm->def->cputune.emulatorsched);\n}\n\n\nstatic int\nqemuProcessResctrlCreate(virQEMUDriverPtr driver,\n                         virDomainObjPtr vm)\n{\n    size_t i = 0;\n    g_autoptr(virCaps) caps = NULL;\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n\n    if (!vm->def->nresctrls)\n        return 0;\n\n    /* Force capability refresh since resctrl info can change\n     * XXX: move cache info into virresctrl so caps are not needed */\n    caps = virQEMUDriverGetCapabilities(driver, true);\n    if (!caps)\n        return -1;\n\n    for (i = 0; i < vm->def->nresctrls; i++) {\n        size_t j = 0;\n        if (virResctrlAllocCreate(caps->host.resctrl,\n                                  vm->def->resctrls[i]->alloc,\n                                  priv->machineName) < 0)\n            return -1;\n\n        for (j = 0; j < vm->def->resctrls[i]->nmonitors; j++) {\n            virDomainResctrlMonDefPtr mon = NULL;\n\n            mon = vm->def->resctrls[i]->monitors[j];\n            if (virResctrlMonitorCreate(mon->instance,\n                                        priv->machineName) < 0)\n                return -1;\n        }\n    }\n\n    return 0;\n}\n\n\nstatic char *\nqemuProcessBuildPRHelperPidfilePath(virDomainObjPtr vm)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    const char *prdAlias = qemuDomainGetManagedPRAlias();\n\n    return virPidFileBuildPath(priv->libDir, prdAlias);\n}\n\n\nvoid\nqemuProcessKillManagedPRDaemon(virDomainObjPtr vm)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    virErrorPtr orig_err;\n    g_autofree char *pidfile = NULL;\n\n    if (!(pidfile = qemuProcessBuildPRHelperPidfilePath(vm))) {\n        VIR_WARN(\"Unable to construct pr-helper pidfile path\");\n        return;\n    }\n\n    virErrorPreserveLast(&orig_err);\n    if (virPidFileForceCleanupPath(pidfile) < 0) {\n        VIR_WARN(\"Unable to kill pr-helper process\");\n    } else {\n        priv->prDaemonRunning = false;\n    }\n    virErrorRestore(&orig_err);\n}\n\n\nstatic int\nqemuProcessStartPRDaemonHook(void *opaque)\n{\n    virDomainObjPtr vm = opaque;\n    size_t i, nfds = 0;\n    g_autofree int *fds = NULL;\n    int ret = -1;\n\n    if (qemuDomainNamespaceEnabled(vm, QEMU_DOMAIN_NS_MOUNT)) {\n        if (virProcessGetNamespaces(vm->pid, &nfds, &fds) < 0)\n            return ret;\n\n        if (nfds > 0 &&\n            virProcessSetNamespaces(nfds, fds) < 0)\n            goto cleanup;\n    }\n\n    ret = 0;\n cleanup:\n    for (i = 0; i < nfds; i++)\n        VIR_FORCE_CLOSE(fds[i]);\n    return ret;\n}\n\n\nint\nqemuProcessStartManagedPRDaemon(virDomainObjPtr vm)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    virQEMUDriverPtr driver = priv->driver;\n    g_autoptr(virQEMUDriverConfig) cfg = NULL;\n    int errfd = -1;\n    g_autofree char *pidfile = NULL;\n    g_autofree char *socketPath = NULL;\n    pid_t cpid = -1;\n    g_autoptr(virCommand) cmd = NULL;\n    virTimeBackOffVar timebackoff;\n    const unsigned long long timeout = 500000; /* ms */\n    int ret = -1;\n\n    cfg = virQEMUDriverGetConfig(driver);\n\n    if (!virFileIsExecutable(cfg->prHelperName)) {\n        virReportSystemError(errno, _(\"'%s' is not a suitable pr helper\"),\n                             cfg->prHelperName);\n        goto cleanup;\n    }\n\n    if (!(pidfile = qemuProcessBuildPRHelperPidfilePath(vm)))\n        goto cleanup;\n\n    if (!(socketPath = qemuDomainGetManagedPRSocketPath(priv)))\n        goto cleanup;\n\n    /* Remove stale socket */\n    if (unlink(socketPath) < 0 &&\n        errno != ENOENT) {\n        virReportSystemError(errno,\n                             _(\"Unable to remove stale socket path: %s\"),\n                             socketPath);\n        goto cleanup;\n    }\n\n    if (!(cmd = virCommandNewArgList(cfg->prHelperName,\n                                     \"-k\", socketPath,\n                                     NULL)))\n        goto cleanup;\n\n    virCommandDaemonize(cmd);\n    virCommandSetPidFile(cmd, pidfile);\n    virCommandSetErrorFD(cmd, &errfd);\n\n    /* Place the process into the same namespace and cgroup as\n     * qemu (so that it shares the same view of the system). */\n    virCommandSetPreExecHook(cmd, qemuProcessStartPRDaemonHook, vm);\n\n    if (virCommandRun(cmd, NULL) < 0)\n        goto cleanup;\n\n    if (virPidFileReadPath(pidfile, &cpid) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"pr helper %s didn't show up\"),\n                       cfg->prHelperName);\n        goto cleanup;\n    }\n\n    if (virTimeBackOffStart(&timebackoff, 1, timeout) < 0)\n        goto cleanup;\n    while (virTimeBackOffWait(&timebackoff)) {\n        char errbuf[1024] = { 0 };\n\n        if (virFileExists(socketPath))\n            break;\n\n        if (virProcessKill(cpid, 0) == 0)\n            continue;\n\n        if (saferead(errfd, errbuf, sizeof(errbuf) - 1) < 0) {\n            virReportSystemError(errno,\n                                 _(\"pr helper %s died unexpectedly\"),\n                                 cfg->prHelperName);\n        } else {\n            virReportError(VIR_ERR_OPERATION_FAILED,\n                           _(\"pr helper died and reported: %s\"), errbuf);\n        }\n        goto cleanup;\n    }\n\n    if (!virFileExists(socketPath)) {\n        virReportError(VIR_ERR_OPERATION_TIMEOUT, \"%s\",\n                       _(\"pr helper socked did not show up\"));\n        goto cleanup;\n    }\n\n    if (priv->cgroup &&\n        virCgroupAddMachineProcess(priv->cgroup, cpid) < 0)\n        goto cleanup;\n\n    if (qemuSecurityDomainSetPathLabel(driver, vm, socketPath, true) < 0)\n        goto cleanup;\n\n    priv->prDaemonRunning = true;\n    ret = 0;\n cleanup:\n    if (ret < 0) {\n        virCommandAbort(cmd);\n        if (cpid >= 0)\n            virProcessKillPainfully(cpid, true);\n        if (pidfile)\n            unlink(pidfile);\n    }\n    VIR_FORCE_CLOSE(errfd);\n    return ret;\n}\n\n\nstatic int\nqemuProcessInitPasswords(virQEMUDriverPtr driver,\n                         virDomainObjPtr vm,\n                         int asyncJob)\n{\n    int ret = 0;\n    g_autoptr(virQEMUDriverConfig) cfg = virQEMUDriverGetConfig(driver);\n    size_t i;\n\n    for (i = 0; i < vm->def->ngraphics; ++i) {\n        virDomainGraphicsDefPtr graphics = vm->def->graphics[i];\n        if (graphics->type == VIR_DOMAIN_GRAPHICS_TYPE_VNC) {\n            ret = qemuDomainChangeGraphicsPasswords(driver, vm,\n                                                    VIR_DOMAIN_GRAPHICS_TYPE_VNC,\n                                                    &graphics->data.vnc.auth,\n                                                    cfg->vncPassword,\n                                                    asyncJob);\n        } else if (graphics->type == VIR_DOMAIN_GRAPHICS_TYPE_SPICE) {\n            ret = qemuDomainChangeGraphicsPasswords(driver, vm,\n                                                    VIR_DOMAIN_GRAPHICS_TYPE_SPICE,\n                                                    &graphics->data.spice.auth,\n                                                    cfg->spicePassword,\n                                                    asyncJob);\n        }\n\n        if (ret < 0)\n            return ret;\n    }\n\n    return ret;\n}\n\n\nstatic int\nqemuProcessPrepareChardevDevice(virDomainDefPtr def G_GNUC_UNUSED,\n                                virDomainChrDefPtr dev,\n                                void *opaque G_GNUC_UNUSED)\n{\n    int fd;\n    if (dev->source->type != VIR_DOMAIN_CHR_TYPE_FILE)\n        return 0;\n\n    if ((fd = open(dev->source->data.file.path,\n                   O_CREAT | O_APPEND, S_IRUSR|S_IWUSR)) < 0) {\n        virReportSystemError(errno,\n                             _(\"Unable to pre-create chardev file '%s'\"),\n                             dev->source->data.file.path);\n        return -1;\n    }\n\n    VIR_FORCE_CLOSE(fd);\n\n    return 0;\n}\n\n\nstatic int\nqemuProcessCleanupChardevDevice(virDomainDefPtr def G_GNUC_UNUSED,\n                                virDomainChrDefPtr dev,\n                                void *opaque G_GNUC_UNUSED)\n{\n    if (dev->source->type == VIR_DOMAIN_CHR_TYPE_UNIX &&\n        dev->source->data.nix.listen &&\n        dev->source->data.nix.path)\n        unlink(dev->source->data.nix.path);\n\n    return 0;\n}\n\n\n/**\n * Loads and update video memory size for video devices according to QEMU\n * process as the QEMU will silently update the values that we pass to QEMU\n * through command line.  We need to load these updated values and store them\n * into the status XML.\n *\n * We will fail if for some reason the values cannot be loaded from QEMU because\n * its mandatory to get the correct video memory size to status XML to not break\n * migration.\n */\nstatic int\nqemuProcessUpdateVideoRamSize(virQEMUDriverPtr driver,\n                              virDomainObjPtr vm,\n                              int asyncJob)\n{\n    int ret = -1;\n    ssize_t i;\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    virDomainVideoDefPtr video = NULL;\n    g_autoptr(virQEMUDriverConfig) cfg = NULL;\n\n    if (qemuDomainObjEnterMonitorAsync(driver, vm, asyncJob) < 0)\n        return -1;\n\n    for (i = 0; i < vm->def->nvideos; i++) {\n        video = vm->def->videos[i];\n\n        switch (video->type) {\n        case VIR_DOMAIN_VIDEO_TYPE_VGA:\n            if (virQEMUCapsGet(priv->qemuCaps, QEMU_CAPS_VGA_VGAMEM)) {\n                if (qemuMonitorUpdateVideoMemorySize(priv->mon, video, \"VGA\") < 0)\n                    goto error;\n            }\n            break;\n        case VIR_DOMAIN_VIDEO_TYPE_QXL:\n            if (i == 0) {\n                if (virQEMUCapsGet(priv->qemuCaps, QEMU_CAPS_QXL_VGAMEM) &&\n                    qemuMonitorUpdateVideoMemorySize(priv->mon, video,\n                                                     \"qxl-vga\") < 0)\n                        goto error;\n\n                if (virQEMUCapsGet(priv->qemuCaps, QEMU_CAPS_QXL_VRAM64) &&\n                    qemuMonitorUpdateVideoVram64Size(priv->mon, video,\n                                                     \"qxl-vga\") < 0)\n                    goto error;\n            } else {\n                if (virQEMUCapsGet(priv->qemuCaps, QEMU_CAPS_QXL_VGAMEM) &&\n                    qemuMonitorUpdateVideoMemorySize(priv->mon, video,\n                                                     \"qxl\") < 0)\n                        goto error;\n\n                if (virQEMUCapsGet(priv->qemuCaps, QEMU_CAPS_QXL_VRAM64) &&\n                    qemuMonitorUpdateVideoVram64Size(priv->mon, video,\n                                                     \"qxl\") < 0)\n                        goto error;\n            }\n            break;\n        case VIR_DOMAIN_VIDEO_TYPE_VMVGA:\n            if (virQEMUCapsGet(priv->qemuCaps, QEMU_CAPS_VMWARE_SVGA_VGAMEM)) {\n                if (qemuMonitorUpdateVideoMemorySize(priv->mon, video,\n                                                     \"vmware-svga\") < 0)\n                    goto error;\n            }\n            break;\n        case VIR_DOMAIN_VIDEO_TYPE_CIRRUS:\n        case VIR_DOMAIN_VIDEO_TYPE_XEN:\n        case VIR_DOMAIN_VIDEO_TYPE_VBOX:\n        case VIR_DOMAIN_VIDEO_TYPE_LAST:\n            break;\n        }\n\n    }\n\n    if (qemuDomainObjExitMonitor(driver, vm) < 0)\n        return -1;\n\n    cfg = virQEMUDriverGetConfig(driver);\n    ret = virDomainObjSave(vm, driver->xmlopt, cfg->stateDir);\n\n    return ret;\n\n error:\n    ignore_value(qemuDomainObjExitMonitor(driver, vm));\n    return -1;\n}\n\n\nstruct qemuProcessHookData {\n    virDomainObjPtr vm;\n    virQEMUDriverPtr driver;\n    virQEMUDriverConfigPtr cfg;\n};\n\nstatic int qemuProcessHook(void *data)\n{\n    struct qemuProcessHookData *h = data;\n    qemuDomainObjPrivatePtr priv = h->vm->privateData;\n    int ret = -1;\n    int fd;\n    virBitmapPtr nodeset = NULL;\n    virDomainNumatuneMemMode mode;\n\n    /* This method cannot use any mutexes, which are not\n     * protected across fork()\n     */\n\n    qemuSecurityPostFork(h->driver->securityManager);\n\n    /* Some later calls want pid present */\n    h->vm->pid = getpid();\n\n    VIR_DEBUG(\"Obtaining domain lock\");\n    /*\n     * Since we're going to leak the returned FD to QEMU,\n     * we need to make sure it gets a sensible label.\n     * This mildly sucks, because there could be other\n     * sockets the lock driver opens that we don't want\n     * labelled. So far we're ok though.\n     */\n    if (qemuSecuritySetSocketLabel(h->driver->securityManager, h->vm->def) < 0)\n        goto cleanup;\n    if (virDomainLockProcessStart(h->driver->lockManager,\n                                  h->cfg->uri,\n                                  h->vm,\n                                  /* QEMU is always paused initially */\n                                  true,\n                                  &fd) < 0)\n        goto cleanup;\n    if (qemuSecurityClearSocketLabel(h->driver->securityManager, h->vm->def) < 0)\n        goto cleanup;\n\n    if (qemuDomainUnshareNamespace(h->cfg, h->driver->securityManager, h->vm) < 0)\n        goto cleanup;\n\n    if (virDomainNumatuneGetMode(h->vm->def->numa, -1, &mode) == 0) {\n        if (mode == VIR_DOMAIN_NUMATUNE_MEM_STRICT &&\n            h->cfg->cgroupControllers & (1 << VIR_CGROUP_CONTROLLER_CPUSET) &&\n            virCgroupControllerAvailable(VIR_CGROUP_CONTROLLER_CPUSET)) {\n            /* Use virNuma* API iff necessary. Once set and child is exec()-ed,\n             * there's no way for us to change it. Rely on cgroups (if available\n             * and enabled in the config) rather than virNuma*. */\n            VIR_DEBUG(\"Relying on CGroups for memory binding\");\n        } else {\n            nodeset = virDomainNumatuneGetNodeset(h->vm->def->numa,\n                                                  priv->autoNodeset, -1);\n\n            if (virNumaSetupMemoryPolicy(mode, nodeset) < 0)\n                goto cleanup;\n        }\n    }\n\n    ret = 0;\n\n cleanup:\n    virObjectUnref(h->cfg);\n    VIR_DEBUG(\"Hook complete ret=%d\", ret);\n    return ret;\n}\n\nint\nqemuProcessPrepareMonitorChr(virDomainChrSourceDefPtr monConfig,\n                             const char *domainDir)\n{\n    monConfig->type = VIR_DOMAIN_CHR_TYPE_UNIX;\n    monConfig->data.nix.listen = true;\n\n    monConfig->data.nix.path = g_strdup_printf(\"%s/monitor.sock\", domainDir);\n    return 0;\n}\n\n\n/*\n * Precondition: vm must be locked, and a job must be active.\n * This method will call {Enter,Exit}Monitor\n */\nint\nqemuProcessStartCPUs(virQEMUDriverPtr driver, virDomainObjPtr vm,\n                     virDomainRunningReason reason,\n                     qemuDomainAsyncJob asyncJob)\n{\n    int ret = -1;\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    g_autoptr(virQEMUDriverConfig) cfg = virQEMUDriverGetConfig(driver);\n\n    /* Bring up netdevs before starting CPUs */\n    if (qemuInterfaceStartDevices(vm->def) < 0)\n       return -1;\n\n    VIR_DEBUG(\"Using lock state '%s'\", NULLSTR(priv->lockState));\n    if (virDomainLockProcessResume(driver->lockManager, cfg->uri,\n                                   vm, priv->lockState) < 0) {\n        /* Don't free priv->lockState on error, because we need\n         * to make sure we have state still present if the user\n         * tries to resume again\n         */\n        return -1;\n    }\n    VIR_FREE(priv->lockState);\n\n    priv->runningReason = reason;\n\n    if (qemuDomainObjEnterMonitorAsync(driver, vm, asyncJob) < 0)\n        goto release;\n\n    ret = qemuMonitorStartCPUs(priv->mon);\n    if (qemuDomainObjExitMonitor(driver, vm) < 0)\n        ret = -1;\n\n    if (ret < 0)\n        goto release;\n\n    /* The RESUME event handler will change the domain state with the reason\n     * saved in priv->runningReason and it will also emit corresponding domain\n     * lifecycle event.\n     */\n\n    return ret;\n\n release:\n    priv->runningReason = VIR_DOMAIN_RUNNING_UNKNOWN;\n    if (virDomainLockProcessPause(driver->lockManager, vm, &priv->lockState) < 0)\n        VIR_WARN(\"Unable to release lease on %s\", vm->def->name);\n    VIR_DEBUG(\"Preserving lock state '%s'\", NULLSTR(priv->lockState));\n    return ret;\n}\n\n\nint qemuProcessStopCPUs(virQEMUDriverPtr driver,\n                        virDomainObjPtr vm,\n                        virDomainPausedReason reason,\n                        qemuDomainAsyncJob asyncJob)\n{\n    int ret = -1;\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n\n    VIR_FREE(priv->lockState);\n\n    priv->pausedReason = reason;\n\n    if (qemuDomainObjEnterMonitorAsync(driver, vm, asyncJob) < 0)\n        goto cleanup;\n\n    ret = qemuMonitorStopCPUs(priv->mon);\n    if (qemuDomainObjExitMonitor(driver, vm) < 0)\n        ret = -1;\n\n    if (ret < 0)\n        goto cleanup;\n\n    /* de-activate netdevs after stopping CPUs */\n    ignore_value(qemuInterfaceStopDevices(vm->def));\n\n    if (priv->job.current)\n        ignore_value(virTimeMillisNow(&priv->job.current->stopped));\n\n    /* The STOP event handler will change the domain state with the reason\n     * saved in priv->pausedReason and it will also emit corresponding domain\n     * lifecycle event.\n     */\n\n    if (virDomainLockProcessPause(driver->lockManager, vm, &priv->lockState) < 0)\n        VIR_WARN(\"Unable to release lease on %s\", vm->def->name);\n    VIR_DEBUG(\"Preserving lock state '%s'\", NULLSTR(priv->lockState));\n\n cleanup:\n    if (ret < 0)\n        priv->pausedReason = VIR_DOMAIN_PAUSED_UNKNOWN;\n\n    return ret;\n}\n\n\n\nstatic void\nqemuProcessNotifyNets(virDomainDefPtr def)\n{\n    size_t i;\n    g_autoptr(virConnect) conn = NULL;\n\n    for (i = 0; i < def->nnets; i++) {\n        virDomainNetDefPtr net = def->nets[i];\n        /* keep others from trying to use the macvtap device name, but\n         * don't return error if this happens, since that causes the\n         * domain to be unceremoniously killed, which would be *very*\n         * impolite.\n         */\n        switch (virDomainNetGetActualType(net)) {\n        case VIR_DOMAIN_NET_TYPE_DIRECT:\n            virNetDevReserveName(net->ifname);\n            break;\n        case VIR_DOMAIN_NET_TYPE_BRIDGE:\n        case VIR_DOMAIN_NET_TYPE_NETWORK:\n        case VIR_DOMAIN_NET_TYPE_ETHERNET:\n            virNetDevReserveName(net->ifname);\n            break;\n        case VIR_DOMAIN_NET_TYPE_USER:\n        case VIR_DOMAIN_NET_TYPE_VHOSTUSER:\n        case VIR_DOMAIN_NET_TYPE_SERVER:\n        case VIR_DOMAIN_NET_TYPE_CLIENT:\n        case VIR_DOMAIN_NET_TYPE_MCAST:\n        case VIR_DOMAIN_NET_TYPE_INTERNAL:\n        case VIR_DOMAIN_NET_TYPE_HOSTDEV:\n        case VIR_DOMAIN_NET_TYPE_UDP:\n        case VIR_DOMAIN_NET_TYPE_VDPA:\n        case VIR_DOMAIN_NET_TYPE_LAST:\n            break;\n        }\n\n        if (net->type == VIR_DOMAIN_NET_TYPE_NETWORK && !conn)\n            conn = virGetConnectNetwork();\n\n        virDomainNetNotifyActualDevice(conn, def, net);\n    }\n}\n\n/* Attempt to instantiate the filters. Ignore failures because it's\n * possible that someone deleted a filter binding and the associated\n * filter while the guest was running and we don't want that action\n * to cause failure to keep the guest running during the reconnection\n * processing. Nor do we necessarily want other failures to do the\n * same. We'll just log the error conditions other than of course\n * ignoreExists possibility (e.g. the true flag) */\nstatic void\nqemuProcessFiltersInstantiate(virDomainDefPtr def)\n{\n    size_t i;\n\n    for (i = 0; i < def->nnets; i++) {\n        virDomainNetDefPtr net = def->nets[i];\n        if ((net->filter) && (net->ifname)) {\n            if (virDomainConfNWFilterInstantiate(def->name, def->uuid, net,\n                                                 true) < 0) {\n                VIR_WARN(\"filter '%s' instantiation for '%s' failed '%s'\",\n                         net->filter, net->ifname, virGetLastErrorMessage());\n                virResetLastError();\n            }\n        }\n    }\n}\n\nstatic int\nqemuProcessUpdateState(virQEMUDriverPtr driver, virDomainObjPtr vm)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    virDomainState state;\n    virDomainPausedReason reason;\n    virDomainState newState = VIR_DOMAIN_NOSTATE;\n    int oldReason;\n    int newReason;\n    bool running;\n    g_autofree char *msg = NULL;\n    int ret;\n\n    qemuDomainObjEnterMonitor(driver, vm);\n    ret = qemuMonitorGetStatus(priv->mon, &running, &reason);\n    if (qemuDomainObjExitMonitor(driver, vm) < 0)\n        return -1;\n\n    if (ret < 0)\n        return -1;\n\n    state = virDomainObjGetState(vm, &oldReason);\n\n    if (running &&\n        (state == VIR_DOMAIN_SHUTOFF ||\n         (state == VIR_DOMAIN_PAUSED &&\n          oldReason == VIR_DOMAIN_PAUSED_STARTING_UP))) {\n        newState = VIR_DOMAIN_RUNNING;\n        newReason = VIR_DOMAIN_RUNNING_BOOTED;\n        msg = g_strdup(\"finished booting\");\n    } else if (state == VIR_DOMAIN_PAUSED && running) {\n        newState = VIR_DOMAIN_RUNNING;\n        newReason = VIR_DOMAIN_RUNNING_UNPAUSED;\n        msg = g_strdup(\"was unpaused\");\n    } else if (state == VIR_DOMAIN_RUNNING && !running) {\n        if (reason == VIR_DOMAIN_PAUSED_SHUTTING_DOWN) {\n            newState = VIR_DOMAIN_SHUTDOWN;\n            newReason = VIR_DOMAIN_SHUTDOWN_UNKNOWN;\n            msg = g_strdup(\"shutdown\");\n        } else if (reason == VIR_DOMAIN_PAUSED_CRASHED) {\n            newState = VIR_DOMAIN_CRASHED;\n            newReason = VIR_DOMAIN_CRASHED_PANICKED;\n            msg = g_strdup(\"crashed\");\n        } else {\n            newState = VIR_DOMAIN_PAUSED;\n            newReason = reason;\n            msg = g_strdup_printf(\"was paused (%s)\",\n                                  virDomainPausedReasonTypeToString(reason));\n        }\n    }\n\n    if (newState != VIR_DOMAIN_NOSTATE) {\n        VIR_DEBUG(\"Domain %s %s while its monitor was disconnected;\"\n                  \" changing state to %s (%s)\",\n                  vm->def->name,\n                  NULLSTR(msg),\n                  virDomainStateTypeToString(newState),\n                  virDomainStateReasonToString(newState, newReason));\n        virDomainObjSetState(vm, newState, newReason);\n    }\n\n    return 0;\n}\n\nstatic int\nqemuProcessRecoverMigrationIn(virQEMUDriverPtr driver,\n                              virDomainObjPtr vm,\n                              const qemuDomainJobObj *job,\n                              virDomainState state,\n                              int reason)\n{\n\n    qemuDomainJobPrivatePtr jobPriv = job->privateData;\n    bool postcopy = (state == VIR_DOMAIN_PAUSED &&\n                     reason == VIR_DOMAIN_PAUSED_POSTCOPY_FAILED) ||\n                    (state == VIR_DOMAIN_RUNNING &&\n                     reason == VIR_DOMAIN_RUNNING_POSTCOPY);\n\n    switch ((qemuMigrationJobPhase) job->phase) {\n    case QEMU_MIGRATION_PHASE_NONE:\n    case QEMU_MIGRATION_PHASE_PERFORM2:\n    case QEMU_MIGRATION_PHASE_BEGIN3:\n    case QEMU_MIGRATION_PHASE_PERFORM3:\n    case QEMU_MIGRATION_PHASE_PERFORM3_DONE:\n    case QEMU_MIGRATION_PHASE_CONFIRM3_CANCELLED:\n    case QEMU_MIGRATION_PHASE_CONFIRM3:\n    case QEMU_MIGRATION_PHASE_LAST:\n        /* N/A for incoming migration */\n        break;\n\n    case QEMU_MIGRATION_PHASE_PREPARE:\n        VIR_DEBUG(\"Killing unfinished incoming migration for domain %s\",\n                  vm->def->name);\n        return -1;\n\n    case QEMU_MIGRATION_PHASE_FINISH2:\n        /* source domain is already killed so let's just resume the domain\n         * and hope we are all set */\n        VIR_DEBUG(\"Incoming migration finished, resuming domain %s\",\n                  vm->def->name);\n        if (qemuProcessStartCPUs(driver, vm,\n                                 VIR_DOMAIN_RUNNING_MIGRATED,\n                                 QEMU_ASYNC_JOB_NONE) < 0) {\n            VIR_WARN(\"Could not resume domain %s\", vm->def->name);\n        }\n        break;\n\n    case QEMU_MIGRATION_PHASE_FINISH3:\n        /* migration finished, we started resuming the domain but didn't\n         * confirm success or failure yet; killing it seems safest unless\n         * we already started guest CPUs or we were in post-copy mode */\n        if (postcopy) {\n            qemuMigrationAnyPostcopyFailed(driver, vm);\n        } else if (state != VIR_DOMAIN_RUNNING) {\n            VIR_DEBUG(\"Killing migrated domain %s\", vm->def->name);\n            return -1;\n        }\n        break;\n    }\n\n    qemuMigrationParamsReset(driver, vm, QEMU_ASYNC_JOB_NONE,\n                             jobPriv->migParams, job->apiFlags);\n    return 0;\n}\n\nstatic int\nqemuProcessRecoverMigrationOut(virQEMUDriverPtr driver,\n                               virDomainObjPtr vm,\n                               const qemuDomainJobObj *job,\n                               virDomainState state,\n                               int reason,\n                               unsigned int *stopFlags)\n{\n    qemuDomainJobPrivatePtr jobPriv = job->privateData;\n    bool postcopy = state == VIR_DOMAIN_PAUSED &&\n                    (reason == VIR_DOMAIN_PAUSED_POSTCOPY ||\n                     reason == VIR_DOMAIN_PAUSED_POSTCOPY_FAILED);\n    bool resume = false;\n\n    switch ((qemuMigrationJobPhase) job->phase) {\n    case QEMU_MIGRATION_PHASE_NONE:\n    case QEMU_MIGRATION_PHASE_PREPARE:\n    case QEMU_MIGRATION_PHASE_FINISH2:\n    case QEMU_MIGRATION_PHASE_FINISH3:\n    case QEMU_MIGRATION_PHASE_LAST:\n        /* N/A for outgoing migration */\n        break;\n\n    case QEMU_MIGRATION_PHASE_BEGIN3:\n        /* nothing happened so far, just forget we were about to migrate the\n         * domain */\n        break;\n\n    case QEMU_MIGRATION_PHASE_PERFORM2:\n    case QEMU_MIGRATION_PHASE_PERFORM3:\n        /* migration is still in progress, let's cancel it and resume the\n         * domain; however we can only do that before migration enters\n         * post-copy mode\n         */\n        if (postcopy) {\n            qemuMigrationAnyPostcopyFailed(driver, vm);\n        } else {\n            VIR_DEBUG(\"Cancelling unfinished migration of domain %s\",\n                      vm->def->name);\n            if (qemuMigrationSrcCancel(driver, vm) < 0) {\n                VIR_WARN(\"Could not cancel ongoing migration of domain %s\",\n                         vm->def->name);\n            }\n            resume = true;\n        }\n        break;\n\n    case QEMU_MIGRATION_PHASE_PERFORM3_DONE:\n        /* migration finished but we didn't have a chance to get the result\n         * of Finish3 step; third party needs to check what to do next; in\n         * post-copy mode we can use PAUSED_POSTCOPY_FAILED state for this\n         */\n        if (postcopy)\n            qemuMigrationAnyPostcopyFailed(driver, vm);\n        break;\n\n    case QEMU_MIGRATION_PHASE_CONFIRM3_CANCELLED:\n        /* Finish3 failed, we need to resume the domain, but once we enter\n         * post-copy mode there's no way back, so let's just mark the domain\n         * as broken in that case\n         */\n        if (postcopy) {\n            qemuMigrationAnyPostcopyFailed(driver, vm);\n        } else {\n            VIR_DEBUG(\"Resuming domain %s after failed migration\",\n                      vm->def->name);\n            resume = true;\n        }\n        break;\n\n    case QEMU_MIGRATION_PHASE_CONFIRM3:\n        /* migration completed, we need to kill the domain here */\n        *stopFlags |= VIR_QEMU_PROCESS_STOP_MIGRATED;\n        return -1;\n    }\n\n    if (resume) {\n        /* resume the domain but only if it was paused as a result of\n         * migration\n         */\n        if (state == VIR_DOMAIN_PAUSED &&\n            (reason == VIR_DOMAIN_PAUSED_MIGRATION ||\n             reason == VIR_DOMAIN_PAUSED_UNKNOWN)) {\n            if (qemuProcessStartCPUs(driver, vm,\n                                     VIR_DOMAIN_RUNNING_MIGRATION_CANCELED,\n                                     QEMU_ASYNC_JOB_NONE) < 0) {\n                VIR_WARN(\"Could not resume domain %s\", vm->def->name);\n            }\n        }\n    }\n\n    qemuMigrationParamsReset(driver, vm, QEMU_ASYNC_JOB_NONE,\n                             jobPriv->migParams, job->apiFlags);\n    return 0;\n}\n\nstatic int\nqemuProcessRecoverJob(virQEMUDriverPtr driver,\n                      virDomainObjPtr vm,\n                      const qemuDomainJobObj *job,\n                      unsigned int *stopFlags)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    virDomainState state;\n    int reason;\n    unsigned long long now;\n\n    state = virDomainObjGetState(vm, &reason);\n\n    switch (job->asyncJob) {\n    case QEMU_ASYNC_JOB_MIGRATION_OUT:\n        if (qemuProcessRecoverMigrationOut(driver, vm, job,\n                                           state, reason, stopFlags) < 0)\n            return -1;\n        break;\n\n    case QEMU_ASYNC_JOB_MIGRATION_IN:\n        if (qemuProcessRecoverMigrationIn(driver, vm, job,\n                                          state, reason) < 0)\n            return -1;\n        break;\n\n    case QEMU_ASYNC_JOB_SAVE:\n    case QEMU_ASYNC_JOB_DUMP:\n    case QEMU_ASYNC_JOB_SNAPSHOT:\n        qemuDomainObjEnterMonitor(driver, vm);\n        ignore_value(qemuMonitorMigrateCancel(priv->mon));\n        if (qemuDomainObjExitMonitor(driver, vm) < 0)\n            return -1;\n        /* resume the domain but only if it was paused as a result of\n         * running a migration-to-file operation.  Although we are\n         * recovering an async job, this function is run at startup\n         * and must resume things using sync monitor connections.  */\n         if (state == VIR_DOMAIN_PAUSED &&\n             ((job->asyncJob == QEMU_ASYNC_JOB_DUMP &&\n               reason == VIR_DOMAIN_PAUSED_DUMP) ||\n              (job->asyncJob == QEMU_ASYNC_JOB_SAVE &&\n               reason == VIR_DOMAIN_PAUSED_SAVE) ||\n              (job->asyncJob == QEMU_ASYNC_JOB_SNAPSHOT &&\n               (reason == VIR_DOMAIN_PAUSED_SNAPSHOT ||\n                reason == VIR_DOMAIN_PAUSED_MIGRATION)) ||\n              reason == VIR_DOMAIN_PAUSED_UNKNOWN)) {\n             if (qemuProcessStartCPUs(driver, vm,\n                                      VIR_DOMAIN_RUNNING_SAVE_CANCELED,\n                                      QEMU_ASYNC_JOB_NONE) < 0) {\n                 VIR_WARN(\"Could not resume domain '%s' after migration to file\",\n                          vm->def->name);\n            }\n        }\n        break;\n\n    case QEMU_ASYNC_JOB_START:\n        /* Already handled in VIR_DOMAIN_PAUSED_STARTING_UP check. */\n        break;\n\n    case QEMU_ASYNC_JOB_BACKUP:\n        ignore_value(virTimeMillisNow(&now));\n\n        /* Restore the config of the async job which is not persisted */\n        priv->jobs_queued++;\n        priv->job.asyncJob = QEMU_ASYNC_JOB_BACKUP;\n        priv->job.asyncOwnerAPI = virThreadJobGet();\n        priv->job.asyncStarted = now;\n\n        qemuDomainObjSetAsyncJobMask(vm, (QEMU_JOB_DEFAULT_MASK |\n                                          JOB_MASK(QEMU_JOB_SUSPEND) |\n                                          JOB_MASK(QEMU_JOB_MODIFY)));\n\n        /* We reset the job parameters for backup so that the job will look\n         * active. This is possible because we are able to recover the state\n         * of blockjobs and also the backup job allows all sub-job types */\n        priv->job.current = g_new0(qemuDomainJobInfo, 1);\n        priv->job.current->operation = VIR_DOMAIN_JOB_OPERATION_BACKUP;\n        priv->job.current->statsType = QEMU_DOMAIN_JOB_STATS_TYPE_BACKUP;\n        priv->job.current->status = QEMU_DOMAIN_JOB_STATUS_ACTIVE;\n        priv->job.current->started = now;\n        break;\n\n    case QEMU_ASYNC_JOB_NONE:\n    case QEMU_ASYNC_JOB_LAST:\n        break;\n    }\n\n    if (!virDomainObjIsActive(vm))\n        return -1;\n\n    /* In case any special handling is added for job type that has been ignored\n     * before, QEMU_DOMAIN_TRACK_JOBS (from qemu_domain.h) needs to be updated\n     * for the job to be properly tracked in domain state XML.\n     */\n    switch (job->active) {\n    case QEMU_JOB_QUERY:\n        /* harmless */\n        break;\n\n    case QEMU_JOB_DESTROY:\n        VIR_DEBUG(\"Domain %s should have already been destroyed\",\n                  vm->def->name);\n        return -1;\n\n    case QEMU_JOB_SUSPEND:\n        /* mostly harmless */\n        break;\n\n    case QEMU_JOB_MODIFY:\n        /* XXX depending on the command we may be in an inconsistent state and\n         * we should probably fall back to \"monitor error\" state and refuse to\n         */\n        break;\n\n    case QEMU_JOB_MIGRATION_OP:\n    case QEMU_JOB_ABORT:\n    case QEMU_JOB_ASYNC:\n    case QEMU_JOB_ASYNC_NESTED:\n        /* async job was already handled above */\n    case QEMU_JOB_NONE:\n    case QEMU_JOB_LAST:\n        break;\n    }\n\n    return 0;\n}\n\nstatic int\nqemuProcessUpdateDevices(virQEMUDriverPtr driver,\n                         virDomainObjPtr vm)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    virDomainDeviceDef dev;\n    g_auto(GStrv) old = g_steal_pointer(&priv->qemuDevices);\n    GStrv tmp;\n\n    if (qemuDomainUpdateDeviceList(driver, vm, QEMU_ASYNC_JOB_NONE) < 0)\n        return -1;\n\n    if (!old)\n        return 0;\n\n    for (tmp = old; *tmp; tmp++) {\n        if (!g_strv_contains((const char **) priv->qemuDevices, *tmp) &&\n            virDomainDefFindDevice(vm->def, *tmp, &dev, false) == 0 &&\n            qemuDomainRemoveDevice(driver, vm, &dev))\n            return -1;\n    }\n\n    return 0;\n}\n\nstatic int\nqemuDomainPerfRestart(virDomainObjPtr vm)\n{\n    size_t i;\n    virDomainDefPtr def = vm->def;\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n\n    if (!(priv->perf = virPerfNew()))\n        return -1;\n\n    for (i = 0; i < VIR_PERF_EVENT_LAST; i++) {\n        if (def->perf.events[i] &&\n            def->perf.events[i] == VIR_TRISTATE_BOOL_YES) {\n\n            /* Failure to re-enable the perf event should not be fatal */\n            if (virPerfEventEnable(priv->perf, i, vm->pid) < 0)\n                def->perf.events[i] = VIR_TRISTATE_BOOL_NO;\n        }\n    }\n\n    return 0;\n}\n\n\nstatic void\nqemuProcessReconnectCheckMemAliasOrderMismatch(virDomainObjPtr vm)\n{\n    size_t i;\n    int aliasidx;\n    virDomainDefPtr def = vm->def;\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n\n    if (!virDomainDefHasMemoryHotplug(def) || def->nmems == 0)\n        return;\n\n    for (i = 0; i < def->nmems; i++) {\n        aliasidx = qemuDomainDeviceAliasIndex(&def->mems[i]->info, \"dimm\");\n\n        if (def->mems[i]->info.addr.dimm.slot != aliasidx) {\n            priv->memAliasOrderMismatch = true;\n            break;\n        }\n    }\n}\n\n\nstatic bool\nqemuProcessNeedHugepagesPath(virDomainDefPtr def,\n                             virDomainMemoryDefPtr mem)\n{\n    const long system_pagesize = virGetSystemPageSizeKB();\n    size_t i;\n\n    if (def->mem.source == VIR_DOMAIN_MEMORY_SOURCE_FILE)\n        return true;\n\n    for (i = 0; i < def->mem.nhugepages; i++) {\n        if (def->mem.hugepages[i].size != system_pagesize)\n            return true;\n    }\n\n    for (i = 0; i < def->nmems; i++) {\n        if (def->mems[i]->model == VIR_DOMAIN_MEMORY_MODEL_DIMM &&\n            def->mems[i]->pagesize &&\n            def->mems[i]->pagesize != system_pagesize)\n            return true;\n    }\n\n    if (mem &&\n        mem->model == VIR_DOMAIN_MEMORY_MODEL_DIMM &&\n        mem->pagesize &&\n        mem->pagesize != system_pagesize)\n        return true;\n\n    return false;\n}\n\n\nstatic bool\nqemuProcessNeedMemoryBackingPath(virDomainDefPtr def,\n                                 virDomainMemoryDefPtr mem)\n{\n    size_t i;\n    size_t numaNodes;\n\n    if (def->mem.source == VIR_DOMAIN_MEMORY_SOURCE_FILE ||\n        def->mem.access != VIR_DOMAIN_MEMORY_ACCESS_DEFAULT)\n        return true;\n\n    numaNodes = virDomainNumaGetNodeCount(def->numa);\n    for (i = 0; i < numaNodes; i++) {\n        if (virDomainNumaGetNodeMemoryAccessMode(def->numa, i)\n            != VIR_DOMAIN_MEMORY_ACCESS_DEFAULT)\n            return true;\n    }\n\n    if (mem &&\n        mem->model == VIR_DOMAIN_MEMORY_MODEL_DIMM &&\n        (mem->access != VIR_DOMAIN_MEMORY_ACCESS_DEFAULT ||\n         (mem->targetNode >= 0 &&\n          virDomainNumaGetNodeMemoryAccessMode(def->numa, mem->targetNode)\n          != VIR_DOMAIN_MEMORY_ACCESS_DEFAULT)))\n        return true;\n\n    return false;\n}\n\n\nstatic int\nqemuProcessBuildDestroyMemoryPathsImpl(virQEMUDriverPtr driver,\n                                       virDomainObjPtr vm,\n                                       const char *path,\n                                       bool build)\n{\n    if (build) {\n        if (virFileExists(path))\n            return 0;\n\n        if (virFileMakePathWithMode(path, 0700) < 0) {\n            virReportSystemError(errno,\n                                 _(\"Unable to create %s\"),\n                                 path);\n            return -1;\n        }\n\n        if (qemuSecurityDomainSetPathLabel(driver, vm, path, true) < 0)\n            return -1;\n    } else {\n        if (virFileDeleteTree(path) < 0)\n            return -1;\n    }\n\n    return 0;\n}\n\n\nint\nqemuProcessBuildDestroyMemoryPaths(virQEMUDriverPtr driver,\n                                   virDomainObjPtr vm,\n                                   virDomainMemoryDefPtr mem,\n                                   bool build)\n{\n\n    g_autoptr(virQEMUDriverConfig) cfg = virQEMUDriverGetConfig(driver);\n    size_t i;\n    bool shouldBuildHP = false;\n    bool shouldBuildMB = false;\n\n    if (build) {\n        shouldBuildHP = qemuProcessNeedHugepagesPath(vm->def, mem);\n        shouldBuildMB = qemuProcessNeedMemoryBackingPath(vm->def, mem);\n    }\n\n    if (!build || shouldBuildHP) {\n        for (i = 0; i < cfg->nhugetlbfs; i++) {\n            g_autofree char *path = NULL;\n            path = qemuGetDomainHugepagePath(driver, vm->def, &cfg->hugetlbfs[i]);\n\n            if (!path)\n                return -1;\n\n            if (qemuProcessBuildDestroyMemoryPathsImpl(driver, vm,\n                                                       path, build) < 0)\n                return -1;\n        }\n    }\n\n    if (!build || shouldBuildMB) {\n        g_autofree char *path = NULL;\n        if (qemuGetMemoryBackingDomainPath(driver, vm->def, &path) < 0)\n            return -1;\n\n        if (qemuProcessBuildDestroyMemoryPathsImpl(driver, vm,\n                                                   path, build) < 0)\n            return -1;\n    }\n\n    return 0;\n}\n\n\nint\nqemuProcessDestroyMemoryBackingPath(virQEMUDriverPtr driver,\n                                    virDomainObjPtr vm,\n                                    virDomainMemoryDefPtr mem)\n{\n    g_autofree char *path = NULL;\n\n    if (qemuGetMemoryBackingPath(driver, vm->def, mem->info.alias, &path) < 0)\n        return -1;\n\n    if (unlink(path) < 0 &&\n        errno != ENOENT) {\n        virReportSystemError(errno, _(\"Unable to remove %s\"), path);\n        return -1;\n    }\n\n    return 0;\n}\n\n\nstatic int\nqemuProcessVNCAllocatePorts(virQEMUDriverPtr driver,\n                            virDomainGraphicsDefPtr graphics,\n                            bool allocate)\n{\n    unsigned short port;\n\n    if (!allocate) {\n        if (graphics->data.vnc.autoport)\n            graphics->data.vnc.port = 5900;\n\n        return 0;\n    }\n\n    if (graphics->data.vnc.autoport) {\n        if (virPortAllocatorAcquire(driver->remotePorts, &port) < 0)\n            return -1;\n        graphics->data.vnc.port = port;\n    }\n\n    if (graphics->data.vnc.websocket == -1) {\n        if (virPortAllocatorAcquire(driver->webSocketPorts, &port) < 0)\n            return -1;\n        graphics->data.vnc.websocket = port;\n        graphics->data.vnc.websocketGenerated = true;\n    }\n\n    return 0;\n}\n\nstatic int\nqemuProcessSPICEAllocatePorts(virQEMUDriverPtr driver,\n                              virDomainGraphicsDefPtr graphics,\n                              bool allocate)\n{\n    g_autoptr(virQEMUDriverConfig) cfg = virQEMUDriverGetConfig(driver);\n    unsigned short port = 0;\n    unsigned short tlsPort;\n    size_t i;\n    int defaultMode = graphics->data.spice.defaultMode;\n\n    bool needTLSPort = false;\n    bool needPort = false;\n\n    if (graphics->data.spice.autoport) {\n        /* check if tlsPort or port need allocation */\n        for (i = 0; i < VIR_DOMAIN_GRAPHICS_SPICE_CHANNEL_LAST; i++) {\n            switch (graphics->data.spice.channels[i]) {\n            case VIR_DOMAIN_GRAPHICS_SPICE_CHANNEL_MODE_SECURE:\n                needTLSPort = true;\n                break;\n\n            case VIR_DOMAIN_GRAPHICS_SPICE_CHANNEL_MODE_INSECURE:\n                needPort = true;\n                break;\n\n            case VIR_DOMAIN_GRAPHICS_SPICE_CHANNEL_MODE_ANY:\n                /* default mode will be used */\n                break;\n            }\n        }\n        switch (defaultMode) {\n        case VIR_DOMAIN_GRAPHICS_SPICE_CHANNEL_MODE_SECURE:\n            needTLSPort = true;\n            break;\n\n        case VIR_DOMAIN_GRAPHICS_SPICE_CHANNEL_MODE_INSECURE:\n            needPort = true;\n            break;\n\n        case VIR_DOMAIN_GRAPHICS_SPICE_CHANNEL_MODE_ANY:\n            if (cfg->spiceTLS)\n                needTLSPort = true;\n            needPort = true;\n            break;\n        }\n    }\n\n    if (!allocate) {\n        if (needPort || graphics->data.spice.port == -1)\n            graphics->data.spice.port = 5901;\n\n        if (needTLSPort || graphics->data.spice.tlsPort == -1)\n            graphics->data.spice.tlsPort = 5902;\n\n        return 0;\n    }\n\n    if (needPort || graphics->data.spice.port == -1) {\n        if (virPortAllocatorAcquire(driver->remotePorts, &port) < 0)\n            return -1;\n\n        graphics->data.spice.port = port;\n\n        if (!graphics->data.spice.autoport)\n            graphics->data.spice.portReserved = true;\n    }\n\n    if (needTLSPort || graphics->data.spice.tlsPort == -1) {\n        if (!cfg->spiceTLS) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"Auto allocation of spice TLS port requested \"\n                             \"but spice TLS is disabled in qemu.conf\"));\n            return -1;\n        }\n\n        if (virPortAllocatorAcquire(driver->remotePorts, &tlsPort) < 0)\n            return -1;\n\n        graphics->data.spice.tlsPort = tlsPort;\n\n        if (!graphics->data.spice.autoport)\n            graphics->data.spice.tlsPortReserved = true;\n    }\n\n    return 0;\n}\n\n\nstatic int\nqemuProcessVerifyHypervFeatures(virDomainDefPtr def,\n                                virCPUDataPtr cpu)\n{\n    size_t i;\n    int rc;\n\n    for (i = 0; i < VIR_DOMAIN_HYPERV_LAST; i++) {\n        g_autofree char *cpuFeature = NULL;\n\n        /* always supported string property */\n        if (i == VIR_DOMAIN_HYPERV_VENDOR_ID ||\n            i == VIR_DOMAIN_HYPERV_SPINLOCKS)\n            continue;\n\n        if (def->hyperv_features[i] != VIR_TRISTATE_SWITCH_ON)\n            continue;\n\n        cpuFeature = g_strdup_printf(\"hv-%s\", virDomainHypervTypeToString(i));\n\n        rc = virCPUDataCheckFeature(cpu, cpuFeature);\n\n        if (rc < 0) {\n            return -1;\n        } else if (rc == 1) {\n            if (i == VIR_DOMAIN_HYPERV_STIMER) {\n                if (def->hyperv_stimer_direct != VIR_TRISTATE_SWITCH_ON)\n                    continue;\n\n                rc = virCPUDataCheckFeature(cpu, VIR_CPU_x86_HV_STIMER_DIRECT);\n                if (rc < 0)\n                    return -1;\n                else if (rc == 1)\n                    continue;\n\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                               _(\"host doesn't support hyperv stimer '%s' feature\"),\n                               \"direct\");\n                return -1;\n            }\n            continue;\n        }\n\n        switch ((virDomainHyperv) i) {\n        case VIR_DOMAIN_HYPERV_RELAXED:\n        case VIR_DOMAIN_HYPERV_VAPIC:\n            VIR_WARN(\"host doesn't support hyperv '%s' feature\",\n                     virDomainHypervTypeToString(i));\n            break;\n\n        case VIR_DOMAIN_HYPERV_VPINDEX:\n        case VIR_DOMAIN_HYPERV_RUNTIME:\n        case VIR_DOMAIN_HYPERV_SYNIC:\n        case VIR_DOMAIN_HYPERV_STIMER:\n        case VIR_DOMAIN_HYPERV_RESET:\n        case VIR_DOMAIN_HYPERV_FREQUENCIES:\n        case VIR_DOMAIN_HYPERV_REENLIGHTENMENT:\n        case VIR_DOMAIN_HYPERV_TLBFLUSH:\n        case VIR_DOMAIN_HYPERV_IPI:\n        case VIR_DOMAIN_HYPERV_EVMCS:\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"host doesn't support hyperv '%s' feature\"),\n                           virDomainHypervTypeToString(i));\n            return -1;\n\n        /* coverity[dead_error_begin] */\n        case VIR_DOMAIN_HYPERV_SPINLOCKS:\n        case VIR_DOMAIN_HYPERV_VENDOR_ID:\n        case VIR_DOMAIN_HYPERV_LAST:\n            break;\n        }\n    }\n\n    return 0;\n}\n\n\nstatic int\nqemuProcessVerifyKVMFeatures(virDomainDefPtr def,\n                             virCPUDataPtr cpu)\n{\n    int rc = 0;\n\n    if (def->features[VIR_DOMAIN_FEATURE_PVSPINLOCK] != VIR_TRISTATE_SWITCH_ON)\n        return 0;\n\n    rc = virCPUDataCheckFeature(cpu, VIR_CPU_x86_KVM_PV_UNHALT);\n\n    if (rc <= 0) {\n        if (rc == 0)\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"host doesn't support paravirtual spinlocks\"));\n        return -1;\n    }\n\n    return 0;\n}\n\n\nstatic int\nqemuProcessVerifyCPUFeatures(virDomainDefPtr def,\n                             virCPUDataPtr cpu)\n{\n    int rc;\n\n    rc = virCPUCheckFeature(def->os.arch, def->cpu, \"invtsc\");\n\n    if (rc < 0) {\n        return -1;\n    } else if (rc == 1) {\n        rc = virCPUDataCheckFeature(cpu, \"invtsc\");\n        if (rc <= 0) {\n            if (rc == 0) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                               _(\"host doesn't support invariant TSC\"));\n            }\n            return -1;\n        }\n    }\n\n    return 0;\n}\n\n\nstatic const char *\nqemuProcessTranslateCPUFeatures(const char *name,\n                                void *opaque)\n{\n    virQEMUCapsPtr qemuCaps = opaque;\n\n    return virQEMUCapsCPUFeatureFromQEMU(qemuCaps, name);\n}\n\n\nstatic int\nqemuProcessFetchGuestCPU(virQEMUDriverPtr driver,\n                         virDomainObjPtr vm,\n                         qemuDomainAsyncJob asyncJob,\n                         virCPUDataPtr *enabled,\n                         virCPUDataPtr *disabled)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    g_autoptr(virCPUData) dataEnabled = NULL;\n    g_autoptr(virCPUData) dataDisabled = NULL;\n    bool generic;\n    int rc;\n\n    *enabled = NULL;\n    *disabled = NULL;\n\n    generic = virQEMUCapsGet(priv->qemuCaps, QEMU_CAPS_CPU_UNAVAILABLE_FEATURES);\n\n    if (!generic && !ARCH_IS_X86(vm->def->os.arch))\n        return 0;\n\n    if (qemuDomainObjEnterMonitorAsync(driver, vm, asyncJob) < 0)\n        return -1;\n\n    if (generic) {\n        rc = qemuMonitorGetGuestCPU(priv->mon,\n                                    vm->def->os.arch,\n                                    qemuProcessTranslateCPUFeatures, priv->qemuCaps,\n                                    &dataEnabled, &dataDisabled);\n    } else {\n        rc = qemuMonitorGetGuestCPUx86(priv->mon, &dataEnabled, &dataDisabled);\n    }\n\n    if (qemuDomainObjExitMonitor(driver, vm) < 0)\n        return -1;\n\n    if (rc == -1)\n        return -1;\n\n    *enabled = g_steal_pointer(&dataEnabled);\n    *disabled = g_steal_pointer(&dataDisabled);\n    return 0;\n}\n\n\nstatic int\nqemuProcessVerifyCPU(virDomainObjPtr vm,\n                     virCPUDataPtr cpu)\n{\n    virDomainDefPtr def = vm->def;\n\n    if (!cpu)\n        return 0;\n\n    if (qemuProcessVerifyKVMFeatures(def, cpu) < 0 ||\n        qemuProcessVerifyHypervFeatures(def, cpu) < 0)\n        return -1;\n\n    if (!def->cpu ||\n        (def->cpu->mode == VIR_CPU_MODE_CUSTOM &&\n         !def->cpu->model))\n        return 0;\n\n    if (qemuProcessVerifyCPUFeatures(def, cpu) < 0)\n        return -1;\n\n    return 0;\n}\n\n\nstatic int\nqemuProcessUpdateLiveGuestCPU(virDomainObjPtr vm,\n                              virCPUDataPtr enabled,\n                              virCPUDataPtr disabled)\n{\n    virDomainDefPtr def = vm->def;\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    g_autoptr(virCPUDef) orig = NULL;\n    int rc;\n\n    if (!enabled)\n        return 0;\n\n    if (!def->cpu ||\n        (def->cpu->mode == VIR_CPU_MODE_CUSTOM &&\n         !def->cpu->model))\n        return 0;\n\n    if (!(orig = virCPUDefCopy(def->cpu)))\n        return -1;\n\n    if ((rc = virCPUUpdateLive(def->os.arch, def->cpu, enabled, disabled)) < 0) {\n        return -1;\n    } else if (rc == 0) {\n        /* Store the original CPU in priv if QEMU changed it and we didn't\n         * get the original CPU via migration, restore, or snapshot revert.\n         */\n        if (!priv->origCPU && !virCPUDefIsEqual(def->cpu, orig, false))\n            priv->origCPU = g_steal_pointer(&orig);\n\n        def->cpu->check = VIR_CPU_CHECK_FULL;\n    }\n\n    return 0;\n}\n\n\nstatic int\nqemuProcessUpdateAndVerifyCPU(virQEMUDriverPtr driver,\n                              virDomainObjPtr vm,\n                              qemuDomainAsyncJob asyncJob)\n{\n    virCPUDataPtr cpu = NULL;\n    virCPUDataPtr disabled = NULL;\n    int ret = -1;\n\n    if (qemuProcessFetchGuestCPU(driver, vm, asyncJob, &cpu, &disabled) < 0)\n        goto cleanup;\n\n    if (qemuProcessVerifyCPU(vm, cpu) < 0)\n        goto cleanup;\n\n    if (qemuProcessUpdateLiveGuestCPU(vm, cpu, disabled) < 0)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    virCPUDataFree(cpu);\n    virCPUDataFree(disabled);\n    return ret;\n}\n\n\nstatic int\nqemuProcessFetchCPUDefinitions(virQEMUDriverPtr driver,\n                               virDomainObjPtr vm,\n                               qemuDomainAsyncJob asyncJob,\n                               virDomainCapsCPUModelsPtr *cpuModels)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    g_autoptr(virDomainCapsCPUModels) models = NULL;\n    int rc;\n\n    if (qemuDomainObjEnterMonitorAsync(driver, vm, asyncJob) < 0)\n        return -1;\n\n    rc = virQEMUCapsFetchCPUModels(priv->mon, vm->def->os.arch, &models);\n\n    if (qemuDomainObjExitMonitor(driver, vm) < 0 || rc < 0)\n        return -1;\n\n    *cpuModels = g_steal_pointer(&models);\n    return 0;\n}\n\n\nstatic int\nqemuProcessUpdateCPU(virQEMUDriverPtr driver,\n                     virDomainObjPtr vm,\n                     qemuDomainAsyncJob asyncJob)\n{\n    g_autoptr(virCPUData) cpu = NULL;\n    g_autoptr(virCPUData) disabled = NULL;\n    g_autoptr(virDomainCapsCPUModels) models = NULL;\n\n    /* The host CPU model comes from host caps rather than QEMU caps so\n     * fallback must be allowed no matter what the user specified in the XML.\n     */\n    vm->def->cpu->fallback = VIR_CPU_FALLBACK_ALLOW;\n\n    if (qemuProcessFetchGuestCPU(driver, vm, asyncJob, &cpu, &disabled) < 0)\n        return -1;\n\n    if (qemuProcessUpdateLiveGuestCPU(vm, cpu, disabled) < 0)\n        return -1;\n\n    if (qemuProcessFetchCPUDefinitions(driver, vm, asyncJob, &models) < 0 ||\n        virCPUTranslate(vm->def->os.arch, vm->def->cpu, models) < 0)\n        return -1;\n\n    return 0;\n}\n\n\nstatic int\nqemuPrepareNVRAM(virQEMUDriverConfigPtr cfg,\n                 virDomainObjPtr vm)\n{\n    int ret = -1;\n    int srcFD = -1;\n    int dstFD = -1;\n    virDomainLoaderDefPtr loader = vm->def->os.loader;\n    bool created = false;\n    const char *master_nvram_path;\n    ssize_t r;\n\n    if (!loader || !loader->nvram || virFileExists(loader->nvram))\n        return 0;\n\n    master_nvram_path = loader->templt;\n    if (!loader->templt) {\n        size_t i;\n        for (i = 0; i < cfg->nfirmwares; i++) {\n            if (STREQ(cfg->firmwares[i]->name, loader->path)) {\n                master_nvram_path = cfg->firmwares[i]->nvram;\n                break;\n            }\n        }\n    }\n\n    if (!master_nvram_path) {\n        virReportError(VIR_ERR_OPERATION_FAILED,\n                       _(\"unable to find any master var store for \"\n                         \"loader: %s\"), loader->path);\n        goto cleanup;\n    }\n\n    if ((srcFD = virFileOpenAs(master_nvram_path, O_RDONLY,\n                               0, -1, -1, 0)) < 0) {\n        virReportSystemError(-srcFD,\n                             _(\"Failed to open file '%s'\"),\n                             master_nvram_path);\n        goto cleanup;\n    }\n    if ((dstFD = virFileOpenAs(loader->nvram,\n                               O_WRONLY | O_CREAT | O_EXCL,\n                               S_IRUSR | S_IWUSR,\n                               cfg->user, cfg->group, 0)) < 0) {\n        virReportSystemError(-dstFD,\n                             _(\"Failed to create file '%s'\"),\n                             loader->nvram);\n        goto cleanup;\n    }\n    created = true;\n\n    do {\n        char buf[1024];\n\n        if ((r = saferead(srcFD, buf, sizeof(buf))) < 0) {\n            virReportSystemError(errno,\n                                 _(\"Unable to read from file '%s'\"),\n                                 master_nvram_path);\n            goto cleanup;\n        }\n\n        if (safewrite(dstFD, buf, r) < 0) {\n            virReportSystemError(errno,\n                                 _(\"Unable to write to file '%s'\"),\n                                 loader->nvram);\n            goto cleanup;\n        }\n    } while (r);\n\n    if (VIR_CLOSE(srcFD) < 0) {\n        virReportSystemError(errno,\n                             _(\"Unable to close file '%s'\"),\n                             master_nvram_path);\n        goto cleanup;\n    }\n    if (VIR_CLOSE(dstFD) < 0) {\n        virReportSystemError(errno,\n                             _(\"Unable to close file '%s'\"),\n                             loader->nvram);\n        goto cleanup;\n    }\n\n    ret = 0;\n cleanup:\n    /* We successfully generated the nvram path, but failed to\n     * copy the file content. Roll back. */\n    if (ret < 0) {\n        if (created)\n            unlink(loader->nvram);\n    }\n\n    VIR_FORCE_CLOSE(srcFD);\n    VIR_FORCE_CLOSE(dstFD);\n    return ret;\n}\n\n\nstatic void\nqemuLogOperation(virDomainObjPtr vm,\n                 const char *msg,\n                 virCommandPtr cmd,\n                 qemuDomainLogContextPtr logCtxt)\n{\n    g_autofree char *timestamp = NULL;\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    int qemuVersion = virQEMUCapsGetVersion(priv->qemuCaps);\n    const char *package = virQEMUCapsGetPackage(priv->qemuCaps);\n    g_autofree char *hostname = virGetHostname();\n    struct utsname uts;\n\n    uname(&uts);\n\n    if ((timestamp = virTimeStringNow()) == NULL)\n        return;\n\n    if (qemuDomainLogContextWrite(logCtxt,\n                                  \"%s: %s %s, qemu version: %d.%d.%d%s, kernel: %s, hostname: %s\\n\",\n                                  timestamp, msg, VIR_LOG_VERSION_STRING,\n                                  (qemuVersion / 1000000) % 1000,\n                                  (qemuVersion / 1000) % 1000,\n                                  qemuVersion % 1000,\n                                  NULLSTR_EMPTY(package),\n                                  uts.release,\n                                  NULLSTR_EMPTY(hostname)) < 0)\n        return;\n\n    if (cmd) {\n        g_autofree char *args = virCommandToString(cmd, true);\n        qemuDomainLogContextWrite(logCtxt, \"%s\\n\", args);\n    }\n}\n\n\nvoid\nqemuProcessIncomingDefFree(qemuProcessIncomingDefPtr inc)\n{\n    if (!inc)\n        return;\n\n    g_free(inc->address);\n    g_free(inc->launchURI);\n    g_free(inc->deferredURI);\n    g_free(inc);\n}\n\n\n/*\n * This function does not copy @path, the caller is responsible for keeping\n * the @path pointer valid during the lifetime of the allocated\n * qemuProcessIncomingDef structure.\n *\n * The caller is responsible for closing @fd, calling\n * qemuProcessIncomingDefFree will NOT close it.\n */\nqemuProcessIncomingDefPtr\nqemuProcessIncomingDefNew(virQEMUCapsPtr qemuCaps,\n                          const char *listenAddress,\n                          const char *migrateFrom,\n                          int fd,\n                          const char *path)\n{\n    qemuProcessIncomingDefPtr inc = NULL;\n\n    if (qemuMigrationDstCheckProtocol(qemuCaps, migrateFrom) < 0)\n        return NULL;\n\n    inc = g_new0(qemuProcessIncomingDef, 1);\n\n    inc->address = g_strdup(listenAddress);\n\n    inc->launchURI = qemuMigrationDstGetURI(migrateFrom, fd);\n    if (!inc->launchURI)\n        goto error;\n\n    if (virQEMUCapsGet(qemuCaps, QEMU_CAPS_INCOMING_DEFER)) {\n        inc->deferredURI = inc->launchURI;\n        inc->launchURI = g_strdup(\"defer\");\n    }\n\n    inc->fd = fd;\n    inc->path = path;\n\n    return inc;\n\n error:\n    qemuProcessIncomingDefFree(inc);\n    return NULL;\n}\n\n\n/*\n * This function starts a new QEMU_ASYNC_JOB_START async job. The user is\n * responsible for calling qemuProcessEndJob to stop this job and for passing\n * QEMU_ASYNC_JOB_START as @asyncJob argument to any function requiring this\n * parameter between qemuProcessBeginJob and qemuProcessEndJob.\n */\nint\nqemuProcessBeginJob(virQEMUDriverPtr driver,\n                    virDomainObjPtr vm,\n                    virDomainJobOperation operation,\n                    unsigned long apiFlags)\n{\n    if (qemuDomainObjBeginAsyncJob(driver, vm, QEMU_ASYNC_JOB_START,\n                                   operation, apiFlags) < 0)\n        return -1;\n\n    qemuDomainObjSetAsyncJobMask(vm, QEMU_JOB_NONE);\n    return 0;\n}\n\n\nvoid\nqemuProcessEndJob(virQEMUDriverPtr driver,\n                  virDomainObjPtr vm)\n{\n    qemuDomainObjEndAsyncJob(driver, vm);\n}\n\n\nstatic int\nqemuProcessStartHook(virQEMUDriverPtr driver,\n                     virDomainObjPtr vm,\n                     virHookQemuOpType op,\n                     virHookSubopType subop)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    g_autofree char *xml = NULL;\n    int ret;\n\n    if (!virHookPresent(VIR_HOOK_DRIVER_QEMU))\n        return 0;\n\n    if (!(xml = qemuDomainDefFormatXML(driver, priv->qemuCaps, vm->def, 0)))\n        return -1;\n\n    ret = virHookCall(VIR_HOOK_DRIVER_QEMU, vm->def->name, op, subop,\n                      NULL, xml, NULL);\n\n    return ret;\n}\n\n\nstatic int\nqemuProcessGraphicsReservePorts(virDomainGraphicsDefPtr graphics,\n                                bool reconnect)\n{\n    virDomainGraphicsListenDefPtr glisten;\n\n    if (graphics->nListens <= 0)\n        return 0;\n\n    glisten = &graphics->listens[0];\n\n    if (glisten->type != VIR_DOMAIN_GRAPHICS_LISTEN_TYPE_ADDRESS &&\n        glisten->type != VIR_DOMAIN_GRAPHICS_LISTEN_TYPE_NETWORK)\n        return 0;\n\n    switch (graphics->type) {\n    case VIR_DOMAIN_GRAPHICS_TYPE_VNC:\n        if (!graphics->data.vnc.autoport ||\n            reconnect) {\n            if (virPortAllocatorSetUsed(graphics->data.vnc.port) < 0)\n                return -1;\n            graphics->data.vnc.portReserved = true;\n        }\n        if (graphics->data.vnc.websocket > 0 &&\n            virPortAllocatorSetUsed(graphics->data.vnc.websocket) < 0)\n            return -1;\n        break;\n\n    case VIR_DOMAIN_GRAPHICS_TYPE_SPICE:\n        if (graphics->data.spice.autoport && !reconnect)\n            return 0;\n\n        if (graphics->data.spice.port > 0) {\n            if (virPortAllocatorSetUsed(graphics->data.spice.port) < 0)\n                return -1;\n            graphics->data.spice.portReserved = true;\n        }\n\n        if (graphics->data.spice.tlsPort > 0) {\n            if (virPortAllocatorSetUsed(graphics->data.spice.tlsPort) < 0)\n                return -1;\n            graphics->data.spice.tlsPortReserved = true;\n        }\n        break;\n\n    case VIR_DOMAIN_GRAPHICS_TYPE_SDL:\n    case VIR_DOMAIN_GRAPHICS_TYPE_RDP:\n    case VIR_DOMAIN_GRAPHICS_TYPE_DESKTOP:\n    case VIR_DOMAIN_GRAPHICS_TYPE_EGL_HEADLESS:\n    case VIR_DOMAIN_GRAPHICS_TYPE_LAST:\n        break;\n    }\n\n    return 0;\n}\n\n\nstatic int\nqemuProcessGraphicsAllocatePorts(virQEMUDriverPtr driver,\n                                 virDomainGraphicsDefPtr graphics,\n                                 bool allocate)\n{\n    virDomainGraphicsListenDefPtr glisten;\n\n    if (graphics->nListens <= 0)\n        return 0;\n\n    glisten = &graphics->listens[0];\n\n    if (glisten->type != VIR_DOMAIN_GRAPHICS_LISTEN_TYPE_ADDRESS &&\n        glisten->type != VIR_DOMAIN_GRAPHICS_LISTEN_TYPE_NETWORK)\n        return 0;\n\n    switch (graphics->type) {\n    case VIR_DOMAIN_GRAPHICS_TYPE_VNC:\n        if (qemuProcessVNCAllocatePorts(driver, graphics, allocate) < 0)\n            return -1;\n        break;\n\n    case VIR_DOMAIN_GRAPHICS_TYPE_SPICE:\n        if (qemuProcessSPICEAllocatePorts(driver, graphics, allocate) < 0)\n            return -1;\n        break;\n\n    case VIR_DOMAIN_GRAPHICS_TYPE_SDL:\n    case VIR_DOMAIN_GRAPHICS_TYPE_RDP:\n    case VIR_DOMAIN_GRAPHICS_TYPE_DESKTOP:\n    case VIR_DOMAIN_GRAPHICS_TYPE_EGL_HEADLESS:\n    case VIR_DOMAIN_GRAPHICS_TYPE_LAST:\n        break;\n    }\n\n    return 0;\n}\n\nstatic int\nqemuProcessGetNetworkAddress(const char *netname,\n                             char **netaddr)\n{\n    g_autoptr(virConnect) conn = NULL;\n    int ret = -1;\n    g_autoptr(virNetwork) net = NULL;\n    virNetworkDefPtr netdef = NULL;\n    virNetworkIPDefPtr ipdef;\n    virSocketAddr addr;\n    virSocketAddrPtr addrptr = NULL;\n    char *dev_name = NULL;\n    g_autofree char *xml = NULL;\n\n    *netaddr = NULL;\n\n    if (!(conn = virGetConnectNetwork()))\n        return -1;\n\n    net = virNetworkLookupByName(conn, netname);\n    if (!net)\n        goto cleanup;\n\n    xml = virNetworkGetXMLDesc(net, 0);\n    if (!xml)\n        goto cleanup;\n\n    netdef = virNetworkDefParseString(xml, NULL);\n    if (!netdef)\n        goto cleanup;\n\n    switch ((virNetworkForwardType) netdef->forward.type) {\n    case VIR_NETWORK_FORWARD_NONE:\n    case VIR_NETWORK_FORWARD_NAT:\n    case VIR_NETWORK_FORWARD_ROUTE:\n    case VIR_NETWORK_FORWARD_OPEN:\n        ipdef = virNetworkDefGetIPByIndex(netdef, AF_UNSPEC, 0);\n        if (!ipdef) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"network '%s' doesn't have an IP address\"),\n                           netdef->name);\n            goto cleanup;\n        }\n        addrptr = &ipdef->address;\n        break;\n\n    case VIR_NETWORK_FORWARD_BRIDGE:\n        if ((dev_name = netdef->bridge))\n            break;\n        /*\n         * fall through if netdef->bridge wasn't set, since that is\n         * macvtap bridge mode network.\n         */\n        G_GNUC_FALLTHROUGH;\n\n    case VIR_NETWORK_FORWARD_PRIVATE:\n    case VIR_NETWORK_FORWARD_VEPA:\n    case VIR_NETWORK_FORWARD_PASSTHROUGH:\n        if ((netdef->forward.nifs > 0) && netdef->forward.ifs)\n            dev_name = netdef->forward.ifs[0].device.dev;\n\n        if (!dev_name) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"network '%s' has no associated interface or bridge\"),\n                           netdef->name);\n            goto cleanup;\n        }\n        break;\n\n    case VIR_NETWORK_FORWARD_HOSTDEV:\n        break;\n\n    case VIR_NETWORK_FORWARD_LAST:\n    default:\n        virReportEnumRangeError(virNetworkForwardType, netdef->forward.type);\n        goto cleanup;\n    }\n\n    if (dev_name) {\n        if (virNetDevIPAddrGet(dev_name, &addr) < 0)\n            goto cleanup;\n        addrptr = &addr;\n    }\n\n    if (!(addrptr &&\n          (*netaddr = virSocketAddrFormat(addrptr)))) {\n        goto cleanup;\n    }\n\n    ret = 0;\n cleanup:\n    virNetworkDefFree(netdef);\n    return ret;\n}\n\n\nstatic int\nqemuProcessGraphicsSetupNetworkAddress(virDomainGraphicsListenDefPtr glisten,\n                                       const char *listenAddr)\n{\n    int rc;\n\n    /* TODO: reject configuration without network specified for network listen */\n    if (!glisten->network) {\n        glisten->address = g_strdup(listenAddr);\n        return 0;\n    }\n\n    rc = qemuProcessGetNetworkAddress(glisten->network, &glisten->address);\n    if (rc <= -2) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"network-based listen isn't possible, \"\n                         \"network driver isn't present\"));\n        return -1;\n    }\n    if (rc < 0)\n        return -1;\n\n    return 0;\n}\n\n\nstatic int\nqemuProcessGraphicsSetupListen(virQEMUDriverPtr driver,\n                               virDomainGraphicsDefPtr graphics,\n                               virDomainObjPtr vm)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    g_autoptr(virQEMUDriverConfig) cfg = virQEMUDriverGetConfig(driver);\n    const char *type = virDomainGraphicsTypeToString(graphics->type);\n    char *listenAddr = NULL;\n    bool useSocket = false;\n    size_t i;\n\n    switch (graphics->type) {\n    case VIR_DOMAIN_GRAPHICS_TYPE_VNC:\n        useSocket = cfg->vncAutoUnixSocket;\n        listenAddr = cfg->vncListen;\n        break;\n\n    case VIR_DOMAIN_GRAPHICS_TYPE_SPICE:\n        useSocket = cfg->spiceAutoUnixSocket;\n        listenAddr = cfg->spiceListen;\n        break;\n\n    case VIR_DOMAIN_GRAPHICS_TYPE_SDL:\n    case VIR_DOMAIN_GRAPHICS_TYPE_RDP:\n    case VIR_DOMAIN_GRAPHICS_TYPE_DESKTOP:\n    case VIR_DOMAIN_GRAPHICS_TYPE_EGL_HEADLESS:\n    case VIR_DOMAIN_GRAPHICS_TYPE_LAST:\n        break;\n    }\n\n    for (i = 0; i < graphics->nListens; i++) {\n        virDomainGraphicsListenDefPtr glisten = &graphics->listens[i];\n\n        switch (glisten->type) {\n        case VIR_DOMAIN_GRAPHICS_LISTEN_TYPE_ADDRESS:\n            if (!glisten->address) {\n                /* If there is no address specified and qemu.conf has\n                 * *_auto_unix_socket set we should use unix socket as\n                 * default instead of tcp listen. */\n                if (useSocket) {\n                    memset(glisten, 0, sizeof(virDomainGraphicsListenDef));\n                    glisten->socket = g_strdup_printf(\"%s/%s.sock\", priv->libDir,\n                                                      type);\n                    glisten->fromConfig = true;\n                    glisten->type = VIR_DOMAIN_GRAPHICS_LISTEN_TYPE_SOCKET;\n                } else if (listenAddr) {\n                    glisten->address = g_strdup(listenAddr);\n                    glisten->fromConfig = true;\n                }\n            }\n            break;\n\n        case VIR_DOMAIN_GRAPHICS_LISTEN_TYPE_NETWORK:\n            if (glisten->address || !listenAddr)\n                continue;\n\n            if (qemuProcessGraphicsSetupNetworkAddress(glisten,\n                                                       listenAddr) < 0)\n                return -1;\n            break;\n\n        case VIR_DOMAIN_GRAPHICS_LISTEN_TYPE_SOCKET:\n            if (!glisten->socket) {\n                glisten->socket = g_strdup_printf(\"%s/%s.sock\", priv->libDir,\n                                                  type);\n                glisten->autoGenerated = true;\n            }\n            break;\n\n        case VIR_DOMAIN_GRAPHICS_LISTEN_TYPE_NONE:\n        case VIR_DOMAIN_GRAPHICS_LISTEN_TYPE_LAST:\n            break;\n        }\n    }\n\n    return 0;\n}\n\n\nstatic int\nqemuProcessGraphicsSetupRenderNode(virDomainGraphicsDefPtr graphics,\n                                   virQEMUCapsPtr qemuCaps)\n{\n    char **rendernode = NULL;\n\n    if (!virDomainGraphicsNeedsAutoRenderNode(graphics))\n        return 0;\n\n    /* Don't bother picking a DRM node if QEMU doesn't support it. */\n    if (graphics->type == VIR_DOMAIN_GRAPHICS_TYPE_SPICE) {\n        if (!virQEMUCapsGet(qemuCaps, QEMU_CAPS_SPICE_RENDERNODE))\n            return 0;\n\n        rendernode = &graphics->data.spice.rendernode;\n    } else {\n        if (!virQEMUCapsGet(qemuCaps, QEMU_CAPS_EGL_HEADLESS_RENDERNODE))\n            return 0;\n\n        rendernode = &graphics->data.egl_headless.rendernode;\n    }\n\n    if (!(*rendernode = virHostGetDRMRenderNode()))\n        return -1;\n\n    return 0;\n}\n\n\nstatic int\nqemuProcessSetupGraphics(virQEMUDriverPtr driver,\n                         virDomainObjPtr vm,\n                         virQEMUCapsPtr qemuCaps,\n                         unsigned int flags)\n{\n    virDomainGraphicsDefPtr graphics;\n    bool allocate = !(flags & VIR_QEMU_PROCESS_START_PRETEND);\n    size_t i;\n\n    for (i = 0; i < vm->def->ngraphics; i++) {\n        graphics = vm->def->graphics[i];\n\n        if (qemuProcessGraphicsSetupRenderNode(graphics, qemuCaps) < 0)\n            return -1;\n\n        if (qemuProcessGraphicsSetupListen(driver, graphics, vm) < 0)\n            return -1;\n    }\n\n    if (allocate) {\n        for (i = 0; i < vm->def->ngraphics; i++) {\n            graphics = vm->def->graphics[i];\n\n            if (qemuProcessGraphicsReservePorts(graphics, false) < 0)\n                return -1;\n        }\n    }\n\n    for (i = 0; i < vm->def->ngraphics; ++i) {\n        graphics = vm->def->graphics[i];\n\n        if (qemuProcessGraphicsAllocatePorts(driver, graphics, allocate) < 0)\n            return -1;\n    }\n\n    return 0;\n}\n\n\nstatic int\nqemuProcessSetupRawIO(virQEMUDriverPtr driver,\n                      virDomainObjPtr vm,\n                      virCommandPtr cmd G_GNUC_UNUSED)\n{\n    bool rawio = false;\n    size_t i;\n    int ret = -1;\n\n    /* in case a certain disk is desirous of CAP_SYS_RAWIO, add this */\n    for (i = 0; i < vm->def->ndisks; i++) {\n        virDomainDeviceDef dev;\n        virDomainDiskDefPtr disk = vm->def->disks[i];\n\n        if (disk->rawio == VIR_TRISTATE_BOOL_YES) {\n            rawio = true;\n#ifndef CAP_SYS_RAWIO\n            break;\n#endif\n        }\n\n        dev.type = VIR_DOMAIN_DEVICE_DISK;\n        dev.data.disk = disk;\n        if (qemuAddSharedDevice(driver, &dev, vm->def->name) < 0)\n            goto cleanup;\n\n        if (qemuSetUnprivSGIO(&dev) < 0)\n            goto cleanup;\n    }\n\n    /* If rawio not already set, check hostdevs as well */\n    if (!rawio) {\n        for (i = 0; i < vm->def->nhostdevs; i++) {\n            virDomainHostdevSubsysSCSIPtr scsisrc;\n\n            if (!virHostdevIsSCSIDevice(vm->def->hostdevs[i]))\n                continue;\n\n            scsisrc = &vm->def->hostdevs[i]->source.subsys.u.scsi;\n            if (scsisrc->rawio == VIR_TRISTATE_BOOL_YES) {\n                rawio = true;\n                break;\n            }\n        }\n    }\n\n    ret = 0;\n\n cleanup:\n    if (rawio) {\n#ifdef CAP_SYS_RAWIO\n        if (ret == 0)\n            virCommandAllowCap(cmd, CAP_SYS_RAWIO);\n#else\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Raw I/O is not supported on this platform\"));\n        ret = -1;\n#endif\n    }\n    return ret;\n}\n\n\nstatic int\nqemuProcessSetupBalloon(virQEMUDriverPtr driver,\n                        virDomainObjPtr vm,\n                        qemuDomainAsyncJob asyncJob)\n{\n    unsigned long long balloon = vm->def->mem.cur_balloon;\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    int ret = -1;\n\n    if (!virDomainDefHasMemballoon(vm->def))\n        return 0;\n\n    if (qemuDomainObjEnterMonitorAsync(driver, vm, asyncJob) < 0)\n        return -1;\n\n    if (vm->def->memballoon->period)\n        qemuMonitorSetMemoryStatsPeriod(priv->mon, vm->def->memballoon,\n                                        vm->def->memballoon->period);\n    if (qemuMonitorSetBalloon(priv->mon, balloon) < 0)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    if (qemuDomainObjExitMonitor(driver, vm) < 0)\n        ret = -1;\n    return ret;\n}\n\n\nstatic int\nqemuProcessMakeDir(virQEMUDriverPtr driver,\n                   virDomainObjPtr vm,\n                   const char *path)\n{\n    if (virFileMakePathWithMode(path, 0750) < 0) {\n        virReportSystemError(errno, _(\"Cannot create directory '%s'\"), path);\n        return -1;\n    }\n\n    if (qemuSecurityDomainSetPathLabel(driver, vm, path, true) < 0)\n        return -1;\n\n    return 0;\n}\n\n\nstatic void\nqemuProcessStartWarnShmem(virDomainObjPtr vm)\n{\n    size_t i;\n    bool check_shmem = false;\n    bool shmem = vm->def->nshmems;\n\n    /*\n     * For vhost-user to work, the domain has to have some type of\n     * shared memory configured.  We're not the proper ones to judge\n     * whether shared hugepages or shm are enough and will be in the\n     * future, so we'll just warn in case neither is configured.\n     * Moreover failing would give the false illusion that libvirt is\n     * really checking that everything works before running the domain\n     * and not only we are unable to do that, but it's also not our\n     * aim to do so.\n     */\n    for (i = 0; i < vm->def->nnets; i++) {\n        if (virDomainNetGetActualType(vm->def->nets[i]) ==\n                                      VIR_DOMAIN_NET_TYPE_VHOSTUSER) {\n            check_shmem = true;\n            break;\n        }\n    }\n\n    if (!check_shmem)\n        return;\n\n    /*\n     * This check is by no means complete.  We merely check\n     * whether there are *some* hugepages enabled and *some* NUMA\n     * nodes with shared memory access.\n     */\n    if (!shmem && vm->def->mem.nhugepages) {\n        for (i = 0; i < virDomainNumaGetNodeCount(vm->def->numa); i++) {\n            if (virDomainNumaGetNodeMemoryAccessMode(vm->def->numa, i) ==\n                VIR_DOMAIN_MEMORY_ACCESS_SHARED) {\n                shmem = true;\n                break;\n            }\n        }\n    }\n\n    if (!shmem) {\n        VIR_WARN(\"Detected vhost-user interface without any shared memory, \"\n                 \"the interface might not be operational\");\n    }\n}\n\n\nstatic int\nqemuProcessStartValidateGraphics(virDomainObjPtr vm)\n{\n    size_t i;\n\n    for (i = 0; i < vm->def->ngraphics; i++) {\n        virDomainGraphicsDefPtr graphics = vm->def->graphics[i];\n\n        switch (graphics->type) {\n        case VIR_DOMAIN_GRAPHICS_TYPE_VNC:\n        case VIR_DOMAIN_GRAPHICS_TYPE_SPICE:\n            if (graphics->nListens > 1) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                               _(\"QEMU does not support multiple listens for \"\n                                 \"one graphics device.\"));\n                return -1;\n            }\n            break;\n\n        case VIR_DOMAIN_GRAPHICS_TYPE_SDL:\n        case VIR_DOMAIN_GRAPHICS_TYPE_RDP:\n        case VIR_DOMAIN_GRAPHICS_TYPE_DESKTOP:\n        case VIR_DOMAIN_GRAPHICS_TYPE_EGL_HEADLESS:\n        case VIR_DOMAIN_GRAPHICS_TYPE_LAST:\n            break;\n        }\n    }\n\n    return 0;\n}\n\n\nstatic int\nqemuProcessStartValidateIOThreads(virDomainObjPtr vm,\n                                  virQEMUCapsPtr qemuCaps)\n{\n    size_t i;\n\n    if (vm->def->niothreadids > 0 &&\n        !virQEMUCapsGet(qemuCaps, QEMU_CAPS_OBJECT_IOTHREAD)) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"IOThreads not supported for this QEMU\"));\n        return -1;\n    }\n\n    for (i = 0; i < vm->def->ncontrollers; i++) {\n        virDomainControllerDefPtr cont = vm->def->controllers[i];\n\n        if (cont->type == VIR_DOMAIN_CONTROLLER_TYPE_SCSI &&\n            cont->model == VIR_DOMAIN_CONTROLLER_MODEL_SCSI_VIRTIO_SCSI &&\n            cont->iothread > 0 &&\n            !virQEMUCapsGet(qemuCaps, QEMU_CAPS_VIRTIO_SCSI_IOTHREAD)) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"IOThreads for virtio-scsi not supported for \"\n                             \"this QEMU\"));\n            return -1;\n        }\n    }\n\n    return 0;\n}\n\n\nstatic int\nqemuProcessStartValidateShmem(virDomainObjPtr vm)\n{\n    size_t i;\n\n    for (i = 0; i < vm->def->nshmems; i++) {\n        virDomainShmemDefPtr shmem = vm->def->shmems[i];\n\n        if (strchr(shmem->name, '/')) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"shmem name '%s' must not contain '/'\"),\n                           shmem->name);\n            return -1;\n        }\n    }\n\n    return 0;\n}\n\n\nstatic int\nqemuProcessStartValidateDisks(virDomainObjPtr vm,\n                              virQEMUCapsPtr qemuCaps)\n{\n    size_t i;\n\n    for (i = 0; i < vm->def->ndisks; i++) {\n        virDomainDiskDefPtr disk = vm->def->disks[i];\n        virStorageSourcePtr src = disk->src;\n\n        /* This is a best effort check as we can only check if the command\n         * option exists, but we cannot determine whether the running QEMU\n         * was build with '--enable-vxhs'. */\n        if (src->type == VIR_STORAGE_TYPE_NETWORK &&\n            src->protocol == VIR_STORAGE_NET_PROTOCOL_VXHS &&\n            !virQEMUCapsGet(qemuCaps, QEMU_CAPS_VXHS)) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"VxHS protocol is not supported with this \"\n                             \"QEMU binary\"));\n            return -1;\n        }\n\n        /* PowerPC pseries based VMs do not support floppy device */\n        if (disk->device == VIR_DOMAIN_DISK_DEVICE_FLOPPY &&\n            qemuDomainIsPSeries(vm->def)) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"PowerPC pseries machines do not support floppy device\"));\n            return -1;\n        }\n\n        if (src->type == VIR_STORAGE_TYPE_NVME &&\n            !virQEMUCapsGet(qemuCaps, QEMU_CAPS_DRIVE_NVME)) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"NVMe disks are not supported with this QEMU binary\"));\n            return -1;\n        }\n    }\n\n    return 0;\n}\n\n\n/* 250 parts per million (ppm) is a half of NTP threshold */\n#define TSC_TOLERANCE 250\n\nstatic int\nqemuProcessStartValidateTSC(virQEMUDriverPtr driver,\n                            virDomainObjPtr vm)\n{\n    size_t i;\n    unsigned long long freq = 0;\n    unsigned long long tolerance;\n    unsigned long long minFreq;\n    unsigned long long maxFreq;\n    virHostCPUTscInfoPtr tsc;\n    g_autoptr(virCPUDef) cpu = NULL;\n\n    for (i = 0; i < vm->def->clock.ntimers; i++) {\n        virDomainTimerDefPtr timer = vm->def->clock.timers[i];\n\n        if (timer->name == VIR_DOMAIN_TIMER_NAME_TSC &&\n            timer->frequency > 0) {\n            freq = timer->frequency;\n            break;\n        }\n    }\n\n    if (freq == 0)\n        return 0;\n\n    VIR_DEBUG(\"Requested TSC frequency %llu Hz\", freq);\n\n    cpu = virQEMUDriverGetHostCPU(driver);\n    if (!cpu || !cpu->tsc) {\n        VIR_DEBUG(\"Host TSC frequency could not be probed\");\n        return 0;\n    }\n\n    tsc = cpu->tsc;\n    tolerance = tsc->frequency * TSC_TOLERANCE / 1000000;\n    minFreq = tsc->frequency - tolerance;\n    maxFreq = tsc->frequency + tolerance;\n\n    VIR_DEBUG(\"Host TSC frequency %llu Hz, scaling %s, tolerance +/- %llu Hz\",\n              tsc->frequency, virTristateBoolTypeToString(tsc->scaling),\n              tolerance);\n\n    if (freq >= minFreq && freq <= maxFreq) {\n        VIR_DEBUG(\"Requested TSC frequency is within tolerance interval\");\n        return 0;\n    }\n\n    if (tsc->scaling == VIR_TRISTATE_BOOL_YES)\n        return 0;\n\n    if (tsc->scaling == VIR_TRISTATE_BOOL_ABSENT) {\n        VIR_DEBUG(\"Requested TSC frequency falls outside tolerance range and \"\n                  \"scaling support is unknown, QEMU will try and possibly \"\n                  \"fail later\");\n        return 0;\n    }\n\n    virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                   _(\"Requested TSC frequency %llu Hz is outside tolerance \"\n                     \"range ([%llu, %llu] Hz) around host frequency %llu Hz \"\n                     \"and TSC scaling is not supported by the host CPU\"),\n                   freq, minFreq, maxFreq, tsc->frequency);\n    return -1;\n}\n\n\n/**\n * qemuProcessStartValidate:\n * @vm: domain object\n * @qemuCaps: emulator capabilities\n * @migration: restoration of existing state\n *\n * This function aggregates checks done prior to start of a VM.\n *\n * Flag VIR_QEMU_PROCESS_START_PRETEND tells, that we don't want to actually\n * start the domain but create a valid qemu command.  If some code shouldn't be\n * executed in this case, make sure to check this flag.\n */\nstatic int\nqemuProcessStartValidate(virQEMUDriverPtr driver,\n                         virDomainObjPtr vm,\n                         virQEMUCapsPtr qemuCaps,\n                         unsigned int flags)\n{\n    if (!(flags & VIR_QEMU_PROCESS_START_PRETEND)) {\n        if (vm->def->virtType == VIR_DOMAIN_VIRT_KVM) {\n            VIR_DEBUG(\"Checking for KVM availability\");\n            if (!virFileExists(\"/dev/kvm\")) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                               _(\"Domain requires KVM, but it is not available. \"\n                                 \"Check that virtualization is enabled in the \"\n                                 \"host BIOS, and host configuration is setup to \"\n                                 \"load the kvm modules.\"));\n                return -1;\n            }\n        }\n\n        VIR_DEBUG(\"Checking domain and device security labels\");\n        if (qemuSecurityCheckAllLabel(driver->securityManager, vm->def) < 0)\n            return -1;\n\n    }\n\n    /* Checks below should not be executed when starting a qemu process for a\n     * VM that was running before (migration, snapshots, save). It's more\n     * important to start such VM than keep the configuration clean */\n    if ((flags & VIR_QEMU_PROCESS_START_NEW) &&\n        virDomainDefValidate(vm->def, 0, driver->xmlopt, qemuCaps) < 0)\n        return -1;\n\n    if (qemuProcessStartValidateGraphics(vm) < 0)\n        return -1;\n\n    if (qemuProcessStartValidateIOThreads(vm, qemuCaps) < 0)\n        return -1;\n\n    if (qemuProcessStartValidateShmem(vm) < 0)\n        return -1;\n\n    if (vm->def->cpu) {\n        if (virCPUValidateFeatures(vm->def->os.arch, vm->def->cpu) < 0)\n            return -1;\n\n        if (ARCH_IS_X86(vm->def->os.arch) &&\n            !virQEMUCapsGet(qemuCaps, QEMU_CAPS_CPU_UNAVAILABLE_FEATURES)) {\n            g_auto(GStrv) features = NULL;\n            int n;\n\n            if ((n = virCPUDefCheckFeatures(vm->def->cpu,\n                                            virCPUx86FeatureFilterSelectMSR,\n                                            NULL,\n                                            &features)) < 0)\n                return -1;\n\n            if (n > 0) {\n                g_autofree char *str = NULL;\n\n                str = g_strjoinv(\", \", features);\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                               _(\"Some features cannot be reliably used \"\n                                 \"with this QEMU: %s\"), str);\n                return -1;\n            }\n        }\n    }\n\n    if (qemuProcessStartValidateDisks(vm, qemuCaps) < 0)\n        return -1;\n\n    if (qemuProcessStartValidateTSC(driver, vm) < 0)\n        return -1;\n\n    VIR_DEBUG(\"Checking for any possible (non-fatal) issues\");\n\n    qemuProcessStartWarnShmem(vm);\n\n    return 0;\n}\n\n\nstatic int\nqemuProcessStartUpdateCustomCaps(virDomainObjPtr vm)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    g_autoptr(virQEMUDriverConfig) cfg = virQEMUDriverGetConfig(priv->driver);\n    qemuDomainXmlNsDefPtr nsdef = vm->def->namespaceData;\n    char **next;\n    int tmp;\n    size_t i;\n\n    if (cfg->capabilityfilters) {\n        for (next = cfg->capabilityfilters; *next; next++) {\n            if ((tmp = virQEMUCapsTypeFromString(*next)) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"invalid capability_filters capability '%s'\"),\n                               *next);\n                return -1;\n            }\n\n            virQEMUCapsClear(priv->qemuCaps, tmp);\n        }\n    }\n\n    if (nsdef) {\n        for (i = 0; i < nsdef->ncapsadd; i++) {\n            if ((tmp = virQEMUCapsTypeFromString(nsdef->capsadd[i])) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"invalid qemu namespace capability '%s'\"),\n                               nsdef->capsadd[i]);\n                return -1;\n            }\n\n            virQEMUCapsSet(priv->qemuCaps, tmp);\n        }\n\n        for (i = 0; i < nsdef->ncapsdel; i++) {\n            if ((tmp = virQEMUCapsTypeFromString(nsdef->capsdel[i])) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"invalid qemu namespace capability '%s'\"),\n                               nsdef->capsdel[i]);\n                return -1;\n            }\n\n            virQEMUCapsClear(priv->qemuCaps, tmp);\n        }\n    }\n\n    return 0;\n}\n\n\n/**\n * qemuProcessPrepareQEMUCaps:\n * @vm: domain object\n * @qemuCapsCache: cache of QEMU capabilities\n * @processStartFlags: flags based on the VIR_QEMU_PROCESS_START_* enum\n *\n * Prepare the capabilities of a QEMU process for startup. This includes\n * copying the caps to a static cache and potential post-processing depending\n * on the configuration of the VM and startup process.\n *\n * Returns 0 on success, -1 on error.\n */\nstatic int\nqemuProcessPrepareQEMUCaps(virDomainObjPtr vm,\n                           virFileCachePtr qemuCapsCache,\n                           unsigned int processStartFlags)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n\n    virObjectUnref(priv->qemuCaps);\n    if (!(priv->qemuCaps = virQEMUCapsCacheLookupCopy(qemuCapsCache,\n                                                      vm->def->virtType,\n                                                      vm->def->emulator,\n                                                      vm->def->os.machine)))\n        return -1;\n\n    if (processStartFlags & VIR_QEMU_PROCESS_START_STANDALONE)\n        virQEMUCapsClear(priv->qemuCaps, QEMU_CAPS_CHARDEV_FD_PASS);\n\n    /* Update qemu capabilities according to lists passed in via namespace */\n    if (qemuProcessStartUpdateCustomCaps(vm) < 0)\n        return -1;\n\n    /* re-process capability lockouts since we might have removed capabilities */\n    virQEMUCapsInitProcessCapsInterlock(priv->qemuCaps);\n\n    return 0;\n}\n\n\n/**\n * qemuProcessInit:\n *\n * Prepares the domain up to the point when priv->qemuCaps is initialized. The\n * function calls qemuProcessStop when needed.\n *\n * Flag VIR_QEMU_PROCESS_START_PRETEND tells, that we don't want to actually\n * start the domain but create a valid qemu command.  If some code shouldn't be\n * executed in this case, make sure to check this flag.\n *\n * Returns 0 on success, -1 on error.\n */\nint\nqemuProcessInit(virQEMUDriverPtr driver,\n                virDomainObjPtr vm,\n                virCPUDefPtr updatedCPU,\n                qemuDomainAsyncJob asyncJob,\n                bool migration,\n                unsigned int flags)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    int stopFlags;\n    virCPUDefPtr origCPU = NULL;\n    int ret = -1;\n\n    VIR_DEBUG(\"vm=%p name=%s id=%d migration=%d\",\n              vm, vm->def->name, vm->def->id, migration);\n\n    VIR_DEBUG(\"Beginning VM startup process\");\n\n    if (virDomainObjIsActive(vm)) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"VM is already active\"));\n        goto cleanup;\n    }\n\n    /* in case when the post parse callback failed we need to re-run it on the\n     * old config prior we start the VM */\n    if (vm->def->postParseFailed) {\n        VIR_DEBUG(\"re-running the post parse callback\");\n\n        /* we don't have the private copy of qemuCaps at this point */\n        if (virDomainDefPostParse(vm->def, 0, driver->xmlopt, NULL) < 0)\n            goto cleanup;\n    }\n\n    VIR_DEBUG(\"Determining emulator version\");\n    if (qemuProcessPrepareQEMUCaps(vm, driver->qemuCapsCache, flags) < 0)\n        goto cleanup;\n\n    if (qemuDomainUpdateCPU(vm, updatedCPU, &origCPU) < 0)\n        goto cleanup;\n\n    if (qemuProcessStartValidate(driver, vm, priv->qemuCaps, flags) < 0)\n        goto cleanup;\n\n    /* Do this upfront, so any part of the startup process can add\n     * runtime state to vm->def that won't be persisted. This let's us\n     * report implicit runtime defaults in the XML, like vnc listen/socket\n     */\n    VIR_DEBUG(\"Setting current domain def as transient\");\n    if (virDomainObjSetDefTransient(driver->xmlopt, vm, priv->qemuCaps) < 0)\n        goto cleanup;\n\n    /* don't clean up files for <transient> disks until we set them up */\n    priv->inhibitDiskTransientDelete = true;\n\n    if (flags & VIR_QEMU_PROCESS_START_PRETEND) {\n        if (qemuDomainSetPrivatePaths(driver, vm) < 0) {\n            virDomainObjRemoveTransientDef(vm);\n            goto cleanup;\n        }\n    } else {\n        vm->def->id = qemuDriverAllocateID(driver);\n        qemuDomainSetFakeReboot(driver, vm, false);\n        virDomainObjSetState(vm, VIR_DOMAIN_PAUSED, VIR_DOMAIN_PAUSED_STARTING_UP);\n\n        if (g_atomic_int_add(&driver->nactive, 1) == 0 && driver->inhibitCallback)\n            driver->inhibitCallback(true, driver->inhibitOpaque);\n\n        /* Run an early hook to set-up missing devices */\n        if (qemuProcessStartHook(driver, vm,\n                                 VIR_HOOK_QEMU_OP_PREPARE,\n                                 VIR_HOOK_SUBOP_BEGIN) < 0)\n            goto stop;\n\n        if (qemuDomainSetPrivatePaths(driver, vm) < 0)\n            goto stop;\n\n        priv->origCPU = g_steal_pointer(&origCPU);\n    }\n\n    ret = 0;\n\n cleanup:\n    virCPUDefFree(origCPU);\n    return ret;\n\n stop:\n    stopFlags = VIR_QEMU_PROCESS_STOP_NO_RELABEL;\n    if (migration)\n        stopFlags |= VIR_QEMU_PROCESS_STOP_MIGRATED;\n    qemuProcessStop(driver, vm, VIR_DOMAIN_SHUTOFF_FAILED, asyncJob, stopFlags);\n    goto cleanup;\n}\n\n\n/**\n * qemuProcessNetworkPrepareDevices\n */\nstatic int\nqemuProcessNetworkPrepareDevices(virQEMUDriverPtr driver,\n                                 virDomainObjPtr vm)\n{\n    virDomainDefPtr def = vm->def;\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    size_t i;\n    g_autoptr(virConnect) conn = NULL;\n\n    for (i = 0; i < def->nnets; i++) {\n        virDomainNetDefPtr net = def->nets[i];\n        virDomainNetType actualType;\n\n        /* If appropriate, grab a physical device from the configured\n         * network's pool of devices, or resolve bridge device name\n         * to the one defined in the network definition.\n         */\n        if (net->type == VIR_DOMAIN_NET_TYPE_NETWORK) {\n            if (!conn && !(conn = virGetConnectNetwork()))\n                return -1;\n            if (virDomainNetAllocateActualDevice(conn, def, net) < 0)\n                return -1;\n        }\n\n        actualType = virDomainNetGetActualType(net);\n        if (actualType == VIR_DOMAIN_NET_TYPE_HOSTDEV &&\n            net->type == VIR_DOMAIN_NET_TYPE_NETWORK) {\n            /* Each type='hostdev' network device must also have a\n             * corresponding entry in the hostdevs array. For netdevs\n             * that are hardcoded as type='hostdev', this is already\n             * done by the parser, but for those allocated from a\n             * network / determined at runtime, we need to do it\n             * separately.\n             */\n            virDomainHostdevDefPtr hostdev = virDomainNetGetActualHostdev(net);\n            virDomainHostdevSubsysPCIPtr pcisrc = &hostdev->source.subsys.u.pci;\n\n            if (virDomainHostdevFind(def, hostdev, NULL) >= 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"PCI device %04x:%02x:%02x.%x \"\n                                 \"allocated from network %s is already \"\n                                 \"in use by domain %s\"),\n                               pcisrc->addr.domain, pcisrc->addr.bus,\n                               pcisrc->addr.slot, pcisrc->addr.function,\n                               net->data.network.name, def->name);\n                return -1;\n            }\n            if (virDomainHostdevInsert(def, hostdev) < 0)\n                return -1;\n        } else if (actualType == VIR_DOMAIN_NET_TYPE_USER &&\n                   !priv->disableSlirp &&\n                   virQEMUCapsGet(priv->qemuCaps, QEMU_CAPS_DBUS_VMSTATE)) {\n            qemuSlirpPtr slirp = NULL;\n            int rv = qemuInterfacePrepareSlirp(driver, net, &slirp);\n\n            if (rv == -1)\n                return -1;\n            if (rv == 1)\n                QEMU_DOMAIN_NETWORK_PRIVATE(net)->slirp = slirp;\n         }\n\n    }\n    return 0;\n}\n\n\n/**\n * qemuProcessSetupVcpu:\n * @vm: domain object\n * @vcpuid: id of VCPU to set defaults\n *\n * This function sets resource properties (cgroups, affinity, scheduler) for a\n * vCPU. This function expects that the vCPU is online and the vCPU pids were\n * correctly detected at the point when it's called.\n *\n * Returns 0 on success, -1 on error.\n */\nint\nqemuProcessSetupVcpu(virDomainObjPtr vm,\n                     unsigned int vcpuid)\n{\n    pid_t vcpupid = qemuDomainGetVcpuPid(vm, vcpuid);\n    virDomainVcpuDefPtr vcpu = virDomainDefGetVcpu(vm->def, vcpuid);\n    virDomainResctrlMonDefPtr mon = NULL;\n    size_t i = 0;\n\n    if (qemuProcessSetupPid(vm, vcpupid, VIR_CGROUP_THREAD_VCPU,\n                            vcpuid, vcpu->cpumask,\n                            vm->def->cputune.period,\n                            vm->def->cputune.quota,\n                            &vcpu->sched) < 0)\n        return -1;\n\n    for (i = 0; i < vm->def->nresctrls; i++) {\n        size_t j = 0;\n        virDomainResctrlDefPtr ct = vm->def->resctrls[i];\n\n        if (virBitmapIsBitSet(ct->vcpus, vcpuid)) {\n            if (virResctrlAllocAddPID(ct->alloc, vcpupid) < 0)\n                return -1;\n\n            for (j = 0; j < ct->nmonitors; j++) {\n                mon = ct->monitors[j];\n\n                if (virBitmapEqual(ct->vcpus, mon->vcpus) &&\n                    !virResctrlAllocIsEmpty(ct->alloc))\n                    continue;\n\n                if (virBitmapIsBitSet(mon->vcpus, vcpuid)) {\n                    if (virResctrlMonitorAddPID(mon->instance, vcpupid) < 0)\n                        return -1;\n                    break;\n                }\n            }\n\n            break;\n        }\n    }\n\n    return 0;\n}\n\n\nstatic int\nqemuProcessSetupVcpus(virDomainObjPtr vm)\n{\n    virDomainVcpuDefPtr vcpu;\n    unsigned int maxvcpus = virDomainDefGetVcpusMax(vm->def);\n    size_t i;\n\n    if ((vm->def->cputune.period || vm->def->cputune.quota) &&\n        !virCgroupHasController(((qemuDomainObjPrivatePtr) vm->privateData)->cgroup,\n                                VIR_CGROUP_CONTROLLER_CPU)) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"cgroup cpu is required for scheduler tuning\"));\n        return -1;\n    }\n\n    if (!qemuDomainHasVcpuPids(vm)) {\n        /* If any CPU has custom affinity that differs from the\n         * VM default affinity, we must reject it */\n        for (i = 0; i < maxvcpus; i++) {\n            vcpu = virDomainDefGetVcpu(vm->def, i);\n\n            if (!vcpu->online)\n                continue;\n\n            if (vcpu->cpumask &&\n                !virBitmapEqual(vm->def->cpumask, vcpu->cpumask)) {\n                virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                                _(\"cpu affinity is not supported\"));\n                return -1;\n            }\n        }\n\n        return 0;\n    }\n\n    for (i = 0; i < maxvcpus; i++) {\n        vcpu = virDomainDefGetVcpu(vm->def, i);\n\n        if (!vcpu->online)\n            continue;\n\n        if (qemuProcessSetupVcpu(vm, i) < 0)\n            return -1;\n    }\n\n    return 0;\n}\n\n\nint\nqemuProcessSetupIOThread(virDomainObjPtr vm,\n                         virDomainIOThreadIDDefPtr iothread)\n{\n    return qemuProcessSetupPid(vm, iothread->thread_id,\n                               VIR_CGROUP_THREAD_IOTHREAD,\n                               iothread->iothread_id,\n                               iothread->cpumask,\n                               vm->def->cputune.iothread_period,\n                               vm->def->cputune.iothread_quota,\n                               &iothread->sched);\n}\n\n\nstatic int\nqemuProcessSetupIOThreads(virDomainObjPtr vm)\n{\n    size_t i;\n\n    for (i = 0; i < vm->def->niothreadids; i++) {\n        virDomainIOThreadIDDefPtr info = vm->def->iothreadids[i];\n\n        if (qemuProcessSetupIOThread(vm, info) < 0)\n            return -1;\n    }\n\n    return 0;\n}\n\n\nstatic int\nqemuProcessValidateHotpluggableVcpus(virDomainDefPtr def)\n{\n    virDomainVcpuDefPtr vcpu;\n    virDomainVcpuDefPtr subvcpu;\n    qemuDomainVcpuPrivatePtr vcpupriv;\n    unsigned int maxvcpus = virDomainDefGetVcpusMax(def);\n    size_t i = 0;\n    size_t j;\n    virBitmapPtr ordermap = virBitmapNew(maxvcpus + 1);\n    int ret = -1;\n\n    /* validate:\n     * - all hotpluggable entities to be hotplugged have the correct data\n     * - vcpus belonging to a hotpluggable entity share configuration\n     * - order of the hotpluggable entities is unique\n     */\n    for (i = 0; i < maxvcpus; i++) {\n        vcpu = virDomainDefGetVcpu(def, i);\n        vcpupriv = QEMU_DOMAIN_VCPU_PRIVATE(vcpu);\n\n        /* skip over hotpluggable entities  */\n        if (vcpupriv->vcpus == 0)\n            continue;\n\n        if (vcpu->order != 0) {\n            if (virBitmapIsBitSet(ordermap, vcpu->order)) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                               _(\"duplicate vcpu order '%u'\"), vcpu->order);\n                goto cleanup;\n            }\n\n            if (virBitmapSetBit(ordermap, vcpu->order)) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                               _(\"vcpu order '%u' exceeds vcpu count\"),\n                               vcpu->order);\n                goto cleanup;\n            }\n        }\n\n        for (j = i + 1; j < (i + vcpupriv->vcpus); j++) {\n            subvcpu = virDomainDefGetVcpu(def, j);\n            if (subvcpu->hotpluggable != vcpu->hotpluggable ||\n                subvcpu->online != vcpu->online ||\n                subvcpu->order != vcpu->order) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                               _(\"vcpus '%zu' and '%zu' are in the same hotplug \"\n                                 \"group but differ in configuration\"), i, j);\n                goto cleanup;\n            }\n        }\n\n        if (vcpu->online && vcpu->hotpluggable == VIR_TRISTATE_BOOL_YES) {\n            if ((vcpupriv->socket_id == -1 && vcpupriv->core_id == -1 &&\n                 vcpupriv->thread_id == -1 && vcpupriv->node_id == -1) ||\n                !vcpupriv->type) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                               _(\"vcpu '%zu' is missing hotplug data\"), i);\n                goto cleanup;\n            }\n        }\n    }\n\n    ret = 0;\n cleanup:\n    virBitmapFree(ordermap);\n    return ret;\n}\n\n\nstatic int\nqemuDomainHasHotpluggableStartupVcpus(virDomainDefPtr def)\n{\n    size_t maxvcpus = virDomainDefGetVcpusMax(def);\n    virDomainVcpuDefPtr vcpu;\n    size_t i;\n\n    for (i = 0; i < maxvcpus; i++) {\n        vcpu = virDomainDefGetVcpu(def, i);\n\n        if (vcpu->online && vcpu->hotpluggable == VIR_TRISTATE_BOOL_YES)\n            return true;\n    }\n\n    return false;\n}\n\n\nstatic int\nqemuProcessVcpusSortOrder(const void *a,\n                          const void *b)\n{\n    virDomainVcpuDefPtr vcpua = *((virDomainVcpuDefPtr *)a);\n    virDomainVcpuDefPtr vcpub = *((virDomainVcpuDefPtr *)b);\n\n    return vcpua->order - vcpub->order;\n}\n\n\nstatic int\nqemuProcessSetupHotpluggableVcpus(virQEMUDriverPtr driver,\n                                  virDomainObjPtr vm,\n                                  qemuDomainAsyncJob asyncJob)\n{\n    unsigned int maxvcpus = virDomainDefGetVcpusMax(vm->def);\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    qemuCgroupEmulatorAllNodesDataPtr emulatorCgroup = NULL;\n    virDomainVcpuDefPtr vcpu;\n    qemuDomainVcpuPrivatePtr vcpupriv;\n    virJSONValuePtr vcpuprops = NULL;\n    size_t i;\n    int ret = -1;\n    int rc;\n\n    virDomainVcpuDefPtr *bootHotplug = NULL;\n    size_t nbootHotplug = 0;\n\n    for (i = 0; i < maxvcpus; i++) {\n        vcpu = virDomainDefGetVcpu(vm->def, i);\n        vcpupriv = QEMU_DOMAIN_VCPU_PRIVATE(vcpu);\n\n        if (vcpu->hotpluggable == VIR_TRISTATE_BOOL_YES && vcpu->online &&\n            vcpupriv->vcpus != 0) {\n            vcpupriv->alias = g_strdup_printf(\"vcpu%zu\", i);\n\n            if (VIR_APPEND_ELEMENT(bootHotplug, nbootHotplug, vcpu) < 0)\n                goto cleanup;\n        }\n    }\n\n    if (nbootHotplug == 0) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    qsort(bootHotplug, nbootHotplug, sizeof(*bootHotplug),\n          qemuProcessVcpusSortOrder);\n\n    if (qemuCgroupEmulatorAllNodesAllow(priv->cgroup, &emulatorCgroup) < 0)\n        goto cleanup;\n\n    for (i = 0; i < nbootHotplug; i++) {\n        vcpu = bootHotplug[i];\n\n        if (!(vcpuprops = qemuBuildHotpluggableCPUProps(vcpu)))\n            goto cleanup;\n\n        if (qemuDomainObjEnterMonitorAsync(driver, vm, asyncJob) < 0)\n            goto cleanup;\n\n        rc = qemuMonitorAddDeviceArgs(qemuDomainGetMonitor(vm), vcpuprops);\n        vcpuprops = NULL;\n\n        if (qemuDomainObjExitMonitor(driver, vm) < 0)\n            goto cleanup;\n\n        if (rc < 0)\n            goto cleanup;\n\n        virJSONValueFree(vcpuprops);\n    }\n\n    ret = 0;\n\n cleanup:\n    qemuCgroupEmulatorAllNodesRestore(emulatorCgroup);\n    VIR_FREE(bootHotplug);\n    virJSONValueFree(vcpuprops);\n    return ret;\n}\n\n\nstatic bool\nqemuProcessDropUnknownCPUFeatures(const char *name,\n                                  virCPUFeaturePolicy policy,\n                                  void *opaque)\n{\n    const char **features = opaque;\n\n    if (policy != VIR_CPU_FEATURE_DISABLE &&\n        policy != VIR_CPU_FEATURE_FORBID)\n        return true;\n\n    if (g_strv_contains(features, name))\n        return true;\n\n    /* Features unknown to QEMU are implicitly disabled, we can just drop them\n     * from the definition. */\n    return false;\n}\n\n\nstatic int\nqemuProcessUpdateGuestCPU(virDomainDefPtr def,\n                          virQEMUCapsPtr qemuCaps,\n                          virArch hostarch,\n                          unsigned int flags)\n{\n    if (!def->cpu)\n        return 0;\n\n    /* nothing to do if only topology part of CPU def is used */\n    if (def->cpu->mode == VIR_CPU_MODE_CUSTOM && !def->cpu->model)\n        return 0;\n\n    /* Old libvirt added host CPU model to host-model CPUs for migrations,\n     * while new libvirt just turns host-model into custom mode. We need\n     * to fix the mode to maintain backward compatibility and to avoid\n     * the CPU model to be replaced in virCPUUpdate.\n     */\n    if (!(flags & VIR_QEMU_PROCESS_START_NEW) &&\n        ARCH_IS_X86(def->os.arch) &&\n        def->cpu->mode == VIR_CPU_MODE_HOST_MODEL &&\n        def->cpu->model) {\n        def->cpu->mode = VIR_CPU_MODE_CUSTOM;\n    }\n\n    if (!virQEMUCapsIsCPUModeSupported(qemuCaps, hostarch, def->virtType,\n                                       def->cpu->mode, def->os.machine)) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"CPU mode '%s' for %s %s domain on %s host is not \"\n                         \"supported by hypervisor\"),\n                       virCPUModeTypeToString(def->cpu->mode),\n                       virArchToString(def->os.arch),\n                       virDomainVirtTypeToString(def->virtType),\n                       virArchToString(hostarch));\n        return -1;\n    }\n\n    if (virCPUConvertLegacy(hostarch, def->cpu) < 0)\n        return -1;\n\n    /* nothing to update for host-passthrough / maximum */\n    if (def->cpu->mode != VIR_CPU_MODE_HOST_PASSTHROUGH &&\n        def->cpu->mode != VIR_CPU_MODE_MAXIMUM) {\n        g_autoptr(virDomainCapsCPUModels) cpuModels = NULL;\n\n        if (def->cpu->check == VIR_CPU_CHECK_PARTIAL &&\n            virCPUCompare(hostarch,\n                          virQEMUCapsGetHostModel(qemuCaps, def->virtType,\n                                                  VIR_QEMU_CAPS_HOST_CPU_FULL),\n                          def->cpu, true) < 0)\n            return -1;\n\n        if (virCPUUpdate(def->os.arch, def->cpu,\n                         virQEMUCapsGetHostModel(qemuCaps, def->virtType,\n                                                 VIR_QEMU_CAPS_HOST_CPU_MIGRATABLE)) < 0)\n            return -1;\n\n        cpuModels = virQEMUCapsGetCPUModels(qemuCaps, def->virtType, NULL, NULL);\n\n        if (virCPUTranslate(def->os.arch, def->cpu, cpuModels) < 0)\n            return -1;\n\n        def->cpu->fallback = VIR_CPU_FALLBACK_FORBID;\n    }\n\n    if (virCPUDefFilterFeatures(def->cpu, virQEMUCapsCPUFilterFeatures,\n                                &def->os.arch) < 0)\n        return -1;\n\n    if (ARCH_IS_X86(def->os.arch)) {\n        g_auto(GStrv) features = NULL;\n\n        if (virQEMUCapsGetCPUFeatures(qemuCaps, def->virtType, false, &features) < 0)\n            return -1;\n\n        if (features &&\n            virCPUDefFilterFeatures(def->cpu, qemuProcessDropUnknownCPUFeatures,\n                                    features) < 0)\n            return -1;\n    }\n\n    return 0;\n}\n\n\nstatic int\nqemuProcessPrepareDomainNUMAPlacement(virDomainObjPtr vm)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    g_autofree char *nodeset = NULL;\n    g_autoptr(virBitmap) numadNodeset = NULL;\n    g_autoptr(virBitmap) hostMemoryNodeset = NULL;\n    g_autoptr(virCapsHostNUMA) caps = NULL;\n\n    /* Get the advisory nodeset from numad if 'placement' of\n     * either <vcpu> or <numatune> is 'auto'.\n     */\n    if (!virDomainDefNeedsPlacementAdvice(vm->def))\n        return 0;\n\n    nodeset = virNumaGetAutoPlacementAdvice(virDomainDefGetVcpus(vm->def),\n                                            virDomainDefGetMemoryTotal(vm->def));\n\n    if (!nodeset)\n        return -1;\n\n    if (!(hostMemoryNodeset = virNumaGetHostMemoryNodeset()))\n        return -1;\n\n    VIR_DEBUG(\"Nodeset returned from numad: %s\", nodeset);\n\n    if (virBitmapParse(nodeset, &numadNodeset, VIR_DOMAIN_CPUMASK_LEN) < 0)\n        return -1;\n\n    if (!(caps = virCapabilitiesHostNUMANewHost()))\n        return -1;\n\n    /* numad may return a nodeset that only contains cpus but cgroups don't play\n     * well with that. Set the autoCpuset from all cpus from that nodeset, but\n     * assign autoNodeset only with nodes containing memory. */\n    if (!(priv->autoCpuset = virCapabilitiesHostNUMAGetCpus(caps, numadNodeset)))\n        return -1;\n\n    virBitmapIntersect(numadNodeset, hostMemoryNodeset);\n\n    priv->autoNodeset = g_steal_pointer(&numadNodeset);\n\n    return 0;\n}\n\n\nstatic int\nqemuProcessPrepareDomainStorage(virQEMUDriverPtr driver,\n                                virDomainObjPtr vm,\n                                qemuDomainObjPrivatePtr priv,\n                                virQEMUDriverConfigPtr cfg,\n                                unsigned int flags)\n{\n    size_t i;\n    bool cold_boot = flags & VIR_QEMU_PROCESS_START_COLD;\n\n    for (i = vm->def->ndisks; i > 0; i--) {\n        size_t idx = i - 1;\n        virDomainDiskDefPtr disk = vm->def->disks[idx];\n\n        if (virDomainDiskTranslateSourcePool(disk) < 0) {\n            if (qemuDomainCheckDiskStartupPolicy(driver, vm, idx, cold_boot) < 0)\n                return -1;\n\n            /* disk source was dropped */\n            continue;\n        }\n\n        if (qemuDomainPrepareDiskSource(disk, priv, cfg) < 0)\n            return -1;\n    }\n\n    return 0;\n}\n\n\nstatic int\nqemuProcessPrepareDomainHostdevs(virDomainObjPtr vm,\n                                 qemuDomainObjPrivatePtr priv)\n{\n    size_t i;\n\n    for (i = 0; i < vm->def->nhostdevs; i++) {\n        virDomainHostdevDefPtr hostdev = vm->def->hostdevs[i];\n\n        if (qemuDomainPrepareHostdev(hostdev, priv) < 0)\n            return -1;\n    }\n\n    return 0;\n}\n\n\nint\nqemuProcessPrepareHostHostdev(virDomainHostdevDefPtr hostdev)\n{\n    if (virHostdevIsSCSIDevice(hostdev)) {\n        virDomainHostdevSubsysSCSIPtr scsisrc = &hostdev->source.subsys.u.scsi;\n\n        switch ((virDomainHostdevSCSIProtocolType) scsisrc->protocol) {\n        case VIR_DOMAIN_HOSTDEV_SCSI_PROTOCOL_TYPE_NONE: {\n            virDomainHostdevSubsysSCSIHostPtr scsihostsrc = &scsisrc->u.host;\n            virStorageSourcePtr src = scsisrc->u.host.src;\n            g_autofree char *devstr = NULL;\n\n            if (!(devstr = virSCSIDeviceGetSgName(NULL,\n                                                  scsihostsrc->adapter,\n                                                  scsihostsrc->bus,\n                                                  scsihostsrc->target,\n                                                  scsihostsrc->unit)))\n                return -1;\n\n            src->path = g_strdup_printf(\"/dev/%s\", devstr);\n            break;\n        }\n\n        case VIR_DOMAIN_HOSTDEV_SCSI_PROTOCOL_TYPE_ISCSI:\n            break;\n\n        case VIR_DOMAIN_HOSTDEV_SCSI_PROTOCOL_TYPE_LAST:\n        default:\n            virReportEnumRangeError(virDomainHostdevSCSIProtocolType, scsisrc->protocol);\n            return -1;\n        }\n    }\n\n    return 0;\n}\n\n\nstatic int\nqemuProcessPrepareHostHostdevs(virDomainObjPtr vm)\n{\n    size_t i;\n\n    for (i = 0; i < vm->def->nhostdevs; i++) {\n        virDomainHostdevDefPtr hostdev = vm->def->hostdevs[i];\n\n        if (qemuProcessPrepareHostHostdev(hostdev) < 0)\n            return -1;\n    }\n\n    return 0;\n}\n\n\nstatic void\nqemuProcessPrepareAllowReboot(virDomainObjPtr vm)\n{\n    virDomainDefPtr def = vm->def;\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n\n    if (priv->allowReboot != VIR_TRISTATE_BOOL_ABSENT)\n        return;\n\n    if (def->onReboot == VIR_DOMAIN_LIFECYCLE_ACTION_DESTROY &&\n        def->onPoweroff == VIR_DOMAIN_LIFECYCLE_ACTION_DESTROY &&\n        (def->onCrash == VIR_DOMAIN_LIFECYCLE_ACTION_DESTROY ||\n         def->onCrash == VIR_DOMAIN_LIFECYCLE_ACTION_COREDUMP_DESTROY)) {\n        priv->allowReboot = VIR_TRISTATE_BOOL_NO;\n    } else {\n        priv->allowReboot = VIR_TRISTATE_BOOL_YES;\n    }\n}\n\n\nstatic int\nqemuProcessUpdateSEVInfo(virDomainObjPtr vm)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    virQEMUCapsPtr qemuCaps = priv->qemuCaps;\n    virDomainSEVDefPtr sev = vm->def->sev;\n    virSEVCapabilityPtr sevCaps = NULL;\n\n    /* if platform specific info like 'cbitpos' and 'reducedPhysBits' have\n     * not been supplied, we need to autofill them from caps now as both are\n     * mandatory on QEMU cmdline\n     */\n    sevCaps = virQEMUCapsGetSEVCapabilities(qemuCaps);\n    if (!sev->haveCbitpos) {\n        sev->cbitpos = sevCaps->cbitpos;\n        sev->haveCbitpos = true;\n    }\n\n    if (!sev->haveReducedPhysBits) {\n        sev->reduced_phys_bits = sevCaps->reduced_phys_bits;\n        sev->haveReducedPhysBits = true;\n    }\n\n    return 0;\n}\n\n\n/**\n * qemuProcessPrepareDomain:\n * @driver: qemu driver\n * @vm: domain object\n * @flags: qemuProcessStartFlags\n *\n * This function groups all code that modifies only live XML of a domain which\n * is about to start and it's the only place to do those modifications.\n *\n * Flag VIR_QEMU_PROCESS_START_PRETEND tells, that we don't want to actually\n * start the domain but create a valid qemu command.  If some code shouldn't be\n * executed in this case, make sure to check this flag.\n *\n * TODO: move all XML modification from qemuBuildCommandLine into this function\n */\nint\nqemuProcessPrepareDomain(virQEMUDriverPtr driver,\n                         virDomainObjPtr vm,\n                         unsigned int flags)\n{\n    size_t i;\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    g_autoptr(virQEMUDriverConfig) cfg = virQEMUDriverGetConfig(driver);\n\n    priv->machineName = qemuDomainGetMachineName(vm);\n    if (!priv->machineName)\n        return -1;\n\n    if (!(flags & VIR_QEMU_PROCESS_START_PRETEND)) {\n        /* If you are using a SecurityDriver with dynamic labelling,\n           then generate a security label for isolation */\n        VIR_DEBUG(\"Generating domain security label (if required)\");\n        if (qemuSecurityGenLabel(driver->securityManager, vm->def) < 0) {\n            virDomainAuditSecurityLabel(vm, false);\n            return -1;\n        }\n        virDomainAuditSecurityLabel(vm, true);\n\n        if (qemuProcessPrepareDomainNUMAPlacement(vm) < 0)\n            return -1;\n    }\n\n    /* Whether we should use virtlogd as stdio handler for character\n     * devices source backend. */\n    if (cfg->stdioLogD &&\n        virQEMUCapsGet(priv->qemuCaps, QEMU_CAPS_CHARDEV_FILE_APPEND)) {\n        priv->chardevStdioLogd = true;\n    }\n\n    /* Track if this domain remembers original owner */\n    priv->rememberOwner = cfg->rememberOwner;\n\n    qemuProcessPrepareAllowReboot(vm);\n\n    /*\n     * Normally PCI addresses are assigned in the virDomainCreate\n     * or virDomainDefine methods. We might still need to assign\n     * some here to cope with the question of upgrades. Regardless\n     * we also need to populate the PCI address set cache for later\n     * use in hotplug\n     */\n    VIR_DEBUG(\"Assigning domain PCI addresses\");\n    if ((qemuDomainAssignAddresses(vm->def, priv->qemuCaps, driver, vm,\n                                   !!(flags & VIR_QEMU_PROCESS_START_NEW))) < 0) {\n        return -1;\n    }\n\n    if (qemuAssignDeviceAliases(vm->def, priv->qemuCaps) < 0)\n        return -1;\n\n    VIR_DEBUG(\"Setting graphics devices\");\n    if (qemuProcessSetupGraphics(driver, vm, priv->qemuCaps, flags) < 0)\n        return -1;\n\n    VIR_DEBUG(\"Create domain masterKey\");\n    if (qemuDomainMasterKeyCreate(vm) < 0)\n        return -1;\n\n    VIR_DEBUG(\"Setting up storage\");\n    if (qemuProcessPrepareDomainStorage(driver, vm, priv, cfg, flags) < 0)\n        return -1;\n\n    VIR_DEBUG(\"Setting up host devices\");\n    if (qemuProcessPrepareDomainHostdevs(vm, priv) < 0)\n        return -1;\n\n    VIR_DEBUG(\"Prepare chardev source backends for TLS\");\n    qemuDomainPrepareChardevSource(vm->def, cfg);\n\n    VIR_DEBUG(\"Prepare device secrets\");\n    if (qemuDomainSecretPrepare(driver, vm) < 0)\n        return -1;\n\n    VIR_DEBUG(\"Prepare bios/uefi paths\");\n    if (qemuFirmwareFillDomain(driver, vm->def, flags) < 0)\n        return -1;\n    if (qemuDomainInitializePflashStorageSource(vm) < 0)\n        return -1;\n\n    VIR_DEBUG(\"Preparing external devices\");\n    if (qemuExtDevicesPrepareDomain(driver, vm) < 0)\n        return -1;\n\n    if (flags & VIR_QEMU_PROCESS_START_NEW) {\n        VIR_DEBUG(\"Aligning guest memory\");\n        if (qemuDomainAlignMemorySizes(vm->def) < 0)\n            return -1;\n    }\n\n    for (i = 0; i < vm->def->nchannels; i++) {\n        if (qemuDomainPrepareChannel(vm->def->channels[i],\n                                     priv->channelTargetDir) < 0)\n            return -1;\n    }\n\n    if (!(priv->monConfig = virDomainChrSourceDefNew(driver->xmlopt)))\n        return -1;\n\n    VIR_DEBUG(\"Preparing monitor state\");\n    if (qemuProcessPrepareMonitorChr(priv->monConfig, priv->libDir) < 0)\n        return -1;\n\n    priv->monError = false;\n    priv->monStart = 0;\n    priv->runningReason = VIR_DOMAIN_RUNNING_UNKNOWN;\n    priv->pausedReason = VIR_DOMAIN_PAUSED_UNKNOWN;\n\n    VIR_DEBUG(\"Updating guest CPU definition\");\n    if (qemuProcessUpdateGuestCPU(vm->def, priv->qemuCaps, driver->hostarch, flags) < 0)\n        return -1;\n\n    for (i = 0; i < vm->def->nshmems; i++)\n        qemuDomainPrepareShmemChardev(vm->def->shmems[i]);\n\n    if (vm->def->sev) {\n        VIR_DEBUG(\"Updating SEV platform info\");\n        if (qemuProcessUpdateSEVInfo(vm) < 0)\n            return -1;\n    }\n\n    return 0;\n}\n\n\nstatic int\nqemuProcessSEVCreateFile(virDomainObjPtr vm,\n                         const char *name,\n                         const char *data)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    virQEMUDriverPtr driver = priv->driver;\n    g_autofree char *configFile = NULL;\n\n    if (!(configFile = virFileBuildPath(priv->libDir, name, \".base64\")))\n        return -1;\n\n    if (virFileRewriteStr(configFile, S_IRUSR | S_IWUSR, data) < 0) {\n        virReportSystemError(errno, _(\"failed to write data to config '%s'\"),\n                             configFile);\n        return -1;\n    }\n\n    if (qemuSecurityDomainSetPathLabel(driver, vm, configFile, true) < 0)\n        return -1;\n\n    return 0;\n}\n\n\nstatic int\nqemuProcessPrepareSEVGuestInput(virDomainObjPtr vm)\n{\n    virDomainSEVDefPtr sev = vm->def->sev;\n\n    if (!sev)\n        return 0;\n\n    VIR_DEBUG(\"Preparing SEV guest\");\n\n    if (sev->dh_cert) {\n        if (qemuProcessSEVCreateFile(vm, \"dh_cert\", sev->dh_cert) < 0)\n            return -1;\n    }\n\n    if (sev->session) {\n        if (qemuProcessSEVCreateFile(vm, \"session\", sev->session) < 0)\n            return -1;\n    }\n\n    return 0;\n}\n\n\nstatic int\nqemuProcessPrepareHostStorage(virQEMUDriverPtr driver,\n                              virDomainObjPtr vm,\n                              unsigned int flags)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    size_t i;\n    bool cold_boot = flags & VIR_QEMU_PROCESS_START_COLD;\n    bool blockdev = virQEMUCapsGet(priv->qemuCaps, QEMU_CAPS_BLOCKDEV);\n\n    for (i = vm->def->ndisks; i > 0; i--) {\n        size_t idx = i - 1;\n        virDomainDiskDefPtr disk = vm->def->disks[idx];\n\n        if (virStorageSourceIsEmpty(disk->src))\n            continue;\n\n        /* backing chain needs to be redetected if we aren't using blockdev */\n        if (!blockdev || qemuDiskBusIsSD(disk->bus))\n            virStorageSourceBackingStoreClear(disk->src);\n\n        /*\n         * Go to applying startup policy for optional disk with nonexistent\n         * source file immediately as determining chain will surely fail\n         * and we don't want noisy error notice in logs for this case.\n         */\n        if (qemuDomainDiskIsMissingLocalOptional(disk) && cold_boot)\n            VIR_INFO(\"optional disk '%s' source file is missing, \"\n                     \"skip checking disk chain\", disk->dst);\n        else if (qemuDomainDetermineDiskChain(driver, vm, disk, NULL, true) >= 0)\n            continue;\n\n        if (qemuDomainCheckDiskStartupPolicy(driver, vm, idx, cold_boot) >= 0)\n            continue;\n\n        return -1;\n    }\n\n    return 0;\n}\n\n\nint\nqemuProcessOpenVhostVsock(virDomainVsockDefPtr vsock)\n{\n    qemuDomainVsockPrivatePtr priv = (qemuDomainVsockPrivatePtr)vsock->privateData;\n    const char *vsock_path = \"/dev/vhost-vsock\";\n    int fd;\n\n    if ((fd = open(vsock_path, O_RDWR)) < 0) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       \"%s\", _(\"unable to open vhost-vsock device\"));\n        return -1;\n    }\n\n    if (vsock->auto_cid == VIR_TRISTATE_BOOL_YES) {\n        if (virVsockAcquireGuestCid(fd, &vsock->guest_cid) < 0)\n            goto error;\n    } else {\n        if (virVsockSetGuestCid(fd, vsock->guest_cid) < 0)\n            goto error;\n    }\n\n    priv->vhostfd = fd;\n    return 0;\n\n error:\n    VIR_FORCE_CLOSE(fd);\n    return -1;\n}\n\n\n/**\n * qemuProcessPrepareHost:\n * @driver: qemu driver\n * @vm: domain object\n * @flags: qemuProcessStartFlags\n *\n * This function groups all code that modifies host system (which also may\n * update live XML) to prepare environment for a domain which is about to start\n * and it's the only place to do those modifications.\n *\n * TODO: move all host modification from qemuBuildCommandLine into this function\n */\nint\nqemuProcessPrepareHost(virQEMUDriverPtr driver,\n                       virDomainObjPtr vm,\n                       unsigned int flags)\n{\n    unsigned int hostdev_flags = 0;\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    g_autoptr(virQEMUDriverConfig) cfg = virQEMUDriverGetConfig(driver);\n\n    if (qemuPrepareNVRAM(cfg, vm) < 0)\n        return -1;\n\n    if (vm->def->vsock) {\n        if (qemuProcessOpenVhostVsock(vm->def->vsock) < 0)\n            return -1;\n    }\n    /* network devices must be \"prepared\" before hostdevs, because\n     * setting up a network device might create a new hostdev that\n     * will need to be setup.\n     */\n    VIR_DEBUG(\"Preparing network devices\");\n    if (qemuProcessNetworkPrepareDevices(driver, vm) < 0)\n        return -1;\n\n    /* Must be run before security labelling */\n    VIR_DEBUG(\"Preparing host devices\");\n    if (!cfg->relaxedACS)\n        hostdev_flags |= VIR_HOSTDEV_STRICT_ACS_CHECK;\n    if (flags & VIR_QEMU_PROCESS_START_NEW)\n        hostdev_flags |= VIR_HOSTDEV_COLD_BOOT;\n    if (qemuHostdevPrepareDomainDevices(driver, vm->def, priv->qemuCaps,\n                                        hostdev_flags) < 0)\n        return -1;\n\n    VIR_DEBUG(\"Preparing chr devices\");\n    if (virDomainChrDefForeach(vm->def,\n                               true,\n                               qemuProcessPrepareChardevDevice,\n                               NULL) < 0)\n        return -1;\n\n    if (qemuProcessBuildDestroyMemoryPaths(driver, vm, NULL, true) < 0)\n        return -1;\n\n    /* Ensure no historical cgroup for this VM is lying around bogus\n     * settings */\n    VIR_DEBUG(\"Ensuring no historical cgroup is lying around\");\n    qemuRemoveCgroup(vm);\n\n    if (virFileMakePath(cfg->logDir) < 0) {\n        virReportSystemError(errno,\n                             _(\"cannot create log directory %s\"),\n                             cfg->logDir);\n        return -1;\n    }\n\n    VIR_FREE(priv->pidfile);\n    if (!(priv->pidfile = virPidFileBuildPath(cfg->stateDir, vm->def->name))) {\n        virReportSystemError(errno,\n                             \"%s\", _(\"Failed to build pidfile path.\"));\n        return -1;\n    }\n\n    if (unlink(priv->pidfile) < 0 &&\n        errno != ENOENT) {\n        virReportSystemError(errno,\n                             _(\"Cannot remove stale PID file %s\"),\n                             priv->pidfile);\n        return -1;\n    }\n\n    /*\n     * Create all per-domain directories in order to make sure domain\n     * with any possible seclabels can access it.\n     */\n    if (qemuProcessMakeDir(driver, vm, priv->libDir) < 0 ||\n        qemuProcessMakeDir(driver, vm, priv->channelTargetDir) < 0)\n        return -1;\n\n    VIR_DEBUG(\"Write domain masterKey\");\n    if (qemuDomainWriteMasterKeyFile(driver, vm) < 0)\n        return -1;\n\n    VIR_DEBUG(\"Preparing disks (host)\");\n    if (qemuProcessPrepareHostStorage(driver, vm, flags) < 0)\n        return -1;\n\n    VIR_DEBUG(\"Preparing hostdevs (host-side)\");\n    if (qemuProcessPrepareHostHostdevs(vm) < 0)\n        return -1;\n\n    VIR_DEBUG(\"Preparing external devices\");\n    if (qemuExtDevicesPrepareHost(driver, vm) < 0)\n        return -1;\n\n    if (qemuProcessPrepareSEVGuestInput(vm) < 0)\n        return -1;\n\n    return 0;\n}\n\n\n/**\n * qemuProcessGenID:\n * @vm: Pointer to domain object\n * @flags: qemuProcessStartFlags\n *\n * If this domain is requesting to use genid, then update the GUID\n * value if the VIR_QEMU_PROCESS_START_GEN_VMID flag is set. This\n * flag is set on specific paths during domain start processing when\n * there is the possibility that the VM is potentially re-executing\n * something that has already been executed before.\n */\nstatic int\nqemuProcessGenID(virDomainObjPtr vm,\n                 unsigned int flags)\n{\n    if (!vm->def->genidRequested)\n        return 0;\n\n    /* If we are coming from a path where we must provide a new gen id\n     * value regardless of whether it was previously generated or provided,\n     * then generate a new GUID value before we build the command line. */\n    if (flags & VIR_QEMU_PROCESS_START_GEN_VMID) {\n        if (virUUIDGenerate(vm->def->genid) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"failed to regenerate genid\"));\n            return -1;\n        }\n    }\n\n    return 0;\n}\n\n\n/**\n * qemuProcessSetupDiskThrottlingBlockdev:\n *\n * Sets up disk trottling for -blockdev via block_set_io_throttle monitor\n * command. This hack should be replaced by proper use of the 'throttle'\n * blockdev driver in qemu once it will support changing of the throttle group.\n * Same hack is done in qemuDomainAttachDiskGeneric.\n */\nstatic int\nqemuProcessSetupDiskThrottlingBlockdev(virQEMUDriverPtr driver,\n                                       virDomainObjPtr vm,\n                                       qemuDomainAsyncJob asyncJob)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    size_t i;\n    int ret = -1;\n\n    if (!virQEMUCapsGet(priv->qemuCaps, QEMU_CAPS_BLOCKDEV))\n        return 0;\n\n    VIR_DEBUG(\"Setting up disk throttling for -blockdev via block_set_io_throttle\");\n\n    if (qemuDomainObjEnterMonitorAsync(driver, vm, asyncJob) < 0)\n        return -1;\n\n    for (i = 0; i < vm->def->ndisks; i++) {\n        virDomainDiskDefPtr disk = vm->def->disks[i];\n        qemuDomainDiskPrivatePtr diskPriv = QEMU_DOMAIN_DISK_PRIVATE(disk);\n\n        /* sd-cards are instantiated via -drive */\n        if (qemuDiskBusIsSD(disk->bus))\n            continue;\n\n        /* Setting throttling for empty drives fails */\n        if (virStorageSourceIsEmpty(disk->src))\n            continue;\n\n        if (!qemuDiskConfigBlkdeviotuneEnabled(disk))\n            continue;\n\n        if (qemuMonitorSetBlockIoThrottle(qemuDomainGetMonitor(vm), NULL,\n                                          diskPriv->qomName, &disk->blkdeviotune,\n                                          true, true, true) < 0)\n            goto cleanup;\n    }\n\n    ret = 0;\n\n cleanup:\n    if (qemuDomainObjExitMonitor(driver, vm) < 0)\n        ret = -1;\n    return ret;\n}\n\n\nstatic int\nqemuProcessEnableDomainNamespaces(virQEMUDriverPtr driver,\n                                  virDomainObjPtr vm)\n{\n    g_autoptr(virQEMUDriverConfig) cfg = virQEMUDriverGetConfig(driver);\n\n    if (virBitmapIsBitSet(cfg->namespaces, QEMU_DOMAIN_NS_MOUNT) &&\n        qemuDomainEnableNamespace(vm, QEMU_DOMAIN_NS_MOUNT) < 0)\n        return -1;\n\n    return 0;\n}\n\n\nstatic int\nqemuProcessEnablePerf(virDomainObjPtr vm)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    size_t i;\n\n    if (!(priv->perf = virPerfNew()))\n        return -1;\n\n    for (i = 0; i < VIR_PERF_EVENT_LAST; i++) {\n        if (vm->def->perf.events[i] == VIR_TRISTATE_BOOL_YES &&\n            virPerfEventEnable(priv->perf, i, vm->pid) < 0)\n            return -1;\n    }\n\n    return 0;\n}\n\n\n/**\n * qemuProcessLaunch:\n *\n * Launch a new QEMU process with stopped virtual CPUs.\n *\n * The caller is supposed to call qemuProcessStop with appropriate\n * flags in case of failure.\n *\n * Returns 0 on success,\n *        -1 on error which happened before devices were labeled and thus\n *           there is no need to restore them,\n *        -2 on error requesting security labels to be restored.\n */\nint\nqemuProcessLaunch(virConnectPtr conn,\n                  virQEMUDriverPtr driver,\n                  virDomainObjPtr vm,\n                  qemuDomainAsyncJob asyncJob,\n                  qemuProcessIncomingDefPtr incoming,\n                  virDomainMomentObjPtr snapshot,\n                  virNetDevVPortProfileOp vmop,\n                  unsigned int flags)\n{\n    int ret = -1;\n    int rv;\n    int logfile = -1;\n    g_autoptr(qemuDomainLogContext) logCtxt = NULL;\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    g_autoptr(virCommand) cmd = NULL;\n    struct qemuProcessHookData hookData;\n    g_autoptr(virQEMUDriverConfig) cfg = NULL;\n    size_t nnicindexes = 0;\n    g_autofree int *nicindexes = NULL;\n\n    VIR_DEBUG(\"conn=%p driver=%p vm=%p name=%s if=%d asyncJob=%d \"\n              \"incoming.launchURI=%s incoming.deferredURI=%s \"\n              \"incoming.fd=%d incoming.path=%s \"\n              \"snapshot=%p vmop=%d flags=0x%x\",\n              conn, driver, vm, vm->def->name, vm->def->id, asyncJob,\n              NULLSTR(incoming ? incoming->launchURI : NULL),\n              NULLSTR(incoming ? incoming->deferredURI : NULL),\n              incoming ? incoming->fd : -1,\n              NULLSTR(incoming ? incoming->path : NULL),\n              snapshot, vmop, flags);\n\n    /* Okay, these are just internal flags,\n     * but doesn't hurt to check */\n    virCheckFlags(VIR_QEMU_PROCESS_START_COLD |\n                  VIR_QEMU_PROCESS_START_PAUSED |\n                  VIR_QEMU_PROCESS_START_AUTODESTROY |\n                  VIR_QEMU_PROCESS_START_NEW |\n                  VIR_QEMU_PROCESS_START_GEN_VMID, -1);\n\n    cfg = virQEMUDriverGetConfig(driver);\n\n    if (flags & VIR_QEMU_PROCESS_START_AUTODESTROY) {\n        if (!conn) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Domain autodestroy requires a connection handle\"));\n            return -1;\n        }\n        if (driver->embeddedRoot) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Domain autodestroy not supported for embedded drivers yet\"));\n            return -1;\n        }\n    }\n\n    hookData.vm = vm;\n    hookData.driver = driver;\n    /* We don't increase cfg's reference counter here. */\n    hookData.cfg = cfg;\n\n    VIR_DEBUG(\"Creating domain log file\");\n    if (!(logCtxt = qemuDomainLogContextNew(driver, vm,\n                                            QEMU_DOMAIN_LOG_CONTEXT_MODE_START))) {\n        virLastErrorPrefixMessage(\"%s\", _(\"can't connect to virtlogd\"));\n        goto cleanup;\n    }\n    logfile = qemuDomainLogContextGetWriteFD(logCtxt);\n\n    if (qemuProcessGenID(vm, flags) < 0)\n        goto cleanup;\n\n    if (qemuExtDevicesStart(driver, vm,\n                            qemuDomainLogContextGetManager(logCtxt),\n                            incoming != NULL) < 0)\n        goto cleanup;\n\n    VIR_DEBUG(\"Building emulator command line\");\n    if (!(cmd = qemuBuildCommandLine(driver,\n                                     qemuDomainLogContextGetManager(logCtxt),\n                                     driver->securityManager,\n                                     vm,\n                                     incoming ? incoming->launchURI : NULL,\n                                     snapshot, vmop,\n                                     false,\n                                     qemuCheckFips(vm),\n                                     &nnicindexes, &nicindexes, 0)))\n        goto cleanup;\n\n    if (incoming && incoming->fd != -1)\n        virCommandPassFD(cmd, incoming->fd, 0);\n\n    /* now that we know it is about to start call the hook if present */\n    if (qemuProcessStartHook(driver, vm,\n                             VIR_HOOK_QEMU_OP_START,\n                             VIR_HOOK_SUBOP_BEGIN) < 0)\n        goto cleanup;\n\n    qemuLogOperation(vm, \"starting up\", cmd, logCtxt);\n\n    qemuDomainObjCheckTaint(driver, vm, logCtxt, incoming != NULL);\n\n    qemuDomainLogContextMarkPosition(logCtxt);\n\n    VIR_DEBUG(\"Building mount namespace\");\n\n    if (qemuProcessEnableDomainNamespaces(driver, vm) < 0)\n        goto cleanup;\n\n    VIR_DEBUG(\"Setting up raw IO\");\n    if (qemuProcessSetupRawIO(driver, vm, cmd) < 0)\n        goto cleanup;\n\n    virCommandSetPreExecHook(cmd, qemuProcessHook, &hookData);\n    virCommandSetMaxProcesses(cmd, cfg->maxProcesses);\n    virCommandSetMaxFiles(cmd, cfg->maxFiles);\n    virCommandSetMaxCoreSize(cmd, cfg->maxCore);\n    virCommandSetUmask(cmd, 0x002);\n\n    VIR_DEBUG(\"Setting up security labelling\");\n    if (qemuSecuritySetChildProcessLabel(driver->securityManager,\n                                         vm->def, cmd) < 0)\n        goto cleanup;\n\n    virCommandSetOutputFD(cmd, &logfile);\n    virCommandSetErrorFD(cmd, &logfile);\n    virCommandNonblockingFDs(cmd);\n    virCommandSetPidFile(cmd, priv->pidfile);\n    virCommandDaemonize(cmd);\n    virCommandRequireHandshake(cmd);\n\n    if (qemuSecurityPreFork(driver->securityManager) < 0)\n        goto cleanup;\n    rv = virCommandRun(cmd, NULL);\n    qemuSecurityPostFork(driver->securityManager);\n\n    /* wait for qemu process to show up */\n    if (rv == 0) {\n        if ((rv = virPidFileReadPath(priv->pidfile, &vm->pid)) < 0) {\n            virReportSystemError(-rv,\n                                 _(\"Domain %s didn't show up\"),\n                                 vm->def->name);\n            goto cleanup;\n        }\n        VIR_DEBUG(\"QEMU vm=%p name=%s running with pid=%lld\",\n                  vm, vm->def->name, (long long)vm->pid);\n    } else {\n        VIR_DEBUG(\"QEMU vm=%p name=%s failed to spawn\",\n                  vm, vm->def->name);\n        goto cleanup;\n    }\n\n    VIR_DEBUG(\"Writing early domain status to disk\");\n    if (virDomainObjSave(vm, driver->xmlopt, cfg->stateDir) < 0)\n        goto cleanup;\n\n    VIR_DEBUG(\"Waiting for handshake from child\");\n    if (virCommandHandshakeWait(cmd) < 0) {\n        /* Read errors from child that occurred between fork and exec. */\n        qemuProcessReportLogError(logCtxt,\n                                  _(\"Process exited prior to exec\"));\n        goto cleanup;\n    }\n\n    VIR_DEBUG(\"Building domain mount namespace (if required)\");\n    if (qemuDomainBuildNamespace(cfg, vm) < 0)\n        goto cleanup;\n\n    VIR_DEBUG(\"Setting up domain cgroup (if required)\");\n    if (qemuSetupCgroup(vm, nnicindexes, nicindexes) < 0)\n        goto cleanup;\n\n    VIR_DEBUG(\"Setting up domain perf (if required)\");\n    if (qemuProcessEnablePerf(vm) < 0)\n        goto cleanup;\n\n    /* This must be done after cgroup placement to avoid resetting CPU\n     * affinity */\n    if (qemuProcessInitCpuAffinity(vm) < 0)\n        goto cleanup;\n\n    VIR_DEBUG(\"Setting emulator tuning/settings\");\n    if (qemuProcessSetupEmulator(vm) < 0)\n        goto cleanup;\n\n    VIR_DEBUG(\"Setting cgroup for external devices (if required)\");\n    if (qemuSetupCgroupForExtDevices(vm, driver) < 0)\n        goto cleanup;\n\n    VIR_DEBUG(\"Setting up resctrl\");\n    if (qemuProcessResctrlCreate(driver, vm) < 0)\n        goto cleanup;\n\n    VIR_DEBUG(\"Setting up managed PR daemon\");\n    if (virDomainDefHasManagedPR(vm->def) &&\n        qemuProcessStartManagedPRDaemon(vm) < 0)\n        goto cleanup;\n\n    VIR_DEBUG(\"Setting domain security labels\");\n    if (qemuSecuritySetAllLabel(driver,\n                                vm,\n                                incoming ? incoming->path : NULL,\n                                incoming != NULL) < 0)\n        goto cleanup;\n\n    /* Security manager labeled all devices, therefore\n     * if any operation from now on fails, we need to ask the caller to\n     * restore labels.\n     */\n    ret = -2;\n\n    if (incoming && incoming->fd != -1) {\n        /* if there's an fd to migrate from, and it's a pipe, put the\n         * proper security label on it\n         */\n        struct stat stdin_sb;\n\n        VIR_DEBUG(\"setting security label on pipe used for migration\");\n\n        if (fstat(incoming->fd, &stdin_sb) < 0) {\n            virReportSystemError(errno,\n                                 _(\"cannot stat fd %d\"), incoming->fd);\n            goto cleanup;\n        }\n        if (S_ISFIFO(stdin_sb.st_mode) &&\n            qemuSecuritySetImageFDLabel(driver->securityManager,\n                                        vm->def, incoming->fd) < 0)\n            goto cleanup;\n    }\n\n    VIR_DEBUG(\"Labelling done, completing handshake to child\");\n    if (virCommandHandshakeNotify(cmd) < 0)\n        goto cleanup;\n    VIR_DEBUG(\"Handshake complete, child running\");\n\n    if (qemuDomainObjStartWorker(vm) < 0)\n        goto cleanup;\n\n    VIR_DEBUG(\"Waiting for monitor to show up\");\n    if (qemuProcessWaitForMonitor(driver, vm, asyncJob, logCtxt) < 0)\n        goto cleanup;\n\n    if (qemuConnectAgent(driver, vm) < 0)\n        goto cleanup;\n\n    VIR_DEBUG(\"Verifying and updating provided guest CPU\");\n    if (qemuProcessUpdateAndVerifyCPU(driver, vm, asyncJob) < 0)\n        goto cleanup;\n\n    VIR_DEBUG(\"setting up hotpluggable cpus\");\n    if (qemuDomainHasHotpluggableStartupVcpus(vm->def)) {\n        if (qemuDomainRefreshVcpuInfo(driver, vm, asyncJob, false) < 0)\n            goto cleanup;\n\n        if (qemuProcessValidateHotpluggableVcpus(vm->def) < 0)\n            goto cleanup;\n\n        if (qemuProcessSetupHotpluggableVcpus(driver, vm, asyncJob) < 0)\n            goto cleanup;\n    }\n\n    VIR_DEBUG(\"Refreshing VCPU info\");\n    if (qemuDomainRefreshVcpuInfo(driver, vm, asyncJob, false) < 0)\n        goto cleanup;\n\n    if (qemuDomainValidateVcpuInfo(vm) < 0)\n        goto cleanup;\n\n    qemuDomainVcpuPersistOrder(vm->def);\n\n    VIR_DEBUG(\"Detecting IOThread PIDs\");\n    if (qemuProcessDetectIOThreadPIDs(driver, vm, asyncJob) < 0)\n        goto cleanup;\n\n    VIR_DEBUG(\"Setting global CPU cgroup (if required)\");\n    if (qemuSetupGlobalCpuCgroup(vm) < 0)\n        goto cleanup;\n\n    VIR_DEBUG(\"Setting vCPU tuning/settings\");\n    if (qemuProcessSetupVcpus(vm) < 0)\n        goto cleanup;\n\n    VIR_DEBUG(\"Setting IOThread tuning/settings\");\n    if (qemuProcessSetupIOThreads(vm) < 0)\n        goto cleanup;\n\n    VIR_DEBUG(\"Setting emulator scheduler\");\n    if (vm->def->cputune.emulatorsched &&\n        virProcessSetScheduler(vm->pid,\n                               vm->def->cputune.emulatorsched->policy,\n                               vm->def->cputune.emulatorsched->priority) < 0)\n        goto cleanup;\n\n    VIR_DEBUG(\"Setting any required VM passwords\");\n    if (qemuProcessInitPasswords(driver, vm, asyncJob) < 0)\n        goto cleanup;\n\n    /* set default link states */\n    /* qemu doesn't support setting this on the command line, so\n     * enter the monitor */\n    VIR_DEBUG(\"Setting network link states\");\n    if (qemuProcessSetLinkStates(driver, vm, asyncJob) < 0)\n        goto cleanup;\n\n    VIR_DEBUG(\"Setting initial memory amount\");\n    if (qemuProcessSetupBalloon(driver, vm, asyncJob) < 0)\n        goto cleanup;\n\n    if (qemuProcessSetupDiskThrottlingBlockdev(driver, vm, asyncJob) < 0)\n        goto cleanup;\n\n    /* Since CPUs were not started yet, the balloon could not return the memory\n     * to the host and thus cur_balloon needs to be updated so that GetXMLdesc\n     * and friends return the correct size in case they can't grab the job */\n    if (!incoming && !snapshot &&\n        qemuProcessRefreshBalloonState(driver, vm, asyncJob) < 0)\n        goto cleanup;\n\n    if (flags & VIR_QEMU_PROCESS_START_AUTODESTROY &&\n        qemuProcessAutoDestroyAdd(driver, vm, conn) < 0)\n        goto cleanup;\n\n    VIR_DEBUG(\"Setting up transient disk\");\n    if (qemuSnapshotCreateDisksTransient(vm, asyncJob) < 0)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    qemuDomainSecretDestroy(vm);\n    return ret;\n}\n\n\n/**\n * qemuProcessRefreshState:\n * @driver: qemu driver data\n * @vm: domain to refresh\n * @asyncJob: async job type\n *\n * This function gathers calls to refresh qemu state after startup. This\n * function is called after a deferred migration finishes so that we can update\n * state influenced by the migration stream.\n */\nint\nqemuProcessRefreshState(virQEMUDriverPtr driver,\n                        virDomainObjPtr vm,\n                        qemuDomainAsyncJob asyncJob)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n\n    VIR_DEBUG(\"Fetching list of active devices\");\n    if (qemuDomainUpdateDeviceList(driver, vm, asyncJob) < 0)\n        return -1;\n\n    VIR_DEBUG(\"Updating info of memory devices\");\n    if (qemuDomainUpdateMemoryDeviceInfo(driver, vm, asyncJob) < 0)\n        return -1;\n\n    VIR_DEBUG(\"Detecting actual memory size for video device\");\n    if (qemuProcessUpdateVideoRamSize(driver, vm, asyncJob) < 0)\n        return -1;\n\n    VIR_DEBUG(\"Updating disk data\");\n    if (qemuProcessRefreshDisks(driver, vm, asyncJob) < 0)\n        return -1;\n    if (!virQEMUCapsGet(priv->qemuCaps, QEMU_CAPS_BLOCKDEV) &&\n        qemuBlockNodeNamesDetect(driver, vm, asyncJob) < 0)\n        return -1;\n\n    return 0;\n}\n\n\n/**\n * qemuProcessFinishStartup:\n *\n * Finish starting a new domain.\n */\nint\nqemuProcessFinishStartup(virQEMUDriverPtr driver,\n                         virDomainObjPtr vm,\n                         qemuDomainAsyncJob asyncJob,\n                         bool startCPUs,\n                         virDomainPausedReason pausedReason)\n{\n    g_autoptr(virQEMUDriverConfig) cfg = virQEMUDriverGetConfig(driver);\n\n    if (startCPUs) {\n        VIR_DEBUG(\"Starting domain CPUs\");\n        if (qemuProcessStartCPUs(driver, vm,\n                                 VIR_DOMAIN_RUNNING_BOOTED,\n                                 asyncJob) < 0) {\n            if (virGetLastErrorCode() == VIR_ERR_OK)\n                virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                               _(\"resume operation failed\"));\n            return -1;\n        }\n    } else {\n        virDomainObjSetState(vm, VIR_DOMAIN_PAUSED, pausedReason);\n    }\n\n    VIR_DEBUG(\"Writing domain status to disk\");\n    if (virDomainObjSave(vm, driver->xmlopt, cfg->stateDir) < 0)\n        return -1;\n\n    if (qemuProcessStartHook(driver, vm,\n                             VIR_HOOK_QEMU_OP_STARTED,\n                             VIR_HOOK_SUBOP_BEGIN) < 0)\n        return -1;\n\n    return 0;\n}\n\n\nint\nqemuProcessStart(virConnectPtr conn,\n                 virQEMUDriverPtr driver,\n                 virDomainObjPtr vm,\n                 virCPUDefPtr updatedCPU,\n                 qemuDomainAsyncJob asyncJob,\n                 const char *migrateFrom,\n                 int migrateFd,\n                 const char *migratePath,\n                 virDomainMomentObjPtr snapshot,\n                 virNetDevVPortProfileOp vmop,\n                 unsigned int flags)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    qemuProcessIncomingDefPtr incoming = NULL;\n    unsigned int stopFlags;\n    bool relabel = false;\n    bool relabelSavedState = false;\n    int ret = -1;\n    int rv;\n\n    VIR_DEBUG(\"conn=%p driver=%p vm=%p name=%s id=%d asyncJob=%s \"\n              \"migrateFrom=%s migrateFd=%d migratePath=%s \"\n              \"snapshot=%p vmop=%d flags=0x%x\",\n              conn, driver, vm, vm->def->name, vm->def->id,\n              qemuDomainAsyncJobTypeToString(asyncJob),\n              NULLSTR(migrateFrom), migrateFd, NULLSTR(migratePath),\n              snapshot, vmop, flags);\n\n    virCheckFlagsGoto(VIR_QEMU_PROCESS_START_COLD |\n                      VIR_QEMU_PROCESS_START_PAUSED |\n                      VIR_QEMU_PROCESS_START_AUTODESTROY |\n                      VIR_QEMU_PROCESS_START_GEN_VMID, cleanup);\n\n    if (!migrateFrom && !snapshot)\n        flags |= VIR_QEMU_PROCESS_START_NEW;\n\n    if (qemuProcessInit(driver, vm, updatedCPU,\n                        asyncJob, !!migrateFrom, flags) < 0)\n        goto cleanup;\n\n    if (migrateFrom) {\n        incoming = qemuProcessIncomingDefNew(priv->qemuCaps, NULL, migrateFrom,\n                                             migrateFd, migratePath);\n        if (!incoming)\n            goto stop;\n    }\n\n    if (qemuProcessPrepareDomain(driver, vm, flags) < 0)\n        goto stop;\n\n    if (qemuProcessPrepareHost(driver, vm, flags) < 0)\n        goto stop;\n\n    if (migratePath) {\n        if (qemuSecuritySetSavedStateLabel(driver->securityManager,\n                                           vm->def, migratePath) < 0)\n            goto cleanup;\n        relabelSavedState = true;\n    }\n\n    if ((rv = qemuProcessLaunch(conn, driver, vm, asyncJob, incoming,\n                                snapshot, vmop, flags)) < 0) {\n        if (rv == -2)\n            relabel = true;\n        goto stop;\n    }\n    relabel = true;\n\n    if (incoming) {\n        if (incoming->deferredURI &&\n            qemuMigrationDstRun(driver, vm, incoming->deferredURI, asyncJob) < 0)\n            goto stop;\n    } else {\n        /* Refresh state of devices from QEMU. During migration this happens\n         * in qemuMigrationDstFinish to ensure that state information is fully\n         * transferred. */\n        if (qemuProcessRefreshState(driver, vm, asyncJob) < 0)\n            goto stop;\n    }\n\n    if (qemuProcessFinishStartup(driver, vm, asyncJob,\n                                 !(flags & VIR_QEMU_PROCESS_START_PAUSED),\n                                 incoming ?\n                                 VIR_DOMAIN_PAUSED_MIGRATION :\n                                 VIR_DOMAIN_PAUSED_USER) < 0)\n        goto stop;\n\n    if (!incoming) {\n        /* Keep watching qemu log for errors during incoming migration, otherwise\n         * unset reporting errors from qemu log. */\n        qemuMonitorSetDomainLog(priv->mon, NULL, NULL, NULL);\n    }\n\n    ret = 0;\n\n cleanup:\n    if (relabelSavedState &&\n        qemuSecurityRestoreSavedStateLabel(driver->securityManager,\n                                           vm->def, migratePath) < 0)\n        VIR_WARN(\"failed to restore save state label on %s\", migratePath);\n    qemuProcessIncomingDefFree(incoming);\n    return ret;\n\n stop:\n    stopFlags = 0;\n    if (!relabel)\n        stopFlags |= VIR_QEMU_PROCESS_STOP_NO_RELABEL;\n    if (migrateFrom)\n        stopFlags |= VIR_QEMU_PROCESS_STOP_MIGRATED;\n    if (priv->mon)\n        qemuMonitorSetDomainLog(priv->mon, NULL, NULL, NULL);\n    qemuProcessStop(driver, vm, VIR_DOMAIN_SHUTOFF_FAILED, asyncJob, stopFlags);\n    goto cleanup;\n}\n\n\nint\nqemuProcessCreatePretendCmdPrepare(virQEMUDriverPtr driver,\n                                   virDomainObjPtr vm,\n                                   const char *migrateURI,\n                                   bool standalone,\n                                   unsigned int flags)\n{\n    virCheckFlags(VIR_QEMU_PROCESS_START_COLD |\n                  VIR_QEMU_PROCESS_START_PAUSED |\n                  VIR_QEMU_PROCESS_START_AUTODESTROY, -1);\n\n    flags |= VIR_QEMU_PROCESS_START_PRETEND;\n\n    if (!migrateURI)\n        flags |= VIR_QEMU_PROCESS_START_NEW;\n\n    if (standalone)\n        flags |= VIR_QEMU_PROCESS_START_STANDALONE;\n\n    if (qemuProcessInit(driver, vm, NULL, QEMU_ASYNC_JOB_NONE,\n                        !!migrateURI, flags) < 0)\n        return -1;\n\n    if (qemuProcessPrepareDomain(driver, vm, flags) < 0)\n        return -1;\n\n    return 0;\n}\n\n\nvirCommandPtr\nqemuProcessCreatePretendCmdBuild(virQEMUDriverPtr driver,\n                                 virDomainObjPtr vm,\n                                 const char *migrateURI,\n                                 bool enableFips,\n                                 bool standalone,\n                                 bool jsonPropsValidation)\n{\n    unsigned int buildflags = 0;\n\n    if (jsonPropsValidation)\n        buildflags = QEMU_BUILD_COMMANDLINE_VALIDATE_KEEP_JSON;\n\n    VIR_DEBUG(\"Building emulator command line\");\n    return qemuBuildCommandLine(driver,\n                                NULL,\n                                driver->securityManager,\n                                vm,\n                                migrateURI,\n                                NULL,\n                                VIR_NETDEV_VPORT_PROFILE_OP_NO_OP,\n                                standalone,\n                                enableFips,\n                                NULL,\n                                NULL,\n                                buildflags);\n}\n\n\nint\nqemuProcessKill(virDomainObjPtr vm, unsigned int flags)\n{\n    VIR_DEBUG(\"vm=%p name=%s pid=%lld flags=0x%x\",\n              vm, vm->def->name,\n              (long long)vm->pid, flags);\n\n    if (!(flags & VIR_QEMU_PROCESS_KILL_NOCHECK)) {\n        if (!virDomainObjIsActive(vm)) {\n            VIR_DEBUG(\"VM '%s' not active\", vm->def->name);\n            return 0;\n        }\n    }\n\n    if (flags & VIR_QEMU_PROCESS_KILL_NOWAIT) {\n        virProcessKill(vm->pid,\n                       (flags & VIR_QEMU_PROCESS_KILL_FORCE) ?\n                       SIGKILL : SIGTERM);\n        return 0;\n    }\n\n    /* Request an extra delay of two seconds per current nhostdevs\n     * to be safe against stalls by the kernel freeing up the resources */\n    return virProcessKillPainfullyDelay(vm->pid,\n                                        !!(flags & VIR_QEMU_PROCESS_KILL_FORCE),\n                                        vm->def->nhostdevs * 2);\n}\n\n\n/**\n * qemuProcessBeginStopJob:\n *\n * Stop all current jobs by killing the domain and start a new one for\n * qemuProcessStop.\n */\nint\nqemuProcessBeginStopJob(virQEMUDriverPtr driver,\n                        virDomainObjPtr vm,\n                        qemuDomainJob job,\n                        bool forceKill)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    unsigned int killFlags = forceKill ? VIR_QEMU_PROCESS_KILL_FORCE : 0;\n    int ret = -1;\n\n    /* We need to prevent monitor EOF callback from doing our work (and\n     * sending misleading events) while the vm is unlocked inside\n     * BeginJob/ProcessKill API\n     */\n    priv->beingDestroyed = true;\n\n    if (qemuProcessKill(vm, killFlags) < 0)\n        goto cleanup;\n\n    /* Wake up anything waiting on domain condition */\n    virDomainObjBroadcast(vm);\n\n    if (qemuDomainObjBeginJob(driver, vm, job) < 0)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    priv->beingDestroyed = false;\n    return ret;\n}\n\n\nvoid qemuProcessStop(virQEMUDriverPtr driver,\n                     virDomainObjPtr vm,\n                     virDomainShutoffReason reason,\n                     qemuDomainAsyncJob asyncJob,\n                     unsigned int flags)\n{\n    int ret;\n    int retries = 0;\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    virErrorPtr orig_err;\n    virDomainDefPtr def = vm->def;\n    const virNetDevVPortProfile *vport = NULL;\n    size_t i;\n    g_autofree char *timestamp = NULL;\n    g_autoptr(virQEMUDriverConfig) cfg = virQEMUDriverGetConfig(driver);\n    g_autoptr(virConnect) conn = NULL;\n\n    VIR_DEBUG(\"Shutting down vm=%p name=%s id=%d pid=%lld, \"\n              \"reason=%s, asyncJob=%s, flags=0x%x\",\n              vm, vm->def->name, vm->def->id,\n              (long long)vm->pid,\n              virDomainShutoffReasonTypeToString(reason),\n              qemuDomainAsyncJobTypeToString(asyncJob),\n              flags);\n\n    /* This method is routinely used in clean up paths. Disable error\n     * reporting so we don't squash a legit error. */\n    virErrorPreserveLast(&orig_err);\n\n    if (asyncJob != QEMU_ASYNC_JOB_NONE) {\n        if (qemuDomainObjBeginNestedJob(driver, vm, asyncJob) < 0)\n            goto cleanup;\n    } else if (priv->job.asyncJob != QEMU_ASYNC_JOB_NONE &&\n               priv->job.asyncOwner == virThreadSelfID() &&\n               priv->job.active != QEMU_JOB_ASYNC_NESTED) {\n        VIR_WARN(\"qemuProcessStop called without a nested job (async=%s)\",\n                 qemuDomainAsyncJobTypeToString(asyncJob));\n    }\n\n    if (!virDomainObjIsActive(vm)) {\n        VIR_DEBUG(\"VM '%s' not active\", vm->def->name);\n        goto endjob;\n    }\n\n    qemuProcessBuildDestroyMemoryPaths(driver, vm, NULL, false);\n\n    if (!!g_atomic_int_dec_and_test(&driver->nactive) && driver->inhibitCallback)\n        driver->inhibitCallback(false, driver->inhibitOpaque);\n\n    /* Wake up anything waiting on domain condition */\n    virDomainObjBroadcast(vm);\n\n    if ((timestamp = virTimeStringNow()) != NULL) {\n        qemuDomainLogAppendMessage(driver, vm, \"%s: shutting down, reason=%s\\n\",\n                                   timestamp,\n                                   virDomainShutoffReasonTypeToString(reason));\n    }\n\n    /* Clear network bandwidth */\n    virDomainClearNetBandwidth(vm->def);\n\n    virDomainConfVMNWFilterTeardown(vm);\n\n    if (cfg->macFilter) {\n        for (i = 0; i < def->nnets; i++) {\n            virDomainNetDefPtr net = def->nets[i];\n            if (net->ifname == NULL)\n                continue;\n            ignore_value(ebtablesRemoveForwardAllowIn(driver->ebtables,\n                                                      net->ifname,\n                                                      &net->mac));\n        }\n    }\n\n    virPortAllocatorRelease(priv->nbdPort);\n    priv->nbdPort = 0;\n\n    if (priv->agent) {\n        qemuAgentClose(priv->agent);\n        priv->agent = NULL;\n    }\n    priv->agentError = false;\n\n    if (priv->mon) {\n        qemuMonitorClose(priv->mon);\n        priv->mon = NULL;\n    }\n\n    if (priv->monConfig) {\n        if (priv->monConfig->type == VIR_DOMAIN_CHR_TYPE_UNIX)\n            unlink(priv->monConfig->data.nix.path);\n        virObjectUnref(priv->monConfig);\n        priv->monConfig = NULL;\n    }\n\n    qemuDomainObjStopWorker(vm);\n\n    /* Remove the master key */\n    qemuDomainMasterKeyRemove(priv);\n\n    /* Do this before we delete the tree and remove pidfile. */\n    qemuProcessKillManagedPRDaemon(vm);\n\n    ignore_value(virDomainChrDefForeach(vm->def,\n                                        false,\n                                        qemuProcessCleanupChardevDevice,\n                                        NULL));\n\n\n    /* shut it off for sure */\n    ignore_value(qemuProcessKill(vm,\n                                 VIR_QEMU_PROCESS_KILL_FORCE|\n                                 VIR_QEMU_PROCESS_KILL_NOCHECK));\n\n    qemuDomainCleanupRun(driver, vm);\n\n    qemuExtDevicesStop(driver, vm);\n\n    qemuDBusStop(driver, vm);\n\n    vm->def->id = -1;\n\n    virFileDeleteTree(priv->libDir);\n    virFileDeleteTree(priv->channelTargetDir);\n\n    /* Stop autodestroy in case guest is restarted */\n    qemuProcessAutoDestroyRemove(driver, vm);\n\n    /* now that we know it's stopped call the hook if present */\n    if (virHookPresent(VIR_HOOK_DRIVER_QEMU)) {\n        g_autofree char *xml = qemuDomainDefFormatXML(driver, NULL, vm->def, 0);\n\n        /* we can't stop the operation even if the script raised an error */\n        ignore_value(virHookCall(VIR_HOOK_DRIVER_QEMU, vm->def->name,\n                                 VIR_HOOK_QEMU_OP_STOPPED, VIR_HOOK_SUBOP_END,\n                                 NULL, xml, NULL));\n    }\n\n    /* Reset Security Labels unless caller don't want us to */\n    if (!(flags & VIR_QEMU_PROCESS_STOP_NO_RELABEL))\n        qemuSecurityRestoreAllLabel(driver, vm,\n                                    !!(flags & VIR_QEMU_PROCESS_STOP_MIGRATED));\n\n    for (i = 0; i < vm->def->ndisks; i++) {\n        virDomainDeviceDef dev;\n        virDomainDiskDefPtr disk = vm->def->disks[i];\n\n        dev.type = VIR_DOMAIN_DEVICE_DISK;\n        dev.data.disk = disk;\n        ignore_value(qemuRemoveSharedDevice(driver, &dev, vm->def->name));\n    }\n\n    /* Clear out dynamically assigned labels */\n    for (i = 0; i < vm->def->nseclabels; i++) {\n        if (vm->def->seclabels[i]->type == VIR_DOMAIN_SECLABEL_DYNAMIC)\n            VIR_FREE(vm->def->seclabels[i]->label);\n        VIR_FREE(vm->def->seclabels[i]->imagelabel);\n    }\n\n    qemuHostdevReAttachDomainDevices(driver, vm->def);\n\n    for (i = 0; i < def->nnets; i++) {\n        virDomainNetDefPtr net = def->nets[i];\n        vport = virDomainNetGetActualVirtPortProfile(net);\n\n        switch (virDomainNetGetActualType(net)) {\n        case VIR_DOMAIN_NET_TYPE_DIRECT:\n            ignore_value(virNetDevMacVLanDeleteWithVPortProfile(\n                             net->ifname, &net->mac,\n                             virDomainNetGetActualDirectDev(net),\n                             virDomainNetGetActualDirectMode(net),\n                             virDomainNetGetActualVirtPortProfile(net),\n                             cfg->stateDir));\n            break;\n        case VIR_DOMAIN_NET_TYPE_ETHERNET:\n            if (net->managed_tap != VIR_TRISTATE_BOOL_NO && net->ifname) {\n                ignore_value(virNetDevTapDelete(net->ifname, net->backend.tap));\n                VIR_FREE(net->ifname);\n            }\n            break;\n        case VIR_DOMAIN_NET_TYPE_BRIDGE:\n        case VIR_DOMAIN_NET_TYPE_NETWORK:\n#ifdef VIR_NETDEV_TAP_REQUIRE_MANUAL_CLEANUP\n            if (!(vport && vport->virtPortType == VIR_NETDEV_VPORT_PROFILE_OPENVSWITCH))\n                ignore_value(virNetDevTapDelete(net->ifname, net->backend.tap));\n#endif\n            break;\n        case VIR_DOMAIN_NET_TYPE_USER:\n        case VIR_DOMAIN_NET_TYPE_VHOSTUSER:\n        case VIR_DOMAIN_NET_TYPE_SERVER:\n        case VIR_DOMAIN_NET_TYPE_CLIENT:\n        case VIR_DOMAIN_NET_TYPE_MCAST:\n        case VIR_DOMAIN_NET_TYPE_INTERNAL:\n        case VIR_DOMAIN_NET_TYPE_HOSTDEV:\n        case VIR_DOMAIN_NET_TYPE_UDP:\n        case VIR_DOMAIN_NET_TYPE_VDPA:\n        case VIR_DOMAIN_NET_TYPE_LAST:\n            /* No special cleanup procedure for these types. */\n            break;\n        }\n        /* release the physical device (or any other resources used by\n         * this interface in the network driver\n         */\n        if (vport) {\n            if (vport->virtPortType == VIR_NETDEV_VPORT_PROFILE_MIDONET) {\n                ignore_value(virNetDevMidonetUnbindPort(vport));\n            } else if (vport->virtPortType == VIR_NETDEV_VPORT_PROFILE_OPENVSWITCH) {\n                ignore_value(virNetDevOpenvswitchRemovePort(\n                                 virDomainNetGetActualBridgeName(net),\n                                 net->ifname));\n            }\n        }\n\n        /* kick the device out of the hostdev list too */\n        virDomainNetRemoveHostdev(def, net);\n        if (net->type == VIR_DOMAIN_NET_TYPE_NETWORK) {\n            if (conn || (conn = virGetConnectNetwork()))\n                virDomainNetReleaseActualDevice(conn, vm->def, net);\n            else\n                VIR_WARN(\"Unable to release network device '%s'\", NULLSTR(net->ifname));\n        }\n    }\n\n retry:\n    if ((ret = qemuRemoveCgroup(vm)) < 0) {\n        if (ret == -EBUSY && (retries++ < 5)) {\n            g_usleep(200*1000);\n            goto retry;\n        }\n        VIR_WARN(\"Failed to remove cgroup for %s\",\n                 vm->def->name);\n    }\n\n    /* Remove resctrl allocation after cgroups are cleaned up which makes it\n     * kind of safer (although removing the allocation should work even with\n     * pids in tasks file */\n    for (i = 0; i < vm->def->nresctrls; i++) {\n        size_t j = 0;\n\n        for (j = 0; j < vm->def->resctrls[i]->nmonitors; j++) {\n            virDomainResctrlMonDefPtr mon = NULL;\n\n            mon = vm->def->resctrls[i]->monitors[j];\n            virResctrlMonitorRemove(mon->instance);\n        }\n\n        virResctrlAllocRemove(vm->def->resctrls[i]->alloc);\n    }\n\n    /* clean up a possible backup job */\n    if (priv->backup)\n        qemuBackupJobTerminate(vm, QEMU_DOMAIN_JOB_STATUS_CANCELED);\n\n    qemuProcessRemoveDomainStatus(driver, vm);\n\n    /* Remove VNC and Spice ports from port reservation bitmap, but only if\n       they were reserved by the driver (autoport=yes)\n    */\n    for (i = 0; i < vm->def->ngraphics; ++i) {\n        virDomainGraphicsDefPtr graphics = vm->def->graphics[i];\n        if (graphics->type == VIR_DOMAIN_GRAPHICS_TYPE_VNC) {\n            if (graphics->data.vnc.autoport) {\n                virPortAllocatorRelease(graphics->data.vnc.port);\n            } else if (graphics->data.vnc.portReserved) {\n                virPortAllocatorRelease(graphics->data.vnc.port);\n                graphics->data.vnc.portReserved = false;\n            }\n            if (graphics->data.vnc.websocketGenerated) {\n                virPortAllocatorRelease(graphics->data.vnc.websocket);\n                graphics->data.vnc.websocketGenerated = false;\n                graphics->data.vnc.websocket = -1;\n            } else if (graphics->data.vnc.websocket) {\n                virPortAllocatorRelease(graphics->data.vnc.websocket);\n            }\n        }\n        if (graphics->type == VIR_DOMAIN_GRAPHICS_TYPE_SPICE) {\n            if (graphics->data.spice.autoport) {\n                virPortAllocatorRelease(graphics->data.spice.port);\n                virPortAllocatorRelease(graphics->data.spice.tlsPort);\n            } else {\n                if (graphics->data.spice.portReserved) {\n                    virPortAllocatorRelease(graphics->data.spice.port);\n                    graphics->data.spice.portReserved = false;\n                }\n\n                if (graphics->data.spice.tlsPortReserved) {\n                    virPortAllocatorRelease(graphics->data.spice.tlsPort);\n                    graphics->data.spice.tlsPortReserved = false;\n                }\n            }\n        }\n    }\n\n    for (i = 0; i < vm->ndeprecations; i++)\n        g_free(vm->deprecations[i]);\n    g_free(vm->deprecations);\n    vm->ndeprecations = 0;\n    vm->deprecations = NULL;\n    vm->taint = 0;\n    vm->pid = -1;\n    virDomainObjSetState(vm, VIR_DOMAIN_SHUTOFF, reason);\n    for (i = 0; i < vm->def->niothreadids; i++)\n        vm->def->iothreadids[i]->thread_id = 0;\n\n    /* Do this explicitly after vm->pid is reset so that security drivers don't\n     * try to enter the domain's namespace which is non-existent by now as qemu\n     * is no longer running. */\n    if (!(flags & VIR_QEMU_PROCESS_STOP_NO_RELABEL)) {\n        for (i = 0; i < def->ndisks; i++) {\n            virDomainDiskDefPtr disk = def->disks[i];\n\n            if (disk->mirror) {\n                if (qemuSecurityRestoreImageLabel(driver, vm, disk->mirror, false) < 0)\n                    VIR_WARN(\"Unable to restore security label on %s\", disk->dst);\n\n                if (virStorageSourceChainHasNVMe(disk->mirror))\n                    qemuHostdevReAttachOneNVMeDisk(driver, vm->def->name, disk->mirror);\n            }\n\n            qemuBlockRemoveImageMetadata(driver, vm, disk->dst, disk->src);\n\n            /* for now transient disks are forbidden with migration so they\n             * can be handled here */\n            if (disk->transient &&\n                !priv->inhibitDiskTransientDelete) {\n                VIR_DEBUG(\"Removing transient overlay '%s' of disk '%s'\",\n                          disk->src->path, disk->dst);\n                if (qemuDomainStorageFileInit(driver, vm, disk->src, NULL) >= 0) {\n                    virStorageSourceUnlink(disk->src);\n                    virStorageSourceDeinit(disk->src);\n                }\n            }\n        }\n    }\n\n    qemuSecurityReleaseLabel(driver->securityManager, vm->def);\n\n    /* clear all private data entries which are no longer needed */\n    qemuDomainObjPrivateDataClear(priv);\n\n    /* The \"release\" hook cleans up additional resources */\n    if (virHookPresent(VIR_HOOK_DRIVER_QEMU)) {\n        g_autofree char *xml = qemuDomainDefFormatXML(driver, NULL, vm->def, 0);\n\n        /* we can't stop the operation even if the script raised an error */\n        virHookCall(VIR_HOOK_DRIVER_QEMU, vm->def->name,\n                    VIR_HOOK_QEMU_OP_RELEASE, VIR_HOOK_SUBOP_END,\n                    NULL, xml, NULL);\n    }\n\n    virDomainObjRemoveTransientDef(vm);\n\n endjob:\n    if (asyncJob != QEMU_ASYNC_JOB_NONE)\n        qemuDomainObjEndJob(driver, vm);\n\n cleanup:\n    virErrorRestore(&orig_err);\n}\n\n\nstatic void\nqemuProcessAutoDestroy(virDomainObjPtr dom,\n                       virConnectPtr conn,\n                       void *opaque)\n{\n    virQEMUDriverPtr driver = opaque;\n    qemuDomainObjPrivatePtr priv = dom->privateData;\n    virObjectEventPtr event = NULL;\n    unsigned int stopFlags = 0;\n\n    VIR_DEBUG(\"vm=%s, conn=%p\", dom->def->name, conn);\n\n    if (priv->job.asyncJob == QEMU_ASYNC_JOB_MIGRATION_IN)\n        stopFlags |= VIR_QEMU_PROCESS_STOP_MIGRATED;\n\n    if (priv->job.asyncJob) {\n        VIR_DEBUG(\"vm=%s has long-term job active, cancelling\",\n                  dom->def->name);\n        qemuDomainObjDiscardAsyncJob(driver, dom);\n    }\n\n    VIR_DEBUG(\"Killing domain\");\n\n    if (qemuProcessBeginStopJob(driver, dom, QEMU_JOB_DESTROY, true) < 0)\n        return;\n\n    qemuProcessStop(driver, dom, VIR_DOMAIN_SHUTOFF_DESTROYED,\n                    QEMU_ASYNC_JOB_NONE, stopFlags);\n\n    virDomainAuditStop(dom, \"destroyed\");\n    event = virDomainEventLifecycleNewFromObj(dom,\n                                     VIR_DOMAIN_EVENT_STOPPED,\n                                     VIR_DOMAIN_EVENT_STOPPED_DESTROYED);\n\n    qemuDomainRemoveInactive(driver, dom);\n\n    qemuDomainObjEndJob(driver, dom);\n\n    virObjectEventStateQueue(driver->domainEventState, event);\n}\n\nint qemuProcessAutoDestroyAdd(virQEMUDriverPtr driver,\n                              virDomainObjPtr vm,\n                              virConnectPtr conn)\n{\n    VIR_DEBUG(\"vm=%s, conn=%p\", vm->def->name, conn);\n    return virCloseCallbacksSet(driver->closeCallbacks, vm, conn,\n                                qemuProcessAutoDestroy);\n}\n\nint qemuProcessAutoDestroyRemove(virQEMUDriverPtr driver,\n                                 virDomainObjPtr vm)\n{\n    VIR_DEBUG(\"vm=%s\", vm->def->name);\n    return virCloseCallbacksUnset(driver->closeCallbacks, vm,\n                                  qemuProcessAutoDestroy);\n}\n\nbool qemuProcessAutoDestroyActive(virQEMUDriverPtr driver,\n                                  virDomainObjPtr vm)\n{\n    virCloseCallback cb;\n    VIR_DEBUG(\"vm=%s\", vm->def->name);\n    cb = virCloseCallbacksGet(driver->closeCallbacks, vm, NULL);\n    return cb == qemuProcessAutoDestroy;\n}\n\n\nint\nqemuProcessRefreshDisks(virQEMUDriverPtr driver,\n                        virDomainObjPtr vm,\n                        qemuDomainAsyncJob asyncJob)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    bool blockdev = virQEMUCapsGet(priv->qemuCaps, QEMU_CAPS_BLOCKDEV);\n    GHashTable *table = NULL;\n    int ret = -1;\n    size_t i;\n\n    if (qemuDomainObjEnterMonitorAsync(driver, vm, asyncJob) == 0) {\n        table = qemuMonitorGetBlockInfo(priv->mon);\n        if (qemuDomainObjExitMonitor(driver, vm) < 0)\n            goto cleanup;\n    }\n\n    if (!table)\n        goto cleanup;\n\n    for (i = 0; i < vm->def->ndisks; i++) {\n        virDomainDiskDefPtr disk = vm->def->disks[i];\n        qemuDomainDiskPrivatePtr diskpriv = QEMU_DOMAIN_DISK_PRIVATE(disk);\n        struct qemuDomainDiskInfo *info;\n        const char *entryname = disk->info.alias;\n\n        if (blockdev && diskpriv->qomName)\n            entryname = diskpriv->qomName;\n\n        if (!(info = virHashLookup(table, entryname)))\n            continue;\n\n        if (info->removable) {\n            if (info->empty)\n                virDomainDiskEmptySource(disk);\n\n            if (info->tray) {\n                if (info->tray_open)\n                    disk->tray_status = VIR_DOMAIN_DISK_TRAY_OPEN;\n                else\n                    disk->tray_status = VIR_DOMAIN_DISK_TRAY_CLOSED;\n            }\n        }\n\n        /* fill in additional data */\n        diskpriv->removable = info->removable;\n        diskpriv->tray = info->tray;\n    }\n\n    ret = 0;\n\n cleanup:\n    virHashFree(table);\n    return ret;\n}\n\n\nstatic int\nqemuProcessRefreshCPUMigratability(virQEMUDriverPtr driver,\n                                   virDomainObjPtr vm,\n                                   qemuDomainAsyncJob asyncJob)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    virDomainDefPtr def = vm->def;\n    bool migratable;\n    int rc;\n\n    if (def->cpu->mode != VIR_CPU_MODE_HOST_PASSTHROUGH &&\n        def->cpu->mode != VIR_CPU_MODE_MAXIMUM)\n        return 0;\n\n    /* If the cpu.migratable capability is present, the migratable attribute\n     * is set correctly. */\n    if (virQEMUCapsGet(priv->qemuCaps, QEMU_CAPS_CPU_MIGRATABLE))\n        return 0;\n\n    if (!ARCH_IS_X86(def->os.arch))\n        return 0;\n\n    if (qemuDomainObjEnterMonitorAsync(driver, vm, asyncJob) < 0)\n        return -1;\n\n    rc = qemuMonitorGetCPUMigratable(priv->mon, &migratable);\n\n    if (qemuDomainObjExitMonitor(driver, vm) < 0 || rc < 0)\n        return -1;\n\n    if (rc == 1)\n        migratable = false;\n\n    /* Libvirt 6.5.0 would set migratable='off' for running domains even though\n     * the actual default used by QEMU was 'on'. */\n    if (def->cpu->migratable == VIR_TRISTATE_SWITCH_OFF && migratable) {\n        VIR_DEBUG(\"Fixing CPU migratable attribute\");\n        def->cpu->migratable = VIR_TRISTATE_SWITCH_ON;\n    }\n\n    if (def->cpu->migratable == VIR_TRISTATE_SWITCH_ABSENT)\n        def->cpu->migratable = virTristateSwitchFromBool(migratable);\n\n    return 0;\n}\n\n\nstatic int\nqemuProcessRefreshCPU(virQEMUDriverPtr driver,\n                      virDomainObjPtr vm)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    g_autoptr(virCPUDef) host = NULL;\n    g_autoptr(virCPUDef) hostmig = NULL;\n    g_autoptr(virCPUDef) cpu = NULL;\n\n    if (!virQEMUCapsGuestIsNative(driver->hostarch, vm->def->os.arch))\n        return 0;\n\n    if (!vm->def->cpu)\n        return 0;\n\n    if (qemuProcessRefreshCPUMigratability(driver, vm, QEMU_ASYNC_JOB_NONE) < 0)\n        return -1;\n\n    if (!(host = virQEMUDriverGetHostCPU(driver))) {\n        virResetLastError();\n        return 0;\n    }\n\n    /* If the domain with a host-model CPU was started by an old libvirt\n     * (< 2.3) which didn't replace the CPU with a custom one, let's do it now\n     * since the rest of our code does not really expect a host-model CPU in a\n     * running domain.\n     */\n    if (vm->def->cpu->mode == VIR_CPU_MODE_HOST_MODEL) {\n        /*\n         * PSeries domains are able to run with host-model CPU by design,\n         * even on Libvirt newer than 2.3, never replacing host-model with\n         * custom in the virCPUUpdate() call. It is not needed to call\n         * virCPUUpdate() and qemuProcessUpdateCPU() in this case.\n         */\n        if (qemuDomainIsPSeries(vm->def))\n            return 0;\n\n        if (!(hostmig = virCPUCopyMigratable(host->arch, host)))\n            return -1;\n\n        if (!(cpu = virCPUDefCopyWithoutModel(hostmig)) ||\n            virCPUDefCopyModelFilter(cpu, hostmig, false,\n                                     virQEMUCapsCPUFilterFeatures,\n                                     &host->arch) < 0)\n            return -1;\n\n        if (virCPUUpdate(vm->def->os.arch, vm->def->cpu, cpu) < 0)\n            return -1;\n\n        if (qemuProcessUpdateCPU(driver, vm, QEMU_ASYNC_JOB_NONE) < 0)\n            return -1;\n    } else if (!virQEMUCapsGet(priv->qemuCaps, QEMU_CAPS_QUERY_CPU_MODEL_EXPANSION)) {\n        /* We only try to fix CPUs when the libvirt/QEMU combo used to start\n         * the domain did not know about query-cpu-model-expansion in which\n         * case the host-model is known to not contain features which QEMU\n         * doesn't know about.\n         */\n        if (qemuDomainFixupCPUs(vm, &priv->origCPU) < 0)\n            return -1;\n    }\n\n    return 0;\n}\n\n\nstatic int\nqemuProcessRefreshLegacyBlockjob(void *payload,\n                                 const char *name,\n                                 void *opaque)\n{\n    const char *jobname = name;\n    virDomainObjPtr vm = opaque;\n    qemuMonitorBlockJobInfoPtr info = payload;\n    virDomainDiskDefPtr disk;\n    qemuBlockJobDataPtr job;\n    qemuBlockJobType jobtype = info->type;\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n\n    if (!(disk = qemuProcessFindDomainDiskByAliasOrQOM(vm, jobname, jobname))) {\n        VIR_DEBUG(\"could not find disk for block job '%s'\", jobname);\n        return 0;\n    }\n\n    if (jobtype == QEMU_BLOCKJOB_TYPE_COMMIT &&\n        disk->mirrorJob == VIR_DOMAIN_BLOCK_JOB_TYPE_ACTIVE_COMMIT)\n        jobtype = disk->mirrorJob;\n\n    if (!(job = qemuBlockJobDiskNew(vm, disk, jobtype, jobname)))\n        return -1;\n\n    if (disk->mirror) {\n        if ((!info->ready_present && info->end == info->cur) ||\n            info->ready) {\n            disk->mirrorState = VIR_DOMAIN_DISK_MIRROR_STATE_READY;\n            job->state = VIR_DOMAIN_BLOCK_JOB_READY;\n        }\n\n        /* Pre-blockdev block copy labelled the chain of the mirrored device\n         * just before pivoting. At that point it was no longer known whether\n         * it's even necessary (e.g. disk is being reused). This code fixes\n         * the labelling in case the job was started in a libvirt version\n         * which did not label the chain when the block copy is being started.\n         * Note that we can't do much on failure. */\n        if (disk->mirrorJob == VIR_DOMAIN_BLOCK_JOB_TYPE_COPY) {\n            if (qemuDomainDetermineDiskChain(priv->driver, vm, disk,\n                                             disk->mirror, true) < 0)\n                goto cleanup;\n\n            if (disk->mirror->format &&\n                disk->mirror->format != VIR_STORAGE_FILE_RAW &&\n                (qemuDomainNamespaceSetupDisk(vm, disk->mirror) < 0 ||\n                 qemuSetupImageChainCgroup(vm, disk->mirror) < 0 ||\n                 qemuSecuritySetImageLabel(priv->driver, vm, disk->mirror,\n                                           true, true) < 0))\n                goto cleanup;\n        }\n    }\n\n    qemuBlockJobStarted(job, vm);\n\n cleanup:\n    qemuBlockJobStartupFinalize(vm, job);\n\n    return 0;\n}\n\n\nstatic int\nqemuProcessRefreshLegacyBlockjobs(virQEMUDriverPtr driver,\n                                  virDomainObjPtr vm)\n{\n    GHashTable *blockJobs = NULL;\n    int ret = -1;\n\n    qemuDomainObjEnterMonitor(driver, vm);\n    blockJobs = qemuMonitorGetAllBlockJobInfo(qemuDomainGetMonitor(vm), true);\n    if (qemuDomainObjExitMonitor(driver, vm) < 0 || !blockJobs)\n        goto cleanup;\n\n    if (virHashForEach(blockJobs, qemuProcessRefreshLegacyBlockjob, vm) < 0)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    virHashFree(blockJobs);\n    return ret;\n}\n\n\nstatic int\nqemuProcessRefreshBlockjobs(virQEMUDriverPtr driver,\n                            virDomainObjPtr vm)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n\n    if (virQEMUCapsGet(priv->qemuCaps, QEMU_CAPS_BLOCKDEV))\n        return qemuBlockJobRefreshJobs(driver, vm);\n    else\n        return qemuProcessRefreshLegacyBlockjobs(driver, vm);\n}\n\n\nstruct qemuProcessReconnectData {\n    virQEMUDriverPtr driver;\n    virDomainObjPtr obj;\n    virIdentityPtr identity;\n};\n/*\n * Open an existing VM's monitor, re-detect VCPU threads\n * and re-reserve the security labels in use\n *\n * This function also inherits a locked and ref'd domain object.\n *\n * This function needs to:\n * 1. Enter job\n * 1. just before monitor reconnect do lightweight MonitorEnter\n *    (increase VM refcount and unlock VM)\n * 2. reconnect to monitor\n * 3. do lightweight MonitorExit (lock VM)\n * 4. continue reconnect process\n * 5. EndJob\n *\n * We can't do normal MonitorEnter & MonitorExit because these two lock the\n * monitor lock, which does not exists in this early phase.\n */\nstatic void\nqemuProcessReconnect(void *opaque)\n{\n    struct qemuProcessReconnectData *data = opaque;\n    virQEMUDriverPtr driver = data->driver;\n    virDomainObjPtr obj = data->obj;\n    qemuDomainObjPrivatePtr priv;\n    g_auto(qemuDomainJobObj) oldjob = {\n      .cb = NULL,\n    };\n    int state;\n    int reason;\n    g_autoptr(virQEMUDriverConfig) cfg = NULL;\n    size_t i;\n    unsigned int stopFlags = 0;\n    bool jobStarted = false;\n    bool retry = true;\n    bool tryMonReconn = false;\n\n    virIdentitySetCurrent(data->identity);\n    g_clear_object(&data->identity);\n    VIR_FREE(data);\n\n    qemuDomainObjRestoreJob(obj, &oldjob);\n    if (oldjob.asyncJob == QEMU_ASYNC_JOB_MIGRATION_IN)\n        stopFlags |= VIR_QEMU_PROCESS_STOP_MIGRATED;\n\n    cfg = virQEMUDriverGetConfig(driver);\n    priv = obj->privateData;\n\n    /* expect that libvirt might have crashed during VM start, so prevent\n     * cleanup of transient disks */\n    priv->inhibitDiskTransientDelete = true;\n\n    if (qemuDomainObjBeginJob(driver, obj, QEMU_JOB_MODIFY) < 0)\n        goto error;\n    jobStarted = true;\n\n    /* XXX If we ever gonna change pid file pattern, come up with\n     * some intelligence here to deal with old paths. */\n    if (!(priv->pidfile = virPidFileBuildPath(cfg->stateDir, obj->def->name)))\n        goto error;\n\n    /* Restore the masterKey */\n    if (qemuDomainMasterKeyReadFile(priv) < 0)\n        goto error;\n\n    /* If we are connecting to a guest started by old libvirt there is no\n     * allowReboot in status XML and we need to initialize it. */\n    qemuProcessPrepareAllowReboot(obj);\n\n    if (qemuHostdevUpdateActiveDomainDevices(driver, obj->def) < 0)\n        goto error;\n\n    if (priv->qemuCaps &&\n        virQEMUCapsGet(priv->qemuCaps, QEMU_CAPS_CHARDEV_FD_PASS))\n        retry = false;\n\n    if (qemuDomainObjStartWorker(obj) < 0)\n        goto error;\n\n    VIR_DEBUG(\"Reconnect monitor to def=%p name='%s' retry=%d\",\n              obj, obj->def->name, retry);\n\n    tryMonReconn = true;\n\n    /* XXX check PID liveliness & EXE path */\n    if (qemuConnectMonitor(driver, obj, QEMU_ASYNC_JOB_NONE, retry, NULL) < 0)\n        goto error;\n\n    priv->machineName = qemuDomainGetMachineName(obj);\n    if (!priv->machineName)\n        goto error;\n\n    if (qemuConnectCgroup(obj) < 0)\n        goto error;\n\n    if (qemuDomainPerfRestart(obj) < 0)\n        goto error;\n\n    /* recreate the pflash storage sources */\n    if (qemuDomainInitializePflashStorageSource(obj) < 0)\n        goto error;\n\n    /* XXX: Need to change as long as lock is introduced for\n     * qemu_driver->sharedDevices.\n     */\n    for (i = 0; i < obj->def->ndisks; i++) {\n        virDomainDiskDefPtr disk = obj->def->disks[i];\n        virDomainDeviceDef dev;\n\n        if (virDomainDiskTranslateSourcePool(disk) < 0)\n            goto error;\n\n        /* backing chains need to be refreshed only if they could change */\n        if (priv->reconnectBlockjobs != VIR_TRISTATE_BOOL_NO &&\n            !virQEMUCapsGet(priv->qemuCaps, QEMU_CAPS_BLOCKDEV)) {\n            /* This should be the only place that calls\n             * qemuDomainDetermineDiskChain with @report_broken == false\n             * to guarantee best-effort domain reconnect */\n            virStorageSourceBackingStoreClear(disk->src);\n            if (qemuDomainDetermineDiskChain(driver, obj, disk, NULL, false) < 0)\n                goto error;\n        } else {\n            VIR_DEBUG(\"skipping backing chain detection for '%s'\", disk->dst);\n        }\n\n        dev.type = VIR_DOMAIN_DEVICE_DISK;\n        dev.data.disk = disk;\n        if (qemuAddSharedDevice(driver, &dev, obj->def->name) < 0)\n            goto error;\n    }\n\n    for (i = 0; i < obj->def->ngraphics; i++) {\n        if (qemuProcessGraphicsReservePorts(obj->def->graphics[i], true) < 0)\n            goto error;\n    }\n\n    if (qemuProcessUpdateState(driver, obj) < 0)\n        goto error;\n\n    state = virDomainObjGetState(obj, &reason);\n    if (state == VIR_DOMAIN_SHUTOFF ||\n        (state == VIR_DOMAIN_PAUSED &&\n         reason == VIR_DOMAIN_PAUSED_STARTING_UP)) {\n        VIR_DEBUG(\"Domain '%s' wasn't fully started yet, killing it\",\n                  obj->def->name);\n        goto error;\n    }\n\n    if (!priv->qemuCaps) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"domain '%s' has no capabilities recorded\"),\n                       obj->def->name);\n        goto error;\n    }\n\n    /* vm startup complete, we can remove transient disks if required */\n    priv->inhibitDiskTransientDelete = false;\n\n    /* In case the domain shutdown while we were not running,\n     * we need to finish the shutdown process. And we need to do it after\n     * we have virQEMUCaps filled in.\n     */\n    if (state == VIR_DOMAIN_SHUTDOWN ||\n        (state == VIR_DOMAIN_PAUSED &&\n         reason == VIR_DOMAIN_PAUSED_SHUTTING_DOWN)) {\n        VIR_DEBUG(\"Finishing shutdown sequence for domain %s\",\n                  obj->def->name);\n        qemuProcessShutdownOrReboot(driver, obj);\n        goto cleanup;\n    }\n\n    if (qemuProcessBuildDestroyMemoryPaths(driver, obj, NULL, true) < 0)\n        goto error;\n\n    if ((qemuDomainAssignAddresses(obj->def, priv->qemuCaps,\n                                   driver, obj, false)) < 0) {\n        goto error;\n    }\n\n    /* if domain requests security driver we haven't loaded, report error, but\n     * do not kill the domain\n     */\n    ignore_value(qemuSecurityCheckAllLabel(driver->securityManager,\n                                           obj->def));\n\n    if (qemuProcessRefreshCPU(driver, obj) < 0)\n        goto error;\n\n    if (qemuDomainRefreshVcpuInfo(driver, obj, QEMU_ASYNC_JOB_NONE, true) < 0)\n        goto error;\n\n    qemuDomainVcpuPersistOrder(obj->def);\n\n    if (qemuProcessDetectIOThreadPIDs(driver, obj, QEMU_ASYNC_JOB_NONE) < 0)\n        goto error;\n\n    if (qemuSecurityReserveLabel(driver->securityManager, obj->def, obj->pid) < 0)\n        goto error;\n\n    qemuProcessNotifyNets(obj->def);\n\n    qemuProcessFiltersInstantiate(obj->def);\n\n    if (qemuProcessRefreshDisks(driver, obj, QEMU_ASYNC_JOB_NONE) < 0)\n        goto error;\n\n    if (!virQEMUCapsGet(priv->qemuCaps, QEMU_CAPS_BLOCKDEV) &&\n        qemuBlockNodeNamesDetect(driver, obj, QEMU_ASYNC_JOB_NONE) < 0)\n        goto error;\n\n    if (qemuRefreshVirtioChannelState(driver, obj, QEMU_ASYNC_JOB_NONE) < 0)\n        goto error;\n\n    /* If querying of guest's RTC failed, report error, but do not kill the domain. */\n    qemuRefreshRTC(driver, obj);\n\n    if (qemuProcessRefreshBalloonState(driver, obj, QEMU_ASYNC_JOB_NONE) < 0)\n        goto error;\n\n    if (qemuProcessRecoverJob(driver, obj, &oldjob, &stopFlags) < 0)\n        goto error;\n\n    if (qemuProcessRefreshBlockjobs(driver, obj) < 0)\n        goto error;\n\n    if (qemuProcessUpdateDevices(driver, obj) < 0)\n        goto error;\n\n    if (qemuRefreshPRManagerState(driver, obj) < 0)\n        goto error;\n\n    qemuProcessReconnectCheckMemAliasOrderMismatch(obj);\n\n    if (qemuConnectAgent(driver, obj) < 0)\n        goto error;\n\n    for (i = 0; i < obj->def->nresctrls; i++) {\n        size_t j = 0;\n\n        if (virResctrlAllocDeterminePath(obj->def->resctrls[i]->alloc,\n                                         priv->machineName) < 0)\n            goto error;\n\n        for (j = 0; j < obj->def->resctrls[i]->nmonitors; j++) {\n            virDomainResctrlMonDefPtr mon = NULL;\n\n            mon = obj->def->resctrls[i]->monitors[j];\n            if (virResctrlMonitorDeterminePath(mon->instance,\n                                               priv->machineName) < 0)\n                goto error;\n        }\n    }\n\n    /* update domain state XML with possibly updated state in virDomainObj */\n    if (virDomainObjSave(obj, driver->xmlopt, cfg->stateDir) < 0)\n        goto error;\n\n    /* Run an hook to allow admins to do some magic */\n    if (virHookPresent(VIR_HOOK_DRIVER_QEMU)) {\n        g_autofree char *xml = qemuDomainDefFormatXML(driver,\n                                                          priv->qemuCaps,\n                                                          obj->def, 0);\n        int hookret;\n\n        hookret = virHookCall(VIR_HOOK_DRIVER_QEMU, obj->def->name,\n                              VIR_HOOK_QEMU_OP_RECONNECT, VIR_HOOK_SUBOP_BEGIN,\n                              NULL, xml, NULL);\n\n        /*\n         * If the script raised an error abort the launch\n         */\n        if (hookret < 0)\n            goto error;\n    }\n\n    if (g_atomic_int_add(&driver->nactive, 1) == 0 && driver->inhibitCallback)\n        driver->inhibitCallback(true, driver->inhibitOpaque);\n\n cleanup:\n    if (jobStarted) {\n        if (!virDomainObjIsActive(obj))\n            qemuDomainRemoveInactive(driver, obj);\n        qemuDomainObjEndJob(driver, obj);\n    } else {\n        if (!virDomainObjIsActive(obj))\n            qemuDomainRemoveInactiveJob(driver, obj);\n    }\n    virDomainObjEndAPI(&obj);\n    virNWFilterUnlockFilterUpdates();\n    virIdentitySetCurrent(NULL);\n    return;\n\n error:\n    if (virDomainObjIsActive(obj)) {\n        /* We can't get the monitor back, so must kill the VM\n         * to remove danger of it ending up running twice if\n         * user tries to start it again later.\n         *\n         * If we cannot get to the monitor when the QEMU command\n         * line used -no-shutdown, then we can safely say that the\n         * domain crashed; otherwise, if the monitor was started,\n         * then we can blame ourselves, else we failed before the\n         * monitor started so we don't really know. */\n        if (!priv->mon && tryMonReconn &&\n            qemuDomainIsUsingNoShutdown(priv))\n            state = VIR_DOMAIN_SHUTOFF_CRASHED;\n        else if (priv->mon)\n            state = VIR_DOMAIN_SHUTOFF_DAEMON;\n        else\n            state = VIR_DOMAIN_SHUTOFF_UNKNOWN;\n\n        /* If BeginJob failed, we jumped here without a job, let's hope another\n         * thread didn't have a chance to start playing with the domain yet\n         * (it's all we can do anyway).\n         */\n        qemuProcessStop(driver, obj, state, QEMU_ASYNC_JOB_NONE, stopFlags);\n    }\n    goto cleanup;\n}\n\nstatic int\nqemuProcessReconnectHelper(virDomainObjPtr obj,\n                           void *opaque)\n{\n    virThread thread;\n    struct qemuProcessReconnectData *src = opaque;\n    struct qemuProcessReconnectData *data;\n    g_autofree char *name = NULL;\n\n    /* If the VM was inactive, we don't need to reconnect */\n    if (!obj->pid)\n        return 0;\n\n    data = g_new0(struct qemuProcessReconnectData, 1);\n\n    memcpy(data, src, sizeof(*data));\n    data->obj = obj;\n    data->identity = virIdentityGetCurrent();\n\n    virNWFilterReadLockFilterUpdates();\n\n    /* this lock and reference will be eventually transferred to the thread\n     * that handles the reconnect */\n    virObjectLock(obj);\n    virObjectRef(obj);\n\n    name = g_strdup_printf(\"init-%s\", obj->def->name);\n\n    if (virThreadCreateFull(&thread, false, qemuProcessReconnect,\n                            name, false, data) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Could not create thread. QEMU initialization \"\n                         \"might be incomplete\"));\n        /* We can't spawn a thread and thus connect to monitor. Kill qemu.\n         * It's safe to call qemuProcessStop without a job here since there\n         * is no thread that could be doing anything else with the same domain\n         * object.\n         */\n        qemuProcessStop(src->driver, obj, VIR_DOMAIN_SHUTOFF_FAILED,\n                        QEMU_ASYNC_JOB_NONE, 0);\n        qemuDomainRemoveInactiveJobLocked(src->driver, obj);\n\n        virDomainObjEndAPI(&obj);\n        virNWFilterUnlockFilterUpdates();\n        g_clear_object(&data->identity);\n        VIR_FREE(data);\n        return -1;\n    }\n\n    return 0;\n}\n\n/**\n * qemuProcessReconnectAll\n *\n * Try to re-open the resources for live VMs that we care\n * about.\n */\nvoid\nqemuProcessReconnectAll(virQEMUDriverPtr driver)\n{\n    struct qemuProcessReconnectData data = {.driver = driver};\n    virDomainObjListForEach(driver->domains, true,\n                            qemuProcessReconnectHelper, &data);\n}\n\n\nstatic void virQEMUCapsMonitorNotify(qemuMonitorPtr mon G_GNUC_UNUSED,\n                                     virDomainObjPtr vm G_GNUC_UNUSED,\n                                     void *opaque G_GNUC_UNUSED)\n{\n}\n\nstatic qemuMonitorCallbacks callbacks = {\n    .eofNotify = virQEMUCapsMonitorNotify,\n    .errorNotify = virQEMUCapsMonitorNotify,\n};\n\n\nstatic void\nqemuProcessQMPStop(qemuProcessQMPPtr proc)\n{\n    if (proc->mon) {\n        virObjectUnlock(proc->mon);\n        qemuMonitorClose(proc->mon);\n        proc->mon = NULL;\n    }\n\n    if (proc->cmd) {\n        virCommandAbort(proc->cmd);\n        virCommandFree(proc->cmd);\n        proc->cmd = NULL;\n    }\n\n    if (proc->monpath)\n        unlink(proc->monpath);\n\n    virDomainObjEndAPI(&proc->vm);\n\n    if (proc->pid != 0) {\n        VIR_DEBUG(\"Killing QMP caps process %lld\", (long long)proc->pid);\n        if (virProcessKill(proc->pid, SIGKILL) < 0 && errno != ESRCH)\n            VIR_ERROR(_(\"Failed to kill process %lld: %s\"),\n                      (long long)proc->pid,\n                      g_strerror(errno));\n\n        proc->pid = 0;\n    }\n\n    if (proc->pidfile)\n        unlink(proc->pidfile);\n\n    if (proc->uniqDir)\n        rmdir(proc->uniqDir);\n}\n\n\n/**\n * qemuProcessQMPFree:\n * @proc: Stores process and connection state\n *\n * Kill QEMU process and free process data structure.\n */\nvoid\nqemuProcessQMPFree(qemuProcessQMPPtr proc)\n{\n    if (!proc)\n        return;\n\n    qemuProcessQMPStop(proc);\n\n    g_object_unref(proc->eventThread);\n\n    g_free(proc->binary);\n    g_free(proc->libDir);\n    g_free(proc->uniqDir);\n    g_free(proc->monpath);\n    g_free(proc->monarg);\n    g_free(proc->pidfile);\n    g_free(proc->stdErr);\n    g_free(proc);\n}\n\n\n/**\n * qemuProcessQMPNew:\n * @binary: QEMU binary\n * @libDir: Directory for process and connection artifacts\n * @runUid: UserId for QEMU process\n * @runGid: GroupId for QEMU process\n * @forceTCG: Force TCG mode if true\n *\n * Allocate and initialize domain structure encapsulating QEMU process state\n * and monitor connection for completing QMP queries.\n */\nqemuProcessQMPPtr\nqemuProcessQMPNew(const char *binary,\n                  const char *libDir,\n                  uid_t runUid,\n                  gid_t runGid,\n                  bool forceTCG)\n{\n    g_autoptr(qemuProcessQMP) proc = NULL;\n    const char *threadSuffix;\n    g_autofree char *threadName = NULL;\n\n    VIR_DEBUG(\"exec=%s, libDir=%s, runUid=%u, runGid=%u, forceTCG=%d\",\n              binary, libDir, runUid, runGid, forceTCG);\n\n    proc = g_new0(qemuProcessQMP, 1);\n\n    proc->binary = g_strdup(binary);\n    proc->libDir = g_strdup(libDir);\n\n    proc->runUid = runUid;\n    proc->runGid = runGid;\n    proc->forceTCG = forceTCG;\n\n    threadSuffix = strrchr(binary, '-');\n    if (threadSuffix)\n        threadSuffix++;\n    else\n        threadSuffix = binary;\n    threadName = g_strdup_printf(\"qmp-%s\", threadSuffix);\n\n    if (!(proc->eventThread = virEventThreadNew(threadName)))\n        return NULL;\n\n    return g_steal_pointer(&proc);\n}\n\n\nstatic int\nqemuProcessQEMULabelUniqPath(qemuProcessQMPPtr proc)\n{\n    /* We cannot use the security driver here, but we should not need to. */\n    if (chown(proc->uniqDir, proc->runUid, -1) < 0) {\n        virReportSystemError(errno,\n                             _(\"Cannot chown uniq path: %s\"),\n                             proc->uniqDir);\n        return -1;\n    }\n\n    return 0;\n}\n\n\nstatic int\nqemuProcessQMPInit(qemuProcessQMPPtr proc)\n{\n    g_autofree char *template = NULL;\n\n    VIR_DEBUG(\"proc=%p, emulator=%s\", proc, proc->binary);\n\n    template = g_strdup_printf(\"%s/qmp-XXXXXX\", proc->libDir);\n\n    if (!(proc->uniqDir = g_mkdtemp(template))) {\n        virReportSystemError(errno,\n                             _(\"Failed to create unique directory with \"\n                               \"template '%s' for probing QEMU\"),\n                             template);\n        return -1;\n    }\n    /* if g_mkdtemp succeeds, proc->uniqDir is now the owner of\n     * the string. Set template to NULL to avoid freeing\n     * the memory in this case */\n    template = NULL;\n\n    if (qemuProcessQEMULabelUniqPath(proc) < 0)\n        return -1;\n\n    proc->monpath = g_strdup_printf(\"%s/%s\", proc->uniqDir, \"qmp.monitor\");\n\n    proc->monarg = g_strdup_printf(\"unix:%s,server,nowait\", proc->monpath);\n\n    /*\n     * Normally we'd use runDir for pid files, but because we're using\n     * -daemonize we need QEMU to be allowed to create them, rather\n     * than libvirtd. So we're using libDir which QEMU can write to\n     */\n    proc->pidfile = g_strdup_printf(\"%s/%s\", proc->uniqDir, \"qmp.pid\");\n\n    return 0;\n}\n\n\nstatic int\nqemuProcessQMPLaunch(qemuProcessQMPPtr proc)\n{\n    const char *machine;\n    int status = 0;\n    int rc;\n\n    if (proc->forceTCG)\n        machine = \"none,accel=tcg\";\n    else\n        machine = \"none,accel=kvm:tcg\";\n\n    VIR_DEBUG(\"Try to probe capabilities of '%s' via QMP, machine %s\",\n              proc->binary, machine);\n\n    /*\n     * We explicitly need to use -daemonize here, rather than\n     * virCommandDaemonize, because we need to synchronize\n     * with QEMU creating its monitor socket API. Using\n     * daemonize guarantees control won't return to libvirt\n     * until the socket is present.\n     */\n    proc->cmd = virCommandNewArgList(proc->binary,\n                                     \"-S\",\n                                     \"-no-user-config\",\n                                     \"-nodefaults\",\n                                     \"-nographic\",\n                                     \"-machine\", machine,\n                                     \"-qmp\", proc->monarg,\n                                     \"-pidfile\", proc->pidfile,\n                                     \"-daemonize\",\n                                    NULL);\n    virCommandAddEnvPassCommon(proc->cmd);\n    virCommandClearCaps(proc->cmd);\n\n#if WITH_CAPNG\n    /* QEMU might run into permission issues, e.g. /dev/sev (0600), override\n     * them just for the purpose of probing */\n    if (geteuid() == 0)\n        virCommandAllowCap(proc->cmd, CAP_DAC_OVERRIDE);\n#endif\n\n    virCommandSetGID(proc->cmd, proc->runGid);\n    virCommandSetUID(proc->cmd, proc->runUid);\n\n    virCommandSetErrorBuffer(proc->cmd, &(proc->stdErr));\n\n    if (virCommandRun(proc->cmd, &status) < 0)\n        return -1;\n\n    if (status != 0) {\n        VIR_DEBUG(\"QEMU %s exited with status %d\", proc->binary, status);\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to start QEMU binary %s for probing: %s\"),\n                       proc->binary,\n                       proc->stdErr ? proc->stdErr : _(\"unknown error\"));\n        return -1;\n    }\n\n    if ((rc = virPidFileReadPath(proc->pidfile, &proc->pid)) < 0) {\n        virReportSystemError(-rc, _(\"Failed to read pidfile %s\"), proc->pidfile);\n        return -1;\n    }\n\n    return 0;\n}\n\n\nint\nqemuProcessQMPInitMonitor(qemuMonitorPtr mon)\n{\n    if (qemuMonitorSetCapabilities(mon) < 0) {\n        VIR_DEBUG(\"Failed to set monitor capabilities %s\",\n                  virGetLastErrorMessage());\n        return -1;\n    }\n\n    return 0;\n}\n\n\nstatic int\nqemuProcessQMPConnectMonitor(qemuProcessQMPPtr proc)\n{\n    virDomainXMLOptionPtr xmlopt = NULL;\n    virDomainChrSourceDef monConfig;\n    int ret = -1;\n\n    VIR_DEBUG(\"proc=%p, emulator=%s, proc->pid=%lld\",\n              proc, proc->binary, (long long)proc->pid);\n\n    monConfig.type = VIR_DOMAIN_CHR_TYPE_UNIX;\n    monConfig.data.nix.path = proc->monpath;\n    monConfig.data.nix.listen = false;\n\n    if (!(xmlopt = virDomainXMLOptionNew(NULL, NULL, NULL, NULL, NULL)) ||\n        !(proc->vm = virDomainObjNew(xmlopt)) ||\n        !(proc->vm->def = virDomainDefNew()))\n        goto cleanup;\n\n    proc->vm->pid = proc->pid;\n\n    if (!(proc->mon = qemuMonitorOpen(proc->vm, &monConfig, true, 0,\n                                      virEventThreadGetContext(proc->eventThread),\n                                      &callbacks, NULL)))\n        goto cleanup;\n\n    virObjectLock(proc->mon);\n\n    if (qemuProcessQMPInitMonitor(proc->mon) < 0)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    virObjectUnref(xmlopt);\n    return ret;\n}\n\n\n/**\n * qemuProcessQMPStart:\n * @proc: QEMU process and connection state created by qemuProcessQMPNew()\n *\n * Start and connect to QEMU binary so QMP queries can be made.\n *\n * Usage:\n *   proc = qemuProcessQMPNew(binary, libDir, runUid, runGid, forceTCG);\n *   qemuProcessQMPStart(proc);\n *   ** Send QMP Queries to QEMU using monitor (proc->mon) **\n *   qemuProcessQMPFree(proc);\n *\n * Process error output (proc->stdErr) remains available in qemuProcessQMP\n * struct until qemuProcessQMPFree is called.\n */\nint\nqemuProcessQMPStart(qemuProcessQMPPtr proc)\n{\n    VIR_DEBUG(\"proc=%p, emulator=%s\", proc, proc->binary);\n\n    if (qemuProcessQMPInit(proc) < 0)\n        return -1;\n\n    if (qemuProcessQMPLaunch(proc) < 0)\n        return -1;\n\n    if (qemuProcessQMPConnectMonitor(proc) < 0)\n        return -1;\n\n    return 0;\n}\n"], "filenames": ["src/qemu/qemu_process.c"], "buggy_code_start_loc": [320], "buggy_code_end_loc": [321], "fixing_code_start_loc": [321], "fixing_code_end_loc": [324], "type": "CWE-416", "message": "A use-after-free flaw was found in libvirt. The qemuMonitorUnregister() function in qemuProcessHandleMonitorEOF is called using multiple threads without being adequately protected by a monitor lock. This flaw could be triggered by the virConnectGetAllDomainStats API when the guest is shutting down. An unprivileged client with a read-only connection could use this flaw to perform a denial of service attack by causing the libvirt daemon to crash.", "other": {"cve": {"id": "CVE-2021-3975", "sourceIdentifier": "secalert@redhat.com", "published": "2022-08-23T20:15:08.427", "lastModified": "2023-02-03T16:30:10.290", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A use-after-free flaw was found in libvirt. The qemuMonitorUnregister() function in qemuProcessHandleMonitorEOF is called using multiple threads without being adequately protected by a monitor lock. This flaw could be triggered by the virConnectGetAllDomainStats API when the guest is shutting down. An unprivileged client with a read-only connection could use this flaw to perform a denial of service attack by causing the libvirt daemon to crash."}, {"lang": "es", "value": "Se ha encontrado un fallo de uso de memoria previamente liberada en libvirt. La funci\u00f3n qemuMonitorUnregister() en qemuProcessHandleMonitorEOF es llamada usando m\u00faltiples hilos sin estar adecuadamente protegida por un bloqueo de monitor. Este fallo podr\u00eda ser activado por la API virConnectGetAllDomainStats cuando el hu\u00e9sped est\u00e1 siendo apagado. Un cliente no privilegiado con una conexi\u00f3n de s\u00f3lo lectura podr\u00eda usar este fallo para llevar a cabo un ataque de denegaci\u00f3n de servicio causando el bloqueo del demonio libvirt."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}]}, "weaknesses": [{"source": "secalert@redhat.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-416"}]}, {"source": "nvd@nist.gov", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-416"}]}], "configurations": [{"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:redhat:libvirt:*:*:*:*:*:*:*:*", "versionEndExcluding": "7.1.0", "matchCriteriaId": "248F6876-51F6-4A2B-999C-FDEE82D40689"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:21.10:*:*:*:*:*:*:*", "matchCriteriaId": "AAE4D2D0-CEEB-416F-8BC5-A7987DF56190"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:35:*:*:*:*:*:*:*", "matchCriteriaId": "80E516C0-98A4-4ADE-B69F-66A772E2BAAA"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "F4CFF558-3C47-480D-A2F0-BABF26042943"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_eus:8.6:*:*:*:*:*:*:*", "matchCriteriaId": "6C3741B8-851F-475D-B428-523F4F722350"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_for_ibm_z_systems:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "87C21FE1-EA5C-498F-9C6C-D05F91A88217"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_for_ibm_z_systems_eus:8.6:*:*:*:*:*:*:*", "matchCriteriaId": "9EF5C4AC-CA69-41E3-AD93-7AC21931374A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_for_power_little_endian:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "47811209-5CE5-4375-8391-B0A7F6A0E420"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_for_power_little_endian_eus:8.6:*:*:*:*:*:*:*", "matchCriteriaId": "729C515E-1DD3-466D-A50B-AFE058FFC94A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_for_power_little_endian_update_services_for_sap_solutions:8.6:*:*:*:*:*:*:*", "matchCriteriaId": "871A5C26-DB7B-4870-A5B2-5DD24C90B4A7"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_tus:8.6:*:*:*:*:*:*:*", "matchCriteriaId": "1272DF03-7674-4BD4-8E64-94004B195448"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:redhat:codeready_linux_builder:-:*:*:*:*:*:*:*", "matchCriteriaId": "1CD81C46-328B-412D-AF4E-68A2AD2F1A73"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:o:redhat:enterprise_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "F4CFF558-3C47-480D-A2F0-BABF26042943"}, {"vulnerable": false, "criteria": "cpe:2.3:o:redhat:enterprise_linux_eus:8.6:*:*:*:*:*:*:*", "matchCriteriaId": "6C3741B8-851F-475D-B428-523F4F722350"}, {"vulnerable": false, "criteria": "cpe:2.3:o:redhat:enterprise_linux_for_ibm_z_systems:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "87C21FE1-EA5C-498F-9C6C-D05F91A88217"}, {"vulnerable": false, "criteria": "cpe:2.3:o:redhat:enterprise_linux_for_ibm_z_systems_eus:8.6:*:*:*:*:*:*:*", "matchCriteriaId": "9EF5C4AC-CA69-41E3-AD93-7AC21931374A"}, {"vulnerable": false, "criteria": "cpe:2.3:o:redhat:enterprise_linux_for_power_little_endian:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "47811209-5CE5-4375-8391-B0A7F6A0E420"}, {"vulnerable": false, "criteria": "cpe:2.3:o:redhat:enterprise_linux_for_power_little_endian_eus:8.6:*:*:*:*:*:*:*", "matchCriteriaId": "729C515E-1DD3-466D-A50B-AFE058FFC94A"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:11.0:*:*:*:*:*:*:*", "matchCriteriaId": "FA6FEEC2-9F11-4643-8827-749718254FED"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:netapp:ontap_select_deploy_administration_utility:-:*:*:*:*:*:*:*", "matchCriteriaId": "E7CF3019-975D-40BB-A8A4-894E62BD3797"}]}]}], "references": [{"url": "https://access.redhat.com/security/cve/CVE-2021-3975", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=2024326", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/libvirt/libvirt/commit/1ac703a7d0789e46833f4013a3876c2e3af18ec7", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20221201-0002/", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "https://ubuntu.com/security/CVE-2021-3975", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/libvirt/libvirt/commit/1ac703a7d0789e46833f4013a3876c2e3af18ec7"}}