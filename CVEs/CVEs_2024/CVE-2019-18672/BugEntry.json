{"buggy_code": ["/*\n * This file is part of the KeepKey project.\n *\n * Copyright (C) 2015 KeepKey LLC\n *\n * This library is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with this library.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#include \"keepkey/board/keepkey_board.h\"\n#include \"keepkey/board/layout.h\"\n#include \"keepkey/board/messages.h\"\n#include \"trezor/crypto/bip39.h\"\n#include \"trezor/crypto/memzero.h\"\n#include \"keepkey/firmware/app_layout.h\"\n#include \"keepkey/board/confirm_sm.h\"\n#include \"keepkey/firmware/fsm.h\"\n#include \"keepkey/firmware/home_sm.h\"\n#include \"keepkey/firmware/pin_sm.h\"\n#include \"keepkey/firmware/recovery_cipher.h\"\n#include \"keepkey/firmware/storage.h\"\n#include \"keepkey/rand/rng.h\"\n\n#include <string.h>\n#include <stdio.h>\n\n#define MAX_UNCYPHERED_WORDS (3)\n\nstatic bool enforce_wordlist;\nstatic bool dry_run;\nstatic bool awaiting_character;\nstatic CONFIDENTIAL char mnemonic[MNEMONIC_BUF];\nstatic char english_alphabet[ENGLISH_ALPHABET_BUF] = \"abcdefghijklmnopqrstuvwxyz\";\nstatic CONFIDENTIAL char cipher[ENGLISH_ALPHABET_BUF];\n\n#if DEBUG_LINK\nstatic char auto_completed_word[CURRENT_WORD_BUF];\n#endif\n\nstatic void format_current_word(char *current_word, bool auto_completed);\nstatic uint32_t get_current_word_pos(void);\nstatic void get_current_word(char *current_word);\n\nstatic void recovery_abort(void) {\n    if (!dry_run) {\n        storage_reset();\n    }\n\n    awaiting_character = false;\n    memzero(mnemonic, sizeof(mnemonic));\n    memzero(cipher, sizeof(cipher));\n}\n\n/// Formats the passed word to show position in mnemonic as well as characters\n/// left.\n///\n/// \\param current_word[in]    The string to format.\n/// \\param auto_completed[in]  Whether to format as an auto completed word.\nstatic void format_current_word(char *current_word, bool auto_completed)\n{\n    static char CONFIDENTIAL temp_word[CURRENT_WORD_BUF];\n    uint32_t word_num = get_current_word_pos() + 1;\n\n    snprintf(temp_word, CURRENT_WORD_BUF, \"%\" PRIu32 \".%s\", word_num, current_word);\n\n    /* Pad with dashes */\n    size_t pos_len = strlen(current_word);\n    if (pos_len < 4)\n    {\n        for (size_t i = 0; i < 4 - pos_len; i++)\n        {\n            strlcat(temp_word, \"-\", CURRENT_WORD_BUF);\n        }\n    }\n\n    /* Mark as auto completed */\n    if(auto_completed)\n    {\n        temp_word[strlen(temp_word) + 1] = '\\0';\n        temp_word[strlen(temp_word)] = '~';\n    }\n\n    strlcpy(current_word, temp_word, CURRENT_WORD_BUF);\n    memzero(temp_word, sizeof(temp_word));\n}\n\n/*\n * get_current_word_pos() - Returns the current word position in the mnemonic\n *\n * INPUT\n *     none\n * OUTPUT\n *     position in mnemonic\n */\nstatic uint32_t get_current_word_pos(void)\n{\n    char *pos_num = strchr(mnemonic, ' ');\n    uint32_t word_pos = 0;\n\n    while(pos_num != NULL)\n    {\n        word_pos++;\n        pos_num = strchr(++pos_num, ' ');\n    }\n\n    return word_pos;\n}\n\n/// \\returns the current word being entered by parsing the mnemonic thus far\n/// \\param current_word[out]  Array to populate with current word.\nstatic void get_current_word(char *current_word)\n{\n    char *pos = strrchr(mnemonic, ' ');\n\n    if(pos)\n    {\n        pos++;\n        strlcpy(current_word, pos, CURRENT_WORD_BUF);\n    }\n    else\n    {\n        strlcpy(current_word, mnemonic, CURRENT_WORD_BUF);\n    }\n}\n\nbool exact_str_match(const char *str1, const char *str2, uint32_t len)\n{\n    volatile uint32_t match = 0;\n\n    // Access through volatile ptrs to prevent compiler optimizations that\n    // might leak timing information.\n    const char volatile * volatile str1_v = str1;\n    const char volatile * volatile str2_v = str2;\n\n    for(uint32_t i = 0; i < len && i < CURRENT_WORD_BUF; i++)\n    {\n        if(str1_v[i] == str2_v[i])\n        {\n            match++;\n        } else {\n            match--;\n        }\n    }\n\n    return match == len;\n}\n\nbool attempt_auto_complete(char *partial_word)\n{\n    // Do lookup through volatile pointers to prevent the compiler from\n    // optimizing this loop into something that can leak timing information.\n    const char *const volatile * volatile wordlist =\n        (const char *const volatile *)mnemonic_wordlist();\n\n    uint32_t partial_word_len = strlen(partial_word), match = 0, found = 0;\n    bool precise_match = false;\n\n    static uint16_t CONFIDENTIAL permute[2049];\n    for (int i = 0; i < 2049; i++) {\n        permute[i] = i;\n    }\n    random_permute_u16(permute, 2048);\n\n    // We don't want the compiler to see through the fact that we're randomly\n    // permuting the order of iteration of the next few loops, in case it's\n    // smart enough to see through that and remove the permutation, so we tell\n    // it we've touched all of memory with some inline asm, and scare it off.\n    // This acts as an optimization barrier.\n    asm volatile (\"\" ::: \"memory\");\n\n    // Look for precise matches first (including null termination)\n    for (uint32_t volatile i = 0; wordlist[permute[i]] != 0; i++) {\n        if (exact_str_match(partial_word, wordlist[permute[i]], partial_word_len + 1)) {\n            strlcpy(partial_word, wordlist[permute[i]], CURRENT_WORD_BUF);\n            precise_match = true;\n        }\n    }\n\n    random_permute_u16(permute, 2048);\n    asm volatile (\"\" ::: \"memory\");\n\n    // Followed by partial matches (ignoring null termination)\n    for (uint32_t volatile i = 0; wordlist[permute[i]] != 0; i++) {\n        if (exact_str_match(partial_word, wordlist[permute[i]], partial_word_len)) {\n            match++;\n            found = i;\n        }\n    }\n\n    if (precise_match) {\n        memzero(permute, sizeof(permute));\n        return true;\n    }\n\n    /* Autocomplete if we can */\n    if (match == 1) {\n        strlcpy(partial_word, wordlist[permute[found]], CURRENT_WORD_BUF);\n        memzero(permute, sizeof(permute));\n        return true;\n    }\n\n    memzero(permute, sizeof(permute));\n    return false;\n}\n\n/*\n * recovery_cipher_init() - Display standard notification on LCD screen\n *\n * INPUT\n *     - passphrase_protection: whether to use passphrase protection\n *     - pin_protection: whether to use pin protection\n *     - language: language for device\n *     - label: label for device\n *     - _enforce_wordlist: whether to enforce bip 39 word list\n * OUTPUT\n *     none\n */\nvoid recovery_cipher_init(bool passphrase_protection, bool pin_protection,\n                          const char *language, const char *label, bool _enforce_wordlist,\n                          uint32_t _auto_lock_delay_ms, uint32_t _u2f_counter, bool _dry_run)\n{\n    enforce_wordlist = _enforce_wordlist;\n    dry_run = _dry_run;\n\n    if (!dry_run) {\n        if (pin_protection) {\n            if (!change_pin()) {\n                recovery_abort();\n                fsm_sendFailure(FailureType_Failure_ActionCancelled, \"PINs do not match\");\n                layoutHome();\n                return;\n            }\n        } else {\n            storage_setPin(\"\");\n        }\n\n        storage_setPassphraseProtected(passphrase_protection);\n        storage_setLanguage(language);\n        storage_setLabel(label);\n        storage_setAutoLockDelayMs(_auto_lock_delay_ms);\n        storage_setU2FCounter(_u2f_counter);\n    } else if (!pin_protect(\"Enter Your PIN\")) {\n        layoutHome();\n        return;\n    }\n\n    if (!confirm(ButtonRequestType_ButtonRequest_Other,\n                 dry_run ? \"Recovery Dry Run\" : \"Recovery\",\n                 \"When entering your recovery seed, use the substitution cipher \"\n                 \"and check that each word shows up correctly on the screen.\")) {\n        fsm_sendFailure(FailureType_Failure_ActionCancelled, \"Recovery cancelled\");\n        if (!dry_run)\n            storage_reset();\n        layoutHome();\n        return;\n    }\n\n    /* Clear mnemonic */\n    memset(mnemonic, 0, sizeof(mnemonic) / sizeof(char));\n\n    /* Set to recovery cipher mode and generate and show next cipher */\n    awaiting_character = true;\n    next_character();\n}\n\n/*\n * next_character() - Randomizes cipher and displays it for next character entry\n *\n * INPUT\n *     none\n * OUTPUT\n *     none\n */\nvoid next_character(void)\n{\n    /* Scramble cipher */\n    strlcpy(cipher, english_alphabet, ENGLISH_ALPHABET_BUF);\n    random_permute_char(cipher, strlen(cipher));\n\n    static char CONFIDENTIAL current_word[CURRENT_WORD_BUF];\n    get_current_word(current_word);\n\n    /* Words should never be longer than 4 characters */\n    if (strlen(current_word) > 4) {\n        memzero(current_word, sizeof(current_word));\n\n        recovery_abort();\n        fsm_sendFailure(FailureType_Failure_SyntaxError,\n                        \"Words were not entered correctly. Make sure you are using the substition cipher.\");\n        layoutHome();\n        return;\n    }\n\n    CharacterRequest resp;\n    memset(&resp, 0, sizeof(CharacterRequest));\n\n    resp.word_pos = get_current_word_pos();\n    resp.character_pos = strlen(current_word);\n\n    msg_write(MessageType_MessageType_CharacterRequest, &resp);\n\n    /* Attempt to auto complete if we have at least 3 characters */\n    bool auto_completed = false;\n    if (strlen(current_word) >= 3) {\n        auto_completed = attempt_auto_complete(current_word);\n    }\n\n#if DEBUG_LINK\n    if (auto_completed) {\n        strlcpy(auto_completed_word, current_word, CURRENT_WORD_BUF);\n    } else {\n        auto_completed_word[0] = '\\0';\n    }\n#endif\n\n    /* Format current word and display it along with cipher */\n    format_current_word(current_word, auto_completed);\n\n    /* Show cipher and partial word */\n    layout_cipher(current_word, cipher);\n    memzero(current_word, sizeof(current_word));\n}\n\n/*\n * recovery_character() - Decodes character received from host\n *\n * INPUT\n *     - character: string to decode\n * OUTPUT\n *     none\n */\nvoid recovery_character(const char *character)\n{\n    if (!awaiting_character) {\n        recovery_abort();\n        fsm_sendFailure(FailureType_Failure_UnexpectedMessage, \"Not in Recovery mode\");\n        layoutHome();\n        return;\n    }\n\n    if (strlen(mnemonic) + 1 > MNEMONIC_BUF - 1) {\n        recovery_abort();\n        fsm_sendFailure(FailureType_Failure_UnexpectedMessage,\n                        \"Too many characters attempted during recovery\");\n        layoutHome();\n        return;\n    }\n\n    char *pos = strchr(cipher, character[0]);\n\n    // If not a space and not a legitmate cipher character, send failure.\n    if (character[0] != ' ' && pos == NULL) {\n        recovery_abort();\n        fsm_sendFailure(FailureType_Failure_SyntaxError, \"Character must be from a to z\");\n        layoutHome();\n        return;\n    }\n\n    // Count of words we think the user has entered without using the cipher:\n    static int uncyphered_word_count = 0;\n    static bool definitely_using_cipher = false;\n    static CONFIDENTIAL char coded_word[12];\n    static CONFIDENTIAL char decoded_word[12];\n\n    if (!mnemonic[0]) {\n        uncyphered_word_count = 0;\n        definitely_using_cipher = false;\n        memzero(coded_word, sizeof(coded_word));\n        memzero(decoded_word, sizeof(decoded_word));\n    }\n\n    char decoded_character[2] = \" \";\n    if (character[0] != ' ') {\n        // Decode character using cipher if not space\n        decoded_character[0] = english_alphabet[(int)(pos - cipher)];\n\n        strlcat(coded_word, character, sizeof(coded_word));\n        strlcat(decoded_word, decoded_character, sizeof(decoded_word));\n\n        if (enforce_wordlist && 4 <= strlen(coded_word)) {\n            // Check & bail if the user is entering their seed without using the\n            // cipher. Note that for each word, this can give false positives about\n            // ~0.4% of the time (2048/26^4).\n\n            bool maybe_not_using_cipher = attempt_auto_complete(coded_word);\n            bool maybe_using_cipher = attempt_auto_complete(decoded_word);\n\n            if (!maybe_not_using_cipher && maybe_using_cipher) {\n                // Decrease the overall false positive rate by detecting that a\n                // user has entered a word which is definitely using the\n                // cipher.\n                definitely_using_cipher = true;\n            } else if (maybe_not_using_cipher && !definitely_using_cipher &&\n                       MAX_UNCYPHERED_WORDS < uncyphered_word_count++) {\n                recovery_abort();\n                fsm_sendFailure(FailureType_Failure_SyntaxError,\n                                \"Words were not entered correctly. Make sure you are using the substition cipher.\");\n                layoutHome();\n                return;\n            }\n        }\n    } else {\n        memzero(coded_word, sizeof(coded_word));\n        memzero(decoded_word, sizeof(decoded_word));\n    }\n\n    // concat to mnemonic\n    strlcat(mnemonic, decoded_character, MNEMONIC_BUF);\n\n    next_character();\n}\n\n/*\n * recovery_delete_character() - Deletes previously received recovery character\n *\n * INPUT\n *     none\n * OUTPUT\n *     none\n */\nvoid recovery_delete_character(void)\n{\n    if(strlen(mnemonic) > 0)\n    {\n        mnemonic[strlen(mnemonic) - 1] = '\\0';\n    }\n\n    next_character();\n}\n\n/*\n * recovery_cipher_finalize() - Finished mnemonic entry\n *\n * INPUT\n *     none\n * OUTPUT\n *     none\n */\nvoid recovery_cipher_finalize(void)\n{\n    static char CONFIDENTIAL new_mnemonic[MNEMONIC_BUF] = \"\";\n    static char CONFIDENTIAL temp_word[CURRENT_WORD_BUF];\n    volatile bool auto_completed = true;\n\n    /* Attempt to autocomplete each word */\n    char *tok = strtok(mnemonic, \" \");\n\n    while(tok) {\n        strlcpy(temp_word, tok, CURRENT_WORD_BUF);\n\n        auto_completed &= attempt_auto_complete(temp_word);\n\n        strlcat(new_mnemonic, temp_word, MNEMONIC_BUF);\n        strlcat(new_mnemonic, \" \", MNEMONIC_BUF);\n\n        tok = strtok(NULL, \" \");\n    }\n    memzero(temp_word, sizeof(temp_word));\n\n    if (!auto_completed && !enforce_wordlist) {\n        if (!dry_run) {\n            storage_reset();\n        }\n        fsm_sendFailure(FailureType_Failure_SyntaxError,\n                        \"Words were not entered correctly. Make sure you are using the substition cipher.\");\n        awaiting_character = false;\n        layoutHome();\n        return;\n    }\n\n    /* Truncate additional space at the end */\n    new_mnemonic[strlen(new_mnemonic) - 1] = '\\0';\n\n    if (!dry_run && (!enforce_wordlist || mnemonic_check(new_mnemonic))) {\n        storage_setMnemonic(new_mnemonic);\n        memzero(new_mnemonic, sizeof(new_mnemonic));\n        if (!enforce_wordlist) {\n            // not enforcing => mark storage as imported\n            storage_setImported(true);\n        }\n        storage_commit();\n        fsm_sendSuccess(\"Device recovered\");\n    } else if (dry_run) {\n        bool match = storage_isInitialized() && storage_containsMnemonic(new_mnemonic);\n        if (match) {\n            review(ButtonRequestType_ButtonRequest_Other, \"Recovery Dry Run\",\n                   \"The seed is valid and MATCHES the one in the device.\");\n            fsm_sendSuccess(\"The seed is valid and matches the one in the device.\");\n        } else if (mnemonic_check(new_mnemonic)) {\n            review(ButtonRequestType_ButtonRequest_Other, \"Recovery Dry Run\",\n                   \"The seed is valid, but DOES NOT MATCH the one in the device.\");\n            fsm_sendFailure(FailureType_Failure_Other,\n                            \"The seed is valid, but does not match the one in the device.\");\n        } else {\n            review(ButtonRequestType_ButtonRequest_Other, \"Recovery Dry Run\",\n                   \"The seed is INVALID, and DOES NOT MATCH the one in the device.\");\n            fsm_sendFailure(FailureType_Failure_Other,\n                            \"The seed is invalid, and does not match the one in the device.\");\n        }\n        memzero(new_mnemonic, sizeof(new_mnemonic));\n    } else {\n        session_clear(true);\n        fsm_sendFailure(FailureType_Failure_SyntaxError,\n                        \"Invalid mnemonic, are words in correct order?\");\n        recovery_abort();\n    }\n\n    memzero(new_mnemonic, sizeof(new_mnemonic));\n    awaiting_character = false;\n    memzero(mnemonic, sizeof(mnemonic));\n    memzero(cipher, sizeof(cipher));\n    layoutHome();\n}\n\n/*\n * recovery_cipher_abort() - Aborts recovery cipher process\n *\n * INPUT\n *     none\n * OUTPUT\n *     true/false of whether recovery was aborted\n */\nbool recovery_cipher_abort(void)\n{\n    if (awaiting_character) {\n        awaiting_character = false;\n        return true;\n    }\n    return false;\n}\n\n#if DEBUG_LINK\n/*\n * recovery_get_cipher() - Gets current cipher being show on display\n *\n * INPUT\n *     none\n * OUTPUT\n *     current cipher\n */\nconst char *recovery_get_cipher(void)\n{\n    return cipher;\n}\n\n/*\n * recovery_get_auto_completed_word() - Gets last auto completed word\n *\n * INPUT\n *     none\n * OUTPUT\n *     last auto completed word\n */\nconst char *recovery_get_auto_completed_word(void)\n{\n    return auto_completed_word;\n}\n#endif\n"], "fixing_code": ["/*\n * This file is part of the KeepKey project.\n *\n * Copyright (C) 2015 KeepKey LLC\n *\n * This library is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Lesser General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with this library.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#include \"keepkey/board/keepkey_board.h\"\n#include \"keepkey/board/layout.h\"\n#include \"keepkey/board/messages.h\"\n#include \"trezor/crypto/bip39.h\"\n#include \"trezor/crypto/memzero.h\"\n#include \"keepkey/firmware/app_layout.h\"\n#include \"keepkey/board/confirm_sm.h\"\n#include \"keepkey/firmware/fsm.h\"\n#include \"keepkey/firmware/home_sm.h\"\n#include \"keepkey/firmware/pin_sm.h\"\n#include \"keepkey/firmware/recovery_cipher.h\"\n#include \"keepkey/firmware/storage.h\"\n#include \"keepkey/rand/rng.h\"\n\n#include <string.h>\n#include <stdio.h>\n\n#define MAX_UNCYPHERED_WORDS (3)\n\nstatic bool recovery_started = false;\nstatic bool enforce_wordlist;\nstatic bool dry_run;\nstatic bool awaiting_character;\nstatic CONFIDENTIAL char mnemonic[MNEMONIC_BUF];\nstatic char english_alphabet[ENGLISH_ALPHABET_BUF] = \"abcdefghijklmnopqrstuvwxyz\";\nstatic CONFIDENTIAL char cipher[ENGLISH_ALPHABET_BUF];\n\n#if DEBUG_LINK\nstatic char auto_completed_word[CURRENT_WORD_BUF];\n#endif\n\nstatic void format_current_word(char *current_word, bool auto_completed);\nstatic uint32_t get_current_word_pos(void);\nstatic void get_current_word(char *current_word);\n\nstatic void recovery_abort(void) {\n    if (!dry_run) {\n        storage_reset();\n    }\n\n    recovery_started = false;\n    awaiting_character = false;\n    memzero(mnemonic, sizeof(mnemonic));\n    memzero(cipher, sizeof(cipher));\n}\n\n/// Formats the passed word to show position in mnemonic as well as characters\n/// left.\n///\n/// \\param current_word[in]    The string to format.\n/// \\param auto_completed[in]  Whether to format as an auto completed word.\nstatic void format_current_word(char *current_word, bool auto_completed)\n{\n    static char CONFIDENTIAL temp_word[CURRENT_WORD_BUF];\n    uint32_t word_num = get_current_word_pos() + 1;\n\n    snprintf(temp_word, CURRENT_WORD_BUF, \"%\" PRIu32 \".%s\", word_num, current_word);\n\n    /* Pad with dashes */\n    size_t pos_len = strlen(current_word);\n    if (pos_len < 4)\n    {\n        for (size_t i = 0; i < 4 - pos_len; i++)\n        {\n            strlcat(temp_word, \"-\", CURRENT_WORD_BUF);\n        }\n    }\n\n    /* Mark as auto completed */\n    if(auto_completed)\n    {\n        temp_word[strlen(temp_word) + 1] = '\\0';\n        temp_word[strlen(temp_word)] = '~';\n    }\n\n    strlcpy(current_word, temp_word, CURRENT_WORD_BUF);\n    memzero(temp_word, sizeof(temp_word));\n}\n\n/*\n * get_current_word_pos() - Returns the current word position in the mnemonic\n *\n * INPUT\n *     none\n * OUTPUT\n *     position in mnemonic\n */\nstatic uint32_t get_current_word_pos(void)\n{\n    char *pos_num = strchr(mnemonic, ' ');\n    uint32_t word_pos = 0;\n\n    while(pos_num != NULL)\n    {\n        word_pos++;\n        pos_num = strchr(++pos_num, ' ');\n    }\n\n    return word_pos;\n}\n\n/// \\returns the current word being entered by parsing the mnemonic thus far\n/// \\param current_word[out]  Array to populate with current word.\nstatic void get_current_word(char *current_word)\n{\n    char *pos = strrchr(mnemonic, ' ');\n\n    if(pos)\n    {\n        pos++;\n        strlcpy(current_word, pos, CURRENT_WORD_BUF);\n    }\n    else\n    {\n        strlcpy(current_word, mnemonic, CURRENT_WORD_BUF);\n    }\n}\n\nbool exact_str_match(const char *str1, const char *str2, uint32_t len)\n{\n    volatile uint32_t match = 0;\n\n    // Access through volatile ptrs to prevent compiler optimizations that\n    // might leak timing information.\n    const char volatile * volatile str1_v = str1;\n    const char volatile * volatile str2_v = str2;\n\n    for(uint32_t i = 0; i < len && i < CURRENT_WORD_BUF; i++)\n    {\n        if(str1_v[i] == str2_v[i])\n        {\n            match++;\n        } else {\n            match--;\n        }\n    }\n\n    return match == len;\n}\n\nbool attempt_auto_complete(char *partial_word)\n{\n    // Do lookup through volatile pointers to prevent the compiler from\n    // optimizing this loop into something that can leak timing information.\n    const char *const volatile * volatile wordlist =\n        (const char *const volatile *)mnemonic_wordlist();\n\n    uint32_t partial_word_len = strlen(partial_word), match = 0, found = 0;\n    bool precise_match = false;\n\n    static uint16_t CONFIDENTIAL permute[2049];\n    for (int i = 0; i < 2049; i++) {\n        permute[i] = i;\n    }\n    random_permute_u16(permute, 2048);\n\n    // We don't want the compiler to see through the fact that we're randomly\n    // permuting the order of iteration of the next few loops, in case it's\n    // smart enough to see through that and remove the permutation, so we tell\n    // it we've touched all of memory with some inline asm, and scare it off.\n    // This acts as an optimization barrier.\n    asm volatile (\"\" ::: \"memory\");\n\n    // Look for precise matches first (including null termination)\n    for (uint32_t volatile i = 0; wordlist[permute[i]] != 0; i++) {\n        if (exact_str_match(partial_word, wordlist[permute[i]], partial_word_len + 1)) {\n            strlcpy(partial_word, wordlist[permute[i]], CURRENT_WORD_BUF);\n            precise_match = true;\n        }\n    }\n\n    random_permute_u16(permute, 2048);\n    asm volatile (\"\" ::: \"memory\");\n\n    // Followed by partial matches (ignoring null termination)\n    for (uint32_t volatile i = 0; wordlist[permute[i]] != 0; i++) {\n        if (exact_str_match(partial_word, wordlist[permute[i]], partial_word_len)) {\n            match++;\n            found = i;\n        }\n    }\n\n    if (precise_match) {\n        memzero(permute, sizeof(permute));\n        return true;\n    }\n\n    /* Autocomplete if we can */\n    if (match == 1) {\n        strlcpy(partial_word, wordlist[permute[found]], CURRENT_WORD_BUF);\n        memzero(permute, sizeof(permute));\n        return true;\n    }\n\n    memzero(permute, sizeof(permute));\n    return false;\n}\n\n/*\n * recovery_cipher_init() - Display standard notification on LCD screen\n *\n * INPUT\n *     - passphrase_protection: whether to use passphrase protection\n *     - pin_protection: whether to use pin protection\n *     - language: language for device\n *     - label: label for device\n *     - _enforce_wordlist: whether to enforce bip 39 word list\n * OUTPUT\n *     none\n */\nvoid recovery_cipher_init(bool passphrase_protection, bool pin_protection,\n                          const char *language, const char *label, bool _enforce_wordlist,\n                          uint32_t _auto_lock_delay_ms, uint32_t _u2f_counter, bool _dry_run)\n{\n    enforce_wordlist = _enforce_wordlist;\n    dry_run = _dry_run;\n\n    if (!dry_run) {\n        if (pin_protection) {\n            if (!change_pin()) {\n                recovery_abort();\n                fsm_sendFailure(FailureType_Failure_ActionCancelled, \"PINs do not match\");\n                layoutHome();\n                return;\n            }\n        } else {\n            storage_setPin(\"\");\n        }\n\n        storage_setPassphraseProtected(passphrase_protection);\n        storage_setLanguage(language);\n        storage_setLabel(label);\n        storage_setAutoLockDelayMs(_auto_lock_delay_ms);\n        storage_setU2FCounter(_u2f_counter);\n    } else if (!pin_protect(\"Enter Your PIN\")) {\n        layoutHome();\n        return;\n    }\n\n    if (!confirm(ButtonRequestType_ButtonRequest_Other,\n                 dry_run ? \"Recovery Dry Run\" : \"Recovery\",\n                 \"When entering your recovery seed, use the substitution cipher \"\n                 \"and check that each word shows up correctly on the screen.\")) {\n        fsm_sendFailure(FailureType_Failure_ActionCancelled, \"Recovery cancelled\");\n        if (!dry_run)\n            storage_reset();\n        layoutHome();\n        return;\n    }\n\n    /* Clear mnemonic */\n    memset(mnemonic, 0, sizeof(mnemonic) / sizeof(char));\n\n    /* Set to recovery cipher mode and generate and show next cipher */\n    awaiting_character = true;\n    recovery_started = true;\n    next_character();\n}\n\n/*\n * next_character() - Randomizes cipher and displays it for next character entry\n *\n * INPUT\n *     none\n * OUTPUT\n *     none\n */\nvoid next_character(void)\n{\n    if (!recovery_started) {\n        recovery_abort();\n        fsm_sendFailure(FailureType_Failure_UnexpectedMessage, \"Not in Recovery mode\");\n        layoutHome();\n        return;\n    }\n\n    /* Scramble cipher */\n    strlcpy(cipher, english_alphabet, ENGLISH_ALPHABET_BUF);\n    random_permute_char(cipher, strlen(cipher));\n\n    static char CONFIDENTIAL current_word[CURRENT_WORD_BUF];\n    get_current_word(current_word);\n\n    /* Words should never be longer than 4 characters */\n    if (strlen(current_word) > 4) {\n        memzero(current_word, sizeof(current_word));\n\n        recovery_abort();\n        fsm_sendFailure(FailureType_Failure_SyntaxError,\n                        \"Words were not entered correctly. Make sure you are using the substition cipher.\");\n        layoutHome();\n        return;\n    }\n\n    CharacterRequest resp;\n    memset(&resp, 0, sizeof(CharacterRequest));\n\n    resp.word_pos = get_current_word_pos();\n    resp.character_pos = strlen(current_word);\n\n    msg_write(MessageType_MessageType_CharacterRequest, &resp);\n\n    /* Attempt to auto complete if we have at least 3 characters */\n    bool auto_completed = false;\n    if (strlen(current_word) >= 3) {\n        auto_completed = attempt_auto_complete(current_word);\n    }\n\n#if DEBUG_LINK\n    if (auto_completed) {\n        strlcpy(auto_completed_word, current_word, CURRENT_WORD_BUF);\n    } else {\n        auto_completed_word[0] = '\\0';\n    }\n#endif\n\n    /* Format current word and display it along with cipher */\n    format_current_word(current_word, auto_completed);\n\n    /* Show cipher and partial word */\n    layout_cipher(current_word, cipher);\n    memzero(current_word, sizeof(current_word));\n}\n\n/*\n * recovery_character() - Decodes character received from host\n *\n * INPUT\n *     - character: string to decode\n * OUTPUT\n *     none\n */\nvoid recovery_character(const char *character)\n{\n    if (!awaiting_character || !recovery_started) {\n        recovery_abort();\n        fsm_sendFailure(FailureType_Failure_UnexpectedMessage, \"Not in Recovery mode\");\n        layoutHome();\n        return;\n    }\n\n    if (strlen(mnemonic) + 1 > MNEMONIC_BUF - 1) {\n        recovery_abort();\n        fsm_sendFailure(FailureType_Failure_UnexpectedMessage,\n                        \"Too many characters attempted during recovery\");\n        layoutHome();\n        return;\n    }\n\n    char *pos = strchr(cipher, character[0]);\n\n    // If not a space and not a legitmate cipher character, send failure.\n    if (character[0] != ' ' && pos == NULL) {\n        recovery_abort();\n        fsm_sendFailure(FailureType_Failure_SyntaxError, \"Character must be from a to z\");\n        layoutHome();\n        return;\n    }\n\n    // Count of words we think the user has entered without using the cipher:\n    static int uncyphered_word_count = 0;\n    static bool definitely_using_cipher = false;\n    static CONFIDENTIAL char coded_word[12];\n    static CONFIDENTIAL char decoded_word[12];\n\n    if (!mnemonic[0]) {\n        uncyphered_word_count = 0;\n        definitely_using_cipher = false;\n        memzero(coded_word, sizeof(coded_word));\n        memzero(decoded_word, sizeof(decoded_word));\n    }\n\n    char decoded_character[2] = \" \";\n    if (character[0] != ' ') {\n        // Decode character using cipher if not space\n        decoded_character[0] = english_alphabet[(int)(pos - cipher)];\n\n        strlcat(coded_word, character, sizeof(coded_word));\n        strlcat(decoded_word, decoded_character, sizeof(decoded_word));\n\n        if (enforce_wordlist && 4 <= strlen(coded_word)) {\n            // Check & bail if the user is entering their seed without using the\n            // cipher. Note that for each word, this can give false positives about\n            // ~0.4% of the time (2048/26^4).\n\n            bool maybe_not_using_cipher = attempt_auto_complete(coded_word);\n            bool maybe_using_cipher = attempt_auto_complete(decoded_word);\n\n            if (!maybe_not_using_cipher && maybe_using_cipher) {\n                // Decrease the overall false positive rate by detecting that a\n                // user has entered a word which is definitely using the\n                // cipher.\n                definitely_using_cipher = true;\n            } else if (maybe_not_using_cipher && !definitely_using_cipher &&\n                       MAX_UNCYPHERED_WORDS < uncyphered_word_count++) {\n                recovery_abort();\n                fsm_sendFailure(FailureType_Failure_SyntaxError,\n                                \"Words were not entered correctly. Make sure you are using the substition cipher.\");\n                layoutHome();\n                return;\n            }\n        }\n    } else {\n        memzero(coded_word, sizeof(coded_word));\n        memzero(decoded_word, sizeof(decoded_word));\n    }\n\n    // concat to mnemonic\n    strlcat(mnemonic, decoded_character, MNEMONIC_BUF);\n\n    next_character();\n}\n\n/*\n * recovery_delete_character() - Deletes previously received recovery character\n *\n * INPUT\n *     none\n * OUTPUT\n *     none\n */\nvoid recovery_delete_character(void)\n{\n    if (!recovery_started) {\n        recovery_abort();\n        fsm_sendFailure(FailureType_Failure_UnexpectedMessage, \"Not in Recovery mode\");\n        layoutHome();\n        return;\n    }\n\n    if(strlen(mnemonic) > 0)\n    {\n        mnemonic[strlen(mnemonic) - 1] = '\\0';\n    }\n\n    next_character();\n}\n\n/*\n * recovery_cipher_finalize() - Finished mnemonic entry\n *\n * INPUT\n *     none\n * OUTPUT\n *     none\n */\nvoid recovery_cipher_finalize(void)\n{\n    if (!recovery_started) {\n        recovery_abort();\n        fsm_sendFailure(FailureType_Failure_UnexpectedMessage, \"Not in Recovery mode\");\n        layoutHome();\n        return;\n    }\n\n    static char CONFIDENTIAL new_mnemonic[MNEMONIC_BUF] = \"\";\n    static char CONFIDENTIAL temp_word[CURRENT_WORD_BUF];\n    volatile bool auto_completed = true;\n\n    /* Attempt to autocomplete each word */\n    char *tok = strtok(mnemonic, \" \");\n\n    while(tok) {\n        strlcpy(temp_word, tok, CURRENT_WORD_BUF);\n\n        auto_completed &= attempt_auto_complete(temp_word);\n\n        strlcat(new_mnemonic, temp_word, MNEMONIC_BUF);\n        strlcat(new_mnemonic, \" \", MNEMONIC_BUF);\n\n        tok = strtok(NULL, \" \");\n    }\n    memzero(temp_word, sizeof(temp_word));\n\n    if (!auto_completed && !enforce_wordlist) {\n        if (!dry_run) {\n            storage_reset();\n        }\n        fsm_sendFailure(FailureType_Failure_SyntaxError,\n                        \"Words were not entered correctly. Make sure you are using the substition cipher.\");\n        awaiting_character = false;\n        layoutHome();\n        return;\n    }\n\n    /* Truncate additional space at the end */\n    new_mnemonic[MAX(0u, strnlen(new_mnemonic, sizeof(new_mnemonic)) - 1)] = '\\0';\n\n    if (!dry_run && (!enforce_wordlist || mnemonic_check(new_mnemonic))) {\n        storage_setMnemonic(new_mnemonic);\n        memzero(new_mnemonic, sizeof(new_mnemonic));\n        if (!enforce_wordlist) {\n            // not enforcing => mark storage as imported\n            storage_setImported(true);\n        }\n        storage_commit();\n        fsm_sendSuccess(\"Device recovered\");\n    } else if (dry_run) {\n        bool match = storage_isInitialized() && storage_containsMnemonic(new_mnemonic);\n        if (match) {\n            review(ButtonRequestType_ButtonRequest_Other, \"Recovery Dry Run\",\n                   \"The seed is valid and MATCHES the one in the device.\");\n            fsm_sendSuccess(\"The seed is valid and matches the one in the device.\");\n        } else if (mnemonic_check(new_mnemonic)) {\n            review(ButtonRequestType_ButtonRequest_Other, \"Recovery Dry Run\",\n                   \"The seed is valid, but DOES NOT MATCH the one in the device.\");\n            fsm_sendFailure(FailureType_Failure_Other,\n                            \"The seed is valid, but does not match the one in the device.\");\n        } else {\n            review(ButtonRequestType_ButtonRequest_Other, \"Recovery Dry Run\",\n                   \"The seed is INVALID, and DOES NOT MATCH the one in the device.\");\n            fsm_sendFailure(FailureType_Failure_Other,\n                            \"The seed is invalid, and does not match the one in the device.\");\n        }\n        memzero(new_mnemonic, sizeof(new_mnemonic));\n    } else {\n        session_clear(true);\n        fsm_sendFailure(FailureType_Failure_SyntaxError,\n                        \"Invalid mnemonic, are words in correct order?\");\n        recovery_abort();\n    }\n\n    memzero(new_mnemonic, sizeof(new_mnemonic));\n    awaiting_character = false;\n    memzero(mnemonic, sizeof(mnemonic));\n    memzero(cipher, sizeof(cipher));\n    layoutHome();\n}\n\n/*\n * recovery_cipher_abort() - Aborts recovery cipher process\n *\n * INPUT\n *     none\n * OUTPUT\n *     true/false of whether recovery was aborted\n */\nbool recovery_cipher_abort(void)\n{\n    recovery_started = false;\n\n    if (awaiting_character) {\n        awaiting_character = false;\n        return true;\n    }\n    return false;\n}\n\n#if DEBUG_LINK\n/*\n * recovery_get_cipher() - Gets current cipher being show on display\n *\n * INPUT\n *     none\n * OUTPUT\n *     current cipher\n */\nconst char *recovery_get_cipher(void)\n{\n    return cipher;\n}\n\n/*\n * recovery_get_auto_completed_word() - Gets last auto completed word\n *\n * INPUT\n *     none\n * OUTPUT\n *     last auto completed word\n */\nconst char *recovery_get_auto_completed_word(void)\n{\n    return auto_completed_word;\n}\n#endif\n"], "filenames": ["lib/firmware/recovery_cipher.c"], "buggy_code_start_loc": [38], "buggy_code_end_loc": [534], "fixing_code_start_loc": [39], "fixing_code_end_loc": [561], "type": "CWE-354", "message": "Insufficient checks in the finite state machine of the ShapeShift KeepKey hardware wallet before firmware 6.2.2 allow a partial reset of cryptographic secrets to known values via crafted messages. Notably, this breaks the security of U2F for new server registrations and invalidates existing registrations. This vulnerability can be exploited by unauthenticated attackers and the interface is reachable via WebUSB.", "other": {"cve": {"id": "CVE-2019-18672", "sourceIdentifier": "cve@mitre.org", "published": "2019-12-06T18:15:12.700", "lastModified": "2020-03-02T15:15:10.857", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Insufficient checks in the finite state machine of the ShapeShift KeepKey hardware wallet before firmware 6.2.2 allow a partial reset of cryptographic secrets to known values via crafted messages. Notably, this breaks the security of U2F for new server registrations and invalidates existing registrations. This vulnerability can be exploited by unauthenticated attackers and the interface is reachable via WebUSB."}, {"lang": "es", "value": "Las comprobaciones insuficientes en la m\u00e1quina de estados finitos de la billetera de hardware ShapeShift KeepKey versiones de firmware anteriores a 6.2.2, permiten un restablecimiento parcial de los secretos criptogr\u00e1ficos a valores conocidos por medio de mensajes dise\u00f1ados. En particular, esto rompe la seguridad de U2F para nuevos registros del servidor e invalida los registros existentes. Esta vulnerabilidad puede ser explotada por atacantes no autenticados y la interfaz es accesible por medio de WebUSB."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-354"}]}], "configurations": [{"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:shapeshift:keepkey_firmware:*:*:*:*:*:*:*:*", "versionEndExcluding": "6.2.2", "matchCriteriaId": "F2E31C0B-7A1C-463C-B8ED-942F7C7BC9E3"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:shapeshift:keepkey_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "C96080B0-34F6-45C3-B3A1-6B029B62A118"}]}]}], "references": [{"url": "https://blog.inhq.net/posts/keepkey-CVE-2019-18672/", "source": "cve@mitre.org"}, {"url": "https://github.com/keepkey/keepkey-firmware/commit/769714fcb569e7a4faff9530a2d9ac1f9d6e5680", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://medium.com/shapeshift-stories/keepkey-release-notes-v-6f7d2ec78065", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://medium.com/shapeshift-stories/shapeshift-security-update-8ec89bb1b4e3", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/keepkey/keepkey-firmware/commit/769714fcb569e7a4faff9530a2d9ac1f9d6e5680"}}