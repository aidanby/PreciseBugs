{"buggy_code": ["/**\n @file packetParser.h\n\n @brief functions to parse and generate a ZRTP packet \n \n @author Johan Pascal\n\n @copyright Copyright (C) 2014 Belledonne Communications, Grenoble, France\n \n This program is free software; you can redistribute it and/or\n modify it under the terms of the GNU General Public License\n as published by the Free Software Foundation; either version 2\n of the License, or (at your option) any later version.\n \n This program is distributed in the hope that it will be useful,\n but WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n GNU General Public License for more details.\n \n You should have received a copy of the GNU General Public License\n along with this program; if not, write to the Free Software\n Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.\n */\n#ifndef PACKETPARSER_H\n#define PACKETPARSER_H\n\n#include <stdint.h>\n#include \"bzrtp/bzrtp.h\"\n\n/* header of ZRTP packet is 12 bytes : Preambule/Sequence Number + ZRTP Magic Cookie +  SSRC */\n#define ZRTP_PACKET_HEADER_LENGTH\t12\n#define ZRTP_PACKET_CRC_LENGTH\t\t4\n#define ZRTP_PACKET_OVERHEAD\t\t16\n\n#define\t\tBZRTP_PARSER_ERROR_INVALIDCRC  \t\t\t0xa001\n#define\t\tBZRTP_PARSER_ERROR_INVALIDPACKET\t\t0xa002\n#define\t\tBZRTP_PARSER_ERROR_OUTOFORDER\t\t\t0xa004\n#define\t\tBZRTP_PARSER_ERROR_INVALIDMESSAGE\t\t0xa008\n#define\t\tBZRTP_PARSER_ERROR_INVALIDCONTEXT\t\t0xa010\n#define\t\tBZRTP_PARSER_ERROR_UNMATCHINGCONFIRMMAC\t0xa020\n#define\t\tBZRTP_PARSER_ERROR_UNMATCHINGSSRC\t\t0xa040\n#define\t\tBZRTP_PARSER_ERROR_UNMATCHINGHASHCHAIN\t0xa080\n#define\t\tBZRTP_PARSER_ERROR_UNMATCHINGMAC\t\t0xa100\n#define\t\tBZRTP_PARSER_ERROR_UNEXPECTEDMESSAGE\t0xa200\n\n#define\t\tBZRTP_BUILDER_ERROR_INVALIDPACKET\t\t0x5001\n#define\t\tBZRTP_BUILDER_ERROR_INVALIDMESSAGE\t\t0x5002\n#define\t\tBZRTP_BUILDER_ERROR_INVALIDMESSAGETYPE\t0x5004\n#define\t\tBZRTP_BUILDER_ERROR_UNKNOWN\t\t\t\t0x5008\n#define\t\tBZRTP_BUILDER_ERROR_INVALIDCONTEXT\t\t0x5010\n\n#define\t\tBZRTP_CREATE_ERROR_INVALIDMESSAGETYPE\t\t\t0x0a01\n#define\t\tBZRTP_CREATE_ERROR_UNABLETOCREATECRYPTOCONTEXT\t0x0a02\n#define\t\tBZRTP_CREATE_ERROR_INVALIDCONTEXT\t\t\t\t0x0a04\n\n/* map all message type to an uint8_t value */\n#define\t\tMSGTYPE_INVALID\t\t0x00\n#define\t\tMSGTYPE_HELLO\t\t0x01\n#define\t\tMSGTYPE_HELLOACK\t0x02\n#define\t\tMSGTYPE_COMMIT\t\t0x03\n#define\t\tMSGTYPE_DHPART1\t\t0x04\n#define\t\tMSGTYPE_DHPART2\t\t0x05\n#define\t\tMSGTYPE_CONFIRM1\t0x06\n#define\t\tMSGTYPE_CONFIRM2\t0x07\n#define\t\tMSGTYPE_CONF2ACK\t0x08\n#define\t\tMSGTYPE_ERROR\t\t0x10\n#define\t\tMSGTYPE_ERRORACK\t0x11\n#define\t\tMSGTYPE_GOCLEAR\t\t0x12\n#define\t\tMSGTYPE_CLEARACK\t0x13\n#define\t\tMSGTYPE_SASRELAY\t0x14\n#define\t\tMSGTYPE_RELAYACK\t0x15\n#define\t\tMSGTYPE_PING\t\t0x16\n#define\t\tMSGTYPE_PINGACK\t\t0x17\n\n/**\n * @brief Store all zrtpPacket informations\n * according to type a specific structure type is mapped to the void * data pointer\n */\ntypedef struct bzrtpPacket_struct {\n\tuint16_t sequenceNumber; /**< set by packet parser to enable caller to retrieve the packet sequence number. This field is not used buy the packet creator, sequence number is given as a parameter when converting the message to a packet string. Used only when parsing a string into a packet struct */\n\tuint32_t sourceIdentifier; /**< the SSRC of current RTP stream */\n\tuint8_t  messageType; /**< the ZRTP message type mapped from strings to hard defined byte */\n\tuint16_t messageLength; /**< the ZRTP message length in bytes - the message length indicated in the message itself is in 32 bits words. Is not the packet length(do not include packet header and CRC) */\n\tvoid *messageData; /**< a pointer to the structure containing all the message field according to message type */\n\tuint8_t *packetString; /**< used to stored the string version of the packet build from the message data or keep a string copy of received packets */\n} bzrtpPacket_t;\n\n/**\n * Structure definition for all zrtp message type according to rfc section 5.2 to 5.16\n *\n */\n\n/**\n * @brief Hello Message rfc 5.2\n */\ntypedef struct bzrtpHelloMessage_struct {\n\tuint8_t version[4]; /**< a string defining the current version, shall be 1.10 */\n\tuint8_t clientIdentifier[16]; /**< a string identifing the vendor and release of ZRTP software */\n\tuint8_t H3[32]; /**< the hash image H3 (256 bits) */\n\tuint8_t ZID[12]; /**< unique identifier for ZRTP endpoint (96 bits) */\n\tuint8_t\tS; /**< The signature-capable flag. If signatures are not supported, the (S) flag MUST be set to zero (1 bit) */\n\tuint8_t M; /**< The MiTM flag (M) is a Boolean that is set to true if and only if this Hello message is sent from a device, usually a PBX, that has the capability to send an SASrelay message (1 bit) **/\n\tuint8_t P; /**< The Passive flag (P) is a Boolean normally set to false, and is set to true if and only if this Hello message is sent from a device that is configured to never send a Commit message (Section 5.4).  This would mean it cannot initiate secure sessions, but may act as a responder. (1 bit) */\n\tuint8_t hc; /**< hash count -zrtpPacket set to 0 means we support only HMAC-SHA256 (4 bits) */\n\tuint8_t supportedHash[7]; /**< list of supported hash algorithms mapped to uint8_t */\n\tuint8_t cc; /**< cipher count - set to 0 means we support only AES128-CFB128 (4 bits) */\n\tuint8_t supportedCipher[7]; /**< list of supported cipher algorithms mapped to uint8_t */\n\tuint8_t ac; /**< auth tag count - set to 0 mean we support only HMAC-SHA1-32 (4 bits) */\n\tuint8_t supportedAuthTag[7]; /**< list of supported SRTP authentication tag algorithms mapped to uint8_t */\n\tuint8_t kc; /**< key agreement count - set to 0 means we support only Diffie-Hellman-Merkle 3072 (4 bits) */\n\tuint8_t supportedKeyAgreement[7]; /**< list of supported key agreement algorithms mapped to uint8_t */\n\tuint8_t sc; /**< sas count - set to 0 means we support only base32 (4 bits) */\n\tuint8_t supportedSas[7]; /**< list of supported Sas representations (4 chars string) */\n\tuint8_t MAC[8]; /**< HMAC over the whole message, keyed by the hash image H2 (64 bits)*/\n} bzrtpHelloMessage_t;\n\n/**\n * @brief Hello ACK Message rfc 5.3\n * This message contains no data but only a length and message type which are stored in the bzrtpPacket_t structure\n * There the no need to define a structure type for this packet\n */\n\n/**\n *\n * @brief Commit Message rfc 5.4\n * This message can be of 3 different types: DHM, PreShared and Multistream, some field of it may be used only by certain type of message\n * It is generated by the initiator (see section 4.2 for commit contention)\n */\ntypedef struct bzrtpCommitMessage_struct {\n\tuint8_t H2[32]; /**< the hash image H2 (256 bits) */\n\tuint8_t ZID[12]; /**< initiator's unique identifier for ZRTP endpoint (96 bits) */\n\tuint8_t hashAlgo; /**< the hash algorithm identifier rfc section 5.1.2 mapped to an integer */\n\tuint8_t cipherAlgo; /**< the cipher algorithm identifier rfc section 5.1.3 mapped to an integer */\n\tuint8_t authTagAlgo; /**< the auth tag algorithm identifier rfc section 5.1.4 mapped to an integer */\n\tuint8_t keyAgreementAlgo; /**< the key agreement algorithm identifier rfc section 5.1.5. It can either be a key exchange algorithm or the commit packet type in case of preShared or multistream commit message mapped to an integer */\n\tuint8_t sasAlgo; /**< the sas rendering algorithm identifier rfc section 5.1.6 mapped to an integer */\n\tuint8_t hvi[32]; /**< only for DH commit : a hash of initiator's DHPart2 and responder's Hello message rfc section 4.4.1.1 */\n\tuint8_t nonce[16]; /**< only for preShared or Multistream modes : a 128 bits random number generated by the initiator */\n\tuint8_t keyID[8]; /**< only for preShared mode : the preshared key identifier */\n\tuint8_t MAC[8]; /**< HMAC over the whole message, keyed by the hash image H1 (64 bits)*/\n} bzrtpCommitMessage_t;\n\n\n/**\n *\n * @brief DHPart Message rfc 5.5 and rfc 5.6\n * DHPart1 and DHPart2 message have the same structure\n * DHPart1 is generated by the responder, and DHPart2 by the initiator\n */\ntypedef struct bzrtpDHPartMessage_struct {\n\tuint8_t H1[32]; /**< the hash image H1 (256 bits) */\n\tuint8_t rs1ID[8]; /**< hash of the retained secret 1 (64 bits) */\n\tuint8_t rs2ID[8]; /**< hash of the retained secret 2 (64 bits) */\n\tuint8_t auxsecretID[8]; /**< hash of the auxiliary shared secret (64 bits) */\n\tuint8_t pbxsecretID[8]; /**< hash of the trusted MiTM PBX shared secret pbxsecret, defined in section 7.3.1 (64 bits) */\n\tuint8_t *pv; /* Key exchange public value (length depends on key agreement type) */\n\tuint8_t MAC[8]; /**< HMAC over the whole message, keyed by the hash image H1 (64 bits)*/\n} bzrtpDHPartMessage_t;\n\n/**\n *\n * @brief Confirm Message rfc 5.7\n * Confirm1 and Confirm2 messages have the same structure\n * Confirm1 is generated by the responder and Confirm2 by the initiator\n * Part of the message is encrypted using the negotiated block cipher for media encryption. Keys ares zrtpkeyr for responder and zrtpkeyi for initiator\n */\ntypedef struct bzrtpConfirmMessage_struct {\n\tuint8_t confirm_mac[8]; /**< a MAC computed over the encrypted part of the message (64 bits) */\n\tuint8_t CFBIV[16]; /**< The CFB Initialization Vector is a 128-bit random nonce (128 bits) */\n\tuint8_t H0[32]; /**< the hash image H0 - Encrypted - (256 bits) */\n\tuint16_t sig_len; /**< The SAS signature length.  If no SAS signature (described in Section 7.2) is present, all bits are set to zero.  The signature length is in words and includes the signature type block.  If the calculated signature octet count is not a multiple of 4, zeros are added to pad it out to a word boundary.  If no signature is present, the overall length of the Confirm1 or Confirm2 message will be set to 19 words - Encrypted - (9 bits) */\n\tuint8_t E; /**< The PBX Enrollment flag (E) is a Boolean bit defined in Section 7.3.1 - Encrypted - (1 bit) */\n\tuint8_t V; /**< The SAS Verified flag (V) is a Boolean bit defined in Section 7.1. - Encrypted - (1 bit) */\n\tuint8_t A; /**< The Allow Clear flag (A) is a Boolean bit defined in Section 4.7.2 - Encrypted - (1 bit) */\n\tuint8_t D; /**< The Disclosure Flag (D) is a Boolean bit defined in Section 11. - Encrypted - (1 bit) */\n\tuint32_t cacheExpirationInterval; /**< The cache expiration interval is defined in Section 4.9 - Encrypted - (32 bits) */\n\tuint8_t signatureBlockType[4]; /**< Optionnal signature type : \"PGP \" or \"X509\" string - Encrypted - (32 bits) */\n\tuint8_t *signatureBlock; /**< Optionnal signature block as decribded in section 7.2 - Encrypted - (variable length) */\n\t\n} bzrtpConfirmMessage_t;\n\n/**\n * @brief Conf2 ACK Message rfc 5.8\n * This message contains no data but only a length and message type which are stored in the bzrtpPacket_t structure\n * There the no need to define a structure type for this packet\n */\n\n/**\n * @brief Error Message rfc section 5.9\n * The Error message is sent to terminate an in-process ZRTP key agreement exchange due to an error.\n * There is no need to define a structure for this packet as it contains length and message type which are stored\n * in the bzrtpPacket_t structure and a 32 bits integer error code only\n */\n\n/**\n * @brief Error ACK Message rfc 5.10\n * This message contains no data but only a length and message type which are stored in the bzrtpPacket_t structure\n * There the no need to define a structure type for this packet\n */\n\n/**\n * @brief GoClear Message rfc 5.11\n * Support for the GoClear message is OPTIONAL in the protocol, and it is sent to switch from SRTP to RTP.\n */\ntypedef struct bzrtpGoClearMessage_struct {\n\tuint8_t clear_mac[8]; /**< The clear_mac is used to authenticate the GoClear message so that bogus GoClear messages introduced by an attacker can be detected and discarded. (64 bits) */\n} bzrtpGoClearMessage_t;\n\n/**\n *\n * @brief Clear ACK Message rfc 5.12\n * This message contains no data but only a length and message type which are stored in the bzrtpPacket_t structure\n * There the no need to define a structure type for this packet\n */\n\n/**\n * @brief SASRelay Message rfc 5.13\n * The SASrelay message is sent by a trusted MiTM, most often a PBX.  It is not sent as a response to a packet, but is sent as a self-initiated packet by the trusted MiTM (Section 7.3).  It can only be sent after the rest of the ZRTP key negotiations have completed, after the Confirm messages and their ACKs.  It can only be sent after the trusted MiTM has finished key negotiations with the other party, because it is the other party's SAS that is being relayed.  It is sent with retry logic until a RelayACK message (Section 5.14) is received or the retry schedule has been exhausted. Part of the message is encrypted using the negotiated block cipher for media encryption.\n * Depending on whether the trusted MiTM had taken the role of the initiator or the responder during the ZRTP key negotiation, the\n * SASrelay message is encrypted with zrtpkeyi or zrtpkeyr.\n */\ntypedef struct bzrtpSASRelayMessage_struct {\n\tuint8_t MAC[8]; /**< a MAC computed over the encrypted part of the message (64 bits) */\n\tuint8_t CFBIV[16]; /**< The CFB Initialization Vector is a 128-bit random nonce (128 bits) */\n\tuint16_t sig_len; /**< The SAS signature length.  The trusted MiTM MAY compute a digital signature on the SAS hash, as described in Section 7.2, using a persistent signing key owned by the trusted MiTM.  If no SAS signature is present, all bits are set to zero.  The signature length is in words and includes the signature type block.  If the calculated signature octet count is not a multiple of 4, zeros are added to pad it out to a word boundary.  If no signature block is present, the overall length of the SASrelay message will be set to 19 words.*/\n\tuint8_t V; /**< The SAS Verified flag (V) is a Boolean bit defined in Section 7.1. - Encrypted - (1 bit) */\n\tuint8_t A; /**< The Allow Clear flag (A) is a Boolean bit defined in Section 4.7.2 - Encrypted - (1 bit) */\n\tuint8_t D; /**< The Disclosure Flag (D) is a Boolean bit defined in Section 11. - Encrypted - (1 bit) */\n\tuint8_t renderingScheme[4]; /**< the SAS rendering scheme for the relayed sashash, which will be the same rendering scheme used by the other party on the other side of the trusted MiTM. - Encrypted - (32 bits) */ \n\tuint8_t relayedSasHash[32];\t/**< the sashash relayed from the other party.  The first 32-bit word of the sashash contains the sasvalue, which may be rendered to the user using the specified SAS rendering scheme.  If this SASrelay message is being sent to a ZRTP client that does not trust this MiTM, the sashash will be ignored by the recipient and should be set to zeros by the PBX. - Encrypted - (256 bits) */\n\tuint8_t signatureBlockType; /**< Optionnal signature type : \"PGP \" or \"X509\" string - Encrypted - (32 bits) */\n\tuint8_t *signatureBlock; /**< Optionnal signature block as decribded in section 7.2 - Encrypted - (variable length) */\n\n} bzrtpSASRelayMessage_t;\n\n/**\n * @brief Relay ACK Message rfc 5.14\n * This message contains no data but only a length and message type which are stored in the bzrtpPacket_t structure\n * There the no need to define a structure type for this packet\n */\n\n/**\n * @brief Ping Message\n * The Ping and PingACK messages are unrelated to the rest of the ZRTP protocol.  No ZRTP endpoint is required to generate a Ping message, but every ZRTP endpoint MUST respond to a Ping message with a PingACK message.\n */\ntypedef struct bzrtpPingMessage_struct {\n\tuint8_t version[4]; /**< a string defining the current version, shall be 1.10 (32 bits) */\n\tuint8_t endpointHash[8]; /**< see section 5.16 for the endpointHash definition (64 bits) */\n} bzrtpPingMessage_t;\n\n/**\n *\n * @brief PingAck Message\n * The Ping and PingACK messages are unrelated to the rest of the ZRTP protocol.  No ZRTP endpoint is required to generate a Ping message, but every ZRTP endpoint MUST respond to a Ping message with a PingACK message.\n */\ntypedef struct bzrtpPingAckMessage_struct {\n\tuint8_t version[4]; /**< a string defining the current version, shall be 1.10 (32 bits) */\n\tuint8_t endpointHash[8]; /**< see section 5.16 for the endpointHash definition (64 bits) */\n\tuint8_t endpointHashReceived[8]; /**< the endpoint hash received in the ping Message we're acknowledging (64 bits) */\n\tuint32_t SSRC; /**< the SSRC received in the ping packet we're acknowledging (32 bits) */\n} bzrtpPingAckMessage_t;\n\n\n/** \n * @brief Parse a string which shall be a valid ZRTP packet\n * Check validity and allocate the bzrtpPacket structure but do not parse the message except for type and length.\n * messageData structure field is not allocated by this function (use then bzrtp_packetParse for that).\n * The packet check and actual message parsing are split in two functions to avoid useless parsing when message is\n * to be discarded as the check will give message type (in case of message repetition for example)\n *\n * @param[in]\tinput\t\t\t\t\t\tThe string buffer storing the complete ZRTP packet\n * @param[in]\tinputLength\t\t\t\t\tInput length in bytes\n * @param[in]\tlastValidSequenceNumber\t\tIf the sequence number of this packet is smaller than this param, packet will be discarded\n *\t\t\t\t\t\t\t\t\t\t\tand an error code returned\n * @param[out]\texitCode\t\t\t\t\t0 on success, error code otherwise\n *\n * @return\t\tThe create bzrtpPacket structure(to be freed using bzrtp_freeZrtpPacket). NULL on error\n */\nbzrtpPacket_t *bzrtp_packetCheck(const uint8_t * input, uint16_t inputLength, uint16_t lastValidSequenceNumber, int *exitCode);\n\n\n/**\n * @brief Parse the packet to extract the message and allocate the matching message structure if needed\n *\n * @param[in]\t\tzrtpContext\t\t\tThe current ZRTP context, some parameters(key agreement algorithm) may be needed to parse packet.\n * @param[in]\t\tzrtpChannelContext\tThe channel context this packet is intended to(channel context and packet must match peer SSRC).\n * @param[in]\t\tinput\t\t\t\tThe string buffer storing the complete ZRTP packet\n * @param[in]\t\tinputLength\t\t\tInput length in bytes\n * @param[in]\t\tzrtpPacket\t\t\tThe zrtpPacket structure allocated by previous call to bzrtpPacketCheck\n *\n * @return \t0 on sucess, error code otherwise\n */\nint bzrtp_packetParser(bzrtpContext_t *zrtpContext, bzrtpChannelContext_t *zrtpChannelContext, const uint8_t * input, uint16_t inputLength, bzrtpPacket_t *zrtpPacket); \n\n\n/**\n * @brief Create an empty packet and allocate the messageData according to requested packetType\n *\n * @param[in]\t\tzrtpContext\t\t\tThe current ZRTP context, some data (H chain or others, may be needed to create messages)\n * @param[in]\t\tzrtpChannelContext\tThe channel context this packet is intended to\n * @param[in]\t\tmessageType\t\t\tThe 32bit integer mapped to the message type to be created\n * @param[out]\t\texitCode\t\t\t0 on success, error code otherwise\n *\n * @return\t\tAn empty packet initialised to get data for the requested paquet tyep. NULL on error\n */ \nbzrtpPacket_t *bzrtp_createZrtpPacket(bzrtpContext_t *zrtpContext, bzrtpChannelContext_t *zrtpChannelContext, uint32_t messageType, int *exitCode);\n\n\n/**\n * @brief Create a ZRTP packet string from the ZRTP packet values present in the structure\n * messageType, messageData and sourceIdentifier in zrtpPacket must have been correctly set before calling this function\n *\n * @param[in]\t\tzrtpContext\t\t\t\tA zrtp context where to find H0-H3 to compute MAC requested by some paquets or encryption's key for commit/SASRelay packet\n * @param[in]\t\tzrtpChannelContext\t\tThe channel context this packet is intended to\n * @param[in/out]\tzrtpPacket\t\t\t\tThe zrtpPacket structure containing the message Data structure, output is stored in ->packetString\n * @param[in]\t\tsequenceNumber\t\t\tSequence number of this packet\n *\n * @return\t\t\t0 on success, error code otherwise\n *\n */\nint bzrtp_packetBuild(bzrtpContext_t *zrtpContext,  bzrtpChannelContext_t *zrtpChannelContext, bzrtpPacket_t *zrtpPacket, uint16_t sequenceNumber);\n\n\n/**\n * @brief Deallocate zrtp Packet\n *\n * @param[in] zrtpPacket\tThe packet to be freed\n *\n */\nvoid bzrtp_freeZrtpPacket(bzrtpPacket_t *zrtpPacket);\n\n/**\n * @brief Modify the current sequence number of the packet in the packetString and sequenceNumber fields\n * The CRC at the end of packetString is also updated\n * \n * param[in/out]\tzrtpPacket\t\tThe zrtpPacket to modify, the packetString must have been generated by\n * \t\t\t\t\t\t\t\t\ta call to bzrtp_packetBuild on this packet\n * param[in]\t\tsequenceNumber\tThe new sequence number to insert in the packetString\n * \n * return\t\t0 on succes, error code otherwise\n */\nint bzrtp_packetUpdateSequenceNumber(bzrtpPacket_t *zrtpPacket, uint16_t sequenceNumber);\n#endif /* PACKETPARSER_H */\n", "/**\n @file packetParser.c\n \n @brief functions to parse and generate a ZRTP packet \n \n @author Johan Pascal\n\n @copyright Copyright (C) 2014 Belledonne Communications, Grenoble, France\n \n This program is free software; you can redistribute it and/or\n modify it under the terms of the GNU General Public License\n as published by the Free Software Foundation; either version 2\n of the License, or (at your option) any later version.\n \n This program is distributed in the hope that it will be useful,\n but WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n GNU General Public License for more details.\n \n You should have received a copy of the GNU General Public License\n along with this program; if not, write to the Free Software\n Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.\n */\n\n#include <stdlib.h>\n#include <string.h>\n#include \"typedef.h\"\n#include \"packetParser.h\"\n#include <bctoolbox/crypto.h>\n#include \"cryptoUtils.h\"\n\n/* DEBUG */\n#include <stdio.h>\n\n/* minimum length of a ZRTP packet: 12 bytes header + 12 bytes message(shortest are ACK messages) + 4 bytes CRC */\n#define ZRTP_MIN_PACKET_LENGTH 28\n\n/* maximum length of a ZRTP packet: 3072 bytes get it from GNU-ZRTP CPP code */\n#define ZRTP_MAX_PACKET_LENGTH 3072\n\n/* header of ZRTP message is 12 bytes : Preambule/Message Length + Message Type(2 words) */\n#define ZRTP_MESSAGE_HEADER_LENGTH 12\n\n/* length of the non optional and fixed part of all messages, in bytes */\n#define ZRTP_HELLOMESSAGE_FIXED_LENGTH\t\t\t88 \n#define ZRTP_HELLOACKMESSAGE_FIXED_LENGTH\t\t12\n#define ZRTP_COMMITMESSAGE_FIXED_LENGTH \t\t84\n#define ZRTP_DHPARTMESSAGE_FIXED_LENGTH \t\t84\n#define ZRTP_CONFIRMMESSAGE_FIXED_LENGTH\t\t76 \n#define ZRTP_CONF2ACKMESSAGE_FIXED_LENGTH \t\t12\n#define ZRTP_ERRORMESSAGE_FIXED_LENGTH \t\t\t16\n#define ZRTP_ERRORACKMESSAGE_FIXED_LENGTH \t\t12\n#define ZRTP_GOCLEARMESSAGE_FIXED_LENGTH\t\t20 \n#define ZRTP_CLEARACKMESSAGE_FIXED_LENGTH \t\t12\n#define ZRTP_SASRELAYMESSAGE_FIXED_LENGTH \t\t76\n#define ZRTP_RELAYACKMESSAGE_FIXED_LENGTH \t\t12\n#define ZRTP_PINGMESSAGE_FIXED_LENGTH \t\t\t24\n#define ZRTP_PINGACKMESSAGE_FIXED_LENGTH \t\t36\n\n/*** local functions prototypes ***/\n\n/**\n * Return the variable private value length in bytes according to given key agreement algorythm\n *\n * @param[in]\tkeyAgreementAlgo\tThe key agreement algo mapped to an integer as defined in cryptoWrapper.h\n *\n * @return\t\tthe private value length in bytes\n *\n */\nuint16_t computeKeyAgreementPrivateValueLength(uint8_t keyAgreementAlgo);\n\n/**\n * @brief Retrieve the 8 char string value message type from the int32_t code\n *\n * @param[in] messageType\t\tThe messageType code\n *\n * @return\tan 9 char string : 8 chars message type as specified in rfc section 5.1.1 + string terminating char\n */\nuint8_t *messageTypeInttoString(uint32_t messageType);\n\n/**\n * @brief Map the 8 char string value message type to an int32_t\n *\n * @param[in] messageTypeString\t\tan 8 bytes string matching a zrtp message type\n *\n * @return\ta 32-bits unsigned integer mapping the message type\n */\nint32_t messageTypeStringtoInt(uint8_t messageTypeString[8]);\n\n/**\n * @brief Write the message header(preambule, length, message type) into the given output buffer\n *\n * @param[out]\toutputBuffer\t\tMessage starts at the begining of this buffer\n * @param[in]\tmessageLength\t\tMessage length in bytes! To be converted into 32bits words before being inserted in the message header\n * @param[in]\tmessageType\t\t\tAn 8 chars string for the message type (validity is not checked by this function)\n *\n */\nvoid zrtpMessageSetHeader(uint8_t *outputBuffer, uint16_t messageLength, uint8_t messageType[8]);\n\n\n\n\n/*** Public functions implementation ***/\n\n/* First call this function to check packet validity and create the packet structure */\nbzrtpPacket_t *bzrtp_packetCheck(const uint8_t * input, uint16_t inputLength, uint16_t lastValidSequenceNumber, int *exitCode) {\n\tbzrtpPacket_t *zrtpPacket;\n\tuint16_t sequenceNumber;\n\tuint32_t packetCRC;\n\tuint16_t messageLength;\n\tuint32_t messageType;\n\n\t/* first check that the packet is a ZRTP one */\n\t/* is the length compatible with a ZRTP packet */ \n\tif ((inputLength<ZRTP_MIN_PACKET_LENGTH) || (inputLength>ZRTP_MAX_PACKET_LENGTH)) {\n\t\t *exitCode = BZRTP_PARSER_ERROR_INVALIDPACKET;\n\t\t return NULL;\n\t}\n\n\t/* check ZRTP packet format from rfc section 5 \n    0                   1                   2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |0 0 0 1|Not Used (set to zero) |         Sequence Number       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |                 Magic Cookie 'ZRTP' (0x5a525450)              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |                        Source Identifier                      |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |                                                               |\n   |           ZRTP Message (length depends on Message Type)       |\n   |                            . . .                              |\n   |                                                               |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |                          CRC (1 word)                         |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+*/\n\tif ((input[0]>>4 != 0x01) || (input[4]!= (uint8_t)((ZRTP_MAGIC_COOKIE>>24)&0xFF)) || (input[5]!= (uint8_t)((ZRTP_MAGIC_COOKIE>>16)&0xFF)) || (input[6]!= (uint8_t)((ZRTP_MAGIC_COOKIE>>8)&0xFF)) || (input[7]!= (uint8_t)(ZRTP_MAGIC_COOKIE&0xFF))) {\n\t\t*exitCode = BZRTP_PARSER_ERROR_INVALIDPACKET;\n\t\treturn NULL;\n\t}\n\n\t/* Check the sequence number : it must be > to the last valid one (given in parameter) to discard out of order packets\n\t * TODO: what if we got a Sequence Number overflowing the 16 bits ? */\n\tsequenceNumber = (((uint16_t)input[2])<<8) | ((uint16_t)input[3]);\n\tif (sequenceNumber <= lastValidSequenceNumber) {\n\t\t*exitCode = BZRTP_PARSER_ERROR_OUTOFORDER;\n\t\treturn NULL;\n\t}\n\n\t/* Check the CRC : The CRC is calculated across the entire ZRTP packet, including the ZRTP header and the ZRTP message, but not including the CRC field.*/\n\tpacketCRC = ((((uint32_t)input[inputLength-4])<<24)&0xFF000000) | ((((uint32_t)input[inputLength-3])<<16)&0x00FF0000) | ((((uint32_t)input[inputLength-2])<<8)&0x0000FF00) | (((uint32_t)input[inputLength-1])&0x000000FF);\n\tif (bzrtp_CRC32((uint8_t *)input, inputLength - 4) != packetCRC) {\n\t\t*exitCode = BZRTP_PARSER_ERROR_INVALIDCRC;\n\t\treturn NULL;\n\t}\n\n\t/* check message header : \n\t *  0                   1                   2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |0 1 0 1 0 0 0 0 0 1 0 1 1 0 1 0|             length            |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |            Message Type Block            (2 words)            |\n   |                                                               |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+*/\n\tif ((input[ZRTP_PACKET_HEADER_LENGTH]!=0x50) || (input[ZRTP_PACKET_HEADER_LENGTH+1]!=0x5a)) {\n\t\t*exitCode = BZRTP_PARSER_ERROR_INVALIDMESSAGE;\n\t\treturn NULL;\n\t}\n\n\t/* get the length from the message: it is expressed in 32bits words, convert it to bytes (4*) */\n\tmessageLength = 4*(((((uint16_t)input[ZRTP_PACKET_HEADER_LENGTH+2])<<8)&0xFF00) | (((uint16_t)input[ZRTP_PACKET_HEADER_LENGTH+3])&0x00FF));\n\n\t/* get the message Type */\n\tmessageType = messageTypeStringtoInt((uint8_t *)(input+ZRTP_PACKET_HEADER_LENGTH+4));\n\n\tif (messageType == MSGTYPE_INVALID) {\n\t\t*exitCode = BZRTP_PARSER_ERROR_INVALIDMESSAGE;\n\t\treturn NULL;\n\t}\n\n\t/* packet and message seems to be valid, so allocate a structure and parse it */\n\tzrtpPacket = (bzrtpPacket_t *)malloc(sizeof(bzrtpPacket_t));\n\tmemset(zrtpPacket, 0, sizeof(bzrtpPacket_t));\n\tzrtpPacket->sequenceNumber = sequenceNumber;\n\tzrtpPacket->messageLength = messageLength;\n\tzrtpPacket->messageType = messageType;\n\tzrtpPacket->messageData = NULL;\n\tzrtpPacket->packetString = NULL;\n\n\t/* get the SSRC */\n\tzrtpPacket->sourceIdentifier = ((((uint32_t)input[8])<<24)&0xFF000000) | ((((uint32_t)input[9])<<16)&0x00FF0000) | ((((uint32_t)input[10])<<8)&0x0000FF00) | (((uint32_t)input[11])&0x000000FF);\n\n\t*exitCode = 0;\n\treturn zrtpPacket;\n}\n\n\n#define MIN(a, b) (((a) < (b)) ? (a) : (b))\n\n\n/* Call this function after the packetCheck one, to actually parse the packet : create and fill the messageData structure */\nint bzrtp_packetParser(bzrtpContext_t *zrtpContext, bzrtpChannelContext_t *zrtpChannelContext, const uint8_t * input, uint16_t inputLength, bzrtpPacket_t *zrtpPacket) {\n\n\tint i;\n\n\t/* now allocate and fill the correct message structure according to the message type */\n\t/* messageContent points to the begining of the ZRTP message */\n\tuint8_t *messageContent = (uint8_t *)(input+ZRTP_PACKET_HEADER_LENGTH+ZRTP_MESSAGE_HEADER_LENGTH);\n\n\tswitch (zrtpPacket->messageType) {\n\t\tcase MSGTYPE_HELLO : \n\t\t\t{\n\t\t\t\t/* allocate a Hello message structure */\n\t\t\t\tbzrtpHelloMessage_t *messageData;\n\t\t\t\tmessageData = (bzrtpHelloMessage_t *)malloc(sizeof(bzrtpHelloMessage_t));\n\n\t\t\t\t/* fill it */\n\t\t\t\tmemcpy(messageData->version, messageContent, 4);\n\t\t\t\tmessageContent +=4;\n\t\t\t\tmemcpy(messageData->clientIdentifier, messageContent, 16);\n\t\t\t\tmessageContent +=16;\n\t\t\t\tmemcpy(messageData->H3, messageContent, 32);\n\t\t\t\tmessageContent +=32;\n\t\t\t\tmemcpy(messageData->ZID, messageContent, 12);\n\t\t\t\tmessageContent +=12;\n\t\t\t\tmessageData->S = ((*messageContent)>>6)&0x01;\n\t\t\t\tmessageData->M = ((*messageContent)>>5)&0x01;\n\t\t\t\tmessageData->P = ((*messageContent)>>4)&0x01;\n\t\t\t\tmessageContent +=1;\n\t\t\t\tmessageData->hc = MIN((*messageContent)&0x0F, 7);\n\t\t\t\tmessageContent +=1;\n\t\t\t\tmessageData->cc = MIN(((*messageContent)>>4)&0x0F, 7);\n\t\t\t\tmessageData->ac = MIN((*messageContent)&0x0F, 7);\n\t\t\t\tmessageContent +=1;\n\t\t\t\tmessageData->kc = MIN(((*messageContent)>>4)&0x0F, 7);\n\t\t\t\tmessageData->sc = MIN((*messageContent)&0x0F, 7);\n\t\t\t\tmessageContent +=1;\n\n\t\t\t\t/* Check message length according to value in hc, cc, ac, kc and sc */\n\t\t\t\tif (zrtpPacket->messageLength != ZRTP_HELLOMESSAGE_FIXED_LENGTH + 4*((uint16_t)(messageData->hc)+(uint16_t)(messageData->cc)+(uint16_t)(messageData->ac)+(uint16_t)(messageData->kc)+(uint16_t)(messageData->sc))) {\n\t\t\t\t\tfree(messageData);\n\t\t\t\t\treturn BZRTP_PARSER_ERROR_INVALIDMESSAGE;\n\t\t\t\t}\n\n\t\t\t\t/* parse the variable length part: algorithms types */\n\t\t\t\tfor (i=0; i<messageData->hc; i++) {\n\t\t\t\t\tmessageData->supportedHash[i] = cryptoAlgoTypeStringToInt(messageContent, ZRTP_HASH_TYPE);\n\t\t\t\t\tmessageContent +=4;\n\t\t\t\t}\n\t\t\t\tfor (i=0; i<messageData->cc; i++) {\n\t\t\t\t\tmessageData->supportedCipher[i] = cryptoAlgoTypeStringToInt(messageContent, ZRTP_CIPHERBLOCK_TYPE);\n\t\t\t\t\tmessageContent +=4;\n\t\t\t\t}\n\t\t\t\tfor (i=0; i<messageData->ac; i++) {\n\t\t\t\t\tmessageData->supportedAuthTag[i] = cryptoAlgoTypeStringToInt(messageContent, ZRTP_AUTHTAG_TYPE);\n\t\t\t\t\tmessageContent +=4;\n\t\t\t\t}\n\t\t\t\tfor (i=0; i<messageData->kc; i++) {\n\t\t\t\t\tmessageData->supportedKeyAgreement[i] = cryptoAlgoTypeStringToInt(messageContent, ZRTP_KEYAGREEMENT_TYPE);\n\t\t\t\t\tmessageContent +=4;\n\t\t\t\t}\n\t\t\t\tfor (i=0; i<messageData->sc; i++) {\n\t\t\t\t\tmessageData->supportedSas[i] = cryptoAlgoTypeStringToInt(messageContent, ZRTP_SAS_TYPE);\n\t\t\t\t\tmessageContent +=4;\n\t\t\t\t}\n\n\t\t\t\taddMandatoryCryptoTypesIfNeeded(ZRTP_HASH_TYPE, messageData->supportedHash, &messageData->hc);\n\t\t\t\taddMandatoryCryptoTypesIfNeeded(ZRTP_CIPHERBLOCK_TYPE, messageData->supportedCipher, &messageData->cc);\n\t\t\t\taddMandatoryCryptoTypesIfNeeded(ZRTP_AUTHTAG_TYPE, messageData->supportedAuthTag, &messageData->ac);\n\t\t\t\taddMandatoryCryptoTypesIfNeeded(ZRTP_KEYAGREEMENT_TYPE, messageData->supportedKeyAgreement, &messageData->kc);\n\t\t\t\taddMandatoryCryptoTypesIfNeeded(ZRTP_SAS_TYPE, messageData->supportedSas, &messageData->sc);\n\n\t\t\t\tmemcpy(messageData->MAC, messageContent, 8);\n\t\t\t\t\n\t\t\t\t/* attach the message structure to the packet one */\n\t\t\t\tzrtpPacket->messageData = (void *)messageData;\n\n\t\t\t\t/* the parsed Hello packet must be saved as it may be used to generate commit message or the total_hash */\n\t\t\t\tzrtpPacket->packetString = (uint8_t *)malloc(inputLength*sizeof(uint8_t));\n\t\t\t\tmemcpy(zrtpPacket->packetString, input, inputLength); /* store the whole packet even if we may use the message only */\n\t\t\t}\n\t\t\tbreak; /* MSGTYPE_HELLO */\n\n\t\tcase MSGTYPE_HELLOACK :\n\t\t\t{\n\t\t\t\t/* check message length */\n\t\t\t\tif (zrtpPacket->messageLength != ZRTP_HELLOACKMESSAGE_FIXED_LENGTH) {\n\t\t\t\t\treturn BZRTP_PARSER_ERROR_INVALIDMESSAGE;\n\t\t\t\t}\n\n\n\t\t\t}\n\t\t\tbreak; /* MSGTYPE_HELLOACK */\n\n\t\tcase MSGTYPE_COMMIT:\n\t\t\t{\n\t\t\t\tuint8_t checkH3[32];\n\t\t\t\tuint8_t checkMAC[32];\n\t\t\t\tbzrtpHelloMessage_t *peerHelloMessageData;\n\t\t\t\tuint16_t variableLength = 0;\n\n\t\t\t\t/* allocate a commit message structure */\n\t\t\t\tbzrtpCommitMessage_t *messageData;\n\t\t\t\tmessageData = (bzrtpCommitMessage_t *)malloc(sizeof(bzrtpCommitMessage_t));\n\n\t\t\t\t/* fill the structure */\n\t\t\t\tmemcpy(messageData->H2, messageContent, 32);\n\t\t\t\tmessageContent +=32;\n\n\t\t\t\t/* We have now H2, check it matches the H3 we had in the hello message H3=SHA256(H2) and that the Hello message MAC is correct */\n\t\t\t\tif (zrtpChannelContext->peerPackets[HELLO_MESSAGE_STORE_ID] == NULL) {\n\t\t\t\t\tfree (messageData);\n\t\t\t\t\t/* we have no Hello message in this channel, this commit shall never have arrived, discard it as invalid */\n\t\t\t\t\treturn BZRTP_PARSER_ERROR_UNEXPECTEDMESSAGE;\n\t\t\t\t}\n\t\t\t\tpeerHelloMessageData = (bzrtpHelloMessage_t *)zrtpChannelContext->peerPackets[HELLO_MESSAGE_STORE_ID]->messageData;\n\t\t\t\t/* Check H3 = SHA256(H2) */\n\t\t\t\tbctoolbox_sha256(messageData->H2, 32, 32, checkH3);\n\t\t\t\tif (memcmp(checkH3, peerHelloMessageData->H3, 32) != 0) {\n\t\t\t\t\tfree (messageData);\n\t\t\t\t\treturn BZRTP_PARSER_ERROR_UNMATCHINGHASHCHAIN;\n\t\t\t\t}\n\t\t\t\t/* Check the hello MAC message. \n\t\t\t\t * MAC is 8 bytes long and is computed on the message(skip the ZRTP_PACKET_HEADER) and exclude the mac itself (-8 bytes from message Length) */\n\t\t\t\tbctoolbox_hmacSha256(messageData->H2, 32, zrtpChannelContext->peerPackets[HELLO_MESSAGE_STORE_ID]->packetString+ZRTP_PACKET_HEADER_LENGTH, zrtpChannelContext->peerPackets[HELLO_MESSAGE_STORE_ID]->messageLength-8, 8, checkMAC);\n\t\t\t\tif (memcmp(checkMAC, peerHelloMessageData->MAC, 8) != 0) {\n\t\t\t\t\tfree (messageData);\n\t\t\t\t\treturn BZRTP_PARSER_ERROR_UNMATCHINGMAC;\n\t\t\t\t}\n\n\t\t\t\tmemcpy(messageData->ZID, messageContent, 12);\n\t\t\t\tmessageContent +=12;\n\t\t\t\tmessageData->hashAlgo = cryptoAlgoTypeStringToInt(messageContent, ZRTP_HASH_TYPE);\n\t\t\t\tmessageContent += 4;\n\t\t\t\tmessageData->cipherAlgo = cryptoAlgoTypeStringToInt(messageContent, ZRTP_CIPHERBLOCK_TYPE);\n\t\t\t\tmessageContent += 4;\n\t\t\t\tmessageData->authTagAlgo = cryptoAlgoTypeStringToInt(messageContent, ZRTP_AUTHTAG_TYPE);\n\t\t\t\tmessageContent += 4;\n\t\t\t\tmessageData->keyAgreementAlgo = cryptoAlgoTypeStringToInt(messageContent, ZRTP_KEYAGREEMENT_TYPE);\n\t\t\t\tmessageContent += 4;\n\t\t\t\t/* commit message length depends on the key agreement type choosen (and set in the zrtpContext->keyAgreementAlgo) */\n\t\t\t\tswitch(messageData->keyAgreementAlgo) {\n\t\t\t\t\tcase ZRTP_KEYAGREEMENT_DH2k :\n\t\t\t\t\tcase ZRTP_KEYAGREEMENT_EC25 :\n\t\t\t\t\tcase ZRTP_KEYAGREEMENT_DH3k :\n\t\t\t\t\tcase ZRTP_KEYAGREEMENT_EC38 :\n\t\t\t\t\tcase ZRTP_KEYAGREEMENT_EC52 :\n\t\t\t\t\t\tvariableLength = 32; /* hvi is 32 bytes length in DH Commit message format */\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase ZRTP_KEYAGREEMENT_Prsh :\n\t\t\t\t\t\tvariableLength = 24; /* nonce (16 bytes) and keyID(8 bytes) are 24 bytes length in preshared Commit message format */\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase ZRTP_KEYAGREEMENT_Mult :\n\t\t\t\t\t\tvariableLength = 16; /* nonce is 24 bytes length in multistream Commit message format */\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tfree(messageData);\n\t\t\t\t\t\treturn BZRTP_PARSER_ERROR_INVALIDMESSAGE;\n\t\t\t\t}\n\n\t\t\t\tif (zrtpPacket->messageLength != ZRTP_COMMITMESSAGE_FIXED_LENGTH + variableLength) {\n\t\t\t\t\tfree(messageData);\n\t\t\t\t\treturn BZRTP_PARSER_ERROR_INVALIDMESSAGE;\n\t\t\t\t}\n\t\t\t\tmessageData->sasAlgo = cryptoAlgoTypeStringToInt(messageContent, ZRTP_SAS_TYPE);\n\t\t\t\tmessageContent += 4;\n\n\t\t\t\t/* if it is a multistream or preshared commit, get the 16 bytes nonce */\n\t\t\t\tif ((messageData->keyAgreementAlgo == ZRTP_KEYAGREEMENT_Prsh) || (messageData->keyAgreementAlgo == ZRTP_KEYAGREEMENT_Mult)) {\n\t\t\t\t\tmemcpy(messageData->nonce, messageContent, 16);\n\t\t\t\t\tmessageContent +=16;\n\n\t\t\t\t\t/* and the keyID for preshared commit only */\n\t\t\t\t\tif (messageData->keyAgreementAlgo == ZRTP_KEYAGREEMENT_Prsh) {\n\t\t\t\t\t\tmemcpy(messageData->keyID, messageContent, 8);\n\t\t\t\t\t\tmessageContent +=8;\n\t\t\t\t\t}\n\t\t\t\t} else { /* it's a DH commit message, get the hvi */\n\t\t\t\t\tmemcpy(messageData->hvi, messageContent, 32);\n\t\t\t\t\tmessageContent +=32;\n\t\t\t\t}\n\n\t\t\t\t/* get the MAC and attach the message data to the packet structure */\n\t\t\t\tmemcpy(messageData->MAC, messageContent, 8);\n\t\t\t\tzrtpPacket->messageData = (void *)messageData;\n\n\t\t\t\t/* the parsed commit packet must be saved as it is used to generate the total_hash */\n\t\t\t\tzrtpPacket->packetString = (uint8_t *)malloc(inputLength*sizeof(uint8_t));\n\t\t\t\tmemcpy(zrtpPacket->packetString, input, inputLength); /* store the whole packet even if we may use the message only */\n\t\t\t}\n\t\t\tbreak; /* MSGTYPE_COMMIT */\n\t\tcase MSGTYPE_DHPART1 :\n\t\tcase MSGTYPE_DHPART2 :\n\t\t\t{\n\t\t\t\tbzrtpDHPartMessage_t *messageData;\n\n\t\t\t\t/*check message length, depends on the selected key agreement algo set in zrtpContext */\n\t\t\t\tuint16_t pvLength = computeKeyAgreementPrivateValueLength(zrtpChannelContext->keyAgreementAlgo);\n\t\t\t\tif (pvLength == 0) {\n\t\t\t\t\treturn BZRTP_PARSER_ERROR_INVALIDCONTEXT;\n\t\t\t\t}\n\n\t\t\t\tif (zrtpPacket->messageLength != ZRTP_DHPARTMESSAGE_FIXED_LENGTH+pvLength) {\n\t\t\t\t\treturn BZRTP_PARSER_ERROR_INVALIDMESSAGE;\n\t\t\t\t}\n\n\t\t\t\t/* allocate a DHPart message structure and pv */\n\t\t\t\tmessageData = (bzrtpDHPartMessage_t *)malloc(sizeof(bzrtpDHPartMessage_t));\n\t\t\t\tmessageData->pv = (uint8_t *)malloc(pvLength*sizeof(uint8_t));\n\n\t\t\t\t/* fill the structure */\n\t\t\t\tmemcpy(messageData->H1, messageContent, 32);\n\t\t\t\tmessageContent +=32;\n\n\t\t\t\t/* We have now H1, check it matches the H2 we had in the commit message H2=SHA256(H1) and that the Commit message MAC is correct */\n\t\t\t\tif ( zrtpChannelContext->role == RESPONDER) { /* do it only if we are responder (we received a commit packet) */\n\t\t\t\t\tuint8_t checkH2[32];\n\t\t\t\t\tuint8_t checkMAC[32];\n\t\t\t\t\tbzrtpCommitMessage_t *peerCommitMessageData;\n\n\t\t\t\t\tif (zrtpChannelContext->peerPackets[COMMIT_MESSAGE_STORE_ID] == NULL) {\n\t\t\t\t\t\tfree (messageData);\n\t\t\t\t\t\t/* we have no Commit message in this channel, this DHPart2 shall never have arrived, discard it as invalid */\n\t\t\t\t\t\treturn BZRTP_PARSER_ERROR_UNEXPECTEDMESSAGE;\n\t\t\t\t\t}\n\t\t\t\t\tpeerCommitMessageData = (bzrtpCommitMessage_t *)zrtpChannelContext->peerPackets[COMMIT_MESSAGE_STORE_ID]->messageData;\n\t\t\t\t\t/* Check H2 = SHA256(H1) */\n\t\t\t\t\tbctoolbox_sha256(messageData->H1, 32, 32, checkH2);\n\t\t\t\t\tif (memcmp(checkH2, peerCommitMessageData->H2, 32) != 0) {\n\t\t\t\t\t\tfree (messageData);\n\t\t\t\t\t\treturn BZRTP_PARSER_ERROR_UNMATCHINGHASHCHAIN;\n\t\t\t\t\t}\n\t\t\t\t\t/* Check the Commit MAC message. \n\t\t\t\t\t * MAC is 8 bytes long and is computed on the message(skip the ZRTP_PACKET_HEADER) and exclude the mac itself (-8 bytes from message Length) */\n\t\t\t\t\tbctoolbox_hmacSha256(messageData->H1, 32, zrtpChannelContext->peerPackets[COMMIT_MESSAGE_STORE_ID]->packetString+ZRTP_PACKET_HEADER_LENGTH, zrtpChannelContext->peerPackets[COMMIT_MESSAGE_STORE_ID]->messageLength-8, 8, checkMAC);\n\t\t\t\t\tif (memcmp(checkMAC, peerCommitMessageData->MAC, 8) != 0) {\n\t\t\t\t\t\tfree (messageData);\n\t\t\t\t\t\treturn BZRTP_PARSER_ERROR_UNMATCHINGMAC;\n\t\t\t\t\t}\n\t\t\t\t} else { /* if we are initiator(we didn't received any commit message and then no H2), we must check that H3=SHA256(SHA256(H1)) and the Hello message MAC */\n\t\t\t\t\tuint8_t checkH2[32];\n\t\t\t\t\tuint8_t checkH3[32];\n\t\t\t\t\tuint8_t checkMAC[32];\n\t\t\t\t\tbzrtpHelloMessage_t *peerHelloMessageData;\n\n\t\t\t\t\tif (zrtpChannelContext->peerPackets[HELLO_MESSAGE_STORE_ID] == NULL) {\n\t\t\t\t\t\tfree (messageData);\n\t\t\t\t\t\t/* we have no Hello message in this channel, this DHPart1 shall never have arrived, discard it as invalid */\n\t\t\t\t\t\treturn BZRTP_PARSER_ERROR_UNEXPECTEDMESSAGE;\n\t\t\t\t\t}\n\t\t\t\t\tpeerHelloMessageData = (bzrtpHelloMessage_t *)zrtpChannelContext->peerPackets[HELLO_MESSAGE_STORE_ID]->messageData;\n\t\t\t\t\t/* Check H3 = SHA256(SHA256(H1)) */\n\t\t\t\t\tbctoolbox_sha256(messageData->H1, 32, 32, checkH2);\n\t\t\t\t\tbctoolbox_sha256(checkH2, 32, 32, checkH3);\n\t\t\t\t\tif (memcmp(checkH3, peerHelloMessageData->H3, 32) != 0) {\n\t\t\t\t\t\tfree (messageData);\n\t\t\t\t\t\treturn BZRTP_PARSER_ERROR_UNMATCHINGHASHCHAIN;\n\t\t\t\t\t}\n\t\t\t\t\t/* Check the hello MAC message. \n\t\t\t\t\t * MAC is 8 bytes long and is computed on the message(skip the ZRTP_PACKET_HEADER) and exclude the mac itself (-8 bytes from message Length) */\n\t\t\t\t\tbctoolbox_hmacSha256(checkH2, 32, zrtpChannelContext->peerPackets[HELLO_MESSAGE_STORE_ID]->packetString+ZRTP_PACKET_HEADER_LENGTH, zrtpChannelContext->peerPackets[HELLO_MESSAGE_STORE_ID]->messageLength-8, 8, checkMAC);\n\t\t\t\t\tif (memcmp(checkMAC, peerHelloMessageData->MAC, 8) != 0) {\n\t\t\t\t\t\tfree (messageData);\n\t\t\t\t\t\treturn BZRTP_PARSER_ERROR_UNMATCHINGMAC;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tmemcpy(messageData->rs1ID, messageContent, 8);\n\t\t\t\tmessageContent +=8;\n\t\t\t\tmemcpy(messageData->rs2ID, messageContent, 8);\n\t\t\t\tmessageContent +=8;\n\t\t\t\tmemcpy(messageData->auxsecretID, messageContent, 8);\n\t\t\t\tmessageContent +=8;\n\t\t\t\tmemcpy(messageData->pbxsecretID, messageContent, 8);\n\t\t\t\tmessageContent +=8;\n\t\t\t\tmemcpy(messageData->pv, messageContent, pvLength);\n\t\t\t\tmessageContent +=pvLength;\n\t\t\t\tmemcpy(messageData->MAC, messageContent, 8);\n\n\t\t\t\t/* attach the message structure to the packet one */\n\t\t\t\tzrtpPacket->messageData = (void *)messageData;\n\n\t\t\t\t/* the parsed commit packet must be saved as it is used to generate the total_hash */\n\t\t\t\tzrtpPacket->packetString = (uint8_t *)malloc(inputLength*sizeof(uint8_t));\n\t\t\t\tmemcpy(zrtpPacket->packetString, input, inputLength); /* store the whole packet even if we may use the message only */\n\t\t\t}\n\t\t\tbreak; /* MSGTYPE_DHPART1 and MSGTYPE_DHPART2 */\n\t\tcase MSGTYPE_CONFIRM1:\n\t\tcase MSGTYPE_CONFIRM2:\n\t\t\t{\n\t\t\t\tuint8_t *confirmMessageKey = NULL;\n\t\t\t\tuint8_t *confirmMessageMacKey = NULL;\n\t\t\t\tbzrtpConfirmMessage_t *messageData;\n\t\t\t\tuint16_t cipherTextLength;\n\t\t\t\tuint8_t computedHmac[8];\n\t\t\t\tuint8_t *confirmPlainMessageBuffer;\n\t\t\t\tuint8_t *confirmPlainMessage;\n\n\t\t\t\t/* we shall first decrypt and validate the message, check we have the keys to do it */\n\t\t\t\tif (zrtpChannelContext->role == RESPONDER) { /* responder uses initiator's keys to decrypt */\n\t\t\t\t\tif ((zrtpChannelContext->zrtpkeyi == NULL) || (zrtpChannelContext->mackeyi == NULL)) {\n\t\t\t\t\t\treturn BZRTP_PARSER_ERROR_INVALIDCONTEXT;\n\t\t\t\t\t}\n\t\t\t\t\tconfirmMessageKey = zrtpChannelContext->zrtpkeyi;\n\t\t\t\t\tconfirmMessageMacKey = zrtpChannelContext->mackeyi;\n\t\t\t\t}\n\n\t\t\t\tif (zrtpChannelContext->role == INITIATOR) { /* the iniator uses responder's keys to decrypt */\n\t\t\t\t\tif ((zrtpChannelContext->zrtpkeyr == NULL) || (zrtpChannelContext->mackeyr == NULL)) {\n\t\t\t\t\t\treturn BZRTP_PARSER_ERROR_INVALIDCONTEXT;\n\t\t\t\t\t}\n\t\t\t\t\tconfirmMessageKey = zrtpChannelContext->zrtpkeyr;\n\t\t\t\t\tconfirmMessageMacKey = zrtpChannelContext->mackeyr;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t/* allocate a confirm message structure */\n\t\t\t\tmessageData = (bzrtpConfirmMessage_t *)malloc(sizeof(bzrtpConfirmMessage_t));\n\n\t\t\t\t/* get the mac and the IV */\n\t\t\t\tmemcpy(messageData->confirm_mac, messageContent, 8);\n\t\t\t\tmessageContent +=8;\n\t\t\t\tmemcpy(messageData->CFBIV, messageContent, 16);\n\t\t\t\tmessageContent +=16;\n\n\n\t\t\t\t\n\t\t\t\t/* get the cipher text length */\n\t\t\t\tcipherTextLength = zrtpPacket->messageLength - ZRTP_MESSAGE_HEADER_LENGTH - 24; /* confirm message is header, confirm_mac(8 bytes), CFB IV(16 bytes), encrypted part */\n\n\t\t\t\t/* validate the mac over the cipher text */\n\t\t\t\tzrtpChannelContext->hmacFunction(confirmMessageMacKey, zrtpChannelContext->hashLength, messageContent, cipherTextLength, 8, computedHmac);\n\t\t\t\t\n\t\t\t\tif (memcmp(computedHmac, messageData->confirm_mac, 8) != 0) { /* confirm_mac doesn't match */\n\t\t\t\t\tfree(messageData);\n\t\t\t\t\treturn BZRTP_PARSER_ERROR_UNMATCHINGCONFIRMMAC;\n\t\t\t\t}\n\n\t\t\t\t/* get plain message */\n\t\t\t\tconfirmPlainMessageBuffer = (uint8_t *)malloc(cipherTextLength*sizeof(uint8_t));\n\t\t\t\tzrtpChannelContext->cipherDecryptionFunction(confirmMessageKey, messageData->CFBIV, messageContent, cipherTextLength, confirmPlainMessageBuffer);\n\t\t\t\tconfirmPlainMessage = confirmPlainMessageBuffer; /* point into the allocated buffer */\n\n\t\t\t\t/* parse it */\n\t\t\t\tmemcpy(messageData->H0, confirmPlainMessage, 32);\n\t\t\t\tconfirmPlainMessage +=33; /* +33 because next 8 bits are unused */\n\n\t\t\t\t/* Hash chain checking: if we are in multichannel or shared mode, we had not DHPart and then no H1 */\n\t\t\t\tif (zrtpChannelContext->keyAgreementAlgo == ZRTP_KEYAGREEMENT_Prsh || zrtpChannelContext->keyAgreementAlgo == ZRTP_KEYAGREEMENT_Mult) {\n\t\t\t\t\t/* compute the H1=SHA256(H0) we never received */\n\t\t\t\t\tuint8_t checkH1[32];\n\t\t\t\t\tbctoolbox_sha256(messageData->H0, 32, 32, checkH1);\n\n\t\t\t\t\t/* if we are responder, we received a commit packet with H2 then check that H2=SHA256(H1) and that the commit message MAC keyed with H1 match */\n\t\t\t\t\tif ( zrtpChannelContext->role == RESPONDER) {\n\t\t\t\t\t\tuint8_t checkH2[32];\n\t\t\t\t\t\tuint8_t checkMAC[32];\n\t\t\t\t\t\tbzrtpCommitMessage_t *peerCommitMessageData;\n\n\t\t\t\t\t\tif (zrtpChannelContext->peerPackets[COMMIT_MESSAGE_STORE_ID] == NULL) {\n\t\t\t\t\t\t\tfree (messageData);\n\t\t\t\t\t\t\t/* we have no Commit message in this channel, this Confirm2 shall never have arrived, discard it as invalid */\n\t\t\t\t\t\t\treturn BZRTP_PARSER_ERROR_UNEXPECTEDMESSAGE;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpeerCommitMessageData = (bzrtpCommitMessage_t *)zrtpChannelContext->peerPackets[COMMIT_MESSAGE_STORE_ID]->messageData;\n\t\t\t\t\t\t/* Check H2 = SHA256(H1) */\n\t\t\t\t\t\tbctoolbox_sha256(checkH1, 32, 32, checkH2);\n\t\t\t\t\t\tif (memcmp(checkH2, peerCommitMessageData->H2, 32) != 0) {\n\t\t\t\t\t\t\tfree (messageData);\n\t\t\t\t\t\t\treturn BZRTP_PARSER_ERROR_UNMATCHINGHASHCHAIN;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/* Check the Commit MAC message. \n\t\t\t\t\t\t * MAC is 8 bytes long and is computed on the message(skip the ZRTP_PACKET_HEADER) and exclude the mac itself (-8 bytes from message Length) */\n\t\t\t\t\t\tbctoolbox_hmacSha256(checkH1, 32, zrtpChannelContext->peerPackets[COMMIT_MESSAGE_STORE_ID]->packetString+ZRTP_PACKET_HEADER_LENGTH, zrtpChannelContext->peerPackets[COMMIT_MESSAGE_STORE_ID]->messageLength-8, 8, checkMAC);\n\t\t\t\t\t\tif (memcmp(checkMAC, peerCommitMessageData->MAC, 8) != 0) {\n\t\t\t\t\t\t\tfree (messageData);\n\t\t\t\t\t\t\treturn BZRTP_PARSER_ERROR_UNMATCHINGMAC;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else { /* if we are initiator(we didn't received any commit message and then no H2), we must check that H3=SHA256(SHA256(H1)) and the Hello message MAC */\n\t\t\t\t\t\tuint8_t checkH2[32];\n\t\t\t\t\t\tuint8_t checkH3[32];\n\t\t\t\t\t\tuint8_t checkMAC[32];\n\t\t\t\t\t\tbzrtpHelloMessage_t *peerHelloMessageData;\n\n\t\t\t\t\t\tif (zrtpChannelContext->peerPackets[HELLO_MESSAGE_STORE_ID] == NULL) {\n\t\t\t\t\t\t\tfree (messageData);\n\t\t\t\t\t\t\t/* we have no Hello message in this channel, this Confirm1 shall never have arrived, discard it as invalid */\n\t\t\t\t\t\t\treturn BZRTP_PARSER_ERROR_UNEXPECTEDMESSAGE;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpeerHelloMessageData = (bzrtpHelloMessage_t *)zrtpChannelContext->peerPackets[HELLO_MESSAGE_STORE_ID]->messageData;\n\t\t\t\t\t\t/* Check H3 = SHA256(SHA256(H1)) */\n\t\t\t\t\t\tbctoolbox_sha256(checkH1, 32, 32, checkH2);\n\t\t\t\t\t\tbctoolbox_sha256(checkH2, 32, 32, checkH3);\n\t\t\t\t\t\tif (memcmp(checkH3, peerHelloMessageData->H3, 32) != 0) {\n\t\t\t\t\t\t\tfree (messageData);\n\t\t\t\t\t\t\treturn BZRTP_PARSER_ERROR_UNMATCHINGHASHCHAIN;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/* Check the hello MAC message. \n\t\t\t\t\t\t * MAC is 8 bytes long and is computed on the message(skip the ZRTP_PACKET_HEADER) and exclude the mac itself (-8 bytes from message Length) */\n\t\t\t\t\t\tbctoolbox_hmacSha256(checkH2, 32, zrtpChannelContext->peerPackets[HELLO_MESSAGE_STORE_ID]->packetString+ZRTP_PACKET_HEADER_LENGTH, zrtpChannelContext->peerPackets[HELLO_MESSAGE_STORE_ID]->messageLength-8, 8, checkMAC);\n\t\t\t\t\t\tif (memcmp(checkMAC, peerHelloMessageData->MAC, 8) != 0) {\n\t\t\t\t\t\t\tfree (messageData);\n\t\t\t\t\t\t\treturn BZRTP_PARSER_ERROR_UNMATCHINGMAC;\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\t\t\t} else { /* we are in DHM mode */\n\t\t\t\t\t/* We have now H0, check it matches the H1 we had in the DHPart message H1=SHA256(H0) and that the DHPart message MAC is correct */\n\t\t\t\t\tuint8_t checkH1[32];\n\t\t\t\t\tuint8_t checkMAC[32];\n\t\t\t\t\tbzrtpDHPartMessage_t *peerDHPartMessageData;\n\n\t\t\t\t\tif (zrtpChannelContext->peerPackets[DHPART_MESSAGE_STORE_ID] == NULL) {\n\t\t\t\t\t\tfree (messageData);\n\t\t\t\t\t\t/* we have no DHPART message in this channel, this confirm shall never have arrived, discard it as invalid */\n\t\t\t\t\t\treturn BZRTP_PARSER_ERROR_UNEXPECTEDMESSAGE;\n\t\t\t\t\t}\n\t\t\t\t\tpeerDHPartMessageData = (bzrtpDHPartMessage_t *)zrtpChannelContext->peerPackets[DHPART_MESSAGE_STORE_ID]->messageData;\n\t\t\t\t\t/* Check H1 = SHA256(H0) */\n\t\t\t\t\tbctoolbox_sha256(messageData->H0, 32, 32, checkH1);\n\t\t\t\t\tif (memcmp(checkH1, peerDHPartMessageData->H1, 32) != 0) {\n\t\t\t\t\t\tfree (messageData);\n\t\t\t\t\t\treturn BZRTP_PARSER_ERROR_UNMATCHINGHASHCHAIN;\n\t\t\t\t\t}\n\t\t\t\t\t/* Check the DHPart message. \n\t\t\t\t\t * MAC is 8 bytes long and is computed on the message(skip the ZRTP_PACKET_HEADER) and exclude the mac itself (-8 bytes from message Length) */\n\t\t\t\t\tbctoolbox_hmacSha256(messageData->H0, 32, zrtpChannelContext->peerPackets[DHPART_MESSAGE_STORE_ID]->packetString+ZRTP_PACKET_HEADER_LENGTH, zrtpChannelContext->peerPackets[DHPART_MESSAGE_STORE_ID]->messageLength-8, 8, checkMAC);\n\t\t\t\t\tif (memcmp(checkMAC, peerDHPartMessageData->MAC, 8) != 0) {\n\t\t\t\t\t\tfree (messageData);\n\t\t\t\t\t\treturn BZRTP_PARSER_ERROR_UNMATCHINGMAC;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tmessageData->sig_len = ((uint16_t)(confirmPlainMessage[0]&0x01))<<8 | (((uint16_t)confirmPlainMessage[1])&0x00FF);\n\t\t\t\tconfirmPlainMessage += 2;\n\t\t\t\tmessageData->E = ((*confirmPlainMessage)&0x08)>>3;\n\t\t\t\tmessageData->V = ((*confirmPlainMessage)&0x04)>>2;\n\t\t\t\tmessageData->A = ((*confirmPlainMessage)&0x02)>>1;\n\t\t\t\tmessageData->D = (*confirmPlainMessage)&0x01;\n\t\t\t\tconfirmPlainMessage += 1;\n\n\t\t\t\tmessageData->cacheExpirationInterval = (((uint32_t)confirmPlainMessage[0])<<24) | (((uint32_t)confirmPlainMessage[1])<<16) | (((uint32_t)confirmPlainMessage[2])<<8) | ((uint32_t)confirmPlainMessage[3]);\n\t\t\t\tconfirmPlainMessage += 4;\n\n\n\t\t\t\t/* if sig_len indicate a signature, parse it */\n\t\t\t\tif (messageData->sig_len>0) {\n\t\t\t\t\tmemcpy(messageData->signatureBlockType, confirmPlainMessage, 4);\n\t\t\t\t\tconfirmPlainMessage += 4;\n\t\t\t\t\t/* allocate memory for the signature block, sig_len is in words(32 bits) and includes the signature block type word */\n\t\t\t\t\tmessageData->signatureBlock = (uint8_t *)malloc(4*(messageData->sig_len-1)*sizeof(uint8_t));\n\t\t\t\t\tmemcpy(messageData->signatureBlock, confirmPlainMessage, 4*(messageData->sig_len-1));\n\t\t\t\t} else {\n\t\t\t\t\tmessageData->signatureBlock  = NULL;\n\t\t\t\t}\n\n\t\t\t\t/* free plain buffer */\n\t\t\t\tfree(confirmPlainMessageBuffer);\n\n\t\t\t\t/* the parsed commit packet must be saved as it is used to check correct packet repetition */\n\t\t\t\tzrtpPacket->packetString = (uint8_t *)malloc(inputLength*sizeof(uint8_t));\n\t\t\t\tmemcpy(zrtpPacket->packetString, input, inputLength); /* store the whole packet even if we may use the message only */\n\n\t\t\t\t/* attach the message structure to the packet one */\n\t\t\t\tzrtpPacket->messageData = (void *)messageData;\n\t\t\t}\n\t\t\tbreak; /* MSGTYPE_CONFIRM1 and MSGTYPE_CONFIRM2 */\n\n\t\tcase MSGTYPE_CONF2ACK:\n\t\t\t/* nothing to do for this one */\n\t\t\tbreak; /* MSGTYPE_CONF2ACK */\n\t\t\n\t\tcase MSGTYPE_PING:\n\t\t\t{\n\t\t\t\t/* allocate a ping message structure */\n\t\t\t\tbzrtpPingMessage_t *messageData;\n\t\t\t\tmessageData = (bzrtpPingMessage_t *)malloc(sizeof(bzrtpPingMessage_t));\n\n\t\t\t\t/* fill the structure */\n\t\t\t\tmemcpy(messageData->version, messageContent, 4);\n\t\t\t\tmessageContent +=4;\n\t\t\t\tmemcpy(messageData->endpointHash, messageContent, 8);\n\n\t\t\t\t/* attach the message structure to the packet one */\n\t\t\t\tzrtpPacket->messageData = (void *)messageData;\n\t\t\t}\n\t\t\tbreak; /* MSGTYPE_PING */\n\n\t}\n\n\treturn 0;\n}\n\n/* Create the packet string from the messageData contained into the zrtp Packet structure */\nint bzrtp_packetBuild(bzrtpContext_t *zrtpContext, bzrtpChannelContext_t *zrtpChannelContext, bzrtpPacket_t *zrtpPacket, uint16_t sequenceNumber) {\n\t\n\tint i;\n\tuint8_t *messageTypeString;\n\tuint8_t *messageString = NULL; /* will point directly to the begining of the message within the packetString buffer */\n\tuint8_t *MACbuffer = NULL; /* if needed this will point to the beginin of the MAC in the packetString buffer */\n\t/*uint8_t *MACMessageData = NULL; */ /* if needed this will point to the MAC field in the message Data structure */\n\tuint8_t *MACkey = NULL;\n\n\t/* checks */\n\tif (zrtpPacket==NULL) {\n\t\treturn BZRTP_BUILDER_ERROR_INVALIDPACKET;\n\t}\n\n\t/* get the message type (and check it is valid) */\n\tmessageTypeString = messageTypeInttoString(zrtpPacket->messageType);\n\tif (messageTypeString == NULL) {\n\t\treturn BZRTP_BUILDER_ERROR_INVALIDMESSAGETYPE;\n\t}\n\n\t/* create first the message. Header and CRC will be added afterward */\n\tswitch (zrtpPacket->messageType) {\n\t\tcase MSGTYPE_HELLO : \n\t\t\t{\n\t\t\t\tbzrtpHelloMessage_t *messageData;\n\n\t\t\t\t/* get the Hello message structure */\n\t\t\t\tif (zrtpPacket->messageData == NULL) {\n\t\t\t\t\treturn BZRTP_BUILDER_ERROR_INVALIDMESSAGE;\n\t\t\t\t}\n\t\t\t\tmessageData = (bzrtpHelloMessage_t *)zrtpPacket->messageData;\n\n\t\t\t\t/* compute the message length in bytes : fixed length and optionnal algorithms parts */\n\t\t\t\tzrtpPacket->messageLength = ZRTP_HELLOMESSAGE_FIXED_LENGTH + 4*((uint16_t)(messageData->hc)+(uint16_t)(messageData->cc)+(uint16_t)(messageData->ac)+(uint16_t)(messageData->kc)+(uint16_t)(messageData->sc));\n\n\t\t\t\t/* allocate the packetString buffer : packet is header+message+crc */\n\t\t\t\tzrtpPacket->packetString = (uint8_t *)malloc((ZRTP_PACKET_HEADER_LENGTH+zrtpPacket->messageLength+ZRTP_PACKET_CRC_LENGTH)*sizeof(uint8_t));\n\t\t\t\t/* have the messageString pointer to the begining of message(after the message header wich is computed for all messages after the switch)\n\t\t\t\t * within the packetString buffer*/\n\t\t\t\tmessageString = zrtpPacket->packetString + ZRTP_PACKET_HEADER_LENGTH + ZRTP_MESSAGE_HEADER_LENGTH;\n\n\t\t\t\t/* set the version (shall be 1.10), Client identifier, H3, ZID, S,M,P flags and  hc,cc,ac,kc,sc */\n\t\t\t\tmemcpy(messageString, messageData->version, 4);\n\t\t\t\tmessageString += 4;\n\t\t\t\tmemcpy(messageString, messageData->clientIdentifier, 16);\n\t\t\t\tmessageString += 16;\n\t\t\t\tmemcpy(messageString, messageData->H3, 32);\n\t\t\t\tmessageString += 32;\n\t\t\t\tmemcpy(messageString, messageData->ZID, 12);\n\t\t\t\tmessageString += 12;\n\t\t\t\t*messageString = ((((messageData->S)&0x01)<<6) | (((messageData->M)&0x01)<<5) | (((messageData->P)&0x01)<<4))&0x70;\n\t\t\t\tmessageString += 1;\n\t\t\t\t*messageString = (messageData->hc)&0x0F;\n\t\t\t\tmessageString += 1;\n\t\t\t\t*messageString = (((messageData->cc)<<4)&0xF0) | ((messageData->ac)&0x0F) ;\n\t\t\t\tmessageString += 1;\n\t\t\t\t*messageString = (((messageData->kc)<<4)&0xF0) | ((messageData->sc)&0x0F) ;\n\t\t\t\tmessageString += 1;\n\n\t\t\t\t/* now set optionnal supported algorithms */\n\t\t\t\tfor (i=0; i<messageData->hc; i++) {\n\t\t\t\t\tcryptoAlgoTypeIntToString(messageData->supportedHash[i], messageString);\n\t\t\t\t\tmessageString +=4;\n\t\t\t\t}\n\t\t\t\tfor (i=0; i<messageData->cc; i++) {\n\t\t\t\t\tcryptoAlgoTypeIntToString(messageData->supportedCipher[i], messageString);\n\t\t\t\t\tmessageString +=4;\n\t\t\t\t}\n\t\t\t\tfor (i=0; i<messageData->ac; i++) {\n\t\t\t\t\tcryptoAlgoTypeIntToString(messageData->supportedAuthTag[i], messageString);\n\t\t\t\t\tmessageString +=4;\n\t\t\t\t}\n\t\t\t\tfor (i=0; i<messageData->kc; i++) {\n\t\t\t\t\tcryptoAlgoTypeIntToString(messageData->supportedKeyAgreement[i], messageString);\n\t\t\t\t\tmessageString +=4;\n\t\t\t\t}\n\t\t\t\tfor (i=0; i<messageData->sc; i++) {\n\t\t\t\t\tcryptoAlgoTypeIntToString(messageData->supportedSas[i], messageString);\n\t\t\t\t\tmessageString +=4;\n\t\t\t\t}\n\n\t\t\t\t/* there is a MAC to compute, set the pointers to the key and MAC output buffer */\n\t\t\t\tMACbuffer = messageString;\n\t\t\t\tMACkey = zrtpChannelContext->selfH[2]; /* HMAC of Hello packet is keyed by H2 which have been set at context initialising */\n\n\t\t\t}\n\t\t\tbreak; /* MSGTYPE_HELLO */\n\n\t\tcase MSGTYPE_HELLOACK : \n\t\t\t{\n\t\t\t\t/* the message length is fixed */\n\t\t\t\tzrtpPacket->messageLength = ZRTP_HELLOACKMESSAGE_FIXED_LENGTH;\n\n\t\t\t\t/* allocate the packetString buffer : packet is header+message+crc */\n\t\t\t\tzrtpPacket->packetString = (uint8_t *)malloc((ZRTP_PACKET_HEADER_LENGTH+ZRTP_HELLOACKMESSAGE_FIXED_LENGTH+ZRTP_PACKET_CRC_LENGTH)*sizeof(uint8_t));\n\t\t\t}\n\t\t\tbreak; /* MSGTYPE_HELLOACK */\n\n\t\tcase MSGTYPE_COMMIT :\n\t\t\t{\n\t\t\t\tbzrtpCommitMessage_t *messageData;\n\t\t\t\tuint16_t variableLength = 0;\n\n\t\t\t\t/* get the Commit message structure */\n\t\t\t\tif (zrtpPacket->messageData == NULL) {\n\t\t\t\t\treturn BZRTP_BUILDER_ERROR_INVALIDMESSAGE;\n\t\t\t\t}\n\n\t\t\t\tmessageData = (bzrtpCommitMessage_t *)zrtpPacket->messageData;\n\n\t\t\t\t/* compute message length */\n\t\t\t\tswitch(messageData->keyAgreementAlgo) {\n\t\t\t\t\tcase ZRTP_KEYAGREEMENT_DH2k :\n\t\t\t\t\tcase ZRTP_KEYAGREEMENT_EC25 :\n\t\t\t\t\tcase ZRTP_KEYAGREEMENT_DH3k :\n\t\t\t\t\tcase ZRTP_KEYAGREEMENT_EC38 :\n\t\t\t\t\tcase ZRTP_KEYAGREEMENT_EC52 :\n\t\t\t\t\t\tvariableLength = 32; /* hvi is 32 bytes length in DH Commit message format */\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase ZRTP_KEYAGREEMENT_Prsh :\n\t\t\t\t\t\tvariableLength = 24; /* nonce (16 bytes) and keyID(8 bytes) are 24 bytes length in preshared Commit message format */\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase ZRTP_KEYAGREEMENT_Mult :\n\t\t\t\t\t\tvariableLength = 16; /* nonce is 24 bytes length in multistream Commit message format */\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\treturn BZRTP_BUILDER_ERROR_INVALIDMESSAGE;\n\t\t\t\t}\n\t\t\t\tzrtpPacket->messageLength = ZRTP_COMMITMESSAGE_FIXED_LENGTH + variableLength;\n\t\t\t\t\n\t\t\t\t/* allocate the packetString buffer : packet is header+message+crc */\n\t\t\t\tzrtpPacket->packetString = (uint8_t *)malloc((ZRTP_PACKET_HEADER_LENGTH+zrtpPacket->messageLength+ZRTP_PACKET_CRC_LENGTH)*sizeof(uint8_t));\n\t\t\t\t/* have the messageString pointer to the begining of message(after the message header wich is computed for all messages after the switch)\n\t\t\t\t * within the packetString buffer*/\n\t\t\t\tmessageString = zrtpPacket->packetString + ZRTP_PACKET_HEADER_LENGTH + ZRTP_MESSAGE_HEADER_LENGTH;\n\n\t\t\t\t/* now insert the different message parts into the packetString */\n\t\t\t\tmemcpy(messageString, messageData->H2, 32);\n\t\t\t\tmessageString += 32;\n\t\t\t\tmemcpy(messageString, messageData->ZID, 12);\n\t\t\t\tmessageString += 12;\n\t\t\t\tcryptoAlgoTypeIntToString(messageData->hashAlgo, messageString);\n\t\t\t\tmessageString += 4;\n\t\t\t\tcryptoAlgoTypeIntToString(messageData->cipherAlgo, messageString);\n\t\t\t\tmessageString += 4;\n\t\t\t\tcryptoAlgoTypeIntToString(messageData->authTagAlgo, messageString);\n\t\t\t\tmessageString += 4;\n\t\t\t\tcryptoAlgoTypeIntToString(messageData->keyAgreementAlgo, messageString);\n\t\t\t\tmessageString += 4;\n\t\t\t\tcryptoAlgoTypeIntToString(messageData->sasAlgo, messageString);\n\t\t\t\tmessageString += 4;\n\n\t\t\t\t/* if it is a multistream or preshared commit insert the 16 bytes nonce */\n\t\t\t\tif ((messageData->keyAgreementAlgo == ZRTP_KEYAGREEMENT_Prsh) || (messageData->keyAgreementAlgo == ZRTP_KEYAGREEMENT_Mult)) {\n\t\t\t\t\t\tmemcpy(messageString, messageData->nonce, 16);\n\t\t\t\t\t\tmessageString += 16;\n\n\t\t\t\t\t/* and the keyID for preshared commit only */\n\t\t\t\t\tif (messageData->keyAgreementAlgo == ZRTP_KEYAGREEMENT_Prsh) {\n\t\t\t\t\t\tmemcpy(messageString, messageData->keyID, 8);\n\t\t\t\t\t\tmessageString +=8;\n\t\t\t\t\t}\n\t\t\t\t} else { /* it's a DH commit message, set the hvi */\n\t\t\t\t\tmemcpy(messageString, messageData->hvi, 32);\n\t\t\t\t\tmessageString +=32;\n\t\t\t\t}\n\t\t\t\n\t\t\t\t/* there is a MAC to compute, set the pointers to the key and MAC output buffer */\n\t\t\t\tMACbuffer = messageString;\n\t\t\t\tMACkey = zrtpChannelContext->selfH[1]; /* HMAC of Hello packet is keyed by H1 which have been set at context initialising */\n\t\t\t}\n\t\t\tbreak; /*MSGTYPE_COMMIT */\n\n\t\tcase MSGTYPE_DHPART1 :\n\t\tcase MSGTYPE_DHPART2 :\n\t\t\t{\n\t\t\t\tbzrtpDHPartMessage_t *messageData;\n\t\t\t\tuint16_t pvLength;\n\n\t\t\t\t/* get the DHPart message structure */\n\t\t\t\tif (zrtpPacket->messageData == NULL) {\n\t\t\t\t\treturn BZRTP_BUILDER_ERROR_INVALIDMESSAGE;\n\t\t\t\t}\n\n\t\t\t\tmessageData = (bzrtpDHPartMessage_t *)zrtpPacket->messageData;\n\n\t\t\t\t/* compute message length */\n\t\t\t\tpvLength = computeKeyAgreementPrivateValueLength(zrtpChannelContext->keyAgreementAlgo);\n\t\t\t\tif (pvLength==0) {\n\t\t\t\t\treturn BZRTP_BUILDER_ERROR_INVALIDCONTEXT;\n\t\t\t\t}\n\t\t\t\tzrtpPacket->messageLength = ZRTP_DHPARTMESSAGE_FIXED_LENGTH + pvLength;\n\t\t\t\t\n\t\t\t\t/* allocate the packetString buffer : packet is header+message+crc */\n\t\t\t\tzrtpPacket->packetString = (uint8_t *)malloc((ZRTP_PACKET_HEADER_LENGTH+zrtpPacket->messageLength+ZRTP_PACKET_CRC_LENGTH)*sizeof(uint8_t));\n\t\t\t\t/* have the messageString pointer to the begining of message(after the message header wich is computed for all messages after the switch)\n\t\t\t\t * within the packetString buffer*/\n\t\t\t\tmessageString = zrtpPacket->packetString + ZRTP_PACKET_HEADER_LENGTH + ZRTP_MESSAGE_HEADER_LENGTH;\n\n\t\t\t\t/* now insert the different message parts into the packetString */\n\t\t\t\tmemcpy(messageString, messageData->H1, 32);\n\t\t\t\tmessageString += 32;\n\t\t\t\tmemcpy(messageString, messageData->rs1ID, 8);\n\t\t\t\tmessageString += 8;\n\t\t\t\tmemcpy(messageString, messageData->rs2ID, 8);\n\t\t\t\tmessageString += 8;\n\t\t\t\tmemcpy(messageString, messageData->auxsecretID, 8);\n\t\t\t\tmessageString += 8;\n\t\t\t\tmemcpy(messageString, messageData->pbxsecretID, 8);\n\t\t\t\tmessageString += 8;\n\t\t\t\tmemcpy(messageString, messageData->pv, pvLength);\n\t\t\t\tmessageString += pvLength;\n\n\t\t\t\t/* there is a MAC to compute, set the pointers to the key and MAC output buffer */\n\t\t\t\tMACbuffer = messageString;\n\t\t\t\tMACkey = zrtpChannelContext->selfH[0]; /* HMAC of Hello packet is keyed by H0 which have been set at context initialising */\n\t\t\t}\n\t\t\tbreak; /* MSGTYPE_DHPART1 and 2 */\n\t\t\n\t\tcase MSGTYPE_CONFIRM1:\n\t\tcase MSGTYPE_CONFIRM2:\n\t\t\t{\n\t\t\t\tuint8_t *confirmMessageKey = NULL;\n\t\t\t\tuint8_t *confirmMessageMacKey = NULL;\n\t\t\t\tbzrtpConfirmMessage_t *messageData;\n\t\t\t\tuint16_t encryptedPartLength;\n\t\t\t\tuint8_t *plainMessageString;\n\t\t\t\tuint16_t plainMessageStringIndex = 0;\n\n\t\t\t\t/* we will have to encrypt and validate the message, check we have the keys to do it */\n\t\t\t\tif (zrtpChannelContext->role == INITIATOR) {\n\t\t\t\t\tif ((zrtpChannelContext->zrtpkeyi == NULL) || (zrtpChannelContext->mackeyi == NULL)) {\n\t\t\t\t\t\treturn BZRTP_BUILDER_ERROR_INVALIDCONTEXT;\n\t\t\t\t\t}\n\t\t\t\t\tconfirmMessageKey = zrtpChannelContext->zrtpkeyi;\n\t\t\t\t\tconfirmMessageMacKey = zrtpChannelContext->mackeyi;\n\t\t\t\t}\n\n\t\t\t\tif (zrtpChannelContext->role == RESPONDER) {\n\t\t\t\t\tif ((zrtpChannelContext->zrtpkeyr == NULL) || (zrtpChannelContext->mackeyr == NULL)) {\n\t\t\t\t\t\treturn BZRTP_BUILDER_ERROR_INVALIDCONTEXT;\n\t\t\t\t\t}\n\t\t\t\t\tconfirmMessageKey = zrtpChannelContext->zrtpkeyr;\n\t\t\t\t\tconfirmMessageMacKey = zrtpChannelContext->mackeyr;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t/* get the Confirm message structure */\n\t\t\t\tif (zrtpPacket->messageData == NULL) {\n\t\t\t\t\treturn BZRTP_BUILDER_ERROR_INVALIDMESSAGE;\n\t\t\t\t}\n\n\t\t\t\tmessageData = (bzrtpConfirmMessage_t *)zrtpPacket->messageData;\n\n\t\t\t\t/* compute message length */\n\t\t\t\tzrtpPacket->messageLength = ZRTP_CONFIRMMESSAGE_FIXED_LENGTH + messageData->sig_len*4; /* sig_len is in word of 4 bytes */\n\t\t\t\t\n\t\t\t\t/* allocate the packetString buffer : packet is header+message+crc */\n\t\t\t\tzrtpPacket->packetString = (uint8_t *)malloc((ZRTP_PACKET_HEADER_LENGTH+zrtpPacket->messageLength+ZRTP_PACKET_CRC_LENGTH)*sizeof(uint8_t));\n\t\t\t\t/* have the messageString pointer to the begining of message(after the message header wich is computed for all messages after the switch)\n\t\t\t\t * within the packetString buffer*/\n\t\t\t\tmessageString = zrtpPacket->packetString + ZRTP_PACKET_HEADER_LENGTH + ZRTP_MESSAGE_HEADER_LENGTH;\n\n\t\t\t\t/* allocate a temporary buffer to store the plain text */\n\t\t\t\tencryptedPartLength = zrtpPacket->messageLength - ZRTP_MESSAGE_HEADER_LENGTH - 24; /* message header, confirm_mac(8 bytes) and CFB IV(16 bytes) are not encrypted */\n\t\t\t\tplainMessageString = (uint8_t *)malloc(encryptedPartLength*sizeof(uint8_t)); \n\n\t\t\t\t/* fill the plain message buffer with data from the message structure */\n\t\t\t\tmemcpy(plainMessageString, messageData->H0, 32);\n\t\t\t\tplainMessageStringIndex += 32;\n\t\t\t\tplainMessageString[plainMessageStringIndex++] = 0x00;\n\t\t\t\tplainMessageString[plainMessageStringIndex++] = (uint8_t)(((messageData->sig_len)>>8)&0x0001);\n\t\t\t\tplainMessageString[plainMessageStringIndex++] = (uint8_t)((messageData->sig_len)&0x00FF);\n\t\t\t\tplainMessageString[plainMessageStringIndex++] = (uint8_t)((messageData->E&0x01)<<3) | (uint8_t)((messageData->V&0x01)<<2) | (uint8_t)((messageData->A&0x01)<<1) | (uint8_t)(messageData->D&0x01) ;\n\t\t\t\t/* cache expiration in a 32 bits unsigned int */\n\t\t\t\tplainMessageString[plainMessageStringIndex++] = (uint8_t)((messageData->cacheExpirationInterval>>24)&0xFF);\n\t\t\t\tplainMessageString[plainMessageStringIndex++] = (uint8_t)((messageData->cacheExpirationInterval>>16)&0xFF);\n\t\t\t\tplainMessageString[plainMessageStringIndex++] = (uint8_t)((messageData->cacheExpirationInterval>>8)&0xFF);\n\t\t\t\tplainMessageString[plainMessageStringIndex++] = (uint8_t)((messageData->cacheExpirationInterval)&0xFF);\n\n\t\t\t\tif (messageData->sig_len>0) {\n\t\t\t\t\tmemcpy(plainMessageString+plainMessageStringIndex, messageData->signatureBlockType, 4);\n\t\t\t\t\tplainMessageStringIndex += 4;\n\t\t\t\t\t/* sig_len is in 4 bytes words and include the 1 word of signature block type */\n\t\t\t\t\tmemcpy(plainMessageString+plainMessageStringIndex, messageData->signatureBlock, (messageData->sig_len-1)*4);\n\t\t\t\t}\n\n\t\t\t\t/* encrypt the buffer, set the output directly in the messageString buffer at the correct position(+24 after message header) */\n\t\t\t\tzrtpChannelContext->cipherEncryptionFunction(confirmMessageKey, messageData->CFBIV, plainMessageString, encryptedPartLength, messageString+24);\n\t\t\t\tfree(plainMessageString); /* free the plain message string temporary buffer */\n\n\t\t\t\t/* compute the mac over the encrypted part of the message and set the result in the messageString */\n\t\t\t\tzrtpChannelContext->hmacFunction(confirmMessageMacKey, zrtpChannelContext->hashLength, messageString+24, encryptedPartLength, 8, messageString);\n\t\t\t\tmessageString += 8;\n\t\t\t\t/* add the CFB IV */\n\t\t\t\tmemcpy(messageString, messageData->CFBIV, 16);\n\t\t\t}\n\t\t\tbreak; /* MSGTYPE_CONFIRM1 and MSGTYPE_CONFIRM2 */\n\n\t\tcase MSGTYPE_CONF2ACK:\n\t\t\t{\n\t\t\t\t/* the message length is fixed */\n\t\t\t\tzrtpPacket->messageLength = ZRTP_CONF2ACKMESSAGE_FIXED_LENGTH;\n\n\t\t\t\t/* allocate the packetString buffer : packet is header+message+crc */\n\t\t\t\tzrtpPacket->packetString = (uint8_t *)malloc((ZRTP_PACKET_HEADER_LENGTH+ZRTP_CONF2ACKMESSAGE_FIXED_LENGTH+ZRTP_PACKET_CRC_LENGTH)*sizeof(uint8_t));\n\t\t\t}\n\t\t\tbreak; /* MSGTYPE_CONF2ACK */\n\n\t\tcase MSGTYPE_PINGACK:\n\t\t\t{\n\t\t\t\tbzrtpPingAckMessage_t *messageData;\n\n\t\t\t\t/* the message length is fixed */\n\t\t\t\tzrtpPacket->messageLength = ZRTP_PINGACKMESSAGE_FIXED_LENGTH;\n\n\t\t\t\t/* allocate the packetString buffer : packet is header+message+crc */\n\t\t\t\tzrtpPacket->packetString = (uint8_t *)malloc((ZRTP_PACKET_HEADER_LENGTH+ZRTP_PINGACKMESSAGE_FIXED_LENGTH+ZRTP_PACKET_CRC_LENGTH)*sizeof(uint8_t));\n\t\t\t\tmessageString = zrtpPacket->packetString + ZRTP_PACKET_HEADER_LENGTH + ZRTP_MESSAGE_HEADER_LENGTH;\n\n\t\t\t\t/* now insert the different message parts into the packetString */\n\t\t\t\tmessageData = (bzrtpPingAckMessage_t *)zrtpPacket->messageData;\n\n\t\t\t\tmemcpy(messageString, messageData->version, 4);\n\t\t\t\tmessageString += 4;\n\t\t\t\tmemcpy(messageString, messageData->endpointHash, 8);\n\t\t\t\tmessageString += 8;\n\t\t\t\tmemcpy(messageString, messageData->endpointHashReceived, 8);\n\t\t\t\tmessageString += 8;\n\t\t\t\t*messageString++ = (uint8_t)((messageData->SSRC>>24)&0xFF);\n\t\t\t\t*messageString++ = (uint8_t)((messageData->SSRC>>16)&0xFF);\n\t\t\t\t*messageString++ = (uint8_t)((messageData->SSRC>>8)&0xFF);\n\t\t\t\t*messageString++ = (uint8_t)(messageData->SSRC&0xFF);\n\t\t\t}\n\t\t\tbreak; /* MSGTYPE_PINGACK */\n\n\t}\n\n\t/* write headers only if we have a packet string */\n\tif (zrtpPacket->packetString != NULL) {\n\t\tuint32_t CRC;\n\t\tuint8_t *CRCbuffer;\n\n\t\tzrtpMessageSetHeader(zrtpPacket->packetString+ZRTP_PACKET_HEADER_LENGTH, zrtpPacket->messageLength, messageTypeString);\n\n\t\t/* Do we have a MAC to compute on the message ? */\n\t\tif (MACbuffer != NULL) {\n\t\t\t/* compute the MAC(64 bits only) using the implicit HMAC function for ZRTP v1.10: HMAC-SHA256 */\n\t\t\t/* HMAC is computed on the whole message except the MAC itself so a length of zrtpPacket->messageLength-8 */\n\t\t\tbctoolbox_hmacSha256(MACkey, 32, zrtpPacket->packetString+ZRTP_PACKET_HEADER_LENGTH, zrtpPacket->messageLength-8, 8, MACbuffer);\n\t\t}\n\t\n\t\t/* set packet header and CRC */\n\t\t/* preambule */\n\t\tzrtpPacket->packetString[0] = 0x10;\n\t\tzrtpPacket->packetString[1] = 0x00;\n\t\t/* Sequence number */\n\t\tzrtpPacket->packetString[2] = (uint8_t)((sequenceNumber>>8)&0x00FF);\n\t\tzrtpPacket->packetString[3] = (uint8_t)(sequenceNumber&0x00FF);\n\t\t/* ZRTP magic cookie */\n\t\tzrtpPacket->packetString[4] = (uint8_t)((ZRTP_MAGIC_COOKIE>>24)&0xFF);\n\t\tzrtpPacket->packetString[5] = (uint8_t)((ZRTP_MAGIC_COOKIE>>16)&0xFF);\n\t\tzrtpPacket->packetString[6] = (uint8_t)((ZRTP_MAGIC_COOKIE>>8)&0xFF);\n\t\tzrtpPacket->packetString[7] = (uint8_t)(ZRTP_MAGIC_COOKIE&0xFF);\n\t\t/* Source Identifier */\n\t\tzrtpPacket->packetString[8] = (uint8_t)(((zrtpPacket->sourceIdentifier)>>24)&0xFF);\n\t\tzrtpPacket->packetString[9] = (uint8_t)(((zrtpPacket->sourceIdentifier)>>16)&0xFF);\n\t\tzrtpPacket->packetString[10] = (uint8_t)(((zrtpPacket->sourceIdentifier)>>8)&0xFF);\n\t\tzrtpPacket->packetString[11] = (uint8_t)((zrtpPacket->sourceIdentifier)&0xFF);\n\t\t/* CRC */\n\t\tCRC = bzrtp_CRC32(zrtpPacket->packetString, zrtpPacket->messageLength+ZRTP_PACKET_HEADER_LENGTH);\n\t\tCRCbuffer = (zrtpPacket->packetString)+(zrtpPacket->messageLength)+ZRTP_PACKET_HEADER_LENGTH;\n\t\t*CRCbuffer = (uint8_t)((CRC>>24)&0xFF);\n\t\tCRCbuffer++;\n\t\t*CRCbuffer = (uint8_t)((CRC>>16)&0xFF);\n\t\tCRCbuffer++;\n\t\t*CRCbuffer = (uint8_t)((CRC>>8)&0xFF);\n\t\tCRCbuffer++;\n\t\t*CRCbuffer = (uint8_t)(CRC&0xFF);\n\t\n\t\treturn 0;\n\t} else { /* no packetString allocated something wen't wrong but we shall never arrive here */\n\t\treturn BZRTP_BUILDER_ERROR_UNKNOWN;\n\t}\n}\n\n/* create a zrtpPacket and initialise it's structures */\nbzrtpPacket_t *bzrtp_createZrtpPacket(bzrtpContext_t *zrtpContext, bzrtpChannelContext_t *zrtpChannelContext, uint32_t messageType, int *exitCode) {\n\t/* allocate packet */\n\tbzrtpPacket_t *zrtpPacket = (bzrtpPacket_t *)malloc(sizeof(bzrtpPacket_t));\n\tmemset(zrtpPacket, 0, sizeof(bzrtpPacket_t));\n\tzrtpPacket->messageData = NULL;\n\tzrtpPacket->packetString = NULL;\n\n\t/* initialise it */\n\tswitch(messageType) {\n\t\tcase MSGTYPE_HELLO:\n\t\t\t{\n\t\t\t\tint i;\n\t\t\t\tbzrtpHelloMessage_t *zrtpHelloMessage = (bzrtpHelloMessage_t *)malloc(sizeof(bzrtpHelloMessage_t));\n\t\t\t\tmemset(zrtpHelloMessage, 0, sizeof(bzrtpHelloMessage_t));\n\t\t\t\t/* initialise some fields using zrtp context data */\n\t\t\t\tmemcpy(zrtpHelloMessage->version, ZRTP_VERSION, 4);\n\t\t\t\tstrncpy((char*)zrtpHelloMessage->clientIdentifier, ZRTP_CLIENT_IDENTIFIER, 16);\n\t\t\t\tmemcpy(zrtpHelloMessage->H3, zrtpChannelContext->selfH[3], 32);\n\t\t\t\tmemcpy(zrtpHelloMessage->ZID, zrtpContext->selfZID, 12);\n\t\t\t\t/* set all S,M,P flags to zero as we're not able to verify signatures, we're not a PBX(TODO: implement?), we're not passive */\n\t\t\t\tzrtpHelloMessage->S = 0;\n\t\t\t\tzrtpHelloMessage->M = 0;\n\t\t\t\tzrtpHelloMessage->P = 0;\n\n\t\t\t\t/* get the algorithm availabilities from the context */\n\t\t\t\tzrtpHelloMessage->hc = zrtpContext->hc;\n\t\t\t\tzrtpHelloMessage->cc = zrtpContext->cc;\n\t\t\t\tzrtpHelloMessage->ac = zrtpContext->ac;\n\t\t\t\tzrtpHelloMessage->kc = zrtpContext->kc;\n\t\t\t\tzrtpHelloMessage->sc = zrtpContext->sc;\n\n\t\t\t\tfor (i=0; i<zrtpContext->hc; i++) {\n\t\t\t\t\tzrtpHelloMessage->supportedHash[i] = zrtpContext->supportedHash[i];\n\t\t\t\t}\n\t\t\t\tfor (i=0; i<zrtpContext->cc; i++) {\n\t\t\t\t\tzrtpHelloMessage->supportedCipher[i] = zrtpContext->supportedCipher[i];\n\t\t\t\t}\n\t\t\t\tfor (i=0; i<zrtpContext->ac; i++) {\n\t\t\t\t\tzrtpHelloMessage->supportedAuthTag[i] = zrtpContext->supportedAuthTag[i];\n\t\t\t\t}\n\t\t\t\tfor (i=0; i<zrtpContext->kc; i++) {\n\t\t\t\t\tzrtpHelloMessage->supportedKeyAgreement[i] = zrtpContext->supportedKeyAgreement[i];\n\t\t\t\t}\n\t\t\t\tfor (i=0; i<zrtpContext->sc; i++) {\n\t\t\t\t\tzrtpHelloMessage->supportedSas[i] = zrtpContext->supportedSas[i];\n\t\t\t\t}\n\n\t\t\t\t/* attach the message data to the packet */\n\t\t\t\tzrtpPacket->messageData = zrtpHelloMessage;\n\t\t\t}\n\t\t\tbreak; /* MSGTYPE_HELLO */\n\n\t\tcase MSGTYPE_HELLOACK :\n\t\t\t{\n\t\t\t\t/* nothing to do for the Hello ACK packet as it just contains it's type */\n\t\t\t}\n\t\t\tbreak; /* MSGTYPE_HELLOACK */\n\t\t/* In case of DH commit, this one must be called after the DHPart build and the self DH message and peer Hello message are stored in the context */\n\t\tcase MSGTYPE_COMMIT :\n\t\t\t{\n\t\t\t\tbzrtpCommitMessage_t *zrtpCommitMessage = (bzrtpCommitMessage_t *)malloc(sizeof(bzrtpCommitMessage_t));\n\t\t\t\tmemset(zrtpCommitMessage, 0, sizeof(bzrtpCommitMessage_t));\n\t\t\t\t\n\t\t\t\t/* initialise some fields using zrtp context data */\n\t\t\t\tmemcpy(zrtpCommitMessage->H2, zrtpChannelContext->selfH[2], 32);\n\t\t\t\tmemcpy(zrtpCommitMessage->ZID, zrtpContext->selfZID, 12);\n\t\t\t\tzrtpCommitMessage->hashAlgo = zrtpChannelContext->hashAlgo;\n\t\t\t\tzrtpCommitMessage->cipherAlgo = zrtpChannelContext->cipherAlgo;\n\t\t\t\tzrtpCommitMessage->authTagAlgo = zrtpChannelContext->authTagAlgo;\n\t\t\t\tzrtpCommitMessage->keyAgreementAlgo = zrtpChannelContext->keyAgreementAlgo;\n\t\t\t\tzrtpCommitMessage->sasAlgo = zrtpChannelContext->sasAlgo;\n\n\t\t\t\t/* if it is a multistream or preshared commit create a 16 random bytes nonce */\n\t\t\t\tif ((zrtpCommitMessage->keyAgreementAlgo == ZRTP_KEYAGREEMENT_Prsh) || (zrtpCommitMessage->keyAgreementAlgo == ZRTP_KEYAGREEMENT_Mult)) {\n\t\t\t\t\tbctoolbox_rng_get(zrtpContext->RNGContext, zrtpCommitMessage->nonce, 16);\n\n\t\t\t\t\t/* and the keyID for preshared commit only */\n\t\t\t\t\tif (zrtpCommitMessage->keyAgreementAlgo == ZRTP_KEYAGREEMENT_Prsh) {\n\t\t\t\t\t\t/* TODO at this point we must first compute the preShared key - make sure at least rs1 is present */\n\t\t\t\t\t\t/* preshared_key = hash(len(rs1) || rs1 || len(auxsecret) || auxsecret ||\n                       len(pbxsecret) || pbxsecret) using the agreed hash and store it into the env */\n\t\t\t\t\t\t/* and then the keyID : MAC(preshared_key, \"Prsh\") truncated to 64 bits using the agreed MAC */\n\t\t\t\t\t}\n\t\t\t\t} else { /* it's a DH commit message, set the hvi */\n\t\t\t\t\t/* hvi = hash(initiator's DHPart2 message || responder's Hello message) using the agreed hash function truncated to 256 bits */\n\t\t\t\t\t/* create a string with the messages concatenated */\n\t\t\t\t\tuint16_t DHPartMessageLength = zrtpChannelContext->selfPackets[DHPART_MESSAGE_STORE_ID]->messageLength;\n\t\t\t\t\tuint16_t HelloMessageLength = zrtpChannelContext->peerPackets[HELLO_MESSAGE_STORE_ID]->messageLength;\n\t\t\t\t\tuint16_t DHPartHelloMessageStringLength = DHPartMessageLength + HelloMessageLength;\n\n\t\t\t\t\tuint8_t *DHPartHelloMessageString = (uint8_t *)malloc(DHPartHelloMessageStringLength*sizeof(uint8_t));\n\t\t\t\t\t\n\t\t\t\t\tmemcpy(DHPartHelloMessageString, zrtpChannelContext->selfPackets[DHPART_MESSAGE_STORE_ID]->packetString+ZRTP_PACKET_HEADER_LENGTH, DHPartMessageLength);\n\t\t\t\t\tmemcpy(DHPartHelloMessageString+DHPartMessageLength, zrtpChannelContext->peerPackets[HELLO_MESSAGE_STORE_ID]->packetString+ZRTP_PACKET_HEADER_LENGTH, HelloMessageLength);\n\n\t\t\t\t\tzrtpChannelContext->hashFunction(DHPartHelloMessageString, DHPartHelloMessageStringLength, 32, zrtpCommitMessage->hvi);\n\n\t\t\t\t\tfree(DHPartHelloMessageString);\n\t\t\t\t}\n\n\t\t\t\t/* attach the message data to the packet */\n\t\t\t\tzrtpPacket->messageData = zrtpCommitMessage;\n\t\t\t}\n\t\t\tbreak; /* MSGTYPE_COMMIT */\n\n\t\t/* this one is called after the exchange of Hello messages when the crypto algo agreement have been performed */\n\t\tcase MSGTYPE_DHPART1 :\n\t\tcase MSGTYPE_DHPART2 :\n\t\t\t{\n\t\t\t\tuint8_t secretLength; /* is in bytes */\n\t\t\t\tuint8_t bctoolbox_keyAgreementAlgo = BCTOOLBOX_DHM_UNSET;\n\t\t\t\tbzrtpDHPartMessage_t *zrtpDHPartMessage = (bzrtpDHPartMessage_t *)malloc(sizeof(bzrtpDHPartMessage_t));\n\t\t\t\tmemset(zrtpDHPartMessage, 0, sizeof(bzrtpDHPartMessage_t));\n\t\t\t\t/* initialise some fields using zrtp context data */\n\t\t\t\tmemcpy(zrtpDHPartMessage->H1, zrtpChannelContext->selfH[1], 32);\n\t\t\t\t/* get the retained secret from context, we anyway create a DHPart2 packet that we may turn into a DHPart1 packet if we end to \n\t\t\t\t * be the responder and not the initiator, use the initiator retained secret hashes */\n\t\t\t\tmemcpy(zrtpDHPartMessage->rs1ID, zrtpContext->initiatorCachedSecretHash.rs1ID, 8);\n\t\t\t\tmemcpy(zrtpDHPartMessage->rs2ID, zrtpContext->initiatorCachedSecretHash.rs2ID, 8);\n\t\t\t\tmemcpy(zrtpDHPartMessage->auxsecretID, zrtpChannelContext->initiatorAuxsecretID, 8);\n\t\t\t\tmemcpy(zrtpDHPartMessage->pbxsecretID, zrtpContext->initiatorCachedSecretHash.pbxsecretID, 8);\n\t\t\t\t\n\t\t\t\t/* compute the public value and insert it in the message, will then be used whatever role - initiator or responder - we assume */\n\t\t\t\t/* initialise the dhm context, secret length shall be twice the size of cipher block key length - rfc section 5.1.5 */\n\t\t\t\tswitch (zrtpChannelContext->cipherAlgo) {\n\t\t\t\t\tcase ZRTP_CIPHER_AES3:\n\t\t\t\t\tcase ZRTP_CIPHER_2FS3:\n\t\t\t\t\t\tsecretLength = 64;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase ZRTP_CIPHER_AES2:\n\t\t\t\t\tcase ZRTP_CIPHER_2FS2:\n\t\t\t\t\t\tsecretLength = 48;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase ZRTP_CIPHER_AES1:\n\t\t\t\t\tcase ZRTP_CIPHER_2FS1:\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tsecretLength = 32;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tswitch (zrtpChannelContext->keyAgreementAlgo) {\n\t\t\t\t\tcase ZRTP_KEYAGREEMENT_DH2k:\n\t\t\t\t\t\tbctoolbox_keyAgreementAlgo = BCTOOLBOX_DHM_2048;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase ZRTP_KEYAGREEMENT_DH3k:\n\t\t\t\t\t\tbctoolbox_keyAgreementAlgo = BCTOOLBOX_DHM_3072;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tfree(zrtpPacket);\n\t\t\t\t\t\tfree(zrtpDHPartMessage);\n\t\t\t\t\t\t*exitCode = BZRTP_CREATE_ERROR_UNABLETOCREATECRYPTOCONTEXT;\n\t\t\t\t\t\treturn NULL;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tzrtpContext->DHMContext = bctoolbox_CreateDHMContext(bctoolbox_keyAgreementAlgo, secretLength);\n\t\t\t\tif (zrtpContext->DHMContext == NULL) {\n\t\t\t\t\tfree(zrtpPacket);\n\t\t\t\t\tfree(zrtpDHPartMessage);\n\t\t\t\t\t*exitCode = BZRTP_CREATE_ERROR_UNABLETOCREATECRYPTOCONTEXT;\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\n\t\t\t\t/* now compute the public value */\n\t\t\t\tbctoolbox_DHMCreatePublic(zrtpContext->DHMContext, (int (*)(void *, uint8_t *, size_t))bctoolbox_rng_get, zrtpContext->RNGContext);\n\t\t\t\tzrtpDHPartMessage->pv = (uint8_t *)malloc((zrtpChannelContext->keyAgreementLength)*sizeof(uint8_t));\n\t\t\t\tmemcpy(zrtpDHPartMessage->pv, zrtpContext->DHMContext->self, zrtpChannelContext->keyAgreementLength);\n\n\t\t\t\t/* attach the message data to the packet */\n\t\t\t\tzrtpPacket->messageData = zrtpDHPartMessage;\n\t\t\t}\n\t\t\tbreak; /* MSGTYPE_DHPART1 and MSGTYPE_DHPART2 */\n\n\t\tcase MSGTYPE_CONFIRM1:\n\t\tcase MSGTYPE_CONFIRM2:\n\t\t\t{\n\t\t\t\tbzrtpConfirmMessage_t *zrtpConfirmMessage = (bzrtpConfirmMessage_t *)malloc(sizeof(bzrtpConfirmMessage_t));\n\t\t\t\tmemset(zrtpConfirmMessage, 0, sizeof(bzrtpConfirmMessage_t));\n\t\t\t\t/* initialise some fields using zrtp context data */\n\t\t\t\tmemcpy(zrtpConfirmMessage->H0, zrtpChannelContext->selfH[0], 32);\n\t\t\t\tzrtpConfirmMessage->sig_len = 0; /* signature is not supported */\n\t\t\t\tzrtpConfirmMessage->cacheExpirationInterval = 0xFFFFFFFF; /* expiration interval is set to unlimited as recommended in rfc section 4.9 */\n\t\t\t\tzrtpConfirmMessage->E = 0; /* we are not a PBX and then will never signal an enrollment - rfc section 7.3.1 */\n\t\t\t\tzrtpConfirmMessage->V = zrtpContext->cachedSecret.previouslyVerifiedSas;\n\t\t\t\tzrtpConfirmMessage->A = 0; /* Go clear message is not supported - rfc section 4.7.2 */\n\t\t\t\tzrtpConfirmMessage->D = 0; /* The is no backdoor in our implementation of ZRTP - rfc section 11 */\n\n\t\t\t\t/* generate a random CFB IV */\n\t\t\t\tbctoolbox_rng_get(zrtpContext->RNGContext, zrtpConfirmMessage->CFBIV, 16);\n\n\t\t\t\t/* attach the message data to the packet */\n\t\t\t\tzrtpPacket->messageData = zrtpConfirmMessage;\n\t\t\t}\n\t\t\tbreak; /* MSGTYPE_CONFIRM1 and MSGTYPE_CONFIRM2 */\n\n\t\tcase MSGTYPE_CONF2ACK :\n\t\t\t{\n\t\t\t\t/* nothing to do for the conf2ACK packet as it just contains it's type */\n\t\t\t}\n\t\t\tbreak; /* MSGTYPE_CONF2ACK */\n\t\tcase MSGTYPE_PINGACK:\n\t\t\t{\n\t\t\t\tbzrtpPingMessage_t *pingMessage;\n\t\t\t\tbzrtpPingAckMessage_t *zrtpPingAckMessage;\n\n\t\t\t\t/* to create a pingACK we must have a ping packet in the channel context, check it */\n\t\t\t\tbzrtpPacket_t *pingPacket = zrtpChannelContext->pingPacket;\n\t\t\t\tif (pingPacket == NULL) {\n\t\t\t\t\t*exitCode = BZRTP_CREATE_ERROR_INVALIDCONTEXT;\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t\tpingMessage = (bzrtpPingMessage_t *)pingPacket->messageData;\n\n\t\t\t\t/* create the message */\n\t\t\t\tzrtpPingAckMessage = (bzrtpPingAckMessage_t *)malloc(sizeof(bzrtpPingAckMessage_t));\n\t\t\t\tmemset(zrtpPingAckMessage, 0, sizeof(bzrtpPingAckMessage_t));\n\n\t\t\t\t/* initialise all fields using zrtp context data and the received ping message */\n\t\t\t\tmemcpy(zrtpPingAckMessage->version,ZRTP_VERSION , 4); /* we support version 1.10 only, so no need to even check what was sent in the ping */\n\t\t\t\tmemcpy(zrtpPingAckMessage->endpointHash, zrtpContext->selfZID, 8); /* as suggested in rfc section 5.16, use the truncated ZID as endPoint hash */\n\t\t\t\tmemcpy(zrtpPingAckMessage->endpointHashReceived, pingMessage->endpointHash, 8);\n\t\t\t\tzrtpPingAckMessage->SSRC = pingPacket->sourceIdentifier;\n\n\t\t\t\t/* attach the message data to the packet */\n\t\t\t\tzrtpPacket->messageData = zrtpPingAckMessage;\n\t\t\t} /* MSGTYPE_PINGACK */\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tfree(zrtpPacket);\n\t\t\t*exitCode = BZRTP_CREATE_ERROR_INVALIDMESSAGETYPE;\n\t\t\treturn NULL;\n\t\t\tbreak;\n\t}\n\n\tzrtpPacket->sequenceNumber = 0; /* this field is not used buy the packet creator, sequence number is given as a parameter when converting\n\tthe message to a packet string(packet build). Used only when parsing a string into a packet struct */\n\tzrtpPacket->messageType = messageType;\n\tzrtpPacket->sourceIdentifier = zrtpChannelContext->selfSSRC;\n\tzrtpPacket->messageLength = 0; /* length will be computed at packet build */\n\tzrtpPacket->packetString = NULL;\n\n\t*exitCode=0;\n\treturn zrtpPacket;\n}\n\nvoid bzrtp_freeZrtpPacket(bzrtpPacket_t *zrtpPacket) {\n\tif (zrtpPacket != NULL) {\n\t\t/* some messages have fields to be freed */\n\t\tif (zrtpPacket->messageData != NULL) {\n\t\t\tswitch(zrtpPacket->messageType) {\n\t\t\t\tcase MSGTYPE_DHPART1 :\n\t\t\t\tcase MSGTYPE_DHPART2 :\n\t\t\t\t\t{\n\t\t\t\t\t\tbzrtpDHPartMessage_t *typedMessageData = (bzrtpDHPartMessage_t *)(zrtpPacket->messageData);\n\t\t\t\t\t\tif (typedMessageData != NULL) {\n\t\t\t\t\t\t\tfree(typedMessageData->pv);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase MSGTYPE_CONFIRM1:\n\t\t\t\tcase MSGTYPE_CONFIRM2:\n\t\t\t\t\t{\n\t\t\t\t\t\tbzrtpConfirmMessage_t *typedMessageData = (bzrtpConfirmMessage_t *)(zrtpPacket->messageData);\n\t\t\t\t\t\tif (typedMessageData != NULL) {\n\t\t\t\t\t\t\tfree(typedMessageData->signatureBlock);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfree(zrtpPacket->messageData);\n\t\tfree(zrtpPacket->packetString);\n\t\tfree(zrtpPacket);\n\t}\n}\n\n/**\n * @brief Modify the current sequence number of the packet in the packetString and sequenceNumber fields\n * The CRC at the end of packetString is also updated\n * \n * param[in/out]\tzrtpPacket\t\tThe zrtpPacket to modify, the packetString must have been generated by\n * \t\t\t\t\t\t\t\t\ta call to bzrtp_packetBuild on this packet\n * param[in]\t\tsequenceNumber\tThe new sequence number to insert in the packetString\n * \n * return\t\t0 on succes, error code otherwise\n */\nint bzrtp_packetUpdateSequenceNumber(bzrtpPacket_t *zrtpPacket, uint16_t sequenceNumber) {\n\tuint32_t CRC;\n\tuint8_t *CRCbuffer;\n\n\tif (zrtpPacket == NULL) {\n\t\treturn BZRTP_BUILDER_ERROR_INVALIDPACKET;\n\t}\n\n\tif (zrtpPacket->packetString == NULL) {\n\t\treturn BZRTP_BUILDER_ERROR_INVALIDPACKET;\n\t}\n\t/* update the sequence number field (even if it is probably useless as this function is called just before sending the DHPart2 packet only)*/\n\tzrtpPacket->sequenceNumber = sequenceNumber;\n\n\t/* update hte sequence number in the packetString */\n\t*(zrtpPacket->packetString+2)= (uint8_t)((sequenceNumber>>8)&0x00FF);\n\t*(zrtpPacket->packetString+3)= (uint8_t)(sequenceNumber&0x00FF);\n\n\n\t/* update the CRC */\n\tCRC = bzrtp_CRC32(zrtpPacket->packetString, zrtpPacket->messageLength+ZRTP_PACKET_HEADER_LENGTH);\n\tCRCbuffer = (zrtpPacket->packetString)+(zrtpPacket->messageLength)+ZRTP_PACKET_HEADER_LENGTH;\n\t*CRCbuffer = (uint8_t)((CRC>>24)&0xFF);\n\tCRCbuffer++;\n\t*CRCbuffer = (uint8_t)((CRC>>16)&0xFF);\n\tCRCbuffer++;\n\t*CRCbuffer = (uint8_t)((CRC>>8)&0xFF);\n\tCRCbuffer++;\n\t*CRCbuffer = (uint8_t)(CRC&0xFF);\n\n\treturn 0;\n}\n\n\n/*** Local functions implementation ***/\n\nuint8_t *messageTypeInttoString(uint32_t messageType) {\n\n\tswitch(messageType) {\n\t\tcase MSGTYPE_HELLO : \n\t\t\treturn (uint8_t *)\"Hello   \";\n\t\t\tbreak;\n\t\tcase MSGTYPE_HELLOACK : \n\t\t\treturn (uint8_t *)\"HelloACK\";\n\t\t\tbreak;\n\t\tcase MSGTYPE_COMMIT : \n\t\t\treturn (uint8_t *)\"Commit  \";\n\t\t\tbreak;\n\t\tcase MSGTYPE_DHPART1 : \n\t\t\treturn (uint8_t *)\"DHPart1 \";\n\t\t\tbreak;\n\t\tcase MSGTYPE_DHPART2 : \n\t\t\treturn (uint8_t *)\"DHPart2 \";\n\t\t\tbreak;\n\t\tcase MSGTYPE_CONFIRM1 : \n\t\t\treturn (uint8_t *)\"Confirm1\";\n\t\t\tbreak;\n\t\tcase MSGTYPE_CONFIRM2 : \n\t\t\treturn (uint8_t *)\"Confirm2\";\n\t\t\tbreak;\n\t\tcase MSGTYPE_CONF2ACK : \n\t\t\treturn (uint8_t *)\"Conf2ACK\";\n\t\t\tbreak;\n\t\tcase MSGTYPE_ERROR : \n\t\t\treturn (uint8_t *)\"Error   \";\n\t\t\tbreak;\n\t\tcase MSGTYPE_ERRORACK : \n\t\t\treturn (uint8_t *)\"ErrorACK\";\n\t\t\tbreak;\n\t\tcase MSGTYPE_GOCLEAR : \n\t\t\treturn (uint8_t *)\"GoClear \";\n\t\t\tbreak;\n\t\tcase MSGTYPE_CLEARACK : \n\t\t\treturn (uint8_t *)\"ClearACK\";\n\t\t\tbreak;\n\t\tcase MSGTYPE_SASRELAY : \n\t\t\treturn (uint8_t *)\"SASrelay\";\n\t\t\tbreak;\n\t\tcase MSGTYPE_RELAYACK : \n\t\t\treturn (uint8_t *)\"RelayACK\";\n\t\t\tbreak;\n\t\tcase MSGTYPE_PING : \n\t\t\treturn (uint8_t *)\"Ping    \";\n\t\t\tbreak;\n\t\tcase MSGTYPE_PINGACK : \n\t\t\treturn (uint8_t *)\"PingACK \";\n\t\t\tbreak;\n\t}\n\treturn NULL;\n}\n\n/*\n * @brief Map the 8 char string value message type to an int32_t\n *\n * @param[in] messageTypeString\t\tan 8 bytes string matching a zrtp message type\n *\n * @return\ta 32-bits unsigned integer mapping the message type\n */\nint32_t messageTypeStringtoInt(uint8_t messageTypeString[8]) {\n\tif (memcmp(messageTypeString, \"Hello   \", 8) == 0) {\n\t\treturn MSGTYPE_HELLO;\n\t} else if (memcmp(messageTypeString, \"HelloACK\", 8) == 0) {\n\t\treturn MSGTYPE_HELLOACK;\n\t} else if (memcmp(messageTypeString, \"Commit  \", 8) == 0) {\n\t\treturn MSGTYPE_COMMIT;\n\t} else if (memcmp(messageTypeString, \"DHPart1 \", 8) == 0) {\n\t\treturn MSGTYPE_DHPART1;\n\t} else if (memcmp(messageTypeString, \"DHPart2 \", 8) == 0) {\n\t\treturn MSGTYPE_DHPART2;\n\t} else if (memcmp(messageTypeString, \"Confirm1\", 8) == 0) {\n\t\treturn MSGTYPE_CONFIRM1;\n\t} else if (memcmp(messageTypeString, \"Confirm2\", 8) == 0) {\n\t\treturn MSGTYPE_CONFIRM2;\n\t} else if (memcmp(messageTypeString, \"Conf2ACK\", 8) == 0) {\n\t\treturn MSGTYPE_CONF2ACK;\n\t} else if (memcmp(messageTypeString, \"Error   \", 8) == 0) {\n\t\treturn MSGTYPE_ERROR;\n\t} else if (memcmp(messageTypeString, \"ErrorACK\", 8) == 0) {\n\t\treturn MSGTYPE_ERRORACK;\n\t} else if (memcmp(messageTypeString, \"GoClear \", 8) == 0) {\n\t\treturn MSGTYPE_GOCLEAR;\n\t} else if (memcmp(messageTypeString, \"ClearACK\", 8) == 0) {\n\t\treturn MSGTYPE_CLEARACK;\n\t} else if (memcmp(messageTypeString, \"SASrelay\", 8) == 0) {\n\t\treturn MSGTYPE_SASRELAY;\n\t} else if (memcmp(messageTypeString, \"RelayACK\", 8) == 0) {\n\t\treturn MSGTYPE_RELAYACK;\n\t} else if (memcmp(messageTypeString, \"Ping    \", 8) == 0) {\n\t\treturn MSGTYPE_PING;\n\t} else if (memcmp(messageTypeString, \"PingACK \", 8) == 0) {\n\t\treturn MSGTYPE_PINGACK;\n\t} else {\n\t\treturn MSGTYPE_INVALID;\n\t}\n}\n\n/*\n * @brief Write the message header(preambule, length, message type) into the given output buffer\n *\n * @param[out]\toutputBuffer\t\tMessage starts at the begining of this buffer\n * @param[in]\tmessageLength\t\tMessage length in bytes! To be converted into 32bits words before being inserted in the message header\n * @param[in]\tmessageType\t\t\tAn 8 chars string for the message type (validity is not checked by this function)\n *\n */\nvoid zrtpMessageSetHeader(uint8_t *outputBuffer, uint16_t messageLength, uint8_t messageType[8]) {\n\t/* insert the preambule */\n\toutputBuffer[0] = 0x50;\n\toutputBuffer[1] = 0x5a;\n\n\t/* then the length in 32 bits words (param is in bytes, so >> 2) */\n\toutputBuffer[2] = (uint8_t)((messageLength>>10)&0x00FF);\n\toutputBuffer[3] = (uint8_t)((messageLength>>2)&0x00FF);\n\n\t/* the message type */\n\tmemcpy(outputBuffer+4, messageType, 8);\n}\n\n/*\n * Return the variable private value length in bytes according to given key agreement algorythm\n *\n * @param[in]\tkeyAgreementAlgo\tThe key agreement algo mapped to an integer as defined in cryptoWrapper.h\n *\n * @return\t\tthe private value length in bytes\n *\n */\nuint16_t computeKeyAgreementPrivateValueLength(uint8_t keyAgreementAlgo) {\n\n\tuint16_t pvLength = 0;\n\tswitch (keyAgreementAlgo) {\n\t\tcase ZRTP_KEYAGREEMENT_DH3k\t:\n\t\t\tpvLength = 384;\n\t\t\tbreak;\n\t\tcase ZRTP_KEYAGREEMENT_DH2k :\n\t\t\tpvLength = 256;\n\t\t\tbreak;\n\t\tcase ZRTP_KEYAGREEMENT_EC25\t:\n\t\t\tpvLength = 64;\n\t\t\tbreak;\n\t\tcase ZRTP_KEYAGREEMENT_EC38\t:\n\t\t\tpvLength = 96;\n\t\t\tbreak;\n\t\tcase ZRTP_KEYAGREEMENT_EC52 :\n\t\t\tpvLength = 132;\n\t\t\tbreak;\n\t\tdefault :\n\t\t\tpvLength = 0;\n\t\t\tbreak;\n\t}\n\n\treturn pvLength;\n}\n", "/**\n @file bzrtpParserTests.c\n @brief Test parsing and building ZRTP packet.\n\n @author Johan Pascal\n\n @copyright Copyright (C) 2014 Belledonne Communications, Grenoble, France\n\n This program is free software; you can redistribute it and/or\n modify it under the terms of the GNU General Public License\n as published by the Free Software Foundation; either version 2\n of the License, or (at your option) any later version.\n\n This program is distributed in the hope that it will be useful,\n but WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n GNU General Public License for more details.\n\n You should have received a copy of the GNU General Public License\n along with this program; if not, write to the Free Software\n Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <errno.h>\n#include \"CUnit/Basic.h\"\n\n#ifndef _WIN32\n#include <time.h>\n#else\n#include <windows.h>\n#endif\n\n#include \"bzrtp/bzrtp.h\"\n#include \"typedef.h\"\n#include \"packetParser.h\"\n#include \"cryptoUtils.h\"\n#include \"zidCache.h\"\n#include \"testUtils.h\"\n\n\n/**\n * Test pattern : the packet data in the patternZRTPPackets, length, sequence number and SSRC in patternZRTPMetaData\n * Pattern generated from wireshark trace\n *\n */\n#define TEST_PACKET_NUMBER 9\n/* meta data: length, sequence number, SSRC */\nstatic uint32_t patternZRTPMetaData[TEST_PACKET_NUMBER][3] = {\n\t{136, 0x09f1, 0x12345678}, /* hello */\n\t{136, 0x02ce, 0x87654321}, /* hello */\n\t{28, 0x09f2, 0x12345678}, /* hello ack */\n\t{132, 0x02d0, 0x87654321}, /* commit */\n\t{484, 0x09f5, 0x12345678}, /* dhpart1 */\n\t{484, 0x02d1, 0x87654321}, /* dhpart2 */\n\t{92, 0x09f6, 0x12345678}, /* confirm 1 */\n\t{92, 0x02d2, 0x87654321}, /* confirm 2 */\n\t{28, 0x09f7, 0x12345678} /* conf2ACK*/\n};\n\nstatic const uint8_t patternZRTPPackets[TEST_PACKET_NUMBER][512] = {\n\t/* This is a Hello packet, sequence number is 0x09f1, SSRC 0x12345678 */\n\t{0x10, 0x00, 0x09, 0xf1, 0x5a, 0x52, 0x54, 0x50, 0x12, 0x34, 0x56, 0x78, 0x50, 0x5a, 0x00, 0x1e, 0x48, 0x65, 0x6c, 0x6c, 0x6f, 0x20, 0x20, 0x20, 0x31, 0x2e, 0x31, 0x30, 0x4c, 0x49, 0x4e, 0x50, 0x48, 0x4f, 0x4e, 0x45, 0x2d, 0x5a, 0x52, 0x54, 0x50, 0x43, 0x50, 0x50, 0xe8, 0xd5, 0x26, 0xc1, 0x3a, 0x0c, 0x4c, 0x6a, 0xce, 0x18, 0xaa, 0xc7, 0xc4, 0xa4, 0x07, 0x0e, 0x65, 0x7a, 0x4d, 0xca, 0x78, 0xf2, 0xcc, 0xcd, 0x20, 0x50, 0x38, 0x73, 0xe9, 0x7e, 0x08, 0x29, 0x7e, 0xb0, 0x04, 0x97, 0xc0, 0xfe, 0xb2, 0xc9, 0x24, 0x31, 0x49, 0x7f, 0x00, 0x01, 0x12, 0x31, 0x53, 0x32, 0x35, 0x36, 0x41, 0x45, 0x53, 0x31, 0x48, 0x53, 0x33, 0x32, 0x48, 0x53, 0x38, 0x30, 0x44, 0x48, 0x33, 0x6b, 0x44, 0x48, 0x32, 0x6b, 0x4d, 0x75, 0x6c, 0x74, 0x42, 0x33, 0x32, 0x20, 0xa0, 0xfd, 0x0f, 0xad, 0xeb, 0xe0, 0x86, 0x56, 0xe3, 0x65, 0x81, 0x02},\n\t/* This is a Hello packet, sequence number is 0x02ce, SSRC 0x87654321 */\n\t{0x10, 0x00, 0x02, 0xce, 0x5a, 0x52, 0x54, 0x50, 0x87, 0x65, 0x43, 0x21, 0x50, 0x5a, 0x00, 0x1e, 0x48, 0x65, 0x6c, 0x6c, 0x6f, 0x20, 0x20, 0x20, 0x31, 0x2e, 0x31, 0x30, 0x4c, 0x49, 0x4e, 0x50, 0x48, 0x4f, 0x4e, 0x45, 0x2d, 0x5a, 0x52, 0x54, 0x50, 0x43, 0x50, 0x50, 0x8d, 0x0f, 0x5a, 0x20, 0x79, 0x97, 0x42, 0x01, 0x99, 0x45, 0x45, 0xf7, 0x0e, 0x31, 0x06, 0xe1, 0x05, 0xc0, 0xb9, 0x24, 0xe9, 0xc9, 0x78, 0xc7, 0x38, 0xf5, 0x97, 0x48, 0xef, 0x42, 0x6a, 0x3e, 0x92, 0x42, 0xc2, 0xcf, 0x44, 0xee, 0x9c, 0x65, 0xca, 0x58, 0x78, 0xf1, 0x00, 0x01, 0x12, 0x31, 0x53, 0x32, 0x35, 0x36, 0x41, 0x45, 0x53, 0x31, 0x48, 0x53, 0x33, 0x32, 0x48, 0x53, 0x38, 0x30, 0x44, 0x48, 0x33, 0x6b, 0x44, 0x48, 0x32, 0x6b, 0x4d, 0x75, 0x6c, 0x74, 0x42, 0x33, 0x32, 0x20, 0xb3, 0x90, 0x91, 0x95, 0xe4, 0x67, 0xa3, 0x21, 0xe3, 0x5f, 0x9c, 0x92},\n\t/* This is a Hello ack packet, sequence number is 0x09f2, SSRC 0x12345678*/\n\t{0x10, 0x00, 0x09, 0xf2, 0x5a, 0x52, 0x54, 0x50, 0x12, 0x34, 0x56, 0x78, 0x50, 0x5a, 0x00, 0x03, 0x48, 0x65, 0x6c, 0x6c, 0x6f, 0x41, 0x43, 0x4b, 0x77, 0x0e, 0x44, 0x07},\n\t/* This is a Commit packet, sequence number is 0x02d0, SSRC 0x87654321 */\n\t{0x10, 0x00, 0x02, 0xd0, 0x5a, 0x52, 0x54, 0x50, 0x87, 0x65, 0x43, 0x21, 0x50, 0x5a, 0x00, 0x1d, 0x43, 0x6f, 0x6d, 0x6d, 0x69, 0x74, 0x20, 0x20, 0xd9, 0xff, 0x14, 0x8b, 0x34, 0xaa, 0x69, 0xe9, 0x33, 0xc1, 0x62, 0xe6, 0x6b, 0xe8, 0xcd, 0x9d, 0xe3, 0x0f, 0xb7, 0x6a, 0xe8, 0x6a, 0x62, 0x2b, 0xcb, 0xe4, 0x6b, 0x91, 0x05, 0xc7, 0xc8, 0x7e, 0x92, 0x42, 0xc2, 0xcf, 0x44, 0xee, 0x9c, 0x65, 0xca, 0x58, 0x78, 0xf1, 0x53, 0x32, 0x35, 0x36, 0x41, 0x45, 0x53, 0x31, 0x48, 0x53, 0x33, 0x32, 0x44, 0x48, 0x33, 0x6b, 0x42, 0x33, 0x32, 0x20, 0x1e, 0xc0, 0xfe, 0x2e, 0x72, 0x06, 0x4d, 0xfb, 0xfc, 0x92, 0x02, 0x8c, 0x03, 0x0f, 0xb8, 0xf8, 0x91, 0xb4, 0xe7, 0x96, 0xac, 0x25, 0xfd, 0xf9, 0x68, 0xc6, 0xe9, 0x67, 0xa9, 0x42, 0xb1, 0x5b, 0xbb, 0x6d, 0x9c, 0xd2, 0x4b, 0x13, 0xa9, 0xae, 0x25, 0x5c, 0xa9, 0xc1},\n\t/* This is a DHPart1 packet, sequence number is 0x09f5, SSRC 0x12345678 */\n\t{0x10, 0x00, 0x09, 0xf5, 0x5a, 0x52, 0x54, 0x50, 0x12, 0x34, 0x56, 0x78, 0x50, 0x5a, 0x00, 0x75, 0x44, 0x48, 0x50, 0x61, 0x72, 0x74, 0x31, 0x20, 0x28, 0x7c, 0x28, 0xe4, 0xd7, 0x3d, 0x14, 0x39, 0xb5, 0x6d, 0x1c, 0x47, 0x9d, 0x59, 0x0a, 0xf2, 0x10, 0x33, 0xde, 0x6b, 0xd5, 0x2b, 0xfb, 0x26, 0xa5, 0x87, 0x4d, 0xe9, 0x20, 0x6b, 0x9f, 0xdd, 0xab, 0xbc, 0xc6, 0x8d, 0xbd, 0x5d, 0xe6, 0x67, 0x00, 0x69, 0x44, 0xb1, 0x84, 0x2c, 0x27, 0x10, 0x8c, 0x4e, 0x58, 0x8a, 0xed, 0x7e, 0x8b, 0x44, 0x2c, 0x3a, 0x13, 0x02, 0xdf, 0x58, 0xb6, 0xda, 0x80, 0x55, 0xec, 0xb0, 0x20, 0xc7, 0x76, 0x50, 0xc4, 0x1b, 0xa8, 0x26, 0x11, 0x5c, 0xf5, 0x71, 0x7e, 0xb4, 0x86, 0x22, 0x17, 0xde, 0x14, 0x08, 0x46, 0x5c, 0xac, 0x88, 0x8c, 0x41, 0x6b, 0x95, 0x22, 0xba, 0xf8, 0x3e, 0x67, 0x20, 0x94, 0xa0, 0x84, 0xa3, 0x93, 0x41, 0x9a, 0x1a, 0x7c, 0x2f, 0x04, 0xf4, 0x14, 0x3f, 0x11, 0x54, 0x02, 0xba, 0xee, 0xc2, 0x20, 0xfa, 0x38, 0xf7, 0xba, 0xa4, 0xbf, 0x4a, 0x70, 0x02, 0x68, 0xdc, 0xb2, 0xe9, 0x1a, 0x8a, 0x87, 0xa5, 0xe4, 0x9c, 0x42, 0x07, 0x82, 0x26, 0xb4, 0xda, 0xe3, 0x1b, 0xdc, 0x78, 0xc7, 0xd8, 0xa8, 0x00, 0x5c, 0x00, 0x14, 0xe4, 0x00, 0xfe, 0x6c, 0x2d, 0xce, 0x62, 0xc9, 0x71, 0x5d, 0xed, 0x4e, 0x66, 0x9f, 0xf5, 0x30, 0xc0, 0x04, 0x53, 0xf6, 0x15, 0x2f, 0xe1, 0x85, 0x3b, 0xd9, 0x40, 0x9b, 0x50, 0x07, 0x43, 0x7c, 0x36, 0x01, 0xa1, 0xda, 0x66, 0xc4, 0x20, 0x2f, 0x45, 0xc0, 0xcc, 0xb2, 0x64, 0x63, 0x9c, 0x07, 0x9d, 0x23, 0x27, 0x80, 0xa1, 0x7f, 0xc2, 0xe0, 0xa0, 0xfd, 0xc3, 0x98, 0x83, 0xa3, 0xaa, 0x6b, 0xdc, 0x9f, 0x6a, 0xc3, 0x32, 0x94, 0xf0, 0x80, 0xa0, 0xd9, 0xf1, 0x83, 0x41, 0x48, 0xa9, 0xb5, 0xed, 0x62, 0x50, 0x88, 0xec, 0x33, 0x32, 0xd2, 0x5f, 0xdc, 0xcc, 0xae, 0xc9, 0x74, 0xca, 0x0a, 0xab, 0x82, 0x06, 0x01, 0x46, 0x35, 0x30, 0xcd, 0x68, 0xec, 0x09, 0xab, 0x8c, 0xb0, 0x39, 0xe5, 0xd8, 0x5c, 0xa2, 0xe4, 0x82, 0xfe, 0x46, 0x01, 0xbd, 0xe7, 0x7f, 0x60, 0x1b, 0x50, 0x62, 0xfb, 0x6f, 0xee, 0x6c, 0xf1, 0xf7, 0x9b, 0xb7, 0x1c, 0x76, 0x48, 0xb5, 0xbe, 0xa5, 0x83, 0x73, 0x07, 0xa2, 0xe2, 0x73, 0xc7, 0x68, 0x34, 0xc8, 0xef, 0x12, 0xc4, 0x32, 0xdf, 0x37, 0x3d, 0xdc, 0x07, 0x0e, 0xa6, 0x92, 0x82, 0xbd, 0xba, 0x20, 0xc4, 0xb4, 0x8d, 0x1f, 0x19, 0x1c, 0x15, 0x0f, 0x5f, 0x01, 0xdf, 0x67, 0x1f, 0x59, 0xd1, 0x5e, 0x99, 0x60, 0xf6, 0xb8, 0x67, 0xe2, 0x46, 0x62, 0x11, 0x30, 0xfb, 0x81, 0x9d, 0x0b, 0xec, 0x36, 0xe9, 0x8d, 0x43, 0xfe, 0x55, 0xd9, 0x61, 0x98, 0x3f, 0x2e, 0x39, 0x6a, 0x26, 0x43, 0xb0, 0x6d, 0x08, 0xec, 0x2e, 0x42, 0x7e, 0x23, 0x82, 0x6f, 0xd9, 0xbb, 0xfd, 0x0a, 0xcd, 0x48, 0xe7, 0xd5, 0x8b, 0xa5, 0x80, 0x34, 0xca, 0x96, 0x4f, 0x58, 0x25, 0xba, 0x43, 0x5e, 0x3d, 0x1c, 0xee, 0x72, 0xb8, 0x35, 0x8c, 0x5d, 0xd9, 0x69, 0x24, 0x58, 0x36, 0x21, 0xb0, 0x45, 0xa4, 0xad, 0x40, 0xda, 0x94, 0x98, 0x0f, 0xb1, 0xed, 0x6c, 0xad, 0x26, 0x03, 0x04, 0x82, 0xff, 0x15, 0x00, 0x41, 0x87, 0x06, 0x93, 0xd4, 0x86, 0xa9, 0x7e, 0xb8, 0xd9, 0x70, 0x34, 0x6d, 0x8e, 0x6a, 0x16, 0xe2, 0x46, 0x52, 0xb0, 0x78, 0x54, 0x53, 0xaf},\n\t/* This is a DHPart2 packet, sequence number is 0x02d1, SSRC 0x87654321 */\n\t{0x10, 0x00, 0x02, 0xd1, 0x5a, 0x52, 0x54, 0x50, 0x87, 0x65, 0x43, 0x21, 0x50, 0x5a, 0x00, 0x75, 0x44, 0x48, 0x50, 0x61, 0x72, 0x74, 0x32, 0x20, 0x9e, 0xb2, 0xa5, 0x8b, 0xe8, 0x96, 0x37, 0xf5, 0x5a, 0x41, 0x34, 0xb2, 0xec, 0xda, 0x84, 0x95, 0xf0, 0xf8, 0x9b, 0xab, 0x61, 0x4f, 0x7c, 0x9e, 0x56, 0xb7, 0x3b, 0xd3, 0x46, 0xba, 0xbe, 0x9a, 0xae, 0x97, 0x97, 0xda, 0x5f, 0x9f, 0x89, 0xba, 0xfe, 0x61, 0x66, 0x5f, 0x9e, 0xa4, 0x5b, 0xcb, 0xd5, 0x69, 0xcf, 0xfb, 0xfd, 0xdc, 0xac, 0x79, 0xac, 0x1d, 0x0b, 0xe5, 0x15, 0x75, 0x39, 0x2e, 0xe5, 0xa9, 0x2a, 0x60, 0xd7, 0xe3, 0x48, 0xd0, 0x1f, 0xd8, 0x61, 0x65, 0xfd, 0x2e, 0x5c, 0xef, 0x43, 0xf5, 0x63, 0x99, 0xb3, 0x45, 0x25, 0xe3, 0xbc, 0xf0, 0xe1, 0xad, 0xf7, 0x84, 0xcd, 0x82, 0x20, 0xe3, 0x6f, 0x2c, 0x77, 0x51, 0xf1, 0x11, 0x2e, 0x4a, 0x2c, 0xfd, 0x2f, 0x5e, 0x74, 0xa9, 0x37, 0x99, 0xff, 0xf7, 0x4c, 0x2d, 0xa8, 0xcf, 0x51, 0xfd, 0x5b, 0xe7, 0x51, 0x14, 0x6d, 0xbc, 0x2f, 0x5b, 0xb9, 0x77, 0x85, 0xad, 0xb4, 0x72, 0x99, 0xad, 0x7b, 0x6c, 0x6a, 0xdf, 0x4d, 0xca, 0x2f, 0xef, 0x8b, 0x5e, 0x4b, 0xf3, 0xd9, 0xfd, 0xbd, 0x47, 0x1a, 0x72, 0xe2, 0x41, 0xd8, 0xfa, 0xa1, 0x25, 0x00, 0xa3, 0xfe, 0x12, 0xda, 0xf6, 0x16, 0xb3, 0xb3, 0x08, 0x02, 0xfd, 0x0a, 0x6a, 0xab, 0x85, 0x17, 0xd7, 0x0f, 0xf4, 0x6b, 0xdf, 0x8f, 0xe2, 0x05, 0xf4, 0x5b, 0x13, 0x26, 0xa9, 0xe2, 0x57, 0xb6, 0xda, 0x76, 0x17, 0x3c, 0x52, 0x13, 0x8d, 0x83, 0xc0, 0x2b, 0xe7, 0x2e, 0xbd, 0xb0, 0xde, 0x98, 0x4f, 0x7a, 0x95, 0xa1, 0x75, 0x19, 0x6e, 0xda, 0x19, 0xff, 0x7f, 0xdd, 0x70, 0x01, 0x12, 0x3c, 0x9e, 0xd7, 0xfe, 0xc3, 0x22, 0x39, 0xce, 0x4f, 0x86, 0xd8, 0x85, 0x40, 0x75, 0xd4, 0xfe, 0x93, 0x57, 0xbc, 0x9b, 0x01, 0xa4, 0x71, 0x35, 0x70, 0x9d, 0x62, 0x91, 0x47, 0x4e, 0x32, 0xa2, 0x76, 0x16, 0x06, 0xaf, 0xc7, 0xe3, 0xe5, 0xdc, 0x25, 0xac, 0xe7, 0x68, 0x25, 0x69, 0x0f, 0x97, 0x8d, 0x91, 0x32, 0x81, 0x23, 0xb1, 0x08, 0xf3, 0xa3, 0x2b, 0x3d, 0xfb, 0xcf, 0x99, 0x12, 0x0a, 0x59, 0xb9, 0xbb, 0x76, 0x16, 0x71, 0xa2, 0x0b, 0x0a, 0x5a, 0x6c, 0x37, 0x99, 0x9d, 0xe6, 0x3a, 0x05, 0x89, 0xf7, 0xc6, 0xfc, 0xf3, 0xfe, 0x36, 0x97, 0x77, 0x86, 0xe4, 0x7c, 0x48, 0x93, 0x0b, 0x26, 0x8e, 0x31, 0xe9, 0x22, 0xcc, 0xd3, 0xe0, 0x56, 0x29, 0xc8, 0x26, 0xe6, 0x1f, 0xa8, 0xb8, 0x93, 0x98, 0xec, 0xd9, 0x7c, 0x4a, 0x45, 0xd3, 0x71, 0x35, 0x9f, 0x14, 0xc1, 0x99, 0xd5, 0x21, 0x0b, 0xfa, 0x0f, 0xfb, 0x31, 0x7a, 0xa0, 0x70, 0x35, 0xb3, 0x9b, 0x1b, 0xe7, 0x65, 0xfd, 0xe3, 0x7d, 0x0b, 0xcc, 0x34, 0x4b, 0xf1, 0x5a, 0x9f, 0x19, 0xa4, 0x8f, 0xc8, 0x30, 0xf1, 0x87, 0x99, 0xc2, 0x75, 0x55, 0x2a, 0x34, 0xd7, 0x81, 0x9c, 0x54, 0x12, 0x82, 0x69, 0x5f, 0x8b, 0x01, 0xc1, 0x45, 0x95, 0xf5, 0xb1, 0x2d, 0x27, 0x0d, 0xa9, 0xc3, 0x93, 0x54, 0x2f, 0x57, 0x04, 0x7b, 0x20, 0xb7, 0xac, 0x33, 0x68, 0xb3, 0xef, 0x9a, 0x33, 0x95, 0x82, 0x9d, 0xfa, 0x2a, 0xb9, 0x88, 0x06, 0x04, 0x88, 0x51, 0x2c, 0x46, 0xdb, 0x83, 0xd7, 0x2f, 0xea, 0x1f, 0x0f, 0x24, 0xab, 0x03, 0xef, 0xb0, 0x61, 0xc7, 0x90, 0xdc, 0x78, 0x17, 0xf2, 0x9a, 0xab},\n\t/* This is a confirm1 packet, sequence number is 0x09f6, SSRC 0x12345678 */\n\t{0x10, 0x00, 0x09, 0xf6, 0x5a, 0x52, 0x54, 0x50, 0x12, 0x34, 0x56, 0x78, 0x50, 0x5a, 0x00, 0x13, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x72, 0x6d, 0x31, 0xb1, 0x21, 0xee, 0xe2, 0x67, 0xa4, 0xfd, 0xa6, 0x94, 0x24, 0x9a, 0x60, 0xf0, 0x2e, 0x5e, 0xd9, 0x33, 0xe1, 0xd8, 0x41, 0x54, 0xa3, 0x7c, 0xea, 0xe9, 0x61, 0xae, 0xf9, 0x19, 0x0d, 0xb3, 0x68, 0x68, 0x9e, 0xf8, 0x1a, 0x18, 0x91, 0x87, 0xc5, 0x6e, 0x5e, 0x2d, 0x5e, 0x32, 0xa2, 0xb2, 0x66, 0x31, 0xb8, 0xe5, 0x59, 0xc9, 0x10, 0xbb, 0xa0, 0x00, 0x6c, 0xee, 0x0c, 0x6d, 0xfb, 0xeb, 0x32, 0x85, 0xb6, 0x6e, 0x93},\n\t/* This is a confirm2 packet, sequence number is 0x02d2, SSRC 0x87654321 */\n\t{0x10, 0x00, 0x02, 0xd2, 0x5a, 0x52, 0x54, 0x50, 0x87, 0x65, 0x43, 0x21, 0x50, 0x5a, 0x00, 0x13, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x72, 0x6d, 0x32, 0x0f, 0xec, 0xfa, 0x4b, 0x45, 0x17, 0x9d, 0xb3, 0x92, 0x7d, 0x1c, 0x53, 0x86, 0x01, 0x12, 0xd9, 0x25, 0x48, 0xca, 0x18, 0xb9, 0x10, 0x95, 0x04, 0xb7, 0xc8, 0xee, 0x87, 0x2b, 0xec, 0x59, 0x39, 0x92, 0x96, 0x11, 0x73, 0xa6, 0x69, 0x2b, 0x11, 0xcd, 0x1d, 0xa1, 0x73, 0xb2, 0xc9, 0x29, 0x6f, 0x82, 0x32, 0x6a, 0x0a, 0x56, 0x40, 0x57, 0xfb, 0xac, 0xab, 0x20, 0xb8, 0xe2, 0xa9, 0x2c, 0x61, 0x6a, 0x05, 0xe8, 0xb5},\n\t/* This is a conf2ACK packet, sequence number 0x09f7, SSRC 0x12345678 */\n\t{0x10, 0x00, 0x09, 0xf7, 0x5a, 0x52, 0x54, 0x50, 0x12, 0x34, 0x56, 0x78, 0x50, 0x5a, 0x00, 0x03, 0x43, 0x6f, 0x6e, 0x66, 0x32, 0x41, 0x43, 0x4b, 0x23, 0xc1, 0x1b, 0x45},\n};\n\n/* Hash images for both sides */\nuint8_t H12345678[4][32] = {\n\t{0xbb, 0xbf, 0x7e, 0xb1, 0x14, 0xd5, 0xd4, 0x0c, 0x6b, 0xb0, 0x79, 0x58, 0x19, 0xc1, 0xd0, 0x83, 0xc9, 0xe1, 0xf4, 0x2e, 0x11, 0xcd, 0x7e, 0xc3, 0xaa, 0xd8, 0xb9, 0x17, 0xe6, 0xb5, 0x9e, 0x86},\n\t{0x28, 0x7c, 0x28, 0xe4, 0xd7, 0x3d, 0x14, 0x39, 0xb5, 0x6d, 0x1c, 0x47, 0x9d, 0x59, 0x0a, 0xf2, 0x10, 0x33, 0xde, 0x6b, 0xd5, 0x2b, 0xfb, 0x26, 0xa5, 0x87, 0x4d, 0xe9, 0x20, 0x6b, 0x9f, 0xdd},\n\t{0x70, 0x12, 0xef, 0x2e, 0x85, 0x2f, 0xfc, 0x84, 0xb8, 0x8d, 0xcc, 0x03, 0xd7, 0x8f, 0x53, 0x01, 0x63, 0xfb, 0xd3, 0xb0, 0x2d, 0xbb, 0x9e, 0x98, 0x22, 0x0d, 0xe3, 0xe3, 0x64, 0x25, 0x04, 0x0f},\n\t{0xe8, 0xd5, 0x26, 0xc1, 0x3a, 0x0c, 0x4c, 0x6a, 0xce, 0x18, 0xaa, 0xc7, 0xc4, 0xa4, 0x07, 0x0e, 0x65, 0x7a, 0x4d, 0xca, 0x78, 0xf2, 0xcc, 0xcd, 0x20, 0x50, 0x38, 0x73, 0xe9, 0x7e, 0x08, 0x29}\n};\n\nuint8_t H87654321[4][32] = {\n\t{0x09, 0x02, 0xcc, 0x13, 0xc4, 0x84, 0x03, 0x31, 0x68, 0x91, 0x05, 0x4d, 0xe0, 0x6d, 0xf4, 0xc9, 0x6a, 0xb5, 0xbe, 0x82, 0xe8, 0x37, 0x33, 0xb7, 0xa9, 0xce, 0xbe, 0xb5, 0x42, 0xaa, 0x54, 0xba},\n\t{0x9e, 0xb2, 0xa5, 0x8b, 0xe8, 0x96, 0x37, 0xf5, 0x5a, 0x41, 0x34, 0xb2, 0xec, 0xda, 0x84, 0x95, 0xf0, 0xf8, 0x9b, 0xab, 0x61, 0x4f, 0x7c, 0x9e, 0x56, 0xb7, 0x3b, 0xd3, 0x46, 0xba, 0xbe, 0x9a},\n\t{0xd9, 0xff, 0x14, 0x8b, 0x34, 0xaa, 0x69, 0xe9, 0x33, 0xc1, 0x62, 0xe6, 0x6b, 0xe8, 0xcd, 0x9d, 0xe3, 0x0f, 0xb7, 0x6a, 0xe8, 0x6a, 0x62, 0x2b, 0xcb, 0xe4, 0x6b, 0x91, 0x05, 0xc7, 0xc8, 0x7e},\n\t{0x8d, 0x0f, 0x5a, 0x20, 0x79, 0x97, 0x42, 0x01, 0x99, 0x45, 0x45, 0xf7, 0x0e, 0x31, 0x06, 0xe1, 0x05, 0xc0, 0xb9, 0x24, 0xe9, 0xc9, 0x78, 0xc7, 0x38, 0xf5, 0x97, 0x48, 0xef, 0x42, 0x6a, 0x3e}\n};\n\n/* mac and zrtp keys */\nuint8_t mackeyi[32] = {0xdc, 0x47, 0xe1, 0xc7, 0x48, 0x11, 0xb1, 0x54, 0x14, 0x2a, 0x91, 0x29, 0x9f, 0xa4, 0x8b, 0x45, 0x87, 0x16, 0x8d, 0x3a, 0xe6, 0xb0, 0x0c, 0x08, 0x4f, 0xa5, 0x48, 0xd5, 0x96, 0x67, 0x1a, 0x1b};\nuint8_t mackeyr[32] = {0x3a, 0xa5, 0x22, 0x43, 0x26, 0x13, 0x8f, 0xd6, 0x54, 0x59, 0x40, 0xb8, 0x5c, 0xf4, 0x0f, 0x0c, 0xbc, 0x9c, 0x4f, 0x7d, 0x55, 0xeb, 0x4b, 0xa5, 0x1e, 0x1c, 0x42, 0xd0, 0x5e, 0xac, 0x12, 0x06};\nuint8_t zrtpkeyi[16] = {0x22, 0xf6, 0xea, 0xaa, 0xa4, 0xad, 0x53, 0x30, 0x71, 0x97, 0xcc, 0x68, 0x6b, 0xb0, 0xcb, 0x55};\nuint8_t zrtpkeyr[16] = {0x09, 0x50, 0xcd, 0x9e, 0xc2, 0x78, 0x54, 0x31, 0x93, 0x2e, 0x99, 0x31, 0x15, 0x58, 0xd0, 0x2a};\n\nvoid test_parser(void) {\n\tint i, retval;\n\tbzrtpPacket_t *zrtpPacket;\n\n\t/* Create zrtp Context to use H0-H3 chains and others */\n\tbzrtpContext_t *context87654321 = bzrtp_createBzrtpContext(0x87654321);\n\tbzrtpContext_t *context12345678 = bzrtp_createBzrtpContext(0x12345678);\n\n\n\t/* replace created H by the patterns one to be able to generate the correct packet */\n\tmemcpy (context12345678->channelContext[0]->selfH[0], H12345678[0], 32);\n\tmemcpy (context12345678->channelContext[0]->selfH[1], H12345678[1], 32);\n\tmemcpy (context12345678->channelContext[0]->selfH[2], H12345678[2], 32);\n\tmemcpy (context12345678->channelContext[0]->selfH[3], H12345678[3], 32);\n\tmemcpy (context87654321->channelContext[0]->selfH[0], H87654321[0], 32);\n\tmemcpy (context87654321->channelContext[0]->selfH[1], H87654321[1], 32);\n\tmemcpy (context87654321->channelContext[0]->selfH[2], H87654321[2], 32);\n\tmemcpy (context87654321->channelContext[0]->selfH[3], H87654321[3], 32);\n\n\t/* preset the key agreement algo in the contexts */\n\tcontext87654321->channelContext[0]->keyAgreementAlgo = ZRTP_KEYAGREEMENT_DH3k;\n\tcontext12345678->channelContext[0]->keyAgreementAlgo = ZRTP_KEYAGREEMENT_DH3k;\n\tcontext87654321->channelContext[0]->cipherAlgo = ZRTP_CIPHER_AES1;\n\tcontext12345678->channelContext[0]->cipherAlgo = ZRTP_CIPHER_AES1;\n\tcontext87654321->channelContext[0]->hashAlgo = ZRTP_HASH_S256;\n\tcontext12345678->channelContext[0]->hashAlgo = ZRTP_HASH_S256;\n\n\tupdateCryptoFunctionPointers(context87654321->channelContext[0]);\n\tupdateCryptoFunctionPointers(context12345678->channelContext[0]);\n\n\t/* set the zrtp and mac keys */\n\tcontext87654321->channelContext[0]->mackeyi = (uint8_t *)malloc(32);\n\tcontext12345678->channelContext[0]->mackeyi = (uint8_t *)malloc(32);\n\tcontext87654321->channelContext[0]->mackeyr = (uint8_t *)malloc(32);\n\tcontext12345678->channelContext[0]->mackeyr = (uint8_t *)malloc(32);\n\n\tcontext87654321->channelContext[0]->zrtpkeyi = (uint8_t *)malloc(16);\n\tcontext12345678->channelContext[0]->zrtpkeyi = (uint8_t *)malloc(16);\n\tcontext87654321->channelContext[0]->zrtpkeyr = (uint8_t *)malloc(16);\n\tcontext12345678->channelContext[0]->zrtpkeyr = (uint8_t *)malloc(16);\n\n\tmemcpy(context12345678->channelContext[0]->mackeyi, mackeyi, 32);\n\tmemcpy(context12345678->channelContext[0]->mackeyr, mackeyr, 32);\n\tmemcpy(context12345678->channelContext[0]->zrtpkeyi, zrtpkeyi, 16);\n\tmemcpy(context12345678->channelContext[0]->zrtpkeyr, zrtpkeyr, 16);\n\tmemcpy(context87654321->channelContext[0]->mackeyi, mackeyi, 32);\n\tmemcpy(context87654321->channelContext[0]->mackeyr, mackeyr, 32);\n\tmemcpy(context87654321->channelContext[0]->zrtpkeyi, zrtpkeyi, 16);\n\tmemcpy(context87654321->channelContext[0]->zrtpkeyr, zrtpkeyr, 16);\n\n\t/* set the role: 87654321 is initiator in our exchange pattern */\n\tcontext12345678->channelContext[0]->role = RESPONDER;\n\n\tfor (i=0; i<TEST_PACKET_NUMBER; i++) {\n\t\tuint8_t freePacketFlag = 1;\n\t\t/* parse a packet string from patterns */\n\t\tzrtpPacket = bzrtp_packetCheck(patternZRTPPackets[i], patternZRTPMetaData[i][0], (patternZRTPMetaData[i][1])-1, &retval);\n\t\tretval +=  bzrtp_packetParser((patternZRTPMetaData[i][2]==0x87654321)?context12345678:context87654321, (patternZRTPMetaData[i][2]==0x87654321)?context12345678->channelContext[0]:context87654321->channelContext[0], patternZRTPPackets[i], patternZRTPMetaData[i][0], zrtpPacket);\n\t\t/*printf(\"parsing Ret val is %x index is %d\\n\", retval, i);*/\n\t\t/* We must store some packets in the context if we want to be able to parse further packets */\n\t\tif (zrtpPacket->messageType==MSGTYPE_HELLO) {\n\t\t\tif (patternZRTPMetaData[i][2]==0x87654321) {\n\t\t\t\tcontext12345678->channelContext[0]->peerPackets[HELLO_MESSAGE_STORE_ID] = zrtpPacket;\n\t\t\t} else {\n\t\t\t\tcontext87654321->channelContext[0]->peerPackets[HELLO_MESSAGE_STORE_ID] = zrtpPacket;\n\t\t\t}\n\t\t\tfreePacketFlag = 0;\n\t\t}\n\t\tif (zrtpPacket->messageType==MSGTYPE_COMMIT) {\n\t\t\tif (patternZRTPMetaData[i][2]==0x87654321) {\n\t\t\t\tcontext12345678->channelContext[0]->peerPackets[COMMIT_MESSAGE_STORE_ID] = zrtpPacket;\n\t\t\t} else {\n\t\t\t\tcontext87654321->channelContext[0]->peerPackets[COMMIT_MESSAGE_STORE_ID] = zrtpPacket;\n\t\t\t}\n\t\t\tfreePacketFlag = 0;\n\t\t}\n\t\tif (zrtpPacket->messageType==MSGTYPE_DHPART1 || zrtpPacket->messageType==MSGTYPE_DHPART2) {\n\t\t\tif (patternZRTPMetaData[i][2]==0x87654321) {\n\t\t\t\tcontext12345678->channelContext[0]->peerPackets[DHPART_MESSAGE_STORE_ID] = zrtpPacket;\n\t\t\t} else {\n\t\t\t\tcontext87654321->channelContext[0]->peerPackets[DHPART_MESSAGE_STORE_ID] = zrtpPacket;\n\t\t\t}\n\t\t\tfreePacketFlag = 0;\n\t\t}\n\t\t/* free the packet string as will be created again by the packetBuild function and might have been copied by packetParser */\n\t\tfree(zrtpPacket->packetString);\n\t\t/* build a packet string from the parser packet*/\n\t\tretval = bzrtp_packetBuild((patternZRTPMetaData[i][2]==0x12345678)?context12345678:context87654321, (patternZRTPMetaData[i][2]==0x12345678)?context12345678->channelContext[0]:context87654321->channelContext[0], zrtpPacket, patternZRTPMetaData[i][1]);\n\t\t/* if (retval ==0) {\n\t\t\tpacketDump(zrtpPacket, 1);\n\t\t} else {\n\t\t\tbzrtp_message(\"Ret val is %x index is %d\\n\", retval, i);\n\t\t}*/\n\n\t\t/* check they are the same */\n\t\tif (zrtpPacket->packetString != NULL) {\n\t\t\tCU_ASSERT_TRUE(memcmp(zrtpPacket->packetString, patternZRTPPackets[i], patternZRTPMetaData[i][0]) == 0);\n\t\t} else {\n\t\t\tCU_FAIL(\"Unable to build packet\");\n\t\t}\n\n\t\tif (freePacketFlag == 1) {\n\t\t\tbzrtp_freeZrtpPacket(zrtpPacket);\n\t\t}\n\t}\n\n\tbzrtp_destroyBzrtpContext(context87654321, 0x87654321);\n\tbzrtp_destroyBzrtpContext(context12345678, 0x12345678);\n\n}\n\n/* context structure mainly used by statemachine test, but also needed by parserComplete to get the zid Filename */\ntypedef struct my_Context_struct {\n\tunsigned char nom[30]; /* nom du contexte */\n\tbzrtpContext_t *peerContext;\n\tbzrtpChannelContext_t *peerChannelContext;\n\tchar zidFilename[80]; /* nom du fichier de cache */\n} my_Context_t;\n\nstatic void freeBuf(void* p){\n\tfree(p);\n}\n\nint floadAlice(void *clientData, uint8_t **output, uint32_t *size, zrtpFreeBuffer_callback *cb) {\n\t/* get filename from ClientData */\n\tmy_Context_t *clientContext = (my_Context_t *)clientData;\n\tchar *filename = clientContext->zidFilename;\n\tFILE *ALICECACHE = fopen(filename, \"r+\");\n\tfseek(ALICECACHE, 0L, SEEK_END);  /* Position to end of file */\n  \t*size = ftell(ALICECACHE);     /* Get file length */\n  \trewind(ALICECACHE);               /* Back to start of file */\n\t*output = (uint8_t *)malloc(*size*sizeof(uint8_t)+1);\n\tif (fread(*output, 1, *size, ALICECACHE)==0){\n\t\tfprintf(stderr,\"floadAlice() fread() error\\n\");\n\t}\n\t*(*output+*size) = '\\0';\n\t*size += 1;\n\tfclose(ALICECACHE);\n\t*cb=freeBuf;\n\treturn *size;\n}\n\nint fwriteAlice(void *clientData, const uint8_t *input, uint32_t size) {\n\t/* get filename from ClientData */\n\tmy_Context_t *clientContext = (my_Context_t *)clientData;\n\tchar *filename = clientContext->zidFilename;\n\n\tFILE *ALICECACHE = fopen(filename, \"w+\");\n\tint retval = fwrite(input, 1, size, ALICECACHE);\n\tfclose(ALICECACHE);\n\treturn retval;\n}\n\nint floadBob(void *clientData, uint8_t **output, uint32_t *size, zrtpFreeBuffer_callback *cb) {\n\t/* get filename from ClientData */\n\tmy_Context_t *clientContext = (my_Context_t *)clientData;\n\tchar *filename = clientContext->zidFilename;\n\n\tFILE *BOBCACHE = fopen(filename, \"r+\");\n\tfseek(BOBCACHE, 0L, SEEK_END);  /* Position to end of file */\n  \t*size = ftell(BOBCACHE);     /* Get file length */\n  \trewind(BOBCACHE);               /* Back to start of file */\n\t*output = (uint8_t *)malloc(*size*sizeof(uint8_t)+1);\n\tif (fread(*output, 1, *size, BOBCACHE)==0){\n\t\tfprintf(stderr,\"floadBob(): fread error.\\n\");\n\t\treturn -1;\n\t}\n\t*(*output+*size) = '\\0';\n\t*size += 1;\n\tfclose(BOBCACHE);\n\t*cb=freeBuf;\n\treturn *size;\n}\n\n\nint fwriteBob(void *clientData, const uint8_t *input, uint32_t size) {\n\t/* get filename from ClientData */\n\tmy_Context_t *clientContext = (my_Context_t *)clientData;\n\tchar *filename = clientContext->zidFilename;\n\n\tFILE *BOBCACHE = fopen(filename, \"w+\");\n\tint retval = fwrite(input, 1, size, BOBCACHE);\n\tfclose(BOBCACHE);\n\treturn retval;\n}\n\nvoid test_parserComplete() {\n\n\tint retval;\n\t/* alice's maintained packet */\n\tbzrtpPacket_t *alice_Hello, *alice_HelloFromBob, *alice_HelloACK, *alice_HelloACKFromBob;\n\t/* bob's maintained packet */\n\tbzrtpPacket_t *bob_Hello, *bob_HelloFromAlice, *bob_HelloACK, *bob_HelloACKFromAlice;\n\t/* Create zrtp Context */\n\tbzrtpContext_t *contextAlice = bzrtp_createBzrtpContext(0x12345678); /* Alice's SSRC of main channel is 12345678 */\n\tbzrtpContext_t *contextBob = bzrtp_createBzrtpContext(0x87654321); /* Bob's SSRC of main channel is 87654321 */\n\n\tbzrtpHelloMessage_t *alice_HelloFromBob_message;\n\tbzrtpHelloMessage_t *bob_HelloFromAlice_message;\n\tbzrtpPacket_t *alice_selfDHPart;\n\tbzrtpPacket_t *bob_selfDHPart;\n\tbzrtpPacket_t *alice_Commit;\n\tbzrtpPacket_t *bob_Commit;\n\tbzrtpPacket_t *bob_CommitFromAlice;\n\tbzrtpPacket_t *alice_CommitFromBob;\n\tuint8_t tmpBuffer[8];\n\tbzrtpDHPartMessage_t *bob_DHPart1;\n\tbzrtpPacket_t *alice_DHPart1FromBob;\n\tbzrtpDHPartMessage_t *alice_DHPart1FromBob_message=NULL;\n\tbzrtpPacket_t *bob_DHPart2FromAlice;\n\tbzrtpDHPartMessage_t *bob_DHPart2FromAlice_message=NULL;\n\tuint16_t secretLength;\n\tuint16_t totalHashDataLength;\n\tuint8_t *dataToHash;\n\tuint16_t hashDataIndex = 0;\n\tuint8_t alice_totalHash[32]; /* Note : actual length of hash depends on the choosen algo */\n\tuint8_t bob_totalHash[32]; /* Note : actual length of hash depends on the choosen algo */\n\tuint8_t *s1=NULL;\n\tuint32_t s1Length=0;\n\tuint8_t *s2=NULL;\n\tuint32_t s2Length=0;\n\tuint8_t *s3=NULL;\n\tuint32_t s3Length=0;\n\tuint8_t alice_sasHash[32];\n\tuint8_t bob_sasHash[32];\n\tuint32_t sasValue;\n\tchar sas[32];\n\tbzrtpPacket_t *bob_Confirm1;\n\tbzrtpPacket_t *alice_Confirm1FromBob;\n\tbzrtpConfirmMessage_t *alice_Confirm1FromBob_message=NULL;\n\tbzrtpPacket_t *alice_Confirm2;\n\tbzrtpPacket_t *bob_Confirm2FromAlice;\n\tbzrtpConfirmMessage_t *bob_Confirm2FromAlice_message=NULL;\n\tbzrtpPacket_t *bob_Conf2ACK;\n\tbzrtpPacket_t *alice_Conf2ACKFromBob;\n\tbzrtpPacket_t *alice_Confirm1;\n\tbzrtpPacket_t *bob_Confirm1FromAlice;\n\tbzrtpConfirmMessage_t *bob_Confirm1FromAlice_message=NULL;\n\tbzrtpPacket_t *bob_Confirm2;\n\tbzrtpPacket_t *alice_Confirm2FromBob;\n\tbzrtpConfirmMessage_t *alice_Confirm2FromBob_message=NULL;\n\tbzrtpPacket_t *alice_Conf2ACK;\n\tbzrtpPacket_t *bob_Conf2ACKFromAlice;\n\tbzrtpCallbacks_t cbs={0};\n\n\t/* Create the client context, used for zidFilename only */\n\tmy_Context_t clientContextAlice;\n\tmy_Context_t clientContextBob;\n\tstrcpy(clientContextAlice.zidFilename, \"./ZIDAlice.txt\");\n\tstrcpy(clientContextBob.zidFilename, \"./ZIDBob.txt\");\n\n\t/* attach the clientContext to the bzrtp Context */\n\tretval = bzrtp_setClientData(contextAlice, 0x12345678, (void *)&clientContextAlice);\n\tretval += bzrtp_setClientData(contextBob, 0x87654321, (void *)&clientContextBob);\n\n\t/* set the cache related callback functions */\n\tcbs.bzrtp_loadCache=floadAlice;\n\tcbs.bzrtp_writeCache=fwriteAlice;\n\n\tbzrtp_setCallbacks(contextAlice, &cbs);\n\n\tcbs.bzrtp_loadCache=floadBob;\n\tcbs.bzrtp_writeCache=fwriteBob;\n\tbzrtp_setCallbacks(contextBob, &cbs);\n\n\tbzrtp_message (\"Init the contexts\\n\");\n\t/* end the context init */\n\tbzrtp_initBzrtpContext(contextAlice);\n\tbzrtp_initBzrtpContext(contextBob);\n\n\t/* now create Alice and BOB Hello packet */\n\talice_Hello = bzrtp_createZrtpPacket(contextAlice, contextAlice->channelContext[0], MSGTYPE_HELLO, &retval);\n\tif (bzrtp_packetBuild(contextAlice, contextAlice->channelContext[0], alice_Hello, contextAlice->channelContext[0]->selfSequenceNumber) ==0) {\n\t\tcontextAlice->channelContext[0]->selfSequenceNumber++;\n\t\tcontextAlice->channelContext[0]->selfPackets[HELLO_MESSAGE_STORE_ID] = alice_Hello;\n\t}\n\tbob_Hello = bzrtp_createZrtpPacket(contextBob, contextBob->channelContext[0], MSGTYPE_HELLO, &retval);\n\tif (bzrtp_packetBuild(contextBob, contextBob->channelContext[0], bob_Hello, contextBob->channelContext[0]->selfSequenceNumber) ==0) {\n\t\tcontextBob->channelContext[0]->selfSequenceNumber++;\n\t\tcontextBob->channelContext[0]->selfPackets[HELLO_MESSAGE_STORE_ID] = bob_Hello;\n\t}\n\n\t/* now send Alice Hello's to Bob and vice-versa, so they parse them */\n\talice_HelloFromBob = bzrtp_packetCheck(bob_Hello->packetString, bob_Hello->messageLength+16, contextAlice->channelContext[0]->peerSequenceNumber, &retval);\n\tretval +=  bzrtp_packetParser(contextAlice, contextAlice->channelContext[0], bob_Hello->packetString, bob_Hello->messageLength+16, alice_HelloFromBob);\n\tbzrtp_message (\"Alice parsing returns %x\\n\", retval);\n\tif (retval==0) {\n\t\tbzrtpHelloMessage_t *alice_HelloFromBob_message;\n\t\tint i;\n\n\t\tcontextAlice->channelContext[0]->peerSequenceNumber = alice_HelloFromBob->sequenceNumber;\n\t\t/* save bob's Hello packet in Alice's context */\n\t\tcontextAlice->channelContext[0]->peerPackets[HELLO_MESSAGE_STORE_ID] = alice_HelloFromBob;\n\n\t\t/* determine crypto Algo to use */\n\t\talice_HelloFromBob_message = (bzrtpHelloMessage_t *)alice_HelloFromBob->messageData;\n\t\tretval = crypoAlgoAgreement(contextAlice, contextAlice->channelContext[0], contextAlice->channelContext[0]->peerPackets[HELLO_MESSAGE_STORE_ID]->messageData);\n\t\tif (retval == 0) {\n\t\t\tbzrtp_message (\"Alice selected algo %x\\n\", contextAlice->channelContext[0]->keyAgreementAlgo);\n\t\t\tmemcpy(contextAlice->peerZID, alice_HelloFromBob_message->ZID, 12);\n\t\t}\n\n\t\t/* check if the peer accept MultiChannel */\n\t\tfor (i=0; i<alice_HelloFromBob_message->kc; i++) {\n\t\t\tif (alice_HelloFromBob_message->supportedKeyAgreement[i] == ZRTP_KEYAGREEMENT_Mult) {\n\t\t\t\tcontextAlice->peerSupportMultiChannel = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tbob_HelloFromAlice = bzrtp_packetCheck(alice_Hello->packetString, alice_Hello->messageLength+16, contextBob->channelContext[0]->peerSequenceNumber, &retval);\n\tretval +=  bzrtp_packetParser(contextBob, contextBob->channelContext[0], alice_Hello->packetString, alice_Hello->messageLength+16, bob_HelloFromAlice);\n\tbzrtp_message (\"Bob parsing returns %x\\n\", retval);\n\tif (retval==0) {\n\t\tbzrtpHelloMessage_t *bob_HelloFromAlice_message;\n\t\tint i;\n\n\t\tcontextBob->channelContext[0]->peerSequenceNumber = bob_HelloFromAlice->sequenceNumber;\n\t\t/* save alice's Hello packet in bob's context */\n\t\tcontextBob->channelContext[0]->peerPackets[HELLO_MESSAGE_STORE_ID] = bob_HelloFromAlice;\n\n\t\t/* determine crypto Algo to use */\n\t\tbob_HelloFromAlice_message = (bzrtpHelloMessage_t *)bob_HelloFromAlice->messageData;\n\t\tretval = crypoAlgoAgreement(contextBob, contextBob->channelContext[0], contextBob->channelContext[0]->peerPackets[HELLO_MESSAGE_STORE_ID]->messageData);\n\t\tif (retval == 0) {\n\t\t\tbzrtp_message (\"Bob selected algo %x\\n\", contextBob->channelContext[0]->keyAgreementAlgo);\n\t\t\tmemcpy(contextBob->peerZID, bob_HelloFromAlice_message->ZID, 12);\n\t\t}\n\n\t\t/* check if the peer accept MultiChannel */\n\t\tfor (i=0; i<bob_HelloFromAlice_message->kc; i++) {\n\t\t\tif (bob_HelloFromAlice_message->supportedKeyAgreement[i] == ZRTP_KEYAGREEMENT_Mult) {\n\t\t\t\tcontextBob->peerSupportMultiChannel = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* update context with hello message information : H3  and compute initiator and responder's shared secret Hashs */\n\talice_HelloFromBob_message = (bzrtpHelloMessage_t *)alice_HelloFromBob->messageData;\n\tmemcpy(contextAlice->channelContext[0]->peerH[3], alice_HelloFromBob_message->H3, 32);\n\tbob_HelloFromAlice_message = (bzrtpHelloMessage_t *)bob_HelloFromAlice->messageData;\n\tmemcpy(contextBob->channelContext[0]->peerH[3], bob_HelloFromAlice_message->H3, 32);\n\n\t/* get the secrets associated to peer ZID */\n\tbzrtp_getPeerAssociatedSecretsHash(contextAlice, alice_HelloFromBob_message->ZID);\n\tbzrtp_getPeerAssociatedSecretsHash(contextBob, bob_HelloFromAlice_message->ZID);\n\n\t/* compute the initiator hashed secret as in rfc section 4.3.1 */\n\tif (contextAlice->cachedSecret.rs1!=NULL) {\n\t\tcontextAlice->channelContext[0]->hmacFunction(contextAlice->cachedSecret.rs1, contextAlice->cachedSecret.rs1Length, (uint8_t *)\"Initiator\", 9, 8, contextAlice->initiatorCachedSecretHash.rs1ID);\n\t} else { /* we have no secret, generate a random */\n\t\tbctoolbox_rng_get(contextAlice->RNGContext, contextAlice->initiatorCachedSecretHash.rs1ID, 8);\n\t}\n\n\tif (contextAlice->cachedSecret.rs2!=NULL) {\n\t\tcontextAlice->channelContext[0]->hmacFunction(contextAlice->cachedSecret.rs2, contextAlice->cachedSecret.rs2Length, (uint8_t *)\"Initiator\", 9, 8, contextAlice->initiatorCachedSecretHash.rs2ID);\n\t} else { /* we have no secret, generate a random */\n\t\tbctoolbox_rng_get(contextAlice->RNGContext, contextAlice->initiatorCachedSecretHash.rs2ID, 8);\n\t}\n\n\tif (contextAlice->cachedSecret.auxsecret!=NULL) {\n\t\tcontextAlice->channelContext[0]->hmacFunction(contextAlice->cachedSecret.auxsecret, contextAlice->cachedSecret.auxsecretLength, contextAlice->channelContext[0]->selfH[3], 32, 8, contextAlice->channelContext[0]->initiatorAuxsecretID);\n\t} else { /* we have no secret, generate a random */\n\t\tbctoolbox_rng_get(contextAlice->RNGContext, contextAlice->channelContext[0]->initiatorAuxsecretID, 8);\n\t}\n\n\tif (contextAlice->cachedSecret.pbxsecret!=NULL) {\n\t\tcontextAlice->channelContext[0]->hmacFunction(contextAlice->cachedSecret.pbxsecret, contextAlice->cachedSecret.pbxsecretLength, (uint8_t *)\"Initiator\", 9, 8, contextAlice->initiatorCachedSecretHash.pbxsecretID);\n\t} else { /* we have no secret, generate a random */\n\t\tbctoolbox_rng_get(contextAlice->RNGContext, contextAlice->initiatorCachedSecretHash.pbxsecretID, 8);\n\t}\n\n\tif (contextAlice->cachedSecret.rs1!=NULL) {\n\t\tcontextAlice->channelContext[0]->hmacFunction(contextAlice->cachedSecret.rs1, contextAlice->cachedSecret.rs1Length, (uint8_t *)\"Responder\", 9, 8, contextAlice->responderCachedSecretHash.rs1ID);\n\t} else { /* we have no secret, generate a random */\n\t\tbctoolbox_rng_get(contextAlice->RNGContext, contextAlice->responderCachedSecretHash.rs1ID, 8);\n\t}\n\n\tif (contextAlice->cachedSecret.rs2!=NULL) {\n\t\tcontextAlice->channelContext[0]->hmacFunction(contextAlice->cachedSecret.rs2, contextAlice->cachedSecret.rs2Length, (uint8_t *)\"Responder\", 9, 8, contextAlice->responderCachedSecretHash.rs2ID);\n\t} else { /* we have no secret, generate a random */\n\t\tbctoolbox_rng_get(contextAlice->RNGContext, contextAlice->responderCachedSecretHash.rs2ID, 8);\n\t}\n\n\tif (contextAlice->cachedSecret.auxsecret!=NULL) {\n\t\tcontextAlice->channelContext[0]->hmacFunction(contextAlice->cachedSecret.auxsecret, contextAlice->cachedSecret.auxsecretLength, contextAlice->channelContext[0]->peerH[3], 32, 8, contextAlice->channelContext[0]->responderAuxsecretID);\n\t} else { /* we have no secret, generate a random */\n\t\tbctoolbox_rng_get(contextAlice->RNGContext, contextAlice->channelContext[0]->responderAuxsecretID, 8);\n\t}\n\n\tif (contextAlice->cachedSecret.pbxsecret!=NULL) {\n\t\tcontextAlice->channelContext[0]->hmacFunction(contextAlice->cachedSecret.pbxsecret, contextAlice->cachedSecret.pbxsecretLength, (uint8_t *)\"Responder\", 9, 8, contextAlice->responderCachedSecretHash.pbxsecretID);\n\t} else { /* we have no secret, generate a random */\n\t\tbctoolbox_rng_get(contextAlice->RNGContext, contextAlice->responderCachedSecretHash.pbxsecretID, 8);\n\t}\n\n\n\t/* Bob hashes*/\n\tif (contextBob->cachedSecret.rs1!=NULL) {\n\t\tcontextBob->channelContext[0]->hmacFunction(contextBob->cachedSecret.rs1, contextBob->cachedSecret.rs1Length, (uint8_t *)\"Initiator\", 9, 8, contextBob->initiatorCachedSecretHash.rs1ID);\n\t} else { /* we have no secret, generate a random */\n\t\tbctoolbox_rng_get(contextBob->RNGContext, contextBob->initiatorCachedSecretHash.rs1ID, 8);\n\t}\n\n\tif (contextBob->cachedSecret.rs2!=NULL) {\n\t\tcontextBob->channelContext[0]->hmacFunction(contextBob->cachedSecret.rs2, contextBob->cachedSecret.rs2Length, (uint8_t *)\"Initiator\", 9, 8, contextBob->initiatorCachedSecretHash.rs2ID);\n\t} else { /* we have no secret, generate a random */\n\t\tbctoolbox_rng_get(contextBob->RNGContext, contextBob->initiatorCachedSecretHash.rs2ID, 8);\n\t}\n\n\tif (contextBob->cachedSecret.auxsecret!=NULL) {\n\t\tcontextBob->channelContext[0]->hmacFunction(contextBob->cachedSecret.auxsecret, contextBob->cachedSecret.auxsecretLength, contextBob->channelContext[0]->selfH[3], 32, 8, contextBob->channelContext[0]->initiatorAuxsecretID);\n\t} else { /* we have no secret, generate a random */\n\t\tbctoolbox_rng_get(contextBob->RNGContext, contextBob->channelContext[0]->initiatorAuxsecretID, 8);\n\t}\n\n\tif (contextBob->cachedSecret.pbxsecret!=NULL) {\n\t\tcontextBob->channelContext[0]->hmacFunction(contextBob->cachedSecret.pbxsecret, contextBob->cachedSecret.pbxsecretLength, (uint8_t *)\"Initiator\", 9, 8, contextBob->initiatorCachedSecretHash.pbxsecretID);\n\t} else { /* we have no secret, generate a random */\n\t\tbctoolbox_rng_get(contextBob->RNGContext, contextBob->initiatorCachedSecretHash.pbxsecretID, 8);\n\t}\n\n\tif (contextBob->cachedSecret.rs1!=NULL) {\n\t\tcontextBob->channelContext[0]->hmacFunction(contextBob->cachedSecret.rs1, contextBob->cachedSecret.rs1Length, (uint8_t *)\"Responder\", 9, 8, contextBob->responderCachedSecretHash.rs1ID);\n\t} else { /* we have no secret, generate a random */\n\t\tbctoolbox_rng_get(contextBob->RNGContext, contextBob->responderCachedSecretHash.rs1ID, 8);\n\t}\n\n\tif (contextBob->cachedSecret.rs2!=NULL) {\n\t\tcontextBob->channelContext[0]->hmacFunction(contextBob->cachedSecret.rs2, contextBob->cachedSecret.rs2Length, (uint8_t *)\"Responder\", 9, 8, contextBob->responderCachedSecretHash.rs2ID);\n\t} else { /* we have no secret, generate a random */\n\t\tbctoolbox_rng_get(contextBob->RNGContext, contextBob->responderCachedSecretHash.rs2ID, 8);\n\t}\n\n\tif (contextBob->cachedSecret.auxsecret!=NULL) {\n\t\tcontextBob->channelContext[0]->hmacFunction(contextBob->cachedSecret.auxsecret, contextBob->cachedSecret.auxsecretLength, contextBob->channelContext[0]->peerH[3], 32, 8, contextBob->channelContext[0]->responderAuxsecretID);\n\t} else { /* we have no secret, generate a random */\n\t\tbctoolbox_rng_get(contextBob->RNGContext, contextBob->channelContext[0]->responderAuxsecretID, 8);\n\t}\n\n\tif (contextBob->cachedSecret.pbxsecret!=NULL) {\n\t\tcontextBob->channelContext[0]->hmacFunction(contextBob->cachedSecret.pbxsecret, contextBob->cachedSecret.pbxsecretLength, (uint8_t *)\"Responder\", 9, 8, contextBob->responderCachedSecretHash.pbxsecretID);\n\t} else { /* we have no secret, generate a random */\n\t\tbctoolbox_rng_get(contextBob->RNGContext, contextBob->responderCachedSecretHash.pbxsecretID, 8);\n\t}\n\n\t/* dump alice's packet on both sides */\n\tbzrtp_message (\"\\nAlice original Packet is \\n\");\n\tpacketDump(alice_Hello, 1);\n\tbzrtp_message (\"\\nBob's parsed Alice Packet is \\n\");\n\tpacketDump(bob_HelloFromAlice, 0);\n\n\t/* Create the DHPart2 packet (that we then may change to DHPart1 if we ended to be the responder) */\n\talice_selfDHPart = bzrtp_createZrtpPacket(contextAlice, contextAlice->channelContext[0], MSGTYPE_DHPART2, &retval);\n\tretval += bzrtp_packetBuild(contextAlice, contextAlice->channelContext[0], alice_selfDHPart, 0); /* we don't care now about sequence number as we just need to build the message to be able to insert a hash of it into the commit packet */\n\tif (retval == 0) { /* ok, insert it in context as we need it to build the commit packet */\n\t\tcontextAlice->channelContext[0]->selfPackets[DHPART_MESSAGE_STORE_ID] = alice_selfDHPart;\n\t} else {\n\t\tbzrtp_message (\"Alice building DHPart packet returns %x\\n\", retval);\n\t}\n\tbob_selfDHPart = bzrtp_createZrtpPacket(contextBob, contextBob->channelContext[0], MSGTYPE_DHPART2, &retval);\n\tretval +=bzrtp_packetBuild(contextBob, contextBob->channelContext[0], bob_selfDHPart, 0); /* we don't care now about sequence number as we just need to build the message to be able to insert a hash of it into the commit packet */\n\tif (retval == 0) { /* ok, insert it in context as we need it to build the commit packet */\n\t\tcontextBob->channelContext[0]->selfPackets[DHPART_MESSAGE_STORE_ID] = bob_selfDHPart;\n\t} else {\n\t\tbzrtp_message (\"Bob building DHPart packet returns %x\\n\", retval);\n\t}\n\tbzrtp_message(\"Alice DHPart packet:\\n\");\n\tpacketDump(alice_selfDHPart,0);\n\tbzrtp_message(\"Bob DHPart packet:\\n\");\n\tpacketDump(bob_selfDHPart,0);\n\n\t/* respond to HELLO packet with an HelloACK - 1 create packets */\n\talice_HelloACK = bzrtp_createZrtpPacket(contextAlice, contextAlice->channelContext[0], MSGTYPE_HELLOACK, &retval);\n\tretval += bzrtp_packetBuild(contextAlice, contextAlice->channelContext[0], alice_HelloACK, contextAlice->channelContext[0]->selfSequenceNumber);\n\tif (retval == 0) {\n\t\tcontextAlice->channelContext[0]->selfSequenceNumber++;\n\t} else {\n\t\tbzrtp_message(\"Alice building HelloACK return %x\\n\", retval);\n\t}\n\n\tbob_HelloACK = bzrtp_createZrtpPacket(contextBob, contextBob->channelContext[0], MSGTYPE_HELLOACK, &retval);\n\tretval += bzrtp_packetBuild(contextBob, contextBob->channelContext[0], bob_HelloACK, contextBob->channelContext[0]->selfSequenceNumber);\n\tif (retval == 0) {\n\t\tcontextBob->channelContext[0]->selfSequenceNumber++;\n\t} else {\n\t\tbzrtp_message(\"Bob building HelloACK return %x\\n\", retval);\n\t}\n\n\t/* exchange the HelloACK */\n\talice_HelloACKFromBob = bzrtp_packetCheck(bob_HelloACK->packetString, bob_HelloACK->messageLength+16, contextAlice->channelContext[0]->peerSequenceNumber, &retval);\n\tretval +=  bzrtp_packetParser(contextAlice, contextAlice->channelContext[0], bob_HelloACK->packetString, bob_HelloACK->messageLength+16, alice_HelloACKFromBob);\n\tbzrtp_message (\"Alice parsing Hello ACK returns %x\\n\", retval);\n\tif (retval==0) {\n\t\tcontextAlice->channelContext[0]->peerSequenceNumber = alice_HelloACKFromBob->sequenceNumber;\n\t}\n\n\tbob_HelloACKFromAlice = bzrtp_packetCheck(alice_HelloACK->packetString, alice_HelloACK->messageLength+16, contextBob->channelContext[0]->peerSequenceNumber, &retval);\n\tretval +=  bzrtp_packetParser(contextBob, contextBob->channelContext[0], alice_HelloACK->packetString, alice_HelloACK->messageLength+16, bob_HelloACKFromAlice);\n\tbzrtp_message (\"Bob parsing Hello ACK returns %x\\n\", retval);\n\tif (retval==0) {\n\t\tcontextBob->channelContext[0]->peerSequenceNumber = bob_HelloACKFromAlice->sequenceNumber;\n\t}\n\tbzrtp_freeZrtpPacket(alice_HelloACK);\n\tbzrtp_freeZrtpPacket(bob_HelloACK);\n\tbzrtp_freeZrtpPacket(alice_HelloACKFromBob);\n\tbzrtp_freeZrtpPacket(bob_HelloACKFromAlice);\n\n\n\t/* now build the commit message (both Alice and Bob will send it, then use the mechanism of rfc section 4.2 to determine who will be the initiator)*/\n\talice_Commit = bzrtp_createZrtpPacket(contextAlice, contextAlice->channelContext[0], MSGTYPE_COMMIT, &retval);\n\tretval += bzrtp_packetBuild(contextAlice, contextAlice->channelContext[0], alice_Commit, contextAlice->channelContext[0]->selfSequenceNumber);\n\tif (retval == 0) {\n\t\tcontextAlice->channelContext[0]->selfSequenceNumber++;\n\t\tcontextAlice->channelContext[0]->selfPackets[COMMIT_MESSAGE_STORE_ID] = alice_Commit;\n\t}\n\tbzrtp_message(\"Alice building Commit return %x\\n\", retval);\n\n\tbob_Commit = bzrtp_createZrtpPacket(contextBob, contextBob->channelContext[0], MSGTYPE_COMMIT, &retval);\n\tretval += bzrtp_packetBuild(contextBob, contextBob->channelContext[0], bob_Commit, contextBob->channelContext[0]->selfSequenceNumber);\n\tif (retval == 0) {\n\t\tcontextBob->channelContext[0]->selfSequenceNumber++;\n\t\tcontextBob->channelContext[0]->selfPackets[COMMIT_MESSAGE_STORE_ID] = bob_Commit;\n\t}\n\tbzrtp_message(\"Bob building Commit return %x\\n\", retval);\n\n\n\t/* and exchange the commits */\n\tbob_CommitFromAlice = bzrtp_packetCheck(alice_Commit->packetString, alice_Commit->messageLength+16, contextBob->channelContext[0]->peerSequenceNumber, &retval);\n\tretval += bzrtp_packetParser(contextBob, contextBob->channelContext[0], alice_Commit->packetString, alice_Commit->messageLength+16, bob_CommitFromAlice);\n\tbzrtp_message (\"Bob parsing Commit returns %x\\n\", retval);\n\tif (retval==0) {\n\t\t/* update context with the information found in the packet */\n\t\tbzrtpCommitMessage_t *bob_CommitFromAlice_message = (bzrtpCommitMessage_t *)bob_CommitFromAlice->messageData;\n\t\tcontextBob->channelContext[0]->peerSequenceNumber = bob_CommitFromAlice->sequenceNumber;\n\t\tmemcpy(contextBob->channelContext[0]->peerH[2], bob_CommitFromAlice_message->H2, 32);\n\t\tcontextBob->channelContext[0]->peerPackets[COMMIT_MESSAGE_STORE_ID] = bob_CommitFromAlice;\n\t}\n\tpacketDump(bob_CommitFromAlice, 0);\n\n\talice_CommitFromBob = bzrtp_packetCheck(bob_Commit->packetString, bob_Commit->messageLength+16, contextAlice->channelContext[0]->peerSequenceNumber, &retval);\n\tretval += bzrtp_packetParser(contextAlice, contextAlice->channelContext[0], bob_Commit->packetString, bob_Commit->messageLength+16, alice_CommitFromBob);\n\tbzrtp_message (\"Alice parsing Commit returns %x\\n\", retval);\n\tif (retval==0) {\n\t\t/* update context with the information found in the packet */\n\t\tcontextAlice->channelContext[0]->peerSequenceNumber = alice_CommitFromBob->sequenceNumber;\n\t\t/* Alice will be the initiator (commit contention not implemented in this test) so just discard bob's commit */\n\t\t/*bzrtpCommirMessage_t *alice_CommitFromBob_message = (bzrtpCommitMessage_t *)alice_CommitFromBob->messageData;\n\t\tmemcpy(contextAlice->channelContext[0]->peerH[2], alice_CommitFromBob_message->H2, 32);\n\t\tcontextAlice->channelContext[0]->peerPackets[COMMIT_MESSAGE_STORE_ID] = alice_CommitFromBob;*/\n\t}\n\tpacketDump(alice_CommitFromBob, 0);\n\tbzrtp_freeZrtpPacket(alice_CommitFromBob);\n\n\t/* Now determine who shall be the initiator : rfc section 4.2 */\n\t/* select the one with the lowest value of hvi */\n\t/* for test purpose, we will set Alice as the initiator */\n\tcontextBob->channelContext[0]->role = RESPONDER;\n\n\t/* Bob (responder) shall update his selected algo list to match Alice selection */\n\t/* no need to do this here as we have the same selection */\n\n\t/* Bob is the responder, rebuild his DHPart packet to be responder and not initiator : */\n\t/* as responder, bob must also swap his aux shared secret between responder and initiator as they are computed using the H3 and not a constant string */\n\tmemcpy(tmpBuffer, contextBob->channelContext[0]->initiatorAuxsecretID, 8);\n\tmemcpy(contextBob->channelContext[0]->initiatorAuxsecretID, contextBob->channelContext[0]->responderAuxsecretID, 8);\n\tmemcpy(contextBob->channelContext[0]->responderAuxsecretID, tmpBuffer, 8);\n\n\tcontextBob->channelContext[0]->selfPackets[DHPART_MESSAGE_STORE_ID]->messageType = MSGTYPE_DHPART1; /* we are now part 1*/\n\tbob_DHPart1 = (bzrtpDHPartMessage_t *)contextBob->channelContext[0]->selfPackets[DHPART_MESSAGE_STORE_ID]->messageData;\n\t/* change the shared secret ID to the responder one (we set them by default to the initiator's one) */\n\tmemcpy(bob_DHPart1->rs1ID, contextBob->responderCachedSecretHash.rs1ID, 8);\n\tmemcpy(bob_DHPart1->rs2ID, contextBob->responderCachedSecretHash.rs2ID, 8);\n\tmemcpy(bob_DHPart1->auxsecretID, contextBob->channelContext[0]->responderAuxsecretID, 8);\n\tmemcpy(bob_DHPart1->pbxsecretID, contextBob->responderCachedSecretHash.pbxsecretID, 8);\n\n\tretval +=bzrtp_packetBuild(contextBob, contextBob->channelContext[0], contextBob->channelContext[0]->selfPackets[DHPART_MESSAGE_STORE_ID],contextBob->channelContext[0]->selfSequenceNumber);\n\tif (retval == 0) {\n\t\tcontextBob->channelContext[0]->selfSequenceNumber++;\n\t}\n\tbzrtp_message(\"Bob building DHPart1 return %x\\n\", retval);\n\n\n\t/* Alice parse bob's DHPart1 message */\n\talice_DHPart1FromBob = bzrtp_packetCheck(contextBob->channelContext[0]->selfPackets[DHPART_MESSAGE_STORE_ID]->packetString, contextBob->channelContext[0]->selfPackets[DHPART_MESSAGE_STORE_ID]->messageLength+16, contextAlice->channelContext[0]->peerSequenceNumber, &retval);\n\tretval += bzrtp_packetParser(contextAlice, contextAlice->channelContext[0], contextBob->channelContext[0]->selfPackets[DHPART_MESSAGE_STORE_ID]->packetString, contextBob->channelContext[0]->selfPackets[DHPART_MESSAGE_STORE_ID]->messageLength+16, alice_DHPart1FromBob);\n\tbzrtp_message (\"Alice parsing DHPart1 returns %x\\n\", retval);\n\tif (retval==0) {\n\t\t/* update context with the information found in the packet */\n\t\tcontextAlice->channelContext[0]->peerSequenceNumber = alice_DHPart1FromBob->sequenceNumber;\n\t\talice_DHPart1FromBob_message = (bzrtpDHPartMessage_t *)alice_DHPart1FromBob->messageData;\n\t\tmemcpy(contextAlice->channelContext[0]->peerH[1], alice_DHPart1FromBob_message->H1, 32);\n\t\tcontextAlice->channelContext[0]->peerPackets[DHPART_MESSAGE_STORE_ID] = alice_DHPart1FromBob;\n\t}\n\tpacketDump(alice_DHPart1FromBob, 1);\n\n\t/* Now Alice may check which shared secret she expected and if they are valid in bob's DHPart1 */\n\tif (contextAlice->cachedSecret.rs1!=NULL) {\n\t\tif (memcmp(contextAlice->responderCachedSecretHash.rs1ID, alice_DHPart1FromBob_message->rs1ID,8) != 0) {\n\t\t\tbzrtp_message (\"Alice found that requested shared secret rs1 ID differs!\\n\");\n\t\t} else {\n\t\t\tbzrtp_message(\"Alice validate rs1ID from bob DHPart1\\n\");\n\t\t}\n\t}\n\tif (contextAlice->cachedSecret.rs2!=NULL) {\n\t\tif (memcmp(contextAlice->responderCachedSecretHash.rs2ID, alice_DHPart1FromBob_message->rs2ID,8) != 0) {\n\t\t\tbzrtp_message (\"Alice found that requested shared secret rs2 ID differs!\\n\");\n\t\t} else {\n\t\t\tbzrtp_message(\"Alice validate rs2ID from bob DHPart1\\n\");\n\t\t}\n\t}\n\tif (contextAlice->cachedSecret.auxsecret!=NULL) {\n\t\tif (memcmp(contextAlice->channelContext[0]->responderAuxsecretID, alice_DHPart1FromBob_message->auxsecretID,8) != 0) {\n\t\t\tbzrtp_message (\"Alice found that requested shared secret aux secret ID differs!\\n\");\n\t\t} else {\n\t\t\tbzrtp_message(\"Alice validate aux secret ID from bob DHPart1\\n\");\n\t\t}\n\t}\n\tif (contextAlice->cachedSecret.pbxsecret!=NULL) {\n\t\tif (memcmp(contextAlice->responderCachedSecretHash.pbxsecretID, alice_DHPart1FromBob_message->pbxsecretID,8) != 0) {\n\t\t\tbzrtp_message (\"Alice found that requested shared secret pbx secret ID differs!\\n\");\n\t\t} else {\n\t\t\tbzrtp_message(\"Alice validate pbxsecretID from bob DHPart1\\n\");\n\t\t}\n\t}\n\n\t/* Now Alice shall check that the PV from bob is not 1 or Prime-1 TODO*/\n\t/* Compute the shared DH secret */\n\tcontextAlice->DHMContext->peer = (uint8_t *)malloc(contextAlice->channelContext[0]->keyAgreementLength*sizeof(uint8_t));\n\tmemcpy (contextAlice->DHMContext->peer, alice_DHPart1FromBob_message->pv, contextAlice->channelContext[0]->keyAgreementLength);\n\tbctoolbox_DHMComputeSecret(contextAlice->DHMContext, (int (*)(void *, uint8_t *, size_t))bctoolbox_rng_get, (void *)contextAlice->RNGContext);\n\n\t/* So Alice send bob her DHPart2 message which is already prepared and stored (we just need to update the sequence number) */\n\tbzrtp_packetUpdateSequenceNumber(contextAlice->channelContext[0]->selfPackets[DHPART_MESSAGE_STORE_ID], contextAlice->channelContext[0]->selfSequenceNumber);\n\tcontextAlice->channelContext[0]->selfSequenceNumber++;\n\n\t/* Bob parse Alice's DHPart2 message */\n\tbob_DHPart2FromAlice = bzrtp_packetCheck(contextAlice->channelContext[0]->selfPackets[DHPART_MESSAGE_STORE_ID]->packetString, contextAlice->channelContext[0]->selfPackets[DHPART_MESSAGE_STORE_ID]->messageLength+16, contextBob->channelContext[0]->peerSequenceNumber, &retval);\n\tbzrtp_message (\"Bob checking DHPart2 returns %x\\n\", retval);\n\tretval += bzrtp_packetParser(contextBob, contextBob->channelContext[0], contextAlice->channelContext[0]->selfPackets[DHPART_MESSAGE_STORE_ID]->packetString, contextAlice->channelContext[0]->selfPackets[DHPART_MESSAGE_STORE_ID]->messageLength+16, bob_DHPart2FromAlice);\n\tbzrtp_message (\"Bob parsing DHPart2 returns %x\\n\", retval);\n\tif (retval==0) {\n\t\t/* update context with the information found in the packet */\n\t\tcontextBob->channelContext[0]->peerSequenceNumber = bob_DHPart2FromAlice->sequenceNumber;\n\t\tbob_DHPart2FromAlice_message = (bzrtpDHPartMessage_t *)bob_DHPart2FromAlice->messageData;\n\t\tmemcpy(contextBob->channelContext[0]->peerH[1], bob_DHPart2FromAlice_message->H1, 32);\n\t\tcontextBob->channelContext[0]->peerPackets[DHPART_MESSAGE_STORE_ID] = bob_DHPart2FromAlice;\n\t}\n\tpacketDump(bob_DHPart2FromAlice, 0);\n\n\t/* Now Bob may check which shared secret she expected and if they are valid in bob's DHPart1 */\n\tif (contextBob->cachedSecret.rs1!=NULL) {\n\t\tif (memcmp(contextBob->initiatorCachedSecretHash.rs1ID, bob_DHPart2FromAlice_message->rs1ID,8) != 0) {\n\t\t\tbzrtp_message (\"Bob found that requested shared secret rs1 ID differs!\\n\");\n\t\t} else {\n\t\t\tbzrtp_message(\"Bob validate rs1ID from Alice DHPart2\\n\");\n\t\t}\n\t}\n\tif (contextBob->cachedSecret.rs2!=NULL) {\n\t\tif (memcmp(contextBob->initiatorCachedSecretHash.rs2ID, bob_DHPart2FromAlice_message->rs2ID,8) != 0) {\n\t\t\tbzrtp_message (\"Bob found that requested shared secret rs2 ID differs!\\n\");\n\t\t} else {\n\t\t\tbzrtp_message(\"Bob validate rs2ID from Alice DHPart2\\n\");\n\t\t}\n\t}\n\tif (contextBob->cachedSecret.auxsecret!=NULL) {\n\t\tif (memcmp(contextBob->channelContext[0]->initiatorAuxsecretID, bob_DHPart2FromAlice_message->auxsecretID,8) != 0) {\n\t\t\tbzrtp_message (\"Bob found that requested shared secret aux secret ID differs!\\n\");\n\t\t} else {\n\t\t\tbzrtp_message(\"Bob validate aux secret ID from Alice DHPart2\\n\");\n\t\t}\n\t}\n\tif (contextBob->cachedSecret.pbxsecret!=NULL) {\n\t\tif (memcmp(contextBob->initiatorCachedSecretHash.pbxsecretID, bob_DHPart2FromAlice_message->pbxsecretID,8) != 0) {\n\t\t\tbzrtp_message (\"Bob found that requested shared secret pbx secret ID differs!\\n\");\n\t\t} else {\n\t\t\tbzrtp_message(\"Bob validate pbxsecretID from Alice DHPart2\\n\");\n\t\t}\n\t}\n\n\t/* Now Bob shall check that the PV from Alice is not 1 or Prime-1 TODO*/\n\t/* Compute the shared DH secret */\n\tcontextBob->DHMContext->peer = (uint8_t *)malloc(contextBob->channelContext[0]->keyAgreementLength*sizeof(uint8_t));\n\tmemcpy (contextBob->DHMContext->peer, bob_DHPart2FromAlice_message->pv, contextBob->channelContext[0]->keyAgreementLength);\n\tbctoolbox_DHMComputeSecret(contextBob->DHMContext, (int (*)(void *, uint8_t *, size_t))bctoolbox_rng_get, (void *)contextAlice->RNGContext);\n\n\n\t/* JUST FOR TEST: check that the generated secrets are the same */\n\tsecretLength = bob_DHPart2FromAlice->messageLength-84; /* length of generated secret is the same than public value */\n\tif (memcmp(contextBob->DHMContext->key, contextAlice->DHMContext->key, secretLength)==0) {\n\t\tbzrtp_message(\"Secret Key correctly exchanged \\n\");\n\t\tCU_PASS(\"Secret Key exchange OK\");\n\t} else {\n\t\tCU_FAIL(\"Secret Key exchange failed\");\n\t\tbzrtp_message(\"ERROR : secretKey exchange failed!!\\n\");\n\t}\n\n\t/* now compute the total_hash as in rfc section 4.4.1.4\n\t * total_hash = hash(Hello of responder || Commit || DHPart1 || DHPart2)\n\t */\n\ttotalHashDataLength = bob_Hello->messageLength + alice_Commit->messageLength + contextBob->channelContext[0]->selfPackets[DHPART_MESSAGE_STORE_ID]->messageLength + alice_selfDHPart->messageLength;\n\tdataToHash = (uint8_t *)malloc(totalHashDataLength*sizeof(uint8_t));\n\t/* get all data from Alice */\n\tmemcpy(dataToHash, contextAlice->channelContext[0]->peerPackets[HELLO_MESSAGE_STORE_ID]->packetString+ZRTP_PACKET_HEADER_LENGTH, contextAlice->channelContext[0]->peerPackets[HELLO_MESSAGE_STORE_ID]->messageLength);\n\thashDataIndex += contextAlice->channelContext[0]->peerPackets[HELLO_MESSAGE_STORE_ID]->messageLength;\n\tmemcpy(dataToHash+hashDataIndex, contextAlice->channelContext[0]->selfPackets[COMMIT_MESSAGE_STORE_ID]->packetString+ZRTP_PACKET_HEADER_LENGTH, contextAlice->channelContext[0]->selfPackets[COMMIT_MESSAGE_STORE_ID]->messageLength);\n\thashDataIndex += contextAlice->channelContext[0]->selfPackets[COMMIT_MESSAGE_STORE_ID]->messageLength;\n\tmemcpy(dataToHash+hashDataIndex, contextAlice->channelContext[0]->peerPackets[DHPART_MESSAGE_STORE_ID]->packetString+ZRTP_PACKET_HEADER_LENGTH, contextAlice->channelContext[0]->peerPackets[DHPART_MESSAGE_STORE_ID]->messageLength);\n\thashDataIndex += contextAlice->channelContext[0]->peerPackets[DHPART_MESSAGE_STORE_ID]->messageLength;\n\tmemcpy(dataToHash+hashDataIndex, contextAlice->channelContext[0]->selfPackets[DHPART_MESSAGE_STORE_ID]->packetString+ZRTP_PACKET_HEADER_LENGTH, contextAlice->channelContext[0]->selfPackets[DHPART_MESSAGE_STORE_ID]->messageLength);\n\n\tcontextAlice->channelContext[0]->hashFunction(dataToHash, totalHashDataLength, 32, alice_totalHash);\n\n\t/* get all data from Bob */\n\thashDataIndex = 0;\n\tmemcpy(dataToHash, contextBob->channelContext[0]->selfPackets[HELLO_MESSAGE_STORE_ID]->packetString+ZRTP_PACKET_HEADER_LENGTH, contextBob->channelContext[0]->selfPackets[HELLO_MESSAGE_STORE_ID]->messageLength);\n\thashDataIndex += contextBob->channelContext[0]->selfPackets[HELLO_MESSAGE_STORE_ID]->messageLength;\n\tmemcpy(dataToHash+hashDataIndex, contextBob->channelContext[0]->peerPackets[COMMIT_MESSAGE_STORE_ID]->packetString+ZRTP_PACKET_HEADER_LENGTH, contextBob->channelContext[0]->peerPackets[COMMIT_MESSAGE_STORE_ID]->messageLength);\n\thashDataIndex += contextBob->channelContext[0]->peerPackets[COMMIT_MESSAGE_STORE_ID]->messageLength;\n\tmemcpy(dataToHash+hashDataIndex, contextBob->channelContext[0]->selfPackets[DHPART_MESSAGE_STORE_ID]->packetString+ZRTP_PACKET_HEADER_LENGTH, contextBob->channelContext[0]->selfPackets[DHPART_MESSAGE_STORE_ID]->messageLength);\n\thashDataIndex += contextBob->channelContext[0]->selfPackets[DHPART_MESSAGE_STORE_ID]->messageLength;\n\tmemcpy(dataToHash+hashDataIndex, contextBob->channelContext[0]->peerPackets[DHPART_MESSAGE_STORE_ID]->packetString+ZRTP_PACKET_HEADER_LENGTH, contextBob->channelContext[0]->peerPackets[DHPART_MESSAGE_STORE_ID]->messageLength);\n\n\tcontextBob->channelContext[0]->hashFunction(dataToHash, totalHashDataLength, 32, bob_totalHash);\n\tif (memcmp(bob_totalHash, alice_totalHash, 32) == 0) {\n\t\tbzrtp_message(\"Got the same total hash\\n\");\n\t\tCU_PASS(\"Total Hash match\");\n\t} else {\n\t\tbzrtp_message(\"AARGG!! total hash mismatch\");\n\t\tCU_FAIL(\"Total Hash mismatch\");\n\t}\n\n\t/* now compute s0 and KDF_context as in rfc section 4.4.1.4\n\t\ts0 = hash(counter || DHResult || \"ZRTP-HMAC-KDF\" || ZIDi || ZIDr || total_hash || len(s1) || s1 || len(s2) || s2 || len(s3) || s3)\n\t\tcounter is a fixed 32 bits integer in big endian set to 1 : 0x00000001\n\t*/\n\tfree(dataToHash);\n\tcontextAlice->channelContext[0]->KDFContextLength = 24+32;/* actual depends on selected hash length*/\n\tcontextAlice->channelContext[0]->KDFContext = (uint8_t *)malloc(contextAlice->channelContext[0]->KDFContextLength*sizeof(uint8_t));\n\tmemcpy(contextAlice->channelContext[0]->KDFContext, contextAlice->selfZID, 12); /* ZIDi*/\n\tmemcpy(contextAlice->channelContext[0]->KDFContext+12, contextAlice->peerZID, 12); /* ZIDr */\n\tmemcpy(contextAlice->channelContext[0]->KDFContext+24, alice_totalHash, 32); /* total Hash*/\n\n\t/* get s1 from rs1 or rs2 */\n\tif (contextAlice->cachedSecret.rs1 != NULL) { /* if there is a s1 (already validated when received the DHpacket) */\n\t\ts1 = contextAlice->cachedSecret.rs1;\n\t\ts1Length = contextAlice->cachedSecret.rs1Length;\n\t} else if (contextAlice->cachedSecret.rs2 != NULL) { /* otherwise if there is a s2 (already validated when received the DHpacket) */\n\t\ts1 = contextAlice->cachedSecret.rs2;\n\t\ts1Length = contextAlice->cachedSecret.rs2Length;\n\t}\n\n\t/* s2 is the auxsecret */\n\ts2 = contextAlice->cachedSecret.auxsecret; /* this may be null if no match or no aux secret where found */\n\ts2Length = contextAlice->cachedSecret.auxsecretLength; /* this may be 0 if no match or no aux secret where found */\n\n\t/* s3 is the pbxsecret */\n\ts3 = contextAlice->cachedSecret.pbxsecret; /* this may be null if no match or no pbx secret where found */\n\ts3Length = contextAlice->cachedSecret.pbxsecretLength; /* this may be 0 if no match or no pbx secret where found */\n\n\ttotalHashDataLength = 4+secretLength+13/*ZRTP-HMAC-KDF string*/ + 12 + 12 + 32 + 4 +s1Length + 4 +s2Length + 4 + s3Length; /* secret length was computed before as the length of DH secret data */\n\n\tdataToHash = (uint8_t *)malloc(totalHashDataLength*sizeof(uint8_t));\n\tdataToHash[0] = 0x00;\n\tdataToHash[1] = 0x00;\n\tdataToHash[2] = 0x00;\n\tdataToHash[3] = 0x01;\n\thashDataIndex = 4;\n\n\tmemcpy(dataToHash+hashDataIndex, contextAlice->DHMContext->key, secretLength);\n\thashDataIndex += secretLength;\n\tmemcpy(dataToHash+hashDataIndex, \"ZRTP-HMAC-KDF\", 13);\n\thashDataIndex += 13;\n\tmemcpy(dataToHash+hashDataIndex, contextAlice->channelContext[0]->KDFContext, contextAlice->channelContext[0]->KDFContextLength);\n\thashDataIndex += 56;\n\n\tdataToHash[hashDataIndex++] = (uint8_t)((s1Length>>24)&0xFF);\n\tdataToHash[hashDataIndex++] = (uint8_t)((s1Length>>16)&0xFF);\n\tdataToHash[hashDataIndex++] = (uint8_t)((s1Length>>8)&0xFF);\n\tdataToHash[hashDataIndex++] = (uint8_t)(s1Length&0xFF);\n\tif (s1!=NULL) {\n\t\tmemcpy(dataToHash+hashDataIndex, s1, s1Length);\n\t\thashDataIndex += s1Length;\n\t}\n\n\tdataToHash[hashDataIndex++] = (uint8_t)((s2Length>>24)&0xFF);\n\tdataToHash[hashDataIndex++] = (uint8_t)((s2Length>>16)&0xFF);\n\tdataToHash[hashDataIndex++] = (uint8_t)((s2Length>>8)&0xFF);\n\tdataToHash[hashDataIndex++] = (uint8_t)(s2Length&0xFF);\n\tif (s2!=NULL) {\n\t\tmemcpy(dataToHash+hashDataIndex, s2, s2Length);\n\t\thashDataIndex += s2Length;\n\t}\n\n\tdataToHash[hashDataIndex++] = (uint8_t)((s3Length>>24)&0xFF);\n\tdataToHash[hashDataIndex++] = (uint8_t)((s3Length>>16)&0xFF);\n\tdataToHash[hashDataIndex++] = (uint8_t)((s3Length>>8)&0xFF);\n\tdataToHash[hashDataIndex++] = (uint8_t)(s3Length&0xFF);\n\tif (s3!=NULL) {\n\t\tmemcpy(dataToHash+hashDataIndex, s3, s3Length);\n\t\thashDataIndex += s3Length;\n\t}\n\n\tcontextAlice->channelContext[0]->s0 = (uint8_t *)malloc(32*sizeof(uint8_t));\n\tcontextAlice->channelContext[0]->hashFunction(dataToHash, totalHashDataLength, 32, contextAlice->channelContext[0]->s0);\n\n\t/* destroy all cached keys in context */\n\tif (contextAlice->cachedSecret.rs1!=NULL) {\n\t\tbzrtp_DestroyKey(contextAlice->cachedSecret.rs1, contextAlice->cachedSecret.rs1Length, contextAlice->RNGContext);\n\t\tfree(contextAlice->cachedSecret.rs1);\n\t\tcontextAlice->cachedSecret.rs1 = NULL;\n\t}\n\tif (contextAlice->cachedSecret.rs2!=NULL) {\n\t\tbzrtp_DestroyKey(contextAlice->cachedSecret.rs2, contextAlice->cachedSecret.rs2Length, contextAlice->RNGContext);\n\t\tfree(contextAlice->cachedSecret.rs2);\n\t\tcontextAlice->cachedSecret.rs2 = NULL;\n\t}\n\tif (contextAlice->cachedSecret.auxsecret!=NULL) {\n\t\tbzrtp_DestroyKey(contextAlice->cachedSecret.auxsecret, contextAlice->cachedSecret.auxsecretLength, contextAlice->RNGContext);\n\t\tfree(contextAlice->cachedSecret.auxsecret);\n\t\tcontextAlice->cachedSecret.auxsecret = NULL;\n\t}\n\tif (contextAlice->cachedSecret.pbxsecret!=NULL) {\n\t\tbzrtp_DestroyKey(contextAlice->cachedSecret.pbxsecret, contextAlice->cachedSecret.pbxsecretLength, contextAlice->RNGContext);\n\t\tfree(contextAlice->cachedSecret.pbxsecret);\n\t\tcontextAlice->cachedSecret.pbxsecret = NULL;\n\t}\n\n\t/*** Do the same for bob ***/\n\t/* get s1 from rs1 or rs2 */\n\ts1=NULL;\n\ts2=NULL;\n\ts3=NULL;\n\tcontextBob->channelContext[0]->KDFContextLength = 24+32;/* actual depends on selected hash length*/\n\tcontextBob->channelContext[0]->KDFContext = (uint8_t *)malloc(contextBob->channelContext[0]->KDFContextLength*sizeof(uint8_t));\n\tmemcpy(contextBob->channelContext[0]->KDFContext, contextBob->peerZID, 12); /* ZIDi*/\n\tmemcpy(contextBob->channelContext[0]->KDFContext+12, contextBob->selfZID, 12); /* ZIDr */\n\tmemcpy(contextBob->channelContext[0]->KDFContext+24, bob_totalHash, 32); /* total Hash*/\n\n\tif (contextBob->cachedSecret.rs1 != NULL) { /* if there is a s1 (already validated when received the DHpacket) */\n\t\ts1 = contextBob->cachedSecret.rs1;\n\t\ts1Length = contextBob->cachedSecret.rs1Length;\n\t} else if (contextBob->cachedSecret.rs2 != NULL) { /* otherwise if there is a s2 (already validated when received the DHpacket) */\n\t\ts1 = contextBob->cachedSecret.rs2;\n\t\ts1Length = contextBob->cachedSecret.rs2Length;\n\t}\n\n\t/* s2 is the auxsecret */\n\ts2 = contextBob->cachedSecret.auxsecret; /* this may be null if no match or no aux secret where found */\n\ts2Length = contextBob->cachedSecret.auxsecretLength; /* this may be 0 if no match or no aux secret where found */\n\n\t/* s3 is the pbxsecret */\n\ts3 = contextBob->cachedSecret.pbxsecret; /* this may be null if no match or no pbx secret where found */\n\ts3Length = contextBob->cachedSecret.pbxsecretLength; /* this may be 0 if no match or no pbx secret where found */\n\n\tfree(dataToHash);\n\tdataToHash = (uint8_t *)malloc(totalHashDataLength*sizeof(uint8_t));\n\tdataToHash[0] = 0x00;\n\tdataToHash[1] = 0x00;\n\tdataToHash[2] = 0x00;\n\tdataToHash[3] = 0x01;\n\thashDataIndex = 4;\n\n\tmemcpy(dataToHash+hashDataIndex, contextBob->DHMContext->key, secretLength);\n\thashDataIndex += secretLength;\n\tmemcpy(dataToHash+hashDataIndex, \"ZRTP-HMAC-KDF\", 13);\n\thashDataIndex += 13;\n\tmemcpy(dataToHash+hashDataIndex, contextBob->channelContext[0]->KDFContext, contextBob->channelContext[0]->KDFContextLength);\n\thashDataIndex += 56;\n\n\tdataToHash[hashDataIndex++] = (uint8_t)((s1Length>>24)&0xFF);\n\tdataToHash[hashDataIndex++] = (uint8_t)((s1Length>>16)&0xFF);\n\tdataToHash[hashDataIndex++] = (uint8_t)((s1Length>>8)&0xFF);\n\tdataToHash[hashDataIndex++] = (uint8_t)(s1Length&0xFF);\n\tif (s1!=NULL) {\n\t\tmemcpy(dataToHash+hashDataIndex, s1, s1Length);\n\t\thashDataIndex += s1Length;\n\t}\n\n\tdataToHash[hashDataIndex++] = (uint8_t)((s2Length>>24)&0xFF);\n\tdataToHash[hashDataIndex++] = (uint8_t)((s2Length>>16)&0xFF);\n\tdataToHash[hashDataIndex++] = (uint8_t)((s2Length>>8)&0xFF);\n\tdataToHash[hashDataIndex++] = (uint8_t)(s2Length&0xFF);\n\tif (s2!=NULL) {\n\t\tmemcpy(dataToHash+hashDataIndex, s2, s2Length);\n\t\thashDataIndex += s2Length;\n\t}\n\n\tdataToHash[hashDataIndex++] = (uint8_t)((s3Length>>24)&0xFF);\n\tdataToHash[hashDataIndex++] = (uint8_t)((s3Length>>16)&0xFF);\n\tdataToHash[hashDataIndex++] = (uint8_t)((s3Length>>8)&0xFF);\n\tdataToHash[hashDataIndex++] = (uint8_t)(s3Length&0xFF);\n\tif (s3!=NULL) {\n\t\tmemcpy(dataToHash+hashDataIndex, s3, s3Length);\n\t\thashDataIndex += s3Length;\n\t}\n\n\tcontextBob->channelContext[0]->s0 = (uint8_t *)malloc(32*sizeof(uint8_t));\n\tcontextBob->channelContext[0]->hashFunction(dataToHash, totalHashDataLength, 32, contextBob->channelContext[0]->s0);\n\n\tfree(dataToHash);\n\n\t/* destroy all cached keys in context */\n\tif (contextBob->cachedSecret.rs1!=NULL) {\n\t\tbzrtp_DestroyKey(contextBob->cachedSecret.rs1, contextBob->cachedSecret.rs1Length, contextBob->RNGContext);\n\t\tfree(contextBob->cachedSecret.rs1);\n\t\tcontextBob->cachedSecret.rs1 = NULL;\n\t}\n\tif (contextBob->cachedSecret.rs2!=NULL) {\n\t\tbzrtp_DestroyKey(contextBob->cachedSecret.rs2, contextBob->cachedSecret.rs2Length, contextBob->RNGContext);\n\t\tfree(contextBob->cachedSecret.rs2);\n\t\tcontextBob->cachedSecret.rs2 = NULL;\n\t}\n\tif (contextBob->cachedSecret.auxsecret!=NULL) {\n\t\tbzrtp_DestroyKey(contextBob->cachedSecret.auxsecret, contextBob->cachedSecret.auxsecretLength, contextBob->RNGContext);\n\t\tfree(contextBob->cachedSecret.auxsecret);\n\t\tcontextBob->cachedSecret.auxsecret = NULL;\n\t}\n\tif (contextBob->cachedSecret.pbxsecret!=NULL) {\n\t\tbzrtp_DestroyKey(contextBob->cachedSecret.pbxsecret, contextBob->cachedSecret.pbxsecretLength, contextBob->RNGContext);\n\t\tfree(contextBob->cachedSecret.pbxsecret);\n\t\tcontextBob->cachedSecret.pbxsecret = NULL;\n\t}\n\n\n\t/* DEBUG compare s0 */\n\tif (memcmp(contextBob->channelContext[0]->s0, contextAlice->channelContext[0]->s0, 32)==0) {\n\t\tbzrtp_message(\"Got the same s0\\n\");\n\t\tCU_PASS(\"s0 match\");\n\t} else {\n\t\tbzrtp_message(\"ERROR s0 differs\\n\");\n\t\tCU_PASS(\"s0 mismatch\");\n\t}\n\n\t/* now compute the ZRTPSession key : section 4.5.2\n\t * ZRTPSess = KDF(s0, \"ZRTP Session Key\", KDF_Context, negotiated hash length)*/\n\tcontextAlice->ZRTPSessLength=32; /* must be set to the length of negotiated hash */\n\tcontextAlice->ZRTPSess = (uint8_t *)malloc(contextAlice->ZRTPSessLength*sizeof(uint8_t));\n\tretval = bzrtp_keyDerivationFunction(contextAlice->channelContext[0]->s0, contextAlice->channelContext[0]->hashLength,\n\t\t(uint8_t *)\"ZRTP Session Key\", 16,\n\t\tcontextAlice->channelContext[0]->KDFContext, contextAlice->channelContext[0]->KDFContextLength, /* this one too depends on selected hash */\n\t\tcontextAlice->channelContext[0]->hashLength,\n\t\t(void (*)(uint8_t *, uint8_t,  uint8_t *, uint32_t,  uint8_t,  uint8_t *))contextAlice->channelContext[0]->hmacFunction,\n\t\tcontextAlice->ZRTPSess);\n\n\tcontextBob->ZRTPSessLength=32; /* must be set to the length of negotiated hash */\n\tcontextBob->ZRTPSess = (uint8_t *)malloc(contextBob->ZRTPSessLength*sizeof(uint8_t));\n\tretval = bzrtp_keyDerivationFunction(contextBob->channelContext[0]->s0, contextBob->channelContext[0]->hashLength,\n\t\t(uint8_t *)\"ZRTP Session Key\", 16,\n\t\tcontextBob->channelContext[0]->KDFContext, contextBob->channelContext[0]->KDFContextLength, /* this one too depends on selected hash */\n\t\tcontextBob->channelContext[0]->hashLength,\n\t\t(void (*)(uint8_t *, uint8_t,  uint8_t *, uint32_t,  uint8_t,  uint8_t *))contextBob->channelContext[0]->hmacFunction,\n\t\tcontextBob->ZRTPSess);\n\n\t/* DEBUG compare ZRTPSess Key */\n\tif (memcmp(contextBob->ZRTPSess, contextAlice->ZRTPSess, 32)==0) {\n\t\tbzrtp_message(\"Got the same ZRTPSess\\n\");\n\t\tCU_PASS(\"ZRTPSess match\");\n\t} else {\n\t\tbzrtp_message(\"ERROR ZRTPSess differs\\n\");\n\t\tCU_PASS(\"ZRTPSess mismatch\");\n\t}\n\n\n\t/* compute the sas according to rfc section 4.5.2 sashash = KDF(s0, \"SAS\", KDF_Context, 256) */\n\tretval = bzrtp_keyDerivationFunction(contextAlice->channelContext[0]->s0, contextAlice->channelContext[0]->hashLength,\n\t\t\t(uint8_t *)\"SAS\", 3,\n\t\t\tcontextAlice->channelContext[0]->KDFContext, contextAlice->channelContext[0]->KDFContextLength, /* this one too depends on selected hash */\n\t\t\t256/8, /* function gets L in bytes */\n\t\t\t(void (*)(uint8_t *, uint8_t,  uint8_t *, uint32_t,  uint8_t,  uint8_t *))contextAlice->channelContext[0]->hmacFunction,\n\t\t\talice_sasHash);\n\n\tretval = bzrtp_keyDerivationFunction(contextBob->channelContext[0]->s0, contextBob->channelContext[0]->hashLength,\n\t\t\t(uint8_t *)\"SAS\", 3,\n\t\t\tcontextBob->channelContext[0]->KDFContext, contextBob->channelContext[0]->KDFContextLength, /* this one too depends on selected hash */\n\t\t\t256/8, /* function gets L in bytes */\n\t\t\t(void (*)(uint8_t *, uint8_t,  uint8_t *, uint32_t,  uint8_t,  uint8_t *))contextBob->channelContext[0]->hmacFunction,\n\t\t\tbob_sasHash);\n\n\t/* DEBUG compare sasHash */\n\tif (memcmp(alice_sasHash, bob_sasHash, 32)==0) {\n\t\tbzrtp_message(\"Got the same SAS Hash\\n\");\n\t\tCU_PASS(\"SAS Hash match\");\n\t} else {\n\t\tbzrtp_message(\"ERROR SAS Hash differs\\n\");\n\t\tCU_PASS(\"SAS Hash mismatch\");\n\t}\n\n\t/* display SAS (we shall not do this now but after the confirm message exchanges) */\n\tsasValue = ((uint32_t)alice_sasHash[0]<<24) | ((uint32_t)alice_sasHash[1]<<16) | ((uint32_t)alice_sasHash[2]<<8) | ((uint32_t)(alice_sasHash[3]));\n\tcontextAlice->channelContext[0]->sasFunction(sasValue, sas, 5);\n\n\tbzrtp_message(\"Alice SAS is %.4s\\n\", sas);\n\n\tsasValue = ((uint32_t)bob_sasHash[0]<<24) | ((uint32_t)bob_sasHash[1]<<16) | ((uint32_t)bob_sasHash[2]<<8) | ((uint32_t)(bob_sasHash[3]));\n\tcontextBob->channelContext[0]->sasFunction(sasValue, sas, 5);\n\n\tbzrtp_message(\"Bob SAS is %.4s\\n\", sas);\n\n\n\t/* now derive the other keys (mackeyi, mackeyr, zrtpkeyi and zrtpkeyr, srtpkeys and salt) */\n\tcontextAlice->channelContext[0]->mackeyi = (uint8_t *)malloc(contextAlice->channelContext[0]->hashLength*(sizeof(uint8_t)));\n\tcontextAlice->channelContext[0]->mackeyr = (uint8_t *)malloc(contextAlice->channelContext[0]->hashLength*(sizeof(uint8_t)));\n\tcontextAlice->channelContext[0]->zrtpkeyi = (uint8_t *)malloc(contextAlice->channelContext[0]->cipherKeyLength*(sizeof(uint8_t)));\n\tcontextAlice->channelContext[0]->zrtpkeyr = (uint8_t *)malloc(contextAlice->channelContext[0]->cipherKeyLength*(sizeof(uint8_t)));\n\tcontextBob->channelContext[0]->mackeyi = (uint8_t *)malloc(contextBob->channelContext[0]->hashLength*(sizeof(uint8_t)));\n\tcontextBob->channelContext[0]->mackeyr = (uint8_t *)malloc(contextBob->channelContext[0]->hashLength*(sizeof(uint8_t)));\n\tcontextBob->channelContext[0]->zrtpkeyi = (uint8_t *)malloc(contextBob->channelContext[0]->cipherKeyLength*(sizeof(uint8_t)));\n\tcontextBob->channelContext[0]->zrtpkeyr = (uint8_t *)malloc(contextBob->channelContext[0]->cipherKeyLength*(sizeof(uint8_t)));\n\n\t/* Alice */\n\tretval = bzrtp_keyDerivationFunction(contextAlice->channelContext[0]->s0, contextAlice->channelContext[0]->hashLength, (uint8_t *)\"Initiator HMAC key\", 18, contextAlice->channelContext[0]->KDFContext, contextAlice->channelContext[0]->KDFContextLength, contextAlice->channelContext[0]->hashLength, (void (*)(uint8_t *, uint8_t,  uint8_t *, uint32_t,  uint8_t,  uint8_t *))contextAlice->channelContext[0]->hmacFunction, contextAlice->channelContext[0]->mackeyi);\n\tretval += bzrtp_keyDerivationFunction(contextAlice->channelContext[0]->s0, contextAlice->channelContext[0]->hashLength, (uint8_t *)\"Responder HMAC key\", 18, contextAlice->channelContext[0]->KDFContext, contextAlice->channelContext[0]->KDFContextLength, contextAlice->channelContext[0]->hashLength, (void (*)(uint8_t *, uint8_t,  uint8_t *, uint32_t,  uint8_t,  uint8_t *))contextAlice->channelContext[0]->hmacFunction, contextAlice->channelContext[0]->mackeyr);\n\tretval += bzrtp_keyDerivationFunction(contextAlice->channelContext[0]->s0, contextAlice->channelContext[0]->hashLength, (uint8_t *)\"Initiator ZRTP key\", 18, contextAlice->channelContext[0]->KDFContext, contextAlice->channelContext[0]->KDFContextLength, contextAlice->channelContext[0]->cipherKeyLength, (void (*)(uint8_t *, uint8_t,  uint8_t *, uint32_t,  uint8_t,  uint8_t *))contextAlice->channelContext[0]->hmacFunction, contextAlice->channelContext[0]->zrtpkeyi);\n\tretval += bzrtp_keyDerivationFunction(contextAlice->channelContext[0]->s0, contextAlice->channelContext[0]->hashLength, (uint8_t *)\"Responder ZRTP key\", 18, contextAlice->channelContext[0]->KDFContext, contextAlice->channelContext[0]->KDFContextLength, contextAlice->channelContext[0]->cipherKeyLength, (void (*)(uint8_t *, uint8_t,  uint8_t *, uint32_t,  uint8_t,  uint8_t *))contextAlice->channelContext[0]->hmacFunction, contextAlice->channelContext[0]->zrtpkeyr);\n\n\t/* Bob */\n\tretval = bzrtp_keyDerivationFunction(contextBob->channelContext[0]->s0, contextBob->channelContext[0]->hashLength, (uint8_t *)\"Initiator HMAC key\", 18, contextBob->channelContext[0]->KDFContext, contextBob->channelContext[0]->KDFContextLength, contextBob->channelContext[0]->hashLength, (void (*)(uint8_t *, uint8_t,  uint8_t *, uint32_t,  uint8_t,  uint8_t *))contextBob->channelContext[0]->hmacFunction, contextBob->channelContext[0]->mackeyi);\n\tretval += bzrtp_keyDerivationFunction(contextBob->channelContext[0]->s0, contextBob->channelContext[0]->hashLength, (uint8_t *)\"Responder HMAC key\", 18, contextBob->channelContext[0]->KDFContext, contextBob->channelContext[0]->KDFContextLength, contextBob->channelContext[0]->hashLength, (void (*)(uint8_t *, uint8_t,  uint8_t *, uint32_t,  uint8_t,  uint8_t *))contextBob->channelContext[0]->hmacFunction, contextBob->channelContext[0]->mackeyr);\n\tretval += bzrtp_keyDerivationFunction(contextBob->channelContext[0]->s0, contextBob->channelContext[0]->hashLength, (uint8_t *)\"Initiator ZRTP key\", 18, contextBob->channelContext[0]->KDFContext, contextBob->channelContext[0]->KDFContextLength, contextBob->channelContext[0]->cipherKeyLength, (void (*)(uint8_t *, uint8_t,  uint8_t *, uint32_t,  uint8_t,  uint8_t *))contextBob->channelContext[0]->hmacFunction, contextBob->channelContext[0]->zrtpkeyi);\n\tretval += bzrtp_keyDerivationFunction(contextBob->channelContext[0]->s0, contextBob->channelContext[0]->hashLength, (uint8_t *)\"Responder ZRTP key\", 18, contextBob->channelContext[0]->KDFContext, contextBob->channelContext[0]->KDFContextLength, contextBob->channelContext[0]->cipherKeyLength, (void (*)(uint8_t *, uint8_t,  uint8_t *, uint32_t,  uint8_t,  uint8_t *))contextBob->channelContext[0]->hmacFunction, contextBob->channelContext[0]->zrtpkeyr);\n\n\n\t/* DEBUG compare keys */\n\tif ((memcmp(contextAlice->channelContext[0]->mackeyi, contextBob->channelContext[0]->mackeyi, contextAlice->channelContext[0]->hashLength)==0) && (memcmp(contextAlice->channelContext[0]->mackeyr, contextBob->channelContext[0]->mackeyr, contextAlice->channelContext[0]->hashLength)==0) && (memcmp(contextAlice->channelContext[0]->zrtpkeyi, contextBob->channelContext[0]->zrtpkeyi, contextAlice->channelContext[0]->cipherKeyLength)==0) && (memcmp(contextAlice->channelContext[0]->zrtpkeyr, contextBob->channelContext[0]->zrtpkeyr, contextAlice->channelContext[0]->cipherKeyLength)==0)) {\n\t\tbzrtp_message(\"Got the same keys\\n\");\n\t\tCU_PASS(\"keys match\");\n\t} else {\n\t\tbzrtp_message(\"ERROR keys differ\\n\");\n\t\tCU_PASS(\"Keys mismatch\");\n\t}\n\n\t/* now Bob build the CONFIRM1 packet and send it to Alice */\n\tbob_Confirm1 = bzrtp_createZrtpPacket(contextBob, contextBob->channelContext[0], MSGTYPE_CONFIRM1, &retval);\n\tretval += bzrtp_packetBuild(contextBob, contextBob->channelContext[0], bob_Confirm1, contextBob->channelContext[0]->selfSequenceNumber);\n\tif (retval == 0) {\n\t\tcontextBob->channelContext[0]->selfSequenceNumber++;\n\t}\n\tbzrtp_message(\"Bob building Confirm1 return %x\\n\", retval);\n\n\talice_Confirm1FromBob = bzrtp_packetCheck(bob_Confirm1->packetString, bob_Confirm1->messageLength+16, contextAlice->channelContext[0]->peerSequenceNumber, &retval);\n\tretval += bzrtp_packetParser(contextAlice, contextAlice->channelContext[0], bob_Confirm1->packetString, bob_Confirm1->messageLength+16, alice_Confirm1FromBob);\n\tbzrtp_message (\"Alice parsing confirm1 returns %x\\n\", retval);\n\tif (retval==0) {\n\t\t/* update context with the information found in the packet */\n\t\tcontextAlice->channelContext[0]->peerSequenceNumber = alice_Confirm1FromBob->sequenceNumber;\n\t\talice_Confirm1FromBob_message = (bzrtpConfirmMessage_t *)alice_Confirm1FromBob->messageData;\n\t\tmemcpy(contextAlice->channelContext[0]->peerH[0], alice_Confirm1FromBob_message->H0, 32);\n\t}\n\n\tpacketDump(bob_Confirm1,1);\n\tpacketDump(alice_Confirm1FromBob,0);\n\n\tbzrtp_freeZrtpPacket(alice_Confirm1FromBob);\n\tbzrtp_freeZrtpPacket(bob_Confirm1);\n\n\t/* now Alice build the CONFIRM2 packet and send it to Bob */\n\talice_Confirm2 = bzrtp_createZrtpPacket(contextAlice, contextAlice->channelContext[0], MSGTYPE_CONFIRM2, &retval);\n\tretval += bzrtp_packetBuild(contextAlice, contextAlice->channelContext[0], alice_Confirm2, contextAlice->channelContext[0]->selfSequenceNumber);\n\tif (retval == 0) {\n\t\tcontextAlice->channelContext[0]->selfSequenceNumber++;\n\t}\n\tbzrtp_message(\"Alice building Confirm2 return %x\\n\", retval);\n\n\tbob_Confirm2FromAlice = bzrtp_packetCheck(alice_Confirm2->packetString, alice_Confirm2->messageLength+16, contextBob->channelContext[0]->peerSequenceNumber, &retval);\n\tretval += bzrtp_packetParser(contextBob, contextBob->channelContext[0], alice_Confirm2->packetString, alice_Confirm2->messageLength+16, bob_Confirm2FromAlice);\n\tbzrtp_message (\"Bob parsing confirm2 returns %x\\n\", retval);\n\tif (retval==0) {\n\t\t/* update context with the information found in the packet */\n\t\tcontextBob->channelContext[0]->peerSequenceNumber = bob_Confirm2FromAlice->sequenceNumber;\n\t\tbob_Confirm2FromAlice_message = (bzrtpConfirmMessage_t *)bob_Confirm2FromAlice->messageData;\n\t\tmemcpy(contextBob->channelContext[0]->peerH[0], bob_Confirm2FromAlice_message->H0, 32);\n\t\t/* set bob's status to secure */\n\t\tcontextBob->isSecure = 1;\n\t}\n\n\tpacketDump(alice_Confirm2,1);\n\tpacketDump(bob_Confirm2FromAlice,0);\n\n\tbzrtp_freeZrtpPacket(bob_Confirm2FromAlice);\n\tbzrtp_freeZrtpPacket(alice_Confirm2);\n\n\t/* Bob build the conf2Ack and send it to Alice */\n\tbob_Conf2ACK =  bzrtp_createZrtpPacket(contextBob, contextBob->channelContext[0], MSGTYPE_CONF2ACK, &retval);\n\tretval += bzrtp_packetBuild(contextBob, contextBob->channelContext[0], bob_Conf2ACK, contextBob->channelContext[0]->selfSequenceNumber);\n\tif (retval == 0) {\n\t\tcontextBob->channelContext[0]->selfSequenceNumber++;\n\t}\n\tbzrtp_message(\"Bob building Conf2ACK return %x\\n\", retval);\n\n\talice_Conf2ACKFromBob = bzrtp_packetCheck(bob_Conf2ACK->packetString, bob_Conf2ACK->messageLength+16, contextAlice->channelContext[0]->peerSequenceNumber, &retval);\n\tretval += bzrtp_packetParser(contextAlice, contextAlice->channelContext[0], bob_Conf2ACK->packetString, bob_Conf2ACK->messageLength+16, alice_Conf2ACKFromBob);\n\tbzrtp_message (\"Alice parsing conf2ACK returns %x\\n\", retval);\n\tif (retval==0) {\n\t\t/* update context with the information found in the packet */\n\t\tcontextAlice->channelContext[0]->peerSequenceNumber = alice_Conf2ACKFromBob->sequenceNumber;\n\t\t/* set Alice's status to secure */\n\t\tcontextAlice->isSecure = 1;\n\t}\n\n\tbzrtp_freeZrtpPacket(bob_Conf2ACK);\n\tbzrtp_freeZrtpPacket(alice_Conf2ACKFromBob);\n\n\tdumpContext(\"Alice\", contextAlice);\n\tdumpContext(\"Bob\", contextBob);\n\n\tbzrtp_message(\"\\n\\n\\n\\n\\n*************************************************************\\n        SECOND CHANNEL\\n**********************************************\\n\\n\");\n\t/* Now create a second channel for Bob and Alice */\n\tretval = bzrtp_addChannel(contextAlice, 0x45678901);\n\tbzrtp_message(\"Add channel to Alice's context returns %d\\n\", retval);\n\tretval = bzrtp_addChannel(contextBob, 0x54321098);\n\tbzrtp_message(\"Add channel to Bob's context returns %d\\n\", retval);\n\n\t/* create hello packets for this channel */\n\talice_Hello = bzrtp_createZrtpPacket(contextAlice, contextAlice->channelContext[1], MSGTYPE_HELLO, &retval);\n\tif (bzrtp_packetBuild(contextAlice, contextAlice->channelContext[1], alice_Hello, contextAlice->channelContext[1]->selfSequenceNumber) ==0) {\n\t\tcontextAlice->channelContext[1]->selfSequenceNumber++;\n\t\tcontextAlice->channelContext[1]->selfPackets[HELLO_MESSAGE_STORE_ID] = alice_Hello;\n\t}\n\tbob_Hello = bzrtp_createZrtpPacket(contextBob, contextBob->channelContext[1], MSGTYPE_HELLO, &retval);\n\tif (bzrtp_packetBuild(contextBob, contextBob->channelContext[1], bob_Hello, contextBob->channelContext[1]->selfSequenceNumber) ==0) {\n\t\tcontextBob->channelContext[1]->selfSequenceNumber++;\n\t\tcontextBob->channelContext[1]->selfPackets[HELLO_MESSAGE_STORE_ID] = bob_Hello;\n\t}\n\n\t/* now send Alice Hello's to Bob and vice-versa, so they parse them */\n\talice_HelloFromBob = bzrtp_packetCheck(bob_Hello->packetString, bob_Hello->messageLength+16, contextAlice->channelContext[1]->peerSequenceNumber, &retval);\n\tretval +=  bzrtp_packetParser(contextAlice, contextAlice->channelContext[0], bob_Hello->packetString, bob_Hello->messageLength+16, alice_HelloFromBob);\n\tbzrtp_message (\"Alice parsing returns %x\\n\", retval);\n\tif (retval==0) {\n\t\tbzrtpHelloMessage_t *alice_HelloFromBob_message;\n\t\tint i;\n\t\tuint8_t checkPeerSupportMultiChannel = 0;\n\n\t\tcontextAlice->channelContext[1]->peerSequenceNumber = alice_HelloFromBob->sequenceNumber;\n\t\t/* save bob's Hello packet in Alice's context */\n\t\tcontextAlice->channelContext[1]->peerPackets[HELLO_MESSAGE_STORE_ID] = alice_HelloFromBob;\n\n\t\t/* we are already secured (shall check isSecure==1), so we just need to check that peer Hello have the Mult in his key agreement list of supported algo */\n\t\talice_HelloFromBob_message = (bzrtpHelloMessage_t *)alice_HelloFromBob->messageData;\n\t\tfor (i=0; i<alice_HelloFromBob_message->kc; i++) {\n\t\t\tif (alice_HelloFromBob_message->supportedKeyAgreement[i] == ZRTP_KEYAGREEMENT_Mult) {\n\t\t\t\tcheckPeerSupportMultiChannel = 1;\n\t\t\t}\n\t\t}\n\n\t\t/* ok multi channel is supported*/\n\t\tif (checkPeerSupportMultiChannel == 1) {\n\t\t\tbzrtp_message(\"Alice found that Bob supports multi channel\\n\");\n\t\t\t/* now set the choosen algos, they MUST be the same than main channel (channel 0) except for keyAgreement which is set to mult */\n\t\t\tcontextAlice->channelContext[1]->hashAlgo = contextAlice->channelContext[0]->hashAlgo;\n\t\t\tcontextAlice->channelContext[1]->hashLength = contextAlice->channelContext[0]->hashLength;\n\t\t\tcontextAlice->channelContext[1]->cipherAlgo = contextAlice->channelContext[0]->cipherAlgo;\n\t\t\tcontextAlice->channelContext[1]->cipherKeyLength = contextAlice->channelContext[0]->cipherKeyLength;\n\t\t\tcontextAlice->channelContext[1]->authTagAlgo = contextAlice->channelContext[0]->authTagAlgo;\n\t\t\tcontextAlice->channelContext[1]->sasAlgo = contextAlice->channelContext[0]->sasAlgo;\n\t\t\tcontextAlice->channelContext[1]->keyAgreementAlgo = ZRTP_KEYAGREEMENT_Mult;\n\t\t\tcontextAlice->channelContext[1]->keyAgreementLength = 0; /* no public values exchanged in Multi channel mode */\n\n\t\t\tupdateCryptoFunctionPointers(contextAlice->channelContext[1]);\n\t\t} else {\n\t\t\tbzrtp_message(\"ERROR : Alice found that Bob doesn't support multi channel\\n\");\n\t\t}\n\n\t}\n\n\tbob_HelloFromAlice = bzrtp_packetCheck(alice_Hello->packetString, alice_Hello->messageLength+16, contextBob->channelContext[1]->peerSequenceNumber, &retval);\n\tretval +=  bzrtp_packetParser(contextBob, contextBob->channelContext[1], alice_Hello->packetString, alice_Hello->messageLength+16, bob_HelloFromAlice);\n\tbzrtp_message (\"Bob parsing returns %x\\n\", retval);\n\tif (retval==0) {\n\t\tbzrtpHelloMessage_t *bob_HelloFromAlice_message;\n\t\tint i;\n\t\tuint8_t checkPeerSupportMultiChannel = 0;\n\n\t\tcontextBob->channelContext[1]->peerSequenceNumber = bob_HelloFromAlice->sequenceNumber;\n\t\t/* save alice's Hello packet in bob's context */\n\t\tcontextBob->channelContext[1]->peerPackets[HELLO_MESSAGE_STORE_ID] = bob_HelloFromAlice;\n\n\t\t/* we are already secured (shall check isSecure==1), so we just need to check that peer Hello have the Mult in his key agreement list of supported algo */\n\t\tbob_HelloFromAlice_message = (bzrtpHelloMessage_t *)bob_HelloFromAlice->messageData;\n\t\tfor (i=0; i<bob_HelloFromAlice_message->kc; i++) {\n\t\t\tif (bob_HelloFromAlice_message->supportedKeyAgreement[i] == ZRTP_KEYAGREEMENT_Mult) {\n\t\t\t\tcheckPeerSupportMultiChannel = 1;\n\t\t\t}\n\t\t}\n\n\t\t/* ok multi channel is supported*/\n\t\tif (checkPeerSupportMultiChannel == 1) {\n\t\t\tbzrtp_message(\"Bob found that Alice supports multi channel\\n\");\n\t\t\t/* now set the choosen algos, they MUST be the same than main channel (channel 0) except for keyAgreement which is set to mult */\n\t\t\tcontextBob->channelContext[1]->hashAlgo = contextBob->channelContext[0]->hashAlgo;\n\t\t\tcontextBob->channelContext[1]->hashLength = contextBob->channelContext[0]->hashLength;\n\t\t\tcontextBob->channelContext[1]->cipherAlgo = contextBob->channelContext[0]->cipherAlgo;\n\t\t\tcontextBob->channelContext[1]->cipherKeyLength = contextBob->channelContext[0]->cipherKeyLength;\n\t\t\tcontextBob->channelContext[1]->authTagAlgo = contextBob->channelContext[0]->authTagAlgo;\n\t\t\tcontextBob->channelContext[1]->sasAlgo = contextBob->channelContext[0]->sasAlgo;\n\t\t\tcontextBob->channelContext[1]->keyAgreementAlgo = ZRTP_KEYAGREEMENT_Mult;\n\t\t\tcontextBob->channelContext[1]->keyAgreementLength = 0; /* no public values exchanged in Multi channel mode */\n\n\t\t\tupdateCryptoFunctionPointers(contextBob->channelContext[1]);\n\t\t} else {\n\t\t\tbzrtp_message(\"ERROR : Bob found that Alice doesn't support multi channel\\n\");\n\t\t}\n\t}\n\n\t/* update context with hello message information : H3  and compute initiator and responder's shared secret Hashs */\n\talice_HelloFromBob_message = (bzrtpHelloMessage_t *)alice_HelloFromBob->messageData;\n\tmemcpy(contextAlice->channelContext[1]->peerH[3], alice_HelloFromBob_message->H3, 32);\n\tbob_HelloFromAlice_message = (bzrtpHelloMessage_t *)bob_HelloFromAlice->messageData;\n\tmemcpy(contextBob->channelContext[1]->peerH[3], bob_HelloFromAlice_message->H3, 32);\n\n\n\t/* here we shall exchange Hello ACK but it is just a test and was done already for channel 0, skip it as it is useless for the test */\n\n\t/* Bob will be the initiator, so compute a commit for him */\n\tbob_Commit = bzrtp_createZrtpPacket(contextBob, contextBob->channelContext[1], MSGTYPE_COMMIT, &retval);\n\tretval += bzrtp_packetBuild(contextBob, contextBob->channelContext[1], bob_Commit, contextBob->channelContext[1]->selfSequenceNumber);\n\tif (retval == 0) {\n\t\tcontextBob->channelContext[1]->selfSequenceNumber++;\n\t\tcontextBob->channelContext[1]->selfPackets[COMMIT_MESSAGE_STORE_ID] = bob_Commit;\n\t}\n\tbzrtp_message(\"Bob building Commit return %x\\n\", retval);\n\n\n\t/* and send it to Alice */\n\talice_CommitFromBob = bzrtp_packetCheck(bob_Commit->packetString, bob_Commit->messageLength+16, contextAlice->channelContext[1]->peerSequenceNumber, &retval);\n\tretval += bzrtp_packetParser(contextAlice, contextAlice->channelContext[1], bob_Commit->packetString, bob_Commit->messageLength+16, alice_CommitFromBob);\n\tbzrtp_message (\"Alice parsing Commit returns %x\\n\", retval);\n\tif (retval==0) {\n\t\tbzrtpCommitMessage_t *alice_CommitFromBob_message;\n\n\t\t/* update context with the information found in the packet */\n\t\tcontextAlice->channelContext[1]->peerSequenceNumber = alice_CommitFromBob->sequenceNumber;\n\t\t/* Alice will be the initiator (commit contention not implemented in this test) so just discard bob's commit */\n\t\talice_CommitFromBob_message = (bzrtpCommitMessage_t *)alice_CommitFromBob->messageData;\n\t\tmemcpy(contextAlice->channelContext[1]->peerH[2], alice_CommitFromBob_message->H2, 32);\n\t\tcontextAlice->channelContext[1]->peerPackets[COMMIT_MESSAGE_STORE_ID] = alice_CommitFromBob;\n\t}\n\tpacketDump(alice_CommitFromBob, 0);\n\n\t/* for test purpose define Alice as the responder */\n\tcontextAlice->channelContext[1]->role = RESPONDER;\n\n\t/* compute the total hash as in rfc section 4.4.3.2 total_hash = hash(Hello of responder || Commit) */\n\ttotalHashDataLength = alice_Hello->messageLength + bob_Commit->messageLength;\n\tdataToHash = (uint8_t *)malloc(totalHashDataLength*sizeof(uint8_t));\n\thashDataIndex = 0;\n\n\t/* get all data from Alice */\n\tmemcpy(dataToHash, contextAlice->channelContext[1]->selfPackets[HELLO_MESSAGE_STORE_ID]->packetString+ZRTP_PACKET_HEADER_LENGTH, contextAlice->channelContext[1]->selfPackets[HELLO_MESSAGE_STORE_ID]->messageLength);\n\thashDataIndex += contextAlice->channelContext[1]->selfPackets[HELLO_MESSAGE_STORE_ID]->messageLength;\n\tmemcpy(dataToHash+hashDataIndex, contextAlice->channelContext[1]->peerPackets[COMMIT_MESSAGE_STORE_ID]->packetString+ZRTP_PACKET_HEADER_LENGTH, contextAlice->channelContext[1]->peerPackets[COMMIT_MESSAGE_STORE_ID]->messageLength);\n\tcontextAlice->channelContext[1]->hashFunction(dataToHash, totalHashDataLength, 32, alice_totalHash);\n\n\t/* get all data from Bob */\n\thashDataIndex = 0;\n\tmemcpy(dataToHash, contextBob->channelContext[1]->peerPackets[HELLO_MESSAGE_STORE_ID]->packetString+ZRTP_PACKET_HEADER_LENGTH, contextBob->channelContext[1]->peerPackets[HELLO_MESSAGE_STORE_ID]->messageLength);\n\thashDataIndex += contextBob->channelContext[1]->peerPackets[HELLO_MESSAGE_STORE_ID]->messageLength;\n\tmemcpy(dataToHash+hashDataIndex, contextBob->channelContext[1]->selfPackets[COMMIT_MESSAGE_STORE_ID]->packetString+ZRTP_PACKET_HEADER_LENGTH, contextBob->channelContext[1]->selfPackets[COMMIT_MESSAGE_STORE_ID]->messageLength);\n\n\tcontextBob->channelContext[1]->hashFunction(dataToHash, totalHashDataLength, 32, bob_totalHash);\n\tif (memcmp(bob_totalHash, alice_totalHash, 32) == 0) {\n\t\tbzrtp_message(\"Got the same total hash\\n\");\n\t\tCU_PASS(\"Total Hash match\");\n\t} else {\n\t\tbzrtp_message(\"AARGG!! total hash mismatch\");\n\t\tCU_FAIL(\"Total Hash mismatch\");\n\t}\n\n\tfree(dataToHash);\n\n\n\t/* compute the KDF Context as in rfc section 4.4.3.2 KDF_Context = (ZIDi || ZIDr || total_hash) */\n\tcontextAlice->channelContext[1]->KDFContextLength = 24 + contextAlice->channelContext[1]->hashLength;\n\tcontextAlice->channelContext[1]->KDFContext = (uint8_t *)malloc(contextAlice->channelContext[1]->KDFContextLength*sizeof(uint8_t));\n\tmemcpy(contextAlice->channelContext[1]->KDFContext, contextAlice->peerZID, 12);\n\tmemcpy(contextAlice->channelContext[1]->KDFContext+12, contextAlice->selfZID, 12);\n\tmemcpy(contextAlice->channelContext[1]->KDFContext+24, alice_totalHash, contextAlice->channelContext[1]->hashLength);\n\n\tcontextBob->channelContext[1]->KDFContextLength = 24 + contextBob->channelContext[1]->hashLength;\n\tcontextBob->channelContext[1]->KDFContext = (uint8_t *)malloc(contextBob->channelContext[1]->KDFContextLength*sizeof(uint8_t));\n\tmemcpy(contextBob->channelContext[1]->KDFContext, contextBob->selfZID, 12);\n\tmemcpy(contextBob->channelContext[1]->KDFContext+12, contextBob->peerZID, 12);\n\tmemcpy(contextBob->channelContext[1]->KDFContext+24, bob_totalHash, contextBob->channelContext[1]->hashLength);\n\n\tif (memcmp(contextBob->channelContext[1]->KDFContext, contextAlice->channelContext[1]->KDFContext, 56) == 0) {\n\t\tbzrtp_message(\"Got the same total KDF Context\\n\");\n\t\tCU_PASS(\"KDFContext match\");\n\t} else {\n\t\tbzrtp_message(\"AARGG!! KDF Context mismatch\");\n\t\tCU_FAIL(\"KDF Context mismatch\");\n\t}\n\n\t/* compute s0 as in rfc section 4.4.3.2  s0 = KDF(ZRTPSess, \"ZRTP MSK\", KDF_Context, negotiated hash length) */\n\tcontextBob->channelContext[1]->s0 = (uint8_t *)malloc(contextBob->channelContext[1]->hashLength*sizeof(uint8_t));\n\tcontextAlice->channelContext[1]->s0 = (uint8_t *)malloc(contextAlice->channelContext[1]->hashLength*sizeof(uint8_t));\n\tretval = bzrtp_keyDerivationFunction(contextBob->ZRTPSess, contextBob->ZRTPSessLength,\n\t\t(uint8_t *)\"ZRTP MSK\", 8,\n\t\tcontextBob->channelContext[1]->KDFContext, contextBob->channelContext[1]->KDFContextLength, /* this one too depends on selected hash */\n\t\tcontextBob->channelContext[1]->hashLength,\n\t\t(void (*)(uint8_t *, uint8_t,  uint8_t *, uint32_t,  uint8_t,  uint8_t *))contextBob->channelContext[1]->hmacFunction,\n\t\tcontextBob->channelContext[1]->s0);\n\n\tretval = bzrtp_keyDerivationFunction(contextAlice->ZRTPSess, contextAlice->ZRTPSessLength,\n\t\t(uint8_t *)\"ZRTP MSK\", 8,\n\t\tcontextAlice->channelContext[1]->KDFContext, contextAlice->channelContext[1]->KDFContextLength, /* this one too depends on selected hash */\n\t\tcontextAlice->channelContext[1]->hashLength,\n\t\t(void (*)(uint8_t *, uint8_t,  uint8_t *, uint32_t,  uint8_t,  uint8_t *))contextAlice->channelContext[1]->hmacFunction,\n\t\tcontextAlice->channelContext[1]->s0);\n\n\tif (memcmp(contextBob->channelContext[1]->s0, contextAlice->channelContext[1]->s0, contextAlice->channelContext[1]->hashLength) == 0) {\n\t\tbzrtp_message(\"Got the same s0\\n\");\n\t\tCU_PASS(\"s0 match\");\n\t} else {\n\t\tbzrtp_message(\"AARGG!! s0 mismatch\");\n\t\tCU_FAIL(\"s0 mismatch\");\n\t}\n\n\n\t/* the rest of key derivation is common to DH mode, no need to test it as it has been done before for channel 0 */\n\t/* we must anyway derive zrtp and mac key for initiator and responder in order to be able to build the confirm packets */\n\tcontextAlice->channelContext[1]->mackeyi = (uint8_t *)malloc(contextAlice->channelContext[1]->hashLength*(sizeof(uint8_t)));\n\tcontextAlice->channelContext[1]->mackeyr = (uint8_t *)malloc(contextAlice->channelContext[1]->hashLength*(sizeof(uint8_t)));\n\tcontextAlice->channelContext[1]->zrtpkeyi = (uint8_t *)malloc(contextAlice->channelContext[1]->cipherKeyLength*(sizeof(uint8_t)));\n\tcontextAlice->channelContext[1]->zrtpkeyr = (uint8_t *)malloc(contextAlice->channelContext[1]->cipherKeyLength*(sizeof(uint8_t)));\n\tcontextBob->channelContext[1]->mackeyi = (uint8_t *)malloc(contextBob->channelContext[1]->hashLength*(sizeof(uint8_t)));\n\tcontextBob->channelContext[1]->mackeyr = (uint8_t *)malloc(contextBob->channelContext[1]->hashLength*(sizeof(uint8_t)));\n\tcontextBob->channelContext[1]->zrtpkeyi = (uint8_t *)malloc(contextBob->channelContext[1]->cipherKeyLength*(sizeof(uint8_t)));\n\tcontextBob->channelContext[1]->zrtpkeyr = (uint8_t *)malloc(contextBob->channelContext[1]->cipherKeyLength*(sizeof(uint8_t)));\n\n\t/* Alice */\n\tretval = bzrtp_keyDerivationFunction(contextAlice->channelContext[1]->s0, contextAlice->channelContext[1]->hashLength, (uint8_t *)\"Initiator HMAC key\", 18, contextAlice->channelContext[1]->KDFContext, contextAlice->channelContext[1]->KDFContextLength, contextAlice->channelContext[1]->hashLength, (void (*)(uint8_t *, uint8_t,  uint8_t *, uint32_t,  uint8_t,  uint8_t *))contextAlice->channelContext[1]->hmacFunction, contextAlice->channelContext[1]->mackeyi);\n\tretval += bzrtp_keyDerivationFunction(contextAlice->channelContext[1]->s0, contextAlice->channelContext[1]->hashLength, (uint8_t *)\"Responder HMAC key\", 18, contextAlice->channelContext[1]->KDFContext, contextAlice->channelContext[1]->KDFContextLength, contextAlice->channelContext[1]->hashLength, (void (*)(uint8_t *, uint8_t,  uint8_t *, uint32_t,  uint8_t,  uint8_t *))contextAlice->channelContext[1]->hmacFunction, contextAlice->channelContext[1]->mackeyr);\n\tretval += bzrtp_keyDerivationFunction(contextAlice->channelContext[1]->s0, contextAlice->channelContext[1]->hashLength, (uint8_t *)\"Initiator ZRTP key\", 18, contextAlice->channelContext[1]->KDFContext, contextAlice->channelContext[1]->KDFContextLength, contextAlice->channelContext[1]->cipherKeyLength, (void (*)(uint8_t *, uint8_t,  uint8_t *, uint32_t,  uint8_t,  uint8_t *))contextAlice->channelContext[1]->hmacFunction, contextAlice->channelContext[1]->zrtpkeyi);\n\tretval += bzrtp_keyDerivationFunction(contextAlice->channelContext[1]->s0, contextAlice->channelContext[1]->hashLength, (uint8_t *)\"Responder ZRTP key\", 18, contextAlice->channelContext[1]->KDFContext, contextAlice->channelContext[1]->KDFContextLength, contextAlice->channelContext[1]->cipherKeyLength, (void (*)(uint8_t *, uint8_t,  uint8_t *, uint32_t,  uint8_t,  uint8_t *))contextAlice->channelContext[1]->hmacFunction, contextAlice->channelContext[1]->zrtpkeyr);\n\n\t/* Bob */\n\tretval = bzrtp_keyDerivationFunction(contextBob->channelContext[1]->s0, contextBob->channelContext[1]->hashLength, (uint8_t *)\"Initiator HMAC key\", 18, contextBob->channelContext[1]->KDFContext, contextBob->channelContext[1]->KDFContextLength, contextBob->channelContext[1]->hashLength, (void (*)(uint8_t *, uint8_t,  uint8_t *, uint32_t,  uint8_t,  uint8_t *))contextBob->channelContext[1]->hmacFunction, contextBob->channelContext[1]->mackeyi);\n\tretval += bzrtp_keyDerivationFunction(contextBob->channelContext[1]->s0, contextBob->channelContext[1]->hashLength, (uint8_t *)\"Responder HMAC key\", 18, contextBob->channelContext[1]->KDFContext, contextBob->channelContext[1]->KDFContextLength, contextBob->channelContext[1]->hashLength, (void (*)(uint8_t *, uint8_t,  uint8_t *, uint32_t,  uint8_t,  uint8_t *))contextBob->channelContext[1]->hmacFunction, contextBob->channelContext[1]->mackeyr);\n\tretval += bzrtp_keyDerivationFunction(contextBob->channelContext[1]->s0, contextBob->channelContext[1]->hashLength, (uint8_t *)\"Initiator ZRTP key\", 18, contextBob->channelContext[1]->KDFContext, contextBob->channelContext[1]->KDFContextLength, contextBob->channelContext[1]->cipherKeyLength, (void (*)(uint8_t *, uint8_t,  uint8_t *, uint32_t,  uint8_t,  uint8_t *))contextBob->channelContext[1]->hmacFunction, contextBob->channelContext[1]->zrtpkeyi);\n\tretval += bzrtp_keyDerivationFunction(contextBob->channelContext[1]->s0, contextBob->channelContext[1]->hashLength, (uint8_t *)\"Responder ZRTP key\", 18, contextBob->channelContext[1]->KDFContext, contextBob->channelContext[1]->KDFContextLength, contextBob->channelContext[1]->cipherKeyLength, (void (*)(uint8_t *, uint8_t,  uint8_t *, uint32_t,  uint8_t,  uint8_t *))contextBob->channelContext[1]->hmacFunction, contextBob->channelContext[1]->zrtpkeyr);\n\n\t/* DEBUG compare keys */\n\tif ((memcmp(contextAlice->channelContext[1]->mackeyi, contextBob->channelContext[1]->mackeyi, contextAlice->channelContext[1]->hashLength)==0) && (memcmp(contextAlice->channelContext[1]->mackeyr, contextBob->channelContext[1]->mackeyr, contextAlice->channelContext[1]->hashLength)==0) && (memcmp(contextAlice->channelContext[1]->zrtpkeyi, contextBob->channelContext[1]->zrtpkeyi, contextAlice->channelContext[1]->cipherKeyLength)==0) && (memcmp(contextAlice->channelContext[1]->zrtpkeyr, contextBob->channelContext[1]->zrtpkeyr, contextAlice->channelContext[1]->cipherKeyLength)==0)) {\n\t\tbzrtp_message(\"Got the same keys\\n\");\n\t\tCU_PASS(\"keys match\");\n\t} else {\n\t\tbzrtp_message(\"ERROR keys differ\\n\");\n\t\tCU_PASS(\"Keys mismatch\");\n\t}\n\n\t/* now Alice build a confirm1 packet */\n\talice_Confirm1 = bzrtp_createZrtpPacket(contextAlice, contextAlice->channelContext[1], MSGTYPE_CONFIRM1, &retval);\n\tretval += bzrtp_packetBuild(contextAlice, contextAlice->channelContext[1], alice_Confirm1, contextAlice->channelContext[1]->selfSequenceNumber);\n\tif (retval == 0) {\n\t\tcontextAlice->channelContext[1]->selfSequenceNumber++;\n\t}\n\tbzrtp_message(\"Alice building Confirm1 return %x\\n\", retval);\n\n\tbob_Confirm1FromAlice = bzrtp_packetCheck(alice_Confirm1->packetString, alice_Confirm1->messageLength+16, contextBob->channelContext[1]->peerSequenceNumber, &retval);\n\tretval += bzrtp_packetParser(contextBob, contextBob->channelContext[1], alice_Confirm1->packetString, alice_Confirm1->messageLength+16, bob_Confirm1FromAlice);\n\tbzrtp_message (\"Bob parsing confirm1 returns %x\\n\", retval);\n\tif (retval==0) {\n\t\t/* update context with the information found in the packet */\n\t\tcontextBob->channelContext[1]->peerSequenceNumber = bob_Confirm1FromAlice->sequenceNumber;\n\t\tbob_Confirm1FromAlice_message = (bzrtpConfirmMessage_t *)bob_Confirm1FromAlice->messageData;\n\t\tmemcpy(contextBob->channelContext[1]->peerH[0], bob_Confirm1FromAlice_message->H0, 32);\n\t}\n\n\tpacketDump(bob_Confirm1FromAlice,0);\n\tbzrtp_freeZrtpPacket(bob_Confirm1FromAlice);\n\tbzrtp_freeZrtpPacket(alice_Confirm1);\n\n\t/* now Bob build the CONFIRM2 packet and send it to Alice */\n\tbob_Confirm2 = bzrtp_createZrtpPacket(contextBob, contextBob->channelContext[1], MSGTYPE_CONFIRM2, &retval);\n\tretval += bzrtp_packetBuild(contextBob, contextBob->channelContext[1], bob_Confirm2, contextBob->channelContext[1]->selfSequenceNumber);\n\tif (retval == 0) {\n\t\tcontextBob->channelContext[1]->selfSequenceNumber++;\n\t}\n\tbzrtp_message(\"Bob building Confirm2 return %x\\n\", retval);\n\talice_Confirm2FromBob = bzrtp_packetCheck(bob_Confirm2->packetString, bob_Confirm2->messageLength+16, contextAlice->channelContext[1]->peerSequenceNumber, &retval);\n\tretval += bzrtp_packetParser(contextAlice, contextAlice->channelContext[1], bob_Confirm2->packetString, bob_Confirm2->messageLength+16, alice_Confirm2FromBob);\n\tbzrtp_message (\"Alice parsing confirm2 returns %x\\n\", retval);\n\tif (retval==0) {\n\t\t/* update context with the information found in the packet */\n\t\tcontextAlice->channelContext[1]->peerSequenceNumber = alice_Confirm2FromBob->sequenceNumber;\n\t\talice_Confirm2FromBob_message = (bzrtpConfirmMessage_t *)alice_Confirm2FromBob->messageData;\n\t\tmemcpy(contextAlice->channelContext[1]->peerH[0], alice_Confirm2FromBob_message->H0, 32);\n\t}\n\n\tpacketDump(alice_Confirm2FromBob,0);\n\tbzrtp_freeZrtpPacket(alice_Confirm2FromBob);\n\tbzrtp_freeZrtpPacket(bob_Confirm2);\n\n\t/* Alice build the conf2Ack and send it to Bob */\n\talice_Conf2ACK =  bzrtp_createZrtpPacket(contextAlice, contextAlice->channelContext[1], MSGTYPE_CONF2ACK, &retval);\n\tretval += bzrtp_packetBuild(contextAlice, contextAlice->channelContext[1], alice_Conf2ACK, contextAlice->channelContext[1]->selfSequenceNumber);\n\tif (retval == 0) {\n\t\tcontextAlice->channelContext[1]->selfSequenceNumber++;\n\t}\n\tbzrtp_message(\"Alice building Conf2ACK return %x\\n\", retval);\n\n\tbob_Conf2ACKFromAlice = bzrtp_packetCheck(alice_Conf2ACK->packetString, alice_Conf2ACK->messageLength+16, contextBob->channelContext[1]->peerSequenceNumber, &retval);\n\tretval += bzrtp_packetParser(contextBob, contextBob->channelContext[1], alice_Conf2ACK->packetString, alice_Conf2ACK->messageLength+16, bob_Conf2ACKFromAlice);\n\tbzrtp_message (\"Bob parsing conf2ACK returns %x\\n\", retval);\n\tif (retval==0) {\n\t\t/* update context with the information found in the packet */\n\t\tcontextBob->channelContext[1]->peerSequenceNumber = bob_Conf2ACKFromAlice->sequenceNumber;\n\t}\n\n\n\tbzrtp_freeZrtpPacket(alice_Conf2ACK);\n\tbzrtp_freeZrtpPacket(bob_Conf2ACKFromAlice);\n\n\n\n\n\n/*\n\tdumpContext(\"\\nAlice\", contextAlice);\n\tdumpContext(\"\\nBob\", contextBob);\n*/\n\tbzrtp_message(\"Destroy the contexts\\n\");\n\t/* destroy the context */\n\tbzrtp_destroyBzrtpContext(contextAlice, 0x45678901);\n\tbzrtp_destroyBzrtpContext(contextBob, 0x54321098);\n\tbzrtp_message(\"Destroy the contexts last channel\\n\");\n\tbzrtp_destroyBzrtpContext(contextBob, 0x87654321);\n\tbzrtp_destroyBzrtpContext(contextAlice, 0x12345678);\n\n}\n\n\ntypedef struct packetDatas_struct {\n\tuint8_t packetString[1000];\n\tuint16_t packetLength;\n} packetDatas_t;\n\n/* Alice and Bob packet queues are globals */\npacketDatas_t aliceQueue[10];\npacketDatas_t bobQueue[10];\nuint8_t aliceQueueIndex = 0;\nuint8_t bobQueueIndex = 0;\n\nuint8_t block_Hello = 0;\n\n/* this is a callback function for send data, just dump the packet */\n/* client Data is a my_Context_t structure */\nint bzrtp_sendData(void *clientData, const uint8_t *packetString, uint16_t packetLength) {\n\t/* get the client Data */\n\tmy_Context_t *contexts = (my_Context_t *)clientData;\n\n/*\tbzrtp_message (\"%s sends a message!\\n\", contexts->nom);\n\tint retval;\n\tbzrtpPacket_t *zrtpPacket = bzrtp_packetCheck(packetString, packetLength, contexts->peerChannelContext->peerSequenceNumber, &retval);\n\tif (retval==0) {\n\t\tretval = bzrtp_packetParser(contexts->peerContext, contexts->peerChannelContext, packetString, packetLength, zrtpPacket);\n\t\tif (retval == 0) {\n*/\t\t/*\tpacketDump(zrtpPacket,0); */\n\t\t/*\tprintHex(\"Data\", packetString, packetLength);*/\n/*\t\t} else {\n\t\t\tbzrtp_message(\"Parse says %04x\\n\", retval);\n\t\t}\n\t} else {\n\t\tbzrtp_message(\"Check says %04x\\n\", retval);\n\t}\n*/\n\t/* put the message in the message queue */\n\tif (contexts->nom[0] == 'A') { /* message sent by Alice, put it in Bob's queue */\n\t\t/* block the first Hello to force going through wait for hello state and check it is retransmitted */\n/*\t\tif ((block_Hello == 0) && (zrtpPacket->messageType == MSGTYPE_HELLO)) {\n\t\t\tblock_Hello = 1;\n\t\t} else {*/\n\t\t\tmemcpy(bobQueue[bobQueueIndex].packetString, packetString, packetLength);\n\t\t\tbobQueue[bobQueueIndex++].packetLength = packetLength;\n/*\t\t}*/\n\t} else {\n\t\tmemcpy(aliceQueue[aliceQueueIndex].packetString, packetString, packetLength);\n\t\taliceQueue[aliceQueueIndex++].packetLength = packetLength;\n\t}\n\n/*\tbzrtp_freeZrtpPacket(zrtpPacket); */\n\n\treturn 0;\n}\n\nuint64_t myCurrentTime = 0; /* we do not need a real time, start at 0 and increment it at each sleep */\nuint64_t getCurrentTimeInMs() {\n\treturn myCurrentTime;\n}\n\nstatic void sleepMs(int ms){\n#ifdef _WIN32\n\tSleep(ms);\n#else\n\tstruct timespec ts;\n\tts.tv_sec=0;\n\tts.tv_nsec=ms*1000000LL;\n\tnanosleep(&ts,NULL);\n#endif\n\tmyCurrentTime +=ms;\n}\n\n/* Ping message length is 24 bytes (already define in packetParser.c out of this scope) */\n#define ZRTP_PINGMESSAGE_FIXED_LENGTH 24\n\nvoid test_stateMachine() {\n\tint retval;\n\tmy_Context_t aliceClientData, bobClientData;\n\tuint64_t initialTime;\n\tuint8_t pingPacketString[ZRTP_PACKET_OVERHEAD+ZRTP_PINGMESSAGE_FIXED_LENGTH]; /* there is no builder for ping packet and it is 24 bytes long(12 bytes of message header, 12 of data + packet overhead*/\n\tuint32_t CRC;\n\tuint8_t *CRCbuffer;\n\tmy_Context_t aliceSecondChannelClientData, bobSecondChannelClientData;\n\tbzrtpCallbacks_t cbs={0} ;\n\n\t/* Create zrtp Context */\n\tbzrtpContext_t *contextAlice = bzrtp_createBzrtpContext(0x12345678); /* Alice's SSRC of main channel is 12345678 */\n\tbzrtpContext_t *contextBob = bzrtp_createBzrtpContext(0x87654321); /* Bob's SSRC of main channel is 87654321 */\n\n\t/* set the cache related callback functions */\n\tcbs.bzrtp_loadCache=floadAlice;\n\tcbs.bzrtp_writeCache=fwriteAlice;\n\tcbs.bzrtp_sendData=bzrtp_sendData;\n\tbzrtp_setCallbacks(contextAlice, &cbs);\n\n\tcbs.bzrtp_loadCache=floadBob;\n\tcbs.bzrtp_writeCache=fwriteBob;\n\tcbs.bzrtp_sendData=bzrtp_sendData;\n\tbzrtp_setCallbacks(contextBob, &cbs);\n\n\t/* create the client Data and associate them to the channel contexts */\n\tmemcpy(aliceClientData.nom, \"Alice\", 6);\n\tmemcpy(bobClientData.nom, \"Bob\", 4);\n\taliceClientData.peerContext = contextBob;\n\taliceClientData.peerChannelContext = contextBob->channelContext[0];\n\tbobClientData.peerContext = contextAlice;\n\tbobClientData.peerChannelContext = contextAlice->channelContext[0];\n\tstrcpy(aliceClientData.zidFilename, \"./ZIDAlice.txt\");\n\tstrcpy(bobClientData.zidFilename, \"./ZIDBob.txt\");\n\n\n\tretval = bzrtp_setClientData(contextAlice, 0x12345678, (void *)&aliceClientData);\n\tretval += bzrtp_setClientData(contextBob, 0x87654321, (void *)&bobClientData);\n\tbzrtp_message(\"Set client data return %x\\n\", retval);\n\n\t/* run the init */\n\tbzrtp_initBzrtpContext(contextAlice);\n\tbzrtp_initBzrtpContext(contextBob);\n\n\t/* now start the engine */\n\tinitialTime = getCurrentTimeInMs();\n\tretval = bzrtp_startChannelEngine(contextAlice, 0x12345678);\n\tbzrtp_message (\"Alice starts return %x\\n\", retval);\n\tretval = bzrtp_startChannelEngine(contextBob, 0x87654321);\n\tbzrtp_message (\"Bob starts return %x\\n\", retval);\n\n\t/* now start infinite loop until we reach secure state */\n\twhile ((contextAlice->isSecure == 0 || contextBob->isSecure == 0) && (getCurrentTimeInMs()-initialTime<5000)){\n\t\tint i;\n\t\t/* first check the message queue */\n\t\tfor (i=0; i<aliceQueueIndex; i++) {\n\t\t\tbzrtp_message(\"Process a message for Alice\\n\");\n\t\t\tretval = bzrtp_processMessage(contextAlice, 0x12345678, aliceQueue[i].packetString, aliceQueue[i].packetLength);\n\t\t\tbzrtp_message(\"Alice processed message %.8s of %d bytes and return %04x\\n\\n\", aliceQueue[i].packetString+16, aliceQueue[i].packetLength, retval);\n\t\t\tmemset(aliceQueue[i].packetString, 0, 1000); /* destroy the packet after sending it to the ZRTP engine */\n\t\t}\n\t\taliceQueueIndex = 0;\n\n\t\tfor (i=0; i<bobQueueIndex; i++) {\n\t\t\tbzrtp_message(\"Process a message for Bob\\n\");\n\t\t\tretval = bzrtp_processMessage(contextBob, 0x87654321, bobQueue[i].packetString, bobQueue[i].packetLength);\n\t\t\tbzrtp_message(\"Bob processed message %.8s of %d bytes and return %04x\\n\\n\", bobQueue[i].packetString+16, bobQueue[i].packetLength, retval);\n\t\t\tmemset(bobQueue[i].packetString, 0, 1000); /* destroy the packet after sending it to the ZRTP engine */\n\t\t}\n\t\tbobQueueIndex = 0;\n\n\n\t\t/* send the actual time to the zrtpContext */\n\t\tbzrtp_iterate(contextAlice, 0x12345678, getCurrentTimeInMs());\n\t\tbzrtp_iterate(contextBob, 0x87654321, getCurrentTimeInMs());\n\n\t\t/* sleep for 10 ms */\n\t\tsleepMs(10);\n\t}\n\n\t/* compare SAS and check we are in secure mode */\n\tif ((contextAlice->isSecure == 1) && (contextBob->isSecure == 1)) { /* don't compare sas if we're not secure at we may not have it */\n\t\tCU_ASSERT_TRUE((memcmp(contextAlice->channelContext[0]->srtpSecrets.sas, contextBob->channelContext[0]->srtpSecrets.sas, 4) == 0));\n\t\t/* call the set verified Sas function */\n\t\tbzrtp_SASVerified(contextAlice);\n\t\tbzrtp_SASVerified(contextBob);\n\t} else {\n\t\tCU_FAIL(\"Unable to reach secure state\");\n\t}\n\n\t/*** Send alice a ping message from Bob ***/\n\t/* set packet header and CRC */\n\t/* preambule */\n\tpingPacketString[0] = 0x10;\n\tpingPacketString[1] = 0x00;\n\t/* Sequence number */\n\tpingPacketString[2] = (uint8_t)((contextBob->channelContext[0]->selfSequenceNumber>>8)&0x00FF);\n\tpingPacketString[3] = (uint8_t)(contextBob->channelContext[0]->selfSequenceNumber&0x00FF);\n\t/* ZRTP magic cookie */\n\tpingPacketString[4] = (uint8_t)((ZRTP_MAGIC_COOKIE>>24)&0xFF);\n\tpingPacketString[5] = (uint8_t)((ZRTP_MAGIC_COOKIE>>16)&0xFF);\n\tpingPacketString[6] = (uint8_t)((ZRTP_MAGIC_COOKIE>>8)&0xFF);\n\tpingPacketString[7] = (uint8_t)(ZRTP_MAGIC_COOKIE&0xFF);\n\t/* Source Identifier : insert bob's one: 0x87654321 */\n\tpingPacketString[8] = 0x87;\n\tpingPacketString[9] = 0x65;\n\tpingPacketString[10] = 0x43;\n\tpingPacketString[11] = 0x21;\n\n\t/* message header */\n\tpingPacketString[12] = 0x50;\n\tpingPacketString[13] = 0x5a;\n\n\t/* length in 32 bits words */\n\tpingPacketString[14] = 0x00;\n\tpingPacketString[15] = 0x06;\n\n\t/* message type \"Ping    \" */\n\tmemcpy(pingPacketString+16, \"Ping    \",8);\n\n\t/* Version on 4 bytes is \"1.10\" */\n\tmemcpy(pingPacketString+24, \"1.10\", 4);\n\n\t/* a endPointHash, use the first 8 bytes of Bob's ZID */\n\tmemcpy(pingPacketString+28, contextBob->selfZID, 8);\n\n\t/* CRC */\n\tCRC = bzrtp_CRC32(pingPacketString, ZRTP_PINGMESSAGE_FIXED_LENGTH+ZRTP_PACKET_HEADER_LENGTH);\n\tCRCbuffer = pingPacketString+ZRTP_PINGMESSAGE_FIXED_LENGTH+ZRTP_PACKET_HEADER_LENGTH;\n\t*CRCbuffer = (uint8_t)((CRC>>24)&0xFF);\n\tCRCbuffer++;\n\t*CRCbuffer = (uint8_t)((CRC>>16)&0xFF);\n\tCRCbuffer++;\n\t*CRCbuffer = (uint8_t)((CRC>>8)&0xFF);\n\tCRCbuffer++;\n\t*CRCbuffer = (uint8_t)(CRC&0xFF);\n\n\tbzrtp_message(\"Process a PING message for Alice\\n\");\n\tretval = bzrtp_processMessage(contextAlice, 0x12345678, pingPacketString, ZRTP_PACKET_OVERHEAD+ZRTP_PINGMESSAGE_FIXED_LENGTH);\n\tbzrtp_message(\"Alice processed PING message and return %04x\\n\\n\", retval);\n\n\n\t/*** now add a second channel ***/\n\tretval = bzrtp_addChannel(contextAlice, 0x34567890);\n\tbzrtp_message(\"Add a channel to Alice context, return %x\\n\", retval);\n\tretval = bzrtp_addChannel(contextBob, 0x09876543);\n\tbzrtp_message(\"Add a channel to Bob context, return %x\\n\", retval);\n\n\t/* create the client Data and associate them to the channel contexts */\n\tmemcpy(aliceSecondChannelClientData.nom, \"Alice\", 6);\n\tmemcpy(bobSecondChannelClientData.nom, \"Bob\", 4);\n\taliceSecondChannelClientData.peerContext = contextBob;\n\taliceSecondChannelClientData.peerChannelContext = contextBob->channelContext[1];\n\tbobSecondChannelClientData.peerContext = contextAlice;\n\tbobSecondChannelClientData.peerChannelContext = contextAlice->channelContext[1];\n\n\tretval = bzrtp_setClientData(contextAlice, 0x34567890, (void *)&aliceSecondChannelClientData);\n\tretval += bzrtp_setClientData(contextBob, 0x09876543, (void *)&bobSecondChannelClientData);\n\tbzrtp_message(\"Set client data return %x\\n\", retval);\n\n\t/* start the channels */\n\tretval = bzrtp_startChannelEngine(contextAlice, 0x34567890);\n\tbzrtp_message (\"Alice starts return %x\\n\", retval);\n\tretval = bzrtp_startChannelEngine(contextBob, 0x09876543);\n\tbzrtp_message (\"Bob starts return %x\\n\", retval);\n\n\t/* now start infinite loop until we reach secure state */\n\twhile ((getCurrentTimeInMs()-initialTime<2000)){\n\t\tint i;\n\t\t/* first check the message queue */\n\t\tfor (i=0; i<aliceQueueIndex; i++) {\n\t\t\tbzrtp_message(\"Process a message for Alice\\n\");\n\t\t\tretval = bzrtp_processMessage(contextAlice, 0x34567890, aliceQueue[i].packetString, aliceQueue[i].packetLength);\n\t\t\tbzrtp_message(\"Alice processed message %.8s of %d bytes and return %04x\\n\\n\", aliceQueue[i].packetString+16, aliceQueue[i].packetLength, retval);\n\t\t\tmemset(aliceQueue[i].packetString, 0, 1000); /* destroy the packet after sending it to the ZRTP engine */\n\t\t}\n\t\taliceQueueIndex = 0;\n\n\t\tfor (i=0; i<bobQueueIndex; i++) {\n\t\t\tbzrtp_message(\"Process a message for Bob\\n\");\n\t\t\tretval = bzrtp_processMessage(contextBob, 0x09876543, bobQueue[i].packetString, bobQueue[i].packetLength);\n\t\t\tbzrtp_message(\"Bob processed message %.8s  of %d bytes and return %04x\\n\\n\", bobQueue[i].packetString+16, bobQueue[i].packetLength, retval);\n\t\t\tmemset(bobQueue[i].packetString, 0, 1000); /* destroy the packet after sending it to the ZRTP engine */\n\t\t}\n\t\tbobQueueIndex = 0;\n\n\n\t\t/* send the actual time to the zrtpContext */\n\t\tbzrtp_iterate(contextAlice, 0x34567890, getCurrentTimeInMs());\n\t\tbzrtp_iterate(contextBob, 0x09876543, getCurrentTimeInMs());\n\n\n\t\t/* sleep for 10 ms */\n\t\tsleepMs(10);\n\t}\n\n\n\tCU_ASSERT_TRUE((memcmp(contextAlice->channelContext[1]->srtpSecrets.selfSrtpKey, contextBob->channelContext[1]->srtpSecrets.peerSrtpKey, 16) == 0) && (contextAlice->isSecure == 1) && (contextBob->isSecure == 1));\n\n\tdumpContext(\"\\nAlice\", contextAlice);\n\tdumpContext(\"\\nBob\", contextBob);\n\n\n\n\tbzrtp_message(\"Destroy the contexts\\n\");\n\t/* destroy the context */\n\tbzrtp_destroyBzrtpContext(contextAlice, 0x34567890);\n\tbzrtp_destroyBzrtpContext(contextBob, 0x09876543);\n\tbzrtp_message(\"Destroy the contexts last channel\\n\");\n\tbzrtp_destroyBzrtpContext(contextBob, 0x87654321);\n\tbzrtp_destroyBzrtpContext(contextAlice, 0x12345678);\n\n\n}\n", "/**\n @file bzrtpCryptoTests.h\n\n @author Johan Pascal\n\n @copyright Copyright (C) 2014 Belledonne Communications, Grenoble, France\n \n This program is free software; you can redistribute it and/or\n modify it under the terms of the GNU General Public License\n as published by the Free Software Foundation; either version 2\n of the License, or (at your option) any later version.\n \n This program is distributed in the hope that it will be useful,\n but WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n GNU General Public License for more details.\n \n You should have received a copy of the GNU General Public License\n along with this program; if not, write to the Free Software\n Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.\n */\nvoid test_parser(void);\nvoid test_parserComplete(void);\nvoid test_stateMachine(void);\n", "/**\n @file bzrtpTests.c\n\n @author Johan Pascal\n\n @copyright Copyright (C) 2014 Belledonne Communications, Grenoble, France\n \n This program is free software; you can redistribute it and/or\n modify it under the terms of the GNU General Public License\n as published by the Free Software Foundation; either version 2\n of the License, or (at your option) any later version.\n \n This program is distributed in the hope that it will be useful,\n but WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n GNU General Public License for more details.\n \n You should have received a copy of the GNU General Public License\n along with this program; if not, write to the Free Software\n Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.\n */\n\n#include <stdio.h>\n#include \"CUnit/Basic.h\"\n#include \"bzrtpCryptoTest.h\"\n#include \"bzrtpParserTest.h\"\n#include \"typedef.h\"\n#include \"testUtils.h\"\n\n#ifdef HAVE_LIBXML2\n#include <libxml/parser.h>\n#endif\n\t\n\nint main(int argc, char *argv[] ) {\n\tint i, fails_count=0;\n\tCU_pSuite cryptoUtilsTestSuite, parserTestSuite;\n\n\tCU_pSuite *suites[] = {\n\t\t&cryptoUtilsTestSuite,\n\t\t&parserTestSuite,\n\t\tNULL\n\t};\n\n\tif (argc>1) {\n\t\tif (argv[1][0] == '-') {\n\t\t\tif (strcmp(argv[1], \"-verbose\") == 0) {\n\t\t\t\tverbose = 1;\n\t\t\t} else {\n\t\t\t\tprintf (\"Usage:\\n %s [-verbose] to enable extensive logging\\n\", argv[0]);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t} else {\n\t\t\tprintf (\"Usage:\\n %s [-verbose] to enable extensive logging\\n\", argv[0]);\n\t\t\treturn 1;\n\t\t}\n\t}\n#ifdef HAVE_LIBXML2\n\txmlInitParser();\n#endif\n\t\n\t/* initialize the CUnit test registry */\n\tif (CUE_SUCCESS != CU_initialize_registry()) {\n\t\treturn CU_get_error();\n\t}\n\n\t/* Add the cryptoUtils suite to the registry */\n\tcryptoUtilsTestSuite = CU_add_suite(\"Bzrtp Crypto Utils\", NULL, NULL);\n\tCU_add_test(cryptoUtilsTestSuite, \"zrtpKDF\", test_zrtpKDF);\n\tCU_add_test(cryptoUtilsTestSuite, \"CRC32\", test_CRC32);\n\tCU_add_test(cryptoUtilsTestSuite, \"algo agreement\", test_algoAgreement);\n\tCU_add_test(cryptoUtilsTestSuite, \"context algo setter and getter\", test_algoSetterGetter);\n\tCU_add_test(cryptoUtilsTestSuite, \"adding mandatory crypto algorithms if needed\", test_addMandatoryCryptoTypesIfNeeded);\n\n\t/* Add the parser suite to the registry */\n\tparserTestSuite = CU_add_suite(\"Bzrtp ZRTP Packet Parser\", NULL, NULL);\n\tCU_add_test(parserTestSuite, \"Parse\", test_parser);\n\tCU_add_test(parserTestSuite, \"Parse Exchange\", test_parserComplete);\n\tCU_add_test(parserTestSuite, \"State machine\", test_stateMachine);\n\n\t/* Run all suites */\n\tfor(i=0; suites[i]; i++){\n\t\tCU_basic_run_suite(*suites[i]);\n\t\tfails_count += CU_get_number_of_tests_failed();\n\t}\n\t\n\t/* cleanup the CUnit registry */\n\tCU_cleanup_registry();\n\n#ifdef HAVE_LIBXML2\n\t/* cleanup libxml2 */\n\txmlCleanupParser();\n#endif\n\n\treturn (fails_count == 0 ? 0 : 1);\n}\n\n"], "fixing_code": ["/**\n @file packetParser.h\n\n @brief functions to parse and generate a ZRTP packet \n \n @author Johan Pascal\n\n @copyright Copyright (C) 2014 Belledonne Communications, Grenoble, France\n \n This program is free software; you can redistribute it and/or\n modify it under the terms of the GNU General Public License\n as published by the Free Software Foundation; either version 2\n of the License, or (at your option) any later version.\n \n This program is distributed in the hope that it will be useful,\n but WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n GNU General Public License for more details.\n \n You should have received a copy of the GNU General Public License\n along with this program; if not, write to the Free Software\n Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.\n */\n#ifndef PACKETPARSER_H\n#define PACKETPARSER_H\n\n#include <stdint.h>\n#include \"bzrtp/bzrtp.h\"\n\n/* header of ZRTP packet is 12 bytes : Preambule/Sequence Number + ZRTP Magic Cookie +  SSRC */\n#define ZRTP_PACKET_HEADER_LENGTH\t12\n#define ZRTP_PACKET_CRC_LENGTH\t\t4\n#define ZRTP_PACKET_OVERHEAD\t\t16\n\n#define\t\tBZRTP_PARSER_ERROR_INVALIDCRC  \t\t\t0xa001\n#define\t\tBZRTP_PARSER_ERROR_INVALIDPACKET\t\t0xa002\n#define\t\tBZRTP_PARSER_ERROR_OUTOFORDER\t\t\t0xa004\n#define\t\tBZRTP_PARSER_ERROR_INVALIDMESSAGE\t\t0xa008\n#define\t\tBZRTP_PARSER_ERROR_INVALIDCONTEXT\t\t0xa010\n#define\t\tBZRTP_PARSER_ERROR_UNMATCHINGCONFIRMMAC\t0xa020\n#define\t\tBZRTP_PARSER_ERROR_UNMATCHINGSSRC\t\t0xa040\n#define\t\tBZRTP_PARSER_ERROR_UNMATCHINGHASHCHAIN\t0xa080\n#define\t\tBZRTP_PARSER_ERROR_UNMATCHINGMAC\t\t0xa100\n#define\t\tBZRTP_PARSER_ERROR_UNEXPECTEDMESSAGE\t0xa200\n#define\t\tBZRTP_PARSER_ERROR_UNMATCHINGHVI\t\t0xa400\n\n#define\t\tBZRTP_BUILDER_ERROR_INVALIDPACKET\t\t0x5001\n#define\t\tBZRTP_BUILDER_ERROR_INVALIDMESSAGE\t\t0x5002\n#define\t\tBZRTP_BUILDER_ERROR_INVALIDMESSAGETYPE\t0x5004\n#define\t\tBZRTP_BUILDER_ERROR_UNKNOWN\t\t\t\t0x5008\n#define\t\tBZRTP_BUILDER_ERROR_INVALIDCONTEXT\t\t0x5010\n\n#define\t\tBZRTP_CREATE_ERROR_INVALIDMESSAGETYPE\t\t\t0x0a01\n#define\t\tBZRTP_CREATE_ERROR_UNABLETOCREATECRYPTOCONTEXT\t0x0a02\n#define\t\tBZRTP_CREATE_ERROR_INVALIDCONTEXT\t\t\t\t0x0a04\n\n/* map all message type to an uint8_t value */\n#define\t\tMSGTYPE_INVALID\t\t0x00\n#define\t\tMSGTYPE_HELLO\t\t0x01\n#define\t\tMSGTYPE_HELLOACK\t0x02\n#define\t\tMSGTYPE_COMMIT\t\t0x03\n#define\t\tMSGTYPE_DHPART1\t\t0x04\n#define\t\tMSGTYPE_DHPART2\t\t0x05\n#define\t\tMSGTYPE_CONFIRM1\t0x06\n#define\t\tMSGTYPE_CONFIRM2\t0x07\n#define\t\tMSGTYPE_CONF2ACK\t0x08\n#define\t\tMSGTYPE_ERROR\t\t0x10\n#define\t\tMSGTYPE_ERRORACK\t0x11\n#define\t\tMSGTYPE_GOCLEAR\t\t0x12\n#define\t\tMSGTYPE_CLEARACK\t0x13\n#define\t\tMSGTYPE_SASRELAY\t0x14\n#define\t\tMSGTYPE_RELAYACK\t0x15\n#define\t\tMSGTYPE_PING\t\t0x16\n#define\t\tMSGTYPE_PINGACK\t\t0x17\n\n/**\n * @brief Store all zrtpPacket informations\n * according to type a specific structure type is mapped to the void * data pointer\n */\ntypedef struct bzrtpPacket_struct {\n\tuint16_t sequenceNumber; /**< set by packet parser to enable caller to retrieve the packet sequence number. This field is not used buy the packet creator, sequence number is given as a parameter when converting the message to a packet string. Used only when parsing a string into a packet struct */\n\tuint32_t sourceIdentifier; /**< the SSRC of current RTP stream */\n\tuint8_t  messageType; /**< the ZRTP message type mapped from strings to hard defined byte */\n\tuint16_t messageLength; /**< the ZRTP message length in bytes - the message length indicated in the message itself is in 32 bits words. Is not the packet length(do not include packet header and CRC) */\n\tvoid *messageData; /**< a pointer to the structure containing all the message field according to message type */\n\tuint8_t *packetString; /**< used to stored the string version of the packet build from the message data or keep a string copy of received packets */\n} bzrtpPacket_t;\n\n/**\n * Structure definition for all zrtp message type according to rfc section 5.2 to 5.16\n *\n */\n\n/**\n * @brief Hello Message rfc 5.2\n */\ntypedef struct bzrtpHelloMessage_struct {\n\tuint8_t version[4]; /**< a string defining the current version, shall be 1.10 */\n\tuint8_t clientIdentifier[16]; /**< a string identifing the vendor and release of ZRTP software */\n\tuint8_t H3[32]; /**< the hash image H3 (256 bits) */\n\tuint8_t ZID[12]; /**< unique identifier for ZRTP endpoint (96 bits) */\n\tuint8_t\tS; /**< The signature-capable flag. If signatures are not supported, the (S) flag MUST be set to zero (1 bit) */\n\tuint8_t M; /**< The MiTM flag (M) is a Boolean that is set to true if and only if this Hello message is sent from a device, usually a PBX, that has the capability to send an SASrelay message (1 bit) **/\n\tuint8_t P; /**< The Passive flag (P) is a Boolean normally set to false, and is set to true if and only if this Hello message is sent from a device that is configured to never send a Commit message (Section 5.4).  This would mean it cannot initiate secure sessions, but may act as a responder. (1 bit) */\n\tuint8_t hc; /**< hash count -zrtpPacket set to 0 means we support only HMAC-SHA256 (4 bits) */\n\tuint8_t supportedHash[7]; /**< list of supported hash algorithms mapped to uint8_t */\n\tuint8_t cc; /**< cipher count - set to 0 means we support only AES128-CFB128 (4 bits) */\n\tuint8_t supportedCipher[7]; /**< list of supported cipher algorithms mapped to uint8_t */\n\tuint8_t ac; /**< auth tag count - set to 0 mean we support only HMAC-SHA1-32 (4 bits) */\n\tuint8_t supportedAuthTag[7]; /**< list of supported SRTP authentication tag algorithms mapped to uint8_t */\n\tuint8_t kc; /**< key agreement count - set to 0 means we support only Diffie-Hellman-Merkle 3072 (4 bits) */\n\tuint8_t supportedKeyAgreement[7]; /**< list of supported key agreement algorithms mapped to uint8_t */\n\tuint8_t sc; /**< sas count - set to 0 means we support only base32 (4 bits) */\n\tuint8_t supportedSas[7]; /**< list of supported Sas representations (4 chars string) */\n\tuint8_t MAC[8]; /**< HMAC over the whole message, keyed by the hash image H2 (64 bits)*/\n} bzrtpHelloMessage_t;\n\n/**\n * @brief Hello ACK Message rfc 5.3\n * This message contains no data but only a length and message type which are stored in the bzrtpPacket_t structure\n * There the no need to define a structure type for this packet\n */\n\n/**\n *\n * @brief Commit Message rfc 5.4\n * This message can be of 3 different types: DHM, PreShared and Multistream, some field of it may be used only by certain type of message\n * It is generated by the initiator (see section 4.2 for commit contention)\n */\ntypedef struct bzrtpCommitMessage_struct {\n\tuint8_t H2[32]; /**< the hash image H2 (256 bits) */\n\tuint8_t ZID[12]; /**< initiator's unique identifier for ZRTP endpoint (96 bits) */\n\tuint8_t hashAlgo; /**< the hash algorithm identifier rfc section 5.1.2 mapped to an integer */\n\tuint8_t cipherAlgo; /**< the cipher algorithm identifier rfc section 5.1.3 mapped to an integer */\n\tuint8_t authTagAlgo; /**< the auth tag algorithm identifier rfc section 5.1.4 mapped to an integer */\n\tuint8_t keyAgreementAlgo; /**< the key agreement algorithm identifier rfc section 5.1.5. It can either be a key exchange algorithm or the commit packet type in case of preShared or multistream commit message mapped to an integer */\n\tuint8_t sasAlgo; /**< the sas rendering algorithm identifier rfc section 5.1.6 mapped to an integer */\n\tuint8_t hvi[32]; /**< only for DH commit : a hash of initiator's DHPart2 and responder's Hello message rfc section 4.4.1.1 */\n\tuint8_t nonce[16]; /**< only for preShared or Multistream modes : a 128 bits random number generated by the initiator */\n\tuint8_t keyID[8]; /**< only for preShared mode : the preshared key identifier */\n\tuint8_t MAC[8]; /**< HMAC over the whole message, keyed by the hash image H1 (64 bits)*/\n} bzrtpCommitMessage_t;\n\n\n/**\n *\n * @brief DHPart Message rfc 5.5 and rfc 5.6\n * DHPart1 and DHPart2 message have the same structure\n * DHPart1 is generated by the responder, and DHPart2 by the initiator\n */\ntypedef struct bzrtpDHPartMessage_struct {\n\tuint8_t H1[32]; /**< the hash image H1 (256 bits) */\n\tuint8_t rs1ID[8]; /**< hash of the retained secret 1 (64 bits) */\n\tuint8_t rs2ID[8]; /**< hash of the retained secret 2 (64 bits) */\n\tuint8_t auxsecretID[8]; /**< hash of the auxiliary shared secret (64 bits) */\n\tuint8_t pbxsecretID[8]; /**< hash of the trusted MiTM PBX shared secret pbxsecret, defined in section 7.3.1 (64 bits) */\n\tuint8_t *pv; /* Key exchange public value (length depends on key agreement type) */\n\tuint8_t MAC[8]; /**< HMAC over the whole message, keyed by the hash image H1 (64 bits)*/\n} bzrtpDHPartMessage_t;\n\n/**\n *\n * @brief Confirm Message rfc 5.7\n * Confirm1 and Confirm2 messages have the same structure\n * Confirm1 is generated by the responder and Confirm2 by the initiator\n * Part of the message is encrypted using the negotiated block cipher for media encryption. Keys ares zrtpkeyr for responder and zrtpkeyi for initiator\n */\ntypedef struct bzrtpConfirmMessage_struct {\n\tuint8_t confirm_mac[8]; /**< a MAC computed over the encrypted part of the message (64 bits) */\n\tuint8_t CFBIV[16]; /**< The CFB Initialization Vector is a 128-bit random nonce (128 bits) */\n\tuint8_t H0[32]; /**< the hash image H0 - Encrypted - (256 bits) */\n\tuint16_t sig_len; /**< The SAS signature length.  If no SAS signature (described in Section 7.2) is present, all bits are set to zero.  The signature length is in words and includes the signature type block.  If the calculated signature octet count is not a multiple of 4, zeros are added to pad it out to a word boundary.  If no signature is present, the overall length of the Confirm1 or Confirm2 message will be set to 19 words - Encrypted - (9 bits) */\n\tuint8_t E; /**< The PBX Enrollment flag (E) is a Boolean bit defined in Section 7.3.1 - Encrypted - (1 bit) */\n\tuint8_t V; /**< The SAS Verified flag (V) is a Boolean bit defined in Section 7.1. - Encrypted - (1 bit) */\n\tuint8_t A; /**< The Allow Clear flag (A) is a Boolean bit defined in Section 4.7.2 - Encrypted - (1 bit) */\n\tuint8_t D; /**< The Disclosure Flag (D) is a Boolean bit defined in Section 11. - Encrypted - (1 bit) */\n\tuint32_t cacheExpirationInterval; /**< The cache expiration interval is defined in Section 4.9 - Encrypted - (32 bits) */\n\tuint8_t signatureBlockType[4]; /**< Optionnal signature type : \"PGP \" or \"X509\" string - Encrypted - (32 bits) */\n\tuint8_t *signatureBlock; /**< Optionnal signature block as decribded in section 7.2 - Encrypted - (variable length) */\n\t\n} bzrtpConfirmMessage_t;\n\n/**\n * @brief Conf2 ACK Message rfc 5.8\n * This message contains no data but only a length and message type which are stored in the bzrtpPacket_t structure\n * There the no need to define a structure type for this packet\n */\n\n/**\n * @brief Error Message rfc section 5.9\n * The Error message is sent to terminate an in-process ZRTP key agreement exchange due to an error.\n * There is no need to define a structure for this packet as it contains length and message type which are stored\n * in the bzrtpPacket_t structure and a 32 bits integer error code only\n */\n\n/**\n * @brief Error ACK Message rfc 5.10\n * This message contains no data but only a length and message type which are stored in the bzrtpPacket_t structure\n * There the no need to define a structure type for this packet\n */\n\n/**\n * @brief GoClear Message rfc 5.11\n * Support for the GoClear message is OPTIONAL in the protocol, and it is sent to switch from SRTP to RTP.\n */\ntypedef struct bzrtpGoClearMessage_struct {\n\tuint8_t clear_mac[8]; /**< The clear_mac is used to authenticate the GoClear message so that bogus GoClear messages introduced by an attacker can be detected and discarded. (64 bits) */\n} bzrtpGoClearMessage_t;\n\n/**\n *\n * @brief Clear ACK Message rfc 5.12\n * This message contains no data but only a length and message type which are stored in the bzrtpPacket_t structure\n * There the no need to define a structure type for this packet\n */\n\n/**\n * @brief SASRelay Message rfc 5.13\n * The SASrelay message is sent by a trusted MiTM, most often a PBX.  It is not sent as a response to a packet, but is sent as a self-initiated packet by the trusted MiTM (Section 7.3).  It can only be sent after the rest of the ZRTP key negotiations have completed, after the Confirm messages and their ACKs.  It can only be sent after the trusted MiTM has finished key negotiations with the other party, because it is the other party's SAS that is being relayed.  It is sent with retry logic until a RelayACK message (Section 5.14) is received or the retry schedule has been exhausted. Part of the message is encrypted using the negotiated block cipher for media encryption.\n * Depending on whether the trusted MiTM had taken the role of the initiator or the responder during the ZRTP key negotiation, the\n * SASrelay message is encrypted with zrtpkeyi or zrtpkeyr.\n */\ntypedef struct bzrtpSASRelayMessage_struct {\n\tuint8_t MAC[8]; /**< a MAC computed over the encrypted part of the message (64 bits) */\n\tuint8_t CFBIV[16]; /**< The CFB Initialization Vector is a 128-bit random nonce (128 bits) */\n\tuint16_t sig_len; /**< The SAS signature length.  The trusted MiTM MAY compute a digital signature on the SAS hash, as described in Section 7.2, using a persistent signing key owned by the trusted MiTM.  If no SAS signature is present, all bits are set to zero.  The signature length is in words and includes the signature type block.  If the calculated signature octet count is not a multiple of 4, zeros are added to pad it out to a word boundary.  If no signature block is present, the overall length of the SASrelay message will be set to 19 words.*/\n\tuint8_t V; /**< The SAS Verified flag (V) is a Boolean bit defined in Section 7.1. - Encrypted - (1 bit) */\n\tuint8_t A; /**< The Allow Clear flag (A) is a Boolean bit defined in Section 4.7.2 - Encrypted - (1 bit) */\n\tuint8_t D; /**< The Disclosure Flag (D) is a Boolean bit defined in Section 11. - Encrypted - (1 bit) */\n\tuint8_t renderingScheme[4]; /**< the SAS rendering scheme for the relayed sashash, which will be the same rendering scheme used by the other party on the other side of the trusted MiTM. - Encrypted - (32 bits) */ \n\tuint8_t relayedSasHash[32];\t/**< the sashash relayed from the other party.  The first 32-bit word of the sashash contains the sasvalue, which may be rendered to the user using the specified SAS rendering scheme.  If this SASrelay message is being sent to a ZRTP client that does not trust this MiTM, the sashash will be ignored by the recipient and should be set to zeros by the PBX. - Encrypted - (256 bits) */\n\tuint8_t signatureBlockType; /**< Optionnal signature type : \"PGP \" or \"X509\" string - Encrypted - (32 bits) */\n\tuint8_t *signatureBlock; /**< Optionnal signature block as decribded in section 7.2 - Encrypted - (variable length) */\n\n} bzrtpSASRelayMessage_t;\n\n/**\n * @brief Relay ACK Message rfc 5.14\n * This message contains no data but only a length and message type which are stored in the bzrtpPacket_t structure\n * There the no need to define a structure type for this packet\n */\n\n/**\n * @brief Ping Message\n * The Ping and PingACK messages are unrelated to the rest of the ZRTP protocol.  No ZRTP endpoint is required to generate a Ping message, but every ZRTP endpoint MUST respond to a Ping message with a PingACK message.\n */\ntypedef struct bzrtpPingMessage_struct {\n\tuint8_t version[4]; /**< a string defining the current version, shall be 1.10 (32 bits) */\n\tuint8_t endpointHash[8]; /**< see section 5.16 for the endpointHash definition (64 bits) */\n} bzrtpPingMessage_t;\n\n/**\n *\n * @brief PingAck Message\n * The Ping and PingACK messages are unrelated to the rest of the ZRTP protocol.  No ZRTP endpoint is required to generate a Ping message, but every ZRTP endpoint MUST respond to a Ping message with a PingACK message.\n */\ntypedef struct bzrtpPingAckMessage_struct {\n\tuint8_t version[4]; /**< a string defining the current version, shall be 1.10 (32 bits) */\n\tuint8_t endpointHash[8]; /**< see section 5.16 for the endpointHash definition (64 bits) */\n\tuint8_t endpointHashReceived[8]; /**< the endpoint hash received in the ping Message we're acknowledging (64 bits) */\n\tuint32_t SSRC; /**< the SSRC received in the ping packet we're acknowledging (32 bits) */\n} bzrtpPingAckMessage_t;\n\n\n/** \n * @brief Parse a string which shall be a valid ZRTP packet\n * Check validity and allocate the bzrtpPacket structure but do not parse the message except for type and length.\n * messageData structure field is not allocated by this function (use then bzrtp_packetParse for that).\n * The packet check and actual message parsing are split in two functions to avoid useless parsing when message is\n * to be discarded as the check will give message type (in case of message repetition for example)\n *\n * @param[in]\tinput\t\t\t\t\t\tThe string buffer storing the complete ZRTP packet\n * @param[in]\tinputLength\t\t\t\t\tInput length in bytes\n * @param[in]\tlastValidSequenceNumber\t\tIf the sequence number of this packet is smaller than this param, packet will be discarded\n *\t\t\t\t\t\t\t\t\t\t\tand an error code returned\n * @param[out]\texitCode\t\t\t\t\t0 on success, error code otherwise\n *\n * @return\t\tThe create bzrtpPacket structure(to be freed using bzrtp_freeZrtpPacket). NULL on error\n */\nbzrtpPacket_t *bzrtp_packetCheck(const uint8_t * input, uint16_t inputLength, uint16_t lastValidSequenceNumber, int *exitCode);\n\n\n/**\n * @brief Parse the packet to extract the message and allocate the matching message structure if needed\n *\n * @param[in]\t\tzrtpContext\t\t\tThe current ZRTP context, some parameters(key agreement algorithm) may be needed to parse packet.\n * @param[in]\t\tzrtpChannelContext\tThe channel context this packet is intended to(channel context and packet must match peer SSRC).\n * @param[in]\t\tinput\t\t\t\tThe string buffer storing the complete ZRTP packet\n * @param[in]\t\tinputLength\t\t\tInput length in bytes\n * @param[in]\t\tzrtpPacket\t\t\tThe zrtpPacket structure allocated by previous call to bzrtpPacketCheck\n *\n * @return \t0 on sucess, error code otherwise\n */\nint bzrtp_packetParser(bzrtpContext_t *zrtpContext, bzrtpChannelContext_t *zrtpChannelContext, const uint8_t * input, uint16_t inputLength, bzrtpPacket_t *zrtpPacket); \n\n\n/**\n * @brief Create an empty packet and allocate the messageData according to requested packetType\n *\n * @param[in]\t\tzrtpContext\t\t\tThe current ZRTP context, some data (H chain or others, may be needed to create messages)\n * @param[in]\t\tzrtpChannelContext\tThe channel context this packet is intended to\n * @param[in]\t\tmessageType\t\t\tThe 32bit integer mapped to the message type to be created\n * @param[out]\t\texitCode\t\t\t0 on success, error code otherwise\n *\n * @return\t\tAn empty packet initialised to get data for the requested paquet tyep. NULL on error\n */ \nbzrtpPacket_t *bzrtp_createZrtpPacket(bzrtpContext_t *zrtpContext, bzrtpChannelContext_t *zrtpChannelContext, uint32_t messageType, int *exitCode);\n\n\n/**\n * @brief Create a ZRTP packet string from the ZRTP packet values present in the structure\n * messageType, messageData and sourceIdentifier in zrtpPacket must have been correctly set before calling this function\n *\n * @param[in]\t\tzrtpContext\t\t\t\tA zrtp context where to find H0-H3 to compute MAC requested by some paquets or encryption's key for commit/SASRelay packet\n * @param[in]\t\tzrtpChannelContext\t\tThe channel context this packet is intended to\n * @param[in/out]\tzrtpPacket\t\t\t\tThe zrtpPacket structure containing the message Data structure, output is stored in ->packetString\n * @param[in]\t\tsequenceNumber\t\t\tSequence number of this packet\n *\n * @return\t\t\t0 on success, error code otherwise\n *\n */\nint bzrtp_packetBuild(bzrtpContext_t *zrtpContext,  bzrtpChannelContext_t *zrtpChannelContext, bzrtpPacket_t *zrtpPacket, uint16_t sequenceNumber);\n\n\n/**\n * @brief Deallocate zrtp Packet\n *\n * @param[in] zrtpPacket\tThe packet to be freed\n *\n */\nvoid bzrtp_freeZrtpPacket(bzrtpPacket_t *zrtpPacket);\n\n/**\n * @brief Modify the current sequence number of the packet in the packetString and sequenceNumber fields\n * The CRC at the end of packetString is also updated\n * \n * param[in/out]\tzrtpPacket\t\tThe zrtpPacket to modify, the packetString must have been generated by\n * \t\t\t\t\t\t\t\t\ta call to bzrtp_packetBuild on this packet\n * param[in]\t\tsequenceNumber\tThe new sequence number to insert in the packetString\n * \n * return\t\t0 on succes, error code otherwise\n */\nint bzrtp_packetUpdateSequenceNumber(bzrtpPacket_t *zrtpPacket, uint16_t sequenceNumber);\n#endif /* PACKETPARSER_H */\n", "/**\n @file packetParser.c\n \n @brief functions to parse and generate a ZRTP packet \n \n @author Johan Pascal\n\n @copyright Copyright (C) 2014 Belledonne Communications, Grenoble, France\n \n This program is free software; you can redistribute it and/or\n modify it under the terms of the GNU General Public License\n as published by the Free Software Foundation; either version 2\n of the License, or (at your option) any later version.\n \n This program is distributed in the hope that it will be useful,\n but WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n GNU General Public License for more details.\n \n You should have received a copy of the GNU General Public License\n along with this program; if not, write to the Free Software\n Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.\n */\n\n#include <stdlib.h>\n#include <string.h>\n#include \"typedef.h\"\n#include \"packetParser.h\"\n#include <bctoolbox/crypto.h>\n#include \"cryptoUtils.h\"\n\n/* DEBUG */\n#include <stdio.h>\n\n/* minimum length of a ZRTP packet: 12 bytes header + 12 bytes message(shortest are ACK messages) + 4 bytes CRC */\n#define ZRTP_MIN_PACKET_LENGTH 28\n\n/* maximum length of a ZRTP packet: 3072 bytes get it from GNU-ZRTP CPP code */\n#define ZRTP_MAX_PACKET_LENGTH 3072\n\n/* header of ZRTP message is 12 bytes : Preambule/Message Length + Message Type(2 words) */\n#define ZRTP_MESSAGE_HEADER_LENGTH 12\n\n/* length of the non optional and fixed part of all messages, in bytes */\n#define ZRTP_HELLOMESSAGE_FIXED_LENGTH\t\t\t88 \n#define ZRTP_HELLOACKMESSAGE_FIXED_LENGTH\t\t12\n#define ZRTP_COMMITMESSAGE_FIXED_LENGTH \t\t84\n#define ZRTP_DHPARTMESSAGE_FIXED_LENGTH \t\t84\n#define ZRTP_CONFIRMMESSAGE_FIXED_LENGTH\t\t76 \n#define ZRTP_CONF2ACKMESSAGE_FIXED_LENGTH \t\t12\n#define ZRTP_ERRORMESSAGE_FIXED_LENGTH \t\t\t16\n#define ZRTP_ERRORACKMESSAGE_FIXED_LENGTH \t\t12\n#define ZRTP_GOCLEARMESSAGE_FIXED_LENGTH\t\t20 \n#define ZRTP_CLEARACKMESSAGE_FIXED_LENGTH \t\t12\n#define ZRTP_SASRELAYMESSAGE_FIXED_LENGTH \t\t76\n#define ZRTP_RELAYACKMESSAGE_FIXED_LENGTH \t\t12\n#define ZRTP_PINGMESSAGE_FIXED_LENGTH \t\t\t24\n#define ZRTP_PINGACKMESSAGE_FIXED_LENGTH \t\t36\n\n/*** local functions prototypes ***/\n\n/**\n * Return the variable private value length in bytes according to given key agreement algorythm\n *\n * @param[in]\tkeyAgreementAlgo\tThe key agreement algo mapped to an integer as defined in cryptoWrapper.h\n *\n * @return\t\tthe private value length in bytes\n *\n */\nuint16_t computeKeyAgreementPrivateValueLength(uint8_t keyAgreementAlgo);\n\n/**\n * @brief Retrieve the 8 char string value message type from the int32_t code\n *\n * @param[in] messageType\t\tThe messageType code\n *\n * @return\tan 9 char string : 8 chars message type as specified in rfc section 5.1.1 + string terminating char\n */\nuint8_t *messageTypeInttoString(uint32_t messageType);\n\n/**\n * @brief Map the 8 char string value message type to an int32_t\n *\n * @param[in] messageTypeString\t\tan 8 bytes string matching a zrtp message type\n *\n * @return\ta 32-bits unsigned integer mapping the message type\n */\nint32_t messageTypeStringtoInt(uint8_t messageTypeString[8]);\n\n/**\n * @brief Write the message header(preambule, length, message type) into the given output buffer\n *\n * @param[out]\toutputBuffer\t\tMessage starts at the begining of this buffer\n * @param[in]\tmessageLength\t\tMessage length in bytes! To be converted into 32bits words before being inserted in the message header\n * @param[in]\tmessageType\t\t\tAn 8 chars string for the message type (validity is not checked by this function)\n *\n */\nvoid zrtpMessageSetHeader(uint8_t *outputBuffer, uint16_t messageLength, uint8_t messageType[8]);\n\n\n\n\n/*** Public functions implementation ***/\n\n/* First call this function to check packet validity and create the packet structure */\nbzrtpPacket_t *bzrtp_packetCheck(const uint8_t * input, uint16_t inputLength, uint16_t lastValidSequenceNumber, int *exitCode) {\n\tbzrtpPacket_t *zrtpPacket;\n\tuint16_t sequenceNumber;\n\tuint32_t packetCRC;\n\tuint16_t messageLength;\n\tuint32_t messageType;\n\n\t/* first check that the packet is a ZRTP one */\n\t/* is the length compatible with a ZRTP packet */ \n\tif ((inputLength<ZRTP_MIN_PACKET_LENGTH) || (inputLength>ZRTP_MAX_PACKET_LENGTH)) {\n\t\t *exitCode = BZRTP_PARSER_ERROR_INVALIDPACKET;\n\t\t return NULL;\n\t}\n\n\t/* check ZRTP packet format from rfc section 5 \n    0                   1                   2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |0 0 0 1|Not Used (set to zero) |         Sequence Number       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |                 Magic Cookie 'ZRTP' (0x5a525450)              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |                        Source Identifier                      |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |                                                               |\n   |           ZRTP Message (length depends on Message Type)       |\n   |                            . . .                              |\n   |                                                               |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |                          CRC (1 word)                         |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+*/\n\tif ((input[0]>>4 != 0x01) || (input[4]!= (uint8_t)((ZRTP_MAGIC_COOKIE>>24)&0xFF)) || (input[5]!= (uint8_t)((ZRTP_MAGIC_COOKIE>>16)&0xFF)) || (input[6]!= (uint8_t)((ZRTP_MAGIC_COOKIE>>8)&0xFF)) || (input[7]!= (uint8_t)(ZRTP_MAGIC_COOKIE&0xFF))) {\n\t\t*exitCode = BZRTP_PARSER_ERROR_INVALIDPACKET;\n\t\treturn NULL;\n\t}\n\n\t/* Check the sequence number : it must be > to the last valid one (given in parameter) to discard out of order packets\n\t * TODO: what if we got a Sequence Number overflowing the 16 bits ? */\n\tsequenceNumber = (((uint16_t)input[2])<<8) | ((uint16_t)input[3]);\n\tif (sequenceNumber <= lastValidSequenceNumber) {\n\t\t*exitCode = BZRTP_PARSER_ERROR_OUTOFORDER;\n\t\treturn NULL;\n\t}\n\n\t/* Check the CRC : The CRC is calculated across the entire ZRTP packet, including the ZRTP header and the ZRTP message, but not including the CRC field.*/\n\tpacketCRC = ((((uint32_t)input[inputLength-4])<<24)&0xFF000000) | ((((uint32_t)input[inputLength-3])<<16)&0x00FF0000) | ((((uint32_t)input[inputLength-2])<<8)&0x0000FF00) | (((uint32_t)input[inputLength-1])&0x000000FF);\n\tif (bzrtp_CRC32((uint8_t *)input, inputLength - 4) != packetCRC) {\n\t\t*exitCode = BZRTP_PARSER_ERROR_INVALIDCRC;\n\t\treturn NULL;\n\t}\n\n\t/* check message header : \n\t *  0                   1                   2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |0 1 0 1 0 0 0 0 0 1 0 1 1 0 1 0|             length            |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |            Message Type Block            (2 words)            |\n   |                                                               |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+*/\n\tif ((input[ZRTP_PACKET_HEADER_LENGTH]!=0x50) || (input[ZRTP_PACKET_HEADER_LENGTH+1]!=0x5a)) {\n\t\t*exitCode = BZRTP_PARSER_ERROR_INVALIDMESSAGE;\n\t\treturn NULL;\n\t}\n\n\t/* get the length from the message: it is expressed in 32bits words, convert it to bytes (4*) */\n\tmessageLength = 4*(((((uint16_t)input[ZRTP_PACKET_HEADER_LENGTH+2])<<8)&0xFF00) | (((uint16_t)input[ZRTP_PACKET_HEADER_LENGTH+3])&0x00FF));\n\n\t/* get the message Type */\n\tmessageType = messageTypeStringtoInt((uint8_t *)(input+ZRTP_PACKET_HEADER_LENGTH+4));\n\n\tif (messageType == MSGTYPE_INVALID) {\n\t\t*exitCode = BZRTP_PARSER_ERROR_INVALIDMESSAGE;\n\t\treturn NULL;\n\t}\n\n\t/* packet and message seems to be valid, so allocate a structure and parse it */\n\tzrtpPacket = (bzrtpPacket_t *)malloc(sizeof(bzrtpPacket_t));\n\tmemset(zrtpPacket, 0, sizeof(bzrtpPacket_t));\n\tzrtpPacket->sequenceNumber = sequenceNumber;\n\tzrtpPacket->messageLength = messageLength;\n\tzrtpPacket->messageType = messageType;\n\tzrtpPacket->messageData = NULL;\n\tzrtpPacket->packetString = NULL;\n\n\t/* get the SSRC */\n\tzrtpPacket->sourceIdentifier = ((((uint32_t)input[8])<<24)&0xFF000000) | ((((uint32_t)input[9])<<16)&0x00FF0000) | ((((uint32_t)input[10])<<8)&0x0000FF00) | (((uint32_t)input[11])&0x000000FF);\n\n\t*exitCode = 0;\n\treturn zrtpPacket;\n}\n\n\n#define MIN(a, b) (((a) < (b)) ? (a) : (b))\n\n\n/* Call this function after the packetCheck one, to actually parse the packet : create and fill the messageData structure */\nint bzrtp_packetParser(bzrtpContext_t *zrtpContext, bzrtpChannelContext_t *zrtpChannelContext, const uint8_t * input, uint16_t inputLength, bzrtpPacket_t *zrtpPacket) {\n\n\tint i;\n\n\t/* now allocate and fill the correct message structure according to the message type */\n\t/* messageContent points to the begining of the ZRTP message */\n\tuint8_t *messageContent = (uint8_t *)(input+ZRTP_PACKET_HEADER_LENGTH+ZRTP_MESSAGE_HEADER_LENGTH);\n\n\tswitch (zrtpPacket->messageType) {\n\t\tcase MSGTYPE_HELLO : \n\t\t\t{\n\t\t\t\t/* allocate a Hello message structure */\n\t\t\t\tbzrtpHelloMessage_t *messageData;\n\t\t\t\tmessageData = (bzrtpHelloMessage_t *)malloc(sizeof(bzrtpHelloMessage_t));\n\n\t\t\t\t/* fill it */\n\t\t\t\tmemcpy(messageData->version, messageContent, 4);\n\t\t\t\tmessageContent +=4;\n\t\t\t\tmemcpy(messageData->clientIdentifier, messageContent, 16);\n\t\t\t\tmessageContent +=16;\n\t\t\t\tmemcpy(messageData->H3, messageContent, 32);\n\t\t\t\tmessageContent +=32;\n\t\t\t\tmemcpy(messageData->ZID, messageContent, 12);\n\t\t\t\tmessageContent +=12;\n\t\t\t\tmessageData->S = ((*messageContent)>>6)&0x01;\n\t\t\t\tmessageData->M = ((*messageContent)>>5)&0x01;\n\t\t\t\tmessageData->P = ((*messageContent)>>4)&0x01;\n\t\t\t\tmessageContent +=1;\n\t\t\t\tmessageData->hc = MIN((*messageContent)&0x0F, 7);\n\t\t\t\tmessageContent +=1;\n\t\t\t\tmessageData->cc = MIN(((*messageContent)>>4)&0x0F, 7);\n\t\t\t\tmessageData->ac = MIN((*messageContent)&0x0F, 7);\n\t\t\t\tmessageContent +=1;\n\t\t\t\tmessageData->kc = MIN(((*messageContent)>>4)&0x0F, 7);\n\t\t\t\tmessageData->sc = MIN((*messageContent)&0x0F, 7);\n\t\t\t\tmessageContent +=1;\n\n\t\t\t\t/* Check message length according to value in hc, cc, ac, kc and sc */\n\t\t\t\tif (zrtpPacket->messageLength != ZRTP_HELLOMESSAGE_FIXED_LENGTH + 4*((uint16_t)(messageData->hc)+(uint16_t)(messageData->cc)+(uint16_t)(messageData->ac)+(uint16_t)(messageData->kc)+(uint16_t)(messageData->sc))) {\n\t\t\t\t\tfree(messageData);\n\t\t\t\t\treturn BZRTP_PARSER_ERROR_INVALIDMESSAGE;\n\t\t\t\t}\n\n\t\t\t\t/* parse the variable length part: algorithms types */\n\t\t\t\tfor (i=0; i<messageData->hc; i++) {\n\t\t\t\t\tmessageData->supportedHash[i] = cryptoAlgoTypeStringToInt(messageContent, ZRTP_HASH_TYPE);\n\t\t\t\t\tmessageContent +=4;\n\t\t\t\t}\n\t\t\t\tfor (i=0; i<messageData->cc; i++) {\n\t\t\t\t\tmessageData->supportedCipher[i] = cryptoAlgoTypeStringToInt(messageContent, ZRTP_CIPHERBLOCK_TYPE);\n\t\t\t\t\tmessageContent +=4;\n\t\t\t\t}\n\t\t\t\tfor (i=0; i<messageData->ac; i++) {\n\t\t\t\t\tmessageData->supportedAuthTag[i] = cryptoAlgoTypeStringToInt(messageContent, ZRTP_AUTHTAG_TYPE);\n\t\t\t\t\tmessageContent +=4;\n\t\t\t\t}\n\t\t\t\tfor (i=0; i<messageData->kc; i++) {\n\t\t\t\t\tmessageData->supportedKeyAgreement[i] = cryptoAlgoTypeStringToInt(messageContent, ZRTP_KEYAGREEMENT_TYPE);\n\t\t\t\t\tmessageContent +=4;\n\t\t\t\t}\n\t\t\t\tfor (i=0; i<messageData->sc; i++) {\n\t\t\t\t\tmessageData->supportedSas[i] = cryptoAlgoTypeStringToInt(messageContent, ZRTP_SAS_TYPE);\n\t\t\t\t\tmessageContent +=4;\n\t\t\t\t}\n\n\t\t\t\taddMandatoryCryptoTypesIfNeeded(ZRTP_HASH_TYPE, messageData->supportedHash, &messageData->hc);\n\t\t\t\taddMandatoryCryptoTypesIfNeeded(ZRTP_CIPHERBLOCK_TYPE, messageData->supportedCipher, &messageData->cc);\n\t\t\t\taddMandatoryCryptoTypesIfNeeded(ZRTP_AUTHTAG_TYPE, messageData->supportedAuthTag, &messageData->ac);\n\t\t\t\taddMandatoryCryptoTypesIfNeeded(ZRTP_KEYAGREEMENT_TYPE, messageData->supportedKeyAgreement, &messageData->kc);\n\t\t\t\taddMandatoryCryptoTypesIfNeeded(ZRTP_SAS_TYPE, messageData->supportedSas, &messageData->sc);\n\n\t\t\t\tmemcpy(messageData->MAC, messageContent, 8);\n\t\t\t\t\n\t\t\t\t/* attach the message structure to the packet one */\n\t\t\t\tzrtpPacket->messageData = (void *)messageData;\n\n\t\t\t\t/* the parsed Hello packet must be saved as it may be used to generate commit message or the total_hash */\n\t\t\t\tzrtpPacket->packetString = (uint8_t *)malloc(inputLength*sizeof(uint8_t));\n\t\t\t\tmemcpy(zrtpPacket->packetString, input, inputLength); /* store the whole packet even if we may use the message only */\n\t\t\t}\n\t\t\tbreak; /* MSGTYPE_HELLO */\n\n\t\tcase MSGTYPE_HELLOACK :\n\t\t\t{\n\t\t\t\t/* check message length */\n\t\t\t\tif (zrtpPacket->messageLength != ZRTP_HELLOACKMESSAGE_FIXED_LENGTH) {\n\t\t\t\t\treturn BZRTP_PARSER_ERROR_INVALIDMESSAGE;\n\t\t\t\t}\n\n\n\t\t\t}\n\t\t\tbreak; /* MSGTYPE_HELLOACK */\n\n\t\tcase MSGTYPE_COMMIT:\n\t\t\t{\n\t\t\t\tuint8_t checkH3[32];\n\t\t\t\tuint8_t checkMAC[32];\n\t\t\t\tbzrtpHelloMessage_t *peerHelloMessageData;\n\t\t\t\tuint16_t variableLength = 0;\n\n\t\t\t\t/* allocate a commit message structure */\n\t\t\t\tbzrtpCommitMessage_t *messageData;\n\t\t\t\tmessageData = (bzrtpCommitMessage_t *)malloc(sizeof(bzrtpCommitMessage_t));\n\n\t\t\t\t/* fill the structure */\n\t\t\t\tmemcpy(messageData->H2, messageContent, 32);\n\t\t\t\tmessageContent +=32;\n\n\t\t\t\t/* We have now H2, check it matches the H3 we had in the hello message H3=SHA256(H2) and that the Hello message MAC is correct */\n\t\t\t\tif (zrtpChannelContext->peerPackets[HELLO_MESSAGE_STORE_ID] == NULL) {\n\t\t\t\t\tfree (messageData);\n\t\t\t\t\t/* we have no Hello message in this channel, this commit shall never have arrived, discard it as invalid */\n\t\t\t\t\treturn BZRTP_PARSER_ERROR_UNEXPECTEDMESSAGE;\n\t\t\t\t}\n\t\t\t\tpeerHelloMessageData = (bzrtpHelloMessage_t *)zrtpChannelContext->peerPackets[HELLO_MESSAGE_STORE_ID]->messageData;\n\t\t\t\t/* Check H3 = SHA256(H2) */\n\t\t\t\tbctoolbox_sha256(messageData->H2, 32, 32, checkH3);\n\t\t\t\tif (memcmp(checkH3, peerHelloMessageData->H3, 32) != 0) {\n\t\t\t\t\tfree (messageData);\n\t\t\t\t\treturn BZRTP_PARSER_ERROR_UNMATCHINGHASHCHAIN;\n\t\t\t\t}\n\t\t\t\t/* Check the hello MAC message. \n\t\t\t\t * MAC is 8 bytes long and is computed on the message(skip the ZRTP_PACKET_HEADER) and exclude the mac itself (-8 bytes from message Length) */\n\t\t\t\tbctoolbox_hmacSha256(messageData->H2, 32, zrtpChannelContext->peerPackets[HELLO_MESSAGE_STORE_ID]->packetString+ZRTP_PACKET_HEADER_LENGTH, zrtpChannelContext->peerPackets[HELLO_MESSAGE_STORE_ID]->messageLength-8, 8, checkMAC);\n\t\t\t\tif (memcmp(checkMAC, peerHelloMessageData->MAC, 8) != 0) {\n\t\t\t\t\tfree (messageData);\n\t\t\t\t\treturn BZRTP_PARSER_ERROR_UNMATCHINGMAC;\n\t\t\t\t}\n\n\t\t\t\tmemcpy(messageData->ZID, messageContent, 12);\n\t\t\t\tmessageContent +=12;\n\t\t\t\tmessageData->hashAlgo = cryptoAlgoTypeStringToInt(messageContent, ZRTP_HASH_TYPE);\n\t\t\t\tmessageContent += 4;\n\t\t\t\tmessageData->cipherAlgo = cryptoAlgoTypeStringToInt(messageContent, ZRTP_CIPHERBLOCK_TYPE);\n\t\t\t\tmessageContent += 4;\n\t\t\t\tmessageData->authTagAlgo = cryptoAlgoTypeStringToInt(messageContent, ZRTP_AUTHTAG_TYPE);\n\t\t\t\tmessageContent += 4;\n\t\t\t\tmessageData->keyAgreementAlgo = cryptoAlgoTypeStringToInt(messageContent, ZRTP_KEYAGREEMENT_TYPE);\n\t\t\t\tmessageContent += 4;\n\t\t\t\t/* commit message length depends on the key agreement type choosen (and set in the zrtpContext->keyAgreementAlgo) */\n\t\t\t\tswitch(messageData->keyAgreementAlgo) {\n\t\t\t\t\tcase ZRTP_KEYAGREEMENT_DH2k :\n\t\t\t\t\tcase ZRTP_KEYAGREEMENT_EC25 :\n\t\t\t\t\tcase ZRTP_KEYAGREEMENT_DH3k :\n\t\t\t\t\tcase ZRTP_KEYAGREEMENT_EC38 :\n\t\t\t\t\tcase ZRTP_KEYAGREEMENT_EC52 :\n\t\t\t\t\t\tvariableLength = 32; /* hvi is 32 bytes length in DH Commit message format */\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase ZRTP_KEYAGREEMENT_Prsh :\n\t\t\t\t\t\tvariableLength = 24; /* nonce (16 bytes) and keyID(8 bytes) are 24 bytes length in preshared Commit message format */\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase ZRTP_KEYAGREEMENT_Mult :\n\t\t\t\t\t\tvariableLength = 16; /* nonce is 24 bytes length in multistream Commit message format */\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tfree(messageData);\n\t\t\t\t\t\treturn BZRTP_PARSER_ERROR_INVALIDMESSAGE;\n\t\t\t\t}\n\n\t\t\t\tif (zrtpPacket->messageLength != ZRTP_COMMITMESSAGE_FIXED_LENGTH + variableLength) {\n\t\t\t\t\tfree(messageData);\n\t\t\t\t\treturn BZRTP_PARSER_ERROR_INVALIDMESSAGE;\n\t\t\t\t}\n\t\t\t\tmessageData->sasAlgo = cryptoAlgoTypeStringToInt(messageContent, ZRTP_SAS_TYPE);\n\t\t\t\tmessageContent += 4;\n\n\t\t\t\t/* if it is a multistream or preshared commit, get the 16 bytes nonce */\n\t\t\t\tif ((messageData->keyAgreementAlgo == ZRTP_KEYAGREEMENT_Prsh) || (messageData->keyAgreementAlgo == ZRTP_KEYAGREEMENT_Mult)) {\n\t\t\t\t\tmemcpy(messageData->nonce, messageContent, 16);\n\t\t\t\t\tmessageContent +=16;\n\n\t\t\t\t\t/* and the keyID for preshared commit only */\n\t\t\t\t\tif (messageData->keyAgreementAlgo == ZRTP_KEYAGREEMENT_Prsh) {\n\t\t\t\t\t\tmemcpy(messageData->keyID, messageContent, 8);\n\t\t\t\t\t\tmessageContent +=8;\n\t\t\t\t\t}\n\t\t\t\t} else { /* it's a DH commit message, get the hvi */\n\t\t\t\t\tmemcpy(messageData->hvi, messageContent, 32);\n\t\t\t\t\tmessageContent +=32;\n\t\t\t\t}\n\n\t\t\t\t/* get the MAC and attach the message data to the packet structure */\n\t\t\t\tmemcpy(messageData->MAC, messageContent, 8);\n\t\t\t\tzrtpPacket->messageData = (void *)messageData;\n\n\t\t\t\t/* the parsed commit packet must be saved as it is used to generate the total_hash */\n\t\t\t\tzrtpPacket->packetString = (uint8_t *)malloc(inputLength*sizeof(uint8_t));\n\t\t\t\tmemcpy(zrtpPacket->packetString, input, inputLength); /* store the whole packet even if we may use the message only */\n\t\t\t}\n\t\t\tbreak; /* MSGTYPE_COMMIT */\n\t\tcase MSGTYPE_DHPART1 :\n\t\tcase MSGTYPE_DHPART2 :\n\t\t\t{\n\t\t\t\tbzrtpDHPartMessage_t *messageData;\n\n\t\t\t\t/*check message length, depends on the selected key agreement algo set in zrtpContext */\n\t\t\t\tuint16_t pvLength = computeKeyAgreementPrivateValueLength(zrtpChannelContext->keyAgreementAlgo);\n\t\t\t\tif (pvLength == 0) {\n\t\t\t\t\treturn BZRTP_PARSER_ERROR_INVALIDCONTEXT;\n\t\t\t\t}\n\n\t\t\t\tif (zrtpPacket->messageLength != ZRTP_DHPARTMESSAGE_FIXED_LENGTH+pvLength) {\n\t\t\t\t\treturn BZRTP_PARSER_ERROR_INVALIDMESSAGE;\n\t\t\t\t}\n\n\t\t\t\t/* allocate a DHPart message structure and pv */\n\t\t\t\tmessageData = (bzrtpDHPartMessage_t *)malloc(sizeof(bzrtpDHPartMessage_t));\n\t\t\t\tmessageData->pv = (uint8_t *)malloc(pvLength*sizeof(uint8_t));\n\n\t\t\t\t/* fill the structure */\n\t\t\t\tmemcpy(messageData->H1, messageContent, 32);\n\t\t\t\tmessageContent +=32;\n\n\t\t\t\t/* We have now H1, check it matches the H2 we had in the commit message H2=SHA256(H1) and that the Commit message MAC is correct */\n\t\t\t\tif ( zrtpChannelContext->role == RESPONDER) { /* do it only if we are responder (we received a commit packet) */\n\t\t\t\t\tuint8_t checkH2[32];\n\t\t\t\t\tuint8_t checkMAC[32];\n\t\t\t\t\tbzrtpCommitMessage_t *peerCommitMessageData;\n\n\t\t\t\t\tif (zrtpChannelContext->peerPackets[COMMIT_MESSAGE_STORE_ID] == NULL) {\n\t\t\t\t\t\tfree (messageData);\n\t\t\t\t\t\t/* we have no Commit message in this channel, this DHPart2 shall never have arrived, discard it as invalid */\n\t\t\t\t\t\treturn BZRTP_PARSER_ERROR_UNEXPECTEDMESSAGE;\n\t\t\t\t\t}\n\t\t\t\t\tpeerCommitMessageData = (bzrtpCommitMessage_t *)zrtpChannelContext->peerPackets[COMMIT_MESSAGE_STORE_ID]->messageData;\n\t\t\t\t\t/* Check H2 = SHA256(H1) */\n\t\t\t\t\tbctoolbox_sha256(messageData->H1, 32, 32, checkH2);\n\t\t\t\t\tif (memcmp(checkH2, peerCommitMessageData->H2, 32) != 0) {\n\t\t\t\t\t\tfree (messageData);\n\t\t\t\t\t\treturn BZRTP_PARSER_ERROR_UNMATCHINGHASHCHAIN;\n\t\t\t\t\t}\n\t\t\t\t\t/* Check the Commit MAC message. \n\t\t\t\t\t * MAC is 8 bytes long and is computed on the message(skip the ZRTP_PACKET_HEADER) and exclude the mac itself (-8 bytes from message Length) */\n\t\t\t\t\tbctoolbox_hmacSha256(messageData->H1, 32, zrtpChannelContext->peerPackets[COMMIT_MESSAGE_STORE_ID]->packetString+ZRTP_PACKET_HEADER_LENGTH, zrtpChannelContext->peerPackets[COMMIT_MESSAGE_STORE_ID]->messageLength-8, 8, checkMAC);\n\t\t\t\t\tif (memcmp(checkMAC, peerCommitMessageData->MAC, 8) != 0) {\n\t\t\t\t\t\tfree (messageData);\n\t\t\t\t\t\treturn BZRTP_PARSER_ERROR_UNMATCHINGMAC;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* Check the hvi received in the commit message  - RFC section 4.4.1.1*/\n\t\t\t\t\t/* First compute the expected hvi */\n\t\t\t\t\t/* hvi = hash(initiator's DHPart2 message(current zrtpPacket)) || responder's Hello message) using the agreed hash function truncated to 256 bits */\n\t\t\t\t\t/* create a string with the messages concatenated */\n\t\t\t\t\t{\n\t\t\t\t\t\tuint8_t computedHvi[32];\n\t\t\t\t\t\tuint16_t HelloMessageLength = zrtpChannelContext->selfPackets[HELLO_MESSAGE_STORE_ID]->messageLength;\n\t\t\t\t\t\tuint16_t DHPartHelloMessageStringLength = zrtpPacket->messageLength + HelloMessageLength;\n\n\t\t\t\t\t\tuint8_t *DHPartHelloMessageString = (uint8_t *)malloc(DHPartHelloMessageStringLength*sizeof(uint8_t));\n\n\t\t\t\t\t\tmemcpy(DHPartHelloMessageString, input+ZRTP_PACKET_HEADER_LENGTH, zrtpPacket->messageLength);\n\t\t\t\t\t\tmemcpy(DHPartHelloMessageString+zrtpPacket->messageLength, zrtpChannelContext->selfPackets[HELLO_MESSAGE_STORE_ID]->packetString+ZRTP_PACKET_HEADER_LENGTH, HelloMessageLength);\n\n\t\t\t\t\t\tzrtpChannelContext->hashFunction(DHPartHelloMessageString, DHPartHelloMessageStringLength, 32, computedHvi);\n\n\t\t\t\t\t\tfree(DHPartHelloMessageString);\n\n\t\t\t\t\t\t/* Compare computed and received hvi */\n\t\t\t\t\t\tif (memcmp(computedHvi, peerCommitMessageData->hvi, 32)!=0) {\n\t\t\t\t\t\t\tfree (messageData);\n\t\t\t\t\t\t\treturn BZRTP_PARSER_ERROR_UNMATCHINGHVI;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t} else { /* if we are initiator(we didn't received any commit message and then no H2), we must check that H3=SHA256(SHA256(H1)) and the Hello message MAC */\n\t\t\t\t\tuint8_t checkH2[32];\n\t\t\t\t\tuint8_t checkH3[32];\n\t\t\t\t\tuint8_t checkMAC[32];\n\t\t\t\t\tbzrtpHelloMessage_t *peerHelloMessageData;\n\n\t\t\t\t\tif (zrtpChannelContext->peerPackets[HELLO_MESSAGE_STORE_ID] == NULL) {\n\t\t\t\t\t\tfree (messageData);\n\t\t\t\t\t\t/* we have no Hello message in this channel, this DHPart1 shall never have arrived, discard it as invalid */\n\t\t\t\t\t\treturn BZRTP_PARSER_ERROR_UNEXPECTEDMESSAGE;\n\t\t\t\t\t}\n\t\t\t\t\tpeerHelloMessageData = (bzrtpHelloMessage_t *)zrtpChannelContext->peerPackets[HELLO_MESSAGE_STORE_ID]->messageData;\n\t\t\t\t\t/* Check H3 = SHA256(SHA256(H1)) */\n\t\t\t\t\tbctoolbox_sha256(messageData->H1, 32, 32, checkH2);\n\t\t\t\t\tbctoolbox_sha256(checkH2, 32, 32, checkH3);\n\t\t\t\t\tif (memcmp(checkH3, peerHelloMessageData->H3, 32) != 0) {\n\t\t\t\t\t\tfree (messageData);\n\t\t\t\t\t\treturn BZRTP_PARSER_ERROR_UNMATCHINGHASHCHAIN;\n\t\t\t\t\t}\n\t\t\t\t\t/* Check the hello MAC message. \n\t\t\t\t\t * MAC is 8 bytes long and is computed on the message(skip the ZRTP_PACKET_HEADER) and exclude the mac itself (-8 bytes from message Length) */\n\t\t\t\t\tbctoolbox_hmacSha256(checkH2, 32, zrtpChannelContext->peerPackets[HELLO_MESSAGE_STORE_ID]->packetString+ZRTP_PACKET_HEADER_LENGTH, zrtpChannelContext->peerPackets[HELLO_MESSAGE_STORE_ID]->messageLength-8, 8, checkMAC);\n\t\t\t\t\tif (memcmp(checkMAC, peerHelloMessageData->MAC, 8) != 0) {\n\t\t\t\t\t\tfree (messageData);\n\t\t\t\t\t\treturn BZRTP_PARSER_ERROR_UNMATCHINGMAC;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tmemcpy(messageData->rs1ID, messageContent, 8);\n\t\t\t\tmessageContent +=8;\n\t\t\t\tmemcpy(messageData->rs2ID, messageContent, 8);\n\t\t\t\tmessageContent +=8;\n\t\t\t\tmemcpy(messageData->auxsecretID, messageContent, 8);\n\t\t\t\tmessageContent +=8;\n\t\t\t\tmemcpy(messageData->pbxsecretID, messageContent, 8);\n\t\t\t\tmessageContent +=8;\n\t\t\t\tmemcpy(messageData->pv, messageContent, pvLength);\n\t\t\t\tmessageContent +=pvLength;\n\t\t\t\tmemcpy(messageData->MAC, messageContent, 8);\n\n\t\t\t\t/* attach the message structure to the packet one */\n\t\t\t\tzrtpPacket->messageData = (void *)messageData;\n\n\t\t\t\t/* the parsed packet must be saved as it is used to generate the total_hash */\n\t\t\t\tzrtpPacket->packetString = (uint8_t *)malloc(inputLength*sizeof(uint8_t));\n\t\t\t\tmemcpy(zrtpPacket->packetString, input, inputLength); /* store the whole packet even if we may use the message only */\n\t\t\t}\n\t\t\tbreak; /* MSGTYPE_DHPART1 and MSGTYPE_DHPART2 */\n\t\tcase MSGTYPE_CONFIRM1:\n\t\tcase MSGTYPE_CONFIRM2:\n\t\t\t{\n\t\t\t\tuint8_t *confirmMessageKey = NULL;\n\t\t\t\tuint8_t *confirmMessageMacKey = NULL;\n\t\t\t\tbzrtpConfirmMessage_t *messageData;\n\t\t\t\tuint16_t cipherTextLength;\n\t\t\t\tuint8_t computedHmac[8];\n\t\t\t\tuint8_t *confirmPlainMessageBuffer;\n\t\t\t\tuint8_t *confirmPlainMessage;\n\n\t\t\t\t/* we shall first decrypt and validate the message, check we have the keys to do it */\n\t\t\t\tif (zrtpChannelContext->role == RESPONDER) { /* responder uses initiator's keys to decrypt */\n\t\t\t\t\tif ((zrtpChannelContext->zrtpkeyi == NULL) || (zrtpChannelContext->mackeyi == NULL)) {\n\t\t\t\t\t\treturn BZRTP_PARSER_ERROR_INVALIDCONTEXT;\n\t\t\t\t\t}\n\t\t\t\t\tconfirmMessageKey = zrtpChannelContext->zrtpkeyi;\n\t\t\t\t\tconfirmMessageMacKey = zrtpChannelContext->mackeyi;\n\t\t\t\t}\n\n\t\t\t\tif (zrtpChannelContext->role == INITIATOR) { /* the iniator uses responder's keys to decrypt */\n\t\t\t\t\tif ((zrtpChannelContext->zrtpkeyr == NULL) || (zrtpChannelContext->mackeyr == NULL)) {\n\t\t\t\t\t\treturn BZRTP_PARSER_ERROR_INVALIDCONTEXT;\n\t\t\t\t\t}\n\t\t\t\t\tconfirmMessageKey = zrtpChannelContext->zrtpkeyr;\n\t\t\t\t\tconfirmMessageMacKey = zrtpChannelContext->mackeyr;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t/* allocate a confirm message structure */\n\t\t\t\tmessageData = (bzrtpConfirmMessage_t *)malloc(sizeof(bzrtpConfirmMessage_t));\n\n\t\t\t\t/* get the mac and the IV */\n\t\t\t\tmemcpy(messageData->confirm_mac, messageContent, 8);\n\t\t\t\tmessageContent +=8;\n\t\t\t\tmemcpy(messageData->CFBIV, messageContent, 16);\n\t\t\t\tmessageContent +=16;\n\n\n\t\t\t\t\n\t\t\t\t/* get the cipher text length */\n\t\t\t\tcipherTextLength = zrtpPacket->messageLength - ZRTP_MESSAGE_HEADER_LENGTH - 24; /* confirm message is header, confirm_mac(8 bytes), CFB IV(16 bytes), encrypted part */\n\n\t\t\t\t/* validate the mac over the cipher text */\n\t\t\t\tzrtpChannelContext->hmacFunction(confirmMessageMacKey, zrtpChannelContext->hashLength, messageContent, cipherTextLength, 8, computedHmac);\n\t\t\t\t\n\t\t\t\tif (memcmp(computedHmac, messageData->confirm_mac, 8) != 0) { /* confirm_mac doesn't match */\n\t\t\t\t\tfree(messageData);\n\t\t\t\t\treturn BZRTP_PARSER_ERROR_UNMATCHINGCONFIRMMAC;\n\t\t\t\t}\n\n\t\t\t\t/* get plain message */\n\t\t\t\tconfirmPlainMessageBuffer = (uint8_t *)malloc(cipherTextLength*sizeof(uint8_t));\n\t\t\t\tzrtpChannelContext->cipherDecryptionFunction(confirmMessageKey, messageData->CFBIV, messageContent, cipherTextLength, confirmPlainMessageBuffer);\n\t\t\t\tconfirmPlainMessage = confirmPlainMessageBuffer; /* point into the allocated buffer */\n\n\t\t\t\t/* parse it */\n\t\t\t\tmemcpy(messageData->H0, confirmPlainMessage, 32);\n\t\t\t\tconfirmPlainMessage +=33; /* +33 because next 8 bits are unused */\n\n\t\t\t\t/* Hash chain checking: if we are in multichannel or shared mode, we had not DHPart and then no H1 */\n\t\t\t\tif (zrtpChannelContext->keyAgreementAlgo == ZRTP_KEYAGREEMENT_Prsh || zrtpChannelContext->keyAgreementAlgo == ZRTP_KEYAGREEMENT_Mult) {\n\t\t\t\t\t/* compute the H1=SHA256(H0) we never received */\n\t\t\t\t\tuint8_t checkH1[32];\n\t\t\t\t\tbctoolbox_sha256(messageData->H0, 32, 32, checkH1);\n\n\t\t\t\t\t/* if we are responder, we received a commit packet with H2 then check that H2=SHA256(H1) and that the commit message MAC keyed with H1 match */\n\t\t\t\t\tif ( zrtpChannelContext->role == RESPONDER) {\n\t\t\t\t\t\tuint8_t checkH2[32];\n\t\t\t\t\t\tuint8_t checkMAC[32];\n\t\t\t\t\t\tbzrtpCommitMessage_t *peerCommitMessageData;\n\n\t\t\t\t\t\tif (zrtpChannelContext->peerPackets[COMMIT_MESSAGE_STORE_ID] == NULL) {\n\t\t\t\t\t\t\tfree (messageData);\n\t\t\t\t\t\t\t/* we have no Commit message in this channel, this Confirm2 shall never have arrived, discard it as invalid */\n\t\t\t\t\t\t\treturn BZRTP_PARSER_ERROR_UNEXPECTEDMESSAGE;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpeerCommitMessageData = (bzrtpCommitMessage_t *)zrtpChannelContext->peerPackets[COMMIT_MESSAGE_STORE_ID]->messageData;\n\t\t\t\t\t\t/* Check H2 = SHA256(H1) */\n\t\t\t\t\t\tbctoolbox_sha256(checkH1, 32, 32, checkH2);\n\t\t\t\t\t\tif (memcmp(checkH2, peerCommitMessageData->H2, 32) != 0) {\n\t\t\t\t\t\t\tfree (messageData);\n\t\t\t\t\t\t\treturn BZRTP_PARSER_ERROR_UNMATCHINGHASHCHAIN;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/* Check the Commit MAC message. \n\t\t\t\t\t\t * MAC is 8 bytes long and is computed on the message(skip the ZRTP_PACKET_HEADER) and exclude the mac itself (-8 bytes from message Length) */\n\t\t\t\t\t\tbctoolbox_hmacSha256(checkH1, 32, zrtpChannelContext->peerPackets[COMMIT_MESSAGE_STORE_ID]->packetString+ZRTP_PACKET_HEADER_LENGTH, zrtpChannelContext->peerPackets[COMMIT_MESSAGE_STORE_ID]->messageLength-8, 8, checkMAC);\n\t\t\t\t\t\tif (memcmp(checkMAC, peerCommitMessageData->MAC, 8) != 0) {\n\t\t\t\t\t\t\tfree (messageData);\n\t\t\t\t\t\t\treturn BZRTP_PARSER_ERROR_UNMATCHINGMAC;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else { /* if we are initiator(we didn't received any commit message and then no H2), we must check that H3=SHA256(SHA256(H1)) and the Hello message MAC */\n\t\t\t\t\t\tuint8_t checkH2[32];\n\t\t\t\t\t\tuint8_t checkH3[32];\n\t\t\t\t\t\tuint8_t checkMAC[32];\n\t\t\t\t\t\tbzrtpHelloMessage_t *peerHelloMessageData;\n\n\t\t\t\t\t\tif (zrtpChannelContext->peerPackets[HELLO_MESSAGE_STORE_ID] == NULL) {\n\t\t\t\t\t\t\tfree (messageData);\n\t\t\t\t\t\t\t/* we have no Hello message in this channel, this Confirm1 shall never have arrived, discard it as invalid */\n\t\t\t\t\t\t\treturn BZRTP_PARSER_ERROR_UNEXPECTEDMESSAGE;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpeerHelloMessageData = (bzrtpHelloMessage_t *)zrtpChannelContext->peerPackets[HELLO_MESSAGE_STORE_ID]->messageData;\n\t\t\t\t\t\t/* Check H3 = SHA256(SHA256(H1)) */\n\t\t\t\t\t\tbctoolbox_sha256(checkH1, 32, 32, checkH2);\n\t\t\t\t\t\tbctoolbox_sha256(checkH2, 32, 32, checkH3);\n\t\t\t\t\t\tif (memcmp(checkH3, peerHelloMessageData->H3, 32) != 0) {\n\t\t\t\t\t\t\tfree (messageData);\n\t\t\t\t\t\t\treturn BZRTP_PARSER_ERROR_UNMATCHINGHASHCHAIN;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/* Check the hello MAC message. \n\t\t\t\t\t\t * MAC is 8 bytes long and is computed on the message(skip the ZRTP_PACKET_HEADER) and exclude the mac itself (-8 bytes from message Length) */\n\t\t\t\t\t\tbctoolbox_hmacSha256(checkH2, 32, zrtpChannelContext->peerPackets[HELLO_MESSAGE_STORE_ID]->packetString+ZRTP_PACKET_HEADER_LENGTH, zrtpChannelContext->peerPackets[HELLO_MESSAGE_STORE_ID]->messageLength-8, 8, checkMAC);\n\t\t\t\t\t\tif (memcmp(checkMAC, peerHelloMessageData->MAC, 8) != 0) {\n\t\t\t\t\t\t\tfree (messageData);\n\t\t\t\t\t\t\treturn BZRTP_PARSER_ERROR_UNMATCHINGMAC;\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\t\t\t} else { /* we are in DHM mode */\n\t\t\t\t\t/* We have now H0, check it matches the H1 we had in the DHPart message H1=SHA256(H0) and that the DHPart message MAC is correct */\n\t\t\t\t\tuint8_t checkH1[32];\n\t\t\t\t\tuint8_t checkMAC[32];\n\t\t\t\t\tbzrtpDHPartMessage_t *peerDHPartMessageData;\n\n\t\t\t\t\tif (zrtpChannelContext->peerPackets[DHPART_MESSAGE_STORE_ID] == NULL) {\n\t\t\t\t\t\tfree (messageData);\n\t\t\t\t\t\t/* we have no DHPART message in this channel, this confirm shall never have arrived, discard it as invalid */\n\t\t\t\t\t\treturn BZRTP_PARSER_ERROR_UNEXPECTEDMESSAGE;\n\t\t\t\t\t}\n\t\t\t\t\tpeerDHPartMessageData = (bzrtpDHPartMessage_t *)zrtpChannelContext->peerPackets[DHPART_MESSAGE_STORE_ID]->messageData;\n\t\t\t\t\t/* Check H1 = SHA256(H0) */\n\t\t\t\t\tbctoolbox_sha256(messageData->H0, 32, 32, checkH1);\n\t\t\t\t\tif (memcmp(checkH1, peerDHPartMessageData->H1, 32) != 0) {\n\t\t\t\t\t\tfree (messageData);\n\t\t\t\t\t\treturn BZRTP_PARSER_ERROR_UNMATCHINGHASHCHAIN;\n\t\t\t\t\t}\n\t\t\t\t\t/* Check the DHPart message. \n\t\t\t\t\t * MAC is 8 bytes long and is computed on the message(skip the ZRTP_PACKET_HEADER) and exclude the mac itself (-8 bytes from message Length) */\n\t\t\t\t\tbctoolbox_hmacSha256(messageData->H0, 32, zrtpChannelContext->peerPackets[DHPART_MESSAGE_STORE_ID]->packetString+ZRTP_PACKET_HEADER_LENGTH, zrtpChannelContext->peerPackets[DHPART_MESSAGE_STORE_ID]->messageLength-8, 8, checkMAC);\n\t\t\t\t\tif (memcmp(checkMAC, peerDHPartMessageData->MAC, 8) != 0) {\n\t\t\t\t\t\tfree (messageData);\n\t\t\t\t\t\treturn BZRTP_PARSER_ERROR_UNMATCHINGMAC;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tmessageData->sig_len = ((uint16_t)(confirmPlainMessage[0]&0x01))<<8 | (((uint16_t)confirmPlainMessage[1])&0x00FF);\n\t\t\t\tconfirmPlainMessage += 2;\n\t\t\t\tmessageData->E = ((*confirmPlainMessage)&0x08)>>3;\n\t\t\t\tmessageData->V = ((*confirmPlainMessage)&0x04)>>2;\n\t\t\t\tmessageData->A = ((*confirmPlainMessage)&0x02)>>1;\n\t\t\t\tmessageData->D = (*confirmPlainMessage)&0x01;\n\t\t\t\tconfirmPlainMessage += 1;\n\n\t\t\t\tmessageData->cacheExpirationInterval = (((uint32_t)confirmPlainMessage[0])<<24) | (((uint32_t)confirmPlainMessage[1])<<16) | (((uint32_t)confirmPlainMessage[2])<<8) | ((uint32_t)confirmPlainMessage[3]);\n\t\t\t\tconfirmPlainMessage += 4;\n\n\n\t\t\t\t/* if sig_len indicate a signature, parse it */\n\t\t\t\tif (messageData->sig_len>0) {\n\t\t\t\t\tmemcpy(messageData->signatureBlockType, confirmPlainMessage, 4);\n\t\t\t\t\tconfirmPlainMessage += 4;\n\t\t\t\t\t/* allocate memory for the signature block, sig_len is in words(32 bits) and includes the signature block type word */\n\t\t\t\t\tmessageData->signatureBlock = (uint8_t *)malloc(4*(messageData->sig_len-1)*sizeof(uint8_t));\n\t\t\t\t\tmemcpy(messageData->signatureBlock, confirmPlainMessage, 4*(messageData->sig_len-1));\n\t\t\t\t} else {\n\t\t\t\t\tmessageData->signatureBlock  = NULL;\n\t\t\t\t}\n\n\t\t\t\t/* free plain buffer */\n\t\t\t\tfree(confirmPlainMessageBuffer);\n\n\t\t\t\t/* the parsed commit packet must be saved as it is used to check correct packet repetition */\n\t\t\t\tzrtpPacket->packetString = (uint8_t *)malloc(inputLength*sizeof(uint8_t));\n\t\t\t\tmemcpy(zrtpPacket->packetString, input, inputLength); /* store the whole packet even if we may use the message only */\n\n\t\t\t\t/* attach the message structure to the packet one */\n\t\t\t\tzrtpPacket->messageData = (void *)messageData;\n\t\t\t}\n\t\t\tbreak; /* MSGTYPE_CONFIRM1 and MSGTYPE_CONFIRM2 */\n\n\t\tcase MSGTYPE_CONF2ACK:\n\t\t\t/* nothing to do for this one */\n\t\t\tbreak; /* MSGTYPE_CONF2ACK */\n\t\t\n\t\tcase MSGTYPE_PING:\n\t\t\t{\n\t\t\t\t/* allocate a ping message structure */\n\t\t\t\tbzrtpPingMessage_t *messageData;\n\t\t\t\tmessageData = (bzrtpPingMessage_t *)malloc(sizeof(bzrtpPingMessage_t));\n\n\t\t\t\t/* fill the structure */\n\t\t\t\tmemcpy(messageData->version, messageContent, 4);\n\t\t\t\tmessageContent +=4;\n\t\t\t\tmemcpy(messageData->endpointHash, messageContent, 8);\n\n\t\t\t\t/* attach the message structure to the packet one */\n\t\t\t\tzrtpPacket->messageData = (void *)messageData;\n\t\t\t}\n\t\t\tbreak; /* MSGTYPE_PING */\n\n\t}\n\n\treturn 0;\n}\n\n/* Create the packet string from the messageData contained into the zrtp Packet structure */\nint bzrtp_packetBuild(bzrtpContext_t *zrtpContext, bzrtpChannelContext_t *zrtpChannelContext, bzrtpPacket_t *zrtpPacket, uint16_t sequenceNumber) {\n\t\n\tint i;\n\tuint8_t *messageTypeString;\n\tuint8_t *messageString = NULL; /* will point directly to the begining of the message within the packetString buffer */\n\tuint8_t *MACbuffer = NULL; /* if needed this will point to the beginin of the MAC in the packetString buffer */\n\t/*uint8_t *MACMessageData = NULL; */ /* if needed this will point to the MAC field in the message Data structure */\n\tuint8_t *MACkey = NULL;\n\n\t/* checks */\n\tif (zrtpPacket==NULL) {\n\t\treturn BZRTP_BUILDER_ERROR_INVALIDPACKET;\n\t}\n\n\t/* get the message type (and check it is valid) */\n\tmessageTypeString = messageTypeInttoString(zrtpPacket->messageType);\n\tif (messageTypeString == NULL) {\n\t\treturn BZRTP_BUILDER_ERROR_INVALIDMESSAGETYPE;\n\t}\n\n\t/* create first the message. Header and CRC will be added afterward */\n\tswitch (zrtpPacket->messageType) {\n\t\tcase MSGTYPE_HELLO : \n\t\t\t{\n\t\t\t\tbzrtpHelloMessage_t *messageData;\n\n\t\t\t\t/* get the Hello message structure */\n\t\t\t\tif (zrtpPacket->messageData == NULL) {\n\t\t\t\t\treturn BZRTP_BUILDER_ERROR_INVALIDMESSAGE;\n\t\t\t\t}\n\t\t\t\tmessageData = (bzrtpHelloMessage_t *)zrtpPacket->messageData;\n\n\t\t\t\t/* compute the message length in bytes : fixed length and optionnal algorithms parts */\n\t\t\t\tzrtpPacket->messageLength = ZRTP_HELLOMESSAGE_FIXED_LENGTH + 4*((uint16_t)(messageData->hc)+(uint16_t)(messageData->cc)+(uint16_t)(messageData->ac)+(uint16_t)(messageData->kc)+(uint16_t)(messageData->sc));\n\n\t\t\t\t/* allocate the packetString buffer : packet is header+message+crc */\n\t\t\t\tzrtpPacket->packetString = (uint8_t *)malloc((ZRTP_PACKET_HEADER_LENGTH+zrtpPacket->messageLength+ZRTP_PACKET_CRC_LENGTH)*sizeof(uint8_t));\n\t\t\t\t/* have the messageString pointer to the begining of message(after the message header wich is computed for all messages after the switch)\n\t\t\t\t * within the packetString buffer*/\n\t\t\t\tmessageString = zrtpPacket->packetString + ZRTP_PACKET_HEADER_LENGTH + ZRTP_MESSAGE_HEADER_LENGTH;\n\n\t\t\t\t/* set the version (shall be 1.10), Client identifier, H3, ZID, S,M,P flags and  hc,cc,ac,kc,sc */\n\t\t\t\tmemcpy(messageString, messageData->version, 4);\n\t\t\t\tmessageString += 4;\n\t\t\t\tmemcpy(messageString, messageData->clientIdentifier, 16);\n\t\t\t\tmessageString += 16;\n\t\t\t\tmemcpy(messageString, messageData->H3, 32);\n\t\t\t\tmessageString += 32;\n\t\t\t\tmemcpy(messageString, messageData->ZID, 12);\n\t\t\t\tmessageString += 12;\n\t\t\t\t*messageString = ((((messageData->S)&0x01)<<6) | (((messageData->M)&0x01)<<5) | (((messageData->P)&0x01)<<4))&0x70;\n\t\t\t\tmessageString += 1;\n\t\t\t\t*messageString = (messageData->hc)&0x0F;\n\t\t\t\tmessageString += 1;\n\t\t\t\t*messageString = (((messageData->cc)<<4)&0xF0) | ((messageData->ac)&0x0F) ;\n\t\t\t\tmessageString += 1;\n\t\t\t\t*messageString = (((messageData->kc)<<4)&0xF0) | ((messageData->sc)&0x0F) ;\n\t\t\t\tmessageString += 1;\n\n\t\t\t\t/* now set optionnal supported algorithms */\n\t\t\t\tfor (i=0; i<messageData->hc; i++) {\n\t\t\t\t\tcryptoAlgoTypeIntToString(messageData->supportedHash[i], messageString);\n\t\t\t\t\tmessageString +=4;\n\t\t\t\t}\n\t\t\t\tfor (i=0; i<messageData->cc; i++) {\n\t\t\t\t\tcryptoAlgoTypeIntToString(messageData->supportedCipher[i], messageString);\n\t\t\t\t\tmessageString +=4;\n\t\t\t\t}\n\t\t\t\tfor (i=0; i<messageData->ac; i++) {\n\t\t\t\t\tcryptoAlgoTypeIntToString(messageData->supportedAuthTag[i], messageString);\n\t\t\t\t\tmessageString +=4;\n\t\t\t\t}\n\t\t\t\tfor (i=0; i<messageData->kc; i++) {\n\t\t\t\t\tcryptoAlgoTypeIntToString(messageData->supportedKeyAgreement[i], messageString);\n\t\t\t\t\tmessageString +=4;\n\t\t\t\t}\n\t\t\t\tfor (i=0; i<messageData->sc; i++) {\n\t\t\t\t\tcryptoAlgoTypeIntToString(messageData->supportedSas[i], messageString);\n\t\t\t\t\tmessageString +=4;\n\t\t\t\t}\n\n\t\t\t\t/* there is a MAC to compute, set the pointers to the key and MAC output buffer */\n\t\t\t\tMACbuffer = messageString;\n\t\t\t\tMACkey = zrtpChannelContext->selfH[2]; /* HMAC of Hello packet is keyed by H2 which have been set at context initialising */\n\n\t\t\t}\n\t\t\tbreak; /* MSGTYPE_HELLO */\n\n\t\tcase MSGTYPE_HELLOACK : \n\t\t\t{\n\t\t\t\t/* the message length is fixed */\n\t\t\t\tzrtpPacket->messageLength = ZRTP_HELLOACKMESSAGE_FIXED_LENGTH;\n\n\t\t\t\t/* allocate the packetString buffer : packet is header+message+crc */\n\t\t\t\tzrtpPacket->packetString = (uint8_t *)malloc((ZRTP_PACKET_HEADER_LENGTH+ZRTP_HELLOACKMESSAGE_FIXED_LENGTH+ZRTP_PACKET_CRC_LENGTH)*sizeof(uint8_t));\n\t\t\t}\n\t\t\tbreak; /* MSGTYPE_HELLOACK */\n\n\t\tcase MSGTYPE_COMMIT :\n\t\t\t{\n\t\t\t\tbzrtpCommitMessage_t *messageData;\n\t\t\t\tuint16_t variableLength = 0;\n\n\t\t\t\t/* get the Commit message structure */\n\t\t\t\tif (zrtpPacket->messageData == NULL) {\n\t\t\t\t\treturn BZRTP_BUILDER_ERROR_INVALIDMESSAGE;\n\t\t\t\t}\n\n\t\t\t\tmessageData = (bzrtpCommitMessage_t *)zrtpPacket->messageData;\n\n\t\t\t\t/* compute message length */\n\t\t\t\tswitch(messageData->keyAgreementAlgo) {\n\t\t\t\t\tcase ZRTP_KEYAGREEMENT_DH2k :\n\t\t\t\t\tcase ZRTP_KEYAGREEMENT_EC25 :\n\t\t\t\t\tcase ZRTP_KEYAGREEMENT_DH3k :\n\t\t\t\t\tcase ZRTP_KEYAGREEMENT_EC38 :\n\t\t\t\t\tcase ZRTP_KEYAGREEMENT_EC52 :\n\t\t\t\t\t\tvariableLength = 32; /* hvi is 32 bytes length in DH Commit message format */\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase ZRTP_KEYAGREEMENT_Prsh :\n\t\t\t\t\t\tvariableLength = 24; /* nonce (16 bytes) and keyID(8 bytes) are 24 bytes length in preshared Commit message format */\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase ZRTP_KEYAGREEMENT_Mult :\n\t\t\t\t\t\tvariableLength = 16; /* nonce is 24 bytes length in multistream Commit message format */\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\treturn BZRTP_BUILDER_ERROR_INVALIDMESSAGE;\n\t\t\t\t}\n\t\t\t\tzrtpPacket->messageLength = ZRTP_COMMITMESSAGE_FIXED_LENGTH + variableLength;\n\t\t\t\t\n\t\t\t\t/* allocate the packetString buffer : packet is header+message+crc */\n\t\t\t\tzrtpPacket->packetString = (uint8_t *)malloc((ZRTP_PACKET_HEADER_LENGTH+zrtpPacket->messageLength+ZRTP_PACKET_CRC_LENGTH)*sizeof(uint8_t));\n\t\t\t\t/* have the messageString pointer to the begining of message(after the message header wich is computed for all messages after the switch)\n\t\t\t\t * within the packetString buffer*/\n\t\t\t\tmessageString = zrtpPacket->packetString + ZRTP_PACKET_HEADER_LENGTH + ZRTP_MESSAGE_HEADER_LENGTH;\n\n\t\t\t\t/* now insert the different message parts into the packetString */\n\t\t\t\tmemcpy(messageString, messageData->H2, 32);\n\t\t\t\tmessageString += 32;\n\t\t\t\tmemcpy(messageString, messageData->ZID, 12);\n\t\t\t\tmessageString += 12;\n\t\t\t\tcryptoAlgoTypeIntToString(messageData->hashAlgo, messageString);\n\t\t\t\tmessageString += 4;\n\t\t\t\tcryptoAlgoTypeIntToString(messageData->cipherAlgo, messageString);\n\t\t\t\tmessageString += 4;\n\t\t\t\tcryptoAlgoTypeIntToString(messageData->authTagAlgo, messageString);\n\t\t\t\tmessageString += 4;\n\t\t\t\tcryptoAlgoTypeIntToString(messageData->keyAgreementAlgo, messageString);\n\t\t\t\tmessageString += 4;\n\t\t\t\tcryptoAlgoTypeIntToString(messageData->sasAlgo, messageString);\n\t\t\t\tmessageString += 4;\n\n\t\t\t\t/* if it is a multistream or preshared commit insert the 16 bytes nonce */\n\t\t\t\tif ((messageData->keyAgreementAlgo == ZRTP_KEYAGREEMENT_Prsh) || (messageData->keyAgreementAlgo == ZRTP_KEYAGREEMENT_Mult)) {\n\t\t\t\t\t\tmemcpy(messageString, messageData->nonce, 16);\n\t\t\t\t\t\tmessageString += 16;\n\n\t\t\t\t\t/* and the keyID for preshared commit only */\n\t\t\t\t\tif (messageData->keyAgreementAlgo == ZRTP_KEYAGREEMENT_Prsh) {\n\t\t\t\t\t\tmemcpy(messageString, messageData->keyID, 8);\n\t\t\t\t\t\tmessageString +=8;\n\t\t\t\t\t}\n\t\t\t\t} else { /* it's a DH commit message, set the hvi */\n\t\t\t\t\tmemcpy(messageString, messageData->hvi, 32);\n\t\t\t\t\tmessageString +=32;\n\t\t\t\t}\n\t\t\t\n\t\t\t\t/* there is a MAC to compute, set the pointers to the key and MAC output buffer */\n\t\t\t\tMACbuffer = messageString;\n\t\t\t\tMACkey = zrtpChannelContext->selfH[1]; /* HMAC of Hello packet is keyed by H1 which have been set at context initialising */\n\t\t\t}\n\t\t\tbreak; /*MSGTYPE_COMMIT */\n\n\t\tcase MSGTYPE_DHPART1 :\n\t\tcase MSGTYPE_DHPART2 :\n\t\t\t{\n\t\t\t\tbzrtpDHPartMessage_t *messageData;\n\t\t\t\tuint16_t pvLength;\n\n\t\t\t\t/* get the DHPart message structure */\n\t\t\t\tif (zrtpPacket->messageData == NULL) {\n\t\t\t\t\treturn BZRTP_BUILDER_ERROR_INVALIDMESSAGE;\n\t\t\t\t}\n\n\t\t\t\tmessageData = (bzrtpDHPartMessage_t *)zrtpPacket->messageData;\n\n\t\t\t\t/* compute message length */\n\t\t\t\tpvLength = computeKeyAgreementPrivateValueLength(zrtpChannelContext->keyAgreementAlgo);\n\t\t\t\tif (pvLength==0) {\n\t\t\t\t\treturn BZRTP_BUILDER_ERROR_INVALIDCONTEXT;\n\t\t\t\t}\n\t\t\t\tzrtpPacket->messageLength = ZRTP_DHPARTMESSAGE_FIXED_LENGTH + pvLength;\n\t\t\t\t\n\t\t\t\t/* allocate the packetString buffer : packet is header+message+crc */\n\t\t\t\tzrtpPacket->packetString = (uint8_t *)malloc((ZRTP_PACKET_HEADER_LENGTH+zrtpPacket->messageLength+ZRTP_PACKET_CRC_LENGTH)*sizeof(uint8_t));\n\t\t\t\t/* have the messageString pointer to the begining of message(after the message header wich is computed for all messages after the switch)\n\t\t\t\t * within the packetString buffer*/\n\t\t\t\tmessageString = zrtpPacket->packetString + ZRTP_PACKET_HEADER_LENGTH + ZRTP_MESSAGE_HEADER_LENGTH;\n\n\t\t\t\t/* now insert the different message parts into the packetString */\n\t\t\t\tmemcpy(messageString, messageData->H1, 32);\n\t\t\t\tmessageString += 32;\n\t\t\t\tmemcpy(messageString, messageData->rs1ID, 8);\n\t\t\t\tmessageString += 8;\n\t\t\t\tmemcpy(messageString, messageData->rs2ID, 8);\n\t\t\t\tmessageString += 8;\n\t\t\t\tmemcpy(messageString, messageData->auxsecretID, 8);\n\t\t\t\tmessageString += 8;\n\t\t\t\tmemcpy(messageString, messageData->pbxsecretID, 8);\n\t\t\t\tmessageString += 8;\n\t\t\t\tmemcpy(messageString, messageData->pv, pvLength);\n\t\t\t\tmessageString += pvLength;\n\n\t\t\t\t/* there is a MAC to compute, set the pointers to the key and MAC output buffer */\n\t\t\t\tMACbuffer = messageString;\n\t\t\t\tMACkey = zrtpChannelContext->selfH[0]; /* HMAC of Hello packet is keyed by H0 which have been set at context initialising */\n\t\t\t}\n\t\t\tbreak; /* MSGTYPE_DHPART1 and 2 */\n\t\t\n\t\tcase MSGTYPE_CONFIRM1:\n\t\tcase MSGTYPE_CONFIRM2:\n\t\t\t{\n\t\t\t\tuint8_t *confirmMessageKey = NULL;\n\t\t\t\tuint8_t *confirmMessageMacKey = NULL;\n\t\t\t\tbzrtpConfirmMessage_t *messageData;\n\t\t\t\tuint16_t encryptedPartLength;\n\t\t\t\tuint8_t *plainMessageString;\n\t\t\t\tuint16_t plainMessageStringIndex = 0;\n\n\t\t\t\t/* we will have to encrypt and validate the message, check we have the keys to do it */\n\t\t\t\tif (zrtpChannelContext->role == INITIATOR) {\n\t\t\t\t\tif ((zrtpChannelContext->zrtpkeyi == NULL) || (zrtpChannelContext->mackeyi == NULL)) {\n\t\t\t\t\t\treturn BZRTP_BUILDER_ERROR_INVALIDCONTEXT;\n\t\t\t\t\t}\n\t\t\t\t\tconfirmMessageKey = zrtpChannelContext->zrtpkeyi;\n\t\t\t\t\tconfirmMessageMacKey = zrtpChannelContext->mackeyi;\n\t\t\t\t}\n\n\t\t\t\tif (zrtpChannelContext->role == RESPONDER) {\n\t\t\t\t\tif ((zrtpChannelContext->zrtpkeyr == NULL) || (zrtpChannelContext->mackeyr == NULL)) {\n\t\t\t\t\t\treturn BZRTP_BUILDER_ERROR_INVALIDCONTEXT;\n\t\t\t\t\t}\n\t\t\t\t\tconfirmMessageKey = zrtpChannelContext->zrtpkeyr;\n\t\t\t\t\tconfirmMessageMacKey = zrtpChannelContext->mackeyr;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t/* get the Confirm message structure */\n\t\t\t\tif (zrtpPacket->messageData == NULL) {\n\t\t\t\t\treturn BZRTP_BUILDER_ERROR_INVALIDMESSAGE;\n\t\t\t\t}\n\n\t\t\t\tmessageData = (bzrtpConfirmMessage_t *)zrtpPacket->messageData;\n\n\t\t\t\t/* compute message length */\n\t\t\t\tzrtpPacket->messageLength = ZRTP_CONFIRMMESSAGE_FIXED_LENGTH + messageData->sig_len*4; /* sig_len is in word of 4 bytes */\n\t\t\t\t\n\t\t\t\t/* allocate the packetString buffer : packet is header+message+crc */\n\t\t\t\tzrtpPacket->packetString = (uint8_t *)malloc((ZRTP_PACKET_HEADER_LENGTH+zrtpPacket->messageLength+ZRTP_PACKET_CRC_LENGTH)*sizeof(uint8_t));\n\t\t\t\t/* have the messageString pointer to the begining of message(after the message header wich is computed for all messages after the switch)\n\t\t\t\t * within the packetString buffer*/\n\t\t\t\tmessageString = zrtpPacket->packetString + ZRTP_PACKET_HEADER_LENGTH + ZRTP_MESSAGE_HEADER_LENGTH;\n\n\t\t\t\t/* allocate a temporary buffer to store the plain text */\n\t\t\t\tencryptedPartLength = zrtpPacket->messageLength - ZRTP_MESSAGE_HEADER_LENGTH - 24; /* message header, confirm_mac(8 bytes) and CFB IV(16 bytes) are not encrypted */\n\t\t\t\tplainMessageString = (uint8_t *)malloc(encryptedPartLength*sizeof(uint8_t)); \n\n\t\t\t\t/* fill the plain message buffer with data from the message structure */\n\t\t\t\tmemcpy(plainMessageString, messageData->H0, 32);\n\t\t\t\tplainMessageStringIndex += 32;\n\t\t\t\tplainMessageString[plainMessageStringIndex++] = 0x00;\n\t\t\t\tplainMessageString[plainMessageStringIndex++] = (uint8_t)(((messageData->sig_len)>>8)&0x0001);\n\t\t\t\tplainMessageString[plainMessageStringIndex++] = (uint8_t)((messageData->sig_len)&0x00FF);\n\t\t\t\tplainMessageString[plainMessageStringIndex++] = (uint8_t)((messageData->E&0x01)<<3) | (uint8_t)((messageData->V&0x01)<<2) | (uint8_t)((messageData->A&0x01)<<1) | (uint8_t)(messageData->D&0x01) ;\n\t\t\t\t/* cache expiration in a 32 bits unsigned int */\n\t\t\t\tplainMessageString[plainMessageStringIndex++] = (uint8_t)((messageData->cacheExpirationInterval>>24)&0xFF);\n\t\t\t\tplainMessageString[plainMessageStringIndex++] = (uint8_t)((messageData->cacheExpirationInterval>>16)&0xFF);\n\t\t\t\tplainMessageString[plainMessageStringIndex++] = (uint8_t)((messageData->cacheExpirationInterval>>8)&0xFF);\n\t\t\t\tplainMessageString[plainMessageStringIndex++] = (uint8_t)((messageData->cacheExpirationInterval)&0xFF);\n\n\t\t\t\tif (messageData->sig_len>0) {\n\t\t\t\t\tmemcpy(plainMessageString+plainMessageStringIndex, messageData->signatureBlockType, 4);\n\t\t\t\t\tplainMessageStringIndex += 4;\n\t\t\t\t\t/* sig_len is in 4 bytes words and include the 1 word of signature block type */\n\t\t\t\t\tmemcpy(plainMessageString+plainMessageStringIndex, messageData->signatureBlock, (messageData->sig_len-1)*4);\n\t\t\t\t}\n\n\t\t\t\t/* encrypt the buffer, set the output directly in the messageString buffer at the correct position(+24 after message header) */\n\t\t\t\tzrtpChannelContext->cipherEncryptionFunction(confirmMessageKey, messageData->CFBIV, plainMessageString, encryptedPartLength, messageString+24);\n\t\t\t\tfree(plainMessageString); /* free the plain message string temporary buffer */\n\n\t\t\t\t/* compute the mac over the encrypted part of the message and set the result in the messageString */\n\t\t\t\tzrtpChannelContext->hmacFunction(confirmMessageMacKey, zrtpChannelContext->hashLength, messageString+24, encryptedPartLength, 8, messageString);\n\t\t\t\tmessageString += 8;\n\t\t\t\t/* add the CFB IV */\n\t\t\t\tmemcpy(messageString, messageData->CFBIV, 16);\n\t\t\t}\n\t\t\tbreak; /* MSGTYPE_CONFIRM1 and MSGTYPE_CONFIRM2 */\n\n\t\tcase MSGTYPE_CONF2ACK:\n\t\t\t{\n\t\t\t\t/* the message length is fixed */\n\t\t\t\tzrtpPacket->messageLength = ZRTP_CONF2ACKMESSAGE_FIXED_LENGTH;\n\n\t\t\t\t/* allocate the packetString buffer : packet is header+message+crc */\n\t\t\t\tzrtpPacket->packetString = (uint8_t *)malloc((ZRTP_PACKET_HEADER_LENGTH+ZRTP_CONF2ACKMESSAGE_FIXED_LENGTH+ZRTP_PACKET_CRC_LENGTH)*sizeof(uint8_t));\n\t\t\t}\n\t\t\tbreak; /* MSGTYPE_CONF2ACK */\n\n\t\tcase MSGTYPE_PINGACK:\n\t\t\t{\n\t\t\t\tbzrtpPingAckMessage_t *messageData;\n\n\t\t\t\t/* the message length is fixed */\n\t\t\t\tzrtpPacket->messageLength = ZRTP_PINGACKMESSAGE_FIXED_LENGTH;\n\n\t\t\t\t/* allocate the packetString buffer : packet is header+message+crc */\n\t\t\t\tzrtpPacket->packetString = (uint8_t *)malloc((ZRTP_PACKET_HEADER_LENGTH+ZRTP_PINGACKMESSAGE_FIXED_LENGTH+ZRTP_PACKET_CRC_LENGTH)*sizeof(uint8_t));\n\t\t\t\tmessageString = zrtpPacket->packetString + ZRTP_PACKET_HEADER_LENGTH + ZRTP_MESSAGE_HEADER_LENGTH;\n\n\t\t\t\t/* now insert the different message parts into the packetString */\n\t\t\t\tmessageData = (bzrtpPingAckMessage_t *)zrtpPacket->messageData;\n\n\t\t\t\tmemcpy(messageString, messageData->version, 4);\n\t\t\t\tmessageString += 4;\n\t\t\t\tmemcpy(messageString, messageData->endpointHash, 8);\n\t\t\t\tmessageString += 8;\n\t\t\t\tmemcpy(messageString, messageData->endpointHashReceived, 8);\n\t\t\t\tmessageString += 8;\n\t\t\t\t*messageString++ = (uint8_t)((messageData->SSRC>>24)&0xFF);\n\t\t\t\t*messageString++ = (uint8_t)((messageData->SSRC>>16)&0xFF);\n\t\t\t\t*messageString++ = (uint8_t)((messageData->SSRC>>8)&0xFF);\n\t\t\t\t*messageString++ = (uint8_t)(messageData->SSRC&0xFF);\n\t\t\t}\n\t\t\tbreak; /* MSGTYPE_PINGACK */\n\n\t}\n\n\t/* write headers only if we have a packet string */\n\tif (zrtpPacket->packetString != NULL) {\n\t\tuint32_t CRC;\n\t\tuint8_t *CRCbuffer;\n\n\t\tzrtpMessageSetHeader(zrtpPacket->packetString+ZRTP_PACKET_HEADER_LENGTH, zrtpPacket->messageLength, messageTypeString);\n\n\t\t/* Do we have a MAC to compute on the message ? */\n\t\tif (MACbuffer != NULL) {\n\t\t\t/* compute the MAC(64 bits only) using the implicit HMAC function for ZRTP v1.10: HMAC-SHA256 */\n\t\t\t/* HMAC is computed on the whole message except the MAC itself so a length of zrtpPacket->messageLength-8 */\n\t\t\tbctoolbox_hmacSha256(MACkey, 32, zrtpPacket->packetString+ZRTP_PACKET_HEADER_LENGTH, zrtpPacket->messageLength-8, 8, MACbuffer);\n\t\t}\n\t\n\t\t/* set packet header and CRC */\n\t\t/* preambule */\n\t\tzrtpPacket->packetString[0] = 0x10;\n\t\tzrtpPacket->packetString[1] = 0x00;\n\t\t/* Sequence number */\n\t\tzrtpPacket->packetString[2] = (uint8_t)((sequenceNumber>>8)&0x00FF);\n\t\tzrtpPacket->packetString[3] = (uint8_t)(sequenceNumber&0x00FF);\n\t\t/* ZRTP magic cookie */\n\t\tzrtpPacket->packetString[4] = (uint8_t)((ZRTP_MAGIC_COOKIE>>24)&0xFF);\n\t\tzrtpPacket->packetString[5] = (uint8_t)((ZRTP_MAGIC_COOKIE>>16)&0xFF);\n\t\tzrtpPacket->packetString[6] = (uint8_t)((ZRTP_MAGIC_COOKIE>>8)&0xFF);\n\t\tzrtpPacket->packetString[7] = (uint8_t)(ZRTP_MAGIC_COOKIE&0xFF);\n\t\t/* Source Identifier */\n\t\tzrtpPacket->packetString[8] = (uint8_t)(((zrtpPacket->sourceIdentifier)>>24)&0xFF);\n\t\tzrtpPacket->packetString[9] = (uint8_t)(((zrtpPacket->sourceIdentifier)>>16)&0xFF);\n\t\tzrtpPacket->packetString[10] = (uint8_t)(((zrtpPacket->sourceIdentifier)>>8)&0xFF);\n\t\tzrtpPacket->packetString[11] = (uint8_t)((zrtpPacket->sourceIdentifier)&0xFF);\n\t\t/* CRC */\n\t\tCRC = bzrtp_CRC32(zrtpPacket->packetString, zrtpPacket->messageLength+ZRTP_PACKET_HEADER_LENGTH);\n\t\tCRCbuffer = (zrtpPacket->packetString)+(zrtpPacket->messageLength)+ZRTP_PACKET_HEADER_LENGTH;\n\t\t*CRCbuffer = (uint8_t)((CRC>>24)&0xFF);\n\t\tCRCbuffer++;\n\t\t*CRCbuffer = (uint8_t)((CRC>>16)&0xFF);\n\t\tCRCbuffer++;\n\t\t*CRCbuffer = (uint8_t)((CRC>>8)&0xFF);\n\t\tCRCbuffer++;\n\t\t*CRCbuffer = (uint8_t)(CRC&0xFF);\n\t\n\t\treturn 0;\n\t} else { /* no packetString allocated something wen't wrong but we shall never arrive here */\n\t\treturn BZRTP_BUILDER_ERROR_UNKNOWN;\n\t}\n}\n\n/* create a zrtpPacket and initialise it's structures */\nbzrtpPacket_t *bzrtp_createZrtpPacket(bzrtpContext_t *zrtpContext, bzrtpChannelContext_t *zrtpChannelContext, uint32_t messageType, int *exitCode) {\n\t/* allocate packet */\n\tbzrtpPacket_t *zrtpPacket = (bzrtpPacket_t *)malloc(sizeof(bzrtpPacket_t));\n\tmemset(zrtpPacket, 0, sizeof(bzrtpPacket_t));\n\tzrtpPacket->messageData = NULL;\n\tzrtpPacket->packetString = NULL;\n\n\t/* initialise it */\n\tswitch(messageType) {\n\t\tcase MSGTYPE_HELLO:\n\t\t\t{\n\t\t\t\tint i;\n\t\t\t\tbzrtpHelloMessage_t *zrtpHelloMessage = (bzrtpHelloMessage_t *)malloc(sizeof(bzrtpHelloMessage_t));\n\t\t\t\tmemset(zrtpHelloMessage, 0, sizeof(bzrtpHelloMessage_t));\n\t\t\t\t/* initialise some fields using zrtp context data */\n\t\t\t\tmemcpy(zrtpHelloMessage->version, ZRTP_VERSION, 4);\n\t\t\t\tstrncpy((char*)zrtpHelloMessage->clientIdentifier, ZRTP_CLIENT_IDENTIFIER, 16);\n\t\t\t\tmemcpy(zrtpHelloMessage->H3, zrtpChannelContext->selfH[3], 32);\n\t\t\t\tmemcpy(zrtpHelloMessage->ZID, zrtpContext->selfZID, 12);\n\t\t\t\t/* set all S,M,P flags to zero as we're not able to verify signatures, we're not a PBX(TODO: implement?), we're not passive */\n\t\t\t\tzrtpHelloMessage->S = 0;\n\t\t\t\tzrtpHelloMessage->M = 0;\n\t\t\t\tzrtpHelloMessage->P = 0;\n\n\t\t\t\t/* get the algorithm availabilities from the context */\n\t\t\t\tzrtpHelloMessage->hc = zrtpContext->hc;\n\t\t\t\tzrtpHelloMessage->cc = zrtpContext->cc;\n\t\t\t\tzrtpHelloMessage->ac = zrtpContext->ac;\n\t\t\t\tzrtpHelloMessage->kc = zrtpContext->kc;\n\t\t\t\tzrtpHelloMessage->sc = zrtpContext->sc;\n\n\t\t\t\tfor (i=0; i<zrtpContext->hc; i++) {\n\t\t\t\t\tzrtpHelloMessage->supportedHash[i] = zrtpContext->supportedHash[i];\n\t\t\t\t}\n\t\t\t\tfor (i=0; i<zrtpContext->cc; i++) {\n\t\t\t\t\tzrtpHelloMessage->supportedCipher[i] = zrtpContext->supportedCipher[i];\n\t\t\t\t}\n\t\t\t\tfor (i=0; i<zrtpContext->ac; i++) {\n\t\t\t\t\tzrtpHelloMessage->supportedAuthTag[i] = zrtpContext->supportedAuthTag[i];\n\t\t\t\t}\n\t\t\t\tfor (i=0; i<zrtpContext->kc; i++) {\n\t\t\t\t\tzrtpHelloMessage->supportedKeyAgreement[i] = zrtpContext->supportedKeyAgreement[i];\n\t\t\t\t}\n\t\t\t\tfor (i=0; i<zrtpContext->sc; i++) {\n\t\t\t\t\tzrtpHelloMessage->supportedSas[i] = zrtpContext->supportedSas[i];\n\t\t\t\t}\n\n\t\t\t\t/* attach the message data to the packet */\n\t\t\t\tzrtpPacket->messageData = zrtpHelloMessage;\n\t\t\t}\n\t\t\tbreak; /* MSGTYPE_HELLO */\n\n\t\tcase MSGTYPE_HELLOACK :\n\t\t\t{\n\t\t\t\t/* nothing to do for the Hello ACK packet as it just contains it's type */\n\t\t\t}\n\t\t\tbreak; /* MSGTYPE_HELLOACK */\n\t\t/* In case of DH commit, this one must be called after the DHPart build and the self DH message and peer Hello message are stored in the context */\n\t\tcase MSGTYPE_COMMIT :\n\t\t\t{\n\t\t\t\tbzrtpCommitMessage_t *zrtpCommitMessage = (bzrtpCommitMessage_t *)malloc(sizeof(bzrtpCommitMessage_t));\n\t\t\t\tmemset(zrtpCommitMessage, 0, sizeof(bzrtpCommitMessage_t));\n\t\t\t\t\n\t\t\t\t/* initialise some fields using zrtp context data */\n\t\t\t\tmemcpy(zrtpCommitMessage->H2, zrtpChannelContext->selfH[2], 32);\n\t\t\t\tmemcpy(zrtpCommitMessage->ZID, zrtpContext->selfZID, 12);\n\t\t\t\tzrtpCommitMessage->hashAlgo = zrtpChannelContext->hashAlgo;\n\t\t\t\tzrtpCommitMessage->cipherAlgo = zrtpChannelContext->cipherAlgo;\n\t\t\t\tzrtpCommitMessage->authTagAlgo = zrtpChannelContext->authTagAlgo;\n\t\t\t\tzrtpCommitMessage->keyAgreementAlgo = zrtpChannelContext->keyAgreementAlgo;\n\t\t\t\tzrtpCommitMessage->sasAlgo = zrtpChannelContext->sasAlgo;\n\n\t\t\t\t/* if it is a multistream or preshared commit create a 16 random bytes nonce */\n\t\t\t\tif ((zrtpCommitMessage->keyAgreementAlgo == ZRTP_KEYAGREEMENT_Prsh) || (zrtpCommitMessage->keyAgreementAlgo == ZRTP_KEYAGREEMENT_Mult)) {\n\t\t\t\t\tbctoolbox_rng_get(zrtpContext->RNGContext, zrtpCommitMessage->nonce, 16);\n\n\t\t\t\t\t/* and the keyID for preshared commit only */\n\t\t\t\t\tif (zrtpCommitMessage->keyAgreementAlgo == ZRTP_KEYAGREEMENT_Prsh) {\n\t\t\t\t\t\t/* TODO at this point we must first compute the preShared key - make sure at least rs1 is present */\n\t\t\t\t\t\t/* preshared_key = hash(len(rs1) || rs1 || len(auxsecret) || auxsecret ||\n                       len(pbxsecret) || pbxsecret) using the agreed hash and store it into the env */\n\t\t\t\t\t\t/* and then the keyID : MAC(preshared_key, \"Prsh\") truncated to 64 bits using the agreed MAC */\n\t\t\t\t\t}\n\t\t\t\t} else { /* it's a DH commit message, set the hvi */\n\t\t\t\t\t/* hvi = hash(initiator's DHPart2 message || responder's Hello message) using the agreed hash function truncated to 256 bits */\n\t\t\t\t\t/* create a string with the messages concatenated */\n\t\t\t\t\tuint16_t DHPartMessageLength = zrtpChannelContext->selfPackets[DHPART_MESSAGE_STORE_ID]->messageLength;\n\t\t\t\t\tuint16_t HelloMessageLength = zrtpChannelContext->peerPackets[HELLO_MESSAGE_STORE_ID]->messageLength;\n\t\t\t\t\tuint16_t DHPartHelloMessageStringLength = DHPartMessageLength + HelloMessageLength;\n\n\t\t\t\t\tuint8_t *DHPartHelloMessageString = (uint8_t *)malloc(DHPartHelloMessageStringLength*sizeof(uint8_t));\n\t\t\t\t\t\n\t\t\t\t\tmemcpy(DHPartHelloMessageString, zrtpChannelContext->selfPackets[DHPART_MESSAGE_STORE_ID]->packetString+ZRTP_PACKET_HEADER_LENGTH, DHPartMessageLength);\n\t\t\t\t\tmemcpy(DHPartHelloMessageString+DHPartMessageLength, zrtpChannelContext->peerPackets[HELLO_MESSAGE_STORE_ID]->packetString+ZRTP_PACKET_HEADER_LENGTH, HelloMessageLength);\n\n\t\t\t\t\tzrtpChannelContext->hashFunction(DHPartHelloMessageString, DHPartHelloMessageStringLength, 32, zrtpCommitMessage->hvi);\n\n\t\t\t\t\tfree(DHPartHelloMessageString);\n\t\t\t\t}\n\n\t\t\t\t/* attach the message data to the packet */\n\t\t\t\tzrtpPacket->messageData = zrtpCommitMessage;\n\t\t\t}\n\t\t\tbreak; /* MSGTYPE_COMMIT */\n\n\t\t/* this one is called after the exchange of Hello messages when the crypto algo agreement have been performed */\n\t\tcase MSGTYPE_DHPART1 :\n\t\tcase MSGTYPE_DHPART2 :\n\t\t\t{\n\t\t\t\tuint8_t secretLength; /* is in bytes */\n\t\t\t\tuint8_t bctoolbox_keyAgreementAlgo = BCTOOLBOX_DHM_UNSET;\n\t\t\t\tbzrtpDHPartMessage_t *zrtpDHPartMessage = (bzrtpDHPartMessage_t *)malloc(sizeof(bzrtpDHPartMessage_t));\n\t\t\t\tmemset(zrtpDHPartMessage, 0, sizeof(bzrtpDHPartMessage_t));\n\t\t\t\t/* initialise some fields using zrtp context data */\n\t\t\t\tmemcpy(zrtpDHPartMessage->H1, zrtpChannelContext->selfH[1], 32);\n\t\t\t\t/* get the retained secret from context, we anyway create a DHPart2 packet that we may turn into a DHPart1 packet if we end to \n\t\t\t\t * be the responder and not the initiator, use the initiator retained secret hashes */\n\t\t\t\tmemcpy(zrtpDHPartMessage->rs1ID, zrtpContext->initiatorCachedSecretHash.rs1ID, 8);\n\t\t\t\tmemcpy(zrtpDHPartMessage->rs2ID, zrtpContext->initiatorCachedSecretHash.rs2ID, 8);\n\t\t\t\tmemcpy(zrtpDHPartMessage->auxsecretID, zrtpChannelContext->initiatorAuxsecretID, 8);\n\t\t\t\tmemcpy(zrtpDHPartMessage->pbxsecretID, zrtpContext->initiatorCachedSecretHash.pbxsecretID, 8);\n\t\t\t\t\n\t\t\t\t/* compute the public value and insert it in the message, will then be used whatever role - initiator or responder - we assume */\n\t\t\t\t/* initialise the dhm context, secret length shall be twice the size of cipher block key length - rfc section 5.1.5 */\n\t\t\t\tswitch (zrtpChannelContext->cipherAlgo) {\n\t\t\t\t\tcase ZRTP_CIPHER_AES3:\n\t\t\t\t\tcase ZRTP_CIPHER_2FS3:\n\t\t\t\t\t\tsecretLength = 64;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase ZRTP_CIPHER_AES2:\n\t\t\t\t\tcase ZRTP_CIPHER_2FS2:\n\t\t\t\t\t\tsecretLength = 48;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase ZRTP_CIPHER_AES1:\n\t\t\t\t\tcase ZRTP_CIPHER_2FS1:\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tsecretLength = 32;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tswitch (zrtpChannelContext->keyAgreementAlgo) {\n\t\t\t\t\tcase ZRTP_KEYAGREEMENT_DH2k:\n\t\t\t\t\t\tbctoolbox_keyAgreementAlgo = BCTOOLBOX_DHM_2048;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase ZRTP_KEYAGREEMENT_DH3k:\n\t\t\t\t\t\tbctoolbox_keyAgreementAlgo = BCTOOLBOX_DHM_3072;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tfree(zrtpPacket);\n\t\t\t\t\t\tfree(zrtpDHPartMessage);\n\t\t\t\t\t\t*exitCode = BZRTP_CREATE_ERROR_UNABLETOCREATECRYPTOCONTEXT;\n\t\t\t\t\t\treturn NULL;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tzrtpContext->DHMContext = bctoolbox_CreateDHMContext(bctoolbox_keyAgreementAlgo, secretLength);\n\t\t\t\tif (zrtpContext->DHMContext == NULL) {\n\t\t\t\t\tfree(zrtpPacket);\n\t\t\t\t\tfree(zrtpDHPartMessage);\n\t\t\t\t\t*exitCode = BZRTP_CREATE_ERROR_UNABLETOCREATECRYPTOCONTEXT;\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\n\t\t\t\t/* now compute the public value */\n\t\t\t\tbctoolbox_DHMCreatePublic(zrtpContext->DHMContext, (int (*)(void *, uint8_t *, size_t))bctoolbox_rng_get, zrtpContext->RNGContext);\n\t\t\t\tzrtpDHPartMessage->pv = (uint8_t *)malloc((zrtpChannelContext->keyAgreementLength)*sizeof(uint8_t));\n\t\t\t\tmemcpy(zrtpDHPartMessage->pv, zrtpContext->DHMContext->self, zrtpChannelContext->keyAgreementLength);\n\n\t\t\t\t/* attach the message data to the packet */\n\t\t\t\tzrtpPacket->messageData = zrtpDHPartMessage;\n\t\t\t}\n\t\t\tbreak; /* MSGTYPE_DHPART1 and MSGTYPE_DHPART2 */\n\n\t\tcase MSGTYPE_CONFIRM1:\n\t\tcase MSGTYPE_CONFIRM2:\n\t\t\t{\n\t\t\t\tbzrtpConfirmMessage_t *zrtpConfirmMessage = (bzrtpConfirmMessage_t *)malloc(sizeof(bzrtpConfirmMessage_t));\n\t\t\t\tmemset(zrtpConfirmMessage, 0, sizeof(bzrtpConfirmMessage_t));\n\t\t\t\t/* initialise some fields using zrtp context data */\n\t\t\t\tmemcpy(zrtpConfirmMessage->H0, zrtpChannelContext->selfH[0], 32);\n\t\t\t\tzrtpConfirmMessage->sig_len = 0; /* signature is not supported */\n\t\t\t\tzrtpConfirmMessage->cacheExpirationInterval = 0xFFFFFFFF; /* expiration interval is set to unlimited as recommended in rfc section 4.9 */\n\t\t\t\tzrtpConfirmMessage->E = 0; /* we are not a PBX and then will never signal an enrollment - rfc section 7.3.1 */\n\t\t\t\tzrtpConfirmMessage->V = zrtpContext->cachedSecret.previouslyVerifiedSas;\n\t\t\t\tzrtpConfirmMessage->A = 0; /* Go clear message is not supported - rfc section 4.7.2 */\n\t\t\t\tzrtpConfirmMessage->D = 0; /* The is no backdoor in our implementation of ZRTP - rfc section 11 */\n\n\t\t\t\t/* generate a random CFB IV */\n\t\t\t\tbctoolbox_rng_get(zrtpContext->RNGContext, zrtpConfirmMessage->CFBIV, 16);\n\n\t\t\t\t/* attach the message data to the packet */\n\t\t\t\tzrtpPacket->messageData = zrtpConfirmMessage;\n\t\t\t}\n\t\t\tbreak; /* MSGTYPE_CONFIRM1 and MSGTYPE_CONFIRM2 */\n\n\t\tcase MSGTYPE_CONF2ACK :\n\t\t\t{\n\t\t\t\t/* nothing to do for the conf2ACK packet as it just contains it's type */\n\t\t\t}\n\t\t\tbreak; /* MSGTYPE_CONF2ACK */\n\t\tcase MSGTYPE_PINGACK:\n\t\t\t{\n\t\t\t\tbzrtpPingMessage_t *pingMessage;\n\t\t\t\tbzrtpPingAckMessage_t *zrtpPingAckMessage;\n\n\t\t\t\t/* to create a pingACK we must have a ping packet in the channel context, check it */\n\t\t\t\tbzrtpPacket_t *pingPacket = zrtpChannelContext->pingPacket;\n\t\t\t\tif (pingPacket == NULL) {\n\t\t\t\t\t*exitCode = BZRTP_CREATE_ERROR_INVALIDCONTEXT;\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t\tpingMessage = (bzrtpPingMessage_t *)pingPacket->messageData;\n\n\t\t\t\t/* create the message */\n\t\t\t\tzrtpPingAckMessage = (bzrtpPingAckMessage_t *)malloc(sizeof(bzrtpPingAckMessage_t));\n\t\t\t\tmemset(zrtpPingAckMessage, 0, sizeof(bzrtpPingAckMessage_t));\n\n\t\t\t\t/* initialise all fields using zrtp context data and the received ping message */\n\t\t\t\tmemcpy(zrtpPingAckMessage->version,ZRTP_VERSION , 4); /* we support version 1.10 only, so no need to even check what was sent in the ping */\n\t\t\t\tmemcpy(zrtpPingAckMessage->endpointHash, zrtpContext->selfZID, 8); /* as suggested in rfc section 5.16, use the truncated ZID as endPoint hash */\n\t\t\t\tmemcpy(zrtpPingAckMessage->endpointHashReceived, pingMessage->endpointHash, 8);\n\t\t\t\tzrtpPingAckMessage->SSRC = pingPacket->sourceIdentifier;\n\n\t\t\t\t/* attach the message data to the packet */\n\t\t\t\tzrtpPacket->messageData = zrtpPingAckMessage;\n\t\t\t} /* MSGTYPE_PINGACK */\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tfree(zrtpPacket);\n\t\t\t*exitCode = BZRTP_CREATE_ERROR_INVALIDMESSAGETYPE;\n\t\t\treturn NULL;\n\t\t\tbreak;\n\t}\n\n\tzrtpPacket->sequenceNumber = 0; /* this field is not used buy the packet creator, sequence number is given as a parameter when converting\n\tthe message to a packet string(packet build). Used only when parsing a string into a packet struct */\n\tzrtpPacket->messageType = messageType;\n\tzrtpPacket->sourceIdentifier = zrtpChannelContext->selfSSRC;\n\tzrtpPacket->messageLength = 0; /* length will be computed at packet build */\n\tzrtpPacket->packetString = NULL;\n\n\t*exitCode=0;\n\treturn zrtpPacket;\n}\n\nvoid bzrtp_freeZrtpPacket(bzrtpPacket_t *zrtpPacket) {\n\tif (zrtpPacket != NULL) {\n\t\t/* some messages have fields to be freed */\n\t\tif (zrtpPacket->messageData != NULL) {\n\t\t\tswitch(zrtpPacket->messageType) {\n\t\t\t\tcase MSGTYPE_DHPART1 :\n\t\t\t\tcase MSGTYPE_DHPART2 :\n\t\t\t\t\t{\n\t\t\t\t\t\tbzrtpDHPartMessage_t *typedMessageData = (bzrtpDHPartMessage_t *)(zrtpPacket->messageData);\n\t\t\t\t\t\tif (typedMessageData != NULL) {\n\t\t\t\t\t\t\tfree(typedMessageData->pv);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase MSGTYPE_CONFIRM1:\n\t\t\t\tcase MSGTYPE_CONFIRM2:\n\t\t\t\t\t{\n\t\t\t\t\t\tbzrtpConfirmMessage_t *typedMessageData = (bzrtpConfirmMessage_t *)(zrtpPacket->messageData);\n\t\t\t\t\t\tif (typedMessageData != NULL) {\n\t\t\t\t\t\t\tfree(typedMessageData->signatureBlock);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfree(zrtpPacket->messageData);\n\t\tfree(zrtpPacket->packetString);\n\t\tfree(zrtpPacket);\n\t}\n}\n\n/**\n * @brief Modify the current sequence number of the packet in the packetString and sequenceNumber fields\n * The CRC at the end of packetString is also updated\n * \n * param[in/out]\tzrtpPacket\t\tThe zrtpPacket to modify, the packetString must have been generated by\n * \t\t\t\t\t\t\t\t\ta call to bzrtp_packetBuild on this packet\n * param[in]\t\tsequenceNumber\tThe new sequence number to insert in the packetString\n * \n * return\t\t0 on succes, error code otherwise\n */\nint bzrtp_packetUpdateSequenceNumber(bzrtpPacket_t *zrtpPacket, uint16_t sequenceNumber) {\n\tuint32_t CRC;\n\tuint8_t *CRCbuffer;\n\n\tif (zrtpPacket == NULL) {\n\t\treturn BZRTP_BUILDER_ERROR_INVALIDPACKET;\n\t}\n\n\tif (zrtpPacket->packetString == NULL) {\n\t\treturn BZRTP_BUILDER_ERROR_INVALIDPACKET;\n\t}\n\t/* update the sequence number field (even if it is probably useless as this function is called just before sending the DHPart2 packet only)*/\n\tzrtpPacket->sequenceNumber = sequenceNumber;\n\n\t/* update hte sequence number in the packetString */\n\t*(zrtpPacket->packetString+2)= (uint8_t)((sequenceNumber>>8)&0x00FF);\n\t*(zrtpPacket->packetString+3)= (uint8_t)(sequenceNumber&0x00FF);\n\n\n\t/* update the CRC */\n\tCRC = bzrtp_CRC32(zrtpPacket->packetString, zrtpPacket->messageLength+ZRTP_PACKET_HEADER_LENGTH);\n\tCRCbuffer = (zrtpPacket->packetString)+(zrtpPacket->messageLength)+ZRTP_PACKET_HEADER_LENGTH;\n\t*CRCbuffer = (uint8_t)((CRC>>24)&0xFF);\n\tCRCbuffer++;\n\t*CRCbuffer = (uint8_t)((CRC>>16)&0xFF);\n\tCRCbuffer++;\n\t*CRCbuffer = (uint8_t)((CRC>>8)&0xFF);\n\tCRCbuffer++;\n\t*CRCbuffer = (uint8_t)(CRC&0xFF);\n\n\treturn 0;\n}\n\n\n/*** Local functions implementation ***/\n\nuint8_t *messageTypeInttoString(uint32_t messageType) {\n\n\tswitch(messageType) {\n\t\tcase MSGTYPE_HELLO : \n\t\t\treturn (uint8_t *)\"Hello   \";\n\t\t\tbreak;\n\t\tcase MSGTYPE_HELLOACK : \n\t\t\treturn (uint8_t *)\"HelloACK\";\n\t\t\tbreak;\n\t\tcase MSGTYPE_COMMIT : \n\t\t\treturn (uint8_t *)\"Commit  \";\n\t\t\tbreak;\n\t\tcase MSGTYPE_DHPART1 : \n\t\t\treturn (uint8_t *)\"DHPart1 \";\n\t\t\tbreak;\n\t\tcase MSGTYPE_DHPART2 : \n\t\t\treturn (uint8_t *)\"DHPart2 \";\n\t\t\tbreak;\n\t\tcase MSGTYPE_CONFIRM1 : \n\t\t\treturn (uint8_t *)\"Confirm1\";\n\t\t\tbreak;\n\t\tcase MSGTYPE_CONFIRM2 : \n\t\t\treturn (uint8_t *)\"Confirm2\";\n\t\t\tbreak;\n\t\tcase MSGTYPE_CONF2ACK : \n\t\t\treturn (uint8_t *)\"Conf2ACK\";\n\t\t\tbreak;\n\t\tcase MSGTYPE_ERROR : \n\t\t\treturn (uint8_t *)\"Error   \";\n\t\t\tbreak;\n\t\tcase MSGTYPE_ERRORACK : \n\t\t\treturn (uint8_t *)\"ErrorACK\";\n\t\t\tbreak;\n\t\tcase MSGTYPE_GOCLEAR : \n\t\t\treturn (uint8_t *)\"GoClear \";\n\t\t\tbreak;\n\t\tcase MSGTYPE_CLEARACK : \n\t\t\treturn (uint8_t *)\"ClearACK\";\n\t\t\tbreak;\n\t\tcase MSGTYPE_SASRELAY : \n\t\t\treturn (uint8_t *)\"SASrelay\";\n\t\t\tbreak;\n\t\tcase MSGTYPE_RELAYACK : \n\t\t\treturn (uint8_t *)\"RelayACK\";\n\t\t\tbreak;\n\t\tcase MSGTYPE_PING : \n\t\t\treturn (uint8_t *)\"Ping    \";\n\t\t\tbreak;\n\t\tcase MSGTYPE_PINGACK : \n\t\t\treturn (uint8_t *)\"PingACK \";\n\t\t\tbreak;\n\t}\n\treturn NULL;\n}\n\n/*\n * @brief Map the 8 char string value message type to an int32_t\n *\n * @param[in] messageTypeString\t\tan 8 bytes string matching a zrtp message type\n *\n * @return\ta 32-bits unsigned integer mapping the message type\n */\nint32_t messageTypeStringtoInt(uint8_t messageTypeString[8]) {\n\tif (memcmp(messageTypeString, \"Hello   \", 8) == 0) {\n\t\treturn MSGTYPE_HELLO;\n\t} else if (memcmp(messageTypeString, \"HelloACK\", 8) == 0) {\n\t\treturn MSGTYPE_HELLOACK;\n\t} else if (memcmp(messageTypeString, \"Commit  \", 8) == 0) {\n\t\treturn MSGTYPE_COMMIT;\n\t} else if (memcmp(messageTypeString, \"DHPart1 \", 8) == 0) {\n\t\treturn MSGTYPE_DHPART1;\n\t} else if (memcmp(messageTypeString, \"DHPart2 \", 8) == 0) {\n\t\treturn MSGTYPE_DHPART2;\n\t} else if (memcmp(messageTypeString, \"Confirm1\", 8) == 0) {\n\t\treturn MSGTYPE_CONFIRM1;\n\t} else if (memcmp(messageTypeString, \"Confirm2\", 8) == 0) {\n\t\treturn MSGTYPE_CONFIRM2;\n\t} else if (memcmp(messageTypeString, \"Conf2ACK\", 8) == 0) {\n\t\treturn MSGTYPE_CONF2ACK;\n\t} else if (memcmp(messageTypeString, \"Error   \", 8) == 0) {\n\t\treturn MSGTYPE_ERROR;\n\t} else if (memcmp(messageTypeString, \"ErrorACK\", 8) == 0) {\n\t\treturn MSGTYPE_ERRORACK;\n\t} else if (memcmp(messageTypeString, \"GoClear \", 8) == 0) {\n\t\treturn MSGTYPE_GOCLEAR;\n\t} else if (memcmp(messageTypeString, \"ClearACK\", 8) == 0) {\n\t\treturn MSGTYPE_CLEARACK;\n\t} else if (memcmp(messageTypeString, \"SASrelay\", 8) == 0) {\n\t\treturn MSGTYPE_SASRELAY;\n\t} else if (memcmp(messageTypeString, \"RelayACK\", 8) == 0) {\n\t\treturn MSGTYPE_RELAYACK;\n\t} else if (memcmp(messageTypeString, \"Ping    \", 8) == 0) {\n\t\treturn MSGTYPE_PING;\n\t} else if (memcmp(messageTypeString, \"PingACK \", 8) == 0) {\n\t\treturn MSGTYPE_PINGACK;\n\t} else {\n\t\treturn MSGTYPE_INVALID;\n\t}\n}\n\n/*\n * @brief Write the message header(preambule, length, message type) into the given output buffer\n *\n * @param[out]\toutputBuffer\t\tMessage starts at the begining of this buffer\n * @param[in]\tmessageLength\t\tMessage length in bytes! To be converted into 32bits words before being inserted in the message header\n * @param[in]\tmessageType\t\t\tAn 8 chars string for the message type (validity is not checked by this function)\n *\n */\nvoid zrtpMessageSetHeader(uint8_t *outputBuffer, uint16_t messageLength, uint8_t messageType[8]) {\n\t/* insert the preambule */\n\toutputBuffer[0] = 0x50;\n\toutputBuffer[1] = 0x5a;\n\n\t/* then the length in 32 bits words (param is in bytes, so >> 2) */\n\toutputBuffer[2] = (uint8_t)((messageLength>>10)&0x00FF);\n\toutputBuffer[3] = (uint8_t)((messageLength>>2)&0x00FF);\n\n\t/* the message type */\n\tmemcpy(outputBuffer+4, messageType, 8);\n}\n\n/*\n * Return the variable private value length in bytes according to given key agreement algorythm\n *\n * @param[in]\tkeyAgreementAlgo\tThe key agreement algo mapped to an integer as defined in cryptoWrapper.h\n *\n * @return\t\tthe private value length in bytes\n *\n */\nuint16_t computeKeyAgreementPrivateValueLength(uint8_t keyAgreementAlgo) {\n\n\tuint16_t pvLength = 0;\n\tswitch (keyAgreementAlgo) {\n\t\tcase ZRTP_KEYAGREEMENT_DH3k\t:\n\t\t\tpvLength = 384;\n\t\t\tbreak;\n\t\tcase ZRTP_KEYAGREEMENT_DH2k :\n\t\t\tpvLength = 256;\n\t\t\tbreak;\n\t\tcase ZRTP_KEYAGREEMENT_EC25\t:\n\t\t\tpvLength = 64;\n\t\t\tbreak;\n\t\tcase ZRTP_KEYAGREEMENT_EC38\t:\n\t\t\tpvLength = 96;\n\t\t\tbreak;\n\t\tcase ZRTP_KEYAGREEMENT_EC52 :\n\t\t\tpvLength = 132;\n\t\t\tbreak;\n\t\tdefault :\n\t\t\tpvLength = 0;\n\t\t\tbreak;\n\t}\n\n\treturn pvLength;\n}\n", "/**\n @file bzrtpParserTests.c\n @brief Test parsing and building ZRTP packet.\n\n @author Johan Pascal\n\n @copyright Copyright (C) 2014 Belledonne Communications, Grenoble, France\n\n This program is free software; you can redistribute it and/or\n modify it under the terms of the GNU General Public License\n as published by the Free Software Foundation; either version 2\n of the License, or (at your option) any later version.\n\n This program is distributed in the hope that it will be useful,\n but WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n GNU General Public License for more details.\n\n You should have received a copy of the GNU General Public License\n along with this program; if not, write to the Free Software\n Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <errno.h>\n#include \"CUnit/Basic.h\"\n\n#ifndef _WIN32\n#include <time.h>\n#else\n#include <windows.h>\n#endif\n\n#include \"bzrtp/bzrtp.h\"\n#include \"typedef.h\"\n#include \"packetParser.h\"\n#include \"cryptoUtils.h\"\n#include \"zidCache.h\"\n#include \"testUtils.h\"\n\n\n/**\n * Test pattern : the packet data in the patternZRTPPackets, length, sequence number and SSRC in patternZRTPMetaData\n * Pattern generated from wireshark trace\n *\n */\n#define TEST_PACKET_NUMBER 9\n/* meta data: length, sequence number, SSRC */\nstatic uint32_t patternZRTPMetaData[TEST_PACKET_NUMBER][3] = {\n\t{136, 0x09f1, 0x12345678}, /* hello */\n\t{136, 0x02ce, 0x87654321}, /* hello */\n\t{28, 0x09f2, 0x12345678}, /* hello ack */\n\t{132, 0x02d0, 0x87654321}, /* commit */\n\t{484, 0x09f5, 0x12345678}, /* dhpart1 */\n\t{484, 0x02d1, 0x87654321}, /* dhpart2 */\n\t{92, 0x09f6, 0x12345678}, /* confirm 1 */\n\t{92, 0x02d2, 0x87654321}, /* confirm 2 */\n\t{28, 0x09f7, 0x12345678} /* conf2ACK*/\n};\n\nstatic const uint8_t patternZRTPPackets[TEST_PACKET_NUMBER][512] = {\n\t/* This is a Hello packet, sequence number is 0x09f1, SSRC 0x12345678 */\n\t{0x10, 0x00, 0x09, 0xf1, 0x5a, 0x52, 0x54, 0x50, 0x12, 0x34, 0x56, 0x78, 0x50, 0x5a, 0x00, 0x1e, 0x48, 0x65, 0x6c, 0x6c, 0x6f, 0x20, 0x20, 0x20, 0x31, 0x2e, 0x31, 0x30, 0x4c, 0x49, 0x4e, 0x50, 0x48, 0x4f, 0x4e, 0x45, 0x2d, 0x5a, 0x52, 0x54, 0x50, 0x43, 0x50, 0x50, 0xe8, 0xd5, 0x26, 0xc1, 0x3a, 0x0c, 0x4c, 0x6a, 0xce, 0x18, 0xaa, 0xc7, 0xc4, 0xa4, 0x07, 0x0e, 0x65, 0x7a, 0x4d, 0xca, 0x78, 0xf2, 0xcc, 0xcd, 0x20, 0x50, 0x38, 0x73, 0xe9, 0x7e, 0x08, 0x29, 0x7e, 0xb0, 0x04, 0x97, 0xc0, 0xfe, 0xb2, 0xc9, 0x24, 0x31, 0x49, 0x7f, 0x00, 0x01, 0x12, 0x31, 0x53, 0x32, 0x35, 0x36, 0x41, 0x45, 0x53, 0x31, 0x48, 0x53, 0x33, 0x32, 0x48, 0x53, 0x38, 0x30, 0x44, 0x48, 0x33, 0x6b, 0x44, 0x48, 0x32, 0x6b, 0x4d, 0x75, 0x6c, 0x74, 0x42, 0x33, 0x32, 0x20, 0xa0, 0xfd, 0x0f, 0xad, 0xeb, 0xe0, 0x86, 0x56, 0xe3, 0x65, 0x81, 0x02},\n\t/* This is a Hello packet, sequence number is 0x02ce, SSRC 0x87654321 */\n\t{0x10, 0x00, 0x02, 0xce, 0x5a, 0x52, 0x54, 0x50, 0x87, 0x65, 0x43, 0x21, 0x50, 0x5a, 0x00, 0x1e, 0x48, 0x65, 0x6c, 0x6c, 0x6f, 0x20, 0x20, 0x20, 0x31, 0x2e, 0x31, 0x30, 0x4c, 0x49, 0x4e, 0x50, 0x48, 0x4f, 0x4e, 0x45, 0x2d, 0x5a, 0x52, 0x54, 0x50, 0x43, 0x50, 0x50, 0x8d, 0x0f, 0x5a, 0x20, 0x79, 0x97, 0x42, 0x01, 0x99, 0x45, 0x45, 0xf7, 0x0e, 0x31, 0x06, 0xe1, 0x05, 0xc0, 0xb9, 0x24, 0xe9, 0xc9, 0x78, 0xc7, 0x38, 0xf5, 0x97, 0x48, 0xef, 0x42, 0x6a, 0x3e, 0x92, 0x42, 0xc2, 0xcf, 0x44, 0xee, 0x9c, 0x65, 0xca, 0x58, 0x78, 0xf1, 0x00, 0x01, 0x12, 0x31, 0x53, 0x32, 0x35, 0x36, 0x41, 0x45, 0x53, 0x31, 0x48, 0x53, 0x33, 0x32, 0x48, 0x53, 0x38, 0x30, 0x44, 0x48, 0x33, 0x6b, 0x44, 0x48, 0x32, 0x6b, 0x4d, 0x75, 0x6c, 0x74, 0x42, 0x33, 0x32, 0x20, 0xb3, 0x90, 0x91, 0x95, 0xe4, 0x67, 0xa3, 0x21, 0xe3, 0x5f, 0x9c, 0x92},\n\t/* This is a Hello ack packet, sequence number is 0x09f2, SSRC 0x12345678*/\n\t{0x10, 0x00, 0x09, 0xf2, 0x5a, 0x52, 0x54, 0x50, 0x12, 0x34, 0x56, 0x78, 0x50, 0x5a, 0x00, 0x03, 0x48, 0x65, 0x6c, 0x6c, 0x6f, 0x41, 0x43, 0x4b, 0x77, 0x0e, 0x44, 0x07},\n\t/* This is a Commit packet, sequence number is 0x02d0, SSRC 0x87654321 */\n\t{0x10, 0x00, 0x02, 0xd0, 0x5a, 0x52, 0x54, 0x50, 0x87, 0x65, 0x43, 0x21, 0x50, 0x5a, 0x00, 0x1d, 0x43, 0x6f, 0x6d, 0x6d, 0x69, 0x74, 0x20, 0x20, 0xd9, 0xff, 0x14, 0x8b, 0x34, 0xaa, 0x69, 0xe9, 0x33, 0xc1, 0x62, 0xe6, 0x6b, 0xe8, 0xcd, 0x9d, 0xe3, 0x0f, 0xb7, 0x6a, 0xe8, 0x6a, 0x62, 0x2b, 0xcb, 0xe4, 0x6b, 0x91, 0x05, 0xc7, 0xc8, 0x7e, 0x92, 0x42, 0xc2, 0xcf, 0x44, 0xee, 0x9c, 0x65, 0xca, 0x58, 0x78, 0xf1, 0x53, 0x32, 0x35, 0x36, 0x41, 0x45, 0x53, 0x31, 0x48, 0x53, 0x33, 0x32, 0x44, 0x48, 0x33, 0x6b, 0x42, 0x33, 0x32, 0x20, 0x1e, 0xc0, 0xfe, 0x2e, 0x72, 0x06, 0x4d, 0xfb, 0xfc, 0x92, 0x02, 0x8c, 0x03, 0x0f, 0xb8, 0xf8, 0x91, 0xb4, 0xe7, 0x96, 0xac, 0x25, 0xfd, 0xf9, 0x68, 0xc6, 0xe9, 0x67, 0xa9, 0x42, 0xb1, 0x5b, 0xbb, 0x6d, 0x9c, 0xd2, 0x4b, 0x13, 0xa9, 0xae, 0x25, 0x5c, 0xa9, 0xc1},\n\t/* This is a DHPart1 packet, sequence number is 0x09f5, SSRC 0x12345678 */\n\t{0x10, 0x00, 0x09, 0xf5, 0x5a, 0x52, 0x54, 0x50, 0x12, 0x34, 0x56, 0x78, 0x50, 0x5a, 0x00, 0x75, 0x44, 0x48, 0x50, 0x61, 0x72, 0x74, 0x31, 0x20, 0x28, 0x7c, 0x28, 0xe4, 0xd7, 0x3d, 0x14, 0x39, 0xb5, 0x6d, 0x1c, 0x47, 0x9d, 0x59, 0x0a, 0xf2, 0x10, 0x33, 0xde, 0x6b, 0xd5, 0x2b, 0xfb, 0x26, 0xa5, 0x87, 0x4d, 0xe9, 0x20, 0x6b, 0x9f, 0xdd, 0xab, 0xbc, 0xc6, 0x8d, 0xbd, 0x5d, 0xe6, 0x67, 0x00, 0x69, 0x44, 0xb1, 0x84, 0x2c, 0x27, 0x10, 0x8c, 0x4e, 0x58, 0x8a, 0xed, 0x7e, 0x8b, 0x44, 0x2c, 0x3a, 0x13, 0x02, 0xdf, 0x58, 0xb6, 0xda, 0x80, 0x55, 0xec, 0xb0, 0x20, 0xc7, 0x76, 0x50, 0xc4, 0x1b, 0xa8, 0x26, 0x11, 0x5c, 0xf5, 0x71, 0x7e, 0xb4, 0x86, 0x22, 0x17, 0xde, 0x14, 0x08, 0x46, 0x5c, 0xac, 0x88, 0x8c, 0x41, 0x6b, 0x95, 0x22, 0xba, 0xf8, 0x3e, 0x67, 0x20, 0x94, 0xa0, 0x84, 0xa3, 0x93, 0x41, 0x9a, 0x1a, 0x7c, 0x2f, 0x04, 0xf4, 0x14, 0x3f, 0x11, 0x54, 0x02, 0xba, 0xee, 0xc2, 0x20, 0xfa, 0x38, 0xf7, 0xba, 0xa4, 0xbf, 0x4a, 0x70, 0x02, 0x68, 0xdc, 0xb2, 0xe9, 0x1a, 0x8a, 0x87, 0xa5, 0xe4, 0x9c, 0x42, 0x07, 0x82, 0x26, 0xb4, 0xda, 0xe3, 0x1b, 0xdc, 0x78, 0xc7, 0xd8, 0xa8, 0x00, 0x5c, 0x00, 0x14, 0xe4, 0x00, 0xfe, 0x6c, 0x2d, 0xce, 0x62, 0xc9, 0x71, 0x5d, 0xed, 0x4e, 0x66, 0x9f, 0xf5, 0x30, 0xc0, 0x04, 0x53, 0xf6, 0x15, 0x2f, 0xe1, 0x85, 0x3b, 0xd9, 0x40, 0x9b, 0x50, 0x07, 0x43, 0x7c, 0x36, 0x01, 0xa1, 0xda, 0x66, 0xc4, 0x20, 0x2f, 0x45, 0xc0, 0xcc, 0xb2, 0x64, 0x63, 0x9c, 0x07, 0x9d, 0x23, 0x27, 0x80, 0xa1, 0x7f, 0xc2, 0xe0, 0xa0, 0xfd, 0xc3, 0x98, 0x83, 0xa3, 0xaa, 0x6b, 0xdc, 0x9f, 0x6a, 0xc3, 0x32, 0x94, 0xf0, 0x80, 0xa0, 0xd9, 0xf1, 0x83, 0x41, 0x48, 0xa9, 0xb5, 0xed, 0x62, 0x50, 0x88, 0xec, 0x33, 0x32, 0xd2, 0x5f, 0xdc, 0xcc, 0xae, 0xc9, 0x74, 0xca, 0x0a, 0xab, 0x82, 0x06, 0x01, 0x46, 0x35, 0x30, 0xcd, 0x68, 0xec, 0x09, 0xab, 0x8c, 0xb0, 0x39, 0xe5, 0xd8, 0x5c, 0xa2, 0xe4, 0x82, 0xfe, 0x46, 0x01, 0xbd, 0xe7, 0x7f, 0x60, 0x1b, 0x50, 0x62, 0xfb, 0x6f, 0xee, 0x6c, 0xf1, 0xf7, 0x9b, 0xb7, 0x1c, 0x76, 0x48, 0xb5, 0xbe, 0xa5, 0x83, 0x73, 0x07, 0xa2, 0xe2, 0x73, 0xc7, 0x68, 0x34, 0xc8, 0xef, 0x12, 0xc4, 0x32, 0xdf, 0x37, 0x3d, 0xdc, 0x07, 0x0e, 0xa6, 0x92, 0x82, 0xbd, 0xba, 0x20, 0xc4, 0xb4, 0x8d, 0x1f, 0x19, 0x1c, 0x15, 0x0f, 0x5f, 0x01, 0xdf, 0x67, 0x1f, 0x59, 0xd1, 0x5e, 0x99, 0x60, 0xf6, 0xb8, 0x67, 0xe2, 0x46, 0x62, 0x11, 0x30, 0xfb, 0x81, 0x9d, 0x0b, 0xec, 0x36, 0xe9, 0x8d, 0x43, 0xfe, 0x55, 0xd9, 0x61, 0x98, 0x3f, 0x2e, 0x39, 0x6a, 0x26, 0x43, 0xb0, 0x6d, 0x08, 0xec, 0x2e, 0x42, 0x7e, 0x23, 0x82, 0x6f, 0xd9, 0xbb, 0xfd, 0x0a, 0xcd, 0x48, 0xe7, 0xd5, 0x8b, 0xa5, 0x80, 0x34, 0xca, 0x96, 0x4f, 0x58, 0x25, 0xba, 0x43, 0x5e, 0x3d, 0x1c, 0xee, 0x72, 0xb8, 0x35, 0x8c, 0x5d, 0xd9, 0x69, 0x24, 0x58, 0x36, 0x21, 0xb0, 0x45, 0xa4, 0xad, 0x40, 0xda, 0x94, 0x98, 0x0f, 0xb1, 0xed, 0x6c, 0xad, 0x26, 0x03, 0x04, 0x82, 0xff, 0x15, 0x00, 0x41, 0x87, 0x06, 0x93, 0xd4, 0x86, 0xa9, 0x7e, 0xb8, 0xd9, 0x70, 0x34, 0x6d, 0x8e, 0x6a, 0x16, 0xe2, 0x46, 0x52, 0xb0, 0x78, 0x54, 0x53, 0xaf},\n\t/* This is a DHPart2 packet, sequence number is 0x02d1, SSRC 0x87654321 */\n\t{0x10, 0x00, 0x02, 0xd1, 0x5a, 0x52, 0x54, 0x50, 0x87, 0x65, 0x43, 0x21, 0x50, 0x5a, 0x00, 0x75, 0x44, 0x48, 0x50, 0x61, 0x72, 0x74, 0x32, 0x20, 0x9e, 0xb2, 0xa5, 0x8b, 0xe8, 0x96, 0x37, 0xf5, 0x5a, 0x41, 0x34, 0xb2, 0xec, 0xda, 0x84, 0x95, 0xf0, 0xf8, 0x9b, 0xab, 0x61, 0x4f, 0x7c, 0x9e, 0x56, 0xb7, 0x3b, 0xd3, 0x46, 0xba, 0xbe, 0x9a, 0xae, 0x97, 0x97, 0xda, 0x5f, 0x9f, 0x89, 0xba, 0xfe, 0x61, 0x66, 0x5f, 0x9e, 0xa4, 0x5b, 0xcb, 0xd5, 0x69, 0xcf, 0xfb, 0xfd, 0xdc, 0xac, 0x79, 0xac, 0x1d, 0x0b, 0xe5, 0x15, 0x75, 0x39, 0x2e, 0xe5, 0xa9, 0x2a, 0x60, 0xd7, 0xe3, 0x48, 0xd0, 0x1f, 0xd8, 0x61, 0x65, 0xfd, 0x2e, 0x5c, 0xef, 0x43, 0xf5, 0x63, 0x99, 0xb3, 0x45, 0x25, 0xe3, 0xbc, 0xf0, 0xe1, 0xad, 0xf7, 0x84, 0xcd, 0x82, 0x20, 0xe3, 0x6f, 0x2c, 0x77, 0x51, 0xf1, 0x11, 0x2e, 0x4a, 0x2c, 0xfd, 0x2f, 0x5e, 0x74, 0xa9, 0x37, 0x99, 0xff, 0xf7, 0x4c, 0x2d, 0xa8, 0xcf, 0x51, 0xfd, 0x5b, 0xe7, 0x51, 0x14, 0x6d, 0xbc, 0x2f, 0x5b, 0xb9, 0x77, 0x85, 0xad, 0xb4, 0x72, 0x99, 0xad, 0x7b, 0x6c, 0x6a, 0xdf, 0x4d, 0xca, 0x2f, 0xef, 0x8b, 0x5e, 0x4b, 0xf3, 0xd9, 0xfd, 0xbd, 0x47, 0x1a, 0x72, 0xe2, 0x41, 0xd8, 0xfa, 0xa1, 0x25, 0x00, 0xa3, 0xfe, 0x12, 0xda, 0xf6, 0x16, 0xb3, 0xb3, 0x08, 0x02, 0xfd, 0x0a, 0x6a, 0xab, 0x85, 0x17, 0xd7, 0x0f, 0xf4, 0x6b, 0xdf, 0x8f, 0xe2, 0x05, 0xf4, 0x5b, 0x13, 0x26, 0xa9, 0xe2, 0x57, 0xb6, 0xda, 0x76, 0x17, 0x3c, 0x52, 0x13, 0x8d, 0x83, 0xc0, 0x2b, 0xe7, 0x2e, 0xbd, 0xb0, 0xde, 0x98, 0x4f, 0x7a, 0x95, 0xa1, 0x75, 0x19, 0x6e, 0xda, 0x19, 0xff, 0x7f, 0xdd, 0x70, 0x01, 0x12, 0x3c, 0x9e, 0xd7, 0xfe, 0xc3, 0x22, 0x39, 0xce, 0x4f, 0x86, 0xd8, 0x85, 0x40, 0x75, 0xd4, 0xfe, 0x93, 0x57, 0xbc, 0x9b, 0x01, 0xa4, 0x71, 0x35, 0x70, 0x9d, 0x62, 0x91, 0x47, 0x4e, 0x32, 0xa2, 0x76, 0x16, 0x06, 0xaf, 0xc7, 0xe3, 0xe5, 0xdc, 0x25, 0xac, 0xe7, 0x68, 0x25, 0x69, 0x0f, 0x97, 0x8d, 0x91, 0x32, 0x81, 0x23, 0xb1, 0x08, 0xf3, 0xa3, 0x2b, 0x3d, 0xfb, 0xcf, 0x99, 0x12, 0x0a, 0x59, 0xb9, 0xbb, 0x76, 0x16, 0x71, 0xa2, 0x0b, 0x0a, 0x5a, 0x6c, 0x37, 0x99, 0x9d, 0xe6, 0x3a, 0x05, 0x89, 0xf7, 0xc6, 0xfc, 0xf3, 0xfe, 0x36, 0x97, 0x77, 0x86, 0xe4, 0x7c, 0x48, 0x93, 0x0b, 0x26, 0x8e, 0x31, 0xe9, 0x22, 0xcc, 0xd3, 0xe0, 0x56, 0x29, 0xc8, 0x26, 0xe6, 0x1f, 0xa8, 0xb8, 0x93, 0x98, 0xec, 0xd9, 0x7c, 0x4a, 0x45, 0xd3, 0x71, 0x35, 0x9f, 0x14, 0xc1, 0x99, 0xd5, 0x21, 0x0b, 0xfa, 0x0f, 0xfb, 0x31, 0x7a, 0xa0, 0x70, 0x35, 0xb3, 0x9b, 0x1b, 0xe7, 0x65, 0xfd, 0xe3, 0x7d, 0x0b, 0xcc, 0x34, 0x4b, 0xf1, 0x5a, 0x9f, 0x19, 0xa4, 0x8f, 0xc8, 0x30, 0xf1, 0x87, 0x99, 0xc2, 0x75, 0x55, 0x2a, 0x34, 0xd7, 0x81, 0x9c, 0x54, 0x12, 0x82, 0x69, 0x5f, 0x8b, 0x01, 0xc1, 0x45, 0x95, 0xf5, 0xb1, 0x2d, 0x27, 0x0d, 0xa9, 0xc3, 0x93, 0x54, 0x2f, 0x57, 0x04, 0x7b, 0x20, 0xb7, 0xac, 0x33, 0x68, 0xb3, 0xef, 0x9a, 0x33, 0x95, 0x82, 0x9d, 0xfa, 0x2a, 0xb9, 0x88, 0x06, 0x04, 0x88, 0x51, 0x2c, 0x46, 0xdb, 0x83, 0xd7, 0x2f, 0xea, 0x1f, 0x0f, 0x24, 0xab, 0x03, 0xef, 0xb0, 0x61, 0xc7, 0x90, 0xdc, 0x78, 0x17, 0xf2, 0x9a, 0xab},\n\t/* This is a confirm1 packet, sequence number is 0x09f6, SSRC 0x12345678 */\n\t{0x10, 0x00, 0x09, 0xf6, 0x5a, 0x52, 0x54, 0x50, 0x12, 0x34, 0x56, 0x78, 0x50, 0x5a, 0x00, 0x13, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x72, 0x6d, 0x31, 0xb1, 0x21, 0xee, 0xe2, 0x67, 0xa4, 0xfd, 0xa6, 0x94, 0x24, 0x9a, 0x60, 0xf0, 0x2e, 0x5e, 0xd9, 0x33, 0xe1, 0xd8, 0x41, 0x54, 0xa3, 0x7c, 0xea, 0xe9, 0x61, 0xae, 0xf9, 0x19, 0x0d, 0xb3, 0x68, 0x68, 0x9e, 0xf8, 0x1a, 0x18, 0x91, 0x87, 0xc5, 0x6e, 0x5e, 0x2d, 0x5e, 0x32, 0xa2, 0xb2, 0x66, 0x31, 0xb8, 0xe5, 0x59, 0xc9, 0x10, 0xbb, 0xa0, 0x00, 0x6c, 0xee, 0x0c, 0x6d, 0xfb, 0xeb, 0x32, 0x85, 0xb6, 0x6e, 0x93},\n\t/* This is a confirm2 packet, sequence number is 0x02d2, SSRC 0x87654321 */\n\t{0x10, 0x00, 0x02, 0xd2, 0x5a, 0x52, 0x54, 0x50, 0x87, 0x65, 0x43, 0x21, 0x50, 0x5a, 0x00, 0x13, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x72, 0x6d, 0x32, 0x0f, 0xec, 0xfa, 0x4b, 0x45, 0x17, 0x9d, 0xb3, 0x92, 0x7d, 0x1c, 0x53, 0x86, 0x01, 0x12, 0xd9, 0x25, 0x48, 0xca, 0x18, 0xb9, 0x10, 0x95, 0x04, 0xb7, 0xc8, 0xee, 0x87, 0x2b, 0xec, 0x59, 0x39, 0x92, 0x96, 0x11, 0x73, 0xa6, 0x69, 0x2b, 0x11, 0xcd, 0x1d, 0xa1, 0x73, 0xb2, 0xc9, 0x29, 0x6f, 0x82, 0x32, 0x6a, 0x0a, 0x56, 0x40, 0x57, 0xfb, 0xac, 0xab, 0x20, 0xb8, 0xe2, 0xa9, 0x2c, 0x61, 0x6a, 0x05, 0xe8, 0xb5},\n\t/* This is a conf2ACK packet, sequence number 0x09f7, SSRC 0x12345678 */\n\t{0x10, 0x00, 0x09, 0xf7, 0x5a, 0x52, 0x54, 0x50, 0x12, 0x34, 0x56, 0x78, 0x50, 0x5a, 0x00, 0x03, 0x43, 0x6f, 0x6e, 0x66, 0x32, 0x41, 0x43, 0x4b, 0x23, 0xc1, 0x1b, 0x45},\n};\n\n/* Hash images for both sides */\nuint8_t H12345678[4][32] = {\n\t{0xbb, 0xbf, 0x7e, 0xb1, 0x14, 0xd5, 0xd4, 0x0c, 0x6b, 0xb0, 0x79, 0x58, 0x19, 0xc1, 0xd0, 0x83, 0xc9, 0xe1, 0xf4, 0x2e, 0x11, 0xcd, 0x7e, 0xc3, 0xaa, 0xd8, 0xb9, 0x17, 0xe6, 0xb5, 0x9e, 0x86},\n\t{0x28, 0x7c, 0x28, 0xe4, 0xd7, 0x3d, 0x14, 0x39, 0xb5, 0x6d, 0x1c, 0x47, 0x9d, 0x59, 0x0a, 0xf2, 0x10, 0x33, 0xde, 0x6b, 0xd5, 0x2b, 0xfb, 0x26, 0xa5, 0x87, 0x4d, 0xe9, 0x20, 0x6b, 0x9f, 0xdd},\n\t{0x70, 0x12, 0xef, 0x2e, 0x85, 0x2f, 0xfc, 0x84, 0xb8, 0x8d, 0xcc, 0x03, 0xd7, 0x8f, 0x53, 0x01, 0x63, 0xfb, 0xd3, 0xb0, 0x2d, 0xbb, 0x9e, 0x98, 0x22, 0x0d, 0xe3, 0xe3, 0x64, 0x25, 0x04, 0x0f},\n\t{0xe8, 0xd5, 0x26, 0xc1, 0x3a, 0x0c, 0x4c, 0x6a, 0xce, 0x18, 0xaa, 0xc7, 0xc4, 0xa4, 0x07, 0x0e, 0x65, 0x7a, 0x4d, 0xca, 0x78, 0xf2, 0xcc, 0xcd, 0x20, 0x50, 0x38, 0x73, 0xe9, 0x7e, 0x08, 0x29}\n};\n\nuint8_t H87654321[4][32] = {\n\t{0x09, 0x02, 0xcc, 0x13, 0xc4, 0x84, 0x03, 0x31, 0x68, 0x91, 0x05, 0x4d, 0xe0, 0x6d, 0xf4, 0xc9, 0x6a, 0xb5, 0xbe, 0x82, 0xe8, 0x37, 0x33, 0xb7, 0xa9, 0xce, 0xbe, 0xb5, 0x42, 0xaa, 0x54, 0xba},\n\t{0x9e, 0xb2, 0xa5, 0x8b, 0xe8, 0x96, 0x37, 0xf5, 0x5a, 0x41, 0x34, 0xb2, 0xec, 0xda, 0x84, 0x95, 0xf0, 0xf8, 0x9b, 0xab, 0x61, 0x4f, 0x7c, 0x9e, 0x56, 0xb7, 0x3b, 0xd3, 0x46, 0xba, 0xbe, 0x9a},\n\t{0xd9, 0xff, 0x14, 0x8b, 0x34, 0xaa, 0x69, 0xe9, 0x33, 0xc1, 0x62, 0xe6, 0x6b, 0xe8, 0xcd, 0x9d, 0xe3, 0x0f, 0xb7, 0x6a, 0xe8, 0x6a, 0x62, 0x2b, 0xcb, 0xe4, 0x6b, 0x91, 0x05, 0xc7, 0xc8, 0x7e},\n\t{0x8d, 0x0f, 0x5a, 0x20, 0x79, 0x97, 0x42, 0x01, 0x99, 0x45, 0x45, 0xf7, 0x0e, 0x31, 0x06, 0xe1, 0x05, 0xc0, 0xb9, 0x24, 0xe9, 0xc9, 0x78, 0xc7, 0x38, 0xf5, 0x97, 0x48, 0xef, 0x42, 0x6a, 0x3e}\n};\n\n/* mac and zrtp keys */\nuint8_t mackeyi[32] = {0xdc, 0x47, 0xe1, 0xc7, 0x48, 0x11, 0xb1, 0x54, 0x14, 0x2a, 0x91, 0x29, 0x9f, 0xa4, 0x8b, 0x45, 0x87, 0x16, 0x8d, 0x3a, 0xe6, 0xb0, 0x0c, 0x08, 0x4f, 0xa5, 0x48, 0xd5, 0x96, 0x67, 0x1a, 0x1b};\nuint8_t mackeyr[32] = {0x3a, 0xa5, 0x22, 0x43, 0x26, 0x13, 0x8f, 0xd6, 0x54, 0x59, 0x40, 0xb8, 0x5c, 0xf4, 0x0f, 0x0c, 0xbc, 0x9c, 0x4f, 0x7d, 0x55, 0xeb, 0x4b, 0xa5, 0x1e, 0x1c, 0x42, 0xd0, 0x5e, 0xac, 0x12, 0x06};\nuint8_t zrtpkeyi[16] = {0x22, 0xf6, 0xea, 0xaa, 0xa4, 0xad, 0x53, 0x30, 0x71, 0x97, 0xcc, 0x68, 0x6b, 0xb0, 0xcb, 0x55};\nuint8_t zrtpkeyr[16] = {0x09, 0x50, 0xcd, 0x9e, 0xc2, 0x78, 0x54, 0x31, 0x93, 0x2e, 0x99, 0x31, 0x15, 0x58, 0xd0, 0x2a};\n\n\nvoid test_parser_param(uint8_t hvi_trick) {\n\tint i, retval;\n\tbzrtpPacket_t *zrtpPacket;\n\n\t/* Create zrtp Context to use H0-H3 chains and others */\n\tbzrtpContext_t *context87654321 = bzrtp_createBzrtpContext(0x87654321);\n\tbzrtpContext_t *context12345678 = bzrtp_createBzrtpContext(0x12345678);\n\n\n\t/* replace created H by the patterns one to be able to generate the correct packet */\n\tmemcpy (context12345678->channelContext[0]->selfH[0], H12345678[0], 32);\n\tmemcpy (context12345678->channelContext[0]->selfH[1], H12345678[1], 32);\n\tmemcpy (context12345678->channelContext[0]->selfH[2], H12345678[2], 32);\n\tmemcpy (context12345678->channelContext[0]->selfH[3], H12345678[3], 32);\n\tmemcpy (context87654321->channelContext[0]->selfH[0], H87654321[0], 32);\n\tmemcpy (context87654321->channelContext[0]->selfH[1], H87654321[1], 32);\n\tmemcpy (context87654321->channelContext[0]->selfH[2], H87654321[2], 32);\n\tmemcpy (context87654321->channelContext[0]->selfH[3], H87654321[3], 32);\n\n\t/* preset the key agreement algo in the contexts */\n\tcontext87654321->channelContext[0]->keyAgreementAlgo = ZRTP_KEYAGREEMENT_DH3k;\n\tcontext12345678->channelContext[0]->keyAgreementAlgo = ZRTP_KEYAGREEMENT_DH3k;\n\tcontext87654321->channelContext[0]->cipherAlgo = ZRTP_CIPHER_AES1;\n\tcontext12345678->channelContext[0]->cipherAlgo = ZRTP_CIPHER_AES1;\n\tcontext87654321->channelContext[0]->hashAlgo = ZRTP_HASH_S256;\n\tcontext12345678->channelContext[0]->hashAlgo = ZRTP_HASH_S256;\n\n\tupdateCryptoFunctionPointers(context87654321->channelContext[0]);\n\tupdateCryptoFunctionPointers(context12345678->channelContext[0]);\n\n\t/* set the zrtp and mac keys */\n\tcontext87654321->channelContext[0]->mackeyi = (uint8_t *)malloc(32);\n\tcontext12345678->channelContext[0]->mackeyi = (uint8_t *)malloc(32);\n\tcontext87654321->channelContext[0]->mackeyr = (uint8_t *)malloc(32);\n\tcontext12345678->channelContext[0]->mackeyr = (uint8_t *)malloc(32);\n\n\tcontext87654321->channelContext[0]->zrtpkeyi = (uint8_t *)malloc(16);\n\tcontext12345678->channelContext[0]->zrtpkeyi = (uint8_t *)malloc(16);\n\tcontext87654321->channelContext[0]->zrtpkeyr = (uint8_t *)malloc(16);\n\tcontext12345678->channelContext[0]->zrtpkeyr = (uint8_t *)malloc(16);\n\n\tmemcpy(context12345678->channelContext[0]->mackeyi, mackeyi, 32);\n\tmemcpy(context12345678->channelContext[0]->mackeyr, mackeyr, 32);\n\tmemcpy(context12345678->channelContext[0]->zrtpkeyi, zrtpkeyi, 16);\n\tmemcpy(context12345678->channelContext[0]->zrtpkeyr, zrtpkeyr, 16);\n\tmemcpy(context87654321->channelContext[0]->mackeyi, mackeyi, 32);\n\tmemcpy(context87654321->channelContext[0]->mackeyr, mackeyr, 32);\n\tmemcpy(context87654321->channelContext[0]->zrtpkeyi, zrtpkeyi, 16);\n\tmemcpy(context87654321->channelContext[0]->zrtpkeyr, zrtpkeyr, 16);\n\n\t/* set the role: 87654321 is initiator in our exchange pattern */\n\tcontext12345678->channelContext[0]->role = RESPONDER;\n\n\tfor (i=0; i<TEST_PACKET_NUMBER; i++) {\n\t\tuint8_t freePacketFlag = 1;\n\t\t/* parse a packet string from patterns */\n\t\tzrtpPacket = bzrtp_packetCheck(patternZRTPPackets[i], patternZRTPMetaData[i][0], (patternZRTPMetaData[i][1])-1, &retval);\n\t\tretval +=  bzrtp_packetParser((patternZRTPMetaData[i][2]==0x87654321)?context12345678:context87654321, (patternZRTPMetaData[i][2]==0x87654321)?context12345678->channelContext[0]:context87654321->channelContext[0], patternZRTPPackets[i], patternZRTPMetaData[i][0], zrtpPacket);\n\t\tif (hvi_trick==0) {\n\t\t\tCU_ASSERT_EQUAL_FATAL(retval,0);\n\t\t} else { /* when hvi trick is enable, the DH2 parsing shall fail and return BZRTP_PARSER_ERROR_UNMATCHINGHVI */\n\t\t\tif (zrtpPacket->messageType==MSGTYPE_DHPART2) {\n\t\t\t\tCU_ASSERT_EQUAL_FATAL(retval, BZRTP_PARSER_ERROR_UNMATCHINGHVI);\n\t\t\t\t/* We shall then anyway skip the end of the test */\n\t\t\t\t/* reset pointers to selfHello packet in order to avoid double free */\n\t\t\t\tcontext87654321->channelContext[0]->selfPackets[HELLO_MESSAGE_STORE_ID] = NULL;\n\t\t\t\tcontext12345678->channelContext[0]->selfPackets[HELLO_MESSAGE_STORE_ID] = NULL;\n\n\t\t\t\tbzrtp_destroyBzrtpContext(context87654321, 0x87654321);\n\t\t\t\tbzrtp_destroyBzrtpContext(context12345678, 0x12345678);\n\n\t\t\t\treturn;\n\n\t\t\t} else {\n\t\t\t\tCU_ASSERT_EQUAL_FATAL(retval,0);\n\t\t\t}\n\t\t}\n\t\t\tbzrtp_message(\"parsing Ret val is %x index is %d\\n\", retval, i);\n\t\t/* We must store some packets in the context if we want to be able to parse further packets */\n\t\tif (zrtpPacket->messageType==MSGTYPE_HELLO) {\n\t\t\tif (patternZRTPMetaData[i][2]==0x87654321) {\n\t\t\t\tcontext12345678->channelContext[0]->peerPackets[HELLO_MESSAGE_STORE_ID] = zrtpPacket;\n\t\t\t\tcontext87654321->channelContext[0]->selfPackets[HELLO_MESSAGE_STORE_ID] = zrtpPacket;\n\t\t\t} else {\n\t\t\t\tcontext87654321->channelContext[0]->peerPackets[HELLO_MESSAGE_STORE_ID] = zrtpPacket;\n\t\t\t\tcontext12345678->channelContext[0]->selfPackets[HELLO_MESSAGE_STORE_ID] = zrtpPacket;\n\t\t\t}\n\t\t\tfreePacketFlag = 0;\n\t\t}\n\t\tif (zrtpPacket->messageType==MSGTYPE_COMMIT) {\n\t\t\tif (patternZRTPMetaData[i][2]==0x87654321) {\n\t\t\t\tcontext12345678->channelContext[0]->peerPackets[COMMIT_MESSAGE_STORE_ID] = zrtpPacket;\n\t\t\t} else {\n\t\t\t\tcontext87654321->channelContext[0]->peerPackets[COMMIT_MESSAGE_STORE_ID] = zrtpPacket;\n\t\t\t}\n\t\t\tfreePacketFlag = 0;\n\t\t}\n\t\tif (zrtpPacket->messageType==MSGTYPE_DHPART1 || zrtpPacket->messageType==MSGTYPE_DHPART2) {\n\t\t\tif (patternZRTPMetaData[i][2]==0x87654321) {\n\t\t\t\tcontext12345678->channelContext[0]->peerPackets[DHPART_MESSAGE_STORE_ID] = zrtpPacket;\n\t\t\t} else {\n\t\t\t\tcontext87654321->channelContext[0]->peerPackets[DHPART_MESSAGE_STORE_ID] = zrtpPacket;\n\t\t\t}\n\t\t\tfreePacketFlag = 0;\n\t\t}\n\t\t/* free the packet string as will be created again by the packetBuild function and might have been copied by packetParser */\n\t\tfree(zrtpPacket->packetString);\n\t\t/* build a packet string from the parser packet*/\n\t\tretval = bzrtp_packetBuild((patternZRTPMetaData[i][2]==0x12345678)?context12345678:context87654321, (patternZRTPMetaData[i][2]==0x12345678)?context12345678->channelContext[0]:context87654321->channelContext[0], zrtpPacket, patternZRTPMetaData[i][1]);\n\t\t/* if (retval ==0) {\n\t\t\tpacketDump(zrtpPacket, 1);\n\t\t} else {\n\t\t\tbzrtp_message(\"Ret val is %x index is %d\\n\", retval, i);\n\t\t}*/\n\n\t\t/* check they are the same */\n\t\tif (zrtpPacket->packetString != NULL) {\n\t\t\tCU_ASSERT_TRUE(memcmp(zrtpPacket->packetString, patternZRTPPackets[i], patternZRTPMetaData[i][0]) == 0);\n\t\t} else {\n\t\t\tCU_FAIL(\"Unable to build packet\");\n\t\t}\n\n\t\tif (freePacketFlag == 1) {\n\t\t\tbzrtp_freeZrtpPacket(zrtpPacket);\n\t\t}\n\n\t\t/* modify the hvi stored in the peerPackets, this shall result in parsing failure on DH2 packet */\n\t\tif (hvi_trick == 1) {\n\t\t\tif (zrtpPacket->messageType==MSGTYPE_COMMIT) {\n\t\t\t\tif (patternZRTPMetaData[i][2]==0x87654321) {\n\t\t\t\t\tbzrtpCommitMessage_t *peerCommitMessageData;\n\t\t\t\t\tpeerCommitMessageData = (bzrtpCommitMessage_t *)zrtpPacket->messageData;\n\t\t\t\t\tpeerCommitMessageData->hvi[0]=0xFF;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\n\t/* reset pointers to selfHello packet in order to avoid double free */\n\tcontext87654321->channelContext[0]->selfPackets[HELLO_MESSAGE_STORE_ID] = NULL;\n\tcontext12345678->channelContext[0]->selfPackets[HELLO_MESSAGE_STORE_ID] = NULL;\n\n\n\tbzrtp_destroyBzrtpContext(context87654321, 0x87654321);\n\tbzrtp_destroyBzrtpContext(context12345678, 0x12345678);\n\n}\n\nvoid test_parser(void) {\n\ttest_parser_param(0);\n}\n\nvoid test_parser_hvi(void) {\n\ttest_parser_param(1);\n}\n\n/* context structure mainly used by statemachine test, but also needed by parserComplete to get the zid Filename */\ntypedef struct my_Context_struct {\n\tunsigned char nom[30]; /* nom du contexte */\n\tbzrtpContext_t *peerContext;\n\tbzrtpChannelContext_t *peerChannelContext;\n\tchar zidFilename[80]; /* nom du fichier de cache */\n} my_Context_t;\n\nstatic void freeBuf(void* p){\n\tfree(p);\n}\n\nint floadAlice(void *clientData, uint8_t **output, uint32_t *size, zrtpFreeBuffer_callback *cb) {\n\t/* get filename from ClientData */\n\tmy_Context_t *clientContext = (my_Context_t *)clientData;\n\tchar *filename = clientContext->zidFilename;\n\tFILE *ALICECACHE = fopen(filename, \"r+\");\n\tfseek(ALICECACHE, 0L, SEEK_END);  /* Position to end of file */\n  \t*size = ftell(ALICECACHE);     /* Get file length */\n  \trewind(ALICECACHE);               /* Back to start of file */\n\t*output = (uint8_t *)malloc(*size*sizeof(uint8_t)+1);\n\tif (fread(*output, 1, *size, ALICECACHE)==0){\n\t\tfprintf(stderr,\"floadAlice() fread() error\\n\");\n\t}\n\t*(*output+*size) = '\\0';\n\t*size += 1;\n\tfclose(ALICECACHE);\n\t*cb=freeBuf;\n\treturn *size;\n}\n\nint fwriteAlice(void *clientData, const uint8_t *input, uint32_t size) {\n\t/* get filename from ClientData */\n\tmy_Context_t *clientContext = (my_Context_t *)clientData;\n\tchar *filename = clientContext->zidFilename;\n\n\tFILE *ALICECACHE = fopen(filename, \"w+\");\n\tint retval = fwrite(input, 1, size, ALICECACHE);\n\tfclose(ALICECACHE);\n\treturn retval;\n}\n\nint floadBob(void *clientData, uint8_t **output, uint32_t *size, zrtpFreeBuffer_callback *cb) {\n\t/* get filename from ClientData */\n\tmy_Context_t *clientContext = (my_Context_t *)clientData;\n\tchar *filename = clientContext->zidFilename;\n\n\tFILE *BOBCACHE = fopen(filename, \"r+\");\n\tfseek(BOBCACHE, 0L, SEEK_END);  /* Position to end of file */\n  \t*size = ftell(BOBCACHE);     /* Get file length */\n  \trewind(BOBCACHE);               /* Back to start of file */\n\t*output = (uint8_t *)malloc(*size*sizeof(uint8_t)+1);\n\tif (fread(*output, 1, *size, BOBCACHE)==0){\n\t\tfprintf(stderr,\"floadBob(): fread error.\\n\");\n\t\treturn -1;\n\t}\n\t*(*output+*size) = '\\0';\n\t*size += 1;\n\tfclose(BOBCACHE);\n\t*cb=freeBuf;\n\treturn *size;\n}\n\n\nint fwriteBob(void *clientData, const uint8_t *input, uint32_t size) {\n\t/* get filename from ClientData */\n\tmy_Context_t *clientContext = (my_Context_t *)clientData;\n\tchar *filename = clientContext->zidFilename;\n\n\tFILE *BOBCACHE = fopen(filename, \"w+\");\n\tint retval = fwrite(input, 1, size, BOBCACHE);\n\tfclose(BOBCACHE);\n\treturn retval;\n}\n\nvoid test_parserComplete() {\n\n\tint retval;\n\t/* alice's maintained packet */\n\tbzrtpPacket_t *alice_Hello, *alice_HelloFromBob, *alice_HelloACK, *alice_HelloACKFromBob;\n\t/* bob's maintained packet */\n\tbzrtpPacket_t *bob_Hello, *bob_HelloFromAlice, *bob_HelloACK, *bob_HelloACKFromAlice;\n\t/* Create zrtp Context */\n\tbzrtpContext_t *contextAlice = bzrtp_createBzrtpContext(0x12345678); /* Alice's SSRC of main channel is 12345678 */\n\tbzrtpContext_t *contextBob = bzrtp_createBzrtpContext(0x87654321); /* Bob's SSRC of main channel is 87654321 */\n\n\tbzrtpHelloMessage_t *alice_HelloFromBob_message;\n\tbzrtpHelloMessage_t *bob_HelloFromAlice_message;\n\tbzrtpPacket_t *alice_selfDHPart;\n\tbzrtpPacket_t *bob_selfDHPart;\n\tbzrtpPacket_t *alice_Commit;\n\tbzrtpPacket_t *bob_Commit;\n\tbzrtpPacket_t *bob_CommitFromAlice;\n\tbzrtpPacket_t *alice_CommitFromBob;\n\tuint8_t tmpBuffer[8];\n\tbzrtpDHPartMessage_t *bob_DHPart1;\n\tbzrtpPacket_t *alice_DHPart1FromBob;\n\tbzrtpDHPartMessage_t *alice_DHPart1FromBob_message=NULL;\n\tbzrtpPacket_t *bob_DHPart2FromAlice;\n\tbzrtpDHPartMessage_t *bob_DHPart2FromAlice_message=NULL;\n\tuint16_t secretLength;\n\tuint16_t totalHashDataLength;\n\tuint8_t *dataToHash;\n\tuint16_t hashDataIndex = 0;\n\tuint8_t alice_totalHash[32]; /* Note : actual length of hash depends on the choosen algo */\n\tuint8_t bob_totalHash[32]; /* Note : actual length of hash depends on the choosen algo */\n\tuint8_t *s1=NULL;\n\tuint32_t s1Length=0;\n\tuint8_t *s2=NULL;\n\tuint32_t s2Length=0;\n\tuint8_t *s3=NULL;\n\tuint32_t s3Length=0;\n\tuint8_t alice_sasHash[32];\n\tuint8_t bob_sasHash[32];\n\tuint32_t sasValue;\n\tchar sas[32];\n\tbzrtpPacket_t *bob_Confirm1;\n\tbzrtpPacket_t *alice_Confirm1FromBob;\n\tbzrtpConfirmMessage_t *alice_Confirm1FromBob_message=NULL;\n\tbzrtpPacket_t *alice_Confirm2;\n\tbzrtpPacket_t *bob_Confirm2FromAlice;\n\tbzrtpConfirmMessage_t *bob_Confirm2FromAlice_message=NULL;\n\tbzrtpPacket_t *bob_Conf2ACK;\n\tbzrtpPacket_t *alice_Conf2ACKFromBob;\n\tbzrtpPacket_t *alice_Confirm1;\n\tbzrtpPacket_t *bob_Confirm1FromAlice;\n\tbzrtpConfirmMessage_t *bob_Confirm1FromAlice_message=NULL;\n\tbzrtpPacket_t *bob_Confirm2;\n\tbzrtpPacket_t *alice_Confirm2FromBob;\n\tbzrtpConfirmMessage_t *alice_Confirm2FromBob_message=NULL;\n\tbzrtpPacket_t *alice_Conf2ACK;\n\tbzrtpPacket_t *bob_Conf2ACKFromAlice;\n\tbzrtpCallbacks_t cbs={0};\n\n\t/* Create the client context, used for zidFilename only */\n\tmy_Context_t clientContextAlice;\n\tmy_Context_t clientContextBob;\n\tstrcpy(clientContextAlice.zidFilename, \"./ZIDAlice.txt\");\n\tstrcpy(clientContextBob.zidFilename, \"./ZIDBob.txt\");\n\n\t/* attach the clientContext to the bzrtp Context */\n\tretval = bzrtp_setClientData(contextAlice, 0x12345678, (void *)&clientContextAlice);\n\tretval += bzrtp_setClientData(contextBob, 0x87654321, (void *)&clientContextBob);\n\n\t/* set the cache related callback functions */\n\tcbs.bzrtp_loadCache=floadAlice;\n\tcbs.bzrtp_writeCache=fwriteAlice;\n\n\tbzrtp_setCallbacks(contextAlice, &cbs);\n\n\tcbs.bzrtp_loadCache=floadBob;\n\tcbs.bzrtp_writeCache=fwriteBob;\n\tbzrtp_setCallbacks(contextBob, &cbs);\n\n\tbzrtp_message (\"Init the contexts\\n\");\n\t/* end the context init */\n\tbzrtp_initBzrtpContext(contextAlice);\n\tbzrtp_initBzrtpContext(contextBob);\n\n\t/* now create Alice and BOB Hello packet */\n\talice_Hello = bzrtp_createZrtpPacket(contextAlice, contextAlice->channelContext[0], MSGTYPE_HELLO, &retval);\n\tif (bzrtp_packetBuild(contextAlice, contextAlice->channelContext[0], alice_Hello, contextAlice->channelContext[0]->selfSequenceNumber) ==0) {\n\t\tcontextAlice->channelContext[0]->selfSequenceNumber++;\n\t\tcontextAlice->channelContext[0]->selfPackets[HELLO_MESSAGE_STORE_ID] = alice_Hello;\n\t}\n\tbob_Hello = bzrtp_createZrtpPacket(contextBob, contextBob->channelContext[0], MSGTYPE_HELLO, &retval);\n\tif (bzrtp_packetBuild(contextBob, contextBob->channelContext[0], bob_Hello, contextBob->channelContext[0]->selfSequenceNumber) ==0) {\n\t\tcontextBob->channelContext[0]->selfSequenceNumber++;\n\t\tcontextBob->channelContext[0]->selfPackets[HELLO_MESSAGE_STORE_ID] = bob_Hello;\n\t}\n\n\t/* now send Alice Hello's to Bob and vice-versa, so they parse them */\n\talice_HelloFromBob = bzrtp_packetCheck(bob_Hello->packetString, bob_Hello->messageLength+16, contextAlice->channelContext[0]->peerSequenceNumber, &retval);\n\tretval +=  bzrtp_packetParser(contextAlice, contextAlice->channelContext[0], bob_Hello->packetString, bob_Hello->messageLength+16, alice_HelloFromBob);\n\tbzrtp_message (\"Alice parsing returns %x\\n\", retval);\n\tif (retval==0) {\n\t\tbzrtpHelloMessage_t *alice_HelloFromBob_message;\n\t\tint i;\n\n\t\tcontextAlice->channelContext[0]->peerSequenceNumber = alice_HelloFromBob->sequenceNumber;\n\t\t/* save bob's Hello packet in Alice's context */\n\t\tcontextAlice->channelContext[0]->peerPackets[HELLO_MESSAGE_STORE_ID] = alice_HelloFromBob;\n\n\t\t/* determine crypto Algo to use */\n\t\talice_HelloFromBob_message = (bzrtpHelloMessage_t *)alice_HelloFromBob->messageData;\n\t\tretval = crypoAlgoAgreement(contextAlice, contextAlice->channelContext[0], contextAlice->channelContext[0]->peerPackets[HELLO_MESSAGE_STORE_ID]->messageData);\n\t\tif (retval == 0) {\n\t\t\tbzrtp_message (\"Alice selected algo %x\\n\", contextAlice->channelContext[0]->keyAgreementAlgo);\n\t\t\tmemcpy(contextAlice->peerZID, alice_HelloFromBob_message->ZID, 12);\n\t\t}\n\n\t\t/* check if the peer accept MultiChannel */\n\t\tfor (i=0; i<alice_HelloFromBob_message->kc; i++) {\n\t\t\tif (alice_HelloFromBob_message->supportedKeyAgreement[i] == ZRTP_KEYAGREEMENT_Mult) {\n\t\t\t\tcontextAlice->peerSupportMultiChannel = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tbob_HelloFromAlice = bzrtp_packetCheck(alice_Hello->packetString, alice_Hello->messageLength+16, contextBob->channelContext[0]->peerSequenceNumber, &retval);\n\tretval +=  bzrtp_packetParser(contextBob, contextBob->channelContext[0], alice_Hello->packetString, alice_Hello->messageLength+16, bob_HelloFromAlice);\n\tbzrtp_message (\"Bob parsing returns %x\\n\", retval);\n\tif (retval==0) {\n\t\tbzrtpHelloMessage_t *bob_HelloFromAlice_message;\n\t\tint i;\n\n\t\tcontextBob->channelContext[0]->peerSequenceNumber = bob_HelloFromAlice->sequenceNumber;\n\t\t/* save alice's Hello packet in bob's context */\n\t\tcontextBob->channelContext[0]->peerPackets[HELLO_MESSAGE_STORE_ID] = bob_HelloFromAlice;\n\n\t\t/* determine crypto Algo to use */\n\t\tbob_HelloFromAlice_message = (bzrtpHelloMessage_t *)bob_HelloFromAlice->messageData;\n\t\tretval = crypoAlgoAgreement(contextBob, contextBob->channelContext[0], contextBob->channelContext[0]->peerPackets[HELLO_MESSAGE_STORE_ID]->messageData);\n\t\tif (retval == 0) {\n\t\t\tbzrtp_message (\"Bob selected algo %x\\n\", contextBob->channelContext[0]->keyAgreementAlgo);\n\t\t\tmemcpy(contextBob->peerZID, bob_HelloFromAlice_message->ZID, 12);\n\t\t}\n\n\t\t/* check if the peer accept MultiChannel */\n\t\tfor (i=0; i<bob_HelloFromAlice_message->kc; i++) {\n\t\t\tif (bob_HelloFromAlice_message->supportedKeyAgreement[i] == ZRTP_KEYAGREEMENT_Mult) {\n\t\t\t\tcontextBob->peerSupportMultiChannel = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* update context with hello message information : H3  and compute initiator and responder's shared secret Hashs */\n\talice_HelloFromBob_message = (bzrtpHelloMessage_t *)alice_HelloFromBob->messageData;\n\tmemcpy(contextAlice->channelContext[0]->peerH[3], alice_HelloFromBob_message->H3, 32);\n\tbob_HelloFromAlice_message = (bzrtpHelloMessage_t *)bob_HelloFromAlice->messageData;\n\tmemcpy(contextBob->channelContext[0]->peerH[3], bob_HelloFromAlice_message->H3, 32);\n\n\t/* get the secrets associated to peer ZID */\n\tbzrtp_getPeerAssociatedSecretsHash(contextAlice, alice_HelloFromBob_message->ZID);\n\tbzrtp_getPeerAssociatedSecretsHash(contextBob, bob_HelloFromAlice_message->ZID);\n\n\t/* compute the initiator hashed secret as in rfc section 4.3.1 */\n\tif (contextAlice->cachedSecret.rs1!=NULL) {\n\t\tcontextAlice->channelContext[0]->hmacFunction(contextAlice->cachedSecret.rs1, contextAlice->cachedSecret.rs1Length, (uint8_t *)\"Initiator\", 9, 8, contextAlice->initiatorCachedSecretHash.rs1ID);\n\t} else { /* we have no secret, generate a random */\n\t\tbctoolbox_rng_get(contextAlice->RNGContext, contextAlice->initiatorCachedSecretHash.rs1ID, 8);\n\t}\n\n\tif (contextAlice->cachedSecret.rs2!=NULL) {\n\t\tcontextAlice->channelContext[0]->hmacFunction(contextAlice->cachedSecret.rs2, contextAlice->cachedSecret.rs2Length, (uint8_t *)\"Initiator\", 9, 8, contextAlice->initiatorCachedSecretHash.rs2ID);\n\t} else { /* we have no secret, generate a random */\n\t\tbctoolbox_rng_get(contextAlice->RNGContext, contextAlice->initiatorCachedSecretHash.rs2ID, 8);\n\t}\n\n\tif (contextAlice->cachedSecret.auxsecret!=NULL) {\n\t\tcontextAlice->channelContext[0]->hmacFunction(contextAlice->cachedSecret.auxsecret, contextAlice->cachedSecret.auxsecretLength, contextAlice->channelContext[0]->selfH[3], 32, 8, contextAlice->channelContext[0]->initiatorAuxsecretID);\n\t} else { /* we have no secret, generate a random */\n\t\tbctoolbox_rng_get(contextAlice->RNGContext, contextAlice->channelContext[0]->initiatorAuxsecretID, 8);\n\t}\n\n\tif (contextAlice->cachedSecret.pbxsecret!=NULL) {\n\t\tcontextAlice->channelContext[0]->hmacFunction(contextAlice->cachedSecret.pbxsecret, contextAlice->cachedSecret.pbxsecretLength, (uint8_t *)\"Initiator\", 9, 8, contextAlice->initiatorCachedSecretHash.pbxsecretID);\n\t} else { /* we have no secret, generate a random */\n\t\tbctoolbox_rng_get(contextAlice->RNGContext, contextAlice->initiatorCachedSecretHash.pbxsecretID, 8);\n\t}\n\n\tif (contextAlice->cachedSecret.rs1!=NULL) {\n\t\tcontextAlice->channelContext[0]->hmacFunction(contextAlice->cachedSecret.rs1, contextAlice->cachedSecret.rs1Length, (uint8_t *)\"Responder\", 9, 8, contextAlice->responderCachedSecretHash.rs1ID);\n\t} else { /* we have no secret, generate a random */\n\t\tbctoolbox_rng_get(contextAlice->RNGContext, contextAlice->responderCachedSecretHash.rs1ID, 8);\n\t}\n\n\tif (contextAlice->cachedSecret.rs2!=NULL) {\n\t\tcontextAlice->channelContext[0]->hmacFunction(contextAlice->cachedSecret.rs2, contextAlice->cachedSecret.rs2Length, (uint8_t *)\"Responder\", 9, 8, contextAlice->responderCachedSecretHash.rs2ID);\n\t} else { /* we have no secret, generate a random */\n\t\tbctoolbox_rng_get(contextAlice->RNGContext, contextAlice->responderCachedSecretHash.rs2ID, 8);\n\t}\n\n\tif (contextAlice->cachedSecret.auxsecret!=NULL) {\n\t\tcontextAlice->channelContext[0]->hmacFunction(contextAlice->cachedSecret.auxsecret, contextAlice->cachedSecret.auxsecretLength, contextAlice->channelContext[0]->peerH[3], 32, 8, contextAlice->channelContext[0]->responderAuxsecretID);\n\t} else { /* we have no secret, generate a random */\n\t\tbctoolbox_rng_get(contextAlice->RNGContext, contextAlice->channelContext[0]->responderAuxsecretID, 8);\n\t}\n\n\tif (contextAlice->cachedSecret.pbxsecret!=NULL) {\n\t\tcontextAlice->channelContext[0]->hmacFunction(contextAlice->cachedSecret.pbxsecret, contextAlice->cachedSecret.pbxsecretLength, (uint8_t *)\"Responder\", 9, 8, contextAlice->responderCachedSecretHash.pbxsecretID);\n\t} else { /* we have no secret, generate a random */\n\t\tbctoolbox_rng_get(contextAlice->RNGContext, contextAlice->responderCachedSecretHash.pbxsecretID, 8);\n\t}\n\n\n\t/* Bob hashes*/\n\tif (contextBob->cachedSecret.rs1!=NULL) {\n\t\tcontextBob->channelContext[0]->hmacFunction(contextBob->cachedSecret.rs1, contextBob->cachedSecret.rs1Length, (uint8_t *)\"Initiator\", 9, 8, contextBob->initiatorCachedSecretHash.rs1ID);\n\t} else { /* we have no secret, generate a random */\n\t\tbctoolbox_rng_get(contextBob->RNGContext, contextBob->initiatorCachedSecretHash.rs1ID, 8);\n\t}\n\n\tif (contextBob->cachedSecret.rs2!=NULL) {\n\t\tcontextBob->channelContext[0]->hmacFunction(contextBob->cachedSecret.rs2, contextBob->cachedSecret.rs2Length, (uint8_t *)\"Initiator\", 9, 8, contextBob->initiatorCachedSecretHash.rs2ID);\n\t} else { /* we have no secret, generate a random */\n\t\tbctoolbox_rng_get(contextBob->RNGContext, contextBob->initiatorCachedSecretHash.rs2ID, 8);\n\t}\n\n\tif (contextBob->cachedSecret.auxsecret!=NULL) {\n\t\tcontextBob->channelContext[0]->hmacFunction(contextBob->cachedSecret.auxsecret, contextBob->cachedSecret.auxsecretLength, contextBob->channelContext[0]->selfH[3], 32, 8, contextBob->channelContext[0]->initiatorAuxsecretID);\n\t} else { /* we have no secret, generate a random */\n\t\tbctoolbox_rng_get(contextBob->RNGContext, contextBob->channelContext[0]->initiatorAuxsecretID, 8);\n\t}\n\n\tif (contextBob->cachedSecret.pbxsecret!=NULL) {\n\t\tcontextBob->channelContext[0]->hmacFunction(contextBob->cachedSecret.pbxsecret, contextBob->cachedSecret.pbxsecretLength, (uint8_t *)\"Initiator\", 9, 8, contextBob->initiatorCachedSecretHash.pbxsecretID);\n\t} else { /* we have no secret, generate a random */\n\t\tbctoolbox_rng_get(contextBob->RNGContext, contextBob->initiatorCachedSecretHash.pbxsecretID, 8);\n\t}\n\n\tif (contextBob->cachedSecret.rs1!=NULL) {\n\t\tcontextBob->channelContext[0]->hmacFunction(contextBob->cachedSecret.rs1, contextBob->cachedSecret.rs1Length, (uint8_t *)\"Responder\", 9, 8, contextBob->responderCachedSecretHash.rs1ID);\n\t} else { /* we have no secret, generate a random */\n\t\tbctoolbox_rng_get(contextBob->RNGContext, contextBob->responderCachedSecretHash.rs1ID, 8);\n\t}\n\n\tif (contextBob->cachedSecret.rs2!=NULL) {\n\t\tcontextBob->channelContext[0]->hmacFunction(contextBob->cachedSecret.rs2, contextBob->cachedSecret.rs2Length, (uint8_t *)\"Responder\", 9, 8, contextBob->responderCachedSecretHash.rs2ID);\n\t} else { /* we have no secret, generate a random */\n\t\tbctoolbox_rng_get(contextBob->RNGContext, contextBob->responderCachedSecretHash.rs2ID, 8);\n\t}\n\n\tif (contextBob->cachedSecret.auxsecret!=NULL) {\n\t\tcontextBob->channelContext[0]->hmacFunction(contextBob->cachedSecret.auxsecret, contextBob->cachedSecret.auxsecretLength, contextBob->channelContext[0]->peerH[3], 32, 8, contextBob->channelContext[0]->responderAuxsecretID);\n\t} else { /* we have no secret, generate a random */\n\t\tbctoolbox_rng_get(contextBob->RNGContext, contextBob->channelContext[0]->responderAuxsecretID, 8);\n\t}\n\n\tif (contextBob->cachedSecret.pbxsecret!=NULL) {\n\t\tcontextBob->channelContext[0]->hmacFunction(contextBob->cachedSecret.pbxsecret, contextBob->cachedSecret.pbxsecretLength, (uint8_t *)\"Responder\", 9, 8, contextBob->responderCachedSecretHash.pbxsecretID);\n\t} else { /* we have no secret, generate a random */\n\t\tbctoolbox_rng_get(contextBob->RNGContext, contextBob->responderCachedSecretHash.pbxsecretID, 8);\n\t}\n\n\t/* dump alice's packet on both sides */\n\tbzrtp_message (\"\\nAlice original Packet is \\n\");\n\tpacketDump(alice_Hello, 1);\n\tbzrtp_message (\"\\nBob's parsed Alice Packet is \\n\");\n\tpacketDump(bob_HelloFromAlice, 0);\n\n\t/* Create the DHPart2 packet (that we then may change to DHPart1 if we ended to be the responder) */\n\talice_selfDHPart = bzrtp_createZrtpPacket(contextAlice, contextAlice->channelContext[0], MSGTYPE_DHPART2, &retval);\n\tretval += bzrtp_packetBuild(contextAlice, contextAlice->channelContext[0], alice_selfDHPart, 0); /* we don't care now about sequence number as we just need to build the message to be able to insert a hash of it into the commit packet */\n\tif (retval == 0) { /* ok, insert it in context as we need it to build the commit packet */\n\t\tcontextAlice->channelContext[0]->selfPackets[DHPART_MESSAGE_STORE_ID] = alice_selfDHPart;\n\t} else {\n\t\tbzrtp_message (\"Alice building DHPart packet returns %x\\n\", retval);\n\t}\n\tbob_selfDHPart = bzrtp_createZrtpPacket(contextBob, contextBob->channelContext[0], MSGTYPE_DHPART2, &retval);\n\tretval +=bzrtp_packetBuild(contextBob, contextBob->channelContext[0], bob_selfDHPart, 0); /* we don't care now about sequence number as we just need to build the message to be able to insert a hash of it into the commit packet */\n\tif (retval == 0) { /* ok, insert it in context as we need it to build the commit packet */\n\t\tcontextBob->channelContext[0]->selfPackets[DHPART_MESSAGE_STORE_ID] = bob_selfDHPart;\n\t} else {\n\t\tbzrtp_message (\"Bob building DHPart packet returns %x\\n\", retval);\n\t}\n\tbzrtp_message(\"Alice DHPart packet:\\n\");\n\tpacketDump(alice_selfDHPart,0);\n\tbzrtp_message(\"Bob DHPart packet:\\n\");\n\tpacketDump(bob_selfDHPart,0);\n\n\t/* respond to HELLO packet with an HelloACK - 1 create packets */\n\talice_HelloACK = bzrtp_createZrtpPacket(contextAlice, contextAlice->channelContext[0], MSGTYPE_HELLOACK, &retval);\n\tretval += bzrtp_packetBuild(contextAlice, contextAlice->channelContext[0], alice_HelloACK, contextAlice->channelContext[0]->selfSequenceNumber);\n\tif (retval == 0) {\n\t\tcontextAlice->channelContext[0]->selfSequenceNumber++;\n\t} else {\n\t\tbzrtp_message(\"Alice building HelloACK return %x\\n\", retval);\n\t}\n\n\tbob_HelloACK = bzrtp_createZrtpPacket(contextBob, contextBob->channelContext[0], MSGTYPE_HELLOACK, &retval);\n\tretval += bzrtp_packetBuild(contextBob, contextBob->channelContext[0], bob_HelloACK, contextBob->channelContext[0]->selfSequenceNumber);\n\tif (retval == 0) {\n\t\tcontextBob->channelContext[0]->selfSequenceNumber++;\n\t} else {\n\t\tbzrtp_message(\"Bob building HelloACK return %x\\n\", retval);\n\t}\n\n\t/* exchange the HelloACK */\n\talice_HelloACKFromBob = bzrtp_packetCheck(bob_HelloACK->packetString, bob_HelloACK->messageLength+16, contextAlice->channelContext[0]->peerSequenceNumber, &retval);\n\tretval +=  bzrtp_packetParser(contextAlice, contextAlice->channelContext[0], bob_HelloACK->packetString, bob_HelloACK->messageLength+16, alice_HelloACKFromBob);\n\tbzrtp_message (\"Alice parsing Hello ACK returns %x\\n\", retval);\n\tif (retval==0) {\n\t\tcontextAlice->channelContext[0]->peerSequenceNumber = alice_HelloACKFromBob->sequenceNumber;\n\t}\n\n\tbob_HelloACKFromAlice = bzrtp_packetCheck(alice_HelloACK->packetString, alice_HelloACK->messageLength+16, contextBob->channelContext[0]->peerSequenceNumber, &retval);\n\tretval +=  bzrtp_packetParser(contextBob, contextBob->channelContext[0], alice_HelloACK->packetString, alice_HelloACK->messageLength+16, bob_HelloACKFromAlice);\n\tbzrtp_message (\"Bob parsing Hello ACK returns %x\\n\", retval);\n\tif (retval==0) {\n\t\tcontextBob->channelContext[0]->peerSequenceNumber = bob_HelloACKFromAlice->sequenceNumber;\n\t}\n\tbzrtp_freeZrtpPacket(alice_HelloACK);\n\tbzrtp_freeZrtpPacket(bob_HelloACK);\n\tbzrtp_freeZrtpPacket(alice_HelloACKFromBob);\n\tbzrtp_freeZrtpPacket(bob_HelloACKFromAlice);\n\n\n\t/* now build the commit message (both Alice and Bob will send it, then use the mechanism of rfc section 4.2 to determine who will be the initiator)*/\n\talice_Commit = bzrtp_createZrtpPacket(contextAlice, contextAlice->channelContext[0], MSGTYPE_COMMIT, &retval);\n\tretval += bzrtp_packetBuild(contextAlice, contextAlice->channelContext[0], alice_Commit, contextAlice->channelContext[0]->selfSequenceNumber);\n\tif (retval == 0) {\n\t\tcontextAlice->channelContext[0]->selfSequenceNumber++;\n\t\tcontextAlice->channelContext[0]->selfPackets[COMMIT_MESSAGE_STORE_ID] = alice_Commit;\n\t}\n\tbzrtp_message(\"Alice building Commit return %x\\n\", retval);\n\n\tbob_Commit = bzrtp_createZrtpPacket(contextBob, contextBob->channelContext[0], MSGTYPE_COMMIT, &retval);\n\tretval += bzrtp_packetBuild(contextBob, contextBob->channelContext[0], bob_Commit, contextBob->channelContext[0]->selfSequenceNumber);\n\tif (retval == 0) {\n\t\tcontextBob->channelContext[0]->selfSequenceNumber++;\n\t\tcontextBob->channelContext[0]->selfPackets[COMMIT_MESSAGE_STORE_ID] = bob_Commit;\n\t}\n\tbzrtp_message(\"Bob building Commit return %x\\n\", retval);\n\n\n\t/* and exchange the commits */\n\tbob_CommitFromAlice = bzrtp_packetCheck(alice_Commit->packetString, alice_Commit->messageLength+16, contextBob->channelContext[0]->peerSequenceNumber, &retval);\n\tretval += bzrtp_packetParser(contextBob, contextBob->channelContext[0], alice_Commit->packetString, alice_Commit->messageLength+16, bob_CommitFromAlice);\n\tbzrtp_message (\"Bob parsing Commit returns %x\\n\", retval);\n\tif (retval==0) {\n\t\t/* update context with the information found in the packet */\n\t\tbzrtpCommitMessage_t *bob_CommitFromAlice_message = (bzrtpCommitMessage_t *)bob_CommitFromAlice->messageData;\n\t\tcontextBob->channelContext[0]->peerSequenceNumber = bob_CommitFromAlice->sequenceNumber;\n\t\tmemcpy(contextBob->channelContext[0]->peerH[2], bob_CommitFromAlice_message->H2, 32);\n\t\tcontextBob->channelContext[0]->peerPackets[COMMIT_MESSAGE_STORE_ID] = bob_CommitFromAlice;\n\t}\n\tpacketDump(bob_CommitFromAlice, 0);\n\n\talice_CommitFromBob = bzrtp_packetCheck(bob_Commit->packetString, bob_Commit->messageLength+16, contextAlice->channelContext[0]->peerSequenceNumber, &retval);\n\tretval += bzrtp_packetParser(contextAlice, contextAlice->channelContext[0], bob_Commit->packetString, bob_Commit->messageLength+16, alice_CommitFromBob);\n\tbzrtp_message (\"Alice parsing Commit returns %x\\n\", retval);\n\tif (retval==0) {\n\t\t/* update context with the information found in the packet */\n\t\tcontextAlice->channelContext[0]->peerSequenceNumber = alice_CommitFromBob->sequenceNumber;\n\t\t/* Alice will be the initiator (commit contention not implemented in this test) so just discard bob's commit */\n\t\t/*bzrtpCommirMessage_t *alice_CommitFromBob_message = (bzrtpCommitMessage_t *)alice_CommitFromBob->messageData;\n\t\tmemcpy(contextAlice->channelContext[0]->peerH[2], alice_CommitFromBob_message->H2, 32);\n\t\tcontextAlice->channelContext[0]->peerPackets[COMMIT_MESSAGE_STORE_ID] = alice_CommitFromBob;*/\n\t}\n\tpacketDump(alice_CommitFromBob, 0);\n\tbzrtp_freeZrtpPacket(alice_CommitFromBob);\n\n\t/* Now determine who shall be the initiator : rfc section 4.2 */\n\t/* select the one with the lowest value of hvi */\n\t/* for test purpose, we will set Alice as the initiator */\n\tcontextBob->channelContext[0]->role = RESPONDER;\n\n\t/* Bob (responder) shall update his selected algo list to match Alice selection */\n\t/* no need to do this here as we have the same selection */\n\n\t/* Bob is the responder, rebuild his DHPart packet to be responder and not initiator : */\n\t/* as responder, bob must also swap his aux shared secret between responder and initiator as they are computed using the H3 and not a constant string */\n\tmemcpy(tmpBuffer, contextBob->channelContext[0]->initiatorAuxsecretID, 8);\n\tmemcpy(contextBob->channelContext[0]->initiatorAuxsecretID, contextBob->channelContext[0]->responderAuxsecretID, 8);\n\tmemcpy(contextBob->channelContext[0]->responderAuxsecretID, tmpBuffer, 8);\n\n\tcontextBob->channelContext[0]->selfPackets[DHPART_MESSAGE_STORE_ID]->messageType = MSGTYPE_DHPART1; /* we are now part 1*/\n\tbob_DHPart1 = (bzrtpDHPartMessage_t *)contextBob->channelContext[0]->selfPackets[DHPART_MESSAGE_STORE_ID]->messageData;\n\t/* change the shared secret ID to the responder one (we set them by default to the initiator's one) */\n\tmemcpy(bob_DHPart1->rs1ID, contextBob->responderCachedSecretHash.rs1ID, 8);\n\tmemcpy(bob_DHPart1->rs2ID, contextBob->responderCachedSecretHash.rs2ID, 8);\n\tmemcpy(bob_DHPart1->auxsecretID, contextBob->channelContext[0]->responderAuxsecretID, 8);\n\tmemcpy(bob_DHPart1->pbxsecretID, contextBob->responderCachedSecretHash.pbxsecretID, 8);\n\n\tretval +=bzrtp_packetBuild(contextBob, contextBob->channelContext[0], contextBob->channelContext[0]->selfPackets[DHPART_MESSAGE_STORE_ID],contextBob->channelContext[0]->selfSequenceNumber);\n\tif (retval == 0) {\n\t\tcontextBob->channelContext[0]->selfSequenceNumber++;\n\t}\n\tbzrtp_message(\"Bob building DHPart1 return %x\\n\", retval);\n\n\n\t/* Alice parse bob's DHPart1 message */\n\talice_DHPart1FromBob = bzrtp_packetCheck(contextBob->channelContext[0]->selfPackets[DHPART_MESSAGE_STORE_ID]->packetString, contextBob->channelContext[0]->selfPackets[DHPART_MESSAGE_STORE_ID]->messageLength+16, contextAlice->channelContext[0]->peerSequenceNumber, &retval);\n\tretval += bzrtp_packetParser(contextAlice, contextAlice->channelContext[0], contextBob->channelContext[0]->selfPackets[DHPART_MESSAGE_STORE_ID]->packetString, contextBob->channelContext[0]->selfPackets[DHPART_MESSAGE_STORE_ID]->messageLength+16, alice_DHPart1FromBob);\n\tbzrtp_message (\"Alice parsing DHPart1 returns %x\\n\", retval);\n\tif (retval==0) {\n\t\t/* update context with the information found in the packet */\n\t\tcontextAlice->channelContext[0]->peerSequenceNumber = alice_DHPart1FromBob->sequenceNumber;\n\t\talice_DHPart1FromBob_message = (bzrtpDHPartMessage_t *)alice_DHPart1FromBob->messageData;\n\t\tmemcpy(contextAlice->channelContext[0]->peerH[1], alice_DHPart1FromBob_message->H1, 32);\n\t\tcontextAlice->channelContext[0]->peerPackets[DHPART_MESSAGE_STORE_ID] = alice_DHPart1FromBob;\n\t}\n\tpacketDump(alice_DHPart1FromBob, 1);\n\n\t/* Now Alice may check which shared secret she expected and if they are valid in bob's DHPart1 */\n\tif (contextAlice->cachedSecret.rs1!=NULL) {\n\t\tif (memcmp(contextAlice->responderCachedSecretHash.rs1ID, alice_DHPart1FromBob_message->rs1ID,8) != 0) {\n\t\t\tbzrtp_message (\"Alice found that requested shared secret rs1 ID differs!\\n\");\n\t\t} else {\n\t\t\tbzrtp_message(\"Alice validate rs1ID from bob DHPart1\\n\");\n\t\t}\n\t}\n\tif (contextAlice->cachedSecret.rs2!=NULL) {\n\t\tif (memcmp(contextAlice->responderCachedSecretHash.rs2ID, alice_DHPart1FromBob_message->rs2ID,8) != 0) {\n\t\t\tbzrtp_message (\"Alice found that requested shared secret rs2 ID differs!\\n\");\n\t\t} else {\n\t\t\tbzrtp_message(\"Alice validate rs2ID from bob DHPart1\\n\");\n\t\t}\n\t}\n\tif (contextAlice->cachedSecret.auxsecret!=NULL) {\n\t\tif (memcmp(contextAlice->channelContext[0]->responderAuxsecretID, alice_DHPart1FromBob_message->auxsecretID,8) != 0) {\n\t\t\tbzrtp_message (\"Alice found that requested shared secret aux secret ID differs!\\n\");\n\t\t} else {\n\t\t\tbzrtp_message(\"Alice validate aux secret ID from bob DHPart1\\n\");\n\t\t}\n\t}\n\tif (contextAlice->cachedSecret.pbxsecret!=NULL) {\n\t\tif (memcmp(contextAlice->responderCachedSecretHash.pbxsecretID, alice_DHPart1FromBob_message->pbxsecretID,8) != 0) {\n\t\t\tbzrtp_message (\"Alice found that requested shared secret pbx secret ID differs!\\n\");\n\t\t} else {\n\t\t\tbzrtp_message(\"Alice validate pbxsecretID from bob DHPart1\\n\");\n\t\t}\n\t}\n\n\t/* Now Alice shall check that the PV from bob is not 1 or Prime-1 TODO*/\n\t/* Compute the shared DH secret */\n\tcontextAlice->DHMContext->peer = (uint8_t *)malloc(contextAlice->channelContext[0]->keyAgreementLength*sizeof(uint8_t));\n\tmemcpy (contextAlice->DHMContext->peer, alice_DHPart1FromBob_message->pv, contextAlice->channelContext[0]->keyAgreementLength);\n\tbctoolbox_DHMComputeSecret(contextAlice->DHMContext, (int (*)(void *, uint8_t *, size_t))bctoolbox_rng_get, (void *)contextAlice->RNGContext);\n\n\t/* So Alice send bob her DHPart2 message which is already prepared and stored (we just need to update the sequence number) */\n\tbzrtp_packetUpdateSequenceNumber(contextAlice->channelContext[0]->selfPackets[DHPART_MESSAGE_STORE_ID], contextAlice->channelContext[0]->selfSequenceNumber);\n\tcontextAlice->channelContext[0]->selfSequenceNumber++;\n\n\t/* Bob parse Alice's DHPart2 message */\n\tbob_DHPart2FromAlice = bzrtp_packetCheck(contextAlice->channelContext[0]->selfPackets[DHPART_MESSAGE_STORE_ID]->packetString, contextAlice->channelContext[0]->selfPackets[DHPART_MESSAGE_STORE_ID]->messageLength+16, contextBob->channelContext[0]->peerSequenceNumber, &retval);\n\tbzrtp_message (\"Bob checking DHPart2 returns %x\\n\", retval);\n\tretval += bzrtp_packetParser(contextBob, contextBob->channelContext[0], contextAlice->channelContext[0]->selfPackets[DHPART_MESSAGE_STORE_ID]->packetString, contextAlice->channelContext[0]->selfPackets[DHPART_MESSAGE_STORE_ID]->messageLength+16, bob_DHPart2FromAlice);\n\tbzrtp_message (\"Bob parsing DHPart2 returns %x\\n\", retval);\n\tif (retval==0) {\n\t\t/* update context with the information found in the packet */\n\t\tcontextBob->channelContext[0]->peerSequenceNumber = bob_DHPart2FromAlice->sequenceNumber;\n\t\tbob_DHPart2FromAlice_message = (bzrtpDHPartMessage_t *)bob_DHPart2FromAlice->messageData;\n\t\tmemcpy(contextBob->channelContext[0]->peerH[1], bob_DHPart2FromAlice_message->H1, 32);\n\t\tcontextBob->channelContext[0]->peerPackets[DHPART_MESSAGE_STORE_ID] = bob_DHPart2FromAlice;\n\t}\n\tpacketDump(bob_DHPart2FromAlice, 0);\n\n\t/* Now Bob may check which shared secret she expected and if they are valid in bob's DHPart1 */\n\tif (contextBob->cachedSecret.rs1!=NULL) {\n\t\tif (memcmp(contextBob->initiatorCachedSecretHash.rs1ID, bob_DHPart2FromAlice_message->rs1ID,8) != 0) {\n\t\t\tbzrtp_message (\"Bob found that requested shared secret rs1 ID differs!\\n\");\n\t\t} else {\n\t\t\tbzrtp_message(\"Bob validate rs1ID from Alice DHPart2\\n\");\n\t\t}\n\t}\n\tif (contextBob->cachedSecret.rs2!=NULL) {\n\t\tif (memcmp(contextBob->initiatorCachedSecretHash.rs2ID, bob_DHPart2FromAlice_message->rs2ID,8) != 0) {\n\t\t\tbzrtp_message (\"Bob found that requested shared secret rs2 ID differs!\\n\");\n\t\t} else {\n\t\t\tbzrtp_message(\"Bob validate rs2ID from Alice DHPart2\\n\");\n\t\t}\n\t}\n\tif (contextBob->cachedSecret.auxsecret!=NULL) {\n\t\tif (memcmp(contextBob->channelContext[0]->initiatorAuxsecretID, bob_DHPart2FromAlice_message->auxsecretID,8) != 0) {\n\t\t\tbzrtp_message (\"Bob found that requested shared secret aux secret ID differs!\\n\");\n\t\t} else {\n\t\t\tbzrtp_message(\"Bob validate aux secret ID from Alice DHPart2\\n\");\n\t\t}\n\t}\n\tif (contextBob->cachedSecret.pbxsecret!=NULL) {\n\t\tif (memcmp(contextBob->initiatorCachedSecretHash.pbxsecretID, bob_DHPart2FromAlice_message->pbxsecretID,8) != 0) {\n\t\t\tbzrtp_message (\"Bob found that requested shared secret pbx secret ID differs!\\n\");\n\t\t} else {\n\t\t\tbzrtp_message(\"Bob validate pbxsecretID from Alice DHPart2\\n\");\n\t\t}\n\t}\n\n\t/* Now Bob shall check that the PV from Alice is not 1 or Prime-1 TODO*/\n\t/* Compute the shared DH secret */\n\tcontextBob->DHMContext->peer = (uint8_t *)malloc(contextBob->channelContext[0]->keyAgreementLength*sizeof(uint8_t));\n\tmemcpy (contextBob->DHMContext->peer, bob_DHPart2FromAlice_message->pv, contextBob->channelContext[0]->keyAgreementLength);\n\tbctoolbox_DHMComputeSecret(contextBob->DHMContext, (int (*)(void *, uint8_t *, size_t))bctoolbox_rng_get, (void *)contextAlice->RNGContext);\n\n\n\t/* JUST FOR TEST: check that the generated secrets are the same */\n\tsecretLength = bob_DHPart2FromAlice->messageLength-84; /* length of generated secret is the same than public value */\n\tif (memcmp(contextBob->DHMContext->key, contextAlice->DHMContext->key, secretLength)==0) {\n\t\tbzrtp_message(\"Secret Key correctly exchanged \\n\");\n\t\tCU_PASS(\"Secret Key exchange OK\");\n\t} else {\n\t\tCU_FAIL(\"Secret Key exchange failed\");\n\t\tbzrtp_message(\"ERROR : secretKey exchange failed!!\\n\");\n\t}\n\n\t/* now compute the total_hash as in rfc section 4.4.1.4\n\t * total_hash = hash(Hello of responder || Commit || DHPart1 || DHPart2)\n\t */\n\ttotalHashDataLength = bob_Hello->messageLength + alice_Commit->messageLength + contextBob->channelContext[0]->selfPackets[DHPART_MESSAGE_STORE_ID]->messageLength + alice_selfDHPart->messageLength;\n\tdataToHash = (uint8_t *)malloc(totalHashDataLength*sizeof(uint8_t));\n\t/* get all data from Alice */\n\tmemcpy(dataToHash, contextAlice->channelContext[0]->peerPackets[HELLO_MESSAGE_STORE_ID]->packetString+ZRTP_PACKET_HEADER_LENGTH, contextAlice->channelContext[0]->peerPackets[HELLO_MESSAGE_STORE_ID]->messageLength);\n\thashDataIndex += contextAlice->channelContext[0]->peerPackets[HELLO_MESSAGE_STORE_ID]->messageLength;\n\tmemcpy(dataToHash+hashDataIndex, contextAlice->channelContext[0]->selfPackets[COMMIT_MESSAGE_STORE_ID]->packetString+ZRTP_PACKET_HEADER_LENGTH, contextAlice->channelContext[0]->selfPackets[COMMIT_MESSAGE_STORE_ID]->messageLength);\n\thashDataIndex += contextAlice->channelContext[0]->selfPackets[COMMIT_MESSAGE_STORE_ID]->messageLength;\n\tmemcpy(dataToHash+hashDataIndex, contextAlice->channelContext[0]->peerPackets[DHPART_MESSAGE_STORE_ID]->packetString+ZRTP_PACKET_HEADER_LENGTH, contextAlice->channelContext[0]->peerPackets[DHPART_MESSAGE_STORE_ID]->messageLength);\n\thashDataIndex += contextAlice->channelContext[0]->peerPackets[DHPART_MESSAGE_STORE_ID]->messageLength;\n\tmemcpy(dataToHash+hashDataIndex, contextAlice->channelContext[0]->selfPackets[DHPART_MESSAGE_STORE_ID]->packetString+ZRTP_PACKET_HEADER_LENGTH, contextAlice->channelContext[0]->selfPackets[DHPART_MESSAGE_STORE_ID]->messageLength);\n\n\tcontextAlice->channelContext[0]->hashFunction(dataToHash, totalHashDataLength, 32, alice_totalHash);\n\n\t/* get all data from Bob */\n\thashDataIndex = 0;\n\tmemcpy(dataToHash, contextBob->channelContext[0]->selfPackets[HELLO_MESSAGE_STORE_ID]->packetString+ZRTP_PACKET_HEADER_LENGTH, contextBob->channelContext[0]->selfPackets[HELLO_MESSAGE_STORE_ID]->messageLength);\n\thashDataIndex += contextBob->channelContext[0]->selfPackets[HELLO_MESSAGE_STORE_ID]->messageLength;\n\tmemcpy(dataToHash+hashDataIndex, contextBob->channelContext[0]->peerPackets[COMMIT_MESSAGE_STORE_ID]->packetString+ZRTP_PACKET_HEADER_LENGTH, contextBob->channelContext[0]->peerPackets[COMMIT_MESSAGE_STORE_ID]->messageLength);\n\thashDataIndex += contextBob->channelContext[0]->peerPackets[COMMIT_MESSAGE_STORE_ID]->messageLength;\n\tmemcpy(dataToHash+hashDataIndex, contextBob->channelContext[0]->selfPackets[DHPART_MESSAGE_STORE_ID]->packetString+ZRTP_PACKET_HEADER_LENGTH, contextBob->channelContext[0]->selfPackets[DHPART_MESSAGE_STORE_ID]->messageLength);\n\thashDataIndex += contextBob->channelContext[0]->selfPackets[DHPART_MESSAGE_STORE_ID]->messageLength;\n\tmemcpy(dataToHash+hashDataIndex, contextBob->channelContext[0]->peerPackets[DHPART_MESSAGE_STORE_ID]->packetString+ZRTP_PACKET_HEADER_LENGTH, contextBob->channelContext[0]->peerPackets[DHPART_MESSAGE_STORE_ID]->messageLength);\n\n\tcontextBob->channelContext[0]->hashFunction(dataToHash, totalHashDataLength, 32, bob_totalHash);\n\tif (memcmp(bob_totalHash, alice_totalHash, 32) == 0) {\n\t\tbzrtp_message(\"Got the same total hash\\n\");\n\t\tCU_PASS(\"Total Hash match\");\n\t} else {\n\t\tbzrtp_message(\"AARGG!! total hash mismatch\");\n\t\tCU_FAIL(\"Total Hash mismatch\");\n\t}\n\n\t/* now compute s0 and KDF_context as in rfc section 4.4.1.4\n\t\ts0 = hash(counter || DHResult || \"ZRTP-HMAC-KDF\" || ZIDi || ZIDr || total_hash || len(s1) || s1 || len(s2) || s2 || len(s3) || s3)\n\t\tcounter is a fixed 32 bits integer in big endian set to 1 : 0x00000001\n\t*/\n\tfree(dataToHash);\n\tcontextAlice->channelContext[0]->KDFContextLength = 24+32;/* actual depends on selected hash length*/\n\tcontextAlice->channelContext[0]->KDFContext = (uint8_t *)malloc(contextAlice->channelContext[0]->KDFContextLength*sizeof(uint8_t));\n\tmemcpy(contextAlice->channelContext[0]->KDFContext, contextAlice->selfZID, 12); /* ZIDi*/\n\tmemcpy(contextAlice->channelContext[0]->KDFContext+12, contextAlice->peerZID, 12); /* ZIDr */\n\tmemcpy(contextAlice->channelContext[0]->KDFContext+24, alice_totalHash, 32); /* total Hash*/\n\n\t/* get s1 from rs1 or rs2 */\n\tif (contextAlice->cachedSecret.rs1 != NULL) { /* if there is a s1 (already validated when received the DHpacket) */\n\t\ts1 = contextAlice->cachedSecret.rs1;\n\t\ts1Length = contextAlice->cachedSecret.rs1Length;\n\t} else if (contextAlice->cachedSecret.rs2 != NULL) { /* otherwise if there is a s2 (already validated when received the DHpacket) */\n\t\ts1 = contextAlice->cachedSecret.rs2;\n\t\ts1Length = contextAlice->cachedSecret.rs2Length;\n\t}\n\n\t/* s2 is the auxsecret */\n\ts2 = contextAlice->cachedSecret.auxsecret; /* this may be null if no match or no aux secret where found */\n\ts2Length = contextAlice->cachedSecret.auxsecretLength; /* this may be 0 if no match or no aux secret where found */\n\n\t/* s3 is the pbxsecret */\n\ts3 = contextAlice->cachedSecret.pbxsecret; /* this may be null if no match or no pbx secret where found */\n\ts3Length = contextAlice->cachedSecret.pbxsecretLength; /* this may be 0 if no match or no pbx secret where found */\n\n\ttotalHashDataLength = 4+secretLength+13/*ZRTP-HMAC-KDF string*/ + 12 + 12 + 32 + 4 +s1Length + 4 +s2Length + 4 + s3Length; /* secret length was computed before as the length of DH secret data */\n\n\tdataToHash = (uint8_t *)malloc(totalHashDataLength*sizeof(uint8_t));\n\tdataToHash[0] = 0x00;\n\tdataToHash[1] = 0x00;\n\tdataToHash[2] = 0x00;\n\tdataToHash[3] = 0x01;\n\thashDataIndex = 4;\n\n\tmemcpy(dataToHash+hashDataIndex, contextAlice->DHMContext->key, secretLength);\n\thashDataIndex += secretLength;\n\tmemcpy(dataToHash+hashDataIndex, \"ZRTP-HMAC-KDF\", 13);\n\thashDataIndex += 13;\n\tmemcpy(dataToHash+hashDataIndex, contextAlice->channelContext[0]->KDFContext, contextAlice->channelContext[0]->KDFContextLength);\n\thashDataIndex += 56;\n\n\tdataToHash[hashDataIndex++] = (uint8_t)((s1Length>>24)&0xFF);\n\tdataToHash[hashDataIndex++] = (uint8_t)((s1Length>>16)&0xFF);\n\tdataToHash[hashDataIndex++] = (uint8_t)((s1Length>>8)&0xFF);\n\tdataToHash[hashDataIndex++] = (uint8_t)(s1Length&0xFF);\n\tif (s1!=NULL) {\n\t\tmemcpy(dataToHash+hashDataIndex, s1, s1Length);\n\t\thashDataIndex += s1Length;\n\t}\n\n\tdataToHash[hashDataIndex++] = (uint8_t)((s2Length>>24)&0xFF);\n\tdataToHash[hashDataIndex++] = (uint8_t)((s2Length>>16)&0xFF);\n\tdataToHash[hashDataIndex++] = (uint8_t)((s2Length>>8)&0xFF);\n\tdataToHash[hashDataIndex++] = (uint8_t)(s2Length&0xFF);\n\tif (s2!=NULL) {\n\t\tmemcpy(dataToHash+hashDataIndex, s2, s2Length);\n\t\thashDataIndex += s2Length;\n\t}\n\n\tdataToHash[hashDataIndex++] = (uint8_t)((s3Length>>24)&0xFF);\n\tdataToHash[hashDataIndex++] = (uint8_t)((s3Length>>16)&0xFF);\n\tdataToHash[hashDataIndex++] = (uint8_t)((s3Length>>8)&0xFF);\n\tdataToHash[hashDataIndex++] = (uint8_t)(s3Length&0xFF);\n\tif (s3!=NULL) {\n\t\tmemcpy(dataToHash+hashDataIndex, s3, s3Length);\n\t\thashDataIndex += s3Length;\n\t}\n\n\tcontextAlice->channelContext[0]->s0 = (uint8_t *)malloc(32*sizeof(uint8_t));\n\tcontextAlice->channelContext[0]->hashFunction(dataToHash, totalHashDataLength, 32, contextAlice->channelContext[0]->s0);\n\n\t/* destroy all cached keys in context */\n\tif (contextAlice->cachedSecret.rs1!=NULL) {\n\t\tbzrtp_DestroyKey(contextAlice->cachedSecret.rs1, contextAlice->cachedSecret.rs1Length, contextAlice->RNGContext);\n\t\tfree(contextAlice->cachedSecret.rs1);\n\t\tcontextAlice->cachedSecret.rs1 = NULL;\n\t}\n\tif (contextAlice->cachedSecret.rs2!=NULL) {\n\t\tbzrtp_DestroyKey(contextAlice->cachedSecret.rs2, contextAlice->cachedSecret.rs2Length, contextAlice->RNGContext);\n\t\tfree(contextAlice->cachedSecret.rs2);\n\t\tcontextAlice->cachedSecret.rs2 = NULL;\n\t}\n\tif (contextAlice->cachedSecret.auxsecret!=NULL) {\n\t\tbzrtp_DestroyKey(contextAlice->cachedSecret.auxsecret, contextAlice->cachedSecret.auxsecretLength, contextAlice->RNGContext);\n\t\tfree(contextAlice->cachedSecret.auxsecret);\n\t\tcontextAlice->cachedSecret.auxsecret = NULL;\n\t}\n\tif (contextAlice->cachedSecret.pbxsecret!=NULL) {\n\t\tbzrtp_DestroyKey(contextAlice->cachedSecret.pbxsecret, contextAlice->cachedSecret.pbxsecretLength, contextAlice->RNGContext);\n\t\tfree(contextAlice->cachedSecret.pbxsecret);\n\t\tcontextAlice->cachedSecret.pbxsecret = NULL;\n\t}\n\n\t/*** Do the same for bob ***/\n\t/* get s1 from rs1 or rs2 */\n\ts1=NULL;\n\ts2=NULL;\n\ts3=NULL;\n\tcontextBob->channelContext[0]->KDFContextLength = 24+32;/* actual depends on selected hash length*/\n\tcontextBob->channelContext[0]->KDFContext = (uint8_t *)malloc(contextBob->channelContext[0]->KDFContextLength*sizeof(uint8_t));\n\tmemcpy(contextBob->channelContext[0]->KDFContext, contextBob->peerZID, 12); /* ZIDi*/\n\tmemcpy(contextBob->channelContext[0]->KDFContext+12, contextBob->selfZID, 12); /* ZIDr */\n\tmemcpy(contextBob->channelContext[0]->KDFContext+24, bob_totalHash, 32); /* total Hash*/\n\n\tif (contextBob->cachedSecret.rs1 != NULL) { /* if there is a s1 (already validated when received the DHpacket) */\n\t\ts1 = contextBob->cachedSecret.rs1;\n\t\ts1Length = contextBob->cachedSecret.rs1Length;\n\t} else if (contextBob->cachedSecret.rs2 != NULL) { /* otherwise if there is a s2 (already validated when received the DHpacket) */\n\t\ts1 = contextBob->cachedSecret.rs2;\n\t\ts1Length = contextBob->cachedSecret.rs2Length;\n\t}\n\n\t/* s2 is the auxsecret */\n\ts2 = contextBob->cachedSecret.auxsecret; /* this may be null if no match or no aux secret where found */\n\ts2Length = contextBob->cachedSecret.auxsecretLength; /* this may be 0 if no match or no aux secret where found */\n\n\t/* s3 is the pbxsecret */\n\ts3 = contextBob->cachedSecret.pbxsecret; /* this may be null if no match or no pbx secret where found */\n\ts3Length = contextBob->cachedSecret.pbxsecretLength; /* this may be 0 if no match or no pbx secret where found */\n\n\tfree(dataToHash);\n\tdataToHash = (uint8_t *)malloc(totalHashDataLength*sizeof(uint8_t));\n\tdataToHash[0] = 0x00;\n\tdataToHash[1] = 0x00;\n\tdataToHash[2] = 0x00;\n\tdataToHash[3] = 0x01;\n\thashDataIndex = 4;\n\n\tmemcpy(dataToHash+hashDataIndex, contextBob->DHMContext->key, secretLength);\n\thashDataIndex += secretLength;\n\tmemcpy(dataToHash+hashDataIndex, \"ZRTP-HMAC-KDF\", 13);\n\thashDataIndex += 13;\n\tmemcpy(dataToHash+hashDataIndex, contextBob->channelContext[0]->KDFContext, contextBob->channelContext[0]->KDFContextLength);\n\thashDataIndex += 56;\n\n\tdataToHash[hashDataIndex++] = (uint8_t)((s1Length>>24)&0xFF);\n\tdataToHash[hashDataIndex++] = (uint8_t)((s1Length>>16)&0xFF);\n\tdataToHash[hashDataIndex++] = (uint8_t)((s1Length>>8)&0xFF);\n\tdataToHash[hashDataIndex++] = (uint8_t)(s1Length&0xFF);\n\tif (s1!=NULL) {\n\t\tmemcpy(dataToHash+hashDataIndex, s1, s1Length);\n\t\thashDataIndex += s1Length;\n\t}\n\n\tdataToHash[hashDataIndex++] = (uint8_t)((s2Length>>24)&0xFF);\n\tdataToHash[hashDataIndex++] = (uint8_t)((s2Length>>16)&0xFF);\n\tdataToHash[hashDataIndex++] = (uint8_t)((s2Length>>8)&0xFF);\n\tdataToHash[hashDataIndex++] = (uint8_t)(s2Length&0xFF);\n\tif (s2!=NULL) {\n\t\tmemcpy(dataToHash+hashDataIndex, s2, s2Length);\n\t\thashDataIndex += s2Length;\n\t}\n\n\tdataToHash[hashDataIndex++] = (uint8_t)((s3Length>>24)&0xFF);\n\tdataToHash[hashDataIndex++] = (uint8_t)((s3Length>>16)&0xFF);\n\tdataToHash[hashDataIndex++] = (uint8_t)((s3Length>>8)&0xFF);\n\tdataToHash[hashDataIndex++] = (uint8_t)(s3Length&0xFF);\n\tif (s3!=NULL) {\n\t\tmemcpy(dataToHash+hashDataIndex, s3, s3Length);\n\t\thashDataIndex += s3Length;\n\t}\n\n\tcontextBob->channelContext[0]->s0 = (uint8_t *)malloc(32*sizeof(uint8_t));\n\tcontextBob->channelContext[0]->hashFunction(dataToHash, totalHashDataLength, 32, contextBob->channelContext[0]->s0);\n\n\tfree(dataToHash);\n\n\t/* destroy all cached keys in context */\n\tif (contextBob->cachedSecret.rs1!=NULL) {\n\t\tbzrtp_DestroyKey(contextBob->cachedSecret.rs1, contextBob->cachedSecret.rs1Length, contextBob->RNGContext);\n\t\tfree(contextBob->cachedSecret.rs1);\n\t\tcontextBob->cachedSecret.rs1 = NULL;\n\t}\n\tif (contextBob->cachedSecret.rs2!=NULL) {\n\t\tbzrtp_DestroyKey(contextBob->cachedSecret.rs2, contextBob->cachedSecret.rs2Length, contextBob->RNGContext);\n\t\tfree(contextBob->cachedSecret.rs2);\n\t\tcontextBob->cachedSecret.rs2 = NULL;\n\t}\n\tif (contextBob->cachedSecret.auxsecret!=NULL) {\n\t\tbzrtp_DestroyKey(contextBob->cachedSecret.auxsecret, contextBob->cachedSecret.auxsecretLength, contextBob->RNGContext);\n\t\tfree(contextBob->cachedSecret.auxsecret);\n\t\tcontextBob->cachedSecret.auxsecret = NULL;\n\t}\n\tif (contextBob->cachedSecret.pbxsecret!=NULL) {\n\t\tbzrtp_DestroyKey(contextBob->cachedSecret.pbxsecret, contextBob->cachedSecret.pbxsecretLength, contextBob->RNGContext);\n\t\tfree(contextBob->cachedSecret.pbxsecret);\n\t\tcontextBob->cachedSecret.pbxsecret = NULL;\n\t}\n\n\n\t/* DEBUG compare s0 */\n\tif (memcmp(contextBob->channelContext[0]->s0, contextAlice->channelContext[0]->s0, 32)==0) {\n\t\tbzrtp_message(\"Got the same s0\\n\");\n\t\tCU_PASS(\"s0 match\");\n\t} else {\n\t\tbzrtp_message(\"ERROR s0 differs\\n\");\n\t\tCU_PASS(\"s0 mismatch\");\n\t}\n\n\t/* now compute the ZRTPSession key : section 4.5.2\n\t * ZRTPSess = KDF(s0, \"ZRTP Session Key\", KDF_Context, negotiated hash length)*/\n\tcontextAlice->ZRTPSessLength=32; /* must be set to the length of negotiated hash */\n\tcontextAlice->ZRTPSess = (uint8_t *)malloc(contextAlice->ZRTPSessLength*sizeof(uint8_t));\n\tretval = bzrtp_keyDerivationFunction(contextAlice->channelContext[0]->s0, contextAlice->channelContext[0]->hashLength,\n\t\t(uint8_t *)\"ZRTP Session Key\", 16,\n\t\tcontextAlice->channelContext[0]->KDFContext, contextAlice->channelContext[0]->KDFContextLength, /* this one too depends on selected hash */\n\t\tcontextAlice->channelContext[0]->hashLength,\n\t\t(void (*)(uint8_t *, uint8_t,  uint8_t *, uint32_t,  uint8_t,  uint8_t *))contextAlice->channelContext[0]->hmacFunction,\n\t\tcontextAlice->ZRTPSess);\n\n\tcontextBob->ZRTPSessLength=32; /* must be set to the length of negotiated hash */\n\tcontextBob->ZRTPSess = (uint8_t *)malloc(contextBob->ZRTPSessLength*sizeof(uint8_t));\n\tretval = bzrtp_keyDerivationFunction(contextBob->channelContext[0]->s0, contextBob->channelContext[0]->hashLength,\n\t\t(uint8_t *)\"ZRTP Session Key\", 16,\n\t\tcontextBob->channelContext[0]->KDFContext, contextBob->channelContext[0]->KDFContextLength, /* this one too depends on selected hash */\n\t\tcontextBob->channelContext[0]->hashLength,\n\t\t(void (*)(uint8_t *, uint8_t,  uint8_t *, uint32_t,  uint8_t,  uint8_t *))contextBob->channelContext[0]->hmacFunction,\n\t\tcontextBob->ZRTPSess);\n\n\t/* DEBUG compare ZRTPSess Key */\n\tif (memcmp(contextBob->ZRTPSess, contextAlice->ZRTPSess, 32)==0) {\n\t\tbzrtp_message(\"Got the same ZRTPSess\\n\");\n\t\tCU_PASS(\"ZRTPSess match\");\n\t} else {\n\t\tbzrtp_message(\"ERROR ZRTPSess differs\\n\");\n\t\tCU_PASS(\"ZRTPSess mismatch\");\n\t}\n\n\n\t/* compute the sas according to rfc section 4.5.2 sashash = KDF(s0, \"SAS\", KDF_Context, 256) */\n\tretval = bzrtp_keyDerivationFunction(contextAlice->channelContext[0]->s0, contextAlice->channelContext[0]->hashLength,\n\t\t\t(uint8_t *)\"SAS\", 3,\n\t\t\tcontextAlice->channelContext[0]->KDFContext, contextAlice->channelContext[0]->KDFContextLength, /* this one too depends on selected hash */\n\t\t\t256/8, /* function gets L in bytes */\n\t\t\t(void (*)(uint8_t *, uint8_t,  uint8_t *, uint32_t,  uint8_t,  uint8_t *))contextAlice->channelContext[0]->hmacFunction,\n\t\t\talice_sasHash);\n\n\tretval = bzrtp_keyDerivationFunction(contextBob->channelContext[0]->s0, contextBob->channelContext[0]->hashLength,\n\t\t\t(uint8_t *)\"SAS\", 3,\n\t\t\tcontextBob->channelContext[0]->KDFContext, contextBob->channelContext[0]->KDFContextLength, /* this one too depends on selected hash */\n\t\t\t256/8, /* function gets L in bytes */\n\t\t\t(void (*)(uint8_t *, uint8_t,  uint8_t *, uint32_t,  uint8_t,  uint8_t *))contextBob->channelContext[0]->hmacFunction,\n\t\t\tbob_sasHash);\n\n\t/* DEBUG compare sasHash */\n\tif (memcmp(alice_sasHash, bob_sasHash, 32)==0) {\n\t\tbzrtp_message(\"Got the same SAS Hash\\n\");\n\t\tCU_PASS(\"SAS Hash match\");\n\t} else {\n\t\tbzrtp_message(\"ERROR SAS Hash differs\\n\");\n\t\tCU_PASS(\"SAS Hash mismatch\");\n\t}\n\n\t/* display SAS (we shall not do this now but after the confirm message exchanges) */\n\tsasValue = ((uint32_t)alice_sasHash[0]<<24) | ((uint32_t)alice_sasHash[1]<<16) | ((uint32_t)alice_sasHash[2]<<8) | ((uint32_t)(alice_sasHash[3]));\n\tcontextAlice->channelContext[0]->sasFunction(sasValue, sas, 5);\n\n\tbzrtp_message(\"Alice SAS is %.4s\\n\", sas);\n\n\tsasValue = ((uint32_t)bob_sasHash[0]<<24) | ((uint32_t)bob_sasHash[1]<<16) | ((uint32_t)bob_sasHash[2]<<8) | ((uint32_t)(bob_sasHash[3]));\n\tcontextBob->channelContext[0]->sasFunction(sasValue, sas, 5);\n\n\tbzrtp_message(\"Bob SAS is %.4s\\n\", sas);\n\n\n\t/* now derive the other keys (mackeyi, mackeyr, zrtpkeyi and zrtpkeyr, srtpkeys and salt) */\n\tcontextAlice->channelContext[0]->mackeyi = (uint8_t *)malloc(contextAlice->channelContext[0]->hashLength*(sizeof(uint8_t)));\n\tcontextAlice->channelContext[0]->mackeyr = (uint8_t *)malloc(contextAlice->channelContext[0]->hashLength*(sizeof(uint8_t)));\n\tcontextAlice->channelContext[0]->zrtpkeyi = (uint8_t *)malloc(contextAlice->channelContext[0]->cipherKeyLength*(sizeof(uint8_t)));\n\tcontextAlice->channelContext[0]->zrtpkeyr = (uint8_t *)malloc(contextAlice->channelContext[0]->cipherKeyLength*(sizeof(uint8_t)));\n\tcontextBob->channelContext[0]->mackeyi = (uint8_t *)malloc(contextBob->channelContext[0]->hashLength*(sizeof(uint8_t)));\n\tcontextBob->channelContext[0]->mackeyr = (uint8_t *)malloc(contextBob->channelContext[0]->hashLength*(sizeof(uint8_t)));\n\tcontextBob->channelContext[0]->zrtpkeyi = (uint8_t *)malloc(contextBob->channelContext[0]->cipherKeyLength*(sizeof(uint8_t)));\n\tcontextBob->channelContext[0]->zrtpkeyr = (uint8_t *)malloc(contextBob->channelContext[0]->cipherKeyLength*(sizeof(uint8_t)));\n\n\t/* Alice */\n\tretval = bzrtp_keyDerivationFunction(contextAlice->channelContext[0]->s0, contextAlice->channelContext[0]->hashLength, (uint8_t *)\"Initiator HMAC key\", 18, contextAlice->channelContext[0]->KDFContext, contextAlice->channelContext[0]->KDFContextLength, contextAlice->channelContext[0]->hashLength, (void (*)(uint8_t *, uint8_t,  uint8_t *, uint32_t,  uint8_t,  uint8_t *))contextAlice->channelContext[0]->hmacFunction, contextAlice->channelContext[0]->mackeyi);\n\tretval += bzrtp_keyDerivationFunction(contextAlice->channelContext[0]->s0, contextAlice->channelContext[0]->hashLength, (uint8_t *)\"Responder HMAC key\", 18, contextAlice->channelContext[0]->KDFContext, contextAlice->channelContext[0]->KDFContextLength, contextAlice->channelContext[0]->hashLength, (void (*)(uint8_t *, uint8_t,  uint8_t *, uint32_t,  uint8_t,  uint8_t *))contextAlice->channelContext[0]->hmacFunction, contextAlice->channelContext[0]->mackeyr);\n\tretval += bzrtp_keyDerivationFunction(contextAlice->channelContext[0]->s0, contextAlice->channelContext[0]->hashLength, (uint8_t *)\"Initiator ZRTP key\", 18, contextAlice->channelContext[0]->KDFContext, contextAlice->channelContext[0]->KDFContextLength, contextAlice->channelContext[0]->cipherKeyLength, (void (*)(uint8_t *, uint8_t,  uint8_t *, uint32_t,  uint8_t,  uint8_t *))contextAlice->channelContext[0]->hmacFunction, contextAlice->channelContext[0]->zrtpkeyi);\n\tretval += bzrtp_keyDerivationFunction(contextAlice->channelContext[0]->s0, contextAlice->channelContext[0]->hashLength, (uint8_t *)\"Responder ZRTP key\", 18, contextAlice->channelContext[0]->KDFContext, contextAlice->channelContext[0]->KDFContextLength, contextAlice->channelContext[0]->cipherKeyLength, (void (*)(uint8_t *, uint8_t,  uint8_t *, uint32_t,  uint8_t,  uint8_t *))contextAlice->channelContext[0]->hmacFunction, contextAlice->channelContext[0]->zrtpkeyr);\n\n\t/* Bob */\n\tretval = bzrtp_keyDerivationFunction(contextBob->channelContext[0]->s0, contextBob->channelContext[0]->hashLength, (uint8_t *)\"Initiator HMAC key\", 18, contextBob->channelContext[0]->KDFContext, contextBob->channelContext[0]->KDFContextLength, contextBob->channelContext[0]->hashLength, (void (*)(uint8_t *, uint8_t,  uint8_t *, uint32_t,  uint8_t,  uint8_t *))contextBob->channelContext[0]->hmacFunction, contextBob->channelContext[0]->mackeyi);\n\tretval += bzrtp_keyDerivationFunction(contextBob->channelContext[0]->s0, contextBob->channelContext[0]->hashLength, (uint8_t *)\"Responder HMAC key\", 18, contextBob->channelContext[0]->KDFContext, contextBob->channelContext[0]->KDFContextLength, contextBob->channelContext[0]->hashLength, (void (*)(uint8_t *, uint8_t,  uint8_t *, uint32_t,  uint8_t,  uint8_t *))contextBob->channelContext[0]->hmacFunction, contextBob->channelContext[0]->mackeyr);\n\tretval += bzrtp_keyDerivationFunction(contextBob->channelContext[0]->s0, contextBob->channelContext[0]->hashLength, (uint8_t *)\"Initiator ZRTP key\", 18, contextBob->channelContext[0]->KDFContext, contextBob->channelContext[0]->KDFContextLength, contextBob->channelContext[0]->cipherKeyLength, (void (*)(uint8_t *, uint8_t,  uint8_t *, uint32_t,  uint8_t,  uint8_t *))contextBob->channelContext[0]->hmacFunction, contextBob->channelContext[0]->zrtpkeyi);\n\tretval += bzrtp_keyDerivationFunction(contextBob->channelContext[0]->s0, contextBob->channelContext[0]->hashLength, (uint8_t *)\"Responder ZRTP key\", 18, contextBob->channelContext[0]->KDFContext, contextBob->channelContext[0]->KDFContextLength, contextBob->channelContext[0]->cipherKeyLength, (void (*)(uint8_t *, uint8_t,  uint8_t *, uint32_t,  uint8_t,  uint8_t *))contextBob->channelContext[0]->hmacFunction, contextBob->channelContext[0]->zrtpkeyr);\n\n\n\t/* DEBUG compare keys */\n\tif ((memcmp(contextAlice->channelContext[0]->mackeyi, contextBob->channelContext[0]->mackeyi, contextAlice->channelContext[0]->hashLength)==0) && (memcmp(contextAlice->channelContext[0]->mackeyr, contextBob->channelContext[0]->mackeyr, contextAlice->channelContext[0]->hashLength)==0) && (memcmp(contextAlice->channelContext[0]->zrtpkeyi, contextBob->channelContext[0]->zrtpkeyi, contextAlice->channelContext[0]->cipherKeyLength)==0) && (memcmp(contextAlice->channelContext[0]->zrtpkeyr, contextBob->channelContext[0]->zrtpkeyr, contextAlice->channelContext[0]->cipherKeyLength)==0)) {\n\t\tbzrtp_message(\"Got the same keys\\n\");\n\t\tCU_PASS(\"keys match\");\n\t} else {\n\t\tbzrtp_message(\"ERROR keys differ\\n\");\n\t\tCU_PASS(\"Keys mismatch\");\n\t}\n\n\t/* now Bob build the CONFIRM1 packet and send it to Alice */\n\tbob_Confirm1 = bzrtp_createZrtpPacket(contextBob, contextBob->channelContext[0], MSGTYPE_CONFIRM1, &retval);\n\tretval += bzrtp_packetBuild(contextBob, contextBob->channelContext[0], bob_Confirm1, contextBob->channelContext[0]->selfSequenceNumber);\n\tif (retval == 0) {\n\t\tcontextBob->channelContext[0]->selfSequenceNumber++;\n\t}\n\tbzrtp_message(\"Bob building Confirm1 return %x\\n\", retval);\n\n\talice_Confirm1FromBob = bzrtp_packetCheck(bob_Confirm1->packetString, bob_Confirm1->messageLength+16, contextAlice->channelContext[0]->peerSequenceNumber, &retval);\n\tretval += bzrtp_packetParser(contextAlice, contextAlice->channelContext[0], bob_Confirm1->packetString, bob_Confirm1->messageLength+16, alice_Confirm1FromBob);\n\tbzrtp_message (\"Alice parsing confirm1 returns %x\\n\", retval);\n\tif (retval==0) {\n\t\t/* update context with the information found in the packet */\n\t\tcontextAlice->channelContext[0]->peerSequenceNumber = alice_Confirm1FromBob->sequenceNumber;\n\t\talice_Confirm1FromBob_message = (bzrtpConfirmMessage_t *)alice_Confirm1FromBob->messageData;\n\t\tmemcpy(contextAlice->channelContext[0]->peerH[0], alice_Confirm1FromBob_message->H0, 32);\n\t}\n\n\tpacketDump(bob_Confirm1,1);\n\tpacketDump(alice_Confirm1FromBob,0);\n\n\tbzrtp_freeZrtpPacket(alice_Confirm1FromBob);\n\tbzrtp_freeZrtpPacket(bob_Confirm1);\n\n\t/* now Alice build the CONFIRM2 packet and send it to Bob */\n\talice_Confirm2 = bzrtp_createZrtpPacket(contextAlice, contextAlice->channelContext[0], MSGTYPE_CONFIRM2, &retval);\n\tretval += bzrtp_packetBuild(contextAlice, contextAlice->channelContext[0], alice_Confirm2, contextAlice->channelContext[0]->selfSequenceNumber);\n\tif (retval == 0) {\n\t\tcontextAlice->channelContext[0]->selfSequenceNumber++;\n\t}\n\tbzrtp_message(\"Alice building Confirm2 return %x\\n\", retval);\n\n\tbob_Confirm2FromAlice = bzrtp_packetCheck(alice_Confirm2->packetString, alice_Confirm2->messageLength+16, contextBob->channelContext[0]->peerSequenceNumber, &retval);\n\tretval += bzrtp_packetParser(contextBob, contextBob->channelContext[0], alice_Confirm2->packetString, alice_Confirm2->messageLength+16, bob_Confirm2FromAlice);\n\tbzrtp_message (\"Bob parsing confirm2 returns %x\\n\", retval);\n\tif (retval==0) {\n\t\t/* update context with the information found in the packet */\n\t\tcontextBob->channelContext[0]->peerSequenceNumber = bob_Confirm2FromAlice->sequenceNumber;\n\t\tbob_Confirm2FromAlice_message = (bzrtpConfirmMessage_t *)bob_Confirm2FromAlice->messageData;\n\t\tmemcpy(contextBob->channelContext[0]->peerH[0], bob_Confirm2FromAlice_message->H0, 32);\n\t\t/* set bob's status to secure */\n\t\tcontextBob->isSecure = 1;\n\t}\n\n\tpacketDump(alice_Confirm2,1);\n\tpacketDump(bob_Confirm2FromAlice,0);\n\n\tbzrtp_freeZrtpPacket(bob_Confirm2FromAlice);\n\tbzrtp_freeZrtpPacket(alice_Confirm2);\n\n\t/* Bob build the conf2Ack and send it to Alice */\n\tbob_Conf2ACK =  bzrtp_createZrtpPacket(contextBob, contextBob->channelContext[0], MSGTYPE_CONF2ACK, &retval);\n\tretval += bzrtp_packetBuild(contextBob, contextBob->channelContext[0], bob_Conf2ACK, contextBob->channelContext[0]->selfSequenceNumber);\n\tif (retval == 0) {\n\t\tcontextBob->channelContext[0]->selfSequenceNumber++;\n\t}\n\tbzrtp_message(\"Bob building Conf2ACK return %x\\n\", retval);\n\n\talice_Conf2ACKFromBob = bzrtp_packetCheck(bob_Conf2ACK->packetString, bob_Conf2ACK->messageLength+16, contextAlice->channelContext[0]->peerSequenceNumber, &retval);\n\tretval += bzrtp_packetParser(contextAlice, contextAlice->channelContext[0], bob_Conf2ACK->packetString, bob_Conf2ACK->messageLength+16, alice_Conf2ACKFromBob);\n\tbzrtp_message (\"Alice parsing conf2ACK returns %x\\n\", retval);\n\tif (retval==0) {\n\t\t/* update context with the information found in the packet */\n\t\tcontextAlice->channelContext[0]->peerSequenceNumber = alice_Conf2ACKFromBob->sequenceNumber;\n\t\t/* set Alice's status to secure */\n\t\tcontextAlice->isSecure = 1;\n\t}\n\n\tbzrtp_freeZrtpPacket(bob_Conf2ACK);\n\tbzrtp_freeZrtpPacket(alice_Conf2ACKFromBob);\n\n\tdumpContext(\"Alice\", contextAlice);\n\tdumpContext(\"Bob\", contextBob);\n\n\tbzrtp_message(\"\\n\\n\\n\\n\\n*************************************************************\\n        SECOND CHANNEL\\n**********************************************\\n\\n\");\n\t/* Now create a second channel for Bob and Alice */\n\tretval = bzrtp_addChannel(contextAlice, 0x45678901);\n\tbzrtp_message(\"Add channel to Alice's context returns %d\\n\", retval);\n\tretval = bzrtp_addChannel(contextBob, 0x54321098);\n\tbzrtp_message(\"Add channel to Bob's context returns %d\\n\", retval);\n\n\t/* create hello packets for this channel */\n\talice_Hello = bzrtp_createZrtpPacket(contextAlice, contextAlice->channelContext[1], MSGTYPE_HELLO, &retval);\n\tif (bzrtp_packetBuild(contextAlice, contextAlice->channelContext[1], alice_Hello, contextAlice->channelContext[1]->selfSequenceNumber) ==0) {\n\t\tcontextAlice->channelContext[1]->selfSequenceNumber++;\n\t\tcontextAlice->channelContext[1]->selfPackets[HELLO_MESSAGE_STORE_ID] = alice_Hello;\n\t}\n\tbob_Hello = bzrtp_createZrtpPacket(contextBob, contextBob->channelContext[1], MSGTYPE_HELLO, &retval);\n\tif (bzrtp_packetBuild(contextBob, contextBob->channelContext[1], bob_Hello, contextBob->channelContext[1]->selfSequenceNumber) ==0) {\n\t\tcontextBob->channelContext[1]->selfSequenceNumber++;\n\t\tcontextBob->channelContext[1]->selfPackets[HELLO_MESSAGE_STORE_ID] = bob_Hello;\n\t}\n\n\t/* now send Alice Hello's to Bob and vice-versa, so they parse them */\n\talice_HelloFromBob = bzrtp_packetCheck(bob_Hello->packetString, bob_Hello->messageLength+16, contextAlice->channelContext[1]->peerSequenceNumber, &retval);\n\tretval +=  bzrtp_packetParser(contextAlice, contextAlice->channelContext[0], bob_Hello->packetString, bob_Hello->messageLength+16, alice_HelloFromBob);\n\tbzrtp_message (\"Alice parsing returns %x\\n\", retval);\n\tif (retval==0) {\n\t\tbzrtpHelloMessage_t *alice_HelloFromBob_message;\n\t\tint i;\n\t\tuint8_t checkPeerSupportMultiChannel = 0;\n\n\t\tcontextAlice->channelContext[1]->peerSequenceNumber = alice_HelloFromBob->sequenceNumber;\n\t\t/* save bob's Hello packet in Alice's context */\n\t\tcontextAlice->channelContext[1]->peerPackets[HELLO_MESSAGE_STORE_ID] = alice_HelloFromBob;\n\n\t\t/* we are already secured (shall check isSecure==1), so we just need to check that peer Hello have the Mult in his key agreement list of supported algo */\n\t\talice_HelloFromBob_message = (bzrtpHelloMessage_t *)alice_HelloFromBob->messageData;\n\t\tfor (i=0; i<alice_HelloFromBob_message->kc; i++) {\n\t\t\tif (alice_HelloFromBob_message->supportedKeyAgreement[i] == ZRTP_KEYAGREEMENT_Mult) {\n\t\t\t\tcheckPeerSupportMultiChannel = 1;\n\t\t\t}\n\t\t}\n\n\t\t/* ok multi channel is supported*/\n\t\tif (checkPeerSupportMultiChannel == 1) {\n\t\t\tbzrtp_message(\"Alice found that Bob supports multi channel\\n\");\n\t\t\t/* now set the choosen algos, they MUST be the same than main channel (channel 0) except for keyAgreement which is set to mult */\n\t\t\tcontextAlice->channelContext[1]->hashAlgo = contextAlice->channelContext[0]->hashAlgo;\n\t\t\tcontextAlice->channelContext[1]->hashLength = contextAlice->channelContext[0]->hashLength;\n\t\t\tcontextAlice->channelContext[1]->cipherAlgo = contextAlice->channelContext[0]->cipherAlgo;\n\t\t\tcontextAlice->channelContext[1]->cipherKeyLength = contextAlice->channelContext[0]->cipherKeyLength;\n\t\t\tcontextAlice->channelContext[1]->authTagAlgo = contextAlice->channelContext[0]->authTagAlgo;\n\t\t\tcontextAlice->channelContext[1]->sasAlgo = contextAlice->channelContext[0]->sasAlgo;\n\t\t\tcontextAlice->channelContext[1]->keyAgreementAlgo = ZRTP_KEYAGREEMENT_Mult;\n\t\t\tcontextAlice->channelContext[1]->keyAgreementLength = 0; /* no public values exchanged in Multi channel mode */\n\n\t\t\tupdateCryptoFunctionPointers(contextAlice->channelContext[1]);\n\t\t} else {\n\t\t\tbzrtp_message(\"ERROR : Alice found that Bob doesn't support multi channel\\n\");\n\t\t}\n\n\t}\n\n\tbob_HelloFromAlice = bzrtp_packetCheck(alice_Hello->packetString, alice_Hello->messageLength+16, contextBob->channelContext[1]->peerSequenceNumber, &retval);\n\tretval +=  bzrtp_packetParser(contextBob, contextBob->channelContext[1], alice_Hello->packetString, alice_Hello->messageLength+16, bob_HelloFromAlice);\n\tbzrtp_message (\"Bob parsing returns %x\\n\", retval);\n\tif (retval==0) {\n\t\tbzrtpHelloMessage_t *bob_HelloFromAlice_message;\n\t\tint i;\n\t\tuint8_t checkPeerSupportMultiChannel = 0;\n\n\t\tcontextBob->channelContext[1]->peerSequenceNumber = bob_HelloFromAlice->sequenceNumber;\n\t\t/* save alice's Hello packet in bob's context */\n\t\tcontextBob->channelContext[1]->peerPackets[HELLO_MESSAGE_STORE_ID] = bob_HelloFromAlice;\n\n\t\t/* we are already secured (shall check isSecure==1), so we just need to check that peer Hello have the Mult in his key agreement list of supported algo */\n\t\tbob_HelloFromAlice_message = (bzrtpHelloMessage_t *)bob_HelloFromAlice->messageData;\n\t\tfor (i=0; i<bob_HelloFromAlice_message->kc; i++) {\n\t\t\tif (bob_HelloFromAlice_message->supportedKeyAgreement[i] == ZRTP_KEYAGREEMENT_Mult) {\n\t\t\t\tcheckPeerSupportMultiChannel = 1;\n\t\t\t}\n\t\t}\n\n\t\t/* ok multi channel is supported*/\n\t\tif (checkPeerSupportMultiChannel == 1) {\n\t\t\tbzrtp_message(\"Bob found that Alice supports multi channel\\n\");\n\t\t\t/* now set the choosen algos, they MUST be the same than main channel (channel 0) except for keyAgreement which is set to mult */\n\t\t\tcontextBob->channelContext[1]->hashAlgo = contextBob->channelContext[0]->hashAlgo;\n\t\t\tcontextBob->channelContext[1]->hashLength = contextBob->channelContext[0]->hashLength;\n\t\t\tcontextBob->channelContext[1]->cipherAlgo = contextBob->channelContext[0]->cipherAlgo;\n\t\t\tcontextBob->channelContext[1]->cipherKeyLength = contextBob->channelContext[0]->cipherKeyLength;\n\t\t\tcontextBob->channelContext[1]->authTagAlgo = contextBob->channelContext[0]->authTagAlgo;\n\t\t\tcontextBob->channelContext[1]->sasAlgo = contextBob->channelContext[0]->sasAlgo;\n\t\t\tcontextBob->channelContext[1]->keyAgreementAlgo = ZRTP_KEYAGREEMENT_Mult;\n\t\t\tcontextBob->channelContext[1]->keyAgreementLength = 0; /* no public values exchanged in Multi channel mode */\n\n\t\t\tupdateCryptoFunctionPointers(contextBob->channelContext[1]);\n\t\t} else {\n\t\t\tbzrtp_message(\"ERROR : Bob found that Alice doesn't support multi channel\\n\");\n\t\t}\n\t}\n\n\t/* update context with hello message information : H3  and compute initiator and responder's shared secret Hashs */\n\talice_HelloFromBob_message = (bzrtpHelloMessage_t *)alice_HelloFromBob->messageData;\n\tmemcpy(contextAlice->channelContext[1]->peerH[3], alice_HelloFromBob_message->H3, 32);\n\tbob_HelloFromAlice_message = (bzrtpHelloMessage_t *)bob_HelloFromAlice->messageData;\n\tmemcpy(contextBob->channelContext[1]->peerH[3], bob_HelloFromAlice_message->H3, 32);\n\n\n\t/* here we shall exchange Hello ACK but it is just a test and was done already for channel 0, skip it as it is useless for the test */\n\n\t/* Bob will be the initiator, so compute a commit for him */\n\tbob_Commit = bzrtp_createZrtpPacket(contextBob, contextBob->channelContext[1], MSGTYPE_COMMIT, &retval);\n\tretval += bzrtp_packetBuild(contextBob, contextBob->channelContext[1], bob_Commit, contextBob->channelContext[1]->selfSequenceNumber);\n\tif (retval == 0) {\n\t\tcontextBob->channelContext[1]->selfSequenceNumber++;\n\t\tcontextBob->channelContext[1]->selfPackets[COMMIT_MESSAGE_STORE_ID] = bob_Commit;\n\t}\n\tbzrtp_message(\"Bob building Commit return %x\\n\", retval);\n\n\n\t/* and send it to Alice */\n\talice_CommitFromBob = bzrtp_packetCheck(bob_Commit->packetString, bob_Commit->messageLength+16, contextAlice->channelContext[1]->peerSequenceNumber, &retval);\n\tretval += bzrtp_packetParser(contextAlice, contextAlice->channelContext[1], bob_Commit->packetString, bob_Commit->messageLength+16, alice_CommitFromBob);\n\tbzrtp_message (\"Alice parsing Commit returns %x\\n\", retval);\n\tif (retval==0) {\n\t\tbzrtpCommitMessage_t *alice_CommitFromBob_message;\n\n\t\t/* update context with the information found in the packet */\n\t\tcontextAlice->channelContext[1]->peerSequenceNumber = alice_CommitFromBob->sequenceNumber;\n\t\t/* Alice will be the initiator (commit contention not implemented in this test) so just discard bob's commit */\n\t\talice_CommitFromBob_message = (bzrtpCommitMessage_t *)alice_CommitFromBob->messageData;\n\t\tmemcpy(contextAlice->channelContext[1]->peerH[2], alice_CommitFromBob_message->H2, 32);\n\t\tcontextAlice->channelContext[1]->peerPackets[COMMIT_MESSAGE_STORE_ID] = alice_CommitFromBob;\n\t}\n\tpacketDump(alice_CommitFromBob, 0);\n\n\t/* for test purpose define Alice as the responder */\n\tcontextAlice->channelContext[1]->role = RESPONDER;\n\n\t/* compute the total hash as in rfc section 4.4.3.2 total_hash = hash(Hello of responder || Commit) */\n\ttotalHashDataLength = alice_Hello->messageLength + bob_Commit->messageLength;\n\tdataToHash = (uint8_t *)malloc(totalHashDataLength*sizeof(uint8_t));\n\thashDataIndex = 0;\n\n\t/* get all data from Alice */\n\tmemcpy(dataToHash, contextAlice->channelContext[1]->selfPackets[HELLO_MESSAGE_STORE_ID]->packetString+ZRTP_PACKET_HEADER_LENGTH, contextAlice->channelContext[1]->selfPackets[HELLO_MESSAGE_STORE_ID]->messageLength);\n\thashDataIndex += contextAlice->channelContext[1]->selfPackets[HELLO_MESSAGE_STORE_ID]->messageLength;\n\tmemcpy(dataToHash+hashDataIndex, contextAlice->channelContext[1]->peerPackets[COMMIT_MESSAGE_STORE_ID]->packetString+ZRTP_PACKET_HEADER_LENGTH, contextAlice->channelContext[1]->peerPackets[COMMIT_MESSAGE_STORE_ID]->messageLength);\n\tcontextAlice->channelContext[1]->hashFunction(dataToHash, totalHashDataLength, 32, alice_totalHash);\n\n\t/* get all data from Bob */\n\thashDataIndex = 0;\n\tmemcpy(dataToHash, contextBob->channelContext[1]->peerPackets[HELLO_MESSAGE_STORE_ID]->packetString+ZRTP_PACKET_HEADER_LENGTH, contextBob->channelContext[1]->peerPackets[HELLO_MESSAGE_STORE_ID]->messageLength);\n\thashDataIndex += contextBob->channelContext[1]->peerPackets[HELLO_MESSAGE_STORE_ID]->messageLength;\n\tmemcpy(dataToHash+hashDataIndex, contextBob->channelContext[1]->selfPackets[COMMIT_MESSAGE_STORE_ID]->packetString+ZRTP_PACKET_HEADER_LENGTH, contextBob->channelContext[1]->selfPackets[COMMIT_MESSAGE_STORE_ID]->messageLength);\n\n\tcontextBob->channelContext[1]->hashFunction(dataToHash, totalHashDataLength, 32, bob_totalHash);\n\tif (memcmp(bob_totalHash, alice_totalHash, 32) == 0) {\n\t\tbzrtp_message(\"Got the same total hash\\n\");\n\t\tCU_PASS(\"Total Hash match\");\n\t} else {\n\t\tbzrtp_message(\"AARGG!! total hash mismatch\");\n\t\tCU_FAIL(\"Total Hash mismatch\");\n\t}\n\n\tfree(dataToHash);\n\n\n\t/* compute the KDF Context as in rfc section 4.4.3.2 KDF_Context = (ZIDi || ZIDr || total_hash) */\n\tcontextAlice->channelContext[1]->KDFContextLength = 24 + contextAlice->channelContext[1]->hashLength;\n\tcontextAlice->channelContext[1]->KDFContext = (uint8_t *)malloc(contextAlice->channelContext[1]->KDFContextLength*sizeof(uint8_t));\n\tmemcpy(contextAlice->channelContext[1]->KDFContext, contextAlice->peerZID, 12);\n\tmemcpy(contextAlice->channelContext[1]->KDFContext+12, contextAlice->selfZID, 12);\n\tmemcpy(contextAlice->channelContext[1]->KDFContext+24, alice_totalHash, contextAlice->channelContext[1]->hashLength);\n\n\tcontextBob->channelContext[1]->KDFContextLength = 24 + contextBob->channelContext[1]->hashLength;\n\tcontextBob->channelContext[1]->KDFContext = (uint8_t *)malloc(contextBob->channelContext[1]->KDFContextLength*sizeof(uint8_t));\n\tmemcpy(contextBob->channelContext[1]->KDFContext, contextBob->selfZID, 12);\n\tmemcpy(contextBob->channelContext[1]->KDFContext+12, contextBob->peerZID, 12);\n\tmemcpy(contextBob->channelContext[1]->KDFContext+24, bob_totalHash, contextBob->channelContext[1]->hashLength);\n\n\tif (memcmp(contextBob->channelContext[1]->KDFContext, contextAlice->channelContext[1]->KDFContext, 56) == 0) {\n\t\tbzrtp_message(\"Got the same total KDF Context\\n\");\n\t\tCU_PASS(\"KDFContext match\");\n\t} else {\n\t\tbzrtp_message(\"AARGG!! KDF Context mismatch\");\n\t\tCU_FAIL(\"KDF Context mismatch\");\n\t}\n\n\t/* compute s0 as in rfc section 4.4.3.2  s0 = KDF(ZRTPSess, \"ZRTP MSK\", KDF_Context, negotiated hash length) */\n\tcontextBob->channelContext[1]->s0 = (uint8_t *)malloc(contextBob->channelContext[1]->hashLength*sizeof(uint8_t));\n\tcontextAlice->channelContext[1]->s0 = (uint8_t *)malloc(contextAlice->channelContext[1]->hashLength*sizeof(uint8_t));\n\tretval = bzrtp_keyDerivationFunction(contextBob->ZRTPSess, contextBob->ZRTPSessLength,\n\t\t(uint8_t *)\"ZRTP MSK\", 8,\n\t\tcontextBob->channelContext[1]->KDFContext, contextBob->channelContext[1]->KDFContextLength, /* this one too depends on selected hash */\n\t\tcontextBob->channelContext[1]->hashLength,\n\t\t(void (*)(uint8_t *, uint8_t,  uint8_t *, uint32_t,  uint8_t,  uint8_t *))contextBob->channelContext[1]->hmacFunction,\n\t\tcontextBob->channelContext[1]->s0);\n\n\tretval = bzrtp_keyDerivationFunction(contextAlice->ZRTPSess, contextAlice->ZRTPSessLength,\n\t\t(uint8_t *)\"ZRTP MSK\", 8,\n\t\tcontextAlice->channelContext[1]->KDFContext, contextAlice->channelContext[1]->KDFContextLength, /* this one too depends on selected hash */\n\t\tcontextAlice->channelContext[1]->hashLength,\n\t\t(void (*)(uint8_t *, uint8_t,  uint8_t *, uint32_t,  uint8_t,  uint8_t *))contextAlice->channelContext[1]->hmacFunction,\n\t\tcontextAlice->channelContext[1]->s0);\n\n\tif (memcmp(contextBob->channelContext[1]->s0, contextAlice->channelContext[1]->s0, contextAlice->channelContext[1]->hashLength) == 0) {\n\t\tbzrtp_message(\"Got the same s0\\n\");\n\t\tCU_PASS(\"s0 match\");\n\t} else {\n\t\tbzrtp_message(\"AARGG!! s0 mismatch\");\n\t\tCU_FAIL(\"s0 mismatch\");\n\t}\n\n\n\t/* the rest of key derivation is common to DH mode, no need to test it as it has been done before for channel 0 */\n\t/* we must anyway derive zrtp and mac key for initiator and responder in order to be able to build the confirm packets */\n\tcontextAlice->channelContext[1]->mackeyi = (uint8_t *)malloc(contextAlice->channelContext[1]->hashLength*(sizeof(uint8_t)));\n\tcontextAlice->channelContext[1]->mackeyr = (uint8_t *)malloc(contextAlice->channelContext[1]->hashLength*(sizeof(uint8_t)));\n\tcontextAlice->channelContext[1]->zrtpkeyi = (uint8_t *)malloc(contextAlice->channelContext[1]->cipherKeyLength*(sizeof(uint8_t)));\n\tcontextAlice->channelContext[1]->zrtpkeyr = (uint8_t *)malloc(contextAlice->channelContext[1]->cipherKeyLength*(sizeof(uint8_t)));\n\tcontextBob->channelContext[1]->mackeyi = (uint8_t *)malloc(contextBob->channelContext[1]->hashLength*(sizeof(uint8_t)));\n\tcontextBob->channelContext[1]->mackeyr = (uint8_t *)malloc(contextBob->channelContext[1]->hashLength*(sizeof(uint8_t)));\n\tcontextBob->channelContext[1]->zrtpkeyi = (uint8_t *)malloc(contextBob->channelContext[1]->cipherKeyLength*(sizeof(uint8_t)));\n\tcontextBob->channelContext[1]->zrtpkeyr = (uint8_t *)malloc(contextBob->channelContext[1]->cipherKeyLength*(sizeof(uint8_t)));\n\n\t/* Alice */\n\tretval = bzrtp_keyDerivationFunction(contextAlice->channelContext[1]->s0, contextAlice->channelContext[1]->hashLength, (uint8_t *)\"Initiator HMAC key\", 18, contextAlice->channelContext[1]->KDFContext, contextAlice->channelContext[1]->KDFContextLength, contextAlice->channelContext[1]->hashLength, (void (*)(uint8_t *, uint8_t,  uint8_t *, uint32_t,  uint8_t,  uint8_t *))contextAlice->channelContext[1]->hmacFunction, contextAlice->channelContext[1]->mackeyi);\n\tretval += bzrtp_keyDerivationFunction(contextAlice->channelContext[1]->s0, contextAlice->channelContext[1]->hashLength, (uint8_t *)\"Responder HMAC key\", 18, contextAlice->channelContext[1]->KDFContext, contextAlice->channelContext[1]->KDFContextLength, contextAlice->channelContext[1]->hashLength, (void (*)(uint8_t *, uint8_t,  uint8_t *, uint32_t,  uint8_t,  uint8_t *))contextAlice->channelContext[1]->hmacFunction, contextAlice->channelContext[1]->mackeyr);\n\tretval += bzrtp_keyDerivationFunction(contextAlice->channelContext[1]->s0, contextAlice->channelContext[1]->hashLength, (uint8_t *)\"Initiator ZRTP key\", 18, contextAlice->channelContext[1]->KDFContext, contextAlice->channelContext[1]->KDFContextLength, contextAlice->channelContext[1]->cipherKeyLength, (void (*)(uint8_t *, uint8_t,  uint8_t *, uint32_t,  uint8_t,  uint8_t *))contextAlice->channelContext[1]->hmacFunction, contextAlice->channelContext[1]->zrtpkeyi);\n\tretval += bzrtp_keyDerivationFunction(contextAlice->channelContext[1]->s0, contextAlice->channelContext[1]->hashLength, (uint8_t *)\"Responder ZRTP key\", 18, contextAlice->channelContext[1]->KDFContext, contextAlice->channelContext[1]->KDFContextLength, contextAlice->channelContext[1]->cipherKeyLength, (void (*)(uint8_t *, uint8_t,  uint8_t *, uint32_t,  uint8_t,  uint8_t *))contextAlice->channelContext[1]->hmacFunction, contextAlice->channelContext[1]->zrtpkeyr);\n\n\t/* Bob */\n\tretval = bzrtp_keyDerivationFunction(contextBob->channelContext[1]->s0, contextBob->channelContext[1]->hashLength, (uint8_t *)\"Initiator HMAC key\", 18, contextBob->channelContext[1]->KDFContext, contextBob->channelContext[1]->KDFContextLength, contextBob->channelContext[1]->hashLength, (void (*)(uint8_t *, uint8_t,  uint8_t *, uint32_t,  uint8_t,  uint8_t *))contextBob->channelContext[1]->hmacFunction, contextBob->channelContext[1]->mackeyi);\n\tretval += bzrtp_keyDerivationFunction(contextBob->channelContext[1]->s0, contextBob->channelContext[1]->hashLength, (uint8_t *)\"Responder HMAC key\", 18, contextBob->channelContext[1]->KDFContext, contextBob->channelContext[1]->KDFContextLength, contextBob->channelContext[1]->hashLength, (void (*)(uint8_t *, uint8_t,  uint8_t *, uint32_t,  uint8_t,  uint8_t *))contextBob->channelContext[1]->hmacFunction, contextBob->channelContext[1]->mackeyr);\n\tretval += bzrtp_keyDerivationFunction(contextBob->channelContext[1]->s0, contextBob->channelContext[1]->hashLength, (uint8_t *)\"Initiator ZRTP key\", 18, contextBob->channelContext[1]->KDFContext, contextBob->channelContext[1]->KDFContextLength, contextBob->channelContext[1]->cipherKeyLength, (void (*)(uint8_t *, uint8_t,  uint8_t *, uint32_t,  uint8_t,  uint8_t *))contextBob->channelContext[1]->hmacFunction, contextBob->channelContext[1]->zrtpkeyi);\n\tretval += bzrtp_keyDerivationFunction(contextBob->channelContext[1]->s0, contextBob->channelContext[1]->hashLength, (uint8_t *)\"Responder ZRTP key\", 18, contextBob->channelContext[1]->KDFContext, contextBob->channelContext[1]->KDFContextLength, contextBob->channelContext[1]->cipherKeyLength, (void (*)(uint8_t *, uint8_t,  uint8_t *, uint32_t,  uint8_t,  uint8_t *))contextBob->channelContext[1]->hmacFunction, contextBob->channelContext[1]->zrtpkeyr);\n\n\t/* DEBUG compare keys */\n\tif ((memcmp(contextAlice->channelContext[1]->mackeyi, contextBob->channelContext[1]->mackeyi, contextAlice->channelContext[1]->hashLength)==0) && (memcmp(contextAlice->channelContext[1]->mackeyr, contextBob->channelContext[1]->mackeyr, contextAlice->channelContext[1]->hashLength)==0) && (memcmp(contextAlice->channelContext[1]->zrtpkeyi, contextBob->channelContext[1]->zrtpkeyi, contextAlice->channelContext[1]->cipherKeyLength)==0) && (memcmp(contextAlice->channelContext[1]->zrtpkeyr, contextBob->channelContext[1]->zrtpkeyr, contextAlice->channelContext[1]->cipherKeyLength)==0)) {\n\t\tbzrtp_message(\"Got the same keys\\n\");\n\t\tCU_PASS(\"keys match\");\n\t} else {\n\t\tbzrtp_message(\"ERROR keys differ\\n\");\n\t\tCU_PASS(\"Keys mismatch\");\n\t}\n\n\t/* now Alice build a confirm1 packet */\n\talice_Confirm1 = bzrtp_createZrtpPacket(contextAlice, contextAlice->channelContext[1], MSGTYPE_CONFIRM1, &retval);\n\tretval += bzrtp_packetBuild(contextAlice, contextAlice->channelContext[1], alice_Confirm1, contextAlice->channelContext[1]->selfSequenceNumber);\n\tif (retval == 0) {\n\t\tcontextAlice->channelContext[1]->selfSequenceNumber++;\n\t}\n\tbzrtp_message(\"Alice building Confirm1 return %x\\n\", retval);\n\n\tbob_Confirm1FromAlice = bzrtp_packetCheck(alice_Confirm1->packetString, alice_Confirm1->messageLength+16, contextBob->channelContext[1]->peerSequenceNumber, &retval);\n\tretval += bzrtp_packetParser(contextBob, contextBob->channelContext[1], alice_Confirm1->packetString, alice_Confirm1->messageLength+16, bob_Confirm1FromAlice);\n\tbzrtp_message (\"Bob parsing confirm1 returns %x\\n\", retval);\n\tif (retval==0) {\n\t\t/* update context with the information found in the packet */\n\t\tcontextBob->channelContext[1]->peerSequenceNumber = bob_Confirm1FromAlice->sequenceNumber;\n\t\tbob_Confirm1FromAlice_message = (bzrtpConfirmMessage_t *)bob_Confirm1FromAlice->messageData;\n\t\tmemcpy(contextBob->channelContext[1]->peerH[0], bob_Confirm1FromAlice_message->H0, 32);\n\t}\n\n\tpacketDump(bob_Confirm1FromAlice,0);\n\tbzrtp_freeZrtpPacket(bob_Confirm1FromAlice);\n\tbzrtp_freeZrtpPacket(alice_Confirm1);\n\n\t/* now Bob build the CONFIRM2 packet and send it to Alice */\n\tbob_Confirm2 = bzrtp_createZrtpPacket(contextBob, contextBob->channelContext[1], MSGTYPE_CONFIRM2, &retval);\n\tretval += bzrtp_packetBuild(contextBob, contextBob->channelContext[1], bob_Confirm2, contextBob->channelContext[1]->selfSequenceNumber);\n\tif (retval == 0) {\n\t\tcontextBob->channelContext[1]->selfSequenceNumber++;\n\t}\n\tbzrtp_message(\"Bob building Confirm2 return %x\\n\", retval);\n\talice_Confirm2FromBob = bzrtp_packetCheck(bob_Confirm2->packetString, bob_Confirm2->messageLength+16, contextAlice->channelContext[1]->peerSequenceNumber, &retval);\n\tretval += bzrtp_packetParser(contextAlice, contextAlice->channelContext[1], bob_Confirm2->packetString, bob_Confirm2->messageLength+16, alice_Confirm2FromBob);\n\tbzrtp_message (\"Alice parsing confirm2 returns %x\\n\", retval);\n\tif (retval==0) {\n\t\t/* update context with the information found in the packet */\n\t\tcontextAlice->channelContext[1]->peerSequenceNumber = alice_Confirm2FromBob->sequenceNumber;\n\t\talice_Confirm2FromBob_message = (bzrtpConfirmMessage_t *)alice_Confirm2FromBob->messageData;\n\t\tmemcpy(contextAlice->channelContext[1]->peerH[0], alice_Confirm2FromBob_message->H0, 32);\n\t}\n\n\tpacketDump(alice_Confirm2FromBob,0);\n\tbzrtp_freeZrtpPacket(alice_Confirm2FromBob);\n\tbzrtp_freeZrtpPacket(bob_Confirm2);\n\n\t/* Alice build the conf2Ack and send it to Bob */\n\talice_Conf2ACK =  bzrtp_createZrtpPacket(contextAlice, contextAlice->channelContext[1], MSGTYPE_CONF2ACK, &retval);\n\tretval += bzrtp_packetBuild(contextAlice, contextAlice->channelContext[1], alice_Conf2ACK, contextAlice->channelContext[1]->selfSequenceNumber);\n\tif (retval == 0) {\n\t\tcontextAlice->channelContext[1]->selfSequenceNumber++;\n\t}\n\tbzrtp_message(\"Alice building Conf2ACK return %x\\n\", retval);\n\n\tbob_Conf2ACKFromAlice = bzrtp_packetCheck(alice_Conf2ACK->packetString, alice_Conf2ACK->messageLength+16, contextBob->channelContext[1]->peerSequenceNumber, &retval);\n\tretval += bzrtp_packetParser(contextBob, contextBob->channelContext[1], alice_Conf2ACK->packetString, alice_Conf2ACK->messageLength+16, bob_Conf2ACKFromAlice);\n\tbzrtp_message (\"Bob parsing conf2ACK returns %x\\n\", retval);\n\tif (retval==0) {\n\t\t/* update context with the information found in the packet */\n\t\tcontextBob->channelContext[1]->peerSequenceNumber = bob_Conf2ACKFromAlice->sequenceNumber;\n\t}\n\n\n\tbzrtp_freeZrtpPacket(alice_Conf2ACK);\n\tbzrtp_freeZrtpPacket(bob_Conf2ACKFromAlice);\n\n\n\n\n\n/*\n\tdumpContext(\"\\nAlice\", contextAlice);\n\tdumpContext(\"\\nBob\", contextBob);\n*/\n\tbzrtp_message(\"Destroy the contexts\\n\");\n\t/* destroy the context */\n\tbzrtp_destroyBzrtpContext(contextAlice, 0x45678901);\n\tbzrtp_destroyBzrtpContext(contextBob, 0x54321098);\n\tbzrtp_message(\"Destroy the contexts last channel\\n\");\n\tbzrtp_destroyBzrtpContext(contextBob, 0x87654321);\n\tbzrtp_destroyBzrtpContext(contextAlice, 0x12345678);\n\n}\n\n\ntypedef struct packetDatas_struct {\n\tuint8_t packetString[1000];\n\tuint16_t packetLength;\n} packetDatas_t;\n\n/* Alice and Bob packet queues are globals */\npacketDatas_t aliceQueue[10];\npacketDatas_t bobQueue[10];\nuint8_t aliceQueueIndex = 0;\nuint8_t bobQueueIndex = 0;\n\nuint8_t block_Hello = 0;\n\n/* this is a callback function for send data, just dump the packet */\n/* client Data is a my_Context_t structure */\nint bzrtp_sendData(void *clientData, const uint8_t *packetString, uint16_t packetLength) {\n\t/* get the client Data */\n\tmy_Context_t *contexts = (my_Context_t *)clientData;\n\n/*\tbzrtp_message (\"%s sends a message!\\n\", contexts->nom);\n\tint retval;\n\tbzrtpPacket_t *zrtpPacket = bzrtp_packetCheck(packetString, packetLength, contexts->peerChannelContext->peerSequenceNumber, &retval);\n\tif (retval==0) {\n\t\tretval = bzrtp_packetParser(contexts->peerContext, contexts->peerChannelContext, packetString, packetLength, zrtpPacket);\n\t\tif (retval == 0) {\n*/\t\t/*\tpacketDump(zrtpPacket,0); */\n\t\t/*\tprintHex(\"Data\", packetString, packetLength);*/\n/*\t\t} else {\n\t\t\tbzrtp_message(\"Parse says %04x\\n\", retval);\n\t\t}\n\t} else {\n\t\tbzrtp_message(\"Check says %04x\\n\", retval);\n\t}\n*/\n\t/* put the message in the message queue */\n\tif (contexts->nom[0] == 'A') { /* message sent by Alice, put it in Bob's queue */\n\t\t/* block the first Hello to force going through wait for hello state and check it is retransmitted */\n/*\t\tif ((block_Hello == 0) && (zrtpPacket->messageType == MSGTYPE_HELLO)) {\n\t\t\tblock_Hello = 1;\n\t\t} else {*/\n\t\t\tmemcpy(bobQueue[bobQueueIndex].packetString, packetString, packetLength);\n\t\t\tbobQueue[bobQueueIndex++].packetLength = packetLength;\n/*\t\t}*/\n\t} else {\n\t\tmemcpy(aliceQueue[aliceQueueIndex].packetString, packetString, packetLength);\n\t\taliceQueue[aliceQueueIndex++].packetLength = packetLength;\n\t}\n\n/*\tbzrtp_freeZrtpPacket(zrtpPacket); */\n\n\treturn 0;\n}\n\nuint64_t myCurrentTime = 0; /* we do not need a real time, start at 0 and increment it at each sleep */\nuint64_t getCurrentTimeInMs() {\n\treturn myCurrentTime;\n}\n\nstatic void sleepMs(int ms){\n#ifdef _WIN32\n\tSleep(ms);\n#else\n\tstruct timespec ts;\n\tts.tv_sec=0;\n\tts.tv_nsec=ms*1000000LL;\n\tnanosleep(&ts,NULL);\n#endif\n\tmyCurrentTime +=ms;\n}\n\n/* Ping message length is 24 bytes (already define in packetParser.c out of this scope) */\n#define ZRTP_PINGMESSAGE_FIXED_LENGTH 24\n\nvoid test_stateMachine() {\n\tint retval;\n\tmy_Context_t aliceClientData, bobClientData;\n\tuint64_t initialTime;\n\tuint8_t pingPacketString[ZRTP_PACKET_OVERHEAD+ZRTP_PINGMESSAGE_FIXED_LENGTH]; /* there is no builder for ping packet and it is 24 bytes long(12 bytes of message header, 12 of data + packet overhead*/\n\tuint32_t CRC;\n\tuint8_t *CRCbuffer;\n\tmy_Context_t aliceSecondChannelClientData, bobSecondChannelClientData;\n\tbzrtpCallbacks_t cbs={0} ;\n\n\t/* Create zrtp Context */\n\tbzrtpContext_t *contextAlice = bzrtp_createBzrtpContext(0x12345678); /* Alice's SSRC of main channel is 12345678 */\n\tbzrtpContext_t *contextBob = bzrtp_createBzrtpContext(0x87654321); /* Bob's SSRC of main channel is 87654321 */\n\n\t/* set the cache related callback functions */\n\tcbs.bzrtp_loadCache=floadAlice;\n\tcbs.bzrtp_writeCache=fwriteAlice;\n\tcbs.bzrtp_sendData=bzrtp_sendData;\n\tbzrtp_setCallbacks(contextAlice, &cbs);\n\n\tcbs.bzrtp_loadCache=floadBob;\n\tcbs.bzrtp_writeCache=fwriteBob;\n\tcbs.bzrtp_sendData=bzrtp_sendData;\n\tbzrtp_setCallbacks(contextBob, &cbs);\n\n\t/* create the client Data and associate them to the channel contexts */\n\tmemcpy(aliceClientData.nom, \"Alice\", 6);\n\tmemcpy(bobClientData.nom, \"Bob\", 4);\n\taliceClientData.peerContext = contextBob;\n\taliceClientData.peerChannelContext = contextBob->channelContext[0];\n\tbobClientData.peerContext = contextAlice;\n\tbobClientData.peerChannelContext = contextAlice->channelContext[0];\n\tstrcpy(aliceClientData.zidFilename, \"./ZIDAlice.txt\");\n\tstrcpy(bobClientData.zidFilename, \"./ZIDBob.txt\");\n\n\n\tretval = bzrtp_setClientData(contextAlice, 0x12345678, (void *)&aliceClientData);\n\tretval += bzrtp_setClientData(contextBob, 0x87654321, (void *)&bobClientData);\n\tbzrtp_message(\"Set client data return %x\\n\", retval);\n\n\t/* run the init */\n\tbzrtp_initBzrtpContext(contextAlice);\n\tbzrtp_initBzrtpContext(contextBob);\n\n\t/* now start the engine */\n\tinitialTime = getCurrentTimeInMs();\n\tretval = bzrtp_startChannelEngine(contextAlice, 0x12345678);\n\tbzrtp_message (\"Alice starts return %x\\n\", retval);\n\tretval = bzrtp_startChannelEngine(contextBob, 0x87654321);\n\tbzrtp_message (\"Bob starts return %x\\n\", retval);\n\n\t/* now start infinite loop until we reach secure state */\n\twhile ((contextAlice->isSecure == 0 || contextBob->isSecure == 0) && (getCurrentTimeInMs()-initialTime<5000)){\n\t\tint i;\n\t\t/* first check the message queue */\n\t\tfor (i=0; i<aliceQueueIndex; i++) {\n\t\t\tbzrtp_message(\"Process a message for Alice\\n\");\n\t\t\tretval = bzrtp_processMessage(contextAlice, 0x12345678, aliceQueue[i].packetString, aliceQueue[i].packetLength);\n\t\t\tbzrtp_message(\"Alice processed message %.8s of %d bytes and return %04x\\n\\n\", aliceQueue[i].packetString+16, aliceQueue[i].packetLength, retval);\n\t\t\tmemset(aliceQueue[i].packetString, 0, 1000); /* destroy the packet after sending it to the ZRTP engine */\n\t\t}\n\t\taliceQueueIndex = 0;\n\n\t\tfor (i=0; i<bobQueueIndex; i++) {\n\t\t\tbzrtp_message(\"Process a message for Bob\\n\");\n\t\t\tretval = bzrtp_processMessage(contextBob, 0x87654321, bobQueue[i].packetString, bobQueue[i].packetLength);\n\t\t\tbzrtp_message(\"Bob processed message %.8s of %d bytes and return %04x\\n\\n\", bobQueue[i].packetString+16, bobQueue[i].packetLength, retval);\n\t\t\tmemset(bobQueue[i].packetString, 0, 1000); /* destroy the packet after sending it to the ZRTP engine */\n\t\t}\n\t\tbobQueueIndex = 0;\n\n\n\t\t/* send the actual time to the zrtpContext */\n\t\tbzrtp_iterate(contextAlice, 0x12345678, getCurrentTimeInMs());\n\t\tbzrtp_iterate(contextBob, 0x87654321, getCurrentTimeInMs());\n\n\t\t/* sleep for 10 ms */\n\t\tsleepMs(10);\n\t}\n\n\t/* compare SAS and check we are in secure mode */\n\tif ((contextAlice->isSecure == 1) && (contextBob->isSecure == 1)) { /* don't compare sas if we're not secure at we may not have it */\n\t\tCU_ASSERT_TRUE((memcmp(contextAlice->channelContext[0]->srtpSecrets.sas, contextBob->channelContext[0]->srtpSecrets.sas, 4) == 0));\n\t\t/* call the set verified Sas function */\n\t\tbzrtp_SASVerified(contextAlice);\n\t\tbzrtp_SASVerified(contextBob);\n\t} else {\n\t\tCU_FAIL(\"Unable to reach secure state\");\n\t}\n\n\t/*** Send alice a ping message from Bob ***/\n\t/* set packet header and CRC */\n\t/* preambule */\n\tpingPacketString[0] = 0x10;\n\tpingPacketString[1] = 0x00;\n\t/* Sequence number */\n\tpingPacketString[2] = (uint8_t)((contextBob->channelContext[0]->selfSequenceNumber>>8)&0x00FF);\n\tpingPacketString[3] = (uint8_t)(contextBob->channelContext[0]->selfSequenceNumber&0x00FF);\n\t/* ZRTP magic cookie */\n\tpingPacketString[4] = (uint8_t)((ZRTP_MAGIC_COOKIE>>24)&0xFF);\n\tpingPacketString[5] = (uint8_t)((ZRTP_MAGIC_COOKIE>>16)&0xFF);\n\tpingPacketString[6] = (uint8_t)((ZRTP_MAGIC_COOKIE>>8)&0xFF);\n\tpingPacketString[7] = (uint8_t)(ZRTP_MAGIC_COOKIE&0xFF);\n\t/* Source Identifier : insert bob's one: 0x87654321 */\n\tpingPacketString[8] = 0x87;\n\tpingPacketString[9] = 0x65;\n\tpingPacketString[10] = 0x43;\n\tpingPacketString[11] = 0x21;\n\n\t/* message header */\n\tpingPacketString[12] = 0x50;\n\tpingPacketString[13] = 0x5a;\n\n\t/* length in 32 bits words */\n\tpingPacketString[14] = 0x00;\n\tpingPacketString[15] = 0x06;\n\n\t/* message type \"Ping    \" */\n\tmemcpy(pingPacketString+16, \"Ping    \",8);\n\n\t/* Version on 4 bytes is \"1.10\" */\n\tmemcpy(pingPacketString+24, \"1.10\", 4);\n\n\t/* a endPointHash, use the first 8 bytes of Bob's ZID */\n\tmemcpy(pingPacketString+28, contextBob->selfZID, 8);\n\n\t/* CRC */\n\tCRC = bzrtp_CRC32(pingPacketString, ZRTP_PINGMESSAGE_FIXED_LENGTH+ZRTP_PACKET_HEADER_LENGTH);\n\tCRCbuffer = pingPacketString+ZRTP_PINGMESSAGE_FIXED_LENGTH+ZRTP_PACKET_HEADER_LENGTH;\n\t*CRCbuffer = (uint8_t)((CRC>>24)&0xFF);\n\tCRCbuffer++;\n\t*CRCbuffer = (uint8_t)((CRC>>16)&0xFF);\n\tCRCbuffer++;\n\t*CRCbuffer = (uint8_t)((CRC>>8)&0xFF);\n\tCRCbuffer++;\n\t*CRCbuffer = (uint8_t)(CRC&0xFF);\n\n\tbzrtp_message(\"Process a PING message for Alice\\n\");\n\tretval = bzrtp_processMessage(contextAlice, 0x12345678, pingPacketString, ZRTP_PACKET_OVERHEAD+ZRTP_PINGMESSAGE_FIXED_LENGTH);\n\tbzrtp_message(\"Alice processed PING message and return %04x\\n\\n\", retval);\n\n\n\t/*** now add a second channel ***/\n\tretval = bzrtp_addChannel(contextAlice, 0x34567890);\n\tbzrtp_message(\"Add a channel to Alice context, return %x\\n\", retval);\n\tretval = bzrtp_addChannel(contextBob, 0x09876543);\n\tbzrtp_message(\"Add a channel to Bob context, return %x\\n\", retval);\n\n\t/* create the client Data and associate them to the channel contexts */\n\tmemcpy(aliceSecondChannelClientData.nom, \"Alice\", 6);\n\tmemcpy(bobSecondChannelClientData.nom, \"Bob\", 4);\n\taliceSecondChannelClientData.peerContext = contextBob;\n\taliceSecondChannelClientData.peerChannelContext = contextBob->channelContext[1];\n\tbobSecondChannelClientData.peerContext = contextAlice;\n\tbobSecondChannelClientData.peerChannelContext = contextAlice->channelContext[1];\n\n\tretval = bzrtp_setClientData(contextAlice, 0x34567890, (void *)&aliceSecondChannelClientData);\n\tretval += bzrtp_setClientData(contextBob, 0x09876543, (void *)&bobSecondChannelClientData);\n\tbzrtp_message(\"Set client data return %x\\n\", retval);\n\n\t/* start the channels */\n\tretval = bzrtp_startChannelEngine(contextAlice, 0x34567890);\n\tbzrtp_message (\"Alice starts return %x\\n\", retval);\n\tretval = bzrtp_startChannelEngine(contextBob, 0x09876543);\n\tbzrtp_message (\"Bob starts return %x\\n\", retval);\n\n\t/* now start infinite loop until we reach secure state */\n\twhile ((getCurrentTimeInMs()-initialTime<2000)){\n\t\tint i;\n\t\t/* first check the message queue */\n\t\tfor (i=0; i<aliceQueueIndex; i++) {\n\t\t\tbzrtp_message(\"Process a message for Alice\\n\");\n\t\t\tretval = bzrtp_processMessage(contextAlice, 0x34567890, aliceQueue[i].packetString, aliceQueue[i].packetLength);\n\t\t\tbzrtp_message(\"Alice processed message %.8s of %d bytes and return %04x\\n\\n\", aliceQueue[i].packetString+16, aliceQueue[i].packetLength, retval);\n\t\t\tmemset(aliceQueue[i].packetString, 0, 1000); /* destroy the packet after sending it to the ZRTP engine */\n\t\t}\n\t\taliceQueueIndex = 0;\n\n\t\tfor (i=0; i<bobQueueIndex; i++) {\n\t\t\tbzrtp_message(\"Process a message for Bob\\n\");\n\t\t\tretval = bzrtp_processMessage(contextBob, 0x09876543, bobQueue[i].packetString, bobQueue[i].packetLength);\n\t\t\tbzrtp_message(\"Bob processed message %.8s  of %d bytes and return %04x\\n\\n\", bobQueue[i].packetString+16, bobQueue[i].packetLength, retval);\n\t\t\tmemset(bobQueue[i].packetString, 0, 1000); /* destroy the packet after sending it to the ZRTP engine */\n\t\t}\n\t\tbobQueueIndex = 0;\n\n\n\t\t/* send the actual time to the zrtpContext */\n\t\tbzrtp_iterate(contextAlice, 0x34567890, getCurrentTimeInMs());\n\t\tbzrtp_iterate(contextBob, 0x09876543, getCurrentTimeInMs());\n\n\n\t\t/* sleep for 10 ms */\n\t\tsleepMs(10);\n\t}\n\n\n\tCU_ASSERT_TRUE((memcmp(contextAlice->channelContext[1]->srtpSecrets.selfSrtpKey, contextBob->channelContext[1]->srtpSecrets.peerSrtpKey, 16) == 0) && (contextAlice->isSecure == 1) && (contextBob->isSecure == 1));\n\n\tdumpContext(\"\\nAlice\", contextAlice);\n\tdumpContext(\"\\nBob\", contextBob);\n\n\n\n\tbzrtp_message(\"Destroy the contexts\\n\");\n\t/* destroy the context */\n\tbzrtp_destroyBzrtpContext(contextAlice, 0x34567890);\n\tbzrtp_destroyBzrtpContext(contextBob, 0x09876543);\n\tbzrtp_message(\"Destroy the contexts last channel\\n\");\n\tbzrtp_destroyBzrtpContext(contextBob, 0x87654321);\n\tbzrtp_destroyBzrtpContext(contextAlice, 0x12345678);\n\n\n}\n", "/**\n @file bzrtpCryptoTests.h\n\n @author Johan Pascal\n\n @copyright Copyright (C) 2014 Belledonne Communications, Grenoble, France\n \n This program is free software; you can redistribute it and/or\n modify it under the terms of the GNU General Public License\n as published by the Free Software Foundation; either version 2\n of the License, or (at your option) any later version.\n \n This program is distributed in the hope that it will be useful,\n but WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n GNU General Public License for more details.\n \n You should have received a copy of the GNU General Public License\n along with this program; if not, write to the Free Software\n Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.\n */\nvoid test_parser(void);\nvoid test_parser_hvi(void);\nvoid test_parserComplete(void);\nvoid test_stateMachine(void);\n", "/**\n @file bzrtpTests.c\n\n @author Johan Pascal\n\n @copyright Copyright (C) 2014 Belledonne Communications, Grenoble, France\n \n This program is free software; you can redistribute it and/or\n modify it under the terms of the GNU General Public License\n as published by the Free Software Foundation; either version 2\n of the License, or (at your option) any later version.\n \n This program is distributed in the hope that it will be useful,\n but WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n GNU General Public License for more details.\n \n You should have received a copy of the GNU General Public License\n along with this program; if not, write to the Free Software\n Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.\n */\n\n#include <stdio.h>\n#include \"CUnit/Basic.h\"\n#include \"bzrtpCryptoTest.h\"\n#include \"bzrtpParserTest.h\"\n#include \"typedef.h\"\n#include \"testUtils.h\"\n\n#ifdef HAVE_LIBXML2\n#include <libxml/parser.h>\n#endif\n\t\n\nint main(int argc, char *argv[] ) {\n\tint i, fails_count=0;\n\tCU_pSuite cryptoUtilsTestSuite, parserTestSuite;\n\n\tCU_pSuite *suites[] = {\n\t\t&cryptoUtilsTestSuite,\n\t\t&parserTestSuite,\n\t\tNULL\n\t};\n\n\tif (argc>1) {\n\t\tif (argv[1][0] == '-') {\n\t\t\tif (strcmp(argv[1], \"-verbose\") == 0) {\n\t\t\t\tverbose = 1;\n\t\t\t} else {\n\t\t\t\tprintf (\"Usage:\\n %s [-verbose] to enable extensive logging\\n\", argv[0]);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t} else {\n\t\t\tprintf (\"Usage:\\n %s [-verbose] to enable extensive logging\\n\", argv[0]);\n\t\t\treturn 1;\n\t\t}\n\t}\n#ifdef HAVE_LIBXML2\n\txmlInitParser();\n#endif\n\t\n\t/* initialize the CUnit test registry */\n\tif (CUE_SUCCESS != CU_initialize_registry()) {\n\t\treturn CU_get_error();\n\t}\n\n\t/* Add the cryptoUtils suite to the registry */\n\tcryptoUtilsTestSuite = CU_add_suite(\"Bzrtp Crypto Utils\", NULL, NULL);\n\tCU_add_test(cryptoUtilsTestSuite, \"zrtpKDF\", test_zrtpKDF);\n\tCU_add_test(cryptoUtilsTestSuite, \"CRC32\", test_CRC32);\n\tCU_add_test(cryptoUtilsTestSuite, \"algo agreement\", test_algoAgreement);\n\tCU_add_test(cryptoUtilsTestSuite, \"context algo setter and getter\", test_algoSetterGetter);\n\tCU_add_test(cryptoUtilsTestSuite, \"adding mandatory crypto algorithms if needed\", test_addMandatoryCryptoTypesIfNeeded);\n\n\t/* Add the parser suite to the registry */\n\tparserTestSuite = CU_add_suite(\"Bzrtp ZRTP Packet Parser\", NULL, NULL);\n\tCU_add_test(parserTestSuite, \"Parse\", test_parser);\n\tCU_add_test(parserTestSuite, \"Parse hvi check fail\", test_parser_hvi);\n\tCU_add_test(parserTestSuite, \"Parse Exchange\", test_parserComplete);\n\tCU_add_test(parserTestSuite, \"State machine\", test_stateMachine);\n\n\t/* Run all suites */\n\tfor(i=0; suites[i]; i++){\n\t\tCU_basic_run_suite(*suites[i]);\n\t\tfails_count += CU_get_number_of_tests_failed();\n\t}\n\t\n\t/* cleanup the CUnit registry */\n\tCU_cleanup_registry();\n\n#ifdef HAVE_LIBXML2\n\t/* cleanup libxml2 */\n\txmlCleanupParser();\n#endif\n\n\treturn (fails_count == 0 ? 0 : 1);\n}\n\n"], "filenames": ["include/packetParser.h", "src/packetParser.c", "test/bzrtpParserTest.c", "test/bzrtpParserTest.h", "test/bzrtpTest.c"], "buggy_code_start_loc": [44, 440, 104, 22, 77], "buggy_code_end_loc": [44, 486, 212, 22, 77], "fixing_code_start_loc": [45, 441, 104, 23, 78], "fixing_code_end_loc": [46, 512, 260, 24, 79], "type": "CWE-254", "message": "The Bzrtp library (aka libbzrtp) 1.0.x before 1.0.4 allows man-in-the-middle attackers to conduct spoofing attacks by leveraging a missing HVI check on DHPart2 packet reception.", "other": {"cve": {"id": "CVE-2016-6271", "sourceIdentifier": "cve@mitre.org", "published": "2017-01-18T22:59:00.780", "lastModified": "2017-08-03T01:29:00.320", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The Bzrtp library (aka libbzrtp) 1.0.x before 1.0.4 allows man-in-the-middle attackers to conduct spoofing attacks by leveraging a missing HVI check on DHPart2 packet reception."}, {"lang": "es", "value": "La librer\u00eda Bzrtp (tambi\u00e9n conocida como libbzrtp) 1.0.x en versiones anteriores a 1.0.4 permite a atacantes man-in-the-middle llevar a cabo ataques de suplantaci\u00f3n de identidad aprovechando una comprobaci\u00f3n HVI desaparecida en la recepci\u00f3n de paquetes DHPart2."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-254"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:bzrtp_project:bzrtp:1.0.0:*:*:*:*:*:*:*", "matchCriteriaId": "9536042E-1DA6-4971-85BA-E99A73F877A1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:bzrtp_project:bzrtp:1.0.2:*:*:*:*:*:*:*", "matchCriteriaId": "27EC44AF-7082-4DF3-8ED1-9B380BE2EBDB"}, {"vulnerable": true, "criteria": "cpe:2.3:a:bzrtp_project:bzrtp:1.0.3:*:*:*:*:*:*:*", "matchCriteriaId": "D470019E-5647-4D3F-A70D-DC19CBD5F588"}]}]}], "references": [{"url": "http://www.securityfocus.com/bid/95928", "source": "cve@mitre.org"}, {"url": "https://github.com/BelledonneCommunications/bzrtp/commit/bbb1e6e2f467ee4bd7b9a8c800e4f07343d7d99b", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch"]}, {"url": "https://github.com/gteissier/CVE-2016-6271", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/BelledonneCommunications/bzrtp/commit/bbb1e6e2f467ee4bd7b9a8c800e4f07343d7d99b"}}