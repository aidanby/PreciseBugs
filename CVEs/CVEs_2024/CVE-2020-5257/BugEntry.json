{"buggy_code": ["module Administrate\n  class Order\n    def initialize(attribute = nil, direction = nil)\n      @attribute = attribute\n      @direction = direction || :asc\n    end\n\n    def apply(relation)\n      return order_by_association(relation) unless\n        reflect_association(relation).nil?\n\n      order = \"#{relation.table_name}.#{attribute} #{direction}\"\n\n      return relation.reorder(Arel.sql(order)) if\n        relation.columns_hash.keys.include?(attribute.to_s)\n\n      relation\n    end\n\n    def ordered_by?(attr)\n      attr.to_s == attribute.to_s\n    end\n\n    def order_params_for(attr)\n      {\n        order: attr,\n        direction: reversed_direction_param_for(attr)\n      }\n    end\n\n    attr_reader :direction\n\n    private\n\n    attr_reader :attribute\n\n    def reversed_direction_param_for(attr)\n      if ordered_by?(attr)\n        opposite_direction\n      else\n        :asc\n      end\n    end\n\n    def opposite_direction\n      direction.to_sym == :asc ? :desc : :asc\n    end\n\n    def order_by_association(relation)\n      return order_by_count(relation) if has_many_attribute?(relation)\n\n      return order_by_id(relation) if belongs_to_attribute?(relation)\n\n      relation\n    end\n\n    def order_by_count(relation)\n      relation.\n        left_joins(attribute.to_sym).\n        group(:id).\n        reorder(\"COUNT(#{attribute}.id) #{direction}\")\n    end\n\n    def order_by_id(relation)\n      relation.reorder(\"#{foreign_key(relation)} #{direction}\")\n    end\n\n    def has_many_attribute?(relation)\n      reflect_association(relation).macro == :has_many\n    end\n\n    def belongs_to_attribute?(relation)\n      reflect_association(relation).macro == :belongs_to\n    end\n\n    def reflect_association(relation)\n      relation.klass.reflect_on_association(attribute.to_s)\n    end\n\n    def foreign_key(relation)\n      reflect_association(relation).foreign_key\n    end\n  end\nend\n", "require \"active_record\"\nrequire \"administrate/order\"\n\ndescribe Administrate::Order do\n  describe \"#apply\" do\n    context \"when `order` argument is nil\" do\n      it \"doesn't sort the resources\" do\n        order = Administrate::Order.new(nil, :desc)\n        relation = relation_with_column(:id)\n        allow(relation).to receive(:reorder).and_return(relation)\n\n        ordered = order.apply(relation)\n\n        expect(relation).not_to have_received(:reorder)\n        expect(ordered).to eq(relation)\n      end\n    end\n\n    context \"when `order` argument isn't a valid column\" do\n      it \"ignores the order\" do\n        order = Administrate::Order.new(:foo)\n        relation = relation_with_column(:id)\n        allow(relation).to receive(:reorder).and_return(relation)\n\n        ordered = order.apply(relation)\n\n        expect(relation).not_to have_received(:reorder)\n        expect(ordered).to eq(relation)\n      end\n    end\n\n    context \"when `order` argument is valid\" do\n      it \"orders by the column\" do\n        order = Administrate::Order.new(:name, :asc)\n        relation = relation_with_column(:name)\n        allow(relation).to receive(:reorder).and_return(relation)\n\n        ordered = order.apply(relation)\n\n        expect(relation).to have_received(:reorder).with(\"table_name.name asc\")\n        expect(ordered).to eq(relation)\n      end\n\n      it \"honors the `direction` argument\" do\n        order = Administrate::Order.new(:name, :desc)\n        relation = relation_with_column(:name)\n        allow(relation).to receive(:reorder).and_return(relation)\n\n        ordered = order.apply(relation)\n\n        expect(relation).to have_received(:reorder).with(\"table_name.name desc\")\n        expect(ordered).to eq(relation)\n      end\n    end\n\n    context \"when relation has_many association\" do\n      it \"orders the column by count\" do\n        order = Administrate::Order.new(:name)\n        relation = relation_with_association(:has_many)\n        allow(relation).to receive(:reorder).and_return(relation)\n        allow(relation).to receive(:left_joins).and_return(relation)\n        allow(relation).to receive(:group).and_return(relation)\n\n        ordered = order.apply(relation)\n\n        expect(relation).to have_received(:left_joins).with(:name)\n        expect(relation).to have_received(:group).with(:id)\n        expect(relation).to have_received(:reorder).with(\"COUNT(name.id) asc\")\n        expect(ordered).to eq(relation)\n      end\n    end\n\n    context \"when relation has belongs_to association\" do\n      it \"orders by id\" do\n        order = Administrate::Order.new(:name)\n        relation = relation_with_association(\n          :belongs_to,\n          foreign_key: \"some_foreign_key\",\n        )\n        allow(relation).to receive(:reorder).and_return(relation)\n\n        ordered = order.apply(relation)\n\n        expect(relation).to have_received(:reorder).with(\"some_foreign_key asc\")\n        expect(ordered).to eq(relation)\n      end\n    end\n  end\n\n  describe \"#ordered_by?\" do\n    it \"returns true if the order is by the given attribute\" do\n      order = Administrate::Order.new(:name, :desc)\n\n      expect(order).to be_ordered_by(\"name\")\n    end\n\n    it \"returns false if the order is not by the given attribute\" do\n      order = Administrate::Order.new(:email, :desc)\n\n      expect(order).not_to be_ordered_by(:name)\n    end\n\n    it \"returns false if there is no order\" do\n      order = Administrate::Order.new(nil, :desc)\n\n      expect(order).not_to be_ordered_by(:name)\n    end\n  end\n\n  describe \"#order_params_for\" do\n    context \"when there is no order\" do\n      it \"returns the attribute\" do\n        order = Administrate::Order.new(nil)\n\n        params = order.order_params_for(:name)\n\n        expect(params[:order]).to eq(:name)\n      end\n\n      it \"does not sort descending\" do\n        order = Administrate::Order.new(nil)\n\n        params = order.order_params_for(:name)\n\n        expect(params[:direction]).to eq(:asc)\n      end\n    end\n\n    context \"when the order is by a different attribute\" do\n      it \"returns the attribute\" do\n        order = Administrate::Order.new(:email)\n\n        params = order.order_params_for(:name)\n\n        expect(params[:order]).to eq(:name)\n      end\n\n      it \"sorts ascending\" do\n        order = Administrate::Order.new(:email)\n\n        params = order.order_params_for(:name)\n\n        expect(params[:direction]).to eq(:asc)\n      end\n    end\n\n    context \"when the data is already ordered by the given attribute\" do\n      it \"returns the attribute\" do\n        order = Administrate::Order.new(:name)\n\n        params = order.order_params_for(:name)\n\n        expect(params[:order]).to eq(:name)\n      end\n\n      it \"orders the data descending if it's not already\" do\n        order = Administrate::Order.new(\"name\")\n\n        params = order.order_params_for(:name)\n\n        expect(params[:direction]).to eq(:desc)\n      end\n\n      it \"sets direction ascending if the data is already descending\" do\n        order = Administrate::Order.new(:name, \"desc\")\n\n        params = order.order_params_for(:name)\n\n        expect(params[:direction]).to eq(:asc)\n      end\n    end\n  end\n\n  def relation_with_column(column)\n    double(\n      klass: double(reflect_on_association: nil),\n      columns_hash: { column.to_s => :column_info },\n      table_name: \"table_name\",\n    )\n  end\n\n  def relation_with_association(association, foreign_key: \"#{association}_id\")\n    double(\n      klass: double(\n        reflect_on_association: double(\n          \"#{association}_reflection\",\n          macro: association,\n          foreign_key: foreign_key,\n        ),\n      ),\n    )\n  end\nend\n"], "fixing_code": ["module Administrate\n  class Order\n    def initialize(attribute = nil, direction = nil)\n      @attribute = attribute\n      @direction = sanitize_direction(direction)\n    end\n\n    def apply(relation)\n      return order_by_association(relation) unless\n        reflect_association(relation).nil?\n\n      order = \"#{relation.table_name}.#{attribute} #{direction}\"\n\n      return relation.reorder(Arel.sql(order)) if\n        relation.columns_hash.keys.include?(attribute.to_s)\n\n      relation\n    end\n\n    def ordered_by?(attr)\n      attr.to_s == attribute.to_s\n    end\n\n    def order_params_for(attr)\n      {\n        order: attr,\n        direction: reversed_direction_param_for(attr)\n      }\n    end\n\n    attr_reader :direction\n\n    private\n\n    attr_reader :attribute\n\n    def sanitize_direction(direction)\n      %w[asc desc].include?(direction.to_s) ? direction.to_sym : :asc\n    end\n\n    def reversed_direction_param_for(attr)\n      if ordered_by?(attr)\n        opposite_direction\n      else\n        :asc\n      end\n    end\n\n    def opposite_direction\n      direction == :asc ? :desc : :asc\n    end\n\n    def order_by_association(relation)\n      return order_by_count(relation) if has_many_attribute?(relation)\n\n      return order_by_id(relation) if belongs_to_attribute?(relation)\n\n      relation\n    end\n\n    def order_by_count(relation)\n      relation.\n        left_joins(attribute.to_sym).\n        group(:id).\n        reorder(\"COUNT(#{attribute}.id) #{direction}\")\n    end\n\n    def order_by_id(relation)\n      relation.reorder(\"#{foreign_key(relation)} #{direction}\")\n    end\n\n    def has_many_attribute?(relation)\n      reflect_association(relation).macro == :has_many\n    end\n\n    def belongs_to_attribute?(relation)\n      reflect_association(relation).macro == :belongs_to\n    end\n\n    def reflect_association(relation)\n      relation.klass.reflect_on_association(attribute.to_s)\n    end\n\n    def foreign_key(relation)\n      reflect_association(relation).foreign_key\n    end\n  end\nend\n", "require \"active_record\"\nrequire \"administrate/order\"\n\ndescribe Administrate::Order do\n  describe \"#apply\" do\n    context \"when `order` argument is nil\" do\n      it \"doesn't sort the resources\" do\n        order = Administrate::Order.new(nil, :desc)\n        relation = relation_with_column(:id)\n        allow(relation).to receive(:reorder).and_return(relation)\n\n        ordered = order.apply(relation)\n\n        expect(relation).not_to have_received(:reorder)\n        expect(ordered).to eq(relation)\n      end\n    end\n\n    context \"when `order` argument isn't a valid column\" do\n      it \"ignores the order\" do\n        order = Administrate::Order.new(:foo)\n        relation = relation_with_column(:id)\n        allow(relation).to receive(:reorder).and_return(relation)\n\n        ordered = order.apply(relation)\n\n        expect(relation).not_to have_received(:reorder)\n        expect(ordered).to eq(relation)\n      end\n    end\n\n    context \"when `order` argument is valid\" do\n      it \"orders by the column\" do\n        order = Administrate::Order.new(:name, :asc)\n        relation = relation_with_column(:name)\n        allow(relation).to receive(:reorder).and_return(relation)\n\n        ordered = order.apply(relation)\n\n        expect(relation).to have_received(:reorder).with(\"table_name.name asc\")\n        expect(ordered).to eq(relation)\n      end\n\n      it \"honors the `direction` argument\" do\n        order = Administrate::Order.new(:name, :desc)\n        relation = relation_with_column(:name)\n        allow(relation).to receive(:reorder).and_return(relation)\n\n        ordered = order.apply(relation)\n\n        expect(relation).to have_received(:reorder).with(\"table_name.name desc\")\n        expect(ordered).to eq(relation)\n      end\n\n      it \"sanitizes arbitary direction parameters\" do\n        order = Administrate::Order.new(:name, :foo)\n        relation = relation_with_column(:name)\n        allow(relation).to receive(:reorder).and_return(relation)\n\n        ordered = order.apply(relation)\n\n        expect(relation).to have_received(:reorder).with(\"table_name.name asc\")\n        expect(ordered).to eq(relation)\n      end\n    end\n\n    context \"when relation has_many association\" do\n      it \"orders the column by count\" do\n        order = Administrate::Order.new(:name)\n        relation = relation_with_association(:has_many)\n        allow(relation).to receive(:reorder).and_return(relation)\n        allow(relation).to receive(:left_joins).and_return(relation)\n        allow(relation).to receive(:group).and_return(relation)\n\n        ordered = order.apply(relation)\n\n        expect(relation).to have_received(:left_joins).with(:name)\n        expect(relation).to have_received(:group).with(:id)\n        expect(relation).to have_received(:reorder).with(\"COUNT(name.id) asc\")\n        expect(ordered).to eq(relation)\n      end\n    end\n\n    context \"when relation has belongs_to association\" do\n      it \"orders by id\" do\n        order = Administrate::Order.new(:name)\n        relation = relation_with_association(\n          :belongs_to,\n          foreign_key: \"some_foreign_key\",\n        )\n        allow(relation).to receive(:reorder).and_return(relation)\n\n        ordered = order.apply(relation)\n\n        expect(relation).to have_received(:reorder).with(\"some_foreign_key asc\")\n        expect(ordered).to eq(relation)\n      end\n    end\n  end\n\n  describe \"#ordered_by?\" do\n    it \"returns true if the order is by the given attribute\" do\n      order = Administrate::Order.new(:name, :desc)\n\n      expect(order).to be_ordered_by(\"name\")\n    end\n\n    it \"returns false if the order is not by the given attribute\" do\n      order = Administrate::Order.new(:email, :desc)\n\n      expect(order).not_to be_ordered_by(:name)\n    end\n\n    it \"returns false if there is no order\" do\n      order = Administrate::Order.new(nil, :desc)\n\n      expect(order).not_to be_ordered_by(:name)\n    end\n  end\n\n  describe \"#order_params_for\" do\n    context \"when there is no order\" do\n      it \"returns the attribute\" do\n        order = Administrate::Order.new(nil)\n\n        params = order.order_params_for(:name)\n\n        expect(params[:order]).to eq(:name)\n      end\n\n      it \"does not sort descending\" do\n        order = Administrate::Order.new(nil)\n\n        params = order.order_params_for(:name)\n\n        expect(params[:direction]).to eq(:asc)\n      end\n    end\n\n    context \"when the order is by a different attribute\" do\n      it \"returns the attribute\" do\n        order = Administrate::Order.new(:email)\n\n        params = order.order_params_for(:name)\n\n        expect(params[:order]).to eq(:name)\n      end\n\n      it \"sorts ascending\" do\n        order = Administrate::Order.new(:email)\n\n        params = order.order_params_for(:name)\n\n        expect(params[:direction]).to eq(:asc)\n      end\n    end\n\n    context \"when the data is already ordered by the given attribute\" do\n      it \"returns the attribute\" do\n        order = Administrate::Order.new(:name)\n\n        params = order.order_params_for(:name)\n\n        expect(params[:order]).to eq(:name)\n      end\n\n      it \"orders the data descending if it's not already\" do\n        order = Administrate::Order.new(\"name\")\n\n        params = order.order_params_for(:name)\n\n        expect(params[:direction]).to eq(:desc)\n      end\n\n      it \"sets direction ascending if the data is already descending\" do\n        order = Administrate::Order.new(:name, \"desc\")\n\n        params = order.order_params_for(:name)\n\n        expect(params[:direction]).to eq(:asc)\n      end\n    end\n  end\n\n  def relation_with_column(column)\n    double(\n      klass: double(reflect_on_association: nil),\n      columns_hash: { column.to_s => :column_info },\n      table_name: \"table_name\",\n    )\n  end\n\n  def relation_with_association(association, foreign_key: \"#{association}_id\")\n    double(\n      klass: double(\n        reflect_on_association: double(\n          \"#{association}_reflection\",\n          macro: association,\n          foreign_key: foreign_key,\n        ),\n      ),\n    )\n  end\nend\n"], "filenames": ["lib/administrate/order.rb", "spec/lib/administrate/order_spec.rb"], "buggy_code_start_loc": [5, 51], "buggy_code_end_loc": [47, 51], "fixing_code_start_loc": [5, 52], "fixing_code_end_loc": [51, 63], "type": "CWE-89", "message": "In Administrate (rubygem) before version 0.13.0, when sorting by attributes on a dashboard, the direction parameter was not validated before being interpolated into the SQL query. This could present a SQL injection if the attacker were able to modify the `direction` parameter and bypass ActiveRecord SQL protections. Whilst this does have a high-impact, to exploit this you need access to the Administrate dashboards, which we would expect to be behind authentication. This is patched in wersion 0.13.0.", "other": {"cve": {"id": "CVE-2020-5257", "sourceIdentifier": "security-advisories@github.com", "published": "2020-03-13T21:15:12.190", "lastModified": "2020-03-18T16:05:25.407", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In Administrate (rubygem) before version 0.13.0, when sorting by attributes on a dashboard, the direction parameter was not validated before being interpolated into the SQL query. This could present a SQL injection if the attacker were able to modify the `direction` parameter and bypass ActiveRecord SQL protections. Whilst this does have a high-impact, to exploit this you need access to the Administrate dashboards, which we would expect to be behind authentication. This is patched in wersion 0.13.0."}, {"lang": "es", "value": "En Administrate (rubygem) versiones anteriores a 0.13.0, cuando se ordenaba por atributos en un panel, el par\u00e1metro direction no se comprobaba antes de ser interpolado en la consulta SQL. Esto podr\u00eda presentar una inyecci\u00f3n SQL si el atacante fuera capaz de modificar el par\u00e1metro \"direction\" y omitir las protecciones de ActiveRecord SQL. Si bien esto tiene un gran impacto, para explotarlo es necesario acceder a los paneles Administrate, que esperar\u00edamos que estuvieran detr\u00e1s de la autenticaci\u00f3n. Esto est\u00e1 parcheado en la versi\u00f3n 0.13.0."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 8.1, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.2}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:L/UI:R/S:C/C:H/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 7.7, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.3, "impactScore": 5.8}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:P/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 5.5}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-89"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-943"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:thoughtbot:administrate:*:*:*:*:*:ruby:*:*", "versionEndExcluding": "0.13.0", "matchCriteriaId": "721AE599-CA75-4123-8175-D0CCAB6EBF79"}]}]}], "references": [{"url": "https://github.com/thoughtbot/administrate/commit/3ab838b83c5f565fba50e0c6f66fe4517f98eed3", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/thoughtbot/administrate/security/advisories/GHSA-2p5p-m353-833w", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/thoughtbot/administrate/commit/3ab838b83c5f565fba50e0c6f66fe4517f98eed3"}}