{"buggy_code": ["// SPDX-License-Identifier: GPL-2.0-only\n/*\n * Driver for the TI bq24190 battery charger.\n *\n * Author: Mark A. Greer <mgreer@animalcreek.com>\n */\n\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n#include <linux/pm_runtime.h>\n#include <linux/power_supply.h>\n#include <linux/power/bq24190_charger.h>\n#include <linux/regulator/driver.h>\n#include <linux/regulator/machine.h>\n#include <linux/workqueue.h>\n#include <linux/i2c.h>\n#include <linux/extcon-provider.h>\n\n#define\tBQ24190_MANUFACTURER\t\"Texas Instruments\"\n\n#define BQ24190_REG_ISC\t\t0x00 /* Input Source Control */\n#define BQ24190_REG_ISC_EN_HIZ_MASK\t\tBIT(7)\n#define BQ24190_REG_ISC_EN_HIZ_SHIFT\t\t7\n#define BQ24190_REG_ISC_VINDPM_MASK\t\t(BIT(6) | BIT(5) | BIT(4) | \\\n\t\t\t\t\t\t BIT(3))\n#define BQ24190_REG_ISC_VINDPM_SHIFT\t\t3\n#define BQ24190_REG_ISC_IINLIM_MASK\t\t(BIT(2) | BIT(1) | BIT(0))\n#define BQ24190_REG_ISC_IINLIM_SHIFT\t\t0\n\n#define BQ24190_REG_POC\t\t0x01 /* Power-On Configuration */\n#define BQ24190_REG_POC_RESET_MASK\t\tBIT(7)\n#define BQ24190_REG_POC_RESET_SHIFT\t\t7\n#define BQ24190_REG_POC_WDT_RESET_MASK\t\tBIT(6)\n#define BQ24190_REG_POC_WDT_RESET_SHIFT\t\t6\n#define BQ24190_REG_POC_CHG_CONFIG_MASK\t\t(BIT(5) | BIT(4))\n#define BQ24190_REG_POC_CHG_CONFIG_SHIFT\t4\n#define BQ24190_REG_POC_CHG_CONFIG_DISABLE\t\t0x0\n#define BQ24190_REG_POC_CHG_CONFIG_CHARGE\t\t0x1\n#define BQ24190_REG_POC_CHG_CONFIG_OTG\t\t\t0x2\n#define BQ24190_REG_POC_CHG_CONFIG_OTG_ALT\t\t0x3\n#define BQ24190_REG_POC_SYS_MIN_MASK\t\t(BIT(3) | BIT(2) | BIT(1))\n#define BQ24190_REG_POC_SYS_MIN_SHIFT\t\t1\n#define BQ24190_REG_POC_SYS_MIN_MIN\t\t\t3000\n#define BQ24190_REG_POC_SYS_MIN_MAX\t\t\t3700\n#define BQ24190_REG_POC_BOOST_LIM_MASK\t\tBIT(0)\n#define BQ24190_REG_POC_BOOST_LIM_SHIFT\t\t0\n\n#define BQ24190_REG_CCC\t\t0x02 /* Charge Current Control */\n#define BQ24190_REG_CCC_ICHG_MASK\t\t(BIT(7) | BIT(6) | BIT(5) | \\\n\t\t\t\t\t\t BIT(4) | BIT(3) | BIT(2))\n#define BQ24190_REG_CCC_ICHG_SHIFT\t\t2\n#define BQ24190_REG_CCC_FORCE_20PCT_MASK\tBIT(0)\n#define BQ24190_REG_CCC_FORCE_20PCT_SHIFT\t0\n\n#define BQ24190_REG_PCTCC\t0x03 /* Pre-charge/Termination Current Cntl */\n#define BQ24190_REG_PCTCC_IPRECHG_MASK\t\t(BIT(7) | BIT(6) | BIT(5) | \\\n\t\t\t\t\t\t BIT(4))\n#define BQ24190_REG_PCTCC_IPRECHG_SHIFT\t\t4\n#define BQ24190_REG_PCTCC_IPRECHG_MIN\t\t\t128\n#define BQ24190_REG_PCTCC_IPRECHG_MAX\t\t\t2048\n#define BQ24190_REG_PCTCC_ITERM_MASK\t\t(BIT(3) | BIT(2) | BIT(1) | \\\n\t\t\t\t\t\t BIT(0))\n#define BQ24190_REG_PCTCC_ITERM_SHIFT\t\t0\n#define BQ24190_REG_PCTCC_ITERM_MIN\t\t\t128\n#define BQ24190_REG_PCTCC_ITERM_MAX\t\t\t2048\n\n#define BQ24190_REG_CVC\t\t0x04 /* Charge Voltage Control */\n#define BQ24190_REG_CVC_VREG_MASK\t\t(BIT(7) | BIT(6) | BIT(5) | \\\n\t\t\t\t\t\t BIT(4) | BIT(3) | BIT(2))\n#define BQ24190_REG_CVC_VREG_SHIFT\t\t2\n#define BQ24190_REG_CVC_BATLOWV_MASK\t\tBIT(1)\n#define BQ24190_REG_CVC_BATLOWV_SHIFT\t\t1\n#define BQ24190_REG_CVC_VRECHG_MASK\t\tBIT(0)\n#define BQ24190_REG_CVC_VRECHG_SHIFT\t\t0\n\n#define BQ24190_REG_CTTC\t0x05 /* Charge Term/Timer Control */\n#define BQ24190_REG_CTTC_EN_TERM_MASK\t\tBIT(7)\n#define BQ24190_REG_CTTC_EN_TERM_SHIFT\t\t7\n#define BQ24190_REG_CTTC_TERM_STAT_MASK\t\tBIT(6)\n#define BQ24190_REG_CTTC_TERM_STAT_SHIFT\t6\n#define BQ24190_REG_CTTC_WATCHDOG_MASK\t\t(BIT(5) | BIT(4))\n#define BQ24190_REG_CTTC_WATCHDOG_SHIFT\t\t4\n#define BQ24190_REG_CTTC_EN_TIMER_MASK\t\tBIT(3)\n#define BQ24190_REG_CTTC_EN_TIMER_SHIFT\t\t3\n#define BQ24190_REG_CTTC_CHG_TIMER_MASK\t\t(BIT(2) | BIT(1))\n#define BQ24190_REG_CTTC_CHG_TIMER_SHIFT\t1\n#define BQ24190_REG_CTTC_JEITA_ISET_MASK\tBIT(0)\n#define BQ24190_REG_CTTC_JEITA_ISET_SHIFT\t0\n\n#define BQ24190_REG_ICTRC\t0x06 /* IR Comp/Thermal Regulation Control */\n#define BQ24190_REG_ICTRC_BAT_COMP_MASK\t\t(BIT(7) | BIT(6) | BIT(5))\n#define BQ24190_REG_ICTRC_BAT_COMP_SHIFT\t5\n#define BQ24190_REG_ICTRC_VCLAMP_MASK\t\t(BIT(4) | BIT(3) | BIT(2))\n#define BQ24190_REG_ICTRC_VCLAMP_SHIFT\t\t2\n#define BQ24190_REG_ICTRC_TREG_MASK\t\t(BIT(1) | BIT(0))\n#define BQ24190_REG_ICTRC_TREG_SHIFT\t\t0\n\n#define BQ24190_REG_MOC\t\t0x07 /* Misc. Operation Control */\n#define BQ24190_REG_MOC_DPDM_EN_MASK\t\tBIT(7)\n#define BQ24190_REG_MOC_DPDM_EN_SHIFT\t\t7\n#define BQ24190_REG_MOC_TMR2X_EN_MASK\t\tBIT(6)\n#define BQ24190_REG_MOC_TMR2X_EN_SHIFT\t\t6\n#define BQ24190_REG_MOC_BATFET_DISABLE_MASK\tBIT(5)\n#define BQ24190_REG_MOC_BATFET_DISABLE_SHIFT\t5\n#define BQ24190_REG_MOC_JEITA_VSET_MASK\t\tBIT(4)\n#define BQ24190_REG_MOC_JEITA_VSET_SHIFT\t4\n#define BQ24190_REG_MOC_INT_MASK_MASK\t\t(BIT(1) | BIT(0))\n#define BQ24190_REG_MOC_INT_MASK_SHIFT\t\t0\n\n#define BQ24190_REG_SS\t\t0x08 /* System Status */\n#define BQ24190_REG_SS_VBUS_STAT_MASK\t\t(BIT(7) | BIT(6))\n#define BQ24190_REG_SS_VBUS_STAT_SHIFT\t\t6\n#define BQ24190_REG_SS_CHRG_STAT_MASK\t\t(BIT(5) | BIT(4))\n#define BQ24190_REG_SS_CHRG_STAT_SHIFT\t\t4\n#define BQ24190_REG_SS_DPM_STAT_MASK\t\tBIT(3)\n#define BQ24190_REG_SS_DPM_STAT_SHIFT\t\t3\n#define BQ24190_REG_SS_PG_STAT_MASK\t\tBIT(2)\n#define BQ24190_REG_SS_PG_STAT_SHIFT\t\t2\n#define BQ24190_REG_SS_THERM_STAT_MASK\t\tBIT(1)\n#define BQ24190_REG_SS_THERM_STAT_SHIFT\t\t1\n#define BQ24190_REG_SS_VSYS_STAT_MASK\t\tBIT(0)\n#define BQ24190_REG_SS_VSYS_STAT_SHIFT\t\t0\n\n#define BQ24190_REG_F\t\t0x09 /* Fault */\n#define BQ24190_REG_F_WATCHDOG_FAULT_MASK\tBIT(7)\n#define BQ24190_REG_F_WATCHDOG_FAULT_SHIFT\t7\n#define BQ24190_REG_F_BOOST_FAULT_MASK\t\tBIT(6)\n#define BQ24190_REG_F_BOOST_FAULT_SHIFT\t\t6\n#define BQ24190_REG_F_CHRG_FAULT_MASK\t\t(BIT(5) | BIT(4))\n#define BQ24190_REG_F_CHRG_FAULT_SHIFT\t\t4\n#define BQ24190_REG_F_BAT_FAULT_MASK\t\tBIT(3)\n#define BQ24190_REG_F_BAT_FAULT_SHIFT\t\t3\n#define BQ24190_REG_F_NTC_FAULT_MASK\t\t(BIT(2) | BIT(1) | BIT(0))\n#define BQ24190_REG_F_NTC_FAULT_SHIFT\t\t0\n\n#define BQ24190_REG_VPRS\t0x0A /* Vendor/Part/Revision Status */\n#define BQ24190_REG_VPRS_PN_MASK\t\t(BIT(5) | BIT(4) | BIT(3))\n#define BQ24190_REG_VPRS_PN_SHIFT\t\t3\n#define BQ24190_REG_VPRS_PN_24190\t\t\t0x4\n#define BQ24190_REG_VPRS_PN_24192\t\t\t0x5 /* Also 24193, 24196 */\n#define BQ24190_REG_VPRS_PN_24192I\t\t\t0x3\n#define BQ24190_REG_VPRS_TS_PROFILE_MASK\tBIT(2)\n#define BQ24190_REG_VPRS_TS_PROFILE_SHIFT\t2\n#define BQ24190_REG_VPRS_DEV_REG_MASK\t\t(BIT(1) | BIT(0))\n#define BQ24190_REG_VPRS_DEV_REG_SHIFT\t\t0\n\n/*\n * The FAULT register is latched by the bq24190 (except for NTC_FAULT)\n * so the first read after a fault returns the latched value and subsequent\n * reads return the current value.  In order to return the fault status\n * to the user, have the interrupt handler save the reg's value and retrieve\n * it in the appropriate health/status routine.\n */\nstruct bq24190_dev_info {\n\tstruct i2c_client\t\t*client;\n\tstruct device\t\t\t*dev;\n\tstruct extcon_dev\t\t*edev;\n\tstruct power_supply\t\t*charger;\n\tstruct power_supply\t\t*battery;\n\tstruct delayed_work\t\tinput_current_limit_work;\n\tchar\t\t\t\tmodel_name[I2C_NAME_SIZE];\n\tbool\t\t\t\tinitialized;\n\tbool\t\t\t\tirq_event;\n\tbool\t\t\t\totg_vbus_enabled;\n\tint\t\t\t\tcharge_type;\n\tu16\t\t\t\tsys_min;\n\tu16\t\t\t\tiprechg;\n\tu16\t\t\t\titerm;\n\tu32\t\t\t\tichg;\n\tu32\t\t\t\tichg_max;\n\tu32\t\t\t\tvreg;\n\tu32\t\t\t\tvreg_max;\n\tstruct mutex\t\t\tf_reg_lock;\n\tu8\t\t\t\tf_reg;\n\tu8\t\t\t\tss_reg;\n\tu8\t\t\t\twatchdog;\n};\n\nstatic int bq24190_charger_set_charge_type(struct bq24190_dev_info *bdi,\n\t\t\t\t\t   const union power_supply_propval *val);\n\nstatic const unsigned int bq24190_usb_extcon_cable[] = {\n\tEXTCON_USB,\n\tEXTCON_NONE,\n};\n\n/*\n * The tables below provide a 2-way mapping for the value that goes in\n * the register field and the real-world value that it represents.\n * The index of the array is the value that goes in the register; the\n * number at that index in the array is the real-world value that it\n * represents.\n */\n\n/* REG00[2:0] (IINLIM) in uAh */\nstatic const int bq24190_isc_iinlim_values[] = {\n\t 100000,  150000,  500000,  900000, 1200000, 1500000, 2000000, 3000000\n};\n\n/* REG02[7:2] (ICHG) in uAh */\nstatic const int bq24190_ccc_ichg_values[] = {\n\t 512000,  576000,  640000,  704000,  768000,  832000,  896000,  960000,\n\t1024000, 1088000, 1152000, 1216000, 1280000, 1344000, 1408000, 1472000,\n\t1536000, 1600000, 1664000, 1728000, 1792000, 1856000, 1920000, 1984000,\n\t2048000, 2112000, 2176000, 2240000, 2304000, 2368000, 2432000, 2496000,\n\t2560000, 2624000, 2688000, 2752000, 2816000, 2880000, 2944000, 3008000,\n\t3072000, 3136000, 3200000, 3264000, 3328000, 3392000, 3456000, 3520000,\n\t3584000, 3648000, 3712000, 3776000, 3840000, 3904000, 3968000, 4032000,\n\t4096000, 4160000, 4224000, 4288000, 4352000, 4416000, 4480000, 4544000\n};\n\n/* REG04[7:2] (VREG) in uV */\nstatic const int bq24190_cvc_vreg_values[] = {\n\t3504000, 3520000, 3536000, 3552000, 3568000, 3584000, 3600000, 3616000,\n\t3632000, 3648000, 3664000, 3680000, 3696000, 3712000, 3728000, 3744000,\n\t3760000, 3776000, 3792000, 3808000, 3824000, 3840000, 3856000, 3872000,\n\t3888000, 3904000, 3920000, 3936000, 3952000, 3968000, 3984000, 4000000,\n\t4016000, 4032000, 4048000, 4064000, 4080000, 4096000, 4112000, 4128000,\n\t4144000, 4160000, 4176000, 4192000, 4208000, 4224000, 4240000, 4256000,\n\t4272000, 4288000, 4304000, 4320000, 4336000, 4352000, 4368000, 4384000,\n\t4400000\n};\n\n/* REG06[1:0] (TREG) in tenths of degrees Celsius */\nstatic const int bq24190_ictrc_treg_values[] = {\n\t600, 800, 1000, 1200\n};\n\n/*\n * Return the index in 'tbl' of greatest value that is less than or equal to\n * 'val'.  The index range returned is 0 to 'tbl_size' - 1.  Assumes that\n * the values in 'tbl' are sorted from smallest to largest and 'tbl_size'\n * is less than 2^8.\n */\nstatic u8 bq24190_find_idx(const int tbl[], int tbl_size, int v)\n{\n\tint i;\n\n\tfor (i = 1; i < tbl_size; i++)\n\t\tif (v < tbl[i])\n\t\t\tbreak;\n\n\treturn i - 1;\n}\n\n/* Basic driver I/O routines */\n\nstatic int bq24190_read(struct bq24190_dev_info *bdi, u8 reg, u8 *data)\n{\n\tint ret;\n\n\tret = i2c_smbus_read_byte_data(bdi->client, reg);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t*data = ret;\n\treturn 0;\n}\n\nstatic int bq24190_write(struct bq24190_dev_info *bdi, u8 reg, u8 data)\n{\n\treturn i2c_smbus_write_byte_data(bdi->client, reg, data);\n}\n\nstatic int bq24190_read_mask(struct bq24190_dev_info *bdi, u8 reg,\n\t\tu8 mask, u8 shift, u8 *data)\n{\n\tu8 v;\n\tint ret;\n\n\tret = bq24190_read(bdi, reg, &v);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tv &= mask;\n\tv >>= shift;\n\t*data = v;\n\n\treturn 0;\n}\n\nstatic int bq24190_write_mask(struct bq24190_dev_info *bdi, u8 reg,\n\t\tu8 mask, u8 shift, u8 data)\n{\n\tu8 v;\n\tint ret;\n\n\tret = bq24190_read(bdi, reg, &v);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tv &= ~mask;\n\tv |= ((data << shift) & mask);\n\n\treturn bq24190_write(bdi, reg, v);\n}\n\nstatic int bq24190_get_field_val(struct bq24190_dev_info *bdi,\n\t\tu8 reg, u8 mask, u8 shift,\n\t\tconst int tbl[], int tbl_size,\n\t\tint *val)\n{\n\tu8 v;\n\tint ret;\n\n\tret = bq24190_read_mask(bdi, reg, mask, shift, &v);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tv = (v >= tbl_size) ? (tbl_size - 1) : v;\n\t*val = tbl[v];\n\n\treturn 0;\n}\n\nstatic int bq24190_set_field_val(struct bq24190_dev_info *bdi,\n\t\tu8 reg, u8 mask, u8 shift,\n\t\tconst int tbl[], int tbl_size,\n\t\tint val)\n{\n\tu8 idx;\n\n\tidx = bq24190_find_idx(tbl, tbl_size, val);\n\n\treturn bq24190_write_mask(bdi, reg, mask, shift, idx);\n}\n\n#ifdef CONFIG_SYSFS\n/*\n * There are a numerous options that are configurable on the bq24190\n * that go well beyond what the power_supply properties provide access to.\n * Provide sysfs access to them so they can be examined and possibly modified\n * on the fly.  They will be provided for the charger power_supply object only\n * and will be prefixed by 'f_' to make them easier to recognize.\n */\n\n#define BQ24190_SYSFS_FIELD(_name, r, f, m, store)\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\t.attr\t= __ATTR(f_##_name, m, bq24190_sysfs_show, store),\t\\\n\t.reg\t= BQ24190_REG_##r,\t\t\t\t\t\\\n\t.mask\t= BQ24190_REG_##r##_##f##_MASK,\t\t\t\t\\\n\t.shift\t= BQ24190_REG_##r##_##f##_SHIFT,\t\t\t\\\n}\n\n#define BQ24190_SYSFS_FIELD_RW(_name, r, f)\t\t\t\t\\\n\t\tBQ24190_SYSFS_FIELD(_name, r, f, S_IWUSR | S_IRUGO,\t\\\n\t\t\t\tbq24190_sysfs_store)\n\n#define BQ24190_SYSFS_FIELD_RO(_name, r, f)\t\t\t\t\\\n\t\tBQ24190_SYSFS_FIELD(_name, r, f, S_IRUGO, NULL)\n\nstatic ssize_t bq24190_sysfs_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf);\nstatic ssize_t bq24190_sysfs_store(struct device *dev,\n\t\tstruct device_attribute *attr, const char *buf, size_t count);\n\nstruct bq24190_sysfs_field_info {\n\tstruct device_attribute\tattr;\n\tu8\treg;\n\tu8\tmask;\n\tu8\tshift;\n};\n\n/* On i386 ptrace-abi.h defines SS that breaks the macro calls below. */\n#undef SS\n\nstatic struct bq24190_sysfs_field_info bq24190_sysfs_field_tbl[] = {\n\t\t\t/*\tsysfs name\treg\tfield in reg */\n\tBQ24190_SYSFS_FIELD_RW(en_hiz,\t\tISC,\tEN_HIZ),\n\tBQ24190_SYSFS_FIELD_RW(vindpm,\t\tISC,\tVINDPM),\n\tBQ24190_SYSFS_FIELD_RW(iinlim,\t\tISC,\tIINLIM),\n\tBQ24190_SYSFS_FIELD_RW(chg_config,\tPOC,\tCHG_CONFIG),\n\tBQ24190_SYSFS_FIELD_RW(sys_min,\t\tPOC,\tSYS_MIN),\n\tBQ24190_SYSFS_FIELD_RW(boost_lim,\tPOC,\tBOOST_LIM),\n\tBQ24190_SYSFS_FIELD_RW(ichg,\t\tCCC,\tICHG),\n\tBQ24190_SYSFS_FIELD_RW(force_20_pct,\tCCC,\tFORCE_20PCT),\n\tBQ24190_SYSFS_FIELD_RW(iprechg,\t\tPCTCC,\tIPRECHG),\n\tBQ24190_SYSFS_FIELD_RW(iterm,\t\tPCTCC,\tITERM),\n\tBQ24190_SYSFS_FIELD_RW(vreg,\t\tCVC,\tVREG),\n\tBQ24190_SYSFS_FIELD_RW(batlowv,\t\tCVC,\tBATLOWV),\n\tBQ24190_SYSFS_FIELD_RW(vrechg,\t\tCVC,\tVRECHG),\n\tBQ24190_SYSFS_FIELD_RW(en_term,\t\tCTTC,\tEN_TERM),\n\tBQ24190_SYSFS_FIELD_RW(term_stat,\tCTTC,\tTERM_STAT),\n\tBQ24190_SYSFS_FIELD_RO(watchdog,\tCTTC,\tWATCHDOG),\n\tBQ24190_SYSFS_FIELD_RW(en_timer,\tCTTC,\tEN_TIMER),\n\tBQ24190_SYSFS_FIELD_RW(chg_timer,\tCTTC,\tCHG_TIMER),\n\tBQ24190_SYSFS_FIELD_RW(jeta_iset,\tCTTC,\tJEITA_ISET),\n\tBQ24190_SYSFS_FIELD_RW(bat_comp,\tICTRC,\tBAT_COMP),\n\tBQ24190_SYSFS_FIELD_RW(vclamp,\t\tICTRC,\tVCLAMP),\n\tBQ24190_SYSFS_FIELD_RW(treg,\t\tICTRC,\tTREG),\n\tBQ24190_SYSFS_FIELD_RW(dpdm_en,\t\tMOC,\tDPDM_EN),\n\tBQ24190_SYSFS_FIELD_RW(tmr2x_en,\tMOC,\tTMR2X_EN),\n\tBQ24190_SYSFS_FIELD_RW(batfet_disable,\tMOC,\tBATFET_DISABLE),\n\tBQ24190_SYSFS_FIELD_RW(jeita_vset,\tMOC,\tJEITA_VSET),\n\tBQ24190_SYSFS_FIELD_RO(int_mask,\tMOC,\tINT_MASK),\n\tBQ24190_SYSFS_FIELD_RO(vbus_stat,\tSS,\tVBUS_STAT),\n\tBQ24190_SYSFS_FIELD_RO(chrg_stat,\tSS,\tCHRG_STAT),\n\tBQ24190_SYSFS_FIELD_RO(dpm_stat,\tSS,\tDPM_STAT),\n\tBQ24190_SYSFS_FIELD_RO(pg_stat,\t\tSS,\tPG_STAT),\n\tBQ24190_SYSFS_FIELD_RO(therm_stat,\tSS,\tTHERM_STAT),\n\tBQ24190_SYSFS_FIELD_RO(vsys_stat,\tSS,\tVSYS_STAT),\n\tBQ24190_SYSFS_FIELD_RO(watchdog_fault,\tF,\tWATCHDOG_FAULT),\n\tBQ24190_SYSFS_FIELD_RO(boost_fault,\tF,\tBOOST_FAULT),\n\tBQ24190_SYSFS_FIELD_RO(chrg_fault,\tF,\tCHRG_FAULT),\n\tBQ24190_SYSFS_FIELD_RO(bat_fault,\tF,\tBAT_FAULT),\n\tBQ24190_SYSFS_FIELD_RO(ntc_fault,\tF,\tNTC_FAULT),\n\tBQ24190_SYSFS_FIELD_RO(pn,\t\tVPRS,\tPN),\n\tBQ24190_SYSFS_FIELD_RO(ts_profile,\tVPRS,\tTS_PROFILE),\n\tBQ24190_SYSFS_FIELD_RO(dev_reg,\t\tVPRS,\tDEV_REG),\n};\n\nstatic struct attribute *\n\tbq24190_sysfs_attrs[ARRAY_SIZE(bq24190_sysfs_field_tbl) + 1];\n\nATTRIBUTE_GROUPS(bq24190_sysfs);\n\nstatic void bq24190_sysfs_init_attrs(void)\n{\n\tint i, limit = ARRAY_SIZE(bq24190_sysfs_field_tbl);\n\n\tfor (i = 0; i < limit; i++)\n\t\tbq24190_sysfs_attrs[i] = &bq24190_sysfs_field_tbl[i].attr.attr;\n\n\tbq24190_sysfs_attrs[limit] = NULL; /* Has additional entry for this */\n}\n\nstatic struct bq24190_sysfs_field_info *bq24190_sysfs_field_lookup(\n\t\tconst char *name)\n{\n\tint i, limit = ARRAY_SIZE(bq24190_sysfs_field_tbl);\n\n\tfor (i = 0; i < limit; i++)\n\t\tif (!strcmp(name, bq24190_sysfs_field_tbl[i].attr.attr.name))\n\t\t\tbreak;\n\n\tif (i >= limit)\n\t\treturn NULL;\n\n\treturn &bq24190_sysfs_field_tbl[i];\n}\n\nstatic ssize_t bq24190_sysfs_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct power_supply *psy = dev_get_drvdata(dev);\n\tstruct bq24190_dev_info *bdi = power_supply_get_drvdata(psy);\n\tstruct bq24190_sysfs_field_info *info;\n\tssize_t count;\n\tint ret;\n\tu8 v;\n\n\tinfo = bq24190_sysfs_field_lookup(attr->attr.name);\n\tif (!info)\n\t\treturn -EINVAL;\n\n\tret = pm_runtime_resume_and_get(bdi->dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = bq24190_read_mask(bdi, info->reg, info->mask, info->shift, &v);\n\tif (ret)\n\t\tcount = ret;\n\telse\n\t\tcount = sysfs_emit(buf, \"%hhx\\n\", v);\n\n\tpm_runtime_mark_last_busy(bdi->dev);\n\tpm_runtime_put_autosuspend(bdi->dev);\n\n\treturn count;\n}\n\nstatic ssize_t bq24190_sysfs_store(struct device *dev,\n\t\tstruct device_attribute *attr, const char *buf, size_t count)\n{\n\tstruct power_supply *psy = dev_get_drvdata(dev);\n\tstruct bq24190_dev_info *bdi = power_supply_get_drvdata(psy);\n\tstruct bq24190_sysfs_field_info *info;\n\tint ret;\n\tu8 v;\n\n\tinfo = bq24190_sysfs_field_lookup(attr->attr.name);\n\tif (!info)\n\t\treturn -EINVAL;\n\n\tret = kstrtou8(buf, 0, &v);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = pm_runtime_resume_and_get(bdi->dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = bq24190_write_mask(bdi, info->reg, info->mask, info->shift, v);\n\tif (ret)\n\t\tcount = ret;\n\n\tpm_runtime_mark_last_busy(bdi->dev);\n\tpm_runtime_put_autosuspend(bdi->dev);\n\n\treturn count;\n}\n#endif\n\nstatic int bq24190_set_otg_vbus(struct bq24190_dev_info *bdi, bool enable)\n{\n\tunion power_supply_propval val = { .intval = bdi->charge_type };\n\tint ret;\n\n\tret = pm_runtime_resume_and_get(bdi->dev);\n\tif (ret < 0) {\n\t\tdev_warn(bdi->dev, \"pm_runtime_get failed: %i\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tbdi->otg_vbus_enabled = enable;\n\tif (enable)\n\t\tret = bq24190_write_mask(bdi, BQ24190_REG_POC,\n\t\t\t\t\t BQ24190_REG_POC_CHG_CONFIG_MASK,\n\t\t\t\t\t BQ24190_REG_POC_CHG_CONFIG_SHIFT,\n\t\t\t\t\t BQ24190_REG_POC_CHG_CONFIG_OTG);\n\telse\n\t\tret = bq24190_charger_set_charge_type(bdi, &val);\n\n\tpm_runtime_mark_last_busy(bdi->dev);\n\tpm_runtime_put_autosuspend(bdi->dev);\n\n\treturn ret;\n}\n\n#ifdef CONFIG_REGULATOR\nstatic int bq24190_vbus_enable(struct regulator_dev *dev)\n{\n\treturn bq24190_set_otg_vbus(rdev_get_drvdata(dev), true);\n}\n\nstatic int bq24190_vbus_disable(struct regulator_dev *dev)\n{\n\treturn bq24190_set_otg_vbus(rdev_get_drvdata(dev), false);\n}\n\nstatic int bq24190_vbus_is_enabled(struct regulator_dev *dev)\n{\n\tstruct bq24190_dev_info *bdi = rdev_get_drvdata(dev);\n\tint ret;\n\tu8 val;\n\n\tret = pm_runtime_resume_and_get(bdi->dev);\n\tif (ret < 0) {\n\t\tdev_warn(bdi->dev, \"pm_runtime_get failed: %i\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = bq24190_read_mask(bdi, BQ24190_REG_POC,\n\t\t\t\tBQ24190_REG_POC_CHG_CONFIG_MASK,\n\t\t\t\tBQ24190_REG_POC_CHG_CONFIG_SHIFT, &val);\n\n\tpm_runtime_mark_last_busy(bdi->dev);\n\tpm_runtime_put_autosuspend(bdi->dev);\n\n\tif (ret)\n\t\treturn ret;\n\n\tbdi->otg_vbus_enabled = (val == BQ24190_REG_POC_CHG_CONFIG_OTG ||\n\t\t\t\t val == BQ24190_REG_POC_CHG_CONFIG_OTG_ALT);\n\treturn bdi->otg_vbus_enabled;\n}\n\nstatic const struct regulator_ops bq24190_vbus_ops = {\n\t.enable = bq24190_vbus_enable,\n\t.disable = bq24190_vbus_disable,\n\t.is_enabled = bq24190_vbus_is_enabled,\n};\n\nstatic const struct regulator_desc bq24190_vbus_desc = {\n\t.name = \"usb_otg_vbus\",\n\t.of_match = \"usb-otg-vbus\",\n\t.type = REGULATOR_VOLTAGE,\n\t.owner = THIS_MODULE,\n\t.ops = &bq24190_vbus_ops,\n\t.fixed_uV = 5000000,\n\t.n_voltages = 1,\n};\n\nstatic const struct regulator_init_data bq24190_vbus_init_data = {\n\t.constraints = {\n\t\t.valid_ops_mask = REGULATOR_CHANGE_STATUS,\n\t},\n};\n\nstatic int bq24190_register_vbus_regulator(struct bq24190_dev_info *bdi)\n{\n\tstruct bq24190_platform_data *pdata = bdi->dev->platform_data;\n\tstruct regulator_config cfg = { };\n\tstruct regulator_dev *reg;\n\tint ret = 0;\n\n\tcfg.dev = bdi->dev;\n\tif (pdata && pdata->regulator_init_data)\n\t\tcfg.init_data = pdata->regulator_init_data;\n\telse\n\t\tcfg.init_data = &bq24190_vbus_init_data;\n\tcfg.driver_data = bdi;\n\treg = devm_regulator_register(bdi->dev, &bq24190_vbus_desc, &cfg);\n\tif (IS_ERR(reg)) {\n\t\tret = PTR_ERR(reg);\n\t\tdev_err(bdi->dev, \"Can't register regulator: %d\\n\", ret);\n\t}\n\n\treturn ret;\n}\n#else\nstatic int bq24190_register_vbus_regulator(struct bq24190_dev_info *bdi)\n{\n\treturn 0;\n}\n#endif\n\nstatic int bq24190_set_config(struct bq24190_dev_info *bdi)\n{\n\tint ret;\n\tu8 v;\n\n\tret = bq24190_read(bdi, BQ24190_REG_CTTC, &v);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tbdi->watchdog = ((v & BQ24190_REG_CTTC_WATCHDOG_MASK) >>\n\t\t\t\t\tBQ24190_REG_CTTC_WATCHDOG_SHIFT);\n\n\t/*\n\t * According to the \"Host Mode and default Mode\" section of the\n\t * manual, a write to any register causes the bq24190 to switch\n\t * from default mode to host mode.  It will switch back to default\n\t * mode after a WDT timeout unless the WDT is turned off as well.\n\t * So, by simply turning off the WDT, we accomplish both with the\n\t * same write.\n\t */\n\tv &= ~BQ24190_REG_CTTC_WATCHDOG_MASK;\n\n\tret = bq24190_write(bdi, BQ24190_REG_CTTC, v);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (bdi->sys_min) {\n\t\tv = bdi->sys_min / 100 - 30; // manual section 9.5.1.2, table 9\n\t\tret = bq24190_write_mask(bdi, BQ24190_REG_POC,\n\t\t\t\t\t BQ24190_REG_POC_SYS_MIN_MASK,\n\t\t\t\t\t BQ24190_REG_POC_SYS_MIN_SHIFT,\n\t\t\t\t\t v);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tif (bdi->iprechg) {\n\t\tv = bdi->iprechg / 128 - 1; // manual section 9.5.1.4, table 11\n\t\tret = bq24190_write_mask(bdi, BQ24190_REG_PCTCC,\n\t\t\t\t\t BQ24190_REG_PCTCC_IPRECHG_MASK,\n\t\t\t\t\t BQ24190_REG_PCTCC_IPRECHG_SHIFT,\n\t\t\t\t\t v);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tif (bdi->iterm) {\n\t\tv = bdi->iterm / 128 - 1; // manual section 9.5.1.4, table 11\n\t\tret = bq24190_write_mask(bdi, BQ24190_REG_PCTCC,\n\t\t\t\t\t BQ24190_REG_PCTCC_ITERM_MASK,\n\t\t\t\t\t BQ24190_REG_PCTCC_ITERM_SHIFT,\n\t\t\t\t\t v);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tif (bdi->ichg) {\n\t\tret = bq24190_set_field_val(bdi, BQ24190_REG_CCC,\n\t\t\t\t\t    BQ24190_REG_CCC_ICHG_MASK,\n\t\t\t\t\t    BQ24190_REG_CCC_ICHG_SHIFT,\n\t\t\t\t\t    bq24190_ccc_ichg_values,\n\t\t\t\t\t    ARRAY_SIZE(bq24190_ccc_ichg_values),\n\t\t\t\t\t    bdi->ichg);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tif (bdi->vreg) {\n\t\tret = bq24190_set_field_val(bdi, BQ24190_REG_CVC,\n\t\t\t\t\t    BQ24190_REG_CVC_VREG_MASK,\n\t\t\t\t\t    BQ24190_REG_CVC_VREG_SHIFT,\n\t\t\t\t\t    bq24190_cvc_vreg_values,\n\t\t\t\t\t    ARRAY_SIZE(bq24190_cvc_vreg_values),\n\t\t\t\t\t    bdi->vreg);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int bq24190_register_reset(struct bq24190_dev_info *bdi)\n{\n\tint ret, limit = 100;\n\tu8 v;\n\n\t/*\n\t * This prop. can be passed on device instantiation from platform code:\n\t * struct property_entry pe[] =\n\t *   { PROPERTY_ENTRY_BOOL(\"disable-reset\"), ... };\n\t * struct i2c_board_info bi =\n\t *   { .type = \"bq24190\", .addr = 0x6b, .properties = pe, .irq = irq };\n\t * struct i2c_adapter ad = { ... };\n\t * i2c_add_adapter(&ad);\n\t * i2c_new_client_device(&ad, &bi);\n\t */\n\tif (device_property_read_bool(bdi->dev, \"disable-reset\"))\n\t\treturn 0;\n\n\t/* Reset the registers */\n\tret = bq24190_write_mask(bdi, BQ24190_REG_POC,\n\t\t\tBQ24190_REG_POC_RESET_MASK,\n\t\t\tBQ24190_REG_POC_RESET_SHIFT,\n\t\t\t0x1);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t/* Reset bit will be cleared by hardware so poll until it is */\n\tdo {\n\t\tret = bq24190_read_mask(bdi, BQ24190_REG_POC,\n\t\t\t\tBQ24190_REG_POC_RESET_MASK,\n\t\t\t\tBQ24190_REG_POC_RESET_SHIFT,\n\t\t\t\t&v);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tif (v == 0)\n\t\t\treturn 0;\n\n\t\tusleep_range(100, 200);\n\t} while (--limit);\n\n\treturn -EIO;\n}\n\n/* Charger power supply property routines */\n\nstatic int bq24190_charger_get_charge_type(struct bq24190_dev_info *bdi,\n\t\tunion power_supply_propval *val)\n{\n\tu8 v;\n\tint type, ret;\n\n\tret = bq24190_read_mask(bdi, BQ24190_REG_POC,\n\t\t\tBQ24190_REG_POC_CHG_CONFIG_MASK,\n\t\t\tBQ24190_REG_POC_CHG_CONFIG_SHIFT,\n\t\t\t&v);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t/* If POC[CHG_CONFIG] (REG01[5:4]) == 0, charge is disabled */\n\tif (!v) {\n\t\ttype = POWER_SUPPLY_CHARGE_TYPE_NONE;\n\t} else {\n\t\tret = bq24190_read_mask(bdi, BQ24190_REG_CCC,\n\t\t\t\tBQ24190_REG_CCC_FORCE_20PCT_MASK,\n\t\t\t\tBQ24190_REG_CCC_FORCE_20PCT_SHIFT,\n\t\t\t\t&v);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\ttype = (v) ? POWER_SUPPLY_CHARGE_TYPE_TRICKLE :\n\t\t\t     POWER_SUPPLY_CHARGE_TYPE_FAST;\n\t}\n\n\tval->intval = type;\n\n\treturn 0;\n}\n\nstatic int bq24190_charger_set_charge_type(struct bq24190_dev_info *bdi,\n\t\tconst union power_supply_propval *val)\n{\n\tu8 chg_config, force_20pct, en_term;\n\tint ret;\n\n\t/*\n\t * According to the \"Termination when REG02[0] = 1\" section of\n\t * the bq24190 manual, the trickle charge could be less than the\n\t * termination current so it recommends turning off the termination\n\t * function.\n\t *\n\t * Note: AFAICT from the datasheet, the user will have to manually\n\t * turn off the charging when in 20% mode.  If its not turned off,\n\t * there could be battery damage.  So, use this mode at your own risk.\n\t */\n\tswitch (val->intval) {\n\tcase POWER_SUPPLY_CHARGE_TYPE_NONE:\n\t\tchg_config = 0x0;\n\t\tbreak;\n\tcase POWER_SUPPLY_CHARGE_TYPE_TRICKLE:\n\t\tchg_config = 0x1;\n\t\tforce_20pct = 0x1;\n\t\ten_term = 0x0;\n\t\tbreak;\n\tcase POWER_SUPPLY_CHARGE_TYPE_FAST:\n\t\tchg_config = 0x1;\n\t\tforce_20pct = 0x0;\n\t\ten_term = 0x1;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tbdi->charge_type = val->intval;\n\t/*\n\t * If the 5V Vbus boost regulator is enabled delay setting\n\t * the charge-type until its gets disabled.\n\t */\n\tif (bdi->otg_vbus_enabled)\n\t\treturn 0;\n\n\tif (chg_config) { /* Enabling the charger */\n\t\tret = bq24190_write_mask(bdi, BQ24190_REG_CCC,\n\t\t\t\tBQ24190_REG_CCC_FORCE_20PCT_MASK,\n\t\t\t\tBQ24190_REG_CCC_FORCE_20PCT_SHIFT,\n\t\t\t\tforce_20pct);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tret = bq24190_write_mask(bdi, BQ24190_REG_CTTC,\n\t\t\t\tBQ24190_REG_CTTC_EN_TERM_MASK,\n\t\t\t\tBQ24190_REG_CTTC_EN_TERM_SHIFT,\n\t\t\t\ten_term);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn bq24190_write_mask(bdi, BQ24190_REG_POC,\n\t\t\tBQ24190_REG_POC_CHG_CONFIG_MASK,\n\t\t\tBQ24190_REG_POC_CHG_CONFIG_SHIFT, chg_config);\n}\n\nstatic int bq24190_charger_get_health(struct bq24190_dev_info *bdi,\n\t\tunion power_supply_propval *val)\n{\n\tu8 v;\n\tint health;\n\n\tmutex_lock(&bdi->f_reg_lock);\n\tv = bdi->f_reg;\n\tmutex_unlock(&bdi->f_reg_lock);\n\n\tif (v & BQ24190_REG_F_NTC_FAULT_MASK) {\n\t\tswitch (v >> BQ24190_REG_F_NTC_FAULT_SHIFT & 0x7) {\n\t\tcase 0x1: /* TS1  Cold */\n\t\tcase 0x3: /* TS2  Cold */\n\t\tcase 0x5: /* Both Cold */\n\t\t\thealth = POWER_SUPPLY_HEALTH_COLD;\n\t\t\tbreak;\n\t\tcase 0x2: /* TS1  Hot */\n\t\tcase 0x4: /* TS2  Hot */\n\t\tcase 0x6: /* Both Hot */\n\t\t\thealth = POWER_SUPPLY_HEALTH_OVERHEAT;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\thealth = POWER_SUPPLY_HEALTH_UNKNOWN;\n\t\t}\n\t} else if (v & BQ24190_REG_F_BAT_FAULT_MASK) {\n\t\thealth = POWER_SUPPLY_HEALTH_OVERVOLTAGE;\n\t} else if (v & BQ24190_REG_F_CHRG_FAULT_MASK) {\n\t\tswitch (v >> BQ24190_REG_F_CHRG_FAULT_SHIFT & 0x3) {\n\t\tcase 0x1: /* Input Fault (VBUS OVP or VBAT<VBUS<3.8V) */\n\t\t\t/*\n\t\t\t * This could be over-voltage or under-voltage\n\t\t\t * and there's no way to tell which.  Instead\n\t\t\t * of looking foolish and returning 'OVERVOLTAGE'\n\t\t\t * when its really under-voltage, just return\n\t\t\t * 'UNSPEC_FAILURE'.\n\t\t\t */\n\t\t\thealth = POWER_SUPPLY_HEALTH_UNSPEC_FAILURE;\n\t\t\tbreak;\n\t\tcase 0x2: /* Thermal Shutdown */\n\t\t\thealth = POWER_SUPPLY_HEALTH_OVERHEAT;\n\t\t\tbreak;\n\t\tcase 0x3: /* Charge Safety Timer Expiration */\n\t\t\thealth = POWER_SUPPLY_HEALTH_SAFETY_TIMER_EXPIRE;\n\t\t\tbreak;\n\t\tdefault:  /* prevent compiler warning */\n\t\t\thealth = -1;\n\t\t}\n\t} else if (v & BQ24190_REG_F_BOOST_FAULT_MASK) {\n\t\t/*\n\t\t * This could be over-current or over-voltage but there's\n\t\t * no way to tell which.  Return 'OVERVOLTAGE' since there\n\t\t * isn't an 'OVERCURRENT' value defined that we can return\n\t\t * even if it was over-current.\n\t\t */\n\t\thealth = POWER_SUPPLY_HEALTH_OVERVOLTAGE;\n\t} else {\n\t\thealth = POWER_SUPPLY_HEALTH_GOOD;\n\t}\n\n\tval->intval = health;\n\n\treturn 0;\n}\n\nstatic int bq24190_charger_get_online(struct bq24190_dev_info *bdi,\n\t\tunion power_supply_propval *val)\n{\n\tu8 pg_stat, batfet_disable;\n\tint ret;\n\n\tret = bq24190_read_mask(bdi, BQ24190_REG_SS,\n\t\t\tBQ24190_REG_SS_PG_STAT_MASK,\n\t\t\tBQ24190_REG_SS_PG_STAT_SHIFT, &pg_stat);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = bq24190_read_mask(bdi, BQ24190_REG_MOC,\n\t\t\tBQ24190_REG_MOC_BATFET_DISABLE_MASK,\n\t\t\tBQ24190_REG_MOC_BATFET_DISABLE_SHIFT, &batfet_disable);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tval->intval = pg_stat && !batfet_disable;\n\n\treturn 0;\n}\n\nstatic int bq24190_battery_set_online(struct bq24190_dev_info *bdi,\n\t\t\t\t      const union power_supply_propval *val);\nstatic int bq24190_battery_get_status(struct bq24190_dev_info *bdi,\n\t\t\t\t      union power_supply_propval *val);\nstatic int bq24190_battery_get_temp_alert_max(struct bq24190_dev_info *bdi,\n\t\t\t\t\t      union power_supply_propval *val);\nstatic int bq24190_battery_set_temp_alert_max(struct bq24190_dev_info *bdi,\n\t\t\t\t\t      const union power_supply_propval *val);\n\nstatic int bq24190_charger_set_online(struct bq24190_dev_info *bdi,\n\t\t\t\t      const union power_supply_propval *val)\n{\n\treturn bq24190_battery_set_online(bdi, val);\n}\n\nstatic int bq24190_charger_get_status(struct bq24190_dev_info *bdi,\n\t\t\t\t      union power_supply_propval *val)\n{\n\treturn bq24190_battery_get_status(bdi, val);\n}\n\nstatic int bq24190_charger_get_temp_alert_max(struct bq24190_dev_info *bdi,\n\t\t\t\t\t      union power_supply_propval *val)\n{\n\treturn bq24190_battery_get_temp_alert_max(bdi, val);\n}\n\nstatic int bq24190_charger_set_temp_alert_max(struct bq24190_dev_info *bdi,\n\t\t\t\t\t      const union power_supply_propval *val)\n{\n\treturn bq24190_battery_set_temp_alert_max(bdi, val);\n}\n\nstatic int bq24190_charger_get_precharge(struct bq24190_dev_info *bdi,\n\t\tunion power_supply_propval *val)\n{\n\tu8 v;\n\tint ret;\n\n\tret = bq24190_read_mask(bdi, BQ24190_REG_PCTCC,\n\t\t\tBQ24190_REG_PCTCC_IPRECHG_MASK,\n\t\t\tBQ24190_REG_PCTCC_IPRECHG_SHIFT, &v);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tval->intval = ++v * 128 * 1000;\n\treturn 0;\n}\n\nstatic int bq24190_charger_get_charge_term(struct bq24190_dev_info *bdi,\n\t\tunion power_supply_propval *val)\n{\n\tu8 v;\n\tint ret;\n\n\tret = bq24190_read_mask(bdi, BQ24190_REG_PCTCC,\n\t\t\tBQ24190_REG_PCTCC_ITERM_MASK,\n\t\t\tBQ24190_REG_PCTCC_ITERM_SHIFT, &v);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tval->intval = ++v * 128 * 1000;\n\treturn 0;\n}\n\nstatic int bq24190_charger_get_current(struct bq24190_dev_info *bdi,\n\t\tunion power_supply_propval *val)\n{\n\tu8 v;\n\tint curr, ret;\n\n\tret = bq24190_get_field_val(bdi, BQ24190_REG_CCC,\n\t\t\tBQ24190_REG_CCC_ICHG_MASK, BQ24190_REG_CCC_ICHG_SHIFT,\n\t\t\tbq24190_ccc_ichg_values,\n\t\t\tARRAY_SIZE(bq24190_ccc_ichg_values), &curr);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = bq24190_read_mask(bdi, BQ24190_REG_CCC,\n\t\t\tBQ24190_REG_CCC_FORCE_20PCT_MASK,\n\t\t\tBQ24190_REG_CCC_FORCE_20PCT_SHIFT, &v);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t/* If FORCE_20PCT is enabled, then current is 20% of ICHG value */\n\tif (v)\n\t\tcurr /= 5;\n\n\tval->intval = curr;\n\treturn 0;\n}\n\nstatic int bq24190_charger_set_current(struct bq24190_dev_info *bdi,\n\t\tconst union power_supply_propval *val)\n{\n\tu8 v;\n\tint ret, curr = val->intval;\n\n\tret = bq24190_read_mask(bdi, BQ24190_REG_CCC,\n\t\t\tBQ24190_REG_CCC_FORCE_20PCT_MASK,\n\t\t\tBQ24190_REG_CCC_FORCE_20PCT_SHIFT, &v);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t/* If FORCE_20PCT is enabled, have to multiply value passed in by 5 */\n\tif (v)\n\t\tcurr *= 5;\n\n\tif (curr > bdi->ichg_max)\n\t\treturn -EINVAL;\n\n\tret = bq24190_set_field_val(bdi, BQ24190_REG_CCC,\n\t\t\tBQ24190_REG_CCC_ICHG_MASK, BQ24190_REG_CCC_ICHG_SHIFT,\n\t\t\tbq24190_ccc_ichg_values,\n\t\t\tARRAY_SIZE(bq24190_ccc_ichg_values), curr);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tbdi->ichg = curr;\n\n\treturn 0;\n}\n\nstatic int bq24190_charger_get_voltage(struct bq24190_dev_info *bdi,\n\t\tunion power_supply_propval *val)\n{\n\tint voltage, ret;\n\n\tret = bq24190_get_field_val(bdi, BQ24190_REG_CVC,\n\t\t\tBQ24190_REG_CVC_VREG_MASK, BQ24190_REG_CVC_VREG_SHIFT,\n\t\t\tbq24190_cvc_vreg_values,\n\t\t\tARRAY_SIZE(bq24190_cvc_vreg_values), &voltage);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tval->intval = voltage;\n\treturn 0;\n}\n\nstatic int bq24190_charger_set_voltage(struct bq24190_dev_info *bdi,\n\t\tconst union power_supply_propval *val)\n{\n\tint ret;\n\n\tif (val->intval > bdi->vreg_max)\n\t\treturn -EINVAL;\n\n\tret = bq24190_set_field_val(bdi, BQ24190_REG_CVC,\n\t\t\tBQ24190_REG_CVC_VREG_MASK, BQ24190_REG_CVC_VREG_SHIFT,\n\t\t\tbq24190_cvc_vreg_values,\n\t\t\tARRAY_SIZE(bq24190_cvc_vreg_values), val->intval);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tbdi->vreg = val->intval;\n\n\treturn 0;\n}\n\nstatic int bq24190_charger_get_iinlimit(struct bq24190_dev_info *bdi,\n\t\tunion power_supply_propval *val)\n{\n\tint iinlimit, ret;\n\n\tret = bq24190_get_field_val(bdi, BQ24190_REG_ISC,\n\t\t\tBQ24190_REG_ISC_IINLIM_MASK,\n\t\t\tBQ24190_REG_ISC_IINLIM_SHIFT,\n\t\t\tbq24190_isc_iinlim_values,\n\t\t\tARRAY_SIZE(bq24190_isc_iinlim_values), &iinlimit);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tval->intval = iinlimit;\n\treturn 0;\n}\n\nstatic int bq24190_charger_set_iinlimit(struct bq24190_dev_info *bdi,\n\t\tconst union power_supply_propval *val)\n{\n\treturn bq24190_set_field_val(bdi, BQ24190_REG_ISC,\n\t\t\tBQ24190_REG_ISC_IINLIM_MASK,\n\t\t\tBQ24190_REG_ISC_IINLIM_SHIFT,\n\t\t\tbq24190_isc_iinlim_values,\n\t\t\tARRAY_SIZE(bq24190_isc_iinlim_values), val->intval);\n}\n\nstatic int bq24190_charger_get_property(struct power_supply *psy,\n\t\tenum power_supply_property psp, union power_supply_propval *val)\n{\n\tstruct bq24190_dev_info *bdi = power_supply_get_drvdata(psy);\n\tint ret;\n\n\tdev_dbg(bdi->dev, \"prop: %d\\n\", psp);\n\n\tret = pm_runtime_resume_and_get(bdi->dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tswitch (psp) {\n\tcase POWER_SUPPLY_PROP_CHARGE_TYPE:\n\t\tret = bq24190_charger_get_charge_type(bdi, val);\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_HEALTH:\n\t\tret = bq24190_charger_get_health(bdi, val);\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_ONLINE:\n\t\tret = bq24190_charger_get_online(bdi, val);\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_STATUS:\n\t\tret = bq24190_charger_get_status(bdi, val);\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_TEMP_ALERT_MAX:\n\t\tret =  bq24190_charger_get_temp_alert_max(bdi, val);\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_PRECHARGE_CURRENT:\n\t\tret = bq24190_charger_get_precharge(bdi, val);\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_CHARGE_TERM_CURRENT:\n\t\tret = bq24190_charger_get_charge_term(bdi, val);\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT:\n\t\tret = bq24190_charger_get_current(bdi, val);\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT_MAX:\n\t\tval->intval = bdi->ichg_max;\n\t\tret = 0;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE:\n\t\tret = bq24190_charger_get_voltage(bdi, val);\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE_MAX:\n\t\tval->intval = bdi->vreg_max;\n\t\tret = 0;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_INPUT_CURRENT_LIMIT:\n\t\tret = bq24190_charger_get_iinlimit(bdi, val);\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_SCOPE:\n\t\tval->intval = POWER_SUPPLY_SCOPE_SYSTEM;\n\t\tret = 0;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_MODEL_NAME:\n\t\tval->strval = bdi->model_name;\n\t\tret = 0;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_MANUFACTURER:\n\t\tval->strval = BQ24190_MANUFACTURER;\n\t\tret = 0;\n\t\tbreak;\n\tdefault:\n\t\tret = -ENODATA;\n\t}\n\n\tpm_runtime_mark_last_busy(bdi->dev);\n\tpm_runtime_put_autosuspend(bdi->dev);\n\n\treturn ret;\n}\n\nstatic int bq24190_charger_set_property(struct power_supply *psy,\n\t\tenum power_supply_property psp,\n\t\tconst union power_supply_propval *val)\n{\n\tstruct bq24190_dev_info *bdi = power_supply_get_drvdata(psy);\n\tint ret;\n\n\tdev_dbg(bdi->dev, \"prop: %d\\n\", psp);\n\n\tret = pm_runtime_resume_and_get(bdi->dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tswitch (psp) {\n\tcase POWER_SUPPLY_PROP_ONLINE:\n\t\tret = bq24190_charger_set_online(bdi, val);\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_TEMP_ALERT_MAX:\n\t\tret = bq24190_charger_set_temp_alert_max(bdi, val);\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_CHARGE_TYPE:\n\t\tret = bq24190_charger_set_charge_type(bdi, val);\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT:\n\t\tret = bq24190_charger_set_current(bdi, val);\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE:\n\t\tret = bq24190_charger_set_voltage(bdi, val);\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_INPUT_CURRENT_LIMIT:\n\t\tret = bq24190_charger_set_iinlimit(bdi, val);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\n\tpm_runtime_mark_last_busy(bdi->dev);\n\tpm_runtime_put_autosuspend(bdi->dev);\n\n\treturn ret;\n}\n\nstatic int bq24190_charger_property_is_writeable(struct power_supply *psy,\n\t\tenum power_supply_property psp)\n{\n\tswitch (psp) {\n\tcase POWER_SUPPLY_PROP_ONLINE:\n\tcase POWER_SUPPLY_PROP_TEMP_ALERT_MAX:\n\tcase POWER_SUPPLY_PROP_CHARGE_TYPE:\n\tcase POWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT:\n\tcase POWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE:\n\tcase POWER_SUPPLY_PROP_INPUT_CURRENT_LIMIT:\n\t\treturn 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic void bq24190_input_current_limit_work(struct work_struct *work)\n{\n\tstruct bq24190_dev_info *bdi =\n\t\tcontainer_of(work, struct bq24190_dev_info,\n\t\t\t     input_current_limit_work.work);\n\tunion power_supply_propval val;\n\tint ret;\n\n\tret = power_supply_get_property_from_supplier(bdi->charger,\n\t\t\t\t\t\t      POWER_SUPPLY_PROP_CURRENT_MAX,\n\t\t\t\t\t\t      &val);\n\tif (ret)\n\t\treturn;\n\n\tbq24190_charger_set_property(bdi->charger,\n\t\t\t\t     POWER_SUPPLY_PROP_INPUT_CURRENT_LIMIT,\n\t\t\t\t     &val);\n}\n\n/* Sync the input-current-limit with our parent supply (if we have one) */\nstatic void bq24190_charger_external_power_changed(struct power_supply *psy)\n{\n\tstruct bq24190_dev_info *bdi = power_supply_get_drvdata(psy);\n\n\t/*\n\t * The Power-Good detection may take up to 220ms, sometimes\n\t * the external charger detection is quicker, and the bq24190 will\n\t * reset to iinlim based on its own charger detection (which is not\n\t * hooked up when using external charger detection) resulting in a\n\t * too low default 500mA iinlim. Delay setting the input-current-limit\n\t * for 300ms to avoid this.\n\t */\n\tqueue_delayed_work(system_wq, &bdi->input_current_limit_work,\n\t\t\t   msecs_to_jiffies(300));\n}\n\nstatic enum power_supply_property bq24190_charger_properties[] = {\n\tPOWER_SUPPLY_PROP_CHARGE_TYPE,\n\tPOWER_SUPPLY_PROP_HEALTH,\n\tPOWER_SUPPLY_PROP_ONLINE,\n\tPOWER_SUPPLY_PROP_STATUS,\n\tPOWER_SUPPLY_PROP_TEMP_ALERT_MAX,\n\tPOWER_SUPPLY_PROP_PRECHARGE_CURRENT,\n\tPOWER_SUPPLY_PROP_CHARGE_TERM_CURRENT,\n\tPOWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT,\n\tPOWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT_MAX,\n\tPOWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE,\n\tPOWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE_MAX,\n\tPOWER_SUPPLY_PROP_INPUT_CURRENT_LIMIT,\n\tPOWER_SUPPLY_PROP_SCOPE,\n\tPOWER_SUPPLY_PROP_MODEL_NAME,\n\tPOWER_SUPPLY_PROP_MANUFACTURER,\n};\n\nstatic char *bq24190_charger_supplied_to[] = {\n\t\"main-battery\",\n};\n\nstatic const struct power_supply_desc bq24190_charger_desc = {\n\t.name\t\t\t= \"bq24190-charger\",\n\t.type\t\t\t= POWER_SUPPLY_TYPE_USB,\n\t.properties\t\t= bq24190_charger_properties,\n\t.num_properties\t\t= ARRAY_SIZE(bq24190_charger_properties),\n\t.get_property\t\t= bq24190_charger_get_property,\n\t.set_property\t\t= bq24190_charger_set_property,\n\t.property_is_writeable\t= bq24190_charger_property_is_writeable,\n\t.external_power_changed\t= bq24190_charger_external_power_changed,\n};\n\n/* Battery power supply property routines */\n\nstatic int bq24190_battery_get_status(struct bq24190_dev_info *bdi,\n\t\tunion power_supply_propval *val)\n{\n\tu8 ss_reg, chrg_fault;\n\tint status, ret;\n\n\tmutex_lock(&bdi->f_reg_lock);\n\tchrg_fault = bdi->f_reg;\n\tmutex_unlock(&bdi->f_reg_lock);\n\n\tchrg_fault &= BQ24190_REG_F_CHRG_FAULT_MASK;\n\tchrg_fault >>= BQ24190_REG_F_CHRG_FAULT_SHIFT;\n\n\tret = bq24190_read(bdi, BQ24190_REG_SS, &ss_reg);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t/*\n\t * The battery must be discharging when any of these are true:\n\t * - there is no good power source;\n\t * - there is a charge fault.\n\t * Could also be discharging when in \"supplement mode\" but\n\t * there is no way to tell when its in that mode.\n\t */\n\tif (!(ss_reg & BQ24190_REG_SS_PG_STAT_MASK) || chrg_fault) {\n\t\tstatus = POWER_SUPPLY_STATUS_DISCHARGING;\n\t} else {\n\t\tss_reg &= BQ24190_REG_SS_CHRG_STAT_MASK;\n\t\tss_reg >>= BQ24190_REG_SS_CHRG_STAT_SHIFT;\n\n\t\tswitch (ss_reg) {\n\t\tcase 0x0: /* Not Charging */\n\t\t\tstatus = POWER_SUPPLY_STATUS_NOT_CHARGING;\n\t\t\tbreak;\n\t\tcase 0x1: /* Pre-charge */\n\t\tcase 0x2: /* Fast Charging */\n\t\t\tstatus = POWER_SUPPLY_STATUS_CHARGING;\n\t\t\tbreak;\n\t\tcase 0x3: /* Charge Termination Done */\n\t\t\tstatus = POWER_SUPPLY_STATUS_FULL;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = -EIO;\n\t\t}\n\t}\n\n\tif (!ret)\n\t\tval->intval = status;\n\n\treturn ret;\n}\n\nstatic int bq24190_battery_get_health(struct bq24190_dev_info *bdi,\n\t\tunion power_supply_propval *val)\n{\n\tu8 v;\n\tint health;\n\n\tmutex_lock(&bdi->f_reg_lock);\n\tv = bdi->f_reg;\n\tmutex_unlock(&bdi->f_reg_lock);\n\n\tif (v & BQ24190_REG_F_BAT_FAULT_MASK) {\n\t\thealth = POWER_SUPPLY_HEALTH_OVERVOLTAGE;\n\t} else {\n\t\tv &= BQ24190_REG_F_NTC_FAULT_MASK;\n\t\tv >>= BQ24190_REG_F_NTC_FAULT_SHIFT;\n\n\t\tswitch (v) {\n\t\tcase 0x0: /* Normal */\n\t\t\thealth = POWER_SUPPLY_HEALTH_GOOD;\n\t\t\tbreak;\n\t\tcase 0x1: /* TS1 Cold */\n\t\tcase 0x3: /* TS2 Cold */\n\t\tcase 0x5: /* Both Cold */\n\t\t\thealth = POWER_SUPPLY_HEALTH_COLD;\n\t\t\tbreak;\n\t\tcase 0x2: /* TS1 Hot */\n\t\tcase 0x4: /* TS2 Hot */\n\t\tcase 0x6: /* Both Hot */\n\t\t\thealth = POWER_SUPPLY_HEALTH_OVERHEAT;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\thealth = POWER_SUPPLY_HEALTH_UNKNOWN;\n\t\t}\n\t}\n\n\tval->intval = health;\n\treturn 0;\n}\n\nstatic int bq24190_battery_get_online(struct bq24190_dev_info *bdi,\n\t\tunion power_supply_propval *val)\n{\n\tu8 batfet_disable;\n\tint ret;\n\n\tret = bq24190_read_mask(bdi, BQ24190_REG_MOC,\n\t\t\tBQ24190_REG_MOC_BATFET_DISABLE_MASK,\n\t\t\tBQ24190_REG_MOC_BATFET_DISABLE_SHIFT, &batfet_disable);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tval->intval = !batfet_disable;\n\treturn 0;\n}\n\nstatic int bq24190_battery_set_online(struct bq24190_dev_info *bdi,\n\t\tconst union power_supply_propval *val)\n{\n\treturn bq24190_write_mask(bdi, BQ24190_REG_MOC,\n\t\t\tBQ24190_REG_MOC_BATFET_DISABLE_MASK,\n\t\t\tBQ24190_REG_MOC_BATFET_DISABLE_SHIFT, !val->intval);\n}\n\nstatic int bq24190_battery_get_temp_alert_max(struct bq24190_dev_info *bdi,\n\t\tunion power_supply_propval *val)\n{\n\tint temp, ret;\n\n\tret = bq24190_get_field_val(bdi, BQ24190_REG_ICTRC,\n\t\t\tBQ24190_REG_ICTRC_TREG_MASK,\n\t\t\tBQ24190_REG_ICTRC_TREG_SHIFT,\n\t\t\tbq24190_ictrc_treg_values,\n\t\t\tARRAY_SIZE(bq24190_ictrc_treg_values), &temp);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tval->intval = temp;\n\treturn 0;\n}\n\nstatic int bq24190_battery_set_temp_alert_max(struct bq24190_dev_info *bdi,\n\t\tconst union power_supply_propval *val)\n{\n\treturn bq24190_set_field_val(bdi, BQ24190_REG_ICTRC,\n\t\t\tBQ24190_REG_ICTRC_TREG_MASK,\n\t\t\tBQ24190_REG_ICTRC_TREG_SHIFT,\n\t\t\tbq24190_ictrc_treg_values,\n\t\t\tARRAY_SIZE(bq24190_ictrc_treg_values), val->intval);\n}\n\nstatic int bq24190_battery_get_property(struct power_supply *psy,\n\t\tenum power_supply_property psp, union power_supply_propval *val)\n{\n\tstruct bq24190_dev_info *bdi = power_supply_get_drvdata(psy);\n\tint ret;\n\n\tdev_warn(bdi->dev, \"warning: /sys/class/power_supply/bq24190-battery is deprecated\\n\");\n\tdev_dbg(bdi->dev, \"prop: %d\\n\", psp);\n\n\tret = pm_runtime_resume_and_get(bdi->dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tswitch (psp) {\n\tcase POWER_SUPPLY_PROP_STATUS:\n\t\tret = bq24190_battery_get_status(bdi, val);\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_HEALTH:\n\t\tret = bq24190_battery_get_health(bdi, val);\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_ONLINE:\n\t\tret = bq24190_battery_get_online(bdi, val);\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_TECHNOLOGY:\n\t\t/* Could be Li-on or Li-polymer but no way to tell which */\n\t\tval->intval = POWER_SUPPLY_TECHNOLOGY_UNKNOWN;\n\t\tret = 0;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_TEMP_ALERT_MAX:\n\t\tret = bq24190_battery_get_temp_alert_max(bdi, val);\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_SCOPE:\n\t\tval->intval = POWER_SUPPLY_SCOPE_SYSTEM;\n\t\tret = 0;\n\t\tbreak;\n\tdefault:\n\t\tret = -ENODATA;\n\t}\n\n\tpm_runtime_mark_last_busy(bdi->dev);\n\tpm_runtime_put_autosuspend(bdi->dev);\n\n\treturn ret;\n}\n\nstatic int bq24190_battery_set_property(struct power_supply *psy,\n\t\tenum power_supply_property psp,\n\t\tconst union power_supply_propval *val)\n{\n\tstruct bq24190_dev_info *bdi = power_supply_get_drvdata(psy);\n\tint ret;\n\n\tdev_warn(bdi->dev, \"warning: /sys/class/power_supply/bq24190-battery is deprecated\\n\");\n\tdev_dbg(bdi->dev, \"prop: %d\\n\", psp);\n\n\tret = pm_runtime_resume_and_get(bdi->dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tswitch (psp) {\n\tcase POWER_SUPPLY_PROP_ONLINE:\n\t\tret = bq24190_battery_set_online(bdi, val);\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_TEMP_ALERT_MAX:\n\t\tret = bq24190_battery_set_temp_alert_max(bdi, val);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\n\tpm_runtime_mark_last_busy(bdi->dev);\n\tpm_runtime_put_autosuspend(bdi->dev);\n\n\treturn ret;\n}\n\nstatic int bq24190_battery_property_is_writeable(struct power_supply *psy,\n\t\tenum power_supply_property psp)\n{\n\tint ret;\n\n\tswitch (psp) {\n\tcase POWER_SUPPLY_PROP_ONLINE:\n\tcase POWER_SUPPLY_PROP_TEMP_ALERT_MAX:\n\t\tret = 1;\n\t\tbreak;\n\tdefault:\n\t\tret = 0;\n\t}\n\n\treturn ret;\n}\n\nstatic enum power_supply_property bq24190_battery_properties[] = {\n\tPOWER_SUPPLY_PROP_STATUS,\n\tPOWER_SUPPLY_PROP_HEALTH,\n\tPOWER_SUPPLY_PROP_ONLINE,\n\tPOWER_SUPPLY_PROP_TECHNOLOGY,\n\tPOWER_SUPPLY_PROP_TEMP_ALERT_MAX,\n\tPOWER_SUPPLY_PROP_SCOPE,\n};\n\nstatic const struct power_supply_desc bq24190_battery_desc = {\n\t.name\t\t\t= \"bq24190-battery\",\n\t.type\t\t\t= POWER_SUPPLY_TYPE_BATTERY,\n\t.properties\t\t= bq24190_battery_properties,\n\t.num_properties\t\t= ARRAY_SIZE(bq24190_battery_properties),\n\t.get_property\t\t= bq24190_battery_get_property,\n\t.set_property\t\t= bq24190_battery_set_property,\n\t.property_is_writeable\t= bq24190_battery_property_is_writeable,\n};\n\nstatic int bq24190_configure_usb_otg(struct bq24190_dev_info *bdi, u8 ss_reg)\n{\n\tbool otg_enabled;\n\tint ret;\n\n\totg_enabled = !!(ss_reg & BQ24190_REG_SS_VBUS_STAT_MASK);\n\tret = extcon_set_state_sync(bdi->edev, EXTCON_USB, otg_enabled);\n\tif (ret < 0)\n\t\tdev_err(bdi->dev, \"Can't set extcon state to %d: %d\\n\",\n\t\t\totg_enabled, ret);\n\n\treturn ret;\n}\n\nstatic void bq24190_check_status(struct bq24190_dev_info *bdi)\n{\n\tconst u8 battery_mask_ss = BQ24190_REG_SS_CHRG_STAT_MASK;\n\tconst u8 battery_mask_f = BQ24190_REG_F_BAT_FAULT_MASK\n\t\t\t\t| BQ24190_REG_F_NTC_FAULT_MASK;\n\tbool alert_charger = false, alert_battery = false;\n\tu8 ss_reg = 0, f_reg = 0;\n\tint i, ret;\n\n\tret = bq24190_read(bdi, BQ24190_REG_SS, &ss_reg);\n\tif (ret < 0) {\n\t\tdev_err(bdi->dev, \"Can't read SS reg: %d\\n\", ret);\n\t\treturn;\n\t}\n\n\ti = 0;\n\tdo {\n\t\tret = bq24190_read(bdi, BQ24190_REG_F, &f_reg);\n\t\tif (ret < 0) {\n\t\t\tdev_err(bdi->dev, \"Can't read F reg: %d\\n\", ret);\n\t\t\treturn;\n\t\t}\n\t} while (f_reg && ++i < 2);\n\n\t/* ignore over/under voltage fault after disconnect */\n\tif (f_reg == (1 << BQ24190_REG_F_CHRG_FAULT_SHIFT) &&\n\t    !(ss_reg & BQ24190_REG_SS_PG_STAT_MASK))\n\t\tf_reg = 0;\n\n\tif (f_reg != bdi->f_reg) {\n\t\tdev_warn(bdi->dev,\n\t\t\t\"Fault: boost %d, charge %d, battery %d, ntc %d\\n\",\n\t\t\t!!(f_reg & BQ24190_REG_F_BOOST_FAULT_MASK),\n\t\t\t!!(f_reg & BQ24190_REG_F_CHRG_FAULT_MASK),\n\t\t\t!!(f_reg & BQ24190_REG_F_BAT_FAULT_MASK),\n\t\t\t!!(f_reg & BQ24190_REG_F_NTC_FAULT_MASK));\n\n\t\tmutex_lock(&bdi->f_reg_lock);\n\t\tif ((bdi->f_reg & battery_mask_f) != (f_reg & battery_mask_f))\n\t\t\talert_battery = true;\n\t\tif ((bdi->f_reg & ~battery_mask_f) != (f_reg & ~battery_mask_f))\n\t\t\talert_charger = true;\n\t\tbdi->f_reg = f_reg;\n\t\tmutex_unlock(&bdi->f_reg_lock);\n\t}\n\n\tif (ss_reg != bdi->ss_reg) {\n\t\t/*\n\t\t * The device is in host mode so when PG_STAT goes from 1->0\n\t\t * (i.e., power removed) HIZ needs to be disabled.\n\t\t */\n\t\tif ((bdi->ss_reg & BQ24190_REG_SS_PG_STAT_MASK) &&\n\t\t\t\t!(ss_reg & BQ24190_REG_SS_PG_STAT_MASK)) {\n\t\t\tret = bq24190_write_mask(bdi, BQ24190_REG_ISC,\n\t\t\t\t\tBQ24190_REG_ISC_EN_HIZ_MASK,\n\t\t\t\t\tBQ24190_REG_ISC_EN_HIZ_SHIFT,\n\t\t\t\t\t0);\n\t\t\tif (ret < 0)\n\t\t\t\tdev_err(bdi->dev, \"Can't access ISC reg: %d\\n\",\n\t\t\t\t\tret);\n\t\t}\n\n\t\tif ((bdi->ss_reg & battery_mask_ss) != (ss_reg & battery_mask_ss))\n\t\t\talert_battery = true;\n\t\tif ((bdi->ss_reg & ~battery_mask_ss) != (ss_reg & ~battery_mask_ss))\n\t\t\talert_charger = true;\n\t\tbdi->ss_reg = ss_reg;\n\t}\n\n\tif (alert_charger || alert_battery) {\n\t\tpower_supply_changed(bdi->charger);\n\t\tbq24190_configure_usb_otg(bdi, ss_reg);\n\t}\n\tif (alert_battery && bdi->battery)\n\t\tpower_supply_changed(bdi->battery);\n\n\tdev_dbg(bdi->dev, \"ss_reg: 0x%02x, f_reg: 0x%02x\\n\", ss_reg, f_reg);\n}\n\nstatic irqreturn_t bq24190_irq_handler_thread(int irq, void *data)\n{\n\tstruct bq24190_dev_info *bdi = data;\n\tint error;\n\n\tbdi->irq_event = true;\n\terror = pm_runtime_resume_and_get(bdi->dev);\n\tif (error < 0) {\n\t\tdev_warn(bdi->dev, \"pm_runtime_get failed: %i\\n\", error);\n\t\treturn IRQ_NONE;\n\t}\n\tbq24190_check_status(bdi);\n\tpm_runtime_mark_last_busy(bdi->dev);\n\tpm_runtime_put_autosuspend(bdi->dev);\n\tbdi->irq_event = false;\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int bq24190_hw_init(struct bq24190_dev_info *bdi)\n{\n\tu8 v;\n\tint ret;\n\n\t/* First check that the device really is what its supposed to be */\n\tret = bq24190_read_mask(bdi, BQ24190_REG_VPRS,\n\t\t\tBQ24190_REG_VPRS_PN_MASK,\n\t\t\tBQ24190_REG_VPRS_PN_SHIFT,\n\t\t\t&v);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tswitch (v) {\n\tcase BQ24190_REG_VPRS_PN_24190:\n\tcase BQ24190_REG_VPRS_PN_24192:\n\tcase BQ24190_REG_VPRS_PN_24192I:\n\t\tbreak;\n\tdefault:\n\t\tdev_err(bdi->dev, \"Error unknown model: 0x%02x\\n\", v);\n\t\treturn -ENODEV;\n\t}\n\n\tret = bq24190_register_reset(bdi);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = bq24190_set_config(bdi);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn bq24190_read(bdi, BQ24190_REG_SS, &bdi->ss_reg);\n}\n\nstatic int bq24190_get_config(struct bq24190_dev_info *bdi)\n{\n\tconst char * const s = \"ti,system-minimum-microvolt\";\n\tstruct power_supply_battery_info *info;\n\tint v, idx;\n\n\tidx = ARRAY_SIZE(bq24190_ccc_ichg_values) - 1;\n\tbdi->ichg_max = bq24190_ccc_ichg_values[idx];\n\n\tidx = ARRAY_SIZE(bq24190_cvc_vreg_values) - 1;\n\tbdi->vreg_max = bq24190_cvc_vreg_values[idx];\n\n\tif (device_property_read_u32(bdi->dev, s, &v) == 0) {\n\t\tv /= 1000;\n\t\tif (v >= BQ24190_REG_POC_SYS_MIN_MIN\n\t\t && v <= BQ24190_REG_POC_SYS_MIN_MAX)\n\t\t\tbdi->sys_min = v;\n\t\telse\n\t\t\tdev_warn(bdi->dev, \"invalid value for %s: %u\\n\", s, v);\n\t}\n\n\tif (!power_supply_get_battery_info(bdi->charger, &info)) {\n\t\tv = info->precharge_current_ua / 1000;\n\t\tif (v >= BQ24190_REG_PCTCC_IPRECHG_MIN\n\t\t && v <= BQ24190_REG_PCTCC_IPRECHG_MAX)\n\t\t\tbdi->iprechg = v;\n\t\telse\n\t\t\tdev_warn(bdi->dev, \"invalid value for battery:precharge-current-microamp: %d\\n\",\n\t\t\t\t v);\n\n\t\tv = info->charge_term_current_ua / 1000;\n\t\tif (v >= BQ24190_REG_PCTCC_ITERM_MIN\n\t\t && v <= BQ24190_REG_PCTCC_ITERM_MAX)\n\t\t\tbdi->iterm = v;\n\t\telse\n\t\t\tdev_warn(bdi->dev, \"invalid value for battery:charge-term-current-microamp: %d\\n\",\n\t\t\t\t v);\n\n\t\t/* These are optional, so no warning when not set */\n\t\tv = info->constant_charge_current_max_ua;\n\t\tif (v >= bq24190_ccc_ichg_values[0] && v <= bdi->ichg_max)\n\t\t\tbdi->ichg = bdi->ichg_max = v;\n\n\t\tv = info->constant_charge_voltage_max_uv;\n\t\tif (v >= bq24190_cvc_vreg_values[0] && v <= bdi->vreg_max)\n\t\t\tbdi->vreg = bdi->vreg_max = v;\n\t}\n\n\treturn 0;\n}\n\nstatic int bq24190_probe(struct i2c_client *client)\n{\n\tconst struct i2c_device_id *id = i2c_client_get_device_id(client);\n\tstruct i2c_adapter *adapter = client->adapter;\n\tstruct device *dev = &client->dev;\n\tstruct power_supply_config charger_cfg = {}, battery_cfg = {};\n\tstruct bq24190_dev_info *bdi;\n\tint ret;\n\n\tif (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE_DATA)) {\n\t\tdev_err(dev, \"No support for SMBUS_BYTE_DATA\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tbdi = devm_kzalloc(dev, sizeof(*bdi), GFP_KERNEL);\n\tif (!bdi) {\n\t\tdev_err(dev, \"Can't alloc bdi struct\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tbdi->client = client;\n\tbdi->dev = dev;\n\tstrncpy(bdi->model_name, id->name, I2C_NAME_SIZE);\n\tmutex_init(&bdi->f_reg_lock);\n\tbdi->charge_type = POWER_SUPPLY_CHARGE_TYPE_FAST;\n\tbdi->f_reg = 0;\n\tbdi->ss_reg = BQ24190_REG_SS_VBUS_STAT_MASK; /* impossible state */\n\tINIT_DELAYED_WORK(&bdi->input_current_limit_work,\n\t\t\t  bq24190_input_current_limit_work);\n\n\ti2c_set_clientdata(client, bdi);\n\n\tif (client->irq <= 0) {\n\t\tdev_err(dev, \"Can't get irq info\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tbdi->edev = devm_extcon_dev_allocate(dev, bq24190_usb_extcon_cable);\n\tif (IS_ERR(bdi->edev))\n\t\treturn PTR_ERR(bdi->edev);\n\n\tret = devm_extcon_dev_register(dev, bdi->edev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tpm_runtime_enable(dev);\n\tpm_runtime_use_autosuspend(dev);\n\tpm_runtime_set_autosuspend_delay(dev, 600);\n\tret = pm_runtime_get_sync(dev);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"pm_runtime_get failed: %i\\n\", ret);\n\t\tgoto out_pmrt;\n\t}\n\n#ifdef CONFIG_SYSFS\n\tbq24190_sysfs_init_attrs();\n\tcharger_cfg.attr_grp = bq24190_sysfs_groups;\n#endif\n\n\tcharger_cfg.drv_data = bdi;\n\tcharger_cfg.of_node = dev->of_node;\n\tcharger_cfg.supplied_to = bq24190_charger_supplied_to;\n\tcharger_cfg.num_supplicants = ARRAY_SIZE(bq24190_charger_supplied_to);\n\tbdi->charger = power_supply_register(dev, &bq24190_charger_desc,\n\t\t\t\t\t\t&charger_cfg);\n\tif (IS_ERR(bdi->charger)) {\n\t\tdev_err(dev, \"Can't register charger\\n\");\n\t\tret = PTR_ERR(bdi->charger);\n\t\tgoto out_pmrt;\n\t}\n\n\t/* the battery class is deprecated and will be removed. */\n\t/* in the interim, this property hides it.              */\n\tif (!device_property_read_bool(dev, \"omit-battery-class\")) {\n\t\tbattery_cfg.drv_data = bdi;\n\t\tbdi->battery = power_supply_register(dev, &bq24190_battery_desc,\n\t\t\t\t\t\t     &battery_cfg);\n\t\tif (IS_ERR(bdi->battery)) {\n\t\t\tdev_err(dev, \"Can't register battery\\n\");\n\t\t\tret = PTR_ERR(bdi->battery);\n\t\t\tgoto out_charger;\n\t\t}\n\t}\n\n\tret = bq24190_get_config(bdi);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Can't get devicetree config\\n\");\n\t\tgoto out_charger;\n\t}\n\n\tret = bq24190_hw_init(bdi);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Hardware init failed\\n\");\n\t\tgoto out_charger;\n\t}\n\n\tret = bq24190_configure_usb_otg(bdi, bdi->ss_reg);\n\tif (ret < 0)\n\t\tgoto out_charger;\n\n\tbdi->initialized = true;\n\n\tret = devm_request_threaded_irq(dev, client->irq, NULL,\n\t\t\tbq24190_irq_handler_thread,\n\t\t\tIRQF_TRIGGER_FALLING | IRQF_ONESHOT,\n\t\t\t\"bq24190-charger\", bdi);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Can't set up irq handler\\n\");\n\t\tgoto out_charger;\n\t}\n\n\tret = bq24190_register_vbus_regulator(bdi);\n\tif (ret < 0)\n\t\tgoto out_charger;\n\n\tenable_irq_wake(client->irq);\n\n\tpm_runtime_mark_last_busy(dev);\n\tpm_runtime_put_autosuspend(dev);\n\n\treturn 0;\n\nout_charger:\n\tif (!IS_ERR_OR_NULL(bdi->battery))\n\t\tpower_supply_unregister(bdi->battery);\n\tpower_supply_unregister(bdi->charger);\n\nout_pmrt:\n\tpm_runtime_put_sync(dev);\n\tpm_runtime_dont_use_autosuspend(dev);\n\tpm_runtime_disable(dev);\n\treturn ret;\n}\n\nstatic void bq24190_remove(struct i2c_client *client)\n{\n\tstruct bq24190_dev_info *bdi = i2c_get_clientdata(client);\n\tint error;\n\n\terror = pm_runtime_resume_and_get(bdi->dev);\n\tif (error < 0)\n\t\tdev_warn(bdi->dev, \"pm_runtime_get failed: %i\\n\", error);\n\n\tbq24190_register_reset(bdi);\n\tif (bdi->battery)\n\t\tpower_supply_unregister(bdi->battery);\n\tpower_supply_unregister(bdi->charger);\n\tif (error >= 0)\n\t\tpm_runtime_put_sync(bdi->dev);\n\tpm_runtime_dont_use_autosuspend(bdi->dev);\n\tpm_runtime_disable(bdi->dev);\n}\n\nstatic void bq24190_shutdown(struct i2c_client *client)\n{\n\tstruct bq24190_dev_info *bdi = i2c_get_clientdata(client);\n\n\t/* Turn off 5V boost regulator on shutdown */\n\tbq24190_set_otg_vbus(bdi, false);\n}\n\nstatic __maybe_unused int bq24190_runtime_suspend(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct bq24190_dev_info *bdi = i2c_get_clientdata(client);\n\n\tif (!bdi->initialized)\n\t\treturn 0;\n\n\tdev_dbg(bdi->dev, \"%s\\n\", __func__);\n\n\treturn 0;\n}\n\nstatic __maybe_unused int bq24190_runtime_resume(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct bq24190_dev_info *bdi = i2c_get_clientdata(client);\n\n\tif (!bdi->initialized)\n\t\treturn 0;\n\n\tif (!bdi->irq_event) {\n\t\tdev_dbg(bdi->dev, \"checking events on possible wakeirq\\n\");\n\t\tbq24190_check_status(bdi);\n\t}\n\n\treturn 0;\n}\n\nstatic __maybe_unused int bq24190_pm_suspend(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct bq24190_dev_info *bdi = i2c_get_clientdata(client);\n\tint error;\n\n\terror = pm_runtime_resume_and_get(bdi->dev);\n\tif (error < 0)\n\t\tdev_warn(bdi->dev, \"pm_runtime_get failed: %i\\n\", error);\n\n\tbq24190_register_reset(bdi);\n\n\tif (error >= 0) {\n\t\tpm_runtime_mark_last_busy(bdi->dev);\n\t\tpm_runtime_put_autosuspend(bdi->dev);\n\t}\n\n\treturn 0;\n}\n\nstatic __maybe_unused int bq24190_pm_resume(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct bq24190_dev_info *bdi = i2c_get_clientdata(client);\n\tint error;\n\n\tbdi->f_reg = 0;\n\tbdi->ss_reg = BQ24190_REG_SS_VBUS_STAT_MASK; /* impossible state */\n\n\terror = pm_runtime_resume_and_get(bdi->dev);\n\tif (error < 0)\n\t\tdev_warn(bdi->dev, \"pm_runtime_get failed: %i\\n\", error);\n\n\tbq24190_register_reset(bdi);\n\tbq24190_set_config(bdi);\n\tbq24190_read(bdi, BQ24190_REG_SS, &bdi->ss_reg);\n\n\tif (error >= 0) {\n\t\tpm_runtime_mark_last_busy(bdi->dev);\n\t\tpm_runtime_put_autosuspend(bdi->dev);\n\t}\n\n\t/* Things may have changed while suspended so alert upper layer */\n\tpower_supply_changed(bdi->charger);\n\tif (bdi->battery)\n\t\tpower_supply_changed(bdi->battery);\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops bq24190_pm_ops = {\n\tSET_RUNTIME_PM_OPS(bq24190_runtime_suspend, bq24190_runtime_resume,\n\t\t\t   NULL)\n\tSET_SYSTEM_SLEEP_PM_OPS(bq24190_pm_suspend, bq24190_pm_resume)\n};\n\nstatic const struct i2c_device_id bq24190_i2c_ids[] = {\n\t{ \"bq24190\" },\n\t{ \"bq24192\" },\n\t{ \"bq24192i\" },\n\t{ \"bq24196\" },\n\t{ },\n};\nMODULE_DEVICE_TABLE(i2c, bq24190_i2c_ids);\n\nstatic const struct of_device_id bq24190_of_match[] = {\n\t{ .compatible = \"ti,bq24190\", },\n\t{ .compatible = \"ti,bq24192\", },\n\t{ .compatible = \"ti,bq24192i\", },\n\t{ .compatible = \"ti,bq24196\", },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, bq24190_of_match);\n\nstatic struct i2c_driver bq24190_driver = {\n\t.probe_new\t= bq24190_probe,\n\t.remove\t\t= bq24190_remove,\n\t.shutdown\t= bq24190_shutdown,\n\t.id_table\t= bq24190_i2c_ids,\n\t.driver = {\n\t\t.name\t\t= \"bq24190-charger\",\n\t\t.pm\t\t= &bq24190_pm_ops,\n\t\t.of_match_table\t= bq24190_of_match,\n\t},\n};\nmodule_i2c_driver(bq24190_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Mark A. Greer <mgreer@animalcreek.com>\");\nMODULE_DESCRIPTION(\"TI BQ24190 Charger Driver\");\n"], "fixing_code": ["// SPDX-License-Identifier: GPL-2.0-only\n/*\n * Driver for the TI bq24190 battery charger.\n *\n * Author: Mark A. Greer <mgreer@animalcreek.com>\n */\n\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n#include <linux/pm_runtime.h>\n#include <linux/power_supply.h>\n#include <linux/power/bq24190_charger.h>\n#include <linux/regulator/driver.h>\n#include <linux/regulator/machine.h>\n#include <linux/workqueue.h>\n#include <linux/i2c.h>\n#include <linux/extcon-provider.h>\n\n#define\tBQ24190_MANUFACTURER\t\"Texas Instruments\"\n\n#define BQ24190_REG_ISC\t\t0x00 /* Input Source Control */\n#define BQ24190_REG_ISC_EN_HIZ_MASK\t\tBIT(7)\n#define BQ24190_REG_ISC_EN_HIZ_SHIFT\t\t7\n#define BQ24190_REG_ISC_VINDPM_MASK\t\t(BIT(6) | BIT(5) | BIT(4) | \\\n\t\t\t\t\t\t BIT(3))\n#define BQ24190_REG_ISC_VINDPM_SHIFT\t\t3\n#define BQ24190_REG_ISC_IINLIM_MASK\t\t(BIT(2) | BIT(1) | BIT(0))\n#define BQ24190_REG_ISC_IINLIM_SHIFT\t\t0\n\n#define BQ24190_REG_POC\t\t0x01 /* Power-On Configuration */\n#define BQ24190_REG_POC_RESET_MASK\t\tBIT(7)\n#define BQ24190_REG_POC_RESET_SHIFT\t\t7\n#define BQ24190_REG_POC_WDT_RESET_MASK\t\tBIT(6)\n#define BQ24190_REG_POC_WDT_RESET_SHIFT\t\t6\n#define BQ24190_REG_POC_CHG_CONFIG_MASK\t\t(BIT(5) | BIT(4))\n#define BQ24190_REG_POC_CHG_CONFIG_SHIFT\t4\n#define BQ24190_REG_POC_CHG_CONFIG_DISABLE\t\t0x0\n#define BQ24190_REG_POC_CHG_CONFIG_CHARGE\t\t0x1\n#define BQ24190_REG_POC_CHG_CONFIG_OTG\t\t\t0x2\n#define BQ24190_REG_POC_CHG_CONFIG_OTG_ALT\t\t0x3\n#define BQ24190_REG_POC_SYS_MIN_MASK\t\t(BIT(3) | BIT(2) | BIT(1))\n#define BQ24190_REG_POC_SYS_MIN_SHIFT\t\t1\n#define BQ24190_REG_POC_SYS_MIN_MIN\t\t\t3000\n#define BQ24190_REG_POC_SYS_MIN_MAX\t\t\t3700\n#define BQ24190_REG_POC_BOOST_LIM_MASK\t\tBIT(0)\n#define BQ24190_REG_POC_BOOST_LIM_SHIFT\t\t0\n\n#define BQ24190_REG_CCC\t\t0x02 /* Charge Current Control */\n#define BQ24190_REG_CCC_ICHG_MASK\t\t(BIT(7) | BIT(6) | BIT(5) | \\\n\t\t\t\t\t\t BIT(4) | BIT(3) | BIT(2))\n#define BQ24190_REG_CCC_ICHG_SHIFT\t\t2\n#define BQ24190_REG_CCC_FORCE_20PCT_MASK\tBIT(0)\n#define BQ24190_REG_CCC_FORCE_20PCT_SHIFT\t0\n\n#define BQ24190_REG_PCTCC\t0x03 /* Pre-charge/Termination Current Cntl */\n#define BQ24190_REG_PCTCC_IPRECHG_MASK\t\t(BIT(7) | BIT(6) | BIT(5) | \\\n\t\t\t\t\t\t BIT(4))\n#define BQ24190_REG_PCTCC_IPRECHG_SHIFT\t\t4\n#define BQ24190_REG_PCTCC_IPRECHG_MIN\t\t\t128\n#define BQ24190_REG_PCTCC_IPRECHG_MAX\t\t\t2048\n#define BQ24190_REG_PCTCC_ITERM_MASK\t\t(BIT(3) | BIT(2) | BIT(1) | \\\n\t\t\t\t\t\t BIT(0))\n#define BQ24190_REG_PCTCC_ITERM_SHIFT\t\t0\n#define BQ24190_REG_PCTCC_ITERM_MIN\t\t\t128\n#define BQ24190_REG_PCTCC_ITERM_MAX\t\t\t2048\n\n#define BQ24190_REG_CVC\t\t0x04 /* Charge Voltage Control */\n#define BQ24190_REG_CVC_VREG_MASK\t\t(BIT(7) | BIT(6) | BIT(5) | \\\n\t\t\t\t\t\t BIT(4) | BIT(3) | BIT(2))\n#define BQ24190_REG_CVC_VREG_SHIFT\t\t2\n#define BQ24190_REG_CVC_BATLOWV_MASK\t\tBIT(1)\n#define BQ24190_REG_CVC_BATLOWV_SHIFT\t\t1\n#define BQ24190_REG_CVC_VRECHG_MASK\t\tBIT(0)\n#define BQ24190_REG_CVC_VRECHG_SHIFT\t\t0\n\n#define BQ24190_REG_CTTC\t0x05 /* Charge Term/Timer Control */\n#define BQ24190_REG_CTTC_EN_TERM_MASK\t\tBIT(7)\n#define BQ24190_REG_CTTC_EN_TERM_SHIFT\t\t7\n#define BQ24190_REG_CTTC_TERM_STAT_MASK\t\tBIT(6)\n#define BQ24190_REG_CTTC_TERM_STAT_SHIFT\t6\n#define BQ24190_REG_CTTC_WATCHDOG_MASK\t\t(BIT(5) | BIT(4))\n#define BQ24190_REG_CTTC_WATCHDOG_SHIFT\t\t4\n#define BQ24190_REG_CTTC_EN_TIMER_MASK\t\tBIT(3)\n#define BQ24190_REG_CTTC_EN_TIMER_SHIFT\t\t3\n#define BQ24190_REG_CTTC_CHG_TIMER_MASK\t\t(BIT(2) | BIT(1))\n#define BQ24190_REG_CTTC_CHG_TIMER_SHIFT\t1\n#define BQ24190_REG_CTTC_JEITA_ISET_MASK\tBIT(0)\n#define BQ24190_REG_CTTC_JEITA_ISET_SHIFT\t0\n\n#define BQ24190_REG_ICTRC\t0x06 /* IR Comp/Thermal Regulation Control */\n#define BQ24190_REG_ICTRC_BAT_COMP_MASK\t\t(BIT(7) | BIT(6) | BIT(5))\n#define BQ24190_REG_ICTRC_BAT_COMP_SHIFT\t5\n#define BQ24190_REG_ICTRC_VCLAMP_MASK\t\t(BIT(4) | BIT(3) | BIT(2))\n#define BQ24190_REG_ICTRC_VCLAMP_SHIFT\t\t2\n#define BQ24190_REG_ICTRC_TREG_MASK\t\t(BIT(1) | BIT(0))\n#define BQ24190_REG_ICTRC_TREG_SHIFT\t\t0\n\n#define BQ24190_REG_MOC\t\t0x07 /* Misc. Operation Control */\n#define BQ24190_REG_MOC_DPDM_EN_MASK\t\tBIT(7)\n#define BQ24190_REG_MOC_DPDM_EN_SHIFT\t\t7\n#define BQ24190_REG_MOC_TMR2X_EN_MASK\t\tBIT(6)\n#define BQ24190_REG_MOC_TMR2X_EN_SHIFT\t\t6\n#define BQ24190_REG_MOC_BATFET_DISABLE_MASK\tBIT(5)\n#define BQ24190_REG_MOC_BATFET_DISABLE_SHIFT\t5\n#define BQ24190_REG_MOC_JEITA_VSET_MASK\t\tBIT(4)\n#define BQ24190_REG_MOC_JEITA_VSET_SHIFT\t4\n#define BQ24190_REG_MOC_INT_MASK_MASK\t\t(BIT(1) | BIT(0))\n#define BQ24190_REG_MOC_INT_MASK_SHIFT\t\t0\n\n#define BQ24190_REG_SS\t\t0x08 /* System Status */\n#define BQ24190_REG_SS_VBUS_STAT_MASK\t\t(BIT(7) | BIT(6))\n#define BQ24190_REG_SS_VBUS_STAT_SHIFT\t\t6\n#define BQ24190_REG_SS_CHRG_STAT_MASK\t\t(BIT(5) | BIT(4))\n#define BQ24190_REG_SS_CHRG_STAT_SHIFT\t\t4\n#define BQ24190_REG_SS_DPM_STAT_MASK\t\tBIT(3)\n#define BQ24190_REG_SS_DPM_STAT_SHIFT\t\t3\n#define BQ24190_REG_SS_PG_STAT_MASK\t\tBIT(2)\n#define BQ24190_REG_SS_PG_STAT_SHIFT\t\t2\n#define BQ24190_REG_SS_THERM_STAT_MASK\t\tBIT(1)\n#define BQ24190_REG_SS_THERM_STAT_SHIFT\t\t1\n#define BQ24190_REG_SS_VSYS_STAT_MASK\t\tBIT(0)\n#define BQ24190_REG_SS_VSYS_STAT_SHIFT\t\t0\n\n#define BQ24190_REG_F\t\t0x09 /* Fault */\n#define BQ24190_REG_F_WATCHDOG_FAULT_MASK\tBIT(7)\n#define BQ24190_REG_F_WATCHDOG_FAULT_SHIFT\t7\n#define BQ24190_REG_F_BOOST_FAULT_MASK\t\tBIT(6)\n#define BQ24190_REG_F_BOOST_FAULT_SHIFT\t\t6\n#define BQ24190_REG_F_CHRG_FAULT_MASK\t\t(BIT(5) | BIT(4))\n#define BQ24190_REG_F_CHRG_FAULT_SHIFT\t\t4\n#define BQ24190_REG_F_BAT_FAULT_MASK\t\tBIT(3)\n#define BQ24190_REG_F_BAT_FAULT_SHIFT\t\t3\n#define BQ24190_REG_F_NTC_FAULT_MASK\t\t(BIT(2) | BIT(1) | BIT(0))\n#define BQ24190_REG_F_NTC_FAULT_SHIFT\t\t0\n\n#define BQ24190_REG_VPRS\t0x0A /* Vendor/Part/Revision Status */\n#define BQ24190_REG_VPRS_PN_MASK\t\t(BIT(5) | BIT(4) | BIT(3))\n#define BQ24190_REG_VPRS_PN_SHIFT\t\t3\n#define BQ24190_REG_VPRS_PN_24190\t\t\t0x4\n#define BQ24190_REG_VPRS_PN_24192\t\t\t0x5 /* Also 24193, 24196 */\n#define BQ24190_REG_VPRS_PN_24192I\t\t\t0x3\n#define BQ24190_REG_VPRS_TS_PROFILE_MASK\tBIT(2)\n#define BQ24190_REG_VPRS_TS_PROFILE_SHIFT\t2\n#define BQ24190_REG_VPRS_DEV_REG_MASK\t\t(BIT(1) | BIT(0))\n#define BQ24190_REG_VPRS_DEV_REG_SHIFT\t\t0\n\n/*\n * The FAULT register is latched by the bq24190 (except for NTC_FAULT)\n * so the first read after a fault returns the latched value and subsequent\n * reads return the current value.  In order to return the fault status\n * to the user, have the interrupt handler save the reg's value and retrieve\n * it in the appropriate health/status routine.\n */\nstruct bq24190_dev_info {\n\tstruct i2c_client\t\t*client;\n\tstruct device\t\t\t*dev;\n\tstruct extcon_dev\t\t*edev;\n\tstruct power_supply\t\t*charger;\n\tstruct power_supply\t\t*battery;\n\tstruct delayed_work\t\tinput_current_limit_work;\n\tchar\t\t\t\tmodel_name[I2C_NAME_SIZE];\n\tbool\t\t\t\tinitialized;\n\tbool\t\t\t\tirq_event;\n\tbool\t\t\t\totg_vbus_enabled;\n\tint\t\t\t\tcharge_type;\n\tu16\t\t\t\tsys_min;\n\tu16\t\t\t\tiprechg;\n\tu16\t\t\t\titerm;\n\tu32\t\t\t\tichg;\n\tu32\t\t\t\tichg_max;\n\tu32\t\t\t\tvreg;\n\tu32\t\t\t\tvreg_max;\n\tstruct mutex\t\t\tf_reg_lock;\n\tu8\t\t\t\tf_reg;\n\tu8\t\t\t\tss_reg;\n\tu8\t\t\t\twatchdog;\n};\n\nstatic int bq24190_charger_set_charge_type(struct bq24190_dev_info *bdi,\n\t\t\t\t\t   const union power_supply_propval *val);\n\nstatic const unsigned int bq24190_usb_extcon_cable[] = {\n\tEXTCON_USB,\n\tEXTCON_NONE,\n};\n\n/*\n * The tables below provide a 2-way mapping for the value that goes in\n * the register field and the real-world value that it represents.\n * The index of the array is the value that goes in the register; the\n * number at that index in the array is the real-world value that it\n * represents.\n */\n\n/* REG00[2:0] (IINLIM) in uAh */\nstatic const int bq24190_isc_iinlim_values[] = {\n\t 100000,  150000,  500000,  900000, 1200000, 1500000, 2000000, 3000000\n};\n\n/* REG02[7:2] (ICHG) in uAh */\nstatic const int bq24190_ccc_ichg_values[] = {\n\t 512000,  576000,  640000,  704000,  768000,  832000,  896000,  960000,\n\t1024000, 1088000, 1152000, 1216000, 1280000, 1344000, 1408000, 1472000,\n\t1536000, 1600000, 1664000, 1728000, 1792000, 1856000, 1920000, 1984000,\n\t2048000, 2112000, 2176000, 2240000, 2304000, 2368000, 2432000, 2496000,\n\t2560000, 2624000, 2688000, 2752000, 2816000, 2880000, 2944000, 3008000,\n\t3072000, 3136000, 3200000, 3264000, 3328000, 3392000, 3456000, 3520000,\n\t3584000, 3648000, 3712000, 3776000, 3840000, 3904000, 3968000, 4032000,\n\t4096000, 4160000, 4224000, 4288000, 4352000, 4416000, 4480000, 4544000\n};\n\n/* REG04[7:2] (VREG) in uV */\nstatic const int bq24190_cvc_vreg_values[] = {\n\t3504000, 3520000, 3536000, 3552000, 3568000, 3584000, 3600000, 3616000,\n\t3632000, 3648000, 3664000, 3680000, 3696000, 3712000, 3728000, 3744000,\n\t3760000, 3776000, 3792000, 3808000, 3824000, 3840000, 3856000, 3872000,\n\t3888000, 3904000, 3920000, 3936000, 3952000, 3968000, 3984000, 4000000,\n\t4016000, 4032000, 4048000, 4064000, 4080000, 4096000, 4112000, 4128000,\n\t4144000, 4160000, 4176000, 4192000, 4208000, 4224000, 4240000, 4256000,\n\t4272000, 4288000, 4304000, 4320000, 4336000, 4352000, 4368000, 4384000,\n\t4400000\n};\n\n/* REG06[1:0] (TREG) in tenths of degrees Celsius */\nstatic const int bq24190_ictrc_treg_values[] = {\n\t600, 800, 1000, 1200\n};\n\n/*\n * Return the index in 'tbl' of greatest value that is less than or equal to\n * 'val'.  The index range returned is 0 to 'tbl_size' - 1.  Assumes that\n * the values in 'tbl' are sorted from smallest to largest and 'tbl_size'\n * is less than 2^8.\n */\nstatic u8 bq24190_find_idx(const int tbl[], int tbl_size, int v)\n{\n\tint i;\n\n\tfor (i = 1; i < tbl_size; i++)\n\t\tif (v < tbl[i])\n\t\t\tbreak;\n\n\treturn i - 1;\n}\n\n/* Basic driver I/O routines */\n\nstatic int bq24190_read(struct bq24190_dev_info *bdi, u8 reg, u8 *data)\n{\n\tint ret;\n\n\tret = i2c_smbus_read_byte_data(bdi->client, reg);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t*data = ret;\n\treturn 0;\n}\n\nstatic int bq24190_write(struct bq24190_dev_info *bdi, u8 reg, u8 data)\n{\n\treturn i2c_smbus_write_byte_data(bdi->client, reg, data);\n}\n\nstatic int bq24190_read_mask(struct bq24190_dev_info *bdi, u8 reg,\n\t\tu8 mask, u8 shift, u8 *data)\n{\n\tu8 v;\n\tint ret;\n\n\tret = bq24190_read(bdi, reg, &v);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tv &= mask;\n\tv >>= shift;\n\t*data = v;\n\n\treturn 0;\n}\n\nstatic int bq24190_write_mask(struct bq24190_dev_info *bdi, u8 reg,\n\t\tu8 mask, u8 shift, u8 data)\n{\n\tu8 v;\n\tint ret;\n\n\tret = bq24190_read(bdi, reg, &v);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tv &= ~mask;\n\tv |= ((data << shift) & mask);\n\n\treturn bq24190_write(bdi, reg, v);\n}\n\nstatic int bq24190_get_field_val(struct bq24190_dev_info *bdi,\n\t\tu8 reg, u8 mask, u8 shift,\n\t\tconst int tbl[], int tbl_size,\n\t\tint *val)\n{\n\tu8 v;\n\tint ret;\n\n\tret = bq24190_read_mask(bdi, reg, mask, shift, &v);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tv = (v >= tbl_size) ? (tbl_size - 1) : v;\n\t*val = tbl[v];\n\n\treturn 0;\n}\n\nstatic int bq24190_set_field_val(struct bq24190_dev_info *bdi,\n\t\tu8 reg, u8 mask, u8 shift,\n\t\tconst int tbl[], int tbl_size,\n\t\tint val)\n{\n\tu8 idx;\n\n\tidx = bq24190_find_idx(tbl, tbl_size, val);\n\n\treturn bq24190_write_mask(bdi, reg, mask, shift, idx);\n}\n\n#ifdef CONFIG_SYSFS\n/*\n * There are a numerous options that are configurable on the bq24190\n * that go well beyond what the power_supply properties provide access to.\n * Provide sysfs access to them so they can be examined and possibly modified\n * on the fly.  They will be provided for the charger power_supply object only\n * and will be prefixed by 'f_' to make them easier to recognize.\n */\n\n#define BQ24190_SYSFS_FIELD(_name, r, f, m, store)\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\t.attr\t= __ATTR(f_##_name, m, bq24190_sysfs_show, store),\t\\\n\t.reg\t= BQ24190_REG_##r,\t\t\t\t\t\\\n\t.mask\t= BQ24190_REG_##r##_##f##_MASK,\t\t\t\t\\\n\t.shift\t= BQ24190_REG_##r##_##f##_SHIFT,\t\t\t\\\n}\n\n#define BQ24190_SYSFS_FIELD_RW(_name, r, f)\t\t\t\t\\\n\t\tBQ24190_SYSFS_FIELD(_name, r, f, S_IWUSR | S_IRUGO,\t\\\n\t\t\t\tbq24190_sysfs_store)\n\n#define BQ24190_SYSFS_FIELD_RO(_name, r, f)\t\t\t\t\\\n\t\tBQ24190_SYSFS_FIELD(_name, r, f, S_IRUGO, NULL)\n\nstatic ssize_t bq24190_sysfs_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf);\nstatic ssize_t bq24190_sysfs_store(struct device *dev,\n\t\tstruct device_attribute *attr, const char *buf, size_t count);\n\nstruct bq24190_sysfs_field_info {\n\tstruct device_attribute\tattr;\n\tu8\treg;\n\tu8\tmask;\n\tu8\tshift;\n};\n\n/* On i386 ptrace-abi.h defines SS that breaks the macro calls below. */\n#undef SS\n\nstatic struct bq24190_sysfs_field_info bq24190_sysfs_field_tbl[] = {\n\t\t\t/*\tsysfs name\treg\tfield in reg */\n\tBQ24190_SYSFS_FIELD_RW(en_hiz,\t\tISC,\tEN_HIZ),\n\tBQ24190_SYSFS_FIELD_RW(vindpm,\t\tISC,\tVINDPM),\n\tBQ24190_SYSFS_FIELD_RW(iinlim,\t\tISC,\tIINLIM),\n\tBQ24190_SYSFS_FIELD_RW(chg_config,\tPOC,\tCHG_CONFIG),\n\tBQ24190_SYSFS_FIELD_RW(sys_min,\t\tPOC,\tSYS_MIN),\n\tBQ24190_SYSFS_FIELD_RW(boost_lim,\tPOC,\tBOOST_LIM),\n\tBQ24190_SYSFS_FIELD_RW(ichg,\t\tCCC,\tICHG),\n\tBQ24190_SYSFS_FIELD_RW(force_20_pct,\tCCC,\tFORCE_20PCT),\n\tBQ24190_SYSFS_FIELD_RW(iprechg,\t\tPCTCC,\tIPRECHG),\n\tBQ24190_SYSFS_FIELD_RW(iterm,\t\tPCTCC,\tITERM),\n\tBQ24190_SYSFS_FIELD_RW(vreg,\t\tCVC,\tVREG),\n\tBQ24190_SYSFS_FIELD_RW(batlowv,\t\tCVC,\tBATLOWV),\n\tBQ24190_SYSFS_FIELD_RW(vrechg,\t\tCVC,\tVRECHG),\n\tBQ24190_SYSFS_FIELD_RW(en_term,\t\tCTTC,\tEN_TERM),\n\tBQ24190_SYSFS_FIELD_RW(term_stat,\tCTTC,\tTERM_STAT),\n\tBQ24190_SYSFS_FIELD_RO(watchdog,\tCTTC,\tWATCHDOG),\n\tBQ24190_SYSFS_FIELD_RW(en_timer,\tCTTC,\tEN_TIMER),\n\tBQ24190_SYSFS_FIELD_RW(chg_timer,\tCTTC,\tCHG_TIMER),\n\tBQ24190_SYSFS_FIELD_RW(jeta_iset,\tCTTC,\tJEITA_ISET),\n\tBQ24190_SYSFS_FIELD_RW(bat_comp,\tICTRC,\tBAT_COMP),\n\tBQ24190_SYSFS_FIELD_RW(vclamp,\t\tICTRC,\tVCLAMP),\n\tBQ24190_SYSFS_FIELD_RW(treg,\t\tICTRC,\tTREG),\n\tBQ24190_SYSFS_FIELD_RW(dpdm_en,\t\tMOC,\tDPDM_EN),\n\tBQ24190_SYSFS_FIELD_RW(tmr2x_en,\tMOC,\tTMR2X_EN),\n\tBQ24190_SYSFS_FIELD_RW(batfet_disable,\tMOC,\tBATFET_DISABLE),\n\tBQ24190_SYSFS_FIELD_RW(jeita_vset,\tMOC,\tJEITA_VSET),\n\tBQ24190_SYSFS_FIELD_RO(int_mask,\tMOC,\tINT_MASK),\n\tBQ24190_SYSFS_FIELD_RO(vbus_stat,\tSS,\tVBUS_STAT),\n\tBQ24190_SYSFS_FIELD_RO(chrg_stat,\tSS,\tCHRG_STAT),\n\tBQ24190_SYSFS_FIELD_RO(dpm_stat,\tSS,\tDPM_STAT),\n\tBQ24190_SYSFS_FIELD_RO(pg_stat,\t\tSS,\tPG_STAT),\n\tBQ24190_SYSFS_FIELD_RO(therm_stat,\tSS,\tTHERM_STAT),\n\tBQ24190_SYSFS_FIELD_RO(vsys_stat,\tSS,\tVSYS_STAT),\n\tBQ24190_SYSFS_FIELD_RO(watchdog_fault,\tF,\tWATCHDOG_FAULT),\n\tBQ24190_SYSFS_FIELD_RO(boost_fault,\tF,\tBOOST_FAULT),\n\tBQ24190_SYSFS_FIELD_RO(chrg_fault,\tF,\tCHRG_FAULT),\n\tBQ24190_SYSFS_FIELD_RO(bat_fault,\tF,\tBAT_FAULT),\n\tBQ24190_SYSFS_FIELD_RO(ntc_fault,\tF,\tNTC_FAULT),\n\tBQ24190_SYSFS_FIELD_RO(pn,\t\tVPRS,\tPN),\n\tBQ24190_SYSFS_FIELD_RO(ts_profile,\tVPRS,\tTS_PROFILE),\n\tBQ24190_SYSFS_FIELD_RO(dev_reg,\t\tVPRS,\tDEV_REG),\n};\n\nstatic struct attribute *\n\tbq24190_sysfs_attrs[ARRAY_SIZE(bq24190_sysfs_field_tbl) + 1];\n\nATTRIBUTE_GROUPS(bq24190_sysfs);\n\nstatic void bq24190_sysfs_init_attrs(void)\n{\n\tint i, limit = ARRAY_SIZE(bq24190_sysfs_field_tbl);\n\n\tfor (i = 0; i < limit; i++)\n\t\tbq24190_sysfs_attrs[i] = &bq24190_sysfs_field_tbl[i].attr.attr;\n\n\tbq24190_sysfs_attrs[limit] = NULL; /* Has additional entry for this */\n}\n\nstatic struct bq24190_sysfs_field_info *bq24190_sysfs_field_lookup(\n\t\tconst char *name)\n{\n\tint i, limit = ARRAY_SIZE(bq24190_sysfs_field_tbl);\n\n\tfor (i = 0; i < limit; i++)\n\t\tif (!strcmp(name, bq24190_sysfs_field_tbl[i].attr.attr.name))\n\t\t\tbreak;\n\n\tif (i >= limit)\n\t\treturn NULL;\n\n\treturn &bq24190_sysfs_field_tbl[i];\n}\n\nstatic ssize_t bq24190_sysfs_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct power_supply *psy = dev_get_drvdata(dev);\n\tstruct bq24190_dev_info *bdi = power_supply_get_drvdata(psy);\n\tstruct bq24190_sysfs_field_info *info;\n\tssize_t count;\n\tint ret;\n\tu8 v;\n\n\tinfo = bq24190_sysfs_field_lookup(attr->attr.name);\n\tif (!info)\n\t\treturn -EINVAL;\n\n\tret = pm_runtime_resume_and_get(bdi->dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = bq24190_read_mask(bdi, info->reg, info->mask, info->shift, &v);\n\tif (ret)\n\t\tcount = ret;\n\telse\n\t\tcount = sysfs_emit(buf, \"%hhx\\n\", v);\n\n\tpm_runtime_mark_last_busy(bdi->dev);\n\tpm_runtime_put_autosuspend(bdi->dev);\n\n\treturn count;\n}\n\nstatic ssize_t bq24190_sysfs_store(struct device *dev,\n\t\tstruct device_attribute *attr, const char *buf, size_t count)\n{\n\tstruct power_supply *psy = dev_get_drvdata(dev);\n\tstruct bq24190_dev_info *bdi = power_supply_get_drvdata(psy);\n\tstruct bq24190_sysfs_field_info *info;\n\tint ret;\n\tu8 v;\n\n\tinfo = bq24190_sysfs_field_lookup(attr->attr.name);\n\tif (!info)\n\t\treturn -EINVAL;\n\n\tret = kstrtou8(buf, 0, &v);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = pm_runtime_resume_and_get(bdi->dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = bq24190_write_mask(bdi, info->reg, info->mask, info->shift, v);\n\tif (ret)\n\t\tcount = ret;\n\n\tpm_runtime_mark_last_busy(bdi->dev);\n\tpm_runtime_put_autosuspend(bdi->dev);\n\n\treturn count;\n}\n#endif\n\nstatic int bq24190_set_otg_vbus(struct bq24190_dev_info *bdi, bool enable)\n{\n\tunion power_supply_propval val = { .intval = bdi->charge_type };\n\tint ret;\n\n\tret = pm_runtime_resume_and_get(bdi->dev);\n\tif (ret < 0) {\n\t\tdev_warn(bdi->dev, \"pm_runtime_get failed: %i\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tbdi->otg_vbus_enabled = enable;\n\tif (enable)\n\t\tret = bq24190_write_mask(bdi, BQ24190_REG_POC,\n\t\t\t\t\t BQ24190_REG_POC_CHG_CONFIG_MASK,\n\t\t\t\t\t BQ24190_REG_POC_CHG_CONFIG_SHIFT,\n\t\t\t\t\t BQ24190_REG_POC_CHG_CONFIG_OTG);\n\telse\n\t\tret = bq24190_charger_set_charge_type(bdi, &val);\n\n\tpm_runtime_mark_last_busy(bdi->dev);\n\tpm_runtime_put_autosuspend(bdi->dev);\n\n\treturn ret;\n}\n\n#ifdef CONFIG_REGULATOR\nstatic int bq24190_vbus_enable(struct regulator_dev *dev)\n{\n\treturn bq24190_set_otg_vbus(rdev_get_drvdata(dev), true);\n}\n\nstatic int bq24190_vbus_disable(struct regulator_dev *dev)\n{\n\treturn bq24190_set_otg_vbus(rdev_get_drvdata(dev), false);\n}\n\nstatic int bq24190_vbus_is_enabled(struct regulator_dev *dev)\n{\n\tstruct bq24190_dev_info *bdi = rdev_get_drvdata(dev);\n\tint ret;\n\tu8 val;\n\n\tret = pm_runtime_resume_and_get(bdi->dev);\n\tif (ret < 0) {\n\t\tdev_warn(bdi->dev, \"pm_runtime_get failed: %i\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = bq24190_read_mask(bdi, BQ24190_REG_POC,\n\t\t\t\tBQ24190_REG_POC_CHG_CONFIG_MASK,\n\t\t\t\tBQ24190_REG_POC_CHG_CONFIG_SHIFT, &val);\n\n\tpm_runtime_mark_last_busy(bdi->dev);\n\tpm_runtime_put_autosuspend(bdi->dev);\n\n\tif (ret)\n\t\treturn ret;\n\n\tbdi->otg_vbus_enabled = (val == BQ24190_REG_POC_CHG_CONFIG_OTG ||\n\t\t\t\t val == BQ24190_REG_POC_CHG_CONFIG_OTG_ALT);\n\treturn bdi->otg_vbus_enabled;\n}\n\nstatic const struct regulator_ops bq24190_vbus_ops = {\n\t.enable = bq24190_vbus_enable,\n\t.disable = bq24190_vbus_disable,\n\t.is_enabled = bq24190_vbus_is_enabled,\n};\n\nstatic const struct regulator_desc bq24190_vbus_desc = {\n\t.name = \"usb_otg_vbus\",\n\t.of_match = \"usb-otg-vbus\",\n\t.type = REGULATOR_VOLTAGE,\n\t.owner = THIS_MODULE,\n\t.ops = &bq24190_vbus_ops,\n\t.fixed_uV = 5000000,\n\t.n_voltages = 1,\n};\n\nstatic const struct regulator_init_data bq24190_vbus_init_data = {\n\t.constraints = {\n\t\t.valid_ops_mask = REGULATOR_CHANGE_STATUS,\n\t},\n};\n\nstatic int bq24190_register_vbus_regulator(struct bq24190_dev_info *bdi)\n{\n\tstruct bq24190_platform_data *pdata = bdi->dev->platform_data;\n\tstruct regulator_config cfg = { };\n\tstruct regulator_dev *reg;\n\tint ret = 0;\n\n\tcfg.dev = bdi->dev;\n\tif (pdata && pdata->regulator_init_data)\n\t\tcfg.init_data = pdata->regulator_init_data;\n\telse\n\t\tcfg.init_data = &bq24190_vbus_init_data;\n\tcfg.driver_data = bdi;\n\treg = devm_regulator_register(bdi->dev, &bq24190_vbus_desc, &cfg);\n\tif (IS_ERR(reg)) {\n\t\tret = PTR_ERR(reg);\n\t\tdev_err(bdi->dev, \"Can't register regulator: %d\\n\", ret);\n\t}\n\n\treturn ret;\n}\n#else\nstatic int bq24190_register_vbus_regulator(struct bq24190_dev_info *bdi)\n{\n\treturn 0;\n}\n#endif\n\nstatic int bq24190_set_config(struct bq24190_dev_info *bdi)\n{\n\tint ret;\n\tu8 v;\n\n\tret = bq24190_read(bdi, BQ24190_REG_CTTC, &v);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tbdi->watchdog = ((v & BQ24190_REG_CTTC_WATCHDOG_MASK) >>\n\t\t\t\t\tBQ24190_REG_CTTC_WATCHDOG_SHIFT);\n\n\t/*\n\t * According to the \"Host Mode and default Mode\" section of the\n\t * manual, a write to any register causes the bq24190 to switch\n\t * from default mode to host mode.  It will switch back to default\n\t * mode after a WDT timeout unless the WDT is turned off as well.\n\t * So, by simply turning off the WDT, we accomplish both with the\n\t * same write.\n\t */\n\tv &= ~BQ24190_REG_CTTC_WATCHDOG_MASK;\n\n\tret = bq24190_write(bdi, BQ24190_REG_CTTC, v);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (bdi->sys_min) {\n\t\tv = bdi->sys_min / 100 - 30; // manual section 9.5.1.2, table 9\n\t\tret = bq24190_write_mask(bdi, BQ24190_REG_POC,\n\t\t\t\t\t BQ24190_REG_POC_SYS_MIN_MASK,\n\t\t\t\t\t BQ24190_REG_POC_SYS_MIN_SHIFT,\n\t\t\t\t\t v);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tif (bdi->iprechg) {\n\t\tv = bdi->iprechg / 128 - 1; // manual section 9.5.1.4, table 11\n\t\tret = bq24190_write_mask(bdi, BQ24190_REG_PCTCC,\n\t\t\t\t\t BQ24190_REG_PCTCC_IPRECHG_MASK,\n\t\t\t\t\t BQ24190_REG_PCTCC_IPRECHG_SHIFT,\n\t\t\t\t\t v);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tif (bdi->iterm) {\n\t\tv = bdi->iterm / 128 - 1; // manual section 9.5.1.4, table 11\n\t\tret = bq24190_write_mask(bdi, BQ24190_REG_PCTCC,\n\t\t\t\t\t BQ24190_REG_PCTCC_ITERM_MASK,\n\t\t\t\t\t BQ24190_REG_PCTCC_ITERM_SHIFT,\n\t\t\t\t\t v);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tif (bdi->ichg) {\n\t\tret = bq24190_set_field_val(bdi, BQ24190_REG_CCC,\n\t\t\t\t\t    BQ24190_REG_CCC_ICHG_MASK,\n\t\t\t\t\t    BQ24190_REG_CCC_ICHG_SHIFT,\n\t\t\t\t\t    bq24190_ccc_ichg_values,\n\t\t\t\t\t    ARRAY_SIZE(bq24190_ccc_ichg_values),\n\t\t\t\t\t    bdi->ichg);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tif (bdi->vreg) {\n\t\tret = bq24190_set_field_val(bdi, BQ24190_REG_CVC,\n\t\t\t\t\t    BQ24190_REG_CVC_VREG_MASK,\n\t\t\t\t\t    BQ24190_REG_CVC_VREG_SHIFT,\n\t\t\t\t\t    bq24190_cvc_vreg_values,\n\t\t\t\t\t    ARRAY_SIZE(bq24190_cvc_vreg_values),\n\t\t\t\t\t    bdi->vreg);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int bq24190_register_reset(struct bq24190_dev_info *bdi)\n{\n\tint ret, limit = 100;\n\tu8 v;\n\n\t/*\n\t * This prop. can be passed on device instantiation from platform code:\n\t * struct property_entry pe[] =\n\t *   { PROPERTY_ENTRY_BOOL(\"disable-reset\"), ... };\n\t * struct i2c_board_info bi =\n\t *   { .type = \"bq24190\", .addr = 0x6b, .properties = pe, .irq = irq };\n\t * struct i2c_adapter ad = { ... };\n\t * i2c_add_adapter(&ad);\n\t * i2c_new_client_device(&ad, &bi);\n\t */\n\tif (device_property_read_bool(bdi->dev, \"disable-reset\"))\n\t\treturn 0;\n\n\t/* Reset the registers */\n\tret = bq24190_write_mask(bdi, BQ24190_REG_POC,\n\t\t\tBQ24190_REG_POC_RESET_MASK,\n\t\t\tBQ24190_REG_POC_RESET_SHIFT,\n\t\t\t0x1);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t/* Reset bit will be cleared by hardware so poll until it is */\n\tdo {\n\t\tret = bq24190_read_mask(bdi, BQ24190_REG_POC,\n\t\t\t\tBQ24190_REG_POC_RESET_MASK,\n\t\t\t\tBQ24190_REG_POC_RESET_SHIFT,\n\t\t\t\t&v);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tif (v == 0)\n\t\t\treturn 0;\n\n\t\tusleep_range(100, 200);\n\t} while (--limit);\n\n\treturn -EIO;\n}\n\n/* Charger power supply property routines */\n\nstatic int bq24190_charger_get_charge_type(struct bq24190_dev_info *bdi,\n\t\tunion power_supply_propval *val)\n{\n\tu8 v;\n\tint type, ret;\n\n\tret = bq24190_read_mask(bdi, BQ24190_REG_POC,\n\t\t\tBQ24190_REG_POC_CHG_CONFIG_MASK,\n\t\t\tBQ24190_REG_POC_CHG_CONFIG_SHIFT,\n\t\t\t&v);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t/* If POC[CHG_CONFIG] (REG01[5:4]) == 0, charge is disabled */\n\tif (!v) {\n\t\ttype = POWER_SUPPLY_CHARGE_TYPE_NONE;\n\t} else {\n\t\tret = bq24190_read_mask(bdi, BQ24190_REG_CCC,\n\t\t\t\tBQ24190_REG_CCC_FORCE_20PCT_MASK,\n\t\t\t\tBQ24190_REG_CCC_FORCE_20PCT_SHIFT,\n\t\t\t\t&v);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\ttype = (v) ? POWER_SUPPLY_CHARGE_TYPE_TRICKLE :\n\t\t\t     POWER_SUPPLY_CHARGE_TYPE_FAST;\n\t}\n\n\tval->intval = type;\n\n\treturn 0;\n}\n\nstatic int bq24190_charger_set_charge_type(struct bq24190_dev_info *bdi,\n\t\tconst union power_supply_propval *val)\n{\n\tu8 chg_config, force_20pct, en_term;\n\tint ret;\n\n\t/*\n\t * According to the \"Termination when REG02[0] = 1\" section of\n\t * the bq24190 manual, the trickle charge could be less than the\n\t * termination current so it recommends turning off the termination\n\t * function.\n\t *\n\t * Note: AFAICT from the datasheet, the user will have to manually\n\t * turn off the charging when in 20% mode.  If its not turned off,\n\t * there could be battery damage.  So, use this mode at your own risk.\n\t */\n\tswitch (val->intval) {\n\tcase POWER_SUPPLY_CHARGE_TYPE_NONE:\n\t\tchg_config = 0x0;\n\t\tbreak;\n\tcase POWER_SUPPLY_CHARGE_TYPE_TRICKLE:\n\t\tchg_config = 0x1;\n\t\tforce_20pct = 0x1;\n\t\ten_term = 0x0;\n\t\tbreak;\n\tcase POWER_SUPPLY_CHARGE_TYPE_FAST:\n\t\tchg_config = 0x1;\n\t\tforce_20pct = 0x0;\n\t\ten_term = 0x1;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tbdi->charge_type = val->intval;\n\t/*\n\t * If the 5V Vbus boost regulator is enabled delay setting\n\t * the charge-type until its gets disabled.\n\t */\n\tif (bdi->otg_vbus_enabled)\n\t\treturn 0;\n\n\tif (chg_config) { /* Enabling the charger */\n\t\tret = bq24190_write_mask(bdi, BQ24190_REG_CCC,\n\t\t\t\tBQ24190_REG_CCC_FORCE_20PCT_MASK,\n\t\t\t\tBQ24190_REG_CCC_FORCE_20PCT_SHIFT,\n\t\t\t\tforce_20pct);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tret = bq24190_write_mask(bdi, BQ24190_REG_CTTC,\n\t\t\t\tBQ24190_REG_CTTC_EN_TERM_MASK,\n\t\t\t\tBQ24190_REG_CTTC_EN_TERM_SHIFT,\n\t\t\t\ten_term);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn bq24190_write_mask(bdi, BQ24190_REG_POC,\n\t\t\tBQ24190_REG_POC_CHG_CONFIG_MASK,\n\t\t\tBQ24190_REG_POC_CHG_CONFIG_SHIFT, chg_config);\n}\n\nstatic int bq24190_charger_get_health(struct bq24190_dev_info *bdi,\n\t\tunion power_supply_propval *val)\n{\n\tu8 v;\n\tint health;\n\n\tmutex_lock(&bdi->f_reg_lock);\n\tv = bdi->f_reg;\n\tmutex_unlock(&bdi->f_reg_lock);\n\n\tif (v & BQ24190_REG_F_NTC_FAULT_MASK) {\n\t\tswitch (v >> BQ24190_REG_F_NTC_FAULT_SHIFT & 0x7) {\n\t\tcase 0x1: /* TS1  Cold */\n\t\tcase 0x3: /* TS2  Cold */\n\t\tcase 0x5: /* Both Cold */\n\t\t\thealth = POWER_SUPPLY_HEALTH_COLD;\n\t\t\tbreak;\n\t\tcase 0x2: /* TS1  Hot */\n\t\tcase 0x4: /* TS2  Hot */\n\t\tcase 0x6: /* Both Hot */\n\t\t\thealth = POWER_SUPPLY_HEALTH_OVERHEAT;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\thealth = POWER_SUPPLY_HEALTH_UNKNOWN;\n\t\t}\n\t} else if (v & BQ24190_REG_F_BAT_FAULT_MASK) {\n\t\thealth = POWER_SUPPLY_HEALTH_OVERVOLTAGE;\n\t} else if (v & BQ24190_REG_F_CHRG_FAULT_MASK) {\n\t\tswitch (v >> BQ24190_REG_F_CHRG_FAULT_SHIFT & 0x3) {\n\t\tcase 0x1: /* Input Fault (VBUS OVP or VBAT<VBUS<3.8V) */\n\t\t\t/*\n\t\t\t * This could be over-voltage or under-voltage\n\t\t\t * and there's no way to tell which.  Instead\n\t\t\t * of looking foolish and returning 'OVERVOLTAGE'\n\t\t\t * when its really under-voltage, just return\n\t\t\t * 'UNSPEC_FAILURE'.\n\t\t\t */\n\t\t\thealth = POWER_SUPPLY_HEALTH_UNSPEC_FAILURE;\n\t\t\tbreak;\n\t\tcase 0x2: /* Thermal Shutdown */\n\t\t\thealth = POWER_SUPPLY_HEALTH_OVERHEAT;\n\t\t\tbreak;\n\t\tcase 0x3: /* Charge Safety Timer Expiration */\n\t\t\thealth = POWER_SUPPLY_HEALTH_SAFETY_TIMER_EXPIRE;\n\t\t\tbreak;\n\t\tdefault:  /* prevent compiler warning */\n\t\t\thealth = -1;\n\t\t}\n\t} else if (v & BQ24190_REG_F_BOOST_FAULT_MASK) {\n\t\t/*\n\t\t * This could be over-current or over-voltage but there's\n\t\t * no way to tell which.  Return 'OVERVOLTAGE' since there\n\t\t * isn't an 'OVERCURRENT' value defined that we can return\n\t\t * even if it was over-current.\n\t\t */\n\t\thealth = POWER_SUPPLY_HEALTH_OVERVOLTAGE;\n\t} else {\n\t\thealth = POWER_SUPPLY_HEALTH_GOOD;\n\t}\n\n\tval->intval = health;\n\n\treturn 0;\n}\n\nstatic int bq24190_charger_get_online(struct bq24190_dev_info *bdi,\n\t\tunion power_supply_propval *val)\n{\n\tu8 pg_stat, batfet_disable;\n\tint ret;\n\n\tret = bq24190_read_mask(bdi, BQ24190_REG_SS,\n\t\t\tBQ24190_REG_SS_PG_STAT_MASK,\n\t\t\tBQ24190_REG_SS_PG_STAT_SHIFT, &pg_stat);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = bq24190_read_mask(bdi, BQ24190_REG_MOC,\n\t\t\tBQ24190_REG_MOC_BATFET_DISABLE_MASK,\n\t\t\tBQ24190_REG_MOC_BATFET_DISABLE_SHIFT, &batfet_disable);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tval->intval = pg_stat && !batfet_disable;\n\n\treturn 0;\n}\n\nstatic int bq24190_battery_set_online(struct bq24190_dev_info *bdi,\n\t\t\t\t      const union power_supply_propval *val);\nstatic int bq24190_battery_get_status(struct bq24190_dev_info *bdi,\n\t\t\t\t      union power_supply_propval *val);\nstatic int bq24190_battery_get_temp_alert_max(struct bq24190_dev_info *bdi,\n\t\t\t\t\t      union power_supply_propval *val);\nstatic int bq24190_battery_set_temp_alert_max(struct bq24190_dev_info *bdi,\n\t\t\t\t\t      const union power_supply_propval *val);\n\nstatic int bq24190_charger_set_online(struct bq24190_dev_info *bdi,\n\t\t\t\t      const union power_supply_propval *val)\n{\n\treturn bq24190_battery_set_online(bdi, val);\n}\n\nstatic int bq24190_charger_get_status(struct bq24190_dev_info *bdi,\n\t\t\t\t      union power_supply_propval *val)\n{\n\treturn bq24190_battery_get_status(bdi, val);\n}\n\nstatic int bq24190_charger_get_temp_alert_max(struct bq24190_dev_info *bdi,\n\t\t\t\t\t      union power_supply_propval *val)\n{\n\treturn bq24190_battery_get_temp_alert_max(bdi, val);\n}\n\nstatic int bq24190_charger_set_temp_alert_max(struct bq24190_dev_info *bdi,\n\t\t\t\t\t      const union power_supply_propval *val)\n{\n\treturn bq24190_battery_set_temp_alert_max(bdi, val);\n}\n\nstatic int bq24190_charger_get_precharge(struct bq24190_dev_info *bdi,\n\t\tunion power_supply_propval *val)\n{\n\tu8 v;\n\tint ret;\n\n\tret = bq24190_read_mask(bdi, BQ24190_REG_PCTCC,\n\t\t\tBQ24190_REG_PCTCC_IPRECHG_MASK,\n\t\t\tBQ24190_REG_PCTCC_IPRECHG_SHIFT, &v);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tval->intval = ++v * 128 * 1000;\n\treturn 0;\n}\n\nstatic int bq24190_charger_get_charge_term(struct bq24190_dev_info *bdi,\n\t\tunion power_supply_propval *val)\n{\n\tu8 v;\n\tint ret;\n\n\tret = bq24190_read_mask(bdi, BQ24190_REG_PCTCC,\n\t\t\tBQ24190_REG_PCTCC_ITERM_MASK,\n\t\t\tBQ24190_REG_PCTCC_ITERM_SHIFT, &v);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tval->intval = ++v * 128 * 1000;\n\treturn 0;\n}\n\nstatic int bq24190_charger_get_current(struct bq24190_dev_info *bdi,\n\t\tunion power_supply_propval *val)\n{\n\tu8 v;\n\tint curr, ret;\n\n\tret = bq24190_get_field_val(bdi, BQ24190_REG_CCC,\n\t\t\tBQ24190_REG_CCC_ICHG_MASK, BQ24190_REG_CCC_ICHG_SHIFT,\n\t\t\tbq24190_ccc_ichg_values,\n\t\t\tARRAY_SIZE(bq24190_ccc_ichg_values), &curr);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = bq24190_read_mask(bdi, BQ24190_REG_CCC,\n\t\t\tBQ24190_REG_CCC_FORCE_20PCT_MASK,\n\t\t\tBQ24190_REG_CCC_FORCE_20PCT_SHIFT, &v);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t/* If FORCE_20PCT is enabled, then current is 20% of ICHG value */\n\tif (v)\n\t\tcurr /= 5;\n\n\tval->intval = curr;\n\treturn 0;\n}\n\nstatic int bq24190_charger_set_current(struct bq24190_dev_info *bdi,\n\t\tconst union power_supply_propval *val)\n{\n\tu8 v;\n\tint ret, curr = val->intval;\n\n\tret = bq24190_read_mask(bdi, BQ24190_REG_CCC,\n\t\t\tBQ24190_REG_CCC_FORCE_20PCT_MASK,\n\t\t\tBQ24190_REG_CCC_FORCE_20PCT_SHIFT, &v);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t/* If FORCE_20PCT is enabled, have to multiply value passed in by 5 */\n\tif (v)\n\t\tcurr *= 5;\n\n\tif (curr > bdi->ichg_max)\n\t\treturn -EINVAL;\n\n\tret = bq24190_set_field_val(bdi, BQ24190_REG_CCC,\n\t\t\tBQ24190_REG_CCC_ICHG_MASK, BQ24190_REG_CCC_ICHG_SHIFT,\n\t\t\tbq24190_ccc_ichg_values,\n\t\t\tARRAY_SIZE(bq24190_ccc_ichg_values), curr);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tbdi->ichg = curr;\n\n\treturn 0;\n}\n\nstatic int bq24190_charger_get_voltage(struct bq24190_dev_info *bdi,\n\t\tunion power_supply_propval *val)\n{\n\tint voltage, ret;\n\n\tret = bq24190_get_field_val(bdi, BQ24190_REG_CVC,\n\t\t\tBQ24190_REG_CVC_VREG_MASK, BQ24190_REG_CVC_VREG_SHIFT,\n\t\t\tbq24190_cvc_vreg_values,\n\t\t\tARRAY_SIZE(bq24190_cvc_vreg_values), &voltage);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tval->intval = voltage;\n\treturn 0;\n}\n\nstatic int bq24190_charger_set_voltage(struct bq24190_dev_info *bdi,\n\t\tconst union power_supply_propval *val)\n{\n\tint ret;\n\n\tif (val->intval > bdi->vreg_max)\n\t\treturn -EINVAL;\n\n\tret = bq24190_set_field_val(bdi, BQ24190_REG_CVC,\n\t\t\tBQ24190_REG_CVC_VREG_MASK, BQ24190_REG_CVC_VREG_SHIFT,\n\t\t\tbq24190_cvc_vreg_values,\n\t\t\tARRAY_SIZE(bq24190_cvc_vreg_values), val->intval);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tbdi->vreg = val->intval;\n\n\treturn 0;\n}\n\nstatic int bq24190_charger_get_iinlimit(struct bq24190_dev_info *bdi,\n\t\tunion power_supply_propval *val)\n{\n\tint iinlimit, ret;\n\n\tret = bq24190_get_field_val(bdi, BQ24190_REG_ISC,\n\t\t\tBQ24190_REG_ISC_IINLIM_MASK,\n\t\t\tBQ24190_REG_ISC_IINLIM_SHIFT,\n\t\t\tbq24190_isc_iinlim_values,\n\t\t\tARRAY_SIZE(bq24190_isc_iinlim_values), &iinlimit);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tval->intval = iinlimit;\n\treturn 0;\n}\n\nstatic int bq24190_charger_set_iinlimit(struct bq24190_dev_info *bdi,\n\t\tconst union power_supply_propval *val)\n{\n\treturn bq24190_set_field_val(bdi, BQ24190_REG_ISC,\n\t\t\tBQ24190_REG_ISC_IINLIM_MASK,\n\t\t\tBQ24190_REG_ISC_IINLIM_SHIFT,\n\t\t\tbq24190_isc_iinlim_values,\n\t\t\tARRAY_SIZE(bq24190_isc_iinlim_values), val->intval);\n}\n\nstatic int bq24190_charger_get_property(struct power_supply *psy,\n\t\tenum power_supply_property psp, union power_supply_propval *val)\n{\n\tstruct bq24190_dev_info *bdi = power_supply_get_drvdata(psy);\n\tint ret;\n\n\tdev_dbg(bdi->dev, \"prop: %d\\n\", psp);\n\n\tret = pm_runtime_resume_and_get(bdi->dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tswitch (psp) {\n\tcase POWER_SUPPLY_PROP_CHARGE_TYPE:\n\t\tret = bq24190_charger_get_charge_type(bdi, val);\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_HEALTH:\n\t\tret = bq24190_charger_get_health(bdi, val);\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_ONLINE:\n\t\tret = bq24190_charger_get_online(bdi, val);\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_STATUS:\n\t\tret = bq24190_charger_get_status(bdi, val);\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_TEMP_ALERT_MAX:\n\t\tret =  bq24190_charger_get_temp_alert_max(bdi, val);\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_PRECHARGE_CURRENT:\n\t\tret = bq24190_charger_get_precharge(bdi, val);\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_CHARGE_TERM_CURRENT:\n\t\tret = bq24190_charger_get_charge_term(bdi, val);\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT:\n\t\tret = bq24190_charger_get_current(bdi, val);\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT_MAX:\n\t\tval->intval = bdi->ichg_max;\n\t\tret = 0;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE:\n\t\tret = bq24190_charger_get_voltage(bdi, val);\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE_MAX:\n\t\tval->intval = bdi->vreg_max;\n\t\tret = 0;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_INPUT_CURRENT_LIMIT:\n\t\tret = bq24190_charger_get_iinlimit(bdi, val);\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_SCOPE:\n\t\tval->intval = POWER_SUPPLY_SCOPE_SYSTEM;\n\t\tret = 0;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_MODEL_NAME:\n\t\tval->strval = bdi->model_name;\n\t\tret = 0;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_MANUFACTURER:\n\t\tval->strval = BQ24190_MANUFACTURER;\n\t\tret = 0;\n\t\tbreak;\n\tdefault:\n\t\tret = -ENODATA;\n\t}\n\n\tpm_runtime_mark_last_busy(bdi->dev);\n\tpm_runtime_put_autosuspend(bdi->dev);\n\n\treturn ret;\n}\n\nstatic int bq24190_charger_set_property(struct power_supply *psy,\n\t\tenum power_supply_property psp,\n\t\tconst union power_supply_propval *val)\n{\n\tstruct bq24190_dev_info *bdi = power_supply_get_drvdata(psy);\n\tint ret;\n\n\tdev_dbg(bdi->dev, \"prop: %d\\n\", psp);\n\n\tret = pm_runtime_resume_and_get(bdi->dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tswitch (psp) {\n\tcase POWER_SUPPLY_PROP_ONLINE:\n\t\tret = bq24190_charger_set_online(bdi, val);\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_TEMP_ALERT_MAX:\n\t\tret = bq24190_charger_set_temp_alert_max(bdi, val);\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_CHARGE_TYPE:\n\t\tret = bq24190_charger_set_charge_type(bdi, val);\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT:\n\t\tret = bq24190_charger_set_current(bdi, val);\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE:\n\t\tret = bq24190_charger_set_voltage(bdi, val);\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_INPUT_CURRENT_LIMIT:\n\t\tret = bq24190_charger_set_iinlimit(bdi, val);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\n\tpm_runtime_mark_last_busy(bdi->dev);\n\tpm_runtime_put_autosuspend(bdi->dev);\n\n\treturn ret;\n}\n\nstatic int bq24190_charger_property_is_writeable(struct power_supply *psy,\n\t\tenum power_supply_property psp)\n{\n\tswitch (psp) {\n\tcase POWER_SUPPLY_PROP_ONLINE:\n\tcase POWER_SUPPLY_PROP_TEMP_ALERT_MAX:\n\tcase POWER_SUPPLY_PROP_CHARGE_TYPE:\n\tcase POWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT:\n\tcase POWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE:\n\tcase POWER_SUPPLY_PROP_INPUT_CURRENT_LIMIT:\n\t\treturn 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic void bq24190_input_current_limit_work(struct work_struct *work)\n{\n\tstruct bq24190_dev_info *bdi =\n\t\tcontainer_of(work, struct bq24190_dev_info,\n\t\t\t     input_current_limit_work.work);\n\tunion power_supply_propval val;\n\tint ret;\n\n\tret = power_supply_get_property_from_supplier(bdi->charger,\n\t\t\t\t\t\t      POWER_SUPPLY_PROP_CURRENT_MAX,\n\t\t\t\t\t\t      &val);\n\tif (ret)\n\t\treturn;\n\n\tbq24190_charger_set_property(bdi->charger,\n\t\t\t\t     POWER_SUPPLY_PROP_INPUT_CURRENT_LIMIT,\n\t\t\t\t     &val);\n}\n\n/* Sync the input-current-limit with our parent supply (if we have one) */\nstatic void bq24190_charger_external_power_changed(struct power_supply *psy)\n{\n\tstruct bq24190_dev_info *bdi = power_supply_get_drvdata(psy);\n\n\t/*\n\t * The Power-Good detection may take up to 220ms, sometimes\n\t * the external charger detection is quicker, and the bq24190 will\n\t * reset to iinlim based on its own charger detection (which is not\n\t * hooked up when using external charger detection) resulting in a\n\t * too low default 500mA iinlim. Delay setting the input-current-limit\n\t * for 300ms to avoid this.\n\t */\n\tqueue_delayed_work(system_wq, &bdi->input_current_limit_work,\n\t\t\t   msecs_to_jiffies(300));\n}\n\nstatic enum power_supply_property bq24190_charger_properties[] = {\n\tPOWER_SUPPLY_PROP_CHARGE_TYPE,\n\tPOWER_SUPPLY_PROP_HEALTH,\n\tPOWER_SUPPLY_PROP_ONLINE,\n\tPOWER_SUPPLY_PROP_STATUS,\n\tPOWER_SUPPLY_PROP_TEMP_ALERT_MAX,\n\tPOWER_SUPPLY_PROP_PRECHARGE_CURRENT,\n\tPOWER_SUPPLY_PROP_CHARGE_TERM_CURRENT,\n\tPOWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT,\n\tPOWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT_MAX,\n\tPOWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE,\n\tPOWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE_MAX,\n\tPOWER_SUPPLY_PROP_INPUT_CURRENT_LIMIT,\n\tPOWER_SUPPLY_PROP_SCOPE,\n\tPOWER_SUPPLY_PROP_MODEL_NAME,\n\tPOWER_SUPPLY_PROP_MANUFACTURER,\n};\n\nstatic char *bq24190_charger_supplied_to[] = {\n\t\"main-battery\",\n};\n\nstatic const struct power_supply_desc bq24190_charger_desc = {\n\t.name\t\t\t= \"bq24190-charger\",\n\t.type\t\t\t= POWER_SUPPLY_TYPE_USB,\n\t.properties\t\t= bq24190_charger_properties,\n\t.num_properties\t\t= ARRAY_SIZE(bq24190_charger_properties),\n\t.get_property\t\t= bq24190_charger_get_property,\n\t.set_property\t\t= bq24190_charger_set_property,\n\t.property_is_writeable\t= bq24190_charger_property_is_writeable,\n\t.external_power_changed\t= bq24190_charger_external_power_changed,\n};\n\n/* Battery power supply property routines */\n\nstatic int bq24190_battery_get_status(struct bq24190_dev_info *bdi,\n\t\tunion power_supply_propval *val)\n{\n\tu8 ss_reg, chrg_fault;\n\tint status, ret;\n\n\tmutex_lock(&bdi->f_reg_lock);\n\tchrg_fault = bdi->f_reg;\n\tmutex_unlock(&bdi->f_reg_lock);\n\n\tchrg_fault &= BQ24190_REG_F_CHRG_FAULT_MASK;\n\tchrg_fault >>= BQ24190_REG_F_CHRG_FAULT_SHIFT;\n\n\tret = bq24190_read(bdi, BQ24190_REG_SS, &ss_reg);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t/*\n\t * The battery must be discharging when any of these are true:\n\t * - there is no good power source;\n\t * - there is a charge fault.\n\t * Could also be discharging when in \"supplement mode\" but\n\t * there is no way to tell when its in that mode.\n\t */\n\tif (!(ss_reg & BQ24190_REG_SS_PG_STAT_MASK) || chrg_fault) {\n\t\tstatus = POWER_SUPPLY_STATUS_DISCHARGING;\n\t} else {\n\t\tss_reg &= BQ24190_REG_SS_CHRG_STAT_MASK;\n\t\tss_reg >>= BQ24190_REG_SS_CHRG_STAT_SHIFT;\n\n\t\tswitch (ss_reg) {\n\t\tcase 0x0: /* Not Charging */\n\t\t\tstatus = POWER_SUPPLY_STATUS_NOT_CHARGING;\n\t\t\tbreak;\n\t\tcase 0x1: /* Pre-charge */\n\t\tcase 0x2: /* Fast Charging */\n\t\t\tstatus = POWER_SUPPLY_STATUS_CHARGING;\n\t\t\tbreak;\n\t\tcase 0x3: /* Charge Termination Done */\n\t\t\tstatus = POWER_SUPPLY_STATUS_FULL;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = -EIO;\n\t\t}\n\t}\n\n\tif (!ret)\n\t\tval->intval = status;\n\n\treturn ret;\n}\n\nstatic int bq24190_battery_get_health(struct bq24190_dev_info *bdi,\n\t\tunion power_supply_propval *val)\n{\n\tu8 v;\n\tint health;\n\n\tmutex_lock(&bdi->f_reg_lock);\n\tv = bdi->f_reg;\n\tmutex_unlock(&bdi->f_reg_lock);\n\n\tif (v & BQ24190_REG_F_BAT_FAULT_MASK) {\n\t\thealth = POWER_SUPPLY_HEALTH_OVERVOLTAGE;\n\t} else {\n\t\tv &= BQ24190_REG_F_NTC_FAULT_MASK;\n\t\tv >>= BQ24190_REG_F_NTC_FAULT_SHIFT;\n\n\t\tswitch (v) {\n\t\tcase 0x0: /* Normal */\n\t\t\thealth = POWER_SUPPLY_HEALTH_GOOD;\n\t\t\tbreak;\n\t\tcase 0x1: /* TS1 Cold */\n\t\tcase 0x3: /* TS2 Cold */\n\t\tcase 0x5: /* Both Cold */\n\t\t\thealth = POWER_SUPPLY_HEALTH_COLD;\n\t\t\tbreak;\n\t\tcase 0x2: /* TS1 Hot */\n\t\tcase 0x4: /* TS2 Hot */\n\t\tcase 0x6: /* Both Hot */\n\t\t\thealth = POWER_SUPPLY_HEALTH_OVERHEAT;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\thealth = POWER_SUPPLY_HEALTH_UNKNOWN;\n\t\t}\n\t}\n\n\tval->intval = health;\n\treturn 0;\n}\n\nstatic int bq24190_battery_get_online(struct bq24190_dev_info *bdi,\n\t\tunion power_supply_propval *val)\n{\n\tu8 batfet_disable;\n\tint ret;\n\n\tret = bq24190_read_mask(bdi, BQ24190_REG_MOC,\n\t\t\tBQ24190_REG_MOC_BATFET_DISABLE_MASK,\n\t\t\tBQ24190_REG_MOC_BATFET_DISABLE_SHIFT, &batfet_disable);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tval->intval = !batfet_disable;\n\treturn 0;\n}\n\nstatic int bq24190_battery_set_online(struct bq24190_dev_info *bdi,\n\t\tconst union power_supply_propval *val)\n{\n\treturn bq24190_write_mask(bdi, BQ24190_REG_MOC,\n\t\t\tBQ24190_REG_MOC_BATFET_DISABLE_MASK,\n\t\t\tBQ24190_REG_MOC_BATFET_DISABLE_SHIFT, !val->intval);\n}\n\nstatic int bq24190_battery_get_temp_alert_max(struct bq24190_dev_info *bdi,\n\t\tunion power_supply_propval *val)\n{\n\tint temp, ret;\n\n\tret = bq24190_get_field_val(bdi, BQ24190_REG_ICTRC,\n\t\t\tBQ24190_REG_ICTRC_TREG_MASK,\n\t\t\tBQ24190_REG_ICTRC_TREG_SHIFT,\n\t\t\tbq24190_ictrc_treg_values,\n\t\t\tARRAY_SIZE(bq24190_ictrc_treg_values), &temp);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tval->intval = temp;\n\treturn 0;\n}\n\nstatic int bq24190_battery_set_temp_alert_max(struct bq24190_dev_info *bdi,\n\t\tconst union power_supply_propval *val)\n{\n\treturn bq24190_set_field_val(bdi, BQ24190_REG_ICTRC,\n\t\t\tBQ24190_REG_ICTRC_TREG_MASK,\n\t\t\tBQ24190_REG_ICTRC_TREG_SHIFT,\n\t\t\tbq24190_ictrc_treg_values,\n\t\t\tARRAY_SIZE(bq24190_ictrc_treg_values), val->intval);\n}\n\nstatic int bq24190_battery_get_property(struct power_supply *psy,\n\t\tenum power_supply_property psp, union power_supply_propval *val)\n{\n\tstruct bq24190_dev_info *bdi = power_supply_get_drvdata(psy);\n\tint ret;\n\n\tdev_warn(bdi->dev, \"warning: /sys/class/power_supply/bq24190-battery is deprecated\\n\");\n\tdev_dbg(bdi->dev, \"prop: %d\\n\", psp);\n\n\tret = pm_runtime_resume_and_get(bdi->dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tswitch (psp) {\n\tcase POWER_SUPPLY_PROP_STATUS:\n\t\tret = bq24190_battery_get_status(bdi, val);\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_HEALTH:\n\t\tret = bq24190_battery_get_health(bdi, val);\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_ONLINE:\n\t\tret = bq24190_battery_get_online(bdi, val);\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_TECHNOLOGY:\n\t\t/* Could be Li-on or Li-polymer but no way to tell which */\n\t\tval->intval = POWER_SUPPLY_TECHNOLOGY_UNKNOWN;\n\t\tret = 0;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_TEMP_ALERT_MAX:\n\t\tret = bq24190_battery_get_temp_alert_max(bdi, val);\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_SCOPE:\n\t\tval->intval = POWER_SUPPLY_SCOPE_SYSTEM;\n\t\tret = 0;\n\t\tbreak;\n\tdefault:\n\t\tret = -ENODATA;\n\t}\n\n\tpm_runtime_mark_last_busy(bdi->dev);\n\tpm_runtime_put_autosuspend(bdi->dev);\n\n\treturn ret;\n}\n\nstatic int bq24190_battery_set_property(struct power_supply *psy,\n\t\tenum power_supply_property psp,\n\t\tconst union power_supply_propval *val)\n{\n\tstruct bq24190_dev_info *bdi = power_supply_get_drvdata(psy);\n\tint ret;\n\n\tdev_warn(bdi->dev, \"warning: /sys/class/power_supply/bq24190-battery is deprecated\\n\");\n\tdev_dbg(bdi->dev, \"prop: %d\\n\", psp);\n\n\tret = pm_runtime_resume_and_get(bdi->dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tswitch (psp) {\n\tcase POWER_SUPPLY_PROP_ONLINE:\n\t\tret = bq24190_battery_set_online(bdi, val);\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_TEMP_ALERT_MAX:\n\t\tret = bq24190_battery_set_temp_alert_max(bdi, val);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\n\tpm_runtime_mark_last_busy(bdi->dev);\n\tpm_runtime_put_autosuspend(bdi->dev);\n\n\treturn ret;\n}\n\nstatic int bq24190_battery_property_is_writeable(struct power_supply *psy,\n\t\tenum power_supply_property psp)\n{\n\tint ret;\n\n\tswitch (psp) {\n\tcase POWER_SUPPLY_PROP_ONLINE:\n\tcase POWER_SUPPLY_PROP_TEMP_ALERT_MAX:\n\t\tret = 1;\n\t\tbreak;\n\tdefault:\n\t\tret = 0;\n\t}\n\n\treturn ret;\n}\n\nstatic enum power_supply_property bq24190_battery_properties[] = {\n\tPOWER_SUPPLY_PROP_STATUS,\n\tPOWER_SUPPLY_PROP_HEALTH,\n\tPOWER_SUPPLY_PROP_ONLINE,\n\tPOWER_SUPPLY_PROP_TECHNOLOGY,\n\tPOWER_SUPPLY_PROP_TEMP_ALERT_MAX,\n\tPOWER_SUPPLY_PROP_SCOPE,\n};\n\nstatic const struct power_supply_desc bq24190_battery_desc = {\n\t.name\t\t\t= \"bq24190-battery\",\n\t.type\t\t\t= POWER_SUPPLY_TYPE_BATTERY,\n\t.properties\t\t= bq24190_battery_properties,\n\t.num_properties\t\t= ARRAY_SIZE(bq24190_battery_properties),\n\t.get_property\t\t= bq24190_battery_get_property,\n\t.set_property\t\t= bq24190_battery_set_property,\n\t.property_is_writeable\t= bq24190_battery_property_is_writeable,\n};\n\nstatic int bq24190_configure_usb_otg(struct bq24190_dev_info *bdi, u8 ss_reg)\n{\n\tbool otg_enabled;\n\tint ret;\n\n\totg_enabled = !!(ss_reg & BQ24190_REG_SS_VBUS_STAT_MASK);\n\tret = extcon_set_state_sync(bdi->edev, EXTCON_USB, otg_enabled);\n\tif (ret < 0)\n\t\tdev_err(bdi->dev, \"Can't set extcon state to %d: %d\\n\",\n\t\t\totg_enabled, ret);\n\n\treturn ret;\n}\n\nstatic void bq24190_check_status(struct bq24190_dev_info *bdi)\n{\n\tconst u8 battery_mask_ss = BQ24190_REG_SS_CHRG_STAT_MASK;\n\tconst u8 battery_mask_f = BQ24190_REG_F_BAT_FAULT_MASK\n\t\t\t\t| BQ24190_REG_F_NTC_FAULT_MASK;\n\tbool alert_charger = false, alert_battery = false;\n\tu8 ss_reg = 0, f_reg = 0;\n\tint i, ret;\n\n\tret = bq24190_read(bdi, BQ24190_REG_SS, &ss_reg);\n\tif (ret < 0) {\n\t\tdev_err(bdi->dev, \"Can't read SS reg: %d\\n\", ret);\n\t\treturn;\n\t}\n\n\ti = 0;\n\tdo {\n\t\tret = bq24190_read(bdi, BQ24190_REG_F, &f_reg);\n\t\tif (ret < 0) {\n\t\t\tdev_err(bdi->dev, \"Can't read F reg: %d\\n\", ret);\n\t\t\treturn;\n\t\t}\n\t} while (f_reg && ++i < 2);\n\n\t/* ignore over/under voltage fault after disconnect */\n\tif (f_reg == (1 << BQ24190_REG_F_CHRG_FAULT_SHIFT) &&\n\t    !(ss_reg & BQ24190_REG_SS_PG_STAT_MASK))\n\t\tf_reg = 0;\n\n\tif (f_reg != bdi->f_reg) {\n\t\tdev_warn(bdi->dev,\n\t\t\t\"Fault: boost %d, charge %d, battery %d, ntc %d\\n\",\n\t\t\t!!(f_reg & BQ24190_REG_F_BOOST_FAULT_MASK),\n\t\t\t!!(f_reg & BQ24190_REG_F_CHRG_FAULT_MASK),\n\t\t\t!!(f_reg & BQ24190_REG_F_BAT_FAULT_MASK),\n\t\t\t!!(f_reg & BQ24190_REG_F_NTC_FAULT_MASK));\n\n\t\tmutex_lock(&bdi->f_reg_lock);\n\t\tif ((bdi->f_reg & battery_mask_f) != (f_reg & battery_mask_f))\n\t\t\talert_battery = true;\n\t\tif ((bdi->f_reg & ~battery_mask_f) != (f_reg & ~battery_mask_f))\n\t\t\talert_charger = true;\n\t\tbdi->f_reg = f_reg;\n\t\tmutex_unlock(&bdi->f_reg_lock);\n\t}\n\n\tif (ss_reg != bdi->ss_reg) {\n\t\t/*\n\t\t * The device is in host mode so when PG_STAT goes from 1->0\n\t\t * (i.e., power removed) HIZ needs to be disabled.\n\t\t */\n\t\tif ((bdi->ss_reg & BQ24190_REG_SS_PG_STAT_MASK) &&\n\t\t\t\t!(ss_reg & BQ24190_REG_SS_PG_STAT_MASK)) {\n\t\t\tret = bq24190_write_mask(bdi, BQ24190_REG_ISC,\n\t\t\t\t\tBQ24190_REG_ISC_EN_HIZ_MASK,\n\t\t\t\t\tBQ24190_REG_ISC_EN_HIZ_SHIFT,\n\t\t\t\t\t0);\n\t\t\tif (ret < 0)\n\t\t\t\tdev_err(bdi->dev, \"Can't access ISC reg: %d\\n\",\n\t\t\t\t\tret);\n\t\t}\n\n\t\tif ((bdi->ss_reg & battery_mask_ss) != (ss_reg & battery_mask_ss))\n\t\t\talert_battery = true;\n\t\tif ((bdi->ss_reg & ~battery_mask_ss) != (ss_reg & ~battery_mask_ss))\n\t\t\talert_charger = true;\n\t\tbdi->ss_reg = ss_reg;\n\t}\n\n\tif (alert_charger || alert_battery) {\n\t\tpower_supply_changed(bdi->charger);\n\t\tbq24190_configure_usb_otg(bdi, ss_reg);\n\t}\n\tif (alert_battery && bdi->battery)\n\t\tpower_supply_changed(bdi->battery);\n\n\tdev_dbg(bdi->dev, \"ss_reg: 0x%02x, f_reg: 0x%02x\\n\", ss_reg, f_reg);\n}\n\nstatic irqreturn_t bq24190_irq_handler_thread(int irq, void *data)\n{\n\tstruct bq24190_dev_info *bdi = data;\n\tint error;\n\n\tbdi->irq_event = true;\n\terror = pm_runtime_resume_and_get(bdi->dev);\n\tif (error < 0) {\n\t\tdev_warn(bdi->dev, \"pm_runtime_get failed: %i\\n\", error);\n\t\treturn IRQ_NONE;\n\t}\n\tbq24190_check_status(bdi);\n\tpm_runtime_mark_last_busy(bdi->dev);\n\tpm_runtime_put_autosuspend(bdi->dev);\n\tbdi->irq_event = false;\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int bq24190_hw_init(struct bq24190_dev_info *bdi)\n{\n\tu8 v;\n\tint ret;\n\n\t/* First check that the device really is what its supposed to be */\n\tret = bq24190_read_mask(bdi, BQ24190_REG_VPRS,\n\t\t\tBQ24190_REG_VPRS_PN_MASK,\n\t\t\tBQ24190_REG_VPRS_PN_SHIFT,\n\t\t\t&v);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tswitch (v) {\n\tcase BQ24190_REG_VPRS_PN_24190:\n\tcase BQ24190_REG_VPRS_PN_24192:\n\tcase BQ24190_REG_VPRS_PN_24192I:\n\t\tbreak;\n\tdefault:\n\t\tdev_err(bdi->dev, \"Error unknown model: 0x%02x\\n\", v);\n\t\treturn -ENODEV;\n\t}\n\n\tret = bq24190_register_reset(bdi);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = bq24190_set_config(bdi);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn bq24190_read(bdi, BQ24190_REG_SS, &bdi->ss_reg);\n}\n\nstatic int bq24190_get_config(struct bq24190_dev_info *bdi)\n{\n\tconst char * const s = \"ti,system-minimum-microvolt\";\n\tstruct power_supply_battery_info *info;\n\tint v, idx;\n\n\tidx = ARRAY_SIZE(bq24190_ccc_ichg_values) - 1;\n\tbdi->ichg_max = bq24190_ccc_ichg_values[idx];\n\n\tidx = ARRAY_SIZE(bq24190_cvc_vreg_values) - 1;\n\tbdi->vreg_max = bq24190_cvc_vreg_values[idx];\n\n\tif (device_property_read_u32(bdi->dev, s, &v) == 0) {\n\t\tv /= 1000;\n\t\tif (v >= BQ24190_REG_POC_SYS_MIN_MIN\n\t\t && v <= BQ24190_REG_POC_SYS_MIN_MAX)\n\t\t\tbdi->sys_min = v;\n\t\telse\n\t\t\tdev_warn(bdi->dev, \"invalid value for %s: %u\\n\", s, v);\n\t}\n\n\tif (!power_supply_get_battery_info(bdi->charger, &info)) {\n\t\tv = info->precharge_current_ua / 1000;\n\t\tif (v >= BQ24190_REG_PCTCC_IPRECHG_MIN\n\t\t && v <= BQ24190_REG_PCTCC_IPRECHG_MAX)\n\t\t\tbdi->iprechg = v;\n\t\telse\n\t\t\tdev_warn(bdi->dev, \"invalid value for battery:precharge-current-microamp: %d\\n\",\n\t\t\t\t v);\n\n\t\tv = info->charge_term_current_ua / 1000;\n\t\tif (v >= BQ24190_REG_PCTCC_ITERM_MIN\n\t\t && v <= BQ24190_REG_PCTCC_ITERM_MAX)\n\t\t\tbdi->iterm = v;\n\t\telse\n\t\t\tdev_warn(bdi->dev, \"invalid value for battery:charge-term-current-microamp: %d\\n\",\n\t\t\t\t v);\n\n\t\t/* These are optional, so no warning when not set */\n\t\tv = info->constant_charge_current_max_ua;\n\t\tif (v >= bq24190_ccc_ichg_values[0] && v <= bdi->ichg_max)\n\t\t\tbdi->ichg = bdi->ichg_max = v;\n\n\t\tv = info->constant_charge_voltage_max_uv;\n\t\tif (v >= bq24190_cvc_vreg_values[0] && v <= bdi->vreg_max)\n\t\t\tbdi->vreg = bdi->vreg_max = v;\n\t}\n\n\treturn 0;\n}\n\nstatic int bq24190_probe(struct i2c_client *client)\n{\n\tconst struct i2c_device_id *id = i2c_client_get_device_id(client);\n\tstruct i2c_adapter *adapter = client->adapter;\n\tstruct device *dev = &client->dev;\n\tstruct power_supply_config charger_cfg = {}, battery_cfg = {};\n\tstruct bq24190_dev_info *bdi;\n\tint ret;\n\n\tif (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE_DATA)) {\n\t\tdev_err(dev, \"No support for SMBUS_BYTE_DATA\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tbdi = devm_kzalloc(dev, sizeof(*bdi), GFP_KERNEL);\n\tif (!bdi) {\n\t\tdev_err(dev, \"Can't alloc bdi struct\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tbdi->client = client;\n\tbdi->dev = dev;\n\tstrncpy(bdi->model_name, id->name, I2C_NAME_SIZE);\n\tmutex_init(&bdi->f_reg_lock);\n\tbdi->charge_type = POWER_SUPPLY_CHARGE_TYPE_FAST;\n\tbdi->f_reg = 0;\n\tbdi->ss_reg = BQ24190_REG_SS_VBUS_STAT_MASK; /* impossible state */\n\tINIT_DELAYED_WORK(&bdi->input_current_limit_work,\n\t\t\t  bq24190_input_current_limit_work);\n\n\ti2c_set_clientdata(client, bdi);\n\n\tif (client->irq <= 0) {\n\t\tdev_err(dev, \"Can't get irq info\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tbdi->edev = devm_extcon_dev_allocate(dev, bq24190_usb_extcon_cable);\n\tif (IS_ERR(bdi->edev))\n\t\treturn PTR_ERR(bdi->edev);\n\n\tret = devm_extcon_dev_register(dev, bdi->edev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tpm_runtime_enable(dev);\n\tpm_runtime_use_autosuspend(dev);\n\tpm_runtime_set_autosuspend_delay(dev, 600);\n\tret = pm_runtime_get_sync(dev);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"pm_runtime_get failed: %i\\n\", ret);\n\t\tgoto out_pmrt;\n\t}\n\n#ifdef CONFIG_SYSFS\n\tbq24190_sysfs_init_attrs();\n\tcharger_cfg.attr_grp = bq24190_sysfs_groups;\n#endif\n\n\tcharger_cfg.drv_data = bdi;\n\tcharger_cfg.of_node = dev->of_node;\n\tcharger_cfg.supplied_to = bq24190_charger_supplied_to;\n\tcharger_cfg.num_supplicants = ARRAY_SIZE(bq24190_charger_supplied_to);\n\tbdi->charger = power_supply_register(dev, &bq24190_charger_desc,\n\t\t\t\t\t\t&charger_cfg);\n\tif (IS_ERR(bdi->charger)) {\n\t\tdev_err(dev, \"Can't register charger\\n\");\n\t\tret = PTR_ERR(bdi->charger);\n\t\tgoto out_pmrt;\n\t}\n\n\t/* the battery class is deprecated and will be removed. */\n\t/* in the interim, this property hides it.              */\n\tif (!device_property_read_bool(dev, \"omit-battery-class\")) {\n\t\tbattery_cfg.drv_data = bdi;\n\t\tbdi->battery = power_supply_register(dev, &bq24190_battery_desc,\n\t\t\t\t\t\t     &battery_cfg);\n\t\tif (IS_ERR(bdi->battery)) {\n\t\t\tdev_err(dev, \"Can't register battery\\n\");\n\t\t\tret = PTR_ERR(bdi->battery);\n\t\t\tgoto out_charger;\n\t\t}\n\t}\n\n\tret = bq24190_get_config(bdi);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Can't get devicetree config\\n\");\n\t\tgoto out_charger;\n\t}\n\n\tret = bq24190_hw_init(bdi);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Hardware init failed\\n\");\n\t\tgoto out_charger;\n\t}\n\n\tret = bq24190_configure_usb_otg(bdi, bdi->ss_reg);\n\tif (ret < 0)\n\t\tgoto out_charger;\n\n\tbdi->initialized = true;\n\n\tret = devm_request_threaded_irq(dev, client->irq, NULL,\n\t\t\tbq24190_irq_handler_thread,\n\t\t\tIRQF_TRIGGER_FALLING | IRQF_ONESHOT,\n\t\t\t\"bq24190-charger\", bdi);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Can't set up irq handler\\n\");\n\t\tgoto out_charger;\n\t}\n\n\tret = bq24190_register_vbus_regulator(bdi);\n\tif (ret < 0)\n\t\tgoto out_charger;\n\n\tenable_irq_wake(client->irq);\n\n\tpm_runtime_mark_last_busy(dev);\n\tpm_runtime_put_autosuspend(dev);\n\n\treturn 0;\n\nout_charger:\n\tif (!IS_ERR_OR_NULL(bdi->battery))\n\t\tpower_supply_unregister(bdi->battery);\n\tpower_supply_unregister(bdi->charger);\n\nout_pmrt:\n\tpm_runtime_put_sync(dev);\n\tpm_runtime_dont_use_autosuspend(dev);\n\tpm_runtime_disable(dev);\n\treturn ret;\n}\n\nstatic void bq24190_remove(struct i2c_client *client)\n{\n\tstruct bq24190_dev_info *bdi = i2c_get_clientdata(client);\n\tint error;\n\n\tcancel_delayed_work_sync(&bdi->input_current_limit_work);\n\terror = pm_runtime_resume_and_get(bdi->dev);\n\tif (error < 0)\n\t\tdev_warn(bdi->dev, \"pm_runtime_get failed: %i\\n\", error);\n\n\tbq24190_register_reset(bdi);\n\tif (bdi->battery)\n\t\tpower_supply_unregister(bdi->battery);\n\tpower_supply_unregister(bdi->charger);\n\tif (error >= 0)\n\t\tpm_runtime_put_sync(bdi->dev);\n\tpm_runtime_dont_use_autosuspend(bdi->dev);\n\tpm_runtime_disable(bdi->dev);\n}\n\nstatic void bq24190_shutdown(struct i2c_client *client)\n{\n\tstruct bq24190_dev_info *bdi = i2c_get_clientdata(client);\n\n\t/* Turn off 5V boost regulator on shutdown */\n\tbq24190_set_otg_vbus(bdi, false);\n}\n\nstatic __maybe_unused int bq24190_runtime_suspend(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct bq24190_dev_info *bdi = i2c_get_clientdata(client);\n\n\tif (!bdi->initialized)\n\t\treturn 0;\n\n\tdev_dbg(bdi->dev, \"%s\\n\", __func__);\n\n\treturn 0;\n}\n\nstatic __maybe_unused int bq24190_runtime_resume(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct bq24190_dev_info *bdi = i2c_get_clientdata(client);\n\n\tif (!bdi->initialized)\n\t\treturn 0;\n\n\tif (!bdi->irq_event) {\n\t\tdev_dbg(bdi->dev, \"checking events on possible wakeirq\\n\");\n\t\tbq24190_check_status(bdi);\n\t}\n\n\treturn 0;\n}\n\nstatic __maybe_unused int bq24190_pm_suspend(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct bq24190_dev_info *bdi = i2c_get_clientdata(client);\n\tint error;\n\n\terror = pm_runtime_resume_and_get(bdi->dev);\n\tif (error < 0)\n\t\tdev_warn(bdi->dev, \"pm_runtime_get failed: %i\\n\", error);\n\n\tbq24190_register_reset(bdi);\n\n\tif (error >= 0) {\n\t\tpm_runtime_mark_last_busy(bdi->dev);\n\t\tpm_runtime_put_autosuspend(bdi->dev);\n\t}\n\n\treturn 0;\n}\n\nstatic __maybe_unused int bq24190_pm_resume(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct bq24190_dev_info *bdi = i2c_get_clientdata(client);\n\tint error;\n\n\tbdi->f_reg = 0;\n\tbdi->ss_reg = BQ24190_REG_SS_VBUS_STAT_MASK; /* impossible state */\n\n\terror = pm_runtime_resume_and_get(bdi->dev);\n\tif (error < 0)\n\t\tdev_warn(bdi->dev, \"pm_runtime_get failed: %i\\n\", error);\n\n\tbq24190_register_reset(bdi);\n\tbq24190_set_config(bdi);\n\tbq24190_read(bdi, BQ24190_REG_SS, &bdi->ss_reg);\n\n\tif (error >= 0) {\n\t\tpm_runtime_mark_last_busy(bdi->dev);\n\t\tpm_runtime_put_autosuspend(bdi->dev);\n\t}\n\n\t/* Things may have changed while suspended so alert upper layer */\n\tpower_supply_changed(bdi->charger);\n\tif (bdi->battery)\n\t\tpower_supply_changed(bdi->battery);\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops bq24190_pm_ops = {\n\tSET_RUNTIME_PM_OPS(bq24190_runtime_suspend, bq24190_runtime_resume,\n\t\t\t   NULL)\n\tSET_SYSTEM_SLEEP_PM_OPS(bq24190_pm_suspend, bq24190_pm_resume)\n};\n\nstatic const struct i2c_device_id bq24190_i2c_ids[] = {\n\t{ \"bq24190\" },\n\t{ \"bq24192\" },\n\t{ \"bq24192i\" },\n\t{ \"bq24196\" },\n\t{ },\n};\nMODULE_DEVICE_TABLE(i2c, bq24190_i2c_ids);\n\nstatic const struct of_device_id bq24190_of_match[] = {\n\t{ .compatible = \"ti,bq24190\", },\n\t{ .compatible = \"ti,bq24192\", },\n\t{ .compatible = \"ti,bq24192i\", },\n\t{ .compatible = \"ti,bq24196\", },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, bq24190_of_match);\n\nstatic struct i2c_driver bq24190_driver = {\n\t.probe_new\t= bq24190_probe,\n\t.remove\t\t= bq24190_remove,\n\t.shutdown\t= bq24190_shutdown,\n\t.id_table\t= bq24190_i2c_ids,\n\t.driver = {\n\t\t.name\t\t= \"bq24190-charger\",\n\t\t.pm\t\t= &bq24190_pm_ops,\n\t\t.of_match_table\t= bq24190_of_match,\n\t},\n};\nmodule_i2c_driver(bq24190_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Mark A. Greer <mgreer@animalcreek.com>\");\nMODULE_DESCRIPTION(\"TI BQ24190 Charger Driver\");\n"], "filenames": ["drivers/power/supply/bq24190_charger.c"], "buggy_code_start_loc": [1908], "buggy_code_end_loc": [1908], "fixing_code_start_loc": [1909], "fixing_code_end_loc": [1910], "type": "CWE-416", "message": "An issue was discovered in the Linux kernel before 6.2.9. A use-after-free was found in bq24190_remove in drivers/power/supply/bq24190_charger.c. It could allow a local attacker to crash the system due to a race condition.", "other": {"cve": {"id": "CVE-2023-33288", "sourceIdentifier": "cve@mitre.org", "published": "2023-05-22T03:15:09.797", "lastModified": "2023-05-26T01:12:42.217", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An issue was discovered in the Linux kernel before 6.2.9. A use-after-free was found in bq24190_remove in drivers/power/supply/bq24190_charger.c. It could allow a local attacker to crash the system due to a race condition."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 4.7, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.0, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-416"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndExcluding": "6.2.9", "matchCriteriaId": "9DB8D56A-80A7-46E9-A9BD-100B7446E81A"}]}]}], "references": [{"url": "https://cdn.kernel.org/pub/linux/kernel/v6.x/ChangeLog-6.2.9", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch", "Release Notes"]}, {"url": "https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=47c29d69212911f50bdcdd0564b5999a559010d4", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/torvalds/linux/commit/47c29d69212911f50bdcdd0564b5999a559010d4", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://lore.kernel.org/all/CAHk-=whcaHLNpb7Mu_QX7ABwPgyRyfW-V8=v4Mv0S22fpjY4JQ@mail.gmail.com/", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch"]}, {"url": "https://lore.kernel.org/lkml/20230309174728.233732-1-zyytlz.wz@163.com/", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/47c29d69212911f50bdcdd0564b5999a559010d4"}}