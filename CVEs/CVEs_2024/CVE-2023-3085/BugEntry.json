{"buggy_code": ["// Copyright 2022 Jo-Philipp Wich <jo@mein.io>\n// Licensed to the public under the Apache License 2.0.\n\nimport { open, stat, glob, lsdir, unlink, basename } from 'fs';\nimport { striptags, entityencode } from 'html';\nimport { connect } from 'ubus';\nimport { cursor } from 'uci';\nimport { rand } from 'math';\n\nimport { hash, load_catalog, change_catalog, translate, ntranslate, getuid } from 'luci.core';\nimport { revision as luciversion, branch as luciname } from 'luci.version';\nimport { default as LuCIRuntime } from 'luci.runtime';\nimport { urldecode } from 'luci.http';\n\nlet ubus = connect();\nlet uci = cursor();\n\nlet indexcache = \"/tmp/luci-indexcache\";\n\nlet http, runtime, tree, luabridge;\n\nfunction error404(msg) {\n\thttp.status(404, 'Not Found');\n\n\ttry {\n\t\truntime.render('error404', { message: msg ?? 'Not found' });\n\t}\n\tcatch {\n\t\thttp.header('Content-Type', 'text/plain; charset=UTF-8');\n\t\thttp.write(msg ?? 'Not found');\n\t}\n\n\treturn false;\n}\n\nfunction error500(msg, ex) {\n\tif (!http.eoh) {\n\t\thttp.status(500, 'Internal Server Error');\n\t\thttp.header('Content-Type', 'text/html; charset=UTF-8');\n\t}\n\n\ttry {\n\t\truntime.render('error500', {\n\t\t\ttitle: ex?.type ?? 'Runtime exception',\n\t\t\tmessage: replace(\n\t\t\t\tmsg,\n\t\t\t\t/(\\s)((\\/[A-Za-z0-9_.-]+)+:\\d+|\\[string \"[^\"]+\"\\]:\\d+)/g,\n\t\t\t\t'$1<code>$2</code>'\n\t\t\t),\n\t\t\texception: ex\n\t\t});\n\t}\n\tcatch {\n\t\thttp.write('<!--]]>--><!--\\'>--><!--\">-->\\n');\n\t\thttp.write(`<p>${trim(ex)}</p>\\n`);\n\n\t\tif (ex) {\n\t\t\thttp.write(`<p>${trim(ex.message)}</p>\\n`);\n\t\t\thttp.write(`<pre>${trim(ex.stacktrace[0].context)}</pre>\\n`);\n\t\t}\n\t}\n\n\texit(0);\n}\n\nfunction load_luabridge(optional) {\n\tif (luabridge == null) {\n\t\ttry {\n\t\t\tluabridge = require('lua');\n\t\t}\n\t\tcatch (ex) {\n\t\t\tluabridge = false;\n\n\t\t\tif (!optional)\n\t\t\t\terror500('No Lua runtime installed');\n\t\t}\n\t}\n\n\treturn luabridge;\n}\n\nfunction determine_request_language() {\n\tlet lang = uci.get('luci', 'main', 'lang') || 'auto';\n\n\tif (lang == 'auto') {\n\t\tfor (let tag in split(http.getenv('HTTP_ACCEPT_LANGUAGE'), ',')) {\n\t\t\ttag = split(trim(split(tag, ';')?.[0]), '-');\n\n\t\t\tif (tag) {\n\t\t\t\tlet cc = tag[1] ? `${tag[0]}_${lc(tag[1])}` : null;\n\n\t\t\t\tif (cc && uci.get('luci', 'languages', cc)) {\n\t\t\t\t\tlang = cc;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if (uci.get('luci', 'languages', tag[0])) {\n\t\t\t\t\tlang = tag[0];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (lang == 'auto')\n\t\tlang = 'en';\n\telse\n\t\tlang = replace(lang, '_', '-');\n\n\tif (load_catalog(lang, '/usr/lib/lua/luci/i18n'))\n\t\tchange_catalog(lang);\n\n\treturn lang;\n}\n\nfunction determine_version() {\n\tlet res = { luciname, luciversion };\n\n\tfor (let f = open(\"/etc/os-release\"), l = f?.read?.(\"line\"); l; l = f.read?.(\"line\")) {\n\t\tlet kv = split(l, '=', 2);\n\n\t\tswitch (kv[0]) {\n\t\tcase 'NAME':\n\t\t\tres.distname = trim(kv[1], '\"\\' \\n');\n\t\t\tbreak;\n\n\t\tcase 'VERSION':\n\t\t\tres.distversion = trim(kv[1], '\"\\' \\n');\n\t\t\tbreak;\n\n\t\tcase 'HOME_URL':\n\t\t\tres.disturl = trim(kv[1], '\"\\' \\n');\n\t\t\tbreak;\n\n\t\tcase 'BUILD_ID':\n\t\t\tres.distrevision = trim(kv[1], '\"\\' \\n');\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn res;\n}\n\nfunction read_jsonfile(path, defval) {\n\tlet rv;\n\n\ttry {\n\t\trv = json(open(path, \"r\"));\n\t}\n\tcatch (e) {\n\t\trv = defval;\n\t}\n\n\treturn rv;\n}\n\nfunction read_cachefile(file, reader) {\n\tlet euid = getuid(),\n\t    fstat = stat(file),\n\t    fuid = fstat?.uid,\n\t    perm = fstat?.perm;\n\n\tif (euid != fuid ||\n\t    perm?.group_read || perm?.group_write || perm?.group_exec ||\n\t    perm?.other_read || perm?.other_write || perm?.other_exec)\n\t    return null;\n\n\treturn reader(file);\n}\n\nfunction check_fs_depends(spec) {\n\tfor (let path, kind in spec) {\n\t\tif (kind == 'directory') {\n\t\t\tif (!length(lsdir(path)))\n\t\t\t\treturn false;\n\t\t}\n\t\telse if (kind == 'executable') {\n\t\t\tlet fstat = stat(path);\n\n\t\t\tif (fstat?.type != 'file' || fstat?.user_exec == false)\n\t\t\t\treturn false;\n\t\t}\n\t\telse if (kind == 'file') {\n\t\t\tlet fstat = stat(path);\n\n\t\t\tif (fstat?.type != 'file')\n\t\t\t\treturn false;\n\t\t}\n\t\telse if (kind == 'absent') {\n\t\t\tif (stat(path) != null)\n\t\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\nfunction check_uci_depends_options(conf, s, opts) {\n\tif (type(opts) == 'string') {\n\t\treturn (s['.type'] == opts);\n\t}\n\telse if (opts === true) {\n\t\tfor (let option, value in s)\n\t\t\tif (ord(option) != 46)\n\t\t\t\treturn true;\n\t}\n\telse if (type(opts) == 'object') {\n\t\tfor (let option, value in opts) {\n\t\t\tlet sval = s[option];\n\n\t\t\tif (type(sval) == 'array') {\n\t\t\t\tif (!(value in sval))\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse if (value === true) {\n\t\t\t\tif (sval == null)\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (sval != value)\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn true;\n}\n\nfunction check_uci_depends_section(conf, sect) {\n\tfor (let section, options in sect) {\n\t\tlet stype = match(section, /^@([A-Za-z0-9_-]+)$/);\n\n\t\tif (stype) {\n\t\t\tlet found = false;\n\n\t\t\tuci.load(conf);\n\t\t\tuci.foreach(conf, stype[1], (s) => {\n\t\t\t\tif (check_uci_depends_options(conf, s, options)) {\n\t\t\t\t\tfound = true;\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tif (!found)\n\t\t\t\treturn false;\n\t\t}\n\t\telse {\n\t\t\tlet s = uci.get_all(conf, section);\n\n\t\t\tif (!s || !check_uci_depends_options(conf, s, options))\n\t\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\nfunction check_uci_depends(conf) {\n\tfor (let config, values in conf) {\n\t\tif (values == true) {\n\t\t\tlet found = false;\n\n\t\t\tuci.load(config);\n\t\t\tuci.foreach(config, null, () => { found = true });\n\n\t\t\tif (!found)\n\t\t\t\treturn false;\n\t\t}\n\t\telse if (type(values) == 'object') {\n\t\t\tif (!check_uci_depends_section(config, values))\n\t\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\nfunction check_depends(spec) {\n\tif (type(spec?.depends?.fs) in ['array', 'object']) {\n\t\tlet satisfied = false;\n\t\tlet alternatives = (type(spec.depends.fs) == 'array') ? spec.depends.fs : [ spec.depends.fs ];\n\n\t\tfor (let alternative in alternatives) {\n\t\t\tif (check_fs_depends(alternative)) {\n\t\t\t\tsatisfied = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!satisfied)\n\t\t\treturn false;\n\t}\n\n\tif (type(spec?.depends?.uci) in ['array', 'object']) {\n\t\tlet satisfied = false;\n\t\tlet alternatives = (type(spec.depends.uci) == 'array') ? spec.depends.uci : [ spec.depends.uci ];\n\n\t\tfor (let alternative in alternatives) {\n\t\t\tif (check_uci_depends(alternative)) {\n\t\t\t\tsatisfied = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!satisfied)\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nfunction check_acl_depends(require_groups, groups) {\n\tif (length(require_groups)) {\n\t\tlet writable = false;\n\n\t\tfor (let group in require_groups) {\n\t\t\tlet read = ('read' in groups?.[group]);\n\t\t\tlet write = ('write' in groups?.[group]);\n\n\t\t\tif (!read && !write)\n\t\t\t\treturn null;\n\n\t\t\tif (write)\n\t\t\t\twritable = true;\n\t\t}\n\n\t\treturn writable;\n\t}\n\n\treturn true;\n}\n\nfunction hash_filelist(files) {\n\tlet hashval = 0x1b756362;\n\n\tfor (let file in files) {\n\t\tlet st = stat(file);\n\n\t\tif (st)\n\t\t\thashval = hash(sprintf(\"%x|%x|%x\", st.ino, st.mtime, st.size), hashval);\n\t}\n\n\treturn hashval;\n}\n\nfunction build_pagetree() {\n\tlet tree = { action: { type: 'firstchild' } };\n\n\tlet schema = {\n\t\taction: 'object',\n\t\tauth: 'object',\n\t\tcors: 'bool',\n\t\tdepends: 'object',\n\t\torder: 'int',\n\t\tsetgroup: 'string',\n\t\tsetuser: 'string',\n\t\ttitle: 'string',\n\t\twildcard: 'bool',\n\t\tfirstchild_ineligible: 'bool'\n\t};\n\n\tlet files = glob('/usr/share/luci/menu.d/*.json', '/usr/lib/lua/luci/controller/*.lua', '/usr/lib/lua/luci/controller/*/*.lua');\n\tlet cachefile;\n\n\tif (indexcache) {\n\t\tcachefile = sprintf('%s.%08x.json', indexcache, hash_filelist(files));\n\n\t\tlet res = read_cachefile(cachefile, read_jsonfile);\n\n\t\tif (res)\n\t\t\treturn res;\n\n\t\tfor (let path in glob(indexcache + '.*.json'))\n\t\t\tunlink(path);\n\t}\n\n\tfor (let file in files) {\n\t\tlet data;\n\n\t\tif (substr(file, -5) == '.json')\n\t\t\tdata = read_jsonfile(file);\n\t\telse if (load_luabridge(true))\n\t\t\tdata = runtime.call('luci.dispatcher', 'process_lua_controller', file);\n\t\telse\n\t\t\twarn(`Lua controller ${file} present but no Lua runtime installed.\\n`);\n\n\t\tif (type(data) == 'object') {\n\t\t\tfor (let path, spec in data) {\n\t\t\t\tif (type(spec) == 'object') {\n\t\t\t\t\tlet node = tree;\n\n\t\t\t\t\tfor (let s in match(path, /[^\\/]+/g)) {\n\t\t\t\t\t\tif (s[0] == '*') {\n\t\t\t\t\t\t\tnode.wildcard = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tnode.children ??= {};\n\t\t\t\t\t\tnode.children[s[0]] ??= {};\n\t\t\t\t\t\tnode = node.children[s[0]];\n\t\t\t\t\t}\n\n\t\t\t\t\tif (node !== tree) {\n\t\t\t\t\t\tfor (let k, t in schema)\n\t\t\t\t\t\t\tif (type(spec[k]) == t)\n\t\t\t\t\t\t\t\tnode[k] = spec[k];\n\n\t\t\t\t\t\tnode.satisfied = check_depends(spec);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (cachefile) {\n\t\tlet fd = open(cachefile, 'w', 0600);\n\n\t\tif (fd) {\n\t\t\tfd.write(tree);\n\t\t\tfd.close();\n\t\t}\n\t}\n\n\treturn tree;\n}\n\nfunction apply_tree_acls(node, acl) {\n\tfor (let name, spec in node?.children)\n\t\tapply_tree_acls(spec, acl);\n\n\tif (node?.depends?.acl) {\n\t\tswitch (check_acl_depends(node.depends.acl, acl[\"access-group\"])) {\n\t\tcase null:  node.satisfied = false; break;\n\t\tcase false: node.readonly = true;   break;\n\t\t}\n\t}\n}\n\nfunction menu_json(acl) {\n\ttree ??= build_pagetree();\n\n\tif (acl)\n\t\tapply_tree_acls(tree, acl);\n\n\treturn tree;\n}\n\nfunction ctx_append(ctx, name, node) {\n\tctx.path ??= [];\n\tpush(ctx.path, name);\n\n\tctx.acls ??= [];\n\tpush(ctx.acls, ...(node?.depends?.acl || []));\n\n\tctx.auth = node.auth || ctx.auth;\n\tctx.cors = node.cors || ctx.cors;\n\tctx.suid = node.setuser || ctx.suid;\n\tctx.sgid = node.setgroup || ctx.sgid;\n\n\treturn ctx;\n}\n\nfunction session_retrieve(sid, allowed_users) {\n\tlet sdat = ubus.call(\"session\", \"get\", { ubus_rpc_session: sid });\n\tlet sacl = ubus.call(\"session\", \"access\", { ubus_rpc_session: sid });\n\n\tif (type(sdat?.values?.token) == 'string' &&\n\t    (!length(allowed_users) || sdat?.values?.username in allowed_users)) {\n\t\t// uci:set_session_id(sid)\n\t\treturn {\n\t\t\tsid,\n\t\t\tdata: sdat.values,\n\t\t\tacls: length(sacl) ? sacl : {}\n\t\t};\n\t}\n\n\treturn null;\n}\n\nfunction randomid(num_bytes) {\n\tlet bytes = [];\n\n\twhile (num_bytes-- > 0)\n\t\tpush(bytes, sprintf('%02x', rand() % 256));\n\n\treturn join('', bytes);\n}\n\nfunction syslog(prio, msg) {\n\twarn(sprintf(\"[%s] %s\\n\", prio, msg));\n}\n\nfunction session_setup(user, pass, path) {\n\tlet timeout = uci.get('luci', 'sauth', 'sessiontime');\n\tlet login = ubus.call(\"session\", \"login\", {\n\t\tusername: user,\n\t\tpassword: pass,\n\t\ttimeout:  timeout ? +timeout : null\n\t});\n\n\tif (type(login?.ubus_rpc_session) == 'string') {\n\t\tubus.call(\"session\", \"set\", {\n\t\t\tubus_rpc_session: login.ubus_rpc_session,\n\t\t\tvalues: { token: randomid(16) }\n\t\t});\n\t\tsyslog(\"info\", sprintf(\"luci: accepted login on /%s for %s from %s\",\n\t\t\tjoin('/', path), user || \"?\", http.getenv(\"REMOTE_ADDR\") || \"?\"));\n\n\t\treturn session_retrieve(login.ubus_rpc_session);\n\t}\n\n\tsyslog(\"info\", sprintf(\"luci: failed login on /%s for %s from %s\",\n\t\tjoin('/', path), user || \"?\", http.getenv(\"REMOTE_ADDR\") || \"?\"));\n}\n\nfunction check_authentication(method) {\n\tlet m = match(method, /^([[:alpha:]]+):(.+)$/);\n\tlet sid;\n\n\tswitch (m?.[1]) {\n\tcase 'cookie':\n\t\tsid = http.getcookie(m[2]);\n\t\tbreak;\n\n\tcase 'param':\n\t\tsid = http.formvalue(m[2]);\n\t\tbreak;\n\n\tcase 'query':\n\t\tsid = http.formvalue(m[2], true);\n\t\tbreak;\n\t}\n\n\treturn sid ? session_retrieve(sid) : null;\n}\n\nfunction is_authenticated(auth) {\n\tfor (let method in auth?.methods) {\n\t\tlet session = check_authentication(method);\n\n\t\tif (session)\n\t\t\treturn session;\n\t}\n\n\treturn null;\n}\n\nfunction node_weight(node) {\n\tlet weight = min(node.order ?? 9999, 9999);\n\n\tif (node.auth?.login)\n\t\tweight += 10000;\n\n\treturn weight;\n}\n\nfunction clone(src) {\n\tswitch (type(src)) {\n\tcase 'array':\n\t\treturn map(src, clone);\n\n\tcase 'object':\n\t\tlet dest = {};\n\n\t\tfor (let k, v in src)\n\t\t\tdest[k] = clone(v);\n\n\t\treturn dest;\n\n\tdefault:\n\t\treturn src;\n\t}\n}\n\nfunction resolve_firstchild(node, session, login_allowed, ctx) {\n\tlet candidate, candidate_ctx;\n\n\tfor (let name, child in node.children) {\n\t\tif (!child.satisfied)\n\t\t\tcontinue;\n\n\t\tif (!session)\n\t\t\tsession = is_authenticated(node.auth);\n\n\t\tlet cacl = child.depends?.acl;\n\t\tlet login = login_allowed || child.auth?.login;\n\n\t\tif (login || check_acl_depends(cacl, session?.acls?.[\"access-group\"]) != null) {\n\t\t\tif (child.title && type(child.action) == \"object\") {\n\t\t\t\tlet child_ctx = ctx_append(clone(ctx), name, child);\n\t\t\t\tif (child.action.type == \"firstchild\") {\n\t\t\t\t\tif (!candidate || node_weight(candidate) > node_weight(child)) {\n\t\t\t\t\t\tlet have_grandchild = resolve_firstchild(child, session, login, child_ctx);\n\t\t\t\t\t\tif (have_grandchild) {\n\t\t\t\t\t\t\tcandidate = child;\n\t\t\t\t\t\t\tcandidate_ctx = child_ctx;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (!child.firstchild_ineligible) {\n\t\t\t\t\tif (!candidate || node_weight(candidate) > node_weight(child)) {\n\t\t\t\t\t\tcandidate = child;\n\t\t\t\t\t\tcandidate_ctx = child_ctx;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!candidate)\n\t\treturn false;\n\n\tfor (let k, v in candidate_ctx)\n\t\tctx[k] = v;\n\n\treturn true;\n}\n\nfunction resolve_page(tree, request_path) {\n\tlet node = tree;\n\tlet login = false;\n\tlet session = null;\n\tlet ctx = {};\n\n\tfor (let i, s in request_path) {\n\t\tnode = node.children?.[s];\n\n\t\tif (!node?.satisfied)\n\t\t\tbreak;\n\n\t\tctx_append(ctx, s, node);\n\n\t\tif (!session)\n\t\t\tsession = is_authenticated(node.auth);\n\n\t\tif (!login && node.auth?.login)\n\t\t\tlogin = true;\n\n\t\tif (node.wildcard) {\n\t\t\tctx.request_args = [];\n\t\t\tctx.request_path = ctx.path ? [ ...ctx.path ] : [];\n\n\t\t\twhile (++i < length(request_path)) {\n\t\t\t\tpush(ctx.request_path, request_path[i]);\n\t\t\t\tpush(ctx.request_args, request_path[i]);\n\t\t\t}\n\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (node?.action?.type == 'firstchild')\n\t\tresolve_firstchild(node, session, login, ctx);\n\n\tctx.acls ??= {};\n\tctx.path ??= [];\n\tctx.request_args ??= [];\n\tctx.request_path ??= request_path ? [ ...request_path ] : [];\n\n\tctx.authsession = session?.sid;\n\tctx.authtoken = session?.data?.token;\n\tctx.authuser = session?.data?.username;\n\tctx.authacl = session?.acls;\n\n\tnode = tree;\n\n\tfor (let s in ctx.path) {\n\t\tnode = node.children[s];\n\t\tassert(node, \"Internal node resolve error\");\n\t}\n\n\treturn { node, ctx, session };\n}\n\nfunction require_post_security(target, args) {\n\tif (target?.type == 'arcombine')\n\t\treturn require_post_security(length(args) ? target?.targets?.[1] : target?.targets?.[0], args);\n\n\tif (type(target?.post) == 'object') {\n\t\tfor (let param_name, required_val in target.post) {\n\t\t\tlet request_val = http.formvalue(param_name);\n\n\t\t\tif ((type(required_val) == 'string' && request_val != required_val) ||\n\t\t\t    (required_val == true && request_val == null))\n\t\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\treturn (target?.post == true);\n}\n\nfunction test_post_security(authtoken) {\n\tif (http.getenv(\"REQUEST_METHOD\") != \"POST\") {\n\t\thttp.status(405, \"Method Not Allowed\");\n\t\thttp.header(\"Allow\", \"POST\");\n\n\t\treturn false;\n\t}\n\n\tif (http.formvalue(\"token\") != authtoken) {\n\t\thttp.status(403, \"Forbidden\");\n\t\truntime.render(\"csrftoken\");\n\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nfunction build_url(...path) {\n\tlet url = [ http.getenv('SCRIPT_NAME') ?? '' ];\n\n\tfor (let p in path)\n\t\tif (match(p, /^[A-Za-z0-9_%.\\/,;-]+$/))\n\t\t\tpush(url, '/', p);\n\n\tif (length(url) == 1)\n\t\tpush(url, '/');\n\n\treturn join('', url);\n}\n\nfunction lookup(...segments) {\n\tlet node = menu_json();\n\tlet path = [];\n\n\tfor (let segment in segments)\n\t\tfor (let name in split(segment, '/'))\n\t\t\tpush(path, name);\n\n\tfor (let name in path) {\n\t\tnode = node.children[name];\n\n\t\tif (!node)\n\t\t\treturn null;\n\n\t\tif (node.leaf)\n\t\t\tbreak;\n\t}\n\n\treturn { node, url: build_url(...path) };\n}\n\nfunction rollback_pending() {\n\tconst now = time();\n\tconst rv = ubus.call('session', 'get', {\n\t\tubus_rpc_session: '00000000000000000000000000000000',\n\t\tkeys: [ 'rollback' ]\n\t});\n\n\tif (type(rv?.values?.rollback?.token) != 'string' ||\n\t    type(rv?.values?.rollback?.session) != 'string' ||\n\t    type(rv?.values?.rollback?.timeout) != 'int' ||\n\t    rv.values.rollback.timeout <= now)\n\t    return false;\n\n\treturn {\n\t\tremaining: rv.values.rollback.timeout - now,\n\t\tsession: rv.values.rollback.session,\n\t\ttoken: rv.values.rollback.token\n\t};\n}\n\nlet dispatch;\n\nfunction render_action(fn) {\n\tconst data = render(fn);\n\n\thttp.write_headers();\n\thttp.output(data);\n}\n\nfunction run_action(request_path, lang, tree, resolved, action) {\n\tswitch (action?.type) {\n\tcase 'template':\n\t\tif (runtime.is_ucode_template(action.path))\n\t\t\truntime.render(action.path, {});\n\t\telse\n\t\t\trender_action(() => {\n\t\t\t\truntime.call('luci.dispatcher', 'render_lua_template', action.path);\n\t\t\t});\n\t\tbreak;\n\n\tcase 'view':\n\t\truntime.render('view', { view: action.path });\n\t\tbreak;\n\n\tcase 'call':\n\t\trender_action(() => {\n\t\t\truntime.call(action.module, action.function,\n\t\t\t\t...(action.parameters ?? []),\n\t\t\t\t...resolved.ctx.request_args\n\t\t\t);\n\t\t});\n\t\tbreak;\n\n\tcase 'function':\n\t\tconst mod = require(action.module);\n\n\t\tassert(type(mod[action.function]) == 'function',\n\t\t\t`Module '${action.module}' does not export function '${action.function}'`);\n\n\t\trender_action(() => {\n\t\t\tcall(mod[action.function], mod, runtime.env,\n\t\t\t\t...(action.parameters ?? []),\n\t\t\t\t...resolved.ctx.request_args\n\t\t\t);\n\t\t});\n\t\tbreak;\n\n\tcase 'cbi':\n\t\trender_action(() => {\n\t\t\truntime.call('luci.dispatcher', 'invoke_cbi_action',\n\t\t\t\taction.path, null,\n\t\t\t\t...resolved.ctx.request_args\n\t\t\t);\n\t\t});\n\t\tbreak;\n\n\tcase 'form':\n\t\trender_action(() => {\n\t\t\truntime.call('luci.dispatcher', 'invoke_form_action',\n\t\t\t\taction.path,\n\t\t\t\t...resolved.ctx.request_args\n\t\t\t);\n\t\t});\n\t\tbreak;\n\n\tcase 'alias':\n\t\tdispatch(http, [ ...split(action.path, '/'), ...resolved.ctx.request_args ]);\n\t\tbreak;\n\n\tcase 'rewrite':\n\t\tdispatch(http, [\n\t\t\t...splice([ ...request_path ], 0, action.remove),\n\t\t\t...split(action.path, '/'),\n\t\t\t...resolved.ctx.request_args\n\t\t]);\n\t\tbreak;\n\n\tcase 'firstchild':\n\t\tif (!length(tree.children))\n\t\t\terror404(\"No root node was registered, this usually happens if no module was installed.\\n\" +\n\t\t\t         \"Install luci-mod-admin-full and retry. \" +\n\t\t\t         \"If the module is already installed, try removing the /tmp/luci-indexcache file.\");\n\t\telse\n\t\t\terror404(`No page is registered at '/${join(\"/\", resolved.ctx.request_path)}'.\\n` +\n\t\t\t         \"If this url belongs to an extension, make sure it is properly installed.\\n\" +\n\t\t\t         \"If the extension was recently installed, try removing the /tmp/luci-indexcache file.\");\n\t\tbreak;\n\n\tdefault:\n\t\terror500(`Unhandled action type ${action?.type ?? '?'}`);\n\t}\n}\n\ndispatch = function(_http, path) {\n\thttp = _http;\n\n\tlet version = determine_version();\n\tlet lang = determine_request_language();\n\n\truntime = runtime || LuCIRuntime({\n\t\thttp,\n\t\tubus,\n\t\tuci,\n\t\tctx: {},\n\t\tversion,\n\t\tconfig: {\n\t\t\tmain: uci.get_all('luci', 'main') ?? {},\n\t\t\tapply: uci.get_all('luci', 'apply') ?? {}\n\t\t},\n\t\tdispatcher: {\n\t\t\trollback_pending,\n\t\t\tis_authenticated,\n\t\t\tload_luabridge,\n\t\t\tlookup,\n\t\t\tmenu_json,\n\t\t\tbuild_url,\n\t\t\trandomid,\n\t\t\terror404,\n\t\t\terror500,\n\t\t\tlang\n\t\t},\n\t\tstriptags,\n\t\tentityencode,\n\t\t_: (...args) => translate(...args) ?? args[0],\n\t\tN_: (...args) => ntranslate(...args) ?? (n[0] == 1 ? n[1] : n[2]),\n\t});\n\n\ttry {\n\t\tlet menu = menu_json();\n\n\t\tpath ??= map(match(http.getenv('PATH_INFO'), /[^\\/]+/g), m => urldecode(m[0]));\n\n\t\tlet resolved = resolve_page(menu, path);\n\n\t\truntime.env.ctx = resolved.ctx;\n\t\truntime.env.dispatched = resolved.node;\n\t\truntime.env.requested ??= resolved.node;\n\n\t\tif (length(resolved.ctx.auth)) {\n\t\t\tlet session = is_authenticated(resolved.ctx.auth);\n\n\t\t\tif (!session && resolved.ctx.auth.login) {\n\t\t\t\tlet user = http.getenv('HTTP_AUTH_USER');\n\t\t\t\tlet pass = http.getenv('HTTP_AUTH_PASS');\n\n\t\t\t\tif (user == null && pass == null) {\n\t\t\t\t\tuser = http.formvalue('luci_username');\n\t\t\t\t\tpass = http.formvalue('luci_password');\n\t\t\t\t}\n\n\t\t\t\tif (user != null && pass != null)\n\t\t\t\t\tsession = session_setup(user, pass, resolved.ctx.request_path);\n\n\t\t\t\tif (!session) {\n\t\t\t\t\tresolved.ctx.path = [];\n\n\t\t\t\t\thttp.status(403, 'Forbidden');\n\t\t\t\t\thttp.header('X-LuCI-Login-Required', 'yes');\n\n\t\t\t\t\tlet scope = { duser: 'root', fuser: user };\n\t\t\t\t\tlet theme_sysauth = `themes/${basename(runtime.env.media)}/sysauth`;\n\n\t\t\t\t\tif (runtime.is_ucode_template(theme_sysauth) || runtime.is_lua_template(theme_sysauth)) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\treturn runtime.render(theme_sysauth, scope);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (e) {\n\t\t\t\t\t\t\truntime.env.media_error = `${e}`;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn runtime.render('sysauth', scope);\n\t\t\t\t}\n\n\t\t\t\tlet cookie_name = (http.getenv('HTTPS') == 'on') ? 'sysauth_https' : 'sysauth_http',\n\t\t\t\t    cookie_secure = (http.getenv('HTTPS') == 'on') ? '; secure' : '';\n\n\t\t\t\thttp.header('Set-Cookie', `${cookie_name}=${session.sid}; path=${build_url()}; SameSite=strict; HttpOnly${cookie_secure}`);\n\t\t\t\thttp.redirect(build_url(...resolved.ctx.request_path));\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (!session) {\n\t\t\t\thttp.status(403, 'Forbidden');\n\t\t\t\thttp.header('X-LuCI-Login-Required', 'yes');\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tresolved.ctx.authsession ??= session.sid;\n\t\t\tresolved.ctx.authtoken ??= session.data?.token;\n\t\t\tresolved.ctx.authuser ??= session.data?.username;\n\t\t\tresolved.ctx.authacl ??= session.acls;\n\n\t\t\t/* In case the Lua runtime was already initialized, e.g. by probing legacy\n\t\t\t * theme header templates, make sure to update the session ID of the uci\n\t\t\t * module. */\n\t\t\tif (runtime.L) {\n\t\t\t\truntime.L.invoke('require', 'luci.model.uci');\n\t\t\t\truntime.L.get('luci', 'model', 'uci').invoke('set_session_id', session.sid);\n\t\t\t}\n\t\t}\n\n\t\tif (length(resolved.ctx.acls)) {\n\t\t\tlet perm = check_acl_depends(resolved.ctx.acls, resolved.ctx.authacl?.['access-group']);\n\n\t\t\tif (perm == null) {\n\t\t\t\thttp.status(403, 'Forbidden');\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (resolved.node)\n\t\t\t\tresolved.node.readonly = !perm;\n\t\t}\n\n\t\tlet action = resolved.node.action;\n\n\t\tif (action?.type == 'arcombine')\n\t\t\taction = length(resolved.ctx.request_args) ? action.targets?.[1] : action.targets?.[0];\n\n\t\tif (resolved.ctx.cors && http.getenv('REQUEST_METHOD') == 'OPTIONS') {\n\t\t\thttp.status(200, 'OK');\n\t\t\thttp.header('Access-Control-Allow-Origin', http.getenv('HTTP_ORIGIN') ?? '*');\n\t\t\thttp.header('Access-Control-Allow-Methods', 'GET, POST, OPTIONS');\n\n\t\t\treturn;\n\t\t}\n\n\t\tif (require_post_security(action) && !test_post_security(resolved.ctx.authtoken))\n\t\t\treturn;\n\n\t\trun_action(path, lang, menu, resolved, action);\n\t}\n\tcatch (ex) {\n\t\terror500('Unhandled exception during request dispatching', ex);\n\t}\n};\n\nexport default dispatch;\n", "{#\n Copyright 2022 Jo-Philipp Wich <jo@mein.io>\n Licensed to the public under the Apache License 2.0.\n-#}\n\n{%\n\tinclude(`themes/${theme}/header`);\n-%}\n\n<script type=\"text/javascript\" src=\"{{ resource }}/promis.min.js\"></script>\n<script type=\"text/javascript\" src=\"{{ resource }}/luci.js\"></script>\n<script type=\"text/javascript\">\n\tL = new LuCI({{ {\n\t\tmedia          : media,\n\t\tresource       : resource,\n\t\tscriptname     : http.getenv(\"SCRIPT_NAME\"),\n\t\tpathinfo       : http.getenv(\"PATH_INFO\"),\n\t\tdocumentroot   : http.getenv(\"DOCUMENT_ROOT\"),\n\t\trequestpath    : ctx.request_path,\n\t\tdispatchpath   : ctx.path,\n\t\tpollinterval   : +config.main.pollinterval || 5,\n\t\tubuspath       : config.main.ubuspath || '/ubus/',\n\t\tsessionid      : ctx.authsession,\n\t\ttoken          : ctx.authtoken,\n\t\tnodespec       : dispatched,\n\t\tapply_rollback : max(+config.apply.rollback ||  90, 90),\n\t\tapply_holdoff  : max(+config.apply.holdoff  ||   4,  1),\n\t\tapply_timeout  : max(+config.apply.timeout  ||   5,  1),\n\t\tapply_display  : max(+config.apply.display  || 1.5,  1),\n\t\trollback_token : rollback_token\n\t} }});\n</script>\n"], "fixing_code": ["// Copyright 2022 Jo-Philipp Wich <jo@mein.io>\n// Licensed to the public under the Apache License 2.0.\n\nimport { open, stat, glob, lsdir, unlink, basename } from 'fs';\nimport { striptags, entityencode } from 'html';\nimport { connect } from 'ubus';\nimport { cursor } from 'uci';\nimport { rand } from 'math';\n\nimport { hash, load_catalog, change_catalog, translate, ntranslate, getuid } from 'luci.core';\nimport { revision as luciversion, branch as luciname } from 'luci.version';\nimport { default as LuCIRuntime } from 'luci.runtime';\nimport { urldecode } from 'luci.http';\n\nlet ubus = connect();\nlet uci = cursor();\n\nlet indexcache = \"/tmp/luci-indexcache\";\n\nlet http, runtime, tree, luabridge;\n\nfunction error404(msg) {\n\thttp.status(404, 'Not Found');\n\n\ttry {\n\t\truntime.render('error404', { message: msg ?? 'Not found' });\n\t}\n\tcatch {\n\t\thttp.header('Content-Type', 'text/plain; charset=UTF-8');\n\t\thttp.write(msg ?? 'Not found');\n\t}\n\n\treturn false;\n}\n\nfunction error500(msg, ex) {\n\tif (!http.eoh) {\n\t\thttp.status(500, 'Internal Server Error');\n\t\thttp.header('Content-Type', 'text/html; charset=UTF-8');\n\t}\n\n\ttry {\n\t\truntime.render('error500', {\n\t\t\ttitle: ex?.type ?? 'Runtime exception',\n\t\t\tmessage: replace(\n\t\t\t\tmsg,\n\t\t\t\t/(\\s)((\\/[A-Za-z0-9_.-]+)+:\\d+|\\[string \"[^\"]+\"\\]:\\d+)/g,\n\t\t\t\t'$1<code>$2</code>'\n\t\t\t),\n\t\t\texception: ex\n\t\t});\n\t}\n\tcatch {\n\t\thttp.write('<!--]]>--><!--\\'>--><!--\">-->\\n');\n\t\thttp.write(`<p>${trim(ex)}</p>\\n`);\n\n\t\tif (ex) {\n\t\t\thttp.write(`<p>${trim(ex.message)}</p>\\n`);\n\t\t\thttp.write(`<pre>${trim(ex.stacktrace[0].context)}</pre>\\n`);\n\t\t}\n\t}\n\n\texit(0);\n}\n\nfunction load_luabridge(optional) {\n\tif (luabridge == null) {\n\t\ttry {\n\t\t\tluabridge = require('lua');\n\t\t}\n\t\tcatch (ex) {\n\t\t\tluabridge = false;\n\n\t\t\tif (!optional)\n\t\t\t\terror500('No Lua runtime installed');\n\t\t}\n\t}\n\n\treturn luabridge;\n}\n\nfunction determine_request_language() {\n\tlet lang = uci.get('luci', 'main', 'lang') || 'auto';\n\n\tif (lang == 'auto') {\n\t\tfor (let tag in split(http.getenv('HTTP_ACCEPT_LANGUAGE'), ',')) {\n\t\t\ttag = split(trim(split(tag, ';')?.[0]), '-');\n\n\t\t\tif (tag) {\n\t\t\t\tlet cc = tag[1] ? `${tag[0]}_${lc(tag[1])}` : null;\n\n\t\t\t\tif (cc && uci.get('luci', 'languages', cc)) {\n\t\t\t\t\tlang = cc;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if (uci.get('luci', 'languages', tag[0])) {\n\t\t\t\t\tlang = tag[0];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (lang == 'auto')\n\t\tlang = 'en';\n\telse\n\t\tlang = replace(lang, '_', '-');\n\n\tif (load_catalog(lang, '/usr/lib/lua/luci/i18n'))\n\t\tchange_catalog(lang);\n\n\treturn lang;\n}\n\nfunction determine_version() {\n\tlet res = { luciname, luciversion };\n\n\tfor (let f = open(\"/etc/os-release\"), l = f?.read?.(\"line\"); l; l = f.read?.(\"line\")) {\n\t\tlet kv = split(l, '=', 2);\n\n\t\tswitch (kv[0]) {\n\t\tcase 'NAME':\n\t\t\tres.distname = trim(kv[1], '\"\\' \\n');\n\t\t\tbreak;\n\n\t\tcase 'VERSION':\n\t\t\tres.distversion = trim(kv[1], '\"\\' \\n');\n\t\t\tbreak;\n\n\t\tcase 'HOME_URL':\n\t\t\tres.disturl = trim(kv[1], '\"\\' \\n');\n\t\t\tbreak;\n\n\t\tcase 'BUILD_ID':\n\t\t\tres.distrevision = trim(kv[1], '\"\\' \\n');\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn res;\n}\n\nfunction read_jsonfile(path, defval) {\n\tlet rv;\n\n\ttry {\n\t\trv = json(open(path, \"r\"));\n\t}\n\tcatch (e) {\n\t\trv = defval;\n\t}\n\n\treturn rv;\n}\n\nfunction read_cachefile(file, reader) {\n\tlet euid = getuid(),\n\t    fstat = stat(file),\n\t    fuid = fstat?.uid,\n\t    perm = fstat?.perm;\n\n\tif (euid != fuid ||\n\t    perm?.group_read || perm?.group_write || perm?.group_exec ||\n\t    perm?.other_read || perm?.other_write || perm?.other_exec)\n\t    return null;\n\n\treturn reader(file);\n}\n\nfunction check_fs_depends(spec) {\n\tfor (let path, kind in spec) {\n\t\tif (kind == 'directory') {\n\t\t\tif (!length(lsdir(path)))\n\t\t\t\treturn false;\n\t\t}\n\t\telse if (kind == 'executable') {\n\t\t\tlet fstat = stat(path);\n\n\t\t\tif (fstat?.type != 'file' || fstat?.user_exec == false)\n\t\t\t\treturn false;\n\t\t}\n\t\telse if (kind == 'file') {\n\t\t\tlet fstat = stat(path);\n\n\t\t\tif (fstat?.type != 'file')\n\t\t\t\treturn false;\n\t\t}\n\t\telse if (kind == 'absent') {\n\t\t\tif (stat(path) != null)\n\t\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\nfunction check_uci_depends_options(conf, s, opts) {\n\tif (type(opts) == 'string') {\n\t\treturn (s['.type'] == opts);\n\t}\n\telse if (opts === true) {\n\t\tfor (let option, value in s)\n\t\t\tif (ord(option) != 46)\n\t\t\t\treturn true;\n\t}\n\telse if (type(opts) == 'object') {\n\t\tfor (let option, value in opts) {\n\t\t\tlet sval = s[option];\n\n\t\t\tif (type(sval) == 'array') {\n\t\t\t\tif (!(value in sval))\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse if (value === true) {\n\t\t\t\tif (sval == null)\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (sval != value)\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn true;\n}\n\nfunction check_uci_depends_section(conf, sect) {\n\tfor (let section, options in sect) {\n\t\tlet stype = match(section, /^@([A-Za-z0-9_-]+)$/);\n\n\t\tif (stype) {\n\t\t\tlet found = false;\n\n\t\t\tuci.load(conf);\n\t\t\tuci.foreach(conf, stype[1], (s) => {\n\t\t\t\tif (check_uci_depends_options(conf, s, options)) {\n\t\t\t\t\tfound = true;\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tif (!found)\n\t\t\t\treturn false;\n\t\t}\n\t\telse {\n\t\t\tlet s = uci.get_all(conf, section);\n\n\t\t\tif (!s || !check_uci_depends_options(conf, s, options))\n\t\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\nfunction check_uci_depends(conf) {\n\tfor (let config, values in conf) {\n\t\tif (values == true) {\n\t\t\tlet found = false;\n\n\t\t\tuci.load(config);\n\t\t\tuci.foreach(config, null, () => { found = true });\n\n\t\t\tif (!found)\n\t\t\t\treturn false;\n\t\t}\n\t\telse if (type(values) == 'object') {\n\t\t\tif (!check_uci_depends_section(config, values))\n\t\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\nfunction check_depends(spec) {\n\tif (type(spec?.depends?.fs) in ['array', 'object']) {\n\t\tlet satisfied = false;\n\t\tlet alternatives = (type(spec.depends.fs) == 'array') ? spec.depends.fs : [ spec.depends.fs ];\n\n\t\tfor (let alternative in alternatives) {\n\t\t\tif (check_fs_depends(alternative)) {\n\t\t\t\tsatisfied = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!satisfied)\n\t\t\treturn false;\n\t}\n\n\tif (type(spec?.depends?.uci) in ['array', 'object']) {\n\t\tlet satisfied = false;\n\t\tlet alternatives = (type(spec.depends.uci) == 'array') ? spec.depends.uci : [ spec.depends.uci ];\n\n\t\tfor (let alternative in alternatives) {\n\t\t\tif (check_uci_depends(alternative)) {\n\t\t\t\tsatisfied = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!satisfied)\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nfunction check_acl_depends(require_groups, groups) {\n\tif (length(require_groups)) {\n\t\tlet writable = false;\n\n\t\tfor (let group in require_groups) {\n\t\t\tlet read = ('read' in groups?.[group]);\n\t\t\tlet write = ('write' in groups?.[group]);\n\n\t\t\tif (!read && !write)\n\t\t\t\treturn null;\n\n\t\t\tif (write)\n\t\t\t\twritable = true;\n\t\t}\n\n\t\treturn writable;\n\t}\n\n\treturn true;\n}\n\nfunction hash_filelist(files) {\n\tlet hashval = 0x1b756362;\n\n\tfor (let file in files) {\n\t\tlet st = stat(file);\n\n\t\tif (st)\n\t\t\thashval = hash(sprintf(\"%x|%x|%x\", st.ino, st.mtime, st.size), hashval);\n\t}\n\n\treturn hashval;\n}\n\nfunction build_pagetree() {\n\tlet tree = { action: { type: 'firstchild' } };\n\n\tlet schema = {\n\t\taction: 'object',\n\t\tauth: 'object',\n\t\tcors: 'bool',\n\t\tdepends: 'object',\n\t\torder: 'int',\n\t\tsetgroup: 'string',\n\t\tsetuser: 'string',\n\t\ttitle: 'string',\n\t\twildcard: 'bool',\n\t\tfirstchild_ineligible: 'bool'\n\t};\n\n\tlet files = glob('/usr/share/luci/menu.d/*.json', '/usr/lib/lua/luci/controller/*.lua', '/usr/lib/lua/luci/controller/*/*.lua');\n\tlet cachefile;\n\n\tif (indexcache) {\n\t\tcachefile = sprintf('%s.%08x.json', indexcache, hash_filelist(files));\n\n\t\tlet res = read_cachefile(cachefile, read_jsonfile);\n\n\t\tif (res)\n\t\t\treturn res;\n\n\t\tfor (let path in glob(indexcache + '.*.json'))\n\t\t\tunlink(path);\n\t}\n\n\tfor (let file in files) {\n\t\tlet data;\n\n\t\tif (substr(file, -5) == '.json')\n\t\t\tdata = read_jsonfile(file);\n\t\telse if (load_luabridge(true))\n\t\t\tdata = runtime.call('luci.dispatcher', 'process_lua_controller', file);\n\t\telse\n\t\t\twarn(`Lua controller ${file} present but no Lua runtime installed.\\n`);\n\n\t\tif (type(data) == 'object') {\n\t\t\tfor (let path, spec in data) {\n\t\t\t\tif (type(spec) == 'object') {\n\t\t\t\t\tlet node = tree;\n\n\t\t\t\t\tfor (let s in match(path, /[^\\/]+/g)) {\n\t\t\t\t\t\tif (s[0] == '*') {\n\t\t\t\t\t\t\tnode.wildcard = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tnode.children ??= {};\n\t\t\t\t\t\tnode.children[s[0]] ??= {};\n\t\t\t\t\t\tnode = node.children[s[0]];\n\t\t\t\t\t}\n\n\t\t\t\t\tif (node !== tree) {\n\t\t\t\t\t\tfor (let k, t in schema)\n\t\t\t\t\t\t\tif (type(spec[k]) == t)\n\t\t\t\t\t\t\t\tnode[k] = spec[k];\n\n\t\t\t\t\t\tnode.satisfied = check_depends(spec);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (cachefile) {\n\t\tlet fd = open(cachefile, 'w', 0600);\n\n\t\tif (fd) {\n\t\t\tfd.write(tree);\n\t\t\tfd.close();\n\t\t}\n\t}\n\n\treturn tree;\n}\n\nfunction apply_tree_acls(node, acl) {\n\tfor (let name, spec in node?.children)\n\t\tapply_tree_acls(spec, acl);\n\n\tif (node?.depends?.acl) {\n\t\tswitch (check_acl_depends(node.depends.acl, acl[\"access-group\"])) {\n\t\tcase null:  node.satisfied = false; break;\n\t\tcase false: node.readonly = true;   break;\n\t\t}\n\t}\n}\n\nfunction menu_json(acl) {\n\ttree ??= build_pagetree();\n\n\tif (acl)\n\t\tapply_tree_acls(tree, acl);\n\n\treturn tree;\n}\n\nfunction ctx_append(ctx, name, node) {\n\tctx.path ??= [];\n\tpush(ctx.path, name);\n\n\tctx.acls ??= [];\n\tpush(ctx.acls, ...(node?.depends?.acl || []));\n\n\tctx.auth = node.auth || ctx.auth;\n\tctx.cors = node.cors || ctx.cors;\n\tctx.suid = node.setuser || ctx.suid;\n\tctx.sgid = node.setgroup || ctx.sgid;\n\n\treturn ctx;\n}\n\nfunction session_retrieve(sid, allowed_users) {\n\tlet sdat = ubus.call(\"session\", \"get\", { ubus_rpc_session: sid });\n\tlet sacl = ubus.call(\"session\", \"access\", { ubus_rpc_session: sid });\n\n\tif (type(sdat?.values?.token) == 'string' &&\n\t    (!length(allowed_users) || sdat?.values?.username in allowed_users)) {\n\t\t// uci:set_session_id(sid)\n\t\treturn {\n\t\t\tsid,\n\t\t\tdata: sdat.values,\n\t\t\tacls: length(sacl) ? sacl : {}\n\t\t};\n\t}\n\n\treturn null;\n}\n\nfunction randomid(num_bytes) {\n\tlet bytes = [];\n\n\twhile (num_bytes-- > 0)\n\t\tpush(bytes, sprintf('%02x', rand() % 256));\n\n\treturn join('', bytes);\n}\n\nfunction syslog(prio, msg) {\n\twarn(sprintf(\"[%s] %s\\n\", prio, msg));\n}\n\nfunction session_setup(user, pass, path) {\n\tlet timeout = uci.get('luci', 'sauth', 'sessiontime');\n\tlet login = ubus.call(\"session\", \"login\", {\n\t\tusername: user,\n\t\tpassword: pass,\n\t\ttimeout:  timeout ? +timeout : null\n\t});\n\n\tif (type(login?.ubus_rpc_session) == 'string') {\n\t\tubus.call(\"session\", \"set\", {\n\t\t\tubus_rpc_session: login.ubus_rpc_session,\n\t\t\tvalues: { token: randomid(16) }\n\t\t});\n\t\tsyslog(\"info\", sprintf(\"luci: accepted login on /%s for %s from %s\",\n\t\t\tjoin('/', path), user || \"?\", http.getenv(\"REMOTE_ADDR\") || \"?\"));\n\n\t\treturn session_retrieve(login.ubus_rpc_session);\n\t}\n\n\tsyslog(\"info\", sprintf(\"luci: failed login on /%s for %s from %s\",\n\t\tjoin('/', path), user || \"?\", http.getenv(\"REMOTE_ADDR\") || \"?\"));\n}\n\nfunction check_authentication(method) {\n\tlet m = match(method, /^([[:alpha:]]+):(.+)$/);\n\tlet sid;\n\n\tswitch (m?.[1]) {\n\tcase 'cookie':\n\t\tsid = http.getcookie(m[2]);\n\t\tbreak;\n\n\tcase 'param':\n\t\tsid = http.formvalue(m[2]);\n\t\tbreak;\n\n\tcase 'query':\n\t\tsid = http.formvalue(m[2], true);\n\t\tbreak;\n\t}\n\n\treturn sid ? session_retrieve(sid) : null;\n}\n\nfunction is_authenticated(auth) {\n\tfor (let method in auth?.methods) {\n\t\tlet session = check_authentication(method);\n\n\t\tif (session)\n\t\t\treturn session;\n\t}\n\n\treturn null;\n}\n\nfunction node_weight(node) {\n\tlet weight = min(node.order ?? 9999, 9999);\n\n\tif (node.auth?.login)\n\t\tweight += 10000;\n\n\treturn weight;\n}\n\nfunction clone(src) {\n\tswitch (type(src)) {\n\tcase 'array':\n\t\treturn map(src, clone);\n\n\tcase 'object':\n\t\tlet dest = {};\n\n\t\tfor (let k, v in src)\n\t\t\tdest[k] = clone(v);\n\n\t\treturn dest;\n\n\tdefault:\n\t\treturn src;\n\t}\n}\n\nfunction resolve_firstchild(node, session, login_allowed, ctx) {\n\tlet candidate, candidate_ctx;\n\n\tfor (let name, child in node.children) {\n\t\tif (!child.satisfied)\n\t\t\tcontinue;\n\n\t\tif (!session)\n\t\t\tsession = is_authenticated(node.auth);\n\n\t\tlet cacl = child.depends?.acl;\n\t\tlet login = login_allowed || child.auth?.login;\n\n\t\tif (login || check_acl_depends(cacl, session?.acls?.[\"access-group\"]) != null) {\n\t\t\tif (child.title && type(child.action) == \"object\") {\n\t\t\t\tlet child_ctx = ctx_append(clone(ctx), name, child);\n\t\t\t\tif (child.action.type == \"firstchild\") {\n\t\t\t\t\tif (!candidate || node_weight(candidate) > node_weight(child)) {\n\t\t\t\t\t\tlet have_grandchild = resolve_firstchild(child, session, login, child_ctx);\n\t\t\t\t\t\tif (have_grandchild) {\n\t\t\t\t\t\t\tcandidate = child;\n\t\t\t\t\t\t\tcandidate_ctx = child_ctx;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (!child.firstchild_ineligible) {\n\t\t\t\t\tif (!candidate || node_weight(candidate) > node_weight(child)) {\n\t\t\t\t\t\tcandidate = child;\n\t\t\t\t\t\tcandidate_ctx = child_ctx;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!candidate)\n\t\treturn false;\n\n\tfor (let k, v in candidate_ctx)\n\t\tctx[k] = v;\n\n\treturn true;\n}\n\nfunction resolve_page(tree, request_path) {\n\tlet node = tree;\n\tlet login = false;\n\tlet session = null;\n\tlet ctx = {};\n\n\tfor (let i, s in request_path) {\n\t\tnode = node.children?.[s];\n\n\t\tif (!node?.satisfied)\n\t\t\tbreak;\n\n\t\tctx_append(ctx, s, node);\n\n\t\tif (!session)\n\t\t\tsession = is_authenticated(node.auth);\n\n\t\tif (!login && node.auth?.login)\n\t\t\tlogin = true;\n\n\t\tif (node.wildcard) {\n\t\t\tctx.request_args = [];\n\t\t\tctx.request_path = ctx.path ? [ ...ctx.path ] : [];\n\n\t\t\twhile (++i < length(request_path)) {\n\t\t\t\tpush(ctx.request_path, request_path[i]);\n\t\t\t\tpush(ctx.request_args, request_path[i]);\n\t\t\t}\n\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (node?.action?.type == 'firstchild')\n\t\tresolve_firstchild(node, session, login, ctx);\n\n\tctx.acls ??= {};\n\tctx.path ??= [];\n\tctx.request_args ??= [];\n\tctx.request_path ??= request_path ? [ ...request_path ] : [];\n\n\tctx.authsession = session?.sid;\n\tctx.authtoken = session?.data?.token;\n\tctx.authuser = session?.data?.username;\n\tctx.authacl = session?.acls;\n\n\tnode = tree;\n\n\tfor (let s in ctx.path) {\n\t\tnode = node.children[s];\n\t\tassert(node, \"Internal node resolve error\");\n\t}\n\n\treturn { node, ctx, session };\n}\n\nfunction require_post_security(target, args) {\n\tif (target?.type == 'arcombine')\n\t\treturn require_post_security(length(args) ? target?.targets?.[1] : target?.targets?.[0], args);\n\n\tif (type(target?.post) == 'object') {\n\t\tfor (let param_name, required_val in target.post) {\n\t\t\tlet request_val = http.formvalue(param_name);\n\n\t\t\tif ((type(required_val) == 'string' && request_val != required_val) ||\n\t\t\t    (required_val == true && request_val == null))\n\t\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\treturn (target?.post == true);\n}\n\nfunction test_post_security(authtoken) {\n\tif (http.getenv(\"REQUEST_METHOD\") != \"POST\") {\n\t\thttp.status(405, \"Method Not Allowed\");\n\t\thttp.header(\"Allow\", \"POST\");\n\n\t\treturn false;\n\t}\n\n\tif (http.formvalue(\"token\") != authtoken) {\n\t\thttp.status(403, \"Forbidden\");\n\t\truntime.render(\"csrftoken\");\n\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nfunction build_url(...path) {\n\tlet url = [ http.getenv('SCRIPT_NAME') ?? '' ];\n\n\tfor (let p in path)\n\t\tif (match(p, /^[A-Za-z0-9_%.\\/,;-]+$/))\n\t\t\tpush(url, '/', p);\n\n\tif (length(url) == 1)\n\t\tpush(url, '/');\n\n\treturn join('', url);\n}\n\nfunction lookup(...segments) {\n\tlet node = menu_json();\n\tlet path = [];\n\n\tfor (let segment in segments)\n\t\tfor (let name in split(segment, '/'))\n\t\t\tpush(path, name);\n\n\tfor (let name in path) {\n\t\tnode = node.children[name];\n\n\t\tif (!node)\n\t\t\treturn null;\n\n\t\tif (node.leaf)\n\t\t\tbreak;\n\t}\n\n\treturn { node, url: build_url(...path) };\n}\n\nfunction rollback_pending() {\n\tconst now = time();\n\tconst rv = ubus.call('session', 'get', {\n\t\tubus_rpc_session: '00000000000000000000000000000000',\n\t\tkeys: [ 'rollback' ]\n\t});\n\n\tif (type(rv?.values?.rollback?.token) != 'string' ||\n\t    type(rv?.values?.rollback?.session) != 'string' ||\n\t    type(rv?.values?.rollback?.timeout) != 'int' ||\n\t    rv.values.rollback.timeout <= now)\n\t    return false;\n\n\treturn {\n\t\tremaining: rv.values.rollback.timeout - now,\n\t\tsession: rv.values.rollback.session,\n\t\ttoken: rv.values.rollback.token\n\t};\n}\n\nlet dispatch;\n\nfunction render_action(fn) {\n\tconst data = render(fn);\n\n\thttp.write_headers();\n\thttp.output(data);\n}\n\nfunction run_action(request_path, lang, tree, resolved, action) {\n\tswitch (action?.type) {\n\tcase 'template':\n\t\tif (runtime.is_ucode_template(action.path))\n\t\t\truntime.render(action.path, {});\n\t\telse\n\t\t\trender_action(() => {\n\t\t\t\truntime.call('luci.dispatcher', 'render_lua_template', action.path);\n\t\t\t});\n\t\tbreak;\n\n\tcase 'view':\n\t\truntime.render('view', { view: action.path });\n\t\tbreak;\n\n\tcase 'call':\n\t\trender_action(() => {\n\t\t\truntime.call(action.module, action.function,\n\t\t\t\t...(action.parameters ?? []),\n\t\t\t\t...resolved.ctx.request_args\n\t\t\t);\n\t\t});\n\t\tbreak;\n\n\tcase 'function':\n\t\tconst mod = require(action.module);\n\n\t\tassert(type(mod[action.function]) == 'function',\n\t\t\t`Module '${action.module}' does not export function '${action.function}'`);\n\n\t\trender_action(() => {\n\t\t\tcall(mod[action.function], mod, runtime.env,\n\t\t\t\t...(action.parameters ?? []),\n\t\t\t\t...resolved.ctx.request_args\n\t\t\t);\n\t\t});\n\t\tbreak;\n\n\tcase 'cbi':\n\t\trender_action(() => {\n\t\t\truntime.call('luci.dispatcher', 'invoke_cbi_action',\n\t\t\t\taction.path, null,\n\t\t\t\t...resolved.ctx.request_args\n\t\t\t);\n\t\t});\n\t\tbreak;\n\n\tcase 'form':\n\t\trender_action(() => {\n\t\t\truntime.call('luci.dispatcher', 'invoke_form_action',\n\t\t\t\taction.path,\n\t\t\t\t...resolved.ctx.request_args\n\t\t\t);\n\t\t});\n\t\tbreak;\n\n\tcase 'alias':\n\t\tdispatch(http, [ ...split(action.path, '/'), ...resolved.ctx.request_args ]);\n\t\tbreak;\n\n\tcase 'rewrite':\n\t\tdispatch(http, [\n\t\t\t...splice([ ...request_path ], 0, action.remove),\n\t\t\t...split(action.path, '/'),\n\t\t\t...resolved.ctx.request_args\n\t\t]);\n\t\tbreak;\n\n\tcase 'firstchild':\n\t\tif (!length(tree.children))\n\t\t\terror404(\"No root node was registered, this usually happens if no module was installed.\\n\" +\n\t\t\t         \"Install luci-mod-admin-full and retry. \" +\n\t\t\t         \"If the module is already installed, try removing the /tmp/luci-indexcache file.\");\n\t\telse\n\t\t\terror404(`No page is registered at '/${entityencode(join(\"/\", resolved.ctx.request_path))}'.\\n` +\n\t\t\t         \"If this url belongs to an extension, make sure it is properly installed.\\n\" +\n\t\t\t         \"If the extension was recently installed, try removing the /tmp/luci-indexcache file.\");\n\t\tbreak;\n\n\tdefault:\n\t\terror500(`Unhandled action type ${action?.type ?? '?'}`);\n\t}\n}\n\ndispatch = function(_http, path) {\n\thttp = _http;\n\n\tlet version = determine_version();\n\tlet lang = determine_request_language();\n\n\truntime = runtime || LuCIRuntime({\n\t\thttp,\n\t\tubus,\n\t\tuci,\n\t\tctx: {},\n\t\tversion,\n\t\tconfig: {\n\t\t\tmain: uci.get_all('luci', 'main') ?? {},\n\t\t\tapply: uci.get_all('luci', 'apply') ?? {}\n\t\t},\n\t\tdispatcher: {\n\t\t\trollback_pending,\n\t\t\tis_authenticated,\n\t\t\tload_luabridge,\n\t\t\tlookup,\n\t\t\tmenu_json,\n\t\t\tbuild_url,\n\t\t\trandomid,\n\t\t\terror404,\n\t\t\terror500,\n\t\t\tlang\n\t\t},\n\t\tstriptags,\n\t\tentityencode,\n\t\t_: (...args) => translate(...args) ?? args[0],\n\t\tN_: (...args) => ntranslate(...args) ?? (n[0] == 1 ? n[1] : n[2]),\n\t});\n\n\ttry {\n\t\tlet menu = menu_json();\n\n\t\tpath ??= map(match(http.getenv('PATH_INFO'), /[^\\/]+/g), m => urldecode(m[0]));\n\n\t\tlet resolved = resolve_page(menu, path);\n\n\t\truntime.env.ctx = resolved.ctx;\n\t\truntime.env.dispatched = resolved.node;\n\t\truntime.env.requested ??= resolved.node;\n\n\t\tif (length(resolved.ctx.auth)) {\n\t\t\tlet session = is_authenticated(resolved.ctx.auth);\n\n\t\t\tif (!session && resolved.ctx.auth.login) {\n\t\t\t\tlet user = http.getenv('HTTP_AUTH_USER');\n\t\t\t\tlet pass = http.getenv('HTTP_AUTH_PASS');\n\n\t\t\t\tif (user == null && pass == null) {\n\t\t\t\t\tuser = http.formvalue('luci_username');\n\t\t\t\t\tpass = http.formvalue('luci_password');\n\t\t\t\t}\n\n\t\t\t\tif (user != null && pass != null)\n\t\t\t\t\tsession = session_setup(user, pass, resolved.ctx.request_path);\n\n\t\t\t\tif (!session) {\n\t\t\t\t\tresolved.ctx.path = [];\n\n\t\t\t\t\thttp.status(403, 'Forbidden');\n\t\t\t\t\thttp.header('X-LuCI-Login-Required', 'yes');\n\n\t\t\t\t\tlet scope = { duser: 'root', fuser: user };\n\t\t\t\t\tlet theme_sysauth = `themes/${basename(runtime.env.media)}/sysauth`;\n\n\t\t\t\t\tif (runtime.is_ucode_template(theme_sysauth) || runtime.is_lua_template(theme_sysauth)) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\treturn runtime.render(theme_sysauth, scope);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (e) {\n\t\t\t\t\t\t\truntime.env.media_error = `${e}`;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn runtime.render('sysauth', scope);\n\t\t\t\t}\n\n\t\t\t\tlet cookie_name = (http.getenv('HTTPS') == 'on') ? 'sysauth_https' : 'sysauth_http',\n\t\t\t\t    cookie_secure = (http.getenv('HTTPS') == 'on') ? '; secure' : '';\n\n\t\t\t\thttp.header('Set-Cookie', `${cookie_name}=${session.sid}; path=${build_url()}; SameSite=strict; HttpOnly${cookie_secure}`);\n\t\t\t\thttp.redirect(build_url(...resolved.ctx.request_path));\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (!session) {\n\t\t\t\thttp.status(403, 'Forbidden');\n\t\t\t\thttp.header('X-LuCI-Login-Required', 'yes');\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tresolved.ctx.authsession ??= session.sid;\n\t\t\tresolved.ctx.authtoken ??= session.data?.token;\n\t\t\tresolved.ctx.authuser ??= session.data?.username;\n\t\t\tresolved.ctx.authacl ??= session.acls;\n\n\t\t\t/* In case the Lua runtime was already initialized, e.g. by probing legacy\n\t\t\t * theme header templates, make sure to update the session ID of the uci\n\t\t\t * module. */\n\t\t\tif (runtime.L) {\n\t\t\t\truntime.L.invoke('require', 'luci.model.uci');\n\t\t\t\truntime.L.get('luci', 'model', 'uci').invoke('set_session_id', session.sid);\n\t\t\t}\n\t\t}\n\n\t\tif (length(resolved.ctx.acls)) {\n\t\t\tlet perm = check_acl_depends(resolved.ctx.acls, resolved.ctx.authacl?.['access-group']);\n\n\t\t\tif (perm == null) {\n\t\t\t\thttp.status(403, 'Forbidden');\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (resolved.node)\n\t\t\t\tresolved.node.readonly = !perm;\n\t\t}\n\n\t\tlet action = resolved.node.action;\n\n\t\tif (action?.type == 'arcombine')\n\t\t\taction = length(resolved.ctx.request_args) ? action.targets?.[1] : action.targets?.[0];\n\n\t\tif (resolved.ctx.cors && http.getenv('REQUEST_METHOD') == 'OPTIONS') {\n\t\t\thttp.status(200, 'OK');\n\t\t\thttp.header('Access-Control-Allow-Origin', http.getenv('HTTP_ORIGIN') ?? '*');\n\t\t\thttp.header('Access-Control-Allow-Methods', 'GET, POST, OPTIONS');\n\n\t\t\treturn;\n\t\t}\n\n\t\tif (require_post_security(action) && !test_post_security(resolved.ctx.authtoken))\n\t\t\treturn;\n\n\t\trun_action(path, lang, menu, resolved, action);\n\t}\n\tcatch (ex) {\n\t\terror500('Unhandled exception during request dispatching', ex);\n\t}\n};\n\nexport default dispatch;\n", "{#\n Copyright 2022 Jo-Philipp Wich <jo@mein.io>\n Licensed to the public under the Apache License 2.0.\n-#}\n\n{%\n\tinclude(`themes/${theme}/header`);\n-%}\n\n<script type=\"text/javascript\" src=\"{{ resource }}/promis.min.js\"></script>\n<script type=\"text/javascript\" src=\"{{ resource }}/luci.js\"></script>\n<script type=\"text/javascript\">\n\tL = new LuCI({{ replace(`${ {\n\t\tmedia          : media,\n\t\tresource       : resource,\n\t\tscriptname     : http.getenv(\"SCRIPT_NAME\"),\n\t\tpathinfo       : http.getenv(\"PATH_INFO\"),\n\t\tdocumentroot   : http.getenv(\"DOCUMENT_ROOT\"),\n\t\trequestpath    : ctx.request_path,\n\t\tdispatchpath   : ctx.path,\n\t\tpollinterval   : +config.main.pollinterval || 5,\n\t\tubuspath       : config.main.ubuspath || '/ubus/',\n\t\tsessionid      : ctx.authsession,\n\t\ttoken          : ctx.authtoken,\n\t\tnodespec       : dispatched,\n\t\tapply_rollback : max(+config.apply.rollback ||  90, 90),\n\t\tapply_holdoff  : max(+config.apply.holdoff  ||   4,  1),\n\t\tapply_timeout  : max(+config.apply.timeout  ||   5,  1),\n\t\tapply_display  : max(+config.apply.display  || 1.5,  1),\n\t\trollback_token : rollback_token\n\t} }`, '/', '\\\\/') }});\n</script>\n"], "filenames": ["modules/luci-base/ucode/dispatcher.uc", "modules/luci-base/ucode/template/header.ut"], "buggy_code_start_loc": [848, 13], "buggy_code_end_loc": [849, 32], "fixing_code_start_loc": [848, 13], "fixing_code_end_loc": [849, 32], "type": "CWE-79", "message": "A vulnerability, which was classified as problematic, has been found in X-WRT luci up to 22.10_b202303061504. This issue affects the function run_action of the file modules/luci-base/ucode/dispatcher.uc of the component 404 Error Template Handler. The manipulation of the argument request_path leads to cross site scripting. The attack may be initiated remotely. Upgrading to version 22.10_b202303121313 is able to address this issue. The patch is named 24d7da2416b9ab246825c33c213fe939a89b369c. It is recommended to upgrade the affected component. The associated identifier of this vulnerability is VDB-230663.", "other": {"cve": {"id": "CVE-2023-3085", "sourceIdentifier": "cna@vuldb.com", "published": "2023-06-03T11:15:21.443", "lastModified": "2024-02-29T01:40:21.803", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "A vulnerability, which was classified as problematic, has been found in X-WRT luci up to 22.10_b202303061504. This issue affects the function run_action of the file modules/luci-base/ucode/dispatcher.uc of the component 404 Error Template Handler. The manipulation of the argument request_path leads to cross site scripting. The attack may be initiated remotely. Upgrading to version 22.10_b202303121313 is able to address this issue. The patch is named 24d7da2416b9ab246825c33c213fe939a89b369c. It is recommended to upgrade the affected component. The associated identifier of this vulnerability is VDB-230663."}, {"lang": "es", "value": "Se ha encontrado una vulnerabilidad, clasificada como problem\u00e1tica, en X-WRT luci hasta la versi\u00f3n 22.10_b202303061504. Este problema afecta a la funci\u00f3n \"run_action\" del archivo \"modules/luci-base/ucode/dispatcher.uc\" del componente \"404 Error Template Handler\". La manipulaci\u00f3n del argumento \"request_path\" conduce a Cross-Site Scripting. El ataque puede iniciarse de forma remota. La actualizaci\u00f3n a la versi\u00f3n 22.10_b202303121313 soluciona este problema. El nombre del parche es 24d7da2416b9ab246825c33c213fe939a89b369c. Se recomienda actualizar el componente afectado. El identificador asociado de esta vulnerabilidad es VDB-230663."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.7}, {"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:R/S:U/C:N/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 3.5, "baseSeverity": "LOW"}, "exploitabilityScore": 2.1, "impactScore": 1.4}], "cvssMetricV2": [{"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 4.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}, {"source": "cna@vuldb.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:x-wrt:luci:*:*:*:*:*:*:*:*", "versionEndExcluding": "22.10_b202303121313", "matchCriteriaId": "09A24A0C-F67C-41C5-AAAB-144C49FB5110"}]}]}], "references": [{"url": "https://github.com/x-wrt/luci/commit/24d7da2416b9ab246825c33c213fe939a89b369c", "source": "cna@vuldb.com", "tags": ["Patch"]}, {"url": "https://github.com/x-wrt/luci/releases/tag/22.10_b202303121313", "source": "cna@vuldb.com", "tags": ["Release Notes"]}, {"url": "https://vuldb.com/?ctiid.230663", "source": "cna@vuldb.com", "tags": ["Permissions Required", "Third Party Advisory"]}, {"url": "https://vuldb.com/?id.230663", "source": "cna@vuldb.com", "tags": ["Permissions Required", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/x-wrt/luci/commit/24d7da2416b9ab246825c33c213fe939a89b369c"}}