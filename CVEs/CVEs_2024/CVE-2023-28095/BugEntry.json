{"buggy_code": ["/*\n * Copyright (C) 2001-2003 FhG Fokus\n * Copyright (C) 2006 Andreas Granig <agranig@linguin.org>\n *   ( covers insert_path_as_route() )\n *\n * This file is part of opensips, a free SIP server.\n *\n * opensips is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version\n *\n * opensips is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301  USA\n *\n * History:\n * --------\n * 2003-01-20  bug_fix: use of return value of snprintf aligned to C99 (jiri)\n * 2003-01-23  added rport patches, contributed by\n *              Maxim Sobolev <sobomax@FreeBSD.org> and heavily modified by me\n *              (andrei)\n * 2003-01-24  added i param to via of outgoing requests (used by tcp),\n *              modified via_builder params (andrei)\n * 2003-01-27  more rport fixes (make use of new via_param->start)  (andrei)\n * 2003-01-27  next baby-step to removing ZT - PRESERVE_ZT (jiri)\n * 2003-01-29  scratchpad removed (jiri)\n * 2003-02-28  scratchpad compatibility abandoned (jiri)\n * 2003-03-01  VOICE_MAIL defs removed (jiri)\n * 2003-03-06  totags in outgoing replies bookmarked to enable\n *             ACK/200 tag matching (andrei)\n * 2003-03-18  killed the build_warning snprintf (andrei)\n * 2003-03-31  added subst lump support (andrei)\n * 2003-04-01  added opt (conditional) lump support (andrei)\n * 2003-04-02  added more subst lumps: SUBST_{SND,RCV}_ALL\n *              => ip:port;transport=proto (andrei)\n * 2003-04-12  added FL_FORCE_RPORT support (andrei)\n * 2003-04-13  updated warning builder -- fixed (andrei)\n * 2003-07-10  check_via_address knows now how to compare with ipv6 address\n *              references (e.g [::1]) (andrei)\n *             build_req_fomr_sip_req no longer adds 1 for ipv6 via parameter\n *              position calculations ([] are part of host.s now) (andrei)\n * 2003-10-02  via+lump dst address/port can be set to preset values (andrei)\n * 2003-10-08  receive_test function-alized (jiri)\n * 2003-10-20  added body_lump list (sip_msg), adjust_clen (andrei & jan)\n * 2003-11-11  type of rpl_lumps replaced by flags (bogdan)\n * 2007-02-22  insert_path_as_route() imported from TM as we need it for\n *             stateless processing also; contributed by Andreas Granig\n *             (bogdan)\n */\n\n/*!\n * \\file\n * \\brief Create and translate SIP messages/ message contents\n * - \\ref ViaSpecialParams\n */\n\n/*! \\page ViaSpecialParams Via header special parameters\n *\n * Via special params:\n *\n * \\section requests Requests:\n * - if the address in via is different from the src_ip or an existing\n *   received=something is found, received=src_ip is added (and any preexisting\n *   received is deleted). received is added as the first via parameter if no\n *   receive is previously present or over the old receive.\n * - if the original via contains rport / rport=something or msg->msg_flags\n *   FL_FORCE_RPORT is set (e.g. script force_rport() cmd) rport=src_port\n *   is added (over previous rport / as first via param or after received\n *   if no received was present and received is added too)\n * \\section localreplies Local replies:\n *    (see also sl_send_reply)\n *  - rport and received are added in mostly the same way as for requests, but\n *    in the reverse order (first rport and then received). See also\n *    limitations.\n *  - the local reply is sent to the message source ip address. The\n *    destination port is set to the source port if rport is present or\n *    FL_FORCE_RPORT flag is set, to the via port or to\n *    the default sip port (5060) if neither rport or via port are present.\n * \\section normalreplies \"Normal\" replies:\n *  - if received is present the message is sent to the received address else\n *    if no port is present (neither a normal via port or rport) a dns srv\n *    lookup is performed on the host part and the reply is sent to the\n *    resulting ip. If a port is present or the host part is an ip address\n *    the dns lookup will be a \"normal\" one (A or AAAA).\n *  - if rport is present, it's value will be used as the destination port\n *   (and this will also disable srv lookups)\n *  - if no port is present the destination port will be taken from the srv\n *    lookup. If the srv lookup fails or is not performed (e.g. ip address\n *    in host) the destination port will be set to the default sip port (5060).\n *\n * \\section limitations Known limitations:\n * - when locally replying to a message, rport and received will be appended to\n *   the via header parameters (for forwarded requests they are inserted at the\n *   beginning).\n * - a locally generated reply might get two received via parameters if a\n *   received is already present in the original message (this should not\n *   happen though, but ...)\n *\n*/\n\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netdb.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n\n#include \"msg_translator.h\"\n#include \"error.h\"\n#include \"mem/mem.h\"\n#include \"dprint.h\"\n#include \"config.h\"\n#include \"md5utils.h\"\n#include \"data_lump.h\"\n#include \"data_lump_rpl.h\"\n#include \"ip_addr.h\"\n#include \"resolve.h\"\n#include \"ut.h\"\n#include \"pt.h\"\n#include \"context.h\"\n#include \"net/trans.h\"\n\nint disable_503_translation = 0;\n\n#define append_str(_dest,_src,_len) \\\n\tdo{\\\n\t\tmemcpy( (_dest) , (_src) , (_len) );\\\n\t\t(_dest) += (_len) ;\\\n\t}while(0);\n\n#define append_str_trans(_dest,_src,_len,_msg) \\\n\tappend_str( (_dest), (_src), (_len) );\n\nextern char version[];\nextern int version_len;\n\n\n/*! \\brief check if IP address in Via != source IP address of signaling */\nint received_test( struct sip_msg *msg )\n{\n\tint rcvd;\n\n\tif(msg->via1->received !=NULL)\n\t\treturn 1;\n\n\tif(msg->via1->maddr){\n\t\trcvd = check_ip_address(&msg->rcv.src_ip, &msg->via1->maddr->value,\n\t\t\tmsg->via1->port, msg->via1->proto, received_dns);\n\t} else {\n\t\trcvd = check_ip_address(&msg->rcv.src_ip,\n\t\t\t&msg->via1->host, msg->via1->port, msg->via1->proto, received_dns);\n\t}\n\n\treturn rcvd;\n}\n\n\nstatic char * warning_builder( struct sip_msg *msg, unsigned int *returned_len)\n{\n\tstatic char buf[MAX_WARNING_LEN];\n\tstr *foo;\n\tint print_len, l, clen;\n\tchar* t;\n\n#define str_print(string, string_len) \\\n\t\tdo{ \\\n\t\t\tl=(string_len); \\\n\t\t\tif ((clen+l)>MAX_WARNING_LEN) \\\n\t\t\t\tgoto error_overflow; \\\n\t\t\tmemcpy(buf+clen, (string), l); \\\n\t\t\tclen+=l; \\\n\t\t}while(0)\n\n#define str_lenpair_print(string, string_len, string2, string2_len) \\\n\t\tdo{ \\\n\t\t\tstr_print(string, string_len); \\\n\t\t\tstr_print(string2, string2_len);\\\n\t\t}while(0)\n\n#define str_pair_print( string, string2, string2_len) \\\n\t\tstr_lenpair_print((string), strlen((string)), (string2), (string2_len))\n\n#define str_int_print(string, intval)\\\n\t\tdo{\\\n\t\t\tt=int2str((intval), &print_len); \\\n\t\t\tstr_pair_print(string, t, print_len);\\\n\t\t} while(0)\n\n#define str_ipaddr_print(string, ipaddr_val)\\\n\t\tdo{\\\n\t\t\tt=ip_addr2a((ipaddr_val)); \\\n\t\t\tprint_len=strlen(t); \\\n\t\t\tstr_pair_print(string, t, print_len);\\\n\t\t} while(0)\n\n\tclen=0;\n\tstr_lenpair_print(WARNING, WARNING_LEN,\n\t\t\t\t\t\tmsg->rcv.bind_address->name.s,\n\t\t\t\t\t\tmsg->rcv.bind_address->name.len);\n\tstr_lenpair_print(\":\", 1, msg->rcv.bind_address->port_no_str.s,\n\t\t\t\t\t\tmsg->rcv.bind_address->port_no_str.len);\n\tstr_print(WARNING_PHRASE, WARNING_PHRASE_LEN);\n\n\t/*adding out_uri*/\n\tif (msg->new_uri.s)\n\t\tfoo=&(msg->new_uri);\n\telse\n\t\tfoo=&(msg->first_line.u.request.uri);\n\t/* pid= */\n\tstr_int_print(\" pid=\", my_pid());\n\t/* req_src_ip= */\n\tstr_ipaddr_print(\" req_src_ip=\", &msg->rcv.src_ip);\n\tstr_int_print(\" req_src_port=\", msg->rcv.src_port);\n\tstr_pair_print(\" in_uri=\", msg->first_line.u.request.uri.s,\n\t\t\t\t\t\t\t\tmsg->first_line.u.request.uri.len);\n\tstr_pair_print(\" out_uri=\", foo->s, foo->len);\n\tstr_pair_print(\" via_cnt\",\n\t\t\t\t(msg->parsed_flag & HDR_EOH_F)==HDR_EOH_F ? \"=\" : \">\", 1);\n\tstr_int_print(\"=\", via_cnt);\n\tif (clen<MAX_WARNING_LEN){ buf[clen]='\"'; clen++; }\n\telse goto error_overflow;\n\n\n\t*returned_len=clen;\n\treturn buf;\nerror_overflow:\n\tLM_ERR(\"buffer size exceeded\\n\");\n\t*returned_len=0;\n\treturn 0;\n}\n\n\n\n\nchar* received_builder(struct sip_msg *msg, unsigned int *received_len)\n{\n\tchar *buf, *tmp;\n\tint  len, tmp_len;\n\tstruct ip_addr *source_ip;\n\n\tsource_ip=&msg->rcv.src_ip;\n\n\tbuf=pkg_malloc(sizeof(char)*MAX_RECEIVED_SIZE);\n\tif (buf==0){\n\t\tser_error=E_OUT_OF_MEM;\n\t\tLM_ERR(\"out of pkg memory\\n\");\n\t\treturn 0;\n\t}\n\tmemcpy(buf, RECEIVED, RECEIVED_LEN);\n\tif ( (tmp=ip_addr2a(source_ip))==0)\n\t\treturn 0; /* error*/\n\ttmp_len=strlen(tmp);\n\tlen=RECEIVED_LEN+tmp_len;\n\n\tmemcpy(buf+RECEIVED_LEN, tmp, tmp_len);\n\tbuf[len]=0; /*null terminate it */\n\n\t*received_len = len;\n\treturn buf;\n}\n\n\n\nchar* rport_builder(struct sip_msg *msg, unsigned int *rport_len)\n{\n\tchar* buf, * tmp;\n\tint len, tmp_len;\n\n\ttmp_len=0;\n\ttmp=int2str(msg->rcv.src_port, &tmp_len);\n\tlen=RPORT_LEN+tmp_len;\n\tbuf=pkg_malloc(sizeof(char)*(len+1));/* space for null term */\n\tif (buf==0){\n\t\tser_error=E_OUT_OF_MEM;\n\t\tLM_ERR(\"out of pkg memory\\n\");\n\t\treturn 0;\n\t}\n\tmemcpy(buf, RPORT, RPORT_LEN);\n\tmemcpy(buf+RPORT_LEN, tmp, tmp_len);\n\tbuf[len]=0; /*null terminate it*/\n\n\t*rport_len=len;\n\treturn buf;\n}\n\n\n\nchar* id_builder(struct sip_msg* msg, unsigned int *id_len)\n{\n\tchar* buf, *p;\n\tint len, value_len, size;\n\tchar revhex[sizeof(int)*2];\n\n\tsize=sizeof(int)*2;\n\tp=&revhex[0];\n\tif (int2reverse_hex(&p, &size, msg->rcv.proto_reserved1)==-1){\n\t\tLM_CRIT(\"not enough space for id\\n\");\n\t\treturn 0;\n\t}\n\tvalue_len=p-&revhex[0];\n\tlen=ID_PARAM_LEN+value_len;\n\tbuf=pkg_malloc(sizeof(char)*(len+1));/* place for ending \\0 */\n\tif (buf==0){\n\t\tser_error=E_OUT_OF_MEM;\n\t\tLM_ERR(\"out of pkg memory\\n\");\n\t\treturn 0;\n\t}\n\tmemcpy(buf, ID_PARAM, ID_PARAM_LEN);\n\tmemcpy(buf+ID_PARAM_LEN, revhex, value_len);\n\tbuf[len]=0; /* null terminate it */\n\t*id_len=len;\n\treturn buf;\n}\n\n\n\nchar* clen_builder(struct sip_msg* msg, int *clen_len, int diff)\n{\n\tchar *buf, * value_s;\n\tint len, value, value_len;\n\tstr body;\n\n\tif ( (get_body(msg,&body)!=0) ) {\n\t\tser_error=E_BAD_REQ;\n\t\tLM_ERR(\"no message body found (missing crlf?)\");\n\t\treturn 0;\n\t}\n\tvalue = body.len + diff;\n\tvalue_s=int2str(value, &value_len);\n\tLM_DBG(\"content-length: %d (%s)\\n\", value, value_s);\n\n\tlen=CONTENT_LENGTH_LEN+value_len+CRLF_LEN;\n\tbuf=pkg_malloc(sizeof(char)*(len+1));\n\tif (buf==0){\n\t\tser_error=E_OUT_OF_MEM;\n\t\tLM_ERR(\"out of pkg memory\\n\");\n\t\treturn 0;\n\t}\n\tmemcpy(buf, CONTENT_LENGTH, CONTENT_LENGTH_LEN);\n\tmemcpy(buf+CONTENT_LENGTH_LEN, value_s, value_len);\n\tmemcpy(buf+CONTENT_LENGTH_LEN+value_len, CRLF, CRLF_LEN);\n\tbuf[len]=0; /* null terminate it */\n\t*clen_len=len;\n\treturn buf;\n}\n\n\n\n/*! \\brief* checks if a lump opt condition\n * returns 1 if cond is true, 0 if false */\nstatic inline int lump_check_opt(\tstruct lump *l,\n\t\t\t\t\t\t\t\t\tstruct sip_msg* msg,\n\t\t\t\t\t\t\t\t\tstruct socket_info* snd_s\n\t\t\t\t\t\t\t\t\t)\n{\n\tstruct ip_addr* ip;\n\tunsigned short port;\n\tint proto;\n\n#define get_ip_port_proto \\\n\t\t\tif (snd_s==0){ \\\n\t\t\t\tLM_CRIT(\"null send socket\\n\"); \\\n\t\t\t\treturn 1; /* we presume they are different :-) */ \\\n\t\t\t} \\\n\t\t\tif (msg->rcv.bind_address){ \\\n\t\t\t\tip=&msg->rcv.bind_address->address; \\\n\t\t\t\tport=msg->rcv.bind_address->port_no; \\\n\t\t\t\tproto=msg->rcv.bind_address->proto; \\\n\t\t\t}else{ \\\n\t\t\t\tip=&msg->rcv.dst_ip; \\\n\t\t\t\tport=msg->rcv.dst_port; \\\n\t\t\t\tproto=msg->rcv.proto; \\\n\t\t\t} \\\n\n\tswitch(l->u.cond){\n\t\tcase COND_FALSE:\n\t\t\treturn 0;\n\t\tcase COND_TRUE:\n\t\t\tl->flags |= LUMPFLAG_COND_TRUE;\n\t\t\treturn 1;\n\t\tcase COND_IF_DIFF_REALMS:\n\t\t\tget_ip_port_proto;\n\t\t\t/* faster tests first */\n\t\t\tif ((port==snd_s->port_no)&&(proto==snd_s->proto)&&\n\t\t\t\t(ip_addr_cmp(ip, &snd_s->address))) {\n\t\t\t\tl->flags &= ~LUMPFLAG_COND_TRUE;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tl->flags |= LUMPFLAG_COND_TRUE;\n\t\t\treturn 1;\n\t\tcase COND_IF_SAME_REALMS:\n\t\t\tget_ip_port_proto;\n\t\t\t/* faster tests first */\n\t\t\tif ((port!=snd_s->port_no)||(proto!=snd_s->proto)||\n\t\t\t\t(!ip_addr_cmp(ip, &snd_s->address))) {\n\t\t\t\tl->flags &= ~LUMPFLAG_COND_TRUE;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tl->flags |= LUMPFLAG_COND_TRUE;\n\t\t\treturn 1;\n\t\tcase COND_IF_DIFF_AF:\n\t\t\tget_ip_port_proto;\n\t\t\tif (ip->af==snd_s->address.af) {\n\t\t\t\tl->flags &= ~LUMPFLAG_COND_TRUE;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tl->flags |= LUMPFLAG_COND_TRUE;\n\t\t\treturn 1;\n\t\tcase COND_IF_DIFF_PROTO:\n\t\t\tget_ip_port_proto;\n\t\t\tif (proto==snd_s->proto) {\n\t\t\t\tl->flags &= ~LUMPFLAG_COND_TRUE;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tl->flags |= LUMPFLAG_COND_TRUE;\n\t\t\treturn 1;\n\t\tcase COND_IF_DIFF_PORT:\n\t\t\tget_ip_port_proto;\n\t\t\tif (port==snd_s->port_no) {\n\t\t\t\tl->flags &= ~LUMPFLAG_COND_TRUE;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tl->flags |= LUMPFLAG_COND_TRUE;\n\t\t\treturn 1;\n\t\tcase COND_IF_DIFF_IP:\n\t\t\tget_ip_port_proto;\n\t\t\tif (ip_addr_cmp(ip, &snd_s->address)) {\n\t\t\t\tl->flags &= ~LUMPFLAG_COND_TRUE;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tl->flags |= LUMPFLAG_COND_TRUE;\n\t\t\treturn 1;\n\t\tdefault:\n\t\t\tLM_CRIT(\"unknown lump condition %d\\n\", l->u.cond);\n\t}\n\treturn 0; /* false */\n}\n\n\n\n/*! \\brief computes the \"unpacked\" len of a lump list,\n   code moved from build_req_from_req */\nint lumps_len(struct sip_msg* msg, struct lump* lumps,\n\t\t\t\t\t\t\t\tstruct socket_info* send_sock, int max_offset)\n{\n\tunsigned int s_offset, new_len;\n\tunsigned int last_del;\n\tstruct lump *t, *r;\n\tstr *send_address_str, *send_port_str;\n\tstr *rcv_address_str=NULL;\n\tstr *rcv_port_str=NULL;\n\n#define SUBST_LUMP_LEN(subst_l) \\\n\t\tswitch((subst_l)->u.subst){ \\\n\t\t\tcase SUBST_RCV_IP: \\\n\t\t\t\tif (msg->rcv.bind_address){ \\\n\t\t\t\t\tnew_len+=rcv_address_str->len; \\\n\t\t\t\t} else \\\n\t\t\t\t\tLM_BUG(\"null bind address 1\"); \\\n\t\t\t\tbreak; \\\n\t\t\tcase SUBST_RCV_PORT: \\\n\t\t\t\tif (msg->rcv.bind_address){ \\\n\t\t\t\t\tnew_len+=rcv_port_str->len; \\\n\t\t\t\t} else \\\n\t\t\t\t\tLM_BUG(\"null bind address 2\"); \\\n\t\t\t\tbreak; \\\n\t\t\tcase SUBST_RCV_PROTO: \\\n\t\t\t\tif (msg->rcv.bind_address){ \\\n\t\t\t\t\tswitch(msg->rcv.bind_address->proto){ \\\n\t\t\t\t\t\t/* TODO change this to look in proto !*/ \\\n\t\t\t\t\t\tcase PROTO_NONE: \\\n\t\t\t\t\t\tcase PROTO_UDP: \\\n\t\t\t\t\t\tcase PROTO_TCP: \\\n\t\t\t\t\t\tcase PROTO_TLS: \\\n\t\t\t\t\t\tcase PROTO_WSS: \\\n\t\t\t\t\t\t\t\tnew_len+=3; \\\n\t\t\t\t\t\t\t\tbreak; \\\n\t\t\t\t\t\tcase PROTO_SCTP: \\\n\t\t\t\t\t\t\t\tnew_len+=4; \\\n\t\t\t\t\t\t\t\tbreak; \\\n\t\t\t\t\t\tcase PROTO_WS: \\\n\t\t\t\t\t\t\t\tnew_len+=2; \\\n\t\t\t\t\t\t\t\tbreak; \\\n\t\t\t\t\t\tdefault: \\\n\t\t\t\t\t\tLM_CRIT(\"unknown proto %d\\n\", \\\n\t\t\t\t\t\t\t\tmsg->rcv.bind_address->proto); \\\n\t\t\t\t\t}\\\n\t\t\t\t} else \\\n\t\t\t\t\tLM_BUG(\"null bind address 3\"); \\\n\t\t\t\tbreak; \\\n\t\t\tcase SUBST_RCV_ALL: \\\n\t\t\t\tif (msg->rcv.bind_address){ \\\n\t\t\t\t\tnew_len+=rcv_address_str->len; \\\n\t\t\t\t\tif (msg->rcv.bind_address->port_no!=SIP_PORT || (rcv_port_str!=&(msg->rcv.bind_address->port_no_str))){ \\\n\t\t\t\t\t\t/* add :port_no */ \\\n\t\t\t\t\t\tnew_len+=1+rcv_port_str->len; \\\n\t\t\t\t\t}\\\n\t\t\t\t\t\t/*add;transport=xxx*/ \\\n\t\t\t\t\tswitch(msg->rcv.bind_address->proto){ \\\n\t\t\t\t\t\tcase PROTO_NONE: \\\n\t\t\t\t\t\tcase PROTO_UDP: \\\n\t\t\t\t\t\t\t\tbreak; /* udp is the default */ \\\n\t\t\t\t\t\tcase PROTO_TCP: \\\n\t\t\t\t\t\tcase PROTO_TLS: \\\n\t\t\t\t\t\tcase PROTO_WSS: \\\n\t\t\t\t\t\t\t\tnew_len+=TRANSPORT_PARAM_LEN+3; \\\n\t\t\t\t\t\t\t\tbreak; \\\n\t\t\t\t\t\tcase PROTO_SCTP: \\\n\t\t\t\t\t\t\t\tnew_len+=TRANSPORT_PARAM_LEN+4; \\\n\t\t\t\t\t\t\t\tbreak; \\\n\t\t\t\t\t\tcase PROTO_WS: \\\n\t\t\t\t\t\t\t\tnew_len+=TRANSPORT_PARAM_LEN+2; \\\n\t\t\t\t\t\t\t\tbreak; \\\n\t\t\t\t\t\tdefault: \\\n\t\t\t\t\t\tLM_CRIT(\"unknown proto %d\\n\", \\\n\t\t\t\t\t\t\t\tmsg->rcv.bind_address->proto); \\\n\t\t\t\t\t}\\\n\t\t\t\t} else \\\n\t\t\t\t\tLM_BUG(\"null bind address 4\"); \\\n\t\t\t\tbreak; \\\n\t\t\tcase SUBST_SND_IP: \\\n\t\t\t\tif (send_sock){ \\\n\t\t\t\t\tnew_len+=send_address_str->len; \\\n\t\t\t\t} else \\\n\t\t\t\t\tLM_BUG(\"null send_socket 1\"); \\\n\t\t\t\tbreak; \\\n\t\t\tcase SUBST_SND_PORT: \\\n\t\t\t\tif (send_sock){ \\\n\t\t\t\t\tnew_len+=send_port_str->len; \\\n\t\t\t\t} else \\\n\t\t\t\t\tLM_BUG(\"null send_socket 2\"); \\\n\t\t\t\tbreak; \\\n\t\t\tcase SUBST_SND_PROTO: \\\n\t\t\t\tif (send_sock){ \\\n\t\t\t\t\tswitch(send_sock->proto){ \\\n\t\t\t\t\t\tcase PROTO_NONE: \\\n\t\t\t\t\t\tcase PROTO_UDP: \\\n\t\t\t\t\t\tcase PROTO_TCP: \\\n\t\t\t\t\t\tcase PROTO_TLS: \\\n\t\t\t\t\t\tcase PROTO_WSS: \\\n\t\t\t\t\t\t\t\tnew_len+=3; \\\n\t\t\t\t\t\t\t\tbreak; \\\n\t\t\t\t\t\tcase PROTO_SCTP: \\\n\t\t\t\t\t\t\t\tnew_len+=4; \\\n\t\t\t\t\t\t\t\tbreak; \\\n\t\t\t\t\t\tcase PROTO_WS: \\\n\t\t\t\t\t\t\t\tnew_len+=2; \\\n\t\t\t\t\t\t\t\tbreak; \\\n\t\t\t\t\t\tdefault: \\\n\t\t\t\t\t\tLM_CRIT(\"unknown proto %d\\n\", \\\n\t\t\t\t\t\t\t\tsend_sock->proto); \\\n\t\t\t\t\t}\\\n\t\t\t\t} else \\\n\t\t\t\t\tLM_BUG(\"null send_socket 3\"); \\\n\t\t\t\tbreak; \\\n\t\t\tcase SUBST_SND_ALL: \\\n\t\t\t\tif (send_sock){ \\\n\t\t\t\t\tnew_len+=send_address_str->len; \\\n\t\t\t\t\tif ((send_sock->port_no!=SIP_PORT) || \\\n\t\t\t\t\t\t\t(send_port_str!=&(send_sock->port_no_str))){ \\\n\t\t\t\t\t\t/* add :port_no */ \\\n\t\t\t\t\t\tnew_len+=1+send_port_str->len; \\\n\t\t\t\t\t}\\\n\t\t\t\t\t/*add;transport=xxx*/ \\\n\t\t\t\t\tswitch(send_sock->proto){ \\\n\t\t\t\t\t\tcase PROTO_NONE: \\\n\t\t\t\t\t\tcase PROTO_UDP: \\\n\t\t\t\t\t\t\t\tbreak; /* udp is the default */ \\\n\t\t\t\t\t\tcase PROTO_TCP: \\\n\t\t\t\t\t\tcase PROTO_TLS: \\\n\t\t\t\t\t\tcase PROTO_WSS: \\\n\t\t\t\t\t\t\t\tnew_len+=TRANSPORT_PARAM_LEN+3; \\\n\t\t\t\t\t\t\t\tbreak; \\\n\t\t\t\t\t\tcase PROTO_SCTP: \\\n\t\t\t\t\t\t\t\tnew_len+=TRANSPORT_PARAM_LEN+4; \\\n\t\t\t\t\t\t\t\tbreak; \\\n\t\t\t\t\t\tcase PROTO_WS: \\\n\t\t\t\t\t\t\t\tnew_len+=TRANSPORT_PARAM_LEN+2; \\\n\t\t\t\t\t\t\t\tbreak; \\\n\t\t\t\t\t\tdefault: \\\n\t\t\t\t\t\tLM_CRIT(\"unknown proto %d\\n\", \\\n\t\t\t\t\t\t\t\tsend_sock->proto); \\\n\t\t\t\t\t}\\\n\t\t\t\t} else \\\n\t\t\t\t\tLM_BUG(\"null send_socket 4\"); \\\n\t\t\t\tbreak; \\\n\t\t\tcase SUBST_NOP: /* do nothing */ \\\n\t\t\t\tbreak; \\\n\t\t\tdefault: \\\n\t\t\t\tLM_CRIT(\"unknown subst type %d\\n\", \\\n\t\t\t\t\t\t(subst_l)->u.subst); \\\n\t\t}\n\n\n\ts_offset=0;\n\tnew_len=0;\n\tlast_del=0;\n\n\t/* init send_address_str & send_port_str */\n\tif(send_sock && send_sock->adv_name_str.len)\n\t\tsend_address_str=&(send_sock->adv_name_str);\n\telse if (msg->set_global_address.s)\n\t\tsend_address_str=&(msg->set_global_address);\n\telse if (default_global_address->s)\n\t\tsend_address_str=default_global_address;\n\telse\n\t\tsend_address_str=&(send_sock->address_str);\n\n\tif(send_sock && send_sock->adv_port_str.len)\n\t\tsend_port_str=&(send_sock->adv_port_str);\n\telse if (msg->set_global_port.s)\n\t\tsend_port_str=&(msg->set_global_port);\n\telse if (default_global_port->s)\n\t\tsend_port_str=default_global_port;\n\telse\n\t\tsend_port_str=&(send_sock->port_no_str);\n\n\t/* init rcv_address_str & rcv_port_str */\n\tif(msg->rcv.bind_address) {\n\t\tif(msg->rcv.bind_address->adv_name_str.len)\n\t\t\trcv_address_str=&(msg->rcv.bind_address->adv_name_str);\n\t\telse if (default_global_address->s)\n\t\t\trcv_address_str=default_global_address;\n\t\telse\n\t\t\trcv_address_str=&(msg->rcv.bind_address->address_str);\n\t\tif(msg->rcv.bind_address->adv_port_str.len)\n\t\t\trcv_port_str=&(msg->rcv.bind_address->adv_port_str);\n\t\telse if (default_global_port->s)\n\t\t\trcv_port_str=default_global_port;\n\t\telse\n\t\t\trcv_port_str=&(msg->rcv.bind_address->port_no_str);\n\t}\n\n\tfor (t = lumps; t && t->u.offset<(unsigned int)max_offset ; t = t->next) {\n\t\t/* is this lump still valid? (it must not be anchored in a deleted area */\n\t\tif (t->u.offset < s_offset && t->u.offset != last_del) {\n\t\t\tLM_DBG(\"skip a %d, buffer offset=%d, lump offset=%d, last_del=%d\\n\",\n\t\t\t\tt->op,s_offset, t->u.offset,last_del);\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor (r = t->before; r; r = r->before) {\n\t\t\tswitch (r->op) {\n\t\t\t\tcase LUMP_ADD:\n\t\t\t\t\tnew_len += r->len;\n\t\t\t\t\tbreak;\n\t\t\t\tcase LUMP_ADD_SUBST:\n\t\t\t\t\tSUBST_LUMP_LEN(r);\n\t\t\t\t\tbreak;\n\t\t\t\tcase LUMP_ADD_OPT:\n\t\t\t\t\t/* skip if this is an OPT lump and the condition is\n\t\t\t\t\t * not satisfied */\n\t\t\t\t\tif (!lump_check_opt(r, msg, send_sock))\n\t\t\t\t\t\tgoto skip_before;\n\t\t\t\t\tbreak;\n\t\t\t\tcase LUMP_SKIP:\n\t\t\t\t\t/* if a SKIP lump, go to the last in the list*/\n\t\t\t\t\tif (!r->before || !r->before->before)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tfor (; r->before->before; r = r->before)\n\t\t\t\t\t\t;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\t/* only ADD allowed for before/after */\n\t\t\t\t\t\tLM_CRIT(\"invalid op for data lump (%x)\\n\", r->op);\n\t\t\t}\n\t\t}\nskip_before:\n\t\tswitch (t->op) {\n\t\t\tcase LUMP_DEL:\n\t\t\t\tlast_del=t->u.offset;\n\n\t\t\t\tif (t->u.offset < s_offset) {\n\t\t\t\t\tif (t->u.offset + t->len > s_offset) {\n\t\t\t\t\t\tnew_len -= t->len - (s_offset - t->u.offset);\n\t\t\t\t\t\ts_offset = t->u.offset + t->len;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tnew_len -= t->len;\n\t\t\t\t\ts_offset = t->u.offset + t->len;\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\tcase LUMP_NOP:\n\t\t\t\t/* do nothing */\n\t\t\t\tbreak;\n\t\t\tcase LUMP_ADD:\n\t\t\t\t/* FIXME: inconsistent with process_lumps() */\n\t\t\t\tnew_len += t->len;\n\t\t\t\tbreak;\n\t\t\tcase LUMP_ADD_OPT:\n\t\t\t\tLM_BUG(\"LUMP_ADD_OPT\");\n\t\t\t\t/* we don't do anything here, it's only a condition for\n\t\t\t\t * before & after */\n\t\t\t\tbreak;\n\t\t\tcase LUMP_SKIP:\n\t\t\t\tLM_BUG(\"LUMP_SKIP\");\n\t\t\t\t/* we don't do anything here, it's only a condition for\n\t\t\t\t * before & after */\n\t\t\t\tbreak;\n\t\t\tcase LUMP_ADD_SUBST:\n\t\t\t\tLM_BUG(\"LUMP_ADD_SUBST\");\n\t\t\t\tSUBST_LUMP_LEN(t);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tLM_BUG(\"op for data lump (%x)\", r->op);\n\t\t}\n\n\t\tfor (r = t->after; r; r = r->after) {\n\t\t\tswitch (r->op) {\n\t\t\t\tcase LUMP_ADD:\n\t\t\t\t\tnew_len+=r->len;\n\t\t\t\t\tbreak;\n\t\t\t\tcase LUMP_ADD_SUBST:\n\t\t\t\t\tSUBST_LUMP_LEN(r);\n\t\t\t\t\tbreak;\n\t\t\t\tcase LUMP_ADD_OPT:\n\t\t\t\t\t/* skip if this is an OPT lump and the condition is\n\t\t\t\t\t * not satisfied */\n\t\t\t\t\tif (!lump_check_opt(r, msg, send_sock))\n\t\t\t\t\t\tgoto skip_after;\n\t\t\t\t\tbreak;\n\t\t\t\tcase LUMP_SKIP:\n\t\t\t\t\t/* if a SKIP lump, go to the last in the list*/\n\t\t\t\t\tif (!r->after || !r->after->after)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tfor (; r->after->after; r = r->after)\n\t\t\t\t\t\t;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\t/* only ADD allowed for before/after */\n\t\t\t\t\tLM_CRIT(\"invalid op for data lump (%x)\\n\", r->op);\n\t\t\t}\n\t\t}\nskip_after:\n\t\t; /* to make gcc 3.* happy */\n\t}\n\treturn new_len;\n}\n\n\n\n/*! \\brief another helper functions, adds/Removes the lump,\n\tcode moved from build_req_from_req  */\n\nvoid process_lumps(\tstruct sip_msg* msg,\n\t\t\t\t\tstruct lump* lumps,\n\t\t\t\t\tchar* new_buf,\n\t\t\t\t\tunsigned int* new_buf_offs,\n\t\t\t\t\tunsigned int* orig_offs,\n\t\t\t\t\tstruct socket_info* send_sock,\n\t\t\t\t\tint max_offset)\n{\n\tstruct lump *t, *r;\n\tchar* orig;\n\tunsigned int size, offset, s_offset;\n\tunsigned int last_del;\n\tstr *send_address_str, *send_port_str;\n\tstr *rcv_address_str=NULL;\n\tstr *rcv_port_str=NULL;\n\n#define SUBST_LUMP(subst_l) \\\n\tswitch((subst_l)->u.subst){ \\\n\t\tcase SUBST_RCV_IP: \\\n\t\t\tif (msg->rcv.bind_address){  \\\n\t\t\t\tmemcpy(new_buf+offset, rcv_address_str->s, \\\n\t\t\t\t\trcv_address_str->len); \\\n\t\t\t\toffset+=rcv_address_str->len; \\\n\t\t\t}else{  \\\n\t\t\t\t/*FIXME*/ \\\n\t\t\t\tLM_CRIT(\"null bind_address\\n\"); \\\n\t\t\t}; \\\n\t\t\tbreak; \\\n\t\tcase SUBST_RCV_PORT: \\\n\t\t\tif (msg->rcv.bind_address){  \\\n\t\t\t\tmemcpy(new_buf+offset, rcv_port_str->s, \\\n\t\t\t\t\t\trcv_port_str->len); \\\n\t\t\t\toffset+=rcv_port_str->len; \\\n\t\t\t}else{  \\\n\t\t\t\t/*FIXME*/ \\\n\t\t\t\tLM_CRIT(\"null bind_address\\n\"); \\\n\t\t\t}; \\\n\t\t\tbreak; \\\n\t\tcase SUBST_RCV_ALL: \\\n\t\t\tif (msg->rcv.bind_address){  \\\n\t\t\t\t/* address */ \\\n\t\t\t\tmemcpy(new_buf+offset, rcv_address_str->s, \\\n\t\t\t\t\t\trcv_address_str->len); \\\n\t\t\t\toffset+=rcv_address_str->len; \\\n\t\t\t\t/* :port */ \\\n\t\t\t\tif (msg->rcv.bind_address->port_no!=SIP_PORT || (rcv_port_str!=&(msg->rcv.bind_address->port_no_str))){ \\\n\t\t\t\t\tnew_buf[offset]=':'; offset++; \\\n\t\t\t\t\tmemcpy(new_buf+offset, \\\n\t\t\t\t\t\t\trcv_port_str->s, \\\n\t\t\t\t\t\t\trcv_port_str->len); \\\n\t\t\t\t\toffset+=rcv_port_str->len; \\\n\t\t\t\t}\\\n\t\t\t\tswitch(msg->rcv.bind_address->proto){ \\\n\t\t\t\t\t/* TODO: change this to look into protos ! */ \\\n\t\t\t\t\tcase PROTO_NONE: \\\n\t\t\t\t\tcase PROTO_UDP: \\\n\t\t\t\t\t\tbreak; /* nothing to do, udp is default*/ \\\n\t\t\t\t\tcase PROTO_TCP: \\\n\t\t\t\t\t\tmemcpy(new_buf+offset, TRANSPORT_PARAM, \\\n\t\t\t\t\t\t\t\tTRANSPORT_PARAM_LEN); \\\n\t\t\t\t\t\toffset+=TRANSPORT_PARAM_LEN; \\\n\t\t\t\t\t\tmemcpy(new_buf+offset, \"tcp\", 3); \\\n\t\t\t\t\t\toffset+=3; \\\n\t\t\t\t\t\tbreak; \\\n\t\t\t\t\tcase PROTO_TLS: \\\n\t\t\t\t\t\tmemcpy(new_buf+offset, TRANSPORT_PARAM, \\\n\t\t\t\t\t\t\t\tTRANSPORT_PARAM_LEN); \\\n\t\t\t\t\t\toffset+=TRANSPORT_PARAM_LEN; \\\n\t\t\t\t\t\tmemcpy(new_buf+offset, \"tls\", 3); \\\n\t\t\t\t\t\toffset+=3; \\\n\t\t\t\t\t\tbreak; \\\n\t\t\t\t\tcase PROTO_SCTP: \\\n\t\t\t\t\t\tmemcpy(new_buf+offset, TRANSPORT_PARAM, \\\n\t\t\t\t\t\t\t\tTRANSPORT_PARAM_LEN); \\\n\t\t\t\t\t\toffset+=TRANSPORT_PARAM_LEN; \\\n\t\t\t\t\t\tmemcpy(new_buf+offset, \"sctp\", 4); \\\n\t\t\t\t\t\toffset+=4; \\\n\t\t\t\t\t\tbreak; \\\n\t\t\t\t\tcase PROTO_WS: \\\n\t\t\t\t\t\tmemcpy(new_buf+offset, TRANSPORT_PARAM, \\\n\t\t\t\t\t\t\t\tTRANSPORT_PARAM_LEN); \\\n\t\t\t\t\t\toffset+=TRANSPORT_PARAM_LEN; \\\n\t\t\t\t\t\tmemcpy(new_buf+offset, \"ws\", 2); \\\n\t\t\t\t\t\toffset+=2; \\\n\t\t\t\t\t\tbreak; \\\n\t\t\t\t\tcase PROTO_WSS: \\\n\t\t\t\t\t\tmemcpy(new_buf+offset, TRANSPORT_PARAM, \\\n\t\t\t\t\t\t\t\tTRANSPORT_PARAM_LEN); \\\n\t\t\t\t\t\toffset+=TRANSPORT_PARAM_LEN; \\\n\t\t\t\t\t\tmemcpy(new_buf+offset, \"wss\", 3); \\\n\t\t\t\t\t\toffset+=3; \\\n\t\t\t\t\t\tbreak; \\\n\t\t\t\t\tdefault: \\\n\t\t\t\t\t\tLM_CRIT(\"unknown proto %d\\n\", \\\n\t\t\t\t\t\t\t\tmsg->rcv.bind_address->proto); \\\n\t\t\t\t} \\\n\t\t\t}else{  \\\n\t\t\t\t/*FIXME*/ \\\n\t\t\t\tLM_CRIT(\"null bind_address\\n\"); \\\n\t\t\t}; \\\n\t\t\tbreak; \\\n\t\tcase SUBST_SND_IP: \\\n\t\t\tif (send_sock){  \\\n\t\t\t\tmemcpy(new_buf+offset, send_address_str->s, \\\n\t\t\t\t\t\t\t\t\tsend_address_str->len); \\\n\t\t\t\toffset+=send_address_str->len; \\\n\t\t\t}else{  \\\n\t\t\t\t/*FIXME*/ \\\n\t\t\t\tLM_CRIT(\"called with null send_sock\\n\"); \\\n\t\t\t}; \\\n\t\t\tbreak; \\\n\t\tcase SUBST_SND_PORT: \\\n\t\t\tif (send_sock){  \\\n\t\t\t\tmemcpy(new_buf+offset, send_port_str->s, \\\n\t\t\t\t\t\t\t\t\tsend_port_str->len); \\\n\t\t\t\toffset+=send_port_str->len; \\\n\t\t\t}else{  \\\n\t\t\t\t/*FIXME*/ \\\n\t\t\t\tLM_CRIT(\"called with null send_sock\\n\"); \\\n\t\t\t}; \\\n\t\t\tbreak; \\\n\t\tcase SUBST_SND_ALL: \\\n\t\t\tif (send_sock){  \\\n\t\t\t\t/* address */ \\\n\t\t\t\tmemcpy(new_buf+offset, send_address_str->s, \\\n\t\t\t\t\t\tsend_address_str->len); \\\n\t\t\t\toffset+=send_address_str->len; \\\n\t\t\t\t/* :port */ \\\n\t\t\t\tif ((send_sock->port_no!=SIP_PORT) || \\\n\t\t\t\t\t(send_port_str!=&(send_sock->port_no_str))){ \\\n\t\t\t\t\tnew_buf[offset]=':'; offset++; \\\n\t\t\t\t\tmemcpy(new_buf+offset, send_port_str->s, \\\n\t\t\t\t\t\t\tsend_port_str->len); \\\n\t\t\t\t\toffset+=send_port_str->len; \\\n\t\t\t\t}\\\n\t\t\t\tswitch(send_sock->proto){ \\\n\t\t\t\t\tcase PROTO_NONE: \\\n\t\t\t\t\tcase PROTO_UDP: \\\n\t\t\t\t\t\tbreak; /* nothing to do, udp is default*/ \\\n\t\t\t\t\tcase PROTO_TCP: \\\n\t\t\t\t\t\tmemcpy(new_buf+offset, TRANSPORT_PARAM, \\\n\t\t\t\t\t\t\t\tTRANSPORT_PARAM_LEN); \\\n\t\t\t\t\t\toffset+=TRANSPORT_PARAM_LEN; \\\n\t\t\t\t\t\tmemcpy(new_buf+offset, \"tcp\", 3); \\\n\t\t\t\t\t\toffset+=3; \\\n\t\t\t\t\t\tbreak; \\\n\t\t\t\t\tcase PROTO_TLS: \\\n\t\t\t\t\t\tmemcpy(new_buf+offset, TRANSPORT_PARAM, \\\n\t\t\t\t\t\t\t\tTRANSPORT_PARAM_LEN); \\\n\t\t\t\t\t\toffset+=TRANSPORT_PARAM_LEN; \\\n\t\t\t\t\t\tmemcpy(new_buf+offset, \"tls\", 3); \\\n\t\t\t\t\t\toffset+=3; \\\n\t\t\t\t\t\tbreak; \\\n\t\t\t\t\tcase PROTO_SCTP: \\\n\t\t\t\t\t\tmemcpy(new_buf+offset, TRANSPORT_PARAM, \\\n\t\t\t\t\t\t\t\tTRANSPORT_PARAM_LEN); \\\n\t\t\t\t\t\toffset+=TRANSPORT_PARAM_LEN; \\\n\t\t\t\t\t\tmemcpy(new_buf+offset, \"sctp\", 4); \\\n\t\t\t\t\t\toffset+=4; \\\n\t\t\t\t\t\tbreak; \\\n\t\t\t\t\tcase PROTO_WS: \\\n\t\t\t\t\t\tmemcpy(new_buf+offset, TRANSPORT_PARAM, \\\n\t\t\t\t\t\t\t\tTRANSPORT_PARAM_LEN); \\\n\t\t\t\t\t\toffset+=TRANSPORT_PARAM_LEN; \\\n\t\t\t\t\t\tmemcpy(new_buf+offset, \"ws\", 2); \\\n\t\t\t\t\t\toffset+=2; \\\n\t\t\t\t\t\tbreak; \\\n\t\t\t\t\tcase PROTO_WSS: \\\n\t\t\t\t\t\tmemcpy(new_buf+offset, TRANSPORT_PARAM, \\\n\t\t\t\t\t\t\t\tTRANSPORT_PARAM_LEN); \\\n\t\t\t\t\t\toffset+=TRANSPORT_PARAM_LEN; \\\n\t\t\t\t\t\tmemcpy(new_buf+offset, \"wss\", 3); \\\n\t\t\t\t\t\toffset+=3; \\\n\t\t\t\t\t\tbreak; \\\n\t\t\t\t\tdefault: \\\n\t\t\t\t\t\tLM_CRIT(\"unknown proto %d\\n\", \\\n\t\t\t\t\t\t\t\tsend_sock->proto); \\\n\t\t\t\t} \\\n\t\t\t}else{  \\\n\t\t\t\t/*FIXME*/ \\\n\t\t\t\tLM_CRIT(\"null bind_address\\n\"); \\\n\t\t\t}; \\\n\t\t\tbreak; \\\n\t\tcase SUBST_RCV_PROTO: \\\n\t\t\tif (msg->rcv.bind_address){ \\\n\t\t\t\tswitch(msg->rcv.bind_address->proto){ \\\n\t\t\t\t\tcase PROTO_NONE: \\\n\t\t\t\t\tcase PROTO_UDP: \\\n\t\t\t\t\t\tmemcpy(new_buf+offset, \"udp\", 3); \\\n\t\t\t\t\t\toffset+=3; \\\n\t\t\t\t\t\tbreak; \\\n\t\t\t\t\tcase PROTO_TCP: \\\n\t\t\t\t\t\tmemcpy(new_buf+offset, \"tcp\", 3); \\\n\t\t\t\t\t\toffset+=3; \\\n\t\t\t\t\t\tbreak; \\\n\t\t\t\t\tcase PROTO_TLS: \\\n\t\t\t\t\t\tmemcpy(new_buf+offset, \"tls\", 3); \\\n\t\t\t\t\t\toffset+=3; \\\n\t\t\t\t\t\tbreak; \\\n\t\t\t\t\tcase PROTO_SCTP: \\\n\t\t\t\t\t\tmemcpy(new_buf+offset, \"sctp\", 4); \\\n\t\t\t\t\t\toffset+=4; \\\n\t\t\t\t\t\tbreak; \\\n\t\t\t\t\tcase PROTO_WS: \\\n\t\t\t\t\t\tmemcpy(new_buf+offset, \"ws\", 2); \\\n\t\t\t\t\t\toffset+=2; \\\n\t\t\t\t\t\tbreak; \\\n\t\t\t\t\tcase PROTO_WSS: \\\n\t\t\t\t\t\tmemcpy(new_buf+offset, \"wss\", 3); \\\n\t\t\t\t\t\toffset+=3; \\\n\t\t\t\t\t\tbreak; \\\n\t\t\t\t\tdefault: \\\n\t\t\t\t\t\tLM_CRIT(\"unknown proto %d\\n\", \\\n\t\t\t\t\t\t\t\tmsg->rcv.bind_address->proto); \\\n\t\t\t\t} \\\n\t\t\t}else{  \\\n\t\t\t\t/*FIXME*/ \\\n\t\t\t\tLM_CRIT(\"called with null send_sock \\n\"); \\\n\t\t\t}; \\\n\t\t\tbreak; \\\n\t\tcase  SUBST_SND_PROTO: \\\n\t\t\tif (send_sock){ \\\n\t\t\t\tswitch(send_sock->proto){ \\\n\t\t\t\t\tcase PROTO_NONE: \\\n\t\t\t\t\tcase PROTO_UDP: \\\n\t\t\t\t\t\tmemcpy(new_buf+offset, \"udp\", 3); \\\n\t\t\t\t\t\toffset+=3; \\\n\t\t\t\t\t\tbreak; \\\n\t\t\t\t\tcase PROTO_TCP: \\\n\t\t\t\t\t\tmemcpy(new_buf+offset, \"tcp\", 3); \\\n\t\t\t\t\t\toffset+=3; \\\n\t\t\t\t\t\tbreak; \\\n\t\t\t\t\tcase PROTO_TLS: \\\n\t\t\t\t\t\tmemcpy(new_buf+offset, \"tls\", 3); \\\n\t\t\t\t\t\toffset+=3; \\\n\t\t\t\t\t\tbreak; \\\n\t\t\t\t\tcase PROTO_SCTP: \\\n\t\t\t\t\t\tmemcpy(new_buf+offset, \"sctp\", 4); \\\n\t\t\t\t\t\toffset+=4; \\\n\t\t\t\t\t\tbreak; \\\n\t\t\t\t\tcase PROTO_WS: \\\n\t\t\t\t\t\tmemcpy(new_buf+offset, \"ws\", 2); \\\n\t\t\t\t\t\toffset+=2; \\\n\t\t\t\t\t\tbreak; \\\n\t\t\t\t\tcase PROTO_WSS: \\\n\t\t\t\t\t\tmemcpy(new_buf+offset, \"wss\", 3); \\\n\t\t\t\t\t\toffset+=3; \\\n\t\t\t\t\t\tbreak; \\\n\t\t\t\t\tdefault: \\\n\t\t\t\t\t\tLM_CRIT(\"unknown proto %d\\n\", \\\n\t\t\t\t\t\t\t\tsend_sock->proto); \\\n\t\t\t\t} \\\n\t\t\t}else{  \\\n\t\t\t\t/*FIXME*/ \\\n\t\t\t\tLM_CRIT(\"called with null send_sock \\n\"); \\\n\t\t\t}; \\\n\t\t\tbreak; \\\n\t\tdefault: \\\n\t\t\t\t\tLM_CRIT(\"unknown subst type %d\\n\", \\\n\t\t\t\t\t\t\t(subst_l)->u.subst); \\\n\t} \\\n \\\n\n\t/* init send_address_str & send_port_str */\n\tif(send_sock && send_sock->adv_name_str.len)\n\t\tsend_address_str=&(send_sock->adv_name_str);\n\telse if (msg->set_global_address.len)\n\t\tsend_address_str=&(msg->set_global_address);\n\telse if (default_global_address->s)\n\t\tsend_address_str=default_global_address;\n\telse\n\t\tsend_address_str=&(send_sock->address_str);\n\tif(send_sock && send_sock->adv_port_str.len)\n\t\tsend_port_str=&(send_sock->adv_port_str);\n\telse if (msg->set_global_port.len)\n\t\tsend_port_str=&(msg->set_global_port);\n\telse if (default_global_port->s)\n\t\tsend_port_str=default_global_port;\n\telse\n\t\tsend_port_str=&(send_sock->port_no_str);\n\n\t/* init rcv_address_str & rcv_port_str */\n\tif(msg->rcv.bind_address) {\n\t\tif(msg->rcv.bind_address->adv_name_str.len)\n\t\t\trcv_address_str=&(msg->rcv.bind_address->adv_name_str);\n\t\telse if (default_global_address->s)\n\t\t\trcv_address_str=default_global_address;\n\t\telse\n\t\t\trcv_address_str=&(msg->rcv.bind_address->address_str);\n\t\tif(msg->rcv.bind_address->adv_port_str.len)\n\t\t\trcv_port_str=&(msg->rcv.bind_address->adv_port_str);\n\t\telse if (default_global_port->s)\n\t\t\trcv_port_str=default_global_port;\n\t\telse\n\t\t\trcv_port_str=&(msg->rcv.bind_address->port_no_str);\n\t}\n\n\torig=msg->buf;\n\toffset=*new_buf_offs;\n\ts_offset=*orig_offs;\n\tlast_del=0;\n\n\tfor (t = lumps; t && t->u.offset<(unsigned int)max_offset ; t = t->next) {\n\t\t/* skip this lump if the \"offset\" is still in a \"deleted\" area */\n\t\tif (t->u.offset < s_offset && t->u.offset != last_del) {\n\t\t\tLM_DBG(\"skip a %d, buffer offset=%d, lump offset=%d, last_del=%d\\n\",\n\t\t\t\tt->op,s_offset, t->u.offset,last_del);\n\t\t\tcontinue;\n\t\t}\n\n\t\tswitch (t->op) {\n\t\t\tcase LUMP_NOP:\n\t\t\tcase LUMP_DEL:\n\t\t\t\t/* copy till offset (if any) */\n\t\t\t\tif (s_offset < t->u.offset) {\n\t\t\t\t\tsize = t->u.offset-s_offset;\n\t\t\t\t\tmemcpy(new_buf+offset, orig+s_offset, size);\n\t\t\t\t\toffset += size;\n\t\t\t\t\ts_offset += size;\n\t\t\t\t}\n\n\t\t\t\tif (t->op == LUMP_DEL)\n\t\t\t\t\tlast_del = t->u.offset;\n\n\t\t\t\t/* process before  */\n\t\t\t\tfor (r = t->before; r; r = r->before) {\n\t\t\t\t\tswitch (r->op) {\n\t\t\t\t\t\tcase LUMP_ADD:\n\t\t\t\t\t\t\t/*just add it here*/\n\t\t\t\t\t\t\tmemcpy(new_buf+offset, r->u.value, r->len);\n\t\t\t\t\t\t\toffset += r->len;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase LUMP_ADD_SUBST:\n\t\t\t\t\t\t\tSUBST_LUMP(r);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase LUMP_ADD_OPT:\n\t\t\t\t\t\t\t/* skip if this is an OPT lump and the condition is\n\t\t\t\t\t \t\t* not satisfied */\n\t\t\t\t\t\t\tif (!lump_check_opt(r, msg, send_sock))\n\t\t\t\t\t\t\t\tgoto skip_nop_before;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase LUMP_SKIP:\n\t\t\t\t\t\t\t/* if a SKIP lump, go to the last in the list*/\n\t\t\t\t\t\t\tif (!r->before || !r->before->before)\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\tfor (; r->before->before; r = r->before)\n\t\t\t\t\t\t\t\t;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t/* only ADD allowed for before/after */\n\t\t\t\t\t\t\tLM_BUG(\"invalid op 1 (%x)\",r->op);\n\t\t\t\t\t}\n\t\t\t\t}\nskip_nop_before:\n\t\t\t\tif (t->op == LUMP_DEL) {\n\t\t\t\t\t/*\n\t\t\t\t\t * skip at most len bytes from orig msg\n\t\t\t\t\t * and properly handle DEL lumps at the same offset --liviu\n\t\t\t\t\t */\n\t\t\t\t\tif (t->u.offset + t->len > s_offset)\n\t\t\t\t\t\ts_offset += t->len - (s_offset - t->u.offset);\n\t\t\t\t}\n\n\t\t\t\t/* process after */\n\t\t\t\tfor (r = t->after; r; r = r->after) {\n\t\t\t\t\tswitch (r->op) {\n\t\t\t\t\t\tcase LUMP_ADD:\n\t\t\t\t\t\t\t/*just add it here*/\n\t\t\t\t\t\t\tmemcpy(new_buf+offset, r->u.value, r->len);\n\t\t\t\t\t\t\toffset += r->len;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase LUMP_ADD_SUBST:\n\t\t\t\t\t\t\tSUBST_LUMP(r);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase LUMP_ADD_OPT:\n\t\t\t\t\t\t\t/* skip if this is an OPT lump and the condition is\n\t\t\t\t\t \t\t* not satisfied */\n\t\t\t\t\t\t\tif (!lump_check_opt(r, msg, send_sock))\n\t\t\t\t\t\t\t\tgoto skip_nop_after;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase LUMP_SKIP:\n\t\t\t\t\t\t\t/* if a SKIP lump, go to the last in the list*/\n\t\t\t\t\t\t\tif (!r->after || !r->after->after)\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\tfor (; r->after->after; r = r->after)\n\t\t\t\t\t\t\t\t;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t/* only ADD allowed for before/after */\n\t\t\t\t\t\t\tLM_BUG(\"invalid op 2 (%x)\", r->op);\n\t\t\t\t\t}\n\t\t\t\t}\nskip_nop_after:\n\t\t\t\tbreak;\n\t\t\tcase LUMP_ADD:\n\t\t\tcase LUMP_ADD_SUBST:\n\t\t\tcase LUMP_ADD_OPT:\n\t\t\t\tLM_BUG(\"ADD|SUBST|OPT\");\n\t\t\t\t/* skip if this is an OPT lump and the condition is\n\t\t\t\t * not satisfied */\n\t\t\t\tif ((t->op==LUMP_ADD_OPT) &&\n\t\t\t\t\t\t(!lump_check_opt(t, msg, send_sock)))\n\t\t\t\t\tcontinue;\n\t\t\t\t/* just add it here! */\n\t\t\t\t/* process before  */\n\t\t\t\tfor(r=t->before;r;r=r->before){\n\t\t\t\t\tswitch (r->op){\n\t\t\t\t\t\tcase LUMP_ADD:\n\t\t\t\t\t\t\t/*just add it here*/\n\t\t\t\t\t\t\tmemcpy(new_buf+offset, r->u.value, r->len);\n\t\t\t\t\t\t\toffset+=r->len;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase LUMP_ADD_SUBST:\n\t\t\t\t\t\t\tSUBST_LUMP(r);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase LUMP_ADD_OPT:\n\t\t\t\t\t\t\t/* skip if this is an OPT lump and the condition is\n\t\t\t\t\t \t\t* not satisfied */\n\t\t\t\t\t\t\tif (!lump_check_opt(r, msg, send_sock))\n\t\t\t\t\t\t\t\tgoto skip_before;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase LUMP_SKIP:\n\t\t\t\t\t\t\t/* if a SKIP lump, go to the last in the list*/\n\t\t\t\t\t\t\tif (!r->before || !r->before->before) continue;\n\t\t\t\t\t\t\tfor(;r->before->before;r=r->before);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t/* only ADD allowed for before/after */\n\t\t\t\t\t\t\tLM_BUG(\"invalid op 3 (%x)\", r->op);\n\t\t\t\t\t}\n\t\t\t\t}\nskip_before:\n\t\t\t\t/* copy \"main\" part */\n\t\t\t\tswitch(t->op){\n\t\t\t\t\tcase LUMP_ADD:\n\t\t\t\t\t\tmemcpy(new_buf+offset, t->u.value, t->len);\n\t\t\t\t\t\toffset+=t->len;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase LUMP_ADD_SUBST:\n\t\t\t\t\t\tSUBST_LUMP(t);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase LUMP_ADD_OPT:\n\t\t\t\t\t\t/* do nothing, it's only a condition */\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\t/* should not ever get here */\n\t\t\t\t\t\tLM_BUG(\"invalid op 4 %d\", t->op);\n\t\t\t\t}\n\t\t\t\t/* process after */\n\t\t\t\tfor(r=t->after;r;r=r->after){\n\t\t\t\t\tswitch (r->op){\n\t\t\t\t\t\tcase LUMP_ADD:\n\t\t\t\t\t\t\t/*just add it here*/\n\t\t\t\t\t\t\tmemcpy(new_buf+offset, r->u.value, r->len);\n\t\t\t\t\t\t\toffset+=r->len;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase LUMP_ADD_SUBST:\n\t\t\t\t\t\t\tSUBST_LUMP(r);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase LUMP_ADD_OPT:\n\t\t\t\t\t\t\t/* skip if this is an OPT lump and the condition is\n\t\t\t\t\t \t\t* not satisfied */\n\t\t\t\t\t\t\tif (!lump_check_opt(r, msg, send_sock))\n\t\t\t\t\t\t\t\tgoto skip_after;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase LUMP_SKIP:\n\t\t\t\t\t\t\t/* if a SKIP lump, go to the last in the list*/\n\t\t\t\t\t\t\tif (!r->after || !r->after->after) continue;\n\t\t\t\t\t\t\tfor(;r->after->after;r=r->after);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t/* only ADD allowed for before/after */\n\t\t\t\t\t\t\tLM_BUG(\"invalid op 5 (%x)\", r->op);\n\t\t\t\t\t}\n\t\t\t\t}\nskip_after:\n\t\t\t\tbreak;\n\t\t\tcase LUMP_SKIP:\n\t\t\t\tLM_BUG(\"LUMP_SKIP\");\n\t\t\t\t/* if a SKIP lump, go to the last in the list*/\n\t\t\t\tif (!t->next || !t->next->next)\n\t\t\t\t\tcontinue;\n\t\t\t\tfor (; t->next->next; t = t->next)\n\t\t\t\t\t;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tLM_BUG(\"invalid op 6 (%x)\", t->op);\n\t\t}\n\t}\n\n\t*new_buf_offs = offset;\n\t*orig_offs = s_offset;\n}\n\n\n/* Prepares a body to be re-assembled. This consists of the following ops:\n *   - run the functions to build the parts (if the case)\n *   - add SIP header lumps to change CT header \n *   - estimating the new len of the body (after applying all the changes)\n * IMPORTANT: keep this function in sync with the reassemble_body_parts()\n *    to be 100% that estimating and building the body leads to the same\n *    result (as len).\n */\nunsigned int prep_reassemble_body_parts( struct sip_msg* msg,\n\t\t\t\t\t\t\t\t\t\t\t\tstruct socket_info* send_sock)\n{\n\tstruct body_part *part;\n\tstruct lump* lump;\n\tstruct lump* ct;\n\tunsigned int size;\n\tunsigned int len = 0;\n\tunsigned int orig_offs;\n\tstruct hdr_field hf;\n\tchar *hdr, *it;\n\n\t/* set the offset (in the original buffer) at the beginning of the body */\n\torig_offs = msg->body->part_count ? msg->body->body.s-msg->buf : msg->len ;\n\n\tif (msg->body->updated_part_count==0) {\n\n\t\t/* no body to be placed in the new msg !\n\t\t * simply skip the entire body */\n\t\tLM_DBG(\"no part to be added\\n\");\n\n\t\t/* Remove Content-Type hdr if present */\n\t\tif (msg->content_type && msg->content_type->name.s\n\t\t&& msg->content_type->name.len\n\t\t&& del_lump(msg, msg->content_type->name.s- msg->buf,\n\t\tmsg->content_type->len, HDR_CONTENTTYPE_T)==0) {\n\t\t\tLM_ERR(\"failed to add lump to delete content type header\\n\");\n\t\t}\n\n\t} else if (msg->body->updated_part_count==1) {\n\n\t\t/* there is only one part to be added, so iterate\n\t\t * and find it */\n\t\tLM_DBG(\"only one part to be added\\n\");\n\n\t\tfor( part=&msg->body->first ; part ; part=part->next)\n\t\t\tif ( (part->flags & SIP_BODY_PART_FLAG_DELETED)==0 ) break;\n\n\t\tif (part==NULL) {\n\t\t\tLM_BUG(\"updated count is 1, but no non-deleted part found :-/\\n\");\n\t\t\treturn len /* 0 */;\n\t\t}\n\n\t\tLM_DBG(\"handing part with flags %x, mime %.*s, dump function %p\\n\",\n\t\t\tpart->flags, part->mime_s.len, part->mime_s.s, part->dump_f);\n\n\t\tif (part->dump_f) {\n\t\t\t/* trigger the the dump function link the resulting buffer\n\t\t\t * as 'dump' (and to be used and freed when the body buffer\n\t\t\t * is actually built) */\n\t\t\tif (part->dump_f( part->parsed ,msg, &part->dump)<0) {\n\t\t\t\tLM_ERR(\"failed to build part, inserting empty\\n\");\n\t\t\t\tpart->dump.s = \"\";\n\t\t\t\tpart->dump.len = 0;\n\t\t\t} else\n\t\t\t\tlen += part->dump.len;\n\t\t} else {\n\t\t\tif ( part->flags & SIP_BODY_PART_FLAG_NEW ) {\n\t\t\t\t/* simpy copy the body of the part */\n\t\t\t\tlen += part->body.len;\n\t\t\t} else {\n\t\t\t\t/* this is one part that was received (so potentially\n\t\t\t\t * modified during runtime) -> apply all body lumps\n\t\t\t\t * inside this part */\n\t\t\t\torig_offs = part->body.s - msg->buf;\n\t\t\t\tlump = msg->body_lumps;\n\t\t\t\twhile ( lump && lump->u.offset<(part->body.s-msg->buf) )\n\t\t\t\t\tlump=lump->next;\n\t\t\t\tif (lump) {\n\t\t\t\t\tLM_DBG(\"lumps found in the part, applying...\\n\");\n\t\t\t\t\tlen += lumps_len( msg, lump, send_sock, \n\t\t\t\t\t\tpart->body.s+part->body.len-msg->buf);\n\t\t\t\t}\n\t\t\t\t/* and copy whatever is left, all the way to the end of part */\n\t\t\t\tlen += (part->body.s+part->body.len-msg->buf)-orig_offs;\n\t\t\t}\n\t\t}\n\n\t\t/* if the part is new (0->1 addition or 1->1 replacement) or\n\t\t * if the part is kept from a stipped multi-part  (n->1)\n\t\t *   =>  replace the msg content-type with the new one */\n\t\tif ( (part->flags & SIP_BODY_PART_FLAG_NEW)\n\t\t|| msg->body->part_count>1 ) {\n\t\t\t/* replace the Content-Type hdr */\n\t\t\tif (msg->content_type)\n\t\t\t\tct = del_lump(msg, msg->content_type->name.s-msg->buf,\n\t\t\t\t\tmsg->content_type->len, HDR_CONTENTTYPE_T);\n\t\t\telse\n\t\t\t\tct = anchor_lump(msg, msg->unparsed - msg->buf,\n\t\t\t\t\tHDR_CONTENTTYPE_T);\n\t\t\tif (ct==NULL) {\n\t\t\t\tLM_ERR(\"failed to remove old CT / create anchor\\n\");\n\t\t\t} else {\n\t\t\t\t/* if a new part, we need to build the CT header; if a \n\t\t\t\t * received part, simply copied from the part */\n\t\t\t\tif (part->flags & SIP_BODY_PART_FLAG_NEW) {\n\t\t\t\t\thdr = (char*)pkg_malloc( 14 + part->mime_s.len +CRLF_LEN +\n\t\t\t\t\t\tpart->headers.len);\n\t\t\t\t\tif (hdr==NULL) {\n\t\t\t\t\t\tLM_ERR(\"failed to allocate new ct hdr\\n\");\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmemcpy( hdr, \"Content-Type: \", 14);\n\t\t\t\t\t\tmemcpy( hdr+14, part->mime_s.s, part->mime_s.len);\n\t\t\t\t\t\tmemcpy( hdr+14+part->mime_s.len, CRLF, CRLF_LEN);\n\t\t\t\t\t\tif (part->headers.len)\n\t\t\t\t\t\t\tmemcpy( hdr+14+part->mime_s.len+CRLF_LEN,\n\t\t\t\t\t\t\t\tpart->headers.s, part->headers.len);\n\t\t\t\t\t\tif (insert_new_lump_before(ct, hdr,\n\t\t\t\t\t\t14+part->mime_s.len+CRLF_LEN+part->headers.len,\n\t\t\t\t\t\tHDR_CONTENTTYPE_T) == NULL) {\n\t\t\t\t\t\t\tLM_ERR(\"failed to create insert lump\\n\");\n\t\t\t\t\t\t\tpkg_free(hdr);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t/* iterate all the SIP hdrs from this part and keep all\n\t\t\t\t\t * except the \"Content-Length\" */\n\t\t\t\t\tit = part->headers.s;\n\t\t\t\t\twhile ( it<part->headers.s+part->headers.len ) {\n\t\t\t\t\t\tmemset( &hf, 0, sizeof(struct hdr_field));\n\t\t\t\t\t\tit = get_hdr_field( it, part->headers.s+part->headers.len, &hf);\n\t\t\t\t\t\tif (hf.type==HDR_ERROR_T || hf.type==HDR_EOH_T)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tif (hf.type==HDR_CONTENTLENGTH_T)\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t/* add this hdr */\n\t\t\t\t\t\thdr = (char*)pkg_malloc( hf.len);\n\t\t\t\t\t\tif (hdr==NULL) {\n\t\t\t\t\t\t\tLM_ERR(\"failed to allocate new ct hdr\\n\");\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tmemcpy( hdr, hf.name.s, hf.len);\n\t\t\t\t\t\t\tif (insert_new_lump_before(ct, hdr,\n\t\t\t\t\t\t\thf.len, HDR_CONTENTTYPE_T) == NULL) {\n\t\t\t\t\t\t\t\tLM_ERR(\"failed to create insert lump\\n\");\n\t\t\t\t\t\t\t\tpkg_free(hdr);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else\n\t\t\t/* if it is an 1->1 keeping the part, try to preserve the\n\t\t\t * the packing (multi-part or not) of this part */\n\t\t\tif ( (part->flags & SIP_BODY_PART_FLAG_NEW)==0 &&\n\t\t\tmsg->body->part_count==1 &&\n\t\t\tmsg->body->flags & SIP_BODY_RCV_MULTIPART) {\n\t\t\t\t/* preserve the original multi-part packing by preserving\n\t\t\t\t * the before and after padding between part and body */\n\t\t\t\tlen += msg->body->body.len - part->body.len;\n\t\t\t}\n\n\t} else if (msg->body->part_count<2) {\n\n\t\t/* transition from 0/1 to multiple parts,\n\t\t * so we need to add boundries */\n\n\t\tLM_DBG(\"transition from 0/1 parts to multi part body\\n\");\n\t\tlump = msg->body_lumps;\n\n\t\tfor( part=&msg->body->first ; part ; part=part->next) {\n\n\t\t\tLM_DBG(\"handing part with flags %x, mime %.*s, dump function %p\\n\",\n\t\t\t\tpart->flags, part->mime_s.len, part->mime_s.s, part->dump_f);\n\n\t\t\t/* skip deleted parts */\n\t\t\tif ( (part->flags & SIP_BODY_PART_FLAG_DELETED) ) {\n\t\t\t\tif ((part->flags & SIP_BODY_PART_FLAG_NEW) == 0)\n\t\t\t\t\t/* reposition at the end of the skipped body */\n\t\t\t\t\torig_offs = part->body.s+part->body.len-msg->buf+CRLF_LEN;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* separator and CT header */\n\t\t\tlen += 2 /* \"--\" */ + sizeof(OSS_BOUNDARY)-1 + CRLF_LEN +\n\t\t\t 14/* \"Content-Type: \" */ + part->mime_s.len +\n\t\t\t CRLF_LEN + part->headers.len + CRLF_LEN ;\n\n\t\t\t/* part with dump function ? */\n\t\t\tif (part->dump_f) {\n\t\t\t\tif (part->dump_f( part->parsed ,msg, &part->dump)<0) {\n\t\t\t\t\tLM_ERR(\"failed to build part, inserting empty\\n\");\n\t\t\t\t\tpart->dump.s = \"\";\n\t\t\t\t\tpart->dump.len = 0;\n\t\t\t\t} else\n\t\t\t\t\tlen += part->dump.len;\n\t\t\t\tlen += CRLF_LEN;\n\t\t\t} else\n\t\t\t/* new part with body attached */\n\t\t\tif ( part->flags & SIP_BODY_PART_FLAG_NEW ) {\n\t\t\t\t/* simpy copy the body of the part */\n\t\t\t\tlen += part->body.len;\n\t\t\t\tlen += CRLF_LEN;\n\t\t\t} else\n\t\t\t/* old part with lumps */\n\t\t\t{\n\t\t\t\t/* first find the first lump inside our body part */\n\t\t\t\twhile ( lump && lump->u.offset<(part->body.s-msg->buf) )\n\t\t\t\t\tlump=lump->next;\n\t\t\t\tif (lump) {\n\t\t\t\t\tLM_DBG(\"lumps found in the part, applying...\\n\");\n\t\t\t\t\t/* apply the lumps */\n\t\t\t\t\tlen += lumps_len( msg, lump, send_sock,\n\t\t\t\t\t\tpart->body.s+part->body.len-msg->buf);\n\t\t\t\t}\n\t\t\t\t/* and copy whatever is left, all the way to the end of part */\n\t\t\t\tsize = (part->body.s+part->body.len-msg->buf)-orig_offs;\n\t\t\t\tlen += size + CRLF_LEN;\n\t\t\t}\n\n\t\t\t/* reposition at the end of the processed body */\n\t\t\tif ((part->flags & SIP_BODY_PART_FLAG_NEW) == 0)\n\t\t\t\torig_offs = part->body.s+part->body.len-msg->buf+CRLF_LEN;\n\n\t\t} /* end for(over the parts) */\n\n\t\t/* the final separator */\n\t\tlen += 2 /* \"--\" */ + sizeof(OSS_BOUNDARY)-1 + 2 /* \"--\" */ + CRLF_LEN;\n\n\t\t/* replace the Content-Type hdr */\n\t\tif (msg->content_type)\n\t\t\tct = del_lump(msg, msg->content_type->name.s-msg->buf,\n\t\t\t\tmsg->content_type->len, HDR_CONTENTTYPE_T);\n\t\telse\n\t\t\tct = anchor_lump(msg, msg->unparsed - msg->buf,\n\t\t\t\tHDR_CONTENTTYPE_T);\n\t\tif (ct==NULL) {\n\t\t\tLM_ERR(\"failed to remove old CT / create anchor\\n\");\n\t\t} else {\n\t\t\t/* \"Content-Type: multipart/mixed;boundary=OSS_BOUNDARY CRLF\" */\n\t\t\thdr = (char*)pkg_malloc( 39 + sizeof(OSS_BOUNDARY)-1 + CRLF_LEN );\n\t\t\tif (hdr==NULL) {\n\t\t\t\tLM_ERR(\"failed to allocate new ct hdr\\n\");\n\t\t\t} else {\n\t\t\t\tmemcpy( hdr,\n\t\t\t\t\"Content-Type: multipart/mixed;boundary=\" OSS_BOUNDARY CRLF,\n\t\t\t\t39 + sizeof(OSS_BOUNDARY)-1 + CRLF_LEN);\n\t\t\t\tif (insert_new_lump_before(ct, hdr,\n\t\t\t\t39 + sizeof(OSS_BOUNDARY)-1 + CRLF_LEN,\n\t\t\t\tHDR_CONTENTTYPE_T) == NULL) {\n\t\t\t\t\tLM_ERR(\"failed to create insert lump\\n\");\n\t\t\t\t\tpkg_free(hdr);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t} else {\n\n\t\t/* multi to multi parts - iterate the list, handle insert new parts,\n\t\t * remove old ones, and modify the kept ones (if the case) */\n\n\t\tLM_DBG(\"multi to multi part body reconstruction\\n\");\n\t\tlump = msg->body_lumps;\n\n\t\tfor( part=&msg->body->first ; part ; part=part->next) {\n\t\t\t/* skip deleted parts */\n\t\t\tif ( (part->flags & SIP_BODY_PART_FLAG_DELETED) ) {\n\t\t\t\tif ( (part->flags & SIP_BODY_PART_FLAG_NEW) == 0 )\n\t\t\t\t\t/* reposition at the end of the skipped body */\n\t\t\t\t\torig_offs = part->body.s+part->body.len-msg->buf+CRLF_LEN;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tLM_DBG(\"handing part with flags %x, mime %.*s, dump function %p\\n\",\n\t\t\t\tpart->flags, part->mime_s.len, part->mime_s.s, part->dump_f);\n\n\t\t\t/* new part ? */\n\t\t\tif ( part->flags & SIP_BODY_PART_FLAG_NEW ) {\n\t\t\t\t/* separator and CT header */\n\t\t\t\tlen += 2 /* \"--\" */ + msg->body->boundary.len +\n\t\t\t\t\tCRLF_LEN + 14 /* \"Content-Type: \" */ + part->mime_s.len +\n\t\t\t\t\tCRLF_LEN + part->headers.len + CRLF_LEN ;\n\t\t\t\t/* simpy copy the body of the part */\n\t\t\t\tif (part->dump_f) {\n\t\t\t\t\tif (part->dump_f( part->parsed ,msg, &part->dump)<0) {\n\t\t\t\t\t\tLM_ERR(\"failed to build part, inserting empty\\n\");\n\t\t\t\t\t\tpart->dump.s = \"\";\n\t\t\t\t\t\tpart->dump.len = 0;\n\t\t\t\t\t} else\n\t\t\t\t\t\tlen += part->dump.len;\n\t\t\t\t} else\n\t\t\t\t\tlen += part->body.len;\n\t\t\t\tlen += CRLF_LEN;\n\t\t\t} else\n\t\t\t/* old part with dump function */\n\t\t\tif (part->dump_f) {\n\t\t\t\t/* copy separator and headers from original message */\n\t\t\t\tlen += (part->body.s - msg->buf) - orig_offs;\n\t\t\t\t/* put in the new body */\n\t\t\t\tif (part->dump_f( part->parsed ,msg, &part->dump)<0) {\n\t\t\t\t\tLM_ERR(\"failed to build part, inserting empty\\n\");\n\t\t\t\t\tpart->dump.s = \"\";\n\t\t\t\t\tpart->dump.len = 0;\n\t\t\t\t} else\n\t\t\t\t\tlen += part->dump.len;\n\t\t\t\tlen += CRLF_LEN;\n\t\t\t\t/* skip the old body */\n\t\t\t} else\n\t\t\t/* old part with lumps -> apply changes */\n\t\t\t{\n\t\t\t\t/* first find the first lump inside our body part\n\t\t\t\t * NOTE: we do not need to explicitly copy the separtor and\n\t\t\t\t * the headers as they will be automatically got by the \n\t\t\t\t * first lup or by the final copy */\n\t\t\t\twhile ( lump && lump->u.offset<(part->body.s-msg->buf) )\n\t\t\t\t\tlump=lump->next;\n\t\t\t\tif (lump) {\n\t\t\t\t\tLM_DBG(\"lumps found in the part, applying...\\n\");\n\t\t\t\t\t/* apply the lumps */\n\t\t\t\t\tlen += lumps_len( msg, lump, send_sock,\n\t\t\t\t\t\t\tpart->body.s+part->body.len-msg->buf);\n\t\t\t\t}\n\t\t\t\t/* and copy whatever is left, all the way to the end of part */\n\t\t\t\tsize = (part->body.s+part->body.len-msg->buf+CRLF_LEN)-orig_offs;\n\t\t\t\tlen += size;\n\t\t\t}\n\n\t\t\t/* reposition at the end of the processed body */\n\t\t\tif ((part->flags & SIP_BODY_PART_FLAG_NEW) == 0)\n\t\t\t\torig_offs = part->body.s+part->body.len-msg->buf+CRLF_LEN;\n\t\t} /* end for(over the parts) */\n\n\t\t/* the final separator */\n\t\tsize = msg->len - orig_offs;\n\t\tlen += size;\n\n\t\t/* Content-Type hdr does not require changes in this case */\n\t}\n\n\tLM_DBG(\"resulting body len is %d\\n\",len);\n\treturn len;\n}\n\n\nvoid reassemble_body_parts( struct sip_msg* msg, char* new_buf,\n\t\t\t\t\t\tunsigned int* new_offs, unsigned int* orig_offs,\n\t\t\t\t\t\tstruct socket_info* send_sock)\n{\n\tstruct body_part *part;\n\tstruct lump* lump;\n\tunsigned int size;\n\tunsigned int offset;\n\tint padding=0;\n\n\tif (msg->body->updated_part_count==0) {\n\n\t\t/* no body to be placed in the new msg !\n\t\t * simply skip the entire body */\n\t\tLM_DBG(\"no part to be added\\n\");\n\n\t} else if (msg->body->updated_part_count==1) {\n\n\t\t/* there is only one part to be added, so iterate\n\t\t * and find it */\n\t\tLM_DBG(\"only one part to be added\\n\");\n\n\t\tfor( part=&msg->body->first ; part ; part=part->next)\n\t\t\tif ( (part->flags & SIP_BODY_PART_FLAG_DELETED)==0 ) break;\n\n\t\tif (part==NULL) {\n\t\t\tLM_BUG(\"updated count is 1, but no non-deleted part found :-/\\n\");\n\t\t\treturn;\n\t\t}\n\n\t\tLM_DBG(\"handing part with flags %x, mime %.*s, dump function %p\\n\",\n\t\t\tpart->flags, part->mime_s.len, part->mime_s.s, part->dump_f);\n\n\t\t/* handle the special case of preserving a single part which was\n\t\t * received packed as multipart -> copy the boundries as\n\t\t * received */\n\t\tif ( msg->body->flags & SIP_BODY_RCV_MULTIPART &&\n\t\tmsg->body->part_count==1 &&\n\t\t(part->flags & SIP_BODY_PART_FLAG_NEW)==0 ) {\n\t\t\t/* copy whatever is between the beginning of the msg body \n\t\t\t * and the part body*/\n\t\t\tmemcpy(new_buf+*new_offs, msg->body->body.s,\n\t\t\t\tpart->body.s-msg->body->body.s );\n\t\t\t*new_offs += part->body.s-msg->body->body.s;\n\t\t\tpadding = 1;\n\t\t}\n\n\t\tif (part->dump_f) {\n\t\t\t/* the dump function was triggered when the length was computed\n\t\t\t * and the resulting buffer was linked as 'dump' (and we need\n\t\t\t * to free it now) */\n\t\t\t/* copy the new body of the part */\n\t\t\tmemcpy(new_buf+*new_offs, part->dump.s, part->dump.len );\n\t\t\t*new_offs += part->dump.len;\n\t\t\tpkg_free(part->dump.s);\n\t\t\tpart->dump.s = NULL;\n\t\t\tpart->dump.len = 0;\n\t\t} else {\n\t\t\tif ( part->flags & SIP_BODY_PART_FLAG_NEW ) {\n\t\t\t\t/* simply copy the body of the part */\n\t\t\t\tmemcpy(new_buf+*new_offs, part->body.s, part->body.len );\n\t\t\t\t*new_offs += part->body.len;\n\t\t\t} else {\n\t\t\t\t/* this is one part that was received (so potentially\n\t\t\t\t * modified during runtime) -> apply all body lumps\n\t\t\t\t * inside this part */\n\t\t\t\t*orig_offs = part->body.s - msg->buf;\n\t\t\t\tlump = msg->body_lumps;\n\t\t\t\twhile ( lump && lump->u.offset<(part->body.s-msg->buf) )\n\t\t\t\t\tlump=lump->next;\n\t\t\t\tif (lump) {\n\t\t\t\t\tLM_DBG(\"lumps found in the part, applying...\\n\");\n\t\t\t\t\t/* apply the lumps */\n\t\t\t\t\tprocess_lumps( msg, lump, new_buf, new_offs, orig_offs,\n\t\t\t\t\t\tsend_sock, part->body.s+part->body.len-msg->buf);\n\t\t\t\t}\n\t\t\t\t/* and copy whatever is left, all the way to the end of part */\n\t\t\t\tsize = (part->body.s+part->body.len-msg->buf)-*orig_offs;\n\t\t\t\tmemcpy(new_buf+*new_offs, msg->buf+*orig_offs, size);\n\t\t\t\t*new_offs += size;\n\t\t\t}\n\t\t}\n\n\t\tif (padding) {\n\t\t\t/* copy whatever is between the end of the part body \n\t\t\t * and the end of the msg body*/\n\t\t\tmemcpy(new_buf+*new_offs, part->body.s+part->body.len,\n\t\t\t\t(msg->body->body.s+msg->body->body.len)-\n\t\t\t\t(part->body.s+part->body.len) );\n\t\t\t*new_offs += (msg->body->body.s+msg->body->body.len)-\n\t\t\t\t(part->body.s+part->body.len);\n\t\t}\n\n\t} else if (msg->body->part_count<2) {\n\n\t\t/* transition from 0/1 to multiple parts,\n\t\t * so we need to add boundries */\n\n\t\tLM_DBG(\"transition from 0/1 parts to multi part body\\n\");\n\t\toffset = *new_offs;\n\t\tlump = msg->body_lumps;\n\n\t\tfor( part=&msg->body->first ; part ; part=part->next) {\n\n\t\t\tLM_DBG(\"handing part with flags %x, mime %.*s, dump function %p\\n\",\n\t\t\t\tpart->flags, part->mime_s.len, part->mime_s.s, part->dump_f);\n\n\t\t\t/* skip deleted parts */\n\t\t\tif ( (part->flags & SIP_BODY_PART_FLAG_DELETED) ) {\n\t\t\t\tif ((part->flags & SIP_BODY_PART_FLAG_NEW) == 0)\n\t\t\t\t\t/* reposition at the end of the skipped body */\n\t\t\t\t\t*orig_offs = part->body.s+part->body.len-msg->buf+CRLF_LEN;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* separator and CT header */\n\t\t\tmemcpy(new_buf+offset, \"--\" OSS_BOUNDARY CRLF \"Content-Type: \",\n\t\t\t\t2 + sizeof(OSS_BOUNDARY)-1 + CRLF_LEN + 14);\n\t\t\toffset += 2 + sizeof(OSS_BOUNDARY)-1 + CRLF_LEN + 14;\n\t\t\tmemcpy(new_buf+offset, part->mime_s.s , part->mime_s.len);\n\t\t\toffset += part->mime_s.len;\n\t\t\tif (part->headers.len==0) {\n\t\t\t\tmemcpy(new_buf+offset, CRLF CRLF , CRLF_LEN+CRLF_LEN);\n\t\t\t\toffset += CRLF_LEN + CRLF_LEN ;\n\t\t\t} else {\n\t\t\t\tmemcpy(new_buf+offset, CRLF , CRLF_LEN);\n\t\t\t\toffset += CRLF_LEN;\n\t\t\t\tmemcpy(new_buf+offset, part->headers.s , part->headers.len);\n\t\t\t\toffset += part->headers.len ;\n\t\t\t\tmemcpy(new_buf+offset, CRLF , CRLF_LEN);\n\t\t\t\toffset += CRLF_LEN;\n\t\t\t}\n\n\t\t\t/* part with dump function ? */\n\t\t\tif (part->dump_f) {\n\t\t\t\tmemcpy(new_buf+offset, part->dump.s, part->dump.len );\n\t\t\t\toffset += part->dump.len;\n\t\t\t\tpkg_free(part->dump.s);\n\t\t\t\tpart->dump.s = NULL;\n\t\t\t\tpart->dump.len = 0;\n\t\t\t\tmemcpy(new_buf+offset, CRLF , CRLF_LEN);\n\t\t\t\toffset += CRLF_LEN;\n\t\t\t} else\n\t\t\t/* new part with body attached */\n\t\t\tif ( part->flags & SIP_BODY_PART_FLAG_NEW ) {\n\t\t\t\t/* simpy copy the body of the part */\n\t\t\t\tmemcpy(new_buf+offset, part->body.s, part->body.len );\n\t\t\t\toffset += part->body.len;\n\t\t\t\tmemcpy(new_buf+offset, CRLF , CRLF_LEN);\n\t\t\t\toffset += CRLF_LEN;\n\t\t\t} else\n\t\t\t/* old part with lumps */\n\t\t\t{\n\t\t\t\t/* first find the first lump inside our body part */\n\t\t\t\twhile ( lump && lump->u.offset<(part->body.s-msg->buf) )\n\t\t\t\t\tlump=lump->next;\n\t\t\t\tif (lump) {\n\t\t\t\t\tLM_DBG(\"lumps found in the part, applying...\\n\");\n\t\t\t\t\t/* apply the lumps */\n\t\t\t\t\tprocess_lumps( msg, lump, new_buf, &offset, orig_offs,\n\t\t\t\t\t\tsend_sock, part->body.s+part->body.len-msg->buf);\n\t\t\t\t}\n\t\t\t\t/* and copy whatever is left, all the way to the end of part */\n\t\t\t\tsize = (part->body.s+part->body.len-msg->buf)-*orig_offs;\n\t\t\t\tmemcpy(new_buf+offset, msg->buf+*orig_offs, size);\n\t\t\t\toffset += size;\n\t\t\t\tmemcpy(new_buf+offset, CRLF , CRLF_LEN);\n\t\t\t\toffset += CRLF_LEN;\n\t\t\t}\n\n\t\t\t/* reposition at the end of the processed body */\n\t\t\tif ((part->flags & SIP_BODY_PART_FLAG_NEW) == 0)\n\t\t\t\t*orig_offs = part->body.s+part->body.len-msg->buf+CRLF_LEN ;\n\n\t\t} /* end for(over the parts) */\n\n\t\t/* the final separator */\n\t\tmemcpy(new_buf+offset, \"--\" OSS_BOUNDARY \"--\" CRLF,\n\t\t\t2 + sizeof(OSS_BOUNDARY)-1 + 2 + CRLF_LEN);\n\t\toffset += 2 + sizeof(OSS_BOUNDARY)-1 + 2 + CRLF_LEN;\n\n\t\t/*done here !!*/\n\t\t*new_offs = offset;\n\n\t} else {\n\n\t\t/* multi to multi parts - iterate the list, handle insert new parts,\n\t\t * remove old ones, and modify the kept ones (if the case) */\n\t\tLM_DBG(\"multi to multi part body reconstruction\\n\");\n\n\t\toffset = *new_offs;\n\t\tlump = msg->body_lumps;\n\t\tfor( part=&msg->body->first ; part ; part=part->next) {\n\t\t\t/* skip deleted parts */\n\t\t\tif ( (part->flags & SIP_BODY_PART_FLAG_DELETED) ) {\n\t\t\t\tif ( (part->flags & SIP_BODY_PART_FLAG_NEW) == 0 )\n\t\t\t\t\t/* reposition at the end of the skipped body */\n\t\t\t\t\t*orig_offs = part->body.s+part->body.len-msg->buf+CRLF_LEN;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tLM_DBG(\"handing part with flags %x, mime %.*s, dump function %p\\n\",\n\t\t\t\tpart->flags, part->mime_s.len, part->mime_s.s, part->dump_f);\n\n\t\t\t/* new part ? */\n\t\t\tif ( part->flags & SIP_BODY_PART_FLAG_NEW ) {\n\t\t\t\t/* separator and CT header */\n\t\t\t\tmemcpy(new_buf+offset, \"--\" , 2);\n\t\t\t\toffset += 2;\n\t\t\t\tmemcpy(new_buf+offset, msg->body->boundary.s , msg->body->boundary.len);\n\t\t\t\toffset += msg->body->boundary.len;\n\t\t\t\tmemcpy(new_buf+offset, CRLF \"Content-Type: \" , CRLF_LEN+14);\n\t\t\t\toffset += CRLF_LEN + 14 ;\n\t\t\t\tmemcpy(new_buf+offset, part->mime_s.s , part->mime_s.len);\n\t\t\t\toffset += part->mime_s.len;\n\t\t\t\tif (part->headers.len==0) {\n\t\t\t\t\tmemcpy(new_buf+offset, CRLF CRLF , CRLF_LEN+CRLF_LEN);\n\t\t\t\t\toffset += CRLF_LEN + CRLF_LEN ;\n\t\t\t\t} else {\n\t\t\t\t\tmemcpy(new_buf+offset, CRLF , CRLF_LEN);\n\t\t\t\t\toffset += CRLF_LEN;\n\t\t\t\t\tmemcpy(new_buf+offset, part->headers.s , part->headers.len);\n\t\t\t\t\toffset += part->headers.len ;\n\t\t\t\t\tmemcpy(new_buf+offset, CRLF , CRLF_LEN);\n\t\t\t\t\toffset += CRLF_LEN;\n\t\t\t\t}\n\t\t\t\t/* simply copy the body of the part */\n\t\t\t\tif (part->dump_f) {\n\t\t\t\t\tmemcpy(new_buf+offset, part->dump.s, part->dump.len );\n\t\t\t\t\toffset += part->dump.len;\n\t\t\t\t\tpart->dump.s = NULL;\n\t\t\t\t\tpart->dump.len = 0;\n\t\t\t\t} else {\n\t\t\t\t\tmemcpy(new_buf+offset, part->body.s, part->body.len );\n\t\t\t\t\toffset += part->body.len;\n\t\t\t\t}\n\t\t\t\tmemcpy(new_buf+offset, CRLF , CRLF_LEN);\n\t\t\t\toffset += CRLF_LEN;\n\t\t\t} else\n\t\t\t/* old part with dump function */\n\t\t\tif (part->dump_f) {\n\t\t\t\t/* copy separator and headers from original message */\n\t\t\t\tsize = (part->body.s - msg->buf) - *orig_offs;\n\t\t\t\tmemcpy( new_buf+offset,  msg->buf+*orig_offs, size);\n\t\t\t\toffset += size;\n\t\t\t\t/* put in the new body */\n\t\t\t\tmemcpy(new_buf+offset, part->dump.s, part->dump.len );\n\t\t\t\toffset += part->dump.len;\n\t\t\t\tpkg_free(part->dump.s);\n\t\t\t\tpart->dump.s = NULL;\n\t\t\t\tpart->dump.len = 0;\n\t\t\t\tmemcpy(new_buf+offset, CRLF , CRLF_LEN);\n\t\t\t\toffset += CRLF_LEN;\n\t\t\t} else\n\t\t\t/* old part with lumps -> apply changes */\n\t\t\t{\n\t\t\t\t/* first find the first lump inside our body part\n\t\t\t\t * NOTE: we do not need to explicitly copy the separtor and\n\t\t\t\t * the headers as they will be automatically got by the \n\t\t\t\t * first lup or by the final copy */\n\t\t\t\twhile ( lump && lump->u.offset<(part->body.s-msg->buf) )\n\t\t\t\t\tlump=lump->next;\n\t\t\t\tif (lump) {\n\t\t\t\t\tLM_DBG(\"lumps found in the part, applying...\\n\");\n\t\t\t\t\t/* apply the lumps */\n\t\t\t\t\tprocess_lumps( msg, lump, new_buf, &offset, orig_offs,\n\t\t\t\t\t\tsend_sock, part->body.s+part->body.len-msg->buf);\n\t\t\t\t}\n\t\t\t\t/* and copy whatever is left, all the way to the end of part,\n\t\t\t\t * including the next CRLF */\n\t\t\t\tsize = (part->body.s+part->body.len-msg->buf+CRLF_LEN)-*orig_offs;\n\t\t\t\tmemcpy(new_buf+offset, msg->buf+*orig_offs, size);\n\t\t\t\toffset += size;\n\t\t\t}\n\n\t\t\t/* reposition at the end of the processed body */\n\t\t\tif ((part->flags & SIP_BODY_PART_FLAG_NEW) == 0)\n\t\t\t\t*orig_offs = part->body.s+part->body.len-msg->buf+CRLF_LEN;\n\n\t\t} /* end for(over the parts) */\n\n\t\t/* the final separator */\n\t\tsize = msg->len - *orig_offs;\n\t\tmemcpy(new_buf+offset, msg->buf+*orig_offs , size);\n\t\t*new_offs = offset + size;\n\t\t*orig_offs += size;\n\n\t}\n\treturn;\n}\n\n\n/* Calculated the body difference in lenght after applying\n *   all the changes (over the sip body) !\n * This is a wrapper to hide the differences between \n *   lump-based changes and body_part-based changes.\n */\nstatic inline int calculate_body_diff(struct sip_msg *msg,\n\t\t\t\t\t\t\t\t\t\t\t\t\tstruct socket_info *sock )\n{\n\tif (msg->body==NULL) {\n\t\t/* no body parsed, no advanced ops done, just dummy lumps over body */\n\t\treturn lumps_len(msg, msg->body_lumps, sock, -1);\n\t} else {\n\t\treturn ((int)prep_reassemble_body_parts( msg, sock) - msg->body->body.len);\n\t}\n}\n\n\n/* Writes down the new SIP message buffer (SIP headers and body) after\n *   after applying all the changes (over SIP hdrs and SIP body) !\n * This is a wrapper to hide the differences between \n *   lump-based changes and body_part-based changes.\n */\nstatic inline void apply_msg_changes(struct sip_msg *msg,\n\t\t\t\t\t\t\tchar *new_buf, unsigned int *new_offs,\n\t\t\t\t\t\t\tunsigned int *orig_offs, struct socket_info *sock,\n\t\t\t\t\t\t\tunsigned int max_offset)\n{\n\tunsigned int size;\n\n\t/* apply changes over the SIP headers */\n\tprocess_lumps(msg, msg->add_rm, new_buf, new_offs, orig_offs, sock, -1);\n\tif (msg->body==NULL) {\n\t\t/* no body parsed, no advanced ops done, just dummy lumps over body */\n\t\tprocess_lumps(msg, msg->body_lumps, new_buf, new_offs,\n\t\t\torig_offs, sock, max_offset);\n\t\t/* copy the rest of the message */\n\t\tmemcpy(new_buf+*new_offs, msg->buf+*orig_offs, max_offset-*orig_offs);\n\t\t*new_offs += max_offset-*orig_offs;\n\t} else {\n\t\t/* copy whatever is left in the original buffer (up to the body) */\n\t\tsize = (msg->body->part_count) ?\n\t\t\t  ((msg->body->body.s - msg->buf) - *orig_offs) /* msg had body */\n\t\t\t: (msg->len - *orig_offs);                      /* no body */\n\t\tmemcpy(new_buf+*new_offs, msg->buf+*orig_offs, size );\n\t\t*new_offs += size;\n\t\t*orig_offs += size;\n\t\t/* rebuild the body, part by part, in a content wise manner */\n\t\treassemble_body_parts(msg, new_buf, new_offs, orig_offs, sock);\n\t}\n}\n\n\n/*! \\brief\n * Adjust/insert Content-Length if necessary\n */\nstatic inline int adjust_clen(struct sip_msg* msg, int body_delta, int proto)\n{\n\tstruct lump* anchor;\n\tchar* clen_buf;\n\tint clen_len;\n\n\t/* Calculate message length difference caused by lumps modifying message\n\t * body, from this point on the message body must not be modified. Zero\n\t * value indicates that the body hasn't been modified\n\t*/\n\n\tclen_buf = 0;\n\tanchor=0;\n\n\t/* check to see if we need to add clen */\n\tif (is_tcp_based_proto(proto)) {\n\t\tif (parse_headers(msg, HDR_CONTENTLENGTH_F, 0)==-1){\n\t\t\tLM_ERR(\"parsing content-length\\n\");\n\t\t\tgoto error;\n\t\t}\n\t\tif (msg->content_length==0){\n\t\t\t/* not present, we need to add it */\n\t\t\t/* msg->unparsed should point just before the final crlf\n\t\t\t * - whole message was parsed by the above parse_headers\n\t\t\t *   which did not find content-length */\n\t\t\tanchor=anchor_lump(msg, msg->unparsed-msg->buf,\n\t\t\t\t\t\t\t\t\t\t\t\tHDR_CONTENTLENGTH_T);\n\t\t\tif (anchor==0){\n\t\t\t\tLM_ERR(\"cannot set clen anchor\\n\");\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t}\n\n\tif ((anchor==0) && body_delta){\n\t\tif (parse_headers(msg, HDR_CONTENTLENGTH_F, 0) == -1) {\n\t\t\tLM_ERR(\"parsing Content-Length\\n\");\n\t\t\tgoto error;\n\t\t}\n\n\t\t/* The body has been changed, try to find\n\t\t * existing Content-Length\n\t\t */\n\t\t/* no need for Content-Length if it's and UDP packet and\n\t\t * it hasn't Content-Length already */\n\t\tif (msg->content_length==0){\n\t\t    /* content-length doesn't exist, append it */\n\t\t\t/* msg->unparsed should point just before the final crlf\n\t\t\t * - whole message was parsed by the above parse_headers\n\t\t\t *   which did not find content-length */\n\t\t\tif (proto!=PROTO_UDP){\n\t\t\t\tanchor=anchor_lump(msg, msg->unparsed-msg->buf,\n\t\t\t\t\t\t\t\t\t\t\t\t\tHDR_CONTENTLENGTH_T);\n\t\t\t\tif (anchor==0){\n\t\t\t\t\tLM_ERR(\"cannot set clen anchor\\n\");\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tLM_DBG(\"the UDP packet has no clen => not adding one \\n\");\n\t\t\t}\n\t\t}else{\n\t\t\t/* Content-Length has been found, remove it */\n\t\t\tanchor = del_lump(\tmsg, msg->content_length->name.s - msg->buf,\n\t\t\t\t\t\t\t\tmsg->content_length->len, HDR_CONTENTLENGTH_T);\n\t\t\tif (anchor==0) {\n\t\t\t\tLM_ERR(\"can't remove original Content-Length\\n\");\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (anchor){\n\t\tclen_buf = clen_builder(msg, &clen_len, body_delta);\n\t\tif (!clen_buf) goto error;\n\t\tif (insert_new_lump_after(anchor, clen_buf, clen_len,\n\t\t\t\t\tHDR_CONTENTLENGTH_T) == 0)\n\t\t\tgoto error;\n\t}\n\n\treturn 0;\nerror:\n\tif (clen_buf) pkg_free(clen_buf);\n\treturn -1;\n}\n\n\n/*! \\brief\n * Save given Path body as Route header in message.\n *\n * If another Route HF is found, it's placed right before that.\n * Otherwise, it's placed after the last Via HF. If also no\n * Via HF is found, it's placed as first HF.\n */\n#define ROUTE_STR  \"Route: \"\n#define ROUTE_LEN  (sizeof(ROUTE_STR)-1)\nstatic inline int insert_path_as_route(struct sip_msg* msg, str* path)\n{\n\tstruct lump *anchor;\n\tchar *route;\n\tstruct hdr_field *hf, *last_via=0;\n\n\tfor (hf = msg->headers; hf; hf = hf->next) {\n\t\tif (hf->type == HDR_ROUTE_T) {\n\t\t\tbreak;\n\t\t} else if (hf->type == HDR_VIA_T) {\n\t\t\tlast_via = hf;\n\t\t}\n\t}\n\tif (hf) {\n\t\t/* Route HF found, insert before it */\n\t\tanchor = anchor_lump(msg, hf->name.s - msg->buf, 0);\n\t} else if(last_via) {\n\t\tif (last_via->next) {\n\t\t\t/* Via HF in between, insert after it */\n\t\t\tanchor = anchor_lump(msg, last_via->next->name.s - msg->buf, 0);\n\t\t} else {\n\t\t\t/* Via HF is last, so append */\n\t\t\tanchor = anchor_lump(msg, msg->unparsed - msg->buf, 0);\n\t\t}\n\t} else {\n\t\t/* None of the above, insert as first */\n\t\tanchor = anchor_lump(msg, msg->headers->name.s - msg->buf, 0);\n\t}\n\n\tif (anchor == 0) {\n\t\tLM_ERR(\"failed to get anchor\\n\");\n\t\treturn -1;\n\t}\n\n\troute = pkg_malloc(ROUTE_LEN + path->len + CRLF_LEN);\n\tif (!route) {\n\t\tLM_ERR(\"out of pkg memory\\n\");\n\t\treturn -1;\n\t}\n\tmemcpy(route, ROUTE_STR, ROUTE_LEN);\n\tmemcpy(route + ROUTE_LEN, path->s, path->len);\n\tmemcpy(route + ROUTE_LEN + path->len, CRLF, CRLF_LEN);\n\n\tif (insert_new_lump_before(anchor, route, ROUTE_LEN + path->len + CRLF_LEN, 0) == 0) {\n\t\tLM_ERR(\"failed to insert lump\\n\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nint is_del_via1_lump(struct sip_msg* msg)\n{\n\tstruct lump* lump;\n\tint via1_off, via1_len;\n\n/*\tfor(lump= msg->add_rm; lump; lump= lump->next)\n\t\tif(lump->type == HDR_VIA1_T && lump->op== LUMP_DEL)\n\t\t\treturn 1;\n*/\n\tif(!msg->h_via1)\n\t\treturn 0;\n\n\tvia1_off = msg->h_via1->name.s - msg->buf;\n\tvia1_len = msg->h_via1->len;\n\n\tfor(lump= msg->add_rm; lump; lump= lump->next)\n\t{\n\t\tif(lump->type == 0 && lump->op== LUMP_DEL && lump->u.offset == via1_off && lump->len == via1_len)\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nchar * build_req_buf_from_sip_req( struct sip_msg* msg,\n\t\t\t\t\t\t\t\tunsigned int *returned_len,\n\t\t\t\t\t\t\t\tstruct socket_info* send_sock, int proto,\n\t\t\t\t\t\t\t\tstr *via_params, unsigned int flags)\n{\n\tunsigned int len, new_len, received_len, rport_len, uri_len, via_len, body_delta;\n\tchar *line_buf, *received_buf, *rport_buf, *new_buf, *buf, *id_buf;\n\tunsigned int offset, s_offset, size, id_len;\n\tstruct lump *anchor, *via_insert_param;\n\tstr branch, extra_params, body;\n\tstruct hostport hp;\n\n\tid_buf=0;\n\tid_len=0;\n\tvia_insert_param=0;\n\textra_params.len=0;\n\textra_params.s=0;\n\turi_len=0;\n\tbuf=msg->buf;\n\tlen=msg->len;\n\treceived_len=0;\n\trport_len=0;\n\tnew_buf=0;\n\treceived_buf=0;\n\trport_buf=0;\n\tline_buf=0;\n\tint via1_deleted = 0;\n\n\tif (msg->path_vec.len) {\n\t\tif (insert_path_as_route(msg, &msg->path_vec) < 0) {\n\t\t\tLM_ERR(\"adding path lumps failed\\n\");\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\t/* Calculate message body difference and adjust\n\t * Content-Length\n\t */\n\tbody_delta = calculate_body_diff( msg, send_sock);\n\tif (adjust_clen(msg, body_delta, proto) < 0) {\n\t\tLM_ERR(\"failed to adjust Content-Length\\n\");\n\t\tgoto error;\n\t}\n\n\tif (flags&MSG_TRANS_NOVIA_FLAG)\n\t\tgoto build_msg;\n\n\t/* add id if tcp-based protocol  */\n\tif (is_tcp_based_proto(msg->rcv.proto)) {\n\t\tif  ((id_buf=id_builder(msg, &id_len))==0){\n\t\t\tLM_ERR(\"id_builder failed\\n\");\n\t\t\tgoto error; /* we don't need to free anything,\n\t\t\t                 nothing alloc'ed yet*/\n\t\t}\n\t\tLM_DBG(\"id added: <%.*s>, rcv proto=%d\\n\",\n\t\t\t\t(int)id_len, id_buf, msg->rcv.proto);\n\t\t/* if there was already something there, simply copy them */\n\t\tif (via_params && via_params->len != 0) {\n\t\t\textra_params.len = id_len + via_params->len;\n\t\t\textra_params.s=pkg_malloc(extra_params.len);\n\t\t\tif(extra_params.s==0) {\n\t\t\t\tLM_ERR(\"extra params building failed\\n\");\n\t\t\t\tpkg_free(id_buf);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tmemcpy(extra_params.s, via_params->s, via_params->len);\n\t\t\tmemcpy(extra_params.s + via_params->len, id_buf, id_len);\n\t\t} else {\n\t\t\textra_params.s=id_buf;\n\t\t\textra_params.len=id_len;\n\t\t}\n\t}\n\n\t/* check whether to add rport parameter to local via */\n\tif(msg->msg_flags&FL_FORCE_LOCAL_RPORT) {\n\t\tid_buf=extra_params.s;\n\t\tid_len=extra_params.len;\n\t\tif (via_params && !extra_params.len) {\n\t\t\t/* if no other parameters were added yet, consider via_params */\n\t\t\textra_params.len = via_params->len;\n\t\t\t/* otherwise, the via_params were already copied in the id block */\n\t\t}\n\t\textra_params.len += RPORT_LEN-1; /* last char in RPORT define is '='\n\t\t\t\t\t\t\t\t\t\twhich is not added, but the new buffer\n\t\t\t\t\t\t\t\t\t\twill be null terminated */\n\t\textra_params.s = (char*)pkg_malloc(extra_params.len+1);\n\t\tif(extra_params.s==0) {\n\t\t\tLM_ERR(\"extra params building failed\\n\");\n\t\t\tif (id_buf) pkg_free(id_buf);\n\t\t\tgoto error;\n\t\t}\n\n\t\tif(id_buf!=0) {\n\t\t\tmemcpy(extra_params.s, id_buf, id_len);\n\t\t\tpkg_free(id_buf);\n\t\t} else if (via_params)\n\t\t\tmemcpy(extra_params.s, via_params->s, via_params->len);\n\t\tmemcpy(extra_params.s+id_len, RPORT, RPORT_LEN-1);\n\t\textra_params.s[extra_params.len]='\\0';\n\t\tLM_DBG(\"extra param added: <%.*s>\\n\",extra_params.len, extra_params.s);\n\t}\n\n\tbranch.s=msg->add_to_branch_s;\n\tbranch.len=msg->add_to_branch_len;\n\tset_hostport(&hp, msg);\n\tline_buf = via_builder( &via_len, send_sock, &branch,\n\t\t\t\t\t\textra_params.len?&extra_params:via_params, proto, &hp);\n\tif (!line_buf){\n\t\tLM_ERR(\"no via received!\\n\");\n\t\tgoto error00;\n\t}\n\n\tvia1_deleted = is_del_via1_lump(msg);\n\t/* check if received needs to be added:\n\t *  - if the VIA address and the received address are different\n\t *  - if the rport was forced (rport requires received)\n\t *  - if the rport was received in the VIA hdr\n\t *  - and there is no lump that delets VIA1 hdr */\n\tif ( (msg->via1->rport || (msg->msg_flags&FL_FORCE_RPORT) ||\n\t\t\treceived_test(msg) ) && !via1_deleted) {\n\t\tif ((received_buf=received_builder(msg,&received_len))==0){\n\t\t\tLM_ERR(\"received_builder failed\\n\");\n\t\t\tgoto error01;  /* free also line_buf */\n\t\t}\n\t}\n\n\t/* check if rport needs to be updated:\n\t *  - if FL_FORCE_RPORT is set add it (and del. any previous version)\n\t *  - if via already contains an rport add it and overwrite the previous\n\t *  rport value if present (if you don't want to overwrite the previous\n\t *  version remove the comments) */\n\tif (((msg->msg_flags&FL_FORCE_RPORT)||\n\t\t\t(msg->via1->rport /*&& msg->via1->rport->value.s==0*/)) && !via1_deleted){\n\t\tif ((rport_buf=rport_builder(msg, &rport_len))==0){\n\t\t\tLM_ERR(\"rport_builder failed\\n\");\n\t\t\tgoto error01; /* free everything */\n\t\t}\n\t}\n\n\t/* add via header to the list */\n\t/* try to add it before msg. 1st via */\n\t/* add first via, as an anchor for second via*/\n\tanchor=anchor_lump(msg, msg->via1->hdr.s-buf, HDR_VIA_T);\n\tif (anchor==0) goto error01;\n\tif (insert_new_lump_before(anchor, line_buf, via_len, HDR_VIA_T)==0)\n\t\tgoto error01;\n\t/* find out where the offset of the first parameter that should be added\n\t * (after host:port), needed by add receive & maybe rport */\n\tif (msg->via1->params.s){\n\t\t\tsize= msg->via1->params.s-msg->via1->hdr.s-1; /*compensate\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t  for ';' */\n\t}else{\n\t\t\tsize= msg->via1->host.s-msg->via1->hdr.s+msg->via1->host.len;\n\t\t\tif (msg->via1->port!=0){\n\t\t\t\t/*size+=strlen(msg->via1->hdr.s+size+1)+1;*/\n\t\t\t\tsize += msg->via1->port_str.len + 1; /* +1 for ':'*/\n\t\t\t}\n\t}\n\t/* if received needs to be added, add anchor after host and add it, or\n\t * overwrite the previous one if already present */\n\tif (received_len){\n\t\tif (msg->via1->received){ /* received already present => overwrite it*/\n\t\t\tvia_insert_param=del_lump(msg,\n\t\t\t\t\t\t\t\tmsg->via1->received->start-buf-1, /*;*/\n\t\t\t\t\t\t\t\tmsg->via1->received->size+1, /*;*/ HDR_VIA_T);\n\t\t}else if (via_insert_param==0){ /* receive not present, ok */\n\t\t\tvia_insert_param=anchor_lump(msg,\n\t\t\t\t\t\t\t\t\t\tmsg->via1->hdr.s-buf+size, HDR_VIA_T);\n\t\t}\n\t\tif (via_insert_param==0) goto error02; /* free received_buf */\n\t\tif (insert_new_lump_after(via_insert_param, received_buf, received_len,\n\t\t\t\t\tHDR_VIA_T) ==0 ) goto error02; /* free received_buf */\n\t}\n\t/* if rport needs to be updated, delete it if present and add it's value */\n\tif (rport_len){\n\t\tif (msg->via1->rport){ /* rport already present */\n\t\t\tvia_insert_param=del_lump(msg,\n\t\t\t\t\t\t\t\tmsg->via1->rport->start-buf-1, /*';'*/\n\t\t\t\t\t\t\t\tmsg->via1->rport->size+1 /* ; */, HDR_VIA_T);\n\t\t}else if (via_insert_param==0){ /*force rport, no rport present */\n\t\t\t/* no rport, add it */\n\t\t\tvia_insert_param=anchor_lump(msg,\n\t\t\t\t\t\t\t\t\tmsg->via1->hdr.s-buf+size, HDR_VIA_T);\n\t\t}\n\t\tif (via_insert_param==0) goto error03; /* free rport_buf */\n\t\tif (insert_new_lump_after(via_insert_param, rport_buf, rport_len,\n\t\t\t\t\t\t\t\t\tHDR_VIA_T) ==0 )\n\t\t\tgoto error03; /* free rport_buf */\n\t}\n\nbuild_msg:\n\t/* adjust len to the useful part of the message */\n\tif (get_body(msg, &body) == 0 && body.len)\n\t\tlen -= (msg->buf + msg->len - body.s - body.len);\n\n\t/* compute new msg len and fix overlapping zones*/\n\tnew_len=len+body_delta+lumps_len(msg, msg->add_rm, send_sock,-1);\n#ifdef XL_DEBUG\n\tLM_DBG(\"new_len(%d)=len(%d)+lumps_len\\n\", new_len, len);\n#endif\n\n\tif (msg->new_uri.s){\n\t\turi_len=msg->new_uri.len;\n\t\tnew_len=new_len-msg->first_line.u.request.uri.len+uri_len;\n\t}\n\tif (flags&MSG_TRANS_SHM_FLAG)\n\t\tnew_buf=(char*)shm_malloc(new_len+1);\n\telse\n\t\tnew_buf=(char*)pkg_malloc(new_len+1);\n\tif (new_buf==0){\n\t\tser_error=E_OUT_OF_MEM;\n\t\tLM_ERR(\"out of pkg memory\\n\");\n\t\tgoto error00;\n\t}\n\n\toffset=s_offset=0;\n\tif (msg->new_uri.s){\n\t\t/* copy message up to uri */\n\t\tsize=msg->first_line.u.request.uri.s-buf;\n\t\tmemcpy(new_buf, buf, size);\n\t\toffset+=size;\n\t\ts_offset+=size;\n\t\t/* add our uri */\n\t\tmemcpy(new_buf+offset, msg->new_uri.s, uri_len);\n\t\toffset+=uri_len;\n\t\ts_offset+=msg->first_line.u.request.uri.len; /* skip original uri */\n\t}\n\n\t/* apply changes over SIP hdrs and body */\n\tapply_msg_changes( msg, new_buf, &offset, &s_offset, send_sock, len);\n\tif (offset!=new_len) {\n\t\tLM_BUG(\"len mismatch : calculated %d, written %d\\n\", new_len, offset);\n\t\tabort();\n\t}\n\n\tnew_buf[new_len]=0;\n\n\t*returned_len=new_len;\n\t/* cleanup */\n\tif (extra_params.s) pkg_free(extra_params.s);\n\treturn new_buf;\n\nerror01:\n\tif (line_buf) pkg_free(line_buf);\nerror02:\n\tif (received_buf) pkg_free(received_buf);\nerror03:\n\tif (rport_buf) pkg_free(rport_buf);\nerror00:\n\tif (extra_params.s) pkg_free(extra_params.s);\nerror:\n\t*returned_len=0;\n\treturn 0;\n}\n\n\n\nchar * build_res_buf_from_sip_res( struct sip_msg* msg,\n\tunsigned int *returned_len, struct socket_info *sock,int flags)\n{\n\tunsigned int new_len, body_delta, len;\n\tchar *new_buf, *buf;\n\tunsigned int offset, s_offset;\n\tstr body;\n\n\tbuf=msg->buf;\n\tlen=msg->len;\n\tnew_buf=0;\n\n\t/* Calculate message body difference and adjust\n\t * Content-Length\n\t */\n\tbody_delta = calculate_body_diff( msg, sock);\n\tif (adjust_clen(msg, body_delta, (msg->via2? msg->via2->proto:PROTO_UDP))\n\t\t\t< 0) {\n\t\tLM_ERR(\"failed to adjust Content-Length\\n\");\n\t\tgoto error;\n\t}\n\n\t/* remove the first via */\n\tif (!(flags & MSG_TRANS_NOVIA_FLAG)) {\n\t\tunsigned int via_len, via_offset;\n\n\t\tif (msg->via1->next) {\n\t\t\tvia_len = msg->via1->bsize;\n\t\t\tvia_offset = msg->h_via1->body.s-buf;\n\t\t} else {\n\t\t\tvia_len = msg->h_via1->len;\n\t\t\tvia_offset = msg->h_via1->name.s-buf;\n\t\t}\n\n\t\tif (del_lump(msg, via_offset, via_len, HDR_VIA_T) == 0) {\n\t\t\tLM_ERR(\"failed to remove first via\\n\");\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\t/* adjust len to the useful part of the message */\n\tif (get_body(msg, &body) == 0 && body.len)\n\t\tlen -= (msg->buf + msg->len - body.s - body.len);\n\tnew_len=len+body_delta+lumps_len(msg, msg->add_rm, sock, -1);\n\n\tLM_DBG(\" old size: %d, new size: %d\\n\", len, new_len);\n\tnew_buf=(char*)pkg_malloc(new_len+1); /* +1 is for debugging\n\t\t\t\t\t\t\t\t\t\t\t (\\0 to print it )*/\n\tif (new_buf==0){\n\t\tLM_ERR(\"out of pkg mem\\n\");\n\t\tgoto error;\n\t}\n\toffset=s_offset=0;\n\n\t/* apply changes over SIP hdrs and body */\n\tapply_msg_changes( msg, new_buf, &offset, &s_offset, sock, len);\n\tif (offset!=new_len) {\n\t\tLM_BUG(\"len mismatch : calculated %d, written %d\\n\", new_len, offset);\n\t\tabort();\n\t}\n\n\tnew_buf[new_len]=0; /* debug: print the message */\n\n\t/* as it is a relaied reply, if 503, make it 500 (just reply code) */\n\tif ( !disable_503_translation && msg->first_line.u.reply.statuscode==503 )\n\t\tnew_buf[(int)(msg->first_line.u.reply.status.s-msg->buf)+2] = '0';\n\t/* send it! */\n\tLM_DBG(\"copied size: orig:%d, new: %d, rest: %d\"\n\t\t\t\" msg=\\n%s\\n\", s_offset, offset, len-s_offset, new_buf);\n\n\t*returned_len=new_len;\n\treturn new_buf;\nerror:\n\t*returned_len=0;\n\treturn 0;\n}\n\n\nchar * build_res_buf_from_sip_req( unsigned int code, const str *text ,str *new_tag,\n\t\tstruct sip_msg* msg, unsigned int *returned_len, struct bookmark *bmark)\n{\n\tchar *buf, *p, *received_buf, *rport_buf, *warning_buf;\n\tchar *content_len_buf, *after_body, *totags;\n\tunsigned int len, foo, received_len, rport_len;\n\tunsigned int warning_len, content_len_len;\n\tstruct hdr_field *hdr;\n\tstruct lump_rpl *lump, *body;\n\tint i;\n\tstr to_tag;\n\n\tbody = 0;\n\tbuf=0;\n\tto_tag.s = 0;\n\tto_tag.len = 0;\n\treceived_buf=rport_buf=warning_buf=content_len_buf=0;\n\treceived_len=rport_len=warning_len=content_len_len=0;\n\n\t/* force parsing all headers -- we want to return all\n\tVia's in the reply and they may be scattered down to the\n\tend of header (non-block Vias are a really poor property\n\tof SIP :( ) */\n\tif (parse_headers( msg, HDR_EOH_F, 0 )==-1) {\n\t\tLM_ERR(\"parse_headers failed\\n\");\n\t\tgoto error00;\n\t}\n\n\t/*computes the length of the new response buffer*/\n\tlen = 0;\n\n\t/* check if rport needs to be updated */\n\tif ( (msg->msg_flags&FL_FORCE_RPORT)||\n\t\t(msg->via1->rport /*&& msg->via1->rport->value.s==0*/)){\n\t\tif ((rport_buf=rport_builder(msg, &rport_len))==0){\n\t\t\tLM_ERR(\"rport_builder failed\\n\");\n\t\t\tgoto error00;\n\t\t}\n\t\tif (msg->via1->rport)\n\t\t\tlen -= msg->via1->rport->size+1; /* include ';' */\n\t}\n\n\t/* check if received needs to be added or via rport has to be added */\n\tif (rport_buf || received_test(msg)) {\n\t\tif ((received_buf=received_builder(msg,&received_len))==0) {\n\t\t\tLM_ERR(\"received_builder failed\\n\");\n\t\t\tgoto error01;\n\t\t}\n\t}\n\n\t/* first line */\n\tlen += SIP_VERSION_LEN + 1/*space*/ + 3/*code*/ + 1/*space*/ +\n\t\ttext->len + CRLF_LEN/*new line*/;\n\t/*headers that will be copied (TO, FROM, CSEQ,CALLID,VIA)*/\n\tfor ( hdr=msg->headers ; hdr ; hdr=hdr->next ) {\n\t\tswitch (hdr->type) {\n\t\t\tcase HDR_TO_T:\n\t\t\t\tif (new_tag && new_tag->len) {\n\t\t\t\t\tto_tag=get_to(msg)->tag_value;\n\t\t\t\t\tif (to_tag.len )\n\t\t\t\t\t\tlen+=new_tag->len-to_tag.len;\n\t\t\t\t\telse\n\t\t\t\t\t\tlen+=new_tag->len+TOTAG_TOKEN_LEN/*\";tag=\"*/;\n\t\t\t\t}\n\t\t\t\tlen += hdr->len;\n\t\t\t\tbreak;\n\t\t\tcase HDR_VIA_T:\n\t\t\t\t/* we always add CRLF to via*/\n\t\t\t\tlen+=(hdr->body.s+hdr->body.len)-hdr->name.s+CRLF_LEN;\n\t\t\t\tif (hdr==msg->h_via1) len += received_len+rport_len;\n\t\t\t\tbreak;\n\t\t\tcase HDR_RECORDROUTE_T:\n\t\t\t\t/* RR only for 1xx and 2xx replies */\n\t\t\t\tif (code<180 || code>=300)\n\t\t\t\t\tbreak;\n\t\t\tcase HDR_FROM_T:\n\t\t\tcase HDR_CALLID_T:\n\t\t\tcase HDR_CSEQ_T:\n\t\t\t\t/* we keep the original termination for these headers*/\n\t\t\t\tlen += hdr->len;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t/* do nothing, we are interested only in the above headers */\n\t\t\t\t;\n\t\t}\n\t}\n\t/* lumps length */\n\tfor(lump=msg->reply_lump;lump;lump=lump->next) {\n\t\tlen += lump->text.len;\n\t\tif (lump->flags&LUMP_RPL_BODY)\n\t\t\tbody = lump;\n\t}\n\t/* server header */\n\tif (server_signature)\n\t\tlen += server_header->len + CRLF_LEN;\n\t/* warning hdr */\n\tif (sip_warning) {\n\t\twarning_buf = warning_builder(msg,&warning_len);\n\t\tif (warning_buf) len += warning_len + CRLF_LEN;\n\t\telse LM_WARN(\"warning skipped -- too big\\n\");\n\t}\n\t/* content length hdr */\n\tif (body) {\n\t\tcontent_len_buf = int2str(body->text.len, (int*)&content_len_len);\n\t\tlen += CONTENT_LENGTH_LEN + content_len_len + CRLF_LEN;\n\t} else {\n\t\tlen += CONTENT_LENGTH_LEN + 1/*0*/ + CRLF_LEN;\n\t}\n\t/* end of message */\n\tlen += CRLF_LEN; /*new line*/\n\n\t/*allocating mem*/\n\tbuf = (char*) pkg_malloc( len+1 );\n\tif (!buf)\n\t{\n\t\tLM_ERR(\"out of pkg memory; needs %d\\n\",len);\n\t\tgoto error01;\n\t}\n\n\t/* filling the buffer*/\n\tp=buf;\n\t/* first line */\n\tmemcpy( p , SIP_VERSION , SIP_VERSION_LEN );\n\tp += SIP_VERSION_LEN;\n\t*(p++) = ' ' ;\n\t/*code*/\n\tfor ( i=2 , foo = code  ;  i>=0  ;  i-- , foo=foo/10 )\n\t\t*(p+i) = '0' + foo - ( foo/10 )*10;\n\tp += 3;\n\t*(p++) = ' ' ;\n\tmemcpy( p , text->s , text->len );\n\tp += text->len;\n\tmemcpy( p, CRLF, CRLF_LEN );\n\tp+=CRLF_LEN;\n\t/* headers*/\n\tfor ( hdr=msg->headers ; hdr ; hdr=hdr->next ) {\n\t\tswitch (hdr->type)\n\t\t{\n\t\t\tcase HDR_VIA_T:\n\t\t\t\tif (hdr==msg->h_via1){\n\t\t\t\t\ti = 0;\n\t\t\t\t\tif (received_buf) {\n\t\t\t\t\t\ti = msg->via1->host.s - msg->via1->hdr.s +\n\t\t\t\t\t\t\tmsg->via1->host.len + (msg->via1->port?\n\t\t\t\t\t\t\tmsg->via1->port_str.len + 1 : 0);\n\t\t\t\t\t\t/* copy via1 up to params */\n\t\t\t\t\t\tappend_str( p, hdr->name.s, i);\n\t\t\t\t\t\t/* copy received param */\n\t\t\t\t\t\tappend_str( p, received_buf, received_len);\n\t\t\t\t\t}\n\t\t\t\t\tif (rport_buf){\n\t\t\t\t\t\tif (msg->via1->rport){ /* delete the old one */\n\t\t\t\t\t\t\t/* copy until rport */\n\t\t\t\t\t\t\tappend_str_trans( p, hdr->name.s+i ,\n\t\t\t\t\t\t\t\tmsg->via1->rport->start-hdr->name.s-1-i,msg);\n\t\t\t\t\t\t\t/* copy new rport */\n\t\t\t\t\t\t\tappend_str(p, rport_buf, rport_len);\n\t\t\t\t\t\t\t/* copy the rest of the via */\n\t\t\t\t\t\t\tappend_str_trans(p, msg->via1->rport->start+\n\t\t\t\t\t\t\t\t\t\t\t\tmsg->via1->rport->size,\n\t\t\t\t\t\t\t\t\t\t\t\thdr->body.s+hdr->body.len-\n\t\t\t\t\t\t\t\t\t\t\t\tmsg->via1->rport->start-\n\t\t\t\t\t\t\t\t\t\t\t\tmsg->via1->rport->size, msg);\n\t\t\t\t\t\t}else{ /* just copy rport and rest of hdr */\n\t\t\t\t\t\t\tappend_str(p, rport_buf, rport_len);\n\t\t\t\t\t\t\tappend_str_trans( p, hdr->name.s+i ,\n\t\t\t\t\t\t\t\t(hdr->body.s+hdr->body.len)-hdr->name.s-i,msg);\n\t\t\t\t\t\t}\n\t\t\t\t\t}else{\n\t\t\t\t\t\t/* normal whole via copy */\n\t\t\t\t\t\tappend_str_trans( p, hdr->name.s+i ,\n\t\t\t\t\t\t\t(hdr->body.s+hdr->body.len)-hdr->name.s-i, msg);\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\t/* normal whole via copy */\n\t\t\t\t\tappend_str_trans( p, hdr->name.s,\n\t\t\t\t\t\t\t(hdr->body.s+hdr->body.len)-hdr->name.s, msg);\n\t\t\t\t}\n\t\t\t\tappend_str( p, CRLF,CRLF_LEN);\n\t\t\t\tbreak;\n\t\t\tcase HDR_RECORDROUTE_T:\n\t\t\t\t/* RR only for 1xx and 2xx replies */\n\t\t\t\tif (code<180 || code>=300) break;\n\t\t\t\tappend_str(p, hdr->name.s, hdr->len);\n\t\t\t\tbreak;\n\t\t\tcase HDR_TO_T:\n\t\t\t\tif (new_tag && new_tag->len){\n\t\t\t\t\tif (to_tag.len ) { /* replacement */\n\t\t\t\t\t\t/* before to-tag */\n\t\t\t\t\t\tappend_str( p, hdr->name.s, to_tag.s-hdr->name.s);\n\t\t\t\t\t\t/* to tag replacement */\n\t\t\t\t\t\tbmark->to_tag_val.s=p;\n\t\t\t\t\t\tbmark->to_tag_val.len=new_tag->len;\n\t\t\t\t\t\tappend_str( p, new_tag->s,new_tag->len);\n\t\t\t\t\t\t/* the rest after to-tag */\n\t\t\t\t\t\tappend_str( p, to_tag.s+to_tag.len,\n\t\t\t\t\t\t\thdr->name.s+hdr->len-(to_tag.s+to_tag.len));\n\t\t\t\t\t}else{ /* adding a new to-tag */\n\t\t\t\t\t\tafter_body=hdr->body.s+hdr->body.len;\n\t\t\t\t\t\tappend_str( p, hdr->name.s, after_body-hdr->name.s);\n\t\t\t\t\t\tappend_str(p, TOTAG_TOKEN, TOTAG_TOKEN_LEN);\n\t\t\t\t\t\tbmark->to_tag_val.s=p;\n\t\t\t\t\t\tbmark->to_tag_val.len=new_tag->len;\n\t\t\t\t\t\tappend_str( p, new_tag->s,new_tag->len);\n\t\t\t\t\t\tappend_str( p, after_body,\n\t\t\t\t\t\t\t\t\t\thdr->name.s+hdr->len-after_body);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t} /* no new to-tag -- proceed to 1:1 copying  */\n\t\t\t\ttotags=((struct to_body*)(hdr->parsed))->tag_value.s;\n\t\t\t\tif (totags) {\n\t\t\t\t\tbmark->to_tag_val.s=p+(totags-hdr->name.s);\n\t\t\t\t\tbmark->to_tag_val.len=\n\t\t\t\t\t\t\t((struct to_body*)(hdr->parsed))->tag_value.len;\n\t\t\t\t} else {\n\t\t\t\t\tbmark->to_tag_val.s = NULL;\n\t\t\t\t\tbmark->to_tag_val.len = 0;\n\t\t\t\t}\n\t\t\tcase HDR_FROM_T:\n\t\t\tcase HDR_CALLID_T:\n\t\t\tcase HDR_CSEQ_T:\n\t\t\t\t\tappend_str(p, hdr->name.s, hdr->len);\n\t\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t/* do nothing, we are interested only in the above headers */\n\t\t\t\t;\n\t\t} /* end switch */\n\t} /* end for */\n\t/* lumps */\n\tfor(lump=msg->reply_lump;lump;lump=lump->next)\n\t\tif (lump->flags&LUMP_RPL_HDR){\n\t\t\tmemcpy(p,lump->text.s,lump->text.len);\n\t\t\tp += lump->text.len;\n\t\t}\n\t/* server header */\n\tif (server_signature) {\n\t\tappend_str( p, server_header->s, server_header->len);\n\t\tappend_str( p, CRLF, CRLF_LEN );\n\t}\n\t/* content_length hdr */\n\tif (content_len_len) {\n\t\tappend_str( p, CONTENT_LENGTH, CONTENT_LENGTH_LEN);\n\t\tappend_str( p, content_len_buf, content_len_len );\n\t\tappend_str( p, CRLF, CRLF_LEN );\n\t} else {\n\t\tappend_str( p, CONTENT_LENGTH\"0\"CRLF,CONTENT_LENGTH_LEN+1+CRLF_LEN);\n\t}\n\t/* warning header */\n\tif (warning_buf) {\n\t\tappend_str( p, warning_buf, warning_len );\n\t\tappend_str( p, CRLF, CRLF_LEN );\n\t}\n\t/*end of message*/\n\tmemcpy( p, CRLF, CRLF_LEN );\n\tp+=CRLF_LEN;\n\t/* body */\n\tif (body) {\n\t\tappend_str( p, body->text.s, body->text.len );\n\t}\n\n\tif (len!=(unsigned long)(p-buf))\n\t\tLM_CRIT(\"diff len=%d p-buf=%d\\n\", len, (int)(p-buf));\n\n\t*(p) = 0;\n\t*returned_len = len;\n\t/* in req2reply, received_buf is not introduced to lumps and\n\t   needs to be deleted here\n\t*/\n\tif (received_buf) pkg_free(received_buf);\n\tif (rport_buf) pkg_free(rport_buf);\n\treturn buf;\n\nerror01:\n\tif (received_buf) pkg_free(received_buf);\n\tif (rport_buf) pkg_free(rport_buf);\nerror00:\n\t*returned_len=0;\n\treturn 0;\n}\n\n\n\n/*! \\brief return number of chars printed or 0 if space exceeded;\n   assumes buffer size of at least MAX_BRANCH_PARAM_LEN\n */\nint branch_builder( unsigned int hash_index,\n\t/* only either parameter useful */\n\tunsigned int label, char * char_v,\n\tint branch,\n\tchar *branch_str, int *len )\n{\n\n\tchar *begin;\n\tint size;\n\n\t/* hash id provided ... start with it */\n\tsize=MAX_BRANCH_PARAM_LEN;\n\tbegin=branch_str;\n\t*len=0;\n\n\tmemcpy(begin, MCOOKIE, MCOOKIE_LEN );\n\tsize-=MCOOKIE_LEN;begin+=MCOOKIE_LEN;\n\n\tif (int2reverse_hex( &begin, &size, hash_index)==-1)\n\t\treturn 0;\n\n\tif (size) {\n\t\t*begin=BRANCH_SEPARATOR;\n\t\tbegin++; size--;\n\t} else return 0;\n\n\t/* string with request's characteristic value ... use it ... */\n\tif (char_v) {\n\t\tif (memcpy(begin,char_v,MD5_LEN)) {\n\t\t\tbegin+=MD5_LEN; size-=MD5_LEN;\n\t\t} else return 0;\n\t} else { /* ... use the \"label\" value otherwise */\n\t\tif (int2reverse_hex( &begin, &size, label )==-1)\n\t\t\treturn 0;\n\t}\n\n\tif (size) {\n\t\t*begin=BRANCH_SEPARATOR;\n\t\tbegin++; size--;\n\t} else return 0;\n\n\tif (int2reverse_hex( &begin, &size, branch)==-1)\n\t\treturn 0;\n\n\t*len=MAX_BRANCH_PARAM_LEN-size;\n\treturn size;\n\n}\n\n\nchar* via_builder( unsigned int *len,\n\tstruct socket_info* send_sock,\n\tstr* branch, str* extra_params, int proto, struct hostport* hp)\n{\n\tunsigned int via_len, extra_len;\n\tchar *line_buf;\n\tint max_len, local_via_len=MY_VIA_LEN;\n\tstr* address_str; /* address displayed in via */\n\tstr* port_str; /* port no displayed in via */\n\n\t/* use pre-set address in via or the outbound socket one */\n\tif (hp && hp->host && hp->host->len)\n\t\taddress_str=hp->host;\n\telse\n\t\taddress_str=get_adv_host(send_sock);\n\n\tif (hp && hp->port && hp->port->len)\n\t\tport_str=hp->port;\n\telse\n\t\tport_str=get_adv_port(send_sock);\n\n\tmax_len=local_via_len+address_str->len /* space in MY_VIA */\n\t\t+2 /* just in case it is a v6 address ... [ ] */\n\t\t+1 /*':'*/+port_str->len\n\t\t+(branch?(MY_BRANCH_LEN+branch->len):0)\n\t\t+(extra_params?extra_params->len:0)\n\t\t+CRLF_LEN+1;\n\tline_buf=pkg_malloc( max_len );\n\tif (line_buf==0){\n\t\tser_error=E_OUT_OF_MEM;\n\t\tLM_ERR(\"out of pkg memory\\n\");\n\t\treturn 0;\n\t}\n\n\textra_len=0;\n\n\tmemcpy(line_buf, MY_VIA, local_via_len);\n\tif (proto==PROTO_UDP){\n\t\t/* do nothing */\n\t}else if (proto==PROTO_TCP){\n\t\tmemcpy(line_buf+local_via_len-4, \"TCP \", 4);\n\t}else if (proto==PROTO_TLS){\n\t\tmemcpy(line_buf+local_via_len-4, \"TLS \", 4);\n\t}else if(proto==PROTO_SCTP){\n\t\tmemcpy(line_buf+local_via_len-4, \"SCTP \", 5);\n\t\tlocal_via_len++;\n\t}else if(proto==PROTO_WS){\n\t\tmemcpy(line_buf+local_via_len-4, \"WS \", 3);\n\t\tlocal_via_len--;\n\t}else if(proto==PROTO_WSS){\n\t\tmemcpy(line_buf+local_via_len-4, \"WSS \", 4);\n\t}else{\n\t\tLM_CRIT(\"unknown proto %d\\n\", proto);\n\t\treturn 0;\n\t}\n\n\tvia_len=local_via_len+address_str->len; /*space included in MY_VIA*/\n\n\tmemcpy(line_buf+local_via_len+extra_len, address_str->s, address_str->len);\n\tline_buf[via_len]=':'; via_len++;\n\tmemcpy(line_buf+via_len, port_str->s, port_str->len);\n\tvia_len+=port_str->len;\n\n\t/* branch parameter */\n\tif (branch){\n\t\tmemcpy(line_buf+via_len, MY_BRANCH, MY_BRANCH_LEN );\n\t\tvia_len+=MY_BRANCH_LEN;\n\t\tmemcpy(line_buf+via_len, branch->s, branch->len );\n\t\tvia_len+=branch->len;\n\t}\n\t/* extra params  */\n\tif (extra_params){\n\t\tmemcpy(line_buf+via_len, extra_params->s, extra_params->len);\n\t\tvia_len+=extra_params->len;\n\t}\n\n\tmemcpy(line_buf+via_len, CRLF, CRLF_LEN);\n\tvia_len+=CRLF_LEN;\n\tline_buf[via_len]=0; /* null terminate the string*/\n\n\t*len = via_len;\n\treturn line_buf;\n}\n\n#define MAX_URI_LEN\t\t1024\nstatic char uri_buff[MAX_URI_LEN];\nchar *construct_uri(str *protocol,str *username,str *domain,str *port,\n\t\tstr *params,int *len)\n{\n\tint pos = 0;\n\n\tif (!len)\n\t{\n\t\tLM_ERR(\"null pointer provided for construct_uri \\n\");\n\t\treturn 0;\n\t}\n\n\tif (!protocol->s || protocol->len == 0)\n\t{\n\t\tLM_ERR(\"no protocol specified\\n\");\n\t\treturn 0;\n\t}\n\n\tif (!domain->s || domain->len == 0)\n\t{\n\t\tLM_ERR(\"no domain specified\\n\");\n\t\treturn 0;\n\t}\n\n\tmemcpy(uri_buff,protocol->s,protocol->len);\n\tpos += protocol->len;\n\turi_buff[pos++] = ':';\n\n\tif (username && username->s && username->len != 0)\n\t{\n\t\tmemcpy(uri_buff+pos,username->s,username->len);\n\t\tpos += username->len;\n\t\turi_buff[pos++] = '@';\n\t}\n\n\tmemcpy(uri_buff+pos,domain->s,domain->len);\n\tpos += domain->len;\n\n\tif (port && port->s && port->len !=0)\n\t{\n\t\turi_buff[pos++] = ':';\n\t\tmemcpy(uri_buff+pos,port->s,port->len);\n\t\tpos += port->len;\n\t}\n\n\tif (params && params->s && params->len !=0 )\n\t{\n\t\turi_buff[pos++] = ';';\n\t\tmemcpy(uri_buff+pos,params->s,params->len);\n\t\tpos += params->len;\n\t}\n\n\turi_buff[pos] = 0;\n\t*len = pos;\n\treturn uri_buff;\n}\n\n/* uses uri_buff above, since contact is still an uri */\nchar *contact_builder(struct socket_info* send_sock, int *ct_len)\n{\n\tchar *p;\n\tint proto_len = 0;\n\tstr* address_str = get_adv_host(send_sock);\n\tstr* port_str = get_adv_port(send_sock);\n\n\t/* sip: */\n\tp = uri_buff;\n\tmemcpy(p, \"sip:\", 4);\n\tp += 4;\n\n\t/* host */\n\tmemcpy(p, address_str->s, address_str->len);\n\tp += address_str->len;\n\n\t/* :port */\n\t*p++ = ':';\n\tmemcpy(p, port_str->s, port_str->len);\n\tp += port_str->len;\n\n\t/* transport if needed */\n\tif (send_sock->proto != PROTO_UDP) {\n\t\tmemcpy(p, \";transport=\", 11);\n\t\tp += 11;\n\t\tproto_len = strlen(protos[send_sock->proto].name);\n\t\tmemcpy(p, protos[send_sock->proto].name, proto_len);\n\t\tp += proto_len;\n\t}\n\n\t*p = '\\0';\n\n\tif (ct_len)\n\t\t*ct_len = p - uri_buff;\n\n\treturn uri_buff;\n}\n"], "fixing_code": ["/*\n * Copyright (C) 2001-2003 FhG Fokus\n * Copyright (C) 2006 Andreas Granig <agranig@linguin.org>\n *   ( covers insert_path_as_route() )\n *\n * This file is part of opensips, a free SIP server.\n *\n * opensips is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version\n *\n * opensips is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301  USA\n *\n * History:\n * --------\n * 2003-01-20  bug_fix: use of return value of snprintf aligned to C99 (jiri)\n * 2003-01-23  added rport patches, contributed by\n *              Maxim Sobolev <sobomax@FreeBSD.org> and heavily modified by me\n *              (andrei)\n * 2003-01-24  added i param to via of outgoing requests (used by tcp),\n *              modified via_builder params (andrei)\n * 2003-01-27  more rport fixes (make use of new via_param->start)  (andrei)\n * 2003-01-27  next baby-step to removing ZT - PRESERVE_ZT (jiri)\n * 2003-01-29  scratchpad removed (jiri)\n * 2003-02-28  scratchpad compatibility abandoned (jiri)\n * 2003-03-01  VOICE_MAIL defs removed (jiri)\n * 2003-03-06  totags in outgoing replies bookmarked to enable\n *             ACK/200 tag matching (andrei)\n * 2003-03-18  killed the build_warning snprintf (andrei)\n * 2003-03-31  added subst lump support (andrei)\n * 2003-04-01  added opt (conditional) lump support (andrei)\n * 2003-04-02  added more subst lumps: SUBST_{SND,RCV}_ALL\n *              => ip:port;transport=proto (andrei)\n * 2003-04-12  added FL_FORCE_RPORT support (andrei)\n * 2003-04-13  updated warning builder -- fixed (andrei)\n * 2003-07-10  check_via_address knows now how to compare with ipv6 address\n *              references (e.g [::1]) (andrei)\n *             build_req_fomr_sip_req no longer adds 1 for ipv6 via parameter\n *              position calculations ([] are part of host.s now) (andrei)\n * 2003-10-02  via+lump dst address/port can be set to preset values (andrei)\n * 2003-10-08  receive_test function-alized (jiri)\n * 2003-10-20  added body_lump list (sip_msg), adjust_clen (andrei & jan)\n * 2003-11-11  type of rpl_lumps replaced by flags (bogdan)\n * 2007-02-22  insert_path_as_route() imported from TM as we need it for\n *             stateless processing also; contributed by Andreas Granig\n *             (bogdan)\n */\n\n/*!\n * \\file\n * \\brief Create and translate SIP messages/ message contents\n * - \\ref ViaSpecialParams\n */\n\n/*! \\page ViaSpecialParams Via header special parameters\n *\n * Via special params:\n *\n * \\section requests Requests:\n * - if the address in via is different from the src_ip or an existing\n *   received=something is found, received=src_ip is added (and any preexisting\n *   received is deleted). received is added as the first via parameter if no\n *   receive is previously present or over the old receive.\n * - if the original via contains rport / rport=something or msg->msg_flags\n *   FL_FORCE_RPORT is set (e.g. script force_rport() cmd) rport=src_port\n *   is added (over previous rport / as first via param or after received\n *   if no received was present and received is added too)\n * \\section localreplies Local replies:\n *    (see also sl_send_reply)\n *  - rport and received are added in mostly the same way as for requests, but\n *    in the reverse order (first rport and then received). See also\n *    limitations.\n *  - the local reply is sent to the message source ip address. The\n *    destination port is set to the source port if rport is present or\n *    FL_FORCE_RPORT flag is set, to the via port or to\n *    the default sip port (5060) if neither rport or via port are present.\n * \\section normalreplies \"Normal\" replies:\n *  - if received is present the message is sent to the received address else\n *    if no port is present (neither a normal via port or rport) a dns srv\n *    lookup is performed on the host part and the reply is sent to the\n *    resulting ip. If a port is present or the host part is an ip address\n *    the dns lookup will be a \"normal\" one (A or AAAA).\n *  - if rport is present, it's value will be used as the destination port\n *   (and this will also disable srv lookups)\n *  - if no port is present the destination port will be taken from the srv\n *    lookup. If the srv lookup fails or is not performed (e.g. ip address\n *    in host) the destination port will be set to the default sip port (5060).\n *\n * \\section limitations Known limitations:\n * - when locally replying to a message, rport and received will be appended to\n *   the via header parameters (for forwarded requests they are inserted at the\n *   beginning).\n * - a locally generated reply might get two received via parameters if a\n *   received is already present in the original message (this should not\n *   happen though, but ...)\n *\n*/\n\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netdb.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n\n#include \"msg_translator.h\"\n#include \"error.h\"\n#include \"mem/mem.h\"\n#include \"dprint.h\"\n#include \"config.h\"\n#include \"md5utils.h\"\n#include \"data_lump.h\"\n#include \"data_lump_rpl.h\"\n#include \"ip_addr.h\"\n#include \"resolve.h\"\n#include \"ut.h\"\n#include \"pt.h\"\n#include \"context.h\"\n#include \"net/trans.h\"\n\nint disable_503_translation = 0;\n\n#define append_str(_dest,_src,_len) \\\n\tdo{\\\n\t\tmemcpy( (_dest) , (_src) , (_len) );\\\n\t\t(_dest) += (_len) ;\\\n\t}while(0);\n\nextern char version[];\nextern int version_len;\n\n\n/*! \\brief check if IP address in Via != source IP address of signaling */\nint received_test( struct sip_msg *msg )\n{\n\tint rcvd;\n\n\tif(msg->via1->received !=NULL)\n\t\treturn 1;\n\n\tif(msg->via1->maddr){\n\t\trcvd = check_ip_address(&msg->rcv.src_ip, &msg->via1->maddr->value,\n\t\t\tmsg->via1->port, msg->via1->proto, received_dns);\n\t} else {\n\t\trcvd = check_ip_address(&msg->rcv.src_ip,\n\t\t\t&msg->via1->host, msg->via1->port, msg->via1->proto, received_dns);\n\t}\n\n\treturn rcvd;\n}\n\n\nstatic char * warning_builder( struct sip_msg *msg, unsigned int *returned_len)\n{\n\tstatic char buf[MAX_WARNING_LEN];\n\tstr *foo;\n\tint print_len, l, clen;\n\tchar* t;\n\n#define str_print(string, string_len) \\\n\t\tdo{ \\\n\t\t\tl=(string_len); \\\n\t\t\tif ((clen+l)>MAX_WARNING_LEN) \\\n\t\t\t\tgoto error_overflow; \\\n\t\t\tmemcpy(buf+clen, (string), l); \\\n\t\t\tclen+=l; \\\n\t\t}while(0)\n\n#define str_lenpair_print(string, string_len, string2, string2_len) \\\n\t\tdo{ \\\n\t\t\tstr_print(string, string_len); \\\n\t\t\tstr_print(string2, string2_len);\\\n\t\t}while(0)\n\n#define str_pair_print( string, string2, string2_len) \\\n\t\tstr_lenpair_print((string), strlen((string)), (string2), (string2_len))\n\n#define str_int_print(string, intval)\\\n\t\tdo{\\\n\t\t\tt=int2str((intval), &print_len); \\\n\t\t\tstr_pair_print(string, t, print_len);\\\n\t\t} while(0)\n\n#define str_ipaddr_print(string, ipaddr_val)\\\n\t\tdo{\\\n\t\t\tt=ip_addr2a((ipaddr_val)); \\\n\t\t\tprint_len=strlen(t); \\\n\t\t\tstr_pair_print(string, t, print_len);\\\n\t\t} while(0)\n\n\tclen=0;\n\tstr_lenpair_print(WARNING, WARNING_LEN,\n\t\t\t\t\t\tmsg->rcv.bind_address->name.s,\n\t\t\t\t\t\tmsg->rcv.bind_address->name.len);\n\tstr_lenpair_print(\":\", 1, msg->rcv.bind_address->port_no_str.s,\n\t\t\t\t\t\tmsg->rcv.bind_address->port_no_str.len);\n\tstr_print(WARNING_PHRASE, WARNING_PHRASE_LEN);\n\n\t/*adding out_uri*/\n\tif (msg->new_uri.s)\n\t\tfoo=&(msg->new_uri);\n\telse\n\t\tfoo=&(msg->first_line.u.request.uri);\n\t/* pid= */\n\tstr_int_print(\" pid=\", my_pid());\n\t/* req_src_ip= */\n\tstr_ipaddr_print(\" req_src_ip=\", &msg->rcv.src_ip);\n\tstr_int_print(\" req_src_port=\", msg->rcv.src_port);\n\tstr_pair_print(\" in_uri=\", msg->first_line.u.request.uri.s,\n\t\t\t\t\t\t\t\tmsg->first_line.u.request.uri.len);\n\tstr_pair_print(\" out_uri=\", foo->s, foo->len);\n\tstr_pair_print(\" via_cnt\",\n\t\t\t\t(msg->parsed_flag & HDR_EOH_F)==HDR_EOH_F ? \"=\" : \">\", 1);\n\tstr_int_print(\"=\", via_cnt);\n\tif (clen<MAX_WARNING_LEN){ buf[clen]='\"'; clen++; }\n\telse goto error_overflow;\n\n\n\t*returned_len=clen;\n\treturn buf;\nerror_overflow:\n\tLM_ERR(\"buffer size exceeded\\n\");\n\t*returned_len=0;\n\treturn 0;\n}\n\n\n\n\nchar* received_builder(struct sip_msg *msg, unsigned int *received_len)\n{\n\tchar *buf, *tmp;\n\tint  len, tmp_len;\n\tstruct ip_addr *source_ip;\n\n\tsource_ip=&msg->rcv.src_ip;\n\n\tbuf=pkg_malloc(sizeof(char)*MAX_RECEIVED_SIZE);\n\tif (buf==0){\n\t\tser_error=E_OUT_OF_MEM;\n\t\tLM_ERR(\"out of pkg memory\\n\");\n\t\treturn 0;\n\t}\n\tmemcpy(buf, RECEIVED, RECEIVED_LEN);\n\tif ( (tmp=ip_addr2a(source_ip))==0)\n\t\treturn 0; /* error*/\n\ttmp_len=strlen(tmp);\n\tlen=RECEIVED_LEN+tmp_len;\n\n\tmemcpy(buf+RECEIVED_LEN, tmp, tmp_len);\n\tbuf[len]=0; /*null terminate it */\n\n\t*received_len = len;\n\treturn buf;\n}\n\n\n\nchar* rport_builder(struct sip_msg *msg, unsigned int *rport_len)\n{\n\tchar* buf, * tmp;\n\tint len, tmp_len;\n\n\ttmp_len=0;\n\ttmp=int2str(msg->rcv.src_port, &tmp_len);\n\tlen=RPORT_LEN+tmp_len;\n\tbuf=pkg_malloc(sizeof(char)*(len+1));/* space for null term */\n\tif (buf==0){\n\t\tser_error=E_OUT_OF_MEM;\n\t\tLM_ERR(\"out of pkg memory\\n\");\n\t\treturn 0;\n\t}\n\tmemcpy(buf, RPORT, RPORT_LEN);\n\tmemcpy(buf+RPORT_LEN, tmp, tmp_len);\n\tbuf[len]=0; /*null terminate it*/\n\n\t*rport_len=len;\n\treturn buf;\n}\n\n\n\nchar* id_builder(struct sip_msg* msg, unsigned int *id_len)\n{\n\tchar* buf, *p;\n\tint len, value_len, size;\n\tchar revhex[sizeof(int)*2];\n\n\tsize=sizeof(int)*2;\n\tp=&revhex[0];\n\tif (int2reverse_hex(&p, &size, msg->rcv.proto_reserved1)==-1){\n\t\tLM_CRIT(\"not enough space for id\\n\");\n\t\treturn 0;\n\t}\n\tvalue_len=p-&revhex[0];\n\tlen=ID_PARAM_LEN+value_len;\n\tbuf=pkg_malloc(sizeof(char)*(len+1));/* place for ending \\0 */\n\tif (buf==0){\n\t\tser_error=E_OUT_OF_MEM;\n\t\tLM_ERR(\"out of pkg memory\\n\");\n\t\treturn 0;\n\t}\n\tmemcpy(buf, ID_PARAM, ID_PARAM_LEN);\n\tmemcpy(buf+ID_PARAM_LEN, revhex, value_len);\n\tbuf[len]=0; /* null terminate it */\n\t*id_len=len;\n\treturn buf;\n}\n\n\n\nchar* clen_builder(struct sip_msg* msg, int *clen_len, int diff)\n{\n\tchar *buf, * value_s;\n\tint len, value, value_len;\n\tstr body;\n\n\tif ( (get_body(msg,&body)!=0) ) {\n\t\tser_error=E_BAD_REQ;\n\t\tLM_ERR(\"no message body found (missing crlf?)\");\n\t\treturn 0;\n\t}\n\tvalue = body.len + diff;\n\tvalue_s=int2str(value, &value_len);\n\tLM_DBG(\"content-length: %d (%s)\\n\", value, value_s);\n\n\tlen=CONTENT_LENGTH_LEN+value_len+CRLF_LEN;\n\tbuf=pkg_malloc(sizeof(char)*(len+1));\n\tif (buf==0){\n\t\tser_error=E_OUT_OF_MEM;\n\t\tLM_ERR(\"out of pkg memory\\n\");\n\t\treturn 0;\n\t}\n\tmemcpy(buf, CONTENT_LENGTH, CONTENT_LENGTH_LEN);\n\tmemcpy(buf+CONTENT_LENGTH_LEN, value_s, value_len);\n\tmemcpy(buf+CONTENT_LENGTH_LEN+value_len, CRLF, CRLF_LEN);\n\tbuf[len]=0; /* null terminate it */\n\t*clen_len=len;\n\treturn buf;\n}\n\n\n\n/*! \\brief* checks if a lump opt condition\n * returns 1 if cond is true, 0 if false */\nstatic inline int lump_check_opt(\tstruct lump *l,\n\t\t\t\t\t\t\t\t\tstruct sip_msg* msg,\n\t\t\t\t\t\t\t\t\tstruct socket_info* snd_s\n\t\t\t\t\t\t\t\t\t)\n{\n\tstruct ip_addr* ip;\n\tunsigned short port;\n\tint proto;\n\n#define get_ip_port_proto \\\n\t\t\tif (snd_s==0){ \\\n\t\t\t\tLM_CRIT(\"null send socket\\n\"); \\\n\t\t\t\treturn 1; /* we presume they are different :-) */ \\\n\t\t\t} \\\n\t\t\tif (msg->rcv.bind_address){ \\\n\t\t\t\tip=&msg->rcv.bind_address->address; \\\n\t\t\t\tport=msg->rcv.bind_address->port_no; \\\n\t\t\t\tproto=msg->rcv.bind_address->proto; \\\n\t\t\t}else{ \\\n\t\t\t\tip=&msg->rcv.dst_ip; \\\n\t\t\t\tport=msg->rcv.dst_port; \\\n\t\t\t\tproto=msg->rcv.proto; \\\n\t\t\t} \\\n\n\tswitch(l->u.cond){\n\t\tcase COND_FALSE:\n\t\t\treturn 0;\n\t\tcase COND_TRUE:\n\t\t\tl->flags |= LUMPFLAG_COND_TRUE;\n\t\t\treturn 1;\n\t\tcase COND_IF_DIFF_REALMS:\n\t\t\tget_ip_port_proto;\n\t\t\t/* faster tests first */\n\t\t\tif ((port==snd_s->port_no)&&(proto==snd_s->proto)&&\n\t\t\t\t(ip_addr_cmp(ip, &snd_s->address))) {\n\t\t\t\tl->flags &= ~LUMPFLAG_COND_TRUE;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tl->flags |= LUMPFLAG_COND_TRUE;\n\t\t\treturn 1;\n\t\tcase COND_IF_SAME_REALMS:\n\t\t\tget_ip_port_proto;\n\t\t\t/* faster tests first */\n\t\t\tif ((port!=snd_s->port_no)||(proto!=snd_s->proto)||\n\t\t\t\t(!ip_addr_cmp(ip, &snd_s->address))) {\n\t\t\t\tl->flags &= ~LUMPFLAG_COND_TRUE;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tl->flags |= LUMPFLAG_COND_TRUE;\n\t\t\treturn 1;\n\t\tcase COND_IF_DIFF_AF:\n\t\t\tget_ip_port_proto;\n\t\t\tif (ip->af==snd_s->address.af) {\n\t\t\t\tl->flags &= ~LUMPFLAG_COND_TRUE;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tl->flags |= LUMPFLAG_COND_TRUE;\n\t\t\treturn 1;\n\t\tcase COND_IF_DIFF_PROTO:\n\t\t\tget_ip_port_proto;\n\t\t\tif (proto==snd_s->proto) {\n\t\t\t\tl->flags &= ~LUMPFLAG_COND_TRUE;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tl->flags |= LUMPFLAG_COND_TRUE;\n\t\t\treturn 1;\n\t\tcase COND_IF_DIFF_PORT:\n\t\t\tget_ip_port_proto;\n\t\t\tif (port==snd_s->port_no) {\n\t\t\t\tl->flags &= ~LUMPFLAG_COND_TRUE;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tl->flags |= LUMPFLAG_COND_TRUE;\n\t\t\treturn 1;\n\t\tcase COND_IF_DIFF_IP:\n\t\t\tget_ip_port_proto;\n\t\t\tif (ip_addr_cmp(ip, &snd_s->address)) {\n\t\t\t\tl->flags &= ~LUMPFLAG_COND_TRUE;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tl->flags |= LUMPFLAG_COND_TRUE;\n\t\t\treturn 1;\n\t\tdefault:\n\t\t\tLM_CRIT(\"unknown lump condition %d\\n\", l->u.cond);\n\t}\n\treturn 0; /* false */\n}\n\n\n\n/*! \\brief computes the \"unpacked\" len of a lump list,\n   code moved from build_req_from_req */\nint lumps_len(struct sip_msg* msg, struct lump* lumps,\n\t\t\t\t\t\t\t\tstruct socket_info* send_sock, int max_offset)\n{\n\tunsigned int s_offset, new_len;\n\tunsigned int last_del;\n\tstruct lump *t, *r;\n\tstr *send_address_str, *send_port_str;\n\tstr *rcv_address_str=NULL;\n\tstr *rcv_port_str=NULL;\n\n#define SUBST_LUMP_LEN(subst_l) \\\n\t\tswitch((subst_l)->u.subst){ \\\n\t\t\tcase SUBST_RCV_IP: \\\n\t\t\t\tif (msg->rcv.bind_address){ \\\n\t\t\t\t\tnew_len+=rcv_address_str->len; \\\n\t\t\t\t} else \\\n\t\t\t\t\tLM_BUG(\"null bind address 1\"); \\\n\t\t\t\tbreak; \\\n\t\t\tcase SUBST_RCV_PORT: \\\n\t\t\t\tif (msg->rcv.bind_address){ \\\n\t\t\t\t\tnew_len+=rcv_port_str->len; \\\n\t\t\t\t} else \\\n\t\t\t\t\tLM_BUG(\"null bind address 2\"); \\\n\t\t\t\tbreak; \\\n\t\t\tcase SUBST_RCV_PROTO: \\\n\t\t\t\tif (msg->rcv.bind_address){ \\\n\t\t\t\t\tswitch(msg->rcv.bind_address->proto){ \\\n\t\t\t\t\t\t/* TODO change this to look in proto !*/ \\\n\t\t\t\t\t\tcase PROTO_NONE: \\\n\t\t\t\t\t\tcase PROTO_UDP: \\\n\t\t\t\t\t\tcase PROTO_TCP: \\\n\t\t\t\t\t\tcase PROTO_TLS: \\\n\t\t\t\t\t\tcase PROTO_WSS: \\\n\t\t\t\t\t\t\t\tnew_len+=3; \\\n\t\t\t\t\t\t\t\tbreak; \\\n\t\t\t\t\t\tcase PROTO_SCTP: \\\n\t\t\t\t\t\t\t\tnew_len+=4; \\\n\t\t\t\t\t\t\t\tbreak; \\\n\t\t\t\t\t\tcase PROTO_WS: \\\n\t\t\t\t\t\t\t\tnew_len+=2; \\\n\t\t\t\t\t\t\t\tbreak; \\\n\t\t\t\t\t\tdefault: \\\n\t\t\t\t\t\tLM_CRIT(\"unknown proto %d\\n\", \\\n\t\t\t\t\t\t\t\tmsg->rcv.bind_address->proto); \\\n\t\t\t\t\t}\\\n\t\t\t\t} else \\\n\t\t\t\t\tLM_BUG(\"null bind address 3\"); \\\n\t\t\t\tbreak; \\\n\t\t\tcase SUBST_RCV_ALL: \\\n\t\t\t\tif (msg->rcv.bind_address){ \\\n\t\t\t\t\tnew_len+=rcv_address_str->len; \\\n\t\t\t\t\tif (msg->rcv.bind_address->port_no!=SIP_PORT || (rcv_port_str!=&(msg->rcv.bind_address->port_no_str))){ \\\n\t\t\t\t\t\t/* add :port_no */ \\\n\t\t\t\t\t\tnew_len+=1+rcv_port_str->len; \\\n\t\t\t\t\t}\\\n\t\t\t\t\t\t/*add;transport=xxx*/ \\\n\t\t\t\t\tswitch(msg->rcv.bind_address->proto){ \\\n\t\t\t\t\t\tcase PROTO_NONE: \\\n\t\t\t\t\t\tcase PROTO_UDP: \\\n\t\t\t\t\t\t\t\tbreak; /* udp is the default */ \\\n\t\t\t\t\t\tcase PROTO_TCP: \\\n\t\t\t\t\t\tcase PROTO_TLS: \\\n\t\t\t\t\t\tcase PROTO_WSS: \\\n\t\t\t\t\t\t\t\tnew_len+=TRANSPORT_PARAM_LEN+3; \\\n\t\t\t\t\t\t\t\tbreak; \\\n\t\t\t\t\t\tcase PROTO_SCTP: \\\n\t\t\t\t\t\t\t\tnew_len+=TRANSPORT_PARAM_LEN+4; \\\n\t\t\t\t\t\t\t\tbreak; \\\n\t\t\t\t\t\tcase PROTO_WS: \\\n\t\t\t\t\t\t\t\tnew_len+=TRANSPORT_PARAM_LEN+2; \\\n\t\t\t\t\t\t\t\tbreak; \\\n\t\t\t\t\t\tdefault: \\\n\t\t\t\t\t\tLM_CRIT(\"unknown proto %d\\n\", \\\n\t\t\t\t\t\t\t\tmsg->rcv.bind_address->proto); \\\n\t\t\t\t\t}\\\n\t\t\t\t} else \\\n\t\t\t\t\tLM_BUG(\"null bind address 4\"); \\\n\t\t\t\tbreak; \\\n\t\t\tcase SUBST_SND_IP: \\\n\t\t\t\tif (send_sock){ \\\n\t\t\t\t\tnew_len+=send_address_str->len; \\\n\t\t\t\t} else \\\n\t\t\t\t\tLM_BUG(\"null send_socket 1\"); \\\n\t\t\t\tbreak; \\\n\t\t\tcase SUBST_SND_PORT: \\\n\t\t\t\tif (send_sock){ \\\n\t\t\t\t\tnew_len+=send_port_str->len; \\\n\t\t\t\t} else \\\n\t\t\t\t\tLM_BUG(\"null send_socket 2\"); \\\n\t\t\t\tbreak; \\\n\t\t\tcase SUBST_SND_PROTO: \\\n\t\t\t\tif (send_sock){ \\\n\t\t\t\t\tswitch(send_sock->proto){ \\\n\t\t\t\t\t\tcase PROTO_NONE: \\\n\t\t\t\t\t\tcase PROTO_UDP: \\\n\t\t\t\t\t\tcase PROTO_TCP: \\\n\t\t\t\t\t\tcase PROTO_TLS: \\\n\t\t\t\t\t\tcase PROTO_WSS: \\\n\t\t\t\t\t\t\t\tnew_len+=3; \\\n\t\t\t\t\t\t\t\tbreak; \\\n\t\t\t\t\t\tcase PROTO_SCTP: \\\n\t\t\t\t\t\t\t\tnew_len+=4; \\\n\t\t\t\t\t\t\t\tbreak; \\\n\t\t\t\t\t\tcase PROTO_WS: \\\n\t\t\t\t\t\t\t\tnew_len+=2; \\\n\t\t\t\t\t\t\t\tbreak; \\\n\t\t\t\t\t\tdefault: \\\n\t\t\t\t\t\tLM_CRIT(\"unknown proto %d\\n\", \\\n\t\t\t\t\t\t\t\tsend_sock->proto); \\\n\t\t\t\t\t}\\\n\t\t\t\t} else \\\n\t\t\t\t\tLM_BUG(\"null send_socket 3\"); \\\n\t\t\t\tbreak; \\\n\t\t\tcase SUBST_SND_ALL: \\\n\t\t\t\tif (send_sock){ \\\n\t\t\t\t\tnew_len+=send_address_str->len; \\\n\t\t\t\t\tif ((send_sock->port_no!=SIP_PORT) || \\\n\t\t\t\t\t\t\t(send_port_str!=&(send_sock->port_no_str))){ \\\n\t\t\t\t\t\t/* add :port_no */ \\\n\t\t\t\t\t\tnew_len+=1+send_port_str->len; \\\n\t\t\t\t\t}\\\n\t\t\t\t\t/*add;transport=xxx*/ \\\n\t\t\t\t\tswitch(send_sock->proto){ \\\n\t\t\t\t\t\tcase PROTO_NONE: \\\n\t\t\t\t\t\tcase PROTO_UDP: \\\n\t\t\t\t\t\t\t\tbreak; /* udp is the default */ \\\n\t\t\t\t\t\tcase PROTO_TCP: \\\n\t\t\t\t\t\tcase PROTO_TLS: \\\n\t\t\t\t\t\tcase PROTO_WSS: \\\n\t\t\t\t\t\t\t\tnew_len+=TRANSPORT_PARAM_LEN+3; \\\n\t\t\t\t\t\t\t\tbreak; \\\n\t\t\t\t\t\tcase PROTO_SCTP: \\\n\t\t\t\t\t\t\t\tnew_len+=TRANSPORT_PARAM_LEN+4; \\\n\t\t\t\t\t\t\t\tbreak; \\\n\t\t\t\t\t\tcase PROTO_WS: \\\n\t\t\t\t\t\t\t\tnew_len+=TRANSPORT_PARAM_LEN+2; \\\n\t\t\t\t\t\t\t\tbreak; \\\n\t\t\t\t\t\tdefault: \\\n\t\t\t\t\t\tLM_CRIT(\"unknown proto %d\\n\", \\\n\t\t\t\t\t\t\t\tsend_sock->proto); \\\n\t\t\t\t\t}\\\n\t\t\t\t} else \\\n\t\t\t\t\tLM_BUG(\"null send_socket 4\"); \\\n\t\t\t\tbreak; \\\n\t\t\tcase SUBST_NOP: /* do nothing */ \\\n\t\t\t\tbreak; \\\n\t\t\tdefault: \\\n\t\t\t\tLM_CRIT(\"unknown subst type %d\\n\", \\\n\t\t\t\t\t\t(subst_l)->u.subst); \\\n\t\t}\n\n\n\ts_offset=0;\n\tnew_len=0;\n\tlast_del=0;\n\n\t/* init send_address_str & send_port_str */\n\tif(send_sock && send_sock->adv_name_str.len)\n\t\tsend_address_str=&(send_sock->adv_name_str);\n\telse if (msg->set_global_address.s)\n\t\tsend_address_str=&(msg->set_global_address);\n\telse if (default_global_address->s)\n\t\tsend_address_str=default_global_address;\n\telse\n\t\tsend_address_str=&(send_sock->address_str);\n\n\tif(send_sock && send_sock->adv_port_str.len)\n\t\tsend_port_str=&(send_sock->adv_port_str);\n\telse if (msg->set_global_port.s)\n\t\tsend_port_str=&(msg->set_global_port);\n\telse if (default_global_port->s)\n\t\tsend_port_str=default_global_port;\n\telse\n\t\tsend_port_str=&(send_sock->port_no_str);\n\n\t/* init rcv_address_str & rcv_port_str */\n\tif(msg->rcv.bind_address) {\n\t\tif(msg->rcv.bind_address->adv_name_str.len)\n\t\t\trcv_address_str=&(msg->rcv.bind_address->adv_name_str);\n\t\telse if (default_global_address->s)\n\t\t\trcv_address_str=default_global_address;\n\t\telse\n\t\t\trcv_address_str=&(msg->rcv.bind_address->address_str);\n\t\tif(msg->rcv.bind_address->adv_port_str.len)\n\t\t\trcv_port_str=&(msg->rcv.bind_address->adv_port_str);\n\t\telse if (default_global_port->s)\n\t\t\trcv_port_str=default_global_port;\n\t\telse\n\t\t\trcv_port_str=&(msg->rcv.bind_address->port_no_str);\n\t}\n\n\tfor (t = lumps; t && t->u.offset<(unsigned int)max_offset ; t = t->next) {\n\t\t/* is this lump still valid? (it must not be anchored in a deleted area */\n\t\tif (t->u.offset < s_offset && t->u.offset != last_del) {\n\t\t\tLM_DBG(\"skip a %d, buffer offset=%d, lump offset=%d, last_del=%d\\n\",\n\t\t\t\tt->op,s_offset, t->u.offset,last_del);\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor (r = t->before; r; r = r->before) {\n\t\t\tswitch (r->op) {\n\t\t\t\tcase LUMP_ADD:\n\t\t\t\t\tnew_len += r->len;\n\t\t\t\t\tbreak;\n\t\t\t\tcase LUMP_ADD_SUBST:\n\t\t\t\t\tSUBST_LUMP_LEN(r);\n\t\t\t\t\tbreak;\n\t\t\t\tcase LUMP_ADD_OPT:\n\t\t\t\t\t/* skip if this is an OPT lump and the condition is\n\t\t\t\t\t * not satisfied */\n\t\t\t\t\tif (!lump_check_opt(r, msg, send_sock))\n\t\t\t\t\t\tgoto skip_before;\n\t\t\t\t\tbreak;\n\t\t\t\tcase LUMP_SKIP:\n\t\t\t\t\t/* if a SKIP lump, go to the last in the list*/\n\t\t\t\t\tif (!r->before || !r->before->before)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tfor (; r->before->before; r = r->before)\n\t\t\t\t\t\t;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\t/* only ADD allowed for before/after */\n\t\t\t\t\t\tLM_CRIT(\"invalid op for data lump (%x)\\n\", r->op);\n\t\t\t}\n\t\t}\nskip_before:\n\t\tswitch (t->op) {\n\t\t\tcase LUMP_DEL:\n\t\t\t\tlast_del=t->u.offset;\n\n\t\t\t\tif (t->u.offset < s_offset) {\n\t\t\t\t\tif (t->u.offset + t->len > s_offset) {\n\t\t\t\t\t\tnew_len -= t->len - (s_offset - t->u.offset);\n\t\t\t\t\t\ts_offset = t->u.offset + t->len;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tnew_len -= t->len;\n\t\t\t\t\ts_offset = t->u.offset + t->len;\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\tcase LUMP_NOP:\n\t\t\t\t/* do nothing */\n\t\t\t\tbreak;\n\t\t\tcase LUMP_ADD:\n\t\t\t\t/* FIXME: inconsistent with process_lumps() */\n\t\t\t\tnew_len += t->len;\n\t\t\t\tbreak;\n\t\t\tcase LUMP_ADD_OPT:\n\t\t\t\tLM_BUG(\"LUMP_ADD_OPT\");\n\t\t\t\t/* we don't do anything here, it's only a condition for\n\t\t\t\t * before & after */\n\t\t\t\tbreak;\n\t\t\tcase LUMP_SKIP:\n\t\t\t\tLM_BUG(\"LUMP_SKIP\");\n\t\t\t\t/* we don't do anything here, it's only a condition for\n\t\t\t\t * before & after */\n\t\t\t\tbreak;\n\t\t\tcase LUMP_ADD_SUBST:\n\t\t\t\tLM_BUG(\"LUMP_ADD_SUBST\");\n\t\t\t\tSUBST_LUMP_LEN(t);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tLM_BUG(\"op for data lump (%x)\", r->op);\n\t\t}\n\n\t\tfor (r = t->after; r; r = r->after) {\n\t\t\tswitch (r->op) {\n\t\t\t\tcase LUMP_ADD:\n\t\t\t\t\tnew_len+=r->len;\n\t\t\t\t\tbreak;\n\t\t\t\tcase LUMP_ADD_SUBST:\n\t\t\t\t\tSUBST_LUMP_LEN(r);\n\t\t\t\t\tbreak;\n\t\t\t\tcase LUMP_ADD_OPT:\n\t\t\t\t\t/* skip if this is an OPT lump and the condition is\n\t\t\t\t\t * not satisfied */\n\t\t\t\t\tif (!lump_check_opt(r, msg, send_sock))\n\t\t\t\t\t\tgoto skip_after;\n\t\t\t\t\tbreak;\n\t\t\t\tcase LUMP_SKIP:\n\t\t\t\t\t/* if a SKIP lump, go to the last in the list*/\n\t\t\t\t\tif (!r->after || !r->after->after)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tfor (; r->after->after; r = r->after)\n\t\t\t\t\t\t;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\t/* only ADD allowed for before/after */\n\t\t\t\t\tLM_CRIT(\"invalid op for data lump (%x)\\n\", r->op);\n\t\t\t}\n\t\t}\nskip_after:\n\t\t; /* to make gcc 3.* happy */\n\t}\n\treturn new_len;\n}\n\n\n\n/*! \\brief another helper functions, adds/Removes the lump,\n\tcode moved from build_req_from_req  */\n\nvoid process_lumps(\tstruct sip_msg* msg,\n\t\t\t\t\tstruct lump* lumps,\n\t\t\t\t\tchar* new_buf,\n\t\t\t\t\tunsigned int* new_buf_offs,\n\t\t\t\t\tunsigned int* orig_offs,\n\t\t\t\t\tstruct socket_info* send_sock,\n\t\t\t\t\tint max_offset)\n{\n\tstruct lump *t, *r;\n\tchar* orig;\n\tunsigned int size, offset, s_offset;\n\tunsigned int last_del;\n\tstr *send_address_str, *send_port_str;\n\tstr *rcv_address_str=NULL;\n\tstr *rcv_port_str=NULL;\n\n#define SUBST_LUMP(subst_l) \\\n\tswitch((subst_l)->u.subst){ \\\n\t\tcase SUBST_RCV_IP: \\\n\t\t\tif (msg->rcv.bind_address){  \\\n\t\t\t\tmemcpy(new_buf+offset, rcv_address_str->s, \\\n\t\t\t\t\trcv_address_str->len); \\\n\t\t\t\toffset+=rcv_address_str->len; \\\n\t\t\t}else{  \\\n\t\t\t\t/*FIXME*/ \\\n\t\t\t\tLM_CRIT(\"null bind_address\\n\"); \\\n\t\t\t}; \\\n\t\t\tbreak; \\\n\t\tcase SUBST_RCV_PORT: \\\n\t\t\tif (msg->rcv.bind_address){  \\\n\t\t\t\tmemcpy(new_buf+offset, rcv_port_str->s, \\\n\t\t\t\t\t\trcv_port_str->len); \\\n\t\t\t\toffset+=rcv_port_str->len; \\\n\t\t\t}else{  \\\n\t\t\t\t/*FIXME*/ \\\n\t\t\t\tLM_CRIT(\"null bind_address\\n\"); \\\n\t\t\t}; \\\n\t\t\tbreak; \\\n\t\tcase SUBST_RCV_ALL: \\\n\t\t\tif (msg->rcv.bind_address){  \\\n\t\t\t\t/* address */ \\\n\t\t\t\tmemcpy(new_buf+offset, rcv_address_str->s, \\\n\t\t\t\t\t\trcv_address_str->len); \\\n\t\t\t\toffset+=rcv_address_str->len; \\\n\t\t\t\t/* :port */ \\\n\t\t\t\tif (msg->rcv.bind_address->port_no!=SIP_PORT || (rcv_port_str!=&(msg->rcv.bind_address->port_no_str))){ \\\n\t\t\t\t\tnew_buf[offset]=':'; offset++; \\\n\t\t\t\t\tmemcpy(new_buf+offset, \\\n\t\t\t\t\t\t\trcv_port_str->s, \\\n\t\t\t\t\t\t\trcv_port_str->len); \\\n\t\t\t\t\toffset+=rcv_port_str->len; \\\n\t\t\t\t}\\\n\t\t\t\tswitch(msg->rcv.bind_address->proto){ \\\n\t\t\t\t\t/* TODO: change this to look into protos ! */ \\\n\t\t\t\t\tcase PROTO_NONE: \\\n\t\t\t\t\tcase PROTO_UDP: \\\n\t\t\t\t\t\tbreak; /* nothing to do, udp is default*/ \\\n\t\t\t\t\tcase PROTO_TCP: \\\n\t\t\t\t\t\tmemcpy(new_buf+offset, TRANSPORT_PARAM, \\\n\t\t\t\t\t\t\t\tTRANSPORT_PARAM_LEN); \\\n\t\t\t\t\t\toffset+=TRANSPORT_PARAM_LEN; \\\n\t\t\t\t\t\tmemcpy(new_buf+offset, \"tcp\", 3); \\\n\t\t\t\t\t\toffset+=3; \\\n\t\t\t\t\t\tbreak; \\\n\t\t\t\t\tcase PROTO_TLS: \\\n\t\t\t\t\t\tmemcpy(new_buf+offset, TRANSPORT_PARAM, \\\n\t\t\t\t\t\t\t\tTRANSPORT_PARAM_LEN); \\\n\t\t\t\t\t\toffset+=TRANSPORT_PARAM_LEN; \\\n\t\t\t\t\t\tmemcpy(new_buf+offset, \"tls\", 3); \\\n\t\t\t\t\t\toffset+=3; \\\n\t\t\t\t\t\tbreak; \\\n\t\t\t\t\tcase PROTO_SCTP: \\\n\t\t\t\t\t\tmemcpy(new_buf+offset, TRANSPORT_PARAM, \\\n\t\t\t\t\t\t\t\tTRANSPORT_PARAM_LEN); \\\n\t\t\t\t\t\toffset+=TRANSPORT_PARAM_LEN; \\\n\t\t\t\t\t\tmemcpy(new_buf+offset, \"sctp\", 4); \\\n\t\t\t\t\t\toffset+=4; \\\n\t\t\t\t\t\tbreak; \\\n\t\t\t\t\tcase PROTO_WS: \\\n\t\t\t\t\t\tmemcpy(new_buf+offset, TRANSPORT_PARAM, \\\n\t\t\t\t\t\t\t\tTRANSPORT_PARAM_LEN); \\\n\t\t\t\t\t\toffset+=TRANSPORT_PARAM_LEN; \\\n\t\t\t\t\t\tmemcpy(new_buf+offset, \"ws\", 2); \\\n\t\t\t\t\t\toffset+=2; \\\n\t\t\t\t\t\tbreak; \\\n\t\t\t\t\tcase PROTO_WSS: \\\n\t\t\t\t\t\tmemcpy(new_buf+offset, TRANSPORT_PARAM, \\\n\t\t\t\t\t\t\t\tTRANSPORT_PARAM_LEN); \\\n\t\t\t\t\t\toffset+=TRANSPORT_PARAM_LEN; \\\n\t\t\t\t\t\tmemcpy(new_buf+offset, \"wss\", 3); \\\n\t\t\t\t\t\toffset+=3; \\\n\t\t\t\t\t\tbreak; \\\n\t\t\t\t\tdefault: \\\n\t\t\t\t\t\tLM_CRIT(\"unknown proto %d\\n\", \\\n\t\t\t\t\t\t\t\tmsg->rcv.bind_address->proto); \\\n\t\t\t\t} \\\n\t\t\t}else{  \\\n\t\t\t\t/*FIXME*/ \\\n\t\t\t\tLM_CRIT(\"null bind_address\\n\"); \\\n\t\t\t}; \\\n\t\t\tbreak; \\\n\t\tcase SUBST_SND_IP: \\\n\t\t\tif (send_sock){  \\\n\t\t\t\tmemcpy(new_buf+offset, send_address_str->s, \\\n\t\t\t\t\t\t\t\t\tsend_address_str->len); \\\n\t\t\t\toffset+=send_address_str->len; \\\n\t\t\t}else{  \\\n\t\t\t\t/*FIXME*/ \\\n\t\t\t\tLM_CRIT(\"called with null send_sock\\n\"); \\\n\t\t\t}; \\\n\t\t\tbreak; \\\n\t\tcase SUBST_SND_PORT: \\\n\t\t\tif (send_sock){  \\\n\t\t\t\tmemcpy(new_buf+offset, send_port_str->s, \\\n\t\t\t\t\t\t\t\t\tsend_port_str->len); \\\n\t\t\t\toffset+=send_port_str->len; \\\n\t\t\t}else{  \\\n\t\t\t\t/*FIXME*/ \\\n\t\t\t\tLM_CRIT(\"called with null send_sock\\n\"); \\\n\t\t\t}; \\\n\t\t\tbreak; \\\n\t\tcase SUBST_SND_ALL: \\\n\t\t\tif (send_sock){  \\\n\t\t\t\t/* address */ \\\n\t\t\t\tmemcpy(new_buf+offset, send_address_str->s, \\\n\t\t\t\t\t\tsend_address_str->len); \\\n\t\t\t\toffset+=send_address_str->len; \\\n\t\t\t\t/* :port */ \\\n\t\t\t\tif ((send_sock->port_no!=SIP_PORT) || \\\n\t\t\t\t\t(send_port_str!=&(send_sock->port_no_str))){ \\\n\t\t\t\t\tnew_buf[offset]=':'; offset++; \\\n\t\t\t\t\tmemcpy(new_buf+offset, send_port_str->s, \\\n\t\t\t\t\t\t\tsend_port_str->len); \\\n\t\t\t\t\toffset+=send_port_str->len; \\\n\t\t\t\t}\\\n\t\t\t\tswitch(send_sock->proto){ \\\n\t\t\t\t\tcase PROTO_NONE: \\\n\t\t\t\t\tcase PROTO_UDP: \\\n\t\t\t\t\t\tbreak; /* nothing to do, udp is default*/ \\\n\t\t\t\t\tcase PROTO_TCP: \\\n\t\t\t\t\t\tmemcpy(new_buf+offset, TRANSPORT_PARAM, \\\n\t\t\t\t\t\t\t\tTRANSPORT_PARAM_LEN); \\\n\t\t\t\t\t\toffset+=TRANSPORT_PARAM_LEN; \\\n\t\t\t\t\t\tmemcpy(new_buf+offset, \"tcp\", 3); \\\n\t\t\t\t\t\toffset+=3; \\\n\t\t\t\t\t\tbreak; \\\n\t\t\t\t\tcase PROTO_TLS: \\\n\t\t\t\t\t\tmemcpy(new_buf+offset, TRANSPORT_PARAM, \\\n\t\t\t\t\t\t\t\tTRANSPORT_PARAM_LEN); \\\n\t\t\t\t\t\toffset+=TRANSPORT_PARAM_LEN; \\\n\t\t\t\t\t\tmemcpy(new_buf+offset, \"tls\", 3); \\\n\t\t\t\t\t\toffset+=3; \\\n\t\t\t\t\t\tbreak; \\\n\t\t\t\t\tcase PROTO_SCTP: \\\n\t\t\t\t\t\tmemcpy(new_buf+offset, TRANSPORT_PARAM, \\\n\t\t\t\t\t\t\t\tTRANSPORT_PARAM_LEN); \\\n\t\t\t\t\t\toffset+=TRANSPORT_PARAM_LEN; \\\n\t\t\t\t\t\tmemcpy(new_buf+offset, \"sctp\", 4); \\\n\t\t\t\t\t\toffset+=4; \\\n\t\t\t\t\t\tbreak; \\\n\t\t\t\t\tcase PROTO_WS: \\\n\t\t\t\t\t\tmemcpy(new_buf+offset, TRANSPORT_PARAM, \\\n\t\t\t\t\t\t\t\tTRANSPORT_PARAM_LEN); \\\n\t\t\t\t\t\toffset+=TRANSPORT_PARAM_LEN; \\\n\t\t\t\t\t\tmemcpy(new_buf+offset, \"ws\", 2); \\\n\t\t\t\t\t\toffset+=2; \\\n\t\t\t\t\t\tbreak; \\\n\t\t\t\t\tcase PROTO_WSS: \\\n\t\t\t\t\t\tmemcpy(new_buf+offset, TRANSPORT_PARAM, \\\n\t\t\t\t\t\t\t\tTRANSPORT_PARAM_LEN); \\\n\t\t\t\t\t\toffset+=TRANSPORT_PARAM_LEN; \\\n\t\t\t\t\t\tmemcpy(new_buf+offset, \"wss\", 3); \\\n\t\t\t\t\t\toffset+=3; \\\n\t\t\t\t\t\tbreak; \\\n\t\t\t\t\tdefault: \\\n\t\t\t\t\t\tLM_CRIT(\"unknown proto %d\\n\", \\\n\t\t\t\t\t\t\t\tsend_sock->proto); \\\n\t\t\t\t} \\\n\t\t\t}else{  \\\n\t\t\t\t/*FIXME*/ \\\n\t\t\t\tLM_CRIT(\"null bind_address\\n\"); \\\n\t\t\t}; \\\n\t\t\tbreak; \\\n\t\tcase SUBST_RCV_PROTO: \\\n\t\t\tif (msg->rcv.bind_address){ \\\n\t\t\t\tswitch(msg->rcv.bind_address->proto){ \\\n\t\t\t\t\tcase PROTO_NONE: \\\n\t\t\t\t\tcase PROTO_UDP: \\\n\t\t\t\t\t\tmemcpy(new_buf+offset, \"udp\", 3); \\\n\t\t\t\t\t\toffset+=3; \\\n\t\t\t\t\t\tbreak; \\\n\t\t\t\t\tcase PROTO_TCP: \\\n\t\t\t\t\t\tmemcpy(new_buf+offset, \"tcp\", 3); \\\n\t\t\t\t\t\toffset+=3; \\\n\t\t\t\t\t\tbreak; \\\n\t\t\t\t\tcase PROTO_TLS: \\\n\t\t\t\t\t\tmemcpy(new_buf+offset, \"tls\", 3); \\\n\t\t\t\t\t\toffset+=3; \\\n\t\t\t\t\t\tbreak; \\\n\t\t\t\t\tcase PROTO_SCTP: \\\n\t\t\t\t\t\tmemcpy(new_buf+offset, \"sctp\", 4); \\\n\t\t\t\t\t\toffset+=4; \\\n\t\t\t\t\t\tbreak; \\\n\t\t\t\t\tcase PROTO_WS: \\\n\t\t\t\t\t\tmemcpy(new_buf+offset, \"ws\", 2); \\\n\t\t\t\t\t\toffset+=2; \\\n\t\t\t\t\t\tbreak; \\\n\t\t\t\t\tcase PROTO_WSS: \\\n\t\t\t\t\t\tmemcpy(new_buf+offset, \"wss\", 3); \\\n\t\t\t\t\t\toffset+=3; \\\n\t\t\t\t\t\tbreak; \\\n\t\t\t\t\tdefault: \\\n\t\t\t\t\t\tLM_CRIT(\"unknown proto %d\\n\", \\\n\t\t\t\t\t\t\t\tmsg->rcv.bind_address->proto); \\\n\t\t\t\t} \\\n\t\t\t}else{  \\\n\t\t\t\t/*FIXME*/ \\\n\t\t\t\tLM_CRIT(\"called with null send_sock \\n\"); \\\n\t\t\t}; \\\n\t\t\tbreak; \\\n\t\tcase  SUBST_SND_PROTO: \\\n\t\t\tif (send_sock){ \\\n\t\t\t\tswitch(send_sock->proto){ \\\n\t\t\t\t\tcase PROTO_NONE: \\\n\t\t\t\t\tcase PROTO_UDP: \\\n\t\t\t\t\t\tmemcpy(new_buf+offset, \"udp\", 3); \\\n\t\t\t\t\t\toffset+=3; \\\n\t\t\t\t\t\tbreak; \\\n\t\t\t\t\tcase PROTO_TCP: \\\n\t\t\t\t\t\tmemcpy(new_buf+offset, \"tcp\", 3); \\\n\t\t\t\t\t\toffset+=3; \\\n\t\t\t\t\t\tbreak; \\\n\t\t\t\t\tcase PROTO_TLS: \\\n\t\t\t\t\t\tmemcpy(new_buf+offset, \"tls\", 3); \\\n\t\t\t\t\t\toffset+=3; \\\n\t\t\t\t\t\tbreak; \\\n\t\t\t\t\tcase PROTO_SCTP: \\\n\t\t\t\t\t\tmemcpy(new_buf+offset, \"sctp\", 4); \\\n\t\t\t\t\t\toffset+=4; \\\n\t\t\t\t\t\tbreak; \\\n\t\t\t\t\tcase PROTO_WS: \\\n\t\t\t\t\t\tmemcpy(new_buf+offset, \"ws\", 2); \\\n\t\t\t\t\t\toffset+=2; \\\n\t\t\t\t\t\tbreak; \\\n\t\t\t\t\tcase PROTO_WSS: \\\n\t\t\t\t\t\tmemcpy(new_buf+offset, \"wss\", 3); \\\n\t\t\t\t\t\toffset+=3; \\\n\t\t\t\t\t\tbreak; \\\n\t\t\t\t\tdefault: \\\n\t\t\t\t\t\tLM_CRIT(\"unknown proto %d\\n\", \\\n\t\t\t\t\t\t\t\tsend_sock->proto); \\\n\t\t\t\t} \\\n\t\t\t}else{  \\\n\t\t\t\t/*FIXME*/ \\\n\t\t\t\tLM_CRIT(\"called with null send_sock \\n\"); \\\n\t\t\t}; \\\n\t\t\tbreak; \\\n\t\tdefault: \\\n\t\t\t\t\tLM_CRIT(\"unknown subst type %d\\n\", \\\n\t\t\t\t\t\t\t(subst_l)->u.subst); \\\n\t} \\\n \\\n\n\t/* init send_address_str & send_port_str */\n\tif(send_sock && send_sock->adv_name_str.len)\n\t\tsend_address_str=&(send_sock->adv_name_str);\n\telse if (msg->set_global_address.len)\n\t\tsend_address_str=&(msg->set_global_address);\n\telse if (default_global_address->s)\n\t\tsend_address_str=default_global_address;\n\telse\n\t\tsend_address_str=&(send_sock->address_str);\n\tif(send_sock && send_sock->adv_port_str.len)\n\t\tsend_port_str=&(send_sock->adv_port_str);\n\telse if (msg->set_global_port.len)\n\t\tsend_port_str=&(msg->set_global_port);\n\telse if (default_global_port->s)\n\t\tsend_port_str=default_global_port;\n\telse\n\t\tsend_port_str=&(send_sock->port_no_str);\n\n\t/* init rcv_address_str & rcv_port_str */\n\tif(msg->rcv.bind_address) {\n\t\tif(msg->rcv.bind_address->adv_name_str.len)\n\t\t\trcv_address_str=&(msg->rcv.bind_address->adv_name_str);\n\t\telse if (default_global_address->s)\n\t\t\trcv_address_str=default_global_address;\n\t\telse\n\t\t\trcv_address_str=&(msg->rcv.bind_address->address_str);\n\t\tif(msg->rcv.bind_address->adv_port_str.len)\n\t\t\trcv_port_str=&(msg->rcv.bind_address->adv_port_str);\n\t\telse if (default_global_port->s)\n\t\t\trcv_port_str=default_global_port;\n\t\telse\n\t\t\trcv_port_str=&(msg->rcv.bind_address->port_no_str);\n\t}\n\n\torig=msg->buf;\n\toffset=*new_buf_offs;\n\ts_offset=*orig_offs;\n\tlast_del=0;\n\n\tfor (t = lumps; t && t->u.offset<(unsigned int)max_offset ; t = t->next) {\n\t\t/* skip this lump if the \"offset\" is still in a \"deleted\" area */\n\t\tif (t->u.offset < s_offset && t->u.offset != last_del) {\n\t\t\tLM_DBG(\"skip a %d, buffer offset=%d, lump offset=%d, last_del=%d\\n\",\n\t\t\t\tt->op,s_offset, t->u.offset,last_del);\n\t\t\tcontinue;\n\t\t}\n\n\t\tswitch (t->op) {\n\t\t\tcase LUMP_NOP:\n\t\t\tcase LUMP_DEL:\n\t\t\t\t/* copy till offset (if any) */\n\t\t\t\tif (s_offset < t->u.offset) {\n\t\t\t\t\tsize = t->u.offset-s_offset;\n\t\t\t\t\tmemcpy(new_buf+offset, orig+s_offset, size);\n\t\t\t\t\toffset += size;\n\t\t\t\t\ts_offset += size;\n\t\t\t\t}\n\n\t\t\t\tif (t->op == LUMP_DEL)\n\t\t\t\t\tlast_del = t->u.offset;\n\n\t\t\t\t/* process before  */\n\t\t\t\tfor (r = t->before; r; r = r->before) {\n\t\t\t\t\tswitch (r->op) {\n\t\t\t\t\t\tcase LUMP_ADD:\n\t\t\t\t\t\t\t/*just add it here*/\n\t\t\t\t\t\t\tmemcpy(new_buf+offset, r->u.value, r->len);\n\t\t\t\t\t\t\toffset += r->len;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase LUMP_ADD_SUBST:\n\t\t\t\t\t\t\tSUBST_LUMP(r);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase LUMP_ADD_OPT:\n\t\t\t\t\t\t\t/* skip if this is an OPT lump and the condition is\n\t\t\t\t\t \t\t* not satisfied */\n\t\t\t\t\t\t\tif (!lump_check_opt(r, msg, send_sock))\n\t\t\t\t\t\t\t\tgoto skip_nop_before;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase LUMP_SKIP:\n\t\t\t\t\t\t\t/* if a SKIP lump, go to the last in the list*/\n\t\t\t\t\t\t\tif (!r->before || !r->before->before)\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\tfor (; r->before->before; r = r->before)\n\t\t\t\t\t\t\t\t;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t/* only ADD allowed for before/after */\n\t\t\t\t\t\t\tLM_BUG(\"invalid op 1 (%x)\",r->op);\n\t\t\t\t\t}\n\t\t\t\t}\nskip_nop_before:\n\t\t\t\tif (t->op == LUMP_DEL) {\n\t\t\t\t\t/*\n\t\t\t\t\t * skip at most len bytes from orig msg\n\t\t\t\t\t * and properly handle DEL lumps at the same offset --liviu\n\t\t\t\t\t */\n\t\t\t\t\tif (t->u.offset + t->len > s_offset)\n\t\t\t\t\t\ts_offset += t->len - (s_offset - t->u.offset);\n\t\t\t\t}\n\n\t\t\t\t/* process after */\n\t\t\t\tfor (r = t->after; r; r = r->after) {\n\t\t\t\t\tswitch (r->op) {\n\t\t\t\t\t\tcase LUMP_ADD:\n\t\t\t\t\t\t\t/*just add it here*/\n\t\t\t\t\t\t\tmemcpy(new_buf+offset, r->u.value, r->len);\n\t\t\t\t\t\t\toffset += r->len;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase LUMP_ADD_SUBST:\n\t\t\t\t\t\t\tSUBST_LUMP(r);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase LUMP_ADD_OPT:\n\t\t\t\t\t\t\t/* skip if this is an OPT lump and the condition is\n\t\t\t\t\t \t\t* not satisfied */\n\t\t\t\t\t\t\tif (!lump_check_opt(r, msg, send_sock))\n\t\t\t\t\t\t\t\tgoto skip_nop_after;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase LUMP_SKIP:\n\t\t\t\t\t\t\t/* if a SKIP lump, go to the last in the list*/\n\t\t\t\t\t\t\tif (!r->after || !r->after->after)\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\tfor (; r->after->after; r = r->after)\n\t\t\t\t\t\t\t\t;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t/* only ADD allowed for before/after */\n\t\t\t\t\t\t\tLM_BUG(\"invalid op 2 (%x)\", r->op);\n\t\t\t\t\t}\n\t\t\t\t}\nskip_nop_after:\n\t\t\t\tbreak;\n\t\t\tcase LUMP_ADD:\n\t\t\tcase LUMP_ADD_SUBST:\n\t\t\tcase LUMP_ADD_OPT:\n\t\t\t\tLM_BUG(\"ADD|SUBST|OPT\");\n\t\t\t\t/* skip if this is an OPT lump and the condition is\n\t\t\t\t * not satisfied */\n\t\t\t\tif ((t->op==LUMP_ADD_OPT) &&\n\t\t\t\t\t\t(!lump_check_opt(t, msg, send_sock)))\n\t\t\t\t\tcontinue;\n\t\t\t\t/* just add it here! */\n\t\t\t\t/* process before  */\n\t\t\t\tfor(r=t->before;r;r=r->before){\n\t\t\t\t\tswitch (r->op){\n\t\t\t\t\t\tcase LUMP_ADD:\n\t\t\t\t\t\t\t/*just add it here*/\n\t\t\t\t\t\t\tmemcpy(new_buf+offset, r->u.value, r->len);\n\t\t\t\t\t\t\toffset+=r->len;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase LUMP_ADD_SUBST:\n\t\t\t\t\t\t\tSUBST_LUMP(r);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase LUMP_ADD_OPT:\n\t\t\t\t\t\t\t/* skip if this is an OPT lump and the condition is\n\t\t\t\t\t \t\t* not satisfied */\n\t\t\t\t\t\t\tif (!lump_check_opt(r, msg, send_sock))\n\t\t\t\t\t\t\t\tgoto skip_before;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase LUMP_SKIP:\n\t\t\t\t\t\t\t/* if a SKIP lump, go to the last in the list*/\n\t\t\t\t\t\t\tif (!r->before || !r->before->before) continue;\n\t\t\t\t\t\t\tfor(;r->before->before;r=r->before);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t/* only ADD allowed for before/after */\n\t\t\t\t\t\t\tLM_BUG(\"invalid op 3 (%x)\", r->op);\n\t\t\t\t\t}\n\t\t\t\t}\nskip_before:\n\t\t\t\t/* copy \"main\" part */\n\t\t\t\tswitch(t->op){\n\t\t\t\t\tcase LUMP_ADD:\n\t\t\t\t\t\tmemcpy(new_buf+offset, t->u.value, t->len);\n\t\t\t\t\t\toffset+=t->len;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase LUMP_ADD_SUBST:\n\t\t\t\t\t\tSUBST_LUMP(t);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase LUMP_ADD_OPT:\n\t\t\t\t\t\t/* do nothing, it's only a condition */\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\t/* should not ever get here */\n\t\t\t\t\t\tLM_BUG(\"invalid op 4 %d\", t->op);\n\t\t\t\t}\n\t\t\t\t/* process after */\n\t\t\t\tfor(r=t->after;r;r=r->after){\n\t\t\t\t\tswitch (r->op){\n\t\t\t\t\t\tcase LUMP_ADD:\n\t\t\t\t\t\t\t/*just add it here*/\n\t\t\t\t\t\t\tmemcpy(new_buf+offset, r->u.value, r->len);\n\t\t\t\t\t\t\toffset+=r->len;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase LUMP_ADD_SUBST:\n\t\t\t\t\t\t\tSUBST_LUMP(r);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase LUMP_ADD_OPT:\n\t\t\t\t\t\t\t/* skip if this is an OPT lump and the condition is\n\t\t\t\t\t \t\t* not satisfied */\n\t\t\t\t\t\t\tif (!lump_check_opt(r, msg, send_sock))\n\t\t\t\t\t\t\t\tgoto skip_after;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase LUMP_SKIP:\n\t\t\t\t\t\t\t/* if a SKIP lump, go to the last in the list*/\n\t\t\t\t\t\t\tif (!r->after || !r->after->after) continue;\n\t\t\t\t\t\t\tfor(;r->after->after;r=r->after);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t/* only ADD allowed for before/after */\n\t\t\t\t\t\t\tLM_BUG(\"invalid op 5 (%x)\", r->op);\n\t\t\t\t\t}\n\t\t\t\t}\nskip_after:\n\t\t\t\tbreak;\n\t\t\tcase LUMP_SKIP:\n\t\t\t\tLM_BUG(\"LUMP_SKIP\");\n\t\t\t\t/* if a SKIP lump, go to the last in the list*/\n\t\t\t\tif (!t->next || !t->next->next)\n\t\t\t\t\tcontinue;\n\t\t\t\tfor (; t->next->next; t = t->next)\n\t\t\t\t\t;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tLM_BUG(\"invalid op 6 (%x)\", t->op);\n\t\t}\n\t}\n\n\t*new_buf_offs = offset;\n\t*orig_offs = s_offset;\n}\n\n\n/* Prepares a body to be re-assembled. This consists of the following ops:\n *   - run the functions to build the parts (if the case)\n *   - add SIP header lumps to change CT header \n *   - estimating the new len of the body (after applying all the changes)\n * IMPORTANT: keep this function in sync with the reassemble_body_parts()\n *    to be 100% that estimating and building the body leads to the same\n *    result (as len).\n */\nunsigned int prep_reassemble_body_parts( struct sip_msg* msg,\n\t\t\t\t\t\t\t\t\t\t\t\tstruct socket_info* send_sock)\n{\n\tstruct body_part *part;\n\tstruct lump* lump;\n\tstruct lump* ct;\n\tunsigned int size;\n\tunsigned int len = 0;\n\tunsigned int orig_offs;\n\tstruct hdr_field hf;\n\tchar *hdr, *it;\n\n\t/* set the offset (in the original buffer) at the beginning of the body */\n\torig_offs = msg->body->part_count ? msg->body->body.s-msg->buf : msg->len ;\n\n\tif (msg->body->updated_part_count==0) {\n\n\t\t/* no body to be placed in the new msg !\n\t\t * simply skip the entire body */\n\t\tLM_DBG(\"no part to be added\\n\");\n\n\t\t/* Remove Content-Type hdr if present */\n\t\tif (msg->content_type && msg->content_type->name.s\n\t\t&& msg->content_type->name.len\n\t\t&& del_lump(msg, msg->content_type->name.s- msg->buf,\n\t\tmsg->content_type->len, HDR_CONTENTTYPE_T)==0) {\n\t\t\tLM_ERR(\"failed to add lump to delete content type header\\n\");\n\t\t}\n\n\t} else if (msg->body->updated_part_count==1) {\n\n\t\t/* there is only one part to be added, so iterate\n\t\t * and find it */\n\t\tLM_DBG(\"only one part to be added\\n\");\n\n\t\tfor( part=&msg->body->first ; part ; part=part->next)\n\t\t\tif ( (part->flags & SIP_BODY_PART_FLAG_DELETED)==0 ) break;\n\n\t\tif (part==NULL) {\n\t\t\tLM_BUG(\"updated count is 1, but no non-deleted part found :-/\\n\");\n\t\t\treturn len /* 0 */;\n\t\t}\n\n\t\tLM_DBG(\"handing part with flags %x, mime %.*s, dump function %p\\n\",\n\t\t\tpart->flags, part->mime_s.len, part->mime_s.s, part->dump_f);\n\n\t\tif (part->dump_f) {\n\t\t\t/* trigger the the dump function link the resulting buffer\n\t\t\t * as 'dump' (and to be used and freed when the body buffer\n\t\t\t * is actually built) */\n\t\t\tif (part->dump_f( part->parsed ,msg, &part->dump)<0) {\n\t\t\t\tLM_ERR(\"failed to build part, inserting empty\\n\");\n\t\t\t\tpart->dump.s = \"\";\n\t\t\t\tpart->dump.len = 0;\n\t\t\t} else\n\t\t\t\tlen += part->dump.len;\n\t\t} else {\n\t\t\tif ( part->flags & SIP_BODY_PART_FLAG_NEW ) {\n\t\t\t\t/* simpy copy the body of the part */\n\t\t\t\tlen += part->body.len;\n\t\t\t} else {\n\t\t\t\t/* this is one part that was received (so potentially\n\t\t\t\t * modified during runtime) -> apply all body lumps\n\t\t\t\t * inside this part */\n\t\t\t\torig_offs = part->body.s - msg->buf;\n\t\t\t\tlump = msg->body_lumps;\n\t\t\t\twhile ( lump && lump->u.offset<(part->body.s-msg->buf) )\n\t\t\t\t\tlump=lump->next;\n\t\t\t\tif (lump) {\n\t\t\t\t\tLM_DBG(\"lumps found in the part, applying...\\n\");\n\t\t\t\t\tlen += lumps_len( msg, lump, send_sock, \n\t\t\t\t\t\tpart->body.s+part->body.len-msg->buf);\n\t\t\t\t}\n\t\t\t\t/* and copy whatever is left, all the way to the end of part */\n\t\t\t\tlen += (part->body.s+part->body.len-msg->buf)-orig_offs;\n\t\t\t}\n\t\t}\n\n\t\t/* if the part is new (0->1 addition or 1->1 replacement) or\n\t\t * if the part is kept from a stipped multi-part  (n->1)\n\t\t *   =>  replace the msg content-type with the new one */\n\t\tif ( (part->flags & SIP_BODY_PART_FLAG_NEW)\n\t\t|| msg->body->part_count>1 ) {\n\t\t\t/* replace the Content-Type hdr */\n\t\t\tif (msg->content_type)\n\t\t\t\tct = del_lump(msg, msg->content_type->name.s-msg->buf,\n\t\t\t\t\tmsg->content_type->len, HDR_CONTENTTYPE_T);\n\t\t\telse\n\t\t\t\tct = anchor_lump(msg, msg->unparsed - msg->buf,\n\t\t\t\t\tHDR_CONTENTTYPE_T);\n\t\t\tif (ct==NULL) {\n\t\t\t\tLM_ERR(\"failed to remove old CT / create anchor\\n\");\n\t\t\t} else {\n\t\t\t\t/* if a new part, we need to build the CT header; if a \n\t\t\t\t * received part, simply copied from the part */\n\t\t\t\tif (part->flags & SIP_BODY_PART_FLAG_NEW) {\n\t\t\t\t\thdr = (char*)pkg_malloc( 14 + part->mime_s.len +CRLF_LEN +\n\t\t\t\t\t\tpart->headers.len);\n\t\t\t\t\tif (hdr==NULL) {\n\t\t\t\t\t\tLM_ERR(\"failed to allocate new ct hdr\\n\");\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmemcpy( hdr, \"Content-Type: \", 14);\n\t\t\t\t\t\tmemcpy( hdr+14, part->mime_s.s, part->mime_s.len);\n\t\t\t\t\t\tmemcpy( hdr+14+part->mime_s.len, CRLF, CRLF_LEN);\n\t\t\t\t\t\tif (part->headers.len)\n\t\t\t\t\t\t\tmemcpy( hdr+14+part->mime_s.len+CRLF_LEN,\n\t\t\t\t\t\t\t\tpart->headers.s, part->headers.len);\n\t\t\t\t\t\tif (insert_new_lump_before(ct, hdr,\n\t\t\t\t\t\t14+part->mime_s.len+CRLF_LEN+part->headers.len,\n\t\t\t\t\t\tHDR_CONTENTTYPE_T) == NULL) {\n\t\t\t\t\t\t\tLM_ERR(\"failed to create insert lump\\n\");\n\t\t\t\t\t\t\tpkg_free(hdr);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t/* iterate all the SIP hdrs from this part and keep all\n\t\t\t\t\t * except the \"Content-Length\" */\n\t\t\t\t\tit = part->headers.s;\n\t\t\t\t\twhile ( it<part->headers.s+part->headers.len ) {\n\t\t\t\t\t\tmemset( &hf, 0, sizeof(struct hdr_field));\n\t\t\t\t\t\tit = get_hdr_field( it, part->headers.s+part->headers.len, &hf);\n\t\t\t\t\t\tif (hf.type==HDR_ERROR_T || hf.type==HDR_EOH_T)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tif (hf.type==HDR_CONTENTLENGTH_T)\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t/* add this hdr */\n\t\t\t\t\t\thdr = (char*)pkg_malloc( hf.len);\n\t\t\t\t\t\tif (hdr==NULL) {\n\t\t\t\t\t\t\tLM_ERR(\"failed to allocate new ct hdr\\n\");\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tmemcpy( hdr, hf.name.s, hf.len);\n\t\t\t\t\t\t\tif (insert_new_lump_before(ct, hdr,\n\t\t\t\t\t\t\thf.len, HDR_CONTENTTYPE_T) == NULL) {\n\t\t\t\t\t\t\t\tLM_ERR(\"failed to create insert lump\\n\");\n\t\t\t\t\t\t\t\tpkg_free(hdr);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else\n\t\t\t/* if it is an 1->1 keeping the part, try to preserve the\n\t\t\t * the packing (multi-part or not) of this part */\n\t\t\tif ( (part->flags & SIP_BODY_PART_FLAG_NEW)==0 &&\n\t\t\tmsg->body->part_count==1 &&\n\t\t\tmsg->body->flags & SIP_BODY_RCV_MULTIPART) {\n\t\t\t\t/* preserve the original multi-part packing by preserving\n\t\t\t\t * the before and after padding between part and body */\n\t\t\t\tlen += msg->body->body.len - part->body.len;\n\t\t\t}\n\n\t} else if (msg->body->part_count<2) {\n\n\t\t/* transition from 0/1 to multiple parts,\n\t\t * so we need to add boundries */\n\n\t\tLM_DBG(\"transition from 0/1 parts to multi part body\\n\");\n\t\tlump = msg->body_lumps;\n\n\t\tfor( part=&msg->body->first ; part ; part=part->next) {\n\n\t\t\tLM_DBG(\"handing part with flags %x, mime %.*s, dump function %p\\n\",\n\t\t\t\tpart->flags, part->mime_s.len, part->mime_s.s, part->dump_f);\n\n\t\t\t/* skip deleted parts */\n\t\t\tif ( (part->flags & SIP_BODY_PART_FLAG_DELETED) ) {\n\t\t\t\tif ((part->flags & SIP_BODY_PART_FLAG_NEW) == 0)\n\t\t\t\t\t/* reposition at the end of the skipped body */\n\t\t\t\t\torig_offs = part->body.s+part->body.len-msg->buf+CRLF_LEN;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* separator and CT header */\n\t\t\tlen += 2 /* \"--\" */ + sizeof(OSS_BOUNDARY)-1 + CRLF_LEN +\n\t\t\t 14/* \"Content-Type: \" */ + part->mime_s.len +\n\t\t\t CRLF_LEN + part->headers.len + CRLF_LEN ;\n\n\t\t\t/* part with dump function ? */\n\t\t\tif (part->dump_f) {\n\t\t\t\tif (part->dump_f( part->parsed ,msg, &part->dump)<0) {\n\t\t\t\t\tLM_ERR(\"failed to build part, inserting empty\\n\");\n\t\t\t\t\tpart->dump.s = \"\";\n\t\t\t\t\tpart->dump.len = 0;\n\t\t\t\t} else\n\t\t\t\t\tlen += part->dump.len;\n\t\t\t\tlen += CRLF_LEN;\n\t\t\t} else\n\t\t\t/* new part with body attached */\n\t\t\tif ( part->flags & SIP_BODY_PART_FLAG_NEW ) {\n\t\t\t\t/* simpy copy the body of the part */\n\t\t\t\tlen += part->body.len;\n\t\t\t\tlen += CRLF_LEN;\n\t\t\t} else\n\t\t\t/* old part with lumps */\n\t\t\t{\n\t\t\t\t/* first find the first lump inside our body part */\n\t\t\t\twhile ( lump && lump->u.offset<(part->body.s-msg->buf) )\n\t\t\t\t\tlump=lump->next;\n\t\t\t\tif (lump) {\n\t\t\t\t\tLM_DBG(\"lumps found in the part, applying...\\n\");\n\t\t\t\t\t/* apply the lumps */\n\t\t\t\t\tlen += lumps_len( msg, lump, send_sock,\n\t\t\t\t\t\tpart->body.s+part->body.len-msg->buf);\n\t\t\t\t}\n\t\t\t\t/* and copy whatever is left, all the way to the end of part */\n\t\t\t\tsize = (part->body.s+part->body.len-msg->buf)-orig_offs;\n\t\t\t\tlen += size + CRLF_LEN;\n\t\t\t}\n\n\t\t\t/* reposition at the end of the processed body */\n\t\t\tif ((part->flags & SIP_BODY_PART_FLAG_NEW) == 0)\n\t\t\t\torig_offs = part->body.s+part->body.len-msg->buf+CRLF_LEN;\n\n\t\t} /* end for(over the parts) */\n\n\t\t/* the final separator */\n\t\tlen += 2 /* \"--\" */ + sizeof(OSS_BOUNDARY)-1 + 2 /* \"--\" */ + CRLF_LEN;\n\n\t\t/* replace the Content-Type hdr */\n\t\tif (msg->content_type)\n\t\t\tct = del_lump(msg, msg->content_type->name.s-msg->buf,\n\t\t\t\tmsg->content_type->len, HDR_CONTENTTYPE_T);\n\t\telse\n\t\t\tct = anchor_lump(msg, msg->unparsed - msg->buf,\n\t\t\t\tHDR_CONTENTTYPE_T);\n\t\tif (ct==NULL) {\n\t\t\tLM_ERR(\"failed to remove old CT / create anchor\\n\");\n\t\t} else {\n\t\t\t/* \"Content-Type: multipart/mixed;boundary=OSS_BOUNDARY CRLF\" */\n\t\t\thdr = (char*)pkg_malloc( 39 + sizeof(OSS_BOUNDARY)-1 + CRLF_LEN );\n\t\t\tif (hdr==NULL) {\n\t\t\t\tLM_ERR(\"failed to allocate new ct hdr\\n\");\n\t\t\t} else {\n\t\t\t\tmemcpy( hdr,\n\t\t\t\t\"Content-Type: multipart/mixed;boundary=\" OSS_BOUNDARY CRLF,\n\t\t\t\t39 + sizeof(OSS_BOUNDARY)-1 + CRLF_LEN);\n\t\t\t\tif (insert_new_lump_before(ct, hdr,\n\t\t\t\t39 + sizeof(OSS_BOUNDARY)-1 + CRLF_LEN,\n\t\t\t\tHDR_CONTENTTYPE_T) == NULL) {\n\t\t\t\t\tLM_ERR(\"failed to create insert lump\\n\");\n\t\t\t\t\tpkg_free(hdr);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t} else {\n\n\t\t/* multi to multi parts - iterate the list, handle insert new parts,\n\t\t * remove old ones, and modify the kept ones (if the case) */\n\n\t\tLM_DBG(\"multi to multi part body reconstruction\\n\");\n\t\tlump = msg->body_lumps;\n\n\t\tfor( part=&msg->body->first ; part ; part=part->next) {\n\t\t\t/* skip deleted parts */\n\t\t\tif ( (part->flags & SIP_BODY_PART_FLAG_DELETED) ) {\n\t\t\t\tif ( (part->flags & SIP_BODY_PART_FLAG_NEW) == 0 )\n\t\t\t\t\t/* reposition at the end of the skipped body */\n\t\t\t\t\torig_offs = part->body.s+part->body.len-msg->buf+CRLF_LEN;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tLM_DBG(\"handing part with flags %x, mime %.*s, dump function %p\\n\",\n\t\t\t\tpart->flags, part->mime_s.len, part->mime_s.s, part->dump_f);\n\n\t\t\t/* new part ? */\n\t\t\tif ( part->flags & SIP_BODY_PART_FLAG_NEW ) {\n\t\t\t\t/* separator and CT header */\n\t\t\t\tlen += 2 /* \"--\" */ + msg->body->boundary.len +\n\t\t\t\t\tCRLF_LEN + 14 /* \"Content-Type: \" */ + part->mime_s.len +\n\t\t\t\t\tCRLF_LEN + part->headers.len + CRLF_LEN ;\n\t\t\t\t/* simpy copy the body of the part */\n\t\t\t\tif (part->dump_f) {\n\t\t\t\t\tif (part->dump_f( part->parsed ,msg, &part->dump)<0) {\n\t\t\t\t\t\tLM_ERR(\"failed to build part, inserting empty\\n\");\n\t\t\t\t\t\tpart->dump.s = \"\";\n\t\t\t\t\t\tpart->dump.len = 0;\n\t\t\t\t\t} else\n\t\t\t\t\t\tlen += part->dump.len;\n\t\t\t\t} else\n\t\t\t\t\tlen += part->body.len;\n\t\t\t\tlen += CRLF_LEN;\n\t\t\t} else\n\t\t\t/* old part with dump function */\n\t\t\tif (part->dump_f) {\n\t\t\t\t/* copy separator and headers from original message */\n\t\t\t\tlen += (part->body.s - msg->buf) - orig_offs;\n\t\t\t\t/* put in the new body */\n\t\t\t\tif (part->dump_f( part->parsed ,msg, &part->dump)<0) {\n\t\t\t\t\tLM_ERR(\"failed to build part, inserting empty\\n\");\n\t\t\t\t\tpart->dump.s = \"\";\n\t\t\t\t\tpart->dump.len = 0;\n\t\t\t\t} else\n\t\t\t\t\tlen += part->dump.len;\n\t\t\t\tlen += CRLF_LEN;\n\t\t\t\t/* skip the old body */\n\t\t\t} else\n\t\t\t/* old part with lumps -> apply changes */\n\t\t\t{\n\t\t\t\t/* first find the first lump inside our body part\n\t\t\t\t * NOTE: we do not need to explicitly copy the separtor and\n\t\t\t\t * the headers as they will be automatically got by the \n\t\t\t\t * first lup or by the final copy */\n\t\t\t\twhile ( lump && lump->u.offset<(part->body.s-msg->buf) )\n\t\t\t\t\tlump=lump->next;\n\t\t\t\tif (lump) {\n\t\t\t\t\tLM_DBG(\"lumps found in the part, applying...\\n\");\n\t\t\t\t\t/* apply the lumps */\n\t\t\t\t\tlen += lumps_len( msg, lump, send_sock,\n\t\t\t\t\t\t\tpart->body.s+part->body.len-msg->buf);\n\t\t\t\t}\n\t\t\t\t/* and copy whatever is left, all the way to the end of part */\n\t\t\t\tsize = (part->body.s+part->body.len-msg->buf+CRLF_LEN)-orig_offs;\n\t\t\t\tlen += size;\n\t\t\t}\n\n\t\t\t/* reposition at the end of the processed body */\n\t\t\tif ((part->flags & SIP_BODY_PART_FLAG_NEW) == 0)\n\t\t\t\torig_offs = part->body.s+part->body.len-msg->buf+CRLF_LEN;\n\t\t} /* end for(over the parts) */\n\n\t\t/* the final separator */\n\t\tsize = msg->len - orig_offs;\n\t\tlen += size;\n\n\t\t/* Content-Type hdr does not require changes in this case */\n\t}\n\n\tLM_DBG(\"resulting body len is %d\\n\",len);\n\treturn len;\n}\n\n\nvoid reassemble_body_parts( struct sip_msg* msg, char* new_buf,\n\t\t\t\t\t\tunsigned int* new_offs, unsigned int* orig_offs,\n\t\t\t\t\t\tstruct socket_info* send_sock)\n{\n\tstruct body_part *part;\n\tstruct lump* lump;\n\tunsigned int size;\n\tunsigned int offset;\n\tint padding=0;\n\n\tif (msg->body->updated_part_count==0) {\n\n\t\t/* no body to be placed in the new msg !\n\t\t * simply skip the entire body */\n\t\tLM_DBG(\"no part to be added\\n\");\n\n\t} else if (msg->body->updated_part_count==1) {\n\n\t\t/* there is only one part to be added, so iterate\n\t\t * and find it */\n\t\tLM_DBG(\"only one part to be added\\n\");\n\n\t\tfor( part=&msg->body->first ; part ; part=part->next)\n\t\t\tif ( (part->flags & SIP_BODY_PART_FLAG_DELETED)==0 ) break;\n\n\t\tif (part==NULL) {\n\t\t\tLM_BUG(\"updated count is 1, but no non-deleted part found :-/\\n\");\n\t\t\treturn;\n\t\t}\n\n\t\tLM_DBG(\"handing part with flags %x, mime %.*s, dump function %p\\n\",\n\t\t\tpart->flags, part->mime_s.len, part->mime_s.s, part->dump_f);\n\n\t\t/* handle the special case of preserving a single part which was\n\t\t * received packed as multipart -> copy the boundries as\n\t\t * received */\n\t\tif ( msg->body->flags & SIP_BODY_RCV_MULTIPART &&\n\t\tmsg->body->part_count==1 &&\n\t\t(part->flags & SIP_BODY_PART_FLAG_NEW)==0 ) {\n\t\t\t/* copy whatever is between the beginning of the msg body \n\t\t\t * and the part body*/\n\t\t\tmemcpy(new_buf+*new_offs, msg->body->body.s,\n\t\t\t\tpart->body.s-msg->body->body.s );\n\t\t\t*new_offs += part->body.s-msg->body->body.s;\n\t\t\tpadding = 1;\n\t\t}\n\n\t\tif (part->dump_f) {\n\t\t\t/* the dump function was triggered when the length was computed\n\t\t\t * and the resulting buffer was linked as 'dump' (and we need\n\t\t\t * to free it now) */\n\t\t\t/* copy the new body of the part */\n\t\t\tmemcpy(new_buf+*new_offs, part->dump.s, part->dump.len );\n\t\t\t*new_offs += part->dump.len;\n\t\t\tpkg_free(part->dump.s);\n\t\t\tpart->dump.s = NULL;\n\t\t\tpart->dump.len = 0;\n\t\t} else {\n\t\t\tif ( part->flags & SIP_BODY_PART_FLAG_NEW ) {\n\t\t\t\t/* simply copy the body of the part */\n\t\t\t\tmemcpy(new_buf+*new_offs, part->body.s, part->body.len );\n\t\t\t\t*new_offs += part->body.len;\n\t\t\t} else {\n\t\t\t\t/* this is one part that was received (so potentially\n\t\t\t\t * modified during runtime) -> apply all body lumps\n\t\t\t\t * inside this part */\n\t\t\t\t*orig_offs = part->body.s - msg->buf;\n\t\t\t\tlump = msg->body_lumps;\n\t\t\t\twhile ( lump && lump->u.offset<(part->body.s-msg->buf) )\n\t\t\t\t\tlump=lump->next;\n\t\t\t\tif (lump) {\n\t\t\t\t\tLM_DBG(\"lumps found in the part, applying...\\n\");\n\t\t\t\t\t/* apply the lumps */\n\t\t\t\t\tprocess_lumps( msg, lump, new_buf, new_offs, orig_offs,\n\t\t\t\t\t\tsend_sock, part->body.s+part->body.len-msg->buf);\n\t\t\t\t}\n\t\t\t\t/* and copy whatever is left, all the way to the end of part */\n\t\t\t\tsize = (part->body.s+part->body.len-msg->buf)-*orig_offs;\n\t\t\t\tmemcpy(new_buf+*new_offs, msg->buf+*orig_offs, size);\n\t\t\t\t*new_offs += size;\n\t\t\t}\n\t\t}\n\n\t\tif (padding) {\n\t\t\t/* copy whatever is between the end of the part body \n\t\t\t * and the end of the msg body*/\n\t\t\tmemcpy(new_buf+*new_offs, part->body.s+part->body.len,\n\t\t\t\t(msg->body->body.s+msg->body->body.len)-\n\t\t\t\t(part->body.s+part->body.len) );\n\t\t\t*new_offs += (msg->body->body.s+msg->body->body.len)-\n\t\t\t\t(part->body.s+part->body.len);\n\t\t}\n\n\t} else if (msg->body->part_count<2) {\n\n\t\t/* transition from 0/1 to multiple parts,\n\t\t * so we need to add boundries */\n\n\t\tLM_DBG(\"transition from 0/1 parts to multi part body\\n\");\n\t\toffset = *new_offs;\n\t\tlump = msg->body_lumps;\n\n\t\tfor( part=&msg->body->first ; part ; part=part->next) {\n\n\t\t\tLM_DBG(\"handing part with flags %x, mime %.*s, dump function %p\\n\",\n\t\t\t\tpart->flags, part->mime_s.len, part->mime_s.s, part->dump_f);\n\n\t\t\t/* skip deleted parts */\n\t\t\tif ( (part->flags & SIP_BODY_PART_FLAG_DELETED) ) {\n\t\t\t\tif ((part->flags & SIP_BODY_PART_FLAG_NEW) == 0)\n\t\t\t\t\t/* reposition at the end of the skipped body */\n\t\t\t\t\t*orig_offs = part->body.s+part->body.len-msg->buf+CRLF_LEN;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* separator and CT header */\n\t\t\tmemcpy(new_buf+offset, \"--\" OSS_BOUNDARY CRLF \"Content-Type: \",\n\t\t\t\t2 + sizeof(OSS_BOUNDARY)-1 + CRLF_LEN + 14);\n\t\t\toffset += 2 + sizeof(OSS_BOUNDARY)-1 + CRLF_LEN + 14;\n\t\t\tmemcpy(new_buf+offset, part->mime_s.s , part->mime_s.len);\n\t\t\toffset += part->mime_s.len;\n\t\t\tif (part->headers.len==0) {\n\t\t\t\tmemcpy(new_buf+offset, CRLF CRLF , CRLF_LEN+CRLF_LEN);\n\t\t\t\toffset += CRLF_LEN + CRLF_LEN ;\n\t\t\t} else {\n\t\t\t\tmemcpy(new_buf+offset, CRLF , CRLF_LEN);\n\t\t\t\toffset += CRLF_LEN;\n\t\t\t\tmemcpy(new_buf+offset, part->headers.s , part->headers.len);\n\t\t\t\toffset += part->headers.len ;\n\t\t\t\tmemcpy(new_buf+offset, CRLF , CRLF_LEN);\n\t\t\t\toffset += CRLF_LEN;\n\t\t\t}\n\n\t\t\t/* part with dump function ? */\n\t\t\tif (part->dump_f) {\n\t\t\t\tmemcpy(new_buf+offset, part->dump.s, part->dump.len );\n\t\t\t\toffset += part->dump.len;\n\t\t\t\tpkg_free(part->dump.s);\n\t\t\t\tpart->dump.s = NULL;\n\t\t\t\tpart->dump.len = 0;\n\t\t\t\tmemcpy(new_buf+offset, CRLF , CRLF_LEN);\n\t\t\t\toffset += CRLF_LEN;\n\t\t\t} else\n\t\t\t/* new part with body attached */\n\t\t\tif ( part->flags & SIP_BODY_PART_FLAG_NEW ) {\n\t\t\t\t/* simpy copy the body of the part */\n\t\t\t\tmemcpy(new_buf+offset, part->body.s, part->body.len );\n\t\t\t\toffset += part->body.len;\n\t\t\t\tmemcpy(new_buf+offset, CRLF , CRLF_LEN);\n\t\t\t\toffset += CRLF_LEN;\n\t\t\t} else\n\t\t\t/* old part with lumps */\n\t\t\t{\n\t\t\t\t/* first find the first lump inside our body part */\n\t\t\t\twhile ( lump && lump->u.offset<(part->body.s-msg->buf) )\n\t\t\t\t\tlump=lump->next;\n\t\t\t\tif (lump) {\n\t\t\t\t\tLM_DBG(\"lumps found in the part, applying...\\n\");\n\t\t\t\t\t/* apply the lumps */\n\t\t\t\t\tprocess_lumps( msg, lump, new_buf, &offset, orig_offs,\n\t\t\t\t\t\tsend_sock, part->body.s+part->body.len-msg->buf);\n\t\t\t\t}\n\t\t\t\t/* and copy whatever is left, all the way to the end of part */\n\t\t\t\tsize = (part->body.s+part->body.len-msg->buf)-*orig_offs;\n\t\t\t\tmemcpy(new_buf+offset, msg->buf+*orig_offs, size);\n\t\t\t\toffset += size;\n\t\t\t\tmemcpy(new_buf+offset, CRLF , CRLF_LEN);\n\t\t\t\toffset += CRLF_LEN;\n\t\t\t}\n\n\t\t\t/* reposition at the end of the processed body */\n\t\t\tif ((part->flags & SIP_BODY_PART_FLAG_NEW) == 0)\n\t\t\t\t*orig_offs = part->body.s+part->body.len-msg->buf+CRLF_LEN ;\n\n\t\t} /* end for(over the parts) */\n\n\t\t/* the final separator */\n\t\tmemcpy(new_buf+offset, \"--\" OSS_BOUNDARY \"--\" CRLF,\n\t\t\t2 + sizeof(OSS_BOUNDARY)-1 + 2 + CRLF_LEN);\n\t\toffset += 2 + sizeof(OSS_BOUNDARY)-1 + 2 + CRLF_LEN;\n\n\t\t/*done here !!*/\n\t\t*new_offs = offset;\n\n\t} else {\n\n\t\t/* multi to multi parts - iterate the list, handle insert new parts,\n\t\t * remove old ones, and modify the kept ones (if the case) */\n\t\tLM_DBG(\"multi to multi part body reconstruction\\n\");\n\n\t\toffset = *new_offs;\n\t\tlump = msg->body_lumps;\n\t\tfor( part=&msg->body->first ; part ; part=part->next) {\n\t\t\t/* skip deleted parts */\n\t\t\tif ( (part->flags & SIP_BODY_PART_FLAG_DELETED) ) {\n\t\t\t\tif ( (part->flags & SIP_BODY_PART_FLAG_NEW) == 0 )\n\t\t\t\t\t/* reposition at the end of the skipped body */\n\t\t\t\t\t*orig_offs = part->body.s+part->body.len-msg->buf+CRLF_LEN;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tLM_DBG(\"handing part with flags %x, mime %.*s, dump function %p\\n\",\n\t\t\t\tpart->flags, part->mime_s.len, part->mime_s.s, part->dump_f);\n\n\t\t\t/* new part ? */\n\t\t\tif ( part->flags & SIP_BODY_PART_FLAG_NEW ) {\n\t\t\t\t/* separator and CT header */\n\t\t\t\tmemcpy(new_buf+offset, \"--\" , 2);\n\t\t\t\toffset += 2;\n\t\t\t\tmemcpy(new_buf+offset, msg->body->boundary.s , msg->body->boundary.len);\n\t\t\t\toffset += msg->body->boundary.len;\n\t\t\t\tmemcpy(new_buf+offset, CRLF \"Content-Type: \" , CRLF_LEN+14);\n\t\t\t\toffset += CRLF_LEN + 14 ;\n\t\t\t\tmemcpy(new_buf+offset, part->mime_s.s , part->mime_s.len);\n\t\t\t\toffset += part->mime_s.len;\n\t\t\t\tif (part->headers.len==0) {\n\t\t\t\t\tmemcpy(new_buf+offset, CRLF CRLF , CRLF_LEN+CRLF_LEN);\n\t\t\t\t\toffset += CRLF_LEN + CRLF_LEN ;\n\t\t\t\t} else {\n\t\t\t\t\tmemcpy(new_buf+offset, CRLF , CRLF_LEN);\n\t\t\t\t\toffset += CRLF_LEN;\n\t\t\t\t\tmemcpy(new_buf+offset, part->headers.s , part->headers.len);\n\t\t\t\t\toffset += part->headers.len ;\n\t\t\t\t\tmemcpy(new_buf+offset, CRLF , CRLF_LEN);\n\t\t\t\t\toffset += CRLF_LEN;\n\t\t\t\t}\n\t\t\t\t/* simply copy the body of the part */\n\t\t\t\tif (part->dump_f) {\n\t\t\t\t\tmemcpy(new_buf+offset, part->dump.s, part->dump.len );\n\t\t\t\t\toffset += part->dump.len;\n\t\t\t\t\tpart->dump.s = NULL;\n\t\t\t\t\tpart->dump.len = 0;\n\t\t\t\t} else {\n\t\t\t\t\tmemcpy(new_buf+offset, part->body.s, part->body.len );\n\t\t\t\t\toffset += part->body.len;\n\t\t\t\t}\n\t\t\t\tmemcpy(new_buf+offset, CRLF , CRLF_LEN);\n\t\t\t\toffset += CRLF_LEN;\n\t\t\t} else\n\t\t\t/* old part with dump function */\n\t\t\tif (part->dump_f) {\n\t\t\t\t/* copy separator and headers from original message */\n\t\t\t\tsize = (part->body.s - msg->buf) - *orig_offs;\n\t\t\t\tmemcpy( new_buf+offset,  msg->buf+*orig_offs, size);\n\t\t\t\toffset += size;\n\t\t\t\t/* put in the new body */\n\t\t\t\tmemcpy(new_buf+offset, part->dump.s, part->dump.len );\n\t\t\t\toffset += part->dump.len;\n\t\t\t\tpkg_free(part->dump.s);\n\t\t\t\tpart->dump.s = NULL;\n\t\t\t\tpart->dump.len = 0;\n\t\t\t\tmemcpy(new_buf+offset, CRLF , CRLF_LEN);\n\t\t\t\toffset += CRLF_LEN;\n\t\t\t} else\n\t\t\t/* old part with lumps -> apply changes */\n\t\t\t{\n\t\t\t\t/* first find the first lump inside our body part\n\t\t\t\t * NOTE: we do not need to explicitly copy the separtor and\n\t\t\t\t * the headers as they will be automatically got by the \n\t\t\t\t * first lup or by the final copy */\n\t\t\t\twhile ( lump && lump->u.offset<(part->body.s-msg->buf) )\n\t\t\t\t\tlump=lump->next;\n\t\t\t\tif (lump) {\n\t\t\t\t\tLM_DBG(\"lumps found in the part, applying...\\n\");\n\t\t\t\t\t/* apply the lumps */\n\t\t\t\t\tprocess_lumps( msg, lump, new_buf, &offset, orig_offs,\n\t\t\t\t\t\tsend_sock, part->body.s+part->body.len-msg->buf);\n\t\t\t\t}\n\t\t\t\t/* and copy whatever is left, all the way to the end of part,\n\t\t\t\t * including the next CRLF */\n\t\t\t\tsize = (part->body.s+part->body.len-msg->buf+CRLF_LEN)-*orig_offs;\n\t\t\t\tmemcpy(new_buf+offset, msg->buf+*orig_offs, size);\n\t\t\t\toffset += size;\n\t\t\t}\n\n\t\t\t/* reposition at the end of the processed body */\n\t\t\tif ((part->flags & SIP_BODY_PART_FLAG_NEW) == 0)\n\t\t\t\t*orig_offs = part->body.s+part->body.len-msg->buf+CRLF_LEN;\n\n\t\t} /* end for(over the parts) */\n\n\t\t/* the final separator */\n\t\tsize = msg->len - *orig_offs;\n\t\tmemcpy(new_buf+offset, msg->buf+*orig_offs , size);\n\t\t*new_offs = offset + size;\n\t\t*orig_offs += size;\n\n\t}\n\treturn;\n}\n\n\n/* Calculated the body difference in lenght after applying\n *   all the changes (over the sip body) !\n * This is a wrapper to hide the differences between \n *   lump-based changes and body_part-based changes.\n */\nstatic inline int calculate_body_diff(struct sip_msg *msg,\n\t\t\t\t\t\t\t\t\t\t\t\t\tstruct socket_info *sock )\n{\n\tif (msg->body==NULL) {\n\t\t/* no body parsed, no advanced ops done, just dummy lumps over body */\n\t\treturn lumps_len(msg, msg->body_lumps, sock, -1);\n\t} else {\n\t\treturn ((int)prep_reassemble_body_parts( msg, sock) - msg->body->body.len);\n\t}\n}\n\n\n/* Writes down the new SIP message buffer (SIP headers and body) after\n *   after applying all the changes (over SIP hdrs and SIP body) !\n * This is a wrapper to hide the differences between \n *   lump-based changes and body_part-based changes.\n */\nstatic inline void apply_msg_changes(struct sip_msg *msg,\n\t\t\t\t\t\t\tchar *new_buf, unsigned int *new_offs,\n\t\t\t\t\t\t\tunsigned int *orig_offs, struct socket_info *sock,\n\t\t\t\t\t\t\tunsigned int max_offset)\n{\n\tunsigned int size;\n\n\t/* apply changes over the SIP headers */\n\tprocess_lumps(msg, msg->add_rm, new_buf, new_offs, orig_offs, sock, -1);\n\tif (msg->body==NULL) {\n\t\t/* no body parsed, no advanced ops done, just dummy lumps over body */\n\t\tprocess_lumps(msg, msg->body_lumps, new_buf, new_offs,\n\t\t\torig_offs, sock, max_offset);\n\t\t/* copy the rest of the message */\n\t\tmemcpy(new_buf+*new_offs, msg->buf+*orig_offs, max_offset-*orig_offs);\n\t\t*new_offs += max_offset-*orig_offs;\n\t} else {\n\t\t/* copy whatever is left in the original buffer (up to the body) */\n\t\tsize = (msg->body->part_count) ?\n\t\t\t  ((msg->body->body.s - msg->buf) - *orig_offs) /* msg had body */\n\t\t\t: (msg->len - *orig_offs);                      /* no body */\n\t\tmemcpy(new_buf+*new_offs, msg->buf+*orig_offs, size );\n\t\t*new_offs += size;\n\t\t*orig_offs += size;\n\t\t/* rebuild the body, part by part, in a content wise manner */\n\t\treassemble_body_parts(msg, new_buf, new_offs, orig_offs, sock);\n\t}\n}\n\n\n/*! \\brief\n * Adjust/insert Content-Length if necessary\n */\nstatic inline int adjust_clen(struct sip_msg* msg, int body_delta, int proto)\n{\n\tstruct lump* anchor;\n\tchar* clen_buf;\n\tint clen_len;\n\n\t/* Calculate message length difference caused by lumps modifying message\n\t * body, from this point on the message body must not be modified. Zero\n\t * value indicates that the body hasn't been modified\n\t*/\n\n\tclen_buf = 0;\n\tanchor=0;\n\n\t/* check to see if we need to add clen */\n\tif (is_tcp_based_proto(proto)) {\n\t\tif (parse_headers(msg, HDR_CONTENTLENGTH_F, 0)==-1){\n\t\t\tLM_ERR(\"parsing content-length\\n\");\n\t\t\tgoto error;\n\t\t}\n\t\tif (msg->content_length==0){\n\t\t\t/* not present, we need to add it */\n\t\t\t/* msg->unparsed should point just before the final crlf\n\t\t\t * - whole message was parsed by the above parse_headers\n\t\t\t *   which did not find content-length */\n\t\t\tanchor=anchor_lump(msg, msg->unparsed-msg->buf,\n\t\t\t\t\t\t\t\t\t\t\t\tHDR_CONTENTLENGTH_T);\n\t\t\tif (anchor==0){\n\t\t\t\tLM_ERR(\"cannot set clen anchor\\n\");\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t}\n\n\tif ((anchor==0) && body_delta){\n\t\tif (parse_headers(msg, HDR_CONTENTLENGTH_F, 0) == -1) {\n\t\t\tLM_ERR(\"parsing Content-Length\\n\");\n\t\t\tgoto error;\n\t\t}\n\n\t\t/* The body has been changed, try to find\n\t\t * existing Content-Length\n\t\t */\n\t\t/* no need for Content-Length if it's and UDP packet and\n\t\t * it hasn't Content-Length already */\n\t\tif (msg->content_length==0){\n\t\t    /* content-length doesn't exist, append it */\n\t\t\t/* msg->unparsed should point just before the final crlf\n\t\t\t * - whole message was parsed by the above parse_headers\n\t\t\t *   which did not find content-length */\n\t\t\tif (proto!=PROTO_UDP){\n\t\t\t\tanchor=anchor_lump(msg, msg->unparsed-msg->buf,\n\t\t\t\t\t\t\t\t\t\t\t\t\tHDR_CONTENTLENGTH_T);\n\t\t\t\tif (anchor==0){\n\t\t\t\t\tLM_ERR(\"cannot set clen anchor\\n\");\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tLM_DBG(\"the UDP packet has no clen => not adding one \\n\");\n\t\t\t}\n\t\t}else{\n\t\t\t/* Content-Length has been found, remove it */\n\t\t\tanchor = del_lump(\tmsg, msg->content_length->name.s - msg->buf,\n\t\t\t\t\t\t\t\tmsg->content_length->len, HDR_CONTENTLENGTH_T);\n\t\t\tif (anchor==0) {\n\t\t\t\tLM_ERR(\"can't remove original Content-Length\\n\");\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (anchor){\n\t\tclen_buf = clen_builder(msg, &clen_len, body_delta);\n\t\tif (!clen_buf) goto error;\n\t\tif (insert_new_lump_after(anchor, clen_buf, clen_len,\n\t\t\t\t\tHDR_CONTENTLENGTH_T) == 0)\n\t\t\tgoto error;\n\t}\n\n\treturn 0;\nerror:\n\tif (clen_buf) pkg_free(clen_buf);\n\treturn -1;\n}\n\n\n/*! \\brief\n * Save given Path body as Route header in message.\n *\n * If another Route HF is found, it's placed right before that.\n * Otherwise, it's placed after the last Via HF. If also no\n * Via HF is found, it's placed as first HF.\n */\n#define ROUTE_STR  \"Route: \"\n#define ROUTE_LEN  (sizeof(ROUTE_STR)-1)\nstatic inline int insert_path_as_route(struct sip_msg* msg, str* path)\n{\n\tstruct lump *anchor;\n\tchar *route;\n\tstruct hdr_field *hf, *last_via=0;\n\n\tfor (hf = msg->headers; hf; hf = hf->next) {\n\t\tif (hf->type == HDR_ROUTE_T) {\n\t\t\tbreak;\n\t\t} else if (hf->type == HDR_VIA_T) {\n\t\t\tlast_via = hf;\n\t\t}\n\t}\n\tif (hf) {\n\t\t/* Route HF found, insert before it */\n\t\tanchor = anchor_lump(msg, hf->name.s - msg->buf, 0);\n\t} else if(last_via) {\n\t\tif (last_via->next) {\n\t\t\t/* Via HF in between, insert after it */\n\t\t\tanchor = anchor_lump(msg, last_via->next->name.s - msg->buf, 0);\n\t\t} else {\n\t\t\t/* Via HF is last, so append */\n\t\t\tanchor = anchor_lump(msg, msg->unparsed - msg->buf, 0);\n\t\t}\n\t} else {\n\t\t/* None of the above, insert as first */\n\t\tanchor = anchor_lump(msg, msg->headers->name.s - msg->buf, 0);\n\t}\n\n\tif (anchor == 0) {\n\t\tLM_ERR(\"failed to get anchor\\n\");\n\t\treturn -1;\n\t}\n\n\troute = pkg_malloc(ROUTE_LEN + path->len + CRLF_LEN);\n\tif (!route) {\n\t\tLM_ERR(\"out of pkg memory\\n\");\n\t\treturn -1;\n\t}\n\tmemcpy(route, ROUTE_STR, ROUTE_LEN);\n\tmemcpy(route + ROUTE_LEN, path->s, path->len);\n\tmemcpy(route + ROUTE_LEN + path->len, CRLF, CRLF_LEN);\n\n\tif (insert_new_lump_before(anchor, route, ROUTE_LEN + path->len + CRLF_LEN, 0) == 0) {\n\t\tLM_ERR(\"failed to insert lump\\n\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nint is_del_via1_lump(struct sip_msg* msg)\n{\n\tstruct lump* lump;\n\tint via1_off, via1_len;\n\n/*\tfor(lump= msg->add_rm; lump; lump= lump->next)\n\t\tif(lump->type == HDR_VIA1_T && lump->op== LUMP_DEL)\n\t\t\treturn 1;\n*/\n\tif(!msg->h_via1)\n\t\treturn 0;\n\n\tvia1_off = msg->h_via1->name.s - msg->buf;\n\tvia1_len = msg->h_via1->len;\n\n\tfor(lump= msg->add_rm; lump; lump= lump->next)\n\t{\n\t\tif(lump->type == 0 && lump->op== LUMP_DEL && lump->u.offset == via1_off && lump->len == via1_len)\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nchar * build_req_buf_from_sip_req( struct sip_msg* msg,\n\t\t\t\t\t\t\t\tunsigned int *returned_len,\n\t\t\t\t\t\t\t\tstruct socket_info* send_sock, int proto,\n\t\t\t\t\t\t\t\tstr *via_params, unsigned int flags)\n{\n\tunsigned int len, new_len, received_len, rport_len, uri_len, via_len, body_delta;\n\tchar *line_buf, *received_buf, *rport_buf, *new_buf, *buf, *id_buf;\n\tunsigned int offset, s_offset, size, id_len;\n\tstruct lump *anchor, *via_insert_param;\n\tstr branch, extra_params, body;\n\tstruct hostport hp;\n\n\tid_buf=0;\n\tid_len=0;\n\tvia_insert_param=0;\n\textra_params.len=0;\n\textra_params.s=0;\n\turi_len=0;\n\tbuf=msg->buf;\n\tlen=msg->len;\n\treceived_len=0;\n\trport_len=0;\n\tnew_buf=0;\n\treceived_buf=0;\n\trport_buf=0;\n\tline_buf=0;\n\tint via1_deleted = 0;\n\n\tif (msg->path_vec.len) {\n\t\tif (insert_path_as_route(msg, &msg->path_vec) < 0) {\n\t\t\tLM_ERR(\"adding path lumps failed\\n\");\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\t/* Calculate message body difference and adjust\n\t * Content-Length\n\t */\n\tbody_delta = calculate_body_diff( msg, send_sock);\n\tif (adjust_clen(msg, body_delta, proto) < 0) {\n\t\tLM_ERR(\"failed to adjust Content-Length\\n\");\n\t\tgoto error;\n\t}\n\n\tif (flags&MSG_TRANS_NOVIA_FLAG)\n\t\tgoto build_msg;\n\n\t/* add id if tcp-based protocol  */\n\tif (is_tcp_based_proto(msg->rcv.proto)) {\n\t\tif  ((id_buf=id_builder(msg, &id_len))==0){\n\t\t\tLM_ERR(\"id_builder failed\\n\");\n\t\t\tgoto error; /* we don't need to free anything,\n\t\t\t                 nothing alloc'ed yet*/\n\t\t}\n\t\tLM_DBG(\"id added: <%.*s>, rcv proto=%d\\n\",\n\t\t\t\t(int)id_len, id_buf, msg->rcv.proto);\n\t\t/* if there was already something there, simply copy them */\n\t\tif (via_params && via_params->len != 0) {\n\t\t\textra_params.len = id_len + via_params->len;\n\t\t\textra_params.s=pkg_malloc(extra_params.len);\n\t\t\tif(extra_params.s==0) {\n\t\t\t\tLM_ERR(\"extra params building failed\\n\");\n\t\t\t\tpkg_free(id_buf);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tmemcpy(extra_params.s, via_params->s, via_params->len);\n\t\t\tmemcpy(extra_params.s + via_params->len, id_buf, id_len);\n\t\t} else {\n\t\t\textra_params.s=id_buf;\n\t\t\textra_params.len=id_len;\n\t\t}\n\t}\n\n\t/* check whether to add rport parameter to local via */\n\tif(msg->msg_flags&FL_FORCE_LOCAL_RPORT) {\n\t\tid_buf=extra_params.s;\n\t\tid_len=extra_params.len;\n\t\tif (via_params && !extra_params.len) {\n\t\t\t/* if no other parameters were added yet, consider via_params */\n\t\t\textra_params.len = via_params->len;\n\t\t\t/* otherwise, the via_params were already copied in the id block */\n\t\t}\n\t\textra_params.len += RPORT_LEN-1; /* last char in RPORT define is '='\n\t\t\t\t\t\t\t\t\t\twhich is not added, but the new buffer\n\t\t\t\t\t\t\t\t\t\twill be null terminated */\n\t\textra_params.s = (char*)pkg_malloc(extra_params.len+1);\n\t\tif(extra_params.s==0) {\n\t\t\tLM_ERR(\"extra params building failed\\n\");\n\t\t\tif (id_buf) pkg_free(id_buf);\n\t\t\tgoto error;\n\t\t}\n\n\t\tif(id_buf!=0) {\n\t\t\tmemcpy(extra_params.s, id_buf, id_len);\n\t\t\tpkg_free(id_buf);\n\t\t} else if (via_params)\n\t\t\tmemcpy(extra_params.s, via_params->s, via_params->len);\n\t\tmemcpy(extra_params.s+id_len, RPORT, RPORT_LEN-1);\n\t\textra_params.s[extra_params.len]='\\0';\n\t\tLM_DBG(\"extra param added: <%.*s>\\n\",extra_params.len, extra_params.s);\n\t}\n\n\tbranch.s=msg->add_to_branch_s;\n\tbranch.len=msg->add_to_branch_len;\n\tset_hostport(&hp, msg);\n\tline_buf = via_builder( &via_len, send_sock, &branch,\n\t\t\t\t\t\textra_params.len?&extra_params:via_params, proto, &hp);\n\tif (!line_buf){\n\t\tLM_ERR(\"no via received!\\n\");\n\t\tgoto error00;\n\t}\n\n\tvia1_deleted = is_del_via1_lump(msg);\n\t/* check if received needs to be added:\n\t *  - if the VIA address and the received address are different\n\t *  - if the rport was forced (rport requires received)\n\t *  - if the rport was received in the VIA hdr\n\t *  - and there is no lump that delets VIA1 hdr */\n\tif ( (msg->via1->rport || (msg->msg_flags&FL_FORCE_RPORT) ||\n\t\t\treceived_test(msg) ) && !via1_deleted) {\n\t\tif ((received_buf=received_builder(msg,&received_len))==0){\n\t\t\tLM_ERR(\"received_builder failed\\n\");\n\t\t\tgoto error01;  /* free also line_buf */\n\t\t}\n\t}\n\n\t/* check if rport needs to be updated:\n\t *  - if FL_FORCE_RPORT is set add it (and del. any previous version)\n\t *  - if via already contains an rport add it and overwrite the previous\n\t *  rport value if present (if you don't want to overwrite the previous\n\t *  version remove the comments) */\n\tif (((msg->msg_flags&FL_FORCE_RPORT)||\n\t\t\t(msg->via1->rport /*&& msg->via1->rport->value.s==0*/)) && !via1_deleted){\n\t\tif ((rport_buf=rport_builder(msg, &rport_len))==0){\n\t\t\tLM_ERR(\"rport_builder failed\\n\");\n\t\t\tgoto error01; /* free everything */\n\t\t}\n\t}\n\n\t/* add via header to the list */\n\t/* try to add it before msg. 1st via */\n\t/* add first via, as an anchor for second via*/\n\tanchor=anchor_lump(msg, msg->via1->hdr.s-buf, HDR_VIA_T);\n\tif (anchor==0) goto error01;\n\tif (insert_new_lump_before(anchor, line_buf, via_len, HDR_VIA_T)==0)\n\t\tgoto error01;\n\t/* find out where the offset of the first parameter that should be added\n\t * (after host:port), needed by add receive & maybe rport */\n\tif (msg->via1->params.s){\n\t\t\tsize= msg->via1->params.s-msg->via1->hdr.s-1; /*compensate\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t  for ';' */\n\t}else{\n\t\t\tsize= msg->via1->host.s-msg->via1->hdr.s+msg->via1->host.len;\n\t\t\tif (msg->via1->port!=0){\n\t\t\t\t/*size+=strlen(msg->via1->hdr.s+size+1)+1;*/\n\t\t\t\tsize += msg->via1->port_str.len + 1; /* +1 for ':'*/\n\t\t\t}\n\t}\n\t/* if received needs to be added, add anchor after host and add it, or\n\t * overwrite the previous one if already present */\n\tif (received_len){\n\t\tif (msg->via1->received){ /* received already present => overwrite it*/\n\t\t\tvia_insert_param=del_lump(msg,\n\t\t\t\t\t\t\t\tmsg->via1->received->start-buf-1, /*;*/\n\t\t\t\t\t\t\t\tmsg->via1->received->size+1, /*;*/ HDR_VIA_T);\n\t\t}else if (via_insert_param==0){ /* receive not present, ok */\n\t\t\tvia_insert_param=anchor_lump(msg,\n\t\t\t\t\t\t\t\t\t\tmsg->via1->hdr.s-buf+size, HDR_VIA_T);\n\t\t}\n\t\tif (via_insert_param==0) goto error02; /* free received_buf */\n\t\tif (insert_new_lump_after(via_insert_param, received_buf, received_len,\n\t\t\t\t\tHDR_VIA_T) ==0 ) goto error02; /* free received_buf */\n\t}\n\t/* if rport needs to be updated, delete it if present and add it's value */\n\tif (rport_len){\n\t\tif (msg->via1->rport){ /* rport already present */\n\t\t\tvia_insert_param=del_lump(msg,\n\t\t\t\t\t\t\t\tmsg->via1->rport->start-buf-1, /*';'*/\n\t\t\t\t\t\t\t\tmsg->via1->rport->size+1 /* ; */, HDR_VIA_T);\n\t\t}else if (via_insert_param==0){ /*force rport, no rport present */\n\t\t\t/* no rport, add it */\n\t\t\tvia_insert_param=anchor_lump(msg,\n\t\t\t\t\t\t\t\t\tmsg->via1->hdr.s-buf+size, HDR_VIA_T);\n\t\t}\n\t\tif (via_insert_param==0) goto error03; /* free rport_buf */\n\t\tif (insert_new_lump_after(via_insert_param, rport_buf, rport_len,\n\t\t\t\t\t\t\t\t\tHDR_VIA_T) ==0 )\n\t\t\tgoto error03; /* free rport_buf */\n\t}\n\nbuild_msg:\n\t/* adjust len to the useful part of the message */\n\tif (get_body(msg, &body) == 0 && body.len)\n\t\tlen -= (msg->buf + msg->len - body.s - body.len);\n\n\t/* compute new msg len and fix overlapping zones*/\n\tnew_len=len+body_delta+lumps_len(msg, msg->add_rm, send_sock,-1);\n#ifdef XL_DEBUG\n\tLM_DBG(\"new_len(%d)=len(%d)+lumps_len\\n\", new_len, len);\n#endif\n\n\tif (msg->new_uri.s){\n\t\turi_len=msg->new_uri.len;\n\t\tnew_len=new_len-msg->first_line.u.request.uri.len+uri_len;\n\t}\n\tif (flags&MSG_TRANS_SHM_FLAG)\n\t\tnew_buf=(char*)shm_malloc(new_len+1);\n\telse\n\t\tnew_buf=(char*)pkg_malloc(new_len+1);\n\tif (new_buf==0){\n\t\tser_error=E_OUT_OF_MEM;\n\t\tLM_ERR(\"out of pkg memory\\n\");\n\t\tgoto error00;\n\t}\n\n\toffset=s_offset=0;\n\tif (msg->new_uri.s){\n\t\t/* copy message up to uri */\n\t\tsize=msg->first_line.u.request.uri.s-buf;\n\t\tmemcpy(new_buf, buf, size);\n\t\toffset+=size;\n\t\ts_offset+=size;\n\t\t/* add our uri */\n\t\tmemcpy(new_buf+offset, msg->new_uri.s, uri_len);\n\t\toffset+=uri_len;\n\t\ts_offset+=msg->first_line.u.request.uri.len; /* skip original uri */\n\t}\n\n\t/* apply changes over SIP hdrs and body */\n\tapply_msg_changes( msg, new_buf, &offset, &s_offset, send_sock, len);\n\tif (offset!=new_len) {\n\t\tLM_BUG(\"len mismatch : calculated %d, written %d\\n\", new_len, offset);\n\t\tabort();\n\t}\n\n\tnew_buf[new_len]=0;\n\n\t*returned_len=new_len;\n\t/* cleanup */\n\tif (extra_params.s) pkg_free(extra_params.s);\n\treturn new_buf;\n\nerror01:\n\tif (line_buf) pkg_free(line_buf);\nerror02:\n\tif (received_buf) pkg_free(received_buf);\nerror03:\n\tif (rport_buf) pkg_free(rport_buf);\nerror00:\n\tif (extra_params.s) pkg_free(extra_params.s);\nerror:\n\t*returned_len=0;\n\treturn 0;\n}\n\n\n\nchar * build_res_buf_from_sip_res( struct sip_msg* msg,\n\tunsigned int *returned_len, struct socket_info *sock,int flags)\n{\n\tunsigned int new_len, body_delta, len;\n\tchar *new_buf, *buf;\n\tunsigned int offset, s_offset;\n\tstr body;\n\n\tbuf=msg->buf;\n\tlen=msg->len;\n\tnew_buf=0;\n\n\t/* Calculate message body difference and adjust\n\t * Content-Length\n\t */\n\tbody_delta = calculate_body_diff( msg, sock);\n\tif (adjust_clen(msg, body_delta, (msg->via2? msg->via2->proto:PROTO_UDP))\n\t\t\t< 0) {\n\t\tLM_ERR(\"failed to adjust Content-Length\\n\");\n\t\tgoto error;\n\t}\n\n\t/* remove the first via */\n\tif (!(flags & MSG_TRANS_NOVIA_FLAG)) {\n\t\tunsigned int via_len, via_offset;\n\n\t\tif (msg->via1->next) {\n\t\t\tvia_len = msg->via1->bsize;\n\t\t\tvia_offset = msg->h_via1->body.s-buf;\n\t\t} else {\n\t\t\tvia_len = msg->h_via1->len;\n\t\t\tvia_offset = msg->h_via1->name.s-buf;\n\t\t}\n\n\t\tif (del_lump(msg, via_offset, via_len, HDR_VIA_T) == 0) {\n\t\t\tLM_ERR(\"failed to remove first via\\n\");\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\t/* adjust len to the useful part of the message */\n\tif (get_body(msg, &body) == 0 && body.len)\n\t\tlen -= (msg->buf + msg->len - body.s - body.len);\n\tnew_len=len+body_delta+lumps_len(msg, msg->add_rm, sock, -1);\n\n\tLM_DBG(\" old size: %d, new size: %d\\n\", len, new_len);\n\tnew_buf=(char*)pkg_malloc(new_len+1); /* +1 is for debugging\n\t\t\t\t\t\t\t\t\t\t\t (\\0 to print it )*/\n\tif (new_buf==0){\n\t\tLM_ERR(\"out of pkg mem\\n\");\n\t\tgoto error;\n\t}\n\toffset=s_offset=0;\n\n\t/* apply changes over SIP hdrs and body */\n\tapply_msg_changes( msg, new_buf, &offset, &s_offset, sock, len);\n\tif (offset!=new_len) {\n\t\tLM_BUG(\"len mismatch : calculated %d, written %d\\n\", new_len, offset);\n\t\tabort();\n\t}\n\n\tnew_buf[new_len]=0; /* debug: print the message */\n\n\t/* as it is a relaied reply, if 503, make it 500 (just reply code) */\n\tif ( !disable_503_translation && msg->first_line.u.reply.statuscode==503 )\n\t\tnew_buf[(int)(msg->first_line.u.reply.status.s-msg->buf)+2] = '0';\n\t/* send it! */\n\tLM_DBG(\"copied size: orig:%d, new: %d, rest: %d\"\n\t\t\t\" msg=\\n%s\\n\", s_offset, offset, len-s_offset, new_buf);\n\n\t*returned_len=new_len;\n\treturn new_buf;\nerror:\n\t*returned_len=0;\n\treturn 0;\n}\n\n\nchar * build_res_buf_from_sip_req( unsigned int code, const str *text ,str *new_tag,\n\t\tstruct sip_msg* msg, unsigned int *returned_len, struct bookmark *bmark)\n{\n\tchar *buf, *p, *received_buf, *rport_buf, *warning_buf;\n\tchar *content_len_buf, *after_body, *totags;\n\tunsigned int len, foo, received_len, rport_len;\n\tunsigned int warning_len, content_len_len;\n\tstruct hdr_field *hdr;\n\tstruct lump_rpl *lump, *body;\n\tint i;\n\tstr to_tag;\n\n\tbody = 0;\n\tbuf=0;\n\tto_tag.s = 0;\n\tto_tag.len = 0;\n\treceived_buf=rport_buf=warning_buf=content_len_buf=0;\n\treceived_len=rport_len=warning_len=content_len_len=0;\n\n\t/* force parsing all headers -- we want to return all\n\tVia's in the reply and they may be scattered down to the\n\tend of header (non-block Vias are a really poor property\n\tof SIP :( ) */\n\tif (parse_headers( msg, HDR_EOH_F, 0 )==-1) {\n\t\tLM_ERR(\"parse_headers failed\\n\");\n\t\tgoto error00;\n\t}\n\n\t/*computes the length of the new response buffer*/\n\tlen = 0;\n\n\t/* check if rport needs to be updated */\n\tif ( (msg->msg_flags&FL_FORCE_RPORT)||\n\t\t(msg->via1->rport /*&& msg->via1->rport->value.s==0*/)){\n\t\tif ((rport_buf=rport_builder(msg, &rport_len))==0){\n\t\t\tLM_ERR(\"rport_builder failed\\n\");\n\t\t\tgoto error00;\n\t\t}\n\t\tif (msg->via1->rport)\n\t\t\tlen -= msg->via1->rport->size+1; /* include ';' */\n\t}\n\n\t/* check if received needs to be added or via rport has to be added */\n\tif (rport_buf || received_test(msg)) {\n\t\tif ((received_buf=received_builder(msg,&received_len))==0) {\n\t\t\tLM_ERR(\"received_builder failed\\n\");\n\t\t\tgoto error01;\n\t\t}\n\t}\n\n\t/* first line */\n\tlen += SIP_VERSION_LEN + 1/*space*/ + 3/*code*/ + 1/*space*/ +\n\t\ttext->len + CRLF_LEN/*new line*/;\n\t/* copy the TO hdr */\n\tif (msg->to) {\n\t\tif (new_tag && new_tag->len) {\n\t\t\tto_tag=get_to(msg)->tag_value;\n\t\t\tif (to_tag.len )\n\t\t\t\tlen+=new_tag->len-to_tag.len;\n\t\t\telse\n\t\t\t\tlen+=new_tag->len+TOTAG_TOKEN_LEN/*\";tag=\"*/;\n\t\t}\n\t\tlen += msg->to->len;\n\t}\n\n\t/* copy all VIA hdrs */\n\tfor( hdr=msg->h_via1 ; hdr ; hdr=hdr->sibling) {\n\t\t/* we always add CRLF to via*/\n\t\tlen+=(hdr->body.s+hdr->body.len)-hdr->name.s+CRLF_LEN;\n\t\tif (hdr==msg->h_via1) len += received_len+rport_len;\n\t}\n\t/* copy all Record-Route hdrs */\n\tfor( hdr=msg->record_route ; hdr ; hdr=hdr->sibling) {\n\t\t/* RR only for 1xx and 2xx replies */\n\t\tif (code>=180 && code<300)\n\t\t\tlen += hdr->len;\n\t}\n\t/* copy the FROM hdr */\n\tif (msg->from)\n\t\tlen += msg->from->len;\n\t/* copy the CALLID hdr */\n\tif (msg->callid)\n\t\tlen += msg->callid->len;\n\t/* copy the CSEQ hdr */\n\tif (msg->cseq)\n\t\tlen += msg->cseq->len;\n\n\t/* lumps length */\n\tfor(lump=msg->reply_lump;lump;lump=lump->next) {\n\t\tlen += lump->text.len;\n\t\tif (lump->flags&LUMP_RPL_BODY)\n\t\t\tbody = lump;\n\t}\n\t/* server header */\n\tif (server_signature)\n\t\tlen += server_header->len + CRLF_LEN;\n\t/* warning hdr */\n\tif (sip_warning) {\n\t\twarning_buf = warning_builder(msg,&warning_len);\n\t\tif (warning_buf) len += warning_len + CRLF_LEN;\n\t\telse LM_WARN(\"warning skipped -- too big\\n\");\n\t}\n\t/* content length hdr */\n\tif (body) {\n\t\tcontent_len_buf = int2str(body->text.len, (int*)&content_len_len);\n\t\tlen += CONTENT_LENGTH_LEN + content_len_len + CRLF_LEN;\n\t} else {\n\t\tlen += CONTENT_LENGTH_LEN + 1/*0*/ + CRLF_LEN;\n\t}\n\t/* end of message */\n\tlen += CRLF_LEN; /*new line*/\n\n\t/*allocating mem*/\n\tbuf = (char*) pkg_malloc( len+1 );\n\tif (!buf)\n\t{\n\t\tLM_ERR(\"out of pkg memory; needs %d\\n\",len);\n\t\tgoto error01;\n\t}\n\n\t/* filling the buffer*/\n\tp=buf;\n\t/* first line */\n\tmemcpy( p , SIP_VERSION , SIP_VERSION_LEN );\n\tp += SIP_VERSION_LEN;\n\t*(p++) = ' ' ;\n\t/*code*/\n\tfor ( i=2 , foo = code  ;  i>=0  ;  i-- , foo=foo/10 )\n\t\t*(p+i) = '0' + foo - ( foo/10 )*10;\n\tp += 3;\n\t*(p++) = ' ' ;\n\tmemcpy( p , text->s , text->len );\n\tp += text->len;\n\tmemcpy( p, CRLF, CRLF_LEN );\n\tp+=CRLF_LEN;\n\t/* VIA headers */\n\tif ( (hdr=msg->h_via1)!=NULL ) {\n\t\t/* handle the VIA1, subject to changes */\n\t\ti = 0;\n\t\tif (received_buf) {\n\t\t\ti = msg->via1->host.s - msg->via1->hdr.s +\n\t\t\t\tmsg->via1->host.len + (msg->via1->port?\n\t\t\t\tmsg->via1->port_str.len + 1 : 0);\n\t\t\t/* copy via1 up to params */\n\t\t\tappend_str( p, hdr->name.s, i);\n\t\t\t/* copy received param */\n\t\t\tappend_str( p, received_buf, received_len);\n\t\t}\n\t\tif (rport_buf){\n\t\t\tif (msg->via1->rport){ /* delete the old one */\n\t\t\t\t/* copy until rport */\n\t\t\t\tappend_str( p, hdr->name.s+i ,\n\t\t\t\t\tmsg->via1->rport->start-hdr->name.s-1-i);\n\t\t\t\t/* copy new rport */\n\t\t\t\tappend_str(p, rport_buf, rport_len);\n\t\t\t\t/* copy the rest of the via */\n\t\t\t\tappend_str(p, msg->via1->rport->start+\n\t\t\t\t\t\t\t\t\tmsg->via1->rport->size,\n\t\t\t\t\t\t\t\t\thdr->body.s+hdr->body.len-\n\t\t\t\t\t\t\t\t\tmsg->via1->rport->start-\n\t\t\t\t\t\t\t\t\tmsg->via1->rport->size);\n\t\t\t}else{ /* just copy rport and rest of hdr */\n\t\t\t\tappend_str(p, rport_buf, rport_len);\n\t\t\t\tappend_str( p, hdr->name.s+i ,\n\t\t\t\t\t(hdr->body.s+hdr->body.len)-hdr->name.s-i);\n\t\t\t}\n\t\t}else{\n\t\t\t/* normal whole via copy */\n\t\t\tappend_str( p, hdr->name.s+i ,\n\t\t\t\t(hdr->body.s+hdr->body.len)-hdr->name.s-i);\n\t\t}\n\t\tappend_str( p, CRLF,CRLF_LEN);\n\t\t/* and now the rest of the VIA hdrs */\n\t\tfor( hdr=hdr->sibling ; hdr ; hdr=hdr->sibling) {\n\t\t\t/* normal whole via copy */\n\t\t\tappend_str( p, hdr->name.s,\n\t\t\t\t\t(hdr->body.s+hdr->body.len)-hdr->name.s);\n\t\t\tappend_str( p, CRLF,CRLF_LEN);\n\t\t}\n\t}\n\t/* Record-Route headers */\n\tfor( hdr=msg->record_route ; hdr ; hdr=hdr->sibling) {\n\t\t/* RR only for 1xx and 2xx replies */\n\t\tif (code>=180 && code<300)\n\t\t\tappend_str(p, hdr->name.s, hdr->len);\n\t}\n\t/* TO hdr */\n\tif ( (hdr=msg->to)!=NULL ) {\n\t\tif (new_tag && new_tag->len){\n\t\t\tif (to_tag.len ) { /* replacement */\n\t\t\t\t/* before to-tag */\n\t\t\t\tappend_str( p, hdr->name.s, to_tag.s-hdr->name.s);\n\t\t\t\t/* to tag replacement */\n\t\t\t\tbmark->to_tag_val.s=p;\n\t\t\t\tbmark->to_tag_val.len=new_tag->len;\n\t\t\t\tappend_str( p, new_tag->s,new_tag->len);\n\t\t\t\t/* the rest after to-tag */\n\t\t\t\tappend_str( p, to_tag.s+to_tag.len,\n\t\t\t\t\thdr->name.s+hdr->len-(to_tag.s+to_tag.len));\n\t\t\t}else{ /* adding a new to-tag */\n\t\t\t\tafter_body=hdr->body.s+hdr->body.len;\n\t\t\t\tappend_str( p, hdr->name.s, after_body-hdr->name.s);\n\t\t\t\tappend_str(p, TOTAG_TOKEN, TOTAG_TOKEN_LEN);\n\t\t\t\tbmark->to_tag_val.s=p;\n\t\t\t\tbmark->to_tag_val.len=new_tag->len;\n\t\t\t\tappend_str( p, new_tag->s,new_tag->len);\n\t\t\t\tappend_str( p, after_body,\n\t\t\t\t\t\t\t\thdr->name.s+hdr->len-after_body);\n\t\t\t}\n\t\t} else {\n\t\t\t/* no new to-tag -- proceed to 1:1 copying  */\n\t\t\ttotags=((struct to_body*)(hdr->parsed))->tag_value.s;\n\t\t\tif (totags) {\n\t\t\t\tbmark->to_tag_val.s=p+(totags-hdr->name.s);\n\t\t\t\tbmark->to_tag_val.len=\n\t\t\t\t\t((struct to_body*)(hdr->parsed))->tag_value.len;\n\t\t\t} else {\n\t\t\t\tbmark->to_tag_val.s = NULL;\n\t\t\t\tbmark->to_tag_val.len = 0;\n\t\t\t}\n\t\t\tappend_str(p, hdr->name.s, hdr->len);\n\t\t}\n\t}\n\t/* FROM header */\n\tif (msg->from)\n\t\tappend_str(p, msg->from->name.s, msg->from->len);\n\t/* CALLID header */\n\tif (msg->callid)\n\t\tappend_str(p, msg->callid->name.s, msg->callid->len);\n\t/* copy the CSEQ hdr */\n\tif (msg->cseq)\n\t\tappend_str(p, msg->cseq->name.s, msg->cseq->len);\n\t/* lumps */\n\tfor(lump=msg->reply_lump;lump;lump=lump->next)\n\t\tif (lump->flags&LUMP_RPL_HDR){\n\t\t\tmemcpy(p,lump->text.s,lump->text.len);\n\t\t\tp += lump->text.len;\n\t\t}\n\t/* server header */\n\tif (server_signature) {\n\t\tappend_str( p, server_header->s, server_header->len);\n\t\tappend_str( p, CRLF, CRLF_LEN );\n\t}\n\t/* content_length hdr */\n\tif (content_len_len) {\n\t\tappend_str( p, CONTENT_LENGTH, CONTENT_LENGTH_LEN);\n\t\tappend_str( p, content_len_buf, content_len_len );\n\t\tappend_str( p, CRLF, CRLF_LEN );\n\t} else {\n\t\tappend_str( p, CONTENT_LENGTH\"0\"CRLF,CONTENT_LENGTH_LEN+1+CRLF_LEN);\n\t}\n\t/* warning header */\n\tif (warning_buf) {\n\t\tappend_str( p, warning_buf, warning_len );\n\t\tappend_str( p, CRLF, CRLF_LEN );\n\t}\n\t/*end of message*/\n\tmemcpy( p, CRLF, CRLF_LEN );\n\tp+=CRLF_LEN;\n\t/* body */\n\tif (body) {\n\t\tappend_str( p, body->text.s, body->text.len );\n\t}\n\n\tif (len!=(unsigned long)(p-buf))\n\t\tLM_CRIT(\"diff len=%d p-buf=%d\\n\", len, (int)(p-buf));\n\n\t*(p) = 0;\n\t*returned_len = len;\n\t/* in req2reply, received_buf is not introduced to lumps and\n\t   needs to be deleted here\n\t*/\n\tif (received_buf) pkg_free(received_buf);\n\tif (rport_buf) pkg_free(rport_buf);\n\treturn buf;\n\nerror01:\n\tif (received_buf) pkg_free(received_buf);\n\tif (rport_buf) pkg_free(rport_buf);\nerror00:\n\t*returned_len=0;\n\treturn 0;\n}\n\n\n\n/*! \\brief return number of chars printed or 0 if space exceeded;\n   assumes buffer size of at least MAX_BRANCH_PARAM_LEN\n */\nint branch_builder( unsigned int hash_index,\n\t/* only either parameter useful */\n\tunsigned int label, char * char_v,\n\tint branch,\n\tchar *branch_str, int *len )\n{\n\n\tchar *begin;\n\tint size;\n\n\t/* hash id provided ... start with it */\n\tsize=MAX_BRANCH_PARAM_LEN;\n\tbegin=branch_str;\n\t*len=0;\n\n\tmemcpy(begin, MCOOKIE, MCOOKIE_LEN );\n\tsize-=MCOOKIE_LEN;begin+=MCOOKIE_LEN;\n\n\tif (int2reverse_hex( &begin, &size, hash_index)==-1)\n\t\treturn 0;\n\n\tif (size) {\n\t\t*begin=BRANCH_SEPARATOR;\n\t\tbegin++; size--;\n\t} else return 0;\n\n\t/* string with request's characteristic value ... use it ... */\n\tif (char_v) {\n\t\tif (memcpy(begin,char_v,MD5_LEN)) {\n\t\t\tbegin+=MD5_LEN; size-=MD5_LEN;\n\t\t} else return 0;\n\t} else { /* ... use the \"label\" value otherwise */\n\t\tif (int2reverse_hex( &begin, &size, label )==-1)\n\t\t\treturn 0;\n\t}\n\n\tif (size) {\n\t\t*begin=BRANCH_SEPARATOR;\n\t\tbegin++; size--;\n\t} else return 0;\n\n\tif (int2reverse_hex( &begin, &size, branch)==-1)\n\t\treturn 0;\n\n\t*len=MAX_BRANCH_PARAM_LEN-size;\n\treturn size;\n\n}\n\n\nchar* via_builder( unsigned int *len,\n\tstruct socket_info* send_sock,\n\tstr* branch, str* extra_params, int proto, struct hostport* hp)\n{\n\tunsigned int via_len, extra_len;\n\tchar *line_buf;\n\tint max_len, local_via_len=MY_VIA_LEN;\n\tstr* address_str; /* address displayed in via */\n\tstr* port_str; /* port no displayed in via */\n\n\t/* use pre-set address in via or the outbound socket one */\n\tif (hp && hp->host && hp->host->len)\n\t\taddress_str=hp->host;\n\telse\n\t\taddress_str=get_adv_host(send_sock);\n\n\tif (hp && hp->port && hp->port->len)\n\t\tport_str=hp->port;\n\telse\n\t\tport_str=get_adv_port(send_sock);\n\n\tmax_len=local_via_len+address_str->len /* space in MY_VIA */\n\t\t+2 /* just in case it is a v6 address ... [ ] */\n\t\t+1 /*':'*/+port_str->len\n\t\t+(branch?(MY_BRANCH_LEN+branch->len):0)\n\t\t+(extra_params?extra_params->len:0)\n\t\t+CRLF_LEN+1;\n\tline_buf=pkg_malloc( max_len );\n\tif (line_buf==0){\n\t\tser_error=E_OUT_OF_MEM;\n\t\tLM_ERR(\"out of pkg memory\\n\");\n\t\treturn 0;\n\t}\n\n\textra_len=0;\n\n\tmemcpy(line_buf, MY_VIA, local_via_len);\n\tif (proto==PROTO_UDP){\n\t\t/* do nothing */\n\t}else if (proto==PROTO_TCP){\n\t\tmemcpy(line_buf+local_via_len-4, \"TCP \", 4);\n\t}else if (proto==PROTO_TLS){\n\t\tmemcpy(line_buf+local_via_len-4, \"TLS \", 4);\n\t}else if(proto==PROTO_SCTP){\n\t\tmemcpy(line_buf+local_via_len-4, \"SCTP \", 5);\n\t\tlocal_via_len++;\n\t}else if(proto==PROTO_WS){\n\t\tmemcpy(line_buf+local_via_len-4, \"WS \", 3);\n\t\tlocal_via_len--;\n\t}else if(proto==PROTO_WSS){\n\t\tmemcpy(line_buf+local_via_len-4, \"WSS \", 4);\n\t}else{\n\t\tLM_CRIT(\"unknown proto %d\\n\", proto);\n\t\treturn 0;\n\t}\n\n\tvia_len=local_via_len+address_str->len; /*space included in MY_VIA*/\n\n\tmemcpy(line_buf+local_via_len+extra_len, address_str->s, address_str->len);\n\tline_buf[via_len]=':'; via_len++;\n\tmemcpy(line_buf+via_len, port_str->s, port_str->len);\n\tvia_len+=port_str->len;\n\n\t/* branch parameter */\n\tif (branch){\n\t\tmemcpy(line_buf+via_len, MY_BRANCH, MY_BRANCH_LEN );\n\t\tvia_len+=MY_BRANCH_LEN;\n\t\tmemcpy(line_buf+via_len, branch->s, branch->len );\n\t\tvia_len+=branch->len;\n\t}\n\t/* extra params  */\n\tif (extra_params){\n\t\tmemcpy(line_buf+via_len, extra_params->s, extra_params->len);\n\t\tvia_len+=extra_params->len;\n\t}\n\n\tmemcpy(line_buf+via_len, CRLF, CRLF_LEN);\n\tvia_len+=CRLF_LEN;\n\tline_buf[via_len]=0; /* null terminate the string*/\n\n\t*len = via_len;\n\treturn line_buf;\n}\n\n#define MAX_URI_LEN\t\t1024\nstatic char uri_buff[MAX_URI_LEN];\nchar *construct_uri(str *protocol,str *username,str *domain,str *port,\n\t\tstr *params,int *len)\n{\n\tint pos = 0;\n\n\tif (!len)\n\t{\n\t\tLM_ERR(\"null pointer provided for construct_uri \\n\");\n\t\treturn 0;\n\t}\n\n\tif (!protocol->s || protocol->len == 0)\n\t{\n\t\tLM_ERR(\"no protocol specified\\n\");\n\t\treturn 0;\n\t}\n\n\tif (!domain->s || domain->len == 0)\n\t{\n\t\tLM_ERR(\"no domain specified\\n\");\n\t\treturn 0;\n\t}\n\n\tmemcpy(uri_buff,protocol->s,protocol->len);\n\tpos += protocol->len;\n\turi_buff[pos++] = ':';\n\n\tif (username && username->s && username->len != 0)\n\t{\n\t\tmemcpy(uri_buff+pos,username->s,username->len);\n\t\tpos += username->len;\n\t\turi_buff[pos++] = '@';\n\t}\n\n\tmemcpy(uri_buff+pos,domain->s,domain->len);\n\tpos += domain->len;\n\n\tif (port && port->s && port->len !=0)\n\t{\n\t\turi_buff[pos++] = ':';\n\t\tmemcpy(uri_buff+pos,port->s,port->len);\n\t\tpos += port->len;\n\t}\n\n\tif (params && params->s && params->len !=0 )\n\t{\n\t\turi_buff[pos++] = ';';\n\t\tmemcpy(uri_buff+pos,params->s,params->len);\n\t\tpos += params->len;\n\t}\n\n\turi_buff[pos] = 0;\n\t*len = pos;\n\treturn uri_buff;\n}\n\n/* uses uri_buff above, since contact is still an uri */\nchar *contact_builder(struct socket_info* send_sock, int *ct_len)\n{\n\tchar *p;\n\tint proto_len = 0;\n\tstr* address_str = get_adv_host(send_sock);\n\tstr* port_str = get_adv_port(send_sock);\n\n\t/* sip: */\n\tp = uri_buff;\n\tmemcpy(p, \"sip:\", 4);\n\tp += 4;\n\n\t/* host */\n\tmemcpy(p, address_str->s, address_str->len);\n\tp += address_str->len;\n\n\t/* :port */\n\t*p++ = ':';\n\tmemcpy(p, port_str->s, port_str->len);\n\tp += port_str->len;\n\n\t/* transport if needed */\n\tif (send_sock->proto != PROTO_UDP) {\n\t\tmemcpy(p, \";transport=\", 11);\n\t\tp += 11;\n\t\tproto_len = strlen(protos[send_sock->proto].name);\n\t\tmemcpy(p, protos[send_sock->proto].name, proto_len);\n\t\tp += proto_len;\n\t}\n\n\t*p = '\\0';\n\n\tif (ct_len)\n\t\t*ct_len = p - uri_buff;\n\n\treturn uri_buff;\n}\n"], "filenames": ["msg_translator.c"], "buggy_code_start_loc": [136], "buggy_code_end_loc": [2667], "fixing_code_start_loc": [135], "fixing_code_end_loc": [2668], "type": "NVD-CWE-noinfo", "message": "OpenSIPS is a Session Initiation Protocol (SIP) server implementation. Versions prior to 3.1.7 and 3.2.4 have a potential issue in `msg_translator.c:2628` which might lead to a server crash. This issue was found while fuzzing the function `build_res_buf_from_sip_req` but could not be reproduced against a running instance of OpenSIPS. This issue could not be exploited against a running instance of OpenSIPS since no public function was found to make use of this vulnerable code. Even in the case of exploitation through unknown vectors, it is highly unlikely that this issue would lead to anything other than Denial of Service. This issue has been fixed in versions 3.1.7 and 3.2.4.", "other": {"cve": {"id": "CVE-2023-28095", "sourceIdentifier": "security-advisories@github.com", "published": "2023-03-15T22:15:10.440", "lastModified": "2023-03-21T19:23:29.190", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "OpenSIPS is a Session Initiation Protocol (SIP) server implementation. Versions prior to 3.1.7 and 3.2.4 have a potential issue in `msg_translator.c:2628` which might lead to a server crash. This issue was found while fuzzing the function `build_res_buf_from_sip_req` but could not be reproduced against a running instance of OpenSIPS. This issue could not be exploited against a running instance of OpenSIPS since no public function was found to make use of this vulnerable code. Even in the case of exploitation through unknown vectors, it is highly unlikely that this issue would lead to anything other than Denial of Service. This issue has been fixed in versions 3.1.7 and 3.2.4."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-20"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:opensips:opensips:*:*:*:*:*:*:*:*", "versionEndExcluding": "3.1.7", "matchCriteriaId": "8EF642AA-D786-40DF-801D-515888AF89BE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:opensips:opensips:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.2.0", "versionEndExcluding": "3.2.4", "matchCriteriaId": "34713A76-CAED-43CF-A77C-73F1C36208AA"}]}]}], "references": [{"url": "https://github.com/OpenSIPS/opensips/commit/9cf3dd3398719dd91207495f76d7726701c5145c", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/OpenSIPS/opensips/security/advisories/GHSA-7pf3-24qg-8v9h", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://opensips.org/pub/audit-2022/opensips-audit-technical-report-full.pdf", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/OpenSIPS/opensips/commit/9cf3dd3398719dd91207495f76d7726701c5145c"}}