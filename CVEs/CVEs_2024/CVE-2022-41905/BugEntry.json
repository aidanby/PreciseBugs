{"buggy_code": ["# -*- coding: utf-8 -*-\n# (c) 2009-2022 Martin Wendt and contributors; see WsgiDAV https://github.com/mar10/wsgidav\n# Licensed under the MIT license:\n# http://www.opensource.org/licenses/mit-license.php\n\"\"\"\nWSGI middleware that handles GET requests on collections to display directories.\n\"\"\"\nimport os\nimport sys\nfrom fnmatch import fnmatch\nfrom urllib.parse import unquote\n\nfrom jinja2 import Environment, FileSystemLoader\n\nfrom wsgidav import __version__, util\nfrom wsgidav.dav_error import HTTP_MEDIATYPE_NOT_SUPPORTED, HTTP_OK, DAVError\nfrom wsgidav.mw.base_mw import BaseMiddleware\nfrom wsgidav.util import get_uri_name, safe_re_encode, send_redirect_response\n\n__docformat__ = \"reStructuredText\"\n\n_logger = util.get_module_logger(__name__)\n\nASSET_SHARE = \"/:dir_browser\"\n\nDAVMOUNT_TEMPLATE = \"\"\"\n<dm:mount xmlns:dm=\"http://purl.org/NET/webdav/mount\">\n  <dm:url>{}</dm:url>\n</dm:mount>\n\"\"\".strip()\n\nMS_OFFICE_TYPE_TO_EXT_MAP = {\n    \"excel\": (\"xls\", \"xlt\", \"xlm\", \"xlsm\", \"xlsx\", \"xltm\", \"xltx\"),\n    \"powerpoint\": (\"pps\", \"ppt\", \"pptm\", \"pptx\", \"potm\", \"potx\", \"ppsm\", \"ppsx\"),\n    \"word\": (\"doc\", \"dot\", \"docm\", \"docx\", \"dotm\", \"dotx\"),\n    \"visio\": (\"vsd\", \"vsdm\", \"vsdx\", \"vstm\", \"vstx\"),\n}\nMS_OFFICE_EXT_TO_TYPE_MAP = {}\nfor t, el in MS_OFFICE_TYPE_TO_EXT_MAP.items():\n    for e in el:\n        MS_OFFICE_EXT_TO_TYPE_MAP[e] = t\nOPEN_OFFICE_EXTENSIONS = {\"odt\", \"odp\", \"odx\"}\n\n\nclass WsgiDavDirBrowser(BaseMiddleware):\n    \"\"\"WSGI middleware that handles GET requests on collections to display directories.\"\"\"\n\n    def __init__(self, wsgidav_app, next_app, config):\n        super().__init__(wsgidav_app, next_app, config)\n\n        self.dir_config = util.get_dict_value(config, \"dir_browser\", as_dict=True)\n\n        # mount path must be \"\" or start (but not end) with '/'\n        self.mount_path = config.get(\"mount_path\") or \"\"\n\n        htdocs_path = self.dir_config.get(\"htdocs_path\")\n        if htdocs_path:\n            self.htdocs_path = os.path.realpath(htdocs_path)\n        else:\n            self.htdocs_path = os.path.join(os.path.dirname(__file__), \"htdocs\")\n\n        if not os.path.isdir(self.htdocs_path):\n            raise ValueError(\n                \"Invalid dir_browser htdocs_path {!r}\".format(self.htdocs_path)\n            )\n\n        # Add an additional read-only FS provider that serves the dir_browser assets\n        self.wsgidav_app.add_provider(ASSET_SHARE, self.htdocs_path, readonly=True)\n        # and make sure we have anonymous access there\n        config.get(\"simple_dc\", {}).get(\"user_mapping\", {}).setdefault(\n            ASSET_SHARE, True\n        )\n\n        # Prepare a Jinja2 template\n        templateLoader = FileSystemLoader(searchpath=self.htdocs_path)\n        templateEnv = Environment(loader=templateLoader)\n        self.template = templateEnv.get_template(\"template.html\")\n\n    def is_disabled(self):\n        return self.dir_config.get(\"enable\") is False\n\n    def __call__(self, environ, start_response):\n        path = environ[\"PATH_INFO\"]\n\n        dav_res = None\n        if environ[\"wsgidav.provider\"]:\n            dav_res = environ[\"wsgidav.provider\"].get_resource_inst(path, environ)\n\n        if (\n            environ[\"REQUEST_METHOD\"] in (\"GET\", \"HEAD\")\n            and dav_res\n            and dav_res.is_collection\n        ):\n\n            if util.get_content_length(environ) != 0:\n                self._fail(\n                    HTTP_MEDIATYPE_NOT_SUPPORTED,\n                    \"The server does not handle any body content.\",\n                )\n\n            if environ[\"REQUEST_METHOD\"] == \"HEAD\":\n                return util.send_status_response(\n                    environ, start_response, HTTP_OK, is_head=True\n                )\n\n            # Support DAV mount (http://www.ietf.org/rfc/rfc4709.txt)\n            if self.dir_config.get(\"davmount\") and \"davmount\" in environ.get(\n                \"QUERY_STRING\", \"\"\n            ):\n                collectionUrl = util.make_complete_url(environ)\n                collectionUrl = collectionUrl.split(\"?\", 1)[0]\n                res = util.to_bytes(DAVMOUNT_TEMPLATE.format(collectionUrl))\n                # TODO: support <dm:open>%s</dm:open>\n\n                start_response(\n                    \"200 OK\",\n                    [\n                        (\"Content-Type\", \"application/davmount+xml\"),\n                        (\"Content-Length\", str(len(res))),\n                        (\"Cache-Control\", \"private\"),\n                        (\"Date\", util.get_rfc1123_time()),\n                    ],\n                )\n                return [res]\n\n            directory_slash = self.dir_config.get(\"directory_slash\")\n            requrest_uri = environ.get(\"REQUEST_URI\")\n            if directory_slash and requrest_uri and not requrest_uri.endswith(\"/\"):\n                _logger.info(f\"Redirect {requrest_uri} to {requrest_uri}/\")\n                return send_redirect_response(\n                    environ, start_response, location=requrest_uri + \"/\"\n                )\n\n            context = self._get_context(environ, dav_res)\n\n            res = self.template.render(**context)\n            res = util.to_bytes(res)\n            start_response(\n                \"200 OK\",\n                [\n                    (\"Content-Type\", \"text/html; charset=utf-8\"),\n                    (\"Content-Length\", str(len(res))),\n                    (\"Cache-Control\", \"private\"),\n                    (\"Date\", util.get_rfc1123_time()),\n                ],\n            )\n            return [res]\n\n        return self.next_app(environ, start_response)\n\n    def _fail(self, value, context_info=None, src_exception=None, err_condition=None):\n        \"\"\"Wrapper to raise (and log) DAVError.\"\"\"\n        e = DAVError(value, context_info, src_exception, err_condition)\n        if self.verbose >= 4:\n            _logger.warning(\n                \"Raising DAVError {}\".format(\n                    safe_re_encode(e.get_user_info(), sys.stdout.encoding)\n                )\n            )\n        raise e\n\n    def _get_context(self, environ, dav_res):\n        \"\"\"\n        @see: http://www.webdav.org/specs/rfc4918.html#rfc.section.9.4\n        \"\"\"\n        assert dav_res.is_collection\n\n        is_readonly = environ[\"wsgidav.provider\"].is_readonly()\n        ms_sharepoint_support = self.dir_config.get(\"ms_sharepoint_support\")\n        libre_office_support = self.dir_config.get(\"libre_office_support\")\n        is_top_dir = dav_res.path in (\"\", \"/\")\n\n        # TODO: WebDAV URLs only on Windows?\n        # TODO: WebDAV URLs only on HTTPS?\n        # is_windows = \"Windows NT \" in environ.get(\"HTTP_USER_AGENT\", \"\")\n\n        context = {\n            \"htdocs\": self.mount_path + ASSET_SHARE,\n            \"rows\": [],\n            \"version\": __version__,\n            \"display_path\": unquote(dav_res.get_href()),\n            \"url\": dav_res.get_href(),  # util.make_complete_url(environ),\n            # \"parent_url\": util.get_uri_parent(dav_res.get_href()),\n            \"is_top_dir\": is_top_dir,\n            \"config\": self.dir_config,\n            \"is_readonly\": is_readonly,\n            \"access\": \"read-only\" if is_readonly else \"read-write\",\n            \"is_authenticated\": False,\n        }\n\n        trailer = self.dir_config.get(\"response_trailer\")\n        if trailer is True:\n            trailer = \"${version} - ${time}\"\n\n        if trailer:\n            trailer = trailer.replace(\n                \"${version}\",\n                f\"<a href='https://github.com/mar10/wsgidav/'>WsgiDAV/{__version__}</a>\",\n            )\n            trailer = trailer.replace(\"${time}\", util.get_rfc1123_time())\n\n        context[\"trailer\"] = trailer\n\n        rows = context[\"rows\"]\n\n        # Ask collection for member info list\n        dirInfoList = dav_res.get_directory_info()\n\n        if dirInfoList is None:\n            # No pre-build info: traverse members\n            dirInfoList = []\n            childList = dav_res.get_descendants(depth=\"1\", add_self=False)\n            for res in childList:\n                di = res.get_display_info()\n                href = res.get_href()\n                ofe_prefix = None\n                tr_classes = []\n                a_classes = []\n\n                # #268 Use relative paths to support reverse proxies:\n                rel_href = get_uri_name(href)\n                if res.is_collection:\n                    tr_classes.append(\"directory\")\n                    rel_href = f\"./{rel_href}/\"  # 274\n\n                add_link_html = []\n\n                if not is_readonly and not res.is_collection:\n                    ext = os.path.splitext(href)[1].lstrip(\".\").lower()\n                    ms_office_type = MS_OFFICE_EXT_TO_TYPE_MAP.get(ext)\n                    if ms_office_type:\n                        if ms_sharepoint_support:\n                            ofe_prefix = f\"ms-{ms_office_type}:ofe|u|\"\n                            a_classes.append(\"msoffice\")\n                            if libre_office_support:\n                                add_link_html.append(\n                                    f\"<a class='edit2' title='Edit with Libre Office' href='vnd.libreoffice.command:ofv|u|{rel_href}'>Edit</a>\"\n                                )\n                                # ofe_prefix_2 = \"vnd.libreoffice.command:ofv|u|\"\n                                # a_classes.append(\"msoffice\")\n                        elif libre_office_support:\n                            ofe_prefix = \"vnd.libreoffice.command:ofv|u|\"\n                            # a_classes.append(\"msoffice\")\n\n                    elif ext in OPEN_OFFICE_EXTENSIONS:\n                        if libre_office_support:\n                            ofe_prefix = \"vnd.libreoffice.command:ofv|u|\"\n                            a_classes.append(\"msoffice\")\n\n                entry = {\n                    \"href\": rel_href,\n                    \"ofe_prefix\": ofe_prefix,\n                    \"a_class\": \" \".join(a_classes),\n                    \"add_link_html\": \"\".join(add_link_html),\n                    \"tr_class\": \" \".join(tr_classes),\n                    \"display_name\": res.get_display_name(),\n                    \"last_modified\": res.get_last_modified(),\n                    \"is_collection\": res.is_collection,\n                    \"content_length\": res.get_content_length(),\n                    \"display_type\": di.get(\"type\"),\n                    \"display_type_comment\": di.get(\"typeComment\"),\n                }\n\n                dirInfoList.append(entry)\n        #\n        ignore_patterns = self.dir_config.get(\"ignore\", [])\n        if util.is_basestring(ignore_patterns):\n            ignore_patterns = ignore_patterns.split(\",\")\n\n        ignored_list = []\n        for entry in dirInfoList:\n            # Skip ignore patterns\n            ignore = False\n            for pat in ignore_patterns:\n                if fnmatch(entry[\"display_name\"], pat):\n                    ignored_list.append(entry[\"display_name\"])\n                    # _logger.debug(\"Ignore {}\".format(entry[\"display_name\"]))\n                    ignore = True\n                    break\n            if ignore:\n                continue\n            #\n            last_modified = entry.get(\"last_modified\")\n            if last_modified is None:\n                entry[\"str_modified\"] = \"\"\n            else:\n                entry[\"str_modified\"] = util.get_rfc1123_time(last_modified)\n\n            entry[\"str_size\"] = \"-\"\n            if not entry.get(\"is_collection\"):\n                content_length = entry.get(\"content_length\")\n                if content_length is not None:\n                    entry[\"str_size\"] = util.byte_number_string(content_length)\n\n            rows.append(entry)\n        if ignored_list:\n            _logger.debug(\n                \"Dir browser ignored {} entries: {}\".format(\n                    len(ignored_list), ignored_list\n                )\n            )\n\n        # sort\n        sort = \"name\"\n        if sort == \"name\":\n            rows.sort(\n                key=lambda v: \"{}{}\".format(\n                    not v[\"is_collection\"], v[\"display_name\"].lower()\n                )\n            )\n\n        if \"wsgidav.auth.user_name\" in environ:\n            context.update(\n                {\n                    \"is_authenticated\": bool(environ.get(\"wsgidav.auth.user_name\")),\n                    \"user_name\": (environ.get(\"wsgidav.auth.user_name\") or \"anonymous\"),\n                    \"realm\": environ.get(\"wsgidav.auth.realm\"),\n                    \"user_roles\": \", \".join(environ.get(\"wsgidav.auth.roles\") or []),\n                    \"user_permissions\": \", \".join(\n                        environ.get(\"wsgidav.auth.permissions\") or []\n                    ),\n                }\n            )\n\n        return context\n", "<!DOCTYPE html>\n<html>\n<head>\n  <meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\">\n  <meta name=\"generator\" content=\"WsgiDAV/{{ version }}\">\n  <title>WsgiDAV - Index of {{ display_path }} </title>\n  <link rel=\"shortcut icon\" href=\"{{ htdocs }}/favicon.ico\">\n  <link rel=\"stylesheet\" href=\"{{ htdocs }}/style.css\" />\n  <script defer src=\"{{ htdocs }}/script.js\"></script>\n  <style type=\"text/css\"> A {behavior: url(#default#AnchorClick);} </style>\n</head>\n\n<body onload=\"onLoad()\">\n\n  <h1>\n    {%- if config.icon %}\n    <img class=\"logo\" alt=\"WsgiDAV\" title=\"WsgiDAV\" src=\"{{ htdocs }}/logo.png\">\n    {% endif -%}\n    Index of {{ display_path }}\n  </h1>\n\n  {% if config.davmount_links %}\n  <p class=\"links\">\n    <a title=\"Open this folder in a registered WebDAV client.\" href=\"{{ url }}?davmount\">Mount</a>\n  </p>\n  {% endif %}\n\n  {%- if user_name and config.show_user %}\n  <p class=\"auth-user\">\n    Authenticated user: \"{{user_name}}\", realm: \"{{realm}}\", access: {{access}}.\n    {%- if is_authenticated and config.show_logout %}\n      <a title=\"Logout current user\" href=\"{{ url }}?logout\" target=\"_blank\">Logout</a>\n    {% endif -%}\n    {%- if user_roles %}\n      , roles: {{ user_roles }}\n    {% endif -%}\n  </p>\n  {% endif -%}\n\n  <hr>\n\n  <table class=\"dir-listing\" onclick=\"return onClickTable(event)\">\n\n    <colgroup>\n      <col>\n      <col>\n      <col class=\"right\">\n      <col class=\"right\">\n    </colgroup>\n\n    <thead>\n      <tr>\n        <th>Name</th>\n        <th>Type</th>\n        <th>Size</th>\n        <th>Last modified</th>\n      </tr>\n    </thead>\n\n    <tbody>\n      {%- if not is_top_dir %}\n      <tr class=\"directory\">\n          <td>\n            <a href=\"..\">..</a>\n          </td>\n        <td>Directory</td>\n        <td>-</td>\n        <td></td>\n      </tr>\n      {% endif -%}\n\n      {% for row in rows %}\n      <tr class=\"{{ row.tr_class }}\">\n        <td>\n          <a class=\"{{ row.a_class }}\" href=\"{{row.href}}\" {% if row.ofe_prefix %} data-ofe=\"{{row.ofe_prefix}}\" {% endif %} >\n              {{row.display_name}}\n          </a>\n          {%- if row.href_2 %}\n            <a class=\"{{ row.a_class_2 }}\" href=\"{{row.href_2}}\" {% if row.ofe_prefix_2%} data-ofe=\"{{row.ofe_prefix_2}}\" {% endif %} >\n                {{row.display_name_2}}\n            </a>\n          {% endif -%}\n          {%- if row.add_link_html %}\n              {{row.add_link_html}}\n          {% endif -%}\n        </td>\n        <td>{{ row.display_type }}</td>\n        <td>{{ row.str_size }}</td>\n        <td>{{ row.str_modified }}</td>\n      </tr>\n      {% endfor %}\n    </tbody>\n  </table>\n\n  <hr>\n\n  {% if trailer %}\n  <p class=\"trailer\">{{ trailer }}</p>\n  {% endif %}\n\n  <object id=\"winFirefoxPlugin\" type=\"application/x-sharepoint\"\n      width=\"0\" height=\"0\" style=\"visibility: hidden;\"></object>\n\n</body>\n</html>\n"], "fixing_code": ["# -*- coding: utf-8 -*-\n# (c) 2009-2022 Martin Wendt and contributors; see WsgiDAV https://github.com/mar10/wsgidav\n# Licensed under the MIT license:\n# http://www.opensource.org/licenses/mit-license.php\n\"\"\"\nWSGI middleware that handles GET requests on collections to display directories.\n\"\"\"\nimport os\nimport sys\nfrom fnmatch import fnmatch\nfrom urllib.parse import unquote\n\nfrom jinja2 import Environment, FileSystemLoader, select_autoescape\n\nfrom wsgidav import __version__, util\nfrom wsgidav.dav_error import HTTP_MEDIATYPE_NOT_SUPPORTED, HTTP_OK, DAVError\nfrom wsgidav.mw.base_mw import BaseMiddleware\nfrom wsgidav.util import get_uri_name, safe_re_encode, send_redirect_response\n\n__docformat__ = \"reStructuredText\"\n\n_logger = util.get_module_logger(__name__)\n\nASSET_SHARE = \"/:dir_browser\"\n\nDAVMOUNT_TEMPLATE = \"\"\"\n<dm:mount xmlns:dm=\"http://purl.org/NET/webdav/mount\">\n  <dm:url>{}</dm:url>\n</dm:mount>\n\"\"\".strip()\n\nMS_OFFICE_TYPE_TO_EXT_MAP = {\n    \"excel\": (\"xls\", \"xlt\", \"xlm\", \"xlsm\", \"xlsx\", \"xltm\", \"xltx\"),\n    \"powerpoint\": (\"pps\", \"ppt\", \"pptm\", \"pptx\", \"potm\", \"potx\", \"ppsm\", \"ppsx\"),\n    \"word\": (\"doc\", \"dot\", \"docm\", \"docx\", \"dotm\", \"dotx\"),\n    \"visio\": (\"vsd\", \"vsdm\", \"vsdx\", \"vstm\", \"vstx\"),\n}\nMS_OFFICE_EXT_TO_TYPE_MAP = {}\nfor t, el in MS_OFFICE_TYPE_TO_EXT_MAP.items():\n    for e in el:\n        MS_OFFICE_EXT_TO_TYPE_MAP[e] = t\nOPEN_OFFICE_EXTENSIONS = {\"odt\", \"odp\", \"odx\"}\n\n\nclass WsgiDavDirBrowser(BaseMiddleware):\n    \"\"\"WSGI middleware that handles GET requests on collections to display directories.\"\"\"\n\n    def __init__(self, wsgidav_app, next_app, config):\n        super().__init__(wsgidav_app, next_app, config)\n\n        self.dir_config = util.get_dict_value(config, \"dir_browser\", as_dict=True)\n\n        # mount path must be \"\" or start (but not end) with '/'\n        self.mount_path = config.get(\"mount_path\") or \"\"\n\n        htdocs_path = self.dir_config.get(\"htdocs_path\")\n        if htdocs_path:\n            self.htdocs_path = os.path.realpath(htdocs_path)\n        else:\n            self.htdocs_path = os.path.join(os.path.dirname(__file__), \"htdocs\")\n\n        if not os.path.isdir(self.htdocs_path):\n            raise ValueError(\n                \"Invalid dir_browser htdocs_path {!r}\".format(self.htdocs_path)\n            )\n\n        # Add an additional read-only FS provider that serves the dir_browser assets\n        self.wsgidav_app.add_provider(ASSET_SHARE, self.htdocs_path, readonly=True)\n        # and make sure we have anonymous access there\n        config.get(\"simple_dc\", {}).get(\"user_mapping\", {}).setdefault(\n            ASSET_SHARE, True\n        )\n\n        # Prepare a Jinja2 template\n        templateLoader = FileSystemLoader(searchpath=self.htdocs_path)\n        templateEnv = Environment(loader=templateLoader, autoescape=select_autoescape())\n        self.template = templateEnv.get_template(\"template.html\")\n\n    def is_disabled(self):\n        return self.dir_config.get(\"enable\") is False\n\n    def __call__(self, environ, start_response):\n        path = environ[\"PATH_INFO\"]\n\n        dav_res = None\n        if environ[\"wsgidav.provider\"]:\n            dav_res = environ[\"wsgidav.provider\"].get_resource_inst(path, environ)\n\n        if (\n            environ[\"REQUEST_METHOD\"] in (\"GET\", \"HEAD\")\n            and dav_res\n            and dav_res.is_collection\n        ):\n\n            if util.get_content_length(environ) != 0:\n                self._fail(\n                    HTTP_MEDIATYPE_NOT_SUPPORTED,\n                    \"The server does not handle any body content.\",\n                )\n\n            if environ[\"REQUEST_METHOD\"] == \"HEAD\":\n                return util.send_status_response(\n                    environ, start_response, HTTP_OK, is_head=True\n                )\n\n            # Support DAV mount (http://www.ietf.org/rfc/rfc4709.txt)\n            if self.dir_config.get(\"davmount\") and \"davmount\" in environ.get(\n                \"QUERY_STRING\", \"\"\n            ):\n                collectionUrl = util.make_complete_url(environ)\n                collectionUrl = collectionUrl.split(\"?\", 1)[0]\n                res = util.to_bytes(DAVMOUNT_TEMPLATE.format(collectionUrl))\n                # TODO: support <dm:open>%s</dm:open>\n\n                start_response(\n                    \"200 OK\",\n                    [\n                        (\"Content-Type\", \"application/davmount+xml\"),\n                        (\"Content-Length\", str(len(res))),\n                        (\"Cache-Control\", \"private\"),\n                        (\"Date\", util.get_rfc1123_time()),\n                    ],\n                )\n                return [res]\n\n            directory_slash = self.dir_config.get(\"directory_slash\")\n            requrest_uri = environ.get(\"REQUEST_URI\")\n            if directory_slash and requrest_uri and not requrest_uri.endswith(\"/\"):\n                _logger.info(f\"Redirect {requrest_uri} to {requrest_uri}/\")\n                return send_redirect_response(\n                    environ, start_response, location=requrest_uri + \"/\"\n                )\n\n            context = self._get_context(environ, dav_res)\n\n            res = self.template.render(**context)\n            res = util.to_bytes(res)\n            start_response(\n                \"200 OK\",\n                [\n                    (\"Content-Type\", \"text/html; charset=utf-8\"),\n                    (\"Content-Length\", str(len(res))),\n                    (\"Cache-Control\", \"private\"),\n                    (\"Date\", util.get_rfc1123_time()),\n                ],\n            )\n            return [res]\n\n        return self.next_app(environ, start_response)\n\n    def _fail(self, value, context_info=None, src_exception=None, err_condition=None):\n        \"\"\"Wrapper to raise (and log) DAVError.\"\"\"\n        e = DAVError(value, context_info, src_exception, err_condition)\n        if self.verbose >= 4:\n            _logger.warning(\n                \"Raising DAVError {}\".format(\n                    safe_re_encode(e.get_user_info(), sys.stdout.encoding)\n                )\n            )\n        raise e\n\n    def _get_context(self, environ, dav_res):\n        \"\"\"\n        @see: http://www.webdav.org/specs/rfc4918.html#rfc.section.9.4\n        \"\"\"\n        assert dav_res.is_collection\n\n        is_readonly = environ[\"wsgidav.provider\"].is_readonly()\n        ms_sharepoint_support = self.dir_config.get(\"ms_sharepoint_support\")\n        libre_office_support = self.dir_config.get(\"libre_office_support\")\n        is_top_dir = dav_res.path in (\"\", \"/\")\n\n        # TODO: WebDAV URLs only on Windows?\n        # TODO: WebDAV URLs only on HTTPS?\n        # is_windows = \"Windows NT \" in environ.get(\"HTTP_USER_AGENT\", \"\")\n\n        context = {\n            \"htdocs\": self.mount_path + ASSET_SHARE,\n            \"rows\": [],\n            \"version\": __version__,\n            \"display_path\": unquote(dav_res.get_href()),\n            \"url\": dav_res.get_href(),  # util.make_complete_url(environ),\n            # \"parent_url\": util.get_uri_parent(dav_res.get_href()),\n            \"is_top_dir\": is_top_dir,\n            \"config\": self.dir_config,\n            \"is_readonly\": is_readonly,\n            \"access\": \"read-only\" if is_readonly else \"read-write\",\n            \"is_authenticated\": False,\n        }\n\n        trailer = self.dir_config.get(\"response_trailer\")\n        if trailer is True:\n            trailer = \"${version} - ${time}\"\n\n        if trailer:\n            trailer = trailer.replace(\n                \"${version}\",\n                f\"<a href='https://github.com/mar10/wsgidav/'>WsgiDAV/{__version__}</a>\",\n            )\n            trailer = trailer.replace(\"${time}\", util.get_rfc1123_time())\n\n        context[\"trailer\"] = trailer\n\n        rows = context[\"rows\"]\n\n        # Ask collection for member info list\n        dirInfoList = dav_res.get_directory_info()\n\n        if dirInfoList is None:\n            # No pre-build info: traverse members\n            dirInfoList = []\n            childList = dav_res.get_descendants(depth=\"1\", add_self=False)\n            for res in childList:\n                di = res.get_display_info()\n                href = res.get_href()\n                ofe_prefix = None\n                tr_classes = []\n                a_classes = []\n\n                # #268 Use relative paths to support reverse proxies:\n                rel_href = get_uri_name(href)\n                if res.is_collection:\n                    tr_classes.append(\"directory\")\n                    rel_href = f\"./{rel_href}/\"  # 274\n\n                add_link_html = []\n\n                if not is_readonly and not res.is_collection:\n                    ext = os.path.splitext(href)[1].lstrip(\".\").lower()\n                    ms_office_type = MS_OFFICE_EXT_TO_TYPE_MAP.get(ext)\n                    if ms_office_type:\n                        if ms_sharepoint_support:\n                            ofe_prefix = f\"ms-{ms_office_type}:ofe|u|\"\n                            a_classes.append(\"msoffice\")\n                            if libre_office_support:\n                                add_link_html.append(\n                                    f\"<a class='edit2' title='Edit with Libre Office' href='vnd.libreoffice.command:ofv|u|{rel_href}'>Edit</a>\"\n                                )\n                                # ofe_prefix_2 = \"vnd.libreoffice.command:ofv|u|\"\n                                # a_classes.append(\"msoffice\")\n                        elif libre_office_support:\n                            ofe_prefix = \"vnd.libreoffice.command:ofv|u|\"\n                            # a_classes.append(\"msoffice\")\n\n                    elif ext in OPEN_OFFICE_EXTENSIONS:\n                        if libre_office_support:\n                            ofe_prefix = \"vnd.libreoffice.command:ofv|u|\"\n                            a_classes.append(\"msoffice\")\n\n                entry = {\n                    \"href\": rel_href,\n                    \"ofe_prefix\": ofe_prefix,\n                    \"a_class\": \" \".join(a_classes),\n                    \"add_link_html\": \"\".join(add_link_html),\n                    \"tr_class\": \" \".join(tr_classes),\n                    \"display_name\": res.get_display_name(),\n                    \"last_modified\": res.get_last_modified(),\n                    \"is_collection\": res.is_collection,\n                    \"content_length\": res.get_content_length(),\n                    \"display_type\": di.get(\"type\"),\n                    \"display_type_comment\": di.get(\"typeComment\"),\n                }\n\n                dirInfoList.append(entry)\n        #\n        ignore_patterns = self.dir_config.get(\"ignore\", [])\n        if util.is_basestring(ignore_patterns):\n            ignore_patterns = ignore_patterns.split(\",\")\n\n        ignored_list = []\n        for entry in dirInfoList:\n            # Skip ignore patterns\n            ignore = False\n            for pat in ignore_patterns:\n                if fnmatch(entry[\"display_name\"], pat):\n                    ignored_list.append(entry[\"display_name\"])\n                    # _logger.debug(\"Ignore {}\".format(entry[\"display_name\"]))\n                    ignore = True\n                    break\n            if ignore:\n                continue\n            #\n            last_modified = entry.get(\"last_modified\")\n            if last_modified is None:\n                entry[\"str_modified\"] = \"\"\n            else:\n                entry[\"str_modified\"] = util.get_rfc1123_time(last_modified)\n\n            entry[\"str_size\"] = \"-\"\n            if not entry.get(\"is_collection\"):\n                content_length = entry.get(\"content_length\")\n                if content_length is not None:\n                    entry[\"str_size\"] = util.byte_number_string(content_length)\n\n            rows.append(entry)\n        if ignored_list:\n            _logger.debug(\n                \"Dir browser ignored {} entries: {}\".format(\n                    len(ignored_list), ignored_list\n                )\n            )\n\n        # sort\n        sort = \"name\"\n        if sort == \"name\":\n            rows.sort(\n                key=lambda v: \"{}{}\".format(\n                    not v[\"is_collection\"], v[\"display_name\"].lower()\n                )\n            )\n\n        if \"wsgidav.auth.user_name\" in environ:\n            context.update(\n                {\n                    \"is_authenticated\": bool(environ.get(\"wsgidav.auth.user_name\")),\n                    \"user_name\": (environ.get(\"wsgidav.auth.user_name\") or \"anonymous\"),\n                    \"realm\": environ.get(\"wsgidav.auth.realm\"),\n                    \"user_roles\": \", \".join(environ.get(\"wsgidav.auth.roles\") or []),\n                    \"user_permissions\": \", \".join(\n                        environ.get(\"wsgidav.auth.permissions\") or []\n                    ),\n                }\n            )\n\n        return context\n", "<!DOCTYPE html>\n<html>\n<head>\n  <meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\">\n  <meta name=\"generator\" content=\"WsgiDAV/{{ version }}\">\n  <title>WsgiDAV - Index of {{ display_path }} </title>\n  <link rel=\"shortcut icon\" href=\"{{ htdocs }}/favicon.ico\">\n  <link rel=\"stylesheet\" href=\"{{ htdocs }}/style.css\" />\n  <script defer src=\"{{ htdocs }}/script.js\"></script>\n  <style type=\"text/css\"> A {behavior: url(#default#AnchorClick);} </style>\n</head>\n\n<body onload=\"onLoad()\">\n\n  <h1>\n    {%- if config.icon %}\n    <img class=\"logo\" alt=\"WsgiDAV\" title=\"WsgiDAV\" src=\"{{ htdocs }}/logo.png\">\n    {% endif -%}\n    Index of {{ display_path }}\n  </h1>\n\n  {% if config.davmount_links %}\n  <p class=\"links\">\n    <a title=\"Open this folder in a registered WebDAV client.\" href=\"{{ url }}?davmount\">Mount</a>\n  </p>\n  {% endif %}\n\n  {%- if user_name and config.show_user %}\n  <p class=\"auth-user\">\n    Authenticated user: \"{{user_name}}\", realm: \"{{realm}}\", access: {{access}}.\n    {%- if is_authenticated and config.show_logout %}\n      <a title=\"Logout current user\" href=\"{{ url }}?logout\" target=\"_blank\">Logout</a>\n    {% endif -%}\n    {%- if user_roles %}\n      , roles: {{ user_roles }}\n    {% endif -%}\n  </p>\n  {% endif -%}\n\n  <hr>\n\n  <table class=\"dir-listing\" onclick=\"return onClickTable(event)\">\n\n    <colgroup>\n      <col>\n      <col>\n      <col class=\"right\">\n      <col class=\"right\">\n    </colgroup>\n\n    <thead>\n      <tr>\n        <th>Name</th>\n        <th>Type</th>\n        <th>Size</th>\n        <th>Last modified</th>\n      </tr>\n    </thead>\n\n    <tbody>\n      {%- if not is_top_dir %}\n      <tr class=\"directory\">\n          <td>\n            <a href=\"..\">..</a>\n          </td>\n        <td>Directory</td>\n        <td>-</td>\n        <td></td>\n      </tr>\n      {% endif -%}\n\n      {% for row in rows %}\n      <tr class=\"{{ row.tr_class }}\">\n        <td>\n          <a class=\"{{ row.a_class }}\" href=\"{{row.href}}\" {% if row.ofe_prefix %} data-ofe=\"{{row.ofe_prefix}}\" {% endif %} >\n              {{row.display_name}}\n          </a>\n          {%- if row.href_2 %}\n            <a class=\"{{ row.a_class_2 }}\" href=\"{{row.href_2}}\" {% if row.ofe_prefix_2%} data-ofe=\"{{row.ofe_prefix_2}}\" {% endif %} >\n                {{row.display_name_2}}\n            </a>\n          {% endif -%}\n          {%- if row.add_link_html %}\n              {{row.add_link_html | safe}}\n          {% endif -%}\n        </td>\n        <td>{{ row.display_type }}</td>\n        <td>{{ row.str_size }}</td>\n        <td>{{ row.str_modified }}</td>\n      </tr>\n      {% endfor %}\n    </tbody>\n  </table>\n\n  <hr>\n\n  {% if trailer %}\n  <p class=\"trailer\">{{ trailer | safe }}</p>\n  {% endif %}\n\n  <object id=\"winFirefoxPlugin\" type=\"application/x-sharepoint\"\n      width=\"0\" height=\"0\" style=\"visibility: hidden;\"></object>\n\n</body>\n</html>\n"], "filenames": ["wsgidav/dir_browser/_dir_browser.py", "wsgidav/dir_browser/htdocs/template.html"], "buggy_code_start_loc": [13, 84], "buggy_code_end_loc": [77, 99], "fixing_code_start_loc": [13, 84], "fixing_code_end_loc": [77, 99], "type": "CWE-79", "message": "WsgiDAV is a generic and extendable WebDAV server based on WSGI. Implementations using this library with directory browsing enabled may be susceptible to Cross Site Scripting (XSS) attacks. This issue has been patched, users can upgrade to version 4.1.0. As a workaround, set `dir_browser.enable = False` in the configuration.", "other": {"cve": {"id": "CVE-2022-41905", "sourceIdentifier": "security-advisories@github.com", "published": "2022-11-11T21:15:09.743", "lastModified": "2022-11-16T18:10:41.607", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "WsgiDAV is a generic and extendable WebDAV server based on WSGI. Implementations using this library with directory browsing enabled may be susceptible to Cross Site Scripting (XSS) attacks. This issue has been patched, users can upgrade to version 4.1.0. As a workaround, set `dir_browser.enable = False` in the configuration."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.7}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:C/C:H/I:H/A:N", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 8.2, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.8}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:wsgidav_project:wsgidav:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.0.0", "versionEndExcluding": "4.1.0", "matchCriteriaId": "A13F7E6A-3839-4247-ACA6-4544D45534CA"}]}]}], "references": [{"url": "https://github.com/mar10/wsgidav/commit/e9606ab0f42f4c1a6611bc3c52de299b0aba7726", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/mar10/wsgidav/security/advisories/GHSA-xx6g-jj35-pxjv", "source": "security-advisories@github.com", "tags": ["Mitigation", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/mar10/wsgidav/commit/e9606ab0f42f4c1a6611bc3c52de299b0aba7726"}}