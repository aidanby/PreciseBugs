{"buggy_code": ["<?php\n/*\n * SPDX-FileCopyrightText: 2010 Jaussoin Timoth\u00e9e\n * SPDX-License-Identifier: AGPL-3.0-or-later\n */\n\nnamespace Movim\\Daemon;\n\nuse Ratchet\\MessageComponentInterface;\nuse Ratchet\\ConnectionInterface;\n\nuse Dflydev\\FigCookies\\Cookies;\n\nuse Movim\\Daemon\\Session;\n\nuse App\\Session as DBSession;\nuse App\\EncryptedPassword;\nuse App\\PushSubscription;\nuse Minishlink\\WebPush\\VAPID;\n\nclass Core implements MessageComponentInterface\n{\n    public $sessions = [];\n    private $key; // Random key generate by the daemon to authenticate the internal Websockets\n\n    public $loop;\n    public $baseuri;\n\n    public $single = ['visio'];\n    public $singlelocks = [];\n\n    public function __construct($loop, $baseuri)\n    {\n        $this->key = \\generateKey(32);\n\n        $this->setWebsocket(config('daemon.port'));\n\n        $this->loop    = $loop;\n        $this->baseuri = $baseuri;\n\n        DBSession::whereNotNull('id')->delete();\n\n        // API_SOCKET ?\n        if (file_exists(CACHE_PATH . 'socketapi.sock')) {\n            unlink(CACHE_PATH . 'socketapi.sock');\n        }\n\n        array_map('unlink', array_merge(\n            glob(PUBLIC_CACHE_PATH . '*.css'),\n            glob(PUBLIC_CACHE_PATH . '*.js')\n        ));\n\n        $this->registerCleaner();\n\n        // Generate Push Notification\n        if (!file_exists(CACHE_PATH . 'vapid_keys.json')) {\n            echo colorize(\"Generate and store the Push Notification VAPID keys\", 'green') . \"\\n\";\n            $keyset = VAPID::createVapidKeys();\n            file_put_contents(CACHE_PATH . 'vapid_keys.json', json_encode($keyset));\n        }\n    }\n\n    public function setWebsocket($port)\n    {\n        echo\n        \"\\n\" .\n            \"--- \" . colorize(\"Server Configuration - Apache\", 'purple') . \" ---\" .\n            \"\\n\";\n        echo colorize(\"Enable the Secure WebSocket to WebSocket tunneling\", 'yellow') . \"\\n# a2enmod proxy_wstunnel \\n\";\n        echo colorize(\"Add this in your configuration file (default-ssl.conf)\", 'yellow') . \"\\nProxyPass /ws/ ws://127.0.0.1:{$port}/\\n\";\n\n        echo\n        \"\\n\" .\n            \"--- \" . colorize(\"Server Configuration - nginx\", 'purple') . \" ---\" .\n            \"\\n\";\n        echo colorize(\"Add this in your configuration file\", 'yellow') . \"\\n\";\n        echo \"location /ws/ {\n    proxy_pass http://127.0.0.1:{$port}/;\n    proxy_http_version 1.1;\n    proxy_set_header Upgrade \\$http_upgrade;\n    proxy_set_header Connection \\\"Upgrade\\\";\n    proxy_set_header Host \\$host;\n    proxy_set_header X-Real-IP \\$remote_addr;\n    proxy_set_header X-Forwarded-For \\$proxy_add_x_forwarded_for;\n    proxy_set_header X-Forwarded-Proto https;\n    proxy_redirect off;\n}\n\";\n\n        echo\n        \"\\n\" .\n            \"--- \" . colorize(\"Server Configuration - Caddy\", 'purple') . \" ---\" .\n            \"\\n\";\n        echo colorize(\"Add this in your configuration file\", 'yellow') . \"\\nhandle /ws/* {\n    reverse_proxy localhost:8080\n}\n\n\";\n    }\n\n    public function onOpen(ConnectionInterface $conn)\n    {\n        if (!$this->isTrustedConnection($conn)) $conn->close();\n\n        // WebSockets from the Browser\n        $sid = $this->getSid($conn);\n\n        if ($sid != null) {\n            $path = $this->getPath($conn);\n\n            if (in_array($path, $this->single)) {\n                if (\n                    array_key_exists($sid, $this->singlelocks)\n                    && array_key_exists($path, $this->singlelocks[$sid])\n                ) {\n                    $this->singlelocks[$sid][$path]++;\n                    $conn->close(1008);\n                } else {\n                    $this->singlelocks[$sid][$path] = 1;\n                }\n            }\n\n            if (!array_key_exists($sid, $this->sessions)) {\n                $language = $this->getLanguage($conn);\n                $offset = $this->getOffset($conn);\n\n                $this->sessions[$sid] = new Session(\n                    $this->loop,\n                    $sid,\n                    $this->baseuri,\n                    config('daemon.port'),\n                    $this->key,\n                    $language,\n                    $offset,\n                    config('daemon.verbose'),\n                    config('daemon.debug')\n                );\n            }\n\n            $this->sessions[$sid]->attach($conn);\n        } else {\n            // WebSocket from the internal subprocess\n            $sid = $this->getHeaderSid($conn);\n            if ($sid != null && isset($this->sessions[$sid])) {\n                $this->sessions[$sid]->attachInternal($conn);\n\n                $obj = new \\StdClass;\n                $obj->func = 'started';\n                $this->sessions[$sid]->messageOut(json_encode($obj));\n            }\n        }\n    }\n\n    public function onMessage(ConnectionInterface $from, $msg)\n    {\n        $sid = $this->getSid($from);\n        if ($sid != null && isset($this->sessions[$sid])) {\n            $this->sessions[$sid]->messageIn($msg);\n        } else {\n            $sid = $this->getHeaderSid($from);\n            if ($sid != null && isset($this->sessions[$sid])) {\n                $this->sessions[$sid]->messageOut($msg);\n            }\n        }\n    }\n\n    public function onClose(ConnectionInterface $conn)\n    {\n        $sid = $this->getSid($conn);\n\n        if ($sid != null && isset($this->sessions[$sid])) {\n            $path = $this->getPath($conn);\n\n            if (in_array($path, $this->single)) {\n                if (\n                    array_key_exists($sid, $this->singlelocks)\n                    && array_key_exists($path, $this->singlelocks[$sid])\n                ) {\n                    $this->singlelocks[$sid][$path]--;\n                    if ($this->singlelocks[$sid][$path] == 0) {\n                        unset($this->singlelocks[$sid][$path]);\n                    }\n                }\n            }\n\n            $this->sessions[$sid]->detach($this->loop, $conn);\n            if ($this->sessions[$sid]->process == null) {\n                unset($this->sessions[$sid]);\n            }\n        }\n\n        gc_collect_cycles();\n    }\n\n    public function forceClose($sid)\n    {\n        if (array_key_exists($sid, $this->sessions)) {\n            $this->sessions[$sid]->killLinker();\n            unset($this->sessions[$sid]);\n        }\n    }\n\n    private function registerCleaner()\n    {\n        $this->loop->addPeriodicTimer(5, function () {\n            foreach ($this->sessions as $sid => $session) {\n                if (\n                    $session->countClients() == 0\n                    && $session->registered == null\n                ) {\n                    $session->killLinker();\n                }\n\n                if ($session->process == null) {\n                    unset($this->sessions[$sid]);\n                }\n            }\n\n            $this->cleanupDBSessions();\n            $this->cleanupEncryptedPasswords();\n            $this->cleanupPushSubscriptions();\n        });\n    }\n\n    private function cleanupDBSessions()\n    {\n        DBSession::where('active', false)\n            ->where('created_at', '<', date(MOVIM_SQL_DATE, time() - 60))\n            ->delete();\n    }\n\n    /**\n     * @desc Delete push subscriptions without activity after a month\n     */\n    private function cleanupPushSubscriptions()\n    {\n        PushSubscription::where('activity_at', '<', date(MOVIM_SQL_DATE, time() - (60 * 60 * 24 * 30)))\n            ->delete();\n    }\n\n    /**\n     * @desc Delete encrypted passwords after 7 days without update\n     */\n    private function cleanupEncryptedPasswords()\n    {\n        EncryptedPassword::where('updated_at', '<', date(MOVIM_SQL_DATE, time() - (60 * 60 * 24 * 7)))\n            ->delete();\n    }\n\n    public function onError(ConnectionInterface $conn, \\Exception $e)\n    {\n        echo \"An error has occurred: {$e->getMessage()}\\n\";\n    }\n\n    public function getSessions()\n    {\n        return array_map(\n            fn ($session) => $session->started,\n            $this->sessions\n        );\n    }\n\n    public function getSession($sid)\n    {\n        if (isset($this->sessions[$sid])) {\n            return $this->sessions[$sid];\n        }\n    }\n\n    private function getLanguage(ConnectionInterface $conn)\n    {\n        $languages = $conn->httpRequest->getHeader('Accept-Language');\n        return (is_array($languages) && !empty($languages)) ? $languages[0] : false;\n    }\n\n    private function getOffset(ConnectionInterface $conn)\n    {\n        parse_str($conn->httpRequest->getUri()->getQuery(), $arr);\n        return (isset($arr['offset'])) ? invertSign(((int)$arr['offset']) * 60) : 0;\n    }\n\n    private function getPath(ConnectionInterface $conn)\n    {\n        parse_str($conn->httpRequest->getUri()->getQuery(), $arr);\n        return isset($arr['path']) ? $arr['path'] : false;\n    }\n\n    private function getSid(ConnectionInterface $conn)\n    {\n        $cookies = Cookies::fromRequest($conn->httpRequest);\n\n        return $cookies->get('MOVIM_SESSION_ID')\n            ? $cookies->get('MOVIM_SESSION_ID')->getValue()\n            : null;\n    }\n\n    private function getHeaderSid(ConnectionInterface $conn)\n    {\n        return ($conn->httpRequest->hasHeader('MOVIM_SESSION_ID'))\n            ? $conn->httpRequest->getHeader('MOVIM_SESSION_ID')[0]\n            : null;\n    }\n\n    private function isTrustedConnection(ConnectionInterface $conn): bool\n    {\n        $daemonKeyHeader = $conn->httpRequest->getHeader('MOVIM_DAEMON_KEY');\n        $secFetchSiteHeader = $conn->httpRequest->getHeader('Sec-Fetch-Site');\n\n        return (is_array($daemonKeyHeader) && !empty($daemonKeyHeader) && $daemonKeyHeader[0] === $this->key)\n            || (is_array($secFetchSiteHeader) && !empty($secFetchSiteHeader) && $secFetchSiteHeader[0] == 'same-origin');\n    }\n}\n"], "fixing_code": ["<?php\n/*\n * SPDX-FileCopyrightText: 2010 Jaussoin Timoth\u00e9e\n * SPDX-License-Identifier: AGPL-3.0-or-later\n */\n\nnamespace Movim\\Daemon;\n\nuse Ratchet\\MessageComponentInterface;\nuse Ratchet\\ConnectionInterface;\n\nuse Dflydev\\FigCookies\\Cookies;\n\nuse Movim\\Daemon\\Session;\n\nuse App\\Session as DBSession;\nuse App\\EncryptedPassword;\nuse App\\PushSubscription;\nuse Minishlink\\WebPush\\VAPID;\n\nclass Core implements MessageComponentInterface\n{\n    public $sessions = [];\n    private $key; // Random key generate by the daemon to authenticate the internal Websockets\n\n    public $loop;\n    public $baseuri;\n\n    public $single = ['visio'];\n    public $singlelocks = [];\n\n    public function __construct($loop, $baseuri)\n    {\n        $this->key = \\generateKey(32);\n\n        $this->setWebsocket(config('daemon.port'));\n\n        $this->loop    = $loop;\n        $this->baseuri = $baseuri;\n\n        DBSession::whereNotNull('id')->delete();\n\n        // API_SOCKET ?\n        if (file_exists(CACHE_PATH . 'socketapi.sock')) {\n            unlink(CACHE_PATH . 'socketapi.sock');\n        }\n\n        array_map('unlink', array_merge(\n            glob(PUBLIC_CACHE_PATH . '*.css'),\n            glob(PUBLIC_CACHE_PATH . '*.js')\n        ));\n\n        $this->registerCleaner();\n\n        // Generate Push Notification\n        if (!file_exists(CACHE_PATH . 'vapid_keys.json')) {\n            echo colorize(\"Generate and store the Push Notification VAPID keys\", 'green') . \"\\n\";\n            $keyset = VAPID::createVapidKeys();\n            file_put_contents(CACHE_PATH . 'vapid_keys.json', json_encode($keyset));\n        }\n    }\n\n    public function setWebsocket($port)\n    {\n        echo\n        \"\\n\" .\n            \"--- \" . colorize(\"Server Configuration - Apache\", 'purple') . \" ---\" .\n            \"\\n\";\n        echo colorize(\"Enable the Secure WebSocket to WebSocket tunneling\", 'yellow') . \"\\n# a2enmod proxy_wstunnel \\n\";\n        echo colorize(\"Add this in your configuration file (default-ssl.conf)\", 'yellow') . \"\\nProxyPass /ws/ ws://127.0.0.1:{$port}/\\n\";\n\n        echo\n        \"\\n\" .\n            \"--- \" . colorize(\"Server Configuration - nginx\", 'purple') . \" ---\" .\n            \"\\n\";\n        echo colorize(\"Add this in your configuration file\", 'yellow') . \"\\n\";\n        echo \"location /ws/ {\n    proxy_pass http://127.0.0.1:{$port}/;\n    proxy_http_version 1.1;\n    proxy_set_header Upgrade \\$http_upgrade;\n    proxy_set_header Connection \\\"Upgrade\\\";\n    proxy_set_header Host \\$host;\n    proxy_set_header X-Real-IP \\$remote_addr;\n    proxy_set_header X-Forwarded-For \\$proxy_add_x_forwarded_for;\n    proxy_set_header X-Forwarded-Proto https;\n    proxy_redirect off;\n}\n\";\n\n        echo\n        \"\\n\" .\n            \"--- \" . colorize(\"Server Configuration - Caddy\", 'purple') . \" ---\" .\n            \"\\n\";\n        echo colorize(\"Add this in your configuration file\", 'yellow') . \"\\nhandle /ws/* {\n    reverse_proxy localhost:8080\n}\n\n\";\n    }\n\n    public function onOpen(ConnectionInterface $conn)\n    {\n        if (!$this->isTrustedConnection($conn)) $conn->close();\n\n        // WebSockets from the Browser\n        $sid = $this->getSid($conn);\n\n        if ($sid != null) {\n            $path = $this->getPath($conn);\n\n            if (in_array($path, $this->single)) {\n                if (\n                    array_key_exists($sid, $this->singlelocks)\n                    && array_key_exists($path, $this->singlelocks[$sid])\n                ) {\n                    $this->singlelocks[$sid][$path]++;\n                    $conn->close(1008);\n                } else {\n                    $this->singlelocks[$sid][$path] = 1;\n                }\n            }\n\n            if (!array_key_exists($sid, $this->sessions)) {\n                $language = $this->getLanguage($conn);\n                $offset = $this->getOffset($conn);\n\n                $this->sessions[$sid] = new Session(\n                    $this->loop,\n                    $sid,\n                    $this->baseuri,\n                    config('daemon.port'),\n                    $this->key,\n                    $language,\n                    $offset,\n                    config('daemon.verbose'),\n                    config('daemon.debug')\n                );\n            }\n\n            $this->sessions[$sid]->attach($conn);\n        } else {\n            // WebSocket from the internal subprocess\n            $sid = $this->getHeaderSid($conn);\n            if ($sid != null && isset($this->sessions[$sid])) {\n                $this->sessions[$sid]->attachInternal($conn);\n\n                $obj = new \\StdClass;\n                $obj->func = 'started';\n                $this->sessions[$sid]->messageOut(json_encode($obj));\n            }\n        }\n    }\n\n    public function onMessage(ConnectionInterface $from, $msg)\n    {\n        $sid = $this->getSid($from);\n        if ($sid != null && isset($this->sessions[$sid])) {\n            $this->sessions[$sid]->messageIn($msg);\n        } else {\n            $sid = $this->getHeaderSid($from);\n            if ($sid != null && isset($this->sessions[$sid])) {\n                $this->sessions[$sid]->messageOut($msg);\n            }\n        }\n    }\n\n    public function onClose(ConnectionInterface $conn)\n    {\n        $sid = $this->getSid($conn);\n\n        if ($sid != null && isset($this->sessions[$sid])) {\n            $path = $this->getPath($conn);\n\n            if (in_array($path, $this->single)) {\n                if (\n                    array_key_exists($sid, $this->singlelocks)\n                    && array_key_exists($path, $this->singlelocks[$sid])\n                ) {\n                    $this->singlelocks[$sid][$path]--;\n                    if ($this->singlelocks[$sid][$path] == 0) {\n                        unset($this->singlelocks[$sid][$path]);\n                    }\n                }\n            }\n\n            $this->sessions[$sid]->detach($this->loop, $conn);\n            if ($this->sessions[$sid]->process == null) {\n                unset($this->sessions[$sid]);\n            }\n        }\n\n        gc_collect_cycles();\n    }\n\n    public function forceClose($sid)\n    {\n        if (array_key_exists($sid, $this->sessions)) {\n            $this->sessions[$sid]->killLinker();\n            unset($this->sessions[$sid]);\n        }\n    }\n\n    private function registerCleaner()\n    {\n        $this->loop->addPeriodicTimer(5, function () {\n            foreach ($this->sessions as $sid => $session) {\n                if (\n                    $session->countClients() == 0\n                    && $session->registered == null\n                ) {\n                    $session->killLinker();\n                }\n\n                if ($session->process == null) {\n                    unset($this->sessions[$sid]);\n                }\n            }\n\n            $this->cleanupDBSessions();\n            $this->cleanupEncryptedPasswords();\n            $this->cleanupPushSubscriptions();\n        });\n    }\n\n    private function cleanupDBSessions()\n    {\n        DBSession::where('active', false)\n            ->where('created_at', '<', date(MOVIM_SQL_DATE, time() - 60))\n            ->delete();\n    }\n\n    /**\n     * @desc Delete push subscriptions without activity after a month\n     */\n    private function cleanupPushSubscriptions()\n    {\n        PushSubscription::where('activity_at', '<', date(MOVIM_SQL_DATE, time() - (60 * 60 * 24 * 30)))\n            ->delete();\n    }\n\n    /**\n     * @desc Delete encrypted passwords after 7 days without update\n     */\n    private function cleanupEncryptedPasswords()\n    {\n        EncryptedPassword::where('updated_at', '<', date(MOVIM_SQL_DATE, time() - (60 * 60 * 24 * 7)))\n            ->delete();\n    }\n\n    public function onError(ConnectionInterface $conn, \\Exception $e)\n    {\n        echo \"An error has occurred: {$e->getMessage()}\\n\";\n    }\n\n    public function getSessions()\n    {\n        return array_map(\n            fn ($session) => $session->started,\n            $this->sessions\n        );\n    }\n\n    public function getSession($sid)\n    {\n        if (isset($this->sessions[$sid])) {\n            return $this->sessions[$sid];\n        }\n    }\n\n    private function getLanguage(ConnectionInterface $conn)\n    {\n        $languages = $conn->httpRequest->getHeader('Accept-Language');\n        return (is_array($languages) && !empty($languages)) ? $languages[0] : false;\n    }\n\n    private function getOffset(ConnectionInterface $conn)\n    {\n        parse_str($conn->httpRequest->getUri()->getQuery(), $arr);\n        return (isset($arr['offset'])) ? invertSign(((int)$arr['offset']) * 60) : 0;\n    }\n\n    private function getPath(ConnectionInterface $conn)\n    {\n        parse_str($conn->httpRequest->getUri()->getQuery(), $arr);\n        return isset($arr['path']) ? $arr['path'] : false;\n    }\n\n    private function getSid(ConnectionInterface $conn)\n    {\n        $cookies = Cookies::fromRequest($conn->httpRequest);\n\n        return $cookies->get('MOVIM_SESSION_ID')\n            ? $cookies->get('MOVIM_SESSION_ID')->getValue()\n            : null;\n    }\n\n    private function getHeaderSid(ConnectionInterface $conn)\n    {\n        return ($conn->httpRequest->hasHeader('MOVIM_SESSION_ID'))\n            ? $conn->httpRequest->getHeader('MOVIM_SESSION_ID')[0]\n            : null;\n    }\n\n    private function isTrustedConnection(ConnectionInterface $conn): bool\n    {\n        $daemonKeyHeader = $conn->httpRequest->getHeader('MOVIM_DAEMON_KEY');\n        $secFetchSiteHeader = $conn->httpRequest->getHeader('Sec-Fetch-Site');\n\n        $sameOrigin = (is_array($secFetchSiteHeader) && !empty($secFetchSiteHeader))\n            ? $secFetchSiteHeader[0] == 'same-origin'\n            : parse_url($conn->httpRequest->getHeader('Origin')[0], PHP_URL_HOST) == parse_url($this->baseuri, PHP_URL_HOST);\n\n        return (is_array($daemonKeyHeader) && !empty($daemonKeyHeader) && $daemonKeyHeader[0] === $this->key)\n            || $sameOrigin;\n    }\n}\n"], "filenames": ["src/Movim/Daemon/Core.php"], "buggy_code_start_loc": [308], "buggy_code_end_loc": [311], "fixing_code_start_loc": [309], "fixing_code_end_loc": [315], "type": "CWE-346", "message": "Movim prior to version 0.22 is affected by a Cross-Site WebSocket Hijacking vulnerability. This was the result of a missing header validation.", "other": {"cve": {"id": "CVE-2023-2848", "sourceIdentifier": "report@snyk.io", "published": "2023-09-14T12:15:07.737", "lastModified": "2023-09-20T15:08:13.750", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Movim prior to version 0.22 is affected by a Cross-Site WebSocket Hijacking vulnerability. This was the result of a missing header validation."}, {"lang": "es", "value": "Movim anterior a la versi\u00f3n 0.22 se ve afectado por una vulnerabilidad de Cross-Site WebSocket Hijacking. Este fue el resultado de una validaci\u00f3n de encabezado faltante."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}, {"source": "report@snyk.io", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:R/S:C/C:H/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 8.0, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.6, "impactScore": 5.8}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-346"}]}, {"source": "report@snyk.io", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-1385"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:movim:movim:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.22", "matchCriteriaId": "A1A64DAC-B509-400D-88DE-4726C3A0C9D9"}]}]}], "references": [{"url": "https://github.com/movim/movim/commit/49e2012aecdf918bb1d16f278fa9ff42fad29a9d", "source": "report@snyk.io", "tags": ["Patch"]}, {"url": "https://github.com/movim/movim/commit/96372082acd3e5d778a2522a60a1805bf2af31f6", "source": "report@snyk.io", "tags": ["Patch"]}, {"url": "https://mov.im/node/pubsub.movim.eu/Movim/a2d05925-0427-4f3f-b777-d20571ddddff", "source": "report@snyk.io", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/movim/movim/commit/49e2012aecdf918bb1d16f278fa9ff42fad29a9d"}}