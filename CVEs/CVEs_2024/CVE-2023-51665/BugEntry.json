{"buggy_code": ["const axios = require('axios')\nconst passport = require('passport')\nconst bcrypt = require('./libs/bcryptjs')\nconst jwt = require('./libs/jsonwebtoken')\nconst LocalStrategy = require('./libs/passportLocal')\nconst JwtStrategy = require('passport-jwt').Strategy\nconst ExtractJwt = require('passport-jwt').ExtractJwt\nconst OpenIDClient = require('openid-client')\nconst Database = require('./Database')\nconst Logger = require('./Logger')\nconst e = require('express')\n\n/**\n * @class Class for handling all the authentication related functionality.\n */\nclass Auth {\n\n  constructor() {\n    // Map of openId sessions indexed by oauth2 state-variable\n    this.openIdAuthSession = new Map()\n  }\n\n  /**\n   * Inializes all passportjs strategies and other passportjs ralated initialization.\n   */\n  async initPassportJs() {\n    // Check if we should load the local strategy (username + password login)\n    if (global.ServerSettings.authActiveAuthMethods.includes(\"local\")) {\n      this.initAuthStrategyPassword()\n    }\n\n    // Check if we should load the openid strategy\n    if (global.ServerSettings.authActiveAuthMethods.includes(\"openid\")) {\n      this.initAuthStrategyOpenID()\n    }\n\n    // Load the JwtStrategy (always) -> for bearer token auth \n    passport.use(new JwtStrategy({\n      jwtFromRequest: ExtractJwt.fromExtractors([ExtractJwt.fromAuthHeaderAsBearerToken(), ExtractJwt.fromUrlQueryParameter('token')]),\n      secretOrKey: Database.serverSettings.tokenSecret\n    }, this.jwtAuthCheck.bind(this)))\n\n    // define how to seralize a user (to be put into the session)\n    passport.serializeUser(function (user, cb) {\n      process.nextTick(function () {\n        // only store id to session\n        return cb(null, JSON.stringify({\n          id: user.id,\n        }))\n      })\n    })\n\n    // define how to deseralize a user (use the ID to get it from the database)\n    passport.deserializeUser((function (user, cb) {\n      process.nextTick((async function () {\n        const parsedUserInfo = JSON.parse(user)\n        // load the user by ID that is stored in the session\n        const dbUser = await Database.userModel.getUserById(parsedUserInfo.id)\n        return cb(null, dbUser)\n      }).bind(this))\n    }).bind(this))\n  }\n\n  /**\n   * Passport use LocalStrategy\n   */\n  initAuthStrategyPassword() {\n    passport.use(new LocalStrategy(this.localAuthCheckUserPw.bind(this)))\n  }\n\n  /**\n   * Passport use OpenIDClient.Strategy\n   */\n  initAuthStrategyOpenID() {\n    if (!Database.serverSettings.isOpenIDAuthSettingsValid) {\n      Logger.error(`[Auth] Cannot init openid auth strategy - invalid settings`)\n      return\n    }\n\n    const openIdIssuerClient = new OpenIDClient.Issuer({\n      issuer: global.ServerSettings.authOpenIDIssuerURL,\n      authorization_endpoint: global.ServerSettings.authOpenIDAuthorizationURL,\n      token_endpoint: global.ServerSettings.authOpenIDTokenURL,\n      userinfo_endpoint: global.ServerSettings.authOpenIDUserInfoURL,\n      jwks_uri: global.ServerSettings.authOpenIDJwksURL\n    }).Client\n    const openIdClient = new openIdIssuerClient({\n      client_id: global.ServerSettings.authOpenIDClientID,\n      client_secret: global.ServerSettings.authOpenIDClientSecret\n    })\n    passport.use('openid-client', new OpenIDClient.Strategy({\n      client: openIdClient,\n      params: {\n        redirect_uri: '/auth/openid/callback',\n        scope: 'openid profile email'\n      }\n    }, async (tokenset, userinfo, done) => {\n      Logger.debug(`[Auth] openid callback userinfo=`, userinfo)\n\n      let failureMessage = 'Unauthorized'\n      if (!userinfo.sub) {\n        Logger.error(`[Auth] openid callback invalid userinfo, no sub`)\n        return done(null, null, failureMessage)\n      }\n\n      // First check for matching user by sub\n      let user = await Database.userModel.getUserByOpenIDSub(userinfo.sub)\n      if (!user) {\n        // Optionally match existing by email or username based on server setting \"authOpenIDMatchExistingBy\"\n        if (Database.serverSettings.authOpenIDMatchExistingBy === 'email' && userinfo.email && userinfo.email_verified) {\n          Logger.info(`[Auth] openid: User not found, checking existing with email \"${userinfo.email}\"`)\n          user = await Database.userModel.getUserByEmail(userinfo.email)\n          // Check that user is not already matched\n          if (user?.authOpenIDSub) {\n            Logger.warn(`[Auth] openid: User found with email \"${userinfo.email}\" but is already matched with sub \"${user.authOpenIDSub}\"`)\n            // TODO: Message isn't actually returned to the user yet. Need to override the passport authenticated callback\n            failureMessage = 'A matching user was found but is already matched with another user from your auth provider'\n            user = null\n          }\n        } else if (Database.serverSettings.authOpenIDMatchExistingBy === 'username' && userinfo.preferred_username) {\n          Logger.info(`[Auth] openid: User not found, checking existing with username \"${userinfo.preferred_username}\"`)\n          user = await Database.userModel.getUserByUsername(userinfo.preferred_username)\n          // Check that user is not already matched\n          if (user?.authOpenIDSub) {\n            Logger.warn(`[Auth] openid: User found with username \"${userinfo.preferred_username}\" but is already matched with sub \"${user.authOpenIDSub}\"`)\n            // TODO: Message isn't actually returned to the user yet. Need to override the passport authenticated callback\n            failureMessage = 'A matching user was found but is already matched with another user from your auth provider'\n            user = null\n          }\n        }\n\n        // If existing user was matched and isActive then save sub to user\n        if (user?.isActive) {\n          Logger.info(`[Auth] openid: New user found matching existing user \"${user.username}\"`)\n          user.authOpenIDSub = userinfo.sub\n          await Database.userModel.updateFromOld(user)\n        } else if (user && !user.isActive) {\n          Logger.warn(`[Auth] openid: New user found matching existing user \"${user.username}\" but that user is deactivated`)\n        }\n\n        // Optionally auto register the user \n        if (!user && Database.serverSettings.authOpenIDAutoRegister) {\n          Logger.info(`[Auth] openid: Auto-registering user with sub \"${userinfo.sub}\"`, userinfo)\n          user = await Database.userModel.createUserFromOpenIdUserInfo(userinfo, this)\n        }\n      }\n\n      if (!user?.isActive) {\n        if (user && !user.isActive) {\n          failureMessage = 'Unauthorized'\n        }\n        // deny login\n        done(null, null, failureMessage)\n        return\n      }\n\n      // permit login\n      return done(null, user)\n    }))\n  }\n\n  /**\n   * Unuse strategy\n   * \n   * @param {string} name \n   */\n  unuseAuthStrategy(name) {\n    passport.unuse(name)\n  }\n\n  /**\n   * Use strategy\n   * \n   * @param {string} name \n   */\n  useAuthStrategy(name) {\n    if (name === 'openid') {\n      this.initAuthStrategyOpenID()\n    } else if (name === 'local') {\n      this.initAuthStrategyPassword()\n    } else {\n      Logger.error('[Auth] Invalid auth strategy ' + name)\n    }\n  }\n\n  /**\n   * Stores the client's choice how the login callback should happen in temp cookies\n   * \n   * @param {import('express').Request} req\n   * @param {import('express').Response} res\n   */\n  paramsToCookies(req, res) {\n    // Set if isRest flag is set or if mobile oauth flow is used\n    if (req.query.isRest?.toLowerCase() == 'true' || req.query.redirect_uri) {\n      // store the isRest flag to the is_rest cookie \n      res.cookie('is_rest', 'true', {\n        maxAge: 120000, // 2 min\n        httpOnly: true\n      })\n    } else {\n      // no isRest-flag set -> set is_rest cookie to false\n      res.cookie('is_rest', 'false', {\n        maxAge: 120000, // 2 min\n        httpOnly: true\n      })\n\n      // persist state if passed in\n      if (req.query.state) {\n        res.cookie('auth_state', req.query.state, {\n          maxAge: 120000, // 2 min\n          httpOnly: true\n        })\n      }\n\n      const callback = req.query.redirect_uri || req.query.callback\n\n      // check if we are missing a callback parameter - we need one if isRest=false\n      if (!callback) {\n        res.status(400).send({\n          message: 'No callback parameter'\n        })\n        return\n      }\n      // store the callback url to the auth_cb cookie \n      res.cookie('auth_cb', callback, {\n        maxAge: 120000, // 2 min\n        httpOnly: true\n      })\n    }\n  }\n\n  /**\n   * Informs the client in the right mode about a successfull login and the token\n   * (clients choise is restored from cookies).\n   * \n   * @param {import('express').Request} req\n   * @param {import('express').Response} res\n   */\n  async handleLoginSuccessBasedOnCookie(req, res) {\n    // get userLogin json (information about the user, server and the session)\n    const data_json = await this.getUserLoginResponsePayload(req.user)\n\n    if (req.cookies.is_rest === 'true') {\n      // REST request - send data\n      res.json(data_json)\n    } else {\n      // UI request -> check if we have a callback url\n      // TODO: do we want to somehow limit the values for auth_cb?\n      if (req.cookies.auth_cb) {\n        let stateQuery = req.cookies.auth_state ? `&state=${req.cookies.auth_state}` : ''\n        // UI request -> redirect to auth_cb url and send the jwt token as parameter\n        res.redirect(302, `${req.cookies.auth_cb}?setToken=${data_json.user.token}${stateQuery}`)\n      } else {\n        res.status(400).send('No callback or already expired')\n      }\n    }\n  }\n\n  /**\n   * Creates all (express) routes required for authentication.\n   * \n   * @param {import('express').Router} router \n   */\n  async initAuthRoutes(router) {\n    // Local strategy login route (takes username and password)\n    router.post('/login', passport.authenticate('local'), async (req, res) => {\n      // return the user login response json if the login was successfull\n      res.json(await this.getUserLoginResponsePayload(req.user))\n    })\n\n    // openid strategy login route (this redirects to the configured openid login provider)\n    router.get('/auth/openid', (req, res, next) => {\n      try {\n        // helper function from openid-client\n        function pick(object, ...paths) {\n          const obj = {}\n          for (const path of paths) {\n            if (object[path] !== undefined) {\n              obj[path] = object[path]\n            }\n          }\n          return obj\n        }\n\n        // Get the OIDC client from the strategy\n        // We need to call the client manually, because the strategy does not support forwarding the code challenge\n        //    for API or mobile clients\n        const oidcStrategy = passport._strategy('openid-client')\n        const protocol = (req.secure || req.get('x-forwarded-proto') === 'https') ? 'https' : 'http'\n\n        let mobile_redirect_uri = null\n\n        // The client wishes a different redirect_uri\n        // We will allow if it is in the whitelist, by saving it into this.openIdAuthSession and setting the redirect uri to /auth/openid/mobile-redirect\n        //    where we will handle the redirect to it\n        if (req.query.redirect_uri) {\n          // Check if the redirect_uri is in the whitelist\n          if (Database.serverSettings.authOpenIDMobileRedirectURIs.includes(req.query.redirect_uri) ||\n           (Database.serverSettings.authOpenIDMobileRedirectURIs.length === 1 && Database.serverSettings.authOpenIDMobileRedirectURIs[0] === '*')) {\n            oidcStrategy._params.redirect_uri = new URL(`${protocol}://${req.get('host')}/auth/openid/mobile-redirect`).toString()\n            mobile_redirect_uri = req.query.redirect_uri\n          } else {\n            Logger.debug(`[Auth] Invalid redirect_uri=${req.query.redirect_uri} - not in whitelist`)\n            return res.status(400).send('Invalid redirect_uri')\n          }\n        } else {\n          oidcStrategy._params.redirect_uri = new URL(`${protocol}://${req.get('host')}/auth/openid/callback`).toString()\n        }\n\n        Logger.debug(`[Auth] Oidc redirect_uri=${oidcStrategy._params.redirect_uri}`)\n        const client = oidcStrategy._client\n        const sessionKey = oidcStrategy._key\n\n        let code_challenge\n        let code_challenge_method\n\n        // If code_challenge is provided, expect that code_verifier will be handled by the client (mobile app)\n        // The web frontend of ABS does not need to do a PKCE itself, because it never handles the \"code\" of the oauth flow\n        //    and as such will not send a code challenge, we will generate then one\n        if (req.query.code_challenge) {\n          code_challenge = req.query.code_challenge\n          code_challenge_method = req.query.code_challenge_method || 'S256'\n\n          if (!['S256', 'plain'].includes(code_challenge_method)) {\n            return res.status(400).send('Invalid code_challenge_method')\n          }\n        } else {\n          // If no code_challenge is provided, assume a web application flow and generate one\n          const code_verifier = OpenIDClient.generators.codeVerifier()\n          code_challenge = OpenIDClient.generators.codeChallenge(code_verifier)\n          code_challenge_method = 'S256'\n\n          // Store the code_verifier in the session for later use in the token exchange\n          req.session[sessionKey] = { ...req.session[sessionKey], code_verifier }\n        }\n\n        const params = {\n          state: OpenIDClient.generators.random(),\n          // Other params by the passport strategy\n          ...oidcStrategy._params\n        }\n\n        if (!params.nonce && params.response_type.includes('id_token')) {\n          params.nonce = OpenIDClient.generators.random()\n        }\n\n        req.session[sessionKey] = {\n          ...req.session[sessionKey],\n          ...pick(params, 'nonce', 'state', 'max_age', 'response_type'),\n          mobile: req.query.redirect_uri, // Used in the abs callback later, set mobile if redirect_uri is filled out\n          sso_redirect_uri: oidcStrategy._params.redirect_uri // Save the redirect_uri (for the SSO Provider) for the callback\n        }\n\n        // We cannot save redirect_uri in the session, because it the mobile client uses browser instead of the API\n        //   for the request to mobile-redirect and as such the session is not shared\n        this.openIdAuthSession.set(params.state, { mobile_redirect_uri: mobile_redirect_uri })\n\n        // Now get the URL to direct to\n        const authorizationUrl = client.authorizationUrl({\n          ...params,\n          scope: 'openid profile email',\n          response_type: 'code',\n          code_challenge,\n          code_challenge_method\n        })\n\n        // params (isRest, callback) to a cookie that will be send to the client\n        this.paramsToCookies(req, res)\n\n        // Redirect the user agent (browser) to the authorization URL\n        res.redirect(authorizationUrl)\n      } catch (error) {\n        Logger.error(`[Auth] Error in /auth/openid route: ${error}`)\n        res.status(500).send('Internal Server Error')\n      }\n    })\n\n    // This will be the oauth2 callback route for mobile clients\n    // It will redirect to an app-link like audiobookshelf://oauth\n    router.get('/auth/openid/mobile-redirect', (req, res) => {\n      try {\n        // Extract the state parameter from the request\n        const { state, code } = req.query\n    \n        // Check if the state provided is in our list\n        if (!state || !this.openIdAuthSession.has(state)) {\n          Logger.error('[Auth] /auth/openid/mobile-redirect route: State parameter mismatch')\n          return res.status(400).send('State parameter mismatch')\n        }\n\n        let mobile_redirect_uri = this.openIdAuthSession.get(state).mobile_redirect_uri\n\n        if (!mobile_redirect_uri) {\n          Logger.error('[Auth] No redirect URI')\n          return res.status(400).send('No redirect URI')\n        }\n\n        this.openIdAuthSession.delete(state)\n\n        const redirectUri = `${mobile_redirect_uri}?code=${encodeURIComponent(code)}&state=${encodeURIComponent(state)}`\n        // Redirect to the overwrite URI saved in the map\n        res.redirect(redirectUri)\n      } catch (error) {\n        Logger.error(`[Auth] Error in /auth/openid/mobile-redirect route: ${error}`)\n        res.status(500).send('Internal Server Error')\n      }\n    })\n\n    // openid strategy callback route (this receives the token from the configured openid login provider)\n    router.get('/auth/openid/callback', (req, res, next) => {\n      const oidcStrategy = passport._strategy('openid-client')\n      const sessionKey = oidcStrategy._key\n\n      if (!req.session[sessionKey]) {\n        return res.status(400).send('No session')\n      }\n\n      // If the client sends us a code_verifier, we will tell passport to use this to send this in the token request\n      // The code_verifier will be validated by the oauth2 provider by comparing it to the code_challenge in the first request\n      // Crucial for API/Mobile clients\n      if (req.query.code_verifier) {\n        req.session[sessionKey].code_verifier = req.query.code_verifier\n      }\n\n      function handleAuthError(isMobile, errorCode, errorMessage, logMessage, response) {\n        Logger.error(logMessage)\n        if (response) {\n          // Depending on the error, it can also have a body\n          // We also log the request header the passport plugin sents for the URL\n          const header = response.req?._header.replace(/Authorization: [^\\r\\n]*/i, 'Authorization: REDACTED')\n          Logger.debug(header + '\\n' + response.body?.toString())\n        }\n\n        if (isMobile) {\n          return res.status(errorCode).send(errorMessage)\n        } else {\n          return res.redirect(`/login?error=${encodeURIComponent(errorMessage)}&autoLaunch=0`)\n        }\n      }\n\n      function passportCallback(req, res, next) {\n        return (err, user, info) => {\n          const isMobile = req.session[sessionKey]?.mobile === true\n          if (err) {\n            return handleAuthError(isMobile, 500, 'Error in callback', `[Auth] Error in openid callback - ${err}`, err?.response)\n          }\n\n          if (!user) {\n            // Info usually contains the error message from the SSO provider\n            return handleAuthError(isMobile, 401, 'Unauthorized', `[Auth] No data in openid callback - ${info}`, info?.response)\n          }\n\n          req.logIn(user, (loginError) => {\n            if (loginError) {\n              return handleAuthError(isMobile, 500, 'Error during login', `[Auth] Error in openid callback: ${loginError}`)\n            }\n            next()\n          })\n        }\n      }\n\n\n      // While not required by the standard, the passport plugin re-sends the original redirect_uri in the token request\n      // We need to set it correctly, as some SSO providers (e.g. keycloak) check that parameter when it is provided\n      // We set it here again because the passport param can change between requests\n      return passport.authenticate('openid-client', { redirect_uri: req.session[sessionKey].sso_redirect_uri }, passportCallback(req, res, next))(req, res, next)\n    },\n      // on a successfull login: read the cookies and react like the client requested (callback or json)\n      this.handleLoginSuccessBasedOnCookie.bind(this))\n\n    /**\n     * Used to auto-populate the openid URLs in config/authentication\n     */\n    router.get('/auth/openid/config', async (req, res) => {\n      if (!req.query.issuer) {\n        return res.status(400).send('Invalid request. Query param \\'issuer\\' is required')\n      }\n      let issuerUrl = req.query.issuer\n      if (issuerUrl.endsWith('/')) issuerUrl = issuerUrl.slice(0, -1)\n\n      const configUrl = `${issuerUrl}/.well-known/openid-configuration`\n      axios.get(configUrl).then(({ data }) => {\n        res.json({\n          issuer: data.issuer,\n          authorization_endpoint: data.authorization_endpoint,\n          token_endpoint: data.token_endpoint,\n          userinfo_endpoint: data.userinfo_endpoint,\n          end_session_endpoint: data.end_session_endpoint,\n          jwks_uri: data.jwks_uri\n        })\n      }).catch((error) => {\n        Logger.error(`[Auth] Failed to get openid configuration at \"${configUrl}\"`, error)\n        res.status(error.statusCode || 400).send(`${error.code || 'UNKNOWN'}: Failed to get openid configuration`)\n      })\n    })\n\n    // Logout route\n    router.post('/logout', (req, res) => {\n      // TODO: invalidate possible JWTs\n      req.logout((err) => {\n        if (err) {\n          res.sendStatus(500)\n        } else {\n          res.sendStatus(200)\n        }\n      })\n    })\n  }\n\n  /**\n   * middleware to use in express to only allow authenticated users.\n   * @param {import('express').Request} req \n   * @param {import('express').Response} res \n   * @param {import('express').NextFunction} next  \n   */\n  isAuthenticated(req, res, next) {\n    // check if session cookie says that we are authenticated\n    if (req.isAuthenticated()) {\n      next()\n    } else {\n      // try JWT to authenticate\n      passport.authenticate(\"jwt\")(req, res, next)\n    }\n  }\n\n  /**\n   * Function to generate a jwt token for a given user\n   * \n   * @param {{ id:string, username:string }} user \n   * @returns {string} token\n   */\n  generateAccessToken(user) {\n    return jwt.sign({ userId: user.id, username: user.username }, global.ServerSettings.tokenSecret)\n  }\n\n  /**\n   * Function to validate a jwt token for a given user\n   * \n   * @param {string} token \n   * @returns {Object} tokens data\n   */\n  static validateAccessToken(token) {\n    try {\n      return jwt.verify(token, global.ServerSettings.tokenSecret)\n    }\n    catch (err) {\n      return null\n    }\n  }\n\n  /**\n   * Generate a token which is used to encrpt/protect the jwts.\n   */\n  async initTokenSecret() {\n    if (process.env.TOKEN_SECRET) { // User can supply their own token secret\n      Database.serverSettings.tokenSecret = process.env.TOKEN_SECRET\n    } else {\n      Database.serverSettings.tokenSecret = require('crypto').randomBytes(256).toString('base64')\n    }\n    await Database.updateServerSettings()\n\n    // New token secret creation added in v2.1.0 so generate new API tokens for each user\n    const users = await Database.userModel.getOldUsers()\n    if (users.length) {\n      for (const user of users) {\n        user.token = await this.generateAccessToken(user)\n      }\n      await Database.updateBulkUsers(users)\n    }\n  }\n\n  /**\n   * Checks if the user in the validated jwt_payload really exists and is active.\n   * @param {Object} jwt_payload \n   * @param {function} done \n   */\n  async jwtAuthCheck(jwt_payload, done) {\n    // load user by id from the jwt token\n    const user = await Database.userModel.getUserByIdOrOldId(jwt_payload.userId)\n\n    if (!user?.isActive) {\n      // deny login\n      done(null, null)\n      return\n    }\n    // approve login\n    done(null, user)\n    return\n  }\n\n  /**\n   * Checks if a username and password tuple is valid and the user active.\n   * @param {string} username \n   * @param {string} password \n   * @param {function} done \n   */\n  async localAuthCheckUserPw(username, password, done) {\n    // Load the user given it's username\n    const user = await Database.userModel.getUserByUsername(username.toLowerCase())\n\n    if (!user?.isActive) {\n      done(null, null)\n      return\n    }\n\n    // Check passwordless root user\n    if (user.type === 'root' && !user.pash) {\n      if (password) {\n        // deny login\n        done(null, null)\n        return\n      }\n      // approve login\n      done(null, user)\n      return\n    } else if (!user.pash) {\n      Logger.error(`[Auth] User \"${user.username}\"/\"${user.type}\" attempted to login without a password set`)\n      done(null, null)\n      return\n    }\n\n    // Check password match\n    const compare = await bcrypt.compare(password, user.pash)\n    if (compare) {\n      // approve login\n      done(null, user)\n      return\n    }\n    // deny login\n    done(null, null)\n    return\n  }\n\n  /**\n   * Hashes a password with bcrypt.\n   * @param {string} password \n   * @returns {string} hash \n   */\n  hashPass(password) {\n    return new Promise((resolve) => {\n      bcrypt.hash(password, 8, (err, hash) => {\n        if (err) {\n          resolve(null)\n        } else {\n          resolve(hash)\n        }\n      })\n    })\n  }\n\n  /**\n   * Return the login info payload for a user\n   * \n   * @param {Object} user \n   * @returns {Promise<Object>} jsonPayload\n   */\n  async getUserLoginResponsePayload(user) {\n    const libraryIds = await Database.libraryModel.getAllLibraryIds()\n    return {\n      user: user.toJSONForBrowser(),\n      userDefaultLibraryId: user.getDefaultLibraryId(libraryIds),\n      serverSettings: Database.serverSettings.toJSONForBrowser(),\n      ereaderDevices: Database.emailSettings.getEReaderDevices(user),\n      Source: global.Source\n    }\n  }\n\n  /**\n   * \n   * @param {string} password \n   * @param {*} user \n   * @returns {boolean}\n   */\n  comparePassword(password, user) {\n    if (user.type === 'root' && !password && !user.pash) return true\n    if (!password || !user.pash) return false\n    return bcrypt.compare(password, user.pash)\n  }\n\n  /**\n   * User changes their password from request\n   * \n   * @param {import('express').Request} req \n   * @param {import('express').Response} res \n   */\n  async userChangePassword(req, res) {\n    let { password, newPassword } = req.body\n    newPassword = newPassword || ''\n    const matchingUser = req.user\n\n    // Only root can have an empty password\n    if (matchingUser.type !== 'root' && !newPassword) {\n      return res.json({\n        error: 'Invalid new password - Only root can have an empty password'\n      })\n    }\n\n    // Check password match\n    const compare = await this.comparePassword(password, matchingUser)\n    if (!compare) {\n      return res.json({\n        error: 'Invalid password'\n      })\n    }\n\n    let pw = ''\n    if (newPassword) {\n      pw = await this.hashPass(newPassword)\n      if (!pw) {\n        return res.json({\n          error: 'Hash failed'\n        })\n      }\n    }\n\n    matchingUser.pash = pw\n\n    const success = await Database.updateUser(matchingUser)\n    if (success) {\n      Logger.info(`[Auth] User \"${matchingUser.username}\" changed password`)\n      res.json({\n        success: true\n      })\n    } else {\n      res.json({\n        error: 'Unknown error'\n      })\n    }\n  }\n}\n\nmodule.exports = Auth"], "fixing_code": ["const axios = require('axios')\nconst passport = require('passport')\nconst bcrypt = require('./libs/bcryptjs')\nconst jwt = require('./libs/jsonwebtoken')\nconst LocalStrategy = require('./libs/passportLocal')\nconst JwtStrategy = require('passport-jwt').Strategy\nconst ExtractJwt = require('passport-jwt').ExtractJwt\nconst OpenIDClient = require('openid-client')\nconst Database = require('./Database')\nconst Logger = require('./Logger')\nconst e = require('express')\n\n/**\n * @class Class for handling all the authentication related functionality.\n */\nclass Auth {\n\n  constructor() {\n    // Map of openId sessions indexed by oauth2 state-variable\n    this.openIdAuthSession = new Map()\n  }\n\n  /**\n   * Inializes all passportjs strategies and other passportjs ralated initialization.\n   */\n  async initPassportJs() {\n    // Check if we should load the local strategy (username + password login)\n    if (global.ServerSettings.authActiveAuthMethods.includes(\"local\")) {\n      this.initAuthStrategyPassword()\n    }\n\n    // Check if we should load the openid strategy\n    if (global.ServerSettings.authActiveAuthMethods.includes(\"openid\")) {\n      this.initAuthStrategyOpenID()\n    }\n\n    // Load the JwtStrategy (always) -> for bearer token auth \n    passport.use(new JwtStrategy({\n      jwtFromRequest: ExtractJwt.fromExtractors([ExtractJwt.fromAuthHeaderAsBearerToken(), ExtractJwt.fromUrlQueryParameter('token')]),\n      secretOrKey: Database.serverSettings.tokenSecret\n    }, this.jwtAuthCheck.bind(this)))\n\n    // define how to seralize a user (to be put into the session)\n    passport.serializeUser(function (user, cb) {\n      process.nextTick(function () {\n        // only store id to session\n        return cb(null, JSON.stringify({\n          id: user.id,\n        }))\n      })\n    })\n\n    // define how to deseralize a user (use the ID to get it from the database)\n    passport.deserializeUser((function (user, cb) {\n      process.nextTick((async function () {\n        const parsedUserInfo = JSON.parse(user)\n        // load the user by ID that is stored in the session\n        const dbUser = await Database.userModel.getUserById(parsedUserInfo.id)\n        return cb(null, dbUser)\n      }).bind(this))\n    }).bind(this))\n  }\n\n  /**\n   * Passport use LocalStrategy\n   */\n  initAuthStrategyPassword() {\n    passport.use(new LocalStrategy(this.localAuthCheckUserPw.bind(this)))\n  }\n\n  /**\n   * Passport use OpenIDClient.Strategy\n   */\n  initAuthStrategyOpenID() {\n    if (!Database.serverSettings.isOpenIDAuthSettingsValid) {\n      Logger.error(`[Auth] Cannot init openid auth strategy - invalid settings`)\n      return\n    }\n\n    const openIdIssuerClient = new OpenIDClient.Issuer({\n      issuer: global.ServerSettings.authOpenIDIssuerURL,\n      authorization_endpoint: global.ServerSettings.authOpenIDAuthorizationURL,\n      token_endpoint: global.ServerSettings.authOpenIDTokenURL,\n      userinfo_endpoint: global.ServerSettings.authOpenIDUserInfoURL,\n      jwks_uri: global.ServerSettings.authOpenIDJwksURL\n    }).Client\n    const openIdClient = new openIdIssuerClient({\n      client_id: global.ServerSettings.authOpenIDClientID,\n      client_secret: global.ServerSettings.authOpenIDClientSecret\n    })\n    passport.use('openid-client', new OpenIDClient.Strategy({\n      client: openIdClient,\n      params: {\n        redirect_uri: '/auth/openid/callback',\n        scope: 'openid profile email'\n      }\n    }, async (tokenset, userinfo, done) => {\n      Logger.debug(`[Auth] openid callback userinfo=`, userinfo)\n\n      let failureMessage = 'Unauthorized'\n      if (!userinfo.sub) {\n        Logger.error(`[Auth] openid callback invalid userinfo, no sub`)\n        return done(null, null, failureMessage)\n      }\n\n      // First check for matching user by sub\n      let user = await Database.userModel.getUserByOpenIDSub(userinfo.sub)\n      if (!user) {\n        // Optionally match existing by email or username based on server setting \"authOpenIDMatchExistingBy\"\n        if (Database.serverSettings.authOpenIDMatchExistingBy === 'email' && userinfo.email && userinfo.email_verified) {\n          Logger.info(`[Auth] openid: User not found, checking existing with email \"${userinfo.email}\"`)\n          user = await Database.userModel.getUserByEmail(userinfo.email)\n          // Check that user is not already matched\n          if (user?.authOpenIDSub) {\n            Logger.warn(`[Auth] openid: User found with email \"${userinfo.email}\" but is already matched with sub \"${user.authOpenIDSub}\"`)\n            // TODO: Message isn't actually returned to the user yet. Need to override the passport authenticated callback\n            failureMessage = 'A matching user was found but is already matched with another user from your auth provider'\n            user = null\n          }\n        } else if (Database.serverSettings.authOpenIDMatchExistingBy === 'username' && userinfo.preferred_username) {\n          Logger.info(`[Auth] openid: User not found, checking existing with username \"${userinfo.preferred_username}\"`)\n          user = await Database.userModel.getUserByUsername(userinfo.preferred_username)\n          // Check that user is not already matched\n          if (user?.authOpenIDSub) {\n            Logger.warn(`[Auth] openid: User found with username \"${userinfo.preferred_username}\" but is already matched with sub \"${user.authOpenIDSub}\"`)\n            // TODO: Message isn't actually returned to the user yet. Need to override the passport authenticated callback\n            failureMessage = 'A matching user was found but is already matched with another user from your auth provider'\n            user = null\n          }\n        }\n\n        // If existing user was matched and isActive then save sub to user\n        if (user?.isActive) {\n          Logger.info(`[Auth] openid: New user found matching existing user \"${user.username}\"`)\n          user.authOpenIDSub = userinfo.sub\n          await Database.userModel.updateFromOld(user)\n        } else if (user && !user.isActive) {\n          Logger.warn(`[Auth] openid: New user found matching existing user \"${user.username}\" but that user is deactivated`)\n        }\n\n        // Optionally auto register the user \n        if (!user && Database.serverSettings.authOpenIDAutoRegister) {\n          Logger.info(`[Auth] openid: Auto-registering user with sub \"${userinfo.sub}\"`, userinfo)\n          user = await Database.userModel.createUserFromOpenIdUserInfo(userinfo, this)\n        }\n      }\n\n      if (!user?.isActive) {\n        if (user && !user.isActive) {\n          failureMessage = 'Unauthorized'\n        }\n        // deny login\n        done(null, null, failureMessage)\n        return\n      }\n\n      // permit login\n      return done(null, user)\n    }))\n  }\n\n  /**\n   * Unuse strategy\n   * \n   * @param {string} name \n   */\n  unuseAuthStrategy(name) {\n    passport.unuse(name)\n  }\n\n  /**\n   * Use strategy\n   * \n   * @param {string} name \n   */\n  useAuthStrategy(name) {\n    if (name === 'openid') {\n      this.initAuthStrategyOpenID()\n    } else if (name === 'local') {\n      this.initAuthStrategyPassword()\n    } else {\n      Logger.error('[Auth] Invalid auth strategy ' + name)\n    }\n  }\n\n  /**\n   * Stores the client's choice how the login callback should happen in temp cookies\n   * \n   * @param {import('express').Request} req\n   * @param {import('express').Response} res\n   */\n  paramsToCookies(req, res) {\n    // Set if isRest flag is set or if mobile oauth flow is used\n    if (req.query.isRest?.toLowerCase() == 'true' || req.query.redirect_uri) {\n      // store the isRest flag to the is_rest cookie \n      res.cookie('is_rest', 'true', {\n        maxAge: 120000, // 2 min\n        httpOnly: true\n      })\n    } else {\n      // no isRest-flag set -> set is_rest cookie to false\n      res.cookie('is_rest', 'false', {\n        maxAge: 120000, // 2 min\n        httpOnly: true\n      })\n\n      // persist state if passed in\n      if (req.query.state) {\n        res.cookie('auth_state', req.query.state, {\n          maxAge: 120000, // 2 min\n          httpOnly: true\n        })\n      }\n\n      const callback = req.query.redirect_uri || req.query.callback\n\n      // check if we are missing a callback parameter - we need one if isRest=false\n      if (!callback) {\n        res.status(400).send({\n          message: 'No callback parameter'\n        })\n        return\n      }\n      // store the callback url to the auth_cb cookie \n      res.cookie('auth_cb', callback, {\n        maxAge: 120000, // 2 min\n        httpOnly: true\n      })\n    }\n  }\n\n  /**\n   * Informs the client in the right mode about a successfull login and the token\n   * (clients choise is restored from cookies).\n   * \n   * @param {import('express').Request} req\n   * @param {import('express').Response} res\n   */\n  async handleLoginSuccessBasedOnCookie(req, res) {\n    // get userLogin json (information about the user, server and the session)\n    const data_json = await this.getUserLoginResponsePayload(req.user)\n\n    if (req.cookies.is_rest === 'true') {\n      // REST request - send data\n      res.json(data_json)\n    } else {\n      // UI request -> check if we have a callback url\n      // TODO: do we want to somehow limit the values for auth_cb?\n      if (req.cookies.auth_cb) {\n        let stateQuery = req.cookies.auth_state ? `&state=${req.cookies.auth_state}` : ''\n        // UI request -> redirect to auth_cb url and send the jwt token as parameter\n        res.redirect(302, `${req.cookies.auth_cb}?setToken=${data_json.user.token}${stateQuery}`)\n      } else {\n        res.status(400).send('No callback or already expired')\n      }\n    }\n  }\n\n  /**\n   * Creates all (express) routes required for authentication.\n   * \n   * @param {import('express').Router} router \n   */\n  async initAuthRoutes(router) {\n    // Local strategy login route (takes username and password)\n    router.post('/login', passport.authenticate('local'), async (req, res) => {\n      // return the user login response json if the login was successfull\n      res.json(await this.getUserLoginResponsePayload(req.user))\n    })\n\n    // openid strategy login route (this redirects to the configured openid login provider)\n    router.get('/auth/openid', (req, res, next) => {\n      try {\n        // helper function from openid-client\n        function pick(object, ...paths) {\n          const obj = {}\n          for (const path of paths) {\n            if (object[path] !== undefined) {\n              obj[path] = object[path]\n            }\n          }\n          return obj\n        }\n\n        // Get the OIDC client from the strategy\n        // We need to call the client manually, because the strategy does not support forwarding the code challenge\n        //    for API or mobile clients\n        const oidcStrategy = passport._strategy('openid-client')\n        const protocol = (req.secure || req.get('x-forwarded-proto') === 'https') ? 'https' : 'http'\n\n        let mobile_redirect_uri = null\n\n        // The client wishes a different redirect_uri\n        // We will allow if it is in the whitelist, by saving it into this.openIdAuthSession and setting the redirect uri to /auth/openid/mobile-redirect\n        //    where we will handle the redirect to it\n        if (req.query.redirect_uri) {\n          // Check if the redirect_uri is in the whitelist\n          if (Database.serverSettings.authOpenIDMobileRedirectURIs.includes(req.query.redirect_uri) ||\n            (Database.serverSettings.authOpenIDMobileRedirectURIs.length === 1 && Database.serverSettings.authOpenIDMobileRedirectURIs[0] === '*')) {\n            oidcStrategy._params.redirect_uri = new URL(`${protocol}://${req.get('host')}/auth/openid/mobile-redirect`).toString()\n            mobile_redirect_uri = req.query.redirect_uri\n          } else {\n            Logger.debug(`[Auth] Invalid redirect_uri=${req.query.redirect_uri} - not in whitelist`)\n            return res.status(400).send('Invalid redirect_uri')\n          }\n        } else {\n          oidcStrategy._params.redirect_uri = new URL(`${protocol}://${req.get('host')}/auth/openid/callback`).toString()\n        }\n\n        Logger.debug(`[Auth] Oidc redirect_uri=${oidcStrategy._params.redirect_uri}`)\n        const client = oidcStrategy._client\n        const sessionKey = oidcStrategy._key\n\n        let code_challenge\n        let code_challenge_method\n\n        // If code_challenge is provided, expect that code_verifier will be handled by the client (mobile app)\n        // The web frontend of ABS does not need to do a PKCE itself, because it never handles the \"code\" of the oauth flow\n        //    and as such will not send a code challenge, we will generate then one\n        if (req.query.code_challenge) {\n          code_challenge = req.query.code_challenge\n          code_challenge_method = req.query.code_challenge_method || 'S256'\n\n          if (!['S256', 'plain'].includes(code_challenge_method)) {\n            return res.status(400).send('Invalid code_challenge_method')\n          }\n        } else {\n          // If no code_challenge is provided, assume a web application flow and generate one\n          const code_verifier = OpenIDClient.generators.codeVerifier()\n          code_challenge = OpenIDClient.generators.codeChallenge(code_verifier)\n          code_challenge_method = 'S256'\n\n          // Store the code_verifier in the session for later use in the token exchange\n          req.session[sessionKey] = { ...req.session[sessionKey], code_verifier }\n        }\n\n        const params = {\n          state: OpenIDClient.generators.random(),\n          // Other params by the passport strategy\n          ...oidcStrategy._params\n        }\n\n        if (!params.nonce && params.response_type.includes('id_token')) {\n          params.nonce = OpenIDClient.generators.random()\n        }\n\n        req.session[sessionKey] = {\n          ...req.session[sessionKey],\n          ...pick(params, 'nonce', 'state', 'max_age', 'response_type'),\n          mobile: req.query.redirect_uri, // Used in the abs callback later, set mobile if redirect_uri is filled out\n          sso_redirect_uri: oidcStrategy._params.redirect_uri // Save the redirect_uri (for the SSO Provider) for the callback\n        }\n\n        // We cannot save redirect_uri in the session, because it the mobile client uses browser instead of the API\n        //   for the request to mobile-redirect and as such the session is not shared\n        this.openIdAuthSession.set(params.state, { mobile_redirect_uri: mobile_redirect_uri })\n\n        // Now get the URL to direct to\n        const authorizationUrl = client.authorizationUrl({\n          ...params,\n          scope: 'openid profile email',\n          response_type: 'code',\n          code_challenge,\n          code_challenge_method\n        })\n\n        // params (isRest, callback) to a cookie that will be send to the client\n        this.paramsToCookies(req, res)\n\n        // Redirect the user agent (browser) to the authorization URL\n        res.redirect(authorizationUrl)\n      } catch (error) {\n        Logger.error(`[Auth] Error in /auth/openid route: ${error}`)\n        res.status(500).send('Internal Server Error')\n      }\n    })\n\n    // This will be the oauth2 callback route for mobile clients\n    // It will redirect to an app-link like audiobookshelf://oauth\n    router.get('/auth/openid/mobile-redirect', (req, res) => {\n      try {\n        // Extract the state parameter from the request\n        const { state, code } = req.query\n\n        // Check if the state provided is in our list\n        if (!state || !this.openIdAuthSession.has(state)) {\n          Logger.error('[Auth] /auth/openid/mobile-redirect route: State parameter mismatch')\n          return res.status(400).send('State parameter mismatch')\n        }\n\n        let mobile_redirect_uri = this.openIdAuthSession.get(state).mobile_redirect_uri\n\n        if (!mobile_redirect_uri) {\n          Logger.error('[Auth] No redirect URI')\n          return res.status(400).send('No redirect URI')\n        }\n\n        this.openIdAuthSession.delete(state)\n\n        const redirectUri = `${mobile_redirect_uri}?code=${encodeURIComponent(code)}&state=${encodeURIComponent(state)}`\n        // Redirect to the overwrite URI saved in the map\n        res.redirect(redirectUri)\n      } catch (error) {\n        Logger.error(`[Auth] Error in /auth/openid/mobile-redirect route: ${error}`)\n        res.status(500).send('Internal Server Error')\n      }\n    })\n\n    // openid strategy callback route (this receives the token from the configured openid login provider)\n    router.get('/auth/openid/callback', (req, res, next) => {\n      const oidcStrategy = passport._strategy('openid-client')\n      const sessionKey = oidcStrategy._key\n\n      if (!req.session[sessionKey]) {\n        return res.status(400).send('No session')\n      }\n\n      // If the client sends us a code_verifier, we will tell passport to use this to send this in the token request\n      // The code_verifier will be validated by the oauth2 provider by comparing it to the code_challenge in the first request\n      // Crucial for API/Mobile clients\n      if (req.query.code_verifier) {\n        req.session[sessionKey].code_verifier = req.query.code_verifier\n      }\n\n      function handleAuthError(isMobile, errorCode, errorMessage, logMessage, response) {\n        Logger.error(logMessage)\n        if (response) {\n          // Depending on the error, it can also have a body\n          // We also log the request header the passport plugin sents for the URL\n          const header = response.req?._header.replace(/Authorization: [^\\r\\n]*/i, 'Authorization: REDACTED')\n          Logger.debug(header + '\\n' + response.body?.toString())\n        }\n\n        if (isMobile) {\n          return res.status(errorCode).send(errorMessage)\n        } else {\n          return res.redirect(`/login?error=${encodeURIComponent(errorMessage)}&autoLaunch=0`)\n        }\n      }\n\n      function passportCallback(req, res, next) {\n        return (err, user, info) => {\n          const isMobile = req.session[sessionKey]?.mobile === true\n          if (err) {\n            return handleAuthError(isMobile, 500, 'Error in callback', `[Auth] Error in openid callback - ${err}`, err?.response)\n          }\n\n          if (!user) {\n            // Info usually contains the error message from the SSO provider\n            return handleAuthError(isMobile, 401, 'Unauthorized', `[Auth] No data in openid callback - ${info}`, info?.response)\n          }\n\n          req.logIn(user, (loginError) => {\n            if (loginError) {\n              return handleAuthError(isMobile, 500, 'Error during login', `[Auth] Error in openid callback: ${loginError}`)\n            }\n            next()\n          })\n        }\n      }\n\n\n      // While not required by the standard, the passport plugin re-sends the original redirect_uri in the token request\n      // We need to set it correctly, as some SSO providers (e.g. keycloak) check that parameter when it is provided\n      // We set it here again because the passport param can change between requests\n      return passport.authenticate('openid-client', { redirect_uri: req.session[sessionKey].sso_redirect_uri }, passportCallback(req, res, next))(req, res, next)\n    },\n      // on a successfull login: read the cookies and react like the client requested (callback or json)\n      this.handleLoginSuccessBasedOnCookie.bind(this))\n\n    /**\n     * Helper route used to auto-populate the openid URLs in config/authentication\n     * Takes an issuer URL as a query param and requests the config data at \"/.well-known/openid-configuration\"\n     * \n     * @example /auth/openid/config?issuer=http://192.168.1.66:9000/application/o/audiobookshelf/\n     */\n    router.get('/auth/openid/config', this.isAuthenticated, async (req, res) => {\n      if (!req.user.isAdminOrUp) {\n        Logger.error(`[Auth] Non-admin user \"${req.user.username}\" attempted to get issuer config`)\n        return res.sendStatus(403)\n      }\n\n      if (!req.query.issuer) {\n        return res.status(400).send('Invalid request. Query param \\'issuer\\' is required')\n      }\n\n      // Strip trailing slash\n      let issuerUrl = req.query.issuer\n      if (issuerUrl.endsWith('/')) issuerUrl = issuerUrl.slice(0, -1)\n\n      // Append config pathname and validate URL\n      let configUrl = null\n      try {\n        configUrl = new URL(`${issuerUrl}/.well-known/openid-configuration`)\n        if (!configUrl.pathname.endsWith('/.well-known/openid-configuration')) {\n          throw new Error('Invalid pathname')\n        }\n      } catch (error) {\n        Logger.error(`[Auth] Failed to get openid configuration. Invalid URL \"${configUrl}\"`, error)\n        return res.status(400).send('Invalid request. Query param \\'issuer\\' is invalid')\n      }\n\n      axios.get(configUrl.toString()).then(({ data }) => {\n        res.json({\n          issuer: data.issuer,\n          authorization_endpoint: data.authorization_endpoint,\n          token_endpoint: data.token_endpoint,\n          userinfo_endpoint: data.userinfo_endpoint,\n          end_session_endpoint: data.end_session_endpoint,\n          jwks_uri: data.jwks_uri\n        })\n      }).catch((error) => {\n        Logger.error(`[Auth] Failed to get openid configuration at \"${configUrl}\"`, error)\n        res.status(error.statusCode || 400).send(`${error.code || 'UNKNOWN'}: Failed to get openid configuration`)\n      })\n    })\n\n    // Logout route\n    router.post('/logout', (req, res) => {\n      // TODO: invalidate possible JWTs\n      req.logout((err) => {\n        if (err) {\n          res.sendStatus(500)\n        } else {\n          res.sendStatus(200)\n        }\n      })\n    })\n  }\n\n  /**\n   * middleware to use in express to only allow authenticated users.\n   * @param {import('express').Request} req \n   * @param {import('express').Response} res \n   * @param {import('express').NextFunction} next  \n   */\n  isAuthenticated(req, res, next) {\n    // check if session cookie says that we are authenticated\n    if (req.isAuthenticated()) {\n      next()\n    } else {\n      // try JWT to authenticate\n      passport.authenticate(\"jwt\")(req, res, next)\n    }\n  }\n\n  /**\n   * Function to generate a jwt token for a given user\n   * \n   * @param {{ id:string, username:string }} user \n   * @returns {string} token\n   */\n  generateAccessToken(user) {\n    return jwt.sign({ userId: user.id, username: user.username }, global.ServerSettings.tokenSecret)\n  }\n\n  /**\n   * Function to validate a jwt token for a given user\n   * \n   * @param {string} token \n   * @returns {Object} tokens data\n   */\n  static validateAccessToken(token) {\n    try {\n      return jwt.verify(token, global.ServerSettings.tokenSecret)\n    }\n    catch (err) {\n      return null\n    }\n  }\n\n  /**\n   * Generate a token which is used to encrpt/protect the jwts.\n   */\n  async initTokenSecret() {\n    if (process.env.TOKEN_SECRET) { // User can supply their own token secret\n      Database.serverSettings.tokenSecret = process.env.TOKEN_SECRET\n    } else {\n      Database.serverSettings.tokenSecret = require('crypto').randomBytes(256).toString('base64')\n    }\n    await Database.updateServerSettings()\n\n    // New token secret creation added in v2.1.0 so generate new API tokens for each user\n    const users = await Database.userModel.getOldUsers()\n    if (users.length) {\n      for (const user of users) {\n        user.token = await this.generateAccessToken(user)\n      }\n      await Database.updateBulkUsers(users)\n    }\n  }\n\n  /**\n   * Checks if the user in the validated jwt_payload really exists and is active.\n   * @param {Object} jwt_payload \n   * @param {function} done \n   */\n  async jwtAuthCheck(jwt_payload, done) {\n    // load user by id from the jwt token\n    const user = await Database.userModel.getUserByIdOrOldId(jwt_payload.userId)\n\n    if (!user?.isActive) {\n      // deny login\n      done(null, null)\n      return\n    }\n    // approve login\n    done(null, user)\n    return\n  }\n\n  /**\n   * Checks if a username and password tuple is valid and the user active.\n   * @param {string} username \n   * @param {string} password \n   * @param {function} done \n   */\n  async localAuthCheckUserPw(username, password, done) {\n    // Load the user given it's username\n    const user = await Database.userModel.getUserByUsername(username.toLowerCase())\n\n    if (!user?.isActive) {\n      done(null, null)\n      return\n    }\n\n    // Check passwordless root user\n    if (user.type === 'root' && !user.pash) {\n      if (password) {\n        // deny login\n        done(null, null)\n        return\n      }\n      // approve login\n      done(null, user)\n      return\n    } else if (!user.pash) {\n      Logger.error(`[Auth] User \"${user.username}\"/\"${user.type}\" attempted to login without a password set`)\n      done(null, null)\n      return\n    }\n\n    // Check password match\n    const compare = await bcrypt.compare(password, user.pash)\n    if (compare) {\n      // approve login\n      done(null, user)\n      return\n    }\n    // deny login\n    done(null, null)\n    return\n  }\n\n  /**\n   * Hashes a password with bcrypt.\n   * @param {string} password \n   * @returns {string} hash \n   */\n  hashPass(password) {\n    return new Promise((resolve) => {\n      bcrypt.hash(password, 8, (err, hash) => {\n        if (err) {\n          resolve(null)\n        } else {\n          resolve(hash)\n        }\n      })\n    })\n  }\n\n  /**\n   * Return the login info payload for a user\n   * \n   * @param {Object} user \n   * @returns {Promise<Object>} jsonPayload\n   */\n  async getUserLoginResponsePayload(user) {\n    const libraryIds = await Database.libraryModel.getAllLibraryIds()\n    return {\n      user: user.toJSONForBrowser(),\n      userDefaultLibraryId: user.getDefaultLibraryId(libraryIds),\n      serverSettings: Database.serverSettings.toJSONForBrowser(),\n      ereaderDevices: Database.emailSettings.getEReaderDevices(user),\n      Source: global.Source\n    }\n  }\n\n  /**\n   * \n   * @param {string} password \n   * @param {*} user \n   * @returns {boolean}\n   */\n  comparePassword(password, user) {\n    if (user.type === 'root' && !password && !user.pash) return true\n    if (!password || !user.pash) return false\n    return bcrypt.compare(password, user.pash)\n  }\n\n  /**\n   * User changes their password from request\n   * \n   * @param {import('express').Request} req \n   * @param {import('express').Response} res \n   */\n  async userChangePassword(req, res) {\n    let { password, newPassword } = req.body\n    newPassword = newPassword || ''\n    const matchingUser = req.user\n\n    // Only root can have an empty password\n    if (matchingUser.type !== 'root' && !newPassword) {\n      return res.json({\n        error: 'Invalid new password - Only root can have an empty password'\n      })\n    }\n\n    // Check password match\n    const compare = await this.comparePassword(password, matchingUser)\n    if (!compare) {\n      return res.json({\n        error: 'Invalid password'\n      })\n    }\n\n    let pw = ''\n    if (newPassword) {\n      pw = await this.hashPass(newPassword)\n      if (!pw) {\n        return res.json({\n          error: 'Hash failed'\n        })\n      }\n    }\n\n    matchingUser.pash = pw\n\n    const success = await Database.updateUser(matchingUser)\n    if (success) {\n      Logger.info(`[Auth] User \"${matchingUser.username}\" changed password`)\n      res.json({\n        success: true\n      })\n    } else {\n      res.json({\n        error: 'Unknown error'\n      })\n    }\n  }\n}\n\nmodule.exports = Auth"], "filenames": ["server/Auth.js"], "buggy_code_start_loc": [299], "buggy_code_end_loc": [483], "fixing_code_start_loc": [299], "fixing_code_end_loc": [504], "type": "CWE-918", "message": "Audiobookshelf is a self-hosted audiobook and podcast server. Prior to 2.7.0, Audiobookshelf is vulnerable to unauthenticated blind server-side request (SSRF) vulnerability in Auth.js. This vulnerability has been addressed in version 2.7.0. There are no known workarounds for this vulnerability.\n\n", "other": {"cve": {"id": "CVE-2023-51665", "sourceIdentifier": "security-advisories@github.com", "published": "2023-12-27T18:15:23.267", "lastModified": "2024-01-05T15:02:21.103", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Audiobookshelf is a self-hosted audiobook and podcast server. Prior to 2.7.0, Audiobookshelf is vulnerable to unauthenticated blind server-side request (SSRF) vulnerability in Auth.js. This vulnerability has been addressed in version 2.7.0. There are no known workarounds for this vulnerability.\n\n"}, {"lang": "es", "value": "Audiobookshelf es un servidor de podcasts y audiolibros autohospedado. Antes de 2.7.0, Audiobookshelf era afectado por una vulnerabilidad de blind server-side request (SSRF) no autenticada en Auth.js. Esta vulnerabilidad se ha solucionado en la versi\u00f3n 2.7.0. No se conocen workarounds para esta vulnerabilidad."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 1.4}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-918"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:audiobookshelf:audiobookshelf:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.7.0", "matchCriteriaId": "13B62B03-BF78-4428-B064-B6186947CE61"}]}]}], "references": [{"url": "https://github.com/advplyr/audiobookshelf/commit/728496010cbfcee5b7b54001c9f79e02ede30d82", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/advplyr/audiobookshelf/security/advisories/GHSA-gjgj-98v3-47pg", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/advplyr/audiobookshelf/commit/728496010cbfcee5b7b54001c9f79e02ede30d82"}}